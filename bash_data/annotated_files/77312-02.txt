    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsISupports.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsDOMEvent.h"
    1: #include "nsEventListenerManager.h"
15969: #include "nsCaret.h"
    1: #include "nsIDOMNSEvent.h"
75046: #include "nsIDOMEventListener.h"
    1: #include "nsITextControlFrame.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsIJSEventListener.h"
    1: #include "prmem.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIScriptRuntime.h"
    1: #include "nsLayoutUtils.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIContent.h"
41930: #include "mozilla/dom/Element.h"
    1: #include "nsIFrame.h"
    1: #include "nsIView.h"
    1: #include "nsIViewManager.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsDOMError.h"
    1: #include "nsIJSContextStack.h"
    1: #include "nsIDocument.h"
    1: #include "nsIPresShell.h"
    1: #include "nsMutationEvent.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsDOMCID.h"
    1: #include "nsIScriptObjectOwner.h" // for nsIScriptEventHandlerOwner
29018: #include "nsFocusManager.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsContentUtils.h"
    1: #include "nsJSUtils.h"
    1: #include "nsContentCID.h"
    1: #include "nsEventDispatcher.h"
    1: #include "nsDOMJSUtils.h"
    1: #include "nsDOMScriptObjectHolder.h"
    1: #include "nsDataHashtable.h"
33903: #include "nsCOMArray.h"
33903: #include "nsEventListenerService.h"
33903: #include "nsDOMEvent.h"
38438: #include "nsIContentSecurityPolicy.h"
77149: #include "nsJSEnvironment.h"
    1: 
41634: using namespace mozilla::dom;
41634: 
    1: #define EVENT_TYPE_EQUALS( ls, type, userType ) \
75046:   (ls->mEventType == type && \
    1:   (ls->mEventType != NS_USER_DEFINED_EVENT || ls->mTypeAtom == userType))
    1: 
    1: static NS_DEFINE_CID(kDOMScriptObjectFactoryCID,
    1:                      NS_DOM_SCRIPT_OBJECT_FACTORY_CID);
    1: 
    1: static const PRUint32 kAllMutationBits =
    1:   NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED |
    1:   NS_EVENT_BITS_MUTATION_NODEINSERTED |
    1:   NS_EVENT_BITS_MUTATION_NODEREMOVED |
    1:   NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT |
    1:   NS_EVENT_BITS_MUTATION_NODEINSERTEDINTODOCUMENT |
    1:   NS_EVENT_BITS_MUTATION_ATTRMODIFIED |
    1:   NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED;
    1: 
    1: static PRUint32
    1: MutationBitForEventType(PRUint32 aEventType)
    1: {
    1:   switch (aEventType) {
    1:     case NS_MUTATION_SUBTREEMODIFIED:
    1:       return NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED;
    1:     case NS_MUTATION_NODEINSERTED:
    1:       return NS_EVENT_BITS_MUTATION_NODEINSERTED;
    1:     case NS_MUTATION_NODEREMOVED:
    1:       return NS_EVENT_BITS_MUTATION_NODEREMOVED;
    1:     case NS_MUTATION_NODEREMOVEDFROMDOCUMENT:
    1:       return NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT;
    1:     case NS_MUTATION_NODEINSERTEDINTODOCUMENT:
    1:       return NS_EVENT_BITS_MUTATION_NODEINSERTEDINTODOCUMENT;
    1:     case NS_MUTATION_ATTRMODIFIED:
    1:       return NS_EVENT_BITS_MUTATION_ATTRMODIFIED;
    1:     case NS_MUTATION_CHARACTERDATAMODIFIED:
    1:       return NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED;
    1:     default:
    1:       break;
    1:   }
    1:   return 0;
    1: }
    1: 
20135: PRUint32 nsEventListenerManager::sCreatedCount = 0;
    1: 
72328: nsEventListenerManager::nsEventListenerManager(nsISupports* aTarget) :
72868:   mMayHavePaintEventListener(PR_FALSE),
72868:   mMayHaveMutationListeners(PR_FALSE),
72868:   mMayHaveCapturingListeners(PR_FALSE),
72868:   mMayHaveSystemGroupListeners(PR_FALSE),
72868:   mMayHaveAudioAvailableEventListener(PR_FALSE),
72868:   mMayHaveTouchEventListener(PR_FALSE),
72868:   mNoListenerForEvent(0),
72328:   mTarget(aTarget)
    1: {
72328:   NS_ASSERTION(aTarget, "unexpected null pointer");
72328: 
20135:   ++sCreatedCount;
    1: }
    1: 
    1: nsEventListenerManager::~nsEventListenerManager() 
    1: {
63952:   // If your code fails this assertion, a possible reason is that
63952:   // a class did not call our Disconnect() manually. Note that
63952:   // this class can have Disconnect called in one of two ways:
63952:   // if it is part of a cycle, then in Unlink() (such a cycle
63952:   // would be with one of the listeners, not mTarget which is weak).
63952:   // If not part of a cycle, then Disconnect must be called manually,
63952:   // typically from the destructor of the owner class (mTarget).
63952:   // XXX azakai: Is there any reason to not just call Disconnect
63952:   //             from right here, if not previously called?
    1:   NS_ASSERTION(!mTarget, "didn't call Disconnect");
    1:   RemoveAllListeners();
    1: 
    1: }
    1: 
72329: void
    1: nsEventListenerManager::RemoveAllListeners()
    1: {
    1:   mListeners.Clear();
    1: }
    1: 
    1: void
    1: nsEventListenerManager::Shutdown()
    1: {
    1:   nsDOMEvent::Shutdown();
    1: }
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsEventListenerManager)
    1: 
72328: NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(nsEventListenerManager, AddRef)
72328: NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE(nsEventListenerManager, Release)
    1: 
72328: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_BEGIN(nsEventListenerManager)
11295:   PRUint32 count = tmp->mListeners.Length();
11295:   for (PRUint32 i = 0; i < count; i++) {
18993:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mListeners[i] mListener");
11295:     cb.NoteXPCOMChild(tmp->mListeners.ElementAt(i).mListener.get());
    1:   }  
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
72328: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_NATIVE(nsEventListenerManager)
    1:   tmp->Disconnect();
    1: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
    1: 
    1: 
20515: nsPIDOMWindow*
20515: nsEventListenerManager::GetInnerWindowForTarget()
20515: {
20515:   nsCOMPtr<nsINode> node = do_QueryInterface(mTarget);
20515:   if (node) {
20515:     // XXX sXBL/XBL2 issue -- do we really want the owner here?  What
20515:     // if that's the XBL document?
20515:     nsIDocument* document = node->GetOwnerDoc();
20515:     if (document)
20515:       return document->GetInnerWindow();
20515:   }
20515: 
20515:   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(mTarget);
20515:   if (window) {
20515:     NS_ASSERTION(window->IsInnerWindow(), "Target should not be an outer window");
20515:     return window;
20515:   }
20515: 
20515:   return nsnull;
20515: }
20515: 
76793: void
    1: nsEventListenerManager::AddEventListener(nsIDOMEventListener *aListener,
    1:                                          PRUint32 aType,
    1:                                          nsIAtom* aTypeAtom,
72331:                                          PRInt32 aFlags)
    1: {
76793:   NS_ABORT_IF_FALSE(aType && aTypeAtom, "Missing type");
76793: 
76793:   if (!aListener) {
76793:     return;
76793:   }
    1: 
    1:   nsRefPtr<nsIDOMEventListener> kungFuDeathGrip = aListener;
    1: 
11295:   nsListenerStruct* ls;
11295:   PRUint32 count = mListeners.Length();
11295:   for (PRUint32 i = 0; i < count; i++) {
11295:     ls = &mListeners.ElementAt(i);
    1:     if (ls->mListener == aListener && ls->mFlags == aFlags &&
75046:         EVENT_TYPE_EQUALS(ls, aType, aTypeAtom)) {
76793:       return;
    1:     }
    1:   }
    1: 
    1:   mNoListenerForEvent = NS_EVENT_TYPE_NULL;
    1:   mNoListenerForEventAtom = nsnull;
    1: 
11295:   ls = mListeners.AppendElement();
    1:   ls->mListener = aListener;
    1:   ls->mEventType = aType;
    1:   ls->mTypeAtom = aTypeAtom;
    1:   ls->mFlags = aFlags;
    1:   ls->mHandlerIsString = PR_FALSE;
72330: 
72330:   if (aFlags & NS_EVENT_FLAG_SYSTEM_EVENT) {
72330:     mMayHaveSystemGroupListeners = PR_TRUE;
72330:   }
34158:   if (aFlags & NS_EVENT_FLAG_CAPTURE) {
34158:     mMayHaveCapturingListeners = PR_TRUE;
34158:   }
    1: 
20515:   if (aType == NS_AFTERPAINT) {
20515:     mMayHavePaintEventListener = PR_TRUE;
20515:     nsPIDOMWindow* window = GetInnerWindowForTarget();
20515:     if (window) {
20516:       window->SetHasPaintEventListeners();
20515:     }
57500: #ifdef MOZ_MEDIA
51477:   } else if (aType == NS_MOZAUDIOAVAILABLE) {
51477:     mMayHaveAudioAvailableEventListener = PR_TRUE;
51477:     nsPIDOMWindow* window = GetInnerWindowForTarget();
51477:     if (window) {
51477:       window->SetHasAudioAvailableEventListeners();
51477:     }
57500: #endif // MOZ_MEDIA
20515:   } else if (aType >= NS_MUTATION_START && aType <= NS_MUTATION_END) {
    1:     // For mutation listeners, we need to update the global bit on the DOM window.
    1:     // Otherwise we won't actually fire the mutation event.
    1:     mMayHaveMutationListeners = PR_TRUE;
    1:     // Go from our target to the nearest enclosing DOM window.
20515:     nsPIDOMWindow* window = GetInnerWindowForTarget();
    1:     if (window) {
   62:       // If aType is NS_MUTATION_SUBTREEMODIFIED, we need to listen all
14239:       // mutations. nsContentUtils::HasMutationListeners relies on this.
   62:       window->SetMutationListeners((aType == NS_MUTATION_SUBTREEMODIFIED) ?
   62:                                    kAllMutationBits :
   62:                                    MutationBitForEventType(aType));
    1:     }
72018:   } else if (aTypeAtom == nsGkAtoms::ondeviceorientation ||
72018:              aTypeAtom == nsGkAtoms::ondevicemotion) {
31738:     nsPIDOMWindow* window = GetInnerWindowForTarget();
31738:     if (window)
31738:       window->SetHasOrientationEventListener();
68880:   } else if ((aType >= NS_MOZTOUCH_DOWN && aType <= NS_MOZTOUCH_UP) ||
68880:              (aTypeAtom == nsGkAtoms::ontouchstart ||
68880:               aTypeAtom == nsGkAtoms::ontouchend ||
68880:               aTypeAtom == nsGkAtoms::ontouchmove ||
68880:               aTypeAtom == nsGkAtoms::ontouchenter ||
68880:               aTypeAtom == nsGkAtoms::ontouchleave ||
68880:               aTypeAtom == nsGkAtoms::ontouchcancel)) {
68880:     mMayHaveTouchEventListener = PR_TRUE;
48711:     nsPIDOMWindow* window = GetInnerWindowForTarget();
48711:     if (window)
48711:       window->SetHasTouchEventListeners();
    1:   }
    1: }
    1: 
72329: void
    1: nsEventListenerManager::RemoveEventListener(nsIDOMEventListener *aListener, 
    1:                                             PRUint32 aType,
    1:                                             nsIAtom* aUserType,
72331:                                             PRInt32 aFlags)
    1: {
75046:   if (!aListener || !aType) {
72329:     return;
    1:   }
    1: 
11295:   nsListenerStruct* ls;
    1:   aFlags &= ~NS_PRIV_EVENT_UNTRUSTED_PERMITTED;
    1: 
11295:   PRUint32 count = mListeners.Length();
11295:   for (PRUint32 i = 0; i < count; ++i) {
11295:     ls = &mListeners.ElementAt(i);
    1:     if (ls->mListener == aListener &&
    1:         ((ls->mFlags & ~NS_PRIV_EVENT_UNTRUSTED_PERMITTED) == aFlags) &&
75046:         EVENT_TYPE_EQUALS(ls, aType, aUserType)) {
29474:       nsRefPtr<nsEventListenerManager> kungFuDeathGrip = this;
 9536:       mListeners.RemoveElementAt(i);
    1:       mNoListenerForEvent = NS_EVENT_TYPE_NULL;
    1:       mNoListenerForEventAtom = nsnull;
    1:       break;
    1:     }
    1:   }
    1: }
    1: 
75046: static inline PRBool
75046: ListenerCanHandle(nsListenerStruct* aLs, nsEvent* aEvent)
    1: {
75046:   // This is slightly different from EVENT_TYPE_EQUALS in that it returns
75046:   // true even when aEvent->message == NS_USER_DEFINED_EVENT and
75046:   // aLs=>mEventType != NS_USER_DEFINED_EVENT as long as the atoms are the same
75046:   return aEvent->message == NS_USER_DEFINED_EVENT ?
75046:     (aLs->mTypeAtom == aEvent->userType) :
75046:     (aLs->mEventType == aEvent->message);
    1: }
    1: 
76793: void
    1: nsEventListenerManager::AddEventListenerByType(nsIDOMEventListener *aListener, 
    1:                                                const nsAString& aType,
72331:                                                PRInt32 aFlags)
    1: {
    1:   nsCOMPtr<nsIAtom> atom = do_GetAtom(NS_LITERAL_STRING("on") + aType);
  265:   PRUint32 type = nsContentUtils::GetEventId(atom);
76793:   AddEventListener(aListener, type, atom, aFlags);
    1: }
    1: 
72329: void
    1: nsEventListenerManager::RemoveEventListenerByType(nsIDOMEventListener *aListener, 
    1:                                                   const nsAString& aType,
72331:                                                   PRInt32 aFlags)
    1: {
    1:   nsCOMPtr<nsIAtom> atom = do_GetAtom(NS_LITERAL_STRING("on") + aType);
  265:   PRUint32 type = nsContentUtils::GetEventId(atom);
75046:   RemoveEventListener(aListener, type, atom, aFlags);
    1: }
    1: 
    1: nsListenerStruct*
    1: nsEventListenerManager::FindJSEventListener(PRUint32 aEventType,
    1:                                             nsIAtom* aTypeAtom)
    1: {
    1:   // Run through the listeners for this type and see if a script
    1:   // listener is registered
    1:   nsListenerStruct *ls;
11295:   PRUint32 count = mListeners.Length();
11295:   for (PRUint32 i = 0; i < count; ++i) {
11295:     ls = &mListeners.ElementAt(i);
    1:     if (EVENT_TYPE_EQUALS(ls, aEventType, aTypeAtom) &&
    1:         ls->mFlags & NS_PRIV_EVENT_FLAG_SCRIPT) {
    1:       return ls;
    1:     }
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: nsresult
    1: nsEventListenerManager::SetJSEventListener(nsIScriptContext *aContext,
    1:                                            void *aScopeObject,
    1:                                            nsIAtom* aName,
77149:                                            JSObject *aHandler,
77149:                                            PRBool aPermitUntrustedEvents,
77149:                                            nsListenerStruct **aListenerStruct)
    1: {
    1:   nsresult rv = NS_OK;
  265:   PRUint32 eventType = nsContentUtils::GetEventId(aName);
    1:   nsListenerStruct* ls = FindJSEventListener(eventType, aName);
    1: 
    1:   if (!ls) {
    1:     // If we didn't find a script listener or no listeners existed
    1:     // create and add a new one.
    1:     nsCOMPtr<nsIDOMEventListener> scriptListener;
74595:     rv = NS_NewJSEventListener(aContext, aScopeObject, mTarget, aName,
77149:                                aHandler, getter_AddRefs(scriptListener));
    1:     if (NS_SUCCEEDED(rv)) {
75046:       AddEventListener(scriptListener, eventType, aName,
72331:                        NS_EVENT_FLAG_BUBBLE | NS_PRIV_EVENT_FLAG_SCRIPT);
    1: 
    1:       ls = FindJSEventListener(eventType, aName);
    1:     }
77149:   } else {
77149:     ls->GetJSListener()->SetHandler(aHandler);
    1:   }
    1: 
    1:   if (NS_SUCCEEDED(rv) && ls) {
    1:     // Set flag to indicate possible need for compilation later
77149:     ls->mHandlerIsString = !aHandler;
    1:     if (aPermitUntrustedEvents) {
    1:       ls->mFlags |= NS_PRIV_EVENT_UNTRUSTED_PERMITTED;
    1:     }
77149: 
77149:     *aListenerStruct = ls;
77149:   } else {
77149:     *aListenerStruct = nsnull;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
72329: nsresult
74595: nsEventListenerManager::AddScriptEventListener(nsIAtom *aName,
    1:                                                const nsAString& aBody,
    1:                                                PRUint32 aLanguage,
    1:                                                PRBool aDeferCompilation,
    1:                                                PRBool aPermitUntrustedEvents)
    1: {
    1:   NS_PRECONDITION(aLanguage != nsIProgrammingLanguage::UNKNOWN,
    1:                   "Must know the language for the script event listener");
    1:   nsIScriptContext *context = nsnull;
    1: 
    1:   // |aPermitUntrustedEvents| is set to False for chrome - events
    1:   // *generated* from an unknown source are not allowed.
    1:   // However, for script languages with no 'sandbox', we want to reject
    1:   // such scripts based on the source of their code, not just the source
    1:   // of the event.
    1:   if (aPermitUntrustedEvents && 
    1:       aLanguage != nsIProgrammingLanguage::JAVASCRIPT) {
    1:     NS_WARNING("Discarding non-JS event listener from untrusted source");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
74595:   nsCOMPtr<nsINode> node(do_QueryInterface(mTarget));
    1: 
    1:   nsCOMPtr<nsIDocument> doc;
    1: 
    1:   nsCOMPtr<nsIScriptGlobalObject> global;
    1: 
    1:   if (node) {
    1:     // Try to get context from doc
  199:     // XXX sXBL/XBL2 issue -- do we really want the owner here?  What
  199:     // if that's the XBL document?
    1:     doc = node->GetOwnerDoc();
    1:     if (doc)
    1:       global = doc->GetScriptGlobalObject();
    1:   } else {
74595:     nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(mTarget));
    1:     if (win) {
    1:       NS_ASSERTION(win->IsInnerWindow(),
    1:                    "Event listener added to outer window!");
    1: 
    1:       nsCOMPtr<nsIDOMDocument> domdoc;
    1:       win->GetDocument(getter_AddRefs(domdoc));
    1:       doc = do_QueryInterface(domdoc);
    1:       global = do_QueryInterface(win);
    1:     } else {
74595:       global = do_QueryInterface(mTarget);
    1:     }
  199:   }
  199: 
  970:   if (!global) {
  970:     // This can happen; for example this document might have been
  970:     // loaded as data.
  970:     return NS_OK;
  970:   }
  970: 
68468:   nsresult rv = NS_OK;
38438:   // return early preventing the event listener from being added
38438:   // 'doc' is fetched above
38438:   if (doc) {
38438:     nsCOMPtr<nsIContentSecurityPolicy> csp;
38438:     rv = doc->NodePrincipal()->GetCsp(getter_AddRefs(csp));
38438:     NS_ENSURE_SUCCESS(rv, rv);
38438: 
38438:     if (csp) {
38438:       PRBool inlineOK;
38438:       rv = csp->GetAllowsInlineScript(&inlineOK);
38438:       NS_ENSURE_SUCCESS(rv, rv);
38438: 
38438:       if ( !inlineOK ) {
61654:         // gather information to log with violation report
61654:         nsIURI* uri = doc->GetDocumentURI();
61654:         nsCAutoString asciiSpec;
61654:         if (uri)
61654:           uri->GetAsciiSpec(asciiSpec);
61654:         nsAutoString scriptSample, attr, tagName(NS_LITERAL_STRING("UNKNOWN"));
61654:         aName->ToString(attr);
74595:         nsCOMPtr<nsIDOMNode> domNode(do_QueryInterface(mTarget));
61654:         if (domNode)
61654:           domNode->GetNodeName(tagName);
61654:         // build a "script sample" based on what we know about this element
61654:         scriptSample.Assign(attr);
61654:         scriptSample.AppendLiteral(" attribute on ");
61654:         scriptSample.Append(tagName);
61654:         scriptSample.AppendLiteral(" element");
61654:         csp->LogViolationDetails(nsIContentSecurityPolicy::VIOLATION_TYPE_INLINE_SCRIPT,
61654:                                  NS_ConvertUTF8toUTF16(asciiSpec),
61654:                                  scriptSample,
61654:                                  nsnull);
38438:         return NS_OK;
38438:       }
38438:     }
38438:   }
38438: 
  199:   // This might be the first reference to this language in the global
  199:   // We must init the language before we attempt to fetch its context.
    1:   if (NS_FAILED(global->EnsureScriptEnvironment(aLanguage))) {
    1:     NS_WARNING("Failed to setup script environment for this language");
    1:     // but fall through and let the inevitable failure below handle it.
    1:   }
  199: 
    1:   context = global->GetScriptContext(aLanguage);
    1:   NS_ENSURE_TRUE(context, NS_ERROR_FAILURE);
    1: 
    1:   void *scope = global->GetScriptGlobal(aLanguage);
    1: 
77149:   nsListenerStruct *ls;
77149:   rv = SetJSEventListener(context, scope, aName, nsnull,
77149:                           aPermitUntrustedEvents, &ls);
77149:   NS_ENSURE_SUCCESS(rv, rv);
77149: 
    1:   if (!aDeferCompilation) {
77149:     return CompileEventHandlerInternal(ls, PR_TRUE, &aBody);
    1:   }
    1: 
77149:   return NS_OK;
    1: }
    1: 
72329: void
    1: nsEventListenerManager::RemoveScriptEventListener(nsIAtom* aName)
    1: {
  265:   PRUint32 eventType = nsContentUtils::GetEventId(aName);
    1:   nsListenerStruct* ls = FindJSEventListener(eventType, aName);
    1: 
    1:   if (ls) {
11295:     mListeners.RemoveElementAt(PRUint32(ls - &mListeners.ElementAt(0)));
    1:     mNoListenerForEvent = NS_EVENT_TYPE_NULL;
    1:     mNoListenerForEventAtom = nsnull;
    1:   }
    1: }
    1: 
77149: nsresult
77149: nsEventListenerManager::CompileEventHandlerInternal(nsListenerStruct *aListenerStruct,
77149:                                                     PRBool aNeedsCxPush,
77149:                                                     const nsAString* aBody)
77149: {
77149:   NS_PRECONDITION(aListenerStruct->GetJSListener(),
77149:                   "Why do we not have a JS listener?");
77149:   NS_PRECONDITION(aListenerStruct->mHandlerIsString,
77149:                   "Why are we compiling a non-string JS listener?");
    1: 
    1:   nsresult result = NS_OK;
    1: 
77149:   nsIJSEventListener *listener = aListenerStruct->GetJSListener();
77149:   NS_ASSERTION(!listener->GetHandler(), "What is there to compile?");
77149: 
77149:   nsIScriptContext *context = listener->GetEventContext();
    1:   nsCOMPtr<nsIScriptEventHandlerOwner> handlerOwner =
77149:     do_QueryInterface(mTarget);
77149:   nsScriptObjectHolder handler(context);
    1: 
    1:   if (handlerOwner) {
77149:     result = handlerOwner->GetCompiledEventHandler(aListenerStruct->mTypeAtom,
    1:                                                    handler);
    1:     if (NS_SUCCEEDED(result) && handler) {
    1:       aListenerStruct->mHandlerIsString = PR_FALSE;
77149:     } else {
77149:       // Make sure there's nothing in the holder in the failure case
77149:       handler.set(nsnull);
    1:     }
    1:   }
    1: 
    1:   if (aListenerStruct->mHandlerIsString) {
77149:     // OK, we didn't find an existing compiled event handler.  Flag us
77149:     // as not a string so we don't keep trying to compile strings
77149:     // which can't be compiled
77149:     aListenerStruct->mHandlerIsString = PR_FALSE;
77149: 
77149:     // mTarget may not be an nsIContent if it's a window and we're
77149:     // getting an inline event listener forwarded from <html:body> or
77149:     // <html:frameset> or <xul:window> or the like.
77149:     // XXX I don't like that we have to reference content from
77149:     // here. The alternative is to store the event handler string on
77149:     // the nsIJSEventListener itself, and that still doesn't address
77149:     // the arg names issue.
77149:     nsCOMPtr<nsIContent> content = do_QueryInterface(mTarget);
    1:     nsAutoString handlerBody;
77149:     const nsAString* body = aBody;
77149:     if (content && !aBody) {
77149:       nsIAtom* attrName = aListenerStruct->mTypeAtom;
77149:       if (aListenerStruct->mTypeAtom == nsGkAtoms::onSVGLoad)
    1:         attrName = nsGkAtoms::onload;
77149:       else if (aListenerStruct->mTypeAtom == nsGkAtoms::onSVGUnload)
    1:         attrName = nsGkAtoms::onunload;
77149:       else if (aListenerStruct->mTypeAtom == nsGkAtoms::onSVGAbort)
    1:         attrName = nsGkAtoms::onabort;
77149:       else if (aListenerStruct->mTypeAtom == nsGkAtoms::onSVGError)
    1:         attrName = nsGkAtoms::onerror;
77149:       else if (aListenerStruct->mTypeAtom == nsGkAtoms::onSVGResize)
    1:         attrName = nsGkAtoms::onresize;
77149:       else if (aListenerStruct->mTypeAtom == nsGkAtoms::onSVGScroll)
    1:         attrName = nsGkAtoms::onscroll;
77149:       else if (aListenerStruct->mTypeAtom == nsGkAtoms::onSVGZoom)
    1:         attrName = nsGkAtoms::onzoom;
48450: #ifdef MOZ_SMIL
77149:       else if (aListenerStruct->mTypeAtom == nsGkAtoms::onbeginEvent)
48450:         attrName = nsGkAtoms::onbegin;
77149:       else if (aListenerStruct->mTypeAtom == nsGkAtoms::onrepeatEvent)
48450:         attrName = nsGkAtoms::onrepeat;
77149:       else if (aListenerStruct->mTypeAtom == nsGkAtoms::onendEvent)
48450:         attrName = nsGkAtoms::onend;
48450: #endif // MOZ_SMIL
    1: 
    1:       content->GetAttr(kNameSpaceID_None, attrName, handlerBody);
77149:       body = &handlerBody;
77149:     }
    1: 
    1:     PRUint32 lineNo = 0;
77149:     nsCAutoString url (NS_LITERAL_CSTRING("-moz-evil:lying-event-listener"));
77149:     nsCOMPtr<nsIDocument> doc;
77149:     if (content) {
77149:       doc = content->GetOwnerDoc();
77149:     } else {
77149:       nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(mTarget);
77149:       if (win) {
77149:         doc = do_QueryInterface(win->GetExtantDocument());
    1:       }
77149:     }
77149: 
    1:     if (doc) {
    1:       nsIURI *uri = doc->GetDocumentURI();
    1:       if (uri) {
    1:         uri->GetSpec(url);
    1:         lineNo = 1;
    1:       }
    1:     }
    1: 
26165:     nsCxPusher pusher;
34158:     if (aNeedsCxPush &&
77149:         !pusher.Push((JSContext*)context->GetNativeContext())) {
26165:       return NS_ERROR_FAILURE;
26165:     }
26165: 
26165: 
    1:     if (handlerOwner) {
    1:       // Always let the handler owner compile the event
    1:       // handler, as it may want to use a special
    1:       // context or scope object.
77149:       result = handlerOwner->CompileEventHandler(context,
77149:                                                  aListenerStruct->mTypeAtom,
77149:                                                  *body,
    1:                                                  url.get(), lineNo,
    1:                                                  handler);
77149:     } else {
    1:       PRUint32 argCount;
    1:       const char **argNames;
77149:       // If no content, then just use kNameSpaceID_None for the
77149:       // namespace ID.  In practice, it doesn't matter since SVG is
77149:       // the only thing with weird arg names and SVG doesn't map event
77149:       // listeners to the window.
77149:       nsContentUtils::GetEventArgNames(content ?
77149:                                          content->GetNameSpaceID() :
77149:                                          kNameSpaceID_None,
77149:                                        aListenerStruct->mTypeAtom,
    1:                                        &argCount, &argNames);
    1: 
77149:       result = context->CompileEventHandler(aListenerStruct->mTypeAtom,
    1:                                             argCount, argNames,
77149:                                             *body,
    1:                                             url.get(), lineNo,
11775:                                             SCRIPTVERSION_DEFAULT, // for now?
    1:                                             handler);
77149:       if (result == NS_ERROR_ILLEGAL_VALUE) {
77149:         NS_WARNING("Probably a syntax error in the event handler!");
77149:         return NS_SUCCESS_LOSS_OF_INSIGNIFICANT_DATA;
77149:       }
    1:       NS_ENSURE_SUCCESS(result, result);
    1:     }
77149:   }
    1: 
77149:   if (handler) {
77149:     // Bind it
77149:     nsScriptObjectHolder boundHandler(context);
77149:     context->BindCompiledEventHandler(mTarget, listener->GetEventScope(),
77149:                                       handler, boundHandler);
77149:     listener->SetHandler(boundHandler);
    1:   }    
    1: 
    1:   return result;
    1: }
    1: 
    1: nsresult
    1: nsEventListenerManager::HandleEventSubType(nsListenerStruct* aListenerStruct,
    1:                                            nsIDOMEventListener* aListener,
    1:                                            nsIDOMEvent* aDOMEvent,
72326:                                            nsIDOMEventTarget* aCurrentTarget,
34158:                                            PRUint32 aPhaseFlags,
34158:                                            nsCxPusher* aPusher)
    1: {
    1:   nsresult result = NS_OK;
    1: 
    1:   // If this is a script handler and we haven't yet
    1:   // compiled the event handler itself
    1:   if ((aListenerStruct->mFlags & NS_PRIV_EVENT_FLAG_SCRIPT) &&
    1:       aListenerStruct->mHandlerIsString) {
77149:     nsIJSEventListener *jslistener = aListenerStruct->GetJSListener();
77149:     result = CompileEventHandlerInternal(aListenerStruct,
34158:                                          jslistener->GetEventContext() !=
77149:                                            aPusher->GetCurrentScriptContext(),
77149:                                          nsnull);
    1:   }
    1: 
28325:   if (NS_SUCCEEDED(result)) {
    1:     // nsIDOMEvent::currentTarget is set in nsEventDispatcher.
    1:     result = aListener->HandleEvent(aDOMEvent);
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: /**
    1: * Causes a check for event listeners and processing by them if they exist.
    1: * @param an event listener
    1: */
    1: 
72329: void
40924: nsEventListenerManager::HandleEventInternal(nsPresContext* aPresContext,
40924:                                             nsEvent* aEvent,
40924:                                             nsIDOMEvent** aDOMEvent,
72326:                                             nsIDOMEventTarget* aCurrentTarget,
    1:                                             PRUint32 aFlags,
34158:                                             nsEventStatus* aEventStatus,
34158:                                             nsCxPusher* aPusher)
    1: {
    1:   //Set the value of the internal PreventDefault flag properly based on aEventStatus
    1:   if (*aEventStatus == nsEventStatus_eConsumeNoDefault) {
    1:     aEvent->flags |= NS_EVENT_FLAG_NO_DEFAULT;
    1:   }
    1: 
11295:   nsAutoTObserverArray<nsListenerStruct, 2>::EndLimitedIterator iter(mListeners);
    1:   nsAutoPopupStatePusher popupStatePusher(nsDOMEvent::GetEventPopupControlState(aEvent));
    1:   PRBool hasListener = PR_FALSE;
 9536:   while (iter.HasMore()) {
11295:     nsListenerStruct* ls = &iter.GetNext();
    1:     // Check that the phase is same in event and event listener.
    1:     // Handle only trusted events, except when listener permits untrusted events.
75046:     if (ListenerCanHandle(ls, aEvent)) {
    1:       hasListener = PR_TRUE;
72330:       // XXX The (mFlags & aFlags) test here seems fragile. Shouldn't we
72330:       // specifically only test the capture/bubble flags.
72330:       if ((ls->mFlags & aFlags & ~NS_EVENT_FLAG_SYSTEM_EVENT) &&
72330:           (ls->mFlags & NS_EVENT_FLAG_SYSTEM_EVENT) ==
72330:           (aFlags & NS_EVENT_FLAG_SYSTEM_EVENT) &&
    1:           (NS_IS_TRUSTED_EVENT(aEvent) ||
    1:            ls->mFlags & NS_PRIV_EVENT_UNTRUSTED_PERMITTED)) {
    1:         if (!*aDOMEvent) {
    1:           nsEventDispatcher::CreateEvent(aPresContext, aEvent,
    1:                                          EmptyString(), aDOMEvent);
    1:         }
    1:         if (*aDOMEvent) {
29233:           if (!aEvent->currentTarget) {
29233:             aEvent->currentTarget = aCurrentTarget->GetTargetForDOMEvent();
29233:             if (!aEvent->currentTarget) {
29233:               break;
29233:             }
29233:           }
16206:           nsRefPtr<nsIDOMEventListener> kungFuDeathGrip = ls->mListener;
75046:           if (aPusher->RePush(aCurrentTarget)) {
59263:             if (NS_FAILED(HandleEventSubType(ls, ls->mListener, *aDOMEvent,
59263:                                              aCurrentTarget, aFlags,
59263:                                              aPusher))) {
59263:               aEvent->flags |= NS_EVENT_FLAG_EXCEPTION_THROWN;
59263:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
29233:   aEvent->currentTarget = nsnull;
29233: 
    1:   if (!hasListener) {
    1:     mNoListenerForEvent = aEvent->message;
    1:     mNoListenerForEventAtom = aEvent->userType;
    1:   }
    1: 
    1:   if (aEvent->flags & NS_EVENT_FLAG_NO_DEFAULT) {
    1:     *aEventStatus = nsEventStatus_eConsumeNoDefault;
    1:   }
    1: }
    1: 
72329: void
    1: nsEventListenerManager::Disconnect()
    1: {
    1:   mTarget = nsnull;
72329:   RemoveAllListeners();
    1: }
    1: 
76793: void
72329: nsEventListenerManager::AddEventListener(const nsAString& aType,
72329:                                          nsIDOMEventListener* aListener,
72329:                                          PRBool aUseCapture,
72329:                                          PRBool aWantsUntrusted)
72329: {
72329:   PRInt32 flags = aUseCapture ? NS_EVENT_FLAG_CAPTURE : NS_EVENT_FLAG_BUBBLE;
72329: 
72329:   if (aWantsUntrusted) {
72329:     flags |= NS_PRIV_EVENT_UNTRUSTED_PERMITTED;
72329:   }
72329: 
72331:   return AddEventListenerByType(aListener, aType, flags);
72329: }
72329: 
72329: void
    1: nsEventListenerManager::RemoveEventListener(const nsAString& aType, 
    1:                                             nsIDOMEventListener* aListener, 
    1:                                             PRBool aUseCapture)
    1: {
    1:   PRInt32 flags = aUseCapture ? NS_EVENT_FLAG_CAPTURE : NS_EVENT_FLAG_BUBBLE;
    1:   
72331:   RemoveEventListenerByType(aListener, aType, flags);
    1: }
    1: 
72329: PRBool
72329: nsEventListenerManager::HasMutationListeners()
    1: {
    1:   if (mMayHaveMutationListeners) {
11295:     PRUint32 count = mListeners.Length();
11295:     for (PRUint32 i = 0; i < count; ++i) {
11295:       nsListenerStruct* ls = &mListeners.ElementAt(i);
 9031:       if (ls->mEventType >= NS_MUTATION_START &&
    1:           ls->mEventType <= NS_MUTATION_END) {
72329:         return PR_TRUE;
    1:       }
    1:     }
    1:   }
    1: 
72329:   return PR_FALSE;
    1: }
    1: 
    1: PRUint32
    1: nsEventListenerManager::MutationListenerBits()
    1: {
    1:   PRUint32 bits = 0;
    1:   if (mMayHaveMutationListeners) {
11295:     PRUint32 count = mListeners.Length();
11295:     for (PRUint32 i = 0; i < count; ++i) {
11295:       nsListenerStruct* ls = &mListeners.ElementAt(i);
 9031:       if (ls->mEventType >= NS_MUTATION_START &&
 9031:           ls->mEventType <= NS_MUTATION_END) {
   62:         if (ls->mEventType == NS_MUTATION_SUBTREEMODIFIED) {
   62:           return kAllMutationBits;
   62:         }
    1:         bits |= MutationBitForEventType(ls->mEventType);
    1:       }
    1:     }
    1:   }
    1:   return bits;
    1: }
    1: 
    1: PRBool
 1292: nsEventListenerManager::HasListenersFor(const nsAString& aEventName)
 1292: {
 1292:   nsCOMPtr<nsIAtom> atom = do_GetAtom(NS_LITERAL_STRING("on") + aEventName);
 1292: 
11295:   PRUint32 count = mListeners.Length();
11295:   for (PRUint32 i = 0; i < count; ++i) {
11295:     nsListenerStruct* ls = &mListeners.ElementAt(i);
75046:     if (ls->mTypeAtom == atom) {
 1292:       return PR_TRUE;
 1292:     }
 1292:   }
 1292:   return PR_FALSE;
 1292: }
 1292: 
 1292: PRBool
19953: nsEventListenerManager::HasListeners()
19953: {
19953:   return !mListeners.IsEmpty();
19953: }
19953: 
33903: nsresult
33903: nsEventListenerManager::GetListenerInfo(nsCOMArray<nsIEventListenerInfo>* aList)
33903: {
72326:   nsCOMPtr<nsIDOMEventTarget> target = do_QueryInterface(mTarget);
33903:   NS_ENSURE_STATE(target);
33903:   aList->Clear();
33903:   PRUint32 count = mListeners.Length();
33903:   for (PRUint32 i = 0; i < count; ++i) {
33903:     const nsListenerStruct& ls = mListeners.ElementAt(i);
33903:     PRBool capturing = !!(ls.mFlags & NS_EVENT_FLAG_CAPTURE);
72330:     PRBool systemGroup = !!(ls.mFlags & NS_EVENT_FLAG_SYSTEM_EVENT);
33903:     PRBool allowsUntrusted = !!(ls.mFlags & NS_PRIV_EVENT_UNTRUSTED_PERMITTED);
33903:     // If this is a script handler and we haven't yet
77149:     // compiled the event handler itself go ahead and compile it
33903:     if ((ls.mFlags & NS_PRIV_EVENT_FLAG_SCRIPT) && ls.mHandlerIsString) {
77149:       CompileEventHandlerInternal(const_cast<nsListenerStruct*>(&ls),
77149:                                   PR_TRUE, nsnull);
33903:     }
33903:     const nsDependentSubstring& eventType =
39101:       Substring(nsDependentAtomString(ls.mTypeAtom), 2);
33903:     nsRefPtr<nsEventListenerInfo> info =
33903:       new nsEventListenerInfo(eventType, ls.mListener, capturing,
33903:                               allowsUntrusted, systemGroup);
33903:     NS_ENSURE_TRUE(info, NS_ERROR_OUT_OF_MEMORY);
33903:     aList->AppendObject(info);
33903:   }
33903:   return NS_OK;
33903: }
33903: 
19953: PRBool
    1: nsEventListenerManager::HasUnloadListeners()
    1: {
11295:   PRUint32 count = mListeners.Length();
11295:   for (PRUint32 i = 0; i < count; ++i) {
11295:     nsListenerStruct* ls = &mListeners.ElementAt(i);
 9031:     if (ls->mEventType == NS_PAGE_UNLOAD ||
75045:         ls->mEventType == NS_BEFORE_PAGE_UNLOAD) {
    1:       return PR_TRUE;
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
77149: 
77149: nsresult
77149: nsEventListenerManager::SetJSEventListenerToJsval(nsIAtom *aEventName,
77149:                                                   JSContext *cx,
77149:                                                   JSObject* aScope,
77149:                                                   const jsval & v)
77149: {
77149:   JSObject *handler;
77149:   if (JSVAL_IS_PRIMITIVE(v) ||
77149:       !JS_ObjectIsCallable(cx, handler = JSVAL_TO_OBJECT(v))) {
77149:     RemoveScriptEventListener(aEventName);
77149:     return NS_OK;
77149:   }
77149: 
77312:   // We might not have a script context, e.g. if we're setting a listener
77312:   // on a dead Window.
77149:   nsIScriptContext *context = nsJSUtils::GetStaticScriptContext(cx, aScope);
77312:   NS_ENSURE_TRUE(context, NS_ERROR_FAILURE);
77312: 
77149:   JSObject *scope = ::JS_GetGlobalForObject(cx, aScope);
77149:   // Untrusted events are always permitted for non-chrome script
77149:   // handlers.
77149:   nsListenerStruct *ignored;
77149:   return SetJSEventListener(context, scope, aEventName, handler,
77149:                             !nsContentUtils::IsCallerChrome(), &ignored);
77149: }
77149: 
77149: void
77149: nsEventListenerManager::GetJSEventListener(nsIAtom *aEventName, jsval *vp)
77149: {
77149:   PRUint32 eventType = nsContentUtils::GetEventId(aEventName);
77149:   nsListenerStruct* ls = FindJSEventListener(eventType, aEventName);
77149: 
77149:   *vp = JSVAL_NULL;
77149: 
77149:   if (!ls) {
77149:     return;
77149:   }
77149: 
77149:   nsIJSEventListener *listener = ls->GetJSListener();
77149:   if (listener->GetEventContext()->GetScriptTypeID() !=
77149:         nsIProgrammingLanguage::JAVASCRIPT) {
77149:     // Not JS, so no point doing anything with it.
77149:     return;
77149:   }
77149:     
77149:   if (ls->mHandlerIsString) {
77149:     CompileEventHandlerInternal(ls, PR_TRUE, nsnull);
77149:   }
77149: 
77149:   *vp = OBJECT_TO_JSVAL(static_cast<JSObject*>(listener->GetHandler()));
77149: }
77149: 
