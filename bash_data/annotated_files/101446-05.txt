     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #ifndef nsLayoutUtils_h__
     1: #define nsLayoutUtils_h__
     1: 
     1: class nsIFormControlFrame;
     1: class nsPresContext;
     1: class nsIContent;
     1: class nsIAtom;
     1: class nsIScrollableFrame;
     1: class nsIDOMEvent;
     1: class nsRegion;
     1: class nsDisplayListBuilder;
 67668: class nsDisplayItem;
 68493: class nsFontMetrics;
 33027: class nsClientRectList;
 71908: class nsFontFaceList;
100047: class nsHTMLCanvasElement;
100047: class nsHTMLVideoElement;
100047: class nsIImageLoadingContent;
100047: class nsHTMLImageElement;
     1: 
     1: #include "prtypes.h"
 98711: #include "nsChangeHint.h"
     1: #include "nsStyleContext.h"
     1: #include "nsAutoPtr.h"
     1: #include "nsStyleSet.h"
     1: #include "nsIView.h"
  5256: #include "nsIFrame.h"
 14319: #include "nsThreadUtils.h"
 23933: #include "nsIPresShell.h"
 29959: #include "nsIPrincipal.h"
 26926: #include "gfxPattern.h"
 32424: #include "imgIContainer.h"
 35554: #include "nsCSSPseudoElements.h"
 51411: #include "nsHTMLReflowState.h"
 60444: #include "nsIFrameLoader.h"
 60444: #include "Layers.h"
     1: 
     1: class nsBlockFrame;
 50420: class gfxDrawable;
     1: 
 83345: namespace mozilla {
 83345: namespace dom {
 83345: class Element;
 83345: } // namespace dom
 83345: } // namespace mozilla
 83345: 
     1: /**
     1:  * nsLayoutUtils is a namespace class used for various helper
     1:  * functions that are useful in multiple places in layout.  The goal
     1:  * is not to define multiple copies of the same static helper.
     1:  */
     1: class nsLayoutUtils
     1: {
 55321:   typedef gfxPattern::GraphicsFilter GraphicsFilter;
 55321: 
     1: public:
 60444:   typedef mozilla::layers::FrameMetrics::ViewID ViewID;
 36646: 
 36646:   /**
 60450:    * Finds previously assigned or generates a unique ViewID for the given
 60450:    * content element.
 60450:    */
 60450:   static ViewID FindIDFor(nsIContent* aContent);
 60450: 
 60450:   /**
 60450:    * Find content for given ID.
 60450:    */
 60450:   static nsIContent* FindContentFor(ViewID aId);
 60450: 
 60450:   /**
 63413:    * Get display port for the given element.
 63413:    */
 63413:   static bool GetDisplayPort(nsIContent* aContent, nsRect *aResult);
 63413: 
 63413:   /**
 77154:    * Use heuristics to figure out the child list that
 47174:    * aChildFrame is currently in.
 36646:    */
 77154:   static nsIFrame::ChildListID GetChildListNameFor(nsIFrame* aChildFrame);
 36646: 
     1:   /**
 16976:    * GetBeforeFrame returns the outermost :before frame of the given frame, if
     1:    * one exists.  This is typically O(1).  The frame passed in must be
     1:    * the first-in-flow.
     1:    *
     1:    * @param aFrame the frame whose :before is wanted
     1:    * @return the :before frame or nsnull if there isn't one
     1:    */
     1:   static nsIFrame* GetBeforeFrame(nsIFrame* aFrame);
     1: 
     1:   /**
 16976:    * GetAfterFrame returns the outermost :after frame of the given frame, if one
     1:    * exists.  This will walk the in-flow chain to the last-in-flow if
     1:    * needed.  This function is typically O(N) in the number of child
     1:    * frames, following in-flows, etc.
     1:    *
     1:    * @param aFrame the frame whose :after is wanted
     1:    * @return the :after frame or nsnull if there isn't one
     1:    */
     1:   static nsIFrame* GetAfterFrame(nsIFrame* aFrame);
     1: 
     1:   /**
     1:    * Given a frame, search up the frame tree until we find an
  3113:    * ancestor that (or the frame itself) is of type aFrameType, if any.
     1:    *
  3113:    * @param aFrame the frame to start at
  3113:    * @param aFrameType the frame type to look for
  3113:    * @return a frame of the given type or nsnull if no
  3113:    *         such ancestor exists
  3113:    */
  3113:   static nsIFrame* GetClosestFrameOfType(nsIFrame* aFrame, nsIAtom* aFrameType);
  3113: 
  3113:   /**
  3113:    * Given a frame, search up the frame tree until we find an
  3113:    * ancestor that (or the frame itself) is a "Page" frame, if any.
  3113:    *
  3113:    * @param aFrame the frame to start at
     1:    * @return a frame of type nsGkAtoms::pageFrame or nsnull if no
     1:    *         such ancestor exists
     1:    */
  3113:   static nsIFrame* GetPageFrame(nsIFrame* aFrame)
  3113:   {
  3113:     return GetClosestFrameOfType(aFrame, nsGkAtoms::pageFrame);
  3113:   }
     1: 
     1:   /**
 35300:    * Given a frame which is the primary frame for an element,
 35300:    * return the frame that has the non-psuedoelement style context for
 35300:    * the content.
 35300:    * This is aPrimaryFrame itself except for tableOuter frames.
 35300:    */
 35300:   static nsIFrame* GetStyleFrame(nsIFrame* aPrimaryFrame);
 35300: 
 35300:   /**
 80486:    * IsGeneratedContentFor returns true if aFrame is the outermost
 16976:    * frame for generated content of type aPseudoElement for aContent.
 16976:    * aFrame *might not* have the aPseudoElement pseudo-style! For example
 16976:    * it might be a table outer frame and the inner table frame might
 16976:    * have the pseudo-style.
     1:    *
     1:    * @param aContent the content node we're looking at.  If this is
     1:    *        null, then we just assume that aFrame has the right content
     1:    *        pointer.
     1:    * @param aFrame the frame we're looking at
     1:    * @param aPseudoElement the pseudo type we're interested in
     1:    * @return whether aFrame is the generated aPseudoElement frame for aContent
     1:    */
 79445:   static bool IsGeneratedContentFor(nsIContent* aContent, nsIFrame* aFrame,
     1:                                       nsIAtom* aPseudoElement);
     1: 
 55416: #ifdef DEBUG
 55416:   // TODO: remove, see bug 598468.
 55416:   static bool gPreventAssertInCompareTreePosition;
 55416: #endif // DEBUG
 55416: 
     1:   /**
     1:    * CompareTreePosition determines whether aContent1 comes before or
     1:    * after aContent2 in a preorder traversal of the content tree.
     1:    *
     1:    * @param aCommonAncestor either null, or a common ancestor of
     1:    *                        aContent1 and aContent2.  Actually this is
     1:    *                        only a hint; if it's not an ancestor of
     1:    *                        aContent1 or aContent2, this function will
     1:    *                        still work, but it will be slower than
     1:    *                        normal.
     1:    * @return < 0 if aContent1 is before aContent2
     1:    *         > 0 if aContent1 is after aContent2,
     1:    *         0 otherwise (meaning they're the same, or they're in
     1:    *           different documents)
     1:    */
     1:   static PRInt32 CompareTreePosition(nsIContent* aContent1,
     1:                                      nsIContent* aContent2,
 32864:                                      const nsIContent* aCommonAncestor = nsnull)
     1:   {
     1:     return DoCompareTreePosition(aContent1, aContent2, -1, 1, aCommonAncestor);
     1:   }
     1: 
     1:   /*
     1:    * More generic version of |CompareTreePosition|.  |aIf1Ancestor|
     1:    * gives the value to return when 1 is an ancestor of 2, and likewise
     1:    * for |aIf2Ancestor|.  Passing (-1, 1) gives preorder traversal
     1:    * order, and (1, -1) gives postorder traversal order.
     1:    */
     1:   static PRInt32 DoCompareTreePosition(nsIContent* aContent1,
     1:                                        nsIContent* aContent2,
     1:                                        PRInt32 aIf1Ancestor,
     1:                                        PRInt32 aIf2Ancestor,
 32864:                                        const nsIContent* aCommonAncestor = nsnull);
     1: 
     1:   /**
     1:    * CompareTreePosition determines whether aFrame1 comes before or
     1:    * after aFrame2 in a preorder traversal of the frame tree, where out
     1:    * of flow frames are treated as children of their placeholders. This is
     1:    * basically the same ordering as DoCompareTreePosition(nsIContent*) except
     1:    * that it handles anonymous content properly and there are subtleties with
     1:    * continuations.
     1:    *
     1:    * @param aCommonAncestor either null, or a common ancestor of
     1:    *                        aContent1 and aContent2.  Actually this is
     1:    *                        only a hint; if it's not an ancestor of
     1:    *                        aContent1 or aContent2, this function will
     1:    *                        still work, but it will be slower than
     1:    *                        normal.
     1:    * @return < 0 if aContent1 is before aContent2
     1:    *         > 0 if aContent1 is after aContent2,
     1:    *         0 otherwise (meaning they're the same, or they're in
     1:    *           different frame trees)
     1:    */
     1:   static PRInt32 CompareTreePosition(nsIFrame* aFrame1,
     1:                                      nsIFrame* aFrame2,
     1:                                      nsIFrame* aCommonAncestor = nsnull)
     1:   {
     1:     return DoCompareTreePosition(aFrame1, aFrame2, -1, 1, aCommonAncestor);
     1:   }
     1: 
     1:   /*
     1:    * More generic version of |CompareTreePosition|.  |aIf1Ancestor|
     1:    * gives the value to return when 1 is an ancestor of 2, and likewise
     1:    * for |aIf2Ancestor|.  Passing (-1, 1) gives preorder traversal
     1:    * order, and (1, -1) gives postorder traversal order.
     1:    */
     1:   static PRInt32 DoCompareTreePosition(nsIFrame* aFrame1,
     1:                                        nsIFrame* aFrame2,
     1:                                        PRInt32 aIf1Ancestor,
     1:                                        PRInt32 aIf2Ancestor,
     1:                                        nsIFrame* aCommonAncestor = nsnull);
     1: 
     1:   /**
 10780:    * GetLastContinuationWithChild gets the last continuation in aFrame's chain
 10780:    * that has a child, or the first continuation if the frame has no children.
 10780:    */
 10780:   static nsIFrame* GetLastContinuationWithChild(nsIFrame* aFrame);
 10780: 
 10780:   /**
     1:    * GetLastSibling simply finds the last sibling of aFrame, or returns nsnull if
     1:    * aFrame is null.
     1:    */
     1:   static nsIFrame* GetLastSibling(nsIFrame* aFrame);
     1: 
     1:   /**
     1:    * FindSiblingViewFor locates the child of aParentView that aFrame's
     1:    * view should be inserted 'above' (i.e., before in sibling view
     1:    * order).  This is the first child view of aParentView whose
     1:    * corresponding content is before aFrame's content (view siblings
     1:    * are in reverse content order).
     1:    */
     1:   static nsIView* FindSiblingViewFor(nsIView* aParentView, nsIFrame* aFrame);
     1: 
     1:   /**
     1:    * Get the parent of aFrame. If aFrame is the root frame for a document,
     1:    * and the document has a parent document in the same view hierarchy, then
     1:    * we try to return the subdocumentframe in the parent document.
 18884:    * @param aExtraOffset [in/out] if non-null, then as we cross documents
 47896:    * an extra offset may be required and it will be added to aCrossDocOffset.
 47896:    * Be careful dealing with this extra offset as it is in app units of the
 47896:    * parent document, which may have a different app units per dev pixel ratio
 47896:    * than the child document.
     1:    */
 18884:   static nsIFrame* GetCrossDocParentFrame(const nsIFrame* aFrame,
 18884:                                           nsPoint* aCrossDocOffset = nsnull);
     1: 
     1:   /**
     1:    * IsProperAncestorFrame checks whether aAncestorFrame is an ancestor
     1:    * of aFrame and not equal to aFrame.
     1:    * @param aCommonAncestor nsnull, or a common ancestor of aFrame and
     1:    * aAncestorFrame. If non-null, this can bound the search and speed up
     1:    * the function
     1:    */
 79445:   static bool IsProperAncestorFrame(nsIFrame* aAncestorFrame, nsIFrame* aFrame,
     1:                                       nsIFrame* aCommonAncestor = nsnull);
     1: 
     1:   /**
     1:    * Like IsProperAncestorFrame, but looks across document boundaries.
 30518:    *
 30518:    * Just like IsAncestorFrameCrossDoc, except that it returns false when
 30518:    * aFrame == aAncestorFrame.
     1:    */
 79445:   static bool IsProperAncestorFrameCrossDoc(nsIFrame* aAncestorFrame, nsIFrame* aFrame,
     1:                                               nsIFrame* aCommonAncestor = nsnull);
     1: 
     1:   /**
 30518:    * IsAncestorFrameCrossDoc checks whether aAncestorFrame is an ancestor
 30518:    * of aFrame or equal to aFrame, looking across document boundaries.
 30518:    * @param aCommonAncestor nsnull, or a common ancestor of aFrame and
 30518:    * aAncestorFrame. If non-null, this can bound the search and speed up
 30518:    * the function.
 30518:    *
 30518:    * Just like IsProperAncestorFrameCrossDoc, except that it returns true when
 30518:    * aFrame == aAncestorFrame.
 30518:    */
 79445:   static bool IsAncestorFrameCrossDoc(nsIFrame* aAncestorFrame, nsIFrame* aFrame,
 30518:                                         nsIFrame* aCommonAncestor = nsnull);
 30518: 
 30518:   /**
 47736:    * Finds the nearest ancestor frame that is the root of an "actively
 47736:    * scrolled" frame subtree, or aStopAtAncestor if there is no
 47736:    * such ancestor before we reach aStopAtAncestor in the ancestor chain.
 47736:    * We expect frames with the same "active scrolled root" to be
 47736:    * scrolled together, so we'll place them in the same ThebesLayer.
 47736:    */
 47736:   static nsIFrame* GetActiveScrolledRootFor(nsIFrame* aFrame,
 49156:                                             nsIFrame* aStopAtAncestor);
 47736: 
 67668:   static nsIFrame* GetActiveScrolledRootFor(nsDisplayItem* aItem,
 69752:                                             nsDisplayListBuilder* aBuilder,
 79445:                                             bool* aShouldFixToViewport = nsnull);
 67668: 
 99197:   /**
 99197:    * Returns true if aActiveScrolledRoot is in a content document,
 99197:    * and its topmost content document ancestor has a root scroll frame with
 99197:    * a displayport set, and aActiveScrolledRoot is scrolled by that scrollframe.
 99197:    */
 99197:   static bool IsScrolledByRootContentDocumentDisplayportScrolling(nsIFrame* aActiveScrolledRoot,
 67668:                                                                   nsDisplayListBuilder* aBuilder);
 67668: 
 47736:   /**
     1:     * GetScrollableFrameFor returns the scrollable frame for a scrolled frame
     1:     */
     1:   static nsIScrollableFrame* GetScrollableFrameFor(nsIFrame *aScrolledFrame);
     1: 
 37057:   /**
 37057:    * GetNearestScrollableFrameForDirection locates the first ancestor of
 37057:    * aFrame (or aFrame itself) that is scrollable with overflow:scroll or
 37057:    * overflow:auto in the given direction and where either the scrollbar for
 37057:    * that direction is visible or the frame can be scrolled by some
 37057:    * positive amount in that direction.
 37057:    * The search extends across document boundaries.
 37057:    *
 37057:    * @param  aFrame the frame to start with
 37057:    * @param  aDirection Whether it's for horizontal or vertical scrolling.
 37057:    * @return the nearest scrollable frame or nsnull if not found
 37057:    */
 37057:   enum Direction { eHorizontal, eVertical };
 37057:   static nsIScrollableFrame* GetNearestScrollableFrameForDirection(nsIFrame* aFrame,
 37057:                                                                    Direction aDirection);
     1: 
     1:   /**
 37057:    * GetNearestScrollableFrame locates the first ancestor of aFrame
 37057:    * (or aFrame itself) that is scrollable with overflow:scroll or
 37057:    * overflow:auto in some direction.
 37057:    * The search extends across document boundaries.
     1:    *
 37057:    * @param  aFrame the frame to start with
 37057:    * @return the nearest scrollable frame or nsnull if not found
     1:    */
 37057:   static nsIScrollableFrame* GetNearestScrollableFrame(nsIFrame* aFrame);
     1: 
     1:   /**
 80486:    * HasPseudoStyle returns true if aContent (whose primary style
     1:    * context is aStyleContext) has the aPseudoElement pseudo-style
 80486:    * attached to it; returns false otherwise.
     1:    *
     1:    * @param aContent the content node we're looking at
     1:    * @param aStyleContext aContent's style context
 35554:    * @param aPseudoElement the id of the pseudo style we care about
     1:    * @param aPresContext the presentation context
     1:    * @return whether aContent has aPseudoElement style attached to it
     1:    */
 79445:   static bool HasPseudoStyle(nsIContent* aContent,
     1:                                nsStyleContext* aStyleContext,
 35554:                                nsCSSPseudoElements::Type aPseudoElement,
 48947:                                nsPresContext* aPresContext);
     1: 
     1:   /**
     1:    * If this frame is a placeholder for a float, then return the float,
 34911:    * otherwise return nsnull.  aPlaceholder must be a placeholder frame.
     1:    */
 34911:   static nsIFrame* GetFloatFromPlaceholder(nsIFrame* aPlaceholder);
     1: 
     1:   // Combine aNewBreakType with aOrigBreakType, but limit the break types
     1:   // to NS_STYLE_CLEAR_LEFT, RIGHT, LEFT_AND_RIGHT.
     1:   static PRUint8 CombineBreakType(PRUint8 aOrigBreakType, PRUint8 aNewBreakType);
     1: 
     1:   /**
     1:    * Get the coordinates of a given DOM mouse event, relative to a given
     1:    * frame. Works only for DOM events generated by nsGUIEvents.
     1:    * @param aDOMEvent the event
     1:    * @param aFrame the frame to make coordinates relative to
     1:    * @return the point, or (NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE) if
     1:    * for some reason the coordinates for the mouse are not known (e.g.,
     1:    * the event is not a GUI event).
     1:    */
     1:   static nsPoint GetDOMEventCoordinatesRelativeTo(nsIDOMEvent* aDOMEvent,
     1:                                                   nsIFrame* aFrame);
     1: 
     1:   /**
     1:    * Get the coordinates of a given native mouse event, relative to a given
     1:    * frame.
     1:    * @param aEvent the event
     1:    * @param aFrame the frame to make coordinates relative to
     1:    * @return the point, or (NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE) if
     1:    * for some reason the coordinates for the mouse are not known (e.g.,
     1:    * the event is not a GUI event).
     1:    */
  2817:   static nsPoint GetEventCoordinatesRelativeTo(const nsEvent* aEvent,
     1:                                                nsIFrame* aFrame);
     1: 
     1:   /**
 87650:    * Get the coordinates of a given point relative to an event and a
 87650:    * given frame.
 87650:    * @param aEvent the event
 87650:    * @param aPoint the point to get the coordinates relative to
 87650:    * @param aFrame the frame to make coordinates relative to
 87650:    * @return the point, or (NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE) if
 87650:    * for some reason the coordinates for the mouse are not known (e.g.,
 87650:    * the event is not a GUI event).
 87650:    */
 87650:   static nsPoint GetEventCoordinatesRelativeTo(const nsEvent* aEvent,
 87650:                                                const nsIntPoint aPoint,
 87650:                                                nsIFrame* aFrame);
 87650: 
 87650:   /**
 39629:    * Get the popup frame of a given native mouse event.
 48255:    * @param aPresContext only check popups within aPresContext or a descendant
 39629:    * @param aEvent  the event.
 39629:    * @return        Null, if there is no popup frame at the point, otherwise,
 39629:    *                returns top-most popup frame at the point.
 39629:    */
 48255:   static nsIFrame* GetPopupFrameForEventCoordinates(nsPresContext* aPresContext,
 48255:                                                     const nsEvent* aEvent);
 39629: 
 39629: /**
     1:    * Translate from widget coordinates to the view's coordinates
     1:    * @param aPresContext the PresContext for the view
     1:    * @param aWidget the widget
     1:    * @param aPt the point relative to the widget
     1:    * @param aView  view to which returned coordinates are relative
     1:    * @return the point in the view's coordinates
     1:    */
     1:   static nsPoint TranslateWidgetToView(nsPresContext* aPresContext,
     1:                                        nsIWidget* aWidget, nsIntPoint aPt,
     1:                                        nsIView* aView);
     1: 
     1:   /**
 19214:    * Given a matrix and a point, let T be the transformation matrix translating points
 19214:    * in the coordinate space with origin aOrigin to the coordinate space used by the
 19214:    * matrix.  If M is the stored matrix, this function returns (T-1)MT, the matrix
 19214:    * that's equivalent to aMatrix but in the coordinate space that treats aOrigin
 19214:    * as the origin.
 19214:    *
 19214:    * @param aOrigin The origin to translate to.
 19214:    * @param aMatrix The matrix to change the basis of.
 19214:    * @return A matrix equivalent to aMatrix, but operating in the coordinate system with
 19214:    *         origin aOrigin.
 19214:    */
 74757:   static gfx3DMatrix ChangeMatrixBasis(const gfxPoint3D &aOrigin, const gfx3DMatrix &aMatrix);
 19214: 
 19214:   /**
 60444:    * Find IDs corresponding to a scrollable content element in the child process.
 60444:    * In correspondence with the shadow layer tree, you can use this to perform a
 60444:    * hit test that corresponds to a specific shadow layer that you can then perform
 60444:    * transformations on to do parent-side scrolling.
 60444:    *
 60444:    * @param aFrame The root frame of a stack context
 60444:    * @param aTarget The rect to hit test relative to the frame origin
 60444:    * @param aOutIDs All found IDs are added here
 60444:    * @param aIgnoreRootScrollFrame a boolean to control if the display list
 60444:    *        builder should ignore the root scroll frame
 60444:    */
 60444:   static nsresult GetRemoteContentIds(nsIFrame* aFrame,
 60444:                                      const nsRect& aTarget,
 60444:                                      nsTArray<ViewID> &aOutIDs,
 79445:                                      bool aIgnoreRootScrollFrame);
 60444: 
 60444:   /**
     1:    * Given aFrame, the root frame of a stacking context, find its descendant
     1:    * frame under the point aPt that receives a mouse event at that location,
     1:    * or nsnull if there is no such frame.
     1:    * @param aPt the point, relative to the frame origin
  5440:    * @param aShouldIgnoreSuppression a boolean to control if the display
  5440:    * list builder should ignore paint suppression or not
 22095:    * @param aIgnoreRootScrollFrame whether or not the display list builder
 22095:    * should ignore the root scroll frame.
     1:    */
  5440:   static nsIFrame* GetFrameForPoint(nsIFrame* aFrame, nsPoint aPt,
 79445:                                     bool aShouldIgnoreSuppression = false,
 79445:                                     bool aIgnoreRootScrollFrame = false);
     1: 
     1:   /**
 40569:    * Given aFrame, the root frame of a stacking context, find all descendant
 40569:    * frames under the area of a rectangle that receives a mouse event,
 40569:    * or nsnull if there is no such frame.
 40569:    * @param aRect the rect, relative to the frame origin
 40569:    * @param aOutFrames an array to add all the frames found
 40569:    * @param aShouldIgnoreSuppression a boolean to control if the display
 40569:    * list builder should ignore paint suppression or not
 40569:    * @param aIgnoreRootScrollFrame whether or not the display list builder
 40569:    * should ignore the root scroll frame.
 40569:    */
 40569:   static nsresult GetFramesForArea(nsIFrame* aFrame, const nsRect& aRect,
 40569:                                    nsTArray<nsIFrame*> &aOutFrames,
 79445:                                    bool aShouldIgnoreSuppression = false,
 79445:                                    bool aIgnoreRootScrollFrame = false);
 40569: 
 86353:   /**
 86353:    * Transform aRect relative to aAncestor down to the coordinate system of
 86353:    * aFrame. Computes the bounding-box of the true quadrilateral.
 86353:    */
 86353:   static nsRect TransformAncestorRectToFrame(nsIFrame* aFrame,
 86353:                                              const nsRect& aRect,
 86353:                                              nsIFrame* aAncestor);
 86248: 
 86353:   /**
 86353:    * Transform aRect relative to aFrame up to the coordinate system of
 86353:    * aAncestor. Computes the bounding-box of the true quadrilateral.
 86353:    */
 86353:   static nsRect TransformFrameRectToAncestor(nsIFrame* aFrame,
 86244:                                              const nsRect& aRect,
 86353:                                              nsIFrame* aAncestor);
 69752: 
 87659: 
 87659:   /**
 87659:    * Gets the transform for aFrame relative to aAncestor. Pass null for aAncestor
 87659:    * to go up to the root frame.
 87659:    */
 87659:   static gfx3DMatrix GetTransformToAncestor(nsIFrame *aFrame, nsIFrame *aAncestor);
 87659: 
 69752:   /**
 19214:    * Given a point in the global coordinate space, returns that point expressed
 19214:    * in the coordinate system of aFrame.  This effectively inverts all transforms
 19214:    * between this point and the root frame.
 19214:    *
 19214:    * @param aFrame The frame that acts as the coordinate space container.
 19214:    * @param aPoint The point, in the global space, to get in the frame-local space.
 19214:    * @return aPoint, expressed in aFrame's canonical coordinate space.
 19214:    */
 86353:   static nsPoint TransformRootPointToFrame(nsIFrame* aFrame,
 19214:                                            const nsPoint &aPt);
 19214: 
 19214:   /**
 19214:    * Helper function that, given a rectangle and a matrix, returns the smallest
 19214:    * rectangle containing the image of the source rectangle.
 19214:    *
 19214:    * @param aBounds The rectangle to transform.
 19214:    * @param aMatrix The matrix to transform it with.
 19214:    * @param aFactor The number of app units per graphics unit.
 19214:    * @return The smallest rect that contains the image of aBounds.
 19214:    */
 19214:   static nsRect MatrixTransformRect(const nsRect &aBounds,
 74283:                                     const gfx3DMatrix &aMatrix, float aFactor);
 19214: 
 19214:   /**
 63072:    * Helper function that, given a rectangle and a matrix, returns the smallest
 63072:    * rectangle containing the image of the source rectangle rounded out to the nearest
 63072:    * pixel value.
 63072:    *
 63072:    * @param aBounds The rectangle to transform.
 63072:    * @param aMatrix The matrix to transform it with.
 63072:    * @param aFactor The number of app units per graphics unit.
 63072:    * @return The smallest rect that contains the image of aBounds.
 63072:    */
 63072:   static nsRect MatrixTransformRectOut(const nsRect &aBounds,
 74283:                                     const gfx3DMatrix &aMatrix, float aFactor);
 63072:   /**
 19214:    * Helper function that, given a point and a matrix, returns the image
 19214:    * of that point under the matrix transform.
 19214:    *
 19214:    * @param aPoint The point to transform.
 19214:    * @param aMatrix The matrix to transform it with.
 19214:    * @param aFactor The number of app units per graphics unit.
 19214:    * @return The image of the point under the transform.
 19214:    */
 19214:   static nsPoint MatrixTransformPoint(const nsPoint &aPoint,
 74283:                                       const gfx3DMatrix &aMatrix, float aFactor);
 19214: 
 19214:   /**
 19214:    * Given a graphics rectangle in graphics space, return a rectangle in
 19214:    * app space that contains the graphics rectangle, rounding out as necessary.
 19214:    *
 19214:    * @param aRect The graphics rect to round outward.
 19214:    * @param aFactor The number of app units per graphics unit.
 19214:    * @return The smallest rectangle in app space that contains aRect.
 19214:    */
 19214:   static nsRect RoundGfxRectToAppRect(const gfxRect &aRect, float aFactor);
 19214: 
 59779:   /**
 59779:    * Returns a subrectangle of aContainedRect that is entirely inside the rounded
 59779:    * rect. Complex cases are handled conservatively by returning a smaller
 59779:    * rect than necessary.
 59779:    */
 59779:   static nsRegion RoundedRectIntersectRect(const nsRect& aRoundedRect,
 59779:                                            const nscoord aRadii[8],
 59779:                                            const nsRect& aContainedRect);
 59779: 
 32424:   enum {
 32424:     PAINT_IN_TRANSFORM = 0x01,
 38805:     PAINT_SYNC_DECODE_IMAGES = 0x02,
 47739:     PAINT_WIDGET_LAYERS = 0x04,
 47739:     PAINT_IGNORE_SUPPRESSION = 0x08,
 54079:     PAINT_DOCUMENT_RELATIVE = 0x10,
 50424:     PAINT_HIDE_CARET = 0x20,
 55826:     PAINT_ALL_CONTINUATIONS = 0x40,
 60857:     PAINT_TO_WINDOW = 0x80,
 60857:     PAINT_EXISTING_TRANSACTION = 0x100
 32424:   };
 32424: 
 19214:   /**
     1:    * Given aFrame, the root frame of a stacking context, paint it and its
     1:    * descendants to aRenderingContext.
     1:    * @param aRenderingContext a rendering context translated so that (0,0)
 12189:    * is the origin of aFrame; for best results, (0,0) should transform
 38805:    * to pixel-aligned coordinates. This can be null, in which case
 38805:    * aFrame must be a "display root" (root frame for a root document,
 38805:    * or the root of a popup) with an associated widget and we draw using
 38805:    * the layer manager for the frame's widget.
     1:    * @param aDirtyRegion the region that must be painted, in the coordinates
     1:    * of aFrame
 29987:    * @param aBackstop paint the dirty area with this color before drawing
     1:    * the actual content; pass NS_RGBA(0,0,0,0) to draw no background
 30541:    * @param aFlags if PAINT_IN_TRANSFORM is set, then we assume
 32424:    * this is inside a transform or SVG foreignObject. If
 38805:    * PAINT_SYNC_DECODE_IMAGES is set, we force synchronous decode on all
 38805:    * images. If PAINT_WIDGET_LAYERS is set, aFrame must be a display root,
 38805:    * and we will use the frame's widget's layer manager to paint
 38805:    * even if aRenderingContext is non-null. This is useful if you want
 38805:    * to force rendering to use the widget's layer manager for testing
 38805:    * or speed. PAINT_WIDGET_LAYERS must be set if aRenderingContext is null.
 54079:    * If PAINT_DOCUMENT_RELATIVE is used, the visible region is interpreted
 54079:    * as being relative to the document.  (Normally it's relative to the CSS
 55826:    * viewport.) PAINT_TO_WINDOW sets painting to window to true on the display
 55826:    * list builder even if we can't tell that we are painting to the window.
 60857:    * If PAINT_EXISTING_TRANSACTION is set, then BeginTransaction() has already
 60857:    * been called on aFrame's widget's layer manager and should not be
 60857:    * called again.
 38805:    *
 38805:    * So there are three possible behaviours:
 38805:    * 1) PAINT_WIDGET_LAYERS is set and aRenderingContext is null; we paint
 38805:    * by calling BeginTransaction on the widget's layer manager
 38805:    * 2) PAINT_WIDGET_LAYERS is set and aRenderingContext is non-null; we
 38805:    * paint by calling BeginTransactionWithTarget on the widget's layer
 38805:    * maanger
 38805:    * 3) PAINT_WIDGET_LAYERS is not set and aRenderingContext is non-null;
 38805:    * we paint by construct a BasicLayerManager and calling
 38805:    * BeginTransactionWithTarget on it. This is desirable if we're doing
 38805:    * something like drawWindow in a mode where what gets rendered doesn't
 38805:    * necessarily correspond to what's visible in the window; we don't
 38805:    * want to mess up the widget's layer tree.
     1:    */
 68481:   static nsresult PaintFrame(nsRenderingContext* aRenderingContext, nsIFrame* aFrame,
 30541:                              const nsRegion& aDirtyRegion, nscolor aBackstop,
 30541:                              PRUint32 aFlags = 0);
     1: 
     1:   /**
     1:    * Compute the used z-index of aFrame; returns zero for elements to which
     1:    * z-index does not apply, and for z-index:auto
     1:    */
     1:   static PRInt32 GetZIndex(nsIFrame* aFrame);
     1: 
     1:   /**
     1:    * Uses a binary search for find where the cursor falls in the line of text
     1:    * It also keeps track of the part of the string that has already been measured
     1:    * so it doesn't have to keep measuring the same text over and over
     1:    *
     1:    * @param "aBaseWidth" contains the width in twips of the portion
     1:    * of the text that has already been measured, and aBaseInx contains
     1:    * the index of the text that has already been measured.
     1:    *
     1:    * @param aTextWidth returns the (in twips) the length of the text that falls
     1:    * before the cursor aIndex contains the index of the text where the cursor falls
     1:    */
 79445:   static bool
 68481:   BinarySearchForPosition(nsRenderingContext* acx,
     1:                           const PRUnichar* aText,
     1:                           PRInt32    aBaseWidth,
     1:                           PRInt32    aBaseInx,
     1:                           PRInt32    aStartInx,
     1:                           PRInt32    aEndInx,
     1:                           PRInt32    aCursorPos,
     1:                           PRInt32&   aIndex,
     1:                           PRInt32&   aTextWidth);
     1: 
 19125:   class BoxCallback {
 19125:   public:
 19125:     virtual void AddBox(nsIFrame* aFrame) = 0;
 19125:   };
 19125:   /**
 19125:    * Collect all CSS boxes associated with aFrame and its
 19125:    * continuations, "drilling down" through outer table frames and
 19125:    * some anonymous blocks since they're not real CSS boxes.
 19125:    * If aFrame is null, no boxes are returned.
 19125:    * SVG frames return a single box, themselves.
 19125:    */
 19125:   static void GetAllInFlowBoxes(nsIFrame* aFrame, BoxCallback* aCallback);
 19125: 
 12349:   class RectCallback {
 12349:   public:
 12349:     virtual void AddRect(const nsRect& aRect) = 0;
 12349:   };
 33027: 
 33027:   struct RectAccumulator : public RectCallback {
 33027:     nsRect mResultRect;
 33027:     nsRect mFirstRect;
 79445:     bool mSeenFirstRect;
 33027: 
 33027:     RectAccumulator();
 33027: 
 33027:     virtual void AddRect(const nsRect& aRect);
 33027:   };
 33027: 
 33027:   struct RectListBuilder : public RectCallback {
 33027:     nsClientRectList* mRectList;
 33027:     nsresult          mRV;
 33027: 
 33027:     RectListBuilder(nsClientRectList* aList);
 33027:      virtual void AddRect(const nsRect& aRect);
 33027:   };
 33027: 
 33027:   static nsIFrame* GetContainingBlockForClientRect(nsIFrame* aFrame);
 33027: 
 86354:   enum {
 86354:     RECTS_ACCOUNT_FOR_TRANSFORMS = 0x01
 86354:   };
     1:   /**
 12349:    * Collect all CSS border-boxes associated with aFrame and its
 12349:    * continuations, "drilling down" through outer table frames and
 12349:    * some anonymous blocks since they're not real CSS boxes.
 12349:    * The boxes are positioned relative to aRelativeTo (taking scrolling
 12349:    * into account) and passed to the callback in frame-tree order.
 12349:    * If aFrame is null, no boxes are returned.
 12349:    * For SVG frames, returns one rectangle, the bounding box.
 86354:    * If aFlags includes RECTS_ACCOUNT_FOR_TRANSFORMS, then when converting
 86354:    * the boxes into aRelativeTo coordinates, transforms (including CSS
 86354:    * and SVG transforms) are taken into account.
     1:    */
 12349:   static void GetAllInFlowRects(nsIFrame* aFrame, nsIFrame* aRelativeTo,
 86354:                                 RectCallback* aCallback, PRUint32 aFlags = 0);
 12349: 
 12349:   /**
 12349:    * Computes the union of all rects returned by GetAllInFlowRects. If
 12349:    * the union is empty, returns the first rect.
 86354:    * If aFlags includes RECTS_ACCOUNT_FOR_TRANSFORMS, then when converting
 86354:    * the boxes into aRelativeTo coordinates, transforms (including CSS
 86354:    * and SVG transforms) are taken into account.
 12349:    */
 86354:   static nsRect GetAllInFlowRectsUnion(nsIFrame* aFrame, nsIFrame* aRelativeTo,
 86354:                                        PRUint32 aFlags = 0);
     1: 
 59781:   enum {
 59781:     EXCLUDE_BLUR_SHADOWS = 0x01
 59781:   };
     1:   /**
 15339:    * Takes a text-shadow array from the style properties of a given nsIFrame and
 15339:    * computes the union of those shadows along with the given initial rect.
 15339:    * If there are no shadows, the initial rect is returned.
 15339:    */
 15339:   static nsRect GetTextShadowRectsUnion(const nsRect& aTextAndDecorationsRect,
 59781:                                         nsIFrame* aFrame,
 59781:                                         PRUint32 aFlags = 0);
 15339: 
 15339:   /**
     1:    * Get the font metrics corresponding to the frame's style data.
     1:    * @param aFrame the frame
     1:    * @param aFontMetrics the font metrics result
 82672:    * @param aSizeInflation number to multiply font size by
     1:    * @return success or failure code
     1:    */
 56866:   static nsresult GetFontMetricsForFrame(const nsIFrame* aFrame,
 82672:                                          nsFontMetrics** aFontMetrics,
 82672:                                          float aSizeInflation = 1.0f);
     1: 
     1:   /**
  4353:    * Get the font metrics corresponding to the given style data.
  4353:    * @param aStyleContext the style data
  4353:    * @param aFontMetrics the font metrics result
 82672:    * @param aSizeInflation number to multiply font size by
  4353:    * @return success or failure code
  4353:    */
  4353:   static nsresult GetFontMetricsForStyleContext(nsStyleContext* aStyleContext,
 82672:                                                 nsFontMetrics** aFontMetrics,
 82672:                                                 float aSizeInflation = 1.0f);
  4353: 
  4353:   /**
     1:    * Find the immediate child of aParent whose frame subtree contains
     1:    * aDescendantFrame. Returns null if aDescendantFrame is not a descendant
     1:    * of aParent.
     1:    */
     1:   static nsIFrame* FindChildContainingDescendant(nsIFrame* aParent, nsIFrame* aDescendantFrame);
     1: 
     1:   /**
     1:    * Find the nearest ancestor that's a block
     1:    */
     1:   static nsBlockFrame* FindNearestBlockAncestor(nsIFrame* aFrame);
     1: 
     1:   /**
 21943:    * Find the nearest ancestor that's not for generated content. Will return
 21943:    * aFrame if aFrame is not for generated content.
 21943:    */
 21943:   static nsIFrame* GetNonGeneratedAncestor(nsIFrame* aFrame);
 21943: 
 21943:   /**
  9572:    * Cast aFrame to an nsBlockFrame* or return null if it's not
  9572:    * an nsBlockFrame.
  9572:    */
  9572:   static nsBlockFrame* GetAsBlock(nsIFrame* aFrame);
  9572: 
 79487:   /*
 79487:    * Whether the frame is an nsBlockFrame which is not a wrapper block.
 79487:    */
 79487:   static bool IsNonWrapperBlock(nsIFrame* aFrame) {
 79487:     return GetAsBlock(aFrame) && !aFrame->IsBlockWrapper();
 79487:   }
 79487: 
  9572:   /**
     1:    * If aFrame is an out of flow frame, return its placeholder, otherwise
     1:    * return its parent.
     1:    */
101446:   static nsIFrame* GetParentOrPlaceholderFor(nsIFrame* aFrame);
     1: 
     1:   /**
    94:    * Get a frame's next-in-flow, or, if it doesn't have one, its special sibling.
    94:    */
    94:   static nsIFrame*
    94:   GetNextContinuationOrSpecialSibling(nsIFrame *aFrame);
    94: 
    94:   /**
 19125:    * Get the first frame in the continuation-plus-special-sibling chain
 19125:    * containing aFrame.
 19125:    */
 19125:   static nsIFrame*
 19125:   GetFirstContinuationOrSpecialSibling(nsIFrame *aFrame);
 19125: 
 19125:   /**
     1:    * Check whether aFrame is a part of the scrollbar or scrollcorner of
     1:    * the root content.
     1:    * @param aFrame the checking frame
     1:    * @return if TRUE, the frame is a part of the scrollbar or scrollcorner of
     1:    *         the root content.
     1:    */
 79445:   static bool IsViewportScrollbarFrame(nsIFrame* aFrame);
     1: 
     1:   /**
     1:    * Get the contribution of aFrame to its containing block's intrinsic
     1:    * width.  This considers the child's intrinsic width, its 'width',
     1:    * 'min-width', and 'max-width' properties, and its padding, border,
     1:    * and margin.
     1:    */
     1:   enum IntrinsicWidthType { MIN_WIDTH, PREF_WIDTH };
 68481:   static nscoord IntrinsicForContainer(nsRenderingContext* aRenderingContext,
     1:                                        nsIFrame* aFrame,
     1:                                        IntrinsicWidthType aType);
     1: 
  1068:   /*
  1068:    * Convert nsStyleCoord to nscoord when percentages depend on the
  1068:    * containing block width.
  1068:    */
     1:   static nscoord ComputeWidthDependentValue(
     1:                    nscoord              aContainingBlockWidth,
     1:                    const nsStyleCoord&  aCoord);
     1: 
  1068:   /*
  1068:    * Convert nsStyleCoord to nscoord when percentages depend on the
  1068:    * containing block width, and enumerated values are for width,
  1068:    * min-width, or max-width.  Returns the content-box width value based
  1068:    * on aContentEdgeToBoxSizing and aBoxSizingToMarginEdge (which are
  1068:    * also used for the enumerated values for width.  This function does
  1068:    * not handle 'auto'.  It ensures that the result is nonnegative.
  1068:    *
  1068:    * @param aRenderingContext Rendering context for font measurement/metrics.
  1068:    * @param aFrame Frame whose (min-/max-/)width is being computed
  1068:    * @param aContainingBlockWidth Width of aFrame's containing block.
  1068:    * @param aContentEdgeToBoxSizing The sum of any left/right padding and
  1068:    *          border that goes inside the rect chosen by -moz-box-sizing.
  1068:    * @param aBoxSizingToMarginEdge The sum of any left/right padding, border,
  1068:    *          and margin that goes outside the rect chosen by -moz-box-sizing.
  1068:    * @param aCoord The width value to compute.
  1068:    */
  1068:   static nscoord ComputeWidthValue(
 68481:                    nsRenderingContext* aRenderingContext,
  1068:                    nsIFrame*            aFrame,
  1068:                    nscoord              aContainingBlockWidth,
  1068:                    nscoord              aContentEdgeToBoxSizing,
  1068:                    nscoord              aBoxSizingToMarginEdge,
  1068:                    const nsStyleCoord&  aCoord);
  1068: 
  1068:   /*
  1068:    * Convert nsStyleCoord to nscoord when percentages depend on the
  1068:    * containing block height.
  1068:    */
     1:   static nscoord ComputeHeightDependentValue(
     1:                    nscoord              aContainingBlockHeight,
     1:                    const nsStyleCoord&  aCoord);
     1: 
  8142:   /*
 51406:    * Likewise, but for 'height', 'min-height', or 'max-height'.
 51406:    */
 51406:   static nscoord ComputeHeightValue(nscoord aContainingBlockHeight,
 51406:                                     const nsStyleCoord& aCoord)
 51406:   {
 51406:     nscoord result =
 51406:       ComputeHeightDependentValue(aContainingBlockHeight, aCoord);
 51406:     if (result < 0)
 51406:       result = 0; // clamp calc()
 51406:     return result;
 51406:   }
 51406: 
 79445:   static bool IsAutoHeight(const nsStyleCoord &aCoord, nscoord aCBHeight)
 51411:   {
 51411:     nsStyleUnit unit = aCoord.GetUnit();
 51411:     return unit == eStyleUnit_Auto ||  // only for 'height'
 51411:            unit == eStyleUnit_None ||  // only for 'max-height'
 51411:            (aCBHeight == NS_AUTOHEIGHT && aCoord.HasPercent());
 51411:   }
 51411: 
 79445:   static bool IsPaddingZero(const nsStyleCoord &aCoord)
 51777:   {
 51777:     return (aCoord.GetUnit() == eStyleUnit_Coord &&
 51777:             aCoord.GetCoordValue() == 0) ||
 51777:            (aCoord.GetUnit() == eStyleUnit_Percent &&
 67624:             aCoord.GetPercentValue() == 0.0f) ||
 51777:            (aCoord.IsCalcUnit() &&
 52283:             // clamp negative calc() to 0
 52283:             nsRuleNode::ComputeCoordPercentCalc(aCoord, nscoord_MAX) <= 0 &&
 52283:             nsRuleNode::ComputeCoordPercentCalc(aCoord, 0) <= 0);
 52283:   }
 52283: 
 79445:   static bool IsMarginZero(const nsStyleCoord &aCoord)
 52283:   {
 52283:     return (aCoord.GetUnit() == eStyleUnit_Coord &&
 52283:             aCoord.GetCoordValue() == 0) ||
 52283:            (aCoord.GetUnit() == eStyleUnit_Percent &&
 67624:             aCoord.GetPercentValue() == 0.0f) ||
 52283:            (aCoord.IsCalcUnit() &&
 51777:             nsRuleNode::ComputeCoordPercentCalc(aCoord, nscoord_MAX) == 0 &&
 51777:             nsRuleNode::ComputeCoordPercentCalc(aCoord, 0) == 0);
 51777:   }
 51777: 
 51406:   /*
  8142:    * Calculate the used values for 'width' and 'height' for a replaced element.
  8142:    *
  8142:    *   http://www.w3.org/TR/CSS21/visudet.html#min-max-widths
  8142:    */
     1:   static nsSize ComputeSizeWithIntrinsicDimensions(
 68481:                     nsRenderingContext* aRenderingContext, nsIFrame* aFrame,
  8147:                     const nsIFrame::IntrinsicSize& aIntrinsicSize,
  8142:                     nsSize aIntrinsicRatio, nsSize aCBSize,
  1068:                     nsSize aMargin, nsSize aBorder, nsSize aPadding);
     1: 
 74937:   /*
 74937:    * Calculate the used values for 'width' and 'height' when width
 74937:    * and height are 'auto'. The tentWidth and tentHeight arguments should be
 74937:    * the result of applying the rules for computing intrinsic sizes and ratios.
 74937:    * as specified by CSS 2.1 sections 10.3.2 and 10.6.2
 74937:    */
 74937:   static nsSize ComputeAutoSizeWithIntrinsicDimensions(nscoord minWidth, nscoord minHeight,
 74937:                                                        nscoord maxWidth, nscoord maxHeight,
 74937:                                                        nscoord tentWidth, nscoord tentHeight);
 74937: 
     1:   // Implement nsIFrame::GetPrefWidth in terms of nsIFrame::AddInlinePrefWidth
     1:   static nscoord PrefWidthFromInline(nsIFrame* aFrame,
 68481:                                      nsRenderingContext* aRenderingContext);
     1: 
     1:   // Implement nsIFrame::GetMinWidth in terms of nsIFrame::AddInlineMinWidth
     1:   static nscoord MinWidthFromInline(nsIFrame* aFrame,
 68481:                                     nsRenderingContext* aRenderingContext);
     1: 
 75138:   // Get a suitable foreground color for painting aProperty for aFrame.
 75138:   static nscolor GetColor(nsIFrame* aFrame, nsCSSProperty aProperty);
 72260: 
 72990:   // Get a baseline y position in app units that is snapped to device pixels.
 72990:   static gfxFloat GetSnappedBaselineY(nsIFrame* aFrame, gfxContext* aContext,
 72990:                                       nscoord aY, nscoord aAscent);
 72990: 
     1:   static void DrawString(const nsIFrame*      aFrame,
 68481:                          nsRenderingContext* aContext,
     1:                          const PRUnichar*     aString,
     1:                          PRInt32              aLength,
 24995:                          nsPoint              aPoint,
 24995:                          PRUint8              aDirection = NS_STYLE_DIRECTION_INHERIT);
     1: 
     1:   static nscoord GetStringWidth(const nsIFrame*      aFrame,
 68481:                                 nsRenderingContext* aContext,
     1:                                 const PRUnichar*     aString,
     1:                                 PRInt32              aLength);
     1: 
     1:   /**
 72827:    * Helper function for drawing text-shadow. The callback's job
 72827:    * is to draw whatever needs to be blurred onto the given context.
 72827:    */
 72827:   typedef void (* TextShadowCallback)(nsRenderingContext* aCtx,
 72827:                                       nsPoint aShadowOffset,
 72827:                                       const nscolor& aShadowColor,
 72827:                                       void* aData);
 72827: 
 72827:   static void PaintTextShadow(const nsIFrame*     aFrame,
 72827:                               nsRenderingContext* aContext,
 72827:                               const nsRect&       aTextRect,
 72827:                               const nsRect&       aDirtyRect,
 72827:                               const nscolor&      aForegroundColor,
 72827:                               TextShadowCallback  aCallback,
 72827:                               void*               aCallbackData);
 72827: 
 72827:   /**
 28519:    * Gets the baseline to vertically center text from a font within a
 28519:    * line of specified height.
 28519:    *
 28519:    * Returns the baseline position relative to the top of the line.
 28519:    */
 68493:   static nscoord GetCenteredFontBaseline(nsFontMetrics* aFontMetrics,
 28519:                                          nscoord         aLineHeight);
 28519: 
 28519:   /**
     1:    * Derive a baseline of |aFrame| (measured from its top border edge)
     1:    * from its first in-flow line box (not descending into anything with
     1:    * 'overflow' not 'visible', potentially including aFrame itself).
     1:    *
     1:    * Returns true if a baseline was found (and fills in aResult).
     1:    * Otherwise returns false.
     1:    */
 79445:   static bool GetFirstLineBaseline(const nsIFrame* aFrame, nscoord* aResult);
     1: 
     1:   /**
 27100:    * Just like GetFirstLineBaseline, except also returns the top and
 27100:    * bottom of the line with the baseline.
 27100:    *
 27100:    * Returns true if a line was found (and fills in aResult).
 27100:    * Otherwise returns false.
 27100:    */
 27100:   struct LinePosition {
 27100:     nscoord mTop, mBaseline, mBottom;
 27100: 
 27100:     LinePosition operator+(nscoord aOffset) const {
 27100:       LinePosition result;
 27100:       result.mTop = mTop + aOffset;
 27100:       result.mBaseline = mBaseline + aOffset;
 27100:       result.mBottom = mBottom + aOffset;
 27100:       return result;
 27100:     }
 27100:   };
 79445:   static bool GetFirstLinePosition(const nsIFrame* aFrame,
 27100:                                      LinePosition* aResult);
 27100: 
 27100: 
 27100:   /**
     1:    * Derive a baseline of |aFrame| (measured from its top border edge)
     1:    * from its last in-flow line box (not descending into anything with
     1:    * 'overflow' not 'visible', potentially including aFrame itself).
     1:    *
     1:    * Returns true if a baseline was found (and fills in aResult).
     1:    * Otherwise returns false.
     1:    */
 79445:   static bool GetLastLineBaseline(const nsIFrame* aFrame, nscoord* aResult);
     1: 
     1:   /**
 14460:    * Returns a y coordinate relative to this frame's origin that represents
 14460:    * the logical bottom of the frame or its visible content, whichever is lower.
 14460:    * Relative positioning is ignored and margins and glyph bounds are not
 14460:    * considered.
 14460:    * This value will be >= mRect.height() and <= overflowRect.YMost() unless
 14460:    * relative positioning is applied.
 14460:    */
 14460:   static nscoord CalculateContentBottom(nsIFrame* aFrame);
 14460: 
 14460:   /**
     1:    * Gets the closest frame (the frame passed in or one of its parents) that
     1:    * qualifies as a "layer"; used in DOM0 methods that depends upon that
     1:    * definition. This is the nearest frame that is either positioned or scrolled
 43138:    * (the child of a scroll frame).
     1:    */
     1:   static nsIFrame* GetClosestLayer(nsIFrame* aFrame);
     1: 
 26926:   /**
 26926:    * Gets the graphics filter for the frame
 26926:    */
 55321:   static GraphicsFilter GetGraphicsFilterForFrame(nsIFrame* aFrame);
 26926: 
 24452:   /* N.B. The only difference between variants of the Draw*Image
 24452:    * functions below is the type of the aImage argument.
 24452:    */
 24452: 
     1:   /**
 75061:    * Draw a background image.  The image's dimensions are as specified in aDest;
 75061:    * the image itself is not consulted to determine a size.
 75061:    * See https://wiki.mozilla.org/Gecko:Image_Snapping_and_Rendering
 75061:    *   @param aRenderingContext Where to draw the image, set up with an
 75061:    *                            appropriate scale and transform for drawing in
 75061:    *                            app units.
 75061:    *   @param aImage            The image.
 75061:    *   @param aImageSize        The unscaled size of the image being drawn.
 75061:    *                            (This might be the image's size if no scaling
 75061:    *                            occurs, or it might be the image's size if
 75061:    *                            the image is a vector image being rendered at
 75061:    *                            that size.)
 75061:    *   @param aDest             The position and scaled area where one copy of
 75061:    *                            the image should be drawn.
 75061:    *   @param aFill             The area to be filled with copies of the
 75061:    *                            image.
 75061:    *   @param aAnchor           A point in aFill which we will ensure is
 75061:    *                            pixel-aligned in the output.
 75061:    *   @param aDirty            Pixels outside this area may be skipped.
 75061:    *   @param aImageFlags       Image flags of the imgIContainer::FLAG_* variety
 75061:    */
 75061:   static nsresult DrawBackgroundImage(nsRenderingContext* aRenderingContext,
 75061:                                       imgIContainer*      aImage,
 75061:                                       const nsIntSize&    aImageSize,
 75061:                                       GraphicsFilter      aGraphicsFilter,
 75061:                                       const nsRect&       aDest,
 75061:                                       const nsRect&       aFill,
 75061:                                       const nsPoint&      aAnchor,
 75061:                                       const nsRect&       aDirty,
 75061:                                       PRUint32            aImageFlags);
 75061: 
 75061:   /**
 21323:    * Draw an image.
 21323:    * See https://wiki.mozilla.org/Gecko:Image_Snapping_and_Rendering
     1:    *   @param aRenderingContext Where to draw the image, set up with an
     1:    *                            appropriate scale and transform for drawing in
 21323:    *                            app units.
  5147:    *   @param aImage            The image.
 21323:    *   @param aDest             Where one copy of the image should mapped to.
 21323:    *   @param aFill             The area to be filled with copies of the
 21323:    *                            image.
 21323:    *   @param aAnchor           A point in aFill which we will ensure is
 21323:    *                            pixel-aligned in the output.
 21323:    *   @param aDirty            Pixels outside this area may be skipped.
 32424:    *   @param aImageFlags       Image flags of the imgIContainer::FLAG_* variety
     1:    */
 68481:   static nsresult DrawImage(nsRenderingContext* aRenderingContext,
     1:                             imgIContainer*       aImage,
 55321:                             GraphicsFilter       aGraphicsFilter,
 21323:                             const nsRect&        aDest,
 21323:                             const nsRect&        aFill,
 21323:                             const nsPoint&       aAnchor,
 32424:                             const nsRect&        aDirty,
 32424:                             PRUint32             aImageFlags);
 21323: 
 21323:   /**
 52135:    * Convert an nsRect to a gfxRect.
 52135:    */
 52135:   static gfxRect RectToGfxRect(const nsRect& aRect,
 52135:                                PRInt32 aAppUnitsPerDevPixel);
 52135: 
 52135:   /**
 50420:    * Draw a drawable using the pixel snapping algorithm.
 50420:    * See https://wiki.mozilla.org/Gecko:Image_Snapping_and_Rendering
 50420:    *   @param aRenderingContext Where to draw the image, set up with an
 50420:    *                            appropriate scale and transform for drawing in
 50420:    *                            app units.
 50420:    *   @param aDrawable         The drawable we want to draw.
 50420:    *   @param aFilter           The graphics filter we should draw with.
 50420:    *   @param aDest             Where one copy of the image should mapped to.
 50420:    *   @param aFill             The area to be filled with copies of the
 50420:    *                            image.
 50420:    *   @param aAnchor           A point in aFill which we will ensure is
 50420:    *                            pixel-aligned in the output.
 50420:    *   @param aDirty            Pixels outside this area may be skipped.
 50420:    */
 68481:   static void DrawPixelSnapped(nsRenderingContext* aRenderingContext,
 50420:                                gfxDrawable*         aDrawable,
 55321:                                GraphicsFilter       aFilter,
 50420:                                const nsRect&        aDest,
 50420:                                const nsRect&        aFill,
 50420:                                const nsPoint&       aAnchor,
 50420:                                const nsRect&        aDirty);
 50420: 
 50420:   /**
 21323:    * Draw a whole image without scaling or tiling.
 21323:    *
 21323:    *   @param aRenderingContext Where to draw the image, set up with an
 21323:    *                            appropriate scale and transform for drawing in
 21323:    *                            app units.
 21323:    *   @param aImage            The image.
 21323:    *   @param aDest             The top-left where the image should be drawn
 55322:    *   @param aDirty            If non-null, then pixels outside this area may
 55322:    *                            be skipped.
 32424:    *   @param aImageFlags       Image flags of the imgIContainer::FLAG_* variety
 21323:    *   @param aSourceArea       If non-null, this area is extracted from
 21323:    *                            the image and drawn at aDest. It's
 21323:    *                            in appunits. For best results it should
 21323:    *                            be aligned with image pixels.
 21323:    */
 68481:   static nsresult DrawSingleUnscaledImage(nsRenderingContext* aRenderingContext,
 21323:                                           imgIContainer*       aImage,
 55322:                                           GraphicsFilter       aGraphicsFilter,
 21323:                                           const nsPoint&       aDest,
 55322:                                           const nsRect*        aDirty,
 32424:                                           PRUint32             aImageFlags,
 21323:                                           const nsRect*        aSourceArea = nsnull);
 21323: 
 21323:   /**
 21323:    * Draw a whole image without tiling.
 21323:    *
 21323:    *   @param aRenderingContext Where to draw the image, set up with an
 21323:    *                            appropriate scale and transform for drawing in
 21323:    *                            app units.
 21323:    *   @param aImage            The image.
 21323:    *   @param aDest             The area that the image should fill
 21323:    *   @param aDirty            Pixels outside this area may be skipped.
 21323:    *   @param aSourceArea       If non-null, this area is extracted from
 21323:    *                            the image and drawn in aDest. It's
 21323:    *                            in appunits. For best results it should
 21323:    *                            be aligned with image pixels.
 32424:    *   @param aImageFlags       Image flags of the imgIContainer::FLAG_* variety
 21323:    */
 68481:   static nsresult DrawSingleImage(nsRenderingContext* aRenderingContext,
 21323:                                   imgIContainer*       aImage,
 55321:                                   GraphicsFilter       aGraphicsFilter,
 21323:                                   const nsRect&        aDest,
 21323:                                   const nsRect&        aDirty,
 32424:                                   PRUint32             aImageFlags,
 21323:                                   const nsRect*        aSourceArea = nsnull);
 21323: 
 21323:   /**
 52215:    * Given an imgIContainer, this method attempts to obtain an intrinsic
 52215:    * px-valued height & width for it.  If the imgIContainer has a non-pixel
 52215:    * value for either height or width, this method tries to generate a pixel
 75061:    * value for that dimension using the intrinsic ratio (if available).  The
 75061:    * intrinsic ratio will be assigned to aIntrinsicRatio; if there's no
 75061:    * intrinsic ratio then (0, 0) will be assigned.
 52215:    *
 52215:    * This method will always set aGotWidth and aGotHeight to indicate whether
 52215:    * we were able to successfully obtain (or compute) a value for each
 52215:    * dimension.
 52215:    *
 52215:    * NOTE: This method is similar to ComputeSizeWithIntrinsicDimensions.  The
 52215:    * difference is that this one is simpler and is suited to places where we
 52215:    * have less information about the frame tree.
 52215:    */
 52215:   static void ComputeSizeForDrawing(imgIContainer* aImage,
 52215:                                     nsIntSize&     aImageSize,
 75061:                                     nsSize&        aIntrinsicRatio,
 75061:                                     bool&          aGotWidth,
 75061:                                     bool&          aGotHeight);
 52215: 
 52215:   /**
 21323:    * Given a source area of an image (in appunits) and a destination area
 21323:    * that we want to map that source area too, computes the area that
 21323:    * would be covered by the whole image. This is useful for passing to
 21323:    * the aDest parameter of DrawImage, when we want to draw a subimage
 21323:    * of an overall image.
 21323:    */
 21323:   static nsRect GetWholeImageDestination(const nsIntSize& aWholeImageSize,
 21323:                                          const nsRect& aImageSourceArea,
 21323:                                          const nsRect& aDestArea);
  1105: 
  1105:   /**
 20039:    * Determine if any corner radius is of nonzero size
 20039:    *   @param aCorners the |nsStyleCorners| object to check
 80486:    *   @return true unless all the coordinates are 0%, 0 or null.
 20039:    *
 20039:    * A corner radius with one dimension zero and one nonzero is
 20039:    * treated as a nonzero-radius corner, even though it will end up
 20039:    * being rendered like a zero-radius corner.  This is because such
 20039:    * corners are not expected to appear outside of test cases, and it's
 20039:    * simpler to implement the test this way.
  1345:    */
 79445:   static bool HasNonZeroCorner(const nsStyleCorners& aCorners);
  1345: 
  1345:   /**
 28109:    * Determine if there is any corner radius on corners adjacent to the
 28109:    * given side.
 28109:    */
 79445:   static bool HasNonZeroCornerOnSide(const nsStyleCorners& aCorners,
 41419:                                        mozilla::css::Side aSide);
 28109: 
 28109:   /**
  1345:    * Determine if a widget is likely to require transparency or translucency.
 31535:    *   @param aBackgroundFrame The frame that the background is set on. For
 31535:    *                           <window>s, this will be the canvas frame.
 31535:    *   @param aCSSRootFrame    The frame that holds CSS properties affecting
 31535:    *                           the widget's transparency. For menupopups,
 31535:    *                           aBackgroundFrame and aCSSRootFrame will be the
 31535:    *                           same.
  1345:    *   @return a value suitable for passing to SetWindowTranslucency
  1345:    */
 31535:   static nsTransparencyMode GetFrameTransparency(nsIFrame* aBackgroundFrame,
 31535:                                                  nsIFrame* aCSSRootFrame);
  4032: 
  4032:   /**
 37081:    * A frame is a popup if it has its own floating window. Menus, panels
 37081:    * and combobox dropdowns are popups.
 37081:    */
 79445:   static bool IsPopup(nsIFrame* aFrame);
 37081: 
 37081:   /**
 37081:    * Find the nearest "display root". This is the nearest enclosing
 37081:    * popup frame or the root prescontext's root frame.
 37081:    */
 37081:   static nsIFrame* GetDisplayRootFrame(nsIFrame* aFrame);
 37081: 
 37081:   /**
  4032:    * Get textrun construction flags determined by a given style; in particular
  4032:    * some combination of:
  4032:    * -- TEXT_DISABLE_OPTIONAL_LIGATURES if letter-spacing is in use
  4032:    * -- TEXT_OPTIMIZE_SPEED if the text-rendering CSS property and font size
  4032:    * and prefs indicate we should be optimizing for speed over quality
  4032:    */
  4032:   static PRUint32 GetTextRunFlagsForStyle(nsStyleContext* aStyleContext,
  4032:                                           const nsStyleText* aStyleText,
  4032:                                           const nsStyleFont* aStyleFont);
 11016: 
 11016:   /**
 11384:    * Takes two rectangles whose origins must be the same, and computes
 11384:    * the difference between their union and their intersection as two
 11384:    * rectangles. (This difference is a superset of the difference
 11384:    * between the two rectangles.)
 11384:    */
 11384:   static void GetRectDifferenceStrips(const nsRect& aR1, const nsRect& aR2,
 11384:                                       nsRect* aHStrip, nsRect* aVStrip);
 11384: 
 11384:   /**
 16228:    * Get a device context that can be used to get up-to-date device
 93485:    * dimensions for the given window. For some reason, this is more
 16228:    * complicated than it ought to be in multi-monitor situations.
 16228:    */
 68668:   static nsDeviceContext*
 93485:   GetDeviceContextForScreenInfo(nsPIDOMWindow* aWindow);
 16228: 
 16228:   /**
 21903:    * Some frames with 'position: fixed' (nsStylePosition::mDisplay ==
 21903:    * NS_STYLE_POSITION_FIXED) are not really fixed positioned, since
 21903:    * they're inside an element with -moz-transform.  This function says
 21903:    * whether such an element is a real fixed-pos element.
 21903:    */
 79445:   static bool IsReallyFixedPos(nsIFrame* aFrame);
 21903: 
 21903:   /**
 34460:    * Return true if aFrame is in an {ib} split and is NOT one of the
 34460:    * continuations of the first inline in it.
 28217:    */
 79445:   static bool FrameIsNonFirstInIBSplit(const nsIFrame* aFrame) {
 28217:     return (aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) &&
 34460:       aFrame->GetFirstContinuation()->
 39965:         Properties().Get(nsIFrame::IBSplitSpecialPrevSibling());
 28217:   }
 28217: 
 28217:   /**
 34460:    * Return true if aFrame is in an {ib} split and is NOT one of the
 34460:    * continuations of the last inline in it.
 28217:    */
 79445:   static bool FrameIsNonLastInIBSplit(const nsIFrame* aFrame) {
 28217:     return (aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) &&
 34460:       aFrame->GetFirstContinuation()->
 39965:         Properties().Get(nsIFrame::IBSplitSpecialSibling());
 28217:   }
 29572: 
 29572:   /**
 29572:    * Obtain a gfxASurface from the given DOM element, if possible.
 29572:    * This obtains the most natural surface from the element; that
 29572:    * is, the one that can be obtained with the fewest conversions.
 29572:    *
 29572:    * The flags below can modify the behaviour of this function.  The
 29572:    * result is returned as a SurfaceFromElementResult struct, also
 29572:    * defined below.
 29572:    *
 29572:    * Currently, this will do:
 29572:    *  - HTML Canvas elements: will return the underlying canvas surface
 29572:    *  - HTML Video elements: will return the current video frame
 29572:    *  - Image elements: will return the image
 29572:    *
 29572:    * The above results are modified by the below flags (copying,
 29572:    * forcing image surface, etc.).
 29572:    */
 29572: 
 29572:   enum {
 29572:     /* Always create a new surface for the result */
 29572:     SFE_WANT_NEW_SURFACE   = 1 << 0,
 29572:     /* When creating a new surface, create an image surface */
 32424:     SFE_WANT_IMAGE_SURFACE = 1 << 1,
 32424:     /* Whether to extract the first frame (as opposed to the
 32424:        current frame) in the case that the element is an image. */
 60418:     SFE_WANT_FIRST_FRAME = 1 << 2,
 60418:     /* Whether we should skip colorspace/gamma conversion */
 60418:     SFE_NO_COLORSPACE_CONVERSION = 1 << 3,
 60418:     /* Whether we should skip premultiplication -- the resulting
 60418:        image will always be an image surface, and must not be given to
 60418:        Thebes for compositing! */
 60418:     SFE_NO_PREMULTIPLY_ALPHA = 1 << 4
 29572:   };
 29572: 
 29572:   struct SurfaceFromElementResult {
 78159:     SurfaceFromElementResult() :
 78159:       // Use safe default values here
 80486:       mIsWriteOnly(true), mIsStillLoading(false), mCORSUsed(false) {}
 43798: 
 29572:     /* mSurface will contain the resulting surface, or will be NULL on error */
 29572:     nsRefPtr<gfxASurface> mSurface;
 29572:     /* The size of the surface */
 29572:     gfxIntSize mSize;
 78533:     /* The principal associated with the element whose surface was returned.
 78533:        If there is a surface, this will never be null. */
 29572:     nsCOMPtr<nsIPrincipal> mPrincipal;
 63836:     /* The image request, if the element is an nsIImageLoadingContent */
 63836:     nsCOMPtr<imgIRequest> mImageRequest;
 29572:     /* Whether the element was "write only", that is, the bits should not be exposed to content */
 79445:     bool mIsWriteOnly;
 43798:     /* Whether the element was still loading.  Some consumers need to handle
 43798:        this case specially. */
 79445:     bool mIsStillLoading;
 78159:     /* Whether the element used CORS when loading. */
 79445:     bool mCORSUsed;
 29572:   };
 29572: 
 83345:   static SurfaceFromElementResult SurfaceFromElement(mozilla::dom::Element *aElement,
 29572:                                                      PRUint32 aSurfaceFlags = 0);
100047:   static SurfaceFromElementResult SurfaceFromElement(nsIImageLoadingContent *aElement,
100047:                                                      PRUint32 aSurfaceFlags = 0);
100047:   // Need an nsHTMLImageElement overload, because otherwise the
100047:   // nsIImageLoadingContent and mozilla::dom::Element overloads are ambiguous
100047:   // for nsHTMLImageElement.
100047:   static SurfaceFromElementResult SurfaceFromElement(nsHTMLImageElement *aElement,
100047:                                                      PRUint32 aSurfaceFlags = 0);
100047:   static SurfaceFromElementResult SurfaceFromElement(nsHTMLCanvasElement *aElement,
100047:                                                      PRUint32 aSurfaceFlags = 0);
100047:   static SurfaceFromElementResult SurfaceFromElement(nsHTMLVideoElement *aElement,
100047:                                                      PRUint32 aSurfaceFlags = 0);
 41068: 
 41068:   /**
 41068:    * When the document is editable by contenteditable attribute of its root
 41068:    * content or body content.
 41068:    *
 41068:    * Be aware, this returns NULL if it's in designMode.
 41068:    *
 41068:    * For example:
 41068:    *
 41068:    *  <html contenteditable="true"><body></body></html>
 41068:    *    returns the <html>.
 41068:    *
 41068:    *  <html><body contenteditable="true"></body></html>
 41068:    *  <body contenteditable="true"></body>
 41068:    *    With these cases, this returns the <body>.
 41068:    *    NOTE: The latter case isn't created normally, however, it can be
 41068:    *          created by script with XHTML.
 41068:    *
 41068:    *  <body><p contenteditable="true"></p></body>
 41068:    *    returns NULL because <body> isn't editable.
 41068:    */
 41068:   static nsIContent*
 41068:     GetEditableRootContentByContentEditable(nsIDocument* aDocument);
 49166: 
 49166:   /**
 49166:    * Returns true if the passed in prescontext needs the dark grey background
 49166:    * that goes behind the page of a print preview presentation.
 49166:    */
 79445:   static bool NeedsPrintPreviewBackground(nsPresContext* aPresContext) {
 49166:     return aPresContext->IsRootPaginatedDocument() &&
 49166:       (aPresContext->Type() == nsPresContext::eContext_PrintPreview ||
 49166:        aPresContext->Type() == nsPresContext::eContext_PageLayout);
 49166:   }
 60338: 
 71908:   /**
 71908:    * Adds all font faces used in the frame tree starting from aFrame
 71908:    * to the list aFontFaceList.
 71908:    */
 71908:   static nsresult GetFontFacesForFrames(nsIFrame* aFrame,
 71908:                                         nsFontFaceList* aFontFaceList);
 71908: 
 71908:   /**
 71908:    * Adds all font faces used within the specified range of text in aFrame,
 71908:    * and optionally its continuations, to the list in aFontFaceList.
 71908:    * Pass 0 and PR_INT32_MAX for aStartOffset and aEndOffset to specify the
 71908:    * entire text is to be considered.
 71908:    */
 71908:   static nsresult GetFontFacesForText(nsIFrame* aFrame,
 71908:                                       PRInt32 aStartOffset,
 71908:                                       PRInt32 aEndOffset,
 79445:                                       bool aFollowContinuations,
 71908:                                       nsFontFaceList* aFontFaceList);
 71908: 
 74749:   /**
 80375:    * Walks the frame tree starting at aFrame looking for textRuns.
 82849:    * If |clear| is true, just clears the TEXT_RUN_MEMORY_ACCOUNTED flag
 82849:    * on each textRun found (and |aMallocSizeOf| is not used).
 82849:    * If |clear| is false, adds the storage used for each textRun to the
 80375:    * total, and sets the TEXT_RUN_MEMORY_ACCOUNTED flag to avoid double-
 80375:    * accounting. (Runs with this flag already set will be skipped.)
 80375:    * Expected usage pattern is therefore to call twice:
 82849:    *    (void)SizeOfTextRunsForFrames(rootFrame, nsnull, true);
 82849:    *    total = SizeOfTextRunsForFrames(rootFrame, mallocSizeOf, false);
 80375:    */
 82849:   static size_t SizeOfTextRunsForFrames(nsIFrame* aFrame,
 82849:                                         nsMallocSizeOfFun aMallocSizeOf,
 82849:                                         bool clear);
 80375: 
 80375:   /**
 74749:    * Checks if CSS 3D transforms are currently enabled.
 74749:    */
 79445:   static bool Are3DTransformsEnabled();
 74749: 
 82670:   /**
 95942:    * Checks if we should forcibly use nearest pixel filtering for the
 95942:    * background.
 95942:    */
 95942:   static bool UseBackgroundNearestFiltering();
 95942: 
 95942:   /**
 97534:    * Checks whether we want to use the GPU to scale images when
 97534:    * possible.
 97534:    */
 97534:   static bool GPUImageScalingEnabled();
 97534: 
 97534:   /**
 87626:    * Unions the overflow areas of all non-popup children of aFrame with
 87626:    * aOverflowAreas.
 87626:    */
 87626:   static void UnionChildOverflow(nsIFrame* aFrame,
 87626:                                  nsOverflowAreas& aOverflowAreas);
 87626: 
 87626:   /**
 82670:    * Return whether this is a frame whose width is used when computing
 82670:    * the font size inflation of its descendants.
 82670:    */
 88118:   static bool IsContainerForFontSizeInflation(const nsIFrame *aFrame)
 88118:   {
 88118:     return aFrame->GetStateBits() & NS_FRAME_FONT_INFLATION_CONTAINER;
 88118:   }
 82670: 
 82670:   /**
 82670:    * Return the font size inflation *ratio* for a given frame.  This is
 82670:    * the factor by which font sizes should be inflated; it is never
 82670:    * smaller than 1.
 82670:    */
 98995:   static float FontSizeInflationFor(const nsIFrame *aFrame);
 82670: 
 82670:   /**
 82670:    * Perform the first half of the computation of FontSizeInflationFor
 82670:    * (see above).
 82670:    * This includes determining whether inflation should be performed
 82670:    * within this container and returning 0 if it should not be.
 82670:    *
 82670:    * The result is guaranteed not to vary between line participants
 82670:    * (inlines, text frames) within a line.
 82670:    *
 82670:    * The result should not be used directly since font sizes slightly
 82670:    * above the minimum should always be adjusted as done by
 82670:    * FontSizeInflationInner.
 82670:    */
 98995:   static nscoord InflationMinFontSizeFor(const nsIFrame *aFrame);
 82670: 
 82670:   /**
 82670:    * Perform the second half of the computation done by
 82670:    * FontSizeInflationFor (see above).
 82670:    *
 82670:    * aMinFontSize must be the result of one of the
 82670:    *   InflationMinFontSizeFor methods above.
 82670:    */
 82670:   static float FontSizeInflationInner(const nsIFrame *aFrame,
 82670:                                       nscoord aMinFontSize);
 82670: 
 82670:   static bool FontSizeInflationEnabled(nsPresContext *aPresContext);
 82670: 
 95532:   /**
 97801:    * See comment above "font.size.inflation.emPerLine" in
 97801:    * modules/libpref/src/init/all.js .
 97801:    */
 97801:   static PRUint32 FontSizeInflationEmPerLine() {
 97801:     return sFontSizeInflationEmPerLine;
 97801:   }
 97801: 
 97801:   /**
 97801:    * See comment above "font.size.inflation.minTwips" in
 97801:    * modules/libpref/src/init/all.js .
 97801:    */
 97801:   static PRUint32 FontSizeInflationMinTwips() {
 97801:     return sFontSizeInflationMinTwips;
 97801:   }
 97801: 
 97801:   /**
 95532:    * See comment above "font.size.inflation.lineThreshold" in
 95532:    * modules/libpref/src/init/all.js .
 95532:    */
 95532:   static PRUint32 FontSizeInflationLineThreshold() {
 95532:     return sFontSizeInflationLineThreshold;
 95532:   }
 95532: 
 82670:   static void Initialize();
 60450:   static void Shutdown();
 60450: 
 82098:   /**
 82098:    * Register an imgIRequest object with a refresh driver.
 82098:    *
 82098:    * @param aPresContext The nsPresContext whose refresh driver we want to
 82098:    *        register with.
 82098:    * @param aRequest A pointer to the imgIRequest object which the client wants
 82098:    *        to register with the refresh driver.
 82098:    * @param aRequestRegistered A pointer to a boolean value which indicates
 82098:    *        whether the given image request is registered. If
 82098:    *        *aRequestRegistered is true, then this request will not be
 82098:    *        registered again. If the request is registered by this function,
 82098:    *        then *aRequestRegistered will be set to true upon the completion of
 82098:    *        this function.
 82098:    *
 82098:    */
 82098:   static void RegisterImageRequest(nsPresContext* aPresContext,
 82098:                                    imgIRequest* aRequest,
 82098:                                    bool* aRequestRegistered);
 82098: 
 82098:   /**
 82098:    * Register an imgIRequest object with a refresh driver, but only if the
 82098:    * request is for an image that is animated.
 82098:    *
 82098:    * @param aPresContext The nsPresContext whose refresh driver we want to
 82098:    *        register with.
 82098:    * @param aRequest A pointer to the imgIRequest object which the client wants
 82098:    *        to register with the refresh driver.
 82098:    * @param aRequestRegistered A pointer to a boolean value which indicates
 82098:    *        whether the given image request is registered. If
 82098:    *        *aRequestRegistered is true, then this request will not be
 82098:    *        registered again. If the request is registered by this function,
 82098:    *        then *aRequestRegistered will be set to true upon the completion of
 82098:    *        this function.
 82098:    *
 82098:    */
 82098:   static void RegisterImageRequestIfAnimated(nsPresContext* aPresContext,
 82098:                                              imgIRequest* aRequest,
 82098:                                              bool* aRequestRegistered);
 82098: 
 82098:   /**
 82098:    * Deregister an imgIRequest object from a refresh driver.
 82098:    *
 82098:    * @param aPresContext The nsPresContext whose refresh driver we want to
 82098:    *        deregister from.
 82098:    * @param aRequest A pointer to the imgIRequest object with which the client
 82098:    *        previously registered and now wants to deregister from the refresh
 82098:    *        driver.
 82098:    * @param aRequestRegistered A pointer to a boolean value which indicates
 82098:    *        whether the given image request is registered. If
 82098:    *        *aRequestRegistered is false, then this request will not be
 82098:    *        deregistered. If the request is deregistered by this function,
 82098:    *        then *aRequestRegistered will be set to false upon the completion of
 82098:    *        this function.
 82098:    */
 82098:   static void DeregisterImageRequest(nsPresContext* aPresContext,
 82098:                                      imgIRequest* aRequest,
 82098:                                      bool* aRequestRegistered);
 82098: 
 98711:   /**
 98711:    * Shim to nsCSSFrameConstructor::PostRestyleEvent. Exists so that we
 98711:    * can avoid including nsCSSFrameConstructor.h and all its dependencies
 98711:    * in content files.
 98711:    */
 98711:   static void PostRestyleEvent(mozilla::dom::Element* aElement,
 98711:                                nsRestyleHint aRestyleHint,
 98711:                                nsChangeHint aMinChangeHint);
 98711: 
 60338: #ifdef DEBUG
 60338:   /**
 60338:    * Assert that there are no duplicate continuations of the same frame
 60338:    * within aFrameList.  Optimize the tests by assuming that all frames
 60338:    * in aFrameList have parent aContainer.
 60338:    */
 60338:   static void
 60338:   AssertNoDuplicateContinuations(nsIFrame* aContainer,
 60338:                                  const nsFrameList& aFrameList);
 60341: 
 60341:   /**
 60341:    * Assert that the frame tree rooted at |aSubtreeRoot| is empty, i.e.,
 60341:    * that it contains no first-in-flows.
 60341:    */
 60341:   static void
 60341:   AssertTreeOnlyEmptyNextInFlows(nsIFrame *aSubtreeRoot);
 60338: #endif
 95532: 
 95532: private:
 97801:   static PRUint32 sFontSizeInflationEmPerLine;
 97801:   static PRUint32 sFontSizeInflationMinTwips;
 95532:   static PRUint32 sFontSizeInflationLineThreshold;
 11016: };
 11016: 
 88122: namespace mozilla {
 88122:   namespace layout {
 88122: 
 88122:     /**
 88122:      * An RAII class which will, for the duration of its lifetime,
 88122:      * **if** the frame given is a container for font size inflation,
 88122:      * set the current inflation container on the pres context to null
 88122:      * (and then, in its destructor, restore the old value).
 88122:      */
 98992:     class AutoMaybeDisableFontInflation {
 88122:     public:
 98992:       AutoMaybeDisableFontInflation(nsIFrame *aFrame)
 88122:       {
 98992:         // FIXME: Now that inflation calculations are based on the flow
 98992:         // root's NCA's (nearest common ancestor of its inflatable
 98992:         // descendants) width, we could probably disable inflation in
 98992:         // fewer cases than we currently do.
 88122:         if (nsLayoutUtils::IsContainerForFontSizeInflation(aFrame)) {
 88122:           mPresContext = aFrame->PresContext();
 98992:           mOldValue = mPresContext->mInflationDisabledForShrinkWrap;
 98992:           mPresContext->mInflationDisabledForShrinkWrap = true;
 88122:         } else {
 88122:           // indicate we have nothing to restore
 88122:           mPresContext = nsnull;
 88122:         }
 88122:       }
 88122: 
 98992:       ~AutoMaybeDisableFontInflation()
 88122:       {
 88122:         if (mPresContext) {
 98992:           mPresContext->mInflationDisabledForShrinkWrap = mOldValue;
 88122:         }
 88122:       }
 88122:     private:
 88122:       nsPresContext *mPresContext;
 98992:       bool mOldValue;
 88122:     };
 88122: 
 88122:   }
 88122: }
 88122: 
 14319: class nsSetAttrRunnable : public nsRunnable
 14319: {
 14319: public:
 14319:   nsSetAttrRunnable(nsIContent* aContent, nsIAtom* aAttrName,
 14319:                     const nsAString& aValue);
 41743:   nsSetAttrRunnable(nsIContent* aContent, nsIAtom* aAttrName,
 41743:                     PRInt32 aValue);
 14319: 
 14319:   NS_DECL_NSIRUNNABLE
 14319: 
 14319:   nsCOMPtr<nsIContent> mContent;
 14319:   nsCOMPtr<nsIAtom> mAttrName;
 14319:   nsAutoString mValue;
 14319: };
 14319: 
 14319: class nsUnsetAttrRunnable : public nsRunnable
 14319: {
 14319: public:
 14319:   nsUnsetAttrRunnable(nsIContent* aContent, nsIAtom* aAttrName);
 14319: 
 14319:   NS_DECL_NSIRUNNABLE
 14319: 
 14319:   nsCOMPtr<nsIContent> mContent;
 14319:   nsCOMPtr<nsIAtom> mAttrName;
 14319: };
 14319: 
 23933: class nsReflowFrameRunnable : public nsRunnable
 23933: {
 23933: public:
 23933:   nsReflowFrameRunnable(nsIFrame* aFrame,
 23933:                         nsIPresShell::IntrinsicDirty aIntrinsicDirty,
 23933:                         nsFrameState aBitToAdd);
 23933: 
 23933:   NS_DECL_NSIRUNNABLE
 23933: 
 23933:   nsWeakFrame mWeakFrame;
 23933:   nsIPresShell::IntrinsicDirty mIntrinsicDirty;
 23933:   nsFrameState mBitToAdd;
 23933: };
 23933: 
     1: #endif // nsLayoutUtils_h__
