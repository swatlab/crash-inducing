 43113: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 43113: 
 43113: #ifndef nsHttpTransaction_h__
 43113: #define nsHttpTransaction_h__
 43113: 
 43113: #include "nsHttp.h"
 43113: #include "nsHttpHeaderArray.h"
 43113: #include "nsAHttpTransaction.h"
 43113: #include "nsAHttpConnection.h"
 43113: #include "nsCOMPtr.h"
 43113: 
 43113: #include "nsIPipe.h"
 43113: #include "nsIInputStream.h"
124828: #include "nsILoadGroup.h"
 43113: #include "nsIOutputStream.h"
 43113: #include "nsIInterfaceRequestor.h"
 43113: #include "nsISocketTransportService.h"
 43113: #include "nsITransport.h"
 43113: #include "nsIEventTarget.h"
 70188: #include "TimingStruct.h"
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: class nsHttpTransaction;
 43113: class nsHttpRequestHead;
 43113: class nsHttpResponseHead;
 43113: class nsHttpChunkedDecoder;
 43113: class nsIHttpActivityObserver;
124978: class UpdateSecurityCallbacks;
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpTransaction represents a single HTTP transaction.  It is thread-safe,
 43113: // intended to run on the socket thread.
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: class nsHttpTransaction : public nsAHttpTransaction
 43113:                         , public nsIInputStreamCallback
 43113:                         , public nsIOutputStreamCallback
 43113: {
 43113: public:
 43113:     NS_DECL_ISUPPORTS
 43113:     NS_DECL_NSAHTTPTRANSACTION
 43113:     NS_DECL_NSIINPUTSTREAMCALLBACK
 43113:     NS_DECL_NSIOUTPUTSTREAMCALLBACK
 43113: 
 43113:     nsHttpTransaction();
 43113:     virtual ~nsHttpTransaction();
 43113: 
 43113:     //
 43113:     // called to initialize the transaction
 43113:     // 
 43113:     // @param caps
 43113:     //        the transaction capabilities (see nsHttp.h)
 43113:     // @param connInfo
 43113:     //        the connection type for this transaction.
 43113:     // @param reqHeaders
 43113:     //        the request header struct
 43113:     // @param reqBody
 43113:     //        the request body (POST or PUT data stream)
 43113:     // @param reqBodyIncludesHeaders
 43113:     //        fun stuff to support NPAPI plugins.
 43113:     // @param target
 43113:     //        the dispatch target were notifications should be sent.
 43113:     // @param callbacks
 43113:     //        the notification callbacks to be given to PSM.
 43113:     // @param responseBody
 43113:     //        the input stream that will contain the response data.  async
 43113:     //        wait on this input stream for data.  on first notification,
 43113:     //        headers should be available (check transaction status).
 43113:     //
124419:     nsresult Init(uint32_t               caps,
 43113:                   nsHttpConnectionInfo  *connInfo,
 43113:                   nsHttpRequestHead     *reqHeaders,
 43113:                   nsIInputStream        *reqBody,
 79445:                   bool                   reqBodyIncludesHeaders,
 43113:                   nsIEventTarget        *consumerTarget,
 43113:                   nsIInterfaceRequestor *callbacks,
 43113:                   nsITransportEventSink *eventsink,
 43113:                   nsIAsyncInputStream  **responseBody);
 43113: 
 43113:     // attributes
 43113:     nsHttpConnectionInfo  *ConnectionInfo() { return mConnInfo; }
106838:     nsHttpResponseHead    *ResponseHead()   { return mHaveAllHeaders ? mResponseHead : nullptr; }
 43113:     nsISupports           *SecurityInfo()   { return mSecurityInfo; }
 43113: 
 43113:     nsIEventTarget        *ConsumerTarget() { return mConsumerTarget; }
 43113: 
121883:     void SetSecurityCallbacks(nsIInterfaceRequestor* aCallbacks);
121882: 
 43113:     // Called to take ownership of the response headers; the transaction
 43113:     // will drop any reference to the response headers after this call.
 43113:     nsHttpResponseHead *TakeResponseHead();
 43113: 
 43113:     // Called to find out if the transaction generated a complete response.
 79445:     bool ResponseIsComplete() { return mResponseIsComplete; }
 43113: 
109252:     bool      ProxyConnectFailed() { return mProxyConnectFailed; }
 43113: 
 84549:     // SetPriority() may only be used by the connection manager.
108991:     void    SetPriority(int32_t priority) { mPriority = priority; }
108991:     int32_t    Priority()                 { return mPriority; }
 43113: 
 70188:     const TimingStruct& Timings() const { return mTimings; }
 93840:     enum Classifier Classification() { return mClassification; }
 70188: 
104066:     void PrintDiagnostics(nsCString &log);
104066: 
114431:     // Sets mPendingTime to the current time stamp or to a null time stamp (if now is false)
114431:     void SetPendingTime(bool now = true) { mPendingTime = now ? mozilla::TimeStamp::Now() : mozilla::TimeStamp(); }
114431:     const mozilla::TimeStamp GetPendingTime() { return mPendingTime; }
114431:     bool UsesPipelining() const { return mCaps & NS_HTTP_ALLOW_PIPELINING; }
114431: 
124828:     void SetLoadGroupConnectionInfo(nsILoadGroupConnectionInfo *aLoadGroupCI) { mLoadGroupCI = aLoadGroupCI; } 
124828:     nsILoadGroupConnectionInfo *LoadGroupConnectionInfo() { return mLoadGroupCI.get(); }
124828:     void DispatchedAsBlocking();
124828:     void RemoveDispatchedAsBlocking();
124828: 
 43113: private:
 43113:     nsresult Restart();
 93845:     nsresult RestartInProgress();
108991:     char    *LocateHttpStart(char *buf, uint32_t len,
 79445:                              bool aAllowPartialMatch);
 71093:     nsresult ParseLine(char *line);
108991:     nsresult ParseLineSegment(char *seg, uint32_t len);
108991:     nsresult ParseHead(char *, uint32_t count, uint32_t *countRead);
 43113:     nsresult HandleContentStart();
108991:     nsresult HandleContent(char *, uint32_t count, uint32_t *contentRead, uint32_t *contentRemaining);
108991:     nsresult ProcessData(char *, uint32_t, uint32_t *);
 43113:     void     DeleteSelfOnConsumerThread();
124828:     void     ReleaseBlockingTransaction();
 43113: 
 93840:     Classifier Classify();
108991:     void       CancelPipeline(uint32_t reason);
 93840: 
 43113:     static NS_METHOD ReadRequestSegment(nsIInputStream *, void *, const char *,
108991:                                         uint32_t, uint32_t, uint32_t *);
 43113:     static NS_METHOD WritePipeSegment(nsIOutputStream *, void *, char *,
108991:                                       uint32_t, uint32_t, uint32_t *);
 43113: 
 79445:     bool TimingEnabled() const { return mCaps & NS_HTTP_TIMING_ENABLED; }
 70188: 
 43113: private:
124978:     class UpdateSecurityCallbacks : public nsRunnable
124978:     {
124978:       public:
124978:         UpdateSecurityCallbacks(nsHttpTransaction* aTrans,
124978:                                 nsIInterfaceRequestor* aCallbacks)
124978:         : mTrans(aTrans), mCallbacks(aCallbacks) {}
124978: 
124978:         NS_IMETHOD Run()
124978:         {
124978:             if (mTrans->mConnection)
124978:                 mTrans->mConnection->SetSecurityCallbacks(mCallbacks);
124978:             return NS_OK;
124978:         }
124978:       private:
124978:         nsRefPtr<nsHttpTransaction> mTrans;
124978:         nsCOMPtr<nsIInterfaceRequestor> mCallbacks;
124978:     };
124978: 
121882:     mozilla::Mutex mCallbacksLock;
121882: 
 43113:     nsCOMPtr<nsIInterfaceRequestor> mCallbacks;
 43113:     nsCOMPtr<nsITransportEventSink> mTransportSink;
 43113:     nsCOMPtr<nsIEventTarget>        mConsumerTarget;
 43113:     nsCOMPtr<nsISupports>           mSecurityInfo;
 43113:     nsCOMPtr<nsIAsyncInputStream>   mPipeIn;
 43113:     nsCOMPtr<nsIAsyncOutputStream>  mPipeOut;
124828:     nsCOMPtr<nsILoadGroupConnectionInfo> mLoadGroupCI;
 43113: 
 43113:     nsCOMPtr<nsISupports>             mChannel;
 43113:     nsCOMPtr<nsIHttpActivityObserver> mActivityDistributor;
 43113: 
 43113:     nsCString                       mReqHeaderBuf;    // flattened request headers
 43113:     nsCOMPtr<nsIInputStream>        mRequestStream;
108991:     uint64_t                        mRequestSize;
 43113: 
 43113:     nsAHttpConnection              *mConnection;      // hard ref
 43113:     nsHttpConnectionInfo           *mConnInfo;        // hard ref
 43113:     nsHttpRequestHead              *mRequestHead;     // weak ref
 43113:     nsHttpResponseHead             *mResponseHead;    // hard ref
 43113: 
 43113:     nsAHttpSegmentReader           *mReader;
 43113:     nsAHttpSegmentWriter           *mWriter;
 43113: 
 43113:     nsCString                       mLineBuf;         // may contain a partial line
 43113: 
108991:     int64_t                         mContentLength;   // equals -1 if unknown
108991:     int64_t                         mContentRead;     // count of consumed content bytes
 43113: 
 61543:     // After a 304/204 or other "no-content" style response we will skip over
 61543:     // up to MAX_INVALID_RESPONSE_BODY_SZ bytes when looking for the next
 61543:     // response header to deal with servers that actually sent a response
 61543:     // body where they should not have. This member tracks how many bytes have
 61543:     // so far been skipped.
108991:     uint32_t                        mInvalidResponseBytesRead;
 61543: 
 43113:     nsHttpChunkedDecoder           *mChunkedDecoder;
 43113: 
 70188:     TimingStruct                    mTimings;
 70188: 
 43113:     nsresult                        mStatus;
 43113: 
108991:     int16_t                         mPriority;
 43113: 
108991:     uint16_t                        mRestartCount;        // the number of times this transaction has been restarted
124419:     uint32_t                        mCaps;
 93840:     enum Classifier                 mClassification;
108991:     int32_t                         mPipelinePosition;
108991:     int64_t                         mMaxPipelineObjectSize;
 43113: 
108528:     nsHttpVersion                   mHttpVersion;
108528: 
 64625:     // state flags, all logically boolean, but not packed together into a
 64625:     // bitfield so as to avoid bitfield-induced races.  See bug 560579.
 79445:     bool                            mClosed;
 79445:     bool                            mConnected;
 79445:     bool                            mHaveStatusLine;
 79445:     bool                            mHaveAllHeaders;
 79445:     bool                            mTransactionDone;
 79445:     bool                            mResponseIsComplete;
 79445:     bool                            mDidContentStart;
 79445:     bool                            mNoContent; // expecting an empty entity body
 79445:     bool                            mSentData;
 79445:     bool                            mReceivedData;
 79445:     bool                            mStatusEventPending;
 79445:     bool                            mHasRequestBody;
109252:     bool                            mProxyConnectFailed;
 79445:     bool                            mHttpResponseMatched;
 79445:     bool                            mPreserveStream;
124828:     bool                            mDispatchedAsBlocking;
 43113: 
 43113:     // mClosed           := transaction has been explicitly closed
 43113:     // mTransactionDone  := transaction ran to completion or was interrupted
 43113:     // mResponseComplete := transaction ran to completion
 93845: 
 93845:     // For Restart-In-Progress Functionality
 93845:     bool                            mReportedStart;
 93845:     bool                            mReportedResponseHeader;
 93845: 
 93845:     // protected by nsHttp::GetLock()
 93845:     nsHttpResponseHead             *mForTakeResponseHead;
 94866:     bool                            mResponseHeadTaken;
 93845: 
114431:     // The time when the transaction was submitted to the Connection Manager
114431:     mozilla::TimeStamp              mPendingTime;
114431: 
 93845:     class RestartVerifier 
 93845:     {
 93845: 
 93845:         // When a idemptotent transaction has received part of its response body
 93845:         // and incurs an error it can be restarted. To do this we mark the place
 93845:         // where we stopped feeding the body to the consumer and start the
 93845:         // network call over again. If everything we track (headers, length, etc..)
 93845:         // matches up to the place where we left off then the consumer starts being
 93845:         // fed data again with the new information. This can be done N times up
 93845:         // to the normal restart (i.e. with no response info) limit.
 93845: 
 93845:     public:
 93845:         RestartVerifier()
 93845:             : mContentLength(-1)
 93845:             , mAlreadyProcessed(0)
 94866:             , mToReadBeforeRestart(0)
 93845:             , mSetup(false)
 93845:         {}
 93845:         ~RestartVerifier() {}
 93845:         
108991:         void Set(int64_t contentLength, nsHttpResponseHead *head);
108991:         bool Verify(int64_t contentLength, nsHttpResponseHead *head);
 94866:         bool IsDiscardingContent() { return mToReadBeforeRestart != 0; }
 93845:         bool IsSetup() { return mSetup; }
108991:         int64_t AlreadyProcessed() { return mAlreadyProcessed; }
108991:         void SetAlreadyProcessed(int64_t val) {
 94866:             mAlreadyProcessed = val;
 94866:             mToReadBeforeRestart = val;
 94866:         }
108991:         int64_t ToReadBeforeRestart() { return mToReadBeforeRestart; }
108991:         void HaveReadBeforeRestart(uint32_t amt)
 94866:         {
 94866:             NS_ABORT_IF_FALSE(amt <= mToReadBeforeRestart,
 94866:                               "too large of a HaveReadBeforeRestart deduction");
 94866:             mToReadBeforeRestart -= amt;
 94866:         }
 93845: 
 93845:     private:
 93845:         // This is the data from the first complete response header
 93845:         // used to make sure that all subsequent response headers match
 93845: 
108991:         int64_t                         mContentLength;
 93845:         nsCString                       mETag;
 93845:         nsCString                       mLastModified;
 93845:         nsCString                       mContentRange;
 93845:         nsCString                       mContentEncoding;
 93845:         nsCString                       mTransferEncoding;
 93845: 
 93845:         // This is the amount of data that has been passed to the channel
 93845:         // from previous iterations of the transaction and must therefore
 93845:         // be skipped in the new one.
108991:         int64_t                         mAlreadyProcessed;
 93845: 
 94866:         // The amount of data that must be discarded in the current iteration
 94866:         // (where iteration > 0) to reach the mAlreadyProcessed high water
 94866:         // mark.
108991:         int64_t                         mToReadBeforeRestart;
 93845: 
 93845:         // true when ::Set has been called with a response header
 93845:         bool                            mSetup;
 93845:     } mRestartInProgressVerifier;
 43113: };
 43113: 
 43113: #endif // nsHttpTransaction_h__
