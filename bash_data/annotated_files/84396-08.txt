46790: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
46790: /* vim: set sw=2 ts=8 et tw=80 : */
46790: 
46790: /* ***** BEGIN LICENSE BLOCK *****
46790:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
46790:  *
46790:  * The contents of this file are subject to the Mozilla Public License Version
46790:  * 1.1 (the "License"); you may not use this file except in compliance with
46790:  * the License. You may obtain a copy of the License at
46790:  * http://www.mozilla.org/MPL/
46790:  *
46790:  * Software distributed under the License is distributed on an "AS IS" basis,
46790:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
46790:  * for the specific language governing rights and limitations under the
46790:  * License.
46790:  *
46790:  * The Original Code is mozilla.org code.
46790:  *
46790:  * The Initial Developer of the Original Code is
46790:  *  The Mozilla Foundation.
46790:  * Portions created by the Initial Developer are Copyright (C) 2010
46790:  * the Initial Developer. All Rights Reserved.
46790:  *
46790:  * Contributor(s):
46790:  *   Daniel Witte <dwitte@mozilla.com>
70436:  *   Jason Duell <jduell.mcbugs@gmail.com>
46790:  *
46790:  * Alternatively, the contents of this file may be used under the terms of
46790:  * either the GNU General Public License Version 2 or later (the "GPL"), or
46790:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
46790:  * in which case the provisions of the GPL or the LGPL are applicable instead
46790:  * of those above. If you wish to allow use of your version of this file only
46790:  * under the terms of either the GPL or the LGPL, and not to allow others to
46790:  * use your version of this file under the terms of the MPL, indicate your
46790:  * decision by deleting the provisions above and replace them with the notice
46790:  * and other provisions required by the GPL or the LGPL. If you do not delete
46790:  * the provisions above, a recipient may use your version of this file under
46790:  * the terms of any one of the MPL, the GPL or the LGPL.
46790:  *
46790:  * ***** END LICENSE BLOCK ***** */
46790: 
46790: #ifndef mozilla_net_HttpBaseChannel_h
46790: #define mozilla_net_HttpBaseChannel_h
46790: 
46790: #include "nsHttp.h"
46790: #include "nsAutoPtr.h"
46790: #include "nsHashPropertyBag.h"
46790: #include "nsProxyInfo.h"
46790: #include "nsHttpRequestHead.h"
46790: #include "nsHttpResponseHead.h"
46790: #include "nsHttpConnectionInfo.h"
53988: #include "nsIEncodedChannel.h"
46790: #include "nsIHttpChannel.h"
46790: #include "nsIHttpChannelInternal.h"
46887: #include "nsIUploadChannel.h"
46887: #include "nsIUploadChannel2.h"
46790: #include "nsIProgressEventSink.h"
46790: #include "nsIURI.h"
53988: #include "nsIStringEnumerator.h"
46793: #include "nsISupportsPriority.h"
49375: #include "nsIApplicationCache.h"
49379: #include "nsIResumableChannel.h"
70436: #include "nsITraceableChannel.h"
56337: #include "mozilla/net/NeckoCommon.h"
71646: #include "nsThreadUtils.h"
46790: 
46790: namespace mozilla {
46790: namespace net {
46790: 
46790: /*
46790:  * This class is a partial implementation of nsIHttpChannel.  It contains code
46790:  * shared by nsHttpChannel and HttpChannelChild. 
46790:  * - Note that this class has nothing to do with nsBaseChannel, which is an
46790:  *   earlier effort at a base class for channels that somehow never made it all
46790:  *   the way to the HTTP channel.
46790:  */
46790: class HttpBaseChannel : public nsHashPropertyBag
53988:                       , public nsIEncodedChannel
46790:                       , public nsIHttpChannel
46790:                       , public nsIHttpChannelInternal
46887:                       , public nsIUploadChannel
46887:                       , public nsIUploadChannel2
46793:                       , public nsISupportsPriority
49379:                       , public nsIResumableChannel
70436:                       , public nsITraceableChannel
46790: {
46790: public:
46790:   NS_DECL_ISUPPORTS_INHERITED
46887:   NS_DECL_NSIUPLOADCHANNEL
46887:   NS_DECL_NSIUPLOADCHANNEL2
70436:   NS_DECL_NSITRACEABLECHANNEL
46790: 
46790:   HttpBaseChannel();
46790:   virtual ~HttpBaseChannel();
46790: 
46909:   virtual nsresult Init(nsIURI *aURI, PRUint8 aCaps, nsProxyInfo *aProxyInfo);
46790: 
46790:   // nsIRequest
46790:   NS_IMETHOD GetName(nsACString& aName);
79445:   NS_IMETHOD IsPending(bool *aIsPending);
46790:   NS_IMETHOD GetStatus(nsresult *aStatus);
46790:   NS_IMETHOD GetLoadGroup(nsILoadGroup **aLoadGroup);
46790:   NS_IMETHOD SetLoadGroup(nsILoadGroup *aLoadGroup);
46790:   NS_IMETHOD GetLoadFlags(nsLoadFlags *aLoadFlags);
46790:   NS_IMETHOD SetLoadFlags(nsLoadFlags aLoadFlags);
46790: 
46790:   // nsIChannel
46790:   NS_IMETHOD GetOriginalURI(nsIURI **aOriginalURI);
46790:   NS_IMETHOD SetOriginalURI(nsIURI *aOriginalURI);
46790:   NS_IMETHOD GetURI(nsIURI **aURI);
46805:   NS_IMETHOD GetOwner(nsISupports **aOwner);
46805:   NS_IMETHOD SetOwner(nsISupports *aOwner);
46790:   NS_IMETHOD GetNotificationCallbacks(nsIInterfaceRequestor **aCallbacks);
46790:   NS_IMETHOD SetNotificationCallbacks(nsIInterfaceRequestor *aCallbacks);
46790:   NS_IMETHOD GetContentType(nsACString& aContentType);
46790:   NS_IMETHOD SetContentType(const nsACString& aContentType);
46790:   NS_IMETHOD GetContentCharset(nsACString& aContentCharset);
46790:   NS_IMETHOD SetContentCharset(const nsACString& aContentCharset);
78165:   NS_IMETHOD GetContentDisposition(PRUint32 *aContentDisposition);
78165:   NS_IMETHOD GetContentDispositionFilename(nsAString& aContentDispositionFilename);
78165:   NS_IMETHOD GetContentDispositionHeader(nsACString& aContentDispositionHeader);
51740:   NS_IMETHOD GetContentLength(PRInt32 *aContentLength);
51740:   NS_IMETHOD SetContentLength(PRInt32 aContentLength);
46790:   NS_IMETHOD Open(nsIInputStream **aResult);
46790: 
53988:   // nsIEncodedChannel
79445:   NS_IMETHOD GetApplyConversion(bool *value);
79445:   NS_IMETHOD SetApplyConversion(bool value);
53988:   NS_IMETHOD GetContentEncodings(nsIUTF8StringEnumerator** aEncodings);
53988: 
46790:   // HttpBaseChannel::nsIHttpChannel
46790:   NS_IMETHOD GetRequestMethod(nsACString& aMethod);
46790:   NS_IMETHOD SetRequestMethod(const nsACString& aMethod);
46790:   NS_IMETHOD GetReferrer(nsIURI **referrer);
46790:   NS_IMETHOD SetReferrer(nsIURI *referrer);
46790:   NS_IMETHOD GetRequestHeader(const nsACString& aHeader, nsACString& aValue);
46790:   NS_IMETHOD SetRequestHeader(const nsACString& aHeader, 
79445:                               const nsACString& aValue, bool aMerge);
46790:   NS_IMETHOD VisitRequestHeaders(nsIHttpHeaderVisitor *visitor);
46790:   NS_IMETHOD GetResponseHeader(const nsACString &header, nsACString &value);
46790:   NS_IMETHOD SetResponseHeader(const nsACString& header, 
79445:                                const nsACString& value, bool merge);
46790:   NS_IMETHOD VisitResponseHeaders(nsIHttpHeaderVisitor *visitor);
79445:   NS_IMETHOD GetAllowPipelining(bool *value);
79445:   NS_IMETHOD SetAllowPipelining(bool value);
46790:   NS_IMETHOD GetRedirectionLimit(PRUint32 *value);
46790:   NS_IMETHOD SetRedirectionLimit(PRUint32 value);
79445:   NS_IMETHOD IsNoStoreResponse(bool *value);
79445:   NS_IMETHOD IsNoCacheResponse(bool *value);
46790:   NS_IMETHOD GetResponseStatus(PRUint32 *aValue);
46790:   NS_IMETHOD GetResponseStatusText(nsACString& aValue);
79445:   NS_IMETHOD GetRequestSucceeded(bool *aValue);
46790: 
46790:   // nsIHttpChannelInternal
46790:   NS_IMETHOD GetDocumentURI(nsIURI **aDocumentURI);
46790:   NS_IMETHOD SetDocumentURI(nsIURI *aDocumentURI);
46790:   NS_IMETHOD GetRequestVersion(PRUint32 *major, PRUint32 *minor);
46790:   NS_IMETHOD GetResponseVersion(PRUint32 *major, PRUint32 *minor);
46790:   NS_IMETHOD SetCookie(const char *aCookieHeader);
79445:   NS_IMETHOD GetForceAllowThirdPartyCookie(bool *aForce);
79445:   NS_IMETHOD SetForceAllowThirdPartyCookie(bool aForce);
79445:   NS_IMETHOD GetCanceled(bool *aCanceled);
79445:   NS_IMETHOD GetChannelIsForDownload(bool *aChannelIsForDownload);
79445:   NS_IMETHOD SetChannelIsForDownload(bool aChannelIsForDownload);
63794:   NS_IMETHOD SetCacheKeysRedirectChain(nsTArray<nsCString> *cacheKeys);
69351:   NS_IMETHOD GetLocalAddress(nsACString& addr);
69351:   NS_IMETHOD GetLocalPort(PRInt32* port);
69351:   NS_IMETHOD GetRemoteAddress(nsACString& addr);
69351:   NS_IMETHOD GetRemotePort(PRInt32* port);
63794:   inline void CleanRedirectCacheChainIfNecessary()
63794:   {
63794:       if (mRedirectedCachekeys) {
63794:           delete mRedirectedCachekeys;
63794:           mRedirectedCachekeys = nsnull;
63794:       }
63794:   }
70090:   NS_IMETHOD HTTPUpgrade(const nsACString & aProtocolName,
70090:                          nsIHttpUpgradeListener *aListener); 
46790: 
46793:   // nsISupportsPriority
46793:   NS_IMETHOD GetPriority(PRInt32 *value);
46793:   NS_IMETHOD AdjustPriority(PRInt32 delta);
46793: 
49379:   // nsIResumableChannel
49379:   NS_IMETHOD GetEntityID(nsACString& aEntityID);
49379: 
53988:   class nsContentEncodings : public nsIUTF8StringEnumerator
53988:     {
53988:     public:
53988:         NS_DECL_ISUPPORTS
53988:         NS_DECL_NSIUTF8STRINGENUMERATOR
53988: 
53988:         nsContentEncodings(nsIHttpChannel* aChannel, const char* aEncodingHeader);
53988:         virtual ~nsContentEncodings();
53988:         
53988:     private:
53988:         nsresult PrepareForNext(void);
53988:         
53988:         // We do not own the buffer.  The channel owns it.
53988:         const char* mEncodingHeader;
53988:         const char* mCurStart;  // points to start of current header
53988:         const char* mCurEnd;  // points to end of current header
53988:         
53988:         // Hold a ref to our channel so that it can't go away and take the
53988:         // header with it.
53988:         nsCOMPtr<nsIHttpChannel> mChannel;
53988:         
79445:         bool mReady;
53988:     };
53988: 
54894:     nsHttpResponseHead * GetResponseHead() const { return mResponseHead; }
54894:     nsHttpRequestHead * GetRequestHead() { return &mRequestHead; }
54894: 
69351:     const PRNetAddr& GetSelfAddr() { return mSelfAddr; }
69351:     const PRNetAddr& GetPeerAddr() { return mPeerAddr; }
69351: 
71646: public: /* Necko internal use only... */
71646: 
80420:   bool ShouldRewriteRedirectToGET(PRUint32 httpStatus, nsHttpAtom method);
80420:   bool IsSafeMethod(nsHttpAtom method);
80420:   
46790: protected:
71646: 
71646:   // Handle notifying listener, removing from loadgroup if request failed.
71646:   void     DoNotifyListener();
71646:   virtual void DoNotifyListenerCleanup() = 0;
71646: 
53990:   nsresult ApplyContentConversions();
53990: 
46906:   void AddCookiesToRequest();
49375:   virtual nsresult SetupReplacementChannel(nsIURI *,
49375:                                            nsIChannel *,
79445:                                            bool preserveMethod);
46906: 
46851:   // Helper function to simplify getting notification callbacks.
46851:   template <class T>
46851:   void GetCallback(nsCOMPtr<T> &aResult)
46851:   {
46851:     NS_QueryNotificationCallbacks(mCallbacks, mLoadGroup,
46851:                                   NS_GET_TEMPLATE_IID(T),
46851:                                   getter_AddRefs(aResult));
46851:   }
46851: 
46790:   nsCOMPtr<nsIURI>                  mURI;
46790:   nsCOMPtr<nsIURI>                  mOriginalURI;
46790:   nsCOMPtr<nsIURI>                  mDocumentURI;
46790:   nsCOMPtr<nsIStreamListener>       mListener;
46790:   nsCOMPtr<nsISupports>             mListenerContext;
46790:   nsCOMPtr<nsILoadGroup>            mLoadGroup;
46805:   nsCOMPtr<nsISupports>             mOwner;
46790:   nsCOMPtr<nsIInterfaceRequestor>   mCallbacks;
46790:   nsCOMPtr<nsIProgressEventSink>    mProgressSink;
46790:   nsCOMPtr<nsIURI>                  mReferrer;
49375:   nsCOMPtr<nsIApplicationCache>     mApplicationCache;
46790: 
46790:   nsHttpRequestHead                 mRequestHead;
46887:   nsCOMPtr<nsIInputStream>          mUploadStream;
46790:   nsAutoPtr<nsHttpResponseHead>     mResponseHead;
46790:   nsRefPtr<nsHttpConnectionInfo>    mConnectionInfo;
46790: 
46790:   nsCString                         mSpec; // ASCII encoded URL spec
46790:   nsCString                         mContentTypeHint;
46790:   nsCString                         mContentCharsetHint;
46906:   nsCString                         mUserSetCookieHeader;
46790: 
69351:   PRNetAddr                         mSelfAddr;
69351:   PRNetAddr                         mPeerAddr;
69351: 
70090:   // HTTP Upgrade Data
70090:   nsCString                        mUpgradeProtocol;
70090:   nsCOMPtr<nsIHttpUpgradeListener> mUpgradeProtocolCallback;
70090: 
49379:   // Resumable channel specific data
49379:   nsCString                         mEntityID;
49379:   PRUint64                          mStartPos;
49379: 
46790:   nsresult                          mStatus;
46790:   PRUint32                          mLoadFlags;
46793:   PRInt16                           mPriority;
46790:   PRUint8                           mCaps;
46790:   PRUint8                           mRedirectionLimit;
46790: 
53988:   PRUint32                          mApplyConversion            : 1;
49375:   PRUint32                          mCanceled                   : 1;
49375:   PRUint32                          mIsPending                  : 1;
49375:   PRUint32                          mWasOpened                  : 1;
49375:   PRUint32                          mResponseHeadersModified    : 1;
49375:   PRUint32                          mAllowPipelining            : 1;
49375:   PRUint32                          mForceAllowThirdPartyCookie : 1;
49375:   PRUint32                          mUploadStreamHasHeaders     : 1;
49375:   PRUint32                          mInheritApplicationCache    : 1;
49375:   PRUint32                          mChooseApplicationCache     : 1;
49375:   PRUint32                          mLoadedFromApplicationCache : 1;
52366:   PRUint32                          mChannelIsForDownload       : 1;
70436:   PRUint32                          mTracingEnabled             : 1;
70188:   // True if timing collection is enabled
70188:   PRUint32                          mTimingEnabled              : 1;
63794: 
71646:   // Current suspension depth for this channel object
71646:   PRUint32                          mSuspendCount;
71646: 
63794:   nsTArray<nsCString>              *mRedirectedCachekeys;
46790: };
46790: 
71646: // Share some code while working around C++'s absurd inability to handle casting
71646: // of member functions between base/derived types.
71646: // - We want to store member function pointer to call at resume time, but one
71646: //   such function--HandleAsyncAbort--we want to share between the
71646: //   nsHttpChannel/HttpChannelChild.  Can't define it in base class, because
71646: //   then we'd have to cast member function ptr between base/derived class
71646: //   types.  Sigh...
71646: template <class T>
71646: class HttpAsyncAborter
71646: {
71646: public:
71646:   HttpAsyncAborter(T *derived) : mThis(derived), mCallOnResume(0) {}
71646: 
71646:   // Aborts channel: calls OnStart/Stop with provided status, removes channel
71646:   // from loadGroup.
71646:   nsresult AsyncAbort(nsresult status);
71646: 
71646:   // Does most the actual work.
71646:   void HandleAsyncAbort();
71646: 
71646:   // AsyncCall calls a member function asynchronously (via an event).
71646:   // retval isn't refcounted and is set only when event was successfully
71646:   // posted, the event is returned for the purpose of cancelling when needed
71646:   nsresult AsyncCall(void (T::*funcPtr)(),
71646:                      nsRunnableMethod<T> **retval = nsnull);
71646: private:
71646:   T *mThis;
71646: 
71646: protected:
71646:   // Function to be called at resume time
71646:   void (T::* mCallOnResume)(void);
71646: };
71646: 
71646: template <class T>
71646: nsresult HttpAsyncAborter<T>::AsyncAbort(nsresult status)
71646: {
71646:   LOG(("HttpAsyncAborter::AsyncAbort [this=%p status=%x]\n", mThis, status));
71646: 
71646:   mThis->mStatus = status;
80486:   mThis->mIsPending = false;
71646: 
71646:   // if this fails?  Callers ignore our return value anyway....
71646:   return AsyncCall(&T::HandleAsyncAbort);
71646: }
71646: 
71646: // Each subclass needs to define its own version of this (which just calls this
71646: // base version), else we wind up casting base/derived member function ptrs
71646: template <class T>
71646: inline void HttpAsyncAborter<T>::HandleAsyncAbort()
71646: {
71646:   NS_PRECONDITION(!mCallOnResume, "How did that happen?");
71646: 
71646:   if (mThis->mSuspendCount) {
71646:     LOG(("Waiting until resume to do async notification [this=%p]\n",
71646:          mThis));
71646:     mCallOnResume = &T::HandleAsyncAbort;
71646:     return;
71646:   }
71646: 
71646:   mThis->DoNotifyListener();
71646: 
71646:   // finally remove ourselves from the load group.
71646:   if (mThis->mLoadGroup)
71646:     mThis->mLoadGroup->RemoveRequest(mThis, nsnull, mThis->mStatus);
71646: }
71646: 
71646: template <class T>
71646: nsresult HttpAsyncAborter<T>::AsyncCall(void (T::*funcPtr)(),
71646:                                    nsRunnableMethod<T> **retval)
71646: {
71646:   nsresult rv;
71646: 
71646:   nsRefPtr<nsRunnableMethod<T> > event = NS_NewRunnableMethod(mThis, funcPtr);
71646:   rv = NS_DispatchToCurrentThread(event);
71646:   if (NS_SUCCEEDED(rv) && retval) {
71646:     *retval = event;
71646:   }
71646: 
71646:   return rv;
71646: }
46790: 
46790: } // namespace net
46790: } // namespace mozilla
46790: 
46790: #endif // mozilla_net_HttpBaseChannel_h
