42611: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
42611:  * ***** BEGIN LICENSE BLOCK *****
42611:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
42611:  *
42611:  * The contents of this file are subject to the Mozilla Public License Version
42611:  * 1.1 (the "License"); you may not use this file except in compliance with
42611:  * the License. You may obtain a copy of the License at
42611:  * http://www.mozilla.org/MPL/
42611:  *
42611:  * Software distributed under the License is distributed on an "AS IS" basis,
42611:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
42611:  * for the specific language governing rights and limitations under the
42611:  * License.
42611:  *
42611:  * The Original Code is Mozilla Corporation code.
42611:  *
42611:  * The Initial Developer of the Original Code is Mozilla Foundation.
42611:  * Portions created by the Initial Developer are Copyright (C) 2009
42611:  * the Initial Developer. All Rights Reserved.
42611:  *
42611:  * Contributor(s):
42611:  *   Bas Schouten <bschouten@mozilla.com>
42611:  *
42611:  * Alternatively, the contents of this file may be used under the terms of
42611:  * either the GNU General Public License Version 2 or later (the "GPL"), or
42611:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
42611:  * in which case the provisions of the GPL or the LGPL are applicable instead
42611:  * of those above. If you wish to allow use of your version of this file only
42611:  * under the terms of either the GPL or the LGPL, and not to allow others to
42611:  * use your version of this file under the terms of the MPL, indicate your
42611:  * decision by deleting the provisions above and replace them with the notice
42611:  * and other provisions required by the GPL or the LGPL. If you do not delete
42611:  * the provisions above, a recipient may use your version of this file under
42611:  * the terms of any one of the MPL, the GPL or the LGPL.
42611:  *
42611:  * ***** END LICENSE BLOCK ***** */
42611: 
42611: #ifndef GFX_LAYERMANAGERD3D9_H
42611: #define GFX_LAYERMANAGERD3D9_H
42611: 
42611: #include "Layers.h"
42611: 
42611: #include <windows.h>
42611: #include <d3d9.h>
42611: 
42611: #include "gfxContext.h"
42611: #include "nsIWidget.h"
42611: 
49316: #include "DeviceManagerD3D9.h"
49316: 
42611: namespace mozilla {
42611: namespace layers {
42611: 
52175: extern cairo_user_data_key_t gKeyD3D9Texture;
52175: 
42611: class LayerD3D9;
42611: class ThebesLayerD3D9;
42611: 
52176: /**
52176:  * This structure is used to pass rectangles to our shader constant. We can use
52176:  * this for passing rectangular areas to SetVertexShaderConstant. In the format
52176:  * of a 4 component float(x,y,width,height). Our vertex shader can then use
52176:  * this to construct rectangular positions from the 0,0-1,1 quad that we source
52176:  * it with.
52176:  */
52176: struct ShaderConstantRect
52176: {
52176:   float mX, mY, mWidth, mHeight;
52176:   ShaderConstantRect(float aX, float aY, float aWidth, float aHeight)
52176:     : mX(aX), mY(aY), mWidth(aWidth), mHeight(aHeight)
52176:   { }
52176: 
52176:   // For easy passing to SetVertexShaderConstantF.
52176:   operator float* () { return &mX; }
52176: };
52176: 
42611: /*
42611:  * This is the LayerManager used for Direct3D 9. For now this will render on
42611:  * the main thread.
42611:  */
42611: class THEBES_API LayerManagerD3D9 : public LayerManager {
42611: public:
42611:   LayerManagerD3D9(nsIWidget *aWidget);
42611:   virtual ~LayerManagerD3D9();
42611: 
42611:   /*
42611:    * Initializes the layer manager, this is when the layer manager will
42611:    * actually access the device and attempt to create the swap chain used
42611:    * to draw to the window. If this method fails the device cannot be used.
42611:    * This function is not threadsafe.
42611:    *
42611:    * \return True is initialization was succesful, false when it was not.
42611:    */
42611:   PRBool Initialize();
42611: 
42611:   /*
42611:    * Sets the clipping region for this layer manager. This is important on
42611:    * windows because using OGL we no longer have GDI's native clipping. Therefor
42611:    * widget must tell us what part of the screen is being invalidated,
42611:    * and we should clip to this.
42611:    *
42611:    * \param aClippingRegion Region to clip to. Setting an empty region
42611:    * will disable clipping.
42611:    */
42611:   void SetClippingRegion(const nsIntRegion& aClippingRegion);
42611: 
42611:   /*
42611:    * LayerManager implementation.
42611:    */
42611:   void BeginTransaction();
42611: 
42611:   void BeginTransactionWithTarget(gfxContext* aTarget);
42611: 
42611:   void EndConstruction();
42611: 
42611:   struct CallbackInfo {
42611:     DrawThebesLayerCallback Callback;
42611:     void *CallbackData;
42611:   };
42611: 
42611:   void EndTransaction(DrawThebesLayerCallback aCallback,
42611:                       void* aCallbackData);
42611: 
42611:   const CallbackInfo &GetCallbackInfo() { return mCurrentCallbackInfo; }
42611: 
42611:   void SetRoot(Layer* aLayer);
42611: 
42611:   virtual already_AddRefed<ThebesLayer> CreateThebesLayer();
42611: 
42611:   virtual already_AddRefed<ContainerLayer> CreateContainerLayer();
42611: 
42611:   virtual already_AddRefed<ImageLayer> CreateImageLayer();
42611: 
42611:   virtual already_AddRefed<ColorLayer> CreateColorLayer();
42611: 
42611:   virtual already_AddRefed<CanvasLayer> CreateCanvasLayer();
42611: 
42611:   virtual already_AddRefed<ImageContainer> CreateImageContainer();
42611: 
52175:   virtual already_AddRefed<gfxASurface>
52175:     CreateOptimalSurface(const gfxIntSize &aSize,
52175:                          gfxASurface::gfxImageFormat imageFormat);
52175: 
42611:   virtual LayersBackend GetBackendType() { return LAYERS_D3D9; }
51975:   virtual void GetBackendName(nsAString& name) { name.AssignLiteral("Direct3D 9"); }
42611: 
42611:   /*
42611:    * Helper methods.
42611:    */
42611:   void SetClippingEnabled(PRBool aEnabled);
42611: 
49316:   void SetShaderMode(DeviceManagerD3D9::ShaderMode aMode)
49316:     { mDeviceManager->SetShaderMode(aMode); }
42611: 
49316:   IDirect3DDevice9 *device() const { return mDeviceManager->device(); }
49316:   DeviceManagerD3D9 *deviceManager() const { return mDeviceManager; }
42611: 
51527:   /** 
51527:    * Return pointer to the Nv3DVUtils instance. Re-direct to mDeviceManager.
51527:    */ 
51527:   Nv3DVUtils *GetNv3DVUtils()  { return mDeviceManager ? mDeviceManager->GetNv3DVUtils() : NULL; } 
51527: 
51527:   /** 
51527:    * Indicate whether 3D is enabled or not 
51527:    */ 
51527:   PRBool Is3DEnabled() { return mIs3DEnabled; } 
51527: 
50600:   static void OnDeviceManagerDestroy(DeviceManagerD3D9 *aDeviceManager) {
50600:     if(aDeviceManager == mDeviceManager)
50600:       mDeviceManager = nsnull;
50600:   }
50600: 
51960: #ifdef MOZ_LAYERS_HAVE_LOG
51960:   virtual const char* Name() const { return "D3D9"; }
51960: #endif // MOZ_LAYERS_HAVE_LOG
51960: 
42611: private:
49316:   /* Device manager instance */
49316:   static DeviceManagerD3D9 *mDeviceManager;
49316: 
49316:   /* Swap chain associated with this layer manager */
49316:   nsRefPtr<SwapChainD3D9> mSwapChain;
42611: 
42611:   /* Widget associated with this layer manager */
42611:   nsIWidget *mWidget;
49316: 
42611:   /*
42611:    * Context target, NULL when drawing directly to our swap chain.
42611:    */
42611:   nsRefPtr<gfxContext> mTarget;
42611: 
42611:   /* Callback info for current transaction */
42611:   CallbackInfo mCurrentCallbackInfo;
42611: 
51527:   /* Flag that indicates whether 3D is enabled or not*/ 
51527:   PRBool mIs3DEnabled; 
51527: 
42611:   /*
42611:    * Region we're clipping our current drawing to.
42611:    */
42611:   nsIntRegion mClippingRegion;
49316: 
42611:   /*
42611:    * Render the current layer tree to the active target.
42611:    */
42611:   void Render();
49316: 
42611:   /*
42611:    * Setup the pipeline.
42611:    */
42611:   void SetupPipeline();
49316: 
42611:   /*
42611:    * Copies the content of our backbuffer to the set transaction target.
42611:    */
42611:   void PaintToTarget();
42611: 
42611: };
42611: 
42611: /*
42611:  * General information and tree management for OGL layers.
42611:  */
42611: class LayerD3D9
42611: {
42611: public:
42611:   LayerD3D9(LayerManagerD3D9 *aManager);
42611: 
42611:   virtual LayerD3D9 *GetFirstChildD3D9() { return nsnull; }
42611: 
42611:   void SetFirstChild(LayerD3D9 *aParent);
42611: 
42611:   virtual Layer* GetLayer() = 0;
42611: 
42611:   virtual void RenderLayer() = 0;
42611: 
53783:   /* This function may be used on device resets to clear all VRAM resources
53783:    * that a layer might be using.
53783:    */
53783:   virtual void CleanResources() {}
53783: 
42611:   IDirect3DDevice9 *device() const { return mD3DManager->device(); }
42611: protected:
42611:   LayerManagerD3D9 *mD3DManager;
42611: };
42611: 
42611: } /* layers */
42611: } /* mozilla */
42611: 
42611: #endif /* GFX_LAYERMANAGERD3D9_H */
