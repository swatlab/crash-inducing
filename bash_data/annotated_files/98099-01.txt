97199: /*-*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
97199: /* This Source Code Form is subject to the terms of the Mozilla Public
97199:  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
97199:  * You can obtain one at http://mozilla.org/MPL/2.0/. */
97199: 
97199: #include "MediaStreamGraph.h"
97199: 
97199: #include "mozilla/Monitor.h"
97199: #include "mozilla/TimeStamp.h"
97199: #include "AudioSegment.h"
97199: #include "VideoSegment.h"
97199: #include "nsContentUtils.h"
97199: #include "nsIAppShell.h"
97199: #include "nsIObserver.h"
97199: #include "nsServiceManagerUtils.h"
97199: #include "nsWidgetsCID.h"
97199: #include "nsXPCOMCIDInternal.h"
97199: #include "prlog.h"
97199: #include "VideoUtils.h"
97199: 
97199: using namespace mozilla::layers;
97199: 
97199: namespace mozilla {
97199: 
97199: namespace {
97199: 
97199: #ifdef PR_LOGGING
97199: PRLogModuleInfo* gMediaStreamGraphLog;
97199: #define LOG(type, msg) PR_LOG(gMediaStreamGraphLog, type, msg)
97199: #else
97199: #define LOG(type, msg)
97199: #endif
97199: 
97199: /**
97199:  * Assume we can run an iteration of the MediaStreamGraph loop in this much time
97199:  * or less.
97199:  * We try to run the control loop at this rate.
97199:  */
97199: const int MEDIA_GRAPH_TARGET_PERIOD_MS = 10;
97199: 
97199: /**
97199:  * Assume that we might miss our scheduled wakeup of the MediaStreamGraph by
97199:  * this much.
97199:  */
97199: const int SCHEDULE_SAFETY_MARGIN_MS = 10;
97199: 
97199: /**
97199:  * Try have this much audio buffered in streams and queued to the hardware.
97199:  * The maximum delay to the end of the next control loop
97199:  * is 2*MEDIA_GRAPH_TARGET_PERIOD_MS + SCHEDULE_SAFETY_MARGIN_MS.
97199:  * There is no point in buffering more audio than this in a stream at any
97199:  * given time (until we add processing).
97199:  * This is not optimal yet.
97199:  */
97199: const int AUDIO_TARGET_MS = 2*MEDIA_GRAPH_TARGET_PERIOD_MS +
97199:     SCHEDULE_SAFETY_MARGIN_MS;
97199: 
97199: /**
97199:  * Try have this much video buffered. Video frames are set
97199:  * near the end of the iteration of the control loop. The maximum delay
97199:  * to the setting of the next video frame is 2*MEDIA_GRAPH_TARGET_PERIOD_MS +
97199:  * SCHEDULE_SAFETY_MARGIN_MS. This is not optimal yet.
97199:  */
97199: const int VIDEO_TARGET_MS = 2*MEDIA_GRAPH_TARGET_PERIOD_MS +
97199:     SCHEDULE_SAFETY_MARGIN_MS;
97199: 
97199: /**
97199:  * A per-stream update message passed from the media graph thread to the
97199:  * main thread.
97199:  */
97199: struct StreamUpdate {
97199:   PRInt64 mGraphUpdateIndex;
97199:   nsRefPtr<MediaStream> mStream;
97199:   StreamTime mNextMainThreadCurrentTime;
97199:   bool mNextMainThreadFinished;
97199: };
97199: 
97199: /**
97199:  * This represents a message passed from the main thread to the graph thread.
97199:  * A ControlMessage always references a particular affected stream.
97199:  */
97199: class ControlMessage {
97199: public:
97199:   ControlMessage(MediaStream* aStream) : mStream(aStream)
97199:   {
97199:     MOZ_COUNT_CTOR(ControlMessage);
97199:   }
97199:   // All these run on the graph thread
97199:   virtual ~ControlMessage()
97199:   {
97199:     MOZ_COUNT_DTOR(ControlMessage);
97199:   }
97199:   // Executed before we know what the action time for this message will be.
97199:   // Call NoteStreamAffected on the stream whose output will be
97199:   // modified by this message. Default implementation calls
97199:   // NoteStreamAffected(mStream).
97199:   virtual void UpdateAffectedStream();
97199:   // Executed after we know what the action time for this message will be.
97199:   virtual void Process() {}
97199:   // When we're shutting down the application, most messages are ignored but
97199:   // some cleanup messages should still be processed (on the main thread).
97199:   virtual void ProcessDuringShutdown() {}
97199: 
97199: protected:
97199:   // We do not hold a reference to mStream. The main thread will be holding
97199:   // a reference to the stream while this message is in flight. The last message
97199:   // referencing a stream is the Destroy message for that stream.
97199:   MediaStream* mStream;
97199: };
97199: 
97199: }
97199: 
97199: /**
97199:  * The implementation of a media stream graph. This class is private to this
97199:  * file. It's not in the anonymous namespace because MediaStream needs to
97199:  * be able to friend it.
97199:  *
97199:  * Currently we only have one per process.
97199:  */
97199: class MediaStreamGraphImpl : public MediaStreamGraph {
97199: public:
97199:   MediaStreamGraphImpl();
97199:   ~MediaStreamGraphImpl()
97199:   {
97199:     NS_ASSERTION(IsEmpty(),
97199:                  "All streams should have been destroyed by messages from the main thread");
97199:     LOG(PR_LOG_DEBUG, ("MediaStreamGraph %p destroyed", this));
97199:   }
97199: 
97199:   // Main thread only.
97199:   /**
97199:    * This runs every time we need to sync state from the media graph thread
97199:    * to the main thread while the main thread is not in the middle
97199:    * of a script. It runs during a "stable state" (per HTML5) or during
97199:    * an event posted to the main thread.
97199:    */
97199:   void RunInStableState();
97199:   /**
97199:    * Ensure a runnable to run RunInStableState is posted to the appshell to
97199:    * run at the next stable state (per HTML5).
97199:    * See EnsureStableStateEventPosted.
97199:    */
97199:   void EnsureRunInStableState();
97199:   /**
97199:    * Called to apply a StreamUpdate to its stream.
97199:    */
97199:   void ApplyStreamUpdate(StreamUpdate* aUpdate);
97199:   /**
97199:    * Append a ControlMessage to the message queue. This queue is drained
97199:    * during RunInStableState; the messages will run on the graph thread.
97199:    */
97199:   void AppendMessage(ControlMessage* aMessage);
97199:   /**
97199:    * Make this MediaStreamGraph enter forced-shutdown state. This state
97199:    * will be noticed by the media graph thread, which will shut down all streams
97199:    * and other state controlled by the media graph thread.
97199:    * This is called during application shutdown.
97199:    */
97199:   void ForceShutDown();
97199:   /**
97199:    * Shutdown() this MediaStreamGraph's threads and return when they've shut down.
97199:    */
97199:   void ShutdownThreads();
97199: 
97199:   // The following methods run on the graph thread (or possibly the main thread if
97199:   // mLifecycleState > LIFECYCLE_RUNNING)
97199:   /**
97199:    * Runs main control loop on the graph thread. Normally a single invocation
97199:    * of this runs for the entire lifetime of the graph thread.
97199:    */
97199:   void RunThread();
97199:   /**
97199:    * Call this to indicate that another iteration of the control loop is
97199:    * required on its regular schedule. The monitor must not be held.
97199:    */
97199:   void EnsureNextIteration();
97199:   /**
97199:    * As above, but with the monitor already held.
97199:    */
97199:   void EnsureNextIterationLocked(MonitorAutoLock& aLock);
97199:   /**
97199:    * Call this to indicate that another iteration of the control loop is
97199:    * required immediately. The monitor must already be held.
97199:    */
97199:   void EnsureImmediateWakeUpLocked(MonitorAutoLock& aLock);
97199:   /**
97199:    * Ensure there is an event posted to the main thread to run RunInStableState.
97199:    * mMonitor must be held.
97199:    * See EnsureRunInStableState
97199:    */
97199:   void EnsureStableStateEventPosted();
97199:   /**
97199:    * Generate messages to the main thread to update it for all state changes.
97199:    * mMonitor must be held.
97199:    */
97199:   void PrepareUpdatesToMainThreadState();
97199:   // The following methods are the various stages of RunThread processing.
97199:   /**
97199:    * Compute a new current time for the graph and advance all on-graph-thread
97199:    * state to the new current time.
97199:    */
97199:   void UpdateCurrentTime();
97199:   /**
97199:    * Update mLastActionTime to the time at which the current set of messages
97199:    * will take effect.
97199:    */
97199:   void ChooseActionTime();
97199:   /**
97201:    * Extract any state updates pending in aStream, and apply them.
97201:    */
97201:   void ExtractPendingInput(SourceMediaStream* aStream);
97201:   /**
97201:    * Update "have enough data" flags in aStream.
97201:    */
97201:   void UpdateBufferSufficiencyState(SourceMediaStream* aStream);
97201:   /**
97199:    * Compute the blocking states of streams from mBlockingDecisionsMadeUntilTime
97199:    * until the desired future time (determined by heuristic).
97199:    * Updates mBlockingDecisionsMadeUntilTime and sets MediaStream::mBlocked
97199:    * for all streams.
97199:    */
97199:   void RecomputeBlocking();
97199:   // The following methods are used to help RecomputeBlocking.
97199:   /**
97199:    * Mark a stream blocked at time aTime. If this results in decisions that need
97199:    * to be revisited at some point in the future, *aEnd will be reduced to the
97199:    * first time in the future to recompute those decisions.
97199:    */
97199:   void MarkStreamBlocked(MediaStream* aStream, GraphTime aTime, GraphTime* aEnd);
97199:   /**
97199:    * Recompute blocking for all streams for the interval starting at aTime.
97199:    * If this results in decisions that need to be revisited at some point
97199:    * in the future, *aEnd will be reduced to the first time in the future to
97199:    * recompute those decisions.
97199:    */
97199:   void RecomputeBlockingAt(GraphTime aTime, GraphTime aEndBlockingDecisions,
97199:                            GraphTime* aEnd);
97199:   /**
97199:    * Returns true if aStream will underrun at aTime for its own playback.
97199:    * aEndBlockingDecisions is when we plan to stop making blocking decisions.
97199:    * *aEnd will be reduced to the first time in the future to recompute these
97199:    * decisions.
97199:    */
97199:   bool WillUnderrun(MediaStream* aStream, GraphTime aTime,
97199:                     GraphTime aEndBlockingDecisions, GraphTime* aEnd);
97199:   /**
97199:    * Return true if there is an explicit blocker set from the current time
97199:    * indefinitely far into the future.
97199:    */
97199:   bool IsAlwaysExplicitlyBlocked(MediaStream* aStream);
97199:   /**
97199:    * Given a graph time aTime, convert it to a stream time taking into
97199:    * account the time during which aStream is scheduled to be blocked.
97199:    */
97199:   StreamTime GraphTimeToStreamTime(MediaStream* aStream, StreamTime aTime);
97199:   enum {
97199:     INCLUDE_TRAILING_BLOCKED_INTERVAL = 0x01
97199:   };
97199:   /**
97199:    * Given a stream time aTime, convert it to a graph time taking into
97199:    * account the time during which aStream is scheduled to be blocked.
97199:    * aTime must be <= mBlockingDecisionsMadeUntilTime since blocking decisions
97199:    * are only known up to that point.
97199:    * If aTime is exactly at the start of a blocked interval, then the blocked
97199:    * interval is included in the time returned if and only if
97199:    * aFlags includes INCLUDE_TRAILING_BLOCKED_INTERVAL.
97199:    */
97199:   GraphTime StreamTimeToGraphTime(MediaStream* aStream, StreamTime aTime,
97199:                                   PRUint32 aFlags = 0);
97199:   /**
97199:    * Get the current audio position of the stream's audio output.
97199:    */
97199:   GraphTime GetAudioPosition(MediaStream* aStream);
97199:   /**
97199:    * If aStream needs an audio stream but doesn't have one, create it.
97199:    * If aStream doesn't need an audio stream but has one, destroy it.
97199:    */
97199:   void CreateOrDestroyAudioStream(GraphTime aAudioOutputStartTime,
97199:                                   MediaStream* aStream);
97199:   /**
97199:    * Update aStream->mFirstActiveTracks.
97199:    */
97199:   void UpdateFirstActiveTracks(MediaStream* aStream);
97199:   /**
97199:    * Queue audio (mix of stream audio and silence for blocked intervals)
97199:    * to the audio output stream.
97199:    */
97199:   void PlayAudio(MediaStream* aStream, GraphTime aFrom, GraphTime aTo);
97199:   /**
97199:    * Set the correct current video frame for stream aStream.
97199:    */
97199:   void PlayVideo(MediaStream* aStream);
97199:   /**
97199:    * No more data will be forthcoming for aStream. The stream will end
97199:    * at the current buffer end point. The StreamBuffer's tracks must be
97199:    * explicitly set to finished by the caller.
97199:    */
97199:   void FinishStream(MediaStream* aStream);
97199:   /**
97199:    * Compute how much stream data we would like to buffer for aStream.
97199:    */
97199:   StreamTime GetDesiredBufferEnd(MediaStream* aStream);
97199:   /**
97199:    * Returns true when there are no active streams.
97199:    */
97199:   bool IsEmpty() { return mStreams.IsEmpty(); }
97199: 
97199:   // For use by control messages
97199:   /**
97199:    * Identify which graph update index we are currently processing.
97199:    */
97199:   PRInt64 GetProcessingGraphUpdateIndex() { return mProcessingGraphUpdateIndex; }
97199:   /**
97199:    * Marks aStream as affected by a change in its output at desired time aTime
97199:    * (in the timeline of aStream). The change may not actually happen at this time,
97199:    * it may be delayed until later if there is buffered data we can't change.
97199:    */
97199:   void NoteStreamAffected(MediaStream* aStream, double aTime);
97199:   /**
97199:    * Marks aStream as affected by a change in its output at the earliest
97199:    * possible time.
97199:    */
97199:   void NoteStreamAffected(MediaStream* aStream);
97199:   /**
97199:    * Add aStream to the graph and initializes its graph-specific state.
97199:    */
97199:   void AddStream(MediaStream* aStream);
97199:   /**
97199:    * Remove aStream from the graph. Ensures that pending messages about the
97199:    * stream back to the main thread are flushed.
97199:    */
97199:   void RemoveStream(MediaStream* aStream);
97199: 
97199:   /**
97199:    * Compute the earliest time at which an action be allowed to occur on any
97199:    * stream. Actions cannot be earlier than the previous action time, and
97199:    * cannot affect already-committed blocking decisions (and associated
97199:    * buffered audio).
97199:    */
97199:   GraphTime GetEarliestActionTime()
97199:   {
97199:     return NS_MAX(mCurrentTime, NS_MAX(mLastActionTime, mBlockingDecisionsMadeUntilTime));
97199:   }
97199: 
97199:   // Data members
97199: 
97199:   /**
97199:    * Media graph thread.
97199:    * Readonly after initialization on the main thread.
97199:    */
97199:   nsCOMPtr<nsIThread> mThread;
97199: 
97199:   // The following state is managed on the graph thread only, unless
97199:   // mLifecycleState > LIFECYCLE_RUNNING in which case the graph thread
97199:   // is not running and this state can be used from the main thread.
97199: 
97199:   nsTArray<nsRefPtr<MediaStream> > mStreams;
97199:   /**
97199:    * The time the last action was deemed to have occurred. This could be
97199:    * later than mCurrentTime if actions have to be delayed during data
97199:    * buffering, or before mCurrentTime if mCurrentTime has advanced since
97199:    * the last action happened. In ControlMessage::Process calls,
97199:    * mLastActionTime has always been updated to be >= mCurrentTime.
97199:    */
97199:   GraphTime mLastActionTime;
97199:   /**
97199:    * The current graph time for the current iteration of the RunThread control
97199:    * loop.
97199:    */
97199:   GraphTime mCurrentTime;
97199:   /**
97199:    * Blocking decisions have been made up to this time. We also buffer audio
97199:    * up to this time.
97199:    */
97199:   GraphTime mBlockingDecisionsMadeUntilTime;
97199:   /**
97199:    * This is only used for logging.
97199:    */
97199:   TimeStamp mInitialTimeStamp;
97199:   /**
97199:    * The real timestamp of the latest run of UpdateCurrentTime.
97199:    */
97199:   TimeStamp mCurrentTimeStamp;
97199:   /**
97199:    * Which update batch we are currently processing.
97199:    */
97199:   PRInt64 mProcessingGraphUpdateIndex;
97199: 
97199:   // mMonitor guards the data below.
97199:   // MediaStreamGraph normally does its work without holding mMonitor, so it is
97199:   // not safe to just grab mMonitor from some thread and start monkeying with
97199:   // the graph. Instead, communicate with the graph thread using provided
97199:   // mechanisms such as the ControlMessage queue.
97199:   Monitor mMonitor;
97199: 
97199:   // Data guarded by mMonitor (must always be accessed with mMonitor held,
97199:   // regardless of the value of mLifecycleState.
97199: 
97199:   /**
97199:    * State to copy to main thread
97199:    */
97199:   nsTArray<StreamUpdate> mStreamUpdates;
97199:   /**
97199:    * Runnables to run after the next update to main thread state.
97199:    */
97199:   nsTArray<nsCOMPtr<nsIRunnable> > mUpdateRunnables;
97199:   struct MessageBlock {
97199:     PRInt64 mGraphUpdateIndex;
97199:     nsTArray<nsAutoPtr<ControlMessage> > mMessages;
97199:   };
97199:   /**
97199:    * A list of batches of messages to process. Each batch is processed
97199:    * as an atomic unit.
97199:    */
97199:   nsTArray<MessageBlock> mMessageQueue;
97199:   /**
97199:    * This enum specifies where this graph is in its lifecycle. This is used
97199:    * to control shutdown.
97199:    * Shutdown is tricky because it can happen in two different ways:
97199:    * 1) Shutdown due to inactivity. RunThread() detects that it has no
97199:    * pending messages and no streams, and exits. The next RunInStableState()
97199:    * checks if there are new pending messages from the main thread (true only
97199:    * if new stream creation raced with shutdown); if there are, it revives
97199:    * RunThread(), otherwise it commits to shutting down the graph. New stream
97199:    * creation after this point will create a new graph. An async event is
97199:    * dispatched to Shutdown() the graph's threads and then delete the graph
97199:    * object.
97199:    * 2) Forced shutdown at application shutdown. A flag is set, RunThread()
97199:    * detects the flag and exits, the next RunInStableState() detects the flag,
97199:    * and dispatches the async event to Shutdown() the graph's threads. However
97199:    * the graph object is not deleted. New messages for the graph are processed
97199:    * synchronously on the main thread if necessary. When the last stream is
97199:    * destroyed, the graph object is deleted.
97199:    */
97199:   enum LifecycleState {
97199:     // The graph thread hasn't started yet.
97199:     LIFECYCLE_THREAD_NOT_STARTED,
97199:     // RunThread() is running normally.
97199:     LIFECYCLE_RUNNING,
97199:     // In the following states, the graph thread is not running so
97199:     // all "graph thread only" state in this class can be used safely
97199:     // on the main thread.
97199:     // RunThread() has exited and we're waiting for the next
97199:     // RunInStableState(), at which point we can clean up the main-thread
97199:     // side of the graph.
97199:     LIFECYCLE_WAITING_FOR_MAIN_THREAD_CLEANUP,
97199:     // RunInStableState() posted a ShutdownRunnable, and we're waiting for it
97199:     // to shut down the graph thread(s).
97199:     LIFECYCLE_WAITING_FOR_THREAD_SHUTDOWN,
97199:     // Graph threads have shut down but we're waiting for remaining streams
97199:     // to be destroyed. Only happens during application shutdown since normally
97199:     // we'd only shut down a graph when it has no streams.
97199:     LIFECYCLE_WAITING_FOR_STREAM_DESTRUCTION
97199:   };
97199:   LifecycleState mLifecycleState;
97199:   /**
97199:    * This enum specifies the wait state of the graph thread.
97199:    */
97199:   enum WaitState {
97199:     // RunThread() is running normally
97199:     WAITSTATE_RUNNING,
97199:     // RunThread() is paused waiting for its next iteration, which will
97199:     // happen soon
97199:     WAITSTATE_WAITING_FOR_NEXT_ITERATION,
97199:     // RunThread() is paused indefinitely waiting for something to change
97199:     WAITSTATE_WAITING_INDEFINITELY,
97199:     // Something has signaled RunThread() to wake up immediately,
97199:     // but it hasn't done so yet
97199:     WAITSTATE_WAKING_UP
97199:   };
97199:   WaitState mWaitState;
97199:   /**
97199:    * True when another iteration of the control loop is required.
97199:    */
97199:   bool mNeedAnotherIteration;
97199:   /**
97199:    * True when we need to do a forced shutdown during application shutdown.
97199:    */
97199:   bool mForceShutDown;
97199:   /**
97199:    * True when we have posted an event to the main thread to run
97199:    * RunInStableState() and the event hasn't run yet.
97199:    */
97199:   bool mPostedRunInStableStateEvent;
97199: 
97199:   // Main thread only
97199: 
97199:   /**
97199:    * Messages posted by the current event loop task. These are forwarded to
97199:    * the media graph thread during RunInStableState. We can't forward them
97199:    * immediately because we want all messages between stable states to be
97199:    * processed as an atomic batch.
97199:    */
97199:   nsTArray<nsAutoPtr<ControlMessage> > mCurrentTaskMessageQueue;
97199:   /**
97199:    * True when RunInStableState has determined that mLifecycleState is >
97199:    * LIFECYCLE_RUNNING. Since only the main thread can reset mLifecycleState to
97199:    * LIFECYCLE_RUNNING, this can be relied on to not change unexpectedly.
97199:    */
97199:   bool mDetectedNotRunning;
97199:   /**
97199:    * True when a stable state runner has been posted to the appshell to run
97199:    * RunInStableState at the next stable state.
97199:    */
97199:   bool mPostedRunInStableState;
97199: };
97199: 
97199: /**
97199:  * The singleton graph instance.
97199:  */
97199: static MediaStreamGraphImpl* gGraph;
97199: 
97199: StreamTime
97199: MediaStreamGraphImpl::GetDesiredBufferEnd(MediaStream* aStream)
97199: {
97199:   StreamTime current = mCurrentTime - aStream->mBufferStartTime;
97199:   StreamTime desiredEnd = current;
97199:   if (!aStream->mAudioOutputs.IsEmpty()) {
97199:     desiredEnd = NS_MAX(desiredEnd, current + MillisecondsToMediaTime(AUDIO_TARGET_MS));
97199:   }
97199:   if (!aStream->mVideoOutputs.IsEmpty()) {
97199:     desiredEnd = NS_MAX(desiredEnd, current + MillisecondsToMediaTime(VIDEO_TARGET_MS));
97199:   }
97199:   return desiredEnd;
97199: }
97199: 
97199: bool
97199: MediaStreamGraphImpl::IsAlwaysExplicitlyBlocked(MediaStream* aStream)
97199: {
97199:   GraphTime t = mCurrentTime;
97199:   while (true) {
97199:     GraphTime end;
97199:     if (aStream->mExplicitBlockerCount.GetAt(t, &end) == 0)
97199:       return false;
97199:     if (end >= GRAPH_TIME_MAX)
97199:       return true;
97199:     t = end;
97199:   }
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::FinishStream(MediaStream* aStream)
97199: {
97199:   if (aStream->mFinished)
97199:     return;
97199:   LOG(PR_LOG_DEBUG, ("MediaStream %p will finish", aStream));
97199:   aStream->mFinished = true;
97199:   // Force at least one more iteration of the control loop, since we rely
97199:   // on UpdateCurrentTime to notify our listeners once the stream end
97199:   // has been reached.
97199:   EnsureNextIteration();
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::NoteStreamAffected(MediaStream* aStream, double aTime)
97199: {
97199:   NS_ASSERTION(aTime >= 0, "Bad time");
97199:   GraphTime t =
97199:       NS_MAX(GetEarliestActionTime(),
97199:           StreamTimeToGraphTime(aStream, SecondsToMediaTime(aTime),
97199:                                 INCLUDE_TRAILING_BLOCKED_INTERVAL));
97199:   aStream->mMessageAffectedTime = NS_MIN(aStream->mMessageAffectedTime, t);
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::NoteStreamAffected(MediaStream* aStream)
97199: {
97199:   GraphTime t = GetEarliestActionTime();
97199:   aStream->mMessageAffectedTime = NS_MIN(aStream->mMessageAffectedTime, t);
97199: }
97199: 
97199: void
97199: ControlMessage::UpdateAffectedStream()
97199: {
97199:   NS_ASSERTION(mStream, "Must have stream for default UpdateAffectedStream");
97199:   mStream->GraphImpl()->NoteStreamAffected(mStream);
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::AddStream(MediaStream* aStream)
97199: {
97199:   aStream->mBufferStartTime = mCurrentTime;
97199:   aStream->mMessageAffectedTime = GetEarliestActionTime();
97199:   *mStreams.AppendElement() = already_AddRefed<MediaStream>(aStream);
97199:   LOG(PR_LOG_DEBUG, ("Adding media stream %p to the graph", aStream));
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::RemoveStream(MediaStream* aStream)
97199: {
97199:   // Remove references in mStreamUpdates before we allow aStream to die.
97199:   // Pending updates are not needed (since the main thread has already given
97199:   // up the stream) so we will just drop them.
97199:   {
97199:     MonitorAutoLock lock(mMonitor);
97199:     for (PRUint32 i = 0; i < mStreamUpdates.Length(); ++i) {
97199:       if (mStreamUpdates[i].mStream == aStream) {
97199:         mStreamUpdates[i].mStream = nsnull;
97199:       }
97199:     }
97199:   }
97199: 
97199:   // This unrefs the stream, probably destroying it
97199:   mStreams.RemoveElement(aStream);
97199: 
97199:   LOG(PR_LOG_DEBUG, ("Removing media stream %p from the graph", aStream));
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::ChooseActionTime()
97199: {
97199:   mLastActionTime = GetEarliestActionTime();
97199: }
97199: 
97201: void
97201: MediaStreamGraphImpl::ExtractPendingInput(SourceMediaStream* aStream)
97201: {
97201:   bool finished;
97201:   {
97201:     MutexAutoLock lock(aStream->mMutex);
97201:     finished = aStream->mUpdateFinished;
97201:     for (PRInt32 i = aStream->mUpdateTracks.Length() - 1; i >= 0; --i) {
97201:       SourceMediaStream::TrackData* data = &aStream->mUpdateTracks[i];
97205:       for (PRUint32 j = 0; j < aStream->mListeners.Length(); ++j) {
97205:         MediaStreamListener* l = aStream->mListeners[j];
97205:         TrackTicks offset = (data->mCommands & SourceMediaStream::TRACK_CREATE)
97205:             ? data->mStart : aStream->mBuffer.FindTrack(data->mID)->GetSegment()->GetDuration();
97205:         l->NotifyQueuedTrackChanges(this, data->mID, data->mRate,
97205:                                     offset, data->mCommands, *data->mData);
97205:       }
97201:       if (data->mCommands & SourceMediaStream::TRACK_CREATE) {
97201:         MediaSegment* segment = data->mData.forget();
97201:         LOG(PR_LOG_DEBUG, ("SourceMediaStream %p creating track %d, rate %d, start %lld, initial end %lld",
97201:                            aStream, data->mID, data->mRate, PRInt64(data->mStart),
97201:                            PRInt64(segment->GetDuration())));
97201:         aStream->mBuffer.AddTrack(data->mID, data->mRate, data->mStart, segment);
97201:         // The track has taken ownership of data->mData, so let's replace
97201:         // data->mData with an empty clone.
97201:         data->mData = segment->CreateEmptyClone();
97201:         data->mCommands &= ~SourceMediaStream::TRACK_CREATE;
97201:       } else if (data->mData->GetDuration() > 0) {
97201:         MediaSegment* dest = aStream->mBuffer.FindTrack(data->mID)->GetSegment();
97201:         LOG(PR_LOG_DEBUG, ("SourceMediaStream %p track %d, advancing end from %lld to %lld",
97201:                            aStream, data->mID,
97201:                            PRInt64(dest->GetDuration()),
97201:                            PRInt64(dest->GetDuration() + data->mData->GetDuration())));
97201:         dest->AppendFrom(data->mData);
97201:       }
97201:       if (data->mCommands & SourceMediaStream::TRACK_END) {
97201:         aStream->mBuffer.FindTrack(data->mID)->SetEnded();
97201:         aStream->mUpdateTracks.RemoveElementAt(i);
97201:       }
97201:     }
97201:     aStream->mBuffer.AdvanceKnownTracksTime(aStream->mUpdateKnownTracksTime);
97201:   }
97201:   if (finished) {
97201:     FinishStream(aStream);
97201:   }
97201: }
97201: 
97201: void
97201: MediaStreamGraphImpl::UpdateBufferSufficiencyState(SourceMediaStream* aStream)
97201: {
97201:   StreamTime desiredEnd = GetDesiredBufferEnd(aStream);
97201:   nsTArray<SourceMediaStream::ThreadAndRunnable> runnables;
97201: 
97201:   {
97201:     MutexAutoLock lock(aStream->mMutex);
97201:     for (PRUint32 i = 0; i < aStream->mUpdateTracks.Length(); ++i) {
97201:       SourceMediaStream::TrackData* data = &aStream->mUpdateTracks[i];
97212:       if (data->mCommands & SourceMediaStream::TRACK_CREATE) {
97212:         // This track hasn't been created yet, so we have no sufficiency
97212:         // data. The track will be created in the next iteration of the
97212:         // control loop and then we'll fire insufficiency notifications
97212:         // if necessary.
97212:         continue;
97212:       }
97208:       if (data->mCommands & SourceMediaStream::TRACK_END) {
97208:         // This track will end, so no point in firing not-enough-data
97208:         // callbacks.
97201:         continue;
97201:       }
97201:       StreamBuffer::Track* track = aStream->mBuffer.FindTrack(data->mID);
97208:       // Note that track->IsEnded() must be false, otherwise we would have
97208:       // removed the track from mUpdateTracks already.
97208:       NS_ASSERTION(!track->IsEnded(), "What is this track doing here?");
97201:       data->mHaveEnough = track->GetEndTimeRoundDown() >= desiredEnd;
97201:       if (!data->mHaveEnough) {
97201:         runnables.MoveElementsFrom(data->mDispatchWhenNotEnough);
97201:       }
97201:     }
97201:   }
97201: 
97201:   for (PRUint32 i = 0; i < runnables.Length(); ++i) {
97201:     runnables[i].mThread->Dispatch(runnables[i].mRunnable, 0);
97201:   }
97201: }
97201: 
97201: 
97199: StreamTime
97199: MediaStreamGraphImpl::GraphTimeToStreamTime(MediaStream* aStream,
97199:                                             GraphTime aTime)
97199: {
97199:   NS_ASSERTION(aTime <= mBlockingDecisionsMadeUntilTime,
97199:                "Don't ask about times where we haven't made blocking decisions yet");
97199:   if (aTime <= mCurrentTime) {
97199:     return NS_MAX<StreamTime>(0, aTime - aStream->mBufferStartTime);
97199:   }
97199:   GraphTime t = mCurrentTime;
97199:   StreamTime s = t - aStream->mBufferStartTime;
97199:   while (t < aTime) {
97199:     GraphTime end;
97199:     if (!aStream->mBlocked.GetAt(t, &end)) {
97199:       s += NS_MIN(aTime, end) - t;
97199:     }
97199:     t = end;
97199:   }
97199:   return NS_MAX<StreamTime>(0, s);
97199: }  
97199: 
97199: GraphTime
97199: MediaStreamGraphImpl::StreamTimeToGraphTime(MediaStream* aStream,
97199:                                             StreamTime aTime, PRUint32 aFlags)
97199: {
97199:   if (aTime >= STREAM_TIME_MAX) {
97199:     return GRAPH_TIME_MAX;
97199:   }
97199:   MediaTime bufferElapsedToCurrentTime = mCurrentTime - aStream->mBufferStartTime;
97199:   if (aTime < bufferElapsedToCurrentTime ||
97199:       (aTime == bufferElapsedToCurrentTime && !(aFlags & INCLUDE_TRAILING_BLOCKED_INTERVAL))) {
97199:     return aTime + aStream->mBufferStartTime;
97199:   }
97199: 
97199:   MediaTime streamAmount = aTime - bufferElapsedToCurrentTime;
97199:   NS_ASSERTION(streamAmount >= 0, "Can't answer queries before current time");
97199: 
97199:   GraphTime t = mCurrentTime;
97199:   while (t < GRAPH_TIME_MAX) {
97199:     bool blocked;
97199:     GraphTime end;
97199:     if (t < mBlockingDecisionsMadeUntilTime) {
97199:       blocked = aStream->mBlocked.GetAt(t, &end);
97199:       end = NS_MIN(end, mBlockingDecisionsMadeUntilTime);
97199:     } else {
97199:       blocked = false;
97199:       end = GRAPH_TIME_MAX;
97199:     }
97199:     if (blocked) {
97199:       t = end;
97199:     } else {
97199:       if (streamAmount == 0) {
97199:         // No more stream time to consume at time t, so we're done.
97199:         break;
97199:       }
97199:       MediaTime consume = NS_MIN(end - t, streamAmount);
97199:       streamAmount -= consume;
97199:       t += consume;
97199:     }
97199:   }
97199:   return t;
97199: }
97199: 
97199: GraphTime
97199: MediaStreamGraphImpl::GetAudioPosition(MediaStream* aStream)
97199: {
97199:   if (!aStream->mAudioOutput) {
97199:     return mCurrentTime;
97199:   }
97843:   PRInt64 positionInFrames = aStream->mAudioOutput->GetPositionInFrames();
97843:   if (positionInFrames < 0) {
97843:     return mCurrentTime;
97843:   }
97199:   return aStream->mAudioPlaybackStartTime +
97199:       TicksToTimeRoundDown(aStream->mAudioOutput->GetRate(),
97843:                            positionInFrames);
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::UpdateCurrentTime()
97199: {
97199:   GraphTime prevCurrentTime = mCurrentTime;
97199:   TimeStamp now = TimeStamp::Now();
97199:   GraphTime nextCurrentTime =
97199:     SecondsToMediaTime((now - mCurrentTimeStamp).ToSeconds()) + mCurrentTime;
97843:   if (mBlockingDecisionsMadeUntilTime < nextCurrentTime) {
97843:     LOG(PR_LOG_WARNING, ("Media graph global underrun detected"));
97843:     LOG(PR_LOG_DEBUG, ("Advancing mBlockingDecisionsMadeUntilTime from %f to %f",
97843:                        MediaTimeToSeconds(mBlockingDecisionsMadeUntilTime),
97843:                        MediaTimeToSeconds(nextCurrentTime)));
97843:     // Advance mBlockingDecisionsMadeUntilTime to nextCurrentTime by
97843:     // adding blocked time to all streams starting at mBlockingDecisionsMadeUntilTime
97843:     for (PRUint32 i = 0; i < mStreams.Length(); ++i) {
97843:       mStreams[i]->mBlocked.SetAtAndAfter(mBlockingDecisionsMadeUntilTime, true);
97843:     }
97843:     mBlockingDecisionsMadeUntilTime = nextCurrentTime;
97199:   }
97199:   mCurrentTimeStamp = now;
97199: 
97845:   LOG(PR_LOG_DEBUG, ("Updating current time to %f (real %f, mBlockingDecisionsMadeUntilTime %f)",
97199:                      MediaTimeToSeconds(nextCurrentTime),
97199:                      (now - mInitialTimeStamp).ToSeconds(),
97199:                      MediaTimeToSeconds(mBlockingDecisionsMadeUntilTime)));
97199: 
97199:   if (prevCurrentTime >= nextCurrentTime) {
97199:     NS_ASSERTION(prevCurrentTime == nextCurrentTime, "Time can't go backwards!");
97199:     // This could happen due to low clock resolution, maybe?
97199:     LOG(PR_LOG_DEBUG, ("Time did not advance"));
97199:     return;
97199:   }
97199: 
97199:   for (PRUint32 i = 0; i < mStreams.Length(); ++i) {
97199:     MediaStream* stream = mStreams[i];
97199: 
97199:     // Calculate blocked time and fire Blocked/Unblocked events
97199:     GraphTime blockedTime = 0;
97199:     GraphTime t = prevCurrentTime;
97199:     // Save current blocked status
97199:     bool wasBlocked = stream->mBlocked.GetAt(prevCurrentTime);
97199:     while (t < nextCurrentTime) {
97199:       GraphTime end;
97199:       bool blocked = stream->mBlocked.GetAt(t, &end);
97199:       if (blocked) {
97199:         blockedTime += NS_MIN(end, nextCurrentTime) - t;
97199:       }
97199:       if (blocked != wasBlocked) {
97199:         for (PRUint32 j = 0; j < stream->mListeners.Length(); ++j) {
97199:           MediaStreamListener* l = stream->mListeners[j];
97199:           l->NotifyBlockingChanged(this,
97199:               blocked ? MediaStreamListener::BLOCKED : MediaStreamListener::UNBLOCKED);
97199:         }
97199:         wasBlocked = blocked;
97199:       }
97199:       t = end;
97199:     }
97199: 
97199:     stream->AdvanceTimeVaryingValuesToCurrentTime(nextCurrentTime, blockedTime);
97199:     // Advance mBlocked last so that implementations of
97199:     // AdvanceTimeVaryingValuesToCurrentTime can rely on the value of mBlocked.
97199:     stream->mBlocked.AdvanceCurrentTime(nextCurrentTime);
97199: 
97199:     if (blockedTime < nextCurrentTime - mCurrentTime) {
97199:       for (PRUint32 i = 0; i < stream->mListeners.Length(); ++i) {
97199:         MediaStreamListener* l = stream->mListeners[i];
97199:         l->NotifyOutput(this);
97199:       }
97199:     }
97199: 
97199:     if (stream->mFinished && !stream->mNotifiedFinished &&
97199:         stream->mBufferStartTime + stream->GetBufferEnd() <= nextCurrentTime) {
97199:       stream->mNotifiedFinished = true;
97199:       for (PRUint32 j = 0; j < stream->mListeners.Length(); ++j) {
97199:         MediaStreamListener* l = stream->mListeners[j];
97199:         l->NotifyFinished(this);
97199:       }
97199:     }
97199: 
97199:     LOG(PR_LOG_DEBUG, ("MediaStream %p bufferStartTime=%f blockedTime=%f",
97199:                        stream, MediaTimeToSeconds(stream->mBufferStartTime),
97199:                        MediaTimeToSeconds(blockedTime)));
97199:   }
97199: 
97199:   mCurrentTime = nextCurrentTime;
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::MarkStreamBlocked(MediaStream* aStream,
97199:                                         GraphTime aTime, GraphTime* aEnd)
97199: {
97199:   NS_ASSERTION(!aStream->mBlocked.GetAt(aTime), "MediaStream already blocked");
97199: 
97199:   aStream->mBlocked.SetAtAndAfter(aTime, true);
97199: }
97199: 
97199: bool
97199: MediaStreamGraphImpl::WillUnderrun(MediaStream* aStream, GraphTime aTime,
97199:                                    GraphTime aEndBlockingDecisions, GraphTime* aEnd)
97199: {
97199:   // Finished streams, or streams that aren't being played back, can't underrun.
97199:   if (aStream->mFinished ||
97199:       (aStream->mAudioOutputs.IsEmpty() && aStream->mVideoOutputs.IsEmpty())) {
97199:     return false;
97199:   }
97199:   GraphTime bufferEnd =
97199:     StreamTimeToGraphTime(aStream, aStream->GetBufferEnd(),
97199:                           INCLUDE_TRAILING_BLOCKED_INTERVAL);
97199:   NS_ASSERTION(bufferEnd >= mCurrentTime, "Buffer underran");
97199:   // We should block after bufferEnd.
97199:   if (bufferEnd <= aTime) {
97199:     LOG(PR_LOG_DEBUG, ("MediaStream %p will block due to data underrun, "
97199:                        "bufferEnd %f",
97199:                        aStream, MediaTimeToSeconds(bufferEnd)));
97199:     return true;
97199:   }
97199:   // We should keep blocking if we're currently blocked and we don't have
97199:   // data all the way through to aEndBlockingDecisions. If we don't have
97199:   // data all the way through to aEndBlockingDecisions, we'll block soon,
97199:   // but we might as well remain unblocked and play the data we've got while
97199:   // we can.
97199:   if (bufferEnd <= aEndBlockingDecisions && aStream->mBlocked.GetBefore(aTime)) {
97199:     LOG(PR_LOG_DEBUG, ("MediaStream %p will block due to speculative data underrun, "
97199:                        "bufferEnd %f",
97199:                        aStream, MediaTimeToSeconds(bufferEnd)));
97199:     return true;
97199:   }
97199:   // Reconsider decisions at bufferEnd
97199:   *aEnd = NS_MIN(*aEnd, bufferEnd);
97199:   return false;
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::RecomputeBlocking()
97199: {
97199:   PRInt32 writeAudioUpTo = AUDIO_TARGET_MS;
97199:   GraphTime endBlockingDecisions =
97199:     mCurrentTime + MillisecondsToMediaTime(writeAudioUpTo);
97199: 
97199:   bool blockingDecisionsWillChange = false;
97199:   // mBlockingDecisionsMadeUntilTime has been set in UpdateCurrentTime
97199:   while (mBlockingDecisionsMadeUntilTime < endBlockingDecisions) {
97199:     LOG(PR_LOG_DEBUG, ("Media graph %p computing blocking for time %f",
97199:                        this, MediaTimeToSeconds(mBlockingDecisionsMadeUntilTime)));
97199:     GraphTime end = GRAPH_TIME_MAX;
97199:     RecomputeBlockingAt(mBlockingDecisionsMadeUntilTime, endBlockingDecisions, &end);
97199:     LOG(PR_LOG_DEBUG, ("Media graph %p computed blocking for interval %f to %f",
97199:                        this, MediaTimeToSeconds(mBlockingDecisionsMadeUntilTime),
97199:                        MediaTimeToSeconds(end)));
97199:     mBlockingDecisionsMadeUntilTime = end;
97199:     if (end < GRAPH_TIME_MAX) {
97199:       blockingDecisionsWillChange = true;
97199:     }
97199:   }
97199:   mBlockingDecisionsMadeUntilTime = endBlockingDecisions;
97199: 
97199:   for (PRUint32 i = 0; i < mStreams.Length(); ++i) {
97199:     MediaStream* stream = mStreams[i];
97199:     GraphTime end;
97199:     stream->mBlocked.GetAt(mCurrentTime, &end);
97199:     if (end < GRAPH_TIME_MAX) {
97199:       blockingDecisionsWillChange = true;
97199:     }
97199:   }
97199:   if (blockingDecisionsWillChange) {
97199:     // Make sure we wake up to notify listeners about these changes.
97199:     EnsureNextIteration();
97199:   }
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::RecomputeBlockingAt(GraphTime aTime,
97199:                                           GraphTime aEndBlockingDecisions,
97199:                                           GraphTime* aEnd)
97199: {
97199:   for (PRUint32 i = 0; i < mStreams.Length(); ++i) {
97199:     MediaStream* stream = mStreams[i];
97199:     stream->mBlocked.SetAtAndAfter(aTime, false);
97199:   }
97199: 
97199:   for (PRUint32 i = 0; i < mStreams.Length(); ++i) {
97199:     MediaStream* stream = mStreams[i];
97199:     // Stream might be blocked by some other stream (due to processing
97199:     // constraints)
97199:     if (stream->mBlocked.GetAt(aTime)) {
97199:       continue;
97199:     }
97199: 
97199:     if (stream->mFinished) {
97199:       GraphTime endTime = StreamTimeToGraphTime(stream, stream->GetBufferEnd());
97199:       if (endTime <= aTime) {
97199:         LOG(PR_LOG_DEBUG, ("MediaStream %p is blocked due to being finished", stream));
97199:         MarkStreamBlocked(stream, aTime, aEnd);
97199:         continue;
97199:       } else {
97199:         LOG(PR_LOG_DEBUG, ("MediaStream %p is finished, but not blocked yet (end at %f, with blocking at %f)",
97199:                            stream, MediaTimeToSeconds(stream->GetBufferEnd()),
97199:                            MediaTimeToSeconds(endTime)));
97199:         *aEnd = NS_MIN(*aEnd, endTime);
97199:       }
97199:     }
97199: 
97199:     // We don't need to explicitly check for cycles; streams in a cycle will
97199:     // just never be able to produce data, and WillUnderrun will trigger.
97199:     GraphTime end;
97199:     bool explicitBlock = stream->mExplicitBlockerCount.GetAt(aTime, &end) > 0;
97199:     *aEnd = NS_MIN(*aEnd, end);
97199:     if (explicitBlock) {
97199:       LOG(PR_LOG_DEBUG, ("MediaStream %p is blocked due to explicit blocker", stream));
97199:       MarkStreamBlocked(stream, aTime, aEnd);
97199:       continue;
97199:     }
97199: 
97199:     bool underrun = WillUnderrun(stream, aTime, aEndBlockingDecisions, aEnd);
97199:     if (underrun) {
97199:       MarkStreamBlocked(stream, aTime, aEnd);
97199:       continue;
97199:     }
97199: 
97199:     if (stream->mAudioOutputs.IsEmpty() && stream->mVideoOutputs.IsEmpty()) {
97199:       // See if the stream is being consumed anywhere. If not, it should block.
97199:       LOG(PR_LOG_DEBUG, ("MediaStream %p is blocked due to having no consumers", stream));
97199:       MarkStreamBlocked(stream, aTime, aEnd);
97199:       continue;
97199:     }
97199:   }
97199: 
97199:   NS_ASSERTION(*aEnd > aTime, "Failed to advance!");
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::UpdateFirstActiveTracks(MediaStream* aStream)
97199: {
97199:   StreamBuffer::Track* newTracksByType[MediaSegment::TYPE_COUNT];
97199:   for (PRUint32 i = 0; i < ArrayLength(newTracksByType); ++i) {
97199:     newTracksByType[i] = nsnull;
97199:   }
97199: 
97199:   for (StreamBuffer::TrackIter iter(aStream->mBuffer);
97199:        !iter.IsEnded(); iter.Next()) {
97199:     MediaSegment::Type type = iter->GetType();
97199:     if ((newTracksByType[type] &&
97199:          iter->GetStartTimeRoundDown() < newTracksByType[type]->GetStartTimeRoundDown()) ||
97199:          aStream->mFirstActiveTracks[type] == TRACK_NONE) {
97199:       newTracksByType[type] = &(*iter);
97199:       aStream->mFirstActiveTracks[type] = iter->GetID();
97199:     }
97199:   }
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::CreateOrDestroyAudioStream(GraphTime aAudioOutputStartTime,
97199:                                                  MediaStream* aStream)
97199: {
97199:   StreamBuffer::Track* track;
97199: 
97199:   if (aStream->mAudioOutputs.IsEmpty() ||
97199:       !(track = aStream->mBuffer.FindTrack(aStream->mFirstActiveTracks[MediaSegment::AUDIO]))) {
97199:     if (aStream->mAudioOutput) {
97199:       aStream->mAudioOutput->Shutdown();
97199:       aStream->mAudioOutput = nsnull;
97199:     }
97199:     return;
97199:   }
97199: 
97199:   if (aStream->mAudioOutput)
97199:     return;
97199: 
97199:   // No output stream created yet. Check if it's time to create one.
97199:   GraphTime startTime =
97199:     StreamTimeToGraphTime(aStream, track->GetStartTimeRoundDown(),
97199:                           INCLUDE_TRAILING_BLOCKED_INTERVAL);
97199:   if (startTime >= mBlockingDecisionsMadeUntilTime) {
97199:     // The stream wants to play audio, but nothing will play for the forseeable
97199:     // future, so don't create the stream.
97199:     return;
97199:   }
97199: 
97199:   // Don't bother destroying the nsAudioStream for ended tracks yet.
97199: 
97199:   // XXX allocating a nsAudioStream could be slow so we're going to have to do
97199:   // something here ... preallocation, async allocation, multiplexing onto a single
97199:   // stream ...
97199: 
97199:   AudioSegment* audio = track->Get<AudioSegment>();
97199:   aStream->mAudioPlaybackStartTime = aAudioOutputStartTime;
97199:   aStream->mAudioOutput = nsAudioStream::AllocateStream();
97199:   aStream->mAudioOutput->Init(audio->GetChannels(),
97199:                               track->GetRate(),
97199:                               audio->GetFirstFrameFormat());
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::PlayAudio(MediaStream* aStream,
97199:                                 GraphTime aFrom, GraphTime aTo)
97199: {
97199:   if (!aStream->mAudioOutput)
97199:     return;
97199: 
97199:   StreamBuffer::Track* track =
97199:     aStream->mBuffer.FindTrack(aStream->mFirstActiveTracks[MediaSegment::AUDIO]);
97199:   AudioSegment* audio = track->Get<AudioSegment>();
97199: 
97199:   // When we're playing multiple copies of this stream at the same time, they're
97199:   // perfectly correlated so adding volumes is the right thing to do.
97199:   float volume = 0.0f;
97199:   for (PRUint32 i = 0; i < aStream->mAudioOutputs.Length(); ++i) {
97199:     volume += aStream->mAudioOutputs[i].mVolume;
97199:   }
97199: 
97199:   // We don't update aStream->mBufferStartTime here to account for
97199:   // time spent blocked. Instead, we'll update it in UpdateCurrentTime after the
97199:   // blocked period has completed. But we do need to make sure we play from the
97199:   // right offsets in the stream buffer, even if we've already written silence for
97199:   // some amount of blocked time after the current time.
97199:   GraphTime t = aFrom;
97199:   while (t < aTo) {
97199:     GraphTime end;
97199:     bool blocked = aStream->mBlocked.GetAt(t, &end);
97199:     end = NS_MIN(end, aTo);
97199: 
97199:     AudioSegment output;
97199:     if (blocked) {
97199:       // Track total blocked time in aStream->mBlockedAudioTime so that
97199:       // the amount of silent samples we've inserted for blocking never gets
97199:       // more than one sample away from the ideal amount.
97199:       TrackTicks startTicks =
97199:           TimeToTicksRoundDown(track->GetRate(), aStream->mBlockedAudioTime);
97199:       aStream->mBlockedAudioTime += end - t;
97199:       TrackTicks endTicks =
97199:           TimeToTicksRoundDown(track->GetRate(), aStream->mBlockedAudioTime);
97199: 
97199:       output.InitFrom(*audio);
97199:       output.InsertNullDataAtStart(endTicks - startTicks);
97199:       LOG(PR_LOG_DEBUG, ("MediaStream %p writing blocking-silence samples for %f to %f",
97199:                          aStream, MediaTimeToSeconds(t), MediaTimeToSeconds(end)));
97199:     } else {
97199:       TrackTicks startTicks =
97199:           track->TimeToTicksRoundDown(GraphTimeToStreamTime(aStream, t));
97199:       TrackTicks endTicks =
97199:           track->TimeToTicksRoundDown(GraphTimeToStreamTime(aStream, end));
97199: 
97199:       output.SliceFrom(*audio, startTicks, endTicks);
97199:       output.ApplyVolume(volume);
97199:       LOG(PR_LOG_DEBUG, ("MediaStream %p writing samples for %f to %f (samples %lld to %lld)",
97199:                          aStream, MediaTimeToSeconds(t), MediaTimeToSeconds(end),
97199:                          startTicks, endTicks));
97199:     }
97199:     output.WriteTo(aStream->mAudioOutput);
97199:     t = end;
97199:   }
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::PlayVideo(MediaStream* aStream)
97199: {
97199:   if (aStream->mVideoOutputs.IsEmpty())
97199:     return;
97199: 
97199:   StreamBuffer::Track* track =
97199:     aStream->mBuffer.FindTrack(aStream->mFirstActiveTracks[MediaSegment::VIDEO]);
97199:   if (!track)
97199:     return;
97199:   VideoSegment* video = track->Get<VideoSegment>();
97199: 
97199:   // Display the next frame a bit early. This is better than letting the current
97199:   // frame be displayed for too long.
97199:   GraphTime framePosition = mCurrentTime + MEDIA_GRAPH_TARGET_PERIOD_MS;
97199:   NS_ASSERTION(framePosition >= aStream->mBufferStartTime, "frame position before buffer?");
97199:   StreamTime frameBufferTime = GraphTimeToStreamTime(aStream, framePosition);
97199:   TrackTicks start;
97199:   const VideoFrame* frame =
97199:     video->GetFrameAt(track->TimeToTicksRoundDown(frameBufferTime), &start);
97199:   if (!frame) {
97199:     frame = video->GetLastFrame(&start);
97199:     if (!frame)
97199:       return;
97199:   }
97199: 
97199:   if (*frame != aStream->mLastPlayedVideoFrame) {
97199:     LOG(PR_LOG_DEBUG, ("MediaStream %p writing video frame %p (%dx%d)",
97199:                        aStream, frame->GetImage(), frame->GetIntrinsicSize().width,
97199:                        frame->GetIntrinsicSize().height));
97199:     GraphTime startTime = StreamTimeToGraphTime(aStream,
97199:         track->TicksToTimeRoundDown(start), INCLUDE_TRAILING_BLOCKED_INTERVAL);
97199:     TimeStamp targetTime = mCurrentTimeStamp +
97199:         TimeDuration::FromMilliseconds(double(startTime - mCurrentTime));
97199:     for (PRUint32 i = 0; i < aStream->mVideoOutputs.Length(); ++i) {
97199:       VideoFrameContainer* output = aStream->mVideoOutputs[i];
97199:       output->SetCurrentFrame(frame->GetIntrinsicSize(), frame->GetImage(),
97199:                               targetTime);
97199:       nsCOMPtr<nsIRunnable> event =
97199:         NS_NewRunnableMethod(output, &VideoFrameContainer::Invalidate);
97199:       NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
97199:     }
97199:     aStream->mLastPlayedVideoFrame = *frame;
97199:   }
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::PrepareUpdatesToMainThreadState()
97199: {
97199:   mMonitor.AssertCurrentThreadOwns();
97199: 
97199:   for (PRUint32 i = 0; i < mStreams.Length(); ++i) {
97199:     MediaStream* stream = mStreams[i];
97199:     StreamUpdate* update = mStreamUpdates.AppendElement();
97199:     update->mGraphUpdateIndex = stream->mGraphUpdateIndices.GetAt(mCurrentTime);
97199:     update->mStream = stream;
97199:     update->mNextMainThreadCurrentTime =
97199:       GraphTimeToStreamTime(stream, mCurrentTime);
97199:     update->mNextMainThreadFinished =
97199:       stream->mFinished &&
97199:       StreamTimeToGraphTime(stream, stream->GetBufferEnd()) <= mCurrentTime;
97199:   }
97199:   mUpdateRunnables.MoveElementsFrom(mPendingUpdateRunnables);
97199: 
97199:   EnsureStableStateEventPosted();
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::EnsureImmediateWakeUpLocked(MonitorAutoLock& aLock)
97199: {
97199:   if (mWaitState == WAITSTATE_WAITING_FOR_NEXT_ITERATION ||
97199:       mWaitState == WAITSTATE_WAITING_INDEFINITELY) {
97199:     mWaitState = WAITSTATE_WAKING_UP;
97199:     aLock.Notify();
97199:   }
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::EnsureNextIteration()
97199: {
97199:   MonitorAutoLock lock(mMonitor);
97199:   EnsureNextIterationLocked(lock);
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::EnsureNextIterationLocked(MonitorAutoLock& aLock)
97199: {
97199:   if (mNeedAnotherIteration)
97199:     return;
97199:   mNeedAnotherIteration = true;
97199:   if (mWaitState == WAITSTATE_WAITING_INDEFINITELY) {
97199:     mWaitState = WAITSTATE_WAKING_UP;
97199:     aLock.Notify();
97199:   }
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::RunThread()
97199: {
97199:   nsTArray<MessageBlock> messageQueue;
97199:   {
97199:     MonitorAutoLock lock(mMonitor);
97199:     messageQueue.SwapElements(mMessageQueue);
97199:   }
97199:   NS_ASSERTION(!messageQueue.IsEmpty(),
97199:                "Shouldn't have started a graph with empty message queue!");
97199: 
97199:   for (;;) {
97199:     // Update mCurrentTime to the min of the playing audio times, or using the
97199:     // wall-clock time change if no audio is playing.
97199:     UpdateCurrentTime();
97199: 
97199:     // Calculate independent action times for each batch of messages (each
97199:     // batch corresponding to an event loop task). This isolates the performance
97199:     // of different scripts to some extent.
97199:     for (PRUint32 i = 0; i < messageQueue.Length(); ++i) {
97199:       mProcessingGraphUpdateIndex = messageQueue[i].mGraphUpdateIndex;
97199:       nsTArray<nsAutoPtr<ControlMessage> >& messages = messageQueue[i].mMessages;
97199: 
97199:       for (PRUint32 j = 0; j < mStreams.Length(); ++j) {
97199:         mStreams[j]->mMessageAffectedTime = GRAPH_TIME_MAX;
97199:       }
97199:       for (PRUint32 j = 0; j < messages.Length(); ++j) {
97199:         messages[j]->UpdateAffectedStream();
97199:       }
97199: 
97199:       ChooseActionTime();
97199: 
97199:       for (PRUint32 j = 0; j < messages.Length(); ++j) {
97199:         messages[j]->Process();
97199:       }
97199:     }
97199:     messageQueue.Clear();
97199: 
97201:     // Grab pending ProcessingEngine results.
97201:     for (PRUint32 i = 0; i < mStreams.Length(); ++i) {
97201:       SourceMediaStream* is = mStreams[i]->AsSourceStream();
97201:       if (is) {
97201:         ExtractPendingInput(is);
97201:       }
97201:     }
97201: 
97199:     GraphTime prevBlockingDecisionsMadeUntilTime = mBlockingDecisionsMadeUntilTime;
97199:     RecomputeBlocking();
97199: 
97199:     PRUint32 audioStreamsActive = 0;
97199:     bool allBlockedForever = true;
97199:     // Figure out what each stream wants to do
97199:     for (PRUint32 i = 0; i < mStreams.Length(); ++i) {
97199:       MediaStream* stream = mStreams[i];
97199:       UpdateFirstActiveTracks(stream);
97199:       CreateOrDestroyAudioStream(prevBlockingDecisionsMadeUntilTime, stream);
97199:       PlayAudio(stream, prevBlockingDecisionsMadeUntilTime,
97199:                 mBlockingDecisionsMadeUntilTime);
97199:       if (stream->mAudioOutput) {
97199:         ++audioStreamsActive;
97199:       }
97199:       PlayVideo(stream);
97201:       SourceMediaStream* is = stream->AsSourceStream();
97201:       if (is) {
97201:         UpdateBufferSufficiencyState(is);
97201:       }
97199:       GraphTime end;
97199:       if (!stream->mBlocked.GetAt(mCurrentTime, &end) || end < GRAPH_TIME_MAX) {
97199:         allBlockedForever = false;
97199:       }
97199:     }
97199:     if (!allBlockedForever || audioStreamsActive > 0) {
97199:       EnsureNextIteration();
97199:     }
97199: 
97199:     {
97199:       MonitorAutoLock lock(mMonitor);
97199:       PrepareUpdatesToMainThreadState();
97199:       if (mForceShutDown || (IsEmpty() && mMessageQueue.IsEmpty())) {
97199:         // Enter shutdown mode. The stable-state handler will detect this
97199:         // and complete shutdown. Destroy any streams immediately.
97199:         for (PRUint32 i = 0; i < mStreams.Length(); ++i) {
97199:           mStreams[i]->DestroyImpl();
97199:         }
97199:         LOG(PR_LOG_DEBUG, ("MediaStreamGraph %p waiting for main thread cleanup", this));
97199:         mLifecycleState = LIFECYCLE_WAITING_FOR_MAIN_THREAD_CLEANUP;
97199:         return;
97199:       }
97199: 
97199:       PRIntervalTime timeout = PR_INTERVAL_NO_TIMEOUT;
97199:       TimeStamp now = TimeStamp::Now();
97199:       if (mNeedAnotherIteration) {
97199:         PRInt64 timeoutMS = MEDIA_GRAPH_TARGET_PERIOD_MS -
97199:           PRInt64((now - mCurrentTimeStamp).ToMilliseconds());
97199:         // Make sure timeoutMS doesn't overflow 32 bits by waking up at
97199:         // least once a minute, if we need to wake up at all
97199:         timeoutMS = NS_MAX<PRInt64>(0, NS_MIN<PRInt64>(timeoutMS, 60*1000));
97199:         timeout = PR_MillisecondsToInterval(PRUint32(timeoutMS));
97199:         LOG(PR_LOG_DEBUG, ("Waiting for next iteration; at %f, timeout=%f",
97199:                            (now - mInitialTimeStamp).ToSeconds(), timeoutMS/1000.0));
97199:         mWaitState = WAITSTATE_WAITING_FOR_NEXT_ITERATION;
97199:       } else {
97199:         mWaitState = WAITSTATE_WAITING_INDEFINITELY;
97199:       }
97199:       if (timeout > 0) {
97199:         lock.Wait(timeout);
97199:         LOG(PR_LOG_DEBUG, ("Resuming after timeout; at %f, elapsed=%f",
97199:                            (TimeStamp::Now() - mInitialTimeStamp).ToSeconds(),
97199:                            (TimeStamp::Now() - now).ToSeconds()));
97199:       }
97199:       mWaitState = WAITSTATE_RUNNING;
97199:       mNeedAnotherIteration = false;
97199:       messageQueue.SwapElements(mMessageQueue);
97199:     }
97199:   }
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::ApplyStreamUpdate(StreamUpdate* aUpdate)
97199: {
97199:   mMonitor.AssertCurrentThreadOwns();
97199: 
97199:   MediaStream* stream = aUpdate->mStream;
97199:   if (!stream)
97199:     return;
97199:   stream->mMainThreadCurrentTime = aUpdate->mNextMainThreadCurrentTime;
97199:   stream->mMainThreadFinished = aUpdate->mNextMainThreadFinished;
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::ShutdownThreads()
97199: {
97199:   NS_ASSERTION(NS_IsMainThread(), "Must be called on main thread");
97199:   // mGraph's thread is not running so it's OK to do whatever here
97199:   LOG(PR_LOG_DEBUG, ("Stopping threads for MediaStreamGraph %p", this));
97199: 
97199:   if (mThread) {
97199:     mThread->Shutdown();
97199:     mThread = nsnull;
97199:   }
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::ForceShutDown()
97199: {
97199:   NS_ASSERTION(NS_IsMainThread(), "Must be called on main thread");
97199:   LOG(PR_LOG_DEBUG, ("MediaStreamGraph %p ForceShutdown", this));
97199:   {
97199:     MonitorAutoLock lock(mMonitor);
97199:     mForceShutDown = true;
97199:     EnsureImmediateWakeUpLocked(lock);
97199:   }
97199: }
97199: 
97199: namespace {
97199: 
97199: class MediaStreamGraphThreadRunnable : public nsRunnable {
97199: public:
97199:   NS_IMETHOD Run()
97199:   {
97199:     gGraph->RunThread();
97199:     return NS_OK;
97199:   }
97199: };
97199: 
97199: class MediaStreamGraphShutDownRunnable : public nsRunnable {
97199: public:
97199:   MediaStreamGraphShutDownRunnable(MediaStreamGraphImpl* aGraph) : mGraph(aGraph) {}
97199:   NS_IMETHOD Run()
97199:   {
97199:     NS_ASSERTION(mGraph->mDetectedNotRunning,
97199:                  "We should know the graph thread control loop isn't running!");
97199:     // mGraph's thread is not running so it's OK to do whatever here
97199:     if (mGraph->IsEmpty()) {
97199:       // mGraph is no longer needed, so delete it. If the graph is not empty
97199:       // then we must be in a forced shutdown and some later AppendMessage will
97199:       // detect that the manager has been emptied, and delete it.
97199:       delete mGraph;
97199:     } else {
97199:       NS_ASSERTION(mGraph->mForceShutDown, "Not in forced shutdown?");
97199:       mGraph->mLifecycleState =
97199:         MediaStreamGraphImpl::LIFECYCLE_WAITING_FOR_STREAM_DESTRUCTION;
97199:     }
97199:     return NS_OK;
97199:   }
97199: private:
97199:   MediaStreamGraphImpl* mGraph;
97199: };
97199: 
97199: class MediaStreamGraphStableStateRunnable : public nsRunnable {
97199: public:
97199:   NS_IMETHOD Run()
97199:   {
97199:     if (gGraph) {
97199:       gGraph->RunInStableState();
97199:     }
97199:     return NS_OK;
97199:   }
97199: };
97199: 
97199: /*
97199:  * Control messages forwarded from main thread to graph manager thread
97199:  */
97199: class CreateMessage : public ControlMessage {
97199: public:
97199:   CreateMessage(MediaStream* aStream) : ControlMessage(aStream) {}
97199:   virtual void UpdateAffectedStream()
97199:   {
97199:     mStream->GraphImpl()->AddStream(mStream);
97199:   }
97199:   virtual void Process()
97199:   {
97199:     mStream->Init();
97199:   }
97199: };
97199: 
97199: class MediaStreamGraphShutdownObserver : public nsIObserver
97199: {
97199: public:
97199:   NS_DECL_ISUPPORTS
97199:   NS_DECL_NSIOBSERVER
97199: };
97199: 
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::RunInStableState()
97199: {
97199:   NS_ASSERTION(NS_IsMainThread(), "Must be called on main thread");
97199: 
97199:   nsTArray<nsCOMPtr<nsIRunnable> > runnables;
97199: 
97199:   {
97199:     MonitorAutoLock lock(mMonitor);
97199:     mPostedRunInStableStateEvent = false;
97199: 
97199:     runnables.SwapElements(mUpdateRunnables);
97199:     for (PRUint32 i = 0; i < mStreamUpdates.Length(); ++i) {
97199:       StreamUpdate* update = &mStreamUpdates[i];
97199:       if (update->mStream) {
97199:         ApplyStreamUpdate(update);
97199:       }
97199:     }
97199:     mStreamUpdates.Clear();
97199: 
97199:     if (mLifecycleState == LIFECYCLE_WAITING_FOR_MAIN_THREAD_CLEANUP && mForceShutDown) {
97199:       for (PRUint32 i = 0; i < mMessageQueue.Length(); ++i) {
97199:         MessageBlock& mb = mMessageQueue[i];
97199:         for (PRUint32 j = 0; j < mb.mMessages.Length(); ++j) {
97199:           mb.mMessages[j]->ProcessDuringShutdown();
97199:         }
97199:       }
97199:       mMessageQueue.Clear();
97199:       for (PRUint32 i = 0; i < mCurrentTaskMessageQueue.Length(); ++i) {
97199:         mCurrentTaskMessageQueue[i]->ProcessDuringShutdown();
97199:       }
97199:       mCurrentTaskMessageQueue.Clear();
97199:       // Stop MediaStreamGraph threads. Do not clear gGraph since
97199:       // we have outstanding DOM objects that may need it.
97199:       mLifecycleState = LIFECYCLE_WAITING_FOR_THREAD_SHUTDOWN;
97199:       nsCOMPtr<nsIRunnable> event = new MediaStreamGraphShutDownRunnable(this);
97199:       NS_DispatchToMainThread(event);
97199:     }
97199: 
97199:     if (mLifecycleState == LIFECYCLE_THREAD_NOT_STARTED) {
97199:       mLifecycleState = LIFECYCLE_RUNNING;
97199:       // Start the thread now. We couldn't start it earlier because
97199:       // the graph might exit immediately on finding it has no streams. The
97199:       // first message for a new graph must create a stream.
97199:       nsCOMPtr<nsIRunnable> event = new MediaStreamGraphThreadRunnable();
97199:       NS_NewThread(getter_AddRefs(mThread), event);
97199:     }
97199: 
97199:     if (mCurrentTaskMessageQueue.IsEmpty()) {
97199:       if (mLifecycleState == LIFECYCLE_WAITING_FOR_MAIN_THREAD_CLEANUP && IsEmpty()) {
97199:         NS_ASSERTION(gGraph == this, "Not current graph??");
97199:         // Complete shutdown. First, ensure that this graph is no longer used.
97199:         // A new graph graph will be created if one is needed.
97199:         LOG(PR_LOG_DEBUG, ("Disconnecting MediaStreamGraph %p", gGraph));
97199:         gGraph = nsnull;
97199:         // Asynchronously clean up old graph. We don't want to do this
97199:         // synchronously because it spins the event loop waiting for threads
97199:         // to shut down, and we don't want to do that in a stable state handler.
97199:         mLifecycleState = LIFECYCLE_WAITING_FOR_THREAD_SHUTDOWN;
97199:         nsCOMPtr<nsIRunnable> event = new MediaStreamGraphShutDownRunnable(this);
97199:         NS_DispatchToMainThread(event);
97199:       }
97199:     } else {
97199:       if (mLifecycleState <= LIFECYCLE_WAITING_FOR_MAIN_THREAD_CLEANUP) {
97199:         MessageBlock* block = mMessageQueue.AppendElement();
97199:         block->mMessages.SwapElements(mCurrentTaskMessageQueue);
97199:         block->mGraphUpdateIndex = mGraphUpdatesSent;
97199:         ++mGraphUpdatesSent;
97199:         EnsureNextIterationLocked(lock);
97199:       }
97199: 
97199:       if (mLifecycleState == LIFECYCLE_WAITING_FOR_MAIN_THREAD_CLEANUP) {
97199:         mLifecycleState = LIFECYCLE_RUNNING;
97199:         // Revive the MediaStreamGraph since we have more messages going to it.
97199:         // Note that we need to put messages into its queue before reviving it,
97199:         // or it might exit immediately.
97199:         nsCOMPtr<nsIRunnable> event = new MediaStreamGraphThreadRunnable();
97199:         mThread->Dispatch(event, 0);
97199:       }
97199:     }
97199: 
97199:     mDetectedNotRunning = mLifecycleState > LIFECYCLE_RUNNING;
97199:   }
97199: 
97199:   // Make sure we get a new current time in the next event loop task
97199:   mPostedRunInStableState = false;
97199: 
97199:   for (PRUint32 i = 0; i < runnables.Length(); ++i) {
97199:     runnables[i]->Run();
97199:   }
97199: }
97199: 
97199: static NS_DEFINE_CID(kAppShellCID, NS_APPSHELL_CID);
97199: 
97199: void
97199: MediaStreamGraphImpl::EnsureRunInStableState()
97199: {
97199:   NS_ASSERTION(NS_IsMainThread(), "main thread only");
97199: 
97199:   if (mPostedRunInStableState)
97199:     return;
97199:   mPostedRunInStableState = true;
97199:   nsCOMPtr<nsIRunnable> event = new MediaStreamGraphStableStateRunnable();
97199:   nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
97199:   if (appShell) {
97199:     appShell->RunInStableState(event);
97199:   } else {
97199:     NS_ERROR("Appshell already destroyed?");
97199:   }
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::EnsureStableStateEventPosted()
97199: {
97199:   mMonitor.AssertCurrentThreadOwns();
97199: 
97199:   if (mPostedRunInStableStateEvent)
97199:     return;
97199:   mPostedRunInStableStateEvent = true;
97199:   nsCOMPtr<nsIRunnable> event = new MediaStreamGraphStableStateRunnable();
97199:   NS_DispatchToMainThread(event);
97199: }
97199: 
97199: void
97199: MediaStreamGraphImpl::AppendMessage(ControlMessage* aMessage)
97199: {
97199:   NS_ASSERTION(NS_IsMainThread(), "main thread only");
97199: 
97199:   if (mDetectedNotRunning &&
97199:       mLifecycleState > LIFECYCLE_WAITING_FOR_MAIN_THREAD_CLEANUP) {
97199:     // The graph control loop is not running and main thread cleanup has
97199:     // happened. From now on we can't append messages to mCurrentTaskMessageQueue,
97199:     // because that will never be processed again, so just ProcessDuringShutdown
97199:     // this message.
97199:     // This should only happen during forced shutdown.
97199:     aMessage->ProcessDuringShutdown();
97199:     delete aMessage;
97199:     if (IsEmpty()) {
97199:       NS_ASSERTION(gGraph == this, "Switched managers during forced shutdown?");
97199:       gGraph = nsnull;
97199:       delete this;
97199:     }
97199:     return;
97199:   }
97199: 
97199:   mCurrentTaskMessageQueue.AppendElement(aMessage);
97199:   EnsureRunInStableState();
97199: }
97199: 
97199: void
97199: MediaStream::Init()
97199: {
97199:   MediaStreamGraphImpl* graph = GraphImpl();
97199:   mBlocked.SetAtAndAfter(graph->mCurrentTime, true);
97199:   mExplicitBlockerCount.SetAtAndAfter(graph->mCurrentTime, true);
97199:   mExplicitBlockerCount.SetAtAndAfter(graph->mLastActionTime, false);
97199: }
97199: 
97199: MediaStreamGraphImpl*
97199: MediaStream::GraphImpl()
97199: {
97199:   return gGraph;
97199: }
97199: 
97199: void
97199: MediaStream::DestroyImpl()
97199: {
97199:   if (mAudioOutput) {
97199:     mAudioOutput->Shutdown();
97199:     mAudioOutput = nsnull;
97199:   }
97199: }
97199: 
97199: void
97199: MediaStream::Destroy()
97199: {
97199:   class Message : public ControlMessage {
97199:   public:
97199:     Message(MediaStream* aStream) : ControlMessage(aStream) {}
97199:     virtual void UpdateAffectedStream()
97199:     {
97199:       mStream->DestroyImpl();
97199:       mStream->GraphImpl()->RemoveStream(mStream);
97199:     }
97199:     virtual void ProcessDuringShutdown()
97199:     { UpdateAffectedStream(); }
97199:   };
97199:   mWrapper = nsnull;
97199:   GraphImpl()->AppendMessage(new Message(this));
97199: }
97199: 
97199: void
97199: MediaStream::AddAudioOutput(void* aKey)
97199: {
97199:   class Message : public ControlMessage {
97199:   public:
97199:     Message(MediaStream* aStream, void* aKey) : ControlMessage(aStream), mKey(aKey) {}
97199:     virtual void UpdateAffectedStream()
97199:     {
97199:       mStream->AddAudioOutputImpl(mKey);
97199:     }
97199:     void* mKey;
97199:   };
97199:   GraphImpl()->AppendMessage(new Message(this, aKey));
97199: }
97199: 
97199: void
97199: MediaStream::SetAudioOutputVolumeImpl(void* aKey, float aVolume)
97199: {
97199:   for (PRUint32 i = 0; i < mAudioOutputs.Length(); ++i) {
97199:     if (mAudioOutputs[i].mKey == aKey) {
97199:       mAudioOutputs[i].mVolume = aVolume;
97199:       return;
97199:     }
97199:   }
97199:   NS_ERROR("Audio output key not found");
97199: }
97199: 
97199: void
97199: MediaStream::SetAudioOutputVolume(void* aKey, float aVolume)
97199: {
97199:   class Message : public ControlMessage {
97199:   public:
97199:     Message(MediaStream* aStream, void* aKey, float aVolume) :
97199:       ControlMessage(aStream), mKey(aKey), mVolume(aVolume) {}
97199:     virtual void UpdateAffectedStream()
97199:     {
97199:       mStream->SetAudioOutputVolumeImpl(mKey, mVolume);
97199:     }
97199:     void* mKey;
97199:     float mVolume;
97199:   };
97199:   GraphImpl()->AppendMessage(new Message(this, aKey, aVolume));
97199: }
97199: 
97199: void
97199: MediaStream::RemoveAudioOutputImpl(void* aKey)
97199: {
97199:   for (PRUint32 i = 0; i < mAudioOutputs.Length(); ++i) {
97199:     if (mAudioOutputs[i].mKey == aKey) {
97199:       mAudioOutputs.RemoveElementAt(i);
97199:       return;
97199:     }
97199:   }
97199:   NS_ERROR("Audio output key not found");
97199: }
97199: 
97199: void
97199: MediaStream::RemoveAudioOutput(void* aKey)
97199: {
97199:   class Message : public ControlMessage {
97199:   public:
97199:     Message(MediaStream* aStream, void* aKey) :
97199:       ControlMessage(aStream), mKey(aKey) {}
97199:     virtual void UpdateAffectedStream()
97199:     {
97199:       mStream->RemoveAudioOutputImpl(mKey);
97199:     }
97199:     void* mKey;
97199:   };
97199:   GraphImpl()->AppendMessage(new Message(this, aKey));
97199: }
97199: 
97199: void
97199: MediaStream::AddVideoOutput(VideoFrameContainer* aContainer)
97199: {
97199:   class Message : public ControlMessage {
97199:   public:
97199:     Message(MediaStream* aStream, VideoFrameContainer* aContainer) :
97199:       ControlMessage(aStream), mContainer(aContainer) {}
97199:     virtual void UpdateAffectedStream()
97199:     {
97199:       mStream->AddVideoOutputImpl(mContainer.forget());
97199:     }
97199:     nsRefPtr<VideoFrameContainer> mContainer;
97199:   };
97199:   GraphImpl()->AppendMessage(new Message(this, aContainer));
97199: }
97199: 
97199: void
97199: MediaStream::RemoveVideoOutput(VideoFrameContainer* aContainer)
97199: {
97199:   class Message : public ControlMessage {
97199:   public:
97199:     Message(MediaStream* aStream, VideoFrameContainer* aContainer) :
97199:       ControlMessage(aStream), mContainer(aContainer) {}
97199:     virtual void UpdateAffectedStream()
97199:     {
97199:       mStream->RemoveVideoOutputImpl(mContainer);
97199:     }
97199:     nsRefPtr<VideoFrameContainer> mContainer;
97199:   };
97199:   GraphImpl()->AppendMessage(new Message(this, aContainer));
97199: }
97199: 
97199: void
97199: MediaStream::ChangeExplicitBlockerCount(PRInt32 aDelta)
97199: {
97199:   class Message : public ControlMessage {
97199:   public:
97199:     Message(MediaStream* aStream, PRInt32 aDelta) :
97199:       ControlMessage(aStream), mDelta(aDelta) {}
97199:     virtual void UpdateAffectedStream()
97199:     {
97199:       mStream->ChangeExplicitBlockerCountImpl(
97199:           mStream->GraphImpl()->mLastActionTime, mDelta);
97199:     }
97199:     PRInt32 mDelta;
97199:   };
97199:   GraphImpl()->AppendMessage(new Message(this, aDelta));
97199: }
97199: 
97199: void
97199: MediaStream::AddListener(MediaStreamListener* aListener)
97199: {
97199:   class Message : public ControlMessage {
97199:   public:
97199:     Message(MediaStream* aStream, MediaStreamListener* aListener) :
97199:       ControlMessage(aStream), mListener(aListener) {}
97199:     virtual void UpdateAffectedStream()
97199:     {
97199:       mStream->AddListenerImpl(mListener.forget());
97199:     }
97199:     nsRefPtr<MediaStreamListener> mListener;
97199:   };
97199:   GraphImpl()->AppendMessage(new Message(this, aListener));
97199: }
97199: 
97199: void
97199: MediaStream::RemoveListener(MediaStreamListener* aListener)
97199: {
97199:   class Message : public ControlMessage {
97199:   public:
97199:     Message(MediaStream* aStream, MediaStreamListener* aListener) :
97199:       ControlMessage(aStream), mListener(aListener) {}
97199:     virtual void UpdateAffectedStream()
97199:     {
97199:       mStream->RemoveListenerImpl(mListener);
97199:     }
97199:     nsRefPtr<MediaStreamListener> mListener;
97199:   };
97199:   GraphImpl()->AppendMessage(new Message(this, aListener));
97199: }
97199: 
97201: void
97201: SourceMediaStream::AddTrack(TrackID aID, TrackRate aRate, TrackTicks aStart,
97201:                             MediaSegment* aSegment)
97201: {
97201:   {
97201:     MutexAutoLock lock(mMutex);
97201:     TrackData* data = mUpdateTracks.AppendElement();
97201:     data->mID = aID;
97201:     data->mRate = aRate;
97201:     data->mStart = aStart;
97201:     data->mCommands = TRACK_CREATE;
97201:     data->mData = aSegment;
97201:     data->mHaveEnough = false;
97201:   }
97201:   GraphImpl()->EnsureNextIteration();
97201: }
97201: 
97201: void
97201: SourceMediaStream::AppendToTrack(TrackID aID, MediaSegment* aSegment)
97201: {
97201:   {
97201:     MutexAutoLock lock(mMutex);
98099:     TrackData *track = FindDataForTrack(aID);
98099:     if (track) {
98099:       track->mData->AppendFrom(aSegment);
98099:     } else {
98099:       NS_ERROR("Append to non-existant track!");
98099:     }
97201:   }
97201:   GraphImpl()->EnsureNextIteration();
97201: }
97201: 
97201: bool
97201: SourceMediaStream::HaveEnoughBuffered(TrackID aID)
97201: {
97201:   MutexAutoLock lock(mMutex);
98099:   TrackData *track = FindDataForTrack(aID);
98099:   if (track) {
98099:     return track->mHaveEnough;
98099:   }
98099:   NS_ERROR("No track in HaveEnoughBuffered!");
98099:   return true;
97201: }
97201: 
97201: void
97201: SourceMediaStream::DispatchWhenNotEnoughBuffered(TrackID aID,
97201:     nsIThread* aSignalThread, nsIRunnable* aSignalRunnable)
97201: {
97201:   MutexAutoLock lock(mMutex);
97201:   TrackData* data = FindDataForTrack(aID);
98099:   if (!data) {
98099:     NS_ERROR("No track in DispatchWhenNotEnoughBuffered");
98099:     return;
98099:   }
98099: 
97201:   if (data->mHaveEnough) {
97201:     data->mDispatchWhenNotEnough.AppendElement()->Init(aSignalThread, aSignalRunnable);
97201:   } else {
97201:     aSignalThread->Dispatch(aSignalRunnable, 0);
97201:   }
97201: }
97201: 
97201: void
97201: SourceMediaStream::EndTrack(TrackID aID)
97201: {
97201:   {
97201:     MutexAutoLock lock(mMutex);
98099:     TrackData *track = FindDataForTrack(aID);
98099:     if (track) {
98099:       track->mCommands |= TRACK_END;
98099:     } else {
98099:       NS_ERROR("End of non-existant track");
98099:     }
97201:   }
97201:   GraphImpl()->EnsureNextIteration();
97201: }
97201: 
97201: void
97201: SourceMediaStream::AdvanceKnownTracksTime(StreamTime aKnownTime)
97201: {
97201:   {
97201:     MutexAutoLock lock(mMutex);
97201:     mUpdateKnownTracksTime = aKnownTime;
97201:   }
97201:   GraphImpl()->EnsureNextIteration();
97201: }
97201: 
97201: void
97201: SourceMediaStream::Finish()
97201: {
97201:   {
97201:     MutexAutoLock lock(mMutex);
97201:     mUpdateFinished = true;
97201:   }
97201:   GraphImpl()->EnsureNextIteration();
97201: }
97201: 
97199: static const PRUint32 kThreadLimit = 4;
97199: static const PRUint32 kIdleThreadLimit = 4;
97199: static const PRUint32 kIdleThreadTimeoutMs = 2000;
97199: 
97199: MediaStreamGraphImpl::MediaStreamGraphImpl()
97199:   : mLastActionTime(1)
97199:   , mCurrentTime(1)
97199:   , mBlockingDecisionsMadeUntilTime(1)
97199:   , mProcessingGraphUpdateIndex(0)
97199:   , mMonitor("MediaStreamGraphImpl")
97199:   , mLifecycleState(LIFECYCLE_THREAD_NOT_STARTED)
97199:   , mWaitState(WAITSTATE_RUNNING)
97199:   , mNeedAnotherIteration(false)
97199:   , mForceShutDown(false)
97199:   , mPostedRunInStableStateEvent(false)
97199:   , mDetectedNotRunning(false)
97199:   , mPostedRunInStableState(false)
97199: {
97199: #ifdef PR_LOGGING
97199:   if (!gMediaStreamGraphLog) {
97199:     gMediaStreamGraphLog = PR_NewLogModule("MediaStreamGraph");
97199:   }
97199: #endif
97199: 
97199:   mCurrentTimeStamp = mInitialTimeStamp = TimeStamp::Now();
97199: }
97199: 
97199: NS_IMPL_ISUPPORTS1(MediaStreamGraphShutdownObserver, nsIObserver)
97199: 
97199: static bool gShutdownObserverRegistered = false;
97199: 
97199: NS_IMETHODIMP
97199: MediaStreamGraphShutdownObserver::Observe(nsISupports *aSubject,
97199:                                           const char *aTopic,
97199:                                           const PRUnichar *aData)
97199: {
97199:   if (strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID) == 0) {
97199:     if (gGraph) {
97199:       gGraph->ForceShutDown();
97199:     }
97199:     nsContentUtils::UnregisterShutdownObserver(this);
97199:     gShutdownObserverRegistered = false;
97199:   }
97199:   return NS_OK;
97199: }
97199: 
97199: MediaStreamGraph*
97199: MediaStreamGraph::GetInstance()
97199: {
97199:   NS_ASSERTION(NS_IsMainThread(), "Main thread only");
97199: 
97199:   if (!gGraph) {
97199:     if (!gShutdownObserverRegistered) {
97199:       gShutdownObserverRegistered = true;
97199:       nsContentUtils::RegisterShutdownObserver(new MediaStreamGraphShutdownObserver());
97199:     }
97199: 
97199:     gGraph = new MediaStreamGraphImpl();
97199:     LOG(PR_LOG_DEBUG, ("Starting up MediaStreamGraph %p", gGraph));
97199:   }
97199: 
97199:   return gGraph;
97199: }
97199: 
97201: SourceMediaStream*
97201: MediaStreamGraph::CreateInputStream(nsDOMMediaStream* aWrapper)
97201: {
97201:   SourceMediaStream* stream = new SourceMediaStream(aWrapper);
97201:   NS_ADDREF(stream);
97201:   static_cast<MediaStreamGraphImpl*>(this)->AppendMessage(new CreateMessage(stream));
97201:   return stream;
97199: }
97201: 
97201: }
