23697: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
23697: /* ***** BEGIN LICENSE BLOCK *****
23697:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
23697:  *
23697:  * The contents of this file are subject to the Mozilla Public License Version
23697:  * 1.1 (the "License"); you may not use this file except in compliance with
23697:  * the License. You may obtain a copy of the License at
23697:  * http://www.mozilla.org/MPL/
23697:  *
23697:  * Software distributed under the License is distributed on an "AS IS" basis,
23697:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
23697:  * for the specific language governing rights and limitations under the
23697:  * License.
23697:  *
23697:  * The Original Code is the Mozilla SVG project.
23697:  *
23697:  * The Initial Developer of the Original Code is Brian Birtles.
23697:  * Portions created by the Initial Developer are Copyright (C) 2005
23697:  * the Initial Developer. All Rights Reserved.
23697:  *
23697:  * Contributor(s):
23697:  *   Brian Birtles <birtles@gmail.com>
23697:  *   Chris Double  <chris.double@double.co.nz>
23697:  *
23697:  * Alternatively, the contents of this file may be used under the terms of
23697:  * either of the GNU General Public License Version 2 or later (the "GPL"),
23697:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
23697:  * in which case the provisions of the GPL or the LGPL are applicable instead
23697:  * of those above. If you wish to allow use of your version of this file only
23697:  * under the terms of either the GPL or the LGPL, and not to allow others to
23697:  * use your version of this file under the terms of the MPL, indicate your
23697:  * decision by deleting the provisions above and replace them with the notice
23697:  * and other provisions required by the GPL or the LGPL. If you do not delete
23697:  * the provisions above, a recipient may use your version of this file under
23697:  * the terms of any one of the MPL, the GPL or the LGPL.
23697:  *
23697:  * ***** END LICENSE BLOCK ***** */
23697: 
23697: #include "nsSVGAnimationElement.h"
23697: #include "nsSVGSVGElement.h"
23697: #include "nsSMILTimeContainer.h"
23697: #include "nsSMILAnimationController.h"
23697: #include "nsSMILAnimationFunction.h"
23697: #include "nsISMILAttr.h"
23697: 
23697: //----------------------------------------------------------------------
23697: // nsISupports methods
23697: 
23697: NS_IMPL_ADDREF_INHERITED(nsSVGAnimationElement, nsSVGAnimationElementBase)
23697: NS_IMPL_RELEASE_INHERITED(nsSVGAnimationElement, nsSVGAnimationElementBase)
23697: 
23697: NS_INTERFACE_MAP_BEGIN(nsSVGAnimationElement)
23697:   NS_INTERFACE_MAP_ENTRY(nsISMILAnimationElement)
23697:   NS_INTERFACE_MAP_ENTRY(nsIDOMElementTimeControl)
23697: NS_INTERFACE_MAP_END_INHERITING(nsSVGAnimationElementBase)
23697: 
23697: //----------------------------------------------------------------------
23697: // Implementation
23697: 
23697: nsSVGAnimationElement::nsSVGAnimationElement(nsINodeInfo *aNodeInfo)
23697:   : nsSVGAnimationElementBase(aNodeInfo),
23697:     mTimedDocumentRoot(nsnull)
23697: {
23697: }
23697: 
23697: nsresult
23697: nsSVGAnimationElement::Init()
23697: {
23697:   nsresult rv = nsSVGAnimationElementBase::Init();
23697:   NS_ENSURE_SUCCESS(rv, rv);
23697: 
23697:   AnimationFunction().SetAnimationElement(this);
23697:   mTimedElement.SetTimeClient(&AnimationFunction());
23697: 
23697:   return NS_OK;
23697: }
23697: 
23697: //----------------------------------------------------------------------
23697: // nsISMILAnimationElement methods
23697: 
23697: const nsIContent&
23697: nsSVGAnimationElement::Content() const
23697: {
23697:   return *this;
23697: }
23697: 
23697: nsIContent&
23697: nsSVGAnimationElement::Content()
23697: {
23697:   return *this;
23697: }
23697: 
23697: const nsAttrValue*
23697: nsSVGAnimationElement::GetAnimAttr(nsIAtom* aName) const
23697: {
23697:   return mAttrsAndChildren.GetAttr(aName, kNameSpaceID_None);
23697: }
23697: 
23697: nsIContent*
23697: nsSVGAnimationElement::GetTargetElementContent()
23697: {
23697:   if (HasAttr(kNameSpaceID_XLink, nsGkAtoms::href)) {
23697:     // XXXdholbert: Use xlink:href attr to look up target element here.
23697: 
23697:     // Note: Need to check for updated target element each sample, because
23697:     // the existing target's ID might've changed, or another element
23697:     // with the same ID might've been inserted earlier in the DOM tree.
23697:     NS_NOTYETIMPLEMENTED("nsSVGAnimationElement::GetTargetElementContent for "
23697:                          "xlink:href-targeted animations");
23697:     return nsnull;
23697:   }
23697: 
23697:   // No "xlink:href" attribute --> target is my parent.
25867:   return nsSVGUtils::GetParentElement(this);
23697: }
23697: 
23697: nsIAtom*
23697: nsSVGAnimationElement::GetTargetAttributeName() const
23697: {
23697:   const nsAttrValue* nameAttr
23697:     = mAttrsAndChildren.GetAttr(nsGkAtoms::attributeName);
23697: 
23697:   if (!nameAttr)
23697:     return nsnull;
23697: 
23697:   NS_ASSERTION(nameAttr->Type() == nsAttrValue::eAtom,
23697:     "attributeName should have been parsed as an atom");
23697:   return nameAttr->GetAtomValue();
23697: }
23697: 
23697: nsSMILTargetAttrType
23697: nsSVGAnimationElement::GetTargetAttributeType() const
23697: {
23697:   nsIContent::AttrValuesArray typeValues[] = { &nsGkAtoms::css,
26659:                                                &nsGkAtoms::XML,
26659:                                                nsnull};
23697:   nsSMILTargetAttrType smilTypes[] = { eSMILTargetAttrType_CSS,
23697:                                        eSMILTargetAttrType_XML };
23697:   PRInt32 index = FindAttrValueIn(kNameSpaceID_None,
23697:                                   nsGkAtoms::attributeType,
23697:                                   typeValues,
23697:                                   eCaseMatters);
23697:   return (index >= 0) ? smilTypes[index] : eSMILTargetAttrType_auto;
23697: }
23697: 
23697: nsSMILTimedElement&
23697: nsSVGAnimationElement::TimedElement()
23697: {
23697:   return mTimedElement;
23697: }
23697: 
23697: //----------------------------------------------------------------------
23697: // nsIDOMSVGAnimationElement methods
23697: 
23697: /* readonly attribute SVGElement targetElement; */
23697: NS_IMETHODIMP
23697: nsSVGAnimationElement::GetTargetElement(nsIDOMSVGElement** aTarget)
23697: {
24029:   FlushAnimations();
24029: 
23697:   // We'll just call the other GetTargetElement method, and QI to the right type
23697:   nsIContent* targetContent = GetTargetElementContent();
23697: 
23697:   nsCOMPtr<nsIDOMSVGElement> targetSVG = do_QueryInterface(targetContent);
23697:   NS_IF_ADDREF(*aTarget = targetSVG);
23697: 
23697:   return NS_OK;
23697: }
23697: 
23929: /* float getStartTime(); */
23697: NS_IMETHODIMP
23697: nsSVGAnimationElement::GetStartTime(float* retval)
23697: {
24029:   FlushAnimations();
24029: 
23929:   nsSMILTimeValue startTime = mTimedElement.GetStartTime();
23929:   if (startTime.IsResolved()) {
23929:     *retval = double(startTime.GetMillis()) / PR_MSEC_PER_SEC;
23929:   } else {
23697:     *retval = 0.f;
23697:   }
23697: 
23929:   return NS_OK;
23929: }
23929: 
23929: /* float getCurrentTime(); */
23697: NS_IMETHODIMP
23697: nsSVGAnimationElement::GetCurrentTime(float* retval)
23697: {
24029:   // Not necessary to call FlushAnimations() for this
24029: 
23929:   nsSMILTimeContainer* root = GetTimeContainer();
23929:   if (root) {
23929:     *retval = double(root->GetCurrentTime()) / PR_MSEC_PER_SEC;
23929:   } else {
23697:     *retval = 0.f;
23929:   }
23929:   return NS_OK;
23697: }
23697: 
23929: /* float getSimpleDuration() raises( DOMException ); */
23697: NS_IMETHODIMP
23697: nsSVGAnimationElement::GetSimpleDuration(float* retval)
23697: {
24029:   // Not necessary to call FlushAnimations() for this
24029: 
23929:   nsSMILTimeValue simpleDur = mTimedElement.GetSimpleDuration();
23929:   if (!simpleDur.IsResolved()) {
23697:     *retval = 0.f;
23929:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
23929:   }
23929: 
23929:   *retval = double(simpleDur.GetMillis()) / PR_MSEC_PER_SEC;
23929:   return NS_OK;
23697: }
23697: 
23697: //----------------------------------------------------------------------
23697: // nsIContent methods
23697: 
23697: nsresult
23697: nsSVGAnimationElement::BindToTree(nsIDocument* aDocument,
23697:                                   nsIContent* aParent,
23697:                                   nsIContent* aBindingParent,
23697:                                   PRBool aCompileEventHandlers)
23697: {
23697:   nsresult rv = nsSVGAnimationElementBase::BindToTree(aDocument, aParent,
23697:                                                       aBindingParent,
23697:                                                       aCompileEventHandlers);
23697:   NS_ENSURE_SUCCESS(rv,rv);
23697: 
23697:   // XXXdholbert is ownerDOMSVG (as a check for SVG parent) still needed here?
23697:   nsCOMPtr<nsIDOMSVGSVGElement> ownerDOMSVG;
23697:   rv = GetOwnerSVGElement(getter_AddRefs(ownerDOMSVG));
23697: 
23697:   if (NS_FAILED(rv) || !ownerDOMSVG)
23697:     // No use proceeding. We don't have an SVG parent (yet) so we won't be able
23697:     // to register ourselves etc. Maybe next time we'll have more luck.
23697:     // (This sort of situation will arise a lot when trees are being constructed
23697:     // piece by piece via script)
23697:     return NS_OK;
23697: 
23697:   mTimedDocumentRoot = GetTimeContainer();
23697:   if (!mTimedDocumentRoot)
23697:     // Timed document root hasn't been created yet. This will be created when
23697:     // the SVG parent is bound. This happens when we create SVG trees entirely
23697:     // by script.
23697:     return NS_OK;
23697: 
23697:   // Add myself to the animation controller's master set of animation elements.
23697:   if (aDocument) {
23697:     nsSMILAnimationController *controller = aDocument->GetAnimationController();
23697:     if (controller) {
23697:       controller->RegisterAnimationElement(this);
23697:     }
23697:   }
23697: 
24029:   AnimationNeedsResample();
24029: 
23697:   return NS_OK;
23697: }
23697: 
23697: void
23697: nsSVGAnimationElement::UnbindFromTree(PRBool aDeep, PRBool aNullParent)
23697: {
23697:   nsIDocument *doc = GetOwnerDoc();
23697:   if (doc) {
23697:     nsSMILAnimationController *controller = doc->GetAnimationController();
23697:     if (controller) {
23697:       controller->UnregisterAnimationElement(this);
23697:     }
23697:   }
23697: 
23697:   if (mTimedDocumentRoot) {
23697:     mTimedDocumentRoot = nsnull;
23697:   }
23697: 
24029:   AnimationNeedsResample();
24029: 
23697:   nsSVGAnimationElementBase::UnbindFromTree(aDeep, aNullParent);
23697: }
23697: 
23697: //----------------------------------------------------------------------
23697: // nsIContent methods
23697: 
23697: PRBool
23697: nsSVGAnimationElement::ParseAttribute(PRInt32 aNamespaceID,
23697:                                       nsIAtom* aAttribute,
23697:                                       const nsAString& aValue,
23697:                                       nsAttrValue& aResult)
23697: {
23697:   if (aNamespaceID == kNameSpaceID_None) {
23697:     // Deal with target-related attributes here
23697:     if (aAttribute == nsGkAtoms::attributeName ||
23697:         aAttribute == nsGkAtoms::attributeType) {
23697:       aResult.ParseAtom(aValue);
24029:       AnimationNeedsResample();
23697:       return PR_TRUE;
23697:     }
23697: 
23697:     nsresult rv = NS_ERROR_FAILURE;
23697: 
23697:     // First let the animation function try to parse it...
23697:     PRBool foundMatch = 
23697:       AnimationFunction().SetAttr(aAttribute, aValue, aResult, &rv);
23697: 
23697:     // ... and if that didn't recognize the attribute, let the timed element
23697:     // try to parse it.
23697:     if (!foundMatch) {
23697:       foundMatch = mTimedElement.SetAttr(aAttribute, aValue, aResult, &rv);
23697:     }
23697:     
23697:     if (foundMatch) {
24029:       AnimationNeedsResample();
23697:       if (NS_FAILED(rv)) {
23697:         ReportAttributeParseFailure(GetOwnerDoc(), aAttribute, aValue);
23697:         return PR_FALSE;
23697:       }
23697:       return PR_TRUE;
23697:     }
23697:   }
23697: 
23697:   return nsSVGAnimationElementBase::ParseAttribute(aNamespaceID, aAttribute,
23697:                                                    aValue, aResult);
23697: }
23697: 
23697: nsresult
23697: nsSVGAnimationElement::UnsetAttr(PRInt32 aNamespaceID,
23697:                                  nsIAtom* aAttribute, PRBool aNotify)
23697: {
23697:   nsresult rv = nsSVGAnimationElementBase::UnsetAttr(aNamespaceID, aAttribute,
23697:                                                      aNotify);
23697:   NS_ENSURE_SUCCESS(rv,rv);
23697: 
23697:   if (aNamespaceID == kNameSpaceID_None) {
24029:     if (AnimationFunction().UnsetAttr(aAttribute) ||
24029:         mTimedElement.UnsetAttr(aAttribute)) {
24029:       AnimationNeedsResample();
23697:     }
23697:   }
23697: 
23697:   return NS_OK;
23697: }
23697: 
23697: //----------------------------------------------------------------------
23697: // Implementation helpers
23697: 
23697: nsSMILTimeContainer*
23697: nsSVGAnimationElement::GetTimeContainer()
23697: {
23697:   nsSMILTimeContainer *result = nsnull;
23697:   nsCOMPtr<nsIDOMSVGSVGElement> ownerDOMSVG;
23697: 
23697:   nsresult rv = GetOwnerSVGElement(getter_AddRefs(ownerDOMSVG));
23697: 
23697:   if (NS_SUCCEEDED(rv) && ownerDOMSVG) {
23697:     nsSVGSVGElement *ownerSVG =
23697:       static_cast<nsSVGSVGElement*>(ownerDOMSVG.get());
23697:     result = ownerSVG->GetTimedDocumentRoot();
23697:   }
23697: 
23697:   return result;
23697: }
23697: 
23697: // nsIDOMElementTimeControl
23697: /* void beginElement (); */
23697: NS_IMETHODIMP
23697: nsSVGAnimationElement::BeginElement(void)
23697: {
23697:   return BeginElementAt(0.f);
23697: }
23697: 
23697: /* void beginElementAt (in float offset); */
23697: NS_IMETHODIMP
23697: nsSVGAnimationElement::BeginElementAt(float offset)
23697: {
24029:   nsresult rv = mTimedElement.BeginElementAt(offset, mTimedDocumentRoot);
24029:   AnimationNeedsResample();
23697: 
24029:   return rv;
23697: }
23697: 
23697: /* void endElement (); */
23697: NS_IMETHODIMP
23697: nsSVGAnimationElement::EndElement(void)
23697: {
23697:   return EndElementAt(0.f);
23697: }
23697: 
23697: /* void endElementAt (in float offset); */
23697: NS_IMETHODIMP
23697: nsSVGAnimationElement::EndElementAt(float offset)
23697: {
24029:   nsresult rv = mTimedElement.EndElementAt(offset, mTimedDocumentRoot);
24029:   AnimationNeedsResample();
23697: 
24029:   return rv;
23697: }
