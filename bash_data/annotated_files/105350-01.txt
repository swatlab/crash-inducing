     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: 
     1: #include "nsWebShellWindow.h"
     1: 
     1: #include "nsLayoutCID.h"
     1: #include "nsContentCID.h"
     1: #include "nsIWeakReference.h"
 80401: #include "nsIContentViewer.h"
     1: #include "nsIComponentManager.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsIURL.h"
     1: #include "nsIIOService.h"
     1: #include "nsIURL.h"
     1: #include "nsNetCID.h"
     1: #include "nsIStringBundle.h"
     1: #include "nsReadableUtils.h"
     1: 
     1: #include "nsEscape.h"
     1: #include "nsPIDOMWindow.h"
     1: #include "nsIDOMEventTarget.h"
     1: #include "nsIWebNavigation.h"
     1: #include "nsIWindowWatcher.h"
     1: 
     1: #include "nsIDOMXULElement.h"
     1: 
     1: #include "nsGUIEvent.h"
     1: #include "nsWidgetsCID.h"
     1: #include "nsIWidget.h"
     1: 
     1: #include "nsIDOMCharacterData.h"
     1: #include "nsIDOMNodeList.h"
     1: 
     1: #include "nsITimer.h"
  8408: #include "nsXULPopupManager.h"
     1: 
     1: #include "prmem.h"
     1: 
     1: #include "nsIDOMXULDocument.h"
     1: 
 29018: #include "nsFocusManager.h"
     1: 
     1: #include "nsIWebProgress.h"
     1: #include "nsIWebProgressListener.h"
     1: 
     1: #include "nsIDocument.h"
     1: #include "nsIDOMDocument.h"
     1: #include "nsIDOMNode.h"
     1: #include "nsIDOMElement.h"
     1: #include "nsIDocumentLoaderFactory.h"
     1: #include "nsIObserverService.h"
     1: #include "prprf.h"
     1: 
 55224: #include "nsIScreenManager.h"
 55224: #include "nsIScreen.h"
 55224: 
     1: #include "nsIContent.h" // for menus
105282: #include "nsIScriptSecurityManager.h"
     1: 
     1: // For calculating size
     1: #include "nsIFrame.h"
     1: #include "nsIPresShell.h"
     1: #include "nsPresContext.h"
     1: 
     1: #include "nsIBaseWindow.h"
     1: #include "nsIDocShellTreeItem.h"
     1: #include "nsIDocShellTreeNode.h"
     1: 
     1: #include "nsIMarkupDocumentViewer.h"
     1: 
 15578: #ifdef XP_MACOSX
 15578: #include "nsINativeMenuService.h"
     1: #define USE_NATIVE_MENUS
     1: #endif
     1: 
 64576: using namespace mozilla;
 64576: 
     1: /* Define Class IDs */
     1: static NS_DEFINE_CID(kWindowCID,           NS_WINDOW_CID);
     1: 
     1: #define SIZE_PERSISTENCE_TIMEOUT 500 // msec
     1: 
 31556: nsWebShellWindow::nsWebShellWindow(PRUint32 aChromeFlags)
 31556:   : nsXULWindow(aChromeFlags)
 64576:   , mSPTimerLock("nsWebShellWindow.mSPTimerLock")
     1: {
     1: }
     1: 
     1: 
     1: nsWebShellWindow::~nsWebShellWindow()
     1: {
 16037:   if (mWindow) {
     1:     mWindow->SetClientData(0);
 16037:     mWindow->Destroy();
     1:     mWindow = nsnull; // Force release here.
 16037:   }
     1: 
 64576:   MutexAutoLock lock(mSPTimerLock);
     1:   if (mSPTimer)
     1:     mSPTimer->Cancel();
     1: }
     1: 
     1: NS_IMPL_ADDREF_INHERITED(nsWebShellWindow, nsXULWindow)
     1: NS_IMPL_RELEASE_INHERITED(nsWebShellWindow, nsXULWindow)
     1: 
     1: NS_INTERFACE_MAP_BEGIN(nsWebShellWindow)
     1:   NS_INTERFACE_MAP_ENTRY(nsIWebProgressListener)
     1: NS_INTERFACE_MAP_END_INHERITING(nsXULWindow)
     1: 
     1: nsresult nsWebShellWindow::Initialize(nsIXULWindow* aParent,
 33261:                                       nsIXULWindow* aOpener,
 80433:                                       nsIURI* aUrl,
     1:                                       PRInt32 aInitialWidth,
     1:                                       PRInt32 aInitialHeight,
 79445:                                       bool aIsHiddenWindow,
     1:                                       nsWidgetInitData& widgetInitData)
     1: {
     1:   nsresult rv;
     1:   nsCOMPtr<nsIWidget> parentWidget;
     1: 
     1:   mIsHiddenWindow = aIsHiddenWindow;
     1: 
 55224:   PRInt32 initialX = 0, initialY = 0;
 33261:   nsCOMPtr<nsIBaseWindow> base(do_QueryInterface(aOpener));
 33261:   if (base) {
 33261:     rv = base->GetPositionAndSize(&mOpenerScreenRect.x,
 33261:                                   &mOpenerScreenRect.y,
 33261:                                   &mOpenerScreenRect.width,
 33261:                                   &mOpenerScreenRect.height);
 33261:     if (NS_FAILED(rv)) {
 68639:       mOpenerScreenRect.SetEmpty();
 55224:     } else {
 55224:       initialX = mOpenerScreenRect.x;
 55224:       initialY = mOpenerScreenRect.y;
 55224:       ConstrainToOpenerScreen(&initialX, &initialY);
 33261:     }
 33261:   }
 33261: 
     1:   // XXX: need to get the default window size from prefs...
     1:   // Doesn't come from prefs... will come from CSS/XUL/RDF
 55224:   nsIntRect r(initialX, initialY, aInitialWidth, aInitialHeight);
     1:   
     1:   // Create top level window
     1:   mWindow = do_CreateInstance(kWindowCID, &rv);
     1:   if (NS_OK != rv) {
     1:     return rv;
     1:   }
     1: 
     1:   /* This next bit is troublesome. We carry two different versions of a pointer
     1:      to our parent window. One is the parent window's widget, which is passed
     1:      to our own widget. The other is a weak reference we keep here to our
     1:      parent WebShellWindow. The former is useful to the widget, and we can't
     1:      trust its treatment of the parent reference because they're platform-
     1:      specific. The latter is useful to this class.
     1:        A better implementation would be one in which the parent keeps strong
     1:      references to its children and closes them before it allows itself
     1:      to be closed. This would mimic the behaviour of OSes that support
     1:      top-level child windows in OSes that do not. Later.
     1:   */
     1:   nsCOMPtr<nsIBaseWindow> parentAsWin(do_QueryInterface(aParent));
     1:   if (parentAsWin) {
     1:     parentAsWin->GetMainWidget(getter_AddRefs(parentWidget));
     1:     mParentWindow = do_GetWeakReference(aParent);
     1:   }
     1: 
     1:   mWindow->SetClientData(this);
     1:   mWindow->Create((nsIWidget *)parentWidget,          // Parent nsIWidget
 33013:                   nsnull,                             // Native parent widget
     1:                   r,                                  // Widget dimensions
     1:                   nsWebShellWindow::HandleEvent,      // Event handler function
     1:                   nsnull,                             // Device context
     1:                   &widgetInitData);                   // Widget initialization data
     1:   mWindow->GetClientBounds(r);
 52184:   // Match the default background color of content. Important on windows
 52184:   // since we no longer use content child widgets.
 52184:   mWindow->SetBackgroundColor(NS_RGB(255,255,255));
     1: 
     1:   // Create web shell
 28078:   mDocShell = do_CreateInstance("@mozilla.org/docshell;1");
     1:   NS_ENSURE_TRUE(mDocShell, NS_ERROR_FAILURE);
     1: 
     1:   // Make sure to set the item type on the docshell _before_ calling
     1:   // Create() so it knows what type it is.
     1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
     1:   NS_ENSURE_TRUE(docShellAsItem, NS_ERROR_FAILURE);
     1:   NS_ENSURE_SUCCESS(EnsureChromeTreeOwner(), NS_ERROR_FAILURE);
     1: 
     1:   docShellAsItem->SetTreeOwner(mChromeTreeOwner);
     1:   docShellAsItem->SetItemType(nsIDocShellTreeItem::typeChrome);
     1: 
     1:   r.x = r.y = 0;
     1:   nsCOMPtr<nsIBaseWindow> docShellAsWin(do_QueryInterface(mDocShell));
     1:   NS_ENSURE_SUCCESS(docShellAsWin->InitWindow(nsnull, mWindow, 
     1:    r.x, r.y, r.width, r.height), NS_ERROR_FAILURE);
     1:   NS_ENSURE_SUCCESS(docShellAsWin->Create(), NS_ERROR_FAILURE);
     1: 
     1:   // Attach a WebProgress listener.during initialization...
     1:   nsCOMPtr<nsIWebProgress> webProgress(do_GetInterface(mDocShell, &rv));
     1:   if (webProgress) {
     1:     webProgress->AddProgressListener(this, nsIWebProgress::NOTIFY_STATE_NETWORK);
     1:   }
     1: 
105282:   // Eagerly create an about:blank content viewer with the right principal here,
105282:   // rather than letting it happening in the upcoming call to
105282:   // SetInitialPrincipalToSubject. This avoids creating the about:blank document
105282:   // and then blowing it away with a second one, which can cause problems for the
105282:   // top-level chrome window case. See bug 789773.
105282:   nsCOMPtr<nsIScriptSecurityManager> ssm =
105282:     do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
105350:   if (ssm) { // Sometimes this happens really early  See bug 793370.
105282:     nsCOMPtr<nsIPrincipal> principal;
105282:     ssm->GetSubjectPrincipal(getter_AddRefs(principal));
105282:     if (!principal) {
105282:       ssm->GetSystemPrincipal(getter_AddRefs(principal));
105282:     }
105282:     rv = mDocShell->CreateAboutBlankContentViewer(principal);
105282:     NS_ENSURE_SUCCESS(rv, rv);
105282:     nsCOMPtr<nsIDocument> doc = do_GetInterface(mDocShell);
105282:     NS_ENSURE_TRUE(!!doc, NS_ERROR_FAILURE);
105282:     doc->SetIsInitialDocument(true);
105350:   }
105282: 
     1:   if (nsnull != aUrl)  {
 31556:     nsCString tmpStr;
     1: 
     1:     rv = aUrl->GetSpec(tmpStr);
     1:     if (NS_FAILED(rv)) return rv;
     1: 
     1:     NS_ConvertUTF8toUTF16 urlString(tmpStr);
     1:     nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(mDocShell));
     1:     NS_ENSURE_TRUE(webNav, NS_ERROR_FAILURE);
     1:     rv = webNav->LoadURI(urlString.get(),
     1:                          nsIWebNavigation::LOAD_FLAGS_NONE,
     1:                          nsnull,
     1:                          nsnull,
     1:                          nsnull);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1:                      
     1:   return rv;
     1: }
     1: 
     1: 
     1: /*
     1:  * Toolbar
     1:  */
     1: nsresult
     1: nsWebShellWindow::Toolbar()
     1: {
     1:     nsCOMPtr<nsIXULWindow> kungFuDeathGrip(this);
     1:     nsCOMPtr<nsIWebBrowserChrome> wbc(do_GetInterface(kungFuDeathGrip));
     1:     if (!wbc)
     1:       return NS_ERROR_UNEXPECTED;
     1: 
     1:     // rjc: don't use "nsIWebBrowserChrome::CHROME_EXTRA"
     1:     //      due to components with multiple sidebar components
     1:     //      (such as Mail/News, Addressbook, etc)... and frankly,
     1:     //      Mac IE, OmniWeb, and other Mac OS X apps all work this way
     1: 
     1:     PRUint32    chromeMask = (nsIWebBrowserChrome::CHROME_TOOLBAR |
     1:                               nsIWebBrowserChrome::CHROME_LOCATIONBAR |
     1:                               nsIWebBrowserChrome::CHROME_PERSONAL_TOOLBAR);
     1: 
     1:     PRUint32    chromeFlags, newChromeFlags = 0;
     1:     wbc->GetChromeFlags(&chromeFlags);
     1:     newChromeFlags = chromeFlags & chromeMask;
     1:     if (!newChromeFlags)    chromeFlags |= chromeMask;
     1:     else                    chromeFlags &= (~newChromeFlags);
     1:     wbc->SetChromeFlags(chromeFlags);
     1:     return NS_OK;
     1: }
     1: 
     1: 
     1: /*
     1:  * Event handler function...
     1:  *
     1:  * This function is called to process events for the nsIWidget of the 
     1:  * nsWebShellWindow...
     1:  */
 20261: nsEventStatus
     1: nsWebShellWindow::HandleEvent(nsGUIEvent *aEvent)
     1: {
     1:   nsEventStatus result = nsEventStatus_eIgnore;
     1:   nsIDocShell* docShell = nsnull;
     1:   nsWebShellWindow *eventWindow = nsnull;
     1: 
     1:   // Get the WebShell instance...
     1:   if (nsnull != aEvent->widget) {
     1:     void* data;
     1: 
     1:     aEvent->widget->GetClientData(data);
     1:     if (data != nsnull) {
  3233:       eventWindow = reinterpret_cast<nsWebShellWindow *>(data);
     1:       docShell = eventWindow->mDocShell;
     1:     }
     1:   }
     1: 
     1:   if (docShell) {
     1:     switch(aEvent->message) {
     1:       /*
     1:        * For size events, the DocShell must be resized to fill the entire
     1:        * client area of the window...
     1:        */
     1:       case NS_MOVE: {
 48253:         // Adjust any child popups so that their widget offsets and coordinates
 48253:         // are correct with respect to the new position of the window
 82030:         nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 48252:         if (pm) {
 48252:           nsCOMPtr<nsPIDOMWindow> window = do_GetInterface(docShell);
 48252:           pm->AdjustPopupsOnWindowChange(window);
 48252:         }
  8408: 
     1:         // persist position, but not immediately, in case this OS is firing
     1:         // repeated move events as the user drags the window
     1:         eventWindow->SetPersistenceTimer(PAD_POSITION);
     1:         break;
     1:       }
     1:       case NS_SIZE: {
 82030:         nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 48252:         if (pm) {
 48252:           nsCOMPtr<nsPIDOMWindow> window = do_GetInterface(docShell);
 48252:           pm->AdjustPopupsOnWindowChange(window);
 48252:         }
  8408:  
     1:         nsSizeEvent* sizeEvent = (nsSizeEvent*)aEvent;
     1:         nsCOMPtr<nsIBaseWindow> shellAsWin(do_QueryInterface(docShell));
     1:         shellAsWin->SetPositionAndSize(0, 0, sizeEvent->windowSize->width, 
 80486:           sizeEvent->windowSize->height, false);  
     1:         // persist size, but not immediately, in case this OS is firing
     1:         // repeated size events as the user drags the sizing handle
     1:         if (!eventWindow->IsLocked())
 31400:           eventWindow->SetPersistenceTimer(PAD_POSITION | PAD_SIZE | PAD_MISC);
     1:         result = nsEventStatus_eConsumeNoDefault;
     1:         break;
     1:       }
     1:       case NS_SIZEMODE: {
     1:         nsSizeModeEvent* modeEvent = (nsSizeModeEvent*)aEvent;
     1: 
     1:         // an alwaysRaised (or higher) window will hide any newly opened
     1:         // normal browser windows. here we just drop a raised window
     1:         // to the normal zlevel if it's maximized. we make no provision
     1:         // for automatically re-raising it when restored.
 30075:         if (modeEvent->mSizeMode == nsSizeMode_Maximized ||
 30075:             modeEvent->mSizeMode == nsSizeMode_Fullscreen) {
     1:           PRUint32 zLevel;
     1:           eventWindow->GetZLevel(&zLevel);
     1:           if (zLevel > nsIXULWindow::normalZ)
     1:             eventWindow->SetZLevel(nsIXULWindow::normalZ);
     1:         }
     1: 
     1:         aEvent->widget->SetSizeMode(modeEvent->mSizeMode);
     1: 
     1:         // persist mode, but not immediately, because in many (all?)
     1:         // cases this will merge with the similar call in NS_SIZE and
     1:         // write the attribute values only once.
     1:         eventWindow->SetPersistenceTimer(PAD_MISC);
     1:         result = nsEventStatus_eConsumeDoDefault;
     1: 
 73680:         nsCOMPtr<nsPIDOMWindow> ourWindow = do_GetInterface(docShell);
 73680:         if (ourWindow) {
 73680:           // Let the application know if it's in fullscreen mode so it
 73680:           // can update its UI.
 72140:           if (modeEvent->mSizeMode == nsSizeMode_Fullscreen) {
 80486:             ourWindow->SetFullScreen(true);
 51548:           }
 89522:           else if (modeEvent->mSizeMode != nsSizeMode_Minimized) {
 89522:             ourWindow->SetFullScreen(false);
 89522:           }
 51548: 
 73680:           // And always fire a user-defined sizemodechange event on the window
 73680:           ourWindow->DispatchCustomEvent("sizemodechange");
 73680:         }
 73680: 
     1:         // Note the current implementation of SetSizeMode just stores
     1:         // the new state; it doesn't actually resize. So here we store
     1:         // the state and pass the event on to the OS. The day is coming
     1:         // when we'll handle the event here, and the return result will
     1:         // then need to be different.
     1:         break;
     1:       }
     1:       case NS_OS_TOOLBAR: {
     1:         nsCOMPtr<nsIXULWindow> kungFuDeathGrip(eventWindow);
     1:         eventWindow->Toolbar();
     1:         break;
     1:       }
     1:       case NS_XUL_CLOSE: {
     1:         // Calling ExecuteCloseHandler may actually close the window
     1:         // (it probably shouldn't, but you never know what the users JS 
     1:         // code will do).  Therefore we add a death-grip to the window
     1:         // for the duration of the close handler.
     1:         nsCOMPtr<nsIXULWindow> kungFuDeathGrip(eventWindow);
     1:         if (!eventWindow->ExecuteCloseHandler())
     1:           eventWindow->Destroy();
     1:         break;
     1:       }
     1:       /*
     1:        * Notify the ApplicationShellService that the window is being closed...
     1:        */
     1:       case NS_DESTROY: {
     1:         eventWindow->Destroy();
     1:         break;
     1:       }
     1: 
 41071:       case NS_UISTATECHANGED: {
 41071:         nsCOMPtr<nsPIDOMWindow> window = do_GetInterface(docShell);
 41071:         if (window) {
 41071:           nsUIStateChangeEvent* event = (nsUIStateChangeEvent*)aEvent;
 41071:           window->SetKeyboardIndicators(event->showAccelerators, event->showFocusRings);
 41071:         }
 41071:         break;
 41071:       }
 41071: 
     1:       case NS_SETZLEVEL: {
     1:         nsZLevelEvent *zEvent = (nsZLevelEvent *) aEvent;
     1: 
     1:         zEvent->mAdjusted = eventWindow->ConstrainToZLevel(zEvent->mImmediate,
     1:                               &zEvent->mPlacement,
     1:                               zEvent->mReqBelow, &zEvent->mActualBelow);
     1:         break;
     1:       }
     1: 
     1:       case NS_ACTIVATE: {
 13389: #if defined(DEBUG_saari) || defined(DEBUG_smaug)
     1:         printf("nsWebShellWindow::NS_ACTIVATE\n");
     1: #endif
 29018:         // focusing the window could cause it to close, so keep a reference to it
 29018:         nsCOMPtr<nsIXULWindow> kungFuDeathGrip(eventWindow);
 29018: 
 29018:         nsCOMPtr<nsIDOMWindow> window = do_GetInterface(docShell);
 29018:         nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
 29018:         if (fm && window)
 29018:           fm->WindowRaised(window);
 29018: 
 29018:         if (eventWindow->mChromeLoaded) {
 29018:           eventWindow->PersistentAttributesDirty(
 29018:                              PAD_POSITION | PAD_SIZE | PAD_MISC);
 29018:           eventWindow->SavePersistentAttributes();
 29018:         }
     1: 
     1:         break;
     1:       }
     1: 
     1:       case NS_DEACTIVATE: {
 13389: #if defined(DEBUG_saari) || defined(DEBUG_smaug)
     1:         printf("nsWebShellWindow::NS_DEACTIVATE\n");
     1: #endif
     1: 
 29018:         nsCOMPtr<nsIDOMWindow> window = do_GetInterface(docShell);
 29018:         nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
 29018:         if (fm && window)
 29018:           fm->WindowLowered(window);
     1:         break;
     1:       }
     1:       
 24781:       case NS_GETACCESSIBLE: {
 24781:         nsCOMPtr<nsIPresShell> presShell;
 24781:         docShell->GetPresShell(getter_AddRefs(presShell));
 24781:         if (presShell) {
 24781:           presShell->HandleEventWithTarget(aEvent, nsnull, nsnull, &result);
 24781:         }
 24781:         break;
 24781:       }
     1:       default:
     1:         break;
     1: 
     1:     }
     1:   }
     1:   return result;
     1: }
     1: 
     1: #ifdef USE_NATIVE_MENUS
  5946: static void LoadNativeMenus(nsIDOMDocument *aDOMDoc, nsIWidget *aParentWindow)
     1: {
     1:   // Find the menubar tag (if there is more than one, we ignore all but
     1:   // the first).
     1:   nsCOMPtr<nsIDOMNodeList> menubarElements;
     1:   aDOMDoc->GetElementsByTagNameNS(NS_LITERAL_STRING("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"),
     1:                                   NS_LITERAL_STRING("menubar"),
     1:                                   getter_AddRefs(menubarElements));
     1: 
     1:   nsCOMPtr<nsIDOMNode> menubarNode;
     1:   if (menubarElements)
     1:     menubarElements->Item(0, getter_AddRefs(menubarNode));
     1:   if (!menubarNode)
     1:     return;
     1: 
 15578:   nsCOMPtr<nsINativeMenuService> nms = do_GetService("@mozilla.org/widget/nativemenuservice;1");
 15578:   nsCOMPtr<nsIContent> menubarContent(do_QueryInterface(menubarNode));
 15578:   if (nms && menubarContent)
 15578:     nms->CreateNativeMenuBar(aParentWindow, menubarContent);
     1: }
     1: #endif
     1: 
     1: void
     1: nsWebShellWindow::SetPersistenceTimer(PRUint32 aDirtyFlags)
     1: {
 64576:   MutexAutoLock lock(mSPTimerLock);
 24552:   if (!mSPTimer) {
     1:     nsresult rv;
     1:     mSPTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
     1:     if (NS_SUCCEEDED(rv)) {
     1:       NS_ADDREF_THIS(); // for the timer, which holds a reference to this window
 24552:     }
 24552:   }
     1:   mSPTimer->InitWithFuncCallback(FirePersistenceTimer, this,
     1:                                  SIZE_PERSISTENCE_TIMEOUT, nsITimer::TYPE_ONE_SHOT);
     1:   PersistentAttributesDirty(aDirtyFlags);
     1: }
     1: 
     1: void
     1: nsWebShellWindow::FirePersistenceTimer(nsITimer *aTimer, void *aClosure)
     1: {
  3233:   nsWebShellWindow *win = static_cast<nsWebShellWindow *>(aClosure);
 64576:   MutexAutoLock lock(win->mSPTimerLock);
     1:   win->SavePersistentAttributes();
     1: }
     1: 
     1: 
     1: //----------------------------------------
     1: // nsIWebProgessListener implementation
     1: //----------------------------------------
     1: NS_IMETHODIMP
     1: nsWebShellWindow::OnProgressChange(nsIWebProgress *aProgress,
     1:                                    nsIRequest *aRequest,
     1:                                    PRInt32 aCurSelfProgress,
     1:                                    PRInt32 aMaxSelfProgress,
     1:                                    PRInt32 aCurTotalProgress,
     1:                                    PRInt32 aMaxTotalProgress)
     1: {
     1:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsWebShellWindow::OnStateChange(nsIWebProgress *aProgress,
     1:                                 nsIRequest *aRequest,
     1:                                 PRUint32 aStateFlags,
     1:                                 nsresult aStatus)
     1: {
     1:   // If the notification is not about a document finishing, then just
     1:   // ignore it...
     1:   if (!(aStateFlags & nsIWebProgressListener::STATE_STOP) || 
     1:       !(aStateFlags & nsIWebProgressListener::STATE_IS_NETWORK)) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   if (mChromeLoaded)
     1:     return NS_OK;
     1: 
     1:   // If this document notification is for a frame then ignore it...
     1:   nsCOMPtr<nsIDOMWindow> eventWin;
     1:   aProgress->GetDOMWindow(getter_AddRefs(eventWin));
     1:   nsCOMPtr<nsPIDOMWindow> eventPWin(do_QueryInterface(eventWin));
     1:   if (eventPWin) {
     1:     nsPIDOMWindow *rootPWin = eventPWin->GetPrivateRoot();
     1:     if (eventPWin != rootPWin)
     1:       return NS_OK;
     1:   }
     1: 
 80486:   mChromeLoaded = true;
 80486:   mLockedUntilChromeLoad = false;
     1: 
     1: #ifdef USE_NATIVE_MENUS
     1:   ///////////////////////////////
     1:   // Find the Menubar DOM  and Load the menus, hooking them up to the loaded commands
     1:   ///////////////////////////////
 80434:   nsCOMPtr<nsIContentViewer> cv;
 80434:   mDocShell->GetContentViewer(getter_AddRefs(cv));
 80434:   if (cv) {
 80434:     nsCOMPtr<nsIDOMDocument> menubarDOMDoc(do_QueryInterface(cv->GetDocument()));
     1:     if (menubarDOMDoc)
  5946:       LoadNativeMenus(menubarDOMDoc, mWindow);
 80434:   }
     1: #endif // USE_NATIVE_MENUS
     1: 
     1:   OnChromeLoaded();
     1:   LoadContentAreas();
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsWebShellWindow::OnLocationChange(nsIWebProgress *aProgress,
     1:                                    nsIRequest *aRequest,
 82127:                                    nsIURI *aURI,
 82127:                                    PRUint32 aFlags)
     1: {
     1:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsWebShellWindow::OnStatusChange(nsIWebProgress* aWebProgress,
     1:                                  nsIRequest* aRequest,
     1:                                  nsresult aStatus,
     1:                                  const PRUnichar* aMessage)
     1: {
     1:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsWebShellWindow::OnSecurityChange(nsIWebProgress *aWebProgress,
     1:                                    nsIRequest *aRequest,
     1:                                    PRUint32 state)
     1: {
     1:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: //----------------------------------------
     1: 
     1: // if the main document URL specified URLs for any content areas, start them loading
     1: void nsWebShellWindow::LoadContentAreas() {
     1: 
     1:   nsAutoString searchSpec;
     1: 
     1:   // fetch the chrome document URL
     1:   nsCOMPtr<nsIContentViewer> contentViewer;
     1:   // yes, it's possible for the docshell to be null even this early
     1:   // see bug 57514.
     1:   if (mDocShell)
     1:     mDocShell->GetContentViewer(getter_AddRefs(contentViewer));
     1:   if (contentViewer) {
 37433:     nsIDocument* doc = contentViewer->GetDocument();
 37433:     if (doc) {
     1:       nsIURI* mainURL = doc->GetDocumentURI();
     1: 
     1:       nsCOMPtr<nsIURL> url = do_QueryInterface(mainURL);
     1:       if (url) {
     1:         nsCAutoString search;
     1:         url->GetQuery(search);
     1: 
     1:         AppendUTF8toUTF16(search, searchSpec);
     1:       }
     1:     }
     1:   }
     1: 
     1:   // content URLs are specified in the search part of the URL
     1:   // as <contentareaID>=<escapedURL>[;(repeat)]
     1:   if (!searchSpec.IsEmpty()) {
     1:     PRInt32     begPos,
     1:                 eqPos,
     1:                 endPos;
     1:     nsString    contentAreaID,
     1:                 contentURL;
     1:     char        *urlChar;
     1:     nsresult rv;
     1:     for (endPos = 0; endPos < (PRInt32)searchSpec.Length(); ) {
     1:       // extract contentAreaID and URL substrings
     1:       begPos = endPos;
     1:       eqPos = searchSpec.FindChar('=', begPos);
     1:       if (eqPos < 0)
     1:         break;
     1: 
     1:       endPos = searchSpec.FindChar(';', eqPos);
     1:       if (endPos < 0)
     1:         endPos = searchSpec.Length();
     1:       searchSpec.Mid(contentAreaID, begPos, eqPos-begPos);
     1:       searchSpec.Mid(contentURL, eqPos+1, endPos-eqPos-1);
     1:       endPos++;
     1: 
     1:       // see if we have a docshell with a matching contentAreaID
     1:       nsCOMPtr<nsIDocShellTreeItem> content;
     1:       rv = GetContentShellById(contentAreaID.get(), getter_AddRefs(content));
     1:       if (NS_SUCCEEDED(rv) && content) {
     1:         nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(content));
     1:         if (webNav) {
     1:           urlChar = ToNewCString(contentURL);
     1:           if (urlChar) {
     1:             nsUnescape(urlChar);
     1:             contentURL.AssignWithConversion(urlChar);
     1:             webNav->LoadURI(contentURL.get(),
     1:                           nsIWebNavigation::LOAD_FLAGS_NONE,
     1:                           nsnull,
     1:                           nsnull,
     1:                           nsnull);
     1:             nsMemory::Free(urlChar);
     1:           }
     1:         }
     1:       }
     1:     }
     1:   }
     1: }
     1: 
     1: /**
     1:  * ExecuteCloseHandler - Run the close handler, if any.
 80486:  * @return true iff we found a close handler to run.
     1:  */
 79445: bool nsWebShellWindow::ExecuteCloseHandler()
     1: {
     1:   /* If the event handler closes this window -- a likely scenario --
     1:      things get deleted out of order without this death grip.
     1:      (The problem may be the death grip in nsWindow::windowProc,
     1:      which forces this window's widget to remain alive longer
     1:      than it otherwise would.) */
     1:   nsCOMPtr<nsIXULWindow> kungFuDeathGrip(this);
     1: 
     1:   nsCOMPtr<nsPIDOMWindow> window(do_GetInterface(mDocShell));
 72326:   nsCOMPtr<nsIDOMEventTarget> eventTarget = do_QueryInterface(window);
     1: 
     1:   if (eventTarget) {
     1:     nsCOMPtr<nsIContentViewer> contentViewer;
     1:     mDocShell->GetContentViewer(getter_AddRefs(contentViewer));
 80401:     if (contentViewer) {
 39823:       nsRefPtr<nsPresContext> presContext;
 80401:       contentViewer->GetPresContext(getter_AddRefs(presContext));
     1: 
     1:       nsEventStatus status = nsEventStatus_eIgnore;
 80486:       nsMouseEvent event(true, NS_XUL_CLOSE, nsnull,
     1:                          nsMouseEvent::eReal);
     1: 
     1:       nsresult rv =
     1:         eventTarget->DispatchDOMEvent(&event, nsnull, presContext, &status);
     1:       if (NS_SUCCEEDED(rv) && status == nsEventStatus_eConsumeNoDefault)
 80486:         return true;
 80486:       // else fall through and return false
     1:     }
     1:   }
     1: 
 80486:   return false;
     1: } // ExecuteCloseHandler
     1: 
 55224: void nsWebShellWindow::ConstrainToOpenerScreen(PRInt32* aX, PRInt32* aY)
 55224: {
 55224:   if (mOpenerScreenRect.IsEmpty()) {
 55224:     *aX = *aY = 0;
 55224:     return;
 55224:   }
 55224: 
 55224:   PRInt32 left, top, width, height;
 55224:   // Constrain initial positions to the same screen as opener
 55224:   nsCOMPtr<nsIScreenManager> screenmgr = do_GetService("@mozilla.org/gfx/screenmanager;1");
 55224:   if (screenmgr) {
 55224:     nsCOMPtr<nsIScreen> screen;
 55224:     screenmgr->ScreenForRect(mOpenerScreenRect.x, mOpenerScreenRect.y,
 55224:                              mOpenerScreenRect.width, mOpenerScreenRect.height,
 55224:                              getter_AddRefs(screen));
 55224:     if (screen) {
 55224:       screen->GetAvailRect(&left, &top, &width, &height);
 71876:       if (*aX < left || *aX > left + width) {
 55224:         *aX = left;
 55224:       }
 55224:       if (*aY < top || *aY > top + height) {
 55224:         *aY = top;
 55224:       }
 55224:     }
 55224:   }
 55224: }
 55224: 
     1: // nsIBaseWindow
     1: NS_IMETHODIMP nsWebShellWindow::Destroy()
     1: {
     1:   nsresult rv;
     1:   nsCOMPtr<nsIWebProgress> webProgress(do_GetInterface(mDocShell, &rv));
     1:   if (webProgress) {
     1:     webProgress->RemoveProgressListener(this);
     1:   }
     1: 
     1:   nsCOMPtr<nsIXULWindow> kungFuDeathGrip(this);
 64576:   {
 64576:     MutexAutoLock lock(mSPTimerLock);
     1:     if (mSPTimer) {
     1:       mSPTimer->Cancel();
     1:       SavePersistentAttributes();
     1:       mSPTimer = nsnull;
     1:       NS_RELEASE_THIS(); // the timer held a reference to us
     1:     }
     1:   }
     1:   return nsXULWindow::Destroy();
     1: }
