    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Joe Hewitt <hewitt@netscape.com> (Original Author)
    1:  *   Dean Tessman <dean_tessman@hotmail.com>
    1:  *   Johnny Stenback <jst@mozilla.jstenback.com>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsAutoCompleteController.h"
    1: #include "nsAutoCompleteSimpleResult.h"
    1: 
    1: #include "nsNetCID.h"
    1: #include "nsIIOService.h"
    1: #include "nsToolkitCompsCID.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIAtomService.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsITreeColumns.h"
    1: #include "nsIObserverService.h"
    1: #include "nsIDOMKeyEvent.h"
41540: #include "mozilla/Services.h"
46998: #include "mozilla/ModuleUtils.h"
    1: 
    1: static const char *kAutoCompleteSearchCID = "@mozilla.org/autocomplete/search;1?name=";
    1: 
21610: NS_IMPL_CYCLE_COLLECTION_CLASS(nsAutoCompleteController)
21610: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsAutoCompleteController)
21610:   tmp->SetInput(nsnull);
21610: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
21610: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsAutoCompleteController)
21610:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mInput)
21610:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mSearches)
21610:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mResults)
21610: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
21610: 
21610: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsAutoCompleteController)
21610: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsAutoCompleteController)
21610: NS_INTERFACE_TABLE_HEAD(nsAutoCompleteController)
21610:   NS_INTERFACE_TABLE4(nsAutoCompleteController, nsIAutoCompleteController,
21610:                       nsIAutoCompleteObserver, nsITimerCallback, nsITreeView)
21610:   NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION(nsAutoCompleteController)
21610: NS_INTERFACE_MAP_END
    1: 
    1: nsAutoCompleteController::nsAutoCompleteController() :
    1:   mDefaultIndexCompleted(PR_FALSE),
    1:   mBackspaced(PR_FALSE),
    1:   mPopupClosedByCompositionStart(PR_FALSE),
    1:   mIsIMEComposing(PR_FALSE),
    1:   mIgnoreHandleText(PR_FALSE),
    1:   mIsOpen(PR_FALSE),
23279:   mSearchStatus(nsAutoCompleteController::STATUS_NONE),
    1:   mRowCount(0),
 4881:   mSearchesOngoing(0),
 4881:   mFirstSearchResult(PR_FALSE)
    1: {
    1: }
    1: 
    1: nsAutoCompleteController::~nsAutoCompleteController()
    1: {
    1:   SetInput(nsnull);
    1: }
    1: 
    1: ////////////////////////////////////////////////////////////////////////
    1: //// nsIAutoCompleteController
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::GetSearchStatus(PRUint16 *aSearchStatus)
    1: {
    1:   *aSearchStatus = mSearchStatus;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::GetMatchCount(PRUint32 *aMatchCount)
    1: {
    1:   *aMatchCount = mRowCount;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::GetInput(nsIAutoCompleteInput **aInput)
    1: {
    1:   *aInput = mInput;
    1:   NS_IF_ADDREF(*aInput);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::SetInput(nsIAutoCompleteInput *aInput)
    1: {
    1:   // Don't do anything if the input isn't changing.
    1:   if (mInput == aInput)
    1:     return NS_OK;
    1: 
    1:   // Clear out the current search context
    1:   if (mInput) {
 4881:     // Stop all searches in case they are async.
 4881:     StopSearch();
    1:     ClearResults();
 4881:     if (mIsOpen)
    1:       ClosePopup();
21610:     mSearches.Clear();
    1:   }
    1: 
    1:   mInput = aInput;
    1: 
    1:   // Nothing more to do if the input was just being set to null.
    1:   if (!aInput)
    1:     return NS_OK;
    1: 
    1:   nsAutoString newValue;
13311:   aInput->GetTextValue(newValue);
    1: 
12564:   // Clear out this reference in case the new input's popup has no tree
12564:   mTree = nsnull;
12564: 
    1:   // Reset all search state members to default values
    1:   mSearchString = newValue;
    1:   mDefaultIndexCompleted = PR_FALSE;
    1:   mBackspaced = PR_FALSE;
    1:   mSearchStatus = nsIAutoCompleteController::STATUS_NONE;
    1:   mRowCount = 0;
    1:   mSearchesOngoing = 0;
    1: 
    1:   // Initialize our list of search objects
    1:   PRUint32 searchCount;
13311:   aInput->GetSearchCount(&searchCount);
21610:   mResults.SetCapacity(searchCount);
21610:   mSearches.SetCapacity(searchCount);
 4881:   mMatchCounts.SetLength(searchCount);
    1: 
    1:   const char *searchCID = kAutoCompleteSearchCID;
    1: 
    1:   for (PRUint32 i = 0; i < searchCount; ++i) {
    1:     // Use the search name to create the contract id string for the search service
    1:     nsCAutoString searchName;
13311:     aInput->GetSearchAt(i, searchName);
    1:     nsCAutoString cid(searchCID);
    1:     cid.Append(searchName);
    1: 
    1:     // Use the created cid to get a pointer to the search service and store it for later
    1:     nsCOMPtr<nsIAutoCompleteSearch> search = do_GetService(cid.get());
    1:     if (search)
21610:       mSearches.AppendObject(search);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::StartSearch(const nsAString &aSearchString)
    1: {
    1:   mSearchString = aSearchString;
    1:   StartSearchTimer();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
30200: nsAutoCompleteController::HandleText()
    1: {
    1:   if (!mInput) {
 4881:     // Stop all searches in case they are async.
    1:     StopSearch();
    1:     // Note: if now is after blur and IME end composition,
    1:     // check mInput before calling.
    1:     // See https://bugzilla.mozilla.org/show_bug.cgi?id=193544#c31
    1:     NS_ERROR("Called before attaching to the control or after detaching from the control");
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsAutoString newValue;
13311:   nsCOMPtr<nsIAutoCompleteInput> input(mInput);
13311:   input->GetTextValue(newValue);
    1: 
    1:   // Note: the events occur in the following order when IME is used.
    1:   // 1. composition start event(HandleStartComposition)
    1:   // 2. composition end event(HandleEndComposition)
    1:   // 3. input event(HandleText)
    1:   // Note that the input event occurs if IME composition is cancelled, as well.
    1:   // In HandleEndComposition, we are processing the popup properly.
    1:   // Therefore, the input event after composition end event should do nothing.
 4881:   // (E.g., calling StopSearch() and ClosePopup().)
    1:   // If it is not, popup is always closed after composition end.
    1:   if (mIgnoreHandleText) {
    1:     mIgnoreHandleText = PR_FALSE;
    1:     if (newValue.Equals(mSearchString))
    1:       return NS_OK;
    1:     NS_ERROR("Now is after composition end event. But the value was changed.");
    1:   }
    1: 
 4881:   // Stop all searches in case they are async.
    1:   StopSearch();
    1: 
 6115:   if (!mInput) {
 6115:     // StopSearch() can call PostSearchCleanup() which might result
 6115:     // in a blur event, which could null out mInput, so we need to check it
 6115:     // again.  See bug #395344 for more details
 6115:     return NS_OK;
 6115:   }
 6115: 
    1:   PRBool disabled;
13311:   input->GetDisableAutoComplete(&disabled);
    1:   NS_ENSURE_TRUE(!disabled, NS_OK);
    1: 
    1:   // Don't search again if the new string is the same as the last search
    1:   if (newValue.Length() > 0 && newValue.Equals(mSearchString))
    1:     return NS_OK;
    1: 
    1:   // Determine if the user has removed text from the end (probably by backspacing)
    1:   if (newValue.Length() < mSearchString.Length() &&
    1:       Substring(mSearchString, 0, newValue.Length()).Equals(newValue))
    1:   {
    1:     // We need to throw away previous results so we don't try to search through them again
    1:     ClearResults();
    1:     mBackspaced = PR_TRUE;
    1:   } else
    1:     mBackspaced = PR_FALSE;
    1: 
    1:   mSearchString = newValue;
    1: 
    1:   // Don't search if the value is empty
    1:   if (newValue.Length() == 0) {
    1:     ClosePopup();
    1:     return NS_OK;
    1:   }
    1: 
    1:   StartSearchTimer();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
12436: nsAutoCompleteController::HandleEnter(PRBool aIsPopupSelection, PRBool *_retval)
    1: {
    1:   *_retval = PR_FALSE;
    1:   if (!mInput)
    1:     return NS_OK;
    1: 
    1:   // allow the event through unless there is something selected in the popup
    1:   mInput->GetPopupOpen(_retval);
    1:   if (*_retval) {
    1:     nsCOMPtr<nsIAutoCompletePopup> popup;
    1:     mInput->GetPopup(getter_AddRefs(popup));
    1: 
    1:     if (popup) {
    1:       PRInt32 selectedIndex;
    1:       popup->GetSelectedIndex(&selectedIndex);
    1:       *_retval = selectedIndex >= 0;
    1:     }
    1:   }
    1: 
32032:   // Stop the search, and handle the enter.
32032:   StopSearch();
12436:   EnterMatch(aIsPopupSelection);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::HandleEscape(PRBool *_retval)
    1: {
    1:   *_retval = PR_FALSE;
    1:   if (!mInput)
    1:     return NS_OK;
    1: 
    1:   // allow the event through if the popup is closed
    1:   mInput->GetPopupOpen(_retval);
    1: 
 4881:   // Stop all searches in case they are async.
 4881:   StopSearch();
    1:   ClearResults();
    1:   RevertTextValue();
    1:   ClosePopup();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::HandleStartComposition()
    1: {
    1:   NS_ENSURE_TRUE(!mIsIMEComposing, NS_OK);
    1: 
    1:   mPopupClosedByCompositionStart = PR_FALSE;
    1:   mIsIMEComposing = PR_TRUE;
    1: 
    1:   if (!mInput)
    1:     return NS_OK;
    1: 
13311:   nsCOMPtr<nsIAutoCompleteInput> input(mInput);
    1:   PRBool disabled;
13311:   input->GetDisableAutoComplete(&disabled);
    1:   if (disabled)
    1:     return NS_OK;
    1: 
 4881:   // Stop all searches in case they are async.
    1:   StopSearch();
    1: 
33455:   PRBool isOpen = PR_FALSE;
13311:   input->GetPopupOpen(&isOpen);
61559:   if (isOpen) {
    1:     ClosePopup();
61559: 
61559:     PRBool stillOpen = PR_FALSE;
61559:     input->GetPopupOpen(&stillOpen);
61559:     mPopupClosedByCompositionStart = !stillOpen;
61559:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::HandleEndComposition()
    1: {
    1:   NS_ENSURE_TRUE(mIsIMEComposing, NS_OK);
    1: 
    1:   mIsIMEComposing = PR_FALSE;
    1:   PRBool forceOpenPopup = mPopupClosedByCompositionStart;
    1:   mPopupClosedByCompositionStart = PR_FALSE;
    1: 
    1:   if (!mInput)
    1:     return NS_OK;
    1: 
    1:   nsAutoString value;
    1:   mInput->GetTextValue(value);
    1:   SetSearchString(EmptyString());
    1:   if (!value.IsEmpty()) {
    1:     // Show the popup with a filtered result set
30200:     HandleText();
    1:   } else if (forceOpenPopup) {
    1:     PRBool cancel;
    1:     HandleKeyNavigation(nsIDOMKeyEvent::DOM_VK_DOWN, &cancel);
    1:   }
    1:   // On here, |value| and |mSearchString| are same. Therefore, next HandleText should be
    1:   // ignored. Because there are no reason to research.
    1:   mIgnoreHandleText = PR_TRUE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::HandleTab()
    1: {
    1:   PRBool cancel;
12436:   return HandleEnter(PR_FALSE, &cancel);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::HandleKeyNavigation(PRUint32 aKey, PRBool *_retval)
    1: {
    1:   // By default, don't cancel the event
    1:   *_retval = PR_FALSE;
    1: 
    1:   if (!mInput) {
43921:     // Stop all searches in case they are async.
43921:     StopSearch();
    1:     // Note: if now is after blur and IME end composition,
    1:     // check mInput before calling.
    1:     // See https://bugzilla.mozilla.org/show_bug.cgi?id=193544#c31
    1:     NS_ERROR("Called before attaching to the control or after detaching from the control");
    1:     return NS_OK;
    1:   }
    1: 
13311:   nsCOMPtr<nsIAutoCompleteInput> input(mInput);
    1:   nsCOMPtr<nsIAutoCompletePopup> popup;
13311:   input->GetPopup(getter_AddRefs(popup));
    1:   NS_ENSURE_TRUE(popup != nsnull, NS_ERROR_FAILURE);
    1: 
    1:   PRBool disabled;
13311:   input->GetDisableAutoComplete(&disabled);
    1:   NS_ENSURE_TRUE(!disabled, NS_OK);
    1: 
    1:   if (aKey == nsIDOMKeyEvent::DOM_VK_UP ||
    1:       aKey == nsIDOMKeyEvent::DOM_VK_DOWN ||
    1:       aKey == nsIDOMKeyEvent::DOM_VK_PAGE_UP ||
    1:       aKey == nsIDOMKeyEvent::DOM_VK_PAGE_DOWN)
    1:   {
    1:     // Prevent the input from handling up/down events, as it may move
    1:     // the cursor to home/end on some systems
    1:     *_retval = PR_TRUE;
    1: 
33455:     PRBool isOpen = PR_FALSE;
13311:     input->GetPopupOpen(&isOpen);
    1:     if (isOpen) {
    1:       PRBool reverse = aKey == nsIDOMKeyEvent::DOM_VK_UP ||
    1:                       aKey == nsIDOMKeyEvent::DOM_VK_PAGE_UP ? PR_TRUE : PR_FALSE;
    1:       PRBool page = aKey == nsIDOMKeyEvent::DOM_VK_PAGE_UP ||
    1:                     aKey == nsIDOMKeyEvent::DOM_VK_PAGE_DOWN ? PR_TRUE : PR_FALSE;
    1: 
    1:       // Fill in the value of the textbox with whatever is selected in the popup
    1:       // if the completeSelectedIndex attribute is set.  We check this before
13311:       // calling SelectBy of an earlier attempt to avoid crashing.
    1:       PRBool completeSelection;
13311:       input->GetCompleteSelectedIndex(&completeSelection);
    1: 
    1:       // Instruct the result view to scroll by the given amount and direction
    1:       popup->SelectBy(reverse, page);
    1: 
    1:       if (completeSelection)
    1:       {
    1:         PRInt32 selectedIndex;
    1:         popup->GetSelectedIndex(&selectedIndex);
    1:         if (selectedIndex >= 0) {
    1:           //  A result is selected, so fill in its value
    1:           nsAutoString value;
    1:           if (NS_SUCCEEDED(GetResultValueAt(selectedIndex, PR_TRUE, value))) {
13311:             input->SetTextValue(value);
13311:             input->SelectTextRange(value.Length(), value.Length());
    1:           }
    1:         } else {
    1:           // Nothing is selected, so fill in the last typed value
13311:           input->SetTextValue(mSearchString);
13311:           input->SelectTextRange(mSearchString.Length(), mSearchString.Length());
    1:         }
    1:       }
    1:     } else {
14069: #ifdef XP_MACOSX
14069:       // on Mac, only show the popup if the caret is at the start or end of
14069:       // the input and there is no selection, so that the default defined key
14069:       // shortcuts for up and down move to the beginning and end of the field
14069:       // otherwise.
14069:       PRInt32 start, end;
14069:       if (aKey == nsIDOMKeyEvent::DOM_VK_UP) {
14069:         input->GetSelectionStart(&start);
14069:         input->GetSelectionEnd(&end);
14069:         if (start > 0 || start != end)
14069:           *_retval = PR_FALSE;
14069:       }
14069:       else if (aKey == nsIDOMKeyEvent::DOM_VK_DOWN) {
14069:         nsAutoString text;
14069:         input->GetTextValue(text);
14069:         input->GetSelectionStart(&start);
14069:         input->GetSelectionEnd(&end);
14069:         if (start != end || end < (PRInt32)text.Length())
14069:           *_retval = PR_FALSE;
14069:       }
14069: #endif
14069:       if (*_retval) {
    1:         // Open the popup if there has been a previous search, or else kick off a new search
21610:         if (mResults.Count() > 0) {
    1:           if (mRowCount) {
    1:             OpenPopup();
    1:           }
43921:         } else {
43921:           // Stop all searches in case they are async.
43921:           StopSearch();
43921: 
43921:           if (!mInput) {
61564:             // StopSearch() can call PostSearchCleanup() which might result
61564:             // in a blur event, which could null out mInput, so we need to check it
61564:             // again.  See bug #395344 for more details
43921:             return NS_OK;
43921:           }
43921: 
    1:           StartSearchTimer();
    1:         }
14069:       }
43921:     }
    1:   } else if (   aKey == nsIDOMKeyEvent::DOM_VK_LEFT
    1:              || aKey == nsIDOMKeyEvent::DOM_VK_RIGHT
    1: #ifndef XP_MACOSX
    1:              || aKey == nsIDOMKeyEvent::DOM_VK_HOME
    1: #endif
    1:             )
    1:   {
    1:     // The user hit a text-navigation key.
33455:     PRBool isOpen = PR_FALSE;
13311:     input->GetPopupOpen(&isOpen);
    1:     if (isOpen) {
    1:       PRInt32 selectedIndex;
    1:       popup->GetSelectedIndex(&selectedIndex);
28639:       PRBool shouldComplete;
28774:       input->GetCompleteDefaultIndex(&shouldComplete);
    1:       if (selectedIndex >= 0) {
    1:         // The pop-up is open and has a selection, take its value
    1:         nsAutoString value;
    1:         if (NS_SUCCEEDED(GetResultValueAt(selectedIndex, PR_TRUE, value))) {
13311:           input->SetTextValue(value);
13311:           input->SelectTextRange(value.Length(), value.Length());
    1:         }
    1:       }
28639:       else if (shouldComplete) {
28639:         // We usually try to preserve the casing of what user has typed, but
28639:         // if he wants to autocomplete, we will replace the value with the
28639:         // actual autocomplete result.
28639:         // The user wants explicitely to use that result, so this ensures
28639:         // association of the result with the autocompleted text.
28639:         nsAutoString value;
28774:         nsAutoString inputValue;
28774:         input->GetTextValue(inputValue);
28774:         if (NS_SUCCEEDED(GetDefaultCompleteValue(selectedIndex, PR_FALSE, value)) &&
28774:             value.Equals(inputValue, nsCaseInsensitiveStringComparator())) {
28639:           input->SetTextValue(value);
28639:           input->SelectTextRange(value.Length(), value.Length());
28639:         }
28639:       }
    1:       // Close the pop-up even if nothing was selected
    1:       ClearSearchTimer();
    1:       ClosePopup();
    1:     }
    1:     // Update last-searched string to the current input, since the input may
    1:     // have changed.  Without this, subsequent backspaces look like text
    1:     // additions, not text deletions.
    1:     nsAutoString value;
13311:     input->GetTextValue(value);
    1:     mSearchString = value;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::HandleDelete(PRBool *_retval)
    1: {
    1:   *_retval = PR_FALSE;
    1:   if (!mInput)
    1:     return NS_OK;
    1: 
13311:   nsCOMPtr<nsIAutoCompleteInput> input(mInput);
    1:   PRBool isOpen = PR_FALSE;
13311:   input->GetPopupOpen(&isOpen);
    1:   if (!isOpen || mRowCount <= 0) {
    1:     // Nothing left to delete, proceed as normal
30200:     HandleText();
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIAutoCompletePopup> popup;
13311:   input->GetPopup(getter_AddRefs(popup));
    1: 
    1:   PRInt32 index, searchIndex, rowIndex;
    1:   popup->GetSelectedIndex(&index);
    1:   RowIndexToSearch(index, &searchIndex, &rowIndex);
    1:   NS_ENSURE_TRUE(searchIndex >= 0 && rowIndex >= 0, NS_ERROR_FAILURE);
    1: 
21610:   nsIAutoCompleteResult *result = mResults[searchIndex];
    1:   NS_ENSURE_TRUE(result, NS_ERROR_FAILURE);
    1: 
    1:   nsAutoString search;
13311:   input->GetSearchParam(search);
    1: 
    1:   // Clear the row in our result and in the DB.
    1:   result->RemoveValueAt(rowIndex, PR_TRUE);
    1:   --mRowCount;
    1: 
32086:   // We removed it, so make sure we cancel the event that triggered this call.
32086:   *_retval = PR_TRUE;
32086: 
    1:   // Unselect the current item.
    1:   popup->SetSelectedIndex(-1);
    1: 
    1:   // Tell the tree that the row count changed.
    1:   if (mTree)
    1:     mTree->RowCountChanged(mRowCount, -1);
    1: 
    1:   // Adjust index, if needed.
    1:   if (index >= (PRInt32)mRowCount)
    1:     index = mRowCount - 1;
    1: 
    1:   if (mRowCount > 0) {
    1:     // There are still rows in the popup, select the current index again.
    1:     popup->SetSelectedIndex(index);
    1: 
    1:     // Complete to the new current value.
19422:     PRBool shouldComplete = PR_FALSE;
19422:     mInput->GetCompleteDefaultIndex(&shouldComplete);
19422:     if (shouldComplete) {
    1:       nsAutoString value;
    1:       if (NS_SUCCEEDED(GetResultValueAt(index, PR_TRUE, value))) {
19422:         CompleteValue(value);
    1:       }
19422:     }
    1: 
    1:     // Invalidate the popup.
    1:     popup->Invalidate();
    1:   } else {
    1:     // Nothing left in the popup, clear any pending search timers and
    1:     // close the popup.
    1:     ClearSearchTimer();
    1:     ClosePopup();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
52364: nsresult 
52364: nsAutoCompleteController::GetResultAt(PRInt32 aIndex, nsIAutoCompleteResult** aResult,
52364:                                       PRInt32* aRowIndex)
52364: {
52364:   PRInt32 searchIndex;
52364:   RowIndexToSearch(aIndex, &searchIndex, aRowIndex);
52364:   NS_ENSURE_TRUE(searchIndex >= 0 && *aRowIndex >= 0, NS_ERROR_FAILURE);
52364: 
52364:   *aResult = mResults[searchIndex];
52364:   NS_ENSURE_TRUE(*aResult, NS_ERROR_FAILURE);
52364:   return NS_OK;
52364: }
52364: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::GetValueAt(PRInt32 aIndex, nsAString & _retval)
    1: {
52364:   GetResultLabelAt(aIndex, PR_FALSE, _retval);
52364: 
52364:   return NS_OK;
52364: }
52364: 
52364: NS_IMETHODIMP
52364: nsAutoCompleteController::GetLabelAt(PRInt32 aIndex, nsAString & _retval)
52364: {
52364:   GetResultLabelAt(aIndex, PR_FALSE, _retval);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::GetCommentAt(PRInt32 aIndex, nsAString & _retval)
    1: {
    1:   PRInt32 rowIndex;
52364:   nsIAutoCompleteResult* result;
52364:   nsresult rv = GetResultAt(aIndex, &result, &rowIndex);
52364:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 3718:   return result->GetCommentAt(rowIndex, _retval);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::GetStyleAt(PRInt32 aIndex, nsAString & _retval)
    1: {
    1:   PRInt32 rowIndex;
52364:   nsIAutoCompleteResult* result;
52364:   nsresult rv = GetResultAt(aIndex, &result, &rowIndex);
52364:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 3718:   return result->GetStyleAt(rowIndex, _retval);
 3718: }
    1: 
 3718: NS_IMETHODIMP
 3718: nsAutoCompleteController::GetImageAt(PRInt32 aIndex, nsAString & _retval)
 3718: {
 3718:   PRInt32 rowIndex;
52364:   nsIAutoCompleteResult* result;
52364:   nsresult rv = GetResultAt(aIndex, &result, &rowIndex);
52364:   NS_ENSURE_SUCCESS(rv, rv);
 3718: 
 3718:   return result->GetImageAt(rowIndex, _retval);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::SetSearchString(const nsAString &aSearchString)
    1: {
    1:   mSearchString = aSearchString;
    1:   return NS_OK;
    1: }
    1: 
 8459: NS_IMETHODIMP
 8459: nsAutoCompleteController::GetSearchString(nsAString &aSearchString)
 8459: {
 8459:   aSearchString = mSearchString;
 8459:   return NS_OK;
 8459: }
 8459: 
 8459: 
    1: ////////////////////////////////////////////////////////////////////////
    1: //// nsIAutoCompleteObserver
    1: 
    1: NS_IMETHODIMP
52365: nsAutoCompleteController::OnUpdateSearchResult(nsIAutoCompleteSearch *aSearch, nsIAutoCompleteResult* aResult)
52365: {
52365:   ClearResults();
52365:   return OnSearchResult(aSearch, aResult);
52365: }
52365: 
52365: NS_IMETHODIMP
    1: nsAutoCompleteController::OnSearchResult(nsIAutoCompleteSearch *aSearch, nsIAutoCompleteResult* aResult)
    1: {
    1:   // look up the index of the search which is returning
21610:   PRUint32 count = mSearches.Count();
    1:   for (PRUint32 i = 0; i < count; ++i) {
21610:     if (mSearches[i] == aSearch) {
    1:       ProcessResult(i, aResult);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: ////////////////////////////////////////////////////////////////////////
    1: //// nsITimerCallback
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::Notify(nsITimer *timer)
    1: {
    1:   mTimer = nsnull;
    1:   StartSearch();
    1:   return NS_OK;
    1: }
    1: 
    1: ////////////////////////////////////////////////////////////////////////
    1: // nsITreeView
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::GetRowCount(PRInt32 *aRowCount)
    1: {
    1:   *aRowCount = mRowCount;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::GetRowProperties(PRInt32 index, nsISupportsArray *properties)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::GetCellProperties(PRInt32 row, nsITreeColumn* col, nsISupportsArray* properties)
    1: {
    1:   if (row >= 0) {
    1:     nsAutoString className;
    1:     GetStyleAt(row, className);
    1:     if (!className.IsEmpty()) {
16562:       nsCOMPtr<nsIAtom> atom(do_GetAtom(className));
    1:       properties->AppendElement(atom);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::GetColumnProperties(nsITreeColumn* col, nsISupportsArray* properties)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::GetImageSrc(PRInt32 row, nsITreeColumn* col, nsAString& _retval)
    1: {
 3718:   const PRUnichar* colID;
 3718:   col->GetIdConst(&colID);
 3718: 
 3718:   if (NS_LITERAL_STRING("treecolAutoCompleteValue").Equals(colID))
 3718:     return GetImageAt(row, _retval);
 3718: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::GetProgressMode(PRInt32 row, nsITreeColumn* col, PRInt32* _retval)
    1: {
    1:   NS_NOTREACHED("tree has no progress cells");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::GetCellValue(PRInt32 row, nsITreeColumn* col, nsAString& _retval)
    1: {
    1:   NS_NOTREACHED("all of our cells are text");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::GetCellText(PRInt32 row, nsITreeColumn* col, nsAString& _retval)
    1: {
    1:   const PRUnichar* colID;
    1:   col->GetIdConst(&colID);
    1: 
    1:   if (NS_LITERAL_STRING("treecolAutoCompleteValue").Equals(colID))
    1:     GetValueAt(row, _retval);
    1:   else if (NS_LITERAL_STRING("treecolAutoCompleteComment").Equals(colID))
    1:     GetCommentAt(row, _retval);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::IsContainer(PRInt32 index, PRBool *_retval)
    1: {
    1:   *_retval = PR_FALSE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::IsContainerOpen(PRInt32 index, PRBool *_retval)
    1: {
    1:   NS_NOTREACHED("no container cells");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::IsContainerEmpty(PRInt32 index, PRBool *_retval)
    1: {
    1:   NS_NOTREACHED("no container cells");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::GetLevel(PRInt32 index, PRInt32 *_retval)
    1: {
    1:   *_retval = 0;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::GetParentIndex(PRInt32 rowIndex, PRInt32 *_retval)
    1: {
15107:   *_retval = -1;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::HasNextSibling(PRInt32 rowIndex, PRInt32 afterIndex, PRBool *_retval)
    1: {
    1:   *_retval = PR_FALSE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::ToggleOpenState(PRInt32 index)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::SetTree(nsITreeBoxObject *tree)
    1: {
    1:   mTree = tree;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::GetSelection(nsITreeSelection * *aSelection)
    1: {
    1:   *aSelection = mSelection;
    1:   NS_IF_ADDREF(*aSelection);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsAutoCompleteController::SetSelection(nsITreeSelection * aSelection)
    1: {
    1:   mSelection = aSelection;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::SelectionChanged()
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::SetCellValue(PRInt32 row, nsITreeColumn* col, const nsAString& value)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::SetCellText(PRInt32 row, nsITreeColumn* col, const nsAString& value)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::CycleHeader(nsITreeColumn* col)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::CycleCell(PRInt32 row, nsITreeColumn* col)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::IsEditable(PRInt32 row, nsITreeColumn* col, PRBool *_retval)
    1: {
    1:   *_retval = PR_FALSE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::IsSelectable(PRInt32 row, nsITreeColumn* col, PRBool *_retval)
    1: {
    1:   *_retval = PR_FALSE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::IsSeparator(PRInt32 index, PRBool *_retval)
    1: {
    1:   *_retval = PR_FALSE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::IsSorted(PRBool *_retval)
    1: {
    1:   *_retval = PR_FALSE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
29545: nsAutoCompleteController::CanDrop(PRInt32 index, PRInt32 orientation,
29545:                                   nsIDOMDataTransfer* dataTransfer, PRBool *_retval)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
29545: nsAutoCompleteController::Drop(PRInt32 row, PRInt32 orientation, nsIDOMDataTransfer* dataTransfer)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::PerformAction(const PRUnichar *action)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::PerformActionOnRow(const PRUnichar *action, PRInt32 row)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCompleteController::PerformActionOnCell(const PRUnichar* action, PRInt32 row, nsITreeColumn* col)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: ////////////////////////////////////////////////////////////////////////
    1: //// nsAutoCompleteController
    1: 
    1: nsresult
    1: nsAutoCompleteController::OpenPopup()
    1: {
    1:   PRUint32 minResults;
    1:   mInput->GetMinResultsForPopup(&minResults);
    1: 
    1:   if (mRowCount >= minResults) {
    1:     mIsOpen = PR_TRUE;
    1:     return mInput->SetPopupOpen(PR_TRUE);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsAutoCompleteController::ClosePopup()
    1: {
    1:   if (!mInput) {
    1:     return NS_OK;
    1:   }
 8246: 
33455:   PRBool isOpen = PR_FALSE;
 8246:   mInput->GetPopupOpen(&isOpen);
 8246:   if (!isOpen)
 8246:     return NS_OK;
 8246: 
    1:   nsCOMPtr<nsIAutoCompletePopup> popup;
    1:   mInput->GetPopup(getter_AddRefs(popup));
    1:   NS_ENSURE_TRUE(popup != nsnull, NS_ERROR_FAILURE);
    1:   popup->SetSelectedIndex(-1);
    1:   mIsOpen = PR_FALSE;
    1:   return mInput->SetPopupOpen(PR_FALSE);
    1: }
    1: 
    1: nsresult
    1: nsAutoCompleteController::StartSearch()
    1: {
    1:   NS_ENSURE_STATE(mInput);
13311:   nsCOMPtr<nsIAutoCompleteInput> input(mInput);
    1:   mSearchStatus = nsIAutoCompleteController::STATUS_SEARCHING;
    1:   mDefaultIndexCompleted = PR_FALSE;
    1: 
18409:   // Cache the current results so that we can pass these through to all the
30711:   // searches without losing them
21610:   nsCOMArray<nsIAutoCompleteResult> resultCache;
21610:   if (!resultCache.AppendObjects(mResults)) {
21610:     return NS_ERROR_OUT_OF_MEMORY;
21610:   }
18409: 
21610:   PRUint32 count = mSearches.Count();
    1:   mSearchesOngoing = count;
 4881:   mFirstSearchResult = PR_TRUE;
    1: 
12047:   // notify the input that the search is beginning
13311:   input->OnSearchBegin();
12047: 
    1:   PRUint32 searchesFailed = 0;
    1:   for (PRUint32 i = 0; i < count; ++i) {
21610:     nsCOMPtr<nsIAutoCompleteSearch> search = mSearches[i];
21610:     nsIAutoCompleteResult *result = resultCache.SafeObjectAt(i);
    1: 
    1:     if (result) {
    1:       PRUint16 searchResult;
    1:       result->GetSearchResult(&searchResult);
 4881:       if (searchResult != nsIAutoCompleteResult::RESULT_SUCCESS &&
30200:           searchResult != nsIAutoCompleteResult::RESULT_SUCCESS_ONGOING &&
30200:           searchResult != nsIAutoCompleteResult::RESULT_NOMATCH)
    1:         result = nsnull;
    1:     }
    1: 
    1:     nsAutoString searchParam;
21610:     nsresult rv = input->GetSearchParam(searchParam);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
 3233:     rv = search->StartSearch(mSearchString, searchParam, result, static_cast<nsIAutoCompleteObserver *>(this));
    1:     if (NS_FAILED(rv)) {
    1:       ++searchesFailed;
    1:       --mSearchesOngoing;
    1:     }
61564:     // Because of the joy of nested event loops (which can easily happen when some
61564:     // code uses a generator for an asynchronous AutoComplete search),
61564:     // nsIAutoCompleteSearch::StartSearch might cause us to be detached from our input
61564:     // field.  The next time we iterate, we'd be touching something that we shouldn't
61564:     // be, and result in a crash.
61560:     if (!mInput) {
61560:       // The search operation has been finished.
61560:       return NS_OK;
61560:     }
    1:   }
    1: 
 4881:   if (searchesFailed == count)
    1:     PostSearchCleanup();
 4881: 
    1:   return NS_OK;
    1: }
    1: 
 4881: NS_IMETHODIMP
    1: nsAutoCompleteController::StopSearch()
    1: {
    1:   // Stop the timer if there is one
    1:   ClearSearchTimer();
    1: 
    1:   // Stop any ongoing asynchronous searches
    1:   if (mSearchStatus == nsIAutoCompleteController::STATUS_SEARCHING) {
21610:     PRUint32 count = mSearches.Count();
    1: 
    1:     for (PRUint32 i = 0; i < count; ++i) {
21610:       nsCOMPtr<nsIAutoCompleteSearch> search = mSearches[i];
    1:       search->StopSearch();
    1:     }
 5252:     mSearchesOngoing = 0;
 5252:     // since we were searching, but now we've stopped,
 5252:     // we need to call PostSearchCleanup()
 5252:     PostSearchCleanup();
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsAutoCompleteController::StartSearchTimer()
    1: {
    1:   // Don't create a new search timer if we're already waiting for one to fire.
    1:   // If we don't check for this, we won't be able to cancel the original timer
    1:   // and may crash when it fires (bug 236659).
    1:   if (mTimer || !mInput)
    1:     return NS_OK;
    1: 
    1:   PRUint32 timeout;
    1:   mInput->GetTimeout(&timeout);
    1: 
13311:   nsresult rv;
13311:   mTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
13311:   if (NS_FAILED(rv))
13311:       return rv;
13311:   rv = mTimer->InitWithCallback(this, timeout, nsITimer::TYPE_ONE_SHOT);
13311:   if (NS_FAILED(rv))
13311:       mTimer = nsnull;
13311: 
13311:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsAutoCompleteController::ClearSearchTimer()
    1: {
    1:   if (mTimer) {
    1:     mTimer->Cancel();
    1:     mTimer = nsnull;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
12436: nsAutoCompleteController::EnterMatch(PRBool aIsPopupSelection)
    1: {
13311:   nsCOMPtr<nsIAutoCompleteInput> input(mInput);
    1:   nsCOMPtr<nsIAutoCompletePopup> popup;
13311:   input->GetPopup(getter_AddRefs(popup));
    1:   NS_ENSURE_TRUE(popup != nsnull, NS_ERROR_FAILURE);
    1: 
    1:   PRBool forceComplete;
13311:   input->GetForceComplete(&forceComplete);
    1: 
    1:   // Ask the popup if it wants to enter a special value into the textbox
    1:   nsAutoString value;
    1:   popup->GetOverrideValue(value);
    1:   if (value.IsEmpty()) {
28774:     PRBool shouldComplete;
28774:     mInput->GetCompleteDefaultIndex(&shouldComplete);
12436:     PRBool completeSelection;
13311:     input->GetCompleteSelectedIndex(&completeSelection);
12436: 
12436:     // If completeselectedindex is false or a row was selected from the popup,
12436:     // enter it into the textbox. If completeselectedindex is true, or
12436:     // EnterMatch was called via other means, for instance pressing Enter,
12436:     // don't fill in the value as it will have already been filled in as needed.
    1:     PRInt32 selectedIndex;
    1:     popup->GetSelectedIndex(&selectedIndex);
12436:     if (selectedIndex >= 0 && (!completeSelection || aIsPopupSelection))
    1:       GetResultValueAt(selectedIndex, PR_TRUE, value);
28774:     else if (shouldComplete) {
28774:       // We usually try to preserve the casing of what user has typed, but
28774:       // if he wants to autocomplete, we will replace the value with the
28774:       // actual autocomplete result.
28774:       // The user wants explicitely to use that result, so this ensures
28774:       // association of the result with the autocompleted text.
28774:       nsAutoString defaultIndexValue;
28774:       nsAutoString inputValue;
28774:       input->GetTextValue(inputValue);
28774:       if (NS_SUCCEEDED(GetDefaultCompleteValue(selectedIndex, PR_FALSE, defaultIndexValue)) &&
28774:           defaultIndexValue.Equals(inputValue, nsCaseInsensitiveStringComparator()))
28774:         value = defaultIndexValue;
28774:     }
    1: 
    1:     if (forceComplete && value.IsEmpty()) {
    1:       // Since nothing was selected, and forceComplete is specified, that means
 4881:       // we have to find the first default match and enter it instead
21610:       PRUint32 count = mResults.Count();
    1:       for (PRUint32 i = 0; i < count; ++i) {
21610:         nsIAutoCompleteResult *result = mResults[i];
    1: 
    1:         if (result) {
    1:           PRInt32 defaultIndex;
    1:           result->GetDefaultIndex(&defaultIndex);
    1:           if (defaultIndex >= 0) {
    1:             result->GetValueAt(defaultIndex, value);
    1:             break;
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   nsCOMPtr<nsIObserverService> obsSvc =
41540:     mozilla::services::GetObserverService();
    1:   NS_ENSURE_STATE(obsSvc);
13311:   obsSvc->NotifyObservers(input, "autocomplete-will-enter-text", nsnull);
    1: 
    1:   if (!value.IsEmpty()) {
13311:     input->SetTextValue(value);
13311:     input->SelectTextRange(value.Length(), value.Length());
    1:     mSearchString = value;
    1:   }
    1: 
13311:   obsSvc->NotifyObservers(input, "autocomplete-did-enter-text", nsnull);
    1:   ClosePopup();
    1: 
    1:   PRBool cancel;
13311:   input->OnTextEntered(&cancel);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsAutoCompleteController::RevertTextValue()
    1: {
 9690:   // StopSearch() can call PostSearchCleanup() which might result
 9690:   // in a blur event, which could null out mInput, so we need to check it
 9690:   // again.  See bug #408463 for more details
 9690:   if (!mInput)
 9690:     return NS_OK;
 9690: 
    1:   nsAutoString oldValue(mSearchString);
13311:   nsCOMPtr<nsIAutoCompleteInput> input(mInput);
    1: 
    1:   PRBool cancel = PR_FALSE;
13311:   input->OnTextReverted(&cancel);
    1: 
    1:   if (!cancel) {
    1:     nsCOMPtr<nsIObserverService> obsSvc =
41540:       mozilla::services::GetObserverService();
    1:     NS_ENSURE_STATE(obsSvc);
13311:     obsSvc->NotifyObservers(input, "autocomplete-will-revert-text", nsnull);
    1: 
13311:     input->SetTextValue(oldValue);
    1: 
13311:     obsSvc->NotifyObservers(input, "autocomplete-did-revert-text", nsnull);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsAutoCompleteController::ProcessResult(PRInt32 aSearchIndex, nsIAutoCompleteResult *aResult)
    1: {
    1:   NS_ENSURE_STATE(mInput);
13311:   nsCOMPtr<nsIAutoCompleteInput> input(mInput);
 4881: 
 4881:   // If this is the first search result we are processing
 4881:   // we should clear out the previously cached results
 4881:   if (mFirstSearchResult) {
    1:     ClearResults();
 4881:     mFirstSearchResult = PR_FALSE;
 4881:   }
    1: 
    1:   PRUint16 result = 0;
    1:   if (aResult)
    1:     aResult->GetSearchResult(&result);
 4881: 
 4881:   // if our results are incremental, the search is still ongoing
 4881:   if (result != nsIAutoCompleteResult::RESULT_SUCCESS_ONGOING &&
 4881:       result != nsIAutoCompleteResult::RESULT_NOMATCH_ONGOING) {
 4881:     --mSearchesOngoing;
 4881:   }
 4881: 
 4881:   PRUint32 oldMatchCount = 0;
 4881:   PRUint32 matchCount = 0;
 5160:   if (aResult)
 4881:     aResult->GetMatchCount(&matchCount);
 4881: 
21610:   PRInt32 oldIndex = mResults.IndexOf(aResult);
 4881:   if (oldIndex == -1) {
 4881:     // cache the result
21610:     mResults.AppendObject(aResult);
 4881:     mMatchCounts.AppendElement(matchCount);
 4881:   }
 4881:   else {
 4881:     // replace the cached result
21610:     mResults.ReplaceObjectAt(aResult, oldIndex);
 4881:     oldMatchCount = mMatchCounts[aSearchIndex];
 4881:     mMatchCounts[oldIndex] = matchCount;
 4881:   }
 4881: 
 4881:   PRUint32 oldRowCount = mRowCount;
 4881:   // If the search failed, increase the match count
 4881:   // to include the error description
    1:   if (result == nsIAutoCompleteResult::RESULT_FAILURE) {
    1:     nsAutoString error;
    1:     aResult->GetErrorDescription(error);
    1:     if (!error.IsEmpty()) {
    1:       ++mRowCount;
    1:       if (mTree)
    1:         mTree->RowCountChanged(oldRowCount, 1);
    1:     }
 4881:   } else if (result == nsIAutoCompleteResult::RESULT_SUCCESS ||
 4881:              result == nsIAutoCompleteResult::RESULT_SUCCESS_ONGOING) {
    1:     // Increase the match count for all matches in this result
 4881:     mRowCount += matchCount - oldMatchCount;
 4881: 
    1:     if (mTree)
 4881:       mTree->RowCountChanged(oldRowCount, matchCount - oldMatchCount);
    1: 
    1:     // Try to autocomplete the default index for this search
    1:     CompleteDefaultIndex(aSearchIndex);
    1:   }
    1: 
    1:   // Refresh the popup view to display the new search results
    1:   nsCOMPtr<nsIAutoCompletePopup> popup;
13311:   input->GetPopup(getter_AddRefs(popup));
    1:   NS_ENSURE_TRUE(popup != nsnull, NS_ERROR_FAILURE);
    1:   popup->Invalidate();
    1: 
11083:   // Make sure the popup is open, if necessary, since we now have at least one
11083:   // search result ready to display. Don't force the popup closed if we might
11083:   // get results in the future to avoid unnecessarily canceling searches.
    1:   if (mRowCount)
    1:     OpenPopup();
11083:   else if (result != nsIAutoCompleteResult::RESULT_NOMATCH_ONGOING)
    1:     ClosePopup();
    1: 
 5252:   if (mSearchesOngoing == 0) {
 5252:     // If this is the last search to return, cleanup
 5252:     PostSearchCleanup();
 5252:   }
 4881: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsAutoCompleteController::PostSearchCleanup()
    1: {
 2165:   NS_ENSURE_STATE(mInput);
13311:   nsCOMPtr<nsIAutoCompleteInput> input(mInput);
16003: 
16003:   PRUint32 minResults;
16003:   mInput->GetMinResultsForPopup(&minResults);
16003: 
16003:   if (mRowCount || minResults == 0) {
    1:     OpenPopup();
16003:     if (mRowCount)
    1:       mSearchStatus = nsIAutoCompleteController::STATUS_COMPLETE_MATCH;
16003:     else
16003:       mSearchStatus = nsIAutoCompleteController::STATUS_COMPLETE_NO_MATCH;
    1:   } else {
    1:     mSearchStatus = nsIAutoCompleteController::STATUS_COMPLETE_NO_MATCH;
    1:     ClosePopup();
    1:   }
    1: 
    1:   // notify the input that the search is complete
13311:   input->OnSearchComplete();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsAutoCompleteController::ClearResults()
    1: {
    1:   PRInt32 oldRowCount = mRowCount;
    1:   mRowCount = 0;
21610:   mResults.Clear();
 4881:   mMatchCounts.Clear();
 8988:   if (oldRowCount != 0) {
 8988:     if (mTree)
    1:       mTree->RowCountChanged(0, -oldRowCount);
 8988:     else if (mInput) {
 8988:       nsCOMPtr<nsIAutoCompletePopup> popup;
 8988:       mInput->GetPopup(getter_AddRefs(popup));
 8988:       NS_ENSURE_TRUE(popup != nsnull, NS_ERROR_FAILURE);
 8988:       // if we had a tree, RowCountChanged() would have cleared the selection
 8988:       // when the selected row was removed.  But since we don't have a tree,
 8988:       // we need to clear the selection manually.
 8988:       popup->SetSelectedIndex(-1);
 8988:     }
 8988:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsAutoCompleteController::CompleteDefaultIndex(PRInt32 aSearchIndex)
    1: {
32032:   if (mDefaultIndexCompleted || mBackspaced || mRowCount == 0 || mSearchString.Length() == 0)
    1:     return NS_OK;
    1: 
16203:   PRInt32 selectionStart;
16203:   mInput->GetSelectionStart(&selectionStart);
16203:   PRInt32 selectionEnd;
16203:   mInput->GetSelectionEnd(&selectionEnd);
16203: 
16203:   // Don't try to automatically complete to the first result if there's already
16203:   // a selection or the cursor isn't at the end of the input
16203:   if (selectionEnd != selectionStart ||
16203:       selectionEnd != (PRInt32)mSearchString.Length())
16203:     return NS_OK;
16203: 
    1:   PRBool shouldComplete;
    1:   mInput->GetCompleteDefaultIndex(&shouldComplete);
    1:   if (!shouldComplete)
    1:     return NS_OK;
    1: 
28639:   nsAutoString resultValue;
28639:   if (NS_SUCCEEDED(GetDefaultCompleteValue(aSearchIndex, PR_TRUE, resultValue)))
28639:     CompleteValue(resultValue);
28639: 
28639:   mDefaultIndexCompleted = PR_TRUE;
28639: 
28639:   return NS_OK;
28639: }
28639: 
28639: nsresult
28639: nsAutoCompleteController::GetDefaultCompleteValue(PRInt32 aSearchIndex,
28639:                                                   PRBool aPreserveCasing,
28639:                                                   nsAString &_retval)
28639: {
28639:   PRInt32 defaultIndex = -1;
28639:   PRInt32 index = aSearchIndex;
28639:   if (index < 0) {
28639:     PRUint32 count = mResults.Count();
28639:     for (PRUint32 i = 0; i < count; ++i) {
28639:       nsIAutoCompleteResult *result = mResults[i];
28639:       if (result && NS_SUCCEEDED(result->GetDefaultIndex(&defaultIndex)) &&
28639:           defaultIndex >= 0) {
28639:         index = i;
28639:         break;
28639:       }
28639:     }
28639:   }
28639:   NS_ENSURE_TRUE(index >= 0, NS_ERROR_FAILURE);
28639: 
28639:   nsIAutoCompleteResult *result = mResults.SafeObjectAt(index);
    1:   NS_ENSURE_TRUE(result != nsnull, NS_ERROR_FAILURE);
    1: 
28639:   if (defaultIndex < 0) {
    1:     // The search must explicitly provide a default index in order
28639:     // for us to be able to complete.
    1:     result->GetDefaultIndex(&defaultIndex);
28639:   }
28639:   NS_ENSURE_TRUE(defaultIndex >= 0, NS_ERROR_FAILURE);
    1: 
    1:   nsAutoString resultValue;
    1:   result->GetValueAt(defaultIndex, resultValue);
28639:   if (aPreserveCasing &&
28639:       StringBeginsWith(resultValue, mSearchString,
28639:                        nsCaseInsensitiveStringComparator())) {
28639:     // We try to preserve user casing, otherwise we would end up changing
28639:     // the case of what he typed, if we have a result with a different casing.
28639:     // For example if we have result "Test", and user starts writing "tuna",
28639:     // after digiting t, we would convert it to T trying to autocomplete "Test".
28639:     // We will still complete to cased "Test" if the user explicitely choose
28639:     // that result, by either selecting it in the results popup, or with
28639:     // keyboard navigation or if autocompleting in the middle.
28639:     nsAutoString casedResultValue;
28639:     casedResultValue.Assign(mSearchString);
28639:     // Use what the user has typed so far.
28639:     casedResultValue.Append(Substring(resultValue,
28639:                                       mSearchString.Length(),
28639:                                       resultValue.Length()));
28639:     _retval = casedResultValue;
28639:   }
28639:   else
28639:     _retval = resultValue;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
19422: nsAutoCompleteController::CompleteValue(nsString &aValue)
    1: /* mInput contains mSearchString, which we want to autocomplete to aValue.  If
    1:  * selectDifference is true, select the remaining portion of aValue not
    1:  * contained in mSearchString. */
    1: {
    1:   const PRInt32 mSearchStringLength = mSearchString.Length();
    1:   PRInt32 endSelect = aValue.Length();  // By default, select all of aValue.
    1: 
    1:   if (aValue.IsEmpty() ||
    1:       StringBeginsWith(aValue, mSearchString,
    1:                        nsCaseInsensitiveStringComparator())) {
    1:     // aValue is empty (we were asked to clear mInput), or mSearchString
    1:     // matches the beginning of aValue.  In either case we can simply
    1:     // autocomplete to aValue.
    1:     mInput->SetTextValue(aValue);
    1:   } else {
    1:     nsresult rv;
    1:     nsCOMPtr<nsIIOService> ios = do_GetService(NS_IOSERVICE_CONTRACTID, &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     nsCAutoString scheme;
    1:     if (NS_SUCCEEDED(ios->ExtractScheme(NS_ConvertUTF16toUTF8(aValue), scheme))) {
    1:       // Trying to autocomplete a URI from somewhere other than the beginning.
    1:       // Only succeed if the missing portion is "http://"; otherwise do not
    1:       // autocomplete.  This prevents us from "helpfully" autocompleting to a
    1:       // URI that isn't equivalent to what the user expected.
19422:       const PRInt32 findIndex = 7; // length of "http://"
    1: 
    1:       if ((endSelect < findIndex + mSearchStringLength) ||
    1:           !scheme.LowerCaseEqualsLiteral("http") ||
    1:           !Substring(aValue, findIndex, mSearchStringLength).Equals(
    1:             mSearchString, nsCaseInsensitiveStringComparator())) {
    1:         return NS_OK;
    1:       }
    1: 
    1:       mInput->SetTextValue(mSearchString +
    1:                            Substring(aValue, mSearchStringLength + findIndex,
    1:                                      endSelect));
    1: 
    1:       endSelect -= findIndex; // We're skipping this many characters of aValue.
19422:     } else {
19422:       // Autocompleting something other than a URI from the middle.
19422:       // Use the format "searchstring >> full string" to indicate to the user
19422:       // what we are going to replace their search string with.
19422:       mInput->SetTextValue(mSearchString + NS_LITERAL_STRING(" >> ") + aValue);
19422: 
19422:       endSelect = mSearchString.Length() + 4 + aValue.Length();
19422:     }
    1:   }
    1: 
19422:   mInput->SelectTextRange(mSearchStringLength, endSelect);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
52364: nsAutoCompleteController::GetResultLabelAt(PRInt32 aIndex, PRBool aValueOnly, nsAString & _retval)
52364: {
52364:   return GetResultValueLabelAt(aIndex, aValueOnly, PR_FALSE, _retval);
52364: }
52364: 
52364: nsresult
    1: nsAutoCompleteController::GetResultValueAt(PRInt32 aIndex, PRBool aValueOnly, nsAString & _retval)
    1: {
52364:   return GetResultValueLabelAt(aIndex, aValueOnly, PR_TRUE, _retval);
52364: }
52364: 
52364: nsresult
52364: nsAutoCompleteController::GetResultValueLabelAt(PRInt32 aIndex, PRBool aValueOnly,
52364:                                                PRBool aGetValue, nsAString & _retval)
52364: {
    1:   NS_ENSURE_TRUE(aIndex >= 0 && (PRUint32) aIndex < mRowCount, NS_ERROR_ILLEGAL_VALUE);
    1: 
    1:   PRInt32 rowIndex;
52364:   nsIAutoCompleteResult *result;
52364:   nsresult rv = GetResultAt(aIndex, &result, &rowIndex);
52364:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRUint16 searchResult;
    1:   result->GetSearchResult(&searchResult);
    1: 
    1:   if (searchResult == nsIAutoCompleteResult::RESULT_FAILURE) {
    1:     if (aValueOnly)
    1:       return NS_ERROR_FAILURE;
    1:     result->GetErrorDescription(_retval);
 4881:   } else if (searchResult == nsIAutoCompleteResult::RESULT_SUCCESS ||
 4881:              searchResult == nsIAutoCompleteResult::RESULT_SUCCESS_ONGOING) {
52364:     if (aGetValue)
    1:       result->GetValueAt(rowIndex, _retval);
52364:     else
52364:       result->GetLabelAt(rowIndex, _retval);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
 3188: /**
 3188:  * Given the index of a row in the autocomplete popup, find the
 3188:  * corresponding nsIAutoCompleteSearch index, and sub-index into
 3188:  * the search's results list.
 3188:  */
    1: nsresult
    1: nsAutoCompleteController::RowIndexToSearch(PRInt32 aRowIndex, PRInt32 *aSearchIndex, PRInt32 *aItemIndex)
    1: {
    1:   *aSearchIndex = -1;
    1:   *aItemIndex = -1;
    1: 
21610:   PRUint32 count = mSearches.Count();
    1:   PRUint32 index = 0;
 3188: 
 3188:   // Move index through the results of each registered nsIAutoCompleteSearch
 3188:   // until we find the given row
    1:   for (PRUint32 i = 0; i < count; ++i) {
21875:     nsIAutoCompleteResult *result = mResults.SafeObjectAt(i);
    1:     if (!result)
    1:       continue;
    1: 
    1:     PRUint16 searchResult;
    1:     result->GetSearchResult(&searchResult);
    1: 
 3188:     // Find out how many results were provided by the
 3188:     // current nsIAutoCompleteSearch
 3188:     PRUint32 rowCount = 0;
 4881:     if (searchResult == nsIAutoCompleteResult::RESULT_SUCCESS ||
 4881:         searchResult == nsIAutoCompleteResult::RESULT_SUCCESS_ONGOING) {
    1:       result->GetMatchCount(&rowCount);
    1:     }
    1: 
 3188:     // If the given row index is within the results range
 3188:     // of the current nsIAutoCompleteSearch then return the
 3188:     // search index and sub-index into the results array
 3188:     if ((rowCount != 0) && (index + rowCount-1 >= (PRUint32) aRowIndex)) {
    1:       *aSearchIndex = i;
    1:       *aItemIndex = aRowIndex - index;
    1:       return NS_OK;
    1:     }
    1: 
 3188:     // Advance the popup table index cursor past the
 3188:     // results of the current search.
    1:     index += rowCount;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsAutoCompleteController)
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsAutoCompleteSimpleResult)
    1: 
46998: NS_DEFINE_NAMED_CID(NS_AUTOCOMPLETECONTROLLER_CID);
46998: NS_DEFINE_NAMED_CID(NS_AUTOCOMPLETESIMPLERESULT_CID);
    1: 
46998: static const mozilla::Module::CIDEntry kAutoCompleteCIDs[] = {
46998:   { &kNS_AUTOCOMPLETECONTROLLER_CID, false, NULL, nsAutoCompleteControllerConstructor },
46998:   { &kNS_AUTOCOMPLETESIMPLERESULT_CID, false, NULL, nsAutoCompleteSimpleResultConstructor },
46998:   { NULL }
    1: };
    1: 
46998: static const mozilla::Module::ContractIDEntry kAutoCompleteContracts[] = {
46998:   { NS_AUTOCOMPLETECONTROLLER_CONTRACTID, &kNS_AUTOCOMPLETECONTROLLER_CID },
46998:   { NS_AUTOCOMPLETESIMPLERESULT_CONTRACTID, &kNS_AUTOCOMPLETESIMPLERESULT_CID },
46998:   { NULL }
46998: };
46998: 
46998: static const mozilla::Module kAutoCompleteModule = {
46998:   mozilla::Module::kVersion,
46998:   kAutoCompleteCIDs,
46998:   kAutoCompleteContracts
46998: };
46998: 
46998: NSMODULE_DEFN(tkAutoCompleteModule) = &kAutoCompleteModule;
