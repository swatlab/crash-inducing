 35778: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 35778:  * vim: sw=4 ts=4 et :
 35778:  */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 35778: 
 35778: #ifndef ipc_glue_AsyncChannel_h
 35778: #define ipc_glue_AsyncChannel_h 1
 35778: 
 35778: #include "base/basictypes.h"
 35778: #include "base/message_loop.h"
 35778: 
 69144: #include "mozilla/Monitor.h"
 71245: #include "mozilla/ipc/Transport.h"
 35786: 
 35786: //-----------------------------------------------------------------------------
 36018: 
 36018: namespace mozilla {
 36018: namespace ipc {
 36018: 
 36018: struct HasResultCodes
 36018: {
 35786:     enum Result {
 35786:         MsgProcessed,
 54001:         MsgDropped,
 35786:         MsgNotKnown,
 35786:         MsgNotAllowed,
 35786:         MsgPayloadError,
 42559:         MsgProcessingError,
 35786:         MsgRouteError,
 87157:         MsgValueError
 35786:     };
 36018: };
 35786: 
 83464: 
 83464: class RefCountedMonitor : public Monitor
 83464: {
 83464: public:
 83464:     RefCountedMonitor() 
 83464:         : Monitor("mozilla.ipc.AsyncChannel.mMonitor")
 83464:     {}
 83464: 
 83464:     NS_INLINE_DECL_THREADSAFE_REFCOUNTING(RefCountedMonitor)
 83464: };
 83464: 
 83464: class AsyncChannel : protected HasResultCodes
 35778: {
 35778: protected:
 69144:     typedef mozilla::Monitor Monitor;
 35882: 
 35778:     enum ChannelState {
 35778:         ChannelClosed,
 35778:         ChannelOpening,
 35859:         ChannelConnected,
 38106:         ChannelTimeout,
 36140:         ChannelClosing,
 35778:         ChannelError
 35778:     };
 35778: 
 35778: public:
 35778:     typedef IPC::Message Message;
 71245:     typedef mozilla::ipc::Transport Transport;
 35778: 
 36018:     class /*NS_INTERFACE_CLASS*/ AsyncListener: protected HasResultCodes
 35778:     {
 35778:     public:
 35787:         virtual ~AsyncListener() { }
 36140: 
 36140:         virtual void OnChannelClose() = 0;
 36140:         virtual void OnChannelError() = 0;
 35778:         virtual Result OnMessageReceived(const Message& aMessage) = 0;
 54001:         virtual void OnProcessingError(Result aError) = 0;
 57663:         virtual void OnChannelConnected(int32 peer_pid) {};
 35778:     };
 35778: 
 71237:     enum Side { Parent, Child, Unknown };
 71237: 
 36018: public:
 36140:     //
 36140:     // These methods are called on the "worker" thread
 36140:     //
 36078:     AsyncChannel(AsyncListener* aListener);
 36078:     virtual ~AsyncChannel();
 35778: 
 37201:     // "Open" from the perspective of the transport layer; the underlying
 35882:     // socketpair/pipe should already be created.
 35882:     //
 35882:     // Returns true iff the transport layer was successfully connected,
 35882:     // i.e., mChannelState == ChannelConnected.
 71237:     bool Open(Transport* aTransport, MessageLoop* aIOLoop=0, Side aSide=Unknown);
 35778:     
 83465:     // "Open" a connection to another thread in the same process.
 83465:     //
 83465:     // Returns true iff the transport layer was successfully connected,
 83465:     // i.e., mChannelState == ChannelConnected.
 83465:     //
 83465:     // For more details on the process of opening a channel between
 83465:     // threads, see the extended comment on this function
 83465:     // in AsyncChannel.cpp.
 83465:     bool Open(AsyncChannel *aTargetChan, MessageLoop *aTargetLoop, Side aSide);
 83465: 
 36039:     // Close the underlying transport channel.
 35778:     void Close();
 35778: 
103778:     // Force the channel to behave as if a channel error occurred. Valid
103778:     // for process links only, not thread links.
103778:     void CloseWithError();
103778: 
 35778:     // Asynchronously send a message to the other side of the channel
 38681:     virtual bool Send(Message* msg);
 35778: 
 71251:     // Asynchronously deliver a message back to this side of the
 71251:     // channel
 71251:     virtual bool Echo(Message* msg);
 71251: 
 57663:     // Send OnChannelConnected notification to listeners.
 57663:     void DispatchOnChannelConnected(int32 peer_pid);
 57663: 
 36140:     //
 83464:     // Each AsyncChannel is associated with either a ProcessLink or a
 83464:     // ThreadLink via the field mLink.  The type of link is determined
 83464:     // by whether this AsyncChannel is communicating with another
 83464:     // process or another thread.  In the former case, file
 83464:     // descriptors or a socket are used via the I/O queue.  In the
 83464:     // latter case, messages are enqueued directly onto the target
 83464:     // thread's work queue.
 36140:     //
 36140: 
 83464:     class Link {
 83464:     protected:
 83464:         AsyncChannel *mChan;
 83464: 
 83464:     public:
 83464:         Link(AsyncChannel *aChan);
 83464:         virtual ~Link();
 83464: 
 83464:         // n.b.: These methods all require that the channel monitor is
 83464:         // held when they are invoked.
 83464:         virtual void EchoMessage(Message *msg) = 0;
 83464:         virtual void SendMessage(Message *msg) = 0;
 83464:         virtual void SendClose() = 0;
 83464:     };
 83464: 
 83464:     class ProcessLink : public Link, public Transport::Listener {
 83464:     protected:
 83464:         Transport* mTransport;
 83464:         MessageLoop* mIOLoop;       // thread where IO happens
 83464:         Transport::Listener* mExistingListener; // channel's previous listener
 83464:     
 83464:         void OnCloseChannel();
 83464:         void OnChannelOpened();
 83464:         void OnEchoMessage(Message* msg);
 83464: 
 83464:         void AssertIOThread() const
 83464:         {
 83464:             NS_ABORT_IF_FALSE(mIOLoop == MessageLoop::current(),
 83464:                               "not on I/O thread!");
 83464:         }
 83464: 
 83464:     public:
 83464:         ProcessLink(AsyncChannel *chan);
 83464:         virtual ~ProcessLink();
 83464:         void Open(Transport* aTransport, MessageLoop *aIOLoop, Side aSide);
 83464:         
 83464:         // Run on the I/O thread, only when using inter-process link.
 83464:         // These methods acquire the monitor and forward to the
 83464:         // similarly named methods in AsyncChannel below
 83464:         // (OnMessageReceivedFromLink(), etc)
 35940:         NS_OVERRIDE virtual void OnMessageReceived(const Message& msg);
 35940:         NS_OVERRIDE virtual void OnChannelConnected(int32 peer_pid);
 35940:         NS_OVERRIDE virtual void OnChannelError();
 35778: 
 83465:         NS_OVERRIDE virtual void EchoMessage(Message *msg);
 83465:         NS_OVERRIDE virtual void SendMessage(Message *msg);
 83465:         NS_OVERRIDE virtual void SendClose();
 83465:     };
 83465:     
 83465:     class ThreadLink : public Link {
 83465:     protected:
 83465:         AsyncChannel* mTargetChan;
 83465:     
 83465:     public:
 83465:         ThreadLink(AsyncChannel *aChan, AsyncChannel *aTargetChan);
 83465:         virtual ~ThreadLink();
 83465: 
 83465:         NS_OVERRIDE virtual void EchoMessage(Message *msg);
 83465:         NS_OVERRIDE virtual void SendMessage(Message *msg);
 83465:         NS_OVERRIDE virtual void SendClose();
 83464:     };
 83464: 
 35778: protected:
 83464:     // The "link" thread is either the I/O thread (ProcessLink) or the
 83464:     // other actor's work thread (ThreadLink).  In either case, it is
 83464:     // NOT our worker thread.
 83464:     void AssertLinkThread() const
 83464:     {
 83464:         NS_ABORT_IF_FALSE(mWorkerLoop != MessageLoop::current(),
 83464:                           "on worker thread but should not be!");
 83464:     }
 83464: 
 35971:     // Can be run on either thread
 41379:     void AssertWorkerThread() const
 35971:     {
 35977:         NS_ABORT_IF_FALSE(mWorkerLoop == MessageLoop::current(),
 35977:                           "not on worker thread!");
 35971:     }
 35971: 
 83464:     bool Connected() const {
 83464:         mMonitor->AssertCurrentThreadOwns();
 83464:         return ChannelConnected == mChannelState;
 35971:     }
 35971: 
 83464:     // Return true if |msg| is a special message targeted at the IO
 83464:     // thread, in which case it shouldn't be delivered to the worker.
 83464:     virtual bool MaybeInterceptSpecialIOMessage(const Message& msg);
 83464:     void ProcessGoodbyeMessage();
 83464: 
 83464:     // Runs on the link thread. Invoked either from the I/O thread methods above
 83464:     // or directly from the other actor if using a thread-based link.
 83464:     // 
 83464:     // n.b.: mMonitor is always held when these methods are invoked.
 83464:     // In the case of a ProcessLink, it is acquired by the ProcessLink.
 83464:     // In the case of a ThreadLink, it is acquired by the other actor, 
 83464:     // which then invokes these methods directly.
 83464:     virtual void OnMessageReceivedFromLink(const Message& msg);
 83464:     virtual void OnChannelErrorFromLink();
 83464:     void PostErrorNotifyTask();
 35940: 
 35977:     // Run on the worker thread
 35778:     void OnDispatchMessage(const Message& aMsg);
 38099:     virtual bool OnSpecialMessage(uint16 id, const Message& msg);
 41379:     void SendSpecialMessage(Message* msg) const;
 38099: 
 38106:     // Tell the IO thread to close the channel and wait for it to ACK.
 38106:     void SynchronouslyClose();
 38106: 
 36015:     bool MaybeHandleError(Result code, const char* channelName);
 41379:     void ReportConnectionError(const char* channelName) const;
 36015: 
 36140:     // Run on the worker thread
 36140: 
 39311:     void OnNotifyMaybeChannelError();
 41379:     virtual bool ShouldDeferNotifyMaybeError() const {
 39311:         return false;
 39311:     }
 36140:     void NotifyChannelClosed();
 36140:     void NotifyMaybeChannelError();
 83465:     void OnOpenAsSlave(AsyncChannel *aTargetChan, Side aSide);
 83465:     void CommonThreadOpenInit(AsyncChannel *aTargetChan, Side aSide);
 36140: 
 39255:     virtual void Clear();
 36140: 
 35799:     AsyncListener* mListener;
 35778:     ChannelState mChannelState;
 83464:     nsRefPtr<RefCountedMonitor> mMonitor;
 35778:     MessageLoop* mWorkerLoop;   // thread where work is done
 35974:     bool mChild;                // am I the child or parent?
 36607:     CancelableTask* mChannelErrorTask; // NotifyMaybeChannelError runnable
 83464:     Link *mLink;                // link to other thread/process
 35778: };
 35778: 
 35778: } // namespace ipc
 35778: } // namespace mozilla
 35778: #endif  // ifndef ipc_glue_AsyncChannel_h
