    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications.
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Vidur Apparao <vidur@netscape.com> (original author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * A class that handles loading and evaluation of <script> elements.
    1:  */
    1: 
    1: #ifndef __nsScriptLoader_h__
    1: #define __nsScriptLoader_h__
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsIScriptElement.h"
    1: #include "nsIURI.h"
    1: #include "nsCOMArray.h"
 6398: #include "nsTArray.h"
 6398: #include "nsAutoPtr.h"
    1: #include "nsIDocument.h"
    1: #include "nsIStreamLoader.h"
    1: 
    1: class nsScriptLoadRequest;
    1: 
    1: //////////////////////////////////////////////////////////////
    1: // Script loader implementation
    1: //////////////////////////////////////////////////////////////
    1: 
    1: class nsScriptLoader : public nsIStreamLoaderObserver
    1: {
54758:   friend class nsScriptRequestProcessor;
    1: public:
    1:   nsScriptLoader(nsIDocument* aDocument);
    1:   virtual ~nsScriptLoader();
    1: 
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSISTREAMLOADEROBSERVER
    1: 
    1:   /**
    1:    * The loader maintains a weak reference to the document with
    1:    * which it is initialized. This call forces the reference to
    1:    * be dropped.
    1:    */
    1:   void DropDocumentReference()
    1:   {
    1:     mDocument = nsnull;
    1:   }
    1: 
    1:   /**
    1:    * Add an observer for all scripts loaded through this loader.
    1:    *
    1:    * @param aObserver observer for all script processing.
    1:    */
    1:   nsresult AddObserver(nsIScriptLoaderObserver* aObserver)
    1:   {
    1:     return mObservers.AppendObject(aObserver) ? NS_OK :
    1:       NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   /**
    1:    * Remove an observer.
    1:    *
    1:    * @param aObserver observer to be removed
    1:    */
    1:   void RemoveObserver(nsIScriptLoaderObserver* aObserver)
    1:   {
    1:     mObservers.RemoveObject(aObserver);
    1:   }
    1:   
    1:   /**
    1:    * Process a script element. This will include both loading the 
    1:    * source of the element if it is not inline and evaluating
    1:    * the script itself.
    1:    *
    1:    * If the script is an inline script that can be executed immediately
    1:    * (i.e. there are no other scripts pending) then ScriptAvailable
    1:    * and ScriptEvaluated will be called before the function returns.
    1:    *
    1:    * If NS_ERROR_HTMLPARSER_BLOCK is returned the script could not be
    1:    * executed immediately. In this case ScriptAvailable is guaranteed
    1:    * to be called at a later point (as well as possibly ScriptEvaluated).
    1:    *
    1:    * @param aElement The element representing the script to be loaded and
    1:    *        evaluated.
    1:    */
    1:   nsresult ProcessScriptElement(nsIScriptElement* aElement);
    1: 
    1:   /**
    1:    * Gets the currently executing script. This is useful if you want to
    1:    * generate a unique key based on the currently executing script.
    1:    */
    1:   nsIScriptElement* GetCurrentScript()
    1:   {
    1:     return mCurrentScript;
    1:   }
    1: 
57326:   nsIScriptElement* GetCurrentParserInsertedScript()
57326:   {
57326:     return mCurrentParserInsertedScript;
57326:   }
57326: 
    1:   /**
    1:    * Whether the loader is enabled or not.
    1:    * When disabled, processing of new script elements is disabled. 
    1:    * Any call to ProcessScriptElement() will fail with a return code of
    1:    * NS_ERROR_NOT_AVAILABLE. Note that this DOES NOT disable
    1:    * currently loading or executing scripts.
    1:    */
    1:   PRBool GetEnabled()
    1:   {
    1:     return mEnabled;
    1:   }
    1:   void SetEnabled(PRBool aEnabled)
    1:   {
    1:     if (!mEnabled && aEnabled) {
    1:       ProcessPendingRequestsAsync();
    1:     }
    1:     mEnabled = aEnabled;
    1:   }
    1: 
    1:   /**
    1:    * Add/remove blocker. Blockers will stop scripts from executing, but not
    1:    * from loading.
    1:    */
    1:   void AddExecuteBlocker()
    1:   {
13098:     ++mBlockerCount;
    1:   }
    1:   void RemoveExecuteBlocker()
    1:   {
    1:     if (!--mBlockerCount) {
    1:       ProcessPendingRequestsAsync();
    1:     }
    1:   }
    1: 
    1:   /**
    1:    * Convert the given buffer to a UTF-16 string.
    1:    * @param aChannel     Channel corresponding to the data. May be null.
    1:    * @param aData        The data to convert
    1:    * @param aLength      Length of the data
    1:    * @param aHintCharset Hint for the character set (e.g., from a charset
    1:    *                     attribute). May be the empty string.
    1:    * @param aDocument    Document which the data is loaded for. Must not be
    1:    *                     null.
    1:    * @param aString      [out] Data as converted to unicode
    1:    */
    1:   static nsresult ConvertToUTF16(nsIChannel* aChannel, const PRUint8* aData,
    1:                                  PRUint32 aLength,
    1:                                  const nsString& aHintCharset,
    1:                                  nsIDocument* aDocument, nsString& aString);
    1: 
    1:   /**
    1:    * Processes any pending requests that are ready for processing.
    1:    */
    1:   void ProcessPendingRequests();
    1: 
13464:   /**
26472:    * Check whether it's OK to load a script from aURI in
26472:    * aDocument.
26472:    */
26472:   static nsresult ShouldLoadScript(nsIDocument* aDocument,
26472:                                    nsISupports* aContext,
26472:                                    nsIURI* aURI,
26472:                                    const nsAString &aType);
26472: 
26472:   /**
13511:    * Check whether it's OK to execute a script loaded via aChannel in
13511:    * aDocument.
13464:    */
13511:   static PRBool ShouldExecuteScript(nsIDocument* aDocument,
13464:                                     nsIChannel* aChannel);
13464: 
16373:   /**
16373:    * Starts deferring deferred scripts and puts them in the mDeferredRequests
16373:    * queue instead.
16373:    */
16373:   void BeginDeferringScripts()
16373:   {
16373:     mDeferEnabled = PR_TRUE;
23757:     if (mDocument) {
23757:       mDocument->BlockOnload();
23757:     }
16373:   }
16373: 
16373:   /**
30067:    * Notifies the script loader that parsing is done.  If aTerminated is true,
30067:    * this will drop any pending scripts that haven't run yet.  Otherwise, it
30067:    * will stops deferring scripts and immediately processes the
30067:    * mDeferredRequests queue.
16373:    *
30067:    * WARNING: This function will synchronously execute content scripts, so be
16373:    * prepared that the world might change around you.
16373:    */
30067:   void ParsingComplete(PRBool aTerminated);
16373: 
20053:   /**
24229:    * Returns the number of pending scripts, deferred or not.
24229:    */
24229:   PRUint32 HasPendingOrCurrentScripts()
24229:   {
54758:     return mCurrentScript || mParserBlockingRequest;
24229:   }
24229: 
24229:   /**
20053:    * Adds aURI to the preload list and starts loading it.
20053:    *
20053:    * @param aURI The URI of the external script.
20053:    * @param aCharset The charset parameter for the script.
20053:    * @param aType The type parameter for the script.
20053:    */
20053:   virtual void PreloadURI(nsIURI *aURI, const nsAString &aCharset,
20053:                           const nsAString &aType);
20053: 
54758: private:
    1:   /**
21823:    * Helper function to check the content policy for a given request.
21823:    */
26472:   static nsresult CheckContentPolicy(nsIDocument* aDocument,
21823:                                      nsISupports *aContext,
26472:                                      nsIURI *aURI,
21823:                                      const nsAString &aType);
21823: 
21823:   /**
20053:    * Start a load for aRequest's URI.
20053:    */
20053:   nsresult StartLoad(nsScriptLoadRequest *aRequest, const nsAString &aType);
20053: 
20053:   /**
23757:    * Process any pending requests asynchronously (i.e. off an event) if there
    1:    * are any. Note that this is a no-op if there aren't any currently pending
    1:    * requests.
23757:    *
23757:    * This function is virtual to allow cross-library calls to SetEnabled()
    1:    */
    1:   virtual void ProcessPendingRequestsAsync();
    1: 
 6398:   /**
 6398:    * If true, the loader is ready to execute scripts, and so are all its
 6398:    * ancestors.  If the loader itself is ready but some ancestor is not, this
 6398:    * function will add an execute blocker and ask the ancestor to remove it
 6398:    * once it becomes ready.
 6398:    */
 6398:   PRBool ReadyToExecuteScripts();
 6398: 
 6398:   /**
 6398:    * Return whether just this loader is ready to execute scripts.
 6398:    */
 6398:   PRBool SelfReadyToExecuteScripts()
    1:   {
    1:     return mEnabled && !mBlockerCount;
    1:   }
    1: 
 6398:   PRBool AddPendingChildLoader(nsScriptLoader* aChild) {
 6398:     return mPendingChildLoaders.AppendElement(aChild) != nsnull;
 6398:   }
 6398:   
    1:   nsresult ProcessRequest(nsScriptLoadRequest* aRequest);
    1:   void FireScriptAvailable(nsresult aResult,
    1:                            nsScriptLoadRequest* aRequest);
    1:   void FireScriptEvaluated(nsresult aResult,
    1:                            nsScriptLoadRequest* aRequest);
    1:   nsresult EvaluateScript(nsScriptLoadRequest* aRequest,
    1:                           const nsAFlatString& aScript);
    1: 
    1:   nsresult PrepareLoadedRequest(nsScriptLoadRequest* aRequest,
    1:                                 nsIStreamLoader* aLoader,
    1:                                 nsresult aStatus,
    1:                                 PRUint32 aStringLen,
    1:                                 const PRUint8* aString);
    1: 
    1:   nsIDocument* mDocument;                   // [WEAK]
    1:   nsCOMArray<nsIScriptLoaderObserver> mObservers;
57321:   nsTArray<nsRefPtr<nsScriptLoadRequest> > mNonAsyncExternalScriptInsertedRequests;
55840:   nsTArray<nsRefPtr<nsScriptLoadRequest> > mAsyncRequests;
55840:   nsTArray<nsRefPtr<nsScriptLoadRequest> > mDeferRequests;
56806:   nsTArray<nsRefPtr<nsScriptLoadRequest> > mXSLTRequests;
55840:   nsRefPtr<nsScriptLoadRequest> mParserBlockingRequest;
20053: 
20053:   // In mRequests, the additional information here is stored by the element.
20053:   struct PreloadInfo {
20053:     nsRefPtr<nsScriptLoadRequest> mRequest;
20053:     nsString mCharset;
20053:   };
20053: 
20053:   struct PreloadRequestComparator {
20053:     PRBool Equals(const PreloadInfo &aPi, nsScriptLoadRequest * const &aRequest)
20053:         const
20053:     {
20053:       return aRequest == aPi.mRequest;
20053:     }
20053:   };
20053:   struct PreloadURIComparator {
20053:     PRBool Equals(const PreloadInfo &aPi, nsIURI * const &aURI) const;
20053:   };
20053:   nsTArray<PreloadInfo> mPreloads;
20053: 
    1:   nsCOMPtr<nsIScriptElement> mCurrentScript;
57326:   nsCOMPtr<nsIScriptElement> mCurrentParserInsertedScript;
 6398:   // XXXbz do we want to cycle-collect these or something?  Not sure.
 6398:   nsTArray< nsRefPtr<nsScriptLoader> > mPendingChildLoaders;
    1:   PRUint32 mBlockerCount;
    1:   PRPackedBool mEnabled;
16373:   PRPackedBool mDeferEnabled;
54758:   PRPackedBool mDocumentParsingDone;
    1: };
    1: 
75206: class nsAutoScriptLoaderDisabler
75206: {
75206: public:
75206:   nsAutoScriptLoaderDisabler(nsIDocument* aDoc)
75206:   {
75206:     mLoader = aDoc->ScriptLoader();
75206:     mWasEnabled = mLoader->GetEnabled();
75206:     if (mWasEnabled) {
75206:       mLoader->SetEnabled(PR_FALSE);
75206:     }
75206:   }
75206:   
75206:   ~nsAutoScriptLoaderDisabler()
75206:   {
75206:     if (mWasEnabled) {
75206:       mLoader->SetEnabled(PR_TRUE);
75206:     }
75206:   }
75206:   
75206:   PRBool mWasEnabled;
75206:   nsRefPtr<nsScriptLoader> mLoader;
75206: };
75206: 
    1: #endif //__nsScriptLoader_h__
