    1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is inline spellchecker code.
    1:  *
    1:  * The Initial Developer of the Original Code is Google Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 2004-2006
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Brett Wilson <brettw@gmail.com> (original author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMDocumentRange.h"
68870: #include "nsIDOMViewCSS.h"
    1: #include "nsIDocument.h"
    1: #include "nsString.h"
    1: #include "nsTArray.h"
 5409: #include "nsIUGenCategory.h"
    1: 
    1: //#define DEBUG_SPELLCHECK
    1: 
    1: class nsIDOMRange;
    1: class nsIDOMNode;
    1: 
    1: /**
    1:  *    This class extracts text from the DOM and builds it into a single string.
    1:  *    The string includes whitespace breaks whereever non-inline elements begin
    1:  *    and end. This string is broken into "real words", following somewhat
    1:  *    complex rules; for example substrings that look like URLs or
    1:  *    email addresses are treated as single words, but otherwise many kinds of
    1:  *    punctuation are treated as word separators. GetNextWord provides a way
    1:  *    to iterate over these "real words".
    1:  *
    1:  *    The basic operation is:
    1:  *
    1:  *    1. Call Init with the weak pointer to the editor that you're using.
    1:  *    2. Call SetEnd to set where you want to stop spellchecking. We'll stop
    1:  *       at the word boundary after that. If SetEnd is not called, we'll stop
    1:  *       at the end of the document's root element.
    1:  *    3. Call SetPosition to initialize the current position inside the
    1:  *       previously given range.
    1:  *    4. Call GetNextWord over and over until it returns false.
    1:  */
    1: 
    1: class mozInlineSpellWordUtil
    1: {
    1: public:
    1:   struct NodeOffset {
    1:     nsIDOMNode* mNode;
    1:     PRInt32     mOffset;
    1:     
    1:     NodeOffset(nsIDOMNode* aNode, PRInt32 aOffset) :
    1:       mNode(aNode), mOffset(aOffset) {}
    1:   };
    1: 
    1:   mozInlineSpellWordUtil()
    1:     : mRootNode(nsnull),
    1:       mSoftBegin(nsnull, 0), mSoftEnd(nsnull, 0),
    1:       mNextWordIndex(-1), mSoftTextValid(PR_FALSE) {}
    1: 
    1:   nsresult Init(nsWeakPtr aWeakEditor);
    1: 
    1:   nsresult SetEnd(nsIDOMNode* aEndNode, PRInt32 aEndOffset);
    1: 
    1:   // sets the current position, this should be inside the range. If we are in
    1:   // the middle of a word, we'll move to its start.
    1:   nsresult SetPosition(nsIDOMNode* aNode, PRInt32 aOffset);
    1: 
    1:   // Given a point inside or immediately following a word, this returns the
    1:   // DOM range that exactly encloses that word's characters. The current
    1:   // position will be at the end of the word. This will find the previous
    1:   // word if the current position is space, so if you care that the point is
    1:   // inside the word, you should check the range.
    1:   //
    1:   // THIS CHANGES THE CURRENT POSITION AND RANGE. It is designed to be called
    1:   // before you actually generate the range you are interested in and iterate
    1:   // the words in it.
    1:   nsresult GetRangeForWord(nsIDOMNode* aWordNode, PRInt32 aWordOffset,
    1:                            nsIDOMRange** aRange);
    1: 
    1:   // Moves to the the next word in the range, and retrieves it's text and range.
    1:   // An empty word and a NULL range are returned when we are done checking.
    1:   // aSkipChecking will be set if the word is "special" and shouldn't be
    1:   // checked (e.g., an email address).
    1:   nsresult GetNextWord(nsAString& aText, nsIDOMRange** aRange,
    1:                        PRBool* aSkipChecking);
    1: 
    1:   // Call to normalize some punctuation. This function takes an autostring
    1:   // so we can access characters directly.
    1:   static void NormalizeWord(nsSubstring& aWord);
    1: 
    1:   nsIDOMDocumentRange* GetDocumentRange() const { return mDOMDocumentRange; }
    1:   nsIDocument* GetDocument() const { return mDocument; }
    1:   nsIDOMNode* GetRootNode() { return mRootNode; }
 5409:   nsIUGenCategory* GetCategories() { return mCategories; }
    1:   
    1: private:
    1: 
    1:   // cached stuff for the editor, set by Init
    1:   nsCOMPtr<nsIDOMDocumentRange> mDOMDocumentRange;
    1:   nsCOMPtr<nsIDocument>         mDocument;
68870:   nsCOMPtr<nsIDOMViewCSS>       mCSSView;
 5409:   nsCOMPtr<nsIUGenCategory>     mCategories;
    1: 
    1:   // range to check, see SetRange
    1:   nsIDOMNode* mRootNode;
    1:   NodeOffset  mSoftBegin;
    1:   NodeOffset  mSoftEnd;
    1: 
    1:   // DOM text covering the soft range, with newlines added at block boundaries
    1:   nsString mSoftText;
    1:   // A list of where we extracted text from, ordered by mSoftTextOffset. A given
    1:   // DOM node appears at most once in this list.
    1:   struct DOMTextMapping {
    1:     NodeOffset mNodeOffset;
    1:     PRInt32    mSoftTextOffset;
    1:     PRInt32    mLength;
    1:     
    1:     DOMTextMapping(NodeOffset aNodeOffset, PRInt32 aSoftTextOffset, PRInt32 aLength)
    1:       : mNodeOffset(aNodeOffset), mSoftTextOffset(aSoftTextOffset),
    1:         mLength(aLength) {}
    1:   };
    1:   nsTArray<DOMTextMapping> mSoftTextDOMMapping;
    1:   
    1:   // A list of the "real words" in mSoftText, ordered by mSoftTextOffset
    1:   struct RealWord {
    1:     PRInt32      mSoftTextOffset;
    1:     PRInt32      mLength;
    1:     PRPackedBool mCheckableWord;
    1:     
    1:     RealWord(PRInt32 aOffset, PRInt32 aLength, PRPackedBool aCheckable)
    1:       : mSoftTextOffset(aOffset), mLength(aLength), mCheckableWord(aCheckable) {}
    1:     PRInt32 EndOffset() const { return mSoftTextOffset + mLength; }
    1:   };
    1:   nsTArray<RealWord> mRealWords;
    1:   PRInt32            mNextWordIndex;
    1: 
    1:   PRPackedBool mSoftTextValid;
    1: 
    1:   void InvalidateWords() { mSoftTextValid = PR_FALSE; }
    1:   void EnsureWords();
    1:   
    1:   PRInt32 MapDOMPositionToSoftTextOffset(NodeOffset aNodeOffset);
    1:   // Map an offset into mSoftText to a DOM position. Note that two DOM positions
    1:   // can map to the same mSoftText offset, e.g. given nodes A=aaaa and B=bbbb
    1:   // forming aaaabbbb, (A,4) and (B,0) give the same string offset. So,
    1:   // aHintBefore controls which position we return ... if aHint is eEnd
    1:   // then the position indicates the END of a range so we return (A,4). Otherwise
    1:   // the position indicates the START of a range so we return (B,0).
    1:   enum DOMMapHint { HINT_BEGIN, HINT_END };
    1:   NodeOffset MapSoftTextOffsetToDOMPosition(PRInt32 aSoftTextOffset,
    1:                                             DOMMapHint aHint);
    1:   // Finds the index of the real word containing aSoftTextOffset, or -1 if none
    1:   // If it's exactly between two words, then if aHint is HINT_BEGIN, return the
    1:   // later word (favouring the assumption that it's the BEGINning of a word),
    1:   // otherwise return the earlier word (assuming it's the END of a word).
    1:   // If aSearchForward is true, then if we don't find a word at the given
    1:   // position, search forward until we do find a word and return that (if found).
    1:   PRInt32 FindRealWordContaining(PRInt32 aSoftTextOffset, DOMMapHint aHint,
    1:                                  PRBool aSearchForward);
    1:     
    1:   // build mSoftText and mSoftTextDOMMapping
    1:   void BuildSoftText();
    1:   // Build mRealWords array
    1:   void BuildRealWords();
    1: 
    1:   void SplitDOMWord(PRInt32 aStart, PRInt32 aEnd);
    1: 
    1:   // Convenience functions, object must be initialized
    1:   nsresult MakeRange(NodeOffset aBegin, NodeOffset aEnd, nsIDOMRange** aRange);
    1:   nsresult MakeRangeForWord(const RealWord& aWord, nsIDOMRange** aRange);
    1: };
