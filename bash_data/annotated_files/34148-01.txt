    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: // vim:cindent:ts=2:et:sw=2:
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Dan Rosen <dr@netscape.com>
    1:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * construction of a frame tree that is nearly isomorphic to the content
    1:  * tree and updating of that tree in response to dynamic changes
    1:  */
    1: 
    1: #include "nsCSSFrameConstructor.h"
    1: #include "nsCRT.h"
    1: #include "nsIAtom.h"
    1: #include "nsIURL.h"
    1: #include "nsHashtable.h"
    1: #include "nsIHTMLDocument.h"
    1: #include "nsIStyleRule.h"
    1: #include "nsIFrame.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsPresContext.h"
    1: #include "nsILinkHandler.h"
    1: #include "nsIDocument.h"
    1: #include "nsTableFrame.h"
    1: #include "nsTableColGroupFrame.h"
    1: #include "nsTableColFrame.h"
    1: #include "nsIDOMHTMLDocument.h"
    1: #include "nsIDOMHTMLTableColElement.h"
    1: #include "nsIDOMHTMLTableCaptionElem.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsIPresShell.h"
33262: #include "nsUnicharUtils.h"
    1: #include "nsStyleSet.h"
    1: #include "nsIViewManager.h"
    1: #include "nsIEventStateManager.h"
    1: #include "nsIScrollableView.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsTableOuterFrame.h"
    1: #include "nsIDOMXULElement.h"
    1: #include "nsHTMLContainerFrame.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIDOMHTMLSelectElement.h"
    1: #include "nsIDOMHTMLLegendElement.h"
    1: #include "nsIComboboxControlFrame.h"
    1: #include "nsIListControlFrame.h"
    1: #include "nsISelectControlFrame.h"
    1: #include "nsIRadioControlFrame.h"
    1: #include "nsICheckboxControlFrame.h"
    1: #include "nsIDOMCharacterData.h"
    1: #include "nsIDOMHTMLImageElement.h"
    1: #include "nsPlaceholderFrame.h"
    1: #include "nsTableRowGroupFrame.h"
    1: #include "nsStyleChangeList.h"
    1: #include "nsIFormControl.h"
    1: #include "nsCSSAnonBoxes.h"
    1: #include "nsCSSPseudoElements.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsTextFragment.h"
    1: #include "nsIAnonymousContentCreator.h"
    1: #include "nsFrameManager.h"
    1: #include "nsLegendFrame.h"
    1: #include "nsIContentIterator.h"
    1: #include "nsBoxLayoutState.h"
    1: #include "nsBindingManager.h"
    1: #include "nsXBLBinding.h"
    1: #include "nsITheme.h"
    1: #include "nsContentCID.h"
    1: #include "nsContentUtils.h"
 7189: #include "nsIScriptError.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsObjectFrame.h"
    1: #include "nsRuleNode.h"
    1: #include "nsIDOMMutationEvent.h"
    1: #include "nsChildIterator.h"
    1: #include "nsCSSRendering.h"
    1: #include "nsISelectElement.h"
    1: #include "nsLayoutErrors.h"
    1: #include "nsLayoutUtils.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsBoxFrame.h"
    1: #include "nsIBoxLayout.h"
    1: #include "nsImageFrame.h"
    1: #include "nsIObjectLoadingContent.h"
    1: #include "nsContentErrors.h"
 3645: #include "nsIPrincipal.h"
    1: #include "nsIDOMWindowInternal.h"
11845: #include "nsStyleUtil.h"
    1: #include "nsBox.h"
24551: #include "nsTArray.h"
27311: #include "nsGenericDOMDataNode.h"
    1: 
    1: #ifdef MOZ_XUL
    1: #include "nsIRootBox.h"
    1: #include "nsIDOMXULCommandDispatcher.h"
    1: #include "nsIDOMXULDocument.h"
    1: #include "nsIXULDocument.h"
    1: #endif
    1: #ifdef ACCESSIBILITY
    1: #include "nsIAccessibilityService.h"
    1: #include "nsIAccessibleEvent.h"
    1: #endif
    1: 
    1: #include "nsInlineFrame.h"
    1: #include "nsBlockFrame.h"
    1: 
    1: #include "nsIScrollableFrame.h"
    1: 
    1: #include "nsIXBLService.h"
    1: 
    1: #undef NOISY_FIRST_LETTER
    1: 
    1: #ifdef MOZ_MATHML
    1: #include "nsMathMLParts.h"
    1: #endif
16411: #ifdef MOZ_SVG
28081: #include "nsSVGFeatures.h"
19948: #include "nsSVGEffects.h"
24030: #include "nsSVGUtils.h"
24030: #include "nsSVGOuterSVGFrame.h"
16411: #endif
    1: 
    1: nsIFrame*
    1: NS_NewHTMLCanvasFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
15751: #if defined(MOZ_MEDIA)
15751: nsIFrame*
15751: NS_NewHTMLVideoFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
15751: #endif
15751: 
    1: #ifdef MOZ_SVG
29052: #include "nsSVGTextContainerFrame.h"
    1: 
    1: PRBool
    1: NS_SVGEnabled();
    1: nsIFrame*
23953: NS_NewSVGOuterSVGFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGInnerSVGFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGPathGeometryFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGGFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGGenericContainerFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGForeignObjectFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGAFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGGlyphFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGSwitchFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
15895: nsIFrame*
23953: NS_NewSVGTextFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGTSpanFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGContainerFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGUseFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: extern nsIFrame*
23953: NS_NewSVGLinearGradientFrame(nsIPresShell *aPresShell, nsStyleContext* aContext);
    1: extern nsIFrame*
23953: NS_NewSVGRadialGradientFrame(nsIPresShell *aPresShell, nsStyleContext* aContext);
    1: extern nsIFrame*
23953: NS_NewSVGStopFrame(nsIPresShell *aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGMarkerFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: extern nsIFrame*
23953: NS_NewSVGImageFrame(nsIPresShell *aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGClipPathFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGTextPathFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGFilterFrame(nsIPresShell *aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGPatternFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGMaskFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
    1: NS_NewSVGLeafFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: #endif
    1: 
    1: #include "nsIDocument.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMDocumentXBL.h"
    1: #include "nsIScrollable.h"
    1: #include "nsINodeInfo.h"
    1: #include "prenv.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsNodeInfoManager.h"
    1: #include "nsContentCreatorFunctions.h"
    1: #include "nsIServiceManager.h"
    1: 
    1: // Global object maintenance
    1: nsIXBLService * nsCSSFrameConstructor::gXBLService = nsnull;
    1: 
    1: #ifdef DEBUG
    1: // Set the environment variable GECKO_FRAMECTOR_DEBUG_FLAGS to one or
    1: // more of the following flags (comma separated) for handy debug
    1: // output.
    1: static PRBool gNoisyContentUpdates = PR_FALSE;
    1: static PRBool gReallyNoisyContentUpdates = PR_FALSE;
    1: static PRBool gNoisyInlineConstruction = PR_FALSE;
    1: static PRBool gVerifyFastFindFrame = PR_FALSE;
    1: 
    1: struct FrameCtorDebugFlags {
    1:   const char* name;
    1:   PRBool* on;
    1: };
    1: 
    1: static FrameCtorDebugFlags gFlags[] = {
    1:   { "content-updates",              &gNoisyContentUpdates },
    1:   { "really-noisy-content-updates", &gReallyNoisyContentUpdates },
    1:   { "noisy-inline",                 &gNoisyInlineConstruction },
26208:   { "fast-find-frame",              &gVerifyFastFindFrame }
    1: };
    1: 
    1: #define NUM_DEBUG_FLAGS (sizeof(gFlags) / sizeof(gFlags[0]))
    1: #endif
    1: 
    1: 
    1: #ifdef MOZ_XUL
    1: #include "nsMenuFrame.h"
    1: #include "nsPopupSetFrame.h"
    1: #include "nsTreeColFrame.h"
    1: #include "nsIBoxObject.h"
    1: #include "nsPIListBoxObject.h"
    1: #include "nsListBoxBodyFrame.h"
    1: #include "nsListItemFrame.h"
23176: #include "nsXULLabelFrame.h"
    1: 
    1: //------------------------------------------------------------------
    1: 
    1: nsIFrame*
    1: NS_NewAutoRepeatBoxFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewRootBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewDocElementBoxFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewThumbFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
23947: NS_NewDeckFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewLeafBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
23947: NS_NewStackFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewProgressMeterFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewImageBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewTextBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewGroupBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewButtonBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewSplitterFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewMenuPopupFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewPopupSetFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewMenuFrame (nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags);
    1: 
    1: nsIFrame*
    1: NS_NewMenuBarFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewTreeBodyFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: // grid
    1: nsresult
    1: NS_NewGridLayout2 ( nsIPresShell* aPresShell, nsIBoxLayout** aNewLayout );
    1: nsIFrame*
23947: NS_NewGridRowLeafFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23947: NS_NewGridRowGroupFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: // end grid
    1: 
    1: nsIFrame*
    1: NS_NewTitleBarFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewResizerFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: 
    1: #endif
    1: 
    1: nsIFrame*
    1: NS_NewHTMLScrollFrame (nsIPresShell* aPresShell, nsStyleContext* aContext, PRBool aIsRoot);
    1: 
    1: nsIFrame*
    1: NS_NewXULScrollFrame (nsIPresShell* aPresShell, nsStyleContext* aContext, PRBool aIsRoot);
    1: 
    1: nsIFrame*
    1: NS_NewSliderFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewScrollbarFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewScrollbarButtonFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: 
    1: #ifdef NOISY_FINDFRAME
    1: static PRInt32 FFWC_totalCount=0;
    1: static PRInt32 FFWC_doLoop=0;
    1: static PRInt32 FFWC_doSibling=0;
    1: static PRInt32 FFWC_recursions=0;
    1: static PRInt32 FFWC_nextInFlows=0;
    1: #endif
    1: 
    1: static nsresult
    1: DeletingFrameSubtree(nsFrameManager* aFrameManager,
    1:                      nsIFrame*       aFrame);
    1: 
    1: static inline nsIFrame*
23176: GetFieldSetBlockFrame(nsIFrame* aFieldsetFrame)
    1: {
    1:   // Depends on the fieldset child frame order - see ConstructFieldSetFrame() below.
    1:   nsIFrame* firstChild = aFieldsetFrame->GetFirstChild(nsnull);
    1:   return firstChild && firstChild->GetNextSibling() ? firstChild->GetNextSibling() : firstChild;
    1: }
    1: 
30785: #define FCDATA_DECL(_flags, _func) \
30785:   { _flags, { (FrameCreationFunc)_func } }
30785: 
    1: //----------------------------------------------------------------------
    1: 
    1: static PRBool
 2829: IsInlineOutside(nsIFrame* aFrame)
 2829: {
 2829:   return aFrame->GetStyleDisplay()->IsInlineOutside();
 2829: }
 2829: 
 4696: /**
 4696:  * True if aFrame is an actual inline frame in the sense of non-replaced
 4696:  * display:inline CSS boxes.  In other words, it can be affected by {ib}
 4696:  * splitting and can contain first-letter frames.  Basically, this is either an
 4696:  * inline frame (positioned or otherwise) or an line frame (this last because
 4696:  * it can contain first-letter and because inserting blocks in the middle of it
 4696:  * needs to terminate it).
 4696:  */
    1: static PRBool
 4696: IsInlineFrame(const nsIFrame* aFrame)
 4696: {
 4696:   return aFrame->IsFrameOfType(nsIFrame::eLineParticipant);
    1: }
    1: 
 7189: /**
 7189:  * If any children require a block parent, return the first such child.
 7189:  * Otherwise return null.
 7189:  */
 7189: static nsIContent*
 7189: AnyKidsNeedBlockParent(nsIFrame *aFrameList)
 7189: {
 7189:   for (nsIFrame *k = aFrameList; k; k = k->GetNextSibling()) {
 7189:     // Line participants, such as text and inline frames, can't be
 7189:     // directly inside a XUL box; they must be wrapped in an
 7189:     // intermediate block.
 7189:     if (k->IsFrameOfType(nsIFrame::eLineParticipant)) {
 7189:       return k->GetContent();
 7189:     }
 7189:   }
 7189:   return nsnull;
 7189: }
 7189: 
 7189: // Reparent a frame into a wrapper frame that is a child of its old parent.
 7189: static void
 7189: ReparentFrame(nsFrameManager* aFrameManager,
 7189:               nsIFrame* aNewParentFrame,
 7189:               nsIFrame* aFrame)
 7189: {
 7189:   aFrame->SetParent(aNewParentFrame);
 7189:   aFrameManager->ReParentStyleContext(aFrame);
 7189:   if (aFrame->GetStateBits() &
 7189:       (NS_FRAME_HAS_VIEW | NS_FRAME_HAS_CHILD_WITH_VIEW)) {
 7189:     // No need to walk up the tree, since the bits are already set
 7189:     // right on the parent of aNewParentFrame.
 7189:     NS_ASSERTION(aNewParentFrame->GetParent()->GetStateBits() &
 7189:                    NS_FRAME_HAS_CHILD_WITH_VIEW,
 7189:                  "aNewParentFrame's parent should have this bit set!");
 7189:     aNewParentFrame->AddStateBits(NS_FRAME_HAS_CHILD_WITH_VIEW);
 7189:   }
 7189: }
 7189: 
30785: static void
30785: ReparentFrames(nsFrameManager* aFrameManager,
30785:                nsIFrame* aNewParentFrame,
30785:                const nsFrameList& aFrameList)
30785: {
30785:   for (nsFrameList::Enumerator e(aFrameList); !e.AtEnd(); e.Next()) {
30785:     ReparentFrame(aFrameManager, aNewParentFrame, e.get());
30785:   }
30785: }
30785: 
    1: //----------------------------------------------------------------------
 5324: //
 5324: // When inline frames get weird and have block frames in them, we
 5324: // annotate them to help us respond to incremental content changes
 5324: // more easily.
 5324: 
 5324: static inline PRBool
 5324: IsFrameSpecial(nsIFrame* aFrame)
 5324: {
 5324:   return (aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) != 0;
 5324: }
 5324: 
 5324: static nsIFrame* GetSpecialSibling(nsIFrame* aFrame)
 5324: {
 5324:   // We only store the "special sibling" annotation with the first
 5324:   // frame in the continuation chain. Walk back to find that frame now.
 5324:   aFrame = aFrame->GetFirstContinuation();
 5324: 
 5324:   void* value = aFrame->GetProperty(nsGkAtoms::IBSplitSpecialSibling);
 5324: 
 5324:   return static_cast<nsIFrame*>(value);
 5324: }
 5324: 
 5324: static nsIFrame*
19125: GetIBSplitSpecialPrevSiblingForAnonymousBlock(nsIFrame* aFrame)
 5324: {
 5324:   NS_PRECONDITION(IsFrameSpecial(aFrame) && !IsInlineFrame(aFrame),
 5324:                   "Shouldn't call this");
 5324:   
 5324:   // We only store the "special sibling" annotation with the first
 5324:   // frame in the continuation chain. Walk back to find that frame now.  
 5324:   return
 5324:     static_cast<nsIFrame*>
 5324:     (aFrame->GetFirstContinuation()->
 5324:        GetProperty(nsGkAtoms::IBSplitSpecialPrevSibling));
 5324: }
 5324: 
 5324: static nsIFrame*
25738: GetLastSpecialSibling(nsIFrame* aFrame, PRBool aIgnoreEmpty)
 5324: {
 5324:   for (nsIFrame *frame = aFrame, *next; ; frame = next) {
 5324:     next = GetSpecialSibling(frame);
25738:     if (!next ||
25738:         (aIgnoreEmpty && !next->GetFirstChild(nsnull)))
 5324:       return frame;
 5324:   }
 5324:   NS_NOTREACHED("unreachable code");
 5324:   return nsnull;
 5324: }
 5324: 
 5324: static void
 5324: SetFrameIsSpecial(nsIFrame* aFrame, nsIFrame* aSpecialSibling)
 5324: {
 5324:   NS_PRECONDITION(aFrame, "bad args!");
 5324: 
 5324:   // Mark the frame and all of its siblings as "special".
 5324:   for (nsIFrame* frame = aFrame; frame != nsnull; frame = frame->GetNextContinuation()) {
 5324:     frame->AddStateBits(NS_FRAME_IS_SPECIAL);
 5324:   }
 5324: 
 5324:   if (aSpecialSibling) {
28217:     // We should be the first continuation
28217:     NS_ASSERTION(!aFrame->GetPrevContinuation(),
28217:                  "assigning special sibling to other than first continuation!");
 5324: 
 5324:     // Store the "special sibling" (if we were given one) with the
 5324:     // first frame in the flow.
 5324:     aFrame->SetProperty(nsGkAtoms::IBSplitSpecialSibling, aSpecialSibling);
 5324:   }
 5324: }
 5324: 
 5324: static nsIFrame*
 5324: GetIBContainingBlockFor(nsIFrame* aFrame)
 5324: {
 5324:   NS_PRECONDITION(IsFrameSpecial(aFrame),
 5324:                   "GetIBContainingBlockFor() should only be called on known IB frames");
 5324: 
 5324:   // Get the first "normal" ancestor of the target frame.
 5324:   nsIFrame* parentFrame;
 5324:   do {
 5324:     parentFrame = aFrame->GetParent();
 5324: 
 5324:     if (! parentFrame) {
 5324:       NS_ERROR("no unsplit block frame in IB hierarchy");
 5324:       return aFrame;
 5324:     }
 5324: 
 5324:     // Note that we ignore non-special frames which have a pseudo on their
 5324:     // style context -- they're not the frames we're looking for!  In
 5324:     // particular, they may be hiding a real parent that _is_ special.
 5324:     if (!IsFrameSpecial(parentFrame) &&
 5324:         !parentFrame->GetStyleContext()->GetPseudoType())
 5324:       break;
 5324: 
 5324:     aFrame = parentFrame;
 5324:   } while (1);
 5324:  
 5324:   // post-conditions
 5324:   NS_ASSERTION(parentFrame, "no normal ancestor found for special frame in GetIBContainingBlockFor");
 5324:   NS_ASSERTION(parentFrame != aFrame, "parentFrame is actually the child frame - bogus reslt");
 5324: 
 5324:   return parentFrame;
 5324: }
 5324: 
 5324: //----------------------------------------------------------------------
    1: 
    1: // Block/inline frame construction logic. We maintain a few invariants here:
    1: //
    1: // 1. Block frames contain block and inline frames.
    1: //
    1: // 2. Inline frames only contain inline frames. If an inline parent has a block
    1: // child then the block child is migrated upward until it lands in a block
    1: // parent (the inline frames containing block is where it will end up).
    1: 
30789: // After this function returns, aLink is pointing to the first link at or
30789: // after its starting position for which the next frame is a block.  If there
30789: // is no such link, it points to the end of the list.
30789: static void
30789: FindFirstBlock(nsFrameList::FrameLinkEnumerator& aLink)
30789: {
30789:   for ( ; !aLink.AtEnd(); aLink.Next()) {
30789:     if (!IsInlineOutside(aLink.NextFrame())) {
30789:       return;
30789:     }
30789:   }
30789: }
30789: 
30789: // This function returns an frame link enumerator pointing to the last link in
30789: // the list which has a block prev frame.  This means the enumerator might be
30789: // at end.  If there are no blocks at all, the returned enumerator will point
30789: // to the beginning of the list.
30789: static nsFrameList::FrameLinkEnumerator
30789: FindLastBlock(const nsFrameList& aList)
30789: {
30789:   nsFrameList::FrameLinkEnumerator cur(aList), last(aList);
30789:   for ( ; !cur.AtEnd(); cur.Next()) {
30789:     if (!IsInlineOutside(cur.NextFrame())) {
30789:       last = cur;
30789:       last.Next();
30789:     }
30789:   }
30789: 
30789:   return last;
    1: }
    1: 
    1: /*
19125:  * The special-prev-sibling is useful for
    1:  * finding the "special parent" of a frame (i.e., a frame from which a
    1:  * good parent style context can be obtained), one looks at the
    1:  * special previous sibling annotation of the real parent of the frame
    1:  * (if the real parent has NS_FRAME_IS_SPECIAL).
    1:  */
    1: inline void
 5324: MarkIBSpecialPrevSibling(nsIFrame *aAnonymousFrame,
    1:                          nsIFrame *aSpecialParent)
    1: {
 5324:   aAnonymousFrame->SetProperty(nsGkAtoms::IBSplitSpecialPrevSibling,
    1:                                aSpecialParent, nsnull, nsnull);
    1: }
    1: 
30790: inline void
30790: SetInitialSingleChild(nsIFrame* aParent, nsIFrame* aFrame)
30790: {
30790:   NS_PRECONDITION(!aFrame->GetNextSibling(), "Should be using a frame list");
32846:   nsFrameList temp(aFrame, aFrame);
30790:   aParent->SetInitialChildList(nsnull, temp);
30790: }
30790: 
    1: // -----------------------------------------------------------
    1: 
 8406: static PRBool
 8406: IsOutOfFlowList(nsIAtom* aListName)
 8406: {
 8406:   return
 8406:     aListName == nsGkAtoms::floatList ||
 8406:     aListName == nsGkAtoms::absoluteList ||
 8406:     aListName == nsGkAtoms::overflowOutOfFlowList ||
 8406:     aListName == nsGkAtoms::fixedList;
 8406: }
 8406: 
    1: // Helper function that recursively removes content to frame mappings and
    1: // undisplayed content mappings.
    1: // This differs from DeletingFrameSubtree() because the frames have not yet been
    1: // added to the frame hierarchy.
    1: // XXXbz it would really help if we merged the two methods somehow... :(
    1: static void
    1: DoCleanupFrameReferences(nsFrameManager*  aFrameManager,
    1:                          nsIFrame*        aFrameIn)
    1: {
    1:   nsIContent* content = aFrameIn->GetContent();
    1: 
    1:   if (aFrameIn->GetType() == nsGkAtoms::placeholderFrame) {
 3233:     nsPlaceholderFrame* placeholder = static_cast<nsPlaceholderFrame*>
 3233:                                                  (aFrameIn);
    1:     // if the frame is a placeholder use the out of flow frame
    1:     aFrameIn = nsPlaceholderFrame::GetRealFrameForPlaceholder(placeholder);
    1: 
    1:     // And don't forget to unregister the placeholder mapping.  Note that this
    1:     // means it's the caller's responsibility to actually destroy the
    1:     // out-of-flow pointed to by the placeholder, since after this point the
    1:     // out-of-flow is not reachable via the placeholder.
    1:     aFrameManager->UnregisterPlaceholderFrame(placeholder);
    1:   }
    1: 
    1:   // Remove the mapping from the content object to its frame
    1:   aFrameManager->RemoveAsPrimaryFrame(content, aFrameIn);
    1:   aFrameManager->ClearAllUndisplayedContentIn(content);
    1: 
    1:   // Recursively walk the child frames.
    1:   nsIAtom* childListName = nsnull;
    1:   PRInt32 childListIndex = 0;
    1:   do {
    1:     nsIFrame* childFrame = aFrameIn->GetFirstChild(childListName);
    1:     while (childFrame) {
    1:       DoCleanupFrameReferences(aFrameManager, childFrame);
    1:     
    1:       // Get the next sibling child frame
    1:       childFrame = childFrame->GetNextSibling();
    1:     }
    1: 
    1:     childListName = aFrameIn->GetAdditionalChildListName(childListIndex++);
    1:   } while (childListName);
    1: }
    1: 
    1: // Helper function that walks a frame list and calls DoCleanupFrameReference()
    1: static void
    1: CleanupFrameReferences(nsFrameManager*  aFrameManager,
30785:                        const nsFrameList& aFrameList)
30785: {
30785:   for (nsFrameList::Enumerator e(aFrameList); !e.AtEnd(); e.Next()) {
30785:     DoCleanupFrameReferences(aFrameManager, e.get());
    1:   }
    1: }
    1: 
    1: // -----------------------------------------------------------
    1: 
32843: // Structure used when constructing formatting object trees.
32843: struct nsFrameItems : public nsFrameList
32843: {
32843:   // Appends the frame to the end of the list
32843:   void AddChild(nsIFrame* aChild);
32843: };
    1: 
    1: void 
    1: nsFrameItems::AddChild(nsIFrame* aChild)
    1: {
32843:   NS_PRECONDITION(aChild, "nsFrameItems::AddChild");
32843: 
32843:   // It'd be really nice if we could just AppendFrames(nsnull, aChild) here,
32843:   // but some of our callers put frames that have different
30785:   // parents (caption, I'm looking at you) on the same framelist, and
30785:   // nsFrameList asserts if you try to do that.
30785:   if (IsEmpty()) {
32843:     SetFrames(aChild);
32843:   }
32843:   else {
32843:     NS_ASSERTION(aChild != mLastChild,
    1:                  "Same frame being added to frame list twice?");
32843:     mLastChild->SetNextSibling(aChild);
32843:     mLastChild = nsLayoutUtils::GetLastSibling(aChild);
32843:   }
    1: }
    1: 
    1: // -----------------------------------------------------------
    1: 
    1: // Structure used when constructing formatting object trees. Contains
    1: // state information needed for absolutely positioned elements
    1: struct nsAbsoluteItems : nsFrameItems {
    1:   // containing block for absolutely positioned elements
    1:   nsIFrame* containingBlock;
    1:   
    1:   nsAbsoluteItems(nsIFrame* aContainingBlock);
    1: #ifdef DEBUG
    1:   // XXXbz Does this need a debug-only assignment operator that nulls out the
    1:   // childList in the nsAbsoluteItems we're copying?  Introducing a difference
    1:   // between debug and non-debug behavior seems bad, so I guess not...
    1:   ~nsAbsoluteItems() {
30785:     NS_ASSERTION(!FirstChild(),
    1:                  "Dangling child list.  Someone forgot to insert it?");
    1:   }
    1: #endif
    1:   
    1:   // Appends the frame to the end of the list
    1:   void AddChild(nsIFrame* aChild);
    1: };
    1: 
    1: nsAbsoluteItems::nsAbsoluteItems(nsIFrame* aContainingBlock)
    1:   : containingBlock(aContainingBlock)
    1: {
    1: }
    1: 
    1: // Additional behavior is that it sets the frame's NS_FRAME_OUT_OF_FLOW flag
    1: void
    1: nsAbsoluteItems::AddChild(nsIFrame* aChild)
    1: {
  238:   NS_ASSERTION(aChild->PresContext()->FrameManager()->
    1:                GetPlaceholderFrameFor(aChild),
    1:                "Child without placeholder being added to nsAbsoluteItems?");
    1:   aChild->AddStateBits(NS_FRAME_OUT_OF_FLOW);
    1:   nsFrameItems::AddChild(aChild);
    1: }
    1: 
    1: // -----------------------------------------------------------
    1: 
    1: // Structure for saving the existing state when pushing/poping containing
    1: // blocks. The destructor restores the state to its previous state
25768: class NS_STACK_CLASS nsFrameConstructorSaveState {
    1: public:
    1:   nsFrameConstructorSaveState();
    1:   ~nsFrameConstructorSaveState();
    1: 
    1: private:
    1:   nsAbsoluteItems* mItems;                // pointer to struct whose data we save/restore
25768:   PRPackedBool*    mFixedPosIsAbsPos;
    1: 
    1:   nsAbsoluteItems  mSavedItems;           // copy of original data
25768:   PRPackedBool     mSavedFixedPosIsAbsPos;
    1: 
    1:   // The name of the child list in which our frames would belong
    1:   nsIAtom* mChildListName;
    1:   nsFrameConstructorState* mState;
    1: 
    1:   friend class nsFrameConstructorState;
    1: };
    1: 
    1: // Structure used for maintaining state information during the
    1: // frame construction process
15599: class NS_STACK_CLASS nsFrameConstructorState {
    1: public:
    1:   nsPresContext            *mPresContext;
    1:   nsIPresShell             *mPresShell;
    1:   nsFrameManager           *mFrameManager;
    1: 
    1: #ifdef MOZ_XUL
    1:   // Frames destined for the nsGkAtoms::popupList.
    1:   nsAbsoluteItems           mPopupItems;
    1: #endif
    1: 
    1:   // Containing block information for out-of-flow frames.
    1:   nsAbsoluteItems           mFixedItems;
    1:   nsAbsoluteItems           mAbsoluteItems;
    1:   nsAbsoluteItems           mFloatedItems;
19214: 
28329:   nsCOMPtr<nsILayoutHistoryState> mFrameState;
28329:   // These bits will be added to the state bits of any frame we construct
28329:   // using this state.
28329:   nsFrameState              mAdditionalStateBits;
28329: 
19214:   // When working with the -moz-transform property, we want to hook
19214:   // the abs-pos and fixed-pos lists together, since transformed
19214:   // elements are fixed-pos containing blocks.  This flag determines
19214:   // whether or not we want to wire the fixed-pos and abs-pos lists
19214:   // together.
25768:   PRPackedBool              mFixedPosIsAbsPos;
25768: 
25768:   // A boolean to indicate whether we have a "pending" popupgroup.  That is, we
25768:   // have already created the FrameConstructionItem for the root popupgroup but
25768:   // we have not yet created the relevant frame.
25768:   PRPackedBool              mHavePendingPopupgroup;
19214: 
31438:   nsCOMArray<nsIContent>    mGeneratedTextNodesWithInitializer;
31438: 
    1:   // Constructor
    1:   // Use the passed-in history state.
    1:   nsFrameConstructorState(nsIPresShell*          aPresShell,
    1:                           nsIFrame*              aFixedContainingBlock,
    1:                           nsIFrame*              aAbsoluteContainingBlock,
    1:                           nsIFrame*              aFloatContainingBlock,
    1:                           nsILayoutHistoryState* aHistoryState);
    1:   // Get the history state from the pres context's pres shell.
    1:   nsFrameConstructorState(nsIPresShell*          aPresShell,
    1:                           nsIFrame*              aFixedContainingBlock,
    1:                           nsIFrame*              aAbsoluteContainingBlock,
    1:                           nsIFrame*              aFloatContainingBlock);
    1: 
    1:   ~nsFrameConstructorState();
    1:   
    1:   // Function to push the existing absolute containing block state and
    1:   // create a new scope. Code that uses this function should get matching
    1:   // logic in GetAbsoluteContainingBlock.
    1:   void PushAbsoluteContainingBlock(nsIFrame* aNewAbsoluteContainingBlock,
    1:                                    nsFrameConstructorSaveState& aSaveState);
    1: 
    1:   // Function to push the existing float containing block state and
    1:   // create a new scope. Code that uses this function should get matching
    1:   // logic in GetFloatContainingBlock.
    1:   // Pushing a null float containing block forbids any frames from being
    1:   // floated until a new float containing block is pushed.
    1:   // XXX we should get rid of null float containing blocks and teach the
    1:   // various frame classes to deal with floats instead.
    1:   void PushFloatContainingBlock(nsIFrame* aNewFloatContainingBlock,
23352:                                 nsFrameConstructorSaveState& aSaveState);
    1: 
    1:   // Function to return the proper geometric parent for a frame with display
    1:   // struct given by aStyleDisplay and parent's frame given by
23944:   // aContentParentFrame.
    1:   nsIFrame* GetGeometricParent(const nsStyleDisplay* aStyleDisplay,
    1:                                nsIFrame* aContentParentFrame);
    1: 
    1:   /**
    1:    * Function to add a new frame to the right frame list.  This MUST be called
    1:    * on frames before their children have been processed if the frames might
    1:    * conceivably be out-of-flow; otherwise cleanup in error cases won't work
    1:    * right.  Also, this MUST be called on frames after they have been
    1:    * initialized.
    1:    * @param aNewFrame the frame to add
    1:    * @param aFrameItems the list to add in-flow frames to
    1:    * @param aContent the content pointer for aNewFrame
 7807:    * @param aStyleContext the style context resolved for aContent
    1:    * @param aParentFrame the parent frame for the content if it were in-flow
    1:    * @param aCanBePositioned pass false if the frame isn't allowed to be
    1:    *        positioned
    1:    * @param aCanBeFloated pass false if the frame isn't allowed to be
    1:    *        floated
    1:    * @param aIsOutOfFlowPopup pass true if the frame is an out-of-flow popup
    1:    *        (XUL-only)
    1:    * @throws NS_ERROR_OUT_OF_MEMORY if it happens.
    1:    * @note If this method throws, that means that aNewFrame was not inserted
    1:    *       into any frame lists.  Furthermore, this method will handle cleanup
    1:    *       of aNewFrame (via calling CleanupFrameReferences() and Destroy() on
    1:    *       it).
    1:    */
    1:   nsresult AddChild(nsIFrame* aNewFrame,
    1:                     nsFrameItems& aFrameItems,
    1:                     nsIContent* aContent,
    1:                     nsStyleContext* aStyleContext,
    1:                     nsIFrame* aParentFrame,
    1:                     PRBool aCanBePositioned = PR_TRUE,
    1:                     PRBool aCanBeFloated = PR_TRUE,
    1:                     PRBool aIsOutOfFlowPopup = PR_FALSE,
    1:                     PRBool aInsertAfter = PR_FALSE,
    1:                     nsIFrame* aInsertAfterFrame = nsnull);
    1: 
19214:   /**
19214:    * Function to return the fixed-pos element list.  Normally this will just hand back the
19214:    * fixed-pos element list, but in case we're dealing with a transformed element that's
19214:    * acting as an abs-pos and fixed-pos container, we'll hand back the abs-pos list.  Callers should
19214:    * use this function if they want to get the list acting as the fixed-pos item parent.
19214:    */
19214:   nsAbsoluteItems& GetFixedItems()
19214:   {
19214:     return mFixedPosIsAbsPos ? mAbsoluteItems : mFixedItems;
19214:   }
19214:   const nsAbsoluteItems& GetFixedItems() const
19214:   {
19214:     return mFixedPosIsAbsPos ? mAbsoluteItems : mFixedItems;
19214:   }
19214: 
    1: protected:
    1:   friend class nsFrameConstructorSaveState;
    1: 
    1:   /**
    1:    * ProcessFrameInsertions takes the frames in aFrameItems and adds them as
    1:    * kids to the aChildListName child list of |aFrameItems.containingBlock|.
    1:    */
    1:   void ProcessFrameInsertions(nsAbsoluteItems& aFrameItems,
    1:                               nsIAtom* aChildListName);
    1: };
    1: 
    1: nsFrameConstructorState::nsFrameConstructorState(nsIPresShell*          aPresShell,
    1:                                                  nsIFrame*              aFixedContainingBlock,
    1:                                                  nsIFrame*              aAbsoluteContainingBlock,
    1:                                                  nsIFrame*              aFloatContainingBlock,
    1:                                                  nsILayoutHistoryState* aHistoryState)
    1:   : mPresContext(aPresShell->GetPresContext()),
    1:     mPresShell(aPresShell),
    1:     mFrameManager(aPresShell->FrameManager()),
    1: #ifdef MOZ_XUL    
23951:     mPopupItems(nsnull),
    1: #endif
    1:     mFixedItems(aFixedContainingBlock),
    1:     mAbsoluteItems(aAbsoluteContainingBlock),
    1:     mFloatedItems(aFloatContainingBlock),
22341:     // See PushAbsoluteContaningBlock below
28329:     mFrameState(aHistoryState),
28329:     mAdditionalStateBits(0),
22341:     mFixedPosIsAbsPos(aAbsoluteContainingBlock &&
22341:                       aAbsoluteContainingBlock->GetStyleDisplay()->
22341:                         HasTransform()),
28329:     mHavePendingPopupgroup(PR_FALSE)
    1: {
23951: #ifdef MOZ_XUL
23951:   nsIRootBox* rootBox = nsIRootBox::GetRootBox(aPresShell);
23951:   if (rootBox) {
23951:     mPopupItems.containingBlock = rootBox->GetPopupSetFrame();
23951:   }
23951: #endif
 5327:   MOZ_COUNT_CTOR(nsFrameConstructorState);
    1: }
    1: 
    1: nsFrameConstructorState::nsFrameConstructorState(nsIPresShell* aPresShell,
    1:                                                  nsIFrame*     aFixedContainingBlock,
    1:                                                  nsIFrame*     aAbsoluteContainingBlock,
    1:                                                  nsIFrame*     aFloatContainingBlock)
    1:   : mPresContext(aPresShell->GetPresContext()),
    1:     mPresShell(aPresShell),
    1:     mFrameManager(aPresShell->FrameManager()),
    1: #ifdef MOZ_XUL    
23951:     mPopupItems(nsnull),
    1: #endif
    1:     mFixedItems(aFixedContainingBlock),
    1:     mAbsoluteItems(aAbsoluteContainingBlock),
    1:     mFloatedItems(aFloatContainingBlock),
22341:     // See PushAbsoluteContaningBlock below
28329:     mAdditionalStateBits(0),
22341:     mFixedPosIsAbsPos(aAbsoluteContainingBlock &&
22341:                       aAbsoluteContainingBlock->GetStyleDisplay()->
22341:                         HasTransform()),
28329:     mHavePendingPopupgroup(PR_FALSE)
    1: {
23951: #ifdef MOZ_XUL
23951:   nsIRootBox* rootBox = nsIRootBox::GetRootBox(aPresShell);
23951:   if (rootBox) {
23951:     mPopupItems.containingBlock = rootBox->GetPopupSetFrame();
23951:   }
23951: #endif
 5327:   MOZ_COUNT_CTOR(nsFrameConstructorState);
    1:   mFrameState = aPresShell->GetDocument()->GetLayoutHistoryState();
    1: }
    1: 
    1: nsFrameConstructorState::~nsFrameConstructorState()
    1: {
    1:   // Frame order comparison functions only work properly when the placeholders
    1:   // have been inserted into the frame tree. So for example if we have a new float
    1:   // containing the placeholder for a new abs-pos frame, and we process the abs-pos
    1:   // insertion first, then we won't be able to find the right place to insert in
    1:   // in the abs-pos list. So put floats in first, because they can contain placeholders
    1:   // for abs-pos and fixed-pos items whose containing blocks are outside the floats.
    1:   // Then put abs-pos frames in, because they can contain placeholders for fixed-pos
    1:   // items whose containing block is outside the abs-pos frames. 
 5327:   MOZ_COUNT_DTOR(nsFrameConstructorState);
    1:   ProcessFrameInsertions(mFloatedItems, nsGkAtoms::floatList);
    1:   ProcessFrameInsertions(mAbsoluteItems, nsGkAtoms::absoluteList);
    1:   ProcessFrameInsertions(mFixedItems, nsGkAtoms::fixedList);
    1: #ifdef MOZ_XUL
    1:   ProcessFrameInsertions(mPopupItems, nsGkAtoms::popupList);
    1: #endif
31438:   for (PRInt32 i = mGeneratedTextNodesWithInitializer.Count() - 1; i >= 0; --i) {
31438:     mGeneratedTextNodesWithInitializer[i]->
31438:       DeleteProperty(nsGkAtoms::genConInitializerProperty);
31438:   }
    1: }
    1: 
    1: static nsIFrame*
 7680: AdjustAbsoluteContainingBlock(nsIFrame* aContainingBlockIn)
    1: {
    1:   if (!aContainingBlockIn) {
    1:     return nsnull;
    1:   }
    1:   
 7680:   // Always use the container's first continuation. (Inline frames can have
 7680:   // non-fluid bidi continuations...)
 7680:   return aContainingBlockIn->GetFirstContinuation();
    1: }
    1: 
    1: void
    1: nsFrameConstructorState::PushAbsoluteContainingBlock(nsIFrame* aNewAbsoluteContainingBlock,
    1:                                                      nsFrameConstructorSaveState& aSaveState)
    1: {
    1:   aSaveState.mItems = &mAbsoluteItems;
    1:   aSaveState.mSavedItems = mAbsoluteItems;
    1:   aSaveState.mChildListName = nsGkAtoms::absoluteList;
    1:   aSaveState.mState = this;
19214: 
19214:   /* Store whether we're wiring the abs-pos and fixed-pos lists together. */
19214:   aSaveState.mFixedPosIsAbsPos = &mFixedPosIsAbsPos;
19214:   aSaveState.mSavedFixedPosIsAbsPos = mFixedPosIsAbsPos;
19214: 
    1:   mAbsoluteItems = 
 7680:     nsAbsoluteItems(AdjustAbsoluteContainingBlock(aNewAbsoluteContainingBlock));
19214: 
19214:   /* See if we're wiring the fixed-pos and abs-pos lists together.  This happens iff
19214:    * we're a transformed element.
19214:    */
19214:   mFixedPosIsAbsPos = (aNewAbsoluteContainingBlock &&
19214:                        aNewAbsoluteContainingBlock->GetStyleDisplay()->HasTransform());
    1: }
    1: 
    1: void
    1: nsFrameConstructorState::PushFloatContainingBlock(nsIFrame* aNewFloatContainingBlock,
23352:                                                   nsFrameConstructorSaveState& aSaveState)
23352: {
    1:   NS_PRECONDITION(!aNewFloatContainingBlock ||
23352:                   aNewFloatContainingBlock->IsFloatContainingBlock(),
    1:                   "Please push a real float containing block!");
    1:   aSaveState.mItems = &mFloatedItems;
    1:   aSaveState.mSavedItems = mFloatedItems;
    1:   aSaveState.mChildListName = nsGkAtoms::floatList;
    1:   aSaveState.mState = this;
    1:   mFloatedItems = nsAbsoluteItems(aNewFloatContainingBlock);
    1: }
    1: 
    1: nsIFrame*
    1: nsFrameConstructorState::GetGeometricParent(const nsStyleDisplay* aStyleDisplay,
    1:                                             nsIFrame* aContentParentFrame)
    1: {
    1:   NS_PRECONDITION(aStyleDisplay, "Must have display struct!");
    1: 
    1:   // If there is no container for a fixed, absolute, or floating root
    1:   // frame, we will ignore the positioning.  This hack is originally
    1:   // brought to you by the letter T: tables, since other roots don't
    1:   // even call into this code.  See bug 178855.
    1:   //
    1:   // XXX Disabling positioning in this case is a hack.  If one was so inclined,
    1:   // one could support this either by (1) inserting a dummy block between the
    1:   // table and the canvas or (2) teaching the canvas how to reflow positioned
    1:   // elements. (1) has the usual problems when multiple frames share the same
    1:   // content (notice all the special cases in this file dealing with inner
    1:   // tables and outer tables which share the same content). (2) requires some
    1:   // work and possible factoring.
    1:   //
    1:   // XXXbz couldn't we just force position to "static" on roots and
    1:   // float to "none"?  That's OK per CSS 2.1, as far as I can tell.
    1:   
    1:   if (aStyleDisplay->IsFloating() && mFloatedItems.containingBlock) {
    1:     NS_ASSERTION(!aStyleDisplay->IsAbsolutelyPositioned(),
    1:                  "Absolutely positioned _and_ floating?");
    1:     return mFloatedItems.containingBlock;
    1:   }
    1: 
    1:   if (aStyleDisplay->mPosition == NS_STYLE_POSITION_ABSOLUTE &&
    1:       mAbsoluteItems.containingBlock) {
    1:     return mAbsoluteItems.containingBlock;
    1:   }
    1: 
    1:   if (aStyleDisplay->mPosition == NS_STYLE_POSITION_FIXED &&
19214:       GetFixedItems().containingBlock) {
19214:     return GetFixedItems().containingBlock;
    1:   }
    1: 
    1:   return aContentParentFrame;
    1: }
    1: 
    1: nsresult
    1: nsFrameConstructorState::AddChild(nsIFrame* aNewFrame,
    1:                                   nsFrameItems& aFrameItems,
    1:                                   nsIContent* aContent,
    1:                                   nsStyleContext* aStyleContext,
    1:                                   nsIFrame* aParentFrame,
    1:                                   PRBool aCanBePositioned,
    1:                                   PRBool aCanBeFloated,
    1:                                   PRBool aIsOutOfFlowPopup,
    1:                                   PRBool aInsertAfter,
    1:                                   nsIFrame* aInsertAfterFrame)
    1: {
30785:   NS_PRECONDITION(!aNewFrame->GetNextSibling(), "Shouldn't happen");
30785:   
 8199:   const nsStyleDisplay* disp = aNewFrame->GetStyleDisplay();
 7807:   
    1:   // The comments in GetGeometricParent regarding root table frames
    1:   // all apply here, unfortunately.
    1: 
    1:   PRBool needPlaceholder = PR_FALSE;
    1:   nsFrameItems* frameItems = &aFrameItems;
    1: #ifdef MOZ_XUL
    1:   if (NS_UNLIKELY(aIsOutOfFlowPopup)) {
    1:       NS_ASSERTION(aNewFrame->GetParent() == mPopupItems.containingBlock,
    1:                    "Popup whose parent is not the popup containing block?");
    1:       NS_ASSERTION(mPopupItems.containingBlock, "Must have a popup set frame!");
    1:       needPlaceholder = PR_TRUE;
    1:       frameItems = &mPopupItems;
    1:   }
    1:   else
    1: #endif // MOZ_XUL
 8199:   if (aCanBeFloated && disp->IsFloating() &&
    1:       mFloatedItems.containingBlock) {
    1:     NS_ASSERTION(aNewFrame->GetParent() == mFloatedItems.containingBlock,
    1:                  "Float whose parent is not the float containing block?");
    1:     needPlaceholder = PR_TRUE;
    1:     frameItems = &mFloatedItems;
    1:   }
    1:   else if (aCanBePositioned) {
 8199:     if (disp->mPosition == NS_STYLE_POSITION_ABSOLUTE &&
    1:         mAbsoluteItems.containingBlock) {
    1:       NS_ASSERTION(aNewFrame->GetParent() == mAbsoluteItems.containingBlock,
    1:                    "Abs pos whose parent is not the abs pos containing block?");
    1:       needPlaceholder = PR_TRUE;
    1:       frameItems = &mAbsoluteItems;
    1:     }
 8199:     if (disp->mPosition == NS_STYLE_POSITION_FIXED &&
19214:         GetFixedItems().containingBlock) {
19214:       NS_ASSERTION(aNewFrame->GetParent() == GetFixedItems().containingBlock,
    1:                    "Fixed pos whose parent is not the fixed pos containing block?");
    1:       needPlaceholder = PR_TRUE;
19214:       frameItems = &GetFixedItems();
    1:     }
    1:   }
    1: 
    1:   if (needPlaceholder) {
    1:     NS_ASSERTION(frameItems != &aFrameItems,
    1:                  "Putting frame in-flow _and_ want a placeholder?");
    1:     nsIFrame* placeholderFrame;
    1:     nsresult rv =
    1:       nsCSSFrameConstructor::CreatePlaceholderFrameFor(mPresShell,
    1:                                                        aContent,
    1:                                                        aNewFrame,
    1:                                                        aStyleContext,
    1:                                                        aParentFrame,
 6219:                                                        nsnull,
    1:                                                        &placeholderFrame);
    1:     if (NS_FAILED(rv)) {
    1:       // Note that aNewFrame could be the top frame for a scrollframe setup,
    1:       // hence already set as the primary frame.  So we have to clean up here.
    1:       // But it shouldn't have any out-of-flow kids.
    1:       // XXXbz Maybe add a utility function to assert that?
30785:       DoCleanupFrameReferences(mFrameManager, aNewFrame);
    1:       aNewFrame->Destroy();
    1:       return rv;
    1:     }
    1: 
16976:     placeholderFrame->AddStateBits(mAdditionalStateBits);
    1:     // Add the placeholder frame to the flow
    1:     aFrameItems.AddChild(placeholderFrame);
    1:   }
    1: #ifdef DEBUG
    1:   else {
    1:     NS_ASSERTION(aNewFrame->GetParent() == aParentFrame,
    1:                  "In-flow frame has wrong parent");
    1:   }
    1: #endif
    1: 
    1:   if (aInsertAfter) {
30785:     frameItems->InsertFrame(nsnull, aInsertAfterFrame, aNewFrame);
    1:   } else {
    1:     frameItems->AddChild(aNewFrame);
    1:   }
    1: 
    1:   // Now add the special siblings too.
    1:   nsIFrame* specialSibling = aNewFrame;
    1:   while (specialSibling && IsFrameSpecial(specialSibling)) {
 4696:     specialSibling = GetSpecialSibling(specialSibling);
    1:     if (specialSibling) {
    1:       NS_ASSERTION(frameItems == &aFrameItems,
    1:                    "IB split ending up in an out-of-flow childlist?");
    1:       frameItems->AddChild(specialSibling);
    1:     }
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsFrameConstructorState::ProcessFrameInsertions(nsAbsoluteItems& aFrameItems,
    1:                                                 nsIAtom* aChildListName)
    1: {
    1: #define NS_NONXUL_LIST_TEST (&aFrameItems == &mFloatedItems &&             \
    1:                              aChildListName == nsGkAtoms::floatList)    || \
    1:                             (&aFrameItems == &mAbsoluteItems &&            \
    1:                              aChildListName == nsGkAtoms::absoluteList) || \
    1:                             (&aFrameItems == &mFixedItems &&               \
    1:                              aChildListName == nsGkAtoms::fixedList)
    1: #ifdef MOZ_XUL
    1:   NS_PRECONDITION(NS_NONXUL_LIST_TEST ||
    1:                   (&aFrameItems == &mPopupItems &&
    1:                    aChildListName == nsGkAtoms::popupList), 
    1:                   "Unexpected aFrameItems/aChildListName combination");
    1: #else
    1:   NS_PRECONDITION(NS_NONXUL_LIST_TEST,
    1:                   "Unexpected aFrameItems/aChildListName combination");
    1: #endif
    1: 
30785:   if (aFrameItems.IsEmpty()) {
    1:     return;
    1:   }
    1:   
    1:   nsIFrame* containingBlock = aFrameItems.containingBlock;
    1: 
    1:   NS_ASSERTION(containingBlock,
    1:                "Child list without containing block?");
    1:   
    1:   // Insert the frames hanging out in aItems.  We can use SetInitialChildList()
30710:   // if the containing block hasn't been reflowed yet (so NS_FRAME_FIRST_REFLOW
    1:   // is set) and doesn't have any frames in the aChildListName child list yet.
30785:   const nsFrameList& childList = containingBlock->GetChildList(aChildListName);
    1:   nsresult rv = NS_OK;
30785:   if (childList.IsEmpty() &&
30785:       (containingBlock->GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
30785:     rv = containingBlock->SetInitialChildList(aChildListName, aFrameItems);
    1:   } else {
    1:     // Note that whether the frame construction context is doing an append or
    1:     // not is not helpful here, since it could be appending to some frame in
    1:     // the middle of the document, which means we're not necessarily
    1:     // appending to the children of the containing block.
    1:     //
    1:     // We need to make sure the 'append to the end of document' case is fast.
    1:     // So first test the last child of the containing block
30785:     nsIFrame* lastChild = childList.LastChild();
    1: 
    1:     // CompareTreePosition uses placeholder hierarchy for out of flow frames,
    1:     // so this will make out-of-flows respect the ordering of placeholders,
    1:     // which is great because it takes care of anonymous content.
30785:     nsIFrame* firstNewFrame = aFrameItems.FirstChild();  
    1:     if (!lastChild ||
    1:         nsLayoutUtils::CompareTreePosition(lastChild, firstNewFrame, containingBlock) < 0) {
32843:       // no lastChild, or lastChild comes before the new children, so just append
32843:       rv = containingBlock->AppendFrames(aChildListName, aFrameItems);
    1:     } else {
    1:       // try the other children
32843:       nsIFrame* insertionPoint = nsnull;
30785:       for (nsIFrame* f = childList.FirstChild(); f != lastChild;
30785:            f = f->GetNextSibling()) {
    1:         PRInt32 compare =
    1:           nsLayoutUtils::CompareTreePosition(f, firstNewFrame, containingBlock);
    1:         if (compare > 0) {
    1:           // f comes after the new children, so stop here and insert after
    1:           // the previous frame
    1:           break;
    1:         }
    1:         insertionPoint = f;
    1:       }
    1:       rv = containingBlock->InsertFrames(aChildListName, insertionPoint,
30941:                                          aFrameItems);
30790:     }
32843:   }
30790: 
30790:   NS_POSTCONDITION(aFrameItems.IsEmpty(), "How did that happen?");
30790: 
    1:   // XXXbz And if NS_FAILED(rv), what?  I guess we need to clean up the list
    1:   // and deal with all the placeholders... but what if the placeholders aren't
    1:   // in the document yet?  Could that happen?
    1:   NS_ASSERTION(NS_SUCCEEDED(rv), "Frames getting lost!");
    1: }
    1: 
    1: 
    1: nsFrameConstructorSaveState::nsFrameConstructorSaveState()
    1:   : mItems(nsnull),
19214:     mFixedPosIsAbsPos(nsnull),
    1:     mSavedItems(nsnull),
19214:     mSavedFixedPosIsAbsPos(PR_FALSE),
    1:     mChildListName(nsnull),
    1:     mState(nsnull)
    1: {
    1: }
    1: 
    1: nsFrameConstructorSaveState::~nsFrameConstructorSaveState()
    1: {
    1:   // Restore the state
    1:   if (mItems) {
    1:     NS_ASSERTION(mState, "Can't have mItems set without having a state!");
    1:     mState->ProcessFrameInsertions(*mItems, mChildListName);
    1:     *mItems = mSavedItems;
    1: #ifdef DEBUG
    1:     // We've transferred the child list, so drop the pointer we held to it.
    1:     // Note that this only matters for the assert in ~nsAbsoluteItems.
30785:     mSavedItems.Clear();
    1: #endif
    1:   }
19214:   if (mFixedPosIsAbsPos) {
19214:     *mFixedPosIsAbsPos = mSavedFixedPosIsAbsPos;
19214:   }
    1: }
    1: 
    1: static 
    1: PRBool IsBorderCollapse(nsIFrame* aFrame)
    1: {
    1:   for (nsIFrame* frame = aFrame; frame; frame = frame->GetParent()) {
    1:     if (nsGkAtoms::tableFrame == frame->GetType()) {
    1:       return ((nsTableFrame*)frame)->IsBorderCollapse();
    1:     }
    1:   }
    1:   NS_ASSERTION(PR_FALSE, "program error");
    1:   return PR_FALSE;
    1: }
    1: 
    1: /**
    1:  * Utility method, called from MoveChildrenTo(), that recursively
    1:  * descends down the frame hierarchy looking for floating frames that
    1:  * need parent pointer adjustments to account for the containment block
    1:  * changes that could occur as the result of the reparenting done in
    1:  * MoveChildrenTo().
    1:  */
    1: static void
    1: AdjustFloatParentPtrs(nsIFrame*                aFrame,
    1:                       nsFrameConstructorState& aState,
    1:                       nsFrameConstructorState& aOuterState)
    1: {
    1:   NS_PRECONDITION(aFrame, "must have frame to work with");
    1: 
    1:   nsIFrame *outOfFlowFrame = nsPlaceholderFrame::GetRealFrameFor(aFrame);
    1:   if (outOfFlowFrame != aFrame) {
    1:     if (outOfFlowFrame->GetStyleDisplay()->IsFloating()) {
    1:       // Update the parent pointer for outOfFlowFrame since its
    1:       // containing block has changed as the result of reparenting
    1:       // and move it from the outer state to the inner, bug 307277.
    1:       
    1:       nsIFrame *parent = aState.mFloatedItems.containingBlock;
    1:       NS_ASSERTION(parent, "Should have float containing block here!");
    1:       NS_ASSERTION(outOfFlowFrame->GetParent() == aOuterState.mFloatedItems.containingBlock,
    1:                    "expected the float to be a child of the outer CB");
    1: 
32844:       aOuterState.mFloatedItems.RemoveFrame(outOfFlowFrame);
    1:       aState.mFloatedItems.AddChild(outOfFlowFrame);
    1: 
    1:       outOfFlowFrame->SetParent(parent);
    1:       if (outOfFlowFrame->GetStateBits() &
    1:           (NS_FRAME_HAS_VIEW | NS_FRAME_HAS_CHILD_WITH_VIEW)) {
    1:         // We don't need to walk up the tree, since we're doing this
    1:         // recursively.
    1:         parent->AddStateBits(NS_FRAME_HAS_CHILD_WITH_VIEW);
    1:       }
    1:     }
    1: 
    1:     // All out-of-flows are automatically float containing blocks, so we're
    1:     // done here.
    1:     return;
    1:   }
    1: 
    1:   if (aFrame->IsFloatContainingBlock()) {
    1:     // No need to recurse further; floats whose placeholders are
    1:     // inside a block already have the right parent.
    1:     return;
    1:   }
    1: 
    1:   // Dive down into children to see if any of their
    1:   // placeholders need adjusting.
    1:   nsIFrame *childFrame = aFrame->GetFirstChild(nsnull);
    1:   while (childFrame) {
    1:     // XXX_kin: Do we need to prevent descent into anonymous content here?
    1: 
    1:     AdjustFloatParentPtrs(childFrame, aState, aOuterState);
    1:     childFrame = childFrame->GetNextSibling();
    1:   }
    1: }
    1: 
    1: /**
 4696:  * Moves frames to a new parent, updating the style context and propagating
 4696:  * relevant frame state bits. |aState| may be null, in which case the parent
    1:  * pointers of out-of-flow frames will remain untouched.
    1:  */
30790: // XXXbz it would be nice if this could take a framelist-like thing, but it
30790: // would need to take some sort of sublist, not nsFrameList, since the frames
30790: // get inserted into their new home before we call this method.  This could
30790: // easily take an nsFrameList::Slice if SetInitialChildList and InsertFrames
30790: // returned one from their respective underlying framelist ops....
    1: static void
    1: MoveChildrenTo(nsFrameManager*          aFrameManager,
    1:                nsIFrame*                aNewParent,
    1:                nsIFrame*                aFrameList,
 5585:                nsIFrame*                aFrameListEnd,
    1:                nsFrameConstructorState* aState,
    1:                nsFrameConstructorState* aOuterState)
    1: {
    1:   PRBool setHasChildWithView = PR_FALSE;
    1: 
 5585:   while (aFrameList && aFrameList != aFrameListEnd) {
    1:     if (!setHasChildWithView
    1:         && (aFrameList->GetStateBits() & (NS_FRAME_HAS_VIEW | NS_FRAME_HAS_CHILD_WITH_VIEW))) {
    1:       setHasChildWithView = PR_TRUE;
    1:     }
    1: 
    1:     aFrameList->SetParent(aNewParent);
    1: 
    1:     // If aState is not null, the caller expects us to make adjustments so that
    1:     // floats whose placeholders are descendants of frames in aFrameList point
    1:     // to the correct parent.
    1:     if (aState) {
    1:       NS_ASSERTION(aOuterState, "need an outer state too");
    1:       AdjustFloatParentPtrs(aFrameList, *aState, *aOuterState);
    1:     }
    1: 
    1:     aFrameList = aFrameList->GetNextSibling();
    1:   }
    1: 
    1:   if (setHasChildWithView) {
 4696:     do {
    1:       aNewParent->AddStateBits(NS_FRAME_HAS_CHILD_WITH_VIEW);
 4696:       aNewParent = aNewParent->GetParent();
 4696:     } while (aNewParent &&
 4696:              !(aNewParent->GetStateBits() & NS_FRAME_HAS_CHILD_WITH_VIEW));
    1:   }
    1: }
    1: 
    1: // -----------------------------------------------------------
    1: 
    1: 
    1: // Structure used to ensure that bindings are properly enqueued in the
    1: // binding manager's attached queue.
15599: struct NS_STACK_CLASS nsAutoEnqueueBinding
    1: {
    1:   nsAutoEnqueueBinding(nsIDocument* aDocument) :
    1:     mDocument(aDocument)
    1:   {}
    1: 
    1:   ~nsAutoEnqueueBinding();
    1: 
    1:   nsRefPtr<nsXBLBinding> mBinding;
    1: private:
    1:   nsIDocument* mDocument;
    1: };
    1: 
    1: nsAutoEnqueueBinding::~nsAutoEnqueueBinding()
    1: {
    1:   if (mBinding) {
    1:     mDocument->BindingManager()->AddToAttachedQueue(mBinding);
    1:   }
    1: }
    1: 
    1: 
    1: // Helper function that determines the child list name that aChildFrame
    1: // is contained in
    1: static nsIAtom*
    1: GetChildListNameFor(nsIFrame*       aChildFrame)
    1: {
    1:   nsIAtom*      listName;
    1: 
 6521:   if (aChildFrame->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER) {
 6521:     listName = nsGkAtoms::overflowContainersList;
 6521:   }
    1:   // See if the frame is moved out of the flow
 6521:   else if (aChildFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
    1:     // Look at the style information to tell
    1:     const nsStyleDisplay* disp = aChildFrame->GetStyleDisplay();
    1:     
    1:     if (NS_STYLE_POSITION_ABSOLUTE == disp->mPosition) {
    1:       listName = nsGkAtoms::absoluteList;
    1:     } else if (NS_STYLE_POSITION_FIXED == disp->mPosition) {
21903:       if (nsLayoutUtils::IsReallyFixedPos(aChildFrame)) {
    1:         listName = nsGkAtoms::fixedList;
21903:       } else {
21903:         listName = nsGkAtoms::absoluteList;
21903:       }
    1: #ifdef MOZ_XUL
    1:     } else if (NS_STYLE_DISPLAY_POPUP == disp->mDisplay) {
    1:       // Out-of-flows that are DISPLAY_POPUP must be kids of the root popup set
    1: #ifdef DEBUG
    1:       nsIFrame* parent = aChildFrame->GetParent();
 3129:       NS_ASSERTION(parent && parent->GetType() == nsGkAtoms::popupSetFrame,
 3129:                    "Unexpected parent");
    1: #endif // DEBUG
    1: 
    1:       // XXX FIXME: Bug 350740
    1:       // Return here, because the postcondition for this function actually
    1:       // fails for this case, since the popups are not in a "real" frame list
    1:       // in the popup set.
    1:       return nsGkAtoms::popupList;      
    1: #endif // MOZ_XUL
    1:     } else {
    1:       NS_ASSERTION(aChildFrame->GetStyleDisplay()->IsFloating(),
    1:                    "not a floated frame");
    1:       listName = nsGkAtoms::floatList;
    1:     }
    1: 
    1:   } else {
    1:     listName = nsnull;
    1:   }
    1: 
    1: #ifdef NS_DEBUG
    1:   // Verify that the frame is actually in that child list or in the
    1:   // corresponding overflow list.
    1:   nsIFrame* parent = aChildFrame->GetParent();
32846:   PRBool found = parent->GetChildList(listName).ContainsFrame(aChildFrame);
    1:   if (!found) {
    1:     if (!(aChildFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
32846:       found = parent->GetChildList(nsGkAtoms::overflowList)
    1:                 .ContainsFrame(aChildFrame);
    1:     }
    1:     else if (aChildFrame->GetStyleDisplay()->IsFloating()) {
32846:       found = parent->GetChildList(nsGkAtoms::overflowOutOfFlowList)
    1:                 .ContainsFrame(aChildFrame);
    1:     }
    1:     // else it's positioned and should have been on the 'listName' child list.
    1:     NS_POSTCONDITION(found, "not in child list");
    1:   }
    1: #endif
    1: 
    1:   return listName;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsCSSFrameConstructor::nsCSSFrameConstructor(nsIDocument *aDocument,
    1:                                              nsIPresShell *aPresShell)
    1:   : mDocument(aDocument)
    1:   , mPresShell(aPresShell)
24659:   , mRootElementFrame(nsnull)
16509:   , mRootElementStyleFrame(nsnull)
    1:   , mFixedContainingBlock(nsnull)
    1:   , mDocElementContainingBlock(nsnull)
    1:   , mGfxScrollFrame(nsnull)
    1:   , mPageSequenceFrame(nsnull)
    1:   , mUpdateCount(0)
    1:   , mQuotesDirty(PR_FALSE)
    1:   , mCountersDirty(PR_FALSE)
    1:   , mIsDestroyingFrameTree(PR_FALSE)
10073:   , mRebuildAllStyleData(PR_FALSE)
18953:   , mHasRootAbsPosContainingBlock(PR_FALSE)
22471:   , mHoverGeneration(0)
22339:   , mRebuildAllExtraHint(nsChangeHint(0))
    1: {
    1:   // XXXbz this should be in Init() or something!
32401:   if (!mPendingRestyles.Init() || !mPendingAnimationRestyles.Init()) {
    1:     // now what?
    1:   }
    1: 
    1: #ifdef DEBUG
    1:   static PRBool gFirstTime = PR_TRUE;
    1:   if (gFirstTime) {
    1:     gFirstTime = PR_FALSE;
    1:     char* flags = PR_GetEnv("GECKO_FRAMECTOR_DEBUG_FLAGS");
    1:     if (flags) {
    1:       PRBool error = PR_FALSE;
    1:       for (;;) {
    1:         char* comma = PL_strchr(flags, ',');
    1:         if (comma)
    1:           *comma = '\0';
    1: 
    1:         PRBool found = PR_FALSE;
    1:         FrameCtorDebugFlags* flag = gFlags;
    1:         FrameCtorDebugFlags* limit = gFlags + NUM_DEBUG_FLAGS;
    1:         while (flag < limit) {
    1:           if (PL_strcasecmp(flag->name, flags) == 0) {
    1:             *(flag->on) = PR_TRUE;
    1:             printf("nsCSSFrameConstructor: setting %s debug flag on\n", flag->name);
    1:             found = PR_TRUE;
    1:             break;
    1:           }
    1:           ++flag;
    1:         }
    1: 
    1:         if (! found)
    1:           error = PR_TRUE;
    1: 
    1:         if (! comma)
    1:           break;
    1: 
    1:         *comma = ',';
    1:         flags = comma + 1;
    1:       }
    1: 
    1:       if (error) {
    1:         printf("Here are the available GECKO_FRAMECTOR_DEBUG_FLAGS:\n");
    1:         FrameCtorDebugFlags* flag = gFlags;
    1:         FrameCtorDebugFlags* limit = gFlags + NUM_DEBUG_FLAGS;
    1:         while (flag < limit) {
    1:           printf("  %s\n", flag->name);
    1:           ++flag;
    1:         }
    1:         printf("Note: GECKO_FRAMECTOR_DEBUG_FLAGS is a comma separated list of flag\n");
    1:         printf("names (no whitespace)\n");
    1:       }
    1:     }
    1:   }
    1: #endif
    1: }
    1: 
    1: nsIXBLService * nsCSSFrameConstructor::GetXBLService()
    1: {
    1:   if (!gXBLService) {
    1:     nsresult rv = CallGetService("@mozilla.org/xbl;1", &gXBLService);
    1:     if (NS_FAILED(rv))
    1:       gXBLService = nsnull;
    1:   }
    1:   
    1:   return gXBLService;
    1: }
    1: 
    1: void
    1: nsCSSFrameConstructor::NotifyDestroyingFrame(nsIFrame* aFrame)
    1: {
 6518:   NS_PRECONDITION(mUpdateCount != 0,
 6518:                   "Should be in an update while destroying frames");
 6518: 
16477:   if (aFrame->GetStateBits() & NS_FRAME_GENERATED_CONTENT) {
16477:     if (mQuoteList.DestroyNodesFor(aFrame))
    1:       QuotesDirty();
    1:   }
16477: 
16477:   if (mCounterManager.DestroyNodesFor(aFrame)) {
    1:     // Technically we don't need to update anything if we destroyed only
    1:     // USE nodes.  However, this is unlikely to happen in the real world
    1:     // since USE nodes generally go along with INCREMENT nodes.
    1:     CountersDirty();
    1:   }
    1: }
16477: 
16976: struct nsGenConInitializer {
16976:   nsAutoPtr<nsGenConNode> mNode;
16976:   nsGenConList*           mList;
16976:   void (nsCSSFrameConstructor::*mDirtyAll)();
16976:   
16976:   nsGenConInitializer(nsGenConNode* aNode, nsGenConList* aList,
16976:                       void (nsCSSFrameConstructor::*aDirtyAll)())
16976:     : mNode(aNode), mList(aList), mDirtyAll(aDirtyAll) {}
16976: };
16976: 
16976: static void
16976: DestroyGenConInitializer(void*    aFrame,
16976:                          nsIAtom* aPropertyName,
16976:                          void*    aPropertyValue,
16976:                          void*    aDtorData)
16976: {
16976:   delete static_cast<nsGenConInitializer*>(aPropertyValue);
16976: }
16976: 
16976: already_AddRefed<nsIContent>
31438: nsCSSFrameConstructor::CreateGenConTextNode(nsFrameConstructorState& aState,
31438:                                             const nsString& aString,
16976:                                             nsCOMPtr<nsIDOMCharacterData>* aText,
16976:                                             nsGenConInitializer* aInitializer)
16976: {
16976:   nsCOMPtr<nsIContent> content;
16976:   NS_NewTextNode(getter_AddRefs(content), mDocument->NodeInfoManager());
16976:   if (!content) {
16976:     // XXX The quotes/counters code doesn't like the text pointer
16976:     // being null in case of dynamic changes!
16976:     NS_ASSERTION(!aText, "this OOM case isn't handled very well");
16976:     return nsnull;
16976:   }
16976:   content->SetText(aString, PR_FALSE);
16976:   if (aText) {
16976:     *aText = do_QueryInterface(content);
16976:   }
16976:   if (aInitializer) {
16976:     content->SetProperty(nsGkAtoms::genConInitializerProperty, aInitializer,
16976:                          DestroyGenConInitializer);
31438:     aState.mGeneratedTextNodesWithInitializer.AppendObject(content);
16976:   }
16976:   return content.forget();
16976: }
16976: 
16976: already_AddRefed<nsIContent>
31438: nsCSSFrameConstructor::CreateGeneratedContent(nsFrameConstructorState& aState,
31438:                                               nsIContent*     aParentContent,
16477:                                               nsStyleContext* aStyleContext,
16976:                                               PRUint32        aContentIndex)
16976: {
    1:   // Get the content value
16976:   const nsStyleContentData &data =
16976:     aStyleContext->GetStyleContent()->ContentAt(aContentIndex);
    1:   nsStyleContentType type = data.mType;
    1: 
    1:   if (eStyleContentType_Image == type) {
    1:     if (!data.mContent.mImage) {
    1:       // CSS had something specified that couldn't be converted to an
    1:       // image object
16976:       return nsnull;
    1:     }
    1:     
    1:     // Create an image content object and pass it the image request.
    1:     // XXX Check if it's an image type we can handle...
    1: 
    1:     nsCOMPtr<nsINodeInfo> nodeInfo;
19197:     nodeInfo = mDocument->NodeInfoManager()->GetNodeInfo(nsGkAtoms::mozgeneratedcontentimage, nsnull,
19197:                                                          kNameSpaceID_XHTML);
    1: 
16976:     nsCOMPtr<nsIContent> content;
16976:     NS_NewGenConImageContent(getter_AddRefs(content), nodeInfo,
    1:                              data.mContent.mImage);
16976:     return content.forget();
16976:   }
    1: 
    1:   switch (type) {
    1:   case eStyleContentType_String:
31438:     return CreateGenConTextNode(aState,
31438:                                 nsDependentString(data.mContent.mString),
31438:                                 nsnull, nsnull);
    1: 
    1:   case eStyleContentType_Attr:
    1:     {
    1:       nsCOMPtr<nsIAtom> attrName;
    1:       PRInt32 attrNameSpace = kNameSpaceID_None;
16976:       nsAutoString contentString(data.mContent.mString);
33262:       
    1:       PRInt32 barIndex = contentString.FindChar('|'); // CSS namespace delimiter
    1:       if (-1 != barIndex) {
    1:         nsAutoString  nameSpaceVal;
    1:         contentString.Left(nameSpaceVal, barIndex);
    1:         PRInt32 error;
    1:         attrNameSpace = nameSpaceVal.ToInteger(&error, 10);
    1:         contentString.Cut(0, barIndex + 1);
    1:         if (contentString.Length()) {
33329:           if (mDocument->IsHTML() && aParentContent->IsHTML()) {
33262:             ToLowerCase(contentString);
33262:           }
    1:           attrName = do_GetAtom(contentString);
    1:         }
    1:       }
    1:       else {
33329:         if (mDocument->IsHTML() && aParentContent->IsHTML()) {
33262:           ToLowerCase(contentString);
33262:         }
    1:         attrName = do_GetAtom(contentString);
    1:       }
    1: 
    1:       if (!attrName) {
16976:         return nsnull;
16976:       }
16976: 
16976:       nsCOMPtr<nsIContent> content;
16976:       NS_NewAttributeContent(mDocument->NodeInfoManager(),
16976:                              attrNameSpace, attrName, getter_AddRefs(content));
16976:       return content.forget();
16976:     }
    1: 
    1:   case eStyleContentType_Counter:
    1:   case eStyleContentType_Counters:
    1:     {
    1:       nsCSSValue::Array* counters = data.mContent.mCounters;
    1:       nsCounterList* counterList = mCounterManager.CounterListFor(
    1:           nsDependentString(counters->Item(0).GetStringBufferValue()));
    1:       if (!counterList)
16976:         return nsnull;
    1: 
    1:       nsCounterUseNode* node =
16976:         new nsCounterUseNode(counters, aContentIndex,
16477:                              type == eStyleContentType_Counters);
    1:       if (!node)
16976:         return nsnull;
16976: 
16976:       nsGenConInitializer* initializer =
16976:         new nsGenConInitializer(node, counterList,
16976:                                 &nsCSSFrameConstructor::CountersDirty);
31438:       return CreateGenConTextNode(aState, EmptyString(), &node->mText,
31438:                                   initializer);
16976:     }
    1: 
    1:   case eStyleContentType_Image:
    1:     NS_NOTREACHED("handled by if above");
16976:     return nsnull;
    1: 
    1:   case eStyleContentType_OpenQuote:
    1:   case eStyleContentType_CloseQuote:
    1:   case eStyleContentType_NoOpenQuote:
    1:   case eStyleContentType_NoCloseQuote:
    1:     {
16976:       nsQuoteNode* node =
16976:         new nsQuoteNode(type, aContentIndex);
    1:       if (!node)
16976:         return nsnull;
16976: 
16976:       nsGenConInitializer* initializer =
16976:         new nsGenConInitializer(node, &mQuoteList,
16976:                                 &nsCSSFrameConstructor::QuotesDirty);
31438:       return CreateGenConTextNode(aState, EmptyString(), &node->mText,
31438:                                   initializer);
16976:     }
    1:   
    1:   case eStyleContentType_AltContent:
    1:     {
    1:       // Use the "alt" attribute; if that fails and the node is an HTML
    1:       // <input>, try the value attribute and then fall back to some default
    1:       // localized text we have.
16976:       // XXX what if the 'alt' attribute is added later, how will we
16976:       // detect that and do the right thing here?
16976:       if (aParentContent->HasAttr(kNameSpaceID_None, nsGkAtoms::alt)) {
16976:         nsCOMPtr<nsIContent> content;
16976:         NS_NewAttributeContent(mDocument->NodeInfoManager(),
16976:                                kNameSpaceID_None, nsGkAtoms::alt, getter_AddRefs(content));
16976:         return content.forget();
16976:       }
16976: 
33329:       if (aParentContent->IsHTML() &&
16976:           aParentContent->NodeInfo()->Equals(nsGkAtoms::input)) {
16976:         if (aParentContent->HasAttr(kNameSpaceID_None, nsGkAtoms::value)) {
16976:           nsCOMPtr<nsIContent> content;
16976:           NS_NewAttributeContent(mDocument->NodeInfoManager(),
16976:                                  kNameSpaceID_None, nsGkAtoms::value, getter_AddRefs(content));
16976:           return content.forget();
16976:         }
16976: 
    1:         nsXPIDLString temp;
16976:         nsContentUtils::GetLocalizedString(nsContentUtils::eFORMS_PROPERTIES,
    1:                                            "Submit", temp);
31438:         return CreateGenConTextNode(aState, temp, nsnull, nsnull);
16976:       }
16976: 
    1:       break;
16976:     }
    1:   } // switch
    1: 
16976:   return nsnull;
16976: }
16976: 
    1: /*
16976:  * aParentFrame - the frame that should be the parent of the generated
    1:  *   content.  This is the frame for the corresponding content node,
    1:  *   which must not be a leaf frame.
16976:  * 
25768:  * Any items created are added to aItems.
16976:  * 
16976:  * We create an XML element (tag _moz_generated_content_before or
16976:  * _moz_generated_content_after) representing the pseudoelement. We
16976:  * create a DOM node for each 'content' item and make those nodes the
16976:  * children of the XML element. Then we create a frame subtree for
16976:  * the XML element as if it were a regular child of
16976:  * aParentFrame/aParentContent, giving the XML element the ::before or
16976:  * ::after style.
    1:  */
16976: void
25768: nsCSSFrameConstructor::CreateGeneratedContentItem(nsFrameConstructorState& aState,
16976:                                                   nsIFrame*        aParentFrame,
16976:                                                   nsIContent*      aParentContent,
    1:                                                   nsStyleContext*  aStyleContext,
    1:                                                   nsIAtom*         aPseudoElement,
25774:                                                   FrameConstructionItemList& aItems)
25768: {
25768:   // XXXbz is this ever true?
16976:   if (!aParentContent->IsNodeOfType(nsINode::eELEMENT))
16976:     return;
    1: 
    1:   nsStyleSet *styleSet = mPresShell->StyleSet();
    1: 
    1:   // Probe for the existence of the pseudo-element
    1:   nsRefPtr<nsStyleContext> pseudoStyleContext;
16976:   pseudoStyleContext = styleSet->ProbePseudoStyleFor(aParentContent,
    1:                                                      aPseudoElement,
    1:                                                      aStyleContext);
16976:   if (!pseudoStyleContext)
16976:     return;
16976:   // |ProbePseudoStyleFor| checked the 'display' property and the
    1:   // |ContentCount()| of the 'content' property for us.
16976:   nsCOMPtr<nsINodeInfo> nodeInfo;
16976:   nsIAtom* elemName = aPseudoElement == nsCSSPseudoElements::before ?
16976:     nsGkAtoms::mozgeneratedcontentbefore : nsGkAtoms::mozgeneratedcontentafter;
19197:   nodeInfo = mDocument->NodeInfoManager()->GetNodeInfo(elemName, nsnull,
19197:                                                        kNameSpaceID_None);
25768:   nsCOMPtr<nsIContent> container;
25768:   nsresult rv = NS_NewXMLElement(getter_AddRefs(container), nodeInfo);
16976:   if (NS_FAILED(rv))
16976:     return;
16976:   container->SetNativeAnonymous();
16976: 
16976:   rv = container->BindToTree(mDocument, aParentContent, aParentContent, PR_TRUE);
16976:   if (NS_FAILED(rv)) {
16976:     container->UnbindFromTree();
16976:     return;
16976:   }
16976: 
16976:   PRUint32 contentCount = pseudoStyleContext->GetStyleContent()->ContentCount();
    1:   for (PRUint32 contentIndex = 0; contentIndex < contentCount; contentIndex++) {
16976:     nsCOMPtr<nsIContent> content =
31438:       CreateGeneratedContent(aState, aParentContent, pseudoStyleContext,
31438:                              contentIndex);
16976:     if (content) {
16976:       container->AppendChildTo(content, PR_FALSE);
16976:     }
16976:   }
16976: 
25771:   AddFrameConstructionItemsInternal(aState, container, aParentFrame, elemName,
29501:                                     kNameSpaceID_None, -1, pseudoStyleContext,
25768:                                     ITEM_IS_GENERATED_CONTENT, aItems);
    1: }
    1:     
    1: /****************************************************
    1:  **  BEGIN TABLE SECTION
    1:  ****************************************************/
    1: 
    1: // The term pseudo frame is being used instead of anonymous frame, since anonymous
    1: // frame has been used elsewhere to refer to frames that have generated content
    1: 
    1: static PRBool
26208: IsTableRelated(nsIAtom* aParentType)
26208: {
26208:   return
30133:     nsGkAtoms::tableOuterFrame    == aParentType ||
26208:     nsGkAtoms::tableFrame         == aParentType ||
26208:     nsGkAtoms::tableRowGroupFrame == aParentType ||
26208:     nsGkAtoms::tableRowFrame      == aParentType ||
26208:     nsGkAtoms::tableCaptionFrame  == aParentType ||
26208:     nsGkAtoms::tableColGroupFrame == aParentType ||
26208:     nsGkAtoms::tableColFrame      == aParentType ||
26208:     IS_TABLE_CELL(aParentType);
26208: }
26208: 
26471: // Return whether the given frame is a table pseudo-frame.  Note that
26471: // cell-content and table-outer frames have pseudo-types, but are always
26471: // created, even for non-anonymous cells and tables respectively.  So for those
26471: // we have to examine the cell or table frame to see whether it's a pseudo
26471: // frame.  In particular, a lone table caption will have an outer table as its
26471: // parent, but will also trigger construction of an empty inner table, which
26471: // will be the one we can examine to see whether the outer was a pseudo-frame.
26471: static PRBool
26471: IsTablePseudo(nsIFrame* aFrame)
26471: {
26471:   nsIAtom* pseudoType = aFrame->GetStyleContext()->GetPseudoType();
26471:   return pseudoType &&
26471:     (pseudoType == nsCSSAnonBoxes::table ||
26471:      pseudoType == nsCSSAnonBoxes::inlineTable ||
26471:      pseudoType == nsCSSAnonBoxes::tableColGroup ||
26471:      pseudoType == nsCSSAnonBoxes::tableRowGroup ||
26471:      pseudoType == nsCSSAnonBoxes::tableRow ||
26471:      pseudoType == nsCSSAnonBoxes::tableCell ||
26471:      (pseudoType == nsCSSAnonBoxes::cellContent &&
26471:       aFrame->GetParent()->GetStyleContext()->GetPseudoType() ==
26471:         nsCSSAnonBoxes::tableCell) ||
26471:      (pseudoType == nsCSSAnonBoxes::tableOuter &&
26471:       (aFrame->GetFirstChild(nsnull)->GetStyleContext()->GetPseudoType() ==
26471:          nsCSSAnonBoxes::table ||
26471:        aFrame->GetFirstChild(nsnull)->GetStyleContext()->GetPseudoType() ==
26471:          nsCSSAnonBoxes::inlineTable)));
26471: }
26471: 
26208: /* static */
26208: nsCSSFrameConstructor::ParentType
29580: nsCSSFrameConstructor::GetParentType(nsIAtom* aFrameType)
29580: {
29580:   if (aFrameType == nsGkAtoms::tableFrame) {
26208:     return eTypeTable;
26208:   }
29580:   if (aFrameType == nsGkAtoms::tableRowGroupFrame) {
26208:     return eTypeRowGroup;
26208:   }
29580:   if (aFrameType == nsGkAtoms::tableRowFrame) {
26208:     return eTypeRow;
26208:   }
29580:   if (aFrameType == nsGkAtoms::tableColGroupFrame) {
26208:     return eTypeColGroup;
26208:   }
26208: 
26208:   return eTypeBlock;
    1: }
    1:            
    1: static nsIFrame*
    1: AdjustCaptionParentFrame(nsIFrame* aParentFrame) 
    1: {
    1:   if (nsGkAtoms::tableFrame == aParentFrame->GetType()) {
    1:     return aParentFrame->GetParent();;
    1:   }
    1:   return aParentFrame;
    1: }
    1:  
    1: /**
    1:  * If the parent frame is a |tableFrame| and the child is a
    1:  * |captionFrame|, then we want to insert the frames beneath the
    1:  * |tableFrame|'s parent frame. Returns |PR_TRUE| if the parent frame
    1:  * needed to be fixed up.
    1:  */
    1: static PRBool
    1: GetCaptionAdjustedParent(nsIFrame*        aParentFrame,
    1:                          const nsIFrame*  aChildFrame,
    1:                          nsIFrame**       aAdjParentFrame)
    1: {
    1:   *aAdjParentFrame = aParentFrame;
    1:   PRBool haveCaption = PR_FALSE;
    1: 
    1:   if (nsGkAtoms::tableCaptionFrame == aChildFrame->GetType()) {
    1:     haveCaption = PR_TRUE;
    1:     *aAdjParentFrame = AdjustCaptionParentFrame(aParentFrame);
    1:   }
    1:   return haveCaption;
    1: }
    1: 
26208: void
26208: nsCSSFrameConstructor::AdjustParentFrame(nsIFrame* &                  aParentFrame,
23955:                                          const FrameConstructionData* aFCData,
26208:                                          nsStyleContext*              aStyleContext)
    1: {
25768:   NS_PRECONDITION(aStyleContext, "Must have child's style context");
25131:   NS_PRECONDITION(aFCData, "Must have frame construction data");
    1: 
25131:   PRBool tablePart = ((aFCData->mBits & FCDATA_IS_TABLE_PART) != 0);
25131: 
26208:   if (tablePart && aStyleContext->GetStyleDisplay()->mDisplay ==
26208:       NS_STYLE_DISPLAY_TABLE_CAPTION) {
26207:     aParentFrame = AdjustCaptionParentFrame(aParentFrame);
26208:   }
    1: }
    1: 
 4368: // Pull all the captions present in aItems out  into aCaptions
 4368: static void
 4368: PullOutCaptionFrames(nsFrameItems& aItems, nsFrameItems& aCaptions)
 4368: {
30785:   nsIFrame *child = aItems.FirstChild();
 4368:   while (child) {
 4368:     nsIFrame *nextSibling = child->GetNextSibling();
 4368:     if (nsGkAtoms::tableCaptionFrame == child->GetType()) {
33388:       aItems.RemoveFrame(child);
 4368:       aCaptions.AddChild(child);
 4368:     }
 4368:     child = nextSibling;
 4368:   }
 4368: }
 4368: 
 4368: 
    1: // Construct the outer, inner table frames and the children frames for the table. 
    1: // XXX Page break frames for pseudo table frames are not constructed to avoid the risk
    1: // associated with revising the pseudo frame mechanism. The long term solution
    1: // of having frames handle page-break-before/after will solve the problem. 
    1: nsresult
26208: nsCSSFrameConstructor::ConstructTable(nsFrameConstructorState& aState,
26208:                                       FrameConstructionItem&   aItem,
26208:                                       nsIFrame*                aParentFrame,
26208:                                       const nsStyleDisplay*    aDisplay,
26208:                                       nsFrameItems&            aFrameItems,
26208:                                       nsIFrame**               aNewFrame)
26208: {
26208:   NS_PRECONDITION(aDisplay->mDisplay == NS_STYLE_DISPLAY_TABLE ||
26208:                   aDisplay->mDisplay == NS_STYLE_DISPLAY_INLINE_TABLE,
26208:                   "Unexpected call");
26208: 
26208:   nsIContent* const content = aItem.mContent;
26208:   nsStyleContext* const styleContext = aItem.mStyleContext;
26208:   const PRUint32 nameSpaceID = aItem.mNameSpaceID;
26208:   
    1:   nsresult rv = NS_OK;
    1: 
    1:   // create the pseudo SC for the outer table as a child of the inner SC
    1:   nsRefPtr<nsStyleContext> outerStyleContext;
    1:   outerStyleContext = mPresShell->StyleSet()->
26208:     ResolvePseudoStyleFor(content, nsCSSAnonBoxes::tableOuter, styleContext);
    1: 
    1:   // Create the outer table frame which holds the caption and inner table frame
26208:   nsIFrame* newFrame;
    1: #ifdef MOZ_MATHML
26208:   if (kNameSpaceID_MathML == nameSpaceID)
26208:     newFrame = NS_NewMathMLmtableOuterFrame(mPresShell, outerStyleContext);
    1:   else
    1: #endif
26208:     newFrame = NS_NewTableOuterFrame(mPresShell, outerStyleContext);
26208: 
26208:   nsIFrame* geometricParent =
26208:     aState.GetGeometricParent(outerStyleContext->GetStyleDisplay(),
26208:                               aParentFrame);
    1: 
    1:   // Init the table outer frame and see if we need to create a view, e.g.
    1:   // the frame is absolutely positioned  
26208:   InitAndRestoreFrame(aState, content, geometricParent, nsnull, newFrame);  
26208:   nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1: 
    1:   // Create the inner table frame
26208:   nsIFrame* innerFrame;
    1: #ifdef MOZ_MATHML
26208:   if (kNameSpaceID_MathML == nameSpaceID)
26208:     innerFrame = NS_NewMathMLmtableFrame(mPresShell, styleContext);
    1:   else
    1: #endif
26208:     innerFrame = NS_NewTableFrame(mPresShell, styleContext);
26208:  
26208:   InitAndRestoreFrame(aState, content, newFrame, nsnull, innerFrame);
26208: 
    1:   // Put the newly created frames into the right child list
30790:   SetInitialSingleChild(newFrame, innerFrame);
26208: 
26208:   rv = aState.AddChild(newFrame, aFrameItems, content, styleContext,
26208:                        aParentFrame);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
24659:   if (!mRootElementFrame) {
24659:     // The frame we're constructing will be the root element frame.
24659:     // Set mRootElementFrame before processing children.
26208:     mRootElementFrame = newFrame;
20147:   }
20147: 
    1:   nsFrameItems childItems;
26208:   if (aItem.mFCData->mBits & FCDATA_USE_CHILD_ITEMS) {
26208:     rv = ConstructFramesFromItemList(aState, aItem.mChildItems,
26208:                                      innerFrame, childItems);
26208:   } else {
26208:     rv = ProcessChildren(aState, content, styleContext, innerFrame,
23352:                          PR_TRUE, childItems, PR_FALSE);
26208:   }
    1:   // XXXbz what about cleaning up?
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   nsFrameItems captionItems;
 4368:   PullOutCaptionFrames(childItems, captionItems);
 4368: 
    1:   // Set the inner table frame's initial primary list 
30785:   innerFrame->SetInitialChildList(nsnull, childItems);
    1: 
    1:   // Set the outer table frame's secondary childlist lists
30785:   if (captionItems.NotEmpty()) {
30785:     newFrame->SetInitialChildList(nsGkAtoms::captionList, captionItems);
    1:   }
26208: 
26208:   *aNewFrame = newFrame;
    1:   return rv;
    1: }
    1: 
    1: nsresult
26208: nsCSSFrameConstructor::ConstructTableRow(nsFrameConstructorState& aState,
26208:                                          FrameConstructionItem&   aItem,
26208:                                          nsIFrame*                aParentFrame,
26208:                                          const nsStyleDisplay*    aDisplay,
26208:                                          nsFrameItems&            aFrameItems,
26208:                                          nsIFrame**               aNewFrame)
26208: {
26208:   NS_PRECONDITION(aDisplay->mDisplay == NS_STYLE_DISPLAY_TABLE_ROW,
26208:                   "Unexpected call");
26208:   nsIContent* const content = aItem.mContent;
26208:   nsStyleContext* const styleContext = aItem.mStyleContext;
26208:   const PRUint32 nameSpaceID = aItem.mNameSpaceID;
26208: 
26208:   nsIFrame* newFrame;
    1: #ifdef MOZ_MATHML
26208:   if (kNameSpaceID_MathML == nameSpaceID)
26208:     newFrame = NS_NewMathMLmtrFrame(mPresShell, styleContext);
    1:   else
    1: #endif
26208:     newFrame = NS_NewTableRowFrame(mPresShell, styleContext);
26208: 
26208:   if (NS_UNLIKELY(!newFrame)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
26208:   InitAndRestoreFrame(aState, content, aParentFrame, nsnull, newFrame);
26208:   nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
26208: 
    1:   nsFrameItems childItems;
26208:   nsresult rv;
26208:   if (aItem.mFCData->mBits & FCDATA_USE_CHILD_ITEMS) {
26208:     rv = ConstructFramesFromItemList(aState, aItem.mChildItems, newFrame,
26208:                                      childItems);
26208:   } else {
26208:     rv = ProcessChildren(aState, content, styleContext, newFrame,
25130:                          PR_TRUE, childItems, PR_FALSE);
26208:   }
    1:   if (NS_FAILED(rv)) return rv;
    1: 
30785:   newFrame->SetInitialChildList(nsnull, childItems);
26208:   aFrameItems.AddChild(newFrame);
26208:   *aNewFrame = newFrame;
    1: 
25130:   return NS_OK;
    1: }
    1: 
    1: nsresult
26207: nsCSSFrameConstructor::ConstructTableCol(nsFrameConstructorState& aState,
26207:                                          FrameConstructionItem&   aItem,
26207:                                          nsIFrame*                aParentFrame,
26207:                                          const nsStyleDisplay*    aStyleDisplay,
26207:                                          nsFrameItems&            aFrameItems,
26207:                                          nsIFrame**               aNewFrame)
26207: {
26207:   nsIContent* const content = aItem.mContent;
26207:   nsStyleContext* const styleContext = aItem.mStyleContext;
26207: 
26207:   nsTableColFrame* colFrame = NS_NewTableColFrame(mPresShell, styleContext);
32841:   if (NS_UNLIKELY(!colFrame)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
26207:   InitAndRestoreFrame(aState, content, aParentFrame, nsnull, colFrame);
26207: 
26207:   NS_ASSERTION(colFrame->GetStyleContext() == styleContext,
26207:                "Unexpected style context");
    1: 
32841:   aFrameItems.AddChild(colFrame);
32841:   *aNewFrame = colFrame;
32841: 
    1:   // construct additional col frames if the col frame has a span > 1
 8151:   PRInt32 span = colFrame->GetSpan();
    1:   for (PRInt32 spanX = 1; spanX < span; spanX++) {
 8151:     nsTableColFrame* newCol = NS_NewTableColFrame(mPresShell, styleContext);
    1:     if (NS_UNLIKELY(!newCol)) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
26207:     InitAndRestoreFrame(aState, content, aParentFrame, nsnull, newCol,
26207:                         PR_FALSE);
32841:     aFrameItems.LastChild()->SetNextContinuation(newCol);
32841:     newCol->SetPrevContinuation(aFrameItems.LastChild());
32841:     aFrameItems.AddChild(newCol);
 8151:     newCol->SetColType(eColAnonymousCol);
32841:   }
    1: 
25130:   return NS_OK;
    1: }
    1: 
    1: nsresult
26208: nsCSSFrameConstructor::ConstructTableCell(nsFrameConstructorState& aState,
26208:                                           FrameConstructionItem&   aItem,
26208:                                           nsIFrame*                aParentFrame,
26208:                                           const nsStyleDisplay*    aDisplay,
26208:                                           nsFrameItems&            aFrameItems,
26208:                                           nsIFrame**               aNewFrame)
26208: {
26208:   NS_PRECONDITION(aDisplay->mDisplay == NS_STYLE_DISPLAY_TABLE_CELL,
26208:                   "Unexpected call");
26208: 
26208:   nsIContent* const content = aItem.mContent;
26208:   nsStyleContext* const styleContext = aItem.mStyleContext;
26208:   const PRUint32 nameSpaceID = aItem.mNameSpaceID;
26208: 
26208:   PRBool borderCollapse = IsBorderCollapse(aParentFrame);
26208:   nsIFrame* newFrame;
    1: #ifdef MOZ_MATHML
    1:   // <mtable> is border separate in mathml.css and the MathML code doesn't implement
    1:   // border collapse. For those users who style <mtable> with border collapse,
26208:   // give them the default non-MathML table frames that understand border collapse.
    1:   // This won't break us because MathML table frames are all subclasses of the default
    1:   // table code, and so we can freely mix <mtable> with <mtr> or <tr>, <mtd> or <td>.
    1:   // What will happen is just that non-MathML frames won't understand MathML attributes
    1:   // and will therefore miss the special handling that the MathML code does.
26208:   if (kNameSpaceID_MathML == nameSpaceID && !borderCollapse)
26208:     newFrame = NS_NewMathMLmtdFrame(mPresShell, styleContext);
    1:   else
    1: #endif
 8578:     // Warning: If you change this and add a wrapper frame around table cell
 8578:     // frames, make sure Bug 368554 doesn't regress!
 8578:     // See IsInAutoWidthTableCellForQuirk() in nsImageFrame.cpp.    
26208:     newFrame = NS_NewTableCellFrame(mPresShell, styleContext, borderCollapse);
26208: 
26208:   if (NS_UNLIKELY(!newFrame)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   // Initialize the table cell frame
26208:   InitAndRestoreFrame(aState, content, aParentFrame, nsnull, newFrame);
26208:   nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1:   
    1:   // Resolve pseudo style and initialize the body cell frame
    1:   nsRefPtr<nsStyleContext> innerPseudoStyle;
    1:   innerPseudoStyle = mPresShell->StyleSet()->
26208:     ResolvePseudoStyleFor(content, nsCSSAnonBoxes::cellContent, styleContext);
    1: 
    1:   // Create a block frame that will format the cell's content
 6818:   PRBool isBlock;
26208:   nsIFrame* cellInnerFrame;
    1: #ifdef MOZ_MATHML
26208:   if (kNameSpaceID_MathML == nameSpaceID) {
26208:     cellInnerFrame = NS_NewMathMLmtdInnerFrame(mPresShell, innerPseudoStyle);
 6818:     isBlock = PR_FALSE;
 6818:   }
    1:   else
    1: #endif
 6818:   {
26208:     cellInnerFrame = NS_NewBlockFormattingContext(mPresShell, innerPseudoStyle);
 6818:     isBlock = PR_TRUE;
 6818:   }
    1: 
26208:   if (NS_UNLIKELY(!cellInnerFrame)) {
26208:     newFrame->Destroy();
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
26208:   InitAndRestoreFrame(aState, content, newFrame, nsnull, cellInnerFrame);
26208: 
26208:   nsFrameItems childItems;
26208:   nsresult rv;
26208:   if (aItem.mFCData->mBits & FCDATA_USE_CHILD_ITEMS) {
26208:     // Need to push ourselves as a float containing block.
26208:     // XXXbz it might be nice to work on getting the parent
26208:     // FrameConstructionItem down into ProcessChildren and just making use of
26208:     // the push there, but that's a bit of work.
26208:     nsFrameConstructorSaveState floatSaveState;
26208:     if (!isBlock) { /* MathML case */
26208:       aState.PushFloatContainingBlock(nsnull, floatSaveState);
26208:     } else {
26208:       aState.PushFloatContainingBlock(cellInnerFrame, floatSaveState);
26208:     }
26208: 
26208:     rv = ConstructFramesFromItemList(aState, aItem.mChildItems, cellInnerFrame,
26208:                                      childItems);
26208:   } else {
    1:     // Process the child content
26208:     rv = ProcessChildren(aState, content, styleContext, cellInnerFrame,
26208:                          PR_TRUE, childItems, isBlock);
26208:   }
    1:   
    1:   if (NS_FAILED(rv)) {
    1:     // Clean up
    1:     // XXXbz kids of this stuff need to be cleaned up too!
26208:     cellInnerFrame->Destroy();
26208:     newFrame->Destroy();
    1:     return rv;
    1:   }
    1: 
30785:   cellInnerFrame->SetInitialChildList(nsnull, childItems);
30790:   SetInitialSingleChild(newFrame, cellInnerFrame);
26208:   aFrameItems.AddChild(newFrame);
26208:   *aNewFrame = newFrame;
    1: 
25130:   return NS_OK;
    1: }
    1: 
    1: static PRBool 
    1: NeedFrameFor(nsIFrame*   aParentFrame,
    1:              nsIContent* aChildContent) 
    1: {
16976:   // don't create a whitespace frame if aParentFrame doesn't want it.
16976:   // always create frames for children in generated content. counter(),
16976:   // quotes, and attr() content can easily change dynamically and we don't
16976:   // want to be reconstructing frames. It's not even clear that these
16976:   // should be considered ignorable just because they evaluate to
16976:   // whitespace.
27311: 
27311:   // We could handle all this in CreateNeededTablePseudos or some other place
27311:   // after we build our frame construction items, but that would involve
27311:   // creating frame construction items for whitespace kids of
27311:   // eExcludesIgnorableWhitespace frames, where we know we'll be dropping them
27311:   // all anyway, and involve an extra walk down the frame construction item
27311:   // list.
27311:   if (!aParentFrame->IsFrameOfType(nsIFrame::eExcludesIgnorableWhitespace) ||
27311:       aParentFrame->IsGeneratedContentFrame() ||
27311:       !aChildContent->IsNodeOfType(nsINode::eTEXT)) {
27311:     return PR_TRUE;
27311:   }
27311: 
29809:   aChildContent->SetFlags(NS_CREATE_FRAME_IF_NON_WHITESPACE |
29809:                           NS_REFRAME_IF_WHITESPACE);
27311:   return !aChildContent->TextIsOnlyWhitespace();
    1: }
    1: 
    1: /***********************************************
    1:  * END TABLE SECTION
    1:  ***********************************************/
    1: 
    1: static PRBool CheckOverflow(nsPresContext* aPresContext,
    1:                             const nsStyleDisplay* aDisplay)
    1: {
    1:   if (aDisplay->mOverflowX == NS_STYLE_OVERFLOW_VISIBLE)
    1:     return PR_FALSE;
    1: 
    1:   if (aDisplay->mOverflowX == NS_STYLE_OVERFLOW_CLIP)
    1:     aPresContext->SetViewportOverflowOverride(NS_STYLE_OVERFLOW_HIDDEN,
    1:                                               NS_STYLE_OVERFLOW_HIDDEN);
    1:   else
    1:     aPresContext->SetViewportOverflowOverride(aDisplay->mOverflowX,
    1:                                               aDisplay->mOverflowY);
    1:   return PR_TRUE;
    1: }
    1: 
    1: /**
    1:  * This checks the root element and the HTML BODY, if any, for an "overflow" property
    1:  * that should be applied to the viewport. If one is found then we return the
    1:  * element that we took the overflow from (which should then be treated as
    1:  * "overflow:visible"), and we store the overflow style in the prescontext.
    1:  * @return if scroll was propagated from some content node, the content node it
    1:  *         was propagated from.
    1:  */
    1: nsIContent*
    1: nsCSSFrameConstructor::PropagateScrollToViewport()
    1: {
    1:   // Set default
    1:   nsPresContext* presContext = mPresShell->GetPresContext();
    1:   presContext->SetViewportOverflowOverride(NS_STYLE_OVERFLOW_AUTO,
    1:                                            NS_STYLE_OVERFLOW_AUTO);
    1: 
    1:   // We never mess with the viewport scroll state
    1:   // when printing or in print preview
    1:   if (presContext->IsPaginated()) {
    1:     return nsnull;
    1:   }
    1: 
    1:   nsIContent* docElement = mDocument->GetRootContent();
    1: 
    1:   // Check the style on the document root element
    1:   nsStyleSet *styleSet = mPresShell->StyleSet();
    1:   nsRefPtr<nsStyleContext> rootStyle;
    1:   rootStyle = styleSet->ResolveStyleFor(docElement, nsnull);
    1:   if (!rootStyle) {
    1:     return nsnull;
    1:   }
    1:   if (CheckOverflow(presContext, rootStyle->GetStyleDisplay())) {
    1:     // tell caller we stole the overflow style from the root element
    1:     return docElement;
    1:   }
    1:   
    1:   // Don't look in the BODY for non-HTML documents or HTML documents
    1:   // with non-HTML roots
    1:   // XXX this should be earlier; we shouldn't even look at the document root
    1:   // for non-HTML documents. Fix this once we support explicit CSS styling
    1:   // of the viewport
    1:   // XXX what about XHTML?
    1:   nsCOMPtr<nsIDOMHTMLDocument> htmlDoc(do_QueryInterface(mDocument));
33329:   if (!htmlDoc || !docElement->IsHTML()) {
    1:     return nsnull;
    1:   }
    1:   
    1:   nsCOMPtr<nsIDOMHTMLElement> body;
    1:   htmlDoc->GetBody(getter_AddRefs(body));
    1:   nsCOMPtr<nsIContent> bodyElement = do_QueryInterface(body);
    1:   
    1:   if (!bodyElement ||
    1:       !bodyElement->NodeInfo()->Equals(nsGkAtoms::body)) {
    1:     // The body is not a <body> tag, it's a <frameset>.
    1:     return nsnull;
    1:   }
    1: 
    1:   nsRefPtr<nsStyleContext> bodyStyle;
    1:   bodyStyle = styleSet->ResolveStyleFor(bodyElement, rootStyle);
    1:   if (!bodyStyle) {
    1:     return nsnull;
    1:   }
    1: 
    1:   if (CheckOverflow(presContext, bodyStyle->GetStyleDisplay())) {
    1:     // tell caller we stole the overflow style from the body element
    1:     return bodyElement;
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: nsresult
28215: nsCSSFrameConstructor::ConstructDocElementFrame(nsIContent*              aDocElement,
28215:                                                 nsILayoutHistoryState*   aFrameState,
    1:                                                 nsIFrame**               aNewFrame)
    1: {
28215:   NS_PRECONDITION(mFixedContainingBlock,
28215:                   "No viewport?  Someone forgot to call ConstructRootFrame!");
28215:   NS_PRECONDITION(mFixedContainingBlock == mPresShell->FrameManager()->GetRootFrame(),
28215:                   "Unexpected mFixedContainingBlock");
30941:   NS_PRECONDITION(!mDocElementContainingBlock,
30941:                   "Shouldn't have a doc element containing block here");
28215: 
    1:   *aNewFrame = nsnull;
    1: 
30585:   // Make sure to call PropagateScrollToViewport before
30585:   // SetUpDocElementContainingBlock, since it sets up our scrollbar state
30585:   // properly.
30585:   nsIContent* propagatedScrollFrom = PropagateScrollToViewport();
30585: 
28215:   SetUpDocElementContainingBlock(aDocElement);
28215: 
28215:   NS_ASSERTION(mDocElementContainingBlock, "Should have parent by now");
28215: 
28215:   nsFrameConstructorState state(mPresShell, mFixedContainingBlock, nsnull,
28215:                                 nsnull, aFrameState);
28215: 
28215:   // XXXbz why, exactly?
    1:   if (!mTempFrameTreeState)
28215:     state.mPresShell->CaptureHistoryState(getter_AddRefs(mTempFrameTreeState));
    1: 
    1:   // --------- CREATE AREA OR BOX FRAME -------
    1:   nsRefPtr<nsStyleContext> styleContext;
    1:   styleContext = mPresShell->StyleSet()->ResolveStyleFor(aDocElement,
    1:                                                          nsnull);
    1: 
    1:   const nsStyleDisplay* display = styleContext->GetStyleDisplay();
    1: 
    1:   // Ensure that our XBL bindings are installed.
    1:   if (display->mBinding) {
    1:     // Get the XBL loader.
    1:     nsresult rv;
    1:     PRBool resolveStyle;
    1:     
    1:     nsIXBLService * xblService = GetXBLService();
    1:     if (!xblService)
    1:       return NS_ERROR_FAILURE;
    1: 
    1:     nsRefPtr<nsXBLBinding> binding;
 3645:     rv = xblService->LoadBindings(aDocElement, display->mBinding->mURI,
 3645:                                   display->mBinding->mOriginPrincipal,
 3645:                                   PR_FALSE, getter_AddRefs(binding),
 3645:                                   &resolveStyle);
    1:     if (NS_FAILED(rv))
    1:       return NS_OK; // Binding will load asynchronously.
    1: 
    1:     if (binding) {
    1:       mDocument->BindingManager()->AddToAttachedQueue(binding);
    1:     }
    1: 
    1:     if (resolveStyle) {
    1:       styleContext = mPresShell->StyleSet()->ResolveStyleFor(aDocElement,
    1:                                                              nsnull);
    1:       display = styleContext->GetStyleDisplay();
    1:     }
    1:   }
    1: 
    1:   // --------- IF SCROLLABLE WRAP IN SCROLLFRAME --------
    1: 
    1: #ifdef DEBUG
    1:   NS_ASSERTION(!display->IsScrollableOverflow() || 
28215:                state.mPresContext->IsPaginated() ||
30585:                propagatedScrollFrom == aDocElement,
    1:                "Scrollbars should have been propagated to the viewport");
    1: #endif
    1: 
19172:   if (NS_UNLIKELY(display->mDisplay == NS_STYLE_DISPLAY_NONE)) {
28215:     state.mFrameManager->SetUndisplayedContent(aDocElement, styleContext);
19172:     return NS_OK;
19172:   }
19172: 
18953:   nsFrameConstructorSaveState absoluteSaveState;
18953:   if (mHasRootAbsPosContainingBlock) {
18953:     // Push the absolute containing block now so we can absolutely position
18953:     // the root element
28215:     state.PushAbsoluteContainingBlock(mDocElementContainingBlock,
28215:                                       absoluteSaveState);
18953:   }
18953: 
    1:   nsresult rv;
    1: 
    1:   // The rules from CSS 2.1, section 9.2.4, have already been applied
    1:   // by the style system, so we can assume that display->mDisplay is
    1:   // either NONE, BLOCK, or TABLE.
    1: 
18953:   // contentFrame is the primary frame for the root element. *aNewFrame
18953:   // is the frame that will be the child of the initial containing block.
18953:   // These are usually the same frame but they can be different, in
18953:   // particular if the root frame is positioned, in which case
18953:   // contentFrame is the out-of-flow frame and *aNewFrame is the
18953:   // placeholder.
18953:   nsIFrame* contentFrame;
18953:   PRBool processChildren = PR_FALSE;
23938: 
23938:   // Check whether we need to build a XUL box or SVG root frame
23938: #ifdef MOZ_XUL
33329:   if (aDocElement->IsXUL()) {
23938:     contentFrame = NS_NewDocElementBoxFrame(mPresShell, styleContext);
23938:     if (NS_UNLIKELY(!contentFrame)) {
23938:       return NS_ERROR_OUT_OF_MEMORY;
23938:     }
28215:     InitAndRestoreFrame(state, aDocElement, mDocElementContainingBlock, nsnull,
28215:                         contentFrame);
23938:     *aNewFrame = contentFrame;
23938:     processChildren = PR_TRUE;
23938:   }
23938:   else
23938: #endif
23938: #ifdef MOZ_SVG
23938:   if (aDocElement->GetNameSpaceID() == kNameSpaceID_SVG) {
23938:     if (aDocElement->Tag() == nsGkAtoms::svg && NS_SVGEnabled()) {
23953:       contentFrame = NS_NewSVGOuterSVGFrame(mPresShell, styleContext);
23938:       if (NS_UNLIKELY(!contentFrame)) {
23938:         return NS_ERROR_OUT_OF_MEMORY;
23938:       }
28215:       InitAndRestoreFrame(state, aDocElement,
28215:                           state.GetGeometricParent(display,
28215:                                                    mDocElementContainingBlock),
23938:                           nsnull, contentFrame);
23938: 
23938:       // AddChild takes care of transforming the frame tree for fixed-pos
23938:       // or abs-pos situations
23938:       nsFrameItems frameItems;
28215:       rv = state.AddChild(contentFrame, frameItems, aDocElement,
28215:                           styleContext, mDocElementContainingBlock);
30785:       if (NS_FAILED(rv) || frameItems.IsEmpty()) {
23938:         return rv;
23938:       }
30785:       *aNewFrame = frameItems.FirstChild();
23938:       processChildren = PR_TRUE;
23938: 
23938:       // See if we need to create a view
23938:       nsHTMLContainerFrame::CreateViewForFrame(contentFrame, PR_FALSE);
23938:     } else {
23938:       return NS_ERROR_FAILURE;
23938:     }
23938:   }
23938:   else
23938: #endif
23938:   {
23938:     PRBool docElemIsTable = (display->mDisplay == NS_STYLE_DISPLAY_TABLE);
    1:     if (docElemIsTable) {
26208:       // We're going to call the right function ourselves, so no need to give a
26208:       // function to this FrameConstructionData.
26208: 
26208:       // XXXbz on the other hand, if we converted this whole function to
26208:       // FrameConstructionData/Item, then we'd need the right function
26208:       // here... but would probably be able to get away with less code in this
26208:       // function in general.
30785:       static const FrameConstructionData rootTableData = FCDATA_DECL(0, nsnull);
26208:       nsRefPtr<nsStyleContext> extraRef(styleContext);
26208:       FrameConstructionItem item(&rootTableData, aDocElement,
26208:                                  aDocElement->Tag(), kNameSpaceID_None,
29501:                                  -1, extraRef.forget());
26208: 
18953:       nsFrameItems frameItems;
    1:       // if the document is a table then just populate it.
28215:       rv = ConstructTable(state, item, mDocElementContainingBlock,
26208:                           styleContext->GetStyleDisplay(),
26208:                           frameItems, &contentFrame);
18953:       if (NS_FAILED(rv))
18953:         return rv;
30785:       if (!contentFrame || frameItems.IsEmpty())
18953:         return NS_ERROR_FAILURE;
30785:       *aNewFrame = frameItems.FirstChild();
30785:       NS_ASSERTION(frameItems.OnlyChild(), "multiple root element frames");
    1:     } else {
18953:       contentFrame = NS_NewBlockFrame(mPresShell, styleContext,
23305:         NS_BLOCK_FLOAT_MGR|NS_BLOCK_MARGIN_ROOT);
18953:       if (!contentFrame)
18885:         return NS_ERROR_OUT_OF_MEMORY;
18953:       nsFrameItems frameItems;
28215:       rv = ConstructBlock(state, display, aDocElement,
28215:                           state.GetGeometricParent(display,
28215:                                                    mDocElementContainingBlock),
28215:                           mDocElementContainingBlock, styleContext,
28215:                           &contentFrame, frameItems, display->IsPositioned());
30785:       if (NS_FAILED(rv) || frameItems.IsEmpty())
18953:         return rv;
30785:       *aNewFrame = frameItems.FirstChild();
30785:       NS_ASSERTION(frameItems.OnlyChild(), "multiple root element frames");
18953:     }
    1:   }
    1: 
    1:   // set the primary frame
28215:   state.mFrameManager->SetPrimaryFrameFor(aDocElement, contentFrame);
    1: 
24659:   NS_ASSERTION(processChildren ? !mRootElementFrame :
24659:                  mRootElementFrame == contentFrame,
24659:                "unexpected mRootElementFrame");
24659:   mRootElementFrame = contentFrame;
    1: 
16509:   // Figure out which frame has the main style for the document element,
16509:   // assigning it to mRootElementStyleFrame.
16509:   // Backgrounds should be propagated from that frame to the viewport.
16509:   PRBool isChild;
28215:   contentFrame->GetParentStyleContextFrame(state.mPresContext,
16509:           &mRootElementStyleFrame, &isChild);
16509:   if (!isChild) {
24659:     mRootElementStyleFrame = mRootElementFrame;
16509:   }
16509: 
18953:   if (processChildren) {
18953:     // Still need to process the child content
    1:     nsFrameItems childItems;
    1: 
18953:     NS_ASSERTION(!nsLayoutUtils::GetAsBlock(contentFrame),
18953:                  "Only XUL and SVG frames should reach here");
28215:     ProcessChildren(state, aDocElement, styleContext, contentFrame, PR_TRUE,
23352:                     childItems, PR_FALSE);
    1: 
    1:     // Set the initial child lists
30785:     contentFrame->SetInitialChildList(nsnull, childItems);
    1:   }
    1: 
30941:   SetInitialSingleChild(mDocElementContainingBlock, *aNewFrame);
28215: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
28215: nsCSSFrameConstructor::ConstructRootFrame(nsIFrame** aNewFrame)
    1: {
    1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
    1:   NS_PRECONDITION(aNewFrame, "null out param");
    1: 
28215:   nsStyleSet *styleSet = mPresShell->StyleSet();
28215: 
28215:   // Set up our style rule observer.
28215:   // XXXbz wouldn't this make more sense as part of presshell init?
28215:   {
28215:     styleSet->SetBindingManager(mDocument->BindingManager());
28215:   }
28215: 
28215:   // --------- BUILD VIEWPORT -----------
28215:   nsIFrame*                 viewportFrame = nsnull;
28215:   nsRefPtr<nsStyleContext> viewportPseudoStyle;
28215: 
28215:   viewportPseudoStyle = styleSet->ResolvePseudoStyleFor(nsnull,
28215:                                                         nsCSSAnonBoxes::viewport,
28215:                                                         nsnull);
28215: 
28215:   viewportFrame = NS_NewViewportFrame(mPresShell, viewportPseudoStyle);
28215: 
28215:   // XXXbz do we _have_ to pass a null content pointer to that frame?
28215:   // Would it really kill us to pass in the root element or something?
28215:   // What would that break?
28215:   viewportFrame->Init(nsnull, nsnull, nsnull);
28215: 
28215:   // Bind the viewport frame to the root view
28215:   nsIView*        rootView;
28215:   mPresShell->GetViewManager()->GetRootView(rootView);
28215:   viewportFrame->SetView(rootView);
28215: 
28215:   nsContainerFrame::SyncFrameViewProperties(mPresShell->GetPresContext(), viewportFrame,
28215:                                             viewportPseudoStyle, rootView);
31401:   nsContainerFrame::SyncWindowProperties(mPresShell->GetPresContext(), viewportFrame,
31401:                                          rootView);
28215: 
28215:   // The viewport is the containing block for 'fixed' elements
28215:   mFixedContainingBlock = viewportFrame;
28215: 
28215:   *aNewFrame = viewportFrame;
28215:   return NS_OK;
28215: }
28215: 
28215: nsresult
28215: nsCSSFrameConstructor::SetUpDocElementContainingBlock(nsIContent* aDocElement)
28215: {
28215:   NS_PRECONDITION(aDocElement, "No element?");
28215:   NS_PRECONDITION(!aDocElement->GetParent(), "Not root content?");
28215:   NS_PRECONDITION(aDocElement->GetCurrentDoc(), "Not in a document?");
28215:   NS_PRECONDITION(aDocElement->GetCurrentDoc()->GetRootContent() ==
28215:                   aDocElement, "Not the root of the document?");
28215: 
    1:   /*
18953:     how the root frame hierarchy should look
18953: 
18953:   Galley presentation, non-XUL, with scrolling (i.e. not a frameset):
18953:   
18953:       ViewportFrame [fixed-cb]
18953:         nsHTMLScrollFrame
18953:           CanvasFrame [abs-cb]
18953:             root element frame (nsBlockFrame, nsSVGOuterSVGFrame,
18953:                                 nsTableOuterFrame, nsPlaceholderFrame)
18953: 
18953:   Galley presentation, non-XUL, without scrolling (i.e. a frameset):
18953:   
18953:       ViewportFrame [fixed-cb]
18953:         CanvasFrame [abs-cb]
18953:           root element frame (nsBlockFrame)
18953: 
18953:   Galley presentation, XUL
18953:   
18953:       ViewportFrame [fixed-cb]
18953:         nsRootBoxFrame
18953:           root element frame (nsDocElementBoxFrame)
18953: 
18953:   Print presentation, non-XUL
18953: 
18953:       ViewportFrame
18953:         nsSimplePageSequenceFrame
18953:           nsPageFrame [fixed-cb]
18953:             nsPageContentFrame
18953:               CanvasFrame [abs-cb]
18953:                 root element frame (nsBlockFrame, nsSVGOuterSVGFrame,
18953:                                     nsTableOuterFrame, nsPlaceholderFrame)
18953: 
18953:   Print-preview presentation, non-XUL
18953: 
18953:       ViewportFrame
18953:         nsHTMLScrollFrame
18953:           nsSimplePageSequenceFrame
18953:             nsPageFrame [fixed-cb]
18953:               nsPageContentFrame
18953:                 CanvasFrame [abs-cb]
18953:                   root element frame (nsBlockFrame, nsSVGOuterSVGFrame,
18953:                                       nsTableOuterFrame, nsPlaceholderFrame)
18953: 
18953:   Print/print preview of XUL is not supported.
18953:   [fixed-cb]: the default containing block for fixed-pos content
18953:   [abs-cb]: the default containing block for abs-pos content
18953:  
18953:   Meaning of nsCSSFrameConstructor fields:
28215:     mRootElementFrame is "root element frame".  This is the primary frame for
28215:       the root element.
24659:     mDocElementContainingBlock is the parent of mRootElementFrame
18953:       (i.e. CanvasFrame or nsRootBoxFrame)
18953:     mFixedContainingBlock is the [fixed-cb]
18953:     mGfxScrollFrame is the nsHTMLScrollFrame mentioned above, or null if there isn't one
18953:     mPageSequenceFrame is the nsSimplePageSequenceFrame, or null if there isn't one
    1:   */
    1: 
    1:   // --------- CREATE ROOT FRAME -------
    1: 
    1: 
    1:   // Create the root frame. The document element's frame is a child of the
    1:   // root frame.
    1:   //
    1:   // The root frame serves two purposes:
    1:   // - reserves space for any margins needed for the document element's frame
    1:   // - renders the document element's background. This ensures the background covers
    1:   //   the entire canvas as specified by the CSS2 spec
    1: 
28215:   nsPresContext* presContext = mPresShell->GetPresContext();
    1:   PRBool isPaginated = presContext->IsRootPaginatedDocument();
28215:   nsIFrame* viewportFrame = mFixedContainingBlock;
28215:   nsStyleContext* viewportPseudoStyle = viewportFrame->GetStyleContext();
    1: 
    1:   nsIFrame* rootFrame = nsnull;
    1:   nsIAtom* rootPseudo;
    1:         
    1:   if (!isPaginated) {
    1: #ifdef MOZ_XUL
33329:     if (aDocElement->IsXUL())
    1:     {
    1:       // pass a temporary stylecontext, the correct one will be set later
    1:       rootFrame = NS_NewRootBoxFrame(mPresShell, viewportPseudoStyle);
    1:     } else
    1: #endif
    1:     {
    1:       // pass a temporary stylecontext, the correct one will be set later
    1:       rootFrame = NS_NewCanvasFrame(mPresShell, viewportPseudoStyle);
18953:       mHasRootAbsPosContainingBlock = PR_TRUE;
    1:     }
    1: 
    1:     rootPseudo = nsCSSAnonBoxes::canvas;
    1:     mDocElementContainingBlock = rootFrame;
    1:   } else {
    1:     // Create a page sequence frame
    1:     rootFrame = NS_NewSimplePageSequenceFrame(mPresShell, viewportPseudoStyle);
    1:     mPageSequenceFrame = rootFrame;
    1:     rootPseudo = nsCSSAnonBoxes::pageSequence;
    1:   }
    1: 
    1: 
    1:   // --------- IF SCROLLABLE WRAP IN SCROLLFRAME --------
    1: 
    1:   // If the device supports scrolling (e.g., in galley mode on the screen and
    1:   // for print-preview, but not when printing), then create a scroll frame that
    1:   // will act as the scrolling mechanism for the viewport. 
    1:   // XXX Do we even need a viewport when printing to a printer?
    1: 
28078:   // As long as the docshell doesn't prohibit it, and the device supports
    1:   // it, create a scroll frame that will act as the scolling mechanism for
    1:   // the viewport.
    1:   //
    1:   // Threre are three possible values stored in the docshell:
    1:   //  1) nsIScrollable::Scrollbar_Never = no scrollbars
    1:   //  2) nsIScrollable::Scrollbar_Auto = scrollbars appear if needed
    1:   //  3) nsIScrollable::Scrollbar_Always = scrollbars always
    1:   // Only need to create a scroll frame/view for cases 2 and 3.
    1: 
33329:   PRBool isHTML = aDocElement->IsHTML();
    1:   PRBool isXUL = PR_FALSE;
    1: 
    1:   if (!isHTML) {
33329:     isXUL = aDocElement->IsXUL();
    1:   }
    1: 
    1:   // Never create scrollbars for XUL documents
    1:   PRBool isScrollable = !isXUL;
    1: 
    1:   // Never create scrollbars for frameset documents.
    1:   if (isHTML) {
    1:     nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(mDocument);
    1:     if (htmlDoc && htmlDoc->GetIsFrameset())
    1:       isScrollable = PR_FALSE;
    1:   }
    1: 
    1:   if (isPaginated) {
    1:     isScrollable = presContext->HasPaginatedScrolling();
    1:   }
    1: 
    1:   // We no longer need to do overflow propagation here. It's taken care of
    1:   // when we construct frames for the element whose overflow might be
    1:   // propagated
    1:   NS_ASSERTION(!isScrollable || !isXUL,
    1:                "XUL documents should never be scrollable - see above");
    1: 
    1:   nsIFrame* newFrame = rootFrame;
    1:   nsRefPtr<nsStyleContext> rootPseudoStyle;
    1:   // we must create a state because if the scrollbars are GFX it needs the 
    1:   // state to build the scrollbar frames.
    1:   nsFrameConstructorState state(mPresShell, nsnull, nsnull, nsnull);
    1: 
28215:   // Start off with the viewport as parent; we'll adjust it as needed.
    1:   nsIFrame* parentFrame = viewportFrame;
    1: 
28215:   nsStyleSet* styleSet = mPresShell->StyleSet();
    1:   // If paginated, make sure we don't put scrollbars in
    1:   if (!isScrollable) {
    1:     rootPseudoStyle = styleSet->ResolvePseudoStyleFor(nsnull,
    1:                                                       rootPseudo,
    1:                                                       viewportPseudoStyle);
    1:   } else {
    1:       if (rootPseudo == nsCSSAnonBoxes::canvas) {
    1:         rootPseudo = nsCSSAnonBoxes::scrolledCanvas;
    1:       } else {
    1:         NS_ASSERTION(rootPseudo == nsCSSAnonBoxes::pageSequence,
    1:                      "Unknown root pseudo");
    1:         rootPseudo = nsCSSAnonBoxes::scrolledPageSequence;
    1:       }
    1: 
28215:       // Build the frame. We give it the content we are wrapping which is the
28215:       // document element, the root frame, the parent view port frame, and we
28215:       // should get back the new frame and the scrollable view if one was
28215:       // created.
    1: 
    1:       // resolve a context for the scrollframe
    1:       nsRefPtr<nsStyleContext>  styleContext;
    1:       styleContext = styleSet->ResolvePseudoStyleFor(nsnull,
    1:                                                      nsCSSAnonBoxes::viewportScroll,
    1:                                                      viewportPseudoStyle);
    1: 
    1:       // Note that the viewport scrollframe is always built with
    1:       // overflow:auto style. This forces the scroll frame to create
    1:       // anonymous content for both scrollbars. This is necessary even
    1:       // if the HTML or BODY elements are overriding the viewport
    1:       // scroll style to 'hidden' --- dynamic style changes might put
    1:       // scrollbars back on the viewport and we don't want to have to
    1:       // reframe the viewport to create the scrollbar content.
    1:       newFrame = nsnull;
    1:       rootPseudoStyle = BeginBuildingScrollFrame( state,
    1:                                                   aDocElement,
    1:                                                   styleContext,
    1:                                                   viewportFrame,
    1:                                                   rootPseudo,
    1:                                                   PR_TRUE,
    1:                                                   newFrame);
    1: 
23554:       nsIScrollableFrame* scrollable = do_QueryFrame(newFrame);
    1:       NS_ENSURE_TRUE(scrollable, NS_ERROR_FAILURE);
    1: 
    1:       nsIScrollableView* scrollableView = scrollable->GetScrollableView();
    1:       NS_ENSURE_TRUE(scrollableView, NS_ERROR_FAILURE);
    1: 
28215:       mPresShell->GetViewManager()->SetRootScrollableView(scrollableView);
    1:       parentFrame = newFrame;
    1: 
    1:       mGfxScrollFrame = newFrame;
    1:   }
    1:   
    1:   rootFrame->SetStyleContextWithoutNotification(rootPseudoStyle);
    1:   rootFrame->Init(aDocElement, parentFrame, nsnull);
    1:   
    1:   if (isScrollable) {
    1:     FinishBuildingScrollFrame(parentFrame, rootFrame);
    1:   }
    1:   
    1:   if (isPaginated) { // paginated
    1:     // Create the first page
    1:     // Set the initial child lists
18953:     nsIFrame *pageFrame, *canvasFrame;
    1:     ConstructPageFrame(mPresShell, presContext, rootFrame, nsnull,
18953:                        pageFrame, canvasFrame);
30790:     SetInitialSingleChild(rootFrame, pageFrame);
    1: 
    1:     // The eventual parent of the document element frame.
    1:     // XXX should this be set for every new page (in ConstructPageFrame)?
18953:     mDocElementContainingBlock = canvasFrame;
18953:     mHasRootAbsPosContainingBlock = PR_TRUE;
    1:   }
    1: 
28215:   if (viewportFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW) {
32846:     SetInitialSingleChild(viewportFrame, newFrame);
28215:   } else {
32846:     nsFrameList newFrameList(newFrame, newFrame);
30941:     viewportFrame->AppendFrames(nsnull, newFrameList);
28215:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructPageFrame(nsIPresShell*  aPresShell,
    1:                                           nsPresContext* aPresContext,
    1:                                           nsIFrame*      aParentFrame,
    1:                                           nsIFrame*      aPrevPageFrame,
    1:                                           nsIFrame*&     aPageFrame,
18953:                                           nsIFrame*&     aCanvasFrame)
    1: {
    1:   nsStyleContext* parentStyleContext = aParentFrame->GetStyleContext();
    1:   nsStyleSet *styleSet = aPresShell->StyleSet();
    1: 
    1:   nsRefPtr<nsStyleContext> pagePseudoStyle;
    1:   pagePseudoStyle = styleSet->ResolvePseudoStyleFor(nsnull,
    1:                                                     nsCSSAnonBoxes::page,
    1:                                                     parentStyleContext);
    1: 
    1:   aPageFrame = NS_NewPageFrame(aPresShell, pagePseudoStyle);
    1:   if (NS_UNLIKELY(!aPageFrame))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   // Initialize the page frame and force it to have a view. This makes printing of
    1:   // the pages easier and faster.
    1:   aPageFrame->Init(nsnull, aParentFrame, aPrevPageFrame);
    1: 
    1:   nsRefPtr<nsStyleContext> pageContentPseudoStyle;
    1:   pageContentPseudoStyle = styleSet->ResolvePseudoStyleFor(nsnull,
    1:                                                            nsCSSAnonBoxes::pageContent,
    1:                                                            pagePseudoStyle);
    1: 
18953:   nsIFrame* pageContentFrame = NS_NewPageContentFrame(aPresShell, pageContentPseudoStyle);
18953:   if (NS_UNLIKELY(!pageContentFrame))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   // Initialize the page content frame and force it to have a view. Also make it the
    1:   // containing block for fixed elements which are repeated on every page.
 4006:   nsIFrame* prevPageContentFrame = nsnull;
 4006:   if (aPrevPageFrame) {
 4006:     prevPageContentFrame = aPrevPageFrame->GetFirstChild(nsnull);
 4006:     NS_ASSERTION(prevPageContentFrame, "missing page content frame");
 4006:   }
18953:   pageContentFrame->Init(nsnull, aPageFrame, prevPageContentFrame);
30790:   SetInitialSingleChild(aPageFrame, pageContentFrame);
18953:   mFixedContainingBlock = pageContentFrame;
18953: 
18953:   nsRefPtr<nsStyleContext> canvasPseudoStyle;
18953:   canvasPseudoStyle = styleSet->ResolvePseudoStyleFor(nsnull,
18953:                                                       nsCSSAnonBoxes::canvas,
18953:                                                       pageContentPseudoStyle);
18953: 
18953:   aCanvasFrame = NS_NewCanvasFrame(aPresShell, canvasPseudoStyle);
18953:   if (NS_UNLIKELY(!aCanvasFrame))
18953:     return NS_ERROR_OUT_OF_MEMORY;
18953: 
18953:   nsIFrame* prevCanvasFrame = nsnull;
18953:   if (prevPageContentFrame) {
18953:     prevCanvasFrame = prevPageContentFrame->GetFirstChild(nsnull);
18953:     NS_ASSERTION(prevCanvasFrame, "missing canvas frame");
18953:   }
18953:   aCanvasFrame->Init(nsnull, pageContentFrame, prevCanvasFrame);
30790:   SetInitialSingleChild(pageContentFrame, aCanvasFrame);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* static */
    1: nsresult
    1: nsCSSFrameConstructor::CreatePlaceholderFrameFor(nsIPresShell*    aPresShell, 
    1:                                                  nsIContent*      aContent,
    1:                                                  nsIFrame*        aFrame,
    1:                                                  nsStyleContext*  aStyleContext,
    1:                                                  nsIFrame*        aParentFrame,
 6219:                                                  nsIFrame*        aPrevInFlow,
    1:                                                  nsIFrame**       aPlaceholderFrame)
    1: {
    1:   nsRefPtr<nsStyleContext> placeholderStyle = aPresShell->StyleSet()->
    1:     ResolveStyleForNonElement(aStyleContext->GetParent());
    1:   
    1:   // The placeholder frame gets a pseudo style context
    1:   nsPlaceholderFrame* placeholderFrame =
    1:     (nsPlaceholderFrame*)NS_NewPlaceholderFrame(aPresShell, placeholderStyle);
    1: 
    1:   if (placeholderFrame) {
 6219:     placeholderFrame->Init(aContent, aParentFrame, aPrevInFlow);
    1:   
    1:     // The placeholder frame has a pointer back to the out-of-flow frame
    1:     placeholderFrame->SetOutOfFlowFrame(aFrame);
    1:   
    1:     aFrame->AddStateBits(NS_FRAME_OUT_OF_FLOW);
    1: 
    1:     // Add mapping from absolutely positioned frame to its placeholder frame
 6219:     aPresShell->FrameManager()->RegisterPlaceholderFrame(placeholderFrame);
    1: 
 3233:     *aPlaceholderFrame = static_cast<nsIFrame*>(placeholderFrame);
    1:     
    1:     return NS_OK;
    1:   }
    1:   else {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructButtonFrame(nsFrameConstructorState& aState,
25769:                                             FrameConstructionItem&   aItem,
    1:                                             nsIFrame*                aParentFrame,
    1:                                             const nsStyleDisplay*    aStyleDisplay,
 4461:                                             nsFrameItems&            aFrameItems,
23944:                                             nsIFrame**               aNewFrame)
23944: {
    1:   *aNewFrame = nsnull;
    1:   nsIFrame* buttonFrame = nsnull;
25769:   nsIContent* const content = aItem.mContent;
25769:   nsStyleContext* const styleContext = aItem.mStyleContext;
25769: 
25769:   if (nsGkAtoms::button == aItem.mTag) {
25769:     buttonFrame = NS_NewHTMLButtonControlFrame(mPresShell, styleContext);
    1:   }
    1:   else {
25769:     buttonFrame = NS_NewGfxButtonControlFrame(mPresShell, styleContext);
    1:   }
    1:   if (NS_UNLIKELY(!buttonFrame)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   // Initialize the button frame
25769:   nsresult rv = InitAndRestoreFrame(aState, content,
    1:                                     aState.GetGeometricParent(aStyleDisplay, aParentFrame),
    1:                                     nsnull, buttonFrame);
    1:   if (NS_FAILED(rv)) {
    1:     buttonFrame->Destroy();
    1:     return rv;
    1:   }
23395:   // See if we need to create a view
23395:   nsHTMLContainerFrame::CreateViewForFrame(buttonFrame, PR_FALSE);
    1: 
25769:   nsRefPtr<nsStyleContext> innerBlockContext;
25769:   innerBlockContext =
25769:     mPresShell->StyleSet()->ResolvePseudoStyleFor(content,
    1:                                                   nsCSSAnonBoxes::buttonContent,
25769:                                                   styleContext);
25769:                                                                
25769:   nsIFrame* blockFrame = NS_NewBlockFrame(mPresShell, innerBlockContext,
23305:                                           NS_BLOCK_FLOAT_MGR);
23167: 
23176:   if (NS_UNLIKELY(!blockFrame)) {
    1:     buttonFrame->Destroy();
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
25769:   rv = InitAndRestoreFrame(aState, content, buttonFrame, nsnull, blockFrame);
    1:   if (NS_FAILED(rv)) {
23176:     blockFrame->Destroy();
    1:     buttonFrame->Destroy();
    1:     return rv;
    1:   }
    1: 
25769:   rv = aState.AddChild(buttonFrame, aFrameItems, content, styleContext,
 8199:                        aParentFrame);
    1:   if (NS_FAILED(rv)) {
23176:     blockFrame->Destroy();
    1:     buttonFrame->Destroy();
    1:     return rv;
    1:   }
    1: 
23343:   PRBool isLeaf = buttonFrame->IsLeaf();
23343: #ifdef DEBUG
23343:   // Make sure that we're an anonymous content creator exactly when we're a
23343:   // leaf
23554:   nsIAnonymousContentCreator* creator = do_QueryFrame(buttonFrame);
23343:   NS_ASSERTION(!creator == !isLeaf,
23343:                "Should be creator exactly when we're a leaf");
23343: #endif
23343:   
23343:   if (!isLeaf) { 
    1:     // Process children
    1:     nsFrameConstructorSaveState absoluteSaveState;
    1:     nsFrameItems                childItems;
    1: 
    1:     if (aStyleDisplay->IsPositioned()) {
    1:       // The area frame becomes a container for child frames that are
    1:       // absolutely positioned
23176:       aState.PushAbsoluteContainingBlock(blockFrame, absoluteSaveState);
23176:     }
23176: 
23343: #ifdef DEBUG
23343:     // Make sure that anonymous child creation will have no effect in this case
23554:     nsIAnonymousContentCreator* creator = do_QueryFrame(blockFrame);
23343:     NS_ASSERTION(!creator, "Shouldn't be an anonymous content creator!");
23343: #endif
23343: 
25769:     rv = ProcessChildren(aState, content, styleContext, blockFrame, PR_TRUE,
29109:                          childItems, aStyleDisplay->IsBlockInside());
    1:     if (NS_FAILED(rv)) return rv;
    1:   
    1:     // Set the areas frame's initial child lists
30785:     blockFrame->SetInitialChildList(nsnull, childItems);
23176:   }
23176: 
30790:   SetInitialSingleChild(buttonFrame, blockFrame);
23167: 
23343:   if (isLeaf) {
    1:     nsFrameItems  anonymousChildItems;
23343:     // if there are any anonymous children create frames for them.  Note that
23343:     // we're doing this using a different parent frame from the one we pass to
23343:     // ProcessChildren!
25769:     CreateAnonymousFrames(aState, content, buttonFrame, anonymousChildItems);
30785:     if (anonymousChildItems.NotEmpty()) {
    1:       // the anonymous content is already parented to the area frame
23176:       aState.mFrameManager->AppendFrames(blockFrame, nsnull,
30941:                                          anonymousChildItems);
23167:     }
    1:   }
    1: 
    1:   // our new button frame returned is the top frame. 
    1:   *aNewFrame = buttonFrame; 
    1: 
    1:   return NS_OK;  
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructSelectFrame(nsFrameConstructorState& aState,
25769:                                             FrameConstructionItem&   aItem,
    1:                                             nsIFrame*                aParentFrame,
    1:                                             const nsStyleDisplay*    aStyleDisplay,
23944:                                             nsFrameItems&            aFrameItems,
23944:                                             nsIFrame**               aNewFrame)
    1: {
    1:   nsresult rv = NS_OK;
    1:   const PRInt32 kNoSizeSpecified = -1;
    1: 
25769:   nsIContent* const content = aItem.mContent;
25769:   nsStyleContext* const styleContext = aItem.mStyleContext;
25769: 
    1:   // Construct a frame-based listbox or combobox
25769:   nsCOMPtr<nsIDOMHTMLSelectElement> sel(do_QueryInterface(content));
    1:   PRInt32 size = 1;
    1:   if (sel) {
    1:     sel->GetSize(&size); 
    1:     PRBool multipleSelect = PR_FALSE;
    1:     sel->GetMultiple(&multipleSelect);
    1:      // Construct a combobox if size=1 or no size is specified and its multiple select
    1:     if (((1 == size || 0 == size) || (kNoSizeSpecified  == size)) && (PR_FALSE == multipleSelect)) {
    1:         // Construct a frame-based combo box.
    1:         // The frame-based combo box is built out of three parts. A display area, a button and
    1:         // a dropdown list. The display area and button are created through anonymous content.
    1:         // The drop-down list's frame is created explicitly. The combobox frame shares its content
    1:         // with the drop-down list.
23305:       PRUint32 flags = NS_BLOCK_FLOAT_MGR;
25769:       nsIFrame* comboboxFrame = NS_NewComboboxControlFrame(mPresShell, styleContext, flags);
    1: 
    1:       // Save the history state so we don't restore during construction
    1:       // since the complete tree is required before we restore.
    1:       nsILayoutHistoryState *historyState = aState.mFrameState;
    1:       aState.mFrameState = nsnull;
    1:       // Initialize the combobox frame
25769:       InitAndRestoreFrame(aState, content,
    1:                           aState.GetGeometricParent(aStyleDisplay, aParentFrame),
    1:                           nsnull, comboboxFrame);
    1: 
23395:       nsHTMLContainerFrame::CreateViewForFrame(comboboxFrame, PR_FALSE);
    1: 
25769:       rv = aState.AddChild(comboboxFrame, aFrameItems, content, styleContext,
 8199:                            aParentFrame);
    1:       if (NS_FAILED(rv)) {
    1:         return rv;
    1:       }
    1:       
    1:       ///////////////////////////////////////////////////////////////////
    1:       // Combobox - Old Native Implementation
    1:       ///////////////////////////////////////////////////////////////////
23554:       nsIComboboxControlFrame* comboBox = do_QueryFrame(comboboxFrame);
    1:       NS_ASSERTION(comboBox, "NS_NewComboboxControlFrame returned frame that "
    1:                              "doesn't implement nsIComboboxControlFrame");
    1: 
    1:         // Resolve pseudo element style for the dropdown list
    1:       nsRefPtr<nsStyleContext> listStyle;
25769:       listStyle = mPresShell->StyleSet()->ResolvePseudoStyleFor(content,
    1:                                                                 nsCSSAnonBoxes::dropDownList, 
25769:                                                                 styleContext);
    1: 
    1:         // Create a listbox
    1:       nsIFrame* listFrame = NS_NewListControlFrame(mPresShell, listStyle);
    1: 
    1:         // Notify the listbox that it is being used as a dropdown list.
23554:       nsIListControlFrame * listControlFrame = do_QueryFrame(listFrame);
23554:       if (listControlFrame) {
    1:         listControlFrame->SetComboboxFrame(comboboxFrame);
    1:       }
    1:          // Notify combobox that it should use the listbox as it's popup
    1:       comboBox->SetDropDown(listFrame);
    1: 
    1:       NS_ASSERTION(!listStyle->GetStyleDisplay()->IsPositioned(),
    1:                    "Ended up with positioned dropdown list somehow.");
    1:       NS_ASSERTION(!listStyle->GetStyleDisplay()->IsFloating(),
    1:                    "Ended up with floating dropdown list somehow.");
    1:       
    1:       // Initialize the scroll frame positioned. Note that it is NOT
    1:       // initialized as absolutely positioned.
25769:       nsIFrame* scrolledFrame = NS_NewSelectsAreaFrame(mPresShell, styleContext, flags);
25769: 
25769:       InitializeSelectFrame(aState, listFrame, scrolledFrame, content,
    1:                             comboboxFrame, listStyle, PR_TRUE, aFrameItems);
    1: 
    1:         // Set flag so the events go to the listFrame not child frames.
    1:         // XXX: We should replace this with a real widget manager similar
    1:         // to how the nsFormControlFrame works. Re-directing events is a temporary Kludge.
    1:       NS_ASSERTION(listFrame->GetView(), "ListFrame's view is nsnull");
    1:       //listFrame->GetView()->SetViewFlags(NS_VIEW_PUBLIC_FLAG_DONT_CHECK_CHILDREN);
    1: 
    1:       // Create display and button frames from the combobox's anonymous content.
    1:       // The anonymous content is appended to existing anonymous content for this
    1:       // element (the scrollbars).
    1: 
    1:       nsFrameItems childItems;
25769:       CreateAnonymousFrames(aState, content, comboboxFrame, childItems);
    1:   
30785:       comboboxFrame->SetInitialChildList(nsnull, childItems);
    1: 
    1:       // Initialize the additional popup child list which contains the
    1:       // dropdown list frame.
    1:       nsFrameItems popupItems;
    1:       popupItems.AddChild(listFrame);
 4448:       comboboxFrame->SetInitialChildList(nsGkAtoms::selectPopupList,
30785:                                          popupItems);
    1: 
23944:       *aNewFrame = comboboxFrame;
    1:       aState.mFrameState = historyState;
    1:       if (aState.mFrameState && aState.mFrameManager) {
    1:         // Restore frame state for the entire subtree of |comboboxFrame|.
    1:         aState.mFrameManager->RestoreFrameState(comboboxFrame,
    1:                                                 aState.mFrameState);
    1:       }
    1:     } else {
    1:       ///////////////////////////////////////////////////////////////////
    1:       // ListBox - Old Native Implementation
    1:       ///////////////////////////////////////////////////////////////////
25769:       nsIFrame* listFrame = NS_NewListControlFrame(mPresShell, styleContext);
    1:       if (listFrame) {
    1:         rv = NS_OK;
    1:       }
    1:       else {
    1:         rv = NS_ERROR_OUT_OF_MEMORY;
    1:       }
    1: 
    1:       nsIFrame* scrolledFrame = NS_NewSelectsAreaFrame(
25769:         mPresShell, styleContext, NS_BLOCK_FLOAT_MGR);
    1: 
    1:       // ******* this code stolen from Initialze ScrollFrame ********
    1:       // please adjust this code to use BuildScrollFrame.
    1: 
25769:       InitializeSelectFrame(aState, listFrame, scrolledFrame, content,
25769:                             aParentFrame, styleContext, PR_FALSE, aFrameItems);
    1: 
23944:       *aNewFrame = listFrame;
    1:     }
    1:   }
    1:   return rv;
    1: 
    1: }
    1: 
    1: /**
    1:  * Used to be InitializeScrollFrame but now it's only used for the select tag
    1:  * But the select tag should really be fixed to use GFX scrollbars that can
    1:  * be create with BuildScrollFrame.
    1:  */
    1: nsresult
    1: nsCSSFrameConstructor::InitializeSelectFrame(nsFrameConstructorState& aState,
    1:                                              nsIFrame*                scrollFrame,
    1:                                              nsIFrame*                scrolledFrame,
    1:                                              nsIContent*              aContent,
    1:                                              nsIFrame*                aParentFrame,
    1:                                              nsStyleContext*          aStyleContext,
    1:                                              PRBool                   aBuildCombobox,
    1:                                              nsFrameItems&            aFrameItems)
    1: {
    1:   const nsStyleDisplay* display = aStyleContext->GetStyleDisplay();
    1: 
    1:   // Initialize it
    1:   nsIFrame* geometricParent = aState.GetGeometricParent(display, aParentFrame);
    1:     
    1:   // We don't call InitAndRestoreFrame for scrollFrame because we can only
    1:   // restore the frame state after its parts have been created (in particular,
    1:   // the scrollable view). So we have to split Init and Restore.
    1: 
    1:   // Initialize the frame
    1:   scrollFrame->Init(aContent, geometricParent, nsnull);
    1: 
    1:   if (!aBuildCombobox) {
 8199:     nsresult rv = aState.AddChild(scrollFrame, aFrameItems, aContent,
 8199:                                   aStyleContext, aParentFrame);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
    1:   }
    1:       
23395:   nsHTMLContainerFrame::CreateViewForFrame(scrollFrame, aBuildCombobox);
    1:   if (aBuildCombobox) {
    1:     // Give the drop-down list a popup widget
    1:     nsIView* view = scrollFrame->GetView();
    1:     NS_ASSERTION(view, "We asked for a view but didn't get one");
    1:     if (view) {
    1:       view->GetViewManager()->SetViewFloating(view, PR_TRUE);
    1: 
    1:       nsWidgetInitData widgetData;
    1:       widgetData.mWindowType  = eWindowType_popup;
    1:       widgetData.mBorderStyle = eBorderStyle_default;
    1: 
    1: #if defined(XP_MACOSX) || defined(XP_BEOS) 
    1:       static NS_DEFINE_IID(kCPopUpCID,  NS_POPUP_CID);
    1:       view->CreateWidget(kCPopUpCID, &widgetData, nsnull);
    1: #else
    1:       static NS_DEFINE_IID(kCChildCID, NS_CHILD_CID);
    1:       view->CreateWidget(kCChildCID, &widgetData, nsnull);
    1: #endif
    1:     }
    1:   }
    1: 
    1:   BuildScrollFrame(aState, aContent, aStyleContext, scrolledFrame,
23950:                    geometricParent, scrollFrame);
    1: 
    1:   if (aState.mFrameState && aState.mFrameManager) {
    1:     // Restore frame state for the scroll frame
    1:     aState.mFrameManager->RestoreFrameStateFor(scrollFrame, aState.mFrameState);
    1:   }
    1: 
    1:   // Process children
    1:   nsFrameConstructorSaveState absoluteSaveState;
    1:   nsFrameItems                childItems;
    1: 
    1:   if (display->IsPositioned()) {
    1:     // The area frame becomes a container for child frames that are
    1:     // absolutely positioned
    1:     aState.PushAbsoluteContainingBlock(scrolledFrame, absoluteSaveState);
    1:   }
    1: 
23352:   ProcessChildren(aState, aContent, aStyleContext, scrolledFrame, PR_FALSE,
    1:                   childItems, PR_TRUE);
    1: 
    1:   // Set the scrolled frame's initial child lists
30785:   scrolledFrame->SetInitialChildList(nsnull, childItems);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructFieldSetFrame(nsFrameConstructorState& aState,
25769:                                               FrameConstructionItem&   aItem,
    1:                                               nsIFrame*                aParentFrame,
23944:                                               const nsStyleDisplay*    aStyleDisplay,
    1:                                               nsFrameItems&            aFrameItems,
23944:                                               nsIFrame**               aNewFrame)
    1: {
25769:   nsIContent* const content = aItem.mContent;
25769:   nsStyleContext* const styleContext = aItem.mStyleContext;
25769: 
25769:   nsIFrame* newFrame = NS_NewFieldSetFrame(mPresShell, styleContext);
    1:   if (NS_UNLIKELY(!newFrame)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   // Initialize it
25769:   InitAndRestoreFrame(aState, content,
    1:                       aState.GetGeometricParent(aStyleDisplay, aParentFrame),
    1:                       nsnull, newFrame);
    1: 
    1:   // See if we need to create a view, e.g. the frame is absolutely
    1:   // positioned
23395:   nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1: 
    1:   // Resolve style and initialize the frame
25769:   nsRefPtr<nsStyleContext> fieldsetContentStyle;
25769:   fieldsetContentStyle =
25769:     mPresShell->StyleSet()->ResolvePseudoStyleFor(content,
    1:                                                   nsCSSAnonBoxes::fieldsetContent,
25769:                                                   styleContext);
25769: 
25769:   nsIFrame* blockFrame = NS_NewBlockFrame(mPresShell, fieldsetContentStyle,
23305:                                           NS_BLOCK_FLOAT_MGR |
23176:                                           NS_BLOCK_MARGIN_ROOT);
25769:   InitAndRestoreFrame(aState, content, newFrame, nsnull, blockFrame);
25769: 
25769:   nsresult rv = aState.AddChild(newFrame, aFrameItems, content, styleContext,
 8199:                                 aParentFrame);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1:   
    1:   // Process children
    1:   nsFrameConstructorSaveState absoluteSaveState;
    1:   nsFrameItems                childItems;
    1: 
    1:   if (aStyleDisplay->IsPositioned()) {
    1:     // The area frame becomes a container for child frames that are
    1:     // absolutely positioned
23352:     // XXXbz this is probably wrong, and once arbitrary frames can be absolute
23352:     // containing blocks we should fix this..
23176:     aState.PushAbsoluteContainingBlock(blockFrame, absoluteSaveState);
23176:   }
23176: 
25769:   ProcessChildren(aState, content, styleContext, blockFrame, PR_TRUE,
    1:                   childItems, PR_TRUE);
    1: 
30790:   nsFrameItems fieldsetKids;
30790:   fieldsetKids.AddChild(blockFrame);
30790: 
33388:   for (nsFrameList::Enumerator e(childItems); !e.AtEnd(); e.Next()) {
33388:     nsLegendFrame* legendFrame = do_QueryFrame(e.get());
23554:     if (legendFrame) {
    1:       // We want the legend to be the first frame in the fieldset child list.
    1:       // That way the EventStateManager will do the right thing when tabbing
    1:       // from a selection point within the legend (bug 236071), which is
    1:       // used for implementing legend access keys (bug 81481).
    1:       // GetAdjustedParentFrame() below depends on this frame order.
33388:       childItems.RemoveFrame(legendFrame);
30790:       // Make sure to reparent the legend so it has the fieldset as the parent.
30790:       fieldsetKids.InsertFrame(newFrame, nsnull, legendFrame);
    1:       break;
    1:     }
30790:   }
30790: 
30790:   // Set the inner frame's initial child lists
30785:   blockFrame->SetInitialChildList(nsnull, childItems);
    1: 
30790:   // Set the outer frame's initial child list
30790:   newFrame->SetInitialChildList(nsnull, fieldsetKids);
    1: 
    1:   // our new frame returned is the top frame which is the list frame. 
23944:   *aNewFrame = newFrame; 
    1: 
    1:   return NS_OK;
    1: }
    1: 
16976: static nsIFrame*
16976: FindAncestorWithGeneratedContentPseudo(nsIFrame* aFrame)
16976: {
16976:   for (nsIFrame* f = aFrame->GetParent(); f; f = f->GetParent()) {
16976:     NS_ASSERTION(f->IsGeneratedContentFrame(),
16976:                  "should not have exited generated content");
16976:     nsIAtom* pseudo = f->GetStyleContext()->GetPseudoType();
16976:     if (pseudo == nsCSSPseudoElements::before ||
16976:         pseudo == nsCSSPseudoElements::after)
16976:       return f;
16976:   }
16976:   return nsnull;
16976: }
16976: 
23955: #define SIMPLE_FCDATA(_func) FCDATA_DECL(0, _func)
25131: #define FULL_CTOR_FCDATA(_flags, _func)                     \
25131:   { _flags | FCDATA_FUNC_IS_FULL_CTOR, { nsnull }, _func }
23955: 
23955: /* static */
23955: const nsCSSFrameConstructor::FrameConstructionData*
23955: nsCSSFrameConstructor::FindTextData(nsIFrame* aParentFrame)
23955: {
23167: #ifdef MOZ_SVG
25772:   if (aParentFrame && aParentFrame->IsFrameOfType(nsIFrame::eSVG)) {
23953:     nsIFrame *ancestorFrame =
23953:       nsSVGUtils::GetFirstNonAAncestorFrame(aParentFrame);
23167:     if (ancestorFrame) {
29052:       nsSVGTextContainerFrame* metrics = do_QueryFrame(ancestorFrame);
23955:       if (metrics) {
23955:         static const FrameConstructionData sSVGGlyphData =
23955:           SIMPLE_FCDATA(NS_NewSVGGlyphFrame);
23955:         return &sSVGGlyphData;
23955:       }
23955:     }
23955:     return nsnull;
23955:   }
23955: #endif
23955: 
25773:   static const FrameConstructionData sTextData =
25773:     FCDATA_DECL(FCDATA_IS_LINE_PARTICIPANT, NS_NewTextFrame);
23955:   return &sTextData;
23955: }
23955: 
23955: nsresult
23955: nsCSSFrameConstructor::ConstructTextFrame(const FrameConstructionData* aData,
23955:                                           nsFrameConstructorState& aState,
    1:                                           nsIContent*              aContent,
    1:                                           nsIFrame*                aParentFrame,
    1:                                           nsStyleContext*          aStyleContext,
26208:                                           nsFrameItems&            aFrameItems)
    1: {
25131:   NS_PRECONDITION(aData, "Must have frame construction data");
23955: 
23955:   nsIFrame* newFrame = (*aData->mFunc.mCreationFunc)(mPresShell, aStyleContext);
    1: 
    1:   if (NS_UNLIKELY(!newFrame))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   nsresult rv = InitAndRestoreFrame(aState, aContent, aParentFrame,
    1:                                     nsnull, newFrame);
    1: 
    1:   if (NS_FAILED(rv)) {
    1:     newFrame->Destroy();
    1:     return rv;
    1:   }
    1: 
    1:   // We never need to create a view for a text frame.
    1: 
16976:   if (newFrame->IsGeneratedContentFrame()) {
16976:     nsAutoPtr<nsGenConInitializer> initializer;
16976:     initializer =
16976:       static_cast<nsGenConInitializer*>(
16976:         aContent->UnsetProperty(nsGkAtoms::genConInitializerProperty));
16976:     if (initializer) {
16976:       if (initializer->mNode->InitTextFrame(initializer->mList,
16976:               FindAncestorWithGeneratedContentPseudo(newFrame), newFrame)) {
16976:         (this->*(initializer->mDirtyAll))();
16976:       }
16976:       initializer->mNode.forget();
16976:     }
16976:   }
    1:   
    1:   // Add the newly constructed frame to the flow
    1:   aFrameItems.AddChild(newFrame);
    1: 
    1:   // Text frames don't go in the content->frame hash table, because
    1:   // they're anonymous. This keeps the hash table smaller
    1: 
    1:   return rv;
    1: }
    1: 
23944: /* static */
23944: const nsCSSFrameConstructor::FrameConstructionData*
23944: nsCSSFrameConstructor::FindDataByInt(PRInt32 aInt,
23167:                                      nsIContent* aContent,
23944:                                      nsStyleContext* aStyleContext,
23944:                                      const FrameConstructionDataByInt* aDataPtr,
23944:                                      PRUint32 aDataLength)
23944: {
23944:   for (const FrameConstructionDataByInt *curData = aDataPtr,
23944:          *endData = aDataPtr + aDataLength;
23944:        curData != endData;
23944:        ++curData) {
23944:     if (curData->mInt == aInt) {
23944:       const FrameConstructionData* data = &curData->mData;
23944:       if (data->mBits & FCDATA_FUNC_IS_DATA_GETTER) {
23944:         return data->mFunc.mDataGetter(aContent, aStyleContext);
23944:       }
23944: 
23944:       return data;
23944:     }
23944:   }
23944: 
23944:   return nsnull;
23944: }
23944: 
23944: /* static */
23944: const nsCSSFrameConstructor::FrameConstructionData*
23944: nsCSSFrameConstructor::FindDataByTag(nsIAtom* aTag,
23944:                                      nsIContent* aContent,
23944:                                      nsStyleContext* aStyleContext,
23944:                                      const FrameConstructionDataByTag* aDataPtr,
23944:                                      PRUint32 aDataLength)
23944: {
23944:   for (const FrameConstructionDataByTag *curData = aDataPtr,
23944:          *endData = aDataPtr + aDataLength;
23944:        curData != endData;
23944:        ++curData) {
23944:     if (*curData->mTag == aTag) {
23944:       const FrameConstructionData* data = &curData->mData;
23944:       if (data->mBits & FCDATA_FUNC_IS_DATA_GETTER) {
23944:         return data->mFunc.mDataGetter(aContent, aStyleContext);
23944:       }
23944: 
23944:       return data;
23944:     }
23944:   }
23944: 
23944:   return nsnull;
23944: }
23944: 
23952: #define SUPPRESS_FCDATA() FCDATA_DECL(FCDATA_SUPPRESS_FRAME, nsnull)
23944: #define SIMPLE_INT_CREATE(_int, _func) { _int, SIMPLE_FCDATA(_func) }
23944: #define SIMPLE_INT_CHAIN(_int, _func)                       \
23944:   { _int, FCDATA_DECL(FCDATA_FUNC_IS_DATA_GETTER, _func) }
23944: #define COMPLEX_INT_CREATE(_int, _func)         \
25131:   { _int, FULL_CTOR_FCDATA(0, _func) }
23944: 
23944: #define SIMPLE_TAG_CREATE(_tag, _func)          \
23944:   { &nsGkAtoms::_tag, SIMPLE_FCDATA(_func) }
23944: #define SIMPLE_TAG_CHAIN(_tag, _func)                                   \
23944:   { &nsGkAtoms::_tag, FCDATA_DECL(FCDATA_FUNC_IS_DATA_GETTER,  _func) }
23944: #define COMPLEX_TAG_CREATE(_tag, _func)             \
25131:   { &nsGkAtoms::_tag, FULL_CTOR_FCDATA(0, _func) }
23944: 
23944: /* static */
23944: const nsCSSFrameConstructor::FrameConstructionData*
23944: nsCSSFrameConstructor::FindHTMLData(nsIContent* aContent,
23167:                                     nsIAtom* aTag,
23167:                                     PRInt32 aNameSpaceID,
24550:                                     nsIFrame* aParentFrame,
23944:                                     nsStyleContext* aStyleContext)
23167: {
23167:   // Ignore the tag if it's not HTML content and if it doesn't extend (via XBL)
23167:   // a valid HTML namespace.  This check must match the one in
23167:   // ShouldHaveFirstLineStyle.
33329:   if (!aContent->IsHTML() &&
23167:       aNameSpaceID != kNameSpaceID_XHTML) {
23944:     return nsnull;
23944:   }
23944: 
24550:   NS_ASSERTION(!aParentFrame ||
24550:                aParentFrame->GetStyleContext()->GetPseudoType() !=
24550:                  nsCSSAnonBoxes::fieldsetContent ||
24550:                aParentFrame->GetParent()->GetType() == nsGkAtoms::fieldSetFrame,
24550:                "Unexpected parent for fieldset content anon box");
24550:   if (aTag == nsGkAtoms::legend &&
24550:       (!aParentFrame ||
24550:        (aParentFrame->GetType() != nsGkAtoms::fieldSetFrame &&
24550:         aParentFrame->GetStyleContext()->GetPseudoType() !=
30867:           nsCSSAnonBoxes::fieldsetContent) ||
31229:        !aContent->GetParent() ||
33329:        !aContent->GetParent()->IsHTML() ||
31229:        aContent->GetParent()->Tag() != nsGkAtoms::fieldset ||
30867:        aStyleContext->GetStyleDisplay()->IsFloating() ||
30867:        aStyleContext->GetStyleDisplay()->IsAbsolutelyPositioned())) {
31229:     // <legend> is only special inside fieldset, check both the frame tree
31229:     // parent and content tree parent due to XBL issues. For floated or
30867:     // absolutely positioned legends we want to construct by display type and
31229:     // not do special legend stuff.
24550:     // XXXbz it would be nice if we could just decide this based on the parent
24550:     // tag, and hence just use a SIMPLE_TAG_CHAIN for legend below, but the
24550:     // fact that with XBL we could end up with this legend element in some
24550:     // totally weird insertion point makes that chancy, I think.
24550:     return nsnull;
24550:   }
24550: 
23944:   static const FrameConstructionDataByTag sHTMLData[] = {
23944:     SIMPLE_TAG_CHAIN(img, nsCSSFrameConstructor::FindImgData),
23944:     SIMPLE_TAG_CHAIN(mozgeneratedcontentimage,
23944:                      nsCSSFrameConstructor::FindImgData),
25773:     { &nsGkAtoms::br,
29501:       FCDATA_DECL(FCDATA_SKIP_FRAMEMAP | FCDATA_IS_LINE_PARTICIPANT |
29501:                   FCDATA_IS_LINE_BREAK,
25773:                   NS_NewBRFrame) },
23977:     SIMPLE_TAG_CREATE(wbr, NS_NewWBRFrame),
23944:     SIMPLE_TAG_CHAIN(input, nsCSSFrameConstructor::FindInputData),
23944:     SIMPLE_TAG_CREATE(textarea, NS_NewTextControlFrame),
23944:     COMPLEX_TAG_CREATE(select, &nsCSSFrameConstructor::ConstructSelectFrame),
23944:     SIMPLE_TAG_CHAIN(object, nsCSSFrameConstructor::FindObjectData),
23944:     SIMPLE_TAG_CHAIN(applet, nsCSSFrameConstructor::FindObjectData),
23944:     SIMPLE_TAG_CHAIN(embed, nsCSSFrameConstructor::FindObjectData),
23944:     COMPLEX_TAG_CREATE(fieldset,
23944:                        &nsCSSFrameConstructor::ConstructFieldSetFrame),
23944:     SIMPLE_TAG_CREATE(legend, NS_NewLegendFrame),
23944:     SIMPLE_TAG_CREATE(frameset, NS_NewHTMLFramesetFrame),
23944:     SIMPLE_TAG_CREATE(iframe, NS_NewSubDocumentFrame),
23944:     SIMPLE_TAG_CREATE(spacer, NS_NewSpacerFrame),
23944:     COMPLEX_TAG_CREATE(button, &nsCSSFrameConstructor::ConstructButtonFrame),
23944:     SIMPLE_TAG_CREATE(canvas, NS_NewHTMLCanvasFrame),
23944: #if defined(MOZ_MEDIA)
23944:     SIMPLE_TAG_CREATE(video, NS_NewHTMLVideoFrame),
23944:     SIMPLE_TAG_CREATE(audio, NS_NewHTMLVideoFrame),
23944: #endif
23944:     SIMPLE_TAG_CREATE(isindex, NS_NewIsIndexFrame)
23944:   };
23944: 
23944:   return FindDataByTag(aTag, aContent, aStyleContext, sHTMLData,
23944:                        NS_ARRAY_LENGTH(sHTMLData));
23944: }
23944: 
23944: /* static */
23944: const nsCSSFrameConstructor::FrameConstructionData*
23944: nsCSSFrameConstructor::FindImgData(nsIContent* aContent,
23944:                                    nsStyleContext* aStyleContext)
23944: {
23944:   if (!nsImageFrame::ShouldCreateImageFrameFor(aContent, aStyleContext)) {
23944:     return nsnull;
23944:   }
23944: 
23944:   static const FrameConstructionData sImgData = SIMPLE_FCDATA(NS_NewImageFrame);
23944:   return &sImgData;
23944: }
23944: 
23944: /* static */
23944: const nsCSSFrameConstructor::FrameConstructionData*
23944: nsCSSFrameConstructor::FindImgControlData(nsIContent* aContent,
23944:                                           nsStyleContext* aStyleContext)
23944: {
23944:   if (!nsImageFrame::ShouldCreateImageFrameFor(aContent, aStyleContext)) {
23944:     return nsnull;
23944:   }
23944: 
23944:   static const FrameConstructionData sImgControlData =
23944:     SIMPLE_FCDATA(NS_NewImageControlFrame);
23944:   return &sImgControlData;
23944: }
23944: 
23944: /* static */
23944: const nsCSSFrameConstructor::FrameConstructionData*
23944: nsCSSFrameConstructor::FindInputData(nsIContent* aContent,
23944:                                      nsStyleContext* aStyleContext)
23944: {
23944:   static const FrameConstructionDataByInt sInputData[] = {
23944:     SIMPLE_INT_CREATE(NS_FORM_INPUT_CHECKBOX, NS_NewGfxCheckboxControlFrame),
23944:     SIMPLE_INT_CREATE(NS_FORM_INPUT_RADIO, NS_NewGfxRadioControlFrame),
23944:     SIMPLE_INT_CREATE(NS_FORM_INPUT_FILE, NS_NewFileControlFrame),
23944:     SIMPLE_INT_CHAIN(NS_FORM_INPUT_IMAGE,
23944:                      nsCSSFrameConstructor::FindImgControlData),
23944:     SIMPLE_INT_CREATE(NS_FORM_INPUT_TEXT, NS_NewTextControlFrame),
23944:     SIMPLE_INT_CREATE(NS_FORM_INPUT_PASSWORD, NS_NewTextControlFrame),
23944:     COMPLEX_INT_CREATE(NS_FORM_INPUT_SUBMIT,
23944:                        &nsCSSFrameConstructor::ConstructButtonFrame),
23944:     COMPLEX_INT_CREATE(NS_FORM_INPUT_RESET,
23944:                        &nsCSSFrameConstructor::ConstructButtonFrame),
23944:     COMPLEX_INT_CREATE(NS_FORM_INPUT_BUTTON,
23944:                        &nsCSSFrameConstructor::ConstructButtonFrame)
23944:     // Keeping hidden inputs out of here on purpose for so they get frames by
23944:     // display (in practice, none).
23944:   };
23944: 
23944:   nsCOMPtr<nsIFormControl> control = do_QueryInterface(aContent);
23944:   NS_ASSERTION(control, "input doesn't implement nsIFormControl?");
23944: 
23944:   return FindDataByInt(control->GetType(), aContent, aStyleContext,
23944:                        sInputData, NS_ARRAY_LENGTH(sInputData));
23944: }
23944: 
23944: /* static */
23944: const nsCSSFrameConstructor::FrameConstructionData*
23944: nsCSSFrameConstructor::FindObjectData(nsIContent* aContent,
23944:                                       nsStyleContext* aStyleContext)
23944: {
23944:   // GetDisplayedType isn't necessarily nsIObjectLoadingContent::TYPE_NULL for
23944:   // cases when the object is broken/suppressed/etc (e.g. a broken image), but
23944:   // we want to treat those cases as TYPE_NULL
23944:   PRUint32 type;
23944:   if (aContent->IntrinsicState() &
23944:       (NS_EVENT_STATE_BROKEN | NS_EVENT_STATE_USERDISABLED |
23944:        NS_EVENT_STATE_SUPPRESSED)) {
23944:     type = nsIObjectLoadingContent::TYPE_NULL;
23944:   } else {
23944:     nsCOMPtr<nsIObjectLoadingContent> objContent(do_QueryInterface(aContent));
23944:     NS_ASSERTION(objContent,
23944:                  "applet, embed and object must implement "
23944:                  "nsIObjectLoadingContent!");
23944: 
23944:     objContent->GetDisplayedType(&type);
23944:   }
23944: 
23944:   static const FrameConstructionDataByInt sObjectData[] = {
23944:     SIMPLE_INT_CREATE(nsIObjectLoadingContent::TYPE_LOADING,
23944:                       NS_NewEmptyFrame),
23944:     SIMPLE_INT_CREATE(nsIObjectLoadingContent::TYPE_PLUGIN,
23944:                       NS_NewObjectFrame),
23944:     SIMPLE_INT_CREATE(nsIObjectLoadingContent::TYPE_IMAGE,
23944:                       NS_NewImageFrame),
23944:     SIMPLE_INT_CREATE(nsIObjectLoadingContent::TYPE_DOCUMENT,
23944:                       NS_NewSubDocumentFrame)
23944:     // Nothing for TYPE_NULL so we'll construct frames by display there
23944:   };
23944: 
23944:   return FindDataByInt((PRInt32)type, aContent, aStyleContext,
23944:                        sObjectData, NS_ARRAY_LENGTH(sObjectData));
23944: }
23944: 
23944: nsresult
25769: nsCSSFrameConstructor::ConstructFrameFromItemInternal(FrameConstructionItem& aItem,
23944:                                                       nsFrameConstructorState& aState,
    1:                                                       nsIFrame* aParentFrame,
26208:                                                       nsFrameItems& aFrameItems)
    1: {
25769:   const FrameConstructionData* data = aItem.mFCData;
25769:   NS_ASSERTION(data, "Must have frame construction data");
25769: 
25769:   PRUint32 bits = data->mBits;
23944: 
23944:   NS_ASSERTION(!(bits & FCDATA_FUNC_IS_DATA_GETTER),
23944:                "Should have dealt with this inside the data finder");
23944: 
23952:   // Some sets of bits are not compatible with each other
23952: #define CHECK_ONLY_ONE_BIT(_bit1, _bit2)               \
23952:   NS_ASSERTION(!(bits & _bit1) || !(bits & _bit2),     \
23952:                "Only one of these bits should be set")
23952:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_FORCE_NULL_ABSPOS_CONTAINER);
24007: #ifdef MOZ_MATHML
23952:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_WRAP_KIDS_IN_BLOCKS);
24007: #endif
23952:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_MAY_NEED_SCROLLFRAME);
23952:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_IS_POPUP);
23952:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_SKIP_ABSPOS_PUSH);
23954:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_FORCE_VIEW);
23954:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR,
23954:                      FCDATA_DISALLOW_GENERATED_CONTENT);
26207:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_ALLOW_BLOCK_STYLES);
23954:   CHECK_ONLY_ONE_BIT(FCDATA_MAY_NEED_SCROLLFRAME, FCDATA_FORCE_VIEW);
23952: #undef CHECK_ONLY_ONE_BIT
23952: 
25769:   nsStyleContext* const styleContext = aItem.mStyleContext;
25769:   const nsStyleDisplay* display = styleContext->GetStyleDisplay();
23944: 
23944:   nsIFrame* newFrame;
23944:   if (bits & FCDATA_FUNC_IS_FULL_CTOR) {
23944:     nsresult rv =
25769:       (this->*(data->mFullConstructor))(aState, aItem, aParentFrame,
25131:                                         display, aFrameItems, &newFrame);
23944:     if (NS_FAILED(rv)) {
23944:       return rv;
23944:     }
23944:   } else {
25769:     nsIContent* const content = aItem.mContent;
25769: 
23944:     newFrame =
25769:       (*data->mFunc.mCreationFunc)(mPresShell, styleContext);
23944:     if (!newFrame) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
23944: 
23944:     PRBool allowOutOfFlow = !(bits & FCDATA_DISALLOW_OUT_OF_FLOW);
25772:     PRBool isPopup = aItem.mIsPopup;
23952:     NS_ASSERTION(!isPopup ||
23952:                  (aState.mPopupItems.containingBlock &&
23952:                   aState.mPopupItems.containingBlock->GetType() ==
23952:                     nsGkAtoms::popupSetFrame),
23952:                  "Should have a containing block here!");
23952: 
23944:     nsIFrame* geometricParent =
23952:       isPopup ? aState.mPopupItems.containingBlock :
23952:       (allowOutOfFlow ? aState.GetGeometricParent(display, aParentFrame)
23952:                       : aParentFrame);
23952: 
23952:     nsresult rv = NS_OK;
23952: 
23952:     // Must init frameToAddToList to null, since it's inout
23952:     nsIFrame* frameToAddToList = nsnull;
23952:     if ((bits & FCDATA_MAY_NEED_SCROLLFRAME) &&
23952:         display->IsScrollableOverflow()) {
25769:       BuildScrollFrame(aState, content, styleContext, newFrame,
23952:                        geometricParent, frameToAddToList);
23952:       // No need to add to frame map later, since BuildScrollFrame did it
23952:       // already
23952:       bits |= FCDATA_SKIP_FRAMEMAP;
23952:     } else {
25769:       rv = InitAndRestoreFrame(aState, content, geometricParent, nsnull,
23944:                                newFrame);
    1:       NS_ASSERTION(NS_SUCCEEDED(rv), "InitAndRestoreFrame failed");
23944:       // See whether we need to create a view
23954:       nsHTMLContainerFrame::CreateViewForFrame(newFrame,
23954:                                                (bits & FCDATA_FORCE_VIEW) != 0);
23952:       frameToAddToList = newFrame;
23952:     }
23952: 
25769:     rv = aState.AddChild(frameToAddToList, aFrameItems, content, styleContext,
23952:                          aParentFrame, allowOutOfFlow, allowOutOfFlow, isPopup);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
23167: 
23952: #ifdef MOZ_XUL
23952:     // Icky XUL stuff, sadly
25768: 
25769:     if (aItem.mIsRootPopupgroup) {
25768:       NS_ASSERTION(nsIRootBox::GetRootBox(mPresShell) &&
25768:                    nsIRootBox::GetRootBox(mPresShell)->GetPopupSetFrame() ==
25768:                      newFrame,
23952:                    "Unexpected PopupSetFrame");
25768:       aState.mPopupItems.containingBlock = newFrame;
25768:       aState.mHavePendingPopupgroup = PR_FALSE;
23952:     }
23952: #endif /* MOZ_XUL */
    1: 
    1:     // Process the child content if requested
    1:     nsFrameItems childItems;
    1:     nsFrameConstructorSaveState absoluteSaveState;
23343: 
23944:     if (bits & FCDATA_FORCE_NULL_ABSPOS_CONTAINER) {
23944:       aState.PushAbsoluteContainingBlock(nsnull, absoluteSaveState);
23952:     } else if (!(bits & FCDATA_SKIP_ABSPOS_PUSH) && display->IsPositioned()) {
    1:       aState.PushAbsoluteContainingBlock(newFrame, absoluteSaveState);
    1:     }
23352: 
26208:     if (bits & FCDATA_USE_CHILD_ITEMS) {
26208:       rv = ConstructFramesFromItemList(aState, aItem.mChildItems, newFrame,
26208:                                        childItems);
26208:     } else {
26207:       // Process the child frames.
25769:       rv = ProcessChildren(aState, content, styleContext, newFrame,
23954:                            !(bits & FCDATA_DISALLOW_GENERATED_CONTENT),
26207:                            childItems,
26207:                            (bits & FCDATA_ALLOW_BLOCK_STYLES) != 0);
26208:     }
23167: 
23952: #ifdef MOZ_XUL
23952:     // More icky XUL stuff
25769:     if (aItem.mNameSpaceID == kNameSpaceID_XUL &&
25769:         (aItem.mTag == nsGkAtoms::treechildren || // trees always need titletips
25769:          content->HasAttr(kNameSpaceID_None, nsGkAtoms::tooltiptext) ||
25769:          content->HasAttr(kNameSpaceID_None, nsGkAtoms::tooltip))) {
23952:       nsIRootBox* rootBox = nsIRootBox::GetRootBox(mPresShell);
23952:       if (rootBox) {
25769:         rootBox->AddTooltipSupport(content);
23952:       }
23952:     }
23952: #endif
23952: 
23946: #ifdef MOZ_MATHML
23946:     if (NS_SUCCEEDED(rv) && (bits & FCDATA_WRAP_KIDS_IN_BLOCKS)) {
23946:       nsFrameItems newItems;
23946:       nsFrameItems currentBlock;
23946:       nsIFrame* f;
30785:       while ((f = childItems.FirstChild()) != nsnull) {
23946:         PRBool wrapFrame = IsInlineFrame(f) || IsFrameSpecial(f);
23946:         if (!wrapFrame) {
25769:           rv = FlushAccumulatedBlock(aState, content, newFrame, &currentBlock, &newItems);
23946:           if (NS_FAILED(rv))
23946:             break;
23946:         }
23946: 
33388:         childItems.RemoveFrame(f);
23946:         if (wrapFrame) {
23946:           currentBlock.AddChild(f);
23946:         } else {
23946:           newItems.AddChild(f);
23946:         }
23946:       }
25769:       rv = FlushAccumulatedBlock(aState, content, newFrame, &currentBlock, &newItems);
23946: 
30785:       if (childItems.NotEmpty()) {
23946:         // an error must have occurred, delete unprocessed frames
30785:         CleanupFrameReferences(aState.mFrameManager, childItems);
30785:         childItems.DestroyFrames();
23946:       }
23946: 
23946:       childItems = newItems;
23946:     }
23946: #endif
    1: 
    1:     // Set the frame's initial child list
23946:     // Note that MathML depends on this being called even if
30785:     // childItems is empty!
30785:     newFrame->SetInitialChildList(nsnull, childItems);
    1:   }
23167: 
25773:   NS_ASSERTION(newFrame->IsFrameOfType(nsIFrame::eLineParticipant) ==
25773:                ((bits & FCDATA_IS_LINE_PARTICIPANT) != 0),
25773:                "Incorrectly set FCDATA_IS_LINE_PARTICIPANT bits");
25773: 
23944:   if (!(bits & FCDATA_SKIP_FRAMEMAP)) {
25769:     aState.mFrameManager->SetPrimaryFrameFor(aItem.mContent, newFrame);
    1:   }
    1: 
23944:   return NS_OK;
    1: }
    1: 
    1: // after the node has been constructed and initialized create any
    1: // anonymous content a node needs.
    1: nsresult
    1: nsCSSFrameConstructor::CreateAnonymousFrames(nsFrameConstructorState& aState,
    1:                                              nsIContent*              aParent,
    1:                                              nsIFrame*                aParentFrame,
    1:                                              nsFrameItems&            aChildItems)
    1: {
    1:   nsAutoTArray<nsIContent*, 4> newAnonymousItems;
25768:   nsresult rv = GetAnonymousContent(aParent, aParentFrame, newAnonymousItems);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRUint32 count = newAnonymousItems.Length();
    1:   if (count == 0) {
    1:     return NS_OK;
    1:   }
    1: 
25768:   nsIAnonymousContentCreator* creator = do_QueryFrame(aParentFrame);
25768:   NS_ASSERTION(creator,
25768:                "How can that happen if we have nodes to construct frames for?");
25768: 
    1:   for (PRUint32 i=0; i < count; i++) {
25768:     nsIContent* content = newAnonymousItems[i];
25768:     NS_ASSERTION(content, "null anonymous content?");
25768: 
25768:     nsIFrame* newFrame = creator->CreateFrameFor(content);
25768:     if (newFrame) {
25768:       aChildItems.AddChild(newFrame);
25768:     }
25768:     else {
25768:       // create the frame and attach it to our frame
25768:       ConstructFrame(aState, content, aParentFrame, aChildItems);
25768:     }
25768:   }
25768: 
25768:   return NS_OK;
25768: }
25768: 
25768: nsresult
25768: nsCSSFrameConstructor::GetAnonymousContent(nsIContent* aParent,
25768:                                            nsIFrame* aParentFrame,
25768:                                            nsTArray<nsIContent*>& aContent)
25768: {
25768:   nsIAnonymousContentCreator* creator = do_QueryFrame(aParentFrame);
25768:   if (!creator)
25768:     return NS_OK;
25768: 
25768:   nsresult rv = creator->CreateAnonymousContent(aContent);
25768:   NS_ENSURE_SUCCESS(rv, rv);
25768: 
25768:   PRUint32 count = aContent.Length();
25768:   for (PRUint32 i=0; i < count; i++) {
    1:     // get our child's content and set its parent to our content
25768:     nsIContent* content = aContent[i];
    1:     NS_ASSERTION(content, "null anonymous content?");
    1: 
    1: #ifdef MOZ_SVG
    1:     // least-surprise CSS binding until we do the SVG specified
    1:     // cascading rules for <svg:use> - bug 265894
25511:     if (aParent &&
25511:         aParent->NodeInfo()->Equals(nsGkAtoms::use, kNameSpaceID_SVG)) {
25511:       content->SetFlags(NODE_IS_ANONYMOUS);
25511:     } else
12250: #endif
12250:     {
12250:       content->SetNativeAnonymous();
12250:     }
    1: 
23342:     rv = content->BindToTree(mDocument, aParent, aParent, PR_TRUE);
    1:     if (NS_FAILED(rv)) {
    1:       content->UnbindFromTree();
    1:       return rv;
    1:     }
25768:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: static
    1: PRBool IsXULDisplayType(const nsStyleDisplay* aDisplay)
    1: {
    1:   return (aDisplay->mDisplay == NS_STYLE_DISPLAY_INLINE_BOX || 
25114: #ifdef MOZ_XUL
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_INLINE_GRID || 
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_INLINE_STACK ||
25114: #endif
25114:           aDisplay->mDisplay == NS_STYLE_DISPLAY_BOX
25114: #ifdef MOZ_XUL
25114:           || aDisplay->mDisplay == NS_STYLE_DISPLAY_GRID ||
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_STACK ||
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_GRID_GROUP ||
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_GRID_LINE ||
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_DECK ||
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_POPUP ||
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_GROUPBOX
25114: #endif
    1:           );
    1: }
    1: 
23952: 
23952: // XUL frames are not allowed to be out of flow.
23952: #define SIMPLE_XUL_FCDATA(_func)                                        \
23952:   FCDATA_DECL(FCDATA_DISALLOW_OUT_OF_FLOW | FCDATA_SKIP_ABSPOS_PUSH,    \
23952:               _func)
23952: #define SCROLLABLE_XUL_FCDATA(_func)                                    \
23952:   FCDATA_DECL(FCDATA_DISALLOW_OUT_OF_FLOW | FCDATA_SKIP_ABSPOS_PUSH |   \
23952:               FCDATA_MAY_NEED_SCROLLFRAME, _func)
23952: #define SIMPLE_XUL_CREATE(_tag, _func)            \
23952:   { &nsGkAtoms::_tag, SIMPLE_XUL_FCDATA(_func) }
23952: #define SCROLLABLE_XUL_CREATE(_tag, _func)            \
23952:   { &nsGkAtoms::_tag, SCROLLABLE_XUL_FCDATA(_func) }
23952: #define SIMPLE_XUL_INT_CREATE(_int, _func)      \
23952:   { _int, SIMPLE_XUL_FCDATA(_func) }
23952: #define SCROLLABLE_XUL_INT_CREATE(_int, _func)                          \
23952:   { _int, SCROLLABLE_XUL_FCDATA(_func) }
23952: 
23952: static
23952: nsIFrame* NS_NewGridBoxFrame(nsIPresShell* aPresShell,
23952:                              nsStyleContext* aStyleContext)
23952: {
23952:   nsCOMPtr<nsIBoxLayout> layout;
23952:   NS_NewGridLayout2(aPresShell, getter_AddRefs(layout));
23952:   if (!layout) {
23952:     return nsnull;
23952:   }
23952: 
23952:   return NS_NewBoxFrame(aPresShell, aStyleContext, PR_FALSE, layout);
23952: }
23952: 
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData*
23952: nsCSSFrameConstructor::FindXULTagData(nsIContent* aContent,
    1:                                       nsIAtom* aTag,
    1:                                       PRInt32 aNameSpaceID,
23952:                                       nsStyleContext* aStyleContext)
23952: {
23952:   if (aNameSpaceID != kNameSpaceID_XUL) {
23952:     return nsnull;
23952:   }
23952: 
23952:   static const FrameConstructionDataByTag sXULTagData[] = {
    1: #ifdef MOZ_XUL
23952:     SCROLLABLE_XUL_CREATE(button, NS_NewButtonBoxFrame),
23952:     SCROLLABLE_XUL_CREATE(checkbox, NS_NewButtonBoxFrame),
23952:     SCROLLABLE_XUL_CREATE(radio, NS_NewButtonBoxFrame),
23952:     SCROLLABLE_XUL_CREATE(autorepeatbutton, NS_NewAutoRepeatBoxFrame),
23952:     SCROLLABLE_XUL_CREATE(titlebar, NS_NewTitleBarFrame),
23952:     SCROLLABLE_XUL_CREATE(resizer, NS_NewResizerFrame),
23952:     SIMPLE_XUL_CREATE(image, NS_NewImageBoxFrame),
23952:     SIMPLE_XUL_CREATE(spring, NS_NewLeafBoxFrame),
23952:     SIMPLE_XUL_CREATE(spacer, NS_NewLeafBoxFrame),
23952:     SIMPLE_XUL_CREATE(treechildren, NS_NewTreeBodyFrame),
23952:     SIMPLE_XUL_CREATE(treecol, NS_NewTreeColFrame),
23952:     SIMPLE_XUL_CREATE(text, NS_NewTextBoxFrame),
23952:     SIMPLE_TAG_CHAIN(label, nsCSSFrameConstructor::FindXULLabelData),
23952:     SIMPLE_TAG_CHAIN(description, nsCSSFrameConstructor::FindXULDescriptionData),
23952:     SIMPLE_XUL_CREATE(menu, NS_NewMenuFrame),
23952:     SIMPLE_XUL_CREATE(menubutton, NS_NewMenuFrame),
23952:     SIMPLE_XUL_CREATE(menuitem, NS_NewMenuItemFrame),
    1: #ifdef XP_MACOSX
23952:     SIMPLE_TAG_CHAIN(menubar, nsCSSFrameConstructor::FindXULMenubarData),
23952: #else
23952:     SIMPLE_XUL_CREATE(menubar, NS_NewMenuBarFrame),
23952: #endif /* XP_MACOSX */
23952:     SIMPLE_TAG_CHAIN(popupgroup, nsCSSFrameConstructor::FindPopupGroupData),
23952:     SIMPLE_XUL_CREATE(iframe, NS_NewSubDocumentFrame),
23952:     SIMPLE_XUL_CREATE(editor, NS_NewSubDocumentFrame),
23952:     SIMPLE_XUL_CREATE(browser, NS_NewSubDocumentFrame),
23952:     SIMPLE_XUL_CREATE(progressmeter, NS_NewProgressMeterFrame),
23952:     SIMPLE_XUL_CREATE(splitter, NS_NewSplitterFrame),
23952:     SIMPLE_TAG_CHAIN(listboxbody,
23952:                      nsCSSFrameConstructor::FindXULListBoxBodyData),
23952:     SIMPLE_TAG_CHAIN(listitem, nsCSSFrameConstructor::FindXULListItemData),
23952: #endif /* MOZ_XUL */
23952:     SIMPLE_XUL_CREATE(slider, NS_NewSliderFrame),
23952:     SIMPLE_XUL_CREATE(scrollbar, NS_NewScrollbarFrame),
23952:     SIMPLE_XUL_CREATE(scrollbarbutton, NS_NewScrollbarButtonFrame)
23952: };
23952: 
23952:   return FindDataByTag(aTag, aContent, aStyleContext, sXULTagData,
23952:                        NS_ARRAY_LENGTH(sXULTagData));
23952: }
23952: 
23952: #ifdef MOZ_XUL
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData*
23952: nsCSSFrameConstructor::FindPopupGroupData(nsIContent* aContent,
23952:                                           nsStyleContext* /* unused */)
23952: {
23952:   if (!aContent->IsRootOfNativeAnonymousSubtree()) {
23952:     return nsnull;
23952:   }
23952: 
23952:   static const FrameConstructionData sPopupSetData =
23952:     SIMPLE_XUL_FCDATA(NS_NewPopupSetFrame);
23952:   return &sPopupSetData;
23952: }
23952: 
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData
23952: nsCSSFrameConstructor::sXULTextBoxData = SIMPLE_XUL_FCDATA(NS_NewTextBoxFrame);
23952: 
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData*
23952: nsCSSFrameConstructor::FindXULLabelData(nsIContent* aContent,
23952:                                         nsStyleContext* /* unused */)
23952: {
23952:   if (aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::value)) {
23952:     return &sXULTextBoxData;
23952:   }
23952: 
23952:   static const FrameConstructionData sLabelData =
23952:     SIMPLE_XUL_FCDATA(NS_NewXULLabelFrame);
23952:   return &sLabelData;
23952: }
23952: 
23952: static nsIFrame*
23952: NS_NewXULDescriptionFrame(nsIPresShell* aPresShell, nsStyleContext *aContext)
23952: {
23952:   // XXXbz do we really need to set those flags?  If the parent is not
23952:   // a block we'll get them anyway, and if it is, do we want them?
23952:   return NS_NewBlockFrame(aPresShell, aContext,
23952:                           NS_BLOCK_FLOAT_MGR | NS_BLOCK_MARGIN_ROOT);
23952: }
23952: 
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData*
23952: nsCSSFrameConstructor::FindXULDescriptionData(nsIContent* aContent,
23952:                                               nsStyleContext* /* unused */)
23952: {
23952:   if (aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::value)) {
23952:     return &sXULTextBoxData;
23952:   }
23952: 
23952:   static const FrameConstructionData sDescriptionData =
23952:     SIMPLE_XUL_FCDATA(NS_NewXULDescriptionFrame);
23952:   return &sDescriptionData;
23952: }
23952: 
23952: #ifdef XP_MACOSX
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData*
23952: nsCSSFrameConstructor::FindXULMenubarData(nsIContent* aContent,
23952:                                           nsStyleContext* aStyleContext)
23952: {
23952:   nsCOMPtr<nsISupports> container =
23952:     aStyleContext->PresContext()->GetContainer();
    1:   if (container) {
    1:     nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryInterface(container));
    1:     if (treeItem) {
    1:       PRInt32 type;
    1:       treeItem->GetItemType(&type);
    1:       if (nsIDocShellTreeItem::typeChrome == type) {
    1:         nsCOMPtr<nsIDocShellTreeItem> parent;
    1:         treeItem->GetParent(getter_AddRefs(parent));
23952:         if (!parent) {
23952:           // This is the root.  Suppress the menubar, since on Mac
23952:           // window menus are not attached to the window.
23952:           static const FrameConstructionData sSuppressData = SUPPRESS_FCDATA();
23952:           return &sSuppressData;
23952:         }
23952:       }
23952:     }
23952:   }
23952: 
23952:   static const FrameConstructionData sMenubarData =
23952:     SIMPLE_XUL_FCDATA(NS_NewMenuBarFrame);
23952:   return &sMenubarData;
23952: }
23952: #endif /* XP_MACOSX */
23952: 
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData*
23952: nsCSSFrameConstructor::FindXULListBoxBodyData(nsIContent* aContent,
23952:                                               nsStyleContext* aStyleContext)
23952: {
23952:   if (aStyleContext->GetStyleDisplay()->mDisplay !=
23952:         NS_STYLE_DISPLAY_GRID_GROUP) {
23952:     return nsnull;
23952:   }
23952: 
23952:   static const FrameConstructionData sListBoxBodyData =
23952:     SCROLLABLE_XUL_FCDATA(NS_NewListBoxBodyFrame);
23952:   return &sListBoxBodyData;
23952: }
23952: 
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData*
23952: nsCSSFrameConstructor::FindXULListItemData(nsIContent* aContent,
23952:                                            nsStyleContext* aStyleContext)
23952: {
23952:   if (aStyleContext->GetStyleDisplay()->mDisplay !=
23952:         NS_STYLE_DISPLAY_GRID_LINE) {
23952:     return nsnull;
23952:   }
23952: 
23952:   static const FrameConstructionData sListItemData =
23952:     SCROLLABLE_XUL_FCDATA(NS_NewListItemFrame);
23952:   return &sListItemData;
23952: }
23952: 
23952: #endif /* MOZ_XUL */
23952: 
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData*
23955: nsCSSFrameConstructor::FindXULDisplayData(const nsStyleDisplay* aDisplay,
23955:                                           nsIContent* aContent,
23952:                                           nsStyleContext* aStyleContext)
23952: {
23952:   static const FrameConstructionDataByInt sXULDisplayData[] = {
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_INLINE_BOX, NS_NewBoxFrame),
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_BOX, NS_NewBoxFrame),
    1: #ifdef MOZ_XUL
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_INLINE_GRID, NS_NewGridBoxFrame),
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_GRID, NS_NewGridBoxFrame),
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_GRID_GROUP,
23952:                               NS_NewGridRowGroupFrame),
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_GRID_LINE,
23952:                               NS_NewGridRowLeafFrame),
23952:     SIMPLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_DECK, NS_NewDeckFrame),
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_GROUPBOX, NS_NewGroupBoxFrame),
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_INLINE_STACK, NS_NewStackFrame),
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_STACK, NS_NewStackFrame),
23952:     { NS_STYLE_DISPLAY_POPUP,
23952:       FCDATA_DECL(FCDATA_DISALLOW_OUT_OF_FLOW | FCDATA_IS_POPUP |
23952:                   FCDATA_SKIP_ABSPOS_PUSH, NS_NewMenuPopupFrame) }
23952: #endif /* MOZ_XUL */
23952:   };
23952: 
23952:   // Processing by display here:
23955:   return FindDataByInt(aDisplay->mDisplay, aContent, aStyleContext,
23952:                        sXULDisplayData, NS_ARRAY_LENGTH(sXULDisplayData));
    1: }
    1: 
 3129: nsresult
 3129: nsCSSFrameConstructor::AddLazyChildren(nsIContent* aContent,
 3129:                                        nsLazyFrameConstructionCallback* aCallback,
 8282:                                        void* aArg, PRBool aIsSynch)
 3129: {
 3129:   nsCOMPtr<nsIRunnable> event =
 3129:     new LazyGenerateChildrenEvent(aContent, mPresShell, aCallback, aArg);
 8282:   return aIsSynch ? event->Run() :
 8282:                     NS_DispatchToCurrentThread(event);
 3129: }
 3129: 
    1: already_AddRefed<nsStyleContext>
    1: nsCSSFrameConstructor::BeginBuildingScrollFrame(nsFrameConstructorState& aState,
    1:                                                 nsIContent*              aContent,
    1:                                                 nsStyleContext*          aContentStyle,
    1:                                                 nsIFrame*                aParentFrame,
    1:                                                 nsIAtom*                 aScrolledPseudo,
    1:                                                 PRBool                   aIsRoot,
    1:                                                 nsIFrame*&               aNewFrame)
    1: {
    1:   nsIFrame* gfxScrollFrame = aNewFrame;
    1: 
    1:   nsFrameItems anonymousItems;
    1: 
    1:   nsRefPtr<nsStyleContext> contentStyle = aContentStyle;
    1: 
    1:   if (!gfxScrollFrame) {
    1:     // Build a XULScrollFrame when the child is a box, otherwise an
    1:     // HTMLScrollFrame
25114:     // XXXbz this is the lone remaining consumer of IsXULDisplayType.
25114:     // I wonder whether we can eliminate that somehow.
    1:     if (IsXULDisplayType(aContentStyle->GetStyleDisplay())) {
    1:       gfxScrollFrame = NS_NewXULScrollFrame(mPresShell, contentStyle, aIsRoot);
    1:     } else {
    1:       gfxScrollFrame = NS_NewHTMLScrollFrame(mPresShell, contentStyle, aIsRoot);
    1:     }
    1: 
    1:     InitAndRestoreFrame(aState, aContent, aParentFrame, nsnull, gfxScrollFrame);
    1: 
    1:     // Create a view
23395:     nsHTMLContainerFrame::CreateViewForFrame(gfxScrollFrame, PR_FALSE);
    1:   }
    1: 
    1:   // if there are any anonymous children for the scroll frame, create
    1:   // frames for them.
23342:   CreateAnonymousFrames(aState, aContent, gfxScrollFrame, anonymousItems);
    1: 
    1:   aNewFrame = gfxScrollFrame;
    1: 
    1:   // we used the style that was passed in. So resolve another one.
    1:   nsStyleSet *styleSet = mPresShell->StyleSet();
    1:   nsStyleContext* aScrolledChildStyle = styleSet->ResolvePseudoStyleFor(aContent,
    1:                                                                         aScrolledPseudo,
    1:                                                                         contentStyle).get();
    1: 
    1:   if (gfxScrollFrame) {
30785:      gfxScrollFrame->SetInitialChildList(nsnull, anonymousItems);
    1:   }
    1: 
    1:   return aScrolledChildStyle;
    1: }
    1: 
    1: void
    1: nsCSSFrameConstructor::FinishBuildingScrollFrame(nsIFrame* aScrollFrame,
    1:                                                  nsIFrame* aScrolledFrame)
    1: {
32846:   nsFrameList scrolled(aScrolledFrame, aScrolledFrame);
30941:   aScrollFrame->AppendFrames(nsnull, scrolled);
    1: 
    1:   // force the scrolled frame to have a view. The view will be parented to
    1:   // the correct anonymous inner view because the scrollframes override
    1:   // nsIFrame::GetParentViewForChildFrame.
23395:   nsHTMLContainerFrame::CreateViewForFrame(aScrolledFrame, PR_TRUE);
23395: 
23395:   // XXXbz what's the point of the code after this in this method?
    1:   nsIView* view = aScrolledFrame->GetView();
    1:   if (!view)
    1:     return;
    1: }
    1: 
    1: 
    1: /**
    1:  * Called to wrap a gfx scrollframe around a frame. The hierarchy will look like this
    1:  *
    1:  * ------- for gfx scrollbars ------
    1:  *
    1:  *
    1:  *            ScrollFrame
    1:  *                 ^
    1:  *                 |
    1:  *               Frame (scrolled frame you passed in)
    1:  *
    1:  *
    1:  *-----------------------------------
    1:  * LEGEND:
    1:  * 
    1:  * ScrollFrame: This is a frame that manages gfx cross platform frame based scrollbars.
    1:  *
    1:  * @param aContent the content node of the child to wrap.
    1:  * @param aScrolledFrame The frame of the content to wrap. This should not be
    1:  *                    Initialized. This method will initialize it with a scrolled pseudo
    1:  *                    and no nsIContent. The content will be attached to the scrollframe 
    1:  *                    returned.
    1:  * @param aContentStyle the style context that has already been resolved for the content being passed in.
    1:  *
    1:  * @param aParentFrame The parent to attach the scroll frame to
    1:  *
    1:  * @param aNewFrame The new scrollframe or gfx scrollframe that we create. It will contain the
    1:  *                  scrolled frame you passed in. (returned)
    1:  *                  If this is not null, we'll just use it
    1:  * @param aScrolledContentStyle the style that was resolved for the scrolled frame. (returned)
    1:  */
    1: nsresult
    1: nsCSSFrameConstructor::BuildScrollFrame(nsFrameConstructorState& aState,
    1:                                         nsIContent*              aContent,
    1:                                         nsStyleContext*          aContentStyle,
    1:                                         nsIFrame*                aScrolledFrame,
    1:                                         nsIFrame*                aParentFrame,
23950:                                         nsIFrame*&               aNewFrame)
    1: {
    1:     nsRefPtr<nsStyleContext> scrolledContentStyle =
    1:       BeginBuildingScrollFrame(aState, aContent, aContentStyle, aParentFrame,
23395:                                nsCSSAnonBoxes::scrolledContent,
    1:                                PR_FALSE, aNewFrame);
    1:     
    1:     aScrolledFrame->SetStyleContextWithoutNotification(scrolledContentStyle);
    1:     InitAndRestoreFrame(aState, aContent, aNewFrame, nsnull, aScrolledFrame);
    1: 
    1:     FinishBuildingScrollFrame(aNewFrame, aScrolledFrame);
    1: 
    1:     // now set the primary frame to the ScrollFrame
    1:     aState.mFrameManager->SetPrimaryFrameFor( aContent, aNewFrame );
    1:     return NS_OK;
    1: 
    1: }
    1: 
25131: const nsCSSFrameConstructor::FrameConstructionData*
25131: nsCSSFrameConstructor::FindDisplayData(const nsStyleDisplay* aDisplay,
26207:                                        nsIContent* aContent,
26207:                                        nsStyleContext* aStyleContext)
25131: {
26208:   PR_STATIC_ASSERT(eParentTypeCount < (1 << (32 - FCDATA_PARENT_TYPE_OFFSET)));
26208: 
    1:   // The style system ensures that floated and positioned frames are
    1:   // block-level.
    1:   NS_ASSERTION(!(aDisplay->IsFloating() ||
    1:                  aDisplay->IsAbsolutelyPositioned()) ||
 2829:                aDisplay->IsBlockOutside(),
    1:                "Style system did not apply CSS2.1 section 9.7 fixups");
    1: 
    1:   // If this is "body", try propagating its scroll style to the viewport
    1:   // Note that we need to do this even if the body is NOT scrollable;
    1:   // it might have dynamically changed from scrollable to not scrollable,
    1:   // and that might need to be propagated.
25131:   // XXXbz is this the right place to do this?  If this code moves,
25131:   // make this function static.
    1:   PRBool propagatedScrollToViewport = PR_FALSE;
    1:   if (aContent->NodeInfo()->Equals(nsGkAtoms::body) &&
33329:       aContent->IsHTML()) {
    1:     propagatedScrollToViewport =
    1:       PropagateScrollToViewport() == aContent;
    1:   }
    1: 
    1:   // If the frame is a block-level frame and is scrollable, then wrap it
    1:   // in a scroll frame.
    1:   // XXX Ignore tables for the time being
25129:   // XXXbz it would be nice to combine this with the other block
25129:   // case... Think about how do do this?
    1:   if (aDisplay->IsBlockInside() &&
    1:       aDisplay->IsScrollableOverflow() &&
    1:       !propagatedScrollToViewport) {
25131:     static const FrameConstructionData sScrollableBlockData =
25131:       FULL_CTOR_FCDATA(0, &nsCSSFrameConstructor::ConstructScrollableBlock);
25131:     return &sScrollableBlockData;
25131:   }
25131: 
25131:   // Handle various non-scrollable blocks
25131:   if (aDisplay->IsBlockInside() ||
25131:       NS_STYLE_DISPLAY_RUN_IN == aDisplay->mDisplay ||
25131:       NS_STYLE_DISPLAY_COMPACT == aDisplay->mDisplay) {  
25131:     static const FrameConstructionData sNonScrollableBlockData =
25131:       FULL_CTOR_FCDATA(0, &nsCSSFrameConstructor::ConstructNonScrollableBlock);
25131:     return &sNonScrollableBlockData;
25131:   }
25131: 
26207:   static const FrameConstructionDataByInt sDisplayData[] = {
25131:     // To keep the hash table small don't add inline frames (they're
25131:     // typically things like FONT and B), because we can quickly
25131:     // find them if we need to.
25131:     // XXXbz the "quickly" part is a bald-faced lie!
26207:     { NS_STYLE_DISPLAY_INLINE,
25773:       FULL_CTOR_FCDATA(FCDATA_SKIP_FRAMEMAP | FCDATA_IS_INLINE |
25773:                        FCDATA_IS_LINE_PARTICIPANT,
26207:                        &nsCSSFrameConstructor::ConstructInline) },
26207:     { NS_STYLE_DISPLAY_MARKER,
26207:       FULL_CTOR_FCDATA(FCDATA_SKIP_FRAMEMAP | FCDATA_IS_INLINE |
26207:                        FCDATA_IS_LINE_PARTICIPANT,
26207:                        &nsCSSFrameConstructor::ConstructInline) },
26208:     { NS_STYLE_DISPLAY_TABLE,
26208:       FULL_CTOR_FCDATA(0, &nsCSSFrameConstructor::ConstructTable) },
26208:     { NS_STYLE_DISPLAY_INLINE_TABLE,
26208:       FULL_CTOR_FCDATA(0, &nsCSSFrameConstructor::ConstructTable) },
26207:     { NS_STYLE_DISPLAY_TABLE_CAPTION,
26207:       FCDATA_DECL(FCDATA_IS_TABLE_PART | FCDATA_SKIP_FRAMEMAP |
26208:                   FCDATA_ALLOW_BLOCK_STYLES | FCDATA_DISALLOW_OUT_OF_FLOW |
26776:                   FCDATA_SKIP_ABSPOS_PUSH |
26208:                   FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeTable),
26207:                   NS_NewTableCaptionFrame) },
26207:     { NS_STYLE_DISPLAY_TABLE_ROW_GROUP,
26207:       FCDATA_DECL(FCDATA_IS_TABLE_PART | FCDATA_SKIP_FRAMEMAP |
26208:                   FCDATA_DISALLOW_OUT_OF_FLOW | FCDATA_MAY_NEED_SCROLLFRAME |
26776:                   FCDATA_SKIP_ABSPOS_PUSH |
26208:                   FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeTable),
26207:                   NS_NewTableRowGroupFrame) },
26207:     { NS_STYLE_DISPLAY_TABLE_HEADER_GROUP,
26207:       FCDATA_DECL(FCDATA_IS_TABLE_PART | FCDATA_SKIP_FRAMEMAP |
26208:                   FCDATA_DISALLOW_OUT_OF_FLOW | FCDATA_MAY_NEED_SCROLLFRAME |
26776:                   FCDATA_SKIP_ABSPOS_PUSH |
26208:                   FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeTable),
26207:                   NS_NewTableRowGroupFrame) },
26207:     { NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP,
26207:       FCDATA_DECL(FCDATA_IS_TABLE_PART | FCDATA_SKIP_FRAMEMAP |
26208:                   FCDATA_DISALLOW_OUT_OF_FLOW | FCDATA_MAY_NEED_SCROLLFRAME |
26776:                   FCDATA_SKIP_ABSPOS_PUSH |
26208:                   FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeTable),
26207:                   NS_NewTableRowGroupFrame) },
26207:     { NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP,
26207:       FCDATA_DECL(FCDATA_IS_TABLE_PART | FCDATA_SKIP_FRAMEMAP |
26776:                   FCDATA_DISALLOW_OUT_OF_FLOW | FCDATA_SKIP_ABSPOS_PUSH |
26208:                   FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeTable),
26207:                   NS_NewTableColGroupFrame) },
26207:     { NS_STYLE_DISPLAY_TABLE_COLUMN,
26208:       FULL_CTOR_FCDATA(FCDATA_IS_TABLE_PART | FCDATA_SKIP_FRAMEMAP |
26208:                        FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeColGroup),
26207:                        &nsCSSFrameConstructor::ConstructTableCol) },
26207:     { NS_STYLE_DISPLAY_TABLE_ROW,
26208:       FULL_CTOR_FCDATA(FCDATA_IS_TABLE_PART | FCDATA_SKIP_FRAMEMAP |
26208:                        FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeRowGroup),
26207:                        &nsCSSFrameConstructor::ConstructTableRow) },
26207:     { NS_STYLE_DISPLAY_TABLE_CELL,
26208:       FULL_CTOR_FCDATA(FCDATA_IS_TABLE_PART | FCDATA_SKIP_FRAMEMAP |
26208:                        FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeRow),
26207:                        &nsCSSFrameConstructor::ConstructTableCell) }
26207:   };
26207: 
26207:   return FindDataByInt(aDisplay->mDisplay, aContent, aStyleContext,
26207:                        sDisplayData, NS_ARRAY_LENGTH(sDisplayData));
25131: }
25131: 
25131: nsresult
25131: nsCSSFrameConstructor::ConstructScrollableBlock(nsFrameConstructorState& aState,
25769:                                                 FrameConstructionItem&   aItem,
25131:                                                 nsIFrame*                aParentFrame,
25131:                                                 const nsStyleDisplay*    aDisplay,
25131:                                                 nsFrameItems&            aFrameItems,
25131:                                                 nsIFrame**               aNewFrame)
25131: {
25769:   nsIContent* const content = aItem.mContent;
25769:   nsStyleContext* const styleContext = aItem.mStyleContext;
25769: 
25131:   *aNewFrame = nsnull;
    1:   nsRefPtr<nsStyleContext> scrolledContentStyle
25769:     = BeginBuildingScrollFrame(aState, content, styleContext,
    1:                                aState.GetGeometricParent(aDisplay, aParentFrame),
    1:                                nsCSSAnonBoxes::scrolledContent,
25131:                                PR_FALSE, *aNewFrame);
25131: 
25131:   // Create our block frame
    1:   // pass a temporary stylecontext, the correct one will be set later
    1:   nsIFrame* scrolledFrame =
25769:     NS_NewBlockFormattingContext(mPresShell, styleContext);
    1: 
    1:   nsFrameItems blockItem;
25131:   nsresult rv = ConstructBlock(aState,
25769:                                scrolledContentStyle->GetStyleDisplay(), content,
25131:                                *aNewFrame, *aNewFrame, scrolledContentStyle,
    1:                                &scrolledFrame, blockItem, aDisplay->IsPositioned());
25131:   if (NS_UNLIKELY(NS_FAILED(rv))) {
25131:     // XXXbz any cleanup needed here?
25131:     return rv;
25131:   }
25131: 
30785:   NS_ASSERTION(blockItem.FirstChild() == scrolledFrame,
    1:                "Scrollframe's frameItems should be exactly the scrolled frame");
25131:   FinishBuildingScrollFrame(*aNewFrame, scrolledFrame);
25131: 
25769:   rv = aState.AddChild(*aNewFrame, aFrameItems, content, styleContext,
 8199:                        aParentFrame);
25131:   return rv;
25131: }
25131: 
25131: nsresult
25131: nsCSSFrameConstructor::ConstructNonScrollableBlock(nsFrameConstructorState& aState,
25769:                                                    FrameConstructionItem&   aItem,
25131:                                                    nsIFrame*                aParentFrame,
25131:                                                    const nsStyleDisplay*    aDisplay,
25131:                                                    nsFrameItems&            aFrameItems,
25131:                                                    nsIFrame**               aNewFrame)
25131: {
25769:   nsStyleContext* const styleContext = aItem.mStyleContext;
25769: 
25129:   if (aDisplay->IsAbsolutelyPositioned() ||
25129:       aDisplay->IsFloating() ||
25129:       NS_STYLE_DISPLAY_INLINE_BLOCK == aDisplay->mDisplay) {
25769:     *aNewFrame = NS_NewBlockFormattingContext(mPresShell, styleContext);
25129:   } else {
25769:     *aNewFrame = NS_NewBlockFrame(mPresShell, styleContext);
25769:   }
25769: 
25769:   return ConstructBlock(aState, aDisplay, aItem.mContent,
25129:                         aState.GetGeometricParent(aDisplay, aParentFrame),
25769:                         aParentFrame, styleContext, aNewFrame,
25129:                         aFrameItems, aDisplay->IsPositioned());
25131: }
25131: 
25131: 
25131: nsresult 
    1: nsCSSFrameConstructor::InitAndRestoreFrame(const nsFrameConstructorState& aState,
    1:                                            nsIContent*              aContent,
    1:                                            nsIFrame*                aParentFrame,
    1:                                            nsIFrame*                aPrevInFlow,
    1:                                            nsIFrame*                aNewFrame,
    1:                                            PRBool                   aAllowCounters)
    1: {
 6518:   NS_PRECONDITION(mUpdateCount != 0,
 6518:                   "Should be in an update while creating frames");
 6518:   
    1:   nsresult rv = NS_OK;
    1:   
    1:   NS_ASSERTION(aNewFrame, "Null frame cannot be initialized");
    1:   if (!aNewFrame)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   // Initialize the frame
    1:   rv = aNewFrame->Init(aContent, aParentFrame, aPrevInFlow);
16976:   aNewFrame->AddStateBits(aState.mAdditionalStateBits);
    1: 
    1:   if (aState.mFrameState && aState.mFrameManager) {
    1:     // Restore frame state for just the newly created frame.
    1:     aState.mFrameManager->RestoreFrameStateFor(aNewFrame, aState.mFrameState);
    1:   }
    1: 
    1:   if (aAllowCounters && !aPrevInFlow &&
    1:       mCounterManager.AddCounterResetsAndIncrements(aNewFrame)) {
    1:     CountersDirty();
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: already_AddRefed<nsStyleContext>
    1: nsCSSFrameConstructor::ResolveStyleContext(nsIFrame*         aParentFrame,
    1:                                            nsIContent*       aContent)
    1: {
18953:   nsStyleContext* parentStyleContext = nsnull;
28215:   NS_ASSERTION(aContent->GetParent(), "Must have parent here");
28215: 
  549:   aParentFrame = nsFrame::CorrectStyleParentFrame(aParentFrame, nsnull);
  549: 
18953:   if (aParentFrame) {
    1:     // Resolve the style context based on the content object and the parent
    1:     // style context
  822:     parentStyleContext = aParentFrame->GetStyleContext();
  822:   } else {
18953:     // Perhaps aParentFrame is a canvasFrame and we're replicating
18953:     // fixed-pos frames.
18953:     // XXX should we create a way to tell ConstructFrame which style
18953:     // context to use, and pass it the style context for the
18953:     // previous page's fixed-pos frame?
18953:   }
    1: 
25772:   return ResolveStyleContext(parentStyleContext, aContent);
25772: }
25772: 
25772: already_AddRefed<nsStyleContext>
25772: nsCSSFrameConstructor::ResolveStyleContext(nsStyleContext* aParentStyleContext,
25772:                                            nsIContent* aContent)
25772: {
    1:   nsStyleSet *styleSet = mPresShell->StyleSet();
    1: 
    1:   if (aContent->IsNodeOfType(nsINode::eELEMENT)) {
25772:     return styleSet->ResolveStyleFor(aContent, aParentStyleContext);
25772:   }
    1: 
    1:   NS_ASSERTION(aContent->IsNodeOfType(nsINode::eTEXT),
    1:                "shouldn't waste time creating style contexts for "
    1:                "comments and processing instructions");
    1: 
25772:   return styleSet->ResolveStyleForNonElement(aParentStyleContext);
    1: }
    1: 
    1: // MathML Mod - RBS
    1: #ifdef MOZ_MATHML
    1: nsresult
 6862: nsCSSFrameConstructor::FlushAccumulatedBlock(nsFrameConstructorState& aState,
 6862:                                              nsIContent* aContent,
 6862:                                              nsIFrame* aParentFrame,
 6862:                                              nsFrameItems* aBlockItems,
 6862:                                              nsFrameItems* aNewItems)
 6862: {
30785:   if (aBlockItems->IsEmpty()) {
 6862:     // Nothing to do
 6862:     return NS_OK;
 6862:   }
 6862: 
 6862:   nsStyleContext* parentContext =
 6862:     nsFrame::CorrectStyleParentFrame(aParentFrame,
 6862:                                      nsCSSAnonBoxes::mozMathMLAnonymousBlock)->GetStyleContext(); 
 6862:   nsStyleSet *styleSet = mPresShell->StyleSet();
 6862:   nsRefPtr<nsStyleContext> blockContext;
 6862:   blockContext = styleSet->ResolvePseudoStyleFor(aContent,
 6862:                                                  nsCSSAnonBoxes::mozMathMLAnonymousBlock,
 6862:                                                  parentContext);
 6862: 
 6862:   // then, create a block frame that will wrap the child frames. Make it a
 6862:   // MathML frame so that Get(Absolute/Float)ContainingBlockFor know that this
 6862:   // is not a suitable block.
 6862:   nsIFrame* blockFrame = NS_NewMathMLmathBlockFrame(mPresShell, blockContext,
23305:                           NS_BLOCK_FLOAT_MGR | NS_BLOCK_MARGIN_ROOT);
 6862:   if (NS_UNLIKELY(!blockFrame))
 6862:     return NS_ERROR_OUT_OF_MEMORY;
 6862: 
 6862:   InitAndRestoreFrame(aState, aContent, aParentFrame, nsnull, blockFrame);
30785:   ReparentFrames(aState.mFrameManager, blockFrame, *aBlockItems);
 6862:   // abs-pos and floats are disabled in MathML children so we don't have to
 6862:   // worry about messing up those.
30785:   blockFrame->SetInitialChildList(nsnull, *aBlockItems);
30790:   NS_ASSERTION(aBlockItems->IsEmpty(), "What happened?");
30790:   aBlockItems->Clear();
 6862:   aNewItems->AddChild(blockFrame);
 6862:   return NS_OK;
 6862: }
 6862: 
23946: // Only <math> elements can be floated or positioned.  All other MathML
23946: // should be in-flow.
23946: #define SIMPLE_MATHML_CREATE(_tag, _func)                               \
23946:   { &nsGkAtoms::_tag,                                                   \
23946:       FCDATA_DECL(FCDATA_DISALLOW_OUT_OF_FLOW |                         \
23946:                   FCDATA_FORCE_NULL_ABSPOS_CONTAINER |                  \
23946:                   FCDATA_WRAP_KIDS_IN_BLOCKS |                          \
23946:                   FCDATA_SKIP_FRAMEMAP, _func) }
23946: 
23946: /* static */
23946: const nsCSSFrameConstructor::FrameConstructionData*
23946: nsCSSFrameConstructor::FindMathMLData(nsIContent* aContent,
    1:                                       nsIAtom* aTag,
    1:                                       PRInt32 aNameSpaceID,
23946:                                       nsStyleContext* aStyleContext)
    1: {
    1:   // Make sure that we remain confined in the MathML world
    1:   if (aNameSpaceID != kNameSpaceID_MathML) 
23946:     return nsnull;
23946: 
25773:   // Handle <math> specially, because it sometimes produces inlines
25773:   if (aTag == nsGkAtoms::math) {
25773:     if (aStyleContext->GetStyleDisplay()->mDisplay == NS_STYLE_DISPLAY_BLOCK) {
25773:       static const FrameConstructionData sBlockMathData =
25773:         FCDATA_DECL(FCDATA_FORCE_NULL_ABSPOS_CONTAINER |
25773:                     FCDATA_WRAP_KIDS_IN_BLOCKS |
25773:                     FCDATA_SKIP_FRAMEMAP,
25773:                     NS_CreateNewMathMLmathBlockFrame);
25773:       return &sBlockMathData;
25773:     }
25773: 
25773:     static const FrameConstructionData sInlineMathData =
25773:       FCDATA_DECL(FCDATA_FORCE_NULL_ABSPOS_CONTAINER |
25773:                   FCDATA_WRAP_KIDS_IN_BLOCKS |
25773:                   FCDATA_SKIP_FRAMEMAP |
25773:                   FCDATA_IS_LINE_PARTICIPANT,
25773:                   NS_NewMathMLmathInlineFrame);
25773:     return &sInlineMathData;
25773:   }
25773:       
25773: 
23946:   static const FrameConstructionDataByTag sMathMLData[] = {
23946:     SIMPLE_MATHML_CREATE(mi_, NS_NewMathMLTokenFrame),
23946:     SIMPLE_MATHML_CREATE(mn_, NS_NewMathMLTokenFrame),
23946:     SIMPLE_MATHML_CREATE(ms_, NS_NewMathMLTokenFrame),
23946:     SIMPLE_MATHML_CREATE(mtext_, NS_NewMathMLTokenFrame),
23946:     SIMPLE_MATHML_CREATE(mo_, NS_NewMathMLmoFrame),
23946:     SIMPLE_MATHML_CREATE(mfrac_, NS_NewMathMLmfracFrame),
23946:     SIMPLE_MATHML_CREATE(msup_, NS_NewMathMLmsupFrame),
23946:     SIMPLE_MATHML_CREATE(msub_, NS_NewMathMLmsubFrame),
23946:     SIMPLE_MATHML_CREATE(msubsup_, NS_NewMathMLmsubsupFrame),
23946:     SIMPLE_MATHML_CREATE(munder_, NS_NewMathMLmunderFrame),
23946:     SIMPLE_MATHML_CREATE(mover_, NS_NewMathMLmoverFrame),
23946:     SIMPLE_MATHML_CREATE(munderover_, NS_NewMathMLmunderoverFrame),
23946:     SIMPLE_MATHML_CREATE(mphantom_, NS_NewMathMLmphantomFrame),
23946:     SIMPLE_MATHML_CREATE(mpadded_, NS_NewMathMLmpaddedFrame),
23946:     SIMPLE_MATHML_CREATE(mspace_, NS_NewMathMLmspaceFrame),
23946:     SIMPLE_MATHML_CREATE(none, NS_NewMathMLmspaceFrame),
23946:     SIMPLE_MATHML_CREATE(mprescripts_, NS_NewMathMLmspaceFrame),
23946:     SIMPLE_MATHML_CREATE(mfenced_, NS_NewMathMLmfencedFrame),
23946:     SIMPLE_MATHML_CREATE(mmultiscripts_, NS_NewMathMLmmultiscriptsFrame),
23946:     SIMPLE_MATHML_CREATE(mstyle_, NS_NewMathMLmstyleFrame),
23946:     SIMPLE_MATHML_CREATE(msqrt_, NS_NewMathMLmsqrtFrame),
23946:     SIMPLE_MATHML_CREATE(mroot_, NS_NewMathMLmrootFrame),
23946:     SIMPLE_MATHML_CREATE(maction_, NS_NewMathMLmactionFrame),
23946:     SIMPLE_MATHML_CREATE(mrow_, NS_NewMathMLmrowFrame),
31351:     SIMPLE_MATHML_CREATE(merror_, NS_NewMathMLmrowFrame),
31351:     SIMPLE_MATHML_CREATE(menclose_, NS_NewMathMLmencloseFrame)
23946:   };
23946: 
23946:   return FindDataByTag(aTag, aContent, aStyleContext, sMathMLData,
23946:                        NS_ARRAY_LENGTH(sMathMLData));
23167: }
23167: #endif // MOZ_MATHML
23167: 
23167: #ifdef MOZ_SVG
23954: // Only outer <svg> elements can be floated or positioned.  All other SVG
    1: // should be in-flow.
23954: #define SIMPLE_SVG_FCDATA(_func)                                        \
23954:   FCDATA_DECL(FCDATA_DISALLOW_OUT_OF_FLOW |                             \
23954:               FCDATA_SKIP_ABSPOS_PUSH | FCDATA_SKIP_FRAMEMAP |          \
23954:               FCDATA_DISALLOW_GENERATED_CONTENT,  _func)
23954: #define SIMPLE_SVG_CREATE(_tag, _func)            \
23954:   { &nsGkAtoms::_tag, SIMPLE_SVG_FCDATA(_func) }
23954: 
23954: /* static */
23954: const nsCSSFrameConstructor::FrameConstructionData*
23954: nsCSSFrameConstructor::FindSVGData(nsIContent* aContent,
    1:                                    nsIAtom* aTag,
    1:                                    PRInt32 aNameSpaceID,
23954:                                    nsIFrame* aParentFrame,
23954:                                    nsStyleContext* aStyleContext)
23954: {
23954:   if (aNameSpaceID != kNameSpaceID_SVG || !NS_SVGEnabled()) {
23954:     return nsnull;
23954:   }
23954: 
23954:   static const FrameConstructionData sSuppressData = SUPPRESS_FCDATA();
23954:   static const FrameConstructionData sGenericContainerData =
23954:     SIMPLE_SVG_FCDATA(NS_NewSVGGenericContainerFrame);
    1: 
    1:   PRBool parentIsSVG = PR_FALSE;
23954:   nsIContent* parentContent =
23954:     aParentFrame ? aParentFrame->GetContent() : nsnull;
23954:   // XXXbz should this really be based on the XBL-resolved tag of the parent
23954:   // frame's content?  Should it not be based on the type of the parent frame
23954:   // (e.g. whether it's an SVG frame)?
23954:   if (parentContent) {
    1:     PRInt32 parentNSID;
    1:     nsIAtom* parentTag =
23954:       parentContent->GetOwnerDoc()->BindingManager()->
23954:         ResolveTag(aParentFrame->GetContent(), &parentNSID);
    1: 
    1:     // It's not clear whether the SVG spec intends to allow any SVG
    1:     // content within svg:foreignObject at all (SVG 1.1, section
    1:     // 23.2), but if it does, it better be svg:svg.  So given that
    1:     // we're allowing it, treat it as a non-SVG parent.
16967:     parentIsSVG = parentNSID == kNameSpaceID_SVG &&
16967:                   parentTag != nsGkAtoms::foreignObject;
    1:   }
    1: 
    1:   if ((aTag != nsGkAtoms::svg && !parentIsSVG) ||
    1:       (aTag == nsGkAtoms::desc || aTag == nsGkAtoms::title)) {
    1:     // Sections 5.1 and G.4 of SVG 1.1 say that SVG elements other than
    1:     // svg:svg not contained within svg:svg are incorrect, although they
    1:     // don't seem to specify error handling.  Ignore them, since many of
    1:     // our frame classes can't deal.  It *may* be that the document
    1:     // should at that point be considered in error according to F.2, but
    1:     // it's hard to tell.
    1:     //
    1:     // Style mutation can't change this situation, so don't bother
    1:     // adding to the undisplayed content map.
23954:     // XXXbz except of course that this makes GetPrimaryFrameFor for this stuff
23954:     // that much slower.
    1:     //
    1:     // We don't currently handle any UI for desc/title
23954:     return &sSuppressData;
    1:   }
    1: 
15895:   // Reduce the number of frames we create unnecessarily. Note that this is not
15895:   // where we select which frame in a <switch> to render! That happens in
15895:   // nsSVGSwitchFrame::PaintSVG.
28081:   if (!nsSVGFeatures::PassesConditionalProcessingTests(aContent)) {
    1:     // Note that just returning is probably not right.  According
    1:     // to the spec, <use> is allowed to use an element that fails its
    1:     // conditional, but because we never actually create the frame when
    1:     // a conditional fails and when we use GetReferencedFrame to find the
    1:     // references, things don't work right.
    1:     // XXX FIXME XXX
23954:     return &sSuppressData;
23954:   }
23954: 
23954:   // Special case for aTag == nsGkAtoms::svg because we don't want to
23954:   // have to recompute parentIsSVG for it.
    1:   if (aTag == nsGkAtoms::svg) {
23954:     if (parentIsSVG) {
23954:       static const FrameConstructionData sInnerSVGData =
23954:         SIMPLE_SVG_FCDATA(NS_NewSVGInnerSVGFrame);
23954:       return &sInnerSVGData;
23954:     }
23954: 
23954:     static const FrameConstructionData sOuterSVGData =
23954:       FCDATA_DECL(FCDATA_FORCE_VIEW | FCDATA_SKIP_ABSPOS_PUSH |
23954:                   FCDATA_SKIP_FRAMEMAP | FCDATA_DISALLOW_GENERATED_CONTENT,
23954:                   NS_NewSVGOuterSVGFrame);
23954:     return &sOuterSVGData;
23954:   }
23954: 
23954:   // Special cases for text/tspan/textpath, because the kind of frame
23954:   // they get depends on the parent frame.
23954:   if (aTag == nsGkAtoms::text) {
25772:     NS_ASSERTION(aParentFrame, "Should have aParentFrame here");
23953:     nsIFrame *ancestorFrame =
23953:       nsSVGUtils::GetFirstNonAAncestorFrame(aParentFrame);
16390:     if (ancestorFrame) {
29052:       nsSVGTextContainerFrame* metrics = do_QueryFrame(ancestorFrame);
16390:       // Text cannot be nested
23954:       if (metrics) {
23954:         return &sGenericContainerData;
23954:       }
    1:     }
16390:   }
    1:   else if (aTag == nsGkAtoms::tspan) {
25772:     NS_ASSERTION(aParentFrame, "Should have aParentFrame here");
23953:     nsIFrame *ancestorFrame =
23953:       nsSVGUtils::GetFirstNonAAncestorFrame(aParentFrame);
    1:     if (ancestorFrame) {
29052:       nsSVGTextContainerFrame* metrics = do_QueryFrame(ancestorFrame);
23954:       if (!metrics) {
23954:         return &sGenericContainerData;
23954:       }
23954:     }
    1:   }
    1:   else if (aTag == nsGkAtoms::textPath) {
25772:     NS_ASSERTION(aParentFrame, "Should have aParentFrame here");
23953:     nsIFrame *ancestorFrame =
23953:       nsSVGUtils::GetFirstNonAAncestorFrame(aParentFrame);
23954:     if (!ancestorFrame ||
23954:         ancestorFrame->GetType() != nsGkAtoms::svgTextFrame) {
23954:       return &sGenericContainerData;
23954:     }
23954:   }
23954: 
23954:   static const FrameConstructionDataByTag sSVGData[] = {
23954:     SIMPLE_SVG_CREATE(g, NS_NewSVGGFrame),
23954:     SIMPLE_SVG_CREATE(svgSwitch, NS_NewSVGSwitchFrame),
23954:     SIMPLE_SVG_CREATE(polygon, NS_NewSVGPathGeometryFrame),
23954:     SIMPLE_SVG_CREATE(polyline, NS_NewSVGPathGeometryFrame),
23954:     SIMPLE_SVG_CREATE(circle, NS_NewSVGPathGeometryFrame),
23954:     SIMPLE_SVG_CREATE(ellipse, NS_NewSVGPathGeometryFrame),
23954:     SIMPLE_SVG_CREATE(line, NS_NewSVGPathGeometryFrame),
23954:     SIMPLE_SVG_CREATE(rect, NS_NewSVGPathGeometryFrame),
23954:     SIMPLE_SVG_CREATE(path, NS_NewSVGPathGeometryFrame),
23954:     SIMPLE_SVG_CREATE(defs, NS_NewSVGContainerFrame),
25772:     { &nsGkAtoms::foreignObject,
25772:       FULL_CTOR_FCDATA(FCDATA_DISALLOW_OUT_OF_FLOW,
25772:                        &nsCSSFrameConstructor::ConstructSVGForeignObjectFrame) },
23954:     SIMPLE_SVG_CREATE(a, NS_NewSVGAFrame),
23954:     SIMPLE_SVG_CREATE(text, NS_NewSVGTextFrame),
23954:     SIMPLE_SVG_CREATE(tspan, NS_NewSVGTSpanFrame),
23954:     SIMPLE_SVG_CREATE(linearGradient, NS_NewSVGLinearGradientFrame),
23954:     SIMPLE_SVG_CREATE(radialGradient, NS_NewSVGRadialGradientFrame),
23954:     SIMPLE_SVG_CREATE(stop, NS_NewSVGStopFrame),
23954:     SIMPLE_SVG_CREATE(use, NS_NewSVGUseFrame),
23954:     SIMPLE_SVG_CREATE(marker, NS_NewSVGMarkerFrame),
23954:     SIMPLE_SVG_CREATE(image, NS_NewSVGImageFrame),
23954:     SIMPLE_SVG_CREATE(clipPath, NS_NewSVGClipPathFrame),
23954:     SIMPLE_SVG_CREATE(textPath, NS_NewSVGTextPathFrame),
23954:     SIMPLE_SVG_CREATE(filter, NS_NewSVGFilterFrame),
23954:     SIMPLE_SVG_CREATE(pattern, NS_NewSVGPatternFrame),
23954:     SIMPLE_SVG_CREATE(mask, NS_NewSVGMaskFrame),
23954:     SIMPLE_SVG_CREATE(feDistantLight, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(fePointLight, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feSpotLight, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feBlend, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feColorMatrix, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feFuncR, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feFuncG, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feFuncB, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feFuncA, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feComposite, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feConvolveMatrix, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feDisplacementMap, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feFlood, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feGaussianBlur, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feImage, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feMergeNode, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feMorphology, NS_NewSVGLeafFrame), 
23954:     SIMPLE_SVG_CREATE(feOffset, NS_NewSVGLeafFrame), 
23954:     SIMPLE_SVG_CREATE(feTile, NS_NewSVGLeafFrame), 
23954:     SIMPLE_SVG_CREATE(feTurbulence, NS_NewSVGLeafFrame) 
23954:   };
23954: 
23954:   const FrameConstructionData* data =
23954:     FindDataByTag(aTag, aContent, aStyleContext, sSVGData,
23954:                   NS_ARRAY_LENGTH(sSVGData));
23954: 
23954:   if (!data) {
23954:     data = &sGenericContainerData;
23954:   }
23954: 
23954:   return data;
23954: }
23954: 
23954: nsresult
23954: nsCSSFrameConstructor::ConstructSVGForeignObjectFrame(nsFrameConstructorState& aState,
25769:                                                       FrameConstructionItem&   aItem,
23954:                                                       nsIFrame* aParentFrame,
23954:                                                       const nsStyleDisplay* aStyleDisplay,
23954:                                                       nsFrameItems& aFrameItems,
23954:                                                       nsIFrame** aNewFrame)
23954: {
25769:   nsIContent* const content = aItem.mContent;
25769:   nsStyleContext* const styleContext = aItem.mStyleContext;
25769: 
25769:   nsIFrame* newFrame = NS_NewSVGForeignObjectFrame(mPresShell, styleContext);
23954:   if (NS_UNLIKELY(!newFrame)) {
23954:     return NS_ERROR_OUT_OF_MEMORY;
23954:   }
23954: 
23954:   // We don't allow this frame to be out of flow
25769:   InitAndRestoreFrame(aState, content, aParentFrame, nsnull, newFrame);
23954:   nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
23954: 
25769:   nsresult rv = aState.AddChild(newFrame, aFrameItems, content, styleContext,
23954:                                 aParentFrame, PR_FALSE, PR_FALSE);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   nsRefPtr<nsStyleContext> innerPseudoStyle;
    1:   innerPseudoStyle = mPresShell->StyleSet()->
25769:     ResolvePseudoStyleFor(content,
25769:                           nsCSSAnonBoxes::mozSVGForeignContent, styleContext);
    1: 
    1:   nsIFrame* blockFrame = NS_NewBlockFrame(mPresShell, innerPseudoStyle,
23305:                                           NS_BLOCK_FLOAT_MGR |
    1:                                           NS_BLOCK_MARGIN_ROOT);
23954:   if (NS_UNLIKELY(!blockFrame)) {
23954:     newFrame->Destroy();
    1:     return NS_ERROR_OUT_OF_MEMORY;
23954:   }
23954: 
23954:   nsFrameItems childItems;
    1:   // Claim to be relatively positioned so that we end up being the
    1:   // absolute containing block.
25769:   rv = ConstructBlock(aState, innerPseudoStyle->GetStyleDisplay(), content,
    1:                       newFrame, newFrame, innerPseudoStyle,
    1:                       &blockFrame, childItems, PR_TRUE);
23954: 
    1:   // Give the blockFrame a view so that GetOffsetTo works for descendants
    1:   // of blockFrame with views...
23395:   nsHTMLContainerFrame::CreateViewForFrame(blockFrame, PR_TRUE);
23954: 
30785:   newFrame->SetInitialChildList(nsnull, childItems);
23954: 
23954:   *aNewFrame = newFrame;
23954: 
23954:   return rv;
23954: }
23954: 
    1: #endif // MOZ_SVG
    1: 
25771: void
25771: nsCSSFrameConstructor::AddPageBreakItem(nsIContent* aContent,
25771:                                         nsStyleContext* aMainStyleContext,
25774:                                         FrameConstructionItemList& aItems)
    1: {
    1:   nsRefPtr<nsStyleContext> pseudoStyle;
25771:   // Use the same parent style context that |aMainStyleContext| has, since
23162:   // that's easier to re-resolve and it doesn't matter in practice.
23162:   // (Getting different parents can result in framechange hints, e.g.,
23162:   // for user-modify.)
25771:   pseudoStyle =
25771:     mPresShell->StyleSet()->
25771:       ResolvePseudoStyleFor(nsnull, nsCSSAnonBoxes::pageBreak,
25771:                             aMainStyleContext->GetParent());
25772: 
25772:   NS_ASSERTION(pseudoStyle->GetStyleDisplay()->mDisplay ==
25772:                  NS_STYLE_DISPLAY_BLOCK, "Unexpected display");
25772: 
25771:   static const FrameConstructionData sPageBreakData =
25771:     FCDATA_DECL(FCDATA_SKIP_FRAMEMAP, NS_NewPageBreakFrame);
25771: 
25771:   // Lie about the tag and namespace so we don't trigger anything
25771:   // interesting during frame construction.
25981:   aItems.AppendItem(&sPageBreakData, aContent, nsCSSAnonBoxes::pageBreak,
29501:                     kNameSpaceID_None, -1, pseudoStyle.forget());
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructFrame(nsFrameConstructorState& aState,
    1:                                       nsIContent*              aContent,
    1:                                       nsIFrame*                aParentFrame,
    1:                                       nsFrameItems&            aFrameItems)
    1: 
    1: {
    1:   NS_PRECONDITION(nsnull != aParentFrame, "no parent frame");
25774:   FrameConstructionItemList items;
29501:   AddFrameConstructionItems(aState, aContent, -1, aParentFrame, items);
25771: 
25774:   for (FCItemIterator iter(items); !iter.IsDone(); iter.Next()) {
26208:     NS_ASSERTION(iter.item().DesiredParentType() == GetParentType(aParentFrame),
26208:                  "This is not going to work");
25771:     nsresult rv =
25774:       ConstructFramesFromItem(aState, iter, aParentFrame, aFrameItems);
25771:     NS_ENSURE_SUCCESS(rv, rv);
25771:   }
25771: 
25768:   return NS_OK;
25768: }
25768: 
25768: void
25771: nsCSSFrameConstructor::AddFrameConstructionItems(nsFrameConstructorState& aState,
25768:                                                  nsIContent* aContent,
29501:                                                  PRInt32 aContentIndex,
25768:                                                  nsIFrame* aParentFrame,
25774:                                                  FrameConstructionItemList& aItems)
25768: {
    1:   // don't create a whitespace frame if aParent doesn't want it
    1:   if (!NeedFrameFor(aParentFrame, aContent)) {
25768:     return;
    1:   }
    1: 
    1:   // never create frames for comments or PIs
    1:   if (aContent->IsNodeOfType(nsINode::eCOMMENT) ||
    1:       aContent->IsNodeOfType(nsINode::ePROCESSING_INSTRUCTION))
25768:     return;
    1: 
    1:   nsRefPtr<nsStyleContext> styleContext;
    1:   styleContext = ResolveStyleContext(aParentFrame, aContent);
    1: 
25771:   AddFrameConstructionItemsInternal(aState, aContent, aParentFrame,
    1:                                     aContent->Tag(), aContent->GetNameSpaceID(),
29501:                                     aContentIndex, styleContext,
25768:                                     ITEM_ALLOW_XBL_BASE | ITEM_ALLOW_PAGE_BREAK,
25768:                                     aItems);
25768: }
25768: 
28357: /**
28357:  * Set aContent as undisplayed content with style context aStyleContext.  This
28357:  * method enforces the invariant that all style contexts in the undisplayed
28357:  * content map must be non-pseudo contexts and also handles unbinding
28357:  * undisplayed generated content as needed.
28357:  */
28357: static void
28357: SetAsUndisplayedContent(nsFrameManager* aFrameManager, nsIContent* aContent,
28357:                         nsStyleContext* aStyleContext,
28357:                         PRBool aIsGeneratedContent)
28357: {
28357:   if (aStyleContext->GetPseudoType()) {
28357:     if (aIsGeneratedContent) {
28357:       aContent->UnbindFromTree();
28357:     }
28357:     return;
28357:   }
28357: 
28357:   NS_ASSERTION(!aIsGeneratedContent, "Should have had pseudo type");
28357:   aFrameManager->SetUndisplayedContent(aContent, aStyleContext);
28357: }
25768: 
25768: void
25771: nsCSSFrameConstructor::AddFrameConstructionItemsInternal(nsFrameConstructorState& aState,
    1:                                                          nsIContent* aContent,
    1:                                                          nsIFrame* aParentFrame,
    1:                                                          nsIAtom* aTag,
    1:                                                          PRInt32 aNameSpaceID,
29501:                                                          PRInt32 aContentIndex,
    1:                                                          nsStyleContext* aStyleContext,
25768:                                                          PRUint32 aFlags,
25774:                                                          FrameConstructionItemList& aItems)
    1: {
29501:   NS_ASSERTION(aContentIndex == -1 ||
29501:                aContent->GetParent()->GetChildAt(aContentIndex) == aContent,
29501:                "aContentIndex isn't the right content index");
29501: 
    1:   // The following code allows the user to specify the base tag
    1:   // of an element using XBL.  XUL and HTML objects (like boxes, menus, etc.)
    1:   // can then be extended arbitrarily.
    1:   const nsStyleDisplay* display = aStyleContext->GetStyleDisplay();
    1:   nsRefPtr<nsStyleContext> styleContext(aStyleContext);
    1:   nsAutoEnqueueBinding binding(mDocument);
25768:   if ((aFlags & ITEM_ALLOW_XBL_BASE) && display->mBinding)
25649:   {
    1:     // Ensure that our XBL bindings are installed.
    1: 
    1:     nsIXBLService * xblService = GetXBLService();
    1:     if (!xblService)
25768:       return;
    1: 
25649:     PRBool resolveStyle;
25649: 
25649:     nsresult rv = xblService->LoadBindings(aContent, display->mBinding->mURI,
 3645:                                            display->mBinding->mOriginPrincipal,
25649:                                            PR_FALSE,
25649:                                            getter_AddRefs(binding.mBinding),
    1:                                            &resolveStyle);
    1:     if (NS_FAILED(rv))
25768:       return;
    1: 
    1:     if (resolveStyle) {
25772:       styleContext = ResolveStyleContext(styleContext->GetParent(), aContent);
    1:       display = styleContext->GetStyleDisplay();
25649:       aStyleContext = styleContext;
25649:     }
25649: 
25649:     aTag = mDocument->BindingManager()->ResolveTag(aContent, &aNameSpaceID);
    1:   }
    1: 
28357:   PRBool isGeneratedContent = ((aFlags & ITEM_IS_GENERATED_CONTENT) != 0);
28357: 
    1:   // Pre-check for display "none" - if we find that, don't create
    1:   // any frame at all
    1:   if (NS_STYLE_DISPLAY_NONE == display->mDisplay) {
28357:     SetAsUndisplayedContent(aState.mFrameManager, aContent, styleContext,
28357:                             isGeneratedContent);
25768:     return;
    1:   }
    1: 
23955:   PRBool isText = aContent->IsNodeOfType(nsINode::eTEXT);
25772:   PRBool isPopup = PR_FALSE;
23955:   // Try to find frame construction data for this content
23955:   const FrameConstructionData* data;
23955:   if (isText) {
23955:     data = FindTextData(aParentFrame);
25131: #ifdef MOZ_SVG
25131:     if (!data) {
25131:       // Nothing to do here; suppressed text inside SVG
25768:       return;
25131:     }
25131: #endif /* MOZ_SVG */
23955:   } else {
25131: #ifdef MOZ_SVG
25131:     // Don't create frames for non-SVG element children of SVG elements.
25131:     if (aNameSpaceID != kNameSpaceID_SVG &&
25131:         aParentFrame &&
25131:         aParentFrame->IsFrameOfType(nsIFrame::eSVG) &&
25131:         !aParentFrame->IsFrameOfType(nsIFrame::eSVGForeignObject)
25131:         ) {
28357:       SetAsUndisplayedContent(aState.mFrameManager, aContent, styleContext,
28357:                               isGeneratedContent);
25768:       return;
25131:     }
25131: #endif /* MOZ_SVG */
25131: 
24550:     data = FindHTMLData(aContent, aTag, aNameSpaceID, aParentFrame,
24550:                         styleContext);
23955:     if (!data) {
23955:       data = FindXULTagData(aContent, aTag, aNameSpaceID, styleContext);
23955:     }
23955: #ifdef MOZ_MATHML
23955:     if (!data) {
23955:       data = FindMathMLData(aContent, aTag, aNameSpaceID, styleContext);
23955:     }
23955: #endif
23955: #ifdef MOZ_SVG
23955:     if (!data) {
23955:       data = FindSVGData(aContent, aTag, aNameSpaceID, aParentFrame,
23955:                          styleContext);
23955:     }
23955: #endif /* MOZ_SVG */
23955: 
25131:     // Now check for XUL display types
25131:     if (!data) {
25649:       data = FindXULDisplayData(display, aContent, styleContext);
25131:     }
25131: 
25131:     // And general display types
25131:     if (!data) {
26207:       data = FindDisplayData(display, aContent, styleContext);
25131:     }
25131: 
25131:     NS_ASSERTION(data, "Should have frame construction data now");
25131: 
25131:     if (data->mBits & FCDATA_SUPPRESS_FRAME) {
28357:       SetAsUndisplayedContent(aState.mFrameManager, aContent, styleContext,
28357:                               isGeneratedContent);
25768:       return;
23955:     }
25650: 
25650: #ifdef MOZ_XUL
25650:     if ((data->mBits & FCDATA_IS_POPUP) &&
25772:         (!aParentFrame || // Parent is inline
25772:          aParentFrame->GetType() != nsGkAtoms::menuFrame)) {
25772:       if (!aState.mPopupItems.containingBlock &&
25768:           !aState.mHavePendingPopupgroup) {
28357:         SetAsUndisplayedContent(aState.mFrameManager, aContent, styleContext,
28357:                                 isGeneratedContent);
25768:         return;
25650:       }
25772: 
25772:       isPopup = PR_TRUE;
25772:     }
25650: #endif /* MOZ_XUL */
23955:   }
23955: 
25772:   PRUint32 bits = data->mBits;
25772: 
25770:   // Inside colgroups, suppress everything except columns.
25770:   if (aParentFrame &&
25770:       aParentFrame->GetType() == nsGkAtoms::tableColGroupFrame &&
25772:       (!(bits & FCDATA_IS_TABLE_PART) ||
25770:        display->mDisplay != NS_STYLE_DISPLAY_TABLE_COLUMN)) {
28357:     SetAsUndisplayedContent(aState.mFrameManager, aContent, styleContext,
28357:                             isGeneratedContent);
25770:     return;
25770:   }
25770: 
25771:   PRBool canHavePageBreak =
25771:     (aFlags & ITEM_ALLOW_PAGE_BREAK) &&
25771:     aState.mPresContext->IsPaginated() &&
25771:     !display->IsAbsolutelyPositioned() &&
25772:     !(bits & FCDATA_IS_TABLE_PART);
25771: 
25771:   if (canHavePageBreak && display->mBreakBefore) {
25771:     AddPageBreakItem(aContent, aStyleContext, aItems);
25771:   }
25771: 
25981:   FrameConstructionItem* item =
29501:     aItems.AppendItem(data, aContent, aTag, aNameSpaceID, aContentIndex,
25981:                       styleContext.forget());
25768:   if (!item) {
25768:     if (isGeneratedContent) {
25768:       aContent->UnbindFromTree();
25768:     }
25768:     return;
25768:   }
25768: 
25768:   item->mIsText = isText;
25768:   item->mIsGeneratedContent = isGeneratedContent;
25768:   if (isGeneratedContent) {
25768:     NS_ADDREF(item->mContent);
25768:   }
25769:   item->mIsRootPopupgroup =
25769:     aNameSpaceID == kNameSpaceID_XUL && aTag == nsGkAtoms::popupgroup &&
25769:     aContent->IsRootOfNativeAnonymousSubtree();
25769:   if (item->mIsRootPopupgroup) {
25769:     aState.mHavePendingPopupgroup = PR_TRUE;
25769:   }
25772:   item->mIsPopup = isPopup;
25771: 
25771:   if (canHavePageBreak && display->mBreakAfter) {
25771:     AddPageBreakItem(aContent, aStyleContext, aItems);
25771:   }
25772: 
25772:   if (bits & FCDATA_IS_INLINE) {
25772:     // To correctly set item->mIsAllInline we need to build up our child items
25772:     // right now.
25772:     BuildInlineChildItems(aState, *item);
25773:     item->mHasInlineEnds = PR_TRUE;
25772:   } else {
25773:     item->mIsAllInline = item->mHasInlineEnds =
25772:       // Table-internal things are inline-outside if they're kids of
25772:       // inlines, since they'll trigger construction of inline-table
25772:       // pseudos.
25772:       ((bits & FCDATA_IS_TABLE_PART) &&
25772:        (!aParentFrame || // No aParentFrame means inline
25772:         aParentFrame->GetStyleDisplay()->mDisplay == NS_STYLE_DISPLAY_INLINE)) ||
25772:       // Things that are inline-outside but aren't inline frames are inline
25772:       display->IsInlineOutside() ||
25772:       // Things that we're guaranteed will end up out-of-flow are inline.  This
25772:       // is not a precise test, since one of our ancestor inlines might add an
25772:       // absolute containing block (if it's relatively positioned) or float
25772:       // containing block (the latter if it gets split by child blocks on both
25772:       // sides of us) when there wasn't such a containining block before.  But
25772:       // it's conservative in the sense that anything that will really end up
25772:       // as an in-flow non-inline will have false mIsAllInline.  It just might
25772:       // be that even an inline that has mIsAllInline false doesn't need an
29075:       // {ib} split.  So this is just an optimization to keep from doing too
25772:       // much work when that happens.
25772:       (!(bits & FCDATA_DISALLOW_OUT_OF_FLOW) &&
25772:        aState.GetGeometricParent(display, nsnull)) ||
25772:       // Popups that are certainly out of flow.
25772:       isPopup;
25772:   }
25774: 
25774:   if (item->mIsAllInline) {
25774:     aItems.InlineItemAdded();
25774:   }
25774: 
29075:   // Our item should be treated as a line participant if we have the relevant
29075:   // bit and are going to be in-flow.  Note that this really only matters if
29075:   // our ancestor is a box or some such, so the fact that we might have an
29075:   // inline ancestor that might become a containing block is not relevant here.
29075:   if ((bits & FCDATA_IS_LINE_PARTICIPANT) &&
29075:       ((bits & FCDATA_DISALLOW_OUT_OF_FLOW) ||
29075:        !aState.GetGeometricParent(display, nsnull))) {
29075:     item->mIsLineParticipant = PR_TRUE;
25774:     aItems.LineParticipantItemAdded();
25774:   }
25768: }
25768: 
25768: static void DestroyContent(void *aObject,
25768:                            nsIAtom *aPropertyName,
25768:                            void *aPropertyValue,
25768:                            void *aData)
25768: {
25768:   nsIContent* content = static_cast<nsIContent*>(aPropertyValue);
25768:   content->UnbindFromTree();
25768:   NS_RELEASE(content);
25768: }
25768: 
29501: /**
29501:  * Return true if the frame construction item pointed to by aIter will
29501:  * create a frame adjacent to a line boundary in the frame tree, and that
29501:  * line boundary is induced by a content node adjacent to the frame's
29501:  * content node in the content tree. The latter condition is necessary so
29501:  * that ContentAppended/ContentInserted/ContentRemoved can easily find any
29501:  * text nodes that were suppressed here.
29501:  */
29501: PRBool
29501: nsCSSFrameConstructor::AtLineBoundary(FCItemIterator& aIter)
29501: {
29501:   PRInt32 contentIndex = aIter.item().mContentIndex;
29501:   if (contentIndex < 0) {
29501:     // Anonymous, or location unknown, so we can't reliably tell where it
29501:     // is in the content tree
29501:     return PR_FALSE;
29501:   }
29501: 
29501:   if (aIter.AtStart()) {
29501:     if (aIter.List()->HasLineBoundaryAtStart() &&
29501:         contentIndex == 0)
29501:       return PR_TRUE;
29501:   } else {
29501:     FCItemIterator prev = aIter;
29501:     prev.Prev();
29501:     PRInt32 prevIndex = prev.item().mContentIndex;
29501:     if (prev.item().IsLineBoundary() &&
29501:         prevIndex >= 0 && prevIndex + 1 == contentIndex)
29501:       return PR_TRUE;
29501:   }
29501: 
29501:   FCItemIterator next = aIter;
29501:   next.Next();
29501:   if (next.IsDone()) {
29501:     if (aIter.List()->HasLineBoundaryAtEnd() &&
29501:         contentIndex == PRInt32(aIter.item().mContent->GetParent()->GetChildCount()) - 1)
29501:       return PR_TRUE;
29501:   } else {
29501:     if (next.item().IsLineBoundary() &&
29501:         contentIndex + 1 == next.item().mContentIndex)
29501:       return PR_TRUE;
29501:   }
29501: 
29501:   return PR_FALSE;
29501: }
29501: 
25768: nsresult
25768: nsCSSFrameConstructor::ConstructFramesFromItem(nsFrameConstructorState& aState,
29501:                                                FCItemIterator& aIter,
25768:                                                nsIFrame* aParentFrame,
25768:                                                nsFrameItems& aFrameItems)
25768: {
    1:   nsIFrame* adjParentFrame = aParentFrame;
29501:   FrameConstructionItem& item = aIter.item();
29501:   nsStyleContext* styleContext = item.mStyleContext;
29501:   AdjustParentFrame(adjParentFrame, item.mFCData, styleContext);
29501: 
29501:   if (item.mIsText) {
29501:     // If this is collapsible whitespace next to a line boundary,
29809:     // don't create a frame. item.IsWhitespace() also sets the
29809:     // NS_CREATE_FRAME_IF_NON_WHITESPACE flag in the text node. (If we
29809:     // end up creating a frame, nsTextFrame::Init will clear the flag.)
29501:     // We don't do this for generated content, because some generated
29501:     // text content is empty text nodes that are about to be initialized.
29501:     // (We check mAdditionalStateBits because only the generated content
29501:     // container's frame construction item is marked with
29501:     // mIsGeneratedContent, and we might not have an aParentFrame.)
29501:     // We don't do it for content that may have XBL anonymous siblings,
29501:     // because they make it difficult to correctly create the frame
29501:     // due to dynamic changes.
29992:     // We don't do it for text that's not a line participant (i.e. SVG text).
29501:     if (AtLineBoundary(aIter) &&
29501:         !styleContext->GetStyleText()->NewlineIsSignificant() &&
29501:         aIter.List()->ParentHasNoXBLChildren() &&
29501:         !(aState.mAdditionalStateBits & NS_FRAME_GENERATED_CONTENT) &&
29992:         (item.mFCData->mBits & FCDATA_IS_LINE_PARTICIPANT) &&
29501:         item.IsWhitespace())
29501:       return NS_OK;
29501: 
29501:     return ConstructTextFrame(item.mFCData, aState, item.mContent,
25768:                               adjParentFrame, styleContext,
26208:                               aFrameItems);
23955:   }
    1: 
    1:   // Start background loads during frame construction. This is just
    1:   // a hint; the paint code will do the right thing in any case.
    1:   {
    1:     styleContext->GetStyleBackground();
    1:   }
    1: 
25768:   nsFrameState savedStateBits = aState.mAdditionalStateBits;
29501:   if (item.mIsGeneratedContent) {
25768:     // Ensure that frames created here are all tagged with
25768:     // NS_FRAME_GENERATED_CONTENT.
25768:     aState.mAdditionalStateBits |= NS_FRAME_GENERATED_CONTENT;
25768: 
26208:     // Note that we're not necessarily setting this property on the primary
26208:     // frame for the content for which this is generated content.  We might be
26208:     // setting it on a table pseudo-frame inserted under that instead.  That's
26208:     // OK, though; we just need to do the property set so that the content will
26208:     // get cleaned up when the frame is destroyed.
25768:     aParentFrame->SetProperty(styleContext->GetPseudoType(),
29501:                               item.mContent, DestroyContent);
29501: 
29501:     // Now that we've passed ownership of item.mContent to the frame, unset
25768:     // our generated content flag so we don't release or unbind it ourselves.
29501:     item.mIsGeneratedContent = PR_FALSE;
25768:   }
25768: 
25769:   // XXXbz maybe just inline ConstructFrameFromItemInternal here or something?
29501:   nsresult rv = ConstructFrameFromItemInternal(item, aState, adjParentFrame,
26208:                                                aFrameItems);
25649: 
25768:   aState.mAdditionalStateBits = savedStateBits;
25649: 
25649:   return rv;
    1: }
    1: 
    1: 
    1: inline PRBool
    1: IsRootBoxFrame(nsIFrame *aFrame)
    1: {
    1:   return (aFrame->GetType() == nsGkAtoms::rootFrame);
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ReconstructDocElementHierarchy()
    1: {
31031:   return RecreateFramesForContent(mPresShell->GetDocument()->GetRootContent(), PR_FALSE);
28215: }
    1: 
    1: nsIFrame*
    1: nsCSSFrameConstructor::GetFrameFor(nsIContent* aContent)
    1: {
    1:   // Get the primary frame associated with the content
    1:   nsIFrame* frame = mPresShell->GetPrimaryFrameFor(aContent);
    1: 
    1:   if (!frame)
    1:     return nsnull;
    1: 
    1:   nsIFrame* insertionFrame = frame->GetContentInsertionFrame();
    1: 
    1:   NS_ASSERTION(insertionFrame == frame || !frame->IsLeaf(),
    1:     "The insertion frame is the primary frame or the primary frame isn't a leaf");
    1: 
    1:   return insertionFrame;
    1: }
    1: 
    1: nsIFrame*
    1: nsCSSFrameConstructor::GetAbsoluteContainingBlock(nsIFrame* aFrame)
    1: {
24659:   NS_PRECONDITION(nsnull != mRootElementFrame, "no root element frame");
    1:   
    1:   // Starting with aFrame, look for a frame that is absolutely positioned or
    1:   // relatively positioned
    1:   nsIFrame* containingBlock = nsnull;
    1:   for (nsIFrame* frame = aFrame; frame && !containingBlock;
    1:        frame = frame->GetParent()) {
    1:     if (frame->IsFrameOfType(nsIFrame::eMathML)) {
    1:       // If it's mathml, bail out -- no absolute positioning out from inside
    1:       // mathml frames.  Note that we don't make this part of the loop
20147:       // condition because of the stuff at the end of this method...
    1:       return nsnull;
    1:     }
    1:     
    1:     // Is it positioned?
    1:     // If it's table-related then ignore it, because for the time
    1:     // being table-related frames are not containers for absolutely
    1:     // positioned child frames.
    1:     const nsStyleDisplay* disp = frame->GetStyleDisplay();
    1: 
26208:     if (disp->IsPositioned() && !IsTableRelated(frame->GetType())) {
    1:       // Find the outermost wrapped block under this frame
    1:       for (nsIFrame* wrappedFrame = aFrame; wrappedFrame != frame->GetParent();
    1:            wrappedFrame = wrappedFrame->GetParent()) {
    1:         nsIAtom* frameType = wrappedFrame->GetType();
23176:         if (nsGkAtoms::blockFrame == frameType ||
23176: #ifdef MOZ_XUL
23176:             nsGkAtoms::XULLabelFrame == frameType ||
23176: #endif
    1:             nsGkAtoms::positionedInlineFrame == frameType) {
    1:           containingBlock = wrappedFrame;
    1:         } else if (nsGkAtoms::fieldSetFrame == frameType) {
    1:           // If the positioned frame is a fieldset, use the area frame inside it.
    1:           // We don't use GetContentInsertionFrame for fieldsets yet.
23176:           containingBlock = GetFieldSetBlockFrame(wrappedFrame);
    1:         }
    1:       }
    1: 
    1: #ifdef DEBUG
    1:       if (!containingBlock)
    1:         NS_WARNING("Positioned frame that does not handle positioned kids; looking further up the parent chain");
    1: #endif
    1:     }
    1:   }
    1: 
 7680:   // If we found an absolutely positioned containing block, then use the
 7680:   // first-continuation.
    1:   if (containingBlock)
 7680:     return AdjustAbsoluteContainingBlock(containingBlock);
    1: 
18953:   // If we didn't find it, then use the document element containing block
18953:   return mHasRootAbsPosContainingBlock ? mDocElementContainingBlock : nsnull;
    1: }
    1: 
    1: nsIFrame*
    1: nsCSSFrameConstructor::GetFloatContainingBlock(nsIFrame* aFrame)
    1: {
    1:   // Starting with aFrame, look for a frame that is a float containing block.
    1:   // IF we hit a mathml frame, bail out; we don't allow floating out of mathml
    1:   // frames, because they don't seem to be able to deal.
23352:   // The logic here needs to match the logic in ProcessChildren()
    1:   for (nsIFrame* containingBlock = aFrame;
 2192:        containingBlock && !containingBlock->IsFrameOfType(nsIFrame::eMathML) &&
 2192:        !containingBlock->IsBoxFrame();
    1:        containingBlock = containingBlock->GetParent()) {
    1:     if (containingBlock->IsFloatContainingBlock()) {
    1:       return containingBlock;
    1:     }
    1:   }
    1: 
    1:   // If we didn't find a containing block, then there just isn't
    1:   // one.... return null
    1:   return nsnull;
    1: }
    1: 
    1: /**
    1:  * This function will check whether aContainer has :after generated content.
    1:  * If so, appending to it should actually insert.  The return value is the
    1:  * parent to use for newly-appended content.  *aAfterFrame points to the :after
    1:  * frame before which appended content should go, if there is one.
    1:  */
    1: static nsIFrame*
    1: AdjustAppendParentForAfterContent(nsPresContext* aPresContext,
    1:                                   nsIContent* aContainer,
    1:                                   nsIFrame* aParentFrame,
    1:                                   nsIFrame** aAfterFrame)
    1: {
    1:   // See if the parent has an :after pseudo-element.  Check for the presence
    1:   // of style first, since nsLayoutUtils::GetAfterFrame is sorta expensive.
    1:   nsStyleContext* parentStyle = aParentFrame->GetStyleContext();
    1:   if (nsLayoutUtils::HasPseudoStyle(aContainer, parentStyle,
    1:                                     nsCSSPseudoElements::after,
    1:                                     aPresContext)) {
    1:     nsIFrame* afterFrame = nsLayoutUtils::GetAfterFrame(aParentFrame);
    1:     if (afterFrame) {
    1:       *aAfterFrame = afterFrame;
    1:       return afterFrame->GetParent();
    1:     }
    1:   }
    1: 
    1:   *aAfterFrame = nsnull;
    1:   return aParentFrame;
    1: }
    1: 
    1: /**
27310:  * This function will get the previous sibling to use for an append operation.
27310:  * it takes a parent frame (must not be null) and its :after frame (may be
27310:  * null).
27310:  */
27310: static nsIFrame*
27310: FindAppendPrevSibling(nsIFrame* aParentFrame, nsIFrame* aAfterFrame)
27310: {
30827:   if (aAfterFrame) {
27310:     NS_ASSERTION(aAfterFrame->GetParent() == aParentFrame, "Wrong parent");
33388:     return aAfterFrame->GetPrevSibling();
27310:   }
27310: 
30827:   return aParentFrame->GetLastChild(nsnull);
27310: }
27310: 
27310: /**
27310:  * This function will get the next sibling for a frame insert operation given
27310:  * the parent and previous sibling.  aPrevSibling may be null.
27310:  */
27310: static nsIFrame*
27310: GetInsertNextSibling(nsIFrame* aParentFrame, nsIFrame* aPrevSibling)
27310: {
27310:   if (aPrevSibling) {
27310:     return aPrevSibling->GetNextSibling();
27310:   }
27310: 
27310:   return aParentFrame->GetFirstChild(nsnull);
27310: }
27310: 
27310: /**
27310:  * This function is called by ContentAppended() and ContentInserted() when
27310:  * appending flowed frames to a parent's principal child list. It handles the
27310:  * case where the parent frame has :after pseudo-element generated content and
27310:  * the case where the parent is the block of an {ib} split.
    1:  */
    1: nsresult
 4696: nsCSSFrameConstructor::AppendFrames(nsFrameConstructorState&       aState,
    1:                                     nsIFrame*                      aParentFrame,
 4696:                                     nsFrameItems&                  aFrameList,
27310:                                     nsIFrame*                      aPrevSibling)
27310: {
27310:   NS_PRECONDITION(!IsFrameSpecial(aParentFrame) ||
27310:                   !GetSpecialSibling(aParentFrame) ||
27310:                   !GetSpecialSibling(aParentFrame)->GetFirstChild(nsnull),
27310:                   "aParentFrame has a special sibling with kids?");
27310:   NS_PRECONDITION(!aPrevSibling || aPrevSibling->GetParent() == aParentFrame,
27310:                   "Parent and prevsibling don't match");
27310: 
27310:   nsIFrame* nextSibling = ::GetInsertNextSibling(aParentFrame, aPrevSibling);
27310: 
27310:   NS_ASSERTION(nextSibling ||
27310:                !aParentFrame->GetNextContinuation() ||
27310:                !aParentFrame->GetNextContinuation()->GetFirstChild(nsnull),
27310:                "aParentFrame has later continuations with kids?");
27310: 
27310:   // If we we're inserting a list of frames that ends in inlines at the end of
27310:   // the block part of an {ib} split, we need to move them out to the beginning
27310:   // of a trailing inline part.
27310:   if (!nextSibling &&
27310:       IsFrameSpecial(aParentFrame) &&
 4696:       !IsInlineFrame(aParentFrame) &&
32843:       IsInlineOutside(aFrameList.LastChild())) {
 4696:     // We want to put some of the frames into the following inline frame.
30789:     nsFrameList::FrameLinkEnumerator lastBlock = FindLastBlock(aFrameList);
32843:     nsFrameList inlineKids = aFrameList.ExtractTail(lastBlock);
30789: 
30789:     NS_ASSERTION(inlineKids.NotEmpty(), "How did that happen?");
25738: 
25738:     nsIFrame* inlineSibling = GetSpecialSibling(aParentFrame);
25738:     NS_ASSERTION(inlineSibling, "How did that happen?");
25738: 
25738:     nsIFrame* stateParent = inlineSibling->GetParent();
25738: 
25738:     nsFrameConstructorState targetState(mPresShell, mFixedContainingBlock,
 4696:                                         GetAbsoluteContainingBlock(stateParent),
 4696:                                         GetFloatContainingBlock(stateParent));
25738: 
30789:     MoveFramesToEndOfIBSplit(aState, inlineSibling, inlineKids,
25738:                              aParentFrame, &targetState);
 4696:   }
 4696:     
30785:   if (aFrameList.IsEmpty()) {
 4696:     // It all got eaten by the special inline
 4696:     return NS_OK;
 4696:   }
 4696:   
27310:   // Insert the frames after out aPrevSibling
27310:   return aState.mFrameManager->InsertFrames(aParentFrame, nsnull, aPrevSibling,
30941:                                             aFrameList);
    1: }
    1: 
 7655: #define UNSET_DISPLAY 255
 7655: 
    1: // This gets called to see if the frames corresponding to aSiblingDisplay and aDisplay
    1: // should be siblings in the frame tree. Although (1) rows and cols, (2) row groups 
 7655: // and col groups, (3) row groups and captions, (4) legends and content inside fieldsets, (5) popups and other kids of the menu
    1: // are siblings from a content perspective, they are not considered siblings in the 
    1: // frame tree.
    1: PRBool
 7655: nsCSSFrameConstructor::IsValidSibling(nsIFrame*              aSibling,
 7655:                                       nsIContent*            aContent,
    1:                                       PRUint8&               aDisplay)
    1: {
 8009:   nsIFrame* parentFrame = aSibling->GetParent();
 8009:   nsIAtom* parentType = nsnull;
 8009:   nsIAtom* grandparentType = nsnull;
 8009:   if (parentFrame) {
 8009:     parentType = parentFrame->GetType();
 8009:     nsIFrame* grandparentFrame = parentFrame->GetParent();
 8009:     if (grandparentFrame) {
 8009:       grandparentType = grandparentFrame->GetType();
 8009:     }
 8009:   }
 8009:     
 7655:   PRUint8 siblingDisplay = aSibling->GetStyleDisplay()->mDisplay;
 7655:   if ((NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP == siblingDisplay) ||
 7655:       (NS_STYLE_DISPLAY_TABLE_COLUMN       == siblingDisplay) ||
 7655:       (NS_STYLE_DISPLAY_TABLE_CAPTION      == siblingDisplay) ||
 7655:       (NS_STYLE_DISPLAY_TABLE_HEADER_GROUP == siblingDisplay) ||
 7655:       (NS_STYLE_DISPLAY_TABLE_ROW_GROUP    == siblingDisplay) ||
 7655:       (NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP == siblingDisplay) ||
 7655:       nsGkAtoms::menuFrame == parentType) {
    1:     // if we haven't already, construct a style context to find the display type of aContent
    1:     if (UNSET_DISPLAY == aDisplay) {
    1:       nsRefPtr<nsStyleContext> styleContext;
 1502:       nsIFrame* styleParent;
 1502:       PRBool providerIsChild;
 1502:       if (NS_FAILED(aSibling->
 1502:                       GetParentStyleContextFrame(aSibling->PresContext(),
 1502:                                                  &styleParent,
 1502:                                                  &providerIsChild)) ||
 1502:           !styleParent) {
 1502:         NS_NOTREACHED("Shouldn't happen");
 1502:         return PR_FALSE;
 1502:       }
 7655:       styleContext = ResolveStyleContext(styleParent, aContent);
    1:       if (!styleContext) return PR_FALSE;
    1:       const nsStyleDisplay* display = styleContext->GetStyleDisplay();
    1:       aDisplay = display->mDisplay;
    1:     }
 7655:     if (nsGkAtoms::menuFrame == parentType) {
 7655:       return
 7655:         (NS_STYLE_DISPLAY_POPUP == aDisplay) ==
 7655:         (NS_STYLE_DISPLAY_POPUP == siblingDisplay);
 7655:     }
 7655:     switch (siblingDisplay) {
    1:     case NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP:
    1:       return (NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP == aDisplay);
    1:     case NS_STYLE_DISPLAY_TABLE_COLUMN:
    1:       return (NS_STYLE_DISPLAY_TABLE_COLUMN == aDisplay);
    1:     case NS_STYLE_DISPLAY_TABLE_CAPTION:
    1:       return (NS_STYLE_DISPLAY_TABLE_CAPTION == aDisplay);
    1:     default: // all of the row group types
    1:       return (NS_STYLE_DISPLAY_TABLE_HEADER_GROUP == aDisplay) ||
    1:              (NS_STYLE_DISPLAY_TABLE_ROW_GROUP    == aDisplay) ||
    1:              (NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP == aDisplay) ||
    1:              (NS_STYLE_DISPLAY_TABLE_CAPTION      == aDisplay);
    1:     }
    1:   }
 8009:   else if (nsGkAtoms::fieldSetFrame == parentType ||
 8009:            (nsGkAtoms::fieldSetFrame == grandparentType &&
23176:             nsGkAtoms::blockFrame == parentType)) {
    1:     // Legends can be sibling of legends but not of other content in the fieldset
 1502:     nsIAtom* sibType = aSibling->GetType();
 7655:     nsCOMPtr<nsIDOMHTMLLegendElement> legendContent(do_QueryInterface(aContent));
    1: 
    1:     if ((legendContent  && (nsGkAtoms::legendFrame != sibType)) ||
    1:         (!legendContent && (nsGkAtoms::legendFrame == sibType)))
    1:       return PR_FALSE;
    1:   }
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
 7655: nsIFrame*
 7655: nsCSSFrameConstructor::FindFrameForContentSibling(nsIContent* aContent,
 7655:                                                   nsIContent* aTargetContent,
 7655:                                                   PRUint8& aTargetContentDisplay,
 7655:                                                   PRBool aPrevSibling)
 7655: {
 7655:   nsIFrame* sibling = mPresShell->GetPrimaryFrameFor(aContent);
34147:   if (!sibling || sibling->GetContent() != aContent) {
34147:     // XXX the GetContent() != aContent check is needed due to bug 135040.
34147:     // Remove it once that's fixed.
 7655:     return nsnull;
 7655:   }
 7655: 
 7655:   // If the frame is out-of-flow, GPFF() will have returned the
 7655:   // out-of-flow frame; we want the placeholder.
 7655:   if (sibling->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
 7655:     nsIFrame* placeholderFrame;
 7655:     mPresShell->GetPlaceholderFrameFor(sibling, &placeholderFrame);
 7655:     NS_ASSERTION(placeholderFrame, "no placeholder for out-of-flow frame");
 7655:     sibling = placeholderFrame;
 7655:   }
 7655: 
 8406:   // The frame we have now should never be a continuation
 8406:   NS_ASSERTION(!sibling->GetPrevContinuation(), "How did that happen?");
 7655: 
 7655:   if (aPrevSibling) {
 7655:     // The frame may be a special frame (a split inline frame that
 7655:     // contains a block).  Get the last part of that split.
 7655:     if (IsFrameSpecial(sibling)) {
25738:       sibling = GetLastSpecialSibling(sibling, PR_FALSE);
 7655:     }
 7655: 
 7655:     // The frame may have a continuation. If so, we want the last
 7655:     // non-overflow-container continuation as our previous sibling.
10780:     sibling = sibling->GetTailContinuation();
 7655:   }
 7655: 
 7655:   if (aTargetContent &&
 7655:       !IsValidSibling(sibling, aTargetContent, aTargetContentDisplay)) {
 7655:     sibling = nsnull;
 7655:   }
 7655: 
 7655:   return sibling;
 7655: }
 7655: 
    1: nsIFrame*
24404: nsCSSFrameConstructor::FindPreviousSibling(const ChildIterator& aFirst,
24404:                                            ChildIterator aIter)
24404: {
24404:   nsIContent* child = *aIter;
    1: 
    1:   PRUint8 childDisplay = UNSET_DISPLAY;
    1:   // Note: not all content objects are associated with a frame (e.g., if it's
 7655:   // `display: none') so keep looking until we find a previous frame
24404:   while (aIter-- != aFirst) {
 7655:     nsIFrame* prevSibling =
24404:       FindFrameForContentSibling(*aIter, child, childDisplay, PR_TRUE);
    1: 
    1:     if (prevSibling) {
    1:       // Found a previous sibling, we're done!
    1:       return prevSibling;
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: nsIFrame*
24404: nsCSSFrameConstructor::FindNextSibling(ChildIterator aIter,
24404:                                        const ChildIterator& aLast)
24404: {
24404:   if (aIter == aLast) {
24404:     // XXXbz Can happen when XBL lies to us about insertion points.  This check
24404:     // might be able to go away once bug 474324 is fixed.
    1:     return nsnull;
24404:   }
24404: 
24404:   nsIContent* child = *aIter;
    1:   PRUint8 childDisplay = UNSET_DISPLAY;
    1: 
24404:   while (++aIter != aLast) {
    1:     nsIFrame* nextSibling =
24404:       FindFrameForContentSibling(*aIter, child, childDisplay, PR_FALSE);
    1: 
    1:     if (nextSibling) {
    1:       // We found a next sibling, we're done!
    1:       return nextSibling;
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: // For fieldsets, returns the area frame, if the child is not a legend. 
    1: static nsIFrame*
    1: GetAdjustedParentFrame(nsIFrame*       aParentFrame,
    1:                        nsIAtom*        aParentFrameType,
24404:                        nsIContent*     aChildContent)
    1: {
 4194:   NS_PRECONDITION(nsGkAtoms::tableOuterFrame != aParentFrameType,
 4194:                   "Shouldn't be happening!");
 4194:   
    1:   nsIFrame* newParent = nsnull;
    1: 
 4194:   if (nsGkAtoms::fieldSetFrame == aParentFrameType) {
    1:     // If the parent is a fieldSet, use the fieldSet's area frame as the
    1:     // parent unless the new content is a legend. 
24404:     nsCOMPtr<nsIDOMHTMLLegendElement> legendContent(do_QueryInterface(aChildContent));
    1:     if (!legendContent) {
23176:       newParent = GetFieldSetBlockFrame(aParentFrame);
    1:     }
    1:   }
    1:   return (newParent) ? newParent : aParentFrame;
    1: }
    1: 
27696: nsIFrame*
27696: nsCSSFrameConstructor::GetInsertionPrevSibling(nsIFrame*& aParentFrame,
27696:                                                nsIContent* aContainer,
27696:                                                nsIContent* aChild,
27696:                                                PRInt32 aIndexInContainer,
27696:                                                PRBool* aIsAppend)
27696: {
27696:   *aIsAppend = PR_FALSE;
27696: 
27696:   // Find the frame that precedes the insertion point. Walk backwards
27696:   // from the parent frame to get the parent content, because if an
27696:   // XBL insertion point is involved, we'll need to use _that_ to find
27696:   // the preceding frame.
27696: 
27696:   NS_PRECONDITION(aParentFrame, "Must have parent frame to start with");
27696:   nsIContent* container = aParentFrame->GetContent();
27696: 
27696:   ChildIterator first, last;
27696:   ChildIterator::Init(container, &first, &last);
27696:   ChildIterator iter(first);
27696:   if (iter.XBLInvolved() || container != aContainer) {
27696:     iter.seek(aChild);
27696:     // Don't touch our aIndexInContainer, though it's almost certainly bogus in
27696:     // this case.  If someone wants to use an index below, they should make
27696:     // sure to use the right index (aIndexInContainer vs iter.position()) with
27696:     // the right parent node.
27696:   } else if (aIndexInContainer != -1) {
27696:     // Do things the fast way if we can.  The check for -1 is because editor is
27696:     // severely broken and calls us directly for native anonymous nodes that it
27696:     // creates.
27696:     iter.seek(aIndexInContainer);
27696:     NS_ASSERTION(*iter == aChild, "Someone screwed up the indexing");
27696:   }
27696: #ifdef DEBUG
27696:   else {
27696:     NS_WARNING("Someone passed native anonymous content directly into frame "
27696:                "construction.  Stop doing that!");
27696:   }
27696: #endif
27696: 
27696:   nsIFrame* prevSibling = FindPreviousSibling(first, iter);
27696: 
27696:   // Now, find the geometric parent so that we can handle
27696:   // continuations properly. Use the prev sibling if we have it;
27696:   // otherwise use the next sibling.
27696:   if (prevSibling) {
27696:     aParentFrame = prevSibling->GetParent()->GetContentInsertionFrame();
27696:   }
27696:   else {
27696:     // If there is no previous sibling, then find the frame that follows
27696:     nsIFrame* nextSibling = FindNextSibling(iter, last);
27696: 
27696:     if (nextSibling) {
27696:       aParentFrame = nextSibling->GetParent()->GetContentInsertionFrame();
27696:     }
27696:     else {
27696:       // No previous or next sibling, so treat this like an appended frame.
27696:       *aIsAppend = PR_TRUE;
27696:       if (IsFrameSpecial(aParentFrame)) {
27696:         // Since we're appending, we'll walk to the last anonymous frame
27696:         // that was created for the broken inline frame.  But don't walk
27696:         // to the trailing inline if it's empty; stop at the block.
27696:         aParentFrame = GetLastSpecialSibling(aParentFrame, PR_TRUE);
27696:       }
27696:       // Get continuation that parents the last child.  This MUST be done
27696:       // before the AdjustAppendParentForAfterContent call.
27696:       aParentFrame = nsLayoutUtils::GetLastContinuationWithChild(aParentFrame);
27696:       // Deal with fieldsets
27696:       aParentFrame = ::GetAdjustedParentFrame(aParentFrame,
27696:                                               aParentFrame->GetType(),
27696:                                               aChild);
27696:       nsIFrame* appendAfterFrame;
27696:       aParentFrame =
27696:         ::AdjustAppendParentForAfterContent(mPresShell->GetPresContext(),
27696:                                             container, aParentFrame,
27696:                                             &appendAfterFrame);
27696:       prevSibling = ::FindAppendPrevSibling(aParentFrame, appendAfterFrame);
27696:     }
27696:   }
27696: 
27696:   return prevSibling;
27696: }
27696: 
    1: static PRBool
    1: IsSpecialFramesetChild(nsIContent* aContent)
    1: {
    1:   // IMPORTANT: This must match the conditions in nsHTMLFramesetFrame::Init.
33329:   return aContent->IsHTML() &&
    1:     (aContent->Tag() == nsGkAtoms::frameset ||
    1:      aContent->Tag() == nsGkAtoms::frame);
    1: }
    1: 
28215: static void
28215: InvalidateCanvasIfNeeded(nsIPresShell* presShell, nsIContent* node);
28215: 
28865: #ifdef MOZ_XUL
28865: 
28865: static
28865: nsListBoxBodyFrame*
28865: MaybeGetListBoxBodyFrame(nsIContent* aContainer, nsIContent* aChild)
28865: {
28865:   if (!aContainer)
28865:     return nsnull;
28865: 
33329:   if (aContainer->IsXUL() &&
33329:       aChild->IsXUL() &&
28865:       aContainer->Tag() == nsGkAtoms::listbox &&
28865:       aChild->Tag() == nsGkAtoms::listitem) {
28865:     nsCOMPtr<nsIDOMXULElement> xulElement = do_QueryInterface(aContainer);
28865:     nsCOMPtr<nsIBoxObject> boxObject;
28865:     xulElement->GetBoxObject(getter_AddRefs(boxObject));
28865:     nsCOMPtr<nsPIListBoxObject> listBoxObject = do_QueryInterface(boxObject);
28865:     if (listBoxObject) {
28865:       return listBoxObject->GetListBoxBody(PR_FALSE);
28865:     }
28865:   }
28865: 
28865:   return nsnull;
28865: }
28865: #endif
28865: 
29501: void
29525: nsCSSFrameConstructor::AddTextItemIfNeeded(nsFrameConstructorState& aState,
29525:                                            nsIFrame* aParentFrame,
29501:                                            nsIContent* aParentContent,
29501:                                            PRInt32 aContentIndex,
29501:                                            FrameConstructionItemList& aItems)
29501: {
29501:   NS_ASSERTION(aContentIndex >= 0 &&
30789:                PRUint32(aContentIndex) < aParentContent->GetChildCount(),
29501:                "child index out of range");
29501:   nsIContent* content = aParentContent->GetChildAt(aContentIndex);
29501:   if (!content->IsNodeOfType(nsINode::eTEXT) ||
29809:       !content->HasFlag(NS_CREATE_FRAME_IF_NON_WHITESPACE)) {
29501:     // Not text, or not suppressed due to being all-whitespace (if it
29809:     // were being suppressed, it would have the
29809:     // NS_CREATE_FRAME_IF_NON_WHITESPACE flag)
29501:     return;
29501:   }
29809:   NS_ASSERTION(!mPresShell->GetPrimaryFrameFor(content),
29809:                "Text node has a frame and NS_CREATE_FRAME_IF_NON_WHITESPACE");
29525:   AddFrameConstructionItems(aState, content, aContentIndex, aParentFrame, aItems);
29501: }
29501: 
29501: void
29501: nsCSSFrameConstructor::ReframeTextIfNeeded(nsIContent* aParentContent,
29501:                                            PRInt32 aContentIndex)
29501: {
29501:   NS_ASSERTION(aContentIndex >= 0 &&
30789:                PRUint32(aContentIndex) < aParentContent->GetChildCount(),
29501:                "child index out of range");
29501:   nsIContent* content = aParentContent->GetChildAt(aContentIndex);
29501:   if (!content->IsNodeOfType(nsINode::eTEXT) ||
29809:       !content->HasFlag(NS_CREATE_FRAME_IF_NON_WHITESPACE)) {
29501:     // Not text, or not suppressed due to being all-whitespace (if it
29809:     // were being suppressed, it would have the
29809:     // NS_CREATE_FRAME_IF_NON_WHITESPACE flag)
29501:     return;
29501:   }
29809:   NS_ASSERTION(!mPresShell->GetPrimaryFrameFor(content),
29809:                "Text node has a frame and NS_CREATE_FRAME_IF_NON_WHITESPACE");
29501:   ContentInserted(aParentContent, content, aContentIndex, nsnull);
29501: }
29501: 
    1: nsresult
    1: nsCSSFrameConstructor::ContentAppended(nsIContent*     aContainer,
    1:                                        PRInt32         aNewIndexInContainer)
    1: {
    1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
 6518:   NS_PRECONDITION(mUpdateCount != 0,
 6518:                   "Should be in an update while creating frames");
 6518: 
    1: #ifdef DEBUG
    1:   if (gNoisyContentUpdates) {
    1:     printf("nsCSSFrameConstructor::ContentAppended container=%p index=%d\n",
 3233:            static_cast<void*>(aContainer), aNewIndexInContainer);
    1:     if (gReallyNoisyContentUpdates && aContainer) {
    1:       aContainer->List(stdout, 0);
    1:     }
    1:   }
    1: #endif
    1: 
    1: #ifdef MOZ_XUL
    1:   if (aContainer) {
    1:     PRInt32 namespaceID;
    1:     nsIAtom* tag =
    1:       mDocument->BindingManager()->ResolveTag(aContainer, &namespaceID);
    1: 
    1:     // Just ignore tree tags, anyway we don't create any frames for them.
    1:     if (tag == nsGkAtoms::treechildren ||
    1:         tag == nsGkAtoms::treeitem ||
23941:         tag == nsGkAtoms::treerow)
    1:       return NS_OK;
    1: 
    1:   }
    1: #endif // MOZ_XUL
    1: 
    1:   // Get the frame associated with the content
    1:   nsIFrame* parentFrame = GetFrameFor(aContainer);
    1:   if (! parentFrame)
    1:     return NS_OK;
    1: 
    1:   // See if we have an XBL insertion point. If so, then that's our
    1:   // real parent frame; if not, then the frame hasn't been built yet
    1:   // and we just bail.
    1:   //
    1:   nsIFrame* insertionPoint;
    1:   PRBool multiple = PR_FALSE;
    1:   GetInsertionPoint(parentFrame, nsnull, &insertionPoint, &multiple);
    1:   if (! insertionPoint)
    1:     return NS_OK; // Don't build the frames.
    1: 
    1:   PRBool hasInsertion = PR_FALSE;
    1:   if (!multiple) {
    1:     nsIDocument* document = nsnull; 
    1:     nsIContent *firstAppendedChild =
    1:       aContainer->GetChildAt(aNewIndexInContainer);
    1:     if (firstAppendedChild) {
    1:       document = firstAppendedChild->GetDocument();
    1:     }
    1:     if (document &&
    1:         document->BindingManager()->GetInsertionParent(firstAppendedChild)) {
    1:       hasInsertion = PR_TRUE;
    1:     }
    1:   }
    1:   
    1:   if (multiple || hasInsertion) {
    1:     // We have an insertion point.  There are some additional tests we need to do
    1:     // in order to ensure that an append is a safe operation.
    1:     PRUint32 childCount = 0;
    1:       
    1:     if (!multiple) {
    1:       // We may need to make multiple ContentInserted calls instead.  A
    1:       // reasonable heuristic to employ (in order to maintain good performance)
    1:       // is to find out if the insertion point's content node contains any
    1:       // explicit children.  If it does not, then it is highly likely that 
    1:       // an append is occurring.  (Note it is not definite, and there are insane
    1:       // cases we will not deal with by employing this heuristic, but it beats
    1:       // always falling back to multiple ContentInserted calls).
    1:       //
    1:       // In the multiple insertion point case, we know we're going to need to do
    1:       // multiple ContentInserted calls anyway.
    1:       childCount = insertionPoint->GetContent()->GetChildCount();
    1:     }
    1: 
    1:     if (multiple || childCount > 0) {
24404:       // Now comes the fun part.  For each appended child, make a
24404:       // ContentInserted call as if it had just gotten inserted at the index
24404:       // it's at in aContainer and let ContentInserted handle the mess.  If our
24404:       // insertion point is non-XBL that's the correct index, and otherwise
24404:       // ContentInserted will ignore the passed-in index.
    1:       PRUint32 containerCount = aContainer->GetChildCount();
    1:       for (PRUint32 i = aNewIndexInContainer; i < containerCount; i++) {
26747:         nsIContent* content = aContainer->GetChildAt(i);
31407:         if ((mPresShell->GetPrimaryFrameFor(content) ||
31407:              mPresShell->FrameManager()->GetUndisplayedContent(content))
28865: #ifdef MOZ_XUL
28865:             //  Except listboxes suck, so do NOT skip anything here if
28865:             //  we plan to notify a listbox.
28865:             && !MaybeGetListBoxBodyFrame(aContainer, content)
28865: #endif
28865:             ) {
31407:           // Already have a frame or undisplayed entry for this content; a
31407:           // previous ContentInserted in this loop must have reconstructed
31407:           // its insertion parent.  Skip it.
26747:           continue;
26747:         }
    1:         LAYOUT_PHASE_TEMP_EXIT();
    1:         // Call ContentInserted with this index.
26784:         ContentInserted(aContainer, content, i, mTempFrameTreeState);
    1:         LAYOUT_PHASE_TEMP_REENTER();
    1:       }
    1: 
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   parentFrame = insertionPoint;
    1: 
    1:   if (parentFrame->GetType() == nsGkAtoms::frameSetFrame) {
    1:     // Check whether we have any kids we care about.
    1:     PRUint32 count = aContainer->GetChildCount();
    1:     for (PRUint32 i = aNewIndexInContainer; i < count; ++i) {
    1:       if (IsSpecialFramesetChild(aContainer->GetChildAt(i))) {
    1:         // Just reframe the parent, since framesets are weird like that.
30749:         LAYOUT_PHASE_TEMP_EXIT();
31031:         nsresult rv = RecreateFramesForContent(parentFrame->GetContent(), PR_FALSE);
30749:         LAYOUT_PHASE_TEMP_REENTER();
30749:         return rv;
    1:       }
    1:     }
    1:   }
    1:   
    1:   if (parentFrame->IsLeaf()) {
    1:     // Nothing to do here; we shouldn't be constructing kids of leaves
    1:     return NS_OK;
    1:   }
    1:   
 6862: #ifdef MOZ_MATHML
30749:   if (parentFrame->IsFrameOfType(nsIFrame::eMathML)) {
30749:     LAYOUT_PHASE_TEMP_EXIT();
31031:     nsresult rv = RecreateFramesForContent(parentFrame->GetContent(), PR_FALSE);
30749:     LAYOUT_PHASE_TEMP_REENTER();
30749:     return rv;
30749:   }
 6862: #endif
 6862: 
 4696:   // If the frame we are manipulating is a ``special'' frame (that is, one
 4696:   // that's been created as a result of a block-in-inline situation) then we
 4696:   // need to append to the last special sibling, not to the frame itself.
29501:   PRBool parentSpecial = IsFrameSpecial(parentFrame);
29501:   if (parentSpecial) {
    1: #ifdef DEBUG
    1:     if (gNoisyContentUpdates) {
    1:       printf("nsCSSFrameConstructor::ContentAppended: parentFrame=");
    1:       nsFrame::ListTag(stdout, parentFrame);
    1:       printf(" is special\n");
    1:     }
    1: #endif
    1: 
    1:     // Since we're appending, we'll walk to the last anonymous frame
25738:     // that was created for the broken inline frame.  But don't walk
27309:     // to the trailing inline if it's empty; stop at the block.
25738:     parentFrame = GetLastSpecialSibling(parentFrame, PR_TRUE);
    1:   }
    1: 
27310:   // Get continuation that parents the last child.  This MUST be done
27310:   // before the AdjustAppendParentForAfterContent call.
10780:   parentFrame = nsLayoutUtils::GetLastContinuationWithChild(parentFrame);
    1: 
24404:   // We should never get here with fieldsets, since they have multiple
24404:   // insertion points.
29501:   NS_ASSERTION(parentFrame->GetType() != nsGkAtoms::fieldSetFrame,
24404:                "Unexpected parent");
    1: 
    1:   // Deal with possible :after generated content on the parent
    1:   nsIFrame* parentAfterFrame;
    1:   parentFrame =
    1:     ::AdjustAppendParentForAfterContent(mPresShell->GetPresContext(),
    1:                                         aContainer, parentFrame,
    1:                                         &parentAfterFrame);
    1:   
    1:   // Create some new frames
    1:   nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
    1:                                 GetAbsoluteContainingBlock(parentFrame),
    1:                                 GetFloatContainingBlock(parentFrame));
    1: 
    1:   // See if the containing block has :first-letter style applied.
    1:   PRBool haveFirstLetterStyle = PR_FALSE, haveFirstLineStyle = PR_FALSE;
    1:   nsIFrame* containingBlock = state.mFloatedItems.containingBlock;
    1:   if (containingBlock) {
 1254:     haveFirstLetterStyle = HasFirstLetterStyle(containingBlock);
 1243:     haveFirstLineStyle =
 1254:       ShouldHaveFirstLineStyle(containingBlock->GetContent(),
 1243:                                containingBlock->GetStyleContext());
    1:   }
    1: 
    1:   if (haveFirstLetterStyle) {
    1:     // Before we get going, remove the current letter frames
    1:     RemoveLetterFrames(state.mPresContext, state.mPresShell,
    1:                        state.mFrameManager, containingBlock);
    1:   }
    1: 
29501:   nsIAtom* frameType = parentFrame->GetType();
29501: 
25774:   FrameConstructionItemList items;
29838:   if (aNewIndexInContainer > 0 && GetParentType(frameType) == eTypeBlock) {
29838:     // If there's a text node in the normal content list just before the new
29838:     // items, and it has no frame, make a frame construction item for it. If it
29838:     // doesn't need a frame, ConstructFramesFromItemList below won't give it
29838:     // one.  No need to do all this if our parent type is not block, though,
29838:     // since WipeContainingBlock already handles that situation.
29838:     //
29501:     // Because we're appending, we don't need to worry about any text
29501:     // after the appended content; there can only be XBL anonymous content
29501:     // (text in an XBL binding is not suppressed) or generated content
29501:     // (and bare text nodes are not generated). Native anonymous content
29501:     // generated by frames never participates in inline layout.
29525:     AddTextItemIfNeeded(state, parentFrame, aContainer,
29501:                         aNewIndexInContainer - 1, items);
29501:   }
25773:   for (PRUint32 i = aNewIndexInContainer, count = aContainer->GetChildCount();
25773:        i < count;
25773:        ++i) {
29501:     AddFrameConstructionItems(state, aContainer->GetChildAt(i), i, parentFrame,
25773:                               items);
25773:   }
25773: 
27310:   nsIFrame* prevSibling = ::FindAppendPrevSibling(parentFrame, parentAfterFrame);
27310: 
25773:   // Perform special check for diddling around with the frames in
25773:   // a special inline frame.
25773:   // If we're appending before :after content, then we're not really
25773:   // appending, so let WipeContainingBlock know that.
26720:   LAYOUT_PHASE_TEMP_EXIT();
25773:   if (WipeContainingBlock(state, containingBlock, parentFrame, items,
27310:                           PR_TRUE, prevSibling)) {
26720:     LAYOUT_PHASE_TEMP_REENTER();
25773:     return NS_OK;
25773:   }
26720:   LAYOUT_PHASE_TEMP_REENTER();
25773: 
29501:   // If the parent is a block frame, and we're not in a special case
29501:   // where frames can be moved around, determine if the list is for the
29501:   // start or end of the block.
29501:   if (nsLayoutUtils::GetAsBlock(parentFrame) && !haveFirstLetterStyle &&
29501:       !haveFirstLineStyle && !parentSpecial) {
29501:     items.SetLineBoundaryAtStart(!prevSibling ||
29501:         !prevSibling->GetStyleDisplay()->IsInlineOutside() ||
29501:         prevSibling->GetType() == nsGkAtoms::brFrame);
29501:     // :after content can't be <br> so no need to check it
29501:     items.SetLineBoundaryAtEnd(!parentAfterFrame ||
29501:         !parentAfterFrame->GetStyleDisplay()->IsInlineOutside());
29501:   }
29501:   // To suppress whitespace-only text frames, we have to verify that
29501:   // our container's DOM child list matches its flattened tree child list.
29501:   // This is guaranteed to be true if GetXBLChildNodesFor() returns null.
29501:   items.SetParentHasNoXBLChildren(
29501:       !mDocument->BindingManager()->GetXBLChildNodesFor(aContainer));
29501: 
25773:   nsFrameItems frameItems;
26216:   ConstructFramesFromItemList(state, items, parentFrame, frameItems);
26216: 
26216:   for (PRUint32 i = aNewIndexInContainer, count = aContainer->GetChildCount();
26216:        i < count;
26216:        ++i) {
26216:     // Invalidate now instead of before the WipeContainingBlock call, just in
26216:     // case we do wipe; in that case we don't need to do this walk at all.
26216:     // XXXbz does that matter?  Would it make more sense to save some virtual
26216:     // GetChildAt calls instead and do this during construction of our
26216:     // FrameConstructionItemList?
26216:     InvalidateCanvasIfNeeded(mPresShell, aContainer->GetChildAt(i));
26216:   }
26216: 
26216:   // if the container is a table and a caption was appended, it needs to be put
26216:   // in the outer table frame's additional child list.
    1:   nsFrameItems captionItems;
 4368:   if (nsGkAtoms::tableFrame == frameType) {
 4368:     // Pull out the captions.  Note that we don't want to do that as we go,
 4368:     // because processing a single caption can add a whole bunch of things to
 4368:     // the frame items due to pseudoframe processing.  So we'd have to pull
 4368:     // captions from a list anyway; might as well do that here.
26208:     // XXXbz this is no longer true; we could pull captions directly out of the
26208:     // FrameConstructionItemList now.
 4368:     PullOutCaptionFrames(frameItems, captionItems);
 4368:   }
 4368:   
    1:   if (haveFirstLineStyle && parentFrame == containingBlock) {
    1:     // It's possible that some of the new frames go into a
    1:     // first-line frame. Look at them and see...
    1:     AppendFirstLineFrames(state, containingBlock->GetContent(),
    1:                           containingBlock, frameItems); 
    1:   }
    1: 
    1:   nsresult result = NS_OK;
    1: 
    1:   // Notify the parent frame passing it the list of new frames
27310:   if (NS_SUCCEEDED(result)) {
27310:     // Append the flowed frames to the principal child list; captions
27310:     // need special treatment
30785:     if (captionItems.NotEmpty()) { // append the caption to the outer table
27310:       NS_ASSERTION(nsGkAtoms::tableFrame == frameType, "how did that happen?");
    1:       nsIFrame* outerTable = parentFrame->GetParent();
    1:       if (outerTable) {
30941:         state.mFrameManager->AppendFrames(outerTable, nsGkAtoms::captionList,
30941:                                           captionItems);
30785:       }
30785:     }
30785: 
30785:     if (frameItems.NotEmpty()) { // append the in-flow kids
27310:       AppendFrames(state, parentFrame, frameItems, prevSibling);
    1:     }
    1:   }
    1: 
    1:   // Recover first-letter frames
    1:   if (haveFirstLetterStyle) {
23461:     RecoverLetterFrames(containingBlock);
    1:   }
    1: 
    1: #ifdef DEBUG
    1:   if (gReallyNoisyContentUpdates) {
    1:     printf("nsCSSFrameConstructor::ContentAppended: resulting frame model:\n");
31709:     parentFrame->List(stdout, 0);
    1:   }
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: #ifdef MOZ_XUL
    1: 
    1: enum content_operation
    1: {
    1:     CONTENT_INSERTED,
    1:     CONTENT_REMOVED
    1: };
    1: 
    1: // Helper function to lookup the listbox body frame and send a notification
    1: // for insertion or removal of content
    1: static
    1: PRBool NotifyListBoxBody(nsPresContext*    aPresContext,
    1:                          nsIContent*        aContainer,
    1:                          nsIContent*        aChild,
    1:                          PRInt32            aIndexInContainer,
    1:                          nsIDocument*       aDocument,                         
    1:                          nsIFrame*          aChildFrame,
    1:                          content_operation  aOperation)
    1: {
28865:   nsListBoxBodyFrame* listBoxBodyFrame =
28865:     MaybeGetListBoxBodyFrame(aContainer, aChild);
20990:   if (listBoxBodyFrame) {
    1:     if (aOperation == CONTENT_REMOVED) {
    1:       // Except if we have an aChildFrame and its parent is not the right
    1:       // thing, then we don't do this.  Pseudo frames are so much fun....
    1:       if (!aChildFrame || aChildFrame->GetParent() == listBoxBodyFrame) {
31436:         listBoxBodyFrame->OnContentRemoved(aPresContext, aContainer,
31436:                                            aChildFrame, aIndexInContainer);
    1:         return PR_TRUE;
    1:       }
    1:     } else {
24404:       // If this codepath ever starts using aIndexInContainer, need to
24404:       // change ContentInserted to pass in something resembling a correct
24404:       // one in the XBL cases.
    1:       listBoxBodyFrame->OnContentInserted(aPresContext, aChild);
    1:       return PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: #endif // MOZ_XUL
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ContentInserted(nsIContent*            aContainer,
    1:                                        nsIContent*            aChild,
    1:                                        PRInt32                aIndexInContainer,
 4696:                                        nsILayoutHistoryState* aFrameState)
    1: {
    1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
 6518:   NS_PRECONDITION(mUpdateCount != 0,
 6518:                   "Should be in an update while creating frames");
 6518: 
    1:   // XXXldb Do we need to re-resolve style to handle the CSS2 + combinator and
    1:   // the :empty pseudo-class?
    1: #ifdef DEBUG
    1:   if (gNoisyContentUpdates) {
    1:     printf("nsCSSFrameConstructor::ContentInserted container=%p child=%p index=%d\n",
 3233:            static_cast<void*>(aContainer),
 3233:            static_cast<void*>(aChild),
    1:            aIndexInContainer);
    1:     if (gReallyNoisyContentUpdates) {
    1:       (aContainer ? aContainer : aChild)->List(stdout, 0);
    1:     }
    1:   }
    1: #endif
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1: #ifdef MOZ_XUL
24404:   // aIndexInContainer might be bogus here, but it's not used by
24404:   // NotifyListBoxBody's CONTENT_INSERTED handling in any case.
    1:   if (NotifyListBoxBody(mPresShell->GetPresContext(), aContainer, aChild,
    1:                         aIndexInContainer, 
23941:                         mDocument, nsnull, CONTENT_INSERTED))
    1:     return NS_OK;
    1: #endif // MOZ_XUL
    1:   
28215:   // If we have a null parent, then this must be the document element being
28215:   // inserted, or some other child of the document in the DOM (might be a PI,
28215:   // say).
    1:   if (! aContainer) {
    1:     nsIContent *docElement = mDocument->GetRootContent();
    1: 
28215:     if (aChild != docElement) {
28215:       // Not the root element; just bail out
28215:       return NS_OK;
28215:     }
28215: 
28215:     NS_PRECONDITION(nsnull == mRootElementFrame,
28215:                     "root element frame already created");
    1: 
    1:     // Create frames for the document element and its child elements
    1:     nsIFrame*               docElementFrame;
28215:     rv = ConstructDocElementFrame(docElement, aFrameState, &docElementFrame);
    1: 
 3026:     if (NS_SUCCEEDED(rv) && docElementFrame) {
26216:       InvalidateCanvasIfNeeded(mPresShell, aChild);
    1: #ifdef DEBUG
 3026:       if (gReallyNoisyContentUpdates) {
28215:         printf("nsCSSFrameConstructor::ContentInserted: resulting frame "
28215:                "model:\n");
31709:         mFixedContainingBlock->List(stdout, 0);
    1:       }
    1: #endif
    1:     }
28215: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Otherwise, we've got parent content. Find its frame.
    1:   nsIFrame* parentFrame = GetFrameFor(aContainer);
    1:   if (! parentFrame)
28215:     return NS_OK;
    1: 
    1:   // See if we have an XBL insertion point. If so, then that's our
    1:   // real parent frame; if not, then the frame hasn't been built yet
    1:   // and we just bail.
    1:   nsIFrame* insertionPoint;
    1:   GetInsertionPoint(parentFrame, aChild, &insertionPoint);
    1:   if (! insertionPoint)
    1:     return NS_OK; // Don't build the frames.
    1: 
    1:   parentFrame = insertionPoint;
    1: 
27696:   PRBool isAppend;
27696:   nsIFrame* prevSibling =
27696:     GetInsertionPrevSibling(parentFrame, aContainer, aChild, aIndexInContainer,
27696:                             &isAppend);
27696: 
    1:   nsIContent* container = parentFrame->GetContent();
    1: 
29110:   nsIAtom* frameType = parentFrame->GetType();
29110:   if (frameType == nsGkAtoms::frameSetFrame &&
    1:       IsSpecialFramesetChild(aChild)) {
    1:     // Just reframe the parent, since framesets are weird like that.
30749:     LAYOUT_PHASE_TEMP_EXIT();
31031:     nsresult rv = RecreateFramesForContent(parentFrame->GetContent(), PR_FALSE);
30749:     LAYOUT_PHASE_TEMP_REENTER();
30749:     return rv;
    1:   }
    1: 
29110:   if (frameType == nsGkAtoms::fieldSetFrame &&
29110:       aChild->Tag() == nsGkAtoms::legend) {
29110:     // Just reframe the parent, since figuring out whether this
29110:     // should be the new legend and then handling it is too complex.
29110:     // We could do a little better here --- check if the fieldset already
29110:     // has a legend which occurs earlier in its child list than this node,
29110:     // and if so, proceed. But we'd have to extend nsFieldSetFrame
29110:     // to locate this legend in the inserted frames and extract it.
30749:     LAYOUT_PHASE_TEMP_EXIT();
31031:     nsresult rv = RecreateFramesForContent(parentFrame->GetContent(), PR_FALSE);
30749:     LAYOUT_PHASE_TEMP_REENTER();
30749:     return rv;
29110:   }
29110: 
    1:   // Don't construct kids of leaves
    1:   if (parentFrame->IsLeaf()) {
    1:     return NS_OK;
    1:   }
    1: 
 6862: #ifdef MOZ_MATHML
30749:   if (parentFrame->IsFrameOfType(nsIFrame::eMathML)) {
30749:     LAYOUT_PHASE_TEMP_EXIT();
31031:     nsresult rv = RecreateFramesForContent(parentFrame->GetContent(), PR_FALSE);
30749:     LAYOUT_PHASE_TEMP_REENTER();
30749:     return rv;
30749:   }
 6862: #endif
 6862: 
    1:   nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
    1:                                 GetAbsoluteContainingBlock(parentFrame),
    1:                                 GetFloatContainingBlock(parentFrame),
    1:                                 aFrameState);
    1: 
    1: 
    1:   // Recover state for the containing block - we need to know if
    1:   // it has :first-letter or :first-line style applied to it. The
    1:   // reason we care is that the internal structure in these cases
    1:   // is not the normal structure and requires custom updating
    1:   // logic.
    1:   nsIFrame* containingBlock = state.mFloatedItems.containingBlock;
    1:   PRBool haveFirstLetterStyle = PR_FALSE;
    1:   PRBool haveFirstLineStyle = PR_FALSE;
    1: 
    1:   // In order to shave off some cycles, we only dig up the
    1:   // containing block haveFirst* flags if the parent frame where
    1:   // the insertion/append is occurring is an inline or block
    1:   // container. For other types of containers this isn't relevant.
    1:   const nsStyleDisplay* parentDisplay = parentFrame->GetStyleDisplay();
    1: 
    1:   // Examine the parentFrame where the insertion is taking
    1:   // place. If it's a certain kind of container then some special
    1:   // processing is done.
    1:   if ((NS_STYLE_DISPLAY_BLOCK == parentDisplay->mDisplay) ||
    1:       (NS_STYLE_DISPLAY_LIST_ITEM == parentDisplay->mDisplay) ||
    1:       (NS_STYLE_DISPLAY_INLINE == parentDisplay->mDisplay) ||
    1:       (NS_STYLE_DISPLAY_INLINE_BLOCK == parentDisplay->mDisplay)) {
    1:     // Recover the special style flags for the containing block
    1:     if (containingBlock) {
 1254:       haveFirstLetterStyle = HasFirstLetterStyle(containingBlock);
 1243:       haveFirstLineStyle =
 1254:         ShouldHaveFirstLineStyle(containingBlock->GetContent(),
 1243:                                  containingBlock->GetStyleContext());
    1:     }
    1: 
    1:     if (haveFirstLetterStyle) {
27696:       // If our current parentFrame is a Letter frame, use its parent as our
27696:       // new parent hint
    1:       if (parentFrame->GetType() == nsGkAtoms::letterFrame) {
34148:         // If parentFrame is out of flow, then we actually want the parent of
34148:         // the placeholder frame.
34148:         if (parentFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
34148:           nsPlaceholderFrame* placeholderFrame =
34148:             state.mFrameManager->GetPlaceholderFrameFor(parentFrame);
34148:           NS_ASSERTION(placeholderFrame, "No placeholder for out-of-flow?");
34148:           parentFrame = placeholderFrame->GetParent();
34148:         } else {
    1:           parentFrame = parentFrame->GetParent();
    1:         }
34148:       }
    1: 
    1:       // Remove the old letter frames before doing the insertion
    1:       RemoveLetterFrames(state.mPresContext, mPresShell,
    1:                          state.mFrameManager,
    1:                          state.mFloatedItems.containingBlock);
    1: 
    1:       // Removing the letterframes messes around with the frame tree, removing
27696:       // and creating frames.  We need to reget our prevsibling, parent frame,
27696:       // etc.
27696:       prevSibling =
27696:         GetInsertionPrevSibling(parentFrame, aContainer, aChild,
27696:                                 aIndexInContainer, &isAppend);
27696:       container = parentFrame->GetContent();
29838:       frameType = parentFrame->GetType();
    1:     }
    1:   }
    1: 
 8154:   if (!prevSibling) {
 8154:     // We're inserting the new frame as the first child. See if the
 8154:     // parent has a :before pseudo-element
 8154:     nsIFrame* firstChild = parentFrame->GetFirstChild(nsnull);
 8154: 
 8154:     if (firstChild &&
26101:         nsLayoutUtils::IsGeneratedContentFor(container, firstChild,
 8154:                                              nsCSSPseudoElements::before)) {
 8154:       // Insert the new frames after the last continuation of the :before
10780:       prevSibling = firstChild->GetTailContinuation();
27696:       parentFrame = prevSibling->GetParent()->GetContentInsertionFrame();
27310:       // Don't change isAppend here; we'll can call AppendFrames as needed, and
27310:       // the change to our prevSibling doesn't affect that.
 8154:     }
 8154:   }
 8154: 
25774:   FrameConstructionItemList items;
29838:   ParentType parentType = GetParentType(frameType);
29838:   if (aIndexInContainer > 0 && parentType == eTypeBlock) {
29838:     // If there's a text node in the normal content list just before the
29838:     // new node, and it has no frame, make a frame construction item for
29838:     // it, because it might need a frame now.  No need to do this if our
29838:     // parent type is not block, though, since WipeContainingBlock
29838:     // already handles that sitation.
29525:     AddTextItemIfNeeded(state, parentFrame, aContainer, aIndexInContainer - 1,
29501:                         items);
29501:   }
29501: 
29501:   AddFrameConstructionItems(state, aChild, aIndexInContainer, parentFrame, items);
29501: 
29838:   if (aIndexInContainer + 1 < PRInt32(aContainer->GetChildCount()) &&
29838:       parentType == eTypeBlock) {
29838:     // If there's a text node in the normal content list just after the
29838:     // new node, and it has no frame, make a frame construction item for
29838:     // it, because it might need a frame now.  No need to do this if our
29838:     // parent type is not block, though, since WipeContainingBlock
29838:     // already handles that sitation.
29525:     AddTextItemIfNeeded(state, parentFrame, aContainer, aIndexInContainer + 1,
29501:                         items);
29501:   }
25773: 
25773:   // Perform special check for diddling around with the frames in
25773:   // a special inline frame.
25773:   // If we're appending before :after content, then we're not really
25773:   // appending, so let WipeContainingBlock know that.
26720:   LAYOUT_PHASE_TEMP_EXIT();
25773:   if (WipeContainingBlock(state, containingBlock, parentFrame, items,
27310:                           isAppend, prevSibling)) {
26720:     LAYOUT_PHASE_TEMP_REENTER();
25773:     return NS_OK;
26720:   }
26720:   LAYOUT_PHASE_TEMP_REENTER();
25773: 
29501:   // If the container is a table and a caption will be appended, it needs to be
    1:   // put in the outer table frame's additional child list.
29501:   // We make no attempt here to set flags to indicate whether the list
29501:   // will be at the start or end of a block. It doesn't seem worthwhile.
    1:   nsFrameItems frameItems, captionItems;
26216:   ConstructFramesFromItemList(state, items, parentFrame, frameItems);
26216: 
30785:   if (frameItems.NotEmpty()) {
26216:     InvalidateCanvasIfNeeded(mPresShell, aChild);
    1:     
30785:     if (nsGkAtoms::tableCaptionFrame == frameItems.FirstChild()->GetType()) {
30785:       NS_ASSERTION(frameItems.OnlyChild(),
    1:                    "adding a non caption frame to the caption childlist?");
30785:       captionItems.AddChild(frameItems.FirstChild());
30785:       frameItems.Clear();
    1:     }
    1:   }
    1: 
 4194:   // If the parent of our current prevSibling is different from the frame we'll
 4194:   // actually use as the parent, then the calculated insertion point is now
 4194:   // invalid and as it is unknown where to insert correctly we append instead
 4194:   // (bug 341858).
27310:   // This can affect our prevSibling and isAppend, but should not have any
27310:   // effect on the WipeContainingBlock above, since this should only happen
27310:   // when neither parent is a special frame and should not affect whitespace
27310:   // handling inside table-related frames (and in fact, can only happen when
27310:   // one of the parents is an outer table and one is an inner table or when the
27311:   // parent is a fieldset or fieldset content frame).  So it won't affect the
27311:   // {ib} or XUL box cases in WipeContainingBlock(), and the table pseudo
27311:   // handling will only be affected by us maybe thinking we're not inserting
27311:   // at the beginning, whereas we really are.  That would have made us reframe
27311:   // unnecessarily, but that's ok.
25773:   // XXXbz we should push our frame construction item code up higher, so we
25773:   // know what our items are by the time we start figuring out previous
25773:   // siblings
30785:   if (prevSibling && frameItems.NotEmpty() &&
30785:       frameItems.FirstChild()->GetParent() != prevSibling->GetParent()) {
25773: #ifdef DEBUG
30785:     nsIFrame* frame1 = frameItems.FirstChild()->GetParent();
25773:     nsIFrame* frame2 = prevSibling->GetParent();
25773:     NS_ASSERTION(!IsFrameSpecial(frame1) && !IsFrameSpecial(frame2),
25773:                  "Neither should be special");
25773:     NS_ASSERTION((frame1->GetType() == nsGkAtoms::tableFrame &&
25773:                   frame2->GetType() == nsGkAtoms::tableOuterFrame) ||
25773:                  (frame1->GetType() == nsGkAtoms::tableOuterFrame &&
25773:                   frame2->GetType() == nsGkAtoms::tableFrame) ||
25773:                  frame1->GetType() == nsGkAtoms::fieldSetFrame ||
25773:                  (frame1->GetParent() &&
25773:                   frame1->GetParent()->GetType() == nsGkAtoms::fieldSetFrame),
25773:                  "Unexpected frame types");
25773: #endif
    1:     isAppend = PR_TRUE;
27310:     nsIFrame* appendAfterFrame;
    1:     parentFrame =
    1:       ::AdjustAppendParentForAfterContent(mPresShell->GetPresContext(),
26101:                                           container,
30785:                                           frameItems.FirstChild()->GetParent(),
    1:                                           &appendAfterFrame);
27310:     prevSibling = ::FindAppendPrevSibling(parentFrame, appendAfterFrame);
    1:   }
    1: 
    1:   if (haveFirstLineStyle && parentFrame == containingBlock) {
    1:     // It's possible that the new frame goes into a first-line
    1:     // frame. Look at it and see...
    1:     if (isAppend) {
    1:       // Use append logic when appending
    1:       AppendFirstLineFrames(state, containingBlock->GetContent(),
    1:                             containingBlock, frameItems); 
    1:     }
    1:     else {
    1:       // Use more complicated insert logic when inserting
26101:       // XXXbz this method is a no-op, so it's easy for the args being passed
26101:       // here to make no sense without anyone noticing...  If it ever stops
26101:       // being a no-op, vet them carefully!
26101:       InsertFirstLineFrames(state, container, containingBlock, &parentFrame,
    1:                             prevSibling, frameItems);
    1:     }
    1:   }
    1:       
30785:   if (NS_SUCCEEDED(rv) && frameItems.NotEmpty()) {
30785:     NS_ASSERTION(captionItems.IsEmpty(), "leaking caption frames");
 3663:     // Notify the parent frame
 3663:     if (isAppend) {
27310:       AppendFrames(state, parentFrame, frameItems, prevSibling);
 3663:     } else {
30785:       state.mFrameManager->InsertFrames(parentFrame, nsnull, prevSibling,
30941:                                         frameItems);
    1:     }
    1:   }
    1:   else {
    1:     // we might have a caption treat it here
30785:     if (NS_SUCCEEDED(rv) && captionItems.NotEmpty()) {
    1:       nsIFrame* outerTableFrame;
30941:       if (GetCaptionAdjustedParent(parentFrame, captionItems.FirstChild(),
30941:                                    &outerTableFrame)) {
 4194:         // If the parent of our current prevSibling is different from the frame
 4194:         // we'll actually use as the parent, then the calculated insertion
 4194:         // point is now invalid (bug 341382).
 4194:         if (prevSibling && prevSibling->GetParent() != outerTableFrame) {
    1:           prevSibling = nsnull;
    1:         }
    1:         // If the parent is not a outer table frame we will try to add frames
    1:         // to a named child list that the parent does not honour and the frames
    1:         // will get lost
    1:         NS_ASSERTION(nsGkAtoms::tableOuterFrame == outerTableFrame->GetType(),
    1:                      "Pseudo frame construction failure, "
    1:                      "a caption can be only a child of a outer table frame");
    1:         if (isAppend) {
    1:           state.mFrameManager->AppendFrames(outerTableFrame,
    1:                                             nsGkAtoms::captionList,
30941:                                             captionItems);
    1:         }
    1:         else {
    1:           state.mFrameManager->InsertFrames(outerTableFrame,
    1:                                             nsGkAtoms::captionList,
30941:                                             prevSibling, captionItems);
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (haveFirstLetterStyle) {
    1:     // Recover the letter frames for the containing block when
    1:     // it has first-letter style.
23461:     RecoverLetterFrames(state.mFloatedItems.containingBlock);
    1:   }
    1: 
    1: #ifdef DEBUG
    1:   if (gReallyNoisyContentUpdates && parentFrame) {
    1:     printf("nsCSSFrameConstructor::ContentInserted: resulting frame model:\n");
31709:     parentFrame->List(stdout, 0);
    1:   }
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
22483: static void
22483: DoDeletingFrameSubtree(nsFrameManager*      aFrameManager,
24551:                        nsTArray<nsIFrame*>& aDestroyQueue,
22483:                        nsIFrame*            aRemovedFrame,
22483:                        nsIFrame*            aFrame);
22483: 
22483: static void
22483: DoDeletingOverflowContainers(nsFrameManager*      aFrameManager,
24551:                              nsTArray<nsIFrame*>& aDestroyQueue,
22483:                              nsIFrame*            aRemovedFrame,
22483:                              nsIFrame*            aFrame)
22483: {
22483:   // The invariant that "continuing frames should be found as part of the
22483:   // walk over the top-most frame's continuing frames" does not hold for
22483:   // out-of-flow overflow containers, so we need to walk them too.
22483:   // Note that DoDeletingFrameSubtree() skips the child lists where
22483:   // overflow containers live so we won't process them twice.
22483:   const PRBool orphanSubtree = aRemovedFrame == aFrame;
22483:   for (nsIFrame* next = aFrame->GetNextContinuation();
22483:        next && (next->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER);
22483:        next = next->GetNextContinuation()) {
22483:     DoDeletingFrameSubtree(aFrameManager, aDestroyQueue,
22483:                            orphanSubtree ? next : aRemovedFrame,
22483:                            next);
22483:   }
22483: }
22483: 
    1: /**
    1:  * Called when a frame subtree is about to be deleted. Two important
    1:  * things happen:
    1:  *
    1:  * 1. For each frame in the subtree, we remove the mapping from the
    1:  *    content object to its frame
    1:  *
 2454:  * 2. For child frames that have been moved out of the flow, we enqueue
 2454:  *    the out-of-flow frame for deletion *if* the out-of-flow frame's
    1:  *    geometric parent is not in |aRemovedFrame|'s hierarchy (e.g., an
    1:  *    absolutely positioned element that has been promoted to be a direct
    1:  *    descendant of an area frame).
    1:  *
    1:  * Note: this function should only be called by DeletingFrameSubtree()
    1:  *
    1:  * @param   aRemovedFrame this is the frame that was removed from the
    1:  *            content model. As we recurse we need to remember this so we
    1:  *            can check if out-of-flow frames are a descendant of the frame
    1:  *            being removed
    1:  * @param   aFrame the local subtree that is being deleted. This is initially
    1:  *            the same as aRemovedFrame, but as we recurse down the tree
    1:  *            this changes
    1:  */
22483: static void
    1: DoDeletingFrameSubtree(nsFrameManager*      aFrameManager,
24551:                        nsTArray<nsIFrame*>& aDestroyQueue,
    1:                        nsIFrame*            aRemovedFrame,
    1:                        nsIFrame*            aFrame)
    1: {
22483: #undef RECURSE
22483: #define RECURSE(top, child)                                                  \
22483:   DoDeletingFrameSubtree(aFrameManager, aDestroyQueue, (top), (child));      \
22483:   DoDeletingOverflowContainers(aFrameManager, aDestroyQueue, (top), (child));
22483: 
    1:   // Remove the mapping from the content object to its frame.
    1:   nsIContent* content = aFrame->GetContent();
    1:   if (content) {
    1:     aFrameManager->RemoveAsPrimaryFrame(content, aFrame);
    1:     aFrameManager->ClearAllUndisplayedContentIn(content);
    1:   }
    1: 
    1:   nsIAtom* childListName = nsnull;
    1:   PRInt32 childListIndex = 0;
    1: 
    1:   do {
    1:     // Walk aFrame's normal flow child frames looking for placeholder frames.
    1:     nsIFrame* childFrame = aFrame->GetFirstChild(childListName);
    1:     for (; childFrame; childFrame = childFrame->GetNextSibling()) {
22483:       NS_ASSERTION(!(childFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW),
22483:                    "out-of-flow on wrong child list");
    1:       if (NS_LIKELY(nsGkAtoms::placeholderFrame != childFrame->GetType())) {
22483:         RECURSE(aRemovedFrame, childFrame);
    1:       } else {
    1:         nsIFrame* outOfFlowFrame =
    1:           nsPlaceholderFrame::GetRealFrameForPlaceholder(childFrame);
    1:   
    1:         // Don't SetOutOfFlowFrame(nsnull) here because the float cache depends
    1:         // on it when the float is removed later on, see bug 348688 comment 6.
    1:         
    1:         // Queue the out-of-flow frame to be destroyed only if aRemovedFrame is _not_
    1:         // one of its ancestor frames or if it is a popup frame. 
    1:         // If aRemovedFrame is an ancestor of the out-of-flow frame, then 
    1:         // the out-of-flow frame will be destroyed by aRemovedFrame.
    1:         if (outOfFlowFrame->GetStyleDisplay()->mDisplay == NS_STYLE_DISPLAY_POPUP ||
    1:             !nsLayoutUtils::IsProperAncestorFrame(aRemovedFrame, outOfFlowFrame)) {
33967:           NS_ASSERTION(!aDestroyQueue.Contains(outOfFlowFrame),
    1:                        "out-of-flow is already in the destroy queue");
    1:           aDestroyQueue.AppendElement(outOfFlowFrame);
    1:           // Recurse into the out-of-flow, it is now the aRemovedFrame.
22483:           RECURSE(outOfFlowFrame, outOfFlowFrame);
    1:         }
    1:         else {
    1:           // Also recurse into the out-of-flow when it's a descendant of aRemovedFrame
    1:           // since we don't walk those lists, see |childListName| increment below.
22483:           RECURSE(aRemovedFrame, outOfFlowFrame);
    1:         }
    1:       }
    1:     }
    1: 
    1:     // Move to next child list but skip lists with frames we should have
22483:     // a placeholder for or that contains only next-in-flow overflow containers
22483:     // (which we walk explicitly above).
    1:     do {
    1:       childListName = aFrame->GetAdditionalChildListName(childListIndex++);
22483:     } while (IsOutOfFlowList(childListName) ||
22483:              childListName == nsGkAtoms::overflowContainersList ||
22483:              childListName == nsGkAtoms::excessOverflowContainersList);
    1:   } while (childListName);
    1: }
    1: 
    1: /**
    1:  * Called when a frame is about to be deleted. Calls DoDeletingFrameSubtree()
    1:  * for aFrame and each of its continuing frames
    1:  */
    1: static nsresult
    1: DeletingFrameSubtree(nsFrameManager* aFrameManager,
    1:                      nsIFrame*       aFrame)
    1: {
    1:   NS_ENSURE_TRUE(aFrame, NS_OK); // XXXldb Remove this sometime in the future.
    1: 
    1:   // If there's no frame manager it's probably because the pres shell is
    1:   // being destroyed.
    1:   if (NS_UNLIKELY(!aFrameManager)) {
    1:     return NS_OK;
    1:   }
    1: 
24551:   nsAutoTArray<nsIFrame*, 8> destroyQueue;
    1: 
    1:   // If it's a "special" block-in-inline frame, then we can't really deal.
    1:   // That really shouldn't be happening.
    1:   NS_ASSERTION(!IsFrameSpecial(aFrame),
    1:                "DeletingFrameSubtree on a special frame.  Prepare to crash.");
    1: 
    1:   do {
    1:     DoDeletingFrameSubtree(aFrameManager, destroyQueue, aFrame, aFrame);
    1: 
    1:     // If it's split, then get the continuing frame. Note that we only do
    1:     // this for the top-most frame being deleted. Don't do it if we're
    1:     // recursing over a subtree, because those continuing frames should be
    1:     // found as part of the walk over the top-most frame's continuing frames.
    1:     // Walking them again will make this an N^2/2 algorithm.
22483:     // The above is true for normal child next-in-flows but not overflow
22483:     // containers which we do walk because they *can* escape the subtree
22483:     // we're deleting.  We skip [excess]overflowContainersList where
22483:     // they live to avoid processing them more than once.
    1:     aFrame = aFrame->GetNextContinuation();
    1:   } while (aFrame);
    1: 
    1:   // Now destroy any out-of-flow frames that have been enqueued for
    1:   // destruction.
24551:   for (PRInt32 i = destroyQueue.Length() - 1; i >= 0; --i) {
24551:     nsIFrame* outOfFlowFrame = destroyQueue[i];
    1: 
    1:     // Ask the out-of-flow's parent to delete the out-of-flow
    1:     // frame from the right list.
    1:     aFrameManager->RemoveFrame(outOfFlowFrame->GetParent(),
    1:                                GetChildListNameFor(outOfFlowFrame),
    1:                                outOfFlowFrame);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::RemoveMappingsForFrameSubtree(nsIFrame* aRemovedFrame)
    1: {
24413:   NS_ASSERTION(!(aRemovedFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW),
24413:                "RemoveMappingsForFrameSubtree doesn't handle out-of-flows");
24413: 
    1:   if (NS_UNLIKELY(mIsDestroyingFrameTree)) {
    1:     // The frame tree might not be in a consistent state after
    1:     // WillDestroyFrameTree() has been called. Most likely we're destroying
    1:     // the pres shell which means the frame manager takes care of clearing all
    1:     // mappings so there is no need to walk the frame tree here, bug 372576.
    1:     return NS_OK;
    1:   }
    1: 
24413:   nsFrameManager *frameManager = mPresShell->FrameManager();
24413:   if (nsGkAtoms::placeholderFrame == aRemovedFrame->GetType()) {
24413:     nsIFrame *placeholderFrame = aRemovedFrame;
24413:     do {
24413:       NS_ASSERTION(placeholderFrame->GetType() == nsGkAtoms::placeholderFrame,
24413:                    "continuation must be of same type");
24413:       nsIFrame* outOfFlowFrame =
24413:         nsPlaceholderFrame::GetRealFrameForPlaceholder(placeholderFrame);
24413:       // Remove the mapping from the out-of-flow frame to its placeholder.
24413:       frameManager->UnregisterPlaceholderFrame(
24413:         static_cast<nsPlaceholderFrame*>(placeholderFrame));
24413:       ::DeletingFrameSubtree(frameManager, outOfFlowFrame);
24413:       frameManager->RemoveFrame(outOfFlowFrame->GetParent(),
24413:                                 GetChildListNameFor(outOfFlowFrame),
24413:                                 outOfFlowFrame);
24413:       placeholderFrame = placeholderFrame->GetNextContinuation();
24413:     } while (placeholderFrame);
24413:   }
24413: 
    1:   // Save the frame tree's state before deleting it
    1:   CaptureStateFor(aRemovedFrame, mTempFrameTreeState);
    1: 
24413:   return ::DeletingFrameSubtree(frameManager, aRemovedFrame);
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ContentRemoved(nsIContent* aContainer,
    1:                                       nsIContent* aChild,
    1:                                       PRInt32     aIndexInContainer,
29501:                                       RemoveFlags aFlags,
 7681:                                       PRBool*     aDidReconstruct)
    1: {
    1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
 6518:   NS_PRECONDITION(mUpdateCount != 0,
 6518:                   "Should be in an update while destroying frames");
 6518: 
 7681:   *aDidReconstruct = PR_FALSE;
 7681:   
    1:   // XXXldb Do we need to re-resolve style to handle the CSS2 + combinator and
    1:   // the :empty pseudo-class?
    1: 
    1: #ifdef DEBUG
    1:   if (gNoisyContentUpdates) {
    1:     printf("nsCSSFrameConstructor::ContentRemoved container=%p child=%p index=%d\n",
 3233:            static_cast<void*>(aContainer),
 3233:            static_cast<void*>(aChild),
    1:            aIndexInContainer);
    1:     if (gReallyNoisyContentUpdates) {
    1:       aContainer->List(stdout, 0);
    1:     }
    1:   }
    1: #endif
    1: 
    1:   nsFrameManager *frameManager = mPresShell->FrameManager();
    1:   nsPresContext *presContext = mPresShell->GetPresContext();
    1:   nsresult                  rv = NS_OK;
    1: 
    1:   // Find the child frame that maps the content
    1:   nsIFrame* childFrame =
28215:     frameManager->GetPrimaryFrameFor(aChild, aIndexInContainer);
    1: 
21936:   if (!childFrame || childFrame->GetContent() != aChild) {
21936:     // XXXbz the GetContent() != aChild check is needed due to bug 135040.
21936:     // Remove it once that's fixed.
    1:     frameManager->ClearUndisplayedContentIn(aChild, aContainer);
    1:   }
    1: 
    1: #ifdef MOZ_XUL
    1:   if (NotifyListBoxBody(presContext, aContainer, aChild, aIndexInContainer, 
23941:                         mDocument, childFrame, CONTENT_REMOVED))
    1:     return NS_OK;
    1: 
    1: #endif // MOZ_XUL
    1: 
28215:   // If we're removing the root, then make sure to remove things starting at
28215:   // the viewport's child instead of the primary frame (which might even be
28215:   // null if the root had an XBL binding or display:none, even though the
28215:   // frames above it got created).  We do the adjustment after the childFrame
28215:   // check above, because we do want to clear any undisplayed content we might
28215:   // have for the root.  Detecting removal of a root is a little exciting; in
28215:   // particular, having a null aContainer is necessary but NOT sufficient.  Due
28215:   // to how we process reframes, the content node might not even be in our
28215:   // document by now.  So explicitly check whether the viewport's first kid's
28215:   // content node is aChild.
28215:   PRBool isRoot = PR_FALSE;
28215:   if (!aContainer) {
28215:     nsIFrame* viewport = frameManager->GetRootFrame();
28215:     if (viewport) {
28215:       nsIFrame* firstChild = viewport->GetFirstChild(nsnull);
28215:       if (firstChild && firstChild->GetContent() == aChild) {
28215:         isRoot = PR_TRUE;
28215:         childFrame = firstChild;
28215:         NS_ASSERTION(!childFrame->GetNextSibling(), "How did that happen?");
28215:       }
28215:     }
28215:   }
28215: 
    1:   if (childFrame) {
26216:     InvalidateCanvasIfNeeded(mPresShell, aChild);
    1:     
26471:     // See whether we need to remove more than just childFrame
30749:     LAYOUT_PHASE_TEMP_EXIT();
26471:     if (MaybeRecreateContainerForFrameRemoval(childFrame, &rv)) {
30749:       LAYOUT_PHASE_TEMP_REENTER();
 7681:       *aDidReconstruct = PR_TRUE;
 4696:       return rv;
    1:     }
30749:     LAYOUT_PHASE_TEMP_REENTER();
    1: 
    1:     // Get the childFrame's parent frame
    1:     nsIFrame* parentFrame = childFrame->GetParent();
 6862:     nsIAtom* parentType = parentFrame->GetType();
 6862: 
 6862:     if (parentType == nsGkAtoms::frameSetFrame &&
    1:         IsSpecialFramesetChild(aChild)) {
    1:       // Just reframe the parent, since framesets are weird like that.
 7681:       *aDidReconstruct = PR_TRUE;
30749:       LAYOUT_PHASE_TEMP_EXIT();
31031:       nsresult rv = RecreateFramesForContent(parentFrame->GetContent(), PR_FALSE);
30749:       LAYOUT_PHASE_TEMP_REENTER();
30749:       return rv;
    1:     }
    1: 
 6862: #ifdef MOZ_MATHML
 6862:     // If we're a child of MathML, then we should reframe the MathML content.
 6862:     // If we're non-MathML, then we would be wrapped in a block so we need to
 6862:     // check our grandparent in that case.
 6862:     nsIFrame* possibleMathMLAncestor = parentType == nsGkAtoms::blockFrame ? 
 6862:          parentFrame->GetParent() : parentFrame;
 7681:     if (possibleMathMLAncestor->IsFrameOfType(nsIFrame::eMathML)) {
 7681:       *aDidReconstruct = PR_TRUE;
30749:       LAYOUT_PHASE_TEMP_EXIT();
31031:       nsresult rv = RecreateFramesForContent(possibleMathMLAncestor->GetContent(), PR_FALSE);
30749:       LAYOUT_PHASE_TEMP_REENTER();
30749:       return rv;
 7681:     }
 6862: #endif
 6862: 
 7189:     // Undo XUL wrapping if it's no longer needed.
 7189:     // (If we're in the XUL block-wrapping situation, parentFrame is the
 7189:     // wrapper frame.)
 7189:     nsIFrame* grandparentFrame = parentFrame->GetParent();
 7189:     if (grandparentFrame && grandparentFrame->IsBoxFrame() &&
 7189:         (grandparentFrame->GetStateBits() & NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK) &&
 7189:         // check if this frame is the only one needing wrapping
 7189:         aChild == AnyKidsNeedBlockParent(parentFrame->GetFirstChild(nsnull)) &&
 7189:         !AnyKidsNeedBlockParent(childFrame->GetNextSibling())) {
 7681:       *aDidReconstruct = PR_TRUE;
30749:       LAYOUT_PHASE_TEMP_EXIT();
31031:       nsresult rv = RecreateFramesForContent(grandparentFrame->GetContent(), PR_TRUE);
30749:       LAYOUT_PHASE_TEMP_REENTER();
30749:       return rv;
 7189:     }
 7189:     
    1:     // Examine the containing-block for the removed content and see if
    1:     // :first-letter style applies.
    1:     nsIFrame* containingBlock = GetFloatContainingBlock(parentFrame);
 1254:     PRBool haveFLS = containingBlock && HasFirstLetterStyle(containingBlock);
    1:     if (haveFLS) {
    1:       // Trap out to special routine that handles adjusting a blocks
    1:       // frame tree when first-letter style is present.
    1: #ifdef NOISY_FIRST_LETTER
    1:       printf("ContentRemoved: containingBlock=");
    1:       nsFrame::ListTag(stdout, containingBlock);
    1:       printf(" parentFrame=");
    1:       nsFrame::ListTag(stdout, parentFrame);
    1:       printf(" childFrame=");
    1:       nsFrame::ListTag(stdout, childFrame);
    1:       printf("\n");
    1: #endif
    1: 
    1:       // First update the containing blocks structure by removing the
    1:       // existing letter frames. This makes the subsequent logic
    1:       // simpler.
    1:       RemoveLetterFrames(presContext, mPresShell, frameManager,
    1:                          containingBlock);
    1: 
    1:       // Recover childFrame and parentFrame
    1:       childFrame = mPresShell->GetPrimaryFrameFor(aChild);
21936:       if (!childFrame || childFrame->GetContent() != aChild) {
21936:         // XXXbz the GetContent() != aChild check is needed due to bug 135040.
21936:         // Remove it once that's fixed.
    1:         frameManager->ClearUndisplayedContentIn(aChild, aContainer);
    1:         return NS_OK;
    1:       }
    1:       parentFrame = childFrame->GetParent();
29580:       parentType = parentFrame->GetType();
    1: 
    1: #ifdef NOISY_FIRST_LETTER
    1:       printf("  ==> revised parentFrame=");
    1:       nsFrame::ListTag(stdout, parentFrame);
    1:       printf(" childFrame=");
    1:       nsFrame::ListTag(stdout, childFrame);
    1:       printf("\n");
    1: #endif
    1:     }
    1: 
    1: #ifdef DEBUG
    1:     if (gReallyNoisyContentUpdates) {
    1:       printf("nsCSSFrameConstructor::ContentRemoved: childFrame=");
    1:       nsFrame::ListTag(stdout, childFrame);
31709:       putchar('\n');
31709:       parentFrame->List(stdout, 0);
    1:     }
    1: #endif
    1: 
    1:     // Walk the frame subtree deleting any out-of-flow frames, and
    1:     // remove the mapping from content objects to frames
    1:     ::DeletingFrameSubtree(frameManager, childFrame);
    1: 
    1:     // See if the child frame is an out-of-flow
    1:     if (childFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
    1:       nsPlaceholderFrame* placeholderFrame =
    1:         frameManager->GetPlaceholderFrameFor(childFrame);
    1:       NS_ASSERTION(placeholderFrame, "No placeholder for out-of-flow?");
    1: 
    1:       // Now we remove the out-of-flow frame
    1:       // XXX has to be done first for now: for floats, the block's line list
    1:       // contains an array of pointers to the placeholder - we have to
    1:       // remove the float first (which gets rid of the lines
    1:       // reference to the placeholder and float) and then remove the
    1:       // placeholder
    1:       rv = frameManager->RemoveFrame(parentFrame,
    1:                                      GetChildListNameFor(childFrame),
    1:                                      childFrame);
    1: 
    1:       // Remove the placeholder frame first (XXX second for now) (so
    1:       // that it doesn't retain a dangling pointer to memory)
    1:       nsIFrame* placeholderParent = placeholderFrame->GetParent();
    1:       ::DeletingFrameSubtree(frameManager, placeholderFrame);
    1:       rv |= frameManager->RemoveFrame(placeholderParent,
    1:                                       nsnull, placeholderFrame);
    1:     } else {
    1:       // Notify the parent frame that it should delete the frame
    1:       // check for a table caption which goes on an additional child list with a different parent
    1:       nsIFrame* outerTableFrame; 
    1:       if (GetCaptionAdjustedParent(parentFrame, childFrame, &outerTableFrame)) {
    1:         rv = frameManager->RemoveFrame(outerTableFrame,
    1:                                        nsGkAtoms::captionList,
    1:                                        childFrame);
    1:       }
    1:       else {
    1:         rv = frameManager->RemoveFrame(parentFrame, nsnull, childFrame);
    1:       }
    1:     }
    1: 
28215:     if (isRoot) {
24659:       mRootElementFrame = nsnull;
16509:       mRootElementStyleFrame = nsnull;
28215:       mDocElementContainingBlock = nsnull;
28215:       mPageSequenceFrame = nsnull;
28215:       mGfxScrollFrame = nsnull;
28215:       mHasRootAbsPosContainingBlock = PR_FALSE;
28215:       mFixedContainingBlock = frameManager->GetRootFrame();
    1:     }
    1: 
24659:     if (haveFLS && mRootElementFrame) {
    1:       NS_ASSERTION(containingBlock == GetFloatContainingBlock(parentFrame),
    1:                    "What happened here?");
    1:       nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
    1:                                     GetAbsoluteContainingBlock(parentFrame),
    1:                                     containingBlock);
23461:       RecoverLetterFrames(containingBlock);
    1:     }
    1: 
29501:     // If we're just reconstructing frames for the element, then the
29501:     // following ContentInserted notification on the element will
29580:     // take care of fixing up any adjacent text nodes.  We don't need
29580:     // to do this if the table parent type of our parent type is not
29580:     // eTypeBlock, though, because in that case the whitespace isn't
29580:     // being suppressed due to us anyway.
29501:     if (aContainer && aIndexInContainer >= 0 &&
29580:         aFlags != REMOVE_FOR_RECONSTRUCTION &&
29580:         GetParentType(parentType) == eTypeBlock) {
29501:       // Adjacent whitespace-only text nodes might have been suppressed if
29501:       // this node does not have inline ends. Create frames for them now
29501:       // if necessary.
29501:       PRInt32 childCount = aContainer->GetChildCount();
29525:       // Reframe any text node just before the node being removed, if there is
29525:       // one, and if it's not the last child or the first child. If a whitespace
29525:       // textframe was being suppressed and it's now the last child or first
29525:       // child then it can stay suppressed since the parent must be a block
29525:       // and hence it's adjacent to a block end.
29525:       PRInt32 prevSiblingIndex = aIndexInContainer - 1;
29525:       if (prevSiblingIndex > 0 && prevSiblingIndex < childCount - 1) {
30749:         LAYOUT_PHASE_TEMP_EXIT();
29525:         ReframeTextIfNeeded(aContainer, prevSiblingIndex);
30749:         LAYOUT_PHASE_TEMP_REENTER();
29525:       }
29525:       // Reframe any text node just after the node being removed, if there is
29525:       // one, and if it's not the last child or the first child.
29525:       if (aIndexInContainer > 0 && aIndexInContainer < childCount - 1) {
30749:         LAYOUT_PHASE_TEMP_EXIT();
29501:         ReframeTextIfNeeded(aContainer, aIndexInContainer);
30749:         LAYOUT_PHASE_TEMP_REENTER();
29501:       }
29501:     }
29501: 
    1: #ifdef DEBUG
    1:     if (gReallyNoisyContentUpdates && parentFrame) {
    1:       printf("nsCSSFrameConstructor::ContentRemoved: resulting frame model:\n");
31709:       parentFrame->List(stdout, 0);
    1:     }
    1: #endif
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: #ifdef DEBUG
    1:   // To ensure that the functions below are only called within
    1:   // |ApplyRenderingChangeToTree|.
    1: static PRBool gInApplyRenderingChangeToTree = PR_FALSE;
    1: #endif
    1: 
    1: static void
    1: DoApplyRenderingChangeToTree(nsIFrame* aFrame,
    1:                              nsIViewManager* aViewManager,
    1:                              nsFrameManager* aFrameManager,
    1:                              nsChangeHint aChange);
    1: 
    1: /**
    1:  * @param aBoundsRect returns the bounds enclosing the areas covered by aFrame and its childre
    1:  * This rect is relative to aFrame's parent
    1:  */
    1: static void
    1: UpdateViewsForTree(nsIFrame* aFrame, nsIViewManager* aViewManager,
    1:                    nsFrameManager* aFrameManager,
  134:                    nsChangeHint aChange)
    1: {
    1:   NS_PRECONDITION(gInApplyRenderingChangeToTree,
    1:                   "should only be called within ApplyRenderingChangeToTree");
    1: 
    1:   nsIView* view = aFrame->GetView();
    1:   if (view) {
    1:     if (aChange & nsChangeHint_SyncFrameView) {
  238:       nsContainerFrame::SyncFrameViewProperties(aFrame->PresContext(),
    1:                                                 aFrame, nsnull, view);
    1:     }
    1:   }
    1: 
    1:   // now do children of frame
    1:   PRInt32 listIndex = 0;
    1:   nsIAtom* childList = nsnull;
    1: 
    1:   do {
    1:     nsIFrame* child = aFrame->GetFirstChild(childList);
    1:     while (child) {
 6521:       if (!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW)
 6521:           || (child->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER)) {
 7655:         // only do frames that don't have placeholders
    1:         if (nsGkAtoms::placeholderFrame == child->GetType()) { // placeholder
    1:           // get out of flow frame and start over there
    1:           nsIFrame* outOfFlowFrame =
    1:             nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
    1: 
    1:           DoApplyRenderingChangeToTree(outOfFlowFrame, aViewManager,
    1:                                        aFrameManager, aChange);
    1:         }
    1:         else {  // regular frame
  134:           UpdateViewsForTree(child, aViewManager, aFrameManager, aChange);
    1:         }
    1:       }
    1:       child = child->GetNextSibling();
    1:     }
    1:     childList = aFrame->GetAdditionalChildListName(listIndex++);
    1:   } while (childList);
    1: }
    1: 
    1: static void
    1: DoApplyRenderingChangeToTree(nsIFrame* aFrame,
    1:                              nsIViewManager* aViewManager,
    1:                              nsFrameManager* aFrameManager,
    1:                              nsChangeHint aChange)
    1: {
    1:   NS_PRECONDITION(gInApplyRenderingChangeToTree,
    1:                   "should only be called within ApplyRenderingChangeToTree");
    1: 
   94:   for ( ; aFrame; aFrame = nsLayoutUtils::GetNextContinuationOrSpecialSibling(aFrame)) {
    1:     // Get view if this frame has one and trigger an update. If the
    1:     // frame doesn't have a view, find the nearest containing view
    1:     // (adjusting r's coordinate system to reflect the nesting) and
    1:     // update there.
  134:     UpdateViewsForTree(aFrame, aViewManager, aFrameManager, aChange);
    1: 
    1:     // if frame has view, will already be invalidated
24030:     if (aChange & nsChangeHint_RepaintFrame) {
24030:       if (aFrame->IsFrameOfType(nsIFrame::eSVG)) {
24030: #ifdef MOZ_SVG
24030:         if (!(aFrame->GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD)) {
24030:           nsSVGOuterSVGFrame *outerSVGFrame = nsSVGUtils::GetOuterSVGFrame(aFrame);
24030:           if (outerSVGFrame) {
29068:             // We need this to invalidate frames when their 'filter' or 'marker'
29068:             // property changes. XXX in theory changes to 'marker' should be
29068:             // handled in nsSVGPathGeometryFrame::DidSetStyleContext, but for
29068:             // some reason that's broken.
29068:             //
29068:             // This call is also currently the only mechanism for invalidating
29068:             // the area covered by a <foreignObject> when 'opacity' changes on
29068:             // it or one of its ancestors. (For 'opacity' changes on <image> or
29068:             // a graphical element such as <path>, or on one of their
29068:             // ancestors, this is redundant since
29068:             // nsSVGPathGeometryFrame::DidSetStyleContext also invalidates.)
24030:             outerSVGFrame->UpdateAndInvalidateCoveredRegion(aFrame);
24030:           }
24030:         }
24030: #endif
24030:       } else {
  134:         aFrame->Invalidate(aFrame->GetOverflowRect());
    1:       }
    1:     }
    1:   }
24030: }
    1: 
    1: static void
    1: ApplyRenderingChangeToTree(nsPresContext* aPresContext,
    1:                            nsIFrame* aFrame,
    1:                            nsChangeHint aChange)
    1: {
    1:   nsIPresShell *shell = aPresContext->PresShell();
    1:   PRBool isPaintingSuppressed = PR_FALSE;
    1:   shell->IsPaintingSuppressed(&isPaintingSuppressed);
    1:   if (isPaintingSuppressed) {
    1:     // Don't allow synchronous rendering changes when painting is turned off.
    1:     aChange = NS_SubtractHint(aChange, nsChangeHint_RepaintFrame);
    1:     if (!aChange) {
    1:       return;
    1:     }
    1:   }
    1: 
    1:   // If the frame's background is propagated to an ancestor, walk up to
    1:   // that ancestor.
    1:   const nsStyleBackground *bg;
25022:   while (!nsCSSRendering::FindBackground(aPresContext, aFrame, &bg)) {
    1:     aFrame = aFrame->GetParent();
    1:     NS_ASSERTION(aFrame, "root frame must paint");
    1:   }
    1: 
26050:   nsIViewManager* viewManager = shell->GetViewManager();
    1: 
    1:   // Trigger rendering updates by damaging this frame and any
    1:   // continuations of this frame.
    1: 
    1:   // XXX this needs to detect the need for a view due to an opacity change and deal with it...
    1: 
10730:   nsIViewManager::UpdateViewBatch batch(viewManager);
    1: 
    1: #ifdef DEBUG
    1:   gInApplyRenderingChangeToTree = PR_TRUE;
    1: #endif
    1:   DoApplyRenderingChangeToTree(aFrame, viewManager, shell->FrameManager(),
    1:                                aChange);
    1: #ifdef DEBUG
    1:   gInApplyRenderingChangeToTree = PR_FALSE;
    1: #endif
    1:   
10730:   batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
    1: }
    1: 
    1: /**
    1:  * This method invalidates the canvas when frames are removed or added for a
    1:  * node that might have its background propagated to the canvas, i.e., a
    1:  * document root node or an HTML BODY which is a child of the root node.
    1:  *
26471:  * @param aFrame a frame for a content node about to be removed or a frame that
    1:  *               was just created for a content node that was inserted.
    1:  */ 
    1: static void
26216: InvalidateCanvasIfNeeded(nsIPresShell* presShell, nsIContent* node)
26216: {
26216:   NS_PRECONDITION(presShell->GetRootFrame(), "What happened here?");
26216:   NS_PRECONDITION(presShell->GetPresContext(), "Say what?");
26216: 
26216:   //  Note that both in ContentRemoved and ContentInserted the content node
    1:   //  will still have the right parent pointer, so looking at that is ok.
    1:   
    1:   nsIContent* parent = node->GetParent();
    1:   if (parent) {
    1:     // Has a parent; might not be what we want
    1:     nsIContent* grandParent = parent->GetParent();
    1:     if (grandParent) {
    1:       // Has a grandparent, so not what we want
    1:       return;
    1:     }
    1: 
    1:     // Check whether it's an HTML body
    1:     if (node->Tag() != nsGkAtoms::body ||
33329:         !node->IsHTML()) {
    1:       return;
    1:     }
    1:   }
    1: 
    1:   // At this point the node has no parent or it's an HTML <body> child of the
    1:   // root.  We might not need to invalidate in this case (eg we might be in
26216:   // XHTML or something), but chances are we want to.  Play it safe.
26216:   // Invalidate the viewport.
26216: 
 7808:   // Wrap this in a DEFERRED view update batch so we don't try to
 7808:   // flush out layout here
 7808: 
26216:   nsIViewManager::UpdateViewBatch batch(presShell->GetViewManager());
26216:   ApplyRenderingChangeToTree(presShell->GetPresContext(),
26216:                              presShell->GetRootFrame(),
    1:                              nsChangeHint_RepaintFrame);
10730:   batch.EndUpdateViewBatch(NS_VMREFRESH_DEFERRED);
    1: }
    1: 
    1: nsresult
31101: nsCSSFrameConstructor::StyleChangeReflow(nsIFrame* aFrame,
31101:                                          nsChangeHint aHint)
    1: {
    1:   // If the frame hasn't even received an initial reflow, then don't
    1:   // send it a style-change reflow!
    1:   if (aFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW)
    1:     return NS_OK;
    1: 
    1: #ifdef DEBUG
    1:   if (gNoisyContentUpdates) {
    1:     printf("nsCSSFrameConstructor::StyleChangeReflow: aFrame=");
    1:     nsFrame::ListTag(stdout, aFrame);
    1:     printf("\n");
    1:   }
    1: #endif
    1: 
31101:   nsIPresShell::IntrinsicDirty dirtyType;
31101:   if (aHint & nsChangeHint_ClearDescendantIntrinsics) {
31101:     NS_ASSERTION(aHint & nsChangeHint_ClearAncestorIntrinsics,
31101:                  "Please read the comments in nsChangeHint.h");
31101:     dirtyType = nsIPresShell::eStyleChange;
31101:   } else if (aHint & nsChangeHint_ClearAncestorIntrinsics) {
31101:     dirtyType = nsIPresShell::eTreeChange;
31101:   } else {
31101:     dirtyType = nsIPresShell::eResize;
31101:   }
31101: 
31101:   nsFrameState dirtyBits;
31101:   if (aHint & nsChangeHint_NeedDirtyReflow) {
31101:     dirtyBits = NS_FRAME_IS_DIRTY;
31101:   } else {
31101:     dirtyBits = NS_FRAME_HAS_DIRTY_CHILDREN;
31101:   }
    1: 
 6521:   do {
31101:     mPresShell->FrameNeedsReflow(aFrame, dirtyType, dirtyBits);
31101:     aFrame = nsLayoutUtils::GetNextContinuationOrSpecialSibling(aFrame);
 6521:   } while (aFrame);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::CharacterDataChanged(nsIContent* aContent,
31131:                                             CharacterDataChangeInfo* aInfo)
    1: {
    1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
    1:   nsresult      rv = NS_OK;
    1: 
29809:   if ((aContent->HasFlag(NS_CREATE_FRAME_IF_NON_WHITESPACE) &&
29809:        !aContent->TextIsOnlyWhitespace()) ||
29809:       (aContent->HasFlag(NS_REFRAME_IF_WHITESPACE) &&
29809:        aContent->TextIsOnlyWhitespace())) {
27311: #ifdef DEBUG
27311:     nsIFrame* frame = mPresShell->GetPrimaryFrameFor(aContent);
27311:     NS_ASSERTION(!frame || !frame->IsGeneratedContentFrame(),
27311:                  "Bit should never be set on generated content");
27311: #endif
30749:     LAYOUT_PHASE_TEMP_EXIT();
31031:     nsresult rv = RecreateFramesForContent(aContent, PR_FALSE);
30749:     LAYOUT_PHASE_TEMP_REENTER();
30749:     return rv;
27311:   }
27311: 
    1:   // Find the child frame
    1:   nsIFrame* frame = mPresShell->GetPrimaryFrameFor(aContent);
    1: 
    1:   // Notify the first frame that maps the content. It will generate a reflow
    1:   // command
    1: 
    1:   // It's possible the frame whose content changed isn't inserted into the
    1:   // frame hierarchy yet, or that there is no frame that maps the content
    1:   if (nsnull != frame) {
    1: #if 0
    1:     NS_FRAME_LOG(NS_FRAME_TRACE_CALLS,
    1:        ("nsCSSFrameConstructor::CharacterDataChanged: content=%p[%s] subcontent=%p frame=%p",
    1:         aContent, ContentTag(aContent, 0),
    1:         aSubContent, frame));
    1: #endif
    1: 
    1:     // Special check for text content that is a child of a letter frame.  If
    1:     // this happens, we should remove the letter frame, do whatever we're
    1:     // planning to do with this notification, then put the letter frame back.
28215:     // Note that this is basically what RecreateFramesForContent ends up doing;
28215:     // the reason we dont' want to call that here is that our text content
28215:     // could be native anonymous, in which case RecreateFramesForContent would
28215:     // completely barf on it.  And recreating the non-anonymous ancestor would
28215:     // just lead us to come back into this notification (e.g. if quotes or
28215:     // counters are involved), leading to a loop.
    1:     nsIFrame* block = GetFloatContainingBlock(frame);
    1:     PRBool haveFirstLetterStyle = PR_FALSE;
    1:     if (block) {
    1:       // See if the block has first-letter style applied to it.
 1254:       haveFirstLetterStyle = HasFirstLetterStyle(block);
    1:       if (haveFirstLetterStyle) {
    1:         RemoveLetterFrames(mPresShell->GetPresContext(), mPresShell,
    1:                            mPresShell->FrameManager(), block);
    1:         // Reget |frame|, since we might have killed it.
    1:         // Do we really need to call CharacterDataChanged in this case, though?
    1:         frame = mPresShell->GetPrimaryFrameFor(aContent);
    1:         NS_ASSERTION(frame, "Should have frame here!");
    1:       }
    1:     }
    1: 
31131:     frame->CharacterDataChanged(aInfo);
    1: 
    1:     if (haveFirstLetterStyle) {
    1:       nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
    1:                                     GetAbsoluteContainingBlock(frame),
    1:                                     block, nsnull);
23461:       RecoverLetterFrames(block);
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ProcessRestyledFrames(nsStyleChangeList& aChangeList)
    1: {
23652:   NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
23652:                "Someone forgot a script blocker");
    1:   PRInt32 count = aChangeList.Count();
    1:   if (!count)
    1:     return NS_OK;
    1: 
 6467:   // Make sure to not rebuild quote or counter lists while we're
 6467:   // processing restyles
 6467:   BeginUpdate();
 6467: 
30522:   nsPresContext* presContext = mPresShell->GetPresContext();
30522:   nsPropertyTable *propTable = presContext->PropertyTable();
    1: 
    1:   // Mark frames so that we skip frames that die along the way, bug 123049.
    1:   // A frame can be in the list multiple times with different hints. Further
    1:   // optmization is possible if nsStyleChangeList::AppendChange could coalesce
    1:   PRInt32 index = count;
    1: 
    1:   while (0 <= --index) {
    1:     const nsStyleChangeData* changeData;
    1:     aChangeList.ChangeAt(index, &changeData);
    1:     if (changeData->mFrame) {
    1:       propTable->SetProperty(changeData->mFrame,
    1:                              nsGkAtoms::changeListProperty,
    1:                              nsnull, nsnull, nsnull);
    1:     }
    1:   }
    1: 
    1:   index = count;
30522:   PRBool didInvalidate = PR_FALSE;
30522:   PRBool didReflow = PR_FALSE;
30522: 
    1:   while (0 <= --index) {
    1:     nsIFrame* frame;
    1:     nsIContent* content;
    1:     nsChangeHint hint;
    1:     aChangeList.ChangeAt(index, frame, content, hint);
31101: 
31101:     NS_ASSERTION(!(hint & nsChangeHint_ReflowFrame) ||
31101:                  (hint & nsChangeHint_NeedReflow),
31101:                  "Reflow hint bits set without actually asking for a reflow");
31101: 
21936:     if (frame && frame->GetContent() != content) {
21936:       // XXXbz this is due to image maps messing with the primary frame map.
21936:       // See bug 135040.  Remove this block once that's fixed.
21936:       frame = nsnull;
21936:       if (!(hint & nsChangeHint_ReconstructFrame)) {
21936:         continue;
21936:       }
21936:     }
    1: 
    1:     // skip any frame that has been destroyed due to a ripple effect
    1:     if (frame) {
    1:       nsresult res;
    1: 
    1:       propTable->GetProperty(frame, nsGkAtoms::changeListProperty, &res);
    1: 
    1:       if (NS_PROPTABLE_PROP_NOT_THERE == res)
    1:         continue;
    1:     }
    1: 
    1:     if (hint & nsChangeHint_ReconstructFrame) {
31031:       RecreateFramesForContent(content, PR_FALSE);
    1:     } else {
    1:       NS_ASSERTION(frame, "This shouldn't happen");
16411: #ifdef MOZ_SVG
16411:       if (hint & nsChangeHint_UpdateEffects) {
19948:         nsSVGEffects::UpdateEffects(frame);
16411:       }
16411: #endif
31101:       if (hint & nsChangeHint_NeedReflow) {
31101:         StyleChangeReflow(frame, hint);
30522:         didReflow = PR_TRUE;
    1:       }
    1:       if (hint & (nsChangeHint_RepaintFrame | nsChangeHint_SyncFrameView)) {
30522:         ApplyRenderingChangeToTree(presContext, frame, hint);
30522:         didInvalidate = PR_TRUE;
    1:       }
    1:       if (hint & nsChangeHint_UpdateCursor) {
    1:         nsIViewManager* viewMgr = mPresShell->GetViewManager();
    1:         if (viewMgr)
    1:           viewMgr->SynthesizeMouseMove(PR_FALSE);
    1:       }
    1:     }
    1:   }
    1: 
 6467:   EndUpdate();
 6467: 
30522:   if (didInvalidate && !didReflow) {
30522:     // RepaintFrame changes can indicate changes in opacity etc which
30522:     // can require plugin clipping to change. If we requested a reflow,
30522:     // we don't need to do this since the reflow will do it for us.
30522:     nsIFrame* rootFrame = mPresShell->FrameManager()->GetRootFrame();
30522:     presContext->RootPresContext()->UpdatePluginGeometry(rootFrame);
30522:   }
30522: 
 6739:   // cleanup references and verify the style tree.  Note that the latter needs
 6739:   // to happen once we've processed the whole list, since until then the tree
 6739:   // is not in fact in a consistent state.
    1:   index = count;
    1:   while (0 <= --index) {
    1:     const nsStyleChangeData* changeData;
    1:     aChangeList.ChangeAt(index, &changeData);
    1:     if (changeData->mFrame) {
    1:       propTable->DeleteProperty(changeData->mFrame,
    1:                                 nsGkAtoms::changeListProperty);
    1:     }
 6739: 
 6739: #ifdef DEBUG
 6739:     // reget frame from content since it may have been regenerated...
 6739:     if (changeData->mContent) {
 6739:       nsIFrame* frame = mPresShell->GetPrimaryFrameFor(changeData->mContent);
 6739:       if (frame) {
 6739:         mPresShell->FrameManager()->DebugVerifyStyleTree(frame);
 6739:       }
 6739:     } else {
 6739:       NS_WARNING("Unable to test style tree integrity -- no content node");
 6739:     }
 6739: #endif
    1:   }
    1: 
    1:   aChangeList.Clear();
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsCSSFrameConstructor::RestyleElement(nsIContent     *aContent,
    1:                                       nsIFrame       *aPrimaryFrame,
    1:                                       nsChangeHint   aMinHint)
    1: {
11409:   NS_ASSERTION(aPrimaryFrame == mPresShell->GetPrimaryFrameFor(aContent),
11409:                "frame/content mismatch");
21936:   if (aPrimaryFrame && aPrimaryFrame->GetContent() != aContent) {
21936:     // XXXbz this is due to image maps messing with the primary frame mapping.
21936:     // See bug 135040.  We can remove this block once that's fixed.
21936:     aPrimaryFrame = nsnull;
21936:   }
11409:   NS_ASSERTION(!aPrimaryFrame || aPrimaryFrame->GetContent() == aContent,
11409:                "frame/content mismatch");
11409: 
    1:   if (aMinHint & nsChangeHint_ReconstructFrame) {
31031:     RecreateFramesForContent(aContent, PR_FALSE);
    1:   } else if (aPrimaryFrame) {
    1:     nsStyleChangeList changeList;
11409:     mPresShell->FrameManager()->
    1:       ComputeStyleChangeFor(aPrimaryFrame, &changeList, aMinHint);
    1:     ProcessRestyledFrames(changeList);
    1:   } else {
    1:     // no frames, reconstruct for content
    1:     MaybeRecreateFramesForContent(aContent);
    1:   }
    1: }
    1: 
    1: void
    1: nsCSSFrameConstructor::RestyleLaterSiblings(nsIContent *aContent)
    1: {
    1:   nsIContent *parent = aContent->GetParent();
    1:   if (!parent)
    1:     return; // root element has no later siblings
    1: 
    1:   for (PRInt32 index = parent->IndexOf(aContent) + 1,
    1:                index_end = parent->GetChildCount();
    1:        index != index_end; ++index) {
    1:     nsIContent *child = parent->GetChildAt(index);
    1:     if (!child->IsNodeOfType(nsINode::eELEMENT))
    1:       continue;
    1: 
    1:     nsIFrame* primaryFrame = mPresShell->GetPrimaryFrameFor(child);
    1:     RestyleElement(child, primaryFrame, NS_STYLE_HINT_NONE);
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ContentStatesChanged(nsIContent* aContent1,
    1:                                             nsIContent* aContent2,
    1:                                             PRInt32 aStateMask) 
    1: {
    1:   DoContentStateChanged(aContent1, aStateMask);
    1:   DoContentStateChanged(aContent2, aStateMask);
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsCSSFrameConstructor::DoContentStateChanged(nsIContent* aContent,
    1:                                              PRInt32 aStateMask) 
    1: {
    1:   nsStyleSet *styleSet = mPresShell->StyleSet();
    1:   nsPresContext *presContext = mPresShell->GetPresContext();
    1:   NS_ASSERTION(styleSet, "couldn't get style set");
    1: 
    1:   if (aContent) {
    1:     nsChangeHint hint = NS_STYLE_HINT_NONE;
    1:     // Any change to a content state that affects which frames we construct
    1:     // must lead to a frame reconstruct here if we already have a frame.
    1:     // Note that we never decide through non-CSS means to not create frames
    1:     // based on content states, so if we already don't have a frame we don't
    1:     // need to force a reframe -- if it's needed, the HasStateDependentStyle
    1:     // call will handle things.
    1:     nsIFrame* primaryFrame = mPresShell->GetPrimaryFrameFor(aContent);
    1:     if (primaryFrame) {
    1:       // If it's generated content, ignore LOADING/etc state changes on it.
    1:       if (!primaryFrame->IsGeneratedContentFrame() &&
    1:           (aStateMask & (NS_EVENT_STATE_BROKEN | NS_EVENT_STATE_USERDISABLED |
    1:                          NS_EVENT_STATE_SUPPRESSED | NS_EVENT_STATE_LOADING))) {
    1:         hint = nsChangeHint_ReconstructFrame;
    1:       } else {          
    1:         PRUint8 app = primaryFrame->GetStyleDisplay()->mAppearance;
    1:         if (app) {
    1:           nsITheme *theme = presContext->GetTheme();
    1:           if (theme && theme->ThemeSupportsWidget(presContext,
    1:                                                   primaryFrame, app)) {
    1:             PRBool repaint = PR_FALSE;
    1:             theme->WidgetStateChanged(primaryFrame, app, nsnull, &repaint);
    1:             if (repaint) {
    1:               NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1: 
    1:     nsReStyleHint rshint = 
    1:       styleSet->HasStateDependentStyle(presContext, aContent, aStateMask);
    1:       
22471:     if ((aStateMask & NS_EVENT_STATE_HOVER) && rshint != 0) {
22471:       ++mHoverGeneration;
22471:     }
22471: 
    1:     PostRestyleEvent(aContent, rshint, hint);
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::AttributeChanged(nsIContent* aContent,
    1:                                         PRInt32 aNameSpaceID,
    1:                                         nsIAtom* aAttribute,
 3410:                                         PRInt32 aModType,
 3410:                                         PRUint32 aStateMask)
    1: {
    1:   nsresult  result = NS_OK;
    1: 
    1:   // Hold onto the PresShell to prevent ourselves from being destroyed.
    1:   // XXXbz how, exactly, would this attribute change cause us to be
    1:   // destroyed from inside this function?
    1:   nsCOMPtr<nsIPresShell> shell = mPresShell;
    1: 
    1:   // Get the frame associated with the content which is the highest in the frame tree
    1:   nsIFrame* primaryFrame = shell->GetPrimaryFrameFor(aContent); 
    1: 
    1: #if 0
    1:   NS_FRAME_LOG(NS_FRAME_TRACE_CALLS,
    1:      ("HTMLStyleSheet::AttributeChanged: content=%p[%s] frame=%p",
    1:       aContent, ContentTag(aContent, 0), frame));
    1: #endif
    1: 
    1:   // the style tag has its own interpretation based on aHint 
 4036:   nsChangeHint hint = aContent->GetAttributeChangeHint(aAttribute, aModType);
    1: 
    1:   PRBool reframe = (hint & nsChangeHint_ReconstructFrame) != 0;
    1: 
    1: #ifdef MOZ_XUL
    1:   // The following listbox widget trap prevents offscreen listbox widget
    1:   // content from being removed and re-inserted (which is what would
    1:   // happen otherwise).
    1:   if (!primaryFrame && !reframe) {
    1:     PRInt32 namespaceID;
    1:     nsIAtom* tag =
    1:       mDocument->BindingManager()->ResolveTag(aContent, &namespaceID);
    1: 
    1:     if (namespaceID == kNameSpaceID_XUL &&
    1:         (tag == nsGkAtoms::listitem ||
    1:          tag == nsGkAtoms::listcell))
    1:       return NS_OK;
    1:   }
    1: 
    1:   if (aAttribute == nsGkAtoms::tooltiptext ||
    1:       aAttribute == nsGkAtoms::tooltip) 
    1:   {
    1:     nsIRootBox* rootBox = nsIRootBox::GetRootBox(mPresShell);
    1:     if (rootBox) {
    1:       if (aModType == nsIDOMMutationEvent::REMOVAL)
    1:         rootBox->RemoveTooltipSupport(aContent);
    1:       if (aModType == nsIDOMMutationEvent::ADDITION)
    1:         rootBox->AddTooltipSupport(aContent);
    1:     }
    1:   }
    1: 
    1: #endif // MOZ_XUL
    1: 
    1:   if (primaryFrame) {
    1:     // See if we have appearance information for a theme.
    1:     const nsStyleDisplay* disp = primaryFrame->GetStyleDisplay();
    1:     if (disp->mAppearance) {
    1:       nsPresContext* presContext = mPresShell->GetPresContext();
    1:       nsITheme *theme = presContext->GetTheme();
 4036:       if (theme && theme->ThemeSupportsWidget(presContext, primaryFrame, disp->mAppearance)) {
    1:         PRBool repaint = PR_FALSE;
 4036:         theme->WidgetStateChanged(primaryFrame, disp->mAppearance, aAttribute, &repaint);
    1:         if (repaint)
    1:           NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
    1:       }
    1:     }
    1:    
    1:     // let the frame deal with it now, so we don't have to deal later
    1:     result = primaryFrame->AttributeChanged(aNameSpaceID, aAttribute,
    1:                                             aModType);
    1:     // XXXwaterson should probably check for special IB siblings
    1:     // here, and propagate the AttributeChanged notification to
    1:     // them, as well. Currently, inline frames don't do anything on
    1:     // this notification, so it's not that big a deal.
    1:   }
    1: 
    1:   // See if we can optimize away the style re-resolution -- must be called after
    1:   // the frame's AttributeChanged() in case it does something that affects the style
    1:   nsFrameManager *frameManager = shell->FrameManager();
    1:   nsReStyleHint rshint = frameManager->HasAttributeDependentStyle(aContent,
    1:                                                                   aAttribute,
 3410:                                                                   aModType,
 3410:                                                                   aStateMask);
    1: 
    1:   PostRestyleEvent(aContent, rshint, hint);
    1: 
    1:   return result;
    1: }
    1: 
    1: void
11855: nsCSSFrameConstructor::BeginUpdate() {
29072:   NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
29072:                "Someone forgot a script blocker");
29072: 
11855:   ++mUpdateCount;
11855: }
11855: 
11855: void
    1: nsCSSFrameConstructor::EndUpdate()
    1: {
    1:   if (mUpdateCount == 1) {
    1:     // This is the end of our last update.  Before we decrement
    1:     // mUpdateCount, recalc quotes and counters as needed.
    1: 
  550:     RecalcQuotesAndCounters();
  550:     NS_ASSERTION(mUpdateCount == 1, "Odd update count");
  550:   }
22957:   --mUpdateCount;
  550: }
  550: 
  550: void
  550: nsCSSFrameConstructor::RecalcQuotesAndCounters()
  550: {
    1:   if (mQuotesDirty) {
    1:     mQuotesDirty = PR_FALSE;
    1:     mQuoteList.RecalcAll();
    1:   }
    1: 
    1:   if (mCountersDirty) {
    1:     mCountersDirty = PR_FALSE;
    1:     mCounterManager.RecalcAll();
    1:   }
    1: 
    1:   NS_ASSERTION(!mQuotesDirty, "Quotes updates will be lost");
    1:   NS_ASSERTION(!mCountersDirty, "Counter updates will be lost");  
    1: }
    1: 
    1: void
26803: nsCSSFrameConstructor::WillDestroyFrameTree()
    1: {
    1: #if defined(DEBUG_dbaron_off)
    1:   mCounterManager.Dump();
    1: #endif
    1: 
    1:   mIsDestroyingFrameTree = PR_TRUE;
    1: 
    1:   // Prevent frame tree destruction from being O(N^2)
    1:   mQuoteList.Clear();
    1:   mCounterManager.Clear();
    1: 
    1:   // Cancel all pending re-resolves
    1:   mRestyleEvent.Revoke();
    1: }
    1: 
    1: //STATIC
    1: 
    1: // XXXbz I'd really like this method to go away. Once we have inline-block and
    1: // I can just use that for sized broken images, that can happen, maybe.
    1: void nsCSSFrameConstructor::GetAlternateTextFor(nsIContent*    aContent,
    1:                                                 nsIAtom*       aTag,  // content object's tag
    1:                                                 nsXPIDLString& aAltText)
    1: {
    1:   // The "alt" attribute specifies alternate text that is rendered
    1:   // when the image can not be displayed
    1: 
    1:   // If there's no "alt" attribute, and aContent is an input    
    1:   // element, then use the value of the "value" attribute
    1:   if (!aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::alt, aAltText) &&
    1:       nsGkAtoms::input == aTag) {
    1:     // If there's no "value" attribute either, then use the localized string 
    1:     // for "Submit" as the alternate text.
    1:     if (!aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::value, aAltText)) {
    1:       nsContentUtils::GetLocalizedString(nsContentUtils::eFORMS_PROPERTIES,
    1:                                          "Submit", aAltText);      
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::CreateContinuingOuterTableFrame(nsIPresShell*    aPresShell,
    1:                                                        nsPresContext*  aPresContext,
    1:                                                        nsIFrame*        aFrame,
    1:                                                        nsIFrame*        aParentFrame,
    1:                                                        nsIContent*      aContent,
    1:                                                        nsStyleContext*  aStyleContext,
    1:                                                        nsIFrame**       aContinuingFrame)
    1: {
    1:   nsIFrame* newFrame = NS_NewTableOuterFrame(aPresShell, aStyleContext);
    1: 
    1:   if (newFrame) {
    1:     newFrame->Init(aContent, aParentFrame, aFrame);
23395:     nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1: 
    1:     // Create a continuing inner table frame, and if there's a caption then
    1:     // replicate the caption
    1:     nsFrameItems  newChildFrames;
    1: 
    1:     nsIFrame* childFrame = aFrame->GetFirstChild(nsnull);
    1:     if (childFrame) {
    1:       nsIFrame* continuingTableFrame;
    1:       nsresult rv = CreateContinuingFrame(aPresContext, childFrame, newFrame,
    1:                                           &continuingTableFrame);
    1:       if (NS_FAILED(rv)) {
    1:         newFrame->Destroy();
    1:         *aContinuingFrame = nsnull;
    1:         return rv;
    1:       }
    1:       newChildFrames.AddChild(continuingTableFrame);
    1:       
    1:       NS_ASSERTION(!childFrame->GetNextSibling(),"there can be only one inner table frame");
    1:     }
    1: 
    1:     // Set the outer table's initial child list
30785:     newFrame->SetInitialChildList(nsnull, newChildFrames);
    1:     
    1:     *aContinuingFrame = newFrame;
    1:     return NS_OK;
    1:   }
    1:   else {
    1:     *aContinuingFrame = nsnull;
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::CreateContinuingTableFrame(nsIPresShell* aPresShell, 
    1:                                                   nsPresContext*  aPresContext,
    1:                                                   nsIFrame*        aFrame,
    1:                                                   nsIFrame*        aParentFrame,
    1:                                                   nsIContent*      aContent,
    1:                                                   nsStyleContext*  aStyleContext,
    1:                                                   nsIFrame**       aContinuingFrame)
    1: {
    1:   nsIFrame* newFrame = NS_NewTableFrame(aPresShell, aStyleContext);
    1: 
    1:   if (newFrame) {
    1:     newFrame->Init(aContent, aParentFrame, aFrame);
23395:     nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1: 
    1:     // Replicate any header/footer frames
    1:     nsFrameItems  childFrames;
    1:     nsIFrame* childFrame = aFrame->GetFirstChild(nsnull);
    1:     for ( ; childFrame; childFrame = childFrame->GetNextSibling()) {
    1:       // See if it's a header/footer, possibly wrapped in a scroll frame.
    1:       nsTableRowGroupFrame* rowGroupFrame =
    1:         nsTableFrame::GetRowGroupFrame(childFrame);
    1:       if (rowGroupFrame) {
    1:         // If the row group was continued, then don't replicate it.
    1:         nsIFrame* rgNextInFlow = rowGroupFrame->GetNextInFlow();
    1:         if (rgNextInFlow) {
    1:           rowGroupFrame->SetRepeatable(PR_FALSE);
    1:         }
    1:         else if (rowGroupFrame->IsRepeatable()) {        
    1:           // Replicate the header/footer frame.
    1:           nsTableRowGroupFrame*   headerFooterFrame;
    1:           nsFrameItems            childItems;
    1:           nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
    1:                                         GetAbsoluteContainingBlock(newFrame),
    1:                                         nsnull);
    1: 
 3233:           headerFooterFrame = static_cast<nsTableRowGroupFrame*>
 3233:                                          (NS_NewTableRowGroupFrame(aPresShell, rowGroupFrame->GetStyleContext()));
    1:           nsIContent* headerFooter = rowGroupFrame->GetContent();
    1:           headerFooterFrame->Init(headerFooter, newFrame, nsnull);
23352:           ProcessChildren(state, headerFooter, rowGroupFrame->GetStyleContext(),
23352:                           headerFooterFrame, PR_TRUE, childItems, PR_FALSE);
30785:           NS_ASSERTION(state.mFloatedItems.IsEmpty(), "unexpected floated element");
30785:           headerFooterFrame->SetInitialChildList(nsnull, childItems);
    1:           headerFooterFrame->SetRepeatable(PR_TRUE);
    1: 
    1:           // Table specific initialization
    1:           headerFooterFrame->InitRepeatedFrame(aPresContext, rowGroupFrame);
    1: 
    1:           // XXX Deal with absolute and fixed frames...
    1:           childFrames.AddChild(headerFooterFrame);
    1:         }
    1:       }
    1:     }
    1:     
    1:     // Set the table frame's initial child list
30785:     newFrame->SetInitialChildList(nsnull, childFrames);
    1:     
    1:     *aContinuingFrame = newFrame;
    1:     return NS_OK;
    1:   }
    1:   else {
    1:     *aContinuingFrame = nsnull;
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::CreateContinuingFrame(nsPresContext* aPresContext,
    1:                                              nsIFrame*       aFrame,
    1:                                              nsIFrame*       aParentFrame,
    1:                                              nsIFrame**      aContinuingFrame,
    1:                                              PRBool          aIsFluid)
    1: {
    1:   nsIPresShell*              shell = aPresContext->PresShell();
    1:   nsStyleContext*            styleContext = aFrame->GetStyleContext();
    1:   nsIFrame*                  newFrame = nsnull;
    1:   nsresult                   rv = NS_OK;
    1:   nsIFrame*                  nextContinuation = aFrame->GetNextContinuation();
    1:   nsIFrame*                  nextInFlow = aFrame->GetNextInFlow();
    1: 
    1:   // Use the frame type to determine what type of frame to create
    1:   nsIAtom* frameType = aFrame->GetType();
    1:   nsIContent* content = aFrame->GetContent();
    1: 
    1:   NS_ASSERTION(aFrame->GetSplittableType() != NS_FRAME_NOT_SPLITTABLE,
    1:                "why CreateContinuingFrame for a non-splittable frame?");
    1:   
    1:   if (nsGkAtoms::textFrame == frameType) {
    1:     newFrame = NS_NewContinuingTextFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1:     }
    1:     
    1:   } else if (nsGkAtoms::inlineFrame == frameType) {
    1:     newFrame = NS_NewInlineFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1:     }
    1:   
    1:   } else if (nsGkAtoms::blockFrame == frameType) {
    1:     newFrame = NS_NewBlockFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
23167:     }
23167:   
23176: #ifdef MOZ_XUL
23176:   } else if (nsGkAtoms::XULLabelFrame == frameType) {
23947:     newFrame = NS_NewXULLabelFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
23167:     }
23176: #endif  
    1:   } else if (nsGkAtoms::columnSetFrame == frameType) {
    1:     newFrame = NS_NewColumnSetFrame(shell, styleContext, 0);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1:     }
    1:   
    1:   } else if (nsGkAtoms::positionedInlineFrame == frameType) {
    1:     newFrame = NS_NewPositionedInlineFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1:     }
    1: 
    1:   } else if (nsGkAtoms::pageFrame == frameType) {
18953:     nsIFrame* canvasFrame;
    1:     rv = ConstructPageFrame(shell, aPresContext, aParentFrame, aFrame,
18953:                             newFrame, canvasFrame);
    1:   } else if (nsGkAtoms::tableOuterFrame == frameType) {
    1:     rv = CreateContinuingOuterTableFrame(shell, aPresContext, aFrame, aParentFrame,
    1:                                          content, styleContext, &newFrame);
    1: 
    1:   } else if (nsGkAtoms::tableFrame == frameType) {
    1:     rv = CreateContinuingTableFrame(shell, aPresContext, aFrame, aParentFrame,
    1:                                     content, styleContext, &newFrame);
    1: 
    1:   } else if (nsGkAtoms::tableRowGroupFrame == frameType) {
    1:     newFrame = NS_NewTableRowGroupFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1:     }
    1: 
    1:   } else if (nsGkAtoms::tableRowFrame == frameType) {
    1:     newFrame = NS_NewTableRowFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1: 
    1:       // Create a continuing frame for each table cell frame
    1:       nsFrameItems  newChildList;
    1:       nsIFrame* cellFrame = aFrame->GetFirstChild(nsnull);
    1:       while (cellFrame) {
    1:         // See if it's a table cell frame
    1:         if (IS_TABLE_CELL(cellFrame->GetType())) {
    1:           nsIFrame* continuingCellFrame;
    1:           rv = CreateContinuingFrame(aPresContext, cellFrame, newFrame,
    1:                                      &continuingCellFrame);
    1:           if (NS_FAILED(rv)) {
30785:             newChildList.DestroyFrames();
    1:             newFrame->Destroy();
    1:             *aContinuingFrame = nsnull;
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:           }
    1:           newChildList.AddChild(continuingCellFrame);
    1:         }
    1:         cellFrame = cellFrame->GetNextSibling();
    1:       }
    1:       
    1:       // Set the table cell's initial child list
30785:       newFrame->SetInitialChildList(nsnull, newChildList);
    1:     }
    1: 
    1:   } else if (IS_TABLE_CELL(frameType)) {
 8578:     // Warning: If you change this and add a wrapper frame around table cell
 8578:     // frames, make sure Bug 368554 doesn't regress!
 8578:     // See IsInAutoWidthTableCellForQuirk() in nsImageFrame.cpp.
    1:     newFrame = NS_NewTableCellFrame(shell, styleContext, IsBorderCollapse(aParentFrame));
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1: 
    1:       // Create a continuing area frame
23296:       nsIFrame* continuingBlockFrame;
23176:       nsIFrame* blockFrame = aFrame->GetFirstChild(nsnull);
23176:       rv = CreateContinuingFrame(aPresContext, blockFrame, newFrame,
23296:                                  &continuingBlockFrame);
    1:       if (NS_FAILED(rv)) {
    1:         newFrame->Destroy();
    1:         *aContinuingFrame = nsnull;
    1:         return rv;
    1:       }
    1: 
    1:       // Set the table cell's initial child list
30790:       SetInitialSingleChild(newFrame, continuingBlockFrame);
    1:     }
    1:   
    1:   } else if (nsGkAtoms::lineFrame == frameType) {
    1:     newFrame = NS_NewFirstLineFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1:     }
    1:   
    1:   } else if (nsGkAtoms::letterFrame == frameType) {
    1:     newFrame = NS_NewFirstLetterFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1:     }
    1: 
    1:   } else if (nsGkAtoms::imageFrame == frameType) {
    1:     newFrame = NS_NewImageFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
    1:     }
 9869:   } else if (nsGkAtoms::imageControlFrame == frameType) {
 9869:     newFrame = NS_NewImageControlFrame(shell, styleContext);
 9869: 
 9869:     if (newFrame) {
 9869:       newFrame->Init(content, aParentFrame, aFrame);
 9869:     }    
    1:   } else if (nsGkAtoms::placeholderFrame == frameType) {
    1:     // create a continuing out of flow frame
    1:     nsIFrame* oofFrame = nsPlaceholderFrame::GetRealFrameForPlaceholder(aFrame);
    1:     nsIFrame* oofContFrame;
    1:     rv = CreateContinuingFrame(aPresContext, oofFrame, aParentFrame, &oofContFrame);
    1:     if (NS_FAILED(rv)) {
    1:       *aContinuingFrame = nsnull;
    1:       return rv;
    1:     }
    1:     // create a continuing placeholder frame
 6219:     rv = CreatePlaceholderFrameFor(shell, content, oofContFrame, styleContext,
 6219:                                    aParentFrame, aFrame, &newFrame);
    1:     if (NS_FAILED(rv)) {
    1:       oofContFrame->Destroy();
    1:       *aContinuingFrame = nsnull;
    1:       return rv;
    1:     }
    1:   } else if (nsGkAtoms::fieldSetFrame == frameType) {
    1:     newFrame = NS_NewFieldSetFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
    1: 
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1: 
    1:       // Create a continuing area frame
    1:       // XXXbz we really shouldn't have to do this by hand!
23296:       nsIFrame* continuingBlockFrame;
23176:       nsIFrame* blockFrame = GetFieldSetBlockFrame(aFrame);
23176:       rv = CreateContinuingFrame(aPresContext, blockFrame, newFrame,
23296:                                  &continuingBlockFrame);
    1:       if (NS_FAILED(rv)) {
    1:         newFrame->Destroy();
    1:         *aContinuingFrame = nsnull;
    1:         return rv;
    1:       }
    1:       // Set the fieldset's initial child list
30790:       SetInitialSingleChild(newFrame, continuingBlockFrame);
    1:     }
24414:   } else if (nsGkAtoms::legendFrame == frameType) {
24414:     newFrame = NS_NewLegendFrame(shell, styleContext);
24414: 
24414:     if (newFrame) {
24414:       newFrame->Init(content, aParentFrame, aFrame);
24414:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
24414:     }
    1:   } else {
    1:     NS_NOTREACHED("unexpected frame type");
    1:     *aContinuingFrame = nsnull;
    1:     return NS_ERROR_UNEXPECTED;
    1:   }
    1: 
    1:   *aContinuingFrame = newFrame;
    1: 
    1:   if (!newFrame) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   // Init() set newFrame to be a fluid continuation of aFrame.
    1:   // If we want a non-fluid continuation, we need to call SetPrevContinuation()
    1:   // to reset NS_FRAME_IS_FLUID_CONTINUATION.
    1:   if (!aIsFluid) {
    1:     newFrame->SetPrevContinuation(aFrame);
    1:   }
    1: 
    1:   // A continuation of generated content is also generated content
    1:   if (aFrame->GetStateBits() & NS_FRAME_GENERATED_CONTENT) {
    1:     newFrame->AddStateBits(NS_FRAME_GENERATED_CONTENT);
    1:   }
    1: 
 6521:   // A continuation of an out-of-flow is also an out-of-flow
 6521:   if (aFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
 6521:     newFrame->AddStateBits(NS_FRAME_OUT_OF_FLOW);
 6521:   }
 6521: 
    1:   if (nextInFlow) {
    1:     nextInFlow->SetPrevInFlow(newFrame);
    1:     newFrame->SetNextInFlow(nextInFlow);
    1:   } else if (nextContinuation) {
    1:     nextContinuation->SetPrevContinuation(newFrame);
    1:     newFrame->SetNextContinuation(nextContinuation);
    1:   }
32841: 
32841:   NS_POSTCONDITION(!newFrame->GetNextSibling(), "unexpected sibling");
    1:   return NS_OK;
    1: }
    1: 
 4347: nsresult
 4347: nsCSSFrameConstructor::ReplicateFixedFrames(nsPageContentFrame* aParentFrame)
 4347: {
18953:   // Now deal with fixed-pos things....  They should appear on all pages,
18953:   // so we want to move over the placeholders when processing the child
18953:   // of the pageContentFrame.
 4347: 
 4347:   nsIFrame* prevPageContentFrame = aParentFrame->GetPrevInFlow();
    1:   if (!prevPageContentFrame) {
 4347:     return NS_OK;
 4347:   }
18953:   nsIFrame* canvasFrame = aParentFrame->GetFirstChild(nsnull);
18953:   nsIFrame* prevCanvasFrame = prevPageContentFrame->GetFirstChild(nsnull);
18953:   if (!canvasFrame || !prevCanvasFrame) {
 4366:     // document's root element frame missing
    1:     return NS_ERROR_UNEXPECTED;
    1:   }
    1: 
    1:   nsFrameItems fixedPlaceholders;
    1:   nsIFrame* firstFixed = prevPageContentFrame->GetFirstChild(nsGkAtoms::fixedList);
    1:   if (!firstFixed) {
    1:     return NS_OK;
    1:   }
    1: 
 8933:   // Don't allow abs-pos descendants of the fixed content to escape the content.
 8933:   // This should not normally be possible (because fixed-pos elements should
 8933:   // be absolute containers) but fixed-pos tables currently aren't abs-pos
 8933:   // containers.
    1:   nsFrameConstructorState state(mPresShell, aParentFrame,
 8933:                                 nsnull,
24659:                                 mRootElementFrame);
    1: 
 4366:   // Iterate across fixed frames and replicate each whose placeholder is a
 4366:   // descendant of aFrame. (We don't want to explicitly copy placeholders that
 4366:   // are within fixed frames, because that would cause duplicates on the new
 4366:   // page - bug 389619)
    1:   for (nsIFrame* fixed = firstFixed; fixed; fixed = fixed->GetNextSibling()) {
 4366:     nsIFrame* prevPlaceholder = nsnull;
 4366:     mPresShell->GetPlaceholderFrameFor(fixed, &prevPlaceholder);
 4366:     if (prevPlaceholder &&
18953:         nsLayoutUtils::IsProperAncestorFrame(prevCanvasFrame, prevPlaceholder)) {
 4347:       nsresult rv = ConstructFrame(state, fixed->GetContent(),
18953:                                    canvasFrame, fixedPlaceholders);
 4347:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
 4366:   }
    1: 
    1:   // Add the placeholders to our primary child list.
18953:   // XXXbz this is a little screwed up, since the fixed frames will have 
18953:   // broken auto-positioning. Oh, well.
18953:   NS_ASSERTION(!canvasFrame->GetFirstChild(nsnull),
 4347:                "leaking frames; doc root continuation must be empty");
30785:   canvasFrame->SetInitialChildList(nsnull, fixedPlaceholders);
    1:   return NS_OK;
    1: }
    1: 
 6719: static PRBool
 6719: IsBindingAncestor(nsIContent* aContent, nsIContent* aBindingRoot)
 6719: {
 6719:   while (PR_TRUE) {
16126:     // Native-anonymous content doesn't contain insertion points, so
16126:     // we don't need to search through it.
16126:     if (aContent->IsRootOfNativeAnonymousSubtree())
16126:       return PR_FALSE;
 6719:     nsIContent* bindingParent = aContent->GetBindingParent();
 6719:     if (!bindingParent)
 6719:       return PR_FALSE;
 6719:     if (bindingParent == aBindingRoot)
 6719:       return PR_TRUE;
 6719:     aContent = bindingParent;
 6719:   }
 6719: }
 6719: 
    1: // Helper function that searches the immediate child frames 
    1: // (and their children if the frames are "special")
    1: // for a frame that maps the specified content object
    1: nsIFrame*
    1: nsCSSFrameConstructor::FindFrameWithContent(nsFrameManager*  aFrameManager,
    1:                                             nsIFrame*        aParentFrame,
    1:                                             nsIContent*      aParentContent,
    1:                                             nsIContent*      aContent,
    1:                                             nsFindFrameHint* aHint)
    1: {
25373:   NS_PRECONDITION(aParentFrame, "Must have a frame");
    1:   
    1: #ifdef NOISY_FINDFRAME
    1:   FFWC_totalCount++;
    1:   printf("looking for content=%p, given aParentFrame %p parentContent %p, hint is %s\n", 
    1:          aContent, aParentFrame, aParentContent, aHint ? "set" : "NULL");
    1: #endif
    1: 
25373:   // Search for the frame in each child list that aParentFrame supports.
    1:   nsIAtom* listName = nsnull;
    1:   PRInt32 listIndex = 0;
    1:   PRBool searchAgain;
    1: 
    1:   do {
    1: #ifdef NOISY_FINDFRAME
    1:     FFWC_doLoop++;
    1: #endif
    1:     nsIFrame* kidFrame = nsnull;
    1: 
    1:     searchAgain = PR_FALSE;
    1: 
    1:     // if we were given an hint, try to use it here to find a good
    1:     // previous frame to start our search (|kidFrame|).
    1:     if (aHint) {
    1: #ifdef NOISY_FINDFRAME
    1:       printf("  hint frame is %p\n", aHint->mPrimaryFrameForPrevSibling);
    1: #endif
    1:       // start with the primary frame for aContent's previous sibling
    1:       kidFrame = aHint->mPrimaryFrameForPrevSibling;
    1:       // But if it's out of flow, start from its placeholder.
    1:       if (kidFrame && (kidFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
    1:         kidFrame = aFrameManager->GetPlaceholderFrameFor(kidFrame);
    1:       }
    1: 
    1:       if (kidFrame) {
    1:         // then use the next sibling frame as our starting point
    1:         if (kidFrame->GetNextSibling()) {
    1:           kidFrame = kidFrame->GetNextSibling();
    1:         }
    1:         else {
    1:           // The hint frame had no next sibling. Try the next-in-flow or
    1:           // special sibling of the parent of the hint frame (or its
    1:           // associated placeholder).
    1:           nsIFrame *parentFrame = kidFrame->GetParent();
    1:           kidFrame = nsnull;
    1:           if (parentFrame) {
   94:             parentFrame = nsLayoutUtils::GetNextContinuationOrSpecialSibling(parentFrame);
    1:           }
    1:           if (parentFrame) {
    1:             // Found it, continue the search with its first child.
    1:             kidFrame = parentFrame->GetFirstChild(listName);
    1:             // Leave |aParentFrame| as-is, since the only time we'll
    1:             // reuse it is if the hint fails.
    1:           }
    1:         }
    1: #ifdef NOISY_FINDFRAME
    1:         printf("  hint gives us kidFrame=%p with parent frame %p content %p\n", 
    1:                kidFrame, aParentFrame, aParentContent);
    1: #endif
    1:       }
    1:     }
    1:     if (!kidFrame) {  // we didn't have enough info to prune, start searching from the beginning
    1:       kidFrame = aParentFrame->GetFirstChild(listName);
    1:     }
    1:     while (kidFrame) {
    1:       // See if the child frame points to the content object we're
    1:       // looking for
    1:       nsIContent* kidContent = kidFrame->GetContent();
    1:       if (kidContent == aContent) {
25373:         // We found a match.  Return the out-of-flow if it's a placeholder.
    1:         return nsPlaceholderFrame::GetRealFrameFor(kidFrame);
    1:       }
    1: 
    1:       // only do this if there is content
    1:       if (kidContent) {
    1:         // We search the immediate children only, but if the child frame has
    1:         // the same content pointer as its parent then we need to search its
    1:         // child frames, too.
    1:         // We also need to search if the child content is anonymous and scoped
    1:         // to the parent content.
16126:         // XXXldb What makes us continue the search once we're inside
16126:         // the anonymous subtree?
    1:         if (aParentContent == kidContent ||
25373:             (aParentContent && IsBindingAncestor(kidContent, aParentContent))) {
    1: #ifdef NOISY_FINDFRAME
    1:           FFWC_recursions++;
    1:           printf("  recursing with new parent set to kidframe=%p, parentContent=%p\n", 
    1:                  kidFrame, aParentContent);
    1: #endif
    1:           nsIFrame* matchingFrame =
 8406:               FindFrameWithContent(aFrameManager,
 8406:                                    nsPlaceholderFrame::GetRealFrameFor(kidFrame),
    1:                                    aParentContent, aContent, nsnull);
    1: 
    1:           if (matchingFrame) {
    1:             return matchingFrame;
    1:           }
    1:         }
    1:       }
    1: 
    1:       kidFrame = kidFrame->GetNextSibling();
25373: 
    1: #ifdef NOISY_FINDFRAME
25373:       if (kidFrame) {
    1:         FFWC_doSibling++;
    1:         printf("  searching sibling frame %p\n", kidFrame);
    1:       }
    1: #endif
    1:     }
    1: 
    1:     if (aHint) {
    1:       // If we get here, and we had a hint, then we didn't find a frame.
    1:       // The hint may have been a frame whose location in the frame tree
    1:       // doesn't match the location of its corresponding element in the
    1:       // DOM tree, e.g. a floated or absolutely positioned frame, or e.g.
    1:       // a <col> frame, in which case we'd be off in the weeds looking
    1:       // through something other than the primary frame list.
    1:       // Reboot the search from scratch, without the hint, but using the
    1:       // null child list again.
    1:       aHint = nsnull;
    1:       searchAgain = PR_TRUE;
25373:     }
25373:     else {
 8406:       do {
    1:         listName = aParentFrame->GetAdditionalChildListName(listIndex++);
 8406:       } while (IsOutOfFlowList(listName));
    1:     }
    1:   } while (listName || searchAgain);
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: // Request to find the primary frame associated with a given content object.
    1: // This is typically called by the pres shell when there is no mapping in
    1: // the pres shell hash table
    1: nsresult
    1: nsCSSFrameConstructor::FindPrimaryFrameFor(nsFrameManager*  aFrameManager,
    1:                                            nsIContent*      aContent,
    1:                                            nsIFrame**       aFrame,
    1:                                            nsFindFrameHint* aHint)
    1: {
    1:   NS_ASSERTION(aFrameManager && aContent && aFrame, "bad arg");
    1: 
    1:   *aFrame = nsnull;  // initialize OUT parameter 
    1: 
    1:   // We want to be able to quickly map from a content object to its frame,
    1:   // but we also want to keep the hash table small. Therefore, many frames
    1:   // are not added to the hash table when they're first created:
    1:   // - text frames
    1:   // - inline frames (often things like FONT and B)
    1:   // - BR frames
    1:   // - internal table frames (row-group, row, cell, col-group, col)
    1:   //
    1:   // That means we need to need to search for the frame
    1:   nsIFrame*              parentFrame;   // this pointer is used to iterate across all frames that map to parentContent
    1: 
    1:   // Get the frame that corresponds to the parent content object.
    1:   // Note that this may recurse indirectly, because the pres shell will
    1:   // call us back if there is no mapping in the hash table
    1:   nsCOMPtr<nsIContent> parentContent = aContent->GetParent(); // Get this once
    1:   if (parentContent) {
    1:     parentFrame = aFrameManager->GetPrimaryFrameFor(parentContent, -1);
    1:     while (parentFrame) {
    1:       // Search the child frames for a match
    1:       *aFrame = FindFrameWithContent(aFrameManager, parentFrame,
    1:                                      parentContent, aContent, aHint);
    1: #ifdef NOISY_FINDFRAME
    1:       printf("FindFrameWithContent returned %p\n", *aFrame);
    1: #endif
    1: 
    1: #ifdef DEBUG
    1:       // if we're given a hint and we were told to verify, then compare the resulting frame with
    1:       // the frame we get by calling FindFrameWithContent *without* the hint.  
    1:       // Assert if they do not match
    1:       // Note that this makes finding frames *slower* than it was before the fix.
25373:       if (gVerifyFastFindFrame && aHint) {
    1: #ifdef NOISY_FINDFRAME
    1:         printf("VERIFYING...\n");
    1: #endif
    1:         nsIFrame *verifyTestFrame =
    1:             FindFrameWithContent(aFrameManager, parentFrame,
    1:                                  parentContent, aContent, nsnull);
    1: #ifdef NOISY_FINDFRAME
    1:         printf("VERIFY returned %p\n", verifyTestFrame);
    1: #endif
    1:         NS_ASSERTION(verifyTestFrame == *aFrame, "hint shortcut found wrong frame");
    1:       }
    1: #endif
    1:       // If we found a match, then add a mapping to the hash table so
    1:       // next time this will be quick
    1:       if (*aFrame) {
    1:         aFrameManager->SetPrimaryFrameFor(aContent, *aFrame);
    1:         break;
    1:       }
25373: 
25373:       // We didn't find a matching frame. If parentFrame has a next-in-flow
25373:       // or special sibling, then continue looking there.
25373:       parentFrame = nsLayoutUtils::GetNextContinuationOrSpecialSibling(parentFrame);
    1: #ifdef NOISY_FINDFRAME
25373:       if (parentFrame) {
25373:         FFWC_nextInFlows++;
25373:         printf("  searching NIF frame %p\n", parentFrame);
25373:       }
25373: #endif
    1:     }
    1:   }
    1: 
    1: #ifdef NOISY_FINDFRAME
    1:   printf("%10s %10s %10s %10s %10s\n", 
25373:          "total", "doLoop", "doSibling", "recur", "nextIF");
    1:   printf("%10d %10d %10d %10d %10d\n", 
    1:          FFWC_totalCount, FFWC_doLoop, FFWC_doSibling, FFWC_recursions, 
25373:          FFWC_nextInFlows);
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::GetInsertionPoint(nsIFrame*     aParentFrame,
    1:                                          nsIContent*   aChildContent,
    1:                                          nsIFrame**    aInsertionPoint,
    1:                                          PRBool*       aMultiple)
    1: {
    1:   // Make the insertion point be the parent frame by default, in case
    1:   // we have to bail early.
    1:   *aInsertionPoint = aParentFrame;
    1: 
    1:   nsIContent* container = aParentFrame->GetContent();
    1:   if (!container)
    1:     return NS_OK;
    1: 
    1:   nsBindingManager *bindingManager = mDocument->BindingManager();
    1: 
    1:   nsIContent* insertionElement;
    1:   if (aChildContent) {
    1:     // We've got an explicit insertion child. Check to see if it's
    1:     // anonymous.
    1:     if (aChildContent->GetBindingParent() == container) {
    1:       // This child content is anonymous. Don't use the insertion
    1:       // point, since that's only for the explicit kids.
    1:       return NS_OK;
    1:     }
    1: 
    1:     PRUint32 index;
    1:     insertionElement = bindingManager->GetInsertionPoint(container,
    1:                                                          aChildContent,
    1:                                                          &index);
    1:   }
    1:   else {
    1:     PRBool multiple;
    1:     PRUint32 index;
    1:     insertionElement = bindingManager->GetSingleInsertionPoint(container,
    1:                                                                &index,
    1:                                                                &multiple);
    1:     if (multiple && aMultiple)
    1:       *aMultiple = multiple; // Record the fact that filters are in use.
    1:   }
    1: 
    1:   if (insertionElement) {
    1:     nsIFrame* insertionPoint = mPresShell->GetPrimaryFrameFor(insertionElement);
    1:     if (insertionPoint) {
    1:       // Use the content insertion frame of the insertion point.
    1:       insertionPoint = insertionPoint->GetContentInsertionFrame();
    1:       if (insertionPoint && insertionPoint != aParentFrame) 
    1:         GetInsertionPoint(insertionPoint, aChildContent, aInsertionPoint, aMultiple);
    1:     }
    1:     else {
    1:       // There was no frame created yet for the insertion point.
    1:       *aInsertionPoint = nsnull;
    1:     }
    1:   }
    1: 
    1:   // fieldsets have multiple insertion points.  Note that we might
    1:   // have to look at insertionElement here...
    1:   if (aMultiple && !*aMultiple) {
    1:     nsIContent* content = insertionElement ? insertionElement : container;
33329:     if (content->IsHTML() &&
    1:         content->Tag() == nsGkAtoms::fieldset) {
    1:       *aMultiple = PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // Capture state for the frame tree rooted at the frame associated with the
    1: // content object, aContent
    1: nsresult
    1: nsCSSFrameConstructor::CaptureStateForFramesOf(nsIContent* aContent,
    1:                                                nsILayoutHistoryState* aHistoryState)
    1: {
    1:   nsIFrame* frame = mPresShell->GetPrimaryFrameFor(aContent);
28215:   if (frame == mRootElementFrame) {
28215:     frame = mFixedContainingBlock;
28215:   }
    1:   if (frame) {
    1:     CaptureStateFor(frame, aHistoryState);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // Capture state for the frame tree rooted at aFrame.
    1: nsresult
    1: nsCSSFrameConstructor::CaptureStateFor(nsIFrame* aFrame,
    1:                                        nsILayoutHistoryState* aHistoryState)
    1: {
    1:   if (aFrame && aHistoryState) {
    1:     mPresShell->FrameManager()->CaptureFrameState(aFrame, aHistoryState);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::MaybeRecreateFramesForContent(nsIContent* aContent)
    1: {
    1:   nsresult result = NS_OK;
    1:   nsFrameManager *frameManager = mPresShell->FrameManager();
    1: 
    1:   nsStyleContext *oldContext = frameManager->GetUndisplayedContent(aContent);
    1:   if (oldContext) {
    1:     // The parent has a frame, so try resolving a new context.
    1:     nsRefPtr<nsStyleContext> newContext = mPresShell->StyleSet()->
    1:       ResolveStyleFor(aContent, oldContext->GetParent());
    1: 
    1:     frameManager->ChangeUndisplayedContent(aContent, newContext);
    1:     if (newContext->GetStyleDisplay()->mDisplay != NS_STYLE_DISPLAY_NONE) {
31031:       result = RecreateFramesForContent(aContent, PR_FALSE);
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
27311: static nsIFrame*
27311: FindFirstNonWhitespaceChild(nsIFrame* aParentFrame)
27311: {
27311:   nsIFrame* f = aParentFrame->GetFirstChild(nsnull);
27311:   while (f && f->GetType() == nsGkAtoms::textFrame &&
27311:          f->GetContent()->TextIsOnlyWhitespace()) {
27311:     f = f->GetNextSibling();
27311:   }
27311:   return f;
27311: }
27311: 
27311: static nsIFrame*
27311: FindNextNonWhitespaceSibling(nsIFrame* aFrame)
27311: {
27311:   nsIFrame* f = aFrame;
27311:   do {
27311:     f = f->GetNextSibling();
27311:   } while (f && f->GetType() == nsGkAtoms::textFrame &&
27311:            f->GetContent()->TextIsOnlyWhitespace());
27311:   return f;
27311: }
27311: 
    1: PRBool
26471: nsCSSFrameConstructor::MaybeRecreateContainerForFrameRemoval(nsIFrame* aFrame,
 4696:                                                              nsresult* aResult)
 4696: {
 4696:   NS_PRECONDITION(aFrame, "Must have a frame");
 4696:   NS_PRECONDITION(aFrame->GetParent(), "Frame shouldn't be root");
 4696:   NS_PRECONDITION(aResult, "Null out param?");
 4696:   NS_PRECONDITION(aFrame == aFrame->GetFirstContinuation(),
 4696:                   "aFrame not the result of GetPrimaryFrameFor()?");
 4696: 
 4696:   if (IsFrameSpecial(aFrame)) {
 4696:     // The removal functions can't handle removal of an {ib} split directly; we
 4696:     // need to rebuild the containing block.
    1: #ifdef DEBUG
    1:     if (gNoisyContentUpdates) {
26471:       printf("nsCSSFrameConstructor::MaybeRecreateContainerForFrameRemoval: "
 4696:              "frame=");
    1:       nsFrame::ListTag(stdout, aFrame);
    1:       printf(" is special\n");
    1:     }
    1: #endif
 4696: 
    1:     *aResult = ReframeContainingBlock(aFrame);
    1:     return PR_TRUE;
    1:   }
    1: 
29110:   if (aFrame->GetType() == nsGkAtoms::legendFrame &&
29110:       aFrame->GetParent()->GetType() == nsGkAtoms::fieldSetFrame) {
29110:     // When we remove the legend for a fieldset, we should reframe
29110:     // the fieldset to ensure another legend is used, if there is one
31031:     *aResult = RecreateFramesForContent(aFrame->GetParent()->GetContent(), PR_FALSE);
29110:     return PR_TRUE;
29110:   }
29110: 
26471:   // Now check for possibly needing to reconstruct due to a pseudo parent
26471:   nsIFrame* inFlowFrame =
26471:     (aFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) ?
26471:       mPresShell->FrameManager()->GetPlaceholderFrameFor(aFrame) : aFrame;
26471:   NS_ASSERTION(inFlowFrame, "How did that happen?");
26471:   nsIFrame* parent = inFlowFrame->GetParent();
26471:   if (IsTablePseudo(parent)) {
27311:     if (FindFirstNonWhitespaceChild(parent) == inFlowFrame ||
27311:         !FindNextNonWhitespaceSibling(inFlowFrame->GetLastContinuation()) ||
26471:         // If we're a table-column-group, then the GetFirstChild check above is
26471:         // not going to catch cases when we're the first child.
26471:         (inFlowFrame->GetType() == nsGkAtoms::tableColGroupFrame &&
26471:          parent->GetFirstChild(nsGkAtoms::colGroupList) == inFlowFrame) ||
26471:         // Similar if we're a table-caption.
26471:         (inFlowFrame->GetType() == nsGkAtoms::tableCaptionFrame &&
26471:          parent->GetFirstChild(nsGkAtoms::captionList) == inFlowFrame)) {
26471:       // We're the first or last frame in the pseudo.  Need to reframe.
26471:       // Good enough to recreate frames for |parent|'s content
31031:       *aResult = RecreateFramesForContent(parent->GetContent(), PR_TRUE);
26471:       return PR_TRUE;
26471:     }
26471:   }
26471: 
26607:   // Might need to reconstruct things if this frame's nextSibling is a table
26607:   // pseudo, since removal of this frame might mean that this pseudo needs to
26607:   // get merged with the frame's prevSibling.
26607:   // XXXbz it would be really nice if we had the prevSibling here too, to check
26607:   // whether this is in fact the case...
27866:   nsIFrame* nextSibling =
27866:     FindNextNonWhitespaceSibling(inFlowFrame->GetLastContinuation());
26607:   NS_ASSERTION(!IsTablePseudo(inFlowFrame), "Shouldn't happen here");
26607:   if (nextSibling && IsTablePseudo(nextSibling)) {
26607: #ifdef DEBUG
26607:     if (gNoisyContentUpdates) {
26607:       printf("nsCSSFrameConstructor::MaybeRecreateContainerForFrameRemoval: "
26607:              "frame=");
26607:       nsFrame::ListTag(stdout, aFrame);
26607:       printf(" has a table pseudo next sibling of different type\n");
26607:     }
26607: #endif
26607:     // Good enough to recreate frames for aFrame's parent's content; even if
26607:     // aFrame's parent is a table pseudo, that'll be the right content node.
31031:     *aResult = RecreateFramesForContent(parent->GetContent(), PR_TRUE);
26607:     return PR_TRUE;
26607:   }
26607: 
26471:   // We might still need to reconstruct things if the parent of inFlowFrame is
 4696:   // special, since in that case the removal of aFrame might affect the
 4696:   // splitting of its parent.
 4696:   if (!IsFrameSpecial(parent)) {
 4696:     return PR_FALSE;
 4696:   }
 4696: 
26471:   // If inFlowFrame is an inline, then it cannot possibly have caused the
26471:   // splitting.  If the frame is being reconstructed and being changed to a
26471:   // block, the ContentInserted call will handle the containing block reframe.
26471:   // So in this case, we don't need to reframe.
26471:   if (IsInlineOutside(inFlowFrame)) {
 4717:     return PR_FALSE;
 4717:   }
 4717: 
26332:   // If aFrame is not the first or last block, then removing it is not
26332:   // going to affect the splitting.
26471:   if (inFlowFrame != parent->GetFirstChild(nsnull) &&
26471:       inFlowFrame->GetLastContinuation()->GetNextSibling()) {
26332:     return PR_FALSE;
26332:   }
26332: 
 4696: #ifdef DEBUG
 5310:   if (gNoisyContentUpdates) {
26471:     printf("nsCSSFrameConstructor::MaybeRecreateContainerForFrameRemoval: "
 4696:            "frame=");
 4696:     nsFrame::ListTag(stdout, parent);
 4696:     printf(" is special\n");
 4696:   }
 4696: #endif
 4696: 
 4696:   *aResult = ReframeContainingBlock(parent);
 4696:   return PR_TRUE;
 4696: }
 4696:  
    1: nsresult
31031: nsCSSFrameConstructor::RecreateFramesForContent(nsIContent* aContent,
31031:                                                 PRBool aAsyncInsert)
    1: {
    1:   // If there is no document, we don't want to recreate frames for it.  (You
    1:   // shouldn't generally be giving this method content without a document
    1:   // anyway).
    1:   // Rebuilding the frame tree can have bad effects, especially if it's the
    1:   // frame tree for chrome (see bug 157322).
    1:   NS_ENSURE_TRUE(aContent->GetDocument(), NS_ERROR_FAILURE);
    1: 
    1:   // Is the frame `special'? If so, we need to reframe the containing
    1:   // block *here*, rather than trying to remove and re-insert the
    1:   // content (which would otherwise result in *two* nested reframe
    1:   // containing block from ContentRemoved() and ContentInserted(),
 4696:   // below!).  We'd really like to optimize away one of those
 4696:   // containing block reframes, hence the code here.
    1: 
    1:   nsIFrame* frame = mPresShell->GetPrimaryFrameFor(aContent);
 6862:   if (frame && frame->IsFrameOfType(nsIFrame::eMathML)) {
 6862:     // Reframe the topmost MathML element to prevent exponential blowup
 6862:     // (see bug 397518)
 6862:     while (PR_TRUE) {
 6862:       nsIContent* parentContent = aContent->GetParent();
 6862:       nsIFrame* parentContentFrame = mPresShell->GetPrimaryFrameFor(parentContent);
 6862:       if (!parentContentFrame || !parentContentFrame->IsFrameOfType(nsIFrame::eMathML))
 6862:         break;
 6862:       aContent = parentContent;
 6862:       frame = parentContentFrame;
 6862:     }
 6862:   }
    1: 
21943:   if (frame) {
21943:     nsIFrame* nonGeneratedAncestor = nsLayoutUtils::GetNonGeneratedAncestor(frame);
21943:     if (nonGeneratedAncestor->GetContent() != aContent) {
31031:       return RecreateFramesForContent(nonGeneratedAncestor->GetContent(), aAsyncInsert);
21943:     }
21943:   }
21943: 
    1:   nsresult rv = NS_OK;
    1: 
26471:   if (frame && MaybeRecreateContainerForFrameRemoval(frame, &rv)) {
    1:     return rv;
    1:   }
    1: 
28215:   nsINode* containerNode = aContent->GetNodeParent();
28215:   if (containerNode) {
    1:     // XXXbz what if this is anonymous content?
29501:     // XXXroc should we recreate frames for the container here instead?
28215:     PRInt32 indexInContainer = containerNode->IndexOf(aContent);
29501: 
    1:     // Before removing the frames associated with the content object,
    1:     // ask them to save their state onto a temporary state object.
    1:     CaptureStateForFramesOf(aContent, mTempFrameTreeState);
    1: 
28215:     // Need both parents, since we need to pass null to ContentInserted and
28215:     // ContentRemoved but want to use our real parent node for IndexOf.
28215:     nsCOMPtr<nsIContent> container = aContent->GetParent();
28215: 
    1:     // Remove the frames associated with the content object on which
    1:     // the attribute change occurred.
 7681:     PRBool didReconstruct;
29501:     rv = ContentRemoved(container, aContent, indexInContainer,
29501:                         REMOVE_FOR_RECONSTRUCTION, &didReconstruct);
 7681: 
 7681:     if (NS_SUCCEEDED(rv) && !didReconstruct) {
 7681:       // Now, recreate the frames associated with this content object. If
 7681:       // ContentRemoved triggered reconstruction, then we don't need to do this
 7681:       // because the frames will already have been built.
31031:       if (aAsyncInsert) {
31031:         PostRestyleEvent(aContent, nsReStyleHint(0), nsChangeHint_ReconstructFrame);
31031:       } else {
    1:         rv = ContentInserted(container, aContent,
 4696:                              indexInContainer, mTempFrameTreeState);
    1:       }
    1:     }
31031:   }
    1: 
    1: #ifdef ACCESSIBILITY
    1:   if (mPresShell->IsAccessibilityActive()) {
32336:     PRUint32 changeType;
    1:     if (frame) {
    1:       nsIFrame *newFrame = mPresShell->GetPrimaryFrameFor(aContent);
32336:       changeType = newFrame ? nsIAccessibilityService::FRAME_SIGNIFICANT_CHANGE :
32336:                               nsIAccessibilityService::FRAME_HIDE;
    1:     }
    1:     else {
32336:       changeType = nsIAccessibilityService::FRAME_SHOW;
    1:     }
    1: 
    1:     // A significant enough change occured that this part
    1:     // of the accessible tree is no longer valid.
    1:     nsCOMPtr<nsIAccessibilityService> accService = 
    1:       do_GetService("@mozilla.org/accessibilityService;1");
    1:     if (accService) {
32336:       accService->InvalidateSubtreeFor(mPresShell, aContent, changeType);
    1:     }
    1:   }
    1: #endif
    1: 
    1:   return rv;
    1: }
    1: 
    1: //////////////////////////////////////////////////////////////////////
    1: 
    1: // Block frame construction code
    1: 
    1: already_AddRefed<nsStyleContext>
    1: nsCSSFrameConstructor::GetFirstLetterStyle(nsIContent* aContent,
    1:                                            nsStyleContext* aStyleContext)
    1: {
    1:   if (aContent) {
    1:     return mPresShell->StyleSet()->
    1:       ResolvePseudoStyleFor(aContent,
    1:                             nsCSSPseudoElements::firstLetter, aStyleContext);
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: already_AddRefed<nsStyleContext>
    1: nsCSSFrameConstructor::GetFirstLineStyle(nsIContent* aContent,
    1:                                          nsStyleContext* aStyleContext)
    1: {
    1:   if (aContent) {
    1:     return mPresShell->StyleSet()->
    1:       ResolvePseudoStyleFor(aContent,
    1:                             nsCSSPseudoElements::firstLine, aStyleContext);
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: // Predicate to see if a given content (block element) has
    1: // first-letter style applied to it.
    1: PRBool
 1254: nsCSSFrameConstructor::ShouldHaveFirstLetterStyle(nsIContent* aContent,
    1:                                                   nsStyleContext* aStyleContext)
    1: {
    1:   return nsLayoutUtils::HasPseudoStyle(aContent, aStyleContext,
    1:                                        nsCSSPseudoElements::firstLetter,
    1:                                        mPresShell->GetPresContext());
    1: }
    1: 
    1: PRBool
 1254: nsCSSFrameConstructor::HasFirstLetterStyle(nsIFrame* aBlockFrame)
  551: {
  551:   NS_PRECONDITION(aBlockFrame, "Need a frame");
15909:   NS_ASSERTION(nsLayoutUtils::GetAsBlock(aBlockFrame),
  551:                "Not a block frame?");
  551: 
  551:   return (aBlockFrame->GetStateBits() & NS_BLOCK_HAS_FIRST_LETTER_STYLE) != 0;
  551: }
  551: 
  551: PRBool
 1254: nsCSSFrameConstructor::ShouldHaveFirstLineStyle(nsIContent* aContent,
    1:                                                 nsStyleContext* aStyleContext)
    1: {
16270:   PRBool hasFirstLine =
16270:     nsLayoutUtils::HasPseudoStyle(aContent, aStyleContext,
    1:                                   nsCSSPseudoElements::firstLine,
    1:                                   mPresShell->GetPresContext());
16270:   if (hasFirstLine) {
16270:     // But disable for fieldsets
16270:     PRInt32 namespaceID;
16270:     nsIAtom* tag = mDocument->BindingManager()->ResolveTag(aContent,
16270:                                                            &namespaceID);
23944:     // This check must match the one in FindHTMLData.
16270:     hasFirstLine = tag != nsGkAtoms::fieldset ||
16270:       (namespaceID != kNameSpaceID_XHTML &&
33329:        !aContent->IsHTML());
16270:   }
16274: 
16274:   return hasFirstLine;
    1: }
    1: 
    1: void
 1254: nsCSSFrameConstructor::ShouldHaveSpecialBlockStyle(nsIContent* aContent,
    1:                                                    nsStyleContext* aStyleContext,
    1:                                                    PRBool* aHaveFirstLetterStyle,
    1:                                                    PRBool* aHaveFirstLineStyle)
    1: {
    1:   *aHaveFirstLetterStyle =
 1254:     ShouldHaveFirstLetterStyle(aContent, aStyleContext);
    1:   *aHaveFirstLineStyle =
 1254:     ShouldHaveFirstLineStyle(aContent, aStyleContext);
    1: }
    1: 
26208: /* static */
26208: const nsCSSFrameConstructor::PseudoParentData
26208: nsCSSFrameConstructor::sPseudoParentData[eParentTypeCount] = {
26208:   { // Cell
26208:     FULL_CTOR_FCDATA(FCDATA_IS_TABLE_PART | FCDATA_SKIP_FRAMEMAP |
26208:                      FCDATA_USE_CHILD_ITEMS |
26208:                      FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeRow),
26208:                      &nsCSSFrameConstructor::ConstructTableCell),
26208:     &nsCSSAnonBoxes::tableCell
26208:   },
26208:   { // Row
26208:     FULL_CTOR_FCDATA(FCDATA_IS_TABLE_PART | FCDATA_SKIP_FRAMEMAP |
26208:                      FCDATA_USE_CHILD_ITEMS |
26208:                      FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeRowGroup),
26208:                      &nsCSSFrameConstructor::ConstructTableRow),
26208:     &nsCSSAnonBoxes::tableRow
26208:   },
26208:   { // Row group
26208:     FCDATA_DECL(FCDATA_IS_TABLE_PART | FCDATA_SKIP_FRAMEMAP |
26208:                 FCDATA_DISALLOW_OUT_OF_FLOW | FCDATA_USE_CHILD_ITEMS |
26776:                 FCDATA_SKIP_ABSPOS_PUSH |
26208:                 FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeTable),
26208:                 NS_NewTableRowGroupFrame),
26208:     &nsCSSAnonBoxes::tableRowGroup
26208:   },
26208:   { // Column group
26208:     FCDATA_DECL(FCDATA_IS_TABLE_PART | FCDATA_SKIP_FRAMEMAP |
26208:                 FCDATA_DISALLOW_OUT_OF_FLOW | FCDATA_USE_CHILD_ITEMS |
26776:                 FCDATA_SKIP_ABSPOS_PUSH |
26208:                 FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeTable),
26208:                 NS_NewTableColGroupFrame),
26208:     &nsCSSAnonBoxes::tableColGroup
26208:   },
26208:   { // Table
26208:     FULL_CTOR_FCDATA(FCDATA_SKIP_FRAMEMAP | FCDATA_USE_CHILD_ITEMS,
26208:                      &nsCSSFrameConstructor::ConstructTable),
26208:     &nsCSSAnonBoxes::table
26208:   }
26208: };
26208: 
26208: /*
26208:  * This function works as follows: we walk through the child list (aItems) and
26208:  * find items that cannot have aParentFrame as their parent.  We wrap
26208:  * continuous runs of such items into a FrameConstructionItem for a frame that
26208:  * gets them closer to their desired parents.  For example, a run of non-row
26208:  * children of a row-group will get wrapped in a row.  When we later construct
26208:  * the frame for this wrapper (in this case for the row), it'll be the correct
26208:  * parent for the cells in the set of items we wrapped or we'll wrap cells
26208:  * around everything else.  At the end of this method, aItems is guaranteed to
26208:  * contain only items for frames that can be direct kids of aParentFrame.
26208:  */
26208: nsresult
26208: nsCSSFrameConstructor::CreateNeededTablePseudos(FrameConstructionItemList& aItems,
26208:                                                 nsIFrame* aParentFrame)
26208: {
26208:   ParentType ourParentType = GetParentType(aParentFrame);
26208:   if (aItems.AllWantParentType(ourParentType)) {
26208:     // Nothing to do here
26208:     return NS_OK;
26208:   }
26208: 
26208:   FCItemIterator iter(aItems);
26208:   do {
27311:     if (iter.SkipItemsWantingParentType(ourParentType)) {
26208:       // Nothing else to do here; we're finished
26208:       return NS_OK;
26208:     }
26208: 
26208:     // Now we're pointing to the first child that wants a different parent
27311:     // type.
26208: 
26208:     // Now try to figure out what kids we can group together.  We can generally
26208:     // group everything that has a different desired parent type from us.  Two
26208:     // exceptions to this:
26208:     // 1) If our parent type is table, we can't group columns with anything
26208:     //    else other than whitespace.
27311:     // 2) Whitespace that lies between two things we can group which both want
27311:     //    a non-block parent should be dropped, even if we can't group them
27311:     //    with each other and even if the whitespace wants a parent of
27311:     //    ourParentType.  Ends of the list count as things that don't want a
27311:     //    block parent (so that for example we'll drop a whitespace-only list).
26208: 
26208:     FCItemIterator endIter(iter); /* iterator to find the end of the group */
26208:     ParentType groupingParentType = endIter.item().DesiredParentType();
27311:     if (aItems.AllWantParentType(groupingParentType) &&
27311:         groupingParentType != eTypeBlock) {
27311:       // Just group them all and be done with it.  We need the check for
27311:       // eTypeBlock here to catch the "all the items are whitespace" case
27311:       // described above.
27311:       endIter.SetToEnd();
27311:     } else {
27311:       // Locate the end of the group.
27311: 
27311:       // Keep track of the type the previous item wanted, in case we have to
27311:       // deal with whitespace.  Start it off with ourParentType, since that's
27311:       // the last thing |iter| would have skipped over.
27311:       ParentType prevParentType = ourParentType;
26208:       do {
27311:         /* Walk an iterator past any whitespace that we might be able to drop from the list */
27311:         FCItemIterator spaceEndIter(endIter);
27311:         if (prevParentType != eTypeBlock &&
27311:             !aParentFrame->IsGeneratedContentFrame() &&
27311:             spaceEndIter.item().IsWhitespace()) {
27311:           PRBool trailingSpaces = spaceEndIter.SkipWhitespace();
27311: 
27311:           // See whether we can drop the whitespace
27311:           if (trailingSpaces ||
27311:               spaceEndIter.item().DesiredParentType() != eTypeBlock) {
27311:             PRBool updateStart = (iter == endIter);
27311:             endIter.DeleteItemsTo(spaceEndIter);
27311:             NS_ASSERTION(trailingSpaces == endIter.IsDone(), "These should match");
27311: 
27311:             if (updateStart) {
27311:               iter = endIter;
27311:             }
27311: 
27311:             if (trailingSpaces) {
27311:               break; /* Found group end */
27311:             }
27311: 
27311:             if (updateStart) {
27311:               // Update groupingParentType, since it might have been eTypeBlock
27311:               // just because of the whitespace.
27311:               groupingParentType = iter.item().DesiredParentType();
27311:             }
27311:           }
27311:         }
27311: 
27311:         // Now endIter points to a non-whitespace item or a non-droppable
27311:         // whitespace item. In the latter case, if this is the end of the group
27311:         // we'll traverse this whitespace again.  But it'll all just be quick
27311:         // DesiredParentType() checks which will match ourParentType (that's
27311:         // what it means that this is the group end), so it's OK.
27311:         prevParentType = endIter.item().DesiredParentType();
27311:         if (prevParentType == ourParentType) {
27311:           // End the group at endIter.
26208:           break;
26208:         }
26208: 
26208:         if (ourParentType == eTypeTable &&
27311:             (prevParentType == eTypeColGroup) !=
26208:             (groupingParentType == eTypeColGroup)) {
26208:           // Either we started with columns and now found something else, or vice
26208:           // versa.  In any case, end the grouping.
26208:           break;
26208:         }
27311: 
27311:         // Include the whitespace we didn't drop (if any) in the group, since
27311:         // this is not the end of the group.  Note that this doesn't change
27311:         // prevParentType, since if we didn't drop the whitespace then we ended
27311:         // at something that wants a block parent.
27311:         endIter = spaceEndIter;
27311: 
27311:         endIter.Next();
27311:       } while (!endIter.IsDone());
27311:     }
27311: 
27311:     if (iter == endIter) {
27311:       // Nothing to wrap here; just skipped some whitespace
27311:       continue;
27311:     }
26208: 
26208:     // Now group together all the items between iter and endIter.  The right
26208:     // parent type to use depends on ourParentType.
26208:     ParentType wrapperType;
26208:     switch (ourParentType) {
26208:       case eTypeBlock:
26208:         wrapperType = eTypeTable;
26208:         break;
26208:       case eTypeRow:
26208:         // The parent type for a cell is eTypeBlock, since that's what a cell
26208:         // looks like to its kids.
26208:         wrapperType = eTypeBlock;
26208:         break;
26208:       case eTypeRowGroup:
26208:         wrapperType = eTypeRow;
26208:         break;
26208:       case eTypeTable:
26208:         // Either colgroup or rowgroup, depending on what we're grouping.
26208:         wrapperType = groupingParentType == eTypeColGroup ?
26208:           eTypeColGroup : eTypeRowGroup;
26208:         break;
26208:       default:
26208:         NS_NOTREACHED("Colgroups should be suppresing non-col child items");
26208:         break;
26208:     }
26208: 
26208:     const PseudoParentData& pseudoData = sPseudoParentData[wrapperType];
26208:     nsIAtom* pseudoType = *pseudoData.mPseudoType;
26208:     nsStyleContext* parentStyle = aParentFrame->GetStyleContext();
26208:     nsIContent* parentContent = aParentFrame->GetContent();
26208: 
26208:     if (pseudoType == nsCSSAnonBoxes::table &&
26208:         parentStyle->GetStyleDisplay()->mDisplay == NS_STYLE_DISPLAY_INLINE) {
26208:       pseudoType = nsCSSAnonBoxes::inlineTable;
26208:     }
26208: 
26208:     nsRefPtr<nsStyleContext> wrapperStyle =
26208:       mPresShell->StyleSet()->ResolvePseudoStyleFor(parentContent,
26208:                                                     pseudoType,
26208:                                                     parentStyle);
26208:     FrameConstructionItem* newItem =
26208:       new FrameConstructionItem(&pseudoData.mFCData,
26208:                                 // Use the content of our parent frame
26208:                                 parentContent,
26208:                                 // Lie about the tag; it doesn't matter anyway
26208:                                 pseudoType,
26208:                                 // The namespace does matter, however; it needs
26208:                                 // to match that of our first child item to
26208:                                 // match the old behavior
26208:                                 iter.item().mNameSpaceID,
29501:                                 -1,
26208:                                 wrapperStyle.forget());
26208: 
26208:     if (!newItem) {
26208:       return NS_ERROR_OUT_OF_MEMORY;
26208:     }
26208: 
26208:     // Here we're cheating a tad... technically, table-internal items should be
26208:     // inline if aParentFrame is inline, but they'll get wrapped in an
26208:     // inline-table in the end, so it'll all work out.  In any case, arguably
26208:     // we don't need to maintain this state at this point... but it's better
26208:     // to, I guess.
26208:     newItem->mIsAllInline = newItem->mHasInlineEnds =
26208:       newItem->mStyleContext->GetStyleDisplay()->IsInlineOutside();
26208: 
29501:     // Table pseudo frames always induce line boundaries around their
29501:     // contents.
29501:     newItem->mChildItems.SetLineBoundaryAtStart(PR_TRUE);
29501:     newItem->mChildItems.SetLineBoundaryAtEnd(PR_TRUE);
29501:     // The parent of the items in aItems is also the parent of the items
29501:     // in mChildItems
29501:     newItem->mChildItems.SetParentHasNoXBLChildren(
29501:       aItems.ParentHasNoXBLChildren());
29501: 
26208:     // Eat up all items between |iter| and |endIter| and put them in our wrapper
26208:     // Advances |iter| to point to |endIter|.
26208:     iter.AppendItemsToList(endIter, newItem->mChildItems);
26208: 
26208:     iter.InsertItem(newItem);
26208: 
26208:     // Now |iter| points to the item that was the first one we didn't wrap;
26208:     // loop and see whether we need to skip it or wrap it in something
26208:     // different.
26208:   } while (!iter.IsDone());
26208: 
26208:   return NS_OK;
26208: }
26208: 
25772: nsresult
25774: nsCSSFrameConstructor::ConstructFramesFromItemList(nsFrameConstructorState& aState,
25774:                                                    FrameConstructionItemList& aItems,
25772:                                                    nsIFrame* aParentFrame,
25772:                                                    nsFrameItems& aFrameItems)
25772: {
26208:   nsresult rv = CreateNeededTablePseudos(aItems, aParentFrame);
26208:   NS_ENSURE_SUCCESS(rv, rv);
26208: 
26208: #ifdef DEBUG
25774:   for (FCItemIterator iter(aItems); !iter.IsDone(); iter.Next()) {
26208:     NS_ASSERTION(iter.item().DesiredParentType() == GetParentType(aParentFrame),
26208:                  "Needed pseudos didn't get created; expect bad things");
26208:   }
26208: #endif
26208: 
26208:   for (FCItemIterator iter(aItems); !iter.IsDone(); iter.Next()) {
26208:     rv = ConstructFramesFromItem(aState, iter, aParentFrame, aFrameItems);
25772:     NS_ENSURE_SUCCESS(rv, rv);
25772:   }
25772: 
25772:   NS_ASSERTION(!aState.mHavePendingPopupgroup,
25772:                "Should have proccessed it by now");
25772: 
25772:   return NS_OK;
25772: }
25772: 
    1: /**
    1:  * Request to process the child content elements and create frames.
    1:  *
    1:  * @param   aContent the content object whose child elements to process
    1:  * @param   aFrame the frame associated with aContent. This will be the
    1:  *            parent frame (both content and geometric) for the flowed
    1:  *            child frames
    1:  */
    1: nsresult
    1: nsCSSFrameConstructor::ProcessChildren(nsFrameConstructorState& aState,
    1:                                        nsIContent*              aContent,
23352:                                        nsStyleContext*          aStyleContext,
    1:                                        nsIFrame*                aFrame,
25768:                                        const PRBool             aCanHaveGeneratedContent,
    1:                                        nsFrameItems&            aFrameItems,
25768:                                        const PRBool             aAllowBlockStyles)
23352: {
23352:   NS_PRECONDITION(aFrame, "Must have parent frame here");
23352:   NS_PRECONDITION(aFrame->GetContentInsertionFrame() == aFrame,
23352:                   "Parent frame in ProcessChildren should be its own "
23352:                   "content insertion frame");
23352: 
    1:   // XXXbz ideally, this would do all the pushing of various
    1:   // containing blocks as needed, so callers don't have to do it...
23343: 
23352:   PRBool haveFirstLetterStyle = PR_FALSE, haveFirstLineStyle = PR_FALSE;
23352:   if (aAllowBlockStyles) {
23352:     ShouldHaveSpecialBlockStyle(aContent, aStyleContext, &haveFirstLetterStyle,
23352:                                 &haveFirstLineStyle);
23352:   }
23352: 
23352:   // The logic here needs to match the logic in GetFloatContainingBlock()
23352:   nsFrameConstructorSaveState floatSaveState;
23352:   if (aFrame->IsFrameOfType(nsIFrame::eMathML) ||
23352:       aFrame->IsBoxFrame()) {
23352:     aState.PushFloatContainingBlock(nsnull, floatSaveState);
23352:   } else if (aFrame->IsFloatContainingBlock()) {
23352:     aState.PushFloatContainingBlock(aFrame, floatSaveState);
23352:   }
    1: 
25774:   FrameConstructionItemList itemsToConstruct;
25768:   nsresult rv = NS_OK;
25768: 
29501:   // If we have first-letter or first-line style then frames can get
29501:   // moved around so don't set these flags.
29501:   if (aAllowBlockStyles && !haveFirstLetterStyle && !haveFirstLineStyle) {
29501:     itemsToConstruct.SetLineBoundaryAtStart(PR_TRUE);
29501:     itemsToConstruct.SetLineBoundaryAtEnd(PR_TRUE);
29501:   }
29501: 
25811:   // Create any anonymous frames we need here.  This must happen before the
25811:   // non-anonymous children are processed to ensure that popups are never
25811:   // constructed before the popupset.
25768:   nsAutoTArray<nsIContent*, 4> anonymousItems;
25768:   GetAnonymousContent(aContent, aFrame, anonymousItems);
25768:   for (PRUint32 i = 0; i < anonymousItems.Length(); ++i) {
25768: #ifdef DEBUG
25768:     nsIAnonymousContentCreator* creator = do_QueryFrame(aFrame);
25768:     NS_ASSERTION(!creator || !creator->CreateFrameFor(anonymousItems[i]),
25768:                  "If you need to use CreateFrameFor, you need to call "
25768:                  "CreateAnonymousFrames manually and not follow the standard "
25768:                  "ProcessChildren() codepath for this frame");
25768: #endif
29501:     AddFrameConstructionItems(aState, anonymousItems[i], -1, aFrame,
25768:                               itemsToConstruct);
25768:   }
25768: 
33641:   if (!aFrame->IsLeaf()) {
23167:     // :before/:after content should have the same style context parent
23167:     // as normal kids.
23352:     // Note that we don't use this style context for looking up things like
23352:     // special block styles because in some cases involving table pseudo-frames
23352:     // it has nothing to do with the parent frame's desired behavior.
25768:     nsStyleContext* styleContext;
25768: 
25768:     if (aCanHaveGeneratedContent) {
25768:       styleContext =
23167:         nsFrame::CorrectStyleParentFrame(aFrame, nsnull)->GetStyleContext();
16976:       // Probe for generated content before
25768:       CreateGeneratedContentItem(aState, aFrame, aContent,
16976:                                  styleContext, nsCSSPseudoElements::before,
25768:                                  itemsToConstruct);
16976:     }
16976: 
    1:     ChildIterator iter, last;
    1:     for (ChildIterator::Init(aContent, &iter, &last);
    1:          iter != last;
    1:          ++iter) {
29501:       PRInt32 i = iter.XBLInvolved() ? -1 : iter.position();
29501:       AddFrameConstructionItems(aState, *iter, i, aFrame, itemsToConstruct);
29501:     }
29501:     itemsToConstruct.SetParentHasNoXBLChildren(!iter.XBLInvolved());
    1: 
16976:     if (aCanHaveGeneratedContent) {
16976:       // Probe for generated content after
25768:       CreateGeneratedContentItem(aState, aFrame, aContent,
16976:                                  styleContext, nsCSSPseudoElements::after,
25768:                                  itemsToConstruct);
25768:     }
25768:   }
25768: 
25774:   rv = ConstructFramesFromItemList(aState, itemsToConstruct, aFrame,
16976:                                    aFrameItems);
25768:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
23352:   NS_ASSERTION(!aAllowBlockStyles || !aFrame->IsBoxFrame(),
22859:                "can't be both block and box");
22859: 
23352:   if (haveFirstLetterStyle) {
23461:     rv = WrapFramesInFirstLetterFrame(aContent, aFrame, aFrameItems);
23167:   }
23352:   if (haveFirstLineStyle) {
30788:     rv = WrapFramesInFirstLineFrame(aState, aContent, aFrame, nsnull,
30788:                                     aFrameItems);
    1:   }
    1: 
26208:   // We might end up with first-line frames that change
26208:   // AnyKidsNeedBlockParent() without changing itemsToConstruct, but that
26208:   // should never happen for cases whan aFrame->IsBoxFrame().
26208:   NS_ASSERTION(!haveFirstLineStyle || !aFrame->IsBoxFrame(),
26208:                "Shouldn't have first-line style if we're a box");
26208:   NS_ASSERTION(!aFrame->IsBoxFrame() ||
26208:                itemsToConstruct.AnyItemsNeedBlockParent() ==
30785:                  (AnyKidsNeedBlockParent(aFrameItems.FirstChild()) != nsnull),
26208:                "Something went awry in our block parent calculations");
26208: 
26208:   if (aFrame->IsBoxFrame() && itemsToConstruct.AnyItemsNeedBlockParent()) {
26208:     // XXXbz we could do this on the FrameConstructionItemList level,
26208:     // no?  And if we cared we could look through the item list
26208:     // instead of groveling through the framelist here..
30785:     nsIContent *badKid = AnyKidsNeedBlockParent(aFrameItems.FirstChild());
22859:     nsAutoString parentTag, kidTag;
22859:     aContent->Tag()->ToString(parentTag);
22859:     badKid->Tag()->ToString(kidTag);
22859:     const PRUnichar* params[] = { parentTag.get(), kidTag.get() };
22859:     nsStyleContext *frameStyleContext = aFrame->GetStyleContext();
22859:     const nsStyleDisplay *display = frameStyleContext->GetStyleDisplay();
22859:     const char *message =
22859:       (display->mDisplay == NS_STYLE_DISPLAY_INLINE_BOX)
22859:         ? "NeededToWrapXULInlineBox" : "NeededToWrapXUL";
22859:     nsContentUtils::ReportToConsole(nsContentUtils::eXUL_PROPERTIES,
22859:                                     message,
22859:                                     params, NS_ARRAY_LENGTH(params),
22859:                                     mDocument->GetDocumentURI(),
22859:                                     EmptyString(), 0, 0, // not useful
22859:                                     nsIScriptError::warningFlag,
22859:                                     "FrameConstructor");
22859: 
22859:     nsRefPtr<nsStyleContext> blockSC = mPresShell->StyleSet()->
22859:       ResolvePseudoStyleFor(aContent,
22859:                             nsCSSAnonBoxes::mozXULAnonymousBlock,
22859:                             frameStyleContext);
22859:     nsIFrame *blockFrame = NS_NewBlockFrame(mPresShell, blockSC);
23305:     // We might, in theory, want to set NS_BLOCK_FLOAT_MGR and
22859:     // NS_BLOCK_MARGIN_ROOT, but I think it's a bad idea given that
22859:     // a real block placed here wouldn't get those set on it.
22859: 
22859:     InitAndRestoreFrame(aState, aContent, aFrame, nsnull,
22859:                         blockFrame, PR_FALSE);
22859: 
22859:     NS_ASSERTION(!blockFrame->HasView(), "need to do view reparenting");
30785:     ReparentFrames(aState.mFrameManager, blockFrame, aFrameItems);
30785: 
30790:     blockFrame->SetInitialChildList(nsnull, aFrameItems);
30790:     NS_ASSERTION(aFrameItems.IsEmpty(), "How did that happen?");
30790:     aFrameItems.Clear();
22859:     aFrameItems.AddChild(blockFrame);
22859: 
22859:     aFrame->AddStateBits(NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK);
22859:   }
22859: 
    1:   return rv;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // Support for :first-line style
    1: 
    1: // Special routine to handle placing a list of frames into a block
    1: // frame that has first-line style. The routine ensures that the first
    1: // collection of inline frames end up in a first-line frame.
23461: // NOTE: aState may have containing block information related to a
23461: // different part of the frame tree than where the first line occurs.
23461: // In particular aState may be set up for where ContentInserted or
23461: // ContentAppended is inserting content, which may be some
23461: // non-first-in-flow continuation of the block to which the first-line
23461: // belongs. So this function needs to be careful about how it uses
23461: // aState.
    1: nsresult
    1: nsCSSFrameConstructor::WrapFramesInFirstLineFrame(
    1:   nsFrameConstructorState& aState,
    1:   nsIContent*              aBlockContent,
    1:   nsIFrame*                aBlockFrame,
30788:   nsIFrame*                aLineFrame,
    1:   nsFrameItems&            aFrameItems)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
30788:   // Find the part of aFrameItems that we want to put in the first-line
30788:   nsFrameList::FrameLinkEnumerator link(aFrameItems);
30788:   while (!link.AtEnd() && IsInlineOutside(link.NextFrame())) {
30788:     link.Next();
30788:   }
30788: 
32843:   nsFrameList firstLineChildren = aFrameItems.ExtractHead(link);
30788: 
30788:   if (firstLineChildren.IsEmpty()) {
30788:     // Nothing is supposed to go into the first-line; nothing to do
30788:     return NS_OK;
30788:   }
30788: 
30788:   if (!aLineFrame) {
    1:     // Create line frame
 7706:     nsStyleContext* parentStyle =
 7706:       nsFrame::CorrectStyleParentFrame(aBlockFrame,
 7706:                                        nsCSSPseudoElements::firstLine)->
 7706:         GetStyleContext();
    1:     nsRefPtr<nsStyleContext> firstLineStyle = GetFirstLineStyle(aBlockContent,
    1:                                                                 parentStyle);
    1: 
30788:     aLineFrame = NS_NewFirstLineFrame(mPresShell, firstLineStyle);
30788: 
30788:     if (aLineFrame) {
    1:       // Initialize the line frame
    1:       rv = InitAndRestoreFrame(aState, aBlockContent, aBlockFrame, nsnull,
30788:                                aLineFrame);
    1: 
    1:       // The lineFrame will be the block's first child; the rest of the
    1:       // frame list (after lastInlineFrame) will be the second and
30788:       // subsequent children; insert lineFrame into aFrameItems.
30788:       aFrameItems.InsertFrame(nsnull, nsnull, aLineFrame);
30788: 
30788:       NS_ASSERTION(aLineFrame->GetStyleContext() == firstLineStyle,
30788:                    "Bogus style context on line frame");
30788:     }
30788:   }
30788: 
30788:   if (aLineFrame) {
    1:     // Give the inline frames to the lineFrame <b>after</b> reparenting them
30788:     ReparentFrames(aState.mFrameManager, aLineFrame, firstLineChildren);
30788:     if (aLineFrame->GetChildList(nsnull).IsEmpty() &&
30788:         (aLineFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
30788:       aLineFrame->SetInitialChildList(nsnull, firstLineChildren);
30788:     } else {
30941:       aState.mFrameManager->AppendFrames(aLineFrame, nsnull, firstLineChildren);
30788:     }
    1:   }
    1:   else {
    1:     rv = NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: // Special routine to handle appending a new frame to a block frame's
    1: // child list. Takes care of placing the new frame into the right
    1: // place when first-line style is present.
    1: nsresult
    1: nsCSSFrameConstructor::AppendFirstLineFrames(
    1:   nsFrameConstructorState& aState,
    1:   nsIContent*              aBlockContent,
    1:   nsIFrame*                aBlockFrame,
    1:   nsFrameItems&            aFrameItems)
    1: {
    1:   // It's possible that aBlockFrame needs to have a first-line frame
    1:   // created because it doesn't currently have any children.
30788:   const nsFrameList& blockKids = aBlockFrame->GetChildList(nsnull);
30788:   if (blockKids.IsEmpty()) {
    1:     return WrapFramesInFirstLineFrame(aState, aBlockContent,
30788:                                       aBlockFrame, nsnull, aFrameItems);
    1:   }
    1: 
    1:   // Examine the last block child - if it's a first-line frame then
    1:   // appended frames need special treatment.
30788:   nsIFrame* lastBlockKid = blockKids.LastChild();
    1:   if (lastBlockKid->GetType() != nsGkAtoms::lineFrame) {
    1:     // No first-line frame at the end of the list, therefore there is
30788:     // an intervening block between any first-line frame the frames
    1:     // we are appending. Therefore, we don't need any special
    1:     // treatment of the appended frames.
30788:     return NS_OK;
30788:   }
30788: 
30788:   return WrapFramesInFirstLineFrame(aState, aBlockContent, aBlockFrame,
30788:                                     lastBlockKid, aFrameItems);
    1: }
    1: 
    1: // Special routine to handle inserting a new frame into a block
    1: // frame's child list. Takes care of placing the new frame into the
    1: // right place when first-line style is present.
    1: nsresult
    1: nsCSSFrameConstructor::InsertFirstLineFrames(
    1:   nsFrameConstructorState& aState,
    1:   nsIContent*              aContent,
    1:   nsIFrame*                aBlockFrame,
    1:   nsIFrame**               aParentFrame,
    1:   nsIFrame*                aPrevSibling,
    1:   nsFrameItems&            aFrameItems)
    1: {
    1:   nsresult rv = NS_OK;
30941:   // XXXbz If you make this method actually do something, check to
30941:   // make sure that the caller is passing what you expect.  In
30941:   // particular, which content is aContent?  And audit the rest of
30941:   // this code too; it makes bogus assumptions and may not build.
    1: #if 0
    1:   nsIFrame* parentFrame = *aParentFrame;
    1:   nsIFrame* newFrame = aFrameItems.childList;
 2829:   PRBool isInline = IsInlineOutside(newFrame);
    1: 
    1:   if (!aPrevSibling) {
    1:     // Insertion will become the first frame. Two cases: we either
    1:     // already have a first-line frame or we don't.
    1:     nsIFrame* firstBlockKid = aBlockFrame->GetFirstChild(nsnull);
    1:     if (firstBlockKid->GetType() == nsGkAtoms::lineFrame) {
    1:       // We already have a first-line frame
    1:       nsIFrame* lineFrame = firstBlockKid;
    1: 
    1:       if (isInline) {
    1:         // Easy case: the new inline frame will go into the lineFrame.
    1:         ReparentFrame(aState.mFrameManager, lineFrame, newFrame);
    1:         aState.mFrameManager->InsertFrames(lineFrame, nsnull, nsnull,
    1:                                            newFrame);
    1: 
    1:         // Since the frame is going into the lineFrame, don't let it
    1:         // go into the block too.
    1:         aFrameItems.childList = nsnull;
    1:         aFrameItems.lastChild = nsnull;
    1:       }
    1:       else {
    1:         // Harder case: We are about to insert a block level element
    1:         // before the first-line frame.
    1:         // XXX need a method to steal away frames from the line-frame
    1:       }
    1:     }
    1:     else {
    1:       // We do not have a first-line frame
    1:       if (isInline) {
    1:         // We now need a first-line frame to contain the inline frame.
    1:         nsIFrame* lineFrame = NS_NewFirstLineFrame(firstLineStyle);
    1:         if (!lineFrame) {
    1:           rv = NS_ERROR_OUT_OF_MEMORY;
    1:         }
    1: 
    1:         if (NS_SUCCEEDED(rv)) {
    1:           // Lookup first-line style context
 7706:           nsStyleContext* parentStyle =
 7706:             nsFrame::CorrectStyleParentFrame(aBlockFrame,
 7706:                                              nsCSSPseudoElements::firstLine)->
 7706:               GetStyleContext();
    1:           nsRefPtr<nsStyleContext> firstLineStyle =
    1:             GetFirstLineStyle(aContent, parentStyle);
    1: 
    1:           // Initialize the line frame
    1:           rv = InitAndRestoreFrame(aState, aContent, aBlockFrame,
    1:                                    nsnull, lineFrame);
    1: 
    1:           // Make sure the caller inserts the lineFrame into the
    1:           // blocks list of children.
    1:           aFrameItems.childList = lineFrame;
    1:           aFrameItems.lastChild = lineFrame;
    1: 
    1:           // Give the inline frames to the lineFrame <b>after</b>
    1:           // reparenting them
    1:           NS_ASSERTION(lineFrame->GetStyleContext() == firstLineStyle,
    1:                        "Bogus style context on line frame");
    1:           ReparentFrame(aPresContext, lineFrame, newFrame);
    1:           lineFrame->SetInitialChildList(nsnull, newFrame);
    1:         }
    1:       }
    1:       else {
    1:         // Easy case: the regular insertion logic can insert the new
    1:         // frame because it's a block frame.
    1:       }
    1:     }
    1:   }
    1:   else {
    1:     // Insertion will not be the first frame.
    1:     nsIFrame* prevSiblingParent = aPrevSibling->GetParent();
    1:     if (prevSiblingParent == aBlockFrame) {
    1:       // Easy case: The prev-siblings parent is the block
    1:       // frame. Therefore the prev-sibling is not currently in a
    1:       // line-frame. Therefore the new frame which is going after it,
    1:       // regardless of type, is not going into a line-frame.
    1:     }
    1:     else {
    1:       // If the prevSiblingParent is not the block-frame then it must
    1:       // be a line-frame (if it were a letter-frame, that logic would
    1:       // already have adjusted the prev-sibling to be the
    1:       // letter-frame).
    1:       if (isInline) {
    1:         // Easy case: the insertion can go where the caller thinks it
    1:         // should go (which is into prevSiblingParent).
    1:       }
    1:       else {
    1:         // Block elements don't end up in line-frames, therefore
    1:         // change the insertion point to aBlockFrame. However, there
    1:         // might be more inline elements following aPrevSibling that
    1:         // need to be pulled out of the line-frame and become children
    1:         // of the block.
    1:         nsIFrame* nextSibling = aPrevSibling->GetNextSibling();
    1:         nsIFrame* nextLineFrame = prevSiblingParent->GetNextInFlow();
    1:         if (nextSibling || nextLineFrame) {
    1:           // Oy. We have work to do. Create a list of the new frames
    1:           // that are going into the block by stripping them away from
    1:           // the line-frame(s).
    1:           if (nextSibling) {
    1:             nsLineFrame* lineFrame = (nsLineFrame*) prevSiblingParent;
32841:             nsFrameList tail = lineFrame->StealFramesAfter(aPrevSibling);
32841:             // XXX do something with 'tail'
    1:           }
    1: 
    1:           nsLineFrame* nextLineFrame = (nsLineFrame*) lineFrame;
    1:           for (;;) {
    1:             nextLineFrame = nextLineFrame->GetNextInFlow();
    1:             if (!nextLineFrame) {
    1:               break;
    1:             }
    1:             nsIFrame* kids = nextLineFrame->GetFirstChild(nsnull);
    1:           }
    1:         }
    1:         else {
    1:           // We got lucky: aPrevSibling was the last inline frame in
    1:           // the line-frame.
    1:           ReparentFrame(aState.mFrameManager, aBlockFrame, newFrame);
    1:           aState.mFrameManager->InsertFrames(aBlockFrame, nsnull,
    1:                                              prevSiblingParent, newFrame);
    1:           aFrameItems.childList = nsnull;
    1:           aFrameItems.lastChild = nsnull;
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1: #endif
    1:   return rv;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // First-letter support
    1: 
    1: // Determine how many characters in the text fragment apply to the
    1: // first letter
    1: static PRInt32
    1: FirstLetterCount(const nsTextFragment* aFragment)
    1: {
    1:   PRInt32 count = 0;
    1:   PRInt32 firstLetterLength = 0;
    1:   PRBool done = PR_FALSE;
    1: 
    1:   PRInt32 i, n = aFragment->GetLength();
    1:   for (i = 0; i < n; i++) {
    1:     PRUnichar ch = aFragment->CharAt(i);
    1:     if (XP_IS_SPACE(ch)) {
    1:       if (firstLetterLength) {
    1:         done = PR_TRUE;
    1:         break;
    1:       }
    1:       count++;
    1:       continue;
    1:     }
    1:     // XXX I18n
    1:     if ((ch == '\'') || (ch == '\"')) {
    1:       if (firstLetterLength) {
    1:         done = PR_TRUE;
    1:         break;
    1:       }
    1:       // keep looping
    1:       firstLetterLength = 1;
    1:     }
    1:     else {
    1:       count++;
    1:       done = PR_TRUE;
    1:       break;
    1:     }
    1:   }
    1: 
    1:   return count;
    1: }
    1: 
    1: static PRBool
    1: NeedFirstLetterContinuation(nsIContent* aContent)
    1: {
    1:   NS_PRECONDITION(aContent, "null ptr");
    1: 
    1:   PRBool result = PR_FALSE;
    1:   if (aContent) {
    1:     const nsTextFragment* frag = aContent->GetText();
    1:     if (frag) {
    1:       PRInt32 flc = FirstLetterCount(frag);
    1:       PRInt32 tl = frag->GetLength();
    1:       if (flc < tl) {
    1:         result = PR_TRUE;
    1:       }
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: static PRBool IsFirstLetterContent(nsIContent* aContent)
    1: {
    1:   return aContent->TextLength() &&
    1:          !aContent->TextIsOnlyWhitespace();
    1: }
    1: 
    1: /**
    1:  * Create a letter frame, only make it a floating frame.
    1:  */
    1: void
    1: nsCSSFrameConstructor::CreateFloatingLetterFrame(
    1:   nsFrameConstructorState& aState,
    1:   nsIFrame* aBlockFrame,
    1:   nsIContent* aTextContent,
    1:   nsIFrame* aTextFrame,
    1:   nsIContent* aBlockContent,
    1:   nsIFrame* aParentFrame,
    1:   nsStyleContext* aStyleContext,
    1:   nsFrameItems& aResult)
    1: {
    1:   // Create the first-letter-frame
    1:   nsresult rv;
    1:   nsIFrame* letterFrame;
    1:   nsStyleSet *styleSet = mPresShell->StyleSet();
    1: 
    1:   letterFrame = NS_NewFirstLetterFrame(mPresShell, aStyleContext);
    1:   // We don't want to use a text content for a non-text frame (because we want
    1:   // its primary frame to be a text frame).  So use its parent for the
    1:   // first-letter.
    1:   nsIContent* letterContent = aTextContent->GetParent();
    1:   InitAndRestoreFrame(aState, letterContent,
    1:                       aState.GetGeometricParent(aStyleContext->GetStyleDisplay(),
    1:                                                 aParentFrame),
    1:                       nsnull, letterFrame);
    1: 
    1:   // Init the text frame to refer to the letter frame. Make sure we
    1:   // get a proper style context for it (the one passed in is for the
    1:   // letter frame and will have the float property set on it; the text
    1:   // frame shouldn't have that set).
    1:   nsRefPtr<nsStyleContext> textSC;
    1:   textSC = styleSet->ResolveStyleForNonElement(aStyleContext);
    1:   aTextFrame->SetStyleContextWithoutNotification(textSC);
    1:   InitAndRestoreFrame(aState, aTextContent, letterFrame, nsnull, aTextFrame);
    1: 
    1:   // And then give the text frame to the letter frame
30790:   SetInitialSingleChild(letterFrame, aTextFrame);
    1: 
    1:   // See if we will need to continue the text frame (does it contain
    1:   // more than just the first-letter text or not?) If it does, then we
    1:   // create (in advance) a continuation frame for it.
    1:   nsIFrame* nextTextFrame = nsnull;
    1:   if (NeedFirstLetterContinuation(aTextContent)) {
    1:     // Create continuation
    1:     rv = CreateContinuingFrame(aState.mPresContext, aTextFrame, aParentFrame,
    1:                                &nextTextFrame);
    1:     if (NS_FAILED(rv)) {
    1:       letterFrame->Destroy();
    1:       return;
    1:     }
    1:     // Repair the continuations style context
    1:     nsStyleContext* parentStyleContext = aStyleContext->GetParent();
    1:     if (parentStyleContext) {
    1:       nsRefPtr<nsStyleContext> newSC;
    1:       newSC = styleSet->ResolveStyleForNonElement(parentStyleContext);
    1:       if (newSC) {
    1:         nextTextFrame->SetStyleContext(newSC);
    1:       }
    1:     }
    1:   }
    1: 
30785:   NS_ASSERTION(aResult.IsEmpty(), "aResult should be an empty nsFrameItems!");
    1:   // Put the new float before any of the floats in the block we're
    1:   // doing first-letter for, that is, before any floats whose parent is aBlockFrame
30788:   nsFrameList::FrameLinkEnumerator link(aState.mFloatedItems);
30788:   while (!link.AtEnd() && link.NextFrame()->GetParent() != aBlockFrame) {
30788:     link.Next();
    1:   }
    1: 
 8199:   rv = aState.AddChild(letterFrame, aResult, letterContent, aStyleContext,
 8199:                        aParentFrame, PR_FALSE, PR_TRUE, PR_FALSE, PR_TRUE,
30788:                        link.PrevFrame());
    1: 
    1:   if (nextTextFrame) {
    1:     if (NS_FAILED(rv)) {
    1:       nextTextFrame->Destroy();
    1:     } else {
    1:       aResult.AddChild(nextTextFrame);
    1:     }
    1:   }
    1: }
    1: 
    1: /**
    1:  * Create a new letter frame for aTextFrame. The letter frame will be
    1:  * a child of aParentFrame.
    1:  */
    1: nsresult
23461: nsCSSFrameConstructor::CreateLetterFrame(nsIFrame* aBlockFrame,
    1:                                          nsIContent* aTextContent,
    1:                                          nsIFrame* aParentFrame,
    1:                                          nsFrameItems& aResult)
    1: {
    1:   NS_PRECONDITION(aTextContent->IsNodeOfType(nsINode::eTEXT),
    1:                   "aTextContent isn't text");
15909:   NS_ASSERTION(nsLayoutUtils::GetAsBlock(aBlockFrame),
  551:                  "Not a block frame?");
  551: 
    1:   // Get style context for the first-letter-frame
 7706:   nsStyleContext* parentStyleContext =
 7706:     nsFrame::CorrectStyleParentFrame(aParentFrame,
 7706:                                      nsCSSPseudoElements::firstLetter)->
 7706:       GetStyleContext();
23461: 
    1:   // Use content from containing block so that we can actually
    1:   // find a matching style rule.
23461:   nsIContent* blockContent = aBlockFrame->GetContent();
    1: 
    1:   // Create first-letter style rule
    1:   nsRefPtr<nsStyleContext> sc = GetFirstLetterStyle(blockContent,
    1:                                                     parentStyleContext);
    1:   if (sc) {
    1:     nsRefPtr<nsStyleContext> textSC;
    1:     textSC = mPresShell->StyleSet()->ResolveStyleForNonElement(sc);
    1:     
    1:     // Create a new text frame (the original one will be discarded)
    1:     // pass a temporary stylecontext, the correct one will be set later
    1:     nsIFrame* textFrame = NS_NewTextFrame(mPresShell, textSC);
    1: 
23461:     NS_ASSERTION(aBlockFrame == GetFloatContainingBlock(aParentFrame),
23461:                  "Containing block is confused");
23461:     nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
23461:                                   GetAbsoluteContainingBlock(aParentFrame),
23461:                                   aBlockFrame);
23461: 
    1:     // Create the right type of first-letter frame
    1:     const nsStyleDisplay* display = sc->GetStyleDisplay();
    1:     if (display->IsFloating()) {
    1:       // Make a floating first-letter frame
23461:       CreateFloatingLetterFrame(state, aBlockFrame, aTextContent, textFrame,
    1:                                 blockContent, aParentFrame,
    1:                                 sc, aResult);
    1:     }
    1:     else {
    1:       // Make an inflow first-letter frame
    1:       nsIFrame* letterFrame = NS_NewFirstLetterFrame(mPresShell, sc);
    1: 
    1:       if (letterFrame) {
    1:         // Initialize the first-letter-frame.  We don't want to use a text
    1:         // content for a non-text frame (because we want its primary frame to
    1:         // be a text frame).  So use its parent for the first-letter.
    1:         nsIContent* letterContent = aTextContent->GetParent();
    1:         letterFrame->Init(letterContent, aParentFrame, nsnull);
    1: 
23461:         InitAndRestoreFrame(state, aTextContent, letterFrame, nsnull,
    1:                             textFrame);
    1: 
30790:         SetInitialSingleChild(letterFrame, textFrame);
30785:         aResult.Clear();
30785:         aResult.AddChild(letterFrame);
 8759:         aBlockFrame->AddStateBits(NS_BLOCK_HAS_FIRST_LETTER_CHILD);
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::WrapFramesInFirstLetterFrame(
    1:   nsIContent*              aBlockContent,
    1:   nsIFrame*                aBlockFrame,
    1:   nsFrameItems&            aBlockFrames)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
  551:   aBlockFrame->AddStateBits(NS_BLOCK_HAS_FIRST_LETTER_STYLE);
  551: 
    1:   nsIFrame* parentFrame = nsnull;
    1:   nsIFrame* textFrame = nsnull;
    1:   nsIFrame* prevFrame = nsnull;
    1:   nsFrameItems letterFrames;
    1:   PRBool stopLooking = PR_FALSE;
23461:   rv = WrapFramesInFirstLetterFrame(aBlockFrame, aBlockFrame,
30785:                                     aBlockFrames.FirstChild(),
    1:                                     &parentFrame, &textFrame, &prevFrame,
    1:                                     letterFrames, &stopLooking);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1:   if (parentFrame) {
    1:     if (parentFrame == aBlockFrame) {
30785:       // Take textFrame out of the block's frame list and substitute the
    1:       // letter frame(s) instead.
33388:       aBlockFrames.DestroyFrame(textFrame);
30785:       aBlockFrames.InsertFrames(nsnull, prevFrame, letterFrames);
    1:     }
    1:     else {
30941:       // Take the old textFrame out of the inline parent's child list
23461:       ::DeletingFrameSubtree(mPresShell->FrameManager(), textFrame);
    1:       parentFrame->RemoveFrame(nsnull, textFrame);
    1: 
    1:       // Insert in the letter frame(s)
30941:       parentFrame->InsertFrames(nsnull, prevFrame, letterFrames);
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::WrapFramesInFirstLetterFrame(
    1:   nsIFrame*                aBlockFrame,
    1:   nsIFrame*                aParentFrame,
    1:   nsIFrame*                aParentFrameList,
    1:   nsIFrame**               aModifiedParent,
    1:   nsIFrame**               aTextFrame,
    1:   nsIFrame**               aPrevFrame,
    1:   nsFrameItems&            aLetterFrames,
    1:   PRBool*                  aStopLooking)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   nsIFrame* prevFrame = nsnull;
    1:   nsIFrame* frame = aParentFrameList;
    1: 
    1:   while (frame) {
    1:     nsIFrame* nextFrame = frame->GetNextSibling();
    1: 
16291:     nsIAtom* frameType = frame->GetType();
16291:     if (nsGkAtoms::textFrame == frameType) {
    1:       // Wrap up first-letter content in a letter frame
    1:       nsIContent* textContent = frame->GetContent();
    1:       if (IsFirstLetterContent(textContent)) {
    1:         // Create letter frame to wrap up the text
23461:         rv = CreateLetterFrame(aBlockFrame, textContent,
    1:                                aParentFrame, aLetterFrames);
    1:         if (NS_FAILED(rv)) {
    1:           return rv;
    1:         }
    1: 
    1:         // Provide adjustment information for parent
    1:         *aModifiedParent = aParentFrame;
    1:         *aTextFrame = frame;
    1:         *aPrevFrame = prevFrame;
    1:         *aStopLooking = PR_TRUE;
    1:         return NS_OK;
    1:       }
    1:     }
16291:     else if (IsInlineFrame(frame) && frameType != nsGkAtoms::brFrame) {
    1:       nsIFrame* kids = frame->GetFirstChild(nsnull);
23461:       WrapFramesInFirstLetterFrame(aBlockFrame, frame, kids,
    1:                                    aModifiedParent, aTextFrame,
    1:                                    aPrevFrame, aLetterFrames, aStopLooking);
    1:       if (*aStopLooking) {
    1:         return NS_OK;
    1:       }
    1:     }
    1:     else {
    1:       // This will stop us looking to create more letter frames. For
    1:       // example, maybe the frame-type is "letterFrame" or
    1:       // "placeholderFrame". This keeps us from creating extra letter
    1:       // frames, and also prevents us from creating letter frames when
    1:       // the first real content child of a block is not text (e.g. an
    1:       // image, hr, etc.)
    1:       *aStopLooking = PR_TRUE;
    1:       break;
    1:     }
    1: 
    1:     prevFrame = frame;
    1:     frame = nextFrame;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::RemoveFloatingFirstLetterFrames(
    1:   nsPresContext* aPresContext,
    1:   nsIPresShell* aPresShell,
    1:   nsFrameManager* aFrameManager,
    1:   nsIFrame* aBlockFrame,
    1:   PRBool* aStopLooking)
    1: {
    1:   // First look for the float frame that is a letter frame
    1:   nsIFrame* floatFrame = aBlockFrame->GetFirstChild(nsGkAtoms::floatList);
    1:   while (floatFrame) {
    1:     // See if we found a floating letter frame
    1:     if (nsGkAtoms::letterFrame == floatFrame->GetType()) {
    1:       break;
    1:     }
    1:     floatFrame = floatFrame->GetNextSibling();
    1:   }
    1:   if (!floatFrame) {
    1:     // No such frame
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Take the text frame away from the letter frame (so it isn't
    1:   // destroyed when we destroy the letter frame).
    1:   nsIFrame* textFrame = floatFrame->GetFirstChild(nsnull);
    1:   if (!textFrame) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Discover the placeholder frame for the letter frame
    1:   nsIFrame* parentFrame;
    1:   nsPlaceholderFrame* placeholderFrame = 
    1:     aFrameManager->GetPlaceholderFrameFor(floatFrame);
    1: 
    1:   if (!placeholderFrame) {
    1:     // Somethings really wrong
    1:     return NS_OK;
    1:   }
    1:   parentFrame = placeholderFrame->GetParent();
    1:   if (!parentFrame) {
    1:     // Somethings really wrong
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Create a new text frame with the right style context that maps
    1:   // all of the content that was previously part of the letter frame
    1:   // (and probably continued elsewhere).
    1:   nsStyleContext* parentSC = parentFrame->GetStyleContext();
    1:   if (!parentSC) {
    1:     return NS_OK;
    1:   }
    1:   nsIContent* textContent = textFrame->GetContent();
    1:   if (!textContent) {
    1:     return NS_OK;
    1:   }
    1:   nsRefPtr<nsStyleContext> newSC;
    1:   newSC = aPresShell->StyleSet()->ResolveStyleForNonElement(parentSC);
    1:   if (!newSC) {
    1:     return NS_OK;
    1:   }
    1:   nsIFrame* newTextFrame = NS_NewTextFrame(aPresShell, newSC);
    1:   if (NS_UNLIKELY(!newTextFrame)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;;
    1:   }
    1:   newTextFrame->Init(textContent, parentFrame, nsnull);
    1: 
    1:   // Destroy the old text frame's continuations (the old text frame
    1:   // will be destroyed when its letter frame is destroyed).
27214:   nsIFrame* frameToDelete = textFrame->GetLastContinuation();
27214:   while (frameToDelete != textFrame) {
27214:     nsIFrame* frameToDeleteParent = frameToDelete->GetParent();
27214:     nsIFrame* nextFrameToDelete = frameToDelete->GetPrevContinuation();
27214:     if (frameToDeleteParent) {
27214:       ::DeletingFrameSubtree(aFrameManager, frameToDelete);
27214:       aFrameManager->RemoveFrame(frameToDeleteParent, nsnull, frameToDelete);
27214:     }
27214:     frameToDelete = nextFrameToDelete;
    1:   }
    1: 
33388:   nsIFrame* prevSibling = placeholderFrame->GetPrevSibling();
    1: 
    1:   // Now that everything is set...
    1: #ifdef NOISY_FIRST_LETTER
    1:   printf("RemoveFloatingFirstLetterFrames: textContent=%p oldTextFrame=%p newTextFrame=%p\n",
    1:          textContent.get(), textFrame, newTextFrame);
    1: #endif
 4162: 
    1:   // Remove the float frame
    1:   ::DeletingFrameSubtree(aFrameManager, floatFrame);
    1:   aFrameManager->RemoveFrame(aBlockFrame, nsGkAtoms::floatList,
    1:                              floatFrame);
    1: 
    1:   // Remove placeholder frame
 4162:   ::DeletingFrameSubtree(aFrameManager, placeholderFrame);
    1:   aFrameManager->RemoveFrame(parentFrame, nsnull, placeholderFrame);
    1: 
    1:   // Insert text frame in its place
32846:   nsFrameList textList(newTextFrame, newTextFrame);
30941:   aFrameManager->InsertFrames(parentFrame, nsnull, prevSibling, textList);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::RemoveFirstLetterFrames(nsPresContext* aPresContext,
    1:                                                nsIPresShell* aPresShell,
    1:                                                nsFrameManager* aFrameManager,
    1:                                                nsIFrame* aFrame,
    1:                                                PRBool* aStopLooking)
    1: {
    1:   nsIFrame* prevSibling = nsnull;
    1:   nsIFrame* kid = aFrame->GetFirstChild(nsnull);
    1: 
    1:   while (kid) {
 4696:     if (nsGkAtoms::letterFrame == kid->GetType()) {
    1:       // Bingo. Found it. First steal away the text frame.
    1:       nsIFrame* textFrame = kid->GetFirstChild(nsnull);
    1:       if (!textFrame) {
    1:         break;
    1:       }
    1: 
    1:       // Create a new textframe
    1:       nsStyleContext* parentSC = aFrame->GetStyleContext();
    1:       if (!parentSC) {
    1:         break;
    1:       }
    1:       nsIContent* textContent = textFrame->GetContent();
    1:       if (!textContent) {
    1:         break;
    1:       }
    1:       nsRefPtr<nsStyleContext> newSC;
    1:       newSC = aPresShell->StyleSet()->ResolveStyleForNonElement(parentSC);
    1:       if (!newSC) {
    1:         break;
    1:       }
    1:       textFrame = NS_NewTextFrame(aPresShell, newSC);
    1:       textFrame->Init(textContent, aFrame, nsnull);
    1: 
    1:       // Next rip out the kid and replace it with the text frame
    1:       ::DeletingFrameSubtree(aFrameManager, kid);
    1:       aFrameManager->RemoveFrame(aFrame, nsnull, kid);
    1: 
    1:       // Insert text frame in its place
32846:       nsFrameList textList(textFrame, textFrame);
30941:       aFrameManager->InsertFrames(aFrame, nsnull, prevSibling, textList);
    1: 
    1:       *aStopLooking = PR_TRUE;
 8759:       aFrame->RemoveStateBits(NS_BLOCK_HAS_FIRST_LETTER_CHILD);
    1:       break;
    1:     }
 4696:     else if (IsInlineFrame(kid)) {
    1:       // Look inside child inline frame for the letter frame
    1:       RemoveFirstLetterFrames(aPresContext, aPresShell, aFrameManager, kid,
    1:                               aStopLooking);
    1:       if (*aStopLooking) {
    1:         break;
    1:       }
    1:     }
    1:     prevSibling = kid;
    1:     kid = kid->GetNextSibling();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::RemoveLetterFrames(nsPresContext* aPresContext,
    1:                                           nsIPresShell* aPresShell,
    1:                                           nsFrameManager* aFrameManager,
    1:                                           nsIFrame* aBlockFrame)
    1: {
 8324:   aBlockFrame = aBlockFrame->GetFirstContinuation();
 8324:   
    1:   PRBool stopLooking = PR_FALSE;
10280:   nsresult rv;
10280:   do {
10280:     rv = RemoveFloatingFirstLetterFrames(aPresContext, aPresShell,
    1:                                          aFrameManager,
    1:                                          aBlockFrame, &stopLooking);
    1:     if (NS_SUCCEEDED(rv) && !stopLooking) {
    1:       rv = RemoveFirstLetterFrames(aPresContext, aPresShell, aFrameManager,
    1:                                    aBlockFrame, &stopLooking);
    1:     }
10280:     if (stopLooking) {
10280:       break;
10280:     }
10280:     aBlockFrame = aBlockFrame->GetNextContinuation();
10280:   }  while (aBlockFrame);
    1:   return rv;
    1: }
    1: 
    1: // Fixup the letter frame situation for the given block
    1: nsresult
23461: nsCSSFrameConstructor::RecoverLetterFrames(nsIFrame* aBlockFrame)
    1: {
 8324:   aBlockFrame = aBlockFrame->GetFirstContinuation();
 8324:   
    1:   nsIFrame* parentFrame = nsnull;
    1:   nsIFrame* textFrame = nsnull;
    1:   nsIFrame* prevFrame = nsnull;
    1:   nsFrameItems letterFrames;
    1:   PRBool stopLooking = PR_FALSE;
10280:   nsresult rv;
10280:   do {
10280:     // XXX shouldn't this bit be set already (bug 408493), assert instead?
10280:     aBlockFrame->AddStateBits(NS_BLOCK_HAS_FIRST_LETTER_STYLE);
23461:     rv = WrapFramesInFirstLetterFrame(aBlockFrame, aBlockFrame,
10280:                                       aBlockFrame->GetFirstChild(nsnull),
    1:                                       &parentFrame, &textFrame, &prevFrame,
    1:                                       letterFrames, &stopLooking);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
10280:     if (stopLooking) {
10280:       break;
10280:     }
10280:     aBlockFrame = aBlockFrame->GetNextContinuation();
10280:   } while (aBlockFrame);
10280: 
    1:   if (parentFrame) {
    1:     // Take the old textFrame out of the parents child list
23461:     ::DeletingFrameSubtree(mPresShell->FrameManager(), textFrame);
    1:     parentFrame->RemoveFrame(nsnull, textFrame);
    1: 
    1:     // Insert in the letter frame(s)
30941:     parentFrame->InsertFrames(nsnull, prevFrame, letterFrames);
    1:   }
    1:   return rv;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // listbox Widget Routines
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::CreateListBoxContent(nsPresContext* aPresContext,
    1:                                             nsIFrame*       aParentFrame,
    1:                                             nsIFrame*       aPrevFrame,
    1:                                             nsIContent*     aChild,
    1:                                             nsIFrame**      aNewFrame,
    1:                                             PRBool          aIsAppend,
    1:                                             PRBool          aIsScrollbar,
    1:                                             nsILayoutHistoryState* aFrameState)
    1: {
    1: #ifdef MOZ_XUL
    1:   nsresult rv = NS_OK;
    1: 
    1:   // Construct a new frame
    1:   if (nsnull != aParentFrame) {
    1:     nsFrameItems            frameItems;
    1:     nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
    1:                                   GetAbsoluteContainingBlock(aParentFrame),
    1:                                   GetFloatContainingBlock(aParentFrame), 
    1:                                   mTempFrameTreeState);
    1: 
    1:     nsRefPtr<nsStyleContext> styleContext;
    1:     styleContext = ResolveStyleContext(aParentFrame, aChild);
    1: 
    1:     // Pre-check for display "none" - only if we find that, do we create
    1:     // any frame at all
    1:     const nsStyleDisplay* display = styleContext->GetStyleDisplay();
    1: 
    1:     if (NS_STYLE_DISPLAY_NONE == display->mDisplay) {
    1:       *aNewFrame = nsnull;
    1:       return NS_OK;
    1:     }
    1: 
 6737:     BeginUpdate();
 6737: 
25774:     FrameConstructionItemList items;
25771:     AddFrameConstructionItemsInternal(state, aChild, aParentFrame,
25771:                                       aChild->Tag(), aChild->GetNameSpaceID(),
29501:                                       -1, styleContext, ITEM_ALLOW_XBL_BASE,
25771:                                       items);
25774:     ConstructFramesFromItemList(state, items, aParentFrame, frameItems);
    1: 
30785:     nsIFrame* newFrame = frameItems.FirstChild();
    1:     *aNewFrame = newFrame;
    1: 
    1:     if (NS_SUCCEEDED(rv) && (nsnull != newFrame)) {
    1:       // Notify the parent frame
    1:       if (aIsAppend)
30941:         rv = ((nsListBoxBodyFrame*)aParentFrame)->ListBoxAppendFrames(frameItems);
    1:       else
30941:         rv = ((nsListBoxBodyFrame*)aParentFrame)->ListBoxInsertFrames(aPrevFrame, frameItems);
    1:     }
 6737: 
 6737:     EndUpdate();
    1:   }
    1: 
    1:   return rv;
    1: #else
    1:   return NS_ERROR_FAILURE;
    1: #endif
    1: }
    1: 
    1: //----------------------------------------
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructBlock(nsFrameConstructorState& aState,
    1:                                       const nsStyleDisplay*    aDisplay,
    1:                                       nsIContent*              aContent,
    1:                                       nsIFrame*                aParentFrame,
    1:                                       nsIFrame*                aContentParentFrame,
    1:                                       nsStyleContext*          aStyleContext,
    1:                                       nsIFrame**               aNewFrame,
    1:                                       nsFrameItems&            aFrameItems,
    1:                                       PRBool                   aAbsPosContainer)
    1: {
    1:   // Create column wrapper if necessary
    1:   nsIFrame* blockFrame = *aNewFrame;
    1:   nsIFrame* parent = aParentFrame;
    1:   nsRefPtr<nsStyleContext> blockStyle = aStyleContext;
    1:   const nsStyleColumn* columns = aStyleContext->GetStyleColumn();
    1: 
    1:   if (columns->mColumnCount != NS_STYLE_COLUMN_COUNT_AUTO
    1:       || columns->mColumnWidth.GetUnit() != eStyleUnit_Auto) {
    1:     nsIFrame* columnSetFrame = nsnull;
    1:     columnSetFrame = NS_NewColumnSetFrame(mPresShell, aStyleContext, 0);
    1:     if (!columnSetFrame) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     InitAndRestoreFrame(aState, aContent, aParentFrame, nsnull, columnSetFrame);
23395:     // See if we need to create a view
23395:     nsHTMLContainerFrame::CreateViewForFrame(columnSetFrame, PR_FALSE);
    1:     blockStyle = mPresShell->StyleSet()->
    1:       ResolvePseudoStyleFor(aContent, nsCSSAnonBoxes::columnContent,
    1:                             aStyleContext);
    1:     parent = columnSetFrame;
    1:     *aNewFrame = columnSetFrame;
    1: 
30790:     SetInitialSingleChild(columnSetFrame, blockFrame);
    1:   }
    1: 
    1:   blockFrame->SetStyleContextWithoutNotification(blockStyle);
    1:   InitAndRestoreFrame(aState, aContent, parent, nsnull, blockFrame);
    1: 
 8199:   nsresult rv = aState.AddChild(*aNewFrame, aFrameItems, aContent,
 8199:                                 aStyleContext,
    1:                                 aContentParentFrame ? aContentParentFrame :
    1:                                                       aParentFrame);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   // See if we need to create a view, e.g. the frame is absolutely positioned
23395:   nsHTMLContainerFrame::CreateViewForFrame(blockFrame, PR_FALSE);
    1: 
24659:   if (!mRootElementFrame) {
24659:     // The frame we're constructing will be the root element frame.
24659:     // Set mRootElementFrame before processing children.
24659:     mRootElementFrame = *aNewFrame;
20147:   }
20147: 
    1:   // We should make the outer frame be the absolute containing block,
    1:   // if one is required. We have to do this because absolute
    1:   // positioning must be computed with respect to the CSS dimensions
    1:   // of the element, which are the dimensions of the outer block. But
    1:   // we can't really do that because only blocks can have absolute
    1:   // children. So use the block and try to compensate with hacks
    1:   // in nsBlockFrame::CalculateContainingBlockSizeForAbsolutes.
    1:   nsFrameConstructorSaveState absoluteSaveState;
    1:   if (aAbsPosContainer) {
    1:     //    NS_ASSERTION(aRelPos, "should have made area frame for this");
    1:     aState.PushAbsoluteContainingBlock(blockFrame, absoluteSaveState);
    1:   }
    1: 
    1:   // Process the child content
    1:   nsFrameItems childItems;
23352:   rv = ProcessChildren(aState, aContent, aStyleContext, blockFrame, PR_TRUE,
23352:                        childItems, PR_TRUE);
    1: 
    1:   // Set the frame's initial child list
30785:   blockFrame->SetInitialChildList(nsnull, childItems);
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructInline(nsFrameConstructorState& aState,
25769:                                        FrameConstructionItem&   aItem,
    1:                                        nsIFrame*                aParentFrame,
25131:                                        const nsStyleDisplay*    aDisplay,
25131:                                        nsFrameItems&            aFrameItems,
25131:                                        nsIFrame**               aNewFrame)
25131: {
25769:   nsIContent* const content = aItem.mContent;
25769:   nsStyleContext* const styleContext = aItem.mStyleContext;
25769: 
25131:   nsIFrame *newFrame;
25131: 
25131:   PRBool positioned =
25131:     NS_STYLE_DISPLAY_INLINE == aDisplay->mDisplay &&
25131:     (NS_STYLE_POSITION_RELATIVE == aDisplay->mPosition ||
25131:      aDisplay->HasTransform());
25131:   if (positioned) {
25769:     newFrame = NS_NewPositionedInlineFrame(mPresShell, styleContext);
25131:   } else {
25769:     newFrame = NS_NewInlineFrame(mPresShell, styleContext);
25131:   }
25131: 
    1:   // Initialize the frame
25769:   InitAndRestoreFrame(aState, content, aParentFrame, nsnull, newFrame);
    1: 
    1:   nsFrameConstructorSaveState absoluteSaveState;  // definition cannot be inside next block
    1:                                                   // because the object's destructor is significant
    1:                                                   // this is part of the fix for bug 42372
    1: 
    1:   // Any inline frame might need a view (because of opacity, or fixed background)
25131:   nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
25131: 
25131:   if (positioned) {                            
    1:     // Relatively positioned frames becomes a container for child
    1:     // frames that are positioned
25131:     aState.PushAbsoluteContainingBlock(newFrame, absoluteSaveState);
    1:   }
    1: 
    1:   // Process the child content
    1:   nsFrameItems childItems;
26208:   nsresult rv = ConstructFramesFromItemList(aState, aItem.mChildItems, newFrame,
26208:                                             childItems);
25772:   if (NS_FAILED(rv)) {
25772:     // Clean up?
25772:     return rv;
25772:   }
25772: 
30789:   nsFrameList::FrameLinkEnumerator firstBlockEnumerator(childItems);
30789:   if (!aItem.mIsAllInline) {
30789:     FindFirstBlock(firstBlockEnumerator);
30789:   }
30789: 
30789:   if (aItem.mIsAllInline || firstBlockEnumerator.AtEnd()) { 
25772:     // This part is easy.  We either already know we have no non-inline kids,
25772:     // or haven't found any when constructing actual frames (the latter can
25772:     // happen only if out-of-flows that we thought had no containing block
25772:     // acquired one when ancestor inline frames and {ib} splits got
25772:     // constructed).  Just put all the kids into the single inline frame and
25772:     // bail.
30785:     newFrame->SetInitialChildList(nsnull, childItems);
25131:     if (NS_SUCCEEDED(rv)) {
25769:       aState.AddChild(newFrame, aFrameItems, content, styleContext, aParentFrame);
25131:       *aNewFrame = newFrame;
25131:     }
    1:     return rv;
    1:   }
    1: 
    1:   // This inline frame contains several types of children. Therefore
    1:   // this frame has to be chopped into several pieces. We will produce
    1:   // as a result of this 3 lists of children. The first list contains
    1:   // all of the inline children that precede the first block child
    1:   // (and may be empty). The second list contains all of the block
    1:   // children and any inlines that are between them (and must not be
    1:   // empty, otherwise - why are we here?). The final list contains all
    1:   // of the inline children that follow the final block child.
    1: 
30789:   // Grab the first inline's kids
32843:   nsFrameList firstInlineKids = childItems.ExtractHead(firstBlockEnumerator);
30789:   newFrame->SetInitialChildList(nsnull, firstInlineKids);
30789:                                              
30789:   // The kids between the first and last block belong to an anonymous block
30789:   // that we create right now. The anonymous block will be the parent of the
30789:   // block children of the inline.
    1:   nsIAtom* blockStyle;
    1:   nsRefPtr<nsStyleContext> blockSC;
    1:   nsIFrame* blockFrame;
25131:   if (positioned) {
    1:     blockStyle = nsCSSAnonBoxes::mozAnonymousPositionedBlock;
    1:     
    1:     blockSC = mPresShell->StyleSet()->
25769:       ResolvePseudoStyleFor(content, blockStyle, styleContext);
    1:   }
    1:   else {
    1:     blockStyle = nsCSSAnonBoxes::mozAnonymousBlock;
    1: 
    1:     blockSC = mPresShell->StyleSet()->
25769:       ResolvePseudoStyleFor(content, blockStyle, styleContext);
25129:   }
    1:   blockFrame = NS_NewBlockFrame(mPresShell, blockSC);
    1: 
25769:   InitAndRestoreFrame(aState, content, aParentFrame, nsnull, blockFrame, PR_FALSE);
    1: 
    1:   // Any inline frame could have a view (e.g., opacity)
23395:   nsHTMLContainerFrame::CreateViewForFrame(blockFrame, PR_FALSE);
    1: 
30789:   // Find the last block child which defines the end of our block kids and the
30789:   // start of our trailing inline's kids
30789:   nsFrameList::FrameLinkEnumerator lastBlock = FindLastBlock(childItems);
32843:   nsFrameList blockKids = childItems.ExtractHead(lastBlock);
30789: 
25131:   if (blockFrame->HasView() || newFrame->HasView()) {
30789:     // Move the block's child frames into the new view
30789:     nsHTMLContainerFrame::ReparentFrameViewList(aState.mPresContext, blockKids,
30789:                                                 newFrame, blockFrame);
30789:   }
30789: 
30790:   // Save the first frame in blockKids for the MoveChildrenTo call, since
30790:   // SetInitialChildList will empty blockKids.
30790:   nsIFrame* firstBlock = blockKids.FirstChild();
30789:   blockFrame->SetInitialChildList(nsnull, blockKids);
    1: 
    1:   nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
    1:                                 GetAbsoluteContainingBlock(blockFrame),
    1:                                 GetFloatContainingBlock(blockFrame));
    1: 
    1:   // If we have an inline between two blocks all inside an inline and the inner
    1:   // inline contains a float, the float will end up in the float list of the
    1:   // parent block of the inline, but its parent pointer will be the anonymous
    1:   // block we create...  AdjustFloatParentPtrs() deals with this by moving the
    1:   // float from the outer state |aState| to the inner |state|.
30790:   MoveChildrenTo(state.mFrameManager, blockFrame, firstBlock, nsnull,
30789:                  &state, &aState);
30789: 
30789:   // What's left in childItems belongs to our trailing inline frame
25738:   nsIFrame* inlineFrame;
25738:   if (positioned) {
25769:     inlineFrame = NS_NewPositionedInlineFrame(mPresShell, styleContext);
25738:   }
25738:   else {
25769:     inlineFrame = NS_NewInlineFrame(mPresShell, styleContext);
25769:   }
25769: 
25769:   InitAndRestoreFrame(aState, content, aParentFrame, nsnull, inlineFrame,
25738:                       PR_FALSE);
25738: 
25738:   // Any frame might need a view
25738:   nsHTMLContainerFrame::CreateViewForFrame(inlineFrame, PR_FALSE);
25738: 
30789:   if (childItems.NotEmpty()) {
30789:     MoveFramesToEndOfIBSplit(aState, inlineFrame, childItems, blockFrame,
30789:                              nsnull);
25738:   }
25738: 
25738:   // Mark the frames as special. That way if any of the append/insert/remove
 4696:   // methods try to fiddle with the children, the containing block will be
 4696:   // reframed instead.
25131:   SetFrameIsSpecial(newFrame, blockFrame);
    1:   SetFrameIsSpecial(blockFrame, inlineFrame);
25738:   SetFrameIsSpecial(inlineFrame, nsnull);
25131:   MarkIBSpecialPrevSibling(blockFrame, newFrame);
19125:   MarkIBSpecialPrevSibling(inlineFrame, blockFrame);
    1: 
    1: #ifdef DEBUG
    1:   if (gNoisyInlineConstruction) {
    1:     printf("nsCSSFrameConstructor::ConstructInline:\n");
31709:     if (*aNewFrame) {
    1:       printf("  ==> leading inline frame:\n");
31709:       (*aNewFrame)->List(stdout, 2);
31709:     }
31709:     if (blockFrame) {
    1:       printf("  ==> block frame:\n");
31709:       blockFrame->List(stdout, 2);
31709:     }
31709:     if (inlineFrame) {
    1:       printf("  ==> trailing inline frame:\n");
31709:       inlineFrame->List(stdout, 2);
    1:     }
    1:   }
    1: #endif
    1: 
25131:   if (NS_SUCCEEDED(rv)) {
25769:     aState.AddChild(newFrame, aFrameItems, content, styleContext, aParentFrame);
25131:     *aNewFrame = newFrame;
25131:   }
    1:   return rv;
    1: }
    1: 
25738: void
 4696: nsCSSFrameConstructor::MoveFramesToEndOfIBSplit(nsFrameConstructorState& aState,
 4696:                                                 nsIFrame* aExistingEndFrame,
32843:                                                 nsFrameList& aFramesToMove,
 4696:                                                 nsIFrame* aBlockPart,
 4696:                                                 nsFrameConstructorState* aTargetState)
 4696: {
25738:   NS_PRECONDITION(aBlockPart, "Must have a block part");
25738:   NS_PRECONDITION(aExistingEndFrame, "Must have trailing inline");
30789:   NS_PRECONDITION(aFramesToMove.NotEmpty(), "Must have frames to move");
30789: 
30789:   nsIFrame* newFirstChild = aFramesToMove.FirstChild();
30789:   if (aExistingEndFrame->HasView() ||
30789:       newFirstChild->GetParent()->HasView()) {
30789:     // Move the frames into the new view
 4696:     nsHTMLContainerFrame::ReparentFrameViewList(aState.mPresContext,
 4696:                                                 aFramesToMove,
30789:                                                 newFirstChild->GetParent(),
25738:                                                 aExistingEndFrame);
 4696:   }
 4696: 
30790:   // Reparent (cheaply) the child frames.  Have to grab the frame pointers
30790:   // for MoveChildrenTo now, since aFramesToMove will get cleared when we add
30790:   // the frames to aExistingEndFrame.  We already have newFirstChild.
25738:   nsIFrame* existingFirstChild = aExistingEndFrame->GetFirstChild(nsnull);
 5585:   if (!existingFirstChild &&
25738:       (aExistingEndFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
25738:     aExistingEndFrame->SetInitialChildList(nsnull, aFramesToMove);
 4696:   } else {
30941:     aExistingEndFrame->InsertFrames(nsnull, nsnull, aFramesToMove);
 4696:   }
 4696:   nsFrameConstructorState* startState = aTargetState ? &aState : nsnull;
30789:   MoveChildrenTo(aState.mFrameManager, aExistingEndFrame, newFirstChild,
 5585:                  existingFirstChild, aTargetState, startState);
 4696: }
 4696: 
25772: void
25772: nsCSSFrameConstructor::BuildInlineChildItems(nsFrameConstructorState& aState,
25772:                                              FrameConstructionItem& aParentItem)
25772: {
25772:   // XXXbz should we preallocate aParentItem.mChildItems to some sane
25772:   // length?  Maybe even to parentContent->GetChildCount()?
25772: 
    1:   // Probe for generated content before
25772:   nsStyleContext* const parentStyleContext = aParentItem.mStyleContext;
25772:   nsIContent* const parentContent = aParentItem.mContent;
25772:   CreateGeneratedContentItem(aState, nsnull, parentContent,
25772:                              parentStyleContext, nsCSSPseudoElements::before,
25772:                              aParentItem.mChildItems);
25772: 
    1:   ChildIterator iter, last;
25772:   for (ChildIterator::Init(parentContent, &iter, &last);
    1:        iter != last;
    1:        ++iter) {
25772:     // Manually check for comments/PIs, since we do't have a frame to pass to
25772:     // AddFrameConstructionItems.  We know our parent is a non-replaced inline,
25772:     // so there is no need to do the NeedFrameFor check.
25772:     nsIContent* content = *iter;
25772:     if (content->IsNodeOfType(nsINode::eCOMMENT) ||
25772:         content->IsNodeOfType(nsINode::ePROCESSING_INSTRUCTION)) {
25772:       continue;
25772:     }
25772: 
25772:     nsRefPtr<nsStyleContext> childContext =
25772:       ResolveStyleContext(parentStyleContext, content);
25772: 
29501:     PRInt32 i = iter.XBLInvolved() ? -1 : iter.position();
25772:     AddFrameConstructionItemsInternal(aState, content, nsnull, content->Tag(),
29501:                                       content->GetNameSpaceID(), i, childContext,
25772:                                       ITEM_ALLOW_XBL_BASE | ITEM_ALLOW_PAGE_BREAK,
25772:                                       aParentItem.mChildItems);
25772:   }
25772: 
25768:   // Probe for generated content after
25772:   CreateGeneratedContentItem(aState, nsnull, parentContent,
25772:                              parentStyleContext, nsCSSPseudoElements::after,
25772:                              aParentItem.mChildItems);
25772: 
25774:   aParentItem.mIsAllInline = aParentItem.mChildItems.AreAllItemsInline();
    1: }
    1: 
    1: PRBool
    1: nsCSSFrameConstructor::WipeContainingBlock(nsFrameConstructorState& aState,
    1:                                            nsIFrame* aContainingBlock,
    1:                                            nsIFrame* aFrame,
27311:                                            FrameConstructionItemList& aItems,
 4696:                                            PRBool aIsAppend,
 4696:                                            nsIFrame* aPrevSibling)
 4696: {
25774:   if (aItems.IsEmpty()) {
 4696:     return PR_FALSE;
 4696:   }
 4696:   
26607:   // Before we go and append the frames, we must check for three
 7189:   // special situations.
 7189: 
 7189:   // Situation #1 is a XUL frame that contains frames that are required
 7189:   // to be wrapped in blocks.
 7189:   if (aFrame->IsBoxFrame() &&
 7189:       !(aFrame->GetStateBits() & NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK) &&
25774:       aItems.AnyItemsNeedBlockParent()) {
31031:     RecreateFramesForContent(aFrame->GetContent(), PR_TRUE);
 7189:     return PR_TRUE;
 7189:   }
 7189: 
27311:   nsIFrame* nextSibling = ::GetInsertNextSibling(aFrame, aPrevSibling);
27311: 
26607:   // Situation #2 is a case when table pseudo-frames don't work out right
26607:   ParentType parentType = GetParentType(aFrame);
26607:   // If all the kids want a parent of the type that aFrame is, then we're all
26607:   // set to go.  Indeed, there won't be any table pseudo-frames created between
26607:   // aFrame and the kids, so those won't need to be merged with any table
26607:   // pseudo-frames that might already be kids of aFrame.  If aFrame itself is a
26607:   // table pseudo-frame, then all the kids in this list would have wanted a
26607:   // frame of that type wrapping them anyway, so putting them inside it is ok.
26607:   if (!aItems.AllWantParentType(parentType)) {
27311:     // Don't give up yet.  If parentType is not eTypeBlock and the parent is
27311:     // not a generated content frame, then try filtering whitespace out of the
27311:     // list.
27311:     if (parentType != eTypeBlock && !aFrame->IsGeneratedContentFrame()) {
27311:       // For leading whitespace followed by a kid that wants our parent type,
27311:       // there are four cases:
27311:       // 1) We have a previous sibling which is not a table pseudo.  That means
27311:       //    that previous sibling wanted a (non-block) parent of the type we're
27311:       //    looking at.  Then the whitespace comes between two table-internal
27311:       //    elements, so should be collapsed out.
27311:       // 2) We have a previous sibling which is a table pseudo.  It might have
27311:       //    kids who want this whitespace, so we need to reframe.
29838:       // 3) We have no previous sibling and our parent frame is not a table
29838:       //    pseudo.  That means that we'll be at the beginning of our actual
29838:       //    non-block-type parent, and the whitespace is OK to collapse out.
29838:       //    If something is ever inserted before us, it'll find our own parent
29838:       //    as its parent and if it's something that would care about the
29838:       //    whitespace it'll want a block parent, so it'll trigger a reframe at
29838:       //    that point.
29838:       // 4) We have no previous sibling and our parent frame is a table pseudo.
29838:       //    Need to reframe.
29838:       // All that is predicated on finding the correct previous sibling.  We
29838:       // might have to walk backwards along continuations from aFrame to do so.
27311:       //
27311:       // It's always OK to drop whitespace between any two items that want a
27311:       // parent of type parentType.
27311:       //
29838:       // For trailing whitespace preceded by a kid that wants our parent type,
29838:       // there are four cases:
29838:       // 1) We have a next sibling which is not a table pseudo.  That means
29838:       //    that next sibling wanted a (non-block) parent of the type we're
29838:       //    looking at.  Then the whitespace comes between two table-internal
29838:       //    elements, so should be collapsed out.
29838:       // 2) We have a next sibling which is a table pseudo.  It might have
29838:       //    kids who want this whitespace, so we need to reframe.
29838:       // 3) We have no next sibling and our parent frame is not a table
29838:       //    pseudo.  That means that we'll be at the end of our actual
29838:       //    non-block-type parent, and the whitespace is OK to collapse out.
29838:       //    If something is ever inserted after us, it'll find our own parent
29838:       //    as its parent and if it's something that would care about the
29838:       //    whitespace it'll want a block parent, so it'll trigger a reframe at
29838:       //    that point.
29838:       // 4) We have no next sibling and our parent frame is a table pseudo.
29838:       //    Need to reframe.
29838:       // All that is predicated on finding the correct next sibling.  We might
29838:       // have to walk forward along continuations from aFrame to do so.  That
29838:       // said, in the case when nextSibling is null at this point and aIsAppend
29838:       // is true, we know we're in case 3.  Furthermore, in that case we don't
29838:       // even have to worry about the table pseudo situation; we know our
29838:       // parent is not a table pseudo there.
27311:       FCItemIterator iter(aItems);
27311:       FCItemIterator start(iter);
27311:       do {
27311:         if (iter.SkipItemsWantingParentType(parentType)) {
27311:           break;
27311:         }
27311: 
27311:         // iter points to an item that wants a different parent.  If it's not
27311:         // whitespace, we're done; no more point scanning the list.
27311:         if (!iter.item().IsWhitespace()) {
27311:           break;
27311:         }
27311: 
27311:         if (iter == start) {
29838:           // Leading whitespace.  How to handle this depends on our
29838:           // previous sibling and aFrame.  See the long comment above.
29838:           nsIFrame* prevSibling = aPrevSibling;
29838:           if (!prevSibling) {
29838:             // Try to find one after all
29838:             nsIFrame* parentPrevCont = aFrame->GetPrevContinuation();
29838:             while (parentPrevCont) {
32841:               prevSibling = parentPrevCont->GetLastChild(nsnull);
29838:               if (prevSibling) {
29838:                 break;
29838:               }
29838:               parentPrevCont = parentPrevCont->GetPrevContinuation();
29838:             }
29838:           };
29838:           if (prevSibling) {
29838:             if (IsTablePseudo(prevSibling)) {
27311:               // need to reframe
27311:               break;
27311:             }
29838:           } else if (IsTablePseudo(aFrame)) {
27311:             // need to reframe
27311:             break;
27311:           }
27311:         }
27311: 
27311:         FCItemIterator spaceEndIter(iter);
27311:         // Advance spaceEndIter past any whitespace
27311:         PRBool trailingSpaces = spaceEndIter.SkipWhitespace();
27311: 
29838:         PRBool okToDrop;
29838:         if (trailingSpaces) {
29838:           // Trailing whitespace.  How to handle this depeds on aIsAppend, our
29838:           // next sibling and aFrame.  See the long comment above.
29838:           okToDrop = aIsAppend && !nextSibling;
29838:           if (!okToDrop) {
29838:             if (!nextSibling) {
29838:               // Try to find one after all
29838:               nsIFrame* parentNextCont = aFrame->GetNextContinuation();
29838:               while (parentNextCont) {
29838:                 nextSibling = parentNextCont->GetFirstChild(nsnull);
29838:                 if (nextSibling) {
29838:                   break;
29838:                 }
29838:                 parentNextCont = parentNextCont->GetNextContinuation();
29838:               }
29838:             }
29838: 
29838:             okToDrop = (nextSibling && !IsTablePseudo(nextSibling)) ||
29838:                        (!nextSibling && !IsTablePseudo(aFrame));
29838:           }
29838: #ifdef DEBUG
29838:           else {
29838:             NS_ASSERTION(!IsTablePseudo(aFrame), "How did that happen?");
29838:           }
29838: #endif
29838:         } else {
29838:           okToDrop = (spaceEndIter.item().DesiredParentType() == parentType);
29838:         }
29838: 
29838:         if (okToDrop) {
27311:           iter.DeleteItemsTo(spaceEndIter);
27311:         } else {
27311:           // We're done: we don't want to drop the whitespace, and it has the
27311:           // wrong parent type.
27311:           break;
27311:         }
27311: 
27311:         // Now loop, since |iter| points to item right after the whitespace we
27311:         // removed.
27311:       } while (!iter.IsDone());
27311:     }
27311: 
26607:     // We might be able to figure out some sort of optimizations here, but they
26607:     // would have to depend on having a correct aPrevSibling and a correct next
26607:     // sibling.  For example, we can probably avoid reframing if none of
26607:     // aFrame, aPrevSibling, and next sibling are table pseudo-frames.  But it
26607:     // doesn't seem worth it to worry about that for now, especially since we
26607:     // in fact do not have a reliable aPrevSibling, nor any next sibling, in
26607:     // this method.
26607: 
27311:     // aItems might have changed, so recheck the parent type thing.  In fact,
27311:     // it might be empty, so recheck that too.
27311:     if (aItems.IsEmpty()) {
27311:       return PR_FALSE;
27311:     }
27311: 
27311:     if (!aItems.AllWantParentType(parentType)) {
26607:       // Reframing aFrame->GetContent() is good enough, since the content of
26607:       // table pseudo-frames is the ancestor content.
31031:       RecreateFramesForContent(aFrame->GetContent(), PR_TRUE);
26607:       return PR_TRUE;
26607:     }
27311:   }
26607: 
26607:   // Situation #3 is an inline frame that will now contain block
    1:   // frames. This is a no-no and the frame construction logic knows
 4696:   // how to fix this.  See defition of IsInlineFrame() for what "an
 4696:   // inline" is.  Whether we have "a block" is tested for by
25773:   // AreAllItemsInline.
 4696: 
 4696:   // We also need to check for an append of content ending in an
 4696:   // inline to the block in an {ib} split or an insert of content
 4696:   // starting with an inline to the start of that block.  If that
 4696:   // happens, we also need to reframe, since that content needs to go
 4696:   // into the following or preceding inline in the split.
 4696: 
 4696:   if (IsInlineFrame(aFrame)) {
 4696:     // Nothing to do if all kids are inline
25774:     if (aItems.AreAllItemsInline()) {
    1:       return PR_FALSE;
 4696:     }
 4696:   } else if (!IsFrameSpecial(aFrame)) {
 4696:     return PR_FALSE;
 4696:   } else {
 4696:     // aFrame is the block in an {ib} split.  Check that we're not
 4696:     // messing up either end of it.
27310:     if (aPrevSibling || !aItems.IsStartInline()) {
27310:       // Not messing up the beginning.  Now let's look at the end.
27310:       if (nextSibling) {
27310:         // Can't possibly screw up the end; bail out
27310:         return PR_FALSE;
27310:       }
27310: 
 4696:       if (aIsAppend) {
25773:         // Will be handled in AppendFrames(), except the case when we might have
25773:         // floats that we won't be able to move out because there is no float
25773:         // containing block to move them into.
 4696: 
 5324:         // Walk up until we get a float containing block that's not part of an
 5324:         // {ib} split, since otherwise we might have to ship floats out of it
 5324:         // too.
25773:         // XXXbz we could keep track of whether we have any descendants with
25773:         // float style in the FrameConstructionItem if we really want, but it's
27310:         // not clear to me that we need to.  In any case, the right solution
27310:         // here is to construct with the right parents to start with.
 5324:         nsIFrame* floatContainer = aFrame;
 5324:         do {
19125:           floatContainer = GetFloatContainingBlock(
19125:             GetIBSplitSpecialPrevSiblingForAnonymousBlock(floatContainer));
 5324:           if (!floatContainer) {
 5324:             break;
 5324:           }
 5324:           if (!IsFrameSpecial(floatContainer)) {
 5324:             return PR_FALSE;
 5324:           }
 5324:         } while (1);
 5324:       }
 5324: 
27310:       // This is an append that won't go through AppendFrames, or won't be able
27310:       // to ship floats out in AppendFrames.  We can bail out if the last frame
27310:       // we're appending is not inline.
27308:       if (!aItems.IsEndInline()) {
 4696:         return PR_FALSE;
 4696:       }
 4696:     }
 4696:   }
    1: 
    1:   // If we don't have a containing block, start with aFrame and look for one.
    1:   if (!aContainingBlock) {
    1:     aContainingBlock = aFrame;
    1:   }
    1:   
    1:   // To find the right block to reframe, just walk up the tree until we find a
    1:   // frame that is:
    1:   // 1)  Not part of an IB split (not special)
    1:   // 2)  Not a pseudo-frame
    1:   // 3)  Not an inline frame
    1:   // We're guaranteed to find one, since nsStyleContext::ApplyStyleFixups
    1:   // enforces that the root is display:none, display:table, or display:block.
    1:   // Note that walking up "too far" is OK in terms of correctness, even if it
    1:   // might be a little inefficient.  This is why we walk out of all
    1:   // pseudo-frames -- telling which ones are or are not OK to walk out of is
    1:   // too hard (and I suspect that we do in fact need to walk out of all of
    1:   // them).
 2829:   while (IsFrameSpecial(aContainingBlock) || IsInlineOutside(aContainingBlock) ||
    1:          aContainingBlock->GetStyleContext()->GetPseudoType()) {
    1:     aContainingBlock = aContainingBlock->GetParent();
    1:     NS_ASSERTION(aContainingBlock,
    1:                  "Must have non-inline, non-special, non-pseudo frame as root "
    1:                  "(or child of root, for a table root)!");
    1:   }
    1: 
    1:   // Tell parent of the containing block to reformulate the
    1:   // entire block. This is painful and definitely not optimal
    1:   // but it will *always* get the right answer.
    1: 
    1:   nsIContent *blockContent = aContainingBlock->GetContent();
    1: #ifdef DEBUG
    1:   if (gNoisyContentUpdates) {
28215:     printf("nsCSSFrameConstructor::WipeContainingBlock: blockContent=%p\n",
28215:            static_cast<void*>(blockContent));
28215:   }
28215: #endif
31031:   RecreateFramesForContent(blockContent, PR_TRUE);
    1:   return PR_TRUE;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ReframeContainingBlock(nsIFrame* aFrame)
    1: {
    1: 
    1: #ifdef DEBUG
    1:   // ReframeContainingBlock is a NASTY routine, it causes terrible performance problems
    1:   // so I want to see when it is happening!  Unfortunately, it is happening way to often because
    1:   // so much content on the web causes 'special' block-in-inline frame situations and we handle them
    1:   // very poorly
    1:   if (gNoisyContentUpdates) {
    1:     printf("nsCSSFrameConstructor::ReframeContainingBlock frame=%p\n",
 3233:            static_cast<void*>(aFrame));
    1:   }
    1: #endif
    1: 
28215:   // XXXbz how exactly would we get here while isReflowing anyway?  Should this
28215:   // whole test be ifdef DEBUG?
    1:   PRBool isReflowing;
    1:   mPresShell->IsReflowLocked(&isReflowing);
    1:   if(isReflowing) {
    1:     // don't ReframeContainingBlock, this will result in a crash
    1:     // if we remove a tree that's in reflow - see bug 121368 for testcase
31561:     NS_ERROR("Atemptted to nsCSSFrameConstructor::ReframeContainingBlock during a Reflow!!!");
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Get the first "normal" ancestor of the target frame.
    1:   nsIFrame* containingBlock = GetIBContainingBlockFor(aFrame);
    1:   if (containingBlock) {
    1:     // From here we look for the containing block in case the target
    1:     // frame is already a block (which can happen when an inline frame
    1:     // wraps some of its content in an anonymous block; see
    1:     // ConstructInline)
    1:    
    1:     // NOTE: We used to get the FloatContainingBlock here, but it was often wrong.
    1:     // GetIBContainingBlock works much better and provides the correct container in all cases
    1:     // so GetFloatContainingBlock(aFrame) has been removed
    1: 
    1:     // And get the containingBlock's content
    1:     nsCOMPtr<nsIContent> blockContent = containingBlock->GetContent();
    1:     if (blockContent) {
    1: #ifdef DEBUG
    1:       if (gNoisyContentUpdates) {
28215:         printf("  ==> blockContent=%p\n", static_cast<void*>(blockContent));
28215:       }
28215: #endif
31031:       return RecreateFramesForContent(blockContent, PR_TRUE);
    1:     }
    1:   }
    1: 
    1:   // If we get here, we're screwed!
31031:   return RecreateFramesForContent(mPresShell->GetDocument()->GetRootContent(), PR_TRUE);
    1: }
    1: 
11845: void
11845: nsCSSFrameConstructor::RestyleForAppend(nsIContent* aContainer,
11845:                                         PRInt32 aNewIndexInContainer)
11845: {
11845:   NS_ASSERTION(aContainer, "must have container for append");
15302: #ifdef DEBUG
15302:   {
15302:     for (PRInt32 index = aNewIndexInContainer;; ++index) {
15302:       nsIContent *content = aContainer->GetChildAt(index);
15302:       if (!content) {
15302:         NS_ASSERTION(index != aNewIndexInContainer, "yikes, nothing appended");
15302:         break;
15302:       }
16128:       NS_ASSERTION(!content->IsRootOfAnonymousSubtree(),
16128:                    "anonymous nodes should not be in child lists");
15302:     }
15302:   }
15302: #endif
11845:   PRUint32 selectorFlags =
11845:     aContainer->GetFlags() & (NODE_ALL_SELECTOR_FLAGS &
11845:                               ~NODE_HAS_SLOW_SELECTOR_NOAPPEND);
11845:   if (selectorFlags == 0)
11845:     return;
11845: 
11845:   if (selectorFlags & NODE_HAS_SLOW_SELECTOR) {
11845:     PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
11845:     // Restyling the container is the most we can do here, so we're done.
11845:     return;
11845:   }
11845: 
11845:   if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
11845:     // see whether we need to restyle the container
11845:     PRBool wasEmpty = PR_TRUE; // :empty or :-moz-only-whitespace
11845:     for (PRInt32 index = 0; index < aNewIndexInContainer; ++index) {
11845:       // We don't know whether we're testing :empty or :-moz-only-whitespace,
11845:       // so be conservative and assume :-moz-only-whitespace (i.e., make
11845:       // IsSignificantChild less likely to be true, and thus make us more
11845:       // likely to restyle).
11845:       if (nsStyleUtil::IsSignificantChild(aContainer->GetChildAt(index),
11845:                                           PR_TRUE, PR_FALSE)) {
11845:         wasEmpty = PR_FALSE;
11845:         break;
11845:       }
11845:     }
11845:     if (wasEmpty) {
11845:       PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
11845:       // Restyling the container is the most we can do here, so we're done.
11845:       return;
11845:     }
11845:   }
11845:   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
11845:     // restyle the last element child before this node
11845:     for (PRInt32 index = aNewIndexInContainer - 1; index >= 0; --index) {
11845:       nsIContent *content = aContainer->GetChildAt(index);
11845:       if (content->IsNodeOfType(nsINode::eELEMENT)) {
11845:         PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
11845:         break;
11845:       }
11845:     }
11845:   }
11845: }
11845: 
11845: // Restyling for a ContentInserted or CharacterDataChanged notification.
11845: // This could be used for ContentRemoved as well if we got the
11845: // notification before the removal happened (and sometimes
11845: // CharacterDataChanged is more like a removal than an addition).
11845: // The comments are written and variables are named in terms of it being
11845: // a ContentInserted notification.
11845: void
11845: nsCSSFrameConstructor::RestyleForInsertOrChange(nsIContent* aContainer,
11845:                                                 nsIContent* aChild)
11845: {
16128:   NS_ASSERTION(!aChild->IsRootOfAnonymousSubtree(),
16128:                "anonymous nodes should not be in child lists");
11845:   PRUint32 selectorFlags =
11845:     aContainer ? (aContainer->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
11845:   if (selectorFlags == 0)
11845:     return;
11845: 
11845:   if (selectorFlags & (NODE_HAS_SLOW_SELECTOR |
11845:                        NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
11845:     PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
11845:     // Restyling the container is the most we can do here, so we're done.
11845:     return;
11845:   }
11845: 
11845:   if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
11845:     // see whether we need to restyle the container
11845:     PRBool wasEmpty = PR_TRUE; // :empty or :-moz-only-whitespace
11845:     for (PRInt32 index = 0; ; ++index) {
11845:       nsIContent *child = aContainer->GetChildAt(index);
11845:       if (!child) // last child
11845:         break;
11845:       if (child == aChild)
11845:         continue;
11845:       // We don't know whether we're testing :empty or :-moz-only-whitespace,
11845:       // so be conservative and assume :-moz-only-whitespace (i.e., make
11845:       // IsSignificantChild less likely to be true, and thus make us more
11845:       // likely to restyle).
11845:       if (nsStyleUtil::IsSignificantChild(child, PR_TRUE, PR_FALSE)) {
11845:         wasEmpty = PR_FALSE;
11845:         break;
11845:       }
11845:     }
11845:     if (wasEmpty) {
11845:       PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
11845:       // Restyling the container is the most we can do here, so we're done.
11845:       return;
11845:     }
11845:   }
11845: 
11845:   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
11845:     // restyle the previously-first element child if it is after this node
11845:     PRBool passedChild = PR_FALSE;
11845:     for (PRInt32 index = 0; ; ++index) {
11845:       nsIContent *content = aContainer->GetChildAt(index);
11845:       if (!content)
11845:         break; // went through all children
11845:       if (content == aChild) {
11845:         passedChild = PR_TRUE;
11845:         continue;
11845:       }
11845:       if (content->IsNodeOfType(nsINode::eELEMENT)) {
11845:         if (passedChild) {
11845:           PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
11845:         }
11845:         break;
11845:       }
11845:     }
11845:     // restyle the previously-last element child if it is before this node
11845:     passedChild = PR_FALSE;
11845:     for (PRInt32 index = aContainer->GetChildCount() - 1;
11845:          index >= 0; --index) {
11845:       nsIContent *content = aContainer->GetChildAt(index);
11845:       if (content == aChild) {
11845:         passedChild = PR_TRUE;
11845:         continue;
11845:       }
11845:       if (content->IsNodeOfType(nsINode::eELEMENT)) {
11845:         if (passedChild) {
11845:           PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
11845:         }
11845:         break;
11845:       }
11845:     }
11845:   }
11845: }
11845: 
11845: void
11845: nsCSSFrameConstructor::RestyleForRemove(nsIContent* aContainer,
11845:                                         nsIContent* aOldChild,
11845:                                         PRInt32 aIndexInContainer)
11845: {
16128:   NS_ASSERTION(!aOldChild->IsRootOfAnonymousSubtree(),
16128:                "anonymous nodes should not be in child lists");
11845:   PRUint32 selectorFlags =
11845:     aContainer ? (aContainer->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
11845:   if (selectorFlags == 0)
11845:     return;
11845: 
11845:   if (selectorFlags & (NODE_HAS_SLOW_SELECTOR |
11845:                        NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
11845:     PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
11845:     // Restyling the container is the most we can do here, so we're done.
11845:     return;
11845:   }
11845: 
11845:   if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
11845:     // see whether we need to restyle the container
11845:     PRBool isEmpty = PR_TRUE; // :empty or :-moz-only-whitespace
11845:     for (PRInt32 index = 0; ; ++index) {
11845:       nsIContent *child = aContainer->GetChildAt(index);
11845:       if (!child) // last child
11845:         break;
11845:       // We don't know whether we're testing :empty or :-moz-only-whitespace,
11845:       // so be conservative and assume :-moz-only-whitespace (i.e., make
11845:       // IsSignificantChild less likely to be true, and thus make us more
11845:       // likely to restyle).
11845:       if (nsStyleUtil::IsSignificantChild(child, PR_TRUE, PR_FALSE)) {
11845:         isEmpty = PR_FALSE;
11845:         break;
11845:       }
11845:     }
11845:     if (isEmpty) {
11845:       PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
11845:       // Restyling the container is the most we can do here, so we're done.
11845:       return;
11845:     }
11845:   }
11845: 
11845:   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
11845:     // restyle the previously-first element child if it is after aOldChild
11845:     for (PRInt32 index = 0; ; ++index) {
11845:       nsIContent *content = aContainer->GetChildAt(index);
11845:       if (!content)
11845:         break; // went through all children
11845:       if (content->IsNodeOfType(nsINode::eELEMENT)) {
11845:         if (index >= aIndexInContainer) {
11845:           PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
11845:         }
11845:         break;
11845:       }
11845:     }
11845:     // restyle the previously-last element child if it is before aOldChild
11845:     for (PRInt32 index = aContainer->GetChildCount() - 1;
11845:          index >= 0; --index) {
11845:       nsIContent *content = aContainer->GetChildAt(index);
11845:       if (content->IsNodeOfType(nsINode::eELEMENT)) {
11845:         if (index < aIndexInContainer) {
11845:           PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
11845:         }
11845:         break;
11845:       }
11845:     }
11845:   }
11845: }
11845: 
11845: 
20261: static PLDHashOperator
    1: CollectRestyles(nsISupports* aContent,
    1:                 nsCSSFrameConstructor::RestyleData& aData,
    1:                 void* aRestyleArrayPtr)
    1: {
    1:   nsCSSFrameConstructor::RestyleEnumerateData** restyleArrayPtr =
 3233:     static_cast<nsCSSFrameConstructor::RestyleEnumerateData**>
 3233:                (aRestyleArrayPtr);
    1:   nsCSSFrameConstructor::RestyleEnumerateData* currentRestyle =
    1:     *restyleArrayPtr;
 3233:   currentRestyle->mContent = static_cast<nsIContent*>(aContent);
    1:   currentRestyle->mRestyleHint = aData.mRestyleHint;
    1:   currentRestyle->mChangeHint = aData.mChangeHint;
    1: 
    1:   // Increment to the next slot in the array
    1:   *restyleArrayPtr = currentRestyle + 1; 
    1: 
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
    1: void
    1: nsCSSFrameConstructor::ProcessOneRestyle(nsIContent* aContent,
    1:                                          nsReStyleHint aRestyleHint,
    1:                                          nsChangeHint aChangeHint)
    1: {
    1:   NS_PRECONDITION(aContent, "Must have content node");
    1:   
    1:   if (!aContent->IsInDoc() ||
    1:       aContent->GetCurrentDoc() != mDocument) {
    1:     // Content node has been removed from our document; nothing else
    1:     // to do here
    1:     return;
    1:   }
    1:   
    1:   nsIFrame* primaryFrame = mPresShell->GetPrimaryFrameFor(aContent);
    1:   if (aRestyleHint & eReStyle_Self) {
    1:     RestyleElement(aContent, primaryFrame, aChangeHint);
    1:   } else if (aChangeHint &&
    1:                (primaryFrame ||
    1:                 (aChangeHint & nsChangeHint_ReconstructFrame))) {
    1:     // Don't need to recompute style; just apply the hint
    1:     nsStyleChangeList changeList;
    1:     changeList.AppendChange(primaryFrame, aContent, aChangeHint);
    1:     ProcessRestyledFrames(changeList);
    1:   }
    1: 
    1:   if (aRestyleHint & eReStyle_LaterSiblings) {
    1:     RestyleLaterSiblings(aContent);
    1:   }
    1: }
    1: 
 7713: #define RESTYLE_ARRAY_STACKSIZE 128
 7713: 
    1: void
11409: nsCSSFrameConstructor::RebuildAllStyleData(nsChangeHint aExtraHint)
11409: {
11409:   NS_ASSERTION(!(aExtraHint & nsChangeHint_ReconstructFrame),
11409:                "Should not reconstruct the root of the frame tree.  "
11409:                "Use ReconstructDocElementHierarchy instead.");
11409: 
10073:   mRebuildAllStyleData = PR_FALSE;
22339:   NS_UpdateHint(aExtraHint, mRebuildAllExtraHint);
22339:   mRebuildAllExtraHint = nsChangeHint(0);
10073: 
25840:   if (!mPresShell || !mPresShell->GetRootFrame() ||
25840:       !mPresShell->GetPresContext()->IsDynamic())
10073:     return;
10073: 
23652:   nsAutoScriptBlocker scriptBlocker;
23652: 
23652:   // Make sure that the viewmanager will outlive the presshell
23652:   nsIViewManager::UpdateViewBatch batch(mPresShell->GetViewManager());
23652: 
21202:   // Processing the style changes could cause a flush that propagates to
21202:   // the parent frame and thus destroys the pres shell.
21202:   nsCOMPtr<nsIPresShell> kungFuDeathGrip(mPresShell);
21202: 
10073:   // Tell the style set to get the old rule tree out of the way
10073:   // so we can recalculate while maintaining rule tree immutability
10073:   nsresult rv = mPresShell->StyleSet()->BeginReconstruct();
23652:   if (NS_FAILED(rv)) {
23652:     batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
10073:     return;
23652:   }
10073: 
10073:   // Recalculate all of the style contexts for the document
10073:   // Note that we can ignore the return value of ComputeStyleChangeFor
10073:   // because we never need to reframe the root frame
10073:   // XXX This could be made faster by not rerunning rule matching
10073:   // (but note that nsPresShell::SetPreferenceStyleRules currently depends
10073:   // on us re-running rule matching here
10073:   nsStyleChangeList changeList;
11409:   // XXX Does it matter that we're passing aExtraHint to the real root
11409:   // frame and not the root node's primary frame?
10073:   mPresShell->FrameManager()->ComputeStyleChangeFor(mPresShell->GetRootFrame(),
11409:                                                     &changeList, aExtraHint);
10073:   // Process the required changes
10073:   ProcessRestyledFrames(changeList);
10073:   // Tell the style set it's safe to destroy the old rule tree.  We
10073:   // must do this after the ProcessRestyledFrames call in case the
10073:   // change list has frame reconstructs in it (since frames to be
10073:   // reconstructed will still have their old style context pointers
10073:   // until they are destroyed).
10073:   mPresShell->StyleSet()->EndReconstruct();
23652:   batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
10073: }
10073: 
10073: void
32401: nsCSSFrameConstructor::ProcessPendingRestyleTable(
32401:                    nsDataHashtable<nsISupportsHashKey, RestyleData>& aRestyles)
32401: {
32401:   PRUint32 count = aRestyles.Count();
22339: 
31031:   // Make sure to not rebuild quote or counter lists while we're
31031:   // processing restyles
31031:   BeginUpdate();
31031: 
31031:   // loop so that we process any restyle events generated by processing
31031:   while (count) {
 7713:     // Use the stack if we can, otherwise fall back on heap-allocation.
 7713:     nsAutoTArray<RestyleEnumerateData, RESTYLE_ARRAY_STACKSIZE> restyleArr;
 7713:     RestyleEnumerateData* restylesToProcess = restyleArr.AppendElements(count);
 7713:   
    1:     if (!restylesToProcess) {
    1:       return;
    1:     }
    1: 
 7713:     RestyleEnumerateData* lastRestyle = restylesToProcess;
32401:     aRestyles.Enumerate(CollectRestyles, &lastRestyle);
    1: 
 7713:     NS_ASSERTION(lastRestyle - restylesToProcess == PRInt32(count),
    1:                  "Enumeration screwed up somehow");
    1: 
    1:     // Clear the hashtable so we don't end up trying to process a restyle we're
    1:     // already processing, sending us into an infinite loop.
32401:     aRestyles.Clear();
    1: 
 7713:     for (RestyleEnumerateData* currentRestyle = restylesToProcess;
    1:          currentRestyle != lastRestyle;
    1:          ++currentRestyle) {
    1:       ProcessOneRestyle(currentRestyle->mContent,
    1:                         currentRestyle->mRestyleHint,
    1:                         currentRestyle->mChangeHint);
    1:     }
    1: 
32965:     count = aRestyles.Count();
31031:   }
31031: 
    1:   EndUpdate();
    1: 
    1: #ifdef DEBUG
    1:   mPresShell->VerifyStyleTree();
    1: #endif
32401: }
32401: 
32401: void
32401: nsCSSFrameConstructor::ProcessPendingRestyles()
32401: {
32401:   NS_PRECONDITION(mDocument, "No document?  Pshaw!\n");
32401:   NS_PRECONDITION(!nsContentUtils::IsSafeToRunScript(),
32401:                   "Missing a script blocker!");
32401: 
32401:   // Process non-animation restyles...
32401:   ProcessPendingRestyleTable(mPendingRestyles);
32401: 
32401:   // ...and then process animation restyles.  This needs to happen
32401:   // second because we need to start animations that resulted from the
32401:   // first set of restyles (e.g., CSS transitions with negative
32401:   // transition-delay), and because we need to immediately
32401:   // restyle-with-animation any just-restyled elements that are
32401:   // mid-transition (since processing the non-animation restyle ignores
32401:   // the running transition so it can check for a new change on the same
32401:   // property, and then posts an immediate animation style change).
32401:   nsPresContext *presContext = mPresShell->GetPresContext();
32401:   presContext->SetProcessingAnimationStyleChange(PR_TRUE);
32401:   ProcessPendingRestyleTable(mPendingAnimationRestyles);
32401:   presContext->SetProcessingAnimationStyleChange(PR_FALSE);
10073: 
10073:   if (mRebuildAllStyleData) {
10073:     // We probably wasted a lot of work up above, but this seems safest
10073:     // and it should be rarely used.
11409:     RebuildAllStyleData(nsChangeHint(0));
10073:   }
    1: }
    1: 
    1: void
32401: nsCSSFrameConstructor::PostRestyleEventCommon(nsIContent* aContent,
    1:                                               nsReStyleHint aRestyleHint,
32401:                                               nsChangeHint aMinChangeHint,
32401:                                               PRBool aForAnimation)
    1: {
26803:   if (NS_UNLIKELY(mPresShell->IsDestroying())) {
10402:     return;
10402:   }
10402: 
    1:   if (aRestyleHint == 0 && !aMinChangeHint) {
    1:     // Nothing to do here
    1:     return;
    1:   }
    1: 
    1:   NS_ASSERTION(aContent->IsNodeOfType(nsINode::eELEMENT),
    1:                "Shouldn't be trying to restyle non-elements directly");
    1: 
    1:   RestyleData existingData;
    1:   existingData.mRestyleHint = nsReStyleHint(0);
    1:   existingData.mChangeHint = NS_STYLE_HINT_NONE;
    1: 
32401:   nsDataHashtable<nsISupportsHashKey, RestyleData> &restyles =
32401:     aForAnimation ? mPendingAnimationRestyles : mPendingRestyles;
32401: 
32401:   restyles.Get(aContent, &existingData);
    1:   existingData.mRestyleHint =
    1:     nsReStyleHint(existingData.mRestyleHint | aRestyleHint);
    1:   NS_UpdateHint(existingData.mChangeHint, aMinChangeHint);
    1: 
32401:   restyles.Put(aContent, existingData);
    1: 
22339:   PostRestyleEventInternal();
22339: }
22339:     
22339: void
22339: nsCSSFrameConstructor::PostRestyleEventInternal()
22339: {
    1:   if (!mRestyleEvent.IsPending()) {
    1:     nsRefPtr<RestyleEvent> ev = new RestyleEvent(this);
    1:     if (NS_FAILED(NS_DispatchToCurrentThread(ev))) {
    1:       NS_WARNING("failed to dispatch restyle event");
    1:       // XXXbz and what?
    1:     } else {
    1:       mRestyleEvent = ev;
    1:     }
    1:   }
    1: }
    1: 
10073: void
22339: nsCSSFrameConstructor::PostRebuildAllStyleDataEvent(nsChangeHint aExtraHint)
22339: {
22339:   NS_ASSERTION(!(aExtraHint & nsChangeHint_ReconstructFrame),
22339:                "Should not reconstruct the root of the frame tree.  "
22339:                "Use ReconstructDocElementHierarchy instead.");
22339: 
10073:   mRebuildAllStyleData = PR_TRUE;
22339:   NS_UpdateHint(mRebuildAllExtraHint, aExtraHint);
10073:   // Get a restyle event posted if necessary
22339:   PostRestyleEventInternal();
10073: }
10073: 
 6171: NS_IMETHODIMP nsCSSFrameConstructor::RestyleEvent::Run()
 6171: {
    1:   if (!mConstructor)
    1:     return NS_OK;  // event was revoked
    1: 
    1:   // Make sure that any restyles that happen from now on will go into
    1:   // a new event.
    1:   mConstructor->mRestyleEvent.Forget();  
    1:   
 6171:   return mConstructor->mPresShell->FlushPendingNotifications(Flush_Style);
    1: }
    1: 
 3129: NS_IMETHODIMP
 3129: nsCSSFrameConstructor::LazyGenerateChildrenEvent::Run()
 3129: {
 3129:   mPresShell->GetDocument()->FlushPendingNotifications(Flush_Layout);
 3129: 
 3129:   // this is hard-coded to handle only menu popup frames
 3129:   nsIFrame* frame = mPresShell->GetPrimaryFrameFor(mContent);
 3129:   if (frame && frame->GetType() == nsGkAtoms::menuPopupFrame) {
30491:     nsWeakFrame weakFrame(frame);
 3799: #ifdef MOZ_XUL
 3129:     // it is possible that the frame is different than the one that requested
 3129:     // the lazy generation, but as long as it's a popup frame that hasn't
 3129:     // generated its children yet, that's OK.
 3233:     nsMenuPopupFrame* menuPopupFrame = static_cast<nsMenuPopupFrame *>(frame);
 9758:     if (menuPopupFrame->HasGeneratedChildren()) {
 9758:       if (mCallback)
 9758:         mCallback(mContent, frame, mArg);
 9758:       
 9758:       return NS_OK;
 9758:     }     
 3129: 
 3129:     // indicate that the children have been generated
 3129:     menuPopupFrame->SetGeneratedChildren();
 3799: #endif
 3129: 
23256:    {
23256:       nsAutoScriptBlocker scriptBlocker;
 6518:       nsCSSFrameConstructor* fc = mPresShell->FrameConstructor();
 6518:       fc->BeginUpdate();
 6518: 
 3129:       nsFrameItems childItems;
 3129:       nsFrameConstructorState state(mPresShell, nsnull, nsnull, nsnull);
23352:       nsresult rv = fc->ProcessChildren(state, mContent, frame->GetStyleContext(),
23352:                                         frame, PR_FALSE, childItems, PR_FALSE);
23652:       if (NS_FAILED(rv)) {
23652:         fc->EndUpdate();
23652:         return rv;
23652:       }
23167: 
30785:       frame->SetInitialChildList(nsnull, childItems);
 3129: 
 6518:       fc->EndUpdate();
23256:     }
 6518: 
30491:     if (mCallback && weakFrame.IsAlive())
 3129:       mCallback(mContent, frame, mArg);
 3129: 
 3129:     // call XBL constructors after the frames are created
 3129:     mPresShell->GetDocument()->BindingManager()->ProcessAttachedQueue();
 3129:   }
 3129: 
 3129:   return NS_OK;
 3129: }
26208: 
27311: //////////////////////////////////////////////////////////
27311: // nsCSSFrameConstructor::FrameConstructionItem methods //
27311: //////////////////////////////////////////////////////////
27311: PRBool
27311: nsCSSFrameConstructor::FrameConstructionItem::IsWhitespace() const
27311: {
27311:   if (!mIsText) {
27311:     return PR_FALSE;
27311:   }
29809:   mContent->SetFlags(NS_CREATE_FRAME_IF_NON_WHITESPACE |
29809:                      NS_REFRAME_IF_WHITESPACE);
27311:   return mContent->TextIsOnlyWhitespace();
27311: }
27311: 
26208: //////////////////////////////////////////////////////////////
26208: // nsCSSFrameConstructor::FrameConstructionItemList methods //
26208: //////////////////////////////////////////////////////////////
26208: void
26208: nsCSSFrameConstructor::FrameConstructionItemList::
26208: AdjustCountsForItem(FrameConstructionItem* aItem, PRInt32 aDelta)
26208: {
26208:   NS_PRECONDITION(aDelta == 1 || aDelta == -1, "Unexpected delta");
26208:   mItemCount += aDelta;
26208:   if (aItem->mIsAllInline) {
26208:     mInlineCount += aDelta;
26208:   }
29075:   if (aItem->mIsLineParticipant) {
26208:     mLineParticipantCount += aDelta;
26208:   }
26208:   mDesiredParentCounts[aItem->DesiredParentType()] += aDelta;
26208: }
26208: 
26208: ////////////////////////////////////////////////////////////////////////
26208: // nsCSSFrameConstructor::FrameConstructionItemList::Iterator methods //
26208: ////////////////////////////////////////////////////////////////////////
27311: inline PRBool
27311: nsCSSFrameConstructor::FrameConstructionItemList::
27311: Iterator::SkipItemsWantingParentType(ParentType aParentType)
27311: {
27311:   NS_PRECONDITION(!IsDone(), "Shouldn't be done yet");
27311:   while (item().DesiredParentType() == aParentType) {
27311:     Next();
27311:     if (IsDone()) {
27311:       return PR_TRUE;
27311:     }
27311:   }
27311:   return PR_FALSE;
27311: }
27311: 
27311: inline PRBool
27311: nsCSSFrameConstructor::FrameConstructionItemList::
27311: Iterator::SkipWhitespace()
27311: {
27311:   NS_PRECONDITION(!IsDone(), "Shouldn't be done yet");
27311:   NS_PRECONDITION(item().IsWhitespace(), "Not pointing to whitespace?");
27311:   do {
27311:     Next();
27311:     if (IsDone()) {
27311:       return PR_TRUE;
27311:     }
27311:   } while (item().IsWhitespace());
27311: 
27311:   return PR_FALSE;
27311: }
27311: 
26208: void
26208: nsCSSFrameConstructor::FrameConstructionItemList::
26208: Iterator::AppendItemToList(FrameConstructionItemList& aTargetList)
26208: {
26208:   NS_ASSERTION(&aTargetList != &mList, "Unexpected call");
26208:   NS_PRECONDITION(!IsDone(), "should not be done");
26208: 
26208:   FrameConstructionItem* item = ToItem(mCurrent);
26208:   Next();
26208:   PR_REMOVE_LINK(item);
26208:   PR_APPEND_LINK(item, &aTargetList.mItems);
26208: 
26208:   mList.AdjustCountsForItem(item, -1);
26208:   aTargetList.AdjustCountsForItem(item, 1);
26208: }
26208: 
26208: void
26208: nsCSSFrameConstructor::FrameConstructionItemList::
26208: Iterator::AppendItemsToList(const Iterator& aEnd,
26208:                             FrameConstructionItemList& aTargetList)
26208: {
26208:   NS_ASSERTION(&aTargetList != &mList, "Unexpected call");
26208:   NS_PRECONDITION(mEnd == aEnd.mEnd, "end iterator for some other list?");
26208: 
26208:   if (!AtStart() || !aEnd.IsDone() || !aTargetList.IsEmpty()) {
26208:     do {
26208:       AppendItemToList(aTargetList);
26208:     } while (*this != aEnd);
26208:     return;
26208:   }
26208: 
26208:   // move over the list of items
26208:   PR_INSERT_AFTER(&aTargetList.mItems, &mList.mItems);
26208:   PR_REMOVE_LINK(&mList.mItems);
26208: 
26208:   // Copy over the various counters
26208:   aTargetList.mInlineCount = mList.mInlineCount;
26208:   aTargetList.mLineParticipantCount = mList.mLineParticipantCount;
26208:   aTargetList.mItemCount = mList.mItemCount;
26208:   memcpy(aTargetList.mDesiredParentCounts, mList.mDesiredParentCounts,
26208:          sizeof(aTargetList.mDesiredParentCounts));
26208: 
26208:   // reset mList
26208:   new (&mList) FrameConstructionItemList();
26208: 
26208:   // Point ourselves to aEnd, as advertised
26208:   mCurrent = mEnd = &mList.mItems;
26208:   NS_POSTCONDITION(*this == aEnd, "How did that happen?");
26208: }
26208: 
26208: void
26208: nsCSSFrameConstructor::FrameConstructionItemList::
26208: Iterator::InsertItem(FrameConstructionItem* aItem)
26208: {
26208:   // Just insert the item before us.  There's no magic here.
26208:   PR_INSERT_BEFORE(aItem, mCurrent);
26208:   mList.AdjustCountsForItem(aItem, 1);
26208: 
26208:   NS_POSTCONDITION(PR_NEXT_LINK(aItem) == mCurrent, "How did that happen?");
26208: }
26208: 
26208: void
27311: nsCSSFrameConstructor::FrameConstructionItemList::
27311: Iterator::DeleteItemsTo(const Iterator& aEnd)
27311: {
27311:   NS_PRECONDITION(mEnd == aEnd.mEnd, "end iterator for some other list?");
27311:   NS_PRECONDITION(*this != aEnd, "Shouldn't be at aEnd yet");
27311: 
27311:   do {
27311:     NS_ASSERTION(!IsDone(), "Ran off end of list?");
26208:     FrameConstructionItem* item = ToItem(mCurrent);
26208:     Next();
26208:     PR_REMOVE_LINK(item);
26208:     mList.AdjustCountsForItem(item, -1);
26208:     delete item;
27311:   } while (*this != aEnd);
27311: }
