     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
  3706: #if defined(XP_OS2) && defined(MOZ_OS2_HIGH_MEMORY)
  3706: // os2safe.h has to be included before os2.h, needed for high mem
  3706: #include <os2safe.h>
  3706: #endif
     1: 
     1: #define XPCOM_TRANSLATE_NSGM_ENTRY_POINT 1
     1: 
 16759: #if defined(MOZ_WIDGET_QT)
 94111: #include <QApplication>
 94111: #include <QStringList>
 80518: #include "nsQAppInstance.h"
 94111: #if (QT_VERSION < QT_VERSION_CHECK(5, 0, 0))
 94111: #include <QInputContextFactory>
 94111: #include <QInputContext>
 94111: #endif
 48828: #endif // MOZ_WIDGET_QT
 16759: 
 49689: #include "mozilla/dom/ContentParent.h"
 79812: #include "mozilla/dom/ContentChild.h"
 49689: 
 80467: #include "mozilla/Util.h"
103727: #include "mozilla/Attributes.h"
 80467: 
 38955: #include "nsAppRunner.h"
102334: #include "mozilla/AppData.h"
 38955: #include "nsUpdateDriver.h"
 99566: #include "ProfileReset.h"
 38955: 
 68747: #ifdef MOZ_INSTRUMENT_EVENT_LOOP
 68747: #include "EventTracer.h"
 68747: #endif
 68747: 
     1: #ifdef XP_MACOSX
 80958: #include "nsVersionComparator.h"
     1: #include "MacLaunchHelper.h"
     1: #include "MacApplicationDelegate.h"
 41062: #include "MacAutoreleasePool.h"
 80700: // these are needed for sysctl
 80700: #include <sys/types.h>
 80700: #include <sys/sysctl.h>
     1: #endif
     1: 
     1: #ifdef XP_OS2
     1: #include "private/pprthred.h"
     1: #endif
     1: #include "prmem.h"
     1: #include "prnetdb.h"
     1: #include "prprf.h"
     1: #include "prproces.h"
     1: #include "prenv.h"
     1: 
     1: #include "nsIAppShellService.h"
     1: #include "nsIAppStartup.h"
     1: #include "nsIAppStartupNotifier.h"
     1: #include "nsIMutableArray.h"
     1: #include "nsICategoryManager.h"
     1: #include "nsIChromeRegistry.h"
     1: #include "nsICommandLineRunner.h"
     1: #include "nsIComponentManager.h"
     1: #include "nsIComponentRegistrar.h"
     1: #include "nsIContentHandler.h"
     1: #include "nsIDialogParamBlock.h"
     1: #include "nsIDOMWindow.h"
 46997: #include "mozilla/ModuleUtils.h"
  4738: #include "nsIIOService2.h"
     1: #include "nsIObserverService.h"
     1: #include "nsINativeAppSupport.h"
     1: #include "nsIProcess.h"
     1: #include "nsIProfileUnlocker.h"
     1: #include "nsIPromptService.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsIStringBundle.h"
     1: #include "nsISupportsPrimitives.h"
     1: #include "nsIToolkitChromeRegistry.h"
     1: #include "nsIToolkitProfile.h"
     1: #include "nsIToolkitProfileService.h"
     1: #include "nsIURI.h"
     1: #include "nsIWindowCreator.h"
     1: #include "nsIWindowMediator.h"
     1: #include "nsIWindowWatcher.h"
     1: #include "nsIXULAppInfo.h"
     1: #include "nsIXULRuntime.h"
     1: #include "nsPIDOMWindow.h"
     1: #include "nsIBaseWindow.h"
     1: #include "nsIWidget.h"
     1: #include "nsIDocShell.h"
     1: #include "nsAppShellCID.h"
     1: 
 76840: #include "mozilla/unused.h"
 76840: 
 80467: using namespace mozilla;
 76840: using mozilla::unused;
 41343: 
     1: #ifdef XP_WIN
     1: #include "nsIWinAppHelper.h"
 30387: #include <windows.h>
 61203: #include "cairo/cairo-features.h"
 30387: 
 30387: #ifndef PROCESS_DEP_ENABLE
 30387: #define PROCESS_DEP_ENABLE 0x1
 30387: #endif
     1: #endif
     1: 
     1: #include "nsCRT.h"
     1: #include "nsCOMPtr.h"
     1: #include "nsDirectoryServiceDefs.h"
     1: #include "nsDirectoryServiceUtils.h"
     1: #include "nsEmbedCID.h"
     1: #include "nsNetUtil.h"
  2962: #include "nsReadableUtils.h"
     1: #include "nsStaticComponents.h"
     1: #include "nsXPCOM.h"
 23546: #include "nsXPCOMCIDInternal.h"
     1: #include "nsXPIDLString.h"
 91887: #include "nsPrintfCString.h"
     1: #include "nsVersionComparator.h"
     1: 
     1: #include "nsAppDirectoryServiceDefs.h"
     1: #include "nsXULAppAPI.h"
     1: #include "nsXREDirProvider.h"
     1: #include "nsToolkitCompsCID.h"
     1: 
     1: #include "nsINIParser.h"
 42540: #include "mozilla/Omnijar.h"
 82448: #include "mozilla/StartupTimeline.h"
     1: 
     1: #include <stdlib.h>
     1: 
119190: // for old system jemalloc version check
119190: #if !defined(MOZ_MEMORY) && defined(__NetBSD__)
119190: #include <sys/param.h>
119190: #endif
119190: 
     1: #ifdef XP_UNIX
     1: #include <sys/stat.h>
     1: #include <unistd.h>
 41531: #include <pwd.h>
     1: #endif
     1: 
     1: #ifdef XP_WIN
     1: #include <process.h>
     1: #include <shlobj.h>
     1: #include "nsThreadUtils.h"
     1: #endif
     1: 
     1: #ifdef XP_MACOSX
     1: #include "nsILocalFileMac.h"
     1: #include "nsCommandLineServiceMac.h"
     1: #endif
     1: 
     1: // for X remote support
     1: #ifdef MOZ_ENABLE_XREMOTE
     1: #include "XRemoteClient.h"
     1: #include "nsIRemoteService.h"
     1: #endif
     1: 
     1: #ifdef NS_TRACE_MALLOC
     1: #include "nsTraceMalloc.h"
     1: #endif
     1: 
     1: #if defined(DEBUG) && defined(XP_WIN32)
     1: #include <malloc.h>
     1: #endif
     1: 
     1: #if defined (XP_MACOSX)
 26366: #include <Carbon/Carbon.h>
     1: #endif
     1: 
     1: #ifdef DEBUG
     1: #include "prlog.h"
     1: #endif
     1: 
     1: #ifdef MOZ_JPROF
     1: #include "jprof.h"
     1: #endif
     1: 
  4389: #ifdef MOZ_CRASHREPORTER
  4389: #include "nsExceptionHandler.h"
   453: #include "nsICrashReporter.h"
   453: #define NS_CRASHREPORTER_CONTRACTID "@mozilla.org/toolkit/crash-reporter;1"
 34844: #include "nsIPrefService.h"
     1: #endif
     1: 
 35741: #include "base/command_line.h"
 35741: 
 42480: 
 82142: #ifdef MOZ_WIDGET_ANDROID
 43080: #include "AndroidBridge.h"
 43080: #endif
 43080: 
108991: extern uint32_t gRestartMode;
 36487: extern void InstallSignalHandlers(const char *ProgramName);
 38688: #include "nsX11ErrorHandler.h"
     1: 
 33900: #define FILE_COMPATIBILITY_INFO NS_LITERAL_CSTRING("compatibility.ini")
 47163: #define FILE_INVALIDATE_CACHES NS_LITERAL_CSTRING(".purgecaches")
 33900: 
     1: int    gArgc;
     1: char **gArgv;
     1: 
 40552: static const char gToolkitVersion[] = NS_STRINGIFY(GRE_MILESTONE);
 40552: static const char gToolkitBuildID[] = NS_STRINGIFY(GRE_BUILDID);
  3041: 
 89683: static nsIProfileLock* gProfileLock;
 89683: 
 99067: int    gRestartArgc;
 99067: char **gRestartArgv;
     1: 
 47852: #ifdef MOZ_WIDGET_QT
 47852: static int    gQtOnlyArgc;
 47852: static char **gQtOnlyArgv;
 47852: #endif
 47852: 
102173: #if defined(MOZ_WIDGET_GTK)
 19744: #if defined(DEBUG) || defined(NS_BUILD_REFCNT_LOGGING) \
 19744:   || defined(NS_TRACE_MALLOC)
 19744: #define CLEANUP_MEMORY 1
 19744: #define PANGO_ENABLE_BACKEND
 19744: #include <pango/pangofc-fontmap.h>
 19744: #endif
     1: #include <gtk/gtk.h>
 16527: #ifdef MOZ_X11
  6618: #include <gdk/gdkx.h>
 16527: #endif /* MOZ_X11 */
     1: #include "nsGTKToolkit.h"
     1: #endif
 71935: #include "BinaryPath.h"
     1: 
 73870: using mozilla::dom::ContentParent;
 79812: using mozilla::dom::ContentChild;
 73870: 
 41012: // Save literal putenv string to environment variable.
 41012: static void
 41012: SaveToEnv(const char *putenv)
 41012: {
 41012:   char *expr = strdup(putenv);
 41012:   if (expr)
 41012:     PR_SetEnv(expr);
 41012:   // We intentionally leak |expr| here since it is required by PR_SetEnv.
 41012: }
 41012: 
 63553: // Tests that an environment variable exists and has a value
 79445: static bool
 63553: EnvHasValue(const char *name)
 63553: {
 63553:   const char *val = PR_GetEnv(name);
 63553:   return (val && *val);
 63553: }
 63553: 
  2962: // Save the given word to the specified environment variable.
  2962: static void
  2962: SaveWordToEnv(const char *name, const nsACString & word)
  2962: {
  2962:   char *expr = PR_smprintf("%s=%s", name, PromiseFlatCString(word).get());
  2962:   if (expr)
  2962:     PR_SetEnv(expr);
  2962:   // We intentionally leak |expr| here since it is required by PR_SetEnv.
  2962: }
  2962: 
     1: // Save the path of the given file to the specified environment variable.
     1: static void
     1: SaveFileToEnv(const char *name, nsIFile *file)
     1: {
  9738: #ifdef XP_WIN
  9738:   nsAutoString path;
  9738:   file->GetPath(path);
  9738:   SetEnvironmentVariableW(NS_ConvertASCIItoUTF16(name).get(), path.get());
  9738: #else
110974:   nsAutoCString path;
     1:   file->GetNativePath(path);
  2962:   SaveWordToEnv(name, path);
  9738: #endif
  9738: }
  9738: 
  9738: // Load the path of a file saved with SaveFileToEnv
101111: static already_AddRefed<nsIFile>
  9738: GetFileFromEnv(const char *name)
  9738: {
  9738:   nsresult rv;
106838:   nsIFile *file = nullptr;
  9738: 
  9738: #ifdef XP_WIN
  9738:   WCHAR path[_MAX_PATH];
  9738:   if (!GetEnvironmentVariableW(NS_ConvertASCIItoUTF16(name).get(),
  9738:                                path, _MAX_PATH))
106838:     return nullptr;
  9738: 
 80486:   rv = NS_NewLocalFile(nsDependentString(path), true, &file);
  9738:   if (NS_FAILED(rv))
106838:     return nullptr;
  9738: 
  9738:   return file;
  9738: #else
  9738:   const char *arg = PR_GetEnv(name);
  9738:   if (!arg || !*arg)
106838:     return nullptr;
  9738: 
 80486:   rv = NS_NewNativeLocalFile(nsDependentCString(arg), true, &file);
  9738:   if (NS_FAILED(rv))
106838:     return nullptr;
  9738: 
  9738:   return file;
  9738: #endif
  2962: }
  2962: 
  2962: // Save the path of the given word to the specified environment variable
  2962: // provided the environment variable does not have a value.
  2962: static void
  2962: SaveWordToEnvIfUnset(const char *name, const nsACString & word)
  2962: {
 63553:   if (!EnvHasValue(name))
  2962:     SaveWordToEnv(name, word);
     1: }
     1: 
     1: // Save the path of the given file to the specified environment variable
     1: // provided the environment variable does not have a value.
     1: static void
     1: SaveFileToEnvIfUnset(const char *name, nsIFile *file)
     1: {
 63553:   if (!EnvHasValue(name))
     1:     SaveFileToEnv(name, file);
     1: }
     1: 
 79445: static bool
     1: strimatch(const char* lowerstr, const char* mixedstr)
     1: {
     1:   while(*lowerstr) {
 80486:     if (!*mixedstr) return false; // mixedstr is shorter
 80486:     if (tolower(*mixedstr) != *lowerstr) return false; // no match
     1: 
     1:     ++lowerstr;
     1:     ++mixedstr;
     1:   }
     1: 
 80486:   if (*mixedstr) return false; // lowerstr is shorter
 80486: 
 80486:   return true;
     1: }
     1: 
     1: /**
     1:  * Output a string to the user.  This method is really only meant to be used to
     1:  * output last-ditch error messages designed for developers NOT END USERS.
     1:  *
     1:  * @param isError
     1:  *        Pass true to indicate severe errors.
     1:  * @param fmt
     1:  *        printf-style format string followed by arguments.
     1:  */
 79445: static void Output(bool isError, const char *fmt, ... )
     1: {
     1:   va_list ap;
     1:   va_start(ap, fmt);
     1: 
     1: #if defined(XP_WIN) && !MOZ_WINCONSOLE
     1:   char *msg = PR_vsmprintf(fmt, ap);
     1:   if (msg)
     1:   {
     1:     UINT flags = MB_OK;
     1:     if (isError)
     1:       flags |= MB_ICONERROR;
     1:     else 
     1:       flags |= MB_ICONINFORMATION;
 19738: 
 19738:     wchar_t wide_msg[1024];
 19738:     MultiByteToWideChar(CP_ACP,
 19738:                         0,
 19738:                         msg,
 19738:                         -1,
 19738:                         wide_msg,
 19738:                         sizeof(wide_msg) / sizeof(wchar_t));
 19738: 
 19738:     MessageBoxW(NULL, wide_msg, L"XULRunner", flags);
     1:     PR_smprintf_free(msg);
     1:   }
     1: #else
     1:   vfprintf(stderr, fmt, ap);
     1: #endif
     1: 
     1:   va_end(ap);
     1: }
     1: 
  4817: enum RemoteResult {
  4817:   REMOTE_NOT_FOUND  = 0,
  4817:   REMOTE_FOUND      = 1,
  4817:   REMOTE_ARG_BAD    = 2
  4817: };
  4817: 
     1: enum ArgResult {
     1:   ARG_NONE  = 0,
     1:   ARG_FOUND = 1,
     1:   ARG_BAD   = 2 // you wanted a param, but there isn't one
     1: };
     1: 
     1: static void RemoveArg(char **argv)
     1: {
     1:   do {
     1:     *argv = *(argv + 1);
     1:     ++argv;
     1:   } while (*argv);
     1: 
     1:   --gArgc;
     1: }
     1: 
     1: /**
     1:  * Check for a commandline flag. If the flag takes a parameter, the
     1:  * parameter is returned in aParam. Flags may be in the form -arg or
     1:  * --arg (or /arg on win32/OS2).
     1:  *
     1:  * @param aArg the parameter to check. Must be lowercase.
  3321:  * @param aCheckOSInt if true returns ARG_BAD if the osint argument is present
  3321:  *        when aArg is also present.
     1:  * @param if non-null, the -arg <data> will be stored in this pointer. This is *not*
     1:  *        allocated, but rather a pointer to the argv data.
     1:  */
     1: static ArgResult
106838: CheckArg(const char* aArg, bool aCheckOSInt = false, const char **aParam = nullptr, bool aRemArg = true)
     1: {
 54026:   NS_ABORT_IF_FALSE(gArgv, "gArgv must be initialized before CheckArg()");
 54026: 
     1:   char **curarg = gArgv + 1; // skip argv[0]
  3321:   ArgResult ar = ARG_NONE;
     1: 
     1:   while (*curarg) {
     1:     char *arg = curarg[0];
     1: 
     1:     if (arg[0] == '-'
     1: #if defined(XP_WIN) || defined(XP_OS2)
     1:         || *arg == '/'
     1: #endif
     1:         ) {
     1:       ++arg;
     1:       if (*arg == '-')
     1:         ++arg;
     1: 
     1:       if (strimatch(aArg, arg)) {
 32011:         if (aRemArg)
     1:           RemoveArg(curarg);
     1:         if (!aParam) {
  3321:           ar = ARG_FOUND;
  3321:           break;
     1:         }
     1: 
     1:         if (*curarg) {
     1:           if (**curarg == '-'
     1: #if defined(XP_WIN) || defined(XP_OS2)
     1:               || **curarg == '/'
     1: #endif
     1:               )
     1:             return ARG_BAD;
     1: 
     1:           *aParam = *curarg;
 32011:           if (aRemArg)
     1:             RemoveArg(curarg);
  3321:           ar = ARG_FOUND;
  3321:           break;
     1:         }
     1:         return ARG_BAD;
     1:       }
     1:     }
     1: 
     1:     ++curarg;
     1:   }
     1: 
  3321:   if (aCheckOSInt && ar == ARG_FOUND) {
  3321:     ArgResult arOSInt = CheckArg("osint");
  3321:     if (arOSInt == ARG_FOUND) {
  3321:       ar = ARG_BAD;
  3321:       PR_fprintf(PR_STDERR, "Error: argument -osint is invalid\n");
  3321:     }
  3321:   }
  3321: 
  3321:   return ar;
     1: }
     1: 
     1: #if defined(XP_WIN)
     1: /**
     1:  * Check for a commandline flag from the windows shell and remove it from the
     1:  * argv used when restarting. Flags MUST be in the form -arg.
     1:  *
     1:  * @param aArg the parameter to check. Must be lowercase.
     1:  */
     1: static ArgResult
     1: CheckArgShell(const char* aArg)
     1: {
     1:   char **curarg = gRestartArgv + 1; // skip argv[0]
     1: 
     1:   while (*curarg) {
     1:     char *arg = curarg[0];
     1: 
     1:     if (arg[0] == '-') {
     1:       ++arg;
     1: 
     1:       if (strimatch(aArg, arg)) {
     1:         do {
     1:           *curarg = *(curarg + 1);
     1:           ++curarg;
     1:         } while (*curarg);
     1: 
     1:         --gRestartArgc;
     1: 
     1:         return ARG_FOUND;
     1:       }
     1:     }
     1: 
     1:     ++curarg;
     1:   }
     1: 
     1:   return ARG_NONE;
     1: }
     1: 
     1: /**
 15466:  * Enabled Native App Support to process DDE messages when the app needs to
 15466:  * restart and the app has been launched by the Windows shell to open an url.
 15466:  * When aWait is false this will process the DDE events manually. This prevents
 15466:  * Windows from displaying an error message due to the DDE message not being
 15466:  * acknowledged.
     1:  */
     1: static void
 79445: ProcessDDE(nsINativeAppSupport* aNative, bool aWait)
     1: {
     1:   // When the app is launched by the windows shell the windows shell
     1:   // expects the app to be available for DDE messages and if it isn't
     1:   // windows displays an error dialog. To prevent the error the DDE server
     1:   // is enabled and pending events are processed when the app needs to
     1:   // restart after it was launched by the shell with the requestpending
     1:   // argument. The requestpending pending argument is removed to
     1:   // differentiate it from being launched when an app restart is not
     1:   // required.
     1:   ArgResult ar;
     1:   ar = CheckArgShell("requestpending");
     1:   if (ar == ARG_FOUND) {
     1:     aNative->Enable(); // enable win32 DDE responses
 15466:     if (aWait) {
     1:       nsIThread *thread = NS_GetCurrentThread();
     1:       // This is just a guesstimate based on testing different values.
     1:       // If count is 8 or less windows will display an error dialog.
108991:       int32_t count = 20;
     1:       while(--count >= 0) {
     1:         NS_ProcessNextEvent(thread);
     1:         PR_Sleep(PR_MillisecondsToInterval(1));
     1:       }
     1:     }
     1:   }
 15466: }
     1: #endif
     1: 
 79445: bool gSafeMode = false;
     1: 
     1: /**
     1:  * The nsXULAppInfo object implements nsIFactory so that it can be its own
     1:  * singleton.
     1:  */
     1: class nsXULAppInfo : public nsIXULAppInfo,
     1: #ifdef XP_WIN
     1:                      public nsIWinAppHelper,
     1: #endif
  4389: #ifdef MOZ_CRASHREPORTER
   453:                      public nsICrashReporter,
   453: #endif
 58881:                      public nsIXULRuntime
     1: 
     1: {
     1: public:
 63906:   nsXULAppInfo() {}
     1:   NS_DECL_ISUPPORTS_INHERITED
     1:   NS_DECL_NSIXULAPPINFO
     1:   NS_DECL_NSIXULRUNTIME
  4389: #ifdef MOZ_CRASHREPORTER
   453:   NS_DECL_NSICRASHREPORTER
   453: #endif
     1: #ifdef XP_WIN
     1:   NS_DECL_NSIWINAPPHELPER
     1: #endif
     1: };
     1: 
     1: NS_INTERFACE_MAP_BEGIN(nsXULAppInfo)
     1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXULRuntime)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXULRuntime)
     1: #ifdef XP_WIN
     1:   NS_INTERFACE_MAP_ENTRY(nsIWinAppHelper)
     1: #endif
  4389: #ifdef MOZ_CRASHREPORTER
   453:   NS_INTERFACE_MAP_ENTRY(nsICrashReporter)
   453: #endif
 79812:   NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsIXULAppInfo, gAppData || 
 79812:                                      XRE_GetProcessType() == GeckoProcessType_Content)
     1: NS_INTERFACE_MAP_END
     1: 
     1: NS_IMETHODIMP_(nsrefcnt)
     1: nsXULAppInfo::AddRef()
     1: {
     1:   return 1;
     1: }
     1: 
     1: NS_IMETHODIMP_(nsrefcnt)
     1: nsXULAppInfo::Release()
     1: {
     1:   return 1;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsXULAppInfo::GetVendor(nsACString& aResult)
     1: {
 79812:   if (XRE_GetProcessType() == GeckoProcessType_Content) {
 79812:     NS_WARNING("Attempt to get unavailable information in content process.");
 79812:     return NS_ERROR_NOT_AVAILABLE;
 79812:   }
     1:   aResult.Assign(gAppData->vendor);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsXULAppInfo::GetName(nsACString& aResult)
     1: {
 79812:   if (XRE_GetProcessType() == GeckoProcessType_Content) {
 79812:     NS_WARNING("Attempt to get unavailable information in content process.");
 79812:     return NS_ERROR_NOT_AVAILABLE;
 79812:   }
     1:   aResult.Assign(gAppData->name);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsXULAppInfo::GetID(nsACString& aResult)
     1: {
 79812:   if (XRE_GetProcessType() == GeckoProcessType_Content) {
 79812:     NS_WARNING("Attempt to get unavailable information in content process.");
 79812:     return NS_ERROR_NOT_AVAILABLE;
 79812:   }
     1:   aResult.Assign(gAppData->ID);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsXULAppInfo::GetVersion(nsACString& aResult)
     1: {
 79812:   if (XRE_GetProcessType() == GeckoProcessType_Content) {
 79812:     ContentChild* cc = ContentChild::GetSingleton();
 79812:     aResult = cc->GetAppInfo().version;
 79812:     return NS_OK;
 79812:   }
     1:   aResult.Assign(gAppData->version);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsXULAppInfo::GetPlatformVersion(nsACString& aResult)
     1: {
  3676:   aResult.Assign(gToolkitVersion);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsXULAppInfo::GetAppBuildID(nsACString& aResult)
     1: {
 79812:   if (XRE_GetProcessType() == GeckoProcessType_Content) {
 79812:     ContentChild* cc = ContentChild::GetSingleton();
 79812:     aResult = cc->GetAppInfo().buildID;
 79812:     return NS_OK;
 79812:   }
     1:   aResult.Assign(gAppData->buildID);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsXULAppInfo::GetPlatformBuildID(nsACString& aResult)
     1: {
  3041:   aResult.Assign(gToolkitBuildID);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 98402: nsXULAppInfo::GetUAName(nsACString& aResult)
 98402: {
 98402:   if (XRE_GetProcessType() == GeckoProcessType_Content) {
 98402:     NS_WARNING("Attempt to get unavailable information in content process.");
 98402:     return NS_ERROR_NOT_AVAILABLE;
 98402:   }
 98402:   aResult.Assign(gAppData->UAName);
 98402: 
 98402:   return NS_OK;
 98402: }
 98402: 
 98402: NS_IMETHODIMP
 79445: nsXULAppInfo::GetLogConsoleErrors(bool *aResult)
     1: {
     1:   *aResult = gLogConsoleErrors;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsXULAppInfo::SetLogConsoleErrors(bool aValue)
     1: {
     1:   gLogConsoleErrors = aValue;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsXULAppInfo::GetInSafeMode(bool *aResult)
     1: {
     1:   *aResult = gSafeMode;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsXULAppInfo::GetOS(nsACString& aResult)
     1: {
     1:   aResult.AssignLiteral(OS_TARGET);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsXULAppInfo::GetXPCOMABI(nsACString& aResult)
     1: {
     1: #ifdef TARGET_XPCOM_ABI
     1:   aResult.AssignLiteral(TARGET_XPCOM_ABI);
     1:   return NS_OK;
     1: #else
     1:   return NS_ERROR_NOT_AVAILABLE;
     1: #endif
     1: }
     1: 
 24526: NS_IMETHODIMP
 24526: nsXULAppInfo::GetWidgetToolkit(nsACString& aResult)
 24526: {
 24526:   aResult.AssignLiteral(MOZ_WIDGET_TOOLKIT);
 24526:   return NS_OK;
 24526: }
 24526: 
 35860: // Ensure that the GeckoProcessType enum, defined in xpcom/build/nsXULAppAPI.h,
 35860: // is synchronized with the const unsigned longs defined in
 35860: // xpcom/system/nsIXULRuntime.idl.
 35860: #define SYNC_ENUMS(a,b) \
 94621:   MOZ_STATIC_ASSERT(nsIXULRuntime::PROCESS_TYPE_ ## a == \
 94621:                     static_cast<int>(GeckoProcessType_ ## b), \
 94621:                     "GeckoProcessType in nsXULAppAPI.h not synchronized with nsIXULRuntime.idl");
 35860: 
 35860: SYNC_ENUMS(DEFAULT, Default)
 35860: SYNC_ENUMS(PLUGIN, Plugin)
 35860: SYNC_ENUMS(CONTENT, Content)
 35963: SYNC_ENUMS(IPDLUNITTEST, IPDLUnitTest)
 35860: 
 35860: // .. and ensure that that is all of them:
 94621: MOZ_STATIC_ASSERT(GeckoProcessType_IPDLUnitTest + 1 == GeckoProcessType_End,
 94621:                   "Did not find the final GeckoProcessType");
 35860: 
 35860: NS_IMETHODIMP
108991: nsXULAppInfo::GetProcessType(uint32_t* aResult)
 35860: {
 35860:   NS_ENSURE_ARG_POINTER(aResult);
 35860:   *aResult = XRE_GetProcessType();
 35860:   return NS_OK;
 35860: }
 35860: 
 33900: NS_IMETHODIMP
 48425: nsXULAppInfo::EnsureContentProcess()
 48425: {
 48425:   if (XRE_GetProcessType() != GeckoProcessType_Default)
 48425:     return NS_ERROR_NOT_AVAILABLE;
 48425: 
 76840:   unused << ContentParent::GetNewOrUsed();
 48425:   return NS_OK;
 48425: }
 48425: 
 48425: NS_IMETHODIMP
 33900: nsXULAppInfo::InvalidateCachesOnRestart()
 33900: {
 33900:   nsCOMPtr<nsIFile> file;
 33900:   nsresult rv = NS_GetSpecialDirectory(NS_APP_PROFILE_DIR_STARTUP, 
 33900:                                        getter_AddRefs(file));
 33900:   if (NS_FAILED(rv))
 33900:     return rv;
 33900:   if (!file)
 33900:     return NS_ERROR_NOT_AVAILABLE;
 33900:   
 33900:   file->AppendNative(FILE_COMPATIBILITY_INFO);
 33900: 
 33900:   nsINIParser parser;
101111:   rv = parser.Init(file);
 33900:   if (NS_FAILED(rv)) {
 33900:     // This fails if compatibility.ini is not there, so we'll
 33900:     // flush the caches on the next restart anyways.
 33900:     return NS_OK;
 33900:   }
 33900:   
110974:   nsAutoCString buf;
 33900:   rv = parser.GetString("Compatibility", "InvalidateCaches", buf);
 33900:   
 33900:   if (NS_FAILED(rv)) {
106838:     PRFileDesc *fd = nullptr;
101111:     file->OpenNSPRFileDesc(PR_RDWR | PR_APPEND, 0600, &fd);
 33900:     if (!fd) {
 33900:       NS_ERROR("could not create output stream");
 33900:       return NS_ERROR_NOT_AVAILABLE;
 33900:     }
 33900:     static const char kInvalidationHeader[] = NS_LINEBREAK "InvalidateCaches=1" NS_LINEBREAK;
107798:     PR_Write(fd, kInvalidationHeader, sizeof(kInvalidationHeader) - 1);
 33900:     PR_Close(fd);
 33900:   }
 33900:   return NS_OK;
 33900: }
 33900: 
 89683: NS_IMETHODIMP
110762: nsXULAppInfo::GetReplacedLockTime(PRTime *aReplacedLockTime)
 89683: {
 89683:   if (!gProfileLock)
 89683:     return NS_ERROR_NOT_AVAILABLE;
 89683:   gProfileLock->GetReplacedLockTime(aReplacedLockTime);
 89683:   return NS_OK;
 89683: }
 89683: 
106292: NS_IMETHODIMP
106292: nsXULAppInfo::GetLastRunCrashID(nsAString &aLastRunCrashID)
106292: {
106292: #ifdef MOZ_CRASHREPORTER
106292:   CrashReporter::GetLastRunCrashID(aLastRunCrashID);
106292:   return NS_OK;
106292: #else
106292:   return NS_ERROR_NOT_IMPLEMENTED;
106292: #endif
106292: }
106292: 
     1: #ifdef XP_WIN
  6144: // Matches the enum in WinNT.h for the Vista SDK but renamed so that we can
  6144: // safely build with the Vista SDK and without it.
  6144: typedef enum 
  6144: {
  6144:   VistaTokenElevationTypeDefault = 1,
  6144:   VistaTokenElevationTypeFull,
  6144:   VistaTokenElevationTypeLimited
  6144: } VISTA_TOKEN_ELEVATION_TYPE;
  6144: 
  6144: // avoid collision with TokeElevationType enum in WinNT.h
  6144: // of the Vista SDK
  6144: #define VistaTokenElevationType static_cast< TOKEN_INFORMATION_CLASS >( 18 )
  6144: 
  6144: NS_IMETHODIMP
 79445: nsXULAppInfo::GetUserCanElevate(bool *aUserCanElevate)
  6144: {
  6144:   HANDLE hToken;
  6144: 
  6144:   VISTA_TOKEN_ELEVATION_TYPE elevationType;
  6144:   DWORD dwSize; 
  6144: 
  6144:   if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken) ||
  6144:       !GetTokenInformation(hToken, VistaTokenElevationType, &elevationType,
  6144:                            sizeof(elevationType), &dwSize)) {
 80486:     *aUserCanElevate = false;
  6144:   } 
  6144:   else {
  6144:     // The possible values returned for elevationType and their meanings are:
  6144:     //   TokenElevationTypeDefault: The token does not have a linked token 
  6144:     //     (e.g. UAC disabled or a standard user, so they can't be elevated)
  6144:     //   TokenElevationTypeFull: The token is linked to an elevated token 
  6144:     //     (e.g. UAC is enabled and the user is already elevated so they can't
  6144:     //      be elevated again)
  6144:     //   TokenElevationTypeLimited: The token is linked to a limited token 
  6144:     //     (e.g. UAC is enabled and the user is not elevated, so they can be
  6144:     //      elevated)
  6144:     *aUserCanElevate = (elevationType == VistaTokenElevationTypeLimited);
  6144:   }
  6144: 
  6144:   if (hToken)
  6144:     CloseHandle(hToken);
  6144: 
  6144:   return NS_OK;
  6144: }
     1: #endif
     1: 
  4389: #ifdef MOZ_CRASHREPORTER
   453: NS_IMETHODIMP
 79445: nsXULAppInfo::GetEnabled(bool *aEnabled)
 26867: {
 26867:   *aEnabled = CrashReporter::GetEnabled();
 26867:   return NS_OK;
 26867: }
 26867: 
 26867: NS_IMETHODIMP
 79445: nsXULAppInfo::SetEnabled(bool aEnabled)
 26867: {
 26867:   if (aEnabled) {
 26867:     if (CrashReporter::GetEnabled())
 26867:       // no point in erroring for double-enabling
 26867:       return NS_OK;
 26867: 
101111:     nsCOMPtr<nsIFile> xreDirectory;
 26867:     if (gAppData) {
 26867:       xreDirectory = gAppData->xreDirectory;
 26867:     }
 26867:     else {
 26867:       // We didn't get started through XRE_Main, probably
 26867:       nsCOMPtr<nsIFile> greDir;
 26867:       NS_GetSpecialDirectory(NS_GRE_DIR, getter_AddRefs(greDir));
 26867:       if (!greDir)
 26867:         return NS_ERROR_FAILURE;
 26867: 
 26867:       xreDirectory = do_QueryInterface(greDir);
 26867:       if (!xreDirectory)
 26867:         return NS_ERROR_FAILURE;
 26867:     }
 26867:     return CrashReporter::SetExceptionHandler(xreDirectory, true);
 26867:   }
 26867:   else {
 26867:     if (!CrashReporter::GetEnabled())
 26867:       // no point in erroring for double-disabling
 26867:       return NS_OK;
 26867: 
 26867:     return CrashReporter::UnsetExceptionHandler();
 26867:   }
 26867: }
 26867: 
 26867: NS_IMETHODIMP
 26867: nsXULAppInfo::GetServerURL(nsIURL** aServerURL)
 26867: {
 26867:   if (!CrashReporter::GetEnabled())
 26867:     return NS_ERROR_NOT_INITIALIZED;
 26867: 
110974:   nsAutoCString data;
 26867:   if (!CrashReporter::GetServerURL(data)) {
 26867:     return NS_ERROR_FAILURE;
 26867:   }
 26867:   nsCOMPtr<nsIURI> uri;
 26867:   NS_NewURI(getter_AddRefs(uri), data);
 26867:   if (!uri)
 26867:     return NS_ERROR_FAILURE;
 26867: 
 26867:   nsCOMPtr<nsIURL> url;
 26867:   url = do_QueryInterface(uri);
 26867:   NS_ADDREF(*aServerURL = url);
 26867: 
 26867:   return NS_OK;
 26867: }
 26867: 
 26867: NS_IMETHODIMP
 26867: nsXULAppInfo::SetServerURL(nsIURL* aServerURL)
 26867: {
 79445:   bool schemeOk;
 26867:   // only allow https or http URLs
 26867:   nsresult rv = aServerURL->SchemeIs("https", &schemeOk);
 26867:   NS_ENSURE_SUCCESS(rv, rv);
 26867:   if (!schemeOk) {
 26867:     rv = aServerURL->SchemeIs("http", &schemeOk);
 26867:     NS_ENSURE_SUCCESS(rv, rv);
 26867: 
 26867:     if (!schemeOk)
 26867:       return NS_ERROR_INVALID_ARG;
 26867:   }
110974:   nsAutoCString spec;
 26867:   rv = aServerURL->GetSpec(spec);
 26867:   NS_ENSURE_SUCCESS(rv, rv);
 26867:   
 26867:   return CrashReporter::SetServerURL(spec);
 26867: }
 26867: 
 26867: NS_IMETHODIMP
101111: nsXULAppInfo::GetMinidumpPath(nsIFile** aMinidumpPath)
 26867: {
 26867:   if (!CrashReporter::GetEnabled())
 26867:     return NS_ERROR_NOT_INITIALIZED;
 26867: 
 26867:   nsAutoString path;
 26867:   if (!CrashReporter::GetMinidumpPath(path))
 26867:     return NS_ERROR_FAILURE;
 26867: 
 80486:   nsresult rv = NS_NewLocalFile(path, false, aMinidumpPath);
 26867:   NS_ENSURE_SUCCESS(rv, rv);
 26867:   return NS_OK;
 26867: }
 26867: 
 26867: NS_IMETHODIMP
101111: nsXULAppInfo::SetMinidumpPath(nsIFile* aMinidumpPath)
 26867: {
 26867:   nsAutoString path;
 26867:   nsresult rv = aMinidumpPath->GetPath(path);
 26867:   NS_ENSURE_SUCCESS(rv, rv);
 26867:   return CrashReporter::SetMinidumpPath(path);
 26867: }
 26867: 
 26867: NS_IMETHODIMP
   453: nsXULAppInfo::AnnotateCrashReport(const nsACString& key,
   453:                                   const nsACString& data)
   453: {
   453:   return CrashReporter::AnnotateCrashReport(key, data);
   453: }
 11440: 
 11440: NS_IMETHODIMP
 16248: nsXULAppInfo::AppendAppNotesToCrashReport(const nsACString& data)
 16248: {
 16248:   return CrashReporter::AppendAppNotesToCrashReport(data);
 16248: }
 16248: 
 16248: NS_IMETHODIMP
108991: nsXULAppInfo::RegisterAppMemory(uint64_t pointer,
108991:                                 uint64_t len)
 73559: {
 73559:   return CrashReporter::RegisterAppMemory((void *)pointer, len);
 73559: }
 73559: 
 73559: NS_IMETHODIMP
 11440: nsXULAppInfo::WriteMinidumpForException(void* aExceptionInfo)
 11440: {
 11440: #ifdef XP_WIN32
 11440:   return CrashReporter::WriteMinidumpForException(static_cast<EXCEPTION_POINTERS*>(aExceptionInfo));
 11440: #else
 11440:   return NS_ERROR_NOT_IMPLEMENTED;
 11440: #endif
 11440: }
   453: 
 18492: NS_IMETHODIMP
 18492: nsXULAppInfo::AppendObjCExceptionInfoToAppNotes(void* aException)
 18492: {
 18492: #ifdef XP_MACOSX
 18492:   return CrashReporter::AppendObjCExceptionInfoToAppNotes(aException);
 18492: #else
 18492:   return NS_ERROR_NOT_IMPLEMENTED;
 18492: #endif
 18492: }
 38030: 
 38030: NS_IMETHODIMP
 79445: nsXULAppInfo::GetSubmitReports(bool* aEnabled)
 38030: {
 38030:   return CrashReporter::GetSubmitReports(aEnabled);
 38030: }
 38030: 
 38030: NS_IMETHODIMP
 79445: nsXULAppInfo::SetSubmitReports(bool aEnabled)
 38030: {
 38030:   return CrashReporter::SetSubmitReports(aEnabled);
 38030: }
 38030: 
 18494: #endif
 18492: 
     1: static const nsXULAppInfo kAppInfo;
 46997: static nsresult AppInfoConstructor(nsISupports* aOuter,
     1:                                    REFNSIID aIID, void **aResult)
     1: {
     1:   NS_ENSURE_NO_AGGREGATION(aOuter);
     1: 
  3233:   return const_cast<nsXULAppInfo*>(&kAppInfo)->
     1:     QueryInterface(aIID, aResult);
     1: }
     1: 
 79445: bool gLogConsoleErrors
     1: #ifdef DEBUG
 80486:          = true;
     1: #else
 80486:          = false;
     1: #endif
     1: 
     1: #define NS_ENSURE_TRUE_LOG(x, ret)               \
     1:   PR_BEGIN_MACRO                                 \
     1:   if (NS_UNLIKELY(!(x))) {                       \
     1:     NS_WARNING("NS_ENSURE_TRUE(" #x ") failed"); \
 80486:     gLogConsoleErrors = true;                 \
     1:     return ret;                                  \
     1:   }                                              \
     1:   PR_END_MACRO
     1: 
     1: #define NS_ENSURE_SUCCESS_LOG(res, ret)          \
     1:   NS_ENSURE_TRUE_LOG(NS_SUCCEEDED(res), ret)
     1: 
     1: /**
     1:  * Because we're starting/stopping XPCOM several times in different scenarios,
     1:  * this class is a stack-based critter that makes sure that XPCOM is shut down
     1:  * during early returns.
     1:  */
     1: 
     1: class ScopedXPCOMStartup
     1: {
     1: public:
     1:   ScopedXPCOMStartup() :
106838:     mServiceManager(nullptr) { }
     1:   ~ScopedXPCOMStartup();
     1: 
     1:   nsresult Initialize();
     1:   nsresult SetWindowCreator(nsINativeAppSupport* native);
     1: 
 46997:   static nsresult CreateAppSupport(nsISupports* aOuter, REFNSIID aIID, void** aResult);
 46997: 
     1: private:
     1:   nsIServiceManager* mServiceManager;
 46997:   static nsINativeAppSupport* gNativeAppSupport;
     1: };
     1: 
     1: ScopedXPCOMStartup::~ScopedXPCOMStartup()
     1: {
 47027:   NS_IF_RELEASE(gNativeAppSupport);
 46997: 
     1:   if (mServiceManager) {
 41062: #ifdef XP_MACOSX
 41062:     // On OS X, we need a pool to catch cocoa objects that are autoreleased
 41062:     // during teardown.
 41062:     mozilla::MacAutoreleasePool pool;
 41062: #endif
 41062: 
  8897:     nsCOMPtr<nsIAppStartup> appStartup (do_GetService(NS_APPSTARTUP_CONTRACTID));
  8897:     if (appStartup)
  8897:       appStartup->DestroyHiddenWindow();
  8897: 
     1:     gDirServiceProvider->DoShutdown();
     1: 
     1:     WriteConsoleLog();
     1: 
     1:     NS_ShutdownXPCOM(mServiceManager);
106838:     mServiceManager = nullptr;
     1:   }
     1: }
     1: 
     1: // {95d89e3e-a169-41a3-8e56-719978e15b12}
     1: #define APPINFO_CID \
     1:   { 0x95d89e3e, 0xa169, 0x41a3, { 0x8e, 0x56, 0x71, 0x99, 0x78, 0xe1, 0x5b, 0x12 } }
     1: 
 46997: // {0C4A446C-EE82-41f2-8D04-D366D2C7A7D4}
 46997: static const nsCID kNativeAppSupportCID =
 46997:   { 0xc4a446c, 0xee82, 0x41f2, { 0x8d, 0x4, 0xd3, 0x66, 0xd2, 0xc7, 0xa7, 0xd4 } };
 46997: 
 46997: // {5F5E59CE-27BC-47eb-9D1F-B09CA9049836}
 46997: static const nsCID kProfileServiceCID =
 46997:   { 0x5f5e59ce, 0x27bc, 0x47eb, { 0x9d, 0x1f, 0xb0, 0x9c, 0xa9, 0x4, 0x98, 0x36 } };
 46997: 
 46997: static already_AddRefed<nsIFactory>
 46997: ProfileServiceFactoryConstructor(const mozilla::Module& module, const mozilla::Module::CIDEntry& entry)
     1: {
 46997:   nsCOMPtr<nsIFactory> factory;
 46997:   NS_NewToolkitProfileFactory(getter_AddRefs(factory));
 46997:   return factory.forget();
 46997: }
 46997: 
 46997: NS_DEFINE_NAMED_CID(APPINFO_CID);
 46997: 
 46997: static const mozilla::Module::CIDEntry kXRECIDs[] = {
 46997:   { &kAPPINFO_CID, false, NULL, AppInfoConstructor },
 46997:   { &kProfileServiceCID, false, ProfileServiceFactoryConstructor, NULL },
 46997:   { &kNativeAppSupportCID, false, NULL, ScopedXPCOMStartup::CreateAppSupport },
 46997:   { NULL }
 46997: };
 46997: 
 46997: static const mozilla::Module::ContractIDEntry kXREContracts[] = {
 46997:   { XULAPPINFO_SERVICE_CONTRACTID, &kAPPINFO_CID },
 46997:   { XULRUNTIME_SERVICE_CONTRACTID, &kAPPINFO_CID },
 47028: #ifdef MOZ_CRASHREPORTER
 46997:   { NS_CRASHREPORTER_CONTRACTID, &kAPPINFO_CID },
 47028: #endif
 46997:   { NS_PROFILESERVICE_CONTRACTID, &kProfileServiceCID },
 46997:   { NS_NATIVEAPPSUPPORT_CONTRACTID, &kNativeAppSupportCID },
 46997:   { NULL }
 46997: };
 46997: 
 46997: static const mozilla::Module kXREModule = {
 46997:   mozilla::Module::kVersion,
 46997:   kXRECIDs,
 46997:   kXREContracts
 46997: };
 46997: 
 46997: NSMODULE_DEFN(Apprunner) = &kXREModule;
 46997: 
     1: nsresult
     1: ScopedXPCOMStartup::Initialize()
     1: {
     1:   NS_ASSERTION(gDirServiceProvider, "Should not get here!");
     1: 
     1:   nsresult rv;
 42540: 
 46997:   rv = NS_InitXPCOM2(&mServiceManager, gDirServiceProvider->GetAppDir(),
 46997:                      gDirServiceProvider);
     1:   if (NS_FAILED(rv)) {
     1:     NS_ERROR("Couldn't start xpcom!");
106838:     mServiceManager = nullptr;
     1:   }
     1:   else {
     1:     nsCOMPtr<nsIComponentRegistrar> reg =
     1:       do_QueryInterface(mServiceManager);
     1:     NS_ASSERTION(reg, "Service Manager doesn't QI to Registrar.");
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: /**
     1:  * This is a little factory class that serves as a singleton-service-factory
     1:  * for the nativeappsupport object.
     1:  */
103727: class nsSingletonFactory MOZ_FINAL : public nsIFactory
     1: {
     1: public:
     1:   NS_DECL_ISUPPORTS
     1:   NS_DECL_NSIFACTORY
     1: 
     1:   nsSingletonFactory(nsISupports* aSingleton);
     1:   ~nsSingletonFactory() { }
     1: 
     1: private:
     1:   nsCOMPtr<nsISupports> mSingleton;
     1: };
     1: 
     1: nsSingletonFactory::nsSingletonFactory(nsISupports* aSingleton)
     1:   : mSingleton(aSingleton)
     1: {
     1:   NS_ASSERTION(mSingleton, "Singleton was null!");
     1: }
     1: 
     1: NS_IMPL_ISUPPORTS1(nsSingletonFactory, nsIFactory)
     1: 
     1: NS_IMETHODIMP
     1: nsSingletonFactory::CreateInstance(nsISupports* aOuter,
     1:                                    const nsIID& aIID,
     1:                                    void* *aResult)
     1: {
     1:   NS_ENSURE_NO_AGGREGATION(aOuter);
     1: 
     1:   return mSingleton->QueryInterface(aIID, aResult);
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsSingletonFactory::LockFactory(bool)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: /**
     1:  * Set our windowcreator on the WindowWatcher service.
     1:  */
     1: nsresult
     1: ScopedXPCOMStartup::SetWindowCreator(nsINativeAppSupport* native)
     1: {
     1:   nsresult rv;
     1: 
 46997:   NS_IF_ADDREF(gNativeAppSupport = native);
 42480: 
     1:   // Inform the chrome registry about OS accessibility
 42314:   nsCOMPtr<nsIToolkitChromeRegistry> cr =
 42314:     mozilla::services::GetToolkitChromeRegistryService();
 42480: 
     1:   if (cr)
     1:     cr->CheckForOSAccessibility();
     1: 
     1:   nsCOMPtr<nsIWindowCreator> creator (do_GetService(NS_APPSTARTUP_CONTRACTID));
     1:   if (!creator) return NS_ERROR_UNEXPECTED;
     1: 
     1:   nsCOMPtr<nsIWindowWatcher> wwatch
     1:     (do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   return wwatch->SetWindowCreator(creator);
     1: }
     1: 
 46997: /* static */ nsresult
 46997: ScopedXPCOMStartup::CreateAppSupport(nsISupports* aOuter, REFNSIID aIID, void** aResult)
 46997: {
 46997:   if (aOuter)
 46997:     return NS_ERROR_NO_AGGREGATION;
 46997: 
 46997:   if (!gNativeAppSupport)
 46997:     return NS_ERROR_NOT_INITIALIZED;
 46997: 
 46997:   return gNativeAppSupport->QueryInterface(aIID, aResult);
 46997: }
 46997: 
 46997: nsINativeAppSupport* ScopedXPCOMStartup::gNativeAppSupport;
 46997: 
     1: /**
  4295:  * A helper class which calls NS_LogInit/NS_LogTerm in its scope.
     1:  */
     1: class ScopedLogging
     1: {
     1: public:
     1:   ScopedLogging() { NS_LogInit(); }
     1:   ~ScopedLogging() { NS_LogTerm(); }
     1: };
     1: 
     1: static void DumpArbitraryHelp()
     1: {
     1:   nsresult rv;
     1: 
     1:   ScopedLogging log;
     1: 
     1:   {
     1:     ScopedXPCOMStartup xpcom;
     1:     xpcom.Initialize();
     1: 
     1:     nsCOMPtr<nsICommandLineRunner> cmdline
     1:       (do_CreateInstance("@mozilla.org/toolkit/command-line;1"));
     1:     if (!cmdline)
     1:       return;
     1: 
     1:     nsCString text;
     1:     rv = cmdline->GetHelpText(text);
     1:     if (NS_SUCCEEDED(rv))
     1:       printf("%s", text.get());
     1:   }
     1: }
     1: 
     1: // English text needs to go into a dtd file.
     1: // But when this is called we have no components etc. These strings must either be
     1: // here, or in a native resource file.
     1: static void
     1: DumpHelp()
     1: {
     1:   printf("Usage: %s [ options ... ] [URL]\n"
     1:          "       where options include:\n\n", gArgv[0]);
     1: 
     1: #ifdef MOZ_X11
     1:   printf("X11 options\n"
 33705:          "  --display=DISPLAY  X display to use\n"
 64501:          "  --sync             Make X calls synchronous\n");
     1: #endif
     1: #ifdef XP_UNIX
 33705:   printf("  --g-fatal-warnings Make all warnings fatal\n"
 18531:          "\n%s options\n", gAppData->name);
     1: #endif
     1: 
 33705:   printf("  -h or -help        Print this message.\n"
 33705:          "  -v or -version     Print %s version.\n"
 33705:          "  -P <profile>       Start with <profile>.\n"
 33705:          "  -migration         Start with migration wizard.\n"
 33705:          "  -ProfileManager    Start with ProfileManager.\n"
 89532:          "  -no-remote         Do not accept or send remote commands; implies -new-instance.\n"
 89532:          "  -new-instance      Open new instance, not a new window in running instance.\n"
 33705:          "  -UILocale <locale> Start with <locale> resources as UI Locale.\n"
 33705:          "  -safe-mode         Disables extensions and themes for this session.\n", gAppData->name);
     1: 
     1: #if defined(XP_WIN) || defined(XP_OS2)
 33705:   printf("  -console           Start %s with a debugging console.\n", gAppData->name);
     1: #endif
     1: 
     1:   // this works, but only after the components have registered.  so if you drop in a new command line handler, -help
     1:   // won't not until the second run.
     1:   // out of the bug, because we ship a component.reg file, it works correctly.
     1:   DumpArbitraryHelp();
     1: }
     1: 
110464: #if defined(DEBUG) && defined(XP_WIN)
     1: #ifdef DEBUG_warren
     1: #define _CRTDBG_MAP_ALLOC
110464: #endif
110464: // Set a CRT ReportHook function to capture and format MSCRT
110464: // warnings, errors and assertions.
110464: // See http://msdn.microsoft.com/en-US/library/74kabxyx(v=VS.80).aspx
110464: #include <stdio.h>
     1: #include <crtdbg.h>
110464: #include "mozilla/mozalloc_abort.h"
110464: static int MSCRTReportHook( int aReportType, char *aMessage, int *oReturnValue)
110464: {
110464:   *oReturnValue = 0; // continue execution
110464: 
110464:   // Do not use fprintf or other functions which may allocate
110464:   // memory from the heap which may be corrupted. Instead,
110464:   // use fputs to output the leading portion of the message
110464:   // and use mozalloc_abort to emit the remainder of the
110464:   // message.
110464: 
110464:   switch(aReportType) {
110464:   case 0:
110464:     fputs("\nWARNING: CRT WARNING", stderr);
110464:     fputs(aMessage, stderr);
110464:     fputs("\n", stderr);
110464:     break;
110464:   case 1:
110464:     fputs("\n###!!! ABORT: CRT ERROR ", stderr);
110464:     mozalloc_abort(aMessage);
110464:     break;
110464:   case 2:
110464:     fputs("\n###!!! ABORT: CRT ASSERT ", stderr);
110464:     mozalloc_abort(aMessage);
110464:     break;
110464:   }
110464: 
110464:   // do not invoke the debugger
110464:   return 1;
110464: }
110464: 
     1: #endif
     1: 
     1: static inline void
     1: DumpVersion()
     1: {
  8479:   printf("%s %s %s", 
  8479:          gAppData->vendor ? gAppData->vendor : "", gAppData->name, gAppData->version);
  8479:   if (gAppData->copyright)
  8479:       printf(", %s", gAppData->copyright);
  8479:   printf("\n");
     1: }
     1: 
     1: #ifdef MOZ_ENABLE_XREMOTE
     1: // use int here instead of a PR type since it will be returned
     1: // from main - just to keep types consistent
     1: static int
     1: HandleRemoteArgument(const char* remote, const char* aDesktopStartupID)
     1: {
     1:   nsresult rv;
     1:   ArgResult ar;
     1: 
     1:   const char *profile = 0;
110974:   nsAutoCString program(gAppData->name);
     1:   ToLowerCase(program);
     1:   const char *username = getenv("LOGNAME");
     1: 
 80486:   ar = CheckArg("p", false, &profile);
     1:   if (ar == ARG_BAD) {
     1:     PR_fprintf(PR_STDERR, "Error: argument -p requires a profile name\n");
     1:     return 1;
     1:   }
     1: 
106838:   const char *temp = nullptr;
 80486:   ar = CheckArg("a", false, &temp);
     1:   if (ar == ARG_BAD) {
     1:     PR_fprintf(PR_STDERR, "Error: argument -a requires an application name\n");
     1:     return 1;
     1:   } else if (ar == ARG_FOUND) {
     1:     program.Assign(temp);
     1:   }
     1: 
 80486:   ar = CheckArg("u", false, &username);
     1:   if (ar == ARG_BAD) {
     1:     PR_fprintf(PR_STDERR, "Error: argument -u requires a username\n");
     1:     return 1;
     1:   }
     1: 
     1:   XRemoteClient client;
     1:   rv = client.Init();
     1:   if (NS_FAILED(rv)) {
     1:     PR_fprintf(PR_STDERR, "Error: Failed to connect to X server.\n");
     1:     return 1;
     1:   }
     1: 
     1:   nsXPIDLCString response;
 79445:   bool success = false;
     1:   rv = client.SendCommand(program.get(), username, profile, remote,
     1:                           aDesktopStartupID, getter_Copies(response), &success);
     1:   // did the command fail?
     1:   if (NS_FAILED(rv)) {
     1:     PR_fprintf(PR_STDERR, "Error: Failed to send command: %s\n",
     1:                response ? response.get() : "No response included");
     1:     return 1;
     1:   }
     1: 
     1:   if (!success) {
     1:     PR_fprintf(PR_STDERR, "Error: No running window found\n");
     1:     return 2;
     1:   }
     1: 
     1:   return 0;
     1: }
     1: 
  4817: static RemoteResult
     1: RemoteCommandLine(const char* aDesktopStartupID)
     1: {
     1:   nsresult rv;
     1:   ArgResult ar;
     1: 
110974:   nsAutoCString program(gAppData->name);
     1:   ToLowerCase(program);
     1:   const char *username = getenv("LOGNAME");
     1: 
106838:   const char *temp = nullptr;
 80486:   ar = CheckArg("a", true, &temp);
     1:   if (ar == ARG_BAD) {
     1:     PR_fprintf(PR_STDERR, "Error: argument -a requires an application name\n");
  4817:     return REMOTE_ARG_BAD;
     1:   } else if (ar == ARG_FOUND) {
     1:     program.Assign(temp);
     1:   }
     1: 
 80486:   ar = CheckArg("u", true, &username);
     1:   if (ar == ARG_BAD) {
     1:     PR_fprintf(PR_STDERR, "Error: argument -u requires a username\n");
  4817:     return REMOTE_ARG_BAD;
     1:   }
     1: 
     1:   XRemoteClient client;
     1:   rv = client.Init();
     1:   if (NS_FAILED(rv))
  4817:     return REMOTE_NOT_FOUND;
     1:  
     1:   nsXPIDLCString response;
 79445:   bool success = false;
106838:   rv = client.SendCommandLine(program.get(), username, nullptr,
     1:                               gArgc, gArgv, aDesktopStartupID,
     1:                               getter_Copies(response), &success);
     1:   // did the command fail?
     1:   if (NS_FAILED(rv) || !success)
  4817:     return REMOTE_NOT_FOUND;
  4817: 
  4817:   return REMOTE_FOUND;
     1: }
     1: #endif // MOZ_ENABLE_XREMOTE
     1: 
 74212: void
101111: XRE_InitOmnijar(nsIFile* greOmni, nsIFile* appOmni)
 74212: {
 74212:   mozilla::Omnijar::Init(greOmni, appOmni);
 74212: }
 74212: 
     1: nsresult
101111: XRE_GetBinaryPath(const char* argv0, nsIFile* *aResult)
     1: {
 71935:   return mozilla::BinaryPath::GetFile(argv0, aResult);
     1: }
     1: 
     1: #ifdef XP_WIN
     1: #include "nsWindowsRestart.cpp"
 23244: #include <shellapi.h>
 61203: 
 61203: typedef BOOL (WINAPI* SetProcessDEPPolicyFunc)(DWORD dwFlags);
     1: #endif
     1: 
 20303: #if defined(XP_OS2) && (__KLIBC__ == 0 && __KLIBC_MINOR__ >= 6) // broken kLibc
  3706: // Copy the environment maintained by the C library into an ASCIIZ array
  3706: // that can be used to pass it on to the OS/2 Dos* APIs (which otherwise
  3706: // don't know anything about the stuff set by PR_SetEnv() or setenv()).
  3706: char *createEnv()
  3706: {
  3706:   // just allocate the maximum amount (24 kB = 0x60000 bytes), to be able to
  3706:   // copy the existing environment
  3706:   char *env = (char *)calloc(0x6000, sizeof(char));
  3706:   if (!env) {
  3706:     return NULL;
  3706:   }
  3706: 
  3706:   // walk along the environ string array of the C library and copy
  3706:   // everything (that fits) into the output environment array, leaving
  3706:   // null bytes between the entries
  3706:   char *penv = env; // movable pointer to result environment ASCIIZ array
  3706:   int i = 0, space = 0x6000;
  3706:   while (environ[i] && environ[i][0]) {
  3706:     int len = strlen(environ[i]);
  3706:     if (space - len <= 0) {
  3706:       break;
  3706:     }
  3706:     strcpy(penv, environ[i]);
  3706:     i++; // next environment variable
  3706:     penv += len + 1; // jump to after next null byte
  3706:     space -= len - 1; // subtract consumed length from usable space
  3706:   }
  3706: 
  3706:   return env;
  3706: }
  3706: 
  3706: // OS2LaunchChild() is there to replace _execv() which is broken in the C
  3706: // runtime library that comes with GCC 3.3.5 on OS/2. It uses createEnv()
  3706: // to copy the process environment and add necessary variables
  3706: //
  3706: // returns -1 on failure and 0 on success
  3706: int OS2LaunchChild(const char *aExePath, int aArgc, char **aArgv)
  3706: {
  3706:   // find total length of aArgv
  3706:   int len = 0;
  3706:   for (int i = 0; i < aArgc; i++) {
  3706:     len += strlen(aArgv[i]) + 1; // plus space in between
  3706:   }
  3706:   len++; // leave space for null byte at end
  3706:   // allocate enough space for all strings and nulls,
  3706:   // calloc helpfully initializes to null
  3706:   char *args = (char *)calloc(len, sizeof(char));
  3706:   if (!args) {
  3706:     return -1;
  3706:   }
  3706:   char *pargs = args; // extra pointer to after the last argument
  3706:   // build argument list in the format the DosStartSession() wants,
  3706:   // adding spaces between the arguments
  3706:   for (int i = 0; i < aArgc; i++, *pargs++ = ' ') {
  3706:     strcpy(pargs, aArgv[i]);
  3706:     pargs += strlen(aArgv[i]);
  3706:   }
  3706:   if (aArgc > 1) {
  3706:     *(pargs-1) = '\0'; // replace last space
  3706:   }
  3706:   *pargs = '\0';
  3706:   // make sure that the program is separated by null byte
  3706:   pargs = strchr(args, ' ');
  3706:   if (pargs) {
  3706:     *pargs = '\0';
  3706:   }
  3706: 
  3706:   char *env = createEnv();
  3706: 
  3706:   char error[CCHMAXPATH] = { 0 };
  3706:   RESULTCODES crc = { 0 };
  3706:   ULONG rc = DosExecPgm(error, sizeof(error), EXEC_ASYNC, args, env,
  3706:                         &crc, (PSZ)aExePath);
  3706:   free(args); // done with the arguments
  3706:   if (env) {
  3706:     free(env);
  3706:   }
  3706:   if (rc != NO_ERROR) {
  3706:     return -1;
  3706:   }
  3706: 
  3706:   return 0;
  3706: }
  3706: #endif
  3706: 
     1: // If aBlankCommandLine is true, then the application will be launched with a
     1: // blank command line instead of being launched with the same command line that
     1: // it was initially started with.
     1: static nsresult LaunchChild(nsINativeAppSupport* aNative,
 79445:                             bool aBlankCommandLine = false)
     1: {
     1:   aNative->Quit(); // release DDE mutex, if we're holding it
     1: 
     1:   // Restart this process by exec'ing it into the current process
     1:   // if supported by the platform.  Otherwise, use NSPR.
     1: 
 75328: #ifdef MOZ_JPROF
 75328:   // make sure JPROF doesn't think we're E10s
 75328:   unsetenv("JPROF_SLAVE");
 75328: #endif
 75328: 
     1:   if (aBlankCommandLine) {
 47852: #if defined(MOZ_WIDGET_QT)
 47852:     // Remove only arguments not given to Qt
 47852:     gRestartArgc = gQtOnlyArgc;
 47852:     gRestartArgv = gQtOnlyArgv;
 47852: #else
  6903:     gRestartArgc = 1;
106838:     gRestartArgv[gRestartArgc] = nullptr;
 47852: #endif
     1:   }
     1: 
 41012:   SaveToEnv("MOZ_LAUNCHED_CHILD=1");
     1: 
 82142: #if defined(MOZ_WIDGET_ANDROID)
 43080:   mozilla::AndroidBridge::Bridge()->ScheduleRestart();
 43080: #else
     1: #if defined(XP_MACOSX)
 80486:   CommandLineServiceMac::SetupMacCommandLine(gRestartArgc, gRestartArgv, true);
108991:   uint32_t restartMode = 0;
 62098:   restartMode = gRestartMode;
 62098:   LaunchChildMac(gRestartArgc, gRestartArgv, restartMode);
     1: #else
101111:   nsCOMPtr<nsIFile> lf;
     1:   nsresult rv = XRE_GetBinaryPath(gArgv[0], getter_AddRefs(lf));
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
  9738: #if defined(XP_WIN)
  9738:   nsAutoString exePath;
  9738:   rv = lf->GetPath(exePath);
  9738:   if (NS_FAILED(rv))
  9738:     return rv;
  9738: 
 23244:   if (!WinLaunchChild(exePath.get(), gRestartArgc, gRestartArgv))
  9738:     return NS_ERROR_FAILURE;
  9738: 
  9738: #else
110974:   nsAutoCString exePath;
     1:   rv = lf->GetNativePath(exePath);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
 20303: #if defined(XP_OS2) && (__KLIBC__ == 0 && __KLIBC_MINOR__ >= 6)
 20303:   // implementation of _execv() is broken with kLibc 0.6.x and later
  3706:   if (OS2LaunchChild(exePath.get(), gRestartArgc, gRestartArgv) == -1)
  3706:     return NS_ERROR_FAILURE;
     1: #elif defined(XP_OS2)
     1:   if (_execv(exePath.get(), gRestartArgv) == -1)
     1:     return NS_ERROR_FAILURE;
     1: #elif defined(XP_UNIX)
     1:   if (execv(exePath.get(), gRestartArgv) == -1)
     1:     return NS_ERROR_FAILURE;
     1: #else
     1:   PRProcess* process = PR_CreateProcess(exePath.get(), gRestartArgv,
106838:                                         nullptr, nullptr);
     1:   if (!process) return NS_ERROR_FAILURE;
     1: 
108991:   int32_t exitCode;
     1:   PRStatus failed = PR_WaitProcess(process, &exitCode);
     1:   if (failed || exitCode)
     1:     return NS_ERROR_FAILURE;
  9738: #endif // XP_OS2 series
  9738: #endif // WP_WIN
  9738: #endif // WP_MACOSX
 82142: #endif // MOZ_WIDGET_ANDROID
     1: 
     1:   return NS_ERROR_LAUNCHED_CHILD_PROCESS;
     1: }
     1: 
     1: static const char kProfileProperties[] =
     1:   "chrome://mozapps/locale/profile/profileSelection.properties";
     1: 
     1: static nsresult
101111: ProfileLockedDialog(nsIFile* aProfileDir, nsIFile* aProfileLocalDir,
     1:                     nsIProfileUnlocker* aUnlocker,
     1:                     nsINativeAppSupport* aNative, nsIProfileLock* *aResult)
     1: {
     1:   nsresult rv;
     1: 
     1:   ScopedXPCOMStartup xpcom;
     1:   rv = xpcom.Initialize();
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 46997:   rv = xpcom.SetWindowCreator(aNative);
     1:   NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
     1:   { //extra scoping is needed so we release these components before xpcom shutdown
 42314:     nsCOMPtr<nsIStringBundleService> sbs =
 42314:       mozilla::services::GetStringBundleService();
     1:     NS_ENSURE_TRUE(sbs, NS_ERROR_FAILURE);
     1: 
     1:     nsCOMPtr<nsIStringBundle> sb;
     1:     sbs->CreateBundle(kProfileProperties, getter_AddRefs(sb));
     1:     NS_ENSURE_TRUE_LOG(sbs, NS_ERROR_FAILURE);
     1: 
     1:     NS_ConvertUTF8toUTF16 appName(gAppData->name);
     1:     const PRUnichar* params[] = {appName.get(), appName.get()};
     1: 
     1:     nsXPIDLString killMessage;
     1: #ifndef XP_MACOSX
     1:     static const PRUnichar kRestartNoUnlocker[] = {'r','e','s','t','a','r','t','M','e','s','s','a','g','e','N','o','U','n','l','o','c','k','e','r','\0'}; // "restartMessageNoUnlocker"
     1:     static const PRUnichar kRestartUnlocker[] = {'r','e','s','t','a','r','t','M','e','s','s','a','g','e','U','n','l','o','c','k','e','r','\0'}; // "restartMessageUnlocker"
     1: #else
     1:     static const PRUnichar kRestartNoUnlocker[] = {'r','e','s','t','a','r','t','M','e','s','s','a','g','e','N','o','U','n','l','o','c','k','e','r','M','a','c','\0'}; // "restartMessageNoUnlockerMac"
     1:     static const PRUnichar kRestartUnlocker[] = {'r','e','s','t','a','r','t','M','e','s','s','a','g','e','U','n','l','o','c','k','e','r','M','a','c','\0'}; // "restartMessageUnlockerMac"
     1: #endif
     1: 
     1:     sb->FormatStringFromName(aUnlocker ? kRestartUnlocker : kRestartNoUnlocker,
     1:                              params, 2, getter_Copies(killMessage));
     1: 
     1:     nsXPIDLString killTitle;
     1:     sb->FormatStringFromName(NS_LITERAL_STRING("restartTitle").get(),
     1:                              params, 1, getter_Copies(killTitle));
     1: 
     1:     if (!killMessage || !killTitle)
     1:       return NS_ERROR_FAILURE;
     1: 
     1:     nsCOMPtr<nsIPromptService> ps
     1:       (do_GetService(NS_PROMPTSERVICE_CONTRACTID));
     1:     NS_ENSURE_TRUE(ps, NS_ERROR_FAILURE);
     1: 
     1:     if (aUnlocker) {
108991:       const uint32_t flags =
 77263:         (nsIPromptService::BUTTON_TITLE_CANCEL * 
 77263:          nsIPromptService::BUTTON_POS_0) +
 77263:         (nsIPromptService::BUTTON_TITLE_IS_STRING * 
 77263:          nsIPromptService::BUTTON_POS_1) +
     1:         nsIPromptService::BUTTON_POS_1_DEFAULT;
     1: 
108991:       int32_t button;
 71407:       // The actual value is irrelevant but we shouldn't be handing out
 71407:       // malformed JSBools to XPConnect.
 79445:       bool checkState = false;
116308: #ifdef MOZ_WIDGET_ANDROID
116308:       mozilla::AndroidBridge::Bridge()->KillAnyZombies();
116308:       button = 1;
116308: #else
106838:       rv = ps->ConfirmEx(nullptr, killTitle, killMessage, flags,
106838:                          killTitle, nullptr, nullptr, nullptr, 
 77263:                          &checkState, &button);
     1:       NS_ENSURE_SUCCESS_LOG(rv, rv);
116308: #endif
     1: 
 77263:       if (button == 1) {
     1:         rv = aUnlocker->Unlock(nsIProfileUnlocker::FORCE_QUIT);
 77263:         if (NS_FAILED(rv)) 
 77263:           return rv;
 77263: 
 77263:         return NS_LockProfilePath(aProfileDir, aProfileLocalDir, 
106838:                                   nullptr, aResult);
 77263:       }
 77263:     } else {
116308: #ifdef MOZ_WIDGET_ANDROID
119334:       if (mozilla::AndroidBridge::Bridge()->UnlockProfile()) {
119334:         return NS_LockProfilePath(aProfileDir, aProfileLocalDir, 
119334:                                   nullptr, aResult);
119334:       }
116308: #else
106838:       rv = ps->Alert(nullptr, killTitle, killMessage);
 77263:       NS_ENSURE_SUCCESS_LOG(rv, rv);
116308: #endif
     1:     }
     1: 
     1:     return NS_ERROR_ABORT;
     1:   }
     1: }
     1: 
 99566: 
 39026: static nsresult
 39026: ProfileMissingDialog(nsINativeAppSupport* aNative)
 39026: {
 39026:   nsresult rv;
 39026: 
 39026:   ScopedXPCOMStartup xpcom;
 39026:   rv = xpcom.Initialize();
 39026:   NS_ENSURE_SUCCESS(rv, rv);
 39026: 
 46997:   rv = xpcom.SetWindowCreator(aNative);
 39026:   NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
 39026: 
 39026:   { //extra scoping is needed so we release these components before xpcom shutdown
 42314:     nsCOMPtr<nsIStringBundleService> sbs =
 42314:       mozilla::services::GetStringBundleService();
 39026:     NS_ENSURE_TRUE(sbs, NS_ERROR_FAILURE);
 39026:   
 39026:     nsCOMPtr<nsIStringBundle> sb;
 39026:     sbs->CreateBundle(kProfileProperties, getter_AddRefs(sb));
 39026:     NS_ENSURE_TRUE_LOG(sbs, NS_ERROR_FAILURE);
 39026:   
 39026:     NS_ConvertUTF8toUTF16 appName(gAppData->name);
 39026:     const PRUnichar* params[] = {appName.get(), appName.get()};
 39026:   
 39026:     nsXPIDLString missingMessage;
 39026:   
 39026:     // profileMissing  
 39026:     static const PRUnichar kMissing[] = {'p','r','o','f','i','l','e','M','i','s','s','i','n','g','\0'};
 39026:     sb->FormatStringFromName(kMissing, params, 2, getter_Copies(missingMessage));
 39026:   
 39026:     nsXPIDLString missingTitle;
 39026:     sb->FormatStringFromName(NS_LITERAL_STRING("profileMissingTitle").get(),
 39026:                              params, 1, getter_Copies(missingTitle));
 39026:   
 39026:     if (missingMessage && missingTitle) {
 39026:       nsCOMPtr<nsIPromptService> ps
 39026:         (do_GetService(NS_PROMPTSERVICE_CONTRACTID));
 39026:       NS_ENSURE_TRUE(ps, NS_ERROR_FAILURE);
 39026:   
106838:       ps->Alert(nullptr, missingTitle, missingMessage);
 39026:     }
 39026: 
 39026:     return NS_ERROR_ABORT;
 39026:   }
 39026: }
 39026: 
 99566: static nsresult
 99566: ProfileLockedDialog(nsIToolkitProfile* aProfile, nsIProfileUnlocker* aUnlocker,
 99566:                     nsINativeAppSupport* aNative, nsIProfileLock* *aResult)
 99566: {
101111:   nsCOMPtr<nsIFile> profileDir;
 99566:   nsresult rv = aProfile->GetRootDir(getter_AddRefs(profileDir));
 99566:   if (NS_FAILED(rv)) return rv;
 99566: 
104138:   bool exists;
104138:   profileDir->Exists(&exists);
104138:   if (!exists) {
104138:     return ProfileMissingDialog(aNative);
104138:   }
104138: 
101111:   nsCOMPtr<nsIFile> profileLocalDir;
 99566:   rv = aProfile->GetLocalDir(getter_AddRefs(profileLocalDir));
 99566:   if (NS_FAILED(rv)) return rv;
 99566: 
 99566:   return ProfileLockedDialog(profileDir, profileLocalDir, aUnlocker, aNative,
 99566:                              aResult);
 99566: }
 99566: 
     1: static const char kProfileManagerURL[] =
     1:   "chrome://mozapps/content/profile/profileSelection.xul";
     1: 
     1: static nsresult
     1: ShowProfileManager(nsIToolkitProfileService* aProfileSvc,
     1:                    nsINativeAppSupport* aNative)
     1: {
     1:   nsresult rv;
     1: 
101111:   nsCOMPtr<nsIFile> profD, profLD;
  2962:   PRUnichar* profileNamePtr;
110974:   nsAutoCString profileName;
     1: 
     1:   {
     1:     ScopedXPCOMStartup xpcom;
     1:     rv = xpcom.Initialize();
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
 46997:     rv = xpcom.SetWindowCreator(aNative);
     1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
     1: #ifdef XP_MACOSX
 80486:     CommandLineServiceMac::SetupMacCommandLine(gRestartArgc, gRestartArgv, true);
     1: #endif
     1: 
     1: #ifdef XP_WIN
 15466:     // we don't have to wait here because profile manager window will pump
 15466:     // and DDE message will be handled
 80486:     ProcessDDE(aNative, false);
     1: #endif
     1: 
     1:     { //extra scoping is needed so we release these components before xpcom shutdown
     1:       nsCOMPtr<nsIWindowWatcher> windowWatcher
     1:         (do_GetService(NS_WINDOWWATCHER_CONTRACTID));
     1:       nsCOMPtr<nsIDialogParamBlock> ioParamBlock
     1:         (do_CreateInstance(NS_DIALOGPARAMBLOCK_CONTRACTID));
     1:       nsCOMPtr<nsIMutableArray> dlgArray (do_CreateInstance(NS_ARRAY_CONTRACTID));
     1:       NS_ENSURE_TRUE(windowWatcher && ioParamBlock && dlgArray, NS_ERROR_FAILURE);
     1: 
     1:       ioParamBlock->SetObjects(dlgArray);
     1: 
     1:       nsCOMPtr<nsIAppStartup> appStartup
     1:         (do_GetService(NS_APPSTARTUP_CONTRACTID));
     1:       NS_ENSURE_TRUE(appStartup, NS_ERROR_FAILURE);
     1: 
     1:       nsCOMPtr<nsIDOMWindow> newWindow;
106838:       rv = windowWatcher->OpenWindow(nullptr,
     1:                                      kProfileManagerURL,
     1:                                      "_blank",
     1:                                      "centerscreen,chrome,modal,titlebar",
     1:                                      ioParamBlock,
     1:                                      getter_AddRefs(newWindow));
     1: 
     1:       NS_ENSURE_SUCCESS_LOG(rv, rv);
     1: 
     1:       aProfileSvc->Flush();
     1: 
108991:       int32_t dialogConfirmed;
     1:       rv = ioParamBlock->GetInt(0, &dialogConfirmed);
     1:       if (NS_FAILED(rv) || dialogConfirmed == 0) return NS_ERROR_ABORT;
     1: 
     1:       nsCOMPtr<nsIProfileLock> lock;
     1:       rv = dlgArray->QueryElementAt(0, NS_GET_IID(nsIProfileLock),
     1:                                     getter_AddRefs(lock));
     1:       NS_ENSURE_SUCCESS_LOG(rv, rv);
     1: 
     1:       rv = lock->GetDirectory(getter_AddRefs(profD));
     1:       NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:       rv = lock->GetLocalDirectory(getter_AddRefs(profLD));
     1:       NS_ENSURE_SUCCESS(rv, rv);
     1: 
  2962:       rv = ioParamBlock->GetString(0, &profileNamePtr);
  2962:       NS_ENSURE_SUCCESS(rv, rv);
  2962: 
  2962:       CopyUTF16toUTF8(profileNamePtr, profileName);
  2962:       NS_Free(profileNamePtr);
  2962: 
     1:       lock->Unlock();
     1:     }
     1:   }
     1: 
     1:   SaveFileToEnv("XRE_PROFILE_PATH", profD);
     1:   SaveFileToEnv("XRE_PROFILE_LOCAL_PATH", profLD);
  2962:   SaveWordToEnv("XRE_PROFILE_NAME", profileName);
     1: 
 79445:   bool offline = false;
     1:   aProfileSvc->GetStartOffline(&offline);
     1:   if (offline) {
 41012:     SaveToEnv("XRE_START_OFFLINE=1");
     1:   }
     1: 
     1:   return LaunchChild(aNative);
     1: }
     1: 
     1: static nsresult
 99566: GetCurrentProfileIsDefault(nsIToolkitProfileService* aProfileSvc,
101111:                            nsIFile* aCurrentProfileRoot, bool *aResult)
 91887: {
 99566:   nsresult rv;
 99566:   // Check that the profile to reset is the default since reset and the associated migration are
 99566:   // only supported in that case.
 99566:   nsCOMPtr<nsIToolkitProfile> selectedProfile;
101111:   nsCOMPtr<nsIFile> selectedProfileRoot;
 99566:   rv = aProfileSvc->GetSelectedProfile(getter_AddRefs(selectedProfile));
 91887:   NS_ENSURE_SUCCESS(rv, rv);
 91887: 
 99566:   rv = selectedProfile->GetRootDir(getter_AddRefs(selectedProfileRoot));
 91887:   NS_ENSURE_SUCCESS(rv, rv);
 91887: 
 99566:   bool currentIsSelected;
 99566:   rv = aCurrentProfileRoot->Equals(selectedProfileRoot, &currentIsSelected);
 99566: 
 99566:   *aResult = currentIsSelected;
 99566:   return rv;
 91887: }
 91887: 
 91887: /**
 91887:  * Set the currently running profile as the default/selected one.
 91887:  *
 91887:  * @param aCurrentProfileRoot The root directory of the current profile.
 91887:  * @return an error if aCurrentProfileRoot is not found or the profile could not
 91887:  * be set as the default.
 91887:  */
 91887: static nsresult
 91887: SetCurrentProfileAsDefault(nsIToolkitProfileService* aProfileSvc,
101111:                            nsIFile* aCurrentProfileRoot)
 91887: {
 91887:   NS_ENSURE_ARG_POINTER(aProfileSvc);
 91887: 
 91887:   nsCOMPtr<nsISimpleEnumerator> profiles;
 91887:   nsresult rv = aProfileSvc->GetProfiles(getter_AddRefs(profiles));
 91887:   if (NS_FAILED(rv))
 91887:     return rv;
 91887: 
 91887:   bool foundMatchingProfile = false;
 91887:   nsCOMPtr<nsIToolkitProfile> profile;
 91887:   rv = profiles->GetNext(getter_AddRefs(profile));
 91887:   while (NS_SUCCEEDED(rv)) {
101111:     nsCOMPtr<nsIFile> profileRoot;
 91887:     profile->GetRootDir(getter_AddRefs(profileRoot));
 91887:     profileRoot->Equals(aCurrentProfileRoot, &foundMatchingProfile);
 91887:     if (foundMatchingProfile && profile) {
 91887:       rv = aProfileSvc->SetSelectedProfile(profile);
 91887:       if (NS_SUCCEEDED(rv))
 91887:         rv = aProfileSvc->Flush();
 91887:       return rv;
 91887:     }
 91887:     rv = profiles->GetNext(getter_AddRefs(profile));
 91887:   }
 91887:   return rv;
 91887: }
 91887: 
 99566: static bool gDoMigration = false;
 99566: static bool gDoProfileReset = false;
 99566: 
 99566: // Pick a profile. We need to end up with a profile lock.
 99566: //
 99566: // 1) check for -profile <path>
 99566: // 2) check for -P <name>
 99566: // 3) check for -ProfileManager
 99566: // 4) use the default profile, if there is one
 99566: // 5) if there are *no* profiles, set up profile-migration
 99566: // 6) display the profile-manager UI
 91887: static nsresult
 91887: SelectProfile(nsIProfileLock* *aResult, nsIToolkitProfileService* aProfileSvc, nsINativeAppSupport* aNative,
 79445:               bool* aStartOffline, nsACString* aProfileName)
     1: {
     1:   nsresult rv;
     1:   ArgResult ar;
     1:   const char* arg;
106838:   *aResult = nullptr;
 80486:   *aStartOffline = false;
 80486: 
 80486:   ar = CheckArg("offline", true);
  3321:   if (ar == ARG_BAD) {
  3321:     PR_fprintf(PR_STDERR, "Error: argument -offline is invalid when argument -osint is specified\n");
  3321:     return NS_ERROR_FAILURE;
  3321:   }
  3321: 
 63553:   if (ar || EnvHasValue("XRE_START_OFFLINE"))
 80486:     *aStartOffline = true;
     1: 
 91887:   if (EnvHasValue("MOZ_RESET_PROFILE_RESTART")) {
 91887:     gDoProfileReset = true;
 91887:     gDoMigration = true;
 91887:     SaveToEnv("MOZ_RESET_PROFILE_RESTART=");
 91887:   }
 91887: 
 91887:   // reset-profile and migration args need to be checked before any profiles are chosen below.
 91887:   ar = CheckArg("reset-profile", true);
 91887:   if (ar == ARG_BAD) {
 91887:     PR_fprintf(PR_STDERR, "Error: argument -reset-profile is invalid when argument -osint is specified\n");
 91887:     return NS_ERROR_FAILURE;
 91887:   } else if (ar == ARG_FOUND) {
 91887:     gDoProfileReset = true;
 91887:   }
 91887: 
 91887:   ar = CheckArg("migration", true);
 91887:   if (ar == ARG_BAD) {
 91887:     PR_fprintf(PR_STDERR, "Error: argument -migration is invalid when argument -osint is specified\n");
 91887:     return NS_ERROR_FAILURE;
 91887:   } else if (ar == ARG_FOUND) {
 91887:     gDoMigration = true;
 91887:   }
  3321: 
101111:   nsCOMPtr<nsIFile> lf = GetFileFromEnv("XRE_PROFILE_PATH");
  9738:   if (lf) {
101111:     nsCOMPtr<nsIFile> localDir =
  9738:       GetFileFromEnv("XRE_PROFILE_LOCAL_PATH");
  9738:     if (!localDir) {
     1:       localDir = lf;
     1:     }
     1: 
  2962:     arg = PR_GetEnv("XRE_PROFILE_NAME");
  2962:     if (arg && *arg && aProfileName)
  2962:       aProfileName->Assign(nsDependentCString(arg));
  2962: 
     1:     // Clear out flags that we handled (or should have handled!) last startup.
     1:     const char *dummy;
 80486:     CheckArg("p", false, &dummy);
 80486:     CheckArg("profile", false, &dummy);
     1:     CheckArg("profilemanager");
     1: 
 91887:     if (gDoProfileReset) {
 99566:       // Check that the profile to reset is the default since reset and migration are only
 99566:       // supported in that case.
 99566:       bool currentIsSelected;
 99566:       GetCurrentProfileIsDefault(aProfileSvc, lf, &currentIsSelected);
 99566:       if (!currentIsSelected) {
 99566:         NS_WARNING("Profile reset is only supported for the default profile.");
 99566:         gDoProfileReset = gDoMigration = false;
 99566:       }
 99566: 
 91887:       // If we're resetting a profile, create a new one and use it to startup.
 91887:       nsCOMPtr<nsIToolkitProfile> newProfile;
 99566:       rv = CreateResetProfile(aProfileSvc, getter_AddRefs(newProfile));
 91887:       if (NS_SUCCEEDED(rv)) {
 91887:         rv = newProfile->GetRootDir(getter_AddRefs(lf));
 91887:         NS_ENSURE_SUCCESS(rv, rv);
 91887:         SaveFileToEnv("XRE_PROFILE_PATH", lf);
 91887: 
 91887:         rv = newProfile->GetLocalDir(getter_AddRefs(localDir));
 91887:         NS_ENSURE_SUCCESS(rv, rv);
 91887:         SaveFileToEnv("XRE_PROFILE_LOCAL_PATH", localDir);
 91887: 
 91887:         rv = newProfile->GetName(*aProfileName);
 91887:         if (NS_FAILED(rv))
 91887:           aProfileName->Truncate(0);
 91887:         SaveWordToEnv("XRE_PROFILE_NAME", *aProfileName);
 91887:       } else {
 91887:         NS_WARNING("Profile reset failed.");
 91887:         gDoProfileReset = false;
 91887:       }
 91887:     }
 91887: 
106838:     return NS_LockProfilePath(lf, localDir, nullptr, aResult);
     1:   }
     1: 
 80486:   ar = CheckArg("profile", true, &arg);
     1:   if (ar == ARG_BAD) {
     1:     PR_fprintf(PR_STDERR, "Error: argument -profile requires a path\n");
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   if (ar) {
 91887:     if (gDoProfileReset) {
 91887:       NS_WARNING("Profile reset is only supported for the default profile.");
 91887:       gDoProfileReset = false;
 91887:     }
 91887: 
101111:     nsCOMPtr<nsIFile> lf;
     1:     rv = XRE_GetFileFromPath(arg, getter_AddRefs(lf));
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     nsCOMPtr<nsIProfileUnlocker> unlocker;
     1: 
 35415:     // Check if the profile path exists and it's a directory.
 79445:     bool exists;
 35415:     lf->Exists(&exists);
 35415:     if (!exists) {
 52341:         rv = lf->Create(nsIFile::DIRECTORY_TYPE, 0700);
 35415:         NS_ENSURE_SUCCESS(rv, rv);
 35415:     }
 35415: 
     1:     // If a profile path is specified directory on the command line, then
     1:     // assume that the temp directory is the same as the given directory.
     1:     rv = NS_LockProfilePath(lf, lf, getter_AddRefs(unlocker), aResult);
     1:     if (NS_SUCCEEDED(rv))
     1:       return rv;
     1: 
     1:     return ProfileLockedDialog(lf, lf, unlocker, aNative, aResult);
     1:   }
     1: 
 80486:   ar = CheckArg("createprofile", true, &arg);
     1:   if (ar == ARG_BAD) {
     1:     PR_fprintf(PR_STDERR, "Error: argument -createprofile requires a profile name\n");
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   if (ar) {
     1:     nsCOMPtr<nsIToolkitProfile> profile;
     1: 
     1:     const char* delim = strchr(arg, ' ');
     1:     if (delim) {
101111:       nsCOMPtr<nsIFile> lf;
     1:       rv = NS_NewNativeLocalFile(nsDependentCString(delim + 1),
 80486:                                    true, getter_AddRefs(lf));
     1:       if (NS_FAILED(rv)) {
     1:         PR_fprintf(PR_STDERR, "Error: profile path not valid.\n");
     1:         return rv;
     1:       }
     1:       
     1:       // As with -profile, assume that the given path will be used for both the
     1:       // main profile directory and the temp profile directory.
 91887:       rv = aProfileSvc->CreateProfile(lf, lf, nsDependentCSubstring(arg, delim),
     1:                                      getter_AddRefs(profile));
     1:     } else {
106838:       rv = aProfileSvc->CreateProfile(nullptr, nullptr, nsDependentCString(arg),
     1:                                      getter_AddRefs(profile));
     1:     }
     1:     // Some pathological arguments can make it this far
     1:     if (NS_FAILED(rv)) {
     1:       PR_fprintf(PR_STDERR, "Error creating profile.\n");
     1:       return rv; 
     1:     }
     1:     rv = NS_ERROR_ABORT;  
 91887:     aProfileSvc->Flush();
     1: 
     1:     // XXXben need to ensure prefs.js exists here so the tinderboxes will
     1:     //        not go orange.
101111:     nsCOMPtr<nsIFile> prefsJSFile;
     1:     profile->GetRootDir(getter_AddRefs(prefsJSFile));
     1:     prefsJSFile->AppendNative(NS_LITERAL_CSTRING("prefs.js"));
110974:     nsAutoCString pathStr;
   826:     prefsJSFile->GetNativePath(pathStr);
   826:     PR_fprintf(PR_STDERR, "Success: created profile '%s' at '%s'\n", arg, pathStr.get());
 79445:     bool exists;
     1:     prefsJSFile->Exists(&exists);
     1:     if (!exists)
     1:       prefsJSFile->Create(nsIFile::NORMAL_FILE_TYPE, 0644);
     1:     // XXXdarin perhaps 0600 would be better?
     1: 
     1:     return rv;
     1:   }
     1: 
108991:   uint32_t count;
 91887:   rv = aProfileSvc->GetProfileCount(&count);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 80486:   ar = CheckArg("p", false, &arg);
     1:   if (ar == ARG_BAD) {
  3321:     ar = CheckArg("osint");
  3321:     if (ar == ARG_FOUND) {
  3321:       PR_fprintf(PR_STDERR, "Error: argument -p is invalid when argument -osint is specified\n");
  3321:       return NS_ERROR_FAILURE;
  3321:     }
 91887:     return ShowProfileManager(aProfileSvc, aNative);
     1:   }
     1:   if (ar) {
  3321:     ar = CheckArg("osint");
  3321:     if (ar == ARG_FOUND) {
  3321:       PR_fprintf(PR_STDERR, "Error: argument -p is invalid when argument -osint is specified\n");
  3321:       return NS_ERROR_FAILURE;
  3321:     }
     1:     nsCOMPtr<nsIToolkitProfile> profile;
 91887:     rv = aProfileSvc->GetProfileByName(nsDependentCString(arg),
     1:                                       getter_AddRefs(profile));
     1:     if (NS_SUCCEEDED(rv)) {
 91887:       if (gDoProfileReset) {
 91887:         NS_WARNING("Profile reset is only supported for the default profile.");
 91887:         gDoProfileReset = false;
 91887:       }
 91887: 
     1:       nsCOMPtr<nsIProfileUnlocker> unlocker;
116363:       rv = profile->Lock(getter_AddRefs(unlocker), aResult);
  2962:       if (NS_SUCCEEDED(rv)) {
  2962:         if (aProfileName)
  2962:           aProfileName->Assign(nsDependentCString(arg));
     1:         return NS_OK;
  2962:       }
     1: 
 99566:       return ProfileLockedDialog(profile, unlocker, aNative, aResult);
     1:     }
     1: 
 91887:     return ShowProfileManager(aProfileSvc, aNative);
     1:   }
     1: 
 80486:   ar = CheckArg("profilemanager", true);
  3321:   if (ar == ARG_BAD) {
  3321:     PR_fprintf(PR_STDERR, "Error: argument -profilemanager is invalid when argument -osint is specified\n");
  3321:     return NS_ERROR_FAILURE;
  3321:   } else if (ar == ARG_FOUND) {
 91887:     return ShowProfileManager(aProfileSvc, aNative);
     1:   }
     1: 
     1:   if (!count) {
 80486:     gDoMigration = true;
 91887:     gDoProfileReset = false;
     1: 
     1:     // create a default profile
     1:     nsCOMPtr<nsIToolkitProfile> profile;
106838:     nsresult rv = aProfileSvc->CreateProfile(nullptr, // choose a default dir for us
106838:                                              nullptr, // choose a default dir for us
     1:                                              NS_LITERAL_CSTRING("default"),
     1:                                              getter_AddRefs(profile));
     1:     if (NS_SUCCEEDED(rv)) {
 91887:       aProfileSvc->Flush();
106838:       rv = profile->Lock(nullptr, aResult);
  2962:       if (NS_SUCCEEDED(rv)) {
  2962:         if (aProfileName)
  2962:           aProfileName->Assign(NS_LITERAL_CSTRING("default"));
     1:         return NS_OK;
     1:       }
     1:     }
  2962:   }
     1: 
 79445:   bool useDefault = true;
     1:   if (count > 1)
 91887:     aProfileSvc->GetStartWithLastProfile(&useDefault);
     1: 
     1:   if (useDefault) {
     1:     nsCOMPtr<nsIToolkitProfile> profile;
     1:     // GetSelectedProfile will auto-select the only profile if there's just one
 91887:     aProfileSvc->GetSelectedProfile(getter_AddRefs(profile));
     1:     if (profile) {
 91887:       // If we're resetting a profile, create a new one and use it to startup.
 91887:       if (gDoProfileReset) {
 99566:         {
 99566:           // Check that the source profile is not in use by temporarily acquiring its lock.
 99566:           nsIProfileLock* tempProfileLock;
 99566:           nsCOMPtr<nsIProfileUnlocker> unlocker;
 99566:           rv = profile->Lock(getter_AddRefs(unlocker), &tempProfileLock);
 99566:           if (NS_FAILED(rv))
 99566:             return ProfileLockedDialog(profile, unlocker, aNative, &tempProfileLock);
 99566:         }
 99566: 
 91887:         nsCOMPtr<nsIToolkitProfile> newProfile;
 99566:         rv = CreateResetProfile(aProfileSvc, getter_AddRefs(newProfile));
 91887:         if (NS_SUCCEEDED(rv))
 91887:           profile = newProfile;
 91887:         else
 91887:           gDoProfileReset = false;
 91887:       }
     1:       nsCOMPtr<nsIProfileUnlocker> unlocker;
     1:       rv = profile->Lock(getter_AddRefs(unlocker), aResult);
  2962:       if (NS_SUCCEEDED(rv)) {
  2962:         // Try to grab the profile name.
  2962:         if (aProfileName) {
  2962:           rv = profile->GetName(*aProfileName);
  2962:           if (NS_FAILED(rv))
  2962:             aProfileName->Truncate(0);
  2962:         }
     1:         return NS_OK;
  2962:       }
     1: 
 99566:       return ProfileLockedDialog(profile, unlocker, aNative, aResult);
     1:     }
     1:   }
     1: 
 91887:   return ShowProfileManager(aProfileSvc, aNative);
     1: }
     1: 
 33900: /** 
 33900:  * Checks the compatibility.ini file to see if we have updated our application
 33900:  * or otherwise invalidated our caches. If the application has been updated, 
 80486:  * we return false; otherwise, we return true. We also write the status 
 33900:  * of the caches (valid/invalid) into the return param aCachesOK. The aCachesOK
 33900:  * is always invalid if the application has been updated. 
 33900:  */
 79445: static bool
     1: CheckCompatibility(nsIFile* aProfileDir, const nsCString& aVersion,
     1:                    const nsCString& aOSABI, nsIFile* aXULRunnerDir,
101111:                    nsIFile* aAppDir, nsIFile* aFlagFile, 
 79445:                    bool* aCachesOK)
     1: {
 80486:   *aCachesOK = false;
     1:   nsCOMPtr<nsIFile> file;
     1:   aProfileDir->Clone(getter_AddRefs(file));
     1:   if (!file)
 80486:     return false;
     1:   file->AppendNative(FILE_COMPATIBILITY_INFO);
     1: 
     1:   nsINIParser parser;
101111:   nsresult rv = parser.Init(file);
     1:   if (NS_FAILED(rv))
 80486:     return false;
     1: 
110974:   nsAutoCString buf;
     1:   rv = parser.GetString("Compatibility", "LastVersion", buf);
     1:   if (NS_FAILED(rv) || !aVersion.Equals(buf))
 80486:     return false;
     1: 
     1:   rv = parser.GetString("Compatibility", "LastOSABI", buf);
     1:   if (NS_FAILED(rv) || !aOSABI.Equals(buf))
 80486:     return false;
     1: 
     1:   rv = parser.GetString("Compatibility", "LastPlatformDir", buf);
     1:   if (NS_FAILED(rv))
 80486:     return false;
     1: 
101111:   nsCOMPtr<nsIFile> lf;
 80486:   rv = NS_NewNativeLocalFile(buf, false,
     1:                              getter_AddRefs(lf));
     1:   if (NS_FAILED(rv))
 80486:     return false;
     1: 
 79445:   bool eq;
     1:   rv = lf->Equals(aXULRunnerDir, &eq);
     1:   if (NS_FAILED(rv) || !eq)
 80486:     return false;
     1: 
     1:   if (aAppDir) {
     1:     rv = parser.GetString("Compatibility", "LastAppDir", buf);
     1:     if (NS_FAILED(rv))
 80486:       return false;
 80486: 
 80486:     rv = NS_NewNativeLocalFile(buf, false,
     1:                                getter_AddRefs(lf));
     1:     if (NS_FAILED(rv))
 80486:       return false;
     1: 
     1:     rv = lf->Equals(aAppDir, &eq);
     1:     if (NS_FAILED(rv) || !eq)
 80486:       return false;
     1:   }
     1: 
 47163:   // If we see this flag, caches are invalid.
 43593:   rv = parser.GetString("Compatibility", "InvalidateCaches", buf);
 33900:   *aCachesOK = (NS_FAILED(rv) || !buf.EqualsLiteral("1"));
 47163:   
 79445:   bool purgeCaches = false;
 47163:   if (aFlagFile) {
 47163:     aFlagFile->Exists(&purgeCaches);
 47163:   }
 47163: 
 47163:   *aCachesOK = !purgeCaches && *aCachesOK;
 80486:   return true;
     1: }
     1: 
     1: static void BuildVersion(nsCString &aBuf)
     1: {
     1:   aBuf.Assign(gAppData->version);
     1:   aBuf.Append('_');
     1:   aBuf.Append(gAppData->buildID);
     1:   aBuf.Append('/');
  3041:   aBuf.Append(gToolkitBuildID);
     1: }
     1: 
     1: static void
     1: WriteVersion(nsIFile* aProfileDir, const nsCString& aVersion,
     1:              const nsCString& aOSABI, nsIFile* aXULRunnerDir,
     1:              nsIFile* aAppDir)
     1: {
     1:   nsCOMPtr<nsIFile> file;
     1:   aProfileDir->Clone(getter_AddRefs(file));
     1:   if (!file)
     1:     return;
     1:   file->AppendNative(FILE_COMPATIBILITY_INFO);
     1: 
110974:   nsAutoCString platformDir;
     1:   aXULRunnerDir->GetNativePath(platformDir);
     1: 
110974:   nsAutoCString appDir;
     1:   if (aAppDir)
     1:     aAppDir->GetNativePath(appDir);
     1: 
106838:   PRFileDesc *fd = nullptr;
101111:   file->OpenNSPRFileDesc(PR_WRONLY | PR_CREATE_FILE | PR_TRUNCATE, 0600, &fd);
     1:   if (!fd) {
     1:     NS_ERROR("could not create output stream");
     1:     return;
     1:   }
     1: 
     1:   static const char kHeader[] = "[Compatibility]" NS_LINEBREAK
     1:                                 "LastVersion=";
     1: 
     1:   PR_Write(fd, kHeader, sizeof(kHeader) - 1);
     1:   PR_Write(fd, aVersion.get(), aVersion.Length());
     1: 
     1:   static const char kOSABIHeader[] = NS_LINEBREAK "LastOSABI=";
     1:   PR_Write(fd, kOSABIHeader, sizeof(kOSABIHeader) - 1);
     1:   PR_Write(fd, aOSABI.get(), aOSABI.Length());
     1: 
     1:   static const char kPlatformDirHeader[] = NS_LINEBREAK "LastPlatformDir=";
     1: 
     1:   PR_Write(fd, kPlatformDirHeader, sizeof(kPlatformDirHeader) - 1);
     1:   PR_Write(fd, platformDir.get(), platformDir.Length());
     1: 
     1:   static const char kAppDirHeader[] = NS_LINEBREAK "LastAppDir=";
     1:   if (aAppDir) {
     1:     PR_Write(fd, kAppDirHeader, sizeof(kAppDirHeader) - 1);
     1:     PR_Write(fd, appDir.get(), appDir.Length());
     1:   }
     1: 
     1:   static const char kNL[] = NS_LINEBREAK;
     1:   PR_Write(fd, kNL, sizeof(kNL) - 1);
     1: 
     1:   PR_Close(fd);
     1: }
     1: 
     1: static void RemoveComponentRegistries(nsIFile* aProfileDir, nsIFile* aLocalProfileDir,
 79445:                                       bool aRemoveEMFiles)
     1: {
     1:   nsCOMPtr<nsIFile> file;
     1:   aProfileDir->Clone(getter_AddRefs(file));
     1:   if (!file)
     1:     return;
     1: 
     1:   if (aRemoveEMFiles) {
     1:     file->SetNativeLeafName(NS_LITERAL_CSTRING("extensions.ini"));
 80486:     file->Remove(false);
     1:   }
     1: 
     1:   aLocalProfileDir->Clone(getter_AddRefs(file));
     1:   if (!file)
     1:     return;
     1: 
 71949: #if defined(XP_UNIX) || defined(XP_BEOS)
 71949: #define PLATFORM_FASL_SUFFIX ".mfasl"
 71949: #elif defined(XP_WIN) || defined(XP_OS2)
 71949: #define PLATFORM_FASL_SUFFIX ".mfl"
 71949: #endif
 71949: 
     1:   file->AppendNative(NS_LITERAL_CSTRING("XUL" PLATFORM_FASL_SUFFIX));
 80486:   file->Remove(false);
 33900:   
 33900:   file->SetNativeLeafName(NS_LITERAL_CSTRING("XPC" PLATFORM_FASL_SUFFIX));
 80486:   file->Remove(false);
 51718: 
 51718:   file->SetNativeLeafName(NS_LITERAL_CSTRING("startupCache"));
 80486:   file->Remove(true);
     1: }
     1: 
  6903: // To support application initiated restart via nsIAppStartup.quit, we
  6903: // need to save various environment variables, and then restore them
  6903: // before re-launching the application.
  6903: 
 80467: static struct SavedVar {
  6903:   const char *name;
  6903:   char *value;
  6903: } gSavedVars[] = {
106838:   {"XUL_APP_FILE", nullptr}
  6903: };
  6903: 
  6903: static void SaveStateForAppInitiatedRestart()
  6903: {
 80467:   for (size_t i = 0; i < ArrayLength(gSavedVars); ++i) {
  6903:     const char *s = PR_GetEnv(gSavedVars[i].name);
  6903:     if (s)
  6903:       gSavedVars[i].value = PR_smprintf("%s=%s", gSavedVars[i].name, s);
  6903:   }
  6903: }
  6903: 
  6903: static void RestoreStateForAppInitiatedRestart()
  6903: {
 80467:   for (size_t i = 0; i < ArrayLength(gSavedVars); ++i) {
  6903:     if (gSavedVars[i].value)
  6903:       PR_SetEnv(gSavedVars[i].value);
  6903:   }
  6903: }
  6903: 
  4389: #ifdef MOZ_CRASHREPORTER
  4389: // When we first initialize the crash reporter we don't have a profile,
     1: // so we set the minidump path to $TEMP.  Once we have a profile,
     1: // we set it to $PROFILE/minidumps, creating the directory
     1: // if needed.
     1: static void MakeOrSetMinidumpPath(nsIFile* profD)
     1: {
     1:   nsCOMPtr<nsIFile> dumpD;
     1:   nsresult rv = profD->Clone(getter_AddRefs(dumpD));
     1:   
     1:   if(dumpD) {
 79445:     bool fileExists;
     1:     //XXX: do some more error checking here
     1:     dumpD->Append(NS_LITERAL_STRING("minidumps"));
     1:     rv = dumpD->Exists(&fileExists);
     1:     if(!fileExists) {
     1:       dumpD->Create(nsIFile::DIRECTORY_TYPE, 0700);
     1:     }
     1: 
     1:     nsAutoString pathStr;
     1:     if(NS_SUCCEEDED(dumpD->GetPath(pathStr)))
   155:       CrashReporter::SetMinidumpPath(pathStr);
     1:   }
     1: }
     1: #endif
     1: 
106838: const nsXREAppData* gAppData = nullptr;
     1: 
     1: #if defined(XP_OS2)
     1: // because we use early returns, we use a stack-based helper to un-set the OS2 FP handler
     1: class ScopedFPHandler {
     1: private:
     1:   EXCEPTIONREGISTRATIONRECORD excpreg;
     1: 
     1: public:
     1:   ScopedFPHandler() { PR_OS2_SetFloatExcpHandler(&excpreg); }
     1:   ~ScopedFPHandler() { PR_OS2_UnsetFloatExcpHandler(&excpreg); }
     1: };
     1: #endif
     1: 
102173: #ifdef MOZ_WIDGET_GTK
     1: #include "prlink.h"
     1: typedef void (*_g_set_application_name_fn)(const gchar *application_name);
     1: typedef void (*_gtk_window_set_auto_startup_notification_fn)(gboolean setting);
     1: 
     1: static PRFuncPtr FindFunction(const char* aName)
     1: {
106838:   PRLibrary *lib = nullptr;
     1:   PRFuncPtr result = PR_FindFunctionSymbolAndLibrary(aName, &lib);
     1:   // Since the library was already loaded, we can safely unload it here.
     1:   if (lib) {
     1:     PR_UnloadLibrary(lib);
     1:   }
     1:   return result;
     1: }
     1: 
  6618: static void MOZ_gdk_display_close(GdkDisplay *display)
  6618: {
 14131:   // XXX wallpaper for bug 417163: don't close the Display if we're using the
 14131:   // Qt theme because we crash (in Qt code) when using jemalloc.
 79445:   bool theme_is_qt = false;
 14131:   GtkSettings* settings =
 14131:     gtk_settings_get_for_screen(gdk_display_get_default_screen(display));
 14131:   gchar *theme_name;
 14131:   g_object_get(settings, "gtk-theme-name", &theme_name, NULL);
 14131:   if (theme_name) {
 14131:     theme_is_qt = strcmp(theme_name, "Qt") == 0;
 14131:     if (theme_is_qt)
 14131:       NS_WARNING("wallpaper bug 417163 for Qt theme");
 14131:     g_free(theme_name);
 14131:   }
 14131: 
  6618:   // gdk_display_close was broken prior to gtk+-2.10.0.
  6618:   // (http://bugzilla.gnome.org/show_bug.cgi?id=85715)
  6618:   // gdk_display_manager_set_default_display (gdk_display_manager_get(), NULL)
  6618:   // was also broken.
  6618:   if (gtk_check_version(2,10,0) != NULL) {
 16527: #ifdef MOZ_X11
  6618:     // Version check failed - broken gdk_display_close.
  6618:     //
  6618:     // Let the gdk structures leak but at least close the Display,
  6618:     // assuming that gdk will not use it again.
  6618:     Display* dpy = GDK_DISPLAY_XDISPLAY(display);
 14131:     if (!theme_is_qt)
  6618:       XCloseDisplay(dpy);
 16527: #else
 16527:     gdk_display_close(display);
 16527: #endif /* MOZ_X11 */
  6618:   }
  6618:   else {
 19744: #if CLEANUP_MEMORY
 19744:     // Get a (new) Pango context that holds a reference to the fontmap that
 19744:     // GTK has been using.  gdk_pango_context_get() must be called while GTK
 19744:     // has a default display.
 19744:     PangoContext *pangoContext = gdk_pango_context_get();
 19744: #endif
 19744: 
 79445:     bool buggyCairoShutdown = cairo_version() < CAIRO_VERSION_ENCODE(1, 4, 0);
 26700: 
 26700:     if (!buggyCairoShutdown) {
 26700:       // We should shut down GDK before we shut down libraries it depends on
 26700:       // like Pango and cairo. But if cairo shutdown is buggy, we should
 26700:       // shut down cairo first otherwise it may crash because of dangling
 26700:       // references to Display objects (see bug 469831).
 14131:       if (!theme_is_qt)
  6618:         gdk_display_close(display);
 26700:     }
 19744: 
 19744: #if CLEANUP_MEMORY
 19744:     // This doesn't take a reference.
 19744:     PangoFontMap *fontmap = pango_context_get_font_map(pangoContext);
 19744:     // Do some shutdown of the fontmap, which releases the fonts, clearing a
 19744:     // bunch of circular references from the fontmap through the fonts back to
 19744:     // itself.  The shutdown that this does is much less than what's done by
 19744:     // the fontmap's finalize, though.
 19744:     if (PANGO_IS_FC_FONT_MAP(fontmap))
 19744:         pango_fc_font_map_shutdown(PANGO_FC_FONT_MAP(fontmap));
 19744:     g_object_unref(pangoContext);
 19744:     // PangoCairo still holds a reference to the fontmap.
 19744:     // Now that we have finished with GTK and Pango, we could unref fontmap,
 19744:     // which would allow us to call FcFini, but removing what is really
 19744:     // Pango's ref feels a bit evil.  Pango-1.22 will have support for
 19744:     // pango_cairo_font_map_set_default(NULL), which would release the
 19744:     // reference on the old fontmap.
 19744: 
 19744: #if GTK_CHECK_VERSION(2,8,0)
 19744:     // cairo_debug_reset_static_data() is prototyped through cairo.h included
 19744:     // by gtk.h.
 19744: #ifdef cairo_debug_reset_static_data
 19744: #error "Looks like we're including Mozilla's cairo instead of system cairo"
 19744: #endif
 11579:     cairo_debug_reset_static_data();
 19744: #endif // 2.8.0
 19744: #endif // CLEANUP_MEMORY
 26700: 
 26700:     if (buggyCairoShutdown) {
 26700:       if (!theme_is_qt)
 26700:         gdk_display_close(display);
 26700:     }
  6618:   }
  6618: }
  6618: #endif // MOZ_WIDGET_GTK2
     1: 
     1: /** 
     1:  * NSPR will search for the "nspr_use_zone_allocator" symbol throughout
     1:  * the process and use it to determine whether the application defines its own
     1:  * memory allocator or not.
     1:  *
     1:  * Since most applications (e.g. Firefox and Thunderbird) don't use any special
     1:  * allocators and therefore don't define this symbol, NSPR must search the
     1:  * entire process, which reduces startup performance.
     1:  *
     1:  * By defining the symbol here, we can avoid the wasted lookup and hopefully
     1:  * improve startup performance.
     1:  */
 80945: NS_VISIBILITY_DEFAULT PRBool nspr_use_zone_allocator = PR_FALSE;
     1: 
 61203: #ifdef CAIRO_HAS_DWRITE_FONT
 61085: 
 61085: #include <dwrite.h>
 61085: 
 61085: typedef HRESULT (WINAPI*DWriteCreateFactoryFunc)(
 73718:   DWRITE_FACTORY_TYPE factoryType,
 73718:   REFIID iid,
 73718:   IUnknown **factory
 61085: );
 61085: 
 61085: #ifdef DEBUG_DWRITE_STARTUP
 61085: 
 61085: #define LOGREGISTRY(msg) LogRegistryEvent(msg)
 61085: 
 61085: // for use when monitoring process
 61085: static void LogRegistryEvent(const wchar_t *msg)
 61085: {
 61085:   HKEY dummyKey;
 61085:   HRESULT hr;
 61085:   wchar_t buf[512];
 61085: 
 61085:   wsprintf(buf, L" log %s", msg);
 61085:   hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, buf, 0, KEY_READ, &dummyKey);
 61085:   if (SUCCEEDED(hr)) {
 61085:     RegCloseKey(dummyKey);
 61085:   }
 61085: }
 61085: #else
 61085: 
 61085: #define LOGREGISTRY(msg)
 61085: 
 61085: #endif
 61085: 
 61085: static DWORD InitDwriteBG(LPVOID lpdwThreadParam)
 61085: {
 61085:   SetThreadPriority(GetCurrentThread(), THREAD_MODE_BACKGROUND_BEGIN);
 61085:   LOGREGISTRY(L"loading dwrite.dll");
 61085:   HMODULE dwdll = LoadLibraryW(L"dwrite.dll");
 63164:   if (dwdll) {
 61085:     DWriteCreateFactoryFunc createDWriteFactory = (DWriteCreateFactoryFunc)
 61085:       GetProcAddress(dwdll, "DWriteCreateFactory");
 61085:     if (createDWriteFactory) {
 61085:       LOGREGISTRY(L"creating dwrite factory");
 61085:       IDWriteFactory *factory;
 61085:       HRESULT hr = createDWriteFactory(
 61085:         DWRITE_FACTORY_TYPE_SHARED,
 61085:         __uuidof(IDWriteFactory),
 61085:         reinterpret_cast<IUnknown**>(&factory));
 63164:       if (SUCCEEDED(hr)) {
 61085:         LOGREGISTRY(L"dwrite factory done");
 61085:         factory->Release();
 61085:         LOGREGISTRY(L"freed factory");
 63164:       } else {
 63164:         LOGREGISTRY(L"failed to create factory");
 63164:       }
 63164:     }
 61085:   }
 61085:   SetThreadPriority(GetCurrentThread(), THREAD_MODE_BACKGROUND_END);
 61085:   return 0;
 61085: }
 30387: #endif
 30387: 
 95210: #ifdef USE_GLX_TEST
 71575: bool fire_glxtest_process();
 69376: #endif
 69376: 
 81024: #include "sampler.h"
 81024: 
 94158: // Encapsulates startup and shutdown state for XRE_main
 94158: class XREMain
 94158: {
 94158: public:
 94158:   XREMain() :
106838:     mScopedXPCom(nullptr)
106838:     , mAppData(nullptr)
 94158:     , mStartOffline(false)
 94158:     , mShuttingDown(false)
 94158: #ifdef MOZ_ENABLE_XREMOTE
 94158:     , mDisableRemote(false)
 94158: #endif
102173: #if defined(MOZ_WIDGET_GTK)
106838:     , mGdkDisplay(nullptr)
 94158: #endif
 94158:   {};
 94158: 
 94158:   ~XREMain() {
 94158:     if (mAppData) {
 94158:       delete mAppData;
 94158:     }
 94158:     if (mScopedXPCom) {
 94158:       NS_WARNING("Scoped xpcom should have been deleted!");
 94158:       delete mScopedXPCom;
 94158:     }
 94158:   }
 94158: 
 94158:   int XRE_main(int argc, char* argv[], const nsXREAppData* aAppData);
 94158:   int XRE_mainInit(const nsXREAppData* aAppData, bool* aExitFlag);
 94158:   int XRE_mainStartup(bool* aExitFlag);
 94158:   nsresult XRE_mainRun();
 94158:   
 94158:   nsCOMPtr<nsINativeAppSupport> mNativeApp;
 94158:   nsCOMPtr<nsIToolkitProfileService> mProfileSvc;
101111:   nsCOMPtr<nsIFile> mProfD;
101111:   nsCOMPtr<nsIFile> mProfLD;
 94158:   nsCOMPtr<nsIProfileLock> mProfileLock;
 94158: #ifdef MOZ_ENABLE_XREMOTE
 94158:   nsCOMPtr<nsIRemoteService> mRemoteService;
 94158: #endif
 94158: 
 94158:   ScopedXPCOMStartup* mScopedXPCom;
 94158:   ScopedAppData* mAppData;
 94158:   nsXREDirProvider mDirProvider;
110974:   nsAutoCString mProfileName;
110974:   nsAutoCString mDesktopStartupID;
 94158: 
 94158:   bool mStartOffline;
 94158:   bool mShuttingDown;
 94158: #ifdef MOZ_ENABLE_XREMOTE
 94158:   bool mDisableRemote;
 94158: #endif
 94158: 
102173: #if defined(MOZ_WIDGET_GTK)
 94158:   GdkDisplay* mGdkDisplay;
 94158: #endif
 94158: };
 94158: 
 94158: /*
 94158:  * XRE_mainInit - Initial setup and command line parameter processing.
 94158:  * Main() will exit early if either return value != 0 or if aExitFlag is
 94158:  * true.
 94158:  */
     1: int
 94158: XREMain::XRE_mainInit(const nsXREAppData* aAppData, bool* aExitFlag)
     1: {
 94158:   if (!aExitFlag)
 94158:     return 1;
 94158:   *aExitFlag = false;
 41343: 
 82448:   StartupTimeline::Record(StartupTimeline::MAIN);
 60458: 
     1:   nsresult rv;
  3321:   ArgResult ar;
     1: 
     1: #ifdef DEBUG
     1:   if (PR_GetEnv("XRE_MAIN_BREAK"))
     1:     NS_BREAK();
     1: #endif
     1: 
 95210: #ifdef USE_GLX_TEST
 94158:   // bug 639842 - it's very important to fire this process BEFORE we set up
 94158:   // error handling. indeed, this process is expected to be crashy, and we
 94158:   // don't want the user to see its crashes. That's the whole reason for
 94158:   // doing this in a separate process.
 94158:   if (fire_glxtest_process()) {
 94158:     *aExitFlag = true;
 71575:     return 0;
 94158:   }
 69376: #endif
 69376: 
 71205: #ifdef XP_WIN
 94158:   {
 71205:     // Vista API.  Mozilla is DPI Aware.
 71205:     typedef BOOL (*SetProcessDPIAwareFunc)(VOID);
 71205:     SetProcessDPIAwareFunc setDPIAware = (SetProcessDPIAwareFunc)
 71205:       GetProcAddress(LoadLibraryW(L"user32.dll"), "SetProcessDPIAware");
 94158:     if (setDPIAware) {
 71205:       setDPIAware();
 94158:     }
 94158:   }
 71205: #endif
 71205: 
 94158:   SetupErrorHandling(gArgv[0]);
     1: 
 61203: #ifdef CAIRO_HAS_DWRITE_FONT
 94158:   {
 61085:     // Bug 602792 - when DWriteCreateFactory is called the dwrite client dll
 61085:     // starts the FntCache service if it isn't already running (it's set
 61085:     // to manual startup by default in Windows 7 RTM).  Subsequent DirectWrite
 61085:     // calls cause the IDWriteFactory object to communicate with the FntCache
 61085:     // service with a timeout; if there's no response after the timeout, the
 61085:     // DirectWrite client library will assume the service isn't around and do
 61085:     // manual font file I/O on _all_ system fonts.  To avoid this, load the
 61085:     // dwrite library and create a factory as early as possible so that the
 61085:     // FntCache service is ready by the time it's needed.
 61085:       
 61085:     OSVERSIONINFO vinfo;
 61085:     vinfo.dwOSVersionInfoSize = sizeof(vinfo);
 61085:     if (GetVersionEx(&vinfo) && vinfo.dwMajorVersion >= 6) {
 61085:       CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&InitDwriteBG, NULL, 0, NULL);
 61085:     }
 94158:   }
 61085: #endif
 61085: 
 41531: #ifdef XP_UNIX
 41531:   const char *home = PR_GetEnv("HOME");
 41531:   if (!home || !*home) {
 41531:     struct passwd *pw = getpwuid(geteuid());
 41531:     if (!pw || !pw->pw_dir) {
 80486:       Output(true, "Could not determine HOME directory");
 41531:       return 1;
 41531:     }
 41531:     SaveWordToEnv("HOME", nsDependentCString(pw->pw_dir));
 41531:   }
 41531: #endif
 41531: 
 22807: #ifdef MOZ_ACCESSIBILITY_ATK
 22807:   // Reset GTK_MODULES, strip atk-bridge if exists
 22807:   // Mozilla will load libatk-bridge.so later if necessary
 22807:   const char* gtkModules = PR_GetEnv("GTK_MODULES");
 22807:   if (gtkModules && *gtkModules) {
 22807:     nsCString gtkModulesStr(gtkModules);
 22807:     gtkModulesStr.ReplaceSubstring("atk-bridge", "");
 22807:     char* expr = PR_smprintf("GTK_MODULES=%s", gtkModulesStr.get());
 22807:     if (expr)
 22807:       PR_SetEnv(expr);
 22807:     // We intentionally leak |expr| here since it is required by PR_SetEnv.
 22807:   }
 22992: 
 22992:   // Suppress atk-bridge init at startup, it works after GNOME 2.24.2
 63553:   SaveToEnv("NO_AT_BRIDGE=1");
 22807: #endif
 22807: 
  9468:   // Check for application.ini overrides
106838:   const char* override = nullptr;
 80486:   ar = CheckArg("override", true, &override);
  9468:   if (ar == ARG_BAD) {
 80486:     Output(true, "Incorrect number of arguments passed to -override");
  9468:     return 1;
  9468:   }
  9468:   else if (ar == ARG_FOUND) {
101111:     nsCOMPtr<nsIFile> overrideLF;
  9468:     rv = XRE_GetFileFromPath(override, getter_AddRefs(overrideLF));
  9468:     if (NS_FAILED(rv)) {
 80486:       Output(true, "Error: unrecognized override.ini path.\n");
  9468:       return 1;
  9468:     }
  9468: 
  9468:     nsXREAppData* overrideAppData = const_cast<nsXREAppData*>(aAppData);
  9468:     rv = XRE_ParseAppData(overrideLF, overrideAppData);
  9468:     if (NS_FAILED(rv)) {
 80486:       Output(true, "Couldn't read override.ini");
  9468:       return 1;
  9468:     }
  9468:   }
  9468: 
     1:   // Check sanity and correctness of app data.
     1: 
 94158:   if (!mAppData->name) {
 80486:     Output(true, "Error: App:Name not specified in application.ini\n");
     1:     return 1;
     1:   }
 94158:   if (!mAppData->buildID) {
 80486:     Output(true, "Error: App:BuildID not specified in application.ini\n");
     1:     return 1;
     1:   }
     1: 
 94158:   // XXX Originally ScopedLogging was here? Now it's in XRE_main above
 94158:   // XRE_mainInit.
 94158: 
 94158:   if (!mAppData->xreDirectory) {
101111:     nsCOMPtr<nsIFile> lf;
  3041:     rv = XRE_GetBinaryPath(gArgv[0], getter_AddRefs(lf));
  3041:     if (NS_FAILED(rv))
  3041:       return 2;
  3041: 
  3041:     nsCOMPtr<nsIFile> greDir;
  3041:     rv = lf->GetParent(getter_AddRefs(greDir));
  3041:     if (NS_FAILED(rv))
  3041:       return 2;
  3041:     
 94158:     rv = CallQueryInterface(greDir, &mAppData->xreDirectory);
  3041:     if (NS_FAILED(rv))
  3041:       return 2;
  3041:   }
  3041: 
 94158:   if (!mAppData->directory) {
 94158:     NS_IF_ADDREF(mAppData->directory = mAppData->xreDirectory);
 94158:   }
 94158: 
 94158:   if (mAppData->size > offsetof(nsXREAppData, minVersion)) {
 94158:     if (!mAppData->minVersion) {
 80486:       Output(true, "Error: Gecko:MinVersion not specified in application.ini\n");
  2806:       return 1;
  2806:     }
  2806: 
 94158:     if (!mAppData->maxVersion) {
  2806:       // If no maxVersion is specified, we assume the app is only compatible
  2806:       // with the initial preview release. Do not increment this number ever!
 94158:       SetAllocatedString(mAppData->maxVersion, "1.*");
 94158:     }
 94158: 
 96745:     if (mozilla::Version(mAppData->minVersion) > gToolkitVersion ||
 96745:         mozilla::Version(mAppData->maxVersion) < gToolkitVersion) {
 80486:       Output(true, "Error: Platform version '%s' is not compatible with\n"
  2806:              "minVersion >= %s\nmaxVersion <= %s\n",
  3041:              gToolkitVersion,
 94158:              mAppData->minVersion, mAppData->maxVersion);
  2806:       return 1;
  2806:     }
  2806:   }
  2806: 
 94158:   rv = mDirProvider.Initialize(mAppData->directory, mAppData->xreDirectory);
 42540:   if (NS_FAILED(rv))
 42540:     return 1;
 42540: 
  4389: #ifdef MOZ_CRASHREPORTER
 63553:   if (EnvHasValue("MOZ_CRASHREPORTER")) {
 94158:     mAppData->flags |= NS_XRE_ENABLE_CRASH_REPORTER;
 94158:   }
 94158: 
 94158:   if ((mAppData->flags & NS_XRE_ENABLE_CRASH_REPORTER) &&
  1715:       NS_SUCCEEDED(
 94158:          CrashReporter::SetExceptionHandler(mAppData->xreDirectory))) {
 94158:     if (mAppData->crashReporterURL)
 94158:       CrashReporter::SetServerURL(nsDependentCString(mAppData->crashReporterURL));
 33294: 
  1715:     // pass some basic info from the app data
 94158:     if (mAppData->vendor)
  1715:       CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("Vendor"),
 94158:                                          nsDependentCString(mAppData->vendor));
 94158:     if (mAppData->name)
  1715:       CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("ProductName"),
 94158:                                          nsDependentCString(mAppData->name));
 94158:     if (mAppData->ID)
 83123:       CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("ProductID"),
 94158:                                          nsDependentCString(mAppData->ID));
 94158:     if (mAppData->version)
  1715:       CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("Version"),
 94158:                                          nsDependentCString(mAppData->version));
 94158:     if (mAppData->buildID)
  1715:       CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("BuildID"),
 94158:                                          nsDependentCString(mAppData->buildID));
 82638: 
 82638:     nsDependentCString releaseChannel(NS_STRINGIFY(MOZ_UPDATE_CHANNEL));
 82638:     CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("ReleaseChannel"),
 82638:                                        releaseChannel);
 94158:     CrashReporter::SetRestartArgs(gArgc, gArgv);
  3517: 
  3517:     // annotate other data (user id etc)
101111:     nsCOMPtr<nsIFile> userAppDataDir;
 94158:     if (NS_SUCCEEDED(mDirProvider.GetUserAppDataDirectory(
  3517:                                                          getter_AddRefs(userAppDataDir)))) {
  3565:       CrashReporter::SetupExtraData(userAppDataDir,
 94158:                                     nsDependentCString(mAppData->buildID));
 10713: 
 10713:       // see if we have a crashreporter-override.ini in the application directory
 10713:       nsCOMPtr<nsIFile> overrideini;
 79445:       bool exists;
 94158:       if (NS_SUCCEEDED(mDirProvider.GetAppDir()->Clone(getter_AddRefs(overrideini))) &&
 10713:           NS_SUCCEEDED(overrideini->AppendNative(NS_LITERAL_CSTRING("crashreporter-override.ini"))) &&
 10713:           NS_SUCCEEDED(overrideini->Exists(&exists)) &&
 10713:           exists) {
 10713: #ifdef XP_WIN
 10713:         nsAutoString overridePathW;
 10713:         overrideini->GetPath(overridePathW);
 10713:         NS_ConvertUTF16toUTF8 overridePath(overridePathW);
 10713: #else
110974:         nsAutoCString overridePath;
 10713:         overrideini->GetNativePath(overridePath);
 10713: #endif
 10713: 
 72589:         SaveWordToEnv("MOZ_CRASHREPORTER_STRINGS_OVERRIDE", overridePath);
 10713:       }
  3517:     }
  1715:   }
  1715: #endif
  1715: 
     1: #ifdef XP_MACOSX
 63553:   if (EnvHasValue("MOZ_LAUNCHED_CHILD")) {
  1549:     // This is needed, on relaunch, to force the OS to use the "Cocoa Dock
  1549:     // API".  Otherwise the call to ReceiveNextEvent() below will make it
  1549:     // use the "Carbon Dock API".  For more info see bmo bug 377166.
  1549:     EnsureUseCocoaDockAPI();
  1549: 
     1:     // When the app relaunches, the original process exits.  This causes
     1:     // the dock tile to stop bouncing, lose the "running" triangle, and
     1:     // if the tile does not permanently reside in the Dock, even disappear.
     1:     // This can be confusing to the user, who is expecting the app to launch.
     1:     // Calling ReceiveNextEvent without requesting any event is enough to
     1:     // cause a dock tile for the child process to appear.
     1:     const EventTypeSpec kFakeEventList[] = { { INT_MAX, INT_MAX } };
     1:     EventRef event;
     1:     ::ReceiveNextEvent(GetEventTypeCount(kFakeEventList), kFakeEventList,
 80486:                        kEventDurationNoWait, false, &event);
     1:   }
     1: 
     1:   if (CheckArg("foreground")) {
     1:     // The original process communicates that it was in the foreground by
     1:     // adding this argument.  This new process, which is taking over for
     1:     // the old one, should make itself the active application.
     1:     ProcessSerialNumber psn;
     1:     if (::GetCurrentProcess(&psn) == noErr)
     1:       ::SetFrontProcess(&psn);
     1:   }
     1: #endif
     1: 
 41012:   SaveToEnv("MOZ_LAUNCHED_CHILD=");
     1: 
     1:   gRestartArgc = gArgc;
 16745:   gRestartArgv = (char**) malloc(sizeof(char*) * (gArgc + 1 + (override ? 2 : 0)));
 94158:   if (!gRestartArgv) {
 94158:     return 1;
 94158:   }
  6903: 
  6903:   int i;
  6903:   for (i = 0; i < gArgc; ++i) {
  6903:     gRestartArgv[i] = gArgv[i];
  6901:   }
 16745:   
 16745:   // Add the -override argument back (it is removed automatically be CheckArg) if there is one
 16745:   if (override) {
 16745:     gRestartArgv[gRestartArgc++] = const_cast<char*>("-override");
 16745:     gRestartArgv[gRestartArgc++] = const_cast<char*>(override);
 16745:   }
 16745: 
106838:   gRestartArgv[gRestartArgc] = nullptr;
 16745:   
     1: 
     1: #if defined(XP_OS2)
 79445:   bool StartOS2App(int aArgc, char **aArgv);
     1:   if (!StartOS2App(gArgc, gArgv))
     1:     return 1;
     1:   ScopedFPHandler handler;
     1: #endif /* XP_OS2 */
     1: 
 63553:   if (EnvHasValue("MOZ_SAFE_MODE_RESTART")) {
 80486:     gSafeMode = true;
 54497:     // unset the env variable
 63553:     SaveToEnv("MOZ_SAFE_MODE_RESTART=");
 54497:   }
 54497: 
 80486:   ar = CheckArg("safe-mode", true);
  3321:   if (ar == ARG_BAD) {
  3321:     PR_fprintf(PR_STDERR, "Error: argument -safe-mode is invalid when argument -osint is specified\n");
  3321:     return 1;
  3321:   } else if (ar == ARG_FOUND) {
 80486:     gSafeMode = true;
  3321:   }
  3321: 
 57882: #ifdef XP_WIN
 59584:   // If the shift key is pressed and the ctrl and / or alt keys are not pressed
 59584:   // during startup start in safe mode. GetKeyState returns a short and the high
 59584:   // order bit will be 1 if the key is pressed. By masking the returned short
 59584:   // with 0x8000 the result will be 0 if the key is not pressed and non-zero
 59584:   // otherwise.
 59584:   if (GetKeyState(VK_SHIFT) & 0x8000 &&
 59584:       !(GetKeyState(VK_CONTROL) & 0x8000) && !(GetKeyState(VK_MENU) & 0x8000)) {
 80486:     gSafeMode = true;
 59584:   }
 57882: #endif
 57882: 
     1: #ifdef XP_MACOSX
 12558:   if (GetCurrentEventKeyModifiers() & optionKey)
 80486:     gSafeMode = true;
     1: #endif
     1: 
 89532:   // Handle -no-remote and -new-instance command line arguments. Setup
 89532:   // the environment to better accommodate other components and various
 89532:   // restart scenarios.
 80486:   ar = CheckArg("no-remote", true);
  3321:   if (ar == ARG_BAD) {
 89532:     PR_fprintf(PR_STDERR, "Error: argument -no-remote is invalid when argument -osint is specified\n");
  3321:     return 1;
  3321:   } else if (ar == ARG_FOUND) {
 41012:     SaveToEnv("MOZ_NO_REMOTE=1");
  3321:   }
 94158: 
 89532:   ar = CheckArg("new-instance", true);
 89532:   if (ar == ARG_BAD) {
 89532:     PR_fprintf(PR_STDERR, "Error: argument -new-instance is invalid when argument -osint is specified\n");
 89532:     return 1;
 89532:   } else if (ar == ARG_FOUND) {
 89532:     SaveToEnv("MOZ_NEW_INSTANCE=1");
 89532:   }
     1: 
     1:   // Handle -help and -version command line arguments.
     1:   // They should return quickly, so we deal with them here.
     1:   if (CheckArg("h") || CheckArg("help") || CheckArg("?")) {
     1:     DumpHelp();
 94158:     *aExitFlag = true;
     1:     return 0;
     1:   }
     1: 
     1:   if (CheckArg("v") || CheckArg("version")) {
     1:     DumpVersion();
 94158:     *aExitFlag = true;
     1:     return 0;
     1:   }
     1:     
     1: #ifdef NS_TRACE_MALLOC
 94158:   gArgc = NS_TraceMallocStartupArgs(gArgc, gArgv);
     1: #endif
     1: 
 36040:   rv = XRE_InitCommandLine(gArgc, gArgv);
 36040:   NS_ENSURE_SUCCESS(rv, 1);
 35746: 
     1:   // Check for -register, which registers chrome and then exits immediately.
 80486:   ar = CheckArg("register", true);
  3321:   if (ar == ARG_BAD) {
  3321:     PR_fprintf(PR_STDERR, "Error: argument -register is invalid when argument -osint is specified\n");
  3321:     return 1;
  3321:   } else if (ar == ARG_FOUND) {
     1:     ScopedXPCOMStartup xpcom;
     1:     rv = xpcom.Initialize();
     1:     NS_ENSURE_SUCCESS(rv, 1);
     1:     {
 42314:       nsCOMPtr<nsIChromeRegistry> chromeReg =
 42314:         mozilla::services::GetChromeRegistryService();
     1:       NS_ENSURE_TRUE(chromeReg, 1);
     1: 
     1:       chromeReg->CheckForNewChrome();
     1:     }
 94158:     *aExitFlag = true;
     1:     return 0;
     1:   }
     1: 
 94158:   return 0;
 94158: }
 94158: 
 94158: /*
 94158:  * XRE_mainStartup - Initializes the profile and various other services.
 94158:  * Main() will exit early if either return value != 0 or if aExitFlag is
 94158:  * true.
 94158:  */
 94158: int
 94158: XREMain::XRE_mainStartup(bool* aExitFlag)
 94158: {
 94158:   nsresult rv;
 94158: 
 94158:   if (!aExitFlag)
 94158:     return 1;
 94158:   *aExitFlag = false;
 94158: 
102173: #if defined(MOZ_WIDGET_GTK) || defined(MOZ_ENABLE_XREMOTE)
     1:   // Stash DESKTOP_STARTUP_ID in malloc'ed memory because gtk_init will clear it.
     1: #define HAVE_DESKTOP_STARTUP_ID
     1:   const char* desktopStartupIDEnv = PR_GetEnv("DESKTOP_STARTUP_ID");
     1:   if (desktopStartupIDEnv) {
 94158:     mDesktopStartupID.Assign(desktopStartupIDEnv);
     1:   }
     1: #endif
     1: 
 16759: #if defined(MOZ_WIDGET_QT)
 80518:   nsQAppInstance::AddRef(gArgc, gArgv, true);
 48828: 
 51787: #if MOZ_PLATFORM_MAEMO > 5
 51787:   if (XRE_GetProcessType() == GeckoProcessType_Default) {
 48836:     // try to get the MInputContext if possible to support the MeeGo VKB
 80518:     QInputContext* inputContext = qApp->inputContext();
 48836:     if (inputContext && inputContext->identifierName() != "MInputContext") {
 48836:         QInputContext* context = QInputContextFactory::create("MInputContext",
 80518:                                                               qApp);
 48836:         if (context)
 80518:             qApp->setInputContext(context);
 48836:     }
 51787:   }
 51787: #endif
 80518:   QStringList nonQtArguments = qApp->arguments();
 47852:   gQtOnlyArgc = 1;
 47852:   gQtOnlyArgv = (char**) malloc(sizeof(char*) 
 47852:                 * (gRestartArgc - nonQtArguments.size() + 2));
 47852: 
 47852:   // copy binary path
 47852:   gQtOnlyArgv[0] = gRestartArgv[0];
 47852: 
 47852:   for (int i = 1; i < gRestartArgc; ++i) {
 47852:     if (!nonQtArguments.contains(gRestartArgv[i])) {
 47852:       // copy arguments used by Qt for later
 47852:       gQtOnlyArgv[gQtOnlyArgc++] = gRestartArgv[i];
 47852:     }
 47852:   }
106838:   gQtOnlyArgv[gQtOnlyArgc] = nullptr;
 16759: #endif
102173: #if defined(MOZ_WIDGET_GTK)
     1:   // setup for private colormap.  Ideally we'd like to do this
     1:   // in nsAppShell::Create, but we need to get in before gtk
     1:   // has been initialized to make sure everything is running
     1:   // consistently.
102173: #if (MOZ_WIDGET_GTK == 2)
     1:   if (CheckArg("install"))
     1:     gdk_rgb_set_install(TRUE);
102173: #endif
     1: 
107964:   // Set program name to the one defined in application.ini.
107964:   {
110974:     nsAutoCString program(gAppData->name);
107964:     ToLowerCase(program);
107964:     g_set_prgname(program.get());
107964:   }
107964: 
  6370:   // Initialize GTK here for splash.
  6370: 
  6370:   // Open the display ourselves instead of using gtk_init, so that we can
  6370:   // close it without fear that one day gtk might clean up the display it
  6370:   // opens.
  6370:   if (!gtk_parse_args(&gArgc, &gArgv))
  6370:     return 1;
  6370: 
  6370:   // display_name is owned by gdk.
  6370:   const char *display_name = gdk_get_display_arg_name();
 17106:   if (display_name) {
 17106:     SaveWordToEnv("DISPLAY", nsDependentCString(display_name));
 17106:   } else {
  6370:     display_name = PR_GetEnv("DISPLAY");
  6370:     if (!display_name) {
  6370:       PR_fprintf(PR_STDERR, "Error: no display specified\n");
  6370:       return 1;
  6370:     }
  6370:   }
 16744: #endif /* MOZ_WIDGET_GTK2 */
 16744: 
 16744: #ifdef MOZ_ENABLE_XREMOTE
 16744:   // handle -remote now that xpcom is fired up
 94158:   bool newInstance;
 77502:   {
 77502:     char *e = PR_GetEnv("MOZ_NO_REMOTE");
 94158:     mDisableRemote = (e && *e);
 94158:     if (mDisableRemote) {
 89532:       newInstance = true;
 89532:     } else {
 89532:       e = PR_GetEnv("MOZ_NEW_INSTANCE");
 89532:       newInstance = (e && *e);
 89532:     }
 77502:   }
 16744: 
 16744:   const char* xremotearg;
 94158:   ArgResult ar = CheckArg("remote", true, &xremotearg);
 16744:   if (ar == ARG_BAD) {
 16744:     PR_fprintf(PR_STDERR, "Error: -remote requires an argument\n");
 16744:     return 1;
 16744:   }
 16744:   const char* desktopStartupIDPtr =
106838:     mDesktopStartupID.IsEmpty() ? nullptr : mDesktopStartupID.get();
 16744:   if (ar) {
 94158:     *aExitFlag = true;
 16744:     return HandleRemoteArgument(xremotearg, desktopStartupIDPtr);
 16744:   }
 16744: 
 89532:   if (!newInstance) {
 16744:     // Try to remote the entire command line. If this fails, start up normally.
 16744:     RemoteResult rr = RemoteCommandLine(desktopStartupIDPtr);
 94158:     if (rr == REMOTE_FOUND) {
 94158:       *aExitFlag = true;
 16744:       return 0;
 94158:     }
 16744:     else if (rr == REMOTE_ARG_BAD)
 16744:       return 1;
 16744:   }
 16744: #endif
 99109: #ifdef MOZ_X11
 99109:   // Init X11 in thread-safe mode. Must be called prior to the first call to XOpenDisplay 
 99109:   // (called inside gdk_display_open). This is a requirement for off main tread compositing.
 99109:   // This is done only on X11 platforms if the environment variable MOZ_USE_OMTC is set so 
 99109:   // as to avoid overhead when omtc is not used. 
 99109:   // An environment variable is used instead of a pref on X11 platforms because we start having 
 99109:   // access to prefs long after the first call to XOpenDisplay which is hard to change due to 
 99109:   // interdependencies in the initialization.
 99109:   if (PR_GetEnv("MOZ_USE_OMTC")) {
 99109:     XInitThreads();
 99109:   }
 99109: #endif
102173: #if defined(MOZ_WIDGET_GTK)
 94158:   mGdkDisplay = gdk_display_open(display_name);
 94158:   if (!mGdkDisplay) {
  6370:     PR_fprintf(PR_STDERR, "Error: cannot open display: %s\n", display_name);
  6370:     return 1;
  6370:   }
  6370:   gdk_display_manager_set_default_display (gdk_display_manager_get(),
 94158:                                            mGdkDisplay);
     1:     
     1:   // g_set_application_name () is only defined in glib2.2 and higher.
     1:   _g_set_application_name_fn _g_set_application_name =
     1:     (_g_set_application_name_fn)FindFunction("g_set_application_name");
     1:   if (_g_set_application_name) {
 94158:     _g_set_application_name(mAppData->name);
     1:   }
     1:   _gtk_window_set_auto_startup_notification_fn _gtk_window_set_auto_startup_notification =
     1:     (_gtk_window_set_auto_startup_notification_fn)FindFunction("gtk_window_set_auto_startup_notification");
     1:   if (_gtk_window_set_auto_startup_notification) {
 80486:     _gtk_window_set_auto_startup_notification(false);
     1:   }
     1: 
102173: #if (MOZ_WIDGET_GTK == 2)
 24530:   gtk_widget_set_default_colormap(gdk_rgb_get_colormap());
102173: #endif /* (MOZ_WIDGET_GTK == 2) */
102173: #endif /* defined(MOZ_WIDGET_GTK) */
 38688: #ifdef MOZ_X11
 38688:   // Do this after initializing GDK, or GDK will install its own handler.
 38688:   InstallX11ErrorHandler();
 38688: #endif
     1: 
     1:   // Call the code to install our handler
     1: #ifdef MOZ_JPROF
     1:   setupProfilingStuff();
     1: #endif
     1: 
 94158:   rv = NS_CreateNativeAppSupport(getter_AddRefs(mNativeApp));
     1:   if (NS_FAILED(rv))
     1:     return 1;
     1: 
 79445:   bool canRun = false;
 94158:   rv = mNativeApp->Start(&canRun);
     1:   if (NS_FAILED(rv) || !canRun) {
     1:     return 1;
     1:   }
     1: 
102173: #if defined(HAVE_DESKTOP_STARTUP_ID) && defined(MOZ_WIDGET_GTK)
 62986:   // DESKTOP_STARTUP_ID is cleared now,
 62986:   // we recover it in case we need a restart.
 94158:   if (!mDesktopStartupID.IsEmpty()) {
110974:     nsAutoCString desktopStartupEnv;
 62986:     desktopStartupEnv.AssignLiteral("DESKTOP_STARTUP_ID=");
 94158:     desktopStartupEnv.Append(mDesktopStartupID);
 62986:     // Leak it with extreme prejudice!
 62986:     PR_SetEnv(ToNewCString(desktopStartupEnv));
 62986:   }
 62986: #endif
 62986: 
110440: #if defined(USE_MOZ_UPDATER)
     1:   // Check for and process any available updates
   676:   nsCOMPtr<nsIFile> updRoot;
 79445:   bool persistent;
 94158:   rv = mDirProvider.GetFile(XRE_UPDATE_ROOT_DIR, &persistent,
   676:                             getter_AddRefs(updRoot));
   676:   // XRE_UPDATE_ROOT_DIR may fail. Fallback to appDir if failed
   676:   if (NS_FAILED(rv))
 94158:     updRoot = mDirProvider.GetAppDir();
     1: 
 86614:   // If the MOZ_PROCESS_UPDATES environment variable already exists, then
 86614:   // we are being called from the callback application.
 63553:   if (EnvHasValue("MOZ_PROCESS_UPDATES")) {
 86588:     // If the caller has asked us to log our arguments, do so.  This is used
 86588:     // to make sure that the maintenance service successfully launches the
 86588:     // callback application.
106838:     const char *logFile = nullptr;
 86588:     if (ARG_FOUND == CheckArg("dump-args", false, &logFile)) {
 86588:       FILE* logFP = fopen(logFile, "wb");
 86588:       if (logFP) {
 94158:         for (int i = 1; i < gRestartArgc; ++i) {
 86588:           fprintf(logFP, "%s\n", gRestartArgv[i]);
 86588:         }
 86588:         fclose(logFP);
 86588:       }
 86588:     }
 94158:     *aExitFlag = true;
 56164:     return 0;
 56164:   }
 86614: 
 86614:   // Support for processing an update and exiting. The MOZ_PROCESS_UPDATES
 86614:   // environment variable will be part of the updater's environment and the
 86614:   // application that is relaunched by the updater. When the application is
 86614:   // relaunched by the updater it will be removed below and the application
 86614:   // will exit.
 86614:   if (CheckArg("process-updates")) {
 86614:     SaveToEnv("MOZ_PROCESS_UPDATES=1");
 86614:   }
 94158:   ProcessUpdates(mDirProvider.GetGREDir(),
 94158:                  mDirProvider.GetAppDir(),
 86614:                  updRoot,
 86614:                  gRestartArgc,
 86614:                  gRestartArgv,
 94158:                  mAppData->version);
 86614:   if (EnvHasValue("MOZ_PROCESS_UPDATES")) {
 86614:     SaveToEnv("MOZ_PROCESS_UPDATES=");
 94158:     *aExitFlag = true;
 86614:     return 0;
 86614:   }
     1: #endif
     1: 
 94158:   rv = NS_NewToolkitProfileService(getter_AddRefs(mProfileSvc));
 91887:   if (rv == NS_ERROR_FILE_ACCESS_DENIED) {
 91887:     PR_fprintf(PR_STDERR, "Error: Access was denied while trying to open files in " \
 91887:                 "your profile directory.\n");
 91887:   }
 91887:   if (NS_FAILED(rv)) {
 91887:     // We failed to choose or create profile - notify user and quit
 94158:     ProfileMissingDialog(mNativeApp);
 91887:     return 1;
 91887:   }
 91887: 
 94158:   rv = SelectProfile(getter_AddRefs(mProfileLock), mProfileSvc, mNativeApp, &mStartOffline,
 94158:                       &mProfileName);
     1:   if (rv == NS_ERROR_LAUNCHED_CHILD_PROCESS ||
 94158:       rv == NS_ERROR_ABORT) {
 94158:     *aExitFlag = true;
 94158:     return 0;
 94158:   }
 39026: 
 39026:   if (NS_FAILED(rv)) {
 39026:     // We failed to choose or create profile - notify user and quit
 94158:     ProfileMissingDialog(mNativeApp);
 39026:     return 1;
 39026:   }
 94158:   gProfileLock = mProfileLock;
 94158: 
 94158:   rv = mProfileLock->GetDirectory(getter_AddRefs(mProfD));
     1:   NS_ENSURE_SUCCESS(rv, 1);
     1: 
 94158:   rv = mProfileLock->GetLocalDirectory(getter_AddRefs(mProfLD));
     1:   NS_ENSURE_SUCCESS(rv, 1);
     1: 
 94158:   rv = mDirProvider.SetProfile(mProfD, mProfLD);
     1:   NS_ENSURE_SUCCESS(rv, 1);
     1: 
     1:   //////////////////////// NOW WE HAVE A PROFILE ////////////////////////
     1: 
  4389: #ifdef MOZ_CRASHREPORTER
 94158:   if (mAppData->flags & NS_XRE_ENABLE_CRASH_REPORTER)
 94158:       MakeOrSetMinidumpPath(mProfD);
     1: #endif
     1: 
110974:   nsAutoCString version;
     1:   BuildVersion(version);
     1: 
     1: #ifdef TARGET_OS_ABI
     1:   NS_NAMED_LITERAL_CSTRING(osABI, TARGET_OS_ABI);
     1: #else
     1:   // No TARGET_XPCOM_ABI, but at least the OS is known
     1:   NS_NAMED_LITERAL_CSTRING(osABI, OS_TARGET "_UNKNOWN");
     1: #endif
     1: 
     1:   // Check for version compatibility with the last version of the app this 
     1:   // profile was started with.  The format of the version stamp is defined
     1:   // by the BuildVersion function.
 33900:   // Also check to see if something has happened to invalidate our
 33900:   // fastload caches, like an extension upgrade or installation.
 47163:  
 47163:   // If we see .purgecaches, that means someone did a make. 
 47163:   // Re-register components to catch potential changes.
101111:   nsCOMPtr<nsIFile> flagFile;
 55170: 
 47163:   rv = NS_ERROR_FILE_NOT_FOUND;
 47163:   nsCOMPtr<nsIFile> fFlagFile;
 94158:   if (mAppData->directory) {
 94158:     rv = mAppData->directory->Clone(getter_AddRefs(fFlagFile));
 47163:   }
 47163:   flagFile = do_QueryInterface(fFlagFile);
 47163:   if (flagFile) {
 52024:     flagFile->AppendNative(FILE_INVALIDATE_CACHES);
 47163:   }
 55170: 
 79445:   bool cachesOK;
 94158:   bool versionOK = CheckCompatibility(mProfD, version, osABI, 
 94158:                                       mDirProvider.GetGREDir(),
 94158:                                       mAppData->directory, flagFile,
 47163:                                       &cachesOK);
 47163:   if (CheckArg("purgecaches")) {
 80486:     cachesOK = false;
 47163:   }
 47163:   if (PR_GetEnv("MOZ_PURGE_CACHES")) {
 80486:     cachesOK = false;
 47163:   }
     1:  
     1:   // Every time a profile is loaded by a build with a different version,
     1:   // it updates the compatibility.ini file saying what version last wrote
 47009:   // the fastload caches.  On subsequent launches if the version matches, 
     1:   // there is no need for re-registration.  If the user loads the same
     1:   // profile in different builds the component registry must be
     1:   // re-generated to prevent mysterious component loading failures.
     1:   //
     1:   if (gSafeMode) {
 94158:     RemoveComponentRegistries(mProfD, mProfLD, false);
 94158:     WriteVersion(mProfD, NS_LITERAL_CSTRING("Safe Mode"), osABI,
 94158:                  mDirProvider.GetGREDir(), mAppData->directory);
     1:   }
     1:   else if (versionOK) {
 33900:     if (!cachesOK) {
 47009:       // Remove caches, forcing component re-registration.
     1:       // The new list of additional components directories is derived from
     1:       // information in "extensions.ini".
 94158:       RemoveComponentRegistries(mProfD, mProfLD, false);
 33900:         
 33900:       // Rewrite compatibility.ini to remove the flag
 94158:       WriteVersion(mProfD, version, osABI,
 94158:                    mDirProvider.GetGREDir(), mAppData->directory);
     1:     }
     1:     // Nothing need be done for the normal startup case.
     1:   }
     1:   else {
 47009:     // Remove caches, forcing component re-registration
     1:     // with the default set of components (this disables any potentially
     1:     // troublesome incompatible XPCOM components). 
 94158:     RemoveComponentRegistries(mProfD, mProfLD, true);
     1: 
     1:     // Write out version
 94158:     WriteVersion(mProfD, version, osABI,
 94158:                  mDirProvider.GetGREDir(), mAppData->directory);
     1:   }
 43593: 
 47163:   if (flagFile) {
 80486:     flagFile->Remove(true);
 47163:   }
 55170: 
 94158:   return 0;
 94158: }
 94158: 
 94158: /*
 94158:  * XRE_mainRun - Command line startup, profile migration, and
 94158:  * the calling of appStartup->Run().
 94158:  */
 94158: nsresult
 94158: XREMain::XRE_mainRun()
     1: {
 94158:   nsresult rv = NS_OK;
 94158:   NS_ASSERTION(mScopedXPCom, "Scoped xpcom not initialized.");
 42480: 
 42480: #ifdef NS_FUNCTION_TIMER
 42480:   // initialize some common services, so we don't pay the cost for these at odd times later on;
 42480:   // SetWindowCreator -> ChromeRegistry -> IOService -> SocketTransportService -> (nspr wspm init), Prefs
 42480:   {
 42480:     nsCOMPtr<nsISupports> comp;
 42480: 
 42480:     comp = do_GetService("@mozilla.org/preferences-service;1");
 42480: 
 42480:     comp = do_GetService("@mozilla.org/network/socket-transport-service;1");
 42480: 
 42480:     comp = do_GetService("@mozilla.org/network/dns-service;1");
 42480: 
 42480:     comp = do_GetService("@mozilla.org/network/io-service;1");
 42480: 
 42480:     comp = do_GetService("@mozilla.org/chrome/chrome-registry;1");
 42480: 
 42480:     comp = do_GetService("@mozilla.org/focus-event-suppressor-service;1");
 42480:   }
 42480: #endif
 42480: 
 94158:   rv = mScopedXPCom->SetWindowCreator(mNativeApp);
107940:   NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
 34844: #ifdef MOZ_CRASHREPORTER
 34844:   // tell the crash reporter to also send the release channel
 34844:   nsCOMPtr<nsIPrefService> prefs = do_GetService("@mozilla.org/preferences-service;1", &rv);
 34844:   if (NS_SUCCEEDED(rv)) {
 34844:     nsCOMPtr<nsIPrefBranch> defaultPrefBranch;
106838:     rv = prefs->GetDefaultBranch(nullptr, getter_AddRefs(defaultPrefBranch));
 34844: 
 34844:     if (NS_SUCCEEDED(rv)) {
 34844:       nsXPIDLCString sval;
 34844:       rv = defaultPrefBranch->GetCharPref("app.update.channel", getter_Copies(sval));
 34844:       if (NS_SUCCEEDED(rv)) {
 34844:         CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("ReleaseChannel"),
 34844:                                             sval);
 34844:       }
 34844:     }
 34844:   }
 34844: #endif
 41343: 
 94158:   if (mStartOffline) {
  4738:     nsCOMPtr<nsIIOService2> io (do_GetService("@mozilla.org/network/io-service;1"));
107940:     NS_ENSURE_TRUE(io, NS_ERROR_FAILURE);
 80486:     io->SetManageOfflineStatus(false);
 80486:     io->SetOffline(true);
     1:   }
     1: 
     1:   {
     1:     nsCOMPtr<nsIObserver> startupNotifier
     1:       (do_CreateInstance(NS_APPSTARTUPNOTIFIER_CONTRACTID, &rv));
107940:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
106838:     startupNotifier->Observe(nullptr, APPSTARTUP_TOPIC, nullptr);
     1:   }
     1: 
 63892:   nsCOMPtr<nsIAppStartup> appStartup
     1:     (do_GetService(NS_APPSTARTUP_CONTRACTID));
107940:   NS_ENSURE_TRUE(appStartup, NS_ERROR_FAILURE);
     1: 
     1:   if (gDoMigration) {
     1:     nsCOMPtr<nsIFile> file;
 94158:     mDirProvider.GetAppDir()->Clone(getter_AddRefs(file));
     1:     file->AppendNative(NS_LITERAL_CSTRING("override.ini"));
     1:     nsINIParser parser;
101111:     nsresult rv = parser.Init(file);
     1:     if (NS_SUCCEEDED(rv)) {
110974:       nsAutoCString buf;
     1:       rv = parser.GetString("XRE", "EnableProfileMigrator", buf);
     1:       if (NS_SUCCEEDED(rv)) {
     1:         if (buf[0] == '0' || buf[0] == 'f' || buf[0] == 'F') {
 80486:           gDoMigration = false;
     1:         }
     1:       }
     1:     }
     1:   }
     1: 
 99566:   {
 99566:     nsCOMPtr<nsIToolkitProfile> selectedProfile;
 99566:     if (gDoProfileReset) {
 99566:       // At this point we can be sure that profile reset is happening on the default profile.
 99566:       rv = mProfileSvc->GetSelectedProfile(getter_AddRefs(selectedProfile));
 99566:       if (NS_FAILED(rv)) {
 99566:         gDoProfileReset = false;
107940:         return NS_ERROR_FAILURE;
 99566:       }
 99566:     }
 99566: 
     1:     // Profile Migration
 94158:     if (mAppData->flags & NS_XRE_ENABLE_PROFILE_MIGRATOR && gDoMigration) {
 80486:       gDoMigration = false;
 99566:       nsCOMPtr<nsIProfileMigrator> pm(do_CreateInstance(NS_PROFILEMIGRATOR_CONTRACTID));
 91887:       if (pm) {
110974:         nsAutoCString aKey;
 91887:         if (gDoProfileReset) {
 91887:           // Automatically migrate from the current application if we just
 91887:           // reset the profile.
 91887:           aKey = MOZ_APP_NAME;
 99566:         }
 94158:         pm->Migrate(&mDirProvider, aKey);
 99566:       }
 99566:     }
 99566: 
 99566:     if (gDoProfileReset) {
 99566:       nsresult backupCreated = ProfileResetCleanup(selectedProfile);
 99566:       if (NS_FAILED(backupCreated)) NS_WARNING("Could not cleanup the profile that was reset");
 99566: 
 99566:       // Set the new profile as the default after we're done cleaning up the old default.
 94158:       rv = SetCurrentProfileAsDefault(mProfileSvc, mProfD);
 91887:       if (NS_FAILED(rv)) NS_WARNING("Could not set current profile as the default");
 91887:     }
     1:   }
 42480: 
 94158:   mDirProvider.DoStartup();
     1: 
 94158:   appStartup->GetShuttingDown(&mShuttingDown);
 27580: 
 27580:   nsCOMPtr<nsICommandLineRunner> cmdLine;
 27580: 
 27582:   nsCOMPtr<nsIFile> workingDir;
 27582:   rv = NS_GetSpecialDirectory(NS_OS_CURRENT_WORKING_DIR, getter_AddRefs(workingDir));
107940:   NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
 27582: 
 94158:   if (!mShuttingDown) {
 27580:     cmdLine = do_CreateInstance("@mozilla.org/toolkit/command-line;1");
107940:     NS_ENSURE_TRUE(cmdLine, NS_ERROR_FAILURE);
     1: 
 94158:     rv = cmdLine->Init(gArgc, gArgv, workingDir,
 94158:                        nsICommandLine::STATE_INITIAL_LAUNCH);
107940:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
     1:     /* Special-case services that need early access to the command
     1:         line. */
 41540:     nsCOMPtr<nsIObserverService> obsService =
 41540:       mozilla::services::GetObserverService();
 32490:     if (obsService) {
106838:       obsService->NotifyObservers(cmdLine, "command-line-startup", nullptr);
     1:     }
 47636:   }
 47636: 
  6903:   SaveStateForAppInitiatedRestart();
  6903: 
     1:   // clear out any environment variables which may have been set 
     1:   // during the relaunch process now that we know we won't be relaunching.
 41012:   SaveToEnv("XRE_PROFILE_PATH=");
 41012:   SaveToEnv("XRE_PROFILE_LOCAL_PATH=");
 41012:   SaveToEnv("XRE_PROFILE_NAME=");
 41012:   SaveToEnv("XRE_START_OFFLINE=");
 41012:   SaveToEnv("NO_EM_RESTART=");
 41012:   SaveToEnv("XUL_APP_FILE=");
 41012:   SaveToEnv("XRE_BINARY_PATH=");
     1: 
 94158:   if (!mShuttingDown) {
 42023:     rv = appStartup->CreateHiddenWindow();
107940:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
 42023: 
102173: #if defined(HAVE_DESKTOP_STARTUP_ID) && defined(MOZ_WIDGET_GTK)
 80842:     nsGTKToolkit* toolkit = nsGTKToolkit::GetToolkit();
 94158:     if (toolkit && !mDesktopStartupID.IsEmpty()) {
 94158:       toolkit->SetDesktopStartupID(mDesktopStartupID);
 42023:     }
 62986:     // Clear the environment variable so it won't be inherited by
 62986:     // child processes and confuse things.
 62986:     g_unsetenv ("DESKTOP_STARTUP_ID");
 42023: #endif
 42023: 
     1: #ifdef XP_MACOSX
 59790:     // Set up ability to respond to system (Apple) events. This must be
 59790:     // done before setting up the command line service.
 59790:     SetupMacApplicationDelegate();
 59790: 
     1:     // we re-initialize the command-line service and do appleevents munging
     1:     // after we are sure that we're not restarting
     1:     cmdLine = do_CreateInstance("@mozilla.org/toolkit/command-line;1");
107940:     NS_ENSURE_TRUE(cmdLine, NS_ERROR_FAILURE);
     1: 
 80486:     CommandLineServiceMac::SetupMacCommandLine(gArgc, gArgv, false);
     1: 
     1:     rv = cmdLine->Init(gArgc, gArgv,
     1:                         workingDir, nsICommandLine::STATE_INITIAL_LAUNCH);
107940:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: #endif
 27580: 
 41540:     nsCOMPtr<nsIObserverService> obsService =
 41540:       mozilla::services::GetObserverService();
     1:     if (obsService)
106838:       obsService->NotifyObservers(nullptr, "final-ui-startup", nullptr);
     1: 
 94158:     appStartup->GetShuttingDown(&mShuttingDown);
 94158:   }
 94158: 
 94158:   if (!mShuttingDown) {
     1:     rv = cmdLine->Run();
107940:     NS_ENSURE_SUCCESS_LOG(rv, NS_ERROR_FAILURE);
     1: 
 94158:     appStartup->GetShuttingDown(&mShuttingDown);
 94158:   }
 94158: 
 94158:   if (!mShuttingDown) {
     1: #ifdef MOZ_ENABLE_XREMOTE
     1:     // if we have X remote support, start listening for requests on the
     1:     // proxy window.
 94158:     if (!mDisableRemote)
 94158:       mRemoteService = do_GetService("@mozilla.org/toolkit/remote-service;1");
 94158:     if (mRemoteService)
 94158:       mRemoteService->Startup(mAppData->name,
 94158:                               PromiseFlatCString(mProfileName).get());
     1: #endif /* MOZ_ENABLE_XREMOTE */
     1: 
 94158:     mNativeApp->Enable();
 27580:   }
     1: 
 68747: #ifdef MOZ_INSTRUMENT_EVENT_LOOP
 84886:   if (PR_GetEnv("MOZ_INSTRUMENT_EVENT_LOOP") || SAMPLER_IS_ACTIVE()) {
 84886:     mozilla::InitEventTracing();
 68747:   }
 68747: #endif /* MOZ_INSTRUMENT_EVENT_LOOP */
 68747: 
 35746:   {
     1:     rv = appStartup->Run();
     1:     if (NS_FAILED(rv)) {
     1:       NS_ERROR("failed to run appstartup");
 80486:       gLogConsoleErrors = true;
     1:     }
 35746:   }
     1: 
 94158:   return rv;
 94158: }
 94158: 
 94158: /*
 94158:  * XRE_main - A class based main entry point used by most platforms.
 94158:  */
 94158: int
 94158: XREMain::XRE_main(int argc, char* argv[], const nsXREAppData* aAppData)
 94158: {
 94158:   SAMPLER_INIT();
 94158:   SAMPLE_LABEL("Startup", "XRE_Main");
 94158: 
 94158:   nsresult rv = NS_OK;
 94158: 
 94158:   gArgc = argc;
 94158:   gArgv = argv;
 94158: 
 94158:   NS_ENSURE_TRUE(aAppData, 2);
 94158: 
 94158:   mAppData = new ScopedAppData(aAppData);
 94158:   if (!mAppData)
 94158:     return 1;
 94158:   // used throughout this file
 94158:   gAppData = mAppData;
 94158: 
 94158:   ScopedLogging log;
 94158: 
102173: #if defined(MOZ_WIDGET_GTK)
119190: #if defined(MOZ_MEMORY) || defined(__FreeBSD__) \
119190:   || defined(__NetBSD__) && __NetBSD_Version__ >= 500000000
 94158:   // Disable the slice allocator, since jemalloc already uses similar layout
 94158:   // algorithms, and using a sub-allocator tends to increase fragmentation.
 94158:   // This must be done before g_thread_init() is called.
 94158:   g_slice_set_config(G_SLICE_CONFIG_ALWAYS_MALLOC, 1);
 94158: #endif
 94158:   g_thread_init(NULL);
 94158: #endif
 94158: 
 94158:   // init
 94158:   bool exit = false;
 94158:   int result = XRE_mainInit(aAppData, &exit);
 94158:   if (result != 0 || exit)
 94158:     return result;
 94158: 
 94158:   // startup
 94158:   result = XRE_mainStartup(&exit);
 94158:   if (result != 0 || exit)
 94158:     return result;
 94158: 
 94158:   bool appInitiatedRestart = false;
 94158: 
 94158:   // Start the real application
 94158:   mScopedXPCom = new ScopedXPCOMStartup();
 94158:   if (!mScopedXPCom)
 94158:     return 1;
 94158: 
 94158:   rv = mScopedXPCom->Initialize();
 94158:   NS_ENSURE_SUCCESS(rv, 1);
 94158: 
 94158:   // run!
 94158:   rv = XRE_mainRun();
 94158: 
 68747: #ifdef MOZ_INSTRUMENT_EVENT_LOOP
 68747:   mozilla::ShutdownEventTracing();
 68747: #endif
 68747: 
     1:   // Check for an application initiated restart.  This is one that
     1:   // corresponds to nsIAppStartup.quit(eRestart)
 94158:   if (rv == NS_SUCCESS_RESTART_APP) {
 80486:     appInitiatedRestart = true;
 94158:   }
 94158: 
 94158:   if (!mShuttingDown) {
     1: #ifdef MOZ_ENABLE_XREMOTE
     1:     // shut down the x remote proxy window
 94158:     if (mRemoteService) {
 94158:       mRemoteService->Shutdown();
 94158:     }
     1: #endif /* MOZ_ENABLE_XREMOTE */
 27580:   }
     1: 
 94158:   delete mScopedXPCom;
106838:   mScopedXPCom = nullptr;
  3367: 
  3367:   // unlock the profile after ScopedXPCOMStartup object (xpcom) 
  3367:   // has gone out of scope.  see bug #386739 for more details
 94158:   mProfileLock->Unlock();
106838:   gProfileLock = nullptr;
     1: 
 80518: #if defined(MOZ_WIDGET_QT)
 80518:   nsQAppInstance::Release();
 80518: #endif
 80518: 
     1:   // Restart the app after XPCOM has been shut down cleanly. 
 47636:   if (appInitiatedRestart) {
  6903:     RestoreStateForAppInitiatedRestart();
     1: 
     1:     // Ensure that these environment variables are set:
 94158:     SaveFileToEnvIfUnset("XRE_PROFILE_PATH", mProfD);
 94158:     SaveFileToEnvIfUnset("XRE_PROFILE_LOCAL_PATH", mProfLD);
 94158:     SaveWordToEnvIfUnset("XRE_PROFILE_NAME", mProfileName);
     1: 
102173: #ifdef MOZ_WIDGET_GTK
 94158:     MOZ_gdk_display_close(mGdkDisplay);
  6370: #endif
  6370: 
 94158:     rv = LaunchChild(mNativeApp, true);
   155: 
  4389: #ifdef MOZ_CRASHREPORTER
 94158:     if (mAppData->flags & NS_XRE_ENABLE_CRASH_REPORTER)
   155:       CrashReporter::UnsetExceptionHandler();
   157: #endif
     1:     return rv == NS_ERROR_LAUNCHED_CHILD_PROCESS ? 0 : 1;
     1:   }
  6370: 
102173: #ifdef MOZ_WIDGET_GTK
  6370:   // gdk_display_close also calls gdk_display_manager_set_default_display
  6370:   // appropriately when necessary.
 94158:   MOZ_gdk_display_close(mGdkDisplay);
  6370: #endif
     1: 
  4389: #ifdef MOZ_CRASHREPORTER
 94158:   if (mAppData->flags & NS_XRE_ENABLE_CRASH_REPORTER)
   155:       CrashReporter::UnsetExceptionHandler();
   157: #endif
   157: 
 36159:   XRE_DeinitCommandLine();
 36159: 
     1:   return NS_FAILED(rv) ? 1 : 0;
     1: }
 36190: 
 94158: int
108991: XRE_main(int argc, char* argv[], const nsXREAppData* aAppData, uint32_t aFlags)
 94158: {
 94158:   XREMain main;
103860:   int result = main.XRE_main(argc, argv, aAppData);
103860:   mozilla::RecordShutdownEndTimeStamp();
103860:   return result;
 94158: }
 94158: 
 36190: nsresult
 36190: XRE_InitCommandLine(int aArgc, char* aArgv[])
 36190: {
 36190:   nsresult rv = NS_OK;
 36190: 
 36190: #if defined(OS_WIN)
 36190:   CommandLine::Init(aArgc, aArgv);
 36190: #else
 46923: 
 36190:   // these leak on error, but that's OK: we'll just exit()
 36190:   char** canonArgs = new char*[aArgc];
 36190: 
 36190:   // get the canonical version of the binary's path
101111:   nsCOMPtr<nsIFile> binFile;
 36190:   rv = XRE_GetBinaryPath(aArgv[0], getter_AddRefs(binFile));
 36190:   if (NS_FAILED(rv))
 36190:     return NS_ERROR_FAILURE;
 36190: 
110974:   nsAutoCString canonBinPath;
 36190:   rv = binFile->GetNativePath(canonBinPath);
 36190:   if (NS_FAILED(rv))
 36190:     return NS_ERROR_FAILURE;
 36190: 
 36190:   canonArgs[0] = strdup(canonBinPath.get());
 36190: 
 36190:   for (int i = 1; i < aArgc; ++i) {
 36190:     if (aArgv[i]) {
 36190:       canonArgs[i] = strdup(aArgv[i]);
 36190:     }
 36190:   }
 36190:  
 36190:   NS_ASSERTION(!CommandLine::IsInitialized(), "Bad news!");
 36190:   CommandLine::Init(aArgc, canonArgs);
 36190: 
 36190:   for (int i = 0; i < aArgc; ++i)
 36190:       free(canonArgs[i]);
 36190:   delete[] canonArgs;
 36190: #endif
 49360: 
106838:   const char *path = nullptr;
 80486:   ArgResult ar = CheckArg("greomni", false, &path);
 49360:   if (ar == ARG_BAD) {
 70010:     PR_fprintf(PR_STDERR, "Error: argument -greomni requires a path argument\n");
 49360:     return NS_ERROR_FAILURE;
 49360:   }
 49360: 
 70010:   if (!path)
 49360:     return rv;
 49360: 
101111:   nsCOMPtr<nsIFile> greOmni;
 70010:   rv = XRE_GetFileFromPath(path, getter_AddRefs(greOmni));
 70010:   if (NS_FAILED(rv)) {
 70010:     PR_fprintf(PR_STDERR, "Error: argument -greomni requires a valid path\n");
 70010:     return rv;
 70010:   }
 70010: 
 80486:   ar = CheckArg("appomni", false, &path);
 70010:   if (ar == ARG_BAD) {
 70010:     PR_fprintf(PR_STDERR, "Error: argument -appomni requires a path argument\n");
 70010:     return NS_ERROR_FAILURE;
 70010:   }
 70010: 
101111:   nsCOMPtr<nsIFile> appOmni;
 70010:   if (path) {
 70010:       rv = XRE_GetFileFromPath(path, getter_AddRefs(appOmni));
 70010:       if (NS_FAILED(rv)) {
 70010:         PR_fprintf(PR_STDERR, "Error: argument -appomni requires a valid path\n");
 70010:         return rv;
 70010:       }
 70010:   }
 70010: 
 70010:   mozilla::Omnijar::Init(greOmni, appOmni);
 36190:   return rv;
 36190: }
 36190: 
 36190: nsresult
 36190: XRE_DeinitCommandLine()
 36190: {
 36190:   nsresult rv = NS_OK;
 36190: 
 36190:   CommandLine::Terminate();
 36190: 
 36190:   return rv;
 36190: }
 36190: 
 36190: GeckoProcessType
 36190: XRE_GetProcessType()
 36190: {
 36190:   return mozilla::startup::sChildProcessType;
 36190: }
 36190: 
 36608: void
 36609: SetupErrorHandling(const char* progname)
 36608: {
 36608: #ifdef XP_WIN
 36608:   /* On Windows XPSP3 and Windows Vista if DEP is configured off-by-default
 36608:      we still want DEP protection: enable it explicitly and programmatically.
 36608:      
 36608:      This function is not available on WinXPSP2 so we dynamically load it.
 36608:   */
 36608: 
 36608:   HMODULE kernel32 = GetModuleHandleW(L"kernel32.dll");
 36608:   SetProcessDEPPolicyFunc _SetProcessDEPPolicy =
 36608:     (SetProcessDEPPolicyFunc) GetProcAddress(kernel32, "SetProcessDEPPolicy");
 36608:   if (_SetProcessDEPPolicy)
 36608:     _SetProcessDEPPolicy(PROCESS_DEP_ENABLE);
 36608: #endif
 36608: 
 69105: #ifdef XP_WIN32
 36608:   // Suppress the "DLL Foo could not be found" dialog, such that if dependent
 36608:   // libraries (such as GDI+) are not preset, we gracefully fail to load those
 36608:   // XPCOM components, instead of being ungraceful.
 36608:   UINT realMode = SetErrorMode(0);
 36608:   realMode |= SEM_FAILCRITICALERRORS;
 36608:   // If XRE_NO_WINDOWS_CRASH_DIALOG is set, suppress displaying the "This
 36608:   // application has crashed" dialog box.  This is mainly useful for
 36608:   // automated testing environments, e.g. tinderbox, where there's no need
 36608:   // for a dozen of the dialog boxes to litter the console
 36608:   if (getenv("XRE_NO_WINDOWS_CRASH_DIALOG"))
 36608:     realMode |= SEM_NOGPFAULTERRORBOX | SEM_NOOPENFILEERRORBOX;
 36608: 
 36608:   SetErrorMode(realMode);
 36608: 
 36608: #endif
 36608: 
110464: #if defined (DEBUG) && defined(XP_WIN)
110464:   // Send MSCRT Warnings, Errors and Assertions to stderr.
110464:   // See http://msdn.microsoft.com/en-us/library/1y71x448(v=VS.80).aspx
110464:   // and http://msdn.microsoft.com/en-us/library/a68f826y(v=VS.80).aspx.
110464: 
110464:   _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);
110464:   _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);
110464:   _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);
110464:   _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);
110464:   _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);
110464:   _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);
110464: 
110464:   _CrtSetReportHook(MSCRTReportHook);
110464: #endif
110464: 
 37645: #ifndef XP_OS2
 36609:   InstallSignalHandlers(progname);
 37645: #endif
 36608: 
 36608:   // Unbuffer stdout, needed for tinderbox tests.
 36608:   setbuf(stdout, 0);
114319: }
114319: 
