    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * rendering object for the point that anchors out-of-flow rendering
    1:  * objects such as floats and absolutely positioned elements
    1:  */
    1: 
    1: /*
    1:  * Destruction of a placeholder and its out-of-flow must observe the
    1:  * following constraints:
    1:  *
    1:  * - The mapping from the out-of-flow to the placeholder must be
    1:  *   removed from the frame manager before the placeholder is destroyed.
    1:  * - The mapping from the out-of-flow to the placeholder must be
    1:  *   removed from the frame manager before the out-of-flow is destroyed.
    1:  * - The placeholder must be removed from the frame tree, or have the
    1:  *   mapping from it to its out-of-flow cleared, before the out-of-flow
    1:  *   is destroyed (so that the placeholder will not point to a destroyed
    1:  *   frame while it's in the frame tree).
    1:  *
36646:  * Furthermore, some code assumes that placeholders point to something
36646:  * useful, so placeholders without an associated out-of-flow should not
36646:  * remain in the tree.
    1:  *
36646:  * The placeholder's Destroy() implementation handles the destruction of
36646:  * the placeholder and its out-of-flow. To avoid crashes, frame removal
36646:  * and destruction code that works with placeholders must not assume
36646:  * that the placeholder points to its out-of-flow.
    1:  */
    1: 
    1: #ifndef nsPlaceholderFrame_h___
    1: #define nsPlaceholderFrame_h___
    1: 
32106: #include "nsFrame.h"
    1: #include "nsGkAtoms.h"
    1: 
34912: nsIFrame* NS_NewPlaceholderFrame(nsIPresShell* aPresShell,
34912:                                  nsStyleContext* aContext,
34912:                                  nsFrameState aTypeBit);
34912: 
34912: // Frame state bits that are used to keep track of what this is a
34912: // placeholder for.
43376: #define PLACEHOLDER_FOR_FLOAT    NS_FRAME_STATE_BIT(20)
43376: #define PLACEHOLDER_FOR_ABSPOS   NS_FRAME_STATE_BIT(21)
43376: #define PLACEHOLDER_FOR_FIXEDPOS NS_FRAME_STATE_BIT(22)
43376: #define PLACEHOLDER_FOR_POPUP    NS_FRAME_STATE_BIT(23)
43376: #define PLACEHOLDER_TYPE_MASK    (PLACEHOLDER_FOR_FLOAT | \
43376:                                   PLACEHOLDER_FOR_ABSPOS | \
43376:                                   PLACEHOLDER_FOR_FIXEDPOS | \
43376:                                   PLACEHOLDER_FOR_POPUP)
    1: 
    1: /**
    1:  * Implementation of a frame that's used as a placeholder for a frame that
    1:  * has been moved out of the flow
    1:  */
32106: class nsPlaceholderFrame : public nsFrame {
    1: public:
32423:   NS_DECL_FRAMEARENA_HELPERS
32423: 
    1:   /**
34912:    * Create a new placeholder frame.  aTypeBit must be one of the
34912:    * PLACEHOLDER_FOR_* constants above.
    1:    */
34912:   friend nsIFrame* NS_NewPlaceholderFrame(nsIPresShell* aPresShell,
34912:                                           nsStyleContext* aContext,
34912:                                           nsFrameState aTypeBit);
34912:   nsPlaceholderFrame(nsStyleContext* aContext, nsFrameState aTypeBit) :
34912:     nsFrame(aContext)
34912:   {
34912:     NS_PRECONDITION(aTypeBit == PLACEHOLDER_FOR_FLOAT ||
34912:                     aTypeBit == PLACEHOLDER_FOR_ABSPOS ||
34912:                     aTypeBit == PLACEHOLDER_FOR_FIXEDPOS ||
34912:                     aTypeBit == PLACEHOLDER_FOR_POPUP,
34912:                     "Unexpected type bit");
34912:     AddStateBits(aTypeBit);
34912:   }
    1:   virtual ~nsPlaceholderFrame();
    1: 
    1:   // Get/Set the associated out of flow frame
    1:   nsIFrame*  GetOutOfFlowFrame() const {return mOutOfFlowFrame;}
32106:   void       SetOutOfFlowFrame(nsIFrame* aFrame) {
32106:                NS_ASSERTION(!aFrame || !aFrame->GetPrevContinuation(),
32106:                             "OOF must be first continuation");
32106:                mOutOfFlowFrame = aFrame;
32106:              }
    1: 
    1:   // nsIHTMLReflow overrides
    1:   // We need to override GetMinWidth and GetPrefWidth because XUL uses
    1:   // placeholders not within lines.
68481:   virtual nscoord GetMinWidth(nsRenderingContext *aRenderingContext);
68481:   virtual nscoord GetPrefWidth(nsRenderingContext *aRenderingContext);
68481:   virtual void AddInlineMinWidth(nsRenderingContext *aRenderingContext,
    1:                                  InlineMinWidthData *aData);
68481:   virtual void AddInlinePrefWidth(nsRenderingContext *aRenderingContext,
    1:                                   InlinePrefWidthData *aData);
43887:   virtual nsSize GetMinSize(nsBoxLayoutState& aBoxLayoutState);
43887:   virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState);
43887:   virtual nsSize GetMaxSize(nsBoxLayoutState& aBoxLayoutState);
    1:   NS_IMETHOD Reflow(nsPresContext* aPresContext,
    1:                     nsHTMLReflowMetrics& aDesiredSize,
    1:                     const nsHTMLReflowState& aReflowState,
    1:                     nsReflowStatus& aStatus);
    1: 
36647:   virtual void DestroyFrom(nsIFrame* aDestructRoot);
    1: 
    1:   // nsIFrame overrides
    1: #if defined(DEBUG) || (defined(MOZ_REFLOW_PERF_DSP) && defined(MOZ_REFLOW_PERF))
    1:   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                               const nsRect&           aDirtyRect,
    1:                               const nsDisplayListSet& aLists);
    1: #endif // DEBUG || (MOZ_REFLOW_PERF_DSP && MOZ_REFLOW_PERF)
    1:   
    1: #ifdef DEBUG
    1:   NS_IMETHOD List(FILE* out, PRInt32 aIndent) const;
    1: #endif // DEBUG
    1: 
    1:   /**
    1:    * Get the "type" of the frame
    1:    *
    1:    * @see nsGkAtoms::placeholderFrame
    1:    */
    1:   virtual nsIAtom* GetType() const;
    1: 
    1: #ifdef DEBUG
    1:   NS_IMETHOD GetFrameName(nsAString& aResult) const;
    1: #endif
    1: 
79445:   virtual bool IsEmpty() { return true; }
79445:   virtual bool IsSelfEmpty() { return true; }
    1: 
79445:   virtual bool CanContinueTextRun() const;
    1: 
    1: #ifdef ACCESSIBILITY
46338:   virtual already_AddRefed<nsAccessible> CreateAccessible()
    1:   {
    1:     nsIFrame* realFrame = GetRealFrameForPlaceholder(this);
46338:     return realFrame ? realFrame->CreateAccessible() :
46338:                        nsFrame::CreateAccessible();
    1:   }
    1: #endif
    1: 
78202:   virtual nsIFrame* GetParentStyleContextFrame();
78202: 
    1:   /**
    1:    * @return the out-of-flow for aFrame if aFrame is a placeholder; otherwise
    1:    * aFrame
    1:    */
    1:   static nsIFrame* GetRealFrameFor(nsIFrame* aFrame) {
    1:     NS_PRECONDITION(aFrame, "Must have a frame to work with");
    1:     if (aFrame->GetType() == nsGkAtoms::placeholderFrame) {
    1:       return GetRealFrameForPlaceholder(aFrame);
    1:     }
    1:     return aFrame;
    1:   }
    1: 
    1:   /**
    1:    * @return the out-of-flow for aFrame, which is known to be a placeholder
    1:    */
    1:   static nsIFrame* GetRealFrameForPlaceholder(nsIFrame* aFrame) {
    1:     NS_PRECONDITION(aFrame->GetType() == nsGkAtoms::placeholderFrame,
    1:                     "Must have placeholder frame as input");
    1:     nsIFrame* outOfFlow =
 3233:       static_cast<nsPlaceholderFrame*>(aFrame)->GetOutOfFlowFrame();
    1:     NS_ASSERTION(outOfFlow, "Null out-of-flow for placeholder?");
    1:     return outOfFlow;
    1:   }
    1: 
    1: protected:
    1:   nsIFrame* mOutOfFlowFrame;
    1: };
    1: 
    1: #endif /* nsPlaceholderFrame_h___ */
