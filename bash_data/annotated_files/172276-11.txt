108788: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-*/
108788: /* This Source Code Form is subject to the terms of the Mozilla Public
108788:  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
108788:  * You can obtain one at http://mozilla.org/MPL/2.0/. */
108788: 
108788: #ifndef MOZILLA_TRACKUNIONSTREAM_H_
108788: #define MOZILLA_TRACKUNIONSTREAM_H_
108788: 
108788: #include "MediaStreamGraph.h"
129543: #include <algorithm>
108788: 
108788: namespace mozilla {
108788: 
108788: #ifdef PR_LOGGING
172276: #define LOG(type, msg) PR_LOG(gMediaStreamGraphLog, type, msg)
108788: #else
172276: #define LOG(type, msg)
108788: #endif
108788: 
108788: /**
108788:  * See MediaStreamGraph::CreateTrackUnionStream.
108788:  * This file is only included by MediaStreamGraph.cpp so it's OK to put the
108788:  * entire implementation in this header file.
108788:  */
108788: class TrackUnionStream : public ProcessedMediaStream {
108788: public:
132678:   TrackUnionStream(DOMMediaStream* aWrapper) :
108788:     ProcessedMediaStream(aWrapper),
147552:     mFilterCallback(nullptr),
108788:     mMaxTrackID(0) {}
108788: 
108788:   virtual void RemoveInput(MediaInputPort* aPort)
108788:   {
108991:     for (int32_t i = mTrackMap.Length() - 1; i >= 0; --i) {
108788:       if (mTrackMap[i].mInputPort == aPort) {
108788:         EndTrack(i);
108788:         mTrackMap.RemoveElementAt(i);
108788:       }
108788:     }
108788:     ProcessedMediaStream::RemoveInput(aPort);
108788:   }
108788:   virtual void ProduceOutput(GraphTime aFrom, GraphTime aTo)
108788:   {
108788:     nsAutoTArray<bool,8> mappedTracksFinished;
108788:     nsAutoTArray<bool,8> mappedTracksWithMatchingInputTracks;
108991:     for (uint32_t i = 0; i < mTrackMap.Length(); ++i) {
108788:       mappedTracksFinished.AppendElement(true);
108788:       mappedTracksWithMatchingInputTracks.AppendElement(false);
108788:     }
108788:     bool allFinished = true;
136819:     bool allHaveCurrentData = true;
108991:     for (uint32_t i = 0; i < mInputs.Length(); ++i) {
108788:       MediaStream* stream = mInputs[i]->GetSource();
108788:       if (!stream->IsFinishedOnGraphThread()) {
108788:         allFinished = false;
108788:       }
136819:       if (!stream->HasCurrentData()) {
136819:         allHaveCurrentData = false;
136819:       }
108788:       for (StreamBuffer::TrackIter tracks(stream->GetStreamBuffer());
108788:            !tracks.IsEnded(); tracks.Next()) {
108788:         bool found = false;
108991:         for (uint32_t j = 0; j < mTrackMap.Length(); ++j) {
108788:           TrackMapEntry* map = &mTrackMap[j];
120807:           if (map->mInputPort == mInputs[i] && map->mInputTrackID == tracks->GetID()) {
108788:             bool trackFinished;
120807:             StreamBuffer::Track* outputTrack = mBuffer.FindTrack(map->mOutputTrackID);
120807:             if (!outputTrack || outputTrack->IsEnded()) {
108788:               trackFinished = true;
108788:             } else {
120807:               CopyTrackData(tracks.get(), j, aFrom, aTo, &trackFinished);
108788:             }
108788:             mappedTracksFinished[j] = trackFinished;
108788:             mappedTracksWithMatchingInputTracks[j] = true;
108788:             found = true;
108788:             break;
108788:           }
108788:         }
147552:         if (!found && (!mFilterCallback || mFilterCallback(tracks.get()))) {
108788:           bool trackFinished = false;
108991:           uint32_t mapIndex = AddTrack(mInputs[i], tracks.get(), aFrom);
120807:           CopyTrackData(tracks.get(), mapIndex, aFrom, aTo, &trackFinished);
108788:           mappedTracksFinished.AppendElement(trackFinished);
108788:           mappedTracksWithMatchingInputTracks.AppendElement(true);
108788:         }
108788:       }
108788:     }
108991:     for (int32_t i = mTrackMap.Length() - 1; i >= 0; --i) {
108788:       if (mappedTracksFinished[i]) {
108788:         EndTrack(i);
108788:       } else {
108788:         allFinished = false;
108788:       }
108788:       if (!mappedTracksWithMatchingInputTracks[i]) {
108788:         mTrackMap.RemoveElementAt(i);
108788:       }
108788:     }
108788:     if (allFinished && mAutofinish) {
108788:       // All streams have finished and won't add any more tracks, and
108788:       // all our tracks have actually finished and been removed from our map,
108788:       // so we're finished now.
108788:       FinishOnGraphThread();
108788:     }
108788:     mBuffer.AdvanceKnownTracksTime(GraphTimeToStreamTime(aTo));
136819:     if (allHaveCurrentData) {
136819:       // We can make progress if we're not blocked
136819:       mHasCurrentData = true;
136819:     }
108788:   }
108788: 
147552:   // Consumers may specify a filtering callback to apply to every input track.
147552:   // Returns true to allow the track to act as an input; false to reject it entirely.
147552:   typedef bool (*TrackIDFilterCallback)(StreamBuffer::Track*);
147552:   void SetTrackIDFilter(TrackIDFilterCallback aCallback) {
147552:     mFilterCallback = aCallback;
147552:   }
147552: 
158189:   // Forward SetTrackEnabled(output_track_id, enabled) to the Source MediaStream,
158189:   // translating the output track ID into the correct ID in the source.
158189:   virtual void ForwardTrackEnabled(TrackID aOutputID, bool aEnabled) {
158189:     for (int32_t i = mTrackMap.Length() - 1; i >= 0; --i) {
158189:       if (mTrackMap[i].mOutputTrackID == aOutputID) {
158189:         mTrackMap[i].mInputPort->GetSource()->
158189:           SetTrackEnabled(mTrackMap[i].mInputTrackID, aEnabled);
158189:       }
158189:     }
158189:   }
158189: 
108788: protected:
147552:   TrackIDFilterCallback mFilterCallback;
147552: 
108788:   // Only non-ended tracks are allowed to persist in this map.
108788:   struct TrackMapEntry {
155436:     // mEndOfConsumedInputTicks is the end of the input ticks that we've consumed.
155436:     // 0 if we haven't consumed any yet.
155436:     TrackTicks mEndOfConsumedInputTicks;
155436:     // mEndOfLastInputIntervalInInputStream is the timestamp for the end of the
155436:     // previous interval which was unblocked for both the input and output
155436:     // stream, in the input stream's timeline, or -1 if there wasn't one.
155436:     StreamTime mEndOfLastInputIntervalInInputStream;
155436:     // mEndOfLastInputIntervalInOutputStream is the timestamp for the end of the
155436:     // previous interval which was unblocked for both the input and output
155436:     // stream, in the output stream's timeline, or -1 if there wasn't one.
155436:     StreamTime mEndOfLastInputIntervalInOutputStream;
108788:     MediaInputPort* mInputPort;
120807:     // We keep track IDs instead of track pointers because
120807:     // tracks can be removed without us being notified (e.g.
120807:     // when a finished track is forgotten.) When we need a Track*,
120807:     // we call StreamBuffer::FindTrack, which will return null if
120807:     // the track has been deleted.
120807:     TrackID mInputTrackID;
120807:     TrackID mOutputTrackID;
108788:     nsAutoPtr<MediaSegment> mSegment;
108788:   };
108788: 
108991:   uint32_t AddTrack(MediaInputPort* aPort, StreamBuffer::Track* aTrack,
108788:                     GraphTime aFrom)
108788:   {
108788:     // Use the ID of the source track if we can, otherwise allocate a new
108788:     // unique ID
129543:     TrackID id = std::max(mMaxTrackID + 1, aTrack->GetID());
108788:     mMaxTrackID = id;
108788: 
108788:     TrackRate rate = aTrack->GetRate();
108788:     // Round up the track start time so the track, if anything, starts a
108788:     // little later than the true time. This means we'll have enough
108788:     // samples in our input stream to go just beyond the destination time.
108788:     TrackTicks outputStart = TimeToTicksRoundUp(rate, GraphTimeToStreamTime(aFrom));
108788: 
108788:     nsAutoPtr<MediaSegment> segment;
108788:     segment = aTrack->GetSegment()->CreateEmptyClone();
108991:     for (uint32_t j = 0; j < mListeners.Length(); ++j) {
108788:       MediaStreamListener* l = mListeners[j];
108788:       l->NotifyQueuedTrackChanges(Graph(), id, rate, outputStart,
108788:                                   MediaStreamListener::TRACK_EVENT_CREATED,
108788:                                   *segment);
108788:     }
108788:     segment->AppendNullData(outputStart);
108788:     StreamBuffer::Track* track =
108788:       &mBuffer.AddTrack(id, rate, outputStart, segment.forget());
172276:     LOG(PR_LOG_DEBUG, ("TrackUnionStream %p adding track %d for input stream %p track %d, start ticks %lld",
108788:                        this, id, aPort->GetSource(), aTrack->GetID(),
108788:                        (long long)outputStart));
108788: 
108788:     TrackMapEntry* map = mTrackMap.AppendElement();
155436:     map->mEndOfConsumedInputTicks = 0;
155436:     map->mEndOfLastInputIntervalInInputStream = -1;
155436:     map->mEndOfLastInputIntervalInOutputStream = -1;
108788:     map->mInputPort = aPort;
120807:     map->mInputTrackID = aTrack->GetID();
120807:     map->mOutputTrackID = track->GetID();
108788:     map->mSegment = aTrack->GetSegment()->CreateEmptyClone();
108788:     return mTrackMap.Length() - 1;
108788:   }
108991:   void EndTrack(uint32_t aIndex)
108788:   {
120807:     StreamBuffer::Track* outputTrack = mBuffer.FindTrack(mTrackMap[aIndex].mOutputTrackID);
120807:     if (!outputTrack || outputTrack->IsEnded())
108788:       return;
108991:     for (uint32_t j = 0; j < mListeners.Length(); ++j) {
108788:       MediaStreamListener* l = mListeners[j];
108788:       TrackTicks offset = outputTrack->GetSegment()->GetDuration();
108788:       nsAutoPtr<MediaSegment> segment;
108788:       segment = outputTrack->GetSegment()->CreateEmptyClone();
108788:       l->NotifyQueuedTrackChanges(Graph(), outputTrack->GetID(),
108788:                                   outputTrack->GetRate(), offset,
108788:                                   MediaStreamListener::TRACK_EVENT_ENDED,
108788:                                   *segment);
108788:     }
108788:     outputTrack->SetEnded();
108788:   }
120807:   void CopyTrackData(StreamBuffer::Track* aInputTrack,
120807:                      uint32_t aMapIndex, GraphTime aFrom, GraphTime aTo,
108788:                      bool* aOutputTrackFinished)
108788:   {
108788:     TrackMapEntry* map = &mTrackMap[aMapIndex];
120807:     StreamBuffer::Track* outputTrack = mBuffer.FindTrack(map->mOutputTrackID);
120807:     MOZ_ASSERT(outputTrack && !outputTrack->IsEnded(), "Can't copy to ended track");
120807: 
108788:     TrackRate rate = outputTrack->GetRate();
108788:     MediaSegment* segment = map->mSegment;
108788:     MediaStream* source = map->mInputPort->GetSource();
108788: 
108788:     GraphTime next;
108788:     *aOutputTrackFinished = false;
108788:     for (GraphTime t = aFrom; t < aTo; t = next) {
108788:       MediaInputPort::InputInterval interval = map->mInputPort->GetNextInputInterval(t);
129543:       interval.mEnd = std::min(interval.mEnd, aTo);
108788:       if (interval.mStart >= interval.mEnd)
108788:         break;
108788:       next = interval.mEnd;
108788: 
108788:       // Ticks >= startTicks and < endTicks are in the interval
108788:       StreamTime outputEnd = GraphTimeToStreamTime(interval.mEnd);
108788:       TrackTicks startTicks = outputTrack->GetEnd();
108788:       StreamTime outputStart = GraphTimeToStreamTime(interval.mStart);
108788:       NS_ASSERTION(startTicks == TimeToTicksRoundUp(rate, outputStart),
108788:                    "Samples missing");
108788:       TrackTicks endTicks = TimeToTicksRoundUp(rate, outputEnd);
108788:       TrackTicks ticks = endTicks - startTicks;
155436:       StreamTime inputStart = source->GraphTimeToStreamTime(interval.mStart);
108788:       StreamTime inputEnd = source->GraphTimeToStreamTime(interval.mEnd);
108788:       TrackTicks inputTrackEndPoint = TRACK_TICKS_MAX;
108788: 
120807:       if (aInputTrack->IsEnded()) {
120807:         TrackTicks inputEndTicks = aInputTrack->TimeToTicksRoundDown(inputEnd);
120807:         if (aInputTrack->GetEnd() <= inputEndTicks) {
120807:           inputTrackEndPoint = aInputTrack->GetEnd();
108788:           *aOutputTrackFinished = true;
108788:         }
108788:       }
108788: 
108788:       if (interval.mInputIsBlocked) {
108788:         // Maybe the input track ended?
108788:         segment->AppendNullData(ticks);
172276:         LOG(PR_LOG_DEBUG+1, ("TrackUnionStream %p appending %lld ticks of null data to track %d",
108788:             this, (long long)ticks, outputTrack->GetID()));
108788:       } else {
108788:         // Figuring out which samples to use from the input stream is tricky
108788:         // because its start time and our start time may differ by a fraction
108788:         // of a tick. Assuming the input track hasn't ended, we have to ensure
108788:         // that 'ticks' samples are gathered, even though a tick boundary may
108788:         // occur between outputStart and outputEnd but not between inputStart
108788:         // and inputEnd.
155436:         // These are the properties we need to ensure:
155436:         // 1) Exactly 'ticks' ticks of output are produced, i.e.
155436:         // inputEndTicks - inputStartTicks = ticks.
155436:         // 2) inputEndTicks <= aInputTrack->GetSegment()->GetDuration().
155436:         // 3) In any sequence of intervals where neither stream is blocked,
155436:         // the content of the input track we use is a contiguous sequence of
155436:         // ticks with no gaps or overlaps.
155436:         if (map->mEndOfLastInputIntervalInInputStream != inputStart ||
155436:             map->mEndOfLastInputIntervalInOutputStream != outputStart) {
155436:           // Start of a new series of intervals where neither stream is blocked.
155436:           map->mEndOfConsumedInputTicks = TimeToTicksRoundDown(rate, inputStart) - 1;
155436:         }
155436:         TrackTicks inputStartTicks = map->mEndOfConsumedInputTicks;
155436:         TrackTicks inputEndTicks = inputStartTicks + ticks;
155436:         map->mEndOfConsumedInputTicks = inputEndTicks;
155436:         map->mEndOfLastInputIntervalInInputStream = inputEnd;
155436:         map->mEndOfLastInputIntervalInOutputStream = outputEnd;
155436:         // Now we prove that the above properties hold:
155436:         // Property #1: trivial by construction.
155436:         // Property #3: trivial by construction. Between every two
155436:         // intervals where both streams are not blocked, the above if condition
155436:         // is false and mEndOfConsumedInputTicks advances exactly to match
155436:         // the ticks that were consumed.
155436:         // Property #2:
155436:         // Let originalOutputStart be the value of outputStart and originalInputStart
155436:         // be the value of inputStart when the body of the "if" block was last
155436:         // executed.
155436:         // Let allTicks be the sum of the values of 'ticks' computed since then.
155436:         // The interval [originalInputStart/rate, inputEnd/rate) is the
155436:         // same length as the interval [originalOutputStart/rate, outputEnd/rate),
155436:         // so the latter interval can have at most one more integer in it. Thus
155436:         // TimeToTicksRoundUp(rate, outputEnd) - TimeToTicksRoundUp(rate, originalOutputStart)
155436:         //   <= TimeToTicksRoundDown(rate, inputEnd) - TimeToTicksRoundDown(rate, originalInputStart) + 1
155436:         // Then
155436:         // inputEndTicks = TimeToTicksRoundDown(rate, originalInputStart) - 1 + allTicks
155436:         //   = TimeToTicksRoundDown(rate, originalInputStart) - 1 + TimeToTicksRoundUp(rate, outputEnd) - TimeToTicksRoundUp(rate, originalOutputStart)
155436:         //   <= TimeToTicksRoundDown(rate, originalInputStart) - 1 + TimeToTicksRoundDown(rate, inputEnd) - TimeToTicksRoundDown(rate, originalInputStart) + 1
155436:         //   = TimeToTicksRoundDown(rate, inputEnd)
155436:         //   <= inputEnd/rate
155436:         // (now using the fact that inputEnd <= track->GetEndTimeRoundDown() for a non-ended track)
155436:         //   <= TicksToTimeRoundDown(rate, aInputTrack->GetSegment()->GetDuration())/rate
155436:         //   <= rate*aInputTrack->GetSegment()->GetDuration()/rate
155436:         //   = aInputTrack->GetSegment()->GetDuration()
155436:         // as required.
155436: 
155436:         if (inputStartTicks < 0) {
155436:           // Data before the start of the track is just null.
155450:           // We have to add a small amount of delay to ensure that there is
155450:           // always a sample available if we see an interval that contains a
155450:           // tick boundary on the output stream's timeline but does not contain
155450:           // a tick boundary on the input stream's timeline. 1 tick delay is
155450:           // necessary and sufficient.
155436:           segment->AppendNullData(-inputStartTicks);
155436:           inputStartTicks = 0;
155436:         }
155436:         if (inputEndTicks > inputStartTicks) {
120807:           segment->AppendSlice(*aInputTrack->GetSegment(),
129543:                                std::min(inputTrackEndPoint, inputStartTicks),
129543:                                std::min(inputTrackEndPoint, inputEndTicks));
155436:         }
172276:         LOG(PR_LOG_DEBUG+1, ("TrackUnionStream %p appending %lld ticks of input data to track %d",
129543:             this, (long long)(std::min(inputTrackEndPoint, inputEndTicks) - std::min(inputTrackEndPoint, inputStartTicks)),
108788:             outputTrack->GetID()));
108788:       }
145761:       ApplyTrackDisabling(outputTrack->GetID(), segment);
108991:       for (uint32_t j = 0; j < mListeners.Length(); ++j) {
108788:         MediaStreamListener* l = mListeners[j];
108788:         l->NotifyQueuedTrackChanges(Graph(), outputTrack->GetID(),
108788:                                     outputTrack->GetRate(), startTicks, 0,
108788:                                     *segment);
108788:       }
108788:       outputTrack->GetSegment()->AppendFrom(segment);
108788:     }
108788:   }
108788: 
108788:   nsTArray<TrackMapEntry> mTrackMap;
108788:   TrackID mMaxTrackID;
108788: };
108788: 
108788: }
108788: 
108788: #endif /* MOZILLA_MEDIASTREAMGRAPH_H_ */
