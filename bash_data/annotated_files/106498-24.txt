101616: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
101616: /* vim: set ts=2 et sw=2 tw=80: */
101616: /* This Source Code Form is subject to the terms of the Mozilla Public
101616:  * License, v. 2.0. If a copy of the MPL was not distributed with this
101616:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
101616: 
101616: #include "XULTreeAccessible.h"
101616: 
101616: #include "nsAccCache.h"
101616: #include "nsAccUtils.h"
101616: #include "nsCoreUtils.h"
106498: #include "nsEventShell.h"
101616: #include "DocAccessible.h"
101616: #include "Relation.h"
101616: #include "Role.h"
101616: #include "States.h"
101616: 
101616: #include "nsComponentManagerUtils.h"
101616: #include "nsIAccessibleRelation.h"
101616: #include "nsIAutoCompleteInput.h"
101616: #include "nsIAutoCompletePopup.h"
101616: #include "nsIDOMXULElement.h"
101616: #include "nsIDOMXULMenuListElement.h"
101616: #include "nsIDOMXULMultSelectCntrlEl.h"
101616: #include "nsIDOMXULTreeElement.h"
101616: #include "nsITreeSelection.h"
101616: #include "nsIMutableArray.h"
101616: 
101616: using namespace mozilla::a11y;
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeAccessible
101616: ////////////////////////////////////////////////////////////////////////////////
101616: 
101616: XULTreeAccessible::
101616:   XULTreeAccessible(nsIContent* aContent, DocAccessible* aDoc) :
101616:   AccessibleWrap(aContent, aDoc)
101616: {
101616:   mFlags |= eXULTreeAccessible;
101616: 
101616:   mTree = nsCoreUtils::GetTreeBoxObject(aContent);
101616:   NS_ASSERTION(mTree, "Can't get mTree!\n");
101616: 
101616:   if (mTree) {
101616:     nsCOMPtr<nsITreeView> treeView;
101616:     mTree->GetView(getter_AddRefs(treeView));
101616:     mTreeView = treeView;
101616:   }
101616: 
101616:   nsIContent* parentContent = mContent->GetParent();
101616:   if (parentContent) {
101616:     nsCOMPtr<nsIAutoCompletePopup> autoCompletePopupElm =
101616:       do_QueryInterface(parentContent);
101616:     if (autoCompletePopupElm)
101616:       mFlags |= eAutoCompletePopupAccessible;
101616:   }
101616: 
101616:   mAccessibleCache.Init(kDefaultTreeCacheSize);
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeAccessible: nsISupports and cycle collection implementation
101616: 
101616: NS_IMPL_CYCLE_COLLECTION_CLASS(XULTreeAccessible)
101616: 
101616: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(XULTreeAccessible,
101616:                                                   Accessible)
101616:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mTree)
101616:   CycleCollectorTraverseCache(tmp->mAccessibleCache, &cb);
101616: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
101616: 
101616: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(XULTreeAccessible, Accessible)
101616:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mTree)
101616:   ClearCache(tmp->mAccessibleCache);
101616: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
101616: 
101616: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(XULTreeAccessible)
101616: NS_INTERFACE_MAP_END_INHERITING(Accessible)
101616: 
101616: NS_IMPL_ADDREF_INHERITED(XULTreeAccessible, Accessible)
101616: NS_IMPL_RELEASE_INHERITED(XULTreeAccessible, Accessible)
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeAccessible: Accessible implementation
101616: 
101616: PRUint64
101616: XULTreeAccessible::NativeState()
101616: {
101616:   // Get focus status from base class.
101616:   PRUint64 state = Accessible::NativeState();
101616: 
101616:   // readonly state
101616:   state |= states::READONLY;
101616: 
101616:   // multiselectable state.
101616:   if (!mTreeView)
101616:     return state;
101616: 
101616:   nsCOMPtr<nsITreeSelection> selection;
101616:   mTreeView->GetSelection(getter_AddRefs(selection));
101616:   NS_ENSURE_TRUE(selection, state);
101616: 
101616:   bool isSingle = false;
101616:   nsresult rv = selection->GetSingle(&isSingle);
101616:   NS_ENSURE_SUCCESS(rv, state);
101616: 
101616:   if (!isSingle)
101616:     state |= states::MULTISELECTABLE;
101616: 
101616:   return state;
101616: }
101616: 
101616: void
101616: XULTreeAccessible::Value(nsString& aValue)
101616: {
101616:   aValue.Truncate();
101616:   if (!mTreeView)
101616:     return;
101616: 
101616:   // Return the value is the first selected child.
101616:   nsCOMPtr<nsITreeSelection> selection;
101616:   mTreeView->GetSelection(getter_AddRefs(selection));
101616:   if (!selection)
101616:     return;
101616: 
101616:   PRInt32 currentIndex;
101616:   nsCOMPtr<nsIDOMElement> selectItem;
101616:   selection->GetCurrentIndex(&currentIndex);
101616:   if (currentIndex >= 0) {
101616:     nsCOMPtr<nsITreeColumn> keyCol;
101616: 
101616:     nsCOMPtr<nsITreeColumns> cols;
101616:     mTree->GetColumns(getter_AddRefs(cols));
101616:     if (cols)
101616:       cols->GetKeyColumn(getter_AddRefs(keyCol));
101616: 
101616:     mTreeView->GetCellText(currentIndex, keyCol, aValue);
101616:   }
101616: 
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeAccessible: nsAccessNode implementation
101616: 
101616: void
101616: XULTreeAccessible::Shutdown()
101616: {
101616:   // XXX: we don't remove accessible from document cache if shutdown wasn't
101616:   // initiated by document destroying. Note, we can't remove accessible from
101616:   // document cache here while document is going to be shutdown. Note, this is
101616:   // not unique place where we have similar problem.
101616:   ClearCache(mAccessibleCache);
101616: 
101616:   mTree = nsnull;
101616:   mTreeView = nsnull;
101616: 
101616:   AccessibleWrap::Shutdown();
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeAccessible: Accessible implementation (put methods here)
101616: 
101616: role
101616: XULTreeAccessible::NativeRole()
101616: {
101616:   // No primary column means we're in a list. In fact, history and mail turn off
101616:   // the primary flag when switching to a flat view.
101616: 
101616:   nsCOMPtr<nsITreeColumns> cols;
101616:   mTree->GetColumns(getter_AddRefs(cols));
101616:   nsCOMPtr<nsITreeColumn> primaryCol;
101616:   if (cols)
101616:     cols->GetPrimaryColumn(getter_AddRefs(primaryCol));
101616: 
101616:   return primaryCol ? roles::OUTLINE : roles::LIST;
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeAccessible: Accessible implementation (DON'T put methods here)
101616: 
101616: Accessible*
101616: XULTreeAccessible::ChildAtPoint(PRInt32 aX, PRInt32 aY,
101616:                                 EWhichChildAtPoint aWhichChild)
101616: {
101616:   nsIFrame *frame = GetFrame();
101616:   if (!frame)
101616:     return nsnull;
101616: 
101616:   nsPresContext *presContext = frame->PresContext();
101616:   nsIPresShell* presShell = presContext->PresShell();
101616: 
101616:   nsIFrame *rootFrame = presShell->GetRootFrame();
101616:   NS_ENSURE_TRUE(rootFrame, nsnull);
101616: 
101616:   nsIntRect rootRect = rootFrame->GetScreenRect();
101616: 
101616:   PRInt32 clientX = presContext->DevPixelsToIntCSSPixels(aX) - rootRect.x;
101616:   PRInt32 clientY = presContext->DevPixelsToIntCSSPixels(aY) - rootRect.y;
101616: 
101616:   PRInt32 row = -1;
101616:   nsCOMPtr<nsITreeColumn> column;
101616:   nsCAutoString childEltUnused;
101616:   mTree->GetCellAt(clientX, clientY, &row, getter_AddRefs(column),
101616:                    childEltUnused);
101616: 
101616:   // If we failed to find tree cell for the given point then it might be
101616:   // tree columns.
101616:   if (row == -1 || !column)
101616:     return AccessibleWrap::ChildAtPoint(aX, aY, aWhichChild);
101616: 
101616:   Accessible* child = GetTreeItemAccessible(row);
101616:   if (aWhichChild == eDeepestChild && child) {
101616:     // Look for accessible cell for the found item accessible.
101616:     nsRefPtr<XULTreeItemAccessibleBase> treeitem = do_QueryObject(child);
101616: 
101616:     Accessible* cell = treeitem->GetCellAccessible(column);
101616:     if (cell)
101616:       child = cell;
101616:   }
101616: 
101616:   return child;
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeAccessible: SelectAccessible
101616: 
101616: bool
101616: XULTreeAccessible::IsSelect()
101616: {
101616:   return true;
101616: }
101616: 
101616: Accessible*
101616: XULTreeAccessible::CurrentItem()
101616: {
101616:   if (!mTreeView)
101616:     return nsnull;
101616: 
101616:   nsCOMPtr<nsITreeSelection> selection;
101616:   mTreeView->GetSelection(getter_AddRefs(selection));
101616:   if (selection) {
101616:     PRInt32 currentIndex = -1;
101616:     selection->GetCurrentIndex(&currentIndex);
101616:     if (currentIndex >= 0)
101616:       return GetTreeItemAccessible(currentIndex);
101616:   }
101616: 
101616:   return nsnull;
101616: }
101616: 
101616: void
101616: XULTreeAccessible::SetCurrentItem(Accessible* aItem)
101616: {
101616:   NS_ERROR("XULTreeAccessible::SetCurrentItem not implemented");
101616: }
101616: 
101616: already_AddRefed<nsIArray>
101616: XULTreeAccessible::SelectedItems()
101616: {
101616:   if (!mTreeView)
101616:     return nsnull;
101616: 
101616:   nsCOMPtr<nsITreeSelection> selection;
101616:   mTreeView->GetSelection(getter_AddRefs(selection));
101616:   if (!selection)
101616:     return nsnull;
101616: 
101616:   nsCOMPtr<nsIMutableArray> selectedItems =
101616:     do_CreateInstance(NS_ARRAY_CONTRACTID);
101616:   if (!selectedItems)
101616:     return nsnull;
101616: 
101616:   PRInt32 rangeCount = 0;
101616:   selection->GetRangeCount(&rangeCount);
101616:   for (PRInt32 rangeIdx = 0; rangeIdx < rangeCount; rangeIdx++) {
101616:     PRInt32 firstIdx = 0, lastIdx = -1;
101616:     selection->GetRangeAt(rangeIdx, &firstIdx, &lastIdx);
101616:     for (PRInt32 rowIdx = firstIdx; rowIdx <= lastIdx; rowIdx++) {
101616:       nsIAccessible* item = GetTreeItemAccessible(rowIdx);
101616:       if (item)
101616:         selectedItems->AppendElement(item, false);
101616:     }
101616:   }
101616: 
101616:   nsIMutableArray* items = nsnull;
101616:   selectedItems.forget(&items);
101616:   return items;
101616: }
101616: 
101616: PRUint32
101616: XULTreeAccessible::SelectedItemCount()
101616: {
101616:   if (!mTreeView)
101616:     return 0;
101616: 
101616:   nsCOMPtr<nsITreeSelection> selection;
101616:   mTreeView->GetSelection(getter_AddRefs(selection));
101616:   if (selection) {
101616:     PRInt32 count = 0;
101616:     selection->GetCount(&count);
101616:     return count;
101616:   }
101616: 
101616:   return 0;
101616: }
101616: 
101616: bool
101616: XULTreeAccessible::AddItemToSelection(PRUint32 aIndex)
101616: {
101616:   if (!mTreeView)
101616:     return false;
101616: 
101616:   nsCOMPtr<nsITreeSelection> selection;
101616:   mTreeView->GetSelection(getter_AddRefs(selection));
101616:   if (selection) {
101616:     bool isSelected = false;
101616:     selection->IsSelected(aIndex, &isSelected);
101616:     if (!isSelected)
101616:       selection->ToggleSelect(aIndex);
101616: 
101616:     return true;
101616:   }
101616:   return false;
101616: }
101616: 
101616: bool
101616: XULTreeAccessible::RemoveItemFromSelection(PRUint32 aIndex)
101616: {
101616:   if (!mTreeView)
101616:     return false;
101616: 
101616:   nsCOMPtr<nsITreeSelection> selection;
101616:   mTreeView->GetSelection(getter_AddRefs(selection));
101616:   if (selection) {
101616:     bool isSelected = false;
101616:     selection->IsSelected(aIndex, &isSelected);
101616:     if (isSelected)
101616:       selection->ToggleSelect(aIndex);
101616: 
101616:     return true;
101616:   }
101616:   return false;
101616: }
101616: 
101616: bool
101616: XULTreeAccessible::IsItemSelected(PRUint32 aIndex)
101616: {
101616:   if (!mTreeView)
101616:     return false;
101616: 
101616:   nsCOMPtr<nsITreeSelection> selection;
101616:   mTreeView->GetSelection(getter_AddRefs(selection));
101616:   if (selection) {
101616:     bool isSelected = false;
101616:     selection->IsSelected(aIndex, &isSelected);
101616:     return isSelected;
101616:   }
101616:   return false;
101616: }
101616: 
101616: bool
101616: XULTreeAccessible::UnselectAll()
101616: {
101616:   if (!mTreeView)
101616:     return false;
101616: 
101616:   nsCOMPtr<nsITreeSelection> selection;
101616:   mTreeView->GetSelection(getter_AddRefs(selection));
101616:   if (!selection)
101616:     return false;
101616: 
101616:   selection->ClearSelection();
101616:   return true;
101616: }
101616: 
101616: Accessible*
101616: XULTreeAccessible::GetSelectedItem(PRUint32 aIndex)
101616: {
101616:   if (!mTreeView)
101616:     return nsnull;
101616: 
101616:   nsCOMPtr<nsITreeSelection> selection;
101616:   mTreeView->GetSelection(getter_AddRefs(selection));
101616:   if (!selection)
101616:     return nsnull;
101616: 
101616:   PRUint32 selCount = 0;
101616:   PRInt32 rangeCount = 0;
101616:   selection->GetRangeCount(&rangeCount);
101616:   for (PRInt32 rangeIdx = 0; rangeIdx < rangeCount; rangeIdx++) {
101616:     PRInt32 firstIdx = 0, lastIdx = -1;
101616:     selection->GetRangeAt(rangeIdx, &firstIdx, &lastIdx);
101616:     for (PRInt32 rowIdx = firstIdx; rowIdx <= lastIdx; rowIdx++) {
101616:       if (selCount == aIndex)
101616:         return GetTreeItemAccessible(rowIdx);
101616: 
101616:       selCount++;
101616:     }
101616:   }
101616: 
101616:   return nsnull;
101616: }
101616: 
101616: bool
101616: XULTreeAccessible::SelectAll()
101616: {
101616:   // see if we are multiple select if so set ourselves as such
101616:   if (!mTreeView)
101616:     return false;
101616: 
101616:   nsCOMPtr<nsITreeSelection> selection;
101616:   mTreeView->GetSelection(getter_AddRefs(selection));
101616:   if (selection) {
101616:     bool single = false;
101616:     selection->GetSingle(&single);
101616:     if (!single) {
101616:       selection->SelectAll();
101616:       return true;
101616:     }
101616:   }
101616: 
101616:   return false;
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeAccessible: Accessible implementation
101616: 
101616: Accessible*
101616: XULTreeAccessible::GetChildAt(PRUint32 aIndex)
101616: {
101616:   PRUint32 childCount = Accessible::ChildCount();
101616:   if (aIndex < childCount)
101616:     return Accessible::GetChildAt(aIndex);
101616: 
101616:   return GetTreeItemAccessible(aIndex - childCount);
101616: }
101616: 
101616: PRUint32
101616: XULTreeAccessible::ChildCount() const
101616: {
101616:   // Tree's children count is row count + treecols count.
101616:   PRUint32 childCount = Accessible::ChildCount();
101616:   if (!mTreeView)
101616:     return childCount;
101616: 
101616:   PRInt32 rowCount = 0;
101616:   mTreeView->GetRowCount(&rowCount);
101616:   childCount += rowCount;
101616: 
101616:   return childCount;
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeAccessible: Widgets
101616: 
101616: bool
101616: XULTreeAccessible::IsWidget() const
101616: {
101616:   return true;
101616: }
101616: 
101616: bool
101616: XULTreeAccessible::IsActiveWidget() const
101616: {
101616:   if (IsAutoCompletePopup()) {
101616:     nsCOMPtr<nsIAutoCompletePopup> autoCompletePopupElm =
101616:       do_QueryInterface(mContent->GetParent());
101616: 
101616:     if (autoCompletePopupElm) {
101616:       bool isOpen = false;
101616:       autoCompletePopupElm->GetPopupOpen(&isOpen);
101616:       return isOpen;
101616:     }
101616:   }
101616:   return FocusMgr()->HasDOMFocus(mContent);
101616: }
101616: 
101616: bool
101616: XULTreeAccessible::AreItemsOperable() const
101616: {
101616:   if (IsAutoCompletePopup()) {
101616:     nsCOMPtr<nsIAutoCompletePopup> autoCompletePopupElm =
101616:       do_QueryInterface(mContent->GetParent());
101616: 
101616:     if (autoCompletePopupElm) {
101616:       bool isOpen = false;
101616:       autoCompletePopupElm->GetPopupOpen(&isOpen);
101616:       return isOpen;
101616:     }
101616:   }
101616:   return true;
101616: }
101616: 
101616: Accessible*
101616: XULTreeAccessible::ContainerWidget() const
101616: {
101616:   if (IsAutoCompletePopup()) {
101616:     // This works for XUL autocompletes. It doesn't work for HTML forms
101616:     // autocomplete because of potential crossprocess calls (when autocomplete
101616:     // lives in content process while popup lives in chrome process). If that's
101616:     // a problem then rethink Widgets interface.
101616:     nsCOMPtr<nsIDOMXULMenuListElement> menuListElm =
101616:       do_QueryInterface(mContent->GetParent());
101616:     if (menuListElm) {
101616:       nsCOMPtr<nsIDOMNode> inputElm;
101616:       menuListElm->GetInputField(getter_AddRefs(inputElm));
101616:       if (inputElm) {
101616:         nsCOMPtr<nsINode> inputNode = do_QueryInterface(inputElm);
101616:         if (inputNode) {
101616:           Accessible* input = 
101616:             mDoc->GetAccessible(inputNode);
101616:           return input ? input->ContainerWidget() : nsnull;
101616:         }
101616:       }
101616:     }
101616:   }
101616:   return nsnull;
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeAccessible: public implementation
101616: 
101616: Accessible*
101616: XULTreeAccessible::GetTreeItemAccessible(PRInt32 aRow)
101616: {
101616:   if (aRow < 0 || IsDefunct() || !mTreeView)
101616:     return nsnull;
101616: 
101616:   PRInt32 rowCount = 0;
101616:   nsresult rv = mTreeView->GetRowCount(&rowCount);
101616:   if (NS_FAILED(rv) || aRow >= rowCount)
101616:     return nsnull;
101616: 
101616:   void *key = reinterpret_cast<void*>(aRow);
101616:   Accessible* cachedTreeItem = mAccessibleCache.GetWeak(key);
101616:   if (cachedTreeItem)
101616:     return cachedTreeItem;
101616: 
101616:   nsRefPtr<Accessible> treeItem = CreateTreeItemAccessible(aRow);
101616:   if (treeItem) {
101616:     mAccessibleCache.Put(key, treeItem);
101616:     if (Document()->BindToDocument(treeItem, nsnull))
101616:       return treeItem;
101616: 
101616:     mAccessibleCache.Remove(key);
101616:   }
101616: 
101616:   return nsnull;
101616: }
101616: 
101616: void
101616: XULTreeAccessible::InvalidateCache(PRInt32 aRow, PRInt32 aCount)
101616: {
101616:   if (IsDefunct())
101616:     return;
101616: 
102097:   if (!mTreeView) {
102097:     ClearCache(mAccessibleCache);
102097:     return;
102097:   }
102097: 
101616:   // Do not invalidate the cache if rows have been inserted.
101616:   if (aCount > 0)
101616:     return;
101616: 
101616:   DocAccessible* document = Document();
101616: 
101616:   // Fire destroy event for removed tree items and delete them from caches.
101616:   for (PRInt32 rowIdx = aRow; rowIdx < aRow - aCount; rowIdx++) {
101616: 
101616:     void* key = reinterpret_cast<void*>(rowIdx);
101616:     Accessible* treeItem = mAccessibleCache.GetWeak(key);
101616: 
101616:     if (treeItem) {
101616:       nsRefPtr<AccEvent> event =
101616:         new AccEvent(nsIAccessibleEvent::EVENT_HIDE, treeItem);
101616:       nsEventShell::FireEvent(event);
101616: 
101616:       // Unbind from document, shutdown and remove from tree cache.
101616:       document->UnbindFromDocument(treeItem);
101616:       mAccessibleCache.Remove(key);
101616:     }
101616:   }
101616: 
101616:   // We dealt with removed tree items already however we may keep tree items
101616:   // having row indexes greater than row count. We should remove these dead tree
101616:   // items silently from caches.
101616:   PRInt32 newRowCount = 0;
101616:   nsresult rv = mTreeView->GetRowCount(&newRowCount);
101616:   if (NS_FAILED(rv))
101616:     return;
101616: 
101616:   PRInt32 oldRowCount = newRowCount - aCount;
101616: 
101616:   for (PRInt32 rowIdx = newRowCount; rowIdx < oldRowCount; ++rowIdx) {
101616: 
101616:     void *key = reinterpret_cast<void*>(rowIdx);
101616:     Accessible* treeItem = mAccessibleCache.GetWeak(key);
101616: 
101616:     if (treeItem) {
101616:       // Unbind from document, shutdown and remove from tree cache.
101616:       document->UnbindFromDocument(treeItem);
101616:       mAccessibleCache.Remove(key);
101616:     }
101616:   }
101616: }
101616: 
101616: void
101616: XULTreeAccessible::TreeViewInvalidated(PRInt32 aStartRow, PRInt32 aEndRow,
101616:                                        PRInt32 aStartCol, PRInt32 aEndCol)
101616: {
101616:   if (IsDefunct())
101616:     return;
101616: 
102179:   if (!mTreeView) {
102179:     ClearCache(mAccessibleCache);
102179:     return;
102179:   }
102179: 
101616:   PRInt32 endRow = aEndRow;
101616: 
101616:   nsresult rv;
101616:   if (endRow == -1) {
101616:     PRInt32 rowCount = 0;
101616:     rv = mTreeView->GetRowCount(&rowCount);
101616:     if (NS_FAILED(rv))
101616:       return;
101616: 
101616:     endRow = rowCount - 1;
101616:   }
101616: 
101616:   nsCOMPtr<nsITreeColumns> treeColumns;
101616:   mTree->GetColumns(getter_AddRefs(treeColumns));
101616:   if (!treeColumns)
101616:     return;
101616: 
101616:   PRInt32 endCol = aEndCol;
101616: 
101616:   if (endCol == -1) {
101616:     PRInt32 colCount = 0;
101616:     rv = treeColumns->GetCount(&colCount);
101616:     if (NS_FAILED(rv))
101616:       return;
101616: 
101616:     endCol = colCount - 1;
101616:   }
101616: 
101616:   for (PRInt32 rowIdx = aStartRow; rowIdx <= endRow; ++rowIdx) {
101616: 
101616:     void *key = reinterpret_cast<void*>(rowIdx);
101616:     Accessible* accessible = mAccessibleCache.GetWeak(key);
101616: 
101616:     if (accessible) {
101616:       nsRefPtr<XULTreeItemAccessibleBase> treeitemAcc = do_QueryObject(accessible);
101616:       NS_ASSERTION(treeitemAcc, "Wrong accessible at the given key!");
101616: 
101616:       treeitemAcc->RowInvalidated(aStartCol, endCol);
101616:     }
101616:   }
101616: }
101616: 
101616: void
101616: XULTreeAccessible::TreeViewChanged(nsITreeView* aView)
101616: {
101616:   if (IsDefunct())
101616:     return;
101616: 
101616:   // Fire reorder event on tree accessible on accessible tree (do not fire
101616:   // show/hide events on tree items because it can be expensive to fire them for
101616:   // each tree item.
101616:   nsRefPtr<AccEvent> reorderEvent =
101616:     new AccEvent(nsIAccessibleEvent::EVENT_REORDER, this, eAutoDetect,
101616:                  AccEvent::eCoalesceFromSameSubtree);
101616:   if (reorderEvent)
101616:     Document()->FireDelayedAccessibleEvent(reorderEvent);
101616: 
101616:   // Clear cache.
101616:   ClearCache(mAccessibleCache);
101616:   mTreeView = aView;
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeAccessible: protected implementation
101616: 
101616: already_AddRefed<Accessible>
101616: XULTreeAccessible::CreateTreeItemAccessible(PRInt32 aRow)
101616: {
101616:   nsRefPtr<Accessible> accessible =
101616:     new XULTreeItemAccessible(mContent, mDoc, this, mTree, mTreeView, aRow);
101616: 
101616:   return accessible.forget();
101616: }
101616:                              
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeItemAccessibleBase
101616: ////////////////////////////////////////////////////////////////////////////////
101616: 
101616: XULTreeItemAccessibleBase::
101616:   XULTreeItemAccessibleBase(nsIContent* aContent, DocAccessible* aDoc,
101616:                             Accessible* aParent, nsITreeBoxObject* aTree,
101616:                             nsITreeView* aTreeView, PRInt32 aRow) :
101616:   AccessibleWrap(aContent, aDoc),
101616:   mTree(aTree), mTreeView(aTreeView), mRow(aRow)
101616: {
101616:   mParent = aParent;
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeItemAccessibleBase: nsISupports implementation
101616: 
101616: NS_IMPL_CYCLE_COLLECTION_CLASS(XULTreeItemAccessibleBase)
101616: 
101616: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(XULTreeItemAccessibleBase,
101616:                                                   Accessible)
101616:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mTree)
101616: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
101616: 
101616: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(XULTreeItemAccessibleBase,
101616:                                                 Accessible)
101616:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mTree)
101616: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
101616: 
101616: NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(XULTreeItemAccessibleBase)
101616:   NS_INTERFACE_TABLE_INHERITED1(XULTreeItemAccessibleBase,
101616:                                 XULTreeItemAccessibleBase)
101616: NS_INTERFACE_TABLE_TAIL_INHERITING(Accessible)
101616: NS_IMPL_ADDREF_INHERITED(XULTreeItemAccessibleBase, Accessible)
101616: NS_IMPL_RELEASE_INHERITED(XULTreeItemAccessibleBase, Accessible)
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeItemAccessibleBase: nsIAccessible implementation
101616: 
101616: Accessible*
101616: XULTreeItemAccessibleBase::FocusedChild()
101616: {
101616:   return FocusMgr()->FocusedAccessible() == this ? this : nsnull;
101616: }
101616: 
101616: NS_IMETHODIMP
101616: XULTreeItemAccessibleBase::GetBounds(PRInt32* aX, PRInt32* aY,
101616:                                      PRInt32* aWidth, PRInt32* aHeight)
101616: {
101616:   NS_ENSURE_ARG_POINTER(aX);
101616:   *aX = 0;
101616:   NS_ENSURE_ARG_POINTER(aY);
101616:   *aY = 0;
101616:   NS_ENSURE_ARG_POINTER(aWidth);
101616:   *aWidth = 0;
101616:   NS_ENSURE_ARG_POINTER(aHeight);
101616:   *aHeight = 0;
101616: 
101616:   if (IsDefunct())
101616:     return NS_ERROR_FAILURE;
101616: 
101616:   // Get x coordinate and width from treechildren element, get y coordinate and
101616:   // height from tree cell.
101616: 
101616:   nsCOMPtr<nsIBoxObject> boxObj = nsCoreUtils::GetTreeBodyBoxObject(mTree);
101616:   NS_ENSURE_STATE(boxObj);
101616: 
101616:   nsCOMPtr<nsITreeColumn> column = nsCoreUtils::GetFirstSensibleColumn(mTree);
101616: 
101616:   PRInt32 x = 0, y = 0, width = 0, height = 0;
101616:   nsresult rv = mTree->GetCoordsForCellItem(mRow, column, EmptyCString(),
101616:                                             &x, &y, &width, &height);
101616:   NS_ENSURE_SUCCESS(rv, rv);
101616: 
101616:   boxObj->GetWidth(&width);
101616: 
101616:   PRInt32 tcX = 0, tcY = 0;
101616:   boxObj->GetScreenX(&tcX);
101616:   boxObj->GetScreenY(&tcY);
101616: 
101616:   x = tcX;
101616:   y += tcY;
101616: 
101616:   nsPresContext* presContext = mDoc->PresContext();
101616:   *aX = presContext->CSSPixelsToDevPixels(x);
101616:   *aY = presContext->CSSPixelsToDevPixels(y);
101616:   *aWidth = presContext->CSSPixelsToDevPixels(width);
101616:   *aHeight = presContext->CSSPixelsToDevPixels(height);
101616: 
101616:   return NS_OK;
101616: }
101616: 
101616: NS_IMETHODIMP
101616: XULTreeItemAccessibleBase::SetSelected(bool aSelect)
101616: {
101616:   if (IsDefunct() || !mTreeView)
101616:     return NS_ERROR_FAILURE;
101616: 
101616:   nsCOMPtr<nsITreeSelection> selection;
101616:   mTreeView->GetSelection(getter_AddRefs(selection));
101616:   if (selection) {
101616:     bool isSelected;
101616:     selection->IsSelected(mRow, &isSelected);
101616:     if (isSelected != aSelect)
101616:       selection->ToggleSelect(mRow);
101616:   }
101616: 
101616:   return NS_OK;
101616: }
101616: 
101616: NS_IMETHODIMP
101616: XULTreeItemAccessibleBase::TakeFocus()
101616: {
101616:   if (IsDefunct() || !mTreeView)
101616:     return NS_ERROR_FAILURE;
101616: 
101616:   nsCOMPtr<nsITreeSelection> selection;
101616:   mTreeView->GetSelection(getter_AddRefs(selection));
101616:   if (selection)
101616:     selection->SetCurrentIndex(mRow);
101616: 
101616:   // focus event will be fired here
101616:   return Accessible::TakeFocus();
101616: }
101616: 
101616: Relation
101616: XULTreeItemAccessibleBase::RelationByType(PRUint32 aType)
101616: {
101616:   if (!mTreeView)
101616:     return Relation();
101616: 
101616:   if (aType != nsIAccessibleRelation::RELATION_NODE_CHILD_OF)
101616:     return Relation();
101616: 
101616:   PRInt32 parentIndex = -1;
101616:   if (!NS_SUCCEEDED(mTreeView->GetParentIndex(mRow, &parentIndex)))
101616:     return Relation();
101616: 
101616:   if (parentIndex == -1)
101616:     return Relation(mParent);
101616: 
101616:   XULTreeAccessible* treeAcc = mParent->AsXULTree();
101616:   return Relation(treeAcc->GetTreeItemAccessible(parentIndex));
101616: }
101616: 
101616: PRUint8
101616: XULTreeItemAccessibleBase::ActionCount()
101616: {
101616:   // "activate" action is available for all treeitems, "expand/collapse" action
101616:   // is avaible for treeitem which is container.
101616:   return IsExpandable() ? 2 : 1;
101616: }
101616: 
101616: NS_IMETHODIMP
101616: XULTreeItemAccessibleBase::GetActionName(PRUint8 aIndex, nsAString& aName)
101616: {
101616:   if (IsDefunct())
101616:     return NS_ERROR_FAILURE;
101616: 
101616:   if (aIndex == eAction_Click) {
101616:     aName.AssignLiteral("activate");
101616:     return NS_OK;
101616:   }
101616: 
101616:   if (aIndex == eAction_Expand && IsExpandable()) {
101616:     bool isContainerOpen;
101616:     mTreeView->IsContainerOpen(mRow, &isContainerOpen);
101616:     if (isContainerOpen)
101616:       aName.AssignLiteral("collapse");
101616:     else
101616:       aName.AssignLiteral("expand");
101616: 
101616:     return NS_OK;
101616:   }
101616: 
101616:   return NS_ERROR_INVALID_ARG;
101616: }
101616: 
101616: NS_IMETHODIMP
101616: XULTreeItemAccessibleBase::DoAction(PRUint8 aIndex)
101616: {
101616:   if (IsDefunct())
101616:     return NS_ERROR_FAILURE;
101616: 
101616:   if (aIndex != eAction_Click &&
101616:       (aIndex != eAction_Expand || !IsExpandable()))
101616:     return NS_ERROR_INVALID_ARG;
101616: 
101616:   DoCommand(nsnull, aIndex);
101616:   return NS_OK;
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeItemAccessibleBase: nsAccessNode implementation
101616: 
101616: void
101616: XULTreeItemAccessibleBase::Shutdown()
101616: {
101616:   mTree = nsnull;
101616:   mTreeView = nsnull;
101616:   mRow = -1;
101616: 
101616:   AccessibleWrap::Shutdown();
101616: }
101616: 
101616: bool
101616: XULTreeItemAccessibleBase::IsPrimaryForNode() const
101616: {
101616:   return false;
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeItemAccessibleBase: Accessible public methods
101616: 
101616: // nsIAccessible::groupPosition
101616: GroupPos
101616: XULTreeItemAccessibleBase::GroupPosition()
101616: {
101616:   GroupPos groupPos;
101616: 
101616:   PRInt32 level;
101616:   nsresult rv = mTreeView->GetLevel(mRow, &level);
101616:   NS_ENSURE_SUCCESS(rv, groupPos);
101616: 
101616:   PRInt32 topCount = 1;
101616:   for (PRInt32 index = mRow - 1; index >= 0; index--) {
101616:     PRInt32 lvl = -1;
101616:     if (NS_SUCCEEDED(mTreeView->GetLevel(index, &lvl))) {
101616:       if (lvl < level)
101616:         break;
101616: 
101616:       if (lvl == level)
101616:         topCount++;
101616:     }
101616:   }
101616: 
101616:   PRInt32 rowCount = 0;
101616:   rv = mTreeView->GetRowCount(&rowCount);
101616:   NS_ENSURE_SUCCESS(rv, groupPos);
101616: 
101616:   PRInt32 bottomCount = 0;
101616:   for (PRInt32 index = mRow + 1; index < rowCount; index++) {
101616:     PRInt32 lvl = -1;
101616:     if (NS_SUCCEEDED(mTreeView->GetLevel(index, &lvl))) {
101616:       if (lvl < level)
101616:         break;
101616: 
101616:       if (lvl == level)
101616:         bottomCount++;
101616:     }
101616:   }
101616: 
101616:   groupPos.level = level + 1;
101616:   groupPos.setSize = topCount + bottomCount;
101616:   groupPos.posInSet = topCount;
101616: 
101616:   return groupPos;
101616: }
101616: 
101616: PRUint64
101616: XULTreeItemAccessibleBase::NativeState()
101616: {
101616:   if (!mTreeView)
101616:     return states::DEFUNCT;
101616: 
101616:   // focusable and selectable states
101616:   PRUint64 state = NativeInteractiveState();
101616: 
101616:   // expanded/collapsed state
101616:   if (IsExpandable()) {
101616:     bool isContainerOpen;
101616:     mTreeView->IsContainerOpen(mRow, &isContainerOpen);
101616:     state |= isContainerOpen ? states::EXPANDED : states::COLLAPSED;
101616:   }
101616: 
101616:   // selected state
101616:   nsCOMPtr<nsITreeSelection> selection;
101616:   mTreeView->GetSelection(getter_AddRefs(selection));
101616:   if (selection) {
101616:     bool isSelected;
101616:     selection->IsSelected(mRow, &isSelected);
101616:     if (isSelected)
101616:       state |= states::SELECTED;
101616:   }
101616: 
101616:   // focused state
101616:   if (FocusMgr()->IsFocused(this))
101616:     state |= states::FOCUSED;
101616: 
101616:   // invisible state
101616:   PRInt32 firstVisibleRow, lastVisibleRow;
101616:   mTree->GetFirstVisibleRow(&firstVisibleRow);
101616:   mTree->GetLastVisibleRow(&lastVisibleRow);
101616:   if (mRow < firstVisibleRow || mRow > lastVisibleRow)
101616:     state |= states::INVISIBLE;
101616: 
101616:   return state;
101616: }
101616: 
101616: PRUint64
101616: XULTreeItemAccessibleBase::NativeInteractiveState() const
101616: {
101616:   return states::FOCUSABLE | states::SELECTABLE;
101616: }
101616: 
101616: PRInt32
101616: XULTreeItemAccessibleBase::IndexInParent() const
101616: {
101616:   return mParent ? mParent->ContentChildCount() + mRow : -1;
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeItemAccessibleBase: Widgets
101616: 
101616: Accessible*
101616: XULTreeItemAccessibleBase::ContainerWidget() const
101616: {
101616:   return mParent;
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeItemAccessibleBase: Accessible protected methods
101616: 
101616: void
101616: XULTreeItemAccessibleBase::DispatchClickEvent(nsIContent* aContent,
101616:                                               PRUint32 aActionIndex)
101616: {
101616:   if (IsDefunct())
101616:     return;
101616: 
101616:   nsCOMPtr<nsITreeColumns> columns;
101616:   mTree->GetColumns(getter_AddRefs(columns));
101616:   if (!columns)
101616:     return;
101616: 
101616:   // Get column and pseudo element.
101616:   nsCOMPtr<nsITreeColumn> column;
101616:   nsCAutoString pseudoElm;
101616: 
101616:   if (aActionIndex == eAction_Click) {
101616:     // Key column is visible and clickable.
101616:     columns->GetKeyColumn(getter_AddRefs(column));
101616:   } else {
101616:     // Primary column contains a twisty we should click on.
101616:     columns->GetPrimaryColumn(getter_AddRefs(column));
101616:     pseudoElm = NS_LITERAL_CSTRING("twisty");
101616:   }
101616: 
101616:   if (column)
101616:     nsCoreUtils::DispatchClickEvent(mTree, mRow, column, pseudoElm);
101616: }
101616: 
101616: Accessible*
101616: XULTreeItemAccessibleBase::GetSiblingAtOffset(PRInt32 aOffset,
101616:                                               nsresult* aError) const
101616: {
101616:   if (aError)
101616:     *aError = NS_OK; // fail peacefully
101616: 
101616:   return mParent->GetChildAt(IndexInParent() + aOffset);
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeItemAccessibleBase: protected implementation
101616: 
101616: bool
101616: XULTreeItemAccessibleBase::IsExpandable()
101616: {
101616:   if (!mTreeView)
101616:     return false;
101616: 
101616:   bool isContainer = false;
101616:   mTreeView->IsContainer(mRow, &isContainer);
101616:   if (isContainer) {
101616:     bool isEmpty = false;
101616:     mTreeView->IsContainerEmpty(mRow, &isEmpty);
101616:     if (!isEmpty) {
101616:       nsCOMPtr<nsITreeColumns> columns;
101616:       mTree->GetColumns(getter_AddRefs(columns));
101616:       nsCOMPtr<nsITreeColumn> primaryColumn;
101616:       if (columns) {
101616:         columns->GetPrimaryColumn(getter_AddRefs(primaryColumn));
101616:         if (primaryColumn &&
101616:             !nsCoreUtils::IsColumnHidden(primaryColumn))
101616:           return true;
101616:       }
101616:     }
101616:   }
101616: 
101616:   return false;
101616: }
101616: 
101616: void
101616: XULTreeItemAccessibleBase::GetCellName(nsITreeColumn* aColumn, nsAString& aName)
101616: {
101616:   if (!mTreeView)
101616:     return;
101616: 
101616:   mTreeView->GetCellText(mRow, aColumn, aName);
101616: 
101616:   // If there is still no name try the cell value:
101616:   // This is for graphical cells. We need tree/table view implementors to
101616:   // implement FooView::GetCellValue to return a meaningful string for cases
101616:   // where there is something shown in the cell (non-text) such as a star icon;
101616:   // in which case GetCellValue for that cell would return "starred" or
101616:   // "flagged" for example.
101616:   if (aName.IsEmpty())
101616:     mTreeView->GetCellValue(mRow, aColumn, aName);
101616: }
101616: 
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeItemAccessible
101616: ////////////////////////////////////////////////////////////////////////////////
101616: 
101616: XULTreeItemAccessible::
101616:   XULTreeItemAccessible(nsIContent* aContent, DocAccessible* aDoc,
101616:                         Accessible* aParent, nsITreeBoxObject* aTree,
101616:                         nsITreeView* aTreeView, PRInt32 aRow) :
101616:   XULTreeItemAccessibleBase(aContent, aDoc, aParent, aTree, aTreeView, aRow)
101616: {
101616:   mColumn = nsCoreUtils::GetFirstSensibleColumn(mTree);
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeItemAccessible: nsISupports implementation
101616: 
101616: NS_IMPL_CYCLE_COLLECTION_CLASS(XULTreeItemAccessible)
101616: 
101616: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(XULTreeItemAccessible,
101616:                                                   XULTreeItemAccessibleBase)
101616:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mColumn)
101616: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
101616: 
101616: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(XULTreeItemAccessible,
101616:                                                 XULTreeItemAccessibleBase)
101616:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mColumn)
101616: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
101616: 
101616: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(XULTreeItemAccessible)
101616: NS_INTERFACE_MAP_END_INHERITING(XULTreeItemAccessibleBase)
101616: NS_IMPL_ADDREF_INHERITED(XULTreeItemAccessible, XULTreeItemAccessibleBase)
101616: NS_IMPL_RELEASE_INHERITED(XULTreeItemAccessible, XULTreeItemAccessibleBase)
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeItemAccessible: nsIAccessible implementation
101616: 
101616: ENameValueFlag
101616: XULTreeItemAccessible::Name(nsString& aName)
101616: {
101616:   aName.Truncate();
101616: 
101616:   GetCellName(mColumn, aName);
101616:   return eNameOK;
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeItemAccessible: nsAccessNode implementation
101616: 
101616: bool
101616: XULTreeItemAccessible::Init()
101616: {
101616:   if (!XULTreeItemAccessibleBase::Init())
101616:     return false;
101616: 
101616:   Name(mCachedName);
101616:   return true;
101616: }
101616: 
101616: void
101616: XULTreeItemAccessible::Shutdown()
101616: {
101616:   mColumn = nsnull;
101616:   XULTreeItemAccessibleBase::Shutdown();
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeItemAccessible: Accessible implementation
101616: 
101616: role
101616: XULTreeItemAccessible::NativeRole()
101616: {
101616:   nsCOMPtr<nsITreeColumns> columns;
101616:   mTree->GetColumns(getter_AddRefs(columns));
101616:   if (!columns) {
101616:     NS_ERROR("No tree columns object in the tree!");
101616:     return roles::NOTHING;
101616:   }
101616: 
101616:   nsCOMPtr<nsITreeColumn> primaryColumn;
101616:   columns->GetPrimaryColumn(getter_AddRefs(primaryColumn));
101616: 
101616:   return primaryColumn ? roles::OUTLINEITEM : roles::LISTITEM;
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeItemAccessible: XULTreeItemAccessibleBase implementation
101616: 
101616: void
101616: XULTreeItemAccessible::RowInvalidated(PRInt32 aStartColIdx, PRInt32 aEndColIdx)
101616: {
101616:   nsAutoString name;
101616:   Name(name);
101616: 
101616:   if (name != mCachedName) {
101616:     nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_NAME_CHANGE, this);
101616:     mCachedName = name;
101616:   }
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // XULTreeItemAccessible: Accessible protected implementation
101616: 
101616: void
101616: XULTreeItemAccessible::CacheChildren()
101616: {
101616: }
101616: 
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: //  XULTreeColumAccessible
101616: ////////////////////////////////////////////////////////////////////////////////
101616: 
101616: XULTreeColumAccessible::
101616:   XULTreeColumAccessible(nsIContent* aContent, DocAccessible* aDoc) :
101616:   XULColumAccessible(aContent, aDoc)
101616: {
101616: }
101616: 
101616: Accessible*
101616: XULTreeColumAccessible::GetSiblingAtOffset(PRInt32 aOffset,
101616:                                            nsresult* aError) const
101616: {
101616:   if (aOffset < 0)
101616:     return XULColumAccessible::GetSiblingAtOffset(aOffset, aError);
101616: 
101616:   if (aError)
101616:     *aError =  NS_OK; // fail peacefully
101616: 
101616:   nsCOMPtr<nsITreeBoxObject> tree = nsCoreUtils::GetTreeBoxObject(mContent);
101616:   if (tree) {
101616:     nsCOMPtr<nsITreeView> treeView;
101616:     tree->GetView(getter_AddRefs(treeView));
101616:     if (treeView) {
101616:       PRInt32 rowCount = 0;
101616:       treeView->GetRowCount(&rowCount);
101616:       if (rowCount > 0 && aOffset <= rowCount) {
101616:         XULTreeAccessible* treeAcc = Parent()->AsXULTree();
101616: 
101616:         if (treeAcc)
101616:           return treeAcc->GetTreeItemAccessible(aOffset - 1);
101616:       }
101616:     }
101616:   }
101616: 
101616:   return nsnull;
101616: }
101616: 
