131289: /* This Source Code Form is subject to the terms of the Mozilla Public
131289:  * License, v. 2.0. If a copy of the MPL was not distributed with this
131289:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
131289: "use strict";
131289: 
136693: const { PageMod } = require("sdk/page-mod");
135382: const testPageMod = require("./pagemod-test-helpers").testPageMod;
131289: const { Loader } = require('sdk/test/loader');
131289: const tabs = require("sdk/tabs");
131289: const timer = require("sdk/timers");
164700: const { Cc, Ci, Cu } = require("chrome");
182866: const { open, getFrames, getMostRecentBrowserWindow } = require('sdk/window/utils');
182866: const windowUtils = require('sdk/deprecated/window-utils');
136693: const { getTabContentWindow, getActiveTab, setTabURL, openTab, closeTab } = require('sdk/tabs/utils');
136693: const xulApp = require("sdk/system/xul-app");
169252: const { isPrivateBrowsingSupported } = require('sdk/self');
136693: const { isPrivate } = require('sdk/private-browsing');
137856: const { openWebpage } = require('./private-browsing/helper');
137856: const { isTabPBSupported, isWindowPBSupported, isGlobalPBSupported } = require('sdk/private-browsing/utils');
136693: const promise = require("sdk/core/promise");
137856: const { pb } = require('./private-browsing/helper');
153617: const { URL } = require("sdk/url");
169252: 
164700: const { waitUntil } = require("sdk/test/utils");
169252: const data = require("./fixtures");
169252: 
169252: const testPageURI = data.url("test.html");
131289: 
164700: // The following adds Debugger constructor to the global namespace.
164700: const { addDebuggerToGlobal } =
164700:   Cu.import('resource://gre/modules/jsdebugger.jsm', {});
164700: addDebuggerToGlobal(this);
131289: 
131289: function Isolate(worker) {
131289:   return "(" + worker + ")()";
131289: }
131289: 
131289: /* Tests for the PageMod APIs */
131289: 
164700: exports.testPageMod1 = function(assert, done) {
164700:   let mods = testPageMod(assert, done, "about:", [{
131289:       include: /about:/,
131289:       contentScriptWhen: 'end',
131289:       contentScript: 'new ' + function WorkerScope() {
131289:         window.document.body.setAttribute("JEP-107", "worked");
131289:       },
131289:       onAttach: function() {
164700:         assert.equal(this, mods[0], "The 'this' object is the page mod.");
131289:       }
131289:     }],
131289:     function(win, done) {
164700:       assert.equal(
131289:         win.document.body.getAttribute("JEP-107"),
131289:         "worked",
131289:         "PageMod.onReady test"
131289:       );
131289:       done();
131289:     }
131289:   );
131289: };
131289: 
164700: exports.testPageMod2 = function(assert, done) {
164700:   testPageMod(assert, done, "about:", [{
131289:       include: "about:*",
131289:       contentScript: [
131289:         'new ' + function contentScript() {
131289:           window.AUQLUE = function() { return 42; }
131289:           try {
131289:             window.AUQLUE()
131289:           }
131289:           catch(e) {
131289:             throw new Error("PageMod scripts executed in order");
131289:           }
131289:           document.documentElement.setAttribute("first", "true");
131289:         },
131289:         'new ' + function contentScript() {
131289:           document.documentElement.setAttribute("second", "true");
131289:         }
131289:       ]
131289:     }], function(win, done) {
164700:       assert.equal(win.document.documentElement.getAttribute("first"),
131289:                        "true",
131289:                        "PageMod test #2: first script has run");
164700:       assert.equal(win.document.documentElement.getAttribute("second"),
131289:                        "true",
131289:                        "PageMod test #2: second script has run");
164700:       assert.equal("AUQLUE" in win, false,
131289:                        "PageMod test #2: scripts get a wrapped window");
131289:       done();
131289:     });
131289: };
131289: 
164700: exports.testPageModIncludes = function(assert, done) {
131289:   var asserts = [];
131289:   function createPageModTest(include, expectedMatch) {
131289:     // Create an 'onload' test function...
131289:     asserts.push(function(test, win) {
131289:       var matches = include in win.localStorage;
164700:       assert.ok(expectedMatch ? matches : !matches,
131289:                   "'" + include + "' match test, expected: " + expectedMatch);
131289:     });
131289:     // ...and corresponding PageMod options
131289:     return {
131289:       include: include,
131289:       contentScript: 'new ' + function() {
131289:         self.on("message", function(msg) {
131289:           window.localStorage[msg] = true;
131289:         });
131289:       },
131289:       // The testPageMod callback with test assertions is called on 'end',
131289:       // and we want this page mod to be attached before it gets called,
131289:       // so we attach it on 'start'.
131289:       contentScriptWhen: 'start',
131289:       onAttach: function(worker) {
131289:         worker.postMessage(this.include[0]);
131289:       }
131289:     };
131289:   }
131289: 
164700:   testPageMod(assert, done, testPageURI, [
131289:       createPageModTest("*", false),
131289:       createPageModTest("*.google.com", false),
153617:       createPageModTest("resource:*", true),
153617:       createPageModTest("resource:", false),
153617:       createPageModTest(testPageURI, true)
131289:     ],
131289:     function (win, done) {
164700:       waitUntil(function () win.localStorage[testPageURI],
153617:                      testPageURI + " page-mod to be executed")
131289:           .then(function () {
131289:             asserts.forEach(function(fn) {
164700:               fn(assert, win);
131289:             });
131289:             done();
131289:           });
131289:     }
131289:     );
131289: };
131289: 
164700: exports.testPageModErrorHandling = function(assert) {
164700:   assert.throws(function() {
136693:       new PageMod();
131289:     },
164700:     /The `include` option must always contain atleast one rule/,
131289:     "PageMod() throws when 'include' option is not specified.");
131289: };
131289: 
131289: /* Tests for internal functions. */
164700: exports.testCommunication1 = function(assert, done) {
131289:   let workerDone = false,
131289:       callbackDone = null;
131289: 
164700:   testPageMod(assert, done, "about:", [{
131289:       include: "about:*",
131289:       contentScriptWhen: 'end',
131289:       contentScript: 'new ' + function WorkerScope() {
131289:         self.on('message', function(msg) {
131289:           document.body.setAttribute('JEP-107', 'worked');
131289:           self.postMessage(document.body.getAttribute('JEP-107'));
131289:         })
131289:       },
131289:       onAttach: function(worker) {
131289:         worker.on('error', function(e) {
164700:           assert.fail('Errors where reported');
131289:         });
131289:         worker.on('message', function(value) {
164700:           assert.equal(
131289:             "worked",
131289:             value,
131289:             "test comunication"
131289:           );
131289:           workerDone = true;
131289:           if (callbackDone)
131289:             callbackDone();
131289:         });
131289:         worker.postMessage('do it!')
131289:       }
131289:     }],
131289:     function(win, done) {
131289:       (callbackDone = function() {
131289:         if (workerDone) {
164700:           assert.equal(
131289:             'worked',
131289:             win.document.body.getAttribute('JEP-107'),
131289:             'attribute should be modified'
131289:           );
131289:           done();
131289:         }
131289:       })();
131289:     }
131289:   );
131289: };
131289: 
164700: exports.testCommunication2 = function(assert, done) {
131289:   let callbackDone = null,
131289:       window;
131289: 
164700:   testPageMod(assert, done, "about:license", [{
131289:       include: "about:*",
131289:       contentScriptWhen: 'start',
131289:       contentScript: 'new ' + function WorkerScope() {
131289:         document.documentElement.setAttribute('AUQLUE', 42);
131289:         window.addEventListener('load', function listener() {
131289:           self.postMessage('onload');
131289:         }, false);
131289:         self.on("message", function() {
131289:           self.postMessage(document.documentElement.getAttribute("test"))
131289:         });
131289:       },
131289:       onAttach: function(worker) {
131289:         worker.on('error', function(e) {
164700:           assert.fail('Errors where reported');
131289:         });
131289:         worker.on('message', function(msg) {
131289:           if ('onload' == msg) {
164700:             assert.equal(
131289:               '42',
131289:               window.document.documentElement.getAttribute('AUQLUE'),
131289:               'PageMod scripts executed in order'
131289:             );
131289:             window.document.documentElement.setAttribute('test', 'changes in window');
131289:             worker.postMessage('get window.test')
131289:           } else {
164700:             assert.equal(
131289:               'changes in window',
131289:               msg,
131289:               'PageMod test #2: second script has run'
131289:             )
131289:             callbackDone();
131289:           }
131289:         });
131289:       }
131289:     }],
131289:     function(win, done) {
131289:       window = win;
131289:       callbackDone = done;
131289:     }
131289:   );
131289: };
131289: 
164700: exports.testEventEmitter = function(assert, done) {
131289:   let workerDone = false,
131289:       callbackDone = null;
131289: 
164700:   testPageMod(assert, done, "about:", [{
131289:       include: "about:*",
131289:       contentScript: 'new ' + function WorkerScope() {
131289:         self.port.on('addon-to-content', function(data) {
131289:           self.port.emit('content-to-addon', data);
131289:         });
131289:       },
131289:       onAttach: function(worker) {
131289:         worker.on('error', function(e) {
164700:           assert.fail('Errors were reported : '+e);
131289:         });
131289:         worker.port.on('content-to-addon', function(value) {
164700:           assert.equal(
131289:             "worked",
131289:             value,
131289:             "EventEmitter API works!"
131289:           );
131289:           if (callbackDone)
131289:             callbackDone();
131289:           else
131289:             workerDone = true;
131289:         });
131289:         worker.port.emit('addon-to-content', 'worked');
131289:       }
131289:     }],
131289:     function(win, done) {
131289:       if (workerDone)
131289:         done();
131289:       else
131289:         callbackDone = done;
131289:     }
131289:   );
131289: };
131289: 
131289: // Execute two concurrent page mods on same document to ensure that their
131289: // JS contexts are different
164700: exports.testMixedContext = function(assert, done) {
131289:   let doneCallback = null;
131289:   let messages = 0;
131289:   let modObject = {
131289:     include: "data:text/html;charset=utf-8,",
131289:     contentScript: 'new ' + function WorkerScope() {
131289:       // Both scripts will execute this,
131289:       // context is shared if one script see the other one modification.
131289:       let isContextShared = "sharedAttribute" in document;
131289:       self.postMessage(isContextShared);
131289:       document.sharedAttribute = true;
131289:     },
131289:     onAttach: function(w) {
131289:       w.on("message", function (isContextShared) {
131289:         if (isContextShared) {
164700:           assert.fail("Page mod contexts are mixed.");
131289:           doneCallback();
131289:         }
131289:         else if (++messages == 2) {
164700:           assert.pass("Page mod contexts are different.");
131289:           doneCallback();
131289:         }
131289:       });
131289:     }
131289:   };
164700:   testPageMod(assert, done, "data:text/html;charset=utf-8,", [modObject, modObject],
131289:     function(win, done) {
131289:       doneCallback = done;
131289:     }
131289:   );
131289: };
131289: 
164700: exports.testHistory = function(assert, done) {
131289:   // We need a valid url in order to have a working History API.
131289:   // (i.e do not work on data: or about: pages)
131289:   // Test bug 679054.
169252:   let url = data.url("test-page-mod.html");
131289:   let callbackDone = null;
164700:   testPageMod(assert, done, url, [{
131289:       include: url,
131289:       contentScriptWhen: 'end',
131289:       contentScript: 'new ' + function WorkerScope() {
131289:         history.pushState({}, "", "#");
131289:         history.replaceState({foo: "bar"}, "", "#");
131289:         self.postMessage(history.state);
131289:       },
131289:       onAttach: function(worker) {
131289:         worker.on('message', function (data) {
164700:           assert.equal(JSON.stringify(data), JSON.stringify({foo: "bar"}),
131289:                            "History API works!");
131289:           callbackDone();
131289:         });
131289:       }
131289:     }],
131289:     function(win, done) {
131289:       callbackDone = done;
131289:     }
131289:   );
131289: };
131289: 
164700: exports.testRelatedTab = function(assert, done) {
131289:   let tab;
131289:   let pageMod = new PageMod({
131289:     include: "about:*",
131289:     onAttach: function(worker) {
164700:       assert.ok(!!worker.tab, "Worker.tab exists");
164700:       assert.equal(tab, worker.tab, "Worker.tab is valid");
131289:       pageMod.destroy();
164700:       tab.close(done);
131289:     }
131289:   });
131289: 
131289:   tabs.open({
131289:     url: "about:",
131289:     onOpen: function onOpen(t) {
131289:       tab = t;
131289:     }
131289:   });
131289: };
131289: 
164700: exports.testRelatedTabNoRequireTab = function(assert, done) {
133768:   let loader = Loader(module);
133768:   let tab;
133768:   let url = "data:text/html;charset=utf-8," + encodeURI("Test related worker tab 2");
133768:   let { PageMod } = loader.require("sdk/page-mod");
133768:   let pageMod = new PageMod({
133768:     include: url,
133768:     onAttach: function(worker) {
164700:       assert.equal(worker.tab.url, url, "Worker.tab.url is valid");
142991:       worker.tab.close(function() {
133768:         pageMod.destroy();
133768:         loader.unload();
164700:         done();
142991:       });
133768:     }
133768:   });
133768: 
133768:   tabs.open(url);
133768: };
133768: 
164700: exports.testRelatedTabNoOtherReqs = function(assert, done) {
131289:   let loader = Loader(module);
131289:   let { PageMod } = loader.require("sdk/page-mod");
131289:   let pageMod = new PageMod({
135382:     include: "about:blank?testRelatedTabNoOtherReqs",
131289:     onAttach: function(worker) {
164700:       assert.ok(!!worker.tab, "Worker.tab exists");
131289:       pageMod.destroy();
131289:       worker.tab.close(function() {
135382:         worker.destroy();
131289:         loader.unload();
164700:         done();
131289:       });
131289:     }
131289:   });
131289: 
131289:   tabs.open({
135382:     url: "about:blank?testRelatedTabNoOtherReqs"
131289:   });
131289: };
131289: 
164700: exports.testWorksWithExistingTabs = function(assert, done) {
131289:   let url = "data:text/html;charset=utf-8," + encodeURI("Test unique document");
131289:   let { PageMod } = require("sdk/page-mod");
131289:   tabs.open({
131289:     url: url,
131289:     onReady: function onReady(tab) {
131289:       let pageModOnExisting = new PageMod({
131289:         include: url,
131289:         attachTo: ["existing", "top", "frame"],
131289:         onAttach: function(worker) {
164700:           assert.ok(!!worker.tab, "Worker.tab exists");
164700:           assert.equal(tab, worker.tab, "A worker has been created on this existing tab");
131289: 
131289:           timer.setTimeout(function() {
131289:             pageModOnExisting.destroy();
131289:             pageModOffExisting.destroy();
164700:             tab.close(done);
131289:           }, 0);
131289:         }
131289:       });
131289: 
131289:       let pageModOffExisting = new PageMod({
131289:         include: url,
131289:         onAttach: function(worker) {
164700:           assert.fail("pageModOffExisting page-mod should not have attached to anything");
131289:         }
131289:       });
131289:     }
131289:   });
131289: };
131289: 
173557: exports.testExistingFrameDoesntMatchInclude = function(assert, done) {
173557:   let iframeURL = 'data:text/html;charset=utf-8,UNIQUE-TEST-STRING-42';
173557:   let iframe = '<iframe src="' + iframeURL + '" />';
173557:   let url = 'data:text/html;charset=utf-8,' + encodeURIComponent(iframe);
173557:   tabs.open({
173557:     url: url,
173557:     onReady: function onReady(tab) {
173557:       let pagemod = new PageMod({
173557:         include: url,
173557:         attachTo: ['existing', 'frame'],
173557:         onAttach: function() {
173557:           assert.fail("Existing iframe URL doesn't match include, must not attach to anything");
173557:         }
173557:       });
173557:       timer.setTimeout(function() {
173557:         assert.pass("PageMod didn't attach to anything")
173557:         pagemod.destroy();
173557:         tab.close(done);
173557:       }, 250);
173557:     }
173557:   });
173557: };
173557: 
173557: exports.testExistingOnlyFrameMatchesInclude = function(assert, done) {
173557:   let iframeURL = 'data:text/html;charset=utf-8,UNIQUE-TEST-STRING-43';
173557:   let iframe = '<iframe src="' + iframeURL + '" />';
173557:   let url = 'data:text/html;charset=utf-8,' + encodeURIComponent(iframe);
173557:   tabs.open({
173557:     url: url,
173557:     onReady: function onReady(tab) {
173557:       let pagemod = new PageMod({
173557:         include: iframeURL,
173557:         attachTo: ['existing', 'frame'],
173557:         onAttach: function(worker) {
173557:           assert.equal(iframeURL, worker.url, 
173557:               "PageMod attached to existing iframe when only it matches include rules");
173557:           pagemod.destroy();
173557:           tab.close(done);
173557:         }
173557:       });
173557:     }
173557:   });
173557: };
173557: 
164700: exports.testTabWorkerOnMessage = function(assert, done) {
131289:   let { browserWindows } = require("sdk/windows");
131289:   let tabs = require("sdk/tabs");
131289:   let { PageMod } = require("sdk/page-mod");
131289: 
131289:   let url1 = "data:text/html;charset=utf-8,<title>tab1</title><h1>worker1.tab</h1>";
131289:   let url2 = "data:text/html;charset=utf-8,<title>tab2</title><h1>worker2.tab</h1>";
131289:   let worker1 = null;
131289: 
131289:   let mod = PageMod({
131289:     include: "data:text/html*",
131289:     contentScriptWhen: "ready",
131289:     contentScript: "self.postMessage('#1');",
131289:     onAttach: function onAttach(worker) {
131289:       worker.on("message", function onMessage() {
131289:         this.tab.attach({
131289:           contentScriptWhen: "ready",
131289:           contentScript: "self.postMessage({ url: window.location.href, title: document.title });",
131289:           onMessage: function onMessage(data) {
164700:             assert.equal(this.tab.url, data.url, "location is correct");
164700:             assert.equal(this.tab.title, data.title, "title is correct");
131289:             if (this.tab.url === url1) {
131289:               worker1 = this;
131289:               tabs.open({ url: url2, inBackground: true });
131289:             }
131289:             else if (this.tab.url === url2) {
131289:               mod.destroy();
142991:               worker1.tab.close(function() {
131289:                 worker1.destroy();
142991:                 worker.tab.close(function() {
131289:                   worker.destroy();
164700:                   done();
142991:                 });
142991:               });
131289:             }
131289:           }
131289:         });
131289:       });
131289:     }
131289:   });
131289: 
131289:   tabs.open(url1);
131289: };
131289: 
164700: exports.testAutomaticDestroy = function(assert, done) {
131289:   let loader = Loader(module);
131289: 
131289:   let pageMod = loader.require("sdk/page-mod").PageMod({
131289:     include: "about:*",
131289:     contentScriptWhen: "start",
131289:     onAttach: function(w) {
164700:       assert.fail("Page-mod should have been detroyed during module unload");
131289:     }
131289:   });
131289: 
131289:   // Unload the page-mod module so that our page mod is destroyed
131289:   loader.unload();
131289: 
131289:   // Then create a second tab to ensure that it is correctly destroyed
131289:   let tabs = require("sdk/tabs");
131289:   tabs.open({
131289:     url: "about:",
131289:     onReady: function onReady(tab) {
164700:       assert.pass("check automatic destroy");
164700:       tab.close(done);
131289:     }
131289:   });
164700: };
131289: 
164700: exports.testAttachToTabsOnly = function(assert, done) {
131289: 
131289:   let { PageMod } = require('sdk/page-mod');
131289:   let openedTab = null; // Tab opened in openTabWithIframe()
131289:   let workerCount = 0;
131289: 
131289:   let mod = PageMod({
131289:     include: 'data:text/html*',
131289:     contentScriptWhen: 'start',
131289:     contentScript: '',
131289:     onAttach: function onAttach(worker) {
131289:       if (worker.tab === openedTab) {
131289:         if (++workerCount == 3) {
164700:           assert.pass('Succesfully applied to tab documents and its iframe');
131289:           worker.destroy();
131289:           mod.destroy();
164700:           openedTab.close(done);
131289:         }
131289:       }
131289:       else {
164700:         assert.fail('page-mod attached to a non-tab document');
131289:       }
131289:     }
131289:   });
131289: 
131289:   function openHiddenFrame() {
131289:     console.info('Open iframe in hidden window');
131289:     let hiddenFrames = require('sdk/frame/hidden-frame');
131289:     let hiddenFrame = hiddenFrames.add(hiddenFrames.HiddenFrame({
131289:       onReady: function () {
131289:         let element = this.element;
131289:         element.addEventListener('DOMContentLoaded', function onload() {
131289:           element.removeEventListener('DOMContentLoaded', onload, false);
131289:           hiddenFrames.remove(hiddenFrame);
135382: 
136693:           if (!xulApp.is("Fennec")) {
131289:             openToplevelWindow();
135382:           }
135382:           else {
135382:             openBrowserIframe();
135382:           }
131289:         }, false);
131289:         element.setAttribute('src', 'data:text/html;charset=utf-8,foo');
131289:       }
131289:     }));
131289:   }
131289: 
131289:   function openToplevelWindow() {
131289:     console.info('Open toplevel window');
131289:     let win = open('data:text/html;charset=utf-8,bar');
131289:     win.addEventListener('DOMContentLoaded', function onload() {
131289:       win.removeEventListener('DOMContentLoaded', onload, false);
131289:       win.close();
131289:       openBrowserIframe();
131289:     }, false);
131289:   }
131289: 
131289:   function openBrowserIframe() {
131289:     console.info('Open iframe in browser window');
182866:     let window = require('sdk/deprecated/window-utils').activeBrowserWindow;
131289:     let document = window.document;
131289:     let iframe = document.createElement('iframe');
131289:     iframe.setAttribute('type', 'content');
131289:     iframe.setAttribute('src', 'data:text/html;charset=utf-8,foobar');
131289:     iframe.addEventListener('DOMContentLoaded', function onload() {
131289:       iframe.removeEventListener('DOMContentLoaded', onload, false);
131289:       iframe.parentNode.removeChild(iframe);
131289:       openTabWithIframes();
131289:     }, false);
131289:     document.documentElement.appendChild(iframe);
131289:   }
131289: 
131289:   // Only these three documents will be accepted by the page-mod
131289:   function openTabWithIframes() {
131289:     console.info('Open iframes in a tab');
131289:     let subContent = '<iframe src="data:text/html;charset=utf-8,sub frame" />'
135382:     let content = '<iframe src="data:text/html;charset=utf-8,' +
131289:                   encodeURIComponent(subContent) + '" />';
131289:     require('sdk/tabs').open({
131289:       url: 'data:text/html;charset=utf-8,' + encodeURIComponent(content),
131289:       onOpen: function onOpen(tab) {
131289:         openedTab = tab;
131289:       }
131289:     });
131289:   }
131289: 
131289:   openHiddenFrame();
131289: };
131289: 
164700: exports['test111 attachTo [top]'] = function(assert, done) {
131289:   let { PageMod } = require('sdk/page-mod');
131289: 
131289:   let subContent = '<iframe src="data:text/html;charset=utf-8,sub frame" />'
131289:   let content = '<iframe src="data:text/html;charset=utf-8,' +
131289:                 encodeURIComponent(subContent) + '" />';
131289:   let topDocumentURL = 'data:text/html;charset=utf-8,' + encodeURIComponent(content)
131289: 
131289:   let workerCount = 0;
131289: 
131289:   let mod = PageMod({
131289:     include: 'data:text/html*',
131289:     contentScriptWhen: 'start',
131289:     contentScript: 'self.postMessage(document.location.href);',
131289:     attachTo: ['top'],
131289:     onAttach: function onAttach(worker) {
131289:       if (++workerCount == 1) {
131289:         worker.on('message', function (href) {
164700:           assert.equal(href, topDocumentURL,
131289:                            "worker on top level document only");
131289:           let tab = worker.tab;
131289:           worker.destroy();
131289:           mod.destroy();
164700:           tab.close(done);
131289:         });
131289:       }
131289:       else {
164700:         assert.fail('page-mod attached to a non-top document');
131289:       }
131289:     }
131289:   });
131289: 
131289:   require('sdk/tabs').open(topDocumentURL);
131289: };
131289: 
164700: exports['test111 attachTo [frame]'] = function(assert, done) {
131289:   let { PageMod } = require('sdk/page-mod');
131289: 
131289:   let subFrameURL = 'data:text/html;charset=utf-8,subframe';
131289:   let subContent = '<iframe src="' + subFrameURL + '" />';
131289:   let frameURL = 'data:text/html;charset=utf-8,' + encodeURIComponent(subContent);
131289:   let content = '<iframe src="' + frameURL + '" />';
131289:   let topDocumentURL = 'data:text/html;charset=utf-8,' + encodeURIComponent(content)
131289: 
131289:   let workerCount = 0, messageCount = 0;
131289: 
131289:   function onMessage(href) {
131289:     if (href == frameURL)
164700:       assert.pass("worker on first frame");
131289:     else if (href == subFrameURL)
164700:       assert.pass("worker on second frame");
131289:     else
164700:       assert.fail("worker on unexpected document: " + href);
131289:     this.destroy();
131289:     if (++messageCount == 2) {
131289:       mod.destroy();
164700:       require('sdk/tabs').activeTab.close(done);
131289:     }
131289:   }
131289:   let mod = PageMod({
131289:     include: 'data:text/html*',
131289:     contentScriptWhen: 'start',
131289:     contentScript: 'self.postMessage(document.location.href);',
131289:     attachTo: ['frame'],
131289:     onAttach: function onAttach(worker) {
131289:       if (++workerCount <= 2) {
131289:         worker.on('message', onMessage);
131289:       }
131289:       else {
164700:         assert.fail('page-mod attached to a non-frame document');
131289:       }
131289:     }
131289:   });
131289: 
131289:   require('sdk/tabs').open(topDocumentURL);
131289: };
131289: 
164700: exports.testContentScriptOptionsOption = function(assert, done) {
131289:   let callbackDone = null;
164700:   testPageMod(assert, done, "about:", [{
131289:       include: "about:*",
131289:       contentScript: "self.postMessage( [typeof self.options.d, self.options] );",
131289:       contentScriptWhen: "end",
131289:       contentScriptOptions: {a: true, b: [1,2,3], c: "string", d: function(){ return 'test'}},
131289:       onAttach: function(worker) {
131289:         worker.on('message', function(msg) {
164700:           assert.equal( msg[0], 'undefined', 'functions are stripped from contentScriptOptions' );
164700:           assert.equal( typeof msg[1], 'object', 'object as contentScriptOptions' );
164700:           assert.equal( msg[1].a, true, 'boolean in contentScriptOptions' );
164700:           assert.equal( msg[1].b.join(), '1,2,3', 'array and numbers in contentScriptOptions' );
164700:           assert.equal( msg[1].c, 'string', 'string in contentScriptOptions' );
131289:           callbackDone();
131289:         });
131289:       }
131289:     }],
131289:     function(win, done) {
131289:       callbackDone = done;
131289:     }
131289:   );
131289: };
131289: 
164700: exports.testPageModCss = function(assert, done) {
164700:   let [pageMod] = testPageMod(assert, done,
131289:     'data:text/html;charset=utf-8,<div style="background: silver">css test</div>', [{
131289:       include: ["*", "data:*"],
131289:       contentStyle: "div { height: 100px; }",
169252:       contentStyleFile: data.url("pagemod-css-include-file.css")
131289:     }],
131289:     function(win, done) {
131289:       let div = win.document.querySelector("div");
164700:       assert.equal(
131289:         div.clientHeight,
131289:         100,
131289:         "PageMod contentStyle worked"
131289:       );
164700:       assert.equal(
131289:        div.offsetHeight,
131289:         120,
131289:         "PageMod contentStyleFile worked"
131289:       );
131289:       done();
131289:     }
131289:   );
131289: };
131289: 
164700: exports.testPageModCssList = function(assert, done) {
164700:   let [pageMod] = testPageMod(assert, done,
131289:     'data:text/html;charset=utf-8,<div style="width:320px; max-width: 480px!important">css test</div>', [{
131289:       include: "data:*",
131289:       contentStyleFile: [
131289:         // Highlight evaluation order in this list
131289:         "data:text/css;charset=utf-8,div { border: 1px solid black; }",
131289:         "data:text/css;charset=utf-8,div { border: 10px solid black; }",
131289:         // Highlight evaluation order between contentStylesheet & contentStylesheetFile
140496:         "data:text/css;charset=utf-8s,div { height: 1000px; }",
131289:         // Highlight precedence between the author and user style sheet
131289:         "data:text/css;charset=utf-8,div { width: 200px; max-width: 640px!important}",
131289:       ],
131289:       contentStyle: [
131289:         "div { height: 10px; }",
131289:         "div { height: 100px; }"
131289:       ]
131289:     }],
131289:     function(win, done) {
131289:       let div = win.document.querySelector("div"),
131289:           style = win.getComputedStyle(div);
131289: 
164700:       assert.equal(
131289:        div.clientHeight,
131289:         100,
131289:         "PageMod contentStyle list works and is evaluated after contentStyleFile"
131289:       );
131289: 
164700:       assert.equal(
131289:         div.offsetHeight,
131289:         120,
131289:         "PageMod contentStyleFile list works"
131289:       );
131289: 
164700:       assert.equal(
131289:         style.width,
131289:         "320px",
140496:         "PageMod add-on author/page author style sheet precedence works"
131289:       );
131289: 
164700:       assert.equal(
131289:         style.maxWidth,
140496:         "480px",
140496:         "PageMod add-on author/page author style sheet precedence with !important works"
131289:       );
131289: 
131289:       done();
131289:     }
131289:   );
131289: };
131289: 
164700: exports.testPageModCssDestroy = function(assert, done) {
164700:   let [pageMod] = testPageMod(assert, done,
131289:     'data:text/html;charset=utf-8,<div style="width:200px">css test</div>', [{
131289:       include: "data:*",
131289:       contentStyle: "div { width: 100px!important; }"
131289:     }],
131289: 
131289:     function(win, done) {
131289:       let div = win.document.querySelector("div"),
131289:           style = win.getComputedStyle(div);
131289: 
164700:       assert.equal(
131289:         style.width,
131289:         "100px",
131289:         "PageMod contentStyle worked"
131289:       );
131289: 
131289:       pageMod.destroy();
164700:       assert.equal(
131289:         style.width,
131289:         "200px",
131289:         "PageMod contentStyle is removed after destroy"
131289:       );
131289: 
131289:       done();
131289: 
131289:     }
131289:   );
131289: };
131289: 
164700: exports.testPageModCssAutomaticDestroy = function(assert, done) {
131289:   let loader = Loader(module);
131289: 
133768:   let pageMod = loader.require("sdk/page-mod").PageMod({
131289:     include: "data:*",
131289:     contentStyle: "div { width: 100px!important; }"
131289:   });
131289: 
131289:   tabs.open({
131289:     url: "data:text/html;charset=utf-8,<div style='width:200px'>css test</div>",
131289: 
131289:     onReady: function onReady(tab) {
182866:       let browserWindow = windowUtils.activeBrowserWindow;
131289:       let win = getTabContentWindow(getActiveTab(browserWindow));
131289: 
135382:       let div = win.document.querySelector("div");
135382:       let style = win.getComputedStyle(div);
131289: 
164700:       assert.equal(
131289:         style.width,
131289:         "100px",
131289:         "PageMod contentStyle worked"
131289:       );
131289: 
131289:       loader.unload();
131289: 
164700:       assert.equal(
131289:         style.width,
131289:         "200px",
131289:         "PageMod contentStyle is removed after loader's unload"
131289:       );
131289: 
164700:       tab.close(done);
131289:     }
131289:   });
131289: };
131289: 
131289: 
164700: exports.testPageModTimeout = function(assert, done) {
131289:   let tab = null
131289:   let loader = Loader(module);
133768:   let { PageMod } = loader.require("sdk/page-mod");
131289: 
131289:   let mod = PageMod({
131289:     include: "data:*",
131289:     contentScript: Isolate(function() {
131289:       var id = setTimeout(function() {
131289:         self.port.emit("fired", id)
131289:       }, 10)
131289:       self.port.emit("scheduled", id);
131289:     }),
131289:     onAttach: function(worker) {
131289:       worker.port.on("scheduled", function(id) {
164700:         assert.pass("timer was scheduled")
131289:         worker.port.on("fired", function(data) {
164700:           assert.equal(id, data, "timer was fired")
142991:           tab.close(function() {
131289:             worker.destroy()
131289:             loader.unload()
164700:             done()
142991:           });
131289:         })
131289:       })
131289:     }
131289:   });
131289: 
131289:   tabs.open({
131289:     url: "data:text/html;charset=utf-8,timeout",
131289:     onReady: function($) { tab = $ }
131289:   })
131289: }
131289: 
131289: 
164700: exports.testPageModcancelTimeout = function(assert, done) {
131289:   let tab = null
131289:   let loader = Loader(module);
133768:   let { PageMod } = loader.require("sdk/page-mod");
131289: 
131289:   let mod = PageMod({
131289:     include: "data:*",
131289:     contentScript: Isolate(function() {
131289:       var id1 = setTimeout(function() {
131289:         self.port.emit("failed")
131289:       }, 10)
131289:       var id2 = setTimeout(function() {
131289:         self.port.emit("timeout")
131289:       }, 100)
131289:       clearTimeout(id1)
131289:     }),
131289:     onAttach: function(worker) {
131289:       worker.port.on("failed", function() {
164700:         assert.fail("cancelled timeout fired")
131289:       })
131289:       worker.port.on("timeout", function(id) {
164700:         assert.pass("timer was scheduled")
142991:         tab.close(function() {
131289:           worker.destroy();
131289:           mod.destroy();
131289:           loader.unload();
164700:           done();
142991:         });
131289:       })
131289:     }
131289:   });
131289: 
131289:   tabs.open({
131289:     url: "data:text/html;charset=utf-8,cancell timeout",
131289:     onReady: function($) { tab = $ }
131289:   })
131289: }
131289: 
164700: exports.testExistingOnFrames = function(assert, done) {
131289:   let subFrameURL = 'data:text/html;charset=utf-8,testExistingOnFrames-sub-frame';
131289:   let subIFrame = '<iframe src="' + subFrameURL + '" />'
131289:   let iFrameURL = 'data:text/html;charset=utf-8,' + encodeURIComponent(subIFrame)
131289:   let iFrame = '<iframe src="' + iFrameURL + '" />';
131289:   let url = 'data:text/html;charset=utf-8,' + encodeURIComponent(iFrame);
131289: 
131289:   // we want all urls related to the test here, and not just the iframe urls
131289:   // because we need to fail if the test is applied to the top window url.
131289:   let urls = [url, iFrameURL, subFrameURL];
131289: 
131289:   let counter = 0;
131289:   let tab = openTab(getMostRecentBrowserWindow(), url);
131289:   let window = getTabContentWindow(tab);
131289: 
131289:   function wait4Iframes() {
131289:     if (window.document.readyState != "complete" ||
131289:         getFrames(window).length != 2) {
131289:       return;
131289:     }
131289: 
136693:     let pagemodOnExisting = PageMod({
131289:       include: ["*", "data:*"],
131289:       attachTo: ["existing", "frame"],
131289:       contentScriptWhen: 'ready',
131289:       onAttach: function(worker) {
131289:         // need to ignore urls that are not part of the test, because other
131289:         // tests are not closing their tabs when they complete..
131289:         if (urls.indexOf(worker.url) == -1)
131289:           return;
131289: 
164700:         assert.notEqual(url,
131289:                             worker.url,
131289:                             'worker should not be attached to the top window');
131289: 
131289:         if (++counter < 2) {
131289:           // we can rely on this order in this case because we are sure that
131289:           // the frames being tested have completely loaded
164700:           assert.equal(iFrameURL, worker.url, '1st attach is for top frame');
131289:         }
131289:         else if (counter > 2) {
164700:           assert.fail('applied page mod too many times');
131289:         }
131289:         else {
164700:           assert.equal(subFrameURL, worker.url, '2nd attach is for sub frame');
131289:           // need timeout because onAttach is called before the constructor returns
131289:           timer.setTimeout(function() {
131289:             pagemodOnExisting.destroy();
131289:             pagemodOffExisting.destroy();
131289:             closeTab(tab);
164700:             done();
131289:           }, 0);
131289:         }
131289:       }
131289:     });
131289: 
136693:     let pagemodOffExisting = PageMod({
131289:       include: ["*", "data:*"],
131289:       attachTo: ["frame"],
131289:       contentScriptWhen: 'ready',
131289:       onAttach: function(mod) {
164700:         assert.fail('pagemodOffExisting page-mod should not have been attached');
131289:       }
131289:     });
131289:   }
131289: 
131289:   window.addEventListener("load", wait4Iframes, false);
131289: };
131289: 
164700: exports.testIFramePostMessage = function(assert, done) {
135382:   let count = 0;
131289: 
131289:   tabs.open({
131289:     url: data.url("test-iframe.html"),
131289:     onReady: function(tab) {
131289:       var worker = tab.attach({
131289:         contentScriptFile: data.url('test-iframe.js'),
131289:         contentScript: 'var iframePath = \'' + data.url('test-iframe-postmessage.html') + '\'',
131289:         onMessage: function(msg) {
164700:           assert.equal(++count, 1);
164700:           assert.equal(msg.first, 'a string');
164700:           assert.ok(msg.second[1], "array");
164700:           assert.equal(typeof msg.third, 'object');
131289: 
131289:           worker.destroy();
164700:           tab.close(done);
131289:         }
131289:       });
131289:     }
131289:   });
131289: };
131289: 
164700: exports.testEvents = function(assert, done) {
131289:   let content = "<script>\n new " + function DocumentScope() {
131289:     window.addEventListener("ContentScriptEvent", function () {
131289:       window.receivedEvent = true;
131289:     }, false);
131289:   } + "\n</script>";
131289:   let url = "data:text/html;charset=utf-8," + encodeURIComponent(content);
164700:   testPageMod(assert, done, url, [{
131289:       include: "data:*",
131289:       contentScript: 'new ' + function WorkerScope() {
131289:         let evt = document.createEvent("Event");
131289:         evt.initEvent("ContentScriptEvent", true, true);
131289:         document.body.dispatchEvent(evt);
131289:       }
131289:     }],
131289:     function(win, done) {
164700:       assert.ok(
131289:         win.receivedEvent,
131289:         "Content script sent an event and document received it"
131289:       );
131289:       done();
131289:     }
131289:   );
131289: };
136693: 
164700: exports["test page-mod on private tab"] = function (assert, done) {
164700:   let fail = assert.fail.bind(assert);
141821: 
136693:   let privateUri = "data:text/html;charset=utf-8," +
136693:                    "<iframe src=\"data:text/html;charset=utf-8,frame\" />";
136693:   let nonPrivateUri = "data:text/html;charset=utf-8,non-private";
136693: 
136693:   let pageMod = new PageMod({
136693:     include: "data:*",
136693:     onAttach: function(worker) {
136693:       if (isTabPBSupported || isWindowPBSupported) {
136693:         // When PB isn't supported, the page-mod will apply to all document
136693:         // as all of them will be non-private
164700:         assert.equal(worker.tab.url,
136693:                          nonPrivateUri,
136693:                          "page-mod should only attach to the non-private tab");
136693:       }
141821: 
164700:       assert.ok(!isPrivate(worker),
136693:                   "The worker is really non-private");
164700:       assert.ok(!isPrivate(worker.tab),
136693:                   "The document is really non-private");
136693:       pageMod.destroy();
141821: 
141821:       page1.close().
141821:         then(page2.close).
164700:         then(done, fail);
136693:     }
136693:   });
136693: 
141821:   let page1, page2;
141821:   page1 = openWebpage(privateUri, true);
141821:   page1.ready.then(function() {
141821:     page2 = openWebpage(nonPrivateUri, false);
141821:   }, fail);
136693: }
137856: 
164700: exports["test page-mod on private tab in global pb"] = function (assert, done) {
137856:   if (!isGlobalPBSupported) {
164700:     assert.pass();
164700:     return done();
137856:   }
137856: 
137856:   let privateUri = "data:text/html;charset=utf-8," +
137856:                    "<iframe%20src=\"data:text/html;charset=utf-8,frame\"/>";
137856: 
137856:   let pageMod = new PageMod({
137856:     include: privateUri,
137856:     onAttach: function(worker) {
164700:       assert.equal(worker.tab.url,
137856:                        privateUri,
137856:                        "page-mod should attach");
164700:       assert.equal(isPrivateBrowsingSupported,
137856:                        false,
137856:                        "private browsing is not supported");
164700:       assert.ok(isPrivate(worker),
137856:                   "The worker is really non-private");
164700:       assert.ok(isPrivate(worker.tab),
137856:                   "The document is really non-private");
137856:       pageMod.destroy();
137856: 
137856:       worker.tab.close(function() {
137856:         pb.once('stop', function() {
164700:           assert.pass('global pb stop');
164700:           done();
137856:         });
137856:         pb.deactivate();
137856:       });
137856:     }
137856:   });
137856: 
137856:   let page1;
137856:   pb.once('start', function() {
164700:     assert.pass('global pb start');
137856:     tabs.open({ url: privateUri });
137856:   });
137856:   pb.activate();
137856: }
146742: 
146742: // Bug 699450: Calling worker.tab.close() should not lead to exception
164700: exports.testWorkerTabClose = function(assert, done) {
146742:   let callbackDone;
164700:   testPageMod(assert, done, "about:", [{
146742:       include: "about:",
146742:       contentScript: '',
146742:       onAttach: function(worker) {
146742:         console.log("call close");
146742:         worker.tab.close(function () {
146742:           // On Fennec, tab is completely destroyed right after close event is
146742:           // dispatch, so we need to wait for the next event loop cycle to
146742:           // check for tab nulliness.
146742:           timer.setTimeout(function () {
164700:             assert.ok(!worker.tab,
146742:                         "worker.tab should be null right after tab.close()");
146742:             callbackDone();
146742:           }, 0);
146742:         });
146742:       }
146742:     }],
146742:     function(win, done) {
146742:       callbackDone = done;
146742:     }
146742:   );
146742: };
164700: 
164700: exports.testDebugMetadata = function(assert, done) {
164700:   let dbg = new Debugger;
164700:   let globalDebuggees = [];
164700:   dbg.onNewGlobalObject = function(global) {
164700:     globalDebuggees.push(global);
164700:   }
164700: 
164700:   let mods = testPageMod(assert, done, "about:", [{
164700:       include: "about:",
164700:       contentScriptWhen: "start",
164700:       contentScript: "null;",
182866:     }],
182866:     function(win, done) {
164700:       assert.ok(globalDebuggees.some(function(global) {
164700:         try {
164700:           let metadata = Cu.getSandboxMetadata(global.unsafeDereference());
182866:           return metadata && metadata.addonID && metadata.SDKContentScript;
164700:         } catch(e) {
164700:           // Some of the globals might not be Sandbox instances and thus
164700:           // will cause getSandboxMetadata to fail.
164700:           return false;
164700:         }
164700:       }), "one of the globals is a content script");
164700:       done();
164700:     }
164700:   );
164700: };
164700: 
164700: require('sdk/test').run(exports);
