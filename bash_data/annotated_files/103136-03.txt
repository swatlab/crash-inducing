 43113: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 43113: /* vim:set et cin ts=4 sw=4 sts=4: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 43113: 
 43113: #ifndef nsHttpChannel_h__
 43113: #define nsHttpChannel_h__
 43113: 
 46790: #include "HttpBaseChannel.h"
 46790: 
 43113: #include "nsHttpTransaction.h"
 43113: #include "nsInputStreamPump.h"
 43113: #include "nsThreadUtils.h"
 48304: #include "nsTArray.h"
 43113: 
 43113: #include "nsIHttpEventSink.h"
 43113: #include "nsICachingChannel.h"
 43113: #include "nsICacheEntryDescriptor.h"
 43113: #include "nsICacheListener.h"
 43113: #include "nsIApplicationCacheChannel.h"
 43113: #include "nsIPrompt.h"
 43113: #include "nsIResumableChannel.h"
 43113: #include "nsIProtocolProxyCallback.h"
 43113: #include "nsICancelable.h"
 43832: #include "nsIHttpAuthenticableChannel.h"
 43832: #include "nsIHttpChannelAuthProvider.h"
 48304: #include "nsIAsyncVerifyRedirectCallback.h"
 70188: #include "nsITimedChannel.h"
101111: #include "nsIFile.h"
 70364: #include "nsDNSPrefetch.h"
 70188: #include "TimingStruct.h"
 99874: #include "AutoClose.h"
 99880: #include "mozilla/Telemetry.h"
 43113: 
 43113: class nsAHttpConnection;
 46790: 
 99874: namespace mozilla { namespace net {
 43113: 
 99878: class HttpCacheQuery;
 99878: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpChannel
 43113: //-----------------------------------------------------------------------------
 43113: 
 46790: class nsHttpChannel : public HttpBaseChannel
 71646:                     , public HttpAsyncAborter<nsHttpChannel>
 43113:                     , public nsIStreamListener
 43113:                     , public nsICachingChannel
 43113:                     , public nsICacheListener
 43113:                     , public nsITransportEventSink
 43113:                     , public nsIProtocolProxyCallback
 43832:                     , public nsIHttpAuthenticableChannel
 43113:                     , public nsIApplicationCacheChannel
 48304:                     , public nsIAsyncVerifyRedirectCallback
 70188:                     , public nsITimedChannel
 43113: {
 43113: public:
 43113:     NS_DECL_ISUPPORTS_INHERITED
 43113:     NS_DECL_NSIREQUESTOBSERVER
 43113:     NS_DECL_NSISTREAMLISTENER
 46915:     NS_DECL_NSICACHEINFOCHANNEL
 43113:     NS_DECL_NSICACHINGCHANNEL
 43113:     NS_DECL_NSICACHELISTENER
 43113:     NS_DECL_NSITRANSPORTEVENTSINK
 43113:     NS_DECL_NSIPROTOCOLPROXYCALLBACK
 43113:     NS_DECL_NSIPROXIEDCHANNEL
 43113:     NS_DECL_NSIAPPLICATIONCACHECONTAINER
 43113:     NS_DECL_NSIAPPLICATIONCACHECHANNEL
 48304:     NS_DECL_NSIASYNCVERIFYREDIRECTCALLBACK
 70188:     NS_DECL_NSITIMEDCHANNEL
 43832: 
 43832:     // nsIHttpAuthenticableChannel. We can't use
 43832:     // NS_DECL_NSIHTTPAUTHENTICABLECHANNEL because it duplicates cancel() and
 43832:     // others.
 79445:     NS_IMETHOD GetIsSSL(bool *aIsSSL);
 79445:     NS_IMETHOD GetProxyMethodIsConnect(bool *aProxyMethodIsConnect);
 43832:     NS_IMETHOD GetServerResponseHeader(nsACString & aServerResponseHeader);
 43832:     NS_IMETHOD GetProxyChallenges(nsACString & aChallenges);
 43832:     NS_IMETHOD GetWWWChallenges(nsACString & aChallenges);
 43832:     NS_IMETHOD SetProxyCredentials(const nsACString & aCredentials);
 43832:     NS_IMETHOD SetWWWCredentials(const nsACString & aCredentials);
 43832:     NS_IMETHOD OnAuthAvailable();
 79445:     NS_IMETHOD OnAuthCancelled(bool userCancel);
 46909:     // Functions we implement from nsIHttpAuthenticableChannel but are
 46909:     // declared in HttpBaseChannel must be implemented in this class. We
 46909:     // just call the HttpBaseChannel:: impls.
 46909:     NS_IMETHOD GetLoadFlags(nsLoadFlags *aLoadFlags);
 46909:     NS_IMETHOD GetURI(nsIURI **aURI);
 46909:     NS_IMETHOD GetNotificationCallbacks(nsIInterfaceRequestor **aCallbacks);
 46909:     NS_IMETHOD GetLoadGroup(nsILoadGroup **aLoadGroup);
 46909:     NS_IMETHOD GetRequestMethod(nsACString& aMethod);
 43113: 
 43113:     nsHttpChannel();
 43113:     virtual ~nsHttpChannel();
 43113: 
 46909:     virtual nsresult Init(nsIURI *aURI, PRUint8 aCaps, nsProxyInfo *aProxyInfo);
 43113: 
 46790:     // Methods HttpBaseChannel didn't implement for us or that we override.
 46790:     //
 46790:     // nsIRequest
 46790:     NS_IMETHOD Cancel(nsresult status);
 46790:     NS_IMETHOD Suspend();
 46790:     NS_IMETHOD Resume();
 46790:     // nsIChannel
 46790:     NS_IMETHOD GetSecurityInfo(nsISupports **aSecurityInfo);
 46790:     NS_IMETHOD AsyncOpen(nsIStreamListener *listener, nsISupports *aContext);
 46790:     // nsIHttpChannelInternal
 46790:     NS_IMETHOD SetupFallbackChannel(const char *aFallbackKey);
 46793:     // nsISupportsPriority
 46793:     NS_IMETHOD SetPriority(PRInt32 value);
 49379:     // nsIResumableChannel
 49379:     NS_IMETHOD ResumeAt(PRUint64 startPos, const nsACString& entityID);
 43173: 
 46790: public: /* internal necko use only */ 
 54894: 
 46887:     void InternalSetUploadStream(nsIInputStream *uploadStream) 
 46887:       { mUploadStream = uploadStream; }
 79445:     void SetUploadStreamHasHeaders(bool hasHeaders) 
 46887:       { mUploadStreamHasHeaders = hasHeaders; }
 46791: 
 46791:     nsresult SetReferrerInternal(nsIURI *referrer) {
 46791:         nsCAutoString spec;
 46791:         nsresult rv = referrer->GetAsciiSpec(spec);
 46791:         if (NS_FAILED(rv)) return rv;
 46791:         mReferrer = referrer;
 46791:         mRequestHead.SetHeader(nsHttp::Referer, spec);
 46791:         return NS_OK;
 46791:     }
 43113: 
 97914:     // This allows cache entry to be marked as foreign even after channel itself
 97914:     // is gone.  Needed for e10s (see HttpChannelParent::RecvDocumentChannelCleanup)
 97914:     class OfflineCacheEntryAsForeignMarker {
 97914:         nsCOMPtr<nsIApplicationCache> mApplicationCache;
 97914:         nsCString mCacheKey;
 97914:     public:
 97914:         OfflineCacheEntryAsForeignMarker(nsIApplicationCache* appCache,
 97914:                                          const nsCSubstring& key)
 97914:              : mApplicationCache(appCache)
 97914:              , mCacheKey(key)
 97914:         {}
 97914: 
 97914:         nsresult MarkAsForeign();
 97914:     };
 97914: 
 97914:     OfflineCacheEntryAsForeignMarker* GetOfflineCacheEntryAsForeignMarker();
 97914: 
 99366:     /**
 99366:      * Returns true if this channel is operating in private browsing mode,
 99366:      * false otherwise.
 99366:      */
 99368:     bool UsingPrivateBrowsing() {
 99368:         bool usingPB;
 99368:         GetUsingPrivateBrowsing(&usingPB);
 99368:         return usingPB;
 99368:     }
 99366: 
 43113: private:
 48304:     typedef nsresult (nsHttpChannel::*nsContinueRedirectionFunc)(nsresult result);
 48304: 
 79445:     bool     RequestIsConditional();
 99870:     nsresult Connect();
 99870:     nsresult ContinueConnect();
 96926:     void     SpeculativeConnect();
 43113:     nsresult SetupTransaction();
 43113:     nsresult CallOnStartRequest();
 43113:     nsresult ProcessResponse();
 48304:     nsresult ContinueProcessResponse(nsresult);
 43113:     nsresult ProcessNormal();
 48304:     nsresult ContinueProcessNormal(nsresult);
 43113:     nsresult ProcessNotModified();
 48304:     nsresult AsyncProcessRedirection(PRUint32 httpStatus);
 48304:     nsresult ContinueProcessRedirection(nsresult);
 48304:     nsresult ContinueProcessRedirectionAfterFallback(nsresult);
102885:     bool     ShouldSSLProxyResponseContinue(PRUint32 httpStatus);
102885:     nsresult ProcessFailedSSLConnect(PRUint32 httpStatus);
 79445:     nsresult ProcessFallback(bool *waitingForRedirectCallback);
 48304:     nsresult ContinueProcessFallback(nsresult);
 71646:     void     HandleAsyncAbort();
 93839:     nsresult EnsureAssocReq();
 43113: 
 48304:     nsresult ContinueOnStartRequest1(nsresult);
 48304:     nsresult ContinueOnStartRequest2(nsresult);
 48304:     nsresult ContinueOnStartRequest3(nsresult);
 48304: 
 43113:     // redirection specific methods
 43113:     void     HandleAsyncRedirect();
 48304:     nsresult ContinueHandleAsyncRedirect(nsresult);
 43113:     void     HandleAsyncNotModified();
 43113:     void     HandleAsyncFallback();
 48304:     nsresult ContinueHandleAsyncFallback(nsresult);
 43113:     nsresult PromptTempRedirect();
 89558:     virtual nsresult SetupReplacementChannel(nsIURI *, nsIChannel *,
 89558:                                              bool preserveMethod,
 89558:                                              bool forProxy);
 43113: 
 43113:     // proxy specific methods
 43113:     nsresult ProxyFailover();
 48304:     nsresult AsyncDoReplaceWithProxy(nsIProxyInfo *);
 48304:     nsresult ContinueDoReplaceWithProxy(nsresult);
 43113:     void HandleAsyncReplaceWithProxy();
 48304:     nsresult ContinueHandleAsyncReplaceWithProxy(nsresult);
 43113:     nsresult ResolveProxy();
 43113: 
 43113:     // cache specific methods
 99878:     nsresult OpenCacheEntry(bool usingSSL);
 53987:     nsresult OnOfflineCacheEntryAvailable(nsICacheEntryDescriptor *aEntry,
 53987:                                           nsCacheAccessMode aAccess,
 93830:                                           nsresult aResult);
 99878:     nsresult OpenNormalCacheEntry(bool usingSSL);
 53987:     nsresult OnNormalCacheEntryAvailable(nsICacheEntryDescriptor *aEntry,
 53987:                                          nsCacheAccessMode aAccess,
 93830:                                          nsresult aResult);
 43113:     nsresult OpenOfflineCacheEntryForWriting();
 93830:     nsresult OnOfflineCacheEntryForWritingAvailable(
 93830:         nsICacheEntryDescriptor *aEntry,
 93830:         nsCacheAccessMode aAccess,
 93830:         nsresult aResult);
 93830:     nsresult OnCacheEntryAvailableInternal(nsICacheEntryDescriptor *entry,
 93830:                                            nsCacheAccessMode access,
 93830:                                            nsresult status);
 43113:     nsresult GenerateCacheKey(PRUint32 postID, nsACString &key);
 43113:     nsresult UpdateExpirationTime();
 43113:     nsresult CheckCache();
 99873:     bool ShouldUpdateOfflineCacheEntry();
 99874:     nsresult ReadFromCache(bool alreadyMarkedValid);
 79445:     void     CloseCacheEntry(bool doomOnFailure);
 43113:     void     CloseOfflineCacheEntry();
 43113:     nsresult InitCacheEntry();
 88544:     void     UpdateInhibitPersistentCachingFlag();
 43113:     nsresult InitOfflineCacheEntry();
 43113:     nsresult AddCacheEntryHeaders(nsICacheEntryDescriptor *entry);
 43113:     nsresult StoreAuthorizationMetaData(nsICacheEntryDescriptor *entry);
 43113:     nsresult FinalizeCacheEntry();
 43113:     nsresult InstallCacheListener(PRUint32 offset = 0);
 43113:     nsresult InstallOfflineCacheListener();
 43113:     void     MaybeInvalidateCacheEntryForSubsequentGet();
 99879:     nsCacheStoragePolicy DetermineStoragePolicy(bool isPrivate);
 53987:     nsresult DetermineCacheAccess(nsCacheAccessMode *_retval);
 43113:     void     AsyncOnExamineCachedResponse();
 43113: 
 43113:     // Handle the bogus Content-Encoding Apache sometimes sends
 43113:     void ClearBogusContentEncodingIfNeeded();
 43113: 
 43113:     // byte range request specific methods
 43113:     nsresult ProcessPartialContent();
 79445:     nsresult OnDoneReadingPartialCacheEntry(bool *streamDone);
 43113: 
 43113:     nsresult DoAuthRetry(nsAHttpConnection *);
 43113: 
 51363:     void     HandleAsyncRedirectChannelToHttps();
 51363:     nsresult AsyncRedirectChannelToHttps();
 51363:     nsresult ContinueAsyncRedirectChannelToHttps(nsresult rv);
 51363: 
 51363:     /**
 51363:      * A function that takes care of reading STS headers and enforcing STS 
 51363:      * load rules.  After a secure channel is erected, STS requires the channel
 51363:      * to be trusted or any STS header data on the channel is ignored.
 51363:      * This is called from ProcessResponse.
 51363:      */
 51363:     nsresult ProcessSTSHeader();
 51363: 
 71627:     void InvalidateCacheEntryForLocation(const char *location);
 71627:     void AssembleCacheKey(const char *spec, PRUint32 postID, nsACString &key);
 71627:     nsresult CreateNewURI(const char *loc, nsIURI **newURI);
 99879:     void DoInvalidateCacheEntry(const nsCString &key);
 71627: 
 71627:     // Ref RFC2616 13.10: "invalidation... MUST only be performed if
 71627:     // the host part is the same as in the Request-URI"
 79445:     inline bool HostPartIsTheSame(nsIURI *uri) {
 71627:         nsCAutoString tmpHost1, tmpHost2;
 71627:         return (NS_SUCCEEDED(mURI->GetAsciiHost(tmpHost1)) &&
 71627:                 NS_SUCCEEDED(uri->GetAsciiHost(tmpHost2)) &&
 71627:                 (tmpHost1 == tmpHost2));
 71627:     }
 71627: 
101254:     inline static bool DoNotRender3xxBody(nsresult rv) {
101254:         return rv == NS_ERROR_REDIRECT_LOOP         ||
101254:                rv == NS_ERROR_CORRUPTED_CONTENT     ||
101254:                rv == NS_ERROR_UNKNOWN_PROTOCOL      ||
101254:                rv == NS_ERROR_MALFORMED_URI;
101254:     }
101254: 
 43113: private:
 43113:     nsCOMPtr<nsISupports>             mSecurityInfo;
 43113:     nsCOMPtr<nsICancelable>           mProxyRequest;
 43113: 
 46790:     nsRefPtr<nsInputStreamPump>       mTransactionPump;
 46790:     nsRefPtr<nsHttpTransaction>       mTransaction;
 43113: 
 43113:     PRUint64                          mLogicalOffset;
 43113: 
 43113:     // cache specific data
 99878:     nsRefPtr<HttpCacheQuery>          mCacheQuery;
 43113:     nsCOMPtr<nsICacheEntryDescriptor> mCacheEntry;
103136:     // We must close mCacheInputStream explicitly to avoid leaks.
103136:     AutoClose<nsIInputStream>         mCacheInputStream;
 43113:     nsRefPtr<nsInputStreamPump>       mCachePump;
 46790:     nsAutoPtr<nsHttpResponseHead>     mCachedResponseHead;
 99874:     nsCOMPtr<nsISupports>             mCachedSecurityInfo;
 43113:     nsCacheAccessMode                 mCacheAccess;
 99880:     mozilla::Telemetry::ID            mCacheEntryDeviceTelemetryID;
 43113:     PRUint32                          mPostID;
 43113:     PRUint32                          mRequestTime;
 43113: 
 53987:     typedef nsresult (nsHttpChannel:: *nsOnCacheEntryAvailableCallback)(
 93830:         nsICacheEntryDescriptor *, nsCacheAccessMode, nsresult);
 53987:     nsOnCacheEntryAvailableCallback   mOnCacheEntryAvailableCallback;
 53987: 
 43113:     nsCOMPtr<nsICacheEntryDescriptor> mOfflineCacheEntry;
 43113:     nsCacheAccessMode                 mOfflineCacheAccess;
103134:     PRUint32                          mOfflineCacheLastModifiedTime;
 43113:     nsCString                         mOfflineCacheClientID;
 43113: 
101111:     nsCOMPtr<nsIFile>                 mProfileDirectory;
100212: 
 43113:     // auth specific data
 43832:     nsCOMPtr<nsIHttpChannelAuthProvider> mAuthProvider;
 43113: 
 43113:     // Proxy info to replace with
 43113:     nsCOMPtr<nsIProxyInfo>            mTargetProxyInfo;
 43113: 
 43113:     // If the channel is associated with a cache, and the URI matched
 43113:     // a fallback namespace, this will hold the key for the fallback
 43113:     // cache entry.
 43113:     nsCString                         mFallbackKey;
 43113: 
 51363:     friend class AutoRedirectVetoNotifier;
 71646:     friend class HttpAsyncAborter<nsHttpChannel>;
 99878:     friend class HttpCacheQuery;
 99878: 
 48304:     nsCOMPtr<nsIURI>                  mRedirectURI;
 48304:     nsCOMPtr<nsIChannel>              mRedirectChannel;
 48304:     PRUint32                          mRedirectType;
 48304: 
 43113:     // state flags
 43113:     PRUint32                          mCachedContentIsValid     : 1;
 43113:     PRUint32                          mCachedContentIsPartial   : 1;
 43113:     PRUint32                          mTransactionReplaced      : 1;
 43113:     PRUint32                          mAuthRetryPending         : 1;
 43113:     PRUint32                          mResuming                 : 1;
 43113:     PRUint32                          mInitedCacheEntry         : 1;
 43113:     PRUint32                          mCacheForOfflineUse       : 1;
 43113:     // True if we are loading a fallback cache entry from the
 43113:     // application cache.
 43113:     PRUint32                          mFallbackChannel          : 1;
 43113:     // True if consumer added its own If-None-Match or If-Modified-Since
 43113:     // headers. In such a case we must not override them in the cache code
 43113:     // and also we want to pass possible 304 code response through.
 43113:     PRUint32                          mCustomConditionalRequest : 1;
 48304:     PRUint32                          mFallingBack              : 1;
 48304:     PRUint32                          mWaitingForRedirectCallback : 1;
 48724:     // True if mRequestTime has been set. In such a case it is safe to update
 48724:     // the cache entry's expiration time. Otherwise, it is not(see bug 567360).
 48724:     PRUint32                          mRequestTimeInitialized : 1;
 43113: 
 48304:     nsTArray<nsContinueRedirectionFunc> mRedirectFuncStack;
 48304: 
 70188:     PRTime                            mChannelCreationTime;
 70188:     mozilla::TimeStamp                mChannelCreationTimestamp;
 70188:     mozilla::TimeStamp                mAsyncOpenTime;
 70188:     mozilla::TimeStamp                mCacheReadStart;
 70188:     mozilla::TimeStamp                mCacheReadEnd;
 70188:     // copied from the transaction before we null out mTransaction
 70188:     // so that the timing can still be queried from OnStopRequest
 70188:     TimingStruct                      mTransactionTimings;
 70364:     // Needed for accurate DNS timing
 70364:     nsRefPtr<nsDNSPrefetch>           mDNSPrefetch;
 70188: 
 48304:     nsresult WaitForRedirectCallback();
 48304:     void PushRedirectAsyncFunc(nsContinueRedirectionFunc func);
 48304:     void PopRedirectAsyncFunc(nsContinueRedirectionFunc func);
 71646: 
 71646: protected:
 71646:     virtual void DoNotifyListenerCleanup();
 78427: 
 78427: private: // cache telemetry
 78427:     enum {
 78427:         kCacheHit = 1,
 78427:         kCacheHitViaReval = 2,
 78427:         kCacheMissedViaReval = 3,
 78427:         kCacheMissed = 4
 78427:     };
 78427:     bool mDidReval;
 43113: };
 43113: 
 99874: } } // namespace mozilla::net
 99874: 
 43113: #endif // nsHttpChannel_h__
