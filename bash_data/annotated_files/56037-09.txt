52560: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52560:  * vim: set ts=4 sw=4 et tw=99:
52560:  *
52560:  * ***** BEGIN LICENSE BLOCK *****
52560:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52560:  *
52560:  * The contents of this file are subject to the Mozilla Public License Version
52560:  * 1.1 (the "License"); you may not use this file except in compliance with
52560:  * the License. You may obtain a copy of the License at
52560:  * http://www.mozilla.org/MPL/
52560:  *
52560:  * Software distributed under the License is distributed on an "AS IS" basis,
52560:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52560:  * for the specific language governing rights and limitations under the
52560:  * License.
52560:  *
52560:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52560:  * May 28, 2008.
52560:  *
52560:  * The Initial Developer of the Original Code is
52560:  *   Brendan Eich <brendan@mozilla.org>
52560:  *
52560:  * Contributor(s):
52560:  *   David Anderson <danderson@mozilla.com>
52560:  *   David Mandelin <dmandelin@mozilla.com>
52560:  *
52560:  * Alternatively, the contents of this file may be used under the terms of
52560:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52560:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52560:  * in which case the provisions of the GPL or the LGPL are applicable instead
52560:  * of those above. If you wish to allow use of your version of this file only
52560:  * under the terms of either the GPL or the LGPL, and not to allow others to
52560:  * use your version of this file under the terms of the MPL, indicate your
52560:  * decision by deleting the provisions above and replace them with the notice
52560:  * and other provisions required by the GPL or the LGPL. If you do not delete
52560:  * the provisions above, a recipient may use your version of this file under
52560:  * the terms of any one of the MPL, the GPL or the LGPL.
52560:  *
52560:  * ***** END LICENSE BLOCK ***** */
52734: #include "jsbool.h"
52842: #include "jslibmath.h"
52808: #include "jsnum.h"
53228: #include "jsscope.h"
53531: #include "jsobjinlines.h"
52606: #include "methodjit/MethodJIT.h"
52606: #include "methodjit/Compiler.h"
52608: #include "methodjit/StubCalls.h"
52618: #include "methodjit/FrameState-inl.h"
52560: 
52560: #include "jsautooplen.h"
52560: 
52560: using namespace js;
52608: using namespace js::mjit;
52560: 
53230: typedef JSC::MacroAssembler::RegisterID RegisterID;
53230: 
53230: RegisterID
53230: mjit::Compiler::rightRegForShift(FrameEntry *rhs)
53230: {
53230: #if defined(JS_CPU_X86) || defined(JS_CPU_X64)
53230:     /*
53230:      * Gross: RHS _must_ be in ECX, on x86.
53230:      * Note that we take this first so that we can't up with other register
53230:      * allocations (below) owning ecx before rhs.
53230:      */
53230:     RegisterID reg = JSC::X86Registers::ecx;
53230:     if (!rhs->isConstant())
53230:         frame.copyDataIntoReg(rhs, reg);
53230:     return reg;
53230: #else
53230:     if (rhs->isConstant())
53230:         return frame.allocReg();
53230:     return frame.copyDataIntoReg(rhs);
53230: #endif
53230: }
53230: 
53230: void
53230: mjit::Compiler::jsop_rsh_const_int(FrameEntry *lhs, FrameEntry *rhs)
53230: {
53230:     RegisterID rhsData = rightRegForShift(rhs);
53230:     RegisterID result = frame.allocReg();
53230:     masm.move(Imm32(lhs->getValue().toInt32()), result);
53230:     masm.rshift32(rhsData, result);
53230: 
53230:     frame.freeReg(rhsData);
53230:     frame.popn(2);
53230:     frame.pushTypedPayload(JSVAL_TYPE_INT32, result);
53230: }
53230: 
53230: void
53230: mjit::Compiler::jsop_rsh_int_int(FrameEntry *lhs, FrameEntry *rhs)
53230: {
53230:     RegisterID rhsData = rightRegForShift(rhs);
53230:     RegisterID lhsData = frame.copyDataIntoReg(lhs);
53230:     masm.rshift32(rhsData, lhsData);
53230:     frame.freeReg(rhsData);
53230:     frame.popn(2);
53230:     frame.pushTypedPayload(JSVAL_TYPE_INT32, lhsData);
53230: }
53230: 
53230: void
53230: mjit::Compiler::jsop_rsh_int_const(FrameEntry *lhs, FrameEntry *rhs)
53230: {
53230:     int32 shiftAmount = rhs->getValue().toInt32();
53230: 
53230:     if (!shiftAmount) {
53230:         frame.pop();
53230:         return;
53230:     }
53230: 
53230:     RegisterID result = frame.copyDataIntoReg(lhs);
53230:     masm.rshift32(Imm32(shiftAmount), result);
53230:     frame.popn(2);
53230:     frame.pushTypedPayload(JSVAL_TYPE_INT32, result);
53230: }
53230: 
53230: void
53230: mjit::Compiler::jsop_rsh_unknown_const(FrameEntry *lhs, FrameEntry *rhs)
53230: {
53230:     int32 shiftAmount = rhs->getValue().toInt32();
53230: 
53230:     RegisterID lhsType = frame.tempRegForType(lhs);
53230:     frame.pinReg(lhsType);
53230:     RegisterID lhsData = frame.copyDataIntoReg(lhs);
53230:     frame.unpinReg(lhsType);
53230: 
53230:     Jump lhsIntGuard = masm.testInt32(Assembler::NotEqual, lhsType);
53230:     stubcc.linkExitDirect(lhsIntGuard, stubcc.masm.label());
53230: 
53230:     Jump lhsDoubleGuard = stubcc.masm.testDouble(Assembler::NotEqual, lhsType);
53230:     frame.loadDouble(lhs, FPRegisters::First, stubcc.masm);
53230:     Jump lhsTruncateGuard = stubcc.masm.branchTruncateDoubleToInt32(FPRegisters::First, lhsData);
53230:     stubcc.crossJump(stubcc.masm.jump(), masm.label());
53230: 
53230:     lhsDoubleGuard.linkTo(stubcc.masm.label(), &stubcc.masm);
53230:     lhsTruncateGuard.linkTo(stubcc.masm.label(), &stubcc.masm);
53230: 
53230:     frame.sync(stubcc.masm, Uses(2));
53230:     stubcc.call(stubs::Rsh);
53230: 
53230:     if (shiftAmount)
53230:         masm.rshift32(Imm32(shiftAmount), lhsData);
53230: 
53230:     frame.popn(2);
53230:     frame.pushTypedPayload(JSVAL_TYPE_INT32, lhsData);
53230: 
53230:     stubcc.rejoin(Changes(1));
53230: }
53230: 
53230: void
53230: mjit::Compiler::jsop_rsh_const_unknown(FrameEntry *lhs, FrameEntry *rhs)
53230: {
53230:     RegisterID rhsData = rightRegForShift(rhs);
53230:     RegisterID rhsType = frame.tempRegForType(rhs);
53230:     frame.pinReg(rhsType);
53230:     RegisterID result = frame.allocReg();
53230:     frame.unpinReg(rhsType);
53230: 
53230:     Jump rhsIntGuard = masm.testInt32(Assembler::NotEqual, rhsType);
53230:     stubcc.linkExit(rhsIntGuard, Uses(2));
53230:     stubcc.leave();
53230:     stubcc.call(stubs::Rsh);
53230:     masm.move(Imm32(lhs->getValue().toInt32()), result);
53230:     masm.rshift32(rhsData, result);
53230:     frame.freeReg(rhsData);
53230: 
53230:     frame.popn(2);
53230:     frame.pushTypedPayload(JSVAL_TYPE_INT32, result);
53230:     stubcc.rejoin(Changes(1));
53230: }
53230: 
53230: void
53230: mjit::Compiler::jsop_rsh_int_unknown(FrameEntry *lhs, FrameEntry *rhs)
53230: {
53230:     RegisterID rhsData = rightRegForShift(rhs);
53230:     RegisterID rhsType = frame.tempRegForType(rhs);
53230:     frame.pinReg(rhsType);
53230:     RegisterID lhsData = frame.copyDataIntoReg(lhs);
53230:     frame.unpinReg(rhsType);
53230: 
53230:     Jump rhsIntGuard = masm.testInt32(Assembler::NotEqual, rhsType);
53230:     stubcc.linkExit(rhsIntGuard, Uses(2));
53230:     stubcc.leave();
53230:     stubcc.call(stubs::Rsh);
53230: 
53230:     masm.rshift32(rhsData, lhsData);
53230:     frame.freeReg(rhsData);
53230:     frame.popn(2);
53230:     frame.pushTypedPayload(JSVAL_TYPE_INT32, lhsData);
53230: 
53230:     stubcc.rejoin(Changes(1));
53230: }
53230: 
53230: void
53238: mjit::Compiler::jsop_rsh_unknown_any(FrameEntry *lhs, FrameEntry *rhs)
53230: {
53854:     JS_ASSERT(!lhs->isTypeKnown());
53854:     JS_ASSERT(!rhs->isNotType(JSVAL_TYPE_INT32));
53854: 
53854:     /* Allocate registers. */
53602:     RegisterID rhsData = rightRegForShift(rhs);
53600: 
53602:     MaybeRegisterID rhsType;
53854:     if (!rhs->isTypeKnown()) {
53602:         rhsType.setReg(frame.tempRegForType(rhs));
53602:         frame.pinReg(rhsType.reg());
53602:     }
53238: 
53230:     RegisterID lhsData = frame.copyDataIntoReg(lhs);
54751:     MaybeRegisterID lhsType;
54751:     if (rhsType.isSet() && frame.haveSameBacking(lhs, rhs))
54751:         lhsType = rhsType;
54751:     else
54751:         lhsType = frame.tempRegForType(lhs);
53854: 
53854:     /* Non-integer rhs jumps to stub. */
53854:     MaybeJump rhsIntGuard;
53854:     if (rhsType.isSet()) {
53854:         rhsIntGuard.setJump(masm.testInt32(Assembler::NotEqual, rhsType.reg()));
53602:         frame.unpinReg(rhsType.reg());
53854:     }
53230: 
53854:     /* Non-integer lhs jumps to double guard. */
54751:     Jump lhsIntGuard = masm.testInt32(Assembler::NotEqual, lhsType.reg());
53230:     stubcc.linkExitDirect(lhsIntGuard, stubcc.masm.label());
53230: 
53854:     /* Attempt to convert lhs double to int32. */
54751:     Jump lhsDoubleGuard = stubcc.masm.testDouble(Assembler::NotEqual, lhsType.reg());
53230:     frame.loadDouble(lhs, FPRegisters::First, stubcc.masm);
53230:     Jump lhsTruncateGuard = stubcc.masm.branchTruncateDoubleToInt32(FPRegisters::First, lhsData);
53230:     stubcc.crossJump(stubcc.masm.jump(), masm.label());
53230: 
53230:     lhsDoubleGuard.linkTo(stubcc.masm.label(), &stubcc.masm);
53230:     lhsTruncateGuard.linkTo(stubcc.masm.label(), &stubcc.masm);
53230: 
53602:     if (rhsIntGuard.isSet())
53602:         stubcc.linkExitDirect(rhsIntGuard.getJump(), stubcc.masm.label());
53230:     frame.sync(stubcc.masm, Uses(2));
53230:     stubcc.call(stubs::Rsh);
53230: 
53230:     masm.rshift32(rhsData, lhsData);
53854: 
53230:     frame.freeReg(rhsData);
53230:     frame.popn(2);
53230:     frame.pushTypedPayload(JSVAL_TYPE_INT32, lhsData);
53230: 
53230:     stubcc.rejoin(Changes(1));
53230: }
53230: 
53230: void
53230: mjit::Compiler::jsop_rsh()
53230: {
53230:     FrameEntry *rhs = frame.peek(-1);
53230:     FrameEntry *lhs = frame.peek(-2);
53230: 
53318:     if (tryBinaryConstantFold(cx, frame, JSOP_RSH, lhs, rhs))
53318:         return;
53318: 
53230:     if (lhs->isNotType(JSVAL_TYPE_INT32) || rhs->isNotType(JSVAL_TYPE_INT32)) {
53230:         prepareStubCall(Uses(2));
53230:         stubCall(stubs::Rsh);
53230:         frame.popn(2);
53230:         frame.pushSyncedType(JSVAL_TYPE_INT32);
53230:         return;
53230:     }
53230: 
53318:     JS_ASSERT(!(lhs->isConstant() && rhs->isConstant()));
53318:     if (lhs->isConstant()) {
53230:         if (rhs->isType(JSVAL_TYPE_INT32))
53230:             jsop_rsh_const_int(lhs, rhs);
53230:         else
53230:             jsop_rsh_const_unknown(lhs, rhs);
53230:     } else if (rhs->isConstant()) {
53230:         if (lhs->isType(JSVAL_TYPE_INT32))
53230:             jsop_rsh_int_const(lhs, rhs);
53230:         else
53230:             jsop_rsh_unknown_const(lhs, rhs);
53230:     } else {
53230:         if (lhs->isType(JSVAL_TYPE_INT32) && rhs->isType(JSVAL_TYPE_INT32))
53230:             jsop_rsh_int_int(lhs, rhs);
53230:         else if (lhs->isType(JSVAL_TYPE_INT32))
53230:             jsop_rsh_int_unknown(lhs, rhs);
53230:         else
53238:             jsop_rsh_unknown_any(lhs, rhs);
53230:     }
53230: }
53230: 
52560: void
52724: mjit::Compiler::jsop_bitnot()
52724: {
52724:     FrameEntry *top = frame.peek(-1);
52724: 
52724:     /* We only want to handle integers here. */
53025:     if (top->isTypeKnown() && top->getKnownType() != JSVAL_TYPE_INT32) {
53087:         prepareStubCall(Uses(1));
53087:         stubCall(stubs::BitNot);
52724:         frame.pop();
53025:         frame.pushSyncedType(JSVAL_TYPE_INT32);
52724:         return;
52724:     }
52724:            
52724:     /* Test the type. */
52724:     bool stubNeeded = false;
52724:     if (!top->isTypeKnown()) {
52824:         Jump intFail = frame.testInt32(Assembler::NotEqual, top);
53088:         stubcc.linkExit(intFail, Uses(1));
53025:         frame.learnType(top, JSVAL_TYPE_INT32);
52724:         stubNeeded = true;
52724:     }
52724: 
52724:     if (stubNeeded) {
52724:         stubcc.leave();
52724:         stubcc.call(stubs::BitNot);
52724:     }
52724: 
52724:     RegisterID reg = frame.ownRegForData(top);
52724:     masm.not32(reg);
52724:     frame.pop();
53025:     frame.pushTypedPayload(JSVAL_TYPE_INT32, reg);
52724: 
52724:     if (stubNeeded)
53088:         stubcc.rejoin(Changes(1));
52724: }
52724: 
52724: void
52617: mjit::Compiler::jsop_bitop(JSOp op)
52617: {
52617:     FrameEntry *rhs = frame.peek(-1);
52617:     FrameEntry *lhs = frame.peek(-2);
52617: 
52685:     VoidStub stub;
52685:     switch (op) {
52721:       case JSOP_BITOR:
52721:         stub = stubs::BitOr;
52721:         break;
52685:       case JSOP_BITAND:
52685:         stub = stubs::BitAnd;
52685:         break;
52718:       case JSOP_BITXOR:
52718:         stub = stubs::BitXor;
52718:         break;
52685:       case JSOP_LSH:
52685:         stub = stubs::Lsh;
52685:         break;
53581:       case JSOP_URSH:
53581:         stub = stubs::Ursh;
53581:         break;
52685:       default:
52685:         JS_NOT_REACHED("wat");
52722:         return;
52685:     }
52685: 
53613:     bool lhsIntOrDouble = !(lhs->isNotType(JSVAL_TYPE_DOUBLE) && 
53613:                             lhs->isNotType(JSVAL_TYPE_INT32));
53613:     
53613:     /* Fast-path double to int conversion. */
53613:     if (!lhs->isConstant() && rhs->isConstant() && lhsIntOrDouble &&
53613:         rhs->isType(JSVAL_TYPE_INT32) && rhs->getValue().toInt32() == 0 &&
53613:         (op == JSOP_BITOR || op == JSOP_LSH)) {
53613:         RegisterID reg = frame.copyDataIntoReg(lhs);
53613:         if (lhs->isType(JSVAL_TYPE_INT32)) {
53613:             frame.popn(2);
53613:             frame.pushTypedPayload(JSVAL_TYPE_INT32, reg);
53613:             return;
53613:         }
53613:         MaybeJump isInt;
53613:         if (!lhs->isType(JSVAL_TYPE_DOUBLE)) {
53613:             RegisterID typeReg = frame.tempRegForType(lhs);
53613:             isInt = masm.testInt32(Assembler::Equal, typeReg);
53613:             Jump notDouble = masm.testDouble(Assembler::NotEqual, typeReg);
53613:             stubcc.linkExit(notDouble, Uses(2));
53613:         }
53613:         frame.loadDouble(lhs, FPRegisters::First, masm);
53613:         
53613:         Jump truncateGuard = masm.branchTruncateDoubleToInt32(FPRegisters::First, reg);
53613:         stubcc.linkExit(truncateGuard, Uses(2));
53613:         stubcc.leave();
53613:         stubcc.call(stub);
53613:         
53613:         if (isInt.isSet())
53613:             isInt.get().linkTo(masm.label(), &masm);
53613:         frame.popn(2);
53613:         frame.pushTypedPayload(JSVAL_TYPE_INT32, reg);
53613:         stubcc.rejoin(Changes(1));
53613:         return;
53613:     }
53613: 
52617:     /* We only want to handle integers here. */
53581:     if (rhs->isNotType(JSVAL_TYPE_INT32) || lhs->isNotType(JSVAL_TYPE_INT32) || 
53581:         (op == JSOP_URSH && rhs->isConstant() && rhs->getValue().toInt32() % 32 == 0)) {
53087:         prepareStubCall(Uses(2));
53087:         stubCall(stub);
52617:         frame.popn(2);
53581:         if (op == JSOP_URSH)
53581:             frame.pushSynced();
53581:         else
53025:             frame.pushSyncedType(JSVAL_TYPE_INT32);
52617:         return;
52617:     }
52617:            
52617:     /* Test the types. */
52670:     bool stubNeeded = false;
52617:     if (!rhs->isTypeKnown()) {
52824:         Jump rhsFail = frame.testInt32(Assembler::NotEqual, rhs);
53201:         stubcc.linkExit(rhsFail, Uses(2));
53025:         frame.learnType(rhs, JSVAL_TYPE_INT32);
52670:         stubNeeded = true;
52617:     }
53115:     if (!lhs->isTypeKnown() && !frame.haveSameBacking(lhs, rhs)) {
52824:         Jump lhsFail = frame.testInt32(Assembler::NotEqual, lhs);
53201:         stubcc.linkExit(lhsFail, Uses(2));
52670:         stubNeeded = true;
52617:     }
52617: 
52620:     if (lhs->isConstant() && rhs->isConstant()) {
53081:         int32 L = lhs->getValue().toInt32();
53081:         int32 R = rhs->getValue().toInt32();
52620: 
52620:         frame.popn(2);
52620:         switch (op) {
52721:           case JSOP_BITOR:
53081:             frame.push(Int32Value(L | R));
52840:             return;
52718:           case JSOP_BITXOR:
53081:             frame.push(Int32Value(L ^ R));
52840:             return;
52620:           case JSOP_BITAND:
53081:             frame.push(Int32Value(L & R));
52620:             return;
52685:           case JSOP_LSH:
53081:             frame.push(Int32Value(L << R));
52685:             return;
53581:           case JSOP_URSH: 
53581:           {
53581:             uint32 unsignedL;
53581:             if (ValueToECMAUint32(cx, lhs->getValue(), (uint32_t*)&unsignedL)) {
53581:                 frame.push(NumberValue(uint32(unsignedL >> (R & 31))));
53581:                 return;
53581:             }
53581:             break;
53581:           }
52620:           default:
52620:             JS_NOT_REACHED("say wat");
52620:         }
52617:     }
52617: 
52620:     RegisterID reg;
52620: 
52620:     switch (op) {
52721:       case JSOP_BITOR:
52718:       case JSOP_BITXOR:
52620:       case JSOP_BITAND:
52620:       {
52620:         /* Commutative, and we're guaranteed both are ints. */
52620:         if (lhs->isConstant()) {
52620:             JS_ASSERT(!rhs->isConstant());
52620:             FrameEntry *temp = rhs;
52620:             rhs = lhs;
52620:             lhs = temp;
52620:         }
52620: 
52620:         reg = frame.ownRegForData(lhs);
52620:         if (rhs->isConstant()) {
52718:             if (op == JSOP_BITAND)
53081:                 masm.and32(Imm32(rhs->getValue().toInt32()), reg);
52718:             else if (op == JSOP_BITXOR)
53081:                 masm.xor32(Imm32(rhs->getValue().toInt32()), reg);
52721:             else
53081:                 masm.or32(Imm32(rhs->getValue().toInt32()), reg);
52620:         } else if (frame.shouldAvoidDataRemat(rhs)) {
52718:             if (op == JSOP_BITAND)
52620:                 masm.and32(masm.payloadOf(frame.addressOf(rhs)), reg);
52718:             else if (op == JSOP_BITXOR)
52718:                 masm.xor32(masm.payloadOf(frame.addressOf(rhs)), reg);
52721:             else
52721:                 masm.or32(masm.payloadOf(frame.addressOf(rhs)), reg);
52620:         } else {
52620:             RegisterID rhsReg = frame.tempRegForData(rhs);
52718:             if (op == JSOP_BITAND)
52620:                 masm.and32(rhsReg, reg);
52718:             else if (op == JSOP_BITXOR)
52718:                 masm.xor32(rhsReg, reg);
52721:             else
52721:                 masm.or32(rhsReg, reg);
52620:         }
52620: 
52620:         break;
52620:       }
52620: 
52685:       case JSOP_LSH:
53581:       case JSOP_URSH:
52685:       {
52685:         /* Not commutative. */
52685:         if (rhs->isConstant()) {
53230:             RegisterID reg = frame.ownRegForData(lhs);
53230:             int shift = rhs->getValue().toInt32() & 0x1F;
52783: 
53581:             if (shift) {
53581:                 if (op == JSOP_LSH)
52685:                     masm.lshift32(Imm32(shift), reg);
53581:                 else
53581:                     masm.urshift32(Imm32(shift), reg);
53581:             }
53581:             if (stubNeeded) {
53581:                 stubcc.leave();
53581:                 stubcc.call(stub);
53581:             }
53581:             frame.popn(2);
53230:             
53581:             /* x >>> 0 may result in a double, handled above. */
53581:             JS_ASSERT_IF(op == JSOP_URSH, shift >= 1);
53230:             frame.pushTypedPayload(JSVAL_TYPE_INT32, reg);
53258: 
53258:             if (stubNeeded)
53258:                 stubcc.rejoin(Changes(1));
53258: 
53230:             return;
52685:         }
52685: #if defined(JS_CPU_X86) || defined(JS_CPU_X64)
52685:         /* Grosssssss! RHS _must_ be in ECX, on x86 */
53230:         RegisterID rr = frame.tempRegInMaskForData(rhs,
53230:                                                    Registers::maskReg(JSC::X86Registers::ecx));
52685: #else
52685:         RegisterID rr = frame.tempRegForData(rhs);
52685: #endif
52685: 
55486:         if (lhs->isConstant()) {
52685:             frame.pinReg(rr);
52685:             reg = frame.allocReg();
53081:             masm.move(Imm32(lhs->getValue().toInt32()), reg);
55486:             frame.unpinReg(rr);
52685:         } else {
53581:             reg = frame.copyDataIntoReg(lhs);
52685:         }
52685:         
53581:         if (op == JSOP_LSH) {
52685:             masm.lshift32(rr, reg);
53581:         } else {
53581:             masm.urshift32(rr, reg);
53581:             
53581:             Jump isNegative = masm.branch32(Assembler::LessThan, reg, Imm32(0));
53581:             stubcc.linkExit(isNegative, Uses(2));
53581:             stubNeeded = true;
53581:         }
52685:         break;
52685:       }
52685: 
52620:       default:
52620:         JS_NOT_REACHED("NYI");
52620:         return;
52620:     }
52620: 
53581:     if (stubNeeded) {
53581:         stubcc.leave();
53581:         stubcc.call(stub);
53581:     }
53581: 
52620:     frame.pop();
52620:     frame.pop();
53581: 
53581:     if (op == JSOP_URSH)
53581:         frame.pushNumber(reg, true);
53581:     else
53025:         frame.pushTypedPayload(JSVAL_TYPE_INT32, reg);
52620: 
52670:     if (stubNeeded)
53088:         stubcc.rejoin(Changes(1));
52620: }
52620: 
52623: void
52623: mjit::Compiler::jsop_globalinc(JSOp op, uint32 index)
52623: {
52623:     uint32 slot = script->getGlobalSlot(index);
52623: 
52623:     bool popped = false;
52623:     PC += JSOP_GLOBALINC_LENGTH;
52623:     if (JSOp(*PC) == JSOP_POP && !analysis[PC].nincoming) {
52623:         popped = true;
52623:         PC += JSOP_POP_LENGTH;
52623:     }
52623: 
52623:     int amt = (js_CodeSpec[op].format & JOF_INC) ? 1 : -1;
52623:     bool post = !!(js_CodeSpec[op].format & JOF_POST);
52623: 
52623:     RegisterID data;
52623:     RegisterID reg = frame.allocReg();
52623:     Address addr = masm.objSlotRef(globalObj, reg, slot);
52804:     uint32 depth = frame.stackDepth();
52623: 
52623:     if (post && !popped) {
52623:         frame.push(addr);
52623:         FrameEntry *fe = frame.peek(-1);
52623:         Jump notInt = frame.testInt32(Assembler::NotEqual, fe);
53088:         stubcc.linkExit(notInt, Uses(0));
52846:         data = frame.copyDataIntoReg(fe);
52623:     } else {
52623:         Jump notInt = masm.testInt32(Assembler::NotEqual, addr);
53088:         stubcc.linkExit(notInt, Uses(0));
52623:         data = frame.allocReg();
53144:         masm.loadPayload(addr, data);
52623:     }
52623: 
52623:     Jump ovf;
52623:     if (amt > 0)
52623:         ovf = masm.branchAdd32(Assembler::Overflow, Imm32(1), data);
52623:     else
52623:         ovf = masm.branchSub32(Assembler::Overflow, Imm32(1), data);
53088:     stubcc.linkExit(ovf, Uses(0));
52623: 
52623:     stubcc.leave();
52623:     stubcc.masm.lea(addr, Registers::ArgReg1);
52804:     stubcc.vpInc(op, depth);
52623: 
54582: #if defined JS_NUNBOX32
53144:     masm.storePayload(data, addr);
54582: #elif defined JS_PUNBOX64
54582:     masm.storeValueFromComponents(ImmType(JSVAL_TYPE_INT32), data, addr);
54582: #endif
52623: 
52623:     if (!post && !popped)
53200:         frame.pushInt32(data);
52623:     else
52623:         frame.freeReg(data);
52623: 
52623:     frame.freeReg(reg);
52623: 
53088:     stubcc.rejoin(Changes((!post && !popped) ? 1 : 0));
52623: }
52623: 
52842: static inline bool
53025: CheckNullOrUndefined(FrameEntry *fe)
52879: {
52879:     if (!fe->isTypeKnown())
52879:         return false;
53025:     JSValueType type = fe->getKnownType();
53025:     return type == JSVAL_TYPE_NULL || type == JSVAL_TYPE_UNDEFINED;
52879: }
52879: 
52879: void
52879: mjit::Compiler::jsop_equality(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused)
52879: {
52879:     FrameEntry *rhs = frame.peek(-1);
52879:     FrameEntry *lhs = frame.peek(-2);
52879: 
52879:     /* The compiler should have handled constant folding. */
52879:     JS_ASSERT(!(rhs->isConstant() && lhs->isConstant()));
52879: 
52879:     bool lhsTest;
53025:     if ((lhsTest = CheckNullOrUndefined(lhs)) || CheckNullOrUndefined(rhs)) {
52879:         /* What's the other mask? */
52879:         FrameEntry *test = lhsTest ? rhs : lhs;
52879: 
52879:         if (test->isTypeKnown()) {
52879:             emitStubCmpOp(stub, target, fused);
52879:             return;
52879:         }
52879: 
52879:         /* The other side must be null or undefined. */
52879:         RegisterID reg = frame.ownRegForType(test);
52954:         frame.pop();
52954:         frame.pop();
52879: 
52954:         /*
52954:          * :FIXME: Easier test for undefined || null?
52954:          * Maybe put them next to each other, subtract, do a single compare?
52954:          */
52879: 
52879:         if (target) {
54719:             frame.syncAndForgetEverything();
52879: 
52954:             if ((op == JSOP_EQ && fused == JSOP_IFNE) ||
52954:                 (op == JSOP_NE && fused == JSOP_IFEQ)) {
53162:                 Jump j = masm.branchPtr(Assembler::Equal, reg, ImmType(JSVAL_TYPE_UNDEFINED));
53133:                 jumpAndTrace(j, target);
53162:                 j = masm.branchPtr(Assembler::Equal, reg, ImmType(JSVAL_TYPE_NULL));
53133:                 jumpAndTrace(j, target);
52879:             } else {
53162:                 Jump j = masm.branchPtr(Assembler::Equal, reg, ImmType(JSVAL_TYPE_UNDEFINED));
53162:                 Jump j2 = masm.branchPtr(Assembler::NotEqual, reg, ImmType(JSVAL_TYPE_NULL));
53133:                 jumpAndTrace(j2, target);
52954:                 j.linkTo(masm.label(), &masm);
52954:             }
52954:         } else {
53162:             Jump j = masm.branchPtr(Assembler::Equal, reg, ImmType(JSVAL_TYPE_UNDEFINED));
53162:             Jump j2 = masm.branchPtr(Assembler::Equal, reg, ImmType(JSVAL_TYPE_NULL));
52954:             masm.move(Imm32(op == JSOP_NE), reg);
52954:             Jump j3 = masm.jump();
52954:             j2.linkTo(masm.label(), &masm);
52954:             j.linkTo(masm.label(), &masm);
52954:             masm.move(Imm32(op == JSOP_EQ), reg);
52954:             j3.linkTo(masm.label(), &masm);
53025:             frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, reg);
52879:         }
52879:         return;
52879:     }
52879: 
52879:     emitStubCmpOp(stub, target, fused);
52879: }
52879: 
52651: void
52653: mjit::Compiler::jsop_relational(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused)
52651: {
52652:     FrameEntry *rhs = frame.peek(-1);
52652:     FrameEntry *lhs = frame.peek(-2);
52652: 
52653:     /* The compiler should have handled constant folding. */
52653:     JS_ASSERT(!(rhs->isConstant() && lhs->isConstant()));
52653: 
52653:     /* Always slow path... */
54160:     if ((lhs->isNotType(JSVAL_TYPE_INT32) && lhs->isNotType(JSVAL_TYPE_DOUBLE) &&
54160:          lhs->isNotType(JSVAL_TYPE_STRING)) ||
54160:         (rhs->isNotType(JSVAL_TYPE_INT32) && rhs->isNotType(JSVAL_TYPE_DOUBLE) &&
54160:          rhs->isNotType(JSVAL_TYPE_STRING))) {
52879:         if (op == JSOP_EQ || op == JSOP_NE)
52879:             jsop_equality(op, stub, target, fused);
52879:         else
52653:             emitStubCmpOp(stub, target, fused);
52653:         return;
52653:     }
52653: 
53201:     if (op == JSOP_EQ || op == JSOP_NE) {
54160:         if ((lhs->isNotType(JSVAL_TYPE_INT32) && lhs->isNotType(JSVAL_TYPE_STRING)) ||
54160:             (rhs->isNotType(JSVAL_TYPE_INT32) && rhs->isNotType(JSVAL_TYPE_STRING))) {
53212:             emitStubCmpOp(stub, target, fused);
54160:         } else if (!target && (lhs->isType(JSVAL_TYPE_STRING) || rhs->isType(JSVAL_TYPE_STRING))) {
54160:             emitStubCmpOp(stub, target, fused);
54717:         } else if (frame.haveSameBacking(lhs, rhs)) {
54717:             emitStubCmpOp(stub, target, fused);
54160:         } else {
54160:             jsop_equality_int_string(op, stub, target, fused);
54160:         }
52653:         return;
52651:     }
52651: 
53201:     if (frame.haveSameBacking(lhs, rhs)) {
53201:         jsop_relational_self(op, stub, target, fused);
54160:     } else if (lhs->isType(JSVAL_TYPE_STRING) || rhs->isType(JSVAL_TYPE_STRING)) {
54160:         emitStubCmpOp(stub, target, fused);
53201:     } else if (lhs->isType(JSVAL_TYPE_DOUBLE) || rhs->isType(JSVAL_TYPE_DOUBLE)) {
53201:         jsop_relational_double(op, stub, target, fused);
52653:     } else {
53201:         jsop_relational_full(op, stub, target, fused);
52653:     }
52653: }
52653: 
52713: void
52734: mjit::Compiler::jsop_not()
52734: {
52734:     FrameEntry *top = frame.peek(-1);
52734: 
52734:     if (top->isConstant()) {
52734:         const Value &v = top->getValue();
52734:         frame.pop();
53081:         frame.push(BooleanValue(!js_ValueToBoolean(v)));
52734:         return;
52734:     }
52734: 
52734:     if (top->isTypeKnown()) {
53025:         JSValueType type = top->getKnownType();
53025:         switch (type) {
53025:           case JSVAL_TYPE_INT32:
52975:           {
52975:             RegisterID data = frame.allocReg(Registers::SingleByteRegs);
52975:             if (frame.shouldAvoidDataRemat(top))
53144:                 masm.loadPayload(frame.addressOf(top), data);
52975:             else
52975:                 masm.move(frame.tempRegForData(top), data);
52975: 
52975:             masm.set32(Assembler::Equal, data, Imm32(0), data);
52975: 
52975:             frame.pop();
53025:             frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, data);
52975:             break;
52975:           }
52975: 
53025:           case JSVAL_TYPE_BOOLEAN:
52734:           {
52734:             RegisterID reg = frame.ownRegForData(top);
52975: 
52975:             masm.xor32(Imm32(1), reg);
52975: 
52734:             frame.pop();
53025:             frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, reg);
52734:             break;
52734:           }
52734: 
53025:           case JSVAL_TYPE_OBJECT:
52734:           {
52734:             frame.pop();
53081:             frame.push(BooleanValue(false));
52734:             break;
52734:           }
52734: 
52734:           default:
52734:           {
53087:             prepareStubCall(Uses(1));
53087:             stubCall(stubs::ValueToBoolean);
52975: 
52975:             RegisterID reg = Registers::ReturnReg;
52734:             frame.takeReg(reg);
52975:             masm.xor32(Imm32(1), reg);
52975: 
52734:             frame.pop();
53025:             frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, reg);
52734:             break;
52734:           }
52734:         }
52734: 
52734:         return;
52734:     }
52734: 
52956:     RegisterID data = frame.allocReg(Registers::SingleByteRegs);
52956:     if (frame.shouldAvoidDataRemat(top))
53144:         masm.loadPayload(frame.addressOf(top), data);
52956:     else
52956:         masm.move(frame.tempRegForData(top), data);
52956:     RegisterID type = frame.tempRegForType(top);
53088:     Label syncTarget = stubcc.syncExitAndJump(Uses(1));
52734: 
52975: 
52975:     /* Inline path is for booleans. */
52975:     Jump jmpNotBool = masm.testBoolean(Assembler::NotEqual, type);
52975:     masm.xor32(Imm32(1), data);
52975: 
52975: 
52975:     /* OOL path is for int + object. */
52975:     Label lblMaybeInt32 = stubcc.masm.label();
52975: 
52975:     Jump jmpNotInt32 = stubcc.masm.testInt32(Assembler::NotEqual, type);
52975:     stubcc.masm.set32(Assembler::Equal, data, Imm32(0), data);
52975:     Jump jmpInt32Exit = stubcc.masm.jump();
52975: 
52975:     Label lblMaybeObject = stubcc.masm.label();
52975:     Jump jmpNotObject = stubcc.masm.testPrimitive(Assembler::Equal, type);
52975:     stubcc.masm.move(Imm32(0), data);
52975:     Jump jmpObjectExit = stubcc.masm.jump();
52975: 
52975: 
52975:     /* Rejoin location. */
52975:     Label lblRejoin = masm.label();
52975: 
52975:     /* Patch up jumps. */
52975:     stubcc.linkExitDirect(jmpNotBool, lblMaybeInt32);
52975: 
52975:     jmpNotInt32.linkTo(lblMaybeObject, &stubcc.masm);
52975:     stubcc.crossJump(jmpInt32Exit, lblRejoin);
52975: 
52975:     jmpNotObject.linkTo(syncTarget, &stubcc.masm);
52975:     stubcc.crossJump(jmpObjectExit, lblRejoin);
52975:     
52975: 
52975:     /* Leave. */
52734:     stubcc.leave();
52734:     stubcc.call(stubs::Not);
52734: 
52734:     frame.pop();
53025:     frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, data);
52734: 
53088:     stubcc.rejoin(Changes(1));
52734: }
52734: 
52738: void
52738: mjit::Compiler::jsop_typeof()
52738: {
52738:     FrameEntry *fe = frame.peek(-1);
52738: 
52738:     if (fe->isTypeKnown()) {
52738:         JSRuntime *rt = cx->runtime;
52738: 
52738:         JSAtom *atom = NULL;
53025:         switch (fe->getKnownType()) {
53025:           case JSVAL_TYPE_STRING:
52738:             atom = rt->atomState.typeAtoms[JSTYPE_STRING];
52738:             break;
53025:           case JSVAL_TYPE_UNDEFINED:
52738:             atom = rt->atomState.typeAtoms[JSTYPE_VOID];
52738:             break;
53025:           case JSVAL_TYPE_NULL:
52738:             atom = rt->atomState.typeAtoms[JSTYPE_OBJECT];
52738:             break;
53025:           case JSVAL_TYPE_OBJECT:
52738:             atom = NULL;
52738:             break;
53025:           case JSVAL_TYPE_BOOLEAN:
52738:             atom = rt->atomState.typeAtoms[JSTYPE_BOOLEAN];
52738:             break;
52738:           default:
52738:             atom = rt->atomState.typeAtoms[JSTYPE_NUMBER];
52738:             break;
52738:         }
52738: 
52738:         if (atom) {
52738:             frame.pop();
53081:             frame.push(StringValue(ATOM_TO_STRING(atom)));
52738:             return;
52738:         }
52738:     }
52738: 
53087:     prepareStubCall(Uses(1));
53087:     stubCall(stubs::TypeOf);
52738:     frame.pop();
52738:     frame.takeReg(Registers::ReturnReg);
53025:     frame.pushTypedPayload(JSVAL_TYPE_STRING, Registers::ReturnReg);
52738: }
52738: 
52804: void
53102: mjit::Compiler::booleanJumpScript(JSOp op, jsbytecode *target)
53086: {
53086:     FrameEntry *fe = frame.peek(-1);
53086: 
53086:     MaybeRegisterID type;
53086:     MaybeRegisterID data;
53086: 
53185:     if (!fe->isTypeKnown() && !frame.shouldAvoidTypeRemat(fe))
53185:         type.setReg(frame.copyTypeIntoReg(fe));
53185:     data.setReg(frame.copyDataIntoReg(fe));
53086: 
54719:     frame.syncAndForgetEverything();
53086: 
53102:     Assembler::Condition cond = (op == JSOP_IFNE || op == JSOP_OR)
53086:                                 ? Assembler::NonZero
53086:                                 : Assembler::Zero;
53102:     Assembler::Condition ncond = (op == JSOP_IFNE || op == JSOP_OR)
53086:                                  ? Assembler::Zero
53086:                                  : Assembler::NonZero;
53086: 
53086:     /* Inline path: Boolean guard + call script. */
53086:     MaybeJump jmpNotBool;
53086:     MaybeJump jmpNotExecScript;
53086:     if (type.isSet()) {
53152:         jmpNotBool.setJump(masm.testBoolean(Assembler::NotEqual, type.reg()));
53086:     } else {
53086:         if (!fe->isTypeKnown()) {
53086:             jmpNotBool.setJump(masm.testBoolean(Assembler::NotEqual,
53086:                                                 frame.addressOf(fe)));
53204:         } else if (fe->isNotType(JSVAL_TYPE_BOOLEAN) &&
53204:                    fe->isNotType(JSVAL_TYPE_INT32)) {
53086:             jmpNotBool.setJump(masm.jump());
53086:         }
53086:     }
53086: 
53086:     /* 
53086:      * TODO: We don't need the second jump if
53086:      * jumpInScript() can go from ool path to inline path.
53086:      */
53152:     jmpNotExecScript.setJump(masm.branchTest32(ncond, data.reg(), data.reg()));
53086:     Label lblExecScript = masm.label();
53086:     Jump j = masm.jump();
53086: 
53086: 
53086:     /* OOL path: Conversion to boolean. */
53086:     MaybeJump jmpCvtExecScript;
53086:     MaybeJump jmpCvtRejoin;
53086:     Label lblCvtPath = stubcc.masm.label();
53086: 
53204:     if (!fe->isTypeKnown() ||
53204:         !(fe->isType(JSVAL_TYPE_BOOLEAN) || fe->isType(JSVAL_TYPE_INT32))) {
53086:         stubcc.masm.fixScriptStack(frame.frameDepth());
53086:         stubcc.masm.setupVMFrame();
53326: #if defined(JS_NO_FASTCALL) && defined(JS_CPU_X86)
53326:         stubcc.masm.push(Registers::ArgReg0);
53326: #endif
53086:         stubcc.masm.call(JS_FUNC_TO_DATA_PTR(void *, stubs::ValueToBoolean));
53326: #if defined(JS_NO_FASTCALL) && defined(JS_CPU_X86)
53326:         stubcc.masm.pop();
53326: #endif
53086: 
53086:         jmpCvtExecScript.setJump(stubcc.masm.branchTest32(cond, Registers::ReturnReg,
53086:                                                           Registers::ReturnReg));
53086:         jmpCvtRejoin.setJump(stubcc.masm.jump());
53086:     }
53086: 
53086:     /* Rejoin tag. */
53086:     Label lblAfterScript = masm.label();
53086: 
53086:     /* Patch up jumps. */
53086:     if (jmpNotBool.isSet())
53086:         stubcc.linkExitDirect(jmpNotBool.getJump(), lblCvtPath);
53086:     if (jmpNotExecScript.isSet())
53086:         jmpNotExecScript.getJump().linkTo(lblAfterScript, &masm);
53086: 
53086:     if (jmpCvtExecScript.isSet())
53086:         stubcc.crossJump(jmpCvtExecScript.getJump(), lblExecScript);
53086:     if (jmpCvtRejoin.isSet())
53086:         stubcc.crossJump(jmpCvtRejoin.getJump(), lblAfterScript);
53086: 
53086:     frame.pop();
53133: 
53133:     jumpAndTrace(j, target);
53086: }
53086: 
53086: void
53102: mjit::Compiler::jsop_ifneq(JSOp op, jsbytecode *target)
53102: {
53102:     FrameEntry *fe = frame.peek(-1);
53102: 
53102:     if (fe->isConstant()) {
53102:         JSBool b = js_ValueToBoolean(fe->getValue());
53102: 
53133:         frame.pop();
53133: 
53102:         if (op == JSOP_IFEQ)
53102:             b = !b;
53102:         if (b) {
54719:             frame.syncAndForgetEverything();
53133:             jumpAndTrace(masm.jump(), target);
53102:         }
53102:         return;
53102:     }
53102: 
53102:     booleanJumpScript(op, target);
53102: }
53102: 
53102: void
53102: mjit::Compiler::jsop_andor(JSOp op, jsbytecode *target)
53102: {
53102:     FrameEntry *fe = frame.peek(-1);
53102: 
53102:     if (fe->isConstant()) {
53102:         JSBool b = js_ValueToBoolean(fe->getValue());
53102:         
53102:         /* Short-circuit. */
53102:         if ((op == JSOP_OR && b == JS_TRUE) ||
53102:             (op == JSOP_AND && b == JS_FALSE)) {
54719:             frame.syncAndForgetEverything();
53133:             jumpAndTrace(masm.jump(), target);
53102:         }
53102: 
53102:         frame.pop();
53102:         return;
53102:     }
53102: 
53102:     booleanJumpScript(op, target);
53102: }
53102: 
53102: void
52808: mjit::Compiler::jsop_localinc(JSOp op, uint32 slot, bool popped)
52808: {
52808:     bool post = (op == JSOP_LOCALINC || op == JSOP_LOCALDEC);
52808:     int32 amt = (op == JSOP_INCLOCAL || op == JSOP_LOCALINC) ? 1 : -1;
52808: 
52808:     frame.pushLocal(slot);
52808: 
52808:     FrameEntry *fe = frame.peek(-1);
52808: 
52808:     if (fe->isConstant() && fe->getValue().isPrimitive()) {
52808:         Value v = fe->getValue();
52808:         double d;
52808:         ValueToNumber(cx, v, &d);
53237:         if (post) {
53237:             frame.push(NumberValue(d + amt));
52808:             frame.storeLocal(slot);
52808:             frame.pop();
53237:         } else {
53237:             frame.pop();
53237:             frame.push(NumberValue(d + amt));
53237:             frame.storeLocal(slot);
53237:         }
53237:         if (popped)
53237:             frame.pop();
52808:         return;
52808:     }
52808: 
53346:     /*
53346:      * If the local variable is not known to be an int32, or the pre-value
53346:      * is observed, then do the simple thing and decompose x++ into simpler
53346:      * opcodes.
53346:      */
53346:     if (fe->isNotType(JSVAL_TYPE_INT32) || (post && !popped)) {
53346:         /* V */
53346:         jsop_pos();
53346:         /* N */
53346: 
52808:         if (post && !popped) {
52808:             frame.dup();
53346:             /* N N */
52808:         }
52808: 
53346:         frame.push(Int32Value(1));
53346:         /* N? N 1 */
53346: 
53346:         if (amt == 1)
53346:             jsop_binary(JSOP_ADD, stubs::Add);
53346:         else
53346:             jsop_binary(JSOP_SUB, stubs::Sub);
53346:         /* N? N+1 */
53346: 
53346:         frame.storeLocal(slot, post || popped);
53346:         /* N? N+1 */
53346: 
53346:         if (post || popped)
53346:             frame.pop();
53346: 
53346:         return;
53346:     }
53346: 
53346:     /* If the pre value is not observed, we can emit better code. */
53346:     if (!fe->isTypeKnown()) {
52808:         Jump intFail = frame.testInt32(Assembler::NotEqual, fe);
53346:         stubcc.linkExit(intFail, Uses(1));
52808:     }
52808: 
53345:     RegisterID reg = frame.copyDataIntoReg(fe);
52808: 
52808:     Jump ovf;
52808:     if (amt > 0)
52808:         ovf = masm.branchAdd32(Assembler::Overflow, Imm32(1), reg);
52808:     else
52808:         ovf = masm.branchSub32(Assembler::Overflow, Imm32(1), reg);
53346:     stubcc.linkExit(ovf, Uses(1));
52808: 
53346:     /* Note, stub call will push the original value again no matter what. */
52808:     stubcc.leave();
52808: 
53345:     stubcc.masm.move(Imm32(slot), Registers::ArgReg1);
53345:     if (op == JSOP_LOCALINC || op == JSOP_INCLOCAL)
53345:         stubcc.call(stubs::IncLocal);
53345:     else
53345:         stubcc.call(stubs::DecLocal);
53345: 
53345:     frame.pop();
53181:     frame.pushTypedPayload(JSVAL_TYPE_INT32, reg);
53346:     frame.storeLocal(slot, popped, false);
52808: 
53346:     if (popped)
52808:         frame.pop();
53346:     else
53181:         frame.forgetType(frame.peek(-1));
52808: 
53346:     stubcc.rejoin(Changes(0));
52808: }
52808: 
52808: void
52804: mjit::Compiler::jsop_arginc(JSOp op, uint32 slot, bool popped)
52804: {
52804:     int amt = (js_CodeSpec[op].format & JOF_INC) ? 1 : -1;
52804:     bool post = !!(js_CodeSpec[op].format & JOF_POST);
52804:     uint32 depth = frame.stackDepth();
52804: 
52804:     jsop_getarg(slot);
52804:     if (post && !popped)
52804:         frame.dup();
52804: 
52804:     FrameEntry *fe = frame.peek(-1);
52804:     Jump notInt = frame.testInt32(Assembler::NotEqual, fe);
53088:     stubcc.linkExit(notInt, Uses(0));
52804: 
52804:     RegisterID reg = frame.ownRegForData(fe);
52804:     frame.pop();
52804: 
52804:     Jump ovf;
52804:     if (amt > 0)
52804:         ovf = masm.branchAdd32(Assembler::Overflow, Imm32(1), reg);
52804:     else
52804:         ovf = masm.branchSub32(Assembler::Overflow, Imm32(1), reg);
53088:     stubcc.linkExit(ovf, Uses(0));
52804: 
52804:     stubcc.leave();
53840:     stubcc.masm.addPtr(Imm32(JSStackFrame::offsetOfFormalArg(fun, slot)),
53840:                        JSFrameReg, Registers::ArgReg1);
52804:     stubcc.vpInc(op, depth);
52804: 
53025:     frame.pushTypedPayload(JSVAL_TYPE_INT32, reg);
52804:     fe = frame.peek(-1);
52804: 
53840:     Address address = Address(JSFrameReg, JSStackFrame::offsetOfFormalArg(fun, slot));
52804:     frame.storeTo(fe, address, popped);
52804: 
52804:     if (post || popped)
52804:         frame.pop();
52804:     else
52804:         frame.forgetType(fe);
52804: 
53088:     stubcc.rejoin(Changes((post || popped) ? 0 : 1));
52804: }
52804: 
52838: void
52838: mjit::Compiler::jsop_setelem()
52838: {
52838:     FrameEntry *obj = frame.peek(-3);
52838:     FrameEntry *id = frame.peek(-2);
52838:     FrameEntry *fe = frame.peek(-1);
52838: 
53227:     if (obj->isNotType(JSVAL_TYPE_OBJECT) || id->isNotType(JSVAL_TYPE_INT32) ||
53081:         (id->isConstant() && id->getValue().toInt32() < 0)) {
52838:         jsop_setelem_slow();
52838:         return;
52838:     }
52838: 
52838:     /* id.isInt32() */
52838:     if (!id->isTypeKnown()) {
52838:         Jump j = frame.testInt32(Assembler::NotEqual, id);
53088:         stubcc.linkExit(j, Uses(3));
52838:     }
52838: 
53023:     /* obj.isObject() */
52838:     if (!obj->isTypeKnown()) {
53023:         Jump j = frame.testObject(Assembler::NotEqual, obj);
53088:         stubcc.linkExit(j, Uses(3));
52838:     }
52838: 
52838:     /* obj.isDenseArray() */
52846:     RegisterID objReg = frame.copyDataIntoReg(obj);
52838:     Jump guardDense = masm.branchPtr(Assembler::NotEqual,
52838:                                       Address(objReg, offsetof(JSObject, clasp)),
52838:                                       ImmPtr(&js_ArrayClass));
53088:     stubcc.linkExit(guardDense, Uses(3));
52838: 
53227:     /* guard within capacity */
55746:     Address capacity(objReg, offsetof(JSObject, capacity));
53227: 
53227:     Jump inRange;
53227:     MaybeRegisterID maybeIdReg;
53227:     if (id->isConstant()) {
55746:         inRange = masm.branch32(Assembler::LessThanOrEqual, capacity,
53227:                                 Imm32(id->getValue().toInt32()));
53227:     } else {
53227:         maybeIdReg = frame.copyDataIntoReg(id);
55746:         inRange = masm.branch32(Assembler::AboveOrEqual, maybeIdReg.reg(), capacity);
53227:     }
53227:     stubcc.linkExit(inRange, Uses(3));
53227: 
55746:     /* load dslots */
55746:     masm.loadPtr(Address(objReg, offsetof(JSObject, slots)), objReg);
52838: 
52838:     /* guard within capacity */
52838:     if (id->isConstant()) {
52838:         /* guard not a hole */
53081:         Address slot(objReg, id->getValue().toInt32() * sizeof(Value));
53224: #if defined JS_NUNBOX32
53146:         Jump notHole = masm.branch32(Assembler::Equal, masm.tagOf(slot), ImmType(JSVAL_TYPE_MAGIC));
53224: #elif defined JS_PUNBOX64
53162:         masm.loadTypeTag(slot, Registers::ValueReg);
53162:         Jump notHole = masm.branchPtr(Assembler::Equal, Registers::ValueReg, ImmType(JSVAL_TYPE_MAGIC));
53162: #endif
53088:         stubcc.linkExit(notHole, Uses(3));
52838: 
52838:         stubcc.leave();
54169:         stubcc.call(STRICT_VARIANT(stubs::SetElem));
52838: 
52838:         /* Infallible, start killing everything. */
52838:         frame.eviscerate(obj);
52838:         frame.eviscerate(id);
52838: 
52838:         /* Perform the store. */
54582:         frame.storeTo(fe, slot);
52838:     } else {
53227:         RegisterID idReg = maybeIdReg.reg();
52838: 
53228:         /*
53228:          * Register for use only in OOL hole path. TODO: would be nice
53228:          * for the frame to do any associated spilling in the OOL path.
53228:          */
53228:         RegisterID T1 = frame.allocReg();
53228: 
53228:         Label syncTarget = stubcc.syncExitAndJump(Uses(3));
53228: 
52838:         /* guard not a hole */
52838:         BaseIndex slot(objReg, idReg, Assembler::JSVAL_SCALE);
53224: #if defined JS_NUNBOX32
53146:         Jump notHole = masm.branch32(Assembler::Equal, masm.tagOf(slot), ImmType(JSVAL_TYPE_MAGIC));
53224: #elif defined JS_PUNBOX64
53162:         masm.loadTypeTag(slot, Registers::ValueReg);
53162:         Jump notHole = masm.branchPtr(Assembler::Equal, Registers::ValueReg, ImmType(JSVAL_TYPE_MAGIC));
53162: #endif
53228: 
53228:         /* Make an OOL path for setting array holes. */
53228:         Label lblHole = stubcc.masm.label();
53228:         stubcc.linkExitDirect(notHole, lblHole);
53228: 
53228:         /* Need a new handle on the object, as objReg now holds the dslots. */
53228:         RegisterID baseReg = frame.tempRegForData(obj, objReg, stubcc.masm);
53228: 
53228:         /*
53228:          * Check if the object has a prototype with indexed properties,
53228:          * in which case it might have a setter for this element. For dense
53650:          * arrays we need to check only Array.prototype and Object.prototype.
53650:          * Indexed properties are indicated by the JSObject::INDEXED flag.
53228:          */
53228: 
53650:         /* Test for indexed properties in Array.prototype. */
53228:         stubcc.masm.loadPtr(Address(baseReg, offsetof(JSObject, proto)), T1);
53650:         stubcc.masm.loadPtr(Address(T1, offsetof(JSObject, flags)), T1);
53841:         Jump extendedArray = stubcc.masm.branchTest32(Assembler::NonZero, T1, Imm32(JSObject::INDEXED));
53228:         extendedArray.linkTo(syncTarget, &stubcc.masm);
53228: 
53228:         /* Test for indexed properties in Object.prototype. */
53228:         stubcc.masm.loadPtr(Address(baseReg, offsetof(JSObject, proto)), T1);
53228:         stubcc.masm.loadPtr(Address(T1, offsetof(JSObject, proto)), T1);
53650:         stubcc.masm.loadPtr(Address(T1, offsetof(JSObject, flags)), T1);
53841:         Jump extendedObject = stubcc.masm.branchTest32(Assembler::NonZero, T1, Imm32(JSObject::INDEXED));
53228:         extendedObject.linkTo(syncTarget, &stubcc.masm);
53228: 
53228:         /* Update the array length if needed. Don't worry about overflow. */
55746:         Address arrayLength(baseReg, offsetof(JSObject, privateData));
54582:         stubcc.masm.load32(arrayLength, T1);
53228:         Jump underLength = stubcc.masm.branch32(Assembler::LessThan, idReg, T1);
53228:         stubcc.masm.move(idReg, T1);
53228:         stubcc.masm.add32(Imm32(1), T1);
54582:         stubcc.masm.store32(T1, arrayLength);
53228:         underLength.linkTo(stubcc.masm.label(), &stubcc.masm);
53228: 
53228:         /* Restore the dslots register if we clobbered it with the object. */
53228:         if (baseReg == objReg)
55746:             stubcc.masm.loadPtr(Address(objReg, offsetof(JSObject, slots)), objReg);
53228: 
53228:         /* Rejoin OOL path with inline path to do the store itself. */
53228:         Jump jmpHoleExit = stubcc.masm.jump();
53228:         Label lblRejoin = masm.label();
53228:         stubcc.crossJump(jmpHoleExit, lblRejoin);
52838: 
52838:         stubcc.leave();
54169:         stubcc.call(STRICT_VARIANT(stubs::SetElem));
52838: 
52838:         /* Infallible, start killing everything. */
52838:         frame.eviscerate(obj);
52838:         frame.eviscerate(id);
52838: 
52838:         /* Perform the store. */
52838:         if (fe->isConstant()) {
52838:             masm.storeValue(fe->getValue(), slot);
54582:         } else if (fe->isTypeKnown()) {
54582:             masm.storeValueFromComponents(ImmType(fe->getKnownType()),
54582:                                           frame.tempRegForData(fe), slot);
52838:         } else {
54582: #if defined JS_NUNBOX32
54582:             masm.storeTypeTag(frame.tempRegForType(fe), slot);
53144:             masm.storePayload(frame.tempRegForData(fe), slot);
54582: #elif defined JS_PUNBOX64
54582:             RegisterID dreg = frame.tempRegForData(fe);
54582:             frame.pinReg(dreg);
54582:             masm.storeValueFromComponents(frame.tempRegForType(fe), dreg, slot);
54582:             frame.unpinReg(dreg);
54582: #endif
52838:         }
52838: 
52838:         frame.freeReg(idReg);
53228:         frame.freeReg(T1);
52838:     }
52838:     frame.freeReg(objReg);
52838: 
52838:     frame.shimmy(2);
53088:     stubcc.rejoin(Changes(0));
52838: }
52838: 
52843: void
53137: mjit::Compiler::jsop_getelem_dense(FrameEntry *obj, FrameEntry *id, RegisterID objReg,
53137:                                    MaybeRegisterID &idReg, RegisterID tmpReg)
52843: {
53137:     /* Note: idReg is only valid if id is not a constant. */
52843:     Jump guardDense = masm.branchPtr(Assembler::NotEqual,
52843:                                      Address(objReg, offsetof(JSObject, clasp)),
52843:                                      ImmPtr(&js_ArrayClass));
53088:     stubcc.linkExit(guardDense, Uses(2));
52843: 
53227:     /* Guard within capacity. */
53227:     Jump inRange;
55746:     Address capacity(objReg, offsetof(JSObject, capacity));
53227:     if (id->isConstant()) {
55746:         inRange = masm.branch32(Assembler::LessThanOrEqual, capacity,
53227:                                 Imm32(id->getValue().toInt32()));
53227:     } else {
55746:         inRange = masm.branch32(Assembler::AboveOrEqual, idReg.reg(), capacity);
53227:     }
53227:     stubcc.linkExit(inRange, Uses(2));
53227: 
55746:     /* load dslots */
55746:     masm.loadPtr(Address(objReg, offsetof(JSObject, slots)), objReg);
52843: 
52843:     /* guard within capacity */
52843:     if (id->isConstant()) {
52843:         /* guard not a hole */
53081:         Address slot(objReg, id->getValue().toInt32() * sizeof(Value));
53224: #if defined JS_NUNBOX32
54414:         masm.loadTypeTag(slot, tmpReg);
54414:         Jump notHole = masm.branchPtr(Assembler::Equal, tmpReg, ImmType(JSVAL_TYPE_MAGIC));
54414:         masm.loadPayload(slot, objReg);
53224: #elif defined JS_PUNBOX64
54414:         masm.loadValueAsComponents(slot, tmpReg, objReg);
54414:         Jump notHole = masm.branchPtr(Assembler::Equal, tmpReg, ImmType(JSVAL_TYPE_MAGIC));
53162: #endif
53088:         stubcc.linkExit(notHole, Uses(2));
52843:     } else {
52843:         /* guard not a hole */
53152:         BaseIndex slot(objReg, idReg.reg(), Assembler::JSVAL_SCALE);
53224: #if defined JS_NUNBOX32
54414:         masm.loadTypeTag(slot, tmpReg);
54414:         Jump notHole = masm.branchPtr(Assembler::Equal, tmpReg, ImmType(JSVAL_TYPE_MAGIC));
54414:         masm.loadPayload(slot, objReg);
53224: #elif defined JS_PUNBOX64
54414:         masm.loadValueAsComponents(slot, tmpReg, objReg);
54414:         Jump notHole = masm.branchPtr(Assembler::Equal, tmpReg, ImmType(JSVAL_TYPE_MAGIC));
53162: #endif
53088:         stubcc.linkExit(notHole, Uses(2));
53137:     }
53137:     /* Postcondition: type must be in tmpReg, data must be in objReg. */
53137: 
53137:     /* Note: linkExits will be hooked up to a leave() after this method completes. */
53137: }
53137: 
56037: bool
53137: mjit::Compiler::jsop_getelem_known_type(FrameEntry *obj, FrameEntry *id, RegisterID tmpReg)
53137: {
53137:     switch (id->getKnownType()) {
53137:       case JSVAL_TYPE_INT32:
53137:       {
53137:         /* Prologue. */
53137:         RegisterID objReg = frame.copyDataIntoReg(obj);
53137:         MaybeRegisterID idReg;
53137:         if (!id->isConstant())
53137:             idReg.setReg(frame.copyDataIntoReg(id));
53137: 
53137:         /* Meat. */
53137:         jsop_getelem_dense(obj, id, objReg, idReg, tmpReg);
52843:         stubcc.leave();
52843:         stubcc.call(stubs::GetElem);
52843: 
53137:         /* Epilogue. */
53137:         if (idReg.isSet())
53152:             frame.freeReg(idReg.reg());
52843:         frame.popn(2);
53137:         frame.pushRegs(tmpReg, objReg);
53137:         stubcc.rejoin(Changes(1));
56037:         break;
53137:       }
53137: #ifdef JS_POLYIC
53137:       case JSVAL_TYPE_STRING:
53137:       {
53137:         /* Prologue. */
53137:         RegisterID objReg = frame.copyDataIntoReg(obj);
53137:         RegisterID idReg = frame.copyDataIntoReg(id);
52843: 
53137:         /* Meat. */
56037:         if (!jsop_getelem_pic(obj, id, objReg, idReg, tmpReg))
56037:             return false;
53137: 
53137:         /* Epilogue. */
53137:         frame.popn(2);
53137:         frame.pushRegs(tmpReg, objReg);
53137:         frame.freeReg(idReg);
53137:         stubcc.rejoin(Changes(1));
56037:         break;
53137:       }
53137: #endif
53137:       default:
53137:         JS_NOT_REACHED("Invalid known id type.");
53137:     }
56037:     return true;
52843: }
52843: 
53137: #ifdef JS_POLYIC
56037: bool
53137: mjit::Compiler::jsop_getelem_with_pic(FrameEntry *obj, FrameEntry *id, RegisterID tmpReg)
53137: {
53137:     JS_ASSERT(!id->isTypeKnown());
53137:     RegisterID objReg = frame.copyDataIntoReg(obj);
53137:     MaybeRegisterID idReg(frame.copyDataIntoReg(id));
53137: 
53137:     RegisterID typeReg = frame.tempRegForType(id, tmpReg);
53137:     Jump intGuard = masm.testInt32(Assembler::NotEqual, typeReg);
53137: 
53137:     JaegerSpew(JSpew_Insns, " ==== BEGIN DENSE ARRAY CODE ==== \n");
53137: 
53137:     jsop_getelem_dense(obj, id, objReg, idReg, tmpReg);
53137:     Jump performedDense = masm.jump();
53137: 
53137:     JaegerSpew(JSpew_Insns, " ==== END DENSE ARRAY CODE ==== \n");
53137: 
53137:     intGuard.linkTo(masm.label(), &masm);
53137:     Jump stringGuard = masm.testString(Assembler::NotEqual, typeReg);
53137:     stubcc.linkExit(stringGuard, Uses(2)); /* Neither int nor string at this point. */
53137: 
53137:     stubcc.leave();
53137:     stubcc.call(stubs::GetElem);
53137:     Jump toFinalMerge = stubcc.masm.jump();
53137: 
56037:     if (!jsop_getelem_pic(obj, id, objReg, idReg.reg(), tmpReg))
56037:         return false;
53137:     performedDense.linkTo(masm.label(), &masm);
53137:     frame.popn(2);
53137:     frame.pushRegs(tmpReg, objReg);
53152:     frame.freeReg(idReg.reg());
53137:     toFinalMerge.linkTo(stubcc.masm.label(), &stubcc.masm);
53088:     stubcc.rejoin(Changes(1));
56037:     return true;
52843: }
53137: #endif
53137: 
53137: void
53137: mjit::Compiler::jsop_getelem_nopic(FrameEntry *obj, FrameEntry *id, RegisterID tmpReg)
53137: {
53137:     /* Only handle the int32 case. */
53137:     RegisterID objReg = frame.copyDataIntoReg(obj);
53137:     MaybeRegisterID idReg(frame.copyDataIntoReg(id));
53137:     RegisterID typeReg = frame.tempRegForType(id, tmpReg);
53137:     Jump intGuard = masm.testInt32(Assembler::NotEqual, typeReg);
53137:     stubcc.linkExit(intGuard, Uses(2));
53137: 
53137:     /* Meat. */
53137:     jsop_getelem_dense(obj, id, objReg, idReg, tmpReg);
53137:     stubcc.leave();
53137:     stubcc.call(stubs::GetElem);
53137: 
53137:     /* Epilogue. */
53152:     frame.freeReg(idReg.reg());
53137:     frame.popn(2);
53137:     frame.pushRegs(tmpReg, objReg);
53137:     stubcc.rejoin(Changes(1));
53137: }
53137: 
56037: bool
53137: mjit::Compiler::jsop_getelem()
53137: {
53137:     FrameEntry *obj = frame.peek(-2);
53137:     FrameEntry *id = frame.peek(-1);
53137: 
53137:     if (obj->isTypeKnown() && obj->getKnownType() != JSVAL_TYPE_OBJECT) {
53137:         jsop_getelem_slow();
56037:         return true;
53137:     }
53137: 
53137:     if (id->isTypeKnown() &&
53137:         !(id->getKnownType() == JSVAL_TYPE_INT32
53137: #ifdef JS_POLYIC
53137:           || id->getKnownType() == JSVAL_TYPE_STRING
53137: #endif
53137:          )) {
53137:         jsop_getelem_slow();
56037:         return true;
53137:     }
53137: 
53137:     if (id->isTypeKnown() && id->getKnownType() == JSVAL_TYPE_INT32 && id->isConstant() &&
53137:         id->getValue().toInt32() < 0) {
53137:         jsop_getelem_slow();
56037:         return true;
53137:     }
53137: 
53137:     if (id->isTypeKnown() && id->getKnownType() == JSVAL_TYPE_STRING && id->isConstant()) {
53137:         /* Never happens, or I'd optimize it. */
53137:         jsop_getelem_slow();
56037:         return true;
53137:     }
53137: 
53137:     RegisterID tmpReg;
53137:     if (obj->isTypeKnown()) {
53137:         tmpReg = frame.allocReg();
53137:     } else {
53137:         tmpReg = frame.copyTypeIntoReg(obj);
53137:         Jump objGuard = masm.testObject(Assembler::NotEqual, tmpReg);
53137:         stubcc.linkExit(objGuard, Uses(2));
53137:     }
53137: 
53137:     if (id->isTypeKnown())
53137:         return jsop_getelem_known_type(obj, id, tmpReg);
53137: 
53137: #ifdef JS_POLYIC
53137:     return jsop_getelem_with_pic(obj, id, tmpReg);
53137: #else
56037:     jsop_getelem_nopic(obj, id, tmpReg);
56037:     return true;
53137: #endif
53137: }
52843: 
52855: static inline bool
53025: ReallySimpleStrictTest(FrameEntry *fe)
52855: {
52855:     if (!fe->isTypeKnown())
52855:         return false;
53025:     JSValueType type = fe->getKnownType();
53025:     return type == JSVAL_TYPE_NULL || type == JSVAL_TYPE_UNDEFINED;
52855: }
52855: 
52856: static inline bool
52856: BooleanStrictTest(FrameEntry *fe)
52856: {
53025:     return fe->isConstant() && fe->getKnownType() == JSVAL_TYPE_BOOLEAN;
52856: }
52856: 
52855: void
52855: mjit::Compiler::jsop_stricteq(JSOp op)
52855: {
52855:     FrameEntry *rhs = frame.peek(-1);
52855:     FrameEntry *lhs = frame.peek(-2);
52855: 
52855:     Assembler::Condition cond = (op == JSOP_STRICTEQ) ? Assembler::Equal : Assembler::NotEqual;
52855: 
53513:     /*
53513:      * NB: x64 can do full-Value comparisons. This is beneficial
53513:      * to do if the payload/type are not yet in registers.
53513:      */
53513: 
53513:     /* Constant-fold. */
53513:     if (lhs->isConstant() && rhs->isConstant()) {
53513:         bool b = StrictlyEqual(cx, lhs->getValue(), rhs->getValue());
53513:         frame.popn(2);
53513:         frame.push(BooleanValue((op == JSOP_STRICTEQ) ? b : !b));
53513:         return;
53513:     }
53513: 
53513:     if (frame.haveSameBacking(lhs, rhs)) {
53513:         /* False iff NaN. */
53513:         if (lhs->isTypeKnown() && lhs->isNotType(JSVAL_TYPE_DOUBLE)) {
53513:             frame.popn(2);
53513:             frame.push(BooleanValue(true));
53513:             return;
53513:         }
53513:         
53521:         /* Assume NaN is in canonical form. */
53521:         RegisterID result = frame.allocReg(Registers::SingleByteRegs);
53521:         RegisterID treg = frame.tempRegForType(lhs);
53521: 
53521:         Assembler::Condition oppositeCond = (op == JSOP_STRICTEQ) ? Assembler::NotEqual : Assembler::Equal;
53521: 
53521: #if defined JS_CPU_X86 || defined JS_CPU_ARM
53521:         static const int CanonicalNaNType = 0x7FF80000;
53521:         masm.setPtr(oppositeCond, treg, Imm32(CanonicalNaNType), result);
53521: #elif defined JS_CPU_X64
53521:         static const void *CanonicalNaNType = (void *)0x7FF8000000000000; 
53521:         masm.move(ImmPtr(CanonicalNaNType), JSC::X86Registers::r11);
53521:         masm.setPtr(oppositeCond, treg, JSC::X86Registers::r11, result);
53521: #endif
53521: 
53521:         frame.popn(2);
53521:         frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, result);
53521:         return;
53513:     }
53513: 
52855:     /* Comparison against undefined or null is super easy. */
52855:     bool lhsTest;
53025:     if ((lhsTest = ReallySimpleStrictTest(lhs)) || ReallySimpleStrictTest(rhs)) {
52855:         FrameEntry *test = lhsTest ? rhs : lhs;
53513:         FrameEntry *known = lhsTest ? lhs : rhs;
52855: 
52855:         if (test->isTypeKnown()) {
52855:             frame.popn(2);
53081:             frame.push(BooleanValue((test->getKnownType() == known->getKnownType()) ==
53025:                                   (op == JSOP_STRICTEQ)));
52855:             return;
52855:         }
52855: 
52855:         /* This is only true if the other side is |null|. */
52855:         RegisterID result = frame.allocReg(Registers::SingleByteRegs);
53215: #if defined JS_CPU_X86 || defined JS_CPU_ARM
53162:         JSValueTag mask = known->getKnownTag();
52855:         if (frame.shouldAvoidTypeRemat(test))
52856:             masm.set32(cond, masm.tagOf(frame.addressOf(test)), Imm32(mask), result);
52855:         else
52855:             masm.set32(cond, frame.tempRegForType(test), Imm32(mask), result);
53162: #elif defined JS_CPU_X64
53162:         RegisterID maskReg = frame.allocReg();
56004:         masm.move(ImmTag(known->getKnownTag()), maskReg);
55742: 
53162:         RegisterID r = frame.tempRegForType(test);
53162:         masm.setPtr(cond, r, maskReg, result);
55514: 
53162:         frame.freeReg(maskReg);
53162: #endif
52855:         frame.popn(2);
53025:         frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, result);
52855:         return;
52855:     }
52855: 
52856:     /* Hardcoded booleans are easy too. */
52856:     if ((lhsTest = BooleanStrictTest(lhs)) || BooleanStrictTest(rhs)) {
52856:         FrameEntry *test = lhsTest ? rhs : lhs;
52856: 
53513:         if (test->isTypeKnown() && test->isNotType(JSVAL_TYPE_BOOLEAN)) {
52856:             frame.popn(2);
53081:             frame.push(BooleanValue(op == JSOP_STRICTNE));
52856:             return;
52856:         }
52856: 
52856:         if (test->isConstant()) {
52856:             frame.popn(2);
52856:             const Value &L = lhs->getValue();
52856:             const Value &R = rhs->getValue();
53081:             frame.push(BooleanValue((L.toBoolean() == R.toBoolean()) == (op == JSOP_STRICTEQ)));
52856:             return;
52856:         }
52856: 
52856:         RegisterID result = frame.allocReg(Registers::SingleByteRegs);
52856:         
52856:         /* Is the other side boolean? */
52856:         Jump notBoolean;
52856:         if (!test->isTypeKnown())
52856:            notBoolean = frame.testBoolean(Assembler::NotEqual, test);
52856: 
52856:         /* Do a dynamic test. */
53081:         bool val = lhsTest ? lhs->getValue().toBoolean() : rhs->getValue().toBoolean();
53215: #if defined JS_CPU_X86 || defined JS_CPU_ARM
52856:         if (frame.shouldAvoidDataRemat(test))
52856:             masm.set32(cond, masm.payloadOf(frame.addressOf(test)), Imm32(val), result);
52856:         else
52856:             masm.set32(cond, frame.tempRegForData(test), Imm32(val), result);
53162: #elif defined JS_CPU_X64
53162:         RegisterID r = frame.tempRegForData(test);
53162:         masm.set32(cond, r, Imm32(val), result);
53162: #endif
52856: 
52856:         if (!test->isTypeKnown()) {
52856:             Jump done = masm.jump();
52856:             notBoolean.linkTo(masm.label(), &masm);
52856:             masm.move(Imm32((op == JSOP_STRICTNE)), result);
52856:             done.linkTo(masm.label(), &masm);
52856:         }
52856: 
52856:         frame.popn(2);
53025:         frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, result);
52856:         return;
52856:     }
52856: 
53513:     /* Is it impossible that both Values are ints? */
53513:     if ((lhs->isTypeKnown() && lhs->isNotType(JSVAL_TYPE_INT32)) ||
53513:         (rhs->isTypeKnown() && rhs->isNotType(JSVAL_TYPE_INT32))) {
53087:         prepareStubCall(Uses(2));
53513: 
52855:         if (op == JSOP_STRICTEQ)
53087:             stubCall(stubs::StrictEq);
52855:         else
53087:             stubCall(stubs::StrictNe);
53513: 
52855:         frame.popn(2);
53513:         frame.pushSyncedType(JSVAL_TYPE_BOOLEAN);
53513:         return;
53513:     }
53513: 
53513: #ifndef JS_CPU_ARM
53513:     /* Try an integer fast-path. */
53513:     bool needStub = false;
53513:     if (!lhs->isTypeKnown()) {
53513:         Jump j = frame.testInt32(Assembler::NotEqual, lhs);
53513:         stubcc.linkExit(j, Uses(2));
53513:         needStub = true;
53513:     }
53513: 
53513:     if (!rhs->isTypeKnown() && !frame.haveSameBacking(lhs, rhs)) {
53513:         Jump j = frame.testInt32(Assembler::NotEqual, rhs);
53513:         stubcc.linkExit(j, Uses(2));
53513:         needStub = true;
53513:     }
53513: 
53513:     FrameEntry *test  = lhs->isConstant() ? rhs : lhs;
53513:     FrameEntry *other = lhs->isConstant() ? lhs : rhs;
53513: 
53513:     /* ReturnReg is safely usable with set32, since %ah can be accessed. */
53513:     RegisterID resultReg = Registers::ReturnReg;
53513:     frame.takeReg(resultReg);
53513:     RegisterID testReg = frame.tempRegForData(test);
53513:     frame.pinReg(testReg);
53513: 
53513:     JS_ASSERT(resultReg != testReg);
53513: 
53513:     /* Set boolean in resultReg. */
53513:     if (other->isConstant()) {
53513:         masm.set32(cond, testReg, Imm32(other->getValue().toInt32()), resultReg);
53513:     } else if (frame.shouldAvoidDataRemat(other)) {
53513:         masm.set32(cond, testReg, frame.addressOf(other), resultReg);
53513:     } else {
53513:         RegisterID otherReg = frame.tempRegForData(other);
53513: 
53513:         JS_ASSERT(otherReg != resultReg);
53513:         JS_ASSERT(otherReg != testReg);
53513: 
53513:         masm.set32(cond, testReg, otherReg, resultReg);
53513:     }
53513: 
53513:     frame.unpinReg(testReg);
53513: 
53513:     if (needStub) {
53513:         stubcc.leave();
53513:         if (op == JSOP_STRICTEQ)
53513:             stubcc.call(stubs::StrictEq);
53513:         else
53513:             stubcc.call(stubs::StrictNe);
53513:     }
53513: 
53513:     frame.popn(2);
53513:     frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, resultReg);
53513: 
53513:     if (needStub)
53513:         stubcc.rejoin(Changes(1));
53513: #else
53513:     /* TODO: Port set32() logic to ARM. */
53513:     prepareStubCall(Uses(2));
53513: 
53513:     if (op == JSOP_STRICTEQ)
53513:         stubCall(stubs::StrictEq);
53513:     else
53513:         stubCall(stubs::StrictNe);
53513: 
53513:     frame.popn(2);
53513:     frame.pushSyncedType(JSVAL_TYPE_BOOLEAN);
53513:     return;
53513: #endif
52855: }
52855: 
52916: void
52916: mjit::Compiler::jsop_pos()
52916: {
52916:     FrameEntry *top = frame.peek(-1);
52916: 
52916:     if (top->isTypeKnown()) {
53025:         if (top->getKnownType() <= JSVAL_TYPE_INT32)
52916:             return;
53087:         prepareStubCall(Uses(1));
53087:         stubCall(stubs::Pos);
52916:         frame.pop();
52916:         frame.pushSynced();
52916:         return;
52916:     }
52916: 
53052:     frame.giveOwnRegs(top);
53052: 
52916:     Jump j;
52916:     if (frame.shouldAvoidTypeRemat(top))
53052:         j = masm.testNumber(Assembler::NotEqual, frame.addressOf(top));
52916:     else
53052:         j = masm.testNumber(Assembler::NotEqual, frame.tempRegForType(top));
53088:     stubcc.linkExit(j, Uses(1));
52916: 
52916:     stubcc.leave();
52916:     stubcc.call(stubs::Pos);
52916: 
53088:     stubcc.rejoin(Changes(1));
52916: }
52916: 
