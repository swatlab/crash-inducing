    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Hubbie Shaw
    1:  *   Doug Turner <dougt@netscape.com>
    1:  *   Mitch Stoltz <mstoltz@netscape.com>
    1:  *   Brian Ryner <bryner@brianryner.com>
    1:  *   Kai Engert <kaie@netscape.com>
    1:  *   Vipul Gupta <vipul.gupta@sun.com>
    1:  *   Douglas Stebila <douglas@stebila.ca>
    1:  *   Kai Engert <kengert@redhat.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsNSSComponent.h"
    1: #include "nsNSSCallbacks.h"
    1: #include "nsNSSIOLayer.h"
    1: #include "nsSSLThread.h"
    1: #include "nsCertVerificationThread.h"
    1: 
    1: #include "nsNetUtil.h"
    1: #include "nsAppDirectoryServiceDefs.h"
    1: #include "nsDirectoryService.h"
    1: #include "nsIStreamListener.h"
    1: #include "nsIStringBundle.h"
    1: #include "nsIDirectoryService.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsCURILoader.h"
    1: #include "nsDirectoryServiceDefs.h"
    1: #include "nsIProxyObjectManager.h"
    1: #include "nsIX509Cert.h"
    1: #include "nsIX509CertDB.h"
    1: #include "nsIProfileChangeStatus.h"
    1: #include "nsNSSCertificate.h"
    1: #include "nsNSSHelper.h"
    1: #include "nsSmartCardMonitor.h"
    1: #include "prlog.h"
    1: #include "nsIPrefService.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPrefBranch2.h"
    1: #include "nsIDateTimeFormat.h"
    1: #include "nsDateTimeFormatCID.h"
    1: #include "nsAutoLock.h"
    1: #include "nsIDOMEvent.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMDocumentEvent.h"
    1: #include "nsIDOMWindow.h"
    1: #include "nsIDOMWindowCollection.h"
    1: #include "nsIDOMWindowInternal.h"
    1: #include "nsIDOMSmartCardEvent.h"
    1: #include "nsIDOMCrypto.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsCRT.h"
    1: #include "nsCRLInfo.h"
20772: #include "nsCertOverrideService.h"
    1: 
    1: #include "nsIWindowWatcher.h"
    1: #include "nsIPrompt.h"
    1: #include "nsProxiedService.h"
    1: #include "nsIPrincipal.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsIDateTimeFormat.h"
    1: #include "prtypes.h"
    1: #include "nsInt64.h"
    1: #include "nsTime.h"
    1: #include "nsIEntropyCollector.h"
    1: #include "nsIBufEntropyCollector.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsILocalFile.h"
    1: #include "nsITokenPasswordDialogs.h"
    1: #include "nsICRLManager.h"
    1: #include "nsNSSShutDown.h"
    1: #include "nsSmartCardEvent.h"
13256: #include "nsIKeyModule.h"
    1: 
    1: #include "nss.h"
    1: #include "pk11func.h"
    1: #include "ssl.h"
    1: #include "sslproto.h"
    1: #include "secmod.h"
    1: #include "sechash.h"
    1: #include "secmime.h"
    1: #include "ocsp.h"
    1: #include "cms.h"
    1: #include "nssckbi.h"
    1: #include "base64.h"
    1: #include "secerr.h"
    1: #include "sslerr.h"
    1: 
    1: extern "C" {
    1: #include "pkcs12.h"
    1: #include "p12plcy.h"
    1: }
    1: 
    1: #ifdef PR_LOGGING
    1: PRLogModuleInfo* gPIPNSSLog = nsnull;
    1: #endif
    1: 
    1: #define NS_CRYPTO_HASH_BUFFER_SIZE 4096
    1: 
    1: static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID);
    1: int nsNSSComponent::mInstanceCount = 0;
    1: 
    1: // XXX tmp callback for slot password
    1: extern char * PR_CALLBACK 
    1: pk11PasswordPrompt(PK11SlotInfo *slot, PRBool retry, void *arg);
    1: 
    1: #define PIPNSS_STRBUNDLE_URL "chrome://pipnss/locale/pipnss.properties"
 2850: #define NSSERR_STRBUNDLE_URL "chrome://pipnss/locale/nsserrors.properties"
    1: 
    1: 
    1: static PLHashNumber PR_CALLBACK certHashtable_keyHash(const void *key)
    1: {
    1:   if (!key)
    1:     return 0;
    1:   
    1:   SECItem *certKey = (SECItem*)key;
    1:   
    1:   // lazy hash function, sum up all char values of SECItem
    1:   
    1:   PLHashNumber hash = 0;
    1:   unsigned int i = 0;
    1:   unsigned char *c = certKey->data;
    1:   
    1:   for (i = 0; i < certKey->len; ++i, ++c) {
    1:     hash += *c;
    1:   }
    1:   
    1:   return hash;
    1: }
    1: 
    1: static PRIntn PR_CALLBACK certHashtable_keyCompare(const void *k1, const void *k2)
    1: {
    1:   // return type is a bool, answering the question "are the keys equal?"
    1: 
    1:   if (!k1 || !k2)
    1:     return PR_FALSE;
    1:   
    1:   SECItem *certKey1 = (SECItem*)k1;
    1:   SECItem *certKey2 = (SECItem*)k2;
    1:   
    1:   if (certKey1->len != certKey2->len) {
    1:     return PR_FALSE;
    1:   }
    1:   
    1:   unsigned int i = 0;
    1:   unsigned char *c1 = certKey1->data;
    1:   unsigned char *c2 = certKey2->data;
    1:   
    1:   for (i = 0; i < certKey1->len; ++i, ++c1, ++c2) {
    1:     if (*c1 != *c2) {
    1:       return PR_FALSE;
    1:     }
    1:   }
    1:   
    1:   return PR_TRUE;
    1: }
    1: 
    1: static PRIntn PR_CALLBACK certHashtable_valueCompare(const void *v1, const void *v2)
    1: {
    1:   // two values are identical if their keys are identical
    1:   
    1:   if (!v1 || !v2)
    1:     return PR_FALSE;
    1:   
    1:   CERTCertificate *cert1 = (CERTCertificate*)v1;
    1:   CERTCertificate *cert2 = (CERTCertificate*)v2;
    1:   
    1:   return certHashtable_keyCompare(&cert1->certKey, &cert2->certKey);
    1: }
    1: 
    1: static PRIntn PR_CALLBACK certHashtable_clearEntry(PLHashEntry *he, PRIntn /*index*/, void * /*userdata*/)
    1: {
    1:   if (he && he->value) {
    1:     CERT_DestroyCertificate((CERTCertificate*)he->value);
    1:   }
    1:   
    1:   return HT_ENUMERATE_NEXT;
    1: }
    1: 
    1: class CRLDownloadEvent : public nsRunnable {
    1: public:
    1:   CRLDownloadEvent(const nsCSubstring &urlString, nsIStreamListener *listener)
    1:     : mURLString(urlString)
    1:     , mListener(listener)
    1:   {}
    1: 
    1:   // Note that nsNSSComponent is a singleton object across all threads, 
    1:   // and automatic downloads are always scheduled sequentially - that is, 
    1:   // once one crl download is complete, the next one is scheduled
    1:   NS_IMETHOD Run()
    1:   {
    1:     if (!mListener || mURLString.IsEmpty())
    1:       return NS_OK;
    1: 
    1:     nsCOMPtr<nsIURI> uri;
    1:     nsresult rv = NS_NewURI(getter_AddRefs(uri), mURLString);
    1:     if (NS_SUCCEEDED(rv)){
    1:       NS_OpenURI(mListener, nsnull, uri);
    1:     }
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1: private:
    1:   nsCString mURLString;
    1:   nsCOMPtr<nsIStreamListener> mListener;
    1: };
    1: 
    1: //This class is used to run the callback code
    1: //passed to the event handlers for smart card notification
    1: class nsTokenEventRunnable : public nsIRunnable {
    1: public:
    1:   nsTokenEventRunnable(const nsAString &aType, const nsAString &aTokenName);
    1:   virtual ~nsTokenEventRunnable();
    1: 
    1:   NS_IMETHOD Run ();
    1:   NS_DECL_ISUPPORTS
    1: private:
    1:   nsString mType;
    1:   nsString mTokenName;
    1: };
    1: 
    1: // ISuuports implementation for nsTokenEventRunnable
    1: NS_IMPL_THREADSAFE_ISUPPORTS1(nsTokenEventRunnable, nsIRunnable)
    1: 
    1: nsTokenEventRunnable::nsTokenEventRunnable(const nsAString &aType, 
    1:    const nsAString &aTokenName): mType(aType), mTokenName(aTokenName) { }
    1: 
    1: nsTokenEventRunnable::~nsTokenEventRunnable() { }
    1: 
    1: //Implementation that runs the callback passed to 
    1: //crypto.generateCRMFRequest as an event.
    1: NS_IMETHODIMP
    1: nsTokenEventRunnable::Run()
    1: { 
    1:   nsresult rv;
    1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   return nssComponent->DispatchEvent(mType, mTokenName);
    1: }
    1: 
25625: // We must ensure that the nsNSSComponent has been loaded before
25625: // creating any other components.
25625: PRBool EnsureNSSInitialized(EnsureNSSOperator op)
25625: {
25625:   static PRBool loading = PR_FALSE;
25625:   static PRBool haveLoaded = PR_FALSE;
25625: 
25625:   switch (op)
25625:   {
25625:     // In following 4 cases we are protected by monitor of XPCOM component
25625:     // manager - we are inside of do_GetService call for nss component, so it is
25625:     // safe to move with the flags here.
25625:   case nssLoading:
25625:     if (loading)
25625:       return PR_FALSE; // We are reentered during nss component creation
25625:     loading = PR_TRUE;
25625:     return PR_TRUE;
25625: 
25625:   case nssInitSucceeded:
25625:     NS_ASSERTION(loading, "Bad call to EnsureNSSInitialized(nssInitSucceeded)");
25625:     loading = PR_FALSE;
25625:     haveLoaded = PR_TRUE;
25625:     return PR_TRUE;
25625: 
25625:   case nssInitFailed:
25625:     NS_ASSERTION(loading, "Bad call to EnsureNSSInitialized(nssInitFailed)");
25625:     loading = PR_FALSE;
25625:     // no break
25625: 
25625:   case nssShutdown:
25625:     haveLoaded = PR_FALSE;
25625:     return PR_FALSE;
25625: 
25625:     // In this case we are called from a component to ensure nss initilization.
25625:     // If the component has not yet been loaded and is not currently loading
25625:     // call do_GetService for nss component to ensure it.
25625:   case nssEnsure:
25625:     // We are reentered during nss component creation or nss component is already up
25625:     if (haveLoaded || loading)
25625:       return PR_TRUE;
25625: 
25625:     {
29543:     nsCOMPtr<nsINSSComponent> nssComponent
25625:       = do_GetService(PSM_COMPONENT_CONTRACTID);
25625: 
25625:     // Nss component failed to initialize, inform the caller of that fact.
25625:     // Flags are appropriately set by component constructor itself.
25625:     if (!nssComponent)
25625:       return PR_FALSE;
25625: 
29543:     PRBool isInitialized;
29543:     nsresult rv = nssComponent->IsNSSInitialized(&isInitialized);
29543:     return NS_SUCCEEDED(rv) && isInitialized;
25625:     }
25625: 
25625:   default:
25625:     NS_ASSERTION(PR_FALSE, "Bad operator to EnsureNSSInitialized");
25625:     return PR_FALSE;
25625:   }
25625: }
25625: 
    1: nsNSSComponent::nsNSSComponent()
25625:   :mNSSInitialized(PR_FALSE), mThreadList(nsnull),
25625:    mSSLThread(NULL), mCertVerificationThread(NULL)
    1: {
    1:   mutex = PR_NewLock();
    1:   
    1: #ifdef PR_LOGGING
    1:   if (!gPIPNSSLog)
    1:     gPIPNSSLog = PR_NewLogModule("pipnss");
    1: #endif
    1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsNSSComponent::ctor\n"));
    1:   mUpdateTimerInitialized = PR_FALSE;
    1:   crlDownloadTimerOn = PR_FALSE;
    1:   crlsScheduledForDownload = nsnull;
    1:   mTimer = nsnull;
    1:   mCrlTimerLock = nsnull;
    1:   mObserversRegistered = PR_FALSE;
    1: 
 7105:   // In order to keep startup time lower, we delay loading and 
 7105:   // registering all identity data until first needed.
 7105:   memset(&mIdentityInfoCallOnce, 0, sizeof(PRCallOnceType));
 7105: 
    1:   NS_ASSERTION( (0 == mInstanceCount), "nsNSSComponent is a singleton, but instantiated multiple times!");
    1:   ++mInstanceCount;
    1:   hashTableCerts = nsnull;
    1:   mShutdownObjectList = nsNSSShutDownList::construct();
    1:   mIsNetworkDown = PR_FALSE;
    1: }
    1: 
    1: nsNSSComponent::~nsNSSComponent()
    1: {
    1:   if (mSSLThread)
    1:   {
    1:     mSSLThread->requestExit();
    1:     delete mSSLThread;
    1:     mSSLThread = nsnull;
    1:   }
    1:   
    1:   if (mCertVerificationThread)
    1:   {
    1:     mCertVerificationThread->requestExit();
    1:     delete mCertVerificationThread;
    1:     mCertVerificationThread = nsnull;
    1:   }
    1: 
    1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsNSSComponent::dtor\n"));
    1: 
17116:   if (mUpdateTimerInitialized) {
    1:     PR_Lock(mCrlTimerLock);
17116:     if (crlDownloadTimerOn) {
    1:       mTimer->Cancel();
    1:     }
    1:     crlDownloadTimerOn = PR_FALSE;
    1:     PR_Unlock(mCrlTimerLock);
    1:     PR_DestroyLock(mCrlTimerLock);
    1:     if(crlsScheduledForDownload != nsnull){
    1:       crlsScheduledForDownload->Reset();
    1:       delete crlsScheduledForDownload;
    1:     }
    1: 
    1:     mUpdateTimerInitialized = PR_FALSE;
    1:   }
    1: 
    1:   // All cleanup code requiring services needs to happen in xpcom_shutdown
    1: 
    1:   ShutdownNSS();
    1:   nsSSLIOLayerHelpers::Cleanup();
    1:   --mInstanceCount;
    1:   delete mShutdownObjectList;
    1: 
    1:   if (mutex) {
    1:     PR_DestroyLock(mutex);
    1:     mutex = nsnull;
    1:   }
    1: 
25625:   // We are being freed, drop the haveLoaded flag to re-enable
25625:   // potential nss initialization later.
25625:   EnsureNSSInitialized(nssShutdown);
25625: 
    1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsNSSComponent::dtor finished\n"));
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNSSComponent::PostEvent(const nsAString &eventType, 
    1:                                                   const nsAString &tokenName)
    1: {
    1:   nsCOMPtr<nsIRunnable> runnable = 
    1:                                new nsTokenEventRunnable(eventType, tokenName);
    1:   if (!runnable) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   return NS_DispatchToMainThread(runnable);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsNSSComponent::DispatchEvent(const nsAString &eventType,
    1:                                                  const nsAString &tokenName)
    1: {
    1:   // 'Dispatch' the event to all the windows. 'DispatchEventToWindow()' will
    1:   // first check to see if a given window has requested crypto events.
    1:   nsresult rv;
    1:   nsCOMPtr<nsIWindowWatcher> windowWatcher =
    1:                             do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
    1: 
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   nsCOMPtr<nsISimpleEnumerator> enumerator;
    1:   rv = windowWatcher->GetWindowEnumerator(getter_AddRefs(enumerator));
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   PRBool hasMoreWindows;
    1: 
    1:   while (NS_SUCCEEDED(enumerator->HasMoreElements(&hasMoreWindows))
    1:          && hasMoreWindows) {
    1:     nsCOMPtr<nsISupports> supports;
    1:     enumerator->GetNext(getter_AddRefs(supports));
    1:     nsCOMPtr<nsIDOMWindow> domWin(do_QueryInterface(supports));
    1:     if (domWin) {
    1:       nsresult rv2 = DispatchEventToWindow(domWin, eventType, tokenName);
    1:       if (NS_FAILED(rv2)) {
    1:         // return the last failure, don't let a single failure prevent
    1:         // continued delivery of events.
    1:         rv = rv2;
    1:       }
    1:     }
    1:   }
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsNSSComponent::DispatchEventToWindow(nsIDOMWindow *domWin,
    1:                       const nsAString &eventType, const nsAString &tokenName)
    1: {
    1:   // first walk the children and dispatch their events 
    1:   {
    1:     nsresult rv;
    1:     nsCOMPtr<nsIDOMWindowCollection> frames;
    1:     rv = domWin->GetFrames(getter_AddRefs(frames));
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
    1: 
    1:     PRUint32 length;
    1:     frames->GetLength(&length);
    1:     PRUint32 i;
    1:     for (i = 0; i < length; i++) {
    1:       nsCOMPtr<nsIDOMWindow> childWin;
    1:       frames->Item(i, getter_AddRefs(childWin));
    1:       DispatchEventToWindow(childWin, eventType, tokenName);
    1:     }
    1:   }
    1: 
    1:   // check if we've enabled smart card events on this window
    1:   // NOTE: it's not an error to say that we aren't going to dispatch
    1:   // the event.
    1:   {
    1:     nsCOMPtr<nsIDOMWindowInternal> intWindow = do_QueryInterface(domWin);
    1:     if (!intWindow) {
    1:       return NS_OK; // nope, it's not an internal window
    1:     }
    1: 
    1:     nsCOMPtr<nsIDOMCrypto> crypto;
    1:     intWindow->GetCrypto(getter_AddRefs(crypto));
    1:     if (!crypto) {
    1:       return NS_OK; // nope, it doesn't have a crypto property
    1:     }
    1: 
    1:     PRBool boolrv;
    1:     crypto->GetEnableSmartCardEvents(&boolrv);
    1:     if (!boolrv) {
    1:       return NS_OK; // nope, it's not enabled.
    1:     }
    1:   }
    1: 
    1:   // dispatch the event ...
    1: 
    1:   nsresult rv;
    1:   // find the document
    1:   nsCOMPtr<nsIDOMDocument> doc;
    1:   rv = domWin->GetDocument(getter_AddRefs(doc));
    1:   if (doc == nsnull) {
    1:     return NS_FAILED(rv) ? rv : NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // create the event
    1:   nsCOMPtr<nsIDOMDocumentEvent> docEvent = do_QueryInterface(doc, &rv);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMEvent> event;
    1:   rv = docEvent->CreateEvent(NS_LITERAL_STRING("Events"), 
    1:                              getter_AddRefs(event));
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   event->InitEvent(eventType, false, true);
    1: 
    1:   // create the Smart Card Event;
    1:   nsCOMPtr<nsIDOMSmartCardEvent> smartCardEvent = 
    1:                                           new nsSmartCardEvent(tokenName);
    1:   // init the smart card event, fail here if we can't complete the 
    1:   // initialization.
    1:   if (!smartCardEvent) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   rv = smartCardEvent->Init(event);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   // Send it 
    1:   nsCOMPtr<nsIDOMEventTarget> target = do_QueryInterface(doc, &rv);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   PRBool boolrv;
    1:   rv = target->DispatchEvent(smartCardEvent, &boolrv);
    1:   return rv;
    1: }
    1: 
    1: 
    1: static void setOCSPOptions(nsIPrefBranch * pref);
    1: 
    1: NS_IMETHODIMP
    1: nsNSSComponent::PIPBundleFormatStringFromName(const char *name,
    1:                                               const PRUnichar **params,
    1:                                               PRUint32 numParams,
    1:                                               nsAString &outString)
    1: {
    1:   nsresult rv = NS_ERROR_FAILURE;
    1: 
    1:   if (mPIPNSSBundle && name) {
    1:     nsXPIDLString result;
    1:     rv = mPIPNSSBundle->FormatStringFromName(NS_ConvertASCIItoUTF16(name).get(),
    1:                                              params, numParams,
    1:                                              getter_Copies(result));
    1:     if (NS_SUCCEEDED(rv)) {
    1:       outString = result;
    1:     }
    1:   }
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNSSComponent::GetPIPNSSBundleString(const char *name,
    1:                                       nsAString &outString)
    1: {
    1:   nsresult rv = NS_ERROR_FAILURE;
    1: 
    1:   outString.SetLength(0);
    1:   if (mPIPNSSBundle && name) {
    1:     nsXPIDLString result;
    1:     rv = mPIPNSSBundle->GetStringFromName(NS_ConvertASCIItoUTF16(name).get(),
    1:                                           getter_Copies(result));
    1:     if (NS_SUCCEEDED(rv)) {
    1:       outString = result;
    1:       rv = NS_OK;
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
 2850: NS_IMETHODIMP
 2850: nsNSSComponent::NSSBundleFormatStringFromName(const char *name,
 2850:                                               const PRUnichar **params,
 2850:                                               PRUint32 numParams,
 2850:                                               nsAString &outString)
 2850: {
 2850:   nsresult rv = NS_ERROR_FAILURE;
 2850: 
 2850:   if (mNSSErrorsBundle && name) {
 2850:     nsXPIDLString result;
 2850:     rv = mNSSErrorsBundle->FormatStringFromName(NS_ConvertASCIItoUTF16(name).get(),
 2850:                                                 params, numParams,
 2850:                                                 getter_Copies(result));
 2850:     if (NS_SUCCEEDED(rv)) {
 2850:       outString = result;
 2850:     }
 2850:   }
 2850:   return rv;
 2850: }
 2850: 
 2850: NS_IMETHODIMP
 2850: nsNSSComponent::GetNSSBundleString(const char *name,
 2850:                                    nsAString &outString)
 2850: {
 2850:   nsresult rv = NS_ERROR_FAILURE;
 2850: 
 2850:   outString.SetLength(0);
 2850:   if (mNSSErrorsBundle && name) {
 2850:     nsXPIDLString result;
 2850:     rv = mNSSErrorsBundle->GetStringFromName(NS_ConvertASCIItoUTF16(name).get(),
 2850:                                              getter_Copies(result));
 2850:     if (NS_SUCCEEDED(rv)) {
 2850:       outString = result;
 2850:       rv = NS_OK;
 2850:     }
 2850:   }
 2850: 
 2850:   return rv;
 2850: }
 2850: 
    1: 
    1: NS_IMETHODIMP
    1: nsNSSComponent::SkipOcsp()
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   CERTCertDBHandle *certdb = CERT_GetDefaultCertDB();
    1: 
    1:   SECStatus rv = CERT_DisableOCSPChecking(certdb);
    1:   return (rv == SECSuccess) ? NS_OK : NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNSSComponent::SkipOcspOff()
    1: {
    1:   setOCSPOptions(mPrefBranch);
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsNSSComponent::LaunchSmartCardThreads()
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   {
    1:     SECMODModuleList *list = SECMOD_GetDefaultModuleList();
    1:     SECMODListLock *lock = SECMOD_GetDefaultModuleListLock();
    1:     SECMOD_GetReadLock(lock);
    1: 
    1:     while (list) {
    1:       SECMODModule *module = list->module;
    1:       LaunchSmartCardThread(module);
    1:       list = list->next;
    1:     }
    1:     SECMOD_ReleaseReadLock(lock);
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNSSComponent::LaunchSmartCardThread(SECMODModule *module)
    1: {
    1:   SmartCardMonitoringThread *newThread;
    1:   if (SECMOD_HasRemovableSlots(module)) {
    1:     if (mThreadList == nsnull) {
    1:       mThreadList = new SmartCardThreadList();
    1:       if (!mThreadList) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:       }
    1:     }
    1:     newThread = new SmartCardMonitoringThread(module);
    1:     if (!newThread) {
    1: 	return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:     // newThread is adopted by the add.
    1:     return mThreadList->Add(newThread);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNSSComponent::ShutdownSmartCardThread(SECMODModule *module)
    1: {
    1:   if (!mThreadList) {
    1:     return NS_OK;
    1:   }
    1:   mThreadList->Remove(module);
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsNSSComponent::ShutdownSmartCardThreads()
    1: {
    1:   delete mThreadList;
    1:   mThreadList = nsnull;
    1: }
    1: 
    1: static char *
    1: nss_addEscape(const char *string, char quote)
    1: {
    1:     char *newString = 0;
    1:     int escapes = 0, size = 0;
    1:     const char *src;
    1:     char *dest;
    1: 
    1:     for (src=string; *src ; src++) {
    1:         if ((*src == quote) || (*src == '\\')) {
    1:           escapes++;
    1:         }
    1:         size++;
    1:     }
    1: 
    1:     newString = (char*)PORT_ZAlloc(escapes+size+1);
    1:     if (newString == NULL) {
    1:         return NULL;
    1:     }
    1: 
    1:     for (src=string, dest=newString; *src; src++,dest++) {
    1:         if ((*src == quote) || (*src == '\\')) {
    1:             *dest++ = '\\';
    1:         }
    1:         *dest = *src;
    1:     }
    1: 
    1:     return newString;
    1: }
    1: 
    1: void
    1: nsNSSComponent::InstallLoadableRoots()
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   SECMODModule *RootsModule = nsnull;
    1: 
    1:   // In the past we used SECMOD_AddNewModule to load our module containing
    1:   // root CA certificates. This caused problems, refer to bug 176501.
    1:   // On startup, we fix our database and clean any stored module reference,
    1:   // and will use SECMOD_LoadUserModule to temporarily load it
    1:   // for the session. (This approach requires to clean up 
    1:   // using SECMOD_UnloadUserModule at the end of the session.)
    1: 
    1:   {
    1:     // Find module containing root certs
    1: 
    1:     SECMODModuleList *list = SECMOD_GetDefaultModuleList();
    1:     SECMODListLock *lock = SECMOD_GetDefaultModuleListLock();
    1:     SECMOD_GetReadLock(lock);
    1: 
    1:     while (!RootsModule && list) {
    1:       SECMODModule *module = list->module;
    1: 
    1:       for (int i=0; i < module->slotCount; i++) {
    1:         PK11SlotInfo *slot = module->slots[i];
    1:         if (PK11_IsPresent(slot)) {
    1:           if (PK11_HasRootCerts(slot)) {
    1:             RootsModule = SECMOD_ReferenceModule(module);
    1:             break;
    1:           }
    1:         }
    1:       }
    1: 
    1:       list = list->next;
    1:     }
    1:     SECMOD_ReleaseReadLock(lock);
    1:   }
    1: 
    1:   if (RootsModule) {
    1:     PRInt32 modType;
    1:     SECMOD_DeleteModule(RootsModule->commonName, &modType);
    1:     SECMOD_DestroyModule(RootsModule);
    1:     RootsModule = nsnull;
    1:   }
    1: 
    1:   // Find the best Roots module for our purposes.
    1:   // Prefer the application's installation directory,
    1:   // but also ensure the library is at least the version we expect.
    1: 
    1:   nsresult rv;
    1:   nsAutoString modName;
    1:   rv = GetPIPNSSBundleString("RootCertModuleName", modName);
    1:   if (NS_FAILED(rv)) return;
    1: 
    1:   nsCOMPtr<nsIProperties> directoryService(do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID));
    1:   if (!directoryService)
    1:     return;
    1: 
    1:   const char *possible_ckbi_locations[] = {
    1:     NS_XPCOM_CURRENT_PROCESS_DIR,
    1:     NS_GRE_DIR,
    1:     0 // This special value means: 
    1:       //   search for ckbi in the directories on the shared
    1:       //   library/DLL search path
    1:   };
    1: 
    1:   for (size_t il = 0; il < sizeof(possible_ckbi_locations)/sizeof(const char*); ++il) {
    1:     nsCOMPtr<nsILocalFile> mozFile;
    1:     char *fullLibraryPath = nsnull;
    1: 
    1:     if (!possible_ckbi_locations[il])
    1:     {
    1:       fullLibraryPath = PR_GetLibraryName(nsnull, "nssckbi");
    1:     }
    1:     else
    1:     {
    1:       directoryService->Get( possible_ckbi_locations[il],
    1:                              NS_GET_IID(nsILocalFile), 
    1:                              getter_AddRefs(mozFile));
    1:   
    1:       if (!mozFile) {
    1:         continue;
    1:       }
    1: 
    1:       nsCAutoString processDir;
    1:       mozFile->GetNativePath(processDir);
    1:       fullLibraryPath = PR_GetLibraryName(processDir.get(), "nssckbi");
    1:     }
    1: 
    1:     if (!fullLibraryPath) {
    1:       continue;
    1:     }
    1: 
    1:     char *escaped_fullLibraryPath = nss_addEscape(fullLibraryPath, '\"');
    1:     if (!escaped_fullLibraryPath) {
    1:       PR_FreeLibraryName(fullLibraryPath); // allocated by NSPR
    1:       continue;
    1:     }
    1: 
    1:     /* If a module exists with the same name, delete it. */
    1:     NS_ConvertUTF16toUTF8 modNameUTF8(modName);
    1:     int modType;
 3233:     SECMOD_DeleteModule(const_cast<char*>(modNameUTF8.get()), &modType);
    1: 
    1:     nsCString pkcs11moduleSpec;
    1:     pkcs11moduleSpec.Append(NS_LITERAL_CSTRING("name=\""));
    1:     pkcs11moduleSpec.Append(modNameUTF8.get());
    1:     pkcs11moduleSpec.Append(NS_LITERAL_CSTRING("\" library=\""));
    1:     pkcs11moduleSpec.Append(escaped_fullLibraryPath);
    1:     pkcs11moduleSpec.Append(NS_LITERAL_CSTRING("\""));
    1: 
    1:     PR_FreeLibraryName(fullLibraryPath); // allocated by NSPR
    1:     PORT_Free(escaped_fullLibraryPath);
    1: 
    1:     RootsModule =
 3233:       SECMOD_LoadUserModule(const_cast<char*>(pkcs11moduleSpec.get()), 
    1:                             nsnull, // no parent 
    1:                             PR_FALSE); // do not recurse
    1: 
    1:     if (RootsModule) {
 2851:       PRBool found = (RootsModule->loaded);
 2851: 
 1427:       SECMOD_DestroyModule(RootsModule);
 2851:       RootsModule = nsnull;
 2851: 
 2851:       if (found) {
    1:         break;
    1:       }
    1:     }
    1:   }
 2851: }
    1: 
    1: void 
    1: nsNSSComponent::UnloadLoadableRoots()
    1: {
    1:   nsresult rv;
    1:   nsAutoString modName;
    1:   rv = GetPIPNSSBundleString("RootCertModuleName", modName);
    1:   if (NS_FAILED(rv)) return;
    1: 
    1:   NS_ConvertUTF16toUTF8 modNameUTF8(modName);
    1:   SECMODModule *RootsModule = SECMOD_FindModule(modNameUTF8.get());
    1: 
    1:   if (RootsModule) {
    1:     SECMOD_UnloadUserModule(RootsModule);
    1:     SECMOD_DestroyModule(RootsModule);
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsNSSComponent::ConfigureInternalPKCS11Token()
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   nsAutoString manufacturerID;
    1:   nsAutoString libraryDescription;
    1:   nsAutoString tokenDescription;
    1:   nsAutoString privateTokenDescription;
    1:   nsAutoString slotDescription;
    1:   nsAutoString privateSlotDescription;
    1:   nsAutoString fips140TokenDescription;
    1:   nsAutoString fips140SlotDescription;
    1: 
    1:   nsresult rv;
    1:   rv = GetPIPNSSBundleString("ManufacturerID", manufacturerID);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   rv = GetPIPNSSBundleString("LibraryDescription", libraryDescription);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   rv = GetPIPNSSBundleString("TokenDescription", tokenDescription);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   rv = GetPIPNSSBundleString("PrivateTokenDescription", privateTokenDescription);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   rv = GetPIPNSSBundleString("SlotDescription", slotDescription);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   rv = GetPIPNSSBundleString("PrivateSlotDescription", privateSlotDescription);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   rv = GetPIPNSSBundleString("Fips140TokenDescription", fips140TokenDescription);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   rv = GetPIPNSSBundleString("Fips140SlotDescription", fips140SlotDescription);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   PK11_ConfigurePKCS11(NS_ConvertUTF16toUTF8(manufacturerID).get(),
    1:                        NS_ConvertUTF16toUTF8(libraryDescription).get(),
    1:                        NS_ConvertUTF16toUTF8(tokenDescription).get(),
    1:                        NS_ConvertUTF16toUTF8(privateTokenDescription).get(),
    1:                        NS_ConvertUTF16toUTF8(slotDescription).get(),
    1:                        NS_ConvertUTF16toUTF8(privateSlotDescription).get(),
    1:                        NS_ConvertUTF16toUTF8(fips140TokenDescription).get(),
    1:                        NS_ConvertUTF16toUTF8(fips140SlotDescription).get(),
    1:                        0, 0);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNSSComponent::InitializePIPNSSBundle()
    1: {
    1:   // Called during init only, no mutex required.
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIStringBundleService> bundleService(do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv));
    1:   if (NS_FAILED(rv) || !bundleService) 
    1:     return NS_ERROR_FAILURE;
    1:   
    1:   bundleService->CreateBundle(PIPNSS_STRBUNDLE_URL,
    1:                               getter_AddRefs(mPIPNSSBundle));
    1:   if (!mPIPNSSBundle)
    1:     rv = NS_ERROR_FAILURE;
    1: 
 2850:   bundleService->CreateBundle(NSSERR_STRBUNDLE_URL,
 2850:                               getter_AddRefs(mNSSErrorsBundle));
 2850:   if (!mNSSErrorsBundle)
 2850:     rv = NS_ERROR_FAILURE;
 2850: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsNSSComponent::RegisterPSMContentListener()
    1: {
    1:   // Called during init only, no mutex required.
    1: 
    1:   nsresult rv = NS_OK;
    1:   if (!mPSMContentListener) {
    1:     nsCOMPtr<nsIURILoader> dispatcher(do_GetService(NS_URI_LOADER_CONTRACTID));
    1:     if (dispatcher) {
    1:       mPSMContentListener = do_CreateInstance(NS_PSMCONTENTLISTEN_CONTRACTID);
    1:       rv = dispatcher->RegisterContentListener(mPSMContentListener);
    1:     }
    1:   }
    1:   return rv;
    1: }
    1: 
    1: /* Table of pref names and SSL cipher ID */
    1: typedef struct {
    1:   const char* pref;
    1:   long id;
    1: } CipherPref;
    1: 
    1: static CipherPref CipherPrefs[] = {
    1: /* SSL2 cipher suites, all use RSA and an MD5 MAC */
    1:  {"security.ssl2.rc4_128", SSL_EN_RC4_128_WITH_MD5}, // 128-bit RC4 encryption with RSA and an MD5 MAC
    1:  {"security.ssl2.rc2_128", SSL_EN_RC2_128_CBC_WITH_MD5}, // 128-bit RC2 encryption with RSA and an MD5 MAC
    1:  {"security.ssl2.des_ede3_192", SSL_EN_DES_192_EDE3_CBC_WITH_MD5}, // 168-bit Triple DES encryption with RSA and MD5 MAC 
    1:  {"security.ssl2.des_64", SSL_EN_DES_64_CBC_WITH_MD5}, // 56-bit DES encryption with RSA and an MD5 MAC
    1:  {"security.ssl2.rc4_40", SSL_EN_RC4_128_EXPORT40_WITH_MD5}, // 40-bit RC4 encryption with RSA and an MD5 MAC (export)
    1:  {"security.ssl2.rc2_40", SSL_EN_RC2_128_CBC_EXPORT40_WITH_MD5}, // 40-bit RC2 encryption with RSA and an MD5 MAC (export)
    1:  /* Fortezza SSL3/TLS cipher suites, see bug 133502 */
    1:  {"security.ssl3.fortezza_fortezza_sha", SSL_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA},
    1:  {"security.ssl3.fortezza_rc4_sha", SSL_FORTEZZA_DMS_WITH_RC4_128_SHA},
    1:  {"security.ssl3.fortezza_null_sha", SSL_FORTEZZA_DMS_WITH_NULL_SHA},
    1:  /* SSL3/TLS cipher suites*/
    1:  {"security.ssl3.rsa_rc4_128_md5", SSL_RSA_WITH_RC4_128_MD5}, // 128-bit RC4 encryption with RSA and an MD5 MAC
    1:  {"security.ssl3.rsa_rc4_128_sha", SSL_RSA_WITH_RC4_128_SHA}, // 128-bit RC4 encryption with RSA and a SHA1 MAC
    1:  {"security.ssl3.rsa_fips_des_ede3_sha", SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA}, // 168-bit Triple DES with RSA and a SHA1 MAC (FIPS)
    1:  {"security.ssl3.rsa_des_ede3_sha", SSL_RSA_WITH_3DES_EDE_CBC_SHA}, // 168-bit Triple DES with RSA and a SHA1 MAC
    1:  {"security.ssl3.rsa_fips_des_sha", SSL_RSA_FIPS_WITH_DES_CBC_SHA}, // 56-bit DES encryption with RSA and a SHA1 MAC (FIPS)
    1:  {"security.ssl3.rsa_des_sha", SSL_RSA_WITH_DES_CBC_SHA}, // 56-bit DES encryption with RSA and a SHA1 MAC
    1:  {"security.ssl3.rsa_1024_rc4_56_sha", TLS_RSA_EXPORT1024_WITH_RC4_56_SHA}, // 56-bit RC4 encryption with RSA and a SHA1 MAC (export)
    1:  {"security.ssl3.rsa_1024_des_cbc_sha", TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA}, // 56-bit DES encryption with RSA and a SHA1 MAC (export)
    1:  {"security.ssl3.rsa_rc4_40_md5", SSL_RSA_EXPORT_WITH_RC4_40_MD5}, // 40-bit RC4 encryption with RSA and an MD5 MAC (export)
    1:  {"security.ssl3.rsa_rc2_40_md5", SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5}, // 40-bit RC2 encryption with RSA and an MD5 MAC (export)
    1:  /* Extra SSL3/TLS cipher suites */
 3982:  {"security.ssl3.dhe_rsa_camellia_256_sha", TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA}, // 256-bit Camellia encryption with RSA, DHE, and a SHA1 MAC
 3982:  {"security.ssl3.dhe_dss_camellia_256_sha", TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA}, // 256-bit Camellia encryption with DSA, DHE, and a SHA1 MAC
 3982:  {"security.ssl3.rsa_camellia_256_sha", TLS_RSA_WITH_CAMELLIA_256_CBC_SHA}, // 256-bit Camellia encryption with RSA and a SHA1 MAC
    1:  {"security.ssl3.dhe_rsa_aes_256_sha", TLS_DHE_RSA_WITH_AES_256_CBC_SHA}, // 256-bit AES encryption with RSA, DHE, and a SHA1 MAC
    1:  {"security.ssl3.dhe_dss_aes_256_sha", TLS_DHE_DSS_WITH_AES_256_CBC_SHA}, // 256-bit AES encryption with DSA, DHE, and a SHA1 MAC
    1:  {"security.ssl3.rsa_aes_256_sha", TLS_RSA_WITH_AES_256_CBC_SHA}, // 256-bit AES encryption with RSA and a SHA1 MAC
    1:    /* TLS_DHE_DSS_WITH_RC4_128_SHA // 128-bit RC4 encryption with DSA, DHE, and a SHA1 MAC
    1:       If this cipher gets included at a later time, it should get added at this position */
    1:  {"security.ssl3.ecdhe_ecdsa_aes_256_sha", TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA}, // 256-bit AES encryption with ECDHE-ECDSA and a SHA1 MAC
    1:  {"security.ssl3.ecdhe_ecdsa_aes_128_sha", TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA}, // 128-bit AES encryption with ECDHE-ECDSA and a SHA1 MAC
    1:  {"security.ssl3.ecdhe_ecdsa_des_ede3_sha", TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA}, // 168-bit Triple DES with ECDHE-ECDSA and a SHA1 MAC
    1:  {"security.ssl3.ecdhe_ecdsa_rc4_128_sha", TLS_ECDHE_ECDSA_WITH_RC4_128_SHA}, // 128-bit RC4 encryption with ECDHE-ECDSA and a SHA1 MAC
    1:  {"security.ssl3.ecdhe_ecdsa_null_sha", TLS_ECDHE_ECDSA_WITH_NULL_SHA}, // No encryption with ECDHE-ECDSA and a SHA1 MAC
    1:  {"security.ssl3.ecdhe_rsa_aes_256_sha", TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA}, // 256-bit AES encryption with ECDHE-RSA and a SHA1 MAC
    1:  {"security.ssl3.ecdhe_rsa_aes_128_sha", TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA}, // 128-bit AES encryption with ECDHE-RSA and a SHA1 MAC
    1:  {"security.ssl3.ecdhe_rsa_des_ede3_sha", TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA}, // 168-bit Triple DES with ECDHE-RSA and a SHA1 MAC
    1:  {"security.ssl3.ecdhe_rsa_rc4_128_sha", TLS_ECDHE_RSA_WITH_RC4_128_SHA}, // 128-bit RC4 encryption with ECDHE-RSA and a SHA1 MAC
    1:  {"security.ssl3.ecdhe_rsa_null_sha", TLS_ECDHE_RSA_WITH_NULL_SHA}, // No encryption with ECDHE-RSA and a SHA1 MAC
    1:  {"security.ssl3.ecdh_ecdsa_aes_256_sha", TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA}, // 256-bit AES encryption with ECDH-ECDSA and a SHA1 MAC
    1:  {"security.ssl3.ecdh_ecdsa_aes_128_sha", TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA}, // 128-bit AES encryption with ECDH-ECDSA and a SHA1 MAC
    1:  {"security.ssl3.ecdh_ecdsa_des_ede3_sha", TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA}, // 168-bit Triple DES with ECDH-ECDSA and a SHA1 MAC
    1:  {"security.ssl3.ecdh_ecdsa_rc4_128_sha", TLS_ECDH_ECDSA_WITH_RC4_128_SHA}, // 128-bit RC4 encryption with ECDH-ECDSA and a SHA1 MAC
    1:  {"security.ssl3.ecdh_ecdsa_null_sha", TLS_ECDH_ECDSA_WITH_NULL_SHA}, // No encryption with ECDH-ECDSA and a SHA1 MAC
    1:  {"security.ssl3.ecdh_rsa_aes_256_sha", TLS_ECDH_RSA_WITH_AES_256_CBC_SHA}, // 256-bit AES encryption with ECDH-RSA and a SHA1 MAC
    1:  {"security.ssl3.ecdh_rsa_aes_128_sha", TLS_ECDH_RSA_WITH_AES_128_CBC_SHA}, // 128-bit AES encryption with ECDH-RSA and a SHA1 MAC
    1:  {"security.ssl3.ecdh_rsa_des_ede3_sha", TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA}, // 168-bit Triple DES with ECDH-RSA and a SHA1 MAC
    1:  {"security.ssl3.ecdh_rsa_rc4_128_sha", TLS_ECDH_RSA_WITH_RC4_128_SHA}, // 128-bit RC4 encryption with ECDH-RSA and a SHA1 MAC
    1:  {"security.ssl3.ecdh_rsa_null_sha", TLS_ECDH_RSA_WITH_NULL_SHA}, // No encryption with ECDH-RSA and a SHA1 MAC
 3982:  {"security.ssl3.dhe_rsa_camellia_128_sha", TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA}, // 128-bit Camellia encryption with RSA, DHE, and a SHA1 MAC
 3982:  {"security.ssl3.dhe_dss_camellia_128_sha", TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA}, // 128-bit Camellia encryption with DSA, DHE, and a SHA1 MAC
 3982:  {"security.ssl3.rsa_camellia_128_sha", TLS_RSA_WITH_CAMELLIA_128_CBC_SHA}, // 128-bit Camellia encryption with RSA and a SHA1 MAC
    1:  {"security.ssl3.dhe_rsa_aes_128_sha", TLS_DHE_RSA_WITH_AES_128_CBC_SHA}, // 128-bit AES encryption with RSA, DHE, and a SHA1 MAC
    1:  {"security.ssl3.dhe_dss_aes_128_sha", TLS_DHE_DSS_WITH_AES_128_CBC_SHA}, // 128-bit AES encryption with DSA, DHE, and a SHA1 MAC
    1:  {"security.ssl3.rsa_aes_128_sha", TLS_RSA_WITH_AES_128_CBC_SHA}, // 128-bit AES encryption with RSA and a SHA1 MAC
    1:  {"security.ssl3.dhe_rsa_des_ede3_sha", SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA}, // 168-bit Triple DES with RSA, DHE, and a SHA1 MAC
    1:  {"security.ssl3.dhe_dss_des_ede3_sha", SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA}, // 168-bit Triple DES with DSA, DHE, and a SHA1 MAC
    1:  {"security.ssl3.dhe_rsa_des_sha", SSL_DHE_RSA_WITH_DES_CBC_SHA}, // 56-bit DES encryption with RSA, DHE, and a SHA1 MAC
    1:  {"security.ssl3.dhe_dss_des_sha", SSL_DHE_DSS_WITH_DES_CBC_SHA}, // 56-bit DES encryption with DSA, DHE, and a SHA1 MAC
    1:  {"security.ssl3.rsa_null_sha", SSL_RSA_WITH_NULL_SHA}, // No encryption with RSA authentication and a SHA1 MAC
    1:  {"security.ssl3.rsa_null_md5", SSL_RSA_WITH_NULL_MD5}, // No encryption with RSA authentication and an MD5 MAC
    1:  {NULL, 0} /* end marker */
    1: };
    1: 
    1: nsresult nsNSSComponent::GetNSSCipherIDFromPrefString(const nsACString &aPrefString, PRUint16 &aCipherId)
    1: {
    1:   for (CipherPref* cp = CipherPrefs; cp->pref; ++cp) {
    1:     if (nsDependentCString(cp->pref) == aPrefString) {
    1:       aCipherId = (PRUint16) cp->id;
    1:       return NS_OK;
    1:     }
    1:   }
    1:   
    1:   return NS_ERROR_NOT_AVAILABLE;
    1: }
    1: 
    1: static void setOCSPOptions(nsIPrefBranch * pref)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   // Set up OCSP //
    1:   PRInt32 ocspEnabled;
    1:   pref->GetIntPref("security.OCSP.enabled", &ocspEnabled);
    1:   switch (ocspEnabled) {
    1:   case 0:
    1:     CERT_DisableOCSPChecking(CERT_GetDefaultCertDB());
    1:     CERT_DisableOCSPDefaultResponder(CERT_GetDefaultCertDB());
    1:     break;
    1:   case 1:
    1:     CERT_EnableOCSPChecking(CERT_GetDefaultCertDB());
    1:     CERT_DisableOCSPDefaultResponder(CERT_GetDefaultCertDB());
    1:     SSL_ClearSessionCache();
    1:     break;
    1:   case 2:
    1:     {
    1:       char *signingCA = nsnull;
    1:       char *url = nsnull;
    1: 
    1:       // Get the signing CA and service url //
    1:       pref->GetCharPref("security.OCSP.signingCA", &signingCA);
    1:       pref->GetCharPref("security.OCSP.URL", &url);
    1: 
    1:       // Set OCSP up
    1:       CERT_EnableOCSPChecking(CERT_GetDefaultCertDB());
    1:       CERT_SetOCSPDefaultResponder(CERT_GetDefaultCertDB(), url, signingCA);
    1:       CERT_EnableOCSPDefaultResponder(CERT_GetDefaultCertDB());
    1:       SSL_ClearSessionCache();
    1: 
    1:       nsMemory::Free(signingCA);
    1:       nsMemory::Free(url);
    1:     }
    1:     break;
    1:   }
 2018:   PRBool ocspRequired;
 2018:   pref->GetBoolPref("security.OCSP.require", &ocspRequired);
 2018:   if (ocspRequired) {
 2018:     CERT_SetOCSPFailureMode(ocspMode_FailureIsVerificationFailure);
 2018:   }
 2018:   else {
 2018:     CERT_SetOCSPFailureMode(ocspMode_FailureIsNotAVerificationFailure);
 2018:   }
    1: }
    1: 
    1: nsresult
    1: nsNSSComponent::PostCRLImportEvent(const nsCSubstring &urlString,
    1:                                    nsIStreamListener *listener)
    1: {
    1:   //Create the event
    1:   nsCOMPtr<nsIRunnable> event = new CRLDownloadEvent(urlString, listener);
    1:   if (!event)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   //Get a handle to the ui thread
    1:   return NS_DispatchToMainThread(event);
    1: }
    1: 
    1: nsresult
    1: nsNSSComponent::DownloadCRLDirectly(nsAutoString url, nsAutoString key)
    1: {
    1:   //This api is meant to support direct interactive update of crl from the crl manager
    1:   //or other such ui.
    1:   nsCOMPtr<nsIStreamListener> listener =
    1:       new PSMContentDownloader(PSMContentDownloader::PKCS7_CRL);
    1:   
    1:   NS_ConvertUTF16toUTF8 url8(url);
    1:   return PostCRLImportEvent(url8, listener);
    1: }
    1: 
    1: nsresult nsNSSComponent::DownloadCrlSilently()
    1: {
    1:   //Add this attempt to the hashtable
    1:   nsStringKey hashKey(mCrlUpdateKey.get());
    1:   crlsScheduledForDownload->Put(&hashKey,(void *)nsnull);
    1:     
    1:   //Set up the download handler
    1:   nsRefPtr<PSMContentDownloader> psmDownloader =
    1:       new PSMContentDownloader(PSMContentDownloader::PKCS7_CRL);
    1:   psmDownloader->setSilentDownload(PR_TRUE);
    1:   psmDownloader->setCrlAutodownloadKey(mCrlUpdateKey);
    1:   
    1:   //Now get the url string
    1:   NS_ConvertUTF16toUTF8 url8(mDownloadURL);
    1:   return PostCRLImportEvent(url8, psmDownloader);
    1: }
    1: 
    1: nsresult nsNSSComponent::getParamsForNextCrlToDownload(nsAutoString *url, PRTime *time, nsAutoString *key)
    1: {
    1:   const char *updateEnabledPref = CRL_AUTOUPDATE_ENABLED_PREF;
    1:   const char *updateTimePref = CRL_AUTOUPDATE_TIME_PREF;
    1:   const char *updateURLPref = CRL_AUTOUPDATE_URL_PREF;
    1:   char **allCrlsToBeUpdated;
    1:   PRUint32 noOfCrls;
    1:   PRTime nearestUpdateTime = 0;
    1:   nsAutoString crlKey;
    1:   char *tempUrl;
    1:   nsresult rv;
    1:   
    1:   nsCOMPtr<nsIPrefBranch> pref = do_GetService(NS_PREFSERVICE_CONTRACTID,&rv);
    1:   if(NS_FAILED(rv)){
    1:     return rv;
    1:   }
    1: 
    1:   rv = pref->GetChildList(updateEnabledPref, &noOfCrls, &allCrlsToBeUpdated);
    1:   if ( (NS_FAILED(rv)) || (noOfCrls==0) ){
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   for(PRUint32 i=0;i<noOfCrls;i++) {
17116:     //First check if update pref is enabled for this crl
17116:     PRBool autoUpdateEnabled = PR_FALSE;
17116:     rv = pref->GetBoolPref(*(allCrlsToBeUpdated+i), &autoUpdateEnabled);
17116:     if (NS_FAILED(rv) || !autoUpdateEnabled) {
17116:       continue;
17116:     }
17116: 
    1:     nsAutoString tempCrlKey;
    1: 
    1:     //Now, generate the crl key. Same key would be used as hashkey as well
    1:     nsCAutoString enabledPrefCString(*(allCrlsToBeUpdated+i));
    1:     enabledPrefCString.ReplaceSubstring(updateEnabledPref,".");
    1:     tempCrlKey.AssignWithConversion(enabledPrefCString.get());
    1:       
    1:     //Check if this crl has already been scheduled. Its presence in the hashtable
    1:     //implies that it has been scheduled already this client session, and
    1:     //is either in the process of being downloaded, or its download failed
    1:     //for some reason. In the second case, we will not retry in the current client session
    1:     nsStringKey hashKey(tempCrlKey.get());
    1:     if(crlsScheduledForDownload->Exists(&hashKey)){
    1:       continue;
    1:     }
    1: 
    1:     char *tempTimeString;
    1:     PRTime tempTime;
    1:     nsCAutoString timingPrefCString(updateTimePref);
    1:     timingPrefCString.AppendWithConversion(tempCrlKey);
    1:     rv = pref->GetCharPref(timingPrefCString.get(), &tempTimeString);
    1:     if (NS_FAILED(rv)){
    1:       continue;
    1:     }
    1:     rv = PR_ParseTimeString(tempTimeString,PR_TRUE, &tempTime);
    1:     nsMemory::Free(tempTimeString);
    1:     if (NS_FAILED(rv)){
    1:       continue;
    1:     }
    1: 
    1:     if(nearestUpdateTime == 0 || tempTime < nearestUpdateTime){
    1:       nsCAutoString urlPrefCString(updateURLPref);
    1:       urlPrefCString.AppendWithConversion(tempCrlKey);
    1:       rv = pref->GetCharPref(urlPrefCString.get(), &tempUrl);
    1:       if (NS_FAILED(rv) || (!tempUrl)){
    1:         continue;
    1:       }
    1:       nearestUpdateTime = tempTime;
    1:       crlKey = tempCrlKey;
    1:     }
    1:   }
    1: 
    1:   if(noOfCrls > 0)
    1:     NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(noOfCrls, allCrlsToBeUpdated);
    1: 
    1:   if(nearestUpdateTime > 0){
    1:     *time = nearestUpdateTime;
    1:     url->AssignWithConversion((const char *)tempUrl);
    1:     nsMemory::Free(tempUrl);
    1:     *key = crlKey;
    1:     rv = NS_OK;
    1:   } else{
    1:     rv = NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNSSComponent::Notify(nsITimer *timer)
    1: {
    1:   nsresult rv;
    1: 
    1:   //Timer has fired. So set the flag accordingly
    1:   PR_Lock(mCrlTimerLock);
    1:   crlDownloadTimerOn = PR_FALSE;
    1:   PR_Unlock(mCrlTimerLock);
    1: 
    1:   //First, handle this download
    1:   rv = DownloadCrlSilently();
    1: 
    1:   //Dont Worry if successful or not
    1:   //Set the next timer
    1:   DefineNextTimer();
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNSSComponent::RemoveCrlFromList(nsAutoString key)
    1: {
    1:   nsStringKey hashKey(key.get());
    1:   if(crlsScheduledForDownload->Exists(&hashKey)){
    1:     crlsScheduledForDownload->Remove(&hashKey);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNSSComponent::DefineNextTimer()
    1: {
    1:   PRTime nextFiring;
    1:   PRTime now = PR_Now();
    1:   PRUint64 diff;
    1:   PRUint32 interval;
    1:   PRUint32 primaryDelay = CRL_AUTOUPDATE_DEFAULT_DELAY;
    1:   nsresult rv;
    1: 
    1:   if(!mTimer){
    1:     mTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
    1:     if(NS_FAILED(rv))
    1:       return rv;
    1:   }
    1: 
    1:   //If some timer is already running, cancel it. Thus, the request that came last,
    1:   //wins. This would ensure that in no way we end up setting two different timers
    1:   //This part should be synchronized because this function might be called from separate
    1:   //threads
    1: 
    1:   //Lock the lock
    1:   PR_Lock(mCrlTimerLock);
    1: 
17116:   if (crlDownloadTimerOn) {
    1:     mTimer->Cancel();
    1:   }
    1: 
    1:   rv = getParamsForNextCrlToDownload(&mDownloadURL, &nextFiring, &mCrlUpdateKey);
    1:   //If there are no more crls to be updated any time in future
    1:   if(NS_FAILED(rv)){
    1:     //Free the lock and return - no error - just implies nothing to schedule
    1:     PR_Unlock(mCrlTimerLock);
    1:     return NS_OK;
    1:   }
    1:      
    1:   //Define the firing interval, from NOW
    1:   if ( now < nextFiring) {
    1:     LL_SUB(diff,nextFiring,now);
    1:     LL_L2UI(interval, diff);
    1:     //Now, we are doing 32 operations - so, don't need LL_ functions...
    1:     interval = interval/PR_USEC_PER_MSEC;
    1:   }else {
    1:     interval = primaryDelay;
    1:   }
    1:   
 3233:   mTimer->InitWithCallback(static_cast<nsITimerCallback*>(this), 
    1:                            interval,
    1:                            nsITimer::TYPE_ONE_SHOT);
    1:   crlDownloadTimerOn = PR_TRUE;
    1:   //Release
    1:   PR_Unlock(mCrlTimerLock);
    1: 
    1:   return NS_OK;
    1: 
    1: }
    1: 
    1: //Note that the StopCRLUpdateTimer and InitializeCRLUpdateTimer functions should never be called
    1: //simultaneously from diff threads - they are NOT threadsafe. But, since there is no chance of 
    1: //that happening, there is not much benefit it trying to make it so at this point
    1: nsresult
    1: nsNSSComponent::StopCRLUpdateTimer()
    1: {
    1:   
    1:   //If it is at all running. 
17116:   if (mUpdateTimerInitialized) {
    1:     if(crlsScheduledForDownload != nsnull){
    1:       crlsScheduledForDownload->Reset();
    1:       delete crlsScheduledForDownload;
    1:       crlsScheduledForDownload = nsnull;
    1:     }
    1: 
    1:     PR_Lock(mCrlTimerLock);
17116:     if (crlDownloadTimerOn) {
    1:       mTimer->Cancel();
    1:     }
    1:     crlDownloadTimerOn = PR_FALSE;
    1:     PR_Unlock(mCrlTimerLock);
    1:     PR_DestroyLock(mCrlTimerLock);
    1: 
    1:     mUpdateTimerInitialized = PR_FALSE;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNSSComponent::InitializeCRLUpdateTimer()
    1: {
    1:   nsresult rv;
    1:     
    1:   //First check if this is already initialized. Then we stop it.
17116:   if (!mUpdateTimerInitialized) {
    1:     mTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
    1:     if(NS_FAILED(rv)){
    1:       return rv;
    1:     }
    1:     crlsScheduledForDownload = new nsHashtable(16, PR_TRUE);
    1:     mCrlTimerLock = PR_NewLock();
    1:     DefineNextTimer();
    1:     mUpdateTimerInitialized = PR_TRUE;  
    1:   } 
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: #ifdef XP_MACOSX
    1: void
    1: nsNSSComponent::TryCFM2MachOMigration(nsIFile *cfmPath, nsIFile *machoPath)
    1: {
    1:   // We will modify the parameters.
    1:   //
    1:   // If neither cert7.db, cert8.db, key3.db, are available, 
    1:   // copy from filenames that were used in the old days
    1:   // test for key3.db first, since a new profile might only contain cert8.db, 
    1:   // but not cert7.db - this optimizes number of tests
    1: 
    1:   NS_NAMED_LITERAL_CSTRING(cstr_key3db, "key3.db");
    1:   NS_NAMED_LITERAL_CSTRING(cstr_cert7db, "cert7.db");
    1:   NS_NAMED_LITERAL_CSTRING(cstr_cert8db, "cert8.db");
    1:   NS_NAMED_LITERAL_CSTRING(cstr_keydatabase3, "Key Database3");
    1:   NS_NAMED_LITERAL_CSTRING(cstr_certificate7, "Certificates7");
    1:   NS_NAMED_LITERAL_CSTRING(cstr_certificate8, "Certificates8");
    1: 
    1:   PRBool bExists;
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsIFile> macho_key3db;
    1:   rv = machoPath->Clone(getter_AddRefs(macho_key3db));
    1:   if (NS_FAILED(rv)) {
    1:     return;
    1:   }
    1: 
    1:   macho_key3db->AppendNative(cstr_key3db);
    1:   rv = macho_key3db->Exists(&bExists);
    1:   if (NS_FAILED(rv) || bExists) {
    1:     return;
    1:   }
    1: 
    1:   nsCOMPtr<nsIFile> macho_cert7db;
    1:   rv = machoPath->Clone(getter_AddRefs(macho_cert7db));
    1:   if (NS_FAILED(rv)) {
    1:     return;
    1:   }
    1: 
    1:   macho_cert7db->AppendNative(cstr_cert7db);
    1:   rv = macho_cert7db->Exists(&bExists);
    1:   if (NS_FAILED(rv) || bExists) {
    1:     return;
    1:   }
    1: 
    1:   nsCOMPtr<nsIFile> macho_cert8db;
    1:   rv = machoPath->Clone(getter_AddRefs(macho_cert8db));
    1:   if (NS_FAILED(rv)) {
    1:     return;
    1:   }
    1: 
    1:   macho_cert8db->AppendNative(cstr_cert8db);
    1:   rv = macho_cert7db->Exists(&bExists);
    1:   if (NS_FAILED(rv) || bExists) {
    1:     return;
    1:   }
    1: 
    1:   // None of the new files exist. Try to copy any available old files.
    1: 
    1:   nsCOMPtr<nsIFile> cfm_key3;
    1:   rv = cfmPath->Clone(getter_AddRefs(cfm_key3));
    1:   if (NS_FAILED(rv)) {
    1:     return;
    1:   }
    1: 
    1:   cfm_key3->AppendNative(cstr_keydatabase3);
    1:   rv = cfm_key3->Exists(&bExists);
    1:   if (NS_FAILED(rv)) {
    1:     return;
    1:   }
    1: 
    1:   if (bExists) {
    1:     cfm_key3->CopyToFollowingLinksNative(machoPath, cstr_key3db);
    1:   }
    1: 
    1:   nsCOMPtr<nsIFile> cfm_cert7;
    1:   rv = cfmPath->Clone(getter_AddRefs(cfm_cert7));
    1:   if (NS_FAILED(rv)) {
    1:     return;
    1:   }
    1: 
    1:   cfm_cert7->AppendNative(cstr_certificate7);
    1:   rv = cfm_cert7->Exists(&bExists);
    1:   if (NS_FAILED(rv)) {
    1:     return;
    1:   }
    1: 
    1:   if (bExists) {
    1:     cfm_cert7->CopyToFollowingLinksNative(machoPath, cstr_cert7db);
    1:   }
    1: 
    1:   nsCOMPtr<nsIFile> cfm_cert8;
    1:   rv = cfmPath->Clone(getter_AddRefs(cfm_cert8));
    1:   if (NS_FAILED(rv)) {
    1:     return;
    1:   }
    1: 
    1:   cfm_cert8->AppendNative(cstr_certificate8);
    1:   rv = cfm_cert8->Exists(&bExists);
    1:   if (NS_FAILED(rv)) {
    1:     return;
    1:   }
    1: 
    1:   if (bExists) {
    1:     cfm_cert8->CopyToFollowingLinksNative(machoPath, cstr_cert8db);
    1:   }
    1: }
    1: #endif
    1: 
    1: nsresult
    1: nsNSSComponent::InitializeNSS(PRBool showWarningBox)
    1: {
    1:   // Can be called both during init and profile change.
    1:   // Needs mutex protection.
    1: 
    1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsNSSComponent::InitializeNSS\n"));
    1: 
 8680:   // If we ever run into this assertion, we must update the values
 8680:   // in nsINSSErrorsService.idl
 8680:   PR_STATIC_ASSERT(nsINSSErrorsService::NSS_SEC_ERROR_BASE == SEC_ERROR_BASE
 8680:                    && nsINSSErrorsService::NSS_SEC_ERROR_LIMIT == SEC_ERROR_LIMIT
 8680:                    && nsINSSErrorsService::NSS_SSL_ERROR_BASE == SSL_ERROR_BASE
 8680:                    && nsINSSErrorsService::NSS_SSL_ERROR_LIMIT == SSL_ERROR_LIMIT);
 8680: 
    1:   // variables used for flow control within this function
    1: 
    1:   enum { problem_none, problem_no_rw, problem_no_security_at_all }
    1:     which_nss_problem = problem_none;
    1: 
    1:   {
    1:     nsAutoLock lock(mutex);
    1: 
    1:     // Init phase 1, prepare own variables used for NSS
    1: 
    1:     if (mNSSInitialized) {
    1:       PR_ASSERT(!"Trying to initialize NSS twice"); // We should never try to 
    1:                                                     // initialize NSS more than
    1:                                                     // once in a process.
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:     
    1:     nsresult rv;
    1:     nsCAutoString profileStr;
    1:     nsCOMPtr<nsIFile> profilePath;
    1: 
    1:     rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
    1:                                 getter_AddRefs(profilePath));
    1:     if (NS_FAILED(rv)) {
    1:       PR_LOG(gPIPNSSLog, PR_LOG_ERROR, ("Unable to get profile directory\n"));
    1:       ConfigureInternalPKCS11Token();
    1:       SECStatus init_rv = NSS_NoDB_Init(NULL);
    1:       if (init_rv != SECSuccess)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:     }
    1:     else
    1:     {
    1: 
    1:   // XP_MAC == CFM
    1:   // XP_MACOSX == MachO
    1: 
    1:   #if defined(XP_MAC) && defined(XP_MACOSX)
    1:   #error "This code assumes XP_MAC and XP_MACOSX will never be defined at the same time"
    1:   #endif
    1: 
    1:   #if defined(XP_MAC) || defined(XP_MACOSX)
    1:     // On Mac CFM we place all NSS DBs in the Security
    1:     // Folder in the profile directory.
    1:     nsCOMPtr<nsIFile> cfmSecurityPath;
    1:     cfmSecurityPath = profilePath; // alias for easier code reading
    1:     cfmSecurityPath->AppendNative(NS_LITERAL_CSTRING("Security"));
    1:   #endif
    1: 
    1:   #if defined(XP_MAC)
    1:     // on CFM, cfmSecurityPath and profilePath point to the same oject
    1:     profilePath->Create(nsIFile::DIRECTORY_TYPE, 0); //This is for Mac, don't worry about
    1:                                                      //permissions.
    1:   #elif defined(XP_MACOSX)
    1:     // On MachO, we need to access both directories,
    1:     // and therefore need separate nsIFile instances.
    1:     // Keep cfmSecurityPath instance, obtain new instance for MachO profilePath.
    1:     rv = cfmSecurityPath->GetParent(getter_AddRefs(profilePath));
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1:   #endif
    1: 
    1:     rv = profilePath->GetNativePath(profileStr);
    1:     if (NS_FAILED(rv)) 
    1:       return rv;
    1: 
25625:     hashTableCerts = PL_NewHashTable( 0, certHashtable_keyHash, certHashtable_keyCompare,
25625:       certHashtable_valueCompare, 0, 0 );
25625: 
    1:   #if defined(XP_MACOSX)
    1:     // function may modify the parameters
    1:     // ignore return code from conversion, we continue anyway
    1:     TryCFM2MachOMigration(cfmSecurityPath, profilePath);
    1:   #endif
    1: 
    1:     PRBool supress_warning_preference = PR_FALSE;
    1:     rv = mPrefBranch->GetBoolPref("security.suppress_nss_rw_impossible_warning", &supress_warning_preference);
    1: 
    1:     if (NS_FAILED(rv)) {
    1:       supress_warning_preference = PR_FALSE;
    1:     }
    1: 
    1:     // init phase 2, init calls to NSS library
    1: 
    1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("NSS Initialization beginning\n"));
    1: 
    1:     // The call to ConfigureInternalPKCS11Token needs to be done before NSS is initialized, 
    1:     // but affects only static data.
    1:     // If we could assume i18n will not change between profiles, one call per application
    1:     // run were sufficient. As I can't predict what happens in the future, let's repeat
    1:     // this call for every re-init of NSS.
    1: 
    1:     ConfigureInternalPKCS11Token();
    1: 
    1:     SECStatus init_rv = ::NSS_InitReadWrite(profileStr.get());
    1: 
    1:     if (init_rv != SECSuccess) {
    1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("can not init NSS r/w in %s\n", profileStr.get()));
    1: 
    1:       if (supress_warning_preference) {
    1:         which_nss_problem = problem_none;
    1:       }
    1:       else {
    1:         which_nss_problem = problem_no_rw;
    1:       }
    1: 
    1:       // try to init r/o
    1:       init_rv = NSS_Init(profileStr.get());
    1: 
    1:       if (init_rv != SECSuccess) {
    1:         PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("can not init in r/o either\n"));
    1:         which_nss_problem = problem_no_security_at_all;
    1: 
    1:         init_rv = NSS_NoDB_Init(profileStr.get());
    1:         if (init_rv != SECSuccess)
    1:           return NS_ERROR_NOT_AVAILABLE;
    1:       }
    1:     } // have profile dir
    1:     } // lock
    1: 
    1:     // init phase 3, only if phase 2 was successful
    1: 
    1:     if (problem_no_security_at_all != which_nss_problem) {
    1: 
    1:       mNSSInitialized = PR_TRUE;
    1: 
    1:       ::NSS_SetDomesticPolicy();
    1:       //  SSL_EnableCipher(SSL_RSA_WITH_NULL_MD5, SSL_ALLOWED);
    1:       //  SSL_EnableCipher(SSL_RSA_WITH_NULL_SHA, SSL_ALLOWED);
    1: 
    1:       PK11_SetPasswordFunc(PK11PasswordPrompt);
    1: 
    1:       // Register an observer so we can inform NSS when these prefs change
    1:       nsCOMPtr<nsIPrefBranch2> pbi = do_QueryInterface(mPrefBranch);
    1:       pbi->AddObserver("security.", this, PR_FALSE);
    1: 
    1:       PRBool enabled;
    1:       mPrefBranch->GetBoolPref("security.enable_ssl2", &enabled);
    1:       SSL_OptionSetDefault(SSL_ENABLE_SSL2, enabled);
    1:       SSL_OptionSetDefault(SSL_V2_COMPATIBLE_HELLO, enabled);
    1:       mPrefBranch->GetBoolPref("security.enable_ssl3", &enabled);
    1:       SSL_OptionSetDefault(SSL_ENABLE_SSL3, enabled);
    1:       mPrefBranch->GetBoolPref("security.enable_tls", &enabled);
    1:       SSL_OptionSetDefault(SSL_ENABLE_TLS, enabled);
    1: 
12290:       // Configure TLS session tickets
12290:       mPrefBranch->GetBoolPref("security.enable_tls_session_tickets", &enabled);
12290:       SSL_OptionSetDefault(SSL_ENABLE_SESSION_TICKETS, enabled);
12290: 
    1:       // Disable any ciphers that NSS might have enabled by default
    1:       for (PRUint16 i = 0; i < SSL_NumImplementedCiphers; ++i)
    1:       {
    1:         PRUint16 cipher_id = SSL_ImplementedCiphers[i];
    1:         SSL_CipherPrefSetDefault(cipher_id, PR_FALSE);
    1:       }
    1: 
    1:       // Now only set SSL/TLS ciphers we knew about at compile time
    1:       for (CipherPref* cp = CipherPrefs; cp->pref; ++cp) {
    1:         mPrefBranch->GetBoolPref(cp->pref, &enabled);
    1: 
    1:         SSL_CipherPrefSetDefault(cp->id, enabled);
    1:       }
    1: 
    1:       // Enable ciphers for PKCS#12
    1:       SEC_PKCS12EnableCipher(PKCS12_RC4_40, 1);
    1:       SEC_PKCS12EnableCipher(PKCS12_RC4_128, 1);
    1:       SEC_PKCS12EnableCipher(PKCS12_RC2_CBC_40, 1);
    1:       SEC_PKCS12EnableCipher(PKCS12_RC2_CBC_128, 1);
    1:       SEC_PKCS12EnableCipher(PKCS12_DES_56, 1);
    1:       SEC_PKCS12EnableCipher(PKCS12_DES_EDE3_168, 1);
    1:       SEC_PKCS12SetPreferredCipher(PKCS12_DES_EDE3_168, 1);
    1:       PORT_SetUCS2_ASCIIConversionFunction(pip_ucs2_ascii_conversion_fn);
    1: 
    1:       // Set up OCSP //
    1:       setOCSPOptions(mPrefBranch);
27009:       RegisterMyOCSPAIAInfoCallback();
    1: 
    1:       mHttpForNSS.initTable();
    1:       mHttpForNSS.registerHttpClient();
    1: 
    1:       InstallLoadableRoots();
    1: 
    1:       LaunchSmartCardThreads();
    1: 
    1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("NSS Initialization done\n"));
    1:     }
    1:   }
    1: 
    1:   if (problem_none != which_nss_problem) {
    1:     nsString message;
    1: 
    1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("NSS problem, trying to bring up GUI error message\n"));
    1: 
    1:     // We might want to use different messages, depending on what failed.
    1:     // For now, let's use the same message.
    1:     if (showWarningBox) {
    1:       ShowAlert(ai_nss_init_problem);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNSSComponent::ShutdownNSS()
    1: {
    1:   // Can be called both during init and profile change,
    1:   // needs mutex protection.
    1:   
    1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsNSSComponent::ShutdownNSS\n"));
    1: 
    1:   nsAutoLock lock(mutex);
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (hashTableCerts) {
    1:     PL_HashTableEnumerateEntries(hashTableCerts, certHashtable_clearEntry, 0);
    1:     PL_HashTableDestroy(hashTableCerts);
    1:     hashTableCerts = nsnull;
    1:   }
    1: 
    1:   if (mNSSInitialized) {
    1:     mNSSInitialized = PR_FALSE;
    1: 
    1:     PK11_SetPasswordFunc((PK11PasswordFunc)nsnull);
    1:     mHttpForNSS.unregisterHttpClient();
27009:     UnregisterMyOCSPAIAInfoCallback();
    1: 
    1:     if (mPrefBranch) {
    1:       nsCOMPtr<nsIPrefBranch2> pbi = do_QueryInterface(mPrefBranch);
    1:       pbi->RemoveObserver("security.", this);
    1:     }
    1: 
    1:     ShutdownSmartCardThreads();
    1:     SSL_ClearSessionCache();
28675:     if (mClientAuthRememberService) {
28675:       mClientAuthRememberService->ClearRememberedDecisions();
28675:     }
    1:     UnloadLoadableRoots();
13140:     CleanupIdentityInfo();
    1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("evaporating psm resources\n"));
    1:     mShutdownObjectList->evaporateAllNSSResources();
    1:     if (SECSuccess != ::NSS_Shutdown()) {
    1:       PR_LOG(gPIPNSSLog, PR_LOG_ALWAYS, ("NSS SHUTDOWN FAILURE\n"));
    1:       rv = NS_ERROR_FAILURE;
    1:     }
    1:     else {
    1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("NSS shutdown =====>> OK <<=====\n"));
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1:  
    1: NS_IMETHODIMP
    1: nsNSSComponent::Init()
    1: {
    1:   // No mutex protection.
    1:   // Assume Init happens before any concurrency on "this" can start.
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("Beginning NSS initialization\n"));
    1: 
25625:   if (!mutex || !mShutdownObjectList)
    1:   {
    1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("NSS init, out of memory in constructor\n"));
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   rv = InitializePIPNSSBundle();
    1:   if (NS_FAILED(rv)) {
    1:     PR_LOG(gPIPNSSLog, PR_LOG_ERROR, ("Unable to create pipnss bundle.\n"));
    1:     return rv;
    1:   }      
    1: 
14244:   // Access our string bundles now, this prevents assertions from I/O
14244:   // - nsStandardURL not thread-safe
14244:   // - wrong thread: 'NS_IsMainThread()' in nsIOService.cpp
14244:   // when loading error strings on the SSL threads.
14244:   {
14244:     NS_NAMED_LITERAL_STRING(dummy_name, "dummy");
14244:     nsXPIDLString result;
14244:     mPIPNSSBundle->GetStringFromName(dummy_name.get(),
14244:                                      getter_Copies(result));
14244:     mNSSErrorsBundle->GetStringFromName(dummy_name.get(),
14244:                                         getter_Copies(result));
14244:   }
14244: 
    1:   if (!mPrefBranch) {
    1:     mPrefBranch = do_GetService(NS_PREFSERVICE_CONTRACTID);
    1:     NS_ASSERTION(mPrefBranch, "Unable to get pref service");
    1:   }
    1: 
    1:   // Do that before NSS init, to make sure we won't get unloaded.
    1:   RegisterObservers();
    1: 
    1:   rv = InitializeNSS(PR_TRUE); // ok to show a warning box on failure
    1:   if (NS_FAILED(rv)) {
    1:     PR_LOG(gPIPNSSLog, PR_LOG_ERROR, ("Unable to Initialize NSS.\n"));
25625: 
25625:     DeregisterObservers();
25625:     mPIPNSSBundle = nsnull;
    1:     return rv;
    1:   }
    1: 
25625:   nsSSLIOLayerHelpers::Init();
25625: 
28675:   mClientAuthRememberService = new nsClientAuthRememberService;
28675:   if (mClientAuthRememberService)
28675:     mClientAuthRememberService->Init();
28675: 
25625:   mSSLThread = new nsSSLThread();
25625:   if (mSSLThread)
25625:     mSSLThread->startThread();
25625:   mCertVerificationThread = new nsCertVerificationThread();
25625:   if (mCertVerificationThread)
25625:     mCertVerificationThread->startThread();
25625: 
25625:   if (!mSSLThread || !mCertVerificationThread)
25625:   {
25625:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("NSS init, could not create threads\n"));
25625: 
25625:     DeregisterObservers();
25625:     mPIPNSSBundle = nsnull;
25625:     return NS_ERROR_OUT_OF_MEMORY;
25625:   }
25625: 
    1:   InitializeCRLUpdateTimer();
    1:   RegisterPSMContentListener();
    1: 
    1:   nsCOMPtr<nsIEntropyCollector> ec
    1:       = do_GetService(NS_ENTROPYCOLLECTOR_CONTRACTID);
    1: 
    1:   nsCOMPtr<nsIBufEntropyCollector> bec;
    1: 
    1:   if (ec) {
    1:     bec = do_QueryInterface(ec);
    1:   }
    1: 
    1:   NS_ASSERTION(bec, "No buffering entropy collector.  "
    1:                     "This means no entropy will be collected.");
    1:   if (bec) {
    1:     bec->ForwardTo(this);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: /* nsISupports Implementation for the class */
    1: NS_IMPL_THREADSAFE_ISUPPORTS7(nsNSSComponent,
    1:                               nsISignatureVerifier,
    1:                               nsIEntropyCollector,
    1:                               nsINSSComponent,
    1:                               nsIObserver,
    1:                               nsISupportsWeakReference,
    1:                               nsITimerCallback,
    1:                               nsINSSErrorsService)
    1: 
    1: 
    1: /* Callback functions for decoder. For now, use empty/default functions. */
    1: static void ContentCallback(void *arg, 
    1:                                            const char *buf,
    1:                                            unsigned long len)
    1: {
    1: }
    1: 
    1: static PK11SymKey * GetDecryptKeyCallback(void *arg, 
    1:                                                  SECAlgorithmID *algid)
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: static PRBool DecryptionAllowedCallback(SECAlgorithmID *algid,  
    1:                                                PK11SymKey *bulkkey)
    1: {
    1:   return SECMIME_DecryptionAllowed(algid, bulkkey);
    1: }
    1: 
    1: static void * GetPasswordKeyCallback(void *arg, void *handle)
    1: {
    1:   return NULL;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNSSComponent::VerifySignature(const char* aRSABuf, PRUint32 aRSABufLen,
    1:                                 const char* aPlaintext, PRUint32 aPlaintextLen,
    1:                                 PRInt32* aErrorCode,
    1:                                 nsIPrincipal** aPrincipal)
    1: {
    1:   if (!aPrincipal || !aErrorCode) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1: 
    1:   *aErrorCode = 0;
    1:   *aPrincipal = nsnull;
    1: 
    1:   nsNSSShutDownPreventionLock locker;
    1:   SEC_PKCS7ContentInfo * p7_info = nsnull; 
    1:   unsigned char hash[SHA1_LENGTH]; 
    1: 
    1:   SECItem item;
    1:   item.type = siEncodedCertBuffer;
    1:   item.data = (unsigned char*)aRSABuf;
    1:   item.len = aRSABufLen;
    1:   p7_info = SEC_PKCS7DecodeItem(&item,
    1:                                 ContentCallback, nsnull,
    1:                                 GetPasswordKeyCallback, nsnull,
    1:                                 GetDecryptKeyCallback, nsnull,
    1:                                 DecryptionAllowedCallback);
    1: 
    1:   if (!p7_info) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // Make sure we call SEC_PKCS7DestroyContentInfo after this point;
    1:   // otherwise we leak data in p7_info
    1:   
    1:   //-- If a plaintext was provided, hash it.
    1:   SECItem digest;
    1:   digest.data = nsnull;
    1:   digest.len = 0;
    1: 
    1:   if (aPlaintext) {
    1:     HASHContext* hash_ctxt;
    1:     PRUint32 hashLen = 0;
    1: 
    1:     hash_ctxt = HASH_Create(HASH_AlgSHA1);
    1:     HASH_Begin(hash_ctxt);
    1:     HASH_Update(hash_ctxt,(const unsigned char*)aPlaintext, aPlaintextLen);
    1:     HASH_End(hash_ctxt, hash, &hashLen, SHA1_LENGTH); 
    1:     HASH_Destroy(hash_ctxt);
    1: 
    1:     digest.data = hash;
    1:     digest.len = SHA1_LENGTH;
    1:   }
    1: 
    1:   //-- Verify signature
    1:   PRBool rv = SEC_PKCS7VerifyDetachedSignature(p7_info, certUsageObjectSigner,
    1:                                                &digest, HASH_AlgSHA1, PR_FALSE);
17116:   if (!rv) {
    1:     *aErrorCode = PR_GetError();
    1:   }
    1: 
    1:   // Get the signing cert //
    1:   CERTCertificate *cert = p7_info->content.signedData->signerInfos[0]->cert;
    1:   nsresult rv2 = NS_OK;
    1:   if (cert) {
    1:     // Use |do { } while (0);| as a "more C++-ish" thing than goto;
    1:     // this way we don't have to worry about goto across variable
    1:     // declarations.  We have no loops in this code, so it's OK.
    1:     do {
    1:       nsCOMPtr<nsIX509Cert> pCert = new nsNSSCertificate(cert);
    1:       if (!pCert) {
    1:         rv2 = NS_ERROR_OUT_OF_MEMORY;
    1:         break;
    1:       }
    1: 
    1:       if (!mScriptSecurityManager) {
    1:         nsAutoLock lock(mutex);
    1:         // re-test the condition to prevent double initialization
    1:         if (!mScriptSecurityManager) {
    1:           mScriptSecurityManager = 
    1:             do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv2);
    1:           if (NS_FAILED(rv2)) {
    1:             break;
    1:           }
    1:         }
    1:       }
    1: 
    1:       //-- Create a certificate principal with id and organization data
    1:       nsAutoString fingerprint;
    1:       rv2 = pCert->GetSha1Fingerprint(fingerprint);
    1:       if (NS_FAILED(rv2)) {
    1:         break;
    1:       }
    1:       nsAutoString orgName;
    1:       rv2 = pCert->GetOrganization(orgName);
    1:       if (NS_FAILED(rv2)) {
    1:         break;
    1:       }
    1:       nsAutoString subjectName;
    1:       rv2 = pCert->GetSubjectName(subjectName);
    1:       if (NS_FAILED(rv2)) {
    1:         break;
    1:       }
    1:     
    1:       nsCOMPtr<nsIPrincipal> certPrincipal;
    1:       rv2 = mScriptSecurityManager->
    1:         GetCertificatePrincipal(NS_ConvertUTF16toUTF8(fingerprint),
    1:                                 NS_ConvertUTF16toUTF8(subjectName),
    1:                                 NS_ConvertUTF16toUTF8(orgName),
    1:                                 pCert, nsnull, getter_AddRefs(certPrincipal));
    1:       if (NS_FAILED(rv2) || !certPrincipal) {
    1:         break;
    1:       }
    1:       
    1:       certPrincipal.swap(*aPrincipal);
    1:     } while (0);
    1:   }
    1: 
    1:   SEC_PKCS7DestroyContentInfo(p7_info);
    1: 
    1:   return rv2;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNSSComponent::RandomUpdate(void *entropy, PRInt32 bufLen)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1: 
    1:   // Asynchronous event happening often,
    1:   // must not interfere with initialization or profile switch.
    1:   
    1:   nsAutoLock lock(mutex);
    1: 
    1:   if (!mNSSInitialized)
    1:       return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   PK11_RandomUpdate(entropy, bufLen);
    1:   return NS_OK;
    1: }
    1: 
    1: #define PROFILE_CHANGE_NET_TEARDOWN_TOPIC "profile-change-net-teardown"
    1: #define PROFILE_CHANGE_NET_RESTORE_TOPIC "profile-change-net-restore"
    1: #define PROFILE_APPROVE_CHANGE_TOPIC "profile-approve-change"
    1: #define PROFILE_CHANGE_TEARDOWN_TOPIC "profile-change-teardown"
    1: #define PROFILE_CHANGE_TEARDOWN_VETO_TOPIC "profile-change-teardown-veto"
    1: #define PROFILE_BEFORE_CHANGE_TOPIC "profile-before-change"
    1: #define PROFILE_AFTER_CHANGE_TOPIC "profile-after-change"
    1: 
    1: NS_IMETHODIMP
    1: nsNSSComponent::Observe(nsISupports *aSubject, const char *aTopic, 
    1:                         const PRUnichar *someData)
    1: {
    1:   if (nsCRT::strcmp(aTopic, PROFILE_APPROVE_CHANGE_TOPIC) == 0) {
 1427:     DoProfileApproveChange(aSubject);
    1:   }
    1:   else if (nsCRT::strcmp(aTopic, PROFILE_CHANGE_TEARDOWN_TOPIC) == 0) {
    1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("in PSM code, receiving change-teardown\n"));
 1427:     DoProfileChangeTeardown(aSubject);
    1:   }
    1:   else if (nsCRT::strcmp(aTopic, PROFILE_CHANGE_TEARDOWN_VETO_TOPIC) == 0) {
    1:     mShutdownObjectList->allowUI();
    1:   }
    1:   else if (nsCRT::strcmp(aTopic, PROFILE_BEFORE_CHANGE_TOPIC) == 0) {
    1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("receiving profile change topic\n"));
 1427:     DoProfileBeforeChange(aSubject);
    1:   }
    1:   else if (nsCRT::strcmp(aTopic, PROFILE_AFTER_CHANGE_TOPIC) == 0) {
 1427:     if (someData && NS_LITERAL_STRING("startup").Equals(someData)) {
 1427:       // The application is initializing against a known profile directory for
 1427:       // the first time during process execution.
 1427:       // However, earlier code execution might have already triggered NSS init.
 1427:       // We must ensure that NSS gets shut down prior to any attempt to init
 1427:       // it again. We use the same cleanup functionality used when switching
 1427:       // profiles. The order of function calls must correspond to the order
 1427:       // of notifications sent by Profile Manager (nsProfile).
 1427:       DoProfileApproveChange(aSubject);
 1427:       DoProfileChangeNetTeardown();
 1427:       DoProfileChangeTeardown(aSubject);
 1427:       DoProfileBeforeChange(aSubject);
 1427:       DoProfileChangeNetRestore();
 1427:     }
    1:   
    1:     PRBool needsInit = PR_TRUE;
    1: 
    1:     {
    1:       nsAutoLock lock(mutex);
    1: 
    1:       if (mNSSInitialized) {
    1:         // We have already initialized NSS before the profile came up,
    1:         // no need to do it again
    1:         needsInit = PR_FALSE;
    1:       }
    1:     }
    1:     
    1:     if (needsInit) {
    1:       if (NS_FAILED(InitializeNSS(PR_FALSE))) { // do not show a warning box on failure
    1:         PR_LOG(gPIPNSSLog, PR_LOG_ERROR, ("Unable to Initialize NSS after profile switch.\n"));
    1:         nsCOMPtr<nsIProfileChangeStatus> status = do_QueryInterface(aSubject);
    1:         if (status) {
    1:           status->ChangeFailed();
    1:         }
    1:       }
    1:     }
    1: 
    1:     InitializeCRLUpdateTimer();
    1:   }
    1:   else if (nsCRT::strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID) == 0) {
    1: 
    1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsNSSComponent: XPCom shutdown observed\n"));
    1: 
    1:     // Cleanup code that requires services, it's too late in destructor.
    1: 
    1:     if (mPSMContentListener) {
    1:       nsresult rv = NS_ERROR_FAILURE;
    1: 
    1:       nsCOMPtr<nsIURILoader> dispatcher(do_GetService(NS_URI_LOADER_CONTRACTID));
    1:       if (dispatcher) {
    1:         rv = dispatcher->UnRegisterContentListener(mPSMContentListener);
    1:       }
    1:       mPSMContentListener = nsnull;
    1:     }
    1: 
    1:     nsCOMPtr<nsIEntropyCollector> ec
    1:         = do_GetService(NS_ENTROPYCOLLECTOR_CONTRACTID);
    1: 
    1:     if (ec) {
    1:       nsCOMPtr<nsIBufEntropyCollector> bec
    1:         = do_QueryInterface(ec);
    1:       if (bec) {
    1:         bec->DontForward();
    1:       }
    1:     }
    1:   }
    1:   else if (nsCRT::strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID) == 0) { 
    1:     nsNSSShutDownPreventionLock locker;
    1:     PRBool clearSessionCache = PR_FALSE;
    1:     PRBool enabled;
    1:     NS_ConvertUTF16toUTF8  prefName(someData);
    1: 
    1:     if (prefName.Equals("security.enable_ssl2")) {
    1:       mPrefBranch->GetBoolPref("security.enable_ssl2", &enabled);
    1:       SSL_OptionSetDefault(SSL_ENABLE_SSL2, enabled);
    1:       SSL_OptionSetDefault(SSL_V2_COMPATIBLE_HELLO, enabled);
    1:       clearSessionCache = PR_TRUE;
    1:     } else if (prefName.Equals("security.enable_ssl3")) {
    1:       mPrefBranch->GetBoolPref("security.enable_ssl3", &enabled);
    1:       SSL_OptionSetDefault(SSL_ENABLE_SSL3, enabled);
    1:       clearSessionCache = PR_TRUE;
    1:     } else if (prefName.Equals("security.enable_tls")) {
    1:       mPrefBranch->GetBoolPref("security.enable_tls", &enabled);
    1:       SSL_OptionSetDefault(SSL_ENABLE_TLS, enabled);
    1:       clearSessionCache = PR_TRUE;
12290:     } else if (prefName.Equals("security.enable_tls_session_tickets")) {
12290:       mPrefBranch->GetBoolPref("security.enable_tls_session_tickets", &enabled);
12290:       SSL_OptionSetDefault(SSL_ENABLE_SESSION_TICKETS, enabled);
 2018:     } else if (prefName.Equals("security.OCSP.enabled")
 2018:                || prefName.Equals("security.OCSP.require")) {
    1:       setOCSPOptions(mPrefBranch);
    1:     } else {
    1:       /* Look through the cipher table and set according to pref setting */
    1:       for (CipherPref* cp = CipherPrefs; cp->pref; ++cp) {
    1:         if (prefName.Equals(cp->pref)) {
    1:           mPrefBranch->GetBoolPref(cp->pref, &enabled);
    1:           SSL_CipherPrefSetDefault(cp->id, enabled);
    1:           clearSessionCache = PR_TRUE;
    1:           break;
    1:         }
    1:       }
    1:     }
    1:     if (clearSessionCache)
    1:       SSL_ClearSessionCache();
    1:   }
    1:   else if (nsCRT::strcmp(aTopic, PROFILE_CHANGE_NET_TEARDOWN_TOPIC) == 0) {
    1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("receiving network teardown topic\n"));
 1427:     DoProfileChangeNetTeardown();
    1:   }
    1:   else if (nsCRT::strcmp(aTopic, PROFILE_CHANGE_NET_RESTORE_TOPIC) == 0) {
    1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("receiving network restore topic\n"));
 1427:     DoProfileChangeNetRestore();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void nsNSSComponent::ShowAlert(AlertIdentifier ai)
    1: {
    1:   nsString message;
    1:   nsresult rv;
    1: 
    1:   switch (ai) {
    1:     case ai_nss_init_problem:
 4289:       rv = GetPIPNSSBundleString("NSSInitProblemX", message);
    1:       break;
    1:     case ai_sockets_still_active:
    1:       rv = GetPIPNSSBundleString("ProfileSwitchSocketsStillActive", message);
    1:       break;
    1:     case ai_crypto_ui_active:
    1:       rv = GetPIPNSSBundleString("ProfileSwitchCryptoUIActive", message);
    1:       break;
    1:     case ai_incomplete_logout:
    1:       rv = GetPIPNSSBundleString("LogoutIncompleteUIActive", message);
    1:       break;
    1:     default:
    1:       return;
    1:   }
    1:   
    1:   if (NS_FAILED(rv))
    1:     return;
    1: 
    1:   nsCOMPtr<nsIWindowWatcher> wwatch(do_GetService(NS_WINDOWWATCHER_CONTRACTID));
    1:   if (!wwatch) {
    1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("can't get window watcher\n"));
    1:   }
    1:   else {
    1:     nsCOMPtr<nsIPrompt> prompter;
    1:     wwatch->GetNewPrompter(0, getter_AddRefs(prompter));
    1:     if (!prompter) {
    1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("can't get window prompter\n"));
    1:     }
    1:     else {
    1:       nsCOMPtr<nsIPrompt> proxyPrompt;
    1:       NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
    1:                            NS_GET_IID(nsIPrompt),
    1:                            prompter, NS_PROXY_SYNC,
    1:                            getter_AddRefs(proxyPrompt));
    1:       if (!proxyPrompt) {
    1:         PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("can't get proxy for nsIPrompt\n"));
    1:       }
    1:       else {
    1:         proxyPrompt->Alert(nsnull, message.get());
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult nsNSSComponent::LogoutAuthenticatedPK11()
    1: {
20772:   nsCOMPtr<nsICertOverrideService> icos = 
20772:     do_GetService("@mozilla.org/security/certoverride;1");
20772:     
20772:   nsCertOverrideService *cos = 
20772:     reinterpret_cast<nsCertOverrideService*>(icos.get());
20772: 
20772:   if (cos) {
20772:     cos->RemoveAllTemporaryOverrides();
20772:   }
20772: 
28675:   if (mClientAuthRememberService) {
28675:     mClientAuthRememberService->ClearRememberedDecisions();
28675:   }
28675: 
    1:   return mShutdownObjectList->doPK11Logout();
    1: }
    1: 
    1: nsresult
    1: nsNSSComponent::RegisterObservers()
    1: {
    1:   // Happens once during init only, no mutex protection.
    1: 
    1:   nsCOMPtr<nsIObserverService> observerService(do_GetService("@mozilla.org/observer-service;1"));
    1:   NS_ASSERTION(observerService, "could not get observer service");
    1:   if (observerService) {
    1:     mObserversRegistered = PR_TRUE;
    1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsNSSComponent: adding observers\n"));
    1: 
    1:     // We are a service.
    1:     // Once we are loaded, don't allow being removed from memory.
    1:     // This makes sense, as initializing NSS is expensive.
    1: 
    1:     // By using PR_FALSE for parameter ownsWeak in AddObserver,
    1:     // we make sure that we won't get unloaded until the application shuts down.
    1: 
    1:     observerService->AddObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID, PR_FALSE);
    1: 
    1:     observerService->AddObserver(this, PROFILE_APPROVE_CHANGE_TOPIC, PR_FALSE);
    1:     observerService->AddObserver(this, PROFILE_CHANGE_TEARDOWN_TOPIC, PR_FALSE);
    1:     observerService->AddObserver(this, PROFILE_CHANGE_TEARDOWN_VETO_TOPIC, PR_FALSE);
    1:     observerService->AddObserver(this, PROFILE_BEFORE_CHANGE_TOPIC, PR_FALSE);
    1:     observerService->AddObserver(this, PROFILE_AFTER_CHANGE_TOPIC, PR_FALSE);
    1:     observerService->AddObserver(this, PROFILE_CHANGE_NET_TEARDOWN_TOPIC, PR_FALSE);
    1:     observerService->AddObserver(this, PROFILE_CHANGE_NET_RESTORE_TOPIC, PR_FALSE);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
25625: nsresult
25625: nsNSSComponent::DeregisterObservers()
25625: {
25625:   if (!mObserversRegistered)
25625:     return NS_OK;
25625: 
25625:   nsCOMPtr<nsIObserverService> observerService(do_GetService("@mozilla.org/observer-service;1"));
25625:   NS_ASSERTION(observerService, "could not get observer service");
25625:   if (observerService) {
25625:     mObserversRegistered = PR_FALSE;
25625:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsNSSComponent: removing observers\n"));
25625: 
25625:     observerService->RemoveObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID);
25625: 
25625:     observerService->RemoveObserver(this, PROFILE_APPROVE_CHANGE_TOPIC);
25625:     observerService->RemoveObserver(this, PROFILE_CHANGE_TEARDOWN_TOPIC);
25625:     observerService->RemoveObserver(this, PROFILE_CHANGE_TEARDOWN_VETO_TOPIC);
25625:     observerService->RemoveObserver(this, PROFILE_BEFORE_CHANGE_TOPIC);
25625:     observerService->RemoveObserver(this, PROFILE_AFTER_CHANGE_TOPIC);
25625:     observerService->RemoveObserver(this, PROFILE_CHANGE_NET_TEARDOWN_TOPIC);
25625:     observerService->RemoveObserver(this, PROFILE_CHANGE_NET_RESTORE_TOPIC);
25625:   }
25625:   return NS_OK;
25625: }
25625: 
    1: NS_IMETHODIMP
    1: nsNSSComponent::RememberCert(CERTCertificate *cert)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1: 
    1:   // Must not interfere with init / shutdown / profile switch.
    1: 
    1:   nsAutoLock lock(mutex);
    1: 
    1:   if (!hashTableCerts || !cert)
    1:     return NS_OK;
    1:   
    1:   void *found = PL_HashTableLookup(hashTableCerts, (void*)&cert->certKey);
    1:   
    1:   if (found) {
    1:     // we remember that cert already
    1:     return NS_OK;
    1:   }
    1:   
    1:   CERTCertificate *myDupCert = CERT_DupCertificate(cert);
    1:   
    1:   if (!myDupCert)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   
    1:   if (!PL_HashTableAdd(hashTableCerts, (void*)&myDupCert->certKey, myDupCert)) {
    1:     CERT_DestroyCertificate(myDupCert);
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: #define EXPECTED_SEC_ERROR_BASE (-0x2000)
    1: #define EXPECTED_SSL_ERROR_BASE (-0x3000)
    1: 
    1: #if SEC_ERROR_BASE != EXPECTED_SEC_ERROR_BASE || SSL_ERROR_BASE != EXPECTED_SSL_ERROR_BASE
    1: #error "Unexpected change of error code numbers in lib NSS, please adjust the mapping code"
    1: /*
    1:  * Please ensure the NSS error codes are mapped into the positive range 0x1000 to 0xf000
    1:  * Search for NS_ERROR_MODULE_SECURITY to ensure there are no conflicts.
    1:  * The current code also assumes that NSS library error codes are negative.
    1:  */
    1: #endif
    1: 
    1: NS_IMETHODIMP
    1: nsNSSComponent::IsNSSErrorCode(PRInt32 aNSPRCode, PRBool *_retval)
    1: {
    1:   if (!_retval)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   *_retval = IS_SEC_ERROR(aNSPRCode) || IS_SSL_ERROR(aNSPRCode);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNSSComponent::GetXPCOMFromNSSError(PRInt32 aNSPRCode, nsresult *aXPCOMErrorCode)
    1: {
    1:   if (!IS_SEC_ERROR(aNSPRCode) && !IS_SSL_ERROR(aNSPRCode))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   if (!aXPCOMErrorCode)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1:   // The error codes within each module may be a 16 bit value.
    1:   // For simplicity let's use the positive value of the NSS code.
    1: 
    1:   *aXPCOMErrorCode =
    1:     NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_SECURITY,
    1:                               -1 * aNSPRCode);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
 7252: nsNSSComponent::GetErrorClass(nsresult aXPCOMErrorCode, PRUint32 *aErrorClass)
 7252: {
 7252:   NS_ENSURE_ARG(aErrorClass);
 7252: 
 7252:   if (NS_ERROR_GET_MODULE(aXPCOMErrorCode) != NS_ERROR_MODULE_SECURITY
 7252:       || NS_ERROR_GET_SEVERITY(aXPCOMErrorCode) != NS_ERROR_SEVERITY_ERROR)
 7252:     return NS_ERROR_FAILURE;
 7252:   
 7252:   PRInt32 aNSPRCode = -1 * NS_ERROR_GET_CODE(aXPCOMErrorCode);
 7252: 
 7252:   if (!IS_SEC_ERROR(aNSPRCode) && !IS_SSL_ERROR(aNSPRCode))
 7252:     return NS_ERROR_FAILURE;
 7252: 
 7252:   switch (aNSPRCode)
 7252:   {
 7252:     case SEC_ERROR_UNKNOWN_ISSUER:
 7252:     case SEC_ERROR_CA_CERT_INVALID:
 7252:     case SEC_ERROR_UNTRUSTED_ISSUER:
 7252:     case SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE:
 7252:     case SEC_ERROR_UNTRUSTED_CERT:
13929:     case SEC_ERROR_INADEQUATE_KEY_USAGE:
 7252:     case SSL_ERROR_BAD_CERT_DOMAIN:
 7252:     case SEC_ERROR_EXPIRED_CERTIFICATE:
 7252:       *aErrorClass = ERROR_CLASS_BAD_CERT;
 7252:       break;
 7252:     default:
 7252:       *aErrorClass = ERROR_CLASS_SSL_PROTOCOL;
 7252:       break;
 7252:   }
 7252:   return NS_OK;
 7252: }
 7252: 
 7252: NS_IMETHODIMP
    1: nsNSSComponent::GetErrorMessage(nsresult aXPCOMErrorCode, nsAString &aErrorMessage)
    1: {
    1:   if (NS_ERROR_GET_MODULE(aXPCOMErrorCode) != NS_ERROR_MODULE_SECURITY
    1:       || NS_ERROR_GET_SEVERITY(aXPCOMErrorCode) != NS_ERROR_SEVERITY_ERROR)
    1:     return NS_ERROR_FAILURE;
    1:   
    1:   PRInt32 aNSPRCode = -1 * NS_ERROR_GET_CODE(aXPCOMErrorCode);
    1: 
    1:   if (!IS_SEC_ERROR(aNSPRCode) && !IS_SSL_ERROR(aNSPRCode))
    1:     return NS_ERROR_FAILURE;
    1: 
 2850:   nsCOMPtr<nsIStringBundle> theBundle = mPIPNSSBundle;
    1:   const char *id_str = nsNSSErrors::getOverrideErrorStringName(aNSPRCode);
    1: 
 2850:   if (!id_str) {
    1:     id_str = nsNSSErrors::getDefaultErrorStringName(aNSPRCode);
 2850:     theBundle = mNSSErrorsBundle;
 2850:   }
 2850: 
 2850:   if (!id_str || !theBundle)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsAutoString msg;
    1:   nsresult rv =
 2850:     theBundle->GetStringFromName(NS_ConvertASCIItoUTF16(id_str).get(),
    1:                                  getter_Copies(msg));
    1:   if (NS_SUCCEEDED(rv)) {
    1:     aErrorMessage = msg;
    1:   }
    1:   return rv;
    1: }
    1: 
 1427: void
 1427: nsNSSComponent::DoProfileApproveChange(nsISupports* aSubject)
 1427: {
 1427:   if (mShutdownObjectList->isUIActive()) {
 1427:     ShowAlert(ai_crypto_ui_active);
 1427:     nsCOMPtr<nsIProfileChangeStatus> status = do_QueryInterface(aSubject);
 1427:     if (status) {
 1427:       status->VetoChange();
 1427:     }
 1427:   }
 1427: }
 1427: 
 1427: void
 1427: nsNSSComponent::DoProfileChangeNetTeardown()
 1427: {
 1427:   if (mSSLThread)
 1427:     mSSLThread->requestExit();
 1427:   if (mCertVerificationThread)
 1427:     mCertVerificationThread->requestExit();
 1427:   mIsNetworkDown = PR_TRUE;
 1427: }
 1427: 
 1427: void
 1427: nsNSSComponent::DoProfileChangeTeardown(nsISupports* aSubject)
 1427: {
 1427:   PRBool callVeto = PR_FALSE;
 1427: 
 1427:   if (!mShutdownObjectList->ifPossibleDisallowUI()) {
 1427:     callVeto = PR_TRUE;
 1427:     ShowAlert(ai_crypto_ui_active);
 1427:   }
 1427:   else if (mShutdownObjectList->areSSLSocketsActive()) {
 1427:     callVeto = PR_TRUE;
 1427:     ShowAlert(ai_sockets_still_active);
 1427:   }
 1427: 
 1427:   if (callVeto) {
 1427:     nsCOMPtr<nsIProfileChangeStatus> status = do_QueryInterface(aSubject);
 1427:     if (status) {
 1427:       status->VetoChange();
 1427:     }
 1427:   }
 1427: }
 1427: 
 1427: void
 1427: nsNSSComponent::DoProfileBeforeChange(nsISupports* aSubject)
 1427: {
 1427:   NS_ASSERTION(mIsNetworkDown, "nsNSSComponent relies on profile manager to wait for synchronous shutdown of all network activity");
 1427: 
 1427:   PRBool needsCleanup = PR_TRUE;
 1427: 
 1427:   {
 1427:     nsAutoLock lock(mutex);
 1427: 
 1427:     if (!mNSSInitialized) {
 1427:       // Make sure we don't try to cleanup if we have already done so.
 1427:       // This makes sure we behave safely, in case we are notified
 1427:       // multiple times.
 1427:       needsCleanup = PR_FALSE;
 1427:     }
 1427:   }
 1427:     
 1427:   StopCRLUpdateTimer();
 1427: 
 1427:   if (needsCleanup) {
 1427:     if (NS_FAILED(ShutdownNSS())) {
 1427:       nsCOMPtr<nsIProfileChangeStatus> status = do_QueryInterface(aSubject);
 1427:       if (status) {
 1427:         status->ChangeFailed();
 1427:       }
 1427:     }
 1427:   }
 1427:   mShutdownObjectList->allowUI();
 1427: }
 1427: 
 1427: void
 1427: nsNSSComponent::DoProfileChangeNetRestore()
 1427: {
 1427:   delete mSSLThread;
 1427:   mSSLThread = new nsSSLThread();
 1427:   if (mSSLThread)
 1427:     mSSLThread->startThread();
 1427:   delete mCertVerificationThread;
 1427:   mCertVerificationThread = new nsCertVerificationThread();
 1427:   if (mCertVerificationThread)
 1427:     mCertVerificationThread->startThread();
 1427:   mIsNetworkDown = PR_FALSE;
 1427: }
 1427: 
28675: NS_IMETHODIMP
28675: nsNSSComponent::GetClientAuthRememberService(nsClientAuthRememberService **cars)
28675: {
28675:   NS_ENSURE_ARG_POINTER(cars);
28675:   NS_IF_ADDREF(*cars = mClientAuthRememberService);
28675:   return NS_OK;
28675: }
28675: 
29543: NS_IMETHODIMP
29543: nsNSSComponent::IsNSSInitialized(PRBool *initialized)
29543: {
29543:   nsAutoLock lock(mutex);
29543:   *initialized = mNSSInitialized;
29543:   return NS_OK;
29543: }
29543: 
    1: //---------------------------------------------
    1: // Implementing nsICryptoHash
    1: //---------------------------------------------
    1: 
    1: nsCryptoHash::nsCryptoHash()
    1:   : mHashContext(nsnull)
    1: {
    1: }
    1: 
    1: nsCryptoHash::~nsCryptoHash()
    1: {
    1:   if (mHashContext)
    1:     HASH_Destroy(mHashContext);
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS1(nsCryptoHash, nsICryptoHash)
    1: 
    1: NS_IMETHODIMP 
    1: nsCryptoHash::Init(PRUint32 algorithm)
    1: {
    1:   if (mHashContext)
    1:     HASH_Destroy(mHashContext);
    1: 
    1:   mHashContext = HASH_Create((HASH_HashType) algorithm);
    1:   if (!mHashContext)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1:   HASH_Begin(mHashContext);
    1:   return NS_OK; 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCryptoHash::InitWithString(const nsACString & aAlgorithm)
    1: {
    1:   if (aAlgorithm.LowerCaseEqualsLiteral("md2"))
    1:     return Init(nsICryptoHash::MD2);
    1: 
    1:   if (aAlgorithm.LowerCaseEqualsLiteral("md5"))
    1:     return Init(nsICryptoHash::MD5);
    1: 
    1:   if (aAlgorithm.LowerCaseEqualsLiteral("sha1"))
    1:     return Init(nsICryptoHash::SHA1);
    1: 
    1:   if (aAlgorithm.LowerCaseEqualsLiteral("sha256"))
    1:     return Init(nsICryptoHash::SHA256);
    1: 
    1:   if (aAlgorithm.LowerCaseEqualsLiteral("sha384"))
    1:     return Init(nsICryptoHash::SHA384);
    1: 
    1:   if (aAlgorithm.LowerCaseEqualsLiteral("sha512"))
    1:     return Init(nsICryptoHash::SHA512);
    1: 
    1:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCryptoHash::Update(const PRUint8 *data, PRUint32 len)
    1: {
    1:   if (!mHashContext)
    1:     return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   HASH_Update(mHashContext, data, len);
    1:   return NS_OK; 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCryptoHash::UpdateFromStream(nsIInputStream *data, PRUint32 len)
    1: {
    1:   if (!mHashContext)
    1:     return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   if (!data)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1:   PRUint32 n;
    1:   nsresult rv = data->Available(&n);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   // if the user has passed PR_UINT32_MAX, then read
    1:   // everything in the stream
    1: 
    1:   if (len == PR_UINT32_MAX)
    1:     len = n;
    1: 
    1:   // So, if the stream has NO data available for the hash,
    1:   // or if the data available is less then what the caller
    1:   // requested, we can not fulfill the hash update.  In this
    1:   // case, just return NS_ERROR_NOT_AVAILABLE indicating
    1:   // that there is not enough data in the stream to satisify
    1:   // the request.
    1: 
    1:   if (n == 0 || n < len)
    1:     return NS_ERROR_NOT_AVAILABLE;
    1:   
    1:   char buffer[NS_CRYPTO_HASH_BUFFER_SIZE];
12341:   PRUint32 read, readLimit;
    1:   
    1:   while(NS_SUCCEEDED(rv) && len>0)
    1:   {
12341:     readLimit = PR_MIN(NS_CRYPTO_HASH_BUFFER_SIZE, len);
12341:     
12341:     rv = data->Read(buffer, readLimit, &read);
    1:     
    1:     if (NS_SUCCEEDED(rv))
    1:       rv = Update((const PRUint8*)buffer, read);
    1:     
    1:     len -= read;
    1:   }
    1:   
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCryptoHash::Finish(PRBool ascii, nsACString & _retval)
    1: {
    1:   if (!mHashContext)
    1:     return NS_ERROR_NOT_INITIALIZED;
    1:   
    1:   PRUint32 hashLen = 0;
    1:   unsigned char buffer[HASH_LENGTH_MAX];
    1:   unsigned char* pbuffer = buffer;
    1: 
 2253:   HASH_End(mHashContext, pbuffer, &hashLen, HASH_LENGTH_MAX);
    1:   HASH_Destroy(mHashContext);
    1: 
    1:   mHashContext = nsnull;
    1: 
    1:   if (ascii)
    1:   {
    1:     char *asciiData = BTOA_DataToAscii(buffer, hashLen);
12341:     NS_ENSURE_TRUE(asciiData, NS_ERROR_OUT_OF_MEMORY);
12341: 
    1:     _retval.Assign(asciiData);
    1:     PORT_Free(asciiData);
    1:   }
    1:   else
    1:   {
    1:     _retval.Assign((const char*)buffer, hashLen);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
12341: //---------------------------------------------
12341: // Implementing nsICryptoHMAC
12341: //---------------------------------------------
12341: 
12341: NS_IMPL_ISUPPORTS1(nsCryptoHMAC, nsICryptoHMAC)
12341: 
12341: nsCryptoHMAC::nsCryptoHMAC()
12341: {
12341:   mHMACContext = nsnull;
12341: }
12341: 
12341: nsCryptoHMAC::~nsCryptoHMAC()
12341: {
12341:   if (mHMACContext)
12341:     PK11_DestroyContext(mHMACContext, PR_TRUE);
12341: }
12341: 
13256: /* void init (in unsigned long aAlgorithm, in nsIKeyObject aKeyObject); */
13256: NS_IMETHODIMP nsCryptoHMAC::Init(PRUint32 aAlgorithm, nsIKeyObject *aKeyObject)
12341: {
12341:   if (mHMACContext)
12341:   {
12341:     PK11_DestroyContext(mHMACContext, PR_TRUE);
12341:     mHMACContext = nsnull;
12341:   }
12341: 
12341:   CK_MECHANISM_TYPE HMACMechType;
12341:   switch (aAlgorithm)
12341:   {
12341:   case nsCryptoHMAC::MD2:
12341:     HMACMechType = CKM_MD2_HMAC; break;
12341:   case nsCryptoHMAC::MD5:
12341:     HMACMechType = CKM_MD5_HMAC; break;
12341:   case nsCryptoHMAC::SHA1:
12341:     HMACMechType = CKM_SHA_1_HMAC; break;
12341:   case nsCryptoHMAC::SHA256:
12341:     HMACMechType = CKM_SHA256_HMAC; break;
12341:   case nsCryptoHMAC::SHA384:
12341:     HMACMechType = CKM_SHA384_HMAC; break;
12341:   case nsCryptoHMAC::SHA512:
12341:     HMACMechType = CKM_SHA512_HMAC; break;
12341:   default:
12341:     return NS_ERROR_INVALID_ARG;
12341:   }
12341: 
13256:   NS_ENSURE_ARG_POINTER(aKeyObject);
13256: 
13256:   nsresult rv;
13256: 
13256:   PRInt16 keyType;
13256:   rv = aKeyObject->GetType(&keyType);
13256:   NS_ENSURE_SUCCESS(rv, rv);
13256: 
13256:   NS_ENSURE_TRUE(keyType == nsIKeyObject::SYM_KEY, NS_ERROR_INVALID_ARG);
13256: 
13256:   PK11SymKey* key;
13256:   // GetKeyObj doesn't addref the key
13256:   rv = aKeyObject->GetKeyObj((void**)&key);
13256:   NS_ENSURE_SUCCESS(rv, rv);
12341: 
12341:   SECItem rawData;
12341:   rawData.data = 0;
12341:   rawData.len = 0;
12341:   mHMACContext = PK11_CreateContextBySymKey(
12341:       HMACMechType, CKA_SIGN, key, &rawData);
12341:   NS_ENSURE_TRUE(mHMACContext, NS_ERROR_FAILURE);
12341: 
12341:   SECStatus ss = PK11_DigestBegin(mHMACContext);
12341:   NS_ENSURE_TRUE(ss == SECSuccess, NS_ERROR_FAILURE);
12341: 
12341:   return NS_OK;
12341: }
12341: 
12341: /* void update ([array, size_is (aLen), const] in octet aData, in unsigned long aLen); */
12341: NS_IMETHODIMP nsCryptoHMAC::Update(const PRUint8 *aData, PRUint32 aLen)
12341: {
12341:   if (!mHMACContext)
12341:     return NS_ERROR_NOT_INITIALIZED;
12341: 
12341:   if (!aData)
12341:     return NS_ERROR_INVALID_ARG;
12341: 
12341:   SECStatus ss = PK11_DigestOp(mHMACContext, aData, aLen);
12341:   NS_ENSURE_TRUE(ss == SECSuccess, NS_ERROR_FAILURE);
12341:   
12341:   return NS_OK;
12341: }
12341: 
12341: /* void updateFromStream (in nsIInputStream aStream, in unsigned long aLen); */
12341: NS_IMETHODIMP nsCryptoHMAC::UpdateFromStream(nsIInputStream *aStream, PRUint32 aLen)
12341: {
12341:   if (!mHMACContext)
12341:     return NS_ERROR_NOT_INITIALIZED;
12341: 
12341:   if (!aStream)
12341:     return NS_ERROR_INVALID_ARG;
12341: 
12341:   PRUint32 n;
12341:   nsresult rv = aStream->Available(&n);
12341:   if (NS_FAILED(rv))
12341:     return rv;
12341: 
12341:   // if the user has passed PR_UINT32_MAX, then read
12341:   // everything in the stream
12341: 
12341:   if (aLen == PR_UINT32_MAX)
12341:     aLen = n;
12341: 
12341:   // So, if the stream has NO data available for the hash,
12341:   // or if the data available is less then what the caller
12341:   // requested, we can not fulfill the HMAC update.  In this
12341:   // case, just return NS_ERROR_NOT_AVAILABLE indicating
12341:   // that there is not enough data in the stream to satisify
12341:   // the request.
12341: 
12341:   if (n == 0 || n < aLen)
12341:     return NS_ERROR_NOT_AVAILABLE;
12341:   
12341:   char buffer[NS_CRYPTO_HASH_BUFFER_SIZE];
12341:   PRUint32 read, readLimit;
12341:   
12341:   while(NS_SUCCEEDED(rv) && aLen > 0)
12341:   {
12341:     readLimit = PR_MIN(NS_CRYPTO_HASH_BUFFER_SIZE, aLen);
12341:     
12341:     rv = aStream->Read(buffer, readLimit, &read);
12341:     if (read == 0)
12341:       return NS_BASE_STREAM_CLOSED;
12341:     
12341:     if (NS_SUCCEEDED(rv))
12341:       rv = Update((const PRUint8*)buffer, read);
12341:     
12341:     aLen -= read;
12341:   }
12341:   
12341:   return rv;
12341: }
12341: 
12341: /* ACString finish (in PRBool aASCII); */
12341: NS_IMETHODIMP nsCryptoHMAC::Finish(PRBool aASCII, nsACString & _retval)
12341: {
12341:   if (!mHMACContext)
12341:     return NS_ERROR_NOT_INITIALIZED;
12341:   
12341:   PRUint32 hashLen = 0;
12341:   unsigned char buffer[HASH_LENGTH_MAX];
12341:   unsigned char* pbuffer = buffer;
12341: 
12341:   PK11_DigestFinal(mHMACContext, pbuffer, &hashLen, HASH_LENGTH_MAX);
12341:   if (aASCII)
12341:   {
12341:     char *asciiData = BTOA_DataToAscii(buffer, hashLen);
12341:     NS_ENSURE_TRUE(asciiData, NS_ERROR_OUT_OF_MEMORY);
12341: 
12341:     _retval.Assign(asciiData);
12341:     PORT_Free(asciiData);
12341:   }
12341:   else
12341:   {
12341:     _retval.Assign((const char*)buffer, hashLen);
12341:   }
12341: 
12341:   return NS_OK;
12341: }
12341: 
12341: /* void reset (); */
12341: NS_IMETHODIMP nsCryptoHMAC::Reset()
12341: {
12341:   SECStatus ss = PK11_DigestBegin(mHMACContext);
12341:   NS_ENSURE_TRUE(ss == SECSuccess, NS_ERROR_FAILURE);
12341: 
12341:   return NS_OK;
12341: }
    1: 
    1: NS_IMPL_ISUPPORTS1(PipUIContext, nsIInterfaceRequestor)
    1: 
    1: PipUIContext::PipUIContext()
    1: {
    1: }
    1: 
    1: PipUIContext::~PipUIContext()
    1: {
    1: }
    1: 
    1: /* void getInterface (in nsIIDRef uuid, [iid_is (uuid), retval] out nsQIResult result); */
    1: NS_IMETHODIMP PipUIContext::GetInterface(const nsIID & uuid, void * *result)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (uuid.Equals(NS_GET_IID(nsIPrompt))) {
    1:     nsCOMPtr<nsIPrompt> prompter;
    1:     nsCOMPtr<nsIWindowWatcher> wwatch(do_GetService(NS_WINDOWWATCHER_CONTRACTID));
    1:     if (wwatch) {
    1:       wwatch->GetNewPrompter(0, getter_AddRefs(prompter));
    1:       if (prompter) {
    1:         nsCOMPtr<nsIPrompt> proxyPrompt;
    1:         NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
    1:                              NS_GET_IID(nsIPrompt),
    1:                              prompter, NS_PROXY_SYNC,
    1:                              getter_AddRefs(proxyPrompt));
    1:         if (!proxyPrompt) return NS_ERROR_FAILURE;
    1:         *result = proxyPrompt;
    1:         NS_ADDREF((nsIPrompt*)*result);
    1:       }
    1:     }
    1:   } else {
    1:     rv = NS_ERROR_NO_INTERFACE;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult 
    1: getNSSDialogs(void **_result, REFNSIID aIID, const char *contract)
    1: {
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsISupports> svc = do_GetService(contract, &rv);
    1:   if (NS_FAILED(rv)) 
    1:     return rv;
    1: 
    1:   rv = NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
    1:                             aIID, svc, NS_PROXY_SYNC,
    1:                             _result);
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: setPassword(PK11SlotInfo *slot, nsIInterfaceRequestor *ctx)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   nsresult rv = NS_OK;
    1:   
    1:   if (PK11_NeedUserInit(slot)) {
    1:     nsITokenPasswordDialogs *dialogs;
    1:     PRBool canceled;
    1:     NS_ConvertUTF8toUTF16 tokenName(PK11_GetTokenName(slot));
    1: 
    1:     rv = getNSSDialogs((void**)&dialogs,
    1:                        NS_GET_IID(nsITokenPasswordDialogs),
    1:                        NS_TOKENPASSWORDSDIALOG_CONTRACTID);
    1: 
    1:     if (NS_FAILED(rv)) goto loser;
    1: 
    1:     {
    1:       nsPSMUITracker tracker;
    1:       if (tracker.isUIForbidden()) {
    1:         rv = NS_ERROR_NOT_AVAILABLE;
    1:       }
    1:       else {
    1:         rv = dialogs->SetPassword(ctx,
    1:                                   tokenName.get(),
    1:                                   &canceled);
    1:       }
    1:     }
    1:     NS_RELEASE(dialogs);
    1:     if (NS_FAILED(rv)) goto loser;
    1: 
    1:     if (canceled) { rv = NS_ERROR_NOT_AVAILABLE; goto loser; }
    1:   }
    1:  loser:
    1:   return rv;
    1: }
    1: 
    1: 
    1: PSMContentDownloader::PSMContentDownloader(PRUint32 type)
    1:   : mByteData(nsnull),
    1:     mType(type),
    1:     mDoSilentDownload(PR_FALSE)
    1: {
    1: }
    1: 
    1: PSMContentDownloader::~PSMContentDownloader()
    1: {
    1:   if (mByteData)
    1:     nsMemory::Free(mByteData);
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS2(PSMContentDownloader, nsIStreamListener, nsIRequestObserver)
    1: 
    1: const PRInt32 kDefaultCertAllocLength = 2048;
    1: 
    1: NS_IMETHODIMP
    1: PSMContentDownloader::OnStartRequest(nsIRequest* request, nsISupports* context)
    1: {
    1:   nsresult rv;
    1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("CertDownloader::OnStartRequest\n"));
    1:   nsCOMPtr<nsIChannel> channel(do_QueryInterface(request));
    1:   if (!channel) return NS_ERROR_FAILURE;
    1: 
    1:   // Get the URI //
    1:   channel->GetURI(getter_AddRefs(mURI));
    1: 
    1:   PRInt32 contentLength;
    1:   rv = channel->GetContentLength(&contentLength);
    1:   if (NS_FAILED(rv) || contentLength <= 0)
    1:     contentLength = kDefaultCertAllocLength;
    1:   
    1:   mBufferOffset = 0;
    1:   mBufferSize = 0;
    1:   mByteData = (char*) nsMemory::Alloc(contentLength);
    1:   if (!mByteData)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   
    1:   mBufferSize = contentLength;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PSMContentDownloader::OnDataAvailable(nsIRequest* request,
    1:                                 nsISupports* context,
    1:                                 nsIInputStream *aIStream,
    1:                                 PRUint32 aSourceOffset,
    1:                                 PRUint32 aLength)
    1: {
    1:   if (!mByteData)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   
    1:   PRUint32 amt;
    1:   nsresult err;
    1:   //Do a check to see if we need to allocate more memory.
    1:   if ((mBufferOffset + (PRInt32)aLength) > mBufferSize) {
    1:       size_t newSize = (mBufferOffset + aLength) *2; // grow some more than needed
    1:       char *newBuffer;
    1:       newBuffer = (char*)nsMemory::Realloc(mByteData, newSize);
    1:       if (newBuffer == nsnull) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:       }
    1:       mByteData = newBuffer;
    1:       mBufferSize = newSize;
    1:   }
    1:   
    1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("CertDownloader::OnDataAvailable\n"));
    1:   do {
    1:     err = aIStream->Read(mByteData+mBufferOffset,
    1:                          aLength, &amt);
    1:     if (NS_FAILED(err)) return err;
    1:     if (amt == 0) break;
    1:     
    1:     aLength -= amt;
    1:     mBufferOffset += amt;
    1:     
    1:   } while (aLength > 0);
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PSMContentDownloader::OnStopRequest(nsIRequest* request,
    1:                               nsISupports* context,
    1:                               nsresult aStatus)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   //Check if the download succeeded - it might have failed due to
    1:   //network issues, etc.
    1:   if (NS_FAILED(aStatus)){
    1:     handleContentDownloadError(aStatus);
    1:     return aStatus;
    1:   }
    1: 
    1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("CertDownloader::OnStopRequest\n"));
    1: 
    1:   nsCOMPtr<nsIX509CertDB> certdb;
    1:   nsCOMPtr<nsICRLManager> crlManager;
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIInterfaceRequestor> ctx = new PipUIContext();
    1: 
    1:   switch (mType) {
    1:   case PSMContentDownloader::X509_CA_CERT:
    1:   case PSMContentDownloader::X509_USER_CERT:
    1:   case PSMContentDownloader::X509_EMAIL_CERT:
    1:     certdb = do_GetService(NS_X509CERTDB_CONTRACTID);
    1:     break;
    1: 
    1:   case PSMContentDownloader::PKCS7_CRL:
    1:     crlManager = do_GetService(NS_CRLMANAGER_CONTRACTID);
    1: 
    1:   default:
    1:     break;
    1:   }
    1: 
    1:   switch (mType) {
    1:   case PSMContentDownloader::X509_CA_CERT:
    1:     return certdb->ImportCertificates((PRUint8*)mByteData, mBufferOffset, mType, ctx); 
    1:   case PSMContentDownloader::X509_USER_CERT:
    1:     return certdb->ImportUserCertificate((PRUint8*)mByteData, mBufferOffset, ctx);
    1:   case PSMContentDownloader::X509_EMAIL_CERT:
    1:     return certdb->ImportEmailCertificate((PRUint8*)mByteData, mBufferOffset, ctx); 
    1:   case PSMContentDownloader::PKCS7_CRL:
    1:     return crlManager->ImportCrl((PRUint8*)mByteData, mBufferOffset, mURI, SEC_CRL_TYPE, mDoSilentDownload, mCrlAutoDownloadKey.get());
    1:   default:
    1:     rv = NS_ERROR_FAILURE;
    1:     break;
    1:   }
    1:   
    1:   return rv;
    1: }
    1: 
    1: 
    1: nsresult
    1: PSMContentDownloader::handleContentDownloadError(nsresult errCode)
    1: {
    1:   nsString tmpMessage;
    1:   nsresult rv;
    1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
    1:   if(NS_FAILED(rv)){
    1:     return rv;
    1:   }
    1:       
    1:   //Handling errors for crl download only, for now.
    1:   switch (mType){
    1:   case PSMContentDownloader::PKCS7_CRL:
    1: 
    1:     //TO DO: Handle network errors in details
    1:     //XXXXXXXXXXXXXXXXXX
    1:     nssComponent->GetPIPNSSBundleString("CrlImportFailureNetworkProblem", tmpMessage);
    1:       
17116:     if (mDoSilentDownload) {
    1:       //This is the case for automatic download. Update failure history
    1:       nsCAutoString updateErrCntPrefStr(CRL_AUTOUPDATE_ERRCNT_PREF);
    1:       nsCAutoString updateErrDetailPrefStr(CRL_AUTOUPDATE_ERRDETAIL_PREF);
    1:       PRUnichar *nameInDb;
    1:       nsCString errMsg;
    1:       PRInt32 errCnt;
    1: 
    1:       nsCOMPtr<nsIPrefBranch> pref = do_GetService(NS_PREFSERVICE_CONTRACTID,&rv);
    1:       if(NS_FAILED(rv)){
    1:         return rv;
    1:       }
    1:       
    1:       nameInDb = (PRUnichar *)mCrlAutoDownloadKey.get();
    1:       updateErrCntPrefStr.AppendWithConversion(nameInDb);
    1:       updateErrDetailPrefStr.AppendWithConversion(nameInDb);  
    1:       errMsg.AssignWithConversion(tmpMessage.get());
    1:       
    1:       rv = pref->GetIntPref(updateErrCntPrefStr.get(),&errCnt);
    1:       if( (NS_FAILED(rv)) || (errCnt == 0) ){
    1:         pref->SetIntPref(updateErrCntPrefStr.get(),1);
    1:       }else{
    1:         pref->SetIntPref(updateErrCntPrefStr.get(),errCnt+1);
    1:       }
    1:       pref->SetCharPref(updateErrDetailPrefStr.get(),errMsg.get());
    1:       nsCOMPtr<nsIPrefService> prefSvc(do_QueryInterface(pref));
    1:       prefSvc->SavePrefFile(nsnull);
    1:     }else{
    1:       nsString message;
    1:       nsCOMPtr<nsIWindowWatcher> wwatch(do_GetService(NS_WINDOWWATCHER_CONTRACTID));
    1:       nsCOMPtr<nsIPrompt> prompter;
    1:       if (wwatch){
    1:         wwatch->GetNewPrompter(0, getter_AddRefs(prompter));
 4289:         nssComponent->GetPIPNSSBundleString("CrlImportFailure1x", message);
    1:         message.Append(NS_LITERAL_STRING("\n").get());
    1:         message.Append(tmpMessage);
    1:         nssComponent->GetPIPNSSBundleString("CrlImportFailure2", tmpMessage);
    1:         message.Append(NS_LITERAL_STRING("\n").get());
    1:         message.Append(tmpMessage);
    1: 
    1:         if(prompter) {
    1:           nsPSMUITracker tracker;
    1:           if (!tracker.isUIForbidden()) {
    1:             prompter->Alert(0, message.get());
    1:           }
    1:         }
    1:       }
    1:     }
    1:     break;
    1:   default:
    1:     break;
    1:   }
    1: 
    1:   return NS_OK;
    1: 
    1: }
    1: 
    1: void 
    1: PSMContentDownloader::setSilentDownload(PRBool flag)
    1: {
    1:   mDoSilentDownload = flag;
    1: }
    1: 
    1: void
    1: PSMContentDownloader::setCrlAutodownloadKey(nsAutoString key)
    1: {
    1:   mCrlAutoDownloadKey = key;
    1: }
    1: 
    1: 
    1: /* other mime types that we should handle sometime:
    1:    
    1:    application/x-pkcs7-crl
    1:    application/x-pkcs7-mime
    1:    application/pkcs7-signature
    1:    application/pre-encrypted
    1:    
    1: */
    1: 
    1: PRUint32
    1: getPSMContentType(const char * aContentType)
    1: { 
    1:   // Don't forget to update RegisterPSMContentListeners in nsNSSModule.cpp 
    1:   // for every supported content type.
    1:   
    1:   if (!nsCRT::strcasecmp(aContentType, "application/x-x509-ca-cert"))
    1:     return PSMContentDownloader::X509_CA_CERT;
    1:   else if (!nsCRT::strcasecmp(aContentType, "application/x-x509-server-cert"))
    1:     return PSMContentDownloader::X509_SERVER_CERT;
    1:   else if (!nsCRT::strcasecmp(aContentType, "application/x-x509-user-cert"))
    1:     return PSMContentDownloader::X509_USER_CERT;
    1:   else if (!nsCRT::strcasecmp(aContentType, "application/x-x509-email-cert"))
    1:     return PSMContentDownloader::X509_EMAIL_CERT;
    1:   else if (!nsCRT::strcasecmp(aContentType, "application/x-pkcs7-crl"))
    1:     return PSMContentDownloader::PKCS7_CRL;
    1:   else if (!nsCRT::strcasecmp(aContentType, "application/x-x509-crl"))
    1:     return PSMContentDownloader::PKCS7_CRL;
    1:   else if (!nsCRT::strcasecmp(aContentType, "application/pkix-crl"))
    1:     return PSMContentDownloader::PKCS7_CRL;
    1:   return PSMContentDownloader::UNKNOWN_TYPE;
    1: }
    1: 
    1: 
    1: NS_IMPL_ISUPPORTS2(PSMContentListener,
    1:                    nsIURIContentListener,
    1:                    nsISupportsWeakReference) 
    1: 
    1: PSMContentListener::PSMContentListener()
    1: {
    1:   mLoadCookie = nsnull;
    1:   mParentContentListener = nsnull;
    1: }
    1: 
    1: PSMContentListener::~PSMContentListener()
    1: {
    1: }
    1: 
    1: nsresult
    1: PSMContentListener::init()
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PSMContentListener::OnStartURIOpen(nsIURI *aURI, PRBool *aAbortOpen)
    1: {
    1:   //if we don't want to handle the URI, return PR_TRUE in
    1:   //*aAbortOpen
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PSMContentListener::IsPreferred(const char * aContentType,
    1:                                  char ** aDesiredContentType,
    1:                                  PRBool * aCanHandleContent)
    1: {
    1:   return CanHandleContent(aContentType, PR_TRUE,
    1:                           aDesiredContentType, aCanHandleContent);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PSMContentListener::CanHandleContent(const char * aContentType,
    1:                                       PRBool aIsContentPreferred,
    1:                                       char ** aDesiredContentType,
    1:                                       PRBool * aCanHandleContent)
    1: {
    1:   PRUint32 type;
    1:   type = getPSMContentType(aContentType);
    1:   if (type == PSMContentDownloader::UNKNOWN_TYPE) {
    1:     *aCanHandleContent = PR_FALSE;
    1:   } else {
    1:     *aCanHandleContent = PR_TRUE;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PSMContentListener::DoContent(const char * aContentType,
    1:                                PRBool aIsContentPreferred,
    1:                                nsIRequest * aRequest,
    1:                                nsIStreamListener ** aContentHandler,
    1:                                PRBool * aAbortProcess)
    1: {
    1:   PSMContentDownloader *downLoader;
    1:   PRUint32 type;
    1:   type = getPSMContentType(aContentType);
    1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("PSMContentListener::DoContent\n"));
    1:   if (type != PSMContentDownloader::UNKNOWN_TYPE) {
    1:     downLoader = new PSMContentDownloader(type);
    1:     if (downLoader) {
    1:       downLoader->QueryInterface(NS_GET_IID(nsIStreamListener), 
    1:                                             (void **)aContentHandler);
    1:       return NS_OK;
    1:     }
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PSMContentListener::GetLoadCookie(nsISupports * *aLoadCookie)
    1: {
    1:   *aLoadCookie = mLoadCookie;
    1:   NS_IF_ADDREF(*aLoadCookie);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PSMContentListener::SetLoadCookie(nsISupports * aLoadCookie)
    1: {
    1:   mLoadCookie = aLoadCookie;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PSMContentListener::GetParentContentListener(nsIURIContentListener ** aContentListener)
    1: {
    1:   *aContentListener = mParentContentListener;
    1:   NS_IF_ADDREF(*aContentListener);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PSMContentListener::SetParentContentListener(nsIURIContentListener * aContentListener)
    1: {
    1:   mParentContentListener = aContentListener;
    1:   return NS_OK;
    1: }
