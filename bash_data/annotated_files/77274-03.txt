    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is PNG Encoding code
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Google Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Brett Wilson <brettw@gmail.com>
    1:  *   Stuart Parmenter <pavlov@pavlov.net>
  779:  *   Justin Dolske <dolske@mozilla.com>
36849:  *   Glenn Randers-Pehrson <glennrp@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
  779: #include "nsCRT.h"
    1: #include "nsPNGEncoder.h"
    1: #include "prmem.h"
  779: #include "prprf.h"
    1: #include "nsString.h"
    1: #include "nsStreamUtils.h"
    1: 
69142: using namespace mozilla;
69142: 
44195: NS_IMPL_THREADSAFE_ISUPPORTS3(nsPNGEncoder, imgIEncoder, nsIInputStream, nsIAsyncInputStream)
    1: 
  779: nsPNGEncoder::nsPNGEncoder() : mPNG(nsnull), mPNGinfo(nsnull),
  779:                                mIsAnimation(PR_FALSE),
47325:                                mFinished(PR_FALSE),
  779:                                mImageBuffer(nsnull), mImageBufferSize(0),
44195:                                mImageBufferUsed(0), mImageBufferReadPoint(0),
47325:                                mCallback(nsnull),
44195:                                mCallbackTarget(nsnull), mNotifyThreshold(0),
69142:                                mReentrantMonitor("nsPNGEncoder.mReentrantMonitor")
    1: {
    1: }
    1: 
    1: nsPNGEncoder::~nsPNGEncoder()
    1: {
    1:   if (mImageBuffer) {
    1:     PR_Free(mImageBuffer);
    1:     mImageBuffer = nsnull;
    1:   }
 7065:   // don't leak if EndImageEncode wasn't called
 7065:   if (mPNG)
 7065:     png_destroy_write_struct(&mPNG, &mPNGinfo);
    1: }
    1: 
    1: // nsPNGEncoder::InitFromData
    1: //
    1: //    One output option is supported: "transparency=none" means that the
    1: //    output PNG will not have an alpha channel, even if the input does.
    1: //
    1: //    Based partially on gfx/cairo/cairo/src/cairo-png.c
    1: //    See also modules/libimg/png/libpng.txt
    1: 
    1: NS_IMETHODIMP nsPNGEncoder::InitFromData(const PRUint8* aData,
36849:                                          PRUint32 aLength, // (unused,
36849:                                                            // req'd by JS)
    1:                                          PRUint32 aWidth,
    1:                                          PRUint32 aHeight,
    1:                                          PRUint32 aStride,
    1:                                          PRUint32 aInputFormat,
    1:                                          const nsAString& aOutputOptions)
    1: {
77274:   NS_ENSURE_ARG(aData);
  779:   nsresult rv;
  779: 
  779:   rv = StartImageEncode(aWidth, aHeight, aInputFormat, aOutputOptions);
  779:   if (!NS_SUCCEEDED(rv))
  779:     return rv;
  779: 
36849:   rv = AddImageFrame(aData, aLength, aWidth, aHeight, aStride,
36849:                      aInputFormat, aOutputOptions);
  779:   if (!NS_SUCCEEDED(rv))
  779:     return rv;
  779: 
  779:   rv = EndImageEncode();
  779: 
  779:   return rv;
  779: }
  779: 
  779: 
  779: // nsPNGEncoder::StartImageEncode
  779: //
  779: // 
  779: // See ::InitFromData for other info.
  779: NS_IMETHODIMP nsPNGEncoder::StartImageEncode(PRUint32 aWidth,
  779:                                              PRUint32 aHeight,
  779:                                              PRUint32 aInputFormat,
  779:                                              const nsAString& aOutputOptions)
  779: {
  779:   PRBool useTransparency = PR_TRUE, skipFirstFrame = PR_FALSE;
  779:   PRUint32 numFrames = 1;
  779:   PRUint32 numPlays = 0; // For animations, 0 == forever
  779: 
  779:   // can't initialize more than once
  779:   if (mImageBuffer != nsnull)
  779:     return NS_ERROR_ALREADY_INITIALIZED;
  779: 
    1:   // validate input format
    1:   if (aInputFormat != INPUT_FORMAT_RGB &&
    1:       aInputFormat != INPUT_FORMAT_RGBA &&
    1:       aInputFormat != INPUT_FORMAT_HOSTARGB)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
  779:   // parse and check any provided output options
  779:   nsresult rv = ParseOptions(aOutputOptions, &useTransparency, &skipFirstFrame,
  779:                              &numFrames, &numPlays, nsnull, nsnull,
  779:                              nsnull, nsnull, nsnull);
36849:   if (rv != NS_OK)
36849:     return rv;
    1: 
36849: #ifdef PNG_APNG_SUPPORTED
36849:   if (numFrames > 1)
  779:     mIsAnimation = PR_TRUE;
36849: 
36849: #endif
    1: 
    1:   // initialize
  779:   mPNG = png_create_write_struct(PNG_LIBPNG_VER_STRING,
36849:                                  nsnull,
  779:                                  ErrorCallback,
  779:                                  ErrorCallback);
  779:   if (! mPNG)
    1:     return NS_ERROR_OUT_OF_MEMORY;
  779: 
  779:   mPNGinfo = png_create_info_struct(mPNG);
  779:   if (! mPNGinfo) {
  779:     png_destroy_write_struct(&mPNG, nsnull);
    1:     return NS_ERROR_FAILURE;
    1:   }
  779: 
  779:   // libpng's error handler jumps back here upon an error.
  779:   // Note: It's important that all png_* callers do this, or errors
  779:   // will result in a corrupt time-warped stack.
  779:   if (setjmp(png_jmpbuf(mPNG))) {
  779:     png_destroy_write_struct(&mPNG, &mPNGinfo);
  779:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // Set up to read the data into our image buffer, start out with an 8K
    1:   // estimated size. Note: we don't have to worry about freeing this data
    1:   // in this function. It will be freed on object destruction.
    1:   mImageBufferSize = 8192;
    1:   mImageBuffer = (PRUint8*)PR_Malloc(mImageBufferSize);
    1:   if (!mImageBuffer) {
  779:     png_destroy_write_struct(&mPNG, &mPNGinfo);
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   mImageBufferUsed = 0;
    1: 
    1:   // set our callback for libpng to give us the data
36849:   png_set_write_fn(mPNG, this, WriteCallback, nsnull);
    1: 
    1:   // include alpha?
    1:   int colorType;
    1:   if ((aInputFormat == INPUT_FORMAT_HOSTARGB ||
36849:        aInputFormat == INPUT_FORMAT_RGBA)  &&
36849:        useTransparency)
    1:     colorType = PNG_COLOR_TYPE_RGB_ALPHA;
    1:   else
    1:     colorType = PNG_COLOR_TYPE_RGB;
    1: 
  779:   png_set_IHDR(mPNG, mPNGinfo, aWidth, aHeight, 8, colorType,
    1:                PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT,
    1:                PNG_FILTER_TYPE_DEFAULT);
    1: 
36849: #ifdef PNG_APNG_SUPPORTED
  779:   if (mIsAnimation) {
  779:     png_set_first_frame_is_hidden(mPNG, mPNGinfo, skipFirstFrame);
  779:     png_set_acTL(mPNG, mPNGinfo, numFrames, numPlays);
  779:   }
36849: #endif
  779: 
  779:   // XXX: support PLTE, gAMA, tRNS, bKGD?
  779: 
  779:   png_write_info(mPNG, mPNGinfo);
  779: 
  779:   return NS_OK;
  779: }
  779: 
77232: // Returns the image buffer size
77232: NS_IMETHODIMP nsPNGEncoder::GetImageBufferSize(PRUint32 *aOutputSize)
77232: {
77232:   NS_ENSURE_ARG_POINTER(aOutputSize);
77232:   *aOutputSize = mImageBufferSize;
77232:   return NS_OK;
77232: }
77232: 
77232: // Returns a pointer to the start of the image buffer
77232: NS_IMETHODIMP nsPNGEncoder::GetImageBuffer(char **aOutputBuffer)
77232: {
77232:   NS_ENSURE_ARG_POINTER(aOutputBuffer);
77232:   *aOutputBuffer = reinterpret_cast<char*>(mImageBuffer);
77232:   return NS_OK;
77232: }
  779: 
  779: NS_IMETHODIMP nsPNGEncoder::AddImageFrame(const PRUint8* aData,
36849:                                           PRUint32 aLength, // (unused,
36849:                                                             // req'd by JS)
  779:                                           PRUint32 aWidth,
  779:                                           PRUint32 aHeight,
  779:                                           PRUint32 aStride,
  779:                                           PRUint32 aInputFormat,
  779:                                           const nsAString& aFrameOptions)
  779: {
  779:   PRBool useTransparency= PR_TRUE;
  779:   PRUint32 delay_ms = 500;
36849: #ifdef PNG_APNG_SUPPORTED
  779:   PRUint32 dispose_op = PNG_DISPOSE_OP_NONE;
  779:   PRUint32 blend_op = PNG_BLEND_OP_SOURCE;
36849: #else
36849:   PRUint32 dispose_op;
36849:   PRUint32 blend_op;
36849: #endif
  779:   PRUint32 x_offset = 0, y_offset = 0;
  779: 
  779:   // must be initialized
  779:   if (mImageBuffer == nsnull)
  779:     return NS_ERROR_NOT_INITIALIZED;
  779: 
 7065:   // EndImageEncode was done, or some error occurred earlier
 7065:   if (!mPNG)
 7065:     return NS_BASE_STREAM_CLOSED;
 7065: 
  779:   // validate input format
  779:   if (aInputFormat != INPUT_FORMAT_RGB &&
  779:       aInputFormat != INPUT_FORMAT_RGBA &&
  779:       aInputFormat != INPUT_FORMAT_HOSTARGB)
  779:     return NS_ERROR_INVALID_ARG;
  779: 
  779:   // libpng's error handler jumps back here upon an error.
  779:   if (setjmp(png_jmpbuf(mPNG))) {
  779:     png_destroy_write_struct(&mPNG, &mPNGinfo);
  779:     return NS_ERROR_FAILURE;
  779:   }
  779: 
  779:   // parse and check any provided output options
  779:   nsresult rv = ParseOptions(aFrameOptions, &useTransparency, nsnull,
  779:                              nsnull, nsnull, &dispose_op, &blend_op,
  779:                              &delay_ms, &x_offset, &y_offset);
36849:   if (rv != NS_OK)
36849:     return rv;
  779: 
36849: #ifdef PNG_APNG_SUPPORTED
  779:   if (mIsAnimation) {
  779:     // XXX the row pointers arg (#3) is unused, can it be removed?
  779:     png_write_frame_head(mPNG, mPNGinfo, nsnull,
  779:                          aWidth, aHeight, x_offset, y_offset,
  779:                          delay_ms, 1000, dispose_op, blend_op);
  779:   }
36849: #endif
  779: 
36849:   // Stride is the padded width of each row, so it better be longer 
36849:   // (I'm afraid people will not understand what stride means, so
36849:   // check it well)
  779:   if ((aInputFormat == INPUT_FORMAT_RGB &&
  779:       aStride < aWidth * 3) ||
36849:       ((aInputFormat == INPUT_FORMAT_RGBA ||
36849:       aInputFormat == INPUT_FORMAT_HOSTARGB) &&
  779:       aStride < aWidth * 4)) {
  779:     NS_WARNING("Invalid stride for InitFromData/AddImageFrame");
  779:     return NS_ERROR_INVALID_ARG;
  779:   }
    1: 
68405: #ifdef PNG_WRITE_FILTER_SUPPORTED
68405:   png_set_filter(mPNG, PNG_FILTER_TYPE_BASE, PNG_FILTER_VALUE_NONE);
68405: #endif
68405: 
    1:   // write each row: if we add more input formats, we may want to
    1:   // generalize the conversions
    1:   if (aInputFormat == INPUT_FORMAT_HOSTARGB) {
36849:     // PNG requires RGBA with post-multiplied alpha, so we need to
36849:     // convert
    1:     PRUint8* row = new PRUint8[aWidth * 4];
    1:     for (PRUint32 y = 0; y < aHeight; y ++) {
    1:       ConvertHostARGBRow(&aData[y * aStride], row, aWidth, useTransparency);
  779:       png_write_row(mPNG, row);
    1:     }
    1:     delete[] row;
    1: 
    1:   } else if (aInputFormat == INPUT_FORMAT_RGBA && ! useTransparency) {
    1:     // RBGA, but we need to strip the alpha
    1:     PRUint8* row = new PRUint8[aWidth * 4];
    1:     for (PRUint32 y = 0; y < aHeight; y ++) {
    1:       StripAlpha(&aData[y * aStride], row, aWidth);
  779:       png_write_row(mPNG, row);
    1:     }
    1:     delete[] row;
    1: 
    1:   } else if (aInputFormat == INPUT_FORMAT_RGB ||
    1:              aInputFormat == INPUT_FORMAT_RGBA) {
    1:     // simple RBG(A), no conversion needed
    1:     for (PRUint32 y = 0; y < aHeight; y ++) {
  779:       png_write_row(mPNG, (PRUint8*)&aData[y * aStride]);
    1:     }
    1: 
    1:   } else {
    1:     NS_NOTREACHED("Bad format type");
  779:     return NS_ERROR_INVALID_ARG;
    1:   }
    1: 
36849: #ifdef PNG_APNG_SUPPORTED
  779:   if (mIsAnimation) {
  779:     png_write_frame_tail(mPNG, mPNGinfo);
  779:   }
36849: #endif
  779: 
  779:   return NS_OK;
  779: }
  779: 
  779: 
  779: NS_IMETHODIMP nsPNGEncoder::EndImageEncode()
  779: {
  779:   // must be initialized
  779:   if (mImageBuffer == nsnull)
  779:     return NS_ERROR_NOT_INITIALIZED;
  779: 
36849:   // EndImageEncode has already been called, or some error
36849:   // occurred earlier
 7065:   if (!mPNG)
 7065:     return NS_BASE_STREAM_CLOSED;
 7065: 
  779:   // libpng's error handler jumps back here upon an error.
  779:   if (setjmp(png_jmpbuf(mPNG))) {
  779:     png_destroy_write_struct(&mPNG, &mPNGinfo);
  779:     return NS_ERROR_FAILURE;
  779:   }
  779: 
  779:   png_write_end(mPNG, mPNGinfo);
  779:   png_destroy_write_struct(&mPNG, &mPNGinfo);
    1: 
44195:   mFinished = PR_TRUE;
44195:   NotifyListener();
44195: 
    1:   // if output callback can't get enough memory, it will free our buffer
    1:   if (!mImageBuffer)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
  779: nsresult
  779: nsPNGEncoder::ParseOptions(const nsAString& aOptions,
  779:                            PRBool* useTransparency,
  779:                            PRBool* skipFirstFrame,
  779:                            PRUint32* numFrames,
  779:                            PRUint32* numPlays,
  779:                            PRUint32* frameDispose,
  779:                            PRUint32* frameBlend,
  779:                            PRUint32* frameDelay,
  779:                            PRUint32* offsetX,
  779:                            PRUint32* offsetY)
  779: {
36849: #ifdef PNG_APNG_SUPPORTED
10545:   // Make a copy of aOptions, because strtok() will modify it.
10545:   nsCAutoString optionsCopy;
10545:   optionsCopy.Assign(NS_ConvertUTF16toUTF8(aOptions));
10545:   char* options = optionsCopy.BeginWriting();
  779: 
10545:   while (char* token = nsCRT::strtok(options, ";", &options)) {
  779:     // If there's an '=' character, split the token around it.
  779:     char* equals = token, *value = nsnull;
36849:     while(*equals != '=' && *equals) {
36849:       ++equals;
36849:     }
36849:     if (*equals == '=')
36849:       value = equals + 1;
  779: 
36849:     if (value)
36849:       *equals = '\0'; // temporary null
  779: 
  779:     // transparency=[yes|no|none]
  779:     if (nsCRT::strcmp(token, "transparency") == 0 && useTransparency) {
36849:       if (!value)
36849:         return NS_ERROR_INVALID_ARG;
  779: 
36849:       if (nsCRT::strcmp(value, "none") == 0 ||
36849:           nsCRT::strcmp(value, "no") == 0) {
  779:         *useTransparency = PR_FALSE;
  779:       } else if (nsCRT::strcmp(value, "yes") == 0) {
  779:         *useTransparency = PR_TRUE;
  779:       } else {
  779:         return NS_ERROR_INVALID_ARG;
  779:       }
  779: 
  779:     // skipfirstframe=[yes|no]
36849:     } else if (nsCRT::strcmp(token, "skipfirstframe") == 0 &&
36849:                skipFirstFrame) {
36849:       if (!value)
36849:         return NS_ERROR_INVALID_ARG;
  779: 
  779:       if (nsCRT::strcmp(value, "no") == 0) {
  779:         *skipFirstFrame = PR_FALSE;
  779:       } else if (nsCRT::strcmp(value, "yes") == 0) {
  779:         *skipFirstFrame = PR_TRUE;
  779:       } else {
  779:         return NS_ERROR_INVALID_ARG;
  779:       }
  779: 
  779:     // frames=#
  779:     } else if (nsCRT::strcmp(token, "frames") == 0 && numFrames) {
36849:       if (!value)
36849:         return NS_ERROR_INVALID_ARG;
  779: 
36849:       if (PR_sscanf(value, "%u", numFrames) != 1) {
36849:         return NS_ERROR_INVALID_ARG;
36849:       }
  779: 
  779:       // frames=0 is nonsense.
36849:       if (*numFrames == 0)
36849:         return NS_ERROR_INVALID_ARG;
  779: 
  779:     // plays=#
  779:     } else if (nsCRT::strcmp(token, "plays") == 0 && numPlays) {
36849:       if (!value)
36849:         return NS_ERROR_INVALID_ARG;
  779: 
36849:       // plays=0 to loop forever, otherwise play sequence specified
36849:       // number of times
36849:       if (PR_sscanf(value, "%u", numPlays) != 1)
36849:         return NS_ERROR_INVALID_ARG;
  779: 
  779:     // dispose=[none|background|previous]
  779:     } else if (nsCRT::strcmp(token, "dispose") == 0 && frameDispose) {
36849:       if (!value)
36849:         return NS_ERROR_INVALID_ARG;
  779: 
  779:       if (nsCRT::strcmp(value, "none") == 0) {
  779:         *frameDispose = PNG_DISPOSE_OP_NONE;
  779:       } else if (nsCRT::strcmp(value, "background") == 0) {
  779:         *frameDispose = PNG_DISPOSE_OP_BACKGROUND;
  779:       } else if (nsCRT::strcmp(value, "previous") == 0) {
  779:         *frameDispose = PNG_DISPOSE_OP_PREVIOUS;
  779:       } else {
  779:         return NS_ERROR_INVALID_ARG;
  779:       }
  779: 
  779:     // blend=[source|over]
  779:     } else if (nsCRT::strcmp(token, "blend") == 0 && frameBlend) {
36849:       if (!value)
36849:         return NS_ERROR_INVALID_ARG;
  779: 
  779:       if (nsCRT::strcmp(value, "source") == 0) {
  779:         *frameBlend = PNG_BLEND_OP_SOURCE;
  779:       } else if (nsCRT::strcmp(value, "over") == 0) {
  779:         *frameBlend = PNG_BLEND_OP_OVER;
  779:       } else {
  779:         return NS_ERROR_INVALID_ARG;
  779:       }
  779: 
  779:     // delay=# (in ms)
  779:     } else if (nsCRT::strcmp(token, "delay") == 0 && frameDelay) {
36849:       if (!value)
36849:         return NS_ERROR_INVALID_ARG;
  779: 
36849:       if (PR_sscanf(value, "%u", frameDelay) != 1)
36849:         return NS_ERROR_INVALID_ARG;
  779: 
  779:     // xoffset=#
  779:     } else if (nsCRT::strcmp(token, "xoffset") == 0 && offsetX) {
36849:       if (!value)
36849:         return NS_ERROR_INVALID_ARG;
  779: 
36849:       if (PR_sscanf(value, "%u", offsetX) != 1)
36849:         return NS_ERROR_INVALID_ARG;
  779: 
  779:     // yoffset=#
  779:     } else if (nsCRT::strcmp(token, "yoffset") == 0 && offsetY) {
36849:       if (!value)
36849:         return NS_ERROR_INVALID_ARG;
  779: 
36849:       if (PR_sscanf(value, "%u", offsetY) != 1)
36849:         return NS_ERROR_INVALID_ARG;
  779: 
  779:     // unknown token name
36849:     } else
  779:       return NS_ERROR_INVALID_ARG;
36849: 
36849:     if (value)
36849:       *equals = '='; // restore '=' so strtok doesn't get lost
  779:   }
  779: 
36849: #endif
  779:   return NS_OK;
  779: }
  779: 
  779: 
    1: /* void close (); */
    1: NS_IMETHODIMP nsPNGEncoder::Close()
    1: {
    1:   if (mImageBuffer != nsnull) {
    1:     PR_Free(mImageBuffer);
    1:     mImageBuffer = nsnull;
    1:     mImageBufferSize = 0;
    1:     mImageBufferUsed = 0;
    1:     mImageBufferReadPoint = 0;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: /* unsigned long available (); */
    1: NS_IMETHODIMP nsPNGEncoder::Available(PRUint32 *_retval)
    1: {
    1:   if (!mImageBuffer)
    1:     return NS_BASE_STREAM_CLOSED;
    1: 
    1:   *_retval = mImageBufferUsed - mImageBufferReadPoint;
    1:   return NS_OK;
    1: }
    1: 
36849: /* [noscript] unsigned long read (in charPtr aBuf,
36849:                                   in unsigned long aCount); */
    1: NS_IMETHODIMP nsPNGEncoder::Read(char * aBuf, PRUint32 aCount,
    1:                                  PRUint32 *_retval)
    1: {
    1:   return ReadSegments(NS_CopySegmentToBuffer, aBuf, aCount, _retval);
    1: }
    1: 
36849: /* [noscript] unsigned long readSegments (in nsWriteSegmentFun aWriter,
36849:                                           in voidPtr aClosure,
36849:                                           in unsigned long aCount); */
    1: NS_IMETHODIMP nsPNGEncoder::ReadSegments(nsWriteSegmentFun aWriter,
    1:                                          void *aClosure, PRUint32 aCount,
    1:                                          PRUint32 *_retval)
    1: {
44195:   // Avoid another thread reallocing the buffer underneath us
69142:   ReentrantMonitorAutoEnter autoEnter(mReentrantMonitor);
44195: 
    1:   PRUint32 maxCount = mImageBufferUsed - mImageBufferReadPoint;
    1:   if (maxCount == 0) {
    1:     *_retval = 0;
44195:     return mFinished ? NS_OK : NS_BASE_STREAM_WOULD_BLOCK;
    1:   }
    1: 
    1:   if (aCount > maxCount)
    1:     aCount = maxCount;
36849:   nsresult rv =
36849:       aWriter(this, aClosure,
13810:               reinterpret_cast<const char*>(mImageBuffer+mImageBufferReadPoint),
13810:               0, aCount, _retval);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     NS_ASSERTION(*_retval <= aCount, "bad write count");
    1:     mImageBufferReadPoint += *_retval;
    1:   }
    1: 
    1:   // errors returned from the writer end here!
    1:   return NS_OK;
    1: }
    1: 
    1: /* boolean isNonBlocking (); */
    1: NS_IMETHODIMP nsPNGEncoder::IsNonBlocking(PRBool *_retval)
    1: {
44195:   *_retval = PR_TRUE;
    1:   return NS_OK;
    1: }
    1: 
44195: NS_IMETHODIMP nsPNGEncoder::AsyncWait(nsIInputStreamCallback *aCallback,
44195:                                       PRUint32 aFlags,
44195:                                       PRUint32 aRequestedCount,
44195:                                       nsIEventTarget *aTarget)
44195: {
44195:   if (aFlags != 0)
44195:     return NS_ERROR_NOT_IMPLEMENTED;
44195: 
44195:   if (mCallback || mCallbackTarget)
44195:     return NS_ERROR_UNEXPECTED;
44195: 
44195:   mCallbackTarget = aTarget;
44195:   // 0 means "any number of bytes except 0"
44195:   mNotifyThreshold = aRequestedCount;
44195:   if (!aRequestedCount)
44195:     mNotifyThreshold = 1024; // We don't want to notify incessantly
44195: 
44195:   // We set the callback absolutely last, because NotifyListener uses it to
44195:   // determine if someone needs to be notified.  If we don't set it last,
44195:   // NotifyListener might try to fire off a notification to a null target
44195:   // which will generally cause non-threadsafe objects to be used off the main thread
44195:   mCallback = aCallback;
44195: 
44195:   // What we are being asked for may be present already
44195:   NotifyListener();
44195:   return NS_OK;
44195: }
44195: 
44195: NS_IMETHODIMP nsPNGEncoder::CloseWithStatus(nsresult aStatus)
44195: {
44195:   return Close();
44195: }
    1: 
    1: // nsPNGEncoder::ConvertHostARGBRow
    1: //
    1: //    Our colors are stored with premultiplied alphas, but PNGs use
    1: //    post-multiplied alpha. This swaps to PNG-style alpha.
    1: //
    1: //    Copied from gfx/cairo/cairo/src/cairo-png.c
    1: 
    1: void
    1: nsPNGEncoder::ConvertHostARGBRow(const PRUint8* aSrc, PRUint8* aDest,
36849:                                  PRUint32 aPixelWidth,
36849:                                  PRBool aUseTransparency)
    1: {
    1:   PRUint32 pixelStride = aUseTransparency ? 4 : 3;
    1:   for (PRUint32 x = 0; x < aPixelWidth; x ++) {
    1:     const PRUint32& pixelIn = ((const PRUint32*)(aSrc))[x];
    1:     PRUint8 *pixelOut = &aDest[x * pixelStride];
    1: 
    1:     PRUint8 alpha = (pixelIn & 0xff000000) >> 24;
    1:     if (alpha == 0) {
    1:       pixelOut[0] = pixelOut[1] = pixelOut[2] = pixelOut[3] = 0;
    1:     } else {
    1:       pixelOut[0] = (((pixelIn & 0xff0000) >> 16) * 255 + alpha / 2) / alpha;
    1:       pixelOut[1] = (((pixelIn & 0x00ff00) >>  8) * 255 + alpha / 2) / alpha;
    1:       pixelOut[2] = (((pixelIn & 0x0000ff) >>  0) * 255 + alpha / 2) / alpha;
    1:       if (aUseTransparency)
    1:         pixelOut[3] = alpha;
    1:     }
    1:   }
    1: }
    1: 
    1: 
    1: // nsPNGEncoder::StripAlpha
    1: //
    1: //    Input is RGBA, output is RGB
    1: 
    1: void
    1: nsPNGEncoder::StripAlpha(const PRUint8* aSrc, PRUint8* aDest,
    1:                           PRUint32 aPixelWidth)
    1: {
    1:   for (PRUint32 x = 0; x < aPixelWidth; x ++) {
    1:     const PRUint8* pixelIn = &aSrc[x * 4];
    1:     PRUint8* pixelOut = &aDest[x * 3];
    1:     pixelOut[0] = pixelIn[0];
    1:     pixelOut[1] = pixelIn[1];
    1:     pixelOut[2] = pixelIn[2];
    1:   }
    1: }
    1: 
    1: 
  779: // nsPNGEncoder::ErrorCallback
  779: 
  779: void // static
36849: nsPNGEncoder::ErrorCallback(png_structp png_ptr,
36849:                             png_const_charp warning_msg)
  779: {
  779: #ifdef DEBUG
36849: 	// XXX: these messages are probably useful callers...
36849:         // use nsIConsoleService?
  779: 	PR_fprintf(PR_STDERR, "PNG Encoder: %s\n", warning_msg);;
  779: #endif
  779: }
  779: 
  779: 
    1: // nsPNGEncoder::WriteCallback
    1: 
    1: void // static
36849: nsPNGEncoder::WriteCallback(png_structp png, png_bytep data,
36849:                             png_size_t size)
    1: {
 3233:   nsPNGEncoder* that = static_cast<nsPNGEncoder*>(png_get_io_ptr(png));
    1:   if (! that->mImageBuffer)
    1:     return;
    1: 
    1:   if (that->mImageBufferUsed + size > that->mImageBufferSize) {
44195:     // When we're reallocing the buffer we need to take the lock to ensure
44195:     // that nobody is trying to read from the buffer we are destroying
69142:     ReentrantMonitorAutoEnter autoEnter(that->mReentrantMonitor);
44195: 
    1:     // expand buffer, just double each time
    1:     that->mImageBufferSize *= 2;
    1:     PRUint8* newBuf = (PRUint8*)PR_Realloc(that->mImageBuffer,
    1:                                            that->mImageBufferSize);
    1:     if (! newBuf) {
    1:       // can't resize, just zero (this will keep us from writing more)
    1:       PR_Free(that->mImageBuffer);
    1:       that->mImageBufferSize = 0;
    1:       that->mImageBufferUsed = 0;
    1:       return;
    1:     }
    1:     that->mImageBuffer = newBuf;
    1:   }
    1:   memcpy(&that->mImageBuffer[that->mImageBufferUsed], data, size);
    1:   that->mImageBufferUsed += size;
44195:   that->NotifyListener();
    1: }
44195: 
44195: void
44195: nsPNGEncoder::NotifyListener()
44195: {
44195:   // We might call this function on multiple threads (any threads that call
44195:   // AsyncWait and any that do encoding) so we lock to avoid notifying the
44195:   // listener twice about the same data (which generally leads to a truncated
44195:   // image).
69142:   ReentrantMonitorAutoEnter autoEnter(mReentrantMonitor);
44195: 
44195:   if (mCallback &&
44195:       (mImageBufferUsed - mImageBufferReadPoint >= mNotifyThreshold ||
44195:        mFinished)) {
44195:     nsCOMPtr<nsIInputStreamCallback> callback;
44195:     if (mCallbackTarget) {
44195:       NS_NewInputStreamReadyEvent(getter_AddRefs(callback),
44195:                                   mCallback,
44195:                                   mCallbackTarget);
44195:     } else {
44195:       callback = mCallback;
44195:     }
44195: 
44195:     NS_ASSERTION(callback, "Shouldn't fail to make the callback");
44195:     // Null the callback first because OnInputStreamReady could reenter
44195:     // AsyncWait
44195:     mCallback = nsnull;
44195:     mCallbackTarget = nsnull;
44195:     mNotifyThreshold = 0;
44195: 
44195:     callback->OnInputStreamReady(this);
44195:   }
44195: }
