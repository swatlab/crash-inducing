    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is JPEG Encoding code
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Google Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Brett Wilson <brettw@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsJPEGEncoder.h"
    1: #include "prmem.h"
    1: #include "prprf.h"
    1: #include "nsString.h"
    1: #include "nsStreamUtils.h"
    1: 
    1: #include <setjmp.h>
    1: #include "jerror.h"
    1: 
69142: using namespace mozilla;
69142: 
44195: NS_IMPL_THREADSAFE_ISUPPORTS3(nsJPEGEncoder, imgIEncoder, nsIInputStream, nsIAsyncInputStream)
    1: 
    1: // used to pass error info through the JPEG library
    1: struct encoder_error_mgr {
    1:   jpeg_error_mgr pub;
    1:   jmp_buf setjmp_buffer;
    1: };
    1: 
47697: nsJPEGEncoder::nsJPEGEncoder() : mFinished(PR_FALSE),
47697:                                  mImageBuffer(nsnull), mImageBufferSize(0),
44195:                                  mImageBufferUsed(0), mImageBufferReadPoint(0),
47697:                                  mCallback(nsnull),
44195:                                  mCallbackTarget(nsnull), mNotifyThreshold(0),
69142:                                  mReentrantMonitor("nsJPEGEncoder.mReentrantMonitor")
    1: {
    1: }
    1: 
    1: nsJPEGEncoder::~nsJPEGEncoder()
    1: {
    1:   if (mImageBuffer) {
    1:     PR_Free(mImageBuffer);
    1:     mImageBuffer = nsnull;
    1:   }
    1: }
    1: 
    1: 
    1: // nsJPEGEncoder::InitFromData
    1: //
    1: //    One output option is supported: "quality=X" where X is an integer in the
    1: //    range 0-100. Higher values for X give better quality.
    1: //
    1: //    Transparency is always discarded.
    1: 
    1: NS_IMETHODIMP nsJPEGEncoder::InitFromData(const PRUint8* aData,
    1:                                           PRUint32 aLength, // (unused, req'd by JS)
    1:                                           PRUint32 aWidth,
    1:                                           PRUint32 aHeight,
    1:                                           PRUint32 aStride,
    1:                                           PRUint32 aInputFormat,
    1:                                           const nsAString& aOutputOptions)
    1: {
77274:   NS_ENSURE_ARG(aData);
77274: 
    1:   // validate input format
    1:   if (aInputFormat != INPUT_FORMAT_RGB &&
    1:       aInputFormat != INPUT_FORMAT_RGBA &&
    1:       aInputFormat != INPUT_FORMAT_HOSTARGB)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1:   // Stride is the padded width of each row, so it better be longer (I'm afraid
    1:   // people will not understand what stride means, so check it well)
    1:   if ((aInputFormat == INPUT_FORMAT_RGB &&
    1:        aStride < aWidth * 3) ||
    1:       ((aInputFormat == INPUT_FORMAT_RGBA || aInputFormat == INPUT_FORMAT_HOSTARGB) &&
    1:        aStride < aWidth * 4)) {
    1:     NS_WARNING("Invalid stride for InitFromData");
    1:     return NS_ERROR_INVALID_ARG;
    1:   }
    1: 
    1:   // can't initialize more than once
    1:   if (mImageBuffer != nsnull)
    1:     return NS_ERROR_ALREADY_INITIALIZED;
    1: 
    1:   // options: we only have one option so this is easy
23806:   int quality = 92;
    1:   if (aOutputOptions.Length() > 0) {
    1:     // have options string
    1:     const nsString qualityPrefix(NS_LITERAL_STRING("quality="));
    1:     if (aOutputOptions.Length() > qualityPrefix.Length()  &&
    1:         StringBeginsWith(aOutputOptions, qualityPrefix)) {
    1:       // have quality string
    1:       nsCString value = NS_ConvertUTF16toUTF8(Substring(aOutputOptions,
    1:                                                         qualityPrefix.Length()));
    1:       int newquality = -1;
71726:       if (PR_sscanf(value.get(), "%d", &newquality) == 1) {
    1:         if (newquality >= 0 && newquality <= 100) {
    1:           quality = newquality;
    1:         } else {
    1:           NS_WARNING("Quality value out of range, should be 0-100, using default");
    1:         }
    1:       } else {
    1:         NS_WARNING("Quality value invalid, should be integer 0-100, using default");
    1:       }
    1:     }
 9580:     else {
 9580:       return NS_ERROR_INVALID_ARG;
 9580:     }
    1:   }
    1: 
    1:   jpeg_compress_struct cinfo;
    1: 
    1:   // We set up the normal JPEG error routines, then override error_exit.
    1:   // This must be done before the call to create_compress
    1:   encoder_error_mgr errmgr;
    1:   cinfo.err = jpeg_std_error(&errmgr.pub);
    1:   errmgr.pub.error_exit = errorExit;
    1:   // Establish the setjmp return context for my_error_exit to use.
    1:   if (setjmp(errmgr.setjmp_buffer)) {
    1:     // If we get here, the JPEG code has signaled an error.
    1:     // We need to clean up the JPEG object, close the input file, and return.
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   jpeg_create_compress(&cinfo);
    1:   cinfo.image_width = aWidth;
    1:   cinfo.image_height = aHeight;
    1:   cinfo.input_components = 3;
    1:   cinfo.in_color_space = JCS_RGB;
    1:   cinfo.data_precision = 8;
    1: 
    1:   jpeg_set_defaults(&cinfo);
    1:   jpeg_set_quality(&cinfo, quality, 1); // quality here is 0-100
17029:   if (quality >= 90) {
17029:     int i;
17029:     for (i=0; i < MAX_COMPONENTS; i++) {
17029:       cinfo.comp_info[i].h_samp_factor=1;
17029:       cinfo.comp_info[i].v_samp_factor=1;
17029:     }
17029:   }
    1: 
    1:   // set up the destination manager
    1:   jpeg_destination_mgr destmgr;
    1:   destmgr.init_destination = initDestination;
    1:   destmgr.empty_output_buffer = emptyOutputBuffer;
    1:   destmgr.term_destination = termDestination;
    1:   cinfo.dest = &destmgr;
    1:   cinfo.client_data = this;
    1: 
    1:   jpeg_start_compress(&cinfo, 1);
    1: 
    1:   // feed it the rows
    1:   if (aInputFormat == INPUT_FORMAT_RGB) {
    1:     while (cinfo.next_scanline < cinfo.image_height) {
    1:       const PRUint8* row = &aData[cinfo.next_scanline * aStride];
 3233:       jpeg_write_scanlines(&cinfo, const_cast<PRUint8**>(&row), 1);
    1:     }
    1:   } else if (aInputFormat == INPUT_FORMAT_RGBA) {
    1:     PRUint8* row = new PRUint8[aWidth * 3];
    1:     while (cinfo.next_scanline < cinfo.image_height) {
    1:       StripAlpha(&aData[cinfo.next_scanline * aStride], row, aWidth);
    1:       jpeg_write_scanlines(&cinfo, &row, 1);
    1:     }
    1:     delete[] row;
    1:   } else if (aInputFormat == INPUT_FORMAT_HOSTARGB) {
    1:     PRUint8* row = new PRUint8[aWidth * 3];
    1:     while (cinfo.next_scanline < cinfo.image_height) {
    1:       ConvertHostARGBRow(&aData[cinfo.next_scanline * aStride], row, aWidth);
    1:       jpeg_write_scanlines(&cinfo, &row, 1);
    1:     }
    1:     delete[] row;
    1:   }
    1: 
    1:   jpeg_finish_compress(&cinfo);
    1:   jpeg_destroy_compress(&cinfo);
    1: 
44195:   mFinished = PR_TRUE;
44195:   NotifyListener();
44195: 
    1:   // if output callback can't get enough memory, it will free our buffer
    1:   if (!mImageBuffer)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
  779: NS_IMETHODIMP nsJPEGEncoder::StartImageEncode(PRUint32 aWidth,
  779:                                               PRUint32 aHeight,
  779:                                               PRUint32 aInputFormat,
  779:                                               const nsAString& aOutputOptions)
  779: {
  779:   return NS_ERROR_NOT_IMPLEMENTED;
  779: }
  779: 
77232: // Returns the image buffer size
77232: NS_IMETHODIMP  nsJPEGEncoder::GetImageBufferSize(PRUint32 *aOutputSize)
77232: {
77232:   NS_ENSURE_ARG_POINTER(aOutputSize);
77232:   *aOutputSize = mImageBufferSize;
77232:   return NS_OK;
77232: }
77232: 
77232: // Returns a pointer to the start of the image buffer
77232: NS_IMETHODIMP nsJPEGEncoder::GetImageBuffer(char **aOutputBuffer)
77232: {
77232:   NS_ENSURE_ARG_POINTER(aOutputBuffer);
77232:   *aOutputBuffer = reinterpret_cast<char*>(mImageBuffer);
77232:   return NS_OK;
77232: }
77232: 
  779: NS_IMETHODIMP nsJPEGEncoder::AddImageFrame(const PRUint8* aData,
  779:                                            PRUint32 aLength,
  779:                                            PRUint32 aWidth,
  779:                                            PRUint32 aHeight,
  779:                                            PRUint32 aStride,
  779:                                            PRUint32 aFrameFormat,
  779:                                            const nsAString& aFrameOptions)
  779: {
  779:   return NS_ERROR_NOT_IMPLEMENTED;
  779: }
  779: 
  779: NS_IMETHODIMP nsJPEGEncoder::EndImageEncode()
  779: {
  779:   return NS_ERROR_NOT_IMPLEMENTED;
  779: }
  779: 
  779: 
    1: /* void close (); */
    1: NS_IMETHODIMP nsJPEGEncoder::Close()
    1: {
    1:   if (mImageBuffer != nsnull) {
    1:     PR_Free(mImageBuffer);
    1:     mImageBuffer = nsnull;
    1:     mImageBufferSize = 0;
    1:     mImageBufferUsed = 0;
    1:     mImageBufferReadPoint = 0;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: /* unsigned long available (); */
    1: NS_IMETHODIMP nsJPEGEncoder::Available(PRUint32 *_retval)
    1: {
    1:   if (!mImageBuffer)
    1:     return NS_BASE_STREAM_CLOSED;
    1: 
    1:   *_retval = mImageBufferUsed - mImageBufferReadPoint;
    1:   return NS_OK;
    1: }
    1: 
    1: /* [noscript] unsigned long read (in charPtr aBuf, in unsigned long aCount); */
    1: NS_IMETHODIMP nsJPEGEncoder::Read(char * aBuf, PRUint32 aCount,
    1:                                   PRUint32 *_retval)
    1: {
    1:   return ReadSegments(NS_CopySegmentToBuffer, aBuf, aCount, _retval);
    1: }
    1: 
    1: /* [noscript] unsigned long readSegments (in nsWriteSegmentFun aWriter, in voidPtr aClosure, in unsigned long aCount); */
    1: NS_IMETHODIMP nsJPEGEncoder::ReadSegments(nsWriteSegmentFun aWriter, void *aClosure, PRUint32 aCount, PRUint32 *_retval)
    1: {
44195:   // Avoid another thread reallocing the buffer underneath us
69142:   ReentrantMonitorAutoEnter autoEnter(mReentrantMonitor);
44195: 
    1:   PRUint32 maxCount = mImageBufferUsed - mImageBufferReadPoint;
    1:   if (maxCount == 0) {
    1:     *_retval = 0;
44195:     return mFinished ? NS_OK : NS_BASE_STREAM_WOULD_BLOCK;
    1:   }
    1: 
    1:   if (aCount > maxCount)
    1:     aCount = maxCount;
    1:   nsresult rv = aWriter(this, aClosure,
13810:                         reinterpret_cast<const char*>(mImageBuffer+mImageBufferReadPoint),
13810:                         0, aCount, _retval);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     NS_ASSERTION(*_retval <= aCount, "bad write count");
    1:     mImageBufferReadPoint += *_retval;
    1:   }
    1: 
    1:   // errors returned from the writer end here!
    1:   return NS_OK;
    1: }
    1: 
    1: /* boolean isNonBlocking (); */
    1: NS_IMETHODIMP nsJPEGEncoder::IsNonBlocking(PRBool *_retval)
    1: {
44195:   *_retval = PR_TRUE;
    1:   return NS_OK;
    1: }
    1: 
44195: NS_IMETHODIMP nsJPEGEncoder::AsyncWait(nsIInputStreamCallback *aCallback,
44195:                                        PRUint32 aFlags,
44195:                                        PRUint32 aRequestedCount,
44195:                                        nsIEventTarget *aTarget)
44195: {
44195:   if (aFlags != 0)
44195:     return NS_ERROR_NOT_IMPLEMENTED;
44195: 
44195:   if (mCallback || mCallbackTarget)
44195:     return NS_ERROR_UNEXPECTED;
44195: 
44195:   mCallbackTarget = aTarget;
44195:   // 0 means "any number of bytes except 0"
44195:   mNotifyThreshold = aRequestedCount;
44195:   if (!aRequestedCount)
44195:     mNotifyThreshold = 1024; // 1 KB seems good.  We don't want to notify incessantly
44195: 
44195:   // We set the callback absolutely last, because NotifyListener uses it to
44195:   // determine if someone needs to be notified.  If we don't set it last,
44195:   // NotifyListener might try to fire off a notification to a null target
44195:   // which will generally cause non-threadsafe objects to be used off the main thread
44195:   mCallback = aCallback;
44195: 
44195:   // What we are being asked for may be present already
44195:   NotifyListener();
44195:   return NS_OK;
44195: }
44195: 
44195: NS_IMETHODIMP nsJPEGEncoder::CloseWithStatus(nsresult aStatus)
44195: {
44195:   return Close();
44195: }
    1: 
    1: // nsJPEGEncoder::ConvertHostARGBRow
    1: //
    1: //    Our colors are stored with premultiplied alphas, but we need
    1: //    an output with no alpha in machine-independent byte order.
    1: //
    1: //    See gfx/cairo/cairo/src/cairo-png.c
    1: 
    1: void
    1: nsJPEGEncoder::ConvertHostARGBRow(const PRUint8* aSrc, PRUint8* aDest,
    1:                                  PRUint32 aPixelWidth)
    1: {
    1:   for (PRUint32 x = 0; x < aPixelWidth; x ++) {
    1:     const PRUint32& pixelIn = ((const PRUint32*)(aSrc))[x];
    1:     PRUint8 *pixelOut = &aDest[x * 3];
    1: 
    1:     PRUint8 alpha = (pixelIn & 0xff000000) >> 24;
    1:     if (alpha == 0) {
    1:       pixelOut[0] = pixelOut[1] = pixelOut[2] = 0;
    1:     } else {
    1:       pixelOut[0] = (((pixelIn & 0xff0000) >> 16) * 255 + alpha / 2) / alpha;
    1:       pixelOut[1] = (((pixelIn & 0x00ff00) >>  8) * 255 + alpha / 2) / alpha;
    1:       pixelOut[2] = (((pixelIn & 0x0000ff) >>  0) * 255 + alpha / 2) / alpha;
    1:     }
    1:   }
    1: }
    1: 
    1: 
    1: // nsJPEGEncoder::StripAlpha
    1: //
    1: //    Input is RGBA, output is RGB
    1: 
    1: void
    1: nsJPEGEncoder::StripAlpha(const PRUint8* aSrc, PRUint8* aDest,
    1:                           PRUint32 aPixelWidth)
    1: {
    1:   for (PRUint32 x = 0; x < aPixelWidth; x ++) {
    1:     const PRUint8* pixelIn = &aSrc[x * 4];
    1:     PRUint8* pixelOut = &aDest[x * 3];
    1:     pixelOut[0] = pixelIn[0];
    1:     pixelOut[1] = pixelIn[1];
    1:     pixelOut[2] = pixelIn[2];
    1:   }
    1: }
    1: 
    1: 
    1: // nsJPEGEncoder::initDestination
    1: //
    1: //    Initialize destination. This is called by jpeg_start_compress() before
    1: //    any data is actually written. It must initialize next_output_byte and
    1: //    free_in_buffer. free_in_buffer must be initialized to a positive value.
    1: 
    1: void // static
    1: nsJPEGEncoder::initDestination(jpeg_compress_struct* cinfo)
    1: {
 3233:   nsJPEGEncoder* that = static_cast<nsJPEGEncoder*>(cinfo->client_data);
    1:   NS_ASSERTION(! that->mImageBuffer, "Image buffer already initialized");
    1: 
    1:   that->mImageBufferSize = 8192;
    1:   that->mImageBuffer = (PRUint8*)PR_Malloc(that->mImageBufferSize);
    1:   that->mImageBufferUsed = 0;
    1: 
    1:   cinfo->dest->next_output_byte = that->mImageBuffer;
    1:   cinfo->dest->free_in_buffer = that->mImageBufferSize;
    1: }
    1: 
    1: 
    1: // nsJPEGEncoder::emptyOutputBuffer
    1: //
    1: //    This is called whenever the buffer has filled (free_in_buffer reaches
    1: //    zero).  In typical applications, it should write out the *entire* buffer
    1: //    (use the saved start address and buffer length; ignore the current state
    1: //    of next_output_byte and free_in_buffer).  Then reset the pointer & count
    1: //    to the start of the buffer, and return TRUE indicating that the buffer
    1: //    has been dumped.  free_in_buffer must be set to a positive value when
    1: //    TRUE is returned.  A FALSE return should only be used when I/O suspension
    1: //    is desired (this operating mode is discussed in the next section).
    1: 
    1: boolean // static
    1: nsJPEGEncoder::emptyOutputBuffer(jpeg_compress_struct* cinfo)
    1: {
 3233:   nsJPEGEncoder* that = static_cast<nsJPEGEncoder*>(cinfo->client_data);
    1:   NS_ASSERTION(that->mImageBuffer, "No buffer to empty!");
    1: 
44195:   // When we're reallocing the buffer we need to take the lock to ensure
44195:   // that nobody is trying to read from the buffer we are destroying
69142:   ReentrantMonitorAutoEnter autoEnter(that->mReentrantMonitor);
44195: 
    1:   that->mImageBufferUsed = that->mImageBufferSize;
    1: 
    1:   // expand buffer, just double size each time
    1:   that->mImageBufferSize *= 2;
    1: 
    1:   PRUint8* newBuf = (PRUint8*)PR_Realloc(that->mImageBuffer,
    1:                                          that->mImageBufferSize);
    1:   if (! newBuf) {
    1:     // can't resize, just zero (this will keep us from writing more)
    1:     PR_Free(that->mImageBuffer);
    1:     that->mImageBuffer = nsnull;
    1:     that->mImageBufferSize = 0;
    1:     that->mImageBufferUsed = 0;
    1: 
    1:     // this seems to be the only way to do errors through the JPEG library
    1:     longjmp(((encoder_error_mgr*)(cinfo->err))->setjmp_buffer,
    1:             NS_ERROR_OUT_OF_MEMORY);
    1:   }
    1:   that->mImageBuffer = newBuf;
    1: 
    1:   cinfo->dest->next_output_byte = &that->mImageBuffer[that->mImageBufferUsed];
    1:   cinfo->dest->free_in_buffer = that->mImageBufferSize - that->mImageBufferUsed;
    1:   return 1;
    1: }
    1: 
    1: 
    1: // nsJPEGEncoder::termDestination
    1: //
    1: //    Terminate destination --- called by jpeg_finish_compress() after all data
    1: //    has been written.  In most applications, this must flush any data
    1: //    remaining in the buffer.  Use either next_output_byte or free_in_buffer
    1: //    to determine how much data is in the buffer.
    1: 
    1: void // static
    1: nsJPEGEncoder::termDestination(jpeg_compress_struct* cinfo)
    1: {
 3233:   nsJPEGEncoder* that = static_cast<nsJPEGEncoder*>(cinfo->client_data);
    1:   if (! that->mImageBuffer)
    1:     return;
    1:   that->mImageBufferUsed = cinfo->dest->next_output_byte - that->mImageBuffer;
    1:   NS_ASSERTION(that->mImageBufferUsed < that->mImageBufferSize,
    1:                "JPEG library busted, got a bad image buffer size");
44195:   that->NotifyListener();
    1: }
    1: 
    1: 
    1: // nsJPEGEncoder::errorExit
    1: //
    1: //    Override the standard error method in the IJG JPEG decoder code. This
    1: //    was mostly copied from nsJPEGDecoder.cpp
    1: 
    1: void // static
    1: nsJPEGEncoder::errorExit(jpeg_common_struct* cinfo)
    1: {
    1:   nsresult error_code;
    1:   encoder_error_mgr *err = (encoder_error_mgr *) cinfo->err;
    1: 
    1:   // Convert error to a browser error code
    1:   switch (cinfo->err->msg_code) {
    1:     case JERR_OUT_OF_MEMORY:
    1:       error_code = NS_ERROR_OUT_OF_MEMORY;
39209:       break;
    1:     default:
    1:       error_code = NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // Return control to the setjmp point.
    1:   longjmp(err->setjmp_buffer, error_code);
    1: }
44195: 
44195: void
44195: nsJPEGEncoder::NotifyListener()
44195: {
44195:   // We might call this function on multiple threads (any threads that call
44195:   // AsyncWait and any that do encoding) so we lock to avoid notifying the
44195:   // listener twice about the same data (which generally leads to a truncated
44195:   // image).
69142:   ReentrantMonitorAutoEnter autoEnter(mReentrantMonitor);
44195: 
44195:   if (mCallback &&
44195:       (mImageBufferUsed - mImageBufferReadPoint >= mNotifyThreshold ||
44195:        mFinished)) {
44195:     nsCOMPtr<nsIInputStreamCallback> callback;
44195:     if (mCallbackTarget) {
44195:       NS_NewInputStreamReadyEvent(getter_AddRefs(callback),
44195:                                   mCallback,
44195:                                   mCallbackTarget);
44195:     } else {
44195:       callback = mCallback;
44195:     }
44195: 
44195:     NS_ASSERTION(callback, "Shouldn't fail to make the callback");
44195:     // Null the callback first because OnInputStreamReady could reenter
44195:     // AsyncWait
44195:     mCallback = nsnull;
44195:     mCallbackTarget = nsnull;
44195:     mNotifyThreshold = 0;
44195: 
44195:     callback->OnInputStreamReady(this);
44195:   }
44195: }
