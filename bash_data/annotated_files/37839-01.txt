    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsIServiceManager.h"
    1: #include "nsDateTimeFormatMac.h"
26226: #include <CoreFoundation/CFDateFormatter.h>
    1: #include "nsIComponentManager.h"
    1: #include "nsLocaleCID.h"
    1: #include "nsILocaleService.h"
    1: #include "nsIMacLocale.h"
    1: #include "nsCRT.h"
    1: #include "plstr.h"
    1: #include "prmem.h"
    1: #include "nsUnicharUtils.h"
26226: #include "nsTArray.h"
    1: 
    1: 
    1: NS_IMPL_THREADSAFE_ISUPPORTS1(nsDateTimeFormatMac, nsIDateTimeFormat)
    1: 
    1: nsresult nsDateTimeFormatMac::Initialize(nsILocale* locale)
    1: {
    1:   nsAutoString localeStr;
    1:   nsAutoString category(NS_LITERAL_STRING("NSILOCALE_TIME"));
    1:   nsresult res;
    1: 
    1:   // use cached info if match with stored locale
    1:   if (nsnull == locale) {
    1:     if (!mLocale.IsEmpty() &&
    1:         mLocale.Equals(mAppLocale, nsCaseInsensitiveStringComparator())) {
    1:       return NS_OK;
    1:     }
    1:   }
    1:   else {
    1:     res = locale->GetCategory(category, localeStr);
    1:     if (NS_SUCCEEDED(res) && !localeStr.IsEmpty()) {
    1:       if (!mLocale.IsEmpty() &&
    1:           mLocale.Equals(localeStr,
    1:                          nsCaseInsensitiveStringComparator())) {
    1:         return NS_OK;
    1:       }
    1:     }
    1:   }
    1: 
    1:   // get application locale
    1:   nsCOMPtr<nsILocaleService> localeService = 
    1:            do_GetService(NS_LOCALESERVICE_CONTRACTID, &res);
    1:   if (NS_SUCCEEDED(res)) {
    1:     nsCOMPtr<nsILocale> appLocale;
    1:     res = localeService->GetApplicationLocale(getter_AddRefs(appLocale));
    1:     if (NS_SUCCEEDED(res)) {
    1:       res = appLocale->GetCategory(category, localeStr);
    1:       if (NS_SUCCEEDED(res) && !localeStr.IsEmpty()) {
    1:         mAppLocale = localeStr; // cache app locale name
    1:       }
    1:     }
    1:   }
    1:   
    1:   // use app default if no locale specified
    1:   if (nsnull == locale) {
    1:     mUseDefaultLocale = true;
    1:   }
    1:   else {
    1:     mUseDefaultLocale = false;
    1:     res = locale->GetCategory(category, localeStr);
    1:   }
    1:     
    1:   if (NS_SUCCEEDED(res) && !localeStr.IsEmpty()) {
    1:     mLocale.Assign(localeStr); // cache locale name
    1:   }
    1: 
    1:   return res;
    1: }
    1: 
    1: // performs a locale sensitive date formatting operation on the time_t parameter
    1: nsresult nsDateTimeFormatMac::FormatTime(nsILocale* locale, 
    1:                                       const nsDateFormatSelector  dateFormatSelector, 
    1:                                       const nsTimeFormatSelector timeFormatSelector, 
    1:                                       const time_t  timetTime, 
    1:                                       nsAString& stringOut)
    1: {
26226:   struct tm tmTime;
26226:   return FormatTMTime(locale, dateFormatSelector, timeFormatSelector, localtime_r(&timetTime, &tmTime), stringOut);
    1: }
    1: 
    1: // performs a locale sensitive date formatting operation on the struct tm parameter
    1: nsresult nsDateTimeFormatMac::FormatTMTime(nsILocale* locale, 
    1:                                            const nsDateFormatSelector  dateFormatSelector, 
    1:                                            const nsTimeFormatSelector timeFormatSelector, 
    1:                                            const struct tm*  tmTime, 
    1:                                            nsAString& stringOut)
    1: {
26226:   nsresult res = NS_OK;
    1: 
    1:   // set up locale data
    1:   (void) Initialize(locale);
    1:   
    1:   // return, nothing to format
    1:   if (dateFormatSelector == kDateFormatNone && timeFormatSelector == kTimeFormatNone) {
    1:     stringOut.Truncate();
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_ASSERTION(tmTime->tm_mon >= 0, "tm is not set correctly");
    1:   NS_ASSERTION(tmTime->tm_mday >= 1, "tm is not set correctly");
    1:   NS_ASSERTION(tmTime->tm_hour >= 0, "tm is not set correctly");
    1:   NS_ASSERTION(tmTime->tm_min >= 0, "tm is not set correctly");
    1:   NS_ASSERTION(tmTime->tm_sec >= 0, "tm is not set correctly");
    1:   NS_ASSERTION(tmTime->tm_wday >= 0, "tm is not set correctly");
    1: 
26226:   // Got the locale for the formatter:
26226:   CFLocaleRef formatterLocale;
26226:   if (!locale) {
26226:     formatterLocale = CFLocaleCopyCurrent();
26226:   } else {
26226:     CFStringRef localeStr = CFStringCreateWithCharacters(NULL, mLocale.get(), mLocale.Length());
26226:     formatterLocale = CFLocaleCreate(NULL, localeStr);
26226:     CFRelease(localeStr);
    1:   }
    1: 
26226:   // Get the date style for the formatter:  
26226:   CFDateFormatterStyle dateStyle;
    1:   switch (dateFormatSelector) {
    1:     case kDateFormatLong:
26226:       dateStyle = kCFDateFormatterLongStyle;
    1:       break;
    1:     case kDateFormatShort:
26226:       dateStyle = kCFDateFormatterShortStyle;
    1:       break;
    1:     case kDateFormatYearMonth:
26226:     case kDateFormatWeekday:
26226:       dateStyle = kCFDateFormatterNoStyle; // formats handled below
26225:       break;
26226:     case kDateFormatNone:
26226:       dateStyle = kCFDateFormatterNoStyle;
    1:       break;
26226:     default:
26226:       NS_ERROR("Unknown nsDateFormatSelector");
26226:       res = NS_ERROR_FAILURE;
26226:       dateStyle = kCFDateFormatterNoStyle;
    1:   }
    1:   
26226:   // Get the time style for the formatter:
26226:   CFDateFormatterStyle timeStyle;
26226:   switch (timeFormatSelector) {
26226:     case kTimeFormatSeconds:
26226:     case kTimeFormatSecondsForce24Hour: // 24 hour part fixed below
26226:       timeStyle = kCFDateFormatterMediumStyle;
26226:       break;
26226:     case kTimeFormatNoSeconds:
26226:     case kTimeFormatNoSecondsForce24Hour: // 24 hour part fixed below
26226:       timeStyle = kCFDateFormatterShortStyle;
26226:       break;
26226:     case kTimeFormatNone:
26226:       timeStyle = kCFDateFormatterNoStyle;
26226:       break;
26226:     default:
26226:       NS_ERROR("Unknown nsTimeFormatSelector");
26226:       res = NS_ERROR_FAILURE;
26226:       timeStyle = kCFDateFormatterNoStyle;
    1:   }
    1:   
26226:   // Create the formatter and fix up its formatting as necessary:
26226:   CFDateFormatterRef formatter =
26226:     CFDateFormatterCreate(NULL, formatterLocale, dateStyle, timeStyle);
    1:   
26226:   CFRelease(formatterLocale);
26226:   
26226:   if (dateFormatSelector == kDateFormatYearMonth ||
26226:       dateFormatSelector == kDateFormatWeekday) {
26226:     CFStringRef dateFormat =
26435:       dateFormatSelector == kDateFormatYearMonth ? CFSTR("yyyy/MM ") : CFSTR("EEE ");
26226:     
26226:     CFStringRef oldFormat = CFDateFormatterGetFormat(formatter);
26226:     CFMutableStringRef newFormat = CFStringCreateMutableCopy(NULL, 0, oldFormat);
26226:     CFStringInsert(newFormat, 0, dateFormat);
26226:     CFDateFormatterSetFormat(formatter, newFormat);
26226:     CFRelease(newFormat); // note we don't own oldFormat
    1:   }
26226:   
26226:   if (timeFormatSelector == kTimeFormatSecondsForce24Hour ||
26226:       timeFormatSelector == kTimeFormatNoSecondsForce24Hour) {
26226:     // Replace "h" with "H", and remove "a":
26226:     CFStringRef oldFormat = CFDateFormatterGetFormat(formatter);
26226:     CFMutableStringRef newFormat = CFStringCreateMutableCopy(NULL, 0, oldFormat);
26226:     CFIndex replaceCount = CFStringFindAndReplace(newFormat,
26226:                                                   CFSTR("h"), CFSTR("H"),
26226:                                                   CFRangeMake(0, CFStringGetLength(newFormat)),	
26226:                                                   0);
26226:     NS_ASSERTION(replaceCount == 1, "Unexpected number of \"h\" occurrences");
26226:     replaceCount = CFStringFindAndReplace(newFormat,
26226:                                           CFSTR("a"), CFSTR(""),
26226:                                           CFRangeMake(0, CFStringGetLength(newFormat)),	
26226:                                           0);
26226:     NS_ASSERTION(replaceCount == 1, "Unexpected number of \"a\" occurrences");
26226:     CFDateFormatterSetFormat(formatter, newFormat);
26226:     CFRelease(newFormat); // note we don't own oldFormat
    1:   }
    1:   
26226:   // Now get the formatted date:
26226:   CFGregorianDate date;
26226:   date.second = tmTime->tm_sec;
26226:   date.minute = tmTime->tm_min;
26226:   date.hour = tmTime->tm_hour;
26226:   date.day = tmTime->tm_mday;      // Mac is 1-based, tm is 1-based
26226:   date.month = tmTime->tm_mon + 1; // Mac is 1-based, tm is 0-based
26226:   date.year = tmTime->tm_year + 1900;
26226: 
26226:   CFTimeZoneRef timeZone = CFTimeZoneCopySystem(); // tmTime is in local time
26226:   CFAbsoluteTime absTime = CFGregorianDateGetAbsoluteTime(date, timeZone);
26226:   CFRelease(timeZone);
26226: 
26226:   CFStringRef formattedDate = CFDateFormatterCreateStringWithAbsoluteTime(NULL, formatter, absTime);
26226:   
26226:   CFIndex stringLen = CFStringGetLength(formattedDate);
26226:   
26226:   nsAutoTArray<UniChar, 256> stringBuffer;
26226:   if (stringBuffer.SetLength(stringLen + 1)) {
26226:     CFStringGetCharacters(formattedDate, CFRangeMake(0, stringLen), stringBuffer.Elements());
26226:     stringOut.Assign(stringBuffer.Elements(), stringLen);
26226:   }
26226:   
26226:   CFRelease(formattedDate);
26226:   CFRelease(formatter);
26226:   
    1:   return res;
    1: }
    1: 
    1: // performs a locale sensitive date formatting operation on the PRTime parameter
    1: nsresult nsDateTimeFormatMac::FormatPRTime(nsILocale* locale, 
    1:                                            const nsDateFormatSelector  dateFormatSelector, 
    1:                                            const nsTimeFormatSelector timeFormatSelector, 
    1:                                            const PRTime  prTime, 
    1:                                            nsAString& stringOut)
    1: {
    1:   PRExplodedTime explodedTime;
    1:   PR_ExplodeTime(prTime, PR_LocalTimeParameters, &explodedTime);
    1: 
    1:   return FormatPRExplodedTime(locale, dateFormatSelector, timeFormatSelector, &explodedTime, stringOut);
    1: }
    1: 
    1: // performs a locale sensitive date formatting operation on the PRExplodedTime parameter
    1: nsresult nsDateTimeFormatMac::FormatPRExplodedTime(nsILocale* locale, 
    1:                                                    const nsDateFormatSelector  dateFormatSelector, 
    1:                                                    const nsTimeFormatSelector timeFormatSelector, 
    1:                                                    const PRExplodedTime*  explodedTime, 
    1:                                                    nsAString& stringOut)
    1: {
    1:   struct tm  tmTime;
    1:   memset( &tmTime, 0, sizeof(tmTime) );
    1: 
    1:   tmTime.tm_yday = explodedTime->tm_yday;
    1:   tmTime.tm_wday = explodedTime->tm_wday;
    1:   tmTime.tm_year = explodedTime->tm_year;
    1:   tmTime.tm_year -= 1900;
    1:   tmTime.tm_mon = explodedTime->tm_month;
    1:   tmTime.tm_mday = explodedTime->tm_mday;
    1:   tmTime.tm_hour = explodedTime->tm_hour;
    1:   tmTime.tm_min = explodedTime->tm_min;
    1:   tmTime.tm_sec = explodedTime->tm_sec;
    1: 
    1:   return FormatTMTime(locale, dateFormatSelector, timeFormatSelector, &tmTime, stringOut);
    1: }
    1: 
