    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Blake Ross <blakeross@telocity.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: //
    1: // Eric Vaughan
    1: // Netscape Communications
    1: //
    1: // See documentation in associated header file
    1: //
    1: 
    1: #include "nsSplitterFrame.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMXULElement.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsPresContext.h"
    1: #include "nsIDocument.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsScrollbarButtonFrame.h"
    1: #include "nsIDOMMouseListener.h"
    1: #include "nsIDOMMouseMotionListener.h"
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsIView.h"
    1: #include "nsIViewManager.h"
    1: #include "nsIScrollableView.h"
    1: #include "nsIDOMMouseEvent.h"
    1: #include "nsIPresShell.h"
27841: #include "nsFrameList.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsILookAndFeel.h"
    1: #include "nsStyleContext.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsBoxLayoutState.h"
    1: #include "nsIXBLService.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsHTMLContainerFrame.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsContentCID.h"
    1: #include "nsStyleSet.h"
    1: #include "nsLayoutUtils.h"
    1: #include "nsDisplayList.h"
    1: #include "nsContentUtils.h"
    1: 
    1: // was used in nsSplitterFrame::Init but now commented out
    1: //static NS_DEFINE_IID(kLookAndFeelCID,  NS_LOOKANDFEEL_CID);
    1: PRInt32 realTimeDrag;
    1: 
    1: class nsSplitterInfo {
    1: public:
    1:   nscoord min;
    1:   nscoord max;
    1:   nscoord current;
    1:   nscoord changed;
    1:   nsCOMPtr<nsIContent> childElem;
    1:   PRInt32 flex;
    1:   PRInt32 index;
    1: };
    1: 
    1: class nsSplitterFrameInner : public nsIDOMMouseListener, public nsIDOMMouseMotionListener {
    1: 
    1: public:
    1: 
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   nsSplitterFrameInner(nsSplitterFrame* aSplitter)
    1:   {
    1:     mOuter = aSplitter;
    1:     mPressed = PR_FALSE;
    1:   }
    1:   virtual ~nsSplitterFrameInner();
    1: 
 1667:   void Disconnect() { mOuter = nsnull; }
 1667: 
    1:   // mouse listener
    1:   NS_IMETHOD MouseDown(nsIDOMEvent* aMouseEvent);
    1:   NS_IMETHOD MouseUp(nsIDOMEvent* aMouseEvent);
    1:   NS_IMETHOD MouseClick(nsIDOMEvent* aMouseEvent) { return NS_OK; }
    1:   NS_IMETHOD MouseDblClick(nsIDOMEvent* aMouseEvent) { return NS_OK; }
    1:   NS_IMETHOD MouseOver(nsIDOMEvent* aMouseEvent) { return NS_OK; }
    1:   NS_IMETHOD MouseOut(nsIDOMEvent* aMouseEvent) { return MouseMove(aMouseEvent); }
    1:   NS_IMETHOD HandleEvent(nsIDOMEvent* aEvent) { return NS_OK; }
    1: 
    1:   // mouse motion listener
    1:   NS_IMETHOD MouseMove(nsIDOMEvent* aMouseEvent);
    1:   NS_IMETHOD DragMove(nsIDOMEvent* aMouseEvent) { return NS_OK; }
    1: 
    1:   void MouseDrag(nsPresContext* aPresContext, nsGUIEvent* aEvent);
    1:   void MouseUp(nsPresContext* aPresContext, nsGUIEvent* aEvent);
    1: 
    1:   void AdjustChildren(nsPresContext* aPresContext);
    1:   void AdjustChildren(nsPresContext* aPresContext, nsSplitterInfo* aChildInfos, PRInt32 aCount, PRBool aIsHorizontal);
    1: 
    1:   void AddRemoveSpace(nscoord aDiff,
    1:                     nsSplitterInfo* aChildInfos,
    1:                     PRInt32 aCount,
    1:                     PRInt32& aSpaceLeft);
    1: 
    1:   void ResizeChildTo(nsPresContext* aPresContext,
    1:                    nscoord& aDiff, 
    1:                    nsSplitterInfo* aChildrenBeforeInfos, 
    1:                    nsSplitterInfo* aChildrenAfterInfos, 
    1:                    PRInt32 aChildrenBeforeCount, 
    1:                    PRInt32 aChildrenAfterCount, 
    1:                    PRBool aBounded);
    1: 
    1:   void UpdateState();
    1: 
    1:   void AddListener(nsPresContext* aPresContext);
    1:   void RemoveListener();
    1: 
 8002:   enum ResizeType { Closest, Farthest, Flex, Grow };
    1:   enum State { Open, CollapsedBefore, CollapsedAfter, Dragging };
    1:   enum CollapseDirection { Before, After };
    1: 
    1:   ResizeType GetResizeBefore();
    1:   ResizeType GetResizeAfter();
    1:   State GetState();
    1: 
    1:   //nsresult CaptureMouse(nsPresContext* aPresContext, PRBool aGrabMouseEvents);
    1:   //PRBool IsMouseCaptured(nsPresContext* aPresContext);
    1:   void Reverse(nsSplitterInfo*& aIndexes, PRInt32 aCount);
    1:   PRBool SupportsCollapseDirection(CollapseDirection aDirection);
    1: 
    1:   void MoveSplitterBy(nsPresContext* aPresContext, nscoord aDiff);
    1:   void EnsureOrient();
    1:   void SetPreferredSize(nsBoxLayoutState& aState, nsIBox* aChildBox, nscoord aOnePixel, PRBool aIsHorizontal, nscoord* aSize);
    1: 
    1:   nsSplitterFrame* mOuter;
    1:   PRBool mDidDrag;
    1:   nscoord mDragStart;
    1:   nscoord mCurrentPos;
    1:   nsIBox* mParentBox;
    1:   PRBool mPressed;
    1:   nsSplitterInfo* mChildInfosBefore;
    1:   nsSplitterInfo* mChildInfosAfter;
    1:   PRInt32 mChildInfosBeforeCount;
    1:   PRInt32 mChildInfosAfterCount;
    1:   State mState;
    1:   nscoord mSplitterPos;
    1:   nscoord mSplitterViewPos;
    1:   PRBool mDragging;
    1: 
    1: };
    1: 
    1: 
13964: NS_IMPL_ADDREF(nsSplitterFrameInner)
13964: NS_IMPL_RELEASE(nsSplitterFrameInner)
13964: NS_INTERFACE_MAP_BEGIN(nsSplitterFrameInner)
13964:   NS_INTERFACE_MAP_ENTRY(nsIDOMMouseListener)
13964:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsIDOMEventListener,nsIDOMMouseListener)
13964:   NS_INTERFACE_MAP_ENTRY(nsIDOMMouseMotionListener)
13964: NS_INTERFACE_MAP_END
    1: 
    1: nsSplitterFrameInner::ResizeType
    1: nsSplitterFrameInner::GetResizeBefore()
    1: {
 8002:   static nsIContent::AttrValuesArray strings[] =
 8002:     {&nsGkAtoms::farthest, &nsGkAtoms::flex, nsnull};
 8002:   switch (mOuter->GetContent()->FindAttrValueIn(kNameSpaceID_None,
 8002:                                                 nsGkAtoms::resizebefore,
 8002:                                                 strings, eCaseMatters)) {
 8002:     case 0: return Farthest;
 8002:     case 1: return Flex;
 8002:   }
    1:   return Closest;
    1: }
    1: 
    1: nsSplitterFrameInner::~nsSplitterFrameInner() 
    1: {
    1:   delete[] mChildInfosBefore;
    1:   delete[] mChildInfosAfter;
    1: }
    1: 
    1: nsSplitterFrameInner::ResizeType
    1: nsSplitterFrameInner::GetResizeAfter()
    1: {
    1:   static nsIContent::AttrValuesArray strings[] =
 8002:     {&nsGkAtoms::farthest, &nsGkAtoms::flex, &nsGkAtoms::grow, nsnull};
    1:   switch (mOuter->GetContent()->FindAttrValueIn(kNameSpaceID_None,
    1:                                                 nsGkAtoms::resizeafter,
    1:                                                 strings, eCaseMatters)) {
    1:     case 0: return Farthest;
 8002:     case 1: return Flex;
 8002:     case 2: return Grow;
    1:   }
    1:   return Closest;
    1: }
    1: 
    1: nsSplitterFrameInner::State
    1: nsSplitterFrameInner::GetState()
    1: {
    1:   static nsIContent::AttrValuesArray strings[] =
    1:     {&nsGkAtoms::dragging, &nsGkAtoms::collapsed, nsnull};
    1:   static nsIContent::AttrValuesArray strings_substate[] =
    1:     {&nsGkAtoms::before, &nsGkAtoms::after, nsnull};
    1:   switch (mOuter->GetContent()->FindAttrValueIn(kNameSpaceID_None,
    1:                                                 nsGkAtoms::state,
    1:                                                 strings, eCaseMatters)) {
    1:     case 0: return Dragging;
    1:     case 1:
    1:       switch (mOuter->GetContent()->FindAttrValueIn(kNameSpaceID_None,
    1:                                                     nsGkAtoms::substate,
    1:                                                     strings_substate,
    1:                                                     eCaseMatters)) {
    1:         case 0: return CollapsedBefore;
    1:         case 1: return CollapsedAfter;
    1:         default:
    1:           if (SupportsCollapseDirection(After))
    1:             return CollapsedAfter;
    1:           return CollapsedBefore;
    1:       }
    1:   }
    1:   return Open;
    1: }
    1: 
    1: //
    1: // NS_NewSplitterFrame
    1: //
    1: // Creates a new Toolbar frame and returns it
    1: //
    1: nsIFrame*
    1: NS_NewSplitterFrame (nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsSplitterFrame(aPresShell, aContext);
    1: } // NS_NewSplitterFrame
    1: 
    1: nsSplitterFrame::nsSplitterFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: : nsBoxFrame(aPresShell, aContext),
    1:   mInner(0)
    1: {
    1: }
    1: 
 1667: void
 1667: nsSplitterFrame::Destroy()
    1: {
    1:   if (mInner) {
    1:     mInner->RemoveListener();
 1667:     mInner->Disconnect();
    1:     mInner->Release();
 1667:     mInner = nsnull;
    1:   }
 1667:   nsBoxFrame::Destroy();
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsSplitterFrame::GetCursor(const nsPoint&    aPoint,
    1:                            nsIFrame::Cursor& aCursor)
    1: {
    1:   return nsBoxFrame::GetCursor(aPoint, aCursor);
    1: 
    1:   /*
    1:     if (IsHorizontal())
    1:       aCursor = NS_STYLE_CURSOR_N_RESIZE;
    1:     else
    1:       aCursor = NS_STYLE_CURSOR_W_RESIZE;
    1: 
    1:     return NS_OK;
    1:   */
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSplitterFrame::AttributeChanged(PRInt32 aNameSpaceID,
    1:                                   nsIAtom* aAttribute,
    1:                                   PRInt32 aModType)
    1: {
    1:   nsresult rv = nsBoxFrame::AttributeChanged(aNameSpaceID, aAttribute,
    1:                                              aModType);
    1:   // if the alignment changed. Let the grippy know
    1:   if (aAttribute == nsGkAtoms::align) {
    1:     // tell the slider its attribute changed so it can 
    1:     // update itself
    1:     nsIFrame* grippy = nsnull;
  238:     nsScrollbarButtonFrame::GetChildWithTag(PresContext(), nsGkAtoms::grippy, this, grippy);
    1:     if (grippy)
    1:       grippy->AttributeChanged(aNameSpaceID, aAttribute, aModType);
    1:   } else if (aAttribute == nsGkAtoms::state) {
    1:     mInner->UpdateState();
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: /**
    1:  * Initialize us. If we are in a box get our alignment so we know what direction we are
    1:  */
    1: NS_IMETHODIMP
    1: nsSplitterFrame::Init(nsIContent*      aContent,
    1:                       nsIFrame*        aParent,
    1:                       nsIFrame*        aPrevInFlow)
    1: {
    1:   NS_ENSURE_FALSE(mInner, NS_ERROR_ALREADY_INITIALIZED);
    1:   mInner = new nsSplitterFrameInner(this);
    1:   if (!mInner)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   mInner->AddRef();
    1:   mInner->mChildInfosAfter = nsnull;
    1:   mInner->mChildInfosBefore = nsnull;
    1:   mInner->mState = nsSplitterFrameInner::Open;
    1:   mInner->mDragging = PR_FALSE;
    1: 
    1:   {
    1: #if 0
    1:     // make it real time drag for now due to problems
    1:     nsCOMPtr<nsILookAndFeel> lookAndFeel = do_GetService(kLookAndFeelCID);
    1:     if (lookAndFeel) {
    1:       lookAndFeel->GetMetric(nsILookAndFeel::eMetric_DragFullWindow, realTimeDrag);
    1:     }
    1:     else
    1: #endif
    1:       realTimeDrag = 1;
    1:   }
    1: 
    1:   // determine orientation of parent, and if vertical, set orient to vertical
    1:   // on splitter content, then re-resolve style
 6632:   // XXXbz this is pretty messed up, since this can change whether we should
 6632:   // have a frame at all.  This really needs a better solution.
    1:   if (aParent && aParent->IsBoxFrame()) {
    1:     if (!aParent->IsHorizontal()) {
    1:       if (!nsContentUtils::HasNonEmptyAttr(aContent, kNameSpaceID_None,
    1:                                            nsGkAtoms::orient)) {
    1:         aContent->SetAttr(kNameSpaceID_None, nsGkAtoms::orient,
    1:                           NS_LITERAL_STRING("vertical"), PR_FALSE);
 6632:         nsStyleContext* parentStyleContext = GetStyleContext()->GetParent();
 6632:         nsRefPtr<nsStyleContext> newContext = PresContext()->StyleSet()->
    1:           ResolveStyleFor(aContent, parentStyleContext);
    1:         SetStyleContextWithoutNotification(newContext);
    1:       }
    1:     }
    1:   }
    1: 
    1:   nsresult  rv = nsBoxFrame::Init(aContent, aParent, aPrevInFlow);
 1412:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
23395:   rv = nsHTMLContainerFrame::CreateViewForFrame(this, PR_TRUE);
 1412:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!realTimeDrag) {
 1412:     nsIView* view = GetView();
    1:     // currently this only works on win32 and mac
    1:     static NS_DEFINE_CID(kCChildCID, NS_CHILD_CID);
    1: 
    1:     // Need to have a widget to appear on top of other widgets.
 1412:     NS_ASSERTION(!view->HasWidget(), "have an unwanted widget");
 1412:     if (!view->HasWidget()) {
    1:       view->CreateWidget(kCChildCID);
    1:     }
 1412:   }
    1: 
    1:   mInner->mState = nsSplitterFrameInner::Open;
  238:   mInner->AddListener(PresContext());
    1:   mInner->mParentBox = nsnull;
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSplitterFrame::DoLayout(nsBoxLayoutState& aState)
    1: {
    1:   if (GetStateBits() & NS_FRAME_FIRST_REFLOW) 
    1:   {
    1:     mInner->mParentBox = GetParentBox();
    1:     mInner->UpdateState();
    1:   }
    1: 
    1:   return nsBoxFrame::DoLayout(aState);
    1: }
    1: 
    1: 
    1: void
    1: nsSplitterFrame::GetInitialOrientation(PRBool& aIsHorizontal)
    1: {
    1:   nsIBox* box = GetParentBox();
    1:   if (box) {
    1:     aIsHorizontal = !box->IsHorizontal();
    1:   }
    1:   else
    1:     nsBoxFrame::GetInitialOrientation(aIsHorizontal);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSplitterFrame::HandlePress(nsPresContext* aPresContext,
    1:                          nsGUIEvent *    aEvent,
    1:                          nsEventStatus*  aEventStatus)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSplitterFrame::HandleMultiplePress(nsPresContext* aPresContext,
    1:                          nsGUIEvent *    aEvent,
    1:                          nsEventStatus*  aEventStatus)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSplitterFrame::HandleDrag(nsPresContext* aPresContext,
    1:                         nsGUIEvent *    aEvent,
    1:                         nsEventStatus*  aEventStatus)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSplitterFrame::HandleRelease(nsPresContext* aPresContext,
    1:                            nsGUIEvent *    aEvent,
    1:                            nsEventStatus*  aEventStatus)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSplitterFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                   const nsRect&           aDirtyRect,
    1:                                   const nsDisplayListSet& aLists)
    1: {
    1:   nsresult rv = nsBoxFrame::BuildDisplayList(aBuilder, aDirtyRect, aLists);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   // if the mouse is captured always return us as the frame.
    1:   if (mInner->mDragging)
    1:   {
    1:     // XXX It's probably better not to check visibility here, right?
    1:     return aLists.Outlines()->AppendNewToTop(new (aBuilder)
    1:         nsDisplayEventReceiver(this));
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSplitterFrame::HandleEvent(nsPresContext* aPresContext, 
    1:                                       nsGUIEvent* aEvent,
    1:                                       nsEventStatus* aEventStatus)
    1: {
25590:   NS_ENSURE_ARG_POINTER(aEventStatus);
25590:   if (nsEventStatus_eConsumeNoDefault == *aEventStatus) {
25590:     return NS_OK;
25590:   }
25590: 
    1:   nsWeakFrame weakFrame(this);
    1:   nsRefPtr<nsSplitterFrameInner> kungFuDeathGrip(mInner);
    1:   switch (aEvent->message) {
    1:     case NS_MOUSE_MOVE: 
    1:       mInner->MouseDrag(aPresContext, aEvent);
    1:     break;
    1:   
    1:     case NS_MOUSE_BUTTON_UP:
    1:       if (aEvent->eventStructType == NS_MOUSE_EVENT &&
 3233:           static_cast<nsMouseEvent*>(aEvent)->button ==
    1:             nsMouseEvent::eLeftButton) {
    1:         mInner->MouseUp(aPresContext, aEvent);
    1:       }
    1:     break;
    1:   }
    1: 
    1:   NS_ENSURE_STATE(weakFrame.IsAlive());
    1:   return nsBoxFrame::HandleEvent(aPresContext, aEvent, aEventStatus);
    1: }
    1: 
    1: void
    1: nsSplitterFrameInner::MouseUp(nsPresContext* aPresContext, nsGUIEvent* aEvent)
    1: {
 1667:   if (mDragging && mOuter) {
    1:     AdjustChildren(aPresContext);
    1:     AddListener(aPresContext);
    1:     mOuter->CaptureMouse(aPresContext, PR_FALSE);
    1:     mDragging = PR_FALSE;
    1:     State newState = GetState(); 
    1:     // if the state is dragging then make it Open.
    1:     if (newState == Dragging)
    1:       mOuter->mContent->SetAttr(kNameSpaceID_None, nsGkAtoms::state, EmptyString(), PR_TRUE);
    1: 
    1:     mPressed = PR_FALSE;
    1: 
    1:     // if we dragged then fire a command event.
    1:     if (mDidDrag) {
    1:       nsCOMPtr<nsIDOMXULElement> element = do_QueryInterface(mOuter->GetContent());
    1:       element->DoCommand();
    1:     }
    1: 
    1:     //printf("MouseUp\n");
    1:   }
    1: 
    1:   delete[] mChildInfosBefore;
    1:   delete[] mChildInfosAfter;
    1:   mChildInfosBefore = nsnull;
    1:   mChildInfosAfter = nsnull;
19336:   mChildInfosBeforeCount = 0;
19336:   mChildInfosAfterCount = 0;
    1: }
    1: 
    1: void
    1: nsSplitterFrameInner::MouseDrag(nsPresContext* aPresContext, nsGUIEvent* aEvent)
    1: {
 1667:   if (mDragging && mOuter) {
    1: 
    1:     //printf("Dragging\n");
    1: 
    1:     PRBool isHorizontal = !mOuter->IsHorizontal();
    1:     // convert coord to pixels
    1:     nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent,
    1:                                                               mParentBox);
    1:     nscoord pos = isHorizontal ? pt.x : pt.y;
    1: 
    1:     // mDragStart is in frame coordinates
    1:     nscoord start = mDragStart;
    1: 
    1:     // take our current position and subtract the start location
    1:     pos -= start;
    1: 
    1:     //printf("Diff=%d\n", pos);
    1: 
    1:     ResizeType resizeAfter  = GetResizeAfter();
    1: 
    1:     PRBool bounded;
    1: 
    1:     if (resizeAfter == nsSplitterFrameInner::Grow)
    1:       bounded = PR_FALSE;
    1:     else 
    1:       bounded = PR_TRUE;
    1: 
    1:     int i;
    1:     for (i=0; i < mChildInfosBeforeCount; i++) 
    1:       mChildInfosBefore[i].changed = mChildInfosBefore[i].current;
    1: 
    1:     for (i=0; i < mChildInfosAfterCount; i++) 
    1:       mChildInfosAfter[i].changed = mChildInfosAfter[i].current;
    1: 
    1:     nscoord oldPos = pos;
    1: 
    1:     ResizeChildTo(aPresContext, pos, mChildInfosBefore, mChildInfosAfter, mChildInfosBeforeCount, mChildInfosAfterCount, bounded);
    1: 
    1:     State currentState = GetState();
    1:     PRBool supportsBefore = SupportsCollapseDirection(Before);
    1:     PRBool supportsAfter = SupportsCollapseDirection(After);
    1: 
    1:     // if we are in a collapsed position
    1:     if (realTimeDrag && ((oldPos > 0 && oldPos > pos && supportsAfter) ||
    1:                          (oldPos < 0 && oldPos < pos && supportsBefore)))
    1:     {
    1:       // and we are not collapsed then collapse
    1:       if (currentState == Dragging) {
    1:         if (oldPos > 0 && oldPos > pos)
    1:         {
    1:           //printf("Collapse right\n");
    1:           if (supportsAfter) 
    1:           {
    1:             nsCOMPtr<nsIContent> outer = mOuter->mContent;
    1:             outer->SetAttr(kNameSpaceID_None, nsGkAtoms::substate,
    1:                            NS_LITERAL_STRING("after"),
    1:                            PR_TRUE);
    1:             outer->SetAttr(kNameSpaceID_None, nsGkAtoms::state,
    1:                            NS_LITERAL_STRING("collapsed"),
    1:                            PR_TRUE);
    1:           }
    1: 
    1:         } else if (oldPos < 0 && oldPos < pos)
    1:         {
    1:           //printf("Collapse left\n");
    1:           if (supportsBefore)
    1:           {
    1:             nsCOMPtr<nsIContent> outer = mOuter->mContent;
    1:             outer->SetAttr(kNameSpaceID_None, nsGkAtoms::substate,
    1:                            NS_LITERAL_STRING("before"),
    1:                            PR_TRUE);
    1:             outer->SetAttr(kNameSpaceID_None, nsGkAtoms::state,
    1:                            NS_LITERAL_STRING("collapsed"),
    1:                            PR_TRUE);
    1:           }
    1:         }
    1:       }
    1:     } else {
    1:       // if we are not in a collapsed position and we are not dragging make sure
    1:       // we are dragging.
    1:       if (currentState != Dragging)
    1:         mOuter->mContent->SetAttr(kNameSpaceID_None, nsGkAtoms::state, NS_LITERAL_STRING("dragging"), PR_TRUE);
    1:       if (realTimeDrag)
    1:         AdjustChildren(aPresContext);
    1:       else
    1:         MoveSplitterBy(aPresContext, pos);
    1:     }
    1: 
    1:     // printf("----- resize ----- ");
    1:     /*
    1:       for (i=0; i < mChildInfosBeforeCount; i++) 
    1:         printf("before, index=%d, current=%d, changed=%d\n", mChildInfosBefore[i].index, mChildInfosBefore[i].current, mChildInfosBefore[i].changed);
    1:       for (i=0; i < mChildInfosAfterCount; i++) 
    1:         printf("after, index=%d, current=%d, changed=%d\n", mChildInfosAfter[i].index, mChildInfosAfter[i].current, mChildInfosAfter[i].changed);
    1:     */
    1: 
    1:     /*
    1:       nsIPresShell *shell = aPresContext->PresShell();
    1: 
 1158:       shell->FrameNeedsReflow(mOuter, nsIPresShell::eStyleChange,
 1158:                               NS_FRAME_IS_DIRTY);
    1:     */
    1:     mDidDrag = PR_TRUE;
    1:   }
    1: }
    1: 
    1: void
    1: nsSplitterFrameInner::AddListener(nsPresContext* aPresContext)
    1: {
 1418:   mOuter->GetContent()->
 3233:     AddEventListenerByIID(static_cast<nsIDOMMouseListener*>(this),
 1418:                           NS_GET_IID(nsIDOMMouseListener));
 1418:   mOuter->GetContent()->
 3233:     AddEventListenerByIID(static_cast<nsIDOMMouseMotionListener*>(this),
 1418:                           NS_GET_IID(nsIDOMMouseMotionListener));
    1: }
    1: 
    1: void
    1: nsSplitterFrameInner::RemoveListener()
    1: {
 1667:   ENSURE_TRUE(mOuter);
 1418:   mOuter->GetContent()->
 3233:     RemoveEventListenerByIID(static_cast<nsIDOMMouseListener*>(this),
 1418:                              NS_GET_IID(nsIDOMMouseListener));
 1418:   mOuter->GetContent()->
 3233:     RemoveEventListenerByIID(static_cast<nsIDOMMouseMotionListener*>(this),
 1418:                              NS_GET_IID(nsIDOMMouseMotionListener));
    1: }
    1: 
    1: /*
    1: nsresult
    1: nsSplitterFrameInner :: CaptureMouse(nsPresContext* aPresContext, PRBool aGrabMouseEvents)
    1: {
    1:   // get its view
    1:   nsIView* view = mOuter->GetView();
    1:   PRBool result;
    1: 
    1:   if (view) {
    1:     nsIViewManager* viewMan = view->GetViewManager();
    1:     if (viewMan) {
    1:       // nsIWidget* widget = view->GetWidget();
    1:       if (aGrabMouseEvents) {
    1:         viewMan->GrabMouseEvents(view,result);
    1:         //  if (widget)
    1:         //   widget->CaptureMouse(PR_TRUE);
    1:       } else {
    1:         viewMan->GrabMouseEvents(nsnull,result);
    1:        // if (widget)
    1:          //  widget->CaptureMouse(PR_FALSE);
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: PRBool
    1: nsSplitterFrameInner :: IsMouseCaptured(nsPresContext* aPresContext)
    1: {
    1:     // get its view
    1:   nsIView* view = mOuter->GetView();
    1:   
    1:   if (view) {
    1:     nsIViewManager* viewMan = view->GetViewManager();
    1: 
    1:     if (viewMan) {
    1:         nsIView* grabbingView;
    1:         viewMan->GetMouseEventGrabber(grabbingView);
    1:         if (grabbingView == view)
    1:           return PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: */
    1: 
    1: nsresult
    1: nsSplitterFrameInner::MouseUp(nsIDOMEvent* aMouseEvent)
    1: {  
 1667:   NS_ENSURE_TRUE(mOuter, NS_OK);
    1:   mPressed = PR_FALSE;
    1: 
  238:   mOuter->CaptureMouse(mOuter->PresContext(), PR_FALSE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsSplitterFrameInner::MouseDown(nsIDOMEvent* aMouseEvent)
    1: {  
 1667:   NS_ENSURE_TRUE(mOuter, NS_OK);
    1:   nsCOMPtr<nsIDOMMouseEvent> mouseEvent(do_QueryInterface(aMouseEvent));
    1: 
    1:   PRUint16 button = 0;
    1:   mouseEvent->GetButton(&button);
    1: 
    1:   // only if left button
    1:   if (button != 0)
    1:      return NS_OK;
    1: 
    1:   if (mOuter->GetContent()->
    1:         AttrValueIs(kNameSpaceID_None, nsGkAtoms::disabled,
    1:                     nsGkAtoms::_true, eCaseMatters))
    1:     return NS_OK;
    1: 
    1:   mParentBox = mOuter->GetParentBox();
    1:   if (!mParentBox)
    1:     return NS_OK;
    1: 
    1:   // get our index
  238:   nsPresContext* outerPresContext = mOuter->PresContext();
27841:   nsFrameList siblingList(mParentBox->GetFirstChild(nsnull));
27841:   PRInt32 childIndex = siblingList.IndexOf(mOuter);
27841:   // if it's 0 (or not found) then stop right here.
27841:   // It might be not found if we're not in the parent's primary frame list.
27841:   if (childIndex <= 0)
 5247:     return NS_OK;
 5247: 
27841:   PRInt32 childCount = siblingList.GetLength();
 5247:   // if it's the last index then we need to allow for resizeafter="grow"
 5247:   if (childIndex == childCount - 1 && GetResizeAfter() != Grow)
    1:     return NS_OK;
    1: 
  918:   nsCOMPtr<nsIRenderingContext> rc;
  918:   nsresult rv = outerPresContext->PresShell()->
  918:                   CreateRenderingContext(mOuter, getter_AddRefs(rc));
  918:   NS_ENSURE_SUCCESS(rv, rv);
  918:   nsBoxLayoutState state(outerPresContext, rc);
    1:   mCurrentPos = 0;
    1:   mPressed = PR_TRUE;
    1: 
    1:   mDidDrag = PR_FALSE;
    1: 
    1:   EnsureOrient();
    1:   PRBool isHorizontal = !mOuter->IsHorizontal();
    1:   
    1:   ResizeType resizeBefore = GetResizeBefore();
    1:   ResizeType resizeAfter  = GetResizeAfter();
    1: 
    1:   delete[] mChildInfosBefore;
    1:   delete[] mChildInfosAfter;
    1:   mChildInfosBefore = new nsSplitterInfo[childCount];
    1:   mChildInfosAfter  = new nsSplitterInfo[childCount];
    1: 
    1:   // create info 2 lists. One of the children before us and one after.
    1:   PRInt32 count = 0;
    1:   mChildInfosBeforeCount = 0;
    1:   mChildInfosAfterCount = 0;
    1: 
    1:   nsIBox* childBox = mParentBox->GetChildBox();
    1: 
    1:   while (nsnull != childBox) 
    1:   { 
    1:     nsIContent* content = childBox->GetContent();
    1:     nsIDocument* doc = content->GetOwnerDoc();
    1:     nsIAtom* atom;
    1:     if (doc) {
    1:       PRInt32 dummy;
    1:       atom = doc->BindingManager()->ResolveTag(content, &dummy);
    1:     } else {
    1:       atom = content->Tag();
    1:     }
    1: 
    1:     // skip over any splitters
    1:     if (atom != nsGkAtoms::splitter) { 
    1:         nsSize prefSize = childBox->GetPrefSize(state);
    1:         nsSize minSize = childBox->GetMinSize(state);
 9862:         nsSize maxSize = nsBox::BoundsCheckMinMax(minSize, childBox->GetMaxSize(state));
 9862:         prefSize = nsBox::BoundsCheck(minSize, prefSize, maxSize);
    1: 
    1:         mOuter->AddMargin(childBox, minSize);
    1:         mOuter->AddMargin(childBox, prefSize);
    1:         mOuter->AddMargin(childBox, maxSize);
    1: 
    1:         nscoord flex = childBox->GetFlex(state);
    1: 
    1:         nsMargin margin(0,0,0,0);
    1:         childBox->GetMargin(margin);
    1:         nsRect r(childBox->GetRect());
    1:         r.Inflate(margin);
    1: 
    1:         // We need to check for hidden attribute too, since treecols with
    1:         // the hidden="true" attribute are not really hidden, just collapsed
    1:         if (!content->AttrValueIs(kNameSpaceID_None, nsGkAtoms::fixed,
    1:                                   nsGkAtoms::_true, eCaseMatters) &&
    1:             !content->AttrValueIs(kNameSpaceID_None, nsGkAtoms::hidden,
    1:                                   nsGkAtoms::_true, eCaseMatters)) {
 8002:             if (count < childIndex && (resizeBefore != Flex || flex > 0)) {
    1:                 mChildInfosBefore[mChildInfosBeforeCount].childElem = content;
    1:                 mChildInfosBefore[mChildInfosBeforeCount].min     = isHorizontal ? minSize.width : minSize.height;
    1:                 mChildInfosBefore[mChildInfosBeforeCount].max     = isHorizontal ? maxSize.width : maxSize.height;
    1:                 mChildInfosBefore[mChildInfosBeforeCount].current = isHorizontal ? r.width : r.height;
    1:                 mChildInfosBefore[mChildInfosBeforeCount].flex    = flex;
    1:                 mChildInfosBefore[mChildInfosBeforeCount].index   = count;
    1:                 mChildInfosBefore[mChildInfosBeforeCount].changed = mChildInfosBefore[mChildInfosBeforeCount].current;
    1:                 mChildInfosBeforeCount++;
 8002:             } else if (count > childIndex && (resizeAfter != Flex || flex > 0)) {
    1:                 mChildInfosAfter[mChildInfosAfterCount].childElem = content;
    1:                 mChildInfosAfter[mChildInfosAfterCount].min     = isHorizontal ? minSize.width : minSize.height;
    1:                 mChildInfosAfter[mChildInfosAfterCount].max     = isHorizontal ? maxSize.width : maxSize.height;
    1:                 mChildInfosAfter[mChildInfosAfterCount].current = isHorizontal ? r.width : r.height;
    1:                 mChildInfosAfter[mChildInfosAfterCount].flex    = flex;
    1:                 mChildInfosAfter[mChildInfosAfterCount].index   = count;
    1:                 mChildInfosAfter[mChildInfosAfterCount].changed = mChildInfosAfter[mChildInfosAfterCount].current;
    1:                 mChildInfosAfterCount++;
    1:             }
    1:         } 
    1:     }
    1:     
    1:     childBox = childBox->GetNextBox();
    1:     count++;
    1:   }
    1: 
    1:   if (!mParentBox->IsNormalDirection()) {
    1:     // The before array is really the after array, and the order needs to be reversed.
    1:     // First reverse both arrays.
    1:     Reverse(mChildInfosBefore, mChildInfosBeforeCount);
    1:     Reverse(mChildInfosAfter, mChildInfosAfterCount);
    1: 
    1:     // Now swap the two arrays.
    1:     nscoord newAfterCount = mChildInfosBeforeCount;
    1:     mChildInfosBeforeCount = mChildInfosAfterCount;
    1:     mChildInfosAfterCount = newAfterCount;
    1:     nsSplitterInfo* temp = mChildInfosAfter;
    1:     mChildInfosAfter = mChildInfosBefore;
    1:     mChildInfosBefore = temp;
    1:   }
    1: 
 8002:   // if resizebefore is not Farthest, reverse the list because the first child
 8002:   // in the list is the farthest, and we want the first child to be the closest.
 8002:   if (resizeBefore != Farthest)
    1:      Reverse(mChildInfosBefore, mChildInfosBeforeCount);
    1: 
    1:   // if the resizeafter is the Farthest we must reverse the list because the first child in the list
    1:   // is the closest we want the first child to be the Farthest.
    1:   if (resizeAfter == Farthest)
    1:      Reverse(mChildInfosAfter, mChildInfosAfterCount);
    1: 
    1:   // grow only applys to the children after. If grow is set then no space should be taken out of any children after
    1:   // us. To do this we just set the size of that list to be 0.
    1:   if (resizeAfter == Grow)
    1:      mChildInfosAfterCount = 0;
    1: 
    1:   nsRect vr = mOuter->GetView()->GetBounds();
    1: 
    1:   PRInt32 c;
    1:   nsPoint pt = nsLayoutUtils::GetDOMEventCoordinatesRelativeTo(mouseEvent,
    1:                                                                mParentBox);
    1:   if (isHorizontal) {
    1:      c = pt.x;
    1:      mSplitterPos = mOuter->mRect.x;
    1:      mSplitterViewPos = vr.x;
    1:   } else {
    1:      c = pt.y;
    1:      mSplitterPos = mOuter->mRect.y;
    1:      mSplitterViewPos = vr.y;
    1:   }
    1: 
    1:   mDragStart = c;
    1: 
    1:   //printf("Pressed mDragStart=%d\n",mDragStart);
    1: 
    1:   mOuter->CaptureMouse(outerPresContext, PR_TRUE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsSplitterFrameInner::MouseMove(nsIDOMEvent* aMouseEvent)
    1: {  
 1667:   NS_ENSURE_TRUE(mOuter, NS_OK);
    1:   if (!mPressed)
    1:     return NS_OK;
    1: 
    1:   if (mDragging)
    1:     return NS_OK;
    1: 
 1667:   nsCOMPtr<nsIDOMMouseListener> kungfuDeathGrip(this);
    1:   mOuter->mContent->SetAttr(kNameSpaceID_None, nsGkAtoms::state, NS_LITERAL_STRING("dragging"), PR_TRUE);
    1: 
    1:   RemoveListener();
    1:   mDragging = PR_TRUE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsSplitterFrameInner::Reverse(nsSplitterInfo*& aChildInfos, PRInt32 aCount)
    1: {
    1:     nsSplitterInfo* infos = new nsSplitterInfo[aCount];
    1: 
    1:     for (int i=0; i < aCount; i++)
    1:        infos[i] = aChildInfos[aCount - 1 - i];
    1: 
    1:     delete[] aChildInfos;
    1:     aChildInfos = infos;
    1: }
    1: 
    1: PRBool
    1: nsSplitterFrameInner::SupportsCollapseDirection
    1: (
    1:   nsSplitterFrameInner::CollapseDirection aDirection
    1: )
    1: {
    1:   static nsIContent::AttrValuesArray strings[] =
    1:     {&nsGkAtoms::before, &nsGkAtoms::after, &nsGkAtoms::both, nsnull};
    1: 
    1:   switch (mOuter->mContent->FindAttrValueIn(kNameSpaceID_None,
    1:                                             nsGkAtoms::collapse,
    1:                                             strings, eCaseMatters)) {
    1:     case 0:
    1:       return (aDirection == Before);
    1:     case 1:
    1:       return (aDirection == After);
    1:     case 2:
    1:       return PR_TRUE;
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: void
    1: nsSplitterFrameInner::UpdateState()
    1: {
    1:   // State Transitions:
    1:   //   Open            -> Dragging
    1:   //   Open            -> CollapsedBefore
    1:   //   Open            -> CollapsedAfter
    1:   //   CollapsedBefore -> Open
    1:   //   CollapsedBefore -> Dragging
    1:   //   CollapsedAfter  -> Open
    1:   //   CollapsedAfter  -> Dragging
    1:   //   Dragging        -> Open
    1:   //   Dragging        -> CollapsedBefore (auto collapse)
    1:   //   Dragging        -> CollapsedAfter (auto collapse)
    1: 
    1:   State newState = GetState(); 
    1: 
    1:   if (newState == mState) {
    1:     // No change.
    1:     return;
    1:   }
    1: 
27841:   if ((SupportsCollapseDirection(Before) || SupportsCollapseDirection(After)) &&
27841:       mOuter->GetParent()->IsBoxFrame()) {
    1:     // Find the splitter's immediate sibling.
27841:     nsIFrame* splitterSibling;
27841:     if (newState == CollapsedBefore || mState == CollapsedBefore) {
27841:       splitterSibling =
27841:         nsFrameList(mOuter->GetParent()).GetPrevSiblingFor(mOuter);
27841:     } else {
27841:       splitterSibling = mOuter->GetNextSibling();
27841:     }
27841: 
27841:     if (splitterSibling && splitterSibling->IsBoxFrame()) {
    1:       nsCOMPtr<nsIContent> sibling = splitterSibling->GetContent();
    1:       if (sibling) {
    1:         if (mState == CollapsedBefore || mState == CollapsedAfter) {
    1:           // CollapsedBefore -> Open
    1:           // CollapsedBefore -> Dragging
    1:           // CollapsedAfter -> Open
    1:           // CollapsedAfter -> Dragging
14319:           nsContentUtils::AddScriptRunner(
14319:             new nsUnsetAttrRunnable(sibling, nsGkAtoms::collapsed));
    1:         } else if ((mState == Open || mState == Dragging)
    1:                    && (newState == CollapsedBefore ||
    1:                        newState == CollapsedAfter)) {
    1:           // Open -> CollapsedBefore / CollapsedAfter
    1:           // Dragging -> CollapsedBefore / CollapsedAfter
14319:           nsContentUtils::AddScriptRunner(
14319:             new nsSetAttrRunnable(sibling, nsGkAtoms::collapsed,
14319:                                   NS_LITERAL_STRING("true")));
    1:         }
    1:       }
    1:     }
    1:   }
    1:   mState = newState;
    1: }
    1: 
    1: void
    1: nsSplitterFrameInner::EnsureOrient()
    1: {
    1:   PRBool isHorizontal = !(mParentBox->GetStateBits() & NS_STATE_IS_HORIZONTAL);
    1:   if (isHorizontal)
    1:     mOuter->mState |= NS_STATE_IS_HORIZONTAL;
    1:   else
    1:     mOuter->mState &= ~NS_STATE_IS_HORIZONTAL;
    1: }
    1: 
    1: void
    1: nsSplitterFrameInner::AdjustChildren(nsPresContext* aPresContext)
    1: {
    1:   EnsureOrient();
    1:   PRBool isHorizontal = !mOuter->IsHorizontal();
    1: 
    1:   AdjustChildren(aPresContext, mChildInfosBefore, mChildInfosBeforeCount, isHorizontal);
    1:   AdjustChildren(aPresContext, mChildInfosAfter, mChildInfosAfterCount, isHorizontal);
    1:    
    1:   
    1:    // printf("----- Posting Dirty -----\n");
    1: 
    1:    
    1:   if (realTimeDrag) {
    1:     aPresContext->PresShell()->FlushPendingNotifications(Flush_Display);
    1:   }
    1:   else {
    1:     aPresContext->PresShell()->
 1158:       FrameNeedsReflow(mOuter, nsIPresShell::eTreeChange, NS_FRAME_IS_DIRTY);
    1:   }
    1: }
    1: 
    1: static nsIBox* GetChildBoxForContent(nsIBox* aParentBox, nsIContent* aContent)
    1: {
    1:   nsIBox* childBox = aParentBox->GetChildBox();
    1: 
    1:   while (nsnull != childBox) {
    1:     if (childBox->GetContent() == aContent) {
    1:       return childBox;
    1:     }
    1:     childBox = childBox->GetNextBox();
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: void
    1: nsSplitterFrameInner::AdjustChildren(nsPresContext* aPresContext, nsSplitterInfo* aChildInfos, PRInt32 aCount, PRBool aIsHorizontal)
    1: {
    1:   ///printf("------- AdjustChildren------\n");
    1: 
    1:   nsBoxLayoutState state(aPresContext);
    1: 
    1:   nscoord onePixel = nsPresContext::CSSPixelsToAppUnits(1);
    1: 
    1:   // first set all the widths.
    1:   nsIBox* child =  mOuter->GetChildBox();
    1:   while(child)
    1:   {
    1:     SetPreferredSize(state, child, onePixel, aIsHorizontal, nsnull);
    1:     child = child->GetNextBox();
    1:   }
    1: 
    1:   // now set our changed widths.
    1:   for (int i=0; i < aCount; i++) 
    1:   {
    1:     nscoord   pref       = aChildInfos[i].changed;
    1:     nsIBox* childBox     = GetChildBoxForContent(mParentBox, aChildInfos[i].childElem);
    1: 
    1:     if (childBox) {
    1:       SetPreferredSize(state, childBox, onePixel, aIsHorizontal, &pref);
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsSplitterFrameInner::SetPreferredSize(nsBoxLayoutState& aState, nsIBox* aChildBox, nscoord aOnePixel, PRBool aIsHorizontal, nscoord* aSize)
    1: {
    1:   //printf("current=%d, pref=%d", current/onePixel, pref/onePixel);
    1:  
    1:   nscoord current = 0;
    1: 
    1:   nsRect rect(aChildBox->GetRect());
    1:   if (aIsHorizontal) 
    1:     current = rect.width;
    1:   else
    1:     current = rect.height;
    1: 
    1:   nscoord pref = 0;
    1: 
    1:   if (!aSize)
    1:   {
    1:     if (aIsHorizontal) 
    1:       pref = rect.width;
    1:     else
    1:       pref = rect.height;
    1:   } else {
    1:     pref = *aSize;
    1:   }
    1: 
    1:   nsMargin margin(0,0,0,0);
    1:   aChildBox->GetMargin(margin);
    1: 
    1:   nsCOMPtr<nsIAtom> attribute;
    1: 
    1:   if (aIsHorizontal) {
    1:     pref -= (margin.left + margin.right);
    1:     attribute = nsGkAtoms::width;
    1:   } else {
    1:     pref -= (margin.top + margin.bottom);
    1:     attribute = nsGkAtoms::height;
    1:   }
    1: 
    1:   nsIContent* content = aChildBox->GetContent();
    1: 
    1:   // set its preferred size.
    1:   nsAutoString prefValue;
    1:   prefValue.AppendInt(pref/aOnePixel);
    1:   if (content->AttrValueIs(kNameSpaceID_None, attribute,
    1:                            prefValue, eCaseMatters))
    1:      return;
    1: 
    1:   nsWeakFrame weakBox(aChildBox);
    1:   content->SetAttr(kNameSpaceID_None, attribute, prefValue, PR_TRUE);
    1:   ENSURE_TRUE(weakBox.IsAlive());
 1158:   aState.PresShell()->FrameNeedsReflow(aChildBox, nsIPresShell::eStyleChange,
 1158:                                        NS_FRAME_IS_DIRTY);
    1: }
    1: 
    1: 
    1: void 
    1: nsSplitterFrameInner::AddRemoveSpace(nscoord aDiff,
    1:                                     nsSplitterInfo* aChildInfos,
    1:                                     PRInt32 aCount,
    1:                                     PRInt32& aSpaceLeft)
    1: {
    1:   aSpaceLeft = 0;
    1: 
    1:   for (int i=0; i < aCount; i++) {   
    1:     nscoord min    = aChildInfos[i].min;
    1:     nscoord max    = aChildInfos[i].max;
    1:     nscoord& c     = aChildInfos[i].changed;
    1: 
    1:     // figure our how much space to add or remove
    1:     if (c + aDiff < min) {
    1:       aDiff += (c - min);
    1:       c = min;
    1:     } else if (c + aDiff > max) {
    1:       aDiff -= (max - c);
    1:       c = max;
    1:     } else {
    1:       c += aDiff;
    1:       aDiff = 0;
    1:     }
    1: 
    1:     // there is not space left? We are done
    1:     if (aDiff == 0)
    1:       break;
    1:   }
    1: 
    1:   aSpaceLeft = aDiff;
    1: }
    1: 
    1: /**
    1:  * Ok if we want to resize a child we will know the actual size in pixels we want it to be.
    1:  * This is not the preferred size. But they only way we can change a child is my manipulating its
    1:  * preferred size. So give the actual pixel size this return method will return figure out the preferred
    1:  * size and set it.
    1:  */
    1: 
    1: void
    1: nsSplitterFrameInner::ResizeChildTo(nsPresContext* aPresContext,
    1:                                    nscoord& aDiff, 
    1:                                    nsSplitterInfo* aChildrenBeforeInfos, 
    1:                                    nsSplitterInfo* aChildrenAfterInfos, 
    1:                                    PRInt32 aChildrenBeforeCount, 
    1:                                    PRInt32 aChildrenAfterCount, 
    1:                                    PRBool aBounded)
    1: { 
    1:   nscoord spaceLeft;
    1:   AddRemoveSpace(aDiff, aChildrenBeforeInfos,aChildrenBeforeCount,spaceLeft);
    1: 
    1:   // if there is any space left over remove it from the dif we were originally given
    1:   aDiff -= spaceLeft;
    1:   AddRemoveSpace(-aDiff, aChildrenAfterInfos,aChildrenAfterCount,spaceLeft);
    1: 
    1:   if (spaceLeft != 0) {
    1:     if (aBounded) {
    1:        aDiff += spaceLeft;
    1:        AddRemoveSpace(spaceLeft, aChildrenBeforeInfos,aChildrenBeforeCount,spaceLeft);
    1:     } else {
    1:       spaceLeft = 0;
    1:     }
    1:   }
    1: }
    1: 
    1: 
    1: void
    1: nsSplitterFrameInner::MoveSplitterBy(nsPresContext* aPresContext, nscoord aDiff)
    1: {
    1:   const nsRect& r = mOuter->mRect;
    1:   nsIView *v = mOuter->GetView();
    1:   nsIViewManager* vm = v->GetViewManager();
    1:   nsRect vr = v->GetBounds();
    1:   nsRect invalid;
    1:   EnsureOrient();
    1:   PRBool isHorizontal = !mOuter->IsHorizontal();
    1:   if (isHorizontal) {
    1:     mOuter->SetPosition(nsPoint(mSplitterPos + aDiff, r.y));
    1:     vm->MoveViewTo(v, mSplitterViewPos + aDiff, vr.y);
    1:     invalid.UnionRect(r,mOuter->mRect);
    1:   } else {
    1:     mOuter->SetPosition(nsPoint(r.x, mSplitterPos + aDiff));
    1:     vm->MoveViewTo(v, vr.x, mSplitterViewPos + aDiff);
    1:     invalid.UnionRect(r,mOuter->mRect);
    1:   }
    1: 
    1:   // redraw immediately only what changed. This is animation so 
    1:   // it must be immediate.
    1:   nsBoxLayoutState state(aPresContext);
    1:   mParentBox->Redraw(state, &invalid, PR_TRUE);
    1: }
