40383: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
40383:  *
40383:  * ***** BEGIN LICENSE BLOCK *****
40383:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
40383:  *
40383:  * The contents of this file are subject to the Mozilla Public License Version
40383:  * 1.1 (the "License"); you may not use this file except in compliance with
40383:  * the License. You may obtain a copy of the License at
40383:  * http://www.mozilla.org/MPL/
40383:  *
40383:  * Software distributed under the License is distributed on an "AS IS" basis,
40383:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
40383:  * for the specific language governing rights and limitations under the
40383:  * License.
40383:  *
40383:  * The Original Code is SpiderMonkey code.
40383:  *
40383:  * The Initial Developer of the Original Code is
40383:  * Mozilla Corporation.
40383:  * Portions created by the Initial Developer are Copyright (C) 2010
40383:  * the Initial Developer. All Rights Reserved.
40383:  *
40383:  * Contributor(s):
40383:  *   Jeff Walden <jwalden+code@mit.edu> (original author)
40383:  *
40383:  * Alternatively, the contents of this file may be used under the terms of
40383:  * either of the GNU General Public License Version 2 or later (the "GPL"),
40383:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
40383:  * in which case the provisions of the GPL or the LGPL are applicable instead
40383:  * of those above. If you wish to allow use of your version of this file only
40383:  * under the terms of either the GPL or the LGPL, and not to allow others to
40383:  * use your version of this file under the terms of the MPL, indicate your
40383:  * decision by deleting the provisions above and replace them with the notice
40383:  * and other provisions required by the GPL or the LGPL. If you do not delete
40383:  * the provisions above, a recipient may use your version of this file under
40383:  * the terms of any one of the MPL, the GPL or the LGPL.
40383:  *
40383:  * ***** END LICENSE BLOCK ***** */
40383: 
40383: #ifndef jscntxtinlines_h___
40383: #define jscntxtinlines_h___
40383: 
40383: #include "jscntxt.h"
42714: #include "jsparse.h"
40383: #include "jsxml.h"
40383: 
40383: #include "jsobjinlines.h"
40383: 
42717: inline bool
42717: JSContext::ensureGeneratorStackSpace()
42717: {
42717:     bool ok = genStack.reserve(genStack.length() + 1);
42717:     if (!ok)
42717:         js_ReportOutOfMemory(this);
42717:     return ok;
42717: }
42717: 
40383: namespace js {
40383: 
42714: JS_REQUIRES_STACK JS_ALWAYS_INLINE JSStackFrame *
42714: CallStack::getCurrentFrame() const
42714: {
42714:     JS_ASSERT(inContext());
42714:     return isSuspended() ? getSuspendedFrame() : cx->fp;
42714: }
42714: 
42714: JS_REQUIRES_STACK inline jsval *
42714: StackSpace::firstUnused() const
42714: {
42714:     CallStack *ccs = currentCallStack;
42714:     if (!ccs)
42714:         return base;
42717:     if (JSContext *cx = ccs->maybeContext()) {
42717:         if (!ccs->isSuspended())
42717:             return cx->regs->sp;
42717:         return ccs->getSuspendedRegs()->sp;
42717:     }
42714:     return ccs->getInitialArgEnd();
42714: }
42714: 
42714: /* Inline so we don't need the friend API. */
42714: JS_ALWAYS_INLINE void
42714: StackSpace::assertIsCurrent(JSContext *cx) const
42714: {
42714: #ifdef DEBUG
42714:     JS_ASSERT(cx == currentCallStack->maybeContext());
42714:     JS_ASSERT(cx->getCurrentCallStack() == currentCallStack);
42714:     cx->assertCallStacksInSync();
42714: #endif
42714: }
42714: 
42714: JS_ALWAYS_INLINE bool
42714: StackSpace::ensureSpace(JSContext *maybecx, jsval *from, ptrdiff_t nvals) const
42714: {
42714:     JS_ASSERT(from == firstUnused());
42714: #ifdef XP_WIN
42714:     JS_ASSERT(from <= commitEnd);
42714:     if (commitEnd - from >= nvals)
42714:         return true;
42714:     if (end - from < nvals) {
42714:         if (maybecx)
42714:             js_ReportOutOfScriptQuota(maybecx);
42714:         return false;
42714:     }
42714:     if (!bumpCommit(from, nvals)) {
42714:         if (maybecx)
42714:             js_ReportOutOfScriptQuota(maybecx);
42714:         return false;
42714:     }
42714:     return true;
42714: #else
42714:     if (end - from < nvals) {
42714:         if (maybecx)
42714:             js_ReportOutOfScriptQuota(maybecx);
42714:         return false;
42714:     }
42714:     return true;
42714: #endif
42714: }
42714: 
42714: JS_ALWAYS_INLINE bool
42714: StackSpace::ensureEnoughSpaceToEnterTrace()
42714: {
42714: #ifdef XP_WIN
42714:     return ensureSpace(NULL, firstUnused(), MAX_TRACE_SPACE_VALS);
42714: #endif
42714:     return end - firstUnused() > MAX_TRACE_SPACE_VALS;
42714: }
42714: 
42714: JS_REQUIRES_STACK JS_ALWAYS_INLINE JSStackFrame *
42714: StackSpace::getInlineFrame(JSContext *cx, jsval *sp,
42714:                            uintN nmissing, uintN nfixed) const
42714: {
42714:     assertIsCurrent(cx);
42714:     JS_ASSERT(cx->hasActiveCallStack());
42717:     JS_ASSERT(cx->regs->sp == sp);
42714: 
42714:     ptrdiff_t nvals = nmissing + VALUES_PER_STACK_FRAME + nfixed;
42714:     if (!ensureSpace(cx, sp, nvals))
42714:         return NULL;
42714: 
42714:     JSStackFrame *fp = reinterpret_cast<JSStackFrame *>(sp + nmissing);
42714:     return fp;
42714: }
42714: 
42714: JS_REQUIRES_STACK JS_ALWAYS_INLINE void
42717: StackSpace::pushInlineFrame(JSContext *cx, JSStackFrame *fp, jsbytecode *pc,
42717:                             JSStackFrame *newfp)
42714: {
42714:     assertIsCurrent(cx);
42714:     JS_ASSERT(cx->hasActiveCallStack());
42717:     JS_ASSERT(cx->fp == fp && cx->regs->pc == pc);
42714: 
42717:     fp->savedPC = pc;
42714:     newfp->down = fp;
42717: #ifdef DEBUG
42717:     newfp->savedPC = JSStackFrame::sInvalidPC;
42717: #endif
42714:     cx->setCurrentFrame(newfp);
42714: }
42714: 
42714: JS_REQUIRES_STACK JS_ALWAYS_INLINE void
42714: StackSpace::popInlineFrame(JSContext *cx, JSStackFrame *up, JSStackFrame *down)
42714: {
42714:     assertIsCurrent(cx);
42714:     JS_ASSERT(cx->hasActiveCallStack());
42714:     JS_ASSERT(cx->fp == up && up->down == down);
42717:     JS_ASSERT(up->savedPC == JSStackFrame::sInvalidPC);
42714: 
42717:     JSFrameRegs *regs = cx->regs;
42717:     regs->pc = down->savedPC;
42717:     regs->sp = up->argv - 1;
42717: #ifdef DEBUG
42717:     down->savedPC = JSStackFrame::sInvalidPC;
42717: #endif
42714:     cx->setCurrentFrame(down);
42714: }
42714: 
40383: void
40383: AutoIdArray::trace(JSTracer *trc) {
40383:     JS_ASSERT(tag == IDARRAY);
40383:     js::TraceValues(trc, idArray->length, idArray->vector, "JSAutoIdArray.idArray");
40383: }
40383: 
40383: class AutoNamespaces : protected AutoGCRooter {
40383:   protected:
40383:     AutoNamespaces(JSContext *cx) : AutoGCRooter(cx, NAMESPACES) {
40383:     }
40383: 
40383:     friend void AutoGCRooter::trace(JSTracer *trc);
40383: 
40383:   public:
40383:     JSXMLArray array;
40383: };
40383: 
40383: inline void
40383: AutoGCRooter::trace(JSTracer *trc)
40383: {
40383:     switch (tag) {
40383:       case JSVAL:
40383:         JS_SET_TRACING_NAME(trc, "js::AutoValueRooter.val");
40383:         js_CallValueTracerIfGCThing(trc, static_cast<AutoValueRooter *>(this)->val);
40383:         return;
40383: 
40383:       case SPROP:
40383:         static_cast<AutoScopePropertyRooter *>(this)->sprop->trace(trc);
40383:         return;
40383: 
40383:       case WEAKROOTS:
41820:         static_cast<AutoPreserveWeakRoots *>(this)->savedRoots.mark(trc);
40383:         return;
40383: 
40860:       case PARSER:
40860:         static_cast<Parser *>(this)->trace(trc);
40383:         return;
40383: 
40383:       case SCRIPT:
40383:         if (JSScript *script = static_cast<AutoScriptRooter *>(this)->script)
40383:             js_TraceScript(trc, script);
40383:         return;
40383: 
40383:       case ENUMERATOR:
40383:         static_cast<AutoEnumStateRooter *>(this)->trace(trc);
40383:         return;
40383: 
40383:       case IDARRAY: {
40383:         JSIdArray *ida = static_cast<AutoIdArray *>(this)->idArray;
40383:         TraceValues(trc, ida->length, ida->vector, "js::AutoIdArray.idArray");
40383:         return;
40383:       }
40383: 
40383:       case DESCRIPTORS: {
40383:         PropertyDescriptorArray &descriptors =
40383:             static_cast<AutoDescriptorArray *>(this)->descriptors;
40383:         for (size_t i = 0, len = descriptors.length(); i < len; i++) {
40383:             PropertyDescriptor &desc = descriptors[i];
40383: 
42733:             JS_CALL_VALUE_TRACER(trc, desc.pd, "PropertyDescriptor::pd");
40383:             JS_CALL_VALUE_TRACER(trc, desc.value, "PropertyDescriptor::value");
40383:             JS_CALL_VALUE_TRACER(trc, desc.get, "PropertyDescriptor::get");
40383:             JS_CALL_VALUE_TRACER(trc, desc.set, "PropertyDescriptor::set");
40383:             js_TraceId(trc, desc.id);
40383:         }
40383:         return;
40383:       }
40383: 
42733:       case DESCRIPTOR : {
42733:         AutoDescriptor &desc = *static_cast<AutoDescriptor *>(this);
42767:         if (desc.obj)
42733:             JS_CALL_OBJECT_TRACER(trc, desc.obj, "Descriptor::obj");
42733:         JS_CALL_VALUE_TRACER(trc, desc.value, "Descriptor::value");
42733:         if (desc.attrs & JSPROP_GETTER)
42733:             JS_CALL_VALUE_TRACER(trc, jsval(desc.getter), "Descriptor::get");
42733:         if (desc.attrs & JSPROP_SETTER)
42733:             JS_CALL_VALUE_TRACER(trc, jsval(desc.setter), "Descriptor::set");
42733:         return;
42733:       }
42733: 
40383:       case NAMESPACES: {
40383:         JSXMLArray &array = static_cast<AutoNamespaces *>(this)->array;
40383:         TraceObjectVector(trc, reinterpret_cast<JSObject **>(array.vector), array.length);
40383:         array.cursors->trace(trc);
40383:         return;
40383:       }
40383: 
40383:       case XML:
40383:         js_TraceXML(trc, static_cast<AutoXMLRooter *>(this)->xml);
40383:         return;
40383: 
40383:       case OBJECT:
40383:         if (JSObject *obj = static_cast<AutoObjectRooter *>(this)->obj) {
40383:             JS_SET_TRACING_NAME(trc, "js::AutoObjectRooter.obj");
40383:             js_CallGCMarker(trc, obj, JSTRACE_OBJECT);
40383:         }
40383:         return;
40383: 
40383:       case ID:
40383:         JS_SET_TRACING_NAME(trc, "js::AutoIdRooter.val");
40383:         js_CallValueTracerIfGCThing(trc, static_cast<AutoIdRooter *>(this)->idval);
40383:         return;
40418: 
40418:       case VECTOR: {
40418:         js::Vector<jsval, 8> &vector = static_cast<js::AutoValueVector *>(this)->vector;
40418:         js::TraceValues(trc, vector.length(), vector.begin(), "js::AutoValueVector.vector");
40418:         return;
40418:       }
40383:     }
40383: 
40383:     JS_ASSERT(tag >= 0);
40383:     TraceValues(trc, tag, static_cast<AutoArrayRooter *>(this)->array, "js::AutoArrayRooter.array");
40383: }
40383: 
40383: }
40383: 
40383: #endif /* jscntxtinlines_h___ */
