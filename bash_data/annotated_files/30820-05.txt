    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2003
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Original Author: Aaron Leventhal (aaronl@netscape.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsRootAccessible.h"
    1: #include "nsAccessibilityAtoms.h"
    1: #include "nsAccessibleEventData.h"
30820: #include "nsAccessibilityService.h"
    1: #include "nsIMutableArray.h"
    1: #include "nsICommandManager.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMAttr.h"
    1: #include "nsIDOMCharacterData.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMDocumentType.h"
    1: #include "nsIDOMNSDocument.h"
    1: #include "nsIDOMNSHTMLDocument.h"
    1: #include "nsIDOMMutationEvent.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIDOMXULPopupElement.h"
    1: #include "nsIEditingSession.h"
    1: #include "nsIEventStateManager.h"
    1: #include "nsIFrame.h"
    1: #include "nsHTMLSelectAccessible.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIScrollableView.h"
    1: #include "nsIViewManager.h"
    1: #include "nsIView.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsIURI.h"
    1: #include "nsIWebNavigation.h"
29018: #include "nsFocusManager.h"
    1: #ifdef MOZ_XUL
    1: #include "nsIXULDocument.h"
    1: #endif
    1: 
    1: //=============================//
    1: // nsDocAccessible  //
    1: //=============================//
    1: 
 6065: PRUint32 nsDocAccessible::gLastFocusedAccessiblesState = 0;
11439: nsIAtom *nsDocAccessible::gLastFocusedFrameType = nsnull;
 6065: 
    1: //-----------------------------------------------------
    1: // construction
    1: //-----------------------------------------------------
    1: nsDocAccessible::nsDocAccessible(nsIDOMNode *aDOMNode, nsIWeakReference* aShell):
  966:   nsHyperTextAccessibleWrap(aDOMNode, aShell), mWnd(nsnull),
15262:   mScrollPositionChangedTicks(0), mIsContentLoaded(PR_FALSE),
15262:   mIsLoadCompleteFired(PR_FALSE), mInFlushPendingEvents(PR_FALSE)
    1: {
    1:   // For GTK+ native window, we do nothing here.
    1:   if (!mDOMNode)
    1:     return;
    1: 
    1:   // Because of the way document loading happens, the new nsIWidget is created before
    1:   // the old one is removed. Since it creates the nsDocAccessible, for a brief moment
    1:   // there can be 2 nsDocAccessible's for the content area, although for 2 different
    1:   // pres shells.
    1: 
    1:   nsCOMPtr<nsIPresShell> shell(do_QueryReferent(mWeakShell));
    1:   if (shell) {
 6279:     // Find mDocument
    1:     mDocument = shell->GetDocument();
 6279:     
 6279:     // Find mWnd
    1:     nsIViewManager* vm = shell->GetViewManager();
    1:     if (vm) {
    1:       nsCOMPtr<nsIWidget> widget;
30527:       vm->GetRootWidget(getter_AddRefs(widget));
    1:       if (widget) {
    1:         mWnd = widget->GetNativeData(NS_NATIVE_WINDOW);
    1:       }
    1:     }
    1:   }
    1: 
    1:   // XXX aaronl should we use an algorithm for the initial cache size?
    1:   mAccessNodeCache.Init(kDefaultCacheSize);
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem =
20521:     nsCoreUtils::GetDocShellTreeItemFor(mDOMNode);
    1:   nsCOMPtr<nsIDocShell> docShell = do_QueryInterface(docShellTreeItem);
    1:   if (docShell) {
    1:     PRUint32 busyFlags;
    1:     docShell->GetBusyFlags(&busyFlags);
    1:     if (busyFlags == nsIDocShell::BUSY_FLAGS_NONE) {
    1:       mIsContentLoaded = PR_TRUE;                                               
    1:     }
    1:   }
    1: }
    1: 
    1: //-----------------------------------------------------
    1: // destruction
    1: //-----------------------------------------------------
    1: nsDocAccessible::~nsDocAccessible()
    1: {
    1: }
    1: 
16428: ////////////////////////////////////////////////////////////////////////////////
16428: // nsDocAccessible. nsISupports
16428: 
20261: static PLDHashOperator
16428: ElementTraverser(const void *aKey, nsIAccessNode *aAccessNode,
16428:                  void *aUserArg)
16428: {
16428:   nsCycleCollectionTraversalCallback *cb = 
16428:     static_cast<nsCycleCollectionTraversalCallback*>(aUserArg);
16428: 
18825:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mAccessNodeCache entry");
16428:   cb->NoteXPCOMChild(aAccessNode);
16428:   return PL_DHASH_NEXT;
16428: }
16428: 
29564: // What we want is: NS_INTERFACE_MAP_ENTRY(self) for static IID accessors,
29564: // but some of our classes have an ambiguous base class of nsISupports which
29564: // prevents this from working (the default macro converts it to nsISupports,
29564: // then addrefs it, then returns it). Therefore, we expand the macro here and
29564: // change it so that it works. Yuck.
29564: #define NS_INTERFACE_MAP_STATIC_AMBIGUOUS(_class) \
29564:   if (aIID.Equals(NS_GET_IID(_class))) { \
29564:     NS_ADDREF(this); \
29564:     *aInstancePtr = this; \
29564:     return NS_OK; \
29564:   } else
29564: 
16428: NS_IMPL_CYCLE_COLLECTION_CLASS(nsDocAccessible)
16428: 
16428: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsDocAccessible, nsAccessible)
16428:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mEventsToFire)
16428:   tmp->mAccessNodeCache.EnumerateRead(ElementTraverser, &cb); 
16428: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
16428: 
16428: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsDocAccessible, nsAccessible)
16428:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mEventsToFire)
16428:   tmp->ClearCache(tmp->mAccessNodeCache);
16428: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
16428: 
16428: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsDocAccessible)
29564:   NS_INTERFACE_MAP_STATIC_AMBIGUOUS(nsDocAccessible)
    1:   NS_INTERFACE_MAP_ENTRY(nsIAccessibleDocument)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDocumentObserver)
    1:   NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)
    1:   NS_INTERFACE_MAP_ENTRY(nsIScrollPositionListener)
    1:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
29564:   NS_INTERFACE_MAP_ENTRY(nsIObserver)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIAccessibleDocument)
    1: NS_INTERFACE_MAP_END_INHERITING(nsHyperTextAccessible)
    1: 
    1: NS_IMPL_ADDREF_INHERITED(nsDocAccessible, nsHyperTextAccessible)
    1: NS_IMPL_RELEASE_INHERITED(nsDocAccessible, nsHyperTextAccessible)
    1: 
20246: NS_IMETHODIMP
20246: nsDocAccessible::GetName(nsAString& aName)
    1: {
    1:   nsresult rv = NS_OK;
    1:   aName.Truncate();
13094:   if (mParent) {
13094:     rv = mParent->GetName(aName); // Allow owning iframe to override the name
    1:   }
    1:   if (aName.IsEmpty()) {
20246:     // Allow name via aria-labelledby or title attribute
20246:     rv = nsAccessible::GetName(aName);
    1:   }
13094:   if (aName.IsEmpty()) {
14340:     rv = GetTitle(aName);   // Try title element
14340:   }
14340:   if (aName.IsEmpty()) {   // Last resort: use URL
14340:     rv = GetURL(aName);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
25822: nsresult
25822: nsDocAccessible::GetRoleInternal(PRUint32 *aRole)
    1: {
    1:   *aRole = nsIAccessibleRole::ROLE_PANE; // Fall back
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem =
20521:     nsCoreUtils::GetDocShellTreeItemFor(mDOMNode);
    1:   if (docShellTreeItem) {
    1:     nsCOMPtr<nsIDocShellTreeItem> sameTypeRoot;
    1:     docShellTreeItem->GetSameTypeRootTreeItem(getter_AddRefs(sameTypeRoot));
 2395:     PRInt32 itemType;
 2395:     docShellTreeItem->GetItemType(&itemType);
    1:     if (sameTypeRoot == docShellTreeItem) {
    1:       // Root of content or chrome tree
    1:       if (itemType == nsIDocShellTreeItem::typeChrome) {
    1:         *aRole = nsIAccessibleRole::ROLE_CHROME_WINDOW;
    1:       }
    1:       else if (itemType == nsIDocShellTreeItem::typeContent) {
    1: #ifdef MOZ_XUL
    1:         nsCOMPtr<nsIXULDocument> xulDoc(do_QueryInterface(mDocument));
  777:         if (xulDoc) {
  777:           *aRole = nsIAccessibleRole::ROLE_APPLICATION;
  777:         } else {
  777:           *aRole = nsIAccessibleRole::ROLE_DOCUMENT;
  777:         }
    1: #else
    1:         *aRole = nsIAccessibleRole::ROLE_DOCUMENT;
    1: #endif
    1:       }
    1:     }
 2395:     else if (itemType == nsIDocShellTreeItem::typeContent) {
 2395:       *aRole = nsIAccessibleRole::ROLE_DOCUMENT;
 2395:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
29320: void
29320: nsDocAccessible::SetRoleMapEntry(nsRoleMapEntry* aRoleMapEntry)
    1: {
29320:   NS_ASSERTION(mDocument, "No document during initialization!");
29320:   if (!mDocument)
29320:     return;
13094: 
13094:   mRoleMapEntry = aRoleMapEntry;
13094: 
29823:   nsIDocument *parentDoc = mDocument->GetParentDocument();
29823:   if (!parentDoc)
29823:     return; // No parent document for the root document
29823: 
13094:   // Allow use of ARIA role from outer to override
13094:   nsIContent *ownerContent = parentDoc->FindContentForSubDocument(mDocument);
13094:   nsCOMPtr<nsIDOMNode> ownerNode(do_QueryInterface(ownerContent));
13094:   if (ownerNode) {
20536:     nsRoleMapEntry *roleMapEntry = nsAccUtils::GetRoleMapEntry(ownerNode);
13094:     if (roleMapEntry)
13094:       mRoleMapEntry = roleMapEntry; // Override
13094:   }
    1: }
    1: 
  262: NS_IMETHODIMP 
 3018: nsDocAccessible::GetDescription(nsAString& aDescription)
 3018: {
13094:   if (mParent)
13094:     mParent->GetDescription(aDescription);
13094: 
13094:   if (aDescription.IsEmpty()) {
 6861:     nsAutoString description;
25175:     nsTextEquivUtils::
25175:       GetTextEquivFromIDRefs(this, nsAccessibilityAtoms::aria_describedby,
25175:                              description);
 6861:     aDescription = description;
13094:   }
13094: 
 3018:   return NS_OK;
 3018: }
 3018: 
21256: nsresult
21256: nsDocAccessible::GetStateInternal(PRUint32 *aState, PRUint32 *aExtraState)
    1: {
21984:   nsresult rv = nsAccessible::GetStateInternal(aState, aExtraState);
21984:   NS_ENSURE_A11Y_SUCCESS(rv, rv);
  262: 
 3826: #ifdef MOZ_XUL
  416:   nsCOMPtr<nsIXULDocument> xulDoc(do_QueryInterface(mDocument));
 3826:   if (!xulDoc)
 3826: #endif
 3826:   {
  416:     // XXX Need to invent better check to see if doc is focusable,
  416:     // which it should be if it is scrollable. A XUL document could be focusable.
  416:     // See bug 376803.
    1:     *aState |= nsIAccessibleStates::STATE_FOCUSABLE;
14924:     if (gLastFocusedNode == mDOMNode) {
14924:       *aState |= nsIAccessibleStates::STATE_FOCUSED;
14924:     }
  416:   }
    1: 
    1:   if (!mIsContentLoaded) {
    1:     *aState |= nsIAccessibleStates::STATE_BUSY;
 1087:     if (aExtraState) {
 1087:       *aExtraState |= nsIAccessibleStates::EXT_STATE_STALE;
 1087:     }
    1:   }
    1:  
    1:   nsIFrame* frame = GetFrame();
    1:   while (frame != nsnull && !frame->HasView()) {
    1:     frame = frame->GetParent();
    1:   }
    1:  
11399:   if (frame == nsnull ||
11399:       !CheckVisibilityInParentChain(mDocument, frame->GetViewExternal())) {
11399:     *aState |= nsIAccessibleStates::STATE_INVISIBLE |
11399:                nsIAccessibleStates::STATE_OFFSCREEN;
    1:   }
    1: 
 4625:   nsCOMPtr<nsIEditor> editor;
 4625:   GetAssociatedEditor(getter_AddRefs(editor));
    1:   if (!editor) {
    1:     *aState |= nsIAccessibleStates::STATE_READONLY;
    1:   }
  512:   else if (aExtraState) {
  512:     *aExtraState |= nsIAccessibleStates::EXT_STATE_EDITABLE;
  512:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
29320: nsresult
29565: nsDocAccessible::GetARIAState(PRUint32 *aState, PRUint32 *aExtraState)
13094: {
13094:   // Combine with states from outer doc
13094:   NS_ENSURE_ARG_POINTER(aState);
29565:   nsresult rv = nsAccessible::GetARIAState(aState, aExtraState);
13094:   NS_ENSURE_SUCCESS(rv, rv);
13094: 
29320:   nsRefPtr<nsAccessible> parent = nsAccUtils::QueryAccessible(mParent);
29320:   if (parent)  // Allow iframe/frame etc. to have final state override via ARIA
29565:     return parent->GetARIAState(aState, aExtraState);
13094: 
13094:   return rv;
13094: }
13094: 
13094: NS_IMETHODIMP
13094: nsDocAccessible::GetAttributes(nsIPersistentProperties **aAttributes)
13094: {
13094:   nsAccessible::GetAttributes(aAttributes);
13094:   if (mParent) {
13094:     mParent->GetAttributes(aAttributes); // Add parent attributes (override inner)
13094:   }
13094:   return NS_OK;
13094: }
13094: 
    1: NS_IMETHODIMP nsDocAccessible::GetFocusedChild(nsIAccessible **aFocusedChild)
    1: {
29018:   // XXXndeakin P3 accessibility shouldn't be caching the focus
    1:   if (!gLastFocusedNode) {
    1:     *aFocusedChild = nsnull;
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Return an accessible for the current global focus, which does not have to
    1:   // be contained within the current document.
    1:   nsCOMPtr<nsIAccessibilityService> accService =
    1:     do_GetService("@mozilla.org/accessibilityService;1");
    1:   return accService->GetAccessibleFor(gLastFocusedNode, aFocusedChild);
    1: }
    1: 
    1: NS_IMETHODIMP nsDocAccessible::TakeFocus()
    1: {
  883:   NS_ENSURE_TRUE(mDocument, NS_ERROR_FAILURE);
  883:   PRUint32 state;
21256:   GetStateInternal(&state, nsnull);
  883:   if (0 == (state & nsIAccessibleStates::STATE_FOCUSABLE)) {
  883:     return NS_ERROR_FAILURE; // Not focusable
  645:   }
  883: 
29018:   nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
29018:   if (fm) {
29018:     nsCOMPtr<nsIDOMDocument> domDocument;
29018:     mDOMNode->GetOwnerDocument(getter_AddRefs(domDocument));
29018:     nsCOMPtr<nsIDocument> document(do_QueryInterface(domDocument));
29018:     if (document) {
29018:       // focus the document
29018:       nsCOMPtr<nsIDOMElement> newFocus;
29167:       return fm->MoveFocus(document->GetWindow(), nsnull,
29167:                            nsIFocusManager::MOVEFOCUS_ROOT, 0,
29018:                            getter_AddRefs(newFocus));
 5696:     }
29018:   }
29167:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: // ------- nsIAccessibleDocument Methods (5) ---------------
    1: 
    1: NS_IMETHODIMP nsDocAccessible::GetURL(nsAString& aURL)
    1: {
    1:   if (!mDocument) {
    1:     return NS_ERROR_FAILURE; // Document has been shut down
    1:   }
    1:   nsCOMPtr<nsISupports> container = mDocument->GetContainer();
    1:   nsCOMPtr<nsIWebNavigation> webNav(do_GetInterface(container));
    1:   nsCAutoString theURL;
    1:   if (webNav) {
    1:     nsCOMPtr<nsIURI> pURI;
    1:     webNav->GetCurrentURI(getter_AddRefs(pURI));
    1:     if (pURI)
    1:       pURI->GetSpec(theURL);
    1:   }
    1:   CopyUTF8toUTF16(theURL, aURL);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocAccessible::GetTitle(nsAString& aTitle)
    1: {
16977:   nsCOMPtr<nsIDOMNSDocument> domnsDocument(do_QueryInterface(mDocument));
16977:   if (domnsDocument) {
16977:     return domnsDocument->GetTitle(aTitle);
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocAccessible::GetMimeType(nsAString& aMimeType)
    1: {
    1:   nsCOMPtr<nsIDOMNSDocument> domnsDocument(do_QueryInterface(mDocument));
    1:   if (domnsDocument) {
    1:     return domnsDocument->GetContentType(aMimeType);
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocAccessible::GetDocType(nsAString& aDocType)
    1: {
    1:   nsCOMPtr<nsIDOMDocument> domDoc(do_QueryInterface(mDocument));
    1:   nsCOMPtr<nsIDOMDocumentType> docType;
    1: 
    1: #ifdef MOZ_XUL
    1:   nsCOMPtr<nsIXULDocument> xulDoc(do_QueryInterface(mDocument));
    1:   if (xulDoc) {
    1:     aDocType.AssignLiteral("window"); // doctype not implemented for XUL at time of writing - causes assertion
    1:     return NS_OK;
    1:   } else
    1: #endif
    1:   if (domDoc && NS_SUCCEEDED(domDoc->GetDoctype(getter_AddRefs(docType))) && docType) {
    1:     return docType->GetPublicId(aDocType);
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocAccessible::GetNameSpaceURIForID(PRInt16 aNameSpaceID, nsAString& aNameSpaceURI)
    1: {
    1:   if (mDocument) {
    1:     nsCOMPtr<nsINameSpaceManager> nameSpaceManager =
    1:         do_GetService(NS_NAMESPACEMANAGER_CONTRACTID);
    1:     if (nameSpaceManager)
    1:       return nameSpaceManager->GetNameSpaceURI(aNameSpaceID, aNameSpaceURI);
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocAccessible::GetWindowHandle(void **aWindow)
    1: {
    1:   *aWindow = mWnd;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocAccessible::GetWindow(nsIDOMWindow **aDOMWin)
    1: {
    1:   *aDOMWin = nsnull;
    1:   if (!mDocument) {
    1:     return NS_ERROR_FAILURE;  // Accessible is Shutdown()
    1:   }
    1:   *aDOMWin = mDocument->GetWindow();
    1: 
    1:   if (!*aDOMWin)
    1:     return NS_ERROR_FAILURE;  // No DOM Window
    1: 
    1:   NS_ADDREF(*aDOMWin);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocAccessible::GetDocument(nsIDOMDocument **aDOMDoc)
    1: {
    1:   nsCOMPtr<nsIDOMDocument> domDoc(do_QueryInterface(mDocument));
    1:   *aDOMDoc = domDoc;
    1: 
    1:   if (domDoc) {
    1:     NS_ADDREF(*aDOMDoc);
    1:     return NS_OK;
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
 4625: NS_IMETHODIMP nsDocAccessible::GetAssociatedEditor(nsIEditor **aEditor)
    1: {
 4625:   NS_ENSURE_ARG_POINTER(aEditor);
20138:   *aEditor = nsnull;
19825: 
20138:   if (!mDocument)
20138:     return NS_ERROR_FAILURE;
    1: 
20138:   // Check if document is editable (designMode="on" case). Otherwise check if
20138:   // the html:body (for HTML document case) or document element is editable.
19825:   if (!mDocument->HasFlag(NODE_IS_EDITABLE)) {
20138:     nsCOMPtr<nsIDOMNode> DOMDocument(do_QueryInterface(mDocument));
20138:     nsCOMPtr<nsIDOMElement> DOMElement =
20521:       nsCoreUtils::GetDOMElementFor(DOMDocument);
20138:     nsCOMPtr<nsIContent> content(do_QueryInterface(DOMElement));
20138: 
21053:     if (!content || !content->HasFlag(NODE_IS_EDITABLE))
20138:       return NS_OK;
19825:   }
    1: 
    1:   nsCOMPtr<nsISupports> container = mDocument->GetContainer();
    1:   nsCOMPtr<nsIEditingSession> editingSession(do_GetInterface(container));
    1:   if (!editingSession)
 4625:     return NS_OK; // No editing session interface
    1: 
    1:   nsCOMPtr<nsIEditor> editor;
 4625:   editingSession->GetEditorForWindow(mDocument->GetWindow(), getter_AddRefs(editor));
 4625:   if (!editor) {
 4625:     return NS_OK;
 4625:   }
 4625:   PRBool isEditable;
 4625:   editor->GetIsDocumentEditable(&isEditable);
 4625:   if (isEditable) {
 4625:     NS_ADDREF(*aEditor = editor);
 4625:   }
 4625:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocAccessible::GetCachedAccessNode(void *aUniqueID, nsIAccessNode **aAccessNode)
    1: {
    1:   GetCacheEntry(mAccessNodeCache, aUniqueID, aAccessNode); // Addrefs for us
    1: #ifdef DEBUG_A11Y
    1:   // All cached accessible nodes should be in the parent
    1:   // It will assert if not all the children were created
    1:   // when they were first cached, and no invalidation
    1:   // ever corrected parent accessible's child cache.
    1:   nsCOMPtr<nsIAccessible> accessible = do_QueryInterface(*aAccessNode);
29320:   nsRefPtr<nsAccessible> acc = nsAccUtils::QueryAccessible(accessible);
29320:   if (acc) {
29320:     nsCOMPtr<nsIAccessible> parent = acc->GetCachedParent();
29320:     nsRefPtr<nsAccessible> parentAcc(nsAccUtils::QueryAccessible(parent));
29320:     if (parentAcc)
29320:       parentAcc->TestChildCache(accessible);
    1:   }
    1: #endif
    1:   return NS_OK;
    1: }
    1: 
29564: void
15313: nsDocAccessible::CacheAccessNode(void *aUniqueID, nsIAccessNode *aAccessNode)
    1: {
15313:   // If there is an access node for the given unique ID then let's shutdown it.
15313:   // The unique ID may be presented in the cache if originally we created
15313:   // access node object and then we want to create accessible object when
15313:   // DOM node is changed.
15313:   nsCOMPtr<nsIAccessNode> accessNode;
15313:   GetCacheEntry(mAccessNodeCache, aUniqueID, getter_AddRefs(accessNode));
15313:   if (accessNode) {
21169:     nsRefPtr<nsAccessNode> accNode = nsAccUtils::QueryAccessNode(accessNode);
21169:     accNode->Shutdown();
15313:   }
15313: 
    1:   PutCacheEntry(mAccessNodeCache, aUniqueID, aAccessNode);
    1: }
    1: 
    1: NS_IMETHODIMP nsDocAccessible::GetParent(nsIAccessible **aParent)
    1: {
    1:   // Hook up our new accessible with our parent
  448:   *aParent = nsnull;
  448:   NS_ENSURE_TRUE(mDocument, NS_ERROR_FAILURE);
    1:   if (!mParent) {
    1:     nsIDocument *parentDoc = mDocument->GetParentDocument();
  448:     NS_ENSURE_TRUE(parentDoc, NS_ERROR_FAILURE);
    1:     nsIContent *ownerContent = parentDoc->FindContentForSubDocument(mDocument);
    1:     nsCOMPtr<nsIDOMNode> ownerNode(do_QueryInterface(ownerContent));
    1:     if (ownerNode) {
    1:       nsCOMPtr<nsIAccessibilityService> accService =
    1:         do_GetService("@mozilla.org/accessibilityService;1");
    1:       if (accService) {
    1:         // XXX aaronl: ideally we would traverse the presshell chain
    1:         // Since there's no easy way to do that, we cheat and use
    1:         // the document hierarchy. GetAccessibleFor() is bad because
    1:         // it doesn't support our concept of multiple presshells per doc.
    1:         // It should be changed to use GetAccessibleInWeakShell()
    1:         accService->GetAccessibleFor(ownerNode, getter_AddRefs(mParent));
    1:       }
    1:     }
    1:   }
    1:   return mParent ? nsAccessible::GetParent(aParent) : NS_ERROR_FAILURE;
    1: }
    1: 
21169: nsresult
21169: nsDocAccessible::Init()
    1: {
 8471:   PutCacheEntry(gGlobalDocAccessibleCache, mDocument, this);
    1: 
    1:   AddEventListeners();
    1: 
13094:   nsCOMPtr<nsIAccessible> parentAccessible;  // Ensure outer doc mParent accessible
13094:   GetParent(getter_AddRefs(parentAccessible));
    1: 
30410:   nsresult rv = nsHyperTextAccessibleWrap::Init();
30410:   NS_ENSURE_SUCCESS(rv, rv);
30410: 
30410:   // Fire reorder event to notify new accessible document has been created and
30410:   // attached to the tree.
30410:   nsCOMPtr<nsIAccessibleEvent> reorderEvent =
30410:     new nsAccReorderEvent(mParent, PR_FALSE, PR_TRUE, mDOMNode);
30410:   NS_ENSURE_TRUE(reorderEvent, NS_ERROR_OUT_OF_MEMORY);
30410: 
30410:   FireDelayedAccessibleEvent(reorderEvent);
30410:   return NS_OK;
    1: }
    1: 
21169: nsresult
21169: nsDocAccessible::Shutdown()
    1: {
    1:   if (!mWeakShell) {
    1:     return NS_OK;  // Already shutdown
    1:   }
    1: 
 5679:   nsCOMPtr<nsIDocShellTreeItem> treeItem =
20521:     nsCoreUtils::GetDocShellTreeItemFor(mDOMNode);
    1:   ShutdownChildDocuments(treeItem);
    1: 
    1:   RemoveEventListeners();
    1: 
    1:   mWeakShell = nsnull;  // Avoid reentrancy
    1: 
    1:   ClearCache(mAccessNodeCache);
    1: 
12240:   nsCOMPtr<nsIDocument> kungFuDeathGripDoc = mDocument;
    1:   mDocument = nsnull;
    1: 
 9691:   nsHyperTextAccessibleWrap::Shutdown();
 9691: 
 9691:   if (mFireEventTimer) {
 9691:     // Doc being shut down before events fired,
 9691:     mFireEventTimer->Cancel();
 9691:     mFireEventTimer = nsnull;
 9691:     if (mEventsToFire.Count() > 0 ) {
 9691:       mEventsToFire.Clear();
 9691:       // Make sure we release the kung fu death grip which is always
 9691:       // there when there are still events left to be fired
15262:       // If FlushPendingEvents() is in call stack,
15262:       // kung fu death grip will be released there.
15262:       if (!mInFlushPendingEvents)
 9691:         NS_RELEASE_THIS();
 9691:     }
 9691:   }
 9691: 
12240:   // Remove from the cache after other parts of Shutdown(), so that Shutdown() procedures
12240:   // can find the doc or root accessible in the cache if they need it.
12438:   // We don't do this during ShutdownAccessibility() because that is already clearing the cache
30820:   if (!nsAccessibilityService::gIsShutdown)
12240:     gGlobalDocAccessibleCache.Remove(static_cast<void*>(kungFuDeathGripDoc));
12240: 
 9691:   return NS_OK;
    1: }
    1: 
    1: void nsDocAccessible::ShutdownChildDocuments(nsIDocShellTreeItem *aStart)
    1: {
    1:   nsCOMPtr<nsIDocShellTreeNode> treeNode(do_QueryInterface(aStart));
    1:   if (treeNode) {
    1:     PRInt32 subDocuments;
    1:     treeNode->GetChildCount(&subDocuments);
    1:     for (PRInt32 count = 0; count < subDocuments; count ++) {
    1:       nsCOMPtr<nsIDocShellTreeItem> treeItemChild;
    1:       treeNode->GetChildAt(count, getter_AddRefs(treeItemChild));
    1:       NS_ASSERTION(treeItemChild, "No tree item when there should be");
    1:       if (!treeItemChild) {
    1:         continue;
    1:       }
    1:       nsCOMPtr<nsIAccessibleDocument> docAccessible =
    1:         GetDocAccessibleFor(treeItemChild);
21169:       if (docAccessible) {
21169:         nsRefPtr<nsAccessNode> docAccNode =
21169:           nsAccUtils::QueryAccessNode(docAccessible);
21169:         docAccNode->Shutdown();
    1:       }
    1:     }
    1:   }
    1: }
    1: 
21169: nsIFrame*
21169: nsDocAccessible::GetFrame()
    1: {
    1:   nsCOMPtr<nsIPresShell> shell(do_QueryReferent(mWeakShell));
    1: 
    1:   nsIFrame* root = nsnull;
    1:   if (shell)
    1:     root = shell->GetRootFrame();
    1: 
    1:   return root;
    1: }
    1: 
29564: PRBool
29564: nsDocAccessible::IsDefunct()
29564: {
29564:   if (nsHyperTextAccessibleWrap::IsDefunct())
29564:     return PR_TRUE;
29564: 
29564:   return !mDocument;
29564: }
29564: 
    1: void nsDocAccessible::GetBoundsRect(nsRect& aBounds, nsIFrame** aRelativeFrame)
    1: {
    1:   *aRelativeFrame = GetFrame();
    1: 
    1:   nsIDocument *document = mDocument;
    1:   nsIDocument *parentDoc = nsnull;
    1: 
    1:   while (document) {
  981:     nsIPresShell *presShell = document->GetPrimaryShell();
    1:     if (!presShell) {
    1:       return;
    1:     }
    1:     nsIViewManager* vm = presShell->GetViewManager();
    1:     if (!vm) {
    1:       return;
    1:     }
    1: 
    1:     nsIScrollableView* scrollableView = nsnull;
    1:     vm->GetRootScrollableView(&scrollableView);
    1: 
    1:     nsRect viewBounds(0, 0, 0, 0);
    1:     if (scrollableView) {
    1:       viewBounds = scrollableView->View()->GetBounds();
    1:     }
    1:     else {
    1:       nsIView *view;
    1:       vm->GetRootView(view);
    1:       if (view) {
    1:         viewBounds = view->GetBounds();
    1:       }
    1:     }
    1: 
    1:     if (parentDoc) {  // After first time thru loop
    1:       aBounds.IntersectRect(viewBounds, aBounds);
    1:     }
    1:     else {  // First time through loop
    1:       aBounds = viewBounds;
    1:     }
    1: 
    1:     document = parentDoc = document->GetParentDocument();
    1:   }
    1: }
    1: 
    1: 
    1: nsresult nsDocAccessible::AddEventListeners()
    1: {
    1:   // 1) Set up scroll position listener
    1:   // 2) Check for editor and listen for changes to editor
    1: 
    1:   nsCOMPtr<nsIPresShell> presShell(GetPresShell());
    1:   NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsISupports> container = mDocument->GetContainer();
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem(do_QueryInterface(container));
    1:   NS_ENSURE_TRUE(docShellTreeItem, NS_ERROR_FAILURE);
    1: 
    1:   // Make sure we're a content docshell
    1:   // We don't want to listen to chrome progress
    1:   PRInt32 itemType;
    1:   docShellTreeItem->GetItemType(&itemType);
    1: 
    1:   PRBool isContent = (itemType == nsIDocShellTreeItem::typeContent);
    1: 
    1:   if (isContent) {
    1:     // We're not an editor yet, but we might become one
    1:     nsCOMPtr<nsICommandManager> commandManager = do_GetInterface(docShellTreeItem);
    1:     if (commandManager) {
    1:       commandManager->AddCommandObserver(this, "obs_documentCreated");
    1:     }
    1:   }
    1: 
 1249:   nsCOMPtr<nsIDocShellTreeItem> rootTreeItem;
 1249:   docShellTreeItem->GetRootTreeItem(getter_AddRefs(rootTreeItem));
 1249:   if (rootTreeItem) {
 6794:     nsCOMPtr<nsIAccessibleDocument> rootAccDoc =
 2395:       GetDocAccessibleFor(rootTreeItem, PR_TRUE); // Ensure root accessible is created;
 6794:     nsRefPtr<nsRootAccessible> rootAccessible = GetRootAccessible(); // Then get it as ref ptr
 2395:     NS_ENSURE_TRUE(rootAccessible, NS_ERROR_FAILURE);
 2395:     nsRefPtr<nsCaretAccessible> caretAccessible = rootAccessible->GetCaretAccessible();
 2395:     if (caretAccessible) {
10873:       caretAccessible->AddDocSelectionListener(presShell);
 1249:     }
 1249:   }
 1249: 
    1:   // add document observer
    1:   mDocument->AddObserver(this);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsDocAccessible::RemoveEventListeners()
    1: {
    1:   // Remove listeners associated with content documents
    1:   // Remove scroll position listener
    1:   RemoveScrollListener();
    1: 
29795:   NS_ASSERTION(mDocument, "No document during removal of listeners.");
29795: 
29795:   if (mDocument) {
    1:     mDocument->RemoveObserver(this);
    1: 
29795:     nsCOMPtr<nsISupports> container = mDocument->GetContainer();
29795:     nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem(do_QueryInterface(container));
29795:     NS_ASSERTION(docShellTreeItem, "doc should support nsIDocShellTreeItem.");
29795: 
29795:     if (docShellTreeItem) {
29795:       PRInt32 itemType;
29795:       docShellTreeItem->GetItemType(&itemType);
29795:       if (itemType == nsIDocShellTreeItem::typeContent) {
29795:         nsCOMPtr<nsICommandManager> commandManager = do_GetInterface(docShellTreeItem);
29795:         if (commandManager) {
29795:           commandManager->RemoveCommandObserver(this, "obs_documentCreated");
29795:         }
29795:       }
29795:     }
29795:   }
29795: 
    1:   if (mScrollWatchTimer) {
    1:     mScrollWatchTimer->Cancel();
    1:     mScrollWatchTimer = nsnull;
10411:     NS_RELEASE_THIS(); // Kung fu death grip
    1:   }
    1: 
 1249:   nsRefPtr<nsRootAccessible> rootAccessible(GetRootAccessible());
 1249:   if (rootAccessible) {
 2395:     nsRefPtr<nsCaretAccessible> caretAccessible = rootAccessible->GetCaretAccessible();
 2395:     if (caretAccessible) {
11032:       // Don't use GetPresShell() which can call Shutdown() if it sees dead pres shell
11032:       nsCOMPtr<nsIPresShell> presShell(do_QueryReferent(mWeakShell));
10873:       caretAccessible->RemoveDocSelectionListener(presShell);
 1249:     }
 1249:   }
 1249: 
    1:   return NS_OK;
    1: }
    1: 
29564: void
29564: nsDocAccessible::FireAnchorJumpEvent()
    1: {
29564:   if (!mIsContentLoaded || !mDocument)
29564:     return;
29564: 
    1:   nsCOMPtr<nsISupports> container = mDocument->GetContainer();
    1:   nsCOMPtr<nsIWebNavigation> webNav(do_GetInterface(container));
    1:   nsCAutoString theURL;
    1:   if (webNav) {
    1:     nsCOMPtr<nsIURI> pURI;
    1:     webNav->GetCurrentURI(getter_AddRefs(pURI));
    1:     if (pURI) {
    1:       pURI->GetSpec(theURL);
    1:     }
    1:   }
    1:   static nsCAutoString lastAnchor;
    1:   const char kHash = '#';
    1:   nsCAutoString currentAnchor;
    1:   PRInt32 hasPosition = theURL.FindChar(kHash);
    1:   if (hasPosition > 0 && hasPosition < (PRInt32)theURL.Length() - 1) {
    1:     mIsAnchor = PR_TRUE;
    1:     currentAnchor.Assign(Substring(theURL,
    1:                                    hasPosition+1, 
    1:                                    (PRInt32)theURL.Length()-hasPosition-1));
    1:   }
    1: 
    1:   if (currentAnchor.Equals(lastAnchor)) {
    1:     mIsAnchorJumped = PR_FALSE;
    1:   } else {
    1:     mIsAnchorJumped = PR_TRUE;
    1:     lastAnchor.Assign(currentAnchor);
    1:   }
    1: }
    1: 
29564: void
29564: nsDocAccessible::FireDocLoadEvents(PRUint32 aEventType)
    1: {
29564:   if (IsDefunct())
29564:     return;
    1: 
    1:   PRBool isFinished = 
    1:              (aEventType == nsIAccessibleEvent::EVENT_DOCUMENT_LOAD_COMPLETE ||
    1:               aEventType == nsIAccessibleEvent::EVENT_DOCUMENT_LOAD_STOPPED);
    1: 
12254:   mIsContentLoaded = isFinished;
12254:   if (isFinished) {
12254:     if (mIsLoadCompleteFired)
29564:       return;
29564: 
12254:     mIsLoadCompleteFired = PR_TRUE;
    1:   }
    1: 
12240:   nsCOMPtr<nsIDocShellTreeItem> treeItem =
20521:     nsCoreUtils::GetDocShellTreeItemFor(mDOMNode);
29564:   if (!treeItem)
29564:     return;
29564: 
12240:   nsCOMPtr<nsIDocShellTreeItem> sameTypeRoot;
12240:   treeItem->GetSameTypeRootTreeItem(getter_AddRefs(sameTypeRoot));
12240: 
    1:   if (isFinished) {
    1:     // Need to wait until scrollable view is available
    1:     AddScrollListener();
    1:     nsCOMPtr<nsIAccessible> parent(nsAccessible::GetParent());
29320:     nsRefPtr<nsAccessible> acc(nsAccUtils::QueryAccessible(parent));
29320:     if (acc) {
    1:       // Make the parent forget about the old document as a child
29320:       acc->InvalidateChildren();
    1:     }
29320: 
12240:     if (sameTypeRoot != treeItem) {
12240:       // Fire show/hide events to indicate frame/iframe content is new, rather than
12240:       // doc load event which causes screen readers to act is if entire page is reloaded
12240:       InvalidateCacheSubtree(nsnull, nsIAccessibleEvent::EVENT_DOM_SIGNIFICANT_CHANGE);
    1:     }
12240:     // Fire STATE_CHANGE event for doc load finish if focus is in same doc tree
12240:     if (gLastFocusedNode) {
12240:       nsCOMPtr<nsIDocShellTreeItem> focusedTreeItem =
20521:         nsCoreUtils::GetDocShellTreeItemFor(gLastFocusedNode);
12240:       if (focusedTreeItem) {
12240:         nsCOMPtr<nsIDocShellTreeItem> sameTypeRootOfFocus;
12240:         focusedTreeItem->GetSameTypeRootTreeItem(getter_AddRefs(sameTypeRootOfFocus));
12240:         if (sameTypeRoot == sameTypeRootOfFocus) {
12240:           nsCOMPtr<nsIAccessibleStateChangeEvent> accEvent =
12240:             new nsAccStateChangeEvent(this, nsIAccessibleStates::STATE_BUSY, PR_FALSE, PR_FALSE);
12240:           FireAccessibleEvent(accEvent);
12240:           FireAnchorJumpEvent();
    1:         }
    1:       }
    1:     }
12254:   }
14921: 
12240:   if (sameTypeRoot == treeItem) {
12240:     // Not a frame or iframe
14921:     if (!isFinished) {
14921:       // Fire state change event to set STATE_BUSY when document is loading. For
14921:       // example, Window-Eyes expects to get it.
14921:       nsCOMPtr<nsIAccessibleStateChangeEvent> accEvent =
14921:         new nsAccStateChangeEvent(this, nsIAccessibleStates::STATE_BUSY,
14921:                                   PR_FALSE, PR_TRUE);
14921:       FireAccessibleEvent(accEvent);
14921:     }
14921: 
20536:     nsAccUtils::FireAccEvent(aEventType, this);
12240:   }
    1: }
    1: 
    1: void nsDocAccessible::ScrollTimerCallback(nsITimer *aTimer, void *aClosure)
    1: {
 3233:   nsDocAccessible *docAcc = reinterpret_cast<nsDocAccessible*>(aClosure);
    1: 
    1:   if (docAcc && docAcc->mScrollPositionChangedTicks &&
    1:       ++docAcc->mScrollPositionChangedTicks > 2) {
    1:     // Whenever scroll position changes, mScrollPositionChangeTicks gets reset to 1
    1:     // We only want to fire accessibilty scroll event when scrolling stops or pauses
    1:     // Therefore, we wait for no scroll events to occur between 2 ticks of this timer
    1:     // That indicates a pause in scrolling, so we fire the accessibilty scroll event
20536:     nsAccUtils::FireAccEvent(nsIAccessibleEvent::EVENT_SCROLLING_END, docAcc);
 3152: 
    1:     docAcc->mScrollPositionChangedTicks = 0;
    1:     if (docAcc->mScrollWatchTimer) {
    1:       docAcc->mScrollWatchTimer->Cancel();
    1:       docAcc->mScrollWatchTimer = nsnull;
10411:       NS_RELEASE(docAcc); // Release kung fu death grip
    1:     }
    1:   }
    1: }
    1: 
    1: void nsDocAccessible::AddScrollListener()
    1: {
    1:   nsCOMPtr<nsIPresShell> presShell(do_QueryReferent(mWeakShell));
    1: 
    1:   nsIViewManager* vm = nsnull;
    1:   if (presShell)
    1:     vm = presShell->GetViewManager();
    1: 
    1:   nsIScrollableView* scrollableView = nsnull;
    1:   if (vm)
    1:     vm->GetRootScrollableView(&scrollableView);
    1: 
    1:   if (scrollableView)
    1:     scrollableView->AddScrollPositionListener(this);
    1: }
    1: 
    1: void nsDocAccessible::RemoveScrollListener()
    1: {
    1:   nsCOMPtr<nsIPresShell> presShell(do_QueryReferent(mWeakShell));
    1: 
    1:   nsIViewManager* vm = nsnull;
    1:   if (presShell)
    1:     vm = presShell->GetViewManager();
    1: 
    1:   nsIScrollableView* scrollableView = nsnull;
    1:   if (vm)
    1:     vm->GetRootScrollableView(&scrollableView);
    1: 
    1:   if (scrollableView)
    1:     scrollableView->RemoveScrollPositionListener(this);
    1: }
    1: 
    1: NS_IMETHODIMP nsDocAccessible::ScrollPositionWillChange(nsIScrollableView *aView, nscoord aX, nscoord aY)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocAccessible::ScrollPositionDidChange(nsIScrollableView *aScrollableView, nscoord aX, nscoord aY)
    1: {
    1:   // Start new timer, if the timer cycles at least 1 full cycle without more scroll position changes,
    1:   // then the ::Notify() method will fire the accessibility event for scroll position changes
    1:   const PRUint32 kScrollPosCheckWait = 50;
    1:   if (mScrollWatchTimer) {
    1:     mScrollWatchTimer->SetDelay(kScrollPosCheckWait);  // Create new timer, to avoid leaks
    1:   }
    1:   else {
    1:     mScrollWatchTimer = do_CreateInstance("@mozilla.org/timer;1");
    1:     if (mScrollWatchTimer) {
10411:       NS_ADDREF_THIS(); // Kung fu death grip
    1:       mScrollWatchTimer->InitWithFuncCallback(ScrollTimerCallback, this,
    1:                                               kScrollPosCheckWait,
    1:                                               nsITimer::TYPE_REPEATING_SLACK);
    1:     }
    1:   }
    1:   mScrollPositionChangedTicks = 1;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocAccessible::Observe(nsISupports *aSubject, const char *aTopic,
    1:                                        const PRUnichar *aData)
    1: {
    1:   if (!nsCRT::strcmp(aTopic,"obs_documentCreated")) {    
 4625:     // State editable will now be set, readonly is now clear
 4625:     nsCOMPtr<nsIAccessibleStateChangeEvent> event =
 4625:       new nsAccStateChangeEvent(this, nsIAccessibleStates::EXT_STATE_EDITABLE,
 4625:                                 PR_TRUE, PR_TRUE);
 4625:     FireAccessibleEvent(event);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1:   ///////////////////////////////////////////////////////////////////////
    1: // nsIDocumentObserver
    1: 
    1: NS_IMPL_NSIDOCUMENTOBSERVER_CORE_STUB(nsDocAccessible)
    1: NS_IMPL_NSIDOCUMENTOBSERVER_LOAD_STUB(nsDocAccessible)
    1: NS_IMPL_NSIDOCUMENTOBSERVER_STYLE_STUB(nsDocAccessible)
    1: 
    1: void
29833: nsDocAccessible::AttributeWillChange(nsIDocument *aDocument,
29833:                                      nsIContent* aContent, PRInt32 aNameSpaceID,
29833:                                      nsIAtom* aAttribute, PRInt32 aModType)
29833: {
29833:   // XXX TODO: bugs 381599 467143 472142 472143
29833:   // Here we will want to cache whatever state we are potentially interested in,
29833:   // such as the existence of aria-pressed for button (so we know if we need to
29833:   // newly expose it as a toggle button) etc.
29833: }
29833: 
29833: void
    1: nsDocAccessible::AttributeChanged(nsIDocument *aDocument, nsIContent* aContent,
    1:                                   PRInt32 aNameSpaceID, nsIAtom* aAttribute,
 3410:                                   PRInt32 aModType, PRUint32 aStateMask)
    1: {
 6065:   AttributeChangedImpl(aContent, aNameSpaceID, aAttribute);
 6065: 
 6065:   // If it was the focused node, cache the new state
 6065:   nsCOMPtr<nsIDOMNode> targetNode = do_QueryInterface(aContent);
 6065:   if (targetNode == gLastFocusedNode) {
 6065:     nsCOMPtr<nsIAccessible> focusedAccessible;
 6065:     GetAccService()->GetAccessibleFor(targetNode, getter_AddRefs(focusedAccessible));
 6065:     if (focusedAccessible) {
20566:       gLastFocusedAccessiblesState = nsAccUtils::State(focusedAccessible);
 6065:     }
 6065:   }
 6065: }
 6065: 
 6065: 
 6065: void
 6065: nsDocAccessible::AttributeChangedImpl(nsIContent* aContent, PRInt32 aNameSpaceID, nsIAtom* aAttribute)
 6065: {
  577:   // Fire accessible event after short timer, because we need to wait for
  577:   // DOM attribute & resulting layout to actually change. Otherwise,
  577:   // assistive technology will retrieve the wrong state/value/selection info.
  577: 
    1:   // XXX todo
    1:   // We still need to handle special HTML cases here
    1:   // For example, if an <img>'s usemap attribute is modified
    1:   // Otherwise it may just be a state change, for example an object changing
    1:   // its visibility
23549:   // 
23549:   // XXX todo: report aria state changes for "undefined" literal value changes
23549:   // filed as bug 472142
23549:   //
23549:   // XXX todo:  invalidate accessible when aria state changes affect exposed role
23549:   // filed as bug 472143
    1:   
    1:   nsCOMPtr<nsISupports> container = mDocument->GetContainer();
    1:   nsCOMPtr<nsIDocShell> docShell = do_QueryInterface(container);
    1:   if (!docShell) {
    1:     return;
    1:   }
 6279: 
    1:   PRUint32 busyFlags;
    1:   docShell->GetBusyFlags(&busyFlags);
    1:   if (busyFlags) {
    1:     return; // Still loading, ignore setting of initial attributes
    1:   }
    1: 
    1:   nsCOMPtr<nsIPresShell> shell = GetPresShell();
    1:   if (!shell) {
    1:     return; // Document has been shut down
    1:   }
    1: 
  652:   nsCOMPtr<nsIDOMNode> targetNode(do_QueryInterface(aContent));
  652:   NS_ASSERTION(targetNode, "No node for attr modified");
20566:   if (!targetNode || !nsAccUtils::IsNodeRelevant(targetNode))
  650:     return;
  650: 
 4516:   // Since we're in synchronous code, we can store whether the current attribute
 4516:   // change is from user input or not. If the attribute change causes an asynchronous
 4516:   // layout change, that event can use the last known user input state
 4516:   nsAccEvent::PrepareForEvent(targetNode);
 4516: 
  652:   // Universal boolean properties that don't require a role.
 6279:   if (aAttribute == nsAccessibilityAtoms::disabled ||
 8937:       aAttribute == nsAccessibilityAtoms::aria_disabled) {
  652:     // Fire the state change whether disabled attribute is
  652:     // set for XUL, HTML or ARIA namespace.
  652:     // Checking the namespace would not seem to gain us anything, because
  652:     // disabled really is going to mean the same thing in any namespace.
 3451:     // We use the attribute instead of the disabled state bit because
 8937:     // ARIA's aria-disabled does not affect the disabled state bit
  652:     nsCOMPtr<nsIAccessibleStateChangeEvent> enabledChangeEvent =
  652:       new nsAccStateChangeEvent(targetNode,
  652:                                 nsIAccessibleStates::EXT_STATE_ENABLED,
  652:                                 PR_TRUE);
  652:     FireDelayedAccessibleEvent(enabledChangeEvent);
  652:     nsCOMPtr<nsIAccessibleStateChangeEvent> sensitiveChangeEvent =
  652:       new nsAccStateChangeEvent(targetNode,
  652:                                 nsIAccessibleStates::EXT_STATE_SENSITIVE,
  652:                                 PR_TRUE);
  652:     FireDelayedAccessibleEvent(sensitiveChangeEvent);
  652:     return;
  652:   }
  652: 
 6279:   // Check for namespaced ARIA attribute
 8937:   if (aNameSpaceID == kNameSpaceID_None) {
 6279:     // Check for hyphenated aria-foo property?
 6279:     const char* attributeName;
 6279:     aAttribute->GetUTF8String(&attributeName);
 6279:     if (!PL_strncmp("aria-", attributeName, 5)) {
 8937:       ARIAAttributeChanged(aContent, aAttribute);
 6279:     }
 6279:   }
  577: 
 6405:   if (aAttribute == nsAccessibilityAtoms::role ||
 6405:       aAttribute == nsAccessibilityAtoms::href ||
27135:       aAttribute == nsAccessibilityAtoms::onclick) {
 6405:     // Not worth the expense to ensure which namespace these are in
 6405:     // It doesn't kill use to recreate the accessible even if the attribute was used
 6405:     // in the wrong namespace or an element that doesn't support it
 4516:     InvalidateCacheSubtree(aContent, nsIAccessibleEvent::EVENT_DOM_SIGNIFICANT_CHANGE);
    1:     return;
    1:   }
    1:   
11915:   if (aAttribute == nsAccessibilityAtoms::alt ||
28314:       aAttribute == nsAccessibilityAtoms::title ||
28314:       aAttribute == nsAccessibilityAtoms::aria_label ||
28314:       aAttribute == nsAccessibilityAtoms::aria_labelledby) {
11915:     FireDelayedToolkitEvent(nsIAccessibleEvent::EVENT_NAME_CHANGE,
13167:                             targetNode);
11915:     return;
11915:   }
11915: 
 8937:   if (aAttribute == nsAccessibilityAtoms::selected ||
 8937:       aAttribute == nsAccessibilityAtoms::aria_selected) {
 8937:     // ARIA or XUL selection
20566:     nsCOMPtr<nsIAccessible> multiSelect =
20566:       nsAccUtils::GetMultiSelectFor(targetNode);
    1:     // Multi selects use selection_add and selection_remove
    1:     // Single select widgets just mirror event_selection for
    1:     // whatever gets event_focus, which is done in
    1:     // nsRootAccessible::FireAccessibleFocusEvent()
    1:     // So right here we make sure only to deal with multi selects
    1:     if (multiSelect) {
    1:       // Need to find the right event to use here, SELECTION_WITHIN would
    1:       // seem right but we had started using it for something else
    1:       nsCOMPtr<nsIAccessNode> multiSelectAccessNode =
    1:         do_QueryInterface(multiSelect);
    1:       nsCOMPtr<nsIDOMNode> multiSelectDOMNode;
    1:       multiSelectAccessNode->GetDOMNode(getter_AddRefs(multiSelectDOMNode));
    1:       NS_ASSERTION(multiSelectDOMNode, "A new accessible without a DOM node!");
    1:       FireDelayedToolkitEvent(nsIAccessibleEvent::EVENT_SELECTION_WITHIN,
13167:                               multiSelectDOMNode,
13167:                               nsAccEvent::eAllowDupes);
  577: 
    1:       static nsIContent::AttrValuesArray strings[] =
    1:         {&nsAccessibilityAtoms::_empty, &nsAccessibilityAtoms::_false, nsnull};
 8937:       if (aContent->FindAttrValueIn(kNameSpaceID_None, aAttribute,
 8937:                                     strings, eCaseMatters) >= 0) {
  577:         FireDelayedToolkitEvent(nsIAccessibleEvent::EVENT_SELECTION_REMOVE,
10375:                                 targetNode);
  577:         return;
    1:       }
  577: 
  577:       FireDelayedToolkitEvent(nsIAccessibleEvent::EVENT_SELECTION_ADD,
10375:                                                   targetNode);
    1:     }
    1:   }
 4625: 
 4625:   if (aAttribute == nsAccessibilityAtoms::contenteditable) {
 4625:     nsCOMPtr<nsIAccessibleStateChangeEvent> editableChangeEvent =
 4625:       new nsAccStateChangeEvent(targetNode,
 4625:                                 nsIAccessibleStates::EXT_STATE_EDITABLE,
 4625:                                 PR_TRUE);
 4625:     FireDelayedAccessibleEvent(editableChangeEvent);
 4625:     return;
 4625:   }
    1: }
  577: 
  577: void
  577: nsDocAccessible::ARIAAttributeChanged(nsIContent* aContent, nsIAtom* aAttribute)
  577: {
  577:   nsCOMPtr<nsIDOMNode> targetNode(do_QueryInterface(aContent));
  577:   if (!targetNode)
  577:     return;
  577: 
 8937:   if (aAttribute == nsAccessibilityAtoms::aria_required) {
  577:     nsCOMPtr<nsIAccessibleStateChangeEvent> event =
  577:       new nsAccStateChangeEvent(targetNode,
  577:                                 nsIAccessibleStates::STATE_REQUIRED,
  577:                                 PR_FALSE);
  577:     FireDelayedAccessibleEvent(event);
  577:     return;
  577:   }
  577: 
 8937:   if (aAttribute == nsAccessibilityAtoms::aria_invalid) {
  577:     nsCOMPtr<nsIAccessibleStateChangeEvent> event =
  577:       new nsAccStateChangeEvent(targetNode,
  577:                                 nsIAccessibleStates::STATE_INVALID,
  577:                                 PR_FALSE);
  577:     FireDelayedAccessibleEvent(event);
  577:     return;
  577:   }
  577: 
 8937:   if (aAttribute == nsAccessibilityAtoms::aria_activedescendant) {
    1:     // The activedescendant universal property redirects accessible focus events
    1:     // to the element with the id that activedescendant points to
    1:     nsCOMPtr<nsIDOMNode> currentFocus = GetCurrentFocus();
20566:     if (SameCOMIdentity(nsCoreUtils::GetRoleContent(currentFocus), targetNode)) {
    1:       nsRefPtr<nsRootAccessible> rootAcc = GetRootAccessible();
  577:       if (rootAcc)
    1:         rootAcc->FireAccessibleFocusEvent(nsnull, currentFocus, nsnull, PR_TRUE);
    1:     }
    1:     return;
    1:   }
  577: 
 8937:   if (!aContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::role)) {
    1:     // We don't care about these other ARIA attribute changes unless there is
    1:     // an ARIA role set for the element
  577:     // XXX: we should check the role map to see if the changed property is
  577:     // relevant for that particular role.
    1:     return;
    1:   }
  577: 
 8937:   // The following ARIA attributes only take affect when dynamic content role is present
 8937:   if (aAttribute == nsAccessibilityAtoms::aria_checked ||
 8937:       aAttribute == nsAccessibilityAtoms::aria_pressed) {
 8937:     const PRUint32 kState = (aAttribute == nsAccessibilityAtoms::aria_checked) ?
 6065:                             nsIAccessibleStates::STATE_CHECKED : 
 6065:                             nsIAccessibleStates::STATE_PRESSED;
 6065:     nsCOMPtr<nsIAccessibleStateChangeEvent> event =
 6065:       new nsAccStateChangeEvent(targetNode, kState, PR_FALSE);
 6065:     FireDelayedAccessibleEvent(event);
 6065:     if (targetNode == gLastFocusedNode) {
 6065:       // State changes for MIXED state currently only supported for focused item, because
 6065:       // otherwise we would need access to the old attribute value in this listener.
 8937:       // This is because we don't know if the previous value of aria-checked or aria-pressed was "mixed"
 6065:       // without caching that info.
 6065:       nsCOMPtr<nsIAccessible> accessible;
 6065:       event->GetAccessible(getter_AddRefs(accessible));
 6065:       if (accessible) {
 6065:         PRBool wasMixed = (gLastFocusedAccessiblesState & nsIAccessibleStates::STATE_MIXED) != 0;
20566:         PRBool isMixed  =
20566:           (nsAccUtils::State(accessible) & nsIAccessibleStates::STATE_MIXED) != 0;
 6065:         if (wasMixed != isMixed) {
  577:           nsCOMPtr<nsIAccessibleStateChangeEvent> event =
  577:             new nsAccStateChangeEvent(targetNode,
 6065:                                       nsIAccessibleStates::STATE_MIXED,
 6065:                                       PR_FALSE, isMixed);
  577:           FireDelayedAccessibleEvent(event);
    1:         }
 6065:       }
 6065:     }
 4624:     return;
 4624:   }
 4624: 
 8937:   if (aAttribute == nsAccessibilityAtoms::aria_expanded) {
  577:     nsCOMPtr<nsIAccessibleStateChangeEvent> event =
  577:       new nsAccStateChangeEvent(targetNode,
  577:                                 nsIAccessibleStates::STATE_EXPANDED,
  577:                                 PR_FALSE);
  577:     FireDelayedAccessibleEvent(event);
  577:     return;
    1:   }
  577: 
 8937:   if (aAttribute == nsAccessibilityAtoms::aria_readonly) {
  577:     nsCOMPtr<nsIAccessibleStateChangeEvent> event =
  577:       new nsAccStateChangeEvent(targetNode,
  577:                                 nsIAccessibleStates::STATE_READONLY,
  577:                                 PR_FALSE);
  577:     FireDelayedAccessibleEvent(event);
  577:     return;
  577:   }
  577: 
29090:   // Fire value change event whenever aria-valuetext is changed, or
29090:   // when aria-valuenow is changed and aria-valuetext is empty
29090:   if (aAttribute == nsAccessibilityAtoms::aria_valuetext ||      
29090:       (aAttribute == nsAccessibilityAtoms::aria_valuenow &&
29090:        (!aContent->HasAttr(kNameSpaceID_None,
29090:            nsAccessibilityAtoms::aria_valuetext) ||
29090:         aContent->AttrValueIs(kNameSpaceID_None,
29090:             nsAccessibilityAtoms::aria_valuetext, nsAccessibilityAtoms::_empty,
29090:             eCaseMatters)))) {
29090:     FireDelayedToolkitEvent(nsIAccessibleEvent::EVENT_VALUE_CHANGE, targetNode);
  577:     return;
  577:   }
  577: 
 8937:   if (aAttribute == nsAccessibilityAtoms::aria_multiselectable &&
 8937:       aContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::role)) {
    1:     // This affects whether the accessible supports nsIAccessibleSelectable.
    1:     // COM says we cannot change what interfaces are supported on-the-fly,
    1:     // so invalidate this object. A new one will be created on demand.
 4516:     InvalidateCacheSubtree(aContent, nsIAccessibleEvent::EVENT_DOM_SIGNIFICANT_CHANGE);
    1:   }
    1: }
    1: 
    1: void nsDocAccessible::ContentAppended(nsIDocument *aDocument,
    1:                                       nsIContent* aContainer,
    1:                                       PRInt32 aNewIndexInContainer)
    1: {
 5474:   if ((!mIsContentLoaded || !mDocument) && mAccessNodeCache.Count() <= 1) {
 4296:     // See comments in nsDocAccessible::InvalidateCacheSubtree
 4296:     InvalidateChildren();
 4296:     return;
 4296:   }
 4296: 
 3950:   PRUint32 childCount = aContainer->GetChildCount();
 3950:   for (PRUint32 index = aNewIndexInContainer; index < childCount; index ++) {
 3950:     nsCOMPtr<nsIContent> child(aContainer->GetChildAt(index));
    1:     // InvalidateCacheSubtree will not fire the EVENT_SHOW for the new node
    1:     // unless an accessible can be created for the passed in node, which it
    1:     // can't do unless the node is visible. The right thing happens there so
    1:     // no need for an extra visibility check here.
 4516:     InvalidateCacheSubtree(child, nsIAccessibleEvent::EVENT_DOM_CREATE);
    1:   }
    1: }
    1: 
    1: void nsDocAccessible::ContentStatesChanged(nsIDocument* aDocument,
    1:                                            nsIContent* aContent1,
    1:                                            nsIContent* aContent2,
    1:                                            PRInt32 aStateMask)
    1: {
    1:   if (0 == (aStateMask & NS_EVENT_STATE_CHECKED)) {
    1:     return;
    1:   }
    1: 
    1:   nsHTMLSelectOptionAccessible::SelectionChangedIfOption(aContent1);
    1:   nsHTMLSelectOptionAccessible::SelectionChangedIfOption(aContent2);
    1: }
    1: 
 5681: void nsDocAccessible::CharacterDataWillChange(nsIDocument *aDocument,
 5681:                                               nsIContent* aContent,
 5681:                                               CharacterDataChangeInfo* aInfo)
 5681: {
 5681:   FireTextChangeEventForText(aContent, aInfo, PR_FALSE);
 5681: }
 5681: 
    1: void nsDocAccessible::CharacterDataChanged(nsIDocument *aDocument,
    1:                                            nsIContent* aContent,
    1:                                            CharacterDataChangeInfo* aInfo)
    1: {
 5681:   FireTextChangeEventForText(aContent, aInfo, PR_TRUE);
    1: }
    1: 
    1: void
    1: nsDocAccessible::ContentInserted(nsIDocument *aDocument, nsIContent* aContainer,
    1:                                  nsIContent* aChild, PRInt32 aIndexInContainer)
    1: {
    1:   // InvalidateCacheSubtree will not fire the EVENT_SHOW for the new node
    1:   // unless an accessible can be created for the passed in node, which it
    1:   // can't do unless the node is visible. The right thing happens there so
    1:   // no need for an extra visibility check here.
 4516:   InvalidateCacheSubtree(aChild, nsIAccessibleEvent::EVENT_DOM_CREATE);
    1: }
    1: 
    1: void
    1: nsDocAccessible::ContentRemoved(nsIDocument *aDocument, nsIContent* aContainer,
    1:                                 nsIContent* aChild, PRInt32 aIndexInContainer)
    1: {
 3950:   // Invalidate the subtree of the removed element.
 5395:   // InvalidateCacheSubtree(aChild, nsIAccessibleEvent::EVENT_DOM_DESTROY);
 5395:   // This is no longer needed, we get our notifications directly from content
 5395:   // *before* the frame for the content is destroyed, or any other side effects occur.
 5395:   // That allows us to correctly calculate the TEXT_REMOVED event if there is one.
    1: }
    1: 
    1: void
    1: nsDocAccessible::ParentChainChanged(nsIContent *aContent)
    1: {
    1: }
    1: 
 3950: void
13353: nsDocAccessible::FireValueChangeForTextFields(nsIAccessible *aPossibleTextFieldAccessible)
13353: {
20566:   if (nsAccUtils::Role(aPossibleTextFieldAccessible) != nsIAccessibleRole::ROLE_ENTRY)
13353:     return;
13353: 
13353:   // Dependent value change event for text changes in textfields
13353:   nsCOMPtr<nsIAccessibleEvent> valueChangeEvent =
13353:     new nsAccEvent(nsIAccessibleEvent::EVENT_VALUE_CHANGE, aPossibleTextFieldAccessible,
13353:                    PR_FALSE, nsAccEvent::eRemoveDupes);
13353:   FireDelayedAccessibleEvent(valueChangeEvent );
13353: }
13353: 
13353: void
 5681: nsDocAccessible::FireTextChangeEventForText(nsIContent *aContent,
 5681:                                             CharacterDataChangeInfo* aInfo,
 5681:                                             PRBool aIsInserted)
 3950: {
 4296:   if (!mIsContentLoaded || !mDocument) {
 4296:     return;
 4296:   }
 4296: 
 3950:   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(aContent));
 3950:   if (!node)
 3950:     return;
 3950: 
 3950:   nsCOMPtr<nsIAccessible> accessible;
 6486:   nsresult rv = GetAccessibleInParentChain(node, PR_TRUE, getter_AddRefs(accessible));
 4751:   if (NS_FAILED(rv) || !accessible)
 3950:     return;
 3950: 
 3950:   nsRefPtr<nsHyperTextAccessible> textAccessible;
 3950:   rv = accessible->QueryInterface(NS_GET_IID(nsHyperTextAccessible),
 3950:                                   getter_AddRefs(textAccessible));
 3950:   if (NS_FAILED(rv) || !textAccessible)
 3950:     return;
 3950: 
 3950:   PRInt32 start = aInfo->mChangeStart;
 3950: 
 3950:   PRInt32 offset = 0;
 4261:   rv = textAccessible->DOMPointToHypertextOffset(node, start, &offset);
 3950:   if (NS_FAILED(rv))
 3950:     return;
 3950: 
 5681:   PRInt32 length = aIsInserted ?
 5683:     aInfo->mReplaceLength: // text has been added
 5683:     aInfo->mChangeEnd - start; // text has been removed
 5681: 
 3950:   if (length > 0) {
 5681:     nsCOMPtr<nsIPresShell> shell(do_QueryReferent(mWeakShell));
 5681:     if (!shell)
 5681:       return;
 5681: 
 5681:     PRUint32 renderedStartOffset, renderedEndOffset;
 5681:     nsIFrame* frame = shell->GetPrimaryFrameFor(aContent);
 8374:     if (!frame)
 8374:       return;
 5681: 
 5681:     rv = textAccessible->ContentToRenderedOffset(frame, start,
 5681:                                                  &renderedStartOffset);
 5681:     if (NS_FAILED(rv))
 5681:       return;
 5681: 
 5681:     rv = textAccessible->ContentToRenderedOffset(frame, start + length,
 5681:                                                  &renderedEndOffset);
 5681:     if (NS_FAILED(rv))
 5681:       return;
 5681: 
 3950:     nsCOMPtr<nsIAccessibleTextChangeEvent> event =
 5681:       new nsAccTextChangeEvent(accessible, offset,
 5681:                                renderedEndOffset - renderedStartOffset,
 5681:                                aIsInserted, PR_FALSE);
 3950:     textAccessible->FireAccessibleEvent(event);
13353: 
13353:     FireValueChangeForTextFields(accessible);
 3950:   }
 3950: }
 3950: 
 5395: already_AddRefed<nsIAccessibleTextChangeEvent>
 5395: nsDocAccessible::CreateTextChangeEventForNode(nsIAccessible *aContainerAccessible,
 5395:                                               nsIDOMNode *aChangeNode,
 5395:                                               nsIAccessible *aAccessibleForChangeNode,
 5395:                                               PRBool aIsInserting,
 5395:                                               PRBool aIsAsynch)
 3950: {
 5395:   nsRefPtr<nsHyperTextAccessible> textAccessible;
 5395:   aContainerAccessible->QueryInterface(NS_GET_IID(nsHyperTextAccessible),
 5395:                                        getter_AddRefs(textAccessible));
 5395:   if (!textAccessible) {
 5395:     return nsnull;
 4296:   }
 4296: 
 5395:   PRInt32 offset;
 5395:   PRInt32 length = 0;
 5395:   nsCOMPtr<nsIAccessible> changeAccessible;
 5395:   nsresult rv = textAccessible->DOMPointToHypertextOffset(aChangeNode, -1, &offset,
 5395:                                                           getter_AddRefs(changeAccessible));
 5395:   NS_ENSURE_SUCCESS(rv, nsnull);
 3950: 
 5395:   if (!aAccessibleForChangeNode) {
 5395:     // A span-level object or something else without an accessible is being removed, where
 5395:     // it has no accessible but it has descendant content which is aggregated as text
 5395:     // into the parent hypertext.
 5395:     // In this case, accessibleToBeRemoved may just be the first
 5395:     // accessible that is removed, which affects the text in the hypertext container
 5395:     if (!changeAccessible) {
 5395:       return nsnull; // No descendant content that represents any text in the hypertext parent
 5395:     }
 5395:     nsCOMPtr<nsIAccessible> child = changeAccessible;
 5395:     while (PR_TRUE) {
 5395:       nsCOMPtr<nsIAccessNode> childAccessNode =
 5395:         do_QueryInterface(changeAccessible);
 5395:       nsCOMPtr<nsIDOMNode> childNode;
 5395:       childAccessNode->GetDOMNode(getter_AddRefs(childNode));
20521:       if (!nsCoreUtils::IsAncestorOf(aChangeNode, childNode)) {
 5395:         break;  // We only want accessibles with DOM nodes as children of this node
 5395:       }
20566:       length += nsAccUtils::TextLength(child);
 5395:       child->GetNextSibling(getter_AddRefs(changeAccessible));
 5395:       if (!changeAccessible) {
 5395:         break;
 5395:       }
 5395:       child.swap(changeAccessible);
 5395:     }
 5395:   }
 5395:   else {
 6285:     NS_ASSERTION(!changeAccessible || changeAccessible == aAccessibleForChangeNode,
 5395:                  "Hypertext is reporting a different accessible for this node");
20566: 
20566:     length = nsAccUtils::TextLength(aAccessibleForChangeNode);
20566:     if (nsAccUtils::Role(aAccessibleForChangeNode) == nsIAccessibleRole::ROLE_WHITESPACE) {  // newline
 3950:       // Don't fire event for the first html:br in an editor.
 3950:       nsCOMPtr<nsIEditor> editor;
 3950:       textAccessible->GetAssociatedEditor(getter_AddRefs(editor));
 3950:       if (editor) {
 3950:         PRBool isEmpty = PR_FALSE;
 3950:         editor->GetDocumentIsEmpty(&isEmpty);
 5395:         if (isEmpty) {
 5395:           return nsnull;
 5395:         }
 5395:       }
 3950:     }
 3950:   }
 3950: 
 5395:   if (length <= 0) {
 5395:     return nsnull;
 3950:   }
 3950: 
 5395:   nsIAccessibleTextChangeEvent *event =
 5395:     new nsAccTextChangeEvent(aContainerAccessible, offset, length, aIsInserting, aIsAsynch);
 5395:   NS_IF_ADDREF(event);
 4296: 
 5395:   return event;
 3950: }
 3950:   
    1: nsresult nsDocAccessible::FireDelayedToolkitEvent(PRUint32 aEvent,
    1:                                                   nsIDOMNode *aDOMNode,
13167:                                                   nsAccEvent::EEventRule aAllowDupes,
 4516:                                                   PRBool aIsAsynch)
    1: {
 4516:   nsCOMPtr<nsIAccessibleEvent> event =
13167:     new nsAccEvent(aEvent, aDOMNode, aIsAsynch, aAllowDupes);
  577:   NS_ENSURE_TRUE(event, NS_ERROR_OUT_OF_MEMORY);
  577: 
13167:   return FireDelayedAccessibleEvent(event);
  577: }
  577: 
  577: nsresult
13167: nsDocAccessible::FireDelayedAccessibleEvent(nsIAccessibleEvent *aEvent)
  577: {
 4846:   NS_ENSURE_TRUE(aEvent, NS_ERROR_FAILURE);
 4846: 
    1:   if (!mFireEventTimer) {
    1:     // Do not yet have a timer going for firing another event.
    1:     mFireEventTimer = do_CreateInstance("@mozilla.org/timer;1");
    1:     NS_ENSURE_TRUE(mFireEventTimer, NS_ERROR_OUT_OF_MEMORY);
    1:   }
  577: 
  577:   mEventsToFire.AppendObject(aEvent);
13167:   if (mEventsToFire.Count() == 1) {
    1:     // This is be the first delayed event in queue, start timer
    1:     // so that event gets fired via FlushEventsCallback
 9691:     NS_ADDREF_THIS(); // Kung fu death grip to prevent crash in callback
    1:     mFireEventTimer->InitWithFuncCallback(FlushEventsCallback,
29564:                                           this, 0, nsITimer::TYPE_ONE_SHOT);
    1:   }
  577: 
    1:   return NS_OK;
    1: }
    1: 
29564: void
29564: nsDocAccessible::FlushPendingEvents()
    1: {
15262:   mInFlushPendingEvents = PR_TRUE;
    1:   PRUint32 length = mEventsToFire.Count();
    1:   NS_ASSERTION(length, "How did we get here without events to fire?");
12400:   nsCOMPtr<nsIPresShell> presShell = GetPresShell();
12400:   if (!presShell)
12400:     length = 0; // The doc is now shut down, don't fire events in it anymore
29442:   else {
29442:     // Flush layout so that all the frame construction, reflow, and styles are
29442:     // up-to-date. This will ensure we can get frames for the related nodes, as
29442:     // well as get the most current information for calculating things like
29442:     // visibility. We don't flush the display because we don't care about
29442:     // painting. If no flush is necessary the method will simple return.
29442:     presShell->FlushPendingNotifications(Flush_Layout);
29442: 
29442:     // filter events
13167:     nsAccEvent::ApplyEventRules(mEventsToFire);
29442:   }
13167:   
13167:   for (PRUint32 index = 0; index < length; index ++) {
  577:     nsCOMPtr<nsIAccessibleEvent> accessibleEvent(
  577:       do_QueryInterface(mEventsToFire[index]));
13167: 
13167:     if (nsAccEvent::EventRule(accessibleEvent) == nsAccEvent::eDoNotEmit)
13167:       continue;
  577: 
    1:     nsCOMPtr<nsIAccessible> accessible;
    1:     accessibleEvent->GetAccessible(getter_AddRefs(accessible));
11439:     nsCOMPtr<nsIDOMNode> domNode;
11439:     accessibleEvent->GetDOMNode(getter_AddRefs(domNode));
13167:     PRUint32 eventType = nsAccEvent::EventType(accessibleEvent);
13167:     PRBool isFromUserInput = nsAccEvent::IsFromUserInput(accessibleEvent);
11439: 
11439:     if (domNode == gLastFocusedNode &&
15175:         (eventType == nsIAccessibleEvent::EVENT_ASYNCH_HIDE || 
15175:         eventType == nsIAccessibleEvent::EVENT_ASYNCH_SHOW)) {
11439:       // If frame type didn't change for this event, then we don't actually need to invalidate
11439:       // However, we only keep track of the old frame type for the focus, where it's very
11439:       // important not to destroy and recreate the accessible for minor style changes,
11439:       // such as a:focus { overflow: scroll; }
11439:       nsCOMPtr<nsIContent> focusContent(do_QueryInterface(domNode));
11439:       if (focusContent) {
11439:         nsIFrame *focusFrame = presShell->GetRealPrimaryFrameFor(focusContent);
11439:         nsIAtom *newFrameType =
11439:           (focusFrame && focusFrame->GetStyleVisibility()->IsVisible()) ?
11439:           focusFrame->GetType() : nsnull;
11439: 
11439:         if (newFrameType == gLastFocusedFrameType) {
11439:           // Don't need to invalidate this current accessible, but can
11439:           // just invalidate the children instead
11439:           FireShowHideEvents(domNode, PR_TRUE, eventType, PR_FALSE, isFromUserInput); 
11439:           continue;
11439:         }
11439:         gLastFocusedFrameType = newFrameType;
11439:       }
11439:     }
11439: 
 5395:     if (eventType == nsIAccessibleEvent::EVENT_DOM_CREATE || 
 5395:         eventType == nsIAccessibleEvent::EVENT_ASYNCH_SHOW) {
16650: 
 6411:       nsCOMPtr<nsIAccessible> containerAccessible;
16650:       if (accessible)
16650:         accessible->GetParent(getter_AddRefs(containerAccessible));
16650: 
16650:       if (!containerAccessible) {
16650:         GetAccessibleInParentChain(domNode, PR_TRUE,
16650:                                    getter_AddRefs(containerAccessible));
16650:         if (!containerAccessible)
16650:           containerAccessible = this;
16650:       }
16650: 
11165:       if (eventType == nsIAccessibleEvent::EVENT_ASYNCH_SHOW) {
10187:         // For asynch show, delayed invalidatation of parent's children
29320:         nsRefPtr<nsAccessible> containerAcc =
29320:           nsAccUtils::QueryAccessible(containerAccessible);
29320:         if (containerAcc)
29320:           containerAcc->InvalidateChildren();
16650: 
11165:         // Some show events in the subtree may have been removed to 
11165:         // avoid firing redundant events. But, we still need to make sure any
11165:         // accessibles parenting those shown nodes lose their child references.
11165:         InvalidateChildrenInSubtree(domNode);
11165:       }
 6411: 
 5395:       // Also fire text changes if the node being created could affect the text in an nsIAccessibleText parent.
 5395:       // When a node is being made visible or is inserted, the text in an ancestor hyper text will gain characters
 5395:       // At this point we now have the frame and accessible for this node if there is one. That is why we
 5395:       // wait to fire this here, instead of in InvalidateCacheSubtree(), where we wouldn't be able to calculate
 5395:       // the offset, length and text for the text change.
 5395:       if (domNode && domNode != mDOMNode) {
 5395:         nsCOMPtr<nsIAccessibleTextChangeEvent> textChangeEvent =
 5395:           CreateTextChangeEventForNode(containerAccessible, domNode, accessible, PR_TRUE, PR_TRUE);
 5395:         if (textChangeEvent) {
11858:           nsAccEvent::PrepareForEvent(textChangeEvent, isFromUserInput);
 5395:           // XXX Queue them up and merge the text change events
 5395:           // XXX We need a way to ignore SplitNode and JoinNode() when they
 5395:           // do not affect the text within the hypertext
 5395:           FireAccessibleEvent(textChangeEvent);
 5395:         }
 5395:       }
 6700: 
 6700:       // Fire show/create events for this node or first accessible descendants of it
11439:       FireShowHideEvents(domNode, PR_FALSE, eventType, PR_FALSE, isFromUserInput); 
 6700:       continue;
 5395:     }
 5395: 
 5395:     if (accessible) {
    1:       if (eventType == nsIAccessibleEvent::EVENT_INTERNAL_LOAD) {
29564:         nsRefPtr<nsDocAccessible> docAcc =
29564:           nsAccUtils::QueryAccessibleDocument(accessible);
29564:         NS_ASSERTION(docAcc, "No doc accessible for doc load event");
29564: 
29564:         if (docAcc)
29564:           docAcc->FireDocLoadEvents(nsIAccessibleEvent::EVENT_DOCUMENT_LOAD_COMPLETE);
    1:       }
  329:       else if (eventType == nsIAccessibleEvent::EVENT_TEXT_CARET_MOVED) {
    1:         nsCOMPtr<nsIAccessibleText> accessibleText = do_QueryInterface(accessible);
    1:         PRInt32 caretOffset;
    1:         if (accessibleText && NS_SUCCEEDED(accessibleText->GetCaretOffset(&caretOffset))) {
 4750: #ifdef DEBUG_A11Y
 3451:           PRUnichar chAtOffset;
 3451:           accessibleText->GetCharacterAtOffset(caretOffset, &chAtOffset);
 3451:           printf("\nCaret moved to %d with char %c", caretOffset, chAtOffset);
 3451: #endif
 8862: #ifdef DEBUG_CARET
 8862:           // Test caret line # -- fire an EVENT_ALERT on the focused node so we can watch the
 8862:           // line-number object attribute on it
 8862:           nsCOMPtr<nsIAccessible> accForFocus;
 8862:           GetAccService()->GetAccessibleFor(gLastFocusedNode, getter_AddRefs(accForFocus));
20536:           nsAccUtils::FireAccEvent(nsIAccessibleEvent::EVENT_ALERT, accForFocus);
 8862: #endif
 2688:           nsCOMPtr<nsIAccessibleCaretMoveEvent> caretMoveEvent =
 2688:             new nsAccCaretMoveEvent(accessible, caretOffset);
15262:           if (!caretMoveEvent)
15262:             break; // Out of memory, break out to release kung fu death grip
 2688: 
 2688:           FireAccessibleEvent(caretMoveEvent);
 2688: 
    1:           PRInt32 selectionCount;
    1:           accessibleText->GetSelectionCount(&selectionCount);
    1:           if (selectionCount) {  // There's a selection so fire selection change as well
20536:             nsAccUtils::FireAccEvent(nsIAccessibleEvent::EVENT_TEXT_SELECTION_CHANGED,
 4516:                                      accessible, PR_TRUE);
    1:           }
    1:         } 
    1:       }
24654:       else if (eventType == nsIAccessibleEvent::EVENT_REORDER) {
24654:         // Fire reorder event if it's unconditional (see InvalidateCacheSubtree
24654:         // method) or if changed node (that is the reason of this reorder event)
24654:         // is accessible or has accessible children.
24675:         nsCOMPtr<nsAccReorderEvent> reorderEvent = do_QueryInterface(accessibleEvent);
24654:         if (reorderEvent->IsUnconditionalEvent() ||
24654:             reorderEvent->HasAccessibleInReasonSubtree()) {
24654:           nsAccEvent::PrepareForEvent(accessibleEvent);
24654:           FireAccessibleEvent(accessibleEvent);
24654:         }
24654:       }
    1:       else {
 4516:         // The input state was previously stored with the nsIAccessibleEvent,
 4516:         // so use that state now when firing the event
 4516:         nsAccEvent::PrepareForEvent(accessibleEvent);
  577:         FireAccessibleEvent(accessibleEvent);
 4637:         // Post event processing
 4637:         if (eventType == nsIAccessibleEvent::EVENT_ASYNCH_HIDE ||
 4637:             eventType == nsIAccessibleEvent::EVENT_DOM_DESTROY) {
 4637:           // Shutdown nsIAccessNode's or nsIAccessibles for any DOM nodes in this subtree
 4637:           nsCOMPtr<nsIDOMNode> hidingNode;
 4637:           accessibleEvent->GetDOMNode(getter_AddRefs(hidingNode));
 4637:           if (hidingNode) {
 4637:             RefreshNodes(hidingNode); // Will this bite us with asynch events
 4637:           }
 4637:         }
    1:       }
    1:     }
    1:   }
    1:   mEventsToFire.Clear(); // Clear out array
 9691:   NS_RELEASE_THIS(); // Release kung fu death grip
11858: 
11858:   // After a flood of events, reset so that user input flag is off
11858:   nsAccEvent::ResetLastInputState();
11858: 
15262:   mInFlushPendingEvents = PR_FALSE;
    1: }
    1: 
    1: void nsDocAccessible::FlushEventsCallback(nsITimer *aTimer, void *aClosure)
    1: {
29564:   nsDocAccessible *accessibleDoc = static_cast<nsDocAccessible*>(aClosure);
    1:   NS_ASSERTION(accessibleDoc, "How did we get here without an accessible document?");
 9691:   if (accessibleDoc) {
 9691:     // A lot of crashes were happening here, so now we're reffing the doc
 9691:     // now until the events are flushed
    1:     accessibleDoc->FlushPendingEvents();
    1:   }
 9691: }
    1: 
11165: void nsDocAccessible::InvalidateChildrenInSubtree(nsIDOMNode *aStartNode)
11165: {
11165:   nsCOMPtr<nsIAccessNode> accessNode;
11165:   GetCachedAccessNode(aStartNode, getter_AddRefs(accessNode));
29320:   nsRefPtr<nsAccessible> acc(nsAccUtils::QueryAccessible(accessNode));
29320:   if (acc)
29320:     acc->InvalidateChildren();
11165: 
11165:   // Invalidate accessible children in the DOM subtree 
11165:   nsCOMPtr<nsINode> node = do_QueryInterface(aStartNode);
11165:   PRInt32 index, numChildren = node->GetChildCount();
11165:   for (index = 0; index < numChildren; index ++) {
11165:     nsCOMPtr<nsIDOMNode> childNode = do_QueryInterface(node->GetChildAt(index));
11165:     if (childNode)
11165:       InvalidateChildrenInSubtree(childNode);
11165:   }
11165: }
11165: 
 4516: void nsDocAccessible::RefreshNodes(nsIDOMNode *aStartNode)
    1: {
10580:   if (mAccessNodeCache.Count() <= 1) {
10580:     return; // All we have is a doc accessible. There is nothing to invalidate, quit early
10580:   }
10580: 
    1:   nsCOMPtr<nsIAccessNode> accessNode;
 8231:   GetCachedAccessNode(aStartNode, getter_AddRefs(accessNode));
    1: 
 8231:   // Shut down accessible subtree, which may have been created for
 8231:   // anonymous content subtree
 8231:   nsCOMPtr<nsIAccessible> accessible(do_QueryInterface(accessNode));
 8231:   if (accessible) {
10625:     // Fire menupopup end if a menu goes away
20566:     PRUint32 role = nsAccUtils::Role(accessible);
10625:     if (role == nsIAccessibleRole::ROLE_MENUPOPUP) {
10625:       nsCOMPtr<nsIDOMNode> domNode;
10625:       accessNode->GetDOMNode(getter_AddRefs(domNode));
10625:       nsCOMPtr<nsIDOMXULPopupElement> popup(do_QueryInterface(domNode));
10625:       if (!popup) {
10625:         // Popup elements already fire these via DOMMenuInactive
10625:         // handling in nsRootAccessible::HandleEvent
20536:         nsAccUtils::FireAccEvent(nsIAccessibleEvent::EVENT_MENUPOPUP_END,
10625:                                  accessible);
10625:       }
10625:     }
29320:     nsRefPtr<nsAccessible> acc = nsAccUtils::QueryAccessible(accessible);
 8231: 
29320:     // We only need to shutdown the accessibles here if one of them has been
29320:     // created.
29320:     nsCOMPtr<nsIAccessible> childAccessible = acc->GetCachedFirstChild();
 8231:     if (childAccessible) {
 8231:       nsCOMPtr<nsIArray> children;
 8231:       // use GetChildren() to fetch children at one time, instead of using
 8231:       // GetNextSibling(), because after we shutdown the first child,
 8231:       // mNextSibling will be set null.
 8231:       accessible->GetChildren(getter_AddRefs(children));
10871:       PRUint32 childCount =0;
10871:       if (children)
 8231:         children->GetLength(&childCount);
10625:       nsCOMPtr<nsIDOMNode> possibleAnonNode;
 8231:       for (PRUint32 index = 0; index < childCount; index++) {
 8231:         nsCOMPtr<nsIAccessNode> childAccessNode;
 8231:         children->QueryElementAt(index, NS_GET_IID(nsIAccessNode),
 8231:                                  getter_AddRefs(childAccessNode));
10625:         childAccessNode->GetDOMNode(getter_AddRefs(possibleAnonNode));
10625:         nsCOMPtr<nsIContent> iterContent = do_QueryInterface(possibleAnonNode);
16126:         if (iterContent && iterContent->IsInAnonymousSubtree()) {
16126:           // IsInAnonymousSubtree() check is a perf win -- make sure we don't
 8231:           // shut down the same subtree twice since we'll reach non-anon content via
 8231:           // DOM traversal later in this method
10625:           RefreshNodes(possibleAnonNode);
10625:         }
 8231:       }
 8231:     }
 8231:   }
10533: 
10533:   // Shutdown ordinary content subtree as well -- there may be
10533:   // access node children which are not full accessible objects
10625:   nsCOMPtr<nsIDOMNode> nextNode, iterNode;
10533:   aStartNode->GetFirstChild(getter_AddRefs(nextNode));
10533:   while (nextNode) {
10533:     nextNode.swap(iterNode);
10533:     RefreshNodes(iterNode);
10533:     iterNode->GetNextSibling(getter_AddRefs(nextNode));
10533:   }
10533: 
10625:   if (!accessNode)
10625:     return;
10625: 
10580:   if (accessNode == this) {
10580:     // Don't shutdown our doc object -- this may just be from the finished loading.
10580:     // We will completely shut it down when the pagehide event is received
10580:     // However, we must invalidate the doc accessible's children in order to be sure
10580:     // all pointers to them are correct
10580:     InvalidateChildren();
10580:     return;
10580:   }
10625: 
 8231:   // Shut down the actual accessible or access node
10533:   void *uniqueID;
10533:   accessNode->GetUniqueID(&uniqueID);
21169:   nsRefPtr<nsAccessNode> accNode = nsAccUtils::QueryAccessNode(accessNode);
21169:   accNode->Shutdown();
10625: 
    1:   // Remove from hash table as well
    1:   mAccessNodeCache.Remove(uniqueID);
    1: }
 8093: 
29564: void
29564: nsDocAccessible::InvalidateCacheSubtree(nsIContent *aChild,
    1:                                         PRUint32 aChangeEventType)
    1: {
 4516:   PRBool isHiding = 
 4516:     aChangeEventType == nsIAccessibleEvent::EVENT_ASYNCH_HIDE ||
 4516:     aChangeEventType == nsIAccessibleEvent::EVENT_DOM_DESTROY;
 4516: 
 4516:   PRBool isShowing = 
 4516:     aChangeEventType == nsIAccessibleEvent::EVENT_ASYNCH_SHOW ||
 4516:     aChangeEventType == nsIAccessibleEvent::EVENT_DOM_CREATE;
 4516: 
 4516:   PRBool isChanging = 
 4516:     aChangeEventType == nsIAccessibleEvent::EVENT_DOM_SIGNIFICANT_CHANGE ||
 4516:     aChangeEventType == nsIAccessibleEvent::EVENT_ASYNCH_SIGNIFICANT_CHANGE;
 4516: 
 4516:   NS_ASSERTION(isChanging || isHiding || isShowing,
    1:                "Incorrect aChangeEventType passed in");
    1: 
 4516:   PRBool isAsynch = 
 4516:     aChangeEventType == nsIAccessibleEvent::EVENT_ASYNCH_HIDE ||
 4516:     aChangeEventType == nsIAccessibleEvent::EVENT_ASYNCH_SHOW ||
 4516:     aChangeEventType == nsIAccessibleEvent::EVENT_ASYNCH_SIGNIFICANT_CHANGE;
 4516: 
    1:   // Invalidate cache subtree
    1:   // We have to check for accessibles for each dom node by traversing DOM tree
    1:   // instead of just the accessible tree, although that would be faster
    1:   // Otherwise we might miss the nsAccessNode's that are not nsAccessible's.
    1: 
29564:   NS_ENSURE_TRUE(mDOMNode,);
29564: 
    1:   nsCOMPtr<nsIDOMNode> childNode = aChild ? do_QueryInterface(aChild) : mDOMNode;
 6700: 
 8729:   nsCOMPtr<nsIPresShell> presShell = GetPresShell();
29564:   NS_ENSURE_TRUE(presShell,);
 8729:   
 6486:   if (!mIsContentLoaded) {
 6486:     // Still loading document
 6486:     if (mAccessNodeCache.Count() <= 1) {
 2707:       // Still loading and no accessibles has yet been created other than this
 2707:       // doc accessible. In this case we optimize
 2707:       // by not firing SHOW/HIDE/REORDER events for every document mutation
 2707:       // caused by page load, since AT is not going to want to grab the
 2707:       // document and listen to these changes until after the page is first loaded
 2707:       // Leave early, and ensure mAccChildCount stays uninitialized instead of 0,
 2707:       // which it is if anyone asks for its children right now.
29320:       InvalidateChildren();
29564:       return;
    1:     }
29564: 
 6486:     nsIEventStateManager *esm = presShell->GetPresContext()->EventStateManager();
29564:     NS_ENSURE_TRUE(esm,);
29564: 
 6486:     if (!esm->IsHandlingUserInputExternal()) {
10591:       // Changes during page load, but not caused by user input
 6486:       // Just invalidate accessible hierarchy and return,
 6486:       // otherwise the page load time slows down way too much
 6486:       nsCOMPtr<nsIAccessible> containerAccessible;
 6486:       GetAccessibleInParentChain(childNode, PR_FALSE, getter_AddRefs(containerAccessible));
 6486:       if (!containerAccessible) {
 6486:         containerAccessible = this;
 6486:       }
29320: 
29320:       nsRefPtr<nsAccessible> containerAcc =
29320:         nsAccUtils::QueryAccessible(containerAccessible);
29320:       containerAcc->InvalidateChildren();
29564:       return;
 6486:     }     
 6486:     // else: user input, so we must fall through and for full handling,
 6486:     // e.g. fire the mutation events. Note: user input could cause DOM_CREATE
 6486:     // during page load if user typed into an input field or contentEditable area
 6486:   }
    1: 
 4516:   // Update last change state information
    1:   nsCOMPtr<nsIAccessNode> childAccessNode;
    1:   GetCachedAccessNode(childNode, getter_AddRefs(childAccessNode));
    1:   nsCOMPtr<nsIAccessible> childAccessible = do_QueryInterface(childAccessNode);
 2950: 
    1: #ifdef DEBUG_A11Y
    1:   nsAutoString localName;
    1:   childNode->GetLocalName(localName);
    1:   const char *hasAccessible = childAccessible ? " (acc)" : "";
 4516:   if (aChangeEventType == nsIAccessibleEvent::EVENT_ASYNCH_HIDE) {
    1:     printf("[Hide %s %s]\n", NS_ConvertUTF16toUTF8(localName).get(), hasAccessible);
    1:   }
 4516:   else if (aChangeEventType == nsIAccessibleEvent::EVENT_ASYNCH_SHOW) {
    1:     printf("[Show %s %s]\n", NS_ConvertUTF16toUTF8(localName).get(), hasAccessible);
    1:   }
 4516:   else if (aChangeEventType == nsIAccessibleEvent::EVENT_ASYNCH_SIGNIFICANT_CHANGE) {
 4516:     printf("[Layout change %s %s]\n", NS_ConvertUTF16toUTF8(localName).get(), hasAccessible);
 4516:   }
 4516:   else if (aChangeEventType == nsIAccessibleEvent::EVENT_DOM_CREATE) {
 4516:     printf("[Create %s %s]\n", NS_ConvertUTF16toUTF8(localName).get(), hasAccessible);
 4516:   }
 4516:   else if (aChangeEventType == nsIAccessibleEvent::EVENT_DOM_DESTROY) {
 4516:     printf("[Destroy  %s %s]\n", NS_ConvertUTF16toUTF8(localName).get(), hasAccessible);
 4516:   }
 4516:   else if (aChangeEventType == nsIAccessibleEvent::EVENT_DOM_SIGNIFICANT_CHANGE) {
 4516:     printf("[Type change %s %s]\n", NS_ConvertUTF16toUTF8(localName).get(), hasAccessible);
    1:   }
    1: #endif
    1: 
 5395:   nsCOMPtr<nsIAccessible> containerAccessible;
 6486:   GetAccessibleInParentChain(childNode, PR_TRUE, getter_AddRefs(containerAccessible));
 5395:   if (!containerAccessible) {
 5395:     containerAccessible = this;
 5395:   }
 5395: 
 4516:   if (!isShowing) {
 6700:     // Fire EVENT_ASYNCH_HIDE or EVENT_DOM_DESTROY
 8729:     if (isHiding) {
 6700:       nsCOMPtr<nsIContent> content(do_QueryInterface(childNode));
 6700:       if (content) {
 6700:         nsIFrame *frame = presShell->GetPrimaryFrameFor(content);
 6700:         if (frame) {
 6700:           nsIFrame *frameParent = frame->GetParent();
 6700:           if (!frameParent || !frameParent->GetStyleVisibility()->IsVisible()) {
 6700:             // Ancestor already hidden or being hidden at the same time:
 6700:             // don't process redundant hide event
 6700:             // This often happens when visibility is cleared for node,
 6700:             // which hides an entire subtree -- we get notified for each
 6700:             // node in the subtree and need to collate the hide events ourselves.
29564:             return;
 6700:           }
 6700:         }
 6700:       }
 6700:     }
 6700: 
 4637:     PRUint32 removalEventType = isAsynch ? nsIAccessibleEvent::EVENT_ASYNCH_HIDE :
 4637:                                            nsIAccessibleEvent::EVENT_DOM_DESTROY;
 6700: 
 6700:     // Fire an event if the accessible existed for node being hidden, otherwise
 6700:     // for the first line accessible descendants. Fire before the accessible(s) away.
11439:     nsresult rv = FireShowHideEvents(childNode, PR_FALSE, removalEventType, PR_TRUE, PR_FALSE);
29564:     NS_ENSURE_SUCCESS(rv,);
29564: 
 5395:     if (childNode != mDOMNode) { // Fire text change unless the node being removed is for this doc
 5395:       // When a node is hidden or removed, the text in an ancestor hyper text will lose characters
 5395:       // At this point we still have the frame and accessible for this node if there was one
 5395:       // XXX Collate events when a range is deleted
 5395:       // XXX We need a way to ignore SplitNode and JoinNode() when they
 5395:       // do not affect the text within the hypertext
 5395:       nsCOMPtr<nsIAccessibleTextChangeEvent> textChangeEvent =
 5395:         CreateTextChangeEventForNode(containerAccessible, childNode, childAccessible,
 5395:                                      PR_FALSE, isAsynch);
 5395:       if (textChangeEvent) {
 5395:         FireAccessibleEvent(textChangeEvent);
 5395:       }
 5395:     }
    1:   }
    1: 
    1:   // We need to get an accessible for the mutation event's container node
    1:   // If there is no accessible for that node, we need to keep moving up the parent
    1:   // chain so there is some accessible.
    1:   // We will use this accessible to fire the accessible mutation event.
    1:   // We're guaranteed success, because we will eventually end up at the doc accessible,
    1:   // and there is always one of those.
    1: 
 5395:   if (aChild && !isHiding) {
10187:     if (!isAsynch) {
10187:       // DOM already updated with new objects -- invalidate parent's children now
10187:       // For asynch we must wait until layout updates before we invalidate the children
29320:       nsRefPtr<nsAccessible> containerAcc =
29320:         nsAccUtils::QueryAccessible(containerAccessible);
29320:       if (containerAcc)
29320:         containerAcc->InvalidateChildren();
29320: 
10187:     }
  329:     // Fire EVENT_SHOW, EVENT_MENUPOPUP_START for newly visible content.
    1:     // Fire after a short timer, because we want to make sure the view has been
    1:     // updated to make this accessible content visible. If we don't wait,
    1:     // the assistive technology may receive the event and then retrieve
    1:     // nsIAccessibleStates::STATE_INVISIBLE for the event's accessible object.
 4516:     PRUint32 additionEvent = isAsynch ? nsIAccessibleEvent::EVENT_ASYNCH_SHOW :
 4516:                                         nsIAccessibleEvent::EVENT_DOM_CREATE;
10375:     FireDelayedToolkitEvent(additionEvent, childNode,
13167:                             nsAccEvent::eCoalesceFromSameSubtree,
13167:                             isAsynch);
 4516: 
11616:     // Check to see change occured in an ARIA menu, and fire
11616:     // an EVENT_MENUPOPUP_START if it did.
20536:     nsRoleMapEntry *roleMapEntry = nsAccUtils::GetRoleMapEntry(childNode);
 8742:     if (roleMapEntry && roleMapEntry->role == nsIAccessibleRole::ROLE_MENUPOPUP) {
  329:       FireDelayedToolkitEvent(nsIAccessibleEvent::EVENT_MENUPOPUP_START,
13167:                               childNode, nsAccEvent::eRemoveDupes,
13167:                               isAsynch);
    1:     }
    1: 
    1:     // Check to see if change occured inside an alert, and fire an EVENT_ALERT if it did
    1:     nsIContent *ancestor = aChild;
 8742:     while (PR_TRUE) {
 8742:       if (roleMapEntry && roleMapEntry->role == nsIAccessibleRole::ROLE_ALERT) {
    1:         nsCOMPtr<nsIDOMNode> alertNode(do_QueryInterface(ancestor));
10375:         FireDelayedToolkitEvent(nsIAccessibleEvent::EVENT_ALERT, alertNode,
13167:                                 nsAccEvent::eRemoveDupes, isAsynch);
    1:         break;
    1:       }
    1:       ancestor = ancestor->GetParent();
 8742:       nsCOMPtr<nsIDOMNode> ancestorNode = do_QueryInterface(ancestor);
 8742:       if (!ancestorNode) {
 8742:         break;
 8742:       }
20536:       roleMapEntry = nsAccUtils::GetRoleMapEntry(ancestorNode);
    1:     }
    1:   }
    1: 
13353:   FireValueChangeForTextFields(containerAccessible);
13353: 
15720:   // Fire an event so the MSAA clients know the children have changed. Also
15720:   // the event is used internally by MSAA part.
24654: 
24656:   // We need to fire a delayed reorder event for the accessible parent of the
24656:   // changed node. We fire an unconditional reorder event if the changed node or
24656:   // one of its children is already accessible. In the case of show events, the
24656:   // accessible object might not be created yet for an otherwise accessible
24656:   // changed node (because its frame might not be constructed yet). In this case
24656:   // we fire a conditional reorder event, so that we will later check whether
24656:   // the changed node is accessible or has accessible children.
24656:   // Filtering/coalescing of these events happens during the queue flush.
24654: 
24654:   PRBool isUnconditionalEvent = childAccessible ||
24654:     aChild && nsAccUtils::HasAccessibleChildren(childNode);
24654: 
 4684:   nsCOMPtr<nsIAccessibleEvent> reorderEvent =
24654:     new nsAccReorderEvent(containerAccessible, isAsynch,
24654:                           isUnconditionalEvent,
24667:                           aChild ? childNode.get() : nsnull);
29564:   NS_ENSURE_TRUE(reorderEvent,);
24654: 
13167:   FireDelayedAccessibleEvent(reorderEvent);
    1: }
    1: 
    1: NS_IMETHODIMP
 2707: nsDocAccessible::GetAccessibleInParentChain(nsIDOMNode *aNode,
 6486:                                             PRBool aCanCreate,
    1:                                             nsIAccessible **aAccessible)
    1: {
    1:   // Find accessible in parent chain of DOM nodes, or return null
    1:   *aAccessible = nsnull;
    1:   nsCOMPtr<nsIDOMNode> currentNode(aNode), parentNode;
    1:   nsCOMPtr<nsIAccessNode> accessNode;
    1: 
    1:   nsIAccessibilityService *accService = GetAccService();
    1:   NS_ENSURE_TRUE(accService, NS_ERROR_FAILURE);
    1: 
    1:   do {
    1:     currentNode->GetParentNode(getter_AddRefs(parentNode));
    1:     currentNode = parentNode;
    1:     if (!currentNode) {
    1:       NS_ADDREF_THIS();
    1:       *aAccessible = this;
    1:       break;
    1:     }
    1: 
    1:     nsCOMPtr<nsIDOMNode> relevantNode;
    1:     if (NS_SUCCEEDED(accService->GetRelevantContentNodeFor(currentNode, getter_AddRefs(relevantNode))) && relevantNode) {
    1:       currentNode = relevantNode;
    1:     }
 8230:     if (aCanCreate) {
 8230:       accService->GetAccessibleInWeakShell(currentNode, mWeakShell, aAccessible);
 8230:     }
 8230:     else { // Only return cached accessibles, don't create anything
 6486:       nsCOMPtr<nsIAccessNode> accessNode;
 6486:       GetCachedAccessNode(currentNode, getter_AddRefs(accessNode)); // AddRefs
 6486:       if (accessNode) {
 6486:         CallQueryInterface(accessNode, aAccessible); // AddRefs
 6486:       }
 6486:     }
    1:   } while (!*aAccessible);
    1: 
    1:   return NS_OK;
    1: }
    1: 
 6700: nsresult
11439: nsDocAccessible::FireShowHideEvents(nsIDOMNode *aDOMNode, PRBool aAvoidOnThisNode, PRUint32 aEventType,
 6700:                                     PRBool aDelay, PRBool aForceIsFromUserInput)
 6700: {
 6700:   NS_ENSURE_ARG(aDOMNode);
 6700: 
 6700:   nsCOMPtr<nsIAccessible> accessible;
11439:   if (!aAvoidOnThisNode) {
 6700:     if (aEventType == nsIAccessibleEvent::EVENT_ASYNCH_HIDE ||
 6700:         aEventType == nsIAccessibleEvent::EVENT_DOM_DESTROY) {
 6700:       // Don't allow creation for accessibles when nodes going away
 6700:       nsCOMPtr<nsIAccessNode> accessNode;
 6700:       GetCachedAccessNode(aDOMNode, getter_AddRefs(accessNode));
 6700:       accessible = do_QueryInterface(accessNode);
 6700:     } else {
 6700:       // Allow creation of new accessibles for show events
 6700:       GetAccService()->GetAttachedAccessibleFor(aDOMNode,
 6700:                                                 getter_AddRefs(accessible));
 6700:     }
11439:   }
 6700: 
 6700:   if (accessible) {
 6700:     // Found an accessible, so fire the show/hide on it and don't
 6700:     // look further into this subtree
 6700:     PRBool isAsynch = aEventType == nsIAccessibleEvent::EVENT_ASYNCH_HIDE ||
 6700:                       aEventType == nsIAccessibleEvent::EVENT_ASYNCH_SHOW;
 6700: 
 6700:     nsCOMPtr<nsIAccessibleEvent> event =
13167:       new nsAccEvent(aEventType, accessible, isAsynch,
13167:                      nsAccEvent::eCoalesceFromSameSubtree);
 6700:     NS_ENSURE_TRUE(event, NS_ERROR_OUT_OF_MEMORY);
 6700:     if (aForceIsFromUserInput) {
11858:       nsAccEvent::PrepareForEvent(event, aForceIsFromUserInput);
 6700:     }
 6700:     if (aDelay) {
13167:       return FireDelayedAccessibleEvent(event);
 6700:     }
 6700:     return FireAccessibleEvent(event);
 6700:   }
 6700: 
 6700:   // Could not find accessible to show hide yet, so fire on any
 6700:   // accessible descendants in this subtree
14606:   nsCOMPtr<nsINode> node(do_QueryInterface(aDOMNode));
14606:   PRUint32 count = node->GetChildCount();
 6700:   for (PRUint32 index = 0; index < count; index++) {
14606:     nsCOMPtr<nsIDOMNode> childNode = do_QueryInterface(node->GetChildAt(index));
11439:     nsresult rv = FireShowHideEvents(childNode, PR_FALSE, aEventType,
 6700:                                      aDelay, aForceIsFromUserInput);
 6700:     NS_ENSURE_SUCCESS(rv, rv);
 6700:   }
 6700: 
 6700:   return NS_OK;
 6700: }
