52560: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52560:  * vim: set ts=4 sw=4 et tw=99:
52560:  *
52560:  * ***** BEGIN LICENSE BLOCK *****
52560:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52560:  *
52560:  * The contents of this file are subject to the Mozilla Public License Version
52560:  * 1.1 (the "License"); you may not use this file except in compliance with
52560:  * the License. You may obtain a copy of the License at
52560:  * http://www.mozilla.org/MPL/
52560:  *
52560:  * Software distributed under the License is distributed on an "AS IS" basis,
52560:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52560:  * for the specific language governing rights and limitations under the
52560:  * License.
52560:  *
52560:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52560:  * May 28, 2008.
52560:  *
52560:  * The Initial Developer of the Original Code is
52560:  *   Brendan Eich <brendan@mozilla.org>
52560:  *
52560:  * Contributor(s):
52560:  *   David Anderson <danderson@mozilla.com>
52560:  *
52560:  * Alternatively, the contents of this file may be used under the terms of
52560:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52560:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52560:  * in which case the provisions of the GPL or the LGPL are applicable instead
52560:  * of those above. If you wish to allow use of your version of this file only
52560:  * under the terms of either the GPL or the LGPL, and not to allow others to
52560:  * use your version of this file under the terms of the MPL, indicate your
52560:  * decision by deleting the provisions above and replace them with the notice
52560:  * and other provisions required by the GPL or the LGPL. If you do not delete
52560:  * the provisions above, a recipient may use your version of this file under
52560:  * the terms of any one of the MPL, the GPL or the LGPL.
52560:  *
52560:  * ***** END LICENSE BLOCK ***** */
52560: 
52560: #if !defined jsjaeger_regstate_h__ && defined JS_METHODJIT
52560: #define jsjaeger_regstate_h__
52560: 
80468: #include "mozilla/Util.h"
80468: 
52560: #include "assembler/assembler/MacroAssembler.h"
52560: 
52560: namespace js {
52560: 
52560: namespace mjit {
52560: 
77343: /* Common handling for both general purpose and floating point registers. */
77343: 
77343: struct AnyRegisterID {
77343:     unsigned reg_;
77343: 
77343:     AnyRegisterID()
77343:         : reg_((unsigned)-1)
77343:     { pin(); }
77343: 
77343:     AnyRegisterID(const AnyRegisterID &o)
77343:         : reg_(o.reg_)
77343:     { pin(); }
77343: 
77343:     AnyRegisterID(JSC::MacroAssembler::RegisterID reg)
77343:         : reg_((unsigned)reg)
77343:     { pin(); }
77343: 
77343:     AnyRegisterID(JSC::MacroAssembler::FPRegisterID reg)
77343:         : reg_(JSC::MacroAssembler::TotalRegisters + (unsigned)reg)
77343:     { pin(); }
77343: 
77343:     static inline AnyRegisterID fromRaw(unsigned reg);
77343: 
77343:     inline JSC::MacroAssembler::RegisterID reg();
77343:     inline JSC::MacroAssembler::FPRegisterID fpreg();
77343: 
77344:     bool isSet() { return reg_ != unsigned(-1); }
77343:     bool isReg() { return reg_ < JSC::MacroAssembler::TotalRegisters; }
77344:     bool isFPReg() { return isSet() && !isReg(); }
77343: 
77343:     inline const char * name();
77343: 
77343:   private:
77343:     unsigned * pin() {
77343:         /*
77343:          * Workaround for apparent compiler bug in GCC 4.2. If GCC thinks that reg_
77343:          * cannot escape then it compiles isReg() and other accesses to reg_ incorrectly.
77343:          */
77343:         static unsigned *v;
77343:         v = &reg_;
77343:         return v;
77343:     }
77343: };
77343: 
52560: struct Registers {
77343: 
77343:     /* General purpose registers. */
77343: 
84755:     static const uint32_t TotalRegisters = JSC::MacroAssembler::TotalRegisters;
77343: 
57766:     enum CallConvention {
57766:         NormalCall,
57766:         FastCall
57766:     };
52560: 
52560:     typedef JSC::MacroAssembler::RegisterID RegisterID;
52560: 
56575:     // Homed and scratch registers for working with Values on x64.
53162: #if defined(JS_CPU_X64)
53476:     static const RegisterID TypeMaskReg = JSC::X86Registers::r13;
53476:     static const RegisterID PayloadMaskReg = JSC::X86Registers::r14;
57716:     static const RegisterID ValueReg = JSC::X86Registers::r10;
68931:     static const RegisterID ScratchReg = JSC::X86Registers::r11;
53162: #endif
53162: 
77343:     // Register that homes the current JSStackFrame.
77343: #if defined(JS_CPU_X86)
77343:     static const RegisterID JSFrameReg = JSC::X86Registers::ebp;
77343: #elif defined(JS_CPU_X64)
56575:     static const RegisterID JSFrameReg = JSC::X86Registers::ebx;
56575: #elif defined(JS_CPU_ARM)
78455:     static const RegisterID JSFrameReg = JSC::ARMRegisters::r10;
68931: #elif defined(JS_CPU_SPARC)
68931:     static const RegisterID JSFrameReg = JSC::SparcRegisters::l0;
87250: #elif defined(JS_CPU_MIPS)
87250:     static const RegisterID JSFrameReg = JSC::MIPSRegisters::s0;
56575: #endif
56575: 
52608: #if defined(JS_CPU_X86) || defined(JS_CPU_X64)
52608:     static const RegisterID ReturnReg = JSC::X86Registers::eax;
64272: # if defined(JS_CPU_X86) || defined(_WIN64)
52608:     static const RegisterID ArgReg0 = JSC::X86Registers::ecx;
52608:     static const RegisterID ArgReg1 = JSC::X86Registers::edx;
53622: #  if defined(JS_CPU_X64)
53622:     static const RegisterID ArgReg2 = JSC::X86Registers::r8;
78457:     static const RegisterID ArgReg3 = JSC::X86Registers::r9;
53622: #  endif
52608: # else
52608:     static const RegisterID ArgReg0 = JSC::X86Registers::edi;
52608:     static const RegisterID ArgReg1 = JSC::X86Registers::esi;
53590:     static const RegisterID ArgReg2 = JSC::X86Registers::edx;
78457:     static const RegisterID ArgReg3 = JSC::X86Registers::ecx;
52608: # endif
52608: #elif JS_CPU_ARM
52608:     static const RegisterID ReturnReg = JSC::ARMRegisters::r0;
52608:     static const RegisterID ArgReg0 = JSC::ARMRegisters::r0;
52608:     static const RegisterID ArgReg1 = JSC::ARMRegisters::r1;
53590:     static const RegisterID ArgReg2 = JSC::ARMRegisters::r2;
68931: #elif JS_CPU_SPARC
68931:     static const RegisterID ReturnReg = JSC::SparcRegisters::o0;
68931:     static const RegisterID ArgReg0 = JSC::SparcRegisters::o0;
68931:     static const RegisterID ArgReg1 = JSC::SparcRegisters::o1;
68931:     static const RegisterID ArgReg2 = JSC::SparcRegisters::o2;
68931:     static const RegisterID ArgReg3 = JSC::SparcRegisters::o3;
68931:     static const RegisterID ArgReg4 = JSC::SparcRegisters::o4;
68931:     static const RegisterID ArgReg5 = JSC::SparcRegisters::o5;
87250: #elif JS_CPU_MIPS
87250:     static const RegisterID ReturnReg = JSC::MIPSRegisters::v0;
87250:     static const RegisterID ArgReg0 = JSC::MIPSRegisters::a0;
87250:     static const RegisterID ArgReg1 = JSC::MIPSRegisters::a1;
87250:     static const RegisterID ArgReg2 = JSC::MIPSRegisters::a2;
87250:     static const RegisterID ArgReg3 = JSC::MIPSRegisters::a3;
52608: #endif
52608: 
52645:     static const RegisterID StackPointer = JSC::MacroAssembler::stackPointerRegister;
52608: 
84755:     static inline uint32_t maskReg(RegisterID reg) {
52560:         return (1 << reg);
52560:     }
52560: 
84755:     static inline uint32_t mask2Regs(RegisterID reg1, RegisterID reg2) {
52560:         return maskReg(reg1) | maskReg(reg2);
52560:     }
52560: 
84755:     static inline uint32_t mask3Regs(RegisterID reg1, RegisterID reg2, RegisterID reg3) {
52560:         return maskReg(reg1) | maskReg(reg2) | maskReg(reg3);
52560:     }
52560: 
52560: #if defined(JS_CPU_X86) || defined(JS_CPU_X64)
84755:     static const uint32_t TempRegs =
52560:           (1 << JSC::X86Registers::eax)
77343: # if defined(JS_CPU_X86)
77343:         | (1 << JSC::X86Registers::ebx)
77343: # endif
52560:         | (1 << JSC::X86Registers::ecx)
52560:         | (1 << JSC::X86Registers::edx)
52560: # if defined(JS_CPU_X64)
52560:         | (1 << JSC::X86Registers::r8)
52560:         | (1 << JSC::X86Registers::r9)
64272: #  if !defined(_WIN64)
52560:         | (1 << JSC::X86Registers::esi)
52560:         | (1 << JSC::X86Registers::edi)
52560: #  endif
52560: # endif
52560:         ;
52560: 
52560: # if defined(JS_CPU_X64)
84755:     static const uint32_t SavedRegs =
53162:         /* r11 is scratchRegister, used by JSC. */
52560:           (1 << JSC::X86Registers::r12)
53476:     // r13 is TypeMaskReg.
53476:     // r14 is PayloadMaskReg.
57716:         | (1 << JSC::X86Registers::r15)
64272: #  if defined(_WIN64)
52560:         | (1 << JSC::X86Registers::esi)
52560:         | (1 << JSC::X86Registers::edi)
52560: #  endif
52560: # else
84755:     static const uint32_t SavedRegs =
52560:           (1 << JSC::X86Registers::esi)
52560:         | (1 << JSC::X86Registers::edi)
52560: # endif
52560:         ;
52560: 
60164: # if defined(JS_CPU_X86)
84755:     static const uint32_t SingleByteRegs = (TempRegs | SavedRegs) &
52560:         ~((1 << JSC::X86Registers::esi) |
52560:           (1 << JSC::X86Registers::edi) |
52560:           (1 << JSC::X86Registers::ebp) |
52560:           (1 << JSC::X86Registers::esp));
60164: # elif defined(JS_CPU_X64)
84755:     static const uint32_t SingleByteRegs = TempRegs | SavedRegs;
60164: # endif
52560: 
52560: #elif defined(JS_CPU_ARM)
84755:     static const uint32_t TempRegs =
52560:           (1 << JSC::ARMRegisters::r0)
52560:         | (1 << JSC::ARMRegisters::r1)
52560:         | (1 << JSC::ARMRegisters::r2);
53451:     // r3 is reserved as a scratch register for the assembler.
77343:     // r12 is IP, and is used for stub calls.
52560: 
84755:     static const uint32_t SavedRegs =
52560:           (1 << JSC::ARMRegisters::r4)
52560:         | (1 << JSC::ARMRegisters::r5)
52560:         | (1 << JSC::ARMRegisters::r6)
52560:         | (1 << JSC::ARMRegisters::r7)
53451:     // r8 is reserved as a scratch register for the assembler.
78455:         | (1 << JSC::ARMRegisters::r9);
78455:     // r10 is reserved for JSFrameReg.
53451:     // r13 is SP and must always point to VMFrame whilst in generated code.
53451:     // r14 is LR and is used for return sequences.
53451:     // r15 is PC (program counter).
52560: 
84755:     static const uint32_t SingleByteRegs = TempRegs | SavedRegs;
68931: #elif defined(JS_CPU_SPARC)
84755:     static const uint32_t TempRegs =
68931:           (1 << JSC::SparcRegisters::o0)
68931:         | (1 << JSC::SparcRegisters::o1)
68931:         | (1 << JSC::SparcRegisters::o2)
68931:         | (1 << JSC::SparcRegisters::o3)
68931:         | (1 << JSC::SparcRegisters::o4)
68931:         | (1 << JSC::SparcRegisters::o5);
68931: 
84755:     static const uint32_t SavedRegs =
68931:           (1 << JSC::SparcRegisters::l2)
68931:         | (1 << JSC::SparcRegisters::l3)
68931:         | (1 << JSC::SparcRegisters::l4)
68931:         | (1 << JSC::SparcRegisters::l5)
68931:         | (1 << JSC::SparcRegisters::l6)
77435:         | (1 << JSC::SparcRegisters::l7);
68931: 
84755:     static const uint32_t SingleByteRegs = TempRegs | SavedRegs;
87250: #elif defined(JS_CPU_MIPS)
87250:     static const uint32_t TempRegs =
87250:           (1 << JSC::MIPSRegisters::at)
87250:         | (1 << JSC::MIPSRegisters::v0)
87250:         | (1 << JSC::MIPSRegisters::v1)
87250:         | (1 << JSC::MIPSRegisters::a0)
87250:         | (1 << JSC::MIPSRegisters::a1)
87250:         | (1 << JSC::MIPSRegisters::a2)
87250:         | (1 << JSC::MIPSRegisters::a3)
87250:         | (1 << JSC::MIPSRegisters::t5)
87250:         | (1 << JSC::MIPSRegisters::t6)
87250:         | (1 << JSC::MIPSRegisters::t7);
87250:     /* t0-t4,t9 is reserved as a scratch register for the assembler.
87250:        We don't use t8 ($24), as we limit ourselves within $0 to $23 to
87250:        leave the bitmask for 8 FP registers. */
87250: 
87250:     static const uint32_t SavedRegs =
87250:           (1 << JSC::MIPSRegisters::s1)
87250:         | (1 << JSC::MIPSRegisters::s2)
87250:         | (1 << JSC::MIPSRegisters::s3)
87250:         | (1 << JSC::MIPSRegisters::s4)
87250:         | (1 << JSC::MIPSRegisters::s5)
87250:         | (1 << JSC::MIPSRegisters::s6)
87250:         | (1 << JSC::MIPSRegisters::s7);
87250:     // s0 is reserved for JSFrameReg.
87250: 
87250:     static const uint32_t SingleByteRegs = TempRegs | SavedRegs;
52560: #else
52560: # error "Unsupported platform"
52560: #endif
52560: 
84755:     static const uint32_t AvailRegs = SavedRegs | TempRegs;
52560: 
77343:     static bool isAvail(RegisterID reg) {
84755:         uint32_t mask = maskReg(reg);
77343:         return bool(mask & AvailRegs);
77343:     }
77343: 
57717:     static bool isSaved(RegisterID reg) {
84755:         uint32_t mask = maskReg(reg);
57717:         JS_ASSERT(mask & AvailRegs);
57717:         return bool(mask & SavedRegs);
57717:     }
57717: 
84755:     static inline uint32_t numArgRegs(CallConvention convention) {
57766: #if defined(JS_CPU_X86)
57766: # if defined(JS_NO_FASTCALL)
57766:         return 0;
57766: # else
57766:         return (convention == FastCall) ? 2 : 0;
57766: # endif
57766: #elif defined(JS_CPU_X64)
57766: # ifdef _WIN64
57766:         return 4;
57766: # else
57766:         return 6;
57766: # endif
57766: #elif defined(JS_CPU_ARM)
57766:         return 4;
68931: #elif defined(JS_CPU_SPARC)
68931:         return 6;
87250: #elif defined(JS_CPU_MIPS)
87250:         return 4;
57766: #endif
57766:     }
57766: 
84755:     static inline bool regForArg(CallConvention conv, uint32_t i, RegisterID *reg) {
57766: #if defined(JS_CPU_X86)
57766:         static const RegisterID regs[] = {
57766:             JSC::X86Registers::ecx,
57766:             JSC::X86Registers::edx
57766:         };
57766: 
57766: # if defined(JS_NO_FASTCALL)
57766:         return false;
57766: # else
57766:         if (conv == NormalCall)
57766:             return false;
57766: # endif
57766: #elif defined(JS_CPU_X64)
57766: # ifdef _WIN64
57766:         static const RegisterID regs[] = {
57766:             JSC::X86Registers::ecx,
57766:             JSC::X86Registers::edx,
57766:             JSC::X86Registers::r8,
57766:             JSC::X86Registers::r9
57766:         };
57766: # else
57766:         static const RegisterID regs[] = {
57766:             JSC::X86Registers::edi,
57766:             JSC::X86Registers::esi,
57766:             JSC::X86Registers::edx,
57766:             JSC::X86Registers::ecx,
57766:             JSC::X86Registers::r8,
57766:             JSC::X86Registers::r9
57766:         };
57766: # endif
57766: #elif defined(JS_CPU_ARM)
57766:         static const RegisterID regs[] = {
57766:             JSC::ARMRegisters::r0,
57766:             JSC::ARMRegisters::r1,
57766:             JSC::ARMRegisters::r2,
57766:             JSC::ARMRegisters::r3
57766:         };
68931: #elif defined(JS_CPU_SPARC)
68931:         static const RegisterID regs[] = {
68931:             JSC::SparcRegisters::o0,
68931:             JSC::SparcRegisters::o1,
68931:             JSC::SparcRegisters::o2,
68931:             JSC::SparcRegisters::o3,
68931:             JSC::SparcRegisters::o4,
68931:             JSC::SparcRegisters::o5
68931:         };
87250: #elif defined(JS_CPU_MIPS)
87250:         static const RegisterID regs[] = {
87250:             JSC::MIPSRegisters::a0,
87250:             JSC::MIPSRegisters::a1,
87250:             JSC::MIPSRegisters::a2,
87250:             JSC::MIPSRegisters::a3,
87250:         };
57766: #endif
80468:         JS_ASSERT(numArgRegs(conv) == mozilla::ArrayLength(regs));
80468:         if (i > mozilla::ArrayLength(regs))
57766:             return false;
57766:         *reg = regs[i];
57766:         return true;
57766:     }
57766: 
77343:     /* Floating point registers. */
77343: 
77343:     typedef JSC::MacroAssembler::FPRegisterID FPRegisterID;
77343: 
77343: #if defined(JS_CPU_X86) || defined(JS_CPU_X64)
77394: #ifdef _WIN64
77394:     /* xmm0-xmm5 are scratch register on Win64 ABI */
84755:     static const uint32_t TotalFPRegisters = 5;
77394:     static const FPRegisterID FPConversionTemp = JSC::X86Registers::xmm5;
77394: #else
84755:     static const uint32_t TotalFPRegisters = 7;
77394:     static const FPRegisterID FPConversionTemp = JSC::X86Registers::xmm7;
77394: #endif
84755:     static const uint32_t TempFPRegs = (
77343:           (1 << JSC::X86Registers::xmm0)
77343:         | (1 << JSC::X86Registers::xmm1)
77343:         | (1 << JSC::X86Registers::xmm2)
77343:         | (1 << JSC::X86Registers::xmm3)
77343:         | (1 << JSC::X86Registers::xmm4)
77394: #ifndef _WIN64
77343:         | (1 << JSC::X86Registers::xmm5)
77343:         | (1 << JSC::X86Registers::xmm6)
77394: #endif
77343:         ) << TotalRegisters;
77343: #elif defined(JS_CPU_ARM)
84755:     static const uint32_t TotalFPRegisters = 3;
84755:     static const uint32_t TempFPRegs = (
77343:           (1 << JSC::ARMRegisters::d0)
77343:         | (1 << JSC::ARMRegisters::d1)
77343:         | (1 << JSC::ARMRegisters::d2)
77343:         ) << TotalRegisters;
77343:     static const FPRegisterID FPConversionTemp = JSC::ARMRegisters::d3;
77343: #elif defined(JS_CPU_SPARC)
84755:     static const uint32_t TotalFPRegisters = 8;
84755:     static const uint32_t TempFPRegs = (uint32_t)(
77435:           (1 << JSC::SparcRegisters::f0)
77435:         | (1 << JSC::SparcRegisters::f2)
77343:         | (1 << JSC::SparcRegisters::f4)
77343:         | (1 << JSC::SparcRegisters::f6)
77435:         ) << TotalRegisters;
77435:     static const FPRegisterID FPConversionTemp = JSC::SparcRegisters::f8;
87250: #elif defined(JS_CPU_MIPS)
87250:     /* TotalRegisters is 24, so TotalFPRegisters can be 8 to have a 32-bit
87250:        bit mask.
87250:        Note that the O32 ABI can access only even FP registers. */
87250:     static const uint32_t TotalFPRegisters = 8;
87250:     static const uint32_t TempFPRegs = (uint32_t)(
87250:           (1 << JSC::MIPSRegisters::f0)
87250:         | (1 << JSC::MIPSRegisters::f2)
87250:         | (1 << JSC::MIPSRegisters::f4)
87250:         | (1 << JSC::MIPSRegisters::f6)
87250:         ) << TotalRegisters;
87250:     // f16 is reserved as a scratch register for the assembler.
87250:     static const FPRegisterID FPConversionTemp = JSC::MIPSRegisters::f18;
77343: #else
77343: # error "Unsupported platform"
77343: #endif
77343: 
78454:     /* Temp reg that can be clobbered when setting up a fallible fast or ABI call. */
78454: #if defined(JS_CPU_X86) || defined(JS_CPU_X64)
78454:     static const RegisterID ClobberInCall = JSC::X86Registers::ecx;
78454: #elif defined(JS_CPU_ARM)
78454:     static const RegisterID ClobberInCall = JSC::ARMRegisters::r2;
78454: #elif defined(JS_CPU_SPARC)
78454:     static const RegisterID ClobberInCall = JSC::SparcRegisters::l1;
87250: #elif defined(JS_CPU_MIPS)
87250:     static const RegisterID ClobberInCall = JSC::MIPSRegisters::at;
78454: #endif
78454: 
84755:     static const uint32_t AvailFPRegs = TempFPRegs;
77343: 
84755:     static inline uint32_t maskReg(FPRegisterID reg) {
77343:         return (1 << reg) << TotalRegisters;
77343:     }
77343: 
77343:     /* Common code. */
77343: 
84755:     static const uint32_t TotalAnyRegisters = TotalRegisters + TotalFPRegisters;
84755:     static const uint32_t TempAnyRegs = TempRegs | TempFPRegs;
84755:     static const uint32_t AvailAnyRegs = AvailRegs | AvailFPRegs;
77343: 
84755:     static inline uint32_t maskReg(AnyRegisterID reg) {
77343:         return (1 << reg.reg_);
77343:     }
74240: 
77412:     /* Get a register which is not live before a FASTCALL. */
77412:     static inline RegisterID tempCallReg() {
78990:         Registers regs(TempRegs);
77412:         regs.takeReg(Registers::ArgReg0);
77412:         regs.takeReg(Registers::ArgReg1);
77412:         return regs.takeAnyReg().reg();
77412:     }
52608: 
78454:     /* Get a register which is not live before a normal ABI call with at most four args. */
78454:     static inline Registers tempCallRegMask() {
78454:         Registers regs(AvailRegs);
78454: #ifndef JS_CPU_X86
78454:         regs.takeReg(ArgReg0);
78454:         regs.takeReg(ArgReg1);
78454:         regs.takeReg(ArgReg2);
78457: #if defined(JS_CPU_SPARC) || defined(JS_CPU_X64)
78454:         regs.takeReg(ArgReg3);
78454: #endif
78454: #endif
78454:         return regs;
78454:     }
78454: 
84755:     Registers(uint32_t freeMask)
52608:       : freeMask(freeMask)
52608:     { }
52560: 
52611:     Registers(const Registers &other)
52611:       : freeMask(other.freeMask)
52611:     { }
52611: 
52611:     Registers & operator =(const Registers &other)
52611:     {
52611:         freeMask = other.freeMask;
52611:         return *this;
52611:     }
52611: 
84755:     bool empty(uint32_t mask) const {
77343:         return !(freeMask & mask);
52560:     }
52560: 
52828:     bool empty() const {
52617:         return !freeMask;
52560:     }
52560: 
84755:     AnyRegisterID peekReg(uint32_t mask) {
77343:         JS_ASSERT(!empty(mask));
77343:         unsigned ireg;
77343:         JS_FLOOR_LOG2(ireg, freeMask & mask);
77343:         return AnyRegisterID::fromRaw(ireg);
52560:     }
52560: 
77343:     AnyRegisterID peekReg() {
77343:         return peekReg(freeMask);
54719:     }
54719: 
84755:     AnyRegisterID takeAnyReg(uint32_t mask) {
77343:         AnyRegisterID reg = peekReg(mask);
52617:         takeReg(reg);
52560:         return reg;
52560:     }
52560: 
77343:     AnyRegisterID takeAnyReg() {
77343:         return takeAnyReg(freeMask);
52653:     }
52653: 
77343:     bool hasReg(AnyRegisterID reg) const {
77343:         return !!(freeMask & (1 << reg.reg_));
52653:     }
52653: 
84755:     bool hasRegInMask(uint32_t mask) const {
77343:         return !!(freeMask & mask);
52560:     }
52560: 
84755:     bool hasAllRegs(uint32_t mask) const {
77343:         return (freeMask & mask) == mask;
52560:     }
52560: 
77343:     void putRegUnchecked(AnyRegisterID reg) {
77343:         freeMask |= (1 << reg.reg_);
77343:     }
77343: 
77343:     void putReg(AnyRegisterID reg) {
52617:         JS_ASSERT(!hasReg(reg));
52617:         putRegUnchecked(reg);
52560:     }
52560: 
77343:     void takeReg(AnyRegisterID reg) {
52617:         JS_ASSERT(hasReg(reg));
60164:         takeRegUnchecked(reg);
60164:     }
60164: 
77343:     void takeRegUnchecked(AnyRegisterID reg) {
77343:         freeMask &= ~(1 << reg.reg_);
52560:     }
52560: 
52578:     bool operator ==(const Registers &other) {
52578:         return freeMask == other.freeMask;
52578:     }
52578: 
84755:     uint32_t freeMask;
52560: };
52560: 
77343: static const JSC::MacroAssembler::RegisterID JSFrameReg = Registers::JSFrameReg;
52828: 
77343: AnyRegisterID
77343: AnyRegisterID::fromRaw(unsigned reg_)
52828: {
77343:     JS_ASSERT(reg_ < Registers::TotalAnyRegisters);
77343:     AnyRegisterID reg;
77343:     reg.reg_ = reg_;
52828:     return reg;
52828: }
52828: 
77343: JSC::MacroAssembler::RegisterID
77343: AnyRegisterID::reg()
77343: {
77343:     JS_ASSERT(reg_ < Registers::TotalRegisters);
77343:     return (JSC::MacroAssembler::RegisterID) reg_;
52828: }
52828: 
77343: JSC::MacroAssembler::FPRegisterID
77343: AnyRegisterID::fpreg()
77343: {
77343:     JS_ASSERT(reg_ >= Registers::TotalRegisters &&
77343:               reg_ < Registers::TotalAnyRegisters);
77343:     return (JSC::MacroAssembler::FPRegisterID) (reg_ - Registers::TotalRegisters);
52828: }
52828: 
77343: const char *
77343: AnyRegisterID::name()
77343: {
77343: #if defined(JS_CPU_X86) || defined(JS_CPU_X64)
77343:     return isReg() ? JSC::X86Registers::nameIReg(reg()) : JSC::X86Registers::nameFPReg(fpreg());
77343: #elif defined(JS_CPU_ARM)
77343:     return isReg() ? JSC::ARMAssembler::nameGpReg(reg()) : JSC::ARMAssembler::nameFpRegD(fpreg());
77343: #else
77343:     return "???";
77343: #endif
52828: }
52828: 
52560: } /* namespace mjit */
52560: 
52560: } /* namespace js */
52560: 
52560: #endif /* jsjaeger_regstate_h__ */
52560: 
