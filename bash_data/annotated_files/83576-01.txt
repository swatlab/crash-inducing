83543: /* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
51662:  * ***** BEGIN LICENSE BLOCK *****
43032:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43032:  *
43032:  * The contents of this file are subject to the Mozilla Public License Version
43032:  * 1.1 (the "License"); you may not use this file except in compliance with
43032:  * the License. You may obtain a copy of the License at
43032:  * http://www.mozilla.org/MPL/
43032:  *
43032:  * Software distributed under the License is distributed on an "AS IS" basis,
43032:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43032:  * for the specific language governing rights and limitations under the
43032:  * License.
43032:  *
43032:  * The Original Code is Mozilla Android code.
43032:  *
43032:  * The Initial Developer of the Original Code is Mozilla Foundation.
43032:  * Portions created by the Initial Developer are Copyright (C) 2009-2010
43032:  * the Initial Developer. All Rights Reserved.
43032:  *
43032:  * Contributor(s):
43032:  *   Vladimir Vukicevic <vladimir@pobox.com>
57436:  *   Matt Brubeck <mbrubeck@mozilla.com>
57436:  *   Vivien Nicolas <vnicolas@mozilla.com>
43032:  *
43032:  * Alternatively, the contents of this file may be used under the terms of
43032:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43032:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43032:  * in which case the provisions of the GPL or the LGPL are applicable instead
43032:  * of those above. If you wish to allow use of your version of this file only
43032:  * under the terms of either the GPL or the LGPL, and not to allow others to
43032:  * use your version of this file under the terms of the MPL, indicate your
43032:  * decision by deleting the provisions above and replace them with the notice
43032:  * and other provisions required by the GPL or the LGPL. If you do not delete
43032:  * the provisions above, a recipient may use your version of this file under
43032:  * the terms of any one of the MPL, the GPL or the LGPL.
43032:  *
43032:  * ***** END LICENSE BLOCK ***** */
43032: 
43032: package org.mozilla.gecko;
43032: 
43032: import java.io.*;
43032: import java.util.*;
43032: import java.util.zip.*;
83536: import java.net.MalformedURLException;
83536: import java.net.URL;
43032: import java.nio.*;
53801: import java.nio.channels.FileChannel;
56159: import java.util.concurrent.*;
78424: import java.lang.reflect.*;
43032: 
43032: import android.os.*;
43032: import android.app.*;
43032: import android.text.*;
43032: import android.view.*;
43032: import android.view.inputmethod.*;
43032: import android.content.*;
63152: import android.content.res.*;
43032: import android.graphics.*;
83536: import android.graphics.drawable.Drawable;
43032: import android.widget.*;
43032: import android.hardware.*;
43032: 
43032: import android.util.*;
56159: import android.net.*;
71133: import android.database.*;
83485: import android.database.sqlite.*;
71133: import android.provider.*;
78424: import android.content.pm.*;
78424: import android.content.pm.PackageManager.*;
83575: import android.content.SharedPreferences.*;
78424: import dalvik.system.*;
43032: 
43032: abstract public class GeckoApp
43032:     extends Activity
43032: {
76836:     private static final String LOG_FILE_NAME     = "GeckoApp";
76836: 
51723:     public static final String ACTION_ALERT_CLICK = "org.mozilla.gecko.ACTION_ALERT_CLICK";
51723:     public static final String ACTION_ALERT_CLEAR = "org.mozilla.gecko.ACTION_ALERT_CLEAR";
75005:     public static final String ACTION_WEBAPP      = "org.mozilla.gecko.WEBAPP";
75005:     public static final String ACTION_DEBUG       = "org.mozilla.gecko.DEBUG";
75067:     public static final String ACTION_BOOKMARK    = "org.mozilla.gecko.BOOKMARK";
51723: 
83537:     private LinearLayout mMainLayout;
83537:     private RelativeLayout mGeckoLayout;
43032:     public static GeckoSurfaceView surfaceView;
80216:     public static SurfaceView cameraView;
43032:     public static GeckoApp mAppContext;
57134:     public static boolean mFullscreen = false;
62123:     public static File sGREDir = null;
64514:     public Handler mMainHandler;
69577:     private IntentFilter mConnectivityFilter;
69577:     private BroadcastReceiver mConnectivityReceiver;
83559:     private BrowserToolbar mBrowserToolbar;
43032: 
83485:     enum LaunchState {Launching, WaitButton,
78217:                       Launched, GeckoRunning, GeckoExiting};
83485:     private static LaunchState sLaunchState = LaunchState.Launching;
74433:     private static boolean sTryCatchAttached = false;
58306: 
83485:     private static final int FILE_PICKER_REQUEST = 1;
83485:     private static final int AWESOMEBAR_REQUEST = 2;
83519:     private static final int CAMERA_CAPTURE_REQUEST = 3;
83541:     private static final int SHOW_TABS_REQUEST = 4;
58306: 
58306:     static boolean checkLaunchState(LaunchState checkState) {
58306:         synchronized(sLaunchState) {
58306:             return sLaunchState == checkState;
58306:         }
58306:     }
58306: 
58306:     static void setLaunchState(LaunchState setState) {
58306:         synchronized(sLaunchState) {
58306:             sLaunchState = setState;
58306:         }
58306:     }
58306: 
58306:     // if mLaunchState is equal to checkState this sets mLaunchState to setState
58306:     // and return true. Otherwise we return false.
58306:     static boolean checkAndSetLaunchState(LaunchState checkState, LaunchState setState) {
58306:         synchronized(sLaunchState) {
58306:             if (sLaunchState != checkState)
58306:                 return false;
58306:             sLaunchState = setState;
58306:             return true;
58306:         }
58306:     }
58306: 
54682:     void showErrorDialog(String message)
54682:     {
54682:         new AlertDialog.Builder(this)
54682:             .setMessage(message)
54682:             .setCancelable(false)
62430:             .setPositiveButton(R.string.exit_label,
54682:                                new DialogInterface.OnClickListener() {
54682:                                    public void onClick(DialogInterface dialog,
54682:                                                        int id)
54682:                                    {
54682:                                        GeckoApp.this.finish();
62430:                                        System.exit(0);
54682:                                    }
54682:                                }).show();
54682:     }
54682: 
78424:     public static final String PLUGIN_ACTION = "android.webkit.PLUGIN";
78424: 
78424:     /**
78424:      * A plugin that wish to be loaded in the WebView must provide this permission
78424:      * in their AndroidManifest.xml.
78424:      */
78424:     public static final String PLUGIN_PERMISSION = "android.webkit.permission.PLUGIN";
78424: 
78424:     private static final String LOGTAG = "PluginManager";
78424: 
78424:     private static final String PLUGIN_SYSTEM_LIB = "/system/lib/plugins/";
78424: 
78424:     private static final String PLUGIN_TYPE = "type";
78424:     private static final String TYPE_NATIVE = "native";
78424:     public ArrayList<PackageInfo> mPackageInfoCache = new ArrayList<PackageInfo>();
78424: 
78424:     String[] getPluginDirectories() {
79515: 
83485:         Log.w(LOGTAG, "zerdatime " + new Date().getTime() + " - start of getPluginDirectories");
83485: 
78424:         ArrayList<String> directories = new ArrayList<String>();
78424:         PackageManager pm = this.mAppContext.getPackageManager();
78424:         List<ResolveInfo> plugins = pm.queryIntentServices(new Intent(PLUGIN_ACTION),
78424:                 PackageManager.GET_SERVICES | PackageManager.GET_META_DATA);
78424: 
78424:         synchronized(mPackageInfoCache) {
79515: 
78424:             // clear the list of existing packageInfo objects
78424:             mPackageInfoCache.clear();
78424: 
79515: 
78424:             for (ResolveInfo info : plugins) {
78424: 
78424:                 // retrieve the plugin's service information
78424:                 ServiceInfo serviceInfo = info.serviceInfo;
78424:                 if (serviceInfo == null) {
78424:                     Log.w(LOGTAG, "Ignore bad plugin");
78424:                     continue;
78424:                 }
78424: 
78424:                 Log.w(LOGTAG, "Loading plugin: " + serviceInfo.packageName);
78424: 
79515: 
78424:                 // retrieve information from the plugin's manifest
78424:                 PackageInfo pkgInfo;
78424:                 try {
78424:                     pkgInfo = pm.getPackageInfo(serviceInfo.packageName,
78424:                                     PackageManager.GET_PERMISSIONS
78424:                                     | PackageManager.GET_SIGNATURES);
78424:                 } catch (Exception e) {
78424:                     Log.w(LOGTAG, "Can't find plugin: " + serviceInfo.packageName);
78424:                     continue;
78424:                 }
78424:                 if (pkgInfo == null) {
78424:                     Log.w(LOGTAG, "Loading plugin: " + serviceInfo.packageName + ". Could not load package information.");
78424:                     continue;
78424:                 }
78424: 
78424:                 /*
78424:                  * find the location of the plugin's shared library. The default
78424:                  * is to assume the app is either a user installed app or an
78424:                  * updated system app. In both of these cases the library is
78424:                  * stored in the app's data directory.
78424:                  */
78424:                 String directory = pkgInfo.applicationInfo.dataDir + "/lib";
78424:                 final int appFlags = pkgInfo.applicationInfo.flags;
78424:                 final int updatedSystemFlags = ApplicationInfo.FLAG_SYSTEM |
78424:                                                ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
78424:                 // preloaded system app with no user updates
78424:                 if ((appFlags & updatedSystemFlags) == ApplicationInfo.FLAG_SYSTEM) {
78424:                     directory = PLUGIN_SYSTEM_LIB + pkgInfo.packageName;
78424:                 }
78424: 
78424:                 // check if the plugin has the required permissions
78424:                 String permissions[] = pkgInfo.requestedPermissions;
78424:                 if (permissions == null) {
78424:                     Log.w(LOGTAG, "Loading plugin: " + serviceInfo.packageName + ". Does not have required permission.");
78424:                     continue;
78424:                 }
78424:                 boolean permissionOk = false;
78424:                 for (String permit : permissions) {
78424:                     if (PLUGIN_PERMISSION.equals(permit)) {
78424:                         permissionOk = true;
78424:                         break;
78424:                     }
78424:                 }
78424:                 if (!permissionOk) {
78424:                     Log.w(LOGTAG, "Loading plugin: " + serviceInfo.packageName + ". Does not have required permission (2).");
78424:                     continue;
78424:                 }
78424: 
78424:                 // check to ensure the plugin is properly signed
78424:                 Signature signatures[] = pkgInfo.signatures;
78424:                 if (signatures == null) {
78424:                     Log.w(LOGTAG, "Loading plugin: " + serviceInfo.packageName + ". Not signed.");
78424:                     continue;
78424:                 }
78424: 
78424:                 // determine the type of plugin from the manifest
78424:                 if (serviceInfo.metaData == null) {
78424:                     Log.e(LOGTAG, "The plugin '" + serviceInfo.name + "' has no type defined");
78424:                     continue;
78424:                 }
78424: 
78424:                 String pluginType = serviceInfo.metaData.getString(PLUGIN_TYPE);
78424:                 if (!TYPE_NATIVE.equals(pluginType)) {
78424:                     Log.e(LOGTAG, "Unrecognized plugin type: " + pluginType);
78424:                     continue;
78424:                 }
78424: 
78424:                 try {
78424:                     Class<?> cls = getPluginClass(serviceInfo.packageName, serviceInfo.name);
78424: 
78424:                     //TODO implement any requirements of the plugin class here!
78424:                     boolean classFound = true;
78424: 
78424:                     if (!classFound) {
78424:                         Log.e(LOGTAG, "The plugin's class' " + serviceInfo.name + "' does not extend the appropriate class.");
78424:                         continue;
78424:                     }
78424: 
78424:                 } catch (NameNotFoundException e) {
78424:                     Log.e(LOGTAG, "Can't find plugin: " + serviceInfo.packageName);
78424:                     continue;
78424:                 } catch (ClassNotFoundException e) {
78424:                     Log.e(LOGTAG, "Can't find plugin's class: " + serviceInfo.name);
78424:                     continue;
78424:                 }
78424: 
78424:                 // if all checks have passed then make the plugin available
78424:                 mPackageInfoCache.add(pkgInfo);
78424:                 directories.add(directory);
78424:             }
78424:         }
78424: 
83485:         String [] result = directories.toArray(new String[directories.size()]);
83485:         Log.w(LOGTAG, "zerdatime " + new Date().getTime() + " - end of getPluginDirectories");
83485:         return result;
78424:     }
78424: 
78424:     Class<?> getPluginClass(String packageName, String className)
78424:             throws NameNotFoundException, ClassNotFoundException {
78424:         Context pluginContext = this.mAppContext.createPackageContext(packageName,
78424:                 Context.CONTEXT_INCLUDE_CODE |
78424:                 Context.CONTEXT_IGNORE_SECURITY);
78424:         ClassLoader pluginCL = pluginContext.getClassLoader();
78424:         return pluginCL.loadClass(className);
78424:     }
78424: 
58306:     // Returns true when the intent is going to be handled by gecko launch
60270:     boolean launch(Intent intent)
43032:     {
83485:         Log.w(LOGTAG, "zerdatime " + new Date().getTime() + " - launch");
83485: 
58306:         if (!checkAndSetLaunchState(LaunchState.Launching, LaunchState.Launched))
58306:             return false;
58306: 
83492:         class GeckoTask extends AsyncTask<Intent, Void, Void> {
83492:             protected Void doInBackground(Intent... intents) {
83492:                 Intent intent = intents[0];
83485:                 File cacheFile = GeckoAppShell.getCacheDir();
83485:                 File libxulFile = new File(cacheFile, "libxul.so");
78603: 
83485:                 if ((!libxulFile.exists() ||
83485:                      new File(getApplication().getPackageResourcePath()).lastModified() >= libxulFile.lastModified())) {
83485:                     File[] libs = cacheFile.listFiles(new FilenameFilter() {
83485:                             public boolean accept(File dir, String name) {
83485:                                 return name.endsWith(".so");
78603:                             }
83485:                         });
83485:                     if (libs != null) {
83485:                         for (int i = 0; i < libs.length; i++) {
83485:                             libs[i].delete();
83485:                         }
83485:                     }
83485:                  }
78603:  
83485:                 // At some point while loading the gecko libs our default locale gets set
83485:                 // so just save it to locale here and reset it as default after the join
83485:                 Locale locale = Locale.getDefault();
83485:                 GeckoAppShell.loadGeckoLibs(
83485:                     getApplication().getPackageResourcePath());
83485:                 Locale.setDefault(locale);
83485:                 Resources res = getBaseContext().getResources();
83485:                 Configuration config = res.getConfiguration();
83485:                 config.locale = locale;
83485:                 res.updateConfiguration(config, res.getDisplayMetrics());
83485: 
83485:                 Log.w(LOGTAG, "zerdatime " + new Date().getTime() + " - runGecko");
58306: 
43032:                 // and then fire us up
71129:                 try {
83492:                     String env = intent.getStringExtra("env0");
83575:                     String uri = intent.getDataString();
83575:                     if (uri == null || uri.equals(""))
83575:                         uri = getLastUri();
83575:                     if (uri == null)
83575:                         uri = "";
83575: 
83575:                     final String awesomeURI = uri; 
83575:                     mMainHandler.post(new Runnable() {
83575:                       public void run() {
83575:                         mBrowserToolbar.setTitle(awesomeURI);
83575:                       }
83575:                     });
83575: 
83575:                     Log.w(LOGTAG, "RunGecko - URI = " + uri);
83575: 
43032:                     GeckoAppShell.runGecko(getApplication().getPackageResourcePath(),
83492:                                            intent.getStringExtra("args"),
83575:                                            uri);
71129:                 } catch (Exception e) {
76836:                     Log.e(LOG_FILE_NAME, "top level exception", e);
71129:                     StringWriter sw = new StringWriter();
71129:                     e.printStackTrace(new PrintWriter(sw));
71129:                     GeckoAppShell.reportJavaCrash(sw.toString());
71129:                 }
83492:                 return null;
60270:             }
83492:         }
83492: 
83492:         if (intent == null)
83492:             intent = getIntent();
83492: 
83492:         new GeckoTask().execute(intent);
83492: 
58306:         return true;
43032:     }
43032: 
83485:     @Override
83485:     public boolean onCreateOptionsMenu(Menu menu)
83485:     {
83485:         final Activity self = this;
83485: 
83494:         MenuInflater inflater = getMenuInflater();
83494:         inflater.inflate(R.layout.gecko_menu, menu);
83494:         return true;
83494:     }
83494: 
83494:     @Override
83494:     public boolean onOptionsItemSelected(MenuItem item) {
83564:         Tab tab = null;
83564:         Tab.HistoryEntry he = null;
83494:         switch (item.getItemId()) {
83494:            case R.id.quit:
83485:                quit();
83485:                return true;
83520:            case R.id.bookmarks:
83520:                Intent intent = new Intent(this, GeckoBookmarks.class);
83564:                tab = Tabs.getInstance().getSelectedTab();
83564:                he = tab.getLastHistoryEntry();
83522:                if (he != null) {
83520:                    intent.setData(android.net.Uri.parse(he.mUri));
83520:                    intent.putExtra("title", he.mTitle);
83520:                    startActivity(intent);
83522:                }
83520:                return true;
83564:            case R.id.share:
83564:                tab = Tabs.getInstance().getSelectedTab();
83564:                he = tab.getLastHistoryEntry();
83564:                if (he != null) {
83564:                    GeckoAppShell.openUriExternal(he.mUri, "text/plain", "", "",
83564:                                                  Intent.ACTION_SEND, he.mTitle);
83564:                }
83564:                return true;
83541:            case R.id.show_tabs:
83541:                Intent showTabsIntent = new Intent(this, ShowTabs.class);
83541:                showTabsIntent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION | Intent.FLAG_ACTIVITY_NO_HISTORY);
83541:                startActivityForResult(showTabsIntent, SHOW_TABS_REQUEST);
83541:                return true;
83494:            default:
83494:                return super.onOptionsItemSelected(item);
83485:         }
83485:     }
83485: 
83575:     private void rememberLastScreen(boolean sync) {
83575:         if (surfaceView == null)
83575:             return;
83575:         Tab tab = Tabs.getInstance().getSelectedTab();
83575:         if (!tab.getHistory().empty()) {
83575:             SharedPreferences prefs = getSharedPreferences("GeckoApp", 0);
83575:             Editor editor = prefs.edit();
83575:             
83575:             String uri = tab.getHistory().peek().mUri;
83575:             String title = tab.getHistory().peek().mTitle;
83575: 
83575:             editor.putString("last-uri", uri);
83575:             editor.putString("last-title", title);
83575: 
83575:             Log.i(LOG_FILE_NAME, "Saving:: " + uri + " " + title);
83575:             editor.commit();
83575:             surfaceView.saveLast(sync);
83575:         }
83575:     }
83575: 
83575:     private String getLastUri() {
83575:         SharedPreferences prefs = getSharedPreferences("GeckoApp", 0);
83575:         String lastUri = prefs.getString("last-uri", "");
83575:         return lastUri;
83575:     }
83575: 
83575:     private boolean restoreLastScreen() {
83575:         SharedPreferences prefs = getSharedPreferences ("GeckoApp", 0);
83575:         String lastUri = prefs.getString("last-uri", "");
83575:         String lastTitle = prefs.getString("last-title", "");
83575: 
83575:         Log.i(LOG_FILE_NAME, "The last uri was: " + lastUri);
83575:         Log.i(LOG_FILE_NAME, "The last title was: " + lastTitle);
83575:         
83575:         return true;
83575:     }
83575: 
83485:     private void quit() {
83485:         Log.i(LOG_FILE_NAME, "pleaseKillMe");
83575:         rememberLastScreen(true);
83576:         System.exit(0);
83485:     }
83485: 
83541:     void handleLocationChange(final int tabId, final String uri) {
83541:         Tab tab = Tabs.getInstance().getTab(tabId);
83541:         if (tab != null)
83541:             tab.updateURL(uri);
83541: 
83541:         if (!Tabs.getInstance().isSelectedTab(tab))
83541:             return;
83541: 
83536:         mMainHandler.post(new Runnable() { 
83536:             public void run() {
83559:                 mBrowserToolbar.setTitle(uri);
83574:                 mBrowserToolbar.setFavicon(null);
83536:             }
83536:         });
83536:     }
83536: 
83541:     void handleDocumentStart(final int tabId) {
83541:         Tab tab = Tabs.getInstance().getTab(tabId);
83541:         tab.setLoading(true);
83541:         
83541:         if (!Tabs.getInstance().isSelectedTab(tab))
83541:             return;
83541: 
83536:         mMainHandler.post(new Runnable() { 
83536:             public void run() {
83559:                 mBrowserToolbar.setProgressVisibility(true);
83559:                 mBrowserToolbar.updateProgress(-1, -1);
83536:             }
83536:         });
83536:     }
83536: 
83541:     void handleDocumentStop(final int tabId) {
83541:         Tab tab = Tabs.getInstance().getTab(tabId);
83541:         tab.setLoading(false);
83541:         
83541:         if (!Tabs.getInstance().isSelectedTab(tab))
83541:             return;
83541: 
83536:         mMainHandler.post(new Runnable() { 
83536:             public void run() {
83559:                 mBrowserToolbar.setProgressVisibility(false);
83536:                 surfaceView.hideStartupBitmap();
83536:             }
83536:         });
83536:     }
83536: 
83541:     void handleProgressChange(final int tabId, final int current, final int total) {
83541:         Tab tab = Tabs.getInstance().getTab(tabId);
83541:         if (!Tabs.getInstance().isSelectedTab(tab))
83541:             return;
83541:         
83536:         mMainHandler.post(new Runnable() { 
83536:             public void run() {
83559:                 mBrowserToolbar.updateProgress(current, total);
83536:             }
83536:         });
83536:     }
83536: 
83541:     void handleContentLoaded(final int tabId, final String uri, final String title) {
83541:         Tab tab = Tabs.getInstance().getTab(tabId);
83541:         tab.updateTitle(title);
83541:         tab.addHistory(new Tab.HistoryEntry(uri, title));
83541: 
83541:         if (!Tabs.getInstance().isSelectedTab(tab))
83541:             return;
83541: 
83536:         mMainHandler.post(new Runnable() {
83536:             public void run() {
83559:                 mBrowserToolbar.setTitle(title);
83536:             }
83536:         });
83536:     }
83536: 
83541:     void handleTitleChanged(final int tabId, final String title) {
83541:         Tab tab = Tabs.getInstance().getTab(tabId);
83541:         tab.updateTitle(title);
83541:         
83541:         if (!Tabs.getInstance().isSelectedTab(tab))
83541:             return;
83541: 
83536:         mMainHandler.post(new Runnable() { 
83536:             public void run() {
83559:                 mBrowserToolbar.setTitle(title);
83536:             }
83536:         });
83536:     }
83536: 
83536:     void handleLinkAdded(String rel, final String href) {
83572:         class DownloadFaviconTask extends AsyncTask<URL, Void, Drawable> {
83572:             protected Drawable doInBackground(URL... url) {
83572:                 Drawable image = null;
83536:                 try {
83572:                     InputStream is = (InputStream) url[0].getContent();
83572:                     image = Drawable.createFromStream(is, "src");
83536:                 } catch (IOException e) {
83536:                     Log.d("GeckoShell", "Error loading favicon: " + e);
83536:                 }
83572:                 return image;
83572:             }
83572:             protected void onPostExecute(Drawable image) {
83572:                 if (image != null) {
83572:                     final Drawable postImage = image;
83572:                     mMainHandler.post(new Runnable() {
83572:                         public void run() {
83572:                             mBrowserToolbar.setFavicon(postImage);
83536:                         }
83536:                     });
83536:                 }
83536:             }
83572:         }
83572: 
83572:         if (rel.indexOf("icon") != -1) {
83572:             try {
83572:                 URL url = new URL(href);
83572:                 new DownloadFaviconTask().execute(url);
83572:             } catch (MalformedURLException e) {
83572:                 Log.d("GeckoShell", "Error loading favicon: " + e);
83572:             }
83572:         }
83572:     }
83536: 
83537:     void addPluginView(final View view,
83537:                        final double x, final double y,
83537:                        final double w, final double h) {
83537:         mMainHandler.post(new Runnable() { 
83537:             public void run() {
83537:                 RelativeLayout.LayoutParams lp = new RelativeLayout.LayoutParams((int) w, (int) h);
83537:                 lp.leftMargin = (int) x;
83537:                 lp.topMargin = (int) y;
83537: 
83537:                 if (mGeckoLayout.indexOfChild(view) == -1) {
83537:                     view.setWillNotDraw(false);
83537:                     if (view instanceof SurfaceView)
83537:                         ((SurfaceView)view).setZOrderOnTop(true);
83537: 
83537:                     mGeckoLayout.addView(view, lp);
83537:                 } else {
83537:                     try {
83537:                         mGeckoLayout.updateViewLayout(view, lp);
83537:                     } catch (IllegalArgumentException e) {
83537:                         Log.i("updateViewLayout - IllegalArgumentException", "e:" + e);
83537:                         // it can be the case where we
83537:                         // get an update before the view
83537:                         // is actually attached.
83537:                     }
83537:                 }
83537:             }
83537:         });
83537:     }
83537: 
83537:     void removePluginView(final View view) {
83537:         mMainHandler.post(new Runnable() { 
83537:             public void run() {
83537:                 try {
83537:                     mGeckoLayout.removeView(view);
83537:                 } catch (Exception e) {}
83537:             }
83537:         });
83537:     }
83537: 
43032:     /** Called when the activity is first created. */
43032:     @Override
43032:     public void onCreate(Bundle savedInstanceState)
43032:     {
83485:         Log.w(LOGTAG, "zerdatime " + new Date().getTime() + " - onCreate");
83485: 
83521:         if (Build.VERSION.SDK_INT >= 9) {
83516:             StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
83516:                                        .detectDiskReads().detectDiskWrites().detectNetwork()
83516:                                        .penaltyLog().build());
83516:             StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().penaltyLog().build());
83521:         }
83558:         if (Build.VERSION.SDK_INT >= 11) {
83558:             setTheme(R.style.HoneycombTheme);
83558:         }
83516: 
83485:         super.onCreate(savedInstanceState);
83485:         
83485:         getWindow().setFlags(mFullscreen ?
83485:                              WindowManager.LayoutParams.FLAG_FULLSCREEN : 0,
83485:                              WindowManager.LayoutParams.FLAG_FULLSCREEN);
83485:         getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);
83485:         
83485:         setContentView(R.layout.gecko_app);
63152:         mAppContext = this;
83485: 
83485:         // setup gecko layout
83537:         mGeckoLayout = (RelativeLayout) findViewById(R.id.geckoLayout);
83559:         mBrowserToolbar = (BrowserToolbar) findViewById(R.id.browserToolbar);
83487: 
83490:         if (surfaceView == null) {
83490:             surfaceView = new GeckoSurfaceView(this);
83537:             mGeckoLayout.addView(surfaceView);
83537:         } else if (mGeckoLayout.getChildCount() == 0) {
83490:            //surfaceView still holds to the old one during rotation. re-add it to new activity
83490:            ((ViewGroup) surfaceView.getParent()).removeAllViews();
83537:            mGeckoLayout.addView(surfaceView);
83487:         }
83487: 
83516:         surfaceView.loadStartupBitmap();
83516: 
83485:         Log.w(LOGTAG, "zerdatime " + new Date().getTime() + " - UI almost up");
83485: 
83490:         if (sGREDir == null)
83490:             sGREDir = new File(this.getApplicationInfo().dataDir);
83485: 
64514:         mMainHandler = new Handler();
63152: 
74433:         if (!sTryCatchAttached) {
74433:             sTryCatchAttached = true;
71129:             mMainHandler.post(new Runnable() {
71129:                 public void run() {
71129:                     try {
71129:                         Looper.loop();
71129:                     } catch (Exception e) {
76836:                         Log.e(LOG_FILE_NAME, "top level exception", e);
71129:                         StringWriter sw = new StringWriter();
71129:                         e.printStackTrace(new PrintWriter(sw));
71129:                         GeckoAppShell.reportJavaCrash(sw.toString());
71129:                     }
74433:                     // resetting this is kinda pointless, but oh well
74433:                     sTryCatchAttached = false;
71129:                 }
71129:             });
74433:         }
71129: 
83537:         mMainLayout = (LinearLayout) findViewById(R.id.mainLayout);
83559:         mBrowserToolbar = (BrowserToolbar) findViewById(R.id.browserToolbar);
58306: 
69614:         mConnectivityFilter = new IntentFilter();
69614:         mConnectivityFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
69614:         mConnectivityReceiver = new GeckoConnectivityReceiver();
69614: 
83485:         final GeckoApp self = this;
83485:  
83485:         mMainHandler.postDelayed(new Runnable() {
83485:             public void run() {
83485: 
83485:                 Log.w(LOGTAG, "zerdatime " + new Date().getTime() + " - pre checkLaunchState");
83485: 
83518:                 /*
83518:                   XXXX see bug 635342
83518:                    We want to disable this code if possible.  It is about 145ms in runtime
79903:                 SharedPreferences settings = getPreferences(Activity.MODE_PRIVATE);
79903:                 String localeCode = settings.getString(getPackageName() + ".locale", "");
79903:                 if (localeCode != null && localeCode.length() > 0)
79903:                     GeckoAppShell.setSelectedLocale(localeCode);
83518:                 */
79903: 
83485:                 if (!checkLaunchState(LaunchState.Launched)) {
58306:                     return;
83485:                 }
58306: 
83485:                 if (false) {
58306:                     checkAndLaunchUpdate();
83485:                 }
83485:             }
83485:         }, 50);
58306:     }
58306: 
43032:     @Override
43811:     protected void onNewIntent(Intent intent) {
83485:         Log.w(LOGTAG, "zerdatime " + new Date().getTime() + " - onNewIntent");
83485: 
58306:         if (checkLaunchState(LaunchState.GeckoExiting)) {
58306:             // We're exiting and shouldn't try to do anything else just incase
58306:             // we're hung for some reason we'll force the process to exit
58306:             System.exit(0);
58306:             return;
58306:         }
43811:         final String action = intent.getAction();
78217:         if (ACTION_DEBUG.equals(action) &&
83485:             checkAndSetLaunchState(LaunchState.Launching, LaunchState.WaitButton)) {
83485:             final Button launchButton = new Button(this);
83485:             launchButton.setText("Launch"); // don't need to localize
83485:             launchButton.setOnClickListener(new Button.OnClickListener() {
83485:                 public void onClick (View v) {
83485:                     // hide the button so we can't be launched again
83537:                     mMainLayout.removeView(launchButton);
78217:                     setLaunchState(LaunchState.Launching);
78217:                     launch(null);
78217:                 }
83485:             });
83537:             mMainLayout.addView(launchButton, 300, 200);
78217:             return;
78217:         }
83485:         if (checkLaunchState(LaunchState.WaitButton) || launch(intent))
78217:             return;
58306: 
75067:         if (Intent.ACTION_MAIN.equals(action)) {
76836:             Log.i(LOG_FILE_NAME, "Intent : ACTION_MAIN");
75067:             GeckoAppShell.sendEventToGecko(new GeckoEvent(""));
75067:         }
78217:         else if (Intent.ACTION_VIEW.equals(action)) {
43811:             String uri = intent.getDataString();
43811:             GeckoAppShell.sendEventToGecko(new GeckoEvent(uri));
76836:             Log.i(LOG_FILE_NAME,"onNewIntent: "+uri);
43811:         }
78217:         else if (ACTION_WEBAPP.equals(action)) {
55889:             String uri = intent.getStringExtra("args");
55889:             GeckoAppShell.sendEventToGecko(new GeckoEvent(uri));
76836:             Log.i(LOG_FILE_NAME,"Intent : WEBAPP - " + uri);
55889:         }
78217:         else if (ACTION_BOOKMARK.equals(action)) {
75067:             String args = intent.getStringExtra("args");
75067:             GeckoAppShell.sendEventToGecko(new GeckoEvent(args));
76836:             Log.i(LOG_FILE_NAME,"Intent : BOOKMARK - " + args);
75067:         }
43811:     }
43811: 
43811:     @Override
43032:     public void onPause()
43032:     {
76836:         Log.i(LOG_FILE_NAME, "pause");
43741:         GeckoAppShell.sendEventToGecko(new GeckoEvent(GeckoEvent.ACTIVITY_PAUSING));
43032:         // The user is navigating away from this activity, but nothing
43032:         // has come to the foreground yet; for Gecko, we may want to
43032:         // stop repainting, for example.
43032: 
43032:         // Whatever we do here should be fast, because we're blocking
43032:         // the next activity from showing up until we finish.
43032: 
43032:         // onPause will be followed by either onResume or onStop.
43032:         super.onPause();
69577: 
69577:         unregisterReceiver(mConnectivityReceiver);
43032:     }
43032: 
43032:     @Override
43032:     public void onResume()
43032:     {
76836:         Log.i(LOG_FILE_NAME, "resume");
58306:         if (checkLaunchState(LaunchState.GeckoRunning))
61773:             GeckoAppShell.onResume();
43032:         // After an onPause, the activity is back in the foreground.
43032:         // Undo whatever we did in onPause.
43032:         super.onResume();
58306: 
58306:         // Just in case. Normally we start in onNewIntent
83485:         if (checkLaunchState(LaunchState.Launching))
58306:             onNewIntent(getIntent());
69577: 
69577:         registerReceiver(mConnectivityReceiver, mConnectivityFilter);
61773:     }
61773: 
61773:     @Override
61773:     public void onStop()
61773:     {
76836:         Log.i(LOG_FILE_NAME, "stop");
61773:         // We're about to be stopped, potentially in preparation for
61773:         // being destroyed.  We're killable after this point -- as I
61773:         // understand it, in extreme cases the process can be terminated
61773:         // without going through onDestroy.
61773:         //
61773:         // We might also get an onRestart after this; not sure what
61773:         // that would mean for Gecko if we were to kill it here.
61773:         // Instead, what we should do here is save prefs, session,
61773:         // etc., and generally mark the profile as 'clean', and then
61773:         // dirty it again if we get an onResume.
61773: 
74672: 
61773:         GeckoAppShell.sendEventToGecko(new GeckoEvent(GeckoEvent.ACTIVITY_STOPPING));
61773:         super.onStop();
61773:     }
61773: 
61773:     @Override
61773:     public void onRestart()
61773:     {
76836:         Log.i(LOG_FILE_NAME, "restart");
61773:         super.onRestart();
61773:     }
61773: 
61773:     @Override
61773:     public void onStart()
61773:     {
83485:         Log.w(LOGTAG, "zerdatime " + new Date().getTime() + " - onStart");
83485: 
76836:         Log.i(LOG_FILE_NAME, "start");
76942:         GeckoAppShell.sendEventToGecko(new GeckoEvent(GeckoEvent.ACTIVITY_START));
61773:         super.onStart();
46173:     }
46173: 
46173:     @Override
43032:     public void onDestroy()
43032:     {
76836:         Log.i(LOG_FILE_NAME, "destroy");
83485: 
43032:         // Tell Gecko to shutting down; we'll end up calling System.exit()
43032:         // in onXreExit.
57135:         if (isFinishing())
59122:             GeckoAppShell.sendEventToGecko(new GeckoEvent(GeckoEvent.ACTIVITY_SHUTDOWN));
43032: 
43032:         super.onDestroy();
43032:     }
43032: 
43032:     @Override
43032:     public void onConfigurationChanged(android.content.res.Configuration newConfig)
43032:     {
76836:         Log.i(LOG_FILE_NAME, "configuration changed");
43032:         // nothing, just ignore
43032:         super.onConfigurationChanged(newConfig);
43032:     }
43032: 
43032:     @Override
43032:     public void onLowMemory()
43032:     {
76836:         Log.e(LOG_FILE_NAME, "low memory");
58306:         if (checkLaunchState(LaunchState.GeckoRunning))
51794:             GeckoAppShell.onLowMemory();
43032:         super.onLowMemory();
43032:     }
43032: 
59565:     abstract public String getPackageName();
46245:     abstract public String getContentProcessName();
43032: 
56418:     public void addEnvToIntent(Intent intent) {
43032:         Map<String,String> envMap = System.getenv();
43032:         Set<Map.Entry<String,String>> envSet = envMap.entrySet();
43032:         Iterator<Map.Entry<String,String>> envIter = envSet.iterator();
43032:         StringBuffer envstr = new StringBuffer();
43032:         int c = 0;
43032:         while (envIter.hasNext()) {
43032:             Map.Entry<String,String> entry = envIter.next();
56418:             intent.putExtra("env" + c, entry.getKey() + "="
43032:                             + entry.getValue());
43032:             c++;
43032:         }
43032:     }
43032: 
43032:     public void doRestart() {
43032:         try {
59565:             String action = "org.mozilla.gecko.restart";
56418:             Intent intent = new Intent(action);
59565:             intent.setClassName(getPackageName(),
59565:                                 getPackageName() + ".Restarter");
56418:             addEnvToIntent(intent);
58498:             intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
58498:                             Intent.FLAG_ACTIVITY_MULTIPLE_TASK);
76836:             Log.i(LOG_FILE_NAME, intent.toString());
63326:             GeckoAppShell.killAnyZombies();
56614:             startActivity(intent);
43032:         } catch (Exception e) {
76836:             Log.i(LOG_FILE_NAME, "error doing restart", e);
43032:         }
56418:         finish();
63180:         // Give the restart process time to start before we die
63326:         GeckoAppShell.waitForAnotherGeckoProc();
43032:     }
51723: 
51723:     public void handleNotification(String action, String alertName, String alertCookie) {
51723:         GeckoAppShell.handleNotification(action, alertName, alertCookie);
43032:     }
53801: 
53801:     private void checkAndLaunchUpdate() {
76836:         Log.i(LOG_FILE_NAME, "Checking for an update");
53801: 
53801:         int statusCode = 8; // UNEXPECTED_ERROR
62278:         File baseUpdateDir = null;
59798:         if (Build.VERSION.SDK_INT >= 8)
62278:             baseUpdateDir = getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS);
59798:         else
62278:             baseUpdateDir = new File(Environment.getExternalStorageDirectory().getPath(), "download");
53801: 
62278:         File updateDir = new File(new File(baseUpdateDir, "updates"),"0");
59798: 
59798:         File updateFile = new File(updateDir, "update.apk");
59798:         File statusFile = new File(updateDir, "update.status");
58005: 
58005:         if (!statusFile.exists() || !readUpdateStatus(statusFile).equals("pending"))
58005:             return;
53801: 
53801:         if (!updateFile.exists())
53801:             return;
53801: 
76836:         Log.i(LOG_FILE_NAME, "Update is available!");
53801: 
53801:         // Launch APK
71523:         File updateFileToRun = new File(updateDir, getPackageName() + "-update.apk");
53801:         try {
54492:             if (updateFile.renameTo(updateFileToRun)) {
53801:                 String amCmd = "/system/bin/am start -a android.intent.action.VIEW " +
53801:                                "-n com.android.packageinstaller/.PackageInstallerActivity -d file://" +
53801:                                updateFileToRun.getPath();
76836:                 Log.i(LOG_FILE_NAME, amCmd);
53801:                 Runtime.getRuntime().exec(amCmd);
53801:                 statusCode = 0; // OK
53801:             } else {
76836:                 Log.i(LOG_FILE_NAME, "Cannot rename the update file!");
53801:                 statusCode = 7; // WRITE_ERROR
51723:             }
53801:         } catch (Exception e) {
76836:             Log.i(LOG_FILE_NAME, "error launching installer to update", e);
53801:         }
53801: 
53801:         // Update the status file
53801:         String status = statusCode == 0 ? "succeeded\n" : "failed: "+ statusCode + "\n";
53801: 
53801:         OutputStream outStream;
53801:         try {
53801:             byte[] buf = status.getBytes("UTF-8");
53801:             outStream = new FileOutputStream(statusFile);
53801:             outStream.write(buf, 0, buf.length);
53801:             outStream.close();
53801:         } catch (Exception e) {
76836:             Log.i(LOG_FILE_NAME, "error writing status file", e);
53801:         }
53801: 
53801:         if (statusCode == 0)
53801:             System.exit(0);
53801:     }
56159: 
58005:     private String readUpdateStatus(File statusFile) {
58005:         String status = "";
58005:         try {
58005:             BufferedReader reader = new BufferedReader(new FileReader(statusFile));
58005:             status = reader.readLine();
58005:             reader.close();
58005:         } catch (Exception e) {
76836:             Log.i(LOG_FILE_NAME, "error reading update status", e);
58005:         }
58005:         return status;
58005:     }
58005: 
83491:     private SynchronousQueue<String> mFilePickerResult = new SynchronousQueue<String>();
56942:     public String showFilePicker(String aMimeType) {
56159:         Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
56159:         intent.addCategory(Intent.CATEGORY_OPENABLE);
56942:         intent.setType(aMimeType);
56159:         GeckoApp.this.
56159:             startActivityForResult(
74666:                 Intent.createChooser(intent, getString(R.string.choose_file)),
56159:                 FILE_PICKER_REQUEST);
56159:         String filePickerResult = "";
76837: 
56159:         try {
76837:             while (null == (filePickerResult = mFilePickerResult.poll(1, TimeUnit.MILLISECONDS))) {
76837:                 Log.i("GeckoApp", "processing events from showFilePicker ");
76837:                 GeckoAppShell.processNextNativeEvent();
76837:             }
56159:         } catch (InterruptedException e) {
76836:             Log.i(LOG_FILE_NAME, "showing file picker ",  e);
53801:         }
56159: 
56159:         return filePickerResult;
56159:     }
56159: 
56159:     @Override
83485:     public boolean onSearchRequested() {
83485:         Intent searchIntent = new Intent(getBaseContext(), AwesomeBar.class);
83485:         searchIntent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION | Intent.FLAG_ACTIVITY_NO_HISTORY);
83551:         searchIntent.putExtra(AwesomeBar.TYPE_KEY, AwesomeBar.Type.ADD.name());
83485:         startActivityForResult(searchIntent, AWESOMEBAR_REQUEST);
83485:         return true;
83485:     }
83485:  
83541:     public boolean onEditRequested() {
83541:         Intent intent = new Intent(getBaseContext(), AwesomeBar.class);
83541:         intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION | Intent.FLAG_ACTIVITY_NO_HISTORY);
83551:         intent.putExtra(AwesomeBar.TYPE_KEY, AwesomeBar.Type.EDIT.name());
83541:         Tab tab = Tabs.getInstance().getSelectedTab();
83541:         if (!tab.getHistory().empty()) {
83541:             intent.putExtra(AwesomeBar.CURRENT_URL_KEY, tab.getHistory().peek().mUri);
83541:         }
83541:         startActivityForResult(intent, AWESOMEBAR_REQUEST);
83541:         return true;
83541:     }
83541: 
83485:     public boolean doReload() {
83485:         Log.i("GeckoApp", "Reload requested");
83541:         Tab tab = Tabs.getInstance().getSelectedTab();
83541:         return tab.doReload();
83485:     }
83485: 
83485:     @Override
83485:     public void onBackPressed() {
83541:         Tab tab = Tabs.getInstance().getSelectedTab();
83541:         if (tab == null || !tab.doBack()) {
83485:             finish();
83485:         }
83485:     }
83485: 
83519:     static int kCaptureIndex = 0;
83519: 
83485:     @Override
56159:     protected void onActivityResult(int requestCode, int resultCode,
56159:                                     Intent data) {
83485:         super.onActivityResult(requestCode, resultCode, data);
83485:         switch (requestCode) {
83485:         case FILE_PICKER_REQUEST:
56159:             String filePickerResult = "";
56159:             if (data != null && resultCode == RESULT_OK) {
56159:                 try {
56159:                     ContentResolver cr = getContentResolver();
56159:                     Uri uri = data.getData();
71133:                     Cursor cursor = GeckoApp.mAppContext.getContentResolver().query(
71133:                         uri, 
71133:                         new String[] { OpenableColumns.DISPLAY_NAME },
71133:                         null, 
71133:                         null, 
71133:                         null);
71133:                     String name = null;
71133:                     if (cursor != null) {
71133:                         try {
71133:                             if (cursor.moveToNext()) {
71133:                                 name = cursor.getString(0);
71133:                             }
71133:                         } finally {
71133:                             cursor.close();
71133:                         }
71133:                     }
71133:                     String fileName = "tmp_";
71133:                     String fileExt = null;
71133:                     int period;
71133:                     if (name == null || (period = name.lastIndexOf('.')) == -1) {
56159:                         String mimeType = cr.getType(uri);
71133:                         fileExt = "." + GeckoAppShell.getExtensionFromMimeType(mimeType);
71133:                     } else {
71133:                         fileExt = name.substring(period);
71133:                         fileName = name.substring(0, period);
71133:                     }
71133:                     File file = File.createTempFile(fileName, fileExt, sGREDir);
56159: 
56159:                     FileOutputStream fos = new FileOutputStream(file);
56159:                     InputStream is = cr.openInputStream(uri);
56159:                     byte[] buf = new byte[4096];
56159:                     int len = is.read(buf);
56159:                     while (len != -1) {
56159:                         fos.write(buf, 0, len);
56159:                         len = is.read(buf);
56159:                     }
56159:                     fos.close();
56159:                     filePickerResult =  file.getAbsolutePath();
56159:                 }catch (Exception e) {
76836:                     Log.e(LOG_FILE_NAME, "showing file picker", e);
56159:                 }
56159:             }
56159:             try {
56159:                 mFilePickerResult.put(filePickerResult);
56159:             } catch (InterruptedException e) {
76836:                 Log.i(LOG_FILE_NAME, "error returning file picker result", e);
56159:             }
83485:             break;
83485:         case AWESOMEBAR_REQUEST:
83485:             if (data != null) {
83485:                 String url = data.getStringExtra(AwesomeBar.URL_KEY);
83551:                 AwesomeBar.Type type = AwesomeBar.Type.valueOf(data.getStringExtra(AwesomeBar.TYPE_KEY));
83485:                 if (url != null && url.length() > 0) {
83559:                     mBrowserToolbar.setProgressVisibility(true);
83559:                     mBrowserToolbar.updateProgress(-1, -1);
83541:                     loadUrl(url, type);
56159:                 }
56159:             }
83485:             break;
83519:         case CAMERA_CAPTURE_REQUEST:
83519:             Log.i(LOG_FILE_NAME, "Returning from CAMERA_CAPTURE_REQUEST: " + resultCode);
83519:             File file = new File(Environment.getExternalStorageDirectory(), "cameraCapture-" + Integer.toString(kCaptureIndex) + ".jpg");
83519:             kCaptureIndex++;
83519:             GeckoEvent e = new GeckoEvent("cameraCaptureDone", resultCode == Activity.RESULT_OK ?
83519:                                           "{\"ok\": true,  \"path\": \"" + file.getPath() + "\" }" :
83519:                                           "{\"ok\": false, \"path\": \"" + file.getPath() + "\" }");
83519:             GeckoAppShell.sendEventToGecko(e);
83519:             break;
83541:         case SHOW_TABS_REQUEST:
83541:             if (data != null) {
83541:                 ShowTabs.Type type = ShowTabs.Type.valueOf(data.getStringExtra(ShowTabs.TYPE));
83541:                 if (type == ShowTabs.Type.ADD) {
83541:                     Intent intent = new Intent(this, AwesomeBar.class);
83541:                     intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION | Intent.FLAG_ACTIVITY_NO_HISTORY);
83551:                     intent.putExtra(AwesomeBar.TYPE_KEY, AwesomeBar.Type.ADD.name());
83541:                     startActivityForResult(intent, AWESOMEBAR_REQUEST);
83541:                 } else {
83541:                     int id = Integer.parseInt(data.getStringExtra(ShowTabs.ID));
83543:                     Tab tab = Tabs.getInstance().selectTab(id);
83541:                     if (tab != null) {
83559:                         mBrowserToolbar.setTitle(tab.getTitle());
83559:                         mBrowserToolbar.setProgressVisibility(tab.isLoading());
83541:                     }
83543:                     GeckoAppShell.sendEventToGecko(new GeckoEvent("tab-select", "" + id));
83541:                 }
83541:             }
83485:        }
83485:     }
83485: 
83519:     public void doCameraCapture() {
83519:         File file = new File(Environment.getExternalStorageDirectory(), "cameraCapture-" + Integer.toString(kCaptureIndex) + ".jpg");
83519: 
83519:         Intent intent = new Intent(android.provider.MediaStore.ACTION_IMAGE_CAPTURE);
83519:         intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(file));
83519: 
83519:         startActivityForResult(intent, CAMERA_CAPTURE_REQUEST);
83519:     }
83519: 
83541:     public void loadUrl(String url, AwesomeBar.Type type) {
83559:         mBrowserToolbar.setTitle(url);
83541:         Log.d(LOG_FILE_NAME, type.name());
83541:         if (type == AwesomeBar.Type.ADD) {
83543:             GeckoAppShell.sendEventToGecko(new GeckoEvent("tab-add", url));
83541:         } else {
83543:             GeckoAppShell.sendEventToGecko(new GeckoEvent("tab-load", url));
83541:         }
83485:    }
83485: }
