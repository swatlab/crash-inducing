 47243: // -*- mode: c++ -*-
 47243: 
114869: // Copyright (c) 2011, Google Inc.
  3869: // All rights reserved.
  3869: //
  3869: // Redistribution and use in source and binary forms, with or without
  3869: // modification, are permitted provided that the following conditions are
  3869: // met:
  3869: //
  3869: //     * Redistributions of source code must retain the above copyright
  3869: // notice, this list of conditions and the following disclaimer.
  3869: //     * Redistributions in binary form must reproduce the above
  3869: // copyright notice, this list of conditions and the following disclaimer
  3869: // in the documentation and/or other materials provided with the
  3869: // distribution.
  3869: //     * Neither the name of Google Inc. nor the names of its
  3869: // contributors may be used to endorse or promote products derived from
  3869: // this software without specific prior written permission.
  3869: //
  3869: // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  3869: // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  3869: // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  3869: // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  3869: // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  3869: // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  3869: // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  3869: // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  3869: // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  3869: // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  3869: // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  3869: 
 47243: // Author: Jim Blandy <jimb@mozilla.com> <jimb@red-bean.com>
 47243: 
  3869: // dump_syms.mm: Create a symbol file for use with minidumps
  3869: 
 47243: #include "common/mac/dump_syms.h"
  3869: 
 47243: #include <Foundation/Foundation.h>
  3869: #include <mach-o/arch.h>
  3869: #include <mach-o/fat.h>
 47243: #include <stdio.h>
  3869: 
114869: #include <ostream>
 47243: #include <string>
 47243: #include <vector>
  3869: 
 47243: #include "common/dwarf/bytereader-inl.h"
 47243: #include "common/dwarf/dwarf2reader.h"
 47243: #include "common/dwarf_cfi_to_module.h"
 47243: #include "common/dwarf_cu_to_module.h"
 47243: #include "common/dwarf_line_to_module.h"
 47243: #include "common/mac/file_id.h"
118328: #include "common/mac/arch_utilities.h"
 47243: #include "common/mac/macho_reader.h"
 47243: #include "common/module.h"
 47243: #include "common/stabs_reader.h"
 47243: #include "common/stabs_to_module.h"
  3869: 
 50677: #ifndef CPU_TYPE_ARM
 50677: #define CPU_TYPE_ARM (static_cast<cpu_type_t>(12))
 50677: #endif //  CPU_TYPE_ARM
 50677: 
 47243: using dwarf2reader::ByteReader;
 47243: using google_breakpad::DwarfCUToModule;
 47243: using google_breakpad::DwarfLineToModule;
  3869: using google_breakpad::FileID;
 47243: using google_breakpad::mach_o::FatReader;
 47243: using google_breakpad::mach_o::Section;
 47243: using google_breakpad::mach_o::Segment;
 47243: using google_breakpad::Module;
 47243: using google_breakpad::StabsReader;
 47243: using google_breakpad::StabsToModule;
 47243: using std::make_pair;
 47243: using std::pair;
 47243: using std::string;
 47243: using std::vector;
  3869: 
 47243: namespace google_breakpad {
  3869: 
 47243: bool DumpSymbols::Read(NSString *filename) {
 47243:   if (![[NSFileManager defaultManager] fileExistsAtPath:filename]) {
 47243:     fprintf(stderr, "Object file does not exist: %s\n",
 47243:             [filename fileSystemRepresentation]);
 47243:     return false;
 22509:   }
 22509: 
 47243:   input_pathname_ = [filename retain];
 22509: 
 47243:   // Does this filename refer to a dSYM bundle?
 47243:   NSBundle *bundle = [NSBundle bundleWithPath:input_pathname_];
  3869: 
 47243:   if (bundle) {
 47243:     // Filenames referring to bundles usually have names of the form
 47243:     // "<basename>.dSYM"; however, if the user has specified a wrapper
 47243:     // suffix (the WRAPPER_SUFFIX and WRAPPER_EXTENSION build settings),
 47243:     // then the name may have the form "<basename>.<extension>.dSYM". In
 47243:     // either case, the resource name for the file containing the DWARF
 47243:     // info within the bundle is <basename>.
 47243:     //
 47243:     // Since there's no way to tell how much to strip off, remove one
 47243:     // extension at a time, and use the first one that
 47243:     // pathForResource:ofType:inDirectory likes.
 47243:     NSString *base_name = [input_pathname_ lastPathComponent];
 47243:     NSString *dwarf_resource;
  3869: 
 47243:     do {
 47243:       NSString *new_base_name = [base_name stringByDeletingPathExtension];
 47243: 
 47243:       // If stringByDeletingPathExtension returned the name unchanged, then
 47243:       // there's nothing more for us to strip off --- lose.
 47243:       if ([new_base_name isEqualToString:base_name]) {
 47243:         fprintf(stderr, "Unable to find DWARF-bearing file in bundle: %s\n",
 47243:                 [input_pathname_ fileSystemRepresentation]);
 47243:         return false;
  3889:       }
  3889: 
 47243:       // Take the shortened result as our new base_name.
 47243:       base_name = new_base_name;
  3869: 
 47243:       // Try to find a DWARF resource in the bundle under the new base_name.
 47243:       dwarf_resource = [bundle pathForResource:base_name
 47243:                         ofType:nil inDirectory:@"DWARF"];
 47243:     } while (!dwarf_resource);
  3869: 
 47243:     object_filename_ = [dwarf_resource retain];
 47243:   } else {
 47243:     object_filename_ = [input_pathname_ retain];
  3869:   }
  3869: 
 47243:   // Read the file's contents into memory.
 47243:   //
 47243:   // The documentation for dataWithContentsOfMappedFile says:
 47243:   //
 47243:   //     Because of file mapping restrictions, this method should only be
 47243:   //     used if the file is guaranteed to exist for the duration of the
 47243:   //     data objectâ€™s existence. It is generally safer to use the
 47243:   //     dataWithContentsOfFile: method.
 47243:   //
 47243:   // I gather this means that OS X doesn't have (or at least, that method
 47243:   // doesn't use) a form of mapping like Linux's MAP_PRIVATE, where the
 47243:   // process appears to get its own copy of the data, and changes to the
 47243:   // file don't affect memory and vice versa).
 47243:   NSError *error;
 47243:   contents_ = [NSData dataWithContentsOfFile:object_filename_
 47243:                                      options:0
 47243:                                        error:&error];
 47243:   if (!contents_) {
 47243:     fprintf(stderr, "Error reading object file: %s: %s\n",
 47243:             [object_filename_ fileSystemRepresentation],
 47243:             [[error localizedDescription] UTF8String]);
 47243:     return false;
 47243:   }
 47243:   [contents_ retain];
  3869: 
 47243:   // Get the list of object files present in the file.
 47243:   FatReader::Reporter fat_reporter([object_filename_
 47243:                                     fileSystemRepresentation]);
 47243:   FatReader fat_reader(&fat_reporter);
 47243:   if (!fat_reader.Read(reinterpret_cast<const uint8_t *>([contents_ bytes]),
 47243:                        [contents_ length])) {
 47243:     return false;
  3869:   }
  3869: 
 47243:   // Get our own copy of fat_reader's object file list.
 47243:   size_t object_files_count;
 47243:   const struct fat_arch *object_files =
 47243:     fat_reader.object_files(&object_files_count);
 47243:   if (object_files_count == 0) {
 47243:     fprintf(stderr, "Fat binary file contains *no* architectures: %s\n",
 47243:             [object_filename_ fileSystemRepresentation]);
 47243:     return false;
 47243:   }
 47243:   object_files_.resize(object_files_count);
 47243:   memcpy(&object_files_[0], object_files,
 47243:          sizeof(struct fat_arch) * object_files_count);
  3869: 
 47243:   return true;
  3869: }
  3869: 
 47243: bool DumpSymbols::SetArchitecture(cpu_type_t cpu_type,
 47243:                                   cpu_subtype_t cpu_subtype) {
 47243:   // Find the best match for the architecture the user requested.
 47243:   const struct fat_arch *best_match
 47243:     = NXFindBestFatArch(cpu_type, cpu_subtype, &object_files_[0],
 50677:                         static_cast<uint32_t>(object_files_.size()));
 47243:   if (!best_match) return false;
  3869: 
 47243:   // Record the selected object file.
 47243:   selected_object_file_ = best_match;
 47243:   return true;
  3889: }
  3889: 
 50677: bool DumpSymbols::SetArchitecture(const std::string &arch_name) {
 50677:   bool arch_set = false;
118328:   const NXArchInfo *arch_info =
118328:       google_breakpad::BreakpadGetArchInfoFromName(arch_name.c_str());
 50677:   if (arch_info) {
 50677:     arch_set = SetArchitecture(arch_info->cputype, arch_info->cpusubtype);
 50677:   }
 50677:   return arch_set;
 50677: }
 50677: 
 47243: string DumpSymbols::Identifier() {
 47243:   FileID file_id([object_filename_ fileSystemRepresentation]);
 47243:   unsigned char identifier_bytes[16];
 47243:   cpu_type_t cpu_type = selected_object_file_->cputype;
118328:   cpu_subtype_t cpu_subtype = selected_object_file_->cpusubtype;
118328:   if (!file_id.MachoIdentifier(cpu_type, cpu_subtype, identifier_bytes)) {
 47243:     fprintf(stderr, "Unable to calculate UUID of mach-o binary %s!\n",
 47243:             [object_filename_ fileSystemRepresentation]);
 47243:     return "";
 22511:   }
 22511: 
 47243:   char identifier_string[40];
 47243:   FileID::ConvertIdentifierToString(identifier_bytes, identifier_string,
 47243:                                     sizeof(identifier_string));
 22509: 
 47243:   string compacted(identifier_string);
 47243:   for(size_t i = compacted.find('-'); i != string::npos;
 47243:       i = compacted.find('-', i))
 47243:     compacted.erase(i, 1);
 47243: 
 47243:   return compacted;
  3869: }
  3869: 
 47243: // A line-to-module loader that accepts line number info parsed by
 47243: // dwarf2reader::LineInfo and populates a Module and a line vector
 47243: // with the results.
 47243: class DumpSymbols::DumperLineToModule:
 47243:       public DwarfCUToModule::LineToModuleFunctor {
 47243:  public:
 47243:   // Create a line-to-module converter using BYTE_READER.
 47243:   DumperLineToModule(dwarf2reader::ByteReader *byte_reader)
 47243:       : byte_reader_(byte_reader) { }
 47243:   void operator()(const char *program, uint64 length,
 47243:                   Module *module, vector<Module::Line> *lines) {
 47243:     DwarfLineToModule handler(module, lines);
 47243:     dwarf2reader::LineInfo parser(program, length, byte_reader_, &handler);
 47243:     parser.Start();
 47243:   }
 47243:  private:
 47243:   dwarf2reader::ByteReader *byte_reader_;  // WEAK
 47243: };
  3869: 
 47243: bool DumpSymbols::ReadDwarf(google_breakpad::Module *module,
 47243:                             const mach_o::Reader &macho_reader,
 47243:                             const mach_o::SectionMap &dwarf_sections) const {
 47243:   // Build a byte reader of the appropriate endianness.
 47243:   ByteReader byte_reader(macho_reader.big_endian()
 47243:                          ? dwarf2reader::ENDIANNESS_BIG
 47243:                          : dwarf2reader::ENDIANNESS_LITTLE);
  3869: 
 47243:   // Construct a context for this file.
 47243:   DwarfCUToModule::FileContext file_context(selected_object_name_,
 47243:                                             module);
  3889: 
 47243:   // Build a dwarf2reader::SectionMap from our mach_o::SectionMap.
 47243:   for (mach_o::SectionMap::const_iterator it = dwarf_sections.begin();
 47243:        it != dwarf_sections.end(); it++) {
 47243:     file_context.section_map[it->first] =
 47243:       make_pair(reinterpret_cast<const char *>(it->second.contents.start),
 47243:                 it->second.contents.Size());
  3889:   }
  3889: 
 47243:   // Find the __debug_info section.
 47243:   std::pair<const char *, uint64> debug_info_section
 47243:       = file_context.section_map["__debug_info"];
 47243:   // There had better be a __debug_info section!
 47243:   if (!debug_info_section.first) {
 47243:     fprintf(stderr, "%s: __DWARF segment of file has no __debug_info section\n",
 47243:             selected_object_name_.c_str());
 47243:     return false;
  7079:   }
  7079: 
 47243:   // Build a line-to-module loader for the root handler to use.
 47243:   DumperLineToModule line_to_module(&byte_reader);
  3869: 
 47243:   // Walk the __debug_info section, one compilation unit at a time.
 47243:   uint64 debug_info_length = debug_info_section.second;
 47243:   for (uint64 offset = 0; offset < debug_info_length;) {
 47243:     // Make a handler for the root DIE that populates MODULE with the
 47243:     // debug info.
 47243:     DwarfCUToModule::WarningReporter reporter(selected_object_name_,
 47243:                                               offset);
 47243:     DwarfCUToModule root_handler(&file_context, &line_to_module, &reporter);
 47243:     // Make a Dwarf2Handler that drives our DIEHandler.
 47243:     dwarf2reader::DIEDispatcher die_dispatcher(&root_handler);
 47243:     // Make a DWARF parser for the compilation unit at OFFSET.
 47243:     dwarf2reader::CompilationUnit dwarf_reader(file_context.section_map,
 47243:                                                offset,
 47243:                                                &byte_reader,
 47243:                                                &die_dispatcher);
 47243:     // Process the entire compilation unit; get the offset of the next.
 47243:     offset += dwarf_reader.Start();
  3869:   }
  3869: 
 47243:   return true;
  3869: }
  3869: 
 47243: bool DumpSymbols::ReadCFI(google_breakpad::Module *module,
 47243:                           const mach_o::Reader &macho_reader,
 47243:                           const mach_o::Section &section,
 47243:                           bool eh_frame) const {
 47243:   // Find the appropriate set of register names for this file's
 47243:   // architecture.
 47243:   vector<string> register_names;
 47243:   switch (macho_reader.cpu_type()) {
 47243:     case CPU_TYPE_X86:
 47243:       register_names = DwarfCFIToModule::RegisterNames::I386();
 47243:       break;
 47243:     case CPU_TYPE_X86_64:
 47243:       register_names = DwarfCFIToModule::RegisterNames::X86_64();
 47243:       break;
 47243:     case CPU_TYPE_ARM:
 47243:       register_names = DwarfCFIToModule::RegisterNames::ARM();
 47243:       break;
 47243:     default: {
118328:       const NXArchInfo *arch = google_breakpad::BreakpadGetArchInfoFromCpuType(
118328:           macho_reader.cpu_type(), macho_reader.cpu_subtype());
 47243:       fprintf(stderr, "%s: cannot convert DWARF call frame information for ",
 47243:               selected_object_name_.c_str());
 47243:       if (arch)
 47243:         fprintf(stderr, "architecture '%s'", arch->name);
 47243:       else
 47243:         fprintf(stderr, "architecture %d,%d",
 47243:                 macho_reader.cpu_type(), macho_reader.cpu_subtype());
 47243:       fprintf(stderr, " to Breakpad symbol file: no register name table\n");
 47243:       return false;
 47243:     }
 22509:   }
 22509: 
 47243:   // Find the call frame information and its size.
 47243:   const char *cfi = reinterpret_cast<const char *>(section.contents.start);
 47243:   size_t cfi_size = section.contents.Size();
 47243: 
 47243:   // Plug together the parser, handler, and their entourages.
 47243:   DwarfCFIToModule::Reporter module_reporter(selected_object_name_,
 47243:                                              section.section_name);
 47243:   DwarfCFIToModule handler(module, register_names, &module_reporter);
 47243:   dwarf2reader::ByteReader byte_reader(macho_reader.big_endian() ?
 47243:                                        dwarf2reader::ENDIANNESS_BIG :
 47243:                                        dwarf2reader::ENDIANNESS_LITTLE);
 47243:   byte_reader.SetAddressSize(macho_reader.bits_64() ? 8 : 4);
 47243:   // At the moment, according to folks at Apple and some cursory
 47243:   // investigation, Mac OS X only uses DW_EH_PE_pcrel-based pointers, so
 47243:   // this is the only base address the CFI parser will need.
 47243:   byte_reader.SetCFIDataBase(section.address, cfi);
 47243: 
 47243:   dwarf2reader::CallFrameInfo::Reporter dwarf_reporter(selected_object_name_,
 47243:                                                        section.section_name);
 47243:   dwarf2reader::CallFrameInfo parser(cfi, cfi_size,
 47243:                                      &byte_reader, &handler, &dwarf_reporter,
 47243:                                      eh_frame);
 47243:   parser.Start();
 47243:   return true;
 22509: }
 22509: 
 47243: // A LoadCommandHandler that loads whatever debugging data it finds into a
 47243: // Module.
 47243: class DumpSymbols::LoadCommandDumper:
 47243:       public mach_o::Reader::LoadCommandHandler {
 47243:  public:
 47243:   // Create a load command dumper handling load commands from READER's
 47243:   // file, and adding data to MODULE.
 47243:   LoadCommandDumper(const DumpSymbols &dumper,
 47243:                     google_breakpad::Module *module,
 47243:                     const mach_o::Reader &reader)
 47243:       : dumper_(dumper), module_(module), reader_(reader) { }
 22509: 
 47243:   bool SegmentCommand(const mach_o::Segment &segment);
 47243:   bool SymtabCommand(const ByteBuffer &entries, const ByteBuffer &strings);
 22509: 
 47243:  private:
 47243:   const DumpSymbols &dumper_;
 47243:   google_breakpad::Module *module_;  // WEAK
 47243:   const mach_o::Reader &reader_;
 47243: };
 22509: 
 47243: bool DumpSymbols::LoadCommandDumper::SegmentCommand(const Segment &segment) {
 47243:   mach_o::SectionMap section_map;
 47243:   if (!reader_.MapSegmentSections(segment, &section_map))
 47243:     return false;
 22509: 
 47243:   if (segment.name == "__TEXT") {
 47243:     module_->SetLoadAddress(segment.vmaddr);
 47243:     mach_o::SectionMap::const_iterator eh_frame =
 47243:         section_map.find("__eh_frame");
 47243:     if (eh_frame != section_map.end()) {
 47243:       // If there is a problem reading this, don't treat it as a fatal error.
 47243:       dumper_.ReadCFI(module_, reader_, eh_frame->second, true);
 47243:     }
 47243:     return true;
 22509:   }
 22509: 
 47243:   if (segment.name == "__DWARF") {
 47243:     if (!dumper_.ReadDwarf(module_, reader_, section_map))
 47243:       return false;
 47243:     mach_o::SectionMap::const_iterator debug_frame
 47243:         = section_map.find("__debug_frame");
 47243:     if (debug_frame != section_map.end()) {
 47243:       // If there is a problem reading this, don't treat it as a fatal error.
 47243:       dumper_.ReadCFI(module_, reader_, debug_frame->second, false);
 47243:     }
 22509:   }
 22509: 
 47243:   return true;
 22509: }
 22509: 
 47243: bool DumpSymbols::LoadCommandDumper::SymtabCommand(const ByteBuffer &entries,
 47243:                                                    const ByteBuffer &strings) {
 47243:   StabsToModule stabs_to_module(module_);
 47243:   // Mac OS X STABS are never "unitized", and the size of the 'value' field
 47243:   // matches the address size of the executable.
 47243:   StabsReader stabs_reader(entries.start, entries.Size(),
 47243:                            strings.start, strings.Size(),
 47243:                            reader_.big_endian(),
 47243:                            reader_.bits_64() ? 8 : 4,
 47243:                            true,
 47243:                            &stabs_to_module);
 47243:   if (!stabs_reader.Process())
 47243:     return false;
 47243:   stabs_to_module.Finalize();
 47243:   return true;
 22509: }
 22509: 
114869: bool DumpSymbols::WriteSymbolFile(std::ostream &stream, bool cfi) {
 47243:   // Select an object file, if SetArchitecture hasn't been called to set one
 47243:   // explicitly.
 47243:   if (!selected_object_file_) {
 47243:     // If there's only one architecture, that's the one.
 47243:     if (object_files_.size() == 1)
 47243:       selected_object_file_ = &object_files_[0];
 47243:     else {
 47243:       // Look for an object file whose architecture matches our own.
 47243:       const NXArchInfo *local_arch = NXGetLocalArchInfo();
 47243:       if (!SetArchitecture(local_arch->cputype, local_arch->cpusubtype)) {
 47243:         fprintf(stderr, "%s: object file contains more than one"
 47243:                 " architecture, none of which match the current"
 47243:                 " architecture; specify an architecture explicitly"
 47243:                 " with '-a ARCH' to resolve the ambiguity\n",
 47243:                 [object_filename_ fileSystemRepresentation]);
 47243:         return false;
 47243:       }
 47243:     }
 22509:   }
 22509: 
 47243:   assert(selected_object_file_);
 47243: 
 47243:   // Find the name of the selected file's architecture, to appear in
 47243:   // the MODULE record and in error messages.
118328:   const NXArchInfo *selected_arch_info =
118328:       google_breakpad::BreakpadGetArchInfoFromCpuType(
118328:           selected_object_file_->cputype, selected_object_file_->cpusubtype);
 47243: 
 50677:   const char *selected_arch_name = selected_arch_info->name;
 50677:   if (strcmp(selected_arch_name, "i386") == 0)
 50677:     selected_arch_name = "x86";
 50677: 
 47243:   // Produce a name to use in error messages that includes the
 47243:   // filename, and the architecture, if there is more than one.
 47243:   selected_object_name_ = [object_filename_ UTF8String];
 47243:   if (object_files_.size() > 1) {
 47243:     selected_object_name_ += ", architecture ";
 50677:     selected_object_name_ + selected_arch_name;
 22509:   }
 22509: 
 47243:   // Compute a module name, to appear in the MODULE record.
 47243:   NSString *module_name = [object_filename_ lastPathComponent];
 47243: 
 47243:   // Choose an identifier string, to appear in the MODULE record.
 47243:   string identifier = Identifier();
 47243:   if (identifier.empty())
 47243:     return false;
 47243:   identifier += "0";
 47243: 
 47243:   // Create a module to hold the debugging information.
 50677:   Module module([module_name UTF8String], "mac", selected_arch_name,
 47243:                 identifier);
 47243: 
 47243:   // Parse the selected object file.
 47243:   mach_o::Reader::Reporter reporter(selected_object_name_);
 47243:   mach_o::Reader reader(&reporter);
 47243:   if (!reader.Read(reinterpret_cast<const uint8_t *>([contents_ bytes])
 47243:                    + selected_object_file_->offset,
 47243:                    selected_object_file_->size,
 47243:                    selected_object_file_->cputype,
 47243:                    selected_object_file_->cpusubtype))
 47243:     return false;
 47243: 
 47243:   // Walk its load commands, and deal with whatever is there.
 47243:   LoadCommandDumper load_command_dumper(*this, &module, reader);
 47243:   if (!reader.WalkLoadCommands(&load_command_dumper))
 47243:     return false;
 47243: 
114869:   return module.Write(stream, cfi);
 22511: }
 22511: 
 47243: }  // namespace google_breakpad
