71297: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
71297:  * vim: set ts=8 sw=4 et tw=99 ft=cpp:
71297:  *
71297:  * ***** BEGIN LICENSE BLOCK *****
71297:  * Copyright (C) 2009 Apple Inc. All rights reserved.
71297:  *
71297:  * Redistribution and use in source and binary forms, with or without
71297:  * modification, are permitted provided that the following conditions
71297:  * are met:
71297:  * 1. Redistributions of source code must retain the above copyright
71297:  *    notice, this list of conditions and the following disclaimer.
71297:  * 2. Redistributions in binary form must reproduce the above copyright
71297:  *    notice, this list of conditions and the following disclaimer in the
71297:  *    documentation and/or other materials provided with the distribution.
71297:  *
71297:  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
71297:  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
71297:  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
71297:  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
71297:  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
71297:  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
71297:  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
71297:  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
71297:  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
71297:  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
71297:  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
71297:  *
71297:  * ***** END LICENSE BLOCK ***** */
71297: 
71297: #include "YarrJIT.h"
71297: 
71297: #include "assembler/assembler/LinkBuffer.h"
71297: #include "Yarr.h"
71297: 
71297: #if ENABLE_YARR_JIT
71297: 
71297: using namespace WTF;
71297: 
71297: namespace JSC { namespace Yarr {
71297: 
71297: class YarrGenerator : private MacroAssembler {
71297:     friend void jitCompile(JSGlobalData*, YarrCodeBlock& jitObject, const UString& pattern, unsigned& numSubpatterns, const char*& error, bool ignoreCase, bool multiline);
71297: 
71297: #if WTF_CPU_ARM
71297:     static const RegisterID input = ARMRegisters::r0;
71297:     static const RegisterID index = ARMRegisters::r1;
71297:     static const RegisterID length = ARMRegisters::r2;
71297:     static const RegisterID output = ARMRegisters::r4;
71297: 
71297:     static const RegisterID regT0 = ARMRegisters::r5;
71297:     static const RegisterID regT1 = ARMRegisters::r6;
71297: 
71297:     static const RegisterID returnRegister = ARMRegisters::r0;
71297: #elif WTF_CPU_MIPS
71297:     static const RegisterID input = MIPSRegisters::a0;
71297:     static const RegisterID index = MIPSRegisters::a1;
71297:     static const RegisterID length = MIPSRegisters::a2;
71297:     static const RegisterID output = MIPSRegisters::a3;
71297: 
71297:     static const RegisterID regT0 = MIPSRegisters::t4;
71297:     static const RegisterID regT1 = MIPSRegisters::t5;
71297: 
71297:     static const RegisterID returnRegister = MIPSRegisters::v0;
71297: #elif WTF_CPU_SH4
71297:     static const RegisterID input = SH4Registers::r4;
71297:     static const RegisterID index = SH4Registers::r5;
71297:     static const RegisterID length = SH4Registers::r6;
71297:     static const RegisterID output = SH4Registers::r7;
71297: 
71297:     static const RegisterID regT0 = SH4Registers::r0;
71297:     static const RegisterID regT1 = SH4Registers::r1;
71297: 
71297:     static const RegisterID returnRegister = SH4Registers::r0;
73085: #elif WTF_CPU_SPARC
73085:     static const RegisterID input = SparcRegisters::i0;
73085:     static const RegisterID index = SparcRegisters::i1;
73085:     static const RegisterID length = SparcRegisters::i2;
73085:     static const RegisterID output = SparcRegisters::i3;
73085: 
73085:     static const RegisterID regT0 = SparcRegisters::i4;
73085:     static const RegisterID regT1 = SparcRegisters::i5;
73085: 
73085:     static const RegisterID returnRegister = SparcRegisters::i0;
71297: #elif WTF_CPU_X86
71297:     static const RegisterID input = X86Registers::eax;
71297:     static const RegisterID index = X86Registers::edx;
71297:     static const RegisterID length = X86Registers::ecx;
71297:     static const RegisterID output = X86Registers::edi;
71297: 
71297:     static const RegisterID regT0 = X86Registers::ebx;
71297:     static const RegisterID regT1 = X86Registers::esi;
71297: 
71297:     static const RegisterID returnRegister = X86Registers::eax;
71297: #elif WTF_CPU_X86_64
71351: #if WTF_PLATFORM_WIN
71351:     static const RegisterID input = X86Registers::ecx;
71351:     static const RegisterID index = X86Registers::edx;
71351:     static const RegisterID length = X86Registers::r8;
71351:     static const RegisterID output = X86Registers::r9;
71351: #else
71297:     static const RegisterID input = X86Registers::edi;
71297:     static const RegisterID index = X86Registers::esi;
71297:     static const RegisterID length = X86Registers::edx;
71297:     static const RegisterID output = X86Registers::ecx;
71351: #endif
71297: 
71297:     static const RegisterID regT0 = X86Registers::eax;
71297:     static const RegisterID regT1 = X86Registers::ebx;
71297: 
71297:     static const RegisterID returnRegister = X86Registers::eax;
71297: #endif
71297: 
71297:     void optimizeAlternative(PatternAlternative* alternative)
71297:     {
71297:         if (!alternative->m_terms.size())
71297:             return;
71297: 
71297:         for (unsigned i = 0; i < alternative->m_terms.size() - 1; ++i) {
71297:             PatternTerm& term = alternative->m_terms[i];
71297:             PatternTerm& nextTerm = alternative->m_terms[i + 1];
71297: 
71297:             if ((term.type == PatternTerm::TypeCharacterClass)
71297:                 && (term.quantityType == QuantifierFixedCount)
71297:                 && (nextTerm.type == PatternTerm::TypePatternCharacter)
71297:                 && (nextTerm.quantityType == QuantifierFixedCount)) {
71297:                 PatternTerm termCopy = term;
71297:                 alternative->m_terms[i] = nextTerm;
71297:                 alternative->m_terms[i + 1] = termCopy;
71297:             }
71297:         }
71297:     }
71297: 
71297:     void matchCharacterClassRange(RegisterID character, JumpList& failures, JumpList& matchDest, const CharacterRange* ranges, unsigned count, unsigned* matchIndex, const UChar* matches, unsigned matchCount)
71297:     {
71297:         do {
71297:             // pick which range we're going to generate
71297:             int which = count >> 1;
71297:             char lo = ranges[which].begin;
71297:             char hi = ranges[which].end;
71297: 
71297:             // check if there are any ranges or matches below lo.  If not, just jl to failure -
71297:             // if there is anything else to check, check that first, if it falls through jmp to failure.
71297:             if ((*matchIndex < matchCount) && (matches[*matchIndex] < lo)) {
71297:                 Jump loOrAbove = branch32(GreaterThanOrEqual, character, Imm32((unsigned short)lo));
71297: 
71297:                 // generate code for all ranges before this one
71297:                 if (which)
71297:                     matchCharacterClassRange(character, failures, matchDest, ranges, which, matchIndex, matches, matchCount);
71297: 
71297:                 while ((*matchIndex < matchCount) && (matches[*matchIndex] < lo)) {
71297:                     matchDest.append(branch32(Equal, character, Imm32((unsigned short)matches[*matchIndex])));
71297:                     ++*matchIndex;
71297:                 }
71297:                 failures.append(jump());
71297: 
71297:                 loOrAbove.link(this);
71297:             } else if (which) {
71297:                 Jump loOrAbove = branch32(GreaterThanOrEqual, character, Imm32((unsigned short)lo));
71297: 
71297:                 matchCharacterClassRange(character, failures, matchDest, ranges, which, matchIndex, matches, matchCount);
71297:                 failures.append(jump());
71297: 
71297:                 loOrAbove.link(this);
71297:             } else
71297:                 failures.append(branch32(LessThan, character, Imm32((unsigned short)lo)));
71297: 
71297:             while ((*matchIndex < matchCount) && (matches[*matchIndex] <= hi))
71297:                 ++*matchIndex;
71297: 
71297:             matchDest.append(branch32(LessThanOrEqual, character, Imm32((unsigned short)hi)));
71297:             // fall through to here, the value is above hi.
71297: 
71297:             // shuffle along & loop around if there are any more matches to handle.
71297:             unsigned next = which + 1;
71297:             ranges += next;
71297:             count -= next;
71297:         } while (count);
71297:     }
71297: 
71297:     void matchCharacterClass(RegisterID character, JumpList& matchDest, const CharacterClass* charClass)
71297:     {
71297:         if (charClass->m_table) {
71297:             ExtendedAddress tableEntry(character, reinterpret_cast<intptr_t>(charClass->m_table->m_table));
71297:             matchDest.append(branchTest8(charClass->m_table->m_inverted ? Zero : NonZero, tableEntry));
71297:             return;
71297:         }
71297:         Jump unicodeFail;
71297:         if (charClass->m_matchesUnicode.size() || charClass->m_rangesUnicode.size()) {
71297:             Jump isAscii = branch32(LessThanOrEqual, character, TrustedImm32(0x7f));
71297: 
71297:             if (charClass->m_matchesUnicode.size()) {
71297:                 for (unsigned i = 0; i < charClass->m_matchesUnicode.size(); ++i) {
71297:                     UChar ch = charClass->m_matchesUnicode[i];
71297:                     matchDest.append(branch32(Equal, character, Imm32(ch)));
71297:                 }
71297:             }
71297: 
71297:             if (charClass->m_rangesUnicode.size()) {
71297:                 for (unsigned i = 0; i < charClass->m_rangesUnicode.size(); ++i) {
71297:                     UChar lo = charClass->m_rangesUnicode[i].begin;
71297:                     UChar hi = charClass->m_rangesUnicode[i].end;
71297: 
71297:                     Jump below = branch32(LessThan, character, Imm32(lo));
71297:                     matchDest.append(branch32(LessThanOrEqual, character, Imm32(hi)));
71297:                     below.link(this);
71297:                 }
71297:             }
71297: 
71297:             unicodeFail = jump();
71297:             isAscii.link(this);
71297:         }
71297: 
71297:         if (charClass->m_ranges.size()) {
71297:             unsigned matchIndex = 0;
71297:             JumpList failures;
71297:             matchCharacterClassRange(character, failures, matchDest, charClass->m_ranges.begin(), charClass->m_ranges.size(), &matchIndex, charClass->m_matches.begin(), charClass->m_matches.size());
71297:             while (matchIndex < charClass->m_matches.size())
71297:                 matchDest.append(branch32(Equal, character, Imm32((unsigned short)charClass->m_matches[matchIndex++])));
71297: 
71297:             failures.link(this);
71297:         } else if (charClass->m_matches.size()) {
71297:             // optimization: gather 'a','A' etc back together, can mask & test once.
71297:             Vector<char> matchesAZaz;
71297: 
71297:             for (unsigned i = 0; i < charClass->m_matches.size(); ++i) {
71297:                 char ch = charClass->m_matches[i];
71297:                 if (m_pattern.m_ignoreCase) {
71297:                     if (isASCIILower(ch)) {
71297:                         matchesAZaz.append(ch);
71297:                         continue;
71297:                     }
71297:                     if (isASCIIUpper(ch))
71297:                         continue;
71297:                 }
71297:                 matchDest.append(branch32(Equal, character, Imm32((unsigned short)ch)));
71297:             }
71297: 
71297:             if (unsigned countAZaz = matchesAZaz.size()) {
71297:                 or32(TrustedImm32(32), character);
71297:                 for (unsigned i = 0; i < countAZaz; ++i)
71297:                     matchDest.append(branch32(Equal, character, TrustedImm32(matchesAZaz[i])));
71297:             }
71297:         }
71297: 
71297:         if (charClass->m_matchesUnicode.size() || charClass->m_rangesUnicode.size())
71297:             unicodeFail.link(this);
71297:     }
71297: 
71297:     // Jumps if input not available; will have (incorrectly) incremented already!
71297:     Jump jumpIfNoAvailableInput(unsigned countToCheck = 0)
71297:     {
71297:         if (countToCheck)
71297:             add32(Imm32(countToCheck), index);
71297:         return branch32(Above, index, length);
71297:     }
71297: 
71297:     Jump jumpIfAvailableInput(unsigned countToCheck)
71297:     {
71297:         add32(Imm32(countToCheck), index);
71297:         return branch32(BelowOrEqual, index, length);
71297:     }
71297: 
71297:     Jump checkInput()
71297:     {
71297:         return branch32(BelowOrEqual, index, length);
71297:     }
71297: 
71297:     Jump atEndOfInput()
71297:     {
71297:         return branch32(Equal, index, length);
71297:     }
71297: 
71297:     Jump notAtEndOfInput()
71297:     {
71297:         return branch32(NotEqual, index, length);
71297:     }
71297: 
71297:     Jump jumpIfCharEquals(UChar ch, int inputPosition)
71297:     {
71297:         return branch16(Equal, BaseIndex(input, index, TimesTwo, inputPosition * sizeof(UChar)), Imm32(ch));
71297:     }
71297: 
71297:     Jump jumpIfCharNotEquals(UChar ch, int inputPosition)
71297:     {
71297:         return branch16(NotEqual, BaseIndex(input, index, TimesTwo, inputPosition * sizeof(UChar)), Imm32(ch));
71297:     }
71297: 
71297:     void readCharacter(int inputPosition, RegisterID reg)
71297:     {
71297:         load16(BaseIndex(input, index, TimesTwo, inputPosition * sizeof(UChar)), reg);
71297:     }
71297: 
71297:     void storeToFrame(RegisterID reg, unsigned frameLocation)
71297:     {
71297:         poke(reg, frameLocation);
71297:     }
71297: 
71297:     void storeToFrame(TrustedImm32 imm, unsigned frameLocation)
71297:     {
71297:         poke(imm, frameLocation);
71297:     }
71297: 
71297:     DataLabelPtr storeToFrameWithPatch(unsigned frameLocation)
71297:     {
71297:         return storePtrWithPatch(TrustedImmPtr(0), Address(stackPointerRegister, frameLocation * sizeof(void*)));
71297:     }
71297: 
71297:     void loadFromFrame(unsigned frameLocation, RegisterID reg)
71297:     {
71297:         peek(reg, frameLocation);
71297:     }
71297: 
71297:     void loadFromFrameAndJump(unsigned frameLocation)
71297:     {
71297:         jump(Address(stackPointerRegister, frameLocation * sizeof(void*)));
71297:     }
71297: 
71297:     enum YarrOpCode {
71297:         // These nodes wrap body alternatives - those in the main disjunction,
71297:         // rather than subpatterns or assertions. These are chained together in
71297:         // a doubly linked list, with a 'begin' node for the first alternative,
71297:         // a 'next' node for each subsequent alternative, and an 'end' node at
71297:         // the end. In the case of repeating alternatives, the 'end' node also
71297:         // has a reference back to 'begin'.
71297:         OpBodyAlternativeBegin,
71297:         OpBodyAlternativeNext,
71297:         OpBodyAlternativeEnd,
71297:         // Similar to the body alternatives, but used for subpatterns with two
71297:         // or more alternatives.
71297:         OpNestedAlternativeBegin,
71297:         OpNestedAlternativeNext,
71297:         OpNestedAlternativeEnd,
71297:         // Used for alternatives in subpatterns where there is only a single
71297:         // alternative (backtrackingis easier in these cases), or for alternatives
71297:         // which never need to be backtracked (those in parenthetical assertions,
71297:         // terminal subpatterns).
71297:         OpSimpleNestedAlternativeBegin,
71297:         OpSimpleNestedAlternativeNext,
71297:         OpSimpleNestedAlternativeEnd,
71297:         // Used to wrap 'Once' subpattern matches (quantityCount == 1).
71297:         OpParenthesesSubpatternOnceBegin,
71297:         OpParenthesesSubpatternOnceEnd,
71297:         // Used to wrap 'Terminal' subpattern matches (at the end of the regexp).
71297:         OpParenthesesSubpatternTerminalBegin,
71297:         OpParenthesesSubpatternTerminalEnd,
71297:         // Used to wrap parenthetical assertions.
71297:         OpParentheticalAssertionBegin,
71297:         OpParentheticalAssertionEnd,
71297:         // Wraps all simple terms (pattern characters, character classes).
71297:         OpTerm,
71297:         // Where an expression contains only 'once through' body alternatives
71297:         // and no repeating ones, this op is used to return match failure.
71297:         OpMatchFailed
71297:     };
71297: 
71297:     // This structure is used to hold the compiled opcode information,
71297:     // including reference back to the original PatternTerm/PatternAlternatives,
71297:     // and JIT compilation data structures.
71297:     struct YarrOp {
71297:         explicit YarrOp(PatternTerm* term)
71297:             : m_op(OpTerm)
71297:             , m_term(term)
71297:             , m_isDeadCode(false)
71297:         {
71297:         }
71297: 
71297:         explicit YarrOp(YarrOpCode op)
71297:             : m_op(op)
71297:             , m_isDeadCode(false)
71297:         {
71297:         }
71297: 
71297:         // The operation, as a YarrOpCode, and also a reference to the PatternTerm.
71297:         YarrOpCode m_op;
71297:         PatternTerm* m_term;
71297: 
71297:         // For alternatives, this holds the PatternAlternative and doubly linked
71297:         // references to this alternative's siblings. In the case of the
71297:         // OpBodyAlternativeEnd node at the end of a section of repeating nodes,
71297:         // m_nextOp will reference the OpBodyAlternativeBegin node of the first
71297:         // repeating alternative.
71297:         PatternAlternative* m_alternative;
71297:         size_t m_previousOp;
71297:         size_t m_nextOp;
71297: 
71297:         // Used to record a set of Jumps out of the generated code, typically
71297:         // used for jumps out to backtracking code, and a single reentry back
71297:         // into the code for a node (likely where a backtrack will trigger
71297:         // rematching).
71297:         Label m_reentry;
71297:         JumpList m_jumps;
71297: 
71297:         // This flag is used to null out the second pattern character, when
71297:         // two are fused to match a pair together.
71297:         bool m_isDeadCode;
71297: 
71297:         // Currently used in the case of some of the more complex management of
71297:         // 'm_checked', to cache the offset used in this alternative, to avoid
71297:         // recalculating it.
71297:         int m_checkAdjust;
71297: 
71297:         // Used by OpNestedAlternativeNext/End to hold the pointer to the
71297:         // value that will be pushed into the pattern's frame to return to,
71297:         // upon backtracking back into the disjunction.
71297:         DataLabelPtr m_returnAddress;
71297:     };
71297: 
71297:     // BacktrackingState
71297:     // This class encapsulates information about the state of code generation
71297:     // whilst generating the code for backtracking, when a term fails to match.
71297:     // Upon entry to code generation of the backtracking code for a given node,
71297:     // the Backtracking state will hold references to all control flow sources
71297:     // that are outputs in need of further backtracking from the prior node
71297:     // generated (which is the subsequent operation in the regular expression,
71297:     // and in the m_ops Vector, since we generated backtracking backwards).
71297:     // These references to control flow take the form of:
71297:     //  - A jump list of jumps, to be linked to code that will backtrack them
71297:     //    further.
71297:     //  - A set of DataLabelPtr values, to be populated with values to be
71297:     //    treated effectively as return addresses backtracking into complex
71297:     //    subpatterns.
71297:     //  - A flag indicating that the current sequence of generated code up to
71297:     //    this point requires backtracking.
71297:     class BacktrackingState {
71297:     public:
71297:         BacktrackingState()
71297:             : m_pendingFallthrough(false)
71297:         {
71297:         }
71297: 
71297:         // Add a jump or jumps, a return address, or set the flag indicating
71297:         // that the current 'fallthrough' control flow requires backtracking.
71297:         void append(const Jump& jump)
71297:         {
71297:             m_laterFailures.append(jump);
71297:         }
71297:         void append(JumpList& jumpList)
71297:         {
71297:             m_laterFailures.append(jumpList);
71297:         }
71297:         void append(const DataLabelPtr& returnAddress)
71297:         {
71297:             m_pendingReturns.append(returnAddress);
71297:         }
71297:         void fallthrough()
71297:         {
71297:             ASSERT(!m_pendingFallthrough);
71297:             m_pendingFallthrough = true;
71297:         }
71297: 
71297:         // These methods clear the backtracking state, either linking to the
71297:         // current location, a provided label, or copying the backtracking out
71297:         // to a JumpList. All actions may require code generation to take place,
71297:         // and as such are passed a pointer to the assembler.
71297:         void link(MacroAssembler* assembler)
71297:         {
71297:             if (m_pendingReturns.size()) {
71297:                 Label here(assembler);
71297:                 for (unsigned i = 0; i < m_pendingReturns.size(); ++i)
71297:                     m_backtrackRecords.append(ReturnAddressRecord(m_pendingReturns[i], here));
71297:                 m_pendingReturns.clear();
71297:             }
71297:             m_laterFailures.link(assembler);
71297:             m_laterFailures.clear();
71297:             m_pendingFallthrough = false;
71297:         }
71297:         void linkTo(Label label, MacroAssembler* assembler)
71297:         {
71297:             if (m_pendingReturns.size()) {
71297:                 for (unsigned i = 0; i < m_pendingReturns.size(); ++i)
71297:                     m_backtrackRecords.append(ReturnAddressRecord(m_pendingReturns[i], label));
71297:                 m_pendingReturns.clear();
71297:             }
71297:             if (m_pendingFallthrough)
71297:                 assembler->jump(label);
71297:             m_laterFailures.linkTo(label, assembler);
71297:             m_laterFailures.clear();
71297:             m_pendingFallthrough = false;
71297:         }
71297:         void takeBacktracksToJumpList(JumpList& jumpList, MacroAssembler* assembler)
71297:         {
71297:             if (m_pendingReturns.size()) {
71297:                 Label here(assembler);
71297:                 for (unsigned i = 0; i < m_pendingReturns.size(); ++i)
71297:                     m_backtrackRecords.append(ReturnAddressRecord(m_pendingReturns[i], here));
71297:                 m_pendingReturns.clear();
71297:                 m_pendingFallthrough = true;
71297:             }
71297:             if (m_pendingFallthrough)
71297:                 jumpList.append(assembler->jump());
71297:             jumpList.append(m_laterFailures);
71297:             m_laterFailures.clear();
71297:             m_pendingFallthrough = false;
71297:         }
71297: 
71297:         bool isEmpty()
71297:         {
71297:             return m_laterFailures.empty() && m_pendingReturns.isEmpty() && !m_pendingFallthrough;
71297:         }
71297: 
71297:         // Called at the end of code generation to link all return addresses.
71297:         void linkDataLabels(LinkBuffer& linkBuffer)
71297:         {
71297:             ASSERT(isEmpty());
71297:             for (unsigned i = 0; i < m_backtrackRecords.size(); ++i)
71297:                 linkBuffer.patch(m_backtrackRecords[i].m_dataLabel, linkBuffer.locationOf(m_backtrackRecords[i].m_backtrackLocation));
71297:         }
71297: 
71297:     private:
71297:         struct ReturnAddressRecord {
71297:             ReturnAddressRecord(DataLabelPtr dataLabel, Label backtrackLocation)
71297:                 : m_dataLabel(dataLabel)
71297:                 , m_backtrackLocation(backtrackLocation)
71297:             {
71297:             }
71297: 
71297:             DataLabelPtr m_dataLabel;
71297:             Label m_backtrackLocation;
71297:         };
71297: 
71297:         JumpList m_laterFailures;
71297:         bool m_pendingFallthrough;
71297:         Vector<DataLabelPtr, 4> m_pendingReturns;
71297:         Vector<ReturnAddressRecord, 4> m_backtrackRecords;
71297:     };
71297: 
71297:     // Generation methods:
71297:     // ===================
71297: 
71297:     // This method provides a default implementation of backtracking common
71297:     // to many terms; terms commonly jump out of the forwards  matching path
71297:     // on any failed conditions, and add these jumps to the m_jumps list. If
71297:     // no special handling is required we can often just backtrack to m_jumps.
71297:     void backtrackTermDefault(size_t opIndex)
71297:     {
71297:         YarrOp& op = m_ops[opIndex];
71297:         m_backtrackingState.append(op.m_jumps);
71297:     }
71297: 
71297:     void generateAssertionBOL(size_t opIndex)
71297:     {
71297:         YarrOp& op = m_ops[opIndex];
71297:         PatternTerm* term = op.m_term;
71297: 
71297:         if (m_pattern.m_multiline) {
71297:             const RegisterID character = regT0;
71297: 
71297:             JumpList matchDest;
71297:             if (!term->inputPosition)
71297:                 matchDest.append(branch32(Equal, index, Imm32(m_checked)));
71297: 
71297:             readCharacter((term->inputPosition - m_checked) - 1, character);
71297:             matchCharacterClass(character, matchDest, m_pattern.newlineCharacterClass());
71297:             op.m_jumps.append(jump());
71297: 
71297:             matchDest.link(this);
71297:         } else {
71297:             // Erk, really should poison out these alternatives early. :-/
71297:             if (term->inputPosition)
71297:                 op.m_jumps.append(jump());
71297:             else
71297:                 op.m_jumps.append(branch32(NotEqual, index, Imm32(m_checked)));
71297:         }
71297:     }
71297:     void backtrackAssertionBOL(size_t opIndex)
71297:     {
71297:         backtrackTermDefault(opIndex);
71297:     }
71297: 
71297:     void generateAssertionEOL(size_t opIndex)
71297:     {
71297:         YarrOp& op = m_ops[opIndex];
71297:         PatternTerm* term = op.m_term;
71297: 
71297:         if (m_pattern.m_multiline) {
71297:             const RegisterID character = regT0;
71297: 
71297:             JumpList matchDest;
71297:             if (term->inputPosition == m_checked)
71297:                 matchDest.append(atEndOfInput());
71297: 
71297:             readCharacter((term->inputPosition - m_checked), character);
71297:             matchCharacterClass(character, matchDest, m_pattern.newlineCharacterClass());
71297:             op.m_jumps.append(jump());
71297: 
71297:             matchDest.link(this);
71297:         } else {
71297:             if (term->inputPosition == m_checked)
71297:                 op.m_jumps.append(notAtEndOfInput());
71297:             // Erk, really should poison out these alternatives early. :-/
71297:             else
71297:                 op.m_jumps.append(jump());
71297:         }
71297:     }
71297:     void backtrackAssertionEOL(size_t opIndex)
71297:     {
71297:         backtrackTermDefault(opIndex);
71297:     }
71297: 
71297:     // Also falls though on nextIsNotWordChar.
71297:     void matchAssertionWordchar(size_t opIndex, JumpList& nextIsWordChar, JumpList& nextIsNotWordChar)
71297:     {
71297:         YarrOp& op = m_ops[opIndex];
71297:         PatternTerm* term = op.m_term;
71297: 
71297:         const RegisterID character = regT0;
71297: 
71297:         if (term->inputPosition == m_checked)
71297:             nextIsNotWordChar.append(atEndOfInput());
71297: 
71297:         readCharacter((term->inputPosition - m_checked), character);
71297:         matchCharacterClass(character, nextIsWordChar, m_pattern.wordcharCharacterClass());
71297:     }
71297: 
71297:     void generateAssertionWordBoundary(size_t opIndex)
71297:     {
71297:         YarrOp& op = m_ops[opIndex];
71297:         PatternTerm* term = op.m_term;
71297: 
71297:         const RegisterID character = regT0;
71297: 
71297:         Jump atBegin;
71297:         JumpList matchDest;
71297:         if (!term->inputPosition)
71297:             atBegin = branch32(Equal, index, Imm32(m_checked));
71297:         readCharacter((term->inputPosition - m_checked) - 1, character);
71297:         matchCharacterClass(character, matchDest, m_pattern.wordcharCharacterClass());
71297:         if (!term->inputPosition)
71297:             atBegin.link(this);
71297: 
71297:         // We fall through to here if the last character was not a wordchar.
71297:         JumpList nonWordCharThenWordChar;
71297:         JumpList nonWordCharThenNonWordChar;
71297:         if (term->invert()) {
71297:             matchAssertionWordchar(opIndex, nonWordCharThenNonWordChar, nonWordCharThenWordChar);
71297:             nonWordCharThenWordChar.append(jump());
71297:         } else {
71297:             matchAssertionWordchar(opIndex, nonWordCharThenWordChar, nonWordCharThenNonWordChar);
71297:             nonWordCharThenNonWordChar.append(jump());
71297:         }
71297:         op.m_jumps.append(nonWordCharThenNonWordChar);
71297: 
71297:         // We jump here if the last character was a wordchar.
71297:         matchDest.link(this);
71297:         JumpList wordCharThenWordChar;
71297:         JumpList wordCharThenNonWordChar;
71297:         if (term->invert()) {
71297:             matchAssertionWordchar(opIndex, wordCharThenNonWordChar, wordCharThenWordChar);
71297:             wordCharThenWordChar.append(jump());
71297:         } else {
71297:             matchAssertionWordchar(opIndex, wordCharThenWordChar, wordCharThenNonWordChar);
71297:             // This can fall-though!
71297:         }
71297: 
71297:         op.m_jumps.append(wordCharThenWordChar);
71297: 
71297:         nonWordCharThenWordChar.link(this);
71297:         wordCharThenNonWordChar.link(this);
71297:     }
71297:     void backtrackAssertionWordBoundary(size_t opIndex)
71297:     {
71297:         backtrackTermDefault(opIndex);
71297:     }
71297: 
71297:     void generatePatternCharacterOnce(size_t opIndex)
71297:     {
71297:         YarrOp& op = m_ops[opIndex];
71297: 
71297:         // m_ops always ends with a OpBodyAlternativeEnd or OpMatchFailed
71297:         // node, so there must always be at least one more node.
71297:         ASSERT(opIndex + 1 < m_ops.size());
71297:         YarrOp& nextOp = m_ops[opIndex + 1];
71297: 
71297:         if (op.m_isDeadCode)
71297:             return;
71297: 
71297:         PatternTerm* term = op.m_term;
71297:         UChar ch = term->patternCharacter;
71297: 
71297:         const RegisterID character = regT0;
71297: 
71297:         if (nextOp.m_op == OpTerm) {
71297:             PatternTerm* nextTerm = nextOp.m_term;
71297:             if (nextTerm->type == PatternTerm::TypePatternCharacter
71297:                 && nextTerm->quantityType == QuantifierFixedCount
71297:                 && nextTerm->quantityCount == 1
71297:                 && nextTerm->inputPosition == (term->inputPosition + 1)) {
71297: 
71297:                 UChar ch2 = nextTerm->patternCharacter;
71297: 
71297:                 int mask = 0;
73085: #if WTF_CPU_BIG_ENDIAN
73085:                 int chPair = ch2 | (ch << 16);
73085: #else
71297:                 int chPair = ch | (ch2 << 16);
73085: #endif
71297: 
71297:                 if (m_pattern.m_ignoreCase) {
71297:                     if (isASCIIAlpha(ch))
71297:                         mask |= 32;
71297:                     if (isASCIIAlpha(ch2))
71297:                         mask |= 32 << 16;
71297:                 }
71297: 
71297:                 BaseIndex address(input, index, TimesTwo, (term->inputPosition - m_checked) * sizeof(UChar));
71297:                 if (mask) {
71297:                     load32WithUnalignedHalfWords(address, character);
71297:                     or32(Imm32(mask), character);
71297:                     op.m_jumps.append(branch32(NotEqual, character, Imm32(chPair | mask)));
71297:                 } else
71297:                     op.m_jumps.append(branch32WithUnalignedHalfWords(NotEqual, address, Imm32(chPair)));
71297: 
71297:                 nextOp.m_isDeadCode = true;
71297:                 return;
71297:             }
71297:         }
71297: 
71297:         if (m_pattern.m_ignoreCase && isASCIIAlpha(ch)) {
71297:             readCharacter(term->inputPosition - m_checked, character);
71297:             or32(TrustedImm32(32), character);
71297:             op.m_jumps.append(branch32(NotEqual, character, Imm32(Unicode::toLower(ch))));
71297:         } else {
71297:             ASSERT(!m_pattern.m_ignoreCase || (Unicode::toLower(ch) == Unicode::toUpper(ch)));
71297:             op.m_jumps.append(jumpIfCharNotEquals(ch, term->inputPosition - m_checked));
71297:         }
71297:     }
71297:     void backtrackPatternCharacterOnce(size_t opIndex)
71297:     {
71297:         backtrackTermDefault(opIndex);
71297:     }
71297: 
71297:     void generatePatternCharacterFixed(size_t opIndex)
71297:     {
71297:         YarrOp& op = m_ops[opIndex];
71297:         PatternTerm* term = op.m_term;
71297:         UChar ch = term->patternCharacter;
71297: 
71297:         const RegisterID character = regT0;
71297:         const RegisterID countRegister = regT1;
71297: 
71297:         move(index, countRegister);
71297:         sub32(Imm32(term->quantityCount), countRegister);
71297: 
71297:         Label loop(this);
71297:         BaseIndex address(input, countRegister, TimesTwo, (term->inputPosition - m_checked + term->quantityCount) * sizeof(UChar));
71297: 
71297:         if (m_pattern.m_ignoreCase && isASCIIAlpha(ch)) {
71297:             load16(address, character);
71297:             or32(TrustedImm32(32), character);
71297:             op.m_jumps.append(branch32(NotEqual, character, Imm32(Unicode::toLower(ch))));
71297:         } else {
71297:             ASSERT(!m_pattern.m_ignoreCase || (Unicode::toLower(ch) == Unicode::toUpper(ch)));
71297:             op.m_jumps.append(branch16(NotEqual, address, Imm32(ch)));
71297:         }
71297:         add32(TrustedImm32(1), countRegister);
71297:         branch32(NotEqual, countRegister, index).linkTo(loop, this);
71297:     }
71297:     void backtrackPatternCharacterFixed(size_t opIndex)
71297:     {
71297:         backtrackTermDefault(opIndex);
71297:     }
71297: 
71297:     void generatePatternCharacterGreedy(size_t opIndex)
71297:     {
71297:         YarrOp& op = m_ops[opIndex];
71297:         PatternTerm* term = op.m_term;
71297:         UChar ch = term->patternCharacter;
71297: 
71297:         const RegisterID character = regT0;
71297:         const RegisterID countRegister = regT1;
71297: 
71297:         move(TrustedImm32(0), countRegister);
71297: 
71297:         JumpList failures;
71297:         Label loop(this);
71297:         failures.append(atEndOfInput());
71297:         if (m_pattern.m_ignoreCase && isASCIIAlpha(ch)) {
71297:             readCharacter(term->inputPosition - m_checked, character);
71297:             or32(TrustedImm32(32), character);
71297:             failures.append(branch32(NotEqual, character, Imm32(Unicode::toLower(ch))));
71297:         } else {
71297:             ASSERT(!m_pattern.m_ignoreCase || (Unicode::toLower(ch) == Unicode::toUpper(ch)));
71297:             failures.append(jumpIfCharNotEquals(ch, term->inputPosition - m_checked));
71297:         }
71297: 
71297:         add32(TrustedImm32(1), countRegister);
71297:         add32(TrustedImm32(1), index);
71297:         if (term->quantityCount == quantifyInfinite)
71297:             jump(loop);
71297:         else
71297:             branch32(NotEqual, countRegister, Imm32(term->quantityCount)).linkTo(loop, this);
71297: 
71297:         failures.link(this);
71297:         op.m_reentry = label();
71297: 
71297:         storeToFrame(countRegister, term->frameLocation);
71297: 
71297:     }
71297:     void backtrackPatternCharacterGreedy(size_t opIndex)
71297:     {
71297:         YarrOp& op = m_ops[opIndex];
71297:         PatternTerm* term = op.m_term;
71297: 
71297:         const RegisterID countRegister = regT1;
71297: 
71297:         m_backtrackingState.link(this);
71297: 
71297:         loadFromFrame(term->frameLocation, countRegister);
71297:         m_backtrackingState.append(branchTest32(Zero, countRegister));
71297:         sub32(TrustedImm32(1), countRegister);
71297:         sub32(TrustedImm32(1), index);
71297:         jump(op.m_reentry);
71297:     }
71297: 
71297:     void generatePatternCharacterNonGreedy(size_t opIndex)
71297:     {
71297:         YarrOp& op = m_ops[opIndex];
71297:         PatternTerm* term = op.m_term;
71297: 
71297:         const RegisterID countRegister = regT1;
71297: 
71297:         move(TrustedImm32(0), countRegister);
71297:         op.m_reentry = label();
71297:         storeToFrame(countRegister, term->frameLocation);
71297:     }
71297:     void backtrackPatternCharacterNonGreedy(size_t opIndex)
71297:     {
71297:         YarrOp& op = m_ops[opIndex];
71297:         PatternTerm* term = op.m_term;
71297:         UChar ch = term->patternCharacter;
71297: 
71297:         const RegisterID character = regT0;
71297:         const RegisterID countRegister = regT1;
71297: 
71297:         JumpList nonGreedyFailures;
71297: 
71297:         m_backtrackingState.link(this);
71297: 
71297:         loadFromFrame(term->frameLocation, countRegister);
71297: 
71297:         nonGreedyFailures.append(atEndOfInput());
71297:         if (term->quantityCount != quantifyInfinite)
71297:             nonGreedyFailures.append(branch32(Equal, countRegister, Imm32(term->quantityCount)));
71297:         if (m_pattern.m_ignoreCase && isASCIIAlpha(ch)) {
71297:             readCharacter(term->inputPosition - m_checked, character);
71297:             or32(TrustedImm32(32), character);
71297:             nonGreedyFailures.append(branch32(NotEqual, character, Imm32(Unicode::toLower(ch))));
71297:         } else {
71297:             ASSERT(!m_pattern.m_ignoreCase || (Unicode::toLower(ch) == Unicode::toUpper(ch)));
71297:             nonGreedyFailures.append(jumpIfCharNotEquals(ch, term->inputPosition - m_checked));
71297:         }
71297: 
71297:         add32(TrustedImm32(1), countRegister);
71297:         add32(TrustedImm32(1), index);
71297: 
71297:         jump(op.m_reentry);
71297: 
71297:         nonGreedyFailures.link(this);
71297:         sub32(countRegister, index);
71297:         m_backtrackingState.fallthrough();
71297:     }
71297: 
71297:     void generateCharacterClassOnce(size_t opIndex)
71297:     {
71297:         YarrOp& op = m_ops[opIndex];
71297:         PatternTerm* term = op.m_term;
71297: 
71297:         const RegisterID character = regT0;
71297: 
71297:         JumpList matchDest;
71297:         readCharacter((term->inputPosition - m_checked), character);
71297:         matchCharacterClass(character, matchDest, term->characterClass);
71297: 
71297:         if (term->invert())
71297:             op.m_jumps.append(matchDest);
71297:         else {
71297:             op.m_jumps.append(jump());
71297:             matchDest.link(this);
71297:         }
71297:     }
71297:     void backtrackCharacterClassOnce(size_t opIndex)
71297:     {
71297:         backtrackTermDefault(opIndex);
71297:     }
71297: 
71297:     void generateCharacterClassFixed(size_t opIndex)
71297:     {
71297:         YarrOp& op = m_ops[opIndex];
71297:         PatternTerm* term = op.m_term;
71297: 
71297:         const RegisterID character = regT0;
71297:         const RegisterID countRegister = regT1;
71297: 
71297:         move(index, countRegister);
71297:         sub32(Imm32(term->quantityCount), countRegister);
71297: 
71297:         Label loop(this);
71297:         JumpList matchDest;
71297:         load16(BaseIndex(input, countRegister, TimesTwo, (term->inputPosition - m_checked + term->quantityCount) * sizeof(UChar)), character);
71297:         matchCharacterClass(character, matchDest, term->characterClass);
71297: 
71297:         if (term->invert())
71297:             op.m_jumps.append(matchDest);
71297:         else {
71297:             op.m_jumps.append(jump());
71297:             matchDest.link(this);
71297:         }
71297: 
71297:         add32(TrustedImm32(1), countRegister);
71297:         branch32(NotEqual, countRegister, index).linkTo(loop, this);
71297:     }
71297:     void backtrackCharacterClassFixed(size_t opIndex)
71297:     {
71297:         backtrackTermDefault(opIndex);
71297:     }
71297: 
71297:     void generateCharacterClassGreedy(size_t opIndex)
71297:     {
71297:         YarrOp& op = m_ops[opIndex];
71297:         PatternTerm* term = op.m_term;
71297: 
71297:         const RegisterID character = regT0;
71297:         const RegisterID countRegister = regT1;
71297: 
71297:         move(TrustedImm32(0), countRegister);
71297: 
71297:         JumpList failures;
71297:         Label loop(this);
71297:         failures.append(atEndOfInput());
71297: 
71297:         if (term->invert()) {
71297:             readCharacter(term->inputPosition - m_checked, character);
71297:             matchCharacterClass(character, failures, term->characterClass);
71297:         } else {
71297:             JumpList matchDest;
71297:             readCharacter(term->inputPosition - m_checked, character);
71297:             matchCharacterClass(character, matchDest, term->characterClass);
71297:             failures.append(jump());
71297:             matchDest.link(this);
71297:         }
71297: 
71297:         add32(TrustedImm32(1), countRegister);
71297:         add32(TrustedImm32(1), index);
71297:         if (term->quantityCount != quantifyInfinite) {
71297:             branch32(NotEqual, countRegister, Imm32(term->quantityCount)).linkTo(loop, this);
71297:             failures.append(jump());
71297:         } else
71297:             jump(loop);
71297: 
71297:         failures.link(this);
71297:         op.m_reentry = label();
71297: 
71297:         storeToFrame(countRegister, term->frameLocation);
71297:     }
71297:     void backtrackCharacterClassGreedy(size_t opIndex)
71297:     {
71297:         YarrOp& op = m_ops[opIndex];
71297:         PatternTerm* term = op.m_term;
71297: 
71297:         const RegisterID countRegister = regT1;
71297: 
71297:         m_backtrackingState.link(this);
71297: 
71297:         loadFromFrame(term->frameLocation, countRegister);
71297:         m_backtrackingState.append(branchTest32(Zero, countRegister));
71297:         sub32(TrustedImm32(1), countRegister);
71297:         sub32(TrustedImm32(1), index);
71297:         jump(op.m_reentry);
71297:     }
71297: 
71297:     void generateCharacterClassNonGreedy(size_t opIndex)
71297:     {
71297:         YarrOp& op = m_ops[opIndex];
71297:         PatternTerm* term = op.m_term;
71297: 
71297:         const RegisterID countRegister = regT1;
71297: 
71297:         move(TrustedImm32(0), countRegister);
71297:         op.m_reentry = label();
71297:         storeToFrame(countRegister, term->frameLocation);
71297:     }
71297:     void backtrackCharacterClassNonGreedy(size_t opIndex)
71297:     {
71297:         YarrOp& op = m_ops[opIndex];
71297:         PatternTerm* term = op.m_term;
71297: 
71297:         const RegisterID character = regT0;
71297:         const RegisterID countRegister = regT1;
71297: 
71297:         JumpList nonGreedyFailures;
71297: 
71297:         m_backtrackingState.link(this);
71297: 
71297:         Label backtrackBegin(this);
71297:         loadFromFrame(term->frameLocation, countRegister);
71297: 
71297:         nonGreedyFailures.append(atEndOfInput());
71297:         nonGreedyFailures.append(branch32(Equal, countRegister, Imm32(term->quantityCount)));
71297: 
71297:         JumpList matchDest;
71297:         readCharacter(term->inputPosition - m_checked, character);
71297:         matchCharacterClass(character, matchDest, term->characterClass);
71297: 
71297:         if (term->invert())
71297:             nonGreedyFailures.append(matchDest);
71297:         else {
71297:             nonGreedyFailures.append(jump());
71297:             matchDest.link(this);
71297:         }
71297: 
71297:         add32(TrustedImm32(1), countRegister);
71297:         add32(TrustedImm32(1), index);
71297: 
71297:         jump(op.m_reentry);
71297: 
71297:         nonGreedyFailures.link(this);
71297:         sub32(countRegister, index);
71297:         m_backtrackingState.fallthrough();
71297:     }
71297: 
71297:     // Code generation/backtracking for simple terms
71297:     // (pattern characters, character classes, and assertions).
71297:     // These methods farm out work to the set of functions above.
71297:     void generateTerm(size_t opIndex)
71297:     {
71297:         YarrOp& op = m_ops[opIndex];
71297:         PatternTerm* term = op.m_term;
71297: 
71297:         switch (term->type) {
71297:         case PatternTerm::TypePatternCharacter:
71297:             switch (term->quantityType) {
71297:             case QuantifierFixedCount:
71297:                 if (term->quantityCount == 1)
71297:                     generatePatternCharacterOnce(opIndex);
71297:                 else
71297:                     generatePatternCharacterFixed(opIndex);
71297:                 break;
71297:             case QuantifierGreedy:
71297:                 generatePatternCharacterGreedy(opIndex);
71297:                 break;
71297:             case QuantifierNonGreedy:
71297:                 generatePatternCharacterNonGreedy(opIndex);
71297:                 break;
71297:             }
71297:             break;
71297: 
71297:         case PatternTerm::TypeCharacterClass:
71297:             switch (term->quantityType) {
71297:             case QuantifierFixedCount:
71297:                 if (term->quantityCount == 1)
71297:                     generateCharacterClassOnce(opIndex);
71297:                 else
71297:                     generateCharacterClassFixed(opIndex);
71297:                 break;
71297:             case QuantifierGreedy:
71297:                 generateCharacterClassGreedy(opIndex);
71297:                 break;
71297:             case QuantifierNonGreedy:
71297:                 generateCharacterClassNonGreedy(opIndex);
71297:                 break;
71297:             }
71297:             break;
71297: 
71297:         case PatternTerm::TypeAssertionBOL:
71297:             generateAssertionBOL(opIndex);
71297:             break;
71297: 
71297:         case PatternTerm::TypeAssertionEOL:
71297:             generateAssertionEOL(opIndex);
71297:             break;
71297: 
71297:         case PatternTerm::TypeAssertionWordBoundary:
71297:             generateAssertionWordBoundary(opIndex);
71297:             break;
71297: 
71297:         case PatternTerm::TypeForwardReference:
71297:             break;
71297: 
71297:         case PatternTerm::TypeParenthesesSubpattern:
71297:         case PatternTerm::TypeParentheticalAssertion:
71297:             ASSERT_NOT_REACHED();
71297:         case PatternTerm::TypeBackReference:
71297:             m_shouldFallBack = true;
71297:             break;
71297:         }
71297:     }
71297:     void backtrackTerm(size_t opIndex)
71297:     {
71297:         YarrOp& op = m_ops[opIndex];
71297:         PatternTerm* term = op.m_term;
71297: 
71297:         switch (term->type) {
71297:         case PatternTerm::TypePatternCharacter:
71297:             switch (term->quantityType) {
71297:             case QuantifierFixedCount:
71297:                 if (term->quantityCount == 1)
71297:                     backtrackPatternCharacterOnce(opIndex);
71297:                 else
71297:                     backtrackPatternCharacterFixed(opIndex);
71297:                 break;
71297:             case QuantifierGreedy:
71297:                 backtrackPatternCharacterGreedy(opIndex);
71297:                 break;
71297:             case QuantifierNonGreedy:
71297:                 backtrackPatternCharacterNonGreedy(opIndex);
71297:                 break;
71297:             }
71297:             break;
71297: 
71297:         case PatternTerm::TypeCharacterClass:
71297:             switch (term->quantityType) {
71297:             case QuantifierFixedCount:
71297:                 if (term->quantityCount == 1)
71297:                     backtrackCharacterClassOnce(opIndex);
71297:                 else
71297:                     backtrackCharacterClassFixed(opIndex);
71297:                 break;
71297:             case QuantifierGreedy:
71297:                 backtrackCharacterClassGreedy(opIndex);
71297:                 break;
71297:             case QuantifierNonGreedy:
71297:                 backtrackCharacterClassNonGreedy(opIndex);
71297:                 break;
71297:             }
71297:             break;
71297: 
71297:         case PatternTerm::TypeAssertionBOL:
71297:             backtrackAssertionBOL(opIndex);
71297:             break;
71297: 
71297:         case PatternTerm::TypeAssertionEOL:
71297:             backtrackAssertionEOL(opIndex);
71297:             break;
71297: 
71297:         case PatternTerm::TypeAssertionWordBoundary:
71297:             backtrackAssertionWordBoundary(opIndex);
71297:             break;
71297: 
71297:         case PatternTerm::TypeForwardReference:
71297:             break;
71297: 
71297:         case PatternTerm::TypeParenthesesSubpattern:
71297:         case PatternTerm::TypeParentheticalAssertion:
71297:             ASSERT_NOT_REACHED();
71297:         case PatternTerm::TypeBackReference:
71297:             m_shouldFallBack = true;
71297:             break;
71297:         }
71297:     }
71297: 
71297:     void generate()
71297:     {
71297:         // Forwards generate the matching code.
71297:         ASSERT(m_ops.size());
71297:         size_t opIndex = 0;
71297: 
71297:         do {
71297:             YarrOp& op = m_ops[opIndex];
71297:             switch (op.m_op) {
71297: 
71297:             case OpTerm:
71297:                 generateTerm(opIndex);
71297:                 break;
71297: 
71297:             // OpBodyAlternativeBegin/Next/End
71297:             //
71297:             // These nodes wrap the set of alternatives in the body of the regular expression.
71297:             // There may be either one or two chains of OpBodyAlternative nodes, one representing
71297:             // the 'once through' sequence of alternatives (if any exist), and one representing
71297:             // the repeating alternatives (again, if any exist).
71297:             //
71297:             // Upon normal entry to the Begin alternative, we will check that input is available.
71297:             // Reentry to the Begin alternative will take place after the check has taken place,
71297:             // and will assume that the input position has already been progressed as appropriate.
71297:             //
71297:             // Entry to subsequent Next/End alternatives occurs when the prior alternative has
71297:             // successfully completed a match - return a success state from JIT code.
71297:             //
71297:             // Next alternatives allow for reentry optimized to suit backtracking from its
71297:             // preceding alternative. It expects the input position to still be set to a position
71297:             // appropriate to its predecessor, and it will only perform an input check if the
71297:             // predecessor had a minimum size less than its own.
71297:             //
71297:             // In the case 'once through' expressions, the End node will also have a reentry
71297:             // point to jump to when the last alternative fails. Again, this expects the input
71297:             // position to still reflect that expected by the prior alternative.
71297:             case OpBodyAlternativeBegin: {
71297:                 PatternAlternative* alternative = op.m_alternative;
71297: 
71297:                 // Upon entry at the head of the set of alternatives, check if input is available
71297:                 // to run the first alternative. (This progresses the input position).
71297:                 op.m_jumps.append(jumpIfNoAvailableInput(alternative->m_minimumSize));
71297:                 // We will reenter after the check, and assume the input position to have been
71297:                 // set as appropriate to this alternative.
71297:                 op.m_reentry = label();
71297: 
71297:                 m_checked += alternative->m_minimumSize;
71297:                 break;
71297:             }
71297:             case OpBodyAlternativeNext:
71297:             case OpBodyAlternativeEnd: {
71297:                 PatternAlternative* priorAlternative = m_ops[op.m_previousOp].m_alternative;
71297:                 PatternAlternative* alternative = op.m_alternative;
71297: 
71297:                 // If we get here, the prior alternative matched - return success.
71297:                 
71297:                 // Adjust the stack pointer to remove the pattern's frame.
80821: #if !WTF_CPU_SPARC
71297:                 if (m_pattern.m_body->m_callFrameSize)
71297:                     addPtr(Imm32(m_pattern.m_body->m_callFrameSize * sizeof(void*)), stackPointerRegister);
80821: #endif
71297: 
71297:                 // Load appropriate values into the return register and the first output
71297:                 // slot, and return. In the case of pattern with a fixed size, we will
71297:                 // not have yet set the value in the first 
71297:                 ASSERT(index != returnRegister);
71297:                 if (m_pattern.m_body->m_hasFixedSize) {
71297:                     move(index, returnRegister);
71297:                     if (priorAlternative->m_minimumSize)
71297:                         sub32(Imm32(priorAlternative->m_minimumSize), returnRegister);
71297:                     store32(returnRegister, output);
71297:                 } else
71297:                     load32(Address(output), returnRegister);
71297:                 store32(index, Address(output, 4));
71297:                 generateReturn();
71297: 
71297:                 // This is the divide between the tail of the prior alternative, above, and
71297:                 // the head of the subsequent alternative, below.
71297: 
71297:                 if (op.m_op == OpBodyAlternativeNext) {
71297:                     // This is the reentry point for the Next alternative. We expect any code
71297:                     // that jumps here to do so with the input position matching that of the
71297:                     // PRIOR alteranative, and we will only check input availability if we
71297:                     // need to progress it forwards.
71297:                     op.m_reentry = label();
72570:                     if (alternative->m_minimumSize > priorAlternative->m_minimumSize) {
72570:                         add32(Imm32(alternative->m_minimumSize - priorAlternative->m_minimumSize), index);
71297:                         op.m_jumps.append(jumpIfNoAvailableInput());
72570:                     } else if (priorAlternative->m_minimumSize > alternative->m_minimumSize)
72570:                         sub32(Imm32(priorAlternative->m_minimumSize - alternative->m_minimumSize), index);
71297:                 } else if (op.m_nextOp == notFound) {
71297:                     // This is the reentry point for the End of 'once through' alternatives,
71297:                     // jumped to when the las alternative fails to match.
71297:                     op.m_reentry = label();
71297:                     sub32(Imm32(priorAlternative->m_minimumSize), index);
71297:                 }
71297: 
71297:                 if (op.m_op == OpBodyAlternativeNext)
71297:                     m_checked += alternative->m_minimumSize;
71297:                 m_checked -= priorAlternative->m_minimumSize;
71297:                 break;
71297:             }
71297: 
71297:             // OpSimpleNestedAlternativeBegin/Next/End
71297:             // OpNestedAlternativeBegin/Next/End
71297:             //
71297:             // These nodes are used to handle sets of alternatives that are nested within
71297:             // subpatterns and parenthetical assertions. The 'simple' forms are used where
71297:             // we do not need to be able to backtrack back into any alternative other than
71297:             // the last, the normal forms allow backtracking into any alternative.
71297:             //
71297:             // Each Begin/Next node is responsible for planting an input check to ensure
71297:             // sufficient input is available on entry. Next nodes additionally need to
71297:             // jump to the end - Next nodes use the End node's m_jumps list to hold this
71297:             // set of jumps.
71297:             //
71297:             // In the non-simple forms, successful alternative matches must store a
71297:             // 'return address' using a DataLabelPtr, used to store the address to jump
71297:             // to when backtracking, to get to the code for the appropriate alternative.
71297:             case OpSimpleNestedAlternativeBegin:
71297:             case OpNestedAlternativeBegin: {
71297:                 PatternTerm* term = op.m_term;
71297:                 PatternAlternative* alternative = op.m_alternative;
71297:                 PatternDisjunction* disjunction = term->parentheses.disjunction;
71297: 
71297:                 // Calculate how much input we need to check for, and if non-zero check.
71297:                 op.m_checkAdjust = alternative->m_minimumSize;
71297:                 if ((term->quantityType == QuantifierFixedCount) && (term->type != PatternTerm::TypeParentheticalAssertion))
71297:                     op.m_checkAdjust -= disjunction->m_minimumSize;
71297:                 if (op.m_checkAdjust)
71297:                     op.m_jumps.append(jumpIfNoAvailableInput(op.m_checkAdjust));
71297:  
71297:                 m_checked += op.m_checkAdjust;
71297:                 break;
71297:             }
71297:             case OpSimpleNestedAlternativeNext:
71297:             case OpNestedAlternativeNext: {
71297:                 PatternTerm* term = op.m_term;
71297:                 PatternAlternative* alternative = op.m_alternative;
71297:                 PatternDisjunction* disjunction = term->parentheses.disjunction;
71297: 
71297:                 // In the non-simple case, store a 'return address' so we can backtrack correctly.
71297:                 if (op.m_op == OpNestedAlternativeNext) {
71297:                     unsigned parenthesesFrameLocation = term->frameLocation;
71297:                     unsigned alternativeFrameLocation = parenthesesFrameLocation;
71297:                     if (term->quantityType != QuantifierFixedCount)
71297:                         alternativeFrameLocation += YarrStackSpaceForBackTrackInfoParenthesesOnce;
71297:                     op.m_returnAddress = storeToFrameWithPatch(alternativeFrameLocation);
71297:                 }
71297: 
71297:                 // If we reach here then the last alternative has matched - jump to the
71297:                 // End node, to skip over any further alternatives.
71297:                 //
71297:                 // FIXME: this is logically O(N^2) (though N can be expected to be very
71297:                 // small). We could avoid this either by adding an extra jump to the JIT
71297:                 // data structures, or by making backtracking code that jumps to Next
71297:                 // alternatives are responsible for checking that input is available (if
71297:                 // we didn't need to plant the input checks, then m_jumps would be free).
71297:                 YarrOp* endOp = &m_ops[op.m_nextOp];
71297:                 while (endOp->m_nextOp != notFound) {
71297:                     ASSERT(endOp->m_op == OpSimpleNestedAlternativeNext || endOp->m_op == OpNestedAlternativeNext);
71297:                     endOp = &m_ops[endOp->m_nextOp];
71297:                 }
71297:                 ASSERT(endOp->m_op == OpSimpleNestedAlternativeEnd || endOp->m_op == OpNestedAlternativeEnd);
71297:                 endOp->m_jumps.append(jump());
71297: 
71297:                 // This is the entry point for the next alternative.
71297:                 op.m_reentry = label();
71297: 
71297:                 // Calculate how much input we need to check for, and if non-zero check.
71297:                 op.m_checkAdjust = alternative->m_minimumSize;
71297:                 if ((term->quantityType == QuantifierFixedCount) && (term->type != PatternTerm::TypeParentheticalAssertion))
71297:                     op.m_checkAdjust -= disjunction->m_minimumSize;
71297:                 if (op.m_checkAdjust)
71297:                     op.m_jumps.append(jumpIfNoAvailableInput(op.m_checkAdjust));
71297: 
71297:                 YarrOp& lastOp = m_ops[op.m_previousOp];
71297:                 m_checked -= lastOp.m_checkAdjust;
71297:                 m_checked += op.m_checkAdjust;
71297:                 break;
71297:             }
71297:             case OpSimpleNestedAlternativeEnd:
71297:             case OpNestedAlternativeEnd: {
71297:                 PatternTerm* term = op.m_term;
71297: 
71297:                 // In the non-simple case, store a 'return address' so we can backtrack correctly.
71297:                 if (op.m_op == OpNestedAlternativeEnd) {
71297:                     unsigned parenthesesFrameLocation = term->frameLocation;
71297:                     unsigned alternativeFrameLocation = parenthesesFrameLocation;
71297:                     if (term->quantityType != QuantifierFixedCount)
71297:                         alternativeFrameLocation += YarrStackSpaceForBackTrackInfoParenthesesOnce;
71297:                     op.m_returnAddress = storeToFrameWithPatch(alternativeFrameLocation);
71297:                 }
71297: 
71297:                 // If this set of alternatives contains more than one alternative,
71297:                 // then the Next nodes will have planted jumps to the End, and added
71297:                 // them to this node's m_jumps list.
71297:                 op.m_jumps.link(this);
71297:                 op.m_jumps.clear();
71297: 
71297:                 YarrOp& lastOp = m_ops[op.m_previousOp];
71297:                 m_checked -= lastOp.m_checkAdjust;
71297:                 break;
71297:             }
71297: 
71297:             // OpParenthesesSubpatternOnceBegin/End
71297:             //
71297:             // These nodes support (optionally) capturing subpatterns, that have a
71297:             // quantity count of 1 (this covers fixed once, and ?/?? quantifiers). 
71297:             case OpParenthesesSubpatternOnceBegin: {
71297:                 PatternTerm* term = op.m_term;
71297:                 unsigned parenthesesFrameLocation = term->frameLocation;
71297:                 const RegisterID indexTemporary = regT0;
71297:                 ASSERT(term->quantityCount == 1);
71297: 
71297:                 // Upon entry to a Greedy quantified set of parenthese store the index.
71297:                 // We'll use this for two purposes:
71297:                 //  - To indicate which iteration we are on of mathing the remainder of
71297:                 //    the expression after the parentheses - the first, including the
71297:                 //    match within the parentheses, or the second having skipped over them.
71297:                 //  - To check for empty matches, which must be rejected.
71297:                 //
71297:                 // At the head of a NonGreedy set of parentheses we'll immediately set the
71297:                 // value on the stack to -1 (indicating a match skipping the subpattern),
71297:                 // and plant a jump to the end. We'll also plant a label to backtrack to
71297:                 // to reenter the subpattern later, with a store to set up index on the
71297:                 // second iteration.
71297:                 //
71297:                 // FIXME: for capturing parens, could use the index in the capture array?
71297:                 if (term->quantityType == QuantifierGreedy)
71297:                     storeToFrame(index, parenthesesFrameLocation);
71297:                 else if (term->quantityType == QuantifierNonGreedy) {
71297:                     storeToFrame(TrustedImm32(-1), parenthesesFrameLocation);
71297:                     op.m_jumps.append(jump());
71297:                     op.m_reentry = label();
71297:                     storeToFrame(index, parenthesesFrameLocation);
71297:                 }
71297: 
71297:                 // If the parenthese are capturing, store the starting index value to the
71297:                 // captures array, offsetting as necessary.
71297:                 //
71297:                 // FIXME: could avoid offsetting this value in JIT code, apply
71297:                 // offsets only afterwards, at the point the results array is
71297:                 // being accessed.
71297:                 if (term->capture()) {
71297:                     int offsetId = term->parentheses.subpatternId << 1;
71297:                     int inputOffset = term->inputPosition - m_checked;
71297:                     if (term->quantityType == QuantifierFixedCount)
71297:                         inputOffset -= term->parentheses.disjunction->m_minimumSize;
71297:                     if (inputOffset) {
71297:                         move(index, indexTemporary);
71297:                         add32(Imm32(inputOffset), indexTemporary);
71297:                         store32(indexTemporary, Address(output, offsetId * sizeof(int)));
71297:                     } else
71297:                         store32(index, Address(output, offsetId * sizeof(int)));
71297:                 }
71297:                 break;
71297:             }
71297:             case OpParenthesesSubpatternOnceEnd: {
71297:                 PatternTerm* term = op.m_term;
71297:                 unsigned parenthesesFrameLocation = term->frameLocation;
71297:                 const RegisterID indexTemporary = regT0;
71297:                 ASSERT(term->quantityCount == 1);
71297: 
71297:                 // For Greedy/NonGreedy quantified parentheses, we must reject zero length
71297:                 // matches. If the minimum size is know to be non-zero we need not check.
71297:                 if (term->quantityType != QuantifierFixedCount && !term->parentheses.disjunction->m_minimumSize)
71297:                     op.m_jumps.append(branch32(Equal, index, Address(stackPointerRegister, parenthesesFrameLocation * sizeof(void*))));
71297: 
71297:                 // If the parenthese are capturing, store the ending index value to the
71297:                 // captures array, offsetting as necessary.
71297:                 //
71297:                 // FIXME: could avoid offsetting this value in JIT code, apply
71297:                 // offsets only afterwards, at the point the results array is
71297:                 // being accessed.
71297:                 if (term->capture()) {
71297:                     int offsetId = (term->parentheses.subpatternId << 1) + 1;
71297:                     int inputOffset = term->inputPosition - m_checked;
71297:                     if (inputOffset) {
71297:                         move(index, indexTemporary);
71297:                         add32(Imm32(inputOffset), indexTemporary);
71297:                         store32(indexTemporary, Address(output, offsetId * sizeof(int)));
71297:                     } else
71297:                         store32(index, Address(output, offsetId * sizeof(int)));
71297:                 }
71297: 
71297:                 // If the parentheses are quantified Greedy then add a label to jump back
71297:                 // to if get a failed match from after the parentheses. For NonGreedy
71297:                 // parentheses, link the jump from before the subpattern to here.
71297:                 if (term->quantityType == QuantifierGreedy)
71297:                     op.m_reentry = label();
71297:                 else if (term->quantityType == QuantifierNonGreedy) {
71297:                     YarrOp& beginOp = m_ops[op.m_previousOp];
71297:                     beginOp.m_jumps.link(this);
71297:                 }
71297:                 break;
71297:             }
71297: 
71297:             // OpParenthesesSubpatternTerminalBegin/End
71297:             case OpParenthesesSubpatternTerminalBegin: {
71297:                 PatternTerm* term = op.m_term;
71297:                 ASSERT(term->quantityType == QuantifierGreedy);
71297:                 ASSERT(term->quantityCount == quantifyInfinite);
71297:                 ASSERT(!term->capture());
71297: 
71297:                 // Upon entry set a label to loop back to.
71297:                 op.m_reentry = label();
71297: 
71297:                 // Store the start index of the current match; we need to reject zero
71297:                 // length matches.
71297:                 storeToFrame(index, term->frameLocation);
71297:                 break;
71297:             }
71297:             case OpParenthesesSubpatternTerminalEnd: {
71297:                 PatternTerm* term = op.m_term;
71297: 
71297:                 // Check for zero length matches - if the match is non-zero, then we
71297:                 // can accept it & loop back up to the head of the subpattern.
71297:                 YarrOp& beginOp = m_ops[op.m_previousOp];
71297:                 branch32(NotEqual, index, Address(stackPointerRegister, term->frameLocation * sizeof(void*)), beginOp.m_reentry);
71297: 
71297:                 // Reject the match - backtrack back into the subpattern.
71297:                 op.m_jumps.append(jump());
71297: 
71297:                 // This is the entry point to jump to when we stop matching - we will
71297:                 // do so once the subpattern cannot match any more.
71297:                 op.m_reentry = label();
71297:                 break;
71297:             }
71297: 
71297:             // OpParentheticalAssertionBegin/End
71297:             case OpParentheticalAssertionBegin: {
71297:                 PatternTerm* term = op.m_term;
71297: 
71297:                 // Store the current index - assertions should not update index, so
71297:                 // we will need to restore it upon a successful match.
71297:                 unsigned parenthesesFrameLocation = term->frameLocation;
71297:                 storeToFrame(index, parenthesesFrameLocation);
71297: 
71297:                 // Check 
71297:                 op.m_checkAdjust = m_checked - term->inputPosition;
71297:                 if (op.m_checkAdjust)
71297:                     sub32(Imm32(op.m_checkAdjust), index);
71297: 
71297:                 m_checked -= op.m_checkAdjust;
71297:                 break;
71297:             }
71297:             case OpParentheticalAssertionEnd: {
71297:                 PatternTerm* term = op.m_term;
71297: 
71297:                 // Restore the input index value.
71297:                 unsigned parenthesesFrameLocation = term->frameLocation;
71297:                 loadFromFrame(parenthesesFrameLocation, index);
71297: 
71297:                 // If inverted, a successful match of the assertion must be treated
71297:                 // as a failure, so jump to backtracking.
71297:                 if (term->invert()) {
71297:                     op.m_jumps.append(jump());
71297:                     op.m_reentry = label();
71297:                 }
71297: 
71297:                 YarrOp& lastOp = m_ops[op.m_previousOp];
71297:                 m_checked += lastOp.m_checkAdjust;
71297:                 break;
71297:             }
71297: 
71297:             case OpMatchFailed:
80821: #if !WTF_CPU_SPARC
71297:                 if (m_pattern.m_body->m_callFrameSize)
71297:                     addPtr(Imm32(m_pattern.m_body->m_callFrameSize * sizeof(void*)), stackPointerRegister);
80821: #endif
71297:                 move(TrustedImm32(-1), returnRegister);
71297:                 generateReturn();
71297:                 break;
71297:             }
71297: 
71297:             ++opIndex;
71297:         } while (opIndex < m_ops.size());
71297:     }
71297: 
71297:     void backtrack()
71297:     {
71297:         // Backwards generate the backtracking code.
71297:         size_t opIndex = m_ops.size();
71297:         ASSERT(opIndex);
71297: 
71297:         do {
71297:             --opIndex;
71297:             YarrOp& op = m_ops[opIndex];
71297:             switch (op.m_op) {
71297: 
71297:             case OpTerm:
71297:                 backtrackTerm(opIndex);
71297:                 break;
71297: 
71297:             // OpBodyAlternativeBegin/Next/End
71297:             //
71297:             // For each Begin/Next node representing an alternative, we need to decide what to do
71297:             // in two circumstances:
71297:             //  - If we backtrack back into this node, from within the alternative.
71297:             //  - If the input check at the head of the alternative fails (if this exists).
71297:             //
71297:             // We treat these two cases differently since in the former case we have slightly
71297:             // more information - since we are backtracking out of a prior alternative we know
71297:             // that at least enough input was available to run it. For example, given the regular
71297:             // expression /a|b/, if we backtrack out of the first alternative (a failed pattern
71297:             // character match of 'a'), then we need not perform an additional input availability
71297:             // check before running the second alternative.
71297:             //
71297:             // Backtracking required differs for the last alternative, which in the case of the
71297:             // repeating set of alternatives must loop. The code generated for the last alternative
71297:             // will also be used to handle all input check failures from any prior alternatives -
71297:             // these require similar functionality, in seeking the next available alternative for
71297:             // which there is sufficient input.
71297:             //
71297:             // Since backtracking of all other alternatives simply requires us to link backtracks
71297:             // to the reentry point for the subsequent alternative, we will only be generating any
71297:             // code when backtracking the last alternative.
71297:             case OpBodyAlternativeBegin:
71297:             case OpBodyAlternativeNext: {
71297:                 PatternAlternative* alternative = op.m_alternative;
71297: 
71297:                 if (op.m_op == OpBodyAlternativeNext) {
71297:                     PatternAlternative* priorAlternative = m_ops[op.m_previousOp].m_alternative;
71297:                     m_checked += priorAlternative->m_minimumSize;
71297:                 }
71297:                 m_checked -= alternative->m_minimumSize;
71297: 
71297:                 // Is this the last alternative? If not, then if we backtrack to this point we just
71297:                 // need to jump to try to match the next alternative.
71297:                 if (m_ops[op.m_nextOp].m_op != OpBodyAlternativeEnd) {
71297:                     m_backtrackingState.linkTo(m_ops[op.m_nextOp].m_reentry, this);
71297:                     break;
71297:                 }
71297:                 YarrOp& endOp = m_ops[op.m_nextOp];
71297: 
71297:                 YarrOp* beginOp = &op;
71297:                 while (beginOp->m_op != OpBodyAlternativeBegin) {
71297:                     ASSERT(beginOp->m_op == OpBodyAlternativeNext);
71297:                     beginOp = &m_ops[beginOp->m_previousOp];
71297:                 }
71297: 
71297:                 bool onceThrough = endOp.m_nextOp == notFound;
71297: 
71297:                 // First, generate code to handle cases where we backtrack out of an attempted match
71297:                 // of the last alternative. If this is a 'once through' set of alternatives then we
71297:                 // have nothing to do - link this straight through to the End.
71297:                 if (onceThrough)
71297:                     m_backtrackingState.linkTo(endOp.m_reentry, this);
71297:                 else {
71297:                     // If we don't need to move the input poistion, and the pattern has a fixed size
71297:                     // (in which case we omit the store of the start index until the pattern has matched)
71297:                     // then we can just link the backtrack out of the last alternative straight to the
71297:                     // head of the first alternative.
72570:                     if (m_pattern.m_body->m_hasFixedSize
72570:                         && (alternative->m_minimumSize > beginOp->m_alternative->m_minimumSize)
72570:                         && (alternative->m_minimumSize - beginOp->m_alternative->m_minimumSize == 1))
71297:                         m_backtrackingState.linkTo(beginOp->m_reentry, this);
71297:                     else {
71297:                         // We need to generate a trampoline of code to execute before looping back
71297:                         // around to the first alternative.
71297:                         m_backtrackingState.link(this);
71297: 
71297:                         // If the pattern size is not fixed, then store the start index, for use if we match.
71297:                         if (!m_pattern.m_body->m_hasFixedSize) {
71297:                             if (alternative->m_minimumSize == 1)
71297:                                 store32(index, Address(output));
71297:                             else {
71297:                                 move(index, regT0);
71297:                                 if (alternative->m_minimumSize)
71297:                                     sub32(Imm32(alternative->m_minimumSize - 1), regT0);
71297:                                 else
71297:                                     add32(Imm32(1), regT0);
71297:                                 store32(regT0, Address(output));
71297:                             }
71297:                         }
71297: 
72570:                         // Generate code to loop. Check whether the last alternative is longer than the
72570:                         // first (e.g. /a|xy/ or /a|xyz/).
72570:                         if (alternative->m_minimumSize > beginOp->m_alternative->m_minimumSize) {
72570:                             // We want to loop, and increment input position. If the delta is 1, it is
72570:                             // already correctly incremented, if more than one then decrement as appropriate.
72570:                             unsigned delta = alternative->m_minimumSize - beginOp->m_alternative->m_minimumSize;
72570:                             ASSERT(delta);
72570:                             if (delta != 1)
72570:                                 sub32(Imm32(delta - 1), index);
72570:                             jump(beginOp->m_reentry);
72570:                         } else {
72570:                             // If the first alternative has minimum size 0xFFFFFFFFu, then there cannot
72570:                             // be sufficent input available to handle this, so just fall through.
72570:                             unsigned delta = beginOp->m_alternative->m_minimumSize - alternative->m_minimumSize;
72570:                             if (delta != 0xFFFFFFFFu) {
72570:                                 // We need to check input because we are incrementing the input.
72570:                                 add32(Imm32(delta + 1), index);
71297:                                 checkInput().linkTo(beginOp->m_reentry, this);
72570:                             }
72570:                         }
71297:                     }
71297:                 }
71297: 
71297:                 // We can reach this point in the code in two ways:
71297:                 //  - Fallthrough from the code above (a repeating alternative backtracked out of its
71297:                 //    last alternative, and did not have sufficent input to run the first).
71297:                 //  - We will loop back up to the following label when a releating alternative loops,
71297:                 //    following a failed input check.
71297:                 //
71297:                 // Either way, we have just failed the input check for the first alternative.
71297:                 Label firstInputCheckFailed(this);
71297: 
71297:                 // Generate code to handle input check failures from alternatives except the last.
71297:                 // prevOp is the alternative we're handling a bail out from (initially Begin), and
71297:                 // nextOp is the alternative we will be attempting to reenter into.
71297:                 // 
71297:                 // We will link input check failures from the forwards matching path back to the code
71297:                 // that can handle them.
71297:                 YarrOp* prevOp = beginOp;
71297:                 YarrOp* nextOp = &m_ops[beginOp->m_nextOp];
71297:                 while (nextOp->m_op != OpBodyAlternativeEnd) {
71297:                     prevOp->m_jumps.link(this);
71297: 
71297:                     // We only get here if an input check fails, it is only worth checking again
71297:                     // if the next alternative has a minimum size less than the last.
72570:                     if (prevOp->m_alternative->m_minimumSize > nextOp->m_alternative->m_minimumSize) {
71297:                         // FIXME: if we added an extra label to YarrOp, we could avoid needing to
71297:                         // subtract delta back out, and reduce this code. Should performance test
71297:                         // the benefit of this.
72570:                         unsigned delta = prevOp->m_alternative->m_minimumSize - nextOp->m_alternative->m_minimumSize;
72570:                         sub32(Imm32(delta), index);
71297:                         Jump fail = jumpIfNoAvailableInput();
72570:                         add32(Imm32(delta), index);
71297:                         jump(nextOp->m_reentry);
71297:                         fail.link(this);
72570:                     } else if (prevOp->m_alternative->m_minimumSize < nextOp->m_alternative->m_minimumSize)
72570:                         add32(Imm32(nextOp->m_alternative->m_minimumSize - prevOp->m_alternative->m_minimumSize), index);
71297:                     prevOp = nextOp;
71297:                     nextOp = &m_ops[nextOp->m_nextOp];
71297:                 }
71297: 
71297:                 // We fall through to here if there is insufficient input to run the last alternative.
71297: 
71297:                 // If there is insufficient input to run the last alternative, then for 'once through'
71297:                 // alternatives we are done - just jump back up into the forwards matching path at the End.
71297:                 if (onceThrough) {
71297:                     op.m_jumps.linkTo(endOp.m_reentry, this);
71297:                     jump(endOp.m_reentry);
71297:                     break;
71297:                 }
71297: 
71297:                 // For repeating alternatives, link any input check failure from the last alternative to
71297:                 // this point.
71297:                 op.m_jumps.link(this);
71297: 
71297:                 bool needsToUpdateMatchStart = !m_pattern.m_body->m_hasFixedSize;
71297: 
71297:                 // Check for cases where input position is already incremented by 1 for the last
71297:                 // alternative (this is particularly useful where the minimum size of the body
71297:                 // disjunction is 0, e.g. /a*|b/).
71297:                 if (needsToUpdateMatchStart && alternative->m_minimumSize == 1) {
71297:                     // index is already incremented by 1, so just store it now!
71297:                     store32(index, Address(output));
71297:                     needsToUpdateMatchStart = false;
71297:                 }
71297: 
71297:                 // Check whether there is sufficient input to loop. Increment the input position by
71297:                 // one, and check. Also add in the minimum disjunction size before checking - there
71297:                 // is no point in looping if we're just going to fail all the input checks around
71297:                 // the next iteration.
72570:                 ASSERT(alternative->m_minimumSize >= m_pattern.m_body->m_minimumSize);
72570:                 if (alternative->m_minimumSize == m_pattern.m_body->m_minimumSize) {
72570:                     // If the last alternative had the same minimum size as the disjunction,
72570:                     // just simply increment input pos by 1, no adjustment based on minimum size.
72570:                     add32(Imm32(1), index);
72570:                 } else {
72570:                     // If the minumum for the last alternative was one greater than than that
72570:                     // for the disjunction, we're already progressed by 1, nothing to do!
72570:                     unsigned delta = (alternative->m_minimumSize - m_pattern.m_body->m_minimumSize) - 1;
72570:                     if (delta)
72570:                         sub32(Imm32(delta), index);
72570:                 }
71297:                 Jump matchFailed = jumpIfNoAvailableInput();
71297: 
71297:                 if (needsToUpdateMatchStart) {
71297:                     if (!m_pattern.m_body->m_minimumSize)
71297:                         store32(index, Address(output));
71297:                     else {
71297:                         move(index, regT0);
71297:                         sub32(Imm32(m_pattern.m_body->m_minimumSize), regT0);
71297:                         store32(regT0, Address(output));
71297:                     }
71297:                 }
71297: 
71297:                 // Calculate how much more input the first alternative requires than the minimum
71297:                 // for the body as a whole. If no more is needed then we dont need an additional
71297:                 // input check here - jump straight back up to the start of the first alternative.
72570:                 if (beginOp->m_alternative->m_minimumSize == m_pattern.m_body->m_minimumSize)
71297:                     jump(beginOp->m_reentry);
71297:                 else {
72570:                     if (beginOp->m_alternative->m_minimumSize > m_pattern.m_body->m_minimumSize)
72570:                         add32(Imm32(beginOp->m_alternative->m_minimumSize - m_pattern.m_body->m_minimumSize), index);
72570:                     else
72570:                         sub32(Imm32(m_pattern.m_body->m_minimumSize - beginOp->m_alternative->m_minimumSize), index);
71297:                     checkInput().linkTo(beginOp->m_reentry, this);
71297:                     jump(firstInputCheckFailed);
71297:                 }
71297: 
71297:                 // We jump to here if we iterate to the point that there is insufficient input to
71297:                 // run any matches, and need to return a failure state from JIT code.
71297:                 matchFailed.link(this);
71297: 
80821: #if !WTF_CPU_SPARC
71297:                 if (m_pattern.m_body->m_callFrameSize)
71297:                     addPtr(Imm32(m_pattern.m_body->m_callFrameSize * sizeof(void*)), stackPointerRegister);
80821: #endif
71297:                 move(TrustedImm32(-1), returnRegister);
71297:                 generateReturn();
71297:                 break;
71297:             }
71297:             case OpBodyAlternativeEnd: {
71297:                 // We should never backtrack back into a body disjunction.
71297:                 ASSERT(m_backtrackingState.isEmpty());
71297: 
71297:                 PatternAlternative* priorAlternative = m_ops[op.m_previousOp].m_alternative;
71297:                 m_checked += priorAlternative->m_minimumSize;
71297:                 break;
71297:             }
71297: 
71297:             // OpSimpleNestedAlternativeBegin/Next/End
71297:             // OpNestedAlternativeBegin/Next/End
71297:             //
71297:             // Generate code for when we backtrack back out of an alternative into
71297:             // a Begin or Next node, or when the entry input count check fails. If
71297:             // there are more alternatives we need to jump to the next alternative,
71297:             // if not we backtrack back out of the current set of parentheses.
71297:             //
71297:             // In the case of non-simple nested assertions we need to also link the
71297:             // 'return address' appropriately to backtrack back out into the correct
71297:             // alternative.
71297:             case OpSimpleNestedAlternativeBegin:
71297:             case OpSimpleNestedAlternativeNext:
71297:             case OpNestedAlternativeBegin:
71297:             case OpNestedAlternativeNext: {
71297:                 YarrOp& nextOp = m_ops[op.m_nextOp];
71297:                 bool isBegin = op.m_previousOp == notFound;
71297:                 bool isLastAlternative = nextOp.m_nextOp == notFound;
71297:                 ASSERT(isBegin == (op.m_op == OpSimpleNestedAlternativeBegin || op.m_op == OpNestedAlternativeBegin));
71297:                 ASSERT(isLastAlternative == (nextOp.m_op == OpSimpleNestedAlternativeEnd || nextOp.m_op == OpNestedAlternativeEnd));
71297: 
71297:                 // Treat an input check failure the same as a failed match.
71297:                 m_backtrackingState.append(op.m_jumps);
71297: 
71297:                 // Set the backtracks to jump to the appropriate place. We may need
71297:                 // to link the backtracks in one of three different way depending on
71297:                 // the type of alternative we are dealing with:
71297:                 //  - A single alternative, with no simplings.
71297:                 //  - The last alternative of a set of two or more.
71297:                 //  - An alternative other than the last of a set of two or more.
71297:                 //
71297:                 // In the case of a single alternative on its own, we don't need to
71297:                 // jump anywhere - if the alternative fails to match we can just
71297:                 // continue to backtrack out of the parentheses without jumping.
71297:                 //
71297:                 // In the case of the last alternative in a set of more than one, we
71297:                 // need to jump to return back out to the beginning. We'll do so by
71297:                 // adding a jump to the End node's m_jumps list, and linking this
71297:                 // when we come to generate the Begin node. For alternatives other
71297:                 // than the last, we need to jump to the next alternative.
71297:                 //
71297:                 // If the alternative had adjusted the input position we must link
71297:                 // backtracking to here, correct, and then jump on. If not we can
71297:                 // link the backtracks directly to their destination.
71297:                 if (op.m_checkAdjust) {
71297:                     // Handle the cases where we need to link the backtracks here.
71297:                     m_backtrackingState.link(this);
71297:                     sub32(Imm32(op.m_checkAdjust), index);
71297:                     if (!isLastAlternative) {
71297:                         // An alternative that is not the last should jump to its successor.
71297:                         jump(nextOp.m_reentry);
71297:                     } else if (!isBegin) {
71297:                         // The last of more than one alternatives must jump back to the begnning.
71297:                         nextOp.m_jumps.append(jump());
71297:                     } else {
71297:                         // A single alternative on its own can fall through.
71297:                         m_backtrackingState.fallthrough();
71297:                     }
71297:                 } else {
71297:                     // Handle the cases where we can link the backtracks directly to their destinations.
71297:                     if (!isLastAlternative) {
71297:                         // An alternative that is not the last should jump to its successor.
71297:                         m_backtrackingState.linkTo(nextOp.m_reentry, this);
71297:                     } else if (!isBegin) {
71297:                         // The last of more than one alternatives must jump back to the begnning.
71297:                         m_backtrackingState.takeBacktracksToJumpList(nextOp.m_jumps, this);
71297:                     }
71297:                     // In the case of a single alternative on its own do nothing - it can fall through.
71297:                 }
71297: 
71297:                 // At this point we've handled the backtracking back into this node.
71297:                 // Now link any backtracks that need to jump to here.
71297: 
71297:                 // For non-simple alternatives, link the alternative's 'return address'
71297:                 // so that we backtrack back out into the previous alternative.
71297:                 if (op.m_op == OpNestedAlternativeNext)
71297:                     m_backtrackingState.append(op.m_returnAddress);
71297: 
71297:                 // If there is more than one alternative, then the last alternative will
71297:                 // have planted a jump to be linked to the end. This jump was added to the
71297:                 // End node's m_jumps list. If we are back at the beginning, link it here.
71297:                 if (isBegin) {
71297:                     YarrOp* endOp = &m_ops[op.m_nextOp];
71297:                     while (endOp->m_nextOp != notFound) {
71297:                         ASSERT(endOp->m_op == OpSimpleNestedAlternativeNext || endOp->m_op == OpNestedAlternativeNext);
71297:                         endOp = &m_ops[endOp->m_nextOp];
71297:                     }
71297:                     ASSERT(endOp->m_op == OpSimpleNestedAlternativeEnd || endOp->m_op == OpNestedAlternativeEnd);
71297:                     m_backtrackingState.append(endOp->m_jumps);
71297:                 }
71297: 
71297:                 if (!isBegin) {
71297:                     YarrOp& lastOp = m_ops[op.m_previousOp];
71297:                     m_checked += lastOp.m_checkAdjust;
71297:                 }
71297:                 m_checked -= op.m_checkAdjust;
71297:                 break;
71297:             }
71297:             case OpSimpleNestedAlternativeEnd:
71297:             case OpNestedAlternativeEnd: {
71297:                 PatternTerm* term = op.m_term;
71297: 
71297:                 // If we backtrack into the end of a simple subpattern do nothing;
71297:                 // just continue through into the last alternative. If we backtrack
71297:                 // into the end of a non-simple set of alterntives we need to jump
71297:                 // to the backtracking return address set up during generation.
71297:                 if (op.m_op == OpNestedAlternativeEnd) {
71297:                     m_backtrackingState.link(this);
71297: 
71297:                     // Plant a jump to the return address.
71297:                     unsigned parenthesesFrameLocation = term->frameLocation;
71297:                     unsigned alternativeFrameLocation = parenthesesFrameLocation;
71297:                     if (term->quantityType != QuantifierFixedCount)
71297:                         alternativeFrameLocation += YarrStackSpaceForBackTrackInfoParenthesesOnce;
71297:                     loadFromFrameAndJump(alternativeFrameLocation);
71297: 
71297:                     // Link the DataLabelPtr associated with the end of the last
71297:                     // alternative to this point.
71297:                     m_backtrackingState.append(op.m_returnAddress);
71297:                 }
71297: 
71297:                 YarrOp& lastOp = m_ops[op.m_previousOp];
71297:                 m_checked += lastOp.m_checkAdjust;
71297:                 break;
71297:             }
71297: 
71297:             // OpParenthesesSubpatternOnceBegin/End
71297:             //
71297:             // When we are backtracking back out of a capturing subpattern we need
71297:             // to clear the start index in the matches output array, to record that
71297:             // this subpattern has not been captured.
71297:             //
71297:             // When backtracking back out of a Greedy quantified subpattern we need
71297:             // to catch this, and try running the remainder of the alternative after
71297:             // the subpattern again, skipping the parentheses.
71297:             //
71297:             // Upon backtracking back into a quantified set of parentheses we need to
71297:             // check whether we were currently skipping the subpattern. If not, we
71297:             // can backtrack into them, if we were we need to either backtrack back
71297:             // out of the start of the parentheses, or jump back to the forwards
71297:             // matching start, depending of whether the match is Greedy or NonGreedy.
71297:             case OpParenthesesSubpatternOnceBegin: {
71297:                 PatternTerm* term = op.m_term;
71297:                 ASSERT(term->quantityCount == 1);
71297: 
71297:                 // We only need to backtrack to thispoint if capturing or greedy.
71297:                 if (term->capture() || term->quantityType == QuantifierGreedy) {
71297:                     m_backtrackingState.link(this);
71297: 
71297:                     // If capturing, clear the capture (we only need to reset start).
71297:                     if (term->capture())
71297:                         store32(TrustedImm32(-1), Address(output, (term->parentheses.subpatternId << 1) * sizeof(int)));
71297: 
71297:                     // If Greedy, jump to the end.
71297:                     if (term->quantityType == QuantifierGreedy) {
71297:                         // Clear the flag in the stackframe indicating we ran through the subpattern.
71297:                         unsigned parenthesesFrameLocation = term->frameLocation;
71297:                         storeToFrame(TrustedImm32(-1), parenthesesFrameLocation);
71297:                         // Jump to after the parentheses, skipping the subpattern.
71297:                         jump(m_ops[op.m_nextOp].m_reentry);
71297:                         // A backtrack from after the parentheses, when skipping the subpattern,
71297:                         // will jump back to here.
71297:                         op.m_jumps.link(this);
71297:                     }
71297: 
71297:                     m_backtrackingState.fallthrough();
71297:                 }
71297:                 break;
71297:             }
71297:             case OpParenthesesSubpatternOnceEnd: {
71297:                 PatternTerm* term = op.m_term;
71297: 
71297:                 if (term->quantityType != QuantifierFixedCount) {
71297:                     m_backtrackingState.link(this);
71297: 
71297:                     // Check whether we should backtrack back into the parentheses, or if we
71297:                     // are currently in a state where we had skipped over the subpattern
71297:                     // (in which case the flag value on the stack will be -1).
71297:                     unsigned parenthesesFrameLocation = term->frameLocation;
71297:                     Jump hadSkipped = branch32(Equal, Address(stackPointerRegister, parenthesesFrameLocation * sizeof(void*)), TrustedImm32(-1));
71297: 
71297:                     if (term->quantityType == QuantifierGreedy) {
71297:                         // For Greedy parentheses, we skip after having already tried going
71297:                         // through the subpattern, so if we get here we're done.
71297:                         YarrOp& beginOp = m_ops[op.m_previousOp];
71297:                         beginOp.m_jumps.append(hadSkipped);
71297:                     } else {
71297:                         // For NonGreedy parentheses, we try skipping the subpattern first,
71297:                         // so if we get here we need to try running through the subpattern
71297:                         // next. Jump back to the start of the parentheses in the forwards
71297:                         // matching path.
71297:                         ASSERT(term->quantityType == QuantifierNonGreedy);
71297:                         YarrOp& beginOp = m_ops[op.m_previousOp];
71297:                         hadSkipped.linkTo(beginOp.m_reentry, this);
71297:                     }
71297: 
71297:                     m_backtrackingState.fallthrough();
71297:                 }
71297: 
71297:                 m_backtrackingState.append(op.m_jumps);
71297:                 break;
71297:             }
71297: 
71297:             // OpParenthesesSubpatternTerminalBegin/End
71297:             //
71297:             // Terminal subpatterns will always match - there is nothing after them to
71297:             // force a backtrack, and they have a minimum count of 0, and as such will
71297:             // always produce an acceptable result.
71297:             case OpParenthesesSubpatternTerminalBegin: {
71297:                 // We will backtrack to this point once the subpattern cannot match any
71297:                 // more. Since no match is accepted as a successful match (we are Greedy
71297:                 // quantified with a minimum of zero) jump back to the forwards matching
71297:                 // path at the end.
71297:                 YarrOp& endOp = m_ops[op.m_nextOp];
71297:                 m_backtrackingState.linkTo(endOp.m_reentry, this);
71297:                 break;
71297:             }
71297:             case OpParenthesesSubpatternTerminalEnd:
71297:                 // We should never be backtracking to here (hence the 'terminal' in the name).
71297:                 ASSERT(m_backtrackingState.isEmpty());
71297:                 m_backtrackingState.append(op.m_jumps);
71297:                 break;
71297: 
71297:             // OpParentheticalAssertionBegin/End
71297:             case OpParentheticalAssertionBegin: {
71297:                 PatternTerm* term = op.m_term;
71297:                 YarrOp& endOp = m_ops[op.m_nextOp];
71297: 
71297:                 // We need to handle the backtracks upon backtracking back out
71297:                 // of a parenthetical assertion if either we need to correct
71297:                 // the input index, or the assertion was inverted.
71297:                 if (op.m_checkAdjust || term->invert()) {
71297:                      m_backtrackingState.link(this);
71297: 
71297:                     if (op.m_checkAdjust)
71297:                         add32(Imm32(op.m_checkAdjust), index);
71297: 
71297:                     // In an inverted assertion failure to match the subpattern
71297:                     // is treated as a successful match - jump to the end of the
71297:                     // subpattern. We already have adjusted the input position
71297:                     // back to that before the assertion, which is correct.
71297:                     if (term->invert())
71297:                         jump(endOp.m_reentry);
71297: 
71297:                     m_backtrackingState.fallthrough();
71297:                 }
71297: 
71297:                 // The End node's jump list will contain any backtracks into
71297:                 // the end of the assertion. Also, if inverted, we will have
71297:                 // added the failure caused by a successful match to this.
71297:                 m_backtrackingState.append(endOp.m_jumps);
71297: 
71297:                 m_checked += op.m_checkAdjust;
71297:                 break;
71297:             }
71297:             case OpParentheticalAssertionEnd: {
71297:                 // FIXME: We should really be clearing any nested subpattern
71297:                 // matches on bailing out from after the pattern. Firefox has
71297:                 // this bug too (presumably because they use YARR!)
71297: 
71297:                 // Never backtrack into an assertion; later failures bail to before the begin.
71297:                 m_backtrackingState.takeBacktracksToJumpList(op.m_jumps, this);
71297: 
71297:                 YarrOp& lastOp = m_ops[op.m_previousOp];
71297:                 m_checked -= lastOp.m_checkAdjust;
71297:                 break;
71297:             }
71297: 
71297:             case OpMatchFailed:
71297:                 break;
71297:             }
71297: 
71297:         } while (opIndex);
71297:     }
71297: 
71297:     // Compilation methods:
71297:     // ====================
71297: 
71297:     // opCompileParenthesesSubpattern
71297:     // Emits ops for a subpattern (set of parentheses). These consist
71297:     // of a set of alternatives wrapped in an outer set of nodes for
71297:     // the parentheses.
71297:     // Supported types of parentheses are 'Once' (quantityCount == 1)
71297:     // and 'Terminal' (non-capturing parentheses quantified as greedy
71297:     // and infinite).
71297:     // Alternatives will use the 'Simple' set of ops if either the
71297:     // subpattern is terminal (in which case we will never need to
71297:     // backtrack), or if the subpattern only contains one alternative.
71297:     void opCompileParenthesesSubpattern(PatternTerm* term)
71297:     {
71297:         YarrOpCode parenthesesBeginOpCode;
71297:         YarrOpCode parenthesesEndOpCode;
71297:         YarrOpCode alternativeBeginOpCode = OpSimpleNestedAlternativeBegin;
71297:         YarrOpCode alternativeNextOpCode = OpSimpleNestedAlternativeNext;
71297:         YarrOpCode alternativeEndOpCode = OpSimpleNestedAlternativeEnd;
71297: 
71297:         // We can currently only compile quantity 1 subpatterns that are
71297:         // not copies. We generate a copy in the case of a range quantifier,
71297:         // e.g. /(?:x){3,9}/, or /(?:x)+/ (These are effectively expanded to
71297:         // /(?:x){3,3}(?:x){0,6}/ and /(?:x)(?:x)*/ repectively). The problem
71297:         // comes where the subpattern is capturing, in which case we would
71297:         // need to restore the capture from the first subpattern upon a
71297:         // failure in the second.
71297:         if (term->quantityCount == 1 && !term->parentheses.isCopy) {
71297:             // Select the 'Once' nodes.
71297:             parenthesesBeginOpCode = OpParenthesesSubpatternOnceBegin;
71297:             parenthesesEndOpCode = OpParenthesesSubpatternOnceEnd;
71297: 
71297:             // If there is more than one alternative we cannot use the 'simple' nodes.
71297:             if (term->parentheses.disjunction->m_alternatives.size() != 1) {
71297:                 alternativeBeginOpCode = OpNestedAlternativeBegin;
71297:                 alternativeNextOpCode = OpNestedAlternativeNext;
71297:                 alternativeEndOpCode = OpNestedAlternativeEnd;
71297:             }
71297:         } else if (term->parentheses.isTerminal) {
81594:             // Terminal groups are optimized on the assumption that matching will never
81594:             // backtrack into the terminal group. But this is false if there is more
81594:             // than one alternative and one of the alternatives can match empty. In that
81594:             // case, the empty match is counted as a failure, so we would need to backtrack.
81594:             // The backtracking code doesn't handle this case correctly, so we fall back
81594:             // to the interpreter.
81594:             Vector<PatternAlternative*>& alternatives = term->parentheses.disjunction->m_alternatives;
81594:             if (alternatives.size() != 1) {
81594:                 for (unsigned i = 0; i < alternatives.size(); ++i) {
81594:                     if (alternatives[i]->m_minimumSize == 0) {
81594:                         m_shouldFallBack = true;
81594:                         return;
81594:                     }
81594:                 }
81594:             }
81594:                         
71297:             // Select the 'Terminal' nodes.
71297:             parenthesesBeginOpCode = OpParenthesesSubpatternTerminalBegin;
71297:             parenthesesEndOpCode = OpParenthesesSubpatternTerminalEnd;
71297:         } else {
71297:             // This subpattern is not supported by the JIT.
71297:             m_shouldFallBack = true;
71297:             return;
71297:         }
71297: 
71297:         size_t parenBegin = m_ops.size();
71297:         m_ops.append(parenthesesBeginOpCode);
71297: 
71297:         m_ops.append(alternativeBeginOpCode);
71297:         m_ops.last().m_previousOp = notFound;
71297:         m_ops.last().m_term = term;
71297:         Vector<PatternAlternative*>& alternatives =  term->parentheses.disjunction->m_alternatives;
71297:         for (unsigned i = 0; i < alternatives.size(); ++i) {
71297:             size_t lastOpIndex = m_ops.size() - 1;
71297: 
71297:             PatternAlternative* nestedAlternative = alternatives[i];
71297:             opCompileAlternative(nestedAlternative);
71297: 
71297:             size_t thisOpIndex = m_ops.size();
71297:             m_ops.append(YarrOp(alternativeNextOpCode));
71297: 
71297:             YarrOp& lastOp = m_ops[lastOpIndex];
71297:             YarrOp& thisOp = m_ops[thisOpIndex];
71297: 
71297:             lastOp.m_alternative = nestedAlternative;
71297:             lastOp.m_nextOp = thisOpIndex;
71297:             thisOp.m_previousOp = lastOpIndex;
71297:             thisOp.m_term = term;
71297:         }
71297:         YarrOp& lastOp = m_ops.last();
71297:         ASSERT(lastOp.m_op == alternativeNextOpCode);
71297:         lastOp.m_op = alternativeEndOpCode;
71297:         lastOp.m_alternative = 0;
71297:         lastOp.m_nextOp = notFound;
71297: 
71297:         size_t parenEnd = m_ops.size();
71297:         m_ops.append(parenthesesEndOpCode);
71297: 
71297:         m_ops[parenBegin].m_term = term;
71297:         m_ops[parenBegin].m_previousOp = notFound;
71297:         m_ops[parenBegin].m_nextOp = parenEnd;
71297:         m_ops[parenEnd].m_term = term;
71297:         m_ops[parenEnd].m_previousOp = parenBegin;
71297:         m_ops[parenEnd].m_nextOp = notFound;
71297:     }
71297: 
71297:     // opCompileParentheticalAssertion
71297:     // Emits ops for a parenthetical assertion. These consist of an
71297:     // OpSimpleNestedAlternativeBegin/Next/End set of nodes wrapping
71297:     // the alternatives, with these wrapped by an outer pair of
71297:     // OpParentheticalAssertionBegin/End nodes.
71297:     // We can always use the OpSimpleNestedAlternative nodes in the
71297:     // case of parenthetical assertions since these only ever match
71297:     // once, and will never backtrack back into the assertion.
71297:     void opCompileParentheticalAssertion(PatternTerm* term)
71297:     {
71297:         size_t parenBegin = m_ops.size();
71297:         m_ops.append(OpParentheticalAssertionBegin);
71297: 
71297:         m_ops.append(OpSimpleNestedAlternativeBegin);
71297:         m_ops.last().m_previousOp = notFound;
71297:         m_ops.last().m_term = term;
71297:         Vector<PatternAlternative*>& alternatives =  term->parentheses.disjunction->m_alternatives;
71297:         for (unsigned i = 0; i < alternatives.size(); ++i) {
71297:             size_t lastOpIndex = m_ops.size() - 1;
71297: 
71297:             PatternAlternative* nestedAlternative = alternatives[i];
71297:             opCompileAlternative(nestedAlternative);
71297: 
71297:             size_t thisOpIndex = m_ops.size();
71297:             m_ops.append(YarrOp(OpSimpleNestedAlternativeNext));
71297: 
71297:             YarrOp& lastOp = m_ops[lastOpIndex];
71297:             YarrOp& thisOp = m_ops[thisOpIndex];
71297: 
71297:             lastOp.m_alternative = nestedAlternative;
71297:             lastOp.m_nextOp = thisOpIndex;
71297:             thisOp.m_previousOp = lastOpIndex;
71297:             thisOp.m_term = term;
71297:         }
71297:         YarrOp& lastOp = m_ops.last();
71297:         ASSERT(lastOp.m_op == OpSimpleNestedAlternativeNext);
71297:         lastOp.m_op = OpSimpleNestedAlternativeEnd;
71297:         lastOp.m_alternative = 0;
71297:         lastOp.m_nextOp = notFound;
71297: 
71297:         size_t parenEnd = m_ops.size();
71297:         m_ops.append(OpParentheticalAssertionEnd);
71297: 
71297:         m_ops[parenBegin].m_term = term;
71297:         m_ops[parenBegin].m_previousOp = notFound;
71297:         m_ops[parenBegin].m_nextOp = parenEnd;
71297:         m_ops[parenEnd].m_term = term;
71297:         m_ops[parenEnd].m_previousOp = parenBegin;
71297:         m_ops[parenEnd].m_nextOp = notFound;
71297:     }
71297: 
71297:     // opCompileAlternative
71297:     // Called to emit nodes for all terms in an alternative.
71297:     void opCompileAlternative(PatternAlternative* alternative)
71297:     {
71297:         optimizeAlternative(alternative);
71297: 
71297:         for (unsigned i = 0; i < alternative->m_terms.size(); ++i) {
71297:             PatternTerm* term = &alternative->m_terms[i];
71297: 
71297:             switch (term->type) {
71297:             case PatternTerm::TypeParenthesesSubpattern:
71297:                 opCompileParenthesesSubpattern(term);
71297:                 break;
71297: 
71297:             case PatternTerm::TypeParentheticalAssertion:
71297:                 opCompileParentheticalAssertion(term);
71297:                 break;
71297: 
71297:             default:
71297:                 m_ops.append(term);
71297:             }
71297:         }
71297:     }
71297: 
71297:     // opCompileBody
71297:     // This method compiles the body disjunction of the regular expression.
71297:     // The body consists of two sets of alternatives - zero or more 'once
71297:     // through' (BOL anchored) alternatives, followed by zero or more
71297:     // repeated alternatives.
71297:     // For each of these two sets of alteratives, if not empty they will be
71297:     // wrapped in a set of OpBodyAlternativeBegin/Next/End nodes (with the
71297:     // 'begin' node referencing the first alternative, and 'next' nodes
71297:     // referencing any further alternatives. The begin/next/end nodes are
71297:     // linked together in a doubly linked list. In the case of repeating
71297:     // alternatives, the end node is also linked back to the beginning.
71297:     // If no repeating alternatives exist, then a OpMatchFailed node exists
71297:     // to return the failing result.
71297:     void opCompileBody(PatternDisjunction* disjunction)
71297:     {
71297:         Vector<PatternAlternative*>& alternatives =  disjunction->m_alternatives;
71297:         size_t currentAlternativeIndex = 0;
71297: 
71297:         // Emit the 'once through' alternatives.
71297:         if (alternatives.size() && alternatives[0]->onceThrough()) {
71297:             m_ops.append(YarrOp(OpBodyAlternativeBegin));
71297:             m_ops.last().m_previousOp = notFound;
71297: 
71297:             do {
71297:                 size_t lastOpIndex = m_ops.size() - 1;
71297:                 PatternAlternative* alternative = alternatives[currentAlternativeIndex];
71297:                 opCompileAlternative(alternative);
71297: 
71297:                 size_t thisOpIndex = m_ops.size();
71297:                 m_ops.append(YarrOp(OpBodyAlternativeNext));
71297: 
71297:                 YarrOp& lastOp = m_ops[lastOpIndex];
71297:                 YarrOp& thisOp = m_ops[thisOpIndex];
71297: 
71297:                 lastOp.m_alternative = alternative;
71297:                 lastOp.m_nextOp = thisOpIndex;
71297:                 thisOp.m_previousOp = lastOpIndex;
71297:                 
71297:                 ++currentAlternativeIndex;
71297:             } while (currentAlternativeIndex < alternatives.size() && alternatives[currentAlternativeIndex]->onceThrough());
71297: 
71297:             YarrOp& lastOp = m_ops.last();
71297: 
71297:             ASSERT(lastOp.m_op == OpBodyAlternativeNext);
71297:             lastOp.m_op = OpBodyAlternativeEnd;
71297:             lastOp.m_alternative = 0;
71297:             lastOp.m_nextOp = notFound;
71297:         }
71297: 
71297:         if (currentAlternativeIndex == alternatives.size()) {
71297:             m_ops.append(YarrOp(OpMatchFailed));
71297:             return;
71297:         }
71297: 
71297:         // Emit the repeated alternatives.
71297:         size_t repeatLoop = m_ops.size();
71297:         m_ops.append(YarrOp(OpBodyAlternativeBegin));
71297:         m_ops.last().m_previousOp = notFound;
71297:         do {
71297:             size_t lastOpIndex = m_ops.size() - 1;
71297:             PatternAlternative* alternative = alternatives[currentAlternativeIndex];
71297:             ASSERT(!alternative->onceThrough());
71297:             opCompileAlternative(alternative);
71297: 
71297:             size_t thisOpIndex = m_ops.size();
71297:             m_ops.append(YarrOp(OpBodyAlternativeNext));
71297: 
71297:             YarrOp& lastOp = m_ops[lastOpIndex];
71297:             YarrOp& thisOp = m_ops[thisOpIndex];
71297: 
71297:             lastOp.m_alternative = alternative;
71297:             lastOp.m_nextOp = thisOpIndex;
71297:             thisOp.m_previousOp = lastOpIndex;
71297:             
71297:             ++currentAlternativeIndex;
71297:         } while (currentAlternativeIndex < alternatives.size());
71297:         YarrOp& lastOp = m_ops.last();
71297:         ASSERT(lastOp.m_op == OpBodyAlternativeNext);
71297:         lastOp.m_op = OpBodyAlternativeEnd;
71297:         lastOp.m_alternative = 0;
71297:         lastOp.m_nextOp = repeatLoop;
71297:     }
71297: 
71297:     void generateEnter()
71297:     {
71297: #if WTF_CPU_X86_64
71297:         push(X86Registers::ebp);
71297:         move(stackPointerRegister, X86Registers::ebp);
71297:         push(X86Registers::ebx);
71297: #elif WTF_CPU_X86
71297:         push(X86Registers::ebp);
71297:         move(stackPointerRegister, X86Registers::ebp);
71297:         // TODO: do we need spill registers to fill the output pointer if there are no sub captures?
71297:         push(X86Registers::ebx);
71297:         push(X86Registers::edi);
71297:         push(X86Registers::esi);
71297:         // load output into edi (2 = saved ebp + return address).
74474:     #if WTF_COMPILER_MSVC || WTF_COMPILER_SUNCC
71297:         loadPtr(Address(X86Registers::ebp, 2 * sizeof(void*)), input);
71297:         loadPtr(Address(X86Registers::ebp, 3 * sizeof(void*)), index);
71297:         loadPtr(Address(X86Registers::ebp, 4 * sizeof(void*)), length);
71297:         loadPtr(Address(X86Registers::ebp, 5 * sizeof(void*)), output);
71297:     #else
71297:         loadPtr(Address(X86Registers::ebp, 2 * sizeof(void*)), output);
71297:     #endif
71297: #elif WTF_CPU_ARM
71297:         push(ARMRegisters::r4);
71297:         push(ARMRegisters::r5);
71297:         push(ARMRegisters::r6);
71297: #if WTF_CPU_ARM_TRADITIONAL
71297:         push(ARMRegisters::r8); // scratch register
71297: #endif
71297:         move(ARMRegisters::r3, output);
71297: #elif WTF_CPU_SH4
71297:         push(SH4Registers::r11);
71297:         push(SH4Registers::r13);
73085: #elif WTF_CPU_SPARC
73085:         save(Imm32(-m_pattern.m_body->m_callFrameSize * sizeof(void*)));
71297: #elif WTF_CPU_MIPS
71297:         // Do nothing.
71297: #endif
71297:     }
71297: 
71297:     void generateReturn()
71297:     {
71297: #if WTF_CPU_X86_64
71297:         pop(X86Registers::ebx);
71297:         pop(X86Registers::ebp);
71297: #elif WTF_CPU_X86
71297:         pop(X86Registers::esi);
71297:         pop(X86Registers::edi);
71297:         pop(X86Registers::ebx);
71297:         pop(X86Registers::ebp);
71297: #elif WTF_CPU_ARM
71297: #if WTF_CPU_ARM_TRADITIONAL
71297:         pop(ARMRegisters::r8); // scratch register
71297: #endif
71297:         pop(ARMRegisters::r6);
71297:         pop(ARMRegisters::r5);
71297:         pop(ARMRegisters::r4);
71297: #elif WTF_CPU_SH4
71297:         pop(SH4Registers::r13);
71297:         pop(SH4Registers::r11);
73085: #elif WTF_CPU_SPARC
73085:         ret_and_restore();
73085:         return;
71297: #elif WTF_CPU_MIPS
71297:         // Do nothing
71297: #endif
71297:         ret();
71297:     }
71297: 
71297: public:
71297:     YarrGenerator(YarrPattern& pattern)
71297:         : m_pattern(pattern)
71297:         , m_shouldFallBack(false)
71297:         , m_checked(0)
71297:     {
71297:     }
71297: 
71297:     void compile(JSGlobalData* globalData, YarrCodeBlock& jitObject)
71297:     {
71297:         generateEnter();
71297: 
71297:         if (!m_pattern.m_body->m_hasFixedSize)
71297:             store32(index, Address(output));
71297: 
80821: #if !WTF_CPU_SPARC
71297:         if (m_pattern.m_body->m_callFrameSize)
71297:             subPtr(Imm32(m_pattern.m_body->m_callFrameSize * sizeof(void*)), stackPointerRegister);
80821: #endif
71297: 
71297:         // Compile the pattern to the internal 'YarrOp' representation.
71297:         opCompileBody(m_pattern.m_body);
71297: 
71297:         // If we encountered anything we can't handle in the JIT code
71297:         // (e.g. backreferences) then return early.
71297:         if (m_shouldFallBack) {
71297:             jitObject.setFallBack(true);
71297:             return;
71297:         }
71297: 
71297:         generate();
71297:         backtrack();
71297: 
71297:         // Link & finalize the code.
71297:         // XXX yarr-oom
71297:         ExecutablePool *pool;
71297:         bool ok;
77559:         LinkBuffer linkBuffer(this, globalData->regexAllocator, &pool, &ok, REGEXP_CODE);
71297:         m_backtrackingState.linkDataLabels(linkBuffer);
71297:         jitObject.set(linkBuffer.finalizeCode());
71297:         jitObject.setFallBack(m_shouldFallBack);
71297:     }
71297: 
71297: private:
71297:     YarrPattern& m_pattern;
71297: 
71297:     // Used to detect regular expression constructs that are not currently
71297:     // supported in the JIT; fall back to the interpreter when this is detected.
71297:     bool m_shouldFallBack;
71297: 
71297:     // The regular expression expressed as a linear sequence of operations.
71297:     Vector<YarrOp, 128> m_ops;
71297: 
71297:     // This records the current input offset being applied due to the current
71297:     // set of alternatives we are nested within. E.g. when matching the
71297:     // character 'b' within the regular expression /abc/, we will know that
71297:     // the minimum size for the alternative is 3, checked upon entry to the
71297:     // alternative, and that 'b' is at offset 1 from the start, and as such
71297:     // when matching 'b' we need to apply an offset of -2 to the load.
71297:     //
71297:     // FIXME: This should go away. Rather than tracking this value throughout
71297:     // code generation, we should gather this information up front & store it
71297:     // on the YarrOp structure.
71297:     int m_checked;
71297: 
71297:     // This class records state whilst generating the backtracking path of code.
71297:     BacktrackingState m_backtrackingState;
71297: };
71297: 
71297: void jitCompile(YarrPattern& pattern, JSGlobalData* globalData, YarrCodeBlock& jitObject)
71297: {
71297:     YarrGenerator(pattern).compile(globalData, jitObject);
71297: }
71297: 
71297: int execute(YarrCodeBlock& jitObject, const UChar* input, unsigned start, unsigned length, int* output)
71297: {
71297:     return jitObject.execute(input, start, length, output);
71297: }
71297: 
71297: }}
71297: 
71297: #endif
