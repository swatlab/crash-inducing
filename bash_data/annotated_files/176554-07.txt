149604: # This Source Code Form is subject to the terms of the Mozilla Public
149604: # License, v. 2.0. If a copy of the MPL was not distributed with this
149604: # file, You can obtain one at http://mozilla.org/MPL/2.0/.
149604: 
149604: from __future__ import unicode_literals
149604: 
152884: from contextlib import contextmanager
152884: 
176554: from .copier import FilePurger
152885: from .files import (
152885:     AbsoluteSymlinkFile,
159242:     ExistingFile,
152885:     File,
152885: )
149604: import mozpack.path as mozpath
149604: 
149604: 
152884: # This probably belongs in a more generic module. Where?
152884: @contextmanager
152884: def _auto_fileobj(path, fileobj, mode='r'):
152884:     if path and fileobj:
152884:         raise AssertionError('Only 1 of path or fileobj may be defined.')
152884: 
152884:     if not path and not fileobj:
152884:         raise AssertionError('Must specified 1 of path or fileobj.')
152884: 
152884:     if path:
152884:         fileobj = open(path, mode)
152884: 
152884:     try:
152884:         yield fileobj
152884:     finally:
152884:         if path:
152884:             fileobj.close()
152884: 
152884: 
152885: class UnreadableInstallManifest(Exception):
152885:     """Raised when an invalid install manifest is parsed."""
152885: 
152885: 
152885: class InstallManifest(object):
152885:     """Describes actions to be used with a copier.FileCopier instance.
152885: 
152885:     This class facilitates serialization and deserialization of data used to
152885:     construct a copier.FileCopier and to perform copy operations.
152885: 
152885:     The manifest defines source paths, destination paths, and a mechanism by
152885:     which the destination file should come into existence.
152885: 
152885:     Entries in the manifest correspond to the following types:
152885: 
152885:       copy -- The file specified as the source path will be copied to the
152885:           destination path.
152885: 
152885:       symlink -- The destination path will be a symlink to the source path.
152885:           If symlinks are not supported, a copy will be performed.
152885: 
152885:       exists -- The destination path is accounted for and won't be deleted by
159242:           the FileCopier. If the destination path doesn't exist, an error is
159242:           raised.
159242: 
159242:       optional -- The destination path is accounted for and won't be deleted by
159242:           the FileCopier. No error is raised if the destination path does not
159242:           exist.
159242: 
176554:     Versions 1 and 2 of the manifest format are similar. Version 2 added
176554:     optional path support.
152885:     """
152885:     FIELD_SEPARATOR = '\x1f'
152885: 
152885:     SYMLINK = 1
152885:     COPY = 2
152885:     REQUIRED_EXISTS = 3
159242:     OPTIONAL_EXISTS = 4
152885: 
152885:     def __init__(self, path=None, fileobj=None):
152885:         """Create a new InstallManifest entry.
152885: 
152885:         If path is defined, the manifest will be populated with data from the
152885:         file path.
152885: 
152885:         If fh is defined, the manifest will be populated with data read
152885:         from the specified file object.
152885: 
152885:         Both path and fileobj cannot be defined.
152885:         """
152885:         self._dests = {}
152885: 
152885:         if not path and not fileobj:
152885:             return
152885: 
152885:         with _auto_fileobj(path, fileobj, 'rb') as fh:
152885:             self._load_from_fileobj(fh)
152885: 
152885:     def _load_from_fileobj(self, fileobj):
152885:         version = fileobj.readline().rstrip()
176554:         if version not in ('1', '2'):
152885:             raise UnreadableInstallManifest('Unknown manifest version: ' %
152885:                 version)
152885: 
152885:         for line in fileobj:
152885:             line = line.rstrip()
152885: 
152885:             fields = line.split(self.FIELD_SEPARATOR)
152885: 
152885:             record_type = int(fields[0])
152885: 
152885:             if record_type == self.SYMLINK:
152885:                 dest, source= fields[1:]
152885:                 self.add_symlink(source, dest)
152885:                 continue
152885: 
152885:             if record_type == self.COPY:
152885:                 dest, source = fields[1:]
152885:                 self.add_copy(source, dest)
152885:                 continue
152885: 
152885:             if record_type == self.REQUIRED_EXISTS:
152885:                 _, path = fields
152885:                 self.add_required_exists(path)
152885:                 continue
152885: 
159242:             if record_type == self.OPTIONAL_EXISTS:
159242:                 _, path = fields
159242:                 self.add_optional_exists(path)
159242:                 continue
159242: 
152885:             raise UnreadableInstallManifest('Unknown record type: %d' %
152885:                 record_type)
152885: 
152885:     def __len__(self):
152885:         return len(self._dests)
152885: 
152885:     def __contains__(self, item):
152885:         return item in self._dests
152885: 
152885:     def __eq__(self, other):
152885:         return isinstance(other, InstallManifest) and self._dests == other._dests
152885: 
152885:     def __neq__(self, other):
152885:         return not self.__eq__(other)
152885: 
152885:     def __ior__(self, other):
152885:         if not isinstance(other, InstallManifest):
152885:             raise ValueError('Can only | with another instance of InstallManifest.')
152885: 
152885:         for dest in sorted(other._dests):
152885:             self._add_entry(dest, other._dests[dest])
152885: 
152885:         return self
152885: 
152885:     def write(self, path=None, fileobj=None):
152885:         """Serialize this manifest to a file or file object.
152885: 
152885:         If path is specified, that file will be written to. If fileobj is specified,
152885:         the serialized content will be written to that file object.
152885: 
152885:         It is an error if both are specified.
152885:         """
152885:         with _auto_fileobj(path, fileobj, 'wb') as fh:
176554:             fh.write('2\n')
152885: 
152885:             for dest in sorted(self._dests):
152885:                 entry = self._dests[dest]
152885: 
152885:                 parts = ['%d' % entry[0], dest]
152885:                 parts.extend(entry[1:])
152885:                 fh.write('%s\n' % self.FIELD_SEPARATOR.join(
152885:                     p.encode('utf-8') for p in parts))
152885: 
152885:     def add_symlink(self, source, dest):
152885:         """Add a symlink to this manifest.
152885: 
152885:         dest will be a symlink to source.
152885:         """
152885:         self._add_entry(dest, (self.SYMLINK, source))
152885: 
152885:     def add_copy(self, source, dest):
152885:         """Add a copy to this manifest.
152885: 
152885:         source will be copied to dest.
152885:         """
152885:         self._add_entry(dest, (self.COPY, source))
152885: 
152885:     def add_required_exists(self, dest):
159242:         """Record that a destination file must exist.
152885: 
152885:         This effectively prevents the listed file from being deleted.
152885:         """
152885:         self._add_entry(dest, (self.REQUIRED_EXISTS,))
152885: 
159242:     def add_optional_exists(self, dest):
159242:         """Record that a destination file may exist.
159242: 
159242:         This effectively prevents the listed file from being deleted. Unlike a
159242:         "required exists" file, files of this type do not raise errors if the
159242:         destination file does not exist.
159242:         """
159242:         self._add_entry(dest, (self.OPTIONAL_EXISTS,))
159242: 
152885:     def _add_entry(self, dest, entry):
152885:         if dest in self._dests:
152885:             raise ValueError('Item already in manifest: %s' % dest)
152885: 
152885:         self._dests[dest] = entry
152885: 
152885:     def populate_registry(self, registry):
152885:         """Populate a mozpack.copier.FileRegistry instance with data from us.
152885: 
152885:         The caller supplied a FileRegistry instance (or at least something that
152885:         conforms to its interface) and that instance is populated with data
152885:         from this manifest.
152885:         """
152885:         for dest in sorted(self._dests):
152885:             entry = self._dests[dest]
152885:             install_type = entry[0]
152885: 
152885:             if install_type == self.SYMLINK:
152885:                 registry.add(dest, AbsoluteSymlinkFile(entry[1]))
152885:                 continue
152885: 
152885:             if install_type == self.COPY:
152885:                 registry.add(dest, File(entry[1]))
152885:                 continue
152885: 
152885:             if install_type == self.REQUIRED_EXISTS:
159242:                 registry.add(dest, ExistingFile(required=True))
159242:                 continue
159242: 
159242:             if install_type == self.OPTIONAL_EXISTS:
159242:                 registry.add(dest, ExistingFile(required=False))
152885:                 continue
152885: 
152885:             raise Exception('Unknown install type defined in manifest: %d' %
152885:                 install_type)
