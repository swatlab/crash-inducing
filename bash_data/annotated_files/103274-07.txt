     1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 34352:  * vim: set ts=4 sw=4 et tw=78:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #ifndef jsinterp_h___
     1: #define jsinterp_h___
     1: /*
     1:  * JS interpreter interface.
     1:  */
     1: #include "jsprvtd.h"
     1: #include "jspubtd.h"
 11377: #include "jsopcode.h"
     1: 
 69223: #include "vm/Stack.h"
     1: 
 42714: namespace js {
 42714: 
 64363: /* Implemented in jsdbgapi: */
 64363: 
 84070: /*
 84070:  * Announce to the debugger that the thread has entered a new JavaScript frame,
 84070:  * |fp|. Call whatever hooks have been registered to observe new frames, and
 84070:  * return a JSTrapStatus code indication how execution should proceed:
 84070:  *
 84070:  * - JSTRAP_CONTINUE: Continue execution normally.
 84070:  *
 84070:  * - JSTRAP_THROW: Throw an exception. ScriptDebugPrologue has set |cx|'s
 84070:  *   pending exception to the value to be thrown.
 84070:  *
 84070:  * - JSTRAP_ERROR: Terminate execution (as is done when a script is terminated
 84070:  *   for running too long). ScriptDebugPrologue has cleared |cx|'s pending
 84070:  *   exception.
 84070:  *
 84070:  * - JSTRAP_RETURN: Return from the new frame immediately. ScriptDebugPrologue
 84070:  *   has set |cx->fp()|'s return value appropriately.
 84070:  */
 84070: extern JSTrapStatus
 69223: ScriptDebugPrologue(JSContext *cx, StackFrame *fp);
 64363: 
 91435: /*
 91435:  * Announce to the debugger that the thread has exited a JavaScript frame, |fp|.
 91435:  * If |ok| is true, the frame is returning normally; if |ok| is false, the frame
 91435:  * is throwing an exception or terminating.
 91435:  *
 91435:  * Call whatever hooks have been registered to observe frame exits. Change cx's
 91435:  * current exception and |fp|'s return value to reflect the changes in behavior
 91435:  * the hooks request, if any. Return the new error/success value.
 91435:  *
 91435:  * This function may be called twice for the same outgoing frame; only the
 91435:  * first call has any effect. (Permitting double calls simplifies some
 91435:  * cases where an onPop handler's resumption value changes a return to a
 91435:  * throw, or vice versa: we can redirect to a complete copy of the
 91435:  * alternative path, containing its own call to ScriptDebugEpilogue.)
 91435:  */
 64363: extern bool
 69223: ScriptDebugEpilogue(JSContext *cx, StackFrame *fp, bool ok);
 64363: 
 64363: /*
 68904:  * For a given |call|, convert null/undefined |this| into the global object for
 68904:  * the callee and replace other primitives with boxed versions. This assumes
 68904:  * that call.callee() is not strict mode code. This is the special/slow case of
 68904:  * ComputeThis.
     1:  */
 53081: extern bool
 68904: BoxNonStrictThis(JSContext *cx, const CallReceiver &call);
 68904: 
 68904: /*
 68904:  * Ensure that fp->thisValue() is the correct value of |this| for the scripted
 68904:  * call represented by |fp|. ComputeThis is necessary because fp->thisValue()
 68904:  * may be set to 'undefined' when 'this' should really be the global object (as
 68904:  * an optimization to avoid global-this computation).
 68904:  */
 68904: inline bool
 69223: ComputeThis(JSContext *cx, StackFrame *fp);
 69223: 
 77341: enum MaybeConstruct {
 77341:     NO_CONSTRUCT = INITIAL_NONE,
 77341:     CONSTRUCT = INITIAL_CONSTRUCT
 77341: };
 77341: 
103274: extern bool
103274: ReportIsNotFunction(JSContext *cx, const Value &v, MaybeConstruct construct = NO_CONSTRUCT);
103274: 
103274: extern bool
103274: ReportIsNotFunction(JSContext *cx, const Value *vp, MaybeConstruct construct = NO_CONSTRUCT);
103274: 
103274: extern JSObject *
103274: ValueToCallable(JSContext *cx, const Value *vp, MaybeConstruct construct = NO_CONSTRUCT);
103274: 
103274: inline JSFunction *
103274: ReportIfNotFunction(JSContext *cx, const Value &v, MaybeConstruct construct = NO_CONSTRUCT)
103274: {
103274:     if (v.isObject() && v.toObject().isFunction())
103274:         return v.toObject().toFunction();
103274: 
103274:     ReportIsNotFunction(cx, v, construct);
103274:     return NULL;
103274: }
103274: 
 69223: /*
 76829:  * InvokeKernel assumes that the given args have been pushed on the top of the
 76829:  * VM stack. Additionally, if 'args' is contained in a CallArgsList, that they
 76829:  * have already been marked 'active'.
     1:  */
 71697: extern bool
 79387: InvokeKernel(JSContext *cx, CallArgs args, MaybeConstruct construct = NO_CONSTRUCT);
 48470: 
     1: /*
 76829:  * Invoke assumes that 'args' has been pushed (via ContextStack::pushInvokeArgs)
 76829:  * and is currently at the top of the VM stack.
 71697:  */
 71697: inline bool
 71697: Invoke(JSContext *cx, InvokeArgsGuard &args, MaybeConstruct construct = NO_CONSTRUCT)
 71697: {
 71697:     args.setActive();
 76829:     bool ok = InvokeKernel(cx, args, construct);
 71697:     args.setInactive();
 71697:     return ok;
 71697: }
 71697: 
 71697: /*
 76829:  * This Invoke overload places the least requirements on the caller: it may be
 76829:  * called at any time and it takes care of copying the given callee, this, and
 76829:  * arguments onto the stack.
 76829:  */
 76829: extern bool
 91237: Invoke(JSContext *cx, const Value &thisv, const Value &fval, unsigned argc, Value *argv,
 76829:        Value *rval);
 76829: 
 76829: /*
 76829:  * This helper takes care of the infinite-recursion check necessary for
 76829:  * getter/setter calls.
 76829:  */
 76829: extern bool
 91237: InvokeGetterOrSetter(JSContext *cx, JSObject *obj, const Value &fval, unsigned argc, Value *argv,
 76829:                      Value *rval);
 76829: 
 76829: /*
 76829:  * InvokeConstructor* implement a function call from a constructor context
 76829:  * (e.g. 'new') handling the the creation of the new 'this' object.
     1:  */
 86484: extern bool
103274: InvokeConstructorKernel(JSContext *cx, CallArgs args);
 53557: 
 76829: /* See the InvokeArgsGuard overload of Invoke. */
 76829: inline bool
 76829: InvokeConstructor(JSContext *cx, InvokeArgsGuard &args)
 76829: {
 76829:     args.setActive();
 76829:     bool ok = InvokeConstructorKernel(cx, ImplicitCast<CallArgs>(args));
 76829:     args.setInactive();
 76829:     return ok;
 76829: }
 76829: 
 76829: /* See the fval overload of Invoke. */
 53557: extern bool
 91237: InvokeConstructor(JSContext *cx, const Value &fval, unsigned argc, Value *argv, Value *rval);
     1: 
 53557: /*
 71695:  * Executes a script with the given scopeChain/this. The 'type' indicates
 71695:  * whether this is eval code or global code. To support debugging, the
 71695:  * evalFrame parameter can point to an arbitrary frame in the context's call
 71695:  * stack to simulate executing an eval in that frame.
 53557:  */
 71695: extern bool
 76829: ExecuteKernel(JSContext *cx, JSScript *script, JSObject &scopeChain, const Value &thisv,
 71695:               ExecuteType type, StackFrame *evalInFrame, Value *result);
 69223: 
 76829: /* Execute a script with the given scopeChain as global code. */
 76829: extern bool
 76829: Execute(JSContext *cx, JSScript *script, JSObject &scopeChain, Value *rval);
 76829: 
 69223: /* Flags to toggle js::Interpret() execution. */
 69223: enum InterpMode
 69223: {
 69223:     JSINTERP_NORMAL    = 0, /* interpreter is running normally */
 87646:     JSINTERP_REJOIN    = 1, /* as normal, but the frame has already started */
 87646:     JSINTERP_SKIP_TRAP = 2  /* as REJOIN, but skip trap at first opcode */
 69223: };
     1: 
 53557: /*
 53557:  * Execute the caller-initialized frame for a user-defined script or function
 53557:  * pointed to by cx->fp until completion or error.
 53557:  */
 86484: extern JS_NEVER_INLINE bool
 71363: Interpret(JSContext *cx, StackFrame *stopFp, InterpMode mode = JSINTERP_NORMAL);
 48474: 
 86484: extern bool
 69223: RunScript(JSContext *cx, JSScript *script, StackFrame *fp);
 12551: 
 48470: extern bool
 88099: StrictlyEqual(JSContext *cx, const Value &lval, const Value &rval, bool *equal);
     1: 
 64551: extern bool
 88099: LooselyEqual(JSContext *cx, const Value &lval, const Value &rval, bool *equal);
 64551: 
 32760: /* === except that NaN is the same as NaN and -0 is not the same as +0. */
 48470: extern bool
 88099: SameValue(JSContext *cx, const Value &v1, const Value &v2, bool *same);
 32760: 
 48470: extern JSType
 48470: TypeOfValue(JSContext *cx, const Value &v);
 48470: 
 48529: extern JSBool
 98960: HasInstance(JSContext *cx, HandleObject obj, const js::Value *v, JSBool *bp);
 48529: 
 15996: /*
 77168:  * A linked list of the |FrameRegs regs;| variables belonging to all
 77168:  * js::Interpret C++ frames on this thread's stack.
 77168:  *
 77168:  * Note that this is *not* a list of all JS frames running under the
 77168:  * interpreter; that would include inlined frames, whose FrameRegs are
 77168:  * saved in various pieces in various places. Rather, this lists each
 77168:  * js::Interpret call's live 'regs'; when control returns to that call, it
 77168:  * will resume execution with this 'regs' instance.
 77168:  *
 77168:  * When Debugger puts a script in single-step mode, all js::Interpret
 77168:  * invocations that might be presently running that script must have
 77168:  * interrupts enabled. It's not practical to simply check
 77168:  * script->stepModeEnabled() at each point some callee could have changed
 77168:  * it, because there are so many places js::Interpret could possibly cause
 77168:  * JavaScript to run: each place an object might be coerced to a primitive
 77168:  * or a number, for example. So instead, we simply expose a list of the
 77168:  * 'regs' those frames are using, and let Debugger tweak the affected
 77168:  * js::Interpret frames when an onStep handler is established.
 77168:  *
 77168:  * Elements of this list are allocated within the js::Interpret stack
 77168:  * frames themselves; the list is headed by this thread's js::ThreadData.
 77168:  */
 77168: class InterpreterFrames {
 77168:   public:
 77168:     class InterruptEnablerBase {
 77168:       public:
 77168:         virtual void enableInterrupts() const = 0;
 77168:     };
 77168: 
 77168:     InterpreterFrames(JSContext *cx, FrameRegs *regs, const InterruptEnablerBase &enabler);
 77168:     ~InterpreterFrames();
 77168: 
 77168:     /* If this js::Interpret frame is running |script|, enable interrupts. */
 79734:     inline void enableInterruptsIfRunning(JSScript *script);
 77168: 
 77169:     InterpreterFrames *older;
 77169: 
 77168:   private:
 77168:     JSContext *context;
 77168:     FrameRegs *regs;
 77168:     const InterruptEnablerBase &enabler;
 77168: };
 77168: 
 52657: /*
 52657:  * Unwind block and scope chains to match the given depth. The function sets
 52657:  * fp->sp on return to stackDepth.
 52657:  */
 86484: extern void
 86484: UnwindScope(JSContext *cx, uint32_t stackDepth);
 52657: 
 91947: /*
 91947:  * Unwind for an uncatchable exception. This means not running finalizers, etc;
 91947:  * just preserving the basic engine stack invariants.
 91947:  */
 91947: extern void
 91947: UnwindForUncatchableException(JSContext *cx, const FrameRegs &regs);
 91947: 
 77822: extern bool
 95355: OnUnknownMethod(JSContext *cx, HandleObject obj, Value idval, Value *vp);
 52657: 
 91947: class TryNoteIter
 91947: {
 91947:     const FrameRegs &regs;
 91947:     JSScript *script;
 91947:     uint32_t pcOffset;
 91947:     JSTryNote *tn, *tnEnd;
 91947:     void settle();
 91947:   public:
 91947:     TryNoteIter(const FrameRegs &regs);
 91947:     bool done() const;
 91947:     void operator++();
 91947:     JSTryNote *operator*() const { return tn; }
 91947: };
 91947: 
 78614: /************************************************************************/
 78614: 
 78614: /*
 78614:  * To really poison a set of values, using 'magic' or 'undefined' isn't good
 78614:  * enough since often these will just be ignored by buggy code (see bug 629974)
 78614:  * in debug builds and crash in release builds. Instead, we use a safe-for-crash
 78614:  * pointer.
 78614:  */
 78614: static JS_ALWAYS_INLINE void
 78614: Debug_SetValueRangeToCrashOnTouch(Value *beg, Value *end)
 78614: {
 78614: #ifdef DEBUG
 78614:     for (Value *v = beg; v != end; ++v)
 98677:         v->setObject(*reinterpret_cast<JSObject *>(0x42));
 78614: #endif
 78614: }
 78614: 
 78614: static JS_ALWAYS_INLINE void
 78614: Debug_SetValueRangeToCrashOnTouch(Value *vec, size_t len)
 78614: {
 78614: #ifdef DEBUG
 78614:     Debug_SetValueRangeToCrashOnTouch(vec, vec + len);
 78614: #endif
 78614: }
 78614: 
 83301: static JS_ALWAYS_INLINE void
 83301: Debug_SetValueRangeToCrashOnTouch(HeapValue *vec, size_t len)
 83301: {
 83301: #ifdef DEBUG
 83301:     Debug_SetValueRangeToCrashOnTouch((Value *) vec, len);
 83301: #endif
 83301: }
 83301: 
 77822: }  /* namespace js */
 53125: 
     1: #endif /* jsinterp_h___ */
