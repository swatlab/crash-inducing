32195: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
32836: /* ***** BEGIN LICENSE BLOCK *****
32836:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
32836:  *
32836:  * The contents of this file are subject to the Mozilla Public License Version
32836:  * 1.1 (the "License"); you may not use this file except in compliance with
32836:  * the License. You may obtain a copy of the License at
32836:  * http://www.mozilla.org/MPL/
32836:  *
32836:  * Software distributed under the License is distributed on an "AS IS" basis,
32836:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
32836:  * for the specific language governing rights and limitations under the
32836:  * License.
32836:  *
32836:  * The Original Code is mozilla.org code.
32836:  *
32836:  * The Initial Developer of the Original Code is
32836:  *   Mozilla Corporation.
32836:  * Portions created by the Initial Developer are Copyright (C) 2009
32836:  * the Initial Developer. All Rights Reserved.
32836:  *
32836:  * Contributor(s):
32836:  *   Vladimir Vukicevic <vladimir@pobox.com> (original author)
32836:  *   Mark Steele <mwsteele@gmail.com>
42477:  *   Cedric Vivier <cedricv@neonux.com>
32836:  *
32836:  * Alternatively, the contents of this file may be used under the terms of
32836:  * either the GNU General Public License Version 2 or later (the "GPL"), or
32836:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
32836:  * in which case the provisions of the GPL or the LGPL are applicable instead
32836:  * of those above. If you wish to allow use of your version of this file only
32836:  * under the terms of either the GPL or the LGPL, and not to allow others to
32836:  * use your version of this file under the terms of the MPL, indicate your
32836:  * decision by deleting the provisions above and replace them with the notice
32836:  * and other provisions required by the GPL or the LGPL. If you do not delete
32836:  * the provisions above, a recipient may use your version of this file under
32836:  * the terms of any one of the MPL, the GPL or the LGPL.
32836:  *
32836:  * ***** END LICENSE BLOCK ***** */
32836: 
32195: #include "WebGLContext.h"
32195: 
32195: #include "nsString.h"
32195: 
32195: #include "gfxImageSurface.h"
32195: #include "gfxContext.h"
32195: #include "gfxPlatform.h"
32195: //#include "nsIDOMHTMLCanvasElement.h"
32195: 
32195: #include "nsContentUtils.h"
32195: #include "nsDOMError.h"
32195: #include "nsLayoutUtils.h"
32195: 
32195: #include "CanvasUtils.h"
32195: #include "NativeJSContext.h"
32195: 
37417: #include "jstypedarray.h"
37417: 
49256: #if defined(USE_ANGLE)
47653: // shader translator
47653: #include "angle/ShaderLang.h"
47653: #endif
47653: 
32195: using namespace mozilla;
32195: 
42916: static PRBool BaseTypeAndSizeFromUniformType(WebGLenum uType, WebGLenum *baseType, WebGLint *unitSize);
32195: 
32195: /* Helper macros for when we're just wrapping a gl method, so that
32195:  * we can avoid having to type this 500 times.  Note that these MUST
32195:  * NOT BE USED if we need to check any of the parameters.
32195:  */
32195: 
32195: #define GL_SAME_METHOD_0(glname, name)                          \
32195: NS_IMETHODIMP WebGLContext::name() {                            \
32195:     MakeContextCurrent(); gl->f##glname(); return NS_OK;        \
32195: }
32195: 
32195: #define GL_SAME_METHOD_1(glname, name, t1)          \
32195: NS_IMETHODIMP WebGLContext::name(t1 a1) {           \
32195:     MakeContextCurrent(); gl->f##glname(a1); return NS_OK;  \
32195: }
32195: 
32195: #define GL_SAME_METHOD_2(glname, name, t1, t2)        \
32195: NS_IMETHODIMP WebGLContext::name(t1 a1, t2 a2) {      \
32195:     MakeContextCurrent(); gl->f##glname(a1,a2); return NS_OK;           \
32195: }
32195: 
32195: #define GL_SAME_METHOD_3(glname, name, t1, t2, t3)      \
32195: NS_IMETHODIMP WebGLContext::name(t1 a1, t2 a2, t3 a3) { \
32195:     MakeContextCurrent(); gl->f##glname(a1,a2,a3); return NS_OK;        \
32195: }
32195: 
32195: #define GL_SAME_METHOD_4(glname, name, t1, t2, t3, t4)         \
32195: NS_IMETHODIMP WebGLContext::name(t1 a1, t2 a2, t3 a3, t4 a4) { \
32195:     MakeContextCurrent(); gl->f##glname(a1,a2,a3,a4); return NS_OK;     \
32195: }
32195: 
32195: #define GL_SAME_METHOD_5(glname, name, t1, t2, t3, t4, t5)            \
32195: NS_IMETHODIMP WebGLContext::name(t1 a1, t2 a2, t3 a3, t4 a4, t5 a5) { \
32195:     MakeContextCurrent(); gl->f##glname(a1,a2,a3,a4,a5); return NS_OK;  \
32195: }
32195: 
32195: #define GL_SAME_METHOD_6(glname, name, t1, t2, t3, t4, t5, t6)          \
32195: NS_IMETHODIMP WebGLContext::name(t1 a1, t2 a2, t3 a3, t4 a4, t5 a5, t6 a6) { \
32195:     MakeContextCurrent(); gl->f##glname(a1,a2,a3,a4,a5,a6); return NS_OK; \
32195: }
32195: 
43331: already_AddRefed<WebGLUniformLocation> WebGLProgram::GetUniformLocationObject(GLint glLocation)
43331: {
43331:     WebGLUniformLocation *existingLocationObject;
43331:     if (mMapUniformLocations.Get(glLocation, &existingLocationObject)) {
43331:         return existingLocationObject;
43331:     } else {
43331:         nsRefPtr<WebGLUniformLocation> loc = new WebGLUniformLocation(mContext, this, glLocation);
43331:         mMapUniformLocations.Put(glLocation, loc);
43331:         return loc.forget();
43331:     }
43331: }
43331: 
32195: //
32195: //  WebGL API
32195: //
32195: 
32835: 
32835: /* void present (); */
32835: NS_IMETHODIMP
32835: WebGLContext::Present()
32835: {
32835:     return NS_ERROR_NOT_IMPLEMENTED;
32835: }
32835: 
42916: /* void GlActiveTexture (in GLenum texture); */
32195: NS_IMETHODIMP
42916: WebGLContext::ActiveTexture(WebGLenum texture)
32195: {
32195:     if (texture < LOCAL_GL_TEXTURE0 || texture >= LOCAL_GL_TEXTURE0+mBound2DTextures.Length())
42477:         return ErrorInvalidEnum("ActiveTexture: texture unit %d out of range (0..%d)",
42477:                                 texture, mBound2DTextures.Length()-1);
32195: 
32195:     MakeContextCurrent();
32195:     mActiveTexture = texture - LOCAL_GL_TEXTURE0;
32195:     gl->fActiveTexture(texture);
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42471: WebGLContext::AttachShader(nsIWebGLProgram *pobj, nsIWebGLShader *shobj)
32195: {
42916:     WebGLuint progname, shadername;
43098:     WebGLProgram *program;
43098:     WebGLShader *shader;
47811:     if (!GetConcreteObjectAndGLName("attachShader: program", pobj, &program, &progname) ||
47811:         !GetConcreteObjectAndGLName("attachShader: shader", shobj, &shader, &shadername))
47811:         return NS_OK;
32195: 
43098:     if (!program->AttachShader(shader))
43098:         return ErrorInvalidOperation("AttachShader: shader is already attached");
43098: 
32195:     MakeContextCurrent();
32195: 
42472:     gl->fAttachShader(progname, shadername);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::BindAttribLocation(nsIWebGLProgram *pobj, WebGLuint location, const nsAString& name)
32195: {
42916:     WebGLuint progname;
47811:     if (!GetGLName<WebGLProgram>("bindAttribLocation: program", pobj, &progname))
47811:         return NS_OK;
42471: 
32195:     if (name.IsEmpty())
42477:         return ErrorInvalidValue("BindAttribLocation: name can't be null or empty");
32195: 
32195:     MakeContextCurrent();
32195: 
42472:     gl->fBindAttribLocation(progname, location, NS_LossyConvertUTF16toASCII(name).get());
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::BindBuffer(WebGLenum target, nsIWebGLBuffer *bobj)
32195: {
42916:     WebGLuint bufname;
42472:     WebGLBuffer* buf;
42472:     PRBool isNull;
47811:     if (!GetConcreteObjectAndGLName("bindBuffer", bobj, &buf, &bufname, &isNull))
47811:         return NS_OK;
35488: 
32195:     if (target == LOCAL_GL_ARRAY_BUFFER) {
42472:         mBoundArrayBuffer = buf;
32195:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
42472:         mBoundElementArrayBuffer = buf;
32195:     } else {
47813:         return ErrorInvalidEnumInfo("BindBuffer: target", target);
32195:     }
32195: 
43009:     if (!isNull) {
43009:         if ((buf->Target() != LOCAL_GL_NONE) && (target != buf->Target()))
43009:             return ErrorInvalidOperation("BindBuffer: buffer already bound to a different target");
43009:         buf->SetTarget(target);
43009:     }
43009: 
42472:     MakeContextCurrent();
42472: 
42472:     gl->fBindBuffer(target, bufname);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::BindFramebuffer(WebGLenum target, nsIWebGLFramebuffer *fbobj)
32195: {
42916:     WebGLuint framebuffername;
42472:     PRBool isNull;
42473:     WebGLFramebuffer *wfb;
42473: 
42473:     if (target != LOCAL_GL_FRAMEBUFFER)
42477:         return ErrorInvalidOperation("BindFramebuffer: target must be GL_FRAMEBUFFER");
42473: 
47811:     if (!GetConcreteObjectAndGLName("bindFramebuffer", fbobj, &wfb, &framebuffername, &isNull))
47811:         return NS_OK;
32195: 
42472:     MakeContextCurrent();
42472: 
47910:     if (isNull) {
47910:         gl->fBindFramebuffer(target, gl->GetOffscreenFBO());
47910:     } else {
42472:         gl->fBindFramebuffer(target, framebuffername);
47910:     }
32195: 
42473:     mBoundFramebuffer = wfb;
42473: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::BindRenderbuffer(WebGLenum target, nsIWebGLRenderbuffer *rbobj)
32195: {
42916:     WebGLuint renderbuffername;
42472:     PRBool isNull;
42473:     WebGLRenderbuffer *wrb;
42473: 
42477:     if (target != LOCAL_GL_RENDERBUFFER)
47813:         return ErrorInvalidEnumInfo("bindRenderbuffer: target", target);
42477: 
47811:     if (!GetConcreteObjectAndGLName("bindRenderBuffer", rbobj, &wrb, &renderbuffername, &isNull))
47811:         return NS_OK;
32195: 
32195:     MakeContextCurrent();
32195: 
42472:     gl->fBindRenderbuffer(target, renderbuffername);
32195: 
42473:     mBoundRenderbuffer = wrb;
42473: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::BindTexture(WebGLenum target, nsIWebGLTexture *tobj)
32195: {
42916:     WebGLuint texturename;
42472:     WebGLTexture *tex;
42472:     PRBool isNull;
47811:     if (!GetConcreteObjectAndGLName("bindTexture", tobj, &tex, &texturename, &isNull))
47811:         return NS_OK;
32195: 
32195:     if (target == LOCAL_GL_TEXTURE_2D) {
42472:         mBound2DTextures[mActiveTexture] = tex;
32195:     } else if (target == LOCAL_GL_TEXTURE_CUBE_MAP) {
42472:         mBoundCubeMapTextures[mActiveTexture] = tex;
32195:     } else {
47813:         return ErrorInvalidEnumInfo("bindTexture: target", target);
32195:     }
32195: 
42472:     MakeContextCurrent();
42472: 
42472:     gl->fBindTexture(target, texturename);
32195: 
32195:     return NS_OK;
32195: }
32195: 
47205: GL_SAME_METHOD_4(BlendColor, BlendColor, WebGLfloat, WebGLfloat, WebGLfloat, WebGLfloat)
32195: 
43855: NS_IMETHODIMP WebGLContext::BlendEquation(WebGLenum mode)
43855: {
46443:     if (!ValidateBlendEquationEnum(mode, "blendEquation: mode"))
46443:         return NS_OK;
43855: 
43855:     MakeContextCurrent();
43855:     gl->fBlendEquation(mode);
43855:     return NS_OK;
43855: }
43855: 
43855: NS_IMETHODIMP WebGLContext::BlendEquationSeparate(WebGLenum modeRGB, WebGLenum modeAlpha)
43855: {
46443:     if (!ValidateBlendEquationEnum(modeRGB, "blendEquationSeparate: modeRGB") ||
46443:         !ValidateBlendEquationEnum(modeAlpha, "blendEquationSeparate: modeAlpha"))
46443:         return NS_OK;
43855: 
43855:     MakeContextCurrent();
43855:     gl->fBlendEquationSeparate(modeRGB, modeAlpha);
43855:     return NS_OK;
43855: }
43855: 
43855: NS_IMETHODIMP WebGLContext::BlendFunc(WebGLenum sfactor, WebGLenum dfactor)
43855: {
46443:     if (!ValidateBlendFuncSrcEnum(sfactor, "blendFunc: sfactor") ||
46443:         !ValidateBlendFuncDstEnum(dfactor, "blendFunc: dfactor"))
46443:         return NS_OK;
43855: 
43855:     MakeContextCurrent();
43855:     gl->fBlendFunc(sfactor, dfactor);
43855:     return NS_OK;
43855: }
43855: 
43855: NS_IMETHODIMP
43855: WebGLContext::BlendFuncSeparate(WebGLenum srcRGB, WebGLenum dstRGB,
43855:                                 WebGLenum srcAlpha, WebGLenum dstAlpha)
43855: {
46443:     if (!ValidateBlendFuncSrcEnum(srcRGB, "blendFuncSeparate: srcRGB") ||
46443:         !ValidateBlendFuncSrcEnum(srcAlpha, "blendFuncSeparate: srcAlpha") ||
46443:         !ValidateBlendFuncDstEnum(dstRGB, "blendFuncSeparate: dstRGB") ||
46443:         !ValidateBlendFuncDstEnum(dstAlpha, "blendFuncSeparate: dstAlpha"))
46443:         return NS_OK;
43855: 
43855:     MakeContextCurrent();
43855:     gl->fBlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
43855:     return NS_OK;
43855: }
32195: 
32195: NS_IMETHODIMP
37417: WebGLContext::BufferData(PRInt32 dummy)
32195: {
37417:     // this should never be called
37417:     LogMessage("BufferData");
37417:     return NS_ERROR_FAILURE;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::BufferData_size(WebGLenum target, WebGLsizei size, WebGLenum usage)
32195: {
32195:     WebGLBuffer *boundBuffer = NULL;
32195: 
32195:     if (target == LOCAL_GL_ARRAY_BUFFER) {
32195:         boundBuffer = mBoundArrayBuffer;
32195:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
32195:         boundBuffer = mBoundElementArrayBuffer;
32195:     } else {
47813:         return ErrorInvalidEnumInfo("bufferData: target", target);
32195:     }
32195: 
47206:     if (size < 0)
47206:         return ErrorInvalidValue("bufferData: negative size");
47206: 
47206:     if (!ValidateBufferUsageEnum(usage, "bufferData: usage"))
47206:         return NS_OK;
47206: 
42477:     if (!boundBuffer)
42477:         return ErrorInvalidOperation("BufferData: no buffer bound!");
37417: 
37417:     MakeContextCurrent();
37417: 
37417:     boundBuffer->SetByteLength(size);
43009:     boundBuffer->ZeroDataIfElementArray();
43009: 
37417:     gl->fBufferData(target, size, 0, usage);
37417: 
37417:     return NS_OK;
32195: }
32195: 
37417: NS_IMETHODIMP
42916: WebGLContext::BufferData_buf(WebGLenum target, js::ArrayBuffer *wb, WebGLenum usage)
37417: {
37417:     WebGLBuffer *boundBuffer = NULL;
37417: 
37417:     if (target == LOCAL_GL_ARRAY_BUFFER) {
37417:         boundBuffer = mBoundArrayBuffer;
37417:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
37417:         boundBuffer = mBoundElementArrayBuffer;
37417:     } else {
47813:         return ErrorInvalidEnumInfo("bufferData: target", target);
37417:     }
37417: 
47206:     if (!ValidateBufferUsageEnum(usage, "bufferData: usage"))
47206:         return NS_OK;
47206: 
42477:     if (!boundBuffer)
42477:         return ErrorInvalidOperation("BufferData: no buffer bound!");
37417: 
37417:     MakeContextCurrent();
37417: 
37417:     boundBuffer->SetByteLength(wb->byteLength);
43009:     boundBuffer->CopyDataIfElementArray(wb->data);
43009: 
37417:     gl->fBufferData(target, wb->byteLength, wb->data, usage);
37417: 
37417:     return NS_OK;
37417: }
37417: 
37417: NS_IMETHODIMP
42916: WebGLContext::BufferData_array(WebGLenum target, js::TypedArray *wa, WebGLenum usage)
37417: {
37417:     WebGLBuffer *boundBuffer = NULL;
37417: 
37417:     if (target == LOCAL_GL_ARRAY_BUFFER) {
37417:         boundBuffer = mBoundArrayBuffer;
37417:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
37417:         boundBuffer = mBoundElementArrayBuffer;
37417:     } else {
47813:         return ErrorInvalidEnumInfo("bufferData: target", target);
37417:     }
37417: 
47206:     if (!ValidateBufferUsageEnum(usage, "bufferData: usage"))
47206:         return NS_OK;
47206: 
42477:     if (!boundBuffer)
42477:         return ErrorInvalidOperation("BufferData: no buffer bound!");
37417: 
37417:     MakeContextCurrent();
37417: 
37417:     boundBuffer->SetByteLength(wa->byteLength);
43009:     boundBuffer->CopyDataIfElementArray(wa->data);
43009: 
37417:     gl->fBufferData(target, wa->byteLength, wa->data, usage);
37417: 
37417:     return NS_OK;
37417: }
37417: 
37417: NS_IMETHODIMP
37417: WebGLContext::BufferSubData(PRInt32 dummy)
37417: {
32195:     return NS_ERROR_FAILURE;
32195: }
37417: 
37417: NS_IMETHODIMP
43009: WebGLContext::BufferSubData_buf(GLenum target, WebGLsizei byteOffset, js::ArrayBuffer *wb)
37417: {
37417:     WebGLBuffer *boundBuffer = NULL;
37417: 
37417:     if (target == LOCAL_GL_ARRAY_BUFFER) {
37417:         boundBuffer = mBoundArrayBuffer;
37417:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
37417:         boundBuffer = mBoundElementArrayBuffer;
37417:     } else {
47813:         return ErrorInvalidEnumInfo("bufferSubData: target", target);
32195:     }
37417: 
42477:     if (!boundBuffer)
42477:         return ErrorInvalidOperation("BufferData: no buffer bound!");
37417: 
47204:     CheckedUint32 checked_neededByteLength = CheckedUint32(byteOffset) + wb->byteLength;
47204:     if (!checked_neededByteLength.valid())
47204:         return ErrorInvalidOperation("bufferSubData: integer overflow computing the needed byte length");
47204: 
47204:     if (checked_neededByteLength.value() > boundBuffer->ByteLength())
42477:         return ErrorInvalidOperation("BufferSubData: not enough data - operation requires %d bytes, but buffer only has %d bytes",
43009:                                      byteOffset, wb->byteLength, boundBuffer->ByteLength());
32195: 
32195:     MakeContextCurrent();
32195: 
43009:     boundBuffer->CopySubDataIfElementArray(byteOffset, wb->byteLength, wb->data);
43009: 
43009:     gl->fBufferSubData(target, byteOffset, wb->byteLength, wb->data);
37417: 
37417:     return NS_OK;
37417: }
37417: 
37417: NS_IMETHODIMP
43009: WebGLContext::BufferSubData_array(WebGLenum target, WebGLsizei byteOffset, js::TypedArray *wa)
37417: {
37417:     WebGLBuffer *boundBuffer = NULL;
37417: 
37417:     if (target == LOCAL_GL_ARRAY_BUFFER) {
37417:         boundBuffer = mBoundArrayBuffer;
37417:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
37417:         boundBuffer = mBoundElementArrayBuffer;
34453:     } else {
47813:         return ErrorInvalidEnumInfo("bufferSubData: target", target);
34453:     }
37417: 
42477:     if (!boundBuffer)
42477:         return ErrorInvalidOperation("BufferData: no buffer bound!");
37417: 
47204:     CheckedUint32 checked_neededByteLength = CheckedUint32(byteOffset) + wa->byteLength;
47204:     if (!checked_neededByteLength.valid())
47204:         return ErrorInvalidOperation("bufferSubData: integer overflow computing the needed byte length");
47204: 
47204:     if (checked_neededByteLength.value() > boundBuffer->ByteLength())
42477:         return ErrorInvalidOperation("BufferSubData: not enough data -- operation requires %d bytes, but buffer only has %d bytes",
43009:                                      byteOffset, wa->byteLength, boundBuffer->ByteLength());
34453: 
34453:     MakeContextCurrent();
34453: 
43009:     boundBuffer->CopySubDataIfElementArray(byteOffset, wa->byteLength, wa->data);
43009: 
43009:     gl->fBufferSubData(target, byteOffset, wa->byteLength, wa->data);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::CheckFramebufferStatus(WebGLenum target, WebGLenum *retval)
32195: {
32195:     MakeContextCurrent();
47910:     if (target != LOCAL_GL_FRAMEBUFFER)
47910:         return ErrorInvalidEnum("CheckFramebufferStatus: target must be FRAMEBUFFER");
47910: 
32195:     *retval = gl->fCheckFramebufferStatus(target);
32195:     return NS_OK;
32195: }
32195: 
34453: NS_IMETHODIMP
34453: WebGLContext::Clear(PRUint32 mask)
34453: {
34453:     MakeContextCurrent();
34453:     gl->fClear(mask);
34453:     Invalidate();
34453: 
34453:     return NS_OK;
34453: }
32195: 
47205: GL_SAME_METHOD_4(ClearColor, ClearColor, WebGLfloat, WebGLfloat, WebGLfloat, WebGLfloat)
32195: 
47205: GL_SAME_METHOD_1(ClearDepth, ClearDepth, WebGLfloat)
32195: 
47205: GL_SAME_METHOD_1(ClearStencil, ClearStencil, WebGLint)
32195: 
42916: GL_SAME_METHOD_4(ColorMask, ColorMask, WebGLboolean, WebGLboolean, WebGLboolean, WebGLboolean)
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::CopyTexImage2D(WebGLenum target,
42916:                              WebGLint level,
42916:                              WebGLenum internalformat,
42916:                              WebGLint x,
42916:                              WebGLint y,
42916:                              WebGLsizei width,
42916:                              WebGLsizei height,
42916:                              WebGLint border)
32195: {
32195:     switch (target) {
32195:         case LOCAL_GL_TEXTURE_2D:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
32195:             break;
32195:         default:
47813:             return ErrorInvalidEnumInfo("copyTexImage2D: target", target);
32195:     }
32195: 
32195:     switch (internalformat) {
32195:         case LOCAL_GL_RGB:
32195:         case LOCAL_GL_RGBA:
32195:         case LOCAL_GL_ALPHA:
32195:         case LOCAL_GL_LUMINANCE:
32195:         case LOCAL_GL_LUMINANCE_ALPHA:
32195:             break;
32195:         default:
47813:             return ErrorInvalidEnumInfo("CopyTexImage2D: internal format", internalformat);
32195:     }
32195: 
32195:     if (border != 0) {
42477:         return ErrorInvalidValue("CopyTexImage2D: border != 0");
32195:     }
32195: 
42477:     if (!CanvasUtils::CheckSaneSubrectSize(x,y,width, height, mWidth, mHeight))
42477:         return ErrorInvalidOperation("CopyTexImage2D: copied rectangle out of bounds");
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     gl->fCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::CopyTexSubImage2D(WebGLenum target,
42916:                                 WebGLint level,
42916:                                 WebGLint xoffset,
42916:                                 WebGLint yoffset,
42916:                                 WebGLint x,
42916:                                 WebGLint y,
42916:                                 WebGLsizei width,
42916:                                 WebGLsizei height)
32195: {
32195:     switch (target) {
32195:         case LOCAL_GL_TEXTURE_2D:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
32195:             break;
32195:         default:
47813:             return ErrorInvalidEnumInfo("CopyTexSubImage2D: target", target);
32195:     }
32195: 
42477:     if (!CanvasUtils::CheckSaneSubrectSize(x,y,width, height, mWidth, mHeight))
42477:         return ErrorInvalidOperation("CopyTexSubImage2D: copied rectangle out of bounds");
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     gl->fCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::CreateProgram(nsIWebGLProgram **retval)
32195: {
32195:     MakeContextCurrent();
32195: 
42916:     WebGLuint name = gl->fCreateProgram();
32195: 
43099:     WebGLProgram *prog = new WebGLProgram(this, name);
32195:     NS_ADDREF(*retval = prog);
32195:     mMapPrograms.Put(name, prog);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::CreateShader(WebGLenum type, nsIWebGLShader **retval)
32195: {
43098:     if (type != LOCAL_GL_VERTEX_SHADER &&
43098:         type != LOCAL_GL_FRAGMENT_SHADER)
43098:     {
47813:         return ErrorInvalidEnumInfo("createShader: type", type);
43098:     }
43098: 
32195:     MakeContextCurrent();
32195: 
42916:     WebGLuint name = gl->fCreateShader(type);
32195: 
43099:     WebGLShader *shader = new WebGLShader(this, name, type);
32195:     NS_ADDREF(*retval = shader);
32195:     mMapShaders.Put(name, shader);
32195: 
32195:     return NS_OK;
32195: }
32195: 
47205: NS_IMETHODIMP
47205: WebGLContext::CullFace(WebGLenum face)
47205: {
47205:     if (!ValidateFaceEnum(face, "cullFace"))
47205:         return NS_OK;
47205: 
47205:     MakeContextCurrent();
47205:     gl->fCullFace(face);
47205:     return NS_OK;
47205: }
32195: 
32195: NS_IMETHODIMP
42472: WebGLContext::DeleteBuffer(nsIWebGLBuffer *bobj)
32195: {
42916:     WebGLuint bufname;
42472:     WebGLBuffer *buf;
42472:     PRBool isNull, isDeleted;
47811:     if (!GetConcreteObjectAndGLName("deleteBuffer", bobj, &buf, &bufname, &isNull, &isDeleted))
47811:         return NS_OK;
42477: 
42477:     if (isNull || isDeleted)
32195:         return NS_OK;
32195: 
32195:     MakeContextCurrent();
32195: 
42472:     gl->fDeleteBuffers(1, &bufname);
42472:     buf->Delete();
42472:     mMapBuffers.Remove(bufname);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42472: WebGLContext::DeleteFramebuffer(nsIWebGLFramebuffer *fbobj)
32195: {
42916:     WebGLuint fbufname;
42472:     WebGLFramebuffer *fbuf;
42472:     PRBool isNull, isDeleted;
47811:     if (!GetConcreteObjectAndGLName("deleteFramebuffer", fbobj, &fbuf, &fbufname, &isNull, &isDeleted))
47811:         return NS_OK;
42477: 
42477:     if (isNull || isDeleted)
32195:         return NS_OK;
32195: 
32195:     MakeContextCurrent();
32195: 
42472:     gl->fDeleteFramebuffers(1, &fbufname);
42472:     fbuf->Delete();
42472:     mMapFramebuffers.Remove(fbufname);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42472: WebGLContext::DeleteRenderbuffer(nsIWebGLRenderbuffer *rbobj)
32195: {
42916:     WebGLuint rbufname;
42472:     WebGLRenderbuffer *rbuf;
42472:     PRBool isNull, isDeleted;
47811:     if (!GetConcreteObjectAndGLName("deleteRenderbuffer", rbobj, &rbuf, &rbufname, &isNull, &isDeleted))
47811:         return NS_OK;
42477: 
42477:     if (isNull || isDeleted)
32195:         return NS_OK;
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     // XXX we need to track renderbuffer attachments; from glDeleteRenderbuffers man page:
32195: 
32195:     /*
32195:             If a renderbuffer object that is currently bound is deleted, the binding reverts
32195:             to 0 (the absence of any renderbuffer object). Additionally, special care
32195:             must be taken when deleting a renderbuffer object if the image of the renderbuffer
32195:             is attached to a framebuffer object. In this case, if the deleted renderbuffer object is
32195:             attached to the currently bound framebuffer object, it is 
32195:             automatically detached.  However, attachments to any other framebuffer objects are the
32195:             responsibility of the application.
32195:     */
32195: 
42472:     gl->fDeleteRenderbuffers(1, &rbufname);
42472:     rbuf->Delete();
42472:     mMapRenderbuffers.Remove(rbufname);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42472: WebGLContext::DeleteTexture(nsIWebGLTexture *tobj)
32195: {
42916:     WebGLuint texname;
42472:     WebGLTexture *tex;
42472:     PRBool isNull, isDeleted;
47811:     if (!GetConcreteObjectAndGLName("deleteTexture", tobj, &tex, &texname, &isNull, &isDeleted))
47811:         return NS_OK;
42477: 
42477:     if (isNull || isDeleted)
32195:         return NS_OK;
32195: 
32195:     MakeContextCurrent();
32195: 
42472:     gl->fDeleteTextures(1, &texname);
42472:     tex->Delete();
42472:     mMapTextures.Remove(texname);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42472: WebGLContext::DeleteProgram(nsIWebGLProgram *pobj)
32195: {
42916:     WebGLuint progname;
42472:     WebGLProgram *prog;
42472:     PRBool isNull, isDeleted;
47811:     if (!GetConcreteObjectAndGLName("deleteProgram", pobj, &prog, &progname, &isNull, &isDeleted))
47811:         return NS_OK;
42477: 
42477:     if (isNull || isDeleted)
32195:         return NS_OK;
32195: 
32195:     MakeContextCurrent();
32195: 
42472:     gl->fDeleteProgram(progname);
42472:     prog->Delete();
42472:     mMapPrograms.Remove(progname);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42472: WebGLContext::DeleteShader(nsIWebGLShader *sobj)
32195: {
42916:     WebGLuint shadername;
42472:     WebGLShader *shader;
42472:     PRBool isNull, isDeleted;
47811:     if (!GetConcreteObjectAndGLName("deleteShader", sobj, &shader, &shadername, &isNull, &isDeleted))
47811:         return NS_OK;
42477: 
42477:     if (isNull || isDeleted)
32195:         return NS_OK;
32195: 
32195:     MakeContextCurrent();
32195: 
42472:     gl->fDeleteShader(shadername);
42472:     shader->Delete();
42472:     mMapShaders.Remove(shadername);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42471: WebGLContext::DetachShader(nsIWebGLProgram *pobj, nsIWebGLShader *shobj)
32195: {
43098:     WebGLuint progname, shadername;
43098:     WebGLProgram *program;
43098:     WebGLShader *shader;
47811:     if (!GetConcreteObjectAndGLName("detachShader: program", pobj, &program, &progname) ||
47811:         !GetConcreteObjectAndGLName("detachShader: shader", shobj, &shader, &shadername))
47811:         return NS_OK;
32195: 
43098:     if (!program->DetachShader(shader))
43098:         return ErrorInvalidOperation("DetachShader: shader is not attached");
43098: 
32195:     MakeContextCurrent();
32195: 
43098:     gl->fDetachShader(progname, shadername);
32195: 
32195:     return NS_OK;
32195: }
32195: 
46442: NS_IMETHODIMP
46442: WebGLContext::DepthFunc(WebGLenum func)
46442: {
46443:     if (!ValidateComparisonEnum(func, "depthFunc"))
46443:         return NS_OK;
46442: 
46442:     MakeContextCurrent();
46442:     gl->fDepthFunc(func);
46442:     return NS_OK;
46442: }
42916: 
42916: GL_SAME_METHOD_1(DepthMask, DepthMask, WebGLboolean)
32195: 
47205: GL_SAME_METHOD_2(DepthRange, DepthRange, WebGLfloat, WebGLfloat)
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::DisableVertexAttribArray(WebGLuint index)
32195: {
32195:     if (index > mAttribBuffers.Length())
42477:         return ErrorInvalidValue("DisableVertexAttribArray: index out of range");
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     gl->fDisableVertexAttribArray(index);
32195:     mAttribBuffers[index].enabled = PR_FALSE;
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
43009: WebGLContext::DrawArrays(GLenum mode, WebGLint first, WebGLsizei count)
32195: {
47813:     if (!ValidateDrawModeEnum(mode, "drawArrays: mode"))
47813:         return NS_OK;
32195: 
43333:     if (first < 0 || count < 0)
43333:         return ErrorInvalidValue("DrawArrays: negative first or count");
43333: 
43098:     // If there is no current program, this is silently ignored.
43098:     // Any checks below this depend on a program being available.
43098:     if (!mCurrentProgram)
43098:         return NS_OK;
43098: 
47204:     CheckedInt32 checked_firstPlusCount = CheckedInt32(first) + count;
47204: 
47204:     if (!checked_firstPlusCount.valid())
47204:         return ErrorInvalidOperation("drawArrays: overflow in first+count");
47204: 
47204:     if (!ValidateBuffers(checked_firstPlusCount.value()))
47809:         return ErrorInvalidOperation("DrawArrays: bound vertex attribute buffers do not have sufficient size for given first and count");
47809: 
47809:     // If count is 0, there's nothing to do.
47809:     if (count == 0)
47809:         return NS_OK;
32195: 
32195:     MakeContextCurrent();
32195: 
43009:     gl->fDrawArrays(mode, first, count);
32195: 
32195:     Invalidate();
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
43333: WebGLContext::DrawElements(WebGLenum mode, WebGLsizei count, WebGLenum type, WebGLint byteOffset)
32195: {
47813:     if (!ValidateDrawModeEnum(mode, "drawElements: mode"))
47813:         return NS_OK;
32195: 
43333:     if (count < 0 || byteOffset < 0)
43333:         return ErrorInvalidValue("DrawElements: negative count or offset");
43333: 
47204:     CheckedUint32 checked_byteCount;
47204: 
43333:     if (type == LOCAL_GL_UNSIGNED_SHORT) {
47204:         checked_byteCount = 2 * CheckedUint32(count);
43009:         if (byteOffset % 2 != 0)
43009:             return ErrorInvalidValue("DrawElements: invalid byteOffset for UNSIGNED_SHORT (must be a multiple of 2)");
43333:     } else if (type == LOCAL_GL_UNSIGNED_BYTE) {
47204:         checked_byteCount = count;
43333:     } else {
42477:         return ErrorInvalidEnum("DrawElements: type must be UNSIGNED_SHORT or UNSIGNED_BYTE");
32195:     }
32195: 
47204:     if (!checked_byteCount.valid())
47204:         return ErrorInvalidValue("DrawElements: overflow in byteCount");
47204: 
43098:     // If there is no current program, this is silently ignored.
43098:     // Any checks below this depend on a program being available.
43098:     if (!mCurrentProgram)
43098:         return NS_OK;
43098: 
43333:     if (!mBoundElementArrayBuffer)
43333:         return ErrorInvalidOperation("DrawElements: must have element array buffer binding");
43333: 
47204:     CheckedUint32 checked_neededByteCount = checked_byteCount + byteOffset;
47204: 
47204:     if (!checked_neededByteCount.valid())
43333:         return ErrorInvalidOperation("DrawElements: overflow in byteOffset+byteCount");
43333: 
47204:     if (checked_neededByteCount.value() > mBoundElementArrayBuffer->ByteLength())
43333:         return ErrorInvalidOperation("DrawElements: bound element array buffer is too small for given count and offset");
43333: 
43009:     WebGLuint maxIndex = 0;
43333:     if (type == LOCAL_GL_UNSIGNED_SHORT) {
43009:         maxIndex = mBoundElementArrayBuffer->FindMaximum<GLushort>(count, byteOffset);
43333:     } else if (type == LOCAL_GL_UNSIGNED_BYTE) {
43009:         maxIndex = mBoundElementArrayBuffer->FindMaximum<GLubyte>(count, byteOffset);
43333:     }
43009: 
47204:     // maxIndex+1 because ValidateBuffers expects the number of elements needed.
47204:     // it is very important here to check tha maxIndex+1 doesn't overflow, otherwise the buffer validation is bypassed !!!
47204:     // maxIndex is a WebGLuint, ValidateBuffers takes a PRUint32, we validate maxIndex+1 as a PRUint32.
47204:     CheckedUint32 checked_neededCount = CheckedUint32(maxIndex) + 1;
47204:     if (!checked_neededCount.valid())
47204:         return ErrorInvalidOperation("drawElements: overflow in maxIndex+1");
47204:     if (!ValidateBuffers(checked_neededCount.value())) {
43009:         return ErrorInvalidOperation("DrawElements: bound vertex attribute buffers do not have sufficient "
47809:                                      "size for given indices from the bound element array");
43009:     }
43009: 
47809:     // If count is 0, there's nothing to do.
47809:     if (count == 0)
47809:         return NS_OK;
47809: 
32195:     MakeContextCurrent();
32195: 
43009:     gl->fDrawElements(mode, count, type, (GLvoid*) (byteOffset));
32195: 
32195:     Invalidate();
32195: 
32195:     return NS_OK;
32195: }
32195: 
43317: NS_IMETHODIMP WebGLContext::Enable(WebGLenum cap)
43317: {
46443:     if (!ValidateCapabilityEnum(cap, "enable"))
46443:         return NS_OK;
43317: 
43317:     MakeContextCurrent();
43317:     gl->fEnable(cap);
43317:     return NS_OK;
43317: }
43317: 
43317: NS_IMETHODIMP WebGLContext::Disable(WebGLenum cap)
43317: {
46443:     if (!ValidateCapabilityEnum(cap, "disable"))
46443:         return NS_OK;
43317: 
43317:     MakeContextCurrent();
43317:     gl->fDisable(cap);
43317:     return NS_OK;
43317: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::EnableVertexAttribArray(WebGLuint index)
32195: {
32195:     if (index > mAttribBuffers.Length())
42477:         return ErrorInvalidValue("EnableVertexAttribArray: index out of range");
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     gl->fEnableVertexAttribArray(index);
32195:     mAttribBuffers[index].enabled = PR_TRUE;
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: // XXX need to track this -- see glDeleteRenderbuffer above and man page for DeleteRenderbuffers
32195: NS_IMETHODIMP
42916: WebGLContext::FramebufferRenderbuffer(WebGLenum target, WebGLenum attachment, WebGLenum rbtarget, nsIWebGLRenderbuffer *rbobj)
32195: {
42916:     WebGLuint renderbuffername;
42472:     PRBool isNull;
42473:     WebGLRenderbuffer *wrb;
42473: 
47811:     if (!GetConcreteObjectAndGLName("framebufferRenderbuffer: renderbuffer", rbobj, &wrb, &renderbuffername, &isNull))
47811:         return NS_OK;
32195: 
32195:     if (target != LOCAL_GL_FRAMEBUFFER)
47813:         return ErrorInvalidEnumInfo("framebufferRenderbuffer: target", target);
35494: 
42473:     if ((attachment < LOCAL_GL_COLOR_ATTACHMENT0 ||
42473:          attachment >= LOCAL_GL_COLOR_ATTACHMENT0 + mFramebufferColorAttachments.Length()) &&
32195:         attachment != LOCAL_GL_DEPTH_ATTACHMENT &&
32195:         attachment != LOCAL_GL_STENCIL_ATTACHMENT)
42473:     {
47813:         return ErrorInvalidEnumInfo("framebufferRenderbuffer: attachment", attachment);
42473:     }
32195: 
32195:     if (rbtarget != LOCAL_GL_RENDERBUFFER)
47813:         return ErrorInvalidEnumInfo("framebufferRenderbuffer: renderbuffer target:", rbtarget);
32195: 
47910:     if (!mBoundFramebuffer)
47910:         return ErrorInvalidOperation("FramebufferRenderbuffer: cannot modify framebuffer 0");
47910: 
42473:     // dimensions are kept for readPixels primarily, function only uses COLOR_ATTACHMENT0
47910:     if (attachment == LOCAL_GL_COLOR_ATTACHMENT0)
42473:         mBoundFramebuffer->setDimensions(wrb);
42473: 
32195:     MakeContextCurrent();
32195: 
42472:     gl->fFramebufferRenderbuffer(target, attachment, rbtarget, renderbuffername);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::FramebufferTexture2D(WebGLenum target,
42916:                                    WebGLenum attachment,
42916:                                    WebGLenum textarget,
42472:                                    nsIWebGLTexture *tobj,
42916:                                    WebGLint level)
32195: {
42916:     WebGLuint texturename;
42472:     PRBool isNull;
42473:     WebGLTexture *wtex;
42473: 
47811:     if (!GetConcreteObjectAndGLName("framebufferTexture2D: texture", tobj, &wtex, &texturename, &isNull))
47811:         return NS_OK;
32195: 
32195:     if (target != LOCAL_GL_FRAMEBUFFER)
47813:         return ErrorInvalidEnumInfo("framebufferTexture2D: target", target);
32195: 
42473:     if ((attachment < LOCAL_GL_COLOR_ATTACHMENT0 ||
42473:          attachment >= LOCAL_GL_COLOR_ATTACHMENT0 + mFramebufferColorAttachments.Length()) &&
32195:         attachment != LOCAL_GL_DEPTH_ATTACHMENT &&
32195:         attachment != LOCAL_GL_STENCIL_ATTACHMENT)
47813:         return ErrorInvalidEnumInfo("framebufferTexture2D: attachment", attachment);
32195: 
32195:     if (textarget != LOCAL_GL_TEXTURE_2D &&
32195:         (textarget < LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X ||
32195:          textarget > LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z))
47813:         return ErrorInvalidEnumInfo("framebufferTexture2D: invalid texture target", textarget);
32195: 
32195:     if (level != 0)
42477:         return ErrorInvalidValue("FramebufferTexture2D: level must be 0");
32195: 
47910:     if (!mBoundFramebuffer)
47910:         return ErrorInvalidOperation("FramebufferTexture2D: cannot modify framebuffer 0");
47910: 
42473:     // dimensions are kept for readPixels primarily, function only uses COLOR_ATTACHMENT0
47910:     if (attachment == LOCAL_GL_COLOR_ATTACHMENT0)
42473:         mBoundFramebuffer->setDimensions(wtex);
42473: 
35494:     // XXXXX we need to store/reference this attachment!
35494: 
32195:     MakeContextCurrent();
32195: 
42472:     gl->fFramebufferTexture2D(target, attachment, textarget, texturename, level);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: GL_SAME_METHOD_0(Flush, Flush)
32195: 
32195: GL_SAME_METHOD_0(Finish, Finish)
32195: 
46442: NS_IMETHODIMP
46442: WebGLContext::FrontFace(WebGLenum mode)
46442: {
46442:     switch (mode) {
46442:         case LOCAL_GL_CW:
46442:         case LOCAL_GL_CCW:
46442:             break;
46442:         default:
47813:             return ErrorInvalidEnumInfo("frontFace: mode", mode);
46442:     }
46442: 
46442:     MakeContextCurrent();
46442:     gl->fFrontFace(mode);
46442:     return NS_OK;
46442: }
32195: 
32195: // returns an object: { size: ..., type: ..., name: ... }
32195: NS_IMETHODIMP
42471: WebGLContext::GetActiveAttrib(nsIWebGLProgram *pobj, PRUint32 index, nsIWebGLActiveInfo **retval)
32195: {
42916:     WebGLuint progname;
47811:     if (!GetGLName<WebGLProgram>("getActiveAttrib: program", pobj, &progname))
47811:         return NS_OK;
42471: 
32195:     NativeJSContext js;
32195:     if (NS_FAILED(js.error))
32195:         return js.error;
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     GLint len = 0;
42472:     gl->fGetProgramiv(progname, LOCAL_GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, &len);
43333:     if (len == 0) {
43333:         *retval = nsnull;
43333:         return NS_OK;
43333:     }
32195: 
43474:     nsAutoArrayPtr<char> name(new char[len]);
32195:     PRInt32 attrsize = 0;
32195:     PRUint32 attrtype = 0;
32195: 
43474:     gl->fGetActiveAttrib(progname, index, len, &len, (GLint*) &attrsize, (WebGLuint*) &attrtype, name);
43333:     if (attrsize == 0 || attrtype == 0) {
43333:         *retval = nsnull;
43333:         return NS_OK;
43333:     }
32195: 
32195:     JSObjectHelper retobj(&js);
32195:     retobj.DefineProperty("size", attrsize);
32195:     retobj.DefineProperty("type", attrtype);
32195:     retobj.DefineProperty("name", name, len);
32195: 
32195:     js.SetRetVal(retobj);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
46442: WebGLContext::GenerateMipmap(WebGLenum target)
46442: {
46443:     if (!ValidateTextureTargetEnum(target, "generateMipmap"))
46443:         return NS_OK;
46442: 
46442:     MakeContextCurrent();
46442:     gl->fGenerateMipmap(target);
46442:     return NS_OK;
46442: }
46442: 
46442: NS_IMETHODIMP
42471: WebGLContext::GetActiveUniform(nsIWebGLProgram *pobj, PRUint32 index, nsIWebGLActiveInfo **retval)
32195: {
42916:     WebGLuint progname;
47811:     if (!GetGLName<WebGLProgram>("getActiveUniform: program", pobj, &progname))
47811:         return NS_OK;
42471: 
32195:     NativeJSContext js;
32195:     if (NS_FAILED(js.error))
32195:         return js.error;
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     GLint len = 0;
42472:     gl->fGetProgramiv(progname, LOCAL_GL_ACTIVE_UNIFORM_MAX_LENGTH, &len);
43474:     if (len == 0) {
43474:         *retval = nsnull;
43474:         return NS_OK;
43474:     }
43474: 
47814:     nsAutoArrayPtr<char> name(new char[len + 3]); // +3 because we might have to append "[0]", see below
47814: 
32195:     PRInt32 attrsize = 0;
32195:     PRUint32 attrtype = 0;
32195: 
43474:     gl->fGetActiveUniform(progname, index, len, &len, (GLint*) &attrsize, (WebGLenum*) &attrtype, name);
43474:     if (len == 0 || attrsize == 0 || attrtype == 0) {
43474:         *retval = nsnull;
43474:         return NS_OK;
43474:     }
32195: 
47814:     // OpenGL ES 2.0 specifies that if foo is a uniform array, GetActiveUniform returns its name as "foo[0]".
47814:     // See section 2.10 page 35 in the OpenGL ES 2.0.24 specification:
47814:     //
47814:     // > If the active uniform is an array, the uniform name returned in name will always
47814:     // > be the name of the uniform array appended with "[0]".
47814:     //
47814:     // There is no such requirement in the OpenGL (non-ES) spec and indeed we have OpenGL implementations returning
47814:     // "foo" instead of "foo[0]". So, when implementing WebGL on top of desktop OpenGL, we must check if the
47814:     // returned name ends in [0], and if it doesn't, append that.
47814:     //
47814:     // In principle we don't need to do that on OpenGL ES, but this is such a tricky difference between the ES and non-ES
47814:     // specs that it seems probable that some ES implementers will overlook it. Since the work-around is quite cheap,
47814:     // we do it unconditionally.
47814:     if (attrsize > 1 && name[len-1] != ']') {
47814:         name[len++] = '[';
47814:         name[len++] = '0';
47814:         name[len++] = ']';
47814:     }
47814: 
32195:     JSObjectHelper retobj(&js);
32195:     retobj.DefineProperty("size", attrsize);
32195:     retobj.DefineProperty("type", attrtype);
32195:     retobj.DefineProperty("name", name, len);
32195: 
32195:     js.SetRetVal(retobj.Object());
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
43637: WebGLContext::GetAttachedShaders(nsIWebGLProgram *pobj, nsIVariant **retval)
32195: {
43637:     WebGLProgram *prog;
47811:     if (!GetConcreteObject("getAttachedShaders", pobj, &prog))
47811:         return NS_OK;
43637: 
43637:     nsCOMPtr<nsIWritableVariant> wrval = do_CreateInstance("@mozilla.org/variant;1");
43637:     NS_ENSURE_TRUE(wrval, NS_ERROR_FAILURE);
32195: 
32195:     MakeContextCurrent();
32195: 
43637:     if (prog->AttachedShaders().Length() == 0) {
43637:         wrval->SetAsEmptyArray();
43637:     }
43637:     else {
43637:         wrval->SetAsArray(nsIDataType::VTYPE_INTERFACE,
43637:                         &NS_GET_IID(nsIWebGLShader),
43637:                         prog->AttachedShaders().Length(),
43637:                         const_cast<void*>( // @#$% SetAsArray doesn't accept a const void*
43637:                             static_cast<const void*>(
43637:                                 prog->AttachedShaders().Elements()
43637:                             )
43637:                         )
43637:                         );
43637:     }
43637: 
43637:     *retval = wrval.forget().get();
43637: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42471: WebGLContext::GetAttribLocation(nsIWebGLProgram *pobj,
32195:                                 const nsAString& name,
32195:                                 PRInt32 *retval)
32195: {
42916:     WebGLuint progname;
47811:     if (!GetGLName<WebGLProgram>("getAttribLocation: program", pobj, &progname))
47811:         return NS_OK;
42471: 
32195:     MakeContextCurrent();
42472:     *retval = gl->fGetAttribLocation(progname, NS_LossyConvertUTF16toASCII(name).get());
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
43533: WebGLContext::GetParameter(PRUint32 pname, nsIVariant **retval)
32195: {
43533:     nsCOMPtr<nsIWritableVariant> wrval = do_CreateInstance("@mozilla.org/variant;1");
43533:     NS_ENSURE_TRUE(wrval, NS_ERROR_FAILURE);
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     switch (pname) {
32195:         //
32195:         // String params
32195:         //
32195: 
32195:         case LOCAL_GL_VENDOR:
43534:             wrval->SetAsDOMString(NS_LITERAL_STRING("Mozilla"));
43534:             break;
32195:         case LOCAL_GL_RENDERER:
43534:             wrval->SetAsDOMString(NS_LITERAL_STRING("Mozilla"));
43534:             break;
32195:         case LOCAL_GL_VERSION:
43534:             wrval->SetAsDOMString(NS_LITERAL_STRING("WebGL 1.0"));
43534:             break;
32195:         case LOCAL_GL_SHADING_LANGUAGE_VERSION:
43534:             wrval->SetAsDOMString(NS_LITERAL_STRING("WebGL GLSL ES 1.0"));
32195:             break;
32195: 
32195:         //
32195:         // Single-value params
32195:         //
32195: 
32195: // int
32195:         case LOCAL_GL_CULL_FACE_MODE:
32195:         case LOCAL_GL_FRONT_FACE:
32195:         case LOCAL_GL_ACTIVE_TEXTURE:
32195:         case LOCAL_GL_DEPTH_CLEAR_VALUE:
32195:         case LOCAL_GL_STENCIL_CLEAR_VALUE:
32195:         case LOCAL_GL_STENCIL_FUNC:
32195:         case LOCAL_GL_STENCIL_REF:
32195:         case LOCAL_GL_STENCIL_FAIL:
32195:         case LOCAL_GL_STENCIL_PASS_DEPTH_FAIL:
32195:         case LOCAL_GL_STENCIL_PASS_DEPTH_PASS:
32195:         case LOCAL_GL_STENCIL_BACK_FUNC:
32195:         case LOCAL_GL_STENCIL_BACK_REF:
32195:         case LOCAL_GL_STENCIL_BACK_FAIL:
32195:         case LOCAL_GL_STENCIL_BACK_PASS_DEPTH_FAIL:
32195:         case LOCAL_GL_STENCIL_BACK_PASS_DEPTH_PASS:
32195:         case LOCAL_GL_DEPTH_FUNC:
32195:         case LOCAL_GL_BLEND_SRC_RGB:
32195:         case LOCAL_GL_BLEND_SRC_ALPHA:
32195:         case LOCAL_GL_BLEND_DST_RGB:
32195:         case LOCAL_GL_BLEND_DST_ALPHA:
32195:         case LOCAL_GL_BLEND_EQUATION_RGB:
32195:         case LOCAL_GL_BLEND_EQUATION_ALPHA:
46442:         case LOCAL_GL_UNPACK_ALIGNMENT:
46442:         case LOCAL_GL_PACK_ALIGNMENT:
32195:         case LOCAL_GL_GENERATE_MIPMAP_HINT:
32195:         case LOCAL_GL_SUBPIXEL_BITS:
32195:         case LOCAL_GL_MAX_TEXTURE_SIZE:
32195:         case LOCAL_GL_MAX_CUBE_MAP_TEXTURE_SIZE:
32195:         case LOCAL_GL_SAMPLE_BUFFERS:
32195:         case LOCAL_GL_SAMPLES:
32195:         case LOCAL_GL_MAX_VERTEX_ATTRIBS:
32195:         case LOCAL_GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS:
32195:         case LOCAL_GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS:
32195:         case LOCAL_GL_MAX_TEXTURE_IMAGE_UNITS:
32195:         case LOCAL_GL_MAX_FRAGMENT_UNIFORM_COMPONENTS:
32195:         case LOCAL_GL_MAX_RENDERBUFFER_SIZE:
32195:         case LOCAL_GL_RED_BITS:
32195:         case LOCAL_GL_GREEN_BITS:
32195:         case LOCAL_GL_BLUE_BITS:
32195:         case LOCAL_GL_ALPHA_BITS:
32195:         case LOCAL_GL_DEPTH_BITS:
32195:         case LOCAL_GL_STENCIL_BITS:
46442:         case LOCAL_GL_IMPLEMENTATION_COLOR_READ_TYPE:
46442:         case LOCAL_GL_IMPLEMENTATION_COLOR_READ_FORMAT:
32195:         {
43305:             GLint i = 0;
43305:             gl->fGetIntegerv(pname, &i);
43533:             wrval->SetAsInt32(i);
43305:         }
43305:             break;
43305: 
46442:         case LOCAL_GL_MAX_VARYING_VECTORS:
46442:         {
48309:             if (gl->IsGLES2()) {
46442:                 GLint i = 0;
46442:                 gl->fGetIntegerv(pname, &i);
46442:                 wrval->SetAsInt32(i);
48309:             } else {
46442:                 // since this pname is absent from desktop OpenGL, we have to implement it by hand.
46442:                 // The formula below comes from the public_webgl list, "problematic GetParameter pnames" thread
46442:                 GLint i = 0, j = 0;
46442:                 gl->fGetIntegerv(LOCAL_GL_MAX_VERTEX_OUTPUT_COMPONENTS, &i);
46442:                 gl->fGetIntegerv(LOCAL_GL_MAX_FRAGMENT_INPUT_COMPONENTS, &j);
46442:                 wrval->SetAsInt32(PR_MIN(i,j)/4);
48309:             }
46442:         }
46442:             break;
46442: 
43533:         case LOCAL_GL_NUM_COMPRESSED_TEXTURE_FORMATS:
43533:             wrval->SetAsInt32(0);
43533:             break;
46442:         case LOCAL_GL_COMPRESSED_TEXTURE_FORMATS:
46442:             wrval->SetAsVoid(); // the spec says we must return null
46442:             break;
43533: 
43305: // unsigned int. here we may have to return very large values like 2^32-1 that can't be represented as
43533: // javascript integer values. We just return them as doubles and javascript doesn't care.
43305:         case LOCAL_GL_STENCIL_BACK_VALUE_MASK:
43305:         case LOCAL_GL_STENCIL_BACK_WRITEMASK:
43305:         case LOCAL_GL_STENCIL_VALUE_MASK:
43305:         case LOCAL_GL_STENCIL_WRITEMASK:
43305:         {
43305:             GLint i = 0; // the GL api (glGetIntegerv) only does signed ints
43305:             gl->fGetIntegerv(pname, &i);
43305:             GLuint i_unsigned(i); // this is where -1 becomes 2^32-1
43533:             double i_double(i_unsigned); // pass as FP value to allow large values such as 2^32-1.
43533:             wrval->SetAsDouble(i_double);
32195:         }
32195:             break;
32195: 
32195: // float
32195:         case LOCAL_GL_LINE_WIDTH:
32195:         case LOCAL_GL_POLYGON_OFFSET_FACTOR:
32195:         case LOCAL_GL_POLYGON_OFFSET_UNITS:
32195:         case LOCAL_GL_SAMPLE_COVERAGE_VALUE:
32195:         {
43533:             GLfloat f = 0.f;
43533:             gl->fGetFloatv(pname, &f);
43533:             wrval->SetAsFloat(f);
32195:         }
32195:             break;
43305: 
32195: // bool
43305:         case LOCAL_GL_BLEND:
43305:         case LOCAL_GL_DEPTH_TEST:
43305:         case LOCAL_GL_STENCIL_TEST:
43305:         case LOCAL_GL_CULL_FACE:
43305:         case LOCAL_GL_DITHER:
43305:         case LOCAL_GL_POLYGON_OFFSET_FILL:
43305:         case LOCAL_GL_SCISSOR_TEST:
32195:         case LOCAL_GL_SAMPLE_COVERAGE_INVERT:
32195:         case LOCAL_GL_DEPTH_WRITEMASK:
32195:         {
43533:             realGLboolean b = 0;
43533:             gl->fGetBooleanv(pname, &b);
43533:             wrval->SetAsBool(PRBool(b));
32195:         }
32195:             break;
32195: 
46442: // bool, WebGL-specific
46442:         case UNPACK_FLIP_Y_WEBGL:
46442:             wrval->SetAsBool(mPixelStoreFlipY);
46442:             break;
46442:         case UNPACK_PREMULTIPLY_ALPHA_WEBGL:
46442:             wrval->SetAsBool(mPixelStorePremultiplyAlpha);
46442:             break;
46442: 
32195:         //
32195:         // Complex values
32195:         //
32195:         case LOCAL_GL_DEPTH_RANGE: // 2 floats
32195:         case LOCAL_GL_ALIASED_POINT_SIZE_RANGE: // 2 floats
32195:         case LOCAL_GL_ALIASED_LINE_WIDTH_RANGE: // 2 floats
32195:         {
43533:             GLfloat fv[2] = { 0 };
43533:             gl->fGetFloatv(pname, fv);
43533:             wrval->SetAsArray(nsIDataType::VTYPE_FLOAT, nsnull,
43533:                               2, static_cast<void*>(fv));
32195:         }
32195:             break;
32195:         
32195:         case LOCAL_GL_COLOR_CLEAR_VALUE: // 4 floats
32195:         case LOCAL_GL_BLEND_COLOR: // 4 floats
32195:         {
43533:             GLfloat fv[4] = { 0 };
43533:             gl->fGetFloatv(pname, fv);
43533:             wrval->SetAsArray(nsIDataType::VTYPE_FLOAT, nsnull,
43533:                               4, static_cast<void*>(fv));
32195:         }
32195:             break;
32195: 
32195:         case LOCAL_GL_MAX_VIEWPORT_DIMS: // 2 ints
32195:         {
43533:             GLint iv[2] = { 0 };
43533:             gl->fGetIntegerv(pname, iv);
43533:             wrval->SetAsArray(nsIDataType::VTYPE_INT32, nsnull,
43533:                               2, static_cast<void*>(iv));
32195:         }
32195:             break;
32195: 
32195:         case LOCAL_GL_SCISSOR_BOX: // 4 ints
32195:         case LOCAL_GL_VIEWPORT: // 4 ints
32195:         {
43533:             GLint iv[2] = { 0 };
43533:             gl->fGetIntegerv(pname, iv);
43533:             wrval->SetAsArray(nsIDataType::VTYPE_INT32, nsnull,
43533:                               4, static_cast<void*>(iv));
32195:         }
32195:             break;
32195: 
43305:         case LOCAL_GL_COLOR_WRITEMASK: // 4 bools
43305:         {
43533:             realGLboolean gl_bv[4] = { 0 };
43533:             gl->fGetBooleanv(pname, gl_bv);
43533:             PRBool pr_bv[4] = { gl_bv[0], gl_bv[1], gl_bv[2], gl_bv[3] };
43533:             wrval->SetAsArray(nsIDataType::VTYPE_BOOL, nsnull,
43533:                               4, static_cast<void*>(pr_bv));
43305:         }
43305:             break;
43305: 
43533:         case LOCAL_GL_ARRAY_BUFFER_BINDING:
43533:             wrval->SetAsISupports(mBoundArrayBuffer);
43305:             break;
43305: 
43533:         case LOCAL_GL_ELEMENT_ARRAY_BUFFER_BINDING:
43533:             wrval->SetAsISupports(mBoundElementArrayBuffer);
43533:             break;
43533: 
43533:         case LOCAL_GL_RENDERBUFFER_BINDING:
43533:             wrval->SetAsISupports(mBoundRenderbuffer);
43533:             break;
43533: 
43533:         case LOCAL_GL_FRAMEBUFFER_BINDING:
43533:             wrval->SetAsISupports(mBoundFramebuffer);
43533:             break;
43533: 
43533:         case LOCAL_GL_CURRENT_PROGRAM:
43533:             wrval->SetAsISupports(mCurrentProgram);
43533:             break;
43533: 
43533:         case LOCAL_GL_TEXTURE_BINDING_2D:
43533:             wrval->SetAsISupports(mBound2DTextures[mActiveTexture]);
43533:             break;
43533: 
43533:         case LOCAL_GL_TEXTURE_BINDING_CUBE_MAP:
43533:             wrval->SetAsISupports(mBoundCubeMapTextures[mActiveTexture]);
43533:             break;
43305: 
32195:         default:
47813:             return ErrorInvalidEnumInfo("getParameter: parameter", pname);
32195:     }
32195: 
43533:     *retval = wrval.forget().get();
43533: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
43851: WebGLContext::GetBufferParameter(WebGLenum target, WebGLenum pname, nsIVariant **retval)
32195: {
43851:     nsCOMPtr<nsIWritableVariant> wrval = do_CreateInstance("@mozilla.org/variant;1");
43851:     NS_ENSURE_TRUE(wrval, NS_ERROR_FAILURE);
32195: 
42477:     if (target != LOCAL_GL_ARRAY_BUFFER && target != LOCAL_GL_ELEMENT_ARRAY_BUFFER)
47813:         return ErrorInvalidEnumInfo("getBufferParameter: target", target);
42477: 
32195:     MakeContextCurrent();
32195: 
32195:     switch (pname) {
32195:         case LOCAL_GL_BUFFER_SIZE:
32195:         case LOCAL_GL_BUFFER_USAGE:
32195:         case LOCAL_GL_BUFFER_ACCESS:
32195:         case LOCAL_GL_BUFFER_MAPPED:
32195:         {
43851:             GLint i = 0;
43851:             gl->fGetBufferParameteriv(target, pname, &i);
43851:             wrval->SetAsInt32(i);
32195:         }
32195:             break;
32195: 
32195:         default:
47813:             return ErrorInvalidEnumInfo("getBufferParameter: parameter", pname);
32195:     }
32195: 
43851:     *retval = wrval.forget().get();
43851: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
43851: WebGLContext::GetFramebufferAttachmentParameter(WebGLenum target, WebGLenum attachment, WebGLenum pname, nsIVariant **retval)
32195: {
43851:     nsCOMPtr<nsIWritableVariant> wrval = do_CreateInstance("@mozilla.org/variant;1");
43851:     NS_ENSURE_TRUE(wrval, NS_ERROR_FAILURE);
32195: 
42477:     if (target != LOCAL_GL_FRAMEBUFFER)
47813:         return ErrorInvalidEnumInfo("getFramebufferAttachmentParameter: target", target);
32195: 
32195:     switch (attachment) {
32195:         case LOCAL_GL_COLOR_ATTACHMENT0:
32195:         case LOCAL_GL_DEPTH_ATTACHMENT:
32195:         case LOCAL_GL_STENCIL_ATTACHMENT:
32195:             break;
32195:         default:
47813:             return ErrorInvalidEnumInfo("GetFramebufferAttachmentParameter: attachment", attachment);
32195:     }
32195: 
47910:     if (!mBoundFramebuffer)
47910:         return ErrorInvalidOperation("GetFramebufferAttachmentParameter: cannot query framebuffer 0");
47910: 
42477:     MakeContextCurrent();
42477: 
47910:     GLint atype = 0;
47910:     gl->fGetFramebufferAttachmentParameteriv(target, attachment, LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE, &atype);
47910: 
47910:     if (atype == LOCAL_GL_RENDERBUFFER) {
32195:         switch (pname) {
32195:             case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:
47910:                 wrval->SetAsInt32(atype);
47910:                 break;
47910: 
47910:             case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: {
47910:                 GLint i = 0;
47910:                 gl->fGetFramebufferAttachmentParameteriv(target, attachment, pname, &i);
47910:                 WebGLRenderbuffer *rb = mMapRenderbuffers.GetWeak(PRUint32(i));
47910:                 NS_ASSERTION(rb, "Expected to find renderbuffer in table, but it's not there?");
47910:                 wrval->SetAsISupports(rb);
47910:             }
47910:                 break;
47910: 
47910:             default:
47910:                 return ErrorInvalidEnum("GetFramebufferAttachmentParameter: invalid parameter");
47910:         }
47910:     } else if (atype == LOCAL_GL_TEXTURE) {
47910:         switch (pname) {
47910:             case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:
47910:                 wrval->SetAsInt32(atype);
47910:                 break;
47910: 
47910:             case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: {
47910:                 GLint i = 0;
47910:                 gl->fGetFramebufferAttachmentParameteriv(target, attachment, pname, &i);
47910:                 WebGLTexture *tex = mMapTextures.GetWeak(PRUint32(i));
47910:                 NS_ASSERTION(tex, "Expected to find texture in table, but it's not there?");
47910:                 wrval->SetAsISupports(tex);
47910:             }
47910:                 break;
47910: 
32195:             case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:
47910:             case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: {
43851:                 GLint i = 0;
43851:                 gl->fGetFramebufferAttachmentParameteriv(target, attachment, pname, &i);
43851:                 wrval->SetAsInt32(i);
32195:             }
32195:                 break;
32195: 
32195:             default:
47910:                 return ErrorInvalidEnum("GetFramebufferAttachmentParameter: invalid parameter");
47910:         }
47910:     } else {
47910:         NS_WARNING("Unknown framebuffer attachment type?");
47910:         return NS_ERROR_FAILURE;
32195:     }
32195: 
43851:     *retval = wrval.forget().get();
43851: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
43851: WebGLContext::GetRenderbufferParameter(WebGLenum target, WebGLenum pname, nsIVariant **retval)
32195: {
43851:     nsCOMPtr<nsIWritableVariant> wrval = do_CreateInstance("@mozilla.org/variant;1");
43851:     NS_ENSURE_TRUE(wrval, NS_ERROR_FAILURE);
32195: 
42477:     if (target != LOCAL_GL_RENDERBUFFER)
47813:         return ErrorInvalidEnumInfo("GetRenderbufferParameter: target", target);
42477: 
32195:     MakeContextCurrent();
32195: 
32195:     switch (pname) {
32195:         case LOCAL_GL_RENDERBUFFER_WIDTH:
32195:         case LOCAL_GL_RENDERBUFFER_HEIGHT:
32195:         case LOCAL_GL_RENDERBUFFER_INTERNAL_FORMAT:
32195:         case LOCAL_GL_RENDERBUFFER_RED_SIZE:
32195:         case LOCAL_GL_RENDERBUFFER_GREEN_SIZE:
32195:         case LOCAL_GL_RENDERBUFFER_BLUE_SIZE:
32195:         case LOCAL_GL_RENDERBUFFER_ALPHA_SIZE:
32195:         case LOCAL_GL_RENDERBUFFER_DEPTH_SIZE:
32195:         case LOCAL_GL_RENDERBUFFER_STENCIL_SIZE:
32195:         {
43851:             GLint i = 0;
43851:             gl->fGetRenderbufferParameteriv(target, pname, &i);
43851:             wrval->SetAsInt32(i);
32195:         }
32195:             break;
32195: 
32195:         default:
47813:             return ErrorInvalidEnumInfo("GetRenderbufferParameter: parameter", pname);
32195:     }
32195: 
43851:     *retval = wrval.forget().get();
43851: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32835: WebGLContext::CreateBuffer(nsIWebGLBuffer **retval)
32195: {
32195:     MakeContextCurrent();
32195: 
42916:     WebGLuint name;
32195:     gl->fGenBuffers(1, &name);
32195: 
43099:     WebGLBuffer *globj = new WebGLBuffer(this, name);
32195:     NS_ADDREF(*retval = globj);
32195:     mMapBuffers.Put(name, globj);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32835: WebGLContext::CreateTexture(nsIWebGLTexture **retval)
32195: {
32195:     MakeContextCurrent();
32195: 
42916:     WebGLuint name;
32195:     gl->fGenTextures(1, &name);
32195: 
43099:     WebGLTexture *globj = new WebGLTexture(this, name);
32195:     NS_ADDREF(*retval = globj);
32195:     mMapTextures.Put(name, globj);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::GetError(WebGLenum *_retval)
32195: {
32195:     MakeContextCurrent();
42477: 
42477:     // Always call glGetError to clear any pending
42477:     // real GL error.
42916:     WebGLenum err = gl->fGetError();
42477: 
42477:     // mSynthesizedGLError has the first error that occurred,
42477:     // whether synthesized or real; if it's not NO_ERROR, use it.
42477:     if (mSynthesizedGLError != LOCAL_GL_NO_ERROR) {
42477:         err = mSynthesizedGLError;
42477:         mSynthesizedGLError = LOCAL_GL_NO_ERROR;
42477:     }
42477: 
42477:     *_retval = err;
42477: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
43851: WebGLContext::GetProgramParameter(nsIWebGLProgram *pobj, PRUint32 pname, nsIVariant **retval)
35013: {
42916:     WebGLuint progname;
47811:     if (!GetGLName<WebGLProgram>("getProgramParameter: program", pobj, &progname))
47811:         return NS_OK;
42471: 
43851:     nsCOMPtr<nsIWritableVariant> wrval = do_CreateInstance("@mozilla.org/variant;1");
43851:     NS_ENSURE_TRUE(wrval, NS_ERROR_FAILURE);
35013: 
35013:     MakeContextCurrent();
35013: 
35013:     switch (pname) {
35013:         case LOCAL_GL_CURRENT_PROGRAM:
35013:         case LOCAL_GL_ATTACHED_SHADERS:
35013:         case LOCAL_GL_INFO_LOG_LENGTH:
35013:         case LOCAL_GL_ACTIVE_UNIFORMS:
35013:         case LOCAL_GL_ACTIVE_UNIFORM_MAX_LENGTH:
35013:         case LOCAL_GL_ACTIVE_ATTRIBUTES:
35013:         case LOCAL_GL_ACTIVE_ATTRIBUTE_MAX_LENGTH:
35013:         {
43851:             GLint i = 0;
43851:             gl->fGetProgramiv(progname, pname, &i);
43851:             wrval->SetAsInt32(i);
35013:         }
35013:             break;
43011:         case LOCAL_GL_DELETE_STATUS:
43011:         case LOCAL_GL_LINK_STATUS:
43011:         case LOCAL_GL_VALIDATE_STATUS:
43011:         {
43851:             GLint i = 0;
43851:             gl->fGetProgramiv(progname, pname, &i);
43851:             wrval->SetAsBool(PRBool(i));
43011:         }
43011:             break;
35013: 
35013:         default:
47813:             return ErrorInvalidEnumInfo("GetProgramParameter: parameter", pname);
35013:     }
35013: 
43851:     *retval = wrval.forget().get();
43851: 
35013:     return NS_OK;
35013: }
35013: 
35013: NS_IMETHODIMP
42471: WebGLContext::GetProgramInfoLog(nsIWebGLProgram *pobj, nsAString& retval)
32195: {
42916:     WebGLuint progname;
47811:     if (!GetGLName<WebGLProgram>("getProgramInfoLog: program", pobj, &progname))
47811:         return NS_OK;
42471: 
32195:     MakeContextCurrent();
32195: 
32195:     PRInt32 k = -1;
42472:     gl->fGetProgramiv(progname, LOCAL_GL_INFO_LOG_LENGTH, (GLint*) &k);
32195:     if (k == -1)
42477:         return NS_ERROR_FAILURE; // XXX GL error? shouldn't happen!
32195: 
32195:     if (k == 0) {
32195:         retval.Truncate();
32195:         return NS_OK;
32195:     }
32195: 
32195:     nsCAutoString log;
32195:     log.SetCapacity(k);
32195: 
42472:     gl->fGetProgramInfoLog(progname, k, (GLint*) &k, (char*) log.BeginWriting());
32195: 
32195:     log.SetLength(k);
32195: 
32195:     CopyASCIItoUTF16(log, retval);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: /* XXX fix */
32195: /* void texParameter (); */
32195: NS_IMETHODIMP
42916: WebGLContext::TexParameterf(WebGLenum target, WebGLenum pname, WebGLfloat param)
32835: {
32835:     NativeJSContext js;
32835:     if (NS_FAILED(js.error))
32835:         return js.error;
32835: 
32835:     if (js.argc != 3)
32835:         return NS_ERROR_DOM_SYNTAX_ERR;
32835: 
32835:     MakeContextCurrent();
32835: 
32835:     gl->fTexParameterf (target, pname, param);
32835: 
32835:     return NS_OK;
32835: }
32835: NS_IMETHODIMP
42916: WebGLContext::TexParameteri(WebGLenum target, WebGLenum pname, WebGLint param)
32835: {
32835:     NativeJSContext js;
32835:     if (NS_FAILED(js.error))
32835:         return js.error;
32835: 
32835:     if (js.argc != 3)
32835:         return NS_ERROR_DOM_SYNTAX_ERR;
32835: 
32835:     MakeContextCurrent();
32835: 
32835:     gl->fTexParameteri (target, pname, param);
32835: 
32835:     return NS_OK;
32835: }
32835: 
32835: #if 0
32835: NS_IMETHODIMP
32195: WebGLContext::TexParameter()
32195: {
32195:     NativeJSContext js;
32195:     if (NS_FAILED(js.error))
32195:         return js.error;
32195: 
32195:     if (js.argc != 3)
32195:         return NS_ERROR_DOM_SYNTAX_ERR;
32195: 
32195:     jsuint targetVal;
32195:     jsuint pnameVal;
32195:     if (!::JS_ValueToECMAUint32(js.ctx, js.argv[0], &targetVal) ||
32195:         !::JS_ValueToECMAUint32(js.ctx, js.argv[1], &pnameVal))
32195:         return NS_ERROR_DOM_SYNTAX_ERR;
32195: 
32195:     if (targetVal != LOCAL_GL_TEXTURE_2D &&
32195:         targetVal != LOCAL_GL_TEXTURE_CUBE_MAP)
32195:     {
32195:         return NS_ERROR_DOM_SYNTAX_ERR;
32195:     }
32195: 
32195:     MakeContextCurrent();
32195:     switch (pnameVal) {
32195:         case LOCAL_GL_TEXTURE_MIN_FILTER: {
32195:             jsuint ival;
32195:             if (!::JS_ValueToECMAUint32(js.ctx, js.argv[2], &ival) ||
32195:                 (ival != LOCAL_GL_NEAREST &&
32195:                  ival != LOCAL_GL_LINEAR &&
32195:                  ival != LOCAL_GL_NEAREST_MIPMAP_NEAREST &&
32195:                  ival != LOCAL_GL_LINEAR_MIPMAP_NEAREST &&
32195:                  ival != LOCAL_GL_NEAREST_MIPMAP_LINEAR &&
32195:                  ival != LOCAL_GL_LINEAR_MIPMAP_LINEAR))
32195:                 return NS_ERROR_DOM_SYNTAX_ERR;
32195:             gl->fTexParameteri (targetVal, pnameVal, ival);
32195:         }
32195:             break;
32195:         case LOCAL_GL_TEXTURE_MAG_FILTER: {
32195:             jsuint ival;
32195:             if (!::JS_ValueToECMAUint32(js.ctx, js.argv[2], &ival) ||
32195:                 (ival != LOCAL_GL_NEAREST &&
32195:                  ival != LOCAL_GL_LINEAR))
32195:                 return NS_ERROR_DOM_SYNTAX_ERR;
32195:             gl->fTexParameteri (targetVal, pnameVal, ival);
32195:         }
32195:             break;
32195:         case LOCAL_GL_TEXTURE_WRAP_S:
32195:         case LOCAL_GL_TEXTURE_WRAP_T: {
32195:             jsuint ival;
32195:             if (!::JS_ValueToECMAUint32(js.ctx, js.argv[2], &ival) ||
32195:                 (ival != LOCAL_GL_CLAMP &&
32195:                  ival != LOCAL_GL_CLAMP_TO_EDGE &&
32195:                  ival != LOCAL_GL_REPEAT))
32195:                 return NS_ERROR_DOM_SYNTAX_ERR;
32195:             gl->fTexParameteri (targetVal, pnameVal, ival);
32195:         }
32195:             break;
32195:         case LOCAL_GL_GENERATE_MIPMAP: {
32195:             jsuint ival;
32195:             if (js.argv[2] == JSVAL_TRUE)
32195:                 ival = 1;
32195:             else if (js.argv[2] == JSVAL_FALSE)
32195:                 ival = 0;
32195:             else if (!::JS_ValueToECMAUint32(js.ctx, js.argv[2], &ival) ||
32195:                      (ival != 0 && ival != 1))
32195:                 return NS_ERROR_DOM_SYNTAX_ERR;
32195:             gl->fTexParameteri (targetVal, pnameVal, ival);
32195:         }
32195:             break;
32195:         case LOCAL_GL_TEXTURE_MAX_ANISOTROPY_EXT: {
32195: #if 0
32195:             if (GLEW_EXT_texture_filter_anisotropic) {
32195:                 jsdouble dval;
32195:                 if (!::JS_ValueToNumber(js.ctx, js.argv[2], &dval))
32195:                     return NS_ERROR_DOM_SYNTAX_ERR;
32195:                 gl->fTexParameterf (targetVal, pnameVal, (float) dval);
32195:             } else {
32195:                 return NS_ERROR_NOT_IMPLEMENTED;
32195:             }
32195: #else
32195:             return NS_ERROR_NOT_IMPLEMENTED;
32195: #endif
32195:         }
32195:             break;
32195:         default:
32195:             return NS_ERROR_DOM_SYNTAX_ERR;
32195:     }
32195: 
32195:     return NS_OK;
32195: }
32835: #endif
32195: 
32835: NS_IMETHODIMP
43851: WebGLContext::GetTexParameter(WebGLenum target, WebGLenum pname, nsIVariant **retval)
32835: {
43851:     nsCOMPtr<nsIWritableVariant> wrval = do_CreateInstance("@mozilla.org/variant;1");
43851:     NS_ENSURE_TRUE(wrval, NS_ERROR_FAILURE);
32835: 
32835:     MakeContextCurrent();
32835: 
46443:     if (!ValidateTextureTargetEnum(target, "getTexParameter: target"))
46443:         return NS_OK;
43851: 
32835:     switch (pname) {
32835:         case LOCAL_GL_TEXTURE_MIN_FILTER:
32835:         case LOCAL_GL_TEXTURE_MAG_FILTER:
32835:         case LOCAL_GL_TEXTURE_WRAP_S:
32835:         case LOCAL_GL_TEXTURE_WRAP_T:
32835:         {
43851:             GLint i = 0;
43011:             gl->fGetTexParameteriv(target, pname, &i);
43851:             wrval->SetAsInt32(i);
32835:         }
32835:             break;
32835: 
32835:         default:
47813:             return ErrorInvalidEnumInfo("getTexParameter: parameter", pname);
32835:     }
32835: 
43851:     *retval = wrval.forget().get();
43851: 
32835:     return NS_OK;
32835: }
32835: 
35013: /* any getUniform(in WebGLProgram program, in WebGLUniformLocation location) raises(DOMException); */
32195: NS_IMETHODIMP
43852: WebGLContext::GetUniform(nsIWebGLProgram *pobj, nsIWebGLUniformLocation *ploc, nsIVariant **retval)
32195: {
42916:     WebGLuint progname;
43010:     WebGLProgram *prog;
47811:     if (!GetConcreteObjectAndGLName("getUniform: program", pobj, &prog, &progname))
47811:         return NS_OK;
42471: 
43010:     WebGLUniformLocation *location;
47811:     if (!GetConcreteObject("getUniform: location", ploc, &location))
47811:         return NS_OK;
43010: 
43010:     if (location->Program() != prog)
43010:         return ErrorInvalidValue("GetUniform: this uniform location corresponds to another program");
43010: 
43331:     if (location->ProgramGeneration() != prog->Generation())
43331:         return ErrorInvalidValue("GetUniform: this uniform location is obsolete since the program has been relinked");
43331: 
43852:     nsCOMPtr<nsIWritableVariant> wrval = do_CreateInstance("@mozilla.org/variant;1");
43852:     NS_ENSURE_TRUE(wrval, NS_ERROR_FAILURE);
32195: 
32195:     MakeContextCurrent();
32195: 
43010:     GLint uniforms = 0;
43474:     GLint uniformNameMaxLength = 0;
43010:     gl->fGetProgramiv(progname, LOCAL_GL_ACTIVE_UNIFORMS, &uniforms);
43474:     gl->fGetProgramiv(progname, LOCAL_GL_ACTIVE_UNIFORM_MAX_LENGTH, &uniformNameMaxLength);
43010: 
43010:     // we now need the type info to switch between fGetUniformfv and fGetUniformiv
43010:     // the only way to get that is to iterate through all active uniforms by index until
43010:     // one matches the given uniform location.
43010:     GLenum uniformType = 0;
43474:     nsAutoArrayPtr<GLchar> uniformName(new GLchar[uniformNameMaxLength]);
47814:     // this buffer has 16 more bytes to be able to store [index] at the end.
47814:     nsAutoArrayPtr<GLchar> uniformNameBracketIndex(new GLchar[uniformNameMaxLength + 16]);
47814: 
43010:     GLint index;
43010:     for (index = 0; index < uniforms; ++index) {
47814:         GLsizei length;
47814:         GLint size;
47814:         gl->fGetActiveUniform(progname, index, uniformNameMaxLength, &length,
47814:                               &size, &uniformType, uniformName);
43010:         if (gl->fGetUniformLocation(progname, uniformName) == location->Location())
43010:             break;
47814: 
47814:         // now we handle the case of array uniforms. In that case, fGetActiveUniform returned as 'size'
47814:         // the biggest index used plus one, so we need to loop over that. The 0 index has already been handled above,
47814:         // so we can start at one. For each index, we construct the string uniformName + "[" + index + "]".
47814:         if (size > 1) {
47814:             bool found_it = false;
47814:             if (uniformName[length - 1] == ']') { // if uniformName ends in [0]
47814:                 // remove the [0] at the end
47814:                 length -= 3;
47814:                 uniformName[length] = 0;
47814:             }
47814:             for (GLint arrayIndex = 1; arrayIndex < size; arrayIndex++) {
47814:                 sprintf(uniformNameBracketIndex.get(), "%s[%d]", uniformName.get(), arrayIndex);
47814:                 if (gl->fGetUniformLocation(progname, uniformNameBracketIndex) == location->Location()) {
47814:                     found_it = true;
47814:                     break;
47814:                 }
47814:             }
47814:             if (found_it) break;
47814:         }
43010:     }
43010: 
43010:     if (index == uniforms)
42477:         return NS_ERROR_FAILURE; // XXX GL error? shouldn't happen.
32195: 
32195:     GLenum baseType;
32195:     GLint unitSize;
43010:     if (!BaseTypeAndSizeFromUniformType(uniformType, &baseType, &unitSize))
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     // this should never happen
32195:     if (unitSize > 16)
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     if (baseType == LOCAL_GL_FLOAT) {
32195:         GLfloat fv[16];
43010:         gl->fGetUniformfv(progname, location->Location(), fv);
43852:         if (unitSize == 1) {
43852:             wrval->SetAsFloat(fv[0]);
43852:         } else {
43852:             wrval->SetAsArray(nsIDataType::VTYPE_FLOAT, nsnull,
43852:                               unitSize, static_cast<void*>(fv));
43852:         }
32195:     } else if (baseType == LOCAL_GL_INT) {
32195:         GLint iv[16];
43010:         gl->fGetUniformiv(progname, location->Location(), iv);
43852:         if (unitSize == 1) {
43852:             wrval->SetAsInt32(iv[0]);
32195:         } else {
43852:             wrval->SetAsArray(nsIDataType::VTYPE_INT32, nsnull,
43852:                               unitSize, static_cast<void*>(iv));
32195:         }
43852:     } else if (baseType == LOCAL_GL_BOOL) {
43852:         GLint iv[16];
43852:         gl->fGetUniformiv(progname, location->Location(), iv);
43852:         if (unitSize == 1) {
43852:             wrval->SetAsBool(PRBool(iv[0]));
43852:         } else {
43852:             PRUint8 uv[16];
43852:             for (int k = 0; k < unitSize; k++)
43852:                 uv[k] = PRUint8(iv[k]);
43852:             wrval->SetAsArray(nsIDataType::VTYPE_UINT8, nsnull,
43852:                               unitSize, static_cast<void*>(uv));
43852:         }
43852:     } else {
43852:         wrval->SetAsVoid();
43852:     }
43852: 
43852:     *retval = wrval.forget().get();
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
43010: WebGLContext::GetUniformLocation(nsIWebGLProgram *pobj, const nsAString& name, nsIWebGLUniformLocation **retval)
32195: {
42916:     WebGLuint progname;
43010:     WebGLProgram *prog;
47811:     if (!GetConcreteObjectAndGLName("getUniformLocation: program", pobj, &prog, &progname))
47811:         return NS_OK;
42471: 
32195:     MakeContextCurrent();
43010: 
43010:     GLint intlocation = gl->fGetUniformLocation(progname, NS_LossyConvertUTF16toASCII(name).get());
43010: 
43331:     nsRefPtr<nsIWebGLUniformLocation> loc = prog->GetUniformLocationObject(intlocation);
43331:     *retval = loc.forget().get();
43010: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::GetVertexAttrib(WebGLuint index, WebGLenum pname)
32195: {
32195:     NativeJSContext js;
32195:     if (NS_FAILED(js.error))
32195:         return js.error;
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     switch (pname) {
32195:         // int
32195:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_SIZE:
32195:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_STRIDE:
32195:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_TYPE:
32195:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
32195:         {
43011:             PRInt32 i = 0;
43011:             gl->fGetVertexAttribiv(index, pname, (GLint*) &i);
43011:             js.SetRetVal(i);
32195:         }
32195:             break;
32195: 
32195:         case LOCAL_GL_CURRENT_VERTEX_ATTRIB:
32195:         {
32195:             GLfloat fv[4] = { 0 };
43011:             gl->fGetVertexAttribfv(index, LOCAL_GL_CURRENT_VERTEX_ATTRIB, fv);
32195:             js.SetRetVal(fv, 4);
32195:         }
32195:             break;
43011:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_ENABLED:
43011:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_NORMALIZED:
43011:         {
43011:             PRInt32 i = 0;
43011:             gl->fGetVertexAttribiv(index, pname, (GLint*) &i);
43011:             js.SetBoolRetVal(PRBool(i));
43011:         }
43011:             break;
32195: 
32195:         // not supported; doesn't make sense to return a pointer unless we have some kind of buffer object abstraction
32195:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_POINTER:
32195:         default:
47813:             return ErrorInvalidEnumInfo("getVertexAttrib: parameter", pname);
32195:     }
32195: 
32195:     return NS_OK;
32195: }
32195: 
32835: /* GLuint getVertexAttribOffset (in GLuint index, in GLenum pname); */
32835: NS_IMETHODIMP
42916: WebGLContext::GetVertexAttribOffset(WebGLuint index, WebGLenum pname, WebGLuint *retval)
32835: {
32835:     return NS_ERROR_NOT_IMPLEMENTED;
32835: }
32835: 
32835: NS_IMETHODIMP
42916: WebGLContext::Hint(WebGLenum target, WebGLenum mode)
32195: {
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::IsBuffer(nsIWebGLBuffer *bobj, WebGLboolean *retval)
32195: {
42472:     PRBool isDeleted;
47811:     *retval = CanGetConcreteObject<WebGLBuffer>("isBuffer", bobj, 0, &isDeleted) && !isDeleted;
42472: 
42471:     return NS_OK;
42471: }
42471: 
42472: NS_IMETHODIMP
42916: WebGLContext::IsFramebuffer(nsIWebGLFramebuffer *fbobj, WebGLboolean *retval)
42472: {
42472:     PRBool isDeleted;
47811:     *retval = CanGetConcreteObject<WebGLFramebuffer>("isFramebuffer", fbobj, 0, &isDeleted) && !isDeleted;
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::IsProgram(nsIWebGLProgram *pobj, WebGLboolean *retval)
32195: {
42472:     PRBool isDeleted;
47811:     *retval = CanGetConcreteObject<WebGLProgram>("isProgram", pobj, 0, &isDeleted) && !isDeleted;
42472: 
42471:     return NS_OK;
42471: }
42471: 
42472: NS_IMETHODIMP
42916: WebGLContext::IsRenderbuffer(nsIWebGLRenderbuffer *rbobj, WebGLboolean *retval)
42472: {
42472:     PRBool isDeleted;
47811:     *retval = CanGetConcreteObject<WebGLRenderbuffer>("isRenderBuffer", rbobj, 0, &isDeleted) && !isDeleted;
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::IsShader(nsIWebGLShader *sobj, WebGLboolean *retval)
32195: {
42472:     PRBool isDeleted;
47811:     *retval = CanGetConcreteObject<WebGLShader>("isShader", sobj, 0, &isDeleted) && !isDeleted;
42472: 
42471:     return NS_OK;
42471: }
42471: 
32195: NS_IMETHODIMP
42916: WebGLContext::IsTexture(nsIWebGLTexture *tobj, WebGLboolean *retval)
32195: {
42472:     PRBool isDeleted;
47811:     *retval = CanGetConcreteObject<WebGLTexture>("isTexture", tobj, 0, &isDeleted) && !isDeleted;
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
43317: WebGLContext::IsEnabled(WebGLenum cap, WebGLboolean *retval)
32195: {
46443:     if (!ValidateCapabilityEnum(cap, "isEnabled")) {
43317:         *retval = 0; // as per the OpenGL ES spec
46443:         return NS_OK;
43317:     }
43317: 
32195:     MakeContextCurrent();
43317:     *retval = gl->fIsEnabled(cap);
32195:     return NS_OK;
32195: }
32195: 
47205: GL_SAME_METHOD_1(LineWidth, LineWidth, WebGLfloat)
32195: 
32195: NS_IMETHODIMP
42471: WebGLContext::LinkProgram(nsIWebGLProgram *pobj)
32195: {
42472:     GLuint progname;
43098:     WebGLProgram *program;
47811:     if (!GetConcreteObjectAndGLName("linkProgram", pobj, &program, &progname))
47811:         return NS_OK;
42471: 
43331:     if (!program->NextGeneration())
43331:         return NS_ERROR_FAILURE;
32195: 
43637:     if (!program->HasBothShaderTypesAttached()) {
43637:         program->SetLinkStatus(PR_FALSE);
43637:         return NS_OK;
43637:     }
43637: 
43637:     MakeContextCurrent();
43637: 
43637:     gl->fLinkProgram(progname);
43637: 
43098:     GLint ok;
43098:     gl->fGetProgramiv(progname, LOCAL_GL_LINK_STATUS, &ok);
43474:     if (ok) {
43474:         program->SetLinkStatus(PR_TRUE);
43474:         program->UpdateInfo(gl);
43474:     } else {
43474:         program->SetLinkStatus(PR_FALSE);
43474:     }
43098: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::PixelStorei(WebGLenum pname, WebGLint param)
32195: {
43639:     switch (pname) {
43639:         case UNPACK_FLIP_Y_WEBGL:
43639:             mPixelStoreFlipY = (param != 0);
43639:             break;
43639:         case UNPACK_PREMULTIPLY_ALPHA_WEBGL:
43639:             mPixelStorePremultiplyAlpha = (param != 0);
43639:             break;
43639:         case LOCAL_GL_PACK_ALIGNMENT:
43639:         case LOCAL_GL_UNPACK_ALIGNMENT:
43639:              if (param != 1 &&
43639:                  param != 2 &&
43639:                  param != 4 &&
43639:                  param != 8)
43639:                  return ErrorInvalidValue("PixelStorei: invalid pack/unpack alignment value");
32195:             MakeContextCurrent();
32195:             gl->fPixelStorei(pname, param);
43639:             break;
43639:         default:
47813:             return ErrorInvalidEnumInfo("PixelStorei: parameter", pname);
43639:     }
32195: 
32195:     return NS_OK;
32195: }
43639: 
32195: 
47205: GL_SAME_METHOD_2(PolygonOffset, PolygonOffset, WebGLfloat, WebGLfloat)
32195: 
32195: NS_IMETHODIMP
43853: WebGLContext::ReadPixels(PRInt32 dummy)
32195: {
43853:     return NS_ERROR_FAILURE;
43853: }
43853: 
43856: nsresult
43853: WebGLContext::ReadPixels_base(WebGLint x, WebGLint y, WebGLsizei width, WebGLsizei height,
43853:                               WebGLenum format, WebGLenum type, void *data, PRUint32 byteLength)
43853: {
43655:     if (HTMLCanvasElement()->IsWriteOnly() && !nsContentUtils::IsCallerTrustedForRead()) {
42477:         LogMessage("ReadPixels: Not allowed");
32195:         return NS_ERROR_DOM_SECURITY_ERR;
32195:     }
32195: 
43853:     if (width < 0 || height < 0)
43853:         return ErrorInvalidValue("ReadPixels: negative size passed");
43853: 
42916:     WebGLsizei boundWidth = mBoundFramebuffer ? mBoundFramebuffer->width() : mWidth;
42916:     WebGLsizei boundHeight = mBoundFramebuffer ? mBoundFramebuffer->height() : mHeight;
32195: 
32195:     PRUint32 size = 0;
32195:     switch (format) {
32195:       case LOCAL_GL_ALPHA:
32195:         size = 1;
32195:         break;
32195:       case LOCAL_GL_RGB:
32195:         size = 3;
32195:         break;
32195:       case LOCAL_GL_RGBA:
32195:         size = 4;
32195:         break;
32195:       default:
47813:         return ErrorInvalidEnumInfo("readPixels: format", format);
32195:     }
42477: 
32195:     switch (type) {
32195: //         case LOCAL_GL_UNSIGNED_SHORT_4_4_4_4:
32195: //         case LOCAL_GL_UNSIGNED_SHORT_5_5_5_1:
32195: //         case LOCAL_GL_UNSIGNED_SHORT_5_6_5:
32195:       case LOCAL_GL_UNSIGNED_BYTE:
32195:         break;
32195:       default:
47813:         return ErrorInvalidEnumInfo("ReadPixels: type", type);
32195:     }
32195: 
42473:     MakeContextCurrent();
42473: 
42849:     PRUint32 packAlignment;
42849:     gl->fGetIntegerv(LOCAL_GL_PACK_ALIGNMENT, (GLint*) &packAlignment);
42849: 
47204:     CheckedUint32 checked_plainRowSize = CheckedUint32(width) * size;
47204: 
47204:     // alignedRowSize = row size rounded up to next multiple of packAlignment
47204:     CheckedUint32 checked_alignedRowSize
47204:         = ((checked_plainRowSize + packAlignment-1) / packAlignment) * packAlignment;
47204: 
47204:     CheckedUint32 checked_neededByteLength
47204:         = (height-1) * checked_alignedRowSize + checked_plainRowSize;
47204: 
47204:     if (!checked_neededByteLength.valid())
47204:         return ErrorInvalidOperation("ReadPixels: integer overflow computing the needed buffer size");
47204: 
47204:     if (checked_neededByteLength.value() > byteLength)
43853:         return ErrorInvalidOperation("ReadPixels: buffer too small");
43853: 
43853:     if (CanvasUtils::CheckSaneSubrectSize(x, y, width, height, boundWidth, boundHeight)) {
43853:         // the easy case: we're not reading out-of-range pixels
43853:         gl->fReadPixels(x, y, width, height, format, type, data);
43853:     } else {
43853:         // the rectangle doesn't fit entirely in the bound buffer. We then have to set to zero the part
43853:         // of the buffer that correspond to out-of-range pixels. We don't want to rely on system OpenGL
43853:         // to do that for us, because passing out of range parameters to a buggy OpenGL implementation
43853:         // could conceivably allow to read memory we shouldn't be allowed to read. So we manually initialize
43853:         // the buffer to zero and compute the parameters to pass to OpenGL. We have to use an intermediate buffer
43853:         // to accomodate the potentially different strides (widths).
43853: 
43853:         // zero the whole destination buffer. Too bad for the part that's going to be overwritten, we're not
43853:         // 100% efficient here, but in practice this is a quite rare case anyway.
43853:         memset(data, 0, byteLength);
43853: 
43853:         if (   x >= boundWidth
43853:             || x+width <= 0
43853:             || y >= boundHeight
43853:             || y+height <= 0)
43853:         {
43853:             // we are completely outside of range, can exit now with buffer filled with zeros
43853:             return NS_OK;
43853:         }
43853: 
43853:         // compute the parameters of the subrect we're actually going to call glReadPixels on
43853:         GLint   subrect_x      = PR_MAX(x, 0);
43853:         GLint   subrect_end_x  = PR_MIN(x+width, boundWidth);
43853:         GLsizei subrect_width  = subrect_end_x - subrect_x;
43853: 
43853:         GLint   subrect_y      = PR_MAX(y, 0);
43853:         GLint   subrect_end_y  = PR_MIN(y+height, boundHeight);
43853:         GLsizei subrect_height = subrect_end_y - subrect_y;
43853: 
47204:         if (subrect_width < 0 || subrect_height < 0 ||
47204:             subrect_width > width || subrect_height)
47204:             return ErrorInvalidOperation("ReadPixels: integer overflow computing clipped rect size");
47204: 
47204:         // now we know that subrect_width is in the [0..width] interval, and same for heights.
47204: 
43853:         // now, same computation as above to find the size of the intermediate buffer to allocate for the subrect
47204:         // no need to check again for integer overflow here, since we already know the sizes aren't greater than before
43853:         PRUint32 subrect_plainRowSize = subrect_width * size;
43853:         PRUint32 subrect_alignedRowSize = (subrect_plainRowSize + packAlignment-1) &
43853:             ~PRUint32(packAlignment-1);
43853:         PRUint32 subrect_byteLength = (subrect_height-1)*subrect_alignedRowSize + subrect_plainRowSize;
43853: 
43853:         // create subrect buffer, call glReadPixels, copy pixels into destination buffer, delete subrect buffer
43853:         GLubyte *subrect_data = new GLubyte[subrect_byteLength];
43853:         gl->fReadPixels(subrect_x, subrect_y, subrect_width, subrect_height, format, type, subrect_data);
47204: 
47204:         // notice that this for loop terminates because we already checked that subrect_height is at most height
43853:         for (GLint y_inside_subrect = 0; y_inside_subrect < subrect_height; ++y_inside_subrect) {
43853:             GLint subrect_x_in_dest_buffer = subrect_x - x;
43853:             GLint subrect_y_in_dest_buffer = subrect_y - y;
43853:             memcpy(static_cast<GLubyte*>(data)
47204:                      + checked_alignedRowSize.value() * (subrect_y_in_dest_buffer + y_inside_subrect)
43853:                      + size * subrect_x_in_dest_buffer, // destination
43853:                    subrect_data + subrect_alignedRowSize * y_inside_subrect, // source
43853:                    subrect_plainRowSize); // size
43853:         }
43853:         delete [] subrect_data;
43853:     }
43853:     return NS_OK;
43853: }
43853: 
43853: NS_IMETHODIMP
43853: WebGLContext::ReadPixels_array(WebGLint x, WebGLint y, WebGLsizei width, WebGLsizei height,
43853:                                WebGLenum format, WebGLenum type, js::TypedArray *pixels)
43853: {
43853:     return ReadPixels_base(x, y, width, height, format, type,
43853:                            pixels ? pixels->data : 0,
43853:                            pixels ? pixels->byteLength : 0);
43853: }
43853: 
43853: NS_IMETHODIMP
43853: WebGLContext::ReadPixels_buf(WebGLint x, WebGLint y, WebGLsizei width, WebGLsizei height,
43853:                              WebGLenum format, WebGLenum type, js::ArrayBuffer *pixels)
43853: {
43853:     return ReadPixels_base(x, y, width, height, format, type,
43853:                            pixels ? pixels->data : 0,
43853:                            pixels ? pixels->byteLength : 0);
43853: }
43853: 
43853: NS_IMETHODIMP
42916: WebGLContext::RenderbufferStorage(WebGLenum target, WebGLenum internalformat, WebGLsizei width, WebGLsizei height)
42473: {
42477:     if (target != LOCAL_GL_RENDERBUFFER)
47813:         return ErrorInvalidEnumInfo("RenderbufferStorage: target", target);
42477: 
42477:     switch (internalformat) {
42477:       case LOCAL_GL_RGBA4:
42477:       // XXX case LOCAL_GL_RGB565:
42477:       case LOCAL_GL_RGB5_A1:
43011:       case LOCAL_GL_DEPTH_COMPONENT:
42477:       case LOCAL_GL_DEPTH_COMPONENT16:
42477:       case LOCAL_GL_STENCIL_INDEX8:
42477:           break;
42477:       default:
47813:           return ErrorInvalidEnumInfo("RenderbufferStorage: internalformat", internalformat);
42477:     }
42477: 
42477:     if (width <= 0 || height <= 0)
42477:         return ErrorInvalidValue("RenderbufferStorage: width and height must be > 0");
42477: 
42473:     if (mBoundRenderbuffer)
42473:         mBoundRenderbuffer->setDimensions(width, height);
42473: 
42473:     MakeContextCurrent();
42473:     gl->fRenderbufferStorage(target, internalformat, width, height);
42473: 
42473:     return NS_OK;
42473: }
32195: 
47205: GL_SAME_METHOD_2(SampleCoverage, SampleCoverage, WebGLfloat, WebGLboolean)
42916: 
46442: NS_IMETHODIMP
46442: WebGLContext::Scissor(WebGLint x, WebGLint y, WebGLsizei width, WebGLsizei height)
46442: {
46442:     if (width < 0 || height < 0)
46442:         return ErrorInvalidValue("Scissor: negative size");
46442: 
46442:     MakeContextCurrent();
46442:     gl->fScissor(x, y, width, height);
46442:     return NS_OK;
46442: }
46442: 
46442: NS_IMETHODIMP
46442: WebGLContext::StencilFunc(WebGLenum func, WebGLint ref, WebGLuint mask)
46442: {
46443:     if (!ValidateComparisonEnum(func, "stencilFunc: func"))
46443:         return NS_OK;
46442: 
46442:     MakeContextCurrent();
46442:     gl->fStencilFunc(func, ref, mask);
46442:     return NS_OK;
46442: }
46442: 
46442: NS_IMETHODIMP
46442: WebGLContext::StencilFuncSeparate(WebGLenum face, WebGLenum func, WebGLint ref, WebGLuint mask)
46442: {
46443:     if (!ValidateFaceEnum(face, "stencilFuncSeparate: face") ||
46443:         !ValidateComparisonEnum(func, "stencilFuncSeparate: func"))
46443:         return NS_OK;
46442: 
46442:     MakeContextCurrent();
46442:     gl->fStencilFuncSeparate(face, func, ref, mask);
46442:     return NS_OK;
46442: }
42916: 
42916: GL_SAME_METHOD_1(StencilMask, StencilMask, WebGLuint)
42916: 
46442: NS_IMETHODIMP
46442: WebGLContext::StencilMaskSeparate(WebGLenum face, WebGLuint mask)
46442: {
46443:     if (!ValidateFaceEnum(face, "stencilMaskSeparate: face"))
46443:         return NS_OK;
46442: 
46442:     MakeContextCurrent();
46442:     gl->fStencilMaskSeparate(face, mask);
46442:     return NS_OK;
46442: }
46442: 
46442: NS_IMETHODIMP
46442: WebGLContext::StencilOp(WebGLenum sfail, WebGLenum dpfail, WebGLenum dppass)
46442: {
46443:     if (!ValidateStencilOpEnum(sfail, "stencilOp: sfail") ||
46443:         !ValidateStencilOpEnum(dpfail, "stencilOp: dpfail") ||
46443:         !ValidateStencilOpEnum(dppass, "stencilOp: dppass"))
46443:         return NS_OK;
46442: 
46442:     MakeContextCurrent();
46442:     gl->fStencilOp(sfail, dpfail, dppass);
46442:     return NS_OK;
46442: }
46442: 
46442: NS_IMETHODIMP
46442: WebGLContext::StencilOpSeparate(WebGLenum face, WebGLenum sfail, WebGLenum dpfail, WebGLenum dppass)
46442: {
46443:     if (!ValidateFaceEnum(face, "stencilOpSeparate: face") ||
46443:         !ValidateStencilOpEnum(sfail, "stencilOpSeparate: sfail") ||
46443:         !ValidateStencilOpEnum(dpfail, "stencilOpSeparate: dpfail") ||
46443:         !ValidateStencilOpEnum(dppass, "stencilOpSeparate: dppass"))
46443:         return NS_OK;
46442: 
46442:     MakeContextCurrent();
46442:     gl->fStencilOpSeparate(face, sfail, dpfail, dppass);
46442:     return NS_OK;
46442: }
32195: 
43854: template<int format>
43854: inline void convert_pixel(PRUint8* dst, const PRUint8* src)
43854: {
43854:     // since has_alpha is a compile time constant, any if(has_alpha) evaluates
43854:     // at compile time, so has zero runtime cost.
43854:     enum { has_alpha = format == gfxASurface::ImageFormatARGB32 };
43854: 
43854: #ifdef IS_LITTLE_ENDIAN
43854:     PRUint8 b = *src++;
43854:     PRUint8 g = *src++;
43854:     PRUint8 r = *src++;
43854:     PRUint8 a = *src;
43854: #else
43854:     PRUint8 a = *src++;
43854:     PRUint8 r = *src++;
43854:     PRUint8 g = *src++;
43854:     PRUint8 b = *src;
43854: #endif
43854: 
43854:     if (has_alpha) {
43854:         // Convert to non-premultiplied color
43854:         if (a != 0) {
43854:             r = (r * 255) / a;
43854:             g = (g * 255) / a;
43854:             b = (b * 255) / a;
43854:         }
43854:     }
43854: 
43854:     *dst++ = r;
43854:     *dst++ = g;
43854:     *dst++ = b;
43854:     if (has_alpha)
43854:         *dst = a;
43854:     else
43854:         *dst = 255;
43854: }
32195: 
32195: nsresult
37417: WebGLContext::DOMElementToImageSurface(nsIDOMElement *imageOrCanvas,
34454:                                        gfxImageSurface **imageOut,
35422:                                        PRBool flipY, PRBool premultiplyAlpha)
32195: {
32195:     gfxImageSurface *surf = nsnull;
32195: 
32195:     nsLayoutUtils::SurfaceFromElementResult res =
32195:         nsLayoutUtils::SurfaceFromElement(imageOrCanvas,
32195:                                           nsLayoutUtils::SFE_WANT_NEW_SURFACE | nsLayoutUtils::SFE_WANT_IMAGE_SURFACE);
32195:     if (!res.mSurface)
32195:         return NS_ERROR_FAILURE;
32195: 
43655:     CanvasUtils::DoDrawImageSecurityCheck(HTMLCanvasElement(), res.mPrincipal, res.mIsWriteOnly);
32195: 
32195:     if (res.mSurface->GetType() != gfxASurface::SurfaceTypeImage) {
32195:         // SurfaceFromElement lied!
32195:         return NS_ERROR_FAILURE;
32195:     }
32195: 
32195:     surf = static_cast<gfxImageSurface*>(res.mSurface.get());
32195: 
32195:     PRInt32 width, height;
32195:     width = res.mSize.width;
32195:     height = res.mSize.height;
32195: 
32195:     if (width <= 0 || height <= 0)
32195:         return NS_ERROR_FAILURE;
32195: 
43854:     // this wants some SSE love
43854:     int row1 = 0, row2 = height-1;
43854:     for (; flipY ? (row1 <= row2) : (row1 < height); row1++, row2--) {
43854:         PRUint8 *row1_start = surf->Data() + row1 * surf->Stride();
43854:         PRUint8 *row1_end = row1_start + surf->Stride();
43854:         PRUint8 *row2_start = surf->Data() + row2 * surf->Stride();
43854: 
43854:         if (flipY == PR_FALSE || row1 == row2) {
32195:             if (surf->Format() == gfxASurface::ImageFormatARGB32) {
43854:                 for (PRUint8 *row1_ptr = row1_start; row1_ptr != row1_end; row1_ptr += 4) {
43854:                     convert_pixel<gfxASurface::ImageFormatARGB32>(row1_ptr, row1_ptr);
32195:                 }
32195:             } else if (surf->Format() == gfxASurface::ImageFormatRGB24) {
43854:                 for (PRUint8 *row1_ptr = row1_start; row1_ptr != row1_end; row1_ptr += 4) {
43854:                     convert_pixel<gfxASurface::ImageFormatRGB24>(row1_ptr, row1_ptr);
32195:                 }
32195:             } else {
32195:                 return NS_ERROR_FAILURE;
32195:             }
43854:         } else {
43854:             PRUint8 *row1_ptr = row1_start;
43854:             PRUint8 *row2_ptr = row2_start;
43854:             PRUint8 tmp[4];
43854:             if (surf->Format() == gfxASurface::ImageFormatARGB32) {
43854:                 for (; row1_ptr != row1_end; row1_ptr += 4, row2_ptr += 4) {
43854:                     convert_pixel<gfxASurface::ImageFormatARGB32>(tmp, row1_ptr);
43854:                     convert_pixel<gfxASurface::ImageFormatARGB32>(row1_ptr, row2_ptr);
43854:                     *reinterpret_cast<PRUint32*>(row2_ptr) = *reinterpret_cast<PRUint32*>(tmp);
43854:                 }
43854:             } else if (surf->Format() == gfxASurface::ImageFormatRGB24) {
43854:                 for (; row1_ptr != row1_end; row1_ptr += 4, row2_ptr += 4) {
43854:                     convert_pixel<gfxASurface::ImageFormatRGB24>(tmp, row1_ptr);
43854:                     convert_pixel<gfxASurface::ImageFormatRGB24>(row1_ptr, row2_ptr);
43854:                     *reinterpret_cast<PRUint32*>(row2_ptr) = *reinterpret_cast<PRUint32*>(tmp);
43854:                 }
43854:             } else {
34454:                 return NS_ERROR_FAILURE;
43854:             }
43854:         }
34454:     }
34454: 
32195:     res.mSurface.forget();
32195:     *imageOut = surf;
32195: 
32195:     return NS_OK;
32195: }
32195: 
47811: #define OBTAIN_UNIFORM_LOCATION(info)                                   \
43010:     WebGLUniformLocation *location_object;                              \
47811:     if (!GetConcreteObject(info, ploc, &location_object))               \
47811:         return NS_OK;                                                   \
43010:     if (mCurrentProgram != location_object->Program())                  \
47814:         return ErrorInvalidOperation("%s: this uniform location doesn't correspond to the current program", info); \
43331:     if (mCurrentProgram->Generation() != location_object->ProgramGeneration())            \
47814:         return ErrorInvalidOperation("%s: This uniform location is obsolete since the program has been relinked", info); \
43010:     GLint location = location_object->Location();
43010: 
43010: #define SIMPLE_ARRAY_METHOD_UNIFORM(name, cnt, arrayType, ptrType)      \
37417: NS_IMETHODIMP                                                           \
37417: WebGLContext::name(PRInt32 dummy) {                                     \
37417:      return NS_ERROR_NOT_IMPLEMENTED;                                   \
37417: }                                                                       \
37417: NS_IMETHODIMP                                                           \
43010: WebGLContext::name##_array(nsIWebGLUniformLocation *ploc, js::TypedArray *wa) \
37417: {                                                                       \
47811:     OBTAIN_UNIFORM_LOCATION(#name ": location")                         \
37417:     if (!wa || wa->type != js::TypedArray::arrayType)                   \
47812:         return ErrorInvalidOperation(#name ": array must be " #arrayType);      \
37417:     if (wa->length == 0 || wa->length % cnt != 0)                       \
47812:         return ErrorInvalidOperation(#name ": array must be > 0 elements and have a length multiple of %d", cnt); \
37417:     MakeContextCurrent();                                               \
43010:     gl->f##name(location, wa->length / cnt, (ptrType *)wa->data);            \
37417:     return NS_OK;                                                       \
37417: }
37417: 
43010: #define SIMPLE_ARRAY_METHOD_NO_COUNT(name, cnt, arrayType, ptrType)  \
37417: NS_IMETHODIMP                                                           \
37417: WebGLContext::name(PRInt32 dummy) {                                     \
37417:      return NS_ERROR_NOT_IMPLEMENTED;                                   \
37417: }                                                                       \
37417: NS_IMETHODIMP                                                           \
42916: WebGLContext::name##_array(WebGLuint idx, js::TypedArray *wa)              \
37417: {                                                                       \
37417:     if (!wa || wa->type != js::TypedArray::arrayType)                   \
47812:         return ErrorInvalidOperation(#name ": array must be " #arrayType);      \
37417:     if (wa->length < cnt)                                               \
47812:         return ErrorInvalidOperation(#name ": array must be >= %d elements", cnt); \
37417:     MakeContextCurrent();                                               \
37417:     gl->f##name(idx, (ptrType *)wa->data);                              \
37417:     return NS_OK;                                                       \
37417: }
37417: 
43010: #define SIMPLE_MATRIX_METHOD_UNIFORM(name, dim, arrayType, ptrType)     \
37417: NS_IMETHODIMP                                                           \
37417: WebGLContext::name(PRInt32 dummy) {                                     \
37417:      return NS_ERROR_NOT_IMPLEMENTED;                                   \
37417: }                                                                       \
37417: NS_IMETHODIMP                                                           \
43010: WebGLContext::name##_array(nsIWebGLUniformLocation *ploc, WebGLboolean transpose, js::TypedArray *wa)  \
37417: {                                                                       \
47811:     OBTAIN_UNIFORM_LOCATION(#name ": location")                         \
37417:     if (!wa || wa->type != js::TypedArray::arrayType)                   \
48925:         return ErrorInvalidValue(#name ": array must be " #arrayType);      \
37417:     if (wa->length == 0 || wa->length % (dim*dim) != 0)                 \
48925:         return ErrorInvalidValue(#name ": array length must be >0 and multiple of %d", dim*dim); \
47812:     if (transpose)                                                      \
47812:         return ErrorInvalidValue(#name ": transpose must be FALSE as per the OpenGL ES 2.0 spec"); \
37417:     MakeContextCurrent();                                               \
43010:     gl->f##name(location, wa->length / (dim*dim), transpose, (ptrType *)wa->data); \
37417:     return NS_OK;                                                       \
37417: }
37417: 
43010: #define SIMPLE_METHOD_UNIFORM_1(glname, name, t1)        \
43010: NS_IMETHODIMP WebGLContext::name(nsIWebGLUniformLocation *ploc, t1 a1) {      \
47811:     OBTAIN_UNIFORM_LOCATION(#name ": location") \
43010:     MakeContextCurrent(); gl->f##glname(location, a1); return NS_OK; \
43010: }
43010: 
43010: #define SIMPLE_METHOD_UNIFORM_2(glname, name, t1, t2)        \
43010: NS_IMETHODIMP WebGLContext::name(nsIWebGLUniformLocation *ploc, t1 a1, t2 a2) {      \
47811:     OBTAIN_UNIFORM_LOCATION(#name ": location") \
43010:     MakeContextCurrent(); gl->f##glname(location, a1, a2); return NS_OK; \
43010: }
43010: 
43010: #define SIMPLE_METHOD_UNIFORM_3(glname, name, t1, t2, t3)        \
43010: NS_IMETHODIMP WebGLContext::name(nsIWebGLUniformLocation *ploc, t1 a1, t2 a2, t3 a3) {      \
47811:     OBTAIN_UNIFORM_LOCATION(#name ": location") \
43010:     MakeContextCurrent(); gl->f##glname(location, a1, a2, a3); return NS_OK; \
43010: }
43010: 
43010: #define SIMPLE_METHOD_UNIFORM_4(glname, name, t1, t2, t3, t4)        \
43010: NS_IMETHODIMP WebGLContext::name(nsIWebGLUniformLocation *ploc, t1 a1, t2 a2, t3 a3, t4 a4) {      \
47811:     OBTAIN_UNIFORM_LOCATION(#name ": location") \
43010:     MakeContextCurrent(); gl->f##glname(location, a1, a2, a3, a4); return NS_OK; \
43010: }
43010: 
43010: SIMPLE_METHOD_UNIFORM_1(Uniform1i, Uniform1i, WebGLint)
43010: SIMPLE_METHOD_UNIFORM_2(Uniform2i, Uniform2i, WebGLint, WebGLint)
43010: SIMPLE_METHOD_UNIFORM_3(Uniform3i, Uniform3i, WebGLint, WebGLint, WebGLint)
43010: SIMPLE_METHOD_UNIFORM_4(Uniform4i, Uniform4i, WebGLint, WebGLint, WebGLint, WebGLint)
43010: 
43010: SIMPLE_METHOD_UNIFORM_1(Uniform1f, Uniform1f, WebGLfloat)
43010: SIMPLE_METHOD_UNIFORM_2(Uniform2f, Uniform2f, WebGLfloat, WebGLfloat)
43010: SIMPLE_METHOD_UNIFORM_3(Uniform3f, Uniform3f, WebGLfloat, WebGLfloat, WebGLfloat)
43010: SIMPLE_METHOD_UNIFORM_4(Uniform4f, Uniform4f, WebGLfloat, WebGLfloat, WebGLfloat, WebGLfloat)
43010: 
43010: SIMPLE_ARRAY_METHOD_UNIFORM(Uniform1iv, 1, TYPE_INT32, WebGLint)
43010: SIMPLE_ARRAY_METHOD_UNIFORM(Uniform2iv, 2, TYPE_INT32, WebGLint)
43010: SIMPLE_ARRAY_METHOD_UNIFORM(Uniform3iv, 3, TYPE_INT32, WebGLint)
43010: SIMPLE_ARRAY_METHOD_UNIFORM(Uniform4iv, 4, TYPE_INT32, WebGLint)
43010: 
43010: SIMPLE_ARRAY_METHOD_UNIFORM(Uniform1fv, 1, TYPE_FLOAT32, WebGLfloat)
43010: SIMPLE_ARRAY_METHOD_UNIFORM(Uniform2fv, 2, TYPE_FLOAT32, WebGLfloat)
43010: SIMPLE_ARRAY_METHOD_UNIFORM(Uniform3fv, 3, TYPE_FLOAT32, WebGLfloat)
43010: SIMPLE_ARRAY_METHOD_UNIFORM(Uniform4fv, 4, TYPE_FLOAT32, WebGLfloat)
43010: 
43010: SIMPLE_MATRIX_METHOD_UNIFORM(UniformMatrix2fv, 2, TYPE_FLOAT32, WebGLfloat)
43010: SIMPLE_MATRIX_METHOD_UNIFORM(UniformMatrix3fv, 3, TYPE_FLOAT32, WebGLfloat)
43010: SIMPLE_MATRIX_METHOD_UNIFORM(UniformMatrix4fv, 4, TYPE_FLOAT32, WebGLfloat)
42916: 
42916: GL_SAME_METHOD_2(VertexAttrib1f, VertexAttrib1f, PRUint32, WebGLfloat)
42916: GL_SAME_METHOD_3(VertexAttrib2f, VertexAttrib2f, PRUint32, WebGLfloat, WebGLfloat)
42916: GL_SAME_METHOD_4(VertexAttrib3f, VertexAttrib3f, PRUint32, WebGLfloat, WebGLfloat, WebGLfloat)
42916: GL_SAME_METHOD_5(VertexAttrib4f, VertexAttrib4f, PRUint32, WebGLfloat, WebGLfloat, WebGLfloat, WebGLfloat)
42916: 
43010: SIMPLE_ARRAY_METHOD_NO_COUNT(VertexAttrib1fv, 1, TYPE_FLOAT32, WebGLfloat)
43010: SIMPLE_ARRAY_METHOD_NO_COUNT(VertexAttrib2fv, 2, TYPE_FLOAT32, WebGLfloat)
43010: SIMPLE_ARRAY_METHOD_NO_COUNT(VertexAttrib3fv, 3, TYPE_FLOAT32, WebGLfloat)
43010: SIMPLE_ARRAY_METHOD_NO_COUNT(VertexAttrib4fv, 4, TYPE_FLOAT32, WebGLfloat)
32195: 
32195: NS_IMETHODIMP
42471: WebGLContext::UseProgram(nsIWebGLProgram *pobj)
32195: {
42472:     WebGLProgram *prog;
42916:     WebGLuint progname;
43098:     PRBool isNull;
47811:     if (!GetConcreteObjectAndGLName("useProgram", pobj, &prog, &progname, &isNull))
47811:         return NS_OK;
42471: 
32195:     MakeContextCurrent();
32195: 
43098:     if (isNull) {
43098:         gl->fUseProgram(0);
43098:         mCurrentProgram = nsnull;
43098:     } else {
43098:         if (!prog->LinkStatus())
43098:             return ErrorInvalidOperation("UseProgram: program was not linked successfully");
42472:         gl->fUseProgram(progname);
42472:         mCurrentProgram = prog;
43098:     }
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42471: WebGLContext::ValidateProgram(nsIWebGLProgram *pobj)
32195: {
42916:     WebGLuint progname;
47811:     if (!GetGLName<WebGLProgram>("validateProgram", pobj, &progname))
47811:         return NS_OK;
42471: 
32195:     MakeContextCurrent();
32195: 
42472:     gl->fValidateProgram(progname);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32835: WebGLContext::CreateFramebuffer(nsIWebGLFramebuffer **retval)
32195: {
32195:     MakeContextCurrent();
32195: 
32195:     GLuint name;
32195:     gl->fGenFramebuffers(1, &name);
32195: 
43099:     WebGLFramebuffer *globj = new WebGLFramebuffer(this, name);
32195:     NS_ADDREF(*retval = globj);
32195:     mMapFramebuffers.Put(name, globj);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32835: WebGLContext::CreateRenderbuffer(nsIWebGLRenderbuffer **retval)
32195: {
32195:     MakeContextCurrent();
32195: 
32195:     GLuint name;
32195:     gl->fGenRenderbuffers(1, &name);
32195: 
43099:     WebGLRenderbuffer *globj = new WebGLRenderbuffer(this, name);
32195:     NS_ADDREF(*retval = globj);
32195:     mMapRenderbuffers.Put(name, globj);
32195: 
32195:     return NS_OK;
32195: }
32195: 
46442: NS_IMETHODIMP
46442: WebGLContext::Viewport(WebGLint x, WebGLint y, WebGLsizei width, WebGLsizei height)
46442: {
46442:     if (width < 0 || height < 0)
46442:         return ErrorInvalidOperation("Viewport: negative size");
46442: 
46442:     MakeContextCurrent();
46442:     gl->fViewport(x, y, width, height);
46442:     return NS_OK;
46442: }
32195: 
32195: NS_IMETHODIMP
42472: WebGLContext::CompileShader(nsIWebGLShader *sobj)
32195: {
47653:     WebGLShader *shader;
42916:     WebGLuint shadername;
47811: 
47833:     if (!GetConcreteObjectAndGLName("compileShader", sobj, &shader, &shadername))
47811:         return NS_OK;
32195:     MakeContextCurrent();
32195: 
49256: #if defined(USE_ANGLE)
47653:     if (shader->NeedsTranslation() && mShaderValidation) {
47653:         ShHandle compiler = 0;
47653:         int debugFlags = 0;
47653:         EShLanguage lang = (shader->ShaderType() == LOCAL_GL_VERTEX_SHADER) ?
47653:             EShLangVertex : EShLangFragment;
47653: 
47653:         TBuiltInResource resources;
47653: 
47653:         resources.maxVertexAttribs = mGLMaxVertexAttribs;
47653:         resources.maxVertexUniformVectors = mGLMaxVertexUniformVectors;
47653:         resources.maxVaryingVectors = mGLMaxVaryingVectors;
47653:         resources.maxVertexTextureImageUnits = mGLMaxVertexTextureImageUnits;
47653:         resources.maxCombinedTextureImageUnits = mGLMaxTextureUnits;
47653:         resources.maxTextureImageUnits = mGLMaxTextureImageUnits;
47653:         resources.maxFragmentUniformVectors = mGLMaxFragmentUniformVectors;
47653:         resources.maxDrawBuffers = 1;
47653: 
48434:         compiler = ShConstructCompiler(lang, EShSpecWebGL, &resources);
47653: 
50606:         nsPromiseFlatCString src(shader->Source());
47653:         const char *s = src.get();
47653: 
50607:         if (!ShCompile(compiler, &s, 1, EShOptNone, debugFlags)) {
49256:             const char* info = ShGetInfoLog(compiler);
49256:             if (info) {
49256:                 shader->SetTranslationFailure(nsDependentCString(info));
49256:             } else {
49256:                 shader->SetTranslationFailure(NS_LITERAL_CSTRING("Internal error: failed to get shader info log"));
49256:             }
47653:             ShDestruct(compiler);
47653:             return NS_OK;
47653:         }
47653: 
47653:         s = ShGetObjectCode(compiler);
47653:         gl->fShaderSource(shadername, 1, &s, NULL);
47653:         shader->SetTranslationSuccess();
47653: 
47653:         ShDestruct(compiler);
47653:     } else
47653: #endif
47653:     {
47653:         const char *s = nsDependentCString(shader->Source()).get();
47653:         gl->fShaderSource(shadername, 1, &s, NULL);
47653:         shader->SetTranslationSuccess();
47653:     }
47653: 
42472:     gl->fCompileShader(shadername);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: 
32195: NS_IMETHODIMP
43851: WebGLContext::GetShaderParameter(nsIWebGLShader *sobj, WebGLenum pname, nsIVariant **retval)
32835: {
47653:     WebGLShader *shader;
42916:     WebGLuint shadername;
47833:     if (!GetConcreteObjectAndGLName("getShaderParameter: shader", sobj, &shader, &shadername))
47811:         return NS_OK;
42471: 
43851:     nsCOMPtr<nsIWritableVariant> wrval = do_CreateInstance("@mozilla.org/variant;1");
43851:     NS_ENSURE_TRUE(wrval, NS_ERROR_FAILURE);
35013: 
35013:     MakeContextCurrent();
35013: 
35013:     switch (pname) {
35013:         case LOCAL_GL_SHADER_TYPE:
35013:         case LOCAL_GL_INFO_LOG_LENGTH:
35013:         {
43851:             GLint i = 0;
43851:             gl->fGetShaderiv(shadername, pname, &i);
43851:             wrval->SetAsInt32(i);
35013:         }
35013:             break;
47653:         case LOCAL_GL_SHADER_SOURCE_LENGTH:
47653:         {
47653:             wrval->SetAsInt32(PRInt32(shader->Source().Length()) + 1);
47653:         }
47653:             break;
43011:         case LOCAL_GL_DELETE_STATUS:
43011:         case LOCAL_GL_COMPILE_STATUS:
43011:         {
43851:             GLint i = 0;
43851:             gl->fGetShaderiv(shadername, pname, &i);
43851:             wrval->SetAsBool(PRBool(i));
43011:         }
43011:             break;
35013: 
35013:         default:
32835:             return NS_ERROR_NOT_IMPLEMENTED;
32835:     }
32835: 
43851:     *retval = wrval.forget().get();
43851: 
35013:     return NS_OK;
35013: }
35013: 
32195: NS_IMETHODIMP
42472: WebGLContext::GetShaderInfoLog(nsIWebGLShader *sobj, nsAString& retval)
32195: {
47653:     WebGLShader *shader;
42916:     WebGLuint shadername;
47833:     if (!GetConcreteObjectAndGLName("getShaderInfoLog: shader", sobj, &shader, &shadername))
47811:         return NS_OK;
42471: 
47653:     const nsCString& tlog = shader->TranslationLog();
47653:     if (!tlog.IsVoid()) {
47653:         CopyASCIItoUTF16(tlog, retval);
47653:         return NS_OK;
47653:     }
47653: 
32195:     MakeContextCurrent();
32195: 
32195:     PRInt32 k = -1;
42472:     gl->fGetShaderiv(shadername, LOCAL_GL_INFO_LOG_LENGTH, (GLint*) &k);
32195:     if (k == -1)
42477:         return NS_ERROR_FAILURE; // XXX GL Error? should never happen.
32195: 
32195:     if (k == 0) {
32195:         retval.Truncate();
32195:         return NS_OK;
32195:     }
32195: 
32195:     nsCAutoString log;
32195:     log.SetCapacity(k);
32195: 
42472:     gl->fGetShaderInfoLog(shadername, k, (GLint*) &k, (char*) log.BeginWriting());
32195: 
32195:     log.SetLength(k);
32195: 
32195:     CopyASCIItoUTF16(log, retval);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42472: WebGLContext::GetShaderSource(nsIWebGLShader *sobj, nsAString& retval)
32195: {
47653:     WebGLShader *shader;
42916:     WebGLuint shadername;
47833:     if (!GetConcreteObjectAndGLName("getShaderSource: shader", sobj, &shader, &shadername))
47811:         return NS_OK;
42471: 
47653:     CopyASCIItoUTF16(shader->Source(), retval);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42472: WebGLContext::ShaderSource(nsIWebGLShader *sobj, const nsAString& source)
32195: {
47653:     WebGLShader *shader;
42916:     WebGLuint shadername;
47833:     if (!GetConcreteObjectAndGLName("shaderSource: shader", sobj, &shader, &shadername))
47811:         return NS_OK;
42471: 
47653:     shader->SetSource(NS_LossyConvertUTF16toASCII(source));
47653: 
47653:     shader->SetNeedsTranslation();
47653: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::VertexAttribPointer(WebGLuint index, WebGLint size, WebGLenum type,
42916:                                   WebGLboolean normalized, WebGLuint stride,
43009:                                   WebGLuint byteOffset)
32195: {
32195:     if (mBoundArrayBuffer == nsnull)
42477:         return ErrorInvalidOperation("VertexAttribPointer: must have valid GL_ARRAY_BUFFER binding");
42477: 
42477:     switch (type) {
42477:       case LOCAL_GL_BYTE:
42477:       case LOCAL_GL_UNSIGNED_BYTE:
42477:       case LOCAL_GL_SHORT:
42477:       case LOCAL_GL_UNSIGNED_SHORT:
42477:       // XXX case LOCAL_GL_FIXED:
42477:       case LOCAL_GL_FLOAT:
42477:           break;
42477:       default:
47813:           return ErrorInvalidEnumInfo("VertexAttribPointer: type", type);
42477:     }
32195: 
32195:     if (index >= mAttribBuffers.Length())
42477:         return ErrorInvalidValue("VertexAttribPointer: index out of range - %d >= %d", index, mAttribBuffers.Length());
32195: 
32195:     if (size < 1 || size > 4)
42477:         return ErrorInvalidValue("VertexAttribPointer: invalid element size");
42477: 
34453:     /* XXX make work with bufferSubData & heterogeneous types 
32195:     if (type != mBoundArrayBuffer->GLType())
42477:         return ErrorInvalidOperation("VertexAttribPointer: type must match bound VBO type: %d != %d", type, mBoundArrayBuffer->GLType());
34453:     */
32195: 
32195:     // XXX 0 stride?
32195:     //if (stride < (GLuint) size)
42477:     //    return ErrorInvalidOperation("VertexAttribPointer: stride must be >= size!");
32195: 
32195:     WebGLVertexAttribData &vd = mAttribBuffers[index];
32195: 
32195:     vd.buf = mBoundArrayBuffer;
32195:     vd.stride = stride;
32195:     vd.size = size;
43009:     vd.byteOffset = byteOffset;
43009:     vd.type = type;
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     gl->fVertexAttribPointer(index, size, type, normalized,
34453:                              stride,
43009:                              (void*) (byteOffset));
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
37417: WebGLContext::TexImage2D(PRInt32 dummy)
32195: {
37417:     return NS_ERROR_FAILURE;
32195: }
32195: 
37417: nsresult
42916: WebGLContext::TexImage2D_base(WebGLenum target, WebGLint level, WebGLenum internalformat,
42916:                               WebGLsizei width, WebGLsizei height, WebGLint border,
42916:                               WebGLenum format, WebGLenum type,
37417:                               void *data, PRUint32 byteLength)
34454: {
37417:     switch (target) {
37417:         case LOCAL_GL_TEXTURE_2D:
37417:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X:
37417:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
37417:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
37417:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
37417:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
37417:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
37417:             break;
37417:         default:
47813:             return ErrorInvalidEnumInfo("texImage2D: target", target);
34454:     }
37417: 
37417:     if (level < 0)
42477:         return ErrorInvalidValue("TexImage2D: level must be >= 0");
37417: 
37417:     switch (internalformat) {
37417:         case LOCAL_GL_RGB:
37417:         case LOCAL_GL_RGBA:
37417:         case LOCAL_GL_ALPHA:
37417:         case LOCAL_GL_LUMINANCE:
37417:         case LOCAL_GL_LUMINANCE_ALPHA:
37417:             break;
37417:         default:
47813:             return ErrorInvalidEnumInfo("TexImage2D: internal format", internalformat);
37417:     }
37417: 
42470:     if (width < 0 || height < 0)
42477:         return ErrorInvalidValue("TexImage2D: width and height must be >= 0");
37417: 
37417:     if (border != 0)
42477:         return ErrorInvalidValue("TexImage2D: border must be 0");
37417: 
46443:     PRUint32 texelSize = 0;
46443:     if (!ValidateTexFormatAndType(format, type, &texelSize, "texImage2D"))
46443:         return NS_OK;
37417: 
47204:     CheckedUint32 checked_bytesNeeded = CheckedUint32(width) * height * texelSize;
47204: 
47204:     if (!checked_bytesNeeded.valid())
47204:         return ErrorInvalidOperation("texImage2D: integer overflow computing the needed buffer size");
47204: 
47204:     PRUint32 bytesNeeded = checked_bytesNeeded.value();
37417:     
37417:     if (byteLength && byteLength < bytesNeeded)
47204:         return ErrorInvalidOperation("TexImage2D: not enough data for operation (need %d, have %d)",
42477:                                  bytesNeeded, byteLength);
37417: 
37417:     MakeContextCurrent();
37417: 
37417:     if (byteLength) {
37417:         gl->fTexImage2D(target, level, internalformat, width, height, border, format, type, data);
37417:     } else {
42476:         // We need some zero pages, because GL doesn't guarantee the
42476:         // contents of a texture allocated with NULL data.
42476:         // Hopefully calloc will just mmap zero pages here.
42476:         void *tempZeroData = calloc(1, bytesNeeded);
42476:         if (!tempZeroData)
42477:             return SynthesizeGLError(LOCAL_GL_OUT_OF_MEMORY, "texImage2D: could not allocate %d bytes (for zero fill)", bytesNeeded);
42476: 
42476:         gl->fTexImage2D(target, level, internalformat, width, height, border, format, type, tempZeroData);
42476: 
42476:         free(tempZeroData);
37417:     }
37417: 
42473:     if (mBound2DTextures[mActiveTexture])
42473:         mBound2DTextures[mActiveTexture]->setDimensions(width, height);
42473: 
37417:     return NS_OK;
37417: }
37417: 
37417: NS_IMETHODIMP
42916: WebGLContext::TexImage2D_buf(WebGLenum target, WebGLint level, WebGLenum internalformat,
42916:                              WebGLsizei width, WebGLsizei height, WebGLint border,
42916:                              WebGLenum format, WebGLenum type,
37417:                              js::ArrayBuffer *pixels)
37417: {
37417:     return TexImage2D_base(target, level, internalformat, width, height, border, format, type,
37417:                            pixels ? pixels->data : 0,
37417:                            pixels ? pixels->byteLength : 0);
37417: }
37417: 
37417: NS_IMETHODIMP
42916: WebGLContext::TexImage2D_array(WebGLenum target, WebGLint level, WebGLenum internalformat,
42916:                                WebGLsizei width, WebGLsizei height, WebGLint border,
42916:                                WebGLenum format, WebGLenum type,
37417:                                js::TypedArray *pixels)
37417: {
37417:     return TexImage2D_base(target, level, internalformat, width, height, border, format, type,
37417:                            pixels ? pixels->data : 0,
37417:                            pixels ? pixels->byteLength : 0);
37417: }
37417: 
37417: NS_IMETHODIMP
43638: WebGLContext::TexImage2D_dom(WebGLenum target, WebGLint level, WebGLenum internalformat,
43638:                              WebGLenum format, GLenum type, nsIDOMElement *elt)
37417: {
34454:     nsRefPtr<gfxImageSurface> isurf;
34454: 
37417:     nsresult rv = DOMElementToImageSurface(elt, getter_AddRefs(isurf),
43639:                                            mPixelStoreFlipY, mPixelStorePremultiplyAlpha);
43638:     if (NS_FAILED(rv))
43638:         return rv;
43638: 
43638:     NS_ASSERTION(isurf->Stride() == isurf->Width() * 4, "Bad stride!");
43638: 
43638:     PRUint32 byteLength = isurf->Stride() * isurf->Height();
43638: 
43638:     return TexImage2D_base(target, level, internalformat,
43638:                            isurf->Width(), isurf->Height(), 0,
43638:                            format, type,
43638:                            isurf->Data(), byteLength);
43638: }
43638: 
43638: NS_IMETHODIMP
37417: WebGLContext::TexSubImage2D(PRInt32 dummy)
32195: {
37417:     return NS_ERROR_FAILURE;
32195: }
32195: 
37417: nsresult
42916: WebGLContext::TexSubImage2D_base(WebGLenum target, WebGLint level,
42916:                                  WebGLint xoffset, WebGLint yoffset,
42916:                                  WebGLsizei width, WebGLsizei height,
42916:                                  WebGLenum format, WebGLenum type,
37417:                                  void *pixels, PRUint32 byteLength)
37417: {
37417:     switch (target) {
32195:         case LOCAL_GL_TEXTURE_2D:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
32195:             break;
32195:         default:
47813:             return ErrorInvalidEnumInfo("texSubImage2D: target", target);
32195:     }
32195: 
37417:     if (level < 0)
42477:         return ErrorInvalidValue("TexSubImage2D: level must be >= 0");
42477: 
42477:     if (width < 0 || height < 0)
42477:         return ErrorInvalidValue("TexSubImage2D: width and height must be > 0!");
42477: 
46443:     PRUint32 texelSize = 0;
46443:     if (!ValidateTexFormatAndType(format, type, &texelSize, "texSubImage2D"))
46443:         return NS_OK;
46443: 
42477:     if (width == 0 || height == 0)
42477:         return NS_OK; // ES 2.0 says it has no effect, we better return right now
37417: 
47204:     CheckedUint32 checked_bytesNeeded = CheckedUint32(width) * height * texelSize;
47204: 
47204:     if (!checked_bytesNeeded.valid())
47204:         return ErrorInvalidOperation("texSubImage2D: integer overflow computing the needed buffer size");
47204: 
47204:     PRUint32 bytesNeeded = checked_bytesNeeded.value();
47204:  
37417:     if (byteLength < bytesNeeded)
42477:         return ErrorInvalidValue("TexSubImage2D: not enough data for operation (need %d, have %d)", bytesNeeded, byteLength);
35422: 
32195:     MakeContextCurrent();
37417: 
37417:     gl->fTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
37417: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::TexSubImage2D_buf(WebGLenum target, WebGLint level,
42916:                                 WebGLint xoffset, WebGLint yoffset,
42916:                                 WebGLsizei width, WebGLsizei height,
42916:                                 WebGLenum format, WebGLenum type,
37417:                                 js::ArrayBuffer *pixels)
32195: {
37417:     if (!pixels)
42477:         return ErrorInvalidValue("TexSubImage2D: pixels must not be null!");
37417: 
37417:     return TexSubImage2D_base(target, level, xoffset, yoffset,
37417:                               width, height, format, type,
37417:                               pixels->data, pixels->byteLength);
32195: }
32195: 
37417: NS_IMETHODIMP
42916: WebGLContext::TexSubImage2D_array(WebGLenum target, WebGLint level,
42916:                                   WebGLint xoffset, WebGLint yoffset,
42916:                                   WebGLsizei width, WebGLsizei height,
42916:                                   WebGLenum format, WebGLenum type,
37417:                                   js::TypedArray *pixels)
32195: {
37417:     if (!pixels)
42477:         return ErrorInvalidValue("TexSubImage2D: pixels must not be null!");
37417: 
37417:     return TexSubImage2D_base(target, level, xoffset, yoffset,
37417:                               width, height, format, type,
37417:                               pixels->data, pixels->byteLength);
32195: }
37417: 
37417: NS_IMETHODIMP
42916: WebGLContext::TexSubImage2D_dom(WebGLenum target, WebGLint level,
42916:                                 WebGLint xoffset, WebGLint yoffset,
43638:                                 WebGLenum format, WebGLenum type,
43638:                                 nsIDOMElement *elt)
37417: {
32195:     nsRefPtr<gfxImageSurface> isurf;
32195: 
37417:     nsresult rv = DOMElementToImageSurface(elt, getter_AddRefs(isurf),
43639:                                            mPixelStoreFlipY, mPixelStorePremultiplyAlpha);
32195:     if (NS_FAILED(rv))
37417:         return rv;
37417: 
43638:     PRUint32 byteLength = isurf->Stride() * isurf->Height();
43638: 
37417:     return TexSubImage2D_base(target, level,
37417:                               xoffset, yoffset,
43638:                               isurf->Width(), isurf->Height(),
37417:                               LOCAL_GL_RGBA, LOCAL_GL_UNSIGNED_BYTE,
43638:                               isurf->Data(), byteLength);
32195: }
32195: 
32195: #if 0
32195: // ImageData getImageData (in float x, in float y, in float width, in float height);
32195: NS_IMETHODIMP
32195: WebGLContext::GetImageData(PRUint32 x, PRUint32 y, PRUint32 w, PRUint32 h)
32195: {
32195:     // disabled due to win32 linkage issues with thebes symbols and NS_RELEASE
32195:     return NS_ERROR_FAILURE;
32195: 
32195: #if 0
32195:     NativeJSContext js;
32195:     if (NS_FAILED(js.error))
32195:         return js.error;
32195: 
32195:     if (js.argc != 4) return NS_ERROR_INVALID_ARG;
32195:     
32195:     if (!mGLPbuffer ||
32195:         !mGLPbuffer->ThebesSurface())
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     if (!mCanvasElement)
32195:         return NS_ERROR_FAILURE;
32195: 
43655:     if (HTMLCanvasElement()->IsWriteOnly() && !IsCallerTrustedForRead()) {
32195:         // XXX ERRMSG we need to report an error to developers here! (bug 329026)
32195:         return NS_ERROR_DOM_SECURITY_ERR;
32195:     }
32195: 
32195:     JSContext *ctx = js.ctx;
32195: 
32195:     if (!CanvasUtils::CheckSaneSubrectSize (x, y, w, h, mWidth, mHeight))
32195:         return NS_ERROR_DOM_SYNTAX_ERR;
32195: 
32195:     nsAutoArrayPtr<PRUint8> surfaceData (new (std::nothrow) PRUint8[w * h * 4]);
32195:     int surfaceDataStride = w*4;
32195:     int surfaceDataOffset = 0;
32195: 
32195:     if (!surfaceData)
32195:         return NS_ERROR_OUT_OF_MEMORY;
32195: 
32195:     nsRefPtr<gfxImageSurface> tmpsurf = new gfxImageSurface(surfaceData,
32195:                                                             gfxIntSize(w, h),
32195:                                                             w * 4,
32195:                                                             gfxASurface::ImageFormatARGB32);
32195:     if (!tmpsurf || tmpsurf->CairoStatus())
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     nsRefPtr<gfxContext> tmpctx = new gfxContext(tmpsurf);
32195: 
32195:     if (!tmpctx || tmpctx->HasError())
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     nsRefPtr<gfxASurface> surf = mGLPbuffer->ThebesSurface();
32195:     nsRefPtr<gfxPattern> pat = CanvasGLThebes::CreatePattern(surf);
32195:     gfxMatrix m;
32195:     m.Translate(gfxPoint(x, mGLPbuffer->Height()-y));
32195:     m.Scale(1.0, -1.0);
32195:     pat->SetMatrix(m);
32195: 
32195:     // XXX I don't want to use PixelSnapped here, but layout doesn't guarantee
32195:     // pixel alignment for this stuff!
32195:     tmpctx->NewPath();
32195:     tmpctx->PixelSnappedRectangleAndSetPattern(gfxRect(0, 0, w, h), pat);
32195:     tmpctx->SetOperator(gfxContext::OPERATOR_SOURCE);
32195:     tmpctx->Fill();
32195: 
32195:     tmpctx = nsnull;
32195:     tmpsurf = nsnull;
32195: 
32195:     PRUint32 len = w * h * 4;
32195:     if (len > (((PRUint32)0xfff00000)/sizeof(jsval)))
32195:         return NS_ERROR_INVALID_ARG;
32195: 
32195:     nsAutoArrayPtr<jsval> jsvector(new (std::nothrow) jsval[w * h * 4]);
32195:     if (!jsvector)
32195:         return NS_ERROR_OUT_OF_MEMORY;
32195:     jsval *dest = jsvector.get();
32195:     PRUint8 *row;
32195:     for (PRUint32 j = 0; j < h; j++) {
32195:         row = surfaceData + surfaceDataOffset + (surfaceDataStride * j);
32195:         for (PRUint32 i = 0; i < w; i++) {
32195:             // XXX Is there some useful swizzle MMX we can use here?
32195:             // I guess we have to INT_TO_JSVAL still
32195: #ifdef IS_LITTLE_ENDIAN
32195:             PRUint8 b = *row++;
32195:             PRUint8 g = *row++;
32195:             PRUint8 r = *row++;
32195:             PRUint8 a = *row++;
32195: #else
32195:             PRUint8 a = *row++;
32195:             PRUint8 r = *row++;
32195:             PRUint8 g = *row++;
32195:             PRUint8 b = *row++;
32195: #endif
32195:             // Convert to non-premultiplied color
32195:             if (a != 0) {
32195:                 r = (r * 255) / a;
32195:                 g = (g * 255) / a;
32195:                 b = (b * 255) / a;
32195:             }
32195: 
32195:             *dest++ = INT_TO_JSVAL(r);
32195:             *dest++ = INT_TO_JSVAL(g);
32195:             *dest++ = INT_TO_JSVAL(b);
32195:             *dest++ = INT_TO_JSVAL(a);
32195:         }
32195:     }
32195: 
32195:     JSObject *dataArray = JS_NewArrayObject(ctx, w*h*4, jsvector);
32195:     if (!dataArray)
32195:         return NS_ERROR_OUT_OF_MEMORY;
32195: 
32195:     JSObjectHelper retobj(&js);
32195:     retobj.DefineProperty("width", w);
32195:     retobj.DefineProperty("height", h);
32195:     retobj.DefineProperty("data", dataArray);
32195: 
32195:     js.SetRetVal(retobj);
32195: 
32195:     return NS_OK;
32195: #endif
32195: }
32195: #endif
32195: 
32195: PRBool
42916: BaseTypeAndSizeFromUniformType(WebGLenum uType, WebGLenum *baseType, WebGLint *unitSize)
32195: {
32195:     switch (uType) {
32195:         case LOCAL_GL_INT:
32195:         case LOCAL_GL_INT_VEC2:
32195:         case LOCAL_GL_INT_VEC3:
32195:         case LOCAL_GL_INT_VEC4:
32195:         case LOCAL_GL_SAMPLER_2D:
32195:         case LOCAL_GL_SAMPLER_CUBE:
32195:             *baseType = LOCAL_GL_INT;
32195:             break;
32195:         case LOCAL_GL_FLOAT:
32195:         case LOCAL_GL_FLOAT_VEC2:
32195:         case LOCAL_GL_FLOAT_VEC3:
32195:         case LOCAL_GL_FLOAT_VEC4:
32195:         case LOCAL_GL_FLOAT_MAT2:
32195:         case LOCAL_GL_FLOAT_MAT3:
32195:         case LOCAL_GL_FLOAT_MAT4:
32195:             *baseType = LOCAL_GL_FLOAT;
32195:             break;
32195:         case LOCAL_GL_BOOL:
32195:         case LOCAL_GL_BOOL_VEC2:
32195:         case LOCAL_GL_BOOL_VEC3:
32195:         case LOCAL_GL_BOOL_VEC4:
43852:             *baseType = LOCAL_GL_BOOL; // pretend these are int
32195:             break;
32195:         default:
32195:             return PR_FALSE;
32195:     }
32195: 
32195:     switch (uType) {
32195:         case LOCAL_GL_INT:
32195:         case LOCAL_GL_FLOAT:
32195:         case LOCAL_GL_BOOL:
32195:         case LOCAL_GL_SAMPLER_2D:
32195:         case LOCAL_GL_SAMPLER_CUBE:
32195:             *unitSize = 1;
32195:             break;
32195:         case LOCAL_GL_INT_VEC2:
32195:         case LOCAL_GL_FLOAT_VEC2:
32195:         case LOCAL_GL_BOOL_VEC2:
32195:             *unitSize = 2;
32195:             break;
32195:         case LOCAL_GL_INT_VEC3:
32195:         case LOCAL_GL_FLOAT_VEC3:
32195:         case LOCAL_GL_BOOL_VEC3:
32195:             *unitSize = 3;
32195:             break;
32195:         case LOCAL_GL_INT_VEC4:
32195:         case LOCAL_GL_FLOAT_VEC4:
32195:         case LOCAL_GL_BOOL_VEC4:
32195:             *unitSize = 4;
32195:             break;
32195:         case LOCAL_GL_FLOAT_MAT2:
32195:             *unitSize = 4;
32195:             break;
32195:         case LOCAL_GL_FLOAT_MAT3:
32195:             *unitSize = 9;
32195:             break;
32195:         case LOCAL_GL_FLOAT_MAT4:
32195:             *unitSize = 16;
32195:             break;
32195:         default:
32195:             return PR_FALSE;
32195:     }
32195: 
32195:     return PR_TRUE;
32195: }
