    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Joe Hewitt <hewitt@netscape.com> (original author)
    1:  *   Christopher A. Aillon <christopher@aillon.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "inDOMUtils.h"
    1: #include "inLayoutUtils.h"
    1: 
    1: #include "nsIServiceManager.h"
    1: #include "nsString.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDocument.h"
31312: #include "nsIPresShell.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMCharacterData.h"
    1: #include "nsRuleNode.h"
    1: #include "nsIStyleRule.h"
    1: #include "nsICSSStyleRule.h"
    1: #include "nsICSSStyleRuleDOMWrapper.h"
    1: #include "nsIDOMWindowInternal.h"
31312: #include "nsXBLBinding.h"
31312: #include "nsXBLPrototypeBinding.h"
31312: #include "nsIDOMElement.h"
31312: #include "nsIMutableArray.h"
31312: #include "nsBindingManager.h"
31312: #include "nsComputedDOMStyle.h"
    1: 
    1: ///////////////////////////////////////////////////////////////////////////////
    1: 
    1: inDOMUtils::inDOMUtils()
    1: {
    1: }
    1: 
    1: inDOMUtils::~inDOMUtils()
    1: {
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS1(inDOMUtils, inIDOMUtils)
    1: 
    1: ///////////////////////////////////////////////////////////////////////////////
    1: // inIDOMUtils
    1: 
    1: NS_IMETHODIMP
    1: inDOMUtils::IsIgnorableWhitespace(nsIDOMCharacterData *aDataNode,
    1:                                   PRBool *aReturn)
    1: {
    1:   NS_PRECONDITION(aReturn, "Must have an out parameter");
    1: 
22837:   NS_ENSURE_ARG_POINTER(aDataNode);
22837: 
    1:   *aReturn = PR_FALSE;
    1: 
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aDataNode);
    1:   NS_ASSERTION(content, "Does not implement nsIContent!");
    1: 
    1:   if (!content->TextIsOnlyWhitespace()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Okay.  We have only white space.  Let's check the white-space
    1:   // property now and make sure that this isn't preformatted text...
    1: 
    1:   nsCOMPtr<nsIDOMWindowInternal> win = inLayoutUtils::GetWindowFor(aDataNode);
    1:   if (!win) {
    1:     // Hmm.  Things are screwy if we have no window...
    1:     NS_ERROR("No window!");
    1:     return NS_OK;
    1:   }
    1: 
36656:   nsIFrame* frame = content->GetPrimaryFrame();
    1:   if (frame) {
    1:     const nsStyleText* text = frame->GetStyleText();
11894:     *aReturn = !text->WhiteSpaceIsSignificant();
    1:   }
    1:   else {
    1:     // empty inter-tag text node without frame, e.g., in between <table>\n<tr>
    1:     *aReturn = PR_TRUE;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMUtils::GetParentForNode(nsIDOMNode* aNode,
    1:                              PRBool aShowingAnonymousContent,
    1:                              nsIDOMNode** aParent)
    1: {
22837:   NS_ENSURE_ARG_POINTER(aNode);
22837: 
    1:   // First do the special cases -- document nodes and anonymous content
    1:   nsCOMPtr<nsIDOMDocument> doc(do_QueryInterface(aNode));
    1:   nsCOMPtr<nsIDOMNode> parent;
    1: 
    1:   if (doc) {
    1:     parent = inLayoutUtils::GetContainerFor(doc);
    1:   } else if (aShowingAnonymousContent) {
    1:     nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
    1:     if (content) {
    1:       nsIContent* bparent = nsnull;
    1:       nsRefPtr<nsBindingManager> bindingManager = inLayoutUtils::GetBindingManagerFor(aNode);
    1:       if (bindingManager) {
    1:         bparent = bindingManager->GetInsertionParent(content);
    1:       }
    1:     
    1:       parent = do_QueryInterface(bparent);
    1:     }
    1:   }
    1:   
    1:   if (!parent) {
    1:     // Ok, just get the normal DOM parent node
    1:     aNode->GetParentNode(getter_AddRefs(parent));
    1:   }
    1: 
    1:   NS_IF_ADDREF(*aParent = parent);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMUtils::GetCSSStyleRules(nsIDOMElement *aElement,
    1:                              nsISupportsArray **_retval)
    1: {
22837:   NS_ENSURE_ARG_POINTER(aElement);
    1: 
    1:   *_retval = nsnull;
    1: 
    1:   nsRuleNode* ruleNode = nsnull;
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aElement);
35230:   nsRefPtr<nsStyleContext> styleContext;
35230:   GetRuleNodeForContent(content, getter_AddRefs(styleContext), &ruleNode);
    1:   if (!ruleNode) {
    1:     // This can fail for content nodes that are not in the document or
    1:     // if the document they're in doesn't have a presshell.  Bail out.
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsISupportsArray> rules;
    1:   NS_NewISupportsArray(getter_AddRefs(rules));
    1:   if (!rules) return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   nsCOMPtr<nsICSSStyleRule> cssRule;
    1:   nsCOMPtr<nsIDOMCSSRule> domRule;
31313:   for ( ; !ruleNode->IsRoot(); ruleNode = ruleNode->GetParent()) {
31313:     cssRule = do_QueryInterface(ruleNode->GetRule());
    1:     if (cssRule) {
    1:       cssRule->GetDOMRule(getter_AddRefs(domRule));
    1:       if (domRule)
    1:         rules->InsertElementAt(domRule, 0);
    1:     }
    1:   }
    1: 
    1:   *_retval = rules;
    1:   NS_ADDREF(*_retval);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMUtils::GetRuleLine(nsIDOMCSSStyleRule *aRule, PRUint32 *_retval)
    1: {
    1:   *_retval = 0;
22837: 
22837:   NS_ENSURE_ARG_POINTER(aRule);
22837: 
    1:   nsCOMPtr<nsICSSStyleRuleDOMWrapper> rule = do_QueryInterface(aRule);
    1:   nsCOMPtr<nsICSSStyleRule> cssrule;
22837:   nsresult rv = rule->GetCSSStyleRule(getter_AddRefs(cssrule));
22837:   NS_ENSURE_SUCCESS(rv, rv);
22837:   NS_ENSURE_TRUE(cssrule != nsnull, NS_ERROR_FAILURE);
    1:   *_retval = cssrule->GetLineNumber();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: inDOMUtils::GetBindingURLs(nsIDOMElement *aElement, nsIArray **_retval)
    1: {
22837:   NS_ENSURE_ARG_POINTER(aElement);
31312: 
31312:   *_retval = nsnull;
31312: 
31312:   nsCOMPtr<nsIMutableArray> urls = do_CreateInstance(NS_ARRAY_CONTRACTID);
31312:   if (!urls)
31312:     return NS_ERROR_FAILURE;
31312: 
31312:   nsCOMPtr<nsIContent> content = do_QueryInterface(aElement);
31312:   NS_ASSERTION(content, "elements must implement nsIContent");
31312: 
31312:   nsIDocument *ownerDoc = content->GetOwnerDoc();
31312:   if (ownerDoc) {
31312:     nsXBLBinding *binding = ownerDoc->BindingManager()->GetBinding(content);
31312: 
31312:     while (binding) {
31312:       urls->AppendElement(binding->PrototypeBinding()->BindingURI(), PR_FALSE);
31312:       binding = binding->GetBaseBinding();
31312:     }
31312:   }
31312: 
31312:   NS_ADDREF(*_retval = urls);
31312:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMUtils::SetContentState(nsIDOMElement *aElement, PRInt32 aState)
    1: {
22837:   NS_ENSURE_ARG_POINTER(aElement);
    1:   
    1:   nsCOMPtr<nsIEventStateManager> esm = inLayoutUtils::GetEventStateManagerFor(aElement);
    1:   if (esm) {
    1:     nsCOMPtr<nsIContent> content;
    1:     content = do_QueryInterface(aElement);
    1:   
    1:     return esm->SetContentState(content, aState);
    1:   }
    1:   
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMUtils::GetContentState(nsIDOMElement *aElement, PRInt32* aState)
    1: {
    1:   *aState = 0;
    1: 
22837:   NS_ENSURE_ARG_POINTER(aElement);
    1: 
    1:   nsCOMPtr<nsIEventStateManager> esm = inLayoutUtils::GetEventStateManagerFor(aElement);
    1:   if (esm) {
    1:     nsCOMPtr<nsIContent> content;
    1:     content = do_QueryInterface(aElement);
    1:   
    1:     return esm->GetContentState(content, *aState);
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
31312: /* static */ nsresult
35230: inDOMUtils::GetRuleNodeForContent(nsIContent* aContent,
35230:                                   nsStyleContext** aStyleContext,
35230:                                   nsRuleNode** aRuleNode)
31312: {
31312:   *aRuleNode = nsnull;
35230:   *aStyleContext = nsnull;
31312: 
31312:   nsIDocument* doc = aContent->GetDocument();
31312:   NS_ENSURE_TRUE(doc, NS_ERROR_UNEXPECTED);
31312: 
31312:   nsIPresShell *presShell = doc->GetPrimaryShell();
31312:   NS_ENSURE_TRUE(presShell, NS_ERROR_UNEXPECTED);
31312: 
36787:   nsPresContext *presContext = presShell->GetPresContext();
36787:   NS_ENSURE_TRUE(presContext, NS_ERROR_UNEXPECTED);
36787: 
36787:   PRBool safe = presContext->EnsureSafeToHandOutCSSRules();
36787:   NS_ENSURE_TRUE(safe, NS_ERROR_OUT_OF_MEMORY);
36787: 
31312:   nsRefPtr<nsStyleContext> sContext =
31312:     nsComputedDOMStyle::GetStyleContextForContent(aContent, nsnull, presShell);
31312:   *aRuleNode = sContext->GetRuleNode();
35230:   sContext.forget(aStyleContext);
31312:   return NS_OK;
31312: }
