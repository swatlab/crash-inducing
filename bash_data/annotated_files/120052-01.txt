     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
104487: #include <stddef.h>                     // for NULL
104487: 
104487: #include "mozilla/Assertions.h"         // for MOZ_ASSERT, etc
104487: #include "mozilla/mozalloc.h"           // for operator new, etc
104487: #include "nsAString.h"                  // for nsAString_internal::Length, etc
104487: #include "nsAutoPtr.h"                  // for nsRefPtr
104487: #include "nsContentUtils.h"             // for nsContentUtils
104487: #include "nsDebug.h"                    // for NS_ENSURE_TRUE, etc
104487: #include "nsDependentSubstring.h"       // for Substring
104487: #include "nsError.h"                    // for NS_OK, NS_ERROR_FAILURE, etc
104487: #include "nsFilteredContentIterator.h"  // for nsFilteredContentIterator
104487: #include "nsIContent.h"                 // for nsIContent, etc
104487: #include "nsIContentIterator.h"         // for nsIContentIterator
104487: #include "nsID.h"                       // for NS_GET_IID
104487: #include "nsIDOMDocument.h"             // for nsIDOMDocument
104487: #include "nsIDOMElement.h"              // for nsIDOMElement
104487: #include "nsIDOMHTMLDocument.h"         // for nsIDOMHTMLDocument
104487: #include "nsIDOMHTMLElement.h"          // for nsIDOMHTMLElement
104487: #include "nsIDOMNode.h"                 // for nsIDOMNode, etc
104487: #include "nsIDOMRange.h"                // for nsIDOMRange, etc
104487: #include "nsIEditor.h"                  // for nsIEditor, etc
104487: #include "nsINode.h"                    // for nsINode
104487: #include "nsIPlaintextEditor.h"         // for nsIPlaintextEditor
104487: #include "nsISelection.h"               // for nsISelection
104487: #include "nsISelectionController.h"     // for nsISelectionController, etc
104487: #include "nsISupportsBase.h"            // for nsISupports
104487: #include "nsISupportsUtils.h"           // for NS_IF_ADDREF, NS_ADDREF, etc
104487: #include "nsITextServicesFilter.h"      // for nsITextServicesFilter
104487: #include "nsIWordBreaker.h"             // for nsWordRange, nsIWordBreaker
104487: #include "nsRange.h"                    // for nsRange
104487: #include "nsStaticAtom.h"               // for NS_STATIC_ATOM, etc
104487: #include "nsString.h"                   // for nsString, nsAutoString
     1: #include "nsTextServicesDocument.h"
104487: #include "nscore.h"                     // for nsresult, NS_IMETHODIMP, etc
     1: 
     1: #define LOCK_DOC(doc)
     1: #define UNLOCK_DOC(doc)
     1: 
 80467: using namespace mozilla;
     1: 
     1: class OffsetEntry
     1: {
     1: public:
108991:   OffsetEntry(nsIDOMNode *aNode, int32_t aOffset, int32_t aLength)
     1:     : mNode(aNode), mNodeOffset(0), mStrOffset(aOffset), mLength(aLength),
 80486:       mIsInsertedText(false), mIsValid(true)
     1:   {
     1:     if (mStrOffset < 1)
     1:       mStrOffset = 0;
     1: 
     1:     if (mLength < 1)
     1:       mLength = 0;
     1:   }
     1: 
     1:   virtual ~OffsetEntry()
     1:   {
     1:     mNode       = 0;
     1:     mNodeOffset = 0;
     1:     mStrOffset  = 0;
     1:     mLength     = 0;
 80486:     mIsValid    = false;
     1:   }
     1: 
     1:   nsIDOMNode *mNode;
108991:   int32_t mNodeOffset;
108991:   int32_t mStrOffset;
108991:   int32_t mLength;
 79445:   bool    mIsInsertedText;
 79445:   bool    mIsValid;
     1: };
     1: 
     1: #define TS_ATOM(name_, value_) nsIAtom* nsTextServicesDocument::name_ = 0;
104487: #include "nsTSAtomList.h" // IWYU pragma: keep
     1: #undef TS_ATOM
     1: 
     1: nsTextServicesDocument::nsTextServicesDocument()
     1: {
     1:   mRefCnt         = 0;
     1: 
     1:   mSelStartIndex  = -1;
     1:   mSelStartOffset = -1;
     1:   mSelEndIndex    = -1;
     1:   mSelEndOffset   = -1;
     1: 
     1:   mIteratorStatus = eIsDone;
     1: }
     1: 
     1: nsTextServicesDocument::~nsTextServicesDocument()
     1: {
     1:   ClearOffsetTable(&mOffsetTable);
     1: }
     1: 
 39099: #define TS_ATOM(name_, value_) NS_STATIC_ATOM_BUFFER(name_##_buffer, value_)
104487: #include "nsTSAtomList.h" // IWYU pragma: keep
 39099: #undef TS_ATOM
 39099: 
     1: /* static */
     1: void
     1: nsTextServicesDocument::RegisterAtoms()
     1: {
     1:   static const nsStaticAtom ts_atoms[] = {
 39099: #define TS_ATOM(name_, value_) NS_STATIC_ATOM(name_##_buffer, &name_),
104487: #include "nsTSAtomList.h" // IWYU pragma: keep
     1: #undef TS_ATOM
     1:   };
     1: 
 91877:   NS_RegisterStaticAtoms(ts_atoms);
     1: }
     1: 
 43054: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsTextServicesDocument)
 43054: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsTextServicesDocument)
 43054: 
 43054: NS_INTERFACE_MAP_BEGIN(nsTextServicesDocument)
 43054:   NS_INTERFACE_MAP_ENTRY(nsITextServicesDocument)
 43303:   NS_INTERFACE_MAP_ENTRY(nsIEditActionListener)
 43054:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsITextServicesDocument)
 43054:   NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsTextServicesDocument)
 43054: NS_INTERFACE_MAP_END
 43054: 
 43303: NS_IMPL_CYCLE_COLLECTION_7(nsTextServicesDocument,
 43054:                            mDOMDocument,
 43054:                            mSelCon,
 43054:                            mIterator,
 43054:                            mPrevTextBlock,
 43054:                            mNextTextBlock,
 43054:                            mExtent,
 43054:                            mTxtSvcFilter)
     1: 
     1: NS_IMETHODIMP
     1: nsTextServicesDocument::InitWithEditor(nsIEditor *aEditor)
     1: {
     1:   nsresult result = NS_OK;
     1:   nsCOMPtr<nsISelectionController> selCon;
     1:   nsCOMPtr<nsIDOMDocument> doc;
     1: 
 43807:   NS_ENSURE_TRUE(aEditor, NS_ERROR_NULL_POINTER);
     1: 
     1:   LOCK_DOC(this);
     1: 
     1:   // Check to see if we already have an mSelCon. If we do, it
     1:   // better be the same one the editor uses!
     1: 
     1:   result = aEditor->GetSelectionController(getter_AddRefs(selCon));
     1: 
     1:   if (NS_FAILED(result))
     1:   {
     1:     UNLOCK_DOC(this);
     1:     return result;
     1:   }
     1: 
     1:   if (!selCon || (mSelCon && selCon != mSelCon))
     1:   {
     1:     UNLOCK_DOC(this);
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   if (!mSelCon)
     1:     mSelCon = selCon;
     1: 
     1:   // Check to see if we already have an mDOMDocument. If we do, it
     1:   // better be the same one the editor uses!
     1: 
     1:   result = aEditor->GetDocument(getter_AddRefs(doc));
     1: 
     1:   if (NS_FAILED(result))
     1:   {
     1:     UNLOCK_DOC(this);
     1:     return result;
     1:   }
     1: 
     1:   if (!doc || (mDOMDocument && doc != mDOMDocument))
     1:   {
     1:     UNLOCK_DOC(this);
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   if (!mDOMDocument)
     1:   {
     1:     mDOMDocument = doc;
     1: 
     1:     result = CreateDocumentContentIterator(getter_AddRefs(mIterator));
     1: 
     1:     if (NS_FAILED(result))
     1:     {
     1:       UNLOCK_DOC(this);
     1:       return result;
     1:     }
     1: 
     1:     mIteratorStatus = nsTextServicesDocument::eIsDone;
     1: 
     1:     result = FirstBlock();
     1: 
     1:     if (NS_FAILED(result))
     1:     {
     1:       UNLOCK_DOC(this);
     1:       return result;
     1:     }
     1:   }
     1: 
     1:   mEditor = do_GetWeakReference(aEditor);
 43303: 
 43303:   result = aEditor->AddEditActionListener(this);
     1: 
     1:   UNLOCK_DOC(this);
     1: 
     1:   return result;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsTextServicesDocument::GetDocument(nsIDOMDocument **aDoc)
     1: {
 43807:   NS_ENSURE_TRUE(aDoc, NS_ERROR_NULL_POINTER);
     1: 
106838:   *aDoc = nullptr; // init out param
 43807:   NS_ENSURE_TRUE(mDOMDocument, NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   *aDoc = mDOMDocument;
     1:   NS_ADDREF(*aDoc);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTextServicesDocument::SetExtent(nsIDOMRange* aDOMRange)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aDOMRange);
     1:   NS_ENSURE_TRUE(mDOMDocument, NS_ERROR_FAILURE);
     1: 
     1:   LOCK_DOC(this);
     1: 
     1:   // We need to store a copy of aDOMRange since we don't
     1:   // know where it came from.
     1: 
     1:   nsresult result = aDOMRange->CloneRange(getter_AddRefs(mExtent));
     1: 
     1:   if (NS_FAILED(result))
     1:   {
     1:     UNLOCK_DOC(this);
     1:     return result;
     1:   }
     1: 
     1:   // Create a new iterator based on our new extent range.
     1: 
     1:   result = CreateContentIterator(mExtent, getter_AddRefs(mIterator));
     1: 
     1:   if (NS_FAILED(result))
     1:   {
     1:     UNLOCK_DOC(this);
     1:     return result;
     1:   }
     1: 
     1:   // Now position the iterator at the start of the first block
     1:   // in the range.
     1: 
     1:   mIteratorStatus = nsTextServicesDocument::eIsDone;
     1: 
     1:   result = FirstBlock();
     1: 
     1:   UNLOCK_DOC(this);
     1: 
     1:   return result;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTextServicesDocument::ExpandRangeToWordBoundaries(nsIDOMRange *aRange)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aRange);
     1: 
     1:   // Get the end points of the range.
     1: 
     1:   nsCOMPtr<nsIDOMNode> rngStartNode, rngEndNode;
108991:   int32_t rngStartOffset, rngEndOffset;
     1: 
     1:   nsresult result =  GetRangeEndPoints(aRange,
     1:                                        getter_AddRefs(rngStartNode),
     1:                                        &rngStartOffset,
     1:                                        getter_AddRefs(rngEndNode),
     1:                                        &rngEndOffset);
     1: 
     1:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   // Create a content iterator based on the range.
     1: 
     1:   nsCOMPtr<nsIContentIterator> iter;
     1:   result = CreateContentIterator(aRange, getter_AddRefs(iter));
     1: 
     1:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   // Find the first text node in the range.
     1: 
     1:   TSDIteratorStatus iterStatus;
     1: 
     1:   result = FirstTextNode(iter, &iterStatus);
     1:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   if (iterStatus == nsTextServicesDocument::eIsDone)
     1:   {
     1:     // No text was found so there's no adjustment necessary!
     1:     return NS_OK;
     1:   }
     1: 
 20503:   nsINode *firstText = iter->GetCurrentNode();
 20503:   NS_ENSURE_TRUE(firstText, NS_ERROR_FAILURE);
     1: 
     1:   // Find the last text node in the range.
     1: 
     1:   result = LastTextNode(iter, &iterStatus);
     1:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   if (iterStatus == nsTextServicesDocument::eIsDone)
     1:   {
     1:     // We should never get here because a first text block
     1:     // was found above.
 80486:     NS_ASSERTION(false, "Found a first without a last!");
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
 20503:   nsINode *lastText = iter->GetCurrentNode();
 20503:   NS_ENSURE_TRUE(lastText, NS_ERROR_FAILURE);
     1: 
     1:   // Now make sure our end points are in terms of text nodes in the range!
     1: 
 20503:   nsCOMPtr<nsIDOMNode> firstTextNode = do_QueryInterface(firstText);
     1:   NS_ENSURE_TRUE(firstTextNode, NS_ERROR_FAILURE);
     1: 
     1:   if (rngStartNode != firstTextNode)
     1:   {
     1:     // The range includes the start of the first text node!
     1:     rngStartNode = firstTextNode;
     1:     rngStartOffset = 0;
     1:   }
     1: 
 20503:   nsCOMPtr<nsIDOMNode> lastTextNode = do_QueryInterface(lastText);
     1:   NS_ENSURE_TRUE(lastTextNode, NS_ERROR_FAILURE);
     1: 
     1:   if (rngEndNode != lastTextNode)
     1:   {
     1:     // The range includes the end of the last text node!
     1:     rngEndNode = lastTextNode;
     1:     nsAutoString str;
     1:     result = lastTextNode->GetNodeValue(str);
     1:     rngEndOffset = str.Length();
     1:   }
     1: 
     1:   // Create a doc iterator so that we can scan beyond
     1:   // the bounds of the extent range.
     1: 
     1:   nsCOMPtr<nsIContentIterator> docIter;
     1:   result = CreateDocumentContentIterator(getter_AddRefs(docIter));
     1:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   // Grab all the text in the block containing our
     1:   // first text node.
     1: 
 20503:   result = docIter->PositionAt(firstText);
     1:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   iterStatus = nsTextServicesDocument::eValid;
     1: 
 27986:   nsTArray<OffsetEntry*> offsetTable;
     1:   nsAutoString blockStr;
     1: 
     1:   result = CreateOffsetTable(&offsetTable, docIter, &iterStatus,
106838:                              nullptr, &blockStr);
     1:   if (NS_FAILED(result))
     1:   {
     1:     ClearOffsetTable(&offsetTable);
     1:     return result;
     1:   }
     1: 
     1:   nsCOMPtr<nsIDOMNode> wordStartNode, wordEndNode;
108991:   int32_t wordStartOffset, wordEndOffset;
     1: 
     1:   result = FindWordBounds(&offsetTable, &blockStr,
     1:                           rngStartNode, rngStartOffset,
     1:                           getter_AddRefs(wordStartNode), &wordStartOffset,
     1:                           getter_AddRefs(wordEndNode), &wordEndOffset);
     1: 
     1:   ClearOffsetTable(&offsetTable);
     1: 
     1:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   rngStartNode = wordStartNode;
     1:   rngStartOffset = wordStartOffset;
     1: 
     1:   // Grab all the text in the block containing our
     1:   // last text node.
     1: 
 20503:   result = docIter->PositionAt(lastText);
     1:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   iterStatus = nsTextServicesDocument::eValid;
     1: 
     1:   result = CreateOffsetTable(&offsetTable, docIter, &iterStatus,
106838:                              nullptr, &blockStr);
     1:   if (NS_FAILED(result))
     1:   {
     1:     ClearOffsetTable(&offsetTable);
     1:     return result;
     1:   }
     1: 
     1:   result = FindWordBounds(&offsetTable, &blockStr,
     1:                           rngEndNode, rngEndOffset,
     1:                           getter_AddRefs(wordStartNode), &wordStartOffset,
     1:                           getter_AddRefs(wordEndNode), &wordEndOffset);
     1: 
     1:   ClearOffsetTable(&offsetTable);
     1: 
     1:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   // To prevent expanding the range too much, we only change
     1:   // rngEndNode and rngEndOffset if it isn't already at the start of the
     1:   // word and isn't equivalent to rngStartNode and rngStartOffset.
     1: 
     1:   if (rngEndNode != wordStartNode || rngEndOffset != wordStartOffset ||
     1:      (rngEndNode == rngStartNode  && rngEndOffset == rngStartOffset))
     1:   {
     1:     rngEndNode = wordEndNode;
     1:     rngEndOffset = wordEndOffset;
     1:   }
     1: 
     1:   // Now adjust the range so that it uses our new
     1:   // end points.
     1: 
     1:   result = aRange->SetEnd(rngEndNode, rngEndOffset);
     1:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   return aRange->SetStart(rngStartNode, rngStartOffset);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTextServicesDocument::SetFilter(nsITextServicesFilter *aFilter)
     1: {
     1:   // Hang on to the filter so we can set it into the filtered iterator.
     1:   mTxtSvcFilter = aFilter;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTextServicesDocument::GetCurrentTextBlock(nsString *aStr)
     1: {
     1:   nsresult result;
     1: 
 43807:   NS_ENSURE_TRUE(aStr, NS_ERROR_NULL_POINTER);
     1: 
     1:   aStr->Truncate();
     1: 
 43807:   NS_ENSURE_TRUE(mIterator, NS_ERROR_FAILURE);
     1: 
     1:   LOCK_DOC(this);
     1: 
     1:   result = CreateOffsetTable(&mOffsetTable, mIterator, &mIteratorStatus,
     1:                              mExtent, aStr);
     1: 
     1:   UNLOCK_DOC(this);
     1: 
     1:   return result;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTextServicesDocument::FirstBlock()
     1: {
     1:   NS_ENSURE_TRUE(mIterator, NS_ERROR_FAILURE);
     1: 
     1:   LOCK_DOC(this);
     1: 
     1:   nsresult result = FirstTextNode(mIterator, &mIteratorStatus);
     1: 
     1:   if (NS_FAILED(result))
     1:   {
     1:     UNLOCK_DOC(this);
     1:     return result;
     1:   }
     1: 
     1:   // Keep track of prev and next blocks, just in case
     1:   // the text service blows away the current block.
     1: 
     1:   if (mIteratorStatus == nsTextServicesDocument::eValid)
     1:   {
106838:     mPrevTextBlock  = nullptr;
     1:     result = GetFirstTextNodeInNextBlock(getter_AddRefs(mNextTextBlock));
     1:   }
     1:   else
     1:   {
     1:     // There's no text block in the document!
     1: 
106838:     mPrevTextBlock  = nullptr;
106838:     mNextTextBlock  = nullptr;
     1:   }
     1: 
     1:   UNLOCK_DOC(this);
     1: 
     1:   return result;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTextServicesDocument::LastSelectedBlock(TSDBlockSelectionStatus *aSelStatus,
108991:                                           int32_t *aSelOffset,
108991:                                           int32_t *aSelLength)
     1: {
     1:   nsresult result = NS_OK;
     1: 
 43807:   NS_ENSURE_TRUE(aSelStatus && aSelOffset && aSelLength, NS_ERROR_NULL_POINTER);
     1: 
     1:   LOCK_DOC(this);
     1: 
     1:   mIteratorStatus = nsTextServicesDocument::eIsDone;
     1: 
     1:   *aSelStatus = nsITextServicesDocument::eBlockNotFound;
     1:   *aSelOffset = *aSelLength = -1;
     1: 
     1:   if (!mSelCon || !mIterator)
     1:   {
     1:     UNLOCK_DOC(this);
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   nsCOMPtr<nsISelection> selection;
 79445:   bool isCollapsed = false;
     1: 
     1:   result = mSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(selection));
     1: 
     1:   if (NS_FAILED(result))
     1:   {
     1:     UNLOCK_DOC(this);
     1:     return result;
     1:   }
     1: 
     1:   result = selection->GetIsCollapsed(&isCollapsed);
     1: 
     1:   if (NS_FAILED(result))
     1:   {
     1:     UNLOCK_DOC(this);
     1:     return result;
     1:   }
     1: 
     1:   nsCOMPtr<nsIContentIterator> iter;
     1:   nsCOMPtr<nsIDOMRange>        range;
     1:   nsCOMPtr<nsIDOMNode>         parent;
108991:   int32_t                      i, rangeCount, offset;
     1: 
     1:   if (isCollapsed)
     1:   {
     1:     // We have a caret. Check if the caret is in a text node.
     1:     // If it is, make the text node's block the current block.
     1:     // If the caret isn't in a text node, search forwards in
     1:     // the document, till we find a text node.
     1: 
     1:     result = selection->GetRangeAt(0, getter_AddRefs(range));
     1: 
     1:     if (NS_FAILED(result))
     1:     {
     1:       UNLOCK_DOC(this);
     1:       return result;
     1:     }
     1: 
     1:     if (!range)
     1:     {
     1:       UNLOCK_DOC(this);
     1:       return NS_ERROR_FAILURE;
     1:     }
     1: 
     1:     result = range->GetStartContainer(getter_AddRefs(parent));
     1: 
     1:     if (NS_FAILED(result))
     1:     {
     1:       UNLOCK_DOC(this);
     1:       return result;
     1:     }
     1: 
     1:     if (!parent)
     1:     {
     1:       UNLOCK_DOC(this);
     1:       return NS_ERROR_FAILURE;
     1:     }
     1: 
     1:     result = range->GetStartOffset(&offset);
     1: 
     1:     if (NS_FAILED(result))
     1:     {
     1:       UNLOCK_DOC(this);
     1:       return result;
     1:     }
     1: 
     1:     if (IsTextNode(parent))
     1:     {
     1:       // The caret is in a text node. Find the beginning
     1:       // of the text block containing this text node and
     1:       // return.
     1: 
     1:       nsCOMPtr<nsIContent> content(do_QueryInterface(parent));
     1: 
     1:       if (!content)
     1:       {
     1:         UNLOCK_DOC(this);
     1:         return NS_ERROR_FAILURE;
     1:       }
     1: 
     1:       result = mIterator->PositionAt(content);
     1: 
     1:       if (NS_FAILED(result))
     1:       {
     1:         UNLOCK_DOC(this);
     1:         return result;
     1:       }
     1: 
     1:       result = FirstTextNodeInCurrentBlock(mIterator);
     1: 
     1:       if (NS_FAILED(result))
     1:       {
     1:         UNLOCK_DOC(this);
     1:         return result;
     1:       }
     1: 
     1:       mIteratorStatus = nsTextServicesDocument::eValid;
     1: 
     1:       result = CreateOffsetTable(&mOffsetTable, mIterator, &mIteratorStatus,
106838:                                  mExtent, nullptr);
     1: 
     1:       if (NS_FAILED(result))
     1:       {
     1:         UNLOCK_DOC(this);
     1:         return result;
     1:       }
     1: 
     1:       result = GetSelection(aSelStatus, aSelOffset, aSelLength);
     1: 
     1:       if (NS_FAILED(result))
     1:       {
     1:         UNLOCK_DOC(this);
     1:         return result;
     1:       }
     1: 
     1:       if (*aSelStatus == nsITextServicesDocument::eBlockContains)
 80486:         result = SetSelectionInternal(*aSelOffset, *aSelLength, false);
     1:     }
     1:     else
     1:     {
     1:       // The caret isn't in a text node. Create an iterator
     1:       // based on a range that extends from the current caret
     1:       // position to the end of the document, then walk forwards
     1:       // till you find a text node, then find the beginning of it's block.
     1: 
 80486:       result = CreateDocumentContentRootToNodeOffsetRange(parent, offset, false, getter_AddRefs(range));
     1: 
     1:       if (NS_FAILED(result))
     1:       {
     1:         UNLOCK_DOC(this);
     1:         return result;
     1:       }
     1: 
     1:       result = range->GetCollapsed(&isCollapsed);
     1: 
     1:       if (NS_FAILED(result))
     1:       {
     1:         UNLOCK_DOC(this);
     1:         return result;
     1:       }
     1: 
     1:       if (isCollapsed)
     1:       {
     1:         // If we get here, the range is collapsed because there is nothing after
     1:         // the caret! Just return NS_OK;
     1: 
     1:         UNLOCK_DOC(this);
     1:         return NS_OK;
     1:       }
     1: 
     1:       result = CreateContentIterator(range, getter_AddRefs(iter));
     1: 
     1:       if (NS_FAILED(result))
     1:       {
     1:         UNLOCK_DOC(this);
     1:         return result;
     1:       }
     1: 
     1:       iter->First();
     1: 
 20503:       nsCOMPtr<nsIContent> content;
     1:       while (!iter->IsDone())
     1:       {
 20503:         content = do_QueryInterface(iter->GetCurrentNode());
     1: 
     1:         if (IsTextNode(content))
     1:           break;
     1: 
106838:         content = nullptr;
     1: 
     1:         iter->Next();
     1:       }
     1: 
     1:       if (!content)
     1:       {
     1:         UNLOCK_DOC(this);
     1:         return NS_OK;
     1:       }
     1: 
     1:       result = mIterator->PositionAt(content);
     1: 
     1:       if (NS_FAILED(result))
     1:       {
     1:         UNLOCK_DOC(this);
     1:         return result;
     1:       }
     1: 
     1:       result = FirstTextNodeInCurrentBlock(mIterator);
     1: 
     1:       if (NS_FAILED(result))
     1:       {
     1:         UNLOCK_DOC(this);
     1:         return result;
     1:       }
     1: 
     1:       mIteratorStatus = nsTextServicesDocument::eValid;
     1: 
     1:       result = CreateOffsetTable(&mOffsetTable, mIterator, &mIteratorStatus,
106838:                                  mExtent, nullptr);
     1: 
     1:       if (NS_FAILED(result))
     1:       {
     1:         UNLOCK_DOC(this);
     1:         return result;
     1:       }
     1: 
     1:       result = GetSelection(aSelStatus, aSelOffset, aSelLength);
     1: 
     1:       if (NS_FAILED(result))
     1:       {
     1:         UNLOCK_DOC(this);
     1:         return result;
     1:       }
     1:     }
     1: 
     1:     UNLOCK_DOC(this);
     1: 
     1:     return result;
     1:   }
     1: 
     1:   // If we get here, we have an uncollapsed selection!
     1:   // Look backwards through each range in the selection till you
     1:   // find the first text node. If you find one, find the
 90153:   // beginning of its text block, and make it the current
     1:   // block.
     1: 
     1:   result = selection->GetRangeCount(&rangeCount);
     1: 
     1:   if (NS_FAILED(result))
     1:   {
     1:     UNLOCK_DOC(this);
     1:     return result;
     1:   }
     1: 
     1:   NS_ASSERTION(rangeCount > 0, "Unexpected range count!");
     1: 
     1:   if (rangeCount <= 0)
     1:   {
     1:     UNLOCK_DOC(this);
     1:     return NS_OK;
     1:   }
     1: 
     1:   // XXX: We may need to add some code here to make sure
     1:   //      the ranges are sorted in document appearance order!
     1: 
     1:   for (i = rangeCount - 1; i >= 0; i--)
     1:   {
     1:     // Get the i'th range from the selection.
     1: 
     1:     result = selection->GetRangeAt(i, getter_AddRefs(range));
     1: 
     1:     if (NS_FAILED(result))
     1:     {
     1:       UNLOCK_DOC(this);
     1:       return result;
     1:     }
     1: 
     1:     // Create an iterator for the range.
     1: 
     1:     result = CreateContentIterator(range, getter_AddRefs(iter));
     1: 
     1:     if (NS_FAILED(result))
     1:     {
     1:       UNLOCK_DOC(this);
     1:       return result;
     1:     }
     1: 
     1:     iter->Last();
     1: 
     1:     // Now walk through the range till we find a text node.
     1: 
     1:     while (!iter->IsDone())
     1:     {
101686:       if (iter->GetCurrentNode()->NodeType() == nsIDOMNode::TEXT_NODE) {
     1:         // We found a text node, so position the document's
     1:         // iterator at the beginning of the block, then get
     1:         // the selection in terms of the string offset.
101686:         nsCOMPtr<nsIContent> content = iter->GetCurrentNode()->AsContent();
     1: 
     1:         result = mIterator->PositionAt(content);
     1: 
     1:         if (NS_FAILED(result))
     1:         {
     1:           UNLOCK_DOC(this);
     1:           return result;
     1:         }
     1: 
     1:         result = FirstTextNodeInCurrentBlock(mIterator);
     1: 
     1:         if (NS_FAILED(result))
     1:         {
     1:           UNLOCK_DOC(this);
     1:           return result;
     1:         }
     1: 
     1:         mIteratorStatus = nsTextServicesDocument::eValid;
     1: 
     1:         result = CreateOffsetTable(&mOffsetTable, mIterator, &mIteratorStatus,
106838:                                    mExtent, nullptr);
     1: 
     1:         if (NS_FAILED(result))
     1:         {
     1:           UNLOCK_DOC(this);
     1:           return result;
     1:         }
     1: 
     1:         result = GetSelection(aSelStatus, aSelOffset, aSelLength);
     1: 
     1:         UNLOCK_DOC(this);
     1: 
     1:         return result;
     1: 
     1:       }
     1: 
     1:       iter->Prev();
     1:     }
     1:   }
     1: 
     1:   // If we get here, we didn't find any text node in the selection!
     1:   // Create a range that extends from the end of the selection,
     1:   // to the end of the document, then iterate forwards through
     1:   // it till you find a text node!
     1: 
     1:   result = selection->GetRangeAt(rangeCount - 1, getter_AddRefs(range));
     1: 
     1:   if (NS_FAILED(result))
     1:   {
     1:     UNLOCK_DOC(this);
     1:     return result;
     1:   }
     1: 
     1:   if (!range)
     1:   {
     1:     UNLOCK_DOC(this);
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   result = range->GetEndContainer(getter_AddRefs(parent));
     1: 
     1:   if (NS_FAILED(result))
     1:   {
     1:     UNLOCK_DOC(this);
     1:     return result;
     1:   }
     1: 
     1:   if (!parent)
     1:   {
     1:     UNLOCK_DOC(this);
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   result = range->GetEndOffset(&offset);
     1: 
     1:   if (NS_FAILED(result))
     1:   {
     1:     UNLOCK_DOC(this);
     1:     return result;
     1:   }
     1: 
 80486:   result = CreateDocumentContentRootToNodeOffsetRange(parent, offset, false, getter_AddRefs(range));
     1: 
     1:   if (NS_FAILED(result))
     1:   {
     1:     UNLOCK_DOC(this);
     1:     return result;
     1:   }
     1: 
     1:   result = range->GetCollapsed(&isCollapsed);
     1: 
     1:   if (NS_FAILED(result))
     1:   {
     1:     UNLOCK_DOC(this);
     1:     return result;
     1:   }
     1: 
     1:   if (isCollapsed)
     1:   {
     1:     // If we get here, the range is collapsed because there is nothing after
     1:     // the current selection! Just return NS_OK;
     1: 
     1:     UNLOCK_DOC(this);
     1:     return NS_OK;
     1:   }
     1: 
     1:   result = CreateContentIterator(range, getter_AddRefs(iter));
     1: 
     1:   if (NS_FAILED(result))
     1:   {
     1:     UNLOCK_DOC(this);
     1:     return result;
     1:   }
     1: 
     1:   iter->First();
     1: 
     1:   while (!iter->IsDone())
     1:   {
101686:     if (iter->GetCurrentNode()->NodeType() == nsIDOMNode::TEXT_NODE) {
     1:       // We found a text node! Adjust the document's iterator to point
 90153:       // to the beginning of its text block, then get the current selection.
101686:       nsCOMPtr<nsIContent> content = iter->GetCurrentNode()->AsContent();
     1: 
     1:       result = mIterator->PositionAt(content);
     1: 
     1:       if (NS_FAILED(result))
     1:       {
     1:         UNLOCK_DOC(this);
     1:         return result;
     1:       }
     1: 
     1:       result = FirstTextNodeInCurrentBlock(mIterator);
     1: 
     1:       if (NS_FAILED(result))
     1:       {
     1:         UNLOCK_DOC(this);
     1:         return result;
     1:       }
     1: 
     1: 
     1:       mIteratorStatus = nsTextServicesDocument::eValid;
     1: 
     1:       result = CreateOffsetTable(&mOffsetTable, mIterator, &mIteratorStatus,
106838:                                  mExtent, nullptr);
     1: 
     1:       if (NS_FAILED(result))
     1:       {
     1:         UNLOCK_DOC(this);
     1:         return result;
     1:       }
     1: 
     1:       result = GetSelection(aSelStatus, aSelOffset, aSelLength);
     1: 
     1:       UNLOCK_DOC(this);
     1: 
     1:       return result;
     1:     }
     1: 
     1:     iter->Next();
     1:   }
     1: 
     1:   // If we get here, we didn't find any block before or inside
     1:   // the selection! Just return OK.
     1: 
     1:   UNLOCK_DOC(this);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTextServicesDocument::PrevBlock()
     1: {
     1:   nsresult result = NS_OK;
     1: 
 43807:   NS_ENSURE_TRUE(mIterator, NS_ERROR_FAILURE);
     1: 
     1:   LOCK_DOC(this);
     1: 
     1:   if (mIteratorStatus == nsTextServicesDocument::eIsDone)
     1:     return NS_OK;
     1: 
     1:   switch (mIteratorStatus)
     1:   {
     1:     case nsTextServicesDocument::eValid:
     1:     case nsTextServicesDocument::eNext:
     1: 
     1:       result = FirstTextNodeInPrevBlock(mIterator);
     1: 
     1:       if (NS_FAILED(result))
     1:       {
     1:         mIteratorStatus = nsTextServicesDocument::eIsDone;
     1:         UNLOCK_DOC(this);
     1:         return result;
     1:       }
     1: 
     1:       if (mIterator->IsDone())
     1:       {
     1:         mIteratorStatus = nsTextServicesDocument::eIsDone;
     1:         UNLOCK_DOC(this);
     1:         return NS_OK;
     1:       }
     1: 
     1:       mIteratorStatus = nsTextServicesDocument::eValid;
     1:       break;
     1: 
     1:     case nsTextServicesDocument::ePrev:
     1: 
     1:       // The iterator already points to the previous
     1:       // block, so don't do anything.
     1: 
     1:       mIteratorStatus = nsTextServicesDocument::eValid;
     1:       break;
     1: 
     1:     default:
     1: 
     1:       mIteratorStatus = nsTextServicesDocument::eIsDone;
     1:       break;
     1:   }
     1: 
     1:   // Keep track of prev and next blocks, just in case
     1:   // the text service blows away the current block.
     1: 
     1:   if (mIteratorStatus == nsTextServicesDocument::eValid)
     1:   {
     1:     result = GetFirstTextNodeInPrevBlock(getter_AddRefs(mPrevTextBlock));
     1:     result = GetFirstTextNodeInNextBlock(getter_AddRefs(mNextTextBlock));
     1:   }
     1:   else
     1:   {
     1:     // We must be done!
     1: 
106838:     mPrevTextBlock = nullptr;
106838:     mNextTextBlock = nullptr;
     1:   }
     1: 
     1:   UNLOCK_DOC(this);
     1: 
     1:   return result;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTextServicesDocument::NextBlock()
     1: {
     1:   nsresult result = NS_OK;
     1: 
 43807:   NS_ENSURE_TRUE(mIterator, NS_ERROR_FAILURE);
     1: 
     1:   LOCK_DOC(this);
     1: 
     1:   if (mIteratorStatus == nsTextServicesDocument::eIsDone)
     1:     return NS_OK;
     1: 
     1:   switch (mIteratorStatus)
     1:   {
     1:     case nsTextServicesDocument::eValid:
     1: 
     1:       // Advance the iterator to the next text block.
     1: 
     1:       result = FirstTextNodeInNextBlock(mIterator);
     1: 
     1:       if (NS_FAILED(result))
     1:       {
     1:         mIteratorStatus = nsTextServicesDocument::eIsDone;
     1:         UNLOCK_DOC(this);
     1:         return result;
     1:       }
     1: 
     1:       if (mIterator->IsDone())
     1:       {
     1:         mIteratorStatus = nsTextServicesDocument::eIsDone;
     1:         UNLOCK_DOC(this);
     1:         return NS_OK;
     1:       }
     1: 
     1:       mIteratorStatus = nsTextServicesDocument::eValid;
     1:       break;
     1: 
     1:     case nsTextServicesDocument::eNext:
     1: 
     1:       // The iterator already points to the next block,
     1:       // so don't do anything to it!
     1: 
     1:       mIteratorStatus = nsTextServicesDocument::eValid;
     1:       break;
     1: 
     1:     case nsTextServicesDocument::ePrev:
     1: 
     1:       // If the iterator is pointing to the previous block,
     1:       // we know that there is no next text block! Just
     1:       // fall through to the default case!
     1: 
     1:     default:
     1: 
     1:       mIteratorStatus = nsTextServicesDocument::eIsDone;
     1:       break;
     1:   }
     1: 
     1:   // Keep track of prev and next blocks, just in case
     1:   // the text service blows away the current block.
     1: 
     1:   if (mIteratorStatus == nsTextServicesDocument::eValid)
     1:   {
     1:     result = GetFirstTextNodeInPrevBlock(getter_AddRefs(mPrevTextBlock));
     1:     result = GetFirstTextNodeInNextBlock(getter_AddRefs(mNextTextBlock));
     1:   }
     1:   else
     1:   {
     1:     // We must be done.
     1: 
106838:     mPrevTextBlock = nullptr;
106838:     mNextTextBlock = nullptr;
     1:   }
     1: 
     1: 
     1:   UNLOCK_DOC(this);
     1: 
     1:   return result;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsTextServicesDocument::IsDone(bool *aIsDone)
     1: {
 43807:   NS_ENSURE_TRUE(aIsDone, NS_ERROR_NULL_POINTER);
     1: 
 80486:   *aIsDone = false;
     1: 
 43807:   NS_ENSURE_TRUE(mIterator, NS_ERROR_FAILURE);
     1: 
     1:   LOCK_DOC(this);
     1: 
 80486:   *aIsDone = (mIteratorStatus == nsTextServicesDocument::eIsDone) ? true : false;
     1: 
     1:   UNLOCK_DOC(this);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTextServicesDocument::SetSelection(int32_t aOffset, int32_t aLength)
     1: {
     1:   nsresult result;
     1: 
 43807:   NS_ENSURE_TRUE(mSelCon && aOffset >= 0 && aLength >= 0, NS_ERROR_FAILURE);
     1: 
     1:   LOCK_DOC(this);
     1: 
 80486:   result = SetSelectionInternal(aOffset, aLength, true);
     1: 
     1:   UNLOCK_DOC(this);
     1: 
     1:   //**** KDEBUG ****
     1:   // printf("\n * Sel: (%2d, %4d) (%2d, %4d)\n", mSelStartIndex, mSelStartOffset, mSelEndIndex, mSelEndOffset);
     1:   //**** KDEBUG ****
     1: 
     1:   return result;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTextServicesDocument::ScrollSelectionIntoView()
     1: {
     1:   nsresult result;
     1: 
 43807:   NS_ENSURE_TRUE(mSelCon, NS_ERROR_FAILURE);
     1: 
     1:   LOCK_DOC(this);
     1: 
 12392:   // After ScrollSelectionIntoView(), the pending notifications might be flushed
 12392:   // and PresShell/PresContext/Frames may be dead. See bug 418470.
 56442:   result = mSelCon->ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL, nsISelectionController::SELECTION_FOCUS_REGION,
 56442:                                             nsISelectionController::SCROLL_SYNCHRONOUS);
     1: 
     1:   UNLOCK_DOC(this);
     1: 
     1:   return result;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTextServicesDocument::DeleteSelection()
     1: {
     1:   nsresult result = NS_OK;
     1: 
     1:   // We don't allow deletion during a collapsed selection!
     1:   nsCOMPtr<nsIEditor> editor (do_QueryReferent(mEditor));
     1:   NS_ASSERTION(editor, "DeleteSelection called without an editor present!"); 
     1:   NS_ASSERTION(SelectionIsValid(), "DeleteSelection called without a valid selection!"); 
     1: 
     1:   if (!editor || !SelectionIsValid())
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   if (SelectionIsCollapsed())
     1:     return NS_OK;
     1: 
     1:   LOCK_DOC(this);
     1: 
     1:   //**** KDEBUG ****
     1:   // printf("\n---- Before Delete\n");
     1:   // printf("Sel: (%2d, %4d) (%2d, %4d)\n", mSelStartIndex, mSelStartOffset, mSelEndIndex, mSelEndOffset);
     1:   // PrintOffsetTable();
     1:   //**** KDEBUG ****
     1: 
 90153:   // If we have an mExtent, save off its current set of
     1:   // end points so we can compare them against mExtent's
     1:   // set after the deletion of the content.
     1: 
     1:   nsCOMPtr<nsIDOMNode> origStartNode, origEndNode;
108991:   int32_t origStartOffset = 0, origEndOffset = 0;
     1: 
     1:   if (mExtent)
     1:   {
     1:     result = GetRangeEndPoints(mExtent,
     1:                                getter_AddRefs(origStartNode), &origStartOffset,
     1:                                getter_AddRefs(origEndNode), &origEndOffset);
     1: 
     1:     if (NS_FAILED(result))
     1:     {
     1:       UNLOCK_DOC(this);
     1:       return result;
     1:     }
     1:   }
     1: 
108991:   int32_t i, selLength;
     1:   OffsetEntry *entry, *newEntry;
     1: 
     1:   for (i = mSelStartIndex; i <= mSelEndIndex; i++)
     1:   {
 27986:     entry = mOffsetTable[i];
     1: 
     1:     if (i == mSelStartIndex)
     1:     {
     1:       // Calculate the length of the selection. Note that the
     1:       // selection length can be zero if the start of the selection
     1:       // is at the very end of a text node entry.
     1: 
     1:       if (entry->mIsInsertedText)
     1:       {
     1:         // Inserted text offset entries have no width when
     1:         // talking in terms of string offsets! If the beginning
     1:         // of the selection is in an inserted text offset entry,
     1:         // the caret is always at the end of the entry!
     1: 
     1:         selLength = 0;
     1:       }
     1:       else
     1:         selLength = entry->mLength - (mSelStartOffset - entry->mStrOffset);
     1: 
     1:       if (selLength > 0 && mSelStartOffset > entry->mStrOffset)
     1:       {
     1:         // Selection doesn't start at the beginning of the
     1:         // text node entry. We need to split this entry into
     1:         // two pieces, the piece before the selection, and
     1:         // the piece inside the selection.
     1: 
     1:         result = SplitOffsetEntry(i, selLength);
     1: 
     1:         if (NS_FAILED(result))
     1:         {
     1:           UNLOCK_DOC(this);
     1:           return result;
     1:         }
     1: 
     1:         // Adjust selection indexes to account for new entry:
     1: 
     1:         ++mSelStartIndex;
     1:         ++mSelEndIndex;
     1:         ++i;
     1: 
 27986:         entry = mOffsetTable[i];
     1:       }
     1: 
     1: 
     1:       if (selLength > 0 && mSelStartIndex < mSelEndIndex)
     1:       {
     1:         // The entire entry is contained in the selection. Mark the
     1:         // entry invalid.
     1: 
 80486:         entry->mIsValid = false;
     1:       }
     1:     }
     1: 
     1:   //**** KDEBUG ****
     1:   // printf("\n---- Middle Delete\n");
     1:   // printf("Sel: (%2d, %4d) (%2d, %4d)\n", mSelStartIndex, mSelStartOffset, mSelEndIndex, mSelEndOffset);
     1:   // PrintOffsetTable();
     1:   //**** KDEBUG ****
     1: 
     1:     if (i == mSelEndIndex)
     1:     {
     1:       if (entry->mIsInsertedText)
     1:       {
     1:         // Inserted text offset entries have no width when
     1:         // talking in terms of string offsets! If the end
     1:         // of the selection is in an inserted text offset entry,
     1:         // the selection includes the entire entry!
     1: 
 80486:         entry->mIsValid = false;
     1:       }
     1:       else
     1:       {
     1:         // Calculate the length of the selection. Note that the
     1:         // selection length can be zero if the end of the selection
     1:         // is at the very beginning of a text node entry.
     1: 
     1:         selLength = mSelEndOffset - entry->mStrOffset;
     1: 
     1:         if (selLength > 0 && mSelEndOffset < entry->mStrOffset + entry->mLength)
     1:         {
     1:           // mStrOffset is guaranteed to be inside the selection, even
     1:           // when mSelStartIndex == mSelEndIndex.
     1: 
     1:           result = SplitOffsetEntry(i, entry->mLength - selLength);
     1: 
     1:           if (NS_FAILED(result))
     1:           {
     1:             UNLOCK_DOC(this);
     1:             return result;
     1:           }
     1: 
     1:           // Update the entry fields:
     1: 
 27986:           newEntry = mOffsetTable[i+1];
     1:           newEntry->mNodeOffset = entry->mNodeOffset;
     1:         }
     1: 
     1: 
     1:         if (selLength > 0 && mSelEndOffset == entry->mStrOffset + entry->mLength)
     1:         {
     1:           // The entire entry is contained in the selection. Mark the
     1:           // entry invalid.
     1: 
 80486:           entry->mIsValid = false;
     1:         }
     1:       }
     1:     }
     1: 
     1:     if (i != mSelStartIndex && i != mSelEndIndex)
     1:     {
     1:       // The entire entry is contained in the selection. Mark the
     1:       // entry invalid.
     1: 
 80486:       entry->mIsValid = false;
     1:     }
     1:   }
     1: 
     1:   // Make sure mIterator always points to something valid!
     1: 
     1:   AdjustContentIterator();
     1: 
     1:   // Now delete the actual content!
     1: 
 98852:   result = editor->DeleteSelection(nsIEditor::ePrevious, nsIEditor::eStrip);
     1: 
     1:   if (NS_FAILED(result))
     1:   {
     1:     UNLOCK_DOC(this);
     1:     return result;
     1:   }
     1: 
     1:   // Now that we've actually deleted the selected content,
     1:   // check to see if our mExtent has changed, if so, then
     1:   // we have to create a new content iterator!
     1: 
     1:   if (origStartNode && origEndNode)
     1:   {
     1:     nsCOMPtr<nsIDOMNode> curStartNode, curEndNode;
108991:     int32_t curStartOffset = 0, curEndOffset = 0;
     1: 
     1:     result = GetRangeEndPoints(mExtent,
     1:                                getter_AddRefs(curStartNode), &curStartOffset,
     1:                                getter_AddRefs(curEndNode), &curEndOffset);
     1: 
     1:     if (NS_FAILED(result))
     1:     {
     1:       UNLOCK_DOC(this);
     1:       return result;
     1:     }
     1: 
     1:     if (origStartNode != curStartNode || origEndNode != curEndNode)
     1:     {
     1:       // The range has changed, so we need to create a new content
     1:       // iterator based on the new range.
     1: 
 20503:       nsCOMPtr<nsIContent> curContent;
     1: 
120052:       if (mIteratorStatus != nsTextServicesDocument::eIsDone) {
     1:         // The old iterator is still pointing to something valid,
 90153:         // so get its current node so we can restore it after we
     1:         // create the new iterator!
     1: 
120052:         curContent = mIterator->GetCurrentNode()
120052:                      ? mIterator->GetCurrentNode()->AsContent()
120052:                      : nullptr;
     1:       }
     1: 
     1:       // Create the new iterator.
     1: 
     1:       result = CreateContentIterator(mExtent, getter_AddRefs(mIterator));
     1: 
     1:       if (NS_FAILED(result))
     1:       {
     1:         UNLOCK_DOC(this);
     1:         return result;
     1:       }
     1: 
     1:       // Now make the new iterator point to the content node
     1:       // the old one was pointing at.
     1: 
     1:       if (curContent)
     1:       {
     1:         result = mIterator->PositionAt(curContent);
     1: 
     1:         if (NS_FAILED(result))
     1:           mIteratorStatus = eIsDone;
     1:         else
     1:           mIteratorStatus = eValid;
     1:       }
     1:     }
     1:   }
     1: 
     1:   entry = 0;
     1: 
     1:   // Move the caret to the end of the first valid entry.
     1:   // Start with mSelStartIndex since it may still be valid.
     1: 
     1:   for (i = mSelStartIndex; !entry && i >= 0; i--)
     1:   {
 27986:     entry = mOffsetTable[i];
     1: 
     1:     if (!entry->mIsValid)
     1:       entry = 0;
     1:     else
     1:     {
     1:       mSelStartIndex  = mSelEndIndex  = i;
     1:       mSelStartOffset = mSelEndOffset = entry->mStrOffset + entry->mLength;
     1:     }
     1:   }
     1: 
     1:   // If we still don't have a valid entry, move the caret
     1:   // to the next valid entry after the selection:
     1: 
108991:   for (i = mSelEndIndex; !entry && i < int32_t(mOffsetTable.Length()); i++)
 27986:   {
 27986:     entry = mOffsetTable[i];
     1: 
     1:     if (!entry->mIsValid)
     1:       entry = 0;
     1:     else
     1:     {
     1:       mSelStartIndex = mSelEndIndex = i;
     1:       mSelStartOffset = mSelEndOffset = entry->mStrOffset;
     1:     }
     1:   }
     1: 
     1:   if (entry)
     1:     result = SetSelection(mSelStartOffset, 0);
     1:   else
     1:   {
     1:     // Uuughh we have no valid offset entry to place our
     1:     // caret ... just mark the selection invalid.
     1: 
     1:     mSelStartIndex  = mSelEndIndex  = -1;
     1:     mSelStartOffset = mSelEndOffset = -1;
     1:   }
     1: 
     1:   // Now remove any invalid entries from the offset table.
     1: 
     1:   result = RemoveInvalidOffsetEntries();
     1: 
     1:   //**** KDEBUG ****
     1:   // printf("\n---- After Delete\n");
     1:   // printf("Sel: (%2d, %4d) (%2d, %4d)\n", mSelStartIndex, mSelStartOffset, mSelEndIndex, mSelEndOffset);
     1:   // PrintOffsetTable();
     1:   //**** KDEBUG ****
     1: 
     1:   UNLOCK_DOC(this);
     1: 
     1:   return result;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTextServicesDocument::InsertText(const nsString *aText)
     1: {
     1:   nsresult result = NS_OK;
     1: 
     1:   nsCOMPtr<nsIEditor> editor (do_QueryReferent(mEditor));
     1:   NS_ASSERTION(editor, "InsertText called without an editor present!"); 
     1: 
     1:   if (!editor || !SelectionIsValid())
     1:     return NS_ERROR_FAILURE;
     1: 
 43807:   NS_ENSURE_TRUE(aText, NS_ERROR_NULL_POINTER);
     1: 
     1:   // If the selection is not collapsed, we need to save
     1:   // off the selection offsets so we can restore the
     1:   // selection and delete the selected content after we've
     1:   // inserted the new text. This is necessary to try and
     1:   // retain as much of the original style of the content
     1:   // being deleted.
     1: 
 79445:   bool collapsedSelection = SelectionIsCollapsed();
108991:   int32_t savedSelOffset = mSelStartOffset;
108991:   int32_t savedSelLength = mSelEndOffset - mSelStartOffset;
     1: 
     1:   if (!collapsedSelection)
     1:   {
     1:     // Collapse to the start of the current selection
     1:     // for the insert!
     1: 
     1:     result = SetSelection(mSelStartOffset, 0);
     1: 
 43808:     NS_ENSURE_SUCCESS(result, result);
     1:   }
     1: 
     1: 
     1:   LOCK_DOC(this);
     1: 
     1:   result = editor->BeginTransaction();
     1: 
     1:   if (NS_FAILED(result))
     1:   {
     1:     UNLOCK_DOC(this);
     1:     return result;
     1:   }
     1: 
     1:   nsCOMPtr<nsIPlaintextEditor> textEditor (do_QueryInterface(editor, &result));
     1:   if (textEditor)
     1:     result = textEditor->InsertText(*aText);
     1: 
     1:   if (NS_FAILED(result))
     1:   {
     1:     editor->EndTransaction();
     1:     UNLOCK_DOC(this);
     1:     return result;
     1:   }
     1: 
     1:   //**** KDEBUG ****
     1:   // printf("\n---- Before Insert\n");
     1:   // printf("Sel: (%2d, %4d) (%2d, %4d)\n", mSelStartIndex, mSelStartOffset, mSelEndIndex, mSelEndOffset);
     1:   // PrintOffsetTable();
     1:   //**** KDEBUG ****
     1: 
108991:   int32_t strLength = aText->Length();
108991:   uint32_t i;
     1: 
     1:   nsCOMPtr<nsISelection> selection;
     1:   OffsetEntry *itEntry;
 27986:   OffsetEntry *entry = mOffsetTable[mSelStartIndex];
     1:   void *node         = entry->mNode;
     1: 
     1:   NS_ASSERTION((entry->mIsValid), "Invalid insertion point!");
     1: 
     1:   if (entry->mStrOffset == mSelStartOffset)
     1:   {
     1:     if (entry->mIsInsertedText)
     1:     {
     1:       // If the caret is in an inserted text offset entry,
     1:       // we simply insert the text at the end of the entry.
     1: 
     1:       entry->mLength += strLength;
     1:     }
     1:     else
     1:     {
     1:       // Insert an inserted text offset entry before the current
     1:       // entry!
     1: 
     1:       itEntry = new OffsetEntry(entry->mNode, entry->mStrOffset, strLength);
     1: 
     1:       if (!itEntry)
     1:       {
     1:         editor->EndTransaction();
     1:         UNLOCK_DOC(this);
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1:       }
     1: 
 80486:       itEntry->mIsInsertedText = true;
     1:       itEntry->mNodeOffset = entry->mNodeOffset;
     1: 
 27986:       if (!mOffsetTable.InsertElementAt(mSelStartIndex, itEntry))
     1:       {
     1:         editor->EndTransaction();
     1:         UNLOCK_DOC(this);
     1:         return NS_ERROR_FAILURE;
     1:       }
     1:     }
     1:   }
     1:   else if ((entry->mStrOffset + entry->mLength) == mSelStartOffset)
     1:   {
     1:     // We are inserting text at the end of the current offset entry.
     1:     // Look at the next valid entry in the table. If it's an inserted
 90153:     // text entry, add to its length and adjust its node offset. If
     1:     // it isn't, add a new inserted text entry.
     1: 
     1:     i       = mSelStartIndex + 1;
     1:     itEntry = 0;
     1: 
 27986:     if (mOffsetTable.Length() > i)
 27986:     {
 27986:       itEntry = mOffsetTable[i];
     1: 
     1:       if (!itEntry)
     1:       {
     1:         editor->EndTransaction();
     1:         UNLOCK_DOC(this);
     1:         return NS_ERROR_FAILURE;
     1:       }
     1: 
     1:       // Check if the entry is a match. If it isn't, set
     1:       // iEntry to zero.
     1: 
     1:       if (!itEntry->mIsInsertedText || itEntry->mStrOffset != mSelStartOffset)
     1:         itEntry = 0;
     1:     }
     1: 
     1:     if (!itEntry)
     1:     {
     1:       // We didn't find an inserted text offset entry, so
     1:       // create one.
     1: 
     1:       itEntry = new OffsetEntry(entry->mNode, mSelStartOffset, 0);
     1: 
     1:       if (!itEntry)
     1:       {
     1:         editor->EndTransaction();
     1:         UNLOCK_DOC(this);
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1:       }
     1: 
     1:       itEntry->mNodeOffset = entry->mNodeOffset + entry->mLength;
 80486:       itEntry->mIsInsertedText = true;
     1: 
 27986:       if (!mOffsetTable.InsertElementAt(i, itEntry))
     1:       {
     1:         delete itEntry;
     1:         return NS_ERROR_FAILURE;
     1:       }
     1:     }
     1: 
 90153:     // We have a valid inserted text offset entry. Update its
     1:     // length, adjust the selection indexes, and make sure the
     1:     // caret is properly placed!
     1: 
     1:     itEntry->mLength += strLength;
     1: 
     1:     mSelStartIndex = mSelEndIndex = i;
     1:           
     1:     result = mSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(selection));
     1: 
     1:     if (NS_FAILED(result))
     1:     {
     1:       editor->EndTransaction();
     1:       UNLOCK_DOC(this);
     1:       return result;
     1:     }
     1: 
     1:     result = selection->Collapse(itEntry->mNode, itEntry->mNodeOffset + itEntry->mLength);
     1:         
     1:     if (NS_FAILED(result))
     1:     {
     1:       editor->EndTransaction();
     1:       UNLOCK_DOC(this);
     1:       return result;
     1:     }
     1:   }
     1:   else if ((entry->mStrOffset + entry->mLength) > mSelStartOffset)
     1:   {
     1:     // We are inserting text into the middle of the current offset entry.
     1:     // split the current entry into two parts, then insert an inserted text
     1:     // entry between them!
     1: 
     1:     i = entry->mLength - (mSelStartOffset - entry->mStrOffset);
     1: 
     1:     result = SplitOffsetEntry(mSelStartIndex, i);
     1: 
     1:     if (NS_FAILED(result))
     1:     {
     1:       editor->EndTransaction();
     1:       UNLOCK_DOC(this);
     1:       return result;
     1:     }
     1: 
     1:     itEntry = new OffsetEntry(entry->mNode, mSelStartOffset, strLength);
     1: 
     1:     if (!itEntry)
     1:     {
     1:       editor->EndTransaction();
     1:       UNLOCK_DOC(this);
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1: 
 80486:     itEntry->mIsInsertedText = true;
     1:     itEntry->mNodeOffset     = entry->mNodeOffset + entry->mLength;
     1: 
 27986:     if (!mOffsetTable.InsertElementAt(mSelStartIndex + 1, itEntry))
     1:     {
     1:       editor->EndTransaction();
     1:       UNLOCK_DOC(this);
     1:       return NS_ERROR_FAILURE;
     1:     }
     1: 
     1:     mSelEndIndex = ++mSelStartIndex;
     1:   }
     1: 
     1:   // We've just finished inserting an inserted text offset entry.
     1:   // update all entries with the same mNode pointer that follow
     1:   // it in the table!
     1: 
 27986:   for (i = mSelStartIndex + 1; i < mOffsetTable.Length(); i++)
 27986:   {
 27986:     entry = mOffsetTable[i];
     1: 
     1:     if (entry->mNode == node)
     1:     {
     1:       if (entry->mIsValid)
     1:         entry->mNodeOffset += strLength;
     1:     }
     1:     else
     1:       break;
     1:   }
     1: 
     1:   //**** KDEBUG ****
     1:   // printf("\n---- After Insert\n");
     1:   // printf("Sel: (%2d, %4d) (%2d, %4d)\n", mSelStartIndex, mSelStartOffset, mSelEndIndex, mSelEndOffset);
     1:   // PrintOffsetTable();
     1:   //**** KDEBUG ****
     1: 
     1:   if (!collapsedSelection)
     1:   {
     1:     result = SetSelection(savedSelOffset, savedSelLength);
     1: 
     1:     if (NS_FAILED(result))
     1:     {
     1:       editor->EndTransaction();
     1:       UNLOCK_DOC(this);
     1:       return result;
     1:     }
     1: 
     1:     result = DeleteSelection();
     1:   
     1:     if (NS_FAILED(result))
     1:     {
     1:       editor->EndTransaction();
     1:       UNLOCK_DOC(this);
     1:       return result;
     1:     }
     1:   }
     1: 
     1:   result = editor->EndTransaction();
     1: 
     1:   UNLOCK_DOC(this);
     1: 
     1:   return result;
     1: }
     1: 
 43303: NS_IMETHODIMP
 43303: nsTextServicesDocument::DidInsertNode(nsIDOMNode *aNode,
     1:                                       nsIDOMNode *aParent,
108991:                                       int32_t     aPosition,
 43303:                                       nsresult    aResult)
     1: {
     1:   return NS_OK;
     1: }
     1: 
 43303: NS_IMETHODIMP
 43303: nsTextServicesDocument::DidDeleteNode(nsIDOMNode *aChild, nsresult aResult)
 43303: {
 43808:   NS_ENSURE_SUCCESS(aResult, NS_OK);
 43303: 
     1:   NS_ENSURE_TRUE(mIterator, NS_ERROR_FAILURE);
     1: 
     1:   //**** KDEBUG ****
     1:   // printf("** DeleteNode: 0x%.8x\n", aChild);
     1:   // fflush(stdout);
     1:   //**** KDEBUG ****
     1: 
     1:   LOCK_DOC(this);
     1: 
108991:   int32_t nodeIndex = 0;
 79445:   bool hasEntry = false;
     1:   OffsetEntry *entry;
     1: 
     1:   nsresult result = NodeHasOffsetEntry(&mOffsetTable, aChild, &hasEntry, &nodeIndex);
     1: 
     1:   if (NS_FAILED(result))
     1:   {
     1:     UNLOCK_DOC(this);
     1:     return result;
     1:   }
     1: 
     1:   if (!hasEntry)
     1:   {
     1:     // It's okay if the node isn't in the offset table, the
     1:     // editor could be cleaning house.
     1: 
     1:     UNLOCK_DOC(this);
     1:     return NS_OK;
     1:   }
     1: 
     1:   nsCOMPtr<nsIDOMNode> node = do_QueryInterface(mIterator->GetCurrentNode());
     1: 
     1:   if (node && node == aChild &&
     1:       mIteratorStatus != nsTextServicesDocument::eIsDone)
     1:   {
     1:     // XXX: This should never really happen because
     1:     // AdjustContentIterator() should have been called prior
     1:     // to the delete to try and position the iterator on the
     1:     // next valid text node in the offset table, and if there
     1:     // wasn't a next, it would've set mIteratorStatus to eIsDone.
     1: 
 31561:     NS_ERROR("DeleteNode called for current iterator node."); 
     1:   }
     1: 
108991:   int32_t tcount = mOffsetTable.Length();
     1: 
     1:   while (nodeIndex < tcount)
     1:   {
 27986:     entry = mOffsetTable[nodeIndex];
     1: 
     1:     if (!entry)
     1:     {
     1:       UNLOCK_DOC(this);
     1:       return NS_ERROR_FAILURE;
     1:     }
     1: 
     1:     if (entry->mNode == aChild)
     1:     {
 80486:       entry->mIsValid = false;
     1:     }
     1: 
     1:     nodeIndex++;
     1:   }
     1: 
     1:   UNLOCK_DOC(this);
     1: 
     1:   return NS_OK;
     1: }
     1: 
 43303: NS_IMETHODIMP
 43303: nsTextServicesDocument::DidSplitNode(nsIDOMNode *aExistingRightNode,
108991:                                      int32_t     aOffset,
 43303:                                      nsIDOMNode *aNewLeftNode,
 43303:                                      nsresult    aResult)
     1: {
     1:   //**** KDEBUG ****
     1:   // printf("** SplitNode: 0x%.8x  %d  0x%.8x\n", aExistingRightNode, aOffset, aNewLeftNode);
     1:   // fflush(stdout);
     1:   //**** KDEBUG ****
     1:   return NS_OK;
     1: }
     1: 
 43303: NS_IMETHODIMP
 43303: nsTextServicesDocument::DidJoinNodes(nsIDOMNode  *aLeftNode,
     1:                                      nsIDOMNode  *aRightNode,
 43303:                                      nsIDOMNode  *aParent,
 43303:                                      nsresult     aResult)
 43303: {
 43808:   NS_ENSURE_SUCCESS(aResult, NS_OK);
 43303: 
108991:   int32_t i;
108991:   uint16_t type;
     1:   nsresult result;
     1: 
     1:   //**** KDEBUG ****
     1:   // printf("** JoinNodes: 0x%.8x  0x%.8x  0x%.8x\n", aLeftNode, aRightNode, aParent);
     1:   // fflush(stdout);
     1:   //**** KDEBUG ****
     1: 
 95587:   // Make sure that both nodes are text nodes -- otherwise we don't care.
     1: 
     1:   result = aLeftNode->GetNodeType(&type);
106878:   NS_ENSURE_SUCCESS(result, NS_OK);
 95587:   if (nsIDOMNode::TEXT_NODE != type) {
 95587:     return NS_OK;
     1:   }
     1: 
     1:   result = aRightNode->GetNodeType(&type);
106878:   NS_ENSURE_SUCCESS(result, NS_OK);
 95587:   if (nsIDOMNode::TEXT_NODE != type) {
 95587:     return NS_OK;
     1:   }
     1: 
     1:   // Note: The editor merges the contents of the left node into the
     1:   //       contents of the right.
     1: 
108991:   int32_t leftIndex = 0;
108991:   int32_t rightIndex = 0;
 79445:   bool leftHasEntry = false;
 79445:   bool rightHasEntry = false;
     1: 
     1:   result = NodeHasOffsetEntry(&mOffsetTable, aLeftNode, &leftHasEntry, &leftIndex);
     1: 
 43808:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   if (!leftHasEntry)
     1:   {
  9473:     // It's okay if the node isn't in the offset table, the
  9473:     // editor could be cleaning house.
  9473:     return NS_OK;
     1:   }
     1: 
     1:   result = NodeHasOffsetEntry(&mOffsetTable, aRightNode, &rightHasEntry, &rightIndex);
     1: 
 43808:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   if (!rightHasEntry)
     1:   {
  9473:     // It's okay if the node isn't in the offset table, the
  9473:     // editor could be cleaning house.
  9473:     return NS_OK;
     1:   }
     1: 
     1:   NS_ASSERTION(leftIndex < rightIndex, "Indexes out of order.");
     1: 
     1:   if (leftIndex > rightIndex)
     1:   {
     1:     // Don't know how to handle this situation.
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   LOCK_DOC(this);
     1: 
 27986:   OffsetEntry *entry = mOffsetTable[rightIndex];
     1:   NS_ASSERTION(entry->mNodeOffset == 0, "Unexpected offset value for rightIndex.");
     1: 
     1:   // Run through the table and change all entries referring to
     1:   // the left node so that they now refer to the right node:
     1: 
     1:   nsAutoString str;
     1:   result = aLeftNode->GetNodeValue(str);
108991:   int32_t nodeLength = str.Length();
     1: 
     1:   for (i = leftIndex; i < rightIndex; i++)
     1:   {
 27986:     entry = mOffsetTable[i];
     1: 
     1:     if (entry->mNode == aLeftNode)
     1:     {
     1:       if (entry->mIsValid)
     1:         entry->mNode = aRightNode;
     1:     }
     1:     else
     1:       break;
     1:   }
     1: 
     1:   // Run through the table and adjust the node offsets
     1:   // for all entries referring to the right node.
     1: 
108991:   for (i = rightIndex; i < int32_t(mOffsetTable.Length()); i++)
 27986:   {
 27986:     entry = mOffsetTable[i];
     1: 
     1:     if (entry->mNode == aRightNode)
     1:     {
     1:       if (entry->mIsValid)
     1:         entry->mNodeOffset += nodeLength;
     1:     }
     1:     else
     1:       break;
     1:   }
     1: 
     1:   // Now check to see if the iterator is pointing to the
     1:   // left node. If it is, make it point to the right node!
     1: 
     1:   nsCOMPtr<nsIContent> leftContent = do_QueryInterface(aLeftNode);
     1:   nsCOMPtr<nsIContent> rightContent = do_QueryInterface(aRightNode);
     1: 
     1:   if (!leftContent || !rightContent)
     1:   {
     1:     UNLOCK_DOC(this);
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   if (mIterator->GetCurrentNode() == leftContent)
     1:     result = mIterator->PositionAt(rightContent);
     1: 
     1:   UNLOCK_DOC(this);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsTextServicesDocument::CreateContentIterator(nsIDOMRange *aRange, nsIContentIterator **aIterator)
     1: {
     1:   nsresult result;
     1: 
 43807:   NS_ENSURE_TRUE(aRange && aIterator, NS_ERROR_NULL_POINTER);
     1: 
     1:   *aIterator = 0;
     1: 
     1:   // Create a nsFilteredContentIterator
     1:   // This class wraps the ContentIterator in order to give itself a chance 
     1:   // to filter out certain content nodes
     1:   nsFilteredContentIterator* filter = new nsFilteredContentIterator(mTxtSvcFilter);
  3233:   *aIterator = static_cast<nsIContentIterator *>(filter);
     1:   if (*aIterator) {
     1:     NS_IF_ADDREF(*aIterator);
     1:     result = filter ? NS_OK : NS_ERROR_FAILURE;
     1:   } else {
     1:     delete filter;
     1:     result = NS_ERROR_FAILURE;
     1:   }
     1:   NS_ENSURE_SUCCESS(result, result);
     1: 
 43807:   NS_ENSURE_TRUE(*aIterator, NS_ERROR_NULL_POINTER);
     1: 
     1:   result = (*aIterator)->Init(aRange);
     1: 
     1:   if (NS_FAILED(result))
     1:   {
     1:     NS_RELEASE((*aIterator));
     1:     *aIterator = 0;
     1:     return result;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsTextServicesDocument::GetDocumentContentRootNode(nsIDOMNode **aNode)
     1: {
     1:   nsresult result;
     1: 
 43807:   NS_ENSURE_TRUE(aNode, NS_ERROR_NULL_POINTER);
     1: 
     1:   *aNode = 0;
     1: 
 43807:   NS_ENSURE_TRUE(mDOMDocument, NS_ERROR_FAILURE);
     1: 
     1:   nsCOMPtr<nsIDOMHTMLDocument> htmlDoc = do_QueryInterface(mDOMDocument);
     1: 
     1:   if (htmlDoc)
     1:   {
     1:     // For HTML documents, the content root node is the body.
     1: 
     1:     nsCOMPtr<nsIDOMHTMLElement> bodyElement;
     1: 
     1:     result = htmlDoc->GetBody(getter_AddRefs(bodyElement));
     1: 
 43808:     NS_ENSURE_SUCCESS(result, result);
     1: 
 43807:     NS_ENSURE_TRUE(bodyElement, NS_ERROR_FAILURE);
     1: 
     1:     result = bodyElement->QueryInterface(NS_GET_IID(nsIDOMNode), (void **)aNode);
     1:   }
     1:   else
     1:   {
     1:     // For non-HTML documents, the content root node will be the document element.
     1: 
     1:     nsCOMPtr<nsIDOMElement> docElement;
     1: 
     1:     result = mDOMDocument->GetDocumentElement(getter_AddRefs(docElement));
     1: 
 43808:     NS_ENSURE_SUCCESS(result, result);
     1: 
 43807:     NS_ENSURE_TRUE(docElement, NS_ERROR_FAILURE);
     1: 
     1:     result = docElement->QueryInterface(NS_GET_IID(nsIDOMNode), (void **)aNode);
     1:   }
     1: 
     1:   return result;
     1: }
     1: 
     1: nsresult
     1: nsTextServicesDocument::CreateDocumentContentRange(nsIDOMRange **aRange)
     1: {
 87303:   *aRange = NULL;
     1: 
     1:   nsCOMPtr<nsIDOMNode> node;
 87303:   nsresult rv = GetDocumentContentRootNode(getter_AddRefs(node));
 87303:   NS_ENSURE_SUCCESS(rv, rv);
 43807:   NS_ENSURE_TRUE(node, NS_ERROR_NULL_POINTER);
     1: 
 87303:   nsRefPtr<nsRange> range = new nsRange();
 87303: 
 87303:   rv = range->SelectNodeContents(node);
 87303:   NS_ENSURE_SUCCESS(rv, rv);
 87303: 
 87303:   range.forget(aRange);
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
108991: nsTextServicesDocument::CreateDocumentContentRootToNodeOffsetRange(nsIDOMNode *aParent, int32_t aOffset, bool aToStart, nsIDOMRange **aRange)
     1: {
 43807:   NS_ENSURE_TRUE(aParent && aRange, NS_ERROR_NULL_POINTER);
     1: 
     1:   *aRange = 0;
     1: 
     1:   NS_ASSERTION(aOffset >= 0, "Invalid offset!");
     1: 
     1:   if (aOffset < 0)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   nsCOMPtr<nsIDOMNode> bodyNode; 
 87303:   nsresult rv = GetDocumentContentRootNode(getter_AddRefs(bodyNode));
 87303:   NS_ENSURE_SUCCESS(rv, rv);
 43807:   NS_ENSURE_TRUE(bodyNode, NS_ERROR_NULL_POINTER);
     1: 
     1:   nsCOMPtr<nsIDOMNode> startNode;
     1:   nsCOMPtr<nsIDOMNode> endNode;
108991:   int32_t startOffset, endOffset;
     1: 
 87303:   if (aToStart) {
     1:     // The range should begin at the start of the document
     1:     // and extend up until (aParent, aOffset).
     1: 
     1:     startNode   = bodyNode;
     1:     startOffset = 0;
 87303:     endNode     = aParent;
     1:     endOffset   = aOffset;
 87303:   } else {
     1:     // The range should begin at (aParent, aOffset) and
     1:     // extend to the end of the document.
     1: 
 87303:     startNode   = aParent;
     1:     startOffset = aOffset;
     1:     endNode     = bodyNode;
 97763: 
 97763:     nsCOMPtr<nsINode> body = do_QueryInterface(bodyNode);
108991:     endOffset = body ? int32_t(body->GetChildCount()) : 0;
     1:   }
     1: 
 87303:   return nsRange::CreateRange(startNode, startOffset, endNode, endOffset,
 87303:                               aRange);
     1: }
     1: 
     1: nsresult
     1: nsTextServicesDocument::CreateDocumentContentIterator(nsIContentIterator **aIterator)
     1: {
     1:   nsresult result;
     1: 
 43807:   NS_ENSURE_TRUE(aIterator, NS_ERROR_NULL_POINTER);
     1: 
     1:   nsCOMPtr<nsIDOMRange> range;
     1: 
     1:   result = CreateDocumentContentRange(getter_AddRefs(range));
     1: 
 43808:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   result = CreateContentIterator(range, aIterator);
     1: 
     1:   return result;
     1: }
     1: 
     1: nsresult
     1: nsTextServicesDocument::AdjustContentIterator()
     1: {
     1:   nsresult result = NS_OK;
     1: 
 43807:   NS_ENSURE_TRUE(mIterator, NS_ERROR_FAILURE);
     1: 
     1:   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(mIterator->GetCurrentNode()));
     1: 
 43807:   NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
     1: 
     1:   nsIDOMNode *nodePtr = node.get();
108991:   int32_t tcount      = mOffsetTable.Length();
     1: 
     1:   nsIDOMNode *prevValidNode = 0;
     1:   nsIDOMNode *nextValidNode = 0;
 79445:   bool foundEntry = false;
     1:   OffsetEntry *entry;
     1: 
108991:   for (int32_t i = 0; i < tcount && !nextValidNode; i++)
     1:   {
 27986:     entry = mOffsetTable[i];
     1: 
 43807:     NS_ENSURE_TRUE(entry, NS_ERROR_FAILURE);
     1: 
     1:     if (entry->mNode == nodePtr)
     1:     {
     1:       if (entry->mIsValid)
     1:       {
     1:         // The iterator is still pointing to something valid!
     1:         // Do nothing!
     1: 
     1:         return NS_OK;
     1:       }
     1:       else
     1:       {
     1:         // We found an invalid entry that points to
     1:         // the current iterator node. Stop looking for
     1:         // a previous valid node!
     1: 
 80486:         foundEntry = true;
     1:       }
     1:     }
     1: 
     1:     if (entry->mIsValid)
     1:     {
     1:       if (!foundEntry)
     1:         prevValidNode = entry->mNode;
     1:       else
     1:         nextValidNode = entry->mNode;
     1:     }
     1:   }
     1: 
     1:   nsCOMPtr<nsIContent> content;
     1: 
     1:   if (prevValidNode)
     1:     content = do_QueryInterface(prevValidNode);
     1:   else if (nextValidNode)
     1:     content = do_QueryInterface(nextValidNode);
     1: 
     1:   if (content)
     1:   {
     1:     result = mIterator->PositionAt(content);
     1: 
     1:     if (NS_FAILED(result))
     1:       mIteratorStatus = eIsDone;
     1:     else
     1:       mIteratorStatus = eValid;
     1: 
     1:     return result;
     1:   }
     1: 
     1:   // If we get here, there aren't any valid entries
     1:   // in the offset table! Try to position the iterator
     1:   // on the next text block first, then previous if
     1:   // one doesn't exist!
     1: 
     1:   if (mNextTextBlock)
     1:   {
     1:     result = mIterator->PositionAt(mNextTextBlock);
     1: 
     1:     if (NS_FAILED(result))
     1:     {
     1:       mIteratorStatus = eIsDone;
     1:       return result;
     1:     }
     1: 
     1:     mIteratorStatus = eNext;
     1:   }
     1:   else if (mPrevTextBlock)
     1:   {
     1:     result = mIterator->PositionAt(mPrevTextBlock);
     1: 
     1:     if (NS_FAILED(result))
     1:     {
     1:       mIteratorStatus = eIsDone;
     1:       return result;
     1:     }
     1: 
     1:     mIteratorStatus = ePrev;
     1:   }
     1:   else
     1:     mIteratorStatus = eIsDone;
     1: 
     1:   return NS_OK;
     1: }
     1: 
 79445: bool
     1: nsTextServicesDocument::DidSkip(nsIContentIterator* aFilteredIter)
     1: {
     1:   // We can assume here that the Iterator is a nsFilteredContentIterator because
     1:   // all the iterator are created in CreateContentIterator which create a 
     1:   // nsFilteredContentIterator
     1:   // So if the iterator bailed on one of the "filtered" content nodes then we 
 80486:   // consider that to be a block and bail with true
     1:   if (aFilteredIter) {
  3233:     nsFilteredContentIterator* filter = static_cast<nsFilteredContentIterator *>(aFilteredIter);
     1:     if (filter && filter->DidSkip()) {
 80486:       return true;
 80486:     }
 80486:   }
 80486:   return false;
     1: }
     1: 
     1: void
     1: nsTextServicesDocument::ClearDidSkip(nsIContentIterator* aFilteredIter)
     1: {
     1:   // Clear filter's skip flag
     1:   if (aFilteredIter) {
  3233:     nsFilteredContentIterator* filter = static_cast<nsFilteredContentIterator *>(aFilteredIter);
     1:     filter->ClearDidSkip();
     1:   }
     1: }
     1: 
 79445: bool
     1: nsTextServicesDocument::IsBlockNode(nsIContent *aContent)
     1: {
 53740:   if (!aContent) {
 53740:     NS_ERROR("How did a null pointer get passed to IsBlockNode?");
 80486:     return false;
 53740:   }
 53740: 
     1:   nsIAtom *atom = aContent->Tag();
     1: 
     1:   return (sAAtom       != atom &&
     1:           sAddressAtom != atom &&
     1:           sBigAtom     != atom &&
     1:           sBlinkAtom   != atom &&
     1:           sBAtom       != atom &&
     1:           sCiteAtom    != atom &&
     1:           sCodeAtom    != atom &&
     1:           sDfnAtom     != atom &&
     1:           sEmAtom      != atom &&
     1:           sFontAtom    != atom &&
     1:           sIAtom       != atom &&
     1:           sKbdAtom     != atom &&
     1:           sKeygenAtom  != atom &&
     1:           sNobrAtom    != atom &&
     1:           sSAtom       != atom &&
     1:           sSampAtom    != atom &&
     1:           sSmallAtom   != atom &&
     1:           sSpacerAtom  != atom &&
     1:           sSpanAtom    != atom &&
     1:           sStrikeAtom  != atom &&
     1:           sStrongAtom  != atom &&
     1:           sSubAtom     != atom &&
     1:           sSupAtom     != atom &&
     1:           sTtAtom      != atom &&
     1:           sUAtom       != atom &&
     1:           sVarAtom     != atom &&
     1:           sWbrAtom     != atom);
     1: }
     1: 
 79445: bool
     1: nsTextServicesDocument::HasSameBlockNodeParent(nsIContent *aContent1, nsIContent *aContent2)
     1: {
     1:   nsIContent* p1 = aContent1->GetParent();
     1:   nsIContent* p2 = aContent2->GetParent();
     1: 
     1:   // Quick test:
     1: 
     1:   if (p1 == p2)
 80486:     return true;
     1: 
     1:   // Walk up the parent hierarchy looking for closest block boundary node:
     1: 
     1:   while (p1 && !IsBlockNode(p1))
     1:   {
     1:     p1 = p1->GetParent();
     1:   }
     1: 
     1:   while (p2 && !IsBlockNode(p2))
     1:   {
     1:     p2 = p2->GetParent();
     1:   }
     1: 
     1:   return p1 == p2;
     1: }
     1: 
 79445: bool
     1: nsTextServicesDocument::IsTextNode(nsIContent *aContent)
     1: {
 80486:   NS_ENSURE_TRUE(aContent, false);
 87303:   return nsIDOMNode::TEXT_NODE == aContent->NodeType();
     1: }
     1: 
 79445: bool
     1: nsTextServicesDocument::IsTextNode(nsIDOMNode *aNode)
     1: {
 80486:   NS_ENSURE_TRUE(aNode, false);
     1: 
 87303:   nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
 87303:   return IsTextNode(content);
     1: }
     1: 
     1: nsresult
108991: nsTextServicesDocument::SetSelectionInternal(int32_t aOffset, int32_t aLength, bool aDoUpdate)
     1: {
     1:   nsresult result = NS_OK;
     1: 
 43807:   NS_ENSURE_TRUE(mSelCon && aOffset >= 0 && aLength >= 0, NS_ERROR_FAILURE);
     1: 
     1:   nsIDOMNode *sNode = 0, *eNode = 0;
108991:   int32_t i, sOffset = 0, eOffset = 0;
     1:   OffsetEntry *entry;
     1: 
     1:   // Find start of selection in node offset terms:
     1: 
108991:   for (i = 0; !sNode && i < int32_t(mOffsetTable.Length()); i++)
 27986:   {
 27986:     entry = mOffsetTable[i];
     1:     if (entry->mIsValid)
     1:     {
     1:       if (entry->mIsInsertedText)
     1:       {
     1:         // Caret can only be placed at the end of an
     1:         // inserted text offset entry, if the offsets
     1:         // match exactly!
     1: 
     1:         if (entry->mStrOffset == aOffset)
     1:         {
     1:           sNode   = entry->mNode;
     1:           sOffset = entry->mNodeOffset + entry->mLength;
     1:         }
     1:       }
     1:       else if (aOffset >= entry->mStrOffset)
     1:       {
 79445:         bool foundEntry = false;
108991:         int32_t strEndOffset = entry->mStrOffset + entry->mLength;
     1: 
     1:         if (aOffset < strEndOffset)
 80486:           foundEntry = true;
     1:         else if (aOffset == strEndOffset)
     1:         {
     1:           // Peek after this entry to see if we have any
     1:           // inserted text entries belonging to the same
     1:           // entry->mNode. If so, we have to place the selection
     1:           // after it!
     1: 
108991:           if ((i+1) < int32_t(mOffsetTable.Length()))
 27986:           {
 27986:             OffsetEntry *nextEntry = mOffsetTable[i+1];
     1: 
     1:             if (!nextEntry->mIsValid || nextEntry->mStrOffset != aOffset)
     1:             {
     1:               // Next offset entry isn't an exact match, so we'll
     1:               // just use the current entry.
 80486:               foundEntry = true;
     1:             }
     1:           }
     1:         }
     1: 
     1:         if (foundEntry)
     1:         {
     1:           sNode   = entry->mNode;
     1:           sOffset = entry->mNodeOffset + aOffset - entry->mStrOffset;
     1:         }
     1:       }
     1: 
     1:       if (sNode)
     1:       {
     1:         mSelStartIndex  = i;
     1:         mSelStartOffset = aOffset;
     1:       }
     1:     }
     1:   }
     1: 
 43807:   NS_ENSURE_TRUE(sNode, NS_ERROR_FAILURE);
     1: 
     1:   // XXX: If we ever get a SetSelection() method in nsIEditor, we should
     1:   //      use it.
     1: 
     1:   nsCOMPtr<nsISelection> selection;
     1: 
     1:   if (aDoUpdate)
     1:   {
     1:     result = mSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(selection));
     1: 
 43808:     NS_ENSURE_SUCCESS(result, result);
     1: 
     1:     result = selection->Collapse(sNode, sOffset);
     1: 
 43808:     NS_ENSURE_SUCCESS(result, result);
     1:    }
     1: 
     1:   if (aLength <= 0)
     1:   {
     1:     // We have a collapsed selection. (Caret)
     1: 
     1:     mSelEndIndex  = mSelStartIndex;
     1:     mSelEndOffset = mSelStartOffset;
     1: 
     1:    //**** KDEBUG ****
     1:    // printf("\n* Sel: (%2d, %4d) (%2d, %4d)\n", mSelStartIndex, mSelStartOffset, mSelEndIndex, mSelEndOffset);
     1:    //**** KDEBUG ****
     1: 
     1:     return NS_OK;
     1:   }
     1: 
     1:   // Find the end of the selection in node offset terms:
     1: 
108991:   int32_t endOffset = aOffset + aLength;
     1: 
 27986:   for (i = mOffsetTable.Length() - 1; !eNode && i >= 0; i--)
 27986:   {
 27986:     entry = mOffsetTable[i];
     1:     
     1:     if (entry->mIsValid)
     1:     {
     1:       if (entry->mIsInsertedText)
     1:       {
     1:         if (entry->mStrOffset == eOffset)
     1:         {
     1:           // If the selection ends on an inserted text offset entry,
     1:           // the selection includes the entire entry!
     1: 
     1:           eNode   = entry->mNode;
     1:           eOffset = entry->mNodeOffset + entry->mLength;
     1:         }
     1:       }
     1:       else if (endOffset >= entry->mStrOffset && endOffset <= entry->mStrOffset + entry->mLength)
     1:       {
     1:         eNode   = entry->mNode;
     1:         eOffset = entry->mNodeOffset + endOffset - entry->mStrOffset;
     1:       }
     1: 
     1:       if (eNode)
     1:       {
     1:         mSelEndIndex  = i;
     1:         mSelEndOffset = endOffset;
     1:       }
     1:     }
     1:   }
     1: 
     1:   if (aDoUpdate && eNode)
     1:   {
     1:     result = selection->Extend(eNode, eOffset);
     1: 
 43808:     NS_ENSURE_SUCCESS(result, result);
     1:   }
     1: 
     1:   //**** KDEBUG ****
     1:   // printf("\n * Sel: (%2d, %4d) (%2d, %4d)\n", mSelStartIndex, mSelStartOffset, mSelEndIndex, mSelEndOffset);
     1:   //**** KDEBUG ****
     1: 
     1:   return result;
     1: }
     1: 
     1: nsresult
108991: nsTextServicesDocument::GetSelection(nsITextServicesDocument::TSDBlockSelectionStatus *aSelStatus, int32_t *aSelOffset, int32_t *aSelLength)
     1: {
     1:   nsresult result;
     1: 
 43807:   NS_ENSURE_TRUE(aSelStatus && aSelOffset && aSelLength, NS_ERROR_NULL_POINTER);
     1: 
     1:   *aSelStatus = nsITextServicesDocument::eBlockNotFound;
     1:   *aSelOffset = -1;
     1:   *aSelLength = -1;
     1: 
 43807:   NS_ENSURE_TRUE(mDOMDocument && mSelCon, NS_ERROR_FAILURE);
     1: 
     1:   if (mIteratorStatus == nsTextServicesDocument::eIsDone)
     1:     return NS_OK;
     1: 
     1:   nsCOMPtr<nsISelection> selection;
 79445:   bool isCollapsed;
     1: 
     1:   result = mSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(selection));
     1: 
 43808:   NS_ENSURE_SUCCESS(result, result);
     1: 
 43807:   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
     1: 
     1:   result = selection->GetIsCollapsed(&isCollapsed);
     1: 
 43808:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   // XXX: If we expose this method publicly, we need to
     1:   //      add LOCK_DOC/UNLOCK_DOC calls!
     1: 
     1:   // LOCK_DOC(this);
     1: 
     1:   if (isCollapsed)
     1:     result = GetCollapsedSelection(aSelStatus, aSelOffset, aSelLength);
     1:   else
     1:     result = GetUncollapsedSelection(aSelStatus, aSelOffset, aSelLength);
     1: 
     1:   // UNLOCK_DOC(this);
     1: 
     1:   return result;
     1: }
     1: 
     1: nsresult
108991: nsTextServicesDocument::GetCollapsedSelection(nsITextServicesDocument::TSDBlockSelectionStatus *aSelStatus, int32_t *aSelOffset, int32_t *aSelLength)
     1: {
     1:   nsCOMPtr<nsISelection> selection;
101126:   nsresult result = mSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(selection));
 43808:   NS_ENSURE_SUCCESS(result, result);
 43807:   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
     1: 
     1:   // The calling function should have done the GetIsCollapsed()
     1:   // check already. Just assume it's collapsed!
     1:   *aSelStatus = nsITextServicesDocument::eBlockOutside;
     1:   *aSelOffset = *aSelLength = -1;
     1: 
108991:   int32_t tableCount = mOffsetTable.Length();
     1: 
     1:   if (tableCount == 0)
     1:     return NS_OK;
     1: 
     1:   // Get pointers to the first and last offset entries
     1:   // in the table.
     1: 
101126:   OffsetEntry* eStart = mOffsetTable[0];
101126:   OffsetEntry* eEnd;
     1:   if (tableCount > 1)
 27986:     eEnd = mOffsetTable[tableCount - 1];
     1:   else
     1:     eEnd = eStart;
     1: 
108991:   int32_t eStartOffset = eStart->mNodeOffset;
108991:   int32_t eEndOffset   = eEnd->mNodeOffset + eEnd->mLength;
101126: 
101126:   nsCOMPtr<nsIDOMRange> range;
     1:   result = selection->GetRangeAt(0, getter_AddRefs(range));
 43808:   NS_ENSURE_SUCCESS(result, result);
     1: 
101126:   nsCOMPtr<nsIDOMNode> domParent;
101126:   result = range->GetStartContainer(getter_AddRefs(domParent));
 43808:   NS_ENSURE_SUCCESS(result, result);
     1: 
101126:   nsCOMPtr<nsINode> parent = do_QueryInterface(domParent);
101126:   MOZ_ASSERT(parent);
101126: 
108991:   int32_t offset;
     1:   result = range->GetStartOffset(&offset);
 43808:   NS_ENSURE_SUCCESS(result, result);
     1: 
108991:   int32_t e1s1 = nsContentUtils::ComparePoints(eStart->mNode, eStartOffset,
101126:                                                domParent, offset);
108991:   int32_t e2s1 = nsContentUtils::ComparePoints(eEnd->mNode, eEndOffset,
101126:                                                domParent, offset);
101126: 
101126:   if (e1s1 > 0 || e2s1 < 0) {
101126:     // We're done if the caret is outside the current text block.
     1:     return NS_OK;
     1:   }
     1: 
101126:   if (parent->NodeType() == nsIDOMNode::TEXT_NODE) {
     1:     // Good news, the caret is in a text node. Look
     1:     // through the offset table for the entry that
 90153:     // matches its parent and offset.
     1: 
108991:     for (int32_t i = 0; i < tableCount; i++) {
101126:       OffsetEntry* entry = mOffsetTable[i];
 43807:       NS_ENSURE_TRUE(entry, NS_ERROR_FAILURE);
     1: 
101126:       if (entry->mNode == domParent.get() &&
     1:           entry->mNodeOffset <= offset && offset <= (entry->mNodeOffset + entry->mLength))
     1:       {
     1:         *aSelStatus = nsITextServicesDocument::eBlockContains;
     1:         *aSelOffset = entry->mStrOffset + (offset - entry->mNodeOffset);
     1:         *aSelLength = 0;
     1: 
     1:         return NS_OK;
     1:       }
     1:     }
     1: 
     1:     // If we get here, we didn't find a text node entry
     1:     // in our offset table that matched.
     1: 
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   // The caret is in our text block, but it's positioned in some
     1:   // non-text node (ex. <b>). Create a range based on the start
     1:   // and end of the text block, then create an iterator based on
 90153:   // this range, with its initial position set to the closest
     1:   // child of this non-text node. Then look for the closest text
     1:   // node.
     1: 
101126:   result = CreateRange(eStart->mNode, eStartOffset, eEnd->mNode, eEndOffset, getter_AddRefs(range));
101126:   NS_ENSURE_SUCCESS(result, result);
101126: 
     1:   nsCOMPtr<nsIContentIterator> iter;
101126:   result = CreateContentIterator(range, getter_AddRefs(iter));
 43808:   NS_ENSURE_SUCCESS(result, result);
     1: 
101126:   nsIContent* saveNode;
101126:   if (parent->HasChildren()) {
     1:     // XXX: We need to make sure that all of parent's
     1:     //      children are in the text block.
     1: 
     1:     // If the parent has children, position the iterator
     1:     // on the child that is to the left of the offset.
     1: 
108991:     uint32_t childIndex = (uint32_t)offset;
     1: 
101126:     if (childIndex > 0) {
108991:       uint32_t numChildren = parent->GetChildCount();
101126:       NS_ASSERTION(childIndex <= numChildren, "Invalid selection offset!");
101126: 
101126:       if (childIndex > numChildren) {
101126:         childIndex = numChildren;
101126:       }
101126: 
101126:       childIndex -= 1;
101126:     }
101126: 
101126:     nsIContent* content = parent->GetChildAt(childIndex);
101126:     NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
101126: 
101126:     result = iter->PositionAt(content);
 43808:     NS_ENSURE_SUCCESS(result, result);
     1: 
101126:     saveNode = content;
101126:   } else {
     1:     // The parent has no children, so position the iterator
     1:     // on the parent.
101686:     NS_ENSURE_TRUE(parent->IsContent(), NS_ERROR_FAILURE);
101686:     nsCOMPtr<nsIContent> content = parent->AsContent();
     1: 
     1:     result = iter->PositionAt(content);
 43808:     NS_ENSURE_SUCCESS(result, result);
     1: 
101126:     saveNode = content;
     1:   }
     1: 
     1:   // Now iterate to the left, towards the beginning of
     1:   // the text block, to find the first text node you
     1:   // come across.
     1: 
106838:   nsIContent* node = nullptr;
101126:   while (!iter->IsDone()) {
101126:     nsINode* current = iter->GetCurrentNode();
101126:     if (current->NodeType() == nsIDOMNode::TEXT_NODE) {
101126:       node = static_cast<nsIContent*>(current);
     1:       break;
     1:     }
     1: 
     1:     iter->Prev();
     1:   }
     1: 
101126:   if (node) {
     1:     // We found a node, now set the offset to the end
     1:     // of the text node.
101126:     offset = node->TextLength();
101126:   } else {
     1:     // We should never really get here, but I'm paranoid.
     1: 
     1:     // We didn't find a text node above, so iterate to
     1:     // the right, towards the end of the text block, looking
     1:     // for a text node.
     1: 
101126:     result = iter->PositionAt(saveNode);
 43808:     NS_ENSURE_SUCCESS(result, result);
101126: 
106838:     node = nullptr;
101126:     while (!iter->IsDone()) {
101126:       nsINode* current = iter->GetCurrentNode();
101126: 
101126:       if (current->NodeType() == nsIDOMNode::TEXT_NODE) {
101126:         node = static_cast<nsIContent*>(current);
101126:         break;
101126:       }
101126: 
101126:       iter->Next();
101126:     }
     1: 
 43807:     NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
     1: 
     1:     // We found a text node, so set the offset to
101126:     // the beginning of the node.
     1: 
     1:     offset = 0;
     1:   }
     1: 
108991:   for (int32_t i = 0; i < tableCount; i++) {
101126:     OffsetEntry* entry = mOffsetTable[i];
 43807:     NS_ENSURE_TRUE(entry, NS_ERROR_FAILURE);
     1: 
101126:     if (entry->mNode == node->AsDOMNode() &&
     1:         entry->mNodeOffset <= offset && offset <= (entry->mNodeOffset + entry->mLength))
     1:     {
     1:       *aSelStatus = nsITextServicesDocument::eBlockContains;
     1:       *aSelOffset = entry->mStrOffset + (offset - entry->mNodeOffset);
     1:       *aSelLength = 0;
     1: 
     1:       // Now move the caret so that it is actually in the text node.
     1:       // We do this to keep things in sync.
     1:       //
     1:       // In most cases, the user shouldn't see any movement in the caret
     1:       // on screen.
     1: 
 80486:       result = SetSelectionInternal(*aSelOffset, *aSelLength, true);
     1: 
     1:       return result;
     1:     }
     1:   }
     1: 
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
     1: nsresult
108991: nsTextServicesDocument::GetUncollapsedSelection(nsITextServicesDocument::TSDBlockSelectionStatus *aSelStatus, int32_t *aSelOffset, int32_t *aSelLength)
     1: {
     1:   nsresult result;
     1: 
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsCOMPtr<nsIDOMRange> range;
     1:   OffsetEntry *entry;
     1: 
     1:   result = mSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(selection));
     1: 
 43808:   NS_ENSURE_SUCCESS(result, result);
     1: 
 43807:   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
     1: 
     1:   // It is assumed that the calling function has made sure that the
     1:   // selection is not collapsed, and that the input params to this
     1:   // method are initialized to some defaults.
     1: 
     1:   nsCOMPtr<nsIDOMNode> startParent, endParent;
108991:   int32_t startOffset, endOffset;
108991:   int32_t rangeCount, tableCount, i;
108991:   int32_t e1s1, e1s2, e2s1, e2s2;
     1: 
     1:   OffsetEntry *eStart, *eEnd;
108991:   int32_t eStartOffset, eEndOffset;
     1: 
 27986:   tableCount = mOffsetTable.Length();
     1: 
     1:   // Get pointers to the first and last offset entries
     1:   // in the table.
     1: 
 27986:   eStart = mOffsetTable[0];
     1: 
     1:   if (tableCount > 1)
 27986:     eEnd = mOffsetTable[tableCount - 1];
     1:   else
     1:     eEnd = eStart;
     1: 
     1:   eStartOffset = eStart->mNodeOffset;
     1:   eEndOffset   = eEnd->mNodeOffset + eEnd->mLength;
     1: 
     1:   result = selection->GetRangeCount(&rangeCount);
     1: 
 43808:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   // Find the first range in the selection that intersects
     1:   // the current text block.
     1: 
     1:   for (i = 0; i < rangeCount; i++)
     1:   {
     1:     result = selection->GetRangeAt(i, getter_AddRefs(range));
     1: 
 43808:     NS_ENSURE_SUCCESS(result, result);
     1: 
     1:     result = GetRangeEndPoints(range,
     1:                                getter_AddRefs(startParent), &startOffset,
     1:                                getter_AddRefs(endParent), &endOffset);
     1: 
 43808:     NS_ENSURE_SUCCESS(result, result);
     1: 
 88484:     e1s2 = nsContentUtils::ComparePoints(eStart->mNode, eStartOffset,
 88484:                                          endParent, endOffset);
 88484:     e2s1 = nsContentUtils::ComparePoints(eEnd->mNode, eEndOffset,
 88484:                                          startParent, startOffset);
     1: 
     1:     // Break out of the loop if the text block intersects the current range.
     1: 
     1:     if (e1s2 <= 0 && e2s1 >= 0)
     1:       break;
     1:   }
     1: 
     1:   // We're done if we didn't find an intersecting range.
     1: 
     1:   if (rangeCount < 1 || e1s2 > 0 || e2s1 < 0)
     1:   {
     1:     *aSelStatus = nsITextServicesDocument::eBlockOutside;
     1:     *aSelOffset = *aSelLength = -1;
     1:     return NS_OK;
     1:   }
     1: 
     1:   // Now that we have an intersecting range, find out more info:
     1: 
 88484:   e1s1 = nsContentUtils::ComparePoints(eStart->mNode, eStartOffset,
 88484:                                        startParent, startOffset);
 88484:   e2s2 = nsContentUtils::ComparePoints(eEnd->mNode, eEndOffset,
 88484:                                        endParent, endOffset);
     1: 
     1:   if (rangeCount > 1)
     1:   {
     1:     // There are multiple selection ranges, we only deal
     1:     // with the first one that intersects the current,
     1:     // text block, so mark this a as a partial.
     1: 
     1:     *aSelStatus = nsITextServicesDocument::eBlockPartial;
     1:   }
     1:   else if (e1s1 > 0 && e2s2 < 0)
     1:   {
     1:     // The range extends beyond the start and
     1:     // end of the current text block.
     1: 
     1:     *aSelStatus = nsITextServicesDocument::eBlockInside;
     1:   }
     1:   else if (e1s1 <= 0 && e2s2 >= 0)
     1:   {
     1:     // The current text block contains the entire
     1:     // range.
     1: 
     1:     *aSelStatus = nsITextServicesDocument::eBlockContains;
     1:   }
     1:   else
     1:   {
     1:     // The range partially intersects the block.
     1: 
     1:     *aSelStatus = nsITextServicesDocument::eBlockPartial;
     1:   }
     1: 
     1:   // Now create a range based on the intersection of the
     1:   // text block and range:
     1: 
     1:   nsCOMPtr<nsIDOMNode> p1, p2;
108991:   int32_t     o1,  o2;
     1: 
     1:   // The start of the range will be the rightmost
     1:   // start node.
     1: 
     1:   if (e1s1 >= 0)
     1:   {
     1:     p1 = do_QueryInterface(eStart->mNode);
     1:     o1 = eStartOffset;
     1:   }
     1:   else
     1:   {
     1:     p1 = startParent;
     1:     o1 = startOffset;
     1:   }
     1: 
     1:   // The end of the range will be the leftmost
     1:   // end node.
     1: 
     1:   if (e2s2 <= 0)
     1:   {
     1:     p2 = do_QueryInterface(eEnd->mNode);
     1:     o2 = eEndOffset;
     1:   }
     1:   else
     1:   {
     1:     p2 = endParent;
     1:     o2 = endOffset;
     1:   }
     1: 
     1:   result = CreateRange(p1, o1, p2, o2, getter_AddRefs(range));
     1: 
 43808:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   // Now iterate over this range to figure out the selection's
     1:   // block offset and length.
     1: 
     1:   nsCOMPtr<nsIContentIterator> iter;
     1: 
     1:   result = CreateContentIterator(range, getter_AddRefs(iter));
     1: 
 43808:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   // Find the first text node in the range.
     1:   
 79445:   bool found;
 20503:   nsCOMPtr<nsIContent> content;
     1: 
     1:   iter->First();
     1: 
     1:   if (!IsTextNode(p1))
     1:   {
 80486:     found = false;
     1: 
     1:     while (!iter->IsDone())
     1:     {
 20503:       content = do_QueryInterface(iter->GetCurrentNode());
     1: 
     1:       if (IsTextNode(content))
     1:       {
     1:         p1 = do_QueryInterface(content);
     1: 
 43807:         NS_ENSURE_TRUE(p1, NS_ERROR_FAILURE);
     1: 
     1:         o1 = 0;
 80486:         found = true;
     1: 
     1:         break;
     1:       }
     1: 
     1:       iter->Next();
     1:     }
     1: 
 43807:     NS_ENSURE_TRUE(found, NS_ERROR_FAILURE);
     1:   }
     1: 
     1:   // Find the last text node in the range.
     1: 
     1:   iter->Last();
     1: 
     1:   if (! IsTextNode(p2))
     1:   {
 80486:     found = false;
     1: 
     1:     while (!iter->IsDone())
     1:     {
 20503:       content = do_QueryInterface(iter->GetCurrentNode());
     1: 
     1:       if (IsTextNode(content))
     1:       {
     1:         p2 = do_QueryInterface(content);
     1: 
 43807:         NS_ENSURE_TRUE(p2, NS_ERROR_FAILURE);
     1: 
     1:         nsString str;
     1: 
     1:         result = p2->GetNodeValue(str);
     1: 
 43808:         NS_ENSURE_SUCCESS(result, result);
     1: 
     1:         o2 = str.Length();
 80486:         found = true;
     1: 
     1:         break;
     1:       }
     1: 
     1:       iter->Prev();
     1:     }
     1: 
 43807:     NS_ENSURE_TRUE(found, NS_ERROR_FAILURE);
     1:   }
     1: 
 80486:   found    = false;
     1:   *aSelLength = 0;
     1: 
     1:   for (i = 0; i < tableCount; i++)
     1:   {
 27986:     entry = mOffsetTable[i];
     1: 
 43807:     NS_ENSURE_TRUE(entry, NS_ERROR_FAILURE);
     1: 
     1:     if (!found)
     1:     {
     1:       if (entry->mNode == p1.get() &&
     1:           entry->mNodeOffset <= o1 && o1 <= (entry->mNodeOffset + entry->mLength))
     1:       {
     1:         *aSelOffset = entry->mStrOffset + (o1 - entry->mNodeOffset);
     1: 
     1:         if (p1 == p2 &&
     1:             entry->mNodeOffset <= o2 && o2 <= (entry->mNodeOffset + entry->mLength))
     1:         {
     1:           // The start and end of the range are in the same offset
     1:           // entry. Calculate the length of the range then we're done.
     1: 
     1:           *aSelLength = o2 - o1;
     1:           break;
     1:         }
     1:         else
     1:         {
     1:           // Add the length of the sub string in this offset entry
     1:           // that follows the start of the range.
     1: 
     1:           *aSelLength = entry->mLength - (o1 - entry->mNodeOffset);
     1:         }
     1: 
 80486:         found = true;
     1:       }
     1:     }
     1:     else // found
     1:     {
     1:       if (entry->mNode == p2.get() &&
     1:           entry->mNodeOffset <= o2 && o2 <= (entry->mNodeOffset + entry->mLength))
     1:       {
     1:         // We found the end of the range. Calculate the length of the
     1:         // sub string that is before the end of the range, then we're done.
     1: 
     1:         *aSelLength += o2 - entry->mNodeOffset;
     1:         break;
     1:       }
     1:       else
     1:       {
     1:         // The entire entry must be in the range.
     1: 
     1:         *aSelLength += entry->mLength;
     1:       }
     1:     }
     1:   }
     1: 
     1:   return result;
     1: }
     1: 
 79445: bool
     1: nsTextServicesDocument::SelectionIsCollapsed()
     1: {
     1:   return(mSelStartIndex == mSelEndIndex && mSelStartOffset == mSelEndOffset);
     1: }
     1: 
 79445: bool
     1: nsTextServicesDocument::SelectionIsValid()
     1: {
     1:   return(mSelStartIndex >= 0);
     1: }
     1: 
     1: nsresult
     1: nsTextServicesDocument::GetRangeEndPoints(nsIDOMRange *aRange,
108991:                                           nsIDOMNode **aStartParent, int32_t *aStartOffset,
108991:                                           nsIDOMNode **aEndParent, int32_t *aEndOffset)
     1: {
     1:   nsresult result;
     1: 
 43807:   NS_ENSURE_TRUE(aRange && aStartParent && aStartOffset && aEndParent && aEndOffset, NS_ERROR_NULL_POINTER);
     1: 
     1:   result = aRange->GetStartContainer(aStartParent);
     1: 
 43808:   NS_ENSURE_SUCCESS(result, result);
     1: 
 43807:   NS_ENSURE_TRUE(aStartParent, NS_ERROR_FAILURE);
     1: 
     1:   result = aRange->GetStartOffset(aStartOffset);
     1: 
 43808:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   result = aRange->GetEndContainer(aEndParent);
     1: 
 43808:   NS_ENSURE_SUCCESS(result, result);
     1: 
 43807:   NS_ENSURE_TRUE(aEndParent, NS_ERROR_FAILURE);
     1: 
     1:   result = aRange->GetEndOffset(aEndOffset);
     1: 
     1:   return result;
     1: }
     1: 
     1: 
     1: nsresult
108991: nsTextServicesDocument::CreateRange(nsIDOMNode *aStartParent, int32_t aStartOffset,
108991:                                     nsIDOMNode *aEndParent, int32_t aEndOffset,
     1:                                     nsIDOMRange **aRange)
     1: {
 87303:   return nsRange::CreateRange(aStartParent, aStartOffset, aEndParent,
 87303:                               aEndOffset, aRange);
     1: }
     1: 
     1: nsresult
     1: nsTextServicesDocument::FirstTextNode(nsIContentIterator *aIterator,
     1:                                       TSDIteratorStatus *aIteratorStatus)
     1: {
     1:   if (aIteratorStatus)
     1:     *aIteratorStatus = nsTextServicesDocument::eIsDone;
     1: 
     1:   aIterator->First();
     1: 
 87303:   while (!aIterator->IsDone()) {
 87303:     if (aIterator->GetCurrentNode()->NodeType() == nsIDOMNode::TEXT_NODE) {
     1:       if (aIteratorStatus)
     1:         *aIteratorStatus = nsTextServicesDocument::eValid;
     1:       break;
     1:     }
     1: 
     1:     aIterator->Next();
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsTextServicesDocument::LastTextNode(nsIContentIterator *aIterator,
     1:                                      TSDIteratorStatus *aIteratorStatus)
     1: {
     1:   if (aIteratorStatus)
     1:     *aIteratorStatus = nsTextServicesDocument::eIsDone;
     1: 
     1:   aIterator->Last();
     1: 
 87303:   while (!aIterator->IsDone()) {
 87303:     if (aIterator->GetCurrentNode()->NodeType() == nsIDOMNode::TEXT_NODE) {
     1:       if (aIteratorStatus)
     1:         *aIteratorStatus = nsTextServicesDocument::eValid;
     1:       break;
     1:     }
     1: 
     1:     aIterator->Prev();
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsTextServicesDocument::FirstTextNodeInCurrentBlock(nsIContentIterator *iter)
     1: {
 43807:   NS_ENSURE_TRUE(iter, NS_ERROR_NULL_POINTER);
     1: 
     1:   ClearDidSkip(iter);
     1: 
     1:   nsCOMPtr<nsIContent> last;
     1: 
     1:   // Walk backwards over adjacent text nodes until
     1:   // we hit a block boundary:
     1: 
     1:   while (!iter->IsDone())
     1:   {
101686:     nsCOMPtr<nsIContent> content = iter->GetCurrentNode()->IsContent()
101686:                                    ? iter->GetCurrentNode()->AsContent()
106838:                                    : nullptr;
     1: 
     1:     if (IsTextNode(content))
     1:     {
     1:       if (!last || HasSameBlockNodeParent(content, last))
     1:         last = content;
     1:       else
     1:       {
     1:         // We're done, the current text node is in a
     1:         // different block.
     1:         break;
     1:       }
     1:     }
     1:     else if (last && IsBlockNode(content))
     1:       break;
     1: 
     1:     iter->Prev();
     1: 
     1:     if (DidSkip(iter))
     1:       break;
     1:   }
     1:   
     1:   if (last)
     1:     iter->PositionAt(last);
     1: 
     1:   // XXX: What should we return if last is null?
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsTextServicesDocument::FirstTextNodeInPrevBlock(nsIContentIterator *aIterator)
     1: {
     1:   nsCOMPtr<nsIContent> content;
     1:   nsresult result;
     1: 
 43807:   NS_ENSURE_TRUE(aIterator, NS_ERROR_NULL_POINTER);
     1: 
     1:   // XXX: What if mIterator is not currently on a text node?
     1: 
     1:   // Make sure mIterator is pointing to the first text node in the
     1:   // current block:
     1: 
     1:   result = FirstTextNodeInCurrentBlock(aIterator);
     1: 
 43808:   NS_ENSURE_SUCCESS(result, NS_ERROR_FAILURE);
     1: 
     1:   // Point mIterator to the first node before the first text node:
     1: 
     1:   aIterator->Prev();
     1: 
     1:   if (aIterator->IsDone())
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   // Now find the first text node of the next block:
     1: 
     1:   return FirstTextNodeInCurrentBlock(aIterator);
     1: }
     1: 
     1: nsresult
     1: nsTextServicesDocument::FirstTextNodeInNextBlock(nsIContentIterator *aIterator)
     1: {
     1:   nsCOMPtr<nsIContent> prev;
 79445:   bool crossedBlockBoundary = false;
     1: 
 43807:   NS_ENSURE_TRUE(aIterator, NS_ERROR_NULL_POINTER);
     1: 
     1:   ClearDidSkip(aIterator);
     1: 
     1:   while (!aIterator->IsDone())
     1:   {
101686:     nsCOMPtr<nsIContent> content = aIterator->GetCurrentNode()->IsContent()
101686:                                    ? aIterator->GetCurrentNode()->AsContent()
106838:                                    : nullptr;
     1: 
     1:     if (IsTextNode(content))
     1:     {
     1:       if (!crossedBlockBoundary && (!prev || HasSameBlockNodeParent(prev, content)))
     1:         prev = content;
     1:       else
     1:         break;
     1:     }
     1:     else if (!crossedBlockBoundary && IsBlockNode(content))
 80486:       crossedBlockBoundary = true;
     1: 
     1:     aIterator->Next();
     1: 
     1:     if (!crossedBlockBoundary && DidSkip(aIterator))
 80486:       crossedBlockBoundary = true;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsTextServicesDocument::GetFirstTextNodeInPrevBlock(nsIContent **aContent)
     1: {
     1:   nsresult result;
     1: 
 43807:   NS_ENSURE_TRUE(aContent, NS_ERROR_NULL_POINTER);
     1: 
     1:   *aContent = 0;
     1: 
     1:   // Save the iterator's current content node so we can restore
     1:   // it when we are done:
     1: 
 20503:   nsINode* node = mIterator->GetCurrentNode();
     1: 
     1:   result = FirstTextNodeInPrevBlock(mIterator);
     1: 
     1:   if (NS_FAILED(result))
     1:   {
     1:     // Try to restore the iterator before returning.
 20503:     mIterator->PositionAt(node);
     1:     return result;
     1:   }
     1: 
     1:   if (!mIterator->IsDone())
     1:   {
101686:     nsCOMPtr<nsIContent> current = mIterator->GetCurrentNode()->IsContent()
101686:                                    ? mIterator->GetCurrentNode()->AsContent()
106838:                                    : nullptr;
 87303:     current.forget(aContent);
     1:   }
     1: 
     1:   // Restore the iterator:
     1: 
 20503:   return mIterator->PositionAt(node);
     1: }
     1: 
     1: nsresult
     1: nsTextServicesDocument::GetFirstTextNodeInNextBlock(nsIContent **aContent)
     1: {
     1:   nsresult result;
     1: 
 43807:   NS_ENSURE_TRUE(aContent, NS_ERROR_NULL_POINTER);
     1: 
     1:   *aContent = 0;
     1: 
     1:   // Save the iterator's current content node so we can restore
     1:   // it when we are done:
     1: 
 20503:   nsINode* node = mIterator->GetCurrentNode();
     1: 
     1:   result = FirstTextNodeInNextBlock(mIterator);
     1: 
     1:   if (NS_FAILED(result))
     1:   {
     1:     // Try to restore the iterator before returning.
 20503:     mIterator->PositionAt(node);
     1:     return result;
     1:   }
     1: 
     1:   if (!mIterator->IsDone())
     1:   {
101686:     nsCOMPtr<nsIContent> current = mIterator->GetCurrentNode()->IsContent()
101686:                                    ? mIterator->GetCurrentNode()->AsContent()
106838:                                    : nullptr;
 87303:     current.forget(aContent);
     1:   }
     1: 
     1:   // Restore the iterator:
 20503:   return mIterator->PositionAt(node);
     1: }
     1: 
     1: nsresult
 27986: nsTextServicesDocument::CreateOffsetTable(nsTArray<OffsetEntry*> *aOffsetTable,
     1:                                           nsIContentIterator *aIterator,
     1:                                           TSDIteratorStatus *aIteratorStatus,
     1:                                           nsIDOMRange *aIterRange,
     1:                                           nsString *aStr)
     1: {
     1:   nsresult result = NS_OK;
     1: 
     1:   nsCOMPtr<nsIContent> first;
     1:   nsCOMPtr<nsIContent> prev;
     1: 
 43807:   NS_ENSURE_TRUE(aIterator, NS_ERROR_NULL_POINTER);
     1: 
     1:   ClearOffsetTable(aOffsetTable);
     1: 
     1:   if (aStr)
     1:     aStr->Truncate();
     1: 
     1:   if (*aIteratorStatus == nsTextServicesDocument::eIsDone)
     1:     return NS_OK;
     1: 
     1:   // If we have an aIterRange, retrieve the endpoints so
     1:   // they can be used in the while loop below to trim entries
     1:   // for text nodes that are partially selected by aIterRange.
     1:   
     1:   nsCOMPtr<nsIDOMNode> rngStartNode, rngEndNode;
108991:   int32_t rngStartOffset = 0, rngEndOffset = 0;
     1: 
     1:   if (aIterRange)
     1:   {
     1:     result = GetRangeEndPoints(aIterRange,
     1:                                getter_AddRefs(rngStartNode), &rngStartOffset,
     1:                                getter_AddRefs(rngEndNode), &rngEndOffset);
     1: 
     1:     NS_ENSURE_SUCCESS(result, result);
     1:   }
     1: 
     1:   // The text service could have added text nodes to the beginning
     1:   // of the current block and called this method again. Make sure
     1:   // we really are at the beginning of the current block:
     1: 
     1:   result = FirstTextNodeInCurrentBlock(aIterator);
     1: 
 43808:   NS_ENSURE_SUCCESS(result, result);
     1: 
108991:   int32_t offset = 0;
     1: 
     1:   ClearDidSkip(aIterator);
     1: 
     1:   while (!aIterator->IsDone())
     1:   {
101686:     nsCOMPtr<nsIContent> content = aIterator->GetCurrentNode()->IsContent()
101686:                                    ? aIterator->GetCurrentNode()->AsContent()
106838:                                    : nullptr;
     1: 
     1:     if (IsTextNode(content))
     1:     {
     1:       if (!prev || HasSameBlockNodeParent(prev, content))
     1:       {
     1:         nsCOMPtr<nsIDOMNode> node = do_QueryInterface(content);
     1: 
     1:         if (node)
     1:         {
     1:           nsString str;
     1: 
     1:           result = node->GetNodeValue(str);
     1: 
 43808:           NS_ENSURE_SUCCESS(result, result);
     1: 
     1:           // Add an entry for this text node into the offset table:
     1: 
     1:           OffsetEntry *entry = new OffsetEntry(node, offset, str.Length());
 27986:           aOffsetTable->AppendElement(entry);
     1: 
     1:           // If one or both of the endpoints of the iteration range
     1:           // are in the text node for this entry, make sure the entry
     1:           // only accounts for the portion of the text node that is
     1:           // in the range.
     1: 
108991:           int32_t startOffset = 0;
108991:           int32_t endOffset   = str.Length();
 79445:           bool adjustStr    = false;
     1: 
     1:           if (entry->mNode == rngStartNode)
     1:           {
     1:             entry->mNodeOffset = startOffset = rngStartOffset;
 80486:             adjustStr = true;
     1:           }
     1: 
     1:           if (entry->mNode == rngEndNode)
     1:           {
     1:             endOffset = rngEndOffset;
 80486:             adjustStr = true;
     1:           }
     1: 
     1:           if (adjustStr)
     1:           {
     1:             entry->mLength = endOffset - startOffset;
     1:             str = Substring(str, startOffset, entry->mLength);
     1:           }
     1: 
     1:           offset += str.Length();
     1: 
     1:           if (aStr)
     1:           {
     1:             // Append the text node's string to the output string:
     1: 
     1:             if (!first)
     1:               *aStr = str;
     1:             else
     1:               *aStr += str;
     1:           }
     1:         }
     1: 
     1:         prev = content;
     1: 
     1:         if (!first)
     1:           first = content;
     1:       }
     1:       else
     1:         break;
     1: 
     1:     }
     1:     else if (IsBlockNode(content))
     1:       break;
     1: 
     1:     aIterator->Next();
     1: 
     1:     if (DidSkip(aIterator))
     1:       break;
     1:   }
     1: 
     1:   if (first)
     1:   {
     1:     // Always leave the iterator pointing at the first
     1:     // text node of the current block!
     1: 
     1:     aIterator->PositionAt(first);
     1:   }
     1:   else
     1:   {
     1:     // If we never ran across a text node, the iterator
     1:     // might have been pointing to something invalid to
     1:     // begin with.
     1: 
     1:     *aIteratorStatus = nsTextServicesDocument::eIsDone;
     1:   }
     1: 
     1:   return result;
     1: }
     1: 
     1: nsresult
     1: nsTextServicesDocument::RemoveInvalidOffsetEntries()
     1: {
     1:   OffsetEntry *entry;
108991:   int32_t i = 0;
108991: 
108991:   while (uint32_t(i) < mOffsetTable.Length())
 27986:   {
 27986:     entry = mOffsetTable[i];
     1: 
     1:     if (!entry->mIsValid)
     1:     {
 27986:       mOffsetTable.RemoveElementAt(i);
     1: 
     1:       if (mSelStartIndex >= 0 && mSelStartIndex >= i)
     1:       {
     1:         // We are deleting an entry that comes before
     1:         // mSelStartIndex, decrement mSelStartIndex so
     1:         // that it points to the correct entry!
     1: 
     1:         NS_ASSERTION(i != mSelStartIndex, "Invalid selection index.");
     1: 
     1:         --mSelStartIndex;
     1:         --mSelEndIndex;
     1:       }
     1:     }
     1:     else
     1:       i++;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
 27986: nsTextServicesDocument::ClearOffsetTable(nsTArray<OffsetEntry*> *aOffsetTable)
 27986: {
108991:   uint32_t i;
 27986: 
 27986:   for (i = 0; i < aOffsetTable->Length(); i++)
 27986:   {
 27986:     delete aOffsetTable->ElementAt(i);
     1:   }
     1: 
     1:   aOffsetTable->Clear();
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
108991: nsTextServicesDocument::SplitOffsetEntry(int32_t aTableIndex, int32_t aNewEntryLength)
     1: {
 27986:   OffsetEntry *entry = mOffsetTable[aTableIndex];
     1: 
     1:   NS_ASSERTION((aNewEntryLength > 0), "aNewEntryLength <= 0");
     1:   NS_ASSERTION((aNewEntryLength < entry->mLength), "aNewEntryLength >= mLength");
     1: 
     1:   if (aNewEntryLength < 1 || aNewEntryLength >= entry->mLength)
     1:     return NS_ERROR_FAILURE;
     1: 
108991:   int32_t oldLength = entry->mLength - aNewEntryLength;
     1: 
     1:   OffsetEntry *newEntry = new OffsetEntry(entry->mNode,
     1:                                           entry->mStrOffset + oldLength,
     1:                                           aNewEntryLength);
     1: 
 27986:   if (!mOffsetTable.InsertElementAt(aTableIndex + 1, newEntry))
     1:   {
     1:     delete newEntry;
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:    // Adjust entry fields:
     1: 
     1:    entry->mLength        = oldLength;
     1:    newEntry->mNodeOffset = entry->mNodeOffset + oldLength;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
108991: nsTextServicesDocument::NodeHasOffsetEntry(nsTArray<OffsetEntry*> *aOffsetTable, nsIDOMNode *aNode, bool *aHasEntry, int32_t *aEntryIndex)
     1: {
     1:   OffsetEntry *entry;
108991:   uint32_t i;
     1: 
 43807:   NS_ENSURE_TRUE(aNode && aHasEntry && aEntryIndex, NS_ERROR_NULL_POINTER);
     1: 
 27986:   for (i = 0; i < aOffsetTable->Length(); i++)
 27986:   {
 27986:     entry = (*aOffsetTable)[i];
     1: 
 43807:     NS_ENSURE_TRUE(entry, NS_ERROR_FAILURE);
     1: 
     1:     if (entry->mNode == aNode)
     1:     {
 80486:       *aHasEntry   = true;
     1:       *aEntryIndex = i;
     1: 
     1:       return NS_OK;
     1:     }
     1:   }
     1: 
 80486:   *aHasEntry   = false;
     1:   *aEntryIndex = -1;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: // Spellchecker code has this. See bug 211343
     1: #define IS_NBSP_CHAR(c) (((unsigned char)0xa0)==(c))
     1: 
     1: nsresult
 27986: nsTextServicesDocument::FindWordBounds(nsTArray<OffsetEntry*> *aOffsetTable,
     1:                                        nsString *aBlockStr,
     1:                                        nsIDOMNode *aNode,
108991:                                        int32_t aNodeOffset,
     1:                                        nsIDOMNode **aWordStartNode,
108991:                                        int32_t *aWordStartOffset,
     1:                                        nsIDOMNode **aWordEndNode,
108991:                                        int32_t *aWordEndOffset)
     1: {
     1:   // Initialize return values.
     1: 
     1:   if (aWordStartNode)
106838:     *aWordStartNode = nullptr;
     1:   if (aWordStartOffset)
     1:     *aWordStartOffset = 0;
     1:   if (aWordEndNode)
106838:     *aWordEndNode = nullptr;
     1:   if (aWordEndOffset)
     1:     *aWordEndOffset = 0;
     1: 
108991:   int32_t entryIndex = 0;
 79445:   bool hasEntry = false;
     1: 
     1:   // It's assumed that aNode is a text node. The first thing
 90153:   // we do is get its index in the offset table so we can
     1:   // calculate the dom point's string offset.
     1: 
     1:   nsresult result = NodeHasOffsetEntry(aOffsetTable, aNode, &hasEntry, &entryIndex);
     1:   NS_ENSURE_SUCCESS(result, result);
     1:   NS_ENSURE_TRUE(hasEntry, NS_ERROR_FAILURE);
     1: 
     1:   // Next we map aNodeOffset into a string offset.
     1: 
 27986:   OffsetEntry *entry = (*aOffsetTable)[entryIndex];
108991:   uint32_t strOffset = entry->mStrOffset + aNodeOffset - entry->mNodeOffset;
     1: 
     1:   // Now we use the word breaker to find the beginning and end
     1:   // of the word from our calculated string offset.
     1: 
     1:   const PRUnichar *str = aBlockStr->get();
108991:   uint32_t strLen = aBlockStr->Length();
     1: 
 97745:   nsIWordBreaker* wordBreaker = nsContentUtils::WordBreaker();
 97745:   nsWordRange res = wordBreaker->FindWord(str, strLen, strOffset);
 97745:   if (res.mBegin > strLen) {
 97745:     return str ? NS_ERROR_ILLEGAL_VALUE : NS_ERROR_NULL_POINTER;
     1:   }
     1: 
     1:   // Strip out the NBSPs at the ends
     1:   while ((res.mBegin <= res.mEnd) && (IS_NBSP_CHAR(str[res.mBegin]))) 
     1:     res.mBegin++;
     1:   if (str[res.mEnd] == (unsigned char)0x20)
     1:   {
108991:     uint32_t realEndWord = res.mEnd - 1;
     1:     while ((realEndWord > res.mBegin) && (IS_NBSP_CHAR(str[realEndWord]))) 
     1:       realEndWord--;
     1:     if (realEndWord < res.mEnd - 1) 
     1:       res.mEnd = realEndWord + 1;
     1:   }
     1: 
     1:   // Now that we have the string offsets for the beginning
     1:   // and end of the word, run through the offset table and
     1:   // convert them back into dom points.
     1: 
108991:   int32_t i, lastIndex = aOffsetTable->Length() - 1;
     1: 
     1:   for (i=0; i <= lastIndex; i++)
     1:   {
 27986:     entry = (*aOffsetTable)[i];
     1: 
108991:     int32_t strEndOffset = entry->mStrOffset + entry->mLength;
     1: 
     1:     // Check to see if res.mBegin is within the range covered
     1:     // by this entry. Note that if res.mBegin is after the last
     1:     // character covered by this entry, we will use the next
     1:     // entry if there is one.
     1: 
108991:     if (uint32_t(entry->mStrOffset) <= res.mBegin &&
108991:         (res.mBegin < uint32_t(strEndOffset) ||
108991:         (res.mBegin == uint32_t(strEndOffset) && i == lastIndex)))
     1:     {
     1:       if (aWordStartNode)
     1:       {
     1:         *aWordStartNode = entry->mNode;
     1:         NS_IF_ADDREF(*aWordStartNode);
     1:       }
     1: 
     1:       if (aWordStartOffset)
     1:         *aWordStartOffset = entry->mNodeOffset + res.mBegin - entry->mStrOffset;
     1: 
     1:       if (!aWordEndNode && !aWordEndOffset)
     1:       {
     1:         // We've found our start entry, but if we're not looking
     1:         // for end entries, we're done.
     1: 
     1:         break;
     1:       }
     1:     }
     1: 
     1:     // Check to see if res.mEnd is within the range covered
     1:     // by this entry.
     1: 
108991:     if (uint32_t(entry->mStrOffset) <= res.mEnd && res.mEnd <= uint32_t(strEndOffset))
108991:     {
108991:       if (res.mBegin == res.mEnd && res.mEnd == uint32_t(strEndOffset) && i != lastIndex)
     1:       {
     1:         // Wait for the next round so that we use the same entry
     1:         // we did for aWordStartNode.
     1: 
     1:         continue;
     1:       }
     1: 
     1:       if (aWordEndNode)
     1:       {
     1:         *aWordEndNode = entry->mNode;
     1:         NS_IF_ADDREF(*aWordEndNode);
     1:       }
     1: 
     1:       if (aWordEndOffset)
     1:         *aWordEndOffset = entry->mNodeOffset + res.mEnd - entry->mStrOffset;
     1: 
     1:       break;
     1:     }
     1:   }
     1: 
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: #ifdef DEBUG_kin
     1: void
     1: nsTextServicesDocument::PrintOffsetTable()
     1: {
     1:   OffsetEntry *entry;
108991:   uint32_t i;
 27986: 
 27986:   for (i = 0; i < mOffsetTable.Length(); i++)
 27986:   {
 27986:     entry = mOffsetTable[i];
     1:     printf("ENTRY %4d: %p  %c  %c  %4d  %4d  %4d\n",
     1:            i, entry->mNode,  entry->mIsValid ? 'V' : 'N',
     1:            entry->mIsInsertedText ? 'I' : 'B',
     1:            entry->mNodeOffset, entry->mStrOffset, entry->mLength);
     1:   }
     1: 
     1:   fflush(stdout);
     1: }
     1: 
     1: void
     1: nsTextServicesDocument::PrintContentNode(nsIContent *aContent)
     1: {
     1:   nsString tmpStr, str;
     1: 
     1:   aContent->Tag()->ToString(tmpStr);
     1:   printf("%s", NS_LossyConvertUTF16toASCII(tmpStr).get());
     1: 
 71773:   if (nsIDOMNode::TEXT_NODE == aContent->NodeType())
 71773:   {
 71773:     aContent->AppendTextTo(str);
     1:     printf(":  \"%s\"", NS_LossyConvertUTF16toASCII(str).get());
     1:   }
     1: 
     1:   printf("\n");
     1:   fflush(stdout);
     1: }
     1: #endif
 43303: 
 43303: NS_IMETHODIMP
 43303: nsTextServicesDocument::WillInsertNode(nsIDOMNode *aNode,
 43303:                               nsIDOMNode *aParent,
108991:                               int32_t     aPosition)
 43303: {
 43303:   return NS_OK;
 43303: }
 43303: 
 43303: NS_IMETHODIMP
 43303: nsTextServicesDocument::WillDeleteNode(nsIDOMNode *aChild)
 43303: {
 43303:   return NS_OK;
 43303: }
 43303: 
 43303: NS_IMETHODIMP
 43303: nsTextServicesDocument::WillSplitNode(nsIDOMNode *aExistingRightNode,
108991:                              int32_t     aOffset)
 43303: {
 43303:   return NS_OK;
 43303: }
 43303: 
 43303: NS_IMETHODIMP
 43303: nsTextServicesDocument::WillJoinNodes(nsIDOMNode  *aLeftNode,
 43303:                              nsIDOMNode  *aRightNode,
 43303:                              nsIDOMNode  *aParent)
 43303: {
 43303:   return NS_OK;
 43303: }
 43303: 
 43303: 
 43303: // -------------------------------
 43303: // stubs for unused listen methods
 43303: // -------------------------------
 43303: 
 43303: NS_IMETHODIMP
108991: nsTextServicesDocument::WillCreateNode(const nsAString& aTag, nsIDOMNode *aParent, int32_t aPosition)
 43303: {
 43303:   return NS_OK;
 43303: }
 43303: 
 43303: NS_IMETHODIMP
108991: nsTextServicesDocument::DidCreateNode(const nsAString& aTag, nsIDOMNode *aNode, nsIDOMNode *aParent, int32_t aPosition, nsresult aResult)
 43303: {
 43303:   return NS_OK;
 43303: }
 43303: 
 43303: NS_IMETHODIMP
108991: nsTextServicesDocument::WillInsertText(nsIDOMCharacterData *aTextNode, int32_t aOffset, const nsAString &aString)
 43303: {
 43303:   return NS_OK;
 43303: }
 43303: 
 43303: NS_IMETHODIMP
108991: nsTextServicesDocument::DidInsertText(nsIDOMCharacterData *aTextNode, int32_t aOffset, const nsAString &aString, nsresult aResult)
 43303: {
 43303:   return NS_OK;
 43303: }
 43303: 
 43303: NS_IMETHODIMP
108991: nsTextServicesDocument::WillDeleteText(nsIDOMCharacterData *aTextNode, int32_t aOffset, int32_t aLength)
 43303: {
 43303:   return NS_OK;
 43303: }
 43303: 
 43303: NS_IMETHODIMP
108991: nsTextServicesDocument::DidDeleteText(nsIDOMCharacterData *aTextNode, int32_t aOffset, int32_t aLength, nsresult aResult)
 43303: {
 43303:   return NS_OK;
 43303: }
 43303: 
 43303: NS_IMETHODIMP
 43303: nsTextServicesDocument::WillDeleteSelection(nsISelection *aSelection)
 43303: {
 43303:   return NS_OK;
 43303: }
 43303: 
 43303: NS_IMETHODIMP
 43303: nsTextServicesDocument::DidDeleteSelection(nsISelection *aSelection)
 43303: {
 43303:   return NS_OK;
 43303: }
 43303: 
