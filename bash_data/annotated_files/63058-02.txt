19246: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
19246: /* ***** BEGIN LICENSE BLOCK *****
19246:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
19246:  *
19246:  * The contents of this file are subject to the Mozilla Public License Version
19246:  * 1.1 (the "License"); you may not use this file except in compliance with
19246:  * the License. You may obtain a copy of the License at
19246:  * http://www.mozilla.org/MPL/
19246:  *
19246:  * Software distributed under the License is distributed on an "AS IS" basis,
19246:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
19246:  * for the specific language governing rights and limitations under the
19246:  * License.
19246:  *
19246:  * The Original Code is mozilla.org code.
19246:  *
19246:  * The Initial Developer of the Original Code is
19246:  * Netscape Communications Corporation.
19246:  * Portions created by the Initial Developer are Copyright (C) 1998
19246:  * the Initial Developer. All Rights Reserved.
19246:  *
19246:  * Contributor(s):
19246:  *
19246:  * Alternatively, the contents of this file may be used under the terms of
19246:  * either the GNU General Public License Version 2 or later (the "GPL"), or
19246:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
19246:  * in which case the provisions of the GPL or the LGPL are applicable instead
19246:  * of those above. If you wish to allow use of your version of this file only
19246:  * under the terms of either the GPL or the LGPL, and not to allow others to
19246:  * use your version of this file under the terms of the MPL, indicate your
19246:  * decision by deleting the provisions above and replace them with the notice
19246:  * and other provisions required by the GPL or the LGPL. If you do not delete
19246:  * the provisions above, a recipient may use your version of this file under
19246:  * the terms of any one of the MPL, the GPL or the LGPL.
19246:  *
19246:  * ***** END LICENSE BLOCK ***** */
19246: 
19246: #ifndef nsNPAPIPluginStreamListener_h_
19246: #define nsNPAPIPluginStreamListener_h_
19246: 
47353: #include "nscore.h"
19246: #include "nsIPluginStreamListener.h"
19246: #include "nsIPluginStreamInfo.h"
19246: #include "nsIHTTPHeaderListener.h"
19246: #include "nsIRequest.h"
19246: #include "nsITimer.h"
47301: #include "nsAutoPtr.h"
63058: #include "nsCOMArray.h"
47353: #include "nsIOutputStream.h"
47353: #include "nsIPluginInstanceOwner.h"
47353: #include "nsString.h"
47353: #include "nsNPAPIPluginInstance.h"
60021: #include "nsIAsyncVerifyRedirectCallback.h"
47353: #include "mozilla/PluginLibrary.h"
19246: 
19246: #define MAX_PLUGIN_NECKO_BUFFER 16384
19246: 
19246: class nsINPAPIPluginStreamInfo;
60021: class nsPluginStreamListenerPeer;
19246: 
47353: // nsINPAPIPluginStreamInfo is an internal helper interface that exposes
47353: // the underlying necko request to consumers of nsIPluginStreamInfo's.
47353: #define NS_INPAPIPLUGINSTREAMINFO_IID       \
47353: { 0x097fdaaa, 0xa2a3, 0x49c2, \
47353: {0x91, 0xee, 0xeb, 0xc5, 0x7d, 0x6c, 0x9c, 0x97} }
47353: 
47353: class nsINPAPIPluginStreamInfo : public nsIPluginStreamInfo
47353: {
47353: public:
47353:   NS_DECLARE_STATIC_IID_ACCESSOR(NS_INPAPIPLUGINSTREAMINFO_IID)
47353: 
63058:   void TrackRequest(nsIRequest* request)
47353:   {
63058:     mRequests.AppendObject(request);
63058:   }
63058: 
63058:   void ReplaceRequest(nsIRequest* oldRequest, nsIRequest* newRequest)
63058:   {
63058:     PRInt32 i = mRequests.IndexOfObject(oldRequest);
63058:     if (i == -1) {
63058:       NS_ASSERTION(mRequests.Count() == 0,
63058:                    "Only our initial stream should be unknown!");
63058:       mRequests.AppendObject(oldRequest);
63058:     }
63058:     else {
63058:       mRequests.ReplaceObjectAt(newRequest, i);
63058:     }
63058:   }
63058:   
63058:   void CancelRequests(nsresult status)
63058:   {
63058:     // Copy the array to avoid modification during the loop.
63058:     nsCOMArray<nsIRequest> requestsCopy(mRequests);
63058:     for (PRInt32 i = 0; i < requestsCopy.Count(); ++i)
63058:       requestsCopy[i]->Cancel(status);
63058:   }
63058: 
63058:   void SuspendRequests() {
63058:     nsCOMArray<nsIRequest> requestsCopy(mRequests);
63058:     for (PRInt32 i = 0; i < requestsCopy.Count(); ++i)
63058:       requestsCopy[i]->Suspend();
63058:   }
63058: 
63058:   void ResumeRequests() {
63058:     nsCOMArray<nsIRequest> requestsCopy(mRequests);
63058:     for (PRInt32 i = 0; i < requestsCopy.Count(); ++i)
63058:       requestsCopy[i]->Resume();
47353:   }
47353: 
47353: protected:
63058:   friend class nsPluginByteRangeStreamListener;
63058:   
63058:   nsCOMArray<nsIRequest> mRequests;
47353: };
47353: 
47353: NS_DEFINE_STATIC_IID_ACCESSOR(nsINPAPIPluginStreamInfo,
47353:                               NS_INPAPIPLUGINSTREAMINFO_IID)
47353: 
47353: // Used to handle NPN_NewStream() - writes the stream as received by the plugin
47353: // to a file and at completion (NPN_DestroyStream), tells the browser to load it into
47353: // a plugin-specified target
47353: class nsPluginStreamToFile : public nsIOutputStream
47353: {
47353: public:
47353:   nsPluginStreamToFile(const char* target, nsIPluginInstanceOwner* owner);
47353:   virtual ~nsPluginStreamToFile();
47353: 
47353:   NS_DECL_ISUPPORTS
47353:   NS_DECL_NSIOUTPUTSTREAM
47353: protected:
47353:   char* mTarget;
47353:   nsCString mFileURL;
47353:   nsCOMPtr<nsILocalFile> mTempFile;
47353:   nsCOMPtr<nsIOutputStream> mOutputStream;
47353:   nsIPluginInstanceOwner* mOwner;
47353: };
47353: 
19246: class nsNPAPIPluginStreamListener : public nsIPluginStreamListener,
19246:                                     public nsITimerCallback,
19246:                                     public nsIHTTPHeaderListener
19246: {
36010: private:
36010:   typedef mozilla::PluginLibrary PluginLibrary;
36010: 
19246: public:
19246:   NS_DECL_ISUPPORTS
19246:   NS_DECL_NSIPLUGINSTREAMLISTENER
19246:   NS_DECL_NSITIMERCALLBACK
19246:   NS_DECL_NSIHTTPHEADERLISTENER
19246: 
19246:   nsNPAPIPluginStreamListener(nsNPAPIPluginInstance* inst, void* notifyData,
19246:                               const char* aURL);
19246:   virtual ~nsNPAPIPluginStreamListener();
60021: 
19246:   PRBool IsStarted();
19246:   nsresult CleanUpStream(NPReason reason);
19246:   void CallURLNotify(NPReason reason);
60021:   void SetCallNotify(PRBool aCallNotify) { mCallNotify = aCallNotify; }
63058:   void SuspendRequest();
19246:   void ResumeRequest();
19246:   nsresult StartDataPump();
19246:   void StopDataPump();
19246:   PRBool PluginInitJSLoadInProgress();
19246: 
60021:   void* GetNotifyData() { return mNPStream.notifyData; }
60021:   nsPluginStreamListenerPeer* GetStreamListenerPeer() { return mStreamListenerPeer; }
60021:   void SetStreamListenerPeer(nsPluginStreamListenerPeer* aPeer) { mStreamListenerPeer = aPeer; }
60021: 
60021:   // Returns true if the redirect will be handled by NPAPI, false otherwise.
60021:   bool HandleRedirectNotification(nsIChannel *oldChannel, nsIChannel *newChannel,
60021:                                   nsIAsyncVerifyRedirectCallback* callback);
60021:   void URLRedirectResponse(NPBool allow);
60021: 
19246: protected:
19246:   char* mStreamBuffer;
19246:   char* mNotifyURL;
47301:   nsRefPtr<nsNPAPIPluginInstance> mInst;
60021:   nsPluginStreamListenerPeer* mStreamListenerPeer;
19246:   NPStream mNPStream;
19246:   PRUint32 mStreamBufferSize;
19246:   PRInt32 mStreamBufferByteCount;
32799:   PRInt32 mStreamType;
19246:   PRPackedBool mStreamStarted;
19246:   PRPackedBool mStreamCleanedUp;
19246:   PRPackedBool mCallNotify;
19246:   PRPackedBool mIsSuspended;
19246:   PRPackedBool mIsPluginInitJSStream;
62512:   PRPackedBool mRedirectDenied;
19246:   nsCString mResponseHeaders;
19246:   char* mResponseHeaderBuf;
19246:   nsCOMPtr<nsITimer> mDataPumpTimer;
60021:   nsCOMPtr<nsIAsyncVerifyRedirectCallback> mHTTPRedirectCallback;
19246: 
19246: public:
19246:   nsCOMPtr<nsIPluginStreamInfo> mStreamInfo;
19246: };
19246: 
19246: #endif // nsNPAPIPluginStreamListener_h_
