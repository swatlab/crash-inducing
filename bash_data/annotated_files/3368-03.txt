   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Dean Tessman <dean_tessman@hotmail.com>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
   1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: #include "nsBaseWidget.h"
   1: #include "nsIDeviceContext.h"
   1: #include "nsCOMPtr.h"
   1: #include "nsIMenuListener.h"
   1: #include "nsGfxCIID.h"
   1: #include "nsWidgetsCID.h"
   1: #include "nsIFullScreen.h"
   1: #include "nsServiceManagerUtils.h"
   1: #include "nsIScreenManager.h"
   1: #include "nsAppDirectoryServiceDefs.h"
   1: #include "nsISimpleEnumerator.h"
   1: 
   1: #ifdef DEBUG
   1: #include "nsIServiceManager.h"
   1: #include "nsIPrefService.h"
   1: #include "nsIPrefBranch2.h"
   1: #include "nsIObserver.h"
   1: 
   1: static void debug_RegisterPrefCallbacks();
   1: 
   1: #endif
   1: 
   1: #ifdef NOISY_WIDGET_LEAKS
   1: static PRInt32 gNumWidgets;
   1: #endif
   1: 
   1: // nsBaseWidget
   1: NS_IMPL_ISUPPORTS1(nsBaseWidget, nsIWidget)
   1: 
   1: 
   1: //-------------------------------------------------------------------------
   1: //
   1: // nsBaseWidget constructor
   1: //
   1: //-------------------------------------------------------------------------
   1: 
   1: nsBaseWidget::nsBaseWidget()
   1: : mClientData(nsnull)
   1: , mEventCallback(nsnull)
   1: , mContext(nsnull)
   1: , mToolkit(nsnull)
   1: , mMouseListener(nsnull)
   1: , mEventListener(nsnull)
   1: , mMenuListener(nsnull)
   1: , mCursor(eCursor_standard)
   1: , mWindowType(eWindowType_child)
   1: , mBorderStyle(eBorderStyle_none)
   1: , mIsShiftDown(PR_FALSE)
   1: , mIsControlDown(PR_FALSE)
   1: , mIsAltDown(PR_FALSE)
   1: , mIsDestroying(PR_FALSE)
   1: , mOnDestroyCalled(PR_FALSE)
   1: , mBounds(0,0,0,0)
   1: , mOriginalBounds(nsnull)
   1: , mZIndex(0)
   1: , mSizeMode(nsSizeMode_Normal)
   1: {
   1: #ifdef NOISY_WIDGET_LEAKS
   1:   gNumWidgets++;
   1:   printf("WIDGETS+ = %d\n", gNumWidgets);
   1: #endif
   1: 
   1: #ifdef DEBUG
   1:     debug_RegisterPrefCallbacks();
   1: #endif
   1: }
   1: 
   1: 
   1: //-------------------------------------------------------------------------
   1: //
   1: // nsBaseWidget destructor
   1: //
   1: //-------------------------------------------------------------------------
   1: nsBaseWidget::~nsBaseWidget()
   1: {
   1: #ifdef NOISY_WIDGET_LEAKS
   1:   gNumWidgets--;
   1:   printf("WIDGETS- = %d\n", gNumWidgets);
   1: #endif
   1: 
   1:   NS_IF_RELEASE(mMenuListener);
   1:   NS_IF_RELEASE(mToolkit);
   1:   NS_IF_RELEASE(mContext);
   1:   if (mOriginalBounds)
   1:     delete mOriginalBounds;
   1: }
   1: 
   1: 
   1: //-------------------------------------------------------------------------
   1: //
   1: // Basic create.
   1: //
   1: //-------------------------------------------------------------------------
   1: void nsBaseWidget::BaseCreate(nsIWidget *aParent,
   1:                               const nsRect &aRect,
   1:                               EVENT_CALLBACK aHandleEventFunction,
   1:                               nsIDeviceContext *aContext,
   1:                               nsIAppShell *aAppShell,
   1:                               nsIToolkit *aToolkit,
   1:                               nsWidgetInitData *aInitData)
   1: {
   1:   if (nsnull == mToolkit) {
   1:     if (nsnull != aToolkit) {
   1:       mToolkit = (nsIToolkit*)aToolkit;
   1:       NS_ADDREF(mToolkit);
   1:     }
   1:     else {
   1:       if (nsnull != aParent) {
2955:         mToolkit = aParent->GetToolkit();
2955:         NS_IF_ADDREF(mToolkit);
   1:       }
   1:       // it's some top level window with no toolkit passed in.
   1:       // Create a default toolkit with the current thread
   1: #if !defined(USE_TLS_FOR_TOOLKIT)
   1:       else {
   1:         static NS_DEFINE_CID(kToolkitCID, NS_TOOLKIT_CID);
   1:         
   1:         nsresult res;
   1:         res = CallCreateInstance(kToolkitCID, &mToolkit);
   1:         NS_ASSERTION(NS_SUCCEEDED(res), "Can not create a toolkit in nsBaseWidget::Create");
   1:         if (mToolkit)
   1:           mToolkit->Init(PR_GetCurrentThread());
   1:       }
   1: #else /* USE_TLS_FOR_TOOLKIT */
   1:       else {
   1:         nsresult rv;
   1: 
   1:         rv = NS_GetCurrentToolkit(&mToolkit);
   1:       }
   1: #endif /* USE_TLS_FOR_TOOLKIT */
   1:     }
   1:     
   1:   }
   1:   
   1:   // save the event callback function
   1:   mEventCallback = aHandleEventFunction;
   1:   
   1:   // keep a reference to the device context
   1:   if (aContext) {
   1:     mContext = aContext;
   1:     NS_ADDREF(mContext);
   1:   }
   1:   else {
   1:     nsresult  res;
   1:     
   1:     static NS_DEFINE_CID(kDeviceContextCID, NS_DEVICE_CONTEXT_CID);
   1:     
   1:     res = CallCreateInstance(kDeviceContextCID, &mContext);
   1: 
   1:     if (NS_SUCCEEDED(res))
   1:       mContext->Init(nsnull);
   1:   }
   1: 
   1:   if (nsnull != aInitData) {
   1:     PreCreateWidget(aInitData);
   1:   }
   1: 
   1:   if (aParent) {
   1:     aParent->AddChild(this);
   1:   }
   1: }
   1: 
   1: NS_IMETHODIMP nsBaseWidget::CaptureMouse(PRBool aCapture)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsBaseWidget::Validate()
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsBaseWidget::InvalidateRegion(const nsIRegion *aRegion, PRBool aIsSynchronous)
   1: {
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1: //-------------------------------------------------------------------------
   1: //
   1: // Accessor functions to get/set the client data
   1: //
   1: //-------------------------------------------------------------------------
   1: 
   1: NS_IMETHODIMP nsBaseWidget::GetClientData(void*& aClientData)
   1: {
   1:   aClientData = mClientData;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsBaseWidget::SetClientData(void* aClientData)
   1: {
   1:   mClientData = aClientData;
   1:   return NS_OK;
   1: }
   1: 
   1: //-------------------------------------------------------------------------
   1: //
   1: // Close this nsBaseWidget
   1: //
   1: //-------------------------------------------------------------------------
   1: NS_METHOD nsBaseWidget::Destroy()
   1: {
   1:   // Just in case our parent is the only ref to us
   1:   nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
   1:   
   1:   // disconnect from the parent
   1:   nsIWidget *parent = GetParent();
   1:   if (parent) {
   1:     parent->RemoveChild(this);
   1:   }
   1:   // disconnect listeners.
   1:   NS_IF_RELEASE(mMouseListener);
   1:   NS_IF_RELEASE(mEventListener);
   1:   NS_IF_RELEASE(mMenuListener);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: //-------------------------------------------------------------------------
   1: //
   1: // Set this nsBaseWidget's parent
   1: //
   1: //-------------------------------------------------------------------------
   1: NS_IMETHODIMP nsBaseWidget::SetParent(nsIWidget* aNewParent)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: 
   1: //-------------------------------------------------------------------------
   1: //
   1: // Get this nsBaseWidget parent
   1: //
   1: //-------------------------------------------------------------------------
   1: nsIWidget* nsBaseWidget::GetParent(void)
   1: {
   1:   return nsnull;
   1: }
   1: 
   1: //-------------------------------------------------------------------------
   1: //
   1: // Add a child to the list of children
   1: //
   1: //-------------------------------------------------------------------------
   1: void nsBaseWidget::AddChild(nsIWidget* aChild)
   1: {
   1:   NS_PRECONDITION(!aChild->GetNextSibling() && !aChild->GetPrevSibling(),
   1:                   "aChild not properly removed from its old child list");
   1:   
   1:   if (!mFirstChild) {
   1:     mFirstChild = mLastChild = aChild;
   1:   } else {
   1:     // append to the list
   1:     NS_ASSERTION(mLastChild, "Bogus state");
   1:     NS_ASSERTION(!mLastChild->GetNextSibling(), "Bogus state");
   1:     mLastChild->SetNextSibling(aChild);
   1:     aChild->SetPrevSibling(mLastChild);
   1:     mLastChild = aChild;
   1:   }
   1: }
   1: 
   1: 
   1: //-------------------------------------------------------------------------
   1: //
   1: // Remove a child from the list of children
   1: //
   1: //-------------------------------------------------------------------------
   1: void nsBaseWidget::RemoveChild(nsIWidget* aChild)
   1: {
   1:   NS_ASSERTION(aChild->GetParent() == this, "Not one of our kids!");
   1:   
   1:   if (mLastChild == aChild) {
   1:     mLastChild = mLastChild->GetPrevSibling();
   1:   }
   1:   if (mFirstChild == aChild) {
   1:     mFirstChild = mFirstChild->GetNextSibling();
   1:   }
   1: 
   1:   // Now remove from the list.  Make sure that we pass ownership of the tail
   1:   // of the list correctly before we have aChild let go of it.
   1:   nsIWidget* prev = aChild->GetPrevSibling();
   1:   nsIWidget* next = aChild->GetNextSibling();
   1:   if (prev) {
   1:     prev->SetNextSibling(next);
   1:   }
   1:   if (next) {
   1:     next->SetPrevSibling(prev);
   1:   }
   1:   
   1:   aChild->SetNextSibling(nsnull);
   1:   aChild->SetPrevSibling(nsnull);
   1: }
   1: 
   1: 
   1: //-------------------------------------------------------------------------
   1: //
   1: // Sets widget's position within its parent's child list.
   1: //
   1: //-------------------------------------------------------------------------
   1: NS_IMETHODIMP nsBaseWidget::SetZIndex(PRInt32 aZIndex)
   1: {
   1:   // Hold a ref to ourselves just in case, since we're going to remove
   1:   // from our parent.
   1:   nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
   1:   
   1:   mZIndex = aZIndex;
   1: 
   1:   // reorder this child in its parent's list.
3233:   nsBaseWidget* parent = static_cast<nsBaseWidget*>(GetParent());
   1:   if (parent) {
   1:     parent->RemoveChild(this);
   1:     // Scope sib outside the for loop so we can check it afterward
   1:     nsIWidget* sib = parent->GetFirstChild();
   1:     for ( ; sib; sib = sib->GetNextSibling()) {
   1:       PRInt32 childZIndex;
   1:       if (NS_SUCCEEDED(sib->GetZIndex(&childZIndex))) {
   1:         if (aZIndex < childZIndex) {
   1:           // Insert ourselves before sib
   1:           nsIWidget* prev = sib->GetPrevSibling();
   1:           mNextSibling = sib;
   1:           mPrevSibling = prev;
   1:           sib->SetPrevSibling(this);
   1:           if (prev) {
   1:             prev->SetNextSibling(this);
   1:           } else {
   1:             NS_ASSERTION(sib == parent->mFirstChild, "Broken child list");
   1:             // We've taken ownership of sib, so it's safe to have parent let
   1:             // go of it
   1:             parent->mFirstChild = this;
   1:           }
   1:           PlaceBehind(eZPlacementBelow, sib, PR_FALSE);
   1:           break;
   1:         }
   1:       }
   1:     }
   1:     // were we added to the list?
   1:     if (!sib) {
   1:       parent->AddChild(this);
   1:     }
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: //-------------------------------------------------------------------------
   1: //
   1: // Gets widget's position within its parent's child list.
   1: //
   1: //-------------------------------------------------------------------------
   1: NS_IMETHODIMP nsBaseWidget::GetZIndex(PRInt32* aZIndex)
   1: {
   1:   *aZIndex = mZIndex;
   1:   return NS_OK;
   1: }
   1: 
   1: //-------------------------------------------------------------------------
   1: //
   1: // Places widget behind the given widget (platforms must override)
   1: //
   1: //-------------------------------------------------------------------------
   1: NS_IMETHODIMP nsBaseWidget::PlaceBehind(nsTopLevelWidgetZPlacement aPlacement,
   1:                                         nsIWidget *aWidget, PRBool aActivate)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: //-------------------------------------------------------------------------
   1: //
   1: // Maximize, minimize or restore the window. The BaseWidget implementation
   1: // merely stores the state.
   1: //
   1: //-------------------------------------------------------------------------
   1: NS_IMETHODIMP nsBaseWidget::SetSizeMode(PRInt32 aMode) {
   1: 
   1:   if (aMode == nsSizeMode_Normal || aMode == nsSizeMode_Minimized ||
   1:       aMode == nsSizeMode_Maximized) {
   1: 
   1:     mSizeMode = (nsSizeMode) aMode;
   1:     return NS_OK;
   1:   }
   1:   return NS_ERROR_ILLEGAL_VALUE;
   1: }
   1: 
   1: //-------------------------------------------------------------------------
   1: //
   1: // Get the size mode (minimized, maximized, that sort of thing...)
   1: //
   1: //-------------------------------------------------------------------------
   1: NS_IMETHODIMP nsBaseWidget::GetSizeMode(PRInt32* aMode) {
   1: 
   1:   *aMode = mSizeMode;
   1:   return NS_OK;
   1: }
   1: 
   1: //-------------------------------------------------------------------------
   1: //
   1: // Get the foreground color
   1: //
   1: //-------------------------------------------------------------------------
   1: nscolor nsBaseWidget::GetForegroundColor(void)
   1: {
   1:   return mForeground;
   1: }
   1: 
   1:     
   1: //-------------------------------------------------------------------------
   1: //
   1: // Set the foreground color
   1: //
   1: //-------------------------------------------------------------------------
   1: NS_METHOD nsBaseWidget::SetForegroundColor(const nscolor &aColor)
   1: {
   1:   mForeground = aColor;
   1:   return NS_OK;
   1: }
   1: 
   1:     
   1: //-------------------------------------------------------------------------
   1: //
   1: // Get the background color
   1: //
   1: //-------------------------------------------------------------------------
   1: nscolor nsBaseWidget::GetBackgroundColor(void)
   1: {
   1:   return mBackground;
   1: }
   1: 
   1: //-------------------------------------------------------------------------
   1: //
   1: // Set the background color
   1: //
   1: //-------------------------------------------------------------------------
   1: NS_METHOD nsBaseWidget::SetBackgroundColor(const nscolor &aColor)
   1: {
   1:   mBackground = aColor;
   1:   return NS_OK;
   1: }
   1:      
   1: //-------------------------------------------------------------------------
   1: //
   1: // Get this component cursor
   1: //
   1: //-------------------------------------------------------------------------
   1: nsCursor nsBaseWidget::GetCursor()
   1: {
   1:   return mCursor;
   1: }
   1: 
   1: NS_METHOD nsBaseWidget::SetCursor(nsCursor aCursor)
   1: {
   1:   mCursor = aCursor; 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsBaseWidget::SetCursor(imgIContainer* aCursor,
   1:                                       PRUint32 aHotspotX, PRUint32 aHotspotY)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1:     
   1: //-------------------------------------------------------------------------
   1: //
   1: // Get the window type for this widget
   1: //
   1: //-------------------------------------------------------------------------
   1: NS_IMETHODIMP nsBaseWidget::GetWindowType(nsWindowType& aWindowType)
   1: {
   1:   aWindowType = mWindowType;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsBaseWidget::SetWindowType(nsWindowType aWindowType) 
   1: {
   1:   mWindowType = aWindowType;
   1:   return NS_OK;
   1: }
   1: 
   1: //-------------------------------------------------------------------------
   1: //
   1: // Window transparency methods
   1: //
   1: //-------------------------------------------------------------------------
   1: 
   1: NS_IMETHODIMP nsBaseWidget::SetWindowTranslucency(PRBool aTranslucent) {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP nsBaseWidget::GetWindowTranslucency(PRBool& aTranslucent) {
   1:   aTranslucent = PR_FALSE;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsBaseWidget::UpdateTranslucentWindowAlpha(const nsRect& aRect, PRUint8* aAlphas) {
   1:   NS_ASSERTION(PR_FALSE, "Window is not translucent");
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: //-------------------------------------------------------------------------
   1: //
   1: // Hide window borders/decorations for this widget
   1: //
   1: //-------------------------------------------------------------------------
   1: NS_IMETHODIMP nsBaseWidget::HideWindowChrome(PRBool aShouldHide)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: //-------------------------------------------------------------------------
   1: //
   1: // Put the window into full-screen mode
   1: //
   1: //-------------------------------------------------------------------------
   1: NS_IMETHODIMP nsBaseWidget::MakeFullScreen(PRBool aFullScreen)
   1: {
   1:   HideWindowChrome(aFullScreen);
   1:   return MakeFullScreenInternal(aFullScreen);
   1: }
   1: 
   1: nsresult nsBaseWidget::MakeFullScreenInternal(PRBool aFullScreen)
   1: {
   1:   nsCOMPtr<nsIFullScreen> fullScreen = do_GetService("@mozilla.org/browser/fullscreen;1");
   1: 
   1:   if (aFullScreen) {
   1:     if (!mOriginalBounds)
   1:       mOriginalBounds = new nsRect();
   1:     GetScreenBounds(*mOriginalBounds);
   1: 
   1:     // Move to top-left corner of screen and size to the screen dimensions
   1:     nsCOMPtr<nsIScreenManager> screenManager;
   1:     screenManager = do_GetService("@mozilla.org/gfx/screenmanager;1"); 
   1:     NS_ASSERTION(screenManager, "Unable to grab screenManager.");
   1:     if (screenManager) {
   1:       nsCOMPtr<nsIScreen> screen;
   1:       screenManager->ScreenForRect(mOriginalBounds->x, mOriginalBounds->y,
   1:                                    mOriginalBounds->width, mOriginalBounds->height,
   1:                                    getter_AddRefs(screen));
   1:       if (screen) {
   1:         PRInt32 left, top, width, height;
   1:         if (NS_SUCCEEDED(screen->GetRect(&left, &top, &width, &height))) {
   1:           SetSizeMode(nsSizeMode_Normal);
   1:           Resize(left, top, width, height, PR_TRUE);
   1:     
   1:           // Hide all of the OS chrome
   1:           if (fullScreen)
   1:             fullScreen->HideAllOSChrome();
   1:         }
   1:       }
   1:     }
   1: 
   1:   } else if (mOriginalBounds) {
   1:     Resize(mOriginalBounds->x, mOriginalBounds->y, mOriginalBounds->width,
   1:            mOriginalBounds->height, PR_TRUE);
   1: 
   1:     // Show all of the OS chrome
   1:     if (fullScreen)
   1:       fullScreen->ShowAllOSChrome();
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: //-------------------------------------------------------------------------
   1: //
   1: // Create a rendering context from this nsBaseWidget
   1: //
   1: //-------------------------------------------------------------------------
   1: nsIRenderingContext* nsBaseWidget::GetRenderingContext()
   1: {
   1:   nsresult                      rv;
   1:   nsCOMPtr<nsIRenderingContext> renderingCtx;
   1: 
   1:   if (mOnDestroyCalled)
   1:     return nsnull;
   1: 
   1:   rv = mContext->CreateRenderingContextInstance(*getter_AddRefs(renderingCtx));
   1:   if (NS_SUCCEEDED(rv)) {
   1: #if defined(MOZ_CAIRO_GFX)
3368:     gfxASurface* surface = GetThebesSurface();
3368:     NS_ENSURE_TRUE(surface, nsnull);
3368:     rv = renderingCtx->Init(mContext, surface);
   1: #else
   1:     rv = renderingCtx->Init(mContext, this);
   1: #endif
   1:     if (NS_SUCCEEDED(rv)) {
   1:       nsIRenderingContext *ret = renderingCtx;
   1:       /* Increment object refcount that the |ret| object is still a valid one
   1:        * after we leave this function... */
   1:       NS_ADDREF(ret);
   1:       return ret;
   1:     }
   1:     else {
   1:       NS_WARNING("GetRenderingContext: nsIRenderingContext::Init() failed.");
   1:     }  
   1:   }
   1:   else {
   1:     NS_WARNING("GetRenderingContext: Cannot create RenderingContext.");
   1:   }  
   1:   
   1:   return nsnull;
   1: }
   1: 
   1: //-------------------------------------------------------------------------
   1: //
   1: // Return the toolkit this widget was created on
   1: //
   1: //-------------------------------------------------------------------------
   1: nsIToolkit* nsBaseWidget::GetToolkit()
   1: {
   1:   return mToolkit;
   1: }
   1: 
   1: 
   1: //-------------------------------------------------------------------------
   1: //
   1: // Return the used device context
   1: //
   1: //-------------------------------------------------------------------------
   1: nsIDeviceContext* nsBaseWidget::GetDeviceContext() 
   1: {
   1:   return mContext; 
   1: }
   1: 
   1: #ifdef MOZ_CAIRO_GFX
   1: //-------------------------------------------------------------------------
   1: //
   1: // Get the thebes surface
   1: //
   1: //-------------------------------------------------------------------------
   1: gfxASurface *nsBaseWidget::GetThebesSurface()
   1: {
   1:   nsIWidget *parent = GetParent();
   1:   if (!parent)
   1:     return nsnull;
   1: 
   1:   // in theory we should get our parent's surface,
   1:   // clone it, and set a device offset before returning
   1:   return nsnull;
   1: }
   1: #endif
   1: 
   1: //-------------------------------------------------------------------------
   1: //
   1: // Destroy the window
   1: //
   1: //-------------------------------------------------------------------------
   1: void nsBaseWidget::OnDestroy()
   1: {
   1:   // release references to device context, toolkit, and app shell
   1:   NS_IF_RELEASE(mContext);
   1:   NS_IF_RELEASE(mToolkit);
   1: }
   1: 
   1: NS_METHOD nsBaseWidget::SetWindowClass(const nsAString& xulWinType)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_METHOD nsBaseWidget::SetBorderStyle(nsBorderStyle aBorderStyle)
   1: {
   1:   mBorderStyle = aBorderStyle;
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: /**
   1: * Processes a mouse pressed event
   1: *
   1: **/
   1: NS_METHOD nsBaseWidget::AddMouseListener(nsIMouseListener * aListener)
   1: {
   1:   NS_PRECONDITION(mMouseListener == nsnull, "Null mouse listener");
   1:   NS_IF_RELEASE(mMouseListener);
   1:   NS_ADDREF(aListener);
   1:   mMouseListener = aListener;
   1:   return NS_OK;
   1: }
   1: 
   1: /**
   1: * Processes a mouse pressed event
   1: *
   1: **/
   1: NS_METHOD nsBaseWidget::AddEventListener(nsIEventListener * aListener)
   1: {
   1:   NS_PRECONDITION(mEventListener == nsnull, "Null mouse listener");
   1:   NS_IF_RELEASE(mEventListener);
   1:   NS_ADDREF(aListener);
   1:   mEventListener = aListener;
   1:   return NS_OK;
   1: }
   1: 
   1: /**
   1: * Add a menu listener
   1: * This interface should only be called by the menu services manager
   1: * This will AddRef() the menu listener
   1: * This will Release() a previously set menu listener
   1: *
   1: **/
   1: 
   1: NS_METHOD nsBaseWidget::AddMenuListener(nsIMenuListener * aListener)
   1: {
   1:   NS_IF_RELEASE(mMenuListener);
   1:   NS_IF_ADDREF(aListener);
   1:   mMenuListener = aListener;
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: /**
   1: * If the implementation of nsWindow supports borders this method MUST be overridden
   1: *
   1: **/
   1: NS_METHOD nsBaseWidget::GetClientBounds(nsRect &aRect)
   1: {
   1:   return GetBounds(aRect);
   1: }
   1: 
   1: /**
   1: * If the implementation of nsWindow supports borders this method MUST be overridden
   1: *
   1: **/
   1: NS_METHOD nsBaseWidget::GetBounds(nsRect &aRect)
   1: {
   1:   aRect = mBounds;
   1:   return NS_OK;
   1: }
   1: 
   1: /**
   1: * If the implementation of nsWindow uses a local coordinate system within the window,
   1: * this method must be overridden
   1: *
   1: **/
   1: NS_METHOD nsBaseWidget::GetScreenBounds(nsRect &aRect)
   1: {
   1:   return GetBounds(aRect);
   1: }
   1: 
   1: /**
   1: * 
   1: *
   1: **/
   1: NS_METHOD nsBaseWidget::SetBounds(const nsRect &aRect)
   1: {
   1:   mBounds = aRect;
   1: 
   1:   return NS_OK;
   1: }
   1:  
   1: 
   1: 
   1: /**
   1: * Calculates the border width and height  
   1: *
   1: **/
   1: NS_METHOD nsBaseWidget::GetBorderSize(PRInt32 &aWidth, PRInt32 &aHeight)
   1: {
   1:   nsRect rectWin;
   1:   nsRect rect;
   1:   GetBounds(rectWin);
   1:   GetClientBounds(rect);
   1: 
   1:   aWidth  = (rectWin.width - rect.width) / 2;
   1:   aHeight = (rectWin.height - rect.height) / 2;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsBaseWidget::ScrollWidgets(PRInt32 aDx, PRInt32 aDy)
   1: {
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1: NS_IMETHODIMP nsBaseWidget::ScrollRect(nsRect &aRect, PRInt32 aDx, PRInt32 aDy)
   1: {
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1: NS_METHOD nsBaseWidget::EnableDragDrop(PRBool aEnable)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: NS_METHOD nsBaseWidget::SetModal(PRBool aModal)
   1: {
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1: // generic xp assumption is that events should be processed
   1: NS_METHOD nsBaseWidget::ModalEventFilter(PRBool aRealEvent, void *aEvent,
   1:                             PRBool *aForWindow)
   1: {
   1:   *aForWindow = PR_TRUE;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsBaseWidget::GetAttention(PRInt32 aCycleCount) {
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsBaseWidget::GetLastInputEventTime(PRUint32& aTime) {
   1:     return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsBaseWidget::SetIcon(const nsAString&)
   1: {
   1:   return NS_OK;
   1: }
   1: 
 382: NS_IMETHODIMP
 382: nsBaseWidget::SetAnimatedResize(PRUint16 aAnimation)
 382: {
 382:   return NS_ERROR_NOT_IMPLEMENTED;
 382: }
 382: 
 382: NS_IMETHODIMP
 382: nsBaseWidget::GetAnimatedResize(PRUint16* aAnimation)
 382: {
 382:   return NS_ERROR_NOT_IMPLEMENTED;
 382: }
 382: 
   1: /**
   1:  * Modifies aFile to point at an icon file with the given name and suffix.  The
   1:  * suffix may correspond to a file extension with leading '.' if appropriate.
   1:  * Returns true if the icon file exists and can be read.
   1:  */
   1: static PRBool
   1: ResolveIconNameHelper(nsILocalFile *aFile,
   1:                       const nsAString &aIconName,
   1:                       const nsAString &aIconSuffix)
   1: {
   1:   aFile->Append(NS_LITERAL_STRING("icons"));
   1:   aFile->Append(NS_LITERAL_STRING("default"));
   1:   aFile->Append(aIconName + aIconSuffix);
   1: 
   1:   PRBool readable;
   1:   return NS_SUCCEEDED(aFile->IsReadable(&readable)) && readable;
   1: }
   1: 
   1: /**
   1:  * Resolve the given icon name into a local file object.  This method is
   1:  * intended to be called by subclasses of nsBaseWidget.  aIconSuffix is a
   1:  * platform specific icon file suffix (e.g., ".ico" under Win32).
   1:  *
   1:  * If no file is found matching the given parameters, then null is returned.
   1:  */
   1: void
   1: nsBaseWidget::ResolveIconName(const nsAString &aIconName,
   1:                               const nsAString &aIconSuffix,
   1:                               nsILocalFile **aResult)
   1: { 
   1:   *aResult = nsnull;
   1: 
   1:   nsCOMPtr<nsIProperties> dirSvc = do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID);
   1:   if (!dirSvc)
   1:     return;
   1: 
   1:   // first check auxilary chrome directories
   1: 
   1:   nsCOMPtr<nsISimpleEnumerator> dirs;
   1:   dirSvc->Get(NS_APP_CHROME_DIR_LIST, NS_GET_IID(nsISimpleEnumerator),
   1:               getter_AddRefs(dirs));
   1:   if (dirs) {
   1:     PRBool hasMore;
   1:     while (NS_SUCCEEDED(dirs->HasMoreElements(&hasMore)) && hasMore) {
   1:       nsCOMPtr<nsISupports> element;
   1:       dirs->GetNext(getter_AddRefs(element));
   1:       if (!element)
   1:         continue;
   1:       nsCOMPtr<nsILocalFile> file = do_QueryInterface(element);
   1:       if (!file)
   1:         continue;
   1:       if (ResolveIconNameHelper(file, aIconName, aIconSuffix)) {
   1:         NS_ADDREF(*aResult = file);
   1:         return;
   1:       }
   1:     }
   1:   }
   1: 
   1:   // then check the main app chrome directory
   1: 
   1:   nsCOMPtr<nsILocalFile> file;
   1:   dirSvc->Get(NS_APP_CHROME_DIR, NS_GET_IID(nsILocalFile),
   1:               getter_AddRefs(file));
   1:   if (file && ResolveIconNameHelper(file, aIconName, aIconSuffix))
   1:     NS_ADDREF(*aResult = file);
   1: }
   1: 
   1: #ifdef DEBUG
   1: //////////////////////////////////////////////////////////////
   1: //
   1: // Convert a GUI event message code to a string.
   1: // Makes it a lot easier to debug events.
   1: //
   1: // See gtk/nsWidget.cpp and windows/nsWindow.cpp
   1: // for a DebugPrintEvent() function that uses
   1: // this.
   1: //
   1: //////////////////////////////////////////////////////////////
   1: /* static */ nsAutoString
   1: nsBaseWidget::debug_GuiEventToString(nsGUIEvent * aGuiEvent)
   1: {
   1:   NS_ASSERTION(nsnull != aGuiEvent,"cmon, null gui event.");
   1: 
   1:   nsAutoString eventName(NS_LITERAL_STRING("UNKNOWN"));
   1: 
   1: #define _ASSIGN_eventName(_value,_name)\
   1: case _value: eventName.AssignWithConversion(_name) ; break
   1: 
   1:   switch(aGuiEvent->message)
   1:   {
   1:     _ASSIGN_eventName(NS_BLUR_CONTENT,"NS_BLUR_CONTENT");
   1:     _ASSIGN_eventName(NS_CONTROL_CHANGE,"NS_CONTROL_CHANGE");
   1:     _ASSIGN_eventName(NS_CREATE,"NS_CREATE");
   1:     _ASSIGN_eventName(NS_DESTROY,"NS_DESTROY");
   1:     _ASSIGN_eventName(NS_DRAGDROP_GESTURE,"NS_DND_GESTURE");
   1:     _ASSIGN_eventName(NS_DRAGDROP_DROP,"NS_DND_DROP");
   1:     _ASSIGN_eventName(NS_DRAGDROP_ENTER,"NS_DND_ENTER");
   1:     _ASSIGN_eventName(NS_DRAGDROP_EXIT,"NS_DND_EXIT");
   1:     _ASSIGN_eventName(NS_DRAGDROP_OVER,"NS_DND_OVER");
   1:     _ASSIGN_eventName(NS_FOCUS_CONTENT,"NS_FOCUS_CONTENT");
   1:     _ASSIGN_eventName(NS_FORM_SELECTED,"NS_FORM_SELECTED");
   1:     _ASSIGN_eventName(NS_FORM_CHANGE,"NS_FORM_CHANGE");
   1:     _ASSIGN_eventName(NS_FORM_INPUT,"NS_FORM_INPUT");
   1:     _ASSIGN_eventName(NS_FORM_RESET,"NS_FORM_RESET");
   1:     _ASSIGN_eventName(NS_FORM_SUBMIT,"NS_FORM_SUBMIT");
   1:     _ASSIGN_eventName(NS_GOTFOCUS,"NS_GOTFOCUS");
   1:     _ASSIGN_eventName(NS_IMAGE_ABORT,"NS_IMAGE_ABORT");
   1:     _ASSIGN_eventName(NS_LOAD_ERROR,"NS_LOAD_ERROR");
   1:     _ASSIGN_eventName(NS_KEY_DOWN,"NS_KEY_DOWN");
   1:     _ASSIGN_eventName(NS_KEY_PRESS,"NS_KEY_PRESS");
   1:     _ASSIGN_eventName(NS_KEY_UP,"NS_KEY_UP");
   1:     _ASSIGN_eventName(NS_LOSTFOCUS,"NS_LOSTFOCUS");
   1:     _ASSIGN_eventName(NS_MENU_SELECTED,"NS_MENU_SELECTED");
   1:     _ASSIGN_eventName(NS_MOUSE_ENTER,"NS_MOUSE_ENTER");
   1:     _ASSIGN_eventName(NS_MOUSE_EXIT,"NS_MOUSE_EXIT");
   1:     _ASSIGN_eventName(NS_MOUSE_BUTTON_DOWN,"NS_MOUSE_BUTTON_DOWN");
   1:     _ASSIGN_eventName(NS_MOUSE_BUTTON_UP,"NS_MOUSE_BUTTON_UP");
   1:     _ASSIGN_eventName(NS_MOUSE_CLICK,"NS_MOUSE_CLICK");
   1:     _ASSIGN_eventName(NS_MOUSE_DOUBLECLICK,"NS_MOUSE_DBLCLICK");
   1:     _ASSIGN_eventName(NS_MOUSE_MOVE,"NS_MOUSE_MOVE");
   1:     _ASSIGN_eventName(NS_MOVE,"NS_MOVE");
   1:     _ASSIGN_eventName(NS_LOAD,"NS_LOAD");
   1:     _ASSIGN_eventName(NS_PAGE_UNLOAD,"NS_PAGE_UNLOAD");
   1:     _ASSIGN_eventName(NS_PAINT,"NS_PAINT");
   1:     _ASSIGN_eventName(NS_XUL_BROADCAST, "NS_XUL_BROADCAST");
   1:     _ASSIGN_eventName(NS_XUL_COMMAND_UPDATE, "NS_XUL_COMMAND_UPDATE");
   1:     _ASSIGN_eventName(NS_SCROLLBAR_LINE_NEXT,"NS_SB_LINE_NEXT");
   1:     _ASSIGN_eventName(NS_SCROLLBAR_LINE_PREV,"NS_SB_LINE_PREV");
   1:     _ASSIGN_eventName(NS_SCROLLBAR_PAGE_NEXT,"NS_SB_PAGE_NEXT");
   1:     _ASSIGN_eventName(NS_SCROLLBAR_PAGE_PREV,"NS_SB_PAGE_PREV");
   1:     _ASSIGN_eventName(NS_SCROLLBAR_POS,"NS_SB_POS");
   1:     _ASSIGN_eventName(NS_SIZE,"NS_SIZE");
   1: 
   1: #undef _ASSIGN_eventName
   1: 
   1:   default: 
   1:     {
   1:       char buf[32];
   1:       
   1:       sprintf(buf,"UNKNOWN: %d",aGuiEvent->message);
   1:       
   1:       eventName.AssignWithConversion(buf);
   1:     }
   1:     break;
   1:   }
   1:   
   1:   return nsAutoString(eventName);
   1: }
   1: //////////////////////////////////////////////////////////////
   1: //
   1: // Code to deal with paint and event debug prefs.
   1: //
   1: //////////////////////////////////////////////////////////////
   1: struct PrefPair
   1: {
   1:   const char * name;
   1:   PRBool value;
   1: };
   1: 
   1: static PrefPair debug_PrefValues[] =
   1: {
   1:   { "nglayout.debug.crossing_event_dumping", PR_FALSE },
   1:   { "nglayout.debug.event_dumping", PR_FALSE },
   1:   { "nglayout.debug.invalidate_dumping", PR_FALSE },
   1:   { "nglayout.debug.motion_event_dumping", PR_FALSE },
   1:   { "nglayout.debug.paint_dumping", PR_FALSE },
   1:   { "nglayout.debug.paint_flashing", PR_FALSE }
   1: };
   1: 
   1: static PRUint32 debug_NumPrefValues = 
   1:   (sizeof(debug_PrefValues) / sizeof(debug_PrefValues[0]));
   1: 
   1: 
   1: //////////////////////////////////////////////////////////////
   1: static PRBool debug_GetBoolPref(nsIPrefBranch * aPrefs,const char * aPrefName)
   1: {
   1:   NS_ASSERTION(nsnull != aPrefName,"cmon, pref name is null.");
   1:   NS_ASSERTION(nsnull != aPrefs,"cmon, prefs are null.");
   1: 
   1:   PRBool value = PR_FALSE;
   1: 
   1:   if (aPrefs)
   1:   {
   1:     aPrefs->GetBoolPref(aPrefName,&value);
   1:   }
   1: 
   1:   return value;
   1: }
   1: //////////////////////////////////////////////////////////////
   1: PRBool
   1: nsBaseWidget::debug_GetCachedBoolPref(const char * aPrefName)
   1: {
   1:   NS_ASSERTION(nsnull != aPrefName,"cmon, pref name is null.");
   1: 
   1:   for (PRUint32 i = 0; i < debug_NumPrefValues; i++)
   1:   {
   1:     if (strcmp(debug_PrefValues[i].name, aPrefName) == 0)
   1:     {
   1:       return debug_PrefValues[i].value;
   1:     }
   1:   }
   1: 
   1:   return PR_FALSE;
   1: }
   1: //////////////////////////////////////////////////////////////
   1: static void debug_SetCachedBoolPref(const char * aPrefName,PRBool aValue)
   1: {
   1:   NS_ASSERTION(nsnull != aPrefName,"cmon, pref name is null.");
   1: 
   1:   for (PRUint32 i = 0; i < debug_NumPrefValues; i++)
   1:   {
   1:     if (strcmp(debug_PrefValues[i].name, aPrefName) == 0)
   1:     {
   1:       debug_PrefValues[i].value = aValue;
   1: 
   1:       return;
   1:     }
   1:   }
   1: 
   1:   NS_ASSERTION(PR_FALSE, "cmon, this code is not reached dude.");
   1: }
   1: 
   1: //////////////////////////////////////////////////////////////
   1: class Debug_PrefObserver : public nsIObserver {
   1:   public:
   1:     NS_DECL_ISUPPORTS
   1:     NS_DECL_NSIOBSERVER
   1: };
   1: 
   1: NS_IMPL_ISUPPORTS1(Debug_PrefObserver, nsIObserver)
   1: 
   1: NS_IMETHODIMP
   1: Debug_PrefObserver::Observe(nsISupports* subject, const char* topic,
   1:                             const PRUnichar* data)
   1: {
   1:   nsCOMPtr<nsIPrefBranch> branch(do_QueryInterface(subject));
   1:   NS_ASSERTION(branch, "must implement nsIPrefBranch");
   1: 
   1:   NS_ConvertUTF16toUTF8 prefName(data);
   1: 
   1:   PRBool value = PR_FALSE;
   1:   branch->GetBoolPref(prefName.get(), &value);
   1:   debug_SetCachedBoolPref(prefName.get(), value);
   1:   return NS_OK;
   1: }
   1: 
   1: //////////////////////////////////////////////////////////////
   1: /* static */ void
   1: debug_RegisterPrefCallbacks()
   1: {
   1:   static PRBool once = PR_TRUE;
   1: 
   1:   if (once)
   1:   {
   1:     once = PR_FALSE;
   1: 
   1:     nsCOMPtr<nsIPrefBranch2> prefs(do_GetService(NS_PREFSERVICE_CONTRACTID));
   1:     
   1:     NS_ASSERTION(prefs, "Prefs services is null.");
   1: 
   1:     if (prefs)
   1:     {
   1:       nsCOMPtr<nsIObserver> obs(new Debug_PrefObserver());
   1:       for (PRUint32 i = 0; i < debug_NumPrefValues; i++)
   1:       {
   1:         // Initialize the pref values
   1:         debug_PrefValues[i].value = 
   1:           debug_GetBoolPref(prefs,debug_PrefValues[i].name);
   1: 
   1:         if (obs) {
   1:           // Register callbacks for when these change
   1:           prefs->AddObserver(debug_PrefValues[i].name, obs, PR_FALSE);
   1:         }
   1:       }
   1:     }
   1:   }
   1: }
   1: //////////////////////////////////////////////////////////////
   1: static PRInt32
   1: _GetPrintCount()
   1: {
   1:   static PRInt32 sCount = 0;
   1:   
   1:   return ++sCount;
   1: }
   1: //////////////////////////////////////////////////////////////
   1: /* static */ PRBool
   1: nsBaseWidget::debug_WantPaintFlashing()
   1: {
   1:   return debug_GetCachedBoolPref("nglayout.debug.paint_flashing");
   1: }
   1: //////////////////////////////////////////////////////////////
   1: /* static */ void
   1: nsBaseWidget::debug_DumpEvent(FILE *                aFileOut,
   1:                               nsIWidget *           aWidget,
   1:                               nsGUIEvent *          aGuiEvent,
   1:                               const nsCAutoString & aWidgetName,
   1:                               PRInt32               aWindowID)
   1: {
   1:   // NS_PAINT is handled by debug_DumpPaintEvent()
   1:   if (aGuiEvent->message == NS_PAINT)
   1:     return;
   1: 
   1:   if (aGuiEvent->message == NS_MOUSE_MOVE)
   1:   {
   1:     if (!debug_GetCachedBoolPref("nglayout.debug.motion_event_dumping"))
   1:       return;
   1:   }
   1:   
   1:   if (aGuiEvent->message == NS_MOUSE_ENTER || 
   1:       aGuiEvent->message == NS_MOUSE_EXIT)
   1:   {
   1:     if (!debug_GetCachedBoolPref("nglayout.debug.crossing_event_dumping"))
   1:       return;
   1:   }
   1: 
   1:   if (!debug_GetCachedBoolPref("nglayout.debug.event_dumping"))
   1:     return;
   1: 
   1:   nsCAutoString tempString; tempString.AssignWithConversion(debug_GuiEventToString(aGuiEvent).get());
   1:   
   1:   fprintf(aFileOut,
   1:           "%4d %-26s widget=%-8p name=%-12s id=%-8p refpt=%d,%d\n",
   1:           _GetPrintCount(),
   1:           tempString.get(),
   1:           (void *) aWidget,
   1:           aWidgetName.get(),
   1:           (void *) (aWindowID ? aWindowID : 0x0),
   1:           aGuiEvent->refPoint.x,
   1:           aGuiEvent->refPoint.y);
   1: }
   1: //////////////////////////////////////////////////////////////
   1: /* static */ void
   1: nsBaseWidget::debug_DumpPaintEvent(FILE *                aFileOut,
   1:                                    nsIWidget *           aWidget,
   1:                                    nsPaintEvent *        aPaintEvent,
   1:                                    const nsCAutoString & aWidgetName,
   1:                                    PRInt32               aWindowID)
   1: {
   1:   NS_ASSERTION(nsnull != aFileOut,"cmon, null output FILE");
   1:   NS_ASSERTION(nsnull != aWidget,"cmon, the widget is null");
   1:   NS_ASSERTION(nsnull != aPaintEvent,"cmon, the paint event is null");
   1: 
   1:   if (!debug_GetCachedBoolPref("nglayout.debug.paint_dumping"))
   1:     return;
   1:   
   1:   fprintf(aFileOut,
   1:           "%4d PAINT      widget=%p name=%-12s id=%-8p rect=", 
   1:           _GetPrintCount(),
   1:           (void *) aWidget,
   1:           aWidgetName.get(),
   1:           (void *) aWindowID);
   1:   
   1:   if (aPaintEvent->rect) 
   1:   {
   1:     fprintf(aFileOut,
   1:             "%3d,%-3d %3d,%-3d",
   1:             aPaintEvent->rect->x, 
   1:             aPaintEvent->rect->y,
   1:             aPaintEvent->rect->width, 
   1:             aPaintEvent->rect->height);
   1:   }
   1:   else
   1:   {
   1:     fprintf(aFileOut,"none");
   1:   }
   1:   
   1:   fprintf(aFileOut,"\n");
   1: }
   1: //////////////////////////////////////////////////////////////
   1: /* static */ void
   1: nsBaseWidget::debug_DumpInvalidate(FILE *                aFileOut,
   1:                                    nsIWidget *           aWidget,
   1:                                    const nsRect *        aRect,
   1:                                    PRBool                aIsSynchronous,
   1:                                    const nsCAutoString & aWidgetName,
   1:                                    PRInt32               aWindowID)
   1: {
   1:   if (!debug_GetCachedBoolPref("nglayout.debug.invalidate_dumping"))
   1:     return;
   1: 
   1:   NS_ASSERTION(nsnull != aFileOut,"cmon, null output FILE");
   1:   NS_ASSERTION(nsnull != aWidget,"cmon, the widget is null");
   1: 
   1:   fprintf(aFileOut,
   1:           "%4d Invalidate widget=%p name=%-12s id=%-8p",
   1:           _GetPrintCount(),
   1:           (void *) aWidget,
   1:           aWidgetName.get(),
   1:           (void *) aWindowID);
   1: 
   1:   if (aRect) 
   1:   {
   1:     fprintf(aFileOut,
   1:             " rect=%3d,%-3d %3d,%-3d",
   1:             aRect->x, 
   1:             aRect->y,
   1:             aRect->width, 
   1:             aRect->height);
   1:   }
   1:   else
   1:   {
   1:     fprintf(aFileOut,
   1:             " rect=%-15s",
   1:             "none");
   1:   }
   1: 
   1:   fprintf(aFileOut,
   1:           " sync=%s",
   1:           (const char *) (aIsSynchronous ? "yes" : "no "));
   1:   
   1:   fprintf(aFileOut,"\n");
   1: }
   1: //////////////////////////////////////////////////////////////
   1: 
   1: #endif // DEBUG
   1: 
