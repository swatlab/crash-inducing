 39447: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 39447: 
 39447: #include "gfxGDIFont.h"
 39447: #include "gfxGDIShaper.h"
 39447: #include "gfxUniscribeShaper.h"
 43527: #include "gfxHarfBuzzShaper.h"
 84392: #ifdef MOZ_GRAPHITE
 84392: #include "gfxGraphiteShaper.h"
 84392: #endif
 39447: #include "gfxWindowsPlatform.h"
 39447: #include "gfxContext.h"
 39447: 
 39447: #include "cairo-win32.h"
 39447: 
 39447: #define ROUND(x) floor((x) + 0.5)
 39447: 
 39447: static inline cairo_antialias_t
 39447: GetCairoAntialiasOption(gfxFont::AntialiasOption anAntialiasOption)
 39447: {
 39447:     switch (anAntialiasOption) {
 39447:     default:
 39447:     case gfxFont::kAntialiasDefault:
 39447:         return CAIRO_ANTIALIAS_DEFAULT;
 39447:     case gfxFont::kAntialiasNone:
 39447:         return CAIRO_ANTIALIAS_NONE;
 39447:     case gfxFont::kAntialiasGrayscale:
 39447:         return CAIRO_ANTIALIAS_GRAY;
 39447:     case gfxFont::kAntialiasSubpixel:
 39447:         return CAIRO_ANTIALIAS_SUBPIXEL;
 39447:     }
 39447: }
 39447: 
 39447: gfxGDIFont::gfxGDIFont(GDIFontEntry *aFontEntry,
 39447:                        const gfxFontStyle *aFontStyle,
 79445:                        bool aNeedsBold,
 39447:                        AntialiasOption anAAOption)
 39447:     : gfxFont(aFontEntry, aFontStyle, anAAOption),
 39447:       mFont(NULL),
106838:       mFontFace(nullptr),
106838:       mMetrics(nullptr),
 41898:       mSpaceGlyph(0),
 41898:       mNeedsBold(aNeedsBold)
 39447: {
 84392: #ifdef MOZ_GRAPHITE
 84392:     if (FontCanSupportGraphite()) {
 84392:         mGraphiteShaper = new gfxGraphiteShaper(this);
 84392:     }
 84392: #endif
 43527:     if (FontCanSupportHarfBuzz()) {
 43527:         mHarfBuzzShaper = new gfxHarfBuzzShaper(this);
 43459:     }
 39447: }
 39447: 
 39447: gfxGDIFont::~gfxGDIFont()
 39447: {
 39447:     if (mScaledFont) {
 39447:         cairo_scaled_font_destroy(mScaledFont);
 39447:     }
 39447:     if (mFontFace) {
 39447:         cairo_font_face_destroy(mFontFace);
 39447:     }
 39447:     if (mFont) {
 39447:         ::DeleteObject(mFont);
 39447:     }
 41898:     delete mMetrics;
 39447: }
 39447: 
 43527: void
 43527: gfxGDIFont::CreatePlatformShaper()
 43527: {
 43527:     mPlatformShaper = new gfxGDIShaper(this);
 43527: }
 43527: 
 39447: gfxFont*
 39447: gfxGDIFont::CopyWithAntialiasOption(AntialiasOption anAAOption)
 39447: {
 39447:     return new gfxGDIFont(static_cast<GDIFontEntry*>(mFontEntry.get()),
 39447:                           &mStyle, mNeedsBold, anAAOption);
 39447: }
 39447: 
 79445: static bool
 86693: UseUniscribe(gfxShapedWord *aShapedWord,
 86693:              const PRUnichar *aString)
 46221: {
108991:     uint32_t flags = aShapedWord->Flags();
 79445:     bool useGDI;
 46221: 
 79445:     bool isXP = (gfxWindowsPlatform::WindowsOSVersion() 
 46221:                        < gfxWindowsPlatform::kWindowsVista);
 46221: 
 46221:     // bug 561304 - Uniscribe bug produces bad positioning at certain
 46221:     // font sizes on XP, so default to GDI on XP using logic of 3.6
 46221: 
 46221:     useGDI = isXP &&
 46221:              (flags &
 46221:                (gfxTextRunFactory::TEXT_OPTIMIZE_SPEED | 
 46221:                 gfxTextRunFactory::TEXT_IS_RTL)
 46221:              ) == gfxTextRunFactory::TEXT_OPTIMIZE_SPEED;
 46221: 
 46221:     return !useGDI ||
 86693:         ScriptIsComplex(aString, aShapedWord->Length(), SIC_COMPLEX) == S_OK;
 46221: }
 46221: 
 79445: bool
 86693: gfxGDIFont::ShapeWord(gfxContext *aContext,
 86693:                       gfxShapedWord *aShapedWord,
 39447:                       const PRUnichar *aString,
 79445:                       bool aPreferPlatformShaping)
 39447: {
 41898:     if (!mMetrics) {
 41898:         Initialize();
 41898:     }
 41898:     if (!mIsValid) {
 41898:         NS_WARNING("invalid font! expect incorrect text rendering");
 80486:         return false;
 41898:     }
 46221: 
 79445:     bool ok = false;
 46221: 
 95363:     // Ensure the cairo font is set up, so there's no risk it'll fall back to
 95363:     // creating a "toy" font internally (see bug 544617).
 95363:     // We must check that this succeeded, otherwise we risk cairo creating the
 95363:     // wrong kind of font internally as a fallback (bug 744480).
 95363:     if (!SetupCairoFont(aContext)) {
 95363:         return false;
 95363:     }
 63896: 
 84392: #ifdef MOZ_GRAPHITE
 84392:     if (mGraphiteShaper && gfxPlatform::GetPlatform()->UseGraphiteShaping()) {
 86693:         ok = mGraphiteShaper->ShapeWord(aContext, aShapedWord, aString);
 84392:     }
 84392: #endif
 84392: 
 84392:     if (!ok && mHarfBuzzShaper) {
 86693:         if (gfxPlatform::GetPlatform()->UseHarfBuzzForScript(aShapedWord->Script())) {
 86693:             ok = mHarfBuzzShaper->ShapeWord(aContext, aShapedWord, aString);
 46221:         }
 46221:     }
 46221: 
 46221:     if (!ok) {
 43440:         GDIFontEntry *fe = static_cast<GDIFontEntry*>(GetFontEntry());
 79445:         bool preferUniscribe =
 61531:             (!fe->IsTrueType() || fe->IsSymbolFont()) && !fe->mForceGDI;
 46221: 
 86693:         if (preferUniscribe || UseUniscribe(aShapedWord, aString)) {
 46221:             // first try Uniscribe
 46221:             if (!mUniscribeShaper) {
 46221:                 mUniscribeShaper = new gfxUniscribeShaper(this);
 46221:             }
 46221: 
 86693:             ok = mUniscribeShaper->ShapeWord(aContext, aShapedWord, aString);
 46221:             if (ok) {
 80486:                 return true;
 46221:             }
 46221: 
 46221:             // fallback to GDI shaping
 46221:             if (!mPlatformShaper) {
 46221:                 CreatePlatformShaper();
 46221:             }
 46221: 
 86693:             ok = mPlatformShaper->ShapeWord(aContext, aShapedWord, aString);
 46221:         } else {
 46221:             // first use GDI
 46221:             if (!mPlatformShaper) {
 46221:                 CreatePlatformShaper();
 43459:             }
 46221: 
 86693:             ok = mPlatformShaper->ShapeWord(aContext, aShapedWord, aString);
 46221:             if (ok) {
 80486:                 return true;
 46221:             }
 46221: 
 61531:             // try Uniscribe if GDI failed
 46221:             if (!mUniscribeShaper) {
 46221:                 mUniscribeShaper = new gfxUniscribeShaper(this);
 46221:             }
 46221: 
 46221:             // use Uniscribe shaping
 86693:             ok = mUniscribeShaper->ShapeWord(aContext, aShapedWord, aString);
 46221:         }
 46221: 
 46221: #if DEBUG
 46221:         if (!ok) {
 46221:             NS_ConvertUTF16toUTF8 name(GetName());
 46221:             char msg[256];
 46221: 
 46221:             sprintf(msg, 
 46221:                     "text shaping with both uniscribe and GDI failed for"
 46221:                     " font: %s",
 46221:                     name.get());
 46221:             NS_WARNING(msg);
 46221:         }
 46221: #endif
 43459:     }
 43527: 
 90073:     if (ok && IsSyntheticBold()) {
 90073:         float synBoldOffset =
 90073:                 GetSyntheticBoldOffset() * CalcXScale(aContext);
 90073:         aShapedWord->AdjustAdvancesForSyntheticBold(synBoldOffset);
 90073:     }
 90073: 
 43527:     return ok;
 39447: }
 39447: 
 39447: const gfxFont::Metrics&
 39447: gfxGDIFont::GetMetrics()
 39447: {
 41898:     if (!mMetrics) {
 41898:         Initialize();
 41898:     }
 41898:     return *mMetrics;
 39447: }
 39447: 
108991: uint32_t
 39447: gfxGDIFont::GetSpaceGlyph()
 39447: {
 41898:     if (!mMetrics) {
 41898:         Initialize();
 41898:     }
 39447:     return mSpaceGlyph;
 39447: }
 39447: 
 79445: bool
 39447: gfxGDIFont::SetupCairoFont(gfxContext *aContext)
 39447: {
 41898:     if (!mMetrics) {
 41898:         Initialize();
 41898:     }
 51561:     if (!mScaledFont ||
 51561:         cairo_scaled_font_status(mScaledFont) != CAIRO_STATUS_SUCCESS) {
 39447:         // Don't cairo_set_scaled_font as that would propagate the error to
 39447:         // the cairo_t, precluding any further drawing.
 80486:         return false;
 39447:     }
 39447:     cairo_set_scaled_font(aContext->GetCairo(), mScaledFont);
 80486:     return true;
 39447: }
 39447: 
 72200: gfxFont::RunMetrics
 72200: gfxGDIFont::Measure(gfxTextRun *aTextRun,
108991:                     uint32_t aStart, uint32_t aEnd,
 72200:                     BoundingBoxType aBoundingBoxType,
 72200:                     gfxContext *aRefContext,
 72200:                     Spacing *aSpacing)
 72200: {
 72200:     gfxFont::RunMetrics metrics =
 72200:         gfxFont::Measure(aTextRun, aStart, aEnd,
 72200:                          aBoundingBoxType, aRefContext, aSpacing);
 72200: 
 72200:     // if aBoundingBoxType is LOOSE_INK_EXTENTS
 72200:     // and the underlying cairo font may be antialiased,
 72200:     // we can't trust Windows to have considered all the pixels
 72200:     // so we need to add "padding" to the bounds.
 72200:     // (see bugs 475968, 439831, compare also bug 445087)
 72200:     if (aBoundingBoxType == LOOSE_INK_EXTENTS &&
 72200:         mAntialiasOption != kAntialiasNone &&
 72200:         metrics.mBoundingBox.width > 0) {
 72200:         metrics.mBoundingBox.x -= aTextRun->GetAppUnitsPerDevUnit();
 72200:         metrics.mBoundingBox.width += aTextRun->GetAppUnitsPerDevUnit() * 3;
 72200:     }
 72200: 
 72200:     return metrics;
 72200: }
 72200: 
 90073: #define OBLIQUE_SKEW_FACTOR 0.3
 90073: 
 39447: void
 41898: gfxGDIFont::Initialize()
 39447: {
 41898:     NS_ASSERTION(!mMetrics, "re-creating metrics? this will leak");
 41898: 
 41898:     LOGFONTW logFont;
 41898: 
103472:     // Figure out if we want to do synthetic oblique styling.
103472:     GDIFontEntry* fe = static_cast<GDIFontEntry*>(GetFontEntry());
103472:     bool wantFakeItalic =
103472:         (mStyle.style & (NS_FONT_STYLE_ITALIC | NS_FONT_STYLE_OBLIQUE)) &&
103472:         !fe->IsItalic();
103472: 
103472:     // If the font's family has an actual italic face (but font matching
103472:     // didn't choose it), we have to use a cairo transform instead of asking
103472:     // GDI to italicize, because that would use a different face and result
103472:     // in a possible glyph ID mismatch between shaping and rendering.
103472:     //
125649:     // We use the mFamilyHasItalicFace flag in the entry in case of user fonts,
103472:     // where the *CSS* family may not know about italic faces that are present
103472:     // in the *GDI* family, and which GDI would use if we asked it to perform
103472:     // the "italicization".
125649:     bool useCairoFakeItalic = wantFakeItalic && fe->mFamilyHasItalicFace;
103472: 
 39447:     if (mAdjustedSize == 0.0) {
 39447:         mAdjustedSize = mStyle.size;
 39447:         if (mStyle.sizeAdjust != 0.0 && mAdjustedSize > 0.0) {
 39447:             // to implement font-size-adjust, we first create the "unadjusted" font
103472:             FillLogFont(logFont, mAdjustedSize,
103472:                         wantFakeItalic && !useCairoFakeItalic);
 41898:             mFont = ::CreateFontIndirectW(&logFont);
 39447: 
 41898:             // initialize its metrics so we can calculate size adjustment
 41898:             Initialize();
 41898: 
 41898:             // calculate the properly adjusted size, and then proceed
 41898:             // to recreate mFont and recalculate metrics
 41898:             gfxFloat aspect = mMetrics->xHeight / mMetrics->emHeight;
 41898:             mAdjustedSize = mStyle.GetAdjustedSize(aspect);
 41898: 
 41898:             // delete the temporary font and metrics
 39447:             ::DeleteObject(mFont);
106838:             mFont = nullptr;
 41898:             delete mMetrics;
106838:             mMetrics = nullptr;
 39447:         }
 39447:     }
 39447: 
 90073:     // (bug 724231) for local user fonts, we don't use GDI's synthetic bold,
 90073:     // as it could lead to a different, incompatible face being used
 90073:     // but instead do our own multi-striking
 90073:     if (mNeedsBold && GetFontEntry()->IsLocalUserFont()) {
 90073:         mApplySyntheticBold = true;
 90073:     }
 90073: 
 84046:     // this may end up being zero
 73915:     mAdjustedSize = ROUND(mAdjustedSize);
103472:     FillLogFont(logFont, mAdjustedSize, wantFakeItalic && !useCairoFakeItalic);
 41898:     mFont = ::CreateFontIndirectW(&logFont);
 41898: 
 41898:     mMetrics = new gfxFont::Metrics;
 41898:     ::memset(mMetrics, 0, sizeof(*mMetrics));
 39447: 
 39447:     AutoDC dc;
 39447:     SetGraphicsMode(dc.GetDC(), GM_ADVANCED);
 39447:     AutoSelectFont selectFont(dc.GetDC(), mFont);
 39447: 
 84046:     // Get font metrics if size > 0
 84046:     if (mAdjustedSize > 0.0) {
 84046: 
 39447:         OUTLINETEXTMETRIC oMetrics;
 39447:         TEXTMETRIC& metrics = oMetrics.otmTextMetrics;
 39447: 
 39447:         if (0 < GetOutlineTextMetrics(dc.GetDC(), sizeof(oMetrics), &oMetrics)) {
 41898:             mMetrics->superscriptOffset = (double)oMetrics.otmptSuperscriptOffset.y;
 39447:             // Some fonts have wrong sign on their subscript offset, bug 410917.
 41898:             mMetrics->subscriptOffset = fabs((double)oMetrics.otmptSubscriptOffset.y);
 41898:             mMetrics->strikeoutSize = (double)oMetrics.otmsStrikeoutSize;
 41898:             mMetrics->strikeoutOffset = (double)oMetrics.otmsStrikeoutPosition;
 41898:             mMetrics->underlineSize = (double)oMetrics.otmsUnderscoreSize;
 41898:             mMetrics->underlineOffset = (double)oMetrics.otmsUnderscorePosition;
 39447: 
 39447:             const MAT2 kIdentityMatrix = { {0, 1}, {0, 0}, {0, 0}, {0, 1} };
 39447:             GLYPHMETRICS gm;
106838:             DWORD len = GetGlyphOutlineW(dc.GetDC(), PRUnichar('x'), GGO_METRICS, &gm, 0, nullptr, &kIdentityMatrix);
 39447:             if (len == GDI_ERROR || gm.gmptGlyphOrigin.y <= 0) {
 39447:                 // 56% of ascent, best guess for true type
 47309:                 mMetrics->xHeight =
 47309:                     ROUND((double)metrics.tmAscent * DEFAULT_XHEIGHT_FACTOR);
 39447:             } else {
 41898:                 mMetrics->xHeight = gm.gmptGlyphOrigin.y;
 39447:             }
 41898:             mMetrics->emHeight = metrics.tmHeight - metrics.tmInternalLeading;
 39447:             gfxFloat typEmHeight = (double)oMetrics.otmAscent - (double)oMetrics.otmDescent;
 41898:             mMetrics->emAscent = ROUND(mMetrics->emHeight * (double)oMetrics.otmAscent / typEmHeight);
 41898:             mMetrics->emDescent = mMetrics->emHeight - mMetrics->emAscent;
 43527:             if (oMetrics.otmEMSquare > 0) {
 61083:                 mFUnitsConvFactor = float(mAdjustedSize / oMetrics.otmEMSquare);
 43527:             }
 39447:         } else {
 39447:             // Make a best-effort guess at extended metrics
 39447:             // this is based on general typographic guidelines
 39447: 
 39447:             // GetTextMetrics can fail if the font file has been removed
 39447:             // or corrupted recently.
 39447:             BOOL result = GetTextMetrics(dc.GetDC(), &metrics);
 39447:             if (!result) {
 39447:                 NS_WARNING("Missing or corrupt font data, fasten your seatbelt");
 80486:                 mIsValid = false;
 41898:                 memset(mMetrics, 0, sizeof(*mMetrics));
 39447:                 return;
 39447:             }
 39447: 
 47309:             mMetrics->xHeight =
 47309:                 ROUND((float)metrics.tmAscent * DEFAULT_XHEIGHT_FACTOR);
 41898:             mMetrics->superscriptOffset = mMetrics->xHeight;
 41898:             mMetrics->subscriptOffset = mMetrics->xHeight;
 41898:             mMetrics->strikeoutSize = 1;
 41898:             mMetrics->strikeoutOffset = ROUND(mMetrics->xHeight * 0.5f); // 50% of xHeight
 41898:             mMetrics->underlineSize = 1;
 41898:             mMetrics->underlineOffset = -ROUND((float)metrics.tmDescent * 0.30f); // 30% of descent
 41898:             mMetrics->emHeight = metrics.tmHeight - metrics.tmInternalLeading;
 41898:             mMetrics->emAscent = metrics.tmAscent - metrics.tmInternalLeading;
 41898:             mMetrics->emDescent = metrics.tmDescent;
 39447:         }
 39447: 
 41898:         mMetrics->internalLeading = metrics.tmInternalLeading;
 41898:         mMetrics->externalLeading = metrics.tmExternalLeading;
 41898:         mMetrics->maxHeight = metrics.tmHeight;
 41898:         mMetrics->maxAscent = metrics.tmAscent;
 41898:         mMetrics->maxDescent = metrics.tmDescent;
 41898:         mMetrics->maxAdvance = metrics.tmMaxCharWidth;
 71173:         mMetrics->aveCharWidth = NS_MAX<gfxFloat>(1, metrics.tmAveCharWidth);
 39447:         // The font is monospace when TMPF_FIXED_PITCH is *not* set!
 39447:         // See http://msdn2.microsoft.com/en-us/library/ms534202(VS.85).aspx
 39447:         if (!(metrics.tmPitchAndFamily & TMPF_FIXED_PITCH)) {
 41898:             mMetrics->maxAdvance = mMetrics->aveCharWidth;
 39447:         }
 39447: 
 39447:         // Cache the width of a single space.
 39447:         SIZE size;
 39447:         GetTextExtentPoint32W(dc.GetDC(), L" ", 1, &size);
 41898:         mMetrics->spaceWidth = ROUND(size.cx);
 39447: 
 39447:         // Cache the width of digit zero.
 39447:         // XXX MSDN (http://msdn.microsoft.com/en-us/library/ms534223.aspx)
 39447:         // does not say what the failure modes for GetTextExtentPoint32 are -
 39447:         // is it safe to assume it will fail iff the font has no '0'?
 41898:         if (GetTextExtentPoint32W(dc.GetDC(), L"0", 1, &size)) {
 41898:             mMetrics->zeroOrAveCharWidth = ROUND(size.cx);
 41898:         } else {
 41898:             mMetrics->zeroOrAveCharWidth = mMetrics->aveCharWidth;
 41898:         }
 39447: 
 39447:         mSpaceGlyph = 0;
 39447:         if (metrics.tmPitchAndFamily & TMPF_TRUETYPE) {
 39447:             WORD glyph;
 39447:             DWORD ret = GetGlyphIndicesW(dc.GetDC(), L" ", 1, &glyph,
 39447:                                          GGI_MARK_NONEXISTING_GLYPHS);
 39447:             if (ret != GDI_ERROR && glyph != 0xFFFF) {
 39447:                 mSpaceGlyph = glyph;
 39447:             }
 39447:         }
 39447: 
 41898:         SanitizeMetrics(mMetrics, GetFontEntry()->mIsBadUnderlineFont);
 84046:     }
 41898: 
 90073:     if (IsSyntheticBold()) {
 90073:         mMetrics->aveCharWidth += GetSyntheticBoldOffset();
 90073:         mMetrics->maxAdvance += GetSyntheticBoldOffset();
 90073:     }
 90073: 
 41898:     mFontFace = cairo_win32_font_face_create_for_logfontw_hfont(&logFont,
 41898:                                                                 mFont);
 41898: 
 41898:     cairo_matrix_t sizeMatrix, ctm;
 41898:     cairo_matrix_init_identity(&ctm);
 41898:     cairo_matrix_init_scale(&sizeMatrix, mAdjustedSize, mAdjustedSize);
 41898: 
103472:     if (useCairoFakeItalic) {
103472:         // Skew the matrix to do fake italic if it wasn't already applied
103472:         // via the LOGFONT
 90073:         double skewfactor = OBLIQUE_SKEW_FACTOR;
 90073:         cairo_matrix_t style;
 90073:         cairo_matrix_init(&style,
 90073:                           1,                //xx
 90073:                           0,                //yx
 90073:                           -1 * skewfactor,  //xy
 90073:                           1,                //yy
 90073:                           0,                //x0
 90073:                           0);               //y0
 90073:         cairo_matrix_multiply(&sizeMatrix, &sizeMatrix, &style);
 90073:     }
 90073: 
 41898:     cairo_font_options_t *fontOptions = cairo_font_options_create();
 41898:     if (mAntialiasOption != kAntialiasDefault) {
 41898:         cairo_font_options_set_antialias(fontOptions,
 41898:             GetCairoAntialiasOption(mAntialiasOption));
 41898:     }
 41898:     mScaledFont = cairo_scaled_font_create(mFontFace, &sizeMatrix,
 41898:                                            &ctm, fontOptions);
 41898:     cairo_font_options_destroy(fontOptions);
 41898: 
 51561:     if (!mScaledFont ||
 51561:         cairo_scaled_font_status(mScaledFont) != CAIRO_STATUS_SUCCESS) {
 41898: #ifdef DEBUG
 41898:         char warnBuf[1024];
 41898:         sprintf(warnBuf, "Failed to create scaled font: %s status: %d",
 51561:                 NS_ConvertUTF16toUTF8(mFontEntry->Name()).get(),
 51561:                 mScaledFont ? cairo_scaled_font_status(mScaledFont) : 0);
 41898:         NS_WARNING(warnBuf);
 41898: #endif
 84046:         mIsValid = false;
 84046:     } else {
 84046:         mIsValid = true;
 41898:     }
 41898: 
 40042: #if 0
 84046:     printf("Font: %p (%s) size: %f adjusted size: %f valid: %s\n", this,
 84046:            NS_ConvertUTF16toUTF8(GetName()).get(), mStyle.size, mAdjustedSize, (mIsValid ? "yes" : "no"));
 84046:     printf("    emHeight: %f emAscent: %f emDescent: %f\n", mMetrics->emHeight, mMetrics->emAscent, mMetrics->emDescent);
 84046:     printf("    maxAscent: %f maxDescent: %f maxAdvance: %f\n", mMetrics->maxAscent, mMetrics->maxDescent, mMetrics->maxAdvance);
 84046:     printf("    internalLeading: %f externalLeading: %f\n", mMetrics->internalLeading, mMetrics->externalLeading);
 84046:     printf("    spaceWidth: %f aveCharWidth: %f xHeight: %f\n", mMetrics->spaceWidth, mMetrics->aveCharWidth, mMetrics->xHeight);
 40042:     printf("    uOff: %f uSize: %f stOff: %f stSize: %f supOff: %f subOff: %f\n",
 84046:            mMetrics->underlineOffset, mMetrics->underlineSize, mMetrics->strikeoutOffset, mMetrics->strikeoutSize,
 84046:            mMetrics->superscriptOffset, mMetrics->subscriptOffset);
 40042: #endif
 39447: }
 39447: 
 39447: void
103472: gfxGDIFont::FillLogFont(LOGFONTW& aLogFont, gfxFloat aSize,
103472:                         bool aUseGDIFakeItalic)
 39447: {
 39447:     GDIFontEntry *fe = static_cast<GDIFontEntry*>(GetFontEntry());
 39447: 
108991:     uint16_t weight;
 90073:     if (fe->IsUserFont()) {
 90073:         if (fe->IsLocalUserFont()) {
 90073:             // for local user fonts, don't change the original weight
 90073:             // in the entry's logfont, because that could alter the
 90073:             // choice of actual face used (bug 724231)
 90073:             weight = 0;
 90073:         } else {
 48283:             // avoid GDI synthetic bold which occurs when weight
 48283:             // specified is >= font data weight + 200
 90073:             weight = mNeedsBold ? 700 : 200;
 39447:         }
 90073:     } else {
 90073:         weight = mNeedsBold ? 700 : fe->Weight();
 39447:     }
 39447: 
 90073:     fe->FillLogFont(&aLogFont, weight, aSize, 
 80486:                     (mAntialiasOption == kAntialiasSubpixel) ? true : false);
103472: 
103472:     // If GDI synthetic italic is wanted, force the lfItalic field to true
103472:     if (aUseGDIFakeItalic) {
103472:         aLogFont.lfItalic = 1;
103472:     }
 39447: }
 39447: 
108991: int32_t
108991: gfxGDIFont::GetGlyphWidth(gfxContext *aCtx, uint16_t aGID)
 43527: {
 43527:     if (!mGlyphWidths.IsInitialized()) {
 43527:         mGlyphWidths.Init(200);
 43527:     }
 43527: 
108991:     int32_t width;
 43527:     if (mGlyphWidths.Get(aGID, &width)) {
 43527:         return width;
 43527:     }
 43527: 
 62991:     DCFromContext dc(aCtx);
 62991:     AutoSelectFont fs(dc, GetHFONT());
 62991: 
 43527:     int devWidth;
 62991:     if (GetCharWidthI(dc, aGID, 1, NULL, &devWidth)) {
 43527:         // ensure width is positive, 16.16 fixed-point value
 43527:         width = (devWidth & 0x7fff) << 16;
 43527:         mGlyphWidths.Put(aGID, width);
 43527:         return width;
 43527:     }
 43527: 
 43527:     return -1;
 43527: }
 93997: 
 93997: void
 93997: gfxGDIFont::SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf,
 93997:                                 FontCacheSizes*   aSizes) const
 93997: {
 93997:     gfxFont::SizeOfExcludingThis(aMallocSizeOf, aSizes);
 93997:     aSizes->mFontInstances += aMallocSizeOf(mMetrics) +
106838:         mGlyphWidths.SizeOfExcludingThis(nullptr, aMallocSizeOf);
 93997: }
 93997: 
 93997: void
 93997: gfxGDIFont::SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf,
 93997:                                 FontCacheSizes*   aSizes) const
 93997: {
 93997:     aSizes->mFontInstances += aMallocSizeOf(this);
 93997:     SizeOfExcludingThis(aMallocSizeOf, aSizes);
 93997: }
