6224: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
6224: /* ***** BEGIN LICENSE BLOCK *****
6224:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
6224:  *
6224:  * The contents of this file are subject to the Mozilla Public License Version
6224:  * 1.1 (the "License"); you may not use this file except in compliance with
6224:  * the License. You may obtain a copy of the License at
6224:  * http://www.mozilla.org/MPL/
6224:  *
6224:  * Software distributed under the License is distributed on an "AS IS" basis,
6224:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
6224:  * for the specific language governing rights and limitations under the
6224:  * License.
6224:  *
6224:  * The Original Code is mozilla.org code.
6224:  *
6224:  * The Initial Developer of the Original Code is
6224:  * Netscape Communications Corporation.
6224:  * Portions created by the Initial Developer are Copyright (C) 1998
6224:  * the Initial Developer. All Rights Reserved.
6224:  *
6224:  * Contributor(s):
6224:  *   Robert O'Callahan <robert@ocallahan.org>
6224:  *   Roger B. Sidje <rbs@maths.uq.edu.au>
6224:  *   Pierre Phaneuf <pp@ludusdesign.com>
6224:  *   Prabhat Hegde <prabhat.hegde@sun.com>
6224:  *   Tomi Leppikangas <tomi.leppikangas@oulu.fi>
6224:  *   Roland Mainz <roland.mainz@informatik.med.uni-giessen.de>
6224:  *   Daniel Glazman <glazman@netscape.com>
6224:  *   Neil Deakin <neil@mozdevgroup.com>
6224:  *   Masayuki Nakano <masayuki@d-toybox.com>
6224:  *   Mats Palmgren <mats.palmgren@bredband.net>
6224:  *   Uri Bernstein <uriber@gmail.com>
6224:  *   Stephen Blackheath <entangled.mooched.stephen@blacksapphire.com>
6224:  *
6224:  * Alternatively, the contents of this file may be used under the terms of
6224:  * either of the GNU General Public License Version 2 or later (the "GPL"),
6224:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
6224:  * in which case the provisions of the GPL or the LGPL are applicable instead
6224:  * of those above. If you wish to allow use of your version of this file only
6224:  * under the terms of either the GPL or the LGPL, and not to allow others to
6224:  * use your version of this file under the terms of the MPL, indicate your
6224:  * decision by deleting the provisions above and replace them with the notice
6224:  * and other provisions required by the GPL or the LGPL. If you do not delete
6224:  * the provisions above, a recipient may use your version of this file under
6224:  * the terms of any one of the MPL, the GPL or the LGPL.
6224:  *
6224:  * ***** END LICENSE BLOCK ***** */
6224: 
6224: #ifndef nsTextFrame_h__
6224: #define nsTextFrame_h__
6224: 
6224: #include "nsFrame.h"
6224: #include "nsLineBox.h"
6224: #include "gfxFont.h"
6224: #include "gfxSkipChars.h"
6224: 
6224: class nsTextPaintStyle;
6224: class PropertyProvider;
6224: 
6224: class nsTextFrame : public nsFrame {
6224: public:
6224:   nsTextFrame(nsStyleContext* aContext) : nsFrame(aContext)
6224:   {
6224:     NS_ASSERTION(mContentOffset == 0, "Bogus content offset");
6224:   }
6224:   
6224:   // nsIFrame
6224:   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
6224:                               const nsRect&           aDirtyRect,
6224:                               const nsDisplayListSet& aLists);
6224: 
6224:   NS_IMETHOD Init(nsIContent*      aContent,
6224:                   nsIFrame*        aParent,
6224:                   nsIFrame*        aPrevInFlow);
6224: 
6224:   virtual void Destroy();
6224:   
6224:   NS_IMETHOD GetCursor(const nsPoint& aPoint,
6224:                        nsIFrame::Cursor& aCursor);
6224:   
6224:   NS_IMETHOD CharacterDataChanged(nsPresContext* aPresContext,
6224:                                   nsIContent*     aChild,
6224:                                   PRBool          aAppend);
6224:                                   
6224:   NS_IMETHOD DidSetStyleContext();
6224:   
6224:   virtual nsIFrame* GetNextContinuation() const {
6224:     return mNextContinuation;
6224:   }
6224:   NS_IMETHOD SetNextContinuation(nsIFrame* aNextContinuation) {
6224:     NS_ASSERTION (!aNextContinuation || GetType() == aNextContinuation->GetType(),
6224:                   "setting a next continuation with incorrect type!");
6224:     NS_ASSERTION (!nsSplittableFrame::IsInNextContinuationChain(aNextContinuation, this),
6224:                   "creating a loop in continuation chain!");
6224:     mNextContinuation = aNextContinuation;
6224:     if (aNextContinuation)
6224:       aNextContinuation->RemoveStateBits(NS_FRAME_IS_FLUID_CONTINUATION);
6224:     return NS_OK;
6224:   }
6224:   virtual nsIFrame* GetNextInFlowVirtual() const { return GetNextInFlow(); }
6224:   nsIFrame* GetNextInFlow() const {
6224:     return mNextContinuation && (mNextContinuation->GetStateBits() & NS_FRAME_IS_FLUID_CONTINUATION) ? 
6224:       mNextContinuation : nsnull;
6224:   }
6224:   NS_IMETHOD SetNextInFlow(nsIFrame* aNextInFlow) {
6224:     NS_ASSERTION (!aNextInFlow || GetType() == aNextInFlow->GetType(),
6224:                   "setting a next in flow with incorrect type!");
6224:     NS_ASSERTION (!nsSplittableFrame::IsInNextContinuationChain(aNextInFlow, this),
6224:                   "creating a loop in continuation chain!");
6224:     mNextContinuation = aNextInFlow;
6224:     if (aNextInFlow)
6224:       aNextInFlow->AddStateBits(NS_FRAME_IS_FLUID_CONTINUATION);
6224:     return NS_OK;
6224:   }
6224:   virtual nsIFrame* GetLastInFlow() const;
6224:   virtual nsIFrame* GetLastContinuation() const;
6224:   
6224:   virtual nsSplittableType GetSplittableType() const {
6224:     return NS_FRAME_SPLITTABLE;
6224:   }
6224:   
6224:   /**
6224:     * Get the "type" of the frame
6224:    *
6224:    * @see nsGkAtoms::textFrame
6224:    */
6224:   virtual nsIAtom* GetType() const;
6224:   
6224:   virtual PRBool IsFrameOfType(PRUint32 aFlags) const
6224:   {
6224:     // Set the frame state bit for text frames to mark them as replaced.
6224:     // XXX kipp: temporary
6224:     return nsFrame::IsFrameOfType(aFlags & ~(nsIFrame::eReplaced |
6224:                                              nsIFrame::eLineParticipant));
6224:   }
6224: 
6224: #ifdef DEBUG
6224:   NS_IMETHOD List(FILE* out, PRInt32 aIndent) const;
6224:   NS_IMETHOD GetFrameName(nsAString& aResult) const;
6224:   NS_IMETHOD_(nsFrameState) GetDebugStateBits() const ;
6224: #endif
6224:   
6224:   virtual ContentOffsets CalcContentOffsetsFromFramePoint(nsPoint aPoint);
6224:    
6224:   NS_IMETHOD SetSelected(nsPresContext* aPresContext,
6224:                          nsIDOMRange *aRange,
6224:                          PRBool aSelected,
6224:                          nsSpread aSpread);
6224:   
6224:   virtual PRBool PeekOffsetNoAmount(PRBool aForward, PRInt32* aOffset);
6224:   virtual PRBool PeekOffsetCharacter(PRBool aForward, PRInt32* aOffset);
6224:   virtual PRBool PeekOffsetWord(PRBool aForward, PRBool aWordSelectEatSpace, PRBool aIsKeyboardSelect,
6224:                                 PRInt32* aOffset, PeekWordState* aState);
6224: 
6224:   NS_IMETHOD CheckVisibility(nsPresContext* aContext, PRInt32 aStartIndex, PRInt32 aEndIndex, PRBool aRecurse, PRBool *aFinished, PRBool *_retval);
6224:   
6224:   // Update offsets to account for new length. This may clear mTextRun.
6224:   void SetLength(PRInt32 aLength);
6224:   
6224:   NS_IMETHOD GetOffsets(PRInt32 &start, PRInt32 &end)const;
6224:   
6224:   virtual void AdjustOffsetsForBidi(PRInt32 start, PRInt32 end);
6224:   
6224:   NS_IMETHOD GetPointFromOffset(PRInt32                 inOffset,
6224:                                 nsPoint*                outPoint);
6224:   
6224:   NS_IMETHOD  GetChildFrameContainingOffset(PRInt32     inContentOffset,
6224:                                             PRBool                  inHint,
6224:                                             PRInt32*                outFrameContentOffset,
6224:                                             nsIFrame*               *outChildFrame);
6224:   
6224:   virtual PRBool IsVisibleInSelection(nsISelection* aSelection);
6224:   
6224:   virtual PRBool IsEmpty();
6224:   virtual PRBool IsSelfEmpty() { return IsEmpty(); }
6224:   
6224:   /**
6224:    * @return PR_TRUE if this text frame ends with a newline character.  It
6224:    * should return PR_FALSE if this is not a text frame.
6224:    */
6224:   virtual PRBool HasTerminalNewline() const;
6224: 
7677:   /**
7677:    * Returns true if this text frame is logically adjacent to the end of the
7677:    * line.
7677:    */
7677:   PRBool IsAtEndOfLine() const;
7677:   
6224: #ifdef ACCESSIBILITY
6224:   NS_IMETHOD GetAccessible(nsIAccessible** aAccessible);
6224: #endif
6224:   
6224:   virtual void MarkIntrinsicWidthsDirty();
6224:   virtual nscoord GetMinWidth(nsIRenderingContext *aRenderingContext);
6224:   virtual nscoord GetPrefWidth(nsIRenderingContext *aRenderingContext);
6224:   virtual void AddInlineMinWidth(nsIRenderingContext *aRenderingContext,
6224:                                  InlineMinWidthData *aData);
6224:   virtual void AddInlinePrefWidth(nsIRenderingContext *aRenderingContext,
6224:                                   InlinePrefWidthData *aData);
6224:   virtual nsSize ComputeSize(nsIRenderingContext *aRenderingContext,
6224:                              nsSize aCBSize, nscoord aAvailableWidth,
6224:                              nsSize aMargin, nsSize aBorder, nsSize aPadding,
6224:                              PRBool aShrinkWrap);
6862:   virtual nsRect ComputeTightBounds(gfxContext* aContext) const;
6224:   NS_IMETHOD Reflow(nsPresContext* aPresContext,
6224:                     nsHTMLReflowMetrics& aMetrics,
6224:                     const nsHTMLReflowState& aReflowState,
6224:                     nsReflowStatus& aStatus);
6224:   virtual PRBool CanContinueTextRun() const;
8514:   // Method that is called for a text frame that is logically
8514:   // adjacent to the end of the line (i.e. followed only by empty text frames,
8514:   // placeholders or inlines containing such).
8514:   struct TrimOutput {
8514:     // true if we trimmed some space or changed metrics in some other way.
8514:     // In this case, we should call RecomputeOverflowRect on this frame.
8514:     PRPackedBool mChanged;
8514:     // true if the last character is not justifiable so should be subtracted
8514:     // from the count of justifiable characters in the frame, since the last
8514:     // character in a line is not justifiable.
8514:     PRPackedBool mLastCharIsJustifiable;
8514:     // an amount to *subtract* from the frame's width (zero if !mChanged)
8514:     nscoord      mDeltaWidth;
8514:   };
8514:   TrimOutput TrimTrailingWhiteSpace(nsIRenderingContext* aRC);
6224:   virtual nsresult GetRenderedText(nsAString* aString = nsnull,
6224:                                    gfxSkipChars* aSkipChars = nsnull,
6224:                                    gfxSkipCharsIterator* aSkipIter = nsnull,
6224:                                    PRUint32 aSkippedStartOffset = 0,
6224:                                    PRUint32 aSkippedMaxLength = PR_UINT32_MAX);
6224: 
6224:   nsRect RecomputeOverflowRect();
6224: 
6224:   void AddInlineMinWidthForFlow(nsIRenderingContext *aRenderingContext,
6224:                                 nsIFrame::InlineMinWidthData *aData);
6224:   void AddInlinePrefWidthForFlow(nsIRenderingContext *aRenderingContext,
6224:                                  InlinePrefWidthData *aData);
6224: 
6224:   gfxFloat GetSnappedBaselineY(gfxContext* aContext, gfxFloat aY);
6224: 
6224:   // primary frame paint method called from nsDisplayText
6224:   void PaintText(nsIRenderingContext* aRenderingContext, nsPoint aPt,
6224:                  const nsRect& aDirtyRect);
6224:   // helper: paint quirks-mode CSS text decorations
6224:   void PaintTextDecorations(gfxContext* aCtx, const gfxRect& aDirtyRect,
6224:                             const gfxPoint& aFramePt,
6224:                             const gfxPoint& aTextBaselinePt,
6224:                             nsTextPaintStyle& aTextStyle,
6224:                             PropertyProvider& aProvider);
6224:   // helper: paint text frame when we're impacted by at least one selection.
6224:   // Return PR_FALSE if the text was not painted and we should continue with
6224:   // the fast path.
6224:   PRBool PaintTextWithSelection(gfxContext* aCtx,
6224:                                 const gfxPoint& aFramePt,
6224:                                 const gfxPoint& aTextBaselinePt,
6224:                                 const gfxRect& aDirtyRect,
6224:                                 PropertyProvider& aProvider,
6224:                                 nsTextPaintStyle& aTextPaintStyle);
6224:   // helper: paint text with foreground and background colors determined
6224:   // by selection(s). Also computes a mask of all selection types applying to
6224:   // our text, returned in aAllTypes.
6224:   void PaintTextWithSelectionColors(gfxContext* aCtx,
6224:                                     const gfxPoint& aFramePt,
6224:                                     const gfxPoint& aTextBaselinePt,
6224:                                     const gfxRect& aDirtyRect,
6224:                                     PropertyProvider& aProvider,
6224:                                     nsTextPaintStyle& aTextPaintStyle,
6224:                                     SelectionDetails* aDetails,
6224:                                     SelectionType* aAllTypes);
6224:   // helper: paint text decorations for text selected by aSelectionType
6224:   void PaintTextSelectionDecorations(gfxContext* aCtx,
6224:                                      const gfxPoint& aFramePt,
6224:                                      const gfxPoint& aTextBaselinePt,
6224:                                      const gfxRect& aDirtyRect,
6224:                                      PropertyProvider& aProvider,
6224:                                      nsTextPaintStyle& aTextPaintStyle,
6224:                                      SelectionDetails* aDetails,
6224:                                      SelectionType aSelectionType);
6224: 
6224:   PRInt16 GetSelectionStatus(PRInt16* aSelectionFlags);
6224: 
6224: #ifdef DEBUG
8253:   void ToCString(nsCString& aBuf, PRInt32* aTotalContentLength) const;
6224: #endif
6224: 
6224:   PRInt32 GetContentOffset() const { return mContentOffset; }
9733:   PRInt32 GetContentLength() const
9733:   {
9733:     NS_ASSERTION(GetContentEnd() - mContentOffset >= 0, "negative length");
9733:     return GetContentEnd() - mContentOffset;
9733:   }
6224:   PRInt32 GetContentEnd() const;
6224:   // This returns the length the frame thinks it *should* have after it was
6224:   // last reflowed (0 if it hasn't been reflowed yet). This should be used only
6224:   // when setting up the text offsets for a new continuation frame.
6224:   PRInt32 GetContentLengthHint() const { return mContentLengthHint; }
6224: 
6224:   // Compute the length of the content mapped by this frame
6224:   // and all its in-flow siblings. Basically this means starting at mContentOffset
6224:   // and going to the end of the text node or the next bidi continuation
6224:   // boundary.
6224:   PRInt32 GetInFlowContentLength();
6224: 
6224:   // Clears out mTextRun from this frame and all other frames that hold a reference
6224:   // to it, then deletes the textrun.
6224:   void ClearTextRun();
6224:   /**
6224:    * Acquires the text run for this content, if necessary.
6224:    * @param aRC the rendering context to use as a reference for creating
6224:    * the textrun, if available (if not, we'll create one which will just be slower)
6224:    * @param aBlock the block ancestor for this frame, or nsnull if unknown
6224:    * @param aLine the line that this frame is on, if any, or nsnull if unknown
6224:    * @param aFlowEndInTextRun if non-null, this returns the textrun offset of
6224:    * end of the text associated with this frame and its in-flow siblings
6224:    * @return a gfxSkipCharsIterator set up to map DOM offsets for this frame
6224:    * to offsets into the textrun; its initial offset is set to this frame's
6224:    * content offset
6224:    */
6862:   gfxSkipCharsIterator EnsureTextRun(gfxContext* aReferenceContext = nsnull,
6224:                                      nsIFrame* aLineContainer = nsnull,
6224:                                      const nsLineList::iterator* aLine = nsnull,
6224:                                      PRUint32* aFlowEndInTextRun = nsnull);
6224: 
6224:   gfxTextRun* GetTextRun() { return mTextRun; }
6224:   void SetTextRun(gfxTextRun* aTextRun) { mTextRun = aTextRun; }
6224: 
6224:   // Get the DOM content range mapped by this frame after excluding
6224:   // whitespace subject to start-of-line and end-of-line trimming.
6224:   // The textrun must have been created before calling this.
6224:   struct TrimmedOffsets {
6224:     PRInt32 mStart;
6224:     PRInt32 mLength;
6224:     PRInt32 GetEnd() { return mStart + mLength; }
6224:   };
6224:   TrimmedOffsets GetTrimmedOffsets(const nsTextFragment* aFrag,
6224:                                    PRBool aTrimAfter);
6224: 
6224: protected:
6224:   virtual ~nsTextFrame();
6224:   
6224:   nsIFrame*   mNextContinuation;
6224:   // The key invariant here is that mContentOffset never decreases along
6224:   // a next-continuation chain. And of course mContentOffset is always <= the
6224:   // the text node's content length, and the mContentOffset for the first frame
6224:   // is always 0. Furthermore the text mapped by a frame is determined by
6224:   // GetContentOffset() and GetContentLength()/GetContentEnd(), which get
6224:   // the length from the difference between this frame's offset and the next
6224:   // frame's offset, or the text length if there is no next frame. This means
6224:   // the frames always map the text node without overlapping or leaving any gaps.
6224:   PRInt32     mContentOffset;
6224:   // This does *not* indicate the length of text currently mapped by the frame;
6224:   // instead it's a hint saying that this frame *wants* to map this much text
6224:   // so if we create a new continuation, this is where that continuation should
6224:   // start.
6224:   PRInt32     mContentLengthHint;
6224:   nscoord     mAscent;
6224:   gfxTextRun* mTextRun;
6224: 
6224:   SelectionDetails* GetSelectionDetails();
6224:   
6224:   void AdjustSelectionPointsForBidi(SelectionDetails *sdptr,
6224:                                     PRInt32 textLength,
6224:                                     PRBool isRTLChars,
6224:                                     PRBool isOddLevel,
6224:                                     PRBool isBidiSystem);
6224: };
6224: 
6224: #endif
