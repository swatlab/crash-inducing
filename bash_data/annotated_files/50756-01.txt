    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim:set ts=2 sw=2 sts=2 et cindent: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is Google Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *  Darin Fisher <darin@meer.net>
    1:  *  Ben Turner <mozilla@songbirdnest.com>
21647:  *  Robert Strong <robert.bugzilla@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include <stdlib.h>
    1: #include <stdio.h>
    1: #include "nsUpdateDriver.h"
    1: #include "nsXULAppAPI.h"
    1: #include "nsAppRunner.h"
    1: #include "nsILocalFile.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsString.h"
    1: #include "nsPrintfCString.h"
    1: #include "prproces.h"
    1: #include "prlog.h"
21647: #include "nsVersionComparator.h"
    1: 
    1: #ifdef XP_MACOSX
    1: #include "nsILocalFileMac.h"
    1: #include "nsCommandLineServiceMac.h"
    1: #endif
    1: 
    1: #if defined(XP_WIN)
    1: # include <direct.h>
    1: # include <process.h>
    1: # include <windows.h>
    1: # define getcwd(path, size) _getcwd(path, size)
    1: # define getpid() GetCurrentProcessId()
    1: #elif defined(XP_OS2)
    1: # include <unistd.h>
    1: # define INCL_DOSFILEMGR
    1: # include <os2.h>
    1: #elif defined(XP_UNIX) || defined(XP_BEOS)
    1: # include <unistd.h>
    1: #endif
    1: 
    1: //
    1: // We use execv to spawn the updater process on all UNIX systems except Mac OSX
    1: // since it is known to cause problems on the Mac.  Windows has execv, but it
    1: // is a faked implementation that doesn't really replace the current process.
    1: // Instead it spawns a new process, so we gain nothing from using execv on
    1: // Windows.
    1: //
    1: // On platforms where we are not calling execv, we may need to make the
    1: // udpaterfail executable wait for the calling process to exit.  Otherwise, the
    1: // updater may have trouble modifying our executable image (because it might
    1: // still be in use).  This is accomplished by passing our PID to the updater so
    1: // that it can wait for us to exit.  This is not perfect as there is a race
    1: // condition that could bite us.  It's possible that the calling process could
    1: // exit before the updater waits on the specified PID, and in the meantime a
    1: // new process with the same PID could be created.  This situation is unlikely,
    1: // however, given the way most operating systems recycle PIDs.  We'll take our
    1: // chances ;-)
    1: //
    1: // A similar #define lives in updater.cpp and should be kept in sync with this.
    1: //
    1: #if defined(XP_UNIX) && !defined(XP_MACOSX)
    1: #define USE_EXECV
    1: #endif
    1: 
    1: #ifdef PR_LOGGING
    1: static PRLogModuleInfo *sUpdateLog = PR_NewLogModule("updatedriver");
    1: #endif
    1: #define LOG(args) PR_LOG(sUpdateLog, PR_LOG_DEBUG, args)
    1: 
    1: #ifdef XP_WIN
    1: static const char kUpdaterBin[] = "updater.exe";
    1: #else
    1: static const char kUpdaterBin[] = "updater";
    1: #endif
    1: static const char kUpdaterINI[] = "updater.ini";
    1: #ifdef XP_MACOSX
    1: static const char kUpdaterApp[] = "updater.app";
    1: #endif
25429: #if defined(XP_UNIX) && !defined(XP_MACOSX)
25429: static const char kUpdaterPNG[] = "updater.png";
25429: #endif
    1: 
    1: static nsresult
    1: GetCurrentWorkingDir(char *buf, size_t size)
    1: {
    1:   // Cannot use NS_GetSpecialDirectory because XPCOM is not yet initialized.
    1:   // This code is duplicated from xpcom/io/SpecialSystemDirectory.cpp:
    1: 
    1: #if defined(XP_OS2)
    1:   if (DosQueryPathInfo( ".", FIL_QUERYFULLNAME, buf, size))
    1:     return NS_ERROR_FAILURE;
10508: #elif defined(XP_WIN)
30893:   wchar_t wpath[MAX_PATH];
30893:   if (!_wgetcwd(wpath, size))
10508:     return NS_ERROR_FAILURE;
10508:   NS_ConvertUTF16toUTF8 path(wpath);
10508:   strncpy(buf, path.get(), size);
    1: #else
    1:   if(!getcwd(buf, size))
    1:     return NS_ERROR_FAILURE;
    1: #endif
    1:   return NS_OK;
    1: }
    1: 
    1: #if defined(XP_MACOSX)
    1: 
    1: // This is a copy of OS X's XRE_GetBinaryPath from nsAppRunner.cpp with the
    1: // gBinaryPath check removed so that the updater can reload the stub executable
    1: // instead of xulrunner-bin. See bug 349737.
    1: static nsresult
    1: GetXULRunnerStubPath(const char* argv0, nsILocalFile* *aResult)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsILocalFile> lf;
    1: 
    1:   NS_NewNativeLocalFile(EmptyCString(), PR_TRUE, getter_AddRefs(lf));
    1:   nsCOMPtr<nsILocalFileMac> lfm (do_QueryInterface(lf));
    1:   if (!lfm)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // Works even if we're not bundled.
    1:   CFBundleRef appBundle = CFBundleGetMainBundle();
    1:   if (!appBundle)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   CFURLRef bundleURL = CFBundleCopyExecutableURL(appBundle);
    1:   if (!bundleURL)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   FSRef fileRef;
    1:   if (!CFURLGetFSRef(bundleURL, &fileRef)) {
    1:     CFRelease(bundleURL);
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   rv = lfm->InitWithFSRef(&fileRef);
    1:   CFRelease(bundleURL);
    1: 
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   NS_ADDREF(*aResult = lf);
    1:   return NS_OK;
    1: }
    1: #endif /* XP_MACOSX */
    1: 
    1: static PRBool
    1: GetFile(nsIFile *dir, const nsCSubstring &name, nsCOMPtr<nsILocalFile> &result)
    1: {
    1:   nsresult rv;
    1:   
21647:   nsCOMPtr<nsIFile> file;
21647:   rv = dir->Clone(getter_AddRefs(file));
    1:   if (NS_FAILED(rv))
    1:     return PR_FALSE;
    1: 
21647:   rv = file->AppendNative(name);
    1:   if (NS_FAILED(rv))
    1:     return PR_FALSE;
    1: 
21647:   result = do_QueryInterface(file, &rv);
    1:   return NS_SUCCEEDED(rv);
    1: }
    1: 
    1: static PRBool
    1: GetStatusFile(nsIFile *dir, nsCOMPtr<nsILocalFile> &result)
    1: {
    1:   return GetFile(dir, NS_LITERAL_CSTRING("update.status"), result);
    1: }
    1: 
    1: static PRBool
    1: IsPending(nsILocalFile *statusFile)
    1: {
    1:   nsresult rv;
    1: 
    1:   FILE *fp;
    1:   rv = statusFile->OpenANSIFileDesc("r", &fp);
    1:   if (NS_FAILED(rv))
    1:     return PR_FALSE;
    1: 
    1:   char buf[32];
    1:   char *result = fgets(buf, sizeof(buf), fp);
    1:   fclose(fp);
    1:   if (!result)
    1:     return PR_FALSE;
    1:   
    1:   const char kPending[] = "pending";
    1:   return (strncmp(buf, kPending, sizeof(kPending) - 1) == 0);
    1: }
    1: 
    1: static PRBool
    1: SetStatus(nsILocalFile *statusFile, const char *status)
    1: {
    1:   FILE *fp;
    1:   nsresult rv = statusFile->OpenANSIFileDesc("w", &fp);
    1:   if (NS_FAILED(rv))
    1:     return PR_FALSE;
    1: 
    1:   fprintf(fp, "%s\n", status);
    1:   fclose(fp);
    1:   return PR_TRUE;
    1: }
    1: 
    1: static PRBool
21647: GetVersionFile(nsIFile *dir, nsCOMPtr<nsILocalFile> &result)
21647: {
21647:   return GetFile(dir, NS_LITERAL_CSTRING("update.version"), result);
21647: }
21647: 
21647: // Compares the current application version with the update's application
21647: // version.
21647: static PRBool
21647: IsOlderVersion(nsILocalFile *versionFile, const char *&appVersion)
21647: {
21647:   nsresult rv;
21647: 
21647:   FILE *fp;
21647:   rv = versionFile->OpenANSIFileDesc("r", &fp);
21647:   if (NS_FAILED(rv))
21647:     return PR_TRUE;
21647: 
21647:   char buf[32];
21647:   char *result = fgets(buf, sizeof(buf), fp);
21647:   fclose(fp);
21647:   if (!result)
21647:     return PR_TRUE;
21647: 
29247:   // Trim off any trailing newline
29247:   int len = strlen(result);
29247:   if (len > 0 && result[len - 1] == '\n')
29247:     result[len - 1] = '\0';
29247: 
21647:   // If the update xml doesn't provide the application version the file will
21647:   // contain the string "null" and it is assumed that the update is not older.
21647:   const char kNull[] = "null";
21647:   if (strncmp(buf, kNull, sizeof(kNull) - 1) == 0)
21647:     return PR_FALSE;
21647: 
21647:   if (NS_CompareVersions(appVersion, result) > 0)
21647:     return PR_TRUE;
21647: 
21647:   return PR_FALSE;
21647: }
21647: 
21647: static PRBool
16676: CopyFileIntoUpdateDir(nsIFile *parentDir, const char *leafName, nsIFile *updateDir)
    1: {
16676:   nsDependentCString leaf(leafName);
    1:   nsCOMPtr<nsIFile> file;
    1: 
    1:   // Make sure there is not an existing file in the target location.
16676:   nsresult rv = updateDir->Clone(getter_AddRefs(file));
    1:   if (NS_FAILED(rv))
    1:     return PR_FALSE;
    1:   rv = file->AppendNative(leaf);
    1:   if (NS_FAILED(rv))
    1:     return PR_FALSE;
    1:   file->Remove(PR_FALSE);
    1: 
    1:   // Now, copy into the target location.
16676:   rv = parentDir->Clone(getter_AddRefs(file));
    1:   if (NS_FAILED(rv))
    1:     return PR_FALSE;
    1:   rv = file->AppendNative(leaf);
    1:   if (NS_FAILED(rv))
    1:     return PR_FALSE;
    1:   rv = file->CopyToNative(updateDir, EmptyCString());
16676:   if (NS_FAILED(rv))
    1:     return PR_FALSE;
16676: 
16676:   return PR_TRUE;
    1: }
    1: 
16676: static PRBool
16676: CopyUpdaterIntoUpdateDir(nsIFile *greDir, nsIFile *appDir, nsIFile *updateDir,
16676:                          nsCOMPtr<nsIFile> &updater)
16676: {
16676:   // Copy the updater application from the GRE and the updater ini from the app
16676: #if defined(XP_MACOSX)
16676:   if (!CopyFileIntoUpdateDir(greDir, kUpdaterApp, updateDir))
16676:     return PR_FALSE;
16676: #else
16676:   if (!CopyFileIntoUpdateDir(greDir, kUpdaterBin, updateDir))
16676:     return PR_FALSE;
16676: #endif
16676:   CopyFileIntoUpdateDir(appDir, kUpdaterINI, updateDir);
25429: #if defined(XP_UNIX) && !defined(XP_MACOSX)
25429:   nsCOMPtr<nsIFile> iconDir;
25429:   appDir->Clone(getter_AddRefs(iconDir));
25429:   iconDir->AppendNative(NS_LITERAL_CSTRING("icons"));
25429:   if (!CopyFileIntoUpdateDir(iconDir, kUpdaterPNG, updateDir))
25429:     return PR_FALSE;
25429: #endif
    1:   // Finally, return the location of the updater binary.
16676:   nsresult rv = updateDir->Clone(getter_AddRefs(updater));
    1:   if (NS_FAILED(rv))
    1:     return PR_FALSE;
    1: #if defined(XP_MACOSX)
    1:   rv  = updater->AppendNative(NS_LITERAL_CSTRING(kUpdaterApp));
    1:   rv |= updater->AppendNative(NS_LITERAL_CSTRING("Contents"));
    1:   rv |= updater->AppendNative(NS_LITERAL_CSTRING("MacOS"));
    1:   if (NS_FAILED(rv))
    1:     return PR_FALSE;
    1: #endif
    1:   rv = updater->AppendNative(NS_LITERAL_CSTRING(kUpdaterBin));
    1:   return NS_SUCCEEDED(rv); 
    1: }
    1: 
    1: static void
    1: ApplyUpdate(nsIFile *greDir, nsIFile *updateDir, nsILocalFile *statusFile,
    1:             nsIFile *appDir, int appArgc, char **appArgv)
    1: {
10399:   nsresult rv;
10399: 
    1:   // Steps:
    1:   //  - mark update as 'applying'
    1:   //  - copy updater into update dir
    1:   //  - run updater w/ appDir as the current working dir
    1: 
    1:   nsCOMPtr<nsIFile> updater;
    1:   if (!CopyUpdaterIntoUpdateDir(greDir, appDir, updateDir, updater)) {
    1:     LOG(("failed copying updater\n"));
    1:     return;
    1:   }
    1: 
    1:   // We need to use the value returned from XRE_GetBinaryPath when attempting
    1:   // to restart the running application.
    1:   nsCOMPtr<nsILocalFile> appFile;
    1: 
    1: #if defined(XP_MACOSX)
    1:   // On OS X we need to pass the location of the xulrunner-stub executable
    1:   // rather than xulrunner-bin. See bug 349737.
    1:   GetXULRunnerStubPath(appArgv[0], getter_AddRefs(appFile));
    1: #else
    1:   XRE_GetBinaryPath(appArgv[0], getter_AddRefs(appFile));
    1: #endif
    1: 
    1:   if (!appFile)
    1:     return;
10399: 
10399: #ifdef XP_WIN
10399:   nsAutoString appFilePathW;
10399:   rv = appFile->GetPath(appFilePathW);
10399:   if (NS_FAILED(rv))
10399:     return;
10399:   NS_ConvertUTF16toUTF8 appFilePath(appFilePathW);
10399: 
10399:   nsAutoString updaterPathW;
10399:   rv = updater->GetPath(updaterPathW);
10399:   if (NS_FAILED(rv))
10399:     return;
10399: 
10399:   NS_ConvertUTF16toUTF8 updaterPath(updaterPathW);
10399: 
10399: #else
    1:   nsCAutoString appFilePath;
10399:   rv = appFile->GetNativePath(appFilePath);
    1:   if (NS_FAILED(rv))
    1:     return;
    1:   
    1:   nsCAutoString updaterPath;
    1:   rv = updater->GetNativePath(updaterPath);
    1:   if (NS_FAILED(rv))
    1:     return;
    1: 
10399: #endif
 9738: 
    1:   // Get the directory to which the update will be applied. On Mac OSX we need
    1:   // to apply the update to the Foo.app directory which is the parent of the
    1:   // parent of the appDir. On other platforms we will just apply to the appDir.
10399: #if defined(XP_MACOSX)
    1:   nsCAutoString applyToDir;
    1:   {
    1:     nsCOMPtr<nsIFile> parentDir1, parentDir2;
    1:     rv = appDir->GetParent(getter_AddRefs(parentDir1));
    1:     if (NS_FAILED(rv))
    1:       return;
    1:     rv = parentDir1->GetParent(getter_AddRefs(parentDir2));
    1:     if (NS_FAILED(rv))
    1:       return;
    1:     rv = parentDir2->GetNativePath(applyToDir);
    1:   }
10399: #elif defined(XP_WIN)
10399:   nsAutoString applyToDir;
10399:   rv = appDir->GetPath(applyToDir);
    1: #else
10399:   nsCAutoString applyToDir;
    1:   rv = appDir->GetNativePath(applyToDir);
    1: #endif
    1:   if (NS_FAILED(rv))
    1:     return;
    1: 
10508: #if defined(XP_WIN)
10508:   nsAutoString updateDirPathW;
10508:   rv = updateDir->GetPath(updateDirPathW);
10508: 
10508:   NS_ConvertUTF16toUTF8 updateDirPath(updateDirPathW);
10508: #else
    1:   nsCAutoString updateDirPath;
    1:   rv = updateDir->GetNativePath(updateDirPath);
10508: #endif
10508: 
    1:   if (NS_FAILED(rv))
    1:     return;
    1: 
    1:   // Get the current working directory.
    1:   char workingDirPath[MAXPATHLEN];
    1:   rv = GetCurrentWorkingDir(workingDirPath, sizeof(workingDirPath));
    1:   if (NS_FAILED(rv))
    1:     return;
    1: 
    1:   if (!SetStatus(statusFile, "applying")) {
    1:     LOG(("failed setting status to 'applying'\n"));
    1:     return;
    1:   }
    1: 
    1:   // Construct the PID argument for this process.  If we are using execv, then
    1:   // we pass "0" which is then ignored by the updater.
    1: #if defined(USE_EXECV)
    1:   NS_NAMED_LITERAL_CSTRING(pid, "0");
    1: #else
    1:   nsCAutoString pid;
    1:   pid.AppendInt((PRInt32) getpid());
    1: #endif
    1: 
    1:   int argc = appArgc + 4;
    1:   char **argv = new char*[argc + 1];
    1:   if (!argv)
    1:     return;
    1:   argv[0] = (char*) updaterPath.get();
    1:   argv[1] = (char*) updateDirPath.get();
    1:   argv[2] = (char*) pid.get();
    1:   if (appArgc) {
    1:     argv[3] = workingDirPath;
    1:     argv[4] = (char*) appFilePath.get();
    1:     for (int i = 1; i < appArgc; ++i)
    1:       argv[4 + i] = appArgv[i];
    1:     argv[4 + appArgc] = nsnull;
    1:   } else {
    1:     argv[3] = nsnull;
    1:     argc = 3;
    1:   }
    1: 
    1:   LOG(("spawning updater process [%s]\n", updaterPath.get()));
    1: 
    1: #if defined(USE_EXECV)
    1:   chdir(applyToDir.get());
    1:   execv(updaterPath.get(), argv);
    1: #elif defined(XP_WIN)
10399:   _wchdir(applyToDir.get());
    1: 
23244:   if (!WinLaunchChild(updaterPathW.get(), appArgc + 4, argv))
    1:     return;
    1:   _exit(0);
    1: #else
    1:   PRStatus status;
    1:   PRProcessAttr *attr;
    1:   
    1:   attr = PR_NewProcessAttr();
    1:   if (!attr)
    1:     goto end;
    1: 
    1:   status = PR_ProcessAttrSetCurrentDirectory(attr, applyToDir.get());
    1:   if (status != PR_SUCCESS)
    1:     goto end;
    1: 
    1: #ifdef XP_MACOSX
43334:   CommandLineServiceMac::SetupMacCommandLine(argc, argv, PR_TRUE);
    1: #endif
    1: 
    1:   PR_CreateProcessDetached(updaterPath.get(), argv, nsnull, attr);
    1:   exit(0);
    1: 
    1: end:
    1:   PR_DestroyProcessAttr(attr); 
    1:   delete[] argv;
    1: #endif
    1: }
    1: 
    1: nsresult
    1: ProcessUpdates(nsIFile *greDir, nsIFile *appDir, nsIFile *updRootDir,
21647:                int argc, char **argv, const char *&appVersion)
    1: {
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsIFile> updatesDir;
    1:   rv = updRootDir->Clone(getter_AddRefs(updatesDir));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1:   rv = updatesDir->AppendNative(NS_LITERAL_CSTRING("updates"));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
50756:   rv = updatesDir->AppendNative(NS_LITERAL_CSTRING("0"));
50756:   if (NS_FAILED(rv))
50756:     return rv;
50756: 
    1:   PRBool exists;
    1:   rv = updatesDir->Exists(&exists);
    1:   if (NS_FAILED(rv) || !exists)
    1:     return rv;
    1: 
    1:   nsCOMPtr<nsILocalFile> statusFile;
50756:   if (GetStatusFile(updatesDir, statusFile) && IsPending(statusFile)) {
21647:     nsCOMPtr<nsILocalFile> versionFile;
21647:     // Remove the update if the update application version file doesn't exist
21647:     // or if the update's application version is less than the current
21647:     // application version.
50756:     if (!GetVersionFile(updatesDir, versionFile) ||
21647:         IsOlderVersion(versionFile, appVersion)) {
50756:       updatesDir->Remove(PR_TRUE);
50756:     } else {
50756:       ApplyUpdate(greDir, updatesDir, statusFile, appDir, argc, argv);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
