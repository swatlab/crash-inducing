     1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
     1:  * vim: set ts=4 sw=4 et tw=80:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "mozJSSubScriptLoader.h"
 73638: #include "mozJSLoaderUtils.h"
     1: 
     1: #include "nsIServiceManager.h"
     1: #include "nsIXPConnect.h"
     1: 
     1: #include "nsIURI.h"
     1: #include "nsIIOService.h"
     1: #include "nsIChannel.h"
     1: #include "nsIInputStream.h"
     1: #include "nsNetCID.h"
     1: #include "nsDependentString.h"
 13211: #include "nsAutoPtr.h"
 13211: #include "nsNetUtil.h"
 13416: #include "nsIProtocolHandler.h"
 13416: #include "nsIFileURL.h"
 55135: #include "nsScriptLoader.h"
     1: 
     1: #include "jsapi.h"
 13416: #include "jsdbgapi.h"
 67915: #include "jsfriendapi.h"
 91900: #include "nsJSPrincipals.h"
     1: 
 42480: #include "mozilla/FunctionTimer.h"
 73638: #include "mozilla/scache/StartupCache.h"
 73638: #include "mozilla/scache/StartupCacheUtils.h"
 73638: 
 73638: using namespace mozilla::scache;
 42480: 
     1: /* load() error msgs, XXX localize? */
     1: #define LOAD_ERROR_NOSERVICE "Error creating IO Service."
 13211: #define LOAD_ERROR_NOURI "Error creating URI (invalid URL scheme?)"
 13211: #define LOAD_ERROR_NOSCHEME "Failed to get URI scheme.  This is bad."
 13416: #define LOAD_ERROR_URI_NOT_LOCAL "Trying to load a non-local URI."
     1: #define LOAD_ERROR_NOSTREAM  "Error opening input stream (invalid filename?)"
     1: #define LOAD_ERROR_NOCONTENT "ContentLength not available (not a local URL?)"
 55135: #define LOAD_ERROR_BADCHARSET "Error converting to specified charset"
     1: #define LOAD_ERROR_BADREAD   "File Read Error."
     1: #define LOAD_ERROR_READUNDERFLOW "File Read Error (underflow.)"
 13211: #define LOAD_ERROR_NOPRINCIPALS "Failed to get principals."
 13211: #define LOAD_ERROR_NOSPEC "Failed to get URI spec.  This is bad."
     1: 
     1: // We just use the same reporter as the component loader
 18907: extern void
     1: mozJSLoaderErrorReporter(JSContext *cx, const char *message, JSErrorReport *rep);
     1: 
106838: mozJSSubScriptLoader::mozJSSubScriptLoader() : mSystemPrincipal(nullptr)
     1: {
     1: }
     1: 
     1: mozJSSubScriptLoader::~mozJSSubScriptLoader()
     1: {
     1:     /* empty */
     1: }
     1: 
     1: NS_IMPL_THREADSAFE_ISUPPORTS1(mozJSSubScriptLoader, mozIJSSubScriptLoader)
     1: 
 73638: static nsresult
 73638: ReportError(JSContext *cx, const char *msg)
 73638: {
 73638:     JS_SetPendingException(cx, STRING_TO_JSVAL(JS_NewStringCopyZ(cx, msg)));
 73638:     return NS_OK;
 73638: }
 73638: 
 73638: nsresult
 73638: mozJSSubScriptLoader::ReadScript(nsIURI *uri, JSContext *cx, JSObject *target_obj,
 84864:                                  const nsAString& charset, const char *uriStr,
 74264:                                  nsIIOService *serv, nsIPrincipal *principal,
 78492:                                  JSScript **scriptp)
 73638: {
 73638:     nsCOMPtr<nsIChannel>     chan;
 73638:     nsCOMPtr<nsIInputStream> instream;
 73638:     JSErrorReporter  er;
 73638: 
 73638:     nsresult rv;
 73638:     // Instead of calling NS_OpenURI, we create the channel ourselves and call
 73638:     // SetContentType, to avoid expensive MIME type lookups (bug 632490).
 73638:     rv = NS_NewChannel(getter_AddRefs(chan), uri, serv,
106838:                        nullptr, nullptr, nsIRequest::LOAD_NORMAL);
 73638:     if (NS_SUCCEEDED(rv)) {
 73638:         chan->SetContentType(NS_LITERAL_CSTRING("application/javascript"));
 73638:         rv = chan->Open(getter_AddRefs(instream));
 73638:     }
 73638: 
 73638:     if (NS_FAILED(rv)) {
 73638:         return ReportError(cx, LOAD_ERROR_NOSTREAM);
 73638:     }
 73638: 
108991:     int32_t len = -1;
 73638: 
 73638:     rv = chan->GetContentLength(&len);
 73638:     if (NS_FAILED(rv) || len == -1) {
 73638:         return ReportError(cx, LOAD_ERROR_NOCONTENT);
 73638:     }
 73638: 
 73638:     nsCString buf;
 73638:     rv = NS_ReadInputStreamToString(instream, buf, len);
 73638:     if (NS_FAILED(rv))
 73638:         return rv;
 73638: 
 73638:     /* set our own error reporter so we can report any bad things as catchable
 73638:      * exceptions, including the source/line number */
 73638:     er = JS_SetErrorReporter(cx, mozJSLoaderErrorReporter);
 73638: 
107688:     JS::CompileOptions options(cx);
107688:     options.setPrincipals(nsJSPrincipals::get(principal))
110383:            .setFileAndLine(uriStr, 1);
107688:     JS::RootedObject target_obj_root(cx, target_obj);
 84864:     if (!charset.IsVoid()) {
 73638:         nsString script;
108991:         rv = nsScriptLoader::ConvertToUTF16(nullptr, reinterpret_cast<const uint8_t*>(buf.get()), len,
106838:                                             charset, nullptr, script);
 73638: 
 73638:         if (NS_FAILED(rv)) {
 73638:             return ReportError(cx, LOAD_ERROR_BADCHARSET);
 73638:         }
 73638: 
107688:         *scriptp = JS::Compile(cx, target_obj_root, options,
107688:                                reinterpret_cast<const jschar*>(script.get()), script.Length());
 73638:     } else {
110383:         // We only use LAZY_SOURCE when no special encoding is specified because
110383:         // the lazy source loader doesn't know the encoding.
110383:         options.setSourcePolicy(JS::CompileOptions::LAZY_SOURCE);
107688:         *scriptp = JS::Compile(cx, target_obj_root, options, buf.get(), len);
 73638:     }
 73638: 
 73638:     /* repent for our evil deeds */
 73638:     JS_SetErrorReporter(cx, er);
 73638: 
 73638:     return NS_OK;
 73638: }
 73638: 
 84864: NS_IMETHODIMP
 84864: mozJSSubScriptLoader::LoadSubScript(const nsAString& url,
 84864:                                     const JS::Value& target,
 84864:                                     const nsAString& charset,
 84864:                                     JSContext* cx,
 84864:                                     JS::Value* retval)
     1: {
     1:     /*
     1:      * Loads a local url and evals it into the current cx
     1:      * Synchronous (an async version would be cool too.)
     1:      *   url: The url to load.  Must be local so that it can be loaded
     1:      *        synchronously.
     1:      *   target_obj: Optional object to eval the script onto (defaults to context
     1:      *               global)
     1:      *   returns: Whatever jsval the script pointed to by the url returns.
     1:      * Should ONLY (O N L Y !) be called from JavaScript code.
     1:      */
     1: 
 84864:     nsresult rv = NS_OK;
     1: 
 42480: #ifdef NS_FUNCTION_TIMER
 42480:     NS_TIME_FUNCTION_FMT("%s (line %d) (url: %s)", MOZ_FUNCTION_NAME,
 84864:                          __LINE__, NS_LossyConvertUTF16toASCII(url).get());
 42480: #endif
 42480: 
 91900:     /* set the system principal if it's not here already */
 80389:     if (!mSystemPrincipal) {
     1:         nsCOMPtr<nsIScriptSecurityManager> secman =
     1:             do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID);
     1:         if (!secman)
 84864:             return NS_OK;
     1: 
     1:         rv = secman->GetSystemPrincipal(getter_AddRefs(mSystemPrincipal));
     1:         if (NS_FAILED(rv) || !mSystemPrincipal)
     1:             return rv;
     1:     }
     1: 
     1:     JSAutoRequest ar(cx);
     1: 
 84864:     JSObject* targetObj;
 84864:     if (!JS_ValueToObject(cx, target, &targetObj))
 84864:         return NS_ERROR_ILLEGAL_VALUE;
     1: 
 57812: 
 84864:     if (!targetObj) {
 84864:         // If the user didn't provide an object to eval onto, find the global
 84864:         // object by walking the parent chain of the calling object.
 84864:         nsCOMPtr<nsIXPConnect> xpc = do_GetService(nsIXPConnect::GetCID());
 84864:         NS_ENSURE_TRUE(xpc, NS_ERROR_FAILURE);
     1: 
106838:         nsAXPCNativeCallContext *cc = nullptr;
 84864:         rv = xpc->GetCurrentNativeCallContext(&cc);
 84864:         NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
     1:         nsCOMPtr<nsIXPConnectWrappedNative> wn;
     1:         rv = cc->GetCalleeWrapper(getter_AddRefs(wn));
 84864:         NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
 84864:         rv = wn->GetJSObject(&targetObj);
 84864:         NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
 86465:         targetObj = JS_GetGlobalForObject(cx, targetObj);
     1:     }
     1: 
 55678:     // Remember an object out of the calling compartment so that we
 55678:     // can properly wrap the result later.
 74264:     nsCOMPtr<nsIPrincipal> principal = mSystemPrincipal;
 84864:     JSObject *result_obj = targetObj;
 84864:     targetObj = JS_FindCompilationScope(cx, targetObj);
 84864:     if (!targetObj)
 74264:         return NS_ERROR_FAILURE;
 74264: 
 84864:     if (targetObj != result_obj) {
 74264:         nsCOMPtr<nsIScriptSecurityManager> secman =
 74264:             do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID);
 74264:         if (!secman)
 74264:             return NS_ERROR_FAILURE;
 74264: 
 84864:         rv = secman->GetObjectPrincipal(cx, targetObj, getter_AddRefs(principal));
 74264:         NS_ENSURE_SUCCESS(rv, rv);
 74264:     }
 55631: 
109257:     JSAutoCompartment ac(cx, targetObj);
     1: 
     1:     /* load up the url.  From here on, failures are reflected as ``custom''
     1:      * js exceptions */
 13211:     nsCOMPtr<nsIURI> uri;
 13211:     nsCAutoString uriStr;
 13211:     nsCAutoString scheme;
     1: 
106838:     JSScript* script = nullptr;
 13416: 
 13416:     // Figure out who's calling us
106838:     if (!JS_DescribeScriptedCaller(cx, &script, nullptr)) {
 95517:         // No scripted frame means we don't know who's calling, bail.
 13416:         return NS_ERROR_FAILURE;
 13416:     }
 13416: 
 74264:     // Suppress caching if we're compiling as content.
 74264:     StartupCache* cache = (principal == mSystemPrincipal)
 74264:                           ? StartupCache::GetSingleton()
106838:                           : nullptr;
     1:     nsCOMPtr<nsIIOService> serv = do_GetService(NS_IOSERVICE_CONTRACTID);
 73638:     if (!serv) {
 73638:         return ReportError(cx, LOAD_ERROR_NOSERVICE);
     1:     }
     1: 
 13211:     // Make sure to explicitly create the URI, since we'll need the
 13211:     // canonicalized spec.
106838:     rv = NS_NewURI(getter_AddRefs(uri), NS_LossyConvertUTF16toASCII(url).get(), nullptr, serv);
 13211:     if (NS_FAILED(rv)) {
 73638:         return ReportError(cx, LOAD_ERROR_NOURI);
     1:     }
     1: 
 13416:     rv = uri->GetSpec(uriStr);
 13416:     if (NS_FAILED(rv)) {
 73638:         return ReportError(cx, LOAD_ERROR_NOSPEC);
 13416:     }
 13416: 
 13211:     rv = uri->GetScheme(scheme);
 73638:     if (NS_FAILED(rv)) {
 73638:         return ReportError(cx, LOAD_ERROR_NOSCHEME);
 13211:     }
 13416: 
 80389:     if (!scheme.EqualsLiteral("chrome")) {
 13416:         // This might be a URI to a local file, though!
 52252:         nsCOMPtr<nsIURI> innerURI = NS_GetInnermostURI(uri);
 52252:         nsCOMPtr<nsIFileURL> fileURL = do_QueryInterface(innerURI);
 73638:         if (!fileURL) {
 73638:             return ReportError(cx, LOAD_ERROR_URI_NOT_LOCAL);
 13211:         }
 13211: 
 13416:         // For file URIs prepend the filename with the filename of the
 13416:         // calling script, and " -> ". See bug 418356.
 13416:         nsCAutoString tmp(JS_GetScriptFilename(cx, script));
 13416:         tmp.AppendLiteral(" -> ");
 13416:         tmp.Append(uriStr);
 13416: 
 13416:         uriStr = tmp;
 13416:     }
 13416: 
 73638:     bool writeScript = false;
 79734:     JSVersion version = JS_GetVersion(cx);
 73638:     nsCAutoString cachePath;
 73638:     cachePath.AppendPrintf("jssubloader/%d", version);
 74081:     PathifyURI(uri, cachePath);
 73638: 
106838:     script = nullptr;
 73638:     if (cache)
 93548:         rv = ReadCachedScript(cache, cachePath, cx, mSystemPrincipal, &script);
 78492:     if (!script) {
 84864:         rv = ReadScript(uri, cx, targetObj, charset,
 84864:                         static_cast<const char*>(uriStr.get()), serv,
 78492:                         principal, &script);
 73638:         writeScript = true;
 62189:     }
 62189: 
 78492:     if (NS_FAILED(rv) || !script)
 73638:         return rv;
     1: 
 84864:     bool ok = JS_ExecuteScriptVersion(cx, targetObj, script, retval, version);
     1: 
 73638:     if (ok) {
109257:         JSAutoCompartment rac(cx, result_obj);
109257:         if (!JS_WrapValue(cx, retval))
 55678:             return NS_ERROR_UNEXPECTED;
 55678:     }
 55678: 
 73638:     if (cache && ok && writeScript) {
 93548:         WriteCachedScript(cache, cachePath, cx, mSystemPrincipal, script);
 73638:     }
     1: 
     1:     return NS_OK;
 73638: }
