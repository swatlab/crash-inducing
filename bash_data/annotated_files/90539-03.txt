60891: /* vim: se cin sw=2 ts=2 et : */
60891: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
60891:  *
60891:  * ***** BEGIN LICENSE BLOCK *****
60891:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
60891:  *
60891:  * The contents of this file are subject to the Mozilla Public License Version
60891:  * 1.1 (the "License"); you may not use this file except in compliance with
60891:  * the License. You may obtain a copy of the License at
60891:  * http://www.mozilla.org/MPL/
60891:  *
60891:  * Software distributed under the License is distributed on an "AS IS" basis,
60891:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
60891:  * for the specific language governing rights and limitations under the
60891:  * License.
60891:  *
60891:  * The Original Code is mozilla.org code.
60891:  *
60891:  * The Initial Developer of the Original Code is
60891:  * Mozilla Foundation.
60891:  * Portions created by the Initial Developer are Copyright (C) 2011
60891:  * the Initial Developer. All Rights Reserved.
60891:  *
60891:  * Contributor(s):
60891:  *
60891:  * Alternatively, the contents of this file may be used under the terms of
60891:  * either the GNU General Public License Version 2 or later (the "GPL"), or
60891:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
60891:  * in which case the provisions of the GPL or the LGPL are applicable instead
60891:  * of those above. If you wish to allow use of your version of this file only
60891:  * under the terms of either the GPL or the LGPL, and not to allow others to
60891:  * use your version of this file under the terms of the MPL, indicate your
60891:  * decision by deleting the provisions above and replace them with the notice
60891:  * and other provisions required by the GPL or the LGPL. If you do not delete
60891:  * the provisions above, a recipient may use your version of this file under
60891:  * the terms of any one of the MPL, the GPL or the LGPL.
60891:  *
60891:  * ***** END LICENSE BLOCK ***** */
60891: 
80467: #include "mozilla/Util.h"
80467: 
60891: #include "GfxInfoBase.h"
60893: 
60891: #include "GfxInfoWebGL.h"
60893: #include "GfxDriverInfo.h"
60892: #include "nsCOMPtr.h"
60893: #include "nsCOMArray.h"
60893: #include "nsAutoPtr.h"
60892: #include "nsString.h"
90539: #include "nsUnicharUtils.h"
60893: #include "mozilla/Services.h"
84603: #include "mozilla/Observer.h"
60893: #include "nsIObserver.h"
60893: #include "nsIObserverService.h"
60893: #include "nsIDOMElement.h"
60893: #include "nsIDOMNode.h"
60893: #include "nsIDOMNodeList.h"
60893: #include "nsTArray.h"
70337: #include "mozilla/Preferences.h"
60891: 
70361: #if defined(MOZ_CRASHREPORTER)
61767: #include "nsExceptionHandler.h"
61767: #endif
61767: 
84603: using namespace mozilla::widget;
80467: using namespace mozilla;
80467: 
84603: nsTArray<GfxDriverInfo>* GfxInfoBase::mDriverInfo;
84603: bool GfxInfoBase::mDriverInfoObserverInitialized;
84603: 
84603: // Observes for shutdown so that the child GfxDriverInfo list is freed.
84603: class ShutdownObserver : public nsIObserver
84603: {
84603: public:
84603:   ShutdownObserver() {}
84603:   virtual ~ShutdownObserver() {}
84603: 
84603:   NS_DECL_ISUPPORTS
84603: 
84603:   NS_IMETHOD Observe(nsISupports *subject, const char *aTopic,
84603:                      const PRUnichar *aData)
84603:   {
84603:     MOZ_ASSERT(strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID) == 0);
84604: 
84603:     delete GfxInfoBase::mDriverInfo;
84603:     GfxInfoBase::mDriverInfo = nsnull;
84604: 
84604:     for (PRUint32 i = 0; i < DeviceFamilyMax; i++)
84604:       delete GfxDriverInfo::mDeviceFamilies[i];
84604: 
84604:     for (PRUint32 i = 0; i < DeviceVendorMax; i++)
84604:       delete GfxDriverInfo::mDeviceVendors[i];
84604: 
84603:     return NS_OK;
84603:   }
84603: };
84603: 
84603: NS_IMPL_ISUPPORTS1(ShutdownObserver, nsIObserver);
84603: 
84603: void InitGfxDriverInfoShutdownObserver()
84603: {
84603:   if (GfxInfoBase::mDriverInfoObserverInitialized)
84603:     return;
84603: 
84603:   GfxInfoBase::mDriverInfoObserverInitialized = true;
84603: 
84603:   nsCOMPtr<nsIObserverService> observerService = services::GetObserverService();
84603:   if (!observerService) {
84603:     NS_WARNING("Could not get observer service!");
84603:     return;
84603:   }
84603: 
84603:   ShutdownObserver *obs = new ShutdownObserver();
84603:   observerService->AddObserver(obs, NS_XPCOM_SHUTDOWN_OBSERVER_ID, false);
84603: }
84603: 
61767: extern "C" {
62252:   void StoreSpline(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy);
62252:   void CrashSpline(double tolerance, int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy);
61767: }
61767: 
62252: static int crash_ax;
62252: static int crash_ay;
62252: static int crash_bx;
62252: static int crash_by;
62252: static int crash_cx;
62252: static int crash_cy;
62252: static int crash_dx;
62252: static int crash_dy;
61767: 
61767: void
62252: StoreSpline(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy) {
61767:     crash_ax = ax;
61767:     crash_ay = ay;
61767:     crash_bx = bx;
61767:     crash_by = by;
61767:     crash_cx = cx;
61767:     crash_cy = cy;
61767:     crash_dx = dx;
61767:     crash_dy = dy;
61767: }
61767: 
61767: void
62252: CrashSpline(double tolerance, int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy) {
70361: #if defined(MOZ_CRASHREPORTER)
61767:   static bool annotated;
61767: 
61767:   if (!annotated) {
61767:     nsCAutoString note;
61767: 
61767:     note.AppendPrintf("curve ");
62252:     note.AppendPrintf("%x ", crash_ax);
62252:     note.AppendPrintf("%x, ", crash_ay);
62252:     note.AppendPrintf("%x ", crash_bx);
62252:     note.AppendPrintf("%x, ", crash_by);
62252:     note.AppendPrintf("%x ", crash_cx);
62252:     note.AppendPrintf("%x, ", crash_cy);
62252:     note.AppendPrintf("%x ", crash_dx);
62252:     note.AppendPrintf("%x\n", crash_dy);
62252:     note.AppendPrintf("crv-crash(%f): ", tolerance);
62252:     note.AppendPrintf("%x ", ax);
62252:     note.AppendPrintf("%x, ", ay);
62252:     note.AppendPrintf("%x ", bx);
62252:     note.AppendPrintf("%x, ", by);
62252:     note.AppendPrintf("%x ", cx);
62252:     note.AppendPrintf("%x, ", cy);
62252:     note.AppendPrintf("%x ", dx);
62252:     note.AppendPrintf("%x\n", dy);
61767: 
61767:     CrashReporter::AppendAppNotesToCrashReport(note);
61767:     annotated = true;
61767:   }
61767: #endif
61767: }
61767: 
61767: 
60891: using namespace mozilla::widget;
70337: using namespace mozilla;
60891: 
60893: NS_IMPL_ISUPPORTS3(GfxInfoBase, nsIGfxInfo, nsIObserver, nsISupportsWeakReference)
60891: 
60892: #define BLACKLIST_PREF_BRANCH "gfx.blacklist."
60892: #define SUGGESTED_VERSION_PREF BLACKLIST_PREF_BRANCH "suggested-driver-version"
60893: #define BLACKLIST_ENTRY_TAG_NAME "gfxBlacklistEntry"
60892: 
60892: static const char*
60892: GetPrefNameForFeature(PRInt32 aFeature)
60892: {
60892:   const char* name = nsnull;
60892:   switch(aFeature) {
60892:     case nsIGfxInfo::FEATURE_DIRECT2D:
60892:       name = BLACKLIST_PREF_BRANCH "direct2d";
60892:       break;
60892:     case nsIGfxInfo::FEATURE_DIRECT3D_9_LAYERS:
60892:       name = BLACKLIST_PREF_BRANCH "layers.direct3d9";
60892:       break;
60892:     case nsIGfxInfo::FEATURE_DIRECT3D_10_LAYERS:
60892:       name = BLACKLIST_PREF_BRANCH "layers.direct3d10";
60892:       break;
60892:     case nsIGfxInfo::FEATURE_DIRECT3D_10_1_LAYERS:
60892:       name = BLACKLIST_PREF_BRANCH "layers.direct3d10-1";
60892:       break;
60892:     case nsIGfxInfo::FEATURE_OPENGL_LAYERS:
60892:       name = BLACKLIST_PREF_BRANCH "layers.opengl";
60892:       break;
60892:     case nsIGfxInfo::FEATURE_WEBGL_OPENGL:
60892:       name = BLACKLIST_PREF_BRANCH "webgl.opengl";
60892:       break;
60892:     case nsIGfxInfo::FEATURE_WEBGL_ANGLE:
60892:       name = BLACKLIST_PREF_BRANCH "webgl.angle";
60892:       break;
81329:     case nsIGfxInfo::FEATURE_WEBGL_MSAA:
81329:       name = BLACKLIST_PREF_BRANCH "webgl.msaa";
81329:       break;
60892:     default:
60892:       break;
60892:   };
60892: 
60892:   return name;
60892: }
60892: 
60892: // Returns the value of the pref for the relevant feature in aValue.
60892: // If the pref doesn't exist, aValue is not touched, and returns false.
60892: static bool
60892: GetPrefValueForFeature(PRInt32 aFeature, PRInt32& aValue)
60892: {
60892:   const char *prefname = GetPrefNameForFeature(aFeature);
60892:   if (!prefname)
60892:     return false;
60892: 
80486:   aValue = false;
70337:   return NS_SUCCEEDED(Preferences::GetInt(prefname, &aValue));
60892: }
60892: 
60892: static void
60892: SetPrefValueForFeature(PRInt32 aFeature, PRInt32 aValue)
60892: {
60892:   const char *prefname = GetPrefNameForFeature(aFeature);
60892:   if (!prefname)
60892:     return;
60892: 
70337:   Preferences::SetInt(prefname, aValue);
60892: }
60892: 
60892: static void
60892: RemovePrefForFeature(PRInt32 aFeature)
60892: {
60892:   const char *prefname = GetPrefNameForFeature(aFeature);
60892:   if (!prefname)
60892:     return;
60892: 
70337:   Preferences::ClearUser(prefname);
60892: }
60892: 
60892: static bool
70337: GetPrefValueForDriverVersion(nsCString& aVersion)
60892: {
70976:   return NS_SUCCEEDED(Preferences::GetCString(SUGGESTED_VERSION_PREF,
70976:                                               &aVersion));
60892: }
60892: 
60892: static void
70976: SetPrefValueForDriverVersion(const nsAString& aVersion)
60892: {
70976:   Preferences::SetString(SUGGESTED_VERSION_PREF, aVersion);
60892: }
60892: 
60892: static void
60892: RemovePrefForDriverVersion()
60892: {
70337:   Preferences::ClearUser(SUGGESTED_VERSION_PREF);
60892: }
60892: 
60893: // <foo>Hello</foo> - "Hello" is stored as a child text node of the foo node.
60893: static bool
60893: BlacklistNodeToTextValue(nsIDOMNode *aBlacklistNode, nsAString& aValue)
60893: {
60893:   nsAutoString value;
71768:   if (NS_FAILED(aBlacklistNode->GetTextContent(value)))
60893:     return false;
60893: 
60893:   value.Trim(" \t\r\n");
60893:   aValue = value;
60893: 
60893:   return true;
60893: }
60893: 
60893: static OperatingSystem
60893: BlacklistOSToOperatingSystem(const nsAString& os)
60893: {
89731:   if (os == NS_LITERAL_STRING("WINNT 5.0"))
89731:     return DRIVER_OS_WINDOWS_2000;
89731:   else if (os == NS_LITERAL_STRING("WINNT 5.1"))
60893:     return DRIVER_OS_WINDOWS_XP;
60893:   else if (os == NS_LITERAL_STRING("WINNT 5.2"))
60893:     return DRIVER_OS_WINDOWS_SERVER_2003;
60893:   else if (os == NS_LITERAL_STRING("WINNT 6.0"))
60893:     return DRIVER_OS_WINDOWS_VISTA;
60893:   else if (os == NS_LITERAL_STRING("WINNT 6.1"))
60893:     return DRIVER_OS_WINDOWS_7;
60893:   else if (os == NS_LITERAL_STRING("Linux"))
60893:     return DRIVER_OS_LINUX;
60893:   else if (os == NS_LITERAL_STRING("Darwin 9"))
60893:     return DRIVER_OS_OS_X_10_5;
60893:   else if (os == NS_LITERAL_STRING("Darwin 10"))
60893:     return DRIVER_OS_OS_X_10_6;
81328:   else if (os == NS_LITERAL_STRING("Darwin 11"))
81328:     return DRIVER_OS_OS_X_10_7;
81328:   else if (os == NS_LITERAL_STRING("Android"))
81328:     return DRIVER_OS_ANDROID;
60893:   else if (os == NS_LITERAL_STRING("All"))
60893:     return DRIVER_OS_ALL;
60893: 
60893:   return DRIVER_OS_UNKNOWN;
60893: }
60893: 
84604: static GfxDeviceFamily*
60893: BlacklistDevicesToDeviceFamily(nsIDOMNodeList* aDevices)
60893: {
60893:   PRUint32 length;
60893:   if (NS_FAILED(aDevices->GetLength(&length)))
60893:     return nsnull;
60893: 
84604:   // For each <device>, get its device ID, and return a freshly-allocated
84604:   // GfxDeviceFamily with the contents of that array.
84604:   GfxDeviceFamily* deviceIds = new GfxDeviceFamily;
60893: 
60893:   for (PRUint32 i = 0; i < length; ++i) {
60893:     nsCOMPtr<nsIDOMNode> node;
60893:     if (NS_FAILED(aDevices->Item(i, getter_AddRefs(node))) || !node)
60893:       continue;
60893: 
60893:     nsAutoString deviceValue;
60893:     if (!BlacklistNodeToTextValue(node, deviceValue))
60893:       continue;
60893: 
84604:     deviceIds->AppendElement(deviceValue);
60893:   }
60893: 
84604:   return deviceIds;
60893: }
60893: 
60893: static PRInt32
60893: BlacklistFeatureToGfxFeature(const nsAString& aFeature)
60893: {
60893:   if (aFeature == NS_LITERAL_STRING("DIRECT2D"))
60893:     return nsIGfxInfo::FEATURE_DIRECT2D;
60893:   else if (aFeature == NS_LITERAL_STRING("DIRECT3D_9_LAYERS"))
60893:     return nsIGfxInfo::FEATURE_DIRECT3D_9_LAYERS;
60893:   else if (aFeature == NS_LITERAL_STRING("DIRECT3D_10_LAYERS"))
60893:     return nsIGfxInfo::FEATURE_DIRECT3D_10_LAYERS;
60893:   else if (aFeature == NS_LITERAL_STRING("DIRECT3D_10_1_LAYERS"))
60893:     return nsIGfxInfo::FEATURE_DIRECT3D_10_1_LAYERS;
60893:   else if (aFeature == NS_LITERAL_STRING("OPENGL_LAYERS"))
60893:     return nsIGfxInfo::FEATURE_OPENGL_LAYERS;
60893:   else if (aFeature == NS_LITERAL_STRING("WEBGL_OPENGL"))
60893:     return nsIGfxInfo::FEATURE_WEBGL_OPENGL;
60893:   else if (aFeature == NS_LITERAL_STRING("WEBGL_ANGLE"))
60893:     return nsIGfxInfo::FEATURE_WEBGL_ANGLE;
81329:   else if (aFeature == NS_LITERAL_STRING("WEBGL_MSAA"))
81329:     return nsIGfxInfo::FEATURE_WEBGL_MSAA;
60893: 
60893:   return 0;
60893: }
60893: 
60893: static PRInt32
60893: BlacklistFeatureStatusToGfxFeatureStatus(const nsAString& aStatus)
60893: {
60893:   if (aStatus == NS_LITERAL_STRING("NO_INFO"))
60893:     return nsIGfxInfo::FEATURE_NO_INFO;
60893:   else if (aStatus == NS_LITERAL_STRING("BLOCKED_DRIVER_VERSION"))
60893:     return nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION;
60893:   else if (aStatus == NS_LITERAL_STRING("BLOCKED_DEVICE"))
60893:     return nsIGfxInfo::FEATURE_BLOCKED_DEVICE;
60893:   else if (aStatus == NS_LITERAL_STRING("DISCOURAGED"))
60893:     return nsIGfxInfo::FEATURE_DISCOURAGED;
60893:   else if (aStatus == NS_LITERAL_STRING("BLOCKED_OS_VERSION"))
60893:     return nsIGfxInfo::FEATURE_BLOCKED_OS_VERSION;
60893: 
84603:   // Do not allow it to set STATUS_UNKNOWN.
84603: 
60893:   return nsIGfxInfo::FEATURE_NO_INFO;
60893: }
60893: 
60893: static VersionComparisonOp
60893: BlacklistComparatorToComparisonOp(const nsAString& op)
60893: {
60893:   if (op == NS_LITERAL_STRING("LESS_THAN"))
60893:     return DRIVER_LESS_THAN;
60893:   else if (op == NS_LITERAL_STRING("LESS_THAN_OR_EQUAL"))
60893:     return DRIVER_LESS_THAN_OR_EQUAL;
60893:   else if (op == NS_LITERAL_STRING("GREATER_THAN"))
60893:     return DRIVER_GREATER_THAN;
60893:   else if (op == NS_LITERAL_STRING("GREATER_THAN_OR_EQUAL"))
60893:     return DRIVER_GREATER_THAN_OR_EQUAL;
60893:   else if (op == NS_LITERAL_STRING("EQUAL"))
60893:     return DRIVER_EQUAL;
60893:   else if (op == NS_LITERAL_STRING("NOT_EQUAL"))
60893:     return DRIVER_NOT_EQUAL;
60893:   else if (op == NS_LITERAL_STRING("BETWEEN_EXCLUSIVE"))
60893:     return DRIVER_BETWEEN_EXCLUSIVE;
60893:   else if (op == NS_LITERAL_STRING("BETWEEN_INCLUSIVE"))
60893:     return DRIVER_BETWEEN_INCLUSIVE;
60893:   else if (op == NS_LITERAL_STRING("BETWEEN_INCLUSIVE_START"))
60893:     return DRIVER_BETWEEN_INCLUSIVE_START;
60893: 
60893:   return DRIVER_UNKNOWN_COMPARISON;
60893: }
60893: 
60893: // Arbitrarily returns the first |tagname| child of |element|.
60893: static bool
60893: BlacklistNodeGetChildByName(nsIDOMElement *element,
60893:                             const nsAString& tagname,
60893:                             nsIDOMNode** firstchild)
60893: {
60893:   nsCOMPtr<nsIDOMNodeList> nodelist;
60893:   if (NS_FAILED(element->GetElementsByTagName(tagname,
60893:                                               getter_AddRefs(nodelist))) ||
60893:       !nodelist) {
60893:     return false;
60893:   }
60893: 
60893:   nsCOMPtr<nsIDOMNode> node;
60893:   if (NS_FAILED(nodelist->Item(0, getter_AddRefs(node))) || !node)
60893:     return false;
60893: 
60893:   *firstchild = node.forget().get();
60893:   return true;
60893: }
60893: 
60893: /*
60893: 
60893: <gfxBlacklistEntry>
60893:   <os>WINNT 6.0</os>
60893:   <vendor>0x8086</vendor>
60893:   <devices>
60893:     <device>0x2582</device>
60893:     <device>0x2782</device>
60893:   </devices>
60893:   <feature> DIRECT3D_10_LAYERS </feature>
60893:   <featureStatus> BLOCKED_DRIVER_VERSION </featureStatus>
60893:   <driverVersion> 8.52.322.2202 </driverVersion>
60893:   <driverVersionComparator> LESS_THAN_OR_EQUAL </driverVersionComparator>
60893: </gfxBlacklistEntry>
60893: 
60893: */
60893: static bool
60893: BlacklistEntryToDriverInfo(nsIDOMNode* aBlacklistEntry,
60893:                            GfxDriverInfo& aDriverInfo)
60893: {
60893:   nsAutoString nodename;
60893:   if (NS_FAILED(aBlacklistEntry->GetNodeName(nodename)) ||
60893:       nodename != NS_LITERAL_STRING(BLACKLIST_ENTRY_TAG_NAME)) {
60893:     return false;
60893:   }
60893: 
60893:   nsCOMPtr<nsIDOMElement> element = do_QueryInterface(aBlacklistEntry);
60893:   if (!element)
60893:     return false;
60893: 
60893:   nsCOMPtr<nsIDOMNode> dataNode;
60893:   nsAutoString dataValue;
60893: 
60893:   // <os>WINNT 6.0</os>
60893:   if (BlacklistNodeGetChildByName(element, NS_LITERAL_STRING("os"),
60893:                                   getter_AddRefs(dataNode))) {
60893:     BlacklistNodeToTextValue(dataNode, dataValue);
60893:     aDriverInfo.mOperatingSystem = BlacklistOSToOperatingSystem(dataValue);
60893:   }
60893: 
60893:   // <vendor>0x8086</vendor>
60893:   if (BlacklistNodeGetChildByName(element, NS_LITERAL_STRING("vendor"),
60893:                                   getter_AddRefs(dataNode))) {
60893:     BlacklistNodeToTextValue(dataNode, dataValue);
84604:     aDriverInfo.mAdapterVendor = dataValue;
60893:   }
60893: 
60893:   // <devices>
60893:   //   <device>0x2582</device>
60893:   //   <device>0x2782</device>
60893:   // </devices>
60893:   if (BlacklistNodeGetChildByName(element, NS_LITERAL_STRING("devices"),
60893:                                   getter_AddRefs(dataNode))) {
60893:     nsCOMPtr<nsIDOMElement> devicesElement = do_QueryInterface(dataNode);
60893:     if (devicesElement) {
60893: 
60893:       // Get only the <device> nodes, because BlacklistDevicesToDeviceFamily
60893:       // assumes it is passed no other nodes.
60893:       nsCOMPtr<nsIDOMNodeList> devices;
60893:       if (NS_SUCCEEDED(devicesElement->GetElementsByTagName(NS_LITERAL_STRING("device"),
60893:                                                             getter_AddRefs(devices)))) {
84604:         GfxDeviceFamily* deviceIds = BlacklistDevicesToDeviceFamily(devices);
60893:         if (deviceIds) {
60893:           // Get GfxDriverInfo to adopt the devices array we created.
60893:           aDriverInfo.mDeleteDevices = true;
60893:           aDriverInfo.mDevices = deviceIds;
60893:         }
60893:       }
60893:     }
60893:   }
60893: 
60893:   // <feature> DIRECT3D_10_LAYERS </feature>
60893:   if (BlacklistNodeGetChildByName(element, NS_LITERAL_STRING("feature"),
60893:                                   getter_AddRefs(dataNode))) {
60893:     BlacklistNodeToTextValue(dataNode, dataValue);
60893:     aDriverInfo.mFeature = BlacklistFeatureToGfxFeature(dataValue);
60893:   }
60893: 
60893:   // <featureStatus> BLOCKED_DRIVER_VERSION </featureStatus>
60893:   if (BlacklistNodeGetChildByName(element, NS_LITERAL_STRING("featureStatus"),
60893:                                   getter_AddRefs(dataNode))) {
60893:     BlacklistNodeToTextValue(dataNode, dataValue);
60893:     aDriverInfo.mFeatureStatus = BlacklistFeatureStatusToGfxFeatureStatus(dataValue);
60893:   }
60893: 
60893:   // <driverVersion> 8.52.322.2202 </driverVersion>
60893:   if (BlacklistNodeGetChildByName(element, NS_LITERAL_STRING("driverVersion"),
60893:                                   getter_AddRefs(dataNode))) {
60893:     BlacklistNodeToTextValue(dataNode, dataValue);
60893:     PRUint64 version;
60893:     if (ParseDriverVersion(dataValue, &version))
60893:       aDriverInfo.mDriverVersion = version;
60893:   }
60893: 
60893:   // <driverVersionComparator> LESS_THAN_OR_EQUAL </driverVersionComparator>
60893:   if (BlacklistNodeGetChildByName(element, NS_LITERAL_STRING("driverVersionComparator"),
60893:                                   getter_AddRefs(dataNode))) {
60893:     BlacklistNodeToTextValue(dataNode, dataValue);
60893:     aDriverInfo.mComparisonOp = BlacklistComparatorToComparisonOp(dataValue);
60893:   }
60893: 
60893:   // We explicitly ignore unknown elements.
60893: 
60893:   return true;
60893: }
60893: 
60893: static void
60893: BlacklistEntriesToDriverInfo(nsIDOMNodeList* aBlacklistEntries,
60893:                              nsTArray<GfxDriverInfo>& aDriverInfo)
60893: {
60893:   PRUint32 length;
60893:   if (NS_FAILED(aBlacklistEntries->GetLength(&length)))
60893:     return;
60893: 
84604:   aDriverInfo.Clear();
84604:   aDriverInfo.SetLength(length);
60893:   for (PRUint32 i = 0; i < length; ++i) {
60893:     nsCOMPtr<nsIDOMNode> blacklistEntry;
60893:     if (NS_SUCCEEDED(aBlacklistEntries->Item(i,
60893:                                              getter_AddRefs(blacklistEntry))) &&
60893:         blacklistEntry) {
60893:       GfxDriverInfo di;
60893:       if (BlacklistEntryToDriverInfo(blacklistEntry, di)) {
84604:         aDriverInfo[i] = di;
60893:       }
84604:       // Prevent di falling out of scope from destroying the devices.
84604:       di.mDeleteDevices = false;
60893:     }
60893:   }
60893: }
60893: 
60893: NS_IMETHODIMP
60893: GfxInfoBase::Observe(nsISupports* aSubject, const char* aTopic,
60893:                      const PRUnichar* aData)
60893: {
60893:   if (strcmp(aTopic, "blocklist-data-gfxItems") == 0) {
60893:     nsCOMPtr<nsIDOMElement> gfxItems = do_QueryInterface(aSubject);
60893:     if (gfxItems) {
60893:       nsCOMPtr<nsIDOMNodeList> blacklistEntries;
60893:       if (NS_SUCCEEDED(gfxItems->
60893:             GetElementsByTagName(NS_LITERAL_STRING(BLACKLIST_ENTRY_TAG_NAME),
60893:                                  getter_AddRefs(blacklistEntries))) &&
60893:           blacklistEntries)
60893:       {
60893:         nsTArray<GfxDriverInfo> driverInfo;
60893:         BlacklistEntriesToDriverInfo(blacklistEntries, driverInfo);
60894:         EvaluateDownloadedBlacklist(driverInfo);
60893:       }
60893:     }
60893:   }
60893: 
60893:   return NS_OK;
60893: }
60893: 
60893: GfxInfoBase::GfxInfoBase()
62106:     : mFailureCount(0)
60893: {
60893: }
60893: 
60893: GfxInfoBase::~GfxInfoBase()
60893: {
60893: }
60893: 
60893: nsresult
60893: GfxInfoBase::Init()
60893: {
84604:   InitGfxDriverInfoShutdownObserver();
84604: 
60893:   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
60893:   if (os) {
80486:     os->AddObserver(this, "blocklist-data-gfxItems", true);
60893:   }
60893: 
60893:   return NS_OK;
60893: }
60893: 
60891: NS_IMETHODIMP
60891: GfxInfoBase::GetFeatureStatus(PRInt32 aFeature, PRInt32* aStatus NS_OUTPARAM)
60891: {
60892:   if (GetPrefValueForFeature(aFeature, *aStatus))
60892:     return NS_OK;
60892: 
60891:   nsString version;
84603:   nsTArray<GfxDriverInfo> driverInfo;
84603:   return GetFeatureStatusImpl(aFeature, aStatus, version, driverInfo);
84603: }
84603: 
84603: PRInt32
84603: GfxInfoBase::FindBlocklistedDeviceInList(const nsTArray<GfxDriverInfo>& info,
84603:                                          nsAString& aSuggestedVersion,
84603:                                          PRInt32 aFeature,
84603:                                          OperatingSystem os)
84603: {
84603:   PRInt32 status = nsIGfxInfo::FEATURE_STATUS_UNKNOWN;
84603: 
84604:   nsAutoString adapterVendorID;
84604:   nsAutoString adapterDeviceID;
84603:   nsAutoString adapterDriverVersionString;
84604:   if (NS_FAILED(GetAdapterVendorID(adapterVendorID)) ||
84604:       NS_FAILED(GetAdapterDeviceID(adapterDeviceID)) ||
84603:       NS_FAILED(GetAdapterDriverVersion(adapterDriverVersionString)))
84603:   {
84603:     return NS_OK;
84603:   }
84603: 
84603:   PRUint64 driverVersion;
84603:   ParseDriverVersion(adapterDriverVersionString, &driverVersion);
84603: 
84603:   PRUint32 i = 0;
84603:   for (; i < info.Length(); i++) {
84603:     if (info[i].mOperatingSystem != DRIVER_OS_ALL &&
84603:         info[i].mOperatingSystem != os)
84603:     {
84603:       continue;
84603:     }
84603: 
90539:     if (!info[i].mAdapterVendor.Equals(GfxDriverInfo::GetDeviceVendor(VendorAll), nsCaseInsensitiveStringComparator()) &&
90539:         !info[i].mAdapterVendor.Equals(adapterVendorID, nsCaseInsensitiveStringComparator())) {
84603:       continue;
84603:     }
84603: 
84604:     if (info[i].mDevices != GfxDriverInfo::allDevices && info[i].mDevices->Length()) {
84603:         bool deviceMatches = false;
84604:         for (PRUint32 j = 0; j < info[i].mDevices->Length(); j++) {
90539:             if ((*info[i].mDevices)[j].Equals(adapterDeviceID, nsCaseInsensitiveStringComparator())) {
84603:                 deviceMatches = true;
84603:                 break;
84603:             }
84603:         }
84603: 
84603:         if (!deviceMatches) {
84603:             continue;
84603:         }
84603:     }
84603: 
84603:     bool match = false;
84603: 
84605: #if defined(XP_WIN) || defined(ANDROID)
84603:     switch (info[i].mComparisonOp) {
84603:     case DRIVER_LESS_THAN:
84603:       match = driverVersion < info[i].mDriverVersion;
84603:       break;
84603:     case DRIVER_LESS_THAN_OR_EQUAL:
84603:       match = driverVersion <= info[i].mDriverVersion;
84603:       break;
84603:     case DRIVER_GREATER_THAN:
84603:       match = driverVersion > info[i].mDriverVersion;
84603:       break;
84603:     case DRIVER_GREATER_THAN_OR_EQUAL:
84603:       match = driverVersion >= info[i].mDriverVersion;
84603:       break;
84603:     case DRIVER_EQUAL:
84603:       match = driverVersion == info[i].mDriverVersion;
84603:       break;
84603:     case DRIVER_NOT_EQUAL:
84603:       match = driverVersion != info[i].mDriverVersion;
84603:       break;
84603:     case DRIVER_BETWEEN_EXCLUSIVE:
84603:       match = driverVersion > info[i].mDriverVersion && driverVersion < info[i].mDriverVersionMax;
84603:       break;
84603:     case DRIVER_BETWEEN_INCLUSIVE:
84603:       match = driverVersion >= info[i].mDriverVersion && driverVersion <= info[i].mDriverVersionMax;
84603:       break;
84603:     case DRIVER_BETWEEN_INCLUSIVE_START:
84603:       match = driverVersion >= info[i].mDriverVersion && driverVersion < info[i].mDriverVersionMax;
84603:       break;
84603:     default:
84603:       NS_WARNING("Bogus op in GfxDriverInfo");
84603:       break;
84603:     }
84603: #else
84603:     // We don't care what driver version it was. We only check OS version and if
84603:     // the device matches.
84603:     match = true;
84603: #endif
84603: 
84605:     if (match || info[i].mDriverVersion == GfxDriverInfo::allDriverVersions) {
84603:       if (info[i].mFeature == GfxDriverInfo::allFeatures ||
84603:           info[i].mFeature == aFeature)
84603:       {
84603:         status = info[i].mFeatureStatus;
84603:         break;
84603:       }
84603:     }
84603:   }
84603: 
84603:   // Depends on Windows driver versioning. We don't pass a GfxDriverInfo object
84603:   // back to the Windows handler, so we must handle this here.
84603: #if defined(XP_WIN)
84603:   if (status == FEATURE_BLOCKED_DRIVER_VERSION) {
84603:     if (info[i].mSuggestedVersion) {
84603:         aSuggestedVersion.AppendPrintf("%s", info[i].mSuggestedVersion);
84603:     } else if (info[i].mComparisonOp == DRIVER_LESS_THAN &&
84603:                info[i].mDriverVersion != GfxDriverInfo::allDriverVersions)
84603:     {
84603:         aSuggestedVersion.AppendPrintf("%lld.%lld.%lld.%lld",
84603:                                       (info[i].mDriverVersion & 0xffff000000000000) >> 48,
84603:                                       (info[i].mDriverVersion & 0x0000ffff00000000) >> 32,
84603:                                       (info[i].mDriverVersion & 0x00000000ffff0000) >> 16,
84603:                                       (info[i].mDriverVersion & 0x000000000000ffff));
84603:     }
84603:   }
84603: #endif
84603: 
84603:   return status;
60891: }
60891: 
81328: nsresult
81328: GfxInfoBase::GetFeatureStatusImpl(PRInt32 aFeature,
81328:                                   PRInt32* aStatus,
84603:                                   nsAString& aSuggestedVersion,
84603:                                   const nsTArray<GfxDriverInfo>& aDriverInfo,
81328:                                   OperatingSystem* aOS /* = nsnull */)
81328: {
84603:   if (*aStatus != nsIGfxInfo::FEATURE_STATUS_UNKNOWN) {
81328:     // Terminate now with the status determined by the derived type (OS-specific
81328:     // code).
81328:     return NS_OK;
81328:   }
81328: 
84603:   // If an operating system was provided by the derived GetFeatureStatusImpl,
84603:   // grab it here. Otherwise, the OS is unknown.
81328:   OperatingSystem os = DRIVER_OS_UNKNOWN;
81328:   if (aOS)
81328:     os = *aOS;
81328: 
84604:   nsAutoString adapterVendorID;
84604:   nsAutoString adapterDeviceID;
81328:   nsAutoString adapterDriverVersionString;
84604:   if (NS_FAILED(GetAdapterVendorID(adapterVendorID)) ||
84604:       NS_FAILED(GetAdapterDeviceID(adapterDeviceID)) ||
81328:       NS_FAILED(GetAdapterDriverVersion(adapterDriverVersionString)))
81328:   {
81503:     return NS_OK;
81328:   }
81328: 
81328:   PRUint64 driverVersion;
81503:   ParseDriverVersion(adapterDriverVersionString, &driverVersion);
81328: 
84603:   // Check if the device is blocked from the downloaded blocklist. If not, check
84603:   // the static list after that. This order is used so that we can later escape
84603:   // out of static blocks (i.e. if we were wrong or something was patched, we
84603:   // can back out our static block without doing a release).
84604:   PRInt32 status;
84604:   if (aDriverInfo.Length()) {
84604:     status = FindBlocklistedDeviceInList(aDriverInfo, aSuggestedVersion, aFeature, os);
84604:   } else {
84604:     if (!mDriverInfo) {
84603:       mDriverInfo = new nsTArray<GfxDriverInfo>();
84604:     }
84603:     status = FindBlocklistedDeviceInList(GetGfxDriverInfo(), aSuggestedVersion, aFeature, os);
81328:   }
81328: 
84603:   // It's now done being processed. It's safe to set the status to NO_INFO.
84603:   if (status == nsIGfxInfo::FEATURE_STATUS_UNKNOWN) {
84603:     *aStatus = nsIGfxInfo::FEATURE_NO_INFO;
84603:   } else {
84603:     *aStatus = status;
82482:   }
81328: 
81328:   return NS_OK;
81328: }
81328: 
60891: NS_IMETHODIMP
60891: GfxInfoBase::GetFeatureSuggestedDriverVersion(PRInt32 aFeature,
60891:                                               nsAString& aVersion NS_OUTPARAM)
60891: {
60892:   nsCString version;
60892:   if (GetPrefValueForDriverVersion(version)) {
60892:     aVersion = NS_ConvertASCIItoUTF16(version);
60892:     return NS_OK;
60892:   }
60892: 
60891:   PRInt32 status;
84603:   nsTArray<GfxDriverInfo> driverInfo;
84603:   return GetFeatureStatusImpl(aFeature, &status, aVersion, driverInfo);
60891: }
60891: 
60892: 
60891: NS_IMETHODIMP
60891: GfxInfoBase::GetWebGLParameter(const nsAString& aParam,
60891:                                nsAString& aResult NS_OUTPARAM)
60891: {
60891:   return GfxInfoWebGL::GetWebGLParameter(aParam, aResult);
60891: }
60894: 
60894: void
60894: GfxInfoBase::EvaluateDownloadedBlacklist(nsTArray<GfxDriverInfo>& aDriverInfo)
60894: {
60894:   PRInt32 features[] = {
60894:     nsIGfxInfo::FEATURE_DIRECT2D,
60894:     nsIGfxInfo::FEATURE_DIRECT3D_9_LAYERS,
60894:     nsIGfxInfo::FEATURE_DIRECT3D_10_LAYERS,
60894:     nsIGfxInfo::FEATURE_DIRECT3D_10_1_LAYERS,
60894:     nsIGfxInfo::FEATURE_OPENGL_LAYERS,
60894:     nsIGfxInfo::FEATURE_WEBGL_OPENGL,
60894:     nsIGfxInfo::FEATURE_WEBGL_ANGLE,
81329:     nsIGfxInfo::FEATURE_WEBGL_MSAA,
60894:     0
60894:   };
60894: 
60894:   // For every feature we know about, we evaluate whether this blacklist has a
60894:   // non-NO_INFO status. If it does, we set the pref we evaluate in
60894:   // GetFeatureStatus above, so we don't need to hold on to this blacklist
60894:   // anywhere permanent.
60894:   int i = 0;
60894:   while (features[i]) {
60894:     PRInt32 status;
60894:     nsAutoString suggestedVersion;
60894:     if (NS_SUCCEEDED(GetFeatureStatusImpl(features[i], &status,
60894:                                           suggestedVersion,
84603:                                           aDriverInfo))) {
60894:       switch (status) {
60894:         default:
60894:         case nsIGfxInfo::FEATURE_NO_INFO:
60894:           RemovePrefForFeature(features[i]);
60894:           break;
60894: 
60894:         case nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION:
60894:           if (!suggestedVersion.IsEmpty()) {
60894:             SetPrefValueForDriverVersion(suggestedVersion);
60894:           } else {
60894:             RemovePrefForDriverVersion();
60894:           }
60894:           // FALLTHROUGH
60894: 
60894:         case nsIGfxInfo::FEATURE_BLOCKED_DEVICE:
60894:         case nsIGfxInfo::FEATURE_DISCOURAGED:
60894:         case nsIGfxInfo::FEATURE_BLOCKED_OS_VERSION:
60894:           SetPrefValueForFeature(features[i], status);
60894:           break;
60894:       }
60894:     }
60894: 
60894:     ++i;
60894:   }
60894: }
62106: 
62106: NS_IMETHODIMP_(void)
62106: GfxInfoBase::LogFailure(const nsACString &failure)
62106: {
62106:   /* We only keep the first 9 failures */
80467:   if (mFailureCount < ArrayLength(mFailures)) {
62106:     mFailures[mFailureCount++] = failure;
62253: 
62253:     /* record it in the crash notes too */
70361: #if defined(MOZ_CRASHREPORTER)
62253:     CrashReporter::AppendAppNotesToCrashReport(failure);
62253: #endif
62106:   }
62253: 
62106: }
62106: 
62106: /* void getFailures ([optional] out unsigned long failureCount, [array, size_is (failureCount), retval] out string failures); */
62106: /* XPConnect method of returning arrays is very ugly. Would not recommend. Fallable nsMemory::Alloc makes things worse */
62106: NS_IMETHODIMP GfxInfoBase::GetFailures(PRUint32 *failureCount NS_OUTPARAM, char ***failures NS_OUTPARAM)
62106: {
62106: 
62106:   NS_ENSURE_ARG_POINTER(failureCount);
62106:   NS_ENSURE_ARG_POINTER(failures);
62106: 
62106:   *failures = nsnull;
62106:   *failureCount = mFailureCount;
62106: 
62106:   if (*failureCount != 0) {
62106:     *failures = (char**)nsMemory::Alloc(*failureCount * sizeof(char*));
62106:     if (!failures)
62106:       return NS_ERROR_OUT_OF_MEMORY;
62106: 
62106:     /* copy over the failure messages into the array we just allocated */
62106:     for (PRUint32 i = 0; i < *failureCount; i++) {
72255:       nsCString& flattenedFailureMessage(mFailures[i]);
62106:       (*failures)[i] = (char*)nsMemory::Clone(flattenedFailureMessage.get(), flattenedFailureMessage.Length() + 1);
62106: 
62106:       if (!(*failures)[i]) {
62106:         /* <sarcasm> I'm too afraid to use an inline function... </sarcasm> */
62106:         NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(i, (*failures));
62106:         return NS_ERROR_OUT_OF_MEMORY;
62106:       }
62106:     }
62106:   }
62106: 
62106:   return NS_OK;
62106: }
82320: 
82320: nsTArray<GfxInfoCollectorBase*> *sCollectors;
82320: 
82320: static void
82320: InitCollectors()
82320: {
82320:   if (!sCollectors)
82320:     sCollectors = new nsTArray<GfxInfoCollectorBase*>;
82320: }
82320: 
82320: nsresult GfxInfoBase::GetInfo(JSContext* aCx, jsval* aResult)
82320: {
82320:   InitCollectors();
82320:   InfoObject obj(aCx);
82320: 
82320:   for (PRUint32 i = 0; i < sCollectors->Length(); i++) {
82320:     (*sCollectors)[i]->GetInfo(obj);
82320:   }
82320: 
82320:   // Some example property definitions
82320:   // obj.DefineProperty("wordCacheSize", gfxTextRunWordCache::Count());
82320:   // obj.DefineProperty("renderer", mRendererIDsString);
82320:   // obj.DefineProperty("five", 5);
82320: 
82320:   if (!obj.mOk) {
82320:     return NS_ERROR_FAILURE;
82320:   }
82320: 
82320:   *aResult = OBJECT_TO_JSVAL(obj.mObj);
82320:   return NS_OK;
82320: }
82320: 
82320: void
82320: GfxInfoBase::AddCollector(GfxInfoCollectorBase* collector)
82320: {
82320:   InitCollectors();
82320:   sCollectors->AppendElement(collector);
82320: }
82320: 
82320: void
82320: GfxInfoBase::RemoveCollector(GfxInfoCollectorBase* collector)
82320: {
82320:   InitCollectors();
82320:   for (PRUint32 i = 0; i < sCollectors->Length(); i++) {
82320:     if ((*sCollectors)[i] == collector) {
82320:       sCollectors->RemoveElementAt(i);
82320:       break;
82320:     }
82320:   }
82418:   if (sCollectors->IsEmpty()) {
82418:     delete sCollectors;
82418:     sCollectors = nsnull;
82418:   }
82320: }
82320: 
82320: GfxInfoCollectorBase::GfxInfoCollectorBase()
82320: {
82320:   GfxInfoBase::AddCollector(this);
82320: }
82320: 
82320: GfxInfoCollectorBase::~GfxInfoCollectorBase()
82320: {
82320:   GfxInfoBase::RemoveCollector(this);
82320: }
