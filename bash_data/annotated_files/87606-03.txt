52839: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52839:  * vim: set ts=4 sw=4 et tw=99:
52839:  *
52839:  * ***** BEGIN LICENSE BLOCK *****
52839:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52839:  *
52839:  * The contents of this file are subject to the Mozilla Public License Version
52839:  * 1.1 (the "License"); you may not use this file except in compliance with
52839:  * the License. You may obtain a copy of the License at
52839:  * http://www.mozilla.org/MPL/
52839:  *
52839:  * Software distributed under the License is distributed on an "AS IS" basis,
52839:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52839:  * for the specific language governing rights and limitations under the
52839:  * License.
52839:  *
52839:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52839:  * May 28, 2008.
52839:  *
52839:  * The Initial Developer of the Original Code is
52839:  *   Brendan Eich <brendan@mozilla.org>
52839:  *
52839:  * Contributor(s):
52839:  *   David Anderson <danderson@mozilla.com>
52839:  *
52839:  * Alternatively, the contents of this file may be used under the terms of
52839:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52839:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52839:  * in which case the provisions of the GPL or the LGPL are applicable instead
52839:  * of those above. If you wish to allow use of your version of this file only
52839:  * under the terms of either the GPL or the LGPL, and not to allow others to
52839:  * use your version of this file under the terms of the MPL, indicate your
52839:  * decision by deleting the provisions above and replace them with the notice
52839:  * and other provisions required by the GPL or the LGPL. If you do not delete
52839:  * the provisions above, a recipient may use your version of this file under
52839:  * the terms of any one of the MPL, the GPL or the LGPL.
52839:  *
52839:  * ***** END LICENSE BLOCK ***** */
56005: 
56005: #if defined JS_NUNBOX32
56005: 
52839: #include "FrameEntry.h"
52839: #include "FrameState.h"
52839: #include "FrameState-inl.h"
52839: #include "ImmutableSync.h"
52839: 
52839: using namespace js;
52839: using namespace js::mjit;
52839: 
77343: ImmutableSync::ImmutableSync()
87606:   : cx(NULL), entries(NULL), frame(NULL), avail(Registers::AvailRegs), generation(0)
52839: {
52839: }
52839: 
52839: ImmutableSync::~ImmutableSync()
52839: {
77343:     if (cx)
64560:         cx->free_(entries);
52839: }
52839: 
52839: bool
84755: ImmutableSync::init(JSContext *cx, const FrameState &frame, uint32_t nentries)
52839: {
77343:     this->cx = cx;
77343:     this->frame = &frame;
77343: 
64560:     entries = (SyncEntry *)cx->calloc_(sizeof(SyncEntry) * nentries);
52839:     return !!entries;
52839: }
52839: 
52839: void
54719: ImmutableSync::reset(Assembler *masm, Registers avail, FrameEntry *top, FrameEntry *bottom)
52839: {
87606:     this->avail = avail;
52839:     this->masm = masm;
54719:     this->top = top;
53113:     this->bottom = bottom;
54719:     this->generation++;
52839:     memset(regs, 0, sizeof(regs));
52839: }
52839: 
84129: inline JSC::MacroAssembler::RegisterID
84129: ImmutableSync::doAllocReg()
52839: {
52839:     if (!avail.empty())
77343:         return avail.takeAnyReg().reg();
52839: 
84755:     uint32_t lastResort = FrameState::InvalidIndex;
84755:     uint32_t evictFromFrame = FrameState::InvalidIndex;
52839: 
52839:     /* Find something to evict. */
84755:     for (uint32_t i = 0; i < Registers::TotalRegisters; i++) {
52839:         RegisterID reg = RegisterID(i);
87606:         if (!(Registers::maskReg(reg) & Registers::AvailRegs))
52839:             continue;
52839: 
84129:         if (frame->regstate(reg).isPinned())
84129:             continue;
84129: 
77435:         lastResort = i;
52839: 
52839:         if (!regs[i]) {
52839:             /* If the frame does not own this register, take it! */
77343:             FrameEntry *fe = frame->regstate(reg).usedBy();
52839:             if (!fe)
52839:                 return reg;
52839: 
52839:             evictFromFrame = i;
52839: 
52839:             /*
52839:              * If not copied, we can sync and not have to load again later.
52839:              * That's about as good as it gets, so just break out now.
52839:              */
52839:             if (!fe->isCopied())
52839:                 break;
52839:         }
52839:     }
52839: 
52839:     if (evictFromFrame != FrameState::InvalidIndex) {
77343:         RegisterID evict = RegisterID(evictFromFrame);
77343:         FrameEntry *fe = frame->regstate(evict).usedBy();
52839:         SyncEntry &e = entryFor(fe);
77343:         if (frame->regstate(evict).type() == RematInfo::TYPE) {
52839:             JS_ASSERT(!e.typeClobbered);
52839:             e.typeClobbered = true;
52839:         } else {
52839:             JS_ASSERT(!e.dataClobbered);
52839:             e.dataClobbered = true;
52839:         }
77343:         return evict;
52839:     }
52839: 
52839:     JS_ASSERT(lastResort != FrameState::InvalidIndex);
52839:     JS_ASSERT(regs[lastResort]);
52839: 
52839:     SyncEntry *e = regs[lastResort];
52839:     RegisterID reg = RegisterID(lastResort);
52839:     if (e->hasDataReg && e->dataReg == reg) {
52839:         e->hasDataReg = false;
52839:     } else if (e->hasTypeReg && e->typeReg == reg) {
52839:         e->hasTypeReg = false;
52839:     } else {
52839:         JS_NOT_REACHED("no way");
52839:     }
52839: 
52839:     return reg;
52839: }
52839: 
84129: JSC::MacroAssembler::RegisterID
84129: ImmutableSync::allocReg()
84129: {
84129:     RegisterID reg = doAllocReg();
84129:     JS_ASSERT(!frame->regstate(reg).isPinned());
84129:     return reg;
84129: }
84129: 
84129: void
84129: ImmutableSync::freeReg(JSC::MacroAssembler::RegisterID reg)
84129: {
87606:     if (!frame->regstate(reg).isPinned())
84129:         avail.putReg(reg);
84129: }
84129: 
52839: inline ImmutableSync::SyncEntry &
52839: ImmutableSync::entryFor(FrameEntry *fe)
52839: {
77343:     JS_ASSERT(fe <= top || frame->isTemporary(fe));
77343:     SyncEntry &e = entries[fe - frame->entries];
54719:     if (e.generation != generation)
54719:         e.reset(generation);
54719:     return e;
52839: }
52839: 
52839: void
52839: ImmutableSync::sync(FrameEntry *fe)
52839: {
52839:     if (fe->isCopy())
52839:         syncCopy(fe);
52839:     else
52839:         syncNormal(fe);
52839: }
52839: 
53113: bool
53113: ImmutableSync::shouldSyncType(FrameEntry *fe, SyncEntry &e)
53113: {
54719:     /* Registers are synced up-front. */
54719:     return !fe->type.synced() && !fe->type.inRegister();
53113: }
53113: 
53113: bool
53113: ImmutableSync::shouldSyncData(FrameEntry *fe, SyncEntry &e)
53113: {
54719:     /* Registers are synced up-front. */
54719:     return !fe->data.synced() && !fe->data.inRegister();
53113: }
53113: 
52839: JSC::MacroAssembler::RegisterID
52839: ImmutableSync::ensureTypeReg(FrameEntry *fe, SyncEntry &e)
52839: {
52839:     if (fe->type.inRegister() && !e.typeClobbered)
52839:         return fe->type.reg();
52839:     if (e.hasTypeReg)
52839:         return e.typeReg;
52839:     e.typeReg = allocReg();
52839:     e.hasTypeReg = true;
52839:     regs[e.typeReg] = &e;
77343:     masm->loadTypeTag(frame->addressOf(fe), e.typeReg);
52839:     return e.typeReg;
52839: }
52839: 
52839: JSC::MacroAssembler::RegisterID
52839: ImmutableSync::ensureDataReg(FrameEntry *fe, SyncEntry &e)
52839: {
52839:     if (fe->data.inRegister() && !e.dataClobbered)
52839:         return fe->data.reg();
52839:     if (e.hasDataReg)
52839:         return e.dataReg;
52839:     e.dataReg = allocReg();
52839:     e.hasDataReg = true;
52839:     regs[e.dataReg] = &e;
77343:     masm->loadPayload(frame->addressOf(fe), e.dataReg);
52839:     return e.dataReg;
52839: }
52839: 
52839: void
52839: ImmutableSync::syncCopy(FrameEntry *fe)
52839: {
54719:     JS_ASSERT(fe >= bottom);
53113: 
52839:     FrameEntry *backing = fe->copyOf();
52839:     SyncEntry &e = entryFor(backing);
52839: 
52839:     JS_ASSERT(!backing->isConstant());
52839: 
77343:     Address addr = frame->addressOf(fe);
52839: 
77343:     if (fe->isTypeKnown() && !fe->isType(JSVAL_TYPE_DOUBLE) && !e.learnedType) {
52839:         e.learnedType = true;
53144:         e.type = fe->getKnownType();
52839:     }
52839: 
52839:     if (!fe->data.synced())
53144:         masm->storePayload(ensureDataReg(backing, e), addr);
52839: 
52839:     if (!fe->type.synced()) {
52839:         if (e.learnedType)
53144:             masm->storeTypeTag(ImmType(e.type), addr);
52839:         else
52839:             masm->storeTypeTag(ensureTypeReg(backing, e), addr);
52839:     }
52839: }
52839: 
52839: void
52839: ImmutableSync::syncNormal(FrameEntry *fe)
52839: {
52839:     SyncEntry &e = entryFor(fe);
52839: 
77343:     Address addr = frame->addressOf(fe);
52839: 
77343:     if (fe->isTypeKnown() && !fe->isType(JSVAL_TYPE_DOUBLE)) {
52839:         e.learnedType = true;
53144:         e.type = fe->getKnownType();
52839:     }
52839: 
54719:     if (shouldSyncData(fe, e)) {
52839:         if (fe->isConstant()) {
52839:             masm->storeValue(fe->getValue(), addr);
52839:             return;
52839:         }
53144:         masm->storePayload(ensureDataReg(fe, e), addr);
52839:     }
52839: 
54719:     if (shouldSyncType(fe, e)) {
52839:         if (e.learnedType)
53144:             masm->storeTypeTag(ImmType(e.type), addr);
52839:         else
52839:             masm->storeTypeTag(ensureTypeReg(fe, e), addr);
52839:     }
52839: 
52839:     if (e.hasDataReg) {
84129:         freeReg(e.dataReg);
52839:         regs[e.dataReg] = NULL;
57724:     } else if (!e.dataClobbered &&
57724:                fe->data.inRegister() &&
77343:                frame->regstate(fe->data.reg()).usedBy()) {
84129:         freeReg(fe->data.reg());
52839:     }
52839: 
52839:     if (e.hasTypeReg) {
84129:         freeReg(e.typeReg);
52839:         regs[e.typeReg] = NULL;
57724:     } else if (!e.typeClobbered &&
57724:                fe->type.inRegister() &&
77343:                frame->regstate(fe->type.reg()).usedBy()) {
84129:         freeReg(fe->type.reg());
52839:     }
52839: }
52839: 
56005: #endif /* JS_NUNBOX32 */
56005: 
