     1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
  3573:  * vim: set ts=8 sw=4 et tw=78:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 97871: /*
 97871:  * XPConnect allows JS code to manipulate C++ object and C++ code to manipulate
 97871:  * JS objects. JS manipulation of C++ objects tends to be significantly more
 97871:  * complex. This comment explains how it is orchestrated by XPConnect.
 97871:  *
 97871:  * For each C++ object to be manipulated in JS, there is a corresponding JS
 97871:  * object. This is called the "flattened JS object". By default, there is an
 97871:  * additional C++ object involved of type XPCWrappedNative. The XPCWrappedNative
 97871:  * holds pointers to the C++ object and the flat JS object.
 97871:  *
 97871:  * As an optimization, some C++ objects don't have XPCWrappedNatives, although
 97871:  * they still have a corresponding flattened JS object. These are called "slim
 97871:  * wrappers": all the wrapping information is stored in extra fields of the C++
 97871:  * object and the JS object. Slim wrappers are only used for DOM objects. As a
 97871:  * deoptimization, slim wrappers can be "morphed" into XPCWrappedNatives if the
 97871:  * extra fields of the XPCWrappedNative become necessary.
 97871:  *
 97871:  * All XPCWrappedNative objects belong to an XPCWrappedNativeScope. These scopes
 97871:  * are essentially in 1:1 correspondence with JS global objects. The
 97871:  * XPCWrappedNativeScope has a pointer to the JS global object. The parent of a
 97871:  * flattened JS object is, by default, the global JS object corresponding to the
 97871:  * wrapper's XPCWrappedNativeScope (the exception to this rule is when a
 97871:  * PreCreate hook asks for a different parent; see nsIXPCScriptable below).
 97871:  *
 97871:  * Some C++ objects (notably DOM objects) have information associated with them
 97871:  * that lists the interfaces implemented by these objects. A C++ object exposes
 97871:  * this information by implementing nsIClassInfo. If a C++ object implements
 97871:  * nsIClassInfo, then JS code can call its methods without needing to use
 97871:  * QueryInterface first. Typically, all instances of a C++ class share the same
 97871:  * nsIClassInfo instance. (That is, obj->QueryInterface(nsIClassInfo) returns
 97871:  * the same result for every obj of a given class.)
 97871:  *
 97871:  * XPConnect tracks nsIClassInfo information in an XPCWrappedNativeProto object.
 97871:  * A given XPCWrappedNativeScope will have one XPCWrappedNativeProto for each
 97871:  * nsIClassInfo instance being used. The XPCWrappedNativeProto has an associated
 97871:  * JS object, which is used as the prototype of all flattened JS objects created
 97871:  * for C++ objects with the given nsIClassInfo.
 97871:  *
 97871:  * Each XPCWrappedNativeProto has a pointer to its XPCWrappedNativeScope. If an
 97871:  * XPCWrappedNative wraps a C++ object with class info, then it points to its
 97871:  * XPCWrappedNativeProto. Otherwise it points to its XPCWrappedNativeScope. (The
 97871:  * pointers are smooshed together in a tagged union.) Either way it can reach
 97871:  * its scope.
 97871:  *
 97871:  * In the case of slim wrappers (where there is no XPCWrappedNative), the
 97871:  * flattened JS object has a pointer to the XPCWrappedNativeProto stored in a
 97871:  * reserved slot.
 97871:  *
 97871:  * An XPCWrappedNativeProto keeps track of the set of interfaces implemented by
 97871:  * the C++ object in an XPCNativeSet. (The list of interfaces is obtained by
 97871:  * calling a method on the nsIClassInfo.) An XPCNativeSet is a collection of
 97871:  * XPCNativeInterfaces. Each interface stores the list of members, which can be
 97871:  * methods, constants, getters, or setters.
 97871:  *
 97871:  * An XPCWrappedNative also points to an XPCNativeSet. Initially this starts out
 97871:  * the same as the XPCWrappedNativeProto's set. If there is no proto, it starts
 97871:  * out as a singleton set containing nsISupports. If JS code QI's new interfaces
 97871:  * outside of the existing set, the set will grow. All QueryInterface results
 97871:  * are cached in XPCWrappedNativeTearOff objects, which are linked off of the
 97871:  * XPCWrappedNative.
 97871:  *
 97871:  * Besides having class info, a C++ object may be "scriptable" (i.e., implement
 97871:  * nsIXPCScriptable). This allows it to implement a more DOM-like interface,
 97871:  * besides just exposing XPCOM methods and constants. An nsIXPCScriptable
 97871:  * instance has hooks that correspond to all the normal JSClass hooks. Each
 97871:  * nsIXPCScriptable instance is mirrored by an XPCNativeScriptableInfo in
 97871:  * XPConnect. These can have pointers from XPCWrappedNativeProto and
 97871:  * XPCWrappedNative (since C++ objects can have scriptable info without having
 97871:  * class info).
 97871:  *
 97871:  * Most data in an XPCNativeScriptableInfo is shared between instances. The
 97871:  * shared data is stored in an XPCNativeScriptableShared object. This type is
 97871:  * important because it holds the JSClass of the flattened JS objects with the
 97871:  * given scriptable info.
 97871:  */
 97871: 
     1: /* All the XPConnect private declarations - only include locally. */
     1: 
     1: #ifndef xpcprivate_h___
     1: #define xpcprivate_h___
     1: 
 90200: #include "mozilla/Assertions.h"
 86054: #include "mozilla/Attributes.h"
 95340: #include "mozilla/StandardInteger.h"
 91575: #include "mozilla/Util.h"
 86054: 
     1: #include <string.h>
     1: #include <stdlib.h>
     1: #include <stdarg.h>
     1: #include <math.h>
 57854: #include "xpcpublic.h"
 38922: #include "jsapi.h"
 38922: #include "jsdhash.h"
 38922: #include "jsprf.h"
 38922: #include "prprf.h"
 38922: #include "jsdbgapi.h"
 78158: #include "jsfriendapi.h"
 38922: #include "jsgc.h"
 79734: #include "jswrapper.h"
     1: #include "nscore.h"
     1: #include "nsXPCOM.h"
     1: #include "nsAutoPtr.h"
     1: #include "nsCycleCollectionParticipant.h"
     1: #include "nsCycleCollector.h"
 62405: #include "nsDebug.h"
     1: #include "nsISupports.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsIClassInfoImpl.h"
     1: #include "nsIComponentManager.h"
     1: #include "nsIComponentRegistrar.h"
     1: #include "nsISupportsPrimitives.h"
     1: #include "nsMemory.h"
     1: #include "nsIXPConnect.h"
     1: #include "nsIInterfaceInfo.h"
     1: #include "nsIInterfaceInfoManager.h"
     1: #include "nsIXPCScriptable.h"
     1: #include "nsIXPCSecurityManager.h"
     1: #include "nsIJSRuntimeService.h"
     1: #include "nsWeakReference.h"
     1: #include "nsCOMPtr.h"
     1: #include "nsXPTCUtils.h"
     1: #include "xptinfo.h"
 80384: #include "XPCForwards.h"
 80384: #include "XPCLog.h"
     1: #include "xpccomponents.h"
     1: #include "xpcexception.h"
     1: #include "xpcjsid.h"
     1: #include "prlong.h"
     1: #include "prmem.h"
     1: #include "prenv.h"
  9848: #include "prclist.h"
     1: #include "nsString.h"
     1: #include "nsReadableUtils.h"
     1: #include "nsXPIDLString.h"
 21377: #include "nsAutoJSValHolder.h"
 97462: 
 97462: #include "js/HashTable.h"
 82298: #include "mozilla/GuardObjects.h"
 69142: #include "mozilla/ReentrantMonitor.h"
 64576: #include "mozilla/Mutex.h"
     1: 
     1: #include "nsThreadUtils.h"
     1: #include "nsIJSContextStack.h"
 74914: #include "nsIJSEngineTelemetryStats.h"
     1: 
     1: #include "nsIConsoleService.h"
     1: #include "nsIScriptError.h"
     1: #include "nsIExceptionService.h"
     1: 
     1: #include "nsVariant.h"
     1: #include "nsIPropertyBag.h"
     1: #include "nsIProperty.h"
 27300: #include "nsCOMArray.h"
  1104: #include "nsTArray.h"
  7286: #include "nsBaseHashtable.h"
  7286: #include "nsHashKeys.h"
 23258: #include "nsWrapperCache.h"
 49065: #include "nsStringBuffer.h"
 97462: #include "nsDataHashtable.h"
 97462: #include "nsDeque.h"
     1: 
 56703: #include "nsIScriptSecurityManager.h"
 56703: #include "nsNetUtil.h"
 56703: 
     1: #include "nsIXPCScriptNotify.h"  // used to notify: ScriptEvaluated
     1: 
     1: #include "nsIScriptObjectPrincipal.h"
     1: #include "nsIPrincipal.h"
     1: #include "nsISecurityCheckedComponent.h"
 98831: #include "xpcObjectHelper.h"
  3310: #include "nsIThreadInternal.h"
  3310: 
 57556: #ifdef XP_WIN
     1: // Nasty MS defines
 57556: #ifdef GetClassInfo
     1: #undef GetClassInfo
 57556: #endif
 57556: #ifdef GetClassName
     1: #undef GetClassName
     1: #endif
 57556: #endif /* XP_WIN */
     1: 
 51515: #include "nsINode.h"
 48124: 
     1: /***************************************************************************/
     1: // Compile time switches for instrumentation and stuff....
     1: 
     1: // Note that one would not normally turn *any* of these on in a non-DEBUG build.
     1: 
     1: #if defined(DEBUG_jband) || defined(DEBUG_jst) || defined(DEBUG_dbradley) || defined(DEBUG_shaver_no) || defined(DEBUG_timeless)
     1: #define DEBUG_xpc_hacker
     1: #endif
     1: 
     1: #if defined(DEBUG_brendan)
     1: #define DEBUG_XPCNativeWrapper 1
     1: #endif
     1: 
     1: #ifdef DEBUG
     1: #define XPC_DETECT_LEADING_UPPERCASE_ACCESS_ERRORS
 58076: #endif
     1: #define XPC_CHECK_WRAPPER_THREADSAFETY
     1: 
     1: #if defined(DEBUG_xpc_hacker)
     1: #define XPC_DUMP_AT_SHUTDOWN
     1: #define XPC_TRACK_WRAPPER_STATS
     1: #define XPC_TRACK_SCOPE_STATS
     1: #define XPC_TRACK_PROTO_STATS
     1: #define XPC_TRACK_DEFERRED_RELEASES
     1: #define XPC_CHECK_WRAPPERS_AT_SHUTDOWN
     1: #define XPC_REPORT_SHADOWED_WRAPPED_NATIVE_MEMBERS
     1: #define XPC_CHECK_CLASSINFO_CLAIMS
     1: #if defined(DEBUG_jst)
     1: #define XPC_ASSERT_CLASSINFO_CLAIMS
     1: #endif
     1: //#define DEBUG_stats_jband 1
     1: //#define XPC_REPORT_NATIVE_INTERFACE_AND_SET_FLUSHING
     1: //#define XPC_REPORT_JSCLASS_FLUSHING
     1: //#define XPC_TRACK_AUTOMARKINGPTR_STATS
     1: #endif
     1: 
     1: #if defined(DEBUG_dbaron) || defined(DEBUG_bzbarsky) // only part of DEBUG_xpc_hacker!
     1: #define XPC_DUMP_AT_SHUTDOWN
     1: #endif
     1: 
     1: /***************************************************************************/
     1: // conditional forward declarations....
     1: 
     1: #ifdef XPC_REPORT_SHADOWED_WRAPPED_NATIVE_MEMBERS
     1: void DEBUG_ReportShadowedMembers(XPCNativeSet* set,
     1:                                  XPCWrappedNative* wrapper,
     1:                                  XPCWrappedNativeProto* proto);
     1: #else
     1: #define DEBUG_ReportShadowedMembers(set, wrapper, proto) ((void)0)
     1: #endif
     1: 
     1: #ifdef XPC_CHECK_WRAPPER_THREADSAFETY
     1: void DEBUG_ReportWrapperThreadSafetyError(XPCCallContext& ccx,
     1:                                           const char* msg,
     1:                                           const XPCWrappedNative* wrapper);
     1: void DEBUG_CheckWrapperThreadSafety(const XPCWrappedNative* wrapper);
     1: #else
     1: #define DEBUG_CheckWrapperThreadSafety(w) ((void)0)
     1: #endif
     1: 
     1: /***************************************************************************/
     1: // default initial sizes for maps (hashtables)
     1: 
     1: #define XPC_CONTEXT_MAP_SIZE                16
     1: #define XPC_JS_MAP_SIZE                     64
     1: #define XPC_JS_CLASS_MAP_SIZE               64
     1: 
     1: #define XPC_NATIVE_MAP_SIZE                 64
     1: #define XPC_NATIVE_PROTO_MAP_SIZE           16
     1: #define XPC_DYING_NATIVE_PROTO_MAP_SIZE     16
     1: #define XPC_DETACHED_NATIVE_PROTO_MAP_SIZE  32
     1: #define XPC_NATIVE_INTERFACE_MAP_SIZE       64
     1: #define XPC_NATIVE_SET_MAP_SIZE             64
     1: #define XPC_NATIVE_JSCLASS_MAP_SIZE         32
     1: #define XPC_THIS_TRANSLATOR_MAP_SIZE         8
     1: #define XPC_NATIVE_WRAPPER_MAP_SIZE         16
 58722: #define XPC_WRAPPER_MAP_SIZE                16
     1: 
     1: /***************************************************************************/
     1: // data declarations...
     1: extern const char XPC_CONTEXT_STACK_CONTRACTID[];
     1: extern const char XPC_RUNTIME_CONTRACTID[];
     1: extern const char XPC_EXCEPTION_CONTRACTID[];
     1: extern const char XPC_CONSOLE_CONTRACTID[];
     1: extern const char XPC_SCRIPT_ERROR_CONTRACTID[];
     1: extern const char XPC_ID_CONTRACTID[];
     1: extern const char XPC_XPCONNECT_CONTRACTID[];
     1: 
 97462: typedef js::HashSet<JSCompartment *,
 97462:                     js::DefaultHasher<JSCompartment *>,
 97462:                     js::SystemAllocPolicy> XPCCompartmentSet;
 97462: 
 97462: typedef XPCCompartmentSet::Range XPCCompartmentRange;
 48503: 
     1: /***************************************************************************/
 58722: // Useful macros...
     1: 
     1: #define XPC_STRING_GETTER_BODY(dest, src)                                     \
     1:     NS_ENSURE_ARG_POINTER(dest);                                              \
     1:     char* result;                                                             \
     1:     if (src)                                                                  \
     1:         result = (char*) nsMemory::Clone(src,                                 \
     1:                                          sizeof(char)*(strlen(src)+1));       \
     1:     else                                                                      \
     1:         result = nsnull;                                                      \
     1:     *dest = result;                                                           \
     1:     return (result || !src) ? NS_OK : NS_ERROR_OUT_OF_MEMORY
     1: 
  8990: 
 90410: #define WRAPPER_SLOTS (JSCLASS_HAS_PRIVATE | JSCLASS_IMPLEMENTS_BARRIERS | \
 90410:                        JSCLASS_HAS_RESERVED_SLOTS(1))
 30001: 
101164: // WRAPPER_MULTISLOT is defined in xpcpublic.h
101164: 
 48470: #define INVALID_OBJECT ((JSObject *)1)
 48470: 
101164: inline void SetSlimWrapperProto(JSObject *obj, XPCWrappedNativeProto *proto)
101164: {
101164:     JS_SetReservedSlot(obj, WRAPPER_MULTISLOT, PRIVATE_TO_JSVAL(proto));
101164: }
101164: 
101164: inline XPCWrappedNativeProto* GetSlimWrapperProto(JSObject *obj)
101164: {
101164:     MOZ_ASSERT(IS_SLIM_WRAPPER(obj));
101164:     const JS::Value &v = js::GetReservedSlot(obj, WRAPPER_MULTISLOT);
101164:     return static_cast<XPCWrappedNativeProto*>(v.toPrivate());
101164: }
101164: 
101164: // A slim wrapper is identified by having a native pointer in its reserved slot.
101164: // This function, therefore, does the official transition from a slim wrapper to
101164: // a non-slim wrapper.
101164: inline void MorphMultiSlot(JSObject *obj)
101164: {
101164:     MOZ_ASSERT(IS_SLIM_WRAPPER(obj));
101164:     JS_SetReservedSlot(obj, WRAPPER_MULTISLOT, JSVAL_NULL);
101164:     MOZ_ASSERT(!IS_SLIM_WRAPPER(obj));
101164: }
101164: 
101165: inline void SetExpandoChain(JSObject *obj, JSObject *chain)
101165: {
101165:     MOZ_ASSERT(IS_WN_WRAPPER(obj));
101165:     JS_SetReservedSlot(obj, WRAPPER_MULTISLOT, JS::ObjectOrNullValue(chain));
101165: }
101165: 
101165: inline JSObject* GetExpandoChain(JSObject *obj)
101165: {
101165:     MOZ_ASSERT(IS_WN_WRAPPER(obj));
101165:     return JS_GetReservedSlot(obj, WRAPPER_MULTISLOT).toObjectOrNull();
101165: }
101165: 
     1: /***************************************************************************/
     1: // Auto locking support class...
     1: 
     1: // We PROMISE to never screw this up.
     1: #ifdef _MSC_VER
     1: #pragma warning(disable : 4355) // OK to pass "this" in member initializer
     1: #endif
     1: 
 69142: typedef mozilla::ReentrantMonitor XPCLock;
     1: 
     1: static inline void xpc_Wait(XPCLock* lock)
     1:     {
     1:         NS_ASSERTION(lock, "xpc_Wait called with null lock!");
 64576:         lock->Wait();
     1:     }
     1: 
     1: static inline void xpc_NotifyAll(XPCLock* lock)
     1:     {
     1:         NS_ASSERTION(lock, "xpc_NotifyAll called with null lock!");
 64576:         lock->NotifyAll();
     1:     }
     1: 
     1: // This is a cloned subset of nsAutoMonitor. We want the use of a monitor -
     1: // mostly because we need reenterability - but we also want to support passing
     1: // a null monitor in without things blowing up. This is used for wrappers that
     1: // are guaranteed to be used only on one thread. We avoid lock overhead by
     1: // using a null monitor. By changing this class we can avoid having multiplte
     1: // code paths or (conditional) manual calls to PR_{Enter,Exit}Monitor.
     1: //
     1: // Note that xpconnect only makes *one* monitor and *mostly* holds it locked
     1: // only through very small critical sections.
     1: 
 64576: class NS_STACK_CLASS XPCAutoLock {
     1: public:
     1: 
     1:     static XPCLock* NewLock(const char* name)
 69142:                         {return new mozilla::ReentrantMonitor(name);}
     1:     static void     DestroyLock(XPCLock* lock)
 64576:                         {delete lock;}
     1: 
 86900:     XPCAutoLock(XPCLock* lock MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
 64576:         : mLock(lock)
     1:     {
 86900:         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
     1:         if (mLock)
 64576:             mLock->Enter();
     1:     }
     1: 
     1:     ~XPCAutoLock()
     1:     {
 80389:         if (mLock) {
 64576:             mLock->Exit();
     1:         }
     1:     }
     1: 
     1: private:
     1:     XPCLock*  mLock;
 86900:     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
     1: 
     1:     // Not meant to be implemented. This makes it a compiler error to
     1:     // construct or assign an XPCAutoLock object incorrectly.
     1:     XPCAutoLock(void) {}
     1:     XPCAutoLock(XPCAutoLock& /*aMon*/) {}
     1:     XPCAutoLock& operator =(XPCAutoLock& /*aMon*/) {
     1:         return *this;
     1:     }
     1: 
     1:     // Not meant to be implemented. This makes it a compiler error to
     1:     // attempt to create an XPCAutoLock object on the heap.
     1:     static void* operator new(size_t /*size*/) CPP_THROW_NEW {
     1:         return nsnull;
     1:     }
     1:     static void operator delete(void* /*memory*/) {}
     1: };
     1: 
     1: /************************************************/
     1: 
 64576: class NS_STACK_CLASS XPCAutoUnlock {
     1: public:
 86900:     XPCAutoUnlock(XPCLock* lock MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
 64576:         : mLock(lock)
     1:     {
 86900:         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
 80389:         if (mLock) {
 64576:             mLock->Exit();
     1:         }
     1:     }
     1: 
     1:     ~XPCAutoUnlock()
     1:     {
     1:         if (mLock)
 64576:             mLock->Enter();
     1:     }
     1: 
     1: private:
     1:     XPCLock*  mLock;
 86900:     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
     1: 
     1:     // Not meant to be implemented. This makes it a compiler error to
     1:     // construct or assign an XPCAutoUnlock object incorrectly.
     1:     XPCAutoUnlock(void) {}
     1:     XPCAutoUnlock(XPCAutoUnlock& /*aMon*/) {}
     1:     XPCAutoUnlock& operator =(XPCAutoUnlock& /*aMon*/) {
     1:         return *this;
     1:     }
     1: 
     1:     // Not meant to be implemented. This makes it a compiler error to
     1:     // attempt to create an XPCAutoUnlock object on the heap.
     1:     static void* operator new(size_t /*size*/) CPP_THROW_NEW {
     1:         return nsnull;
     1:     }
     1:     static void operator delete(void* /*memory*/) {}
     1: };
     1: 
     1: /***************************************************************************
     1: ****************************************************************************
     1: *
     1: * Core runtime and context classes...
     1: *
     1: ****************************************************************************
     1: ***************************************************************************/
     1: 
     1: // We have a general rule internally that getters that return addref'd interface
     1: // pointer generally do so using an 'out' parm. When interface pointers are
     1: // returned as function call result values they are not addref'd. Exceptions
     1: // to this rule are noted explicitly.
     1: 
 81559: // JSTRACE_XML can recursively hold on to more JSTRACE_XML objects, adding it to
 81559: // the cycle collector avoids stack overflow.
 81559: inline bool
 81559: AddToCCKind(JSGCTraceKind kind)
 81559: {
 81559:     return kind == JSTRACE_OBJECT || kind == JSTRACE_XML || kind == JSTRACE_SCRIPT;
 81559: }
 81559: 
     1: class nsXPConnect : public nsIXPConnect,
  3310:                     public nsIThreadObserver,
     1:                     public nsSupportsWeakReference,
  7286:                     public nsCycleCollectionJSRuntime,
 20312:                     public nsCycleCollectionParticipant,
 20462:                     public nsIJSRuntimeService,
 74914:                     public nsIThreadJSContextStack,
 74914:                     public nsIJSEngineTelemetryStats
     1: {
     1: public:
     1:     // all the interface method declarations...
     1:     NS_DECL_ISUPPORTS
     1:     NS_DECL_NSIXPCONNECT
  3310:     NS_DECL_NSITHREADOBSERVER
 20312:     NS_DECL_NSIJSRUNTIMESERVICE
 20462:     NS_DECL_NSIJSCONTEXTSTACK
 20462:     NS_DECL_NSITHREADJSCONTEXTSTACK
 74914:     NS_DECL_NSIJSENGINETELEMETRYSTATS
     1: 
     1:     // non-interface implementation
     1: public:
     1:     // These get non-addref'd pointers
     1:     static nsXPConnect*  GetXPConnect();
 47412:     static nsXPConnect*  FastGetXPConnect() { return gSelf ? gSelf : GetXPConnect(); }
 20312:     static XPCJSRuntime* GetRuntimeInstance();
 20312:     XPCJSRuntime* GetRuntime() {return mRuntime;}
     1: 
     1:     // Gets addref'd pointer
     1:     static nsresult GetInterfaceInfoManager(nsIInterfaceInfoSuperManager** iim,
     1:                                             nsXPConnect* xpc = nsnull);
     1: 
     1:     static JSBool IsISupportsDescendant(nsIInterfaceInfo* info);
     1: 
     1:     nsIXPCSecurityManager* GetDefaultSecurityManager() const
 54276:     {
 54276:         // mDefaultSecurityManager is main-thread only.
 54276:         if (!NS_IsMainThread()) {
 54276:             return nsnull;
 54276:         }
 54276:         return mDefaultSecurityManager;
 54276:     }
     1: 
     1:     PRUint16 GetDefaultSecurityManagerFlags() const
     1:         {return mDefaultSecurityManagerFlags;}
     1: 
     1:     // This returns an AddRef'd pointer. It does not do this with an 'out' param
     1:     // only because this form is required by the generic module macro:
     1:     // NS_GENERIC_FACTORY_SINGLETON_CONSTRUCTOR
     1:     static nsXPConnect* GetSingleton();
     1: 
     1:     // Called by module code in dll startup
 82794:     static void InitStatics() { gSelf = nsnull; gOnceAliveNowDead = false; }
     1:     // Called by module code on dll shutdown.
     1:     static void ReleaseXPConnectSingleton();
     1: 
     1:     virtual ~nsXPConnect();
     1: 
     1:     JSBool IsShuttingDown() const {return mShuttingDown;}
     1: 
 82794:     void EnsureGCBeforeCC() { mNeedGCBeforeCC = true; }
 90410:     void ClearGCBeforeCC() { mNeedGCBeforeCC = false; }
 71367: 
     1:     nsresult GetInfoForIID(const nsIID * aIID, nsIInterfaceInfo** info);
     1:     nsresult GetInfoForName(const char * name, nsIInterfaceInfo** info);
     1: 
  3669:     // nsCycleCollectionParticipant
 67681:     NS_IMETHOD Root(void *p);
  1829:     NS_IMETHOD Unlink(void *p);
  1829:     NS_IMETHOD Unroot(void *p);
  1829:     NS_IMETHOD Traverse(void *p,
  1829:                         nsCycleCollectionTraversalCallback &cb);
  3669: 
  3669:     // nsCycleCollectionLanguageRuntime
 88135:     virtual bool NotifyLeaveMainThread();
 81562:     virtual void NotifyEnterCycleCollectionThread();
 81562:     virtual void NotifyLeaveCycleCollectionThread();
 81562:     virtual void NotifyEnterMainThread();
 96941:     virtual nsresult BeginCycleCollection(nsCycleCollectionTraversalCallback &cb);
 57794:     virtual nsresult FinishTraverse();
 97523:     virtual nsCycleCollectionParticipant *GetParticipant();
 71367:     virtual bool NeedCollect();
 88182:     virtual void Collect(PRUint32 reason, PRUint32 kind);
  1829: 
 61809:     XPCCallContext *GetCycleCollectionContext()
 61809:     {
 61809:         return mCycleCollectionContext;
 61809:     }
 61809: 
 53548:     unsigned GetOutstandingRequests(JSContext* cx);
  7286: 
  7286:     // This returns the singleton nsCycleCollectionParticipant for JSContexts.
  7286:     static nsCycleCollectionParticipant *JSContextParticipant();
  7286: 
 30001:     virtual nsIPrincipal* GetPrincipal(JSObject* obj,
 79445:                                        bool allowShortCircuit) const;
 30001: 
     1:     void RecordTraversal(void *p, nsISupports *s);
 79445:     virtual char* DebugPrintJSStack(bool showArgs,
 79445:                                     bool showLocals,
 79445:                                     bool showThisProps);
 79445: 
 79445: 
 79445:     static bool ReportAllJSExceptions()
 14170:     {
 14170:       return gReportAllJSExceptions > 0;
 14170:     }
     1: 
 82537:     static void CheckForDebugMode(JSRuntime *rt);
 82537: 
     1: protected:
     1:     nsXPConnect();
     1: 
     1: private:
     1:     static PRThread* FindMainThread();
     1: 
     1: private:
     1:     // Singleton instance
     1:     static nsXPConnect*      gSelf;
     1:     static JSBool            gOnceAliveNowDead;
     1: 
     1:     XPCJSRuntime*            mRuntime;
     1:     nsCOMPtr<nsIInterfaceInfoSuperManager> mInterfaceInfoManager;
     1:     nsIXPCSecurityManager*   mDefaultSecurityManager;
     1:     PRUint16                 mDefaultSecurityManagerFlags;
     1:     JSBool                   mShuttingDown;
 71367:     JSBool                   mNeedGCBeforeCC;
 87321: 
 87321:     // nsIThreadInternal doesn't remember which observers it called
 87321:     // OnProcessNextEvent on when it gets around to calling AfterProcessNextEvent.
 87321:     // So if XPConnect gets initialized mid-event (which can happen), we'll get
 87321:     // an 'after' notification without getting an 'on' notification. If we don't
 87321:     // watch out for this, we'll do an unmatched |pop| on the context stack.
 87321:     PRUint16                   mEventDepth;
 48507:     nsAutoPtr<XPCCallContext> mCycleCollectionContext;
     1: 
 93686:     typedef nsBaseHashtable<nsPtrHashKey<void>, nsISupports*, nsISupports*> ScopeSet;
  7286:     ScopeSet mScopes;
 20312:     nsCOMPtr<nsIXPCScriptable> mBackstagePass;
 20312: 
 14170:     static PRUint32 gReportAllJSExceptions;
 56783:     static JSBool gDebugMode;
 56783:     static JSBool gDesiredDebugMode;
 56703: 
 56703: public:
 56703:     static nsIScriptSecurityManager *gScriptSecurityManager;
     1: };
     1: 
     1: /***************************************************************************/
     1: 
  2072: class XPCRootSetElem
  2072: {
  2072: public:
  2072:     XPCRootSetElem()
  2072:     {
  2072: #ifdef DEBUG
  2072:         mNext = nsnull;
  2072:         mSelfp = nsnull;
  2072: #endif
  2072:     }
  2072: 
  2072:     ~XPCRootSetElem()
  2072:     {
  2072:         NS_ASSERTION(!mNext, "Must be unlinked");
  2072:         NS_ASSERTION(!mSelfp, "Must be unlinked");
  2072:     }
  2072: 
  2072:     inline XPCRootSetElem* GetNextRoot() { return mNext; }
 57794:     void AddToRootSet(XPCLock *lock, XPCRootSetElem **listHead);
 57794:     void RemoveFromRootSet(XPCLock *lock);
  2072: 
  2072: private:
  2072:     XPCRootSetElem *mNext;
  2072:     XPCRootSetElem **mSelfp;
  2072: };
  2072: 
  2072: /***************************************************************************/
  2072: 
     1: // In the current xpconnect system there can only be one XPCJSRuntime.
     1: // So, xpconnect can only be used on one JSRuntime within the process.
     1: 
     1: // no virtuals. no refcounting.
     1: class XPCJSRuntime
     1: {
     1: public:
 20312:     static XPCJSRuntime* newXPCJSRuntime(nsXPConnect* aXPConnect);
     1: 
     1:     JSRuntime*     GetJSRuntime() const {return mJSRuntime;}
     1:     nsXPConnect*   GetXPConnect() const {return mXPConnect;}
 74825:     JSContext*     GetJSCycleCollectionContext();
     1: 
     1:     JSObject2WrappedJSMap*     GetWrappedJSMap()        const
     1:         {return mWrappedJSMap;}
     1: 
     1:     IID2WrappedJSClassMap*     GetWrappedJSClassMap()   const
     1:         {return mWrappedJSClassMap;}
     1: 
     1:     IID2NativeInterfaceMap* GetIID2NativeInterfaceMap() const
     1:         {return mIID2NativeInterfaceMap;}
     1: 
     1:     ClassInfo2NativeSetMap* GetClassInfo2NativeSetMap() const
     1:         {return mClassInfo2NativeSetMap;}
     1: 
     1:     NativeSetMap* GetNativeSetMap() const
     1:         {return mNativeSetMap;}
     1: 
     1:     IID2ThisTranslatorMap* GetThisTranslatorMap() const
     1:         {return mThisTranslatorMap;}
     1: 
     1:     XPCNativeScriptableSharedMap* GetNativeScriptableSharedMap() const
     1:         {return mNativeScriptableSharedMap;}
     1: 
     1:     XPCWrappedNativeProtoMap* GetDyingWrappedNativeProtoMap() const
     1:         {return mDyingWrappedNativeProtoMap;}
     1: 
     1:     XPCWrappedNativeProtoMap* GetDetachedWrappedNativeProtoMap() const
     1:         {return mDetachedWrappedNativeProtoMap;}
     1: 
 97462:     XPCCompartmentSet& GetCompartmentSet()
 97462:         {return mCompartmentSet;}
 48503: 
     1:     XPCLock* GetMapLock() const {return mMapLock;}
     1: 
 20312:     JSBool OnJSContextNew(JSContext* cx);
     1: 
     1:     JSBool DeferredRelease(nsISupports* obj);
     1: 
     1:     JSBool GetDoingFinalization() const {return mDoingFinalization;}
     1: 
     1:     // Mapping of often used strings to jsid atoms that live 'forever'.
     1:     //
     1:     // To add a new string: add to this list and to XPCJSRuntime::mStrings
     1:     // at the top of xpcjsruntime.cpp
     1:     enum {
     1:         IDX_CONSTRUCTOR             = 0 ,
     1:         IDX_TO_STRING               ,
     1:         IDX_TO_SOURCE               ,
     1:         IDX_LAST_RESULT             ,
     1:         IDX_RETURN_CODE             ,
     1:         IDX_VALUE                   ,
     1:         IDX_QUERY_INTERFACE         ,
     1:         IDX_COMPONENTS              ,
     1:         IDX_WRAPPED_JSOBJECT        ,
     1:         IDX_OBJECT                  ,
     1:         IDX_FUNCTION                ,
     1:         IDX_PROTOTYPE               ,
     1:         IDX_CREATE_INSTANCE         ,
     1:         IDX_ITEM                    ,
  6464:         IDX_PROTO                   ,
  6464:         IDX_ITERATOR                ,
 33352:         IDX_EXPOSEDPROPS            ,
 55629:         IDX_SCRIPTONLY              ,
 78692:         IDX_BASEURIOBJECT           ,
 78692:         IDX_NODEPRINCIPAL           ,
 78692:         IDX_DOCUMENTURIOBJECT       ,
     1:         IDX_TOTAL_COUNT // just a count of the above
     1:     };
     1: 
 91237:     jsid GetStringID(unsigned index) const
     1:     {
     1:         NS_ASSERTION(index < IDX_TOTAL_COUNT, "index out of range");
     1:         return mStrIDs[index];
     1:     }
 91237:     jsval GetStringJSVal(unsigned index) const
     1:     {
     1:         NS_ASSERTION(index < IDX_TOTAL_COUNT, "index out of range");
     1:         return mStrJSVals[index];
     1:     }
 91237:     const char* GetStringName(unsigned index) const
     1:     {
     1:         NS_ASSERTION(index < IDX_TOTAL_COUNT, "index out of range");
     1:         return mStrings[index];
     1:     }
     1: 
 80159:     static void TraceBlackJS(JSTracer* trc, void* data);
 80159:     static void TraceGrayJS(JSTracer* trc, void* data);
 48479:     void TraceXPConnectRoots(JSTracer *trc);
 91250:     void AddXPConnectRoots(nsCycleCollectionTraversalCallback& cb);
 89871:     void UnmarkSkippableJSHolders();
  1025: 
 91339:     static void GCCallback(JSRuntime *rt, JSGCStatus status);
 99487:     static void FinalizeCallback(JSFreeOp *fop, JSFinalizeStatus status, JSBool isCompartmentGC);
     1: 
  2072:     inline void AddVariantRoot(XPCTraceableVariant* variant);
  2072:     inline void AddWrappedJSRoot(nsXPCWrappedJS* wrappedJS);
  2072:     inline void AddObjectHolderRoot(XPCJSObjectHolder* holder);
  2072: 
  7230:     nsresult AddJSHolder(void* aHolder, nsScriptObjectTracer* aTracer);
  7230:     nsresult RemoveJSHolder(void* aHolder);
  7230: 
 91250:     static void SuspectWrappedNative(XPCWrappedNative *wrapper,
 61809:                                      nsCycleCollectionTraversalCallback &cb);
 61809: 
     1:     void DebugDump(PRInt16 depth);
     1: 
 89826:     void SystemIsBeingShutDown();
     1: 
     1:     PRThread* GetThreadRunningGC() const {return mThreadRunningGC;}
     1: 
     1:     ~XPCJSRuntime();
     1: 
     1: #ifdef XPC_CHECK_WRAPPERS_AT_SHUTDOWN
     1:    void DEBUG_AddWrappedNative(nsIXPConnectWrappedNative* wrapper)
     1:         {XPCAutoLock lock(GetMapLock());
     1:          JSDHashEntryHdr *entry =
     1:             JS_DHashTableOperate(DEBUG_WrappedNativeHashtable,
     1:                                  wrapper, JS_DHASH_ADD);
     1:          if (entry) ((JSDHashEntryStub *)entry)->key = wrapper;}
     1: 
     1:    void DEBUG_RemoveWrappedNative(nsIXPConnectWrappedNative* wrapper)
     1:         {XPCAutoLock lock(GetMapLock());
     1:          JS_DHashTableOperate(DEBUG_WrappedNativeHashtable,
     1:                               wrapper, JS_DHASH_REMOVE);}
     1: private:
     1:    JSDHashTable* DEBUG_WrappedNativeHashtable;
     1: public:
     1: #endif
     1: 
 36094:     void AddGCCallback(JSGCCallback cb);
 36094:     void RemoveGCCallback(JSGCCallback cb);
 36094: 
 74834:     static void ActivityCallback(void *arg, JSBool active);
 50462: 
 80085:     bool NewDOMBindingsEnabled()
 80085:     {
 80085:         return gNewDOMBindingsEnabled;
 80085:     }
 80085: 
 96736:     bool ExperimentalBindingsEnabled()
 94512:     {
 96736:         return gExperimentalBindingsEnabled;
 94512:     }
 94512: 
 83471:     size_t SizeOfIncludingThis(nsMallocSizeOfFun mallocSizeOf);
 83471: 
     1: private:
     1:     XPCJSRuntime(); // no implementation
 20312:     XPCJSRuntime(nsXPConnect* aXPConnect);
     1: 
 25087:     // The caller must be holding the GC lock
 25087:     void RescheduleWatchdog(XPCContext* ccx);
 25087: 
 25087:     static void WatchdogMain(void *arg);
 25087: 
 80085:     static bool gNewDOMBindingsEnabled;
 96736:     static bool gExperimentalBindingsEnabled;
 80085: 
     1:     static const char* mStrings[IDX_TOTAL_COUNT];
     1:     jsid mStrIDs[IDX_TOTAL_COUNT];
     1:     jsval mStrJSVals[IDX_TOTAL_COUNT];
     1: 
     1:     nsXPConnect*             mXPConnect;
     1:     JSRuntime*               mJSRuntime;
 74825:     JSContext*               mJSCycleCollectionContext;
     1:     JSObject2WrappedJSMap*   mWrappedJSMap;
     1:     IID2WrappedJSClassMap*   mWrappedJSClassMap;
     1:     IID2NativeInterfaceMap*  mIID2NativeInterfaceMap;
     1:     ClassInfo2NativeSetMap*  mClassInfo2NativeSetMap;
     1:     NativeSetMap*            mNativeSetMap;
     1:     IID2ThisTranslatorMap*   mThisTranslatorMap;
     1:     XPCNativeScriptableSharedMap* mNativeScriptableSharedMap;
     1:     XPCWrappedNativeProtoMap* mDyingWrappedNativeProtoMap;
     1:     XPCWrappedNativeProtoMap* mDetachedWrappedNativeProtoMap;
 97462:     XPCCompartmentSet        mCompartmentSet;
     1:     XPCLock* mMapLock;
     1:     PRThread* mThreadRunningGC;
 26582:     nsTArray<nsXPCWrappedJS*> mWrappedJSToReleaseArray;
 26582:     nsTArray<nsISupports*> mNativesToReleaseArray;
     1:     JSBool mDoingFinalization;
  2072:     XPCRootSetElem *mVariantRoots;
  2072:     XPCRootSetElem *mWrappedJSRoots;
  2072:     XPCRootSetElem *mObjectHolderRoots;
  7230:     JSDHashTable mJSHolders;
 91846:     PRLock *mWatchdogLock;
 25087:     PRCondVar *mWatchdogWakeup;
 25087:     PRThread *mWatchdogThread;
 36094:     nsTArray<JSGCCallback> extraGCCallbacks;
 79445:     bool mWatchdogHibernating;
 50462:     PRTime mLastActiveTime; // -1 if active NOW
 91846: 
 91846:     friend class AutoLockWatchdog;
     1: };
     1: 
     1: /***************************************************************************/
     1: /***************************************************************************/
     1: // XPCContext is mostly a dumb class to hold JSContext specific data and
     1: // maps that let us find wrappers created for the given JSContext.
     1: 
     1: // no virtuals
     1: class XPCContext
     1: {
 20312:     friend class XPCJSRuntime;
     1: public:
 20312:     static XPCContext* GetXPCContext(JSContext* aJSContext)
 20312:         {
 86983:             NS_ASSERTION(JS_GetSecondContextPrivate(aJSContext), "should already have XPCContext");
 86983:             return static_cast<XPCContext *>(JS_GetSecondContextPrivate(aJSContext));
 20312:         }
     1: 
     1:     XPCJSRuntime* GetRuntime() const {return mRuntime;}
     1:     JSContext* GetJSContext() const {return mJSContext;}
     1: 
     1:     enum LangType {LANG_UNKNOWN, LANG_JS, LANG_NATIVE};
     1: 
     1:     LangType GetCallingLangType() const
     1:         {
     1:             return mCallingLangType;
     1:         }
     1:     LangType SetCallingLangType(LangType lt)
     1:         {
     1:             LangType tmp = mCallingLangType;
     1:             mCallingLangType = lt;
     1:             return tmp;
     1:         }
     1:     JSBool CallerTypeIsJavaScript() const
     1:         {
     1:             return LANG_JS == mCallingLangType;
     1:         }
     1:     JSBool CallerTypeIsNative() const
     1:         {
     1:             return LANG_NATIVE == mCallingLangType;
     1:         }
     1:     JSBool CallerTypeIsKnown() const
     1:         {
     1:             return LANG_UNKNOWN != mCallingLangType;
     1:         }
     1: 
     1:     nsresult GetException(nsIException** e)
     1:         {
     1:             NS_IF_ADDREF(mException);
     1:             *e = mException;
     1:             return NS_OK;
     1:         }
     1:     void SetException(nsIException* e)
     1:         {
     1:             NS_IF_ADDREF(e);
     1:             NS_IF_RELEASE(mException);
     1:             mException = e;
     1:         }
     1: 
     1:     nsresult GetLastResult() {return mLastResult;}
     1:     void SetLastResult(nsresult rc) {mLastResult = rc;}
     1: 
     1:     nsresult GetPendingResult() {return mPendingResult;}
     1:     void SetPendingResult(nsresult rc) {mPendingResult = rc;}
     1: 
     1:     nsIXPCSecurityManager* GetSecurityManager() const
     1:         {return mSecurityManager;}
     1:     void SetSecurityManager(nsIXPCSecurityManager* aSecurityManager)
     1:         {mSecurityManager = aSecurityManager;}
     1: 
     1:     PRUint16 GetSecurityManagerFlags() const
     1:         {return mSecurityManagerFlags;}
     1:     void SetSecurityManagerFlags(PRUint16 f)
     1:         {mSecurityManagerFlags = f;}
     1: 
     1:     nsIXPCSecurityManager* GetAppropriateSecurityManager(PRUint16 flags) const
     1:         {
     1:             NS_ASSERTION(CallerTypeIsKnown(),"missing caller type set somewhere");
     1:             if (!CallerTypeIsJavaScript())
     1:                 return nsnull;
 80389:             if (mSecurityManager) {
     1:                 if (flags & mSecurityManagerFlags)
     1:                     return mSecurityManager;
 80390:             } else {
     1:                 nsIXPCSecurityManager* mgr;
     1:                 nsXPConnect* xpc = mRuntime->GetXPConnect();
     1:                 mgr = xpc->GetDefaultSecurityManager();
     1:                 if (mgr && (flags & xpc->GetDefaultSecurityManagerFlags()))
     1:                     return mgr;
     1:             }
     1:             return nsnull;
     1:         }
     1: 
     1:     void DebugDump(PRInt16 depth);
 10291:     void AddScope(PRCList *scope) { PR_INSERT_AFTER(scope, &mScopes); }
 10291:     void RemoveScope(PRCList *scope) { PR_REMOVE_LINK(scope); }
     1: 
     1:     ~XPCContext();
     1: 
     1: private:
     1:     XPCContext();    // no implementation
     1:     XPCContext(XPCJSRuntime* aRuntime, JSContext* aJSContext);
     1: 
 20312:     static XPCContext* newXPCContext(XPCJSRuntime* aRuntime,
 20312:                                      JSContext* aJSContext);
     1: private:
     1:     XPCJSRuntime* mRuntime;
     1:     JSContext*  mJSContext;
     1:     nsresult mLastResult;
     1:     nsresult mPendingResult;
     1:     nsIXPCSecurityManager* mSecurityManager;
     1:     nsIException* mException;
     1:     LangType mCallingLangType;
     1:     PRUint16 mSecurityManagerFlags;
 10291: 
 10291:     // A linked list of scopes to notify when we are destroyed.
 10291:     PRCList mScopes;
     1: };
     1: 
     1: /***************************************************************************/
     1: 
     1: #define NATIVE_CALLER  XPCContext::LANG_NATIVE
     1: #define JS_CALLER      XPCContext::LANG_JS
     1: 
  9332: // class to export a JSString as an const nsAString, no refcounting :(
  9332: class XPCReadableJSStringWrapper : public nsDependentString
  9332: {
  9332: public:
  9332:     typedef nsDependentString::char_traits char_traits;
  9332: 
 26502:     XPCReadableJSStringWrapper(const PRUnichar *chars, size_t length) :
  9332:         nsDependentString(chars, length)
  9332:     { }
  9332: 
  9332:     XPCReadableJSStringWrapper() :
  9332:         nsDependentString(char_traits::sEmptyBuffer, char_traits::sEmptyBuffer)
 80486:     { SetIsVoid(true); }
 26502: 
 59889:     JSBool init(JSContext* aContext, JSString* str)
 59889:     {
 59889:         size_t length;
 59889:         const jschar* chars = JS_GetStringCharsZAndLength(aContext, str, &length);
 59889:         if (!chars)
 82794:             return false;
 59889: 
 59889:         NS_ASSERTION(IsEmpty(), "init() on initialized string");
 59889:         new(static_cast<nsDependentString *>(this)) nsDependentString(chars, length);
 82794:         return true;
 59889:     }
  9332: };
  9332: 
     1: // No virtuals
     1: // XPCCallContext is ALWAYS declared as a local variable in some function;
     1: // i.e. instance lifetime is always controled by some C++ function returning.
     1: //
     1: // These things are created frequently in many places. We *intentionally* do
     1: // not inialialize all members in order to save on construction overhead.
     1: // Some constructor pass more valid params than others. We init what must be
     1: // init'd and leave other members undefined. In debug builds the accessors
     1: // use a CHECK_STATE macro to track whether or not the object is in a valid
     1: // state to answer the question a caller might be asking. As long as this
     1: // class is maintained correctly it can do its job without a bunch of added
     1: // overhead from useless initializations and non-DEBUG error checking.
     1: //
     1: // Note that most accessors are inlined.
     1: 
 10286: class XPCCallContext : public nsAXPCNativeCallContext
     1: {
     1: public:
 10286:     NS_IMETHOD GetCallee(nsISupports **aResult);
 10286:     NS_IMETHOD GetCalleeMethodIndex(PRUint16 *aResult);
 10286:     NS_IMETHOD GetCalleeWrapper(nsIXPConnectWrappedNative **aResult);
 10286:     NS_IMETHOD GetJSContext(JSContext **aResult);
 10286:     NS_IMETHOD GetArgc(PRUint32 *aResult);
 10286:     NS_IMETHOD GetArgvPtr(jsval **aResult);
 10286:     NS_IMETHOD GetCalleeInterface(nsIInterfaceInfo **aResult);
 10286:     NS_IMETHOD GetCalleeClassInfo(nsIClassInfo **aResult);
 20343:     NS_IMETHOD GetPreviousCallContext(nsAXPCNativeCallContext **aResult);
 20343:     NS_IMETHOD GetLanguage(PRUint16 *aResult);
     1: 
 91237:     enum {NO_ARGS = (unsigned) -1};
     1: 
     1:     XPCCallContext(XPCContext::LangType callerLanguage,
     1:                    JSContext* cx    = nsnull,
     1:                    JSObject* obj    = nsnull,
     1:                    JSObject* funobj = nsnull,
 48470:                    jsid id          = JSID_VOID,
 91237:                    unsigned argc       = NO_ARGS,
     1:                    jsval *argv      = nsnull,
     1:                    jsval *rval      = nsnull);
     1: 
     1:     virtual ~XPCCallContext();
     1: 
     1:     inline JSBool                       IsValid() const ;
     1: 
     1:     inline nsXPConnect*                 GetXPConnect() const ;
     1:     inline XPCJSRuntime*                GetRuntime() const ;
     1:     inline XPCPerThreadData*            GetThreadData() const ;
     1:     inline XPCContext*                  GetXPCContext() const ;
     1:     inline JSContext*                   GetJSContext() const ;
     1:     inline JSBool                       GetContextPopRequired() const ;
     1:     inline XPCContext::LangType         GetCallerLanguage() const ;
     1:     inline XPCContext::LangType         GetPrevCallerLanguage() const ;
     1:     inline XPCCallContext*              GetPrevCallContext() const ;
     1: 
 62405:     /*
 62405:      * The 'scope for new JSObjects' will be the scope for objects created when
 62405:      * carrying out a JS/C++ call. This member is only available if HAVE_SCOPE.
 62405:      * The object passed to the ccx constructor is used as the scope for new
 62405:      * JSObjects. However, this object is also queried for a wrapper, so
 62405:      * clients that don't want a wrapper (and thus pass NULL to the ccx
 62405:      * constructor) need to manually call SetScopeForNewJSObjects.
 62405:      */
 62405:     inline JSObject*                    GetScopeForNewJSObjects() const ;
 62405:     inline void                         SetScopeForNewJSObjects(JSObject *obj) ;
 62405: 
     1:     inline JSObject*                    GetFlattenedJSObject() const ;
     1:     inline nsISupports*                 GetIdentityObject() const ;
     1:     inline XPCWrappedNative*            GetWrapper() const ;
 30001:     inline XPCWrappedNativeProto*       GetProto() const ;
     1: 
     1:     inline JSBool                       CanGetTearOff() const ;
     1:     inline XPCWrappedNativeTearOff*     GetTearOff() const ;
     1: 
     1:     inline XPCNativeScriptableInfo*     GetScriptableInfo() const ;
     1:     inline JSBool                       CanGetSet() const ;
     1:     inline XPCNativeSet*                GetSet() const ;
     1:     inline JSBool                       CanGetInterface() const ;
     1:     inline XPCNativeInterface*          GetInterface() const ;
     1:     inline XPCNativeMember*             GetMember() const ;
     1:     inline JSBool                       HasInterfaceAndMember() const ;
 48470:     inline jsid                         GetName() const ;
     1:     inline JSBool                       GetStaticMemberIsLocal() const ;
 91237:     inline unsigned                        GetArgc() const ;
     1:     inline jsval*                       GetArgv() const ;
     1:     inline jsval*                       GetRetVal() const ;
     1: 
     1:     inline PRUint16                     GetMethodIndex() const ;
     1:     inline void                         SetMethodIndex(PRUint16 index) ;
     1: 
     1:     inline JSBool   GetDestroyJSContextInDestructor() const;
     1:     inline void     SetDestroyJSContextInDestructor(JSBool b);
     1: 
 48470:     inline jsid GetResolveName() const;
 48470:     inline jsid SetResolveName(jsid name);
     1: 
     1:     inline XPCWrappedNative* GetResolvingWrapper() const;
     1:     inline XPCWrappedNative* SetResolvingWrapper(XPCWrappedNative* w);
     1: 
     1:     inline void SetRetVal(jsval val);
     1: 
 48470:     void SetName(jsid name);
 91237:     void SetArgsAndResultPtr(unsigned argc, jsval *argv, jsval *rval);
     1:     void SetCallInfo(XPCNativeInterface* iface, XPCNativeMember* member,
     1:                      JSBool isSetter);
     1: 
     1:     nsresult  CanCallNow();
     1: 
     1:     void SystemIsBeingShutDown();
     1: 
     1:     operator JSContext*() const {return GetJSContext();}
     1: 
 59889:     XPCReadableJSStringWrapper *NewStringWrapper(const PRUnichar *str, PRUint32 len);
  9332:     void DeleteString(nsAString *string);
  9332: 
     1: private:
     1: 
     1:     // no copy ctor or assignment allowed
     1:     XPCCallContext(const XPCCallContext& r); // not implemented
     1:     XPCCallContext& operator= (const XPCCallContext& r); // not implemented
     1: 
 31395:     friend class XPCLazyCallContext;
 31395:     XPCCallContext(XPCContext::LangType callerLanguage,
 31395:                    JSContext* cx,
 31395:                    JSBool callBeginRequest,
 31395:                    JSObject* obj,
 62405:                    JSObject* flattenedJSObject,
 31395:                    XPCWrappedNative* wn,
 31395:                    XPCWrappedNativeTearOff* tearoff);
 31395: 
 62405:     enum WrapperInitOptions {
 62405:         WRAPPER_PASSED_TO_CONSTRUCTOR,
 62405:         INIT_SHOULD_LOOKUP_WRAPPER
 62405:     };
 62405: 
 31395:     void Init(XPCContext::LangType callerLanguage,
 31395:               JSBool callBeginRequest,
 31395:               JSObject* obj,
 31395:               JSObject* funobj,
 62405:               WrapperInitOptions wrapperInitOptions,
 48470:               jsid name,
 91237:               unsigned argc,
 31395:               jsval *argv,
 31395:               jsval *rval);
 31395: 
     1: private:
     1:     // posible values for mState
     1:     enum State {
     1:         INIT_FAILED,
     1:         SYSTEM_SHUTDOWN,
     1:         HAVE_CONTEXT,
 62405:         HAVE_SCOPE,
     1:         HAVE_OBJECT,
     1:         HAVE_NAME,
     1:         HAVE_ARGS,
     1:         READY_TO_CALL,
     1:         CALL_DONE
     1:     };
     1: 
     1: #ifdef DEBUG
     1: inline void CHECK_STATE(int s) const {NS_ASSERTION(mState >= s, "bad state");}
     1: #else
     1: #define CHECK_STATE(s) ((void)0)
     1: #endif
     1: 
     1: private:
     1:     State                           mState;
     1: 
     1:     nsXPConnect*                    mXPC;
     1: 
     1:     XPCPerThreadData*               mThreadData;
     1:     XPCContext*                     mXPCContext;
     1:     JSContext*                      mJSContext;
     1:     JSBool                          mContextPopRequired;
     1:     JSBool                          mDestroyJSContextInDestructor;
     1: 
     1:     XPCContext::LangType            mCallerLanguage;
     1: 
     1:     // ctor does not necessarily init the following. BEWARE!
     1: 
     1:     XPCContext::LangType            mPrevCallerLanguage;
     1: 
     1:     XPCCallContext*                 mPrevCallContext;
     1: 
 62405:     JSObject*                       mScopeForNewJSObjects;
     1:     JSObject*                       mFlattenedJSObject;
     1:     XPCWrappedNative*               mWrapper;
     1:     XPCWrappedNativeTearOff*        mTearOff;
     1: 
     1:     XPCNativeScriptableInfo*        mScriptableInfo;
     1: 
     1:     XPCNativeSet*                   mSet;
     1:     XPCNativeInterface*             mInterface;
     1:     XPCNativeMember*                mMember;
     1: 
 48470:     jsid                            mName;
     1:     JSBool                          mStaticMemberIsLocal;
     1: 
 91237:     unsigned                           mArgc;
     1:     jsval*                          mArgv;
     1:     jsval*                          mRetVal;
     1: 
     1:     PRUint16                        mMethodIndex;
     1: 
  9332: #define XPCCCX_STRING_CACHE_SIZE 2
  9332: 
  9332:     // String wrapper entry, holds a string, and a boolean that tells
  9332:     // whether the string is in use or not.
 64225:     //
 64225:     // NB: The string is not stored by value so that we avoid the cost of
 64225:     // construction/destruction.
  9332:     struct StringWrapperEntry
  9332:     {
 80486:         StringWrapperEntry() : mInUse(false) { }
 64225: 
 64225:         js::AlignedStorage2<XPCReadableJSStringWrapper> mString;
 79445:         bool mInUse;
     1:     };
     1: 
 64225:     StringWrapperEntry mScratchStrings[XPCCCX_STRING_CACHE_SIZE];
  9332: };
     1: 
 31395: class XPCLazyCallContext
 31395: {
 31395: public:
 31395:     XPCLazyCallContext(XPCCallContext& ccx)
 31395:         : mCallBeginRequest(DONT_CALL_BEGINREQUEST),
 31395:           mCcx(&ccx),
 31395:           mCcxToDestroy(nsnull)
 32041: #ifdef DEBUG
 32041:           , mCx(nsnull)
 32041:           , mCallerLanguage(JS_CALLER)
 32041:           , mObj(nsnull)
 62405:           , mFlattenedJSObject(nsnull)
 32041:           , mWrapper(nsnull)
 32041:           , mTearOff(nsnull)
 32041: #endif
 31395:     {
 31395:     }
 31395:     XPCLazyCallContext(XPCContext::LangType callerLanguage, JSContext* cx,
 31395:                        JSObject* obj = nsnull,
 62405:                        JSObject* flattenedJSObject = nsnull,
 31395:                        XPCWrappedNative* wrapper = nsnull,
 31395:                        XPCWrappedNativeTearOff* tearoff = nsnull)
 31395:         : mCallBeginRequest(callerLanguage == NATIVE_CALLER ?
 31395:                             CALL_BEGINREQUEST : DONT_CALL_BEGINREQUEST),
 31395:           mCcx(nsnull),
 31395:           mCcxToDestroy(nsnull),
 31395:           mCx(cx),
 31395:           mCallerLanguage(callerLanguage),
 31395:           mObj(obj),
 62405:           mFlattenedJSObject(flattenedJSObject),
 31395:           mWrapper(wrapper),
 31395:           mTearOff(tearoff)
 31395:     {
 31395:         NS_ASSERTION(cx, "Need a JS context!");
 31395:         NS_ASSERTION(callerLanguage == NATIVE_CALLER ||
 31395:                      callerLanguage == JS_CALLER,
 31395:                      "Can't deal with unknown caller language!");
 31395: #ifdef DEBUG
 31395:         AssertContextIsTopOfStack(cx);
 31395: #endif
 31395:     }
 31395:     ~XPCLazyCallContext()
 31395:     {
 31395:         if (mCcxToDestroy)
 31395:             mCcxToDestroy->~XPCCallContext();
 31395:         else if (mCallBeginRequest == CALLED_BEGINREQUEST)
 31395:             JS_EndRequest(mCx);
 31395:     }
 33786:     void SetWrapper(XPCWrappedNative* wrapper,
 33786:                     XPCWrappedNativeTearOff* tearoff);
 62405:     void SetWrapper(JSObject* flattenedJSObject);
 31395: 
 31395:     JSContext *GetJSContext()
 31395:     {
 31395:         if (mCcx)
 31395:             return mCcx->GetJSContext();
 31395: 
 31395:         if (mCallBeginRequest == CALL_BEGINREQUEST) {
 31395:             JS_BeginRequest(mCx);
 31395:             mCallBeginRequest = CALLED_BEGINREQUEST;
 31395:         }
 31395: 
 31395:         return mCx;
 31395:     }
 62405:     JSObject *GetScopeForNewJSObjects() const
 31395:     {
 32041:         if (mCcx)
 62405:             return mCcx->GetScopeForNewJSObjects();
 62405: 
 97588:         return xpc_UnmarkGrayObject(mObj);
 62405:     }
 62405:     void SetScopeForNewJSObjects(JSObject *obj)
 62405:     {
 62405:         if (mCcx) {
 62405:             mCcx->SetScopeForNewJSObjects(obj);
 62405:             return;
 62405:         }
 62405:         NS_ABORT_IF_FALSE(!mObj, "already set!");
 62405:         mObj = obj;
 62405:     }
 62405:     JSObject *GetFlattenedJSObject() const
 62405:     {
 62405:         if (mCcx)
 62405:             return mCcx->GetFlattenedJSObject();
 62405: 
 97588:         return xpc_UnmarkGrayObject(mFlattenedJSObject);
 31395:     }
 31395:     XPCCallContext &GetXPCCallContext()
 31395:     {
 80389:         if (!mCcx) {
 96915:             XPCCallContext *data = mData.addr();
 31395:             mCcxToDestroy = mCcx =
 96915:                 new (data) XPCCallContext(mCallerLanguage, mCx,
 31395:                                           mCallBeginRequest == CALL_BEGINREQUEST,
 97588:                                            xpc_UnmarkGrayObject(mObj),
 97588:                                            xpc_UnmarkGrayObject(mFlattenedJSObject),
 97588:                                            mWrapper,
 31395:                                           mTearOff);
 80389:             if (!mCcx->IsValid()) {
 31395:                 NS_ERROR("This is not supposed to fail!");
 31395:             }
 31395:         }
 31395: 
 31395:         return *mCcx;
 31395:     }
 31395: 
 31395: private:
 31395: #ifdef DEBUG
 31395:     static void AssertContextIsTopOfStack(JSContext* cx);
 31395: #endif
 31395: 
 31395:     enum {
 31395:         DONT_CALL_BEGINREQUEST,
 31395:         CALL_BEGINREQUEST,
 31395:         CALLED_BEGINREQUEST
 31395:     } mCallBeginRequest;
 31395: 
 31395:     XPCCallContext *mCcx;
 31395:     XPCCallContext *mCcxToDestroy;
 31395:     JSContext *mCx;
 31395:     XPCContext::LangType mCallerLanguage;
 31395:     JSObject *mObj;
 62405:     JSObject *mFlattenedJSObject;
 31395:     XPCWrappedNative *mWrapper;
 31395:     XPCWrappedNativeTearOff *mTearOff;
 96915:     mozilla::AlignedStorage2<XPCCallContext> mData;
 31395: };
 31395: 
     1: /***************************************************************************
     1: ****************************************************************************
     1: *
     1: * Core classes for wrapped native objects for use from JavaScript...
     1: *
     1: ****************************************************************************
     1: ***************************************************************************/
     1: 
     1: // These are the various JSClasses and callbacks whose use that required
     1: // visibility from more than one .cpp file.
     1: 
 90308: struct XPCWrappedNativeJSClass;
 90308: extern XPCWrappedNativeJSClass XPC_WN_NoHelper_JSClass;
 48622: extern js::Class XPC_WN_NoMods_WithCall_Proto_JSClass;
 48622: extern js::Class XPC_WN_NoMods_NoCall_Proto_JSClass;
 48622: extern js::Class XPC_WN_ModsAllowed_WithCall_Proto_JSClass;
 48622: extern js::Class XPC_WN_ModsAllowed_NoCall_Proto_JSClass;
 48622: extern js::Class XPC_WN_Tearoff_JSClass;
 48622: extern js::Class XPC_WN_NoHelper_Proto_JSClass;
     1: 
 30001: extern JSBool
 98960: XPC_WN_Equality(JSContext *cx, JSHandleObject obj, const jsval *v, JSBool *bp);
     1: 
 18907: extern JSBool
 91237: XPC_WN_CallMethod(JSContext *cx, unsigned argc, jsval *vp);
     1: 
 18907: extern JSBool
 91237: XPC_WN_GetterSetter(JSContext *cx, unsigned argc, jsval *vp);
     1: 
     1: extern JSBool
 98960: XPC_WN_JSOp_Enumerate(JSContext *cx, JSHandleObject obj, JSIterateOp enum_op,
 48622:                       jsval *statep, jsid *idp);
 48622: 
 48622: extern JSType
 98960: XPC_WN_JSOp_TypeOf_Object(JSContext *cx, JSHandleObject obj);
 48622: 
 48622: extern JSType
 98960: XPC_WN_JSOp_TypeOf_Function(JSContext *cx, JSHandleObject obj);
 48622: 
 48622: extern void
 98960: XPC_WN_JSOp_Clear(JSContext *cx, JSHandleObject obj);
 48622: 
 48622: extern JSObject*
 98960: XPC_WN_JSOp_ThisObject(JSContext *cx, JSHandleObject obj);
 48622: 
 48622: // Macros to initialize Object or Function like XPC_WN classes
 48622: #define XPC_WN_WithCall_ObjectOps                                             \
 48622:     {                                                                         \
 78672:         nsnull, /* lookupGeneric */                                           \
 48622:         nsnull, /* lookupProperty */                                          \
 77980:         nsnull, /* lookupElement */                                           \
 78672:         nsnull, /* lookupSpecial */                                           \
 78672:         nsnull, /* defineGeneric */                                           \
 48622:         nsnull, /* defineProperty */                                          \
 77980:         nsnull, /* defineElement */                                           \
 78672:         nsnull, /* defineSpecial */                                           \
 78672:         nsnull, /* getGeneric    */                                           \
 48622:         nsnull, /* getProperty    */                                          \
 77980:         nsnull, /* getElement    */                                           \
 81417:         nsnull, /* getElementIfPresent */                                     \
 78672:         nsnull, /* getSpecial    */                                           \
 78672:         nsnull, /* setGeneric    */                                           \
 48622:         nsnull, /* setProperty    */                                          \
 77980:         nsnull, /* setElement    */                                           \
 78672:         nsnull, /* setSpecial    */                                           \
 78672:         nsnull, /* getGenericAttributes  */                                   \
 48622:         nsnull, /* getAttributes  */                                          \
 77980:         nsnull, /* getElementAttributes  */                                   \
 78672:         nsnull, /* getSpecialAttributes  */                                   \
 78672:         nsnull, /* setGenericAttributes  */                                   \
 48622:         nsnull, /* setAttributes  */                                          \
 77980:         nsnull, /* setElementAttributes  */                                   \
 78672:         nsnull, /* setSpecialAttributes  */                                   \
 48622:         nsnull, /* deleteProperty */                                          \
 77980:         nsnull, /* deleteElement */                                           \
 78672:         nsnull, /* deleteSpecial */                                           \
 78614:         XPC_WN_JSOp_Enumerate,                                                \
 48622:         XPC_WN_JSOp_TypeOf_Function,                                          \
 48622:         XPC_WN_JSOp_ThisObject,                                               \
 48622:         XPC_WN_JSOp_Clear                                                     \
 48622:     }
 48622: 
 48622: #define XPC_WN_NoCall_ObjectOps                                               \
 48622:     {                                                                         \
 78672:         nsnull, /* lookupGeneric */                                           \
 48622:         nsnull, /* lookupProperty */                                          \
 77980:         nsnull, /* lookupElement */                                           \
 78672:         nsnull, /* lookupSpecial */                                           \
 78672:         nsnull, /* defineGeneric */                                           \
 48622:         nsnull, /* defineProperty */                                          \
 77980:         nsnull, /* defineElement */                                           \
 78672:         nsnull, /* defineSpecial */                                           \
 78672:         nsnull, /* getGeneric    */                                           \
 48622:         nsnull, /* getProperty    */                                          \
 77980:         nsnull, /* getElement    */                                           \
 81417:         nsnull, /* getElementIfPresent */                                     \
 78672:         nsnull, /* getSpecial    */                                           \
 78672:         nsnull, /* setGeneric    */                                           \
 48622:         nsnull, /* setProperty    */                                          \
 77980:         nsnull, /* setElement    */                                           \
 78672:         nsnull, /* setSpecial    */                                           \
 78672:         nsnull, /* getGenericAttributes  */                                   \
 48622:         nsnull, /* getAttributes  */                                          \
 77980:         nsnull, /* getElementAttributes  */                                   \
 78672:         nsnull, /* getSpecialAttributes  */                                   \
 78672:         nsnull, /* setGenericAttributes  */                                   \
 48622:         nsnull, /* setAttributes  */                                          \
 77980:         nsnull, /* setElementAttributes  */                                   \
 78672:         nsnull, /* setSpecialAttributes  */                                   \
 48622:         nsnull, /* deleteProperty */                                          \
 77980:         nsnull, /* deleteElement */                                           \
 78672:         nsnull, /* deleteSpecial */                                           \
 78614:         XPC_WN_JSOp_Enumerate,                                                \
 48622:         XPC_WN_JSOp_TypeOf_Object,                                            \
 48622:         XPC_WN_JSOp_ThisObject,                                               \
 48622:         XPC_WN_JSOp_Clear                                                     \
 48622:     }
     1: 
  9030: // Maybe this macro should check for class->enumerate ==
  9030: // XPC_WN_Shared_Proto_Enumerate or something rather than checking for
  9030: // 4 classes?
 86105: static inline bool IS_PROTO_CLASS(js::Class *clazz)
 86105: {
 86105:     return clazz == &XPC_WN_NoMods_WithCall_Proto_JSClass ||
 86105:            clazz == &XPC_WN_NoMods_NoCall_Proto_JSClass ||
 86105:            clazz == &XPC_WN_ModsAllowed_WithCall_Proto_JSClass ||
 86105:            clazz == &XPC_WN_ModsAllowed_NoCall_Proto_JSClass;
 86105: }
     1: 
     1: /***************************************************************************/
     1: 
 39404: namespace XPCWrapper {
 39404: 
 39404: enum WrapperType {
 39404:     UNKNOWN         = 0,
 39404:     NONE            = 0,
 39404:     XPCNW_IMPLICIT  = 1 << 0,
 39404:     XPCNW_EXPLICIT  = 1 << 1,
 39404:     XPCNW           = (XPCNW_IMPLICIT | XPCNW_EXPLICIT),
 39404:     SJOW            = 1 << 2,
 39404:     // SJOW must be the last wrapper type that can be returned to chrome.
 39404: 
 39404:     XOW             = 1 << 3,
 39404:     COW             = 1 << 4,
 39404:     SOW             = 1 << 5
 39404: };
 39404: 
 39404: }
 39404: 
     1: /***************************************************************************/
     1: // XPCWrappedNativeScope is one-to-one with a JS global object.
     1: 
 10291: class XPCWrappedNativeScope : public PRCList
     1: {
     1: public:
     1: 
     1:     static XPCWrappedNativeScope*
 91584:     GetNewOrUsed(XPCCallContext& ccx, JSObject* aGlobal, nsISupports* aNative = nsnull);
     1: 
     1:     XPCJSRuntime*
     1:     GetRuntime() const {return mRuntime;}
     1: 
     1:     Native2WrappedNativeMap*
     1:     GetWrappedNativeMap() const {return mWrappedNativeMap;}
     1: 
     1:     ClassInfo2WrappedNativeProtoMap*
 29424:     GetWrappedNativeProtoMap(JSBool aMainThreadOnly) const
 29424:         {return aMainThreadOnly ?
 29424:                 mMainThreadWrappedNativeProtoMap :
 29424:                 mWrappedNativeProtoMap;}
     1: 
     1:     nsXPCComponents*
     1:     GetComponents() const {return mComponents;}
     1: 
     1:     JSObject*
 97588:     GetGlobalJSObject() const
 97588:         {return xpc_UnmarkGrayObject(mGlobalJSObject);}
     1: 
     1:     JSObject*
 97588:     GetGlobalJSObjectPreserveColor() const {return mGlobalJSObject;}
 97588: 
 97588:     JSObject*
 97588:     GetPrototypeJSObject() const
 97588:         {return xpc_UnmarkGrayObject(mPrototypeJSObject);}
 97588: 
 97588:     JSObject*
 97588:     GetPrototypeJSObjectPreserveColor() const {return mPrototypeJSObject;}
     1: 
 10478:     // Getter for the prototype that we use for wrappers that have no
 10478:     // helper.
 10478:     JSObject*
 10478:     GetPrototypeNoHelper(XPCCallContext& ccx);
 10478: 
     1:     nsIPrincipal*
     1:     GetPrincipal() const
     1:     {return mScriptObjectPrincipal ?
     1:          mScriptObjectPrincipal->GetPrincipal() : nsnull;}
     1: 
     1:     void RemoveWrappedNativeProtos();
     1: 
     1:     static XPCWrappedNativeScope*
 25050:     FindInJSObjectScope(JSContext* cx, JSObject* obj,
 82794:                         JSBool OKIfNotInitialized = false,
 25050:                         XPCJSRuntime* runtime = nsnull);
 25050: 
 25050:     static XPCWrappedNativeScope*
     1:     FindInJSObjectScope(XPCCallContext& ccx, JSObject* obj,
 82794:                         JSBool OKIfNotInitialized = false)
 25050:     {
 25050:         return FindInJSObjectScope(ccx, obj, OKIfNotInitialized,
 25050:                                    ccx.GetRuntime());
 25050:     }
     1: 
     1:     static void
 89826:     SystemIsBeingShutDown();
     1: 
     1:     static void
  1025:     TraceJS(JSTracer* trc, XPCJSRuntime* rt);
  1025: 
 97874:     void TraceSelf(JSTracer *trc) {
 97874:         JSObject *obj = GetGlobalJSObjectPreserveColor();
 97874:         MOZ_ASSERT(obj);
 97874:         JS_CALL_OBJECT_TRACER(trc, obj, "XPCWrappedNativeScope::mGlobalJSObject");
 97874: 
 97874:         JSObject *proto = GetPrototypeJSObjectPreserveColor();
 97874:         if (proto)
 97874:             JS_CALL_OBJECT_TRACER(trc, proto, "XPCWrappedNativeScope::mPrototypeJSObject");
 97874:     }
 97874: 
  1025:     static void
 91250:     SuspectAllWrappers(XPCJSRuntime* rt, nsCycleCollectionTraversalCallback &cb);
  2954: 
  2954:     static void
 94738:     StartFinalizationPhaseOfGC(JSFreeOp *fop, XPCJSRuntime* rt);
     1: 
     1:     static void
 94738:     FinishedFinalizationPhaseOfGC();
     1: 
     1:     static void
     1:     MarkAllWrappedNativesAndProtos();
     1: 
     1:     static nsresult
     1:     ClearAllWrappedNativeSecurityPolicies(XPCCallContext& ccx);
     1: 
     1: #ifdef DEBUG
     1:     static void
     1:     ASSERT_NoInterfaceSetsAreMarked();
     1: #endif
     1: 
     1:     static void
     1:     SweepAllWrappedNativeTearOffs();
     1: 
     1:     static void
     1:     DebugDumpAllScopes(PRInt16 depth);
     1: 
     1:     void
     1:     DebugDump(PRInt16 depth);
     1: 
 83471:     static size_t
 83471:     SizeOfAllScopesIncludingThis(nsMallocSizeOfFun mallocSizeOf);
 83471: 
 83471:     size_t
 83471:     SizeOfIncludingThis(nsMallocSizeOfFun mallocSizeOf);
 83471: 
     1:     JSBool
     1:     IsValid() const {return mRuntime != nsnull;}
     1: 
  4099:     static JSBool
  4099:     IsDyingScope(XPCWrappedNativeScope *scope);
  4099: 
     1:     void SetComponents(nsXPCComponents* aComponents);
 97169:     nsXPCComponents *GetComponents();
 91584:     void SetGlobal(XPCCallContext& ccx, JSObject* aGlobal, nsISupports* aNative);
     1: 
     1:     static void InitStatics() { gScopes = nsnull; gDyingScopes = nsnull; }
     1: 
 10291:     XPCContext *GetContext() { return mContext; }
 97739:     void ClearContext() { mContext = nsnull; }
 10291: 
 80079:     nsDataHashtable<nsDepCharHashKey, JSObject*>& GetCachedDOMPrototypes()
 80070:     {
 80070:         return mCachedDOMPrototypes;
 80070:     }
 80070: 
 91250:     static XPCWrappedNativeScope *GetNativeScope(JSObject *obj)
 80070:     {
 90200:         MOZ_ASSERT(js::GetObjectClass(obj)->flags & JSCLASS_XPCONNECT_GLOBAL);
 80070: 
 83252:         const js::Value &v = js::GetObjectSlot(obj, JSCLASS_GLOBAL_SLOT_COUNT);
 80072:         return v.isUndefined()
 80072:                ? nsnull
 80072:                : static_cast<XPCWrappedNativeScope *>(v.toPrivate());
 80070:     }
 80070:     void TraceDOMPrototypes(JSTracer *trc);
 80070: 
 80085:     JSBool NewDOMBindingsEnabled()
 80085:     {
 80085:         return mNewDOMBindingsEnabled;
 80085:     }
 80085: 
 96736:     JSBool ExperimentalBindingsEnabled()
 94512:     {
 96736:         return mExperimentalBindingsEnabled;
 94512:     }
 94512: 
     1: protected:
 91584:     XPCWrappedNativeScope(XPCCallContext& ccx, JSObject* aGlobal, nsISupports* aNative);
     1:     virtual ~XPCWrappedNativeScope();
     1: 
     1:     static void KillDyingScopes();
     1: 
     1:     XPCWrappedNativeScope(); // not implemented
     1: 
     1: private:
     1:     static XPCWrappedNativeScope* gScopes;
     1:     static XPCWrappedNativeScope* gDyingScopes;
     1: 
     1:     XPCJSRuntime*                    mRuntime;
     1:     Native2WrappedNativeMap*         mWrappedNativeMap;
     1:     ClassInfo2WrappedNativeProtoMap* mWrappedNativeProtoMap;
 29424:     ClassInfo2WrappedNativeProtoMap* mMainThreadWrappedNativeProtoMap;
 97169:     nsRefPtr<nsXPCComponents>        mComponents;
     1:     XPCWrappedNativeScope*           mNext;
     1:     // The JS global object for this scope.  If non-null, this will be the
     1:     // default parent for the XPCWrappedNatives that have us as the scope,
     1:     // unless a PreCreate hook overrides it.  Note that this _may_ be null (see
     1:     // constructor).
 87981:     js::ObjectPtr                    mGlobalJSObject;
 10478: 
 10478:     // Cached value of Object.prototype
 87981:     js::ObjectPtr                    mPrototypeJSObject;
 10478:     // Prototype to use for wrappers with no helper.
 10478:     JSObject*                        mPrototypeNoHelper;
 10478: 
 10291:     XPCContext*                      mContext;
     1: 
     1:     // The script object principal instance corresponding to our current global
     1:     // JS object.
     1:     // XXXbz what happens if someone calls JS_SetPrivate on mGlobalJSObject.
     1:     // How do we deal?  Do we need to?  I suspect this isn't worth worrying
     1:     // about, since all of our scope objects are verified as not doing that.
 28592:     nsIScriptObjectPrincipal* mScriptObjectPrincipal;
 80070: 
 80079:     nsDataHashtable<nsDepCharHashKey, JSObject*> mCachedDOMPrototypes;
 80085: 
 80085:     JSBool mNewDOMBindingsEnabled;
 96736:     JSBool mExperimentalBindingsEnabled;
     1: };
     1: 
     1: /***************************************************************************/
     1: // XPCNativeMember represents a single idl declared method, attribute or
     1: // constant.
     1: 
     1: // Tight. No virtual methods. Can be bitwise copied (until any resolution done).
     1: 
     1: class XPCNativeMember
     1: {
     1: public:
     1:     static JSBool GetCallInfo(XPCCallContext& ccx,
     1:                               JSObject* funobj,
     1:                               XPCNativeInterface** pInterface,
     1:                               XPCNativeMember**    pMember);
     1: 
 48470:     jsid   GetName() const {return mName;}
     1: 
     1:     PRUint16 GetIndex() const {return mIndex;}
     1: 
 10471:     JSBool GetConstantValue(XPCCallContext& ccx, XPCNativeInterface* iface,
 10471:                             jsval* pval)
 10471:         {NS_ASSERTION(IsConstant(),
 10471:                       "Only call this if you're sure this is a constant!");
 53572:          return Resolve(ccx, iface, nsnull, pval);}
     1: 
 10471:     JSBool NewFunctionObject(XPCCallContext& ccx, XPCNativeInterface* iface,
 15179:                              JSObject *parent, jsval* pval);
 10471: 
     1:     JSBool IsMethod() const
     1:         {return 0 != (mFlags & METHOD);}
     1: 
     1:     JSBool IsConstant() const
     1:         {return 0 != (mFlags & CONSTANT);}
     1: 
     1:     JSBool IsAttribute() const
     1:         {return 0 != (mFlags & GETTER);}
     1: 
     1:     JSBool IsWritableAttribute() const
     1:         {return 0 != (mFlags & SETTER_TOO);}
     1: 
     1:     JSBool IsReadOnlyAttribute() const
     1:         {return IsAttribute() && !IsWritableAttribute();}
     1: 
     1: 
 48470:     void SetName(jsid a) {mName = a;}
     1: 
     1:     void SetMethod(PRUint16 index)
 53572:         {mFlags = METHOD; mIndex = index;}
     1: 
     1:     void SetConstant(PRUint16 index)
 53572:         {mFlags = CONSTANT; mIndex = index;}
     1: 
     1:     void SetReadOnlyAttribute(PRUint16 index)
 53572:         {mFlags = GETTER; mIndex = index;}
     1: 
     1:     void SetWritableAttribute()
     1:         {NS_ASSERTION(mFlags == GETTER,"bad"); mFlags = GETTER | SETTER_TOO;}
     1: 
     1:     /* default ctor - leave random contents */
     1:     XPCNativeMember()  {MOZ_COUNT_CTOR(XPCNativeMember);}
     1:     ~XPCNativeMember() {MOZ_COUNT_DTOR(XPCNativeMember);}
     1: 
     1: private:
 53572:     JSBool Resolve(XPCCallContext& ccx, XPCNativeInterface* iface,
 53572:                    JSObject *parent, jsval *vp);
     1: 
     1:     enum {
 53572:         METHOD      = 0x01,
 53572:         CONSTANT    = 0x02,
 53572:         GETTER      = 0x04,
 53572:         SETTER_TOO  = 0x08
     1:     };
     1: 
     1: private:
     1:     // our only data...
 48470:     jsid     mName;
     1:     PRUint16 mIndex;
     1:     PRUint16 mFlags;
     1: };
     1: 
     1: /***************************************************************************/
     1: // XPCNativeInterface represents a single idl declared interface. This is
     1: // primarily the set of XPCNativeMembers.
     1: 
     1: // Tight. No virtual methods.
     1: 
     1: class XPCNativeInterface
     1: {
     1:   public:
     1:     static XPCNativeInterface* GetNewOrUsed(XPCCallContext& ccx,
     1:                                             const nsIID* iid);
     1:     static XPCNativeInterface* GetNewOrUsed(XPCCallContext& ccx,
     1:                                             nsIInterfaceInfo* info);
     1:     static XPCNativeInterface* GetNewOrUsed(XPCCallContext& ccx,
     1:                                             const char* name);
     1:     static XPCNativeInterface* GetISupports(XPCCallContext& ccx);
     1: 
     1:     inline nsIInterfaceInfo* GetInterfaceInfo() const {return mInfo.get();}
 48470:     inline jsid              GetName()          const {return mName;}
     1: 
     1:     inline const nsIID* GetIID() const;
     1:     inline const char*  GetNameString() const;
 48470:     inline XPCNativeMember* FindMember(jsid name) const;
     1: 
     1:     inline JSBool HasAncestor(const nsIID* iid) const;
     1: 
 97872:     PRUint16 GetMemberCount() const {
 97872:         return mMemberCount;
 97872:     }
 97872:     XPCNativeMember* GetMemberAt(PRUint16 i) {
 97872:         NS_ASSERTION(i < mMemberCount, "bad index");
 97872:         return &mMembers[i];
 97872:     }
     1: 
     1:     void DebugDump(PRInt16 depth);
     1: 
     1: #define XPC_NATIVE_IFACE_MARK_FLAG ((PRUint16)JS_BIT(15)) // only high bit of 16 is set
     1: 
 97872:     void Mark() {
 97872:         mMarked = 1;
 97872:     }
 97872: 
 97872:     void Unmark() {
 97872:         mMarked = 0;
 97872:     }
 97872: 
 97872:     bool IsMarked() const {
 97872:         return mMarked != 0;
 97872:     }
     1: 
     1:     // NOP. This is just here to make the AutoMarkingPtr code compile.
  1025:     inline void TraceJS(JSTracer* trc) {}
  1025:     inline void AutoTrace(JSTracer* trc) {}
     1: 
 31395:     static void DestroyInstance(XPCNativeInterface* inst);
     1: 
 83471:     size_t SizeOfIncludingThis(nsMallocSizeOfFun mallocSizeOf);
 83471: 
     1:   protected:
     1:     static XPCNativeInterface* NewInstance(XPCCallContext& ccx,
     1:                                            nsIInterfaceInfo* aInfo);
     1: 
     1:     XPCNativeInterface();   // not implemented
 48470:     XPCNativeInterface(nsIInterfaceInfo* aInfo, jsid aName)
 97872:       : mInfo(aInfo), mName(aName), mMemberCount(0), mMarked(0)
 97872:     {
 97872:         MOZ_COUNT_CTOR(XPCNativeInterface);
 97872:     }
 97872:     ~XPCNativeInterface() {
 97872:         MOZ_COUNT_DTOR(XPCNativeInterface);
 97872:     }
     1: 
     1:     void* operator new(size_t, void* p) CPP_THROW_NEW {return p;}
     1: 
     1:     XPCNativeInterface(const XPCNativeInterface& r); // not implemented
     1:     XPCNativeInterface& operator= (const XPCNativeInterface& r); // not implemented
     1: 
     1: private:
     1:     nsCOMPtr<nsIInterfaceInfo> mInfo;
 48470:     jsid                       mName;
 97872:     PRUint16                   mMemberCount : 15;
 97872:     PRUint16                   mMarked : 1;
     1:     XPCNativeMember            mMembers[1]; // always last - object sized for array
     1: };
     1: 
     1: /***************************************************************************/
     1: // XPCNativeSetKey is used to key a XPCNativeSet in a NativeSetMap.
     1: 
     1: class XPCNativeSetKey
     1: {
     1: public:
     1:     XPCNativeSetKey(XPCNativeSet*       BaseSet  = nsnull,
     1:                     XPCNativeInterface* Addition = nsnull,
     1:                     PRUint16            Position = 0)
     1:         : mIsAKey(IS_A_KEY), mPosition(Position), mBaseSet(BaseSet),
     1:           mAddition(Addition) {}
     1:     ~XPCNativeSetKey() {}
     1: 
     1:     XPCNativeSet*           GetBaseSet()  const {return mBaseSet;}
     1:     XPCNativeInterface*     GetAddition() const {return mAddition;}
     1:     PRUint16                GetPosition() const {return mPosition;}
     1: 
     1:     // This is a fun little hack...
     1:     // We build these keys only on the stack. We use them for lookup in
     1:     // NativeSetMap. Becasue we don't want to pay the cost of cloning a key and
     1:     // sticking it into the hashtable, when the XPCNativeSet actually
     1:     // gets added to the table the 'key' in the table is a pointer to the
     1:     // set itself and not this key. Our key compare function expects to get
     1:     // a key and a set. When we do external lookups in the map we pass in one
     1:     // of these keys and our compare function gets passed a key and a set.
     1:     // (see compare_NativeKeyToSet in xpcmaps.cpp). This is all well and good.
     1:     // Except, when the table decides to resize itself. Then it tries to use
     1:     // our compare function with the 'keys' that are in the hashtable (which are
     1:     // really XPCNativeSet objects and not XPCNativeSetKey objects!
     1:     //
     1:     // So, the hack is to have the compare function assume it is getting a
     1:     // XPCNativeSetKey pointer and call this IsAKey method. If that fails then
     1:     // it realises that it really has a XPCNativeSet pointer and deals with that
     1:     // fact. This is safe because we know that both of these classes have no
     1:     // virtual methods and their first data member is a PRUint16. We are
     1:     // confident that XPCNativeSet->mMemberCount will never be 0xffff.
     1: 
     1:     JSBool                  IsAKey() const {return mIsAKey == IS_A_KEY;}
     1: 
     1:     enum {IS_A_KEY = 0xffff};
     1: 
     1:     // Allow shallow copy
     1: 
     1: private:
     1:     PRUint16                mIsAKey;    // must be first data member
     1:     PRUint16                mPosition;
     1:     XPCNativeSet*           mBaseSet;
     1:     XPCNativeInterface*     mAddition;
     1: };
     1: 
     1: /***************************************************************************/
     1: // XPCNativeSet represents an ordered collection of XPCNativeInterface pointers.
     1: 
     1: class XPCNativeSet
     1: {
     1:   public:
     1:     static XPCNativeSet* GetNewOrUsed(XPCCallContext& ccx, const nsIID* iid);
     1:     static XPCNativeSet* GetNewOrUsed(XPCCallContext& ccx,
     1:                                       nsIClassInfo* classInfo);
     1:     static XPCNativeSet* GetNewOrUsed(XPCCallContext& ccx,
     1:                                       XPCNativeSet* otherSet,
     1:                                       XPCNativeInterface* newInterface,
     1:                                       PRUint16 position);
     1: 
 93361:     // This generates a union set.
 93361:     //
 93361:     // If preserveFirstSetOrder is true, the elements from |firstSet| come first,
 93361:     // followed by any non-duplicate items from |secondSet|. If false, the same
 93361:     // algorithm is applied; but if we detect that |secondSet| is a superset of
 93361:     // |firstSet|, we return |secondSet| without worrying about whether the
 93361:     // ordering might differ from |firstSet|.
 93361:     static XPCNativeSet* GetNewOrUsed(XPCCallContext& ccx,
 93361:                                       XPCNativeSet* firstSet,
 93361:                                       XPCNativeSet* secondSet,
 93361:                                       bool preserveFirstSetOrder);
 93361: 
     1:     static void ClearCacheEntryForClassInfo(nsIClassInfo* classInfo);
     1: 
 48470:     inline JSBool FindMember(jsid name, XPCNativeMember** pMember,
     1:                              PRUint16* pInterfaceIndex) const;
     1: 
 48470:     inline JSBool FindMember(jsid name, XPCNativeMember** pMember,
     1:                              XPCNativeInterface** pInterface) const;
     1: 
 48470:     inline JSBool FindMember(jsid name,
     1:                              XPCNativeMember** pMember,
     1:                              XPCNativeInterface** pInterface,
     1:                              XPCNativeSet* protoSet,
     1:                              JSBool* pIsLocal) const;
     1: 
     1:     inline JSBool HasInterface(XPCNativeInterface* aInterface) const;
     1:     inline JSBool HasInterfaceWithAncestor(XPCNativeInterface* aInterface) const;
 30001:     inline JSBool HasInterfaceWithAncestor(const nsIID* iid) const;
     1: 
     1:     inline XPCNativeInterface* FindInterfaceWithIID(const nsIID& iid) const;
     1: 
 48470:     inline XPCNativeInterface* FindNamedInterface(jsid name) const;
     1: 
 97872:     PRUint16 GetMemberCount() const {
 97872:         return mMemberCount;
 97872:     }
 97872:     PRUint16 GetInterfaceCount() const {
 97872:         return mInterfaceCount;
 97872:     }
 97872:     XPCNativeInterface **GetInterfaceArray() {
 97872:         return mInterfaces;
 97872:     }
     1: 
     1:     XPCNativeInterface* GetInterfaceAt(PRUint16 i)
     1:         {NS_ASSERTION(i < mInterfaceCount, "bad index"); return mInterfaces[i];}
     1: 
     1:     inline JSBool MatchesSetUpToInterface(const XPCNativeSet* other,
     1:                                           XPCNativeInterface* iface) const;
     1: 
     1: #define XPC_NATIVE_SET_MARK_FLAG ((PRUint16)JS_BIT(15)) // only high bit of 16 is set
     1: 
     1:     inline void Mark();
     1: 
     1:     // NOP. This is just here to make the AutoMarkingPtr code compile.
  1025:     inline void TraceJS(JSTracer* trc) {}
  1025:     inline void AutoTrace(JSTracer* trc) {}
     1: 
     1:   private:
 97872:     void MarkSelfOnly() {
 97872:         mMarked = 1;
 97872:     }
 97872: 
     1:   public:
 97872:     void Unmark() {
 97872:         mMarked = 0;
 97872:     }
 97872:     bool IsMarked() const {
 97872:         return !!mMarked;
 97872:     }
     1: 
     1: #ifdef DEBUG
     1:     inline void ASSERT_NotMarked();
     1: #endif
     1: 
     1:     void DebugDump(PRInt16 depth);
     1: 
     1:     static void DestroyInstance(XPCNativeSet* inst);
     1: 
 83471:     size_t SizeOfIncludingThis(nsMallocSizeOfFun mallocSizeOf);
 83471: 
     1:   protected:
     1:     static XPCNativeSet* NewInstance(XPCCallContext& ccx,
     1:                                      XPCNativeInterface** array,
     1:                                      PRUint16 count);
     1:     static XPCNativeSet* NewInstanceMutate(XPCNativeSet*       otherSet,
     1:                                            XPCNativeInterface* newInterface,
     1:                                            PRUint16            position);
 97872:     XPCNativeSet()
 97872:       : mMemberCount(0), mInterfaceCount(0), mMarked(0)
 97872:     {
 97872:         MOZ_COUNT_CTOR(XPCNativeSet);
 97872:     }
 97872:     ~XPCNativeSet() {
 97872:         MOZ_COUNT_DTOR(XPCNativeSet);
 97872:     }
     1:     void* operator new(size_t, void* p) CPP_THROW_NEW {return p;}
     1: 
     1:   private:
     1:     PRUint16                mMemberCount;
 97872:     PRUint16                mInterfaceCount : 15;
 97872:     PRUint16                mMarked : 1;
     1:     XPCNativeInterface*     mInterfaces[1];  // always last - object sized for array
     1: };
     1: 
     1: /***************************************************************************/
     1: // XPCNativeScriptableFlags is a wrapper class that holds the flags returned
     1: // from calls to nsIXPCScriptable::GetScriptableFlags(). It has convenience
     1: // methods to check for particular bitflags. Since we also use this class as
     1: // a member of the gc'd class XPCNativeScriptableShared, this class holds the
     1: // bit and exposes the inlined methods to support marking.
     1: 
     1: #define XPC_WN_SJSFLAGS_MARK_FLAG JS_BIT(31) // only high bit of 32 is set
     1: 
     1: class XPCNativeScriptableFlags
     1: {
     1: private:
 84755:     uint32_t mFlags;
     1: 
     1: public:
     1: 
 84755:     XPCNativeScriptableFlags(uint32_t flags = 0) : mFlags(flags) {}
 84755: 
 84755:     uint32_t GetFlags() const {return mFlags & ~XPC_WN_SJSFLAGS_MARK_FLAG;}
 84755:     void     SetFlags(uint32_t flags) {mFlags = flags;}
 84755: 
 84755:     operator uint32_t() const {return GetFlags();}
     1: 
     1:     XPCNativeScriptableFlags(const XPCNativeScriptableFlags& r)
     1:         {mFlags = r.GetFlags();}
     1: 
     1:     XPCNativeScriptableFlags& operator= (const XPCNativeScriptableFlags& r)
     1:         {mFlags = r.GetFlags(); return *this;}
     1: 
     1:     void Mark()       {mFlags |= XPC_WN_SJSFLAGS_MARK_FLAG;}
     1:     void Unmark()     {mFlags &= ~XPC_WN_SJSFLAGS_MARK_FLAG;}
     1:     JSBool IsMarked() const {return 0 != (mFlags & XPC_WN_SJSFLAGS_MARK_FLAG);}
     1: 
     1: #ifdef GET_IT
     1: #undef GET_IT
     1: #endif
     1: #define GET_IT(f_) const {return 0 != (mFlags & nsIXPCScriptable:: f_ );}
     1: 
     1:     JSBool WantPreCreate()                GET_IT(WANT_PRECREATE)
     1:     JSBool WantCreate()                   GET_IT(WANT_CREATE)
     1:     JSBool WantPostCreate()               GET_IT(WANT_POSTCREATE)
     1:     JSBool WantAddProperty()              GET_IT(WANT_ADDPROPERTY)
     1:     JSBool WantDelProperty()              GET_IT(WANT_DELPROPERTY)
     1:     JSBool WantGetProperty()              GET_IT(WANT_GETPROPERTY)
     1:     JSBool WantSetProperty()              GET_IT(WANT_SETPROPERTY)
     1:     JSBool WantEnumerate()                GET_IT(WANT_ENUMERATE)
     1:     JSBool WantNewEnumerate()             GET_IT(WANT_NEWENUMERATE)
     1:     JSBool WantNewResolve()               GET_IT(WANT_NEWRESOLVE)
     1:     JSBool WantConvert()                  GET_IT(WANT_CONVERT)
     1:     JSBool WantFinalize()                 GET_IT(WANT_FINALIZE)
     1:     JSBool WantCheckAccess()              GET_IT(WANT_CHECKACCESS)
     1:     JSBool WantCall()                     GET_IT(WANT_CALL)
     1:     JSBool WantConstruct()                GET_IT(WANT_CONSTRUCT)
     1:     JSBool WantHasInstance()              GET_IT(WANT_HASINSTANCE)
     1:     JSBool WantEquality()                 GET_IT(WANT_EQUALITY)
     1:     JSBool WantOuterObject()              GET_IT(WANT_OUTER_OBJECT)
     1:     JSBool UseJSStubForAddProperty()      GET_IT(USE_JSSTUB_FOR_ADDPROPERTY)
     1:     JSBool UseJSStubForDelProperty()      GET_IT(USE_JSSTUB_FOR_DELPROPERTY)
     1:     JSBool UseJSStubForSetProperty()      GET_IT(USE_JSSTUB_FOR_SETPROPERTY)
     1:     JSBool DontEnumStaticProps()          GET_IT(DONT_ENUM_STATIC_PROPS)
     1:     JSBool DontEnumQueryInterface()       GET_IT(DONT_ENUM_QUERY_INTERFACE)
     1:     JSBool DontAskInstanceForScriptable() GET_IT(DONT_ASK_INSTANCE_FOR_SCRIPTABLE)
     1:     JSBool ClassInfoInterfacesOnly()      GET_IT(CLASSINFO_INTERFACES_ONLY)
     1:     JSBool AllowPropModsDuringResolve()   GET_IT(ALLOW_PROP_MODS_DURING_RESOLVE)
     1:     JSBool AllowPropModsToPrototype()     GET_IT(ALLOW_PROP_MODS_TO_PROTOTYPE)
 91575:     JSBool IsGlobalObject()               GET_IT(IS_GLOBAL_OBJECT)
     1:     JSBool DontReflectInterfaceNames()    GET_IT(DONT_REFLECT_INTERFACE_NAMES)
 77985:     JSBool UseStubEqualityHook()          GET_IT(USE_STUB_EQUALITY_HOOK)
     1: 
     1: #undef GET_IT
     1: };
     1: 
     1: /***************************************************************************/
     1: 
     1: // XPCNativeScriptableShared is used to hold the JSClass and the
     1: // associated scriptable flags for XPCWrappedNatives. These are shared across
     1: // the runtime and are garbage collected by xpconnect. We *used* to just store
     1: // this inside the XPCNativeScriptableInfo (usually owned by instances of
     1: // XPCWrappedNativeProto. This had two problems... It was wasteful, and it
     1: // was a big problem when wrappers are reparented to different scopes (and
     1: // thus different protos (the DOM does this).
     1: 
 90308: // We maintain the invariant that every JSClass for which ext.isWrappedNative
 90308: // is true is a contained in an instance of this struct, and can thus be cast
 90308: // to it.
 90308: struct XPCWrappedNativeJSClass
 40491: {
 48622:     js::Class base;
 40491:     PRUint32 interfacesBitmap;
 40491: };
 40491: 
     1: class XPCNativeScriptableShared
     1: {
     1: public:
     1:     const XPCNativeScriptableFlags& GetFlags() const {return mFlags;}
 40491:     PRUint32                        GetInterfacesBitmap() const
 40491:         {return mJSClass.interfacesBitmap;}
 48622:     JSClass*                        GetJSClass()
 78614:         {return Jsvalify(&mJSClass.base);}
 30001:     JSClass*                        GetSlimJSClass()
 33785:         {if (mCanBeSlim) return GetJSClass(); return nsnull;}
     1: 
 84755:     XPCNativeScriptableShared(uint32_t aFlags, char* aName,
 40491:                               PRUint32 interfacesBitmap)
 33785:         : mFlags(aFlags),
 82794:           mCanBeSlim(false)
     1:         {memset(&mJSClass, 0, sizeof(mJSClass));
     1:          mJSClass.base.name = aName;  // take ownership
 40491:          mJSClass.interfacesBitmap = interfacesBitmap;
     1:          MOZ_COUNT_CTOR(XPCNativeScriptableShared);}
     1: 
     1:     ~XPCNativeScriptableShared()
     1:         {if (mJSClass.base.name)nsMemory::Free((void*)mJSClass.base.name);
     1:          MOZ_COUNT_DTOR(XPCNativeScriptableShared);}
     1: 
     1:     char* TransferNameOwnership()
     1:         {char* name=(char*)mJSClass.base.name; mJSClass.base.name = nsnull;
     1:         return name;}
     1: 
 91578:     void PopulateJSClass();
     1: 
     1:     void Mark()       {mFlags.Mark();}
     1:     void Unmark()     {mFlags.Unmark();}
     1:     JSBool IsMarked() const {return mFlags.IsMarked();}
     1: 
     1: private:
     1:     XPCNativeScriptableFlags mFlags;
 90308:     XPCWrappedNativeJSClass  mJSClass;
 33785:     JSBool                   mCanBeSlim;
     1: };
     1: 
     1: /***************************************************************************/
     1: // XPCNativeScriptableInfo is used to hold the nsIXPCScriptable state for a
     1: // given class or instance.
     1: 
     1: class XPCNativeScriptableInfo
     1: {
     1: public:
     1:     static XPCNativeScriptableInfo*
 91578:     Construct(XPCCallContext& ccx, const XPCNativeScriptableCreateInfo* sci);
     1: 
     1:     nsIXPCScriptable*
     1:     GetCallback() const {return mCallback;}
     1: 
     1:     const XPCNativeScriptableFlags&
     1:     GetFlags() const      {return mShared->GetFlags();}
     1: 
 40491:     PRUint32
 40491:     GetInterfacesBitmap() const {return mShared->GetInterfacesBitmap();}
 40491: 
     1:     JSClass*
     1:     GetJSClass()          {return mShared->GetJSClass();}
     1: 
 30001:     JSClass*
 30001:     GetSlimJSClass()      {return mShared->GetSlimJSClass();}
 30001: 
     1:     XPCNativeScriptableShared*
     1:     GetScriptableShared() {return mShared;}
     1: 
     1:     void
     1:     SetCallback(nsIXPCScriptable* s) {mCallback = s;}
 29479:     void
 29479:     SetCallback(already_AddRefed<nsIXPCScriptable> s) {mCallback = s;}
     1: 
     1:     void
     1:     SetScriptableShared(XPCNativeScriptableShared* shared) {mShared = shared;}
     1: 
 98022:     void Mark() {
 98022:         if (mShared)
 98022:             mShared->Mark();
 98022:     }
 98022: 
 98022:     void TraceJS(JSTracer *trc) {}
 98022:     void AutoTrace(JSTracer *trc) {}
     1: 
     1: protected:
     1:     XPCNativeScriptableInfo(nsIXPCScriptable* scriptable = nsnull,
     1:                             XPCNativeScriptableShared* shared = nsnull)
     1:         : mCallback(scriptable), mShared(shared)
     1:                                {MOZ_COUNT_CTOR(XPCNativeScriptableInfo);}
     1: public:
     1:     ~XPCNativeScriptableInfo() {MOZ_COUNT_DTOR(XPCNativeScriptableInfo);}
     1: private:
     1: 
     1:     // disable copy ctor and assignment
     1:     XPCNativeScriptableInfo(const XPCNativeScriptableInfo& r); // not implemented
     1:     XPCNativeScriptableInfo& operator= (const XPCNativeScriptableInfo& r); // not implemented
     1: 
     1: private:
     1:     nsCOMPtr<nsIXPCScriptable>  mCallback;
     1:     XPCNativeScriptableShared*  mShared;
     1: };
     1: 
     1: /***************************************************************************/
     1: // XPCNativeScriptableCreateInfo is used in creating new wrapper and protos.
     1: // it abstracts out the scriptable interface pointer and the flags. After
     1: // creation these are factored differently using XPCNativeScriptableInfo.
     1: 
 40489: class NS_STACK_CLASS XPCNativeScriptableCreateInfo
     1: {
     1: public:
     1: 
     1:     XPCNativeScriptableCreateInfo(const XPCNativeScriptableInfo& si)
 40491:         : mCallback(si.GetCallback()), mFlags(si.GetFlags()),
 40491:           mInterfacesBitmap(si.GetInterfacesBitmap()) {}
     1: 
 40489:     XPCNativeScriptableCreateInfo(already_AddRefed<nsIXPCScriptable> callback,
 40491:                                   XPCNativeScriptableFlags flags,
 40491:                                   PRUint32 interfacesBitmap)
 40491:         : mCallback(callback), mFlags(flags),
 40491:           mInterfacesBitmap(interfacesBitmap) {}
     1: 
 40489:     XPCNativeScriptableCreateInfo()
 40491:         : mFlags(0), mInterfacesBitmap(0) {}
 40489: 
 40489: 
     1:     nsIXPCScriptable*
     1:     GetCallback() const {return mCallback;}
     1: 
     1:     const XPCNativeScriptableFlags&
     1:     GetFlags() const      {return mFlags;}
     1: 
 40491:     PRUint32
 40491:     GetInterfacesBitmap() const     {return mInterfacesBitmap;}
 40491: 
     1:     void
 29479:     SetCallback(already_AddRefed<nsIXPCScriptable> callback)
 29479:         {mCallback = callback;}
     1: 
     1:     void
     1:     SetFlags(const XPCNativeScriptableFlags& flags)  {mFlags = flags;}
     1: 
 40491:     void
 40491:     SetInterfacesBitmap(PRUint32 interfacesBitmap)
 40491:         {mInterfacesBitmap = interfacesBitmap;}
 40491: 
     1: private:
     1:     nsCOMPtr<nsIXPCScriptable>  mCallback;
     1:     XPCNativeScriptableFlags    mFlags;
 40491:     PRUint32                    mInterfacesBitmap;
     1: };
     1: 
     1: /***********************************************/
 86632: // XPCWrappedNativeProto hold the additional shared wrapper data
     1: // for XPCWrappedNative whose native objects expose nsIClassInfo.
     1: 
 21218: #define UNKNOWN_OFFSETS ((QITableEntry*)1)
 21218: 
     1: class XPCWrappedNativeProto
     1: {
     1: public:
     1:     static XPCWrappedNativeProto*
     1:     GetNewOrUsed(XPCCallContext& ccx,
 86632:                  XPCWrappedNativeScope* scope,
 86632:                  nsIClassInfo* classInfo,
 86632:                  const XPCNativeScriptableCreateInfo* scriptableCreateInfo,
 91586:                  QITableEntry* offsets = UNKNOWN_OFFSETS,
 91586:                  bool callPostCreatePrototype = true);
     1: 
     1:     XPCWrappedNativeScope*
     1:     GetScope()   const {return mScope;}
     1: 
     1:     XPCJSRuntime*
     1:     GetRuntime() const {return mScope->GetRuntime();}
     1: 
     1:     JSObject*
 97588:     GetJSProtoObject() const {return xpc_UnmarkGrayObject(mJSProtoObject);}
     1: 
     1:     nsIClassInfo*
     1:     GetClassInfo()     const {return mClassInfo;}
     1: 
     1:     XPCNativeSet*
     1:     GetSet()           const {return mSet;}
     1: 
     1:     XPCNativeScriptableInfo*
     1:     GetScriptableInfo()   {return mScriptableInfo;}
     1: 
     1:     void**
     1:     GetSecurityInfoAddr() {return &mSecurityInfo;}
     1: 
 84755:     uint32_t
     1:     GetClassInfoFlags() const {return mClassInfoFlags;}
     1: 
 21218:     QITableEntry*
 21218:     GetOffsets()
 21218:     {
 21218:         return InitedOffsets() ? mOffsets : nsnull;
 21218:     }
 21218:     QITableEntry*
 21218:     GetOffsetsMasked()
 21218:     {
 21218:         return mOffsets;
 21218:     }
 21218:     void
 21218:     CacheOffsets(nsISupports* identity)
 21218:     {
 21218:         static NS_DEFINE_IID(kThisPtrOffsetsSID, NS_THISPTROFFSETS_SID);
 21218: 
 21218: #ifdef DEBUG
 80389:         if (InitedOffsets() && mOffsets) {
 21218:             QITableEntry* offsets;
 21218:             identity->QueryInterface(kThisPtrOffsetsSID, (void**)&offsets);
 21218:             NS_ASSERTION(offsets == mOffsets,
 21218:                          "We can't deal with objects that have the same "
 21218:                          "classinfo but different offset tables.");
 21218:         }
 21218: #endif
 21218: 
 80389:         if (!InitedOffsets()) {
 80389:             if (mClassInfoFlags & nsIClassInfo::CONTENT_NODE) {
 21218:                 identity->QueryInterface(kThisPtrOffsetsSID, (void**)&mOffsets);
 80390:             } else {
 21218:                 mOffsets = nsnull;
 21218:             }
 21218:         }
 21218:     }
 21218: 
     1: #ifdef GET_IT
     1: #undef GET_IT
     1: #endif
 18991: #define GET_IT(f_) const {return !!(mClassInfoFlags & nsIClassInfo:: f_ );}
     1: 
     1:     JSBool ClassIsSingleton()           GET_IT(SINGLETON)
     1:     JSBool ClassIsThreadSafe()          GET_IT(THREADSAFE)
     1:     JSBool ClassIsMainThreadOnly()      GET_IT(MAIN_THREAD_ONLY)
     1:     JSBool ClassIsDOMObject()           GET_IT(DOM_OBJECT)
     1:     JSBool ClassIsPluginObject()        GET_IT(PLUGIN_OBJECT)
     1: 
     1: #undef GET_IT
     1: 
     1:     XPCLock* GetLock() const
     1:         {return ClassIsThreadSafe() ? GetRuntime()->GetMapLock() : nsnull;}
     1: 
     1:     void SetScriptableInfo(XPCNativeScriptableInfo* si)
     1:         {NS_ASSERTION(!mScriptableInfo, "leak here!"); mScriptableInfo = si;}
     1: 
 91585:     bool CallPostCreatePrototype(XPCCallContext& ccx);
 94738:     void JSProtoObjectFinalized(js::FreeOp *fop, JSObject *obj);
     1: 
 89826:     void SystemIsBeingShutDown();
     1: 
     1:     void DebugDump(PRInt16 depth);
     1: 
 97874:     void TraceSelf(JSTracer *trc) {
 97874:         if (mJSProtoObject)
 97874:             JS_CALL_OBJECT_TRACER(trc, mJSProtoObject, "XPCWrappedNativeProto::mJSProtoObject");
  1025:     }
 97874: 
 97874:     void TraceInside(JSTracer *trc) {
 97872:         if (JS_IsGCMarkingTracer(trc)) {
 97872:             mSet->Mark();
 97872:             if (mScriptableInfo)
  1025:                 mScriptableInfo->Mark();
  1025:         }
 97872:     }
  1025: 
 97874:     void TraceJS(JSTracer *trc) {
 97874:         TraceSelf(trc);
 97874:         TraceInside(trc);
 97874:     }
 97874: 
 87981:     void WriteBarrierPre(JSRuntime* rt)
 87981:     {
 87981:         if (js::IsIncrementalBarrierNeeded(rt) && mJSProtoObject)
 87981:             mJSProtoObject.writeBarrierPre(rt);
 87981:     }
 87981: 
     1:     // NOP. This is just here to make the AutoMarkingPtr code compile.
  1025:     inline void AutoTrace(JSTracer* trc) {}
     1: 
     1:     // Yes, we *do* need to mark the mScriptableInfo in both cases.
     1:     void Mark() const
     1:         {mSet->Mark();
     1:          if (mScriptableInfo) mScriptableInfo->Mark();}
     1: 
     1: #ifdef DEBUG
     1:     void ASSERT_SetNotMarked() const {mSet->ASSERT_NotMarked();}
     1: #endif
     1: 
     1:     ~XPCWrappedNativeProto();
     1: 
     1: protected:
     1:     // disable copy ctor and assignment
     1:     XPCWrappedNativeProto(const XPCWrappedNativeProto& r); // not implemented
     1:     XPCWrappedNativeProto& operator= (const XPCWrappedNativeProto& r); // not implemented
     1: 
     1:     // hide ctor
     1:     XPCWrappedNativeProto(XPCWrappedNativeScope* Scope,
     1:                           nsIClassInfo* ClassInfo,
     1:                           PRUint32 ClassInfoFlags,
 21218:                           XPCNativeSet* Set,
 21218:                           QITableEntry* offsets);
     1: 
 91578:     JSBool Init(XPCCallContext& ccx,
 91586:                 const XPCNativeScriptableCreateInfo* scriptableCreateInfo,
 91586:                 bool callPostCreatePrototype);
     1: 
     1: private:
     1: #if defined(DEBUG_xpc_hacker) || defined(DEBUG)
     1:     static PRInt32 gDEBUG_LiveProtoCount;
     1: #endif
     1: 
     1: private:
 79445:     bool
 21218:     InitedOffsets()
 21218:     {
 21218:         return mOffsets != UNKNOWN_OFFSETS;
 21218:     }
 21218: 
     1:     XPCWrappedNativeScope*   mScope;
 87981:     js::ObjectPtr            mJSProtoObject;
     1:     nsCOMPtr<nsIClassInfo>   mClassInfo;
     1:     PRUint32                 mClassInfoFlags;
     1:     XPCNativeSet*            mSet;
     1:     void*                    mSecurityInfo;
     1:     XPCNativeScriptableInfo* mScriptableInfo;
 21218:     QITableEntry*            mOffsets;
     1: };
     1: 
 51515: class xpcObjectHelper;
 48124: extern JSBool ConstructSlimWrapper(XPCCallContext &ccx,
 51515:                                    xpcObjectHelper &aHelper,
 30001:                                    XPCWrappedNativeScope* xpcScope,
 30001:                                    jsval *rval);
 30001: extern JSBool MorphSlimWrapper(JSContext *cx, JSObject *obj);
 30001: 
     1: /***********************************************/
     1: // XPCWrappedNativeTearOff represents the info needed to make calls to one
     1: // interface on the underlying native object of a XPCWrappedNative.
     1: 
     1: class XPCWrappedNativeTearOff
     1: {
     1: public:
     1:     JSBool IsAvailable() const {return mInterface == nsnull;}
     1:     JSBool IsReserved()  const {return mInterface == (XPCNativeInterface*)1;}
     1:     JSBool IsValid()     const {return !IsAvailable() && !IsReserved();}
     1:     void   SetReserved()       {mInterface = (XPCNativeInterface*)1;}
     1: 
     1:     XPCNativeInterface* GetInterface() const {return mInterface;}
     1:     nsISupports*        GetNative()    const {return mNative;}
 89966:     JSObject*           GetJSObject();
 89966:     JSObject*           GetJSObjectPreserveColor() const;
     1:     void SetInterface(XPCNativeInterface*  Interface) {mInterface = Interface;}
     1:     void SetNative(nsISupports*  Native)              {mNative = Native;}
     1:     void SetJSObject(JSObject*  JSObj);
     1: 
     1:     void JSObjectFinalized() {SetJSObject(nsnull);}
     1: 
     1:     XPCWrappedNativeTearOff()
     1:         : mInterface(nsnull), mNative(nsnull), mJSObject(nsnull) {}
     1:     ~XPCWrappedNativeTearOff();
     1: 
     1:     // NOP. This is just here to make the AutoMarkingPtr code compile.
  1025:     inline void TraceJS(JSTracer* trc) {}
  1025:     inline void AutoTrace(JSTracer* trc) {}
     1: 
 86976:     void Mark()       {mJSObject = (JSObject*)(intptr_t(mJSObject) | 1);}
 86976:     void Unmark()     {mJSObject = (JSObject*)(intptr_t(mJSObject) & ~1);}
 86976:     bool IsMarked() const {return !!(intptr_t(mJSObject) & 1);}
     1: 
     1: private:
 86976:     XPCWrappedNativeTearOff(const XPCWrappedNativeTearOff& r) MOZ_DELETE;
 86976:     XPCWrappedNativeTearOff& operator= (const XPCWrappedNativeTearOff& r) MOZ_DELETE;
     1: 
     1: private:
     1:     XPCNativeInterface* mInterface;
     1:     nsISupports*        mNative;
     1:     JSObject*           mJSObject;
     1: };
     1: 
     1: /***********************************************/
     1: // XPCWrappedNativeTearOffChunk is a collections of XPCWrappedNativeTearOff
     1: // objects. It lets us allocate a set of XPCWrappedNativeTearOff objects and
     1: // link the sets - rather than only having the option of linking single
     1: // XPCWrappedNativeTearOff objects.
     1: //
     1: // The value of XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK can be tuned at buildtime
     1: // to balance between the code of allocations of additional chunks and the waste
     1: // of space for ununsed XPCWrappedNativeTearOff objects.
     1: 
     1: #define XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK 1
     1: 
     1: class XPCWrappedNativeTearOffChunk
     1: {
     1: friend class XPCWrappedNative;
     1: private:
     1:     XPCWrappedNativeTearOffChunk() : mNextChunk(nsnull) {}
     1:     ~XPCWrappedNativeTearOffChunk() {delete mNextChunk;}
     1: 
     1: private:
     1:     XPCWrappedNativeTearOff mTearOffs[XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK];
     1:     XPCWrappedNativeTearOffChunk* mNextChunk;
     1: };
     1: 
 30001: void *xpc_GetJSPrivate(JSObject *obj);
 30001: 
     1: /***************************************************************************/
     1: // XPCWrappedNative the wrapper around one instance of a native xpcom object
     1: // to be used from JavaScript.
     1: 
     1: class XPCWrappedNative : public nsIXPConnectWrappedNative
     1: {
     1: public:
  7230:     NS_DECL_ISUPPORTS
     1:     NS_DECL_NSIXPCONNECTJSOBJECTHOLDER
     1:     NS_DECL_NSIXPCONNECTWRAPPEDNATIVE
 10141:     // No need to unlink the JS objects, if the XPCWrappedNative will be cycle
 10141:     // collected then its mFlatJSObject will be cycle collected too and
 10141:     // finalization of the mFlatJSObject will unlink the js objects (see
 10141:     // XPC_WN_NoHelper_Finalize and FlatJSObjectFinalized).
 67680:     // We also give XPCWrappedNative empty Root/Unroot methods, to avoid
 67680:     // root/unrooting the JS objects from addrefing/releasing the
 67680:     // XPCWrappedNative during unlinking, which would make the JS objects
 67680:     // uncollectable to the JS GC.
 12418:     class NS_CYCLE_COLLECTION_INNERCLASS
 12418:      : public nsXPCOMCycleCollectionParticipant
 12418:     {
 12418:       NS_DECL_CYCLE_COLLECTION_CLASS_BODY_NO_UNLINK(XPCWrappedNative,
 12418:                                                     XPCWrappedNative)
 67681:       NS_IMETHOD Root(void *p) { return NS_OK; }
 67680:       NS_IMETHOD Unlink(void *p);
 12418:       NS_IMETHOD Unroot(void *p) { return NS_OK; }
 12418:     };
 12418:     NS_CYCLE_COLLECTION_PARTICIPANT_INSTANCE
  7230:     NS_DECL_CYCLE_COLLECTION_UNMARK_PURPLE_STUB(XPCWrappedNative)
     1: 
 30001:     nsIPrincipal* GetObjectPrincipal() const;
     1: 
     1:     JSBool
     1:     IsValid() const {return nsnull != mFlatJSObject;}
     1: 
 86976: #define XPC_SCOPE_WORD(s)   (intptr_t(s))
 86976: #define XPC_SCOPE_MASK      (intptr_t(0x3))
 86976: #define XPC_SCOPE_TAG       (intptr_t(0x1))
 86976: #define XPC_WRAPPER_EXPIRED (intptr_t(0x2))
     1: 
     1:     static inline JSBool
     1:     IsTaggedScope(XPCWrappedNativeScope* s)
     1:         {return XPC_SCOPE_WORD(s) & XPC_SCOPE_TAG;}
     1: 
     1:     static inline XPCWrappedNativeScope*
     1:     TagScope(XPCWrappedNativeScope* s)
     1:         {NS_ASSERTION(!IsTaggedScope(s), "bad pointer!");
     1:          return (XPCWrappedNativeScope*)(XPC_SCOPE_WORD(s) | XPC_SCOPE_TAG);}
     1: 
     1:     static inline XPCWrappedNativeScope*
     1:     UnTagScope(XPCWrappedNativeScope* s)
     1:         {return (XPCWrappedNativeScope*)(XPC_SCOPE_WORD(s) & ~XPC_SCOPE_TAG);}
     1: 
 12418:     inline JSBool
 12418:     IsWrapperExpired() const
 12418:         {return XPC_SCOPE_WORD(mMaybeScope) & XPC_WRAPPER_EXPIRED;}
 12418: 
     1:     JSBool
     1:     HasProto() const {return !IsTaggedScope(mMaybeScope);}
     1: 
     1:     XPCWrappedNativeProto*
 12418:     GetProto() const
 12418:         {return HasProto() ?
 12418:          (XPCWrappedNativeProto*)
 12418:          (XPC_SCOPE_WORD(mMaybeProto) & ~XPC_SCOPE_MASK) : nsnull;}
 12418: 
 82129:     void SetProto(XPCWrappedNativeProto* p);
     1: 
     1:     XPCWrappedNativeScope*
 12418:     GetScope() const
 12418:         {return GetProto() ? GetProto()->GetScope() :
 12418:          (XPCWrappedNativeScope*)
 12418:          (XPC_SCOPE_WORD(mMaybeScope) & ~XPC_SCOPE_MASK);}
     1: 
     1:     nsISupports*
     1:     GetIdentityObject() const {return mIdentity;}
     1: 
 62690:     /**
 62690:      * This getter clears the gray bit before handing out the JSObject which
 62690:      * means that the object is guaranteed to be kept alive past the next CC.
 62690:      */
     1:     JSObject*
 62690:     GetFlatJSObject() const
 62690:         {if (mFlatJSObject != INVALID_OBJECT)
 62690:              xpc_UnmarkGrayObject(mFlatJSObject);
 57794:          return mFlatJSObject;}
 57794: 
 62690:     /**
 62690:      * This getter does not change the color of the JSObject meaning that the
 62690:      * object returned is not guaranteed to be kept alive past the next CC.
 62690:      *
 62690:      * This should only be called if you are certain that the return value won't
 62690:      * be passed into a JS API function and that it won't be stored without
 62690:      * being rooted (or otherwise signaling the stored value to the CC).
 62690:      */
 57794:     JSObject*
 62690:     GetFlatJSObjectPreserveColor() const {return mFlatJSObject;}
     1: 
     1:     XPCLock*
     1:     GetLock() const {return IsValid() && HasProto() ?
 12418:                                 GetProto()->GetLock() : nsnull;}
     1: 
     1:     XPCNativeSet*
 24206:     GetSet() const {XPCAutoLock al(GetLock()); return mSet;}
     1: 
 24206:     void
 24206:     SetSet(XPCNativeSet* set) {XPCAutoLock al(GetLock()); mSet = set;}
 12418: 
 56818: private:
 12418:     inline void
 12418:     ExpireWrapper()
 12418:         {mMaybeScope = (XPCWrappedNativeScope*)
 12418:                        (XPC_SCOPE_WORD(mMaybeScope) | XPC_WRAPPER_EXPIRED);}
 12418: 
     1: public:
     1: 
     1:     XPCNativeScriptableInfo*
     1:     GetScriptableInfo() const {return mScriptableInfo;}
     1: 
     1:     nsIXPCScriptable*      // call this wrong and you deserve to crash
     1:     GetScriptableCallback() const  {return mScriptableInfo->GetCallback();}
     1: 
     1:     void**
     1:     GetSecurityInfoAddr() {return HasProto() ?
 12418:                                    GetProto()->GetSecurityInfoAddr() : nsnull;}
     1: 
     1:     nsIClassInfo*
     1:     GetClassInfo() const {return IsValid() && HasProto() ?
 12418:                             GetProto()->GetClassInfo() : nsnull;}
     1: 
     1:     JSBool
     1:     HasMutatedSet() const {return IsValid() &&
     1:                                   (!HasProto() ||
 12418:                                    GetSet() != GetProto()->GetSet());}
     1: 
     1:     XPCJSRuntime*
     1:     GetRuntime() const {XPCWrappedNativeScope* scope = GetScope();
     1:                         return scope ? scope->GetRuntime() : nsnull;}
     1: 
     1:     static nsresult
 91588:     WrapNewGlobal(XPCCallContext &ccx, xpcObjectHelper &nativeHelper,
 91588:                   nsIPrincipal *principal, bool initStandardClasses,
 91588:                   XPCWrappedNative **wrappedGlobal);
 91588: 
 91588:     static nsresult
     1:     GetNewOrUsed(XPCCallContext& ccx,
 51515:                  xpcObjectHelper& helper,
     1:                  XPCWrappedNativeScope* Scope,
     1:                  XPCNativeInterface* Interface,
     1:                  XPCWrappedNative** wrapper);
     1: 
 30001:     static nsresult
 30001:     Morph(XPCCallContext& ccx,
 30001:           JSObject* existingJSObject,
 30001:           XPCNativeInterface* Interface,
 30001:           nsWrapperCache *cache,
 30001:           XPCWrappedNative** resultWrapper);
 30001: 
     1: public:
     1:     static nsresult
     1:     GetUsedOnly(XPCCallContext& ccx,
     1:                 nsISupports* Object,
     1:                 XPCWrappedNativeScope* Scope,
     1:                 XPCNativeInterface* Interface,
     1:                 XPCWrappedNative** wrapper);
     1: 
 33786:     // If pobj2 is not null and *pobj2 is not null after the call then *pobj2
 33786:     // points to an object for which IS_SLIM_WRAPPER_OBJECT is true.
 71347:     // cx is null when invoked from the marking phase of the GC. In this case
 71347:     // fubobj must be null as well.
     1:     static XPCWrappedNative*
     1:     GetWrappedNativeOfJSObject(JSContext* cx, JSObject* obj,
     1:                                JSObject* funobj = nsnull,
     1:                                JSObject** pobj2 = nsnull,
     1:                                XPCWrappedNativeTearOff** pTearOff = nsnull);
 30001:     static XPCWrappedNative*
 30001:     GetAndMorphWrappedNativeOfJSObject(JSContext* cx, JSObject* obj)
 30001:     {
 30001:         JSObject *obj2 = nsnull;
 30001:         XPCWrappedNative* wrapper =
 30001:             GetWrappedNativeOfJSObject(cx, obj, nsnull, &obj2);
 30001:         if (wrapper || !obj2)
 30001:             return wrapper;
 30001: 
 30001:         NS_ASSERTION(IS_SLIM_WRAPPER(obj2),
 30001:                      "Hmm, someone changed GetWrappedNativeOfJSObject?");
 30001:         SLIM_LOG_WILL_MORPH(cx, obj2);
 30001:         return MorphSlimWrapper(cx, obj2) ?
 30001:                (XPCWrappedNative*)xpc_GetJSPrivate(obj2) :
 30001:                nsnull;
 30001:     }
     1: 
     1:     static nsresult
     1:     ReparentWrapperIfFound(XPCCallContext& ccx,
     1:                            XPCWrappedNativeScope* aOldScope,
     1:                            XPCWrappedNativeScope* aNewScope,
     1:                            JSObject* aNewParent,
     1:                            nsISupports* aCOMObj,
     1:                            XPCWrappedNative** aWrapper);
     1: 
100253:     // Returns the wrapper corresponding to the parent of our mFlatJSObject.
100253:     //
100253:     // If the parent does not have a WN, or if there is no parent, null is
100253:     // returned.
100253:     XPCWrappedNative *GetParentWrapper();
100253: 
100253:     bool IsOrphan();
100253:     nsresult RescueOrphans(XPCCallContext& ccx);
100253: 
 89826:     void FlatJSObjectFinalized();
 89826: 
 89826:     void SystemIsBeingShutDown();
     1: 
     1:     enum CallMode {CALL_METHOD, CALL_GETTER, CALL_SETTER};
     1: 
     1:     static JSBool CallMethod(XPCCallContext& ccx,
     1:                              CallMode mode = CALL_METHOD);
     1: 
     1:     static JSBool GetAttribute(XPCCallContext& ccx)
     1:         {return CallMethod(ccx, CALL_GETTER);}
     1: 
     1:     static JSBool SetAttribute(XPCCallContext& ccx)
     1:         {return CallMethod(ccx, CALL_SETTER);}
     1: 
     1:     inline JSBool HasInterfaceNoQI(const nsIID& iid);
     1: 
     1:     XPCWrappedNativeTearOff* LocateTearOff(XPCCallContext& ccx,
     1:                                            XPCNativeInterface* aInterface);
     1:     XPCWrappedNativeTearOff* FindTearOff(XPCCallContext& ccx,
     1:                                          XPCNativeInterface* aInterface,
 82794:                                          JSBool needJSObject = false,
     1:                                          nsresult* pError = nsnull);
     1:     void Mark() const
     1:     {
 24206:         mSet->Mark();
     1:         if (mScriptableInfo) mScriptableInfo->Mark();
 12418:         if (HasProto()) GetProto()->Mark();
     1:     }
     1: 
     1:     // Yes, we *do* need to mark the mScriptableInfo in both cases.
 97874:     inline void TraceInside(JSTracer *trc) {
 97872:         if (JS_IsGCMarkingTracer(trc)) {
 97872:             mSet->Mark();
 97872:             if (mScriptableInfo)
  1025:                 mScriptableInfo->Mark();
 97872:         }
 97872:         if (HasProto())
 97872:             GetProto()->TraceJS(trc);
 62690:         JSObject* wrapper = GetWrapperPreserveColor();
 27664:         if (wrapper)
 27664:             JS_CALL_OBJECT_TRACER(trc, wrapper, "XPCWrappedNative::mWrapper");
 80070:         if (mScriptableInfo &&
 80070:             (mScriptableInfo->GetJSClass()->flags & JSCLASS_XPCONNECT_GLOBAL))
 97872:         {
 91587:             TraceXPCGlobal(trc, mFlatJSObject);
 97872:         }
     1:     }
     1: 
 97874:     void TraceJS(JSTracer *trc) {
 97874:         TraceInside(trc);
 97874:     }
 97874: 
 97874:     void TraceSelf(JSTracer *trc) {
     1:         // If this got called, we're being kept alive by someone who really
     1:         // needs us alive and whole.  Do not let our mFlatJSObject go away.
  1025:         // This is the only time we should be tracing our mFlatJSObject,
  1025:         // normally somebody else is doing that. Be careful not to trace the
 48470:         // bogus INVALID_OBJECT value we can have during init, though.
 80389:         if (mFlatJSObject && mFlatJSObject != INVALID_OBJECT) {
  1025:             JS_CALL_OBJECT_TRACER(trc, mFlatJSObject,
  1025:                                   "XPCWrappedNative::mFlatJSObject");
     1:         }
     1:     }
     1: 
 97874:     void AutoTrace(JSTracer *trc) {
 97874:         TraceSelf(trc);
 97874:     }
 97874: 
     1: #ifdef DEBUG
     1:     void ASSERT_SetsNotMarked() const
     1:         {mSet->ASSERT_NotMarked();
 12418:          if (HasProto()){GetProto()->ASSERT_SetNotMarked();}}
     1: 
     1:     int DEBUG_CountOfTearoffChunks() const
     1:         {int i = 0; const XPCWrappedNativeTearOffChunk* to;
     1:          for (to = &mFirstChunk; to; to = to->mNextChunk) {i++;} return i;}
     1: #endif
     1: 
     1:     inline void SweepTearOffs();
     1: 
     1:     // Returns a string that shuld be free'd using JS_smprintf_free (or null).
     1:     char* ToString(XPCCallContext& ccx,
     1:                    XPCWrappedNativeTearOff* to = nsnull) const;
     1: 
 80387:     static void GatherProtoScriptableCreateInfo(nsIClassInfo* classInfo,
 40489:                                                 XPCNativeScriptableCreateInfo& sciProto);
     1: 
     1:     JSBool HasExternalReference() const {return mRefCnt > 1;}
     1: 
 47574:     JSBool NeedsSOW() { return !!(mWrapperWord & NEEDS_SOW); }
 47574:     void SetNeedsSOW() { mWrapperWord |= NEEDS_SOW; }
 47574:     JSBool NeedsCOW() { return !!(mWrapperWord & NEEDS_COW); }
 47574:     void SetNeedsCOW() { mWrapperWord |= NEEDS_COW; }
 82054:     JSBool MightHaveExpandoObject() { return !!(mWrapperWord & MIGHT_HAVE_EXPANDO); }
 82054:     void SetHasExpandoObject() { mWrapperWord |= MIGHT_HAVE_EXPANDO; }
 30625: 
 62690:     JSObject* GetWrapperPreserveColor() const
 62690:         {return (JSObject*)(mWrapperWord & (size_t)~(size_t)FLAG_MASK);}
 62690: 
 27664:     JSObject* GetWrapper()
 27664:     {
 62690:         JSObject* wrapper = GetWrapperPreserveColor();
 80389:         if (wrapper) {
 62690:             xpc_UnmarkGrayObject(wrapper);
 62690:             // Call this to unmark mFlatJSObject.
 62690:             GetFlatJSObject();
 62690:         }
 62690:         return wrapper;
 27664:     }
 27664:     void SetWrapper(JSObject *obj)
 27664:     {
 87981:         js::IncrementalReferenceBarrier(GetWrapperPreserveColor());
 95340:         intptr_t newval = intptr_t(obj) | (mWrapperWord & FLAG_MASK);
 87981:         mWrapperWord = newval;
 27664:     }
     1: 
 94841:     // Returns the relevant same-compartment security if applicable, or
 94841:     // mFlatJSObject otherwise.
 94841:     //
 94841:     // This takes care of checking mWrapperWord to see if we already have such
 94841:     // a wrapper.
 94841:     JSObject *GetSameCompartmentSecurityWrapper(JSContext *cx);
 94841: 
  7286:     void NoteTearoffs(nsCycleCollectionTraversalCallback& cb);
  7286: 
 21218:     QITableEntry* GetOffsets()
 21218:     {
 21218:         if (!HasProto() || !GetProto()->ClassIsDOMObject())
 21218:             return nsnull;
 21218: 
 21218:         XPCWrappedNativeProto* proto = GetProto();
 21218:         QITableEntry* offsets = proto->GetOffsets();
 80389:         if (!offsets) {
 21218:             static NS_DEFINE_IID(kThisPtrOffsetsSID, NS_THISPTROFFSETS_SID);
 21218:             mIdentity->QueryInterface(kThisPtrOffsetsSID, (void**)&offsets);
 21218:         }
 21218:         return offsets;
 21218:     }
 21218: 
     1:     // Make ctor and dtor protected (rather than private) to placate nsCOMPtr.
     1: protected:
     1:     XPCWrappedNative(); // not implemented
     1: 
     1:     // This ctor is used if this object will have a proto.
 26411:     XPCWrappedNative(already_AddRefed<nsISupports> aIdentity,
     1:                      XPCWrappedNativeProto* aProto);
     1: 
     1:     // This ctor is used if this object will NOT have a proto.
 26411:     XPCWrappedNative(already_AddRefed<nsISupports> aIdentity,
     1:                      XPCWrappedNativeScope* aScope,
     1:                      XPCNativeSet* aSet);
     1: 
     1:     virtual ~XPCWrappedNative();
 68654:     void Destroy();
     1: 
 82129:     void UpdateScriptableInfo(XPCNativeScriptableInfo *si);
 82129: 
     1: private:
 47410:     enum {
 47574:         NEEDS_SOW = JS_BIT(0),
 47574:         NEEDS_COW = JS_BIT(1),
 82054:         MIGHT_HAVE_EXPANDO = JS_BIT(2),
 82054:         FLAG_MASK = JS_BITMASK(3)
 47410:     };
 47410: 
 47410: private:
 30625: 
 91578:     JSBool Init(XPCCallContext& ccx, JSObject* parent, const XPCNativeScriptableCreateInfo* sci);
 30001:     JSBool Init(XPCCallContext &ccx, JSObject *existingJSObject);
 30001:     JSBool FinishInit(XPCCallContext &ccx);
     1: 
     1:     JSBool ExtendSet(XPCCallContext& ccx, XPCNativeInterface* aInterface);
     1: 
     1:     nsresult InitTearOff(XPCCallContext& ccx,
     1:                          XPCWrappedNativeTearOff* aTearOff,
     1:                          XPCNativeInterface* aInterface,
     1:                          JSBool needJSObject);
     1: 
     1:     JSBool InitTearOffJSObject(XPCCallContext& ccx,
     1:                                XPCWrappedNativeTearOff* to);
     1: 
     1: public:
 80387:     static const XPCNativeScriptableCreateInfo& GatherScriptableCreateInfo(nsISupports* obj,
     1:                                                                            nsIClassInfo* classInfo,
 40489:                                                                            XPCNativeScriptableCreateInfo& sciProto,
 40489:                                                                            XPCNativeScriptableCreateInfo& sciWrapper);
     1: 
     1: private:
     1:     union
     1:     {
     1:         XPCWrappedNativeScope*   mMaybeScope;
     1:         XPCWrappedNativeProto*   mMaybeProto;
     1:     };
     1:     XPCNativeSet*                mSet;
     1:     JSObject*                    mFlatJSObject;
     1:     XPCNativeScriptableInfo*     mScriptableInfo;
     1:     XPCWrappedNativeTearOffChunk mFirstChunk;
 95340:     intptr_t                     mWrapperWord;
     1: 
  7230: #ifdef XPC_CHECK_WRAPPER_THREADSAFETY
     1: public:
 60581:     // Don't want to overload _mOwningThread
 60581:     PRThread*                    mThread;
  7230: #endif
     1: };
     1: 
     1: /***************************************************************************
     1: ****************************************************************************
     1: *
     1: * Core classes for wrapped JSObject for use from native code...
     1: *
     1: ****************************************************************************
     1: ***************************************************************************/
     1: 
     1: // this interfaces exists so we can refcount nsXPCWrappedJSClass
     1: // {2453EBA0-A9B8-11d2-BA64-00805F8A5DD7}
     1: #define NS_IXPCONNECT_WRAPPED_JS_CLASS_IID                                    \
     1: { 0x2453eba0, 0xa9b8, 0x11d2,                                                 \
     1:   { 0xba, 0x64, 0x0, 0x80, 0x5f, 0x8a, 0x5d, 0xd7 } }
     1: 
     1: class nsIXPCWrappedJSClass : public nsISupports
     1: {
     1: public:
     1:     NS_DECLARE_STATIC_IID_ACCESSOR(NS_IXPCONNECT_WRAPPED_JS_CLASS_IID)
     1:     NS_IMETHOD DebugDump(PRInt16 depth) = 0;
     1: };
     1: 
     1: NS_DEFINE_STATIC_IID_ACCESSOR(nsIXPCWrappedJSClass,
     1:                               NS_IXPCONNECT_WRAPPED_JS_CLASS_IID)
     1: 
     1: /*************************/
     1: // nsXPCWrappedJSClass represents the sharable factored out common code and
     1: // data for nsXPCWrappedJS instances for the same interface type.
     1: 
     1: class nsXPCWrappedJSClass : public nsIXPCWrappedJSClass
     1: {
     1:     // all the interface method declarations...
     1:     NS_DECL_ISUPPORTS
     1:     NS_IMETHOD DebugDump(PRInt16 depth);
     1: public:
     1: 
     1:     static nsresult
     1:     GetNewOrUsed(XPCCallContext& ccx,
     1:                  REFNSIID aIID,
     1:                  nsXPCWrappedJSClass** clazz);
     1: 
     1:     REFNSIID GetIID() const {return mIID;}
     1:     XPCJSRuntime* GetRuntime() const {return mRuntime;}
     1:     nsIInterfaceInfo* GetInterfaceInfo() const {return mInfo;}
     1:     const char* GetInterfaceName();
     1: 
     1:     static JSBool IsWrappedJS(nsISupports* aPtr);
     1: 
     1:     NS_IMETHOD DelegatedQueryInterface(nsXPCWrappedJS* self, REFNSIID aIID,
     1:                                        void** aInstancePtr);
     1: 
     1:     JSObject* GetRootJSObject(XPCCallContext& ccx, JSObject* aJSObj);
     1: 
 86464:     NS_IMETHOD CallMethod(nsXPCWrappedJS* wrapper, uint16_t methodIndex,
     1:                           const XPTMethodDescriptor* info,
     1:                           nsXPTCMiniVariant* params);
     1: 
     1:     JSObject*  CallQueryInterfaceOnJSObject(XPCCallContext& ccx,
     1:                                             JSObject* jsobj, REFNSIID aIID);
     1: 
     1:     static nsresult BuildPropertyEnumerator(XPCCallContext& ccx,
     1:                                             JSObject* aJSObj,
     1:                                             nsISimpleEnumerator** aEnumerate);
     1: 
     1:     static nsresult GetNamedPropertyAsVariant(XPCCallContext& ccx,
     1:                                               JSObject* aJSObj,
 91832:                                               const nsAString& aName,
     1:                                               nsIVariant** aResult);
     1: 
     1:     virtual ~nsXPCWrappedJSClass();
     1: 
     1:     static nsresult CheckForException(XPCCallContext & ccx,
     1:                                       const char * aPropertyName,
 14170:                                       const char * anInterfaceName,
 79445:                                       bool aForceReport);
     1: private:
     1:     nsXPCWrappedJSClass();   // not implemented
     1:     nsXPCWrappedJSClass(XPCCallContext& ccx, REFNSIID aIID,
     1:                         nsIInterfaceInfo* aInfo);
     1: 
 27428:     JSObject*  NewOutObject(JSContext* cx, JSObject* scope);
     1: 
 86464:     JSBool IsReflectable(uint16_t i) const
     1:         {return (JSBool)(mDescriptors[i/32] & (1 << (i%32)));}
 86464:     void SetReflectable(uint16_t i, JSBool b)
     1:         {if (b) mDescriptors[i/32] |= (1 << (i%32));
     1:          else mDescriptors[i/32] &= ~(1 << (i%32));}
     1: 
     1:     JSBool GetArraySizeFromParam(JSContext* cx,
     1:                                  const XPTMethodDescriptor* method,
     1:                                  const nsXPTParamInfo& param,
 86464:                                  uint16_t methodIndex,
 86464:                                  uint8_t paramIndex,
     1:                                  nsXPTCMiniVariant* params,
 84755:                                  uint32_t* result);
     1: 
     1:     JSBool GetInterfaceTypeFromParam(JSContext* cx,
     1:                                      const XPTMethodDescriptor* method,
     1:                                      const nsXPTParamInfo& param,
 86464:                                      uint16_t methodIndex,
     1:                                      const nsXPTType& type,
     1:                                      nsXPTCMiniVariant* params,
     1:                                      nsID* result);
     1: 
     1:     void CleanupPointerArray(const nsXPTType& datum_type,
 84755:                              uint32_t array_count,
     1:                              void** arrayp);
     1: 
     1:     void CleanupPointerTypeObject(const nsXPTType& type,
     1:                                   void** pp);
     1: 
     1: private:
     1:     XPCJSRuntime* mRuntime;
     1:     nsIInterfaceInfo* mInfo;
     1:     char* mName;
     1:     nsIID mIID;
 86464:     uint32_t* mDescriptors;
     1: };
     1: 
     1: /*************************/
     1: // nsXPCWrappedJS is a wrapper for a single JSObject for use from native code.
     1: // nsXPCWrappedJS objects are chained together to represent the various
     1: // interface on the single underlying (possibly aggregate) JSObject.
     1: 
     1: class nsXPCWrappedJS : protected nsAutoXPTCStub,
     1:                        public nsIXPConnectWrappedJS,
     1:                        public nsSupportsWeakReference,
  2072:                        public nsIPropertyBag,
  2072:                        public XPCRootSetElem
     1: {
     1: public:
     1:     NS_DECL_ISUPPORTS
     1:     NS_DECL_NSIXPCONNECTJSOBJECTHOLDER
     1:     NS_DECL_NSIXPCONNECTWRAPPEDJS
     1:     NS_DECL_NSISUPPORTSWEAKREFERENCE
     1:     NS_DECL_NSIPROPERTYBAG
 10981: 
 67680:     NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsXPCWrappedJS, nsIXPConnectWrappedJS)
     1:     NS_DECL_CYCLE_COLLECTION_UNMARK_PURPLE_STUB(nsXPCWrappedJS)
     1: 
     1:     NS_IMETHOD CallMethod(PRUint16 methodIndex,
     1:                           const XPTMethodDescriptor *info,
     1:                           nsXPTCMiniVariant* params);
     1: 
     1:     /*
     1:     * This is rarely called directly. Instead one usually calls
     1:     * XPCConvert::JSObject2NativeInterface which will handles cases where the
     1:     * JS object is already a wrapped native or a DOM object.
     1:     */
     1: 
     1:     static nsresult
     1:     GetNewOrUsed(XPCCallContext& ccx,
     1:                  JSObject* aJSObj,
     1:                  REFNSIID aIID,
     1:                  nsISupports* aOuter,
     1:                  nsXPCWrappedJS** wrapper);
     1: 
     1:     nsISomeInterface* GetXPTCStub() { return mXPTCStub; }
 62690: 
 62690:     /**
 62690:      * This getter clears the gray bit before handing out the JSObject which
 62690:      * means that the object is guaranteed to be kept alive past the next CC.
 62690:      */
 97588:     JSObject* GetJSObject() const {return xpc_UnmarkGrayObject(mJSObj);}
 62690: 
 62690:     /**
 62690:      * This getter does not change the color of the JSObject meaning that the
 62690:      * object returned is not guaranteed to be kept alive past the next CC.
 62690:      *
 62690:      * This should only be called if you are certain that the return value won't
 62690:      * be passed into a JS API function and that it won't be stored without
 62690:      * being rooted (or otherwise signaling the stored value to the CC).
 62690:      */
 62690:     JSObject* GetJSObjectPreserveColor() const {return mJSObj;}
 62690: 
     1:     nsXPCWrappedJSClass*  GetClass() const {return mClass;}
     1:     REFNSIID GetIID() const {return GetClass()->GetIID();}
     1:     nsXPCWrappedJS* GetRootWrapper() const {return mRoot;}
     1:     nsXPCWrappedJS* GetNextWrapper() const {return mNext;}
     1: 
     1:     nsXPCWrappedJS* Find(REFNSIID aIID);
     1:     nsXPCWrappedJS* FindInherited(REFNSIID aIID);
     1: 
     1:     JSBool IsValid() const {return mJSObj != nsnull;}
     1:     void SystemIsBeingShutDown(JSRuntime* rt);
     1: 
     1:     // This is used by XPCJSRuntime::GCCallback to find wrappers that no
     1:     // longer root their JSObject and are only still alive because they
     1:     // were being used via nsSupportsWeakReference at the time when their
     1:     // last (outside) reference was released. Wrappers that fit into that
     1:     // category are only deleted when we see that their corresponding JSObject
     1:     // is to be finalized.
     1:     JSBool IsSubjectToFinalization() const {return IsValid() && mRefCnt == 1;}
     1: 
     1:     JSBool IsAggregatedToNative() const {return mRoot->mOuter != nsnull;}
     1:     nsISupports* GetAggregatedNativeObject() const {return mRoot->mOuter;}
     1: 
 90200:     void SetIsMainThreadOnly() {
 90200:         MOZ_ASSERT(mMainThread);
 90200:         mMainThreadOnly = true;
 90200:     }
 81556:     bool IsMainThreadOnly() const {return mMainThreadOnly;}
 81556: 
  2072:     void TraceJS(JSTracer* trc);
 98544:     static void GetTraceName(JSTracer* trc, char *buf, size_t bufsize);
  2072: 
     1:     virtual ~nsXPCWrappedJS();
     1: protected:
     1:     nsXPCWrappedJS();   // not implemented
     1:     nsXPCWrappedJS(XPCCallContext& ccx,
     1:                    JSObject* aJSObj,
     1:                    nsXPCWrappedJSClass* aClass,
     1:                    nsXPCWrappedJS* root,
     1:                    nsISupports* aOuter);
     1: 
  7286:    void Unlink();
  7286: 
     1: private:
     1:     JSObject* mJSObj;
     1:     nsXPCWrappedJSClass* mClass;
     1:     nsXPCWrappedJS* mRoot;
     1:     nsXPCWrappedJS* mNext;
     1:     nsISupports* mOuter;    // only set in root
 56711:     bool mMainThread;
 81556:     bool mMainThreadOnly;
     1: };
     1: 
     1: /***************************************************************************/
     1: 
  2072: class XPCJSObjectHolder : public nsIXPConnectJSObjectHolder,
  2072:                           public XPCRootSetElem
     1: {
     1: public:
     1:     // all the interface method declarations...
     1:     NS_DECL_ISUPPORTS
     1:     NS_DECL_NSIXPCONNECTJSOBJECTHOLDER
     1: 
     1:     // non-interface implementation
     1: 
     1: public:
  2072:     static XPCJSObjectHolder* newHolder(XPCCallContext& ccx, JSObject* obj);
     1: 
     1:     virtual ~XPCJSObjectHolder();
     1: 
  2072:     void TraceJS(JSTracer *trc);
 98544:     static void GetTraceName(JSTracer* trc, char *buf, size_t bufsize);
  2072: 
     1: private:
  2072:     XPCJSObjectHolder(XPCCallContext& ccx, JSObject* obj);
     1:     XPCJSObjectHolder(); // not implemented
     1: 
     1:     JSObject* mJSObj;
     1: };
     1: 
     1: /***************************************************************************
     1: ****************************************************************************
     1: *
     1: * All manner of utility classes follow...
     1: *
     1: ****************************************************************************
     1: ***************************************************************************/
     1: 
     1: class xpcProperty : public nsIProperty
     1: {
     1: public:
     1:   NS_DECL_ISUPPORTS
     1:   NS_DECL_NSIPROPERTY
     1: 
     1:   xpcProperty(const PRUnichar* aName, PRUint32 aNameLen, nsIVariant* aValue);
     1:   virtual ~xpcProperty() {}
     1: 
     1: private:
     1:     nsString             mName;
     1:     nsCOMPtr<nsIVariant> mValue;
     1: };
     1: 
     1: /***************************************************************************/
     1: // class here just for static methods
     1: class XPCConvert
     1: {
     1: public:
     1:     static JSBool IsMethodReflectable(const XPTMethodDescriptor& info);
     1: 
     1:     /**
     1:      * Convert a native object into a jsval.
     1:      *
     1:      * @param ccx the context for the whole procedure
     1:      * @param d [out] the resulting jsval
     1:      * @param s the native object we're working with
     1:      * @param type the type of object that s is
     1:      * @param iid the interface of s that we want
 41968:      * @param scope the default scope to put on the new JSObject's parent
     1:      *        chain
     1:      * @param pErr [out] relevant error code, if any.
     1:      */
     1:     static JSBool NativeData2JS(XPCCallContext& ccx, jsval* d, const void* s,
     1:                                 const nsXPTType& type, const nsID* iid,
 62405:                                 nsresult* pErr)
 31395:     {
 31395:         XPCLazyCallContext lccx(ccx);
 62405:         return NativeData2JS(lccx, d, s, type, iid, pErr);
 31395:     }
 31395:     static JSBool NativeData2JS(XPCLazyCallContext& lccx, jsval* d,
 31395:                                 const void* s, const nsXPTType& type,
 62405:                                 const nsID* iid, nsresult* pErr);
     1: 
     1:     static JSBool JSData2Native(XPCCallContext& ccx, void* d, jsval s,
     1:                                 const nsXPTType& type,
     1:                                 JSBool useAllocator, const nsID* iid,
     1:                                 nsresult* pErr);
     1: 
     1:     /**
     1:      * Convert a native nsISupports into a JSObject.
     1:      *
     1:      * @param ccx the context for the whole procedure
     1:      * @param dest [out] the resulting JSObject
     1:      * @param src the native object we're working with
 31395:      * @param iid the interface of src that we want (may be null)
 31395:      * @param Interface the interface of src that we want
 31395:      * @param cache the wrapper cache for src (may be null, in which case src
 31395:      *              will be QI'ed to get the cache)
     1:      * @param allowNativeWrapper if true, this method may wrap the resulting
     1:      *        JSObject in an XPCNativeWrapper and return that, as needed.
     1:      * @param pErr [out] relevant error code, if any.
 80486:      * @param src_is_identity optional performance hint. Set to true only
 48124:      *                        if src is the identity pointer.
     1:      */
     1:     static JSBool NativeInterface2JSObject(XPCCallContext& ccx,
 22841:                                            jsval* d,
     1:                                            nsIXPConnectJSObjectHolder** dest,
 51515:                                            xpcObjectHelper& aHelper,
     1:                                            const nsID* iid,
 31395:                                            XPCNativeInterface** Interface,
 79445:                                            bool allowNativeWrapper,
 51515:                                            nsresult* pErr)
 31395:     {
 31395:         XPCLazyCallContext lccx(ccx);
 51515:         return NativeInterface2JSObject(lccx, d, dest, aHelper, iid, Interface,
 91578:                                         allowNativeWrapper, pErr);
 31395:     }
 31395:     static JSBool NativeInterface2JSObject(XPCLazyCallContext& lccx,
 31395:                                            jsval* d,
 31395:                                            nsIXPConnectJSObjectHolder** dest,
 51515:                                            xpcObjectHelper& aHelper,
 31395:                                            const nsID* iid,
 31395:                                            XPCNativeInterface** Interface,
 79445:                                            bool allowNativeWrapper,
 51515:                                            nsresult* pErr);
     1: 
     1:     static JSBool GetNativeInterfaceFromJSObject(XPCCallContext& ccx,
     1:                                                  void** dest, JSObject* src,
     1:                                                  const nsID* iid,
     1:                                                  nsresult* pErr);
     1:     static JSBool JSObject2NativeInterface(XPCCallContext& ccx,
     1:                                            void** dest, JSObject* src,
     1:                                            const nsID* iid,
     1:                                            nsISupports* aOuter,
     1:                                            nsresult* pErr);
 32833:     static JSBool GetISupportsFromJSObject(JSObject* obj, nsISupports** iface);
     1: 
     1:     /**
     1:      * Convert a native array into a jsval.
     1:      *
     1:      * @param ccx the context for the whole procedure
     1:      * @param d [out] the resulting jsval
     1:      * @param s the native array we're working with
     1:      * @param type the type of objects in the array
     1:      * @param iid the interface of each object in the array that we want
     1:      * @param count the number of items in the array
 41968:      * @param scope the default scope to put on the new JSObjects' parent chain
     1:      * @param pErr [out] relevant error code, if any.
     1:      */
 31395:     static JSBool NativeArray2JS(XPCLazyCallContext& ccx,
     1:                                  jsval* d, const void** s,
     1:                                  const nsXPTType& type, const nsID* iid,
 84755:                                  uint32_t count, nsresult* pErr);
     1: 
     1:     static JSBool JSArray2Native(XPCCallContext& ccx, void** d, jsval s,
 84755:                                  uint32_t count, const nsXPTType& type,
 83339:                                  const nsID* iid, nsresult* pErr);
 83339: 
 83339:     static JSBool JSTypedArray2Native(XPCCallContext& ccx,
 83339:                                       void** d,
 83339:                                       JSObject* jsarray,
 84755:                                       uint32_t count,
 83339:                                       const nsXPTType& type,
 83339:                                       nsresult* pErr);
     1: 
 31395:     static JSBool NativeStringWithSize2JS(JSContext* cx,
     1:                                           jsval* d, const void* s,
     1:                                           const nsXPTType& type,
 84755:                                           uint32_t count,
     1:                                           nsresult* pErr);
     1: 
     1:     static JSBool JSStringWithSize2Native(XPCCallContext& ccx, void* d, jsval s,
 84755:                                           uint32_t count, const nsXPTType& type,
 91237:                                           unsigned* pErr);
     1: 
     1:     static nsresult JSValToXPCException(XPCCallContext& ccx,
     1:                                         jsval s,
     1:                                         const char* ifaceName,
     1:                                         const char* methodName,
     1:                                         nsIException** exception);
     1: 
     1:     static nsresult JSErrorToXPCException(XPCCallContext& ccx,
     1:                                           const char* message,
     1:                                           const char* ifaceName,
     1:                                           const char* methodName,
     1:                                           const JSErrorReport* report,
     1:                                           nsIException** exception);
     1: 
     1:     static nsresult ConstructException(nsresult rv, const char* message,
     1:                                        const char* ifaceName,
     1:                                        const char* methodName,
     1:                                        nsISupports* data,
 19303:                                        nsIException** exception,
 21377:                                        JSContext* cx,
 21377:                                        jsval *jsExceptionPtr);
     1: 
     1: private:
     1:     XPCConvert(); // not implemented
 23442: 
     1: };
     1: 
     1: /***************************************************************************/
     1: 
     1: // readable string conversions, static methods only
     1: class XPCStringConvert
     1: {
     1: public:
     1: 
 49065:     // If the string shares the readable's buffer, that buffer will
 49065:     // get assigned to *sharedBuffer.  Otherwise null will be
 49065:     // assigned.
 47921:     static jsval ReadableToJSVal(JSContext *cx, const nsAString &readable,
 49065:                                  nsStringBuffer** sharedBuffer);
     1: 
     1: private:
     1:     XPCStringConvert();         // not implemented
     1: };
     1: 
     1: /***************************************************************************/
     1: // code for throwing exceptions into JS
     1: 
     1: class XPCThrower
     1: {
     1: public:
     1:     static void Throw(nsresult rv, JSContext* cx);
     1:     static void Throw(nsresult rv, XPCCallContext& ccx);
     1:     static void ThrowBadResult(nsresult rv, nsresult result, XPCCallContext& ccx);
 91237:     static void ThrowBadParam(nsresult rv, unsigned paramNum, XPCCallContext& ccx);
     1:     static JSBool SetVerbosity(JSBool state)
     1:         {JSBool old = sVerbose; sVerbose = state; return old;}
     1: 
 18543:     static void BuildAndThrowException(JSContext* cx, nsresult rv, const char* sz);
 18543:     static JSBool CheckForPendingException(nsresult result, JSContext *cx);
 18543: 
     1: private:
     1:     static void Verbosify(XPCCallContext& ccx,
 79445:                           char** psz, bool own);
     1: 
     1:     static JSBool ThrowExceptionObject(JSContext* cx, nsIException* e);
     1: 
     1: private:
     1:     static JSBool sVerbose;
     1: };
     1: 
     1: 
     1: /***************************************************************************/
     1: 
     1: class XPCJSStack
     1: {
     1: public:
     1:     static nsresult
     1:     CreateStack(JSContext* cx, nsIStackFrame** stack);
     1: 
     1:     static nsresult
     1:     CreateStackFrameLocation(PRUint32 aLanguage,
     1:                              const char* aFilename,
     1:                              const char* aFunctionName,
     1:                              PRInt32 aLineNumber,
     1:                              nsIStackFrame* aCaller,
     1:                              nsIStackFrame** stack);
     1: private:
     1:     XPCJSStack();   // not implemented
     1: };
     1: 
     1: /***************************************************************************/
     1: 
     1: class nsXPCException :
     1:             public nsIXPCException
     1: {
     1: public:
     1:     NS_DEFINE_STATIC_CID_ACCESSOR(NS_XPCEXCEPTION_CID)
     1: 
     1:     NS_DECL_ISUPPORTS
     1:     NS_DECL_NSIEXCEPTION
     1:     NS_DECL_NSIXPCEXCEPTION
     1: 
     1:     static nsresult NewException(const char *aMessage,
     1:                                  nsresult aResult,
     1:                                  nsIStackFrame *aLocation,
     1:                                  nsISupports *aData,
     1:                                  nsIException** exception);
     1: 
     1:     static JSBool NameAndFormatForNSResult(nsresult rv,
     1:                                            const char** name,
     1:                                            const char** format);
     1: 
     1:     static void* IterateNSResults(nsresult* rv,
     1:                                   const char** name,
     1:                                   const char** format,
     1:                                   void** iterp);
     1: 
     1:     static PRUint32 GetNSResultCount();
     1: 
     1:     nsXPCException();
     1:     virtual ~nsXPCException();
     1: 
 82794:     static void InitStatics() { sEverMadeOneFromFactory = false; }
     1: 
     1: protected:
     1:     void Reset();
     1: private:
     1:     char*           mMessage;
     1:     nsresult        mResult;
     1:     char*           mName;
     1:     nsIStackFrame*  mLocation;
     1:     nsISupports*    mData;
     1:     char*           mFilename;
     1:     int             mLineNumber;
     1:     nsIException*   mInner;
 79445:     bool            mInitialized;
     1: 
 21377:     nsAutoJSValHolder mThrownJSVal;
 19303: 
     1:     static JSBool sEverMadeOneFromFactory;
     1: };
     1: 
     1: /***************************************************************************/
     1: /*
     1: * nsJSID implements nsIJSID. It is also used by nsJSIID and nsJSCID as a
     1: * member (as a hidden implementaion detail) to which they delegate many calls.
     1: */
     1: 
 91582: // Initialization is done on demand, and calling the destructor below is always
 91582: // safe.
     1: extern void xpc_DestroyJSxIDClassObjects();
     1: 
     1: class nsJSID : public nsIJSID
     1: {
     1: public:
     1:     NS_DEFINE_STATIC_CID_ACCESSOR(NS_JS_ID_CID)
     1: 
     1:     NS_DECL_ISUPPORTS
     1:     NS_DECL_NSIJSID
     1: 
 79445:     bool InitWithName(const nsID& id, const char *nameString);
 79445:     bool SetName(const char* name);
     1:     void   SetNameToNoString()
     1:         {NS_ASSERTION(!mName, "name already set"); mName = gNoString;}
 79445:     bool NameIsSet() const {return nsnull != mName;}
 10204:     const nsID& ID() const {return mID;}
 79445:     bool IsValid() const {return !mID.Equals(GetInvalidIID());}
     1: 
     1:     static nsJSID* NewID(const char* str);
 10204:     static nsJSID* NewID(const nsID& id);
     1: 
     1:     nsJSID();
     1:     virtual ~nsJSID();
     1: protected:
     1: 
     1:     void Reset();
     1:     const nsID& GetInvalidIID() const;
     1: 
     1: protected:
     1:     static char gNoString[];
     1:     nsID    mID;
     1:     char*   mNumber;
     1:     char*   mName;
     1: };
     1: 
     1: // nsJSIID
     1: 
 68602: class nsJSIID : public nsIJSIID,
 68602:                 public nsIXPCScriptable,
 68602:                 public nsISecurityCheckedComponent
     1: {
     1: public:
     1:     NS_DECL_ISUPPORTS
     1: 
     1:     // we manually delagate these to nsJSID
     1:     NS_DECL_NSIJSID
     1: 
     1:     // we implement the rest...
     1:     NS_DECL_NSIJSIID
     1:     NS_DECL_NSIXPCSCRIPTABLE
     1:     NS_DECL_NSISECURITYCHECKEDCOMPONENT
     1: 
     1:     static nsJSIID* NewID(nsIInterfaceInfo* aInfo);
     1: 
     1:     nsJSIID(nsIInterfaceInfo* aInfo);
     1:     nsJSIID(); // not implemented
     1:     virtual ~nsJSIID();
     1: 
     1: private:
     1:     nsCOMPtr<nsIInterfaceInfo> mInfo;
     1: };
     1: 
     1: // nsJSCID
     1: 
     1: class nsJSCID : public nsIJSCID, public nsIXPCScriptable
     1: {
     1: public:
     1:     NS_DECL_ISUPPORTS
     1: 
     1:     // we manually delagate these to nsJSID
     1:     NS_DECL_NSIJSID
     1: 
     1:     // we implement the rest...
     1:     NS_DECL_NSIJSCID
     1:     NS_DECL_NSIXPCSCRIPTABLE
     1: 
     1:     static nsJSCID* NewID(const char* str);
     1: 
     1:     nsJSCID();
     1:     virtual ~nsJSCID();
     1: 
     1: private:
     1:     void ResolveName();
     1: 
     1: private:
     1:     nsJSID mDetails;
     1: };
     1: 
     1: 
     1: /***************************************************************************/
     1: // XPCJSContextStack is not actually an xpcom object, but xpcom calls are
     1: // delegated to it as an implementation detail.
 10990: struct XPCJSContextInfo {
 10990:     XPCJSContextInfo(JSContext* aCx) :
  1104:         cx(aCx),
 71697:         savedFrameChain(false),
 53548:         suspendDepth(0)
  1104:     {}
  1104:     JSContext* cx;
 10990: 
 71697:     // Whether the frame chain was saved
 71697:     bool savedFrameChain;
 10990: 
 53548:     // Greater than 0 if a request was suspended.
 91392:     unsigned suspendDepth;
  1104: };
     1: 
     1: class XPCJSContextStack
     1: {
     1: public:
 86979:     XPCJSContextStack()
 86979:       : mSafeJSContext(NULL)
 86979:       , mOwnSafeJSContext(NULL)
 86979:     { }
 86979: 
     1:     virtual ~XPCJSContextStack();
     1: 
 86979:     uint32_t Count()
 86979:     {
 86979:         return mStack.Length();
 86979:     }
 86979: 
 86979:     JSContext *Peek()
 86979:     {
 86979:         return mStack.IsEmpty() ? NULL : mStack[mStack.Length() - 1].cx;
 86979:     }
 86979: 
 86979:     JSContext *Pop();
 86979:     bool Push(JSContext *cx);
 86979:     JSContext *GetSafeJSContext();
 86979: 
     1: #ifdef DEBUG
 86979:     bool DEBUG_StackHasJSContext(JSContext *cx);
     1: #endif
     1: 
 86979:     const InfallibleTArray<XPCJSContextInfo>* GetStack()
  1104:     { return &mStack; }
     1: 
     1: private:
 86979:     AutoInfallibleTArray<XPCJSContextInfo, 16> mStack;
     1:     JSContext*  mSafeJSContext;
     1:     JSContext*  mOwnSafeJSContext;
     1: };
     1: 
     1: /***************************************************************************/
     1: 
     1: #define NS_XPC_JSCONTEXT_STACK_ITERATOR_CID                                   \
     1: { 0x05bae29d, 0x8aef, 0x486d,                                                 \
     1:   { 0x84, 0xaa, 0x53, 0xf4, 0x8f, 0x14, 0x68, 0x11 } }
     1: 
     1: class nsXPCJSContextStackIterator : public nsIJSContextStackIterator
     1: {
     1: public:
     1:     NS_DECL_ISUPPORTS
     1:     NS_DECL_NSIJSCONTEXTSTACKITERATOR
     1: 
     1: private:
 86979:     const InfallibleTArray<XPCJSContextInfo> *mStack;
  1104:     PRUint32 mPosition;
     1: };
     1: 
     1: /**************************************************************/
     1: // All of our thread local storage.
     1: 
     1: class XPCPerThreadData
     1: {
 64576:     typedef mozilla::Mutex Mutex;
 64576: 
     1: public:
     1:     // Get the instance of this object for the current thread
 10490:     static inline XPCPerThreadData* GetData(JSContext *cx)
 10490:     {
 87322:         // Do a release-mode assert that we're not doing anything significant in
 87322:         // XPConnect off the main thread. If you're an extension developer hitting
 87322:         // this, you need to change your code. See bug 716167.
 87322:         if (!NS_LIKELY(NS_IsMainThread() || NS_IsCycleCollectorThread()))
 90200:             MOZ_Assert("NS_IsMainThread()", __FILE__, __LINE__);
 87322: 
 80389:         if (cx) {
 88135:             if (js::GetOwnerThread(cx) == sMainJSThread)
 10490:                 return sMainThreadData;
 80390:         } else if (sMainThreadData && sMainThreadData->mThread == PR_GetCurrentThread()) {
 15864:             return sMainThreadData;
 15864:         }
 10490: 
 10490:         return GetDataImpl(cx);
 10490:     }
 10490: 
     1:     static void CleanupAllThreads();
     1: 
     1:     ~XPCPerThreadData();
     1: 
     1:     nsresult GetException(nsIException** aException)
     1:     {
     1:         if (EnsureExceptionManager())
     1:             return mExceptionManager->GetCurrentException(aException);
     1: 
     1:         NS_IF_ADDREF(mException);
     1:         *aException = mException;
     1:         return NS_OK;
     1:     }
     1: 
     1:     nsresult SetException(nsIException* aException)
     1:     {
     1:         if (EnsureExceptionManager())
     1:             return mExceptionManager->SetCurrentException(aException);
     1: 
     1:         NS_IF_ADDREF(aException);
     1:         NS_IF_RELEASE(mException);
     1:         mException = aException;
     1:         return NS_OK;
     1:     }
     1: 
     1:     nsIExceptionManager* GetExceptionManager()
     1:     {
     1:         if (EnsureExceptionManager())
     1:             return mExceptionManager;
     1:         return nsnull;
     1:     }
     1: 
     1:     JSBool EnsureExceptionManager()
     1:     {
     1:         if (mExceptionManager)
 82794:             return true;
     1: 
     1:         if (mExceptionManagerNotAvailable)
 82794:             return false;
     1: 
     1:         nsCOMPtr<nsIExceptionService> xs =
     1:             do_GetService(NS_EXCEPTIONSERVICE_CONTRACTID);
     1:         if (xs)
     1:             xs->GetCurrentExceptionManager(&mExceptionManager);
     1:         if (mExceptionManager)
 82794:             return true;
 82794: 
 82794:         mExceptionManagerNotAvailable = true;
 82794:         return false;
     1:     }
     1: 
     1:     XPCJSContextStack* GetJSContextStack() {return mJSContextStack;}
     1: 
     1:     XPCCallContext*  GetCallContext() const {return mCallContext;}
     1:     XPCCallContext*  SetCallContext(XPCCallContext* ccx)
     1:         {XPCCallContext* old = mCallContext; mCallContext = ccx; return old;}
     1: 
 48470:     jsid GetResolveName() const {return mResolveName;}
 48470:     jsid SetResolveName(jsid name)
 48470:         {jsid old = mResolveName; mResolveName = name; return old;}
     1: 
     1:     XPCWrappedNative* GetResolvingWrapper() const {return mResolvingWrapper;}
     1:     XPCWrappedNative* SetResolvingWrapper(XPCWrappedNative* w)
     1:         {XPCWrappedNative* old = mResolvingWrapper;
     1:          mResolvingWrapper = w; return old;}
     1: 
     1:     void Cleanup();
     1:     void ReleaseNatives();
     1: 
 79445:     bool IsValid() const {return mJSContextStack != nsnull;}
     1: 
 64576:     static Mutex* GetLock() {return gLock;}
     1:     // Must be called with the threads locked.
     1:     static XPCPerThreadData* IterateThreads(XPCPerThreadData** iteratorp);
     1: 
     1:     AutoMarkingPtr**  GetAutoRootsAdr() {return &mAutoRoots;}
     1: 
  1025:     void TraceJS(JSTracer* trc);
     1:     void MarkAutoRootsAfterJSFinalize();
     1: 
     1:     static void InitStatics()
     1:         { gLock = nsnull; gThreads = nsnull; gTLSIndex = BAD_TLS_INDEX; }
     1: 
     1: #ifdef XPC_CHECK_WRAPPER_THREADSAFETY
 84755:     uint32_t  IncrementWrappedNativeThreadsafetyReportDepth()
     1:         {return ++mWrappedNativeThreadsafetyReportDepth;}
     1:     void      ClearWrappedNativeThreadsafetyReportDepth()
     1:         {mWrappedNativeThreadsafetyReportDepth = 0;}
     1: #endif
     1: 
 10490:     static void ShutDown()
 10490:         {sMainJSThread = nsnull; sMainThreadData = nsnull;}
 10490: 
 79445:     static bool IsMainThread(JSContext *cx)
 88135:         { return js::GetOwnerThread(cx) == sMainJSThread; }
 18543: 
     1: private:
     1:     XPCPerThreadData();
 10490:     static XPCPerThreadData* GetDataImpl(JSContext *cx);
     1: 
     1: private:
     1:     XPCJSContextStack*   mJSContextStack;
     1:     XPCPerThreadData*    mNextThread;
     1:     XPCCallContext*      mCallContext;
 48470:     jsid                 mResolveName;
     1:     XPCWrappedNative*    mResolvingWrapper;
     1: 
     1:     nsIExceptionManager* mExceptionManager;
     1:     nsIException*        mException;
     1:     JSBool               mExceptionManagerNotAvailable;
     1:     AutoMarkingPtr*      mAutoRoots;
     1: 
     1: #ifdef XPC_CHECK_WRAPPER_THREADSAFETY
 84755:     uint32_t             mWrappedNativeThreadsafetyReportDepth;
     1: #endif
     1:     PRThread*            mThread;
     1: 
 64576:     static Mutex*            gLock;
     1:     static XPCPerThreadData* gThreads;
     1:     static PRUintn           gTLSIndex;
 10490: 
 10490:     // Cached value of cx->thread on the main thread.
 10490:     static void *sMainJSThread;
 10490: 
 10490:     // Cached per thread data for the main thread. Only safe to access
 10490:     // if cx->thread == sMainJSThread.
 10490:     static XPCPerThreadData *sMainThreadData;
     1: };
     1: 
     1: /***************************************************************************/
     1: #include "nsIScriptSecurityManager.h"
     1: 
     1: class BackstagePass : public nsIScriptObjectPrincipal,
     1:                       public nsIXPCScriptable,
     1:                       public nsIClassInfo
     1: {
     1: public:
     1:   NS_DECL_ISUPPORTS
     1:   NS_DECL_NSIXPCSCRIPTABLE
     1:   NS_DECL_NSICLASSINFO
     1: 
     1:   virtual nsIPrincipal* GetPrincipal() {
     1:     return mPrincipal;
     1:   }
     1: 
     1:   BackstagePass(nsIPrincipal *prin) :
     1:     mPrincipal(prin)
     1:   {
     1:   }
     1: 
     1:   virtual ~BackstagePass() { }
     1: 
     1: private:
     1:   nsCOMPtr<nsIPrincipal> mPrincipal;
     1: };
     1: // 'Components' object
     1: 
     1: class nsXPCComponents : public nsIXPCComponents,
     1:                         public nsIXPCScriptable,
 68602:                         public nsIClassInfo,
 68602:                         public nsISecurityCheckedComponent
     1: {
     1: public:
     1:     NS_DECL_ISUPPORTS
     1:     NS_DECL_NSIXPCCOMPONENTS
     1:     NS_DECL_NSIXPCSCRIPTABLE
     1:     NS_DECL_NSICLASSINFO
     1:     NS_DECL_NSISECURITYCHECKEDCOMPONENT
     1: 
     1: public:
     1:     static JSBool
 97170:     AttachComponentsObject(XPCCallContext& ccx,
     1:                            XPCWrappedNativeScope* aScope,
     1:                            JSObject* aGlobal);
     1: 
     1:     void SystemIsBeingShutDown() {ClearMembers();}
     1: 
     1:     virtual ~nsXPCComponents();
     1: 
     1: private:
 97169:     nsXPCComponents(XPCWrappedNativeScope* aScope);
     1:     void ClearMembers();
     1: 
     1: private:
 97169:     friend class XPCWrappedNativeScope;
 97169:     XPCWrappedNativeScope*          mScope;
     1:     nsXPCComponents_Interfaces*     mInterfaces;
     1:     nsXPCComponents_InterfacesByID* mInterfacesByID;
     1:     nsXPCComponents_Classes*        mClasses;
     1:     nsXPCComponents_ClassesByID*    mClassesByID;
     1:     nsXPCComponents_Results*        mResults;
     1:     nsXPCComponents_ID*             mID;
     1:     nsXPCComponents_Exception*      mException;
     1:     nsXPCComponents_Constructor*    mConstructor;
     1:     nsXPCComponents_Utils*          mUtils;
     1: };
     1: 
     1: 
     1: /***************************************************************************/
     1: 
     1: extern JSObject*
     1: xpc_NewIDObject(JSContext *cx, JSObject* jsobj, const nsID& aID);
     1: 
 10204: extern const nsID*
     1: xpc_JSObjectToID(JSContext *cx, JSObject* obj);
     1: 
     1: extern JSBool
     1: xpc_JSObjectIsID(JSContext *cx, JSObject* obj);
     1: 
     1: /***************************************************************************/
     1: // in xpcdebug.cpp
     1: 
     1: extern JSBool
  5905: xpc_DumpJSStack(JSContext* cx, JSBool showArgs, JSBool showLocals,
     1:                 JSBool showThisProps);
     1: 
 55472: // Return a newly-allocated string containing a representation of the
 55472: // current JS stack.  It is the *caller's* responsibility to free this
 55472: // string with JS_smprintf_free().
 55472: extern char*
 55472: xpc_PrintJSStack(JSContext* cx, JSBool showArgs, JSBool showLocals,
 55472:                  JSBool showThisProps);
 55472: 
     1: extern JSBool
 84755: xpc_DumpEvalInJSStackFrame(JSContext* cx, uint32_t frameno, const char* text);
     1: 
     1: extern JSBool
     1: xpc_DumpJSObject(JSObject* obj);
     1: 
     1: extern JSBool
     1: xpc_InstallJSDebuggerKeywordHandler(JSRuntime* rt);
     1: 
     1: /***************************************************************************/
     1: 
     1: // Definition of nsScriptError, defined here because we lack a place to put
     1: // XPCOM objects associated with the JavaScript engine.
 86030: class nsScriptError : public nsIScriptError {
     1: public:
     1:     nsScriptError();
     1: 
     1:     virtual ~nsScriptError();
     1: 
     1:   // TODO - do something reasonable on getting null from these babies.
     1: 
     1:     NS_DECL_ISUPPORTS
     1:     NS_DECL_NSICONSOLEMESSAGE
     1:     NS_DECL_NSISCRIPTERROR
     1: 
     1: private:
     1:     nsString mMessage;
     1:     nsString mSourceName;
     1:     PRUint32 mLineNumber;
     1:     nsString mSourceLine;
     1:     PRUint32 mColumnNumber;
     1:     PRUint32 mFlags;
     1:     nsCString mCategory;
 77330:     PRUint64 mOuterWindowID;
 77330:     PRUint64 mInnerWindowID;
 84832:     PRInt64 mTimeStamp;
     1: };
     1: 
     1: /******************************************************************************
     1:  * Handles pre/post script processing and the setting/resetting the error
     1:  * reporter
     1:  */
 40209: class NS_STACK_CLASS AutoScriptEvaluate
     1: {
     1: public:
     1:     /**
     1:      * Saves the JSContext as well as initializing our state
     1:      * @param cx The JSContext, this can be null, we don't do anything then
     1:      */
 86900:     AutoScriptEvaluate(JSContext * cx MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
 80486:          : mJSContext(cx), mState(0), mErrorReporterSet(false),
 80486:            mEvaluated(false), mContextHasThread(0) {
 86900:         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
 40209:     }
     1: 
     1:     /**
     1:      * Does the pre script evaluation and sets the error reporter if given
     1:      * This function should only be called once, and will assert if called
     1:      * more than once
     1:      * @param errorReporter the error reporter callback function to set
     1:      */
     1: 
 79445:     bool StartEvaluating(JSObject *scope, JSErrorReporter errorReporter = nsnull);
     1:     /**
     1:      * Does the post script evaluation and resets the error reporter
     1:      */
     1:     ~AutoScriptEvaluate();
     1: private:
     1:     JSContext* mJSContext;
     1:     JSExceptionState* mState;
 79445:     bool mErrorReporterSet;
 79445:     bool mEvaluated;
 86976:     intptr_t mContextHasThread;
 61765:     JSAutoEnterCompartment mEnterCompartment;
 86900:     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
     1: 
     1:     // No copying or assignment allowed
 86054:     AutoScriptEvaluate(const AutoScriptEvaluate &) MOZ_DELETE;
 86054:     AutoScriptEvaluate & operator =(const AutoScriptEvaluate &) MOZ_DELETE;
     1: };
     1: 
     1: /***************************************************************************/
 40209: class NS_STACK_CLASS AutoResolveName
     1: {
     1: public:
 48470:     AutoResolveName(XPCCallContext& ccx, jsid name
 86900:                     MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
     1:         : mTLS(ccx.GetThreadData()),
     1:           mOld(mTLS->SetResolveName(name)),
 40209:           mCheck(name) {
 86900:         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
 40209:     }
     1:     ~AutoResolveName()
     1:         {
     1: #ifdef DEBUG
 48470:             jsid old =
     1: #endif
     1:             mTLS->SetResolveName(mOld);
     1:             NS_ASSERTION(old == mCheck, "Bad Nesting!");
     1:         }
     1: 
     1: private:
     1:     XPCPerThreadData* mTLS;
 48470:     jsid mOld;
 48470:     jsid mCheck;
 86900:     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
     1: };
     1: 
     1: /***************************************************************************/
     1: class XPCMarkableJSVal
     1: {
     1: public:
     1:     XPCMarkableJSVal(jsval val) : mVal(val), mValPtr(&mVal) {}
 48470:     XPCMarkableJSVal(jsval *pval) : mVal(JSVAL_VOID), mValPtr(pval) {}
     1:     ~XPCMarkableJSVal() {}
     1:     void Mark() {}
  1025:     void TraceJS(JSTracer* trc)
  1025:     {
  1025:         JS_CALL_VALUE_TRACER(trc, *mValPtr, "XPCMarkableJSVal");
  1025:     }
  1025:     void AutoTrace(JSTracer* trc) {}
     1: private:
     1:     XPCMarkableJSVal(); // not implemented
     1:     jsval  mVal;
     1:     jsval* mValPtr;
     1: };
     1: 
     1: /***************************************************************************/
     1: // AutoMarkingPtr is the base class for the various AutoMarking pointer types
     1: // below. This system allows us to temporarily protect instances of our garbage
     1: // collected types after they are constructed but before they are safely
     1: // attached to other rooted objects.
     1: // This base class has pure virtual support for marking.
     1: 
     1: class AutoMarkingPtr
     1: {
     1:   public:
 97873:     AutoMarkingPtr(XPCCallContext& ccx) {
 97873:         mRoot = ccx.GetThreadData()->GetAutoRootsAdr();
 97873:         mNext = *mRoot;
 97873:         *mRoot = this;
     1:     }
 97873: 
 97873:     virtual ~AutoMarkingPtr() {
 97873:         if (mRoot) {
 97873:             MOZ_ASSERT(*mRoot == this);
 97873:             *mRoot = mNext;
     1:         }
 97873:     }
 97873: 
 97873:     void TraceJSAll(JSTracer* trc) {
 97873:         for (AutoMarkingPtr *cur = this; cur; cur = cur->mNext)
 97873:             cur->TraceJS(trc);
 97873:     }
 97873: 
 97873:     void MarkAfterJSFinalizeAll() {
 97873:         for (AutoMarkingPtr *cur = this; cur; cur = cur->mNext)
 97873:             cur->MarkAfterJSFinalize();
 97873:     }
 97873: 
 97873:   protected:
  1025:     virtual void TraceJS(JSTracer* trc) = 0;
     1:     virtual void MarkAfterJSFinalize() = 0;
     1: 
 97873:   private:
 97873:     AutoMarkingPtr** mRoot;
 97873:     AutoMarkingPtr* mNext;
 97873: };
 97873: 
 97873: template<class T>
 97873: class TypedAutoMarkingPtr : public AutoMarkingPtr
 97873: {
 97873:   public:
 97873:     TypedAutoMarkingPtr(XPCCallContext& ccx) : AutoMarkingPtr(ccx), mPtr(nsnull) {}
 97873:     TypedAutoMarkingPtr(XPCCallContext& ccx, T* ptr) : AutoMarkingPtr(ccx), mPtr(ptr) {}
 97873: 
 97873:     T* get() const { return mPtr; }
 97873:     operator T *() const { return mPtr; }
 97873:     T* operator->() const { return mPtr; }
 97873: 
 97873:     TypedAutoMarkingPtr<T>& operator =(T* ptr) { mPtr = ptr; return *this; }
 97873: 
     1:   protected:
 97873:     virtual void TraceJS(JSTracer* trc)
 97873:     {
 97873:         if (mPtr) {
 97873:             mPtr->TraceJS(trc);
 97873:             mPtr->AutoTrace(trc);
 97873:         }
 97873:     }
 97873: 
 97873:     virtual void MarkAfterJSFinalize()
 97873:     {
 97873:         if (mPtr)
 97873:             mPtr->Mark();
 97873:     }
 97873: 
 97873:   private:
 97873:     T* mPtr;
     1: };
     1: 
 97873: typedef TypedAutoMarkingPtr<XPCNativeInterface> AutoMarkingNativeInterfacePtr;
 97873: typedef TypedAutoMarkingPtr<XPCNativeSet> AutoMarkingNativeSetPtr;
 97873: typedef TypedAutoMarkingPtr<XPCWrappedNative> AutoMarkingWrappedNativePtr;
 97873: typedef TypedAutoMarkingPtr<XPCWrappedNativeTearOff> AutoMarkingWrappedNativeTearOffPtr;
 97873: typedef TypedAutoMarkingPtr<XPCWrappedNativeProto> AutoMarkingWrappedNativeProtoPtr;
 97873: typedef TypedAutoMarkingPtr<XPCMarkableJSVal> AutoMarkingJSVal;
 98022: typedef TypedAutoMarkingPtr<XPCNativeScriptableInfo> AutoMarkingNativeScriptableInfoPtr;
 97873: 
 97873: template<class T>
 97873: class ArrayAutoMarkingPtr : public AutoMarkingPtr
 97873: {
 97873:   public:
 97873:     ArrayAutoMarkingPtr(XPCCallContext& ccx)
 97873:       : AutoMarkingPtr(ccx), mPtr(nsnull), mCount(0) {}
 97873:     ArrayAutoMarkingPtr(XPCCallContext& ccx, T** ptr, PRUint32 count, bool clear)
 97873:       : AutoMarkingPtr(ccx), mPtr(ptr), mCount(count)
 97873:     {
 97873:         if (!mPtr) mCount = 0;
 97873:         else if (clear) memset(mPtr, 0, mCount*sizeof(T*));
 97873:     }
 97873: 
 97873:     T** get() const { return mPtr; }
 97873:     operator T **() const { return mPtr; }
 97873:     T** operator->() const { return mPtr; }
 97873: 
 97873:     ArrayAutoMarkingPtr<T>& operator =(const ArrayAutoMarkingPtr<T> &other)
 97873:     {
 97873:         mPtr = other.mPtr;
 97873:         mCount = other.mCount;
 97873:         return *this;
 97873:     }
 97873: 
 97873:   protected:
 97873:     virtual void TraceJS(JSTracer* trc)
 97873:     {
 97873:         for (PRUint32 i = 0; i < mCount; i++) {
 97873:             if (mPtr[i]) {
 97873:                 mPtr[i]->TraceJS(trc);
 97873:                 mPtr[i]->AutoTrace(trc);
 97873:             }
 97873:         }
 97873:     }
 97873: 
 97873:     virtual void MarkAfterJSFinalize()
 97873:     {
 97873:         for (PRUint32 i = 0; i < mCount; i++) {
 97873:             if (mPtr[i])
 97873:                 mPtr[i]->Mark();
 97873:         }
 97873:     }
 97873: 
 97873:   private:
 97873:     T** mPtr;
 97873:     PRUint32 mCount;
     1: };
     1: 
 97873: typedef ArrayAutoMarkingPtr<XPCNativeInterface> AutoMarkingNativeInterfacePtrArrayPtr;
     1: 
     1: #define AUTO_MARK_JSVAL_HELPER2(tok, line) tok##line
     1: #define AUTO_MARK_JSVAL_HELPER(tok, line) AUTO_MARK_JSVAL_HELPER2(tok, line)
     1: 
     1: #define AUTO_MARK_JSVAL(ccx, val)                                             \
     1:     XPCMarkableJSVal AUTO_MARK_JSVAL_HELPER(_val_,__LINE__)(val);             \
     1:     AutoMarkingJSVal AUTO_MARK_JSVAL_HELPER(_automarker_,__LINE__)            \
     1:     (ccx, &AUTO_MARK_JSVAL_HELPER(_val_,__LINE__))
     1: 
     1: /***************************************************************************/
     1: // Allocates a string that grants all access ("AllAccess")
     1: 
     1: extern char* xpc_CloneAllAccess();
     1: /***************************************************************************/
     1: // Returns access if wideName is in list
     1: 
     1: extern char * xpc_CheckAccessList(const PRUnichar* wideName, const char* list[]);
     1: 
     1: /***************************************************************************/
     1: // in xpcvariant.cpp...
     1: 
     1: // {1809FD50-91E8-11d5-90F9-0010A4E73D9A}
     1: #define XPCVARIANT_IID                                                        \
     1:     {0x1809fd50, 0x91e8, 0x11d5,                                              \
     1:       { 0x90, 0xf9, 0x0, 0x10, 0xa4, 0xe7, 0x3d, 0x9a } }
     1: 
 47016: // {DC524540-487E-4501-9AC7-AAA784B17C1C}
 47016: #define XPCVARIANT_CID                                                        \
 47016:     {0xdc524540, 0x487e, 0x4501,                                              \
 47016:       { 0x9a, 0xc7, 0xaa, 0xa7, 0x84, 0xb1, 0x7c, 0x1c } }
 47016: 
     1: class XPCVariant : public nsIVariant
     1: {
     1: public:
     1:     NS_DECL_CYCLE_COLLECTING_ISUPPORTS
     1:     NS_DECL_NSIVARIANT
     1:     NS_DECL_CYCLE_COLLECTION_CLASS(XPCVariant)
     1: 
     1:     // If this class ever implements nsIWritableVariant, take special care with
     1:     // the case when mJSVal is JSVAL_STRING, since we don't own the data in
     1:     // that case.
     1: 
     1:     // We #define and iid so that out module local code can use QI to detect
     1:     // if a given nsIVariant is in fact an XPCVariant.
     1:     NS_DECLARE_STATIC_IID_ACCESSOR(XPCVARIANT_IID)
     1: 
     1:     static XPCVariant* newVariant(XPCCallContext& ccx, jsval aJSVal);
     1: 
 37802:     /**
 62690:      * This getter clears the gray bit before handing out the jsval if the jsval
 62690:      * represents a JSObject. That means that the object is guaranteed to be
 62690:      * kept alive past the next CC.
 37802:      */
 62690:     jsval GetJSVal() const
 62690:         {if (!JSVAL_IS_PRIMITIVE(mJSVal))
 62690:              xpc_UnmarkGrayObject(JSVAL_TO_OBJECT(mJSVal));
 62690:          return mJSVal;}
 62690: 
 62690:     /**
 62690:      * This getter does not change the color of the jsval (if it represents a
 62690:      * JSObject) meaning that the value returned is not guaranteed to be kept
 62690:      * alive past the next CC.
 62690:      *
 62690:      * This should only be called if you are certain that the return value won't
 62690:      * be passed into a JS API function and that it won't be stored without
 62690:      * being rooted (or otherwise signaling the stored value to the CC).
 62690:      */
 62690:     jsval GetJSValPreserveColor() const {return mJSVal;}
     1: 
 31172:     XPCVariant(XPCCallContext& ccx, jsval aJSVal);
     1: 
     1:     /**
     1:      * Convert a variant into a jsval.
     1:      *
     1:      * @param ccx the context for the whole procedure
     1:      * @param variant the variant to convert
 41968:      * @param scope the default scope to put on the new JSObject's parent chain
     1:      * @param pErr [out] relevant error code, if any.
     1:      * @param pJSVal [out] the resulting jsval.
     1:      */
 31395:     static JSBool VariantDataToJS(XPCLazyCallContext& lccx,
     1:                                   nsIVariant* variant,
 62405:                                   nsresult* pErr, jsval* pJSVal);
     1: 
 88262:     bool IsPurple()
 88262:     {
 88262:         return mRefCnt.IsPurple();
 88262:     }
 88262: 
 88262:     void RemovePurple()
 88262:     {
 88262:         mRefCnt.RemovePurple();
 88262:     }
 88262: 
 88262:     void SetCCGeneration(PRUint32 aGen)
 88262:     {
 88262:         mCCGeneration = aGen;
 88262:     }
 88262: 
 88262:     PRUint32 CCGeneration() { return mCCGeneration; }
     1: protected:
  2072:     virtual ~XPCVariant() { }
     1: 
     1:     JSBool InitializeData(XPCCallContext& ccx);
     1: 
     1: protected:
     1:     nsDiscriminatedUnion mData;
     1:     jsval                mJSVal;
 88262:     bool                 mReturnRawObject : 1;
 88262:     PRUint32             mCCGeneration : 31;
  2072: };
  2072: 
  2072: NS_DEFINE_STATIC_IID_ACCESSOR(XPCVariant, XPCVARIANT_IID)
  2072: 
  2072: class XPCTraceableVariant: public XPCVariant,
  2072:                            public XPCRootSetElem
  2072: {
  2072: public:
 31172:     XPCTraceableVariant(XPCCallContext& ccx, jsval aJSVal)
 31172:         : XPCVariant(ccx, aJSVal)
  2072:     {
 31172:         ccx.GetRuntime()->AddVariantRoot(this);
  2072:     }
  2072: 
  2072:     virtual ~XPCTraceableVariant();
  2072: 
  2072:     void TraceJS(JSTracer* trc);
 98544:     static void GetTraceName(JSTracer* trc, char *buf, size_t bufsize);
     1: };
     1: 
     1: /***************************************************************************/
     1: 
     1: #define PRINCIPALHOLDER_IID \
     1: {0xbf109f49, 0xf94a, 0x43d8, {0x93, 0xdb, 0xe4, 0x66, 0x49, 0xc5, 0xd9, 0x7d}}
     1: 
     1: class PrincipalHolder : public nsIScriptObjectPrincipal
     1: {
     1: public:
     1:     NS_DECLARE_STATIC_IID_ACCESSOR(PRINCIPALHOLDER_IID)
     1: 
     1:     PrincipalHolder(nsIPrincipal *holdee)
     1:         : mHoldee(holdee)
     1:     {
     1:     }
     1:     virtual ~PrincipalHolder() { }
     1: 
     1:     NS_DECL_ISUPPORTS
     1: 
     1:     nsIPrincipal *GetPrincipal();
     1: 
     1: private:
     1:     nsCOMPtr<nsIPrincipal> mHoldee;
     1: };
     1: 
     1: NS_DEFINE_STATIC_IID_ACCESSOR(PrincipalHolder, PRINCIPALHOLDER_IID)
     1: 
     1: /***************************************************************************/
     1: // Utilities
     1: 
 10858: inline void *
 10858: xpc_GetJSPrivate(JSObject *obj)
 10858: {
 79734:     return js::GetObjectPrivate(obj);
 10858: }
 47410: 
 10858: 
     1: // Helper for creating a sandbox object to use for evaluating
     1: // untrusted code completely separated from all other code in the
     1: // system using xpc_EvalInSandbox(). Takes the JSContext on which to
     1: // do setup etc on, puts the sandbox object in *vp (which must be
     1: // rooted by the caller), and uses the principal that's either
     1: // directly passed in prinOrSop or indirectly as an
     1: // nsIScriptObjectPrincipal holding the principal. If no principal is
     1: // reachable through prinOrSop, a new null principal will be created
     1: // and used.
     1: nsresult
 55675: xpc_CreateSandboxObject(JSContext * cx, jsval * vp, nsISupports *prinOrSop,
 99153:                         JSObject *proto, bool preferXray, bool wantComponents,
 99153:                         const nsACString &sandboxName);
     1: // Helper for evaluating scripts in a sandbox object created with
     1: // xpc_CreateSandboxObject(). The caller is responsible of ensuring
     1: // that *rval doesn't get collected during the call or usage after the
     1: // call. This helper will use filename and lineNo for error reporting,
     1: // and if no filename is provided it will use the codebase from the
  3573: // principal and line number 1 as a fallback. if returnStringOnly is
  3573: // true, then the result in *rval, or the exception in cx->exception
  3573: // will be coerced into strings. If an exception is thrown converting
  3573: // an exception to a string, evalInSandbox will return an NS_ERROR_*
  3573: // result, and cx->exception will be empty.
     1: nsresult
     1: xpc_EvalInSandbox(JSContext *cx, JSObject *sandbox, const nsAString& source,
  3573:                   const char *filename, PRInt32 lineNo,
 79445:                   JSVersion jsVersion, bool returnStringOnly, jsval *rval);
     1: 
     1: /***************************************************************************/
     1: // Inlined utilities.
     1: 
     1: inline JSBool
 48470: xpc_ForcePropertyResolve(JSContext* cx, JSObject* obj, jsid id);
     1: 
 33352: inline jsid
 91237: GetRTIdByIndex(JSContext *cx, unsigned index);
 33352: 
  7987: // Wrapper for JS_NewObject to mark the new object as system when parent is
 77343: // also a system object. If uniqueType is specified then a new type object will
 77343: // be created which is used only by the result, so that its property types
 77343: // will be tracked precisely.
  7987: inline JSObject*
  7987: xpc_NewSystemInheritingJSObject(JSContext *cx, JSClass *clasp, JSObject *proto,
 77343:                                 bool uniqueType, JSObject *parent);
  7987: 
     1: nsISupports *
     1: XPC_GetIdentityObject(JSContext *cx, JSObject *obj);
     1: 
 55675: namespace xpc {
 55675: 
 99154: class CompartmentPrivate
 55675: {
 99154: public:
 98908:     typedef nsDataHashtable<nsPtrHashKey<XPCWrappedNative>, JSObject *> ExpandoMap;
 98908:     typedef nsTHashtable<nsPtrHashKey<JSObject> > DOMExpandoMap;
 98908: 
 97462:     CompartmentPrivate(bool wantXrays)
 97462:         : wantXrays(wantXrays)
 55675:     {
 73499:         MOZ_COUNT_CTOR(xpc::CompartmentPrivate);
 55675:     }
 58722: 
 58722:     ~CompartmentPrivate();
 58722: 
 56473:     bool wantXrays;
 80341:     nsAutoPtr<JSObject2JSObjectMap> waiverWrapperMap;
 61214:     // NB: we don't want this map to hold a strong reference to the wrapper.
 98908:     nsAutoPtr<ExpandoMap> expandoMap;
 98908:     nsAutoPtr<DOMExpandoMap> domExpandoMap;
 61214: 
 61214:     bool RegisterExpandoObject(XPCWrappedNative *wn, JSObject *expando) {
 61214:         if (!expandoMap) {
 98908:             expandoMap = new ExpandoMap();
 98908:             expandoMap->Init(8);
 80341:         }
 82054:         wn->SetHasExpandoObject();
 98908:         return expandoMap->Put(wn, expando, mozilla::fallible_t());
 61214:     }
 61214: 
 62809:     /**
 62809:      * This lookup does not change the color of the JSObject meaning that the
 62809:      * object returned is not guaranteed to be kept alive past the next CC.
 62809:      *
 62809:      * This should only be called if you are certain that the return value won't
 62809:      * be passed into a JS API function and that it won't be stored without
 62809:      * being rooted (or otherwise signaling the stored value to the CC).
 62809:      */
 62809:     JSObject *LookupExpandoObjectPreserveColor(XPCWrappedNative *wn) {
 62809:         return expandoMap ? expandoMap->Get(wn) : nsnull;
 62809:     }
 62809: 
 62809:     /**
 62809:      * This lookup clears the gray bit before handing out the JSObject which
 62809:      * means that the object is guaranteed to be kept alive past the next CC.
 62809:      */
 61214:     JSObject *LookupExpandoObject(XPCWrappedNative *wn) {
 62809:         JSObject *obj = LookupExpandoObjectPreserveColor(wn);
 97588:         return xpc_UnmarkGrayObject(obj);
 61214:     }
 80074: 
 80074:     bool RegisterDOMExpandoObject(JSObject *expando) {
 80074:         if (!domExpandoMap) {
 98908:             domExpandoMap = new DOMExpandoMap();
 98908:             domExpandoMap->Init(8);
 80074:         }
 98908:         return domExpandoMap->PutEntry(expando, mozilla::fallible_t());
 80074:     }
 80074:     void RemoveDOMExpandoObject(JSObject *expando) {
 80074:         if (domExpandoMap)
 80074:             domExpandoMap->RemoveEntry(expando);
 80074:     }
 99154: 
 99154:     const nsACString& GetLocation() {
 99154:         if (locationURI) {
 99154:             if (NS_FAILED(locationURI->GetSpec(location)))
 99154:                 location = NS_LITERAL_CSTRING("<unknown location>");
 99154:             locationURI = nsnull;
 99154:         }
 99154:         return location;
 99154:     }
 99154:     void SetLocation(const nsACString& aLocation) {
 99154:         if (aLocation.IsEmpty())
 99154:             return;
 99154:         if (!location.IsEmpty() || locationURI)
 99154:             return;
 99154:         location = aLocation;
 99154:     }
 99154:     void SetLocation(nsIURI *aLocationURI) {
 99154:         if (!aLocationURI)
 99154:             return;
 99154:         if (!location.IsEmpty() || locationURI)
 99154:             return;
 99154:         locationURI = aLocationURI;
 99154:     }
 99154: 
 99154: private:
 99154:     nsCString location;
 99154:     nsCOMPtr<nsIURI> locationURI;
 55675: };
 55675: 
 99328: inline CompartmentPrivate*
 99328: GetCompartmentPrivate(JSCompartment *compartment)
 99328: {
 99328:     MOZ_ASSERT(compartment);
 99328:     void *priv = JS_GetCompartmentPrivate(compartment);
 99328:     return static_cast<CompartmentPrivate*>(priv);
 99328: }
 99328: 
 99328: inline CompartmentPrivate*
 99328: GetCompartmentPrivate(JSObject *object)
 99328: {
 99328:     MOZ_ASSERT(object);
 99328:     JSCompartment *compartment = js::GetObjectCompartment(object);
 99328: 
 99328:     MOZ_ASSERT(compartment);
 99328:     return GetCompartmentPrivate(compartment);
 99328: }
 99328: 
 55675: }
 55675: 
     1: /***************************************************************************/
     1: // Inlines use the above - include last.
     1: 
 80384: #include "XPCInlines.h"
     1: 
     1: /***************************************************************************/
     1: // Maps have inlines that use the above - include last.
     1: 
 80384: #include "XPCMaps.h"
     1: 
     1: /***************************************************************************/
     1: 
     1: #endif /* xpcprivate_h___ */
