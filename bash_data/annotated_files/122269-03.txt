 48320: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 48320:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 48320: 
 48320: #ifndef imgStatusTracker_h__
 48320: #define imgStatusTracker_h__
 48320: 
 48320: class imgIContainer;
 48320: class imgRequest;
 48320: class imgRequestProxy;
 48321: class imgStatusNotifyRunnable;
 49699: class imgRequestNotifyRunnable;
118748: class imgStatusTracker;
 61036: struct nsIntRect;
 50554: namespace mozilla {
 87852: namespace image {
 50554: class Image;
 87852: } // namespace image
 50554: } // namespace mozilla
 50554: 
 48320: 
 49699: #include "nsCOMPtr.h"
118748: #include "nsAutoPtr.h"
118741: #include "nsTObserverArray.h"
 49699: #include "nsIRunnable.h"
 48320: #include "nscore.h"
118748: #include "nsWeakReference.h"
118748: #include "imgIDecoderObserver.h"
 48320: 
 48320: enum {
119700:   stateRequestStarted    = 1u << 0,
119700:   stateHasSize           = 1u << 1,
119700:   stateDecodeStopped     = 1u << 3,
119700:   stateFrameStopped      = 1u << 4,
119700:   stateRequestStopped    = 1u << 5,
119700:   stateBlockingOnload    = 1u << 6
 48320: };
 48320: 
118748: class imgStatusTrackerObserver : public imgIDecoderObserver,
118748:                                  public nsSupportsWeakReference
118748: {
118748: public:
118748:   NS_DECL_ISUPPORTS
118748:   NS_DECL_IMGIDECODEROBSERVER
118748:   NS_DECL_IMGICONTAINEROBSERVER
118748: 
118748:   imgStatusTrackerObserver(imgStatusTracker* aTracker)
118748:   : mTracker(aTracker) {}
118748: 
118748:   virtual ~imgStatusTrackerObserver() {}
118748: 
118748:   void SetTracker(imgStatusTracker* aTracker) {
118748:     mTracker = aTracker;
118748:   }
118748: 
118748: private:
118748:   imgStatusTracker* mTracker;
118748: };
118748: 
 48320: /*
 48320:  * The image status tracker is a class that encapsulates all the loading and
 50546:  * decoding status about an Image, and makes it possible to send notifications
 50546:  * to imgRequestProxys, both synchronously (i.e., the status now) and
 50546:  * asynchronously (the status later).
 48321:  *
 48321:  * When a new proxy needs to be notified of the current state of an image, call
 48321:  * the Notify() method on this class with the relevant proxy as its argument,
 48321:  * and the notifications will be replayed to the proxy asynchronously.
 48320:  */
 48320: 
 48320: class imgStatusTracker
 48320: {
 48320: public:
 48320:   // aImage is the image that this status tracker will pass to the
 48321:   // imgRequestProxys in SyncNotify() and EmulateRequestFinished(), and must be
 48320:   // alive as long as this instance is, because we hold a weak reference to it.
118744:   imgStatusTracker(mozilla::image::Image* aImage, imgRequest* aRequest);
 49699:   imgStatusTracker(const imgStatusTracker& aOther);
 48320: 
 51296:   // Image-setter, for imgStatusTrackers created by imgRequest::Init, which
 51296:   // are created before their Image is created.  This method should only
 51296:   // be called once, and only on an imgStatusTracker that was initialized
 51296:   // without an image.
 87852:   void SetImage(mozilla::image::Image* aImage);
 51296: 
 48321:   // Schedule an asynchronous "replaying" of all the notifications that would
 48321:   // have to happen to put us in the current state.
 48321:   // We will also take note of any notifications that happen between the time
 48321:   // Notify() is called and when we call SyncNotify on |proxy|, and replay them
 48321:   // as well.
 48321:   void Notify(imgRequest* request, imgRequestProxy* proxy);
 48321: 
 48321:   // Schedule an asynchronous "replaying" of all the notifications that would
 48321:   // have to happen to put us in the state we are in right now.
 48321:   // Unlike Notify(), does *not* take into account future notifications.
 48321:   // This is only useful if you do not have an imgRequest, e.g., if you are a
 48321:   // static request returned from imgIRequest::GetStaticRequest().
 48321:   void NotifyCurrentState(imgRequestProxy* proxy);
 48321: 
 48320:   // "Replay" all of the notifications that would have to happen to put us in
 48320:   // the state we're currently in.
 48321:   // Only use this if you're already servicing an asynchronous call (e.g.
 48321:   // OnStartRequest).
 48321:   void SyncNotify(imgRequestProxy* proxy);
 48320: 
118608:   // Send some notifications that would be necessary to make |proxy| believe
118608:   // the request is finished downloading and decoding.  We only send
118608:   // OnStopRequest and UnblockOnload, and only if necessary.
118608:   void EmulateRequestFinished(imgRequestProxy* proxy, nsresult aStatus);
 48320: 
118741:   // We manage a set of consumers that are using an image and thus concerned
118741:   // with its status. Weak pointers.
118741:   void AddConsumer(imgRequestProxy* aConsumer);
118741:   bool RemoveConsumer(imgRequestProxy* aConsumer, nsresult aStatus);
118741:   size_t ConsumerCount() const { return mConsumers.Length(); };
118741: 
118741:   // This is intentionally non-general because its sole purpose is to support an
118741:   // some obscure network priority logic in imgRequest. That stuff could probably
118741:   // be improved, but it's too scary to mess with at the moment.
118741:   bool FirstConsumerIs(imgRequestProxy* aConsumer) {
118741:     return mConsumers.SafeElementAt(0, nullptr) == aConsumer;
118741:   }
118741: 
118741:   void AdoptConsumers(imgStatusTracker* aTracker) { mConsumers = aTracker->mConsumers; }
118741: 
 48320:   // Returns whether we are in the process of loading; that is, whether we have
 48320:   // not received OnStopRequest.
 79445:   bool IsLoading() const;
 48320: 
 48320:   // Get the current image status (as in imgIRequest).
108991:   uint32_t GetImageStatus() const;
 48320: 
 48320:   // Following are all the notification methods. You must call the Record
 48320:   // variant on this status tracker, then call the Send variant for each proxy
 48320:   // you want to notify.
 48320: 
 48320:   // Call when the request is being cancelled.
 48320:   void RecordCancel();
 48320: 
 48320:   // Shorthand for recording all the load notifications: StartRequest,
 48320:   // StartContainer, StopRequest.
 48320:   void RecordLoaded();
 48320: 
 48320:   // Shorthand for recording all the decode notifications: StartDecode,
118752:   // StartFrame, DataAvailable, StopFrame, StopDecode.
 48320:   void RecordDecoded();
 48320: 
 48320:   /* non-virtual imgIDecoderObserver methods */
 48320:   void RecordStartContainer(imgIContainer* aContainer);
118757:   void SendStartContainer(imgRequestProxy* aProxy);
118757:   void RecordDataAvailable();
118757:   void SendDataAvailable(imgRequestProxy* aProxy, const nsIntRect* aRect);
118757:   void RecordStopFrame();
118757:   void SendStopFrame(imgRequestProxy* aProxy);
118752:   void RecordStopDecode(nsresult statusg);
118752:   void SendStopDecode(imgRequestProxy* aProxy, nsresult aStatus);
 48320:   void RecordDiscard();
 48320:   void SendDiscard(imgRequestProxy* aProxy);
 82096:   void RecordImageIsAnimated();
 82096:   void SendImageIsAnimated(imgRequestProxy *aProxy);
 48320: 
 48320:   /* non-virtual imgIContainerObserver methods */
118757:   void RecordFrameChanged(const nsIntRect* aDirtyRect);
118757:   void SendFrameChanged(imgRequestProxy* aProxy, const nsIntRect* aDirtyRect);
 48320: 
 48320:   /* non-virtual sort-of-nsIRequestObserver methods */
 48320:   void RecordStartRequest();
 48320:   void SendStartRequest(imgRequestProxy* aProxy);
 79445:   void RecordStopRequest(bool aLastPart, nsresult aStatus);
 79445:   void SendStopRequest(imgRequestProxy* aProxy, bool aLastPart, nsresult aStatus);
 48320: 
118749:   void OnStartRequest();
118749:   void OnDataAvailable();
118749:   void OnStopRequest(bool aLastPart, nsresult aStatus);
118749: 
108324:   /* non-virtual imgIOnloadBlocker methods */
108324:   // NB: If UnblockOnload is sent, and then we are asked to replay the
108324:   // notifications, we will not send a BlockOnload/UnblockOnload pair.  This
108324:   // is different from all the other notifications.
108324:   void RecordBlockOnload();
108324:   void SendBlockOnload(imgRequestProxy* aProxy);
108324:   void RecordUnblockOnload();
108324:   void SendUnblockOnload(imgRequestProxy* aProxy);
108324: 
118748:   void MaybeUnblockOnload();
118748: 
122269:   // Null out any reference to an associated image request
122269:   void ClearRequest();
122269: 
118744:   // Weak pointer getters - no AddRefs.
118744:   inline mozilla::image::Image* GetImage() const { return mImage; };
118744:   inline imgRequest* GetRequest() const { return mRequest; };
118744: 
118748:   inline imgIDecoderObserver* GetDecoderObserver() { return mTrackerObserver.get(); }
118748: 
 48320: private:
 48321:   friend class imgStatusNotifyRunnable;
 49699:   friend class imgRequestNotifyRunnable;
118748:   friend class imgStatusTrackerObserver;
 49699: 
 49699:   nsCOMPtr<nsIRunnable> mRequestRunnable;
 48321: 
118744:   // Weak pointers to the image and request. The request owns the image, and
118744:   // the image (or the request, if there's no image) owns the status tracker.
 87852:   mozilla::image::Image* mImage;
118744:   imgRequest* mRequest;
108991:   uint32_t mState;
108991:   uint32_t mImageStatus;
 79445:   bool mHadLastPart;
118748:   bool mBlockingOnload;
118741: 
118741:   // List of proxies attached to the image. Each proxy represents a consumer
118741:   // using the image.
118741:   nsTObserverArray<imgRequestProxy*> mConsumers;
118748: 
118748:   nsRefPtr<imgStatusTrackerObserver> mTrackerObserver;
 48320: };
 48320: 
 48320: #endif
