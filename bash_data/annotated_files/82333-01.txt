47172: /* ***** BEGIN LICENSE BLOCK *****
47172:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
47172:  *
47172:  * The contents of this file are subject to the Mozilla Public License Version
47172:  * 1.1 (the "License"); you may not use this file except in compliance with
47172:  * the License. You may obtain a copy of the License at
47172:  * http://www.mozilla.org/MPL/
47172:  *
47172:  * Software distributed under the License is distributed on an "AS IS" basis,
47172:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
47172:  * for the specific language governing rights and limitations under the
47172:  * License.
47172:  *
47172:  * The Original Code is mozilla.org code.
47172:  *
47172:  * The Initial Developer of the Original Code is
47172:  * Mozilla Foundation.
47172:  * Portions created by the Initial Developer are Copyright (C) 2010
47172:  * the Initial Developer. All Rights Reserved.
47172:  *
47172:  * Contributor(s):
47172:  *  Alexander Surkov <surkov.alexander@gmail.com> (original author)
47172:  *
47172:  * Alternatively, the contents of this file may be used under the terms of
47172:  * either the GNU General Public License Version 2 or later (the "GPL"), or
47172:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
47172:  * in which case the provisions of the GPL or the LGPL are applicable instead
47172:  * of those above. If you wish to allow use of your version of this file only
47172:  * under the terms of either the GPL or the LGPL, and not to allow others to
47172:  * use your version of this file under the terms of the MPL, indicate your
47172:  * decision by deleting the provisions above and replace them with the notice
47172:  * and other provisions required by the GPL or the LGPL. If you do not delete
47172:  * the provisions above, a recipient may use your version of this file under
47172:  * the terms of any one of the MPL, the GPL or the LGPL.
47172:  *
47172:  * ***** END LICENSE BLOCK ***** */
47172: 
47172: #include "AccGroupInfo.h"
47172: 
67790: #include "States.h"
67790: 
74618: using namespace mozilla::a11y;
74618: 
47172: AccGroupInfo::AccGroupInfo(nsAccessible* aItem, PRUint32 aRole) :
47172:   mPosInSet(0), mSetSize(0), mParent(nsnull)
47172: {
47803:   MOZ_COUNT_CTOR(AccGroupInfo);
74545:   nsAccessible* parent = aItem->Parent();
47172:   if (!parent)
47172:     return;
47172: 
72476:   PRInt32 indexInParent = aItem->IndexInParent();
82333:   PRInt32 siblingCount = parent->GetChildCount();
82333:   if (siblingCount < indexInParent) {
82333:     NS_ERROR("Wrong index in parent! Tree invalidation problem.");
82333:     return;
82333:   }
82333: 
47172:   PRInt32 level = nsAccUtils::GetARIAOrDefaultLevel(aItem);
47172: 
47172:   // Compute position in set.
47172:   mPosInSet = 1;
47172:   for (PRInt32 idx = indexInParent - 1; idx >=0 ; idx--) {
47172:     nsAccessible* sibling = parent->GetChildAt(idx);
52089:     PRUint32 siblingRole = sibling->Role();
47172: 
47172:     // If the sibling is separator then the group is ended.
47172:     if (siblingRole == nsIAccessibleRole::ROLE_SEPARATOR)
47172:       break;
47172: 
47172:     // If sibling is not visible and hasn't the same base role.
67790:     if (BaseRole(siblingRole) != aRole || sibling->State() & states::INVISIBLE)
47172:       continue;
47172: 
47172:     // Check if it's hierarchical flatten structure, i.e. if the sibling
47172:     // level is lesser than this one then group is ended, if the sibling level
47172:     // is greater than this one then the group is split by some child elements
47172:     // (group will be continued).
47172:     PRInt32 siblingLevel = nsAccUtils::GetARIAOrDefaultLevel(sibling);
47172:     if (siblingLevel < level) {
47172:       mParent = sibling;
47172:       break;
47172:     }
47172: 
47172:     // Skip subset.
47172:     if (siblingLevel > level)
47172:       continue;
47172: 
47172:     // If the previous item in the group has calculated group information then
47172:     // build group information for this item based on found one.
47172:     if (sibling->mGroupInfo) {
47172:       mPosInSet += sibling->mGroupInfo->mPosInSet;
47172:       mParent = sibling->mGroupInfo->mParent;
47172:       mSetSize = sibling->mGroupInfo->mSetSize;
47172:       return;
47172:     }
47172: 
47172:     mPosInSet++;
47172:   }
47172: 
47172:   // Compute set size.
47172:   mSetSize = mPosInSet;
47172: 
47172:   for (PRInt32 idx = indexInParent + 1; idx < siblingCount; idx++) {
47172:     nsAccessible* sibling = parent->GetChildAt(idx);
47172: 
52089:     PRUint32 siblingRole = sibling->Role();
47172: 
47172:     // If the sibling is separator then the group is ended.
47172:     if (siblingRole == nsIAccessibleRole::ROLE_SEPARATOR)
47172:       break;
47172: 
47172:     // If sibling is visible and has the same base role
67790:     if (BaseRole(siblingRole) != aRole || sibling->State() & states::INVISIBLE)
47172:       continue;
47172: 
47172:     // and check if it's hierarchical flatten structure.
47172:     PRInt32 siblingLevel = nsAccUtils::GetARIAOrDefaultLevel(sibling);
47172:     if (siblingLevel < level)
47172:       break;
47172: 
47172:     // Skip subset.
47172:     if (siblingLevel > level)
47172:       continue;
47172: 
47172:     // If the next item in the group has calculated group information then
47172:     // build group information for this item based on found one.
47172:     if (sibling->mGroupInfo) {
47172:       mParent = sibling->mGroupInfo->mParent;
47172:       mSetSize = sibling->mGroupInfo->mSetSize;
47172:       return;
47172:     }
47172: 
47172:     mSetSize++;
47172:   }
47172: 
47172:   if (mParent)
47172:     return;
47172: 
52089:   PRUint32 parentRole = parent->Role();
74780:   if (IsConceptualParent(aRole, parentRole))
74780:     mParent = parent;
47172: 
74780:   // In the case of ARIA tree (not ARIA treegrid) a tree can be arranged by
74780:   // using ARIA groups to organize levels. In this case the parent of the tree
74780:   // item will be a group and the previous treeitem of that should be the tree
74780:   // item parent.
74780:   if (parentRole != nsIAccessibleRole::ROLE_GROUPING ||
74780:       aRole != nsIAccessibleRole::ROLE_OUTLINEITEM)
47172:     return;
47172: 
71380:   nsAccessible* parentPrevSibling = parent->PrevSibling();
52089:   if (!parentPrevSibling)
52089:     return;
52089: 
52089:   PRUint32 parentPrevSiblingRole = parentPrevSibling->Role();
47172:   if (parentPrevSiblingRole == nsIAccessibleRole::ROLE_TEXT_LEAF) {
47172:     // XXX Sometimes an empty text accessible is in the hierarchy here,
47172:     // although the text does not appear to be rendered, GetRenderedText()
47172:     // says that it is so we need to skip past it to find the true
47172:     // previous sibling.
71380:     parentPrevSibling = parentPrevSibling->PrevSibling();
52089:     if (parentPrevSibling)
52089:       parentPrevSiblingRole = parentPrevSibling->Role();
47172:   }
47172: 
47172:   // Previous sibling of parent group is a tree item, this is the
47172:   // conceptual tree item parent.
47172:   if (parentPrevSiblingRole == nsIAccessibleRole::ROLE_OUTLINEITEM)
47172:     mParent = parentPrevSibling;
47172: }
74780: 
74780: bool
74780: AccGroupInfo::IsConceptualParent(PRUint32 aRole, PRUint32 aParentRole)
74780: {
74780:   if (aParentRole == nsIAccessibleRole::ROLE_OUTLINE &&
74780:       aRole == nsIAccessibleRole::ROLE_OUTLINEITEM)
74780:     return true;
74780:   if ((aParentRole == nsIAccessibleRole::ROLE_TABLE ||
74780:        aParentRole == nsIAccessibleRole::ROLE_TREE_TABLE) &&
74780:       aRole == nsIAccessibleRole::ROLE_ROW)
74780:     return true;
74780:   if (aParentRole == nsIAccessibleRole::ROLE_ROW &&
74780:       (aRole == nsIAccessibleRole::ROLE_CELL ||
74780:        aRole == nsIAccessibleRole::ROLE_GRID_CELL))
74780:     return true;
74780:   if (aParentRole == nsIAccessibleRole::ROLE_LIST &&
74780:       aRole == nsIAccessibleRole::ROLE_LISTITEM)
74780:     return true;
74780:   if (aParentRole == nsIAccessibleRole::ROLE_COMBOBOX_LIST &&
74780:       aRole == nsIAccessibleRole::ROLE_COMBOBOX_OPTION)
74780:     return true;
74780:   if (aParentRole == nsIAccessibleRole::ROLE_LISTBOX &&
74780:       aRole == nsIAccessibleRole::ROLE_OPTION)
74780:     return true;
74780:   if (aParentRole == nsIAccessibleRole::ROLE_PAGETABLIST &&
74780:       aRole == nsIAccessibleRole::ROLE_PAGETAB)
74780:     return true;
74780:   if ((aParentRole == nsIAccessibleRole::ROLE_POPUP_MENU ||
74780:        aParentRole == nsIAccessibleRole::ROLE_MENUPOPUP) &&
74780:       aRole == nsIAccessibleRole::ROLE_MENUITEM)
74780:     return true;
74780: 
74780:   return false;
74780: }
