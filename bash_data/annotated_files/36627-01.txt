 4042: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 4042: /* vim: set ts=2 sw=2 et tw=78: */
 4042: /* ***** BEGIN LICENSE BLOCK *****
 4042:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 4042:  *
 4042:  * The contents of this file are subject to the Mozilla Public License Version
 4042:  * 1.1 (the "License"); you may not use this file except in compliance with
 4042:  * the License. You may obtain a copy of the License at
 4042:  * http://www.mozilla.org/MPL/
 4042:  *
 4042:  * Software distributed under the License is distributed on an "AS IS" basis,
 4042:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 4042:  * for the specific language governing rights and limitations under the
 4042:  * License.
 4042:  *
 4042:  * The Original Code is mozilla.org code.
 4042:  *
 4042:  * The Initial Developer of the Original Code is
 4042:  * The Mozilla Foundation.
 4042:  * Portions created by the Initial Developer are Copyright (C) 2006
 4042:  * the Initial Developer. All Rights Reserved.
 4042:  *
 4042:  * Contributor(s):
 4042:  *   Blake Kaplan <mrbkap@gmail.com> (original author)
 4042:  *
 4042:  * Alternatively, the contents of this file may be used under the terms of
 4042:  * either the GNU General Public License Version 2 or later (the "GPL"), or
 4042:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 4042:  * in which case the provisions of the GPL or the LGPL are applicable instead
 4042:  * of those above. If you wish to allow use of your version of this file only
 4042:  * under the terms of either the GPL or the LGPL, and not to allow others to
 4042:  * use your version of this file under the terms of the MPL, indicate your
 4042:  * decision by deleting the provisions above and replace them with the notice
 4042:  * and other provisions required by the GPL or the LGPL. If you do not delete
 4042:  * the provisions above, a recipient may use your version of this file under
 4042:  * the terms of any one of the MPL, the GPL or the LGPL.
 4042:  *
 4042:  * ***** END LICENSE BLOCK ***** */
 4042: 
 4042: #include "xpcprivate.h"
 4042: #include "nsDOMError.h"
 4042: #include "jsdbgapi.h"
 6464: #include "jscntxt.h"  // For JSAutoTempValueRooter.
 4042: #include "XPCWrapper.h"
 4042: #include "nsIDOMWindow.h"
 4042: #include "nsIDOMWindowCollection.h"
 4042: 
 4042: // This file implements a wrapper around objects that allows them to be
 4042: // accessed safely from across origins.
 4042: 
18907: static JSBool
 4042: XPC_XOW_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 4042: 
18907: static JSBool
 4042: XPC_XOW_DelProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 4042: 
18907: static JSBool
 4042: XPC_XOW_GetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 4042: 
18907: static JSBool
 4042: XPC_XOW_SetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 4042: 
18907: static JSBool
 4042: XPC_XOW_Enumerate(JSContext *cx, JSObject *obj);
 4042: 
18907: static JSBool
 4042: XPC_XOW_NewResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
 4042:                    JSObject **objp);
 4042: 
18907: static JSBool
 4042: XPC_XOW_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp);
 4042: 
18907: static void
 4042: XPC_XOW_Finalize(JSContext *cx, JSObject *obj);
 4042: 
18907: static JSBool
 4042: XPC_XOW_CheckAccess(JSContext *cx, JSObject *obj, jsval id, JSAccessMode mode,
 4042:                     jsval *vp);
 4042: 
18907: static JSBool
 4042: XPC_XOW_Call(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 4042: 
18907: static JSBool
 4042: XPC_XOW_Construct(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
 4042:                   jsval *rval);
 4042: 
18907: static JSBool
 9428: XPC_XOW_HasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp);
 9428: 
18907: static JSBool
 4042: XPC_XOW_Equality(JSContext *cx, JSObject *obj, jsval v, JSBool *bp);
 4042: 
18907: static JSObject *
 6464: XPC_XOW_Iterator(JSContext *cx, JSObject *obj, JSBool keysonly);
 6464: 
18907: static JSObject *
 9560: XPC_XOW_WrappedObject(JSContext *cx, JSObject *obj);
 9560: 
36309: // The slot that we stick our scope into.
36309: // This is used in the finalizer to see if we actually need to remove
36309: // ourselves from our scope's map. Because we cannot outlive our scope
36309: // (the parent link ensures this), we know that, when we're being
36309: // finalized, either our scope is still alive (i.e. we became garbage
36309: // due to no more references) or it is being garbage collected right now.
36309: // Therefore, we can look in gDyingScopes, and if our scope is there,
36309: // then the map is about to be destroyed anyway, so we don't need to
36309: // do anything.
36309: static const int XPC_XOW_ScopeSlot = XPCWrapper::sNumSlots;
36309: static const int sUXPCObjectSlot = XPCWrapper::sNumSlots + 1;
36309: 
36309: using namespace XPCWrapper;
36309: 
36309: // Throws an exception on context |cx|.
36309: static inline
36309: JSBool
36309: ThrowException(nsresult ex, JSContext *cx)
36309: {
36309:   XPCWrapper::DoThrowException(ex, cx);
36309: 
36309:   return JS_FALSE;
36309: }
36309: 
36309: // Get the (possibly non-existant) XOW off of an object
36309: static inline
36309: JSObject *
36309: GetWrapper(JSObject *obj)
36309: {
36309:   while (STOBJ_GET_CLASS(obj) != &XPCCrossOriginWrapper::XOWClass.base) {
36309:     obj = STOBJ_GET_PROTO(obj);
36309:     if (!obj) {
36309:       break;
36309:     }
36309:   }
36309: 
36309:   return obj;
36309: }
36309: 
36309: static inline
36309: JSObject *
36309: GetWrappedObject(JSContext *cx, JSObject *wrapper)
36309: {
36309:   return XPCWrapper::UnwrapGeneric(cx, &XPCCrossOriginWrapper::XOWClass, wrapper);
36309: }
36309: 
36309: static JSBool
36309: XPC_XOW_FunctionWrapper(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
36309:                         jsval *rval);
36309: 
36309: // This flag is set on objects that were created for UniversalXPConnect-
36309: // enabled code.
36309: static const PRUint32 FLAG_IS_UXPC_OBJECT = XPCWrapper::LAST_FLAG << 1;
36309: 
36309: namespace XPCCrossOriginWrapper {
36309: 
36309: JSExtendedClass XOWClass = {
 4042:   // JSClass (JSExtendedClass.base) initialization
 4042:   { "XPCCrossOriginWrapper",
 4042:     JSCLASS_NEW_RESOLVE | JSCLASS_IS_EXTENDED |
34220:     JSCLASS_HAS_RESERVED_SLOTS(XPCWrapper::sNumSlots + 2),
 4042:     XPC_XOW_AddProperty, XPC_XOW_DelProperty,
 4042:     XPC_XOW_GetProperty, XPC_XOW_SetProperty,
 4042:     XPC_XOW_Enumerate,   (JSResolveOp)XPC_XOW_NewResolve,
 4042:     XPC_XOW_Convert,     XPC_XOW_Finalize,
 4042:     nsnull,              XPC_XOW_CheckAccess,
 4042:     XPC_XOW_Call,        XPC_XOW_Construct,
 9428:     nsnull,              XPC_XOW_HasInstance,
 4042:     nsnull,              nsnull
 4042:   },
 6464: 
 4042:   // JSExtendedClass initialization
 6464:   XPC_XOW_Equality,
 6464:   nsnull,             // outerObject
 6464:   nsnull,             // innerObject
 6464:   XPC_XOW_Iterator,
 9560:   XPC_XOW_WrappedObject,
 6464:   JSCLASS_NO_RESERVED_MEMBERS
 4042: };
 4042: 
 4042: JSBool
36309: WrapperMoved(JSContext *cx, XPCWrappedNative *innerObj,
 9848:                      XPCWrappedNativeScope *newScope)
 9848: {
 9848:   typedef WrappedNative2WrapperMap::Link Link;
20312:   XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
 9848:   WrappedNative2WrapperMap *map = innerObj->GetScope()->GetWrapperMap();
 9848:   Link *link;
 9848: 
 9848:   { // Scoped lock
 9848:     XPCAutoLock al(rt->GetMapLock());
 9848:     link = map->FindLink(innerObj->GetFlatJSObject());
 9848:   }
 9848: 
 9848:   if (!link) {
 9848:     // No link here means that there were no XOWs for this object.
 9848:     return JS_TRUE;
 9848:   }
 9848: 
 9848:   JSObject *xow = link->obj;
 9848: 
 9848:   { // Scoped lock.
 9848:     XPCAutoLock al(rt->GetMapLock());
 9848:     if (!newScope->GetWrapperMap()->AddLink(innerObj->GetFlatJSObject(), link))
 9848:       return JS_FALSE;
 9848:     map->Remove(innerObj->GetFlatJSObject());
 9848:   }
 9848: 
 9848:   if (!xow) {
 9848:     // Nothing else to do.
 9848:     return JS_TRUE;
 9848:   }
 9848: 
11430:   return JS_SetReservedSlot(cx, xow, XPC_XOW_ScopeSlot,
 9848:                             PRIVATE_TO_JSVAL(newScope)) &&
 9848:          JS_SetParent(cx, xow, newScope->GetGlobalJSObject());
 9848: }
 9848: 
13269: // Returns whether the currently executing code is allowed to access
13269: // the wrapper.  Uses nsIPrincipal::Subsumes.
 4042: // |cx| must be the top context on the context stack.
13269: // If the subject is allowed to access the object returns NS_OK. If not,
 4042: // returns NS_ERROR_DOM_PROP_ACCESS_DENIED, returns another error code on
 4042: // failure.
 4042: nsresult
34220: CanAccessWrapper(JSContext *cx, JSObject *wrappedObj, JSBool *privilegeEnabled)
 4042: {
34220:   // TODO bug 508928: Refactor this with the XOW security checking code.
 4042:   // Get the subject principal from the execution stack.
11024:   nsIScriptSecurityManager *ssm = XPCWrapper::GetSecurityManager();
 4042:   if (!ssm) {
 4042:     ThrowException(NS_ERROR_NOT_INITIALIZED, cx);
 4042:     return NS_ERROR_NOT_INITIALIZED;
 4042:   }
 4042: 
20761:   JSStackFrame *fp = nsnull;
20761:   nsIPrincipal *subjectPrin = ssm->GetCxSubjectPrincipalAndFrame(cx, &fp);
 4042: 
 4042:   if (!subjectPrin) {
 4042:     ThrowException(NS_ERROR_FAILURE, cx);
 4042:     return NS_ERROR_FAILURE;
 4042:   }
 4042: 
 4042:   PRBool isSystem = PR_FALSE;
 9825:   nsresult rv = ssm->IsSystemPrincipal(subjectPrin, &isSystem);
 4042:   NS_ENSURE_SUCCESS(rv, rv);
 4042: 
34220:   if (privilegeEnabled) {
34220:     *privilegeEnabled = JS_FALSE;
34220:   }
34220: 
 4042:   // If we somehow end up being called from chrome, just allow full access.
 4042:   // This can happen from components with xpcnativewrappers=no.
13269:   // Note that this is just an optimization to avoid getting the
13269:   // object principal in this case, since Subsumes() would return true.
 4042:   if (isSystem) {
 4042:     return NS_OK;
 4042:   }
 4042: 
 9825:   nsCOMPtr<nsIPrincipal> objectPrin;
 4042:   rv = ssm->GetObjectPrincipal(cx, wrappedObj, getter_AddRefs(objectPrin));
 4042:   if (NS_FAILED(rv)) {
 4042:     return rv;
 4042:   }
 4042:   NS_ASSERTION(objectPrin, "Object didn't have principals?");
 4042: 
 4042:   // Micro-optimization: don't call into caps if we know the answer.
 4042:   if (subjectPrin == objectPrin) {
 4042:     return NS_OK;
 4042:   }
 4042: 
 4042:   // Now, we have our two principals, compare them!
13269:   PRBool subsumes;
13269:   rv = subjectPrin->Subsumes(objectPrin, &subsumes);
13269:   if (NS_SUCCEEDED(rv) && !subsumes) {
34220:     // We're about to fail, but make a last effort to see if
34220:     // UniversalXPConnect was enabled anywhere else on the stack.
34220:     rv = ssm->IsCapabilityEnabled("UniversalXPConnect", &isSystem);
34220:     if (NS_SUCCEEDED(rv) && isSystem) {
34220:       rv = NS_OK;
34220:       if (privilegeEnabled) {
34220:         *privilegeEnabled = JS_TRUE;
34220:       }
34220:     } else {
13269:       rv = NS_ERROR_DOM_PROP_ACCESS_DENIED;
13269:     }
34220:   }
13269:   return rv;
 4042: }
 4042: 
36309: JSBool
36309: WrapFunction(JSContext *cx, JSObject *outerObj, JSObject *funobj, jsval *rval)
36309: {
36309:   jsval funobjVal = OBJECT_TO_JSVAL(funobj);
36309:   JSFunction *wrappedFun =
36309:     reinterpret_cast<JSFunction *>(xpc_GetJSPrivate(funobj));
36309:   JSNative native = JS_GetFunctionNative(cx, wrappedFun);
36309:   if (!native || native == XPC_XOW_FunctionWrapper) {
36309:     *rval = funobjVal;
36309:     return JS_TRUE;
36309:   }
36309: 
36309:   JSFunction *funWrapper =
36309:     JS_NewFunction(cx, XPC_XOW_FunctionWrapper,
36309:                    JS_GetFunctionArity(wrappedFun), 0,
36309:                    JS_GetGlobalForObject(cx, outerObj),
36309:                    JS_GetFunctionName(wrappedFun));
36309:   if (!funWrapper) {
36309:     return JS_FALSE;
36309:   }
36309: 
36309:   JSObject *funWrapperObj = JS_GetFunctionObject(funWrapper);
36309:   *rval = OBJECT_TO_JSVAL(funWrapperObj);
36309: 
36309:   if (!JS_SetReservedSlot(cx, funWrapperObj, eWrappedFunctionSlot, funobjVal) ||
36309:       !JS_SetReservedSlot(cx, funWrapperObj, eAllAccessSlot, JSVAL_FALSE)) {
36309:     return JS_FALSE;
36309:   }
36309: 
36309:   return JS_TRUE;
36309: }
36309: 
36309: JSBool
36309: RewrapIfNeeded(JSContext *cx, JSObject *outerObj, jsval *vp)
36309: {
36309:   // Don't need to wrap primitive values.
36309:   if (JSVAL_IS_PRIMITIVE(*vp)) {
36309:     return JS_TRUE;
36309:   }
36309: 
36309:   JSObject *obj = JSVAL_TO_OBJECT(*vp);
36309: 
36309:   if (JS_ObjectIsFunction(cx, obj)) {
36309:     return WrapFunction(cx, outerObj, obj, vp);
36309:   }
36309: 
36309:   XPCWrappedNative *wn = nsnull;
36309:   if (STOBJ_GET_CLASS(obj) == &XOWClass.base &&
36309:       STOBJ_GET_PARENT(outerObj) != STOBJ_GET_PARENT(obj)) {
36309:     *vp = OBJECT_TO_JSVAL(GetWrappedObject(cx, obj));
36309:   } else if (!(wn = XPCWrappedNative::GetAndMorphWrappedNativeOfJSObject(cx, obj))) {
36309:     return JS_TRUE;
36309:   }
36309: 
36309:   return WrapObject(cx, JS_GetGlobalForObject(cx, outerObj), vp, wn);
36309: }
36309: 
36309: JSBool
36309: WrapObject(JSContext *cx, JSObject *parent, jsval *vp, XPCWrappedNative* wn)
36309: {
36309:   NS_ASSERTION(XPCPerThreadData::IsMainThread(cx),
36309:                "Can't do this off the main thread!");
36309: 
36309:   // Our argument should be a wrapped native object, but the caller may have
36309:   // passed it in as an optimization.
36309:   JSObject *wrappedObj;
36571:   if (JSVAL_IS_PRIMITIVE(*vp) ||
36309:       !(wrappedObj = JSVAL_TO_OBJECT(*vp)) ||
36309:       STOBJ_GET_CLASS(wrappedObj) == &XOWClass.base) {
36309:     return JS_TRUE;
36309:   }
36309: 
36309:   if (!wn &&
36309:       !(wn = XPCWrappedNative::GetAndMorphWrappedNativeOfJSObject(cx, wrappedObj))) {
36309:     return JS_TRUE;
36309:   }
36309: 
36309:   XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
36309: 
36309:   // The parent must be the inner global object for its scope.
36309:   parent = JS_GetGlobalForObject(cx, parent);
36309: 
36309:   JSClass *clasp = STOBJ_GET_CLASS(parent);
36309:   if (clasp->flags & JSCLASS_IS_EXTENDED) {
36309:     JSExtendedClass *xclasp = reinterpret_cast<JSExtendedClass *>(clasp);
36309:     if (xclasp->innerObject) {
36309:       parent = xclasp->innerObject(cx, parent);
36309:       if (!parent) {
36309:         return JS_FALSE;
36309:       }
36309:     }
36309:   }
36309: 
36309:   XPCWrappedNativeScope *parentScope =
36309:     XPCWrappedNativeScope::FindInJSObjectScope(cx, parent, nsnull, rt);
36309: 
36309: #ifdef DEBUG_mrbkap_off
36309:   printf("Wrapping object at %p (%s) [%p]\n",
36309:          (void *)wrappedObj, STOBJ_GET_CLASS(wrappedObj)->name,
36309:          (void *)parentScope);
36309: #endif
36309: 
36309:   JSObject *outerObj = nsnull;
36309:   WrappedNative2WrapperMap *map = parentScope->GetWrapperMap();
36309: 
36309:   outerObj = map->Find(wrappedObj);
36309:   if (outerObj) {
36309:     NS_ASSERTION(STOBJ_GET_CLASS(outerObj) == &XOWClass.base,
36309:                               "What crazy object are we getting here?");
36309: #ifdef DEBUG_mrbkap_off
36309:     printf("But found a wrapper in the map %p!\n", (void *)outerObj);
36309: #endif
36309:     *vp = OBJECT_TO_JSVAL(outerObj);
36309:     return JS_TRUE;
36309:   }
36309: 
36309:   outerObj = JS_NewObjectWithGivenProto(cx, &XOWClass.base, nsnull,
36309:                                         parent);
36309:   if (!outerObj) {
36309:     return JS_FALSE;
36309:   }
36309: 
36309:   if (!JS_SetReservedSlot(cx, outerObj, sWrappedObjSlot, *vp) ||
36309:       !JS_SetReservedSlot(cx, outerObj, sFlagsSlot, JSVAL_ZERO) ||
36309:       !JS_SetReservedSlot(cx, outerObj, XPC_XOW_ScopeSlot,
36309:                           PRIVATE_TO_JSVAL(parentScope))) {
36309:     return JS_FALSE;
36309:   }
36309: 
36309:   *vp = OBJECT_TO_JSVAL(outerObj);
36309: 
36309:   map->Add(wn->GetScope()->GetWrapperMap(), wrappedObj, outerObj);
36309: 
36309:   return JS_TRUE;
36309: }
36309: 
36309: } // namespace XPCCrossOriginWrapper
36309: 
36309: using namespace XPCCrossOriginWrapper;
36309: 
36309: static JSBool
36309: XPC_XOW_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
36309:                  jsval *rval);
36309: 
36309: static JSBool
36309: IsValFrame(JSObject *obj, jsval v, XPCWrappedNative *wn)
36309: {
36309:   // Fast path for the common case.
36309:   if (STOBJ_GET_CLASS(obj)->name[0] != 'W') {
36309:     return JS_FALSE;
36309:   }
36309: 
36309:   nsCOMPtr<nsIDOMWindow> domwin(do_QueryWrappedNative(wn));
36309:   if (!domwin) {
36309:     return JS_FALSE;
36309:   }
36309: 
36309:   nsCOMPtr<nsIDOMWindowCollection> col;
36309:   domwin->GetFrames(getter_AddRefs(col));
36309:   if (!col) {
36309:     return JS_FALSE;
36309:   }
36309: 
36309:   if (JSVAL_IS_INT(v)) {
36309:     col->Item(JSVAL_TO_INT(v), getter_AddRefs(domwin));
36309:   } else {
36309:     nsAutoString str(reinterpret_cast<PRUnichar *>
36309:                                      (JS_GetStringChars(JSVAL_TO_STRING(v))));
36309:     col->NamedItem(str, getter_AddRefs(domwin));
36309:   }
36309: 
36309:   return domwin != nsnull;
36309: }
36309: 
 4042: static JSBool
 4687: WrapSameOriginProp(JSContext *cx, JSObject *outerObj, jsval *vp);
 4687: 
 4687: static JSBool
 4042: XPC_XOW_FunctionWrapper(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
 4042:                         jsval *rval)
 4042: {
 4687:   JSObject *wrappedObj, *outerObj = obj;
 4042: 
 4691:   // Allow 'this' to be either an XOW, in which case we unwrap it.
 4691:   // We disallow invalid XOWs that have no wrapped object. Otherwise,
 4691:   // if it isn't an XOW, then pass it through as-is.
 4691: 
10858:   wrappedObj = GetWrapper(obj);
 4691:   if (wrappedObj) {
 4691:     wrappedObj = GetWrappedObject(cx, wrappedObj);
 4691:     if (!wrappedObj) {
 4042:       return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
 4042:     }
 4691:   } else {
 4691:     wrappedObj = obj;
 4691:   }
 4042: 
 4042:   JSObject *funObj = JSVAL_TO_OBJECT(argv[-2]);
 4042:   jsval funToCall;
36309:   if (!JS_GetReservedSlot(cx, funObj, eWrappedFunctionSlot, &funToCall)) {
 4042:     return JS_FALSE;
 4042:   }
 4042: 
 4042:   JSFunction *fun = JS_ValueToFunction(cx, funToCall);
 4042:   if (!fun) {
 4042:     return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
 4042:   }
 4042: 
14770:   XPCCallContext ccx(JS_CALLER, cx);
14770:   if (!ccx.IsValid()) {
14770:     return ThrowException(NS_ERROR_FAILURE, cx);
14770:   }
14770: 
34220:   nsresult rv = CanAccessWrapper(cx, JSVAL_TO_OBJECT(funToCall), nsnull);
 4687:   if (NS_FAILED(rv) && rv != NS_ERROR_DOM_PROP_ACCESS_DENIED) {
 4687:     return ThrowException(rv, cx);
 4687:   }
 4687: 
31939: #ifdef DEBUG
 4042:   JSNative native = JS_GetFunctionNative(cx, fun);
 4042:   NS_ASSERTION(native, "How'd we get here with a scripted function?");
31939: #endif
 4042: 
31939:   if (!JS_CallFunctionValue(cx, wrappedObj, funToCall, argc, argv, rval)) {
 4042:     return JS_FALSE;
 4042:   }
 4042: 
 4687:   if (NS_SUCCEEDED(rv)) {
 4687:     return WrapSameOriginProp(cx, outerObj, rval);
 4687:   }
 4687: 
36309:   return RewrapIfNeeded(cx, obj, rval);
 4042: }
 4042: 
 4687: static JSBool
 4687: WrapSameOriginProp(JSContext *cx, JSObject *outerObj, jsval *vp)
 4687: {
36309:   // Don't call RewrapIfNeeded for same origin properties. We only
 4687:   // need to wrap window, document and location.
 4687:   if (JSVAL_IS_PRIMITIVE(*vp)) {
 4687:     return JS_TRUE;
 4687:   }
 4687: 
 4687:   JSObject *wrappedObj = JSVAL_TO_OBJECT(*vp);
10858:   JSClass *clasp = STOBJ_GET_CLASS(wrappedObj);
36309:   if (ClassNeedsXOW(clasp->name)) {
36309:     return WrapObject(cx, JS_GetGlobalForObject(cx, outerObj), vp);
 4687:   }
 4687: 
 4688:   // Check if wrappedObj is an XOW. If so, verify that it's from the
 4688:   // right scope.
36309:   if (clasp == &XOWClass.base &&
10858:       STOBJ_GET_PARENT(wrappedObj) != STOBJ_GET_PARENT(outerObj)) {
 4688:     *vp = OBJECT_TO_JSVAL(GetWrappedObject(cx, wrappedObj));
36309:     return WrapObject(cx, STOBJ_GET_PARENT(outerObj), vp);
 4688:   }
 4688: 
 4687:   return JS_TRUE;
 4687: }
 4687: 
18907: static JSBool
 4042: XPC_XOW_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 4042: {
 4042:   // All AddProperty needs to do is pass on addProperty requests to
 4042:   // same-origin objects, and throw for all else.
 4042: 
10858:   obj = GetWrapper(obj);
 4042:   jsval resolving;
36309:   if (!JS_GetReservedSlot(cx, obj, sFlagsSlot, &resolving)) {
 4042:     return JS_FALSE;
 4042:   }
 4042: 
36627:   if (!JSVAL_IS_PRIMITIVE(*vp)) {
36571:     JSObject *addedObj = JSVAL_TO_OBJECT(*vp);
36571:     if (STOBJ_GET_CLASS(addedObj) == &XOWClass.base &&
36571:         STOBJ_GET_PARENT(addedObj) != STOBJ_GET_PARENT(obj)) {
36571:       *vp = OBJECT_TO_JSVAL(GetWrappedObject(cx, addedObj));
36571:       if (!WrapObject(cx, STOBJ_GET_PARENT(obj), vp, nsnull)) {
36571:         return JS_FALSE;
36571:       }
36571:     }
36571:   }
36571: 
27664:   if (HAS_FLAGS(resolving, FLAG_RESOLVING)) {
 4042:     // Allow us to define a property on ourselves.
 4042:     return JS_TRUE;
 4042:   }
 4042: 
 4042:   JSObject *wrappedObj = GetWrappedObject(cx, obj);
 4042:   if (!wrappedObj) {
 4042:     return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
 4042:   }
14770: 
14770:   XPCCallContext ccx(JS_CALLER, cx);
14770:   if (!ccx.IsValid()) {
14770:     return ThrowException(NS_ERROR_FAILURE, cx);
14770:   }
14770: 
34220:   JSBool privilegeEnabled = JS_FALSE;
34220:   nsresult rv = CanAccessWrapper(cx, wrappedObj, &privilegeEnabled);
 4042:   if (NS_FAILED(rv)) {
 4042:     if (rv == NS_ERROR_DOM_PROP_ACCESS_DENIED) {
 4042:       // Can't override properties on foreign objects.
 4042:       return ThrowException(rv, cx);
 4042:     }
 4042:     return JS_FALSE;
 4042:   }
 4042: 
 4042:   // Same origin, pass this request along.
36309:   return AddProperty(cx, obj, JS_TRUE, wrappedObj, id, vp);
 4042: }
 4042: 
18907: static JSBool
 4042: XPC_XOW_DelProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 4042: {
 4042:   JSObject *wrappedObj = GetWrappedObject(cx, obj);
 4042:   if (!wrappedObj) {
 4042:     return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
 4042:   }
14770: 
14770:   XPCCallContext ccx(JS_CALLER, cx);
14770:   if (!ccx.IsValid()) {
14770:     return ThrowException(NS_ERROR_FAILURE, cx);
14770:   }
14770: 
34220:   nsresult rv = CanAccessWrapper(cx, wrappedObj, nsnull);
 4042:   if (NS_FAILED(rv)) {
 4042:     if (rv == NS_ERROR_DOM_PROP_ACCESS_DENIED) {
 4042:       // Can't delete properties on foreign objects.
 4042:       return ThrowException(rv, cx);
 4042:     }
 4042:     return JS_FALSE;
 4042:   }
 4042: 
 4042:   // Same origin, pass this request along.
36309:   return DelProperty(cx, wrappedObj, id, vp);
 4042: }
 4042: 
 4042: static JSBool
 4042: XPC_XOW_GetOrSetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp,
 4042:                          JSBool isSet)
 4042: {
 4042:   if (id == GetRTStringByIndex(cx, XPCJSRuntime::IDX_TO_STRING)) {
 4042:     return JS_TRUE;
 4042:   }
 4042: 
 4687:   // Don't do anything if we already resolved to a wrapped function in
 4687:   // NewResolve. In practice, this means that this is a wrapped eval
 4687:   // function.
 4687:   jsval v = *vp;
 4687:   if (!JSVAL_IS_PRIMITIVE(v) &&
 4687:       JS_ObjectIsFunction(cx, JSVAL_TO_OBJECT(v)) &&
 4687:       JS_GetFunctionNative(cx, JS_ValueToFunction(cx, v)) ==
 4687:       XPC_XOW_FunctionWrapper) {
 4687:     return JS_TRUE;
 4687:   }
 4687: 
 8383:   JSObject *origObj = obj;
10858:   obj = GetWrapper(obj);
 4727:   if (!obj) {
 4727:     return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
 4727:   }
 4727: 
 4115:   XPCCallContext ccx(JS_CALLER, cx);
 4115:   if (!ccx.IsValid()) {
 4115:     return ThrowException(NS_ERROR_FAILURE, cx);
 4115:   }
 4115: 
 4115:   AUTO_MARK_JSVAL(ccx, vp);
 4115: 
 4042:   JSObject *wrappedObj = GetWrappedObject(cx, obj);
 4042:   if (!wrappedObj) {
 4042:     return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
 4042:   }
34220: 
34220:   JSBool privilegeEnabled;
34220:   nsresult rv = CanAccessWrapper(cx, wrappedObj, &privilegeEnabled);
 4042:   if (NS_FAILED(rv)) {
 4042:     if (rv != NS_ERROR_DOM_PROP_ACCESS_DENIED) {
 4042:       return JS_FALSE;
 4042:     }
 4042: 
 4042:     // This is a request to get a property across origins. We need to
 4042:     // determine if this property is allAccess. If it is, then we need to
 4042:     // actually get the property. If not, we simply need to throw an
 4042:     // exception.
 4042: 
 4042:     XPCWrappedNative *wn =
 4042:       XPCWrappedNative::GetWrappedNativeOfJSObject(cx, wrappedObj);
 4042:     NS_ASSERTION(wn, "How did we wrap a non-WrappedNative?");
10858:     if (!IsValFrame(wrappedObj, id, wn)) {
36309:       nsIScriptSecurityManager *ssm = GetSecurityManager();
 4097:       if (!ssm) {
 4097:         return ThrowException(NS_ERROR_NOT_INITIALIZED, cx);
 4097:       }
 4042:       rv = ssm->CheckPropertyAccess(cx, wrappedObj,
10858:                                     STOBJ_GET_CLASS(wrappedObj)->name,
36309:                                     id, isSet ? sSecMgrSetProp
36309:                                               : sSecMgrGetProp);
 4042:       if (NS_FAILED(rv)) {
 4042:         // The security manager threw an exception for us.
 4042:         return JS_FALSE;
 4042:       }
 4042:     }
 4042: 
36309:     return GetOrSetNativeProperty(cx, obj, wn, id, vp, isSet, JS_FALSE);
 4042:   }
 4042: 
 4210:   JSObject *proto = nsnull; // Initialize this to quiet GCC.
 4210:   JSBool checkProto =
 4210:     (isSet && id == GetRTStringByIndex(cx, XPCJSRuntime::IDX_PROTO));
 4210:   if (checkProto) {
10858:     proto = STOBJ_GET_PROTO(wrappedObj);
 4210:   }
 4210: 
 4042:   // Same origin, pass this request along as though nothing interesting
 4042:   // happened.
 4042:   jsid asId;
 4042: 
 4042:   if (!JS_ValueToId(cx, id, &asId)) {
 4042:     return JS_FALSE;
 4042:   }
 4042: 
 4042:   JSBool ok = isSet
26167:               ? JS_SetPropertyById(cx, wrappedObj, asId, vp)
26167:               : JS_GetPropertyById(cx, wrappedObj, asId, vp);
 4042:   if (!ok) {
 4042:     return JS_FALSE;
 4042:   }
 4042: 
 8383:   if (checkProto) {
10858:     JSObject *newProto = STOBJ_GET_PROTO(wrappedObj);
 8383: 
 8383:     // If code is trying to set obj.__proto__ and we're on obj's
26167:     // prototype chain, then the JS_GetPropertyById above will do the
 8383:     // wrong thing if wrappedObj still delegates to Object.prototype.
 8383:     // However, it's hard to figure out if wrappedObj still does
 8383:     // delegate to Object.prototype so check to see if proto changed as a
 8383:     // result of setting __proto__.
 8383: 
 8383:     if (origObj != obj) {
 8383:       // Undo the damage.
 8383:       if (!JS_SetPrototype(cx, wrappedObj, proto) ||
 8383:           !JS_SetPrototype(cx, origObj, newProto)) {
 8383:         return JS_FALSE;
 8383:       }
 8383:     } else if (newProto) {
 8383:       // __proto__ setting is a bad hack, people shouldn't do it. In
 8383:       // this case we're setting the direct prototype of a XOW object,
 8383:       // in the interests of sanity only allow it to be set to null in
 8383:       // this case.
 4210: 
 6234:       JS_SetPrototype(cx, wrappedObj, proto);
 6234:       JS_ReportError(cx, "invalid __proto__ value (can only be set to null)");
 4210:       return JS_FALSE;
 4210:     }
 8383:   }
 4210: 
 4687:   return WrapSameOriginProp(cx, obj, vp);
 4042: }
 4042: 
18907: static JSBool
 4042: XPC_XOW_GetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 4042: {
 4042:   return XPC_XOW_GetOrSetProperty(cx, obj, id, vp, JS_FALSE);
 4042: }
 4042: 
18907: static JSBool
 4042: XPC_XOW_SetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 4042: {
 4042:   return XPC_XOW_GetOrSetProperty(cx, obj, id, vp, JS_TRUE);
 4042: }
 4042: 
18907: static JSBool
 4042: XPC_XOW_Enumerate(JSContext *cx, JSObject *obj)
 4042: {
10858:   obj = GetWrapper(obj);
 4042:   JSObject *wrappedObj = GetWrappedObject(cx, obj);
 4042:   if (!wrappedObj) {
 4042:     // Nothing to enumerate.
 4042:     return JS_TRUE;
 4042:   }
14770: 
14770:   XPCCallContext ccx(JS_CALLER, cx);
14770:   if (!ccx.IsValid()) {
14770:     return ThrowException(NS_ERROR_FAILURE, cx);
14770:   }
14770: 
34220:   nsresult rv = CanAccessWrapper(cx, wrappedObj, nsnull);
 4042:   if (NS_FAILED(rv)) {
 4042:     if (rv == NS_ERROR_DOM_PROP_ACCESS_DENIED) {
 4042:       // Can't enumerate on foreign objects.
 4042:       return ThrowException(rv, cx);
 4042:     }
 4042: 
 4042:     return JS_FALSE;
 4042:   }
 4042: 
36309:   return Enumerate(cx, obj, wrappedObj);
 4042: }
 4042: 
34220: // Because of the drastically different ways that same- and cross-origin XOWs
34220: // work, we have to call JS_ClearScope when a XOW changes from being same-
34220: // origin to cross-origin. Normally, there are defined places in Gecko where
34220: // this happens and they notify us. However, UniversalXPConnect causes the
34220: // same transition without any notifications. We could try to detect when this
34220: // happens, but doing so would require calling JS_ClearScope from random
34220: // hooks, which is bad.
34220: //
34220: // The compromise is the UXPCObject. When resolving a property on a XOW as
34220: // same-origin because of UniversalXPConnect, we actually resolve it on the
34220: // UXPCObject (which is just a XOW for the same object). This causes the JS
34220: // engine to do all of its work on another object, not polluting the main
34220: // object. However, if the get results in calling a setter, the engine still
34220: // uses the regular object as 'this', ensuring that the UXPCObject doesn't
34220: // leak to script.
34220: static JSObject *
34220: GetUXPCObject(JSContext *cx, JSObject *obj)
34220: {
36309:   NS_ASSERTION(STOBJ_GET_CLASS(obj) == &XOWClass.base, "wrong object");
34220: 
34220:   jsval v;
36309:   if (!JS_GetReservedSlot(cx, obj, sFlagsSlot, &v)) {
34220:     return nsnull;
34220:   }
34220: 
34220:   if (HAS_FLAGS(v, FLAG_IS_UXPC_OBJECT)) {
34220:     return obj;
34220:   }
34220: 
34220:   if (!JS_GetReservedSlot(cx, obj, sUXPCObjectSlot, &v)) {
34220:     return nsnull;
34220:   }
34220: 
34220:   if (JSVAL_IS_OBJECT(v)) {
34220:     return JSVAL_TO_OBJECT(v);
34220:   }
34220: 
34220:   JSObject *uxpco =
36309:     JS_NewObjectWithGivenProto(cx, &XOWClass.base, nsnull,
34220:                                STOBJ_GET_PARENT(obj));
34220:   if (!uxpco) {
34220:     return nsnull;
34220:   }
34220: 
34220:   JSAutoTempValueRooter tvr(cx, uxpco);
34220: 
34220:   jsval wrappedObj, parentScope;
36309:   if (!JS_GetReservedSlot(cx, obj, sWrappedObjSlot, &wrappedObj) ||
34220:       !JS_GetReservedSlot(cx, obj, XPC_XOW_ScopeSlot, &parentScope)) {
34220:     return nsnull;
34220:   }
34220: 
36309:   if (!JS_SetReservedSlot(cx, uxpco, sWrappedObjSlot, wrappedObj) ||
36309:       !JS_SetReservedSlot(cx, uxpco, sFlagsSlot,
34220:                           INT_TO_JSVAL(FLAG_IS_UXPC_OBJECT)) ||
34220:       !JS_SetReservedSlot(cx, uxpco, XPC_XOW_ScopeSlot, parentScope)) {
34220:     return nsnull;
34220:   }
34220: 
34220:   if (!JS_SetReservedSlot(cx, obj, sUXPCObjectSlot, OBJECT_TO_JSVAL(uxpco))) {
34220:     return nsnull;
34220:   }
34220: 
34220:   return uxpco;
34220: }
34220: 
18907: static JSBool
 4042: XPC_XOW_NewResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
 4042:                    JSObject **objp)
 4042: {
10858:   obj = GetWrapper(obj);
 4042: 
 4042:   JSObject *wrappedObj = GetWrappedObject(cx, obj);
 4042:   if (!wrappedObj) {
 4042:     // No wrappedObj means that this is probably the prototype.
 4042:     *objp = nsnull;
 4042:     return JS_TRUE;
 4042:   }
 4042: 
14770:   XPCCallContext ccx(JS_CALLER, cx);
14770:   if (!ccx.IsValid()) {
14770:     return ThrowException(NS_ERROR_FAILURE, cx);
14770:   }
14770: 
34220:   JSBool privilegeEnabled;
34220:   nsresult rv = CanAccessWrapper(cx, wrappedObj, &privilegeEnabled);
 4042:   if (NS_FAILED(rv)) {
 4042:     if (rv != NS_ERROR_DOM_PROP_ACCESS_DENIED) {
 4042:       return JS_FALSE;
 4042:     }
 4042: 
 4042:     // We're dealing with a cross-origin lookup. Ensure that we're allowed to
 4042:     // resolve this property and resolve it if so. Otherwise, we deny access
 4042:     // and throw a security error. Note that this code does not actually check
 4042:     // to see if the property exists, that's dealt with below.
 4042: 
 4042:     XPCWrappedNative *wn =
 4042:       XPCWrappedNative::GetWrappedNativeOfJSObject(cx, wrappedObj);
 4042:     NS_ASSERTION(wn, "How did we wrap a non-WrappedNative?");
10858:     if (!IsValFrame(wrappedObj, id, wn)) {
36309:       nsIScriptSecurityManager *ssm = GetSecurityManager();
 4097:       if (!ssm) {
 4097:         return ThrowException(NS_ERROR_NOT_INITIALIZED, cx);
 4097:       }
34220: 
 4042:       PRUint32 action = (flags & JSRESOLVE_ASSIGNING)
36309:                         ? sSecMgrSetProp
36309:                         : sSecMgrGetProp;
 4042:       rv = ssm->CheckPropertyAccess(cx, wrappedObj,
10858:                                     STOBJ_GET_CLASS(wrappedObj)->name,
 4042:                                     id, action);
 4042:       if (NS_FAILED(rv)) {
 4042:         // The security manager threw an exception for us.
 4042:         return JS_FALSE;
 4042:       }
 4042:     }
 4042: 
 4042:     // We're out! We're allowed to resolve this property.
36309:     return ResolveNativeProperty(cx, obj, wrappedObj, wn, id,
 4042:                                  flags, objp, JS_FALSE);
 4042: 
 4042:   }
 4042: 
34220:   if (privilegeEnabled && !(obj = GetUXPCObject(cx, obj))) {
34220:     return JS_FALSE;
34220:   }
34220: 
 9671:   if (id == GetRTStringByIndex(cx, XPCJSRuntime::IDX_TO_STRING)) {
 9671:     jsval oldSlotVal;
36309:     if (!JS_GetReservedSlot(cx, obj, sFlagsSlot, &oldSlotVal) ||
36309:         !JS_SetReservedSlot(cx, obj, sFlagsSlot,
27664:                             INT_TO_JSVAL(JSVAL_TO_INT(oldSlotVal) |
27664:                                          FLAG_RESOLVING))) {
 9671:       return JS_FALSE;
 9671:     }
 9671: 
 9671:     JSBool ok = JS_DefineFunction(cx, obj, "toString",
 9671:                                   XPC_XOW_toString, 0, 0) != nsnull;
 9671: 
36309:     JS_SetReservedSlot(cx, obj, sFlagsSlot, oldSlotVal);
27664: 
27664:     if (ok) {
 9671:       *objp = obj;
 9671:     }
 9671: 
 9671:     return ok;
 9671:   }
 9671: 
36309:   return NewResolve(cx, obj, JS_TRUE, wrappedObj, id, flags, objp);
 4042: }
 4042: 
18907: static JSBool
 4042: XPC_XOW_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
 4042: {
10698:   // Don't do any work to convert to object.
10698:   if (type == JSTYPE_OBJECT) {
10698:     *vp = OBJECT_TO_JSVAL(obj);
10698:     return JS_TRUE;
10698:   }
10698: 
 4042:   JSObject *wrappedObj = GetWrappedObject(cx, obj);
 4042:   if (!wrappedObj) {
 4042:     // Converting the prototype to something.
 4042: 
10698:     if (type == JSTYPE_STRING || type == JSTYPE_VOID) {
 4042:       return XPC_XOW_toString(cx, obj, 0, nsnull, vp);
 4042:     }
 4042: 
 4042:     *vp = OBJECT_TO_JSVAL(obj);
 4042:     return JS_TRUE;
 4042:   }
 4042: 
14770:   XPCCallContext ccx(JS_CALLER, cx);
14770:   if (!ccx.IsValid()) {
14770:     return ThrowException(NS_ERROR_FAILURE, cx);
14770:   }
14770: 
 6233:   // Note: JSTYPE_VOID and JSTYPE_STRING are equivalent.
34220:   nsresult rv = CanAccessWrapper(cx, wrappedObj, nsnull);
 4042:   if (NS_FAILED(rv) &&
 6233:       (rv != NS_ERROR_DOM_PROP_ACCESS_DENIED ||
 6233:        (type != JSTYPE_STRING && type != JSTYPE_VOID))) {
 6233:     // Ensure that we report some kind of error.
 6233:     if (rv == NS_ERROR_DOM_PROP_ACCESS_DENIED) {
 6233:       ThrowException(rv, cx);
 6233:     }
 4042:     return JS_FALSE;
 4042:   }
 4042: 
10858:   if (!STOBJ_GET_CLASS(wrappedObj)->convert(cx, wrappedObj, type, vp)) {
10698:     return JS_FALSE;
10698:   }
10698: 
10698:   return NS_SUCCEEDED(rv)
10698:          ? WrapSameOriginProp(cx, obj, vp)
36309:          : RewrapIfNeeded(cx, obj, vp);
 4042: }
 4042: 
18907: static void
 4042: XPC_XOW_Finalize(JSContext *cx, JSObject *obj)
 4042: {
 4042:   JSObject *wrappedObj = GetWrappedObject(cx, obj);
 4042:   if (!wrappedObj) {
 4042:     return;
 4042:   }
 4042: 
 4099:   // Get our scope.
 4099:   jsval scopeVal;
 4099:   if (!JS_GetReservedSlot(cx, obj, XPC_XOW_ScopeSlot, &scopeVal)) {
 4097:     return;
 4097:   }
 4042: 
 4099:   // Now that we have our scope, see if it's going away. If it is,
 4099:   // then our work here is going to be done when we destroy the scope
 6464:   // entirely. Scope can be null if we're an enumerating XOW.
 4099:   XPCWrappedNativeScope *scope = reinterpret_cast<XPCWrappedNativeScope *>
 4099:                                                  (JSVAL_TO_PRIVATE(scopeVal));
 9848:   if (!scope) {
 4099:     return;
 4099:   }
 4042: 
 4099:   // Remove ourselves from the map.
 4042:   scope->GetWrapperMap()->Remove(wrappedObj);
 4042: }
 4042: 
18907: static JSBool
 4042: XPC_XOW_CheckAccess(JSContext *cx, JSObject *obj, jsval prop, JSAccessMode mode,
 4042:                     jsval *vp)
 4042: {
 4042:   // Simply forward checkAccess to our wrapped object. It's already expecting
 4042:   // untrusted things to ask it about accesses.
 4042: 
 4042:   uintN junk;
 4042:   jsid id;
 4042:   return JS_ValueToId(cx, prop, &id) &&
 4042:          JS_CheckAccess(cx, GetWrappedObject(cx, obj), id, mode, vp, &junk);
 4042: }
 4042: 
18907: static JSBool
 4042: XPC_XOW_Call(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 4042: {
 4042:   JSObject *wrappedObj = GetWrappedObject(cx, obj);
 4042:   if (!wrappedObj) {
 4042:     // Nothing to call.
 4042:     return JS_TRUE;
 4042:   }
14770: 
14770:   XPCCallContext ccx(JS_CALLER, cx);
14770:   if (!ccx.IsValid()) {
14770:     return ThrowException(NS_ERROR_FAILURE, cx);
14770:   }
14770: 
34220:   nsresult rv = CanAccessWrapper(cx, wrappedObj, nsnull);
 4042:   if (NS_FAILED(rv)) {
 4042:     if (rv == NS_ERROR_DOM_PROP_ACCESS_DENIED) {
 4042:       // Can't call.
 4042:       return ThrowException(rv, cx);
 4042:     }
 4042: 
 4042:     return JS_FALSE;
 4042:   }
 4042: 
 4042:   JSObject *callee = JSVAL_TO_OBJECT(argv[-2]);
 4042:   NS_ASSERTION(GetWrappedObject(cx, callee), "How'd we get here?");
 4042:   callee = GetWrappedObject(cx, callee);
 4042:   if (!JS_CallFunctionValue(cx, obj, OBJECT_TO_JSVAL(callee), argc, argv,
 4042:                             rval)) {
 4042:     return JS_FALSE;
 4042:   }
 4042: 
36309:   return RewrapIfNeeded(cx, callee, rval);
 4042: }
 4042: 
18907: static JSBool
 4042: XPC_XOW_Construct(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
 4042:                   jsval *rval)
 4042: {
10858:   JSObject *realObj = GetWrapper(JSVAL_TO_OBJECT(argv[-2]));
 4042:   JSObject *wrappedObj = GetWrappedObject(cx, realObj);
 4042:   if (!wrappedObj) {
 4042:     // Nothing to construct.
 4042:     return JS_TRUE;
 4042:   }
14770: 
14770:   XPCCallContext ccx(JS_CALLER, cx);
14770:   if (!ccx.IsValid()) {
14770:     return ThrowException(NS_ERROR_FAILURE, cx);
14770:   }
14770: 
34220:   nsresult rv = CanAccessWrapper(cx, wrappedObj, nsnull);
 4042:   if (NS_FAILED(rv)) {
 4042:     if (rv == NS_ERROR_DOM_PROP_ACCESS_DENIED) {
 4042:       // Can't construct.
 4042:       return ThrowException(rv, cx);
 4042:     }
 4042:     return JS_FALSE;
 4042:   }
 4042: 
25522:   if (!JS_CallFunctionValue(cx, obj, OBJECT_TO_JSVAL(wrappedObj), argc, argv,
 4042:                             rval)) {
 4042:     return JS_FALSE;
 4042:   }
 4042: 
36309:   return RewrapIfNeeded(cx, wrappedObj, rval);
 4042: }
 4042: 
18907: static JSBool
 9428: XPC_XOW_HasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
 9428: {
 9428:   JSObject *iface = GetWrappedObject(cx, obj);
14770: 
14770:   XPCCallContext ccx(JS_CALLER, cx);
14770:   if (!ccx.IsValid()) {
14770:     return ThrowException(NS_ERROR_FAILURE, cx);
14770:   }
14770: 
34220:   nsresult rv = CanAccessWrapper(cx, iface, nsnull);
 9428:   if (NS_FAILED(rv)) {
 9428:     if (rv == NS_ERROR_DOM_PROP_ACCESS_DENIED) {
 9428:       // Don't do this test across origins.
 9428:       return ThrowException(rv, cx);
 9428:     }
 9428:     return JS_FALSE;
 9428:   }
 9428: 
10858:   JSClass *clasp = STOBJ_GET_CLASS(iface);
 9428: 
 9428:   *bp = JS_FALSE;
 9428:   if (!clasp->hasInstance) {
 9428:     return JS_TRUE;
 9428:   }
 9428: 
 9428:   // Prematurely unwrap the left hand side.
 9428:   if (!JSVAL_IS_PRIMITIVE(v)) {
 9428:     JSObject *test = JSVAL_TO_OBJECT(v);
 9428: 
 9428:     // GetWrappedObject does an instanceof check.
 9428:     test = GetWrappedObject(cx, test);
 9428:     if (test) {
 9428:       v = OBJECT_TO_JSVAL(test);
 9428:     }
 9428:   }
 9428: 
 9428:   return clasp->hasInstance(cx, iface, v, bp);
 9428: }
 9428: 
18907: static JSBool
 4042: XPC_XOW_Equality(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
 4042: {
 4042:   // Convert both sides to XPCWrappedNative and see if they match.
 4042:   if (JSVAL_IS_PRIMITIVE(v)) {
 4042:     *bp = JS_FALSE;
 4042:     return JS_TRUE;
 4042:   }
 4042: 
 4042:   JSObject *test = JSVAL_TO_OBJECT(v);
36309:   if (STOBJ_GET_CLASS(test) == &XOWClass.base) {
36309:     if (!JS_GetReservedSlot(cx, test, sWrappedObjSlot, &v)) {
 4042:       return JS_FALSE;
 4042:     }
 4042: 
 4042:     if (JSVAL_IS_PRIMITIVE(v)) {
 4042:       *bp = JS_FALSE;
 4042:       return JS_TRUE;
 4042:     }
 4042: 
 4042:     test = JSVAL_TO_OBJECT(v);
 4042:   }
 4042: 
 4042:   obj = GetWrappedObject(cx, obj);
 4042:   if (!obj) {
 4042:     return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
 4042:   }
 4042:   XPCWrappedNative *other =
 4042:     XPCWrappedNative::GetWrappedNativeOfJSObject(cx, test);
 4042:   if (!other) {
 4042:     *bp = JS_FALSE;
 4042:     return JS_TRUE;
 4042:   }
 4042: 
 4042:   XPCWrappedNative *me = XPCWrappedNative::GetWrappedNativeOfJSObject(cx, obj);
 4042:   obj = me->GetFlatJSObject();
 4042:   test = other->GetFlatJSObject();
10858:   return ((JSExtendedClass *)STOBJ_GET_CLASS(obj))->
 4042:     equality(cx, obj, OBJECT_TO_JSVAL(test), bp);
 4042: }
 4042: 
18907: static JSObject *
 6464: XPC_XOW_Iterator(JSContext *cx, JSObject *obj, JSBool keysonly)
 6464: {
13270:   JSObject *wrappedObj = GetWrappedObject(cx, obj);
13270:   if (!wrappedObj) {
13270:     ThrowException(NS_ERROR_INVALID_ARG, cx);
13270:     return nsnull;
13270:   }
14770: 
14770:   XPCCallContext ccx(JS_CALLER, cx);
14770:   if (!ccx.IsValid()) {
14770:     ThrowException(NS_ERROR_FAILURE, cx);
14770:     return nsnull;
14770:   }
14770: 
34220:   nsresult rv = CanAccessWrapper(cx, wrappedObj, nsnull);
13270:   if (NS_FAILED(rv)) {
13270:     if (rv == NS_ERROR_DOM_PROP_ACCESS_DENIED) {
13270:       // Can't create iterators for foreign objects.
13270:       ThrowException(rv, cx);
13270:       return nsnull;
13270:     }
13270: 
13270:     ThrowException(NS_ERROR_FAILURE, cx);
13270:     return nsnull;
13270:   }
13270: 
36309:   JSObject *wrapperIter = JS_NewObject(cx, &XOWClass.base, nsnull,
 6464:                                        JS_GetGlobalForObject(cx, obj));
 6464:   if (!wrapperIter) {
 6464:     return nsnull;
 6464:   }
 6464: 
 9724:   JSAutoTempValueRooter tvr(cx, OBJECT_TO_JSVAL(wrapperIter));
 6464: 
 6464:   // Initialize our XOW.
13270:   jsval v = OBJECT_TO_JSVAL(wrappedObj);
36309:   if (!JS_SetReservedSlot(cx, wrapperIter, sWrappedObjSlot, v) ||
36309:       !JS_SetReservedSlot(cx, wrapperIter, sFlagsSlot, JSVAL_ZERO) ||
11430:       !JS_SetReservedSlot(cx, wrapperIter, XPC_XOW_ScopeSlot,
 6464:                           PRIVATE_TO_JSVAL(nsnull))) {
 6464:     return nsnull;
 6464:   }
 6464: 
36309:   return CreateIteratorObj(cx, wrapperIter, obj, wrappedObj, keysonly);
 6464: }
 6464: 
18907: static JSObject *
 9560: XPC_XOW_WrappedObject(JSContext *cx, JSObject *obj)
 9560: {
 9560:   return GetWrappedObject(cx, obj);
 9560: }
 9560: 
18907: static JSBool
 4042: XPC_XOW_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
 4042:                  jsval *rval)
 4042: {
10858:   obj = GetWrapper(obj);
 4042:   if (!obj) {
 4042:     return ThrowException(NS_ERROR_UNEXPECTED, cx);
 4042:   }
 4042: 
 4042:   JSObject *wrappedObj = GetWrappedObject(cx, obj);
 4042:   if (!wrappedObj) {
 4042:     // Someone's calling toString on our prototype.
 4042:     NS_NAMED_LITERAL_CSTRING(protoString, "[object XPCCrossOriginWrapper]");
 4042:     JSString *str =
 4042:       JS_NewStringCopyN(cx, protoString.get(), protoString.Length());
 4042:     if (!str) {
 4042:       return JS_FALSE;
 4042:     }
 4042:     *rval = STRING_TO_JSVAL(str);
 4042:     return JS_TRUE;
 4042:   }
 4042: 
14770:   XPCCallContext ccx(JS_CALLER, cx);
14770:   if (!ccx.IsValid()) {
14770:     return ThrowException(NS_ERROR_FAILURE, cx);
14770:   }
14770: 
34220:   nsresult rv = CanAccessWrapper(cx, wrappedObj, nsnull);
 4042:   if (rv == NS_ERROR_DOM_PROP_ACCESS_DENIED) {
36309:     nsIScriptSecurityManager *ssm = GetSecurityManager();
 4097:     if (!ssm) {
 4097:       return ThrowException(NS_ERROR_NOT_INITIALIZED, cx);
 4097:     }
 4042:     rv = ssm->CheckPropertyAccess(cx, wrappedObj,
10858:                                   STOBJ_GET_CLASS(wrappedObj)->name,
 4042:                                   GetRTStringByIndex(cx, XPCJSRuntime::IDX_TO_STRING),
 4042:                                   nsIXPCSecurityManager::ACCESS_GET_PROPERTY);
 4042:   }
 4042:   if (NS_FAILED(rv)) {
 4042:     return JS_FALSE;
 4042:   }
 4042: 
 4042:   XPCWrappedNative *wn =
 4042:     XPCWrappedNative::GetWrappedNativeOfJSObject(cx, wrappedObj);
36309:   return NativeToString(cx, wn, argc, argv, rval, JS_FALSE);
 4042: }
