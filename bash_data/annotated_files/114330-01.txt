     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 94037: // Main header first:
 93575: #include "nsSVGGlyphFrame.h"
 93575: 
 94037: // Keep others in (case-insensitive) order:
 58893: #include "DOMSVGPoint.h"
     1: #include "gfxContext.h"
     1: #include "gfxMatrix.h"
   630: #include "gfxPlatform.h"
 94037: #include "mozilla/LookAndFeel.h"
 94037: #include "nsBidiPresUtils.h"
105956: #include "nsDisplayList.h"
108290: #include "nsError.h"
 94037: #include "nsIDOMSVGRect.h"
 94037: #include "nsRenderingContext.h"
 89450: #include "nsSVGEffects.h"
103332: #include "nsSVGIntegrationUtils.h"
 89450: #include "nsSVGPaintServerFrame.h"
 94037: #include "nsSVGRect.h"
 94037: #include "nsSVGTextPathFrame.h"
 94037: #include "nsSVGUtils.h"
 94037: #include "nsTextFragment.h"
 94037: #include "SVGLengthList.h"
   630: 
 47840: using namespace mozilla;
 47840: 
 13259: struct CharacterPosition {
 13259:   gfxPoint pos;
 13259:   gfxFloat angle;
 79445:   bool draw;
 13259: };
 13259: 
 61489: static gfxContext* MakeTmpCtx() {
 61489:   return new gfxContext(gfxPlatform::GetPlatform()->ScreenReferenceSurface());
 61489: }
 61489: 
 13259: /**
 13259:  * This is a do-it-all helper class. It supports iterating through the
 60286:  * drawable character clusters of a string. For each cluster, it can set up
 13259:  * a graphics context with a transform appropriate for drawing the
 13259:  * character, or a transform appropriate for emitting geometry in the
 13259:  * text metrics coordinate system (which differs from the drawing
 13259:  * coordinate system by a scale factor of AppUnitPerCSSPixels). These
 13259:  * transforms include offsets and rotations of characters along paths, and
 13259:  * the mPosition of the nsSVGGlyphFrame.
 13259:  * 
 13259:  * This helper also creates the textrun as needed. It supports detecting
 13259:  * the special case when the entire textrun can be drawn or measured
 13259:  * as a unit, and setting the graphics context transform up for that. It
 13259:  * takes care of setting up the global transform if requested. It also
 13259:  * provides direct access to the character path position data for the
 13259:  * DOM APIs that need that.
 13259:  * 
 13259:  * If an error occurs, for example, a canvas TM is not available because
 13259:  * the element is in a <defs> section, then the CharacterIterator will
 13259:  * behave as if the frame has no drawable characters.
 13259:  *
 13259:  * XXX needs RTL love
 13259:  * XXX might want to make AdvanceToCharacter constant time (e.g. by
 13259:  * caching advances and/or the CharacterPosition array across DOM
 13259:  * API calls) to ensure that calling Get*OfChar (etc) for each character
 13259:  * in the text is O(N)
 13259:  */
 13259: class CharacterIterator
 13259: {
 13259: public:
 13259:   /**
 60286:    * Sets up the iterator so that NextCluster will return the first drawable
 60286:    * cluster.
 13259:    * @param aForceGlobalTransform passed on to EnsureTextRun (see below)
 13259:    */
 79445:   CharacterIterator(nsSVGGlyphFrame *aSource, bool aForceGlobalTransform);
 13259:   /**
 13259:    * This matrix will be applied to aContext in the SetupFor methods below,
 13259:    * before any glyph translation/rotation.
 13259:    */
106707:   bool SetInitialMatrix(gfxContext *aContext) {
 13760:     mInitialMatrix = aContext->CurrentMatrix();
 13760:     if (mInitialMatrix.IsSingular()) {
 80486:       mInError = true;
 13760:     }
106707:     return !mInError;
 13760:   }
 13259:   /**
 13259:    * Try to set up aContext so we can draw the whole textrun at once.
 13760:    * This applies any global transform requested by SetInitialMatrix,
 13259:    * then applies the positioning of the text. Returns false if drawing
 13259:    * the whole textrun at once is impossible due to individual positioning
 13259:    * and/or rotation of glyphs.
 13259:    */
 79445:   bool SetupForDirectTextRunDrawing(gfxContext *aContext) {
 13259:     return SetupForDirectTextRun(aContext, mDrawScale);
 13259:   }
 13259:   /**
 13259:    * Try to set up aContext so we can measure the whole textrun at once.
 13760:    * This applies any global transform requested by SetInitialMatrix,
 13259:    * then applies the positioning of the text, then applies a scale
 13259:    * from appunits to device pixels so drawing in appunits works.
 13259:    * Returns false if drawing the whole textrun at once is impossible due
 13259:    * to individual positioning and/or rotation of glyphs.
 13259:    */
 79445:   bool SetupForDirectTextRunMetrics(gfxContext *aContext) {
 13259:     return SetupForDirectTextRun(aContext, mMetricsScale);
 13259:   }
 57021:   /**
 57021:    * We are scaling the glyphs up/down to the size we want so we need to
 57021:    * inverse scale the outline widths of those glyphs so they are invariant
 57021:    */
 87411:   void SetLineWidthAndDashesForDrawing(gfxContext *aContext) {
 57021:     aContext->SetLineWidth(aContext->CurrentLineWidth() / mDrawScale);
 87411:     AutoFallibleTArray<gfxFloat, 10> dashes;
 87411:     gfxFloat dashOffset;
 87411:     if (aContext->CurrentDash(dashes, &dashOffset)) {
108991:       for (uint32_t i = 0; i <  dashes.Length(); i++) {
 87411:         dashes[i] /= mDrawScale;
 87411:       }
 87411:       aContext->SetDash(dashes.Elements(), dashes.Length(), dashOffset / mDrawScale);
 87411:     }
 57021:   }
 13259: 
 13259:   /**
 77019:    * Returns the index of the next cluster in the string that should be drawn,
108991:    * or InvalidCluster() (i.e. uint32_t(-1)) if there is no such cluster.
 13259:    */
108991:   uint32_t NextCluster();
 60286: 
 13259:   /**
 60286:    * Returns the length of the current cluster (usually 1, unless there
 60286:    * are combining marks)
 60286:    */
108991:   uint32_t ClusterLength();
 60286: 
 60286:   /**
 60286:    * Repeated calls NextCluster until it returns aIndex (i.e. aIndex is the
 13259:    * current drawable character). Returns false if that never happens
 13259:    * (because aIndex is before or equal to the current character, or
 13259:    * out of bounds, or not drawable).
 13259:    */
108991:   bool AdvanceToCharacter(uint32_t aIndex);
 13259: 
 13259:   /**
 56945:    * Resets the iterator to the beginning of the string.
 56945:    */
 56945:   void Reset() {
 56945:     // There are two ways mInError can be set
 56945:     // a) If there was a problem creating the iterator (mCurrentChar == -1)
 56945:     // b) If we ran off the end of the string (mCurrentChar != -1)
 56945:     // We can only reset the mInError flag in case b)
 77019:     if (mCurrentChar != InvalidCluster()) {
 77019:       mCurrentChar = InvalidCluster();
 80486:       mInError = false;
 56945:     }
 56945:   }
 56945: 
 56945:   /**
 13259:    * Set up aContext for glyph drawing. This applies any global transform
 13760:    * requested by SetInitialMatrix, then applies any positioning and
 13259:    * rotation for the current character.
 13259:    */
 13259:   void SetupForDrawing(gfxContext *aContext) {
 13259:     return SetupFor(aContext, mDrawScale);
 13259:   }
 13259:   /**
 13259:    * Set up aContext for glyph measuring. This applies any global transform
 13760:    * requested by SetInitialMatrix, then applies any positioning and
 13259:    * rotation for the current character, then applies a scale from appunits
 13259:    * to device pixels so that drawing in appunits sizes works.
 13259:    */
 13259:   void SetupForMetrics(gfxContext *aContext) {
 13259:     return SetupFor(aContext, mMetricsScale);
 13259:   }
 13259:   /**
 13259:    * Get the raw position data for the current character.
 13259:    */
 13259:   CharacterPosition GetPositionData();
 13259: 
 77019:   /**
 77019:    * "Invalid" cluster index returned to indicate error state
 77019:    */
108991:   uint32_t InvalidCluster() {
108991:     return uint32_t(-1);
 77019:   }
 77019: 
 13259: private:
 79445:   bool SetupForDirectTextRun(gfxContext *aContext, float aScale);
 13259:   void SetupFor(gfxContext *aContext, float aScale);
 13259: 
 13259:   nsSVGGlyphFrame *mSource;
 13259:   nsAutoTArray<CharacterPosition,80> mPositions;
 13259:   gfxMatrix mInitialMatrix;
 13259:   // Textrun advance width from start to mCurrentChar, in appunits
 13259:   gfxFloat mCurrentAdvance;
108991:   uint32_t mCurrentChar;
 13259:   float mDrawScale;
 13259:   float mMetricsScale;
 79445:   bool mInError;
 13259: };
     1: 
105956: 
105956: class nsDisplaySVGGlyphs : public nsDisplayItem {
105956: public:
105956:   nsDisplaySVGGlyphs(nsDisplayListBuilder* aBuilder,
105956:                      nsSVGGlyphFrame* aFrame)
105956:     : nsDisplayItem(aBuilder, aFrame)
105956:   {
105956:     MOZ_COUNT_CTOR(nsDisplaySVGGlyphs);
105956:     NS_ABORT_IF_FALSE(aFrame, "Must have a frame!");
105956:   }
105956: #ifdef NS_BUILD_REFCNT_LOGGING
105956:   virtual ~nsDisplaySVGGlyphs() {
105956:     MOZ_COUNT_DTOR(nsDisplaySVGGlyphs);
105956:   }
105956: #endif
105956: 
105956:   NS_DISPLAY_DECL_NAME("nsDisplaySVGGlyphs", TYPE_SVG_GLYPHS)
105956: 
105956:   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
105956:                        HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames);
105956:   virtual void Paint(nsDisplayListBuilder* aBuilder,
105956:                      nsRenderingContext* aCtx);
105956: };
105956: 
105956: void
105956: nsDisplaySVGGlyphs::HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
105956:                             HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames)
105956: {
105956:   nsSVGGlyphFrame *frame = static_cast<nsSVGGlyphFrame*>(mFrame);
105956:   nsPoint pointRelativeToReferenceFrame = aRect.Center();
105956:   // ToReferenceFrame() includes frame->GetPosition(), our user space position.
105956:   nsPoint userSpacePt = pointRelativeToReferenceFrame -
105956:                           (ToReferenceFrame() - frame->GetPosition());
105956:   if (frame->GetFrameForPoint(userSpacePt)) {
105956:     aOutFrames->AppendElement(frame);
105956:   }
105956: }
105956: 
105956: void
105956: nsDisplaySVGGlyphs::Paint(nsDisplayListBuilder* aBuilder,
105956:                           nsRenderingContext* aCtx)
105956: {
105956:   // ToReferenceFrame includes our mRect offset, but painting takes
105956:   // account of that too. To avoid double counting, we subtract that
105956:   // here.
105956:   nsPoint offset = ToReferenceFrame() - mFrame->GetPosition();
105956: 
105956:   aCtx->PushState();
105956:   aCtx->Translate(offset);
106838:   static_cast<nsSVGGlyphFrame*>(mFrame)->PaintSVG(aCtx, nullptr);
105956:   aCtx->PopState();
105956: }
105956: 
     1: //----------------------------------------------------------------------
     1: // Implementation
     1: 
     1: nsIFrame*
 23953: NS_NewSVGGlyphFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
     1: {
     1:   return new (aPresShell) nsSVGGlyphFrame(aContext);
     1: }
     1: 
 32423: NS_IMPL_FRAMEARENA_HELPERS(nsSVGGlyphFrame)
 32423: 
     1: //----------------------------------------------------------------------
 23554: // nsQueryFrame methods
     1: 
 23554: NS_QUERYFRAME_HEAD(nsSVGGlyphFrame)
 23554:   NS_QUERYFRAME_ENTRY(nsISVGGlyphFragmentNode)
 23554:   NS_QUERYFRAME_ENTRY(nsISVGChildFrame)
 23554: NS_QUERYFRAME_TAIL_INHERITING(nsSVGGlyphFrameBase)
     1: 
     1: //----------------------------------------------------------------------
     1: // nsIFrame methods
     1: 
     1: NS_IMETHODIMP
 31131: nsSVGGlyphFrame::CharacterDataChanged(CharacterDataChangeInfo* aInfo)
     1: {
 93574:   // NotifyGlyphMetricsChange takes care of calling
 93574:   // nsSVGUtils::InvalidateAndScheduleBoundsUpdate on the appropriate frames.
 93574: 
 93574:   NotifyGlyphMetricsChange();
 93574: 
 13259:   ClearTextRun();
 80413:   if (IsTextEmpty()) {
 93574:     // The one time that NotifyGlyphMetricsChange fails to call
 93574:     // nsSVGUtils::InvalidateAndScheduleBoundsUpdate properly is when all our
 93574:     // text is gone, since it skips empty frames. So we have to invalidate
 93574:     // ourself.
 93574:     nsSVGUtils::InvalidateBounds(this);
 80413:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 13259: // Usable font size range in devpixels / user-units
 13259: #define CLAMP_MIN_SIZE 8
 13259: #define CLAMP_MAX_SIZE 200
 13259: #define PRECISE_SIZE   200
 13259: 
 20441: /* virtual */ void
 20836: nsSVGGlyphFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
     1: {
 20836:   nsSVGGlyphFrameBase::DidSetStyleContext(aOldStyleContext);
 16307: 
 16307:   if (!(GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
 13259:     ClearTextRun();
 14042:     NotifyGlyphMetricsChange();
 16307:   }
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsSVGGlyphFrame::IsSelectable(bool* aIsSelectable,
108991:                               uint8_t* aSelectStyle) const
     1: {
     1:   nsresult rv = nsSVGGlyphFrameBase::IsSelectable(aIsSelectable, aSelectStyle);
     1: #if defined(DEBUG) && defined(SVG_DEBUG_SELECTION)
     1:   printf("nsSVGGlyphFrame(%p)::IsSelectable()=(%d,%d)\n", this, *aIsSelectable, aSelectStyle);
     1: #endif
     1:   return rv;
     1: }
     1: 
 23953: NS_IMETHODIMP
 23953: nsSVGGlyphFrame::Init(nsIContent* aContent,
 23953:                       nsIFrame* aParent,
 23953:                       nsIFrame* aPrevInFlow)
 23953: {
 26734: #ifdef DEBUG
 23953:   NS_ASSERTION(aParent, "null parent");
 23953: 
 23953:   nsIFrame* ancestorFrame = nsSVGUtils::GetFirstNonAAncestorFrame(aParent);
 23953:   NS_ASSERTION(ancestorFrame, "Must have ancestor");
 23953: 
 29052:   nsSVGTextContainerFrame *metrics = do_QueryFrame(ancestorFrame);
 23953:   NS_ASSERTION(metrics,
 23953:                "trying to construct an SVGGlyphFrame for an invalid container");
 23953: 
 23953:   NS_ASSERTION(aContent->IsNodeOfType(nsINode::eTEXT),
 23953:                "trying to construct an SVGGlyphFrame for wrong content element");
 26734: #endif /* DEBUG */
 23953: 
 23953:   return nsSVGGlyphFrameBase::Init(aContent, aParent, aPrevInFlow);
 23953: }
 23953: 
     1: nsIAtom *
     1: nsSVGGlyphFrame::GetType() const
     1: {
     1:   return nsGkAtoms::svgGlyphFrame;
     1: }
     1: 
105956: NS_IMETHODIMP
105956: nsSVGGlyphFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
105956:                                   const nsRect&           aDirtyRect,
105956:                                   const nsDisplayListSet& aLists)
105956: {
105956:   if (GetStyleFont()->mFont.size <= 0) {
105956:     return NS_OK;
105956:   }
105956:   return aLists.Content()->AppendNewToTop(
105956:            new (aBuilder) nsDisplaySVGGlyphs(aBuilder, this));
105956: }
105956: 
     1: //----------------------------------------------------------------------
     1: // nsISVGChildFrame methods
     1: 
     1: NS_IMETHODIMP
 91412: nsSVGGlyphFrame::PaintSVG(nsRenderingContext *aContext,
 20652:                           const nsIntRect *aDirtyRect)
     1: {
     1:   if (!GetStyleVisibility()->IsVisible())
     1:     return NS_OK;
     1: 
103331:   if (GetStyleFont()->mFont.size <= 0) {
103331:     // Don't even try to paint, or cairo will go into an error state.
103331:     return NS_OK;
103331:   }
103331: 
103332:   AutoCanvasTMForMarker autoCanvasTMFor(this, FOR_PAINTING);
103332: 
 91412:   gfxContext *gfx = aContext->ThebesContext();
108991:   uint16_t renderMode = SVGAutoRenderState::GetRenderMode(aContext);
     1: 
 27708:   switch (GetStyleSVG()->mTextRendering) {
 27708:   case NS_STYLE_TEXT_RENDERING_OPTIMIZESPEED:
 27708:     gfx->SetAntialiasMode(gfxContext::MODE_ALIASED);
 27708:     break;
 27708:   default:
 27708:     gfx->SetAntialiasMode(gfxContext::MODE_COVERAGE);
 27708:     break;
 27708:   }
 27708: 
 91412:   if (renderMode != SVGAutoRenderState::NORMAL) {
102099:     NS_ABORT_IF_FALSE(renderMode == SVGAutoRenderState::CLIP ||
102099:                       renderMode == SVGAutoRenderState::CLIP_MASK,
102099:                       "Unknown render mode");
102057:     gfxContextMatrixAutoSaveRestore matrixAutoSaveRestore(gfx);
103332:     SetupGlobalTransform(gfx, FOR_PAINTING);
 13760: 
 80486:     CharacterIterator iter(this, true);
106707:     if (!iter.SetInitialMatrix(gfx)) {
106707:       return NS_OK;
106707:     }
 13259: 
     1:     if (GetClipRule() == NS_STYLE_FILL_RULE_EVENODD)
   630:       gfx->SetFillRule(gfxContext::FILL_RULE_EVEN_ODD);
     1:     else
   630:       gfx->SetFillRule(gfxContext::FILL_RULE_WINDING);
     1: 
 91412:     if (renderMode == SVGAutoRenderState::CLIP_MASK) {
   630:       gfx->SetColor(gfxRGBA(1.0f, 1.0f, 1.0f, 1.0f));
 89450:       DrawCharacters(&iter, gfx, gfxFont::GLYPH_FILL);
     1:     } else {
 89450:       DrawCharacters(&iter, gfx, gfxFont::GLYPH_PATH);
     1:     }
     1: 
     1:     return NS_OK;
     1:   }
     1: 
 13760:   // We are adding patterns or gradients to the context. Save
 13760:   // it so we don't leak them into the next object we draw
 13259:   gfx->Save();
103332:   SetupGlobalTransform(gfx, FOR_PAINTING);
 13760: 
 80486:   CharacterIterator iter(this, true);
106707:   if (!iter.SetInitialMatrix(gfx)) {
106707:     gfx->Restore();
106707:     return NS_OK;
106707:   }
 13259: 
111297:   gfxTextObjectPaint *outerObjectPaint =
111297:     (gfxTextObjectPaint*)aContext->GetUserData(&gfxTextObjectPaint::sUserDataKey);
111297: 
111297:   nsAutoPtr<gfxTextObjectPaint> objectPaint;
111297:   DrawMode drawMode = SetupCairoState(gfx, outerObjectPaint, getter_Transfers(objectPaint));
 89450: 
 89450:   if (drawMode) {
111297:     DrawCharacters(&iter, gfx, drawMode, objectPaint);
     1:   }
     1:   
   630:   gfx->Restore();
     1: 
     1:   return NS_OK;
     1: }
     1: 
 18367: NS_IMETHODIMP_(nsIFrame*)
 18367: nsSVGGlyphFrame::GetFrameForPoint(const nsPoint &aPoint)
     1: {
108991:   uint16_t hitTestFlags = GetHitTestFlags();
 73614:   if (!hitTestFlags) {
106838:     return nullptr;
     1:   }
     1: 
103332:   AutoCanvasTMForMarker autoCanvasTMFor(this, FOR_HIT_TESTING);
103332: 
102058:   nsRefPtr<gfxContext> tmpCtx = MakeTmpCtx();
103332:   SetupGlobalTransform(tmpCtx, FOR_HIT_TESTING);
 80486:   CharacterIterator iter(this, true);
106707:   if (!iter.SetInitialMatrix(tmpCtx)) {
106838:     return nullptr;
106707:   }
 61489: 
 61489:   // The SVG 1.1 spec says that text is hit tested against the character cells
 61489:   // of the text, not the fill and stroke. See the section starting "For text
 61489:   // elements..." here:
 61489:   //
 61489:   //   http://www.w3.org/TR/SVG11/interact.html#PointerEventsProperty
 61489:   //
 73614:   // Currently we just test the character cells if GetHitTestFlags says we're
 61489:   // supposed to be testing either the fill OR the stroke:
 61489: 
108991:   uint32_t i;
 77019:   while ((i = iter.NextCluster()) != iter.InvalidCluster()) {
 61489:     gfxTextRun::Metrics metrics =
 61489:     mTextRun->MeasureText(i, iter.ClusterLength(),
106838:                           gfxFont::LOOSE_INK_EXTENTS, nullptr, nullptr);
102058:     iter.SetupForMetrics(tmpCtx);
102058:     tmpCtx->Rectangle(metrics.mBoundingBox);
 61489:   }
 61489: 
 61489:   gfxPoint userSpacePoint =
102058:     tmpCtx->DeviceToUser(gfxPoint(PresContext()->AppUnitsToGfxUnits(aPoint.x),
 61489:                                   PresContext()->AppUnitsToGfxUnits(aPoint.y)));
 61489: 
 79445:   bool isHit = false;
 73614:   if (hitTestFlags & SVG_HIT_TEST_FILL || hitTestFlags & SVG_HIT_TEST_STROKE) {
102058:     isHit = tmpCtx->PointInFill(userSpacePoint);
 61489:   }
 61489: 
 61489:   // If isHit is false, we may also want to fill and stroke the text to check
 61489:   // whether the pointer is over an area of fill or stroke that lies outside
 61489:   // the character cells. (With a thick stroke, or with fonts like Zapfino, such
 61489:   // areas may be very significant.) This is what Opera appears to do, but
 61489:   // currently we do not.
 61489: 
 61489:   if (isHit && nsSVGUtils::HitTestClip(this, aPoint))
 18367:     return this;
     1: 
106838:   return nullptr;
     1: }
     1: 
     1: NS_IMETHODIMP_(nsRect)
     1: nsSVGGlyphFrame::GetCoveredRegion()
     1: {
106157:   return nsSVGUtils::TransformFrameRectToOuterSVG(
106157:                        mRect, GetCanvasTM(FOR_OUTERSVG_TM), PresContext());
     1: }
     1: 
 93574: void
106052: nsSVGGlyphFrame::ReflowSVG()
     1: {
106052:   NS_ASSERTION(nsSVGUtils::OuterSVGIsCallingReflowSVG(this),
106052:                "This call is probably a wasteful mistake");
 93574: 
 93574:   NS_ABORT_IF_FALSE(!(GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD),
106052:                     "ReflowSVG mechanism not designed for this");
 93574: 
 68639:   mRect.SetEmpty();
 21217: 
108991:   uint32_t flags = nsSVGUtils::eBBoxIncludeFill |
104244:                    nsSVGUtils::eBBoxIncludeStroke |
104244:                    nsSVGUtils::eBBoxIncludeMarkers;
104244:   // Our "visual" overflow rect needs to be valid for building display lists
104244:   // for hit testing, which means that for certain values of 'pointer-events'
104244:   // it needs to include the geometry of the fill or stroke even when the fill/
104244:   // stroke don't actually render (e.g. when stroke="none" or
104244:   // stroke-opacity="0"). GetHitTestFlags() accounts for 'pointer-events'.
108991:   uint16_t hitTestFlags = GetHitTestFlags();
104244:   if ((hitTestFlags & SVG_HIT_TEST_FILL)) {
104244:    flags |= nsSVGUtils::eBBoxIncludeFillGeometry;
104244:   }
104244:   if ((hitTestFlags & SVG_HIT_TEST_STROKE)) {
104244:    flags |= nsSVGUtils::eBBoxIncludeStrokeGeometry;
104244:   }
104244:   gfxRect extent = GetBBoxContribution(gfxMatrix(), flags);
     1: 
 21217:   if (!extent.IsEmpty()) {
 89877:     mRect = nsLayoutUtils::RoundGfxRectToAppRect(extent, 
 90353:               PresContext()->AppUnitsPerCSSPixel());
 21217:   }
 21217: 
103922:   // We only invalidate if we are dirty, if our outer-<svg> has already had its
103922:   // initial reflow (since if it hasn't, its entire area will be invalidated
103922:   // when it gets that initial reflow), and if our parent is not dirty (since
103922:   // if it is, then it will invalidate its entire new area, which will include
103922:   // our new area).
103922:   bool invalidate = (mState & NS_FRAME_IS_DIRTY) &&
103922:     !(GetParent()->GetStateBits() &
103922:        (NS_FRAME_FIRST_REFLOW | NS_FRAME_IS_DIRTY));
103922: 
 98711:   nsRect overflow = nsRect(nsPoint(0,0), mRect.Size());
 98711:   nsOverflowAreas overflowAreas(overflow, overflow);
 98711:   FinishAndStoreOverflow(overflowAreas, mRect.Size());
 98711: 
     1:   mState &= ~(NS_FRAME_FIRST_REFLOW | NS_FRAME_IS_DIRTY |
     1:               NS_FRAME_HAS_DIRTY_CHILDREN);
     1: 
103922:   if (invalidate) {
 98711:     // XXXSDL Let FinishAndStoreOverflow do this.
 93574:     nsSVGUtils::InvalidateBounds(this, true);
 93573:   }
     1: }  
     1: 
 10661: void
108991: nsSVGGlyphFrame::NotifySVGChanged(uint32_t aFlags)
     1: {
 92020:   NS_ABORT_IF_FALSE(aFlags & (TRANSFORM_CHANGED | COORD_CONTEXT_CHANGED),
 92020:                     "Invalidation logic may need adjusting");
 92020: 
102793:   // Ancestor changes can't affect how we render from the perspective of
102793:   // any rendering observers that we may have, so we don't need to
102793:   // invalidate them. We also don't need to invalidate ourself, since our
102793:   // changed ancestor will have invalidated its entire area, which includes
102793:   // our area.
102793:   // XXXjwatt: seems to me that our ancestor's change could change our glyph
102793:   // metrics, in which case we should call NotifyGlyphMetricsChange instead.
106052:   nsSVGUtils::ScheduleReflowSVG(this);
 93574: 
 13259:   if (aFlags & TRANSFORM_CHANGED) {
 13259:     ClearTextRun();
 13259:   }
     1: }
     1: 
 89454: void
 13259: nsSVGGlyphFrame::AddBoundingBoxesToPath(CharacterIterator *aIter,
 13259:                                         gfxContext *aContext)
 13259: {
 13259:   if (aIter->SetupForDirectTextRunMetrics(aContext)) {
 13259:     gfxTextRun::Metrics metrics =
 13259:       mTextRun->MeasureText(0, mTextRun->GetLength(),
106838:                             gfxFont::LOOSE_INK_EXTENTS, nullptr, nullptr);
 13259:     aContext->Rectangle(metrics.mBoundingBox);
 13259:     return;
 13259:   }
 13259: 
108991:   uint32_t i;
 77019:   while ((i = aIter->NextCluster()) != aIter->InvalidCluster()) {
 13259:     aIter->SetupForMetrics(aContext);
 13259:     gfxTextRun::Metrics metrics =
 60286:       mTextRun->MeasureText(i, aIter->ClusterLength(),
106838:                             gfxFont::LOOSE_INK_EXTENTS, nullptr, nullptr);
 13259:     aContext->Rectangle(metrics.mBoundingBox);
 13259:   }
 13259: }
 13259: 
 13259: void
 89450: nsSVGGlyphFrame::DrawCharacters(CharacterIterator *aIter,
 89450:                                 gfxContext *aContext,
 89450:                                 DrawMode aDrawMode,
111295:                                 gfxTextObjectPaint *aObjectPaint)
 13259: {
 89450:   if (aDrawMode & gfxFont::GLYPH_STROKE) {
 89450:     aIter->SetLineWidthAndDashesForDrawing(aContext);
 89450:   }
 89450: 
 13259:   if (aIter->SetupForDirectTextRunDrawing(aContext)) {
 89450:     mTextRun->Draw(aContext, gfxPoint(0, 0), aDrawMode, 0,
111295:                    mTextRun->GetLength(), nullptr, nullptr, aObjectPaint);
 13259:     return;
 13259:   }
 13259: 
108991:   uint32_t i;
 77019:   while ((i = aIter->NextCluster()) != aIter->InvalidCluster()) {
 13259:     aIter->SetupForDrawing(aContext);
 89450:     mTextRun->Draw(aContext, gfxPoint(0, 0), aDrawMode, i,
111295:                    aIter->ClusterLength(), nullptr, nullptr, aObjectPaint);
 13259:   }
 13259: }
 13259: 
 95489: SVGBBox
 79556: nsSVGGlyphFrame::GetBBoxContribution(const gfxMatrix &aToBBoxUserspace,
108991:                                      uint32_t aFlags)
     1: {
106707:   SVGBBox bbox;
106707: 
 78868:   if (mOverrideCanvasTM) {
 78868:     *mOverrideCanvasTM = aToBBoxUserspace;
 78868:   } else {
 78868:     mOverrideCanvasTM = new gfxMatrix(aToBBoxUserspace);
 78868:   }
     1: 
 13259:   nsRefPtr<gfxContext> tmpCtx = MakeTmpCtx();
103332:   SetupGlobalTransform(tmpCtx, FOR_OUTERSVG_TM);
 80486:   CharacterIterator iter(this, true);
106707:   if (!iter.SetInitialMatrix(tmpCtx)) {
106707:     return bbox;
106707:   }
 35017:   AddBoundingBoxesToPath(&iter, tmpCtx);
 27899:   tmpCtx->IdentityMatrix();
     1: 
106838:   mOverrideCanvasTM = nullptr;
 27899: 
104173:   // Be careful when replacing the following logic to get the fill and stroke
104173:   // extents independently (instead of computing the stroke extents from the
104173:   // path extents). You may think that you can just use the stroke extents if
104173:   // there is both a fill and a stroke. In reality it's necessary to calculate
104173:   // both the fill and stroke extents, and take the union of the two. There are
104173:   // two reasons for this:
104173:   //
104173:   // # Due to stroke dashing, in certain cases the fill extents could actually
104173:   //   extend outside the stroke extents.
104173:   // # If the stroke is very thin, cairo won't paint any stroke, and so the
104173:   //   stroke bounds that it will return will be empty.
104173:   //
104173:   // Another thing to be aware of is that under AddBoundingBoxesToPath the
104173:   // gfxContext has SetLineWidth() called on it, so if we want to ask the
104173:   // gfxContext for *stroke* extents, we'll need to wrap the
104173:   // AddBoundingBoxesToPath() call with CurrentLineWidth()/SetLineWidth()
104173:   // calls to record and then reset the stroke width.
104173: 
 79556:   gfxRect pathExtents = tmpCtx->GetUserPathExtent();
 79556: 
 79556:   // Account for fill:
104244:   if ((aFlags & nsSVGUtils::eBBoxIncludeFillGeometry) ||
104244:       ((aFlags & nsSVGUtils::eBBoxIncludeFill) &&
 79556:        GetStyleSVG()->mFill.mType != eStyleSVGPaintType_None)) {
 79556:     bbox = pathExtents;
 79556:   }
 79556: 
 79556:   // Account for stroke:
104244:   if ((aFlags & nsSVGUtils::eBBoxIncludeStrokeGeometry) ||
108089:       ((aFlags & nsSVGUtils::eBBoxIncludeStroke) &&
108089:        nsSVGUtils::HasStroke(this))) {
106707:     bbox.UnionEdges(nsSVGUtils::PathExtentsToMaxStrokeExtents(pathExtents,
 89878:                                                               this,
 89878:                                                               aToBBoxUserspace));
 79556:   }
 79556: 
 79556:   return bbox;
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: // nsSVGGeometryFrame methods:
     1: 
 27899: gfxMatrix
108991: nsSVGGlyphFrame::GetCanvasTM(uint32_t aFor)
     1: {
 27899:   if (mOverrideCanvasTM) {
 78868:     return *mOverrideCanvasTM;
 27899:   }
103332:   if (!(GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD)) {
103332:     if ((aFor == FOR_PAINTING && NS_SVGDisplayListPaintingEnabled()) ||
103332:         (aFor == FOR_HIT_TESTING && NS_SVGDisplayListHitTestingEnabled())) {
103332:       return nsSVGIntegrationUtils::GetCSSPxToDevPxMatrix(this);
103332:     }
103332:   }
     1:   NS_ASSERTION(mParent, "null parent");
103332:   return static_cast<nsSVGContainerFrame*>(mParent)->GetCanvasTM(aFor);
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: // nsSVGGlyphFrame methods:
     1: 
 79445: bool
     1: nsSVGGlyphFrame::GetCharacterData(nsAString & aCharacterData)
     1: {
     1:   nsAutoString characterData;
 35581:   mContent->AppendTextTo(characterData);
     1: 
 69324:   if (mCompressWhitespace) {
 69324:     characterData.CompressWhitespace(mTrimLeadingWhitespace,
 69324:                                      mTrimTrailingWhitespace);
     1:   } else {
     1:     nsAString::iterator start, end;
     1:     characterData.BeginWriting(start);
     1:     characterData.EndWriting(end);
     1:     while (start != end) {
     1:       if (NS_IsAsciiWhitespace(*start))
     1:         *start = ' ';
     1:       ++start;
     1:     }
     1:   }
     1:   aCharacterData = characterData;
     1: 
     1:   return !characterData.IsEmpty();
     1: }
     1: 
 79445: bool
 13259: nsSVGGlyphFrame::GetCharacterPositions(nsTArray<CharacterPosition>* aCharacterPositions,
 13259:                                        float aMetricsScale)
     1: {
108991:   uint32_t strLength = mTextRun->GetLength();
 69410:   NS_ABORT_IF_FALSE(strLength > 0, "no text");
 40002: 
 40002:   const gfxFloat radPerDeg = M_PI / 180.0;
 40002: 
 54300:   nsTArray<float> xList, yList;
 55785:   GetEffectiveXY(strLength, xList, yList);
 54300:   nsTArray<float> dxList, dyList;
 55785:   GetEffectiveDxDy(strLength, dxList, dyList);
 54300:   nsTArray<float> rotateList;
 55785:   GetEffectiveRotate(strLength, rotateList);
 40033: 
 40002:   gfxPoint pos = mPosition;
 54300:   gfxFloat angle = 0.0;
     1: 
     1:   nsSVGTextPathFrame *textPath = FindTextPathParent();
     1: 
 40002:   if (textPath) {
   565:     nsRefPtr<gfxFlattenedPath> data = textPath->GetFlattenedPath();
     1: 
 40002:     // textPath frame, but invalid target
     1:     if (!data)
 80486:       return false;
     1: 
 40002:     if (!aCharacterPositions->SetLength(strLength))
 80486:       return false;
 40002: 
 82261:     gfxFloat pathScale = textPath->GetOffsetScale();
 40002: 
 40002:     CharacterPosition *cp = aCharacterPositions->Elements();
 40002: 
   724:     gfxFloat length = data->GetLength();
 40002: 
108991:     for (uint32_t i = 0; i < strLength; i++) {
 40002:       gfxFloat halfAdvance =
106838:         mTextRun->GetAdvanceWidth(i, 1, nullptr)*aMetricsScale / 2.0;
 40002: 
 54300:       // use only x position for horizontal writing
 54300:       if (i > 0 && i < xList.Length()) {
 54300:         pos.x = xList[i];
 54300:       }
 54300:       pos.x += (i > 0 && i < dxList.Length()) ? dxList[i] * pathScale : 0.0;
 54300:       pos.y += (i > 0 && i < dyList.Length()) ? dyList[i] * pathScale : 0.0;
 54300:       if (i < rotateList.Length()) {
 54300:         angle = rotateList[i] * radPerDeg;
 54300:       }
 40002: 
 40002:       // check that we're within the path boundaries
 40002:       cp[i].draw = (pos.x + halfAdvance >= 0.0 &&
 40002:                     pos.x + halfAdvance <= length);
 40002: 
 40002:       if (cp[i].draw) {
 40002: 
 40002:         // add y (normal)
 40002:         // add rotation
 40002:         // move point back along tangent
 40002:         gfxPoint pt = data->FindPoint(gfxPoint(pos.x + halfAdvance, pos.y),
 40002:                                       &(cp[i].angle));
 40002:         cp[i].pos =
 40002:           pt - gfxPoint(cos(cp[i].angle), sin(cp[i].angle)) * halfAdvance;
 54300:         cp[i].angle += angle;
 40002:       }
 40002:       pos.x += 2 * halfAdvance;
 40002:     }
 80486:     return true;
 40002:   }
 40002: 
 54300:   if (xList.Length() <= 1 &&
 54300:       yList.Length() <= 1 &&
 54300:       dxList.Length() <= 1 &&
 54300:       dyList.Length() <= 1 &&
 54300:       rotateList.IsEmpty()) {
 40002:     // simple text without individual positioning
 80486:     return true;
 40002:   }
     1: 
 13259:   if (!aCharacterPositions->SetLength(strLength))
 80486:     return false;
   630: 
 13259:   CharacterPosition *cp = aCharacterPositions->Elements();
     1: 
108991:   uint16_t anchor = GetTextAnchor();
     1: 
108991:   for (uint32_t i = 0; i < strLength; i++) {
 80486:     cp[i].draw = true;
     1: 
106838:     gfxFloat advance = mTextRun->GetAdvanceWidth(i, 1, nullptr)*aMetricsScale;
 54300:     if (xList.Length() > 1 && i < xList.Length()) {
 47840:       pos.x = xList[i];
 54300: 
 40002:       // apply text-anchor to character
 40002:       if (anchor == NS_STYLE_TEXT_ANCHOR_MIDDLE)
 40002:         pos.x -= advance/2.0;
 40002:       else if (anchor == NS_STYLE_TEXT_ANCHOR_END)
 40002:         pos.x -= advance;
     1:     }
 54300:     if (yList.Length() > 1 && i < yList.Length()) {
 47840:       pos.y = yList[i];
     1:     }
 54300:     pos.x += (i > 0 && i < dxList.Length()) ? dxList[i] : 0.0;
 54300:     pos.y += (i > 0 && i < dyList.Length()) ? dyList[i] : 0.0;
 40002:     cp[i].pos = pos;
 40002:     pos.x += advance;
 54300:     if (i < rotateList.Length()) {
 54300:       angle = rotateList[i] * radPerDeg;
 54300:     }
 54300:     cp[i].angle = angle;
 40002:   }
 80486:   return true;
     1: }
     1: 
108991: uint32_t
108991: nsSVGGlyphFrame::GetTextRunFlags(uint32_t strLength)
 55972: {
 55972:   // Keep the logic here consistent with GetCharacterPositions
 55972: 
 55972:   if (FindTextPathParent()) {
 55972:     return gfxTextRunFactory::TEXT_DISABLE_OPTIONAL_LIGATURES;
 55972:   }
 55972: 
 55972:   nsTArray<float> xList, yList;
 55972:   GetEffectiveXY(strLength, xList, yList);
 55972:   nsTArray<float> dxList, dyList;
 55972:   GetEffectiveDxDy(strLength, dxList, dyList);
 55972:   nsTArray<float> rotateList;
 55972:   GetEffectiveRotate(strLength, rotateList);
 55972: 
 55972:   return (xList.Length() > 1 ||
 55972:           yList.Length() > 1 ||
 55972:           dxList.Length() > 1 ||
 55972:           dyList.Length() > 1 ||
 55972:           !rotateList.IsEmpty()) ?
 55972:     gfxTextRunFactory::TEXT_DISABLE_OPTIONAL_LIGATURES : 0;
 55972: }
 55972: 
 29310: float
108991: nsSVGGlyphFrame::GetSubStringAdvance(uint32_t aCharnum, 
108991:                                      uint32_t aFragmentChars,
 40002:                                      float aMetricsScale)
 29310: {
 40002:   if (aFragmentChars == 0)
 29310:     return 0.0f;
 29310:  
 40002:   gfxFloat advance =
106838:     mTextRun->GetAdvanceWidth(aCharnum, aFragmentChars, nullptr) * aMetricsScale;
 40002: 
 54300:   nsTArray<float> dxlist, notUsed;
 55785:   GetEffectiveDxDy(mTextRun->GetLength(), dxlist, notUsed);
108991:   uint32_t dxcount = dxlist.Length();
 40002:   if (dxcount) {
 40002:     gfxFloat pathScale = 1.0;
 40002:     nsSVGTextPathFrame *textPath = FindTextPathParent();
 40002:     if (textPath)
 82261:       pathScale = textPath->GetOffsetScale();
 40002:     if (dxcount > aFragmentChars) 
 40002:       dxcount = aFragmentChars;
108991:     for (uint32_t i = aCharnum; i < dxcount; i++) {
 47840:       advance += dxlist[i] * pathScale;
 40002:     }
 40002:   }
 40002: 
 29310:   return float(advance);
 29310: }
 29310: 
 29310: gfxFloat
 40002: nsSVGGlyphFrame::GetBaselineOffset(float aMetricsScale)
 29310: {
 29310:   gfxTextRun::Metrics metrics =
 29310:     mTextRun->MeasureText(0, mTextRun->GetLength(),
106838:                           gfxFont::LOOSE_INK_EXTENTS, nullptr, nullptr);
 29310: 
108991:   uint16_t dominantBaseline;
 29310: 
 29310:   for (nsIFrame *frame = GetParent(); frame; frame = frame->GetParent()) {
 29310:     dominantBaseline = frame->GetStyleSVGReset()->mDominantBaseline;
 29310:     if (dominantBaseline != NS_STYLE_DOMINANT_BASELINE_AUTO ||
 29310:         frame->GetType() == nsGkAtoms::svgTextFrame) {
 29310:       break;
 29310:     }
 29310:   }
 29310: 
 29310:   gfxFloat baselineAppUnits;
 29310:   switch (dominantBaseline) {
 29310:   case NS_STYLE_DOMINANT_BASELINE_HANGING:
 29310:     // not really right, but the best we can do with the information provided
 29310:     // FALLTHROUGH
 29310:   case NS_STYLE_DOMINANT_BASELINE_TEXT_BEFORE_EDGE:
 29310:     baselineAppUnits = -metrics.mAscent;
 29310:     break;
 29310:   case NS_STYLE_DOMINANT_BASELINE_TEXT_AFTER_EDGE:
 29310:   case NS_STYLE_DOMINANT_BASELINE_IDEOGRAPHIC:
 29310:     baselineAppUnits = metrics.mDescent;
 29310:     break;
 29310:   case NS_STYLE_DOMINANT_BASELINE_CENTRAL:
 29310:   case NS_STYLE_DOMINANT_BASELINE_MIDDLE:
 29310:     baselineAppUnits = -(metrics.mAscent - metrics.mDescent) / 2.0;
 29310:     break;
 29310:   case NS_STYLE_DOMINANT_BASELINE_AUTO:
 29310:   case NS_STYLE_DOMINANT_BASELINE_ALPHABETIC:
 29310:     return 0.0;
 29310:   default:
 29310:     NS_WARNING("We don't know about this type of dominant-baseline");
 29310:     return 0.0;
 29310:   }
 40002:   return baselineAppUnits * aMetricsScale;
 29310: }
 29310: 
 89450: DrawMode
111297: nsSVGGlyphFrame::SetupCairoState(gfxContext *aContext,
111297:                                  gfxTextObjectPaint *aOuterObjectPaint,
111297:                                  gfxTextObjectPaint **aThisObjectPaint)
 90412: {
 89450:   DrawMode toDraw = DrawMode(0);
111297:   SVGTextObjectPaint *thisObjectPaint = new SVGTextObjectPaint();
111297: 
111302:   if (SetupCairoStroke(aContext, aOuterObjectPaint, thisObjectPaint)) {
111297:     toDraw = DrawMode(toDraw | gfxFont::GLYPH_STROKE);
111297:   }
111297: 
111297:   if (SetupCairoFill(aContext, aOuterObjectPaint, thisObjectPaint)) {
111297:     toDraw = DrawMode(toDraw | gfxFont::GLYPH_FILL);
111297:   }
111297: 
111297:   *aThisObjectPaint = thisObjectPaint;
111297: 
111297:   return toDraw;
111297: }
111297: 
111302: bool
111297: nsSVGGlyphFrame::SetupCairoStroke(gfxContext *aContext,
111297:                                   gfxTextObjectPaint *aOuterObjectPaint,
111297:                                   SVGTextObjectPaint *aThisObjectPaint)
111297: {
 89450:   const nsStyleSVG *style = GetStyleSVG();
111302:   if (style->mStroke.mType == eStyleSVGPaintType_None) {
111302:     aThisObjectPaint->SetStrokeOpacity(0.0f);
111302:     return false;
111302:   }
 89450: 
 90412:   gfxContextMatrixAutoSaveRestore matrixRestore(aContext);
 90412:   aContext->IdentityMatrix();
 89450: 
111304:   nsSVGUtils::SetupCairoStrokeHitGeometry(this, aContext, aOuterObjectPaint);
111302:   float opacity = nsSVGUtils::GetOpacity(style->mStrokeOpacitySource,
111302:                                          style->mStrokeOpacity,
111302:                                          aOuterObjectPaint);
 89450: 
111297:   SetupInheritablePaint(aContext, opacity, aOuterObjectPaint,
111297:                         aThisObjectPaint->mStrokePaint, &nsStyleSVG::mStroke,
 89450:                         nsSVGEffects::StrokeProperty());
111302: 
111302:   aThisObjectPaint->SetStrokeOpacity(opacity);
111302: 
111302:   return opacity != 0.0f;
 90413: }
 89450: 
111297: bool
111297: nsSVGGlyphFrame::SetupCairoFill(gfxContext *aContext,
111297:                                 gfxTextObjectPaint *aOuterObjectPaint,
111297:                                 SVGTextObjectPaint *aThisObjectPaint)
111297: {
111297:   const nsStyleSVG *style = GetStyleSVG();
111297:   if (style->mFill.mType == eStyleSVGPaintType_None) {
111302:     aThisObjectPaint->SetFillOpacity(0.0f);
111297:     return false;
111297:   }
111297: 
111302:   float opacity = nsSVGUtils::GetOpacity(style->mFillOpacitySource,
111302:                                          style->mFillOpacity,
111302:                                          aOuterObjectPaint);
111297: 
111297:   SetupInheritablePaint(aContext, opacity, aOuterObjectPaint,
111297:                         aThisObjectPaint->mFillPaint, &nsStyleSVG::mFill,
111297:                         nsSVGEffects::FillProperty());
111297: 
111302:   aThisObjectPaint->SetFillOpacity(opacity);
111302: 
111297:   return true;
111297: }
111297: 
111297: void
111297: nsSVGGlyphFrame::SetupInheritablePaint(gfxContext *aContext,
111302:                                        float& aOpacity,
111297:                                        gfxTextObjectPaint *aOuterObjectPaint,
111297:                                        SVGTextObjectPaint::Paint& aTargetPaint,
111297:                                        nsStyleSVGPaint nsStyleSVG::*aFillOrStroke,
111297:                                        const FramePropertyDescriptor *aProperty)
111297: {
111297:   const nsStyleSVG *style = GetStyleSVG();
111297:   nsSVGPaintServerFrame *ps =
111297:     nsSVGEffects::GetPaintServer(this, &(style->*aFillOrStroke), aProperty);
111297: 
111297:   if (ps && ps->SetupPaintServer(aContext, this, aFillOrStroke, aOpacity)) {
111297:     aTargetPaint.SetPaintServer(this, aContext->CurrentMatrix(), ps);
111297:   } else if (SetupObjectPaint(aContext, aFillOrStroke, aOpacity, aOuterObjectPaint)) {
111297:     aTargetPaint.SetObjectPaint(aOuterObjectPaint, (style->*aFillOrStroke).mType);
111297:   } else {
111297:     nscolor color = nsSVGUtils::GetFallbackOrPaintColor(aContext,
111297:                                                         GetStyleContext(),
111297:                                                         aFillOrStroke);
111297:     aTargetPaint.SetColor(color);
111297: 
111297:     aContext->SetPattern(new gfxPattern(gfxRGBA(NS_GET_R(color) / 255.0,
 89450:                                                 NS_GET_G(color) / 255.0,
 89450:                                                 NS_GET_B(color) / 255.0,
111297:                                                 NS_GET_A(color) / 255.0 * aOpacity)));
111297:   }
 89450: }
 90413: 
111297: bool
111297: nsSVGGlyphFrame::SetupObjectPaint(gfxContext *aContext,
111297:                                   nsStyleSVGPaint nsStyleSVG::*aFillOrStroke,
111302:                                   float& aOpacity,
111297:                                   gfxTextObjectPaint *aOuterObjectPaint)
111297: {
114330:   if (!aOuterObjectPaint) {
114330:     NS_WARNING("Outer object paint value used outside SVG glyph");
114330:     return false;
114330:   }
114330: 
111297:   const nsStyleSVG *style = GetStyleSVG();
111297:   const nsStyleSVGPaint &paint = style->*aFillOrStroke;
111297: 
111297:   if (paint.mType != eStyleSVGPaintType_ObjectFill &&
111297:       paint.mType != eStyleSVGPaintType_ObjectStroke) {
111297:     return false;
 89450:   }
 89450: 
111297:   nsRefPtr<gfxPattern> pattern = paint.mType == eStyleSVGPaintType_ObjectFill ?
111297:                                  aOuterObjectPaint->GetFillPattern(aOpacity) :
111297:                                  aOuterObjectPaint->GetStrokePattern(aOpacity);
111297: 
111297:   if (!pattern) {
111297:     return false;
 89450:   }
 89450: 
111297:   pattern->SetMatrix(aContext->CurrentMatrix().Multiply(pattern->GetMatrix()));
111297:   aContext->SetPattern(pattern);
111297: 
111297:   return true;
111297: }
111297: 
111297: //----------------------------------------------------------------------
111297: // SVGTextObjectPaint methods:
111297: 
111297: already_AddRefed<gfxPattern>
111297: nsSVGGlyphFrame::SVGTextObjectPaint::GetFillPattern(float aOpacity)
111297: {
111297:   return mFillPaint.GetPattern(aOpacity, &nsStyleSVG::mFill);
111297: }
111297: 
111297: already_AddRefed<gfxPattern>
111297: nsSVGGlyphFrame::SVGTextObjectPaint::GetStrokePattern(float aOpacity)
111297: {
111297:   return mStrokePaint.GetPattern(aOpacity, &nsStyleSVG::mStroke);
111297: }
111297: 
111297: already_AddRefed<gfxPattern>
111297: nsSVGGlyphFrame::SVGTextObjectPaint::Paint::GetPattern(float aOpacity,
111297:                                                        nsStyleSVGPaint nsStyleSVG::*aFillOrStroke)
111297: {
111297:   nsRefPtr<gfxPattern> pattern;
111297:   if (mPatternCache.Get(aOpacity, getter_AddRefs(pattern))) {
111297:     // Set the pattern matrix just in case it was messed with by a previous
111297:     // caller. We should get the same matrix each time a pattern is constructed
111297:     // so this should be fine.
111297:     pattern->SetMatrix(mPatternMatrix);
111297:     return pattern.forget();
111297:   }
111297: 
111297:   switch (mPaintType) {
111297:   case eStyleSVGPaintType_None:
111297:     pattern = new gfxPattern(gfxRGBA(0.0f, 0.0f, 0.0f, 0.0f));
111297:     break;
111297:   case eStyleSVGPaintType_Color:
111297:     pattern = new gfxPattern(gfxRGBA(NS_GET_R(mPaintDefinition.mColor) / 255.0,
111297:                                      NS_GET_G(mPaintDefinition.mColor) / 255.0,
111297:                                      NS_GET_B(mPaintDefinition.mColor) / 255.0,
111297:                                      NS_GET_A(mPaintDefinition.mColor) / 255.0 * aOpacity));
111297:     break;
111297:   case eStyleSVGPaintType_Server:
111297:     pattern = mPaintDefinition.mPaintServerFrame->GetPaintServerPattern(mFrame,
111297:                                                                         mContextMatrix,
111297:                                                                         aFillOrStroke,
111297:                                                                         aOpacity);
111297:     break;
111297:   case eStyleSVGPaintType_ObjectFill:
111297:     pattern = mPaintDefinition.mObjectPaint->GetFillPattern(aOpacity);
111297:     break;
111297:   case eStyleSVGPaintType_ObjectStroke:
111297:     pattern = mPaintDefinition.mObjectPaint->GetStrokePattern(aOpacity);
111297:     break;
111297:   default:
111297:     return nullptr;
111297:   }
111297: 
111297:   gfxMatrix contextInverse = mContextMatrix;
111297:   contextInverse.Invert();
111297: 
111297:   mPatternMatrix = pattern->GetMatrix().PreMultiply(contextInverse);
111297:   pattern->SetMatrix(mPatternMatrix);
111297:   mPatternCache.Put(aOpacity, pattern);
111297: 
111297:   return pattern.forget();
 89450: }
 89450: 
     1: //----------------------------------------------------------------------
     1: 
     1: // Utilities for converting from indices in the uncompressed content
     1: // element strings to compressed frame string and back:
     1: static int
     1: CompressIndex(int index, const nsTextFragment*fragment)
     1: {
     1:   int ci=0;
     1:   if (fragment->Is2b()) {
     1:     const PRUnichar *data=fragment->Get2b();
     1:     while(*data && index) {
     1:       if (XP_IS_SPACE_W(*data)){
     1:         do {
     1:           ++data;
     1:           --index;
     1:         }while(XP_IS_SPACE_W(*data) && index);
     1:       }
     1:       else {
     1:         ++data;
     1:         --index;
     1:       }
     1:       ++ci;
     1:     }
     1:   }
     1:   else {
     1:     const char *data=fragment->Get1b();
     1:     while(*data && index) {
     1:       if (XP_IS_SPACE_W(*data)){
     1:         do {
     1:           ++data;
     1:           --index;
     1:         }while(XP_IS_SPACE_W(*data) && index);
     1:       }
     1:       else {
     1:         ++data;
     1:         --index;
     1:       }
     1:       ++ci;
     1:     }
     1:   }
     1:     
     1:   return ci;
     1: }
     1: 
     1: nsresult
108991: nsSVGGlyphFrame::GetHighlight(uint32_t *charnum, uint32_t *nchars,
     1:                               nscolor *foreground, nscolor *background)
     1: {
     1:   *foreground = NS_RGB(255,255,255);
     1:   *background = NS_RGB(0,0,0); 
     1:   *charnum=0;
     1:   *nchars=0;
     1: 
 85101:   bool hasHighlight = IsSelected();
     1:   if (!hasHighlight) {
     1:     NS_ERROR("nsSVGGlyphFrame::GetHighlight() called by renderer when there is no highlight");
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
   238:   nsPresContext *presContext = PresContext();
     1: 
     1:   // The selection ranges are relative to the uncompressed text in
     1:   // the content element. We'll need the text fragment:
 35581:   const nsTextFragment *fragment = mContent->GetText();
     1:   NS_ASSERTION(fragment, "no text");
     1:   
     1:   // get the selection details 
106838:   SelectionDetails *details = nullptr;
     1:   {
 70097:     nsRefPtr<nsFrameSelection> frameSelection = presContext->PresShell()->FrameSelection();
     1:     if (!frameSelection) {
     1:       NS_ERROR("no frameselection interface");
     1:       return NS_ERROR_FAILURE;
     1:     }
     1: 
     1:     details = frameSelection->LookUpSelection(
 80486:       mContent, 0, fragment->GetLength(), false
     1:       );
     1:   }
     1: 
     1: #if defined(DEBUG) && defined(SVG_DEBUG_SELECTION)
     1:   {
     1:     SelectionDetails *dp = details;
     1:     printf("nsSVGGlyphFrame(%p)::GetHighlight() [\n", this);
     1:     while (dp) {
     1:       printf("selection detail: %d(%d)->%d(%d) type %d\n",
     1:              dp->mStart, CompressIndex(dp->mStart, fragment),
     1:              dp->mEnd, CompressIndex(dp->mEnd, fragment),
     1:              dp->mType);
     1:       dp = dp->mNext;
     1:     }
     1:     printf("]\n");
     1:       
     1:   }
     1: #endif
     1:   
     1:   if (details) {
106838:     NS_ASSERTION(details->mNext==nullptr, "can't do multiple selection ranges");
     1: 
     1:     *charnum=CompressIndex(details->mStart, fragment);
     1:     *nchars=CompressIndex(details->mEnd, fragment)-*charnum;  
     1: 
 78130:     LookAndFeel::GetColor(LookAndFeel::eColorID_TextSelectBackground,
 78130:                           background);
 78130:     LookAndFeel::GetColor(LookAndFeel::eColorID_TextSelectForeground,
 78130:                           foreground);
     1: 
     1:     SelectionDetails *dp = details;
106838:     while ((dp=details->mNext) != nullptr) {
     1:       delete details;
     1:       details = dp;
     1:     }
     1:     delete details;
     1:   }
     1:   
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: //----------------------------------------------------------------------
 69457: // Internal methods
     1: 
 69457: void
 79445: nsSVGGlyphFrame::SetGlyphPosition(gfxPoint *aPosition, bool aForceGlobalTransform)
     1: {
 40002:   float drawScale, metricsScale;
 40002: 
 54300:   nsSVGTextPathFrame *textPath = FindTextPathParent();
 54300:   // In a textPath, the 'y' attribute has no effect, so we reset 'y' here
 54300:   // to use aPosition.y for dy only
 77154:   if (textPath && textPath->GetFirstPrincipalChild() == this) {
 54300:     aPosition->y = 0.0;
 54300:   }
 54300: 
 40002:   if (!EnsureTextRun(&drawScale, &metricsScale, aForceGlobalTransform))
 40002:     return;
 40002: 
 40002:   mPosition.MoveTo(aPosition->x, aPosition->y - GetBaselineOffset(metricsScale));
 40002: 
108991:   uint32_t strLength = mTextRun->GetLength();
 54300: 
 54300:   nsTArray<float> xList, yList;
 55785:   GetEffectiveXY(strLength, xList, yList);
108991:   uint32_t xCount = NS_MIN(xList.Length(), strLength);
108991:   uint32_t yCount = NS_MIN(yList.Length(), strLength);
 54300: 
 54300:   // move aPosition to the last glyph position
 54300:   gfxFloat x = aPosition->x;
 54300:   if (xCount > 1) {
 54300:     x = xList[xCount - 1];
 54300:     x +=
106838:       mTextRun->GetAdvanceWidth(xCount - 1, 1, nullptr) * metricsScale;
 54300: 
 54300:       // advance to the last glyph
 54300:       if (strLength > xCount) {
 54300:         x +=
106838:           mTextRun->GetAdvanceWidth(xCount, strLength - xCount, nullptr) *
 54300:             metricsScale;
 54300:       }
 54300:   } else {
106838:     x += mTextRun->GetAdvanceWidth(0, strLength, nullptr) * metricsScale;
 54300:   }
 54300: 
 54300:   gfxFloat y = (textPath || yCount <= 1) ? aPosition->y : yList[yCount - 1];
 74607:   aPosition->MoveTo(x, y);
 40002: 
 40002:   gfxFloat pathScale = 1.0;
 40002:   if (textPath)
 82261:     pathScale = textPath->GetOffsetScale();
 40002: 
 54300:   nsTArray<float> dxList, dyList;
 55785:   GetEffectiveDxDy(strLength, dxList, dyList);
 40002: 
108991:   uint32_t dxcount = NS_MIN(dxList.Length(), strLength);
 54300:   if (dxcount > 0) {
 54300:     mPosition.x += dxList[0] * pathScale;
 54300:   }
108991:   for (uint32_t i = 0; i < dxcount; i++) {
 47840:     aPosition->x += dxList[i] * pathScale;
 40002:   }
108991:   uint32_t dycount = NS_MIN(dyList.Length(), strLength);
 54300:   if (dycount > 0) {
 54300:     mPosition.y += dyList[0]* pathScale;
 54300:   }
108991:   for (uint32_t i = 0; i < dycount; i++) {
 47840:     aPosition->y += dyList[i] * pathScale;
 40002:   }
     1: }
     1: 
 69457: nsresult
108991: nsSVGGlyphFrame::GetStartPositionOfChar(uint32_t charnum,
 13259:                                         nsIDOMSVGPoint **_retval)
     1: {
106838:   *_retval = nullptr;
     1: 
 80486:   CharacterIterator iter(this, false);
 13259:   if (!iter.AdvanceToCharacter(charnum))
 13259:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
 13219: 
 58893:   NS_ADDREF(*_retval = new DOMSVGPoint(iter.GetPositionData().pos));
 58893:   return NS_OK;
     1: }
     1: 
 69457: nsresult
108991: nsSVGGlyphFrame::GetEndPositionOfChar(uint32_t charnum,
 13259:                                       nsIDOMSVGPoint **_retval)
     1: {
106838:   *_retval = nullptr;
     1: 
 80486:   CharacterIterator iter(this, false);
 13259:   if (!iter.AdvanceToCharacter(charnum))
 13259:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
 13219: 
 13259:   nsRefPtr<gfxContext> tmpCtx = MakeTmpCtx();
 13259:   iter.SetupForMetrics(tmpCtx);
106838:   tmpCtx->MoveTo(gfxPoint(mTextRun->GetAdvanceWidth(charnum, 1, nullptr), 0));
 13259:   tmpCtx->IdentityMatrix();
 58893:   NS_ADDREF(*_retval = new DOMSVGPoint(tmpCtx->CurrentPoint()));
 58893:   return NS_OK;
     1: }
     1: 
 69457: nsresult
108991: nsSVGGlyphFrame::GetExtentOfChar(uint32_t charnum, nsIDOMSVGRect **_retval)
     1: {
106838:   *_retval = nullptr;
     1: 
 80486:   CharacterIterator iter(this, false);
 52414:   if (!iter.AdvanceToCharacter(0))
 52414:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
 52414: 
108991:   uint32_t start = charnum, limit = charnum + 1;
 25387:   while (start > 0 && !mTextRun->IsClusterStart(start)) {
 25387:     --start;
 25387:   }
 25387:   while (limit < mTextRun->GetLength() && !mTextRun->IsClusterStart(limit)) {
 25387:     ++limit;
 25387:   }
 25387: 
 52414:   if (start > 0 && !iter.AdvanceToCharacter(start))
 13259:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
     1: 
   630:   gfxTextRun::Metrics metrics =
 25417:     mTextRun->MeasureText(start, limit - start, gfxFont::LOOSE_INK_EXTENTS,
106838:                           nullptr, nullptr);
     1: 
 13259:   nsRefPtr<gfxContext> tmpCtx = MakeTmpCtx();
 13259:   iter.SetupForMetrics(tmpCtx);
 25387:   tmpCtx->Rectangle(gfxRect(0, -metrics.mAscent,
 25387:                             metrics.mAdvanceWidth,
 25387:                             metrics.mAscent + metrics.mDescent));
 13259:   tmpCtx->IdentityMatrix();
 13259:   return NS_NewSVGRect(_retval, tmpCtx->GetUserPathExtent());
     1: }
     1: 
 69457: nsresult
108991: nsSVGGlyphFrame::GetRotationOfChar(uint32_t charnum, float *_retval)
     1: {
 80486:   CharacterIterator iter(this, false);
 13259:   if (!iter.AdvanceToCharacter(charnum))
 13259:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
 13259: 
 13259:   CharacterPosition pos = iter.GetPositionData();
 13259:   if (!pos.draw)
 13259:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
 13259: 
 13219:   const gfxFloat radPerDeg = M_PI/180.0;
 13259:   *_retval = float(pos.angle / radPerDeg);
     1:   return NS_OK;
     1: }
     1: 
 69457: float
 79445: nsSVGGlyphFrame::GetAdvance(bool aForceGlobalTransform)
     1: {
 13259:   float drawScale, metricsScale;
 13259:   if (!EnsureTextRun(&drawScale, &metricsScale, aForceGlobalTransform))
   630:     return 0.0f;
     1: 
 40002:   return GetSubStringAdvance(0, mTextRun->GetLength(), metricsScale);
     1: }
     1: 
 69457: nsSVGTextPathFrame*
     1: nsSVGGlyphFrame::FindTextPathParent()
     1: {
     1:   /* check if we're the child of a textPath */
     1:   for (nsIFrame *frame = GetParent();
106838:        frame != nullptr;
     1:        frame = frame->GetParent()) {
     1:     nsIAtom* type = frame->GetType();
     1:     if (type == nsGkAtoms::svgTextPathFrame) {
  3233:       return static_cast<nsSVGTextPathFrame*>(frame);
     1:     } else if (type == nsGkAtoms::svgTextFrame)
106838:       return nullptr;
     1:   }
106838:   return nullptr;
     1: }
     1: 
 79445: bool
     1: nsSVGGlyphFrame::IsStartOfChunk()
     1: {
     1:   // this fragment is a chunk if it has a corresponding absolute
     1:   // position adjustment in an ancestors' x or y array. (At the moment
     1:   // we don't map the full arrays, but only the first elements.)
     1: 
 80486:   return false;
     1: }
     1: 
 69457: void
 47840: nsSVGGlyphFrame::GetXY(SVGUserUnitList *aX, SVGUserUnitList *aY)
     1: {
 54300:   static_cast<nsSVGTextContainerFrame *>(mParent)->GetXY(aX, aY);
 54300: }
 54300: 
 69457: void
108991: nsSVGGlyphFrame::SetStartIndex(uint32_t aStartIndex)
 54300: {
 54300:   mStartIndex = aStartIndex;
 54300: }
 54300: 
 69457: void
108991: nsSVGGlyphFrame::GetEffectiveXY(int32_t strLength, nsTArray<float> &aX, nsTArray<float> &aY)
 54300: {
 54300:   nsTArray<float> x, y;
 54300:   static_cast<nsSVGTextContainerFrame *>(mParent)->GetEffectiveXY(x, y);
 54300: 
108991:   int32_t xCount = NS_MAX((int32_t)(x.Length() - mStartIndex), 0);
 54300:   xCount = NS_MIN(xCount, strLength);
 54300:   aX.AppendElements(x.Elements() + mStartIndex, xCount);
 54300: 
108991:   int32_t yCount = NS_MAX((int32_t)(y.Length() - mStartIndex), 0);
 54300:   yCount = NS_MIN(yCount, strLength);
 54300:   aY.AppendElements(y.Elements() + mStartIndex, yCount);
     1: }
     1: 
 47840: void
 47840: nsSVGGlyphFrame::GetDxDy(SVGUserUnitList *aDx, SVGUserUnitList *aDy)
     1: {
 54300:   static_cast<nsSVGTextContainerFrame *>(mParent)->GetDxDy(aDx, aDy);
 54300: }
 54300: 
 54300: void
108991: nsSVGGlyphFrame::GetEffectiveDxDy(int32_t strLength, nsTArray<float> &aDx, nsTArray<float> &aDy)
 54300: {
 54300:   nsTArray<float> dx, dy;
 54300:   static_cast<nsSVGTextContainerFrame *>(mParent)->GetEffectiveDxDy(dx, dy);
 54300: 
108991:   int32_t dxCount = NS_MAX((int32_t)(dx.Length() - mStartIndex), 0);
 54300:   dxCount = NS_MIN(dxCount, strLength);
 54300:   aDx.AppendElements(dx.Elements() + mStartIndex, dxCount);
 54300: 
108991:   int32_t dyCount = NS_MAX((int32_t)(dy.Length() - mStartIndex), 0);
 54300:   dyCount = NS_MIN(dyCount, strLength);
 54300:   aDy.AppendElements(dy.Elements() + mStartIndex, dyCount);
     1: }
     1: 
 58554: const SVGNumberList*
 40002: nsSVGGlyphFrame::GetRotate()
 40002: {
 40002:   nsSVGTextContainerFrame *containerFrame;
 40002:   containerFrame = static_cast<nsSVGTextContainerFrame *>(mParent);
 40002:   if (containerFrame)
 40002:     return containerFrame->GetRotate();
106838:   return nullptr;
 40002: }
 40002: 
 54300: void
108991: nsSVGGlyphFrame::GetEffectiveRotate(int32_t strLength, nsTArray<float> &aRotate)
 54300: {
 54300:   nsTArray<float> rotate;
 54300:   static_cast<nsSVGTextContainerFrame *>(mParent)->GetEffectiveRotate(rotate);
 54300: 
108991:   int32_t rotateCount = NS_MAX((int32_t)(rotate.Length() - mStartIndex), 0);
 54300:   rotateCount = NS_MIN(rotateCount, strLength);
 54300:   if (rotateCount > 0) {
 54300:     aRotate.AppendElements(rotate.Elements() + mStartIndex, rotateCount);
 54300:   } else if (!rotate.IsEmpty()) {
 54300:     // rotate is applied for extra characters too
 54300:     aRotate.AppendElement(rotate[rotate.Length() - 1]);
 54300:   }
 54300: }
 54300: 
108991: uint16_t
     1: nsSVGGlyphFrame::GetTextAnchor()
     1: {
     1:   return GetStyleSVG()->mTextAnchor;
     1: }
     1: 
 79445: bool
     1: nsSVGGlyphFrame::IsAbsolutelyPositioned()
     1: {
 79445:   bool hasTextPathAncestor = false;
     1:   for (nsIFrame *frame = GetParent();
106838:        frame != nullptr;
 54300:        frame = frame->GetParent()) {
     1: 
 54300:     // at the start of a 'text' element
 54300:     // at the start of each 'textPath' element
 54300:     if (frame->GetType() == nsGkAtoms::svgTextPathFrame) {
 80486:       hasTextPathAncestor = true;
 54300:     }
 54300:     if ((frame->GetType() == nsGkAtoms::svgTextFrame ||
 54300:          frame->GetType() == nsGkAtoms::svgTextPathFrame) &&
 77154:         frame->GetFirstPrincipalChild() == this) {
 80486:         return true;
 54300:     }
     1: 
     1:     if (frame->GetType() == nsGkAtoms::svgTextFrame)
     1:       break;
     1:   }
     1: 
 54300:   // for each character within a 'text', 'tspan', 'tref' and 'altGlyph' element
 54300:   // which has an x or y attribute value assigned to it explicitly
 54300:   nsTArray<float> x, y;
 55785:   GetEffectiveXY(GetNumberOfChars(), x, y);
 54300:   // Note: the y of descendants of textPath has no effect in horizontal writing
 54300:   return (!x.IsEmpty() || (!hasTextPathAncestor && !y.IsEmpty()));
     1: }
     1: 
     1: 
     1: //----------------------------------------------------------------------
     1: // nsISVGGlyphFragmentNode interface:
     1: 
108991: uint32_t
     1: nsSVGGlyphFrame::GetNumberOfChars()
     1: {
 69324:   if (mCompressWhitespace) {
     1:     nsAutoString text;
     1:     GetCharacterData(text);
     1:     return text.Length();
     1:   }
     1: 
 69324:   return mContent->TextLength();
 69324: }
 69324: 
 29052: float
     1: nsSVGGlyphFrame::GetComputedTextLength()
     1: {
 80486:   return GetAdvance(false);
     1: }
     1: 
 29052: float
108991: nsSVGGlyphFrame::GetSubStringLength(uint32_t charnum, uint32_t fragmentChars)
     1: {
 13259:   float drawScale, metricsScale;
 80486:   if (!EnsureTextRun(&drawScale, &metricsScale, false))
   630:     return 0.0f;
     1: 
 40002:   return GetSubStringAdvance(charnum, fragmentChars, metricsScale);
     1: }
     1: 
108991: int32_t
     1: nsSVGGlyphFrame::GetCharNumAtPosition(nsIDOMSVGPoint *point)
     1: {
     1:   float xPos, yPos;
     1:   point->GetX(&xPos);
     1:   point->GetY(&yPos);
     1: 
 13259:   nsRefPtr<gfxContext> tmpCtx = MakeTmpCtx();
 80486:   CharacterIterator iter(this, false);
     1: 
108991:   uint32_t i;
108991:   int32_t last = -1;
 13259:   gfxPoint pt(xPos, yPos);
 77019:   while ((i = iter.NextCluster()) != iter.InvalidCluster()) {
108991:     uint32_t limit = i + iter.ClusterLength();
 13259:     gfxTextRun::Metrics metrics =
 25417:       mTextRun->MeasureText(i, limit - i, gfxFont::LOOSE_INK_EXTENTS,
106838:                             nullptr, nullptr);
 25387: 
 25387:     // the SVG spec tells us to divide the width of the cluster equally among
 25387:     // its chars, so we'll step through the chars, allocating a share of the
 25387:     // total advance to each
108991:     int32_t current, end, step;
 25387:     if (mTextRun->IsRightToLeft()) {
 25387:       current = limit - 1;
 25387:       end = i - 1;
 25387:       step = -1;
 25387:     } else {
 25387:       current = i;
 25387:       end = limit;
 25387:       step = 1;
 25387:     }
 25387:     gfxFloat leftEdge = 0.0;
 25387:     gfxFloat width = metrics.mAdvanceWidth / (limit - i);
 25387:     while (current != end) {
 13259:       iter.SetupForMetrics(tmpCtx);
 13259:       tmpCtx->NewPath();
 25387:       tmpCtx->Rectangle(gfxRect(leftEdge, -metrics.mAscent,
 25387:                                 width, metrics.mAscent + metrics.mDescent));
 13259:       tmpCtx->IdentityMatrix();
 13259:       if (tmpCtx->PointInFill(pt)) {
 25387:         // Can't return yet; if there's glyph overlap, the last character
 25387:         // to be rendered wins, so we still have to check the rest...
 25387:         last = current;
 25387:         break; // ...but we don't need to check more slices of this cluster
 25387:       }
 25387:       current += step;
 25387:       leftEdge += width;
 25387:     }
     1:   }
     1: 
 13259:   return last;
     1: }
     1: 
 69457: NS_IMETHODIMP_(nsSVGGlyphFrame *)
 69457: nsSVGGlyphFrame::GetFirstGlyphFrame()
     1: {
 69457:   nsSVGGlyphFrame *frame = this;
 69457:   while (frame && frame->IsTextEmpty()) {
 69457:     frame = frame->GetNextGlyphFrame();
 69410:   }
 69457:   return frame;
     1: }
     1: 
 69457: NS_IMETHODIMP_(nsSVGGlyphFrame *)
 69457: nsSVGGlyphFrame::GetNextGlyphFrame()
     1: {
 32845:   nsIFrame* sibling = GetNextSibling();
     1:   while (sibling) {
 23554:     nsISVGGlyphFragmentNode *node = do_QueryFrame(sibling);
     1:     if (node)
 69457:       return node->GetFirstGlyphFrame();
     1:     sibling = sibling->GetNextSibling();
     1:   }
     1: 
     1:   // no more siblings. go back up the tree.
     1:   
 32845:   NS_ASSERTION(GetParent(), "null parent");
 32845:   nsISVGGlyphFragmentNode *node = do_QueryFrame(GetParent());
106838:   return node ? node->GetNextGlyphFrame() : nullptr;
     1: }
     1: 
 79445: bool
 69324: nsSVGGlyphFrame::EndsWithWhitespace() const
     1: {
 69324:   const nsTextFragment* text = mContent->GetText();
 69410:   NS_ABORT_IF_FALSE(text->GetLength() > 0, "text expected");
 69410: 
 69324:   return NS_IsAsciiWhitespace(text->CharAt(text->GetLength() - 1));
     1: }
     1: 
 79445: bool
 69324: nsSVGGlyphFrame::IsAllWhitespace() const
 59397: {
 59397:   const nsTextFragment* text = mContent->GetText();
 59397: 
 59397:   if (text->Is2b())
 80486:     return false;
108991:   int32_t len = text->GetLength();
 59397:   const char* str = text->Get1b();
108991:   for (int32_t i = 0; i < len; ++i) {
 59397:     if (!NS_IsAsciiWhitespace(str[i]))
 80486:       return false;
 59397:   }
 80486:   return true;
 59397: }
 59397: 
     1: //----------------------------------------------------------------------
     1: //
     1: 
 14042: void
 14042: nsSVGGlyphFrame::NotifyGlyphMetricsChange()
     1: {
 14042:   nsSVGTextContainerFrame *containerFrame =
 14042:     static_cast<nsSVGTextContainerFrame *>(mParent);
 14042:   if (containerFrame)
 14042:     containerFrame->NotifyGlyphMetricsChange();
     1: }
     1: 
 13760: void
108991: nsSVGGlyphFrame::SetupGlobalTransform(gfxContext *aContext, uint32_t aFor)
 13760: {
103332:   gfxMatrix matrix = GetCanvasTM(aFor);
 27899:   if (!matrix.IsSingular()) {
 13760:     aContext->Multiply(matrix);
     1:   }
 27899: }
     1: 
 13259: void
 13259: nsSVGGlyphFrame::ClearTextRun()
   630: {
 13259:   delete mTextRun;
106838:   mTextRun = nullptr;
 13259: }
 13259: 
 79445: bool
 13259: nsSVGGlyphFrame::EnsureTextRun(float *aDrawScale, float *aMetricsScale,
 79445:                                bool aForceGlobalTransform)
 13259: {
 13259:   // Compute the size at which the text should render (excluding the CTM)
 13259:   const nsStyleFont* fontData = GetStyleFont();
 13259:   // Since SVG has its own scaling, we really don't want
 13259:   // fonts in SVG to respond to the browser's "TextZoom"
 13259:   // (Ctrl++,Ctrl+-)
 13259:   nsPresContext *presContext = PresContext();
 13259:   float textZoom = presContext->TextZoom();
 13259:   double size =
 13259:     presContext->AppUnitsToFloatCSSPixels(fontData->mSize) / textZoom;
 13259: 
 13259:   double textRunSize;
 13259:   if (mTextRun) {
 13259:     textRunSize = mTextRun->GetFontGroup()->GetStyle()->size;
 13259:   } else {
 13259:     nsAutoString text;
 13259:     if (!GetCharacterData(text))
 80486:       return false;
 13259: 
 59830:     nsAutoString visualText;
 59830:       
 59830:     /*
 59830:      * XXXsmontagu: The SVG spec says:
 59830:      *
 59830:      * http://www.w3.org/TR/SVG11/text.html#DirectionProperty
 59830:      *  "For the 'direction' property to have any effect, the 'unicode-bidi'
 59830:      *   property's value must be embed or bidi-override."
 59830:      *
 59830:      * The SVGTiny spec, on the other hand, says 
 59830:      *
 59830:      * http://www.w3.org/TR/SVGTiny12/text.html#DirectionProperty
 59830:      *  "For the 'direction' property to have any effect on an element that 
 59830:      *   does not by itself establish a new text chunk (such as the 'tspan'
 59830:      *   element in SVG 1.2 Tiny), the 'unicode-bidi' property's value must
 59830:      *   be embed or bidi-override."
 59830:      *
 59830:      * Note that this is different from HTML/CSS, where setting the 'dir'
 59830:      *  attribute on an inline element automatically sets unicode-bidi: embed
 59830:      *
 59830:      * Our current implementation of bidi in SVG does not distinguish between
 59830:      * different text elements, but treats every text container frame as a
 59830:      * new text chunk, so we always set the base direction according to the
 59830:      * direction property
 59830:      *
 59830:      * See also XXXsmontagu comments in nsSVGTextFrame::UpdateGlyphPositioning
 59830:      */
 59830:     
 59830:     // Get the unicodeBidi property from the parent, because it doesn't
 59830:     // inherit
 80540:     bool bidiOverride = !!(mParent->GetStyleTextReset()->mUnicodeBidi &
 59830:                            NS_STYLE_UNICODE_BIDI_OVERRIDE);
 59830:     nsBidiLevel baseDirection =
 59830:       GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL ?
 59830:         NSBIDI_RTL : NSBIDI_LTR;
 73724:     nsBidiPresUtils::CopyLogicalToVisual(text, visualText,
 59830:                                          baseDirection, bidiOverride);
 59830:     if (!visualText.IsEmpty()) {
 59830:       text = visualText;
 59830:     }
 59830: 
 13259:     gfxMatrix m;
 13259:     if (aForceGlobalTransform ||
 13259:         !(GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD)) {
103332:       m = GetCanvasTM(mGetCanvasTMForFlag);
 87150:       if (m.IsSingular())
 80486:         return false;
 13259:     }
 13259: 
 13259:     // The context scale is the ratio of the length of the transformed
 13259:     // diagonal vector (1,1) to the length of the untransformed diagonal
 13259:     // (which is sqrt(2)).
 13259:     gfxPoint p = m.Transform(gfxPoint(1, 1)) - m.Transform(gfxPoint(0, 0));
 15943:     double contextScale = nsSVGUtils::ComputeNormalizedHypotenuse(p.x, p.y);
 13259: 
 13259:     if (GetStyleSVG()->mTextRendering ==
 13259:         NS_STYLE_TEXT_RENDERING_GEOMETRICPRECISION) {
 13259:       textRunSize = PRECISE_SIZE;
 13259:     } else {
 13259:       textRunSize = size*contextScale;
 32531:       textRunSize = NS_MAX(textRunSize, double(CLAMP_MIN_SIZE));
 32531:       textRunSize = NS_MIN(textRunSize, double(CLAMP_MAX_SIZE));
 13259:     }
 13259: 
 13259:     const nsFont& font = fontData->mFont;
 79445:     bool printerFont = (presContext->Type() == nsPresContext::eContext_PrintPreview ||
 22866:                           presContext->Type() == nsPresContext::eContext_Print);
 24408:     gfxFontStyle fontStyle(font.style, font.weight, font.stretch, textRunSize,
 88039:                            mStyleContext->GetStyleFont()->mLanguage,
 38493:                            font.sizeAdjust, font.systemFont,
 47359:                            printerFont,
 47359:                            font.languageOverride);
 13259: 
 96988:     font.AddFontFeaturesToStyle(&fontStyle);
 96988: 
 13259:     nsRefPtr<gfxFontGroup> fontGroup =
 19962:       gfxPlatform::GetPlatform()->CreateFontGroup(font.name, &fontStyle, presContext->GetUserFontSet());
   630: 
108991:     uint32_t flags = gfxTextRunFactory::TEXT_NEED_BOUNDING_BOX |
 55972:       GetTextRunFlags(text.Length()) |
107217:       nsLayoutUtils::GetTextRunFlagsForStyle(GetStyleContext(), GetStyleFont(), 0);
 13259: 
 13259:     // XXX We should use a better surface here! But then we'd have to
 13259:     // change things so we can ensure we always have the "right" sort of
 13259:     // surface available, by creating the textrun only at the right times
 13259:     nsRefPtr<gfxContext> tmpCtx = MakeTmpCtx();
 13259:     tmpCtx->SetMatrix(m);
 13259: 
 86690:     // Use only the fonts' internal word caching here.
 86690:     // We don't cache the textrun globally because we create
 13259:     // a new fontgroup every time. Even if we cached fontgroups, we
 13259:     // might render at very many different sizes (e.g. during zoom
 13259:     // animation) and caching a textrun for each such size would be bad.
 13259:     gfxTextRunFactory::Parameters params = {
106838:         tmpCtx, nullptr, nullptr, nullptr, 0, GetTextRunUnitsFactor()
 13259:     };
 86690:     mTextRun =
 86690:       fontGroup->MakeTextRun(text.get(), text.Length(), &params, flags);
 13259:     if (!mTextRun)
 80486:       return false;
 13259:   }
 13259: 
 13259:   *aDrawScale = float(size/textRunSize);
 13259:   *aMetricsScale = (*aDrawScale)/GetTextRunUnitsFactor();
 80486:   return true;
   630: }
   630: 
     1: //----------------------------------------------------------------------
     1: // helper class
     1: 
 13259: CharacterIterator::CharacterIterator(nsSVGGlyphFrame *aSource,
 79445:         bool aForceGlobalTransform)
 77019:   : mSource(aSource)
 77019:   , mCurrentAdvance(0)
108991:   , mCurrentChar(uint32_t(-1))
 80486:   , mInError(false)
     1: {
 13259:   if (!aSource->EnsureTextRun(&mDrawScale, &mMetricsScale,
 13259:                               aForceGlobalTransform) ||
 13259:       !aSource->GetCharacterPositions(&mPositions, mMetricsScale)) {
 80486:     mInError = true;
     1:   }
     1: }
     1: 
 79445: bool
 13259: CharacterIterator::SetupForDirectTextRun(gfxContext *aContext, float aScale)
 13259: {
 13259:   if (!mPositions.IsEmpty() || mInError)
 80486:     return false;
 13259:   aContext->SetMatrix(mInitialMatrix);
 13259:   aContext->Translate(mSource->mPosition);
 13259:   aContext->Scale(aScale, aScale);
 80486:   return true;
 13259: }
 13259: 
108991: uint32_t
 60286: CharacterIterator::NextCluster()
 13259: {
 56945:   if (mInError) {
 56945: #ifdef DEBUG
 77019:     if (mCurrentChar != InvalidCluster()) {
 79445:       bool pastEnd = (mCurrentChar >= mSource->mTextRun->GetLength());
 56945:       NS_ABORT_IF_FALSE(pastEnd, "Past the end of CharacterIterator. Missing Reset?");
 56945:     }
 56945: #endif
 77019:     return InvalidCluster();
 56945:   }
 13259: 
 80486:   while (true) {
 77019:     if (mCurrentChar != InvalidCluster() &&
 13259:         (mPositions.IsEmpty() || mPositions[mCurrentChar].draw)) {
 13259:       mCurrentAdvance +=
106838:         mSource->mTextRun->GetAdvanceWidth(mCurrentChar, 1, nullptr);
 13259:     }
 13259:     ++mCurrentChar;
 13259: 
 77019:     if (mCurrentChar >= mSource->mTextRun->GetLength()) {
 80486:       mInError = true;
 77019:       return InvalidCluster();
 56945:     }
 13259: 
 60286:     if (mSource->mTextRun->IsClusterStart(mCurrentChar) &&
 60286:         (mPositions.IsEmpty() || mPositions[mCurrentChar].draw)) {
 13259:       return mCurrentChar;
 13259:     }
 13259:   }
 60286: }
 60286: 
108991: uint32_t
 60286: CharacterIterator::ClusterLength()
 60286: {
 60286:   if (mInError) {
 60286:     return 0;
 60286:   }
 60286: 
108991:   uint32_t i = mCurrentChar;
 60286:   while (++i < mSource->mTextRun->GetLength()) {
 60286:     if (mSource->mTextRun->IsClusterStart(i)) {
 60286:       break;
 60286:     }
 60286:   }
 60286:   return i - mCurrentChar;
 60286: }
 13259: 
 79445: bool
108991: CharacterIterator::AdvanceToCharacter(uint32_t aIndex)
 13259: {
 77019:   while (NextCluster() != InvalidCluster()) {
 13259:     if (mCurrentChar == aIndex)
 80486:       return true;
 13259:   }
 80486:   return false;
 13259: }
 13259: 
 13259: void
 13259: CharacterIterator::SetupFor(gfxContext *aContext, float aScale)
 13259: {
 13259:   NS_ASSERTION(!mInError, "We should not have reached here");
 13259: 
 13259:   aContext->SetMatrix(mInitialMatrix);
 13259:   if (mPositions.IsEmpty()) {
 14005:     aContext->Translate(mSource->mPosition);
 14005:     aContext->Scale(aScale, aScale);
 14005:     aContext->Translate(gfxPoint(mCurrentAdvance, 0));
 13259:   } else {
 13259:     aContext->Translate(mPositions[mCurrentChar].pos);
 13259:     aContext->Rotate(mPositions[mCurrentChar].angle);
 14005:     aContext->Scale(aScale, aScale);
 13259:   }
 13259: }
 13259: 
 13259: CharacterPosition
 13259: CharacterIterator::GetPositionData()
 13259: {
 13259:   if (!mPositions.IsEmpty())
 13259:     return mPositions[mCurrentChar];
 13259: 
 19832:   gfxFloat advance = mCurrentAdvance * mMetricsScale;
 13259:   CharacterPosition cp =
 80486:     { mSource->mPosition + gfxPoint(advance, 0), 0, true };
 13259:   return cp;
 13259: }
