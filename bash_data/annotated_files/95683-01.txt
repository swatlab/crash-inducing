42611: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
42611:  * ***** BEGIN LICENSE BLOCK *****
42611:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
42611:  *
42611:  * The contents of this file are subject to the Mozilla Public License Version
42611:  * 1.1 (the "License"); you may not use this file except in compliance with
42611:  * the License. You may obtain a copy of the License at
42611:  * http://www.mozilla.org/MPL/
42611:  *
42611:  * Software distributed under the License is distributed on an "AS IS" basis,
42611:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
42611:  * for the specific language governing rights and limitations under the
42611:  * License.
42611:  *
42611:  * The Original Code is Mozilla Corporation code.
42611:  *
42611:  * The Initial Developer of the Original Code is Mozilla Foundation.
42611:  * Portions created by the Initial Developer are Copyright (C) 2010
42611:  * the Initial Developer. All Rights Reserved.
42611:  *
42611:  * Contributor(s):
42611:  *   Vladimir Vukicevic <vladimir@pobox.com>
42611:  *   Bas Schouten <bschouten@mozilla.com>
42611:  *
42611:  * Alternatively, the contents of this file may be used under the terms of
42611:  * either the GNU General Public License Version 2 or later (the "GPL"), or
42611:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
42611:  * in which case the provisions of the GPL or the LGPL are applicable instead
42611:  * of those above. If you wish to allow use of your version of this file only
42611:  * under the terms of either the GPL or the LGPL, and not to allow others to
42611:  * use your version of this file under the terms of the MPL, indicate your
42611:  * decision by deleting the provisions above and replace them with the notice
42611:  * and other provisions required by the GPL or the LGPL. If you do not delete
42611:  * the provisions above, a recipient may use your version of this file under
42611:  * the terms of any one of the MPL, the GPL or the LGPL.
42611:  *
42611:  * ***** END LICENSE BLOCK ***** */
42611: 
72995: 
72995: #include "mozilla/layers/PLayers.h"
72995: #include "mozilla/layers/ShadowLayers.h"
72995: #include "ShadowBufferD3D9.h"
42611: 
42611: #include "gfxImageSurface.h"
42611: #include "gfxWindowsSurface.h"
52175: #include "gfxWindowsPlatform.h"
42611: 
72995: #include "CanvasLayerD3D9.h"
72995: 
42611: namespace mozilla {
42611: namespace layers {
42611: 
42611: CanvasLayerD3D9::~CanvasLayerD3D9()
42611: {
53980:   if (mD3DManager) {
53784:     mD3DManager->deviceManager()->mLayersWithResources.RemoveElement(this);
53784:   }
42611: }
42611: 
42611: void
42611: CanvasLayerD3D9::Initialize(const Data& aData)
42611: {
42611:   NS_ASSERTION(mSurface == nsnull, "BasicCanvasLayer::Initialize called twice!");
42611: 
82414:   if (aData.mDrawTarget) {
82414:     mDrawTarget = aData.mDrawTarget;
82414:     mNeedsYFlip = false;
82414:     mDataIsPremultiplied = true;
82414:   } else if (aData.mSurface) {
42611:     mSurface = aData.mSurface;
42611:     NS_ASSERTION(aData.mGLContext == nsnull,
42611:                  "CanvasLayer can't have both surface and GLContext");
80486:     mNeedsYFlip = false;
80486:     mDataIsPremultiplied = true;
42611:   } else if (aData.mGLContext) {
47909:     NS_ASSERTION(aData.mGLContext->IsOffscreen(), "canvas gl context isn't offscreen");
42611:     mGLContext = aData.mGLContext;
47909:     mCanvasFramebuffer = mGLContext->GetOffscreenFBO();
51316:     mDataIsPremultiplied = aData.mGLBufferIsPremultiplied;
80486:     mNeedsYFlip = true;
42611:   } else {
82414:     NS_ERROR("CanvasLayer created without mSurface, mGLContext or mDrawTarget?");
42611:   }
42611: 
42611:   mBounds.SetRect(0, 0, aData.mSize.width, aData.mSize.height);
42611: 
53785:   CreateTexture();
49317: }
42611: 
42611: void
64540: CanvasLayerD3D9::UpdateSurface()
42611: {
87505:   if (!mDirty && mTexture)
64540:     return;
80486:   mDirty = false;
64540: 
42611:   if (!mTexture) {
53785:     CreateTexture();
87505: 
87505:     if (!mTexture) {
87505:       NS_WARNING("CanvasLayerD3D9::Updated called but no texture present and creation failed!");
42611:       return;
42611:     }
87505:   }
42611: 
42611:   if (mGLContext) {
42611:     // WebGL reads entire surface.
72995:     LockTextureRectD3D9 textureLock(mTexture);
72995:     if (!textureLock.HasLock()) {
53786:       NS_WARNING("Failed to lock CanvasLayer texture.");
53786:       return;
53786:     }
42611: 
72995:     D3DLOCKED_RECT r = textureLock.GetLockRect();
72995: 
94020:     const bool stridesMatch = r.Pitch == mBounds.width * 4;
94020: 
42611:     PRUint8 *destination;
94020:     if (!stridesMatch) {
94020:       destination = GetTempBlob(mBounds.width * mBounds.height * 4);
42611:     } else {
94020:       DiscardTempBlob();
42611:       destination = (PRUint8*)r.pBits;
42611:     }
42611: 
80020:     mGLContext->MakeCurrent();
80020: 
47909:     PRUint32 currentFramebuffer = 0;
47909: 
47909:     mGLContext->fGetIntegerv(LOCAL_GL_FRAMEBUFFER_BINDING, (GLint*)&currentFramebuffer);
47909: 
47909:     // Make sure that we read pixels from the correct framebuffer, regardless
47909:     // of what's currently bound.
47909:     if (currentFramebuffer != mCanvasFramebuffer)
47909:       mGLContext->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, mCanvasFramebuffer);
47909: 
49076:     nsRefPtr<gfxImageSurface> tmpSurface =
49076:       new gfxImageSurface(destination,
49076:                           gfxIntSize(mBounds.width, mBounds.height),
49076:                           mBounds.width * 4,
49076:                           gfxASurface::ImageFormatARGB32);
49076:     mGLContext->ReadPixelsIntoImageSurface(0, 0,
49076:                                            mBounds.width, mBounds.height,
49076:                                            tmpSurface);
49076:     tmpSurface = nsnull;
42611: 
47909:     // Put back the previous framebuffer binding.
47909:     if (currentFramebuffer != mCanvasFramebuffer)
47909:       mGLContext->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, currentFramebuffer);
47909: 
94020:     if (!stridesMatch) {
42611:       for (int y = 0; y < mBounds.height; y++) {
42611:         memcpy((PRUint8*)r.pBits + r.Pitch * y,
42611:                destination + mBounds.width * 4 * y,
42611:                mBounds.width * 4);
42611:       }
42611:     }
82414:   } else {
42611:     RECT r;
64540:     r.left = mBounds.x;
64540:     r.top = mBounds.y;
64540:     r.right = mBounds.XMost();
64540:     r.bottom = mBounds.YMost();
42611: 
72995:     LockTextureRectD3D9 textureLock(mTexture);
72995:     if (!textureLock.HasLock()) {
53786:       NS_WARNING("Failed to lock CanvasLayer texture.");
53786:       return;
53786:     }
42611: 
72995:     D3DLOCKED_RECT lockedRect = textureLock.GetLockRect();
72995: 
42611:     nsRefPtr<gfxImageSurface> sourceSurface;
82414:     nsRefPtr<gfxASurface> tempSurface;
82414:     if (mDrawTarget) {
82414:       tempSurface = gfxPlatform::GetPlatform()->GetThebesSurfaceForDrawTarget(mDrawTarget);
82414:     }
82414:     else {
82414:       tempSurface = mSurface;
82414:     }
42611: 
82414:     if (tempSurface->GetType() == gfxASurface::SurfaceTypeWin32) {
82414:       sourceSurface = tempSurface->GetAsImageSurface();
82414:     } else if (tempSurface->GetType() == gfxASurface::SurfaceTypeImage) {
82414:       sourceSurface = static_cast<gfxImageSurface*>(tempSurface.get());
42611:       if (sourceSurface->Format() != gfxASurface::ImageFormatARGB32 &&
42611:           sourceSurface->Format() != gfxASurface::ImageFormatRGB24)
42611:       {
42611:         return;
42611:       }
42611:     } else {
64540:       sourceSurface = new gfxImageSurface(gfxIntSize(mBounds.width, mBounds.height),
42611:                                           gfxASurface::ImageFormatARGB32);
42611:       nsRefPtr<gfxContext> ctx = new gfxContext(sourceSurface);
42611:       ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
95683:       ctx->SetSource(tempSurface);
42611:       ctx->Paint();
42611:     }
42611: 
64540:     PRUint8 *startBits = sourceSurface->Data();
64540:     PRUint32 sourceStride = sourceSurface->Stride();
64540: 
62301:     if (sourceSurface->Format() != gfxASurface::ImageFormatARGB32) {
62301:       mHasAlpha = false;
62301:     } else {
62301:       mHasAlpha = true;
62301:     }
62301: 
64540:     for (int y = 0; y < mBounds.height; y++) {
42611:       memcpy((PRUint8*)lockedRect.pBits + lockedRect.Pitch * y,
42611:              startBits + sourceStride * y,
64540:              mBounds.width * 4);
42611:     }
42611: 
42611:   }
42611: }
42611: 
42611: Layer*
42611: CanvasLayerD3D9::GetLayer()
42611: {
42611:   return this;
42611: }
42611: 
42611: void
57097: CanvasLayerD3D9::RenderLayer()
42611: {
64540:   UpdateSurface();
64541:   FireDidTransactionCallback();
64541: 
64540:   if (!mTexture)
64540:     return;
53785: 
42611:   /*
54880:    * We flip the Y axis here, note we can only do this because we are in 
54880:    * CULL_NONE mode!
42611:    */
54880: 
54880:   ShaderConstantRect quad(0, 0, mBounds.width, mBounds.height);
42611:   if (mNeedsYFlip) {
54880:     quad.mHeight = (float)-mBounds.height;
54880:     quad.mY = (float)mBounds.height;
42611:   }
42611: 
54880:   device()->SetVertexShaderConstantF(CBvLayerQuad, quad, 1);
42611: 
57097:   SetShaderTransformAndOpacity();
42611: 
62301:   if (mHasAlpha) {
51963:     mD3DManager->SetShaderMode(DeviceManagerD3D9::RGBALAYER);
62301:   } else {
62301:     mD3DManager->SetShaderMode(DeviceManagerD3D9::RGBLAYER);
62301:   }
42611: 
59728:   if (mFilter == gfxPattern::FILTER_NEAREST) {
59728:     device()->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_POINT);
59728:     device()->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_POINT);
59728:   }
51316:   if (!mDataIsPremultiplied) {
42611:     device()->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
51314:     device()->SetRenderState(D3DRS_SEPARATEALPHABLENDENABLE, TRUE);
42611:   }
42611:   device()->SetTexture(0, mTexture);
42611:   device()->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);
51316:   if (!mDataIsPremultiplied) {
42611:     device()->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
51314:     device()->SetRenderState(D3DRS_SEPARATEALPHABLENDENABLE, FALSE);
42611:   }
59728:   if (mFilter == gfxPattern::FILTER_NEAREST) {
59728:     device()->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
59728:     device()->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
59728:   }
42611: }
42611: 
53784: void
53784: CanvasLayerD3D9::CleanResources()
53784: {
53784:   if (mD3DManager->deviceManager()->HasDynamicTextures()) {
53784:     // In this case we have a texture in POOL_DEFAULT
53784:     mTexture = nsnull;
53784:   }
53784: }
53784: 
53785: void
53979: CanvasLayerD3D9::LayerManagerDestroyed()
53979: {
53979:   mD3DManager->deviceManager()->mLayersWithResources.RemoveElement(this);
53979:   mD3DManager = nsnull;
53979: }
53979: 
53979: void
53785: CanvasLayerD3D9::CreateTexture()
53785: {
81355:   HRESULT hr;
53785:   if (mD3DManager->deviceManager()->HasDynamicTextures()) {
81355:     hr = device()->CreateTexture(mBounds.width, mBounds.height, 1, D3DUSAGE_DYNAMIC,
53785:                                  D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT,
53785:                                  getter_AddRefs(mTexture), NULL);
53785:   } else {
53785:     // D3DPOOL_MANAGED is fine here since we require Dynamic Textures for D3D9Ex
53785:     // devices.
81355:     hr = device()->CreateTexture(mBounds.width, mBounds.height, 1, 0,
53785:                                  D3DFMT_A8R8G8B8, D3DPOOL_MANAGED,
53785:                                  getter_AddRefs(mTexture), NULL);
53785:   }
81355:   if (FAILED(hr)) {
81355:     mD3DManager->ReportFailure(NS_LITERAL_CSTRING("CanvasLayerD3D9::CreateTexture() failed"),
81355:                                  hr);
81355:     return;
81355:   }
53785: }
53785: 
72995: ShadowCanvasLayerD3D9::ShadowCanvasLayerD3D9(LayerManagerD3D9* aManager)
72995:   : ShadowCanvasLayer(aManager, nsnull)
72995:   , LayerD3D9(aManager)
80486:   , mNeedsYFlip(false)
72995: {
72995:   mImplData = static_cast<LayerD3D9*>(this);
72995: }
72995:  
72995: ShadowCanvasLayerD3D9::~ShadowCanvasLayerD3D9()
72995: {}
72995: 
72995: void
72995: ShadowCanvasLayerD3D9::Initialize(const Data& aData)
72995: {
72995:   NS_RUNTIMEABORT("Non-shadow layer API unexpectedly used for shadow layer");
72995: }
72995: 
72995: void
79426: ShadowCanvasLayerD3D9::Init(bool needYFlip)
72995: {
72995:   if (!mBuffer) {
72995:     mBuffer = new ShadowBufferD3D9(this);
72995:   }
72995: 
72995:   mNeedsYFlip = needYFlip;
72995: }
72995: 
72995: void
79426: ShadowCanvasLayerD3D9::Swap(const CanvasSurface& aNewFront,
79426:                             bool needYFlip,
79426:                             CanvasSurface* aNewBack)
72995: {
79426:   NS_ASSERTION(aNewFront.type() == CanvasSurface::TSurfaceDescriptor, 
79426:     "ShadowCanvasLayerD3D9::Swap expected CanvasSurface surface");
72995: 
72995:   nsRefPtr<gfxASurface> surf = 
72995:     ShadowLayerForwarder::OpenDescriptor(aNewFront);
79426:   if (!mBuffer) {
79426:     Init(needYFlip);
79426:   }
72995:   mBuffer->Upload(surf, GetVisibleRegion().GetBounds());
72995: 
72995:   *aNewBack = aNewFront;
72995: }
72995: 
72995: void
72995: ShadowCanvasLayerD3D9::DestroyFrontBuffer()
72995: {
72995:   Destroy();
72995: }
72995: 
72995: void
72995: ShadowCanvasLayerD3D9::Disconnect()
72995: {
72995:   Destroy();
72995: }
72995: 
72995: void
72995: ShadowCanvasLayerD3D9::Destroy()
72995: {
72995:   mBuffer = nsnull;
72995: }
72995: 
72995: void
72995: ShadowCanvasLayerD3D9::CleanResources()
72995: {
72995:   Destroy();
72995: }
72995: 
72995: void
72995: ShadowCanvasLayerD3D9::LayerManagerDestroyed()
72995: {
72995:   mD3DManager->deviceManager()->mLayersWithResources.RemoveElement(this);
72995:   mD3DManager = nsnull;
72995: }
72995: 
72995: Layer*
72995: ShadowCanvasLayerD3D9::GetLayer()
72995: {
72995:   return this;
72995: }
72995: 
72995: void
72995: ShadowCanvasLayerD3D9::RenderLayer()
72995: {
72995:   if (!mBuffer) {
72995:     return;
72995:   }
72995: 
72995:   mBuffer->RenderTo(mD3DManager, GetEffectiveVisibleRegion());
72995: }
72995: 
72995: 
42611: } /* namespace layers */
47909: } /* namespace mozilla */
