41550: /*
41550: # ***** BEGIN LICENSE BLOCK *****
41550: # Version: MPL 1.1/GPL 2.0/LGPL 2.1
41550: #
41550: # The contents of this file are subject to the Mozilla Public License Version
41550: # 1.1 (the "License"); you may not use this file except in compliance with
41550: # the License. You may obtain a copy of the License at
41550: # http://www.mozilla.org/MPL/
41550: #
41550: # Software distributed under the License is distributed on an "AS IS" basis,
41550: # WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
41550: # for the specific language governing rights and limitations under the
41550: # License.
41550: #
41550: # The Original Code is the Extension Manager.
41550: #
41550: # The Initial Developer of the Original Code is
41550: # the Mozilla Foundation.
41550: # Portions created by the Initial Developer are Copyright (C) 2009
41550: # the Initial Developer. All Rights Reserved.
41550: #
41550: # Contributor(s):
41550: #   Dave Townsend <dtownsend@oxymoronical.com>
81116: #   Blair McBride <bmcbride@mozilla.com>
41550: #
41550: # Alternatively, the contents of this file may be used under the terms of
41550: # either the GNU General Public License Version 2 or later (the "GPL"), or
41550: # the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
41550: # in which case the provisions of the GPL or the LGPL are applicable instead
41550: # of those above. If you wish to allow use of your version of this file only
41550: # under the terms of either the GPL or the LGPL, and not to allow others to
41550: # use your version of this file under the terms of the MPL, indicate your
41550: # decision by deleting the provisions above and replace them with the notice
41550: # and other provisions required by the GPL or the LGPL. If you do not delete
41550: # the provisions above, a recipient may use your version of this file under
41550: # the terms of any one of the MPL, the GPL or the LGPL.
41550: #
41550: # ***** END LICENSE BLOCK *****
41550: */
41550: 
74689: "use strict";
74689: 
41550: const Cc = Components.classes;
41550: const Ci = Components.interfaces;
41550: const Cr = Components.results;
41550: 
41550: var EXPORTED_SYMBOLS = [];
41550: 
41550: Components.utils.import("resource://gre/modules/Services.jsm");
41550: Components.utils.import("resource://gre/modules/AddonManager.jsm");
51520: Components.utils.import("resource://gre/modules/AddonRepository.jsm");
81116: Components.utils.import("resource://gre/modules/ChromeManifestParser.jsm");
54549: Components.utils.import("resource://gre/modules/LightweightThemeManager.jsm");
41550: Components.utils.import("resource://gre/modules/FileUtils.jsm");
41550: Components.utils.import("resource://gre/modules/NetUtil.jsm");
41550: 
41550: const PREF_DB_SCHEMA                  = "extensions.databaseSchema";
41550: const PREF_INSTALL_CACHE              = "extensions.installCache";
41550: const PREF_BOOTSTRAP_ADDONS           = "extensions.bootstrappedAddons";
41550: const PREF_PENDING_OPERATIONS         = "extensions.pendingOperations";
41550: const PREF_MATCH_OS_LOCALE            = "intl.locale.matchOS";
41550: const PREF_SELECTED_LOCALE            = "general.useragent.locale";
41550: const PREF_EM_DSS_ENABLED             = "extensions.dss.enabled";
41550: const PREF_DSS_SWITCHPENDING          = "extensions.dss.switchPending";
41550: const PREF_DSS_SKIN_TO_SELECT         = "extensions.lastSelectedSkin";
41550: const PREF_GENERAL_SKINS_SELECTEDSKIN = "general.skins.selectedSkin";
70820: const PREF_EM_CHECK_COMPATIBILITY_BASE = "extensions.checkCompatibility";
41550: const PREF_EM_CHECK_UPDATE_SECURITY   = "extensions.checkUpdateSecurity";
41550: const PREF_EM_UPDATE_URL              = "extensions.update.url";
41575: const PREF_EM_ENABLED_ADDONS          = "extensions.enabledAddons";
41577: const PREF_EM_EXTENSION_FORMAT        = "extensions.";
41579: const PREF_EM_ENABLED_SCOPES          = "extensions.enabledScopes";
72632: const PREF_EM_AUTO_DISABLED_SCOPES    = "extensions.autoDisableScopes";
50742: const PREF_EM_SHOW_MISMATCH_UI        = "extensions.showMismatchUI";
41550: const PREF_XPI_ENABLED                = "xpinstall.enabled";
41550: const PREF_XPI_WHITELIST_REQUIRED     = "xpinstall.whitelist.required";
41593: const PREF_XPI_WHITELIST_PERMISSIONS  = "xpinstall.whitelist.add";
41593: const PREF_XPI_BLACKLIST_PERMISSIONS  = "xpinstall.blacklist.add";
52422: const PREF_XPI_UNPACK                 = "extensions.alwaysUnpack";
52111: const PREF_INSTALL_REQUIREBUILTINCERTS = "extensions.install.requireBuiltInCerts";
60885: const PREF_INSTALL_DISTRO_ADDONS      = "extensions.installDistroAddons";
60885: const PREF_BRANCH_INSTALLED_ADDON     = "extensions.installedDistroAddon.";
75342: const PREF_SHOWN_SELECTION_UI         = "extensions.shownSelectionUI";
75342: 
82276: const PREF_EM_MIN_COMPAT_APP_VERSION      = "extensions.minCompatibleAppVersion";
82276: const PREF_EM_MIN_COMPAT_PLATFORM_VERSION = "extensions.minCompatiblePlatformVersion";
82276: 
75342: const URI_EXTENSION_SELECT_DIALOG     = "chrome://mozapps/content/extensions/selectAddons.xul";
50742: const URI_EXTENSION_UPDATE_DIALOG     = "chrome://mozapps/content/extensions/update.xul";
70152: const URI_EXTENSION_STRINGS           = "chrome://mozapps/locale/extensions/extensions.properties";
70152: 
70152: const STRING_TYPE_NAME                = "type.%ID%.name";
50742: 
41550: const DIR_EXTENSIONS                  = "extensions";
41550: const DIR_STAGE                       = "staged";
55436: const DIR_XPI_STAGE                   = "staged-xpis";
56256: const DIR_TRASH                       = "trash";
41550: 
41550: const FILE_OLD_DATABASE               = "extensions.rdf";
59564: const FILE_OLD_CACHE                  = "extensions.cache";
41550: const FILE_DATABASE                   = "extensions.sqlite";
41550: const FILE_INSTALL_MANIFEST           = "install.rdf";
41550: const FILE_XPI_ADDONS_LIST            = "extensions.ini";
41550: 
41550: const KEY_PROFILEDIR                  = "ProfD";
41550: const KEY_APPDIR                      = "XCurProcD";
48669: const KEY_TEMPDIR                     = "TmpD";
60885: const KEY_APP_DISTRIBUTION            = "XREAppDist";
41550: 
41550: const KEY_APP_PROFILE                 = "app-profile";
41550: const KEY_APP_GLOBAL                  = "app-global";
41550: const KEY_APP_SYSTEM_LOCAL            = "app-system-local";
41550: const KEY_APP_SYSTEM_SHARE            = "app-system-share";
41550: const KEY_APP_SYSTEM_USER             = "app-system-user";
41550: 
41550: const UNKNOWN_XPCOM_ABI               = "unknownABI";
41590: const XPI_PERMISSION                  = "install";
41590: 
41550: const PREFIX_ITEM_URI                 = "urn:mozilla:item:";
41590: const RDFURI_ITEM_ROOT                = "urn:mozilla:item:root"
41590: const RDFURI_INSTALL_MANIFEST_ROOT    = "urn:mozilla:install-manifest";
41590: const PREFIX_NS_EM                    = "http://www.mozilla.org/2004/em-rdf#";
41550: 
41550: const TOOLKIT_ID                      = "toolkit@mozilla.org";
41550: 
41550: const BRANCH_REGEXP                   = /^([^\.]+\.[0-9]+[a-z]*).*/gi;
41550: 
82652: const DB_SCHEMA                       = 12;
41550: 
76354: #ifdef MOZ_COMPATIBILITY_NIGHTLY
70820: const PREF_EM_CHECK_COMPATIBILITY = PREF_EM_CHECK_COMPATIBILITY_BASE +
70820:                                     ".nightly";
70820: #else
70820: const PREF_EM_CHECK_COMPATIBILITY = PREF_EM_CHECK_COMPATIBILITY_BASE + "." +
70820:                                     Services.appinfo.version.replace(BRANCH_REGEXP, "$1");
70820: #endif
70820: 
47133: // Properties that exist in the install manifest
41550: const PROP_METADATA      = ["id", "version", "type", "internalName", "updateURL",
71220:                             "updateKey", "optionsURL", "optionsType", "aboutURL",
71220:                             "iconURL", "icon64URL"];
41550: const PROP_LOCALE_SINGLE = ["name", "description", "creator", "homepageURL"];
41550: const PROP_LOCALE_MULTI  = ["developers", "translators", "contributors"];
41550: const PROP_TARGETAPP     = ["id", "minVersion", "maxVersion"];
41550: 
47133: // Properties that only exist in the database
82404: const DB_METADATA        = ["syncGUID",
82404:                             "installDate",
82404:                             "updateDate",
82404:                             "size",
82404:                             "sourceURI",
82404:                             "releaseNotesURI",
82404:                             "applyBackgroundUpdates"];
47133: const DB_BOOL_METADATA   = ["visible", "active", "userDisabled", "appDisabled",
70084:                             "pendingUninstall", "bootstrap", "skinnable",
82652:                             "softDisabled", "isForeignInstall",
81117:                             "hasBinaryComponents", "strictCompatibility"];
47133: 
82579: // Properties that should be migrated where possible from an old database. These
82579: // shouldn't include properties that can be read directly from install.rdf files
82579: // or calculated
82579: const DB_MIGRATE_METADATA= ["installDate", "userDisabled", "softDisabled",
82579:                             "sourceURI", "applyBackgroundUpdates",
82652:                             "releaseNotesURI", "isForeignInstall", "syncGUID"];
82579: 
41591: const BOOTSTRAP_REASONS = {
41591:   APP_STARTUP     : 1,
41591:   APP_SHUTDOWN    : 2,
41591:   ADDON_ENABLE    : 3,
41591:   ADDON_DISABLE   : 4,
41591:   ADDON_INSTALL   : 5,
41591:   ADDON_UNINSTALL : 6,
41591:   ADDON_UPGRADE   : 7,
41591:   ADDON_DOWNGRADE : 8
41591: };
41591: 
41550: // Map new string type identifiers to old style nsIUpdateItem types
41550: const TYPES = {
41550:   extension: 2,
41550:   theme: 4,
48669:   locale: 8,
79913:   multipackage: 32,
79913:   dictionary: 64
41550: };
41550: 
70154: const MSG_JAR_FLUSH = "AddonJarFlush";
70154: 
80426: var gGlobalScope = this;
80426: 
41550: /**
41550:  * Valid IDs fit this pattern.
41550:  */
41550: var gIDTest = /^(\{[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\}|[a-z0-9-\._]*\@[a-z0-9-\._]+)$/i;
41550: 
41596: ["LOG", "WARN", "ERROR"].forEach(function(aName) {
41596:   this.__defineGetter__(aName, function() {
41596:     Components.utils.import("resource://gre/modules/AddonLogging.jsm");
41596: 
41596:     LogManager.getLogger("addons.xpi", this);
41596:     return this[aName];
41596:   })
41596: }, this);
41550: 
41550: /**
60885:  * A safe way to install a file or the contents of a directory to a new
60885:  * directory. The file or directory is moved or copied recursively and if
60885:  * anything fails an attempt is made to rollback the entire operation. The
60885:  * operation may also be rolled back to its original state after it has
60885:  * completed by calling the rollback method.
56256:  *
60885:  * Operations can be chained. Calling move or copy multiple times will remember
60885:  * the whole set and if one fails all of the operations will be rolled back.
60885:  */
60885: function SafeInstallOperation() {
60885:   this._installedFiles = [];
56256:   this._createdDirs = [];
56256: }
56256: 
60885: SafeInstallOperation.prototype = {
60885:   _installedFiles: null,
56256:   _createdDirs: null,
56256: 
60885:   _installFile: function(aFile, aTargetDirectory, aCopy) {
60885:     let oldFile = aCopy ? null : aFile.clone();
56256:     let newFile = aFile.clone();
56256:     try {
60885:       if (aCopy)
60885:         newFile.copyTo(aTargetDirectory, null);
60885:       else
56256:         newFile.moveTo(aTargetDirectory, null);
56256:     }
56256:     catch (e) {
60885:       ERROR("Failed to " + (aCopy ? "copy" : "move") + " file " + aFile.path +
60885:             " to " + aTargetDirectory.path, e);
57401:       throw e;
56256:     }
69087:     this._installedFiles.push({ oldFile: oldFile, newFile: newFile });
56256:   },
56256: 
60885:   _installDirectory: function(aDirectory, aTargetDirectory, aCopy) {
56256:     let newDir = aTargetDirectory.clone();
56256:     newDir.append(aDirectory.leafName);
56256:     try {
56256:       newDir.create(Ci.nsILocalFile.DIRECTORY_TYPE, FileUtils.PERMS_DIRECTORY);
56256:     }
56256:     catch (e) {
57401:       ERROR("Failed to create directory " + newDir.path, e);
57401:       throw e;
56256:     }
56256:     this._createdDirs.push(newDir);
56256: 
56256:     let entries = aDirectory.directoryEntries
56256:                             .QueryInterface(Ci.nsIDirectoryEnumerator);
60072:     let cacheEntries = [];
56256:     try {
56256:       let entry;
56256:       while (entry = entries.nextFile)
60072:         cacheEntries.push(entry);
56256:     }
56256:     finally {
56256:       entries.close();
56256:     }
56256: 
60072:     cacheEntries.forEach(function(aEntry) {
60072:       try {
60885:         this._installDirEntry(aEntry, newDir, aCopy);
60072:       }
60072:       catch (e) {
60885:         ERROR("Failed to " + (aCopy ? "copy" : "move") + " entry " +
60885:               aEntry.path, e);
60072:         throw e;
60072:       }
60072:     }, this);
60072: 
60885:     // If this is only a copy operation then there is nothing else to do
60885:     if (aCopy)
60885:       return;
60885: 
56256:     // The directory should be empty by this point. If it isn't this will throw
56256:     // and all of the operations will be rolled back
56256:     try {
56256:       aDirectory.permissions = FileUtils.PERMS_DIRECTORY;
56256:       aDirectory.remove(false);
56256:     }
56256:     catch (e) {
57401:       ERROR("Failed to remove directory " + aDirectory.path, e);
57401:       throw e;
56256:     }
56256: 
56256:     // Note we put the directory move in after all the file moves so the
56256:     // directory is recreated before all the files are moved back
60885:     this._installedFiles.push({ oldFile: aDirectory, newFile: newDir });
56256:   },
56256: 
60885:   _installDirEntry: function(aDirEntry, aTargetDirectory, aCopy) {
58901:     try {
86316:       if (aDirEntry.isDirectory())
60885:         this._installDirectory(aDirEntry, aTargetDirectory, aCopy);
56256:       else
60885:         this._installFile(aDirEntry, aTargetDirectory, aCopy);
58901:     }
58901:     catch (e) {
60885:       ERROR("Failure " + (aCopy ? "copying" : "moving") + " " + aDirEntry.path +
60885:             " to " + aTargetDirectory.path);
58901:       throw e;
58901:     }
56256:   },
56256: 
56256:   /**
56256:    * Moves a file or directory into a new directory. If an error occurs then all
56256:    * files that have been moved will be moved back to their original location.
56256:    *
56256:    * @param  aFile
56256:    *         The file or directory to be moved.
56256:    * @param  aTargetDirectory
56256:    *         The directory to move into, this is expected to be an empty
56256:    *         directory.
56256:    */
56256:   move: function(aFile, aTargetDirectory) {
56256:     try {
60885:       this._installDirEntry(aFile, aTargetDirectory, false);
56256:     }
56256:     catch (e) {
56256:       this.rollback();
56256:       throw e;
56256:     }
56256:   },
56256: 
56256:   /**
60885:    * Copies a file or directory into a new directory. If an error occurs then
60885:    * all new files that have been created will be removed.
60885:    *
60885:    * @param  aFile
60885:    *         The file or directory to be copied.
60885:    * @param  aTargetDirectory
60885:    *         The directory to copy into, this is expected to be an empty
60885:    *         directory.
60885:    */
60885:   copy: function(aFile, aTargetDirectory) {
60885:     try {
60885:       this._installDirEntry(aFile, aTargetDirectory, true);
60885:     }
60885:     catch (e) {
60885:       this.rollback();
60885:       throw e;
60885:     }
60885:   },
60885: 
60885:   /**
56256:    * Rolls back all the moves that this operation performed. If an exception
56256:    * occurs here then both old and new directories are left in an indeterminate
56256:    * state
56256:    */
56256:   rollback: function() {
60885:     while (this._installedFiles.length > 0) {
60885:       let move = this._installedFiles.pop();
86316:       if (move.newFile.isDirectory()) {
56256:         let oldDir = move.oldFile.parent.clone();
56256:         oldDir.append(move.oldFile.leafName);
56256:         oldDir.create(Ci.nsILocalFile.DIRECTORY_TYPE, FileUtils.PERMS_DIRECTORY);
56256:       }
60885:       else if (!move.oldFile) {
60885:         // No old file means this was a copied file
60885:         move.newFile.remove(true);
60885:       }
56256:       else {
56256:         move.newFile.moveTo(move.oldFile.parent, null);
56256:       }
56256:     }
56256: 
56256:     while (this._createdDirs.length > 0)
56256:       recursiveRemove(this._createdDirs.pop());
56256:   }
56256: };
56256: 
56256: /**
41550:  * Gets the currently selected locale for display.
41550:  * @return  the selected locale or "en-US" if none is selected
41550:  */
41550: function getLocale() {
52422:   if (Prefs.getBoolPref(PREF_MATCH_OS_LOCALE, false))
41550:     return Services.locale.getLocaleComponentForUserAgent();
69949:   let locale = Prefs.getComplexValue(PREF_SELECTED_LOCALE, Ci.nsIPrefLocalizedString);
63430:   if (locale)
63430:     return locale;
41550:   return Prefs.getCharPref(PREF_SELECTED_LOCALE, "en-US");
41550: }
41550: 
41550: /**
41550:  * Selects the closest matching locale from a list of locales.
41550:  *
41584:  * @param  aLocales
41550:  *         An array of locales
41550:  * @return the best match for the currently selected locale
41550:  */
41584: function findClosestLocale(aLocales) {
41550:   let appLocale = getLocale();
41550: 
41550:   // Holds the best matching localized resource
41550:   var bestmatch = null;
41550:   // The number of locale parts it matched with
41550:   var bestmatchcount = 0;
41550:   // The number of locale parts in the match
41550:   var bestpartcount = 0;
41550: 
41550:   var matchLocales = [appLocale.toLowerCase()];
41550:   /* If the current locale is English then it will find a match if there is
41550:      a valid match for en-US so no point searching that locale too. */
41550:   if (matchLocales[0].substring(0, 3) != "en-")
41550:     matchLocales.push("en-us");
41550: 
41550:   for each (var locale in matchLocales) {
41550:     var lparts = locale.split("-");
41584:     for each (var localized in aLocales) {
74689:       for each (let found in localized.locales) {
41550:         found = found.toLowerCase();
41550:         // Exact match is returned immediately
41550:         if (locale == found)
41550:           return localized;
41550: 
41550:         var fparts = found.split("-");
41550:         /* If we have found a possible match and this one isn't any longer
41550:            then we dont need to check further. */
41550:         if (bestmatch && fparts.length < bestmatchcount)
41550:           continue;
41550: 
41550:         // Count the number of parts that match
41550:         var maxmatchcount = Math.min(fparts.length, lparts.length);
41550:         var matchcount = 0;
41550:         while (matchcount < maxmatchcount &&
41550:                fparts[matchcount] == lparts[matchcount])
41550:           matchcount++;
41550: 
41550:         /* If we matched more than the last best match or matched the same and
41550:            this locale is less specific than the last best match. */
41550:         if (matchcount > bestmatchcount ||
41550:            (matchcount == bestmatchcount && fparts.length < bestpartcount)) {
41550:           bestmatch = localized;
41550:           bestmatchcount = matchcount;
41550:           bestpartcount = fparts.length;
41550:         }
41550:       }
41550:     }
41550:     // If we found a valid match for this locale return it
41550:     if (bestmatch)
41550:       return bestmatch;
41550:   }
41550:   return null;
41550: }
41550: 
41550: /**
70084:  * Sets the userDisabled and softDisabled properties of an add-on based on what
70084:  * values those properties had for a previous instance of the add-on. The
70084:  * previous instance may be a previous install or in the case of an application
70084:  * version change the same add-on.
70084:  *
70084:  * @param  aOldAddon
70084:  *         The previous instance of the add-on
70084:  * @param  aNewAddon
70084:  *         The new instance of the add-on
70084:  * @param  aAppVersion
70084:  *         The optional application version to use when checking the blocklist
70084:  *         or undefined to use the current application
70084:  * @param  aPlatformVersion
70084:  *         The optional platform version to use when checking the blocklist or
70084:  *         undefined to use the current platform
70084:  */
70084: function applyBlocklistChanges(aOldAddon, aNewAddon, aOldAppVersion,
70084:                                aOldPlatformVersion) {
70084:   // Copy the properties by default
70084:   aNewAddon.userDisabled = aOldAddon.userDisabled;
70084:   aNewAddon.softDisabled = aOldAddon.softDisabled;
70084: 
70084:   let bs = Cc["@mozilla.org/extensions/blocklist;1"].
70084:            getService(Ci.nsIBlocklistService);
70084: 
70084:   let oldBlocklistState = bs.getAddonBlocklistState(aOldAddon.id,
70084:                                                     aOldAddon.version,
70084:                                                     aOldAppVersion,
70084:                                                     aOldPlatformVersion);
70084:   let newBlocklistState = bs.getAddonBlocklistState(aNewAddon.id,
70084:                                                     aNewAddon.version);
70084: 
70084:   // If the blocklist state hasn't changed then the properties don't need to
70084:   // change
70084:   if (newBlocklistState == oldBlocklistState)
70084:     return;
70084: 
70084:   if (newBlocklistState == Ci.nsIBlocklistService.STATE_SOFTBLOCKED) {
70084:     if (aNewAddon.type != "theme") {
70084:       // The add-on has become softblocked, set softDisabled if it isn't already
70084:       // userDisabled
70084:       aNewAddon.softDisabled = !aNewAddon.userDisabled;
70084:     }
70084:     else {
70084:       // Themes just get userDisabled to switch back to the default theme
70084:       aNewAddon.userDisabled = true;
70084:     }
70084:   }
70084:   else {
70084:     // If the new add-on is not softblocked then it cannot be softDisabled
70084:     aNewAddon.softDisabled = false;
70084:   }
70084: }
70084: 
70084: /**
41550:  * Calculates whether an add-on should be appDisabled or not.
41550:  *
41584:  * @param  aAddon
41550:  *         The add-on to check
41550:  * @return true if the add-on should not be appDisabled
41550:  */
41584: function isUsableAddon(aAddon) {
41550:   // Hack to ensure the default theme is always usable
41584:   if (aAddon.type == "theme" && aAddon.internalName == XPIProvider.defaultSkin)
41550:     return true;
47136: 
47136:   if (aAddon.blocklistState == Ci.nsIBlocklistService.STATE_BLOCKED)
47136:     return false;
47136: 
47136:   if (XPIProvider.checkUpdateSecurity && !aAddon.providesUpdatesSecurely)
47136:     return false;
47136: 
47136:   if (!aAddon.isPlatformCompatible)
47136:     return false;
47136: 
41550:   if (XPIProvider.checkCompatibility) {
41584:     if (!aAddon.isCompatible)
41550:       return false;
41550:   }
41550:   else {
41584:     if (!aAddon.matchingTargetApplication)
41550:       return false;
41550:   }
47136: 
47136:   return true;
41550: }
41550: 
70084: function isAddonDisabled(aAddon) {
70084:   return aAddon.appDisabled || aAddon.softDisabled || aAddon.userDisabled;
70084: }
70084: 
41590: this.__defineGetter__("gRDF", function() {
41590:   delete this.gRDF;
41590:   return this.gRDF = Cc["@mozilla.org/rdf/rdf-service;1"].
41590:                      getService(Ci.nsIRDFService);
41590: });
41590: 
41590: function EM_R(aProperty) {
41590:   return gRDF.GetResource(PREFIX_NS_EM + aProperty);
41590: }
41590: 
41590: /**
41590:  * Converts an RDF literal, resource or integer into a string.
41590:  *
41590:  * @param  aLiteral
41590:  *         The RDF object to convert
41590:  * @return a string if the object could be converted or null
41590:  */
41590: function getRDFValue(aLiteral) {
41590:   if (aLiteral instanceof Ci.nsIRDFLiteral)
41590:     return aLiteral.Value;
41590:   if (aLiteral instanceof Ci.nsIRDFResource)
41590:     return aLiteral.Value;
41590:   if (aLiteral instanceof Ci.nsIRDFInt)
41590:     return aLiteral.Value;
41590:   return null;
41590: }
41590: 
41590: /**
41590:  * Gets an RDF property as a string
41590:  *
41590:  * @param  aDs
41590:  *         The RDF datasource to read the property from
41590:  * @param  aResource
41590:  *         The RDF resource to read the property from
41590:  * @param  aProperty
41590:  *         The property to read
41590:  * @return a string if the property existed or null
41590:  */
41590: function getRDFProperty(aDs, aResource, aProperty) {
41590:   return getRDFValue(aDs.GetTarget(aResource, EM_R(aProperty), true));
41590: }
41590: 
41550: /**
41550:  * Reads an AddonInternal object from an RDF stream.
41550:  *
41584:  * @param  aUri
41550:  *         The URI that the manifest is being read from
41584:  * @param  aStream
41550:  *         An open stream to read the RDF from
41550:  * @return an AddonInternal object
41550:  * @throws if the install manifest in the RDF stream is corrupt or could not
41550:  *         be read
41550:  */
41584: function loadManifestFromRDF(aUri, aStream) {
41584:   function getPropertyArray(aDs, aSource, aProperty) {
41550:     let values = [];
41584:     let targets = aDs.GetTargets(aSource, EM_R(aProperty), true);
41550:     while (targets.hasMoreElements())
41590:       values.push(getRDFValue(targets.getNext()));
41550: 
41550:     return values;
41550:   }
41550: 
46185:   /**
46185:    * Reads locale properties from either the main install manifest root or
46185:    * an em:localized section in the install manifest.
46185:    *
46185:    * @param  aDs
46185:    *         The nsIRDFDatasource to read from
46185:    * @param  aSource
46185:    *         The nsIRDFResource to read the properties from
46185:    * @param  isDefault
46185:    *         True if the locale is to be read from the main install manifest
46185:    *         root
46185:    * @param  aSeenLocales
46185:    *         An array of locale names already seen for this install manifest.
46185:    *         Any locale names seen as a part of this function will be added to
46185:    *         this array
46185:    * @return an object containing the locale properties
46185:    */
46185:   function readLocale(aDs, aSource, isDefault, aSeenLocales) {
41550:     let locale = { };
41550:     if (!isDefault) {
41550:       locale.locales = [];
41584:       let targets = ds.GetTargets(aSource, EM_R("locale"), true);
46185:       while (targets.hasMoreElements()) {
46185:         let localeName = getRDFValue(targets.getNext());
46185:         if (!localeName) {
46185:           WARN("Ignoring empty locale in localized properties");
46185:           continue;
46185:         }
46185:         if (aSeenLocales.indexOf(localeName) != -1) {
46185:           WARN("Ignoring duplicate locale in localized properties");
46185:           continue;
46185:         }
46185:         aSeenLocales.push(localeName);
46185:         locale.locales.push(localeName);
46185:       }
46185: 
46185:       if (locale.locales.length == 0) {
46185:         WARN("Ignoring localized properties with no listed locales");
46185:         return null;
46185:       }
41550:     }
41550: 
41584:     PROP_LOCALE_SINGLE.forEach(function(aProp) {
41590:       locale[aProp] = getRDFProperty(aDs, aSource, aProp);
41550:     });
41550: 
41584:     PROP_LOCALE_MULTI.forEach(function(aProp) {
41584:       locale[aProp] = getPropertyArray(aDs, aSource,
41584:                                        aProp.substring(0, aProp.length - 1));
41550:     });
41550: 
41550:     return locale;
41550:   }
41550: 
41550:   let rdfParser = Cc["@mozilla.org/rdf/xml-parser;1"].
41550:                   createInstance(Ci.nsIRDFXMLParser)
41550:   let ds = Cc["@mozilla.org/rdf/datasource;1?name=in-memory-datasource"].
41550:            createInstance(Ci.nsIRDFDataSource);
41584:   let listener = rdfParser.parseAsync(ds, aUri);
41550:   let channel = Cc["@mozilla.org/network/input-stream-channel;1"].
41550:                 createInstance(Ci.nsIInputStreamChannel);
41584:   channel.setURI(aUri);
41584:   channel.contentStream = aStream;
41550:   channel.QueryInterface(Ci.nsIChannel);
41550:   channel.contentType = "text/xml";
41550: 
41550:   listener.onStartRequest(channel, null);
41550: 
41550:   try {
41550:     let pos = 0;
41584:     let count = aStream.available();
41550:     while (count > 0) {
41584:       listener.onDataAvailable(channel, null, aStream, pos, count);
41550:       pos += count;
41584:       count = aStream.available();
41550:     }
41550:     listener.onStopRequest(channel, null, Components.results.NS_OK);
41550:   }
41550:   catch (e) {
41550:     listener.onStopRequest(channel, null, e.result);
41550:     throw e;
41550:   }
41550: 
41590:   let root = gRDF.GetResource(RDFURI_INSTALL_MANIFEST_ROOT);
41550:   let addon = new AddonInternal();
41584:   PROP_METADATA.forEach(function(aProp) {
41590:     addon[aProp] = getRDFProperty(ds, root, aProp);
41550:   });
52422:   addon.unpack = getRDFProperty(ds, root, "unpack") == "true";
41550: 
41550:   if (!addon.type) {
41550:     addon.type = addon.internalName ? "theme" : "extension";
41550:   }
41550:   else {
71218:     let type = addon.type;
71218:     addon.type = null;
41550:     for (let name in TYPES) {
71218:       if (TYPES[name] == type) {
41550:         addon.type = name;
41550:         break;
41550:       }
41550:     }
41550:   }
47133: 
41550:   if (!(addon.type in TYPES))
41550:     throw new Error("Install manifest specifies unknown type: " + addon.type);
47133: 
48669:   if (addon.type != "multipackage") {
48669:     if (!addon.id)
48669:       throw new Error("No ID in install manifest");
48669:     if (!gIDTest.test(addon.id))
48669:       throw new Error("Illegal add-on ID " + addon.id);
48669:     if (!addon.version)
48669:       throw new Error("No version in install manifest");
48669:   }
48669: 
81117:   // Only read the bootstrap and strictCompatibility properties for extensions.
47133:   if (addon.type == "extension") {
47133:     addon.bootstrap = getRDFProperty(ds, root, "bootstrap") == "true";
81117:     addon.strictCompatibility = getRDFProperty(ds, root, "strictCompatibility") == "true";
71220:     if (addon.optionsType &&
71220:         addon.optionsType != AddonManager.OPTIONS_TYPE_DIALOG &&
72001:         addon.optionsType != AddonManager.OPTIONS_TYPE_INLINE &&
72001:         addon.optionsType != AddonManager.OPTIONS_TYPE_TAB) {
71220:       throw new Error("Install manifest specifies unknown type: " + addon.optionsType);
71220:     }
47133:   }
47133:   else {
79913:     // spell check dictionaries never require a restart
79913:     if (addon.type == "dictionary")
79913:       addon.bootstrap = true;
79913: 
71220:     // Only extensions are allowed to provide an optionsURL, optionsType or aboutURL. For
47133:     // all other types they are silently ignored
41583:     addon.optionsURL = null;
71220:     addon.optionsType = null;
41583:     addon.aboutURL = null;
81117:     addon.strictCompatibility = true;
47133: 
47133:     if (addon.type == "theme") {
47133:       if (!addon.internalName)
47133:         throw new Error("Themes must include an internalName property");
47133:       addon.skinnable = getRDFProperty(ds, root, "skinnable") == "true";
47133:     }
47133:   }
41591: 
41550:   addon.defaultLocale = readLocale(ds, root, true);
41550: 
46185:   let seenLocales = [];
41550:   addon.locales = [];
41550:   let targets = ds.GetTargets(root, EM_R("localized"), true);
41550:   while (targets.hasMoreElements()) {
41550:     let target = targets.getNext().QueryInterface(Ci.nsIRDFResource);
46185:     let locale = readLocale(ds, target, false, seenLocales);
46185:     if (locale)
46185:       addon.locales.push(locale);
46185:   }
46185: 
46185:   let seenApplications = [];
41550:   addon.targetApplications = [];
41550:   targets = ds.GetTargets(root, EM_R("targetApplication"), true);
41550:   while (targets.hasMoreElements()) {
41550:     let target = targets.getNext().QueryInterface(Ci.nsIRDFResource);
41550:     let targetAppInfo = {};
41584:     PROP_TARGETAPP.forEach(function(aProp) {
41590:       targetAppInfo[aProp] = getRDFProperty(ds, target, aProp);
41550:     });
41550:     if (!targetAppInfo.id || !targetAppInfo.minVersion ||
46185:         !targetAppInfo.maxVersion) {
46185:       WARN("Ignoring invalid targetApplication entry in install manifest");
46185:       continue;
46185:     }
46185:     if (seenApplications.indexOf(targetAppInfo.id) != -1) {
46185:       WARN("Ignoring duplicate targetApplication entry for " + targetAppInfo.id +
46185:            " in install manifest");
46185:       continue;
46185:     }
46185:     seenApplications.push(targetAppInfo.id);
41550:     addon.targetApplications.push(targetAppInfo);
41550:   }
41550: 
47133:   // Note that we don't need to check for duplicate targetPlatform entries since
47133:   // the RDF service coalesces them for us.
47133:   let targetPlatforms = getPropertyArray(ds, root, "targetPlatform");
47133:   addon.targetPlatforms = [];
47133:   targetPlatforms.forEach(function(aPlatform) {
47133:     let platform = {
47133:       os: null,
47133:       abi: null
47133:     };
47133: 
47133:     let pos = aPlatform.indexOf("_");
47133:     if (pos != -1) {
47133:       platform.os = aPlatform.substring(0, pos);
47133:       platform.abi = aPlatform.substring(pos + 1);
47133:     }
47133:     else {
47133:       platform.os = aPlatform;
47133:     }
47133: 
47133:     addon.targetPlatforms.push(platform);
47133:   });
41550: 
54549:   // A theme's userDisabled value is true if the theme is not the selected skin
54549:   // or if there is an active lightweight theme. We ignore whether softblocking
54549:   // is in effect since it would change the active theme.
54549:   if (addon.type == "theme") {
54549:     addon.userDisabled = !!LightweightThemeManager.currentTheme ||
54549:                          addon.internalName != XPIProvider.selectedSkin;
54549:   }
54549:   else {
70084:     addon.userDisabled = false;
70084:     addon.softDisabled = addon.blocklistState == Ci.nsIBlocklistService.STATE_SOFTBLOCKED;
54549:   }
47133: 
53775:   addon.applyBackgroundUpdates = AddonManager.AUTOUPDATE_DEFAULT;
41586: 
84963:   // Generate random GUID used for Sync.
84963:   // This was lifted from util.js:makeGUID() from services-sync.
84963:   let rng = Cc["@mozilla.org/security/random-generator;1"].
84963:             createInstance(Ci.nsIRandomGenerator);
84963:   let bytes = rng.generateRandomBytes(9);
84963:   let byte_string = [String.fromCharCode(byte) for each (byte in bytes)]
84963:                     .join("");
84963:   // Base64 encode
87639:   addon.syncGUID = btoa(byte_string).replace(/\+/g, '-')
87639:                                     .replace(/\//g, '_');
84963: 
41550:   return addon;
41550: }
41550: 
41550: /**
41550:  * Loads an AddonInternal object from an add-on extracted in a directory.
41550:  *
41584:  * @param  aDir
41550:  *         The nsIFile directory holding the add-on
41550:  * @return an AddonInternal object
41550:  * @throws if the directory does not contain a valid install manifest
41550:  */
41584: function loadManifestFromDir(aDir) {
47133:   function getFileSize(aFile) {
47133:     if (aFile.isSymlink())
47133:       return 0;
47133: 
47133:     if (!aFile.isDirectory())
47133:       return aFile.fileSize;
47133: 
47133:     let size = 0;
47133:     let entries = aFile.directoryEntries.QueryInterface(Ci.nsIDirectoryEnumerator);
47133:     let entry;
47133:     while (entry = entries.nextFile)
47133:       size += getFileSize(entry);
47133:     entries.close();
47133:     return size;
47133:   }
47133: 
41584:   let file = aDir.clone();
41550:   file.append(FILE_INSTALL_MANIFEST);
41550:   if (!file.exists() || !file.isFile())
54205:     throw new Error("Directory " + aDir.path + " does not contain a valid " +
41550:                     "install manifest");
41550: 
41550:   let fis = Cc["@mozilla.org/network/file-input-stream;1"].
41550:             createInstance(Ci.nsIFileInputStream);
41550:   fis.init(file, -1, -1, false);
41550:   let bis = Cc["@mozilla.org/network/buffered-input-stream;1"].
41550:             createInstance(Ci.nsIBufferedInputStream);
41550:   bis.init(fis, 4096);
41550: 
41550:   try {
41550:     let addon = loadManifestFromRDF(Services.io.newFileURI(file), bis);
41584:     addon._sourceBundle = aDir.clone().QueryInterface(Ci.nsILocalFile);
47133:     addon.size = getFileSize(aDir);
81116: 
81116:     file = aDir.clone();
81116:     file.append("chrome.manifest");
81116:     let chromeManifest = ChromeManifestParser.parseSync(Services.io.newFileURI(file));
81116:     addon.hasBinaryComponents = ChromeManifestParser.hasType(chromeManifest,
81116:                                                              "binary-component");
81116: 
82368:     addon.appDisabled = !isUsableAddon(addon);
41550:     return addon;
41550:   }
41550:   finally {
41550:     bis.close();
41550:     fis.close();
41550:   }
41550: }
41550: 
41550: /**
48669:  * Loads an AddonInternal object from an nsIZipReader for an add-on.
47133:  *
47133:  * @param  aZipReader
48669:  *         An open nsIZipReader for the add-on's files
47133:  * @return an AddonInternal object
48669:  * @throws if the XPI file does not contain a valid install manifest
47133:  */
47133: function loadManifestFromZipReader(aZipReader) {
47133:   let zis = aZipReader.getInputStream(FILE_INSTALL_MANIFEST);
47133:   let bis = Cc["@mozilla.org/network/buffered-input-stream;1"].
47133:             createInstance(Ci.nsIBufferedInputStream);
47133:   bis.init(zis, 4096);
47133: 
47133:   try {
47133:     let uri = buildJarURI(aZipReader.file, FILE_INSTALL_MANIFEST);
47133:     let addon = loadManifestFromRDF(uri, bis);
47133:     addon._sourceBundle = aZipReader.file;
47133: 
47133:     addon.size = 0;
47133:     let entries = aZipReader.findEntries(null);
47133:     while (entries.hasMore())
47133:       addon.size += aZipReader.getEntry(entries.getNext()).realSize;
47133: 
81116:     // Binary components can only be loaded from unpacked addons.
81116:     if (addon.unpack) {
81116:       uri = buildJarURI(aZipReader.file, "chrome.manifest");
81116:       let chromeManifest = ChromeManifestParser.parseSync(uri);
81116:       addon.hasBinaryComponents = ChromeManifestParser.hasType(chromeManifest,
81116:                                                                "binary-component");
81116:     } else {
81116:       addon.hasBinaryComponents = false;
81116:     }
81116: 
82368:     addon.appDisabled = !isUsableAddon(addon);
47133:     return addon;
47133:   }
47133:   finally {
47133:     bis.close();
47133:     zis.close();
47133:   }
47133: }
47133: 
47133: /**
48669:  * Loads an AddonInternal object from an add-on in an XPI file.
48669:  *
48669:  * @param  aXPIFile
48669:  *         An nsIFile pointing to the add-on's XPI file
48669:  * @return an AddonInternal object
48669:  * @throws if the XPI file does not contain a valid install manifest
48669:  */
48669: function loadManifestFromZipFile(aXPIFile) {
48669:   let zipReader = Cc["@mozilla.org/libjar/zip-reader;1"].
48669:                   createInstance(Ci.nsIZipReader);
48669:   try {
48669:     zipReader.open(aXPIFile);
48669: 
48669:     return loadManifestFromZipReader(zipReader);
48669:   }
48669:   finally {
48669:     zipReader.close();
48669:   }
48669: }
48669: 
60885: function loadManifestFromFile(aFile) {
60885:   if (aFile.isFile())
60885:     return loadManifestFromZipFile(aFile);
60885:   else
60885:     return loadManifestFromDir(aFile);
60885: }
60885: 
48669: /**
71854:  * Gets an nsIURI for a file within another file, either a directory or an XPI
71854:  * file. If aFile is a directory then this will return a file: URI, if it is an
71854:  * XPI file then it will return a jar: URI.
71854:  *
71854:  * @param  aFile
71854:  *         The file containing the resources, must be either a directory or an
71854:  *         XPI file
71854:  * @param  aPath
71854:  *         The path to find the resource at, "/" separated. If aPath is empty
71854:  *         then the uri to the root of the contained files will be returned
71854:  * @return an nsIURI pointing at the resource
71854:  */
71854: function getURIForResourceInFile(aFile, aPath) {
71854:   if (aFile.isDirectory()) {
71854:     let resource = aFile.clone();
71854:     if (aPath) {
71854:       aPath.split("/").forEach(function(aPart) {
71854:         resource.append(aPart);
71854:       });
71854:     }
71854:     return NetUtil.newURI(resource);
71854:   }
71854: 
71854:   return buildJarURI(aFile, aPath);
71854: }
71854: 
71854: /**
41550:  * Creates a jar: URI for a file inside a ZIP file.
41550:  *
41584:  * @param  aJarfile
41550:  *         The ZIP file as an nsIFile
41584:  * @param  aPath
41550:  *         The path inside the ZIP file
41550:  * @return an nsIURI for the file
41550:  */
41584: function buildJarURI(aJarfile, aPath) {
41584:   let uri = Services.io.newFileURI(aJarfile);
41584:   uri = "jar:" + uri.spec + "!/" + aPath;
41550:   return NetUtil.newURI(uri);
41550: }
41550: 
41550: /**
70154:  * Sends local and remote notifications to flush a JAR file cache entry
70154:  *
70154:  * @param aJarFile
70154:  *        The ZIP/XPI/JAR file as a nsIFile
70154:  */
70154: function flushJarCache(aJarFile) {
70154:   Services.obs.notifyObservers(aJarFile, "flush-cache-entry", null);
70154:   Cc["@mozilla.org/globalmessagemanager;1"].getService(Ci.nsIChromeFrameMessageManager)
70154:     .sendAsyncMessage(MSG_JAR_FLUSH, aJarFile.path);
70154: }
70154: 
71854: function flushStartupCache() {
71854:   // Init this, so it will get the notification.
71854:   Services.obs.notifyObservers(null, "startupcache-invalidate", null);
71854: }
71854: 
70154: /**
48669:  * Creates and returns a new unique temporary file. The caller should delete
48669:  * the file when it is no longer needed.
56256:  *
48669:  * @return an nsIFile that points to a randomly named, initially empty file in
48669:  *         the OS temporary files directory
48669:  */
48669: function getTemporaryFile() {
48669:   let file = FileUtils.getDir(KEY_TEMPDIR, []);
48669:   let random = Math.random().toString(36).replace(/0./, '').substr(-3);
48669:   file.append("tmp-" + random + ".xpi");
48669:   file.createUnique(Ci.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
48669: 
48669:   return file;
48669: }
48669: 
48669: /**
41550:  * Extracts files from a ZIP file into a directory.
41550:  *
41584:  * @param  aZipFile
41550:  *         The source ZIP file that contains the add-on.
41584:  * @param  aDir
41550:  *         The nsIFile to extract to.
41550:  */
41584: function extractFiles(aZipFile, aDir) {
41584:   function getTargetFile(aDir, entry) {
41584:     let target = aDir.clone();
41584:     entry.split("/").forEach(function(aPart) {
41584:       target.append(aPart);
41550:     });
41550:     return target;
41550:   }
41550: 
41550:   let zipReader = Cc["@mozilla.org/libjar/zip-reader;1"].
41550:                   createInstance(Ci.nsIZipReader);
41584:   zipReader.open(aZipFile);
41550: 
41550:   try {
41550:     // create directories first
41550:     let entries = zipReader.findEntries("*/");
41550:     while (entries.hasMore()) {
41550:       var entryName = entries.getNext();
41584:       let target = getTargetFile(aDir, entryName);
41550:       if (!target.exists()) {
41550:         try {
41550:           target.create(Ci.nsILocalFile.DIRECTORY_TYPE,
41550:                         FileUtils.PERMS_DIRECTORY);
41550:         }
41550:         catch (e) {
41550:           ERROR("extractFiles: failed to create target directory for " +
57401:                 "extraction file = " + target.path, e);
41550:         }
41550:       }
41550:     }
41550: 
41550:     entries = zipReader.findEntries(null);
41550:     while (entries.hasMore()) {
41550:       let entryName = entries.getNext();
41584:       let target = getTargetFile(aDir, entryName);
41550:       if (target.exists())
41550:         continue;
41550: 
41550:       zipReader.extract(entryName, target);
41550:       target.permissions |= FileUtils.PERMS_FILE;
41550:     }
41550:   }
41550:   finally {
41550:     zipReader.close();
41550:   }
41550: }
41550: 
41550: /**
41550:  * Verifies that a zip file's contents are all signed by the same principal.
41550:  * Directory entries and anything in the META-INF directory are not checked.
41550:  *
41584:  * @param  aZip
41550:  *         A nsIZipReader to check
41584:  * @param  aPrincipal
41550:  *         The nsIPrincipal to compare against
41550:  * @return true if all the contents that should be signed were signed by the
41550:  *         principal
41550:  */
41584: function verifyZipSigning(aZip, aPrincipal) {
41550:   var count = 0;
41584:   var entries = aZip.findEntries(null);
41550:   while (entries.hasMore()) {
41550:     var entry = entries.getNext();
41550:     // Nothing in META-INF is in the manifest.
41550:     if (entry.substr(0, 9) == "META-INF/")
41550:       continue;
41550:     // Directory entries aren't in the manifest.
41550:     if (entry.substr(-1) == "/")
41550:       continue;
41550:     count++;
41584:     var entryPrincipal = aZip.getCertificatePrincipal(entry);
41584:     if (!entryPrincipal || !aPrincipal.equals(entryPrincipal))
41550:       return false;
41550:   }
41584:   return aZip.manifestEntriesCount == count;
41550: }
41550: 
41550: /**
41550:  * Replaces %...% strings in an addon url (update and updateInfo) with
41550:  * appropriate values.
41550:  *
41584:  * @param  aAddon
41550:  *         The AddonInternal representing the add-on
41584:  * @param  aUri
41550:  *         The uri to escape
41584:  * @param  aUpdateType
41550:  *         An optional number representing the type of update, only applicable
41550:  *         when creating a url for retrieving an update manifest
41584:  * @param  aAppVersion
41550:  *         The optional application version to use for %APP_VERSION%
41550:  * @return the appropriately escaped uri.
41550:  */
41584: function escapeAddonURI(aAddon, aUri, aUpdateType, aAppVersion)
41550: {
84794:   let uri = AddonManager.escapeAddonURI(aAddon, aUri, aAppVersion);
41550: 
41550:   // If there is an updateType then replace the UPDATE_TYPE string
41584:   if (aUpdateType)
41584:     uri = uri.replace(/%UPDATE_TYPE%/g, aUpdateType);
41550: 
41550:   // If this add-on has compatibility information for either the current
41550:   // application or toolkit then replace the ITEM_MAXAPPVERSION with the
41550:   // maxVersion
41584:   let app = aAddon.matchingTargetApplication;
41550:   if (app)
41550:     var maxVersion = app.maxVersion;
41550:   else
41550:     maxVersion = "";
41550:   uri = uri.replace(/%ITEM_MAXAPPVERSION%/g, maxVersion);
41550: 
83134:   let compatMode = "normal";
83134:   if (!XPIProvider.checkCompatibility)
83134:     compatMode = "ignore";
83134:   else if (AddonManager.strictCompatibility)
83134:     compatMode = "strict";
83134:   uri = uri.replace(/%COMPATIBILITY_MODE%/g, compatMode);
83134: 
84794:   return uri;
41550: }
41550: 
41550: /**
41550:  * Copies properties from one object to another. If no target object is passed
41550:  * a new object will be created and returned.
41550:  *
41584:  * @param  aObject
41550:  *         An object to copy from
41584:  * @param  aProperties
41550:  *         An array of properties to be copied
41584:  * @param  aTarget
41550:  *         An optional target object to copy the properties to
41550:  * @return the object that the properties were copied onto
41550:  */
41584: function copyProperties(aObject, aProperties, aTarget) {
41584:   if (!aTarget)
41584:     aTarget = {};
41584:   aProperties.forEach(function(aProp) {
41584:     aTarget[aProp] = aObject[aProp];
41550:   });
41584:   return aTarget;
41550: }
41550: 
41550: /**
41550:  * Copies properties from a mozIStorageRow to an object. If no target object is
41550:  * passed a new object will be created and returned.
41550:  *
41584:  * @param  aRow
41550:  *         A mozIStorageRow to copy from
41584:  * @param  aProperties
41550:  *         An array of properties to be copied
41584:  * @param  aTarget
41550:  *         An optional target object to copy the properties to
41550:  * @return the object that the properties were copied onto
41550:  */
41584: function copyRowProperties(aRow, aProperties, aTarget) {
41584:   if (!aTarget)
41584:     aTarget = {};
41584:   aProperties.forEach(function(aProp) {
41584:     aTarget[aProp] = aRow.getResultByName(aProp);
41550:   });
41584:   return aTarget;
41550: }
41550: 
41550: /**
41550:  * A generator to synchronously return result rows from an mozIStorageStatement.
41550:  *
41584:  * @param  aStatement
41550:  *         The statement to execute
41550:  */
41584: function resultRows(aStatement) {
41550:   try {
42885:     while (stepStatement(aStatement))
41584:       yield aStatement.row;
41550:   }
41550:   finally {
41584:     aStatement.reset();
41550:   }
41550: }
41550: 
41550: /**
56256:  * Removes the specified files or directories in a staging directory and then if
56256:  * the staging directory is empty attempts to remove it.
56256:  *
56256:  * @param  aDir
56256:  *         nsIFile for the staging directory to clean up
56256:  * @param  aLeafNames
56256:  *         An array of file or directory to remove from the directory, the
56256:  *         array may be empty
56256:  */
56256: function cleanStagingDir(aDir, aLeafNames) {
56256:   aLeafNames.forEach(function(aName) {
56256:     let file = aDir.clone();
56256:     file.append(aName);
56256:     if (file.exists())
56256:       recursiveRemove(file);
56256:   });
56256: 
56256:   let dirEntries = aDir.directoryEntries.QueryInterface(Ci.nsIDirectoryEnumerator);
56256:   try {
56256:     if (dirEntries.nextFile)
56256:       return;
56256:   }
56256:   finally {
56256:     dirEntries.close();
56256:   }
56256: 
56256:   try {
56256:     aDir.permissions = FileUtils.PERMS_DIRECTORY;
56256:     aDir.remove(false);
56256:   }
56256:   catch (e) {
72311:     WARN("Failed to remove staging dir", e);
56256:     // Failing to remove the staging directory is ignorable
56256:   }
56256: }
56256: 
56256: /**
55436:  * Recursively removes a directory or file fixing permissions when necessary.
55436:  *
55436:  * @param  aFile
55436:  *         The nsIFile to remove
55436:  */
55436: function recursiveRemove(aFile) {
55436:   aFile.permissions = aFile.isDirectory() ? FileUtils.PERMS_DIRECTORY
55436:                                           : FileUtils.PERMS_FILE;
55436: 
55436:   try {
55436:     aFile.remove(true);
55436:     return;
55436:   }
55436:   catch (e) {
86316:     if (!aFile.isDirectory()) {
58902:       ERROR("Failed to remove file " + aFile.path, e);
55436:       throw e;
55436:     }
58902:   }
55436: 
55436:   let entry;
55436:   let dirEntries = aFile.directoryEntries.QueryInterface(Ci.nsIDirectoryEnumerator);
55436:   try {
55436:     while (entry = dirEntries.nextFile)
55436:       recursiveRemove(entry);
72311:     try {
55436:       aFile.remove(true);
55436:     }
72311:     catch (e) {
72311:       ERROR("Failed to remove empty directory " + aFile.path, e);
72311:       throw e;
72311:     }
72311:   }
55436:   finally {
55436:     dirEntries.close();
55436:   }
55436: }
55436: 
55436: /**
55169:  * Returns the timestamp of the most recently modified file in a directory,
55169:  * or simply the file's own timestamp if it is not a directory.
55169:  *
55169:  * @param  aFile
55169:  *         A non-null nsIFile object
55169:  * @return Epoch time, as described above. 0 for an empty directory.
55169:  */
55169: function recursiveLastModifiedTime(aFile) {
55169:   if (aFile.isFile())
55169:     return aFile.lastModifiedTime;
55169: 
55169:   if (aFile.isDirectory()) {
55169:     let entries = aFile.directoryEntries.QueryInterface(Ci.nsIDirectoryEnumerator);
55169:     let entry, time;
55169:     let maxTime = aFile.lastModifiedTime;
55169:     while (entry = entries.nextFile) {
55169:       time = recursiveLastModifiedTime(entry);
55169:       maxTime = Math.max(time, maxTime);
55169:     }
55169:     entries.close();
55169:     return maxTime;
55169:   }
55169: 
55169:   // If the file is something else, just ignore it.
55169:   return 0;
55169: }
55169: 
55169: /**
41550:  * A helpful wrapper around the prefs service that allows for default values
41550:  * when requested values aren't set.
41550:  */
41550: var Prefs = {
41550:   /**
41550:    * Gets a preference from the default branch ignoring user-set values.
41550:    *
41584:    * @param  aName
41550:    *         The name of the preference
41584:    * @param  aDefaultValue
41550:    *         A value to return if the preference does not exist
41584:    * @return the default value of the preference or aDefaultValue if there is
41550:    *         none
41550:    */
41584:   getDefaultCharPref: function(aName, aDefaultValue) {
41550:     try {
41584:       return Services.prefs.getDefaultBranch("").getCharPref(aName);
41550:     }
41550:     catch (e) {
41550:     }
41584:     return aDefaultValue;
41550:   },
41550: 
41550:   /**
41550:    * Gets a string preference.
41550:    *
41584:    * @param  aName
41584:    *         The name of the preference
41584:    * @param  aDefaultValue
41584:    *         A value to return if the preference does not exist
41584:    * @return the value of the preference or aDefaultValue if there is none
41584:    */
41584:   getCharPref: function(aName, aDefaultValue) {
41584:     try {
41584:       return Services.prefs.getCharPref(aName);
41584:     }
41584:     catch (e) {
41584:     }
41584:     return aDefaultValue;
41584:   },
41584: 
41584:   /**
63430:    * Gets a complex preference.
63430:    *
63430:    * @param  aName
63430:    *         The name of the preference
63430:    * @param  aType
63430:    *         The interface type of the preference
63430:    * @param  aDefaultValue
63430:    *         A value to return if the preference does not exist
63430:    * @return the value of the preference or aDefaultValue if there is none
63430:    */
69949:   getComplexValue: function(aName, aType, aDefaultValue) {
63430:     try {
69949:       return Services.prefs.getComplexValue(aName, aType).data;
63430:     }
63430:     catch (e) {
63430:     }
63430:     return aDefaultValue;
63430:   },
63430: 
63430:   /**
41584:    * Gets a boolean preference.
41584:    *
41584:    * @param  aName
41584:    *         The name of the preference
41584:    * @param  aDefaultValue
41584:    *         A value to return if the preference does not exist
41584:    * @return the value of the preference or aDefaultValue if there is none
41584:    */
41584:   getBoolPref: function(aName, aDefaultValue) {
41584:     try {
41584:       return Services.prefs.getBoolPref(aName);
41584:     }
41584:     catch (e) {
41584:     }
41584:     return aDefaultValue;
41584:   },
41584: 
41584:   /**
41584:    * Gets an integer preference.
41584:    *
41584:    * @param  aName
41550:    *         The name of the preference
41550:    * @param  defaultValue
41550:    *         A value to return if the preference does not exist
41550:    * @return the value of the preference or defaultValue if there is none
41550:    */
41584:   getIntPref: function(aName, defaultValue) {
41550:     try {
41584:       return Services.prefs.getIntPref(aName);
41550:     }
41550:     catch (e) {
41550:     }
41550:     return defaultValue;
70084:   },
70084: 
70084:   /**
70084:    * Clears a preference if it has a user value
70084:    *
70084:    * @param  aName
70084:    *         The name of the preference
70084:    */
70084:   clearUserPref: function(aName) {
70084:     if (Services.prefs.prefHasUserValue(aName))
70084:       Services.prefs.clearUserPref(aName);
41550:   }
41550: }
41550: 
41550: var XPIProvider = {
41550:   // An array of known install locations
41550:   installLocations: null,
41550:   // A dictionary of known install locations by name
41550:   installLocationsByName: null,
41550:   // An array of currently active AddonInstalls
41550:   installs: null,
41550:   // The default skin for the application
41550:   defaultSkin: "classic/1.0",
42089:   // The current skin used by the application
42089:   currentSkin: null,
42089:   // The selected skin to be used by the application when it is restarted. This
42089:   // will be the same as currentSkin when it is the skin to be used when the
42089:   // application is restarted
41550:   selectedSkin: null,
41550:   // The value of the checkCompatibility preference
41550:   checkCompatibility: true,
41550:   // The value of the checkUpdateSecurity preference
41550:   checkUpdateSecurity: true,
82276:   // The value of the minCompatibleAppVersion preference
82276:   minCompatibleAppVersion: null,
82276:   // The value of the minCompatiblePlatformVersion preference
82276:   minCompatiblePlatformVersion: null,
41550:   // A dictionary of the file descriptors for bootstrappable add-ons by ID
41550:   bootstrappedAddons: {},
41550:   // A dictionary of JS scopes of loaded bootstrappable add-ons by ID
41550:   bootstrapScopes: {},
50742:   // True if the platform could have activated extensions
50742:   extensionsActive: false,
50742: 
50742:   // True if all of the add-ons found during startup were installed in the
50742:   // application install location
50742:   allAppGlobal: true,
41575:   // A string listing the enabled add-ons for annotating crash reports
41575:   enabledAddons: null,
50742:   // An array of add-on IDs of add-ons that were inactive during startup
50742:   inactiveAddonIDs: [],
41550: 
41550:   /**
41550:    * Starts the XPI provider initializes the install locations and prefs.
51288:    *
51288:    * @param  aAppChanged
51288:    *         A tri-state value. Undefined means the current profile was created
51288:    *         for this session, true means the profile already existed but was
51288:    *         last used with an application with a different version number,
51288:    *         false means that the profile was last used by this version of the
51288:    *         application.
70084:    * @param  aOldAppVersion
70084:    *         The version of the application last run with this profile or null
70084:    *         if it is a new profile or the version is unknown
70084:    * @param  aOldPlatformVersion
70084:    *         The version of the platform last run with this profile or null
70084:    *         if it is a new profile or the version is unknown
70084:    */
70084:   startup: function XPI_startup(aAppChanged, aOldAppVersion, aOldPlatformVersion) {
41550:     LOG("startup");
41550:     this.installs = [];
41550:     this.installLocations = [];
41550:     this.installLocationsByName = {};
41550: 
41584:     function addDirectoryInstallLocation(aName, aKey, aPaths, aScope, aLocked) {
41578:       try {
41584:         var dir = FileUtils.getDir(aKey, aPaths);
41578:       }
41578:       catch (e) {
41578:         // Some directories aren't defined on some platforms, ignore them
41584:         LOG("Skipping unavailable install location " + aName);
41578:         return;
41578:       }
41578: 
41578:       try {
41584:         var location = new DirectoryInstallLocation(aName, dir, aScope, aLocked);
41578:       }
41578:       catch (e) {
57401:         WARN("Failed to add directory install location " + aName, e);
41578:         return;
41578:       }
41578: 
41578:       XPIProvider.installLocations.push(location);
41578:       XPIProvider.installLocationsByName[location.name] = location;
41578:     }
41578: 
41584:     function addRegistryInstallLocation(aName, aRootkey, aScope) {
41578:       try {
41584:         var location = new WinRegInstallLocation(aName, aRootkey, aScope);
41578:       }
41578:       catch (e) {
57401:         WARN("Failed to add registry install location " + aName, e);
41578:         return;
41578:       }
41578: 
41578:       XPIProvider.installLocations.push(location);
41578:       XPIProvider.installLocationsByName[location.name] = location;
41578:     }
41578: 
41578:     let hasRegistry = ("nsIWindowsRegKey" in Ci);
41578: 
41579:     let enabledScopes = Prefs.getIntPref(PREF_EM_ENABLED_SCOPES,
41579:                                          AddonManager.SCOPE_ALL);
41579: 
41550:     // These must be in order of priority for processFileChanges etc. to work
41579:     if (enabledScopes & AddonManager.SCOPE_SYSTEM) {
41579:       if (hasRegistry) {
41579:         addRegistryInstallLocation("winreg-app-global",
41579:                                    Ci.nsIWindowsRegKey.ROOT_KEY_LOCAL_MACHINE,
41579:                                    AddonManager.SCOPE_SYSTEM);
41579:       }
41579:       addDirectoryInstallLocation(KEY_APP_SYSTEM_LOCAL, "XRESysLExtPD",
41579:                                   [Services.appinfo.ID],
41579:                                   AddonManager.SCOPE_SYSTEM, true);
41579:       addDirectoryInstallLocation(KEY_APP_SYSTEM_SHARE, "XRESysSExtPD",
41579:                                   [Services.appinfo.ID],
41579:                                   AddonManager.SCOPE_SYSTEM, true);
41579:     }
41579: 
41579:     if (enabledScopes & AddonManager.SCOPE_APPLICATION) {
41579:       addDirectoryInstallLocation(KEY_APP_GLOBAL, KEY_APPDIR,
41579:                                   [DIR_EXTENSIONS],
41579:                                   AddonManager.SCOPE_APPLICATION, true);
41579:     }
41579: 
41579:     if (enabledScopes & AddonManager.SCOPE_USER) {
41579:       if (hasRegistry) {
41579:         addRegistryInstallLocation("winreg-app-user",
41579:                                    Ci.nsIWindowsRegKey.ROOT_KEY_CURRENT_USER,
41579:                                    AddonManager.SCOPE_USER);
41579:       }
41579:       addDirectoryInstallLocation(KEY_APP_SYSTEM_USER, "XREUSysExt",
41579:                                   [Services.appinfo.ID],
41579:                                   AddonManager.SCOPE_USER, true);
41579:     }
41579: 
41579:     // The profile location is always enabled
41579:     addDirectoryInstallLocation(KEY_APP_PROFILE, KEY_PROFILEDIR,
41579:                                 [DIR_EXTENSIONS],
41579:                                 AddonManager.SCOPE_PROFILE, false);
41550: 
41550:     this.defaultSkin = Prefs.getDefaultCharPref(PREF_GENERAL_SKINS_SELECTEDSKIN,
41550:                                                 "classic/1.0");
42089:     this.currentSkin = Prefs.getCharPref(PREF_GENERAL_SKINS_SELECTEDSKIN,
41550:                                          this.defaultSkin);
42089:     this.selectedSkin = this.currentSkin;
47636:     this.applyThemeChange();
41550: 
70820:     this.checkCompatibility = Prefs.getBoolPref(PREF_EM_CHECK_COMPATIBILITY,
41550:                                                 true)
41550:     this.checkUpdateSecurity = Prefs.getBoolPref(PREF_EM_CHECK_UPDATE_SECURITY,
41550:                                                  true)
82276:     this.minCompatibleAppVersion = Prefs.getCharPref(PREF_EM_MIN_COMPAT_APP_VERSION,
82276:                                                      null);
82276:     this.minCompatiblePlatformVersion = Prefs.getCharPref(PREF_EM_MIN_COMPAT_PLATFORM_VERSION,
82276:                                                           null);
47636:     this.enabledAddons = [];
47636: 
70820:     Services.prefs.addObserver(PREF_EM_CHECK_COMPATIBILITY, this, false);
47636:     Services.prefs.addObserver(PREF_EM_CHECK_UPDATE_SECURITY, this, false);
82276:     Services.prefs.addObserver(PREF_EM_MIN_COMPAT_APP_VERSION, this, false);
82276:     Services.prefs.addObserver(PREF_EM_MIN_COMPAT_PLATFORM_VERSION, this, false);
47636: 
70084:     let flushCaches = this.checkForChanges(aAppChanged, aOldAppVersion,
70084:                                            aOldPlatformVersion);
47636: 
47636:     // Changes to installed extensions may have changed which theme is selected
47636:     this.applyThemeChange();
47636: 
50742:     // If the application has been upgraded and there are add-ons outside the
50742:     // application directory then we may need to synchronize compatibility
72782:     // information but only if the mismatch UI isn't disabled
72782:     if (aAppChanged && !this.allAppGlobal &&
72782:         Prefs.getBoolPref(PREF_EM_SHOW_MISMATCH_UI, true)) {
75342:       this.showUpgradeUI();
60305:       flushCaches = true;
50742:     }
75342:     else if (aAppChanged === undefined) {
75342:       // For new profiles we will never need to show the add-on selection UI
75342:       Services.prefs.setBoolPref(PREF_SHOWN_SELECTION_UI, true);
75342:     }
50742: 
60305:     if (flushCaches) {
71854:       flushStartupCache();
63267: 
63267:       // UI displayed early in startup (like the compatibility UI) may have
63267:       // caused us to cache parts of the skin or locale in memory. These must
63267:       // be flushed to allow extension provided skins and locales to take full
63267:       // effect
63267:       Services.obs.notifyObservers(null, "chrome-flush-skin-caches", null);
63267:       Services.obs.notifyObservers(null, "chrome-flush-caches", null);
60305:     }
60305: 
41575:     this.enabledAddons = Prefs.getCharPref(PREF_EM_ENABLED_ADDONS, "");
41575:     if ("nsICrashReporter" in Ci &&
41575:         Services.appinfo instanceof Ci.nsICrashReporter) {
41575:       // Annotate the crash report with relevant add-on information.
41575:       try {
42089:         Services.appinfo.annotateCrashReport("Theme", this.currentSkin);
41575:       } catch (e) { }
41575:       try {
41575:         Services.appinfo.annotateCrashReport("EMCheckCompatibility",
41575:                                              this.checkCompatibility);
41575:       } catch (e) { }
41575:       this.addAddonsToCrashReporter();
41575:     }
41550: 
47636:     for (let id in this.bootstrappedAddons) {
52422:       let file = Cc["@mozilla.org/file/local;1"].createInstance(Ci.nsILocalFile);
52422:       file.persistentDescriptor = this.bootstrappedAddons[id].descriptor;
79913:       this.callBootstrapMethod(id, this.bootstrappedAddons[id].version,
79913:                                this.bootstrappedAddons[id].type, file,
47636:                                "startup", BOOTSTRAP_REASONS.APP_STARTUP);
47636:     }
47636: 
47636:     // Let these shutdown a little earlier when they still have access to most
47636:     // of XPCOM
47636:     Services.obs.addObserver({
47636:       observe: function(aSubject, aTopic, aData) {
47636:         Services.prefs.setCharPref(PREF_BOOTSTRAP_ADDONS,
47636:                                    JSON.stringify(XPIProvider.bootstrappedAddons));
47636:         for (let id in XPIProvider.bootstrappedAddons) {
52422:           let file = Cc["@mozilla.org/file/local;1"].createInstance(Ci.nsILocalFile);
52422:           file.persistentDescriptor = XPIProvider.bootstrappedAddons[id].descriptor;
47636:           XPIProvider.callBootstrapMethod(id, XPIProvider.bootstrappedAddons[id].version,
79913:                                           XPIProvider.bootstrappedAddons[id].type, file, "shutdown",
47636:                                           BOOTSTRAP_REASONS.APP_SHUTDOWN);
47636:         }
47636:         Services.obs.removeObserver(this, "quit-application-granted");
47636:       }
47636:     }, "quit-application-granted", false);
50742: 
50742:     this.extensionsActive = true;
41550:   },
41550: 
41550:   /**
41550:    * Shuts down the database and releases all references.
41550:    */
41550:   shutdown: function XPI_shutdown() {
41550:     LOG("shutdown");
41550: 
70820:     Services.prefs.removeObserver(PREF_EM_CHECK_COMPATIBILITY, this);
41550:     Services.prefs.removeObserver(PREF_EM_CHECK_UPDATE_SECURITY, this);
41550: 
42427:     this.bootstrappedAddons = {};
42427:     this.bootstrapScopes = {};
42427:     this.enabledAddons = null;
50742:     this.allAppGlobal = true;
50742: 
50742:     this.inactiveAddonIDs = [];
42427: 
56256:     // If there are pending operations then we must update the list of active
56256:     // add-ons
56256:     if (Prefs.getBoolPref(PREF_PENDING_OPERATIONS, false)) {
41550:       XPIDatabase.updateActiveAddons();
56256:       XPIDatabase.writeAddonsList();
41550:       Services.prefs.setBoolPref(PREF_PENDING_OPERATIONS, false);
41550:     }
51520: 
41550:     this.installs = null;
41550:     this.installLocations = null;
41550:     this.installLocationsByName = null;
50742: 
50742:     // This is needed to allow xpcshell tests to simulate a restart
50742:     this.extensionsActive = false;
51520: 
51520:     XPIDatabase.shutdown(function() {
51520:       Services.obs.notifyObservers(null, "xpi-provider-shutdown", null);
51520:     });
41550:   },
41550: 
41550:   /**
47636:    * Applies any pending theme change to the preferences.
47636:    */
47636:   applyThemeChange: function XPI_applyThemeChange() {
47636:     if (!Prefs.getBoolPref(PREF_DSS_SWITCHPENDING, false))
47636:       return;
47636: 
47636:     // Tell the Chrome Registry which Skin to select
47636:     try {
47636:       this.selectedSkin = Prefs.getCharPref(PREF_DSS_SKIN_TO_SELECT);
47636:       Services.prefs.setCharPref(PREF_GENERAL_SKINS_SELECTEDSKIN,
47636:                                  this.selectedSkin);
47636:       Services.prefs.clearUserPref(PREF_DSS_SKIN_TO_SELECT);
47636:       LOG("Changed skin to " + this.selectedSkin);
47636:       this.currentSkin = this.selectedSkin;
47636:     }
47636:     catch (e) {
57401:       ERROR("Error applying theme change", e);
47636:     }
47636:     Services.prefs.clearUserPref(PREF_DSS_SWITCHPENDING);
47636:   },
47636: 
47636:   /**
50742:    * Shows the "Compatibility Updates" UI
50742:    */
75342:   showUpgradeUI: function XPI_showUpgradeUI() {
78260:     // Flip a flag to indicate that we interrupted startup with an interactive prompt
78260:     Services.startup.interrupted = true;
78260: 
75342:     if (!Prefs.getBoolPref(PREF_SHOWN_SELECTION_UI, false)) {
75342:       // This *must* be modal as it has to block startup.
75342:       var features = "chrome,centerscreen,dialog,titlebar,modal";
75342:       Services.ww.openWindow(null, URI_EXTENSION_SELECT_DIALOG, "", features, null);
75342:       Services.prefs.setBoolPref(PREF_SHOWN_SELECTION_UI, true);
75342:     }
75342:     else {
50742:       var variant = Cc["@mozilla.org/variant;1"].
50742:                     createInstance(Ci.nsIWritableVariant);
50742:       variant.setFromVariant(this.inactiveAddonIDs);
50742:   
50742:       // This *must* be modal as it has to block startup.
50742:       var features = "chrome,centerscreen,dialog,titlebar,modal";
50742:       var ww = Cc["@mozilla.org/embedcomp/window-watcher;1"].
50742:                getService(Ci.nsIWindowWatcher);
50742:       ww.openWindow(null, URI_EXTENSION_UPDATE_DIALOG, "", features, variant);
75342:     }
54690: 
54690:     // Ensure any changes to the add-ons list are flushed to disk
82313:     XPIDatabase.writeAddonsList();
54690:     Services.prefs.setBoolPref(PREF_PENDING_OPERATIONS, false);
50742:   },
50742: 
50742:   /**
41575:    * Adds a list of currently active add-ons to the next crash report.
41575:    */
41575:   addAddonsToCrashReporter: function XPI_addAddonsToCrashReporter() {
41575:     if (!("nsICrashReporter" in Ci) ||
41575:         !(Services.appinfo instanceof Ci.nsICrashReporter))
41575:       return;
41575: 
54988:     // In safe mode no add-ons are loaded so we should not include them in the
54988:     // crash report
54988:     if (Services.appinfo.inSafeMode)
54988:       return;
54988: 
41575:     let data = this.enabledAddons;
41575:     for (let id in this.bootstrappedAddons)
41575:       data += (data ? "," : "") + id + ":" + this.bootstrappedAddons[id].version;
41575: 
41575:     try {
41575:       Services.appinfo.annotateCrashReport("Add-ons", data);
41575:     }
41575:     catch (e) { }
80810:     
80810:     const TelemetryPing = Cc["@mozilla.org/base/telemetry-ping;1"].getService(Ci.nsIObserver);
80810:     TelemetryPing.observe(null, "Add-ons", data);
41575:   },
41575: 
41575:   /**
41550:    * Gets the add-on states for an install location.
55169:    * This function may be expensive because of the recursiveLastModifiedTime call.
41550:    *
41550:    * @param  location
41550:    *         The install location to retrieve the add-on states for
41550:    * @return a dictionary mapping add-on IDs to objects with a descriptor
52422:    *         property which contains the add-ons dir/file descriptor and an
41550:    *         mtime property which contains the add-on's last modified time as
41550:    *         the number of milliseconds since the epoch.
41550:    */
41584:   getAddonStates: function XPI_getAddonStates(aLocation) {
41550:     let addonStates = {};
52422:     aLocation.addonLocations.forEach(function(file) {
52422:       let id = aLocation.getIDForLocation(file);
41550:       addonStates[id] = {
52422:         descriptor: file.persistentDescriptor,
55169:         mtime: recursiveLastModifiedTime(file)
41550:       };
41550:     });
41550: 
41550:     return addonStates;
41550:   },
41550: 
41550:   /**
41550:    * Gets an array of install location states which uniquely describes all
41550:    * installed add-ons with the add-on's InstallLocation name and last modified
55169:    * time. This function may be expensive because of the getAddonStates() call.
41550:    *
41550:    * @return an array of add-on states for each install location. Each state
41550:    *         is an object with a name property holding the location's name and
41550:    *         an addons property holding the add-on states for the location
41550:    */
41550:   getInstallLocationStates: function XPI_getInstallLocationStates() {
41550:     let states = [];
41584:     this.installLocations.forEach(function(aLocation) {
41584:       let addons = aLocation.addonLocations;
41550:       if (addons.length == 0)
41550:         return;
41550: 
41550:       let locationState = {
41584:         name: aLocation.name,
41584:         addons: this.getAddonStates(aLocation)
41550:       };
41550: 
41550:       states.push(locationState);
41550:     }, this);
41550:     return states;
41550:   },
41550: 
41550:   /**
41550:    * Check the staging directories of install locations for any add-ons to be
41550:    * installed or add-ons to be uninstalled.
41550:    *
41584:    * @param  aManifests
41550:    *         A dictionary to add detected install manifests to for the purpose
41550:    *         of passing through updated compatibility information
41550:    * @return true if an add-on was installed or uninstalled
41550:    */
41584:   processPendingFileChanges: function XPI_processPendingFileChanges(aManifests) {
41550:     let changed = false;
41584:     this.installLocations.forEach(function(aLocation) {
41584:       aManifests[aLocation.name] = {};
41550:       // We can't install or uninstall anything in locked locations
41584:       if (aLocation.locked)
41550:         return;
41550: 
55436:       let stagedXPIDir = aLocation.getXPIStagingDir();
41584:       let stagingDir = aLocation.getStagingDir();
55436: 
55436:       if (stagedXPIDir.exists() && stagedXPIDir.isDirectory()) {
55436:         let entries = stagedXPIDir.directoryEntries
55436:                                   .QueryInterface(Ci.nsIDirectoryEnumerator);
55436:         while (entries.hasMoreElements()) {
55436:           let stageDirEntry = entries.nextFile;
55436: 
55436:           if (!stageDirEntry.isDirectory()) {
55436:             WARN("Ignoring file in XPI staging directory: " + stageDirEntry.path);
55436:             continue;
55436:           }
55436: 
55436:           // Find the last added XPI file in the directory
55436:           let stagedXPI = null;
55436:           var xpiEntries = stageDirEntry.directoryEntries
55436:                                         .QueryInterface(Ci.nsIDirectoryEnumerator);
55436:           while (xpiEntries.hasMoreElements()) {
55436:             let file = xpiEntries.nextFile;
55436:             if (!(file instanceof Ci.nsILocalFile))
55436:               continue;
55436:             if (file.isDirectory())
55436:               continue;
55436: 
55436:             let extension = file.leafName;
55436:             extension = extension.substring(extension.length - 4);
55436: 
55436:             if (extension != ".xpi" && extension != ".jar")
55436:               continue;
55436: 
55436:             stagedXPI = file;
55436:           }
55436:           xpiEntries.close();
55436: 
55436:           if (!stagedXPI)
55436:             continue;
55436: 
55436:           let addon = null;
55436:           try {
55436:             addon = loadManifestFromZipFile(stagedXPI);
55436:           }
55436:           catch (e) {
68871:             ERROR("Unable to read add-on manifest from " + stagedXPI.path, e);
55436:             continue;
55436:           }
55436: 
55436:           LOG("Migrating staged install of " + addon.id + " in " + aLocation.name);
55436: 
55436:           if (addon.unpack || Prefs.getBoolPref(PREF_XPI_UNPACK, false)) {
55436:             let targetDir = stagingDir.clone();
55436:             targetDir.append(addon.id);
55436:             try {
55436:               targetDir.create(Ci.nsIFile.DIRECTORY_TYPE, FileUtils.PERMS_DIRECTORY);
55436:             }
55436:             catch (e) {
57401:               ERROR("Failed to create staging directory for add-on " + id, e);
55436:               continue;
55436:             }
55436: 
55436:             try {
55436:               extractFiles(stagedXPI, targetDir);
55436:             }
55436:             catch (e) {
55436:               ERROR("Failed to extract staged XPI for add-on " + id + " in " +
57401:                     aLocation.name, e);
55436:             }
55436:           }
55436:           else {
55436:             try {
55436:               stagedXPI.moveTo(stagingDir, addon.id + ".xpi");
55436:             }
55436:             catch (e) {
55436:               ERROR("Failed to move staged XPI for add-on " + id + " in " +
57401:                     aLocation.name, e);
55436:             }
55436:           }
55436:         }
55436:         entries.close();
55436:       }
55436: 
55436:       if (stagedXPIDir.exists()) {
55436:         try {
55436:           recursiveRemove(stagedXPIDir);
55436:         }
55436:         catch (e) {
55436:           // Non-critical, just saves some perf on startup if we clean this up.
58902:           LOG("Error removing XPI staging dir " + stagedXPIDir.path, e);
55436:         }
55436:       }
55436: 
55436:       if (!stagingDir || !stagingDir.exists() || !stagingDir.isDirectory())
41550:         return;
41550: 
72311:       let seenFiles = [];
74689:       let entries = stagingDir.directoryEntries
55436:                               .QueryInterface(Ci.nsIDirectoryEnumerator);
41550:       while (entries.hasMoreElements()) {
41550:         let stageDirEntry = entries.getNext().QueryInterface(Ci.nsILocalFile);
41550: 
52422:         let id = stageDirEntry.leafName;
41550:         if (!stageDirEntry.isDirectory()) {
52422:           if (id.substring(id.length - 4).toLowerCase() == ".xpi") {
52422:             id = id.substring(0, id.length - 4);
52422:           }
52422:           else {
72311:             if (id.substring(id.length - 5).toLowerCase() != ".json") {
41550:               WARN("Ignoring file: " + stageDirEntry.path);
72311:               seenFiles.push(stageDirEntry.leafName);
72311:             }
41550:             continue;
41550:           }
52422:         }
41550: 
41550:         // Check that the directory's name is a valid ID.
41550:         if (!gIDTest.test(id)) {
41550:           WARN("Ignoring directory whose name is not a valid add-on ID: " +
41550:                stageDirEntry.path);
72311:           seenFiles.push(stageDirEntry.leafName);
41550:           continue;
41550:         }
41550: 
56256:         changed = true;
56256: 
52422:         if (stageDirEntry.isDirectory()) {
41550:           // Check if the directory contains an install manifest.
41550:           let manifest = stageDirEntry.clone();
41550:           manifest.append(FILE_INSTALL_MANIFEST);
41550: 
41550:           // If the install manifest doesn't exist uninstall this add-on in this
41550:           // install location.
41550:           if (!manifest.exists()) {
41584:             LOG("Processing uninstall of " + id + " in " + aLocation.name);
56256:             try {
41584:               aLocation.uninstallAddon(id);
72311:               seenFiles.push(stageDirEntry.leafName);
56256:             }
56256:             catch (e) {
57401:               ERROR("Failed to uninstall add-on " + id + " in " + aLocation.name, e);
56256:             }
41550:             // The file check later will spot the removal and cleanup the database
41550:             continue;
41550:           }
52422:         }
41550: 
41584:         aManifests[aLocation.name][id] = null;
68871:         let existingAddonID = id;
41550: 
41550:         let jsonfile = stagingDir.clone();
41550:         jsonfile.append(id + ".json");
79395: 
79395:         try {
79395:           aManifests[aLocation.name][id] = loadManifestFromFile(stageDirEntry);
79395:         }
79395:         catch (e) {
79395:           ERROR("Unable to read add-on manifest from " + stageDirEntry.path, e);
79395:           // This add-on can't be installed so just remove it now
79395:           seenFiles.push(stageDirEntry.leafName);
79395:           seenFiles.push(jsonfile.leafName);
79395:           continue;
79395:         }
79395: 
79395:         // Check for a cached metadata for this add-on, it may contain updated
79395:         // compatibility information
41550:         if (jsonfile.exists()) {
79395:           LOG("Found updated metadata for " + id + " in " + aLocation.name);
41550:           let fis = Cc["@mozilla.org/network/file-input-stream;1"].
41550:                        createInstance(Ci.nsIFileInputStream);
41550:           let json = Cc["@mozilla.org/dom/json;1"].
41550:                      createInstance(Ci.nsIJSON);
41550: 
41550:           try {
41550:             fis.init(jsonfile, -1, 0, 0);
79395:             let metadata = json.decodeFromStream(fis, jsonfile.fileSize);
79395:             aManifests[aLocation.name][id].importMetadata(metadata);
41550:           }
41550:           catch (e) {
79395:             // If some data can't be recovered from the cached metadata then it
79395:             // is unlikely to be a problem big enough to justify throwing away
79395:             // the install, just log and error and continue
79395:             ERROR("Unable to read metadata from " + jsonfile.path, e);
41550:           }
41550:           finally {
41550:             fis.close();
41550:           }
41550:         }
72311:         seenFiles.push(jsonfile.leafName);
58192: 
68871:         existingAddonID = aManifests[aLocation.name][id].existingAddonID || id;
68871: 
68871:         var oldBootstrap = null;
58192:         LOG("Processing install of " + id + " in " + aLocation.name);
68871:         if (existingAddonID in this.bootstrappedAddons) {
68871:           try {
68871:             var existingAddon = aLocation.getLocationForID(existingAddonID);
68871:             if (this.bootstrappedAddons[existingAddonID].descriptor ==
68871:                 existingAddon.persistentDescriptor) {
68871:               oldBootstrap = this.bootstrappedAddons[existingAddonID];
68871: 
68871:               // We'll be replacing a currently active bootstrapped add-on so
68871:               // call its uninstall method
68871:               let oldVersion = aManifests[aLocation.name][id].version;
68871:               let newVersion = oldBootstrap.version;
68871:               let uninstallReason = Services.vc.compare(newVersion, oldVersion) < 0 ?
68871:                                     BOOTSTRAP_REASONS.ADDON_UPGRADE :
68871:                                     BOOTSTRAP_REASONS.ADDON_DOWNGRADE;
68871: 
68871:               this.callBootstrapMethod(existingAddonID, oldBootstrap.version,
79913:                                        oldBootstrap.type, existingAddon, "uninstall", uninstallReason);
68871:               this.unloadBootstrapScope(existingAddonID);
71854:               flushStartupCache();
68871:             }
68871:           }
68871:           catch (e) {
68871:           }
68871:         }
68871: 
58192:         try {
58192:           var addonInstallLocation = aLocation.installAddon(id, stageDirEntry,
58192:                                                             existingAddonID);
59564:           if (aManifests[aLocation.name][id])
58192:             aManifests[aLocation.name][id]._sourceBundle = addonInstallLocation;
58192:         }
58192:         catch (e) {
58192:           ERROR("Failed to install staged add-on " + id + " in " + aLocation.name,
58192:                 e);
72311:           // Re-create the staged install
72311:           AddonInstall.createStagedInstall(aLocation, stageDirEntry,
72311:                                            aManifests[aLocation.name][id]);
72311:           // Make sure not to delete the cached manifest json file
72311:           seenFiles.pop();
72311: 
58192:           delete aManifests[aLocation.name][id];
68871: 
68871:           if (oldBootstrap) {
68871:             // Re-install the old add-on
68871:             this.callBootstrapMethod(existingAddonID, oldBootstrap.version,
79913:                                      oldBootstrap.type, existingAddon, "install",
68871:                                      BOOTSTRAP_REASONS.ADDON_INSTALL);
68871:           }
58192:           continue;
58192:         }
41550:       }
55436:       entries.close();
41550: 
41550:       try {
72311:         cleanStagingDir(stagingDir, seenFiles);
41550:       }
41550:       catch (e) {
41550:         // Non-critical, just saves some perf on startup if we clean this up.
72311:         LOG("Error cleaning staging dir " + stagingDir.path, e);
41550:       }
68871:     }, this);
41550:     return changed;
41550:   },
41550: 
41550:   /**
60885:    * Installs any add-ons located in the extensions directory of the
60885:    * application's distribution specific directory into the profile unless a
60885:    * newer version already exists or the user has previously uninstalled the
60885:    * distributed add-on.
60885:    *
60885:    * @param  aManifests
60885:    *         A dictionary to add new install manifests to to save having to
60885:    *         reload them later
60885:    * @return true if any new add-ons were installed
60885:    */
60885:   installDistributionAddons: function XPI_installDistributionAddons(aManifests) {
60885:     let distroDir;
60885:     try {
60885:       distroDir = FileUtils.getDir(KEY_APP_DISTRIBUTION, [DIR_EXTENSIONS]);
60885:     }
60885:     catch (e) {
60885:       return false;
60885:     }
60885: 
60885:     if (!distroDir.exists())
60885:       return false;
60885: 
60885:     if (!distroDir.isDirectory())
60885:       return false;
60885: 
60885:     let changed = false;
60885:     let profileLocation = this.installLocationsByName[KEY_APP_PROFILE];
60885: 
60885:     let entries = distroDir.directoryEntries
60885:                            .QueryInterface(Ci.nsIDirectoryEnumerator);
60885:     let entry;
60885:     while (entry = entries.nextFile) {
60885:       // Should never happen really
60885:       if (!(entry instanceof Ci.nsILocalFile))
60885:         continue;
60885: 
60885:       let id = entry.leafName;
60885: 
60885:       if (entry.isFile()) {
60885:         if (id.substring(id.length - 4).toLowerCase() == ".xpi") {
60885:           id = id.substring(0, id.length - 4);
60885:         }
60885:         else {
60885:           LOG("Ignoring distribution add-on that isn't an XPI: " + entry.path);
60885:           continue;
60885:         }
60885:       }
60885:       else if (!entry.isDirectory()) {
60885:         LOG("Ignoring distribution add-on that isn't a file or directory: " +
60885:             entry.path);
60885:         continue;
60885:       }
60885: 
60885:       if (!gIDTest.test(id)) {
60885:         LOG("Ignoring distribution add-on whose name is not a valid add-on ID: " +
60885:             entry.path);
60885:         continue;
60885:       }
60885: 
60885:       let addon;
60885:       try {
60885:         addon = loadManifestFromFile(entry);
60885:       }
60885:       catch (e) {
60885:         WARN("File entry " + entry.path + " contains an invalid add-on", e);
60885:         continue;
60885:       }
60885: 
60885:       if (addon.id != id) {
60885:         WARN("File entry " + entry.path + " contains an add-on with an " +
60885:              "incorrect ID")
60885:         continue;
60885:       }
60885: 
60885:       let existingEntry = null;
60885:       try {
60885:         existingEntry = profileLocation.getLocationForID(id);
60885:       }
60885:       catch (e) {
60885:       }
60885: 
60885:       if (existingEntry) {
60885:         let existingAddon;
60885:         try {
60885:           existingAddon = loadManifestFromFile(existingEntry);
60885: 
60885:           if (Services.vc.compare(addon.version, existingAddon.version) <= 0)
60885:             continue;
60885:         }
60885:         catch (e) {
60885:           // Bad add-on in the profile so just proceed and install over the top
60885:           WARN("Profile contains an add-on with a bad or missing install " +
60885:                "manifest at " + existingEntry.path + ", overwriting", e);
60885:         }
60885:       }
60885:       else if (Prefs.getBoolPref(PREF_BRANCH_INSTALLED_ADDON + id, false)) {
60885:         continue;
60885:       }
60885: 
60885:       // Install the add-on
60885:       try {
60885:         profileLocation.installAddon(id, entry, null, true);
60885:         LOG("Installed distribution add-on " + id);
60885: 
60885:         Services.prefs.setBoolPref(PREF_BRANCH_INSTALLED_ADDON + id, true)
60885: 
60885:         // aManifests may contain a copy of a newly installed add-on's manifest
60885:         // and we'll have overwritten that so instead cache our install manifest
60885:         // which will later be put into the database in processFileChanges
60885:         if (!(KEY_APP_PROFILE in aManifests))
60885:           aManifests[KEY_APP_PROFILE] = {};
60885:         aManifests[KEY_APP_PROFILE][id] = addon;
60885:         changed = true;
60885:       }
60885:       catch (e) {
60885:         ERROR("Failed to install distribution add-on " + entry.path, e);
60885:       }
60885:     }
60885: 
60885:     entries.close();
60885: 
60885:     return changed;
60885:   },
60885: 
60885:   /**
41550:    * Compares the add-ons that are currently installed to those that were
41550:    * known to be installed when the application last ran and applies any
55169:    * changes found to the database. Also sends "startupcache-invalidate" signal to
55169:    * observerservice if it detects that data may have changed.
41550:    *
41584:    * @param  aState
41550:    *         The array of current install location states
41584:    * @param  aManifests
41550:    *         A dictionary of cached AddonInstalls for add-ons that have been
41550:    *         installed
41584:    * @param  aUpdateCompatibility
41550:    *         true to update add-ons appDisabled property when the application
41550:    *         version has changed
70084:    * @param  aOldAppVersion
70084:    *         The version of the application last run with this profile or null
70084:    *         if it is a new profile or the version is unknown
70084:    * @param  aOldPlatformVersion
70084:    *         The version of the platform last run with this profile or null
70084:    *         if it is a new profile or the version is unknown
57160:    * @param  aMigrateData
57160:    *         an object generated from a previous version of the database
57160:    *         holding information about what add-ons were previously userDisabled
57160:    *         and updated compatibility information if present
57160:    * @param  aActiveBundles
57160:    *         When performing recovery after startup this will be an array of
57160:    *         persistent descriptors of add-ons that are known to be active,
57160:    *         otherwise it will be null
71594:    * @return a boolean indicating if a change requiring flushing the caches was
71594:    *         detected
41550:    */
41584:   processFileChanges: function XPI_processFileChanges(aState, aManifests,
41584:                                                       aUpdateCompatibility,
70084:                                                       aOldAppVersion,
70084:                                                       aOldPlatformVersion,
57160:                                                       aMigrateData,
57160:                                                       aActiveBundles) {
41550:     let visibleAddons = {};
60302:     let oldBootstrappedAddons = this.bootstrappedAddons;
60302:     this.bootstrappedAddons = {};
41550: 
41550:     /**
41550:      * Updates an add-on's metadata and determines if a restart of the
41550:      * application is necessary. This is called when either the add-on's
41550:      * install directory path or last modified time has changed.
41550:      *
41584:      * @param  aInstallLocation
41550:      *         The install location containing the add-on
41584:      * @param  aOldAddon
41550:      *         The AddonInternal as it appeared the last time the application
41550:      *         ran
41584:      * @param  aAddonState
41550:      *         The new state of the add-on
71594:      * @return a boolean indicating if flushing caches is required to complete
41550:      *         changing this add-on
41550:      */
41584:     function updateMetadata(aInstallLocation, aOldAddon, aAddonState) {
41584:       LOG("Add-on " + aOldAddon.id + " modified in " + aInstallLocation.name);
41550: 
41550:       // Check if there is an updated install manifest for this add-on
41584:       let newAddon = aManifests[aInstallLocation.name][aOldAddon.id];
41550: 
41550:       try {
52422:         // If not load it
41550:         if (!newAddon) {
52422:           let file = aInstallLocation.getLocationForID(aOldAddon.id);
60885:           newAddon = loadManifestFromFile(file);
70084:           applyBlocklistChanges(aOldAddon, newAddon);
41550:         }
41550: 
41550:         // The ID in the manifest that was loaded must match the ID of the old
41550:         // add-on.
41584:         if (newAddon.id != aOldAddon.id)
41550:           throw new Error("Incorrect id in install manifest");
41550:       }
41550:       catch (e) {
57401:         WARN("Add-on is invalid", e);
41584:         XPIDatabase.removeAddonMetadata(aOldAddon);
41584:         if (!aInstallLocation.locked)
41584:           aInstallLocation.uninstallAddon(aOldAddon.id);
41578:         else
41578:           WARN("Could not uninstall invalid item from locked install location");
41550:         // If this was an active add-on then we must force a restart
60302:         if (aOldAddon.active)
41550:           return true;
41550: 
41550:         return false;
41550:       }
41550: 
41550:       // Set the additional properties on the new AddonInternal
41584:       newAddon._installLocation = aInstallLocation;
41584:       newAddon.updateDate = aAddonState.mtime;
41550:       newAddon.visible = !(newAddon.id in visibleAddons);
41550: 
41550:       // Update the database
41584:       XPIDatabase.updateAddonMetadata(aOldAddon, newAddon, aAddonState.descriptor);
41550:       if (newAddon.visible) {
41550:         visibleAddons[newAddon.id] = newAddon;
72782:         // Remember add-ons that were changed during startup
72782:         AddonManagerPrivate.addStartupChange(AddonManager.STARTUP_CHANGE_CHANGED,
72782:                                              newAddon.id);
56927: 
70084:         // If this was the active theme and it is now disabled then enable the
70084:         // default theme
70084:         if (aOldAddon.active && isAddonDisabled(newAddon))
70084:           XPIProvider.enableDefaultTheme();
70084: 
56927:         // If the new add-on is bootstrapped and active then call its install method
56927:         if (newAddon.active && newAddon.bootstrap) {
71854:           // Startup cache must be flushed before calling the bootstrap script
71854:           flushStartupCache();
71854: 
56927:           let installReason = Services.vc.compare(aOldAddon.version, newAddon.version) < 0 ?
56927:                               BOOTSTRAP_REASONS.ADDON_UPGRADE :
56927:                               BOOTSTRAP_REASONS.ADDON_DOWNGRADE;
56927: 
56927:           let file = Cc["@mozilla.org/file/local;1"].createInstance(Ci.nsILocalFile);
56927:           file.persistentDescriptor = aAddonState.descriptor;
79913:           XPIProvider.callBootstrapMethod(newAddon.id, newAddon.version, newAddon.type, file,
56927:                                           "install", installReason);
56927:           return false;
56927:         }
56927: 
41550:         return true;
41550:       }
41550: 
41550:       return false;
41550:     }
41550: 
41550:     /**
71594:      * Updates an add-on's descriptor for when the add-on has moved in the
71594:      * filesystem but hasn't changed in any other way.
41550:      *
41584:      * @param  aInstallLocation
41550:      *         The install location containing the add-on
41584:      * @param  aOldAddon
41550:      *         The AddonInternal as it appeared the last time the application
41550:      *         ran
41584:      * @param  aAddonState
41550:      *         The new state of the add-on
71594:      * @return a boolean indicating if flushing caches is required to complete
71594:      *         changing this add-on
71594:      */
71594:     function updateDescriptor(aInstallLocation, aOldAddon, aAddonState) {
71594:       LOG("Add-on " + aOldAddon.id + " moved to " + aAddonState.descriptor);
71594: 
71594:       aOldAddon._descriptor = aAddonState.descriptor;
71594:       aOldAddon.visible = !(aOldAddon.id in visibleAddons);
71594: 
71594:       // Update the database
71594:       XPIDatabase.setAddonDescriptor(aOldAddon, aAddonState.descriptor);
71594:       if (aOldAddon.visible) {
71594:         visibleAddons[aOldAddon.id] = aOldAddon;
71594: 
71594:         return true;
71594:       }
71594: 
71594:       return false;
71594:     }
71594: 
71594:     /**
71594:      * Called when no change has been detected for an add-on's metadata. The
71594:      * add-on may have become visible due to other add-ons being removed or
71594:      * the add-on may need to be updated when the application version has
71594:      * changed.
71594:      *
71594:      * @param  aInstallLocation
71594:      *         The install location containing the add-on
71594:      * @param  aOldAddon
71594:      *         The AddonInternal as it appeared the last time the application
71594:      *         ran
71594:      * @param  aAddonState
71594:      *         The new state of the add-on
71594:      * @return a boolean indicating if flushing caches is required to complete
71594:      *         changing this add-on
41550:      */
41584:     function updateVisibilityAndCompatibility(aInstallLocation, aOldAddon,
41584:                                               aAddonState) {
41550:       let changed = false;
41550: 
41550:       // This add-ons metadata has not changed but it may have become visible
41584:       if (!(aOldAddon.id in visibleAddons)) {
41584:         visibleAddons[aOldAddon.id] = aOldAddon;
41584: 
41584:         if (!aOldAddon.visible) {
72782:           // Remember add-ons that were changed during startup.
72782:           AddonManagerPrivate.addStartupChange(AddonManager.STARTUP_CHANGE_CHANGED,
72782:                                                aOldAddon.id);
41584:           XPIDatabase.makeAddonVisible(aOldAddon);
41550: 
56927:           if (aOldAddon.bootstrap) {
56927:             // The add-on is bootstrappable so call its install script
56927:             let file = Cc["@mozilla.org/file/local;1"].createInstance(Ci.nsILocalFile);
56927:             file.persistentDescriptor = aAddonState.descriptor;
79913:             XPIProvider.callBootstrapMethod(aOldAddon.id, aOldAddon.version, aOldAddon.type, file,
56927:                                             "install",
56927:                                             BOOTSTRAP_REASONS.ADDON_INSTALL);
56927: 
56927:             // If it should be active then mark it as active otherwise unload
56927:             // its scope
70084:             if (!isAddonDisabled(aOldAddon)) {
41584:               aOldAddon.active = true;
41584:               XPIDatabase.updateAddonActive(aOldAddon);
56927:             }
56927:             else {
56927:               XPIProvider.unloadBootstrapScope(newAddon.id);
56927:             }
41550:           }
41550:           else {
41550:             // Otherwise a restart is necessary
41550:             changed = true;
41550:           }
41550:         }
41550:       }
41550: 
41550:       // App version changed, we may need to update the appDisabled property.
41584:       if (aUpdateCompatibility) {
70084:         // Create a basic add-on object for the new state to save reproducing
70084:         // the applyBlocklistChanges code
70084:         let newAddon = new AddonInternal();
70084:         newAddon.id = aOldAddon.id;
82404:         newAddon.syncGUID = aOldAddon.syncGUID;
70084:         newAddon.version = aOldAddon.version;
70084:         newAddon.type = aOldAddon.type;
70084:         newAddon.appDisabled = !isUsableAddon(aOldAddon);
70084: 
47199:         // Sync the userDisabled flag to the selectedSkin
47199:         if (aOldAddon.type == "theme")
70084:           newAddon.userDisabled = aOldAddon.internalName != XPIProvider.selectedSkin;
70084: 
70084:         applyBlocklistChanges(aOldAddon, newAddon, aOldAppVersion,
70084:                               aOldPlatformVersion);
70084: 
70084:         let wasDisabled = isAddonDisabled(aOldAddon);
70084:         let isDisabled = isAddonDisabled(newAddon);
47199: 
47199:         // If either property has changed update the database.
70084:         if (newAddon.appDisabled != aOldAddon.appDisabled ||
70084:             newAddon.userDisabled != aOldAddon.userDisabled ||
70084:             newAddon.softDisabled != aOldAddon.softDisabled) {
41584:           LOG("Add-on " + aOldAddon.id + " changed appDisabled state to " +
70084:               newAddon.appDisabled + ", userDisabled state to " +
70084:               newAddon.userDisabled + " and softDisabled state to " +
70084:               newAddon.softDisabled);
41584:           XPIDatabase.setAddonProperties(aOldAddon, {
70084:             appDisabled: newAddon.appDisabled,
70084:             userDisabled: newAddon.userDisabled,
70084:             softDisabled: newAddon.softDisabled
41550:           });
47199:         }
47199: 
47199:         // If this is a visible add-on and it has changed disabled state then we
41550:         // may need a restart or to update the bootstrap list.
47199:         if (aOldAddon.visible && wasDisabled != isDisabled) {
72782:           // Remember add-ons that became disabled or enabled by the application
72782:           // change
72782:           let change = isDisabled ? AddonManager.STARTUP_CHANGE_DISABLED
72782:                                   : AddonManager.STARTUP_CHANGE_ENABLED;
72782:           AddonManagerPrivate.addStartupChange(change, aOldAddon.id);
41591:           if (aOldAddon.bootstrap) {
47199:             // Update the add-ons active state
47199:             aOldAddon.active = !isDisabled;
41584:             XPIDatabase.updateAddonActive(aOldAddon);
60302:           }
60302:           else {
60302:             changed = true;
60302:           }
60302:         }
60302:       }
60302: 
60302:       if (aOldAddon.visible && aOldAddon.active && aOldAddon.bootstrap) {
41584:         XPIProvider.bootstrappedAddons[aOldAddon.id] = {
41584:           version: aOldAddon.version,
79913:           type: aOldAddon.type,
41584:           descriptor: aAddonState.descriptor
41575:         };
41575:       }
41550: 
41550:       return changed;
41550:     }
41550: 
41550:     /**
41550:      * Called when an add-on has been removed.
41550:      *
41584:      * @param  aInstallLocation
41550:      *         The install location containing the add-on
41584:      * @param  aOldAddon
41550:      *         The AddonInternal as it appeared the last time the application
41550:      *         ran
71594:      * @return a boolean indicating if flushing caches is required to complete
71594:      *         changing this add-on
41550:      */
41584:     function removeMetadata(aInstallLocation, aOldAddon) {
41550:       // This add-on has disappeared
41584:       LOG("Add-on " + aOldAddon.id + " removed from " + aInstallLocation.name);
41584:       XPIDatabase.removeAddonMetadata(aOldAddon);
72782: 
72782:       // Remember add-ons that were uninstalled during startup
72782:       if (aOldAddon.visible) {
72782:         AddonManagerPrivate.addStartupChange(AddonManager.STARTUP_CHANGE_UNINSTALLED,
72782:                                              aOldAddon.id);
72782:       }
72782:       else if (AddonManager.getStartupChanges(AddonManager.STARTUP_CHANGE_INSTALLED)
72782:                            .indexOf(aOldAddon.id) != -1) {
72782:         AddonManagerPrivate.addStartupChange(AddonManager.STARTUP_CHANGE_CHANGED,
72782:                                              aOldAddon.id);
72782:       }
72782: 
41584:       if (aOldAddon.active) {
41550:         // Enable the default theme if the previously active theme has been
41550:         // removed
41584:         if (aOldAddon.type == "theme")
41550:           XPIProvider.enableDefaultTheme();
41550: 
41550:         return true;
41550:       }
41550: 
41550:       return false;
41550:     }
41550: 
41550:     /**
82652:      * Called to add the metadata for an add-on in one of the install locations
82652:      * to the database. This can be called in three different cases. Either an
82652:      * add-on has been dropped into the location from outside of Firefox, or
82652:      * an add-on has been installed through the application, or the database
82652:      * has been upgraded or become corrupt and add-on data has to be reloaded
82652:      * into it.
41550:      *
41584:      * @param  aInstallLocation
41550:      *         The install location containing the add-on
41584:      * @param  aId
41550:      *         The ID of the add-on
41584:      * @param  aAddonState
41550:      *         The new state of the add-on
41584:      * @param  aMigrateData
41550:      *         If during startup the database had to be upgraded this will
41550:      *         contain data that used to be held about this add-on
71594:      * @return a boolean indicating if flushing caches is required to complete
71594:      *         changing this add-on
41550:      */
41584:     function addMetadata(aInstallLocation, aId, aAddonState, aMigrateData) {
41584:       LOG("New add-on " + aId + " installed in " + aInstallLocation.name);
41550: 
57160:       let newAddon = null;
80812:       let sameVersion = false;
57160:       // Check the updated manifests lists for the install location, If there
57160:       // is no manifest for the add-on ID then newAddon will be undefined
57160:       if (aInstallLocation.name in aManifests)
57160:         newAddon = aManifests[aInstallLocation.name][aId];
41550: 
82652:       // If we aren't recovering from a corrupt database or we don't have
82652:       // migration data for this add-on then this must be a new install.
82652:       let isNewInstall = !aActiveBundles && !aMigrateData;
82652:  
82652:       // If it's a new install and we haven't yet loaded the manifest then it
82652:       // must be something dropped directly into the install location
82652:       let isDetectedInstall = isNewInstall && !newAddon;
82652: 
82652:       // Load the manifest if necessary and sanity check the add-on ID
41550:       try {
52422:         if (!newAddon) {
80772:           // Load the manifest from the add-on.
52422:           let file = aInstallLocation.getLocationForID(aId);
60885:           newAddon = loadManifestFromFile(file);
52422:         }
41550:         // The add-on in the manifest should match the add-on ID.
41584:         if (newAddon.id != aId)
41550:           throw new Error("Incorrect id in install manifest");
41550:       }
41550:       catch (e) {
57401:         WARN("Add-on is invalid", e);
41550: 
41578:         // Remove the invalid add-on from the install location if the install
41578:         // location isn't locked, no restart will be necessary
41584:         if (!aInstallLocation.locked)
41584:           aInstallLocation.uninstallAddon(aId);
41578:         else
41578:           WARN("Could not uninstall invalid item from locked install location");
41550:         return false;
41550:       }
41550: 
41550:       // Update the AddonInternal properties.
41584:       newAddon._installLocation = aInstallLocation;
41550:       newAddon.visible = !(newAddon.id in visibleAddons);
63356:       newAddon.installDate = aAddonState.mtime;
41584:       newAddon.updateDate = aAddonState.mtime;
82652:       newAddon.foreignInstall = isDetectedInstall;
82652: 
82652:       if (aMigrateData) {
41550:         // If there is migration data then apply it.
72029:         LOG("Migrating data from old database");
82579: 
82579:         DB_MIGRATE_METADATA.forEach(function(aProp) {
42097:           // A theme's disabled state is determined by the selected theme
42097:           // preference which is read in loadManifestFromRDF
82579:           if (aProp == "userDisabled" && newAddon.type == "theme")
82579:             return;
82579: 
82579:           if (aProp in aMigrateData)
82579:             newAddon[aProp] = aMigrateData[aProp];
82579:         });
47839: 
82652:         // Force all non-profile add-ons to be foreignInstalls since they can't
82652:         // have been installed through the API
82652:         newAddon.foreignInstall |= aInstallLocation.name != KEY_APP_PROFILE;
82652: 
47839:         // Some properties should only be migrated if the add-on hasn't changed.
47839:         // The version property isn't a perfect check for this but covers the
47839:         // vast majority of cases.
80812:         if (aMigrateData.version == newAddon.version) {
72029:           LOG("Migrating compatibility info");
80812:           sameVersion = true;
80812:           if ("targetApplications" in aMigrateData)
41590:             newAddon.applyCompatibilityUpdate(aMigrateData, true);
41550:         }
70084: 
70084:         // Since the DB schema has changed make sure softDisabled is correct
70084:         applyBlocklistChanges(newAddon, newAddon, aOldAppVersion,
70084:                               aOldPlatformVersion);
70084:       }
70084: 
82652:       // The default theme is never a foreign install
82652:       if (newAddon.type == "theme" && newAddon.internalName == XPIProvider.defaultSkin)
82652:         newAddon.foreignInstall = false;
82652: 
82652:       if (isDetectedInstall && newAddon.foreignInstall) {
82652:         // If the add-on is a foreign install and is in a scope where add-ons
82652:         // that were dropped in should default to disabled then disable it
82652:         let disablingScopes = Prefs.getIntPref(PREF_EM_AUTO_DISABLED_SCOPES, 0);
82652:         if (aInstallLocation.scope & disablingScopes)
82652:           newAddon.userDisabled = true;
82652:       }
82652: 
57160:       if (aActiveBundles) {
70084:         // If we have a list of what add-ons should be marked as active then use
70084:         // it to guess at migration data
57160:         // For themes we know which is active by the current skin setting
57160:         if (newAddon.type == "theme")
57160:           newAddon.active = newAddon.internalName == XPIProvider.currentSkin;
57160:         else
57160:           newAddon.active = aActiveBundles.indexOf(aAddonState.descriptor) != -1;
57160: 
70084:         // If the add-on wasn't active and it isn't already disabled in some way
70084:         // then it was probably either softDisabled or userDisabled
70084:         if (!newAddon.active && newAddon.visible && !isAddonDisabled(newAddon)) {
70084:           // If the add-on is softblocked then assume it is softDisabled
70084:           if (newAddon.blocklistState == Ci.nsIBlocklistService.STATE_SOFTBLOCKED)
70084:             newAddon.softDisabled = true;
70084:           else
57160:             newAddon.userDisabled = true;
57160:         }
70084:       }
57160:       else {
70084:         newAddon.active = (newAddon.visible && !isAddonDisabled(newAddon))
57160:       }
57160: 
42885:       try {
41550:         // Update the database.
41584:         XPIDatabase.addAddonMetadata(newAddon, aAddonState.descriptor);
42885:       }
42885:       catch (e) {
42885:         // Failing to write the add-on into the database is non-fatal, the
42885:         // add-on will just be unavailable until we try again in a subsequent
42885:         // startup
42885:         ERROR("Failed to add add-on " + aId + " in " + aInstallLocation.name +
57401:               " to database", e);
42885:         return false;
42885:       }
41550: 
41550:       if (newAddon.visible) {
82652:         // Remember add-ons that were first detected during startup.
82652:         if (isDetectedInstall) {
72782:           // If a copy from a higher priority location was removed then this
72782:           // add-on has changed
72782:           if (AddonManager.getStartupChanges(AddonManager.STARTUP_CHANGE_UNINSTALLED)
72782:                           .indexOf(newAddon.id) != -1) {
72782:             AddonManagerPrivate.addStartupChange(AddonManager.STARTUP_CHANGE_CHANGED,
72782:                                                  newAddon.id);
72782:           }
72782:           else {
72782:             AddonManagerPrivate.addStartupChange(AddonManager.STARTUP_CHANGE_INSTALLED,
72782:                                                  newAddon.id);
72782:           }
72782:         }
72782: 
50742:         // Note if any visible add-on is not in the application install location
50742:         if (newAddon._installLocation.name != KEY_APP_GLOBAL)
50742:           XPIProvider.allAppGlobal = false;
50742: 
41550:         visibleAddons[newAddon.id] = newAddon;
56927: 
56927:         let installReason = BOOTSTRAP_REASONS.ADDON_INSTALL;
56927: 
56927:         // If we're hiding a bootstrapped add-on then call its uninstall method
60302:         if (newAddon.id in oldBootstrappedAddons) {
60302:           let oldBootstrap = oldBootstrappedAddons[newAddon.id];
60302:           XPIProvider.bootstrappedAddons[newAddon.id] = oldBootstrap;
56927: 
80812:           // If the old version is the same as the new version, don't call
80812:           // uninstall and install methods.
80812:           if (sameVersion)
80812:             return false;
80812: 
56927:           installReason = Services.vc.compare(oldBootstrap.version, newAddon.version) < 0 ?
56927:                           BOOTSTRAP_REASONS.ADDON_UPGRADE :
56927:                           BOOTSTRAP_REASONS.ADDON_DOWNGRADE;
56927: 
56927:           let oldAddonFile = Cc["@mozilla.org/file/local;1"].
56927:                              createInstance(Ci.nsILocalFile);
56927:           oldAddonFile.persistentDescriptor = oldBootstrap.descriptor;
71854: 
56927:           XPIProvider.callBootstrapMethod(newAddon.id, oldBootstrap.version,
79913:                                           oldBootstrap.type, oldAddonFile, "uninstall",
56927:                                           installReason);
56927:           XPIProvider.unloadBootstrapScope(newAddon.id);
71854: 
71854:           // If the new add-on is bootstrapped then we must flush the caches
71854:           // before calling the new bootstrap script
71854:           if (newAddon.bootstrap)
71854:             flushStartupCache();
56927:         }
56927: 
41591:         if (!newAddon.bootstrap)
41550:           return true;
41550: 
50742:         // Visible bootstrapped add-ons need to have their install method called
52422:         let file = Cc["@mozilla.org/file/local;1"].createInstance(Ci.nsILocalFile);
52422:         file.persistentDescriptor = aAddonState.descriptor;
79913:         XPIProvider.callBootstrapMethod(newAddon.id, newAddon.version, newAddon.type, file,
56927:                                         "install", installReason);
46289:         if (!newAddon.active)
46289:           XPIProvider.unloadBootstrapScope(newAddon.id);
41550:       }
41550: 
41550:       return false;
41550:     }
41550: 
41550:     let changed = false;
41550:     let knownLocations = XPIDatabase.getInstallLocations();
41550: 
41550:     // The install locations are iterated in reverse order of priority so when
41550:     // there are multiple add-ons installed with the same ID the one that
41550:     // should be visible is the first one encountered.
41584:     aState.reverse().forEach(function(aSt) {
41550: 
41550:       // We can't include the install location directly in the state as it has
41550:       // to be cached as JSON.
41584:       let installLocation = this.installLocationsByName[aSt.name];
41584:       let addonStates = aSt.addons;
41550: 
41550:       // Check if the database knows about any add-ons in this install location.
41550:       let pos = knownLocations.indexOf(installLocation.name);
41550:       if (pos >= 0) {
41550:         knownLocations.splice(pos, 1);
41550:         let addons = XPIDatabase.getAddonsInLocation(installLocation.name);
41550:         // Iterate through the add-ons installed the last time the application
41550:         // ran
41584:         addons.forEach(function(aOldAddon) {
72782:           // If a version of this add-on has been installed in an higher
72782:           // priority install location then count it as changed
72782:           if (AddonManager.getStartupChanges(AddonManager.STARTUP_CHANGE_INSTALLED)
72782:                           .indexOf(aOldAddon.id) != -1) {
72782:             AddonManagerPrivate.addStartupChange(AddonManager.STARTUP_CHANGE_CHANGED,
72782:                                                  aOldAddon.id);
72782:           }
72782: 
41550:           // Check if the add-on is still installed
41584:           if (aOldAddon.id in addonStates) {
41584:             let addonState = addonStates[aOldAddon.id];
41584:             delete addonStates[aOldAddon.id];
41550: 
50742:             // Remember add-ons that were inactive during startup
50742:             if (aOldAddon.visible && !aOldAddon.active)
50742:               XPIProvider.inactiveAddonIDs.push(aOldAddon.id);
50742: 
41550:             // The add-on has changed if the modification time has changed, or
71594:             // we have an updated manifest for it. Also reload the metadata for
71594:             // add-ons in the application directory when the application version
71594:             // has changed
41584:             if (aOldAddon.id in aManifests[installLocation.name] ||
41584:                 aOldAddon.updateDate != addonState.mtime ||
47950:                 (aUpdateCompatibility && installLocation.name == KEY_APP_GLOBAL)) {
41584:               changed = updateMetadata(installLocation, aOldAddon, addonState) ||
41550:                         changed;
41550:             }
71594:             else if (aOldAddon._descriptor != addonState.descriptor) {
71594:               changed = updateDescriptor(installLocation, aOldAddon, addonState) ||
71594:                         changed;
71594:             }
41550:             else {
41550:               changed = updateVisibilityAndCompatibility(installLocation,
41584:                                                          aOldAddon, addonState) ||
41550:                         changed;
41550:             }
50742:             if (aOldAddon.visible && aOldAddon._installLocation.name != KEY_APP_GLOBAL)
50742:               XPIProvider.allAppGlobal = false;
41550:           }
41550:           else {
41584:             changed = removeMetadata(installLocation, aOldAddon) || changed;
41550:           }
41550:         }, this);
41550:       }
41550: 
41550:       // All the remaining add-ons in this install location must be new.
41550: 
41550:       // Get the migration data for this install location.
41550:       let locMigrateData = {};
41584:       if (aMigrateData && installLocation.name in aMigrateData)
41584:         locMigrateData = aMigrateData[installLocation.name];
41550:       for (let id in addonStates) {
41550:         changed = addMetadata(installLocation, id, addonStates[id],
41550:                               locMigrateData[id]) || changed;
41550:       }
41550:     }, this);
41550: 
41550:     // The remaining locations that had add-ons installed in them no longer
41550:     // have any add-ons installed in them, or the locations no longer exist.
41550:     // The metadata for the add-ons that were in them must be removed from the
41550:     // database.
41584:     knownLocations.forEach(function(aLocation) {
41584:       let addons = XPIDatabase.getAddonsInLocation(aLocation);
41584:       addons.forEach(function(aOldAddon) {
41584:         changed = removeMetadata(aLocation, aOldAddon) || changed;
41550:       }, this);
41550:     }, this);
41550: 
41550:     // Cache the new install location states
74689:     let cache = JSON.stringify(this.getInstallLocationStates());
41550:     Services.prefs.setCharPref(PREF_INSTALL_CACHE, cache);
55169: 
41550:     return changed;
41550:   },
41550: 
41550:   /**
41593:    * Imports the xpinstall permissions from preferences into the permissions
41593:    * manager for the user to change later.
41593:    */
41593:   importPermissions: function XPI_importPermissions() {
41593:     function importList(aPrefBranch, aAction) {
41593:       let list = Services.prefs.getChildList(aPrefBranch, {});
41593:       list.forEach(function(aPref) {
41593:         let hosts = Prefs.getCharPref(aPref, "");
41593:         if (!hosts)
41593:           return;
41593: 
41593:         hosts.split(",").forEach(function(aHost) {
41593:           Services.perms.add(NetUtil.newURI("http://" + aHost), XPI_PERMISSION,
41593:                              aAction);
41593:         });
48028: 
48028:         Services.prefs.setCharPref(aPref, "");
41593:       });
41593:     }
41593: 
41593:     importList(PREF_XPI_WHITELIST_PERMISSIONS,
41593:                Ci.nsIPermissionManager.ALLOW_ACTION);
41593:     importList(PREF_XPI_BLACKLIST_PERMISSIONS,
41593:                Ci.nsIPermissionManager.DENY_ACTION);
41593:   },
41593: 
41593:   /**
41550:    * Checks for any changes that have occurred since the last time the
41550:    * application was launched.
41550:    *
41584:    * @param  aAppChanged
51288:    *         A tri-state value. Undefined means the current profile was created
51288:    *         for this session, true means the profile already existed but was
51288:    *         last used with an application with a different version number,
51288:    *         false means that the profile was last used by this version of the
51288:    *         application.
70084:    * @param  aOldAppVersion
70084:    *         The version of the application last run with this profile or null
70084:    *         if it is a new profile or the version is unknown
70084:    * @param  aOldPlatformVersion
70084:    *         The version of the platform last run with this profile or null
70084:    *         if it is a new profile or the version is unknown
41550:    * @return true if a change requiring a restart was detected
41550:    */
70084:   checkForChanges: function XPI_checkForChanges(aAppChanged, aOldAppVersion,
70084:                                                 aOldPlatformVersion) {
41550:     LOG("checkForChanges");
41550: 
51288:     // Import the website installation permissions if the application has changed
51288:     if (aAppChanged !== false)
41593:       this.importPermissions();
41593: 
57160:     // If the application version has changed then the database information
57160:     // needs to be updated
57160:     let updateDatabase = aAppChanged;
57160: 
68871:     // Load the list of bootstrapped add-ons first so processFileChanges can
68871:     // modify it
68871:     this.bootstrappedAddons = JSON.parse(Prefs.getCharPref(PREF_BOOTSTRAP_ADDONS,
68871:                                          "{}"));
68871: 
57160:     // First install any new add-ons into the locations, if there are any
57160:     // changes then we must update the database with the information in the
57160:     // install locations
41550:     let manifests = {};
57160:     updateDatabase = this.processPendingFileChanges(manifests) | updateDatabase;
57160: 
57160:     // This will be true if the previous session made changes that affect the
57160:     // active state of add-ons but didn't commit them properly (normally due
57160:     // to the application crashing)
57160:     let hasPendingChanges = Prefs.getBoolPref(PREF_PENDING_OPERATIONS);
57160: 
57160:     // If the schema appears to have changed then we should update the database
57160:     updateDatabase |= DB_SCHEMA != Prefs.getIntPref(PREF_DB_SCHEMA, 0);
57160: 
60885:     // If the application has changed then check for new distribution add-ons
60885:     if (aAppChanged !== false &&
60885:         Prefs.getBoolPref(PREF_INSTALL_DISTRO_ADDONS, true))
60885:       updateDatabase = this.installDistributionAddons(manifests) | updateDatabase;
60885: 
41550:     let state = this.getInstallLocationStates();
57160: 
57160:     if (!updateDatabase) {
57160:       // If the state has changed then we must update the database
57160:       let cache = Prefs.getCharPref(PREF_INSTALL_CACHE, null);
57160:       updateDatabase |= cache != JSON.stringify(state);
57160:     }
57160: 
82208:     // If the database doesn't exist and there are add-ons installed then we
82208:     // must update the database however if there are no add-ons then there is
82208:     // no need to update the database.
82208:     if (!XPIDatabase.dbfileExists)
82208:       updateDatabase = state.length > 0;
82208: 
60302:     if (!updateDatabase) {
60302:       let bootstrapDescriptors = [this.bootstrappedAddons[b].descriptor
60302:                                   for (b in this.bootstrappedAddons)];
60302: 
60302:       state.forEach(function(aInstallLocationState) {
60302:         for (let id in aInstallLocationState.addons) {
60302:           let pos = bootstrapDescriptors.indexOf(aInstallLocationState.addons[id].descriptor);
60302:           if (pos != -1)
60302:             bootstrapDescriptors.splice(pos, 1);
60302:         }
60302:       });
60302: 
60302:       if (bootstrapDescriptors.length > 0) {
60302:         WARN("Bootstrap state is invalid (missing add-ons: " + bootstrapDescriptors.toSource() + ")");
60302:         updateDatabase = true;
60302:       }
60302:     }
60302: 
57160:     // Catch any errors during the main startup and rollback the database changes
57160:     XPIDatabase.beginTransaction();
41550:     try {
57160:       let extensionListChanged = false;
57160:       // If the database needs to be updated then open it and then update it
57160:       // from the filesystem
57160:       if (updateDatabase || hasPendingChanges) {
82208:         let migrateData = XPIDatabase.openConnection(false, true);
57160: 
57160:         try {
57160:           extensionListChanged = this.processFileChanges(state, manifests,
57160:                                                          aAppChanged,
70084:                                                          aOldAppVersion,
70084:                                                          aOldPlatformVersion,
57160:                                                          migrateData, null);
41550:         }
41550:         catch (e) {
57401:           ERROR("Error processing file changes", e);
41550:         }
41550:       }
41550: 
59564:       if (aAppChanged) {
46454:         // When upgrading the app and using a custom skin make sure it is still
46454:         // compatible otherwise switch back the default
59564:         if (this.currentSkin != this.defaultSkin) {
46454:           let oldSkin = XPIDatabase.getVisibleAddonForInternalName(this.currentSkin);
70084:           if (!oldSkin || isAddonDisabled(oldSkin))
46454:             this.enableDefaultTheme();
46454:         }
46454: 
59564:         // When upgrading remove the old extensions cache to force older
59564:         // versions to rescan the entire list of extensions
59564:         let oldCache = FileUtils.getFile(KEY_PROFILEDIR, [FILE_OLD_CACHE], true);
59564:         if (oldCache.exists())
59564:           oldCache.remove(true);
59564:       }
59564: 
41550:       // If the application crashed before completing any pending operations then
41550:       // we should perform them now.
57160:       if (extensionListChanged || hasPendingChanges) {
47636:         LOG("Updating database with changes to installed add-ons");
41550:         XPIDatabase.updateActiveAddons();
42885:         XPIDatabase.commitTransaction();
56256:         XPIDatabase.writeAddonsList();
41550:         Services.prefs.setBoolPref(PREF_PENDING_OPERATIONS, false);
42628:         Services.prefs.setCharPref(PREF_BOOTSTRAP_ADDONS,
42628:                                    JSON.stringify(this.bootstrappedAddons));
60305:         return true;
41550:       }
41550: 
41550:       LOG("No changes found");
42885:       XPIDatabase.commitTransaction();
42885:     }
42885:     catch (e) {
42885:       ERROR("Error during startup file checks, rolling back any database " +
57401:             "changes", e);
42885:       XPIDatabase.rollbackTransaction();
42885:     }
41550: 
41550:     // Check that the add-ons list still exists
41550:     let addonsList = FileUtils.getFile(KEY_PROFILEDIR, [FILE_XPI_ADDONS_LIST],
41550:                                        true);
82313:     if (addonsList.exists() == (state.length == 0)) {
82313:       LOG("Add-ons list is invalid, rebuilding");
56256:       XPIDatabase.writeAddonsList();
47636:     }
60305: 
60305:     return false;
41550:   },
41550: 
41550:   /**
41550:    * Called to test whether this provider supports installing a particular
41550:    * mimetype.
41550:    *
41584:    * @param  aMimetype
41550:    *         The mimetype to check for
41550:    * @return true if the mimetype is application/x-xpinstall
41550:    */
41584:   supportsMimetype: function XPI_supportsMimetype(aMimetype) {
41584:     return aMimetype == "application/x-xpinstall";
41550:   },
41550: 
41550:   /**
41550:    * Called to test whether installing XPI add-ons is enabled.
41550:    *
41550:    * @return true if installing is enabled
41550:    */
41550:   isInstallEnabled: function XPI_isInstallEnabled() {
41550:     // Default to enabled if the preference does not exist
41550:     return Prefs.getBoolPref(PREF_XPI_ENABLED, true);
41550:   },
41550: 
41550:   /**
41550:    * Called to test whether installing XPI add-ons from a URI is allowed.
41550:    *
41584:    * @param  aUri
41550:    *         The URI being installed from
41550:    * @return true if installing is allowed
41550:    */
41584:   isInstallAllowed: function XPI_isInstallAllowed(aUri) {
41550:     if (!this.isInstallEnabled())
41550:       return false;
41550: 
41584:     if (!aUri)
41550:       return true;
41550: 
41550:     // file: and chrome: don't need whitelisted hosts
41584:     if (aUri.schemeIs("chrome") || aUri.schemeIs("file"))
41550:       return true;
41550: 
41550: 
41584:     let permission = Services.perms.testPermission(aUri, XPI_PERMISSION);
41550:     if (permission == Ci.nsIPermissionManager.DENY_ACTION)
41550:       return false;
41550: 
41550:     let requireWhitelist = Prefs.getBoolPref(PREF_XPI_WHITELIST_REQUIRED, true);
41550:     if (requireWhitelist && (permission != Ci.nsIPermissionManager.ALLOW_ACTION))
41550:       return false;
41550: 
41550:     return true;
41550:   },
41550: 
41550:   /**
41550:    * Called to get an AddonInstall to download and install an add-on from a URL.
41550:    *
41584:    * @param  aUrl
41550:    *         The URL to be installed
41584:    * @param  aHash
41550:    *         A hash for the install
41584:    * @param  aName
41550:    *         A name for the install
41584:    * @param  aIconURL
41550:    *         An icon URL for the install
41584:    * @param  aVersion
41550:    *         A version for the install
41584:    * @param  aLoadGroup
41569:    *         An nsILoadGroup to associate requests with
41584:    * @param  aCallback
41550:    *         A callback to pass the AddonInstall to
41550:    */
41584:   getInstallForURL: function XPI_getInstallForURL(aUrl, aHash, aName, aIconURL,
41584:                                                   aVersion, aLoadGroup, aCallback) {
41584:     AddonInstall.createDownload(function(aInstall) {
41584:       aCallback(aInstall.wrapper);
41584:     }, aUrl, aHash, aName, aIconURL, aVersion, aLoadGroup);
41550:   },
41550: 
41550:   /**
41550:    * Called to get an AddonInstall to install an add-on from a local file.
41550:    *
41584:    * @param  aFile
41550:    *         The file to be installed
41584:    * @param  aCallback
41550:    *         A callback to pass the AddonInstall to
41550:    */
41584:   getInstallForFile: function XPI_getInstallForFile(aFile, aCallback) {
41584:     AddonInstall.createInstall(function(aInstall) {
41584:       if (aInstall)
41584:         aCallback(aInstall.wrapper);
41550:       else
41584:         aCallback(null);
41584:     }, aFile);
41550:   },
41550: 
41584:   /**
41584:    * Removes an AddonInstall from the list of active installs.
41584:    *
41584:    * @param  install
41584:    *         The AddonInstall to remove
41584:    */
41584:   removeActiveInstall: function XPI_removeActiveInstall(aInstall) {
41584:     this.installs = this.installs.filter(function(i) i != aInstall);
41582:   },
41582: 
41550:   /**
41550:    * Called to get an Addon with a particular ID.
41550:    *
41584:    * @param  aId
41550:    *         The ID of the add-on to retrieve
41584:    * @param  aCallback
41550:    *         A callback to pass the Addon to
41550:    */
41585:   getAddonByID: function XPI_getAddonByID(aId, aCallback) {
41584:     XPIDatabase.getVisibleAddonForID(aId, function(aAddon) {
41584:       if (aAddon)
41584:         aCallback(createWrapper(aAddon));
41550:       else
41584:         aCallback(null);
41550:     });
41550:   },
41550: 
41550:   /**
41550:    * Called to get Addons of a particular type.
41550:    *
41584:    * @param  aTypes
41550:    *         An array of types to fetch. Can be null to get all types.
41584:    * @param  aCallback
41550:    *         A callback to pass an array of Addons to
41550:    */
41584:   getAddonsByTypes: function XPI_getAddonsByTypes(aTypes, aCallback) {
41584:     XPIDatabase.getVisibleAddons(aTypes, function(aAddons) {
41584:       aCallback([createWrapper(a) for each (a in aAddons)]);
41550:     });
41550:   },
41550: 
41550:   /**
82404:    * Obtain an Addon having the specified Sync GUID.
82404:    *
82404:    * @param  aGUID
82404:    *         String GUID of add-on to retrieve
82404:    * @param  aCallback
82404:    *         A callback to pass the Addon to. Receives null if not found.
82404:    */
82404:   getAddonBySyncGUID: function XPI_getAddonBySyncGUID(aGUID, aCallback) {
82404:     XPIDatabase.getAddonBySyncGUID(aGUID, function(aAddon) {
82404:       if (aAddon)
82404:         aCallback(createWrapper(aAddon));
82404:       else
82404:         aCallback(null);
82404:     });
82404:   },
82404: 
82404:   /**
41550:    * Called to get Addons that have pending operations.
41550:    *
41584:    * @param  aTypes
41550:    *         An array of types to fetch. Can be null to get all types
41584:    * @param  aCallback
41550:    *         A callback to pass an array of Addons to
41550:    */
41585:   getAddonsWithOperationsByTypes:
41585:   function XPI_getAddonsWithOperationsByTypes(aTypes, aCallback) {
41584:     XPIDatabase.getVisibleAddonsWithPendingOperations(aTypes, function(aAddons) {
41584:       let results = [createWrapper(a) for each (a in aAddons)];
41584:       XPIProvider.installs.forEach(function(aInstall) {
41584:         if (aInstall.state == AddonManager.STATE_INSTALLED &&
41584:             !(aInstall.addon instanceof DBAddonInternal))
41584:           results.push(createWrapper(aInstall.addon));
41550:       });
41584:       aCallback(results);
41550:     });
41550:   },
41550: 
41550:   /**
41550:    * Called to get the current AddonInstalls, optionally limiting to a list of
41550:    * types.
41550:    *
41584:    * @param  aTypes
41550:    *         An array of types or null to get all types
41584:    * @param  aCallback
41550:    *         A callback to pass the array of AddonInstalls to
41550:    */
41585:   getInstallsByTypes: function XPI_getInstallsByTypes(aTypes, aCallback) {
41564:     let results = [];
41584:     this.installs.forEach(function(aInstall) {
41584:       if (!aTypes || aTypes.indexOf(aInstall.type) >= 0)
41584:         results.push(aInstall.wrapper);
41564:     });
41584:     aCallback(results);
41550:   },
41550: 
41550:   /**
41550:    * Called when a new add-on has been enabled when only one add-on of that type
41550:    * can be enabled.
41550:    *
41584:    * @param  aId
41550:    *         The ID of the newly enabled add-on
41584:    * @param  aType
41550:    *         The type of the newly enabled add-on
41584:    * @param  aPendingRestart
41550:    *         true if the newly enabled add-on will only become enabled after a
41550:    *         restart
41550:    */
41584:   addonChanged: function XPI_addonChanged(aId, aType, aPendingRestart) {
41550:     // We only care about themes in this provider
41584:     if (aType != "theme")
41550:       return;
41550: 
41584:     if (!aId) {
41550:       // Fallback to the default theme when no theme was enabled
41550:       this.enableDefaultTheme();
41550:       return;
41550:     }
41550: 
41550:     // Look for the previously enabled theme and find the internalName of the
41550:     // currently selected theme
41550:     let previousTheme = null;
41550:     let newSkin = this.defaultSkin;
41550:     let addons = XPIDatabase.getAddonsByType("theme");
41584:     addons.forEach(function(aTheme) {
41584:       if (!aTheme.visible)
41550:         return;
41584:       if (aTheme.id == aId)
41584:         newSkin = aTheme.internalName;
41584:       else if (aTheme.userDisabled == false && !aTheme.pendingUninstall)
41584:         previousTheme = aTheme;
41550:     }, this);
41550: 
41584:     if (aPendingRestart) {
41550:       Services.prefs.setBoolPref(PREF_DSS_SWITCHPENDING, true);
41550:       Services.prefs.setCharPref(PREF_DSS_SKIN_TO_SELECT, newSkin);
41550:     }
42089:     else if (newSkin == this.currentSkin) {
42089:       try {
42089:         Services.prefs.clearUserPref(PREF_DSS_SWITCHPENDING);
42089:       }
42089:       catch (e) { }
42089:       try {
42089:         Services.prefs.clearUserPref(PREF_DSS_SKIN_TO_SELECT);
42089:       }
42089:       catch (e) { }
42089:     }
41550:     else {
41550:       Services.prefs.setCharPref(PREF_GENERAL_SKINS_SELECTEDSKIN, newSkin);
42089:       this.currentSkin = newSkin;
41550:     }
41550:     this.selectedSkin = newSkin;
41550: 
54991:     // Flush the preferences to disk so they don't get out of sync with the
54991:     // database
54991:     Services.prefs.savePrefFile(null);
54991: 
41550:     // Mark the previous theme as disabled. This won't cause recursion since
41550:     // only enabled calls notifyAddonChanged.
41550:     if (previousTheme)
41550:       this.updateAddonDisabledState(previousTheme, true);
41550:   },
41550: 
41550:   /**
41589:    * Update the appDisabled property for all add-ons.
41589:    */
41589:   updateAddonAppDisabledStates: function XPI_updateAddonAppDisabledStates() {
41589:     let addons = XPIDatabase.getAddons();
41589:     addons.forEach(function(aAddon) {
41589:       this.updateAddonDisabledState(aAddon);
41589:     }, this);
41589:   },
41589: 
41589:   /**
83133:    * Update the repositoryAddon property for all add-ons.
83133:    *
83133:    * @param  aCallback
83133:    *         Function to call when operation is complete.
83133:    */
83133:   updateAddonRepositoryData: function XPI_updateAddonRepositoryData(aCallback) {
83133:     let self = this;
83133:     XPIDatabase.getVisibleAddons(null, function UARD_getVisibleAddonsCallback(aAddons) {
83133:       let pending = aAddons.length;
83192:       if (pending == 0) {
83192:         aCallback();
83192:         return;
83192:       }
83192: 
83133:       function notifyComplete() {
83133:         if (--pending == 0)
83133:           aCallback();
83133:       }
83133: 
83133:       aAddons.forEach(function UARD_forEachCallback(aAddon) {
83133:         AddonRepository.getCachedAddonByID(aAddon.id,
83133:                                            function UARD_getCachedAddonCallback(aRepoAddon) {
83133:           if (aRepoAddon) {
83133:             aAddon._repositoryAddon = aRepoAddon;
83133:             aAddon.compatibilityOverrides = aRepoAddon.compatibilityOverrides;
83133:             self.updateAddonDisabledState(aAddon);
83133:           }
83133: 
83133:           notifyComplete();
83133:         });
83133:       });
83133:     });
83133:   },
83133: 
83133:   /**
41550:    * When the previously selected theme is removed this method will be called
41550:    * to enable the default theme.
41550:    */
41550:   enableDefaultTheme: function XPI_enableDefaultTheme() {
41550:     LOG("Activating default theme");
46454:     let addon = XPIDatabase.getVisibleAddonForInternalName(this.defaultSkin);
70084:     if (addon) {
70084:       if (addon.userDisabled) {
46454:         this.updateAddonDisabledState(addon, false);
70084:       }
70084:       else if (!this.extensionsActive) {
70084:         // During startup we may end up trying to enable the default theme when
70084:         // the database thinks it is already enabled (see f.e. bug 638847). In
70084:         // this case just force the theme preferences to be correct
70084:         Services.prefs.setCharPref(PREF_GENERAL_SKINS_SELECTEDSKIN,
70084:                                    addon.internalName);
70084:         this.currentSkin = this.selectedSkin = addon.internalName;
70084:         Prefs.clearUserPref(PREF_DSS_SKIN_TO_SELECT);
70084:         Prefs.clearUserPref(PREF_DSS_SWITCHPENDING);
70084:       }
70084:       else {
70084:         WARN("Attempting to activate an already active default theme");
70084:       }
70084:     }
70084:     else {
46454:       WARN("Unable to activate the default theme");
70084:     }
41550:   },
41550: 
41550:   /**
41550:    * Notified when a preference we're interested in has changed.
41550:    *
41550:    * @see nsIObserver
41550:    */
41584:   observe: function XPI_observe(aSubject, aTopic, aData) {
41584:     switch (aData) {
70820:     case PREF_EM_CHECK_COMPATIBILITY:
41550:     case PREF_EM_CHECK_UPDATE_SECURITY:
82276:     case PREF_EM_MIN_COMPAT_APP_VERSION:
82276:     case PREF_EM_MIN_COMPAT_PLATFORM_VERSION:
70820:       this.checkCompatibility = Prefs.getBoolPref(PREF_EM_CHECK_COMPATIBILITY,
41550:                                                   true);
41550:       this.checkUpdateSecurity = Prefs.getBoolPref(PREF_EM_CHECK_UPDATE_SECURITY,
41550:                                                    true);
82276:       this.minCompatibleAppVersion = Prefs.getCharPref(PREF_EM_MIN_COMPAT_APP_VERSION,
82276:                                                        null);
82276:       this.minCompatiblePlatformVersion = Prefs.getCharPref(PREF_EM_MIN_COMPAT_PLATFORM_VERSION,
82276:                                                             null);
41550:       this.updateAllAddonDisabledStates();
41550:       break;
41550:     }
41550:   },
41550: 
41550:   /**
41550:    * Tests whether enabling an add-on will require a restart.
41550:    *
41584:    * @param  aAddon
41550:    *         The add-on to test
41550:    * @return true if the operation requires a restart
41550:    */
41584:   enableRequiresRestart: function XPI_enableRequiresRestart(aAddon) {
50742:     // If the platform couldn't have activated extensions then we can make
50742:     // changes without any restart.
50742:     if (!this.extensionsActive)
50742:       return false;
50742: 
54988:     // If the application is in safe mode then any change can be made without
54988:     // restarting
54988:     if (Services.appinfo.inSafeMode)
54988:       return false;
54988: 
51837:     // Anything that is active is already enabled
51837:     if (aAddon.active)
51837:       return false;
51837: 
51837:     if (aAddon.type == "theme") {
51837:       // If dynamic theme switching is enabled then switching themes does not
51837:       // require a restart
51837:       if (Prefs.getBoolPref(PREF_EM_DSS_ENABLED))
51837:         return false;
51837: 
51837:       // If the theme is already the theme in use then no restart is necessary.
51837:       // This covers the case where the default theme is in use but a
51837:       // lightweight theme is considered active.
51837:       return aAddon.internalName != this.currentSkin;
51837:     }
41550: 
41591:     return !aAddon.bootstrap;
41550:   },
41550: 
41550:   /**
41550:    * Tests whether disabling an add-on will require a restart.
41550:    *
41584:    * @param  aAddon
41550:    *         The add-on to test
41550:    * @return true if the operation requires a restart
41550:    */
41584:   disableRequiresRestart: function XPI_disableRequiresRestart(aAddon) {
50742:     // If the platform couldn't have activated up extensions then we can make
50742:     // changes without any restart.
50742:     if (!this.extensionsActive)
50742:       return false;
50742: 
54988:     // If the application is in safe mode then any change can be made without
54988:     // restarting
54988:     if (Services.appinfo.inSafeMode)
54988:       return false;
54988: 
51837:     // Anything that isn't active is already disabled
51837:     if (!aAddon.active)
51837:       return false;
51837: 
51837:     if (aAddon.type == "theme") {
51837:       // If dynamic theme switching is enabled then switching themes does not
51837:       // require a restart
51837:       if (Prefs.getBoolPref(PREF_EM_DSS_ENABLED))
51837:         return false;
51837: 
51837:       // Non-default themes always require a restart to disable since it will
51837:       // be switching from one theme to another or to the default theme and a
51837:       // lightweight theme.
51837:       if (aAddon.internalName != this.defaultSkin)
51837:         return true;
51837: 
51837:       // The default theme requires a restart to disable if we are in the
51837:       // process of switching to a different theme. Note that this makes the
51837:       // disabled flag of operationsRequiringRestart incorrect for the default
51837:       // theme (it will be false most of the time). Bug 520124 would be required
51837:       // to fix it. For the UI this isn't a problem since we never try to
51837:       // disable or uninstall the default theme.
51837:       return this.selectedSkin != this.currentSkin;
51837:     }
41550: 
41591:     return !aAddon.bootstrap;
41550:   },
41550: 
41550:   /**
41550:    * Tests whether installing an add-on will require a restart.
41550:    *
41584:    * @param  aAddon
41550:    *         The add-on to test
41550:    * @return true if the operation requires a restart
41550:    */
41584:   installRequiresRestart: function XPI_installRequiresRestart(aAddon) {
50742:     // If the platform couldn't have activated up extensions then we can make
50742:     // changes without any restart.
50742:     if (!this.extensionsActive)
50742:       return false;
50742: 
54988:     // If the application is in safe mode then any change can be made without
54988:     // restarting
54988:     if (Services.appinfo.inSafeMode)
54988:       return false;
54988: 
51837:     // Add-ons that are already installed don't require a restart to install.
51837:     // This wouldn't normally be called for an already installed add-on (except
51837:     // for forming the operationsRequiringRestart flags) so is really here as
51837:     // a safety measure.
51837:     if (aAddon instanceof DBAddonInternal)
51837:       return false;
51837: 
51837:     // If we have an AddonInstall for this add-on then we can see if there is
51837:     // an existing installed add-on with the same ID
51837:     if ("_install" in aAddon && aAddon._install) {
51837:       // If there is an existing installed add-on and uninstalling it would
51837:       // require a restart then installing the update will also require a
51837:       // restart
51837:       let existingAddon = aAddon._install.existingAddon;
51837:       if (existingAddon && this.uninstallRequiresRestart(existingAddon))
51837:         return true;
51837:     }
51837: 
51837:     // If the add-on is not going to be active after installation then it
51837:     // doesn't require a restart to install.
70084:     if (isAddonDisabled(aAddon))
51837:       return false;
51837: 
51837:     // Themes will require a restart (even if dynamic switching is enabled due
51837:     // to some caching issues) and non-bootstrapped add-ons will require a
51837:     // restart
51837:     return aAddon.type == "theme" || !aAddon.bootstrap;
41550:   },
41550: 
41550:   /**
41550:    * Tests whether uninstalling an add-on will require a restart.
41550:    *
41584:    * @param  aAddon
41550:    *         The add-on to test
41550:    * @return true if the operation requires a restart
41550:    */
41584:   uninstallRequiresRestart: function XPI_uninstallRequiresRestart(aAddon) {
50742:     // If the platform couldn't have activated up extensions then we can make
50742:     // changes without any restart.
50742:     if (!this.extensionsActive)
50742:       return false;
50742: 
54988:     // If the application is in safe mode then any change can be made without
54988:     // restarting
54988:     if (Services.appinfo.inSafeMode)
54988:       return false;
54988: 
51837:     // If the add-on can be disabled without a restart then it can also be
51837:     // uninstalled without a restart
51837:     return this.disableRequiresRestart(aAddon);
41550:   },
41550: 
41550:   /**
41591:    * Loads a bootstrapped add-on's bootstrap.js into a sandbox and the reason
41591:    * values as constants in the scope. This will also add information about the
41591:    * add-on to the bootstrappedAddons dictionary and notify the crash reporter
41591:    * that new add-ons have been loaded.
41550:    *
41584:    * @param  aId
41591:    *         The add-on's ID
52422:    * @param  aFile
52422:    *         The nsILocalFile for the add-on
41591:    * @param  aVersion
41591:    *         The add-on's version
41591:    * @return a JavaScript scope
41550:    */
79913:   loadBootstrapScope: function XPI_loadBootstrapScope(aId, aFile, aVersion, aType) {
52422:     LOG("Loading bootstrap scope from " + aFile.path);
41575:     // Mark the add-on as active for the crash reporter before loading
41584:     this.bootstrappedAddons[aId] = {
41584:       version: aVersion,
79913:       type: aType,
52422:       descriptor: aFile.persistentDescriptor
41575:     };
41575:     this.addAddonsToCrashReporter();
41575: 
41591:     let principal = Cc["@mozilla.org/systemprincipal;1"].
41591:                     createInstance(Ci.nsIPrincipal);
41591: 
71854:     if (!aFile.exists()) {
76944:       this.bootstrapScopes[aId] = new Components.utils.Sandbox(principal,
76944:                                                                {sandboxName: aFile.path});
60302:       ERROR("Attempted to load bootstrap scope from missing directory " + bootstrap.path);
60302:       return;
60302:     }
60302: 
76944:     let uri = getURIForResourceInFile(aFile, "bootstrap.js").spec;
76944:     this.bootstrapScopes[aId] = new Components.utils.Sandbox(principal,
76944:                                                              {sandboxName: uri});
76944: 
41591:     let loader = Cc["@mozilla.org/moz/jssubscript-loader;1"].
41591:                  createInstance(Ci.mozIJSSubScriptLoader);
41591: 
41550:     try {
60997:       // As we don't want our caller to control the JS version used for the
60997:       // bootstrap file, we run loadSubScript within the context of the
60997:       // sandbox with the latest JS version set explicitly.
79913:       if (aType == "dictionary") {
79913:         this.bootstrapScopes[aId].__SCRIPT_URI_SPEC__ =
79913:             "resource://gre/modules/SpellCheckDictionaryBootstrap.js"
79913:       } else {
76944:         this.bootstrapScopes[aId].__SCRIPT_URI_SPEC__ = uri;
79913:       }
60997:       Components.utils.evalInSandbox(
60997:         "Components.classes['@mozilla.org/moz/jssubscript-loader;1'] \
60997:                    .createInstance(Components.interfaces.mozIJSSubScriptLoader) \
60997:                    .loadSubScript(__SCRIPT_URI_SPEC__);", this.bootstrapScopes[aId], "ECMAv5");
41550:     }
41550:     catch (e) {
57401:       WARN("Error loading bootstrap.js for " + aId, e);
41584:     }
41584: 
41591:     // Copy the reason values from the global object into the bootstrap scope.
41591:     for (let name in BOOTSTRAP_REASONS)
41591:       this.bootstrapScopes[aId][name] = BOOTSTRAP_REASONS[name];
80426: 
80426: 
80426:     // Add other stuff that extensions want.
80426:     const features = [ "Worker", "ChromeWorker" ];
80426: 
80426:     for each (let feature in features)
80426:       this.bootstrapScopes[aId][feature] = gGlobalScope[feature];
41550:   },
41550: 
41550:   /**
41591:    * Unloads a bootstrap scope by dropping all references to it and then
41591:    * updating the list of active add-ons with the crash reporter.
41550:    *
41584:    * @param  aId
41591:    *         The add-on's ID
41550:    */
41591:   unloadBootstrapScope: function XPI_unloadBootstrapScope(aId) {
41591:     delete this.bootstrapScopes[aId];
41591:     delete this.bootstrappedAddons[aId];
41591:     this.addAddonsToCrashReporter();
41591:   },
41591: 
41591:   /**
41591:    * Calls a bootstrap method for an add-on.
41591:    *
41591:    * @param  aId
41591:    *         The ID of the add-on
41591:    * @param  aVersion
41591:    *         The version of the add-on
79913:    * @param  aType
79913:    *         The type for the add-on
52422:    * @param  aFile
52422:    *         The nsILocalFile for the add-on
41591:    * @param  aMethod
41591:    *         The name of the bootstrap method to call
41591:    * @param  aReason
41591:    *         The reason flag to pass to the bootstrap's startup method
41591:    */
79913:   callBootstrapMethod: function XPI_callBootstrapMethod(aId, aVersion, aType, aFile,
41591:                                                         aMethod, aReason) {
54988:     // Never call any bootstrap methods in safe mode
54988:     if (Services.appinfo.inSafeMode)
54988:       return;
54988: 
80655:     if (aMethod == "startup")
80655:       Components.manager.addBootstrappedManifestLocation(aFile);
80655: 
80655:     try {
41591:       // Load the scope if it hasn't already been loaded
41591:       if (!(aId in this.bootstrapScopes))
79913:         this.loadBootstrapScope(aId, aFile, aVersion, aType);
41591: 
41591:       if (!(aMethod in this.bootstrapScopes[aId])) {
41591:         WARN("Add-on " + aId + " is missing bootstrap method " + aMethod);
41550:         return;
41550:       }
41591: 
41591:       let params = {
41591:         id: aId,
41591:         version: aVersion,
71854:         installPath: aFile.clone(),
71854:         resourceURI: getURIForResourceInFile(aFile, "")
41591:       };
41591: 
41591:       LOG("Calling bootstrap method " + aMethod + " on " + aId + " version " +
41591:           aVersion);
41591:       try {
41591:         this.bootstrapScopes[aId][aMethod](params, aReason);
41591:       }
41591:       catch (e) {
42098:         WARN("Exception running bootstrap method " + aMethod + " on " +
57401:              aId, e);
41591:       }
80655:     }
80655:     finally {
80655:       if (aMethod == "shutdown")
80655:         Components.manager.removeBootstrappedManifestLocation(aFile);
80655:     }
41550:   },
41550: 
41550:   /**
41550:    * Updates the appDisabled property for all add-ons.
41550:    */
41550:   updateAllAddonDisabledStates: function XPI_updateAllAddonDisabledStates() {
41550:     let addons = XPIDatabase.getAddons();
41584:     addons.forEach(function(aAddon) {
41584:       this.updateAddonDisabledState(aAddon);
41550:     }, this);
41550:   },
41550: 
41550:   /**
41550:    * Updates the disabled state for an add-on. Its appDisabled property will be
41550:    * calculated and if the add-on is changed appropriate notifications will be
41550:    * sent out to the registered AddonListeners.
41550:    *
41584:    * @param  aAddon
41550:    *         The DBAddonInternal to update
41584:    * @param  aUserDisabled
41550:    *         Value for the userDisabled property. If undefined the value will
41550:    *         not change
70084:    * @param  aSoftDisabled
70084:    *         Value for the softDisabled property. If undefined the value will
70084:    *         not change. If true this will force userDisabled to be true
41550:    * @throws if addon is not a DBAddonInternal
41550:    */
41584:   updateAddonDisabledState: function XPI_updateAddonDisabledState(aAddon,
70084:                                                                   aUserDisabled,
70084:                                                                   aSoftDisabled) {
41584:     if (!(aAddon instanceof DBAddonInternal))
41550:       throw new Error("Can only update addon states for installed addons.");
70084:     if (aUserDisabled !== undefined && aSoftDisabled !== undefined) {
70084:       throw new Error("Cannot change userDisabled and softDisabled at the " +
70084:                       "same time");
70084:     }
70084: 
70084:     if (aUserDisabled === undefined) {
41584:       aUserDisabled = aAddon.userDisabled;
70084:     }
70084:     else if (!aUserDisabled) {
70084:       // If enabling the add-on then remove softDisabled
70084:       aSoftDisabled = false;
70084:     }
70084: 
70084:     // If not changing softDisabled or the add-on is already userDisabled then
70084:     // use the existing value for softDisabled
70084:     if (aSoftDisabled === undefined || aUserDisabled)
70084:       aSoftDisabled = aAddon.softDisabled;
41584: 
41584:     let appDisabled = !isUsableAddon(aAddon);
41550:     // No change means nothing to do here
41584:     if (aAddon.userDisabled == aUserDisabled &&
70084:         aAddon.appDisabled == appDisabled &&
70084:         aAddon.softDisabled == aSoftDisabled)
41550:       return;
41550: 
70084:     let wasDisabled = isAddonDisabled(aAddon);
70084:     let isDisabled = aUserDisabled || aSoftDisabled || appDisabled;
41550: 
41550:     // Update the properties in the database
41584:     XPIDatabase.setAddonProperties(aAddon, {
41584:       userDisabled: aUserDisabled,
70084:       appDisabled: appDisabled,
70084:       softDisabled: aSoftDisabled
41550:     });
41550: 
41550:     // If the add-on is not visible or the add-on is not changing state then
41550:     // there is no need to do anything else
41584:     if (!aAddon.visible || (wasDisabled == isDisabled))
41550:       return;
41550: 
41550:     // Flag that active states in the database need to be updated on shutdown
41550:     Services.prefs.setBoolPref(PREF_PENDING_OPERATIONS, true);
41550: 
41584:     let wrapper = createWrapper(aAddon);
41550:     // Have we just gone back to the current state?
41584:     if (isDisabled != aAddon.active) {
41550:       AddonManagerPrivate.callAddonListeners("onOperationCancelled", wrapper);
41550:     }
41550:     else {
41550:       if (isDisabled) {
41584:         var needsRestart = this.disableRequiresRestart(aAddon);
41550:         AddonManagerPrivate.callAddonListeners("onDisabling", wrapper,
41550:                                                needsRestart);
41550:       }
41550:       else {
41584:         needsRestart = this.enableRequiresRestart(aAddon);
41550:         AddonManagerPrivate.callAddonListeners("onEnabling", wrapper,
41550:                                                needsRestart);
41550:       }
41550: 
41550:       if (!needsRestart) {
41584:         aAddon.active = !isDisabled;
41584:         XPIDatabase.updateAddonActive(aAddon);
41550:         if (isDisabled) {
41591:           if (aAddon.bootstrap) {
52422:             let file = aAddon._installLocation.getLocationForID(aAddon.id);
79913:             this.callBootstrapMethod(aAddon.id, aAddon.version, aAddon.type, file, "shutdown",
41591:                                      BOOTSTRAP_REASONS.ADDON_DISABLE);
41591:             this.unloadBootstrapScope(aAddon.id);
41591:           }
41550:           AddonManagerPrivate.callAddonListeners("onDisabled", wrapper);
41550:         }
41550:         else {
41591:           if (aAddon.bootstrap) {
52422:             let file = aAddon._installLocation.getLocationForID(aAddon.id);
79913:             this.callBootstrapMethod(aAddon.id, aAddon.version, aAddon.type, file, "startup",
41591:                                      BOOTSTRAP_REASONS.ADDON_ENABLE);
41550:           }
41550:           AddonManagerPrivate.callAddonListeners("onEnabled", wrapper);
41550:         }
41550:       }
41550:     }
41550: 
41550:     // Notify any other providers that a new theme has been enabled
41584:     if (aAddon.type == "theme" && !isDisabled)
41594:       AddonManagerPrivate.notifyAddonChanged(aAddon.id, aAddon.type, needsRestart);
41550:   },
41550: 
41550:   /**
41550:    * Uninstalls an add-on, immediately if possible or marks it as pending
41550:    * uninstall if not.
41550:    *
41584:    * @param  aAddon
41550:    *         The DBAddonInternal to uninstall
41550:    * @throws if the addon cannot be uninstalled because it is in an install
41550:    *         location that does not allow it
41550:    */
41584:   uninstallAddon: function XPI_uninstallAddon(aAddon) {
41584:     if (!(aAddon instanceof DBAddonInternal))
41550:       throw new Error("Can only uninstall installed addons.");
41550: 
41584:     if (aAddon._installLocation.locked)
41550:       throw new Error("Cannot uninstall addons from locked install locations");
41550: 
41550:     // Inactive add-ons don't require a restart to uninstall
51837:     let requiresRestart = this.uninstallRequiresRestart(aAddon);
41550: 
41550:     if (requiresRestart) {
41550:       // We create an empty directory in the staging directory to indicate that
41550:       // an uninstall is necessary on next startup.
41584:       let stage = aAddon._installLocation.getStagingDir();
41584:       stage.append(aAddon.id);
41550:       if (!stage.exists())
41550:         stage.create(Ci.nsIFile.DIRECTORY_TYPE, FileUtils.PERMS_DIRECTORY);
41550: 
41584:       XPIDatabase.setAddonProperties(aAddon, {
41550:         pendingUninstall: true
41550:       });
41550:       Services.prefs.setBoolPref(PREF_PENDING_OPERATIONS, true);
41550:     }
41550: 
41550:     // If the add-on is not visible then there is no need to notify listeners.
41584:     if (!aAddon.visible)
41550:       return;
41550: 
41584:     let wrapper = createWrapper(aAddon);
41550:     AddonManagerPrivate.callAddonListeners("onUninstalling", wrapper,
41550:                                            requiresRestart);
41550: 
56927:     // Reveal the highest priority add-on with the same ID
56927:     function revealAddon(aAddon) {
56927:       XPIDatabase.makeAddonVisible(aAddon);
56927: 
56927:       let wrappedAddon = createWrapper(aAddon);
56927:       AddonManagerPrivate.callAddonListeners("onInstalling", wrappedAddon, false);
56927: 
70084:       if (!isAddonDisabled(aAddon) && !XPIProvider.enableRequiresRestart(aAddon)) {
56927:         aAddon.active = true;
56927:         XPIDatabase.updateAddonActive(aAddon);
56927:       }
56927: 
56927:       if (aAddon.bootstrap) {
56927:         let file = aAddon._installLocation.getLocationForID(aAddon.id);
79913:         XPIProvider.callBootstrapMethod(aAddon.id, aAddon.version, aAddon.type, file,
56927:                                         "install", BOOTSTRAP_REASONS.ADDON_INSTALL);
56927: 
56927:         if (aAddon.active) {
79913:           XPIProvider.callBootstrapMethod(aAddon.id, aAddon.version, aAddon.type, file,
56927:                                           "startup", BOOTSTRAP_REASONS.ADDON_INSTALL);
56927:         }
56927:         else {
56927:           XPIProvider.unloadBootstrapScope(aAddon.id);
56927:         }
56927:       }
56927: 
56927:       // We always send onInstalled even if a restart is required to enable
56927:       // the revealed add-on
56927:       AddonManagerPrivate.callAddonListeners("onInstalled", wrappedAddon);
56927:     }
56927: 
56927:     function checkInstallLocation(aPos) {
56927:       if (aPos < 0)
56927:         return;
56927: 
56927:       let location = XPIProvider.installLocations[aPos];
56927:       XPIDatabase.getAddonInLocation(aAddon.id, location.name, function(aNewAddon) {
56927:         if (aNewAddon)
56927:           revealAddon(aNewAddon);
56927:         else
56927:           checkInstallLocation(aPos - 1);
56927:       })
56927:     }
56927: 
74689:     if (!requiresRestart) {
74689:       if (aAddon.bootstrap) {
74689:         let file = aAddon._installLocation.getLocationForID(aAddon.id);
74689:         if (aAddon.active) {
79913:           this.callBootstrapMethod(aAddon.id, aAddon.version, aAddon.type, file,
79913:                                    "shutdown",
74689:                                    BOOTSTRAP_REASONS.ADDON_UNINSTALL);
74689:         }
74689: 
79913:         this.callBootstrapMethod(aAddon.id, aAddon.version, aAddon.type, file,
79913:                                  "uninstall",
74689:                                  BOOTSTRAP_REASONS.ADDON_UNINSTALL);
74689:         this.unloadBootstrapScope(aAddon.id);
74689:         flushStartupCache();
74689:       }
74689:       aAddon._installLocation.uninstallAddon(aAddon.id);
74689:       XPIDatabase.removeAddonMetadata(aAddon);
74689:       AddonManagerPrivate.callAddonListeners("onUninstalled", wrapper);
74689: 
56927:       checkInstallLocation(this.installLocations.length - 1);
41550:     }
41550: 
41550:     // Notify any other providers that a new theme has been enabled
41584:     if (aAddon.type == "theme" && aAddon.active)
41584:       AddonManagerPrivate.notifyAddonChanged(null, aAddon.type, requiresRestart);
41550:   },
41550: 
41550:   /**
41550:    * Cancels the pending uninstall of an add-on.
41550:    *
41584:    * @param  aAddon
41550:    *         The DBAddonInternal to cancel uninstall for
41550:    */
41584:   cancelUninstallAddon: function XPI_cancelUninstallAddon(aAddon) {
41584:     if (!(aAddon instanceof DBAddonInternal))
41550:       throw new Error("Can only cancel uninstall for installed addons.");
41550: 
56256:     cleanStagingDir(aAddon._installLocation.getStagingDir(), [aAddon.id]);
41550: 
41584:     XPIDatabase.setAddonProperties(aAddon, {
41550:       pendingUninstall: false
41550:     });
41550: 
41584:     if (!aAddon.visible)
41550:       return;
41550: 
41550:     Services.prefs.setBoolPref(PREF_PENDING_OPERATIONS, true);
41550: 
41550:     // TODO hide hidden add-ons (bug 557710)
41584:     let wrapper = createWrapper(aAddon);
41550:     AddonManagerPrivate.callAddonListeners("onOperationCancelled", wrapper);
41550: 
41550:     // Notify any other providers that this theme is now enabled again.
41584:     if (aAddon.type == "theme" && aAddon.active)
41584:       AddonManagerPrivate.notifyAddonChanged(aAddon.id, aAddon.type, false);
41550:   }
41550: };
41550: 
82404: const FIELDS_ADDON = "internal_id, id, syncGUID, location, version, type, " +
82404:                      "internalName, updateURL, updateKey, optionsURL, " +
82404:                      "optionsType, aboutURL, iconURL, icon64URL, " +
82404:                      "defaultLocale, visible, active, userDisabled, " +
82404:                      "appDisabled, pendingUninstall, descriptor, " +
71220:                      "installDate, updateDate, applyBackgroundUpdates, bootstrap, " +
80772:                      "skinnable, size, sourceURI, releaseNotesURI, softDisabled, " +
82652:                      "isForeignInstall, hasBinaryComponents, strictCompatibility";
41550: 
42885: /**
42885:  * A helper function to log an SQL error.
42885:  *
42885:  * @param  aError
42885:  *         The storage error code associated with the error
42885:  * @param  aErrorString
42885:  *         An error message
42885:  */
42885: function logSQLError(aError, aErrorString) {
42885:   ERROR("SQL error " + aError + ": " + aErrorString);
42885: }
42885: 
42885: /**
42885:  * A helper function to log any errors that occur during async statements.
42885:  *
42885:  * @param  aError
42885:  *         A mozIStorageError to log
42885:  */
41584: function asyncErrorLogger(aError) {
42885:   logSQLError(aError.result, aError.message);
42885: }
42885: 
42885: /**
42885:  * A helper function to execute a statement synchronously and log any error
42885:  * that occurs.
42885:  *
42885:  * @param  aStatement
42885:  *         A mozIStorageStatement to execute
42885:  */
42885: function executeStatement(aStatement) {
42885:   try {
42885:     aStatement.execute();
42885:   }
42885:   catch (e) {
42885:     logSQLError(XPIDatabase.connection.lastError,
42885:                 XPIDatabase.connection.lastErrorString);
42885:     throw e;
42885:   }
42885: }
42885: 
42885: /**
42885:  * A helper function to step a statement synchronously and log any error that
42885:  * occurs.
42885:  *
42885:  * @param  aStatement
42885:  *         A mozIStorageStatement to execute
42885:  */
42885: function stepStatement(aStatement) {
42885:   try {
42885:     return aStatement.executeStep();
42885:   }
42885:   catch (e) {
42885:     logSQLError(XPIDatabase.connection.lastError,
42885:                 XPIDatabase.connection.lastErrorString);
42885:     throw e;
42885:   }
41550: }
41550: 
42870: /**
42870:  * A mozIStorageStatementCallback that will asynchronously build DBAddonInternal
42870:  * instances from the results it receives. Once the statement has completed
42870:  * executing and all of the metadata for all of the add-ons has been retrieved
42870:  * they will be passed as an array to aCallback.
42870:  *
42870:  * @param  aCallback
42870:  *         A callback function to pass the array of DBAddonInternals to
42870:  */
42870: function AsyncAddonListCallback(aCallback) {
42870:   this.callback = aCallback;
42870:   this.addons = [];
42870: }
42870: 
42870: AsyncAddonListCallback.prototype = {
42870:   callback: null,
42870:   complete: false,
42870:   count: 0,
42870:   addons: null,
42870: 
42870:   handleResult: function(aResults) {
42870:     let row = null;
42870:     while (row = aResults.getNextRow()) {
42870:       this.count++;
42870:       let self = this;
42870:       XPIDatabase.makeAddonFromRowAsync(row, function(aAddon) {
51520:         function completeAddon(aRepositoryAddon) {
51520:           aAddon._repositoryAddon = aRepositoryAddon;
83133:           aAddon.compatibilityOverrides = aRepositoryAddon ?
83133:                                             aRepositoryAddon.compatibilityOverrides :
83133:                                             null;
42870:           self.addons.push(aAddon);
42870:           if (self.complete && self.addons.length == self.count)
42870:            self.callback(self.addons);
51520:         }
51520: 
51520:         if ("getCachedAddonByID" in AddonRepository)
51520:           AddonRepository.getCachedAddonByID(aAddon.id, completeAddon);
51520:         else
51520:           completeAddon(null);
42870:       });
42870:     }
42870:   },
42870: 
42870:   handleError: asyncErrorLogger,
42870: 
42870:   handleCompletion: function(aReason) {
42870:     this.complete = true;
42870:     if (this.addons.length == this.count)
42870:       this.callback(this.addons);
42870:   }
42870: };
42870: 
41550: var XPIDatabase = {
41550:   // true if the database connection has been opened
41550:   initialized: false,
41550:   // A cache of statements that are used and need to be finalized on shutdown
41550:   statementCache: {},
41550:   // A cache of weak referenced DBAddonInternals so we can reuse objects where
41550:   // possible
41550:   addonCache: [],
42885:   // The nested transaction count
42885:   transactionCount: 0,
82208:   // The database file
82208:   dbfile: FileUtils.getFile(KEY_PROFILEDIR, [FILE_DATABASE], true),
41550: 
41550:   // The statements used by the database
41550:   statements: {
41550:     _getDefaultLocale: "SELECT id, name, description, creator, homepageURL " +
41550:                        "FROM locale WHERE id=:id",
41550:     _getLocales: "SELECT addon_locale.locale, locale.id, locale.name, " +
41550:                  "locale.description, locale.creator, locale.homepageURL " +
41550:                  "FROM addon_locale JOIN locale ON " +
41550:                  "addon_locale.locale_id=locale.id WHERE " +
41550:                  "addon_internal_id=:internal_id",
41550:     _getTargetApplications: "SELECT addon_internal_id, id, minVersion, " +
41550:                             "maxVersion FROM targetApplication WHERE " +
41550:                             "addon_internal_id=:internal_id",
47133:     _getTargetPlatforms: "SELECT os, abi FROM targetPlatform WHERE " +
47133:                          "addon_internal_id=:internal_id",
41550:     _readLocaleStrings: "SELECT locale_id, type, value FROM locale_strings " +
41550:                         "WHERE locale_id=:id",
41550: 
82404:     addAddonMetadata_addon: "INSERT INTO addon VALUES (NULL, :id, :syncGUID, " +
82404:                             ":location, :version, :type, :internalName, " +
82404:                             ":updateURL, :updateKey, :optionsURL, " +
82404:                             ":optionsType, :aboutURL, " +
71220:                             ":iconURL, :icon64URL, :locale, :visible, :active, " +
51834:                             ":userDisabled, :appDisabled, :pendingUninstall, " +
51834:                             ":descriptor, :installDate, :updateDate, " +
51834:                             ":applyBackgroundUpdates, :bootstrap, :skinnable, " +
80772:                             ":size, :sourceURI, :releaseNotesURI, :softDisabled, " +
82652:                             ":isForeignInstall, :hasBinaryComponents, " +
81117:                             ":strictCompatibility)",
41550:     addAddonMetadata_addon_locale: "INSERT INTO addon_locale VALUES " +
41550:                                    "(:internal_id, :name, :locale)",
41550:     addAddonMetadata_locale: "INSERT INTO locale (name, description, creator, " +
41550:                              "homepageURL) VALUES (:name, :description, " +
41550:                              ":creator, :homepageURL)",
41550:     addAddonMetadata_strings: "INSERT INTO locale_strings VALUES (:locale, " +
41550:                               ":type, :value)",
41550:     addAddonMetadata_targetApplication: "INSERT INTO targetApplication VALUES " +
41550:                                         "(:internal_id, :id, :minVersion, " +
41550:                                         ":maxVersion)",
47133:     addAddonMetadata_targetPlatform: "INSERT INTO targetPlatform VALUES " +
47133:                                      "(:internal_id, :os, :abi)",
41550: 
41550:     clearVisibleAddons: "UPDATE addon SET visible=0 WHERE id=:id",
42093:     updateAddonActive: "UPDATE addon SET active=:active WHERE " +
41550:                        "internal_id=:internal_id",
41550: 
41550:     getActiveAddons: "SELECT " + FIELDS_ADDON + " FROM addon WHERE active=1 AND " +
41591:                      "type<>'theme' AND bootstrap=0",
41550:     getActiveTheme: "SELECT " + FIELDS_ADDON + " FROM addon WHERE " +
41550:                     "internalName=:internalName AND type='theme'",
42890:     getThemes: "SELECT " + FIELDS_ADDON + " FROM addon WHERE type='theme'",
41550: 
41550:     getAddonInLocation: "SELECT " + FIELDS_ADDON + " FROM addon WHERE id=:id " +
41550:                         "AND location=:location",
41550:     getAddons: "SELECT " + FIELDS_ADDON + " FROM addon",
41550:     getAddonsByType: "SELECT " + FIELDS_ADDON + " FROM addon WHERE type=:type",
41550:     getAddonsInLocation: "SELECT " + FIELDS_ADDON + " FROM addon WHERE " +
41550:                          "location=:location",
41550:     getInstallLocations: "SELECT DISTINCT location FROM addon",
41550:     getVisibleAddonForID: "SELECT " + FIELDS_ADDON + " FROM addon WHERE " +
41550:                           "visible=1 AND id=:id",
77970:     getVisibleAddonForInternalName: "SELECT " + FIELDS_ADDON + " FROM addon " +
46454:                                     "WHERE visible=1 AND internalName=:internalName",
41550:     getVisibleAddons: "SELECT " + FIELDS_ADDON + " FROM addon WHERE visible=1",
41550:     getVisibleAddonsWithPendingOperations: "SELECT " + FIELDS_ADDON + " FROM " +
41550:                                            "addon WHERE visible=1 " +
41550:                                            "AND (pendingUninstall=1 OR " +
41550:                                            "MAX(userDisabled,appDisabled)=active)",
82404:     getAddonBySyncGUID: "SELECT " + FIELDS_ADDON + " FROM addon " +
82404:                         "WHERE syncGUID=:syncGUID",
41550:     makeAddonVisible: "UPDATE addon SET visible=1 WHERE internal_id=:internal_id",
41550:     removeAddonMetadata: "DELETE FROM addon WHERE internal_id=:internal_id",
72311:     // Equates to active = visible && !userDisabled && !softDisabled &&
72311:     //                     !appDisabled && !pendingUninstall
41550:     setActiveAddons: "UPDATE addon SET active=MIN(visible, 1 - userDisabled, " +
72311:                      "1 - softDisabled, 1 - appDisabled, 1 - pendingUninstall)",
41550:     setAddonProperties: "UPDATE addon SET userDisabled=:userDisabled, " +
41550:                         "appDisabled=:appDisabled, " +
70084:                         "softDisabled=:softDisabled, " +
41586:                         "pendingUninstall=:pendingUninstall, " +
41586:                         "applyBackgroundUpdates=:applyBackgroundUpdates WHERE " +
41550:                         "internal_id=:internal_id",
71594:     setAddonDescriptor: "UPDATE addon SET descriptor=:descriptor WHERE " +
71594:                         "internal_id=:internal_id",
82404:     setAddonSyncGUID: "UPDATE addon SET syncGUID=:syncGUID WHERE " +
82404:                       "internal_id=:internal_id",
41550:     updateTargetApplications: "UPDATE targetApplication SET " +
41550:                               "minVersion=:minVersion, maxVersion=:maxVersion " +
41550:                               "WHERE addon_internal_id=:internal_id AND id=:id",
42885: 
42885:     createSavepoint: "SAVEPOINT 'default'",
42885:     releaseSavepoint: "RELEASE SAVEPOINT 'default'",
42885:     rollbackSavepoint: "ROLLBACK TO SAVEPOINT 'default'"
42885:   },
42885: 
82208:   get dbfileExists() {
82208:     delete this.dbfileExists;
82208:     return this.dbfileExists = this.dbfile.exists();
82208:   },
82208: 
42885:   /**
42885:    * Begins a new transaction in the database. Transactions may be nested. Data
42885:    * written by an inner transaction may be rolled back on its own. Rolling back
42885:    * an outer transaction will rollback all the changes made by inner
42885:    * transactions even if they were committed. No data is written to the disk
42885:    * until the outermost transaction is committed. Transactions can be started
42885:    * even when the database is not yet open in which case they will be started
42885:    * when the database is first opened.
42885:    */
42885:   beginTransaction: function XPIDB_beginTransaction() {
42885:     if (this.initialized)
42885:       this.getStatement("createSavepoint").execute();
42885:     this.transactionCount++;
42885:   },
42885: 
42885:   /**
42885:    * Commits the most recent transaction. The data may still be rolled back if
42885:    * an outer transaction is rolled back.
42885:    */
42885:   commitTransaction: function XPIDB_commitTransaction() {
42885:     if (this.transactionCount == 0) {
42885:       ERROR("Attempt to commit one transaction too many.");
42885:       return;
42885:     }
42885: 
42885:     if (this.initialized)
42885:       this.getStatement("releaseSavepoint").execute();
42885:     this.transactionCount--;
42885:   },
42885: 
42885:   /**
42885:    * Rolls back the most recent transaction. The database will return to its
42885:    * state when the transaction was started.
42885:    */
42885:   rollbackTransaction: function XPIDB_rollbackTransaction() {
42885:     if (this.transactionCount == 0) {
42885:       ERROR("Attempt to rollback one transaction too many.");
42885:       return;
42885:     }
42885: 
42885:     if (this.initialized) {
42885:       this.getStatement("rollbackSavepoint").execute();
42885:       this.getStatement("releaseSavepoint").execute();
42885:     }
42885:     this.transactionCount--;
41550:   },
41550: 
41550:   /**
57160:    * Attempts to open the database file. If it fails it will try to delete the
57160:    * existing file and create an empty database. If that fails then it will
57160:    * open an in-memory database that can be used during this session.
57160:    *
57160:    * @param  aDBFile
57160:    *         The nsIFile to open
57160:    * @return the mozIStorageConnection for the database
57160:    */
57160:   openDatabaseFile: function XPIDB_openDatabaseFile(aDBFile) {
57160:     LOG("Opening database");
57160:     let connection = null;
57160: 
57160:     // Attempt to open the database
57160:     try {
57160:       connection = Services.storage.openUnsharedDatabase(aDBFile);
82208:       this.dbfileExists = true;
57160:     }
57160:     catch (e) {
57401:       ERROR("Failed to open database (1st attempt)", e);
57160:       try {
57160:         aDBFile.remove(true);
57160:       }
57160:       catch (e) {
57401:         ERROR("Failed to remove database that could not be opened", e);
57160:       }
57160:       try {
57160:         connection = Services.storage.openUnsharedDatabase(aDBFile);
57160:       }
57160:       catch (e) {
57401:         ERROR("Failed to open database (2nd attempt)", e);
57160: 
57160:         // If we have got here there seems to be no way to open the real
57160:         // database, instead open a temporary memory database so things will
57160:         // work for this session
57160:         return Services.storage.openSpecialDatabase("memory");
57160:       }
57160:     }
57160: 
57160:     connection.executeSimpleSQL("PRAGMA synchronous = FULL");
57160:     connection.executeSimpleSQL("PRAGMA locking_mode = EXCLUSIVE");
57160: 
57160:     return connection;
57160:   },
57160: 
57160:   /**
41550:    * Opens a new connection to the database file.
41550:    *
57160:    * @param  aRebuildOnError
57160:    *         A boolean indicating whether add-on information should be loaded
57160:    *         from the install locations if the database needs to be rebuilt.
57160:    * @return the migration data from the database if it was an old schema or
57160:    *         null otherwise.
57160:    */
82208:   openConnection: function XPIDB_openConnection(aRebuildOnError, aForceOpen) {
82208:     delete this.connection;
82208: 
82208:     if (!aForceOpen && !this.dbfileExists) {
82208:       this.connection = null;
82208:       return {};
82208:     }
82208: 
82048:     this.initialized = true;
82208: 
82208:     this.connection = this.openDatabaseFile(this.dbfile);
57160: 
57160:     let migrateData = null;
57160:     // If the database was corrupt or missing then the new blank database will
57160:     // have a schema version of 0.
57160:     let schemaVersion = this.connection.schemaVersion;
57160:     if (schemaVersion != DB_SCHEMA) {
57160:       // A non-zero schema version means that a schema has been successfully
57160:       // created in the database in the past so we might be able to get useful
57160:       // information from it
57160:       if (schemaVersion != 0) {
57160:         LOG("Migrating data from schema " + schemaVersion);
57160:         migrateData = this.getMigrateDataFromDatabase();
57160: 
57160:         // Delete the existing database
57160:         this.connection.close();
57160:         try {
82208:           if (this.dbfileExists)
82208:             this.dbfile.remove(true);
57160: 
57160:           // Reopen an empty database
82208:           this.connection = this.openDatabaseFile(this.dbfile);
57160:         }
57160:         catch (e) {
57401:           ERROR("Failed to remove old database", e);
57160:           // If the file couldn't be deleted then fall back to an in-memory
57160:           // database
57160:           this.connection = Services.storage.openSpecialDatabase("memory");
57160:         }
57160:       }
57160:       else if (Prefs.getIntPref(PREF_DB_SCHEMA, 0) == 0) {
57160:         // Only migrate data from the RDF if we haven't done it before
57160:         migrateData = this.getMigrateDataFromRDF();
57160:       }
57160: 
57160:       // At this point the database should be completely empty
57160:       this.createSchema();
57160: 
57160:       if (aRebuildOnError) {
57160:         let activeBundles = this.getActiveBundles();
57160:         WARN("Rebuilding add-ons database from installed extensions.");
57160:         this.beginTransaction();
57160:         try {
57160:           let state = XPIProvider.getInstallLocationStates();
70084:           XPIProvider.processFileChanges(state, {}, false, undefined, undefined,
70084:                                          migrateData, activeBundles)
57160:           // Make sure to update the active add-ons and add-ons list on shutdown
57160:           Services.prefs.setBoolPref(PREF_PENDING_OPERATIONS, true);
57160:           this.commitTransaction();
57160:         }
57160:         catch (e) {
57401:           ERROR("Error processing file changes", e);
57160:           this.rollbackTransaction();
57160:         }
57160:       }
57160:     }
57160: 
57160:     // If the database connection has a file open then it has the right schema
57160:     // by now so make sure the preferences reflect that. If not then there is
57160:     // an in-memory database open which means a problem opening and deleting the
57160:     // real database, clear the schema preference to force trying to load the
57160:     // database on the next startup
57160:     if (this.connection.databaseFile) {
57160:       Services.prefs.setIntPref(PREF_DB_SCHEMA, DB_SCHEMA);
57160:     }
57160:     else {
57160:       try {
57160:         Services.prefs.clearUserPref(PREF_DB_SCHEMA);
57160:       }
57160:       catch (e) {
57160:         // The preference may not be defined
57160:       }
57160:     }
57160:     Services.prefs.savePrefFile(null);
42885: 
42885:     // Begin any pending transactions
42885:     for (let i = 0; i < this.transactionCount; i++)
42885:       this.connection.executeSimpleSQL("SAVEPOINT 'default'");
57160:     return migrateData;
57160:   },
57160: 
57160:   /**
57160:    * A lazy getter for the database connection.
57160:    */
57160:   get connection() {
57160:     this.openConnection(true);
42885:     return this.connection;
41550:   },
41550: 
41550:   /**
57160:    * Gets the list of file descriptors of active extension directories or XPI
57160:    * files from the add-ons list. This must be loaded from disk since the
57160:    * directory service gives no easy way to get both directly. This list doesn't
57160:    * include themes as preferences already say which theme is currently active
57160:    *
57160:    * @return an array of persisitent descriptors for the directories
57160:    */
57160:   getActiveBundles: function XPIDB_getActiveBundles() {
57160:     let bundles = [];
57160: 
57160:     let addonsList = FileUtils.getFile(KEY_PROFILEDIR, [FILE_XPI_ADDONS_LIST],
57160:                                        true);
57160: 
57160:     let iniFactory = Cc["@mozilla.org/xpcom/ini-parser-factory;1"].
57160:                      getService(Ci.nsIINIParserFactory);
57160:     let parser = iniFactory.createINIParser(addonsList);
57160: 
57160:     let keys = parser.getKeys("ExtensionDirs");
57160: 
57160:     while (keys.hasMore())
57160:       bundles.push(parser.getString("ExtensionDirs", keys.getNext()));
57160: 
57160:     // Also include the list of active bootstrapped extensions
57160:     for (let id in XPIProvider.bootstrappedAddons)
57160:       bundles.push(XPIProvider.bootstrappedAddons[id].descriptor);
57160: 
57160:     return bundles;
57123:   },
57123: 
57123:   /**
57160:    * Retrieves migration data from the old extensions.rdf database.
57117:    *
41550:    * @return an object holding information about what add-ons were previously
57160:    *         userDisabled and any updated compatibility information
57160:    */
57160:   getMigrateDataFromRDF: function XPIDB_getMigrateDataFromRDF(aDbWasMissing) {
41550:     let migrateData = {};
41550: 
41550:     // Migrate data from extensions.rdf
41550:     let rdffile = FileUtils.getFile(KEY_PROFILEDIR, [FILE_OLD_DATABASE], true);
41550:     if (rdffile.exists()) {
82208:       LOG("Migrating data from extensions.rdf");
41590:       let ds = gRDF.GetDataSourceBlocking(Services.io.newFileURI(rdffile).spec);
41590:       let root = Cc["@mozilla.org/rdf/container;1"].
41590:                  createInstance(Ci.nsIRDFContainer);
41590:       root.Init(ds, gRDF.GetResource(RDFURI_ITEM_ROOT));
41590:       let elements = root.GetElements();
41590:       while (elements.hasMoreElements()) {
41590:         let source = elements.getNext().QueryInterface(Ci.nsIRDFResource);
41590: 
41590:         let location = getRDFProperty(ds, source, "installLocation");
41590:         if (location) {
41590:           if (!(location in migrateData))
41590:             migrateData[location] = {};
41550:           let id = source.ValueUTF8.substring(PREFIX_ITEM_URI.length);
41590:           migrateData[location][id] = {
47839:             version: getRDFProperty(ds, source, "version"),
41590:             userDisabled: false,
41590:             targetApplications: []
41590:           }
41590: 
41590:           let disabled = getRDFProperty(ds, source, "userDisabled");
41590:           if (disabled == "true" || disabled == "needs-disable")
41590:             migrateData[location][id].userDisabled = true;
41590: 
41591:           let targetApps = ds.GetTargets(source, EM_R("targetApplication"),
41591:                                          true);
41590:           while (targetApps.hasMoreElements()) {
41591:             let targetApp = targetApps.getNext()
41591:                                       .QueryInterface(Ci.nsIRDFResource);
41590:             let appInfo = {
55436:               id: getRDFProperty(ds, targetApp, "id")
41590:             };
55436: 
55436:             let minVersion = getRDFProperty(ds, targetApp, "updatedMinVersion");
55436:             if (minVersion) {
55436:               appInfo.minVersion = minVersion;
55436:               appInfo.maxVersion = getRDFProperty(ds, targetApp, "updatedMaxVersion");
55436:             }
55436:             else {
55436:               appInfo.minVersion = getRDFProperty(ds, targetApp, "minVersion");
55436:               appInfo.maxVersion = getRDFProperty(ds, targetApp, "maxVersion");
55436:             }
41590:             migrateData[location][id].targetApplications.push(appInfo);
41590:           }
41590:         }
41590:       }
41550:     }
57160: 
57160:     return migrateData;
57160:   },
57160: 
57160:   /**
57160:    * Retrieves migration data from a database that has an older or newer schema.
57160:    *
57160:    * @return an object holding information about what add-ons were previously
57160:    *         userDisabled and any updated compatibility information
57160:    */
57160:   getMigrateDataFromDatabase: function XPIDB_getMigrateDataFromDatabase() {
57160:     let migrateData = {};
57160: 
41550:     // Attempt to migrate data from a different (even future!) version of the
41550:     // database
41550:     try {
82579:       var stmt = this.connection.createStatement("PRAGMA table_info(addon)");
82579: 
82579:       const REQUIRED = ["internal_id", "id", "location", "userDisabled",
82579:                         "installDate", "version"];
82579: 
82579:       let reqCount = 0;
82579:       let props = [];
82579:       for (let row in resultRows(stmt)) {
82579:         if (REQUIRED.indexOf(row.name) != -1) {
82579:           reqCount++;
82579:           props.push(row.name);
82579:         }
82579:         else if (DB_METADATA.indexOf(row.name) != -1) {
82579:           props.push(row.name);
82579:         }
82579:         else if (DB_BOOL_METADATA.indexOf(row.name) != -1) {
82579:           props.push(row.name);
82579:         }
82579:       }
82579: 
82579:       if (reqCount < REQUIRED.length) {
70084:         ERROR("Unable to read anything useful from the database");
70084:         return migrateData;
70084:       }
82579:       stmt.finalize();
82579: 
82579:       stmt = this.connection.createStatement("SELECT " + props.join(",") + " FROM addon");
41550:       for (let row in resultRows(stmt)) {
41550:         if (!(row.location in migrateData))
41550:           migrateData[row.location] = {};
82579:         let addonData = {
47133:           targetApplications: []
82579:         }
82579:         migrateData[row.location][row.id] = addonData;
82579: 
82579:         props.forEach(function(aProp) {
82579:           if (DB_BOOL_METADATA.indexOf(aProp) != -1)
82579:             addonData[aProp] = row[aProp] == 1;
82579:           else
82579:             addonData[aProp] = row[aProp];
82579:         })
41550:       }
47133: 
47133:       var taStmt = this.connection.createStatement("SELECT id, minVersion, " +
47133:                                                    "maxVersion FROM " +
47133:                                                    "targetApplication WHERE " +
47133:                                                    "addon_internal_id=:internal_id");
47133: 
47133:       for (let location in migrateData) {
47133:         for (let id in migrateData[location]) {
47133:           taStmt.params.internal_id = migrateData[location][id].internal_id;
47133:           delete migrateData[location][id].internal_id;
47133:           for (let row in resultRows(taStmt)) {
47133:             migrateData[location][id].targetApplications.push({
47133:               id: row.id,
47133:               minVersion: row.minVersion,
47133:               maxVersion: row.maxVersion
47133:             });
47133:           }
47133:         }
47133:       }
41550:     }
41550:     catch (e) {
41550:       // An error here means the schema is too different to read
57401:       ERROR("Error migrating data", e);
41550:     }
41550:     finally {
47133:       if (taStmt)
47133:         taStmt.finalize();
47133:       if (stmt)
41550:         stmt.finalize();
41550:     }
41550: 
41550:     return migrateData;
41550:   },
41550: 
41550:   /**
41550:    * Shuts down the database connection and releases all cached objects.
41550:    */
51520:   shutdown: function XPIDB_shutdown(aCallback) {
41550:     if (this.initialized) {
41550:       for each (let stmt in this.statementCache)
41550:         stmt.finalize();
41550:       this.statementCache = {};
41550:       this.addonCache = [];
42885: 
42885:       if (this.transactionCount > 0) {
42885:         ERROR(this.transactionCount + " outstanding transactions, rolling back.");
42885:         while (this.transactionCount > 0)
42885:           this.rollbackTransaction();
42885:       }
42885: 
41550:       this.initialized = false;
51520:       let connection = this.connection;
41550:       delete this.connection;
41550: 
41550:       // Re-create the connection smart getter to allow the database to be
41550:       // re-loaded during testing.
41550:       this.__defineGetter__("connection", function() {
57160:         this.openConnection(true);
57160:         return this.connection;
41550:       });
51520: 
51520:       connection.asyncClose(aCallback);
51520:     }
51520:     else {
51520:       if (aCallback)
51520:         aCallback();
41550:     }
41550:   },
41550: 
41550:   /**
41550:    * Gets a cached statement or creates a new statement if it doesn't already
41550:    * exist.
41550:    *
41550:    * @param  key
41550:    *         A unique key to reference the statement
41584:    * @param  aSql
41550:    *         An optional SQL string to use for the query, otherwise a
41550:    *         predefined sql string for the key will be used.
41550:    * @return a mozIStorageStatement for the passed SQL
41550:    */
41584:   getStatement: function XPIDB_getStatement(aKey, aSql) {
41584:     if (aKey in this.statementCache)
41584:       return this.statementCache[aKey];
41584:     if (!aSql)
41584:       aSql = this.statements[aKey];
41550: 
41550:     try {
41584:       return this.statementCache[aKey] = this.connection.createStatement(aSql);
41550:     }
41550:     catch (e) {
41584:       ERROR("Error creating statement " + aKey + " (" + aSql + ")");
41550:       throw e;
41550:     }
41550:   },
41550: 
41550:   /**
41550:    * Creates the schema in the database.
41550:    */
41550:   createSchema: function XPIDB_createSchema() {
41550:     LOG("Creating database schema");
42885:     this.beginTransaction();
42885: 
42885:     // Any errors in here should rollback the transaction
42885:     try {
41550:       this.connection.createTable("addon",
41550:                                   "internal_id INTEGER PRIMARY KEY AUTOINCREMENT, " +
82404:                                   "id TEXT, syncGUID TEXT, " +
82404:                                   "location TEXT, version TEXT, " +
41550:                                   "type TEXT, internalName TEXT, updateURL TEXT, " +
71220:                                   "updateKey TEXT, optionsURL TEXT, " +
71220:                                   "optionsType TEXT, aboutURL TEXT, iconURL TEXT, " +
71220:                                   "icon64URL TEXT, defaultLocale INTEGER, " +
41550:                                   "visible INTEGER, active INTEGER, " +
41550:                                   "userDisabled INTEGER, appDisabled INTEGER, " +
41550:                                   "pendingUninstall INTEGER, descriptor TEXT, " +
41550:                                   "installDate INTEGER, updateDate INTEGER, " +
41586:                                   "applyBackgroundUpdates INTEGER, " +
47133:                                   "bootstrap INTEGER, skinnable INTEGER, " +
47133:                                   "size INTEGER, sourceURI TEXT, " +
70084:                                   "releaseNotesURI TEXT, softDisabled INTEGER, " +
82652:                                   "isForeignInstall INTEGER, " +
81116:                                   "hasBinaryComponents INTEGER, " +
81117:                                   "strictCompatibility INTEGER, " +
82404:                                   "UNIQUE (id, location), " +
82404:                                   "UNIQUE (syncGUID)");
41550:       this.connection.createTable("targetApplication",
41550:                                   "addon_internal_id INTEGER, " +
41550:                                   "id TEXT, minVersion TEXT, maxVersion TEXT, " +
41550:                                   "UNIQUE (addon_internal_id, id)");
47133:       this.connection.createTable("targetPlatform",
47133:                                   "addon_internal_id INTEGER, " +
47133:                                   "os, abi TEXT, " +
47133:                                   "UNIQUE (addon_internal_id, os, abi)");
41550:       this.connection.createTable("addon_locale",
41550:                                   "addon_internal_id INTEGER, "+
41550:                                   "locale TEXT, locale_id INTEGER, " +
41550:                                   "UNIQUE (addon_internal_id, locale)");
41550:       this.connection.createTable("locale",
41550:                                   "id INTEGER PRIMARY KEY AUTOINCREMENT, " +
41550:                                   "name TEXT, description TEXT, creator TEXT, " +
41550:                                   "homepageURL TEXT");
41550:       this.connection.createTable("locale_strings",
41550:                                   "locale_id INTEGER, type TEXT, value TEXT");
41550:       this.connection.executeSimpleSQL("CREATE TRIGGER delete_addon AFTER DELETE " +
41550:         "ON addon BEGIN " +
41550:         "DELETE FROM targetApplication WHERE addon_internal_id=old.internal_id; " +
47133:         "DELETE FROM targetPlatform WHERE addon_internal_id=old.internal_id; " +
41550:         "DELETE FROM addon_locale WHERE addon_internal_id=old.internal_id; " +
41550:         "DELETE FROM locale WHERE id=old.defaultLocale; " +
41550:         "END");
41550:       this.connection.executeSimpleSQL("CREATE TRIGGER delete_addon_locale AFTER " +
41550:         "DELETE ON addon_locale WHEN NOT EXISTS " +
41550:         "(SELECT * FROM addon_locale WHERE locale_id=old.locale_id) BEGIN " +
41550:         "DELETE FROM locale WHERE id=old.locale_id; " +
41550:         "END");
41550:       this.connection.executeSimpleSQL("CREATE TRIGGER delete_locale AFTER " +
41550:         "DELETE ON locale BEGIN " +
41550:         "DELETE FROM locale_strings WHERE locale_id=old.id; " +
41550:         "END");
41550:       this.connection.schemaVersion = DB_SCHEMA;
42885:       this.commitTransaction();
42885:     }
42885:     catch (e) {
57401:       ERROR("Failed to create database schema", e);
42885:       logSQLError(this.connection.lastError, this.connection.lastErrorString);
42885:       this.rollbackTransaction();
54271:       this.connection.close();
54271:       this.connection = null;
42885:       throw e;
42885:     }
41550:   },
41550: 
41550:   /**
41550:    * Synchronously reads the multi-value locale strings for a locale
41550:    *
41584:    * @param  aLocale
41550:    *         The locale object to read into
41550:    */
41584:   _readLocaleStrings: function XPIDB__readLocaleStrings(aLocale) {
41550:     let stmt = this.getStatement("_readLocaleStrings");
41550: 
42870:     stmt.params.id = aLocale.id;
41550:     for (let row in resultRows(stmt)) {
42870:       if (!(row.type in aLocale))
41584:         aLocale[row.type] = [];
41584:       aLocale[row.type].push(row.value);
41550:     }
41550:   },
41550: 
41550:   /**
41550:    * Synchronously reads the locales for an add-on
41550:    *
41584:    * @param  aAddon
41550:    *         The DBAddonInternal to read the locales for
41550:    * @return the array of locales
41550:    */
41584:   _getLocales: function XPIDB__getLocales(aAddon) {
41550:     let stmt = this.getStatement("_getLocales");
41550: 
41550:     let locales = [];
41584:     stmt.params.internal_id = aAddon._internal_id;
41550:     for (let row in resultRows(stmt)) {
41550:       let locale = {
41550:         id: row.id,
41550:         locales: [row.locale]
41550:       };
41550:       copyProperties(row, PROP_LOCALE_SINGLE, locale);
41550:       locales.push(locale);
41550:     }
41584:     locales.forEach(function(aLocale) {
41584:       this._readLocaleStrings(aLocale);
41550:     }, this);
41550:     return locales;
41550:   },
41550: 
41550:   /**
41550:    * Synchronously reads the default locale for an add-on
41550:    *
41584:    * @param  aAddon
41550:    *         The DBAddonInternal to read the default locale for
41550:    * @return the default locale for the add-on
41550:    * @throws if the database does not contain the default locale information
41550:    */
41584:   _getDefaultLocale: function XPIDB__getDefaultLocale(aAddon) {
41550:     let stmt = this.getStatement("_getDefaultLocale");
41550: 
41584:     stmt.params.id = aAddon._defaultLocale;
42885:     if (!stepStatement(stmt))
41584:       throw new Error("Missing default locale for " + aAddon.id);
41550:     let locale = copyProperties(stmt.row, PROP_LOCALE_SINGLE);
41584:     locale.id = aAddon._defaultLocale;
41550:     stmt.reset();
41550:     this._readLocaleStrings(locale);
41550:     return locale;
41550:   },
41550: 
41550:   /**
41550:    * Synchronously reads the target application entries for an add-on
41550:    *
41584:    * @param  aAddon
41550:    *         The DBAddonInternal to read the target applications for
41550:    * @return an array of target applications
41550:    */
41584:   _getTargetApplications: function XPIDB__getTargetApplications(aAddon) {
41550:     let stmt = this.getStatement("_getTargetApplications");
41550: 
41584:     stmt.params.internal_id = aAddon._internal_id;
41550:     return [copyProperties(row, PROP_TARGETAPP) for each (row in resultRows(stmt))];
41550:   },
41550: 
41550:   /**
47133:    * Synchronously reads the target platform entries for an add-on
47133:    *
47133:    * @param  aAddon
47133:    *         The DBAddonInternal to read the target platforms for
47133:    * @return an array of target platforms
47133:    */
47133:   _getTargetPlatforms: function XPIDB__getTargetPlatforms(aAddon) {
47133:     let stmt = this.getStatement("_getTargetPlatforms");
47133: 
47133:     stmt.params.internal_id = aAddon._internal_id;
48386:     return [copyProperties(row, ["os", "abi"]) for each (row in resultRows(stmt))];
47133:   },
47133: 
47133:   /**
41550:    * Synchronously makes a DBAddonInternal from a storage row or returns one
41584:    * from the cache.
41550:    *
41584:    * @param  aRow
41550:    *         The storage row to make the DBAddonInternal from
41550:    * @return a DBAddonInternal
41550:    */
41584:   makeAddonFromRow: function XPIDB_makeAddonFromRow(aRow) {
41584:     if (this.addonCache[aRow.internal_id]) {
41584:       let addon = this.addonCache[aRow.internal_id].get();
41550:       if (addon)
41550:         return addon;
41550:     }
41550: 
41550:     let addon = new DBAddonInternal();
41584:     addon._internal_id = aRow.internal_id;
41584:     addon._installLocation = XPIProvider.installLocationsByName[aRow.location];
41584:     addon._descriptor = aRow.descriptor;
47133:     addon._defaultLocale = aRow.defaultLocale;
41584:     copyProperties(aRow, PROP_METADATA, addon);
47133:     copyProperties(aRow, DB_METADATA, addon);
47133:     DB_BOOL_METADATA.forEach(function(aProp) {
41584:       addon[aProp] = aRow[aProp] != 0;
41550:     });
60290:     try {
60290:       addon._sourceBundle = addon._installLocation.getLocationForID(addon.id);
60290:     }
60290:     catch (e) {
60290:       // An exception will be thrown if the add-on appears in the database but
60290:       // not on disk. In general this should only happen during startup as
60290:       // this change is being detected.
60290:     }
60290: 
41584:     this.addonCache[aRow.internal_id] = Components.utils.getWeakReference(addon);
41550:     return addon;
41550:   },
41550: 
41550:   /**
41550:    * Asynchronously fetches additional metadata for a DBAddonInternal.
41550:    *
41584:    * @param  aAddon
41550:    *         The DBAddonInternal
41584:    * @param  aCallback
41550:    *         The callback to call when the metadata is completely retrieved
41550:    */
42870:   fetchAddonMetadata: function XPIDB_fetchAddonMetadata(aAddon) {
41584:     function readLocaleStrings(aLocale, aCallback) {
41550:       let stmt = XPIDatabase.getStatement("_readLocaleStrings");
41550: 
41584:       stmt.params.id = aLocale.id;
41550:       stmt.executeAsync({
41584:         handleResult: function(aResults) {
41550:           let row = null;
41584:           while (row = aResults.getNextRow()) {
41550:             let type = row.getResultByName("type");
41584:             if (!(type in aLocale))
41584:               aLocale[type] = [];
41584:             aLocale[type].push(row.getResultByName("value"));
41550:           }
41550:         },
41550: 
41550:         handleError: asyncErrorLogger,
41550: 
41584:         handleCompletion: function(aReason) {
41584:           aCallback();
41550:         }
41550:       });
41550:     }
41550: 
41550:     function readDefaultLocale() {
41584:       delete aAddon.defaultLocale;
41550:       let stmt = XPIDatabase.getStatement("_getDefaultLocale");
41550: 
41584:       stmt.params.id = aAddon._defaultLocale;
41550:       stmt.executeAsync({
41584:         handleResult: function(aResults) {
41584:           aAddon.defaultLocale = copyRowProperties(aResults.getNextRow(),
41550:                                                    PROP_LOCALE_SINGLE);
41584:           aAddon.defaultLocale.id = aAddon._defaultLocale;
41550:         },
41550: 
41550:         handleError: asyncErrorLogger,
41550: 
41584:         handleCompletion: function(aReason) {
41584:           if (aAddon.defaultLocale) {
41584:             readLocaleStrings(aAddon.defaultLocale, readLocales);
41550:           }
41550:           else {
41584:             ERROR("Missing default locale for " + aAddon.id);
41550:             readLocales();
41550:           }
41550:         }
41550:       });
41550:     }
41550: 
41550:     function readLocales() {
41584:       delete aAddon.locales;
41584:       aAddon.locales = [];
41550:       let stmt = XPIDatabase.getStatement("_getLocales");
41550: 
41584:       stmt.params.internal_id = aAddon._internal_id;
41550:       stmt.executeAsync({
41584:         handleResult: function(aResults) {
41550:           let row = null;
41584:           while (row = aResults.getNextRow()) {
41550:             let locale = {
41550:               id: row.getResultByName("id"),
41550:               locales: [row.getResultByName("locale")]
41550:             };
41550:             copyRowProperties(row, PROP_LOCALE_SINGLE, locale);
41584:             aAddon.locales.push(locale);
41550:           }
41550:         },
41550: 
41550:         handleError: asyncErrorLogger,
41550: 
41584:         handleCompletion: function(aReason) {
41550:           let pos = 0;
41550:           function readNextLocale() {
41584:             if (pos < aAddon.locales.length)
41584:               readLocaleStrings(aAddon.locales[pos++], readNextLocale);
41550:             else
41550:               readTargetApplications();
41550:           }
41550: 
41550:           readNextLocale();
41550:         }
41550:       });
41550:     }
41550: 
41550:     function readTargetApplications() {
41584:       delete aAddon.targetApplications;
41584:       aAddon.targetApplications = [];
41550:       let stmt = XPIDatabase.getStatement("_getTargetApplications");
41550: 
41584:       stmt.params.internal_id = aAddon._internal_id;
41550:       stmt.executeAsync({
41584:         handleResult: function(aResults) {
41550:           let row = null;
41584:           while (row = aResults.getNextRow())
41584:             aAddon.targetApplications.push(copyRowProperties(row, PROP_TARGETAPP));
41550:         },
41550: 
41550:         handleError: asyncErrorLogger,
41550: 
41584:         handleCompletion: function(aReason) {
47133:           readTargetPlatforms();
47133:         }
47133:       });
47133:     }
47133: 
47133:     function readTargetPlatforms() {
47133:       delete aAddon.targetPlatforms;
47133:       aAddon.targetPlatforms = [];
47133:       let stmt = XPIDatabase.getStatement("_getTargetPlatforms");
47133: 
47133:       stmt.params.internal_id = aAddon._internal_id;
47133:       stmt.executeAsync({
47133:         handleResult: function(aResults) {
47133:           let row = null;
47133:           while (row = aResults.getNextRow())
47133:             aAddon.targetPlatforms.push(copyRowProperties(row, ["os", "abi"]));
47133:         },
47133: 
47133:         handleError: asyncErrorLogger,
47133: 
47133:         handleCompletion: function(aReason) {
42870:           let callbacks = aAddon._pendingCallbacks;
42870:           delete aAddon._pendingCallbacks;
42870:           callbacks.forEach(function(aCallback) {
41584:             aCallback(aAddon);
42870:           });
41550:         }
41550:       });
41550:     }
41550: 
41550:     readDefaultLocale();
41550:   },
41550: 
41550:   /**
41550:    * Synchronously makes a DBAddonInternal from a mozIStorageRow or returns one
41550:    * from the cache.
41550:    *
41584:    * @param  aRow
41550:    *         The mozIStorageRow to make the DBAddonInternal from
41550:    * @return a DBAddonInternal
41550:    */
42870:   makeAddonFromRowAsync: function XPIDB_makeAddonFromRowAsync(aRow, aCallback) {
41584:     let internal_id = aRow.getResultByName("internal_id");
41550:     if (this.addonCache[internal_id]) {
41550:       let addon = this.addonCache[internal_id].get();
42870:       if (addon) {
42870:         // If metadata is still pending for this instance add our callback to
42870:         // the list to be called when complete, otherwise pass the addon to
42870:         // our callback
42870:         if ("_pendingCallbacks" in addon)
42870:           addon._pendingCallbacks.push(aCallback);
42870:         else
42870:           aCallback(addon);
42870:         return;
42870:       }
41550:     }
41550: 
41550:     let addon = new DBAddonInternal();
41550:     addon._internal_id = internal_id;
41584:     let location = aRow.getResultByName("location");
41550:     addon._installLocation = XPIProvider.installLocationsByName[location];
41584:     addon._descriptor = aRow.getResultByName("descriptor");
41584:     copyRowProperties(aRow, PROP_METADATA, addon);
41584:     addon._defaultLocale = aRow.getResultByName("defaultLocale");
47133:     copyRowProperties(aRow, DB_METADATA, addon);
47133:     DB_BOOL_METADATA.forEach(function(aProp) {
41584:       addon[aProp] = aRow.getResultByName(aProp) != 0;
41550:     });
60290:     try {
60290:       addon._sourceBundle = addon._installLocation.getLocationForID(addon.id);
60290:     }
60290:     catch (e) {
60290:       // An exception will be thrown if the add-on appears in the database but
60290:       // not on disk. In general this should only happen during startup as
60290:       // this change is being detected.
60290:     }
42870: 
41550:     this.addonCache[internal_id] = Components.utils.getWeakReference(addon);
42870:     addon._pendingCallbacks = [aCallback];
42870:     this.fetchAddonMetadata(addon);
41550:   },
41550: 
41550:   /**
41550:    * Synchronously reads all install locations known about by the database. This
41550:    * is often a a subset of the total install locations when not all have
41550:    * installed add-ons, occasionally a superset when an install location no
41550:    * longer exists.
41550:    *
41550:    * @return  an array of names of install locations
41550:    */
41550:   getInstallLocations: function XPIDB_getInstallLocations() {
82208:     if (!this.connection)
82208:       return [];
82208: 
41550:     let stmt = this.getStatement("getInstallLocations");
41550: 
41550:     return [row.location for each (row in resultRows(stmt))];
41550:   },
41550: 
41550:   /**
41550:    * Synchronously reads all the add-ons in a particular install location.
41550:    *
41550:    * @param  location
41550:    *         The name of the install location
41550:    * @return an array of DBAddonInternals
41550:    */
41584:   getAddonsInLocation: function XPIDB_getAddonsInLocation(aLocation) {
82208:     if (!this.connection)
82208:       return [];
82208: 
41550:     let stmt = this.getStatement("getAddonsInLocation");
41550: 
41584:     stmt.params.location = aLocation;
41550:     return [this.makeAddonFromRow(row) for each (row in resultRows(stmt))];
41550:   },
41550: 
41550:   /**
41550:    * Asynchronously gets an add-on with a particular ID in a particular
41550:    * install location.
41550:    *
41584:    * @param  aId
41550:    *         The ID of the add-on to retrieve
41584:    * @param  aLocation
41550:    *         The name of the install location
41584:    * @param  aCallback
41550:    *         A callback to pass the DBAddonInternal to
41550:    */
41584:   getAddonInLocation: function XPIDB_getAddonInLocation(aId, aLocation, aCallback) {
82208:     if (!this.connection) {
82208:       aCallback(null);
82208:       return;
82208:     }
82208: 
41550:     let stmt = this.getStatement("getAddonInLocation");
41550: 
41584:     stmt.params.id = aId;
41584:     stmt.params.location = aLocation;
42870:     stmt.executeAsync(new AsyncAddonListCallback(function(aAddons) {
42870:       if (aAddons.length == 0) {
41584:         aCallback(null);
42870:         return;
42870:       }
42870:       // This should never happen but indicates invalid data in the database if
42870:       // it does
42870:       if (aAddons.length > 1)
42870:         ERROR("Multiple addons with ID " + aId + " found in location " + aLocation);
42870:       aCallback(aAddons[0]);
42870:     }));
41550:   },
41550: 
41550:   /**
41550:    * Asynchronously gets the add-on with an ID that is visible.
41550:    *
41584:    * @param  aId
41550:    *         The ID of the add-on to retrieve
41584:    * @param  aCallback
41550:    *         A callback to pass the DBAddonInternal to
41550:    */
41584:   getVisibleAddonForID: function XPIDB_getVisibleAddonForID(aId, aCallback) {
82208:     if (!this.connection) {
82208:       aCallback(null);
82208:       return;
82208:     }
82208: 
41550:     let stmt = this.getStatement("getVisibleAddonForID");
41550: 
41584:     stmt.params.id = aId;
42870:     stmt.executeAsync(new AsyncAddonListCallback(function(aAddons) {
42870:       if (aAddons.length == 0) {
41584:         aCallback(null);
42870:         return;
42870:       }
42870:       // This should never happen but indicates invalid data in the database if
42870:       // it does
42870:       if (aAddons.length > 1)
42870:         ERROR("Multiple visible addons with ID " + aId + " found");
42870:       aCallback(aAddons[0]);
42870:     }));
41550:   },
41550: 
41550:   /**
41550:    * Asynchronously gets the visible add-ons, optionally restricting by type.
41550:    *
41584:    * @param  aTypes
41550:    *         An array of types to include or null to include all types
41584:    * @param  aCallback
41550:    *         A callback to pass the array of DBAddonInternals to
41550:    */
41584:   getVisibleAddons: function XPIDB_getVisibleAddons(aTypes, aCallback) {
82208:     if (!this.connection) {
82208:       aCallback([]);
82208:       return;
82208:     }
82208: 
41550:     let stmt = null;
41584:     if (!aTypes || aTypes.length == 0) {
41550:       stmt = this.getStatement("getVisibleAddons");
41550:     }
41550:     else {
77614:       let sql = "SELECT " + FIELDS_ADDON + " FROM addon WHERE visible=1 AND " +
77614:                 "type IN (";
41584:       for (let i = 1; i <= aTypes.length; i++) {
41550:         sql += "?" + i;
41584:         if (i < aTypes.length)
41550:           sql += ",";
41550:       }
41550:       sql += ")";
41550: 
41550:       // Note that binding to index 0 sets the value for the ?1 parameter
41584:       stmt = this.getStatement("getVisibleAddons_" + aTypes.length, sql);
41584:       for (let i = 0; i < aTypes.length; i++)
64479:         stmt.bindByIndex(i, aTypes[i]);
41550:     }
41550: 
42870:     stmt.executeAsync(new AsyncAddonListCallback(aCallback));
41550:   },
41550: 
41550:   /**
41550:    * Synchronously gets all add-ons of a particular type.
41550:    *
41584:    * @param  aType
41550:    *         The type of add-on to retrieve
41550:    * @return an array of DBAddonInternals
41550:    */
41584:   getAddonsByType: function XPIDB_getAddonsByType(aType) {
82208:     if (!this.connection)
82208:       return [];
82208: 
41550:     let stmt = this.getStatement("getAddonsByType");
41550: 
41584:     stmt.params.type = aType;
41550:     return [this.makeAddonFromRow(row) for each (row in resultRows(stmt))];;
41550:   },
41550: 
41550:   /**
46454:    * Synchronously gets an add-on with a particular internalName.
46454:    *
46454:    * @param  aInternalName
46454:    *         The internalName of the add-on to retrieve
46454:    * @return a DBAddonInternal
46454:    */
46454:   getVisibleAddonForInternalName: function XPIDB_getVisibleAddonForInternalName(aInternalName) {
82208:     if (!this.connection)
82208:       return null;
82208: 
77970:     let stmt = this.getStatement("getVisibleAddonForInternalName");
46454: 
46454:     let addon = null;
46454:     stmt.params.internalName = aInternalName;
46454: 
46454:     if (stepStatement(stmt))
46454:       addon = this.makeAddonFromRow(stmt.row);
46454: 
46454:     stmt.reset();
46454:     return addon;
46454:   },
46454: 
46454:   /**
41550:    * Asynchronously gets all add-ons with pending operations.
41550:    *
41584:    * @param  aTypes
41550:    *         The types of add-ons to retrieve or null to get all types
41584:    * @param  aCallback
41550:    *         A callback to pass the array of DBAddonInternal to
41550:    */
41550:   getVisibleAddonsWithPendingOperations:
41584:     function XPIDB_getVisibleAddonsWithPendingOperations(aTypes, aCallback) {
82208:     if (!this.connection) {
82208:       aCallback([]);
82208:       return;
82208:     }
82208: 
41550:     let stmt = null;
41584:     if (!aTypes || aTypes.length == 0) {
41550:       stmt = this.getStatement("getVisibleAddonsWithPendingOperations");
41550:     }
41550:     else {
41550:       let sql = "SELECT * FROM addon WHERE visible=1 AND " +
41550:                 "(pendingUninstall=1 OR MAX(userDisabled,appDisabled)=active) " +
41550:                 "AND type IN (";
41584:       for (let i = 1; i <= aTypes.length; i++) {
41550:         sql += "?" + i;
41584:         if (i < aTypes.length)
41550:           sql += ",";
41550:       }
41550:       sql += ")";
41550: 
41550:       // Note that binding to index 0 sets the value for the ?1 parameter
41550:       stmt = this.getStatement("getVisibleAddonsWithPendingOperations_" +
41584:                                aTypes.length, sql);
41584:       for (let i = 0; i < aTypes.length; i++)
64479:         stmt.bindByIndex(i, aTypes[i]);
41550:     }
41550: 
42870:     stmt.executeAsync(new AsyncAddonListCallback(aCallback));
41550:   },
41550: 
41550:   /**
82404:    * Asynchronously get an add-on by its Sync GUID.
82404:    *
82404:    * @param  aGUID
82404:    *         Sync GUID of add-on to fetch
82404:    * @param  aCallback
82404:    *         A callback to pass the DBAddonInternal record to. Receives null
82404:    *         if no add-on with that GUID is found.
82404:    *
82404:    */
82404:   getAddonBySyncGUID: function XPIDB_getAddonBySyncGUID(aGUID, aCallback) {
82404:     let stmt = this.getStatement("getAddonBySyncGUID");
82404:     stmt.params.syncGUID = aGUID;
82404: 
82404:     stmt.executeAsync(new AsyncAddonListCallback(function(aAddons) {
82404:       if (aAddons.length == 0) {
82404:         aCallback(null);
82404:         return;
82404:       }
82404:       aCallback(aAddons[0]);
82404:     }));
82404:   },
82404: 
82404:   /**
41550:    * Synchronously gets all add-ons in the database.
41550:    *
41550:    * @return  an array of DBAddonInternals
41550:    */
41550:   getAddons: function XPIDB_getAddons() {
82208:     if (!this.connection)
82208:       return [];
82208: 
41550:     let stmt = this.getStatement("getAddons");
41550: 
41550:     return [this.makeAddonFromRow(row) for each (row in resultRows(stmt))];;
41550:   },
41550: 
41550:   /**
41550:    * Synchronously adds an AddonInternal's metadata to the database.
41550:    *
41584:    * @param  aAddon
41550:    *         AddonInternal to add
41584:    * @param  aDescriptor
52422:    *         The file descriptor of the add-on
41550:    */
41584:   addAddonMetadata: function XPIDB_addAddonMetadata(aAddon, aDescriptor) {
82208:     // If there is no DB yet then forcibly create one
82208:     if (!this.connection)
82208:       this.openConnection(false, true);
82208: 
42885:     this.beginTransaction();
42885: 
74689:     var self = this;
41584:     function insertLocale(aLocale) {
74689:       let localestmt = self.getStatement("addAddonMetadata_locale");
74689:       let stringstmt = self.getStatement("addAddonMetadata_strings");
74689: 
41584:       copyProperties(aLocale, PROP_LOCALE_SINGLE, localestmt.params);
42885:       executeStatement(localestmt);
41550:       let row = XPIDatabase.connection.lastInsertRowID;
41550: 
41584:       PROP_LOCALE_MULTI.forEach(function(aProp) {
41584:         aLocale[aProp].forEach(function(aStr) {
41550:           stringstmt.params.locale = row;
41584:           stringstmt.params.type = aProp;
41584:           stringstmt.params.value = aStr;
42885:           executeStatement(stringstmt);
41550:         });
41550:       });
41550:       return row;
41550:     }
41550: 
74689:     // Any errors in here should rollback the transaction
74689:     try {
74689: 
41584:       if (aAddon.visible) {
41550:         let stmt = this.getStatement("clearVisibleAddons");
41584:         stmt.params.id = aAddon.id;
42885:         executeStatement(stmt);
41550:       }
41550: 
41550:       let stmt = this.getStatement("addAddonMetadata_addon");
41550: 
41584:       stmt.params.locale = insertLocale(aAddon.defaultLocale);
41584:       stmt.params.location = aAddon._installLocation.name;
41584:       stmt.params.descriptor = aDescriptor;
41584:       copyProperties(aAddon, PROP_METADATA, stmt.params);
47133:       copyProperties(aAddon, DB_METADATA, stmt.params);
47133:       DB_BOOL_METADATA.forEach(function(aProp) {
41584:         stmt.params[aProp] = aAddon[aProp] ? 1 : 0;
41550:       });
42885:       executeStatement(stmt);
41550:       let internal_id = this.connection.lastInsertRowID;
41550: 
41550:       stmt = this.getStatement("addAddonMetadata_addon_locale");
41584:       aAddon.locales.forEach(function(aLocale) {
41584:         let id = insertLocale(aLocale);
41584:         aLocale.locales.forEach(function(aName) {
41550:           stmt.params.internal_id = internal_id;
41584:           stmt.params.name = aName;
41584:           stmt.params.locale = insertLocale(aLocale);
42885:           executeStatement(stmt);
41550:         });
41550:       });
41550: 
41550:       stmt = this.getStatement("addAddonMetadata_targetApplication");
41550: 
41584:       aAddon.targetApplications.forEach(function(aApp) {
41550:         stmt.params.internal_id = internal_id;
41584:         stmt.params.id = aApp.id;
41584:         stmt.params.minVersion = aApp.minVersion;
41584:         stmt.params.maxVersion = aApp.maxVersion;
42885:         executeStatement(stmt);
41550:       });
47133: 
47133:       stmt = this.getStatement("addAddonMetadata_targetPlatform");
47133: 
47133:       aAddon.targetPlatforms.forEach(function(aPlatform) {
47133:         stmt.params.internal_id = internal_id;
47133:         stmt.params.os = aPlatform.os;
47133:         stmt.params.abi = aPlatform.abi;
47133:         executeStatement(stmt);
47133:       });
47133: 
42885:       this.commitTransaction();
42885:     }
42885:     catch (e) {
42885:       this.rollbackTransaction();
42885:       throw e;
42885:     }
41550:   },
41550: 
41550:   /**
41550:    * Synchronously updates an add-ons metadata in the database. Currently just
41550:    * removes and recreates.
41550:    *
41584:    * @param  aOldAddon
41550:    *         The DBAddonInternal to be replaced
41584:    * @param  aNewAddon
41550:    *         The new AddonInternal to add
41584:    * @param  aDescriptor
52422:    *         The file descriptor of the add-on
41550:    */
41584:   updateAddonMetadata: function XPIDB_updateAddonMetadata(aOldAddon, aNewAddon,
41584:                                                           aDescriptor) {
42885:     this.beginTransaction();
42885: 
42885:     // Any errors in here should rollback the transaction
42885:     try {
41584:       this.removeAddonMetadata(aOldAddon);
82404:       aNewAddon.syncGUID = aOldAddon.syncGUID;
41586:       aNewAddon.installDate = aOldAddon.installDate;
41586:       aNewAddon.applyBackgroundUpdates = aOldAddon.applyBackgroundUpdates;
80772:       aNewAddon.foreignInstall = aOldAddon.foreignInstall;
57160:       aNewAddon.active = (aNewAddon.visible && !aNewAddon.userDisabled &&
57160:                           !aNewAddon.appDisabled)
82404: 
41584:       this.addAddonMetadata(aNewAddon, aDescriptor);
42885:       this.commitTransaction();
42885:     }
42885:     catch (e) {
42885:       this.rollbackTransaction();
42885:       throw e;
42885:     }
41550:   },
41550: 
41550:   /**
41550:    * Synchronously updates the target application entries for an add-on.
41550:    *
41584:    * @param  aAddon
41550:    *         The DBAddonInternal being updated
41584:    * @param  aTargets
41550:    *         The array of target applications to update
41550:    */
41584:   updateTargetApplications: function XPIDB_updateTargetApplications(aAddon,
41584:                                                                     aTargets) {
42885:     this.beginTransaction();
42885: 
42885:     // Any errors in here should rollback the transaction
42885:     try {
41550:       let stmt = this.getStatement("updateTargetApplications");
41584:       aTargets.forEach(function(aTarget) {
41584:         stmt.params.internal_id = aAddon._internal_id;
41584:         stmt.params.id = aTarget.id;
41584:         stmt.params.minVersion = aTarget.minVersion;
41584:         stmt.params.maxVersion = aTarget.maxVersion;
42885:         executeStatement(stmt);
41550:       });
42885:       this.commitTransaction();
42885:     }
42885:     catch (e) {
42885:       this.rollbackTransaction();
42885:       throw e;
42885:     }
41550:   },
41550: 
41550:   /**
41550:    * Synchronously removes an add-on from the database.
41550:    *
41584:    * @param  aAddon
41550:    *         The DBAddonInternal being removed
41550:    */
41584:   removeAddonMetadata: function XPIDB_removeAddonMetadata(aAddon) {
41550:     let stmt = this.getStatement("removeAddonMetadata");
41584:     stmt.params.internal_id = aAddon._internal_id;
42885:     executeStatement(stmt);
41550:   },
41550: 
41550:   /**
41550:    * Synchronously marks a DBAddonInternal as visible marking all other
41550:    * instances with the same ID as not visible.
41550:    *
41584:    * @param  aAddon
41550:    *         The DBAddonInternal to make visible
41550:    * @param  callback
41550:    *         A callback to pass the DBAddonInternal to
41550:    */
41584:   makeAddonVisible: function XPIDB_makeAddonVisible(aAddon) {
41550:     let stmt = this.getStatement("clearVisibleAddons");
41584:     stmt.params.id = aAddon.id;
42885:     executeStatement(stmt);
41550: 
41550:     stmt = this.getStatement("makeAddonVisible");
41584:     stmt.params.internal_id = aAddon._internal_id;
42885:     executeStatement(stmt);
41550: 
41584:     aAddon.visible = true;
41550:   },
41550: 
41550:   /**
41550:    * Synchronously sets properties for an add-on.
41550:    *
41584:    * @param  aAddon
41550:    *         The DBAddonInternal being updated
41584:    * @param  aProperties
41550:    *         A dictionary of properties to set
41550:    */
41584:   setAddonProperties: function XPIDB_setAddonProperties(aAddon, aProperties) {
41550:     function convertBoolean(value) {
41550:       return value ? 1 : 0;
41550:     }
41550: 
41550:     let stmt = this.getStatement("setAddonProperties");
41584:     stmt.params.internal_id = aAddon._internal_id;
41584: 
70084:     ["userDisabled", "appDisabled", "softDisabled",
53775:      "pendingUninstall"].forEach(function(aProp) {
41586:       if (aProp in aProperties) {
41586:         stmt.params[aProp] = convertBoolean(aProperties[aProp]);
41586:         aAddon[aProp] = aProperties[aProp];
41550:       }
41550:       else {
41586:         stmt.params[aProp] = convertBoolean(aAddon[aProp]);
41586:       }
41586:     });
41550: 
53775:     if ("applyBackgroundUpdates" in aProperties) {
53775:       stmt.params.applyBackgroundUpdates = aProperties.applyBackgroundUpdates;
53775:       aAddon.applyBackgroundUpdates = aProperties.applyBackgroundUpdates;
53775:     }
53775:     else {
53775:       stmt.params.applyBackgroundUpdates = aAddon.applyBackgroundUpdates;
53775:     }
53775: 
42885:     executeStatement(stmt);
41550:   },
41550: 
41550:   /**
82404:    * Synchronously sets the Sync GUID for an add-on.
82404:    *
82404:    * @param  aAddon
82404:    *         The DBAddonInternal being updated
82404:    * @param  aGUID
82404:    *         GUID string to set the value to
82404:    */
82404:   setAddonSyncGUID: function XPIDB_setAddonSyncGUID(aAddon, aGUID) {
82404:     let stmt = this.getStatement("setAddonSyncGUID");
82404:     stmt.params.internal_id = aAddon._internal_id;
82404:     stmt.params.syncGUID = aGUID;
82404: 
82404:     executeStatement(stmt);
82404:   },
82404: 
82404:   /**
71594:    * Synchronously sets the file descriptor for an add-on.
71594:    *
71594:    * @param  aAddon
71594:    *         The DBAddonInternal being updated
71594:    * @param  aProperties
71594:    *         A dictionary of properties to set
71594:    */
71594:   setAddonDescriptor: function XPIDB_setAddonDescriptor(aAddon, aDescriptor) {
71594:     let stmt = this.getStatement("setAddonDescriptor");
71594:     stmt.params.internal_id = aAddon._internal_id;
71594:     stmt.params.descriptor = aDescriptor;
71594: 
71594:     executeStatement(stmt);
71594:   },
71594: 
71594:   /**
71594:    * Synchronously updates an add-on's active flag in the database.
41550:    *
41584:    * @param  aAddon
41550:    *         The DBAddonInternal to update
41550:    */
41584:   updateAddonActive: function XPIDB_updateAddonActive(aAddon) {
41550:     LOG("Updating add-on state");
41550: 
42890:     let stmt = this.getStatement("updateAddonActive");
41584:     stmt.params.internal_id = aAddon._internal_id;
41584:     stmt.params.active = aAddon.active ? 1 : 0;
42885:     executeStatement(stmt);
41550:   },
41550: 
41550:   /**
41550:    * Synchronously calculates and updates all the active flags in the database.
41550:    */
41550:   updateActiveAddons: function XPIDB_updateActiveAddons() {
41550:     LOG("Updating add-on states");
41550:     let stmt = this.getStatement("setActiveAddons");
42885:     executeStatement(stmt);
47636: 
47636:     // Note that this does not update the active property on cached
47636:     // DBAddonInternal instances so we throw away the cache. This should only
47636:     // happen during shutdown when everything is going away anyway or during
47636:     // startup when the only references are internal.
47636:     this.addonCache = [];
41550:   },
41550: 
41550:   /**
41550:    * Writes out the XPI add-ons list for the platform to read.
56256:    */
56256:   writeAddonsList: function XPIDB_writeAddonsList() {
41550:     Services.appinfo.invalidateCachesOnRestart();
82313: 
41550:     let addonsList = FileUtils.getFile(KEY_PROFILEDIR, [FILE_XPI_ADDONS_LIST],
41550:                                        true);
82313:     if (!this.connection) {
82313:       try {
82313:         addonsList.remove(false);
82313:         LOG("Deleted add-ons list");
82313:       }
82313:       catch (e) {
82313:       }
82313: 
82313:       Services.prefs.clearUserPref(PREF_EM_ENABLED_ADDONS);
82313:       return;
82313:     }
41550: 
41575:     let enabledAddons = [];
41550:     let text = "[ExtensionDirs]\r\n";
41550:     let count = 0;
82313:     let fullCount = 0;
82313: 
82313:     let stmt = this.getStatement("getActiveAddons");
41550: 
41575:     for (let row in resultRows(stmt)) {
41550:       text += "Extension" + (count++) + "=" + row.descriptor + "\r\n";
41575:       enabledAddons.push(row.id + ":" + row.version);
41575:     }
82313:     fullCount += count;
41550: 
41550:     // The selected skin may come from an inactive theme (the default theme
41550:     // when a lightweight theme is applied for example)
41550:     text += "\r\n[ThemeDirs]\r\n";
82208: 
42890:     if (Prefs.getBoolPref(PREF_EM_DSS_ENABLED)) {
42890:       stmt = this.getStatement("getThemes");
42890:     }
42890:     else {
41550:       stmt = this.getStatement("getActiveTheme");
41550:       stmt.params.internalName = XPIProvider.selectedSkin;
42890:     }
82313: 
82313:     if (stmt) {
41550:       count = 0;
41575:       for (let row in resultRows(stmt)) {
41550:         text += "Extension" + (count++) + "=" + row.descriptor + "\r\n";
41575:         enabledAddons.push(row.id + ":" + row.version);
41575:       }
82313:       fullCount += count;
82313:     }
82313: 
82313:     if (fullCount > 0) {
82313:       LOG("Writing add-ons list");
41550:       var fos = FileUtils.openSafeFileOutputStream(addonsList);
41550:       fos.write(text, text.length);
41550:       FileUtils.closeSafeFileOutputStream(fos);
41575: 
41575:       Services.prefs.setCharPref(PREF_EM_ENABLED_ADDONS, enabledAddons.join(","));
41550:     }
82313:     else {
82313:       if (addonsList.exists()) {
82313:         LOG("Deleting add-ons list");
82313:         addonsList.remove(false);
82313:       }
82313: 
82313:       Services.prefs.clearUserPref(PREF_EM_ENABLED_ADDONS);
82313:     }
82313:   }
41550: };
41550: 
57183: function getHashStringForCrypto(aCrypto) {
57183:   // return the two-digit hexadecimal code for a byte
57183:   function toHexString(charCode)
57183:     ("0" + charCode.toString(16)).slice(-2);
57183: 
57183:   // convert the binary hash data to a hex string.
57183:   let binary = aCrypto.finish(false);
57183:   return [toHexString(binary.charCodeAt(i)) for (i in binary)].join("").toLowerCase()
57183: }
57183: 
41550: /**
72311:  * Instantiates an AddonInstall.
72311:  *
41584:  * @param  aInstallLocation
41550:  *         The install location the add-on will be installed into
41584:  * @param  aUrl
41550:  *         The nsIURL to get the add-on from. If this is an nsIFileURL then
41550:  *         the add-on will not need to be downloaded
41584:  * @param  aHash
41550:  *         An optional hash for the add-on
47135:  * @param  aReleaseNotesURI
47135:  *         An optional nsIURI of release notes for the add-on
41584:  * @param  aExistingAddon
41550:  *         The add-on this install will update if known
41584:  * @param  aLoadGroup
41550:  *         The nsILoadGroup to associate any requests with
41550:  * @throws if the url is the url of a local file and the hash does not match
41550:  *         or the add-on does not contain an valid install manifest
41550:  */
72311: function AddonInstall(aInstallLocation, aUrl, aHash, aReleaseNotesURI,
72311:                       aExistingAddon, aLoadGroup) {
41550:   this.wrapper = new AddonInstallWrapper(this);
41584:   this.installLocation = aInstallLocation;
47134:   this.sourceURI = aUrl;
47135:   this.releaseNotesURI = aReleaseNotesURI;
57183:   if (aHash) {
57183:     let hashSplit = aHash.toLowerCase().split(":");
57183:     this.originalHash = {
57183:       algorithm: hashSplit[0],
57183:       data: hashSplit[1]
57183:     };
57183:   }
57183:   this.hash = this.originalHash;
41584:   this.loadGroup = aLoadGroup;
41550:   this.listeners = [];
41584:   this.existingAddon = aExistingAddon;
43491:   this.error = 0;
53954:   if (aLoadGroup)
53954:     this.window = aLoadGroup.notificationCallbacks
53954:                             .getInterface(Ci.nsIDOMWindow);
53954:   else
53954:     this.window = null;
72311: }
72311: 
72311: AddonInstall.prototype = {
72311:   installLocation: null,
72311:   wrapper: null,
72311:   stream: null,
72311:   crypto: null,
72311:   originalHash: null,
72311:   hash: null,
72311:   loadGroup: null,
72311:   badCertHandler: null,
72311:   listeners: null,
72311:   restartDownload: false,
72311: 
72311:   name: null,
72311:   type: null,
72311:   version: null,
72311:   iconURL: null,
72311:   releaseNotesURI: null,
72311:   sourceURI: null,
72311:   file: null,
72311:   ownsTempFile: false,
72311:   certificate: null,
72311:   certName: null,
72311: 
72311:   linkedInstalls: null,
72311:   existingAddon: null,
72311:   addon: null,
72311: 
72311:   state: null,
72311:   error: null,
72311:   progress: null,
72311:   maxProgress: null,
72311: 
72311:   /**
72311:    * Initialises this install to be a staged install waiting to be applied
72311:    *
72311:    * @param  aManifest
72311:    *         The cached manifest for the staged install
72311:    */
72311:   initStagedInstall: function(aManifest) {
72311:     this.name = aManifest.name;
72311:     this.type = aManifest.type;
72311:     this.version = aManifest.version;
72311:     this.iconURL = aManifest.iconURL;
72311:     this.releaseNotesURI = aManifest.releaseNotesURI ?
72311:                            NetUtil.newURI(aManifest.releaseNotesURI) :
72311:                            null
72311:     this.sourceURI = aManifest.sourceURI ?
72311:                      NetUtil.newURI(aManifest.sourceURI) :
72311:                      null;
72311:     this.file = null;
72311:     this.addon = aManifest;
72311: 
72311:     this.state = AddonManager.STATE_INSTALLED;
72311: 
72311:     XPIProvider.installs.push(this);
72311:   },
72311: 
72311:   /**
72311:    * Initialises this install to be an install from a local file.
72311:    *
72311:    * @param  aCallback
72311:    *         The callback to pass the initialised AddonInstall to
72311:    */
72311:   initLocalInstall: function(aCallback) {
72311:     this.file = this.sourceURI.QueryInterface(Ci.nsIFileURL)
72311:                     .file.QueryInterface(Ci.nsILocalFile);
43491: 
43491:     if (!this.file.exists()) {
43491:       WARN("XPI file " + this.file.path + " does not exist");
43491:       this.state = AddonManager.STATE_DOWNLOAD_FAILED;
43491:       this.error = AddonManager.ERROR_NETWORK_FAILURE;
43491:       aCallback(this);
43491:       return;
43491:     }
43491: 
41550:     this.state = AddonManager.STATE_DOWNLOADED;
41550:     this.progress = this.file.fileSize;
41550:     this.maxProgress = this.file.fileSize;
41550: 
41550:     if (this.hash) {
41550:       let crypto = Cc["@mozilla.org/security/hash;1"].
41550:                    createInstance(Ci.nsICryptoHash);
57183:       try {
57183:         crypto.initWithString(this.hash.algorithm);
57183:       }
57183:       catch (e) {
57183:         WARN("Unknown hash algorithm " + this.hash.algorithm);
57183:         this.state = AddonManager.STATE_DOWNLOAD_FAILED;
57183:         this.error = AddonManager.ERROR_INCORRECT_HASH;
57183:         aCallback(this);
57183:         return;
57183:       }
57183: 
41550:       let fis = Cc["@mozilla.org/network/file-input-stream;1"].
41550:                 createInstance(Ci.nsIFileInputStream);
41550:       fis.init(this.file, -1, -1, false);
41550:       crypto.updateFromStream(fis, this.file.fileSize);
57183:       let calculatedHash = getHashStringForCrypto(crypto);
57183:       if (calculatedHash != this.hash.data) {
57183:         WARN("File hash (" + calculatedHash + ") did not match provided hash (" +
57183:              this.hash.data + ")");
43491:         this.state = AddonManager.STATE_DOWNLOAD_FAILED;
43491:         this.error = AddonManager.ERROR_INCORRECT_HASH;
43491:         aCallback(this);
43491:         return;
43491:       }
43491:     }
43491: 
43491:     try {
41550:       let self = this;
48669:       this.loadManifest(function() {
48669:         XPIDatabase.getVisibleAddonForID(self.addon.id, function(aAddon) {
41584:           self.existingAddon = aAddon;
55373:           if (aAddon)
70084:             applyBlocklistChanges(aAddon, self.addon);
51284:           self.addon.updateDate = Date.now();
51284:           self.addon.installDate = aAddon ? aAddon.installDate : self.addon.updateDate;
41559: 
41559:           if (!self.addon.isCompatible) {
41559:             // TODO Should we send some event here?
41584:             self.state = AddonManager.STATE_CHECKING;
41559:             new UpdateChecker(self.addon, {
41584:               onUpdateFinished: function(aAddon) {
41584:                 self.state = AddonManager.STATE_DOWNLOADED;
41550:                 XPIProvider.installs.push(self);
41568:                 AddonManagerPrivate.callInstallListeners("onNewInstall",
41568:                                                          self.listeners,
41550:                                                          self.wrapper);
41550: 
41584:                 aCallback(self);
41559:               }
41559:             }, AddonManager.UPDATE_WHEN_ADDON_INSTALLED);
41559:           }
41559:           else {
41559:             XPIProvider.installs.push(self);
48669:             AddonManagerPrivate.callInstallListeners("onNewInstall",
48669:                                                      self.listeners,
41559:                                                      self.wrapper);
41559: 
41584:             aCallback(self);
41559:           }
41550:         });
48669:       });
48669:     }
48669:     catch (e) {
57401:       WARN("Invalid XPI", e);
48669:       this.state = AddonManager.STATE_DOWNLOAD_FAILED;
48669:       this.error = AddonManager.ERROR_CORRUPT_FILE;
48669:       aCallback(this);
48669:       return;
48669:     }
72311:   },
72311: 
72311:   /**
72311:    * Initialises this install to be a download from a remote url.
72311:    *
72311:    * @param  aCallback
72311:    *         The callback to pass the initialised AddonInstall to
72311:    * @param  aName
72311:    *         An optional name for the add-on
72311:    * @param  aType
72311:    *         An optional type for the add-on
72311:    * @param  aIconURL
72311:    *         An optional icon for the add-on
72311:    * @param  aVersion
72311:    *         An optional version for the add-on
72311:    */
72311:   initAvailableDownload: function(aName, aType, aIconURL, aVersion, aCallback) {
41550:     this.state = AddonManager.STATE_AVAILABLE;
41584:     this.name = aName;
41584:     this.type = aType;
41584:     this.version = aVersion;
41584:     this.iconURL = aIconURL;
41550:     this.progress = 0;
41550:     this.maxProgress = -1;
41550: 
41550:     XPIProvider.installs.push(this);
41550:     AddonManagerPrivate.callInstallListeners("onNewInstall", this.listeners,
41550:                                              this.wrapper);
41550: 
41584:     aCallback(this);
72311:   },
41550: 
41550:   /**
41550:    * Starts installation of this add-on from whatever state it is currently at
41550:    * if possible.
41550:    *
41550:    * @throws if installation cannot proceed from the current state
41550:    */
41550:   install: function AI_install() {
41550:     switch (this.state) {
41550:     case AddonManager.STATE_AVAILABLE:
41550:       this.startDownload();
41550:       break;
41550:     case AddonManager.STATE_DOWNLOADED:
41550:       this.startInstall();
41550:       break;
57183:     case AddonManager.STATE_DOWNLOAD_FAILED:
57183:     case AddonManager.STATE_INSTALL_FAILED:
57183:     case AddonManager.STATE_CANCELLED:
57183:       this.removeTemporaryFile();
57183:       this.state = AddonManager.STATE_AVAILABLE;
57183:       this.error = 0;
57183:       this.progress = 0;
57183:       this.maxProgress = -1;
57183:       this.hash = this.originalHash;
57183:       XPIProvider.installs.push(this);
57183:       this.startDownload();
57183:       break;
41550:     case AddonManager.STATE_DOWNLOADING:
41550:     case AddonManager.STATE_CHECKING:
41550:     case AddonManager.STATE_INSTALLING:
41550:       // Installation is already running
41550:       return;
41550:     default:
41550:       throw new Error("Cannot start installing from this state");
41550:     }
41550:   },
41550: 
41550:   /**
41550:    * Cancels installation of this add-on.
41550:    *
41550:    * @throws if installation cannot be cancelled from the current state
41550:    */
41550:   cancel: function AI_cancel() {
41550:     switch (this.state) {
41550:     case AddonManager.STATE_DOWNLOADING:
55372:       if (this.channel)
41574:         this.channel.cancel(Cr.NS_BINDING_ABORTED);
41550:     case AddonManager.STATE_AVAILABLE:
41550:     case AddonManager.STATE_DOWNLOADED:
47134:       LOG("Cancelling download of " + this.sourceURI.spec);
41550:       this.state = AddonManager.STATE_CANCELLED;
41582:       XPIProvider.removeActiveInstall(this);
41550:       AddonManagerPrivate.callInstallListeners("onDownloadCancelled",
41550:                                                this.listeners, this.wrapper);
57429:       this.removeTemporaryFile();
41550:       break;
41550:     case AddonManager.STATE_INSTALLED:
41550:       LOG("Cancelling install of " + this.addon.id);
58902:       let xpi = this.installLocation.getStagingDir();
58902:       xpi.append(this.addon.id + ".xpi");
70154:       flushJarCache(xpi);
56256:       cleanStagingDir(this.installLocation.getStagingDir(),
56256:                       [this.addon.id, this.addon.id + ".xpi",
56256:                        this.addon.id + ".json"]);
41550:       this.state = AddonManager.STATE_CANCELLED;
41582:       XPIProvider.removeActiveInstall(this);
51140: 
51140:       if (this.existingAddon) {
51140:         delete this.existingAddon.pendingUpgrade;
51140:         this.existingAddon.pendingUpgrade = null;
51140:       }
51140: 
54984:       AddonManagerPrivate.callAddonListeners("onOperationCancelled", createWrapper(this.addon));
54984: 
41550:       AddonManagerPrivate.callInstallListeners("onInstallCancelled",
41550:                                                this.listeners, this.wrapper);
41550:       break;
41550:     default:
59809:       throw new Error("Cannot cancel install of " + this.sourceURI.spec +
59809:                       " from this state (" + this.state + ")");
41550:     }
41550:   },
41550: 
41550:   /**
41550:    * Adds an InstallListener for this instance if the listener is not already
41550:    * registered.
41550:    *
41584:    * @param  aListener
41550:    *         The InstallListener to add
41550:    */
41584:   addListener: function AI_addListener(aListener) {
41584:     if (!this.listeners.some(function(i) { return i == aListener; }))
41584:       this.listeners.push(aListener);
41550:   },
41550: 
41550:   /**
41550:    * Removes an InstallListener for this instance if it is registered.
41550:    *
41584:    * @param  aListener
41550:    *         The InstallListener to remove
41550:    */
41584:   removeListener: function AI_removeListener(aListener) {
41550:     this.listeners = this.listeners.filter(function(i) {
41584:       return i != aListener;
41550:     });
41550:   },
41550: 
41550:   /**
48669:    * Removes the temporary file owned by this AddonInstall if there is one.
48669:    */
48669:   removeTemporaryFile: function AI_removeTemporaryFile() {
48669:     // Only proceed if this AddonInstall owns its XPI file
48669:     if (!this.ownsTempFile)
48669:       return;
48669: 
48669:     try {
48669:       this.file.remove(true);
48669:       this.ownsTempFile = false;
48669:     }
48669:     catch (e) {
57401:       WARN("Failed to remove temporary file " + this.file.path, e);
48669:     }
48669:   },
48669: 
48669:   /**
48669:    * Updates the sourceURI and releaseNotesURI values on the Addon being
48669:    * installed by this AddonInstall instance.
48669:    */
48669:   updateAddonURIs: function AI_updateAddonURIs() {
48669:     this.addon.sourceURI = this.sourceURI.spec;
48669:     if (this.releaseNotesURI)
48669:       this.addon.releaseNotesURI = this.releaseNotesURI.spec;
48669:   },
48669: 
48669:   /**
48669:    * Loads add-on manifests from a multi-package XPI file. Each of the
48669:    * XPI and JAR files contained in the XPI will be extracted. Any that
48669:    * do not contain valid add-ons will be ignored. The first valid add-on will
48669:    * be installed by this AddonInstall instance, the rest will have new
48669:    * AddonInstall instances created for them.
48669:    *
48669:    * @param  aZipReader
48669:    *         An open nsIZipReader for the multi-package XPI's files. This will
48669:    *         be closed before this method returns.
48669:    * @param  aCallback
48669:    *         A function to call when all of the add-on manifests have been
48669:    *         loaded.
48669:    */
48669:   loadMultipackageManifests: function AI_loadMultipackageManifests(aZipReader,
48669:                                                                    aCallback) {
48669:     let files = [];
48669:     let entries = aZipReader.findEntries("(*.[Xx][Pp][Ii]|*.[Jj][Aa][Rr])");
48669:     while (entries.hasMore()) {
48669:       let entryName = entries.getNext();
48669:       var target = getTemporaryFile();
48669:       try {
48669:         aZipReader.extract(entryName, target);
48669:         files.push(target);
48669:       }
48669:       catch (e) {
48669:         WARN("Failed to extract " + entryName + " from multi-package " +
57401:              "XPI", e);
48669:         target.remove(false);
48669:       }
48669:     }
48669: 
48669:     aZipReader.close();
48669: 
48669:     if (files.length == 0) {
48669:       throw new Error("Multi-package XPI does not contain any packages " +
48669:                       "to install");
48669:     }
48669: 
48669:     let addon = null;
48669: 
48669:     // Find the first file that has a valid install manifest and use it for
48669:     // the add-on that this AddonInstall instance will install.
48669:     while (files.length > 0) {
48669:       this.removeTemporaryFile();
48669:       this.file = files.shift();
48669:       this.ownsTempFile = true;
48669:       try {
48669:         addon = loadManifestFromZipFile(this.file);
48669:         break;
48669:       }
48669:       catch (e) {
48669:         WARN(this.file.leafName + " cannot be installed from multi-package " +
57401:              "XPI", e);
48669:       }
48669:     }
48669: 
48669:     if (!addon) {
48669:       // No valid add-on was found
48669:       aCallback();
48669:       return;
48669:     }
48669: 
48669:     this.addon = addon;
48669: 
48669:     this.updateAddonURIs();
48669: 
48669:     this.addon._install = this;
48669:     this.name = this.addon.selectedLocale.name;
48669:     this.type = this.addon.type;
48669:     this.version = this.addon.version;
48669: 
48669:     // Setting the iconURL to something inside the XPI locks the XPI and
48669:     // makes it impossible to delete on Windows.
48669:     //let newIcon = createWrapper(this.addon).iconURL;
48669:     //if (newIcon)
48669:     //  this.iconURL = newIcon;
48669: 
48669:     // Create new AddonInstall instances for every remaining file
48669:     if (files.length > 0) {
48669:       this.linkedInstalls = [];
48669:       let count = 0;
48669:       let self = this;
48669:       files.forEach(function(file) {
48669:         AddonInstall.createInstall(function(aInstall) {
48669:           // Ignore bad add-ons (createInstall will have logged the error)
48669:           if (aInstall.state == AddonManager.STATE_DOWNLOAD_FAILED) {
48669:             // Manually remove the temporary file
48669:             file.remove(true);
48669:           }
48669:           else {
48669:             // Make the new install own its temporary file
48669:             aInstall.ownsTempFile = true;
48669: 
48669:             self.linkedInstalls.push(aInstall)
48669: 
48669:             aInstall.sourceURI = self.sourceURI;
48669:             aInstall.releaseNotesURI = self.releaseNotesURI;
48669:             aInstall.updateAddonURIs();
48669:           }
48669: 
48669:           count++;
48669:           if (count == files.length)
48669:             aCallback();
48669:         }, file);
48669:       }, this);
48669:     }
48669:     else {
48669:       aCallback();
48669:     }
48669:   },
48669: 
48669:   /**
41550:    * Called after the add-on is a local file and the signature and install
41550:    * manifest can be read.
41550:    *
48669:    * @param  aCallback
48669:    *         A function to call when the manifest has been loaded
41550:    * @throws if the add-on does not contain a valid install manifest or the
41550:    *         XPI is incorrectly signed
41550:    */
48669:   loadManifest: function AI_loadManifest(aCallback) {
55374:     function addRepositoryData(aAddon) {
55374:       // Try to load from the existing cache first
55374:       AddonRepository.getCachedAddonByID(aAddon.id, function(aRepoAddon) {
55374:         if (aRepoAddon) {
55374:           aAddon._repositoryAddon = aRepoAddon;
83133:           aAddon.compatibilityOverrides = aRepoAddon.compatibilityOverrides;
86445:           aAddon.appDisabled = !isUsableAddon(aAddon);
55374:           aCallback();
55374:           return;
55374:         }
55374: 
55374:         // It wasn't there so try to re-download it
55374:         AddonRepository.cacheAddons([aAddon.id], function() {
55374:           AddonRepository.getCachedAddonByID(aAddon.id, function(aRepoAddon) {
55374:             aAddon._repositoryAddon = aRepoAddon;
83133:             aAddon.compatibilityOverrides = aRepoAddon ?
83133:                                               aRepoAddon.compatibilityOverrides :
83133:                                               null;
86445:             aAddon.appDisabled = !isUsableAddon(aAddon);
55374:             aCallback();
55374:           });
55374:         });
55374:       });
55374:     }
55374: 
41550:     let zipreader = Cc["@mozilla.org/libjar/zip-reader;1"].
41550:                     createInstance(Ci.nsIZipReader);
48669:     try {
41550:       zipreader.open(this.file);
48669:     }
48669:     catch (e) {
48669:       zipreader.close();
48669:       throw e;
48669:     }
48669: 
41550:     let principal = zipreader.getCertificatePrincipal(null);
41550:     if (principal && principal.hasCertificate) {
41573:       LOG("Verifying XPI signature");
41550:       if (verifyZipSigning(zipreader, principal)) {
41550:         let x509 = principal.certificate;
41550:         if (x509 instanceof Ci.nsIX509Cert)
41550:           this.certificate = x509;
41550:         if (this.certificate && this.certificate.commonName.length > 0)
41550:           this.certName = this.certificate.commonName;
41550:         else
41550:           this.certName = principal.prettyName;
41550:       }
41550:       else {
48669:         zipreader.close();
41550:         throw new Error("XPI is incorrectly signed");
41550:       }
41550:     }
41550: 
48669:     try {
48669:       this.addon = loadManifestFromZipReader(zipreader);
48669:     }
48669:     catch (e) {
41550:       zipreader.close();
48669:       throw e;
48669:     }
48669: 
48669:     if (this.addon.type == "multipackage") {
55374:       let self = this;
55374:       this.loadMultipackageManifests(zipreader, function() {
55374:         addRepositoryData(self.addon);
55374:       });
48669:       return;
48669:     }
48669: 
48669:     zipreader.close();
48669: 
48669:     this.updateAddonURIs();
48669: 
41566:     this.addon._install = this;
42843:     this.name = this.addon.selectedLocale.name;
42843:     this.type = this.addon.type;
42843:     this.version = this.addon.version;
42883: 
42883:     // Setting the iconURL to something inside the XPI locks the XPI and
42883:     // makes it impossible to delete on Windows.
42883:     //let newIcon = createWrapper(this.addon).iconURL;
42883:     //if (newIcon)
42883:     //  this.iconURL = newIcon;
48669: 
55374:     addRepositoryData(this.addon);
41550:   },
41550: 
41584:   observe: function AI_observe(aSubject, aTopic, aData) {
41574:     // Network is going offline
41574:     this.cancel();
41574:   },
41574: 
41550:   /**
41550:    * Starts downloading the add-on's XPI file.
41550:    */
41550:   startDownload: function AI_startDownload() {
41550:     this.state = AddonManager.STATE_DOWNLOADING;
41550:     if (!AddonManagerPrivate.callInstallListeners("onDownloadStarted",
41550:                                                   this.listeners, this.wrapper)) {
41550:       this.state = AddonManager.STATE_CANCELLED;
41582:       XPIProvider.removeActiveInstall(this);
41550:       AddonManagerPrivate.callInstallListeners("onDownloadCancelled",
41550:                                                this.listeners, this.wrapper)
41550:       return;
41550:     }
41550: 
55372:     // If a listener changed our state then do not proceed with the download
55372:     if (this.state != AddonManager.STATE_DOWNLOADING)
55372:       return;
55372: 
68756:     if (this.channel) {
68756:       // A previous download attempt hasn't finished cleaning up yet, signal
68756:       // that it should restart when complete
68756:       LOG("Waiting for previous download to complete");
68756:       this.restartDownload = true;
68756:       return;
68756:     }
68756: 
68756:     this.openChannel();
68756:   },
68756: 
68756:   openChannel: function AI_openChannel() {
68756:     this.restartDownload = false;
68756: 
41550:     try {
48669:       this.file = getTemporaryFile();
48669:       this.ownsTempFile = true;
41550:       this.stream = Cc["@mozilla.org/network/file-output-stream;1"].
41550:                     createInstance(Ci.nsIFileOutputStream);
41550:       this.stream.init(this.file, FileUtils.MODE_WRONLY | FileUtils.MODE_CREATE |
41550:                        FileUtils.MODE_TRUNCATE, FileUtils.PERMS_FILE, 0);
43491:     }
43491:     catch (e) {
57401:       WARN("Failed to start download", e);
43491:       this.state = AddonManager.STATE_DOWNLOAD_FAILED;
43491:       this.error = AddonManager.ERROR_FILE_ACCESS;
43491:       XPIProvider.removeActiveInstall(this);
43491:       AddonManagerPrivate.callInstallListeners("onDownloadFailed",
43491:                                                this.listeners, this.wrapper);
43491:       return;
43491:     }
41550: 
41550:     let listener = Cc["@mozilla.org/network/stream-listener-tee;1"].
41550:                    createInstance(Ci.nsIStreamListenerTee);
41550:     listener.init(this, this.stream);
43491:     try {
52112:       Components.utils.import("resource://gre/modules/CertUtils.jsm");
52112:       let requireBuiltIn = Prefs.getBoolPref(PREF_INSTALL_REQUIREBUILTINCERTS, true);
52112:       this.badCertHandler = new BadCertHandler(!requireBuiltIn);
52112: 
47134:       this.channel = NetUtil.newChannel(this.sourceURI);
52112:       this.channel.notificationCallbacks = this;
54990:       if (this.channel instanceof Ci.nsIHttpChannelInternal)
54990:         this.channel.forceAllowThirdPartyCookie = true;
41574:       this.channel.asyncOpen(listener, null);
43491: 
43491:       Services.obs.addObserver(this, "network:offline-about-to-go-offline", false);
41550:     }
41550:     catch (e) {
57401:       WARN("Failed to start download", e);
41550:       this.state = AddonManager.STATE_DOWNLOAD_FAILED;
43491:       this.error = AddonManager.ERROR_NETWORK_FAILURE;
41582:       XPIProvider.removeActiveInstall(this);
41550:       AddonManagerPrivate.callInstallListeners("onDownloadFailed",
43491:                                                this.listeners, this.wrapper);
41550:     }
41550:   },
41550: 
41550:   /**
41550:    * Update the crypto hasher with the new data and call the progress listeners.
41550:    *
41550:    * @see nsIStreamListener
41550:    */
41584:   onDataAvailable: function AI_onDataAvailable(aRequest, aContext, aInputstream,
41584:                                                aOffset, aCount) {
41584:     this.crypto.updateFromStream(aInputstream, aCount);
41584:     this.progress += aCount;
41550:     if (!AddonManagerPrivate.callInstallListeners("onDownloadProgress",
41550:                                                   this.listeners, this.wrapper)) {
41550:       // TODO cancel the download and make it available again (bug 553024)
41550:     }
41550:   },
41550: 
41550:   /**
52112:    * Check the redirect response for a hash of the target XPI and verify that
52112:    * we don't end up on an insecure channel.
52112:    *
52112:    * @see nsIChannelEventSink
52112:    */
52112:   asyncOnChannelRedirect: function(aOldChannel, aNewChannel, aFlags, aCallback) {
52112:     if (!this.hash && aOldChannel.originalURI.schemeIs("https") &&
52112:         aOldChannel instanceof Ci.nsIHttpChannel) {
52112:       try {
57183:         let hashStr = aOldChannel.getResponseHeader("X-Target-Digest");
57183:         let hashSplit = hashStr.toLowerCase().split(":");
57183:         this.hash = {
57183:           algorithm: hashSplit[0],
57183:           data: hashSplit[1]
57183:         };
52112:       }
52112:       catch (e) {
52112:       }
52112:     }
52112: 
52112:     // Verify that we don't end up on an insecure channel if we haven't got a
52112:     // hash to verify with (see bug 537761 for discussion)
52112:     if (!this.hash)
52112:       this.badCertHandler.asyncOnChannelRedirect(aOldChannel, aNewChannel, aFlags, aCallback);
52112:     else
52112:       aCallback.onRedirectVerifyCallback(Cr.NS_OK);
57429: 
57429:     this.channel = aNewChannel;
52112:   },
52112: 
52112:   /**
41550:    * This is the first chance to get at real headers on the channel.
41550:    *
41550:    * @see nsIStreamListener
41550:    */
41584:   onStartRequest: function AI_onStartRequest(aRequest, aContext) {
52112:     this.crypto = Cc["@mozilla.org/security/hash;1"].
52112:                   createInstance(Ci.nsICryptoHash);
52112:     if (this.hash) {
52112:       try {
57183:         this.crypto.initWithString(this.hash.algorithm);
52112:       }
52112:       catch (e) {
57183:         WARN("Unknown hash algorithm " + this.hash.algorithm);
52112:         this.state = AddonManager.STATE_DOWNLOAD_FAILED;
52112:         this.error = AddonManager.ERROR_INCORRECT_HASH;
52112:         XPIProvider.removeActiveInstall(this);
52112:         AddonManagerPrivate.callInstallListeners("onDownloadFailed",
52112:                                                  this.listeners, this.wrapper);
52112:         aRequest.cancel(Cr.NS_BINDING_ABORTED);
52112:         return;
52112:       }
52112:     }
52112:     else {
52112:       // We always need something to consume data from the inputstream passed
52112:       // to onDataAvailable so just create a dummy cryptohasher to do that.
52112:       this.crypto.initWithString("sha1");
52112:     }
52112: 
41550:     this.progress = 0;
41584:     if (aRequest instanceof Ci.nsIChannel) {
41550:       try {
41584:         this.maxProgress = aRequest.contentLength;
41550:       }
41550:       catch (e) {
41550:       }
47134:       LOG("Download started for " + this.sourceURI.spec + " to file " +
41550:           this.file.path);
41550:     }
41550:   },
41550: 
41550:   /**
41550:    * The download is complete.
41550:    *
41550:    * @see nsIStreamListener
41550:    */
41584:   onStopRequest: function AI_onStopRequest(aRequest, aContext, aStatus) {
41550:     this.stream.close();
41574:     this.channel = null;
52112:     this.badCerthandler = null;
41574:     Services.obs.removeObserver(this, "network:offline-about-to-go-offline");
41574: 
41574:     // If the download was cancelled then all events will have already been sent
57429:     if (aStatus == Cr.NS_BINDING_ABORTED) {
57429:       this.removeTemporaryFile();
68756:       if (this.restartDownload)
68756:         this.openChannel();
41574:       return;
57429:     }
41574: 
47134:     LOG("Download of " + this.sourceURI.spec + " completed.");
41550: 
41584:     if (Components.isSuccessCode(aStatus)) {
41584:       if (!(aRequest instanceof Ci.nsIHttpChannel) || aRequest.requestSucceeded) {
41584:         if (!this.hash && (aRequest instanceof Ci.nsIChannel)) {
41550:           try {
52111:             checkCert(aRequest,
52111:                       !Prefs.getBoolPref(PREF_INSTALL_REQUIREBUILTINCERTS, true));
41550:           }
41550:           catch (e) {
41550:             this.downloadFailed(AddonManager.ERROR_NETWORK_FAILURE, e);
41550:             return;
41550:           }
41550:         }
41550: 
41550:         // convert the binary hash data to a hex string.
57183:         let calculatedHash = getHashStringForCrypto(this.crypto);
41550:         this.crypto = null;
57183:         if (this.hash && calculatedHash != this.hash.data) {
41550:           this.downloadFailed(AddonManager.ERROR_INCORRECT_HASH,
57183:                               "Downloaded file hash (" + calculatedHash +
57183:                               ") did not match provided hash (" + this.hash.data + ")");
41550:           return;
41550:         }
41550:         try {
48669:           let self = this;
48669:           this.loadManifest(function() {
48669:             if (self.addon.isCompatible) {
48669:               self.downloadCompleted();
41550:             }
41550:             else {
41550:               // TODO Should we send some event here (bug 557716)?
48669:               self.state = AddonManager.STATE_CHECKING;
48669:               new UpdateChecker(self.addon, {
41584:                 onUpdateFinished: function(aAddon) {
41550:                   self.downloadCompleted();
41550:                 }
41550:               }, AddonManager.UPDATE_WHEN_ADDON_INSTALLED);
41550:             }
48669:           });
41550:         }
41550:         catch (e) {
41550:           this.downloadFailed(AddonManager.ERROR_CORRUPT_FILE, e);
41550:         }
41550:       }
41550:       else {
41584:         if (aRequest instanceof Ci.nsIHttpChannel)
41550:           this.downloadFailed(AddonManager.ERROR_NETWORK_FAILURE,
41584:                               aRequest.responseStatus + " " +
41584:                               aRequest.responseStatusText);
41550:         else
41584:           this.downloadFailed(AddonManager.ERROR_NETWORK_FAILURE, aStatus);
41550:       }
41550:     }
41550:     else {
41584:       this.downloadFailed(AddonManager.ERROR_NETWORK_FAILURE, aStatus);
41550:     }
41550:   },
41550: 
41550:   /**
41550:    * Notify listeners that the download failed.
41550:    *
41584:    * @param  aReason
41550:    *         Something to log about the failure
41550:    * @param  error
41550:    *         The error code to pass to the listeners
41550:    */
41584:   downloadFailed: function(aReason, aError) {
57401:     WARN("Download failed", aError);
41550:     this.state = AddonManager.STATE_DOWNLOAD_FAILED;
43491:     this.error = aReason;
41582:     XPIProvider.removeActiveInstall(this);
41550:     AddonManagerPrivate.callInstallListeners("onDownloadFailed", this.listeners,
43491:                                              this.wrapper);
57183: 
57183:     // If the listener hasn't restarted the download then remove any temporary
57183:     // file
57183:     if (this.state == AddonManager.STATE_DOWNLOAD_FAILED)
48669:       this.removeTemporaryFile();
41550:   },
41550: 
41550:   /**
41550:    * Notify listeners that the download completed.
41550:    */
41550:   downloadCompleted: function() {
41550:     let self = this;
41584:     XPIDatabase.getVisibleAddonForID(this.addon.id, function(aAddon) {
58192:       if (aAddon)
41584:         self.existingAddon = aAddon;
58192: 
58192:       self.state = AddonManager.STATE_DOWNLOADED;
51284:       self.addon.updateDate = Date.now();
58192: 
58192:       if (self.existingAddon) {
58192:         self.addon.existingAddonID = self.existingAddon.id;
58192:         self.addon.installDate = self.existingAddon.installDate;
70084:         applyBlocklistChanges(self.existingAddon, self.addon);
58192:       }
58192:       else {
58192:         self.addon.installDate = self.addon.updateDate;
58192:       }
58192: 
41550:       if (AddonManagerPrivate.callInstallListeners("onDownloadEnded",
41550:                                                    self.listeners,
48669:                                                    self.wrapper)) {
55372:         // If a listener changed our state then do not proceed with the install
55372:         if (self.state != AddonManager.STATE_DOWNLOADED)
55372:           return;
55372: 
41550:         self.install();
48669: 
48669:         if (self.linkedInstalls) {
48669:           self.linkedInstalls.forEach(function(aInstall) {
48669:             aInstall.install();
48669:           });
48669:         }
48669:       }
41550:     });
41550:   },
41550: 
41550:   // TODO This relies on the assumption that we are always installing into the
41550:   // highest priority install location so the resulting add-on will be visible
41550:   // overriding any existing copy in another install location (bug 557710).
41550:   /**
41550:    * Installs the add-on into the install location.
41550:    */
41550:   startInstall: function AI_startInstall() {
41550:     this.state = AddonManager.STATE_INSTALLING;
41550:     if (!AddonManagerPrivate.callInstallListeners("onInstallStarted",
41550:                                                   this.listeners, this.wrapper)) {
41550:       this.state = AddonManager.STATE_DOWNLOADED;
41582:       XPIProvider.removeActiveInstall(this);
41550:       AddonManagerPrivate.callInstallListeners("onInstallCancelled",
41550:                                                this.listeners, this.wrapper)
41550:       return;
41550:     }
41550: 
56059:     // Find and cancel any pending installs for the same add-on in the same
56059:     // install location
56059:     XPIProvider.installs.forEach(function(aInstall) {
56059:       if (aInstall.state == AddonManager.STATE_INSTALLED &&
56059:           aInstall.installLocation == this.installLocation &&
56059:           aInstall.addon.id == this.addon.id)
56059:         aInstall.cancel();
56059:     }, this);
56059: 
41550:     let isUpgrade = this.existingAddon &&
41550:                     this.existingAddon._installLocation == this.installLocation;
41550:     let requiresRestart = XPIProvider.installRequiresRestart(this.addon);
41550: 
47134:     LOG("Starting install of " + this.sourceURI.spec);
41550:     AddonManagerPrivate.callAddonListeners("onInstalling",
41550:                                            createWrapper(this.addon),
41550:                                            requiresRestart);
41550:     let stagedAddon = this.installLocation.getStagingDir();
41550: 
41550:     try {
41550:       // First stage the file regardless of whether restarting is necessary
52422:       if (this.addon.unpack || Prefs.getBoolPref(PREF_XPI_UNPACK, false)) {
52422:         LOG("Addon " + this.addon.id + " will be installed as " +
52422:             "an unpacked directory");
41550:         stagedAddon.append(this.addon.id);
41550:         if (stagedAddon.exists())
55436:           recursiveRemove(stagedAddon);
41550:         stagedAddon.create(Ci.nsIFile.DIRECTORY_TYPE, FileUtils.PERMS_DIRECTORY);
41550:         extractFiles(this.file, stagedAddon);
52422:       }
52422:       else {
52422:         LOG("Addon " + this.addon.id + " will be installed as " +
52422:             "a packed xpi");
52422:         stagedAddon.append(this.addon.id + ".xpi");
52422:         if (stagedAddon.exists())
52422:           stagedAddon.remove(true);
52422:         this.file.copyTo(this.installLocation.getStagingDir(),
52422:                          this.addon.id + ".xpi");
52422:       }
41550: 
41550:       if (requiresRestart) {
42883:         // Point the add-on to its extracted files as the xpi may get deleted
42883:         this.addon._sourceBundle = stagedAddon;
42883: 
41550:         // Cache the AddonInternal as it may have updated compatibiltiy info
56256:         let stagedJSON = stagedAddon.clone();
56256:         stagedJSON.leafName = this.addon.id + ".json";
41550:         if (stagedJSON.exists())
41550:           stagedJSON.remove(true);
41550:         let stream = Cc["@mozilla.org/network/file-output-stream;1"].
41550:                      createInstance(Ci.nsIFileOutputStream);
41550:         let converter = Cc["@mozilla.org/intl/converter-output-stream;1"].
41550:                         createInstance(Ci.nsIConverterOutputStream);
41550: 
41550:         try {
41550:           stream.init(stagedJSON, FileUtils.MODE_WRONLY | FileUtils.MODE_CREATE |
41550:                                   FileUtils.MODE_TRUNCATE, FileUtils.PERMS_FILE,
41550:                                  0);
41550:           converter.init(stream, "UTF-8", 0, 0x0000);
42843:           converter.writeString(JSON.stringify(this.addon));
41550:         }
41550:         finally {
41550:           converter.close();
41550:           stream.close();
41550:         }
41550: 
47134:         LOG("Install of " + this.sourceURI.spec + " completed.");
41550:         this.state = AddonManager.STATE_INSTALLED;
41565:         if (isUpgrade) {
41565:           delete this.existingAddon.pendingUpgrade;
41565:           this.existingAddon.pendingUpgrade = this.addon;
41565:         }
41550:         AddonManagerPrivate.callInstallListeners("onInstallEnded",
41550:                                                  this.listeners, this.wrapper,
41550:                                                  createWrapper(this.addon));
41550:       }
41550:       else {
42090:         // The install is completed so it should be removed from the active list
42090:         XPIProvider.removeActiveInstall(this);
42090: 
41550:         // TODO We can probably reduce the number of DB operations going on here
41550:         // We probably also want to support rolling back failed upgrades etc.
41550:         // See bug 553015.
41550: 
41550:         // Deactivate and remove the old add-on as necessary
41591:         let reason = BOOTSTRAP_REASONS.ADDON_INSTALL;
41550:         if (this.existingAddon) {
41591:           if (Services.vc.compare(this.existingAddon.version, this.addon.version) < 0)
41591:             reason = BOOTSTRAP_REASONS.ADDON_UPGRADE;
41591:           else
41591:             reason = BOOTSTRAP_REASONS.ADDON_DOWNGRADE;
41591: 
41591:           if (this.existingAddon.bootstrap) {
52422:             let file = this.existingAddon._installLocation
41591:                            .getLocationForID(this.existingAddon.id);
41550:             if (this.existingAddon.active) {
41591:               XPIProvider.callBootstrapMethod(this.existingAddon.id,
41591:                                               this.existingAddon.version,
79913:                                               this.existingAddon.type, file,
79913:                                               "shutdown", reason);
41591:             }
71854: 
41591:             XPIProvider.callBootstrapMethod(this.existingAddon.id,
41591:                                             this.existingAddon.version,
79913:                                             this.existingAddon.type, file,
79913:                                             "uninstall", reason);
41591:             XPIProvider.unloadBootstrapScope(this.existingAddon.id);
71854:             flushStartupCache();
41591:           }
41591: 
56256:           if (!isUpgrade && this.existingAddon.active) {
41550:             this.existingAddon.active = false;
41550:             XPIDatabase.updateAddonActive(this.existingAddon);
41550:           }
41550:         }
41550: 
52422:         // Install the new add-on into its final location
58192:         let existingAddonID = this.existingAddon ? this.existingAddon.id : null;
58192:         let file = this.installLocation.installAddon(this.addon.id, stagedAddon,
58192:                                                      existingAddonID);
56256:         cleanStagingDir(stagedAddon.parent, []);
41550: 
41550:         // Update the metadata in the database
60290:         this.addon._sourceBundle = file;
41550:         this.addon._installLocation = this.installLocation;
55169:         this.addon.updateDate = recursiveLastModifiedTime(file);
41550:         this.addon.visible = true;
41550:         if (isUpgrade) {
41550:           XPIDatabase.updateAddonMetadata(this.existingAddon, this.addon,
52422:                                           file.persistentDescriptor);
41550:         }
41550:         else {
63356:           this.addon.installDate = this.addon.updateDate;
70084:           this.addon.active = (this.addon.visible && !isAddonDisabled(this.addon))
52422:           XPIDatabase.addAddonMetadata(this.addon, file.persistentDescriptor);
41550:         }
41550: 
41550:         // Retrieve the new DBAddonInternal for the add-on we just added
41550:         let self = this;
41550:         XPIDatabase.getAddonInLocation(this.addon.id, this.installLocation.name,
41550:                                        function(a) {
41550:           self.addon = a;
41591:           if (self.addon.bootstrap) {
41591:             XPIProvider.callBootstrapMethod(self.addon.id, self.addon.version,
79913:                                             self.addon.type, file, "install",
79913:                                             reason);
41591:             if (self.addon.active) {
41591:               XPIProvider.callBootstrapMethod(self.addon.id, self.addon.version,
79913:                                               self.addon.type, file, "startup",
79913:                                               reason);
41591:             }
41591:             else {
42911:               XPIProvider.unloadBootstrapScope(self.addon.id);
41591:             }
41591:           }
41550:           AddonManagerPrivate.callAddonListeners("onInstalled",
41550:                                                  createWrapper(self.addon));
41550: 
47134:           LOG("Install of " + self.sourceURI.spec + " completed.");
41550:           self.state = AddonManager.STATE_INSTALLED;
41550:           AddonManagerPrivate.callInstallListeners("onInstallEnded",
41550:                                                    self.listeners, self.wrapper,
41550:                                                    createWrapper(self.addon));
41550:         });
41550:       }
41550:     }
41550:     catch (e) {
57401:       WARN("Failed to install", e);
41550:       if (stagedAddon.exists())
55436:         recursiveRemove(stagedAddon);
41550:       this.state = AddonManager.STATE_INSTALL_FAILED;
43491:       this.error = AddonManager.ERROR_FILE_ACCESS;
41582:       XPIProvider.removeActiveInstall(this);
41550:       AddonManagerPrivate.callInstallListeners("onInstallFailed",
41550:                                                this.listeners,
43491:                                                this.wrapper);
41550:     }
41550:     finally {
48669:       this.removeTemporaryFile();
42883:     }
52112:   },
52112: 
52112:   getInterface: function(iid) {
52112:     if (iid.equals(Ci.nsIAuthPrompt2)) {
52112:       var factory = Cc["@mozilla.org/prompter;1"].
52112:                     getService(Ci.nsIPromptFactory);
53954:       return factory.getPrompt(this.window, Ci.nsIAuthPrompt);
52112:     }
52112:     else if (iid.equals(Ci.nsIChannelEventSink)) {
52112:       return this;
52112:     }
52112: 
52112:     return this.badCertHandler.getInterface(iid);
41550:   }
41550: }
41550: 
41550: /**
72311:  * Creates a new AddonInstall for an already staged install. Used when
72311:  * installing the staged install failed for some reason.
72311:  *
72311:  * @param  aDir
72311:  *         The directory holding the staged install
72311:  * @param  aManifest
72311:  *         The cached manifest for the install
72311:  */
72311: AddonInstall.createStagedInstall = function(aInstallLocation, aDir, aManifest) {
72311:   let url = Services.io.newFileURI(aDir);
72311: 
72311:   let install = new AddonInstall(aInstallLocation, aDir);
72311:   install.initStagedInstall(aManifest);
72311: };
72311: 
72311: /**
41550:  * Creates a new AddonInstall to install an add-on from a local file. Installs
41550:  * always go into the profile install location.
41550:  *
41584:  * @param  aCallback
41550:  *         The callback to pass the new AddonInstall to
41584:  * @param  aFile
41550:  *         The file to install
41550:  */
41584: AddonInstall.createInstall = function(aCallback, aFile) {
41550:   let location = XPIProvider.installLocationsByName[KEY_APP_PROFILE];
41584:   let url = Services.io.newFileURI(aFile);
41550: 
41550:   try {
72311:     let install = new AddonInstall(location, url);
72311:     install.initLocalInstall(aCallback);
41550:   }
41550:   catch(e) {
57401:     ERROR("Error creating install", e);
41584:     aCallback(null);
41550:   }
41550: };
41550: 
41550: /**
41550:  * Creates a new AddonInstall to download and install a URL.
41550:  *
41584:  * @param  aCallback
41550:  *         The callback to pass the new AddonInstall to
41584:  * @param  aUri
41550:  *         The URI to download
41584:  * @param  aHash
41550:  *         A hash for the add-on
41584:  * @param  aName
41550:  *         A name for the add-on
41584:  * @param  aIconURL
41550:  *         An icon URL for the add-on
41584:  * @param  aVersion
41550:  *         A version for the add-on
41584:  * @param  aLoadGroup
41550:  *         An nsILoadGroup to associate the download with
41550:  */
41584: AddonInstall.createDownload = function(aCallback, aUri, aHash, aName, aIconURL,
41584:                                        aVersion, aLoadGroup) {
41550:   let location = XPIProvider.installLocationsByName[KEY_APP_PROFILE];
41584:   let url = NetUtil.newURI(aUri);
72311: 
72311:   let install = new AddonInstall(location, url, aHash, null, null, aLoadGroup);
72311:   if (url instanceof Ci.nsIFileURL)
72311:     install.initLocalInstall(aCallback);
72311:   else
72311:     install.initAvailableDownload(aName, null, aIconURL, aVersion, aCallback);
41550: };
41550: 
41550: /**
41550:  * Creates a new AddonInstall for an update.
41550:  *
41584:  * @param  aCallback
41550:  *         The callback to pass the new AddonInstall to
41584:  * @param  aAddon
41550:  *         The add-on being updated
41584:  * @param  aUpdate
41550:  *         The metadata about the new version from the update manifest
41550:  */
41584: AddonInstall.createUpdate = function(aCallback, aAddon, aUpdate) {
41584:   let url = NetUtil.newURI(aUpdate.updateURL);
47135:   let releaseNotesURI = null;
47135:   try {
41584:     if (aUpdate.updateInfoURL)
47135:       releaseNotesURI = NetUtil.newURI(escapeAddonURI(aAddon, aUpdate.updateInfoURL));
47135:   }
47135:   catch (e) {
47135:     // If the releaseNotesURI cannot be parsed then just ignore it.
47135:   }
72311: 
72311:   let install = new AddonInstall(aAddon._installLocation, url,
72311:                                  aUpdate.updateHash, releaseNotesURI, aAddon);
72311:   if (url instanceof Ci.nsIFileURL) {
72311:     install.initLocalInstall(aCallback);
72311:   }
72311:   else {
72311:     install.initAvailableDownload(aAddon.selectedLocale.name, aAddon.type,
72311:                                   aAddon.iconURL, aUpdate.version, aCallback);
72311:   }
41550: };
41550: 
41550: /**
41550:  * Creates a wrapper for an AddonInstall that only exposes the public API
41550:  *
41550:  * @param  install
41550:  *         The AddonInstall to create a wrapper for
41550:  */
41584: function AddonInstallWrapper(aInstall) {
47135:   ["name", "type", "version", "iconURL", "releaseNotesURI", "file", "state", "error",
43491:    "progress", "maxProgress", "certificate", "certName"].forEach(function(aProp) {
41584:     this.__defineGetter__(aProp, function() aInstall[aProp]);
41550:   }, this);
41550: 
41550:   this.__defineGetter__("existingAddon", function() {
41584:     return createWrapper(aInstall.existingAddon);
41550:   });
41584:   this.__defineGetter__("addon", function() createWrapper(aInstall.addon));
47134:   this.__defineGetter__("sourceURI", function() aInstall.sourceURI);
41550: 
48669:   this.__defineGetter__("linkedInstalls", function() {
48669:     if (!aInstall.linkedInstalls)
48669:       return null;
48669:     return [i.wrapper for each (i in aInstall.linkedInstalls)];
48669:   });
48669: 
41550:   this.install = function() {
41584:     aInstall.install();
41550:   }
41550: 
41550:   this.cancel = function() {
41584:     aInstall.cancel();
41550:   }
41550: 
41550:   this.addListener = function(listener) {
41584:     aInstall.addListener(listener);
41550:   }
41550: 
41550:   this.removeListener = function(listener) {
41584:     aInstall.removeListener(listener);
41550:   }
41550: }
41550: 
41550: AddonInstallWrapper.prototype = {};
41550: 
41550: /**
41550:  * Creates a new update checker.
41550:  *
41584:  * @param  aAddon
41550:  *         The add-on to check for updates
41584:  * @param  aListener
41550:  *         An UpdateListener to notify of updates
41584:  * @param  aReason
41550:  *         The reason for the update check
41584:  * @param  aAppVersion
41550:  *         An optional application version to check for updates for
41584:  * @param  aPlatformVersion
41550:  *         An optional platform version to check for updates for
41584:  * @throws if the aListener or aReason arguments are not valid
41550:  */
41584: function UpdateChecker(aAddon, aListener, aReason, aAppVersion, aPlatformVersion) {
41584:   if (!aListener || !aReason)
41550:     throw Cr.NS_ERROR_INVALID_ARG;
41550: 
41550:   Components.utils.import("resource://gre/modules/AddonUpdateChecker.jsm");
41550: 
41584:   this.addon = aAddon;
41584:   this.listener = aListener;
41584:   this.appVersion = aAppVersion;
41584:   this.platformVersion = aPlatformVersion;
41584:   this.syncCompatibility = (aReason == AddonManager.UPDATE_WHEN_NEW_APP_INSTALLED);
41584: 
41584:   let updateURL = aAddon.updateURL ? aAddon.updateURL :
41550:                                      Services.prefs.getCharPref(PREF_EM_UPDATE_URL);
41550: 
41550:   const UPDATE_TYPE_COMPATIBILITY = 32;
41550:   const UPDATE_TYPE_NEWVERSION = 64;
41550: 
41584:   aReason |= UPDATE_TYPE_COMPATIBILITY;
41550:   if ("onUpdateAvailable" in this.listener)
41584:     aReason |= UPDATE_TYPE_NEWVERSION;
41584: 
41584:   let url = escapeAddonURI(aAddon, updateURL, aReason, aAppVersion);
41584:   AddonUpdateChecker.checkForUpdates(aAddon.id, aAddon.type, aAddon.updateKey,
41584:                                      url, this);
41550: }
41550: 
41550: UpdateChecker.prototype = {
41550:   addon: null,
41550:   listener: null,
41550:   appVersion: null,
41550:   platformVersion: null,
41580:   syncCompatibility: null,
41550: 
41550:   /**
53710:    * Calls a method on the listener passing any number of arguments and
53710:    * consuming any exceptions.
53710:    *
53710:    * @param  aMethod
53710:    *         The method to call on the listener
53710:    */
53710:   callListener: function(aMethod) {
53710:     if (!(aMethod in this.listener))
53710:       return;
53710: 
53710:     let args = Array.slice(arguments, 1);
53710:     try {
53710:       this.listener[aMethod].apply(this.listener, args);
53710:     }
53710:     catch (e) {
53710:       LOG("Exception calling UpdateListener method " + aMethod + ": " + e);
53710:     }
53710:   },
53710: 
53710:   /**
41550:    * Called when AddonUpdateChecker completes the update check
41550:    *
41550:    * @param  updates
41550:    *         The list of update details for the add-on
41550:    */
41584:   onUpdateCheckComplete: function UC_onUpdateCheckComplete(aUpdates) {
41550:     let AUC = AddonUpdateChecker;
41580: 
83134:     let ignoreMaxVersion = false;
83135:     let ignoreStrictCompat = false;
83134:     if (!XPIProvider.checkCompatibility) {
83134:       ignoreMaxVersion = true;
83135:       ignoreStrictCompat = true;
83134:     } else if (this.addon.type == "extension" &&
83134:                !AddonManager.strictCompatibility &&
83134:                !this.addon.strictCompatibility &&
83134:                !this.addon.hasBinaryComponents) {
83134:       ignoreMaxVersion = true;
83134:     }
83134: 
41580:     // Always apply any compatibility update for the current version
41584:     let compatUpdate = AUC.getCompatibilityUpdate(aUpdates, this.addon.version,
83134:                                                   this.syncCompatibility,
83134:                                                   null, null,
83135:                                                   ignoreMaxVersion,
83135:                                                   ignoreStrictCompat);
41580:     // Apply the compatibility update to the database
41580:     if (compatUpdate)
41580:       this.addon.applyCompatibilityUpdate(compatUpdate, this.syncCompatibility);
41580: 
41580:     // If the request is for an application or platform version that is
41580:     // different to the current application or platform version then look for a
41580:     // compatibility update for those versions.
41580:     if ((this.appVersion &&
41580:          Services.vc.compare(this.appVersion, Services.appinfo.version) != 0) ||
41580:         (this.platformVersion &&
41580:          Services.vc.compare(this.platformVersion, Services.appinfo.platformVersion) != 0)) {
41584:       compatUpdate = AUC.getCompatibilityUpdate(aUpdates, this.addon.version,
41580:                                                 false, this.appVersion,
83134:                                                 this.platformVersion,
83135:                                                 ignoreMaxVersion,
83135:                                                 ignoreStrictCompat);
41580:     }
41580: 
53710:     if (compatUpdate)
53710:       this.callListener("onCompatibilityUpdateAvailable", createWrapper(this.addon));
53710:     else
53710:       this.callListener("onNoCompatibilityUpdateAvailable", createWrapper(this.addon));
53710: 
53710:     function sendUpdateAvailableMessages(aSelf, aInstall) {
53710:       if (aInstall) {
53710:         aSelf.callListener("onUpdateAvailable", createWrapper(aSelf.addon),
53710:                            aInstall.wrapper);
53710:       }
53710:       else {
53710:         aSelf.callListener("onNoUpdateAvailable", createWrapper(aSelf.addon));
53710:       }
53710:       aSelf.callListener("onUpdateFinished", createWrapper(aSelf.addon),
53710:                          AddonManager.UPDATE_STATUS_NO_ERROR);
41550:     }
41568: 
83134:     let compatOverrides = AddonManager.strictCompatibility ?
83134:                             null :
83134:                             this.addon.compatibilityOverrides;
83134: 
41584:     let update = AUC.getNewestCompatibleUpdate(aUpdates,
41568:                                                this.appVersion,
83134:                                                this.platformVersion,
83134:                                                ignoreMaxVersion,
83135:                                                ignoreStrictCompat,
83134:                                                compatOverrides);
53710: 
41550:     if (update && Services.vc.compare(this.addon.version, update.version) < 0) {
53710:       for (let i = 0; i < XPIProvider.installs.length; i++) {
53710:         // Skip installs that don't match the available update
53710:         if (XPIProvider.installs[i].existingAddon != this.addon ||
53710:             XPIProvider.installs[i].version != update.version)
53710:           continue;
53710: 
53710:         // If the existing install has not yet started downloading then send an
53710:         // available update notification. If it is already downloading then
53710:         // don't send any available update notification
53710:         if (XPIProvider.installs[i].state == AddonManager.STATE_AVAILABLE)
53710:           sendUpdateAvailableMessages(this, XPIProvider.installs[i]);
53710:         else
53710:           sendUpdateAvailableMessages(this, null);
53710:         return;
53710:       }
53710: 
41550:       let self = this;
53710:       AddonInstall.createUpdate(function(aInstall) {
53710:         sendUpdateAvailableMessages(self, aInstall);
41550:       }, this.addon, update);
41550:     }
41568:     else {
53710:       sendUpdateAvailableMessages(this, null);
41568:     }
41550:   },
41550: 
41550:   /**
41550:    * Called when AddonUpdateChecker fails the update check
41550:    *
53710:    * @param  aError
41550:    *         An error status
41550:    */
41584:   onUpdateCheckError: function UC_onUpdateCheckError(aError) {
53710:     this.callListener("onNoCompatibilityUpdateAvailable", createWrapper(this.addon));
53710:     this.callListener("onNoUpdateAvailable", createWrapper(this.addon));
53710:     this.callListener("onUpdateFinished", createWrapper(this.addon), aError);
41550:   }
41550: };
41550: 
41550: /**
41550:  * The AddonInternal is an internal only representation of add-ons. It may
41550:  * have come from the database (see DBAddonInternal below) or an install
41550:  * manifest.
41550:  */
41550: function AddonInternal() {
41550: }
41550: 
41550: AddonInternal.prototype = {
41550:   _selectedLocale: null,
41550:   active: false,
41550:   visible: false,
41550:   userDisabled: false,
41550:   appDisabled: false,
70084:   softDisabled: false,
47133:   sourceURI: null,
47133:   releaseNotesURI: null,
80772:   foreignInstall: false,
41550: 
82652:   get isForeignInstall() {
82652:     return this.foreignInstall;
82652:   },
82652:   set isForeignInstall(aVal) {
82652:     this.foreignInstall = aVal;
82652:   },
82652: 
41550:   get selectedLocale() {
41550:     if (this._selectedLocale)
41550:       return this._selectedLocale;
41550:     let locale = findClosestLocale(this.locales);
41550:     this._selectedLocale = locale ? locale : this.defaultLocale;
41550:     return this._selectedLocale;
41550:   },
41550: 
41550:   get providesUpdatesSecurely() {
41550:     return !!(this.updateKey || !this.updateURL ||
41550:               this.updateURL.substring(0, 6) == "https:");
41550:   },
41550: 
41550:   get isCompatible() {
41580:     return this.isCompatibleWith();
41580:   },
41580: 
47136:   get isPlatformCompatible() {
47136:     if (this.targetPlatforms.length == 0)
47136:       return true;
47136: 
47136:     let matchedOS = false;
47136: 
47136:     // If any targetPlatform matches the OS and contains an ABI then we will
47136:     // only match a targetPlatform that contains both the current OS and ABI
47136:     let needsABI = false;
47136: 
47136:     // Some platforms do not specify an ABI, test against null in that case.
47136:     let abi = null;
47136:     try {
47136:       abi = Services.appinfo.XPCOMABI;
47136:     }
47136:     catch (e) { }
47136: 
47136:     for (let i = 0; i < this.targetPlatforms.length; i++) {
47136:       let platform = this.targetPlatforms[i];
47136:       if (platform.os == Services.appinfo.OS) {
47136:         if (platform.abi) {
47136:           needsABI = true;
47136:           if (platform.abi === abi)
47136:             return true;
47136:         }
47136:         else {
47136:           matchedOS = true;
47136:         }
47136:       }
47136:     }
47136: 
47136:     return matchedOS && !needsABI;
47136:   },
47136: 
41584:   isCompatibleWith: function(aAppVersion, aPlatformVersion) {
41550:     let app = this.matchingTargetApplication;
41550:     if (!app)
41550:       return false;
41550: 
41584:     if (!aAppVersion)
41584:       aAppVersion = Services.appinfo.version;
41584:     if (!aPlatformVersion)
41584:       aPlatformVersion = Services.appinfo.platformVersion;
41580: 
41550:     let version;
41550:     if (app.id == Services.appinfo.ID)
41584:       version = aAppVersion;
41550:     else if (app.id == TOOLKIT_ID)
41584:       version = aPlatformVersion
41550: 
82275:     // Only extensions can be compatible by default; themes and language packs
82275:     // always use strict compatibility checking.
82275:     if (this.type == "extension" && !AddonManager.strictCompatibility &&
82275:         !this.strictCompatibility && !this.hasBinaryComponents) {
82276: 
83133:       // The repository can specify compatibility overrides.
83133:       // Note: For now, only blacklisting is supported by overrides.
83133:       if (this._repositoryAddon &&
83133:           this._repositoryAddon.compatibilityOverrides) {
83133:         let overrides = this._repositoryAddon.compatibilityOverrides;
83133:         let override = AddonRepository.findMatchingCompatOverride(this.version,
83133:                                                                   overrides);
83133:         if (override && override.type == "incompatible")
83133:           return false;
83133:       }
83133: 
82276:       // Extremely old extensions should not be compatible by default.
82276:       let minCompatVersion;
82276:       if (app.id == Services.appinfo.ID)
82276:         minCompatVersion = XPIProvider.minCompatibleAppVersion;
82276:       else if (app.id == TOOLKIT_ID)
82276:         minCompatVersion = XPIProvider.minCompatiblePlatformVersion;
82276: 
82276:       if (minCompatVersion &&
82276:           Services.vc.compare(minCompatVersion, app.maxVersion) > 0)
82276:         return false;
82276: 
82275:       return Services.vc.compare(version, app.minVersion) >= 0;
82275:     }
82275: 
41550:     return (Services.vc.compare(version, app.minVersion) >= 0) &&
41550:            (Services.vc.compare(version, app.maxVersion) <= 0)
41550:   },
41550: 
41550:   get matchingTargetApplication() {
41550:     let app = null;
41550:     for (let i = 0; i < this.targetApplications.length; i++) {
41550:       if (this.targetApplications[i].id == Services.appinfo.ID)
41550:         return this.targetApplications[i];
41550:       if (this.targetApplications[i].id == TOOLKIT_ID)
41550:         app = this.targetApplications[i];
41550:     }
41550:     return app;
41550:   },
41550: 
41550:   get blocklistState() {
41550:     let bs = Cc["@mozilla.org/extensions/blocklist;1"].
41550:              getService(Ci.nsIBlocklistService);
41550:     return bs.getAddonBlocklistState(this.id, this.version);
41550:   },
41550: 
70883:   get blocklistURL() {
70883:     let bs = Cc["@mozilla.org/extensions/blocklist;1"].
70883:              getService(Ci.nsIBlocklistService);
70883:     return bs.getAddonBlocklistURL(this.id, this.version);
70883:   },
70883: 
41584:   applyCompatibilityUpdate: function(aUpdate, aSyncCompatibility) {
41584:     this.targetApplications.forEach(function(aTargetApp) {
41584:       aUpdate.targetApplications.forEach(function(aUpdateTarget) {
41584:         if (aTargetApp.id == aUpdateTarget.id && (aSyncCompatibility ||
41584:             Services.vc.compare(aTargetApp.maxVersion, aUpdateTarget.maxVersion) < 0)) {
41584:           aTargetApp.minVersion = aUpdateTarget.minVersion;
41584:           aTargetApp.maxVersion = aUpdateTarget.maxVersion;
41550:         }
41550:       });
41550:     });
41550:     this.appDisabled = !isUsableAddon(this);
42843:   },
42843: 
42844:   /**
42844:    * toJSON is called by JSON.stringify in order to create a filtered version
42844:    * of this object to be serialized to a JSON file. A new object is returned
42844:    * with copies of all non-private properties. Functions, getters and setters
42844:    * are not copied.
42844:    *
42844:    * @param  aKey
42844:    *         The key that this object is being serialized as in the JSON.
42844:    *         Unused here since this is always the main object serialized
42844:    *
42844:    * @return an object containing copies of the properties of this object
42844:    *         ignoring private properties, functions, getters and setters
42844:    */
42844:   toJSON: function(aKey) {
42843:     let obj = {};
42843:     for (let prop in this) {
42843:       // Ignore private properties
42843:       if (prop.substring(0, 1) == "_")
42843:         continue;
42843: 
42843:       // Ignore getters
42843:       if (this.__lookupGetter__(prop))
42843:         continue;
42843: 
42843:       // Ignore setters
42843:       if (this.__lookupSetter__(prop))
42843:         continue;
42843: 
42843:       // Ignore functions
42843:       if (typeof this[prop] == "function")
42843:         continue;
42843: 
42843:       obj[prop] = this[prop];
42843:     }
42843: 
42843:     return obj;
72029:   },
72029: 
72029:   /**
79395:    * When an add-on install is pending its metadata will be cached in a file.
79395:    * This method reads particular properties of that metadata that may be newer
79395:    * than that in the install manifest, like compatibility information.
72029:    *
72029:    * @param  aObj
79395:    *         A JS object containing the cached metadata
79395:    */
79395:   importMetadata: function(aObj) {
86022:     ["syncGUID", "targetApplications", "userDisabled", "softDisabled",
86022:      "existingAddonID", "sourceURI", "releaseNotesURI", "installDate",
86022:      "updateDate", "applyBackgroundUpdates", "compatibilityOverrides"]
86022:     .forEach(function(aProp) {
79395:       if (!(aProp in aObj))
79395:         return;
79395: 
79395:       this[aProp] = aObj[aProp];
79395:     }, this);
79395: 
79395:     // Compatibility info may have changed so update appDisabled
79395:     this.appDisabled = !isUsableAddon(this);
41550:   }
41550: };
41550: 
41550: /**
41550:  * The DBAddonInternal is a special AddonInternal that has been retrieved from
41550:  * the database. Add-ons retrieved synchronously only have the basic metadata
41550:  * the rest is filled out synchronously when needed. Asynchronously read add-ons
41550:  * have all data available.
41550:  */
41550: function DBAddonInternal() {
41550:   this.__defineGetter__("targetApplications", function() {
41550:     delete this.targetApplications;
41550:     return this.targetApplications = XPIDatabase._getTargetApplications(this);
41550:   });
41550: 
47133:   this.__defineGetter__("targetPlatforms", function() {
47133:     delete this.targetPlatforms;
47133:     return this.targetPlatforms = XPIDatabase._getTargetPlatforms(this);
47133:   });
47133: 
41550:   this.__defineGetter__("locales", function() {
41550:     delete this.locales;
41550:     return this.locales = XPIDatabase._getLocales(this);
41550:   });
41550: 
41550:   this.__defineGetter__("defaultLocale", function() {
41550:     delete this.defaultLocale;
41550:     return this.defaultLocale = XPIDatabase._getDefaultLocale(this);
41550:   });
41565: 
41565:   this.__defineGetter__("pendingUpgrade", function() {
41565:     delete this.pendingUpgrade;
41565:     for (let i = 0; i < XPIProvider.installs.length; i++) {
41565:       let install = XPIProvider.installs[i];
41565:       if (install.state == AddonManager.STATE_INSTALLED &&
41565:           !(install.addon instanceof DBAddonInternal) &&
41565:           install.addon.id == this.id &&
41565:           install.installLocation == this._installLocation) {
41565:         return this.pendingUpgrade = install.addon;
41565:       }
41565:     };
41565:   });
41550: }
41550: 
41550: DBAddonInternal.prototype = {
41584:   applyCompatibilityUpdate: function(aUpdate, aSyncCompatibility) {
41550:     let changes = [];
41584:     this.targetApplications.forEach(function(aTargetApp) {
41584:       aUpdate.targetApplications.forEach(function(aUpdateTarget) {
41584:         if (aTargetApp.id == aUpdateTarget.id && (aSyncCompatibility ||
41584:             Services.vc.compare(aTargetApp.maxVersion, aUpdateTarget.maxVersion) < 0)) {
41584:           aTargetApp.minVersion = aUpdateTarget.minVersion;
41584:           aTargetApp.maxVersion = aUpdateTarget.maxVersion;
41584:           changes.push(aUpdateTarget);
41550:         }
41550:       });
41550:     });
42885:     try {
41550:       XPIDatabase.updateTargetApplications(this, changes);
42885:     }
42885:     catch (e) {
42885:       // A failure just means that we discard the compatibility update
42885:       ERROR("Failed to update target application info in the database for " +
57401:             "add-on " + this.id, e);
42885:       return;
42885:     }
41550:     XPIProvider.updateAddonDisabledState(this);
41550:   }
41550: }
41550: 
41550: DBAddonInternal.prototype.__proto__ = AddonInternal.prototype;
41550: 
41550: /**
41550:  * Creates an AddonWrapper for an AddonInternal.
41550:  *
41550:  * @param   addon
41550:  *          The AddonInternal to wrap
41550:  * @return  an AddonWrapper or null if addon was null
41550:  */
41584: function createWrapper(aAddon) {
41584:   if (!aAddon)
41550:     return null;
42843:   if (!aAddon._wrapper)
42843:     aAddon._wrapper = new AddonWrapper(aAddon);
42843:   return aAddon._wrapper;
41550: }
41550: 
41550: /**
41550:  * The AddonWrapper wraps an Addon to provide the data visible to consumers of
41550:  * the public API.
41550:  */
41584: function AddonWrapper(aAddon) {
51520:   function chooseValue(aObj, aProp) {
51520:     let repositoryAddon = aAddon._repositoryAddon;
51520:     let objValue = aObj[aProp];
51520: 
51520:     if (repositoryAddon && (aProp in repositoryAddon) &&
51520:         (objValue === undefined || objValue === null)) {
51520:       return [repositoryAddon[aProp], true];
51520:     }
51520: 
51520:     return [objValue, false];
51520:   }
51520: 
82404:   ["id", "syncGUID", "version", "type", "isCompatible", "isPlatformCompatible",
70883:    "providesUpdatesSecurely", "blocklistState", "blocklistURL", "appDisabled",
81117:    "softDisabled", "skinnable", "size", "foreignInstall", "hasBinaryComponents",
83133:    "strictCompatibility", "compatibilityOverrides"].forEach(function(aProp) {
41584:      this.__defineGetter__(aProp, function() aAddon[aProp]);
41550:   }, this);
41550: 
51520:   ["fullDescription", "developerComments", "eula", "supportURL",
51520:    "contributionURL", "contributionAmount", "averageRating", "reviewCount",
51520:    "reviewURL", "totalDownloads", "weeklyDownloads", "dailyUsers",
51520:    "repositoryStatus"].forEach(function(aProp) {
51520:     this.__defineGetter__(aProp, function() {
51520:       if (aAddon._repositoryAddon)
51520:         return aAddon._repositoryAddon[aProp];
51520: 
51520:       return null;
51520:     });
51520:   }, this);
51520: 
71220:   this.__defineGetter__("aboutURL", function() {
71220:     return this.isActive ? aAddon["aboutURL"] : null;
42825:   });
42825: 
41584:   ["installDate", "updateDate"].forEach(function(aProp) {
41584:     this.__defineGetter__(aProp, function() new Date(aAddon[aProp]));
41550:   }, this);
41550: 
47133:   ["sourceURI", "releaseNotesURI"].forEach(function(aProp) {
47133:     this.__defineGetter__(aProp, function() {
51520:       let target = chooseValue(aAddon, aProp)[0];
51520:       if (!target)
47133:         return null;
51520:       return NetUtil.newURI(target);
47133:     });
47133:   }, this);
47133: 
71220:   // Maps iconURL, icon64URL and optionsURL to the properties of the same name
71220:   // or icon.png, icon64.png and options.xul in the add-on's files.
71220:   ["icon", "icon64", "options"].forEach(function(aProp) {
51834:     this.__defineGetter__(aProp + "URL", function() {
54988:       if (this.isActive && aAddon[aProp + "URL"])
51834:         return aAddon[aProp + "URL"];
51834: 
71220:       switch (aProp) {
71220:         case "icon":
71220:         case "icon64":
51834:           if (this.hasResource(aProp + ".png"))
51834:             return this.getResourceURI(aProp + ".png").spec;
71220:           break;
71220:         case "options":
71220:           if (this.isActive && this.hasResource(aProp + ".xul"))
71220:             return this.getResourceURI(aProp + ".xul").spec;
71220:           break;
71220:       }
42843: 
51520:       if (aAddon._repositoryAddon)
51834:         return aAddon._repositoryAddon[aProp + "URL"];
51520: 
42843:       return null;
42843:     }, this);
51834:   }, this);
41550: 
71220:   this.__defineGetter__("optionsType", function() {
71220:     if (!this.isActive)
71220:       return null;
71220: 
71220:     if (aAddon.optionsType)
71220:       return aAddon.optionsType;
71220: 
71220:     if (this.hasResource("options.xul"))
71220:       return AddonManager.OPTIONS_TYPE_INLINE;
71220: 
71220:     if (this.optionsURL)
71220:       return AddonManager.OPTIONS_TYPE_DIALOG;
71220: 
71220:     return null;
71220:   }, this);
71220: 
41584:   PROP_LOCALE_SINGLE.forEach(function(aProp) {
41584:     this.__defineGetter__(aProp, function() {
51520:       // Override XPI creator if repository creator is defined
51520:       if (aProp == "creator" &&
51520:           aAddon._repositoryAddon && aAddon._repositoryAddon.creator) {
51520:         return aAddon._repositoryAddon.creator;
51520:       }
51520: 
51520:       let result = null;
51520: 
41584:       if (aAddon.active) {
41577:         try {
41584:           let pref = PREF_EM_EXTENSION_FORMAT + aAddon.id + "." + aProp;
41577:           let value = Services.prefs.getComplexValue(pref,
41577:                                                      Ci.nsIPrefLocalizedString);
41577:           if (value.data)
51520:             result = value.data;
41577:         }
41577:         catch (e) {
41577:         }
41577:       }
51520: 
51520:       if (result == null)
51520:         [result, ] = chooseValue(aAddon.selectedLocale, aProp);
51520: 
51520:       if (aProp == "creator")
51520:         return result ? new AddonManagerPrivate.AddonAuthor(result) : null;
51520: 
51520:       return result;
41577:     });
41550:   }, this);
41550: 
41584:   PROP_LOCALE_MULTI.forEach(function(aProp) {
41584:     this.__defineGetter__(aProp, function() {
51520:       let results = null;
51520:       let usedRepository = false;
51520: 
41584:       if (aAddon.active) {
41584:         let pref = PREF_EM_EXTENSION_FORMAT + aAddon.id + "." +
41584:                    aProp.substring(0, aProp.length - 1);
41577:         let list = Services.prefs.getChildList(pref, {});
41577:         if (list.length > 0) {
58514:           list.sort();
51520:           results = [];
41584:           list.forEach(function(aPref) {
41584:             let value = Services.prefs.getComplexValue(aPref,
41577:                                                        Ci.nsIPrefLocalizedString);
41577:             if (value.data)
41577:               results.push(value.data);
41577:           });
51520:         }
51520:       }
51520: 
51520:       if (results == null)
51520:         [results, usedRepository] = chooseValue(aAddon.selectedLocale, aProp);
51520: 
51520:       if (results && !usedRepository) {
51520:         results = results.map(function(aResult) {
51520:           return new AddonManagerPrivate.AddonAuthor(aResult);
51520:         });
51520:       }
51520: 
41577:       return results;
41577:     });
41550:   }, this);
41550: 
41550:   this.__defineGetter__("screenshots", function() {
51520:     let repositoryAddon = aAddon._repositoryAddon;
51520:     if (repositoryAddon && ("screenshots" in repositoryAddon)) {
51520:       let repositoryScreenshots = repositoryAddon.screenshots;
51520:       if (repositoryScreenshots && repositoryScreenshots.length > 0)
51520:         return repositoryScreenshots;
51520:     }
51520: 
51520:     if (aAddon.type == "theme" && this.hasResource("preview.png")) {
51520:       let url = this.getResourceURI("preview.png").spec;
51520:       return [new AddonManagerPrivate.AddonScreenshot(url)];
51520:     }
51520: 
51520:     return null;
41550:   });
41550: 
41586:   this.__defineGetter__("applyBackgroundUpdates", function() {
41586:     return aAddon.applyBackgroundUpdates;
41550:   });
41586:   this.__defineSetter__("applyBackgroundUpdates", function(val) {
53775:     if (val != AddonManager.AUTOUPDATE_DEFAULT &&
53775:         val != AddonManager.AUTOUPDATE_DISABLE &&
53775:         val != AddonManager.AUTOUPDATE_ENABLE) {
53775:       val = val ? AddonManager.AUTOUPDATE_DEFAULT :
53775:                   AddonManager.AUTOUPDATE_DISABLE;
53775:     }
53775: 
47349:     if (val == aAddon.applyBackgroundUpdates)
47349:       return val;
47349: 
41586:     XPIDatabase.setAddonProperties(aAddon, {
41586:       applyBackgroundUpdates: val
41586:     });
47349:     AddonManagerPrivate.callAddonListeners("onPropertyChanged", this, ["applyBackgroundUpdates"]);
47349: 
47349:     return val;
41550:   });
41550: 
82404:   this.__defineSetter__("syncGUID", function(val) {
82404:     if (aAddon.syncGUID == val)
82404:       return val;
82404: 
84963:     if (aAddon instanceof DBAddonInternal)
82404:       XPIDatabase.setAddonSyncGUID(aAddon, val);
84963: 
82404:     aAddon.syncGUID = val;
82404: 
82404:     return val;
82404:   });
82404: 
41566:   this.__defineGetter__("install", function() {
41584:     if (!("_install" in aAddon) || !aAddon._install)
41566:       return null;
41584:     return aAddon._install.wrapper;
41566:   });
41566: 
41565:   this.__defineGetter__("pendingUpgrade", function() {
41584:     return createWrapper(aAddon.pendingUpgrade);
41565:   });
41565: 
41579:   this.__defineGetter__("scope", function() {
41584:     if (aAddon._installLocation)
41584:       return aAddon._installLocation.scope;
41579: 
41579:     return AddonManager.SCOPE_PROFILE;
41579:   });
41579: 
41550:   this.__defineGetter__("pendingOperations", function() {
41550:     let pending = 0;
51140:     if (!(aAddon instanceof DBAddonInternal)) {
51140:       // Add-on is pending install if there is no associated install (shouldn't
51140:       // happen here) or if the install is in the process of or has successfully
72311:       // completed the install. If an add-on is pending install then we ignore
72311:       // any other pending operations.
51140:       if (!aAddon._install || aAddon._install.state == AddonManager.STATE_INSTALLING ||
51140:           aAddon._install.state == AddonManager.STATE_INSTALLED)
72311:         return AddonManager.PENDING_INSTALL;
51140:     }
51140:     else if (aAddon.pendingUninstall) {
72311:       // If an add-on is pending uninstall then we ignore any other pending
72311:       // operations
72311:       return AddonManager.PENDING_UNINSTALL;
51140:     }
41550: 
70084:     if (aAddon.active && isAddonDisabled(aAddon))
41550:       pending |= AddonManager.PENDING_DISABLE;
70084:     else if (!aAddon.active && !isAddonDisabled(aAddon))
41550:       pending |= AddonManager.PENDING_ENABLE;
41550: 
41584:     if (aAddon.pendingUpgrade)
41565:       pending |= AddonManager.PENDING_UPGRADE;
41565: 
41550:     return pending;
41550:   });
41550: 
48205:   this.__defineGetter__("operationsRequiringRestart", function() {
48205:     let ops = 0;
48205:     if (XPIProvider.installRequiresRestart(aAddon))
48205:       ops |= AddonManager.OP_NEEDS_RESTART_INSTALL;
48205:     if (XPIProvider.uninstallRequiresRestart(aAddon))
48205:       ops |= AddonManager.OP_NEEDS_RESTART_UNINSTALL;
48205:     if (XPIProvider.enableRequiresRestart(aAddon))
48205:       ops |= AddonManager.OP_NEEDS_RESTART_ENABLE;
48205:     if (XPIProvider.disableRequiresRestart(aAddon))
48205:       ops |= AddonManager.OP_NEEDS_RESTART_DISABLE;
48205: 
48205:     return ops;
48205:   });
48205: 
41550:   this.__defineGetter__("permissions", function() {
41550:     let permissions = 0;
60306: 
60306:     // Add-ons that aren't installed cannot be modified in any way
60306:     if (!(aAddon instanceof DBAddonInternal))
60306:       return permissions;
60306: 
41584:     if (!aAddon.appDisabled) {
70084:       if (this.userDisabled)
41550:         permissions |= AddonManager.PERM_CAN_ENABLE;
41584:       else if (aAddon.type != "theme")
41550:         permissions |= AddonManager.PERM_CAN_DISABLE;
41550:     }
60306: 
60306:     // Add-ons that are in locked install locations, or are pending uninstall
60019:     // cannot be upgraded or uninstalled
60306:     if (!aAddon._installLocation.locked && !aAddon.pendingUninstall) {
60019:       // Add-ons that are installed by a file link cannot be upgraded
59206:       if (!aAddon._installLocation.isLinkedAddon(aAddon.id))
41550:         permissions |= AddonManager.PERM_CAN_UPGRADE;
59206: 
41550:       permissions |= AddonManager.PERM_CAN_UNINSTALL;
41550:     }
41550:     return permissions;
41550:   });
41550: 
54988:   this.__defineGetter__("isActive", function() {
54988:     if (Services.appinfo.inSafeMode)
54988:       return false;
54988:     return aAddon.active;
54988:   });
54988: 
70084:   this.__defineGetter__("userDisabled", function() {
70084:     return aAddon.softDisabled || aAddon.userDisabled;
70084:   });
41550:   this.__defineSetter__("userDisabled", function(val) {
70084:     if (val == this.userDisabled)
47349:       return val;
47349: 
48206:     if (aAddon instanceof DBAddonInternal) {
48206:       if (aAddon.type == "theme" && val) {
48206:         if (aAddon.internalName == XPIProvider.defaultSkin)
48206:           throw new Error("Cannot disable the default theme");
48206:         XPIProvider.enableDefaultTheme();
48206:       }
48206:       else {
41584:         XPIProvider.updateAddonDisabledState(aAddon, val);
48206:       }
48206:     }
48206:     else {
41584:       aAddon.userDisabled = val;
70084:       // When enabling remove the softDisabled flag
70084:       if (!val)
70084:         aAddon.softDisabled = false;
70084:     }
70084: 
70084:     return val;
70084:   });
70084: 
70084:   this.__defineSetter__("softDisabled", function(val) {
70084:     if (val == aAddon.softDisabled)
70084:       return val;
70084: 
70084:     if (aAddon instanceof DBAddonInternal) {
70084:       // When softDisabling a theme just enable the active theme
70084:       if (aAddon.type == "theme" && val && !aAddon.userDisabled) {
70084:         if (aAddon.internalName == XPIProvider.defaultSkin)
70084:           throw new Error("Cannot disable the default theme");
70084:         XPIProvider.enableDefaultTheme();
70084:       }
70084:       else {
70084:         XPIProvider.updateAddonDisabledState(aAddon, undefined, val);
70084:       }
70084:     }
70084:     else {
70084:       // Only set softDisabled if not already disabled
70084:       if (!aAddon.userDisabled)
70084:         aAddon.softDisabled = val;
48206:     }
47349: 
47349:     return val;
41550:   });
41550: 
41584:   this.isCompatibleWith = function(aAppVersion, aPlatformVersion) {
41584:     return aAddon.isCompatibleWith(aAppVersion, aPlatformVersion);
41580:   };
41580: 
41550:   this.uninstall = function() {
41584:     if (!(aAddon instanceof DBAddonInternal))
41550:       throw new Error("Cannot uninstall an add-on that isn't installed");
41584:     if (aAddon.pendingUninstall)
41550:       throw new Error("Add-on is already marked to be uninstalled");
41584:     XPIProvider.uninstallAddon(aAddon);
41550:   };
41550: 
41550:   this.cancelUninstall = function() {
41584:     if (!(aAddon instanceof DBAddonInternal))
41550:       throw new Error("Cannot cancel uninstall for an add-on that isn't installed");
41584:     if (!aAddon.pendingUninstall)
41550:       throw new Error("Add-on is not marked to be uninstalled");
41584:     XPIProvider.cancelUninstallAddon(aAddon);
41550:   };
41550: 
41584:   this.findUpdates = function(aListener, aReason, aAppVersion, aPlatformVersion) {
41584:     new UpdateChecker(aAddon, aListener, aReason, aAppVersion, aPlatformVersion);
41550:   };
41550: 
41584:   this.hasResource = function(aPath) {
60290:     let bundle = aAddon._sourceBundle.clone();
41550: 
41550:     if (bundle.isDirectory()) {
46204:       if (aPath) {
46204:         aPath.split("/").forEach(function(aPart) {
46204:           bundle.append(aPart);
46204:         });
46204:       }
41550:       return bundle.exists();
41550:     }
41550: 
41550:     let zipReader = Cc["@mozilla.org/libjar/zip-reader;1"].
41550:                     createInstance(Ci.nsIZipReader);
41550:     zipReader.open(bundle);
41584:     let result = zipReader.hasEntry(aPath);
41550:     zipReader.close();
41550:     return result;
41550:   },
41550: 
71854:   /**
71854:    * Returns a URI to the selected resource or to the add-on bundle if aPath
71854:    * is null. URIs to the bundle will always be file: URIs. URIs to resources
71854:    * will be file: URIs if the add-on is unpacked or jar: URIs if the add-on is
71854:    * still an XPI file.
71854:    *
71854:    * @param  aPath
71854:    *         The path in the add-on to get the URI for or null to get a URI to
71854:    *         the file or directory the add-on is installed as.
71854:    * @return an nsIURI
71854:    */
44136:   this.getResourceURI = function(aPath) {
46204:     if (!aPath)
71854:       return NetUtil.newURI(aAddon._sourceBundle);
71854: 
71854:     return getURIForResourceInFile(aAddon._sourceBundle, aPath);
41550:   }
41550: }
41550: 
41550: /**
41550:  * An object which identifies a directory install location for add-ons. The
41550:  * location consists of a directory which contains the add-ons installed in the
41550:  * location.
41550:  *
41550:  * Each add-on installed in the location is either a directory containing the
41550:  * add-on's files or a text file containing an absolute path to the directory
41550:  * containing the add-ons files. The directory or text file must have the same
41550:  * name as the add-on's ID.
41550:  *
41550:  * There may also a special directory named "staged" which can contain
41550:  * directories with the same name as an add-on ID. If the directory is empty
41550:  * then it means the add-on will be uninstalled from this location during the
41550:  * next startup. If the directory contains the add-on's files then they will be
41550:  * installed during the next startup.
41550:  *
41584:  * @param  aName
41550:  *         The string identifier for the install location
41584:  * @param  aDirectory
41550:  *         The nsIFile directory for the install location
41584:  * @param  aScope
41579:  *         The scope of add-ons installed in this location
41584:  * @param  aLocked
41550:  *         true if add-ons cannot be installed, uninstalled or upgraded in the
41550:  *         install location
41550:  */
41584: function DirectoryInstallLocation(aName, aDirectory, aScope, aLocked) {
41584:   this._name = aName;
41584:   this.locked = aLocked;
41584:   this._directory = aDirectory;
41584:   this._scope = aScope
52422:   this._IDToFileMap = {};
52422:   this._FileToIDMap = {};
59206:   this._linkedAddons = [];
41550: 
41584:   if (!aDirectory.exists())
41550:     return;
41584:   if (!aDirectory.isDirectory())
41550:     throw new Error("Location must be a directory.");
41550: 
41550:   this._readAddons();
41550: }
41550: 
41550: DirectoryInstallLocation.prototype = {
41550:   _name       : "",
41550:   _directory   : null,
52422:   _IDToFileMap : null,  // mapping from add-on ID to nsIFile
52422:   _FileToIDMap : null,  // mapping from add-on path to add-on ID
41550: 
41550:   /**
41550:    * Reads a directory linked to in a file.
41550:    *
41550:    * @param   file
41550:    *          The file containing the directory path
41550:    * @return  a nsILocalFile object representing the linked directory.
41550:    */
41584:   _readDirectoryFromFile: function DirInstallLocation__readDirectoryFromFile(aFile) {
41550:     let fis = Cc["@mozilla.org/network/file-input-stream;1"].
41550:               createInstance(Ci.nsIFileInputStream);
41584:     fis.init(aFile, -1, -1, false);
41550:     let line = { value: "" };
41550:     if (fis instanceof Ci.nsILineInputStream)
41550:       fis.readLine(line);
41550:     fis.close();
41550:     if (line.value) {
86316:       let linkedDirectory = Cc["@mozilla.org/file/local;1"].
41550:                             createInstance(Ci.nsILocalFile);
41550: 
41550:       try {
41550:         linkedDirectory.initWithPath(line.value);
41550:       }
41550:       catch (e) {
71094:         linkedDirectory.setRelativeDescriptor(aFile.parent, line.value);
41550:       }
86316: 
47207:       if (!linkedDirectory.exists()) {
47207:         WARN("File pointer " + aFile.path + " points to " + linkedDirectory.path +
47207:              " which does not exist");
47207:         return null;
47207:       }
47207: 
47207:       if (!linkedDirectory.isDirectory()) {
47207:         WARN("File pointer " + aFile.path + " points to " + linkedDirectory.path +
47207:              " which is not a directory");
47207:         return null;
47207:       }
47207: 
41550:       return linkedDirectory;
41550:     }
47207: 
47207:     WARN("File pointer " + aFile.path + " does not contain a path");
41550:     return null;
41550:   },
41550: 
41550:   /**
41550:    * Finds all the add-ons installed in this location.
41550:    */
41550:   _readAddons: function DirInstallLocation__readAddons() {
41550:     let entries = this._directory.directoryEntries
41550:                                  .QueryInterface(Ci.nsIDirectoryEnumerator);
41550:     let entry;
41550:     while (entry = entries.nextFile) {
41550:       // Should never happen really
59087:       if (!(entry instanceof Ci.nsILocalFile))
41550:         continue;
41550: 
41550:       let id = entry.leafName;
41550: 
56256:       if (id == DIR_STAGE || id == DIR_XPI_STAGE || id == DIR_TRASH)
41550:         continue;
41550: 
53655:       let directLoad = false;
53655:       if (entry.isFile() &&
53655:           id.substring(id.length - 4).toLowerCase() == ".xpi") {
53655:         directLoad = true;
53655:         id = id.substring(0, id.length - 4);
53655:       }
53655: 
41550:       if (!gIDTest.test(id)) {
41550:         LOG("Ignoring file entry whose name is not a valid add-on ID: " +
41550:              entry.path);
41550:         continue;
41550:       }
41550: 
86316:       if (entry.isFile() && !directLoad) {
74689:         let newEntry = this._readDirectoryFromFile(entry);
69820:         if (!newEntry) {
69820:           LOG("Deleting stale pointer file " + entry.path);
69820:           entry.remove(true);
41550:           continue;
69820:         }
59206: 
41550:         entry = newEntry;
59206:         this._linkedAddons.push(id);
41550:       }
52422: 
52422:       this._IDToFileMap[id] = entry;
52422:       this._FileToIDMap[entry.path] = id;
41550:     }
41550:     entries.close();
41550:   },
41550: 
41550:   /**
41550:    * Gets the name of this install location.
41550:    */
41550:   get name() {
41550:     return this._name;
41550:   },
41550: 
41550:   /**
41579:    * Gets the scope of this install location.
41579:    */
41579:   get scope() {
41579:     return this._scope;
41579:   },
41579: 
41579:   /**
41550:    * Gets an array of nsIFiles for add-ons installed in this location.
41550:    */
41550:   get addonLocations() {
41550:     let locations = [];
52422:     for (let id in this._IDToFileMap) {
52422:       locations.push(this._IDToFileMap[id].clone()
41550:                          .QueryInterface(Ci.nsILocalFile));
41550:     }
41550:     return locations;
41550:   },
41550: 
41550:   /**
41550:    * Gets the staging directory to put add-ons that are pending install and
41550:    * uninstall into.
41550:    *
41550:    * @return an nsIFile
41550:    */
41550:   getStagingDir: function DirInstallLocation_getStagingDir() {
41550:     let dir = this._directory.clone();
41550:     dir.append(DIR_STAGE);
41550:     return dir;
41550:   },
41550: 
41550:   /**
55436:    * Gets the directory used by old versions for staging XPI and JAR files ready
55436:    * to be installed.
55436:    *
55436:    * @return an nsIFile
55436:    */
55436:   getXPIStagingDir: function DirInstallLocation_getXPIStagingDir() {
55436:     let dir = this._directory.clone();
55436:     dir.append(DIR_XPI_STAGE);
55436:     return dir;
55436:   },
55436: 
55436:   /**
56256:    * Returns a directory that is normally on the same filesystem as the rest of
56256:    * the install location and can be used for temporarily storing files during
56256:    * safe move operations. Calling this method will delete the existing trash
56256:    * directory and its contents.
56256:    *
56256:    * @return an nsIFile
56256:    */
56256:   getTrashDir: function DirInstallLocation_getTrashDir() {
56256:     let trashDir = this._directory.clone();
56256:     trashDir.append(DIR_TRASH);
56256:     if (trashDir.exists())
56256:       recursiveRemove(trashDir);
56256:     trashDir.create(Ci.nsIFile.DIRECTORY_TYPE, FileUtils.PERMS_DIRECTORY);
56256:     return trashDir;
56256:   },
56256: 
56256:   /**
52422:    * Installs an add-on into the install location.
41550:    *
41584:    * @param  aId
41550:    *         The ID of the add-on to install
41584:    * @param  aSource
52422:    *         The source nsIFile to install from
58192:    * @param  aExistingAddonID
58192:    *         The ID of an existing add-on to uninstall at the same time
60885:    * @param  aCopy
60885:    *         If false the source files will be moved to the new location,
60885:    *         otherwise they will only be copied
41550:    * @return an nsIFile indicating where the add-on was installed to
41550:    */
60885:   installAddon: function DirInstallLocation_installAddon(aId, aSource,
60885:                                                          aExistingAddonID,
60885:                                                          aCopy) {
56256:     let trashDir = this.getTrashDir();
56256: 
60885:     let transaction = new SafeInstallOperation();
56256: 
58192:     let self = this;
58192:     function moveOldAddon(aId) {
58192:       let file = self._directory.clone().QueryInterface(Ci.nsILocalFile);
52422:       file.append(aId);
56256: 
52422:       if (file.exists())
56256:         transaction.move(file, trashDir);
52422: 
58192:       file = self._directory.clone().QueryInterface(Ci.nsILocalFile);
52422:       file.append(aId + ".xpi");
52422:       if (file.exists()) {
70154:         flushJarCache(file);
56256:         transaction.move(file, trashDir);
56256:       }
58192:     }
58192: 
58192:     // If any of these operations fails the finally block will clean up the
58192:     // temporary directory
58192:     try {
58192:       moveOldAddon(aId);
58192:       if (aExistingAddonID && aExistingAddonID != aId)
58192:         moveOldAddon(aExistingAddonID);
56256: 
60885:       if (aCopy) {
60885:         transaction.copy(aSource, this._directory);
60885:       }
60885:       else {
52422:         if (aSource.isFile())
70154:           flushJarCache(aSource);
56256: 
56256:         transaction.move(aSource, this._directory);
56256:       }
60885:     }
56256:     finally {
56256:       // It isn't ideal if this cleanup fails but it isn't worth rolling back
56256:       // the install because of it.
56256:       try {
56256:         recursiveRemove(trashDir);
56256:       }
56256:       catch (e) {
57401:         WARN("Failed to remove trash directory when installing " + aId, e);
56256:       }
56256:     }
56256: 
56256:     let newFile = this._directory.clone().QueryInterface(Ci.nsILocalFile);
56256:     newFile.append(aSource.leafName);
56256:     newFile.lastModifiedTime = Date.now();
56256:     this._FileToIDMap[newFile.path] = aId;
56256:     this._IDToFileMap[aId] = newFile;
56256: 
58192:     if (aExistingAddonID && aExistingAddonID != aId &&
58192:         aExistingAddonID in this._IDToFileMap) {
58192:       delete this._FileToIDMap[this._IDToFileMap[aExistingAddonID]];
58192:       delete this._IDToFileMap[aExistingAddonID];
58192:     }
58192: 
56256:     return newFile;
41550:   },
41550: 
41550:   /**
41550:    * Uninstalls an add-on from this location.
41550:    *
41584:    * @param  aId
41550:    *         The ID of the add-on to uninstall
41550:    * @throws if the ID does not match any of the add-ons installed
41550:    */
41584:   uninstallAddon: function DirInstallLocation_uninstallAddon(aId) {
52422:     let file = this._IDToFileMap[aId];
52422:     if (!file) {
52422:       WARN("Attempted to remove " + aId + " from " +
49549:            this._name + " but it was already gone");
49549:       return;
49549:     }
41550: 
54689:     file = this._directory.clone();
54689:     file.append(aId);
54689:     if (!file.exists())
54689:       file.leafName += ".xpi";
54689: 
52422:     if (!file.exists()) {
52422:       WARN("Attempted to remove " + aId + " from " +
52422:            this._name + " but it was already gone");
56256: 
56256:       delete this._FileToIDMap[file.path];
56256:       delete this._IDToFileMap[aId];
52422:       return;
52422:     }
52422: 
56256:     let trashDir = this.getTrashDir();
56256: 
54689:     if (file.leafName != aId)
70154:       flushJarCache(file);
56256: 
60885:     let transaction = new SafeInstallOperation();
56256: 
56256:     try {
56256:       transaction.move(file, trashDir);
56256:     }
56256:     finally {
56256:       // It isn't ideal if this cleanup fails, but it is probably better than
56256:       // rolling back the uninstall at this point
56256:       try {
56256:         recursiveRemove(trashDir);
56256:       }
56256:       catch (e) {
57401:         WARN("Failed to remove trash directory when uninstalling " + aId, e);
56256:       }
56256:     }
56256: 
56256:     delete this._FileToIDMap[file.path];
56256:     delete this._IDToFileMap[aId];
41550:   },
41550: 
41550:   /**
52422:    * Gets the ID of the add-on installed in the given nsIFile.
41550:    *
52422:    * @param  aFile
52422:    *         The nsIFile to look in
41550:    * @return the ID
52422:    * @throws if the file does not represent an installed add-on
41550:    */
52422:   getIDForLocation: function DirInstallLocation_getIDForLocation(aFile) {
52422:     if (aFile.path in this._FileToIDMap)
52422:       return this._FileToIDMap[aFile.path];
52422:     throw new Error("Unknown add-on location " + aFile.path);
41550:   },
41550: 
41550:   /**
41550:    * Gets the directory that the add-on with the given ID is installed in.
41550:    *
41584:    * @param  aId
41550:    *         The ID of the add-on
52422:    * @return the nsILocalFile
41550:    * @throws if the ID does not match any of the add-ons installed
41550:    */
41584:   getLocationForID: function DirInstallLocation_getLocationForID(aId) {
52422:     if (aId in this._IDToFileMap)
52422:       return this._IDToFileMap[aId].clone().QueryInterface(Ci.nsILocalFile);
41584:     throw new Error("Unknown add-on ID " + aId);
59206:   },
59206: 
59206:   /**
59206:    * Returns true if the given addon was installed in this location by a text
59206:    * file pointing to its real path.
59206:    *
59206:    * @param aId
59206:    *        The ID of the addon
59206:    */
59206:   isLinkedAddon: function(aId) {
59206:     return this._linkedAddons.indexOf(aId) != -1;
41550:   }
41550: };
41550: 
41550: #ifdef XP_WIN
41550: /**
41550:  * An object that identifies a registry install location for add-ons. The location
41550:  * consists of a registry key which contains string values mapping ID to the
52422:  * path where an add-on is installed
41550:  *
41584:  * @param  aName
41550:  *         The string identifier of this Install Location.
41584:  * @param  aRootKey
41550:  *         The root key (one of the ROOT_KEY_ values from nsIWindowsRegKey).
41579:  * @param  scope
41579:  *         The scope of add-ons installed in this location
41550:  */
41584: function WinRegInstallLocation(aName, aRootKey, aScope) {
41550:   this.locked = true;
41584:   this._name = aName;
41584:   this._rootKey = aRootKey;
41584:   this._scope = aScope;
52422:   this._IDToFileMap = {};
52422:   this._FileToIDMap = {};
41550: 
41550:   let path = this._appKeyPath + "\\Extensions";
41550:   let key = Cc["@mozilla.org/windows-registry-key;1"].
41550:             createInstance(Ci.nsIWindowsRegKey);
41550: 
41550:   // Reading the registry may throw an exception, and that's ok.  In error
41550:   // cases, we just leave ourselves in the empty state.
41550:   try {
41550:     key.open(this._rootKey, path, Ci.nsIWindowsRegKey.ACCESS_READ);
41578:   }
41578:   catch (e) {
41578:     return;
41578:   }
41578: 
41550:   this._readAddons(key);
41550:   key.close();
41550: }
41550: 
41550: WinRegInstallLocation.prototype = {
41550:   _name       : "",
41550:   _rootKey    : null,
41579:   _scope      : null,
52422:   _IDToFileMap : null,  // mapping from ID to nsIFile
52422:   _FileToIDMap : null,  // mapping from path to ID
41550: 
41550:   /**
41550:    * Retrieves the path of this Application's data key in the registry.
41550:    */
41550:   get _appKeyPath() {
41550:     let appVendor = Services.appinfo.vendor;
41550:     let appName = Services.appinfo.name;
41550: 
41550: #ifdef MOZ_THUNDERBIRD
41550:     // XXX Thunderbird doesn't specify a vendor string
41550:     if (appVendor == "")
41550:       appVendor = "Mozilla";
41550: #endif
41550: 
41550:     // XULRunner-based apps may intentionally not specify a vendor
41550:     if (appVendor != "")
41550:       appVendor += "\\";
41550: 
41550:     return "SOFTWARE\\" + appVendor + appName;
41550:   },
41550: 
41550:   /**
52422:    * Read the registry and build a mapping between ID and path for each
41550:    * installed add-on.
41550:    *
41550:    * @param  key
41550:    *         The key that contains the ID to path mapping
41550:    */
41584:   _readAddons: function RegInstallLocation__readAddons(aKey) {
41584:     let count = aKey.valueCount;
41550:     for (let i = 0; i < count; ++i) {
41584:       let id = aKey.getValueName(i);
41550: 
52422:       let file = Cc["@mozilla.org/file/local;1"].
41550:                 createInstance(Ci.nsILocalFile);
52422:       file.initWithPath(aKey.readStringValue(id));
52422: 
54271:       if (!file.exists()) {
52422:         WARN("Ignoring missing add-on in " + file.path);
54271:         continue;
54271:       }
52422: 
52422:       this._IDToFileMap[id] = file;
52422:       this._FileToIDMap[file.path] = id;
41550:     }
41550:   },
41550: 
41550:   /**
41550:    * Gets the name of this install location.
41550:    */
41550:   get name() {
41550:     return this._name;
41550:   },
41550: 
41550:   /**
41579:    * Gets the scope of this install location.
41579:    */
41579:   get scope() {
41579:     return this._scope;
41579:   },
41579: 
41579:   /**
41550:    * Gets an array of nsIFiles for add-ons installed in this location.
41550:    */
41550:   get addonLocations() {
41550:     let locations = [];
52422:     for (let id in this._IDToFileMap) {
52422:       locations.push(this._IDToFileMap[id].clone()
41550:                          .QueryInterface(Ci.nsILocalFile));
41550:     }
41550:     return locations;
41550:   },
41550: 
41550:   /**
52422:    * Gets the ID of the add-on installed in the given nsIFile.
41550:    *
41584:    * @param  aFile
52422:    *         The nsIFile to look in
41550:    * @return the ID
52422:    * @throws if the file does not represent an installed add-on
41550:    */
41584:   getIDForLocation: function RegInstallLocation_getIDForLocation(aFile) {
52422:     if (aFile.path in this._FileToIDMap)
52422:       return this._FileToIDMap[aFile.path];
41550:     throw new Error("Unknown add-on location");
41550:   },
41550: 
41550:   /**
52422:    * Gets the nsIFile that the add-on with the given ID is installed in.
41550:    *
41584:    * @param  aId
41550:    *         The ID of the add-on
52422:    * @return the nsIFile
41550:    */
41584:   getLocationForID: function RegInstallLocation_getLocationForID(aId) {
52422:     if (aId in this._IDToFileMap)
52422:       return this._IDToFileMap[aId].clone().QueryInterface(Ci.nsILocalFile);
41550:     throw new Error("Unknown add-on ID");
59206:   },
59206: 
59206:   /**
59206:    * @see DirectoryInstallLocation
59206:    */
59206:   isLinkedAddon: function(aId) {
59206:     return true;
41550:   }
41550: };
41550: #endif
41550: 
70152: AddonManagerPrivate.registerProvider(XPIProvider, [
70152:   new AddonManagerPrivate.AddonType("extension", URI_EXTENSION_STRINGS,
70152:                                     STRING_TYPE_NAME,
70152:                                     AddonManager.VIEW_TYPE_LIST, 4000),
70152:   new AddonManagerPrivate.AddonType("theme", URI_EXTENSION_STRINGS,
70152:                                     STRING_TYPE_NAME,
70152:                                     AddonManager.VIEW_TYPE_LIST, 5000),
79913:   new AddonManagerPrivate.AddonType("dictionary", URI_EXTENSION_STRINGS,
79913:                                     STRING_TYPE_NAME,
79913:                                     AddonManager.VIEW_TYPE_LIST, 7000,
79913:                                     AddonManager.TYPE_UI_HIDE_EMPTY),
70152:   new AddonManagerPrivate.AddonType("locale", URI_EXTENSION_STRINGS,
70152:                                     STRING_TYPE_NAME,
79913:                                     AddonManager.VIEW_TYPE_LIST, 8000,
70152:                                     AddonManager.TYPE_UI_HIDE_EMPTY)
70152: ]);
