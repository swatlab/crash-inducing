    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2003
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Original Author: Aaron Leventhal (aaronl@netscape.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* For documentation of the accessibility architecture, 
    1:  * see http://lxr.mozilla.org/seamonkey/source/accessible/accessible-docs.html
    1:  */
    1: 
    1: #ifndef _nsAccessNode_H_
    1: #define _nsAccessNode_H_
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsAccessibilityAtoms.h"
20521: #include "nsCoreUtils.h"
20536: #include "nsAccUtils.h"
16001: 
  497: #include "nsIAccessibleTypes.h"
    1: #include "nsIAccessNode.h"
    1: #include "nsIContent.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIStringBundle.h"
    1: #include "nsWeakReference.h"
    1: #include "nsInterfaceHashtable.h"
    1: #include "nsIAccessibilityService.h"
    1: 
    1: class nsIPresShell;
    1: class nsPresContext;
    1: class nsIAccessibleDocument;
    1: class nsIFrame;
    1: class nsIDOMNodeList;
    1: class nsITimer;
    1: class nsRootAccessible;
 2063: class nsApplicationAccessibleWrap;
 8471: class nsIDocShellTreeItem;
    1: 
    1: #define ACCESSIBLE_BUNDLE_URL "chrome://global-platform/locale/accessible.properties"
    1: #define PLATFORM_KEYS_BUNDLE_URL "chrome://global-platform/locale/platformKeys.properties"
    1: 
 3466: typedef nsInterfaceHashtable<nsVoidPtrHashKey, nsIAccessNode>
 3466:         nsAccessNodeHashtable;
    1: 
21984: #define NS_OK_DEFUNCT_OBJECT \
21984: NS_ERROR_GENERATE_SUCCESS(NS_ERROR_MODULE_GENERAL, 0x22)
21984: 
21984: #define NS_ENSURE_A11Y_SUCCESS(res, ret)                                  \
21984:   PR_BEGIN_MACRO                                                          \
21984:     nsresult __rv = res; /* Don't evaluate |res| more than once */        \
21984:     if (NS_FAILED(__rv)) {                                                \
21984:       NS_ENSURE_SUCCESS_BODY(res, ret)                                    \
21984:       return ret;                                                         \
21984:     }                                                                     \
21984:     if (__rv == NS_OK_DEFUNCT_OBJECT)                                     \
21984:       return ret;                                                         \
21984:   PR_END_MACRO
21984: 
21169: #define NS_ACCESSNODE_IMPL_CID                          \
21169: {  /* 13555f6e-0c0f-4002-84f6-558d47b8208e */           \
21169:   0x13555f6e,                                           \
21169:   0xc0f,                                                \
21169:   0x4002,                                               \
21169:   { 0x84, 0xf6, 0x55, 0x8d, 0x47, 0xb8, 0x20, 0x8e }    \
21169: }
21169: 
21169: class nsAccessNode: public nsIAccessNode
    1: {
    1:   public: // construction, destruction
    1:     nsAccessNode(nsIDOMNode *, nsIWeakReference* aShell);
    1:     virtual ~nsAccessNode();
    1: 
16428:     NS_DECL_CYCLE_COLLECTING_ISUPPORTS
16428:     NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsAccessNode, nsIAccessNode)
16428: 
    1:     NS_DECL_NSIACCESSNODE
21169:     NS_DECLARE_STATIC_IID_ACCESSOR(NS_ACCESSNODE_IMPL_CID)
    1: 
    1:     static void InitXPAccessibility();
    1:     static void ShutdownXPAccessibility();
    1: 
 2063:     /**
 2063:      * Return an application accessible.
 2063:      */
 2063:     static already_AddRefed<nsApplicationAccessibleWrap> GetApplicationAccessible();
 2063: 
    1:     // Static methods for handling per-document cache
 3466:     static void PutCacheEntry(nsAccessNodeHashtable& aCache,
    1:                               void* aUniqueID, nsIAccessNode *aAccessNode);
 3466:     static void GetCacheEntry(nsAccessNodeHashtable& aCache,
 3466:                               void* aUniqueID, nsIAccessNode **aAccessNode);
 3466:     static void ClearCache(nsAccessNodeHashtable& aCache);
    1: 
20261:     static PLDHashOperator ClearCacheEntry(const void* aKey, nsCOMPtr<nsIAccessNode>& aAccessNode, void* aUserArg);
    1: 
    1:     // Static cache methods for global document cache
 8471:     static already_AddRefed<nsIAccessibleDocument> GetDocAccessibleFor(nsIDocument *aDocument);
 8471:     static already_AddRefed<nsIAccessibleDocument> GetDocAccessibleFor(nsIWeakReference *aWeakShell);
 8471:     static already_AddRefed<nsIAccessibleDocument> GetDocAccessibleFor(nsIDocShellTreeItem *aContainer, PRBool aCanCreate = PR_FALSE);
    1:     static already_AddRefed<nsIAccessibleDocument> GetDocAccessibleFor(nsIDOMNode *aNode);
    1: 
    1:     already_AddRefed<nsRootAccessible> GetRootAccessible();
    1: 
    1:     static nsIDOMNode *gLastFocusedNode;
    1:     static nsIAccessibilityService* GetAccService();
    1:     already_AddRefed<nsIDOMNode> GetCurrentFocus();
    1: 
 9622:     /**
 9622:      * Returns true when the accessible is defunct.
 9622:      */
26291:     virtual PRBool IsDefunct();
 9622: 
21169:     /**
21169:      * Initialize the access node object, add it to the cache.
21169:      */
21169:     virtual nsresult Init();
21169: 
21169:     /**
21169:      * Shutdown the access node object.
21169:      */
21169:     virtual nsresult Shutdown();
21169: 
21169:     /**
21169:      * Return frame for the given access node object.
21169:      */
21169:     virtual nsIFrame* GetFrame();
21169: 
    1: protected:
    1:     nsresult MakeAccessNode(nsIDOMNode *aNode, nsIAccessNode **aAccessNode);
    1:     already_AddRefed<nsIPresShell> GetPresShell();
    1:     nsPresContext* GetPresContext();
    1:     already_AddRefed<nsIAccessibleDocument> GetDocAccessible();
  732:     void LastRelease();
    1: 
    1:     nsCOMPtr<nsIDOMNode> mDOMNode;
    1:     nsCOMPtr<nsIWeakReference> mWeakShell;
    1: 
    1: #ifdef DEBUG_A11Y
    1:     PRBool mIsInitialized;
    1: #endif
    1: 
 1071:     /**
 1071:      * Notify global nsIObserver's that a11y is getting init'd or shutdown
 1071:      */
30820:     static void NotifyA11yInitOrShutdown(PRBool aIsInit);
 1071: 
    1:     // Static data, we do our own refcounting for our static data
    1:     static nsIStringBundle *gStringBundle;
    1:     static nsIStringBundle *gKeyStringBundle;
    1:     static nsITimer *gDoCommandTimer;
30820: #ifdef DEBUG
    1:     static PRBool gIsAccessibilityActive;
30820: #endif
    1:     static PRBool gIsCacheDisabled;
    1:     static PRBool gIsFormFillEnabled;
    1: 
 3466:     static nsAccessNodeHashtable gGlobalDocAccessibleCache;
    1: 
    1: private:
 2063:   static nsApplicationAccessibleWrap *gApplicationAccessible;
    1: };
    1: 
21169: NS_DEFINE_STATIC_IID_ACCESSOR(nsAccessNode,
21169:                               NS_ACCESSNODE_IMPL_CID)
21169: 
    1: #endif
    1: 
