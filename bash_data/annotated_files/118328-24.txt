  3863: // Copyright (c) 2006, Google Inc.
  3863: // All rights reserved.
  3863: //
  3863: // Redistribution and use in source and binary forms, with or without
  3863: // modification, are permitted provided that the following conditions are
  3863: // met:
  3863: //
  3863: //     * Redistributions of source code must retain the above copyright
  3863: // notice, this list of conditions and the following disclaimer.
  3863: //     * Redistributions in binary form must reproduce the above
  3863: // copyright notice, this list of conditions and the following disclaimer
  3863: // in the documentation and/or other materials provided with the
  3863: // distribution.
  3863: //     * Neither the name of Google Inc. nor the names of its
  3863: // contributors may be used to endorse or promote products derived from
  3863: // this software without specific prior written permission.
  3863: //
  3863: // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  3863: // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  3863: // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  3863: // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  3863: // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  3863: // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  3863: // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  3863: // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  3863: // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  3863: // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  3863: // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  3863: 
 47243: #include "google_breakpad/processor/minidump_processor.h"
  3869: 
 47243: #include <assert.h>
 47243: #include <stdio.h>
 47243: 
  3869: #include "google_breakpad/processor/call_stack.h"
  3869: #include "google_breakpad/processor/minidump.h"
  3869: #include "google_breakpad/processor/process_state.h"
114869: #include "google_breakpad/processor/exploitability.h"
  3897: #include "processor/logging.h"
  3863: #include "processor/scoped_ptr.h"
  3863: #include "processor/stackwalker_x86.h"
  3863: 
  3869: namespace google_breakpad {
  3863: 
  3869: MinidumpProcessor::MinidumpProcessor(SymbolSupplier *supplier,
  3869:                                      SourceLineResolverInterface *resolver)
114869:     : supplier_(supplier), resolver_(resolver),
114869:       enable_exploitability_(false) {
114869: }
114869: 
114869: MinidumpProcessor::MinidumpProcessor(SymbolSupplier *supplier,
114869:                                      SourceLineResolverInterface *resolver,
114869:                                      bool enable_exploitability)
114869:     : supplier_(supplier), resolver_(resolver),
114869:       enable_exploitability_(enable_exploitability) {
  3863: }
  3863: 
  3863: MinidumpProcessor::~MinidumpProcessor() {
  3863: }
  3863: 
 32241: ProcessResult MinidumpProcessor::Process(
 32241:     Minidump *dump, ProcessState *process_state) {
 32241:   assert(dump);
 32241:   assert(process_state);
  3863: 
  3869:   process_state->Clear();
  3863: 
 32241:   const MDRawHeader *header = dump->header();
 32241:   if (!header) {
 32241:     BPLOG(ERROR) << "Minidump " << dump->path() << " has no header";
 32241:     return PROCESS_ERROR_NO_MINIDUMP_HEADER;
 32241:   }
  3869:   process_state->time_date_stamp_ = header->time_date_stamp;
  3869: 
 32241:   bool has_cpu_info = GetCPUInfo(dump, &process_state->system_info_);
 32241:   bool has_os_info = GetOSInfo(dump, &process_state->system_info_);
  3863: 
  3868:   u_int32_t dump_thread_id = 0;
  3868:   bool has_dump_thread = false;
  3868:   u_int32_t requesting_thread_id = 0;
  3868:   bool has_requesting_thread = false;
  3868: 
 32241:   MinidumpBreakpadInfo *breakpad_info = dump->GetBreakpadInfo();
  3869:   if (breakpad_info) {
  3869:     has_dump_thread = breakpad_info->GetDumpThreadID(&dump_thread_id);
  3868:     has_requesting_thread =
  3869:         breakpad_info->GetRequestingThreadID(&requesting_thread_id);
  3868:   }
  3868: 
 32241:   MinidumpException *exception = dump->GetException();
  3863:   if (exception) {
  3863:     process_state->crashed_ = true;
  3868:     has_requesting_thread = exception->GetThreadID(&requesting_thread_id);
  3863: 
  3863:     process_state->crash_reason_ = GetCrashReason(
 32241:         dump, &process_state->crash_address_);
  3863:   }
  3863: 
 36832:   // This will just return an empty string if it doesn't exist.
 36832:   process_state->assertion_ = GetAssertion(dump);
 36832: 
 32241:   MinidumpModuleList *module_list = dump->GetModuleList();
  3869: 
  3869:   // Put a copy of the module list into ProcessState object.  This is not
  3869:   // necessarily a MinidumpModuleList, but it adheres to the CodeModules
  3869:   // interface, which is all that ProcessState needs to expose.
  3869:   if (module_list)
  3869:     process_state->modules_ = module_list->Copy();
  3869: 
 32241:   MinidumpThreadList *threads = dump->GetThreadList();
  3863:   if (!threads) {
 32241:     BPLOG(ERROR) << "Minidump " << dump->path() << " has no thread list";
 32241:     return PROCESS_ERROR_NO_THREAD_LIST;
  3863:   }
  3863: 
 32241:   BPLOG(INFO) << "Minidump " << dump->path() << " has " <<
  3897:       (has_cpu_info           ? "" : "no ") << "CPU info, " <<
  3897:       (has_os_info            ? "" : "no ") << "OS info, " <<
  3897:       (breakpad_info != NULL  ? "" : "no ") << "Breakpad info, " <<
  3897:       (exception != NULL      ? "" : "no ") << "exception, " <<
  3897:       (module_list != NULL    ? "" : "no ") << "module list, " <<
  3897:       (threads != NULL        ? "" : "no ") << "thread list, " <<
  3897:       (has_dump_thread        ? "" : "no ") << "dump thread, and " <<
  3897:       (has_requesting_thread  ? "" : "no ") << "requesting thread";
  3897: 
  3910:   bool interrupted = false;
  3868:   bool found_requesting_thread = false;
  3863:   unsigned int thread_count = threads->thread_count();
  3863:   for (unsigned int thread_index = 0;
  3863:        thread_index < thread_count;
  3863:        ++thread_index) {
  3897:     char thread_string_buffer[64];
  3897:     snprintf(thread_string_buffer, sizeof(thread_string_buffer), "%d/%d",
  3897:              thread_index, thread_count);
 32241:     string thread_string = dump->path() + ":" + thread_string_buffer;
  3897: 
  3863:     MinidumpThread *thread = threads->GetThreadAtIndex(thread_index);
  3863:     if (!thread) {
  3897:       BPLOG(ERROR) << "Could not get thread for " << thread_string;
 32241:       return PROCESS_ERROR_GETTING_THREAD;
  3863:     }
  3863: 
  3868:     u_int32_t thread_id;
  3868:     if (!thread->GetThreadID(&thread_id)) {
  3897:       BPLOG(ERROR) << "Could not get thread ID for " << thread_string;
 32241:       return PROCESS_ERROR_GETTING_THREAD_ID;
  3863:     }
  3863: 
  3897:     thread_string += " id " + HexString(thread_id);
  3897:     BPLOG(INFO) << "Looking at thread " << thread_string;
  3897: 
  3868:     // If this thread is the thread that produced the minidump, don't process
  3868:     // it.  Because of the problems associated with a thread producing a
  3868:     // dump of itself (when both its context and its stack are in flux),
  3868:     // processing that stack wouldn't provide much useful data.
  3868:     if (has_dump_thread && thread_id == dump_thread_id) {
  3868:       continue;
  3868:     }
  3868: 
  3868:     MinidumpContext *context = thread->GetContext();
  3868: 
  3868:     if (has_requesting_thread && thread_id == requesting_thread_id) {
  3868:       if (found_requesting_thread) {
  3868:         // There can't be more than one requesting thread.
  3897:         BPLOG(ERROR) << "Duplicate requesting thread: " << thread_string;
 32241:         return PROCESS_ERROR_DUPLICATE_REQUESTING_THREADS;
  3868:       }
  3868: 
  3868:       // Use processed_state->threads_.size() instead of thread_index.
  3868:       // thread_index points to the thread index in the minidump, which
  3868:       // might be greater than the thread index in the threads vector if
  3868:       // any of the minidump's threads are skipped and not placed into the
  3868:       // processed threads vector.  The thread vector's current size will
  3868:       // be the index of the current thread when it's pushed into the
  3868:       // vector.
  3868:       process_state->requesting_thread_ = process_state->threads_.size();
  3868: 
  3868:       found_requesting_thread = true;
  3868: 
  3868:       if (process_state->crashed_) {
  3868:         // Use the exception record's context for the crashed thread, instead
  3868:         // of the thread's own context.  For the crashed thread, the thread's
  3868:         // own context is the state inside the exception handler.  Using it
  3868:         // would not result in the expected stack trace from the time of the
 36832:         // crash. If the exception context is invalid, however, we fall back
 36832:         // on the thread context.
 36832:         MinidumpContext *ctx = exception->GetContext();
 36832:         context = ctx ? ctx : thread->GetContext();
  3868:       }
  3863:     }
  3863: 
  3863:     MinidumpMemoryRegion *thread_memory = thread->GetMemory();
  3863:     if (!thread_memory) {
  3897:       BPLOG(ERROR) << "No memory region for " << thread_string;
 32241:       return PROCESS_ERROR_NO_MEMORY_FOR_THREAD;
  3863:     }
  3863: 
  3869:     // Use process_state->modules_ instead of module_list, because the
  3869:     // |modules| argument will be used to populate the |module| fields in
  3869:     // the returned StackFrame objects, which will be placed into the
  3869:     // returned ProcessState object.  module_list's lifetime is only as
  3869:     // long as the Minidump object: it will be deleted when this function
  3869:     // returns.  process_state->modules_ is owned by the ProcessState object
  3869:     // (just like the StackFrame objects), and is much more suitable for this
  3869:     // task.
  3863:     scoped_ptr<Stackwalker> stackwalker(
  3869:         Stackwalker::StackwalkerForCPU(process_state->system_info(),
  3869:                                        context,
  3863:                                        thread_memory,
  3869:                                        process_state->modules_,
  3869:                                        supplier_,
  3869:                                        resolver_));
  3863:     if (!stackwalker.get()) {
  3897:       BPLOG(ERROR) << "No stackwalker for " << thread_string;
 32241:       return PROCESS_ERROR_NO_STACKWALKER_FOR_THREAD;
  3863:     }
  3863: 
  3869:     scoped_ptr<CallStack> stack(new CallStack());
  3869:     if (!stackwalker->Walk(stack.get())) {
  3910:       BPLOG(INFO) << "Stackwalker interrupt (missing symbols?) at " <<
  3910:           thread_string;
  3910:       interrupted = true;
  3863:     }
  3863:     process_state->threads_.push_back(stack.release());
 36832:     process_state->thread_memory_regions_.push_back(thread_memory);
  3863:   }
  3863: 
  3910:   if (interrupted) {
 32241:     BPLOG(INFO) << "Processing interrupted for " << dump->path();
 32241:     return PROCESS_SYMBOL_SUPPLIER_INTERRUPTED;
  3910:   }
  3910: 
  3868:   // If a requesting thread was indicated, it must be present.
  3868:   if (has_requesting_thread && !found_requesting_thread) {
  3869:     // Don't mark as an error, but invalidate the requesting thread
  3897:     BPLOG(ERROR) << "Minidump indicated requesting thread " <<
  3897:         HexString(requesting_thread_id) << ", not found in " <<
 32241:         dump->path();
  3869:     process_state->requesting_thread_ = -1;
  3863:   }
  3863: 
114869:   // Exploitability defaults to EXPLOITABILITY_NOT_ANALYZED
114869:   process_state->exploitability_ = EXPLOITABILITY_NOT_ANALYZED;
114869: 
114869:   // If an exploitability run was requested we perform the platform specific
114869:   // rating.
114869:   if (enable_exploitability_) {
114869:     scoped_ptr<Exploitability> exploitability(
114869:         Exploitability::ExploitabilityForPlatform(dump, process_state));
114869:     // The engine will be null if the platform is not supported
114869:     if (exploitability != NULL) {
114869:       process_state->exploitability_ = exploitability->CheckExploitability();
114869:     } else {
114869:       process_state->exploitability_ = EXPLOITABILITY_ERR_NOENGINE;
114869:     }
114869:   }
114869: 
 32241:   BPLOG(INFO) << "Processed " << dump->path();
  3869:   return PROCESS_OK;
  3863: }
  3863: 
 32241: ProcessResult MinidumpProcessor::Process(
 32241:     const string &minidump_file, ProcessState *process_state) {
 32241:   BPLOG(INFO) << "Processing minidump in file " << minidump_file;
 32241: 
 32241:   Minidump dump(minidump_file);
 32241:   if (!dump.Read()) {
 32241:      BPLOG(ERROR) << "Minidump " << dump.path() << " could not be read";
 32241:      return PROCESS_ERROR_MINIDUMP_NOT_FOUND;
 32241:   }
 32241: 
 32241:   return Process(&dump, process_state);
 32241: }
 32241: 
  3863: // Returns the MDRawSystemInfo from a minidump, or NULL if system info is
  3863: // not available from the minidump.  If system_info is non-NULL, it is used
  3863: // to pass back the MinidumpSystemInfo object.
  3863: static const MDRawSystemInfo* GetSystemInfo(Minidump *dump,
  3863:                                             MinidumpSystemInfo **system_info) {
  3863:   MinidumpSystemInfo *minidump_system_info = dump->GetSystemInfo();
  3863:   if (!minidump_system_info)
  3863:     return NULL;
  3863: 
  3863:   if (system_info)
  3863:     *system_info = minidump_system_info;
  3863: 
  3863:   return minidump_system_info->system_info();
  3863: }
  3863: 
  3863: // static
  3897: bool MinidumpProcessor::GetCPUInfo(Minidump *dump, SystemInfo *info) {
  3869:   assert(dump);
  3869:   assert(info);
  3869: 
  3869:   info->cpu.clear();
  3869:   info->cpu_info.clear();
  3863: 
  3863:   MinidumpSystemInfo *system_info;
  3863:   const MDRawSystemInfo *raw_system_info = GetSystemInfo(dump, &system_info);
  3863:   if (!raw_system_info)
  3897:     return false;
  3863: 
  3863:   switch (raw_system_info->processor_architecture) {
  8662:     case MD_CPU_ARCHITECTURE_X86:
  8662:     case MD_CPU_ARCHITECTURE_AMD64: {
  8662:       if (raw_system_info->processor_architecture ==
  8662:           MD_CPU_ARCHITECTURE_X86)
  3869:         info->cpu = "x86";
  8662:       else
  8662:         info->cpu = "amd64";
  8662: 
  3863:       const string *cpu_vendor = system_info->GetCPUVendor();
  3863:       if (cpu_vendor) {
  3869:         info->cpu_info = *cpu_vendor;
  3869:         info->cpu_info.append(" ");
  3863:       }
  3863: 
  3863:       char x86_info[36];
  3863:       snprintf(x86_info, sizeof(x86_info), "family %u model %u stepping %u",
  3863:                raw_system_info->processor_level,
  3863:                raw_system_info->processor_revision >> 8,
  3863:                raw_system_info->processor_revision & 0xff);
  3869:       info->cpu_info.append(x86_info);
  3863:       break;
  3863:     }
  3863: 
  3863:     case MD_CPU_ARCHITECTURE_PPC: {
  3869:       info->cpu = "ppc";
  3863:       break;
  3863:     }
  3863: 
  7079:     case MD_CPU_ARCHITECTURE_SPARC: {
  7079:       info->cpu = "sparc";
  7079:       break;
  7079:     }
  7079: 
 36832:     case MD_CPU_ARCHITECTURE_ARM: {
 36832:       info->cpu = "arm";
 36832:       break;
 36832:     }
 36832: 
  3863:     default: {
  3863:       // Assign the numeric architecture ID into the CPU string.
  3863:       char cpu_string[7];
  3863:       snprintf(cpu_string, sizeof(cpu_string), "0x%04x",
  3863:                raw_system_info->processor_architecture);
  3869:       info->cpu = cpu_string;
  3863:       break;
  3863:     }
  3863:   }
  3897: 
  3910:   info->cpu_count = raw_system_info->number_of_processors;
  3910: 
  3897:   return true;
  3863: }
  3863: 
  3863: // static
  3897: bool MinidumpProcessor::GetOSInfo(Minidump *dump, SystemInfo *info) {
  3869:   assert(dump);
  3869:   assert(info);
  3869: 
  3869:   info->os.clear();
  3869:   info->os_short.clear();
  3869:   info->os_version.clear();
  3863: 
  3863:   MinidumpSystemInfo *system_info;
  3863:   const MDRawSystemInfo *raw_system_info = GetSystemInfo(dump, &system_info);
  3863:   if (!raw_system_info)
  3897:     return false;
  3863: 
  3869:   info->os_short = system_info->GetOS();
  3869: 
  3863:   switch (raw_system_info->platform_id) {
  3863:     case MD_OS_WIN32_NT: {
  3869:       info->os = "Windows NT";
  3863:       break;
  3863:     }
  3863: 
  3863:     case MD_OS_WIN32_WINDOWS: {
  3869:       info->os = "Windows";
  3863:       break;
  3863:     }
  3863: 
  3863:     case MD_OS_MAC_OS_X: {
  3869:       info->os = "Mac OS X";
  3863:       break;
  3863:     }
  3863: 
114869:     case MD_OS_IOS: {
114869:       info->os = "iOS";
114869:       break;
114869:     }
114869: 
  3863:     case MD_OS_LINUX: {
  3869:       info->os = "Linux";
  3863:       break;
  3863:     }
  3863: 
  7079:     case MD_OS_SOLARIS: {
  7079:       info->os = "Solaris";
  7079:       break;
  7079:     }
  7079: 
114869:     case MD_OS_ANDROID: {
114869:       info->os = "Android";
114869:       break;
114869:     }
114869: 
  3863:     default: {
  3863:       // Assign the numeric platform ID into the OS string.
  3863:       char os_string[11];
  3863:       snprintf(os_string, sizeof(os_string), "0x%08x",
  3863:                raw_system_info->platform_id);
  3869:       info->os = os_string;
  3863:       break;
  3863:     }
  3863:   }
  3863: 
  3863:   char os_version_string[33];
  3863:   snprintf(os_version_string, sizeof(os_version_string), "%u.%u.%u",
  3863:            raw_system_info->major_version,
  3863:            raw_system_info->minor_version,
  3863:            raw_system_info->build_number);
  3869:   info->os_version = os_version_string;
  3863: 
  3863:   const string *csd_version = system_info->GetCSDVersion();
  3863:   if (csd_version) {
  3869:     info->os_version.append(" ");
  3869:     info->os_version.append(*csd_version);
  3863:   }
  3897: 
  3897:   return true;
  3863: }
  3863: 
  3863: // static
  3863: string MinidumpProcessor::GetCrashReason(Minidump *dump, u_int64_t *address) {
  3863:   MinidumpException *exception = dump->GetException();
  3863:   if (!exception)
  3863:     return "";
  3863: 
  3863:   const MDRawExceptionStream *raw_exception = exception->exception();
  3863:   if (!raw_exception)
  3863:     return "";
  3863: 
  3863:   if (address)
  3863:     *address = raw_exception->exception_record.exception_address;
  3863: 
  3863:   // The reason value is OS-specific and possibly CPU-specific.  Set up
  3863:   // sensible numeric defaults for the reason string in case we can't
  3863:   // map the codes to a string (because there's no system info, or because
  3863:   // it's an unrecognized platform, or because it's an unrecognized code.)
  3863:   char reason_string[24];
  3869:   u_int32_t exception_code = raw_exception->exception_record.exception_code;
  3869:   u_int32_t exception_flags = raw_exception->exception_record.exception_flags;
  3863:   snprintf(reason_string, sizeof(reason_string), "0x%08x / 0x%08x",
  3869:            exception_code, exception_flags);
  3863:   string reason = reason_string;
  3863: 
  3863:   const MDRawSystemInfo *raw_system_info = GetSystemInfo(dump, NULL);
  3863:   if (!raw_system_info)
  3863:     return reason;
  3863: 
  3863:   switch (raw_system_info->platform_id) {
114869:     case MD_OS_MAC_OS_X:
114869:     case MD_OS_IOS: {
  3869:       char flags_string[11];
  3869:       snprintf(flags_string, sizeof(flags_string), "0x%08x", exception_flags);
  3869:       switch (exception_code) {
  3869:         case MD_EXCEPTION_MAC_BAD_ACCESS:
  3869:           reason = "EXC_BAD_ACCESS / ";
  3869:           switch (exception_flags) {
  3869:             case MD_EXCEPTION_CODE_MAC_INVALID_ADDRESS:
  3869:               reason.append("KERN_INVALID_ADDRESS");
  3869:               break;
  3869:             case MD_EXCEPTION_CODE_MAC_PROTECTION_FAILURE:
  3869:               reason.append("KERN_PROTECTION_FAILURE");
  3869:               break;
  3869:             case MD_EXCEPTION_CODE_MAC_NO_ACCESS:
  3869:               reason.append("KERN_NO_ACCESS");
  3869:               break;
  3869:             case MD_EXCEPTION_CODE_MAC_MEMORY_FAILURE:
  3869:               reason.append("KERN_MEMORY_FAILURE");
  3869:               break;
  3869:             case MD_EXCEPTION_CODE_MAC_MEMORY_ERROR:
  3869:               reason.append("KERN_MEMORY_ERROR");
  3869:               break;
118328:             default:
118328:               // arm and ppc overlap
118328:               if (raw_system_info->processor_architecture ==
118328:                   MD_CPU_ARCHITECTURE_ARM) {
118328:                 switch (exception_flags) {
118328:                   case MD_EXCEPTION_CODE_MAC_ARM_DA_ALIGN:
118328:                     reason.append("EXC_ARM_DA_ALIGN");
118328:                     break;
118328:                   case MD_EXCEPTION_CODE_MAC_ARM_DA_DEBUG:
118328:                     reason.append("EXC_ARM_DA_DEBUG");
118328:                     break;
118328:                   default:
118328:                     reason.append(flags_string);
118328:                     BPLOG(INFO) << "Unknown exception reason " << reason;
118328:                     break;
118328:                 }
118328:               } else if (raw_system_info->processor_architecture ==
118328:                          MD_CPU_ARCHITECTURE_PPC) {
118328:                 switch (exception_flags) {
  3869:                   case MD_EXCEPTION_CODE_MAC_PPC_VM_PROT_READ:
  3869:                     reason.append("EXC_PPC_VM_PROT_READ");
  3869:                     break;
  3869:                   case MD_EXCEPTION_CODE_MAC_PPC_BADSPACE:
  3869:                     reason.append("EXC_PPC_BADSPACE");
  3869:                     break;
  3869:                   case MD_EXCEPTION_CODE_MAC_PPC_UNALIGNED:
  3869:                     reason.append("EXC_PPC_UNALIGNED");
  3869:                     break;
  3869:                   default:
  3869:                     reason.append(flags_string);
  3897:                     BPLOG(INFO) << "Unknown exception reason " << reason;
  3869:                     break;
  3869:                 }
118328:               } else {
118328:                 reason.append(flags_string);
118328:                 BPLOG(INFO) << "Unknown exception reason " << reason;
118328:               }
118328:               break;
118328:           }
  3869:           break;
  3869:         case MD_EXCEPTION_MAC_BAD_INSTRUCTION:
  3869:           reason = "EXC_BAD_INSTRUCTION / ";
  3869:           switch (raw_system_info->processor_architecture) {
118328:             case MD_CPU_ARCHITECTURE_ARM: {
118328:               switch (exception_flags) {
118328:                 case MD_EXCEPTION_CODE_MAC_ARM_UNDEFINED:
118328:                   reason.append("EXC_ARM_UNDEFINED");
118328:                   break;
118328:                 default:
118328:                   reason.append(flags_string);
118328:                   BPLOG(INFO) << "Unknown exception reason " << reason;
118328:                   break;
118328:               }
118328:               break;
118328:             }
  3869:             case MD_CPU_ARCHITECTURE_PPC: {
  3869:               switch (exception_flags) {
  3869:                 case MD_EXCEPTION_CODE_MAC_PPC_INVALID_SYSCALL:
  3869:                   reason.append("EXC_PPC_INVALID_SYSCALL");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_PPC_UNIMPLEMENTED_INSTRUCTION:
  3869:                   reason.append("EXC_PPC_UNIPL_INST");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_PPC_PRIVILEGED_INSTRUCTION:
  3869:                   reason.append("EXC_PPC_PRIVINST");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_PPC_PRIVILEGED_REGISTER:
  3869:                   reason.append("EXC_PPC_PRIVREG");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_PPC_TRACE:
  3869:                   reason.append("EXC_PPC_TRACE");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_PPC_PERFORMANCE_MONITOR:
  3869:                   reason.append("EXC_PPC_PERFMON");
  3869:                   break;
  3869:                 default:
  3869:                   reason.append(flags_string);
  3897:                   BPLOG(INFO) << "Unknown exception reason " << reason;
  3869:                   break;
  3869:               }
  3869:               break;
  3869:             }
  3869:             case MD_CPU_ARCHITECTURE_X86: {
  3869:               switch (exception_flags) {
  3869:                 case MD_EXCEPTION_CODE_MAC_X86_INVALID_OPERATION:
  3869:                   reason.append("EXC_I386_INVOP");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_X86_INVALID_TASK_STATE_SEGMENT:
  3869:                   reason.append("EXC_INVTSSFLT");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_X86_SEGMENT_NOT_PRESENT:
  3869:                   reason.append("EXC_SEGNPFLT");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_X86_STACK_FAULT:
  3869:                   reason.append("EXC_STKFLT");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_X86_GENERAL_PROTECTION_FAULT:
  3869:                   reason.append("EXC_GPFLT");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_X86_ALIGNMENT_FAULT:
  3869:                   reason.append("EXC_ALIGNFLT");
  3869:                   break;
  3869:                 default:
  3869:                   reason.append(flags_string);
  3897:                   BPLOG(INFO) << "Unknown exception reason " << reason;
  3869:                   break;
  3869:               }
  3869:               break;
  3869:             }
  3869:             default:
  3869:               reason.append(flags_string);
  3897:               BPLOG(INFO) << "Unknown exception reason " << reason;
  3869:               break;
  3869:           }
  3869:           break;
  3869:         case MD_EXCEPTION_MAC_ARITHMETIC:
  3869:           reason = "EXC_ARITHMETIC / ";
  3869:           switch (raw_system_info->processor_architecture) {
  3869:             case MD_CPU_ARCHITECTURE_PPC: {
  3869:               switch (exception_flags) {
  3869:                 case MD_EXCEPTION_CODE_MAC_PPC_OVERFLOW:
  3869:                   reason.append("EXC_PPC_OVERFLOW");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_PPC_ZERO_DIVIDE:
  3869:                   reason.append("EXC_PPC_ZERO_DIVIDE");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_PPC_FLOAT_INEXACT:
  3869:                   reason.append("EXC_FLT_INEXACT");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_PPC_FLOAT_ZERO_DIVIDE:
  3869:                   reason.append("EXC_PPC_FLT_ZERO_DIVIDE");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_PPC_FLOAT_UNDERFLOW:
  3869:                   reason.append("EXC_PPC_FLT_UNDERFLOW");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_PPC_FLOAT_OVERFLOW:
  3869:                   reason.append("EXC_PPC_FLT_OVERFLOW");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_PPC_FLOAT_NOT_A_NUMBER:
  3869:                   reason.append("EXC_PPC_FLT_NOT_A_NUMBER");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_PPC_NO_EMULATION:
  3869:                   reason.append("EXC_PPC_NOEMULATION");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_PPC_ALTIVEC_ASSIST:
  3869:                   reason.append("EXC_PPC_ALTIVECASSIST");
  3869:                 default:
  3869:                   reason.append(flags_string);
  3897:                   BPLOG(INFO) << "Unknown exception reason " << reason;
  3869:                   break;
  3869:               }
  3869:               break;
  3869:             }
  3869:             case MD_CPU_ARCHITECTURE_X86: {
  3869:               switch (exception_flags) {
  3869:                 case MD_EXCEPTION_CODE_MAC_X86_DIV:
  3869:                   reason.append("EXC_I386_DIV");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_X86_INTO:
  3869:                   reason.append("EXC_I386_INTO");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_X86_NOEXT:
  3869:                   reason.append("EXC_I386_NOEXT");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_X86_EXTOVR:
  3869:                   reason.append("EXC_I386_EXTOVR");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_X86_EXTERR:
  3869:                   reason.append("EXC_I386_EXTERR");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_X86_EMERR:
  3869:                   reason.append("EXC_I386_EMERR");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_X86_BOUND:
  3869:                   reason.append("EXC_I386_BOUND");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_X86_SSEEXTERR:
  3869:                   reason.append("EXC_I386_SSEEXTERR");
  3869:                   break;
  3869:                 default:
  3869:                   reason.append(flags_string);
  3897:                   BPLOG(INFO) << "Unknown exception reason " << reason;
  3869:                   break;
  3869:               }
  3869:               break;
  3869:             }
  3869:             default:
  3869:               reason.append(flags_string);
  3897:               BPLOG(INFO) << "Unknown exception reason " << reason;
  3869:               break;
  3869:           }
  3869:           break;
  3869:         case MD_EXCEPTION_MAC_EMULATION:
  3869:           reason = "EXC_EMULATION / ";
  3869:           reason.append(flags_string);
  3869:           break;
  3869:         case MD_EXCEPTION_MAC_SOFTWARE:
  3869:           reason = "EXC_SOFTWARE / ";
  3869:           switch (exception_flags) {
114869:             case MD_EXCEPTION_CODE_MAC_ABORT:
114869:               reason.append("SIGABRT");
114869:               break;
114869:             case MD_EXCEPTION_CODE_MAC_NS_EXCEPTION:
114869:               reason.append("UNCAUGHT_NS_EXCEPTION");
114869:               break;
  3869:             // These are ppc only but shouldn't be a problem as they're
  3869:             // unused on x86
  3869:             case MD_EXCEPTION_CODE_MAC_PPC_TRAP:
  3869:               reason.append("EXC_PPC_TRAP");
  3869:               break;
  3869:             case MD_EXCEPTION_CODE_MAC_PPC_MIGRATE:
  3869:               reason.append("EXC_PPC_MIGRATE");
  3869:               break;
  3869:             default:
  3869:               reason.append(flags_string);
  3897:               BPLOG(INFO) << "Unknown exception reason " << reason;
  3869:               break;
  3869:           }
  3869:           break;
  3869:         case MD_EXCEPTION_MAC_BREAKPOINT:
  3869:           reason = "EXC_BREAKPOINT / ";
  3869:           switch (raw_system_info->processor_architecture) {
118328:             case MD_CPU_ARCHITECTURE_ARM: {
118328:               switch (exception_flags) {
118328:                 case MD_EXCEPTION_CODE_MAC_ARM_DA_ALIGN:
118328:                   reason.append("EXC_ARM_DA_ALIGN");
118328:                   break;
118328:                 case MD_EXCEPTION_CODE_MAC_ARM_DA_DEBUG:
118328:                   reason.append("EXC_ARM_DA_DEBUG");
118328:                   break;
118328:                 case MD_EXCEPTION_CODE_MAC_ARM_BREAKPOINT:
118328:                   reason.append("EXC_ARM_BREAKPOINT");
118328:                   break;
118328:                 default:
118328:                   reason.append(flags_string);
118328:                   BPLOG(INFO) << "Unknown exception reason " << reason;
118328:                   break;
118328:               }
118328:               break;
118328:             }
  3869:             case MD_CPU_ARCHITECTURE_PPC: {
  3869:               switch (exception_flags) {
  3869:                 case MD_EXCEPTION_CODE_MAC_PPC_BREAKPOINT:
  3869:                   reason.append("EXC_PPC_BREAKPOINT");
  3869:                   break;
  3869:                 default:
  3869:                   reason.append(flags_string);
  3897:                   BPLOG(INFO) << "Unknown exception reason " << reason;
  3869:                   break;
  3869:               }
  3869:               break;
  3869:             }
  3869:             case MD_CPU_ARCHITECTURE_X86: {
  3869:               switch (exception_flags) {
  3869:                 case MD_EXCEPTION_CODE_MAC_X86_SGL:
  3869:                   reason.append("EXC_I386_SGL");
  3869:                   break;
  3869:                 case MD_EXCEPTION_CODE_MAC_X86_BPT:
  3869:                   reason.append("EXC_I386_BPT");
  3869:                   break;
  3869:                 default:
  3869:                   reason.append(flags_string);
  3897:                   BPLOG(INFO) << "Unknown exception reason " << reason;
  3869:                   break;
  3869:               }
  3869:               break;
  3869:             }
  3869:             default:
  3869:               reason.append(flags_string);
  3897:               BPLOG(INFO) << "Unknown exception reason " << reason;
  3869:               break;
  3869:           }
  3869:           break;
  3869:         case MD_EXCEPTION_MAC_SYSCALL:
  3869:           reason = "EXC_SYSCALL / ";
  3869:           reason.append(flags_string);
  3869:           break;
  3869:         case MD_EXCEPTION_MAC_MACH_SYSCALL:
  3869:           reason = "EXC_MACH_SYSCALL / ";
  3869:           reason.append(flags_string);
  3869:           break;
  3869:         case MD_EXCEPTION_MAC_RPC_ALERT:
  3869:           reason = "EXC_RPC_ALERT / ";
  3869:           reason.append(flags_string);
  3869:           break;
  3869:       }
  3869:       break;
  3869:     }
  3869: 
  3863:     case MD_OS_WIN32_NT:
  3863:     case MD_OS_WIN32_WINDOWS: {
  3869:       switch (exception_code) {
  3863:         case MD_EXCEPTION_CODE_WIN_CONTROL_C:
  3863:           reason = "DBG_CONTROL_C";
  3863:           break;
  3863:         case MD_EXCEPTION_CODE_WIN_GUARD_PAGE_VIOLATION:
  3863:           reason = "EXCEPTION_GUARD_PAGE";
  3863:           break;
  3863:         case MD_EXCEPTION_CODE_WIN_DATATYPE_MISALIGNMENT:
  3863:           reason = "EXCEPTION_DATATYPE_MISALIGNMENT";
  3863:           break;
  3863:         case MD_EXCEPTION_CODE_WIN_BREAKPOINT:
  3863:           reason = "EXCEPTION_BREAKPOINT";
  3863:           break;
  3863:         case MD_EXCEPTION_CODE_WIN_SINGLE_STEP:
  3863:           reason = "EXCEPTION_SINGLE_STEP";
  3863:           break;
  3863:         case MD_EXCEPTION_CODE_WIN_ACCESS_VIOLATION:
  3863:           // For EXCEPTION_ACCESS_VIOLATION, Windows puts the address that
  3863:           // caused the fault in exception_information[1].
  3863:           // exception_information[0] is 0 if the violation was caused by
  3863:           // an attempt to read data and 1 if it was an attempt to write
  3863:           // data.
  3863:           // This information is useful in addition to the code address, which
  3863:           // will be present in the crash thread's instruction field anyway.
 47243:           if (raw_exception->exception_record.number_parameters >= 1) {
114869:             MDAccessViolationTypeWin av_type =
114869:                 static_cast<MDAccessViolationTypeWin>
114869:                 (raw_exception->exception_record.exception_information[0]);
114869:             switch (av_type) {
114869:               case MD_ACCESS_VIOLATION_WIN_READ:
 47243:                 reason = "EXCEPTION_ACCESS_VIOLATION_READ";
 47243:                 break;
114869:               case MD_ACCESS_VIOLATION_WIN_WRITE:
 47243:                 reason = "EXCEPTION_ACCESS_VIOLATION_WRITE";
 47243:                 break;
114869:               case MD_ACCESS_VIOLATION_WIN_EXEC:
 47243:                 reason = "EXCEPTION_ACCESS_VIOLATION_EXEC";
 47243:                 break;
 47243:               default:
  3863:                 reason = "EXCEPTION_ACCESS_VIOLATION";
 47243:                 break;
 47243:             }
 47243:           } else {
 47243:             reason = "EXCEPTION_ACCESS_VIOLATION";
 47243:           }
  3863:           if (address &&
  3863:               raw_exception->exception_record.number_parameters >= 2) {
  3863:             *address =
  3863:                 raw_exception->exception_record.exception_information[1];
  3863:           }
  3863:           break;
  3863:         case MD_EXCEPTION_CODE_WIN_IN_PAGE_ERROR:
  3863:           reason = "EXCEPTION_IN_PAGE_ERROR";
  3863:           break;
  3863:         case MD_EXCEPTION_CODE_WIN_INVALID_HANDLE:
  3863:           reason = "EXCEPTION_INVALID_HANDLE";
  3863:           break;
  3863:         case MD_EXCEPTION_CODE_WIN_ILLEGAL_INSTRUCTION:
  3863:           reason = "EXCEPTION_ILLEGAL_INSTRUCTION";
  3863:           break;
  3863:         case MD_EXCEPTION_CODE_WIN_NONCONTINUABLE_EXCEPTION:
  3863:           reason = "EXCEPTION_NONCONTINUABLE_EXCEPTION";
  3863:           break;
  3863:         case MD_EXCEPTION_CODE_WIN_INVALID_DISPOSITION:
  3863:           reason = "EXCEPTION_INVALID_DISPOSITION";
  3863:           break;
  3863:         case MD_EXCEPTION_CODE_WIN_ARRAY_BOUNDS_EXCEEDED:
  3863:           reason = "EXCEPTION_BOUNDS_EXCEEDED";
  3863:           break;
  3863:         case MD_EXCEPTION_CODE_WIN_FLOAT_DENORMAL_OPERAND:
  3863:           reason = "EXCEPTION_FLT_DENORMAL_OPERAND";
  3863:           break;
  3863:         case MD_EXCEPTION_CODE_WIN_FLOAT_DIVIDE_BY_ZERO:
  3863:           reason = "EXCEPTION_FLT_DIVIDE_BY_ZERO";
  3863:           break;
  3863:         case MD_EXCEPTION_CODE_WIN_FLOAT_INEXACT_RESULT:
  3863:           reason = "EXCEPTION_FLT_INEXACT_RESULT";
  3863:           break;
  3863:         case MD_EXCEPTION_CODE_WIN_FLOAT_INVALID_OPERATION:
  3863:           reason = "EXCEPTION_FLT_INVALID_OPERATION";
  3863:           break;
  3863:         case MD_EXCEPTION_CODE_WIN_FLOAT_OVERFLOW:
  3863:           reason = "EXCEPTION_FLT_OVERFLOW";
  3863:           break;
  3863:         case MD_EXCEPTION_CODE_WIN_FLOAT_STACK_CHECK:
  3863:           reason = "EXCEPTION_FLT_STACK_CHECK";
  3863:           break;
  3863:         case MD_EXCEPTION_CODE_WIN_FLOAT_UNDERFLOW:
  3863:           reason = "EXCEPTION_FLT_UNDERFLOW";
  3863:           break;
  3863:         case MD_EXCEPTION_CODE_WIN_INTEGER_DIVIDE_BY_ZERO:
  3863:           reason = "EXCEPTION_INT_DIVIDE_BY_ZERO";
  3863:           break;
  3863:         case MD_EXCEPTION_CODE_WIN_INTEGER_OVERFLOW:
  3863:           reason = "EXCEPTION_INT_OVERFLOW";
  3863:           break;
  3863:         case MD_EXCEPTION_CODE_WIN_PRIVILEGED_INSTRUCTION:
  3863:           reason = "EXCEPTION_PRIV_INSTRUCTION";
  3863:           break;
  3863:         case MD_EXCEPTION_CODE_WIN_STACK_OVERFLOW:
  3863:           reason = "EXCEPTION_STACK_OVERFLOW";
  3863:           break;
  3863:         case MD_EXCEPTION_CODE_WIN_POSSIBLE_DEADLOCK:
  3863:           reason = "EXCEPTION_POSSIBLE_DEADLOCK";
  3863:           break;
 47243:         case MD_EXCEPTION_CODE_WIN_STACK_BUFFER_OVERRUN:
 47243:           reason = "EXCEPTION_STACK_BUFFER_OVERRUN";
 47243:           break;
 47243:         case MD_EXCEPTION_CODE_WIN_HEAP_CORRUPTION:
 47243:           reason = "EXCEPTION_HEAP_CORRUPTION";
 47243:           break;
 36832:         case MD_EXCEPTION_CODE_WIN_UNHANDLED_CPP_EXCEPTION:
 36832:           reason = "Unhandled C++ Exception";
 36832:           break;
  3897:         default:
  3897:           BPLOG(INFO) << "Unknown exception reason " << reason;
  3897:           break;
  3863:       }
  3897:       break;
  7079:     }
  3910: 
114869:     case MD_OS_ANDROID:
  7079:     case MD_OS_LINUX: {
  3910:       switch (exception_code) {
  3910:         case MD_EXCEPTION_CODE_LIN_SIGHUP:
  3910:           reason = "SIGHUP";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGINT:
  3910:           reason = "SIGINT";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGQUIT:
  3910:           reason = "SIGQUIT";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGILL:
  3910:           reason = "SIGILL";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGTRAP:
  3910:           reason = "SIGTRAP";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGABRT:
  3910:           reason = "SIGABRT";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGBUS:
  3910:           reason = "SIGBUS";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGFPE:
  3910:           reason = "SIGFPE";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGKILL:
  3910:           reason = "SIGKILL";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGUSR1:
  3910:           reason = "SIGUSR1";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGSEGV:
  3910:           reason = "SIGSEGV";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGUSR2:
  3910:           reason = "SIGUSR2";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGPIPE:
  3910:           reason = "SIGPIPE";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGALRM:
  3910:           reason = "SIGALRM";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGTERM:
  3910:           reason = "SIGTERM";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGSTKFLT:
  3910:           reason = "SIGSTKFLT";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGCHLD:
  3910:           reason = "SIGCHLD";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGCONT:
  3910:           reason = "SIGCONT";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGSTOP:
  3910:           reason = "SIGSTOP";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGTSTP:
  3910:           reason = "SIGTSTP";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGTTIN:
  3910:           reason = "SIGTTIN";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGTTOU:
  3910:           reason = "SIGTTOU";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGURG:
  3910:           reason = "SIGURG";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGXCPU:
  3910:           reason = "SIGXCPU";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGXFSZ:
  3910:           reason = "SIGXFSZ";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGVTALRM:
  3910:           reason = "SIGVTALRM";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGPROF:
  3910:           reason = "SIGPROF";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGWINCH:
  3910:           reason = "SIGWINCH";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGIO:
  3910:           reason = "SIGIO";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGPWR:
  3910:           reason = "SIGPWR";
  3910:           break;
  3910:         case MD_EXCEPTION_CODE_LIN_SIGSYS:
  3910:           reason = "SIGSYS";
  3910:           break;
114869:       case MD_EXCEPTION_CODE_LIN_DUMP_REQUESTED:
114869:           reason = "DUMP_REQUESTED";
114869:           break;
  3910:         default:
  3910:           BPLOG(INFO) << "Unknown exception reason " << reason;
  3910:           break;
  3910:       }
  3910:       break;
  3897:     }
  3897: 
  7079:     case MD_OS_SOLARIS: {
  7079:       switch (exception_code) {
  7079:         case MD_EXCEPTION_CODE_SOL_SIGHUP:
  7079:           reason = "SIGHUP";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGINT:
  7079:           reason = "SIGINT";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGQUIT:
  7079:           reason = "SIGQUIT";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGILL:
  7079:           reason = "SIGILL";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGTRAP:
  7079:           reason = "SIGTRAP";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGIOT:
  7079:           reason = "SIGIOT | SIGABRT";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGEMT:
  7079:           reason = "SIGEMT";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGFPE:
  7079:           reason = "SIGFPE";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGKILL:
  7079:           reason = "SIGKILL";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGBUS:
  7079:           reason = "SIGBUS";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGSEGV:
  7079:           reason = "SIGSEGV";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGSYS:
  7079:           reason = "SIGSYS";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGPIPE:
  7079:           reason = "SIGPIPE";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGALRM:
  7079:           reason = "SIGALRM";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGTERM:
  7079:           reason = "SIGTERM";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGUSR1:
  7079:           reason = "SIGUSR1";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGUSR2:
  7079:           reason = "SIGUSR2";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGCLD:
  7079:           reason = "SIGCLD | SIGCHLD";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGPWR:
  7079:           reason = "SIGPWR";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGWINCH:
  7079:           reason = "SIGWINCH";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGURG:
  7079:           reason = "SIGURG";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGPOLL:
  7079:           reason = "SIGPOLL | SIGIO";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGSTOP:
  7079:           reason = "SIGSTOP";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGTSTP:
  7079:           reason = "SIGTSTP";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGCONT:
  7079:           reason = "SIGCONT";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGTTIN:
  7079:           reason = "SIGTTIN";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGTTOU:
  7079:           reason = "SIGTTOU";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGVTALRM:
  7079:           reason = "SIGVTALRM";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGPROF:
  7079:           reason = "SIGPROF";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGXCPU:
  7079:           reason = "SIGXCPU";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGXFSZ:
  7079:           reason = "SIGXFSZ";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGWAITING:
  7079:           reason = "SIGWAITING";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGLWP:
  7079:           reason = "SIGLWP";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGFREEZE:
  7079:           reason = "SIGFREEZE";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGTHAW:
  7079:           reason = "SIGTHAW";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGCANCEL:
  7079:           reason = "SIGCANCEL";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGLOST:
  7079:           reason = "SIGLOST";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGXRES:
  7079:           reason = "SIGXRES";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGJVM1:
  7079:           reason = "SIGJVM1";
  7079:           break;
  7079:         case MD_EXCEPTION_CODE_SOL_SIGJVM2:
  7079:           reason = "SIGJVM2";
  7079:           break;
  7079:         default:
  7079:           BPLOG(INFO) << "Unknown exception reason " << reason;
  7079:           break;
  7079:       }
  7079:       break;
  7079:     }
  7079: 
  3897:     default: {
  3897:       BPLOG(INFO) << "Unknown exception reason " << reason;
  3897:       break;
  3863:     }
  3863:   }
  3863: 
  3863:   return reason;
  3863: }
  3863: 
 36832: // static
114869: string MinidumpProcessor::GetAssertion(Minidump *dump) {
 36832:   MinidumpAssertion *assertion = dump->GetAssertion();
 36832:   if (!assertion)
 36832:     return "";
 36832: 
 36832:   const MDRawAssertionInfo *raw_assertion = assertion->assertion();
 36832:   if (!raw_assertion)
 36832:     return "";
 36832: 
 36832:   string assertion_string;
 36832:   switch (raw_assertion->type) {
 36832:   case MD_ASSERTION_INFO_TYPE_INVALID_PARAMETER:
 36832:     assertion_string = "Invalid parameter passed to library function";
 36832:     break;
 36832:   case MD_ASSERTION_INFO_TYPE_PURE_VIRTUAL_CALL:
 36832:     assertion_string = "Pure virtual function called";
 36832:     break;
 36832:   default: {
 36832:     char assertion_type[32];
 36832:     sprintf(assertion_type, "0x%08x", raw_assertion->type);
 36832:     assertion_string = "Unknown assertion type ";
 36832:     assertion_string += assertion_type;
 36832:     break;
 36832:   }
 36832:   }
 36832: 
 36832:   string expression = assertion->expression();
 36832:   if (!expression.empty()) {
 36832:     assertion_string.append(" " + expression);
 36832:   }
 36832: 
 36832:   string function = assertion->function();
 36832:   if (!function.empty()) {
 36832:     assertion_string.append(" in function " + function);
 36832:   }
 36832: 
 36832:   string file = assertion->file();
 36832:   if (!file.empty()) {
 36832:     assertion_string.append(", in file " + file);
 36832:   }
 36832: 
 36832:   if (raw_assertion->line != 0) {
 36832:     char assertion_line[32];
 36832:     sprintf(assertion_line, "%u", raw_assertion->line);
 36832:     assertion_string.append(" at line ");
 36832:     assertion_string.append(assertion_line);
 36832:   }
 36832: 
 36832:   return assertion_string;
 36832: }
 36832: 
  3869: }  // namespace google_breakpad
