23697: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
23697: /* ***** BEGIN LICENSE BLOCK *****
23697:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
23697:  *
23697:  * The contents of this file are subject to the Mozilla Public License Version
23697:  * 1.1 (the "License"); you may not use this file except in compliance with
23697:  * the License. You may obtain a copy of the License at
23697:  * http://www.mozilla.org/MPL/
23697:  *
23697:  * Software distributed under the License is distributed on an "AS IS" basis,
23697:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
23697:  * for the specific language governing rights and limitations under the
23697:  * License.
23697:  *
23697:  * The Original Code is the Mozilla SMIL module.
23697:  *
23697:  * The Initial Developer of the Original Code is Brian Birtles.
23697:  * Portions created by the Initial Developer are Copyright (C) 2005
23697:  * the Initial Developer. All Rights Reserved.
23697:  *
23697:  * Contributor(s):
23697:  *   Brian Birtles <birtles@gmail.com>
23697:  *
23697:  * Alternatively, the contents of this file may be used under the terms of
23697:  * either of the GNU General Public License Version 2 or later (the "GPL"),
23697:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
23697:  * in which case the provisions of the GPL or the LGPL are applicable instead
23697:  * of those above. If you wish to allow use of your version of this file only
23697:  * under the terms of either the GPL or the LGPL, and not to allow others to
23697:  * use your version of this file under the terms of the MPL, indicate your
23697:  * decision by deleting the provisions above and replace them with the notice
23697:  * and other provisions required by the GPL or the LGPL. If you do not delete
23697:  * the provisions above, a recipient may use your version of this file under
23697:  * the terms of any one of the MPL, the GPL or the LGPL.
23697:  *
23697:  * ***** END LICENSE BLOCK ***** */
23697: 
23697: #ifndef NS_SMILTIMEDELEMENT_H_
23697: #define NS_SMILTIMEDELEMENT_H_
23697: 
23697: #include "nsSMILInterval.h"
23697: #include "nsSMILInstanceTime.h"
37113: #include "nsSMILMilestone.h"
23697: #include "nsSMILTimeValueSpec.h"
23697: #include "nsSMILRepeatCount.h"
23697: #include "nsSMILTypes.h"
23697: #include "nsTArray.h"
37116: #include "nsTHashtable.h"
37116: #include "nsHashKeys.h"
23697: #include "nsAutoPtr.h"
23697: #include "nsAttrValue.h"
23697: 
37113: class nsISMILAnimationElement;
23697: class nsSMILAnimationFunction;
23697: class nsSMILTimeContainer;
23697: class nsSMILTimeValue;
23697: class nsIAtom;
23697: 
23697: //----------------------------------------------------------------------
23697: // nsSMILTimedElement
23697: 
23697: class nsSMILTimedElement
23697: {
23697: public:
23697:   nsSMILTimedElement();
38818:   ~nsSMILTimedElement();
23697: 
50805:   typedef mozilla::dom::Element Element;
50805: 
37113:   /*
37113:    * Sets the owning animation element which this class uses to convert between
37113:    * container times and to register timebase elements.
37113:    */
37113:   void SetAnimationElement(nsISMILAnimationElement* aElement);
37113: 
37113:   /*
37113:    * Returns the time container with which this timed element is associated or
37113:    * nsnull if it is not associated with a time container.
37113:    */
37113:   nsSMILTimeContainer* GetTimeContainer();
37113: 
50806:   /*
50806:    * Returns the element targeted by the animation element. Needed for
50806:    * registering event listeners against the appropriate element.
50806:    */
50806:   mozilla::dom::Element* GetTargetElement()
50806:   {
50806:     return mAnimationElement ?
50806:         mAnimationElement->GetTargetElementContent() :
50806:         nsnull;
50806:   }
50806: 
23697:   /**
23697:    * Methods for supporting the nsIDOMElementTimeControl interface.
23697:    */
23697: 
23697:   /*
37113:    * Adds a new begin instance time at the current container time plus or minus
37113:    * the specified offset.
23697:    *
23697:    * @param aOffsetSeconds A real number specifying the number of seconds to add
23697:    *                       to the current container time.
23697:    * @return NS_OK if the operation succeeeded, or an error code otherwise.
23697:    */
37113:   nsresult BeginElementAt(double aOffsetSeconds);
23697: 
23697:   /*
37113:    * Adds a new end instance time at the current container time plus or minus
37113:    * the specified offset.
23697:    *
23697:    * @param aOffsetSeconds A real number specifying the number of seconds to add
23697:    *                       to the current container time.
23697:    * @return NS_OK if the operation succeeeded, or an error code otherwise.
23697:    */
37113:   nsresult EndElementAt(double aOffsetSeconds);
23697: 
23697:   /**
23929:    * Methods for supporting the nsSVGAnimationElement interface.
23929:    */
23929: 
23929:   /**
33782:    * According to SVG 1.1 SE this returns
23929:    *
33782:    *   the begin time, in seconds, for this animation element's current
33782:    *   interval, if it exists, regardless of whether the interval has begun yet.
23929:    *
33782:    * @return the start time as defined above in milliseconds or an unresolved
33782:    * time if there is no current interval.
23929:    */
23929:   nsSMILTimeValue GetStartTime() const;
23929: 
23929:   /**
23929:    * Returns the simple duration of this element.
23929:    *
23929:    * @return the simple duration in milliseconds or INDEFINITE.
23929:    */
23929:   nsSMILTimeValue GetSimpleDuration() const
23929:   {
23929:     return mSimpleDur;
23929:   }
23929: 
23929:   /**
23929:    * Internal SMIL methods
23929:    */
23929: 
23929:   /**
23697:    * Adds an instance time object this element's list of instance times.
23697:    * These instance times are used when creating intervals.
23697:    *
23697:    * This method is typically called by an nsSMILTimeValueSpec.
23697:    *
37113:    * @param aInstanceTime   The time to add, expressed in container time.
37113:    * @param aIsBegin        PR_TRUE if the time to be added represents a begin
37113:    *                        time or PR_FALSE if it represents an end time.
23697:    */
37115:   void AddInstanceTime(nsSMILInstanceTime* aInstanceTime, PRBool aIsBegin);
37115: 
37115:   /**
37115:    * Requests this element update the given instance time.
37115:    *
37115:    * This method is typically called by a child nsSMILTimeValueSpec.
37115:    *
37115:    * @param aInstanceTime   The instance time to update.
37115:    * @param aUpdatedTime    The time to update aInstanceTime with.
37115:    * @param aDependentTime  The instance time upon which aInstanceTime should be
37115:    *                        based.
37115:    * @param aIsBegin        PR_TRUE if the time to be updated represents a begin
37115:    *                        instance time or PR_FALSE if it represents an end
37115:    *                        instance time.
37115:    */
37115:   void UpdateInstanceTime(nsSMILInstanceTime* aInstanceTime,
37115:                           nsSMILTimeValue& aUpdatedTime,
23697:                           PRBool aIsBegin);
23697: 
23697:   /**
42519:    * Removes an instance time object from this element's list of instance times.
37115:    *
37115:    * This method is typically called by a child nsSMILTimeValueSpec.
37115:    *
37115:    * @param aInstanceTime   The instance time to remove.
37115:    * @param aIsBegin        PR_TRUE if the time to be removed represents a begin
37115:    *                        time or PR_FALSE if it represents an end time.
37115:    */
37115:   void RemoveInstanceTime(nsSMILInstanceTime* aInstanceTime, PRBool aIsBegin);
37115: 
37115:   /**
38818:    * Removes all the instance times associated with the given
38818:    * nsSMILTimeValueSpec object. Used when an ID assignment changes and hence
38818:    * all the previously associated instance times become invalid.
38818:    *
38818:    * @param aSpec    The nsSMILTimeValueSpec object whose created
38818:    *                 nsSMILInstanceTime's should be removed.
38818:    * @param aIsBegin PR_TRUE if the times to be removed represent begin
38818:    *                 times or PR_FALSE if they are end times.
38818:    */
38818:   void RemoveInstanceTimesForCreator(const nsSMILTimeValueSpec* aSpec,
38818:                                      PRBool aIsBegin);
38818: 
38818:   /**
23697:    * Sets the object that will be called by this timed element each time it is
23697:    * sampled.
23697:    *
23697:    * In Schmitz's model it is possible to associate several time clients with
23697:    * a timed element but for now we only allow one.
23697:    *
23697:    * @param aClient   The time client to associate. Any previous time client
23697:    *                  will be disassociated and no longer sampled. Setting this
23697:    *                  to nsnull will simply disassociate the previous client, if
23697:    *                  any.
23697:    */
23697:   void SetTimeClient(nsSMILAnimationFunction* aClient);
23697: 
23697:   /**
37113:    * Samples the object at the given container time. Timing intervals are
37113:    * updated and if this element is active at the given time the associated time
37113:    * client will be sampled with the appropriate simple time.
23697:    *
37113:    * @param aContainerTime The container time at which to sample.
23697:    */
37113:   void SampleAt(nsSMILTime aContainerTime);
37113: 
37113:   /**
37113:    * Performs a special sample for the end of an interval. Such a sample should
37113:    * only advance the timed element (and any dependent elements) to the waiting
37113:    * or postactive state. It should not cause a transition to the active state.
37113:    * Transition to the active state is only performed on a regular SampleAt.
37113:    *
37113:    * This allows all interval ends at a given time to be processed first and
37113:    * hence the new interval can be established based on full information of the
37113:    * available instance times.
37113:    *
37113:    * @param aContainerTime The container time at which to sample.
37113:    */
37113:   void SampleEndAt(nsSMILTime aContainerTime);
23697: 
23697:   /**
37115:    * Informs the timed element that its time container has changed time
37115:    * relative to document time. The timed element therefore needs to update its
37115:    * dependent elements (which may belong to a different time container) so they
37115:    * can re-resolve their times.
37115:    */
37115:   void HandleContainerTimeChange();
37115: 
37115:   /**
47197:    * Resets this timed element's accumulated times and intervals back to start
47197:    * up state.
47197:    *
47197:    * This is used for backwards seeking where rather than accumulating
47197:    * historical timing state and winding it back, we reset the element and seek
47197:    * forwards.
47197:    */
47197:   void Rewind();
47197: 
47197:   /**
23697:    * Attempts to set an attribute on this timed element.
23697:    *
23697:    * @param aAttribute  The name of the attribute to set. The namespace of this
23697:    *                    attribute is not specified as it is checked by the host
23697:    *                    element. Only attributes in the namespace defined for
23697:    *                    SMIL attributes in the host language are passed to the
23697:    *                    timed element.
23697:    * @param aValue      The attribute value.
23697:    * @param aResult     The nsAttrValue object that may be used for storing the
23697:    *                    parsed result.
50805:    * @param aContextNode The element to use for context when resolving
50805:    *                     references to other elements.
23697:    * @param[out] aParseResult The result of parsing the attribute. Will be set
23697:    *                          to NS_OK if parsing is successful.
23697:    *
23697:    * @return PR_TRUE if the given attribute is a timing attribute, PR_FALSE
23697:    * otherwise.
23697:    */
23697:   PRBool SetAttr(nsIAtom* aAttribute, const nsAString& aValue,
50805:                  nsAttrValue& aResult, Element* aContextNode,
37115:                  nsresult* aParseResult = nsnull);
23697: 
23697:   /**
23697:    * Attempts to unset an attribute on this timed element.
23697:    *
23697:    * @param aAttribute  The name of the attribute to set. As with SetAttr the
23697:    *                    namespace of the attribute is not specified (see
23697:    *                    SetAttr).
23697:    *
23697:    * @return PR_TRUE if the given attribute is a timing attribute, PR_FALSE
23697:    * otherwise.
23697:    */
23697:   PRBool UnsetAttr(nsIAtom* aAttribute);
23697: 
37113:   /**
37115:    * Adds a syncbase dependency to the list of dependents that will be notified
37115:    * when this timed element creates, deletes, or updates its current interval.
37115:    *
37115:    * @param aDependent  The nsSMILTimeValueSpec object to notify. A raw pointer
37115:    *                    to this object will be stored. Therefore it is necessary
37115:    *                    for the object to be explicitly unregistered (with
37115:    *                    RemoveDependent) when it is destroyed.
37113:    */
37115:   void AddDependent(nsSMILTimeValueSpec& aDependent);
37115: 
37115:   /**
37115:    * Removes a syncbase dependency from the list of dependents that are notified
37115:    * when the current interval is modified.
37115:    *
37115:    * @param aDependent  The nsSMILTimeValueSpec object to unregister.
37115:    */
37116:   void RemoveDependent(nsSMILTimeValueSpec& aDependent);
37115: 
37115:   /**
37115:    * Determines if this timed element is dependent on the given timed element's
37115:    * begin time for the interval currently in effect. Whilst the element is in
37115:    * the active state this is the current interval and in the postactive or
37115:    * waiting state this is the previous interval if one exists. In all other
37115:    * cases the element is not considered a time dependent of any other element.
37115:    *
37115:    * @param aOther    The potential syncbase element.
37115:    * @return PR_TRUE if this timed element's begin time for the currently
37115:    * effective interval is directly or indirectly derived from aOther, PR_FALSE
37115:    * otherwise.
37115:    */
37115:   PRBool IsTimeDependent(const nsSMILTimedElement& aOther) const;
37115: 
37115:   /**
37115:    * Called when the timed element has been bound to the document so that
37115:    * references from this timed element to other elements can be resolved.
37115:    *
37115:    * @param aContextNode  The node which provides the necessary context for
37115:    *                      resolving references. This is typically the element in
37115:    *                      the host language that owns this timed element. Should
37115:    *                      not be null.
37115:    */
37115:   void BindToTree(nsIContent* aContextNode);
37115: 
37115:   /**
50806:    * Called when the target of the animation has changed so that event
50806:    * registrations can be updated.
50806:    */
50806:   void HandleTargetElementChange(mozilla::dom::Element* aNewTarget);
50806: 
50806:   /**
37115:    * Called when the timed element has been removed from a document so that
37115:    * references to other elements can be broken.
37115:    */
37115:   void DissolveReferences() { Unlink(); }
37115: 
37115:   // Cycle collection
37115:   void Traverse(nsCycleCollectionTraversalCallback* aCallback);
37115:   void Unlink();
37113: 
50803:   typedef PRBool (*RemovalTestFunction)(nsSMILInstanceTime* aInstance);
50803: 
23697: protected:
37115:   // Typedefs
37115:   typedef nsTArray<nsAutoPtr<nsSMILTimeValueSpec> > TimeValueSpecList;
37115:   typedef nsTArray<nsRefPtr<nsSMILInstanceTime> >   InstanceTimeList;
38818:   typedef nsTArray<nsAutoPtr<nsSMILInterval> >      IntervalList;
37116:   typedef nsPtrHashKey<nsSMILTimeValueSpec> TimeValueSpecPtrKey;
37116:   typedef nsTHashtable<TimeValueSpecPtrKey> TimeValueSpecHashSet;
37115: 
37115:   // Helper classes
37115:   class InstanceTimeComparator {
37115:     public:
37115:       PRBool Equals(const nsSMILInstanceTime* aElem1,
37115:                     const nsSMILInstanceTime* aElem2) const;
37115:       PRBool LessThan(const nsSMILInstanceTime* aElem1,
37115:                       const nsSMILInstanceTime* aElem2) const;
37115:   };
37115: 
37116:   struct NotifyTimeDependentsParams {
37116:     nsSMILInterval*      mCurrentInterval;
37116:     nsSMILTimeContainer* mTimeContainer;
37116:   };
37116: 
47196:   // Templated helper functions
47196:   template <class TestFunctor>
47196:   void RemoveInstanceTimes(InstanceTimeList& aArray, TestFunctor& aTest);
47196: 
23697:   //
23697:   // Implementation helpers
23697:   //
23697: 
37115:   nsresult          SetBeginSpec(const nsAString& aBeginSpec,
50805:                                  Element* aContextNode,
50803:                                  RemovalTestFunction aRemove);
37115:   nsresult          SetEndSpec(const nsAString& aEndSpec,
50805:                                Element* aContextNode,
50803:                                RemovalTestFunction aRemove);
23697:   nsresult          SetSimpleDuration(const nsAString& aDurSpec);
23697:   nsresult          SetMin(const nsAString& aMinSpec);
23697:   nsresult          SetMax(const nsAString& aMaxSpec);
23697:   nsresult          SetRestart(const nsAString& aRestartSpec);
23697:   nsresult          SetRepeatCount(const nsAString& aRepeatCountSpec);
23697:   nsresult          SetRepeatDur(const nsAString& aRepeatDurSpec);
23697:   nsresult          SetFillMode(const nsAString& aFillModeSpec);
23697: 
50803:   void              UnsetBeginSpec(RemovalTestFunction aRemove);
50803:   void              UnsetEndSpec(RemovalTestFunction aRemove);
23697:   void              UnsetSimpleDuration();
23697:   void              UnsetMin();
23697:   void              UnsetMax();
23697:   void              UnsetRestart();
23697:   void              UnsetRepeatCount();
23697:   void              UnsetRepeatDur();
23697:   void              UnsetFillMode();
23697: 
37115:   nsresult          SetBeginOrEndSpec(const nsAString& aSpec,
50805:                                       Element* aContextNode,
50803:                                       PRBool aIsBegin,
50803:                                       RemovalTestFunction aRemove);
50803:   void              ClearSpecs(TimeValueSpecList& aSpecs,
50803:                                InstanceTimeList& aInstances,
50803:                                RemovalTestFunction aRemove);
74323:   void              ClearIntervals();
37113:   void              DoSampleAt(nsSMILTime aContainerTime, PRBool aEndOnly);
23697: 
23697:   /**
47196:    * Helper function to check for an early end and, if necessary, update the
47196:    * current interval accordingly.
47196:    *
47196:    * See SMIL 3.0, section 5.4.5, Element life cycle, "Active Time - Playing an
47196:    * interval" for a description of ending early.
47196:    *
47196:    * @param aSampleTime The current sample time. Early ends should only be
47196:    *                    applied at the last possible moment (i.e. if they are at
47196:    *                    or before the current sample time) and only if the
47196:    *                    current interval is not already ending.
71823:    * @return PR_TRUE if the end time of the current interval was updated,
71823:    *         PR_FALSE otherwise.
47196:    */
71823:   PRBool ApplyEarlyEnd(const nsSMILTimeValue& aSampleTime);
47196: 
47196:   /**
47196:    * Clears certain state in response to the element restarting.
47196:    *
47196:    * This state is described in SMIL 3.0, section 5.4.3, Resetting element state
47196:    */
47196:   void Reset();
47196: 
47196:   /**
47197:    * Completes a seek operation by sending appropriate events and, in the case
47197:    * of a backwards seek, updating the state of timing information that was
47197:    * previously considered historical.
47197:    */
47197:   void DoPostSeek();
47197: 
47197:   /**
47197:    * Unmarks instance times that were previously preserved because they were
47197:    * considered important historical milestones but are no longer such because
47197:    * a backwards seek has been performed.
47197:    */
47197:   void UnpreserveInstanceTimes(InstanceTimeList& aList);
47197: 
47197:   /**
47196:    * Helper function to iterate through this element's accumulated timing
47196:    * information (specifically old nsSMILIntervals and nsSMILTimeInstanceTimes)
47196:    * and discard items that are no longer needed or exceed some threshold of
47196:    * accumulated state.
47196:    */
47196:   void FilterHistory();
47196: 
47196:   // Helper functions for FilterHistory to clear old nsSMILIntervals and
47196:   // nsSMILInstanceTimes respectively.
47196:   void FilterIntervals();
47196:   void FilterInstanceTimes(InstanceTimeList& aList);
47196: 
47196:   /**
37115:    * Calculates the next acceptable interval for this element after the
37115:    * specified interval, or, if no previous interval is specified, it will be
37115:    * the first interval with an end time after t=0.
23697:    *
23697:    * @see SMILANIM 3.6.8
37115:    *
37115:    * @param aPrevInterval   The previous interval used. If supplied, the first
37115:    *                        interval that begins after aPrevInterval will be
37115:    *                        returned. May be nsnull.
72214:    * @param aReplacedInterval The interval that is being updated (if any). This
72214:    *                        used to ensure we don't return interval endpoints
72214:    *                        that are dependent on themselves. May be nsnull.
37115:    * @param aFixedBeginTime The time to use for the start of the interval. This
37115:    *                        is used when only the endpoint of the interval
37115:    *                        should be updated such as when the animation is in
37115:    *                        the ACTIVE state. May be nsnull.
37115:    * @param[out] aResult    The next interval. Will be unchanged if no suitable
64043:    *                        interval was found (in which case PR_FALSE will be
64043:    *                        returned).
64043:    * @return  PR_TRUE if a suitable interval was found, PR_FALSE otherwise.
23697:    */
64043:   PRBool            GetNextInterval(const nsSMILInterval* aPrevInterval,
72214:                                     const nsSMILInterval* aReplacedInterval,
37115:                                     const nsSMILInstanceTime* aFixedBeginTime,
38819:                                     nsSMILInterval& aResult) const;
37115:   nsSMILInstanceTime* GetNextGreater(const InstanceTimeList& aList,
31133:                                      const nsSMILTimeValue& aBase,
37115:                                      PRInt32& aPosition) const;
37115:   nsSMILInstanceTime* GetNextGreaterOrEqual(const InstanceTimeList& aList,
23697:                                             const nsSMILTimeValue& aBase,
37115:                                             PRInt32& aPosition) const;
23697:   nsSMILTimeValue   CalcActiveEnd(const nsSMILTimeValue& aBegin,
37113:                                   const nsSMILTimeValue& aEnd) const;
37113:   nsSMILTimeValue   GetRepeatDuration() const;
37113:   nsSMILTimeValue   ApplyMinAndMax(const nsSMILTimeValue& aDuration) const;
23697:   nsSMILTime        ActiveTimeToSimpleTime(nsSMILTime aActiveTime,
23697:                                            PRUint32& aRepeatIteration);
37115:   nsSMILInstanceTime* CheckForEarlyEnd(
37113:                         const nsSMILTimeValue& aContainerTime) const;
37115:   void              UpdateCurrentInterval(PRBool aForceChangeNotice = PR_FALSE);
23697:   void              SampleSimpleTime(nsSMILTime aActiveTime);
23697:   void              SampleFillValue();
24029:   void              AddInstanceTimeFromCurrentTime(nsSMILTime aCurrentTime,
24029:                         double aOffsetSeconds, PRBool aIsBegin);
37113:   void              RegisterMilestone();
37113:   PRBool            GetNextMilestone(nsSMILMilestone& aNextMilestone) const;
23697: 
71823:   // Notification methods. Note that these notifications can result in nested
71823:   // calls to this same object. Therefore,
71823:   // (i)  we should not perform notification until this object is in
71823:   //      a consistent state to receive callbacks, and
71823:   // (ii) after calling these methods we must assume that the state of the
71823:   //      element may have changed.
37115:   void              NotifyNewInterval();
71823:   void              NotifyChangedInterval(nsSMILInterval* aInterval,
71823:                                           PRBool aBeginObjectChanged,
71823:                                           PRBool aEndObjectChanged);
71823: 
48450:   void              FireTimeEventAsync(PRUint32 aMsg, PRInt32 aDetail);
37115:   const nsSMILInstanceTime* GetEffectiveBeginInstance() const;
38818:   const nsSMILInterval* GetPreviousInterval() const;
38818:   PRBool            HasPlayed() const { return !mOldIntervals.IsEmpty(); }
50804:   PRBool            EndHasEventConditions() const;
23697: 
55397:   // Reset the current interval by first passing ownership to a temporary
55397:   // variable so that if Unlink() results in us receiving a callback,
55397:   // mCurrentInterval will be nsnull and we will be in a consistent state.
55397:   void ResetCurrentInterval()
55397:   {
55397:     if (mCurrentInterval) {
55397:       // Transfer ownership to temp var. (This sets mCurrentInterval to null.)
55397:       nsAutoPtr<nsSMILInterval> interval(mCurrentInterval);
55397:       interval->Unlink();
55397:     }
55397:   }
55397: 
37116:   // Hashtable callback methods
37116:   PR_STATIC_CALLBACK(PLDHashOperator) NotifyNewIntervalCallback(
37116:       TimeValueSpecPtrKey* aKey, void* aData);
37116: 
23697:   //
23697:   // Members
23697:   //
37115:   nsISMILAnimationElement*        mAnimationElement; // [weak] won't outlive
37115:                                                      // owner
37115:   TimeValueSpecList               mBeginSpecs; // [strong]
37115:   TimeValueSpecList               mEndSpecs; // [strong]
23697: 
23697:   nsSMILTimeValue                 mSimpleDur;
23697: 
23697:   nsSMILRepeatCount               mRepeatCount;
23697:   nsSMILTimeValue                 mRepeatDur;
23697: 
23697:   nsSMILTimeValue                 mMin;
23697:   nsSMILTimeValue                 mMax;
23697: 
23697:   enum nsSMILFillMode
23697:   {
23697:     FILL_REMOVE,
23697:     FILL_FREEZE
23697:   };
23697:   nsSMILFillMode                  mFillMode;
23697:   static nsAttrValue::EnumTable   sFillModeTable[];
23697: 
23697:   enum nsSMILRestartMode
23697:   {
23697:     RESTART_ALWAYS,
23697:     RESTART_WHENNOTACTIVE,
23697:     RESTART_NEVER
23697:   };
23697:   nsSMILRestartMode               mRestartMode;
23697:   static nsAttrValue::EnumTable   sRestartModeTable[];
23697: 
37115:   InstanceTimeList                mBeginInstances;
37115:   InstanceTimeList                mEndInstances;
37115:   PRUint32                        mInstanceSerialIndex;
23697: 
23697:   nsSMILAnimationFunction*        mClient;
38818:   nsAutoPtr<nsSMILInterval>       mCurrentInterval;
38818:   IntervalList                    mOldIntervals;
48450:   PRUint32                        mCurrentRepeatIteration;
37113:   nsSMILMilestone                 mPrevRegisteredMilestone;
37113:   static const nsSMILMilestone    sMaxMilestone;
47196:   static const PRUint8            sMaxNumIntervals;
47196:   static const PRUint8            sMaxNumInstanceTimes;
23697: 
42519:   // Set of dependent time value specs to be notified when establishing a new
42519:   // current interval. Change notifications and delete notifications are handled
42519:   // by the interval.
37115:   //
37115:   // [weak] The nsSMILTimeValueSpec objects register themselves and unregister
37115:   // on destruction. Likewise, we notify them when we are destroyed.
37116:   TimeValueSpecHashSet mTimeDependents;
37115: 
23697:   /**
23697:    * The state of the element in its life-cycle. These states are based on the
23697:    * element life-cycle described in SMILANIM 3.6.8
23697:    */
23697:   enum nsSMILElementState
23697:   {
23697:     STATE_STARTUP,
23697:     STATE_WAITING,
23697:     STATE_ACTIVE,
23697:     STATE_POSTACTIVE
23697:   };
23697:   nsSMILElementState              mElementState;
47197: 
47197:   enum nsSMILSeekState
47197:   {
47197:     SEEK_NOT_SEEKING,
47197:     SEEK_FORWARD_FROM_ACTIVE,
47197:     SEEK_FORWARD_FROM_INACTIVE,
47197:     SEEK_BACKWARD_FROM_ACTIVE,
47197:     SEEK_BACKWARD_FROM_INACTIVE
47197:   };
47197:   nsSMILSeekState                 mSeekState;
72933: 
72933:   // Used to batch updates to the timing model
72933:   class AutoIntervalUpdateBatcher;
72933:   PRPackedBool mDeferIntervalUpdates;
72933:   PRPackedBool mDoDeferredUpdate; // Set if an update to the current interval
72933:                                   // was requested while mDeferIntervalUpdates
72933:                                   // was set
72935: 
72935:   // Recursion depth checking
72935:   PRUint16              mUpdateIntervalRecursionDepth;
72935:   static const PRUint16 sMaxUpdateIntervalRecursionDepth;
23697: };
23697: 
23697: #endif // NS_SMILTIMEDELEMENT_H_
