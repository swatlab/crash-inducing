     1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
  1349: #include "prmem.h"
  1349: 
 62693: #include "gfxAlphaRecovery.h"
     1: #include "gfxImageSurface.h"
     1: 
     1: #include "cairo.h"
101748: #include "mozilla/gfx/2D.h"
101748: #include "gfx2DGlue.h"
101748: 
101748: using namespace mozilla::gfx;
     1: 
 42262: gfxImageSurface::gfxImageSurface()
 42262:   : mSize(0, 0),
 80486:     mOwnsData(false),
 42262:     mFormat(ImageFormatUnknown),
 42262:     mStride(0)
 42262: {
 42262: }
 42262: 
 42262: void
 42262: gfxImageSurface::InitFromSurface(cairo_surface_t *csurf)
 42262: {
 42262:     mSize.width = cairo_image_surface_get_width(csurf);
 42262:     mSize.height = cairo_image_surface_get_height(csurf);
 42262:     mData = cairo_image_surface_get_data(csurf);
 42262:     mFormat = (gfxImageFormat) cairo_image_surface_get_format(csurf);
 80486:     mOwnsData = false;
 42262:     mStride = cairo_image_surface_get_stride(csurf);
 42262: 
 80486:     Init(csurf, true);
 42262: }
 42262: 
 15751: gfxImageSurface::gfxImageSurface(unsigned char *aData, const gfxIntSize& aSize,
 15751:                                  long aStride, gfxImageFormat aFormat)
 15751: {
 57209:     InitWithData(aData, aSize, aStride, aFormat);
 57209: }
 57209: 
 57209: void
 79633: gfxImageSurface::MakeInvalid()
 79633: {
 79633:     mSize = gfxIntSize(-1, -1);
 79633:     mData = NULL;
 79633:     mStride = 0;
 79633: }
 79633: 
 79633: void
 57209: gfxImageSurface::InitWithData(unsigned char *aData, const gfxIntSize& aSize,
 57209:                               long aStride, gfxImageFormat aFormat)
 57209: {
 57209:     mSize = aSize;
 80486:     mOwnsData = false;
 57209:     mData = aData;
 57209:     mFormat = aFormat;
 57209:     mStride = aStride;
 57209: 
 15751:     if (!CheckSurfaceSize(aSize))
 79633:         MakeInvalid();
 15751: 
 15751:     cairo_surface_t *surface =
 15751:         cairo_image_surface_create_for_data((unsigned char*)mData,
 15751:                                             (cairo_format_t)mFormat,
 15751:                                             mSize.width,
 15751:                                             mSize.height,
 15751:                                             mStride);
 15751: 
 15751:     // cairo_image_surface_create_for_data can return a 'null' surface
 15751:     // in out of memory conditions. The gfxASurface::Init call checks
 15751:     // the surface it receives to see if there is an error with the
 15751:     // surface and handles it appropriately. That is why there is
 15751:     // no check here.
 15751:     Init(surface);
 15751: }
 15751: 
 62693: static void*
 62693: TryAllocAlignedBytes(size_t aSize)
 62693: {
 62693:     // Use fallible allocators here
 94810: #if defined(HAVE_POSIX_MEMALIGN)
 62693:     void* ptr;
 62693:     // Try to align for fast alpha recovery.  This should only help
 62693:     // cairo too, can't hurt.
 62693:     return moz_posix_memalign(&ptr,
 62693:                               1 << gfxAlphaRecovery::GoodAlignmentLog2(),
 62693:                               aSize) ?
 62693:              nsnull : ptr;
 62693: #else
 62693:     // Oh well, hope that luck is with us in the allocator
 62693:     return moz_malloc(aSize);
 62693: #endif
 62693: }
 62693: 
 95670: gfxImageSurface::gfxImageSurface(const gfxIntSize& size, gfxImageFormat format, bool aClear) :
 80486:     mSize(size), mOwnsData(false), mData(nsnull), mFormat(format)
     1: {
  1349:     mStride = ComputeStride();
  1349: 
  1349:     if (!CheckSurfaceSize(size))
 79633:         MakeInvalid();
  1349: 
 49179:     // if we have a zero-sized surface, just leave mData nsnull
  1651:     if (mSize.height * mStride > 0) {
 51291: 
 62693:         // This can fail to allocate memory aligned as we requested,
 62693:         // or it can fail to allocate any memory at all.
 62693:         mData = (unsigned char *) TryAllocAlignedBytes(mSize.height * mStride);
  1349:         if (!mData)
  1349:             return;
 95670:         if (aClear)
 51291:             memset(mData, 0, mSize.height * mStride);
  1651:     }
  1349: 
 80486:     mOwnsData = true;
     1: 
     1:     cairo_surface_t *surface =
     1:         cairo_image_surface_create_for_data((unsigned char*)mData,
     1:                                             (cairo_format_t)format,
     1:                                             mSize.width,
     1:                                             mSize.height,
  1349:                                             mStride);
 42553: 
     1:     Init(surface);
 42553: 
 57899:     if (mSurfaceValid) {
 57899:         RecordMemoryUsed(mSize.height * ComputeStride() +
 57899:                          sizeof(gfxImageSurface));
 57899:     }
     1: }
     1: 
     1: gfxImageSurface::gfxImageSurface(cairo_surface_t *csurf)
     1: {
     1:     mSize.width = cairo_image_surface_get_width(csurf);
     1:     mSize.height = cairo_image_surface_get_height(csurf);
     1:     mData = cairo_image_surface_get_data(csurf);
     1:     mFormat = (gfxImageFormat) cairo_image_surface_get_format(csurf);
 80486:     mOwnsData = false;
     1:     mStride = cairo_image_surface_get_stride(csurf);
     1: 
 80486:     Init(csurf, true);
     1: }
     1: 
     1: gfxImageSurface::~gfxImageSurface()
     1: {
 15696:     if (mOwnsData)
  1349:         free(mData);
     1: }
     1: 
 59847: /*static*/ long
 59847: gfxImageSurface::ComputeStride(const gfxIntSize& aSize, gfxImageFormat aFormat)
     1: {
     1:     long stride;
     1: 
 59847:     if (aFormat == ImageFormatARGB32)
 59847:         stride = aSize.width * 4;
 59847:     else if (aFormat == ImageFormatRGB24)
 59847:         stride = aSize.width * 4;
 59847:     else if (aFormat == ImageFormatRGB16_565)
 59847:         stride = aSize.width * 2;
 59847:     else if (aFormat == ImageFormatA8)
 59847:         stride = aSize.width;
 59847:     else if (aFormat == ImageFormatA1) {
 59847:         stride = (aSize.width + 7) / 8;
     1:     } else {
     1:         NS_WARNING("Unknown format specified to gfxImageSurface!");
 59847:         stride = aSize.width * 4;
     1:     }
     1: 
     1:     stride = ((stride + 3) / 4) * 4;
     1: 
     1:     return stride;
     1: }
 11244: 
101748: // helper function for the CopyFrom methods
101748: static void
101748: CopyForStride(unsigned char* aDest, unsigned char* aSrc, const gfxIntSize& aSize, long aDestStride, long aSrcStride)
101748: {
101748:     if (aDestStride == aSrcStride) {
101748:         memcpy (aDest, aSrc, aSrcStride * aSize.height);
101748:     } else {
101748:         int lineSize = NS_MIN(aDestStride, aSrcStride);
101748:         for (int i = 0; i < aSize.height; i++) {
101748:             unsigned char* src = aSrc + aSrcStride * i;
101748:             unsigned char* dst = aDest + aDestStride * i;
101748: 
101748:             memcpy (dst, src, lineSize);
101748:         }
101748:     }
101748: }
101748: 
101748: // helper function for the CopyFrom methods
101748: static bool
101748: FormatsAreCompatible(gfxASurface::gfxImageFormat a1, gfxASurface::gfxImageFormat a2)
101748: {
101748:     if (a1 != a2 &&
101748:         !(a1 == gfxASurface::ImageFormatARGB32 &&
101748:           a2 == gfxASurface::ImageFormatRGB24) &&
101748:         !(a1 == gfxASurface::ImageFormatRGB24 &&
101748:           a2 == gfxASurface::ImageFormatARGB32)) {
101748:         return false;
101748:     }
101748: 
101748:     return true;
101748: }
101748: 
101748: bool
101748: gfxImageSurface::CopyFrom (SourceSurface *aSurface)
101748: {
101748:     mozilla::RefPtr<DataSourceSurface> data = aSurface->GetDataSurface();
101748: 
101748:     if (!data) {
101748:         return false;
101748:     }
101748: 
101748:     gfxIntSize size(data->GetSize().width, data->GetSize().height);
101748:     if (size != mSize) {
101748:         return false;
101748:     }
101748: 
101748:     if (!FormatsAreCompatible(SurfaceFormatToImageFormat(aSurface->GetFormat()),
101748:                               mFormat)) {
101748:         return false;
101748:     }
101748: 
101748:     CopyForStride(mData, data->GetData(), size, mStride, data->Stride());
101748: 
101748:     return true;
101748: }
101748: 
101748: 
 79445: bool
 11244: gfxImageSurface::CopyFrom(gfxImageSurface *other)
 11244: {
101748:     if (other->mSize != mSize) {
 80486:         return false;
 11244:     }
 11244: 
101748:     if (!FormatsAreCompatible(other->mFormat, mFormat)) {
 80486:         return false;
 11244:     }
 11244: 
101748:     CopyForStride(mData, other->mData, mSize, mStride, other->mStride);
 11244: 
 80486:     return true;
 11244: }
 53939: 
 53939: already_AddRefed<gfxSubimageSurface>
 53939: gfxImageSurface::GetSubimage(const gfxRect& aRect)
 53939: {
 53939:     gfxRect r(aRect);
 53939:     r.Round();
 53939:     unsigned char* subData = Data() +
 53939:         (Stride() * (int)r.Y()) +
 53939:         (int)r.X() * gfxASurface::BytePerPixelFromFormat(Format());
 53939: 
 53939:     nsRefPtr<gfxSubimageSurface> image =
 53939:         new gfxSubimageSurface(this, subData,
 53939:                                gfxIntSize((int)r.Width(), (int)r.Height()));
 53939: 
 53939:     return image.forget().get();
 53939: }
 53939: 
 53939: gfxSubimageSurface::gfxSubimageSurface(gfxImageSurface* aParent,
 53939:                                        unsigned char* aData,
 53939:                                        const gfxIntSize& aSize)
 53939:   : gfxImageSurface(aData, aSize, aParent->Stride(), aParent->Format())
 53939:   , mParent(aParent)
 53939: {
 53939: }
 57344: 
 57344: already_AddRefed<gfxImageSurface>
 57344: gfxImageSurface::GetAsImageSurface()
 57344: {
 57344:   nsRefPtr<gfxImageSurface> surface = this;
 57344:   return surface.forget();
 57344: }
 63369: 
 63369: void
 63369: gfxImageSurface::MovePixels(const nsIntRect& aSourceRect,
 63369:                             const nsIntPoint& aDestTopLeft)
 63369: {
 63369:     const nsIntRect bounds(0, 0, mSize.width, mSize.height);
 63369:     nsIntPoint offset = aDestTopLeft - aSourceRect.TopLeft(); 
 63369:     nsIntRect clippedSource = aSourceRect;
 63369:     clippedSource.IntersectRect(clippedSource, bounds);
 63369:     nsIntRect clippedDest = clippedSource + offset;
 63369:     clippedDest.IntersectRect(clippedDest, bounds);
 63369:     const nsIntRect dest = clippedDest;
 63369:     const nsIntRect source = dest - offset;
 63369:     // NB: this relies on IntersectRect() and operator+/- preserving
 63369:     // x/y for empty rectangles
 63369:     NS_ABORT_IF_FALSE(bounds.Contains(dest) && bounds.Contains(source) &&
 63369:                       aSourceRect.Contains(source) &&
 63369:                       nsIntRect(aDestTopLeft, aSourceRect.Size()).Contains(dest) &&
 63369:                       source.Size() == dest.Size() &&
 63369:                       offset == (dest.TopLeft() - source.TopLeft()),
 63369:                       "Messed up clipping, crash or corruption will follow");
 68638:     if (source.IsEmpty() || source.IsEqualInterior(dest)) {
 63369:         return;
 63369:     }
 63369: 
 63369:     long naturalStride = ComputeStride(mSize, mFormat);
 63369:     if (mStride == naturalStride && dest.width == bounds.width) {
 63369:         // Fast path: this is a vertical shift of some rows in a
 63369:         // "normal" image surface.  We can directly memmove and
 63369:         // hopefully stay in SIMD land.
 63369:         unsigned char* dst = mData + dest.y * mStride;
 63369:         const unsigned char* src = mData + source.y * mStride;
 63369:         size_t nBytes = dest.height * mStride;
 63369:         memmove(dst, src, nBytes);
 63369:         return;
 63369:     }
 63369: 
 63369:     // Slow(er) path: have to move row-by-row.
 63369:     const PRInt32 bpp = BytePerPixelFromFormat(mFormat);
 63369:     const size_t nRowBytes = dest.width * bpp;
 63369:     // dstRow points at the first pixel within the current destination
 63369:     // row, and similarly for srcRow.  endSrcRow is one row beyond the
 63369:     // last row we need to copy.  stride is either +mStride or
 63369:     // -mStride, depending on which direction we're copying.
 63369:     unsigned char* dstRow;
 63369:     unsigned char* srcRow;
 63369:     unsigned char* endSrcRow;   // NB: this may point outside the image
 63369:     long stride;
 63369:     if (dest.y > source.y) {
 63369:         // We're copying down from source to dest, so walk backwards
 63369:         // starting from the last rows to avoid stomping pixels we
 63369:         // need.
 63369:         stride = -mStride;
 63369:         dstRow = mData + dest.x * bpp + (dest.YMost() - 1) * mStride;
 63369:         srcRow = mData + source.x * bpp + (source.YMost() - 1) * mStride;
 63369:         endSrcRow = mData + source.x * bpp + (source.y - 1) * mStride;
 63369:     } else {
 63369:         stride = mStride;
 63369:         dstRow = mData + dest.x * bpp + dest.y * mStride;
 63369:         srcRow = mData + source.x * bpp + source.y * mStride;
 63369:         endSrcRow = mData + source.x * bpp + source.YMost() * mStride;
 63369:     }
 63369: 
 63369:     for (; srcRow != endSrcRow; dstRow += stride, srcRow += stride) {
 63369:         memmove(dstRow, srcRow, nRowBytes);
 63369:     }
 63369: }
