29366: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
32658:  * vim: set ts=8 sw=4 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JavaScript bytecode interpreter.
    1:  */
    1: #include <stdio.h>
    1: #include <string.h>
    1: #include <math.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsarena.h" /* Added by JSIFY */
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jsprf.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jsbool.h"
    1: #include "jscntxt.h"
25087: #include "jsdate.h"
18863: #include "jsversion.h"
    1: #include "jsdbgapi.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jsiter.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
    1: #include "jsscan.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
    1: #include "jsstr.h"
18989: #include "jsstaticcheck.h"
17584: #include "jstracer.h"
30268: #include "jslibmath.h"
32581: #include "jsvector.h"
34349: 
34349: #include "jsatominlines.h"
34349: #include "jsscopeinlines.h"
34349: #include "jsscriptinlines.h"
32607: #include "jsstrinlines.h"
    1: 
 7058: #ifdef INCLUDE_MOZILLA_DTRACE
 7058: #include "jsdtracef.h"
 7058: #endif
 7058: 
    1: #if JS_HAS_XML_SUPPORT
    1: #include "jsxml.h"
    1: #endif
    1: 
15453: #include "jsautooplen.h"
15453: 
15996: /* jsinvoke_cpp___ indicates inclusion from jsinvoke.cpp. */
15996: #if !JS_LONE_INTERPRET ^ defined jsinvoke_cpp___
12551: 
33123: JS_REQUIRES_STACK JSPropCacheEntry *
33123: js_FillPropertyCache(JSContext *cx, JSObject *obj,
33123:                      uintN scopeIndex, uintN protoIndex, JSObject *pobj,
33123:                      JSScopeProperty *sprop, JSBool adding)
33123: {
33123:     JSPropertyCache *cache;
33123:     jsbytecode *pc;
33123:     JSScope *scope;
33123:     jsuword kshape, vshape, khash;
33123:     JSOp op;
33123:     const JSCodeSpec *cs;
33123:     jsuword vword;
33123:     ptrdiff_t pcoff;
33123:     JSAtom *atom;
33123:     JSPropCacheEntry *entry;
33123: 
33123:     JS_ASSERT(!cx->runtime->gcRunning);
33123:     cache = &JS_PROPERTY_CACHE(cx);
33123: 
33123:     /* FIXME bug 489098: consider enabling the property cache for eval. */
33123:     if (js_IsPropertyCacheDisabled(cx) || (cx->fp->flags & JSFRAME_EVAL)) {
33123:         PCMETER(cache->disfills++);
33123:         return JS_NO_PROP_CACHE_FILL;
33123:     }
33123: 
33123:     /*
33123:      * Check for fill from js_SetPropertyHelper where the setter removed sprop
33123:      * from pobj's scope (via unwatch or delete, e.g.).
33123:      */
33123:     scope = OBJ_SCOPE(pobj);
33123:     if (!scope->has(sprop)) {
33123:         PCMETER(cache->oddfills++);
33123:         return JS_NO_PROP_CACHE_FILL;
33123:     }
33123: 
33123:     /*
33123:      * Check for overdeep scope and prototype chain. Because resolve, getter,
33123:      * and setter hooks can change the prototype chain using JS_SetPrototype
33123:      * after js_LookupPropertyWithFlags has returned the nominal protoIndex,
33123:      * we have to validate protoIndex if it is non-zero. If it is zero, then
33123:      * we know thanks to the scope->has test above, combined with the fact that
33123:      * obj == pobj, that protoIndex is invariant.
33123:      *
33123:      * The scopeIndex can't be wrong. We require JS_SetParent calls to happen
33123:      * before any running script might consult a parent-linked scope chain. If
33123:      * this requirement is not satisfied, the fill in progress will never hit,
33123:      * but vcap vs. scope shape tests ensure nothing malfunctions.
33123:      */
33123:     JS_ASSERT_IF(scopeIndex == 0 && protoIndex == 0, obj == pobj);
33123: 
33123:     if (protoIndex != 0) {
33123:         JSObject *tmp = obj;
33123: 
33123:         for (uintN i = 0; i != scopeIndex; i++)
33123:             tmp = OBJ_GET_PARENT(cx, tmp);
33123:         JS_ASSERT(tmp != pobj);
33123: 
33123:         protoIndex = 1;
33123:         for (;;) {
33123:             tmp = OBJ_GET_PROTO(cx, tmp);
33123: 
33123:             /*
33123:              * We cannot cache properties coming from native objects behind
33123:              * non-native ones on the prototype chain. The non-natives can
33123:              * mutate in arbitrary way without changing any shapes.
33123:              */
33123:             if (!tmp || !OBJ_IS_NATIVE(tmp)) {
33123:                 PCMETER(cache->noprotos++);
33123:                 return JS_NO_PROP_CACHE_FILL;
33123:             }
33123:             if (tmp == pobj)
33123:                 break;
33123:             ++protoIndex;
33123:         }
33123:     }
33123: 
33123:     if (scopeIndex > PCVCAP_SCOPEMASK || protoIndex > PCVCAP_PROTOMASK) {
33123:         PCMETER(cache->longchains++);
33123:         return JS_NO_PROP_CACHE_FILL;
33123:     }
33123: 
33123:     /*
33123:      * Optimize the cached vword based on our parameters and the current pc's
33123:      * opcode format flags.
33123:      */
33123:     pc = cx->fp->regs->pc;
33123:     op = js_GetOpcode(cx, cx->fp->script, pc);
33123:     cs = &js_CodeSpec[op];
33123:     kshape = 0;
33123: 
33123:     do {
33123:         /*
33123:          * Check for a prototype "plain old method" callee computation. What
33123:          * is a plain old method? It's a function-valued property with stub
33123:          * getter, so get of a function is idempotent.
33123:          */
33123:         if (cs->format & JOF_CALLOP) {
33123:             jsval v;
33123: 
33123:             if (sprop->isMethod()) {
33123:                 /*
33123:                  * A compiler-created function object, AKA a method, already
33123:                  * memoized in the property tree.
33123:                  */
33123:                 JS_ASSERT(scope->hasMethodBarrier());
33123:                 v = sprop->methodValue();
33123:                 JS_ASSERT(VALUE_IS_FUNCTION(cx, v));
33123:                 JS_ASSERT(v == LOCKED_OBJ_GET_SLOT(pobj, sprop->slot));
33123:                 vword = JSVAL_OBJECT_TO_PCVAL(v);
33123:                 break;
33123:             }
33123: 
33123:             if (SPROP_HAS_STUB_GETTER(sprop) &&
33123:                 SPROP_HAS_VALID_SLOT(sprop, scope)) {
33123:                 v = LOCKED_OBJ_GET_SLOT(pobj, sprop->slot);
33123:                 if (VALUE_IS_FUNCTION(cx, v)) {
33123:                     /*
33123:                      * Great, we have a function-valued prototype property
33123:                      * where the getter is JS_PropertyStub. The type id in
33123:                      * pobj's scope does not evolve with changes to property
33123:                      * values, however.
33123:                      *
33123:                      * So here, on first cache fill for this method, we brand
33123:                      * the scope with a new shape and set the JSScope::BRANDED
33123:                      * flag. Once this flag is set, any property assignment
33123:                      * that changes the value from or to a different function
33123:                      * object will result in shape being regenerated.
33123:                      */
33123:                     if (!scope->branded()) {
33123:                         PCMETER(cache->brandfills++);
33123: #ifdef DEBUG_notme
33123:                         fprintf(stderr,
33123:                                 "branding %p (%s) for funobj %p (%s), shape %lu\n",
33123:                                 pobj, pobj->getClass()->name,
33123:                                 JSVAL_TO_OBJECT(v),
33123:                                 JS_GetFunctionName(GET_FUNCTION_PRIVATE(cx, JSVAL_TO_OBJECT(v))),
33123:                                 OBJ_SHAPE(obj));
33123: #endif
33123:                         scope->brandingShapeChange(cx, sprop->slot, v);
33123:                         if (js_IsPropertyCacheDisabled(cx))  /* check for rt->shapeGen overflow */
33123:                             return JS_NO_PROP_CACHE_FILL;
33123:                         scope->setBranded();
33123:                     }
33123:                     vword = JSVAL_OBJECT_TO_PCVAL(v);
33123:                     break;
33123:                 }
33123:             }
33123:         }
33123: 
33123:         /* If getting a value via a stub getter, we can cache the slot. */
33123:         if (!(cs->format & (JOF_SET | JOF_INCDEC | JOF_FOR)) &&
33123:             SPROP_HAS_STUB_GETTER(sprop) &&
33123:             SPROP_HAS_VALID_SLOT(sprop, scope)) {
33123:             /* Great, let's cache sprop's slot and use it on cache hit. */
33123:             vword = SLOT_TO_PCVAL(sprop->slot);
33123:         } else {
33123:             /* Best we can do is to cache sprop (still a nice speedup). */
33123:             vword = SPROP_TO_PCVAL(sprop);
33123:             if (adding &&
33123:                 sprop == scope->lastProp &&
33123:                 scope->shape == sprop->shape) {
33123:                 /*
33123:                  * Our caller added a new property. We also know that a setter
33123:                  * that js_NativeSet could have run has not mutated the scope,
33123:                  * so the added property is still the last one added, and the
33123:                  * scope is not branded.
33123:                  *
33123:                  * We want to cache under scope's shape before the property
33123:                  * addition to bias for the case when the mutator opcode
33123:                  * always adds the same property. This allows us to optimize
33123:                  * periodic execution of object initializers or other explicit
33123:                  * initialization sequences such as
33123:                  *
33123:                  *   obj = {}; obj.x = 1; obj.y = 2;
33123:                  *
33123:                  * We assume that on average the win from this optimization is
33123:                  * greater than the cost of an extra mismatch per loop owing to
33123:                  * the bias for the following case:
33123:                  *
33123:                  *   obj = {}; ... for (...) { ... obj.x = ... }
33123:                  *
33123:                  * On the first iteration of such a for loop, JSOP_SETPROP
33123:                  * fills the cache with the shape of the newly created object
33123:                  * obj, not the shape of obj after obj.x has been assigned.
33123:                  * That mismatches obj's shape on the second iteration. Note
33123:                  * that on the third and subsequent iterations the cache will
33123:                  * be hit because the shape is no longer updated.
33123:                  */
33123:                 JS_ASSERT(scope->owned());
33123:                 if (sprop->parent) {
33123:                     kshape = sprop->parent->shape;
33123:                 } else {
33123:                     /*
33123:                      * If obj had its own empty scope before, with a unique
33123:                      * shape, that is lost. Here we only attempt to find a
33123:                      * matching empty scope. In unusual cases involving
33123:                      * __proto__ assignment we may not find one.
33123:                      */
33123:                     JSObject *proto = STOBJ_GET_PROTO(obj);
33123:                     if (!proto || !OBJ_IS_NATIVE(proto))
33123:                         return JS_NO_PROP_CACHE_FILL;
33123:                     JSScope *protoscope = OBJ_SCOPE(proto);
33123:                     if (!protoscope->emptyScope ||
35117:                         protoscope->emptyScope->clasp != obj->getClass()) {
33123:                         return JS_NO_PROP_CACHE_FILL;
33123:                     }
33123:                     kshape = protoscope->emptyScope->shape;
33123:                 }
33123: 
33123:                 /*
33123:                  * When adding we predict no prototype object will later gain a
33123:                  * readonly property or setter.
33123:                  */
33123:                 vshape = cx->runtime->protoHazardShape;
33123:             }
33123:         }
33123:     } while (0);
33123: 
33123:     if (kshape == 0) {
33123:         kshape = OBJ_SHAPE(obj);
33123:         vshape = scope->shape;
33123:     }
35077:     JS_ASSERT(kshape < SHAPE_OVERFLOW_BIT);
33123: 
33123:     khash = PROPERTY_CACHE_HASH_PC(pc, kshape);
33123:     if (obj == pobj) {
33123:         JS_ASSERT(scopeIndex == 0 && protoIndex == 0);
33123:     } else {
33123:         if (op == JSOP_LENGTH) {
33123:             atom = cx->runtime->atomState.lengthAtom;
33123:         } else {
33123:             pcoff = (JOF_TYPE(cs->format) == JOF_SLOTATOM) ? SLOTNO_LEN : 0;
33123:             GET_ATOM_FROM_BYTECODE(cx->fp->script, pc, pcoff, atom);
33123:         }
33123: 
33123: #ifdef DEBUG
33123:         if (scopeIndex == 0) {
33123:             JS_ASSERT(protoIndex != 0);
33123:             JS_ASSERT((protoIndex == 1) == (OBJ_GET_PROTO(cx, obj) == pobj));
33123:         }
33123: #endif
33123: 
33123:         if (scopeIndex != 0 || protoIndex != 1) {
33123:             khash = PROPERTY_CACHE_HASH_ATOM(atom, obj);
33123:             PCMETER(if (PCVCAP_TAG(cache->table[khash].vcap) <= 1)
33123:                         cache->pcrecycles++);
33123:             pc = (jsbytecode *) atom;
33123:             kshape = (jsuword) obj;
33123: 
33123:             /*
33123:              * Make sure that a later shadowing assignment will enter
33123:              * PurgeProtoChain and invalidate this entry, bug 479198.
33123:              *
33123:              * This is thread-safe even though obj is not locked. Only the
33123:              * DELEGATE bit of obj->classword can change at runtime, given that
33123:              * obj is native; and the bit is only set, never cleared. And on
33123:              * platforms where another CPU can fail to see this write, it's OK
33123:              * because the property cache and JIT cache are thread-local.
33123:              */
33123:             obj->setDelegate();
33123:         }
33123:     }
35077:     JS_ASSERT(vshape < SHAPE_OVERFLOW_BIT);
33123: 
33123:     entry = &cache->table[khash];
33123:     PCMETER(PCVAL_IS_NULL(entry->vword) || cache->recycles++);
33123:     entry->kpc = pc;
33123:     entry->kshape = kshape;
33123:     entry->vcap = PCVCAP_MAKE(vshape, scopeIndex, protoIndex);
33123:     entry->vword = vword;
33123: 
33123:     cache->empty = JS_FALSE;
33123:     PCMETER(cache->fills++);
33123: 
33123:     /*
33123:      * The modfills counter is not exact. It increases if a getter or setter
33123:      * recurse into the interpreter.
33123:      */
33123:     PCMETER(entry == cache->pctestentry || cache->modfills++);
33123:     PCMETER(cache->pctestentry = NULL);
33123:     return entry;
33123: }
33123: 
33123: JS_REQUIRES_STACK JSAtom *
33123: js_FullTestPropertyCache(JSContext *cx, jsbytecode *pc,
33123:                          JSObject **objp, JSObject **pobjp,
33123:                          JSPropCacheEntry **entryp)
33123: {
33123:     JSOp op;
33123:     const JSCodeSpec *cs;
33123:     ptrdiff_t pcoff;
33123:     JSAtom *atom;
33123:     JSObject *obj, *pobj, *tmp;
33123:     JSPropCacheEntry *entry;
33123:     uint32 vcap;
33123: 
33123:     JS_ASSERT(uintN((cx->fp->imacpc ? cx->fp->imacpc : pc) - cx->fp->script->code)
33123:               < cx->fp->script->length);
33123: 
33123:     op = js_GetOpcode(cx, cx->fp->script, pc);
33123:     cs = &js_CodeSpec[op];
33123:     if (op == JSOP_LENGTH) {
33123:         atom = cx->runtime->atomState.lengthAtom;
33123:     } else {
33123:         pcoff = (JOF_TYPE(cs->format) == JOF_SLOTATOM) ? SLOTNO_LEN : 0;
33123:         GET_ATOM_FROM_BYTECODE(cx->fp->script, pc, pcoff, atom);
33123:     }
33123: 
33123:     obj = *objp;
33123:     JS_ASSERT(OBJ_IS_NATIVE(obj));
33123:     entry = &JS_PROPERTY_CACHE(cx).table[PROPERTY_CACHE_HASH_ATOM(atom, obj)];
33123:     *entryp = entry;
33123:     vcap = entry->vcap;
33123: 
33123:     if (entry->kpc != (jsbytecode *) atom) {
33123:         PCMETER(JS_PROPERTY_CACHE(cx).idmisses++);
33123: 
33123: #ifdef DEBUG_notme
33123:         entry = &JS_PROPERTY_CACHE(cx).table[PROPERTY_CACHE_HASH_PC(pc, OBJ_SHAPE(obj))];
33123:         fprintf(stderr,
33123:                 "id miss for %s from %s:%u"
33123:                 " (pc %u, kpc %u, kshape %u, shape %u)\n",
33123:                 js_AtomToPrintableString(cx, atom),
33123:                 cx->fp->script->filename,
33123:                 js_PCToLineNumber(cx, cx->fp->script, pc),
33123:                 pc - cx->fp->script->code,
33123:                 entry->kpc - cx->fp->script->code,
33123:                 entry->kshape,
33123:                 OBJ_SHAPE(obj));
33123:                 js_Disassemble1(cx, cx->fp->script, pc,
33123:                                 pc - cx->fp->script->code,
33123:                                 JS_FALSE, stderr);
33123: #endif
33123: 
33123:         return atom;
33123:     }
33123: 
33123:     if (entry->kshape != (jsuword) obj) {
33123:         PCMETER(JS_PROPERTY_CACHE(cx).komisses++);
33123:         return atom;
33123:     }
33123: 
33123:     pobj = obj;
33123: 
33123:     if (JOF_MODE(cs->format) == JOF_NAME) {
33123:         while (vcap & (PCVCAP_SCOPEMASK << PCVCAP_PROTOBITS)) {
33123:             tmp = OBJ_GET_PARENT(cx, pobj);
33123:             if (!tmp || !OBJ_IS_NATIVE(tmp))
33123:                 break;
33123:             pobj = tmp;
33123:             vcap -= PCVCAP_PROTOSIZE;
33123:         }
33123: 
33123:         *objp = pobj;
33123:     }
33123: 
33123:     while (vcap & PCVCAP_PROTOMASK) {
33123:         tmp = OBJ_GET_PROTO(cx, pobj);
33123:         if (!tmp || !OBJ_IS_NATIVE(tmp))
33123:             break;
33123:         pobj = tmp;
33123:         --vcap;
33123:     }
33123: 
33123:     if (JS_LOCK_OBJ_IF_SHAPE(cx, pobj, PCVCAP_SHAPE(vcap))) {
33123: #ifdef DEBUG
33123:         jsid id = ATOM_TO_JSID(atom);
33123: 
33123:         id = js_CheckForStringIndex(id);
33123:         JS_ASSERT(OBJ_SCOPE(pobj)->lookup(id));
33123:         JS_ASSERT_IF(OBJ_SCOPE(pobj)->object, OBJ_SCOPE(pobj)->object == pobj);
33123: #endif
33123:         *pobjp = pobj;
33123:         return NULL;
33123:     }
33123: 
33123:     PCMETER(JS_PROPERTY_CACHE(cx).vcmisses++);
33123:     return atom;
33123: }
33123: 
33123: #ifdef DEBUG
33123: #define ASSERT_CACHE_IS_EMPTY(cache)                                          \
33123:     JS_BEGIN_MACRO                                                            \
33123:         JSPropertyCache *cache_ = (cache);                                    \
33123:         uintN i_;                                                             \
33123:         JS_ASSERT(cache_->empty);                                             \
33123:         for (i_ = 0; i_ < PROPERTY_CACHE_SIZE; i_++) {                        \
33123:             JS_ASSERT(!cache_->table[i_].kpc);                                \
33123:             JS_ASSERT(!cache_->table[i_].kshape);                             \
33123:             JS_ASSERT(!cache_->table[i_].vcap);                               \
33123:             JS_ASSERT(!cache_->table[i_].vword);                              \
33123:         }                                                                     \
33123:     JS_END_MACRO
33123: #else
33123: #define ASSERT_CACHE_IS_EMPTY(cache) ((void)0)
33123: #endif
33123: 
33123: JS_STATIC_ASSERT(PCVAL_NULL == 0);
33123: 
33123: void
33123: js_PurgePropertyCache(JSContext *cx, JSPropertyCache *cache)
33123: {
33123:     if (cache->empty) {
33123:         ASSERT_CACHE_IS_EMPTY(cache);
33123:         return;
33123:     }
33123: 
33123:     memset(cache->table, 0, sizeof cache->table);
33123:     cache->empty = JS_TRUE;
33123: 
33123: #ifdef JS_PROPERTY_CACHE_METERING
33123:   { static FILE *fp;
33123:     if (!fp)
33123:         fp = fopen("/tmp/propcache.stats", "w");
33123:     if (fp) {
33123:         fputs("Property cache stats for ", fp);
33123: #ifdef JS_THREADSAFE
33123:         fprintf(fp, "thread %lu, ", (unsigned long) cx->thread->id);
33123: #endif
33123:         fprintf(fp, "GC %u\n", cx->runtime->gcNumber);
33123: 
33123: # define P(mem) fprintf(fp, "%11s %10lu\n", #mem, (unsigned long)cache->mem)
33123:         P(fills);
33123:         P(nofills);
33123:         P(rofills);
33123:         P(disfills);
33123:         P(oddfills);
33123:         P(modfills);
33123:         P(brandfills);
33123:         P(noprotos);
33123:         P(longchains);
33123:         P(recycles);
33123:         P(pcrecycles);
33123:         P(tests);
33123:         P(pchits);
33123:         P(protopchits);
33123:         P(initests);
33123:         P(inipchits);
33123:         P(inipcmisses);
33123:         P(settests);
33123:         P(addpchits);
33123:         P(setpchits);
33123:         P(setpcmisses);
33123:         P(slotchanges);
33123:         P(setmisses);
33123:         P(idmisses);
33123:         P(komisses);
33123:         P(vcmisses);
33123:         P(misses);
33123:         P(flushes);
33123:         P(pcpurges);
33123: # undef P
33123: 
33123:         fprintf(fp, "hit rates: pc %g%% (proto %g%%), set %g%%, ini %g%%, full %g%%\n",
33123:                 (100. * cache->pchits) / cache->tests,
33123:                 (100. * cache->protopchits) / cache->tests,
33123:                 (100. * (cache->addpchits + cache->setpchits))
33123:                 / cache->settests,
33123:                 (100. * cache->inipchits) / cache->initests,
33123:                 (100. * (cache->tests - cache->misses)) / cache->tests);
33123:         fflush(fp);
33123:     }
33123:   }
33123: #endif
33123: 
33123:     PCMETER(cache->flushes++);
33123: }
33123: 
33123: void
33123: js_PurgePropertyCacheForScript(JSContext *cx, JSScript *script)
33123: {
33123:     JSPropertyCache *cache;
33123:     JSPropCacheEntry *entry;
33123: 
33123:     cache = &JS_PROPERTY_CACHE(cx);
33123:     for (entry = cache->table; entry < cache->table + PROPERTY_CACHE_SIZE;
33123:          entry++) {
33123:         if (JS_UPTRDIFF(entry->kpc, script->code) < script->length) {
33123:             entry->kpc = NULL;
33123:             entry->kshape = 0;
33123: #ifdef DEBUG
33123:             entry->vcap = entry->vword = 0;
33123: #endif
33123:         }
33123:     }
33123: }
33123: 
    1: /*
 6040:  * Check if the current arena has enough space to fit nslots after sp and, if
 6040:  * so, reserve the necessary space.
    1:  */
24499: static JS_REQUIRES_STACK JSBool
 6040: AllocateAfterSP(JSContext *cx, jsval *sp, uintN nslots)
 6040: {
 6040:     uintN surplus;
 6040:     jsval *sp2;
 6040: 
 6040:     JS_ASSERT((jsval *) cx->stackPool.current->base <= sp);
 6040:     JS_ASSERT(sp <= (jsval *) cx->stackPool.current->avail);
 6040:     surplus = (jsval *) cx->stackPool.current->avail - sp;
 6040:     if (nslots <= surplus)
 6040:         return JS_TRUE;
 6040: 
 6040:     /*
 6040:      * No room before current->avail, check if the arena has enough space to
 6040:      * fit the missing slots before the limit.
 6040:      */
 6040:     if (nslots > (size_t) ((jsval *) cx->stackPool.current->limit - sp))
 6040:         return JS_FALSE;
 6040: 
 6040:     JS_ARENA_ALLOCATE_CAST(sp2, jsval *, &cx->stackPool,
 6040:                            (nslots - surplus) * sizeof(jsval));
 6040:     JS_ASSERT(sp2 == sp + surplus);
 6040:     return JS_TRUE;
 6040: }
 6040: 
24499: JS_STATIC_INTERPRET JS_REQUIRES_STACK jsval *
    1: js_AllocRawStack(JSContext *cx, uintN nslots, void **markp)
    1: {
    1:     jsval *sp;
    1: 
26555:     JS_ASSERT(nslots != 0);
29887:     JS_ASSERT_NOT_ON_TRACE(cx);
26555: 
10985:     if (!cx->stackPool.first.next) {
10985:         int64 *timestamp;
10985: 
12112:         JS_ARENA_ALLOCATE_CAST(timestamp, int64 *,
12112:                                &cx->stackPool, sizeof *timestamp);
10985:         if (!timestamp) {
10985:             js_ReportOutOfScriptQuota(cx);
10985:             return NULL;
10985:         }
10985:         *timestamp = JS_Now();
10985:     }
10985: 
    1:     if (markp)
    1:         *markp = JS_ARENA_MARK(&cx->stackPool);
    1:     JS_ARENA_ALLOCATE_CAST(sp, jsval *, &cx->stackPool, nslots * sizeof(jsval));
 8296:     if (!sp)
 8296:         js_ReportOutOfScriptQuota(cx);
    1:     return sp;
    1: }
    1: 
24499: JS_STATIC_INTERPRET JS_REQUIRES_STACK void
    1: js_FreeRawStack(JSContext *cx, void *mark)
    1: {
    1:     JS_ARENA_RELEASE(&cx->stackPool, mark);
    1: }
    1: 
24499: JS_REQUIRES_STACK JS_FRIEND_API(jsval *)
    1: js_AllocStack(JSContext *cx, uintN nslots, void **markp)
    1: {
 6040:     jsval *sp;
    1:     JSArena *a;
    1:     JSStackHeader *sh;
    1: 
    1:     /* Callers don't check for zero nslots: we do to avoid empty segments. */
    1:     if (nslots == 0) {
    1:         *markp = NULL;
 3164:         return (jsval *) JS_ARENA_MARK(&cx->stackPool);
    1:     }
    1: 
    1:     /* Allocate 2 extra slots for the stack segment header we'll likely need. */
    1:     sp = js_AllocRawStack(cx, 2 + nslots, markp);
    1:     if (!sp)
    1:         return NULL;
    1: 
    1:     /* Try to avoid another header if we can piggyback on the last segment. */
    1:     a = cx->stackPool.current;
    1:     sh = cx->stackHeaders;
    1:     if (sh && JS_STACK_SEGMENT(sh) + sh->nslots == sp) {
    1:         /* Extend the last stack segment, give back the 2 header slots. */
    1:         sh->nslots += nslots;
    1:         a->avail -= 2 * sizeof(jsval);
    1:     } else {
    1:         /*
 6040:          * Need a new stack segment, so allocate and push a stack segment
 6040:          * header from the 2 extra slots.
    1:          */
    1:         sh = (JSStackHeader *)sp;
    1:         sh->nslots = nslots;
    1:         sh->down = cx->stackHeaders;
    1:         cx->stackHeaders = sh;
    1:         sp += 2;
    1:     }
    1: 
    1:     /*
    1:      * Store JSVAL_NULL using memset, to let compilers optimize as they see
    1:      * fit, in case a caller allocates and pushes GC-things one by one, which
    1:      * could nest a last-ditch GC that will scan this segment.
    1:      */
    1:     memset(sp, 0, nslots * sizeof(jsval));
    1:     return sp;
    1: }
    1: 
24499: JS_REQUIRES_STACK JS_FRIEND_API(void)
    1: js_FreeStack(JSContext *cx, void *mark)
    1: {
    1:     JSStackHeader *sh;
    1:     jsuword slotdiff;
    1: 
    1:     /* Check for zero nslots allocation special case. */
    1:     if (!mark)
    1:         return;
    1: 
    1:     /* We can assert because js_FreeStack always balances js_AllocStack. */
    1:     sh = cx->stackHeaders;
    1:     JS_ASSERT(sh);
    1: 
    1:     /* If mark is in the current segment, reduce sh->nslots, else pop sh. */
    1:     slotdiff = JS_UPTRDIFF(mark, JS_STACK_SEGMENT(sh)) / sizeof(jsval);
    1:     if (slotdiff < (jsuword)sh->nslots)
    1:         sh->nslots = slotdiff;
    1:     else
    1:         cx->stackHeaders = sh->down;
    1: 
    1:     /* Release the stackPool space allocated since mark was set. */
    1:     JS_ARENA_RELEASE(&cx->stackPool, mark);
    1: }
    1: 
    1: JSObject *
    1: js_GetScopeChain(JSContext *cx, JSStackFrame *fp)
    1: {
26238:     JSObject *sharedBlock = fp->blockChain;
26238: 
26238:     if (!sharedBlock) {
    1:         /*
    1:          * Don't force a call object for a lightweight function call, but do
    1:          * insist that there is a call object for a heavyweight function call.
    1:          */
    1:         JS_ASSERT(!fp->fun ||
    1:                   !(fp->fun->flags & JSFUN_HEAVYWEIGHT) ||
    1:                   fp->callobj);
    1:         JS_ASSERT(fp->scopeChain);
    1:         return fp->scopeChain;
    1:     }
    1: 
26238:     /* We don't handle cloning blocks on trace.  */
26238:     js_LeaveTrace(cx);
26238: 
    1:     /*
    1:      * We have one or more lexical scopes to reflect into fp->scopeChain, so
    1:      * make sure there's a call object at the current head of the scope chain,
    1:      * if this frame is a call frame.
26238:      *
26238:      * Also, identify the innermost compiler-allocated block we needn't clone.
26238:      */
26238:     JSObject *limitBlock, *limitClone;
    1:     if (fp->fun && !fp->callobj) {
    1:         JS_ASSERT(OBJ_GET_CLASS(cx, fp->scopeChain) != &js_BlockClass ||
32684:                   fp->scopeChain->getPrivate() != fp);
25217:         if (!js_GetCallObject(cx, fp))
    1:             return NULL;
26238: 
26238:         /* We know we must clone everything on blockChain. */
26238:         limitBlock = limitClone = NULL;
26238:     } else {
26238:         /*
26238:          * scopeChain includes all blocks whose static scope we're within that
26238:          * have already been cloned.  Find the innermost such block.  Its
26238:          * prototype should appear on blockChain; we'll clone blockChain up
26238:          * to, but not including, that prototype.
26238:          */
26238:         limitClone = fp->scopeChain;
26238:         while (OBJ_GET_CLASS(cx, limitClone) == &js_WithClass)
26238:             limitClone = OBJ_GET_PARENT(cx, limitClone);
26238:         JS_ASSERT(limitClone);
26238: 
26238:         /*
26238:          * It may seem like we don't know enough about limitClone to be able
26238:          * to just grab its prototype as we do here, but it's actually okay.
26238:          *
26238:          * If limitClone is a block object belonging to this frame, then its
26238:          * prototype is the innermost entry in blockChain that we have already
26238:          * cloned, and is thus the place to stop when we clone below.
26238:          *
26238:          * Otherwise, there are no blocks for this frame on scopeChain, and we
26238:          * need to clone the whole blockChain.  In this case, limitBlock can
26238:          * point to any object known not to be on blockChain, since we simply
26238:          * loop until we hit limitBlock or NULL.  If limitClone is a block, it
26238:          * isn't a block from this function, since blocks can't be nested
26238:          * within themselves on scopeChain (recursion is dynamic nesting, not
26238:          * static nesting).  If limitClone isn't a block, its prototype won't
26238:          * be a block either.  So we can just grab limitClone's prototype here
26238:          * regardless of its type or which frame it belongs to.
26238:          */
26238:         limitBlock = OBJ_GET_PROTO(cx, limitClone);
26238: 
26238:         /* If the innermost block has already been cloned, we are done. */
26238:         if (limitBlock == sharedBlock)
26238:             return fp->scopeChain;
26238:     }
26238: 
26238:     /*
26238:      * Special-case cloning the innermost block; this doesn't have enough in
26238:      * common with subsequent steps to include in the loop.
26238:      *
30645:      * js_CloneBlockObject leaves the clone's parent slot uninitialized. We
30645:      * populate it below.
30645:      */
30645:     JSObject *innermostNewChild = js_CloneBlockObject(cx, sharedBlock, fp);
26238:     if (!innermostNewChild)
26238:         return NULL;
26238:     JSAutoTempValueRooter tvr(cx, innermostNewChild);
26238: 
26238:     /*
26238:      * Clone our way towards outer scopes until we reach the innermost
26238:      * enclosing function, or the innermost block we've already cloned.
26238:      */
26238:     JSObject *newChild = innermostNewChild;
26186:     for (;;) {
26238:         JS_ASSERT(OBJ_GET_PROTO(cx, newChild) == sharedBlock);
26238:         sharedBlock = OBJ_GET_PARENT(cx, sharedBlock);
26238: 
26238:         /* Sometimes limitBlock will be NULL, so check that first.  */
26238:         if (sharedBlock == limitBlock || !sharedBlock)
26238:             break;
26238: 
26238:         /* As in the call above, we don't know the real parent yet.  */
26238:         JSObject *clone
30645:             = js_CloneBlockObject(cx, sharedBlock, fp);
26238:         if (!clone)
26186:             return NULL;
26238: 
26238:         /*
26238:          * Avoid OBJ_SET_PARENT overhead as newChild cannot escape to
26186:          * other threads.
26186:          */
26238:         STOBJ_SET_PARENT(newChild, clone);
26238:         newChild = clone;
26238:     }
30645:     STOBJ_SET_PARENT(newChild, fp->scopeChain);
30645: 
26238: 
26238:     /*
26238:      * If we found a limit block belonging to this frame, then we should have
26238:      * found it in blockChain.
26238:      */
26238:     JS_ASSERT_IF(limitBlock &&
26238:                  OBJ_GET_CLASS(cx, limitBlock) == &js_BlockClass &&
32684:                  limitClone->getPrivate() == fp,
26238:                  sharedBlock);
26238: 
26238:     /* Place our newly cloned blocks at the head of the scope chain.  */
26238:     fp->scopeChain = innermostNewChild;
26238:     return fp->scopeChain;
    1: }
    1: 
 2383: JSBool
 4127: js_GetPrimitiveThis(JSContext *cx, jsval *vp, JSClass *clasp, jsval *thisvp)
    1: {
 4127:     jsval v;
 4127:     JSObject *obj;
 4127: 
 4127:     v = vp[1];
 4127:     if (JSVAL_IS_OBJECT(v)) {
12470:         obj = JS_THIS_OBJECT(cx, vp);
 4127:         if (!JS_InstanceOf(cx, obj, clasp, vp + 2))
 4127:             return JS_FALSE;
32684:         v = obj->fslots[JSSLOT_PRIMITIVE_THIS];
 4127:     }
 4127:     *thisvp = v;
 2383:     return JS_TRUE;
 4127: }
 4127: 
34292: /* Some objects (e.g., With) delegate 'this' to another object. */
34293: static inline JSObject *
34292: CallThisObjectHook(JSContext *cx, JSObject *obj, jsval *argv)
34292: {
34292:     JSObject *thisp = obj->thisObject(cx);
34292:     if (!thisp)
34292:         return NULL;
34292:     argv[-1] = OBJECT_TO_JSVAL(thisp);
34292:     return thisp;
34292: }
34292: 
    1: /*
 4127:  * ECMA requires "the global object", but in embeddings such as the browser,
 4127:  * which have multiple top-level objects (windows, frames, etc. in the DOM),
 4127:  * we prefer fun's parent.  An example that causes this code to run:
    1:  *
    1:  *   // in window w1
    1:  *   function f() { return this }
    1:  *   function g() { return f }
    1:  *
    1:  *   // in window w2
    1:  *   var h = w1.g()
    1:  *   alert(h() == w1)
    1:  *
    1:  * The alert should display "true".
    1:  */
15996: JS_STATIC_INTERPRET JSObject *
12551: js_ComputeGlobalThis(JSContext *cx, JSBool lazy, jsval *argv)
 4127: {
 4127:     JSObject *thisp;
 4127: 
    1:     if (JSVAL_IS_PRIMITIVE(argv[-2]) ||
    1:         !OBJ_GET_PARENT(cx, JSVAL_TO_OBJECT(argv[-2]))) {
    1:         thisp = cx->globalObject;
    1:     } else {
11774:         JSStackFrame *fp;
    1:         jsid id;
    1:         jsval v;
    1:         uintN attrs;
11774:         JSBool ok;
    1:         JSObject *parent;
    1: 
11774:         /*
11774:          * Walk up the parent chain, first checking that the running script
11774:          * has access to the callee's parent object. Note that if lazy, the
11774:          * running script whose principals we want to check is the script
11774:          * associated with fp->down, not with fp.
11774:          *
11774:          * FIXME: 417851 -- this access check should not be required, as it
12551:          * imposes a performance penalty on all js_ComputeGlobalThis calls,
12551:          * and it represents a maintenance hazard.
11774:          */
22652:         fp = js_GetTopStackFrame(cx);    /* quell GCC overwarning */
11774:         if (lazy) {
12470:             JS_ASSERT(fp->argv == argv);
11774:             fp->dormantNext = cx->dormantFrameChain;
11774:             cx->dormantFrameChain = fp;
11774:             cx->fp = fp->down;
11774:             fp->down = NULL;
11774:         }
    1:         thisp = JSVAL_TO_OBJECT(argv[-2]);
    1:         id = ATOM_TO_JSID(cx->runtime->atomState.parentAtom);
11774: 
31501:         ok = thisp->checkAccess(cx, id, JSACC_PARENT, &v, &attrs);
11774:         if (lazy) {
11774:             cx->dormantFrameChain = fp->dormantNext;
11774:             fp->dormantNext = NULL;
11774:             fp->down = cx->fp;
11774:             cx->fp = fp;
11774:         }
11774:         if (!ok)
11774:             return NULL;
11774: 
11774:         thisp = JSVAL_IS_VOID(v)
    1:                 ? OBJ_GET_PARENT(cx, thisp)
    1:                 : JSVAL_TO_OBJECT(v);
11774:         while ((parent = OBJ_GET_PARENT(cx, thisp)) != NULL)
    1:             thisp = parent;
    1:     }
10987: 
34292:     return CallThisObjectHook(cx, thisp, argv);
11774: }
11774: 
11774: static JSObject *
11774: ComputeThis(JSContext *cx, JSBool lazy, jsval *argv)
 4127: {
 4127:     JSObject *thisp;
 4127: 
 4127:     JS_ASSERT(!JSVAL_IS_NULL(argv[-1]));
11774:     if (!JSVAL_IS_OBJECT(argv[-1])) {
11774:         if (!js_PrimitiveToObject(cx, &argv[-1]))
11774:             return NULL;
11774:         thisp = JSVAL_TO_OBJECT(argv[-1]);
34292:         return thisp;
34292:     } 
34292: 
 4127:     thisp = JSVAL_TO_OBJECT(argv[-1]);
34292:     if (OBJ_GET_CLASS(cx, thisp) == &js_CallClass || OBJ_GET_CLASS(cx, thisp) == &js_BlockClass)
12551:         return js_ComputeGlobalThis(cx, lazy, argv);
34292: 
34292:     return CallThisObjectHook(cx, thisp, argv);
11774: }
11774: 
11774: JSObject *
11774: js_ComputeThis(JSContext *cx, JSBool lazy, jsval *argv)
 4127: {
35331:     JS_ASSERT(argv[-1] != JSVAL_HOLE);  // check for SynthesizeFrame poisoning
 4127:     if (JSVAL_IS_NULL(argv[-1]))
12551:         return js_ComputeGlobalThis(cx, lazy, argv);
11774:     return ComputeThis(cx, lazy, argv);
    1: }
    1: 
    1: #if JS_HAS_NO_SUCH_METHOD
    1: 
32684: const uint32 JSSLOT_FOUND_FUNCTION  = JSSLOT_PRIVATE;
32684: const uint32 JSSLOT_SAVED_ID        = JSSLOT_PRIVATE + 1;
14789: 
12579: JSClass js_NoSuchMethodClass = {
12579:     "NoSuchMethod",
28093:     JSCLASS_HAS_RESERVED_SLOTS(2) | JSCLASS_IS_ANONYMOUS,
12579:     JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,   JS_PropertyStub,
30654:     JS_EnumerateStub, JS_ResolveStub,   JS_ConvertStub,    NULL,
12579:     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
12579: };
12579: 
12579: /*
12579:  * When JSOP_CALLPROP or JSOP_CALLELEM does not find the method property of
12579:  * the base object, we search for the __noSuchMethod__ method in the base.
12579:  * If it exists, we store the method and the property's id into an object of
12579:  * NoSuchMethod class and store this object into the callee's stack slot.
12579:  * Later, js_Invoke will recognise such an object and transfer control to
12579:  * NoSuchMethod that invokes the method like:
12579:  *
12579:  *   this.__noSuchMethod__(id, args)
12579:  *
12579:  * where id is the name of the method that this invocation attempted to
12579:  * call by name, and args is an Array containing this invocation's actual
12579:  * parameters.
12579:  */
15996: JS_STATIC_INTERPRET JSBool
12579: js_OnUnknownMethod(JSContext *cx, jsval *vp)
12579: {
12579:     JS_ASSERT(!JSVAL_IS_PRIMITIVE(vp[1]));
33178: 
33178:     JSObject *obj = JSVAL_TO_OBJECT(vp[1]);
33178:     jsid id = ATOM_TO_JSID(cx->runtime->atomState.noSuchMethodAtom);
33178:     JSAutoTempValueRooter tvr(cx, JSVAL_NULL);
33178:     if (!js_GetMethod(cx, obj, id, JSGET_NO_METHOD_BARRIER, tvr.addr()))
33178:         return false;
33178:     if (JSVAL_IS_PRIMITIVE(tvr.value())) {
33178:         vp[0] = tvr.value();
12579:     } else {
    1: #if JS_HAS_XML_SUPPORT
12610:         /* Extract the function name from function::name qname. */
12610:         if (!JSVAL_IS_PRIMITIVE(vp[0])) {
12610:             obj = JSVAL_TO_OBJECT(vp[0]);
33178:             if (!js_IsFunctionQName(cx, obj, &id))
33178:                 return false;
12610:             if (id != 0)
12610:                 vp[0] = ID_TO_VALUE(id);
12610:         }
    1: #endif
28093:         obj = js_NewObjectWithGivenProto(cx, &js_NoSuchMethodClass,
30439:                                          NULL, NULL);
33178:         if (!obj)
33178:             return false;
33178:         obj->fslots[JSSLOT_FOUND_FUNCTION] = tvr.value();
14789:         obj->fslots[JSSLOT_SAVED_ID] = vp[0];
12579:         vp[0] = OBJECT_TO_JSVAL(obj);
12579:     }
33178:     return true;
12579: }
12579: 
24499: static JS_REQUIRES_STACK JSBool
 6040: NoSuchMethod(JSContext *cx, uintN argc, jsval *vp, uint32 flags)
    1: {
14789:     jsval *invokevp;
14789:     void *mark;
14789:     JSBool ok;
14789:     JSObject *obj, *argsobj;
14789: 
14789:     invokevp = js_AllocStack(cx, 2 + 2, &mark);
14789:     if (!invokevp)
14789:         return JS_FALSE;
12579: 
12579:     JS_ASSERT(!JSVAL_IS_PRIMITIVE(vp[0]));
14789:     JS_ASSERT(!JSVAL_IS_PRIMITIVE(vp[1]));
12579:     obj = JSVAL_TO_OBJECT(vp[0]);
12579:     JS_ASSERT(STOBJ_GET_CLASS(obj) == &js_NoSuchMethodClass);
14789: 
14789:     invokevp[0] = obj->fslots[JSSLOT_FOUND_FUNCTION];
14789:     invokevp[1] = vp[1];
14789:     invokevp[2] = obj->fslots[JSSLOT_SAVED_ID];
    1:     argsobj = js_NewArrayObject(cx, argc, vp + 2);
  348:     if (!argsobj) {
  348:         ok = JS_FALSE;
14789:     } else {
14789:         invokevp[3] = OBJECT_TO_JSVAL(argsobj);
14789:         ok = (flags & JSINVOKE_CONSTRUCT)
19577:              ? js_InvokeConstructor(cx, 2, JS_TRUE, invokevp)
14789:              : js_Invoke(cx, 2, invokevp, flags);
14789:         vp[0] = invokevp[0];
14789:     }
14789:     js_FreeStack(cx, mark);
  348:     return ok;
    1: }
    1: 
    1: #endif /* JS_HAS_NO_SUCH_METHOD */
    1: 
    1: /*
 4127:  * We check if the function accepts a primitive value as |this|. For that we
 4127:  * use a table that maps value's tag into the corresponding function flag.
 4127:  */
 4127: JS_STATIC_ASSERT(JSVAL_INT == 1);
 4127: JS_STATIC_ASSERT(JSVAL_DOUBLE == 2);
 4127: JS_STATIC_ASSERT(JSVAL_STRING == 4);
31521: JS_STATIC_ASSERT(JSVAL_SPECIAL == 6);
 4127: 
12551: const uint16 js_PrimitiveTestFlags[] = {
 4127:     JSFUN_THISP_NUMBER,     /* INT     */
 4127:     JSFUN_THISP_NUMBER,     /* DOUBLE  */
 4127:     JSFUN_THISP_NUMBER,     /* INT     */
 4127:     JSFUN_THISP_STRING,     /* STRING  */
 4127:     JSFUN_THISP_NUMBER,     /* INT     */
 4127:     JSFUN_THISP_BOOLEAN,    /* BOOLEAN */
 4127:     JSFUN_THISP_NUMBER      /* INT     */
    1: };
    1: 
    1: /*
    1:  * Find a function reference and its 'this' object implicit first parameter
    1:  * under argc arguments on cx's stack, and call the function.  Push missing
    1:  * required arguments, allocate declared local variables, and pop everything
    1:  * when done.  Then push the return value.
    1:  */
24499: JS_REQUIRES_STACK JS_FRIEND_API(JSBool)
 6040: js_Invoke(JSContext *cx, uintN argc, jsval *vp, uintN flags)
    1: {
    1:     void *mark;
 6040:     JSStackFrame frame;
 6040:     jsval *sp, *argv, *newvp;
 6040:     jsval v;
 2383:     JSObject *funobj, *parent;
    1:     JSBool ok;
    1:     JSClass *clasp;
32777:     const JSObjectOps *ops;
    1:     JSNative native;
    1:     JSFunction *fun;
    1:     JSScript *script;
16519:     uintN nslots, i;
 6040:     uint32 rootedArgsFlag;
    1:     JSInterpreterHook hook;
    1:     void *hookData;
    1: 
31823:     JS_ASSERT(argc <= JS_ARGS_LENGTH_MAX);
31823: 
 6040:     /* [vp .. vp + 2 + argc) must belong to the last JS stack arena. */
 6040:     JS_ASSERT((jsval *) cx->stackPool.current->base <= vp);
 6040:     JS_ASSERT(vp + 2 + argc <= (jsval *) cx->stackPool.current->avail);
 6040: 
28086:     /* Mark the top of stack and load frequently-used registers. */
    1:     mark = JS_ARENA_MARK(&cx->stackPool);
28086:     MUST_FLOW_THROUGH("out2");
    1:     v = *vp;
    1: 
12579:     if (JSVAL_IS_PRIMITIVE(v))
    1:         goto bad;
    1: 
    1:     funobj = JSVAL_TO_OBJECT(v);
    1:     parent = OBJ_GET_PARENT(cx, funobj);
    1:     clasp = OBJ_GET_CLASS(cx, funobj);
    1:     if (clasp != &js_FunctionClass) {
12579: #if JS_HAS_NO_SUCH_METHOD
12579:         if (clasp == &js_NoSuchMethodClass) {
12579:             ok = NoSuchMethod(cx, argc, vp, flags);
12579:             goto out2;
12579:         }
12579: #endif
12579: 
    1:         /* Function is inlined, all other classes use object ops. */
    1:         ops = funobj->map->ops;
    1: 
    1:         /*
    1:          * XXX this makes no sense -- why convert to function if clasp->call?
    1:          * XXX better to call that hook without converting
    1:          *
26728:          * FIXME bug 408416: try converting to function, for API compatibility
26728:          * if there is a call op defined.
    1:          */
    1:         if ((ops == &js_ObjectOps) ? clasp->call : ops->call) {
    1:             ok = clasp->convert(cx, funobj, JSTYPE_FUNCTION, &v);
    1:             if (!ok)
    1:                 goto out2;
    1: 
    1:             if (VALUE_IS_FUNCTION(cx, v)) {
    1:                 /* Make vp refer to funobj to keep it available as argv[-2]. */
    1:                 *vp = v;
    1:                 funobj = JSVAL_TO_OBJECT(v);
    1:                 parent = OBJ_GET_PARENT(cx, funobj);
    1:                 goto have_fun;
    1:             }
    1:         }
    1:         fun = NULL;
    1:         script = NULL;
16072:         nslots = 0;
    1: 
    1:         /* Try a call or construct native object op. */
 2383:         if (flags & JSINVOKE_CONSTRUCT) {
 2383:             if (!JSVAL_IS_OBJECT(vp[1])) {
 2383:                 ok = js_PrimitiveToObject(cx, &vp[1]);
 2383:                 if (!ok)
 2383:                     goto out2;
 2383:             }
 2383:             native = ops->construct;
 2383:         } else {
 2383:             native = ops->call;
 2383:         }
    1:         if (!native)
    1:             goto bad;
    1:     } else {
    1: have_fun:
    1:         /* Get private data and set derived locals from it. */
13691:         fun = GET_FUNCTION_PRIVATE(cx, funobj);
13702:         nslots = FUN_MINARGS(fun);
13702:         nslots = (nslots > argc) ? nslots - argc : 0;
    1:         if (FUN_INTERPRETED(fun)) {
    1:             native = NULL;
    1:             script = fun->u.i.script;
26728:             JS_ASSERT(script);
34290: 
34290:             if (script->isEmpty()) {
34290:                 if (flags & JSINVOKE_CONSTRUCT) {
34290:                     JS_ASSERT(!JSVAL_IS_PRIMITIVE(vp[1]));
34290:                     *vp = vp[1];
34290:                 } else {
34290:                     *vp = JSVAL_VOID;
34290:                 }
34290:                 ok = JS_TRUE;
34290:                 goto out2;
34290:             }
    1:         } else {
    1:             native = fun->u.n.native;
    1:             script = NULL;
    1:             nslots += fun->u.n.extra;
    1:         }
    1: 
    1:         if (JSFUN_BOUND_METHOD_TEST(fun->flags)) {
    1:             /* Handle bound method special case. */
 2383:             vp[1] = OBJECT_TO_JSVAL(parent);
 2383:         } else if (!JSVAL_IS_OBJECT(vp[1])) {
    1:             JS_ASSERT(!(flags & JSINVOKE_CONSTRUCT));
 4127:             if (PRIMITIVE_THIS_TEST(fun, vp[1]))
16519:                 goto start_call;
    1:         }
    1:     }
    1: 
    1:     if (flags & JSINVOKE_CONSTRUCT) {
 2383:         JS_ASSERT(!JSVAL_IS_PRIMITIVE(vp[1]));
    1:     } else {
 2383:         /*
 4127:          * We must call js_ComputeThis in case we are not called from the
 4127:          * interpreter, where a prior bytecode has computed an appropriate
 4127:          * |this| already.
11843:          *
11848:          * But we need to compute |this| eagerly only for so-called "slow"
11848:          * (i.e., not fast) native functions. Fast natives must use either
11848:          * JS_THIS or JS_THIS_OBJECT, and scripted functions will go through
11848:          * the appropriate this-computing bytecode, e.g., JSOP_THIS.
 2383:          */
13702:         if (native && (!fun || !(fun->flags & JSFUN_FAST_NATIVE))) {
12470:             if (!js_ComputeThis(cx, JS_FALSE, vp + 2)) {
11774:                 ok = JS_FALSE;
    1:                 goto out2;
    1:             }
12470:             flags |= JSFRAME_COMPUTED_THIS;
12470:         }
11774:     }
    1: 
16519:   start_call:
16519:     if (native && fun && (fun->flags & JSFUN_FAST_NATIVE)) {
16519: #ifdef DEBUG_NOT_THROWING
16519:         JSBool alreadyThrowing = cx->throwing;
16519: #endif
16519:         JS_ASSERT(nslots == 0);
16519:         ok = ((JSFastNative) native)(cx, argc, vp);
16519:         JS_RUNTIME_METER(cx->runtime, nativeCalls);
16519: #ifdef DEBUG_NOT_THROWING
16519:         if (ok && !alreadyThrowing)
16519:             ASSERT_NOT_THROWING(cx);
16519: #endif
16519:         goto out2;
16519:     }
16519: 
 6040:     argv = vp + 2;
 6040:     sp = argv + argc;
 6040: 
 6040:     rootedArgsFlag = JSFRAME_ROOTED_ARGV;
 6040:     if (nslots != 0) {
 2383:         /*
14820:          * The extra slots required by the function continue with argument
14820:          * slots. Thus, when the last stack pool arena does not have room to
14820:          * fit nslots right after sp and AllocateAfterSP fails, we have to copy
 6040:          * [vp..vp+2+argc) slots and clear rootedArgsFlag to root the copy.
 6040:          */
 6040:         if (!AllocateAfterSP(cx, sp, nslots)) {
 6040:             rootedArgsFlag = 0;
12551:             newvp = js_AllocRawStack(cx, 2 + argc + nslots, NULL);
 6040:             if (!newvp) {
 6040:                 ok = JS_FALSE;
 6040:                 goto out2;
 6040:             }
 6040:             memcpy(newvp, vp, (2 + argc) * sizeof(jsval));
 6040:             argv = newvp + 2;
 6040:             sp = argv + argc;
 6040:         }
 6040: 
 6040:         /* Push void to initialize missing args. */
 6040:         i = nslots;
 6040:         do {
12551:             *sp++ = JSVAL_VOID;
 6040:         } while (--i != 0);
 6040:     }
 6040: 
16072:     /* Allocate space for local variables and stack of interpreted function. */
16072:     if (script && script->nslots != 0) {
16072:         if (!AllocateAfterSP(cx, sp, script->nslots)) {
18308:             /* NB: Discontinuity between argv and slots, stack slots. */
16072:             sp = js_AllocRawStack(cx, script->nslots, NULL);
 6040:             if (!sp) {
 6040:                 ok = JS_FALSE;
 6040:                 goto out2;
 6040:             }
 6040:         }
 6040: 
 6040:         /* Push void to initialize local variables. */
16072:         for (jsval *end = sp + fun->u.i.nvars; sp != end; ++sp)
16072:             *sp = JSVAL_VOID;
 6040:     }
 6040: 
 6040:     /*
13168:      * Initialize the frame.
 2383:      */
32774:     frame.thisv = vp[1];
    1:     frame.varobj = NULL;
30248:     frame.callobj = NULL;
30248:     frame.argsobj = NULL;
    1:     frame.script = script;
    1:     frame.fun = fun;
    1:     frame.argc = argc;
 6040:     frame.argv = argv;
 6040: 
 6040:     /* Default return value for a constructor is the new object. */
 6040:     frame.rval = (flags & JSINVOKE_CONSTRUCT) ? vp[1] : JSVAL_VOID;
24499:     frame.down = cx->fp;
    1:     frame.annotation = NULL;
    1:     frame.scopeChain = NULL;    /* set below for real, after cx->fp is set */
26728:     frame.blockChain = NULL;
13168:     frame.regs = NULL;
21685:     frame.imacpc = NULL;
16072:     frame.slots = NULL;
 6040:     frame.flags = flags | rootedArgsFlag;
    1:     frame.dormantNext = NULL;
26728:     frame.displaySave = NULL;
    1: 
18989:     MUST_FLOW_THROUGH("out");
    1:     cx->fp = &frame;
    1: 
    1:     /* Init these now in case we goto out before first hook call. */
 2433:     hook = cx->debugHooks->callHook;
    1:     hookData = NULL;
    1: 
    1:     if (native) {
    1:         /* If native, use caller varobj and scopeChain for eval. */
 6114:         JS_ASSERT(!frame.varobj);
 6114:         JS_ASSERT(!frame.scopeChain);
 6114:         if (frame.down) {
 6114:             frame.varobj = frame.down->varobj;
 6114:             frame.scopeChain = frame.down->scopeChain;
 6040:         }
 3307: 
 3307:         /* But ensure that we have a scope chain. */
 3307:         if (!frame.scopeChain)
 3307:             frame.scopeChain = parent;
26728:     } else {
    1:         /* Use parent scope so js_GetCallObject can find the right "Call". */
    1:         frame.scopeChain = parent;
    1:         if (JSFUN_HEAVYWEIGHT_TEST(fun->flags)) {
    1:             /* Scope with a call object parented by the callee's parent. */
25217:             if (!js_GetCallObject(cx, &frame)) {
    1:                 ok = JS_FALSE;
    1:                 goto out;
    1:             }
    1:         }
16072:         frame.slots = sp - fun->u.i.nvars;
26728:     }
26728: 
26728:     /* Call the hook if present after we fully initialized the frame. */
26728:     if (hook)
26728:         hookData = hook(cx, &frame, JS_TRUE, 0, cx->debugHooks->callHookData);
26728: 
29445: #ifdef INCLUDE_MOZILLA_DTRACE
29445:     /* DTrace function entry, non-inlines */
29445:     if (JAVASCRIPT_FUNCTION_ENTRY_ENABLED())
29445:         jsdtrace_function_entry(cx, &frame, fun);
29445:     if (JAVASCRIPT_FUNCTION_INFO_ENABLED())
29445:         jsdtrace_function_info(cx, &frame, frame.down, fun);
29445:     if (JAVASCRIPT_FUNCTION_ARGS_ENABLED())
29445:         jsdtrace_function_args(cx, &frame, fun, frame.argc, frame.argv);
29445: #endif
29445: 
26728:     /* Call the function, either a native method or an interpreted script. */
26728:     if (native) {
26728: #ifdef DEBUG_NOT_THROWING
26728:         JSBool alreadyThrowing = cx->throwing;
26728: #endif
32774:         /* Primitive |this| should not be passed to slow natives. */
32774:         JSObject *thisp = JSVAL_TO_OBJECT(frame.thisv);
32774:         ok = native(cx, thisp, argc, frame.argv, &frame.rval);
26728:         JS_RUNTIME_METER(cx->runtime, nativeCalls);
26728: #ifdef DEBUG_NOT_THROWING
26728:         if (ok && !alreadyThrowing)
26728:             ASSERT_NOT_THROWING(cx);
26728: #endif
26728:     } else {
26728:         JS_ASSERT(script);
12688:         ok = js_Interpret(cx);
    1:     }
    1: 
29445: #ifdef INCLUDE_MOZILLA_DTRACE
29445:     /* DTrace function return, non-inlines */
29445:     if (JAVASCRIPT_FUNCTION_RVAL_ENABLED())
29445:         jsdtrace_function_rval(cx, &frame, fun, &frame.rval);
29445:     if (JAVASCRIPT_FUNCTION_RETURN_ENABLED())
29445:         jsdtrace_function_return(cx, &frame, fun);
29445: #endif
29445: 
    1: out:
    1:     if (hookData) {
 2433:         hook = cx->debugHooks->callHook;
    1:         if (hook)
    1:             hook(cx, &frame, JS_FALSE, &ok, hookData);
    1:     }
    1: 
31823:     frame.putActivationObjects(cx);
    1: 
 6040:     *vp = frame.rval;
 6040: 
    1:     /* Restore cx->fp now that we're done releasing frame objects. */
 6040:     cx->fp = frame.down;
    1: 
    1: out2:
    1:     /* Pop everything we may have allocated off the stack. */
    1:     JS_ARENA_RELEASE(&cx->stackPool, mark);
 6040:     if (!ok)
 6040:         *vp = JSVAL_NULL;
    1:     return ok;
    1: 
    1: bad:
    1:     js_ReportIsNotFunction(cx, vp, flags & JSINVOKE_FUNFLAGS);
    1:     ok = JS_FALSE;
    1:     goto out2;
    1: }
    1: 
24612: JSBool
    1: js_InternalInvoke(JSContext *cx, JSObject *obj, jsval fval, uintN flags,
    1:                   uintN argc, jsval *argv, jsval *rval)
    1: {
 6040:     jsval *invokevp;
    1:     void *mark;
    1:     JSBool ok;
    1: 
24612:     js_LeaveTrace(cx);
 6040:     invokevp = js_AllocStack(cx, 2 + argc, &mark);
 6040:     if (!invokevp)
 6040:         return JS_FALSE;
 6040: 
 6040:     invokevp[0] = fval;
 6040:     invokevp[1] = OBJECT_TO_JSVAL(obj);
 6040:     memcpy(invokevp + 2, argv, argc * sizeof *argv);
 6040: 
14721:     ok = js_Invoke(cx, argc, invokevp, flags);
    1:     if (ok) {
    1:         /*
    1:          * Store *rval in the a scoped local root if a scope is open, else in
    1:          * the lastInternalResult pigeon-hole GC root, solely so users of
    1:          * js_InternalInvoke and its direct and indirect (js_ValueToString for
    1:          * example) callers do not need to manage roots for local, temporary
    1:          * references to such results.
    1:          */
 6040:         *rval = *invokevp;
  583:         if (JSVAL_IS_GCTHING(*rval) && *rval != JSVAL_NULL) {
35075:             JSLocalRootStack *lrs = JS_THREAD_DATA(cx)->localRootStack;
35075:             if (lrs) {
35075:                 if (js_PushLocalRoot(cx, lrs, *rval) < 0)
    1:                     ok = JS_FALSE;
    1:             } else {
    1:                 cx->weakRoots.lastInternalResult = *rval;
    1:             }
    1:         }
    1:     }
    1: 
    1:     js_FreeStack(cx, mark);
    1:     return ok;
    1: }
    1: 
    1: JSBool
    1: js_InternalGetOrSet(JSContext *cx, JSObject *obj, jsid id, jsval fval,
    1:                     JSAccessMode mode, uintN argc, jsval *argv, jsval *rval)
    1: {
24499:     js_LeaveTrace(cx);
24499: 
    1:     /*
    1:      * js_InternalInvoke could result in another try to get or set the same id
    1:      * again, see bug 355497.
    1:      */
11139:     JS_CHECK_RECURSION(cx, return JS_FALSE);
    1: 
    1:     return js_InternalCall(cx, obj, fval, argc, argv, rval);
    1: }
    1: 
    1: JSBool
    1: js_Execute(JSContext *cx, JSObject *chain, JSScript *script,
    1:            JSStackFrame *down, uintN flags, jsval *result)
    1: {
    1:     JSInterpreterHook hook;
    1:     void *hookData, *mark;
    1:     JSStackFrame *oldfp, frame;
    1:     JSObject *obj, *tmp;
    1:     JSBool ok;
    1: 
34290:     if (script->isEmpty()) {
34290:         if (result)
34290:             *result = JSVAL_VOID;
34290:         return JS_TRUE;
34290:     }
34290: 
28134:     js_LeaveTrace(cx);
28134: 
 7058: #ifdef INCLUDE_MOZILLA_DTRACE
 7058:     if (JAVASCRIPT_EXECUTE_START_ENABLED())
 7058:         jsdtrace_execute_start(script);
 7058: #endif
 7058: 
 2433:     hook = cx->debugHooks->executeHook;
    1:     hookData = mark = NULL;
22652:     oldfp = js_GetTopStackFrame(cx);
    1:     frame.script = script;
    1:     if (down) {
16072:         /* Propagate arg state for eval and the debugger API. */
    1:         frame.callobj = down->callobj;
    1:         frame.argsobj = down->argsobj;
    1:         frame.varobj = down->varobj;
33188:         frame.fun = (script->staticLevel > 0) ? down->fun : NULL;
32774:         frame.thisv = down->thisv;
12502:         if (down->flags & JSFRAME_COMPUTED_THIS)
12502:             flags |= JSFRAME_COMPUTED_THIS;
    1:         frame.argc = down->argc;
    1:         frame.argv = down->argv;
    1:         frame.annotation = down->annotation;
    1:     } else {
30248:         frame.callobj = NULL;
30248:         frame.argsobj = NULL;
    1:         obj = chain;
    1:         if (cx->options & JSOPTION_VAROBJFIX) {
    1:             while ((tmp = OBJ_GET_PARENT(cx, obj)) != NULL)
    1:                 obj = tmp;
    1:         }
    1:         frame.varobj = obj;
    1:         frame.fun = NULL;
32774:         frame.thisv = OBJECT_TO_JSVAL(chain);
    1:         frame.argc = 0;
    1:         frame.argv = NULL;
16072:         frame.annotation = NULL;
16072:     }
21685: 
21685:     frame.imacpc = NULL;
16072:     if (script->nslots != 0) {
19635:         frame.slots = js_AllocRawStack(cx, script->nslots, &mark);
16072:         if (!frame.slots) {
 7058:             ok = JS_FALSE;
 7058:             goto out;
 7058:         }
16072:         memset(frame.slots, 0, script->nfixed * sizeof(jsval));
32772: 
32729: #if JS_HAS_SHARP_VARS
32772:         JS_STATIC_ASSERT(SHARP_NSLOTS == 2);
32772: 
33750:         if (script->hasSharps) {
32772:             JS_ASSERT(script->nfixed >= SHARP_NSLOTS);
32772:             jsval *sharps = &frame.slots[script->nfixed - SHARP_NSLOTS];
32772: 
33750:             if (down && down->script && down->script->hasSharps) {
32773:                 JS_ASSERT(down->script->nfixed >= SHARP_NSLOTS);
32773:                 int base = (down->fun && !(down->flags & JSFRAME_SPECIAL))
32729:                            ? down->fun->sharpSlotBase(cx)
32772:                            : down->script->nfixed - SHARP_NSLOTS;
32729:                 if (base < 0) {
32729:                     ok = JS_FALSE;
32729:                     goto out;
32729:                 }
32772:                 sharps[0] = down->slots[base];
32772:                 sharps[1] = down->slots[base + 1];
32729:             } else {
32772:                 sharps[0] = sharps[1] = JSVAL_VOID;
32729:             }
33188:         }
32729: #endif
    1:     } else {
16072:         frame.slots = NULL;
16072:     }
16072: 
    1:     frame.rval = JSVAL_VOID;
    1:     frame.down = down;
    1:     frame.scopeChain = chain;
13168:     frame.regs = NULL;
    1:     frame.flags = flags;
    1:     frame.dormantNext = NULL;
    1:     frame.blockChain = NULL;
    1: 
    1:     /*
    1:      * Here we wrap the call to js_Interpret with code to (conditionally)
    1:      * save and restore the old stack frame chain into a chain of 'dormant'
    1:      * frame chains.  Since we are replacing cx->fp, we were running into
    1:      * the problem that if GC was called under this frame, some of the GC
    1:      * things associated with the old frame chain (available here only in
    1:      * the C variable 'oldfp') were not rooted and were being collected.
    1:      *
    1:      * So, now we preserve the links to these 'dormant' frame chains in cx
    1:      * before calling js_Interpret and cleanup afterwards.  The GC walks
    1:      * these dormant chains and marks objects in the same way that it marks
    1:      * objects in the primary cx->fp chain.
    1:      */
    1:     if (oldfp && oldfp != down) {
    1:         JS_ASSERT(!oldfp->dormantNext);
    1:         oldfp->dormantNext = cx->dormantFrameChain;
    1:         cx->dormantFrameChain = oldfp;
    1:     }
    1: 
    1:     cx->fp = &frame;
15584:     if (!down) {
32578:         OBJ_TO_INNER_OBJECT(cx, chain);
32578:         if (!chain)
32578:             return JS_FALSE;
32578:         frame.scopeChain = chain;
32578: 
32774:         JSObject *thisp = JSVAL_TO_OBJECT(frame.thisv)->thisObject(cx);
32774:         if (!thisp) {
15584:             ok = JS_FALSE;
15584:             goto out2;
15584:         }
32774:         frame.thisv = OBJECT_TO_JSVAL(thisp);
15584:         frame.flags |= JSFRAME_COMPUTED_THIS;
15584:     }
15584: 
 2433:     if (hook) {
 2433:         hookData = hook(cx, &frame, JS_TRUE, 0,
 2433:                         cx->debugHooks->executeHookData);
 2433:     }
    1: 
12688:     ok = js_Interpret(cx);
17828:     if (result)
    1:         *result = frame.rval;
    1: 
    1:     if (hookData) {
 2433:         hook = cx->debugHooks->executeHook;
    1:         if (hook)
    1:             hook(cx, &frame, JS_FALSE, &ok, hookData);
    1:     }
15584: 
15584: out2:
    1:     if (mark)
    1:         js_FreeRawStack(cx, mark);
    1:     cx->fp = oldfp;
    1: 
    1:     if (oldfp && oldfp != down) {
    1:         JS_ASSERT(cx->dormantFrameChain == oldfp);
    1:         cx->dormantFrameChain = oldfp->dormantNext;
    1:         oldfp->dormantNext = NULL;
    1:     }
    1: 
 7058: out:
 7058: #ifdef INCLUDE_MOZILLA_DTRACE
 7058:     if (JAVASCRIPT_EXECUTE_DONE_ENABLED())
 7058:         jsdtrace_execute_done(script);
 7058: #endif
    1:     return ok;
    1: }
    1: 
    1: JSBool
    1: js_CheckRedeclaration(JSContext *cx, JSObject *obj, jsid id, uintN attrs,
    1:                       JSObject **objp, JSProperty **propp)
    1: {
    1:     JSObject *obj2;
    1:     JSProperty *prop;
    1:     uintN oldAttrs, report;
30258:     bool isFunction;
    1:     jsval value;
    1:     const char *type, *name;
    1: 
24592:     /*
24592:      * Both objp and propp must be either null or given. When given, *propp
24592:      * must be null. This way we avoid an extra "if (propp) *propp = NULL" for
24592:      * the common case of a non-existing property.
24592:      */
24592:     JS_ASSERT(!objp == !propp);
24592:     JS_ASSERT_IF(propp, !*propp);
24592: 
24592:     /* The JSPROP_INITIALIZER case below may generate a warning. Since we must
24592:      * drop the property before reporting it, we insists on !propp to avoid
24592:      * looking up the property again after the reporting is done.
24592:      */
24592:     JS_ASSERT_IF(attrs & JSPROP_INITIALIZER, attrs == JSPROP_INITIALIZER);
24592:     JS_ASSERT_IF(attrs == JSPROP_INITIALIZER, !propp);
24592: 
31501:     if (!obj->lookupProperty(cx, id, &obj2, &prop))
    1:         return JS_FALSE;
    1:     if (!prop)
    1:         return JS_TRUE;
    1: 
31501:     /* Use prop as a speedup hint to obj->getAttributes. */
31501:     if (!obj2->getAttributes(cx, id, prop, &oldAttrs)) {
31501:         obj2->dropProperty(cx, prop);
24592:         return JS_FALSE;
    1:     }
    1: 
    1:     /*
    1:      * If our caller doesn't want prop, drop it (we don't need it any longer).
    1:      */
    1:     if (!propp) {
31501:         obj2->dropProperty(cx, prop);
    1:         prop = NULL;
24592:     } else {
24592:         *objp = obj2;
24592:         *propp = prop;
    1:     }
    1: 
    1:     if (attrs == JSPROP_INITIALIZER) {
    1:         /* Allow the new object to override properties. */
    1:         if (obj2 != obj)
    1:             return JS_TRUE;
24592: 
24592:         /* The property must be dropped already. */
24592:         JS_ASSERT(!prop);
    1:         report = JSREPORT_WARNING | JSREPORT_STRICT;
30258: 
30258: #ifdef __GNUC__
30258:         isFunction = false;     /* suppress bogus gcc warnings */
30258: #endif
    1:     } else {
    1:         /* We allow redeclaring some non-readonly properties. */
    1:         if (((oldAttrs | attrs) & JSPROP_READONLY) == 0) {
24592:             /* Allow redeclaration of variables and functions. */
    1:             if (!(attrs & (JSPROP_GETTER | JSPROP_SETTER)))
    1:                 return JS_TRUE;
24592: 
24592:             /*
24592:              * Allow adding a getter only if a property already has a setter
24592:              * but no getter and similarly for adding a setter. That is, we
24592:              * allow only the following transitions:
24592:              *
24592:              *   no-property --> getter --> getter + setter
24592:              *   no-property --> setter --> getter + setter
24592:              */
    1:             if ((~(oldAttrs ^ attrs) & (JSPROP_GETTER | JSPROP_SETTER)) == 0)
    1:                 return JS_TRUE;
24592: 
24592:             /*
24592:              * Allow redeclaration of an impermanent property (in which case
24592:              * anyone could delete it and redefine it, willy-nilly).
24592:              */
    1:             if (!(oldAttrs & JSPROP_PERMANENT))
    1:                 return JS_TRUE;
    1:         }
24592:         if (prop)
31501:             obj2->dropProperty(cx, prop);
    1: 
    1:         report = JSREPORT_ERROR;
    1:         isFunction = (oldAttrs & (JSPROP_GETTER | JSPROP_SETTER)) != 0;
    1:         if (!isFunction) {
31501:             if (!obj->getProperty(cx, id, &value))
24592:                 return JS_FALSE;
    1:             isFunction = VALUE_IS_FUNCTION(cx, value);
    1:         }
    1:     }
    1: 
    1:     type = (attrs == JSPROP_INITIALIZER)
    1:            ? "property"
    1:            : (oldAttrs & attrs & JSPROP_GETTER)
    1:            ? js_getter_str
    1:            : (oldAttrs & attrs & JSPROP_SETTER)
    1:            ? js_setter_str
    1:            : (oldAttrs & JSPROP_READONLY)
    1:            ? js_const_str
    1:            : isFunction
    1:            ? js_function_str
    1:            : js_var_str;
    1:     name = js_ValueToPrintableString(cx, ID_TO_VALUE(id));
    1:     if (!name)
24592:         return JS_FALSE;
    1:     return JS_ReportErrorFlagsAndNumber(cx, report,
    1:                                         js_GetErrorMessage, NULL,
    1:                                         JSMSG_REDECLARED_VAR,
    1:                                         type, name);
    1: }
    1: 
    1: JSBool
 9560: js_StrictlyEqual(JSContext *cx, jsval lval, jsval rval)
    1: {
    1:     jsval ltag = JSVAL_TAG(lval), rtag = JSVAL_TAG(rval);
    1:     jsdouble ld, rd;
    1: 
    1:     if (ltag == rtag) {
    1:         if (ltag == JSVAL_STRING) {
    1:             JSString *lstr = JSVAL_TO_STRING(lval),
    1:                      *rstr = JSVAL_TO_STRING(rval);
    1:             return js_EqualStrings(lstr, rstr);
    1:         }
    1:         if (ltag == JSVAL_DOUBLE) {
    1:             ld = *JSVAL_TO_DOUBLE(lval);
    1:             rd = *JSVAL_TO_DOUBLE(rval);
    1:             return JSDOUBLE_COMPARE(ld, ==, rd, JS_FALSE);
    1:         }
 9560:         if (ltag == JSVAL_OBJECT &&
 9560:             lval != rval &&
 9560:             !JSVAL_IS_NULL(lval) &&
 9560:             !JSVAL_IS_NULL(rval)) {
 9560:             JSObject *lobj, *robj;
12674: 
12674:             lobj = js_GetWrappedObject(cx, JSVAL_TO_OBJECT(lval));
12674:             robj = js_GetWrappedObject(cx, JSVAL_TO_OBJECT(rval));
 9579:             lval = OBJECT_TO_JSVAL(lobj);
 9579:             rval = OBJECT_TO_JSVAL(robj);
 9579:         }
    1:         return lval == rval;
    1:     }
    1:     if (ltag == JSVAL_DOUBLE && JSVAL_IS_INT(rval)) {
    1:         ld = *JSVAL_TO_DOUBLE(lval);
    1:         rd = JSVAL_TO_INT(rval);
    1:         return JSDOUBLE_COMPARE(ld, ==, rd, JS_FALSE);
    1:     }
    1:     if (JSVAL_IS_INT(lval) && rtag == JSVAL_DOUBLE) {
    1:         ld = JSVAL_TO_INT(lval);
    1:         rd = *JSVAL_TO_DOUBLE(rval);
    1:         return JSDOUBLE_COMPARE(ld, ==, rd, JS_FALSE);
    1:     }
    1:     return lval == rval;
    1: }
    1: 
32760: static inline bool
32760: IsNegativeZero(jsval v)
32760: {
32760:     return JSVAL_IS_DOUBLE(v) && JSDOUBLE_IS_NEGZERO(*JSVAL_TO_DOUBLE(v));
32760: }
32760: 
32760: static inline bool
32760: IsNaN(jsval v)
32760: {
32760:     return JSVAL_IS_DOUBLE(v) && JSDOUBLE_IS_NaN(*JSVAL_TO_DOUBLE(v));
32760: }
32760: 
32760: JSBool
32760: js_SameValue(jsval v1, jsval v2, JSContext *cx)
32760: {
32760:     if (IsNegativeZero(v1))
32760:         return IsNegativeZero(v2);
32760:     if (IsNegativeZero(v2))
32760:         return JS_FALSE;
32760:     if (IsNaN(v1) && IsNaN(v2))
32760:         return JS_TRUE;
32760:     return js_StrictlyEqual(cx, v1, v2);
32760: }
32760: 
24499: JS_REQUIRES_STACK JSBool
19577: js_InvokeConstructor(JSContext *cx, uintN argc, JSBool clampReturn, jsval *vp)
    1: {
 8367:     JSFunction *fun, *fun2;
    1:     JSObject *obj, *obj2, *proto, *parent;
    1:     jsval lval, rval;
 8367:     JSClass *clasp;
    1: 
    1:     fun = NULL;
    1:     obj2 = NULL;
    1:     lval = *vp;
    1:     if (!JSVAL_IS_OBJECT(lval) ||
    1:         (obj2 = JSVAL_TO_OBJECT(lval)) == NULL ||
    1:         /* XXX clean up to avoid special cases above ObjectOps layer */
    1:         OBJ_GET_CLASS(cx, obj2) == &js_FunctionClass ||
    1:         !obj2->map->ops->construct)
    1:     {
    1:         fun = js_ValueToFunction(cx, vp, JSV2F_CONSTRUCT);
    1:         if (!fun)
    1:             return JS_FALSE;
    1:     }
    1: 
    1:     clasp = &js_ObjectClass;
    1:     if (!obj2) {
    1:         proto = parent = NULL;
    1:         fun = NULL;
    1:     } else {
    1:         /*
    1:          * Get the constructor prototype object for this function.
    1:          * Use the nominal 'this' parameter slot, vp[1], as a local
    1:          * root to protect this prototype, in case it has no other
    1:          * strong refs.
    1:          */
31501:         if (!obj2->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom),
    1:                                &vp[1])) {
    1:             return JS_FALSE;
    1:         }
    1:         rval = vp[1];
    1:         proto = JSVAL_IS_OBJECT(rval) ? JSVAL_TO_OBJECT(rval) : NULL;
    1:         parent = OBJ_GET_PARENT(cx, obj2);
    1: 
    1:         if (OBJ_GET_CLASS(cx, obj2) == &js_FunctionClass) {
13691:             fun2 = GET_FUNCTION_PRIVATE(cx, obj2);
25887:             if (!FUN_INTERPRETED(fun2) && fun2->u.n.clasp)
25887:                 clasp = fun2->u.n.clasp;
13702:         }
13702:     }
30439:     obj = js_NewObject(cx, clasp, proto, parent);
    1:     if (!obj)
    1:         return JS_FALSE;
    1: 
    1:     /* Now we have an object with a constructor method; call it. */
    1:     vp[1] = OBJECT_TO_JSVAL(obj);
33178:     if (!js_Invoke(cx, argc, vp, JSINVOKE_CONSTRUCT))
    1:         return JS_FALSE;
    1: 
    1:     /* Check the return value and if it's primitive, force it to be obj. */
    1:     rval = *vp;
19577:     if (clampReturn && JSVAL_IS_PRIMITIVE(rval)) {
    1:         if (!fun) {
    1:             /* native [[Construct]] returning primitive is error */
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_BAD_NEW_RESULT,
    1:                                  js_ValueToPrintableString(cx, rval));
    1:             return JS_FALSE;
    1:         }
    1:         *vp = OBJECT_TO_JSVAL(obj);
    1:     }
    1: 
    1:     JS_RUNTIME_METER(cx->runtime, constructs);
    1:     return JS_TRUE;
    1: }
    1: 
12551: JSBool
12551: js_InternNonIntElementId(JSContext *cx, JSObject *obj, jsval idval, jsid *idp)
    1: {
    1:     JS_ASSERT(!JSVAL_IS_INT(idval));
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:     if (!JSVAL_IS_PRIMITIVE(idval)) {
    1:         if (OBJECT_IS_XML(cx, obj)) {
    1:             *idp = OBJECT_JSVAL_TO_JSID(idval);
    1:             return JS_TRUE;
    1:         }
    1:         if (!js_IsFunctionQName(cx, JSVAL_TO_OBJECT(idval), idp))
    1:             return JS_FALSE;
    1:         if (*idp != 0)
    1:             return JS_TRUE;
    1:     }
    1: #endif
    1: 
10573:     return js_ValueToStringId(cx, idval, idp);
    1: }
    1: 
    1: /*
11672:  * Enter the new with scope using an object at sp[-1] and associate the depth
11672:  * of the with block with sp + stackIndex.
11672:  */
22652: JS_STATIC_INTERPRET JS_REQUIRES_STACK JSBool
12551: js_EnterWith(JSContext *cx, jsint stackIndex)
11672: {
11672:     JSStackFrame *fp;
11672:     jsval *sp;
11672:     JSObject *obj, *parent, *withobj;
11672: 
11672:     fp = cx->fp;
13168:     sp = fp->regs->sp;
11672:     JS_ASSERT(stackIndex < 0);
16072:     JS_ASSERT(StackBase(fp) <= sp + stackIndex);
11672: 
11672:     if (!JSVAL_IS_PRIMITIVE(sp[-1])) {
11672:         obj = JSVAL_TO_OBJECT(sp[-1]);
11672:     } else {
11672:         obj = js_ValueToNonNullObject(cx, sp[-1]);
11672:         if (!obj)
    1:             return JS_FALSE;
11672:         sp[-1] = OBJECT_TO_JSVAL(obj);
11672:     }
11672: 
11672:     parent = js_GetScopeChain(cx, fp);
11672:     if (!parent)
11672:         return JS_FALSE;
11672: 
11672:     OBJ_TO_INNER_OBJECT(cx, obj);
11672:     if (!obj)
11672:         return JS_FALSE;
11672: 
11672:     withobj = js_NewWithObject(cx, obj, parent,
16072:                                sp + stackIndex - StackBase(fp));
11672:     if (!withobj)
11672:         return JS_FALSE;
11672: 
11672:     fp->scopeChain = withobj;
    1:     return JS_TRUE;
    1: }
    1: 
22652: JS_STATIC_INTERPRET JS_REQUIRES_STACK void
12551: js_LeaveWith(JSContext *cx)
11672: {
11672:     JSObject *withobj;
11672: 
11672:     withobj = cx->fp->scopeChain;
11672:     JS_ASSERT(OBJ_GET_CLASS(cx, withobj) == &js_WithClass);
32684:     JS_ASSERT(withobj->getPrivate() == cx->fp);
11758:     JS_ASSERT(OBJ_BLOCK_DEPTH(cx, withobj) >= 0);
11672:     cx->fp->scopeChain = OBJ_GET_PARENT(cx, withobj);
31452:     withobj->setPrivate(NULL);
11672: }
11672: 
22652: JS_REQUIRES_STACK JSClass *
12551: js_IsActiveWithOrBlock(JSContext *cx, JSObject *obj, int stackDepth)
11758: {
11758:     JSClass *clasp;
11758: 
11758:     clasp = OBJ_GET_CLASS(cx, obj);
11758:     if ((clasp == &js_WithClass || clasp == &js_BlockClass) &&
32684:         obj->getPrivate() == cx->fp &&
11758:         OBJ_BLOCK_DEPTH(cx, obj) >= stackDepth) {
11758:         return clasp;
11758:     }
11758:     return NULL;
11758: }
11758: 
11758: /*
11758:  * Unwind block and scope chains to match the given depth. The function sets
11758:  * fp->sp on return to stackDepth.
11758:  */
22652: JS_REQUIRES_STACK JSBool
12551: js_UnwindScope(JSContext *cx, JSStackFrame *fp, jsint stackDepth,
11758:                JSBool normalUnwind)
11758: {
11758:     JSObject *obj;
11758:     JSClass *clasp;
11758: 
11758:     JS_ASSERT(stackDepth >= 0);
16072:     JS_ASSERT(StackBase(fp) + stackDepth <= fp->regs->sp);
11758: 
11758:     for (obj = fp->blockChain; obj; obj = OBJ_GET_PARENT(cx, obj)) {
11758:         JS_ASSERT(OBJ_GET_CLASS(cx, obj) == &js_BlockClass);
11758:         if (OBJ_BLOCK_DEPTH(cx, obj) < stackDepth)
11758:             break;
11758:     }
11758:     fp->blockChain = obj;
11758: 
11758:     for (;;) {
11758:         obj = fp->scopeChain;
12551:         clasp = js_IsActiveWithOrBlock(cx, obj, stackDepth);
11758:         if (!clasp)
11758:             break;
11758:         if (clasp == &js_BlockClass) {
11758:             /* Don't fail until after we've updated all stacks. */
11859:             normalUnwind &= js_PutBlockObject(cx, normalUnwind);
11758:         } else {
12551:             js_LeaveWith(cx);
11758:         }
11758:     }
11758: 
16072:     fp->regs->sp = StackBase(fp) + stackDepth;
11758:     return normalUnwind;
11758: }
11758: 
15996: JS_STATIC_INTERPRET JSBool
12611: js_DoIncDec(JSContext *cx, const JSCodeSpec *cs, jsval *vp, jsval *vp2)
12611: {
12611:     jsval v;
12611:     jsdouble d;
12611: 
12611:     v = *vp;
12611:     if (JSVAL_IS_DOUBLE(v)) {
12611:         d = *JSVAL_TO_DOUBLE(v);
12611:     } else if (JSVAL_IS_INT(v)) {
12611:         d = JSVAL_TO_INT(v);
12611:     } else {
12694:         d = js_ValueToNumber(cx, vp);
12694:         if (JSVAL_IS_NULL(*vp))
12611:             return JS_FALSE;
12850:         JS_ASSERT(JSVAL_IS_NUMBER(*vp) || *vp == JSVAL_TRUE);
12611: 
12611:         /* Store the result of v conversion back in vp for post increments. */
12850:         if ((cs->format & JOF_POST) &&
12850:             *vp == JSVAL_TRUE
12850:             && !js_NewNumberInRootedValue(cx, d, vp)) {
12611:             return JS_FALSE;
12611:         }
12850:     }
12611: 
12611:     (cs->format & JOF_INC) ? d++ : d--;
12850:     if (!js_NewNumberInRootedValue(cx, d, vp2))
12611:         return JS_FALSE;
12611: 
12611:     if (!(cs->format & JOF_POST))
12611:         *vp = *vp2;
12611:     return JS_TRUE;
12611: }
12611: 
28275: jsval&
27168: js_GetUpvar(JSContext *cx, uintN level, uintN cookie)
27168: {
27168:     level -= UPVAR_FRAME_SKIP(cookie);
27168:     JS_ASSERT(level < JS_DISPLAY_SIZE);
27168: 
27168:     JSStackFrame *fp = cx->display[level];
27168:     JS_ASSERT(fp->script);
27168: 
27168:     uintN slot = UPVAR_FRAME_SLOT(cookie);
27168:     jsval *vp;
27168: 
27168:     if (!fp->fun) {
27168:         vp = fp->slots + fp->script->nfixed;
27168:     } else if (slot < fp->fun->nargs) {
27168:         vp = fp->argv;
27168:     } else if (slot == CALLEE_UPVAR_SLOT) {
27168:         vp = &fp->argv[-2];
27168:         slot = 0;
27168:     } else {
27168:         slot -= fp->fun->nargs;
27168:         JS_ASSERT(slot < fp->script->nslots);
27168:         vp = fp->slots;
27168:     }
27168: 
27168:     return vp[slot];
27168: }
27168: 
15453: #ifdef DEBUG
15453: 
22652: JS_STATIC_INTERPRET JS_REQUIRES_STACK void
26954: js_TraceOpcode(JSContext *cx)
15453: {
15453:     FILE *tracefp;
15453:     JSStackFrame *fp;
15453:     JSFrameRegs *regs;
15453:     intN ndefs, n, nuses;
15453:     jsval *siter;
15453:     JSString *str;
15453:     JSOp op;
15453: 
15453:     tracefp = (FILE *) cx->tracefp;
15453:     JS_ASSERT(tracefp);
15453:     fp = cx->fp;
15453:     regs = fp->regs;
26954: 
26954:     /*
26954:      * Operations in prologues don't produce interesting values, and
26954:      * js_DecompileValueGenerator isn't set up to handle them anyway.
26954:      */
27233:     if (cx->tracePrevPc && regs->pc >= fp->script->main) {
27233:         JSOp tracePrevOp = JSOp(*cx->tracePrevPc);
27233:         ndefs = js_GetStackDefs(cx, &js_CodeSpec[tracePrevOp], tracePrevOp,
27233:                                 fp->script, cx->tracePrevPc);
26954: 
26954:         /*
32658:          * If there aren't that many elements on the stack, then we have
32658:          * probably entered a new frame, and printing output would just be
32658:          * misleading.
26954:          */
26954:         if (ndefs != 0 &&
26954:             ndefs < regs->sp - fp->slots) {
15453:             for (n = -ndefs; n < 0; n++) {
15453:                 char *bytes = js_DecompileValueGenerator(cx, n, regs->sp[n],
15453:                                                          NULL);
15453:                 if (bytes) {
15453:                     fprintf(tracefp, "%s %s",
15453:                             (n == -ndefs) ? "  output:" : ",",
15453:                             bytes);
30851:                     cx->free(bytes);
15453:                 }
15453:             }
16275:             fprintf(tracefp, " @ %u\n", (uintN) (regs->sp - StackBase(fp)));
15453:         }
15453:         fprintf(tracefp, "  stack: ");
16072:         for (siter = StackBase(fp); siter < regs->sp; siter++) {
15453:             str = js_ValueToString(cx, *siter);
15453:             if (!str)
15453:                 fputs("<null>", tracefp);
15453:             else
15453:                 js_FileEscapedString(tracefp, str, 0);
15453:             fputc(' ', tracefp);
15453:         }
15453:         fputc('\n', tracefp);
15453:     }
15453: 
21685:     fprintf(tracefp, "%4u: ",
21685:             js_PCToLineNumber(cx, fp->script, fp->imacpc ? fp->imacpc : regs->pc));
15453:     js_Disassemble1(cx, fp->script, regs->pc,
25144:                     regs->pc - fp->script->code,
15453:                     JS_FALSE, tracefp);
15453:     op = (JSOp) *regs->pc;
26955:     nuses = js_GetStackUses(&js_CodeSpec[op], op, regs->pc);
15453:     if (nuses != 0) {
15453:         for (n = -nuses; n < 0; n++) {
15453:             char *bytes = js_DecompileValueGenerator(cx, n, regs->sp[n],
15453:                                                      NULL);
15453:             if (bytes) {
15453:                 fprintf(tracefp, "%s %s",
15453:                         (n == -nuses) ? "  inputs:" : ",",
15453:                         bytes);
30851:                 cx->free(bytes);
15453:             }
15453:         }
16275:         fprintf(tracefp, " @ %u\n", (uintN) (regs->sp - StackBase(fp)));
15453:     }
27233:     cx->tracePrevPc = regs->pc;
26954: 
26954:     /* It's nice to have complete traces when debugging a crash.  */
26954:     fflush(tracefp);
15453: }
15453: 
15453: #endif /* DEBUG */
15453: 
12551: #ifdef JS_OPMETER
    1: 
    1: # include <stdlib.h>
    1: 
12551: # define HIST_NSLOTS            8
12551: 
    1: /*
    1:  * The second dimension is hardcoded at 256 because we know that many bits fit
    1:  * in a byte, and mainly to optimize away multiplying by JSOP_LIMIT to address
    1:  * any particular row.
    1:  */
    1: static uint32 succeeds[JSOP_LIMIT][256];
    1: static uint32 slot_ops[JSOP_LIMIT][HIST_NSLOTS];
    1: 
15996: JS_STATIC_INTERPRET void
12551: js_MeterOpcodePair(JSOp op1, JSOp op2)
12551: {
12551:     if (op1 != JSOP_STOP)
12551:         ++succeeds[op1][op2];
12551: }
12551: 
15996: JS_STATIC_INTERPRET void
12551: js_MeterSlotOpcode(JSOp op, uint32 slot)
12551: {
12551:     if (slot < HIST_NSLOTS)
12551:         ++slot_ops[op][slot];
12551: }
12551: 
    1: typedef struct Edge {
    1:     const char  *from;
    1:     const char  *to;
    1:     uint32      count;
    1: } Edge;
    1: 
    1: static int
    1: compare_edges(const void *a, const void *b)
    1: {
    1:     const Edge *ea = (const Edge *) a;
    1:     const Edge *eb = (const Edge *) b;
    1: 
    1:     return (int32)eb->count - (int32)ea->count;
    1: }
    1: 
    1: void
    1: js_DumpOpMeters()
    1: {
    1:     const char *name, *from, *style;
    1:     FILE *fp;
    1:     uint32 total, count;
    1:     uint32 i, j, nedges;
    1:     Edge *graph;
    1: 
    1:     name = getenv("JS_OPMETER_FILE");
    1:     if (!name)
    1:         name = "/tmp/ops.dot";
    1:     fp = fopen(name, "w");
    1:     if (!fp) {
    1:         perror(name);
    1:         return;
    1:     }
    1: 
    1:     total = nedges = 0;
    1:     for (i = 0; i < JSOP_LIMIT; i++) {
    1:         for (j = 0; j < JSOP_LIMIT; j++) {
    1:             count = succeeds[i][j];
    1:             if (count != 0) {
    1:                 total += count;
    1:                 ++nedges;
    1:             }
    1:         }
    1:     }
    1: 
    1: # define SIGNIFICANT(count,total) (200. * (count) >= (total))
    1: 
30851:     graph = (Edge *) js_calloc(nedges * sizeof graph[0]);
    1:     for (i = nedges = 0; i < JSOP_LIMIT; i++) {
12410:         from = js_CodeName[i];
    1:         for (j = 0; j < JSOP_LIMIT; j++) {
    1:             count = succeeds[i][j];
    1:             if (count != 0 && SIGNIFICANT(count, total)) {
    1:                 graph[nedges].from = from;
12410:                 graph[nedges].to = js_CodeName[j];
    1:                 graph[nedges].count = count;
    1:                 ++nedges;
    1:             }
    1:         }
    1:     }
    1:     qsort(graph, nedges, sizeof(Edge), compare_edges);
    1: 
    1: # undef SIGNIFICANT
    1: 
    1:     fputs("digraph {\n", fp);
    1:     for (i = 0, style = NULL; i < nedges; i++) {
    1:         JS_ASSERT(i == 0 || graph[i-1].count >= graph[i].count);
    1:         if (!style || graph[i-1].count != graph[i].count) {
    1:             style = (i > nedges * .75) ? "dotted" :
    1:                     (i > nedges * .50) ? "dashed" :
    1:                     (i > nedges * .25) ? "solid" : "bold";
    1:         }
    1:         fprintf(fp, "  %s -> %s [label=\"%lu\" style=%s]\n",
    1:                 graph[i].from, graph[i].to,
    1:                 (unsigned long)graph[i].count, style);
    1:     }
30851:     js_free(graph);
    1:     fputs("}\n", fp);
    1:     fclose(fp);
    1: 
    1:     name = getenv("JS_OPMETER_HIST");
    1:     if (!name)
    1:         name = "/tmp/ops.hist";
    1:     fp = fopen(name, "w");
    1:     if (!fp) {
    1:         perror(name);
    1:         return;
    1:     }
    1:     fputs("bytecode", fp);
    1:     for (j = 0; j < HIST_NSLOTS; j++)
    1:         fprintf(fp, "  slot %1u", (unsigned)j);
    1:     putc('\n', fp);
    1:     fputs("========", fp);
    1:     for (j = 0; j < HIST_NSLOTS; j++)
    1:         fputs(" =======", fp);
    1:     putc('\n', fp);
    1:     for (i = 0; i < JSOP_LIMIT; i++) {
    1:         for (j = 0; j < HIST_NSLOTS; j++) {
    1:             if (slot_ops[i][j] != 0) {
    1:                 /* Reuse j in the next loop, since we break after. */
12410:                 fprintf(fp, "%-8.8s", js_CodeName[i]);
    1:                 for (j = 0; j < HIST_NSLOTS; j++)
    1:                     fprintf(fp, " %7lu", (unsigned long)slot_ops[i][j]);
    1:                 putc('\n', fp);
    1:                 break;
    1:             }
    1:         }
    1:     }
    1:     fclose(fp);
    1: }
    1: 
    1: #endif /* JS_OPSMETER */
    1: 
15996: #endif /* !JS_LONE_INTERPRET ^ defined jsinvoke_cpp___ */
15996: 
15996: #ifndef  jsinvoke_cpp___
12551: 
13168: #define PUSH(v)         (*regs.sp++ = (v))
12579: #define PUSH_OPND(v)    PUSH(v)
13168: #define STORE_OPND(n,v) (regs.sp[n] = (v))
13168: #define POP()           (*--regs.sp)
12551: #define POP_OPND()      POP()
13168: #define FETCH_OPND(n)   (regs.sp[n])
12551: 
12551: /*
12579:  * Push the jsdouble d using sp from the lexical environment. Try to convert d
12579:  * to a jsint that fits in a jsval, otherwise GC-alloc space for it and push a
12579:  * reference.
12551:  */
12551: #define STORE_NUMBER(cx, n, d)                                                \
12551:     JS_BEGIN_MACRO                                                            \
12551:         jsint i_;                                                             \
12551:                                                                               \
13168:         if (JSDOUBLE_IS_INT(d, i_) && INT_FITS_IN_JSVAL(i_))                  \
13168:             regs.sp[n] = INT_TO_JSVAL(i_);                                    \
13168:         else if (!js_NewDoubleInRootedValue(cx, d, &regs.sp[n]))              \
12551:             goto error;                                                       \
12551:     JS_END_MACRO
12551: 
12551: #define STORE_INT(cx, n, i)                                                   \
12551:     JS_BEGIN_MACRO                                                            \
13168:         if (INT_FITS_IN_JSVAL(i))                                             \
13168:             regs.sp[n] = INT_TO_JSVAL(i);                                     \
13168:         else if (!js_NewDoubleInRootedValue(cx, (jsdouble) (i), &regs.sp[n])) \
12551:             goto error;                                                       \
12551:     JS_END_MACRO
12551: 
12551: #define STORE_UINT(cx, n, u)                                                  \
12551:     JS_BEGIN_MACRO                                                            \
13168:         if ((u) <= JSVAL_INT_MAX)                                             \
13168:             regs.sp[n] = INT_TO_JSVAL(u);                                     \
13168:         else if (!js_NewDoubleInRootedValue(cx, (jsdouble) (u), &regs.sp[n])) \
12551:             goto error;                                                       \
12551:     JS_END_MACRO
12551: 
12551: #define FETCH_NUMBER(cx, n, d)                                                \
12551:     JS_BEGIN_MACRO                                                            \
12551:         jsval v_;                                                             \
12551:                                                                               \
12551:         v_ = FETCH_OPND(n);                                                   \
12694:         VALUE_TO_NUMBER(cx, n, v_, d);                                        \
12551:     JS_END_MACRO
12551: 
12551: #define FETCH_INT(cx, n, i)                                                   \
12551:     JS_BEGIN_MACRO                                                            \
12681:         jsval v_;                                                             \
12681:                                                                               \
12681:         v_= FETCH_OPND(n);                                                    \
12551:         if (JSVAL_IS_INT(v_)) {                                               \
12551:             i = JSVAL_TO_INT(v_);                                             \
12551:         } else {                                                              \
13168:             i = js_ValueToECMAInt32(cx, &regs.sp[n]);                         \
13168:             if (JSVAL_IS_NULL(regs.sp[n]))                                    \
12551:                 goto error;                                                   \
12551:         }                                                                     \
12551:     JS_END_MACRO
12551: 
12551: #define FETCH_UINT(cx, n, ui)                                                 \
12551:     JS_BEGIN_MACRO                                                            \
12681:         jsval v_;                                                             \
12681:                                                                               \
12681:         v_= FETCH_OPND(n);                                                    \
12681:         if (JSVAL_IS_INT(v_)) {                                               \
12681:             ui = (uint32) JSVAL_TO_INT(v_);                                   \
12551:         } else {                                                              \
13168:             ui = js_ValueToECMAUint32(cx, &regs.sp[n]);                       \
13168:             if (JSVAL_IS_NULL(regs.sp[n]))                                    \
12551:                 goto error;                                                   \
12551:         }                                                                     \
12551:     JS_END_MACRO
12551: 
12551: /*
12551:  * Optimized conversion macros that test for the desired type in v before
12551:  * homing sp and calling a conversion function.
12551:  */
12694: #define VALUE_TO_NUMBER(cx, n, v, d)                                          \
12551:     JS_BEGIN_MACRO                                                            \
13168:         JS_ASSERT(v == regs.sp[n]);                                           \
12551:         if (JSVAL_IS_INT(v)) {                                                \
12551:             d = (jsdouble)JSVAL_TO_INT(v);                                    \
12551:         } else if (JSVAL_IS_DOUBLE(v)) {                                      \
12551:             d = *JSVAL_TO_DOUBLE(v);                                          \
12551:         } else {                                                              \
13168:             d = js_ValueToNumber(cx, &regs.sp[n]);                            \
13168:             if (JSVAL_IS_NULL(regs.sp[n]))                                    \
12551:                 goto error;                                                   \
13168:             JS_ASSERT(JSVAL_IS_NUMBER(regs.sp[n]) ||                          \
13168:                       regs.sp[n] == JSVAL_TRUE);                              \
12551:         }                                                                     \
12551:     JS_END_MACRO
12551: 
12551: #define POP_BOOLEAN(cx, v, b)                                                 \
12551:     JS_BEGIN_MACRO                                                            \
12551:         v = FETCH_OPND(-1);                                                   \
12551:         if (v == JSVAL_NULL) {                                                \
12551:             b = JS_FALSE;                                                     \
12551:         } else if (JSVAL_IS_BOOLEAN(v)) {                                     \
12551:             b = JSVAL_TO_BOOLEAN(v);                                          \
12551:         } else {                                                              \
12551:             b = js_ValueToBoolean(v);                                         \
12551:         }                                                                     \
13168:         regs.sp--;                                                            \
12551:     JS_END_MACRO
12551: 
12551: #define VALUE_TO_OBJECT(cx, n, v, obj)                                        \
12551:     JS_BEGIN_MACRO                                                            \
12551:         if (!JSVAL_IS_PRIMITIVE(v)) {                                         \
12551:             obj = JSVAL_TO_OBJECT(v);                                         \
12551:         } else {                                                              \
12551:             obj = js_ValueToNonNullObject(cx, v);                             \
12551:             if (!obj)                                                         \
12551:                 goto error;                                                   \
12551:             STORE_OPND(n, OBJECT_TO_JSVAL(obj));                              \
12551:         }                                                                     \
12551:     JS_END_MACRO
12551: 
12551: #define FETCH_OBJECT(cx, n, v, obj)                                           \
12551:     JS_BEGIN_MACRO                                                            \
12551:         v = FETCH_OPND(n);                                                    \
12551:         VALUE_TO_OBJECT(cx, n, v, obj);                                       \
12551:     JS_END_MACRO
12551: 
12551: #define DEFAULT_VALUE(cx, n, hint, v)                                         \
12551:     JS_BEGIN_MACRO                                                            \
12551:         JS_ASSERT(!JSVAL_IS_PRIMITIVE(v));                                    \
13168:         JS_ASSERT(v == regs.sp[n]);                                           \
31501:         if (!JSVAL_TO_OBJECT(v)->defaultValue(cx, hint, &regs.sp[n]))         \
12551:             goto error;                                                       \
13168:         v = regs.sp[n];                                                       \
12551:     JS_END_MACRO
12551: 
12551: /*
12611:  * Quickly test if v is an int from the [-2**29, 2**29) range, that is, when
12611:  * the lowest bit of v is 1 and the bits 30 and 31 are both either 0 or 1. For
12611:  * such v we can do increment or decrement via adding or subtracting two
12611:  * without checking that the result overflows JSVAL_INT_MIN or JSVAL_INT_MAX.
12611:  */
12611: #define CAN_DO_FAST_INC_DEC(v)     (((((v) << 1) ^ v) & 0x80000001) == 1)
12611: 
12611: JS_STATIC_ASSERT(JSVAL_INT == 1);
31478: JS_STATIC_ASSERT(!CAN_DO_FAST_INC_DEC(INT_TO_JSVAL_CONSTEXPR(JSVAL_INT_MIN)));
31478: JS_STATIC_ASSERT(!CAN_DO_FAST_INC_DEC(INT_TO_JSVAL_CONSTEXPR(JSVAL_INT_MAX)));
12611: 
12611: /*
12551:  * Conditional assert to detect failure to clear a pending exception that is
12551:  * suppressed (or unintentional suppression of a wanted exception).
12551:  */
12551: #if defined DEBUG_brendan || defined DEBUG_mrbkap || defined DEBUG_shaver
12551: # define DEBUG_NOT_THROWING 1
12551: #endif
12551: 
12551: #ifdef DEBUG_NOT_THROWING
12551: # define ASSERT_NOT_THROWING(cx) JS_ASSERT(!(cx)->throwing)
    1: #else
12551: # define ASSERT_NOT_THROWING(cx) /* nothing */
    1: #endif
12551: 
12551: /*
12551:  * Define JS_OPMETER to instrument bytecode succession, generating a .dot file
12551:  * on shutdown that shows the graph of significant predecessor/successor pairs
12551:  * executed, where the edge labels give the succession counts.  The .dot file
12551:  * is named by the JS_OPMETER_FILE envariable, and defaults to /tmp/ops.dot.
12551:  *
12551:  * Bonus feature: JS_OPMETER also enables counters for stack-addressing ops
16429:  * such as JSOP_GETLOCAL, JSOP_INCARG, via METER_SLOT_OP. The resulting counts
12551:  * are written to JS_OPMETER_HIST, defaulting to /tmp/ops.hist.
12551:  */
12551: #ifndef JS_OPMETER
12551: # define METER_OP_INIT(op)      /* nothing */
12551: # define METER_OP_PAIR(op1,op2) /* nothing */
12551: # define METER_SLOT_OP(op,slot) /* nothing */
12551: #else
12551: 
12551: /*
12551:  * The second dimension is hardcoded at 256 because we know that many bits fit
12551:  * in a byte, and mainly to optimize away multiplying by JSOP_LIMIT to address
12551:  * any particular row.
12551:  */
12551: # define METER_OP_INIT(op)      ((op) = JSOP_STOP)
12551: # define METER_OP_PAIR(op1,op2) (js_MeterOpcodePair(op1, op2))
12551: # define METER_SLOT_OP(op,slot) (js_MeterSlotOpcode(op, slot))
12551: 
    1: #endif
    1: 
    1: /*
    1:  * Threaded interpretation via computed goto appears to be well-supported by
    1:  * GCC 3 and higher.  IBM's C compiler when run with the right options (e.g.,
    1:  * -qlanglvl=extended) also supports threading.  Ditto the SunPro C compiler.
    1:  * Currently it's broken for JS_VERSION < 160, though this isn't worth fixing.
    1:  * Add your compiler support macros here.
    1:  */
    1: #ifndef JS_THREADED_INTERP
    1: # if JS_VERSION >= 160 && (                                                   \
    1:     __GNUC__ >= 3 ||                                                          \
    1:     (__IBMC__ >= 700 && defined __IBM_COMPUTED_GOTO) ||                       \
    1:     __SUNPRO_C >= 0x570)
    1: #  define JS_THREADED_INTERP 1
    1: # else
    1: #  define JS_THREADED_INTERP 0
    1: # endif
    1: #endif
    1: 
15453: /*
27164:  * Deadlocks or else bad races are likely if JS_THREADSAFE, so we must rely on
27164:  * single-thread DEBUG js shell testing to verify property cache hits.
27164:  */
27164: #if defined DEBUG && !defined JS_THREADSAFE
27164: 
27164: # define ASSERT_VALID_PROPERTY_CACHE_HIT(pcoff,obj,pobj,entry)                \
27164:     JS_BEGIN_MACRO                                                            \
27164:         if (!AssertValidPropertyCacheHit(cx, script, regs, pcoff, obj, pobj,  \
27164:                                          entry)) {                            \
27164:             goto error;                                                       \
27164:         }                                                                     \
27164:     JS_END_MACRO
27164: 
27164: static bool
27164: AssertValidPropertyCacheHit(JSContext *cx, JSScript *script, JSFrameRegs& regs,
27164:                             ptrdiff_t pcoff, JSObject *start, JSObject *found,
27164:                             JSPropCacheEntry *entry)
27164: {
27164:     uint32 sample = cx->runtime->gcNumber;
27164: 
27164:     JSAtom *atom;
27164:     if (pcoff >= 0)
27164:         GET_ATOM_FROM_BYTECODE(script, regs.pc, pcoff, atom);
27164:     else
27164:         atom = cx->runtime->atomState.lengthAtom;
27164: 
27164:     JSObject *obj, *pobj;
27164:     JSProperty *prop;
33166:     JSBool ok;
27164: 
27164:     if (JOF_OPMODE(*regs.pc) == JOF_NAME) {
27164:         ok = js_FindProperty(cx, ATOM_TO_JSID(atom), &obj, &pobj, &prop);
27164:     } else {
27164:         obj = start;
27164:         ok = js_LookupProperty(cx, obj, ATOM_TO_JSID(atom), &pobj, &prop);
27164:     }
27164:     if (!ok)
27164:         return false;
27164:     if (cx->runtime->gcNumber != sample ||
27164:         PCVCAP_SHAPE(entry->vcap) != OBJ_SHAPE(pobj)) {
31501:         pobj->dropProperty(cx, prop);
27164:         return true;
27164:     }
27164:     JS_ASSERT(prop);
27164:     JS_ASSERT(pobj == found);
27164: 
27164:     JSScopeProperty *sprop = (JSScopeProperty *) prop;
27164:     if (PCVAL_IS_SLOT(entry->vword)) {
27164:         JS_ASSERT(PCVAL_TO_SLOT(entry->vword) == sprop->slot);
32658:         JS_ASSERT(!sprop->isMethod());
27164:     } else if (PCVAL_IS_SPROP(entry->vword)) {
27164:         JS_ASSERT(PCVAL_TO_SPROP(entry->vword) == sprop);
32658:         JS_ASSERT_IF(sprop->isMethod(),
32658:                      sprop->methodValue() == LOCKED_OBJ_GET_SLOT(pobj, sprop->slot));
27164:     } else {
27164:         jsval v;
27164:         JS_ASSERT(PCVAL_IS_OBJECT(entry->vword));
27164:         JS_ASSERT(entry->vword != PCVAL_NULL);
35018:         JS_ASSERT(OBJ_SCOPE(pobj)->branded() || OBJ_SCOPE(pobj)->hasMethodBarrier());
32658:         JS_ASSERT(SPROP_HAS_STUB_GETTER_OR_IS_METHOD(sprop));
27164:         JS_ASSERT(SPROP_HAS_VALID_SLOT(sprop, OBJ_SCOPE(pobj)));
27164:         v = LOCKED_OBJ_GET_SLOT(pobj, sprop->slot);
27164:         JS_ASSERT(VALUE_IS_FUNCTION(cx, v));
27164:         JS_ASSERT(PCVAL_TO_OBJECT(entry->vword) == JSVAL_TO_OBJECT(v));
32658: 
32658:         if (sprop->isMethod()) {
32658:             JS_ASSERT(js_CodeSpec[*regs.pc].format & JOF_CALLOP);
32658:             JS_ASSERT(sprop->methodValue() == v);
32658:         }
27164:     }
27164: 
31501:     pobj->dropProperty(cx, prop);
27164:     return true;
27164: }
27164: 
27164: #else
27164: # define ASSERT_VALID_PROPERTY_CACHE_HIT(pcoff,obj,pobj,entry) ((void) 0)
27164: #endif
27164: 
27164: /*
    1:  * Ensure that the intrepreter switch can close call-bytecode cases in the
    1:  * same way as non-call bytecodes.
    1:  */
    1: JS_STATIC_ASSERT(JSOP_NAME_LENGTH == JSOP_CALLNAME_LENGTH);
    1: JS_STATIC_ASSERT(JSOP_GETGVAR_LENGTH == JSOP_CALLGVAR_LENGTH);
18308: JS_STATIC_ASSERT(JSOP_GETUPVAR_LENGTH == JSOP_CALLUPVAR_LENGTH);
28952: JS_STATIC_ASSERT(JSOP_GETUPVAR_DBG_LENGTH == JSOP_CALLUPVAR_DBG_LENGTH);
28952: JS_STATIC_ASSERT(JSOP_GETUPVAR_DBG_LENGTH == JSOP_GETUPVAR_LENGTH);
27012: JS_STATIC_ASSERT(JSOP_GETDSLOT_LENGTH == JSOP_CALLDSLOT_LENGTH);
    1: JS_STATIC_ASSERT(JSOP_GETARG_LENGTH == JSOP_CALLARG_LENGTH);
    1: JS_STATIC_ASSERT(JSOP_GETLOCAL_LENGTH == JSOP_CALLLOCAL_LENGTH);
    1: JS_STATIC_ASSERT(JSOP_XMLNAME_LENGTH == JSOP_CALLXMLNAME_LENGTH);
    1: 
11377: /*
28952:  * Same for debuggable flat closures defined at top level in another function
28952:  * or program fragment.
28952:  */
28952: JS_STATIC_ASSERT(JSOP_DEFFUN_FC_LENGTH == JSOP_DEFFUN_DBGFC_LENGTH);
28952: 
28952: /*
11377:  * Same for JSOP_SETNAME and JSOP_SETPROP, which differ only slightly but
32658:  * remain distinct for the decompiler. Likewise for JSOP_INIT{PROP,METHOD}.
11377:  */
11377: JS_STATIC_ASSERT(JSOP_SETNAME_LENGTH == JSOP_SETPROP_LENGTH);
32658: JS_STATIC_ASSERT(JSOP_SETNAME_LENGTH == JSOP_SETMETHOD_LENGTH);
32658: JS_STATIC_ASSERT(JSOP_INITPROP_LENGTH == JSOP_INITMETHOD_LENGTH);
11377: 
15464: /* See TRY_BRANCH_AFTER_COND. */
15464: JS_STATIC_ASSERT(JSOP_IFNE_LENGTH == JSOP_IFEQ_LENGTH);
15464: JS_STATIC_ASSERT(JSOP_IFNE == JSOP_IFEQ + 1);
15464: 
16051: /* For the fastest case inder JSOP_INCNAME, etc. */
16051: JS_STATIC_ASSERT(JSOP_INCNAME_LENGTH == JSOP_DECNAME_LENGTH);
16051: JS_STATIC_ASSERT(JSOP_INCNAME_LENGTH == JSOP_NAMEINC_LENGTH);
16051: JS_STATIC_ASSERT(JSOP_INCNAME_LENGTH == JSOP_NAMEDEC_LENGTH);
16051: 
27479: #ifdef JS_TRACER
27479: # define ABORT_RECORDING(cx, reason)                                          \
27479:     JS_BEGIN_MACRO                                                            \
27479:         if (TRACE_RECORDER(cx))                                               \
27479:             js_AbortRecording(cx, reason);                                    \
27479:     JS_END_MACRO
27479: #else
27464: # define ABORT_RECORDING(cx, reason)    ((void) 0)
27479: #endif
27479: 
22652: JS_REQUIRES_STACK JSBool
12688: js_Interpret(JSContext *cx)
    1: {
29368: #ifdef MOZ_TRACEVIS
31063:     TraceVisStateObj tvso(cx, S_INTERP);
29368: #endif
29368: 
    1:     JSRuntime *rt;
    1:     JSStackFrame *fp;
    1:     JSScript *script;
    1:     uintN inlineCallCount;
    1:     JSAtom **atoms;
12688:     JSVersion currentVersion, originalVersion;
13168:     JSFrameRegs regs;
    1:     JSObject *obj, *obj2, *parent;
    1:     JSBool ok, cond;
12579:     jsint len;
    1:     jsbytecode *endpc, *pc2;
    1:     JSOp op, op2;
 3235:     jsatomid index;
    1:     JSAtom *atom;
12423:     uintN argc, attrs, flags;
12423:     uint32 slot;
    1:     jsval *vp, lval, rval, ltmp, rtmp;
    1:     jsid id;
    1:     JSProperty *prop;
    1:     JSScopeProperty *sprop;
    1:     JSString *str, *str2;
    1:     jsint i, j;
    1:     jsdouble d, d2;
    1:     JSClass *clasp;
    1:     JSFunction *fun;
    1:     JSType type;
    1:     jsint low, high, off, npairs;
    1:     JSBool match;
    1: #if JS_HAS_GETTER_SETTER
    1:     JSPropertyOp getter, setter;
    1: #endif
19712:     JSAutoResolveFlags rf(cx, JSRESOLVE_INFER);
    1: 
26954: # ifdef DEBUG
26954:     /*
26954:      * We call this macro from BEGIN_CASE in threaded interpreters,
26954:      * and before entering the switch in non-threaded interpreters.
26954:      * However, reaching such points doesn't mean we've actually
26954:      * fetched an OP from the instruction stream: some opcodes use
26954:      * 'op=x; DO_OP()' to let another opcode's implementation finish
26954:      * their work, and many opcodes share entry points with a run of
26954:      * consecutive BEGIN_CASEs.
26954:      *
26954:      * Take care to trace OP only when it is the opcode fetched from
26954:      * the instruction stream, so the trace matches what one would
26954:      * expect from looking at the code.  (We do omit POPs after SETs;
26954:      * unfortunate, but not worth fixing.)
26954:      */
26954: #  define TRACE_OPCODE(OP)  JS_BEGIN_MACRO                                    \
26954:                                 if (JS_UNLIKELY(cx->tracefp != NULL) &&       \
26954:                                     (OP) == *regs.pc)                         \
26954:                                     js_TraceOpcode(cx);                       \
26954:                             JS_END_MACRO
26954: # else
26954: #  define TRACE_OPCODE(OP)  ((void) 0)
26954: # endif
26954: 
    1: #if JS_THREADED_INTERP
15510:     static void *const normalJumpTable[] = {
    1: # define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format) \
    1:         JS_EXTENSION &&L_##op,
    1: # include "jsopcode.tbl"
    1: # undef OPDEF
    1:     };
    1: 
23111:     static void *const interruptJumpTable[] = {
17408: # define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format)              \
23111:         JS_EXTENSION &&interrupt,
17408: # include "jsopcode.tbl"
17408: # undef OPDEF
17408:     };
23111: 
23111:     register void * const *jumpTable = normalJumpTable;
    1: 
    1:     METER_OP_INIT(op);      /* to nullify first METER_OP_PAIR */
    1: 
23111: # define ENABLE_INTERRUPTS() ((void) (jumpTable = interruptJumpTable))
23111: 
18171: # ifdef JS_TRACER
23111: #  define CHECK_RECORDER()                                                    \
23111:     JS_ASSERT_IF(TRACE_RECORDER(cx), jumpTable == interruptJumpTable)
18171: # else
18171: #  define CHECK_RECORDER()  ((void)0)
18171: # endif
18171: 
18171: # define DO_OP()            JS_BEGIN_MACRO                                    \
18171:                                 CHECK_RECORDER();                             \
18161:                                 JS_EXTENSION_(goto *jumpTable[op]);           \
18161:                             JS_END_MACRO
15453: # define DO_NEXT_OP(n)      JS_BEGIN_MACRO                                    \
15453:                                 METER_OP_PAIR(op, regs.pc[n]);                \
13168:                                 op = (JSOp) *(regs.pc += (n));                \
15453:                                 DO_OP();                                      \
15453:                             JS_END_MACRO
15453: 
24497: # define BEGIN_CASE(OP)     L_##OP: TRACE_OPCODE(OP); CHECK_RECORDER();
    1: # define END_CASE(OP)       DO_NEXT_OP(OP##_LENGTH);
    1: # define END_VARLEN_CASE    DO_NEXT_OP(len);
15453: # define ADD_EMPTY_CASE(OP) BEGIN_CASE(OP)                                    \
15453:                                 JS_ASSERT(js_CodeSpec[OP].length == 1);       \
15453:                                 op = (JSOp) *++regs.pc;                       \
15453:                                 DO_OP();
15453: 
15453: # define END_EMPTY_CASES
15453: 
15453: #else /* !JS_THREADED_INTERP */
15453: 
23111:     register intN switchMask = 0;
23111:     intN switchOp;
23111: 
23111: # define ENABLE_INTERRUPTS() ((void) (switchMask = -1))
23111: 
23111: # ifdef JS_TRACER
23111: #  define CHECK_RECORDER()                                                    \
23111:     JS_ASSERT_IF(TRACE_RECORDER(cx), switchMask == -1)
23111: # else
23111: #  define CHECK_RECORDER()  ((void)0)
23111: # endif
23111: 
    1: # define DO_OP()            goto do_op
15453: # define DO_NEXT_OP(n)      JS_BEGIN_MACRO                                    \
15453:                                 JS_ASSERT((n) == len);                        \
15453:                                 goto advance_pc;                              \
15453:                             JS_END_MACRO
15453: 
23111: # define BEGIN_CASE(OP)     case OP: CHECK_RECORDER();
15453: # define END_CASE(OP)       END_CASE_LEN(OP##_LENGTH)
15453: # define END_CASE_LEN(n)    END_CASE_LENX(n)
15453: # define END_CASE_LENX(n)   END_CASE_LEN##n
15453: 
15453: /*
15453:  * To share the code for all len == 1 cases we use the specialized label with
15453:  * code that falls through to advance_pc: .
15453:  */
15453: # define END_CASE_LEN1      goto advance_pc_by_one;
15453: # define END_CASE_LEN2      len = 2; goto advance_pc;
15453: # define END_CASE_LEN3      len = 3; goto advance_pc;
15453: # define END_CASE_LEN4      len = 4; goto advance_pc;
15453: # define END_CASE_LEN5      len = 5; goto advance_pc;
15453: # define END_VARLEN_CASE    goto advance_pc;
15453: # define ADD_EMPTY_CASE(OP) BEGIN_CASE(OP)
15453: # define END_EMPTY_CASES    goto advance_pc_by_one;
15453: 
18617: #endif /* !JS_THREADED_INTERP */
18617: 
15453:     /* Check for too deep of a native thread stack. */
11758:     JS_CHECK_RECURSION(cx, return JS_FALSE);
11758: 
    1:     rt = cx->runtime;
    1: 
    1:     /* Set registerized frame pointer and derived script pointer. */
    1:     fp = cx->fp;
    1:     script = fp->script;
34290:     JS_ASSERT(!script->isEmpty());
34290:     JS_ASSERT(script->length > 1);
    1: 
    1:     /* Count of JS function calls that nest in this C js_Interpret frame. */
    1:     inlineCallCount = 0;
    1: 
 3235:     /*
 3235:      * Initialize the index segment register used by LOAD_ATOM and
17454:      * GET_FULL_INDEX macros below. As a register we use a pointer based on
 3235:      * the atom map to turn frequently executed LOAD_ATOM into simple array
 3235:      * access. For less frequent object and regexp loads we have to recover
 3235:      * the segment from atoms pointer first.
 3235:      */
    1:     atoms = script->atomMap.vector;
    1: 
 3235: #define LOAD_ATOM(PCOFF)                                                      \
 3235:     JS_BEGIN_MACRO                                                            \
21685:         JS_ASSERT(fp->imacpc                                                  \
21685:                   ? atoms == COMMON_ATOMS_START(&rt->atomState) &&            \
21685:                     GET_INDEX(regs.pc + PCOFF) < js_common_atom_count         \
21685:                   : (size_t)(atoms - script->atomMap.vector) <                \
13168:                     (size_t)(script->atomMap.length -                         \
13168:                              GET_INDEX(regs.pc + PCOFF)));                    \
13168:         atom = atoms[GET_INDEX(regs.pc + PCOFF)];                             \
 3235:     JS_END_MACRO
 3235: 
 3235: #define GET_FULL_INDEX(PCOFF)                                                 \
13168:     (atoms - script->atomMap.vector + GET_INDEX(regs.pc + PCOFF))
 3235: 
 3235: #define LOAD_OBJECT(PCOFF)                                                    \
32723:     (obj = script->getObject(GET_FULL_INDEX(PCOFF)))
 3235: 
 3235: #define LOAD_FUNCTION(PCOFF)                                                  \
32723:     (fun = script->getFunction(GET_FULL_INDEX(PCOFF)))
    1: 
17598: #ifdef JS_TRACER
17598: 
29368: #ifdef MOZ_TRACEVIS
31063: #if JS_THREADED_INTERP
29368: #define MONITOR_BRANCH_TRACEVIS                                               \
29368:     JS_BEGIN_MACRO                                                            \
29368:         if (jumpTable != interruptJumpTable)                                  \
31063:             js_EnterTraceVisState(cx, S_RECORD, R_NONE);                      \
29368:     JS_END_MACRO
31063: #else /* !JS_THREADED_INTERP */
31063: #define MONITOR_BRANCH_TRACEVIS                                               \
31063:     JS_BEGIN_MACRO                                                            \
31063:         js_EnterTraceVisState(cx, S_RECORD, R_NONE);                          \
31063:     JS_END_MACRO
31063: #endif
29368: #else
29368: #define MONITOR_BRANCH_TRACEVIS
29368: #endif
29368: 
33564: #define RESTORE_INTERP_VARS()                                                 \
17410:     JS_BEGIN_MACRO                                                            \
17923:         fp = cx->fp;                                                          \
17923:         script = fp->script;                                                  \
24293:         atoms = FrameAtomBase(cx, fp);                                        \
17923:         currentVersion = (JSVersion) script->version;                         \
17923:         JS_ASSERT(fp->regs == &regs);                                         \
20403:         if (cx->throwing)                                                     \
20403:             goto error;                                                       \
33564:     JS_END_MACRO
33564: 
33564: #define MONITOR_BRANCH(reason)                                                \
33564:     JS_BEGIN_MACRO                                                            \
33564:         if (TRACING_ENABLED(cx)) {                                            \
33564:             if (js_MonitorLoopEdge(cx, inlineCallCount, reason)) {            \
33564:                 JS_ASSERT(TRACE_RECORDER(cx));                                \
33564:                 MONITOR_BRANCH_TRACEVIS;                                      \
33564:                 ENABLE_INTERRUPTS();                                          \
33564:             }                                                                 \
33564:             RESTORE_INTERP_VARS();                                            \
17923:         }                                                                     \
17410:     JS_END_MACRO
17410: 
17598: #else /* !JS_TRACER */
17598: 
33564: #define MONITOR_BRANCH(reason) ((void) 0)
17598: 
17598: #endif /* !JS_TRACER */
17598: 
    1:     /*
11758:      * Prepare to call a user-supplied branch handler, and abort the script
11758:      * if it returns false.
11758:      */
17410: #define CHECK_BRANCH()                                                        \
 3235:     JS_BEGIN_MACRO                                                            \
25087:         if (!JS_CHECK_OPERATION_LIMIT(cx))                                    \
11859:             goto error;                                                       \
 3235:     JS_END_MACRO
23442: 
27038: #ifndef TRACE_RECORDER
27038: #define TRACE_RECORDER(cx) (false)
27038: #endif
27038: 
17410: #define BRANCH(n)                                                             \
17410:     JS_BEGIN_MACRO                                                            \
25627:         regs.pc += (n);                                                       \
25627:         op = (JSOp) *regs.pc;                                                 \
26375:         if ((n) <= 0) {                                                       \
26375:             CHECK_BRANCH();                                                   \
25627:             if (op == JSOP_NOP) {                                             \
27038:                 if (TRACE_RECORDER(cx)) {                                     \
34351:                     MONITOR_BRANCH(Record_Branch);                           \
27038:                     op = (JSOp) *regs.pc;                                     \
27038:                 } else {                                                      \
25627:                     op = (JSOp) *++regs.pc;                                   \
27038:                 }                                                             \
32776:             } else if (op == JSOP_TRACE) {                                    \
34351:                 MONITOR_BRANCH(Record_Branch);                               \
25627:                 op = (JSOp) *regs.pc;                                         \
17410:             }                                                                 \
26375:         }                                                                     \
17611:         DO_OP();                                                              \
17410:     JS_END_MACRO
16072: 
18989:     MUST_FLOW_THROUGH("exit");
18308:     ++cx->interpLevel;
18308: 
18308:     /*
    1:      * Optimized Get and SetVersion for proper script language versioning.
    1:      *
    1:      * If any native method or JSClass/JSObjectOps hook calls js_SetVersion
    1:      * and changes cx->version, the effect will "stick" and we will stop
    1:      * maintaining currentVersion.  This is relied upon by testsuites, for
    1:      * the most part -- web browsers select version before compiling and not
    1:      * at run-time.
    1:      */
 3164:     currentVersion = (JSVersion) script->version;
 3164:     originalVersion = (JSVersion) cx->version;
    1:     if (currentVersion != originalVersion)
    1:         js_SetVersion(cx, currentVersion);
    1: 
18308:     /* Update the static-link display. */
27012:     if (script->staticLevel < JS_DISPLAY_SIZE) {
27012:         JSStackFrame **disp = &cx->display[script->staticLevel];
18308:         fp->displaySave = *disp;
18308:         *disp = fp;
18308:     }
    1: 
23111: # define CHECK_INTERRUPT_HANDLER()                                            \
23111:     JS_BEGIN_MACRO                                                            \
23111:         if (cx->debugHooks->interruptHandler)                                 \
23111:             ENABLE_INTERRUPTS();                                              \
23111:     JS_END_MACRO
23111: 
    1:     /*
    1:      * Load the debugger's interrupt hook here and after calling out to native
    1:      * functions (but not to getters, setters, or other native hooks), so we do
    1:      * not have to reload it each time through the interpreter loop -- we hope
    1:      * the compiler can keep it in a register when it is non-null.
    1:      */
23111:     CHECK_INTERRUPT_HANDLER();
    1: 
20908: #if !JS_HAS_GENERATORS
20908:     JS_ASSERT(!fp->regs);
20908: #else
20908:     /* Initialize the pc and sp registers unless we're resuming a generator. */
16072:     if (JS_LIKELY(!fp->regs)) {
20908: #endif
11758:         ASSERT_NOT_THROWING(cx);
13168:         regs.pc = script->code;
16072:         regs.sp = StackBase(fp);
13168:         fp->regs = &regs;
20908: #if JS_HAS_GENERATORS
    1:     } else {
13168:         JSGenerator *gen;
13168: 
11758:         JS_ASSERT(fp->flags & JSFRAME_GENERATOR);
13168:         gen = FRAME_TO_GENERATOR(fp);
13168:         JS_ASSERT(fp->regs == &gen->savedRegs);
13168:         regs = gen->savedRegs;
13168:         fp->regs = &regs;
13168:         JS_ASSERT((size_t) (regs.pc - script->code) <= script->length);
16072:         JS_ASSERT((size_t) (regs.sp - StackBase(fp)) <= StackDepth(script));
    1: 
    1:         /*
11758:          * To support generator_throw and to catch ignored exceptions,
11758:          * fail if cx->throwing is set.
    1:          */
11758:         if (cx->throwing) {
    1: #ifdef DEBUG_NOT_THROWING
11442:             if (cx->exception != JSVAL_ARETURN) {
    1:                 printf("JS INTERPRETER CALLED WITH PENDING EXCEPTION %lx\n",
    1:                        (unsigned long) cx->exception);
11442:             }
    1: #endif
11859:             goto error;
10592:         }
    1:     }
20908: #endif /* JS_HAS_GENERATORS */
    1: 
33546: #ifdef JS_TRACER
33546:     /*
33546:      * We cannot reenter the interpreter while recording; wait to abort until
33546:      * after cx->fp->regs is set.
33546:      */
33546:     if (TRACE_RECORDER(cx))
33546:         js_AbortRecording(cx, "attempt to reenter interpreter while recording");
33546: #endif
33546: 
15453:     /*
15453:      * It is important that "op" be initialized before calling DO_OP because
15453:      * it is possible for "op" to be specially assigned during the normal
15453:      * processing of an opcode while looping. We rely on DO_NEXT_OP to manage
15453:      * "op" correctly in all other cases.
15453:      */
15453:     len = 0;
15453:     DO_NEXT_OP(len);
15453: 
    1: #if JS_THREADED_INTERP
    1:     /*
    1:      * This is a loop, but it does not look like a loop. The loop-closing
15453:      * jump is distributed throughout goto *jumpTable[op] inside of DO_OP.
15453:      * When interrupts are enabled, jumpTable is set to interruptJumpTable
23111:      * where all jumps point to the interrupt label. The latter, after
15453:      * calling the interrupt handler, dispatches through normalJumpTable to
15453:      * continue the normal bytecode processing.
15453:      */
31481: 
23111: #else /* !JS_THREADED_INTERP */
15453:     for (;;) {
15453:       advance_pc_by_one:
15453:         JS_ASSERT(js_CodeSpec[op].length == 1);
15453:         len = 1;
15453:       advance_pc:
15453:         regs.pc += len;
13168:         op = (JSOp) *regs.pc;
15453: 
15453:       do_op:
23111:         CHECK_RECORDER();
26954:         TRACE_OPCODE(op);
23111:         switchOp = intN(op) | switchMask;
15453:       do_switch:
15453:         switch (switchOp) {
27490: #endif
31481: 
31481: /********************** Here we include the operations ***********************/
31481: #include "jsops.cpp"
31481: /*****************************************************************************/
31481: 
31481: #if !JS_THREADED_INTERP
    1:           default:
    1: #endif
24384: #ifndef JS_TRACER
24384:         bad_opcode:
24384: #endif
    1:           {
    1:             char numBuf[12];
    1:             JS_snprintf(numBuf, sizeof numBuf, "%d", op);
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_BAD_BYTECODE, numBuf);
11859:             goto error;
    1:           }
    1: 
    1: #if !JS_THREADED_INTERP
    1:         } /* switch (op) */
23111:     } /* for (;;) */
    1: #endif /* !JS_THREADED_INTERP */
    1: 
11859:   error:
21685:     if (fp->imacpc && cx->throwing) {
21685:         // To keep things simple, we hard-code imacro exception handlers here.
28812:         if (*fp->imacpc == JSOP_NEXTITER && js_ValueIsStopIteration(cx->exception)) {
24384:             // pc may point to JSOP_DUP here due to bug 474854.
27012:             JS_ASSERT(*regs.pc == JSOP_CALL || *regs.pc == JSOP_DUP || *regs.pc == JSOP_TRUE);
21685:             cx->throwing = JS_FALSE;
21685:             cx->exception = JSVAL_VOID;
21685:             regs.sp[-1] = JSVAL_HOLE;
21685:             PUSH(JSVAL_FALSE);
21685:             goto end_imacro;
21685:         }
21685: 
21685:         // Handle other exceptions as if they came from the imacro-calling pc.
21685:         regs.pc = fp->imacpc;
21685:         fp->imacpc = NULL;
21685:         atoms = script->atomMap.vector;
21685:     }
21685: 
26277:     JS_ASSERT((size_t)((fp->imacpc ? fp->imacpc : regs.pc) - script->code) < script->length);
24245: 
27490: #ifdef JS_TRACER
24245:     /*
24245:      * This abort could be weakened to permit tracing through exceptions that
24245:      * are thrown and caught within a loop, with the co-operation of the tracer.
24245:      * For now just bail on any sign of trouble.
24245:      */
27490:     if (TRACE_RECORDER(cx))
27490:         js_AbortRecording(cx, "error or exception while recording");
27490: #endif
24245: 
11859:     if (!cx->throwing) {
11859:         /* This is an error, not a catchable exception, quit the frame ASAP. */
11859:         ok = JS_FALSE;
11859:     } else {
 1825:         JSTrapHandler handler;
 1825:         JSTryNote *tn, *tnlimit;
 1825:         uint32 offset;
 1825: 
11758:         /* Call debugger throw hook if set. */
 2433:         handler = cx->debugHooks->throwHook;
    1:         if (handler) {
13168:             switch (handler(cx, script, regs.pc, &rval,
 2433:                             cx->debugHooks->throwHookData)) {
    1:               case JSTRAP_ERROR:
    1:                 cx->throwing = JS_FALSE;
11859:                 goto error;
    1:               case JSTRAP_RETURN:
    1:                 cx->throwing = JS_FALSE;
    1:                 fp->rval = rval;
11758:                 ok = JS_TRUE;
11758:                 goto forced_return;
    1:               case JSTRAP_THROW:
    1:                 cx->exception = rval;
    1:               case JSTRAP_CONTINUE:
    1:               default:;
    1:             }
23111:             CHECK_INTERRUPT_HANDLER();
    1:         }
    1: 
    1:         /*
    1:          * Look for a try block in script that can catch this exception.
    1:          */
 3235:         if (script->trynotesOffset == 0)
 1825:             goto no_catch;
 1825: 
13168:         offset = (uint32)(regs.pc - script->main);
32723:         tn = script->trynotes()->vector;
32723:         tnlimit = tn + script->trynotes()->length;
 3025:         do {
 3025:             if (offset - tn->start >= tn->length)
 3025:                 continue;
 3025: 
 3025:             /*
 3025:              * We have a note that covers the exception pc but we must check
 3025:              * whether the interpreter has already executed the corresponding
 3025:              * handler. This is possible when the executed bytecode
 3025:              * implements break or return from inside a for-in loop.
 3025:              *
 3025:              * In this case the emitter generates additional [enditer] and
 3025:              * [gosub] opcodes to close all outstanding iterators and execute
 3025:              * the finally blocks. If such an [enditer] throws an exception,
 3025:              * its pc can still be inside several nested for-in loops and
 3025:              * try-finally statements even if we have already closed the
 3025:              * corresponding iterators and invoked the finally blocks.
 3025:              *
 3025:              * To address this, we make [enditer] always decrease the stack
 3025:              * even when its implementation throws an exception. Thus already
 3025:              * executed [enditer] and [gosub] opcodes will have try notes
 3025:              * with the stack depth exceeding the current one and this
 3025:              * condition is what we use to filter them out.
 3025:              */
16072:             if (tn->stackDepth > regs.sp - StackBase(fp))
 3025:                 continue;
 3025: 
 3025:             /*
 3025:              * Set pc to the first bytecode after the the try note to point
 3025:              * to the beginning of catch or finally or to [enditer] closing
 3025:              * the for-in loop.
 1825:              */
13168:             regs.pc = (script)->main + tn->start + tn->length;
13168: 
12551:             ok = js_UnwindScope(cx, fp, tn->stackDepth, JS_TRUE);
16072:             JS_ASSERT(fp->regs->sp == StackBase(fp) + tn->stackDepth);
11758:             if (!ok) {
11758:                 /*
11758:                  * Restart the handler search with updated pc and stack depth
11758:                  * to properly notify the debugger.
11758:                  */
11859:                 goto error;
11758:             }
 1825: 
 3025:             switch (tn->kind) {
20420:               case JSTRY_CATCH:
25215:                 JS_ASSERT(js_GetOpcode(cx, fp->script, regs.pc) == JSOP_ENTERBLOCK);
 3025: 
 3025: #if JS_HAS_GENERATORS
 3025:                 /* Catch cannot intercept the closing of a generator. */
 3025:                 if (JS_UNLIKELY(cx->exception == JSVAL_ARETURN))
 3025:                     break;
 3025: #endif
 3025: 
 1825:                 /*
 3025:                  * Don't clear cx->throwing to save cx->exception from GC
 3025:                  * until it is pushed to the stack via [exception] in the
 3025:                  * catch block.
 3025:                  */
 3025:                 len = 0;
 3025:                 DO_NEXT_OP(len);
 3025: 
20420:               case JSTRY_FINALLY:
 3025:                 /*
 3025:                  * Push (true, exception) pair for finally to indicate that
 1825:                  * [retsub] should rethrow the exception.
 1825:                  */
 1825:                 PUSH(JSVAL_TRUE);
 1825:                 PUSH(cx->exception);
 1825:                 cx->throwing = JS_FALSE;
 3025:                 len = 0;
 3025:                 DO_NEXT_OP(len);
 3025: 
20420:               case JSTRY_ITER:
 1825:                 /*
21441:                  * This is similar to JSOP_ENDITER in the interpreter loop,
21441:                  * except the code now uses the stack slot normally used by
21441:                  * JSOP_NEXTITER, namely regs.sp[-1] before the regs.sp -= 2
21441:                  * adjustment and regs.sp[1] after, to save and restore the
21441:                  * pending exception.
 1825:                  */
25215:                 JS_ASSERT(js_GetOpcode(cx, fp->script, regs.pc) == JSOP_ENDITER);
21441:                 regs.sp[-1] = cx->exception;
 3025:                 cx->throwing = JS_FALSE;
13168:                 ok = js_CloseIterator(cx, regs.sp[-2]);
13168:                 regs.sp -= 2;
11859:                 if (!ok)
11859:                     goto error;
 3025:                 cx->throwing = JS_TRUE;
13168:                 cx->exception = regs.sp[1];
11859:             }
11859:         } while (++tn != tnlimit);
11859: 
11859:       no_catch:
 3025:         /*
11859:          * Propagate the exception or error to the caller unless the exception
11859:          * is an asynchronous return from a generator.
 3025:          */
 3025:         ok = JS_FALSE;
 1969: #if JS_HAS_GENERATORS
 3025:         if (JS_UNLIKELY(cx->throwing && cx->exception == JSVAL_ARETURN)) {
 1969:             cx->throwing = JS_FALSE;
 1969:             ok = JS_TRUE;
 1969:             fp->rval = JSVAL_VOID;
 1969:         }
 1969: #endif
    1:     }
    1: 
11758:   forced_return:
    1:     /*
11859:      * Unwind the scope making sure that ok stays false even when UnwindScope
11859:      * returns true.
11859:      *
11859:      * When a trap handler returns JSTRAP_RETURN, we jump here with ok set to
11859:      * true bypassing any finally blocks.
    1:      */
12551:     ok &= js_UnwindScope(cx, fp, 0, ok || cx->throwing);
16072:     JS_ASSERT(regs.sp == StackBase(fp));
11758: 
27233: #ifdef DEBUG
27233:     cx->tracePrevPc = NULL;
27233: #endif
27233: 
    1:     if (inlineCallCount)
    1:         goto inline_return;
    1: 
11758:   exit:
    1:     /*
11377:      * At this point we are inevitably leaving an interpreted function or a
11377:      * top-level script, and returning to one of:
11758:      * (a) an "out of line" call made through js_Invoke;
11758:      * (b) a js_Execute activation;
11758:      * (c) a generator (SendToGenerator, jsiter.c).
11758:      *
11859:      * We must not be in an inline frame. The check above ensures that for the
11859:      * error case and for a normal return, the code jumps directly to parent's
11859:      * frame pc.
    1:      */
11758:     JS_ASSERT(inlineCallCount == 0);
13168:     JS_ASSERT(fp->regs == &regs);
18181: #ifdef JS_TRACER
19093:     if (TRACE_RECORDER(cx))
20422:         js_AbortRecording(cx, "recording out of js_Interpret");
18181: #endif
20908: #if JS_HAS_GENERATORS
16072:     if (JS_UNLIKELY(fp->flags & JSFRAME_YIELDING)) {
13168:         JSGenerator *gen;
13168: 
13168:         gen = FRAME_TO_GENERATOR(fp);
13168:         gen->savedRegs = regs;
13168:         gen->frame.regs = &gen->savedRegs;
20908:     } else
20908: #endif /* JS_HAS_GENERATORS */
20908:     {
16072:         JS_ASSERT(!fp->blockChain);
16072:         JS_ASSERT(!js_IsActiveWithOrBlock(cx, fp->scopeChain, 0));
13168:         fp->regs = NULL;
16072:     }
16072: 
18308:     /* Undo the remaining effects committed on entry to js_Interpret. */
27012:     if (script->staticLevel < JS_DISPLAY_SIZE)
27012:         cx->display[script->staticLevel] = fp->displaySave;
    1:     if (cx->version == currentVersion && currentVersion != originalVersion)
    1:         js_SetVersion(cx, originalVersion);
18308:     --cx->interpLevel;
18706: 
    1:     return ok;
    1: 
    1:   atom_not_defined:
    1:     {
11720:         const char *printable;
11720: 
11720:         printable = js_AtomToPrintableString(cx, atom);
    1:         if (printable)
    1:             js_ReportIsNotDefined(cx, printable);
11859:         goto error;
11859:     }
11859: }
12551: 
15996: #endif /* !defined jsinvoke_cpp___ */
