    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   David Hyatt <hyatt@netscape.com>
    1:  *   Daniel Glazman <glazman@netscape.com>
15212:  *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * representation of CSS style rules (selectors+declaration), CSS
    1:  * selectors, and DOM objects for style rules, selectors, and
    1:  * declarations
    1:  */
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsCSSRule.h"
    1: #include "nsICSSStyleRule.h"
    1: #include "nsICSSGroupRule.h"
    1: #include "nsCSSDeclaration.h"
    1: #include "nsICSSStyleSheet.h"
    1: #include "nsICSSParser.h"
    1: #include "nsICSSLoader.h"
    1: #include "nsIURL.h"
    1: #include "nsPresContext.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsIAtom.h"
    1: #include "nsCRT.h"
    1: #include "nsString.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsStyleUtil.h"
    1: #include "nsIFontMetrics.h"
    1: #include "nsIDOMCSSStyleSheet.h"
    1: #include "nsICSSStyleRuleDOMWrapper.h"
    1: #include "nsIDOMCSSStyleDeclaration.h"
    1: #include "nsDOMCSSDeclaration.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsXMLNameSpaceMap.h"
    1: #include "nsILookAndFeel.h"
    1: #include "nsRuleNode.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsCSSPseudoElements.h"
 1036: #include "nsIPrincipal.h"
 1036: #include "nsComponentManagerUtils.h"
15212: #include "nsCSSPseudoClasses.h"
    1: 
    1: #include "nsContentUtils.h"
    1: #include "nsContentErrors.h"
14228: #include "mozAutoDocUpdate.h"
    1: 
    1: #define NS_IF_CLONE(member_)                                                  \
    1:   PR_BEGIN_MACRO                                                              \
    1:     if (member_) {                                                            \
    1:       result->member_ = member_->Clone();                                     \
    1:       if (!result->member_) {                                                 \
    1:         delete result;                                                        \
    1:         return nsnull;                                                        \
    1:       }                                                                       \
    1:     }                                                                         \
    1:   PR_END_MACRO
    1: 
    1: #define NS_IF_DELETE(ptr)                                                     \
    1:   PR_BEGIN_MACRO                                                              \
    1:     delete ptr;                                                               \
    1:     ptr = nsnull;                                                             \
    1:   PR_END_MACRO
    1: 
    1: /* ************************************************************************** */
    1: 
    1: nsAtomList::nsAtomList(nsIAtom* aAtom)
    1:   : mAtom(aAtom),
    1:     mNext(nsnull)
    1: {
    1:   MOZ_COUNT_CTOR(nsAtomList);
    1: }
    1: 
    1: nsAtomList::nsAtomList(const nsString& aAtomValue)
    1:   : mAtom(nsnull),
    1:     mNext(nsnull)
    1: {
    1:   MOZ_COUNT_CTOR(nsAtomList);
    1:   mAtom = do_GetAtom(aAtomValue);
    1: }
    1: 
    1: nsAtomList*
    1: nsAtomList::Clone(PRBool aDeep) const
    1: {
    1:   nsAtomList *result = new nsAtomList(mAtom);
    1:   if (!result)
    1:     return nsnull;
    1: 
    1:   if (aDeep)
20563:     NS_CSS_CLONE_LIST_MEMBER(nsAtomList, this, mNext, result, (PR_FALSE));
    1:   return result;
    1: }
    1: 
    1: nsAtomList::~nsAtomList(void)
    1: {
    1:   MOZ_COUNT_DTOR(nsAtomList);
20563:   NS_CSS_DELETE_LIST_MEMBER(nsAtomList, this, mNext);
    1: }
    1: 
15212: nsPseudoClassList::nsPseudoClassList(nsIAtom* aAtom)
15212:   : mAtom(aAtom),
15212:     mNext(nsnull)
15212: {
15212:   NS_ASSERTION(!nsCSSPseudoClasses::HasStringArg(aAtom) &&
15212:                !nsCSSPseudoClasses::HasNthPairArg(aAtom),
15212:                "unexpected pseudo-class");
15212:   MOZ_COUNT_CTOR(nsPseudoClassList);
15212:   u.mMemory = nsnull;
15212: }
15212: 
15211: nsPseudoClassList::nsPseudoClassList(nsIAtom* aAtom, const PRUnichar* aString)
    1:   : mAtom(aAtom),
    1:     mNext(nsnull)
    1: {
15212:   NS_ASSERTION(nsCSSPseudoClasses::HasStringArg(aAtom),
15212:                "unexpected pseudo-class");
15212:   NS_ASSERTION(aString, "string expected");
15211:   MOZ_COUNT_CTOR(nsPseudoClassList);
15212:   u.mString = NS_strdup(aString);
15212: }
15212: 
15212: nsPseudoClassList::nsPseudoClassList(nsIAtom* aAtom, const PRInt32* aIntPair)
15212:   : mAtom(aAtom),
15212:     mNext(nsnull)
15212: {
15212:   NS_ASSERTION(nsCSSPseudoClasses::HasNthPairArg(aAtom),
15212:                "unexpected pseudo-class");
15212:   NS_ASSERTION(aIntPair, "integer pair expected");
15212:   MOZ_COUNT_CTOR(nsPseudoClassList);
15212:   u.mNumbers =
15212:     static_cast<PRInt32*>(nsMemory::Clone(aIntPair, sizeof(PRInt32) * 2));
    1: }
    1: 
15211: nsPseudoClassList*
15211: nsPseudoClassList::Clone(PRBool aDeep) const
    1: {
15212:   nsPseudoClassList *result;
15212:   if (!u.mMemory) {
15212:     result = new nsPseudoClassList(mAtom);
15212:   } else if (nsCSSPseudoClasses::HasStringArg(mAtom)) {
15212:     result = new nsPseudoClassList(mAtom, u.mString);
15212:   } else {
15212:     NS_ASSERTION(nsCSSPseudoClasses::HasNthPairArg(mAtom),
15212:                  "unexpected pseudo-class");
15212:     result = new nsPseudoClassList(mAtom, u.mNumbers);
15212:   }
    1: 
    1:   if (aDeep)
20563:     NS_CSS_CLONE_LIST_MEMBER(nsPseudoClassList, this, mNext, result,
20563:                              (PR_FALSE));
    1: 
    1:   return result;
    1: }
    1: 
15211: nsPseudoClassList::~nsPseudoClassList(void)
    1: {
15211:   MOZ_COUNT_DTOR(nsPseudoClassList);
15212:   if (u.mMemory)
15212:     NS_Free(u.mMemory);
20563:   NS_CSS_DELETE_LIST_MEMBER(nsPseudoClassList, this, mNext);
    1: }
    1: 
    1: nsAttrSelector::nsAttrSelector(PRInt32 aNameSpace, const nsString& aAttr)
    1:   : mNameSpace(aNameSpace),
    1:     mAttr(nsnull),
    1:     mFunction(NS_ATTR_FUNC_SET),
    1:     mCaseSensitive(1),
    1:     mValue(),
    1:     mNext(nsnull)
    1: {
    1:   MOZ_COUNT_CTOR(nsAttrSelector);
    1: 
    1:   mAttr = do_GetAtom(aAttr);
    1: }
    1: 
    1: nsAttrSelector::nsAttrSelector(PRInt32 aNameSpace, const nsString& aAttr, PRUint8 aFunction, 
    1:                                const nsString& aValue, PRBool aCaseSensitive)
    1:   : mNameSpace(aNameSpace),
    1:     mAttr(nsnull),
    1:     mFunction(aFunction),
    1:     mCaseSensitive(aCaseSensitive),
    1:     mValue(aValue),
    1:     mNext(nsnull)
    1: {
    1:   MOZ_COUNT_CTOR(nsAttrSelector);
    1: 
    1:   mAttr = do_GetAtom(aAttr);
    1: }
    1: 
    1: nsAttrSelector::nsAttrSelector(PRInt32 aNameSpace, nsIAtom* aAttr,
    1:                                PRUint8 aFunction, const nsString& aValue,
    1:                                PRBool aCaseSensitive)
    1:   : mNameSpace(aNameSpace),
    1:     mAttr(aAttr),
    1:     mFunction(aFunction),
    1:     mCaseSensitive(aCaseSensitive),
    1:     mValue(aValue),
    1:     mNext(nsnull)
    1: {
    1:   MOZ_COUNT_CTOR(nsAttrSelector);
    1: }
    1: 
    1: nsAttrSelector*
    1: nsAttrSelector::Clone(PRBool aDeep) const
    1: {
    1:   nsAttrSelector *result =
    1:     new nsAttrSelector(mNameSpace, mAttr, mFunction, mValue, mCaseSensitive);
    1: 
    1:   if (aDeep)
20563:     NS_CSS_CLONE_LIST_MEMBER(nsAttrSelector, this, mNext, result, (PR_FALSE));
    1: 
    1:   return result;
    1: }
    1: 
    1: nsAttrSelector::~nsAttrSelector(void)
    1: {
    1:   MOZ_COUNT_DTOR(nsAttrSelector);
    1: 
20563:   NS_CSS_DELETE_LIST_MEMBER(nsAttrSelector, this, mNext);
    1: }
    1: 
    1: // -- nsCSSSelector -------------------------------
    1: 
    1: nsCSSSelector::nsCSSSelector(void)
    1:   : mNameSpace(kNameSpaceID_Unknown), mTag(nsnull), 
    1:     mIDList(nsnull), 
    1:     mClassList(nsnull), 
    1:     mPseudoClassList(nsnull),
    1:     mAttrList(nsnull), 
    1:     mOperator(0),
    1:     mNegations(nsnull),
    1:     mNext(nsnull)
    1: {
    1:   MOZ_COUNT_CTOR(nsCSSSelector);
    1: }
    1: 
    1: nsCSSSelector*
    1: nsCSSSelector::Clone(PRBool aDeepNext, PRBool aDeepNegations) const
    1: {
    1:   nsCSSSelector *result = new nsCSSSelector();
    1:   if (!result)
    1:     return nsnull;
    1: 
    1:   result->mNameSpace = mNameSpace;
    1:   result->mTag = mTag;
    1:   
    1:   NS_IF_CLONE(mIDList);
    1:   NS_IF_CLONE(mClassList);
    1:   NS_IF_CLONE(mPseudoClassList);
    1:   NS_IF_CLONE(mAttrList);
    1: 
    1:   // No need to worry about multiple levels of recursion since an
    1:   // mNegations can't have an mNext.
20563:   NS_ASSERTION(!mNegations || !mNegations->mNext,
20563:                "mNegations can't have non-null mNext");
    1:   if (aDeepNegations) {
20563:     NS_CSS_CLONE_LIST_MEMBER(nsCSSSelector, this, mNegations, result,
20563:                              (PR_TRUE, PR_FALSE));
    1:   }
    1: 
    1:   if (aDeepNext) {
20563:     NS_CSS_CLONE_LIST_MEMBER(nsCSSSelector, this, mNext, result,
20563:                              (PR_FALSE, PR_TRUE));
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: nsCSSSelector::~nsCSSSelector(void)  
    1: {
    1:   MOZ_COUNT_DTOR(nsCSSSelector);
    1:   Reset();
    1:   // No need to worry about multiple levels of recursion since an
    1:   // mNegations can't have an mNext.
20563:   NS_CSS_DELETE_LIST_MEMBER(nsCSSSelector, this, mNext);
    1: }
    1: 
    1: void nsCSSSelector::Reset(void)
    1: {
    1:   mNameSpace = kNameSpaceID_Unknown;
    1:   mTag = nsnull;
    1:   NS_IF_DELETE(mIDList);
    1:   NS_IF_DELETE(mClassList);
    1:   NS_IF_DELETE(mPseudoClassList);
    1:   NS_IF_DELETE(mAttrList);
    1:   // No need to worry about multiple levels of recursion since an
    1:   // mNegations can't have an mNext.
20563:   NS_ASSERTION(!mNegations || !mNegations->mNext,
20563:                "mNegations can't have non-null mNext");
20563:   NS_CSS_DELETE_LIST_MEMBER(nsCSSSelector, this, mNegations);
    1:   mOperator = PRUnichar(0);
    1: }
    1: 
    1: void nsCSSSelector::SetNameSpace(PRInt32 aNameSpace)
    1: {
    1:   mNameSpace = aNameSpace;
    1: }
    1: 
    1: void nsCSSSelector::SetTag(const nsString& aTag)
    1: {
    1:   if (aTag.IsEmpty())
    1:     mTag = nsnull;
    1:   else
    1:     mTag = do_GetAtom(aTag);
    1: }
    1: 
    1: void nsCSSSelector::AddID(const nsString& aID)
    1: {
    1:   if (!aID.IsEmpty()) {
    1:     nsAtomList** list = &mIDList;
    1:     while (nsnull != *list) {
    1:       list = &((*list)->mNext);
    1:     }
    1:     *list = new nsAtomList(aID);
    1:   }
    1: }
    1: 
    1: void nsCSSSelector::AddClass(const nsString& aClass)
    1: {
    1:   if (!aClass.IsEmpty()) {
    1:     nsAtomList** list = &mClassList;
    1:     while (nsnull != *list) {
    1:       list = &((*list)->mNext);
    1:     }
    1:     *list = new nsAtomList(aClass);
    1:   }
    1: }
    1: 
15212: void nsCSSSelector::AddPseudoClass(nsIAtom* aPseudoClass)
15212: {
15212:   AddPseudoClassInternal(new nsPseudoClassList(aPseudoClass));
15212: }
15212: 
    1: void nsCSSSelector::AddPseudoClass(nsIAtom* aPseudoClass,
    1:                                    const PRUnichar* aString)
    1: {
15212:   AddPseudoClassInternal(new nsPseudoClassList(aPseudoClass, aString));
15212: }
15212: 
15212: void nsCSSSelector::AddPseudoClass(nsIAtom* aPseudoClass,
15212:                                    const PRInt32* aIntPair)
15212: {
15212:   AddPseudoClassInternal(new nsPseudoClassList(aPseudoClass, aIntPair));
15212: }
15212: 
15212: void nsCSSSelector::AddPseudoClassInternal(nsPseudoClassList *aPseudoClass)
15212: {
15211:   nsPseudoClassList** list = &mPseudoClassList;
    1:   while (nsnull != *list) {
    1:     list = &((*list)->mNext);
    1:   }
15212:   *list = aPseudoClass;
    1: }
    1: 
    1: void nsCSSSelector::AddAttribute(PRInt32 aNameSpace, const nsString& aAttr)
    1: {
    1:   if (!aAttr.IsEmpty()) {
    1:     nsAttrSelector** list = &mAttrList;
    1:     while (nsnull != *list) {
    1:       list = &((*list)->mNext);
    1:     }
    1:     *list = new nsAttrSelector(aNameSpace, aAttr);
    1:   }
    1: }
    1: 
    1: void nsCSSSelector::AddAttribute(PRInt32 aNameSpace, const nsString& aAttr, PRUint8 aFunc, 
    1:                                  const nsString& aValue, PRBool aCaseSensitive)
    1: {
    1:   if (!aAttr.IsEmpty()) {
    1:     nsAttrSelector** list = &mAttrList;
    1:     while (nsnull != *list) {
    1:       list = &((*list)->mNext);
    1:     }
    1:     *list = new nsAttrSelector(aNameSpace, aAttr, aFunc, aValue, aCaseSensitive);
    1:   }
    1: }
    1: 
    1: void nsCSSSelector::SetOperator(PRUnichar aOperator)
    1: {
    1:   mOperator = aOperator;
    1: }
    1: 
    1: PRInt32 nsCSSSelector::CalcWeight(void) const
    1: {
    1:   PRInt32 weight = 0;
    1: 
    1:   if (nsnull != mTag) {
    1:     weight += 0x000001;
    1:   }
    1:   nsAtomList* list = mIDList;
    1:   while (nsnull != list) {
    1:     weight += 0x010000;
    1:     list = list->mNext;
    1:   }
    1:   list = mClassList;
    1:   while (nsnull != list) {
    1:     weight += 0x000100;
    1:     list = list->mNext;
    1:   }
15211:   nsPseudoClassList *plist = mPseudoClassList;
    1:   while (nsnull != plist) {
    1:     weight += 0x000100;
    1:     plist = plist->mNext;
    1:   }
    1:   nsAttrSelector* attr = mAttrList;
    1:   while (nsnull != attr) {
    1:     weight += 0x000100;
    1:     attr = attr->mNext;
    1:   }
    1:   if (nsnull != mNegations) {
    1:     weight += mNegations->CalcWeight();
    1:   }
    1:   return weight;
    1: }
    1: 
    1: // pseudo-elements are stored in the selectors' chain using fictional elements;
    1: // these fictional elements have mTag starting with a colon
    1: static PRBool IsPseudoElement(nsIAtom* aAtom)
    1: {
    1:   if (aAtom) {
    1:     const char* str;
    1:     aAtom->GetUTF8String(&str);
    1:     return str && (*str == ':');
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: void nsCSSSelector::AppendNegationToString(nsAString& aString)
    1: {
    1:   aString.AppendLiteral(":not(");
    1: }
    1: 
    1: //
    1: // Builds the textual representation of a selector. Called by DOM 2 CSS 
    1: // StyleRule:selectorText
    1: //
    1: void
    1: nsCSSSelector::ToString(nsAString& aString, nsICSSStyleSheet* aSheet,
    1:                         PRBool aAppend) const
    1: {
    1:   if (!aAppend)
    1:    aString.Truncate();
    1:    
    1:   ToStringInternal(aString, aSheet, IsPseudoElement(mTag), PR_FALSE);
    1: }
    1: 
    1: void nsCSSSelector::ToStringInternal(nsAString& aString,
    1:                                      nsICSSStyleSheet* aSheet,
    1:                                      PRBool aIsPseudoElem,
    1:                                      PRBool aIsNegated) const
    1: {
    1:   nsAutoString temp;
    1:   PRBool isPseudoElement = IsPseudoElement(mTag);
    1:   
    1:   // selectors are linked from right-to-left, so the next selector in the linked list
    1:   // actually precedes this one in the resulting string
    1:   if (mNext) {
    1:     mNext->ToStringInternal(aString, aSheet, IsPseudoElement(mTag), 0);
    1:     if (!aIsNegated && !isPseudoElement) {
    1:       // don't add a leading whitespace if we have a pseudo-element
    1:       // or a negated simple selector
    1:       aString.Append(PRUnichar(' '));
    1:     }
    1:   }
    1: 
    1:   // For non-pseudo-element selectors or for lone pseudo-elements, deal with
    1:   // namespace prefixes.
    1:   PRBool wroteNamespace = PR_FALSE;
    1:   if (!isPseudoElement || !mNext) {
    1:     // append the namespace prefix if needed
    1:     if (mNameSpace == kNameSpaceID_None) {
    1:       // The only way to do this in CSS is to have an explicit namespace
    1:       // of "none" specified in the sheet by having a '|' with nothing
    1:       // before it.
    1:       aString.Append(PRUnichar('|'));
    1:       wroteNamespace = PR_TRUE;
    1:     } else {
  495:       if (aSheet) {
    1:         nsXMLNameSpaceMap *sheetNS = aSheet->GetNameSpaceMap();
    1:     
    1:         // sheetNS is non-null if and only if we had an @namespace rule.  If it's
    1:         // null, that means that the only namespaces we could have are the
    1:         // wildcard namespace (which can be implicit in this case) and the "none"
    1:         // namespace, which we handled above.  So no need to output anything when
    1:         // sheetNS is null.
    1:         if (sheetNS) {
    1:           if (mNameSpace != kNameSpaceID_Unknown) {
    1:             if (sheetNS->FindNameSpaceID(nsnull) != mNameSpace) {
    1:               nsIAtom *prefixAtom = sheetNS->FindPrefix(mNameSpace);
    1:               NS_ASSERTION(prefixAtom, "how'd we get a non-default namespace "
    1:                                        "without a prefix?");
    1:               nsAutoString prefix;
    1:               prefixAtom->ToString(prefix);
    1:               aString.Append(prefix);
    1:               aString.Append(PRUnichar('|'));
    1:               wroteNamespace = PR_TRUE;
    1:             }
    1:             // otherwise it must be the default namespace
    1:           } else {
    1:             // A selector for an element in any namespace.
    1:             if (// Use explicit "*|" only when it's not implied
    1:                 sheetNS->FindNameSpaceID(nsnull) != kNameSpaceID_None &&
    1:                 // :not() is special in that the default namespace is
    1:                 // not implied for non-type selectors
    1:                 (!aIsNegated || (!mIDList && !mClassList &&
    1:                                  !mPseudoClassList && !mAttrList))) {
    1:               aString.AppendLiteral("*|");
    1:               wroteNamespace = PR_TRUE;
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
  495:   }
    1:       
    1:   if (!mTag) {
    1:     // Universal selector:  avoid writing the universal selector when we
    1:     // can avoid it, especially since we're required to avoid it for the
    1:     // inside of :not()
    1:     if (wroteNamespace ||
    1:         (!mIDList && !mClassList && !mPseudoClassList && !mAttrList &&
    1:          (aIsNegated || !mNegations))) {
    1:       aString.Append(PRUnichar('*'));
    1:     }
    1:   } else {
    1:     // Append the tag name
    1:     if (isPseudoElement) {
    1:       if (!mNext) {
    1:         // Lone pseudo-element selector -- toss in a wildcard type selector
    1:         // XXXldb Why?
    1:         aString.Append(PRUnichar('*'));
    1:       }
    1:       if (!nsCSSPseudoElements::IsCSS2PseudoElement(mTag)) {
    1:         aString.Append(PRUnichar(':'));
    1:       }
    1:     }
    1:     nsAutoString prefix;
    1:     mTag->ToString(prefix);
    1:     aString.Append(prefix);
    1:   }
    1: 
    1:   // Append the id, if there is one
    1:   if (mIDList) {
    1:     nsAtomList* list = mIDList;
    1:     while (list != nsnull) {
    1:       list->mAtom->ToString(temp);
    1:       aString.Append(PRUnichar('#'));
    1:       aString.Append(temp);
    1:       list = list->mNext;
    1:     }
    1:   }
    1: 
    1:   // Append each class in the linked list
    1:   if (mClassList) {
    1:     nsAtomList* list = mClassList;
    1:     while (list != nsnull) {
    1:       list->mAtom->ToString(temp);
    1:       aString.Append(PRUnichar('.'));
    1:       aString.Append(temp);
    1:       list = list->mNext;
    1:     }
    1:   }
    1: 
    1:   // Append each attribute selector in the linked list
    1:   if (mAttrList) {
    1:     nsAttrSelector* list = mAttrList;
    1:     while (list != nsnull) {
    1:       aString.Append(PRUnichar('['));
    1:       // Append the namespace prefix
    1:       if (list->mNameSpace > 0) {
  495:         if (aSheet) {
    1:           nsXMLNameSpaceMap *sheetNS = aSheet->GetNameSpaceMap();
    1:           // will return null if namespace was the default
    1:           nsIAtom *prefixAtom = sheetNS->FindPrefix(list->mNameSpace);
    1:           if (prefixAtom) { 
    1:             nsAutoString prefix;
    1:             prefixAtom->ToString(prefix);
    1:             aString.Append(prefix);
    1:             aString.Append(PRUnichar('|'));
    1:           }
    1:         }
  495:       }
    1:       // Append the attribute name
    1:       list->mAttr->ToString(temp);
    1:       aString.Append(temp);
    1: 
    1:       if (list->mFunction != NS_ATTR_FUNC_SET) {
    1:         // Append the function
    1:         if (list->mFunction == NS_ATTR_FUNC_INCLUDES)
    1:           aString.Append(PRUnichar('~'));
    1:         else if (list->mFunction == NS_ATTR_FUNC_DASHMATCH)
    1:           aString.Append(PRUnichar('|'));
    1:         else if (list->mFunction == NS_ATTR_FUNC_BEGINSMATCH)
    1:           aString.Append(PRUnichar('^'));
    1:         else if (list->mFunction == NS_ATTR_FUNC_ENDSMATCH)
    1:           aString.Append(PRUnichar('$'));
    1:         else if (list->mFunction == NS_ATTR_FUNC_CONTAINSMATCH)
    1:           aString.Append(PRUnichar('*'));
    1: 
    1:         aString.Append(PRUnichar('='));
    1:       
    1:         // Append the value
    1:         nsAutoString escaped;
    1:         nsStyleUtil::EscapeCSSString(list->mValue, escaped);
    1:       
    1:         aString.Append(PRUnichar('\"'));
    1:         aString.Append(escaped);
    1:         aString.Append(PRUnichar('\"'));
    1:       }
    1: 
    1:       aString.Append(PRUnichar(']'));
    1:       
    1:       list = list->mNext;
    1:     }
    1:   }
    1: 
    1:   // Append each pseudo-class in the linked list
    1:   if (mPseudoClassList) {
15211:     nsPseudoClassList* list = mPseudoClassList;
    1:     while (list != nsnull) {
    1:       list->mAtom->ToString(temp);
    1:       aString.Append(temp);
15212:       if (list->u.mMemory) {
    1:         aString.Append(PRUnichar('('));
15212:         if (nsCSSPseudoClasses::HasStringArg(list->mAtom)) {
15212:           aString.Append(list->u.mString);
15212:         } else {
15212:           NS_ASSERTION(nsCSSPseudoClasses::HasNthPairArg(list->mAtom),
15212:                        "unexpected pseudo-class");
15212:           PRInt32 a = list->u.mNumbers[0],
15212:                   b = list->u.mNumbers[1];
15212:           temp.Truncate();
15212:           if (a != 0) {
15212:             if (a == -1) {
15212:               temp.Append(PRUnichar('-'));
15212:             } else if (a != 1) {
15212:               temp.AppendInt(a);
15212:             }
15212:             temp.Append(PRUnichar('n'));
15212:           }
15212:           if (b != 0 || a == 0) {
15212:             if (b >= 0 && a != 0) // check a != 0 for whether we printed above
15212:               temp.Append(PRUnichar('+'));
15212:             temp.AppendInt(b);
15212:           }
15212:           aString.Append(temp);
15212:         }
    1:         aString.Append(PRUnichar(')'));
    1:       }
    1:       list = list->mNext;
    1:     }
    1:   }
    1: 
    1:   if (!aIsNegated) {
    1:     for (nsCSSSelector* negation = mNegations; negation;
    1:          negation = negation->mNegations) {
    1:       aString.AppendLiteral(":not(");
    1:       negation->ToStringInternal(aString, aSheet, PR_FALSE, PR_TRUE);
    1:       aString.Append(PRUnichar(')'));
    1:     }
    1:   }
    1: 
    1:   // Append the operator only if the selector is not negated and is not
    1:   // a pseudo-element
    1:   if (!aIsNegated && mOperator && !aIsPseudoElem) {
    1:     aString.Append(PRUnichar(' '));
    1:     aString.Append(mOperator);
    1:   }
    1: }
    1: 
    1: // -- nsCSSSelectorList -------------------------------
    1: 
    1: nsCSSSelectorList::nsCSSSelectorList(void)
    1:   : mSelectors(nsnull),
    1:     mWeight(0),
    1:     mNext(nsnull)
    1: {
    1:   MOZ_COUNT_CTOR(nsCSSSelectorList);
    1: }
    1: 
    1: nsCSSSelectorList::~nsCSSSelectorList()
    1: {
    1:   MOZ_COUNT_DTOR(nsCSSSelectorList);
20563:   delete mSelectors;
20563:   NS_CSS_DELETE_LIST_MEMBER(nsCSSSelectorList, this, mNext);
    1: }
    1: 
 3813: void nsCSSSelectorList::AddSelector(nsAutoPtr<nsCSSSelector>& aSelector)
    1: { // prepend to list
 3813:   nsCSSSelector* newSel = aSelector.forget();
    1:   if (newSel) {
    1:     newSel->mNext = mSelectors;
    1:     mSelectors = newSel;
    1:   }
    1: }
    1: 
    1: void
    1: nsCSSSelectorList::ToString(nsAString& aResult, nsICSSStyleSheet* aSheet)
    1: {
    1:   aResult.Truncate();
    1:   nsCSSSelectorList *p = this;
    1:   for (;;) {
    1:     p->mSelectors->ToString(aResult, aSheet, PR_TRUE);
    1:     p = p->mNext;
    1:     if (!p)
    1:       break;
    1:     aResult.AppendLiteral(", ");
    1:   }
    1: }
    1: 
    1: nsCSSSelectorList*
    1: nsCSSSelectorList::Clone(PRBool aDeep) const
    1: {
    1:   nsCSSSelectorList *result = new nsCSSSelectorList();
    1:   result->mWeight = mWeight;
    1:   NS_IF_CLONE(mSelectors);
    1: 
    1:   if (aDeep) {
20563:     NS_CSS_CLONE_LIST_MEMBER(nsCSSSelectorList, this, mNext, result,
20563:                              (PR_FALSE));
    1:   }
    1:   return result;
    1: }
    1: 
    1: // -- CSSImportantRule -------------------------------
    1: 
    1: class CSSStyleRuleImpl;
    1: 
    1: class CSSImportantRule : public nsIStyleRule {
    1: public:
    1:   CSSImportantRule(nsCSSDeclaration* aDeclaration);
    1: 
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   // nsIStyleRule interface
    1:   NS_IMETHOD MapRuleInfoInto(nsRuleData* aRuleData);
    1: #ifdef DEBUG
    1:   NS_IMETHOD List(FILE* out = stdout, PRInt32 aIndent = 0) const;
    1: #endif
    1: 
    1: protected:
    1:   virtual ~CSSImportantRule(void);
    1: 
    1:   nsCSSDeclaration*  mDeclaration;
    1: 
    1:   friend class CSSStyleRuleImpl;
    1: };
    1: 
    1: CSSImportantRule::CSSImportantRule(nsCSSDeclaration* aDeclaration)
    1:   : mDeclaration(aDeclaration)
    1: {
    1: }
    1: 
    1: CSSImportantRule::~CSSImportantRule(void)
    1: {
    1:   mDeclaration = nsnull;
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS1(CSSImportantRule, nsIStyleRule)
    1: 
    1: NS_IMETHODIMP
    1: CSSImportantRule::MapRuleInfoInto(nsRuleData* aRuleData)
    1: {
    1:   // Check this at runtime because it might be hit in some out-of-memory cases.
    1:   NS_ENSURE_TRUE(mDeclaration->HasImportantData(), NS_ERROR_UNEXPECTED);
    1: 
    1:   return mDeclaration->MapImportantRuleInfoInto(aRuleData);
    1: }
    1: 
    1: #ifdef DEBUG
    1: NS_IMETHODIMP
    1: CSSImportantRule::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   // Indent
    1:   for (PRInt32 index = aIndent; --index >= 0; ) fputs("  ", out);
    1: 
    1:   fputs("! Important rule ", out);
    1:   if (nsnull != mDeclaration) {
    1:     mDeclaration->List(out);
    1:   }
    1:   else {
    1:     fputs("{ null declaration }", out);
    1:   }
    1:   fputs("\n", out);
    1: 
    1:   return NS_OK;
    1: }
    1: #endif
    1: 
    1: // --------------------------------------------------------
    1: 
    1: class DOMCSSStyleRuleImpl;
    1: 
    1: class DOMCSSDeclarationImpl : public nsDOMCSSDeclaration
    1: {
    1: public:
    1:   DOMCSSDeclarationImpl(nsICSSStyleRule *aRule);
    1:   virtual ~DOMCSSDeclarationImpl(void);
    1: 
    1:   NS_IMETHOD GetParentRule(nsIDOMCSSRule **aParent);
    1:   virtual void DropReference(void);
    1:   virtual nsresult GetCSSDeclaration(nsCSSDeclaration **aDecl,
    1:                                      PRBool aAllocate);
    1:   virtual nsresult GetCSSParsingEnvironment(nsIURI** aSheetURI,
    1:                                             nsIURI** aBaseURI,
 1036:                                             nsIPrincipal** aSheetPrincipal,
    1:                                             nsICSSLoader** aCSSLoader,
    1:                                             nsICSSParser** aCSSParser);
    1:   virtual nsresult DeclarationChanged();
    1: 
    1:   // Override |AddRef| and |Release| for being a member of
    1:   // |DOMCSSStyleRuleImpl|.
    1:   NS_IMETHOD_(nsrefcnt) AddRef(void);
    1:   NS_IMETHOD_(nsrefcnt) Release(void);
    1: 
    1:   friend class DOMCSSStyleRuleImpl;
    1: 
    1: protected:
    1:   // This reference is not reference-counted. The rule object tells us
    1:   // when it's about to go away.
    1:   nsICSSStyleRule *mRule;
    1: 
    1:   inline DOMCSSStyleRuleImpl* DomRule();
    1: 
    1: private:
    1:   // NOT TO BE IMPLEMENTED
    1:   // This object cannot be allocated on its own.  It must be a member of
    1:   // DOMCSSStyleRuleImpl.
    1:   void* operator new(size_t size) CPP_THROW_NEW;
    1: };
    1: 
    1: class DOMCSSStyleRuleImpl : public nsICSSStyleRuleDOMWrapper
    1: {
    1: public:
    1:   DOMCSSStyleRuleImpl(nsICSSStyleRule *aRule);
    1:   virtual ~DOMCSSStyleRuleImpl();
    1: 
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSIDOMCSSRULE
    1:   NS_DECL_NSIDOMCSSSTYLERULE
    1: 
    1:   // nsICSSStyleRuleDOMWrapper
    1:   NS_IMETHOD GetCSSStyleRule(nsICSSStyleRule **aResult);
    1: 
    1:   DOMCSSDeclarationImpl* DOMDeclaration() { return &mDOMDeclaration; }
    1: 
    1:   friend class DOMCSSDeclarationImpl;
    1: 
    1: protected:
    1:   DOMCSSDeclarationImpl mDOMDeclaration;
    1: 
    1:   nsICSSStyleRule* Rule() {
    1:     return mDOMDeclaration.mRule;
    1:   }
    1: };
    1: 
    1: DOMCSSDeclarationImpl::DOMCSSDeclarationImpl(nsICSSStyleRule *aRule)
    1:   : mRule(aRule)
    1: {
    1:   MOZ_COUNT_CTOR(DOMCSSDeclarationImpl);
    1: }
    1: 
    1: DOMCSSDeclarationImpl::~DOMCSSDeclarationImpl(void)
    1: {
    1:   NS_ASSERTION(!mRule, "DropReference not called.");
    1: 
    1:   MOZ_COUNT_DTOR(DOMCSSDeclarationImpl);
    1: }
    1: 
    1: inline DOMCSSStyleRuleImpl* DOMCSSDeclarationImpl::DomRule()
    1: {
 3233:   return reinterpret_cast<DOMCSSStyleRuleImpl*>
 3233:                          (reinterpret_cast<char*>(this) -
    1:            offsetof(DOMCSSStyleRuleImpl, mDOMDeclaration));
    1: }
    1: 
    1: NS_IMPL_ADDREF_USING_AGGREGATOR(DOMCSSDeclarationImpl, DomRule())
    1: NS_IMPL_RELEASE_USING_AGGREGATOR(DOMCSSDeclarationImpl, DomRule())
    1: 
    1: void
    1: DOMCSSDeclarationImpl::DropReference(void)
    1: {
    1:   mRule = nsnull;
    1: }
    1: 
    1: nsresult
    1: DOMCSSDeclarationImpl::GetCSSDeclaration(nsCSSDeclaration **aDecl,
    1:                                          PRBool aAllocate)
    1: {
    1:   if (mRule) {
    1:     *aDecl = mRule->GetDeclaration();
    1:   }
    1:   else {
    1:     *aDecl = nsnull;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /*
    1:  * This is a utility function.  It will only fail if it can't get a
    1:  * parser.  This means it can return NS_OK without aURI or aCSSLoader
    1:  * being initialized.
    1:  */
    1: nsresult
    1: DOMCSSDeclarationImpl::GetCSSParsingEnvironment(nsIURI** aSheetURI, 
    1:                                                 nsIURI** aBaseURI,
 1036:                                                 nsIPrincipal** aSheetPrincipal,
    1:                                                 nsICSSLoader** aCSSLoader,
    1:                                                 nsICSSParser** aCSSParser)
    1: {
    1:   // null out the out params since some of them may not get initialized below
    1:   *aSheetURI = nsnull;
    1:   *aBaseURI = nsnull;
 1036:   *aSheetPrincipal = nsnull;
    1:   *aCSSLoader = nsnull;
    1:   *aCSSParser = nsnull;
    1:   nsresult result;
    1:   nsCOMPtr<nsIStyleSheet> sheet;
    1:   if (mRule) {
    1:     mRule->GetStyleSheet(*getter_AddRefs(sheet));
    1:     if (sheet) {
    1:       sheet->GetSheetURI(aSheetURI);
    1:       sheet->GetBaseURI(aBaseURI);
 1036: 
 1036:       nsCOMPtr<nsICSSStyleSheet> cssSheet(do_QueryInterface(sheet));
 1036:       if (cssSheet) {
 1036:         NS_ADDREF(*aSheetPrincipal = cssSheet->Principal());
 1036:       }
 1036: 
    1:       nsCOMPtr<nsIDocument> document;
    1:       sheet->GetOwningDocument(*getter_AddRefs(document));
    1:       if (document) {
    1:         NS_ADDREF(*aCSSLoader = document->CSSLoader());
    1:       }
    1:     }
    1:   }
    1:   // XXXldb Why bother if |mRule| is null?
    1:   if (*aCSSLoader) {
    1:     result = (*aCSSLoader)->GetParserFor(nsnull, aCSSParser);
    1:   } else {
    1:     result = NS_NewCSSParser(aCSSParser);
    1:   }
    1: 
 1036:   if (NS_SUCCEEDED(result) && !*aSheetPrincipal) {
 1036:     result = CallCreateInstance("@mozilla.org/nullprincipal;1",
 1036:                                 aSheetPrincipal);
 1036:   }
 1036: 
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: DOMCSSDeclarationImpl::GetParentRule(nsIDOMCSSRule **aParent)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aParent);
    1: 
    1:   if (!mRule) {
    1:     *aParent = nsnull;
    1:     return NS_OK;
    1:   }
    1: 
    1:   return mRule->GetDOMRule(aParent);
    1: }
    1: 
    1: nsresult
    1: DOMCSSDeclarationImpl::DeclarationChanged()
    1: {
    1:   NS_PRECONDITION(mRule,
    1:          "can only be called when |GetCSSDeclaration| returned a declaration");
    1: 
    1:   nsCOMPtr<nsIDocument> owningDoc;
    1:   nsCOMPtr<nsIStyleSheet> sheet;
    1:   mRule->GetStyleSheet(*getter_AddRefs(sheet));
    1:   if (sheet) {
    1:     sheet->GetOwningDocument(*getter_AddRefs(owningDoc));
    1:   }
    1: 
    1:   mozAutoDocUpdate updateBatch(owningDoc, UPDATE_STYLE, PR_TRUE);
    1: 
    1:   nsCOMPtr<nsICSSStyleRule> oldRule = mRule;
    1:   mRule = oldRule->DeclarationChanged(PR_TRUE).get();
    1:   if (!mRule)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   nsrefcnt cnt = mRule->Release();
    1:   if (cnt == 0) {
    1:     NS_NOTREACHED("container didn't take ownership");
    1:     mRule = nsnull;
    1:     return NS_ERROR_UNEXPECTED;
    1:   }
    1: 
    1:   if (owningDoc) {
    1:     owningDoc->StyleRuleChanged(sheet, oldRule, mRule);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: DOMCSSStyleRuleImpl::DOMCSSStyleRuleImpl(nsICSSStyleRule* aRule)
    1:   : mDOMDeclaration(aRule)
    1: {
    1: }
    1: 
    1: DOMCSSStyleRuleImpl::~DOMCSSStyleRuleImpl()
    1: {
    1: }
    1: 
    1: NS_INTERFACE_MAP_BEGIN(DOMCSSStyleRuleImpl)
    1:   NS_INTERFACE_MAP_ENTRY(nsICSSStyleRuleDOMWrapper)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSStyleRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsISupports)
    1:   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(CSSStyleRule)
    1: NS_INTERFACE_MAP_END
    1: 
    1: NS_IMPL_ADDREF(DOMCSSStyleRuleImpl)
    1: NS_IMPL_RELEASE(DOMCSSStyleRuleImpl)
    1: 
    1: NS_IMETHODIMP    
    1: DOMCSSStyleRuleImpl::GetType(PRUint16* aType)
    1: {
    1:   *aType = nsIDOMCSSRule::STYLE_RULE;
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP    
    1: DOMCSSStyleRuleImpl::GetCssText(nsAString& aCssText)
    1: {
    1:   if (!Rule()) {
    1:     aCssText.Truncate();
    1:     return NS_OK;
    1:   }
    1:   return Rule()->GetCssText(aCssText);
    1: }
    1: 
    1: NS_IMETHODIMP    
    1: DOMCSSStyleRuleImpl::SetCssText(const nsAString& aCssText)
    1: {
    1:   if (!Rule()) {
    1:     return NS_OK;
    1:   }
    1:   return Rule()->SetCssText(aCssText);
    1: }
    1: 
    1: NS_IMETHODIMP    
    1: DOMCSSStyleRuleImpl::GetParentStyleSheet(nsIDOMCSSStyleSheet** aSheet)
    1: {
    1:   if (!Rule()) {
    1:     *aSheet = nsnull;
    1:     return NS_OK;
    1:   }
    1:   nsCOMPtr<nsICSSStyleSheet> sheet;
    1:   Rule()->GetParentStyleSheet(getter_AddRefs(sheet));
    1:   if (!sheet) {
    1:     *aSheet = nsnull;
    1:     return NS_OK;
    1:   }
    1:   return CallQueryInterface(sheet, aSheet);
    1: }
    1: 
    1: NS_IMETHODIMP    
    1: DOMCSSStyleRuleImpl::GetParentRule(nsIDOMCSSRule** aParentRule)
    1: {
    1:   if (!Rule()) {
    1:     *aParentRule = nsnull;
    1:     return NS_OK;
    1:   }
    1:   nsCOMPtr<nsICSSGroupRule> rule;
    1:   Rule()->GetParentRule(getter_AddRefs(rule));
    1:   if (!rule) {
    1:     *aParentRule = nsnull;
    1:     return NS_OK;
    1:   }
    1:   return rule->GetDOMRule(aParentRule);
    1: }
    1: 
    1: NS_IMETHODIMP    
    1: DOMCSSStyleRuleImpl::GetSelectorText(nsAString& aSelectorText)
    1: {
    1:   if (!Rule()) {
    1:     aSelectorText.Truncate();
    1:     return NS_OK;
    1:   }
    1:   return Rule()->GetSelectorText(aSelectorText);
    1: }
    1: 
    1: NS_IMETHODIMP    
    1: DOMCSSStyleRuleImpl::SetSelectorText(const nsAString& aSelectorText)
    1: {
    1:   if (!Rule()) {
    1:     return NS_OK;
    1:   }
    1:   return Rule()->SetSelectorText(aSelectorText);
    1: }
    1: 
    1: NS_IMETHODIMP    
    1: DOMCSSStyleRuleImpl::GetStyle(nsIDOMCSSStyleDeclaration** aStyle)
    1: {
    1:   *aStyle = &mDOMDeclaration;
    1:   NS_ADDREF(*aStyle);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: DOMCSSStyleRuleImpl::GetCSSStyleRule(nsICSSStyleRule **aResult)
    1: {
    1:   *aResult = Rule();
    1:   NS_IF_ADDREF(*aResult);
    1:   return NS_OK;
    1: }
    1: 
    1: // -- nsCSSStyleRule -------------------------------
    1: 
    1: class CSSStyleRuleImpl : public nsCSSRule,
    1:                          public nsICSSStyleRule
    1: {
    1: public:
    1:   CSSStyleRuleImpl(nsCSSSelectorList* aSelector,
    1:                    nsCSSDeclaration *aDeclaration);
    1: private:
    1:   // for |Clone|
    1:   CSSStyleRuleImpl(const CSSStyleRuleImpl& aCopy); 
    1:   // for |DeclarationChanged|
    1:   CSSStyleRuleImpl(CSSStyleRuleImpl& aCopy,
    1:                    nsCSSDeclaration *aDeclaration); 
    1: public:
    1: 
    1:   NS_DECL_ISUPPORTS_INHERITED
    1: 
    1:   virtual nsCSSSelectorList* Selector(void);
    1: 
    1:   virtual PRUint32 GetLineNumber(void) const;
    1:   virtual void SetLineNumber(PRUint32 aLineNumber);
    1: 
    1:   virtual nsCSSDeclaration* GetDeclaration(void) const;
    1: 
    1:   virtual already_AddRefed<nsIStyleRule> GetImportantRule(void);
    1: 
    1:   NS_IMETHOD GetStyleSheet(nsIStyleSheet*& aSheet) const;
    1:   NS_IMETHOD SetStyleSheet(nsICSSStyleSheet* aSheet);
    1:   
    1:   NS_IMETHOD SetParentRule(nsICSSGroupRule* aRule);
    1: 
    1:   virtual nsresult GetCssText(nsAString& aCssText);
    1:   virtual nsresult SetCssText(const nsAString& aCssText);
    1:   virtual nsresult GetParentStyleSheet(nsICSSStyleSheet** aSheet);
    1:   virtual nsresult GetParentRule(nsICSSGroupRule** aParentRule);
    1:   virtual nsresult GetSelectorText(nsAString& aSelectorText);
    1:   virtual nsresult SetSelectorText(const nsAString& aSelectorText);
    1: 
    1:   NS_IMETHOD GetType(PRInt32& aType) const;
    1:   NS_IMETHOD Clone(nsICSSRule*& aClone) const;
    1: 
    1:   NS_IMETHOD GetDOMRule(nsIDOMCSSRule** aDOMRule);
    1: 
    1:   virtual already_AddRefed<nsICSSStyleRule>
    1:     DeclarationChanged(PRBool aHandleContainer);
    1: 
    1:   // The new mapping function.
    1:   NS_IMETHOD MapRuleInfoInto(nsRuleData* aRuleData);
    1: 
    1: #ifdef DEBUG
    1:   NS_IMETHOD List(FILE* out = stdout, PRInt32 aIndent = 0) const;
    1: #endif
    1: 
    1: private: 
    1:   // These are not supported and are not implemented! 
    1:   CSSStyleRuleImpl& operator=(const CSSStyleRuleImpl& aCopy); 
    1: 
    1: protected:
    1:   virtual ~CSSStyleRuleImpl(void);
    1: 
    1: protected:
    1:   nsCSSSelectorList*      mSelector; // null for style attribute
    1:   nsCSSDeclaration*       mDeclaration;
    1:   CSSImportantRule*       mImportantRule;
    1:   DOMCSSStyleRuleImpl*    mDOMRule;                          
    1:   PRUint32                mLineNumber;
    1: };
    1: 
    1: CSSStyleRuleImpl::CSSStyleRuleImpl(nsCSSSelectorList* aSelector,
    1:                                    nsCSSDeclaration* aDeclaration)
    1:   : nsCSSRule(),
    1:     mSelector(aSelector),
    1:     mDeclaration(aDeclaration), 
    1:     mImportantRule(nsnull),
    1:     mDOMRule(nsnull),
    1:     mLineNumber(0)
    1: {
    1:   mDeclaration->AddRef();
    1: }
    1: 
    1: // for |Clone|
    1: CSSStyleRuleImpl::CSSStyleRuleImpl(const CSSStyleRuleImpl& aCopy)
    1:   : nsCSSRule(aCopy),
    1:     mSelector(aCopy.mSelector ? aCopy.mSelector->Clone() : nsnull),
    1:     mDeclaration(aCopy.mDeclaration->Clone()),
    1:     mImportantRule(nsnull),
    1:     mDOMRule(nsnull),
    1:     mLineNumber(aCopy.mLineNumber)
    1: {
    1:   if (mDeclaration)
    1:     mDeclaration->AddRef();
    1:   // rest is constructed lazily on existing data
    1: }
    1: 
    1: // for |DeclarationChanged|
    1: CSSStyleRuleImpl::CSSStyleRuleImpl(CSSStyleRuleImpl& aCopy,
    1:                                    nsCSSDeclaration* aDeclaration)
    1:   : nsCSSRule(aCopy),
    1:     mSelector(aCopy.mSelector),
    1:     mDeclaration(aDeclaration),
    1:     mImportantRule(nsnull),
    1:     mDOMRule(aCopy.mDOMRule),
    1:     mLineNumber(aCopy.mLineNumber)
    1: {
    1:   // The DOM rule is replacing |aCopy| with |this|, so transfer
    1:   // the reverse pointer as well (and transfer ownership).
    1:   aCopy.mDOMRule = nsnull;
    1: 
    1:   NS_ASSERTION(aDeclaration == aCopy.mDeclaration, "declaration mismatch");
    1:   // Transfer ownership of selector and declaration:
    1:   aCopy.mSelector = nsnull;
    1: #if 0
    1:   aCopy.mDeclaration = nsnull;
    1: #else
    1:   // We ought to be able to transfer ownership of the selector and the
    1:   // declaration since this rule should now be unused, but unfortunately
    1:   // SetInlineStyleRule might use it before setting the new rule (see
    1:   // stack in bug 209575).  So leave the declaration pointer on the old
    1:   // rule.
    1:   mDeclaration->AddRef();
    1: #endif
    1: }
    1: 
    1: 
    1: CSSStyleRuleImpl::~CSSStyleRuleImpl(void)
    1: {
    1:   if (mSelector) {
    1:     delete mSelector;
    1:     mSelector = nsnull;
    1:   }
    1:   if (nsnull != mDeclaration) {
    1:     mDeclaration->Release();
    1:     mDeclaration = nsnull;
    1:   }
    1:   if (nsnull != mImportantRule) {
    1:     NS_RELEASE(mImportantRule);
    1:     mImportantRule = nsnull;
    1:   }
    1:   if (mDOMRule) {
    1:     mDOMRule->DOMDeclaration()->DropReference();
    1:     NS_RELEASE(mDOMRule);
    1:   }
    1: }
    1: 
    1: // QueryInterface implementation for CSSStyleRuleImpl
    1: NS_INTERFACE_MAP_BEGIN(CSSStyleRuleImpl)
    1:   NS_INTERFACE_MAP_ENTRY(nsICSSStyleRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsICSSRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIStyleRule)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsICSSStyleRule)
    1: NS_INTERFACE_MAP_END
    1: 
    1: NS_IMPL_ADDREF_INHERITED(CSSStyleRuleImpl, nsCSSRule)
    1: NS_IMPL_RELEASE_INHERITED(CSSStyleRuleImpl, nsCSSRule)
    1: 
    1: nsCSSSelectorList* CSSStyleRuleImpl::Selector(void)
    1: {
    1:   return mSelector;
    1: }
    1: 
    1: PRUint32 CSSStyleRuleImpl::GetLineNumber(void) const
    1: {
    1:   return mLineNumber;
    1: }
    1: 
    1: void CSSStyleRuleImpl::SetLineNumber(PRUint32 aLineNumber)
    1: {
    1:   mLineNumber = aLineNumber;
    1: }
    1: 
    1: nsCSSDeclaration* CSSStyleRuleImpl::GetDeclaration(void) const
    1: {
    1:   return mDeclaration;
    1: }
    1: 
    1: already_AddRefed<nsIStyleRule> CSSStyleRuleImpl::GetImportantRule(void)
    1: {
    1:   if (!mDeclaration->HasImportantData()) {
    1:     NS_ASSERTION(!mImportantRule, "immutable, so should be no important rule");
    1:     return nsnull;
    1:   }
    1: 
    1:   if (!mImportantRule) {
    1:     mImportantRule = new CSSImportantRule(mDeclaration);
    1:     if (!mImportantRule)
    1:       return nsnull;
    1:     NS_ADDREF(mImportantRule);
    1:   }
    1:   NS_ADDREF(mImportantRule);
    1:   return mImportantRule;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: CSSStyleRuleImpl::GetStyleSheet(nsIStyleSheet*& aSheet) const
    1: {
    1: // XXX What about inner, etc.
    1:   return nsCSSRule::GetStyleSheet(aSheet);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: CSSStyleRuleImpl::SetStyleSheet(nsICSSStyleSheet* aSheet)
    1: {
    1:   return nsCSSRule::SetStyleSheet(aSheet);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: CSSStyleRuleImpl::SetParentRule(nsICSSGroupRule* aRule)
    1: {
    1:   return nsCSSRule::SetParentRule(aRule);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: CSSStyleRuleImpl::GetType(PRInt32& aType) const
    1: {
    1:   aType = nsICSSRule::STYLE_RULE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: CSSStyleRuleImpl::Clone(nsICSSRule*& aClone) const
    1: {
    1:   CSSStyleRuleImpl* clone = new CSSStyleRuleImpl(*this);
    1:   if (!clone || !clone->mDeclaration || (!clone->mSelector != !mSelector)) {
    1:     delete clone;
    1:     aClone = nsnull;
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   return CallQueryInterface(clone, &aClone);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: CSSStyleRuleImpl::GetDOMRule(nsIDOMCSSRule** aDOMRule)
    1: {
    1:   if (!mSheet) {
    1:     // inline style rules aren't supposed to have a DOM rule object, only
    1:     // a declaration.
    1:     *aDOMRule = nsnull;
    1:     return NS_OK;
    1:   }
    1:   if (!mDOMRule) {
    1:     mDOMRule = new DOMCSSStyleRuleImpl(this);
    1:     if (!mDOMRule) {
    1:       *aDOMRule = nsnull;
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:     NS_ADDREF(mDOMRule);
    1:   }
    1:   *aDOMRule = mDOMRule;
    1:   NS_ADDREF(*aDOMRule);
    1:   return NS_OK;
    1: }
    1: 
    1: /* virtual */ already_AddRefed<nsICSSStyleRule>
    1: CSSStyleRuleImpl::DeclarationChanged(PRBool aHandleContainer)
    1: {
    1:   CSSStyleRuleImpl* clone = new CSSStyleRuleImpl(*this, mDeclaration);
    1:   if (!clone) {
    1:     return nsnull;
    1:   }
    1: 
    1:   NS_ADDREF(clone); // for return
    1: 
    1:   if (aHandleContainer) {
    1:     NS_ASSERTION(mSheet, "rule must be in a sheet");
    1:     if (mParentRule) {
    1:       mSheet->ReplaceRuleInGroup(mParentRule, this, clone);
    1:     } else {
    1:       mSheet->ReplaceStyleRule(this, clone);
    1:     }
    1:   }
    1: 
    1:   return clone;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: CSSStyleRuleImpl::MapRuleInfoInto(nsRuleData* aRuleData)
    1: {
    1:   return mDeclaration->MapRuleInfoInto(aRuleData);
    1: }
    1: 
    1: #ifdef DEBUG
    1: NS_IMETHODIMP
    1: CSSStyleRuleImpl::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   // Indent
    1:   for (PRInt32 index = aIndent; --index >= 0; ) fputs("  ", out);
    1: 
    1:   nsAutoString buffer;
    1:   if (mSelector)
    1:     mSelector->ToString(buffer, mSheet);
    1: 
    1:   buffer.AppendLiteral(" ");
    1:   fputs(NS_LossyConvertUTF16toASCII(buffer).get(), out);
    1:   if (nsnull != mDeclaration) {
    1:     mDeclaration->List(out);
    1:   }
    1:   else {
    1:     fputs("{ null declaration }", out);
    1:   }
    1:   fputs("\n", out);
    1: 
    1:   return NS_OK;
    1: }
    1: #endif
    1: 
    1: /* virtual */ nsresult
    1: CSSStyleRuleImpl::GetCssText(nsAString& aCssText)
    1: {
    1:   if (mSelector) {
    1:     mSelector->ToString(aCssText, mSheet);
    1:     aCssText.Append(PRUnichar(' '));
    1:   }
    1:   aCssText.Append(PRUnichar('{'));
    1:   aCssText.Append(PRUnichar(' '));
    1:   if (mDeclaration)
    1:   {
    1:     nsAutoString   tempString;
    1:     mDeclaration->ToString( tempString );
    1:     aCssText.Append( tempString );
    1:   }
    1:   aCssText.Append(PRUnichar(' '));
    1:   aCssText.Append(PRUnichar('}'));
    1:   return NS_OK;
    1: }
    1: 
    1: /* virtual */ nsresult    
    1: CSSStyleRuleImpl::SetCssText(const nsAString& aCssText)
    1: {
    1:   // XXX TBI - need to re-parse rule & declaration
    1:   return NS_OK;
    1: }
    1: 
    1: /* virtual */ nsresult    
    1: CSSStyleRuleImpl::GetParentStyleSheet(nsICSSStyleSheet** aSheet)
    1: {
    1:   *aSheet = mSheet;
    1:   NS_IF_ADDREF(*aSheet);
    1:   return NS_OK;
    1: }
    1: 
    1: /* virtual */ nsresult    
    1: CSSStyleRuleImpl::GetParentRule(nsICSSGroupRule** aParentRule)
    1: {
    1:   *aParentRule = mParentRule;
    1:   NS_IF_ADDREF(*aParentRule);
    1:   return NS_OK;
    1: }
    1: 
    1: /* virtual */ nsresult    
    1: CSSStyleRuleImpl::GetSelectorText(nsAString& aSelectorText)
    1: {
    1:   if (mSelector)
    1:     mSelector->ToString(aSelectorText, mSheet);
    1:   else
    1:     aSelectorText.Truncate();
    1:   return NS_OK;
    1: }
    1: 
    1: /* virtual */ nsresult    
    1: CSSStyleRuleImpl::SetSelectorText(const nsAString& aSelectorText)
    1: {
    1:   // XXX TBI - get a parser and re-parse the selectors, 
    1:   // XXX then need to re-compute the cascade
    1:   // XXX and dirty sheet
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: NS_NewCSSStyleRule(nsICSSStyleRule** aInstancePtrResult,
    1:                    nsCSSSelectorList* aSelector,
    1:                    nsCSSDeclaration* aDeclaration)
    1: {
    1:   NS_PRECONDITION(aDeclaration, "must have a declaration");
    1:   CSSStyleRuleImpl *it = new CSSStyleRuleImpl(aSelector, aDeclaration);
    1:   if (!it) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   return CallQueryInterface(it, aInstancePtrResult);
    1: }
