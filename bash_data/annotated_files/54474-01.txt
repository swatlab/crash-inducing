    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 2106: /* vim: set ts=2 sw=2 et tw=78: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * The Mozilla Foundation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Johnny Stenback <jst@mozilla.org> (original author)
    1:  *   Brendan Eich <brendan@mozilla.org>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "xpcprivate.h"
    1: #include "XPCNativeWrapper.h"
12582: #include "XPCWrapper.h"
    1: #include "jsdbgapi.h"
    1: 
18907: static JSBool
48470: XPC_NW_AddProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
    1: 
18907: static JSBool
48470: XPC_NW_DelProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
    1: 
18907: static JSBool
48470: XPC_NW_GetProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
    1: 
18907: static JSBool
48470: XPC_NW_SetProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
    1: 
18907: static JSBool
    1: XPC_NW_Enumerate(JSContext *cx, JSObject *obj);
    1: 
18907: static JSBool
48470: XPC_NW_NewResolve(JSContext *cx, JSObject *obj, jsid id, uintN flags,
    1:                   JSObject **objp);
    1: 
18907: static JSBool
    1: XPC_NW_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp);
    1: 
18907: static void
    1: XPC_NW_Finalize(JSContext *cx, JSObject *obj);
    1: 
18907: static JSBool
48470: XPC_NW_CheckAccess(JSContext *cx, JSObject *obj, jsid id,
    1:                    JSAccessMode mode, jsval *vp);
    1: 
18907: static JSBool
53557: XPC_NW_Call(JSContext *cx, uintN argc, jsval *vp);
    1: 
18907: static JSBool
53557: XPC_NW_Construct(JSContext *cx, uintN argc, jsval *vp);
    1: 
18907: static JSBool
48470: XPC_NW_HasInstance(JSContext *cx, JSObject *obj, const jsval *valp, JSBool *bp);
    1: 
18907: static void
 1025: XPC_NW_Trace(JSTracer *trc, JSObject *obj);
    1: 
18907: static JSBool
48470: XPC_NW_Equality(JSContext *cx, JSObject *obj, const jsval *valp, JSBool *bp);
    1: 
33307: static JSObject *
33307: XPC_NW_Iterator(JSContext *cx, JSObject *obj, JSBool keysonly);
33307: 
18907: static JSBool
53557: XPC_NW_FunctionWrapper(JSContext *cx, uintN argc, jsval *vp);
    1: 
36309: using namespace XPCWrapper;
36309: 
36309: // If this flag is set, then this XPCNativeWrapper is *not* the implicit
36309: // wrapper stored in XPCWrappedNative::mWrapperWord. These wrappers may
36309: // be exposed to content script and because they are not shared, they do
36309: // not have expando properties set on implicit native wrappers.
43198: static const PRUint32 FLAG_EXPLICIT = XPCWrapper::LAST_FLAG << 1;
36309: 
36309: namespace XPCNativeWrapper { namespace internal {
36309: 
    1: // JS class for XPCNativeWrapper (and this doubles as the constructor
    1: // for XPCNativeWrapper for the moment too...)
    1: 
48622: js::Class NW_NoCall_Class = {
48622:     "XPCNativeWrapper",
40310:     JSCLASS_HAS_PRIVATE | JSCLASS_PRIVATE_IS_NSISUPPORTS |
40310:     // Our one reserved slot holds a jsint of flag bits
40310:     JSCLASS_NEW_RESOLVE | JSCLASS_HAS_RESERVED_SLOTS(1) |
48622:     JSCLASS_MARK_IS_TRACE | JSCLASS_CONSTRUCT_PROTOTYPE,
48622:     js::Valueify(XPC_NW_AddProperty),
48622:     js::Valueify(XPC_NW_DelProperty),
48622:     js::Valueify(XPC_NW_GetProperty),
48622:     js::Valueify(XPC_NW_SetProperty),
48622:     XPC_NW_Enumerate,
48622:     (JSResolveOp)XPC_NW_NewResolve,
48622:     js::Valueify(XPC_NW_Convert),
48622:     XPC_NW_Finalize,
48622:     nsnull,   // reserved0
48622:     js::Valueify(XPC_NW_CheckAccess),
48622:     nsnull,   // call
48622:     js::Valueify(XPC_NW_Construct),
48622:     nsnull,   // xdrObject
48622:     js::Valueify(XPC_NW_HasInstance),
48622:     JS_CLASS_TRACE(XPC_NW_Trace),
40310: 
48622:     // ClassExtension
48622:     {
48622:       js::Valueify(XPC_NW_Equality),
40310:       nsnull, // outerObject
40310:       nsnull, // innerObject
40310:       XPC_NW_Iterator,
40310:       nsnull, // wrappedObject
48622:     }
40310: };
40310: 
48622: js::Class NW_Call_Class = {
48622:     "XPCNativeWrapper",
    1:     JSCLASS_HAS_PRIVATE | JSCLASS_PRIVATE_IS_NSISUPPORTS |
    1:     // Our one reserved slot holds a jsint of flag bits
    1:     JSCLASS_NEW_RESOLVE | JSCLASS_HAS_RESERVED_SLOTS(1) |
48622:     JSCLASS_MARK_IS_TRACE | JSCLASS_CONSTRUCT_PROTOTYPE,
48622:     js::Valueify(XPC_NW_AddProperty),
48622:     js::Valueify(XPC_NW_DelProperty),
48622:     js::Valueify(XPC_NW_GetProperty),
48622:     js::Valueify(XPC_NW_SetProperty),
48622:     XPC_NW_Enumerate,
48622:     (JSResolveOp)XPC_NW_NewResolve,
48622:     js::Valueify(XPC_NW_Convert),
48622:     XPC_NW_Finalize,
48622:     nsnull,   // reserved0
48622:     js::Valueify(XPC_NW_CheckAccess),
48622:     js::Valueify(XPC_NW_Call),
48622:     js::Valueify(XPC_NW_Construct),
48622:     nsnull,   // xdrObject
48622:     js::Valueify(XPC_NW_HasInstance),
48622:     JS_CLASS_TRACE(XPC_NW_Trace),
33307: 
48622:     // ClassExtension
48622:     {
48622:       js::Valueify(XPC_NW_Equality),
33307:       nsnull, // outerObject
33307:       nsnull, // innerObject
33307:       XPC_NW_Iterator,
33307:       nsnull, // wrappedObject
48622:     }
    1: };
    1: 
36309: } // namespace internal
36309: 
36309: JSBool
36309: GetWrappedNative(JSContext *cx, JSObject *obj,
36309:                  XPCWrappedNative **aWrappedNative)
36309: {
36309:   XPCWrappedNative *wn = static_cast<XPCWrappedNative *>(xpc_GetJSPrivate(obj));
36309:   *aWrappedNative = wn;
36309:   if (!wn) {
36309:     return JS_TRUE;
36309:   }
36309: 
36309:   nsIScriptSecurityManager *ssm = GetSecurityManager();
36309:   if (!ssm) {
36309:     return JS_TRUE;
36309:   }
36309: 
36309:   nsIPrincipal *subjectPrincipal = ssm->GetCxSubjectPrincipal(cx);
36309:   if (!subjectPrincipal) {
36309:     return JS_TRUE;
36309:   }
36309: 
36309:   XPCWrappedNativeScope *scope = wn->GetScope();
36309:   nsIPrincipal *objectPrincipal = scope->GetPrincipal();
36309: 
36309:   PRBool subsumes;
36309:   nsresult rv = subjectPrincipal->Subsumes(objectPrincipal, &subsumes);
36309:   if (NS_FAILED(rv) || !subsumes) {
36309:     PRBool isPrivileged;
36309:     rv = ssm->IsCapabilityEnabled("UniversalXPConnect", &isPrivileged);
36309:     return NS_SUCCEEDED(rv) && isPrivileged;
36309:   }
36309: 
36309:   return JS_TRUE;
36309: }
36309: 
36309: JSBool
36309: WrapFunction(JSContext* cx, JSObject* funobj, jsval *rval)
36309: {
36309:   // If funobj is already a wrapped function, just return it.
36309:   if (JS_GetFunctionNative(cx,
36309:                            JS_ValueToFunction(cx, OBJECT_TO_JSVAL(funobj))) ==
36309:       XPC_NW_FunctionWrapper) {
36309:     *rval = OBJECT_TO_JSVAL(funobj);
36309:     return JS_TRUE;
36309:   }
36309: 
36309:   // Ensure that we've been called from JS. Native code should extract
36309:   // the wrapped native and deal with that directly.
36309:   // XXX Can we simply trust |cx| here?
36309:   JSStackFrame *iterator = nsnull;
36309:   if (!::JS_FrameIterator(cx, &iterator)) {
36309:     ::JS_ReportError(cx, "XPCNativeWrappers must be used from script");
36309:     return JS_FALSE;
36309:   }
36309: 
36309:   // Create a new function that'll call our given function.  This new
36309:   // function's parent will be the original function and that's how we
36309:   // get the right thing to call when this function is called.
36309:   // Note that we pass nsnull as the nominal parent so that we'll inherit
36309:   // our caller's Function.prototype.
36309:   JSFunction *funWrapper =
36309:     ::JS_NewFunction(cx, XPC_NW_FunctionWrapper, 0, 0, nsnull,
36309:                      "XPCNativeWrapper function wrapper");
36309:   if (!funWrapper) {
36309:     return JS_FALSE;
36309:   }
36309: 
36309:   JSObject* funWrapperObj = ::JS_GetFunctionObject(funWrapper);
36309:   ::JS_SetParent(cx, funWrapperObj, funobj);
36309:   *rval = OBJECT_TO_JSVAL(funWrapperObj);
36309: 
36309:   JS_SetReservedSlot(cx, funWrapperObj, eAllAccessSlot, JSVAL_FALSE);
36309: 
36309:   return JS_TRUE;
36309: }
36309: 
36309: JSBool
43198: RewrapValue(JSContext *cx, JSObject *obj, jsval v, jsval *rval)
36309: {
36309:   NS_ASSERTION(XPCNativeWrapper::IsNativeWrapper(obj),
36309:                "Unexpected object");
36309: 
43198:   if (JSVAL_IS_PRIMITIVE(v)) {
43198:     *rval = v;
43198:     return JS_TRUE;
43198:   }
36309: 
43198:   JSObject* nativeObj = JSVAL_TO_OBJECT(v);
43198: 
43198:   // Wrap function objects specially.
43198:   if (JS_ObjectIsFunction(cx, nativeObj)) {
36309:     return WrapFunction(cx, nativeObj, rval);
36309:   }
36309: 
39406:   JSObject *scope = JS_GetScopeChain(cx);
39406:   if (!scope) {
36309:     return JS_FALSE;
36309:   }
36309: 
43198:   jsval flags;
43198:   ::JS_GetReservedSlot(cx, obj, 0, &flags);
39406:   WrapperType type = HAS_FLAGS(flags, FLAG_EXPLICIT)
39406:                      ? XPCNW_EXPLICIT : XPCNW_IMPLICIT;
43198:   return RewrapObject(cx, JS_GetGlobalForObject(cx, scope),
43198:                       nativeObj, type, rval);
36309: }
36309: 
36309: } // namespace XPCNativeWrapper
36309: 
36309: using namespace XPCNativeWrapper;
36309: 
18907: static JSBool
53557: XPC_NW_toString(JSContext *cx, uintN argc, jsval *vp);
    1: 
    1: static inline
    1: JSBool
    1: ThrowException(nsresult ex, JSContext *cx)
    1: {
    1:   XPCThrower::Throw(ex, cx);
    1: 
    1:   return JS_FALSE;
    1: }
    1: 
 3162: static inline
 3162: JSBool
25743: EnsureLegalActivity(JSContext *cx, JSObject *obj,
48470:                     jsid id = JSID_VOID, PRUint32 accessType = 0)
 3162: {
36309:   nsIScriptSecurityManager *ssm = GetSecurityManager();
24010:   if (!ssm) {
24010:     // If there's no security manager, then we're not running in a browser
24010:     // context: allow access.
24010:     return JS_TRUE;
24010:   }
24010: 
24010:   JSStackFrame *fp;
24010:   nsIPrincipal *subjectPrincipal = ssm->GetCxSubjectPrincipalAndFrame(cx, &fp);
24010:   if (!subjectPrincipal || !fp) {
34220:     // We must allow access if there is no code running.
31207:     return JS_TRUE;
31207:   }
31207: 
34220:   PRBool isSystem;
34220:   if (NS_SUCCEEDED(ssm->IsSystemPrincipal(subjectPrincipal, &isSystem)) &&
34220:       isSystem) {
34220:     // Chrome code is running.
24010:     return JS_TRUE;
24010:   }
24010: 
39405:   jsval flags;
39405: 
39405:   JS_GetReservedSlot(cx, obj, sFlagsSlot, &flags);
39405:   if (HAS_FLAGS(flags, FLAG_SOW) && !SystemOnlyWrapper::CheckFilename(cx, id, fp)) {
39405:     return JS_FALSE;
39405:   }
39405: 
24010:   // We're in unprivileged code, ensure that we're allowed to access the
24010:   // underlying object.
24010:   XPCWrappedNative *wn = XPCNativeWrapper::SafeGetWrappedNative(obj);
24010:   if (wn) {
24010:     nsIPrincipal *objectPrincipal = wn->GetScope()->GetPrincipal();
24010:     PRBool subsumes;
24010:     if (NS_FAILED(subjectPrincipal->Subsumes(objectPrincipal, &subsumes)) ||
24010:         !subsumes) {
34220:       // This might be chrome code or content code with UniversalXPConnect.
34220:       PRBool isPrivileged = PR_FALSE;
34220:       nsresult rv =
34220:         ssm->IsCapabilityEnabled("UniversalXPConnect", &isPrivileged);
34220:       if (NS_SUCCEEDED(rv) && isPrivileged) {
34220:         return JS_TRUE;
34220:       }
25743: 
25743:       JSObject* flatObj;
48470:       if (!JSID_IS_VOID(id) &&
36309:           (accessType & (sSecMgrSetProp | sSecMgrGetProp)) &&
25743:           (flatObj = wn->GetFlatJSObject())) {
25743:         rv = ssm->CheckPropertyAccess(cx, flatObj,
40410:                                       flatObj->getClass()->name,
25743:                                       id, accessType);
25743:         return NS_SUCCEEDED(rv);
25743:       }
25743: 
24010:       return ThrowException(NS_ERROR_XPC_SECURITY_MANAGER_VETO, cx);
24010:     }
24010:   }
24010: 
39405: #ifdef DEBUG
24010:   // The underlying object is accessible, but this might be the wrong
24010:   // type of wrapper to access it through.
 3162: 
 3162:   if (HAS_FLAGS(flags, FLAG_EXPLICIT)) {
 3162:     // Can't make any assertions about the owner of this wrapper.
 3162:     return JS_TRUE;
 3162:   }
 3162: 
24010:   JSScript *script = JS_GetFrameScript(cx, fp);
35445:   if (!script) {
35445:     // This is likely a SJOW around an XPCNativeWrapper. We don't know
35445:     // who is accessing us, but given the TODO above, allow access.
35445:     return JS_TRUE;
35445:   }
35445: 
24010:   uint32 fileFlags = JS_GetScriptFilenameFlags(script);
24010:   if (fileFlags == JSFILENAME_NULL || (fileFlags & JSFILENAME_SYSTEM)) {
 3162:     // We expect implicit native wrappers in system files.
 3162:     return JS_TRUE;
 3162:   }
 3162: 
 3162:   // Otherwise, we're looking at a non-system file with a handle on an
 3163:   // implicit wrapper. This is a bug! Deny access.
50575:   NS_WARNING("Implicit native wrapper in content code");
50575:   return JS_TRUE;
39405: #else
39405:   return JS_TRUE;
39405: #endif
39405: 
39405:   // NB: Watch for early returns in the ifdef DEBUG code above.
 3162: }
 3162: 
18907: static JSBool
48470: XPC_NW_AddProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
    1: {
26167:   JSPropertyDescriptor desc;
 9833: 
48470:   if (!JS_GetPropertyDescriptorById(cx, obj, id, JSRESOLVE_QUALIFIED,
26167:                                     &desc)) {
 9833:     return JS_FALSE;
 9833:   }
 9833: 
 9833:   // Do not allow scripted getters or setters on XPCNativeWrappers.
26167:   if (desc.attrs & (JSPROP_GETTER | JSPROP_SETTER)) {
 9833:     return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
 9833:   }
 9833: 
26167:   jsval flags = JSVAL_VOID;
26167:   JS_GetReservedSlot(cx, obj, 0, &flags);
25743:   // The purpose of XPC_NW_AddProperty is to wrap any object set on the
25743:   // XPCNativeWrapper by the wrapped object's scriptable helper, so bail
25743:   // here if the scriptable helper is not currently adding a property.
25743:   // See comment above #define FLAG_RESOLVING in XPCWrapper.h.
    1:   if (!HAS_FLAGS(flags, FLAG_RESOLVING)) {
    1:     return JS_TRUE;
    1:   }
    1: 
    1:   // Note: no need to protect *vp from GC here, since it's already in the slot
    1:   // on |obj|.
36309:   return EnsureLegalActivity(cx, obj, id, sSecMgrSetProp) &&
43198:          RewrapValue(cx, obj, *vp, vp);
    1: }
    1: 
18907: static JSBool
48470: XPC_NW_DelProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
    1: {
43200:   return EnsureLegalActivity(cx, obj);
    1: }
    1: 
18907: static JSBool
53557: XPC_NW_FunctionWrapper(JSContext *cx, uintN argc, jsval *vp)
    1: {
53557:   JSObject *obj = JS_THIS_OBJECT(cx, vp);
53557:   if (!obj)
53557:     return JS_FALSE;
53557: 
53557:   JSObject *funObj = JSVAL_TO_OBJECT(JS_CALLEE(cx, vp));
    1:   if (!::JS_ObjectIsFunction(cx, funObj)) {
    1:     obj = nsnull;
    1:   }
    1: 
10858:   while (obj && !XPCNativeWrapper::IsNativeWrapper(obj)) {
39928:     obj = obj->getProto();
    1:   }
    1: 
    1:   if (!obj) {
    1:     return ThrowException(NS_ERROR_UNEXPECTED, cx);
    1:   }
    1: 
    1:   // The real method we're going to call is the parent of this
    1:   // function's JSObject.
39930:   JSObject *methodToCallObj = funObj->getParent();
25743:   XPCWrappedNative* wrappedNative = nsnull;
    1: 
25743:   jsval isAllAccess;
36309:   if (::JS_GetReservedSlot(cx, funObj, eAllAccessSlot, &isAllAccess) &&
25743:       JSVAL_TO_BOOLEAN(isAllAccess)) {
25743:     wrappedNative = XPCNativeWrapper::SafeGetWrappedNative(obj);
25743:   } else if (!XPCNativeWrapper::GetWrappedNative(cx, obj, &wrappedNative)) {
25743:     wrappedNative = nsnull;
25743:   }
25743: 
25743:   if (!wrappedNative || !::JS_ObjectIsFunction(cx, methodToCallObj)) {
    1:     return ThrowException(NS_ERROR_UNEXPECTED, cx);
    1:   }
    1: 
    1:   jsval v;
    1:   if (!::JS_CallFunctionValue(cx, wrappedNative->GetFlatJSObject(),
53557:                               OBJECT_TO_JSVAL(methodToCallObj), argc,
53557:                               JS_ARGV(cx, vp), &v)) {
    1:     return JS_FALSE;
    1:   }
    1: 
    1:   XPCCallContext ccx(JS_CALLER, cx, obj);
    1: 
    1:   // Make sure v doesn't get collected while we're re-wrapping it.
    1:   AUTO_MARK_JSVAL(ccx, v);
    1: 
53557:   return RewrapValue(cx, obj, v, vp);
    1: }
    1: 
    1: static JSBool
36577: GetwrappedJSObject(JSContext *cx, JSObject *obj, jsval *vp)
36577: {
36577:   // If we're wrapping an untrusted content wrapper, then we should
36577:   // return a safe wrapper for the underlying native object. Otherwise,
36577:   // such a wrapper would be superfluous.
36577: 
36577:   nsIScriptSecurityManager *ssm = GetSecurityManager();
36577:   nsCOMPtr<nsIPrincipal> prin;
36577:   nsresult rv = ssm->GetObjectPrincipal(cx, obj, getter_AddRefs(prin));
36577:   if (NS_FAILED(rv)) {
36577:     return ThrowException(rv, cx);
36577:   }
36577: 
36577:   jsval v = OBJECT_TO_JSVAL(obj);
36577: 
36577:   PRBool isSystem;
36577:   if (NS_SUCCEEDED(ssm->IsSystemPrincipal(prin, &isSystem)) && isSystem) {
36577:     *vp = v;
36577:     return JS_TRUE;
36577:   }
36577: 
36577:   return XPCSafeJSObjectWrapper::WrapObject(cx, JS_GetScopeChain(cx), v, vp);
36577: }
36577: 
36577: static JSBool
48470: XPC_NW_GetOrSetProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp,
    1:                         JSBool aIsSet)
    1: {
    1:   // We don't deal with the following properties here.
48470:   if (id == GetRTIdByIndex(cx, XPCJSRuntime::IDX_PROTOTYPE) ||
48470:       id == GetRTIdByIndex(cx, XPCJSRuntime::IDX_TO_STRING)) {
    1:     return JS_TRUE;
    1:   }
    1: 
10858:   while (!XPCNativeWrapper::IsNativeWrapper(obj)) {
39928:     obj = obj->getProto();
    1:     if (!obj) {
    1:       return ThrowException(NS_ERROR_UNEXPECTED, cx);
    1:     }
    1:   }
    1: 
25743:   if (!EnsureLegalActivity(cx, obj, id,
36309:                            aIsSet ? sSecMgrSetProp : sSecMgrGetProp)) {
 3162:     return JS_FALSE;
 3162:   }
 3162: 
24010:   // Protected by EnsureLegalActivity.
24010:   XPCWrappedNative *wrappedNative = XPCNativeWrapper::SafeGetWrappedNative(obj);
    1: 
    1:   if (!wrappedNative) {
    1:     return ThrowException(NS_ERROR_INVALID_ARG, cx);
    1:   }
    1: 
    1:   JSObject *nativeObj = wrappedNative->GetFlatJSObject();
    1: 
    1:   if (!aIsSet &&
48470:       id == GetRTIdByIndex(cx, XPCJSRuntime::IDX_WRAPPED_JSOBJECT)) {
36577:     return GetwrappedJSObject(cx, nativeObj, vp);
    1:   }
    1: 
36309:   return GetOrSetNativeProperty(cx, obj, wrappedNative, id, vp, aIsSet,
36309:                                 JS_TRUE);
    1: }
    1: 
18907: static JSBool
48470: XPC_NW_GetProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
    1: {
    1:   return XPC_NW_GetOrSetProperty(cx, obj, id, vp, PR_FALSE);
    1: }
    1: 
18907: static JSBool
48470: XPC_NW_SetProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
    1: {
    1:   return XPC_NW_GetOrSetProperty(cx, obj, id, vp, PR_TRUE);
    1: }
    1: 
18907: static JSBool
    1: XPC_NW_Enumerate(JSContext *cx, JSObject *obj)
    1: {
    1:   // We are being notified of a for-in loop or similar operation on this
    1:   // XPCNativeWrapper, so forward to the correct high-level object hook,
    1:   // OBJ_ENUMERATE on the XPCWrappedNative's object, called via the
    1:   // JS_Enumerate API.  Then reflect properties named by the enumerated
    1:   // identifiers from the wrapped native to the native wrapper.
    1: 
 3162:   if (!EnsureLegalActivity(cx, obj)) {
 3162:     return JS_FALSE;
 3162:   }
 3162: 
24010:   // Protected by EnsureLegalActivity.
24010:   XPCWrappedNative *wn = XPCNativeWrapper::SafeGetWrappedNative(obj);
    1:   if (!wn) {
    1:     return JS_TRUE;
    1:   }
    1: 
36309:   return Enumerate(cx, obj, wn->GetFlatJSObject());
    1: }
    1: 
18907: static JSBool
48470: XPC_NW_NewResolve(JSContext *cx, JSObject *obj, jsid id, uintN flags,
    1:                   JSObject **objp)
    1: {
    1:   // No need to preserve on sets of wrappedJSObject or toString, since callers
    1:   // couldn't get at those values anyway.  Also, we always deal with
    1:   // wrappedJSObject and toString before looking at our scriptable hooks, so no
    1:   // need to mess with our flags yet.
48470:   if (id == GetRTIdByIndex(cx, XPCJSRuntime::IDX_WRAPPED_JSOBJECT)) {
    1:     return JS_TRUE;
    1:   }
    1: 
48470:   if (id == GetRTIdByIndex(cx, XPCJSRuntime::IDX_TO_STRING)) {
 8391:     *objp = obj;
25525: 
36309:     // See the comment in WrapFunction for why we create this function
25525:     // like this.
25525:     JSFunction *fun = JS_NewFunction(cx, XPC_NW_toString, 0, 0, nsnull,
25525:                                      "toString");
25525:     if (!fun) {
25525:       return JS_FALSE;
25525:     }
25525: 
25525:     JSObject *funobj = JS_GetFunctionObject(fun);
39930:     funobj->setParent(obj);
25525: 
25525:     return JS_DefineProperty(cx, obj, "toString", OBJECT_TO_JSVAL(funobj),
25525:                              nsnull, nsnull, 0);
 8391:   }
 8391: 
25743:   PRUint32 accessType =
36309:     (flags & JSRESOLVE_ASSIGNING) ? sSecMgrSetProp : sSecMgrGetProp;
25743:   if (!EnsureLegalActivity(cx, obj, id, accessType)) {
 3162:     return JS_FALSE;
 3162:   }
 3162: 
10858:   while (!XPCNativeWrapper::IsNativeWrapper(obj)) {
39928:     obj = obj->getProto();
    1:     if (!obj) {
    1:       return ThrowException(NS_ERROR_UNEXPECTED, cx);
    1:     }
    1:   }
    1: 
24010:   // Protected by EnsureLegalActivity.
24010:   XPCWrappedNative *wrappedNative = XPCNativeWrapper::SafeGetWrappedNative(obj);
    1: 
    1:   if (!wrappedNative) {
    1:     // No wrapped native, no properties.
    1: 
    1:     return JS_TRUE;
    1:   }
    1: 
36309:   return ResolveNativeProperty(cx, obj, wrappedNative->GetFlatJSObject(),
36309:                                wrappedNative, id, flags, objp, JS_TRUE);
    1: }
    1: 
18907: static JSBool
    1: XPC_NW_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
    1: {
43200:   return EnsureLegalActivity(cx, obj);
    1: }
    1: 
18907: static void
    1: XPC_NW_Finalize(JSContext *cx, JSObject *obj)
    1: {
    1:   // We must not use obj's private data here since it's likely that it
    1:   // has already been finalized.
20312:   XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    1: 
    1:   {
    1:     // scoped lock
    1:     XPCAutoLock lock(rt->GetMapLock());
    1:     rt->GetExplicitNativeWrapperMap()->Remove(obj);
    1:   }
    1: }
    1: 
18907: static JSBool
48470: XPC_NW_CheckAccess(JSContext *cx, JSObject *obj, jsid id,
    1:                    JSAccessMode mode, jsval *vp)
    1: {
    1:   // Prevent setting __proto__ on an XPCNativeWrapper
    1:   if ((mode & JSACC_WATCH) == JSACC_PROTO && (mode & JSACC_WRITE)) {
    1:     return ThrowException(NS_ERROR_XPC_SECURITY_MANAGER_VETO, cx);
    1:   }
    1: 
    1:   // Forward to the checkObjectAccess hook in the JSContext, if any.
18871:   JSSecurityCallbacks *callbacks = JS_GetSecurityCallbacks(cx);
18871:   if (callbacks && callbacks->checkObjectAccess &&
18871:       !callbacks->checkObjectAccess(cx, obj, id, mode, vp)) {
    1:     return JS_FALSE;
    1:   }
    1: 
24010:   // This function does its own security checks.
24010:   XPCWrappedNative *wrappedNative = XPCNativeWrapper::SafeGetWrappedNative(obj);
    1:   if (!wrappedNative) {
    1:     return JS_TRUE;
    1:   }
    1: 
    1:   JSObject *wrapperJSObject = wrappedNative->GetFlatJSObject();
    1: 
48470:   JSClass *clazz = wrapperJSObject->getJSClass();
    1:   return !clazz->checkAccess ||
    1:     clazz->checkAccess(cx, wrapperJSObject, id, mode, vp);
    1: }
    1: 
18907: static JSBool
53557: XPC_NW_Call(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1: #ifdef DEBUG
53557:   JSObject *obj = JS_THIS_OBJECT(cx, vp);
53557:   if (!obj)
53557:     return JS_FALSE;
43200:   if (!XPCNativeWrapper::IsNativeWrapper(obj) &&
43200:       !JS_ObjectIsFunction(cx, obj)) {
    1:     NS_WARNING("Ignoring a call for a weird object");
    1:   }
    1: #endif
53557:   JS_SET_RVAL(cx, vp, JSVAL_VOID);
    1:   return JS_TRUE;
    1: }
    1: 
18907: static JSBool
53557: XPC_NW_Construct(JSContext *cx, uintN argc, jsval *vp)
    1: {
53557:   JSObject *obj = JSVAL_TO_OBJECT(JS_CALLEE(cx, vp));
24010:   if (!EnsureLegalActivity(cx, obj)) {
24010:     return JS_FALSE;
24010:   }
24010: 
24010:   // Protected by EnsureLegalActivity.
24010:   XPCWrappedNative *wrappedNative = XPCNativeWrapper::SafeGetWrappedNative(obj);
    1:   if (!wrappedNative) {
    1:     return JS_TRUE;
    1:   }
    1: 
    1:   JSBool retval = JS_TRUE;
    1: 
    1:   if (!NATIVE_HAS_FLAG(wrappedNative, WantConstruct)) {
    1:     return ThrowException(NS_ERROR_INVALID_ARG, cx);
    1:   }
    1: 
54474:   XPCCallContext ccx(JS_CALLER, cx, obj, nsnull, JSID_VOID,
54474:                      argc, JS_ARGV(cx, vp), vp);
54474:   if(!ccx.IsValid())
54474:       return JS_FALSE;
54474: 
54474:   JS_ASSERT(obj == ccx.GetFlattenedJSObject());
54474: 
    1:   nsresult rv = wrappedNative->GetScriptableInfo()->
53557:     GetCallback()->Construct(wrappedNative, cx, obj, argc, JS_ARGV(cx, vp), vp,
    1:                              &retval);
    1:   if (NS_FAILED(rv)) {
    1:     return ThrowException(rv, cx);
    1:   }
    1: 
    1:   if (!retval) {
    1:     return JS_FALSE;
    1:   }
    1: 
53557:   if (JSVAL_IS_PRIMITIVE(*vp)) {
    1:     return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
    1:   }
    1: 
53557:   return RewrapValue(cx, obj, *vp, vp);
    1: }
    1: 
18907: static JSBool
48470: XPC_NW_HasInstance(JSContext *cx, JSObject *obj, const jsval *valp, JSBool *bp)
    1: {
    1:   return JS_TRUE;
    1: }
    1: 
    1: static JSBool
53557: XPCNativeWrapperCtor(JSContext *cx, uintN argc, jsval *vp)
    1: {
32513:   JSBool constructing = JS_FALSE;
53557: 
53557:   JSObject *givenThis;
53557:   if (JS_IsConstructing_PossiblyWithGivenThisObject(cx, vp, &givenThis)) {
32513:     constructing = JS_TRUE;
53557:     if (givenThis) {
53557:       // This is the XPCNativeWrapper prototype
53557:       JS_ASSERT(givenThis->getProto() != NULL);
53557:       JS_ASSERT(XPCNativeWrapper::IsNativeWrapper(givenThis));
53557:       JS_ASSERT(!XPCNativeWrapper::IsNativeWrapper(givenThis->getProto()));
32513: 
53557:       if (!JS_SetPrivate(cx, givenThis, nsnull) ||
53557:           !JS_SetReservedSlot(cx, givenThis, 0, JSVAL_ZERO)) {
53557:         return JS_FALSE;
53557:       }
32416: 
53557:       JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(givenThis));
53557:       return JS_TRUE;
32416:     }
32416:   }
32416: 
    1:   if (argc < 1) {
    1:     return ThrowException(NS_ERROR_XPC_NOT_ENOUGH_ARGS, cx);
    1:   }
    1: 
53557:   jsval *argv = JS_ARGV(cx, vp);
    1:   jsval native = argv[0];
    1: 
    1:   if (JSVAL_IS_PRIMITIVE(native)) {
32513:     if (constructing) {
24834:       return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
24834:     }
24834: 
53557:     JS_SET_RVAL(cx, vp, native);
24834:     return JS_TRUE;
    1:   }
    1: 
    1:   JSObject *nativeObj = JSVAL_TO_OBJECT(native);
    1: 
39406:   // First, if this is another type of security wrapper, unwrap it to see what
39406:   // we're really dealing with.
39406:   nativeObj = UnsafeUnwrapSecurityWrapper(cx, nativeObj);
39406:   if (!nativeObj) {
39406:     return ThrowException(NS_ERROR_INVALID_ARG, cx);
39406:   }
39406:   native = OBJECT_TO_JSVAL(nativeObj);
39406: 
39406:   // Now, figure out if we're allowed to create an XPCNativeWrapper around it.
39406:   JSObject *scope = JS_GetScopeChain(cx);
39406:   if (!scope) {
39406:     return JS_FALSE;
24010:   }
12584: 
39406:   XPCWrappedNativeScope *xpcscope =
39406:     XPCWrappedNativeScope::FindInJSObjectScope(cx, scope);
39406:   NS_ASSERTION(xpcscope, "what crazy scope are we in?");
39406: 
    1:   XPCWrappedNative *wrappedNative;
39406:   WrapperType type = xpcscope->GetWrapperFor(cx, nativeObj, XPCNW_EXPLICIT,
39406:                                              &wrappedNative);
    1: 
39406:   if (type != NONE && !(type & XPCNW_EXPLICIT)) {
    1:     return ThrowException(NS_ERROR_INVALID_ARG, cx);
    1:   }
    1: 
39406:   // We might have to morph.
39406:   if (!wrappedNative) {
32827:     wrappedNative =
32827:       XPCWrappedNative::GetAndMorphWrappedNativeOfJSObject(cx, nativeObj);
    1: 
    1:     if (!wrappedNative) {
    1:       return ThrowException(NS_ERROR_INVALID_ARG, cx);
    1:     }
39406:   }
    1: 
    1:   // Prevent wrapping a double-wrapped JS object in an
    1:   // XPCNativeWrapper!
    1:   nsCOMPtr<nsIXPConnectWrappedJS> xpcwrappedjs =
    1:     do_QueryWrappedNative(wrappedNative);
    1: 
    1:   if (xpcwrappedjs) {
    1:     return ThrowException(NS_ERROR_INVALID_ARG, cx);
    1:   }
    1: 
    1:   if (argc == 2 && !JSVAL_IS_PRIMITIVE(argv[1])) {
    1:     // An object was passed as the second argument to the
    1:     // constructor. In this case we check that the object we're
    1:     // wrapping is an instance of the assumed constructor that we
    1:     // got. If not, throw an exception.
    1:     JSBool hasInstance;
32513:     if (!JS_HasInstance(cx, JSVAL_TO_OBJECT(argv[1]), native, &hasInstance)) {
    1:       return ThrowException(NS_ERROR_UNEXPECTED, cx);
    1:     }
    1: 
    1:     if (!hasInstance) {
    1:       return ThrowException(NS_ERROR_INVALID_ARG, cx);
    1:     }
    1:   }
    1: 
53557:   if (!XPCNativeWrapper::CreateExplicitWrapper(cx, wrappedNative, vp)) {
39406:     return JS_FALSE;
39406:   }
39406: 
39406:   if (!(type & SOW)) {
39406:     return JS_TRUE;
39406:   }
39406: 
53557:   return SystemOnlyWrapper::MakeSOW(cx, JSVAL_TO_OBJECT(*vp));
    1: }
    1: 
18907: static void
 1025: XPC_NW_Trace(JSTracer *trc, JSObject *obj)
    1: {
24010:   // Untrusted code can't trigger this.
24010:   XPCWrappedNative *wrappedNative = XPCNativeWrapper::SafeGetWrappedNative(obj);
    1: 
    1:   if (wrappedNative && wrappedNative->IsValid()) {
 1025:     JS_CALL_OBJECT_TRACER(trc, wrappedNative->GetFlatJSObject(),
 1025:                           "wrappedNative.flatJSObject");
    1:   }
    1: }
    1: 
18907: static JSBool
48470: XPC_NW_Equality(JSContext *cx, JSObject *obj, const jsval *valp, JSBool *bp)
    1: {
10858:   NS_ASSERTION(XPCNativeWrapper::IsNativeWrapper(obj),
    1:                "Uh, we should only ever be called for XPCNativeWrapper "
    1:                "objects!");
    1: 
24010:   if (!EnsureLegalActivity(cx, obj)) {
24010:     return JS_FALSE;
24010:   }
24010: 
48470:   jsval v = *valp;
    1:   if (JSVAL_IS_PRIMITIVE(v)) {
    1:     *bp = JS_FALSE;
    1: 
    1:     return JS_TRUE;
    1:   }
    1: 
24010:   // Protected by EnsureLegalActivity.
24010:   XPCWrappedNative *wrappedNative = XPCNativeWrapper::SafeGetWrappedNative(obj);
    1: 
    1:   if (wrappedNative && wrappedNative->IsValid() &&
    1:       NATIVE_HAS_FLAG(wrappedNative, WantEquality)) {
    1:     // Forward the call to the wrapped native's Equality() hook.
    1:     nsresult rv = wrappedNative->GetScriptableCallback()->
    1:       Equality(wrappedNative, cx, obj, v, bp);
    1: 
    1:     if (NS_FAILED(rv)) {
    1:       return ThrowException(rv, cx);
    1:     }
    1:   } else {
    1:     JSObject *other = JSVAL_TO_OBJECT(v);
    1: 
    1:     *bp = (obj == other ||
    1:            XPC_GetIdentityObject(cx, obj) == XPC_GetIdentityObject(cx, other));
    1:   }
    1: 
    1:   return JS_TRUE;
    1: }
    1: 
33307: static JSObject *
33307: XPC_NW_Iterator(JSContext *cx, JSObject *obj, JSBool keysonly)
33307: {
33307:   XPCCallContext ccx(JS_CALLER, cx);
33307:   if (!ccx.IsValid()) {
33307:     ThrowException(NS_ERROR_FAILURE, cx);
33307:     return nsnull;
33307:   }
33307: 
33307:   JSObject *wrapperIter =
40310:     JS_NewObjectWithGivenProto(cx, XPCNativeWrapper::GetJSClass(false), nsnull,
39930:                                obj->getParent());
33307:   if (!wrapperIter) {
33307:     return nsnull;
33307:   }
33307: 
40402:   js::AutoObjectRooter tvr(cx, wrapperIter);
33307: 
33307:   // Initialize our native wrapper.
33307:   XPCWrappedNative *wn = static_cast<XPCWrappedNative *>(JS_GetPrivate(cx, obj));
33307:   JS_SetPrivate(cx, wrapperIter, wn);
43198:   if (!JS_SetReservedSlot(cx, wrapperIter, 0, INT_TO_JSVAL(FLAG_EXPLICIT))) {
33307:     return nsnull;
33307:   }
33307: 
36309:   return CreateIteratorObj(cx, wrapperIter, obj, wn->GetFlatJSObject(),
36309:                            keysonly);
33307: }
33307: 
18907: static JSBool
53557: XPC_NW_toString(JSContext *cx, uintN argc, jsval *vp)
    1: {
53557:   JSObject *obj = JS_THIS_OBJECT(cx, vp);
53557:   if (!obj)
53557:     return JS_FALSE;
53557: 
10858:   while (!XPCNativeWrapper::IsNativeWrapper(obj)) {
39928:     obj = obj->getProto();
    1:     if (!obj) {
    1:       return ThrowException(NS_ERROR_UNEXPECTED, cx);
    1:     }
    1:   }
    1: 
29945:   if (!EnsureLegalActivity(cx, obj,
48470:                            GetRTIdByIndex(cx, XPCJSRuntime::IDX_TO_STRING),
36309:                            sSecMgrGetProp)) {
 3162:     return JS_FALSE;
 3162:   }
 3162: 
24010:   // Protected by EnsureLegalActivity.
24010:   XPCWrappedNative *wrappedNative = XPCNativeWrapper::SafeGetWrappedNative(obj);
    1: 
    1:   if (!wrappedNative) {
    1:     // toString() called on XPCNativeWrapper.prototype
    1:     NS_NAMED_LITERAL_STRING(protoString, "[object XPCNativeWrapper]");
    1:     JSString *str =
 3233:       ::JS_NewUCStringCopyN(cx, reinterpret_cast<const jschar*>
 3233:                                                 (protoString.get()),
    1:                             protoString.Length());
    1:     NS_ENSURE_TRUE(str, JS_FALSE);
53557:     JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(str));
    1:     return JS_TRUE;
    1:   }
    1: 
53557:   return NativeToString(cx, wrappedNative, argc, JS_ARGV(cx, vp), vp, JS_TRUE);
    1: }
    1: 
36577: static JSBool
36577: UnwrapNW(JSContext *cx, uintN argc, jsval *vp)
36577: {
36577:   if (argc != 1) {
36577:     return ThrowException(NS_ERROR_XPC_NOT_ENOUGH_ARGS, cx);
36577:   }
36577: 
36577:   jsval v = JS_ARGV(cx, vp)[0];
36577:   if (JSVAL_IS_PRIMITIVE(v)) {
36577:     return ThrowException(NS_ERROR_INVALID_ARG, cx);
36577:   }
36577: 
36577:   if (!IsNativeWrapper(JSVAL_TO_OBJECT(v))) {
36577:     JS_SET_RVAL(cx, vp, v);
36577:     return JS_TRUE;
36577:   }
36577: 
37489:   XPCWrappedNative *wn;
37489:   if (!XPCNativeWrapper::GetWrappedNative(cx, JSVAL_TO_OBJECT(v), &wn)) {
37489:     return JS_FALSE;
37489:   }
37489: 
37489:   if (!wn) {
37489:     JS_SET_RVAL(cx, vp, JSVAL_NULL);
37489:     return JS_TRUE;
37489:   }
37489: 
37489:   return GetwrappedJSObject(cx, wn->GetFlatJSObject(), vp);
36577: }
36577: 
36577: static JSFunctionSpec static_functions[] = {
36577:   JS_FN("unwrap", UnwrapNW, 1, 0),
36577:   JS_FS_END
36577: };
36577: 
    1: // static
    1: PRBool
    1: XPCNativeWrapper::AttachNewConstructorObject(XPCCallContext &ccx,
    1:                                              JSObject *aGlobalObject)
    1: {
    1:   JSObject *class_obj =
48622:     ::JS_InitClass(ccx, aGlobalObject, nsnull,
48622:                    js::Jsvalify(&internal::NW_Call_Class),
 8391:                    XPCNativeWrapperCtor, 0, nsnull, nsnull,
36577:                    nsnull, static_functions);
    1:   if (!class_obj) {
    1:     NS_WARNING("can't initialize the XPCNativeWrapper class");
    1:     return PR_FALSE;
    1:   }
    1:   
    1:   // Make sure our prototype chain is empty and that people can't mess
    1:   // with XPCNativeWrapper.prototype.
    1:   ::JS_SetPrototype(ccx, class_obj, nsnull);
    1:   if (!::JS_SealObject(ccx, class_obj, JS_FALSE)) {
    1:     NS_WARNING("Failed to seal XPCNativeWrapper.prototype");
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   JSBool found;
    1:   return ::JS_SetPropertyAttributes(ccx, aGlobalObject,
48622:                                     internal::NW_Call_Class.name,
    1:                                     JSPROP_READONLY | JSPROP_PERMANENT,
    1:                                     &found);
    1: }
    1: 
    1: // static
    1: JSObject *
16566: XPCNativeWrapper::GetNewOrUsed(JSContext *cx, XPCWrappedNative *wrapper,
37932:                                JSObject *scope, nsIPrincipal *aObjectPrincipal)
    1: {
49088:   CheckWindow(wrapper);
49088: 
20762:   if (aObjectPrincipal) {
36309:     nsIScriptSecurityManager *ssm = GetSecurityManager();
16566: 
16566:     PRBool isSystem;
20762:     nsresult rv = ssm->IsSystemPrincipal(aObjectPrincipal, &isSystem);
16566:     if (NS_SUCCEEDED(rv) && !isSystem) {
16566:       jsval v = OBJECT_TO_JSVAL(wrapper->GetFlatJSObject());
43197:       if (!CreateExplicitWrapper(cx, wrapper, &v)) {
16566:         return nsnull;
32513:       }
16566:       return JSVAL_TO_OBJECT(v);
16566:     }
16566:   }
16566: 
    1:   // Prevent wrapping a double-wrapped JS object in an
    1:   // XPCNativeWrapper!
    1:   nsCOMPtr<nsIXPConnectWrappedJS> xpcwrappedjs(do_QueryWrappedNative(wrapper));
    1: 
    1:   if (xpcwrappedjs) {
25423:     JSObject *flat = wrapper->GetFlatJSObject();
25423:     jsval v = OBJECT_TO_JSVAL(flat);
25423: 
25423:     XPCCallContext ccx(JS_CALLER, cx);
25423: 
25423:     // Make sure v doesn't get collected while we're re-wrapping it.
25423:     AUTO_MARK_JSVAL(ccx, v);
25423: 
37932:     if (XPCSafeJSObjectWrapper::WrapObject(cx, scope, v, &v))
25423:         return JSVAL_TO_OBJECT(v);
    1: 
    1:     return nsnull;
    1:   }
    1: 
 4042:   JSObject *obj = wrapper->GetWrapper();
    1:   if (obj) {
    1:     return obj;
    1:   }
    1: 
51079:   JSObject *nw_parent = wrapper->GetScope()->GetGlobalJSObject();
    1: 
40310:   bool call = NATIVE_HAS_FLAG(wrapper, WantCall) ||
40310:               NATIVE_HAS_FLAG(wrapper, WantConstruct);
51079:   obj = JS_NewObjectWithGivenProto(cx, GetJSClass(call), nsnull, nw_parent);
    1: 
    1:   if (!obj ||
51079:       !JS_SetPrivate(cx, obj, wrapper) ||
51079:       !JS_SetReservedSlot(cx, obj, 0, JSVAL_ZERO)) {
    1:     return nsnull;
    1:   }
    1: 
 4042:   wrapper->SetWrapper(obj);
    1: 
    1: #if defined(DEBUG_XPCNativeWrapper) || defined(DEBUG_xpc_leaks)
    1:   {
    1:     XPCCallContext ccx(NATIVE_CALLER, cx);
    1: 
    1:     // Keep obj alive while we mess with strings
    1:     AUTO_MARK_JSVAL(ccx, OBJECT_TO_JSVAL(obj));
    1: 
    1:     char *s = wrapper->ToString(ccx);
    1:     printf("Created new XPCNativeWrapper %p for wrapped native %s\n",
    1:            (void*)obj, s);
    1:     if (s)
    1:       JS_smprintf_free(s);
    1:   }
    1: #endif
    1:   
    1:   return obj;
    1: }
    1: 
32513: // static
32513: JSBool
32513: XPCNativeWrapper::CreateExplicitWrapper(JSContext *cx,
32513:                                         XPCWrappedNative *wrappedNative,
32513:                                         jsval *rval)
32513: {
32513: #ifdef DEBUG_XPCNativeWrapper
32513:   printf("Creating new JSObject\n");
32513: #endif
32513: 
40310:   bool call = NATIVE_HAS_FLAG(wrappedNative, WantCall) ||
40310:               NATIVE_HAS_FLAG(wrappedNative, WantConstruct);
32513:   JSObject *wrapperObj =
40310:     JS_NewObjectWithGivenProto(cx, XPCNativeWrapper::GetJSClass(call), nsnull,
32513:                                wrappedNative->GetScope()->GetGlobalJSObject());
32513: 
32513:   if (!wrapperObj) {
32513:     // JS_NewObject already threw (or reported OOM).
32513:     return JS_FALSE;
32513:   }
32513: 
51079:   if (!JS_SetReservedSlot(cx, wrapperObj, 0, INT_TO_JSVAL(FLAG_EXPLICIT))) {
32513:     return JS_FALSE;
32513:   }
32513: 
32513:   // Set the XPCWrappedNative as private data in the native wrapper.
32513:   if (!JS_SetPrivate(cx, wrapperObj, wrappedNative)) {
32513:     return JS_FALSE;
32513:   }
32513: 
32513: #if defined(DEBUG_XPCNativeWrapper) || defined(DEBUG_xpc_leaks)
32513:   {
32513:     XPCCallContext ccx(JS_CALLER, cx);
32513: 
32513:     // Keep wrapperObj alive while we mess with strings
32513:     AUTO_MARK_JSVAL(ccx, OBJECT_TO_JSVAL(wrapperObj));
32513: 
32513:     char *s = wrappedNative->ToString(ccx);
32513:     printf("Created new XPCNativeWrapper %p for wrapped native %s\n",
32513:            (void*)wrapperObj, s);
32513:     if (s)
32513:       JS_smprintf_free(s);
32513:   }
32513: #endif
32513: 
32513:   *rval = OBJECT_TO_JSVAL(wrapperObj);
32513: 
32513:   {
32513:     XPCJSRuntime *rt = wrappedNative->GetRuntime();
32513: 
32513:     // scoped lock
32513:     XPCAutoLock lock(rt->GetMapLock());
32513:     rt->GetExplicitNativeWrapperMap()->Add(wrapperObj);
32513:   }
32513: 
32513:   return JS_TRUE;
32513: }
32513: 
    1: struct WrapperAndCxHolder
    1: {
    1:     XPCWrappedNative* wrapper;
    1:     JSContext* cx;
    1: };
    1: 
18907: static JSDHashOperator
    1: ClearNativeWrapperScope(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                         uint32 number, void *arg)
    1: {
    1:     JSDHashEntryStub* entry = (JSDHashEntryStub*)hdr;
    1:     WrapperAndCxHolder* d = (WrapperAndCxHolder*)arg;
    1: 
 4042:     if (d->wrapper->GetWrapper() == (JSObject*)entry->key)
    1:     {
    1:         ::JS_ClearScope(d->cx, (JSObject*)entry->key);
    1:     }
    1: 
    1:     return JS_DHASH_NEXT;
    1: }
    1: 
    1: // static
    1: void
    1: XPCNativeWrapper::ClearWrappedNativeScopes(JSContext* cx,
    1:                                            XPCWrappedNative* wrapper)
    1: {
 4042:   JSObject *nativeWrapper = wrapper->GetWrapper();
    1: 
    1:   if (nativeWrapper) {
    1:     ::JS_ClearScope(cx, nativeWrapper);
    1:   }
    1: 
    1:   WrapperAndCxHolder d =
    1:     {
    1:       wrapper,
    1:       cx
    1:     };
    1: 
    1:   wrapper->GetRuntime()->GetExplicitNativeWrapperMap()->
    1:     Enumerate(ClearNativeWrapperScope, &d);
    1: }
