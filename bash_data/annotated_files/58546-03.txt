    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
29948: /* vim: set ts=2 sw=2 et tw=79: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Daniel Glazman <glazman@netscape.com>
    1:  *   Neil Deakin <neil@mozdevgroup.com>
39468:  *   Mats Palmgren <matspal@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* build on macs with low memory */
    1: #if defined(XP_MAC) && defined(MOZ_MAC_LOWMEM)
    1: #pragma optimization_level 1
    1: #endif
    1: 
    1: #include "nsHTMLEditRules.h"
    1: 
    1: #include "nsEditor.h"
    1: #include "nsTextEditUtils.h"
    1: #include "nsHTMLEditUtils.h"
    1: #include "nsHTMLCSSUtils.h"
    1: #include "nsHTMLEditor.h"
    1: 
    1: #include "nsIServiceManager.h"
    1: #include "nsCRT.h"
    1: #include "nsIContent.h"
    1: #include "nsIContentIterator.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsIDOMText.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsISelection.h"
    1: #include "nsISelectionPrivate.h"
    1: #include "nsISelectionController.h"
    1: #include "nsIDOMRange.h"
    1: #include "nsIDOMNSRange.h"
    1: #include "nsIRangeUtils.h"
    1: #include "nsIDOMCharacterData.h"
    1: #include "nsIEnumerator.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPrefService.h"
    1: #include "nsIDOMNamedNodeMap.h"
    1: #include "nsIRange.h"
    1: 
    1: #include "nsEditorUtils.h"
    1: #include "nsWSRunObject.h"
    1: 
    1: #include "InsertTextTxn.h"
    1: #include "DeleteTextTxn.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsUnicharUtils.h"
    1: 
    1: #include "nsFrameSelection.h"
20532: #include "nsIDOM3Node.h"
20532: #include "nsContentUtils.h"
23148: #include "nsTArray.h"
58546: #include "nsIHTMLDocument.h"
    1: 
    1: //const static char* kMOZEditorBogusNodeAttr="MOZ_EDITOR_BOGUS_NODE";
    1: //const static char* kMOZEditorBogusNodeValue="TRUE";
    1: 
    1: enum
    1: {
    1:   kLonely = 0,
    1:   kPrevSib = 1,
    1:   kNextSib = 2,
    1:   kBothSibs = 3
    1: };
    1: 
    1: /********************************************************
    1:  *  first some helpful funcotrs we will use
    1:  ********************************************************/
    1: 
    1: static PRBool IsBlockNode(nsIDOMNode* node)
    1: {
    1:   PRBool isBlock (PR_FALSE);
    1:   nsHTMLEditor::NodeIsBlockStatic(node, &isBlock);
    1:   return isBlock;
    1: }
    1: 
    1: static PRBool IsInlineNode(nsIDOMNode* node)
    1: {
    1:   return !IsBlockNode(node);
    1: }
    1:  
    1: class nsTableCellAndListItemFunctor : public nsBoolDomIterFunctor
    1: {
    1:   public:
    1:     virtual PRBool operator()(nsIDOMNode* aNode)  // used to build list of all li's, td's & th's iterator covers
    1:     {
    1:       if (nsHTMLEditUtils::IsTableCell(aNode)) return PR_TRUE;
    1:       if (nsHTMLEditUtils::IsListItem(aNode)) return PR_TRUE;
    1:       return PR_FALSE;
    1:     }
    1: };
    1: 
    1: class nsBRNodeFunctor : public nsBoolDomIterFunctor
    1: {
    1:   public:
    1:     virtual PRBool operator()(nsIDOMNode* aNode)  
    1:     {
    1:       if (nsTextEditUtils::IsBreak(aNode)) return PR_TRUE;
    1:       return PR_FALSE;
    1:     }
    1: };
    1: 
 8716: class nsEmptyEditableFunctor : public nsBoolDomIterFunctor
    1: {
    1:   public:
 8716:     nsEmptyEditableFunctor(nsHTMLEditor* editor) : mHTMLEditor(editor) {}
    1:     virtual PRBool operator()(nsIDOMNode* aNode)  
    1:     {
 8716:       if (mHTMLEditor->IsEditable(aNode) &&
 8716:         (nsHTMLEditUtils::IsListItem(aNode) ||
 8716:         nsHTMLEditUtils::IsTableCellOrCaption(aNode)))
    1:       {
    1:         PRBool bIsEmptyNode;
    1:         nsresult res = mHTMLEditor->IsEmptyNode(aNode, &bIsEmptyNode, PR_FALSE, PR_FALSE);
43805:         NS_ENSURE_SUCCESS(res, PR_FALSE);
    1:         if (bIsEmptyNode)
    1:           return PR_TRUE;
    1:       }
    1:       return PR_FALSE;
    1:     }
    1:   protected:
    1:     nsHTMLEditor* mHTMLEditor;
    1: };
    1: 
    1: class nsEditableTextFunctor : public nsBoolDomIterFunctor
    1: {
    1:   public:
    1:     nsEditableTextFunctor(nsHTMLEditor* editor) : mHTMLEditor(editor) {}
    1:     virtual PRBool operator()(nsIDOMNode* aNode)  
    1:     {
    1:       if (nsEditor::IsTextNode(aNode) && mHTMLEditor->IsEditable(aNode)) 
    1:       {
    1:         return PR_TRUE;
    1:       }
    1:       return PR_FALSE;
    1:     }
    1:   protected:
    1:     nsHTMLEditor* mHTMLEditor;
    1: };
    1: 
    1: 
    1: /********************************************************
    1:  *  routine for making new rules instance
    1:  ********************************************************/
    1: 
    1: nsresult
    1: NS_NewHTMLEditRules(nsIEditRules** aInstancePtrResult)
    1: {
    1:   nsHTMLEditRules * rules = new nsHTMLEditRules();
    1:   if (rules)
    1:     return rules->QueryInterface(NS_GET_IID(nsIEditRules), (void**) aInstancePtrResult);
    1:   return NS_ERROR_OUT_OF_MEMORY;
    1: }
    1: 
    1: /********************************************************
    1:  *  Constructor/Destructor 
    1:  ********************************************************/
    1: 
    1: nsHTMLEditRules::nsHTMLEditRules() : 
    1: mDocChangeRange(nsnull)
    1: ,mListenerEnabled(PR_TRUE)
    1: ,mReturnInEmptyLIKillsList(PR_TRUE)
    1: ,mDidDeleteSelection(PR_FALSE)
    1: ,mDidRangedDelete(PR_FALSE)
58546: ,mRestoreContentEditableCount(PR_FALSE)
    1: ,mUtilRange(nsnull)
    1: ,mJoinOffset(0)
    1: {
    1:   nsString emptyString;
    1:   // populate mCachedStyles
    1:   mCachedStyles[0] = StyleCache(nsEditProperty::b, emptyString, emptyString);
    1:   mCachedStyles[1] = StyleCache(nsEditProperty::i, emptyString, emptyString);
    1:   mCachedStyles[2] = StyleCache(nsEditProperty::u, emptyString, emptyString);
    1:   mCachedStyles[3] = StyleCache(nsEditProperty::font, NS_LITERAL_STRING("face"), emptyString);
    1:   mCachedStyles[4] = StyleCache(nsEditProperty::font, NS_LITERAL_STRING("size"), emptyString);
    1:   mCachedStyles[5] = StyleCache(nsEditProperty::font, NS_LITERAL_STRING("color"), emptyString);
    1:   mCachedStyles[6] = StyleCache(nsEditProperty::tt, emptyString, emptyString);
    1:   mCachedStyles[7] = StyleCache(nsEditProperty::em, emptyString, emptyString);
    1:   mCachedStyles[8] = StyleCache(nsEditProperty::strong, emptyString, emptyString);
    1:   mCachedStyles[9] = StyleCache(nsEditProperty::dfn, emptyString, emptyString);
    1:   mCachedStyles[10] = StyleCache(nsEditProperty::code, emptyString, emptyString);
    1:   mCachedStyles[11] = StyleCache(nsEditProperty::samp, emptyString, emptyString);
    1:   mCachedStyles[12] = StyleCache(nsEditProperty::var, emptyString, emptyString);
    1:   mCachedStyles[13] = StyleCache(nsEditProperty::cite, emptyString, emptyString);
    1:   mCachedStyles[14] = StyleCache(nsEditProperty::abbr, emptyString, emptyString);
    1:   mCachedStyles[15] = StyleCache(nsEditProperty::acronym, emptyString, emptyString);
    1:   mCachedStyles[16] = StyleCache(nsEditProperty::cssBackgroundColor, emptyString, emptyString);
    1:   mCachedStyles[17] = StyleCache(nsEditProperty::sub, emptyString, emptyString);
    1:   mCachedStyles[18] = StyleCache(nsEditProperty::sup, emptyString, emptyString);
    1: }
    1: 
    1: nsHTMLEditRules::~nsHTMLEditRules()
    1: {
    1:   // remove ourselves as a listener to edit actions
28152:   // In some cases, we have already been removed by 
28152:   // ~nsHTMLEditor, in which case we will get a null pointer here
    1:   // which we ignore.  But this allows us to add the ability to
    1:   // switch rule sets on the fly if we want.
28152:   if (mHTMLEditor)
    1:     mHTMLEditor->RemoveEditActionListener(this);
    1: }
    1: 
    1: /********************************************************
    1:  *  XPCOM Cruft
    1:  ********************************************************/
    1: 
    1: NS_IMPL_ADDREF_INHERITED(nsHTMLEditRules, nsTextEditRules)
    1: NS_IMPL_RELEASE_INHERITED(nsHTMLEditRules, nsTextEditRules)
28153: NS_IMPL_QUERY_INTERFACE_INHERITED2(nsHTMLEditRules, nsTextEditRules, nsIHTMLEditRules, nsIEditActionListener)
    1: 
    1: 
    1: /********************************************************
    1:  *  Public methods 
    1:  ********************************************************/
    1: 
    1: NS_IMETHODIMP
40703: nsHTMLEditRules::Init(nsPlaintextEditor *aEditor)
    1: {
 3233:   mHTMLEditor = static_cast<nsHTMLEditor*>(aEditor);
    1:   nsresult res;
    1:   
    1:   // call through to base class Init 
40703:   res = nsTextEditRules::Init(aEditor);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // cache any prefs we care about
    1:   nsCOMPtr<nsIPrefBranch> prefBranch =
    1:     do_GetService(NS_PREFSERVICE_CONTRACTID, &res);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   char *returnInEmptyLIKillsList = 0;
    1:   res = prefBranch->GetCharPref("editor.html.typing.returnInEmptyListItemClosesList",
    1:                                 &returnInEmptyLIKillsList);
    1: 
    1:   if (NS_SUCCEEDED(res) && returnInEmptyLIKillsList)
    1:   {
    1:     if (!strncmp(returnInEmptyLIKillsList, "false", 5))
    1:       mReturnInEmptyLIKillsList = PR_FALSE; 
    1:     else
    1:       mReturnInEmptyLIKillsList = PR_TRUE; 
    1:   }
    1:   else
    1:   {
    1:     mReturnInEmptyLIKillsList = PR_TRUE; 
    1:   }
    1:   
    1:   // make a utility range for use by the listenter
    1:   mUtilRange = do_CreateInstance("@mozilla.org/content/range;1");
43806:   NS_ENSURE_TRUE(mUtilRange, NS_ERROR_NULL_POINTER);
    1:    
    1:   // set up mDocChangeRange to be whole doc
    1:   nsIDOMElement *rootElem = mHTMLEditor->GetRoot();
    1:   if (rootElem)
    1:   {
    1:     // temporarily turn off rules sniffing
    1:     nsAutoLockRulesSniffing lockIt((nsTextEditRules*)this);
    1:     if (!mDocChangeRange)
    1:     {
    1:       mDocChangeRange = do_CreateInstance("@mozilla.org/content/range;1");
43806:       NS_ENSURE_TRUE(mDocChangeRange, NS_ERROR_NULL_POINTER);
    1:     }
    1:     mDocChangeRange->SelectNode(rootElem);
    1:     res = AdjustSpecialBreaks();
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1: 
    1:   // add ourselves as a listener to edit actions
    1:   res = mHTMLEditor->AddEditActionListener(this);
    1: 
    1:   return res;
    1: }
    1: 
28152: NS_IMETHODIMP
28152: nsHTMLEditRules::DetachEditor()
28152: {
28152:   mHTMLEditor = nsnull;
28152:   return nsTextEditRules::DetachEditor();
28152: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditRules::BeforeEdit(PRInt32 action, nsIEditor::EDirection aDirection)
    1: {
    1:   if (mLockRulesSniffing) return NS_OK;
    1:   
    1:   nsAutoLockRulesSniffing lockIt((nsTextEditRules*)this);
    1:   mDidExplicitlySetInterline = PR_FALSE;
    1: 
57273:   if (!mActionNesting++)
    1:   {
    1:     // clear our flag about if just deleted a range
    1:     mDidRangedDelete = PR_FALSE;
    1:     
    1:     // remember where our selection was before edit action took place:
    1:     
    1:     // get selection
    1:     nsCOMPtr<nsISelection>selection;
    1:     nsresult res = mHTMLEditor->GetSelection(getter_AddRefs(selection));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   
    1:     // get the selection start location
    1:     nsCOMPtr<nsIDOMNode> selStartNode, selEndNode;
    1:     PRInt32 selOffset;
43518:     res = mHTMLEditor->GetStartNodeAndOffset(selection, getter_AddRefs(selStartNode), &selOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     mRangeItem.startNode = selStartNode;
    1:     mRangeItem.startOffset = selOffset;
    1: 
    1:     // get the selection end location
43518:     res = mHTMLEditor->GetEndNodeAndOffset(selection, getter_AddRefs(selEndNode), &selOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     mRangeItem.endNode = selEndNode;
    1:     mRangeItem.endOffset = selOffset;
    1: 
    1:     // register this range with range updater to track this as we perturb the doc
    1:     (mHTMLEditor->mRangeUpdater).RegisterRangeItem(&mRangeItem);
    1: 
    1:     // clear deletion state bool
    1:     mDidDeleteSelection = PR_FALSE;
    1:     
    1:     // clear out mDocChangeRange and mUtilRange
    1:     if(mDocChangeRange)
    1:     {
    1:       // clear out our accounting of what changed
    1:       nsCOMPtr<nsIRange> range = do_QueryInterface(mDocChangeRange);
    1:       range->Reset(); 
    1:     }
    1:     if(mUtilRange)
    1:     {
    1:       // ditto for mUtilRange.
    1:       nsCOMPtr<nsIRange> range = do_QueryInterface(mUtilRange);
    1:       range->Reset(); 
    1:     }
    1: 
    1:     // remember current inline styles for deletion and normal insertion operations
    1:     if ((action == nsEditor::kOpInsertText)      || 
    1:         (action == nsEditor::kOpInsertIMEText)   ||
    1:         (action == nsEditor::kOpDeleteSelection) ||
    1:         (action == nsEditor::kOpInsertBreak))
    1:     {
    1:       nsCOMPtr<nsIDOMNode> selNode = selStartNode;
    1:       if (aDirection == nsIEditor::eNext)
    1:         selNode = selEndNode;
    1:       res = CacheInlineStyles(selNode);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1: 
58546:     // Stabilize the document against contenteditable count changes
58546:     nsCOMPtr<nsIDOMDocument> doc;
58546:     res = mHTMLEditor->GetDocument(getter_AddRefs(doc));
58546:     NS_ENSURE_SUCCESS(res, res);
58546:     nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(doc);
58546:     NS_ENSURE_TRUE(htmlDoc, NS_ERROR_FAILURE);
58546:     if (htmlDoc->GetEditingState() == nsIHTMLDocument::eContentEditable) {
58546:       htmlDoc->ChangeContentEditableCount(nsnull, +1);
58546:       mRestoreContentEditableCount = PR_TRUE;
58546:     }
58546: 
    1:     // check that selection is in subtree defined by body node
    1:     ConfirmSelectionInBody();
    1:     // let rules remember the top level action
    1:     mTheAction = action;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditRules::AfterEdit(PRInt32 action, nsIEditor::EDirection aDirection)
    1: {
    1:   if (mLockRulesSniffing) return NS_OK;
    1: 
    1:   nsAutoLockRulesSniffing lockIt(this);
    1: 
    1:   NS_PRECONDITION(mActionNesting>0, "bad action nesting!");
    1:   nsresult res = NS_OK;
    1:   if (!--mActionNesting)
    1:   {
    1:     // do all the tricky stuff
    1:     res = AfterEditInner(action, aDirection);
    1: 
    1:     // free up selectionState range item
    1:     (mHTMLEditor->mRangeUpdater).DropRangeItem(&mRangeItem);
    1: 
    1:     /* After inserting text the cursor Bidi level must be set to the level of the inserted text.
    1:      * This is difficult, because we cannot know what the level is until after the Bidi algorithm
    1:      * is applied to the whole paragraph.
    1:      *
    1:      * So we set the cursor Bidi level to UNDEFINED here, and the caret code will set it correctly later
    1:      */
    1:     if (action == nsEditor::kOpInsertText
    1:         || action == nsEditor::kOpInsertIMEText) {
    1: 
    1:       nsCOMPtr<nsISelection> selection;
    1:       nsresult res = mHTMLEditor->GetSelection(getter_AddRefs(selection));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       nsCOMPtr<nsISelectionPrivate> privateSelection(do_QueryInterface(selection));
    1:       nsCOMPtr<nsFrameSelection> frameSelection;
    1:       privateSelection->GetFrameSelection(getter_AddRefs(frameSelection));
    1:       if (frameSelection) {
    1:         frameSelection->UndefineCaretBidiLevel();
    1:       }
    1:     }
58546: 
58546:     // Reset the contenteditable count to its previous value
58546:     if (mRestoreContentEditableCount) {
58546:       nsCOMPtr<nsIDOMDocument> doc;
58546:       res = mHTMLEditor->GetDocument(getter_AddRefs(doc));
58546:       NS_ENSURE_SUCCESS(res, res);
58546:       nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(doc);
58546:       NS_ENSURE_TRUE(htmlDoc, NS_ERROR_FAILURE);
58546:       if (htmlDoc->GetEditingState() == nsIHTMLDocument::eContentEditable) {
58546:         htmlDoc->ChangeContentEditableCount(nsnull, -1);
58546:       }
58546:       mRestoreContentEditableCount = PR_FALSE;
58546:     }
    1:   }
    1: 
    1:   return res;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsHTMLEditRules::AfterEditInner(PRInt32 action, nsIEditor::EDirection aDirection)
    1: {
    1:   ConfirmSelectionInBody();
    1:   if (action == nsEditor::kOpIgnore) return NS_OK;
    1:   
    1:   nsCOMPtr<nsISelection>selection;
    1:   nsresult res = mHTMLEditor->GetSelection(getter_AddRefs(selection));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   nsCOMPtr<nsIDOMNode> rangeStartParent, rangeEndParent;
    1:   PRInt32 rangeStartOffset = 0, rangeEndOffset = 0;
    1:   // do we have a real range to act on?
    1:   PRBool bDamagedRange = PR_FALSE;  
    1:   if (mDocChangeRange)
    1:   {  
    1:     mDocChangeRange->GetStartContainer(getter_AddRefs(rangeStartParent));
    1:     mDocChangeRange->GetEndContainer(getter_AddRefs(rangeEndParent));
    1:     mDocChangeRange->GetStartOffset(&rangeStartOffset);
    1:     mDocChangeRange->GetEndOffset(&rangeEndOffset);
    1:     if (rangeStartParent && rangeEndParent) 
    1:       bDamagedRange = PR_TRUE; 
    1:   }
    1:   
    1:   if (bDamagedRange && !((action == nsEditor::kOpUndo) || (action == nsEditor::kOpRedo)))
    1:   {
    1:     // don't let any txns in here move the selection around behind our back.
    1:     // Note that this won't prevent explicit selection setting from working.
    1:     nsAutoTxnsConserveSelection dontSpazMySelection(mHTMLEditor);
    1:    
    1:     // expand the "changed doc range" as needed
    1:     res = PromoteRange(mDocChangeRange, action);
43805:     NS_ENSURE_SUCCESS(res, res);
    1: 
    1:     // if we did a ranged deletion, make sure we have a place to put caret.
    1:     // Note we only want to do this if the overall operation was deletion,
    1:     // not if deletion was done along the way for kOpLoadHTML, kOpInsertText, etc.
    1:     // That's why this is here rather than DidDeleteSelection().
    1:     if ((action == nsEditor::kOpDeleteSelection) && mDidRangedDelete)
    1:     {
    1:       res = InsertBRIfNeeded(selection);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }  
    1:     
    1:     // add in any needed <br>s, and remove any unneeded ones.
    1:     res = AdjustSpecialBreaks();
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     
    1:     // merge any adjacent text nodes
    1:     if ( (action != nsEditor::kOpInsertText &&
    1:          action != nsEditor::kOpInsertIMEText) )
    1:     {
    1:       res = mHTMLEditor->CollapseAdjacentTextNodes(mDocChangeRange);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1: 
    1:     // clean up any empty nodes in the selection
    1:     res = RemoveEmptyNodes();
43805:     NS_ENSURE_SUCCESS(res, res);
    1: 
    1:     // attempt to transform any unneeded nbsp's into spaces after doing various operations
    1:     if ((action == nsEditor::kOpInsertText) || 
    1:         (action == nsEditor::kOpInsertIMEText) ||
    1:         (action == nsEditor::kOpDeleteSelection) ||
    1:         (action == nsEditor::kOpInsertBreak) || 
    1:         (action == nsHTMLEditor::kOpHTMLPaste ||
    1:         (action == nsHTMLEditor::kOpLoadHTML)))
    1:     {
    1:       res = AdjustWhitespace(selection);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       
    1:       // also do this for original selection endpoints. 
    1:       nsWSRunObject(mHTMLEditor, mRangeItem.startNode, mRangeItem.startOffset).AdjustWhitespace();
    1:       // we only need to handle old selection endpoint if it was different from start
    1:       if ((mRangeItem.startNode != mRangeItem.endNode) || (mRangeItem.startOffset != mRangeItem.endOffset))
    1:       {
    1:         nsWSRunObject(mHTMLEditor, mRangeItem.endNode, mRangeItem.endOffset).AdjustWhitespace();
    1:       }
    1:     }
    1:     
    1:     // if we created a new block, make sure selection lands in it
    1:     if (mNewBlock)
    1:     {
    1:       res = PinSelectionToNewBlock(selection);
    1:       mNewBlock = 0;
    1:     }
    1: 
    1:     // adjust selection for insert text, html paste, and delete actions
    1:     if ((action == nsEditor::kOpInsertText) || 
    1:         (action == nsEditor::kOpInsertIMEText) ||
    1:         (action == nsEditor::kOpDeleteSelection) ||
    1:         (action == nsEditor::kOpInsertBreak) || 
    1:         (action == nsHTMLEditor::kOpHTMLPaste ||
    1:         (action == nsHTMLEditor::kOpLoadHTML)))
    1:     {
    1:       res = AdjustSelection(selection, aDirection);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1: 
    1:     // check for any styles which were removed inappropriately
    1:     if ((action == nsEditor::kOpInsertText)      || 
    1:         (action == nsEditor::kOpInsertIMEText)   ||
    1:         (action == nsEditor::kOpDeleteSelection) ||
    1:         (action == nsEditor::kOpInsertBreak))
    1:     {
    1:       mHTMLEditor->mTypeInState->UpdateSelState(selection);
    1:       res = ReapplyCachedStyles();
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = ClearCachedStyles();
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }    
    1:   }
    1: 
    1:   res = mHTMLEditor->HandleInlineSpellCheck(action, selection, 
    1:                                             mRangeItem.startNode, mRangeItem.startOffset,
    1:                                             rangeStartParent, rangeStartOffset,
    1:                                             rangeEndParent, rangeEndOffset);
43808:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // detect empty doc
    1:   res = CreateBogusNodeIfNeeded(selection);
    1:   
    1:   // adjust selection HINT if needed
43808:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   if (!mDidExplicitlySetInterline)
    1:   {
    1:     res = CheckInterlinePosition(selection);
    1:   }
    1:   
    1:   return res;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditRules::WillDoAction(nsISelection *aSelection, 
    1:                               nsRulesInfo *aInfo, 
    1:                               PRBool *aCancel, 
    1:                               PRBool *aHandled)
    1: {
43807:   NS_ENSURE_TRUE(aInfo && aCancel && aHandled, NS_ERROR_NULL_POINTER);
    1: #if defined(DEBUG_ftang)
    1:   printf("nsHTMLEditRules::WillDoAction action = %d\n", aInfo->action);
    1: #endif
    1: 
    1:   *aCancel = PR_FALSE;
    1:   *aHandled = PR_FALSE;
    1:     
    1:   // my kingdom for dynamic cast
 3233:   nsTextRulesInfo *info = static_cast<nsTextRulesInfo*>(aInfo);
    1: 
 2896:   // Deal with actions for which we don't need to check whether the selection is
 2896:   // editable.
29948:   if (info->action == kOutputText ||
29948:       info->action == kUndo ||
29948:       info->action == kRedo)
29948:   {
 2896:     return nsTextEditRules::WillDoAction(aSelection, aInfo, aCancel, aHandled);
 2896:   }
 2896: 
 2896:   nsCOMPtr<nsIDOMRange> domRange;
 2896:   nsresult rv = aSelection->GetRangeAt(0, getter_AddRefs(domRange));
 2896:   NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 2896:   nsCOMPtr<nsIDOMNode> selStartNode;
 2896:   rv = domRange->GetStartContainer(getter_AddRefs(selStartNode));
 2896:   NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 2896:   if (!mHTMLEditor->IsModifiableNode(selStartNode))
 2896:   {
 2896:     *aCancel = PR_TRUE;
 2896: 
 2896:     return NS_OK;
 2896:   }
 2896: 
 2896:   nsCOMPtr<nsIDOMNode> selEndNode;
 2896:   rv = domRange->GetEndContainer(getter_AddRefs(selEndNode));
 2896:   NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 2896:   if (selStartNode != selEndNode)
 2896:   {
 2896:     if (!mHTMLEditor->IsModifiableNode(selEndNode))
 2896:     {
 2896:       *aCancel = PR_TRUE;
 2896: 
 2896:       return NS_OK;
 2896:     }
 2896: 
 2896:     nsCOMPtr<nsIRange> range = do_QueryInterface(domRange);
 2896:     nsCOMPtr<nsIDOMNode> ancestor =
 2896:       do_QueryInterface(range->GetCommonAncestor());
 2896:     if (!mHTMLEditor->IsModifiableNode(ancestor))
 2896:     {
 2896:       *aCancel = PR_TRUE;
 2896: 
 2896:       return NS_OK;
 2896:     }
 2896:   }
 2896: 
    1:   switch (info->action)
    1:   {
    1:     case kInsertText:
    1:     case kInsertTextIME:
    1:       return WillInsertText(info->action,
    1:                             aSelection, 
    1:                             aCancel, 
    1:                             aHandled,
    1:                             info->inString,
    1:                             info->outString,
    1:                             info->maxLength);
    1:     case kLoadHTML:
    1:       return WillLoadHTML(aSelection, aCancel);
    1:     case kInsertBreak:
    1:       return WillInsertBreak(aSelection, aCancel, aHandled);
    1:     case kDeleteSelection:
    1:       return WillDeleteSelection(aSelection, info->collapsedAction, aCancel, aHandled);
    1:     case kMakeList:
    1:       return WillMakeList(aSelection, info->blockType, info->entireList, info->bulletType, aCancel, aHandled);
    1:     case kIndent:
    1:       return WillIndent(aSelection, aCancel, aHandled);
    1:     case kOutdent:
    1:       return WillOutdent(aSelection, aCancel, aHandled);
    1:     case kSetAbsolutePosition:
    1:       return WillAbsolutePosition(aSelection, aCancel, aHandled);
    1:     case kRemoveAbsolutePosition:
    1:       return WillRemoveAbsolutePosition(aSelection, aCancel, aHandled);
    1:     case kAlign:
    1:       return WillAlign(aSelection, info->alignType, aCancel, aHandled);
    1:     case kMakeBasicBlock:
    1:       return WillMakeBasicBlock(aSelection, info->blockType, aCancel, aHandled);
    1:     case kRemoveList:
    1:       return WillRemoveList(aSelection, info->bOrdered, aCancel, aHandled);
    1:     case kMakeDefListItem:
    1:       return WillMakeDefListItem(aSelection, info->blockType, info->entireList, aCancel, aHandled);
    1:     case kInsertElement:
    1:       return WillInsert(aSelection, aCancel);
    1:     case kDecreaseZIndex:
    1:       return WillRelativeChangeZIndex(aSelection, -1, aCancel, aHandled);
    1:     case kIncreaseZIndex:
    1:       return WillRelativeChangeZIndex(aSelection, 1, aCancel, aHandled);
    1:   }
    1:   return nsTextEditRules::WillDoAction(aSelection, aInfo, aCancel, aHandled);
    1: }
    1:   
    1:   
    1: NS_IMETHODIMP 
    1: nsHTMLEditRules::DidDoAction(nsISelection *aSelection,
    1:                              nsRulesInfo *aInfo, nsresult aResult)
    1: {
 3233:   nsTextRulesInfo *info = static_cast<nsTextRulesInfo*>(aInfo);
    1:   switch (info->action)
    1:   {
    1:     case kInsertBreak:
    1:       return DidInsertBreak(aSelection, aResult);
    1:     case kDeleteSelection:
    1:       return DidDeleteSelection(aSelection, info->collapsedAction, aResult);
    1:     case kMakeBasicBlock:
    1:     case kIndent:
    1:     case kOutdent:
    1:     case kAlign:
    1:       return DidMakeBasicBlock(aSelection, aInfo, aResult);
    1:     case kSetAbsolutePosition: {
    1:       nsresult rv = DidMakeBasicBlock(aSelection, aInfo, aResult);
43805:       NS_ENSURE_SUCCESS(rv, rv);
    1:       return DidAbsolutePosition();
    1:       }
    1:   }
    1:   
    1:   // default: pass thru to nsTextEditRules
    1:   return nsTextEditRules::DidDoAction(aSelection, aInfo, aResult);
    1: }
    1:   
    1: /********************************************************
    1:  *  nsIHTMLEditRules methods
    1:  ********************************************************/
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditRules::GetListState(PRBool *aMixed, PRBool *aOL, PRBool *aUL, PRBool *aDL)
    1: {
43807:   NS_ENSURE_TRUE(aMixed && aOL && aUL && aDL, NS_ERROR_NULL_POINTER);
    1:   *aMixed = PR_FALSE;
    1:   *aOL = PR_FALSE;
    1:   *aUL = PR_FALSE;
    1:   *aDL = PR_FALSE;
    1:   PRBool bNonList = PR_FALSE;
    1:   
    1:   nsCOMArray<nsIDOMNode> arrayOfNodes;
    1:   nsresult res = GetListActionNodes(arrayOfNodes, PR_FALSE, PR_TRUE);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // examine list type for nodes in selection
    1:   PRInt32 listCount = arrayOfNodes.Count();
    1:   PRInt32 i;
    1:   for (i=listCount-1; i>=0; i--)
    1:   {
    1:     nsIDOMNode* curNode = arrayOfNodes[i];
    1:     
    1:     if (nsHTMLEditUtils::IsUnorderedList(curNode))
    1:       *aUL = PR_TRUE;
    1:     else if (nsHTMLEditUtils::IsOrderedList(curNode))
    1:       *aOL = PR_TRUE;
    1:     else if (nsEditor::NodeIsType(curNode, nsEditProperty::li))
    1:     {
    1:       nsCOMPtr<nsIDOMNode> parent;
    1:       PRInt32 offset;
    1:       res = nsEditor::GetNodeLocation(curNode, address_of(parent), &offset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       if (nsHTMLEditUtils::IsUnorderedList(parent))
    1:         *aUL = PR_TRUE;
    1:       else if (nsHTMLEditUtils::IsOrderedList(parent))
    1:         *aOL = PR_TRUE;
    1:     }
    1:     else if (nsEditor::NodeIsType(curNode, nsEditProperty::dl) ||
    1:              nsEditor::NodeIsType(curNode, nsEditProperty::dt) ||
    1:              nsEditor::NodeIsType(curNode, nsEditProperty::dd) )
    1:     {
    1:       *aDL = PR_TRUE;
    1:     }
    1:     else bNonList = PR_TRUE;
    1:   }  
    1:   
    1:   // hokey arithmetic with booleans
    1:   if ( (*aUL + *aOL + *aDL + bNonList) > 1) *aMixed = PR_TRUE;
    1:   
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditRules::GetListItemState(PRBool *aMixed, PRBool *aLI, PRBool *aDT, PRBool *aDD)
    1: {
43807:   NS_ENSURE_TRUE(aMixed && aLI && aDT && aDD, NS_ERROR_NULL_POINTER);
    1:   *aMixed = PR_FALSE;
    1:   *aLI = PR_FALSE;
    1:   *aDT = PR_FALSE;
    1:   *aDD = PR_FALSE;
    1:   PRBool bNonList = PR_FALSE;
    1:   
    1:   nsCOMArray<nsIDOMNode> arrayOfNodes;
    1:   nsresult res = GetListActionNodes(arrayOfNodes, PR_FALSE, PR_TRUE);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // examine list type for nodes in selection
    1:   PRInt32 listCount = arrayOfNodes.Count();
    1:   PRInt32 i;
    1:   for (i = listCount-1; i>=0; i--)
    1:   {
    1:     nsIDOMNode* curNode = arrayOfNodes[i];
    1:     
    1:     if (nsHTMLEditUtils::IsUnorderedList(curNode) ||
    1:         nsHTMLEditUtils::IsOrderedList(curNode) ||
    1:         nsEditor::NodeIsType(curNode, nsEditProperty::li) )
    1:     {
    1:       *aLI = PR_TRUE;
    1:     }
    1:     else if (nsEditor::NodeIsType(curNode, nsEditProperty::dt))
    1:     {
    1:       *aDT = PR_TRUE;
    1:     }
    1:     else if (nsEditor::NodeIsType(curNode, nsEditProperty::dd))
    1:     {
    1:       *aDD = PR_TRUE;
    1:     }
    1:     else if (nsEditor::NodeIsType(curNode, nsEditProperty::dl))
    1:     {
    1:       // need to look inside dl and see which types of items it has
    1:       PRBool bDT, bDD;
    1:       res = GetDefinitionListItemTypes(curNode, bDT, bDD);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       *aDT |= bDT;
    1:       *aDD |= bDD;
    1:     }
    1:     else bNonList = PR_TRUE;
    1:   }  
    1:   
    1:   // hokey arithmetic with booleans
    1:   if ( (*aDT + *aDD + bNonList) > 1) *aMixed = PR_TRUE;
    1:   
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditRules::GetAlignment(PRBool *aMixed, nsIHTMLEditor::EAlignment *aAlign)
    1: {
    1:   // for now, just return first alignment.  we'll lie about
    1:   // if it's mixed.  This is for efficiency
    1:   // given that our current ui doesn't care if it's mixed.
    1:   // cmanske: NOT TRUE! We would like to pay attention to mixed state
    1:   //  in Format | Align submenu!
    1: 
    1:   // this routine assumes that alignment is done ONLY via divs
    1: 
    1:   // default alignment is left
43807:   NS_ENSURE_TRUE(aMixed && aAlign, NS_ERROR_NULL_POINTER);
    1:   *aMixed = PR_FALSE;
    1:   *aAlign = nsIHTMLEditor::eLeft;
    1: 
    1:   // get selection
    1:   nsCOMPtr<nsISelection>selection;
    1:   nsresult res = mHTMLEditor->GetSelection(getter_AddRefs(selection));
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // get selection location
    1:   nsCOMPtr<nsIDOMNode> parent;
    1:   nsIDOMElement *rootElem = mHTMLEditor->GetRoot();
43807:   NS_ENSURE_TRUE(rootElem, NS_ERROR_FAILURE);
    1: 
    1:   PRInt32 offset, rootOffset;
    1:   res = nsEditor::GetNodeLocation(rootElem, address_of(parent), &rootOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
43518:   res = mHTMLEditor->GetStartNodeAndOffset(selection, getter_AddRefs(parent), &offset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // is the selection collapsed?
    1:   PRBool bCollapsed;
    1:   res = selection->GetIsCollapsed(&bCollapsed);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   nsCOMPtr<nsIDOMNode> nodeToExamine;
    1:   nsCOMPtr<nsISupports> isupports;
    1:   if (bCollapsed)
    1:   {
    1:     // if it is, we want to look at 'parent' and it's ancestors
    1:     // for divs with alignment on them
    1:     nodeToExamine = parent;
    1:   }
    1:   else if (mHTMLEditor->IsTextNode(parent)) 
    1:   {
    1:     // if we are in a text node, then that is the node of interest
    1:     nodeToExamine = parent;
    1:   }
    1:   else if (nsEditor::NodeIsType(parent, nsEditProperty::html) &&
    1:            offset == rootOffset)
    1:   {
    1:     // if we have selected the body, let's look at the first editable node
    1:     mHTMLEditor->GetNextNode(parent, offset, PR_TRUE, address_of(nodeToExamine));
    1:   }
    1:   else
    1:   {
    1:     nsCOMArray<nsIDOMRange> arrayOfRanges;
    1:     res = GetPromotedRanges(selection, arrayOfRanges, kAlign);
43805:     NS_ENSURE_SUCCESS(res, res);
    1: 
    1:     // use these ranges to construct a list of nodes to act on.
    1:     nsCOMArray<nsIDOMNode> arrayOfNodes;
    1:     res = GetNodesForOperation(arrayOfRanges, arrayOfNodes, kAlign, PR_TRUE);
43805:     NS_ENSURE_SUCCESS(res, res);                                 
    1:     nodeToExamine = arrayOfNodes.SafeObjectAt(0);
    1:   }
    1: 
43806:   NS_ENSURE_TRUE(nodeToExamine, NS_ERROR_NULL_POINTER);
    1: 
    1:   PRBool useCSS;
    1:   mHTMLEditor->GetIsCSSEnabled(&useCSS);
    1:   NS_NAMED_LITERAL_STRING(typeAttrName, "align");
    1:   nsIAtom  *dummyProperty = nsnull;
    1:   nsCOMPtr<nsIDOMNode> blockParent;
    1:   if (mHTMLEditor->IsBlockNode(nodeToExamine))
    1:     blockParent = nodeToExamine;
    1:   else
    1:     blockParent = mHTMLEditor->GetBlockNodeParent(nodeToExamine);
    1: 
43806:   NS_ENSURE_TRUE(blockParent, NS_ERROR_FAILURE);
    1: 
    1:   if (useCSS)
    1:   {
    1:     nsCOMPtr<nsIContent> blockParentContent = do_QueryInterface(blockParent);
    1:     if (blockParentContent && 
    1:         mHTMLEditor->mHTMLCSSUtils->IsCSSEditableProperty(blockParent, dummyProperty, &typeAttrName))
    1:     {
    1:       // we are in CSS mode and we know how to align this element with CSS
    1:       nsAutoString value;
    1:       // let's get the value(s) of text-align or margin-left/margin-right
    1:       mHTMLEditor->mHTMLCSSUtils->GetCSSEquivalentToHTMLInlineStyleSet(blockParent,
    1:                                                      dummyProperty,
    1:                                                      &typeAttrName,
    1:                                                      value,
    1:                                                      COMPUTED_STYLE_TYPE);
    1:       if (value.EqualsLiteral("center") ||
    1:           value.EqualsLiteral("-moz-center") ||
    1:           value.EqualsLiteral("auto auto"))
    1:       {
    1:         *aAlign = nsIHTMLEditor::eCenter;
    1:         return NS_OK;
    1:       }
    1:       if (value.EqualsLiteral("right") ||
    1:           value.EqualsLiteral("-moz-right") ||
    1:           value.EqualsLiteral("auto 0px"))
    1:       {
    1:         *aAlign = nsIHTMLEditor::eRight;
    1:         return NS_OK;
    1:       }
    1:       if (value.EqualsLiteral("justify"))
    1:       {
    1:         *aAlign = nsIHTMLEditor::eJustify;
    1:         return NS_OK;
    1:       }
    1:       *aAlign = nsIHTMLEditor::eLeft;
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   // check up the ladder for divs with alignment
    1:   nsCOMPtr<nsIDOMNode> temp = nodeToExamine;
    1:   PRBool isFirstNodeToExamine = PR_TRUE;
    1:   while (nodeToExamine)
    1:   {
    1:     if (!isFirstNodeToExamine && nsHTMLEditUtils::IsTable(nodeToExamine))
    1:     {
    1:       // the node to examine is a table and this is not the first node
    1:       // we examine; let's break here to materialize the 'inline-block'
    1:       // behaviour of html tables regarding to text alignment
    1:       return NS_OK;
    1:     }
    1:     if (nsHTMLEditUtils::SupportsAlignAttr(nodeToExamine))
    1:     {
    1:       // check for alignment
    1:       nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(nodeToExamine);
    1:       if (elem)
    1:       {
    1:         nsAutoString typeAttrVal;
    1:         res = elem->GetAttribute(NS_LITERAL_STRING("align"), typeAttrVal);
    1:         ToLowerCase(typeAttrVal);
    1:         if (NS_SUCCEEDED(res) && typeAttrVal.Length())
    1:         {
    1:           if (typeAttrVal.EqualsLiteral("center"))
    1:             *aAlign = nsIHTMLEditor::eCenter;
    1:           else if (typeAttrVal.EqualsLiteral("right"))
    1:             *aAlign = nsIHTMLEditor::eRight;
    1:           else if (typeAttrVal.EqualsLiteral("justify"))
    1:             *aAlign = nsIHTMLEditor::eJustify;
    1:           else
    1:             *aAlign = nsIHTMLEditor::eLeft;
    1:           return res;
    1:         }
    1:       }
    1:     }
    1:     isFirstNodeToExamine = PR_FALSE;
    1:     res = nodeToExamine->GetParentNode(getter_AddRefs(temp));
    1:     if (NS_FAILED(res)) temp = nsnull;
    1:     nodeToExamine = temp; 
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsIAtom* MarginPropertyAtomForIndent(nsHTMLCSSUtils* aHTMLCSSUtils, nsIDOMNode* aNode) {
    1:   nsAutoString direction;
    1:   aHTMLCSSUtils->GetComputedProperty(aNode, nsEditProperty::cssDirection, direction);
    1:   return direction.EqualsLiteral("rtl") ?
    1:     nsEditProperty::cssMarginRight : nsEditProperty::cssMarginLeft;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditRules::GetIndentState(PRBool *aCanIndent, PRBool *aCanOutdent)
    1: {
43807:   NS_ENSURE_TRUE(aCanIndent && aCanOutdent, NS_ERROR_FAILURE);
    1:   *aCanIndent = PR_TRUE;    
    1:   *aCanOutdent = PR_FALSE;
    1: 
    1:   // get selection
    1:   nsCOMPtr<nsISelection>selection;
    1:   nsresult res = mHTMLEditor->GetSelection(getter_AddRefs(selection));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(selection));
43807:   NS_ENSURE_TRUE(selPriv, NS_ERROR_FAILURE);
    1: 
    1:   // contruct a list of nodes to act on.
    1:   nsCOMArray<nsIDOMNode> arrayOfNodes;
    1:   res = GetNodesFromSelection(selection, kIndent, arrayOfNodes, PR_TRUE);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // examine nodes in selection for blockquotes or list elements;
    1:   // these we can outdent.  Note that we return true for canOutdent
    1:   // if *any* of the selection is outdentable, rather than all of it.
    1:   PRInt32 listCount = arrayOfNodes.Count();
    1:   PRInt32 i;
    1:   PRBool useCSS;
    1:   mHTMLEditor->GetIsCSSEnabled(&useCSS);
    1:   for (i=listCount-1; i>=0; i--)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> curNode = arrayOfNodes[i];
    1:     
    1:     if (nsHTMLEditUtils::IsNodeThatCanOutdent(curNode))
    1:     {
    1:       *aCanOutdent = PR_TRUE;
    1:       break;
    1:     }
    1:     else if (useCSS) {
    1:       // we are in CSS mode, indentation is done using the margin-left (or margin-right) property
    1:       nsIAtom* marginProperty = MarginPropertyAtomForIndent(mHTMLEditor->mHTMLCSSUtils, curNode);
    1:       nsAutoString value;
    1:       // retrieve its specified value
    1:       mHTMLEditor->mHTMLCSSUtils->GetSpecifiedProperty(curNode, marginProperty, value);
    1:       float f;
    1:       nsCOMPtr<nsIAtom> unit;
    1:       // get its number part and its unit
    1:       mHTMLEditor->mHTMLCSSUtils->ParseLength(value, &f, getter_AddRefs(unit));
    1:       // if the number part is strictly positive, outdent is possible
    1:       if (0 < f) {
    1:         *aCanOutdent = PR_TRUE;
    1:         break;
    1:       }
    1:     }
    1:   }  
    1:   
    1:   if (!*aCanOutdent)
    1:   {
    1:     // if we haven't found something to outdent yet, also check the parents
    1:     // of selection endpoints.  We might have a blockquote or list item 
41545:     // in the parent hierarchy.
    1:     
    1:     // gather up info we need for test
    1:     nsCOMPtr<nsIDOMNode> parent, tmp, root;
    1:     nsIDOMElement *rootElem = mHTMLEditor->GetRoot();
43806:     NS_ENSURE_TRUE(rootElem, NS_ERROR_NULL_POINTER);
    1:     nsCOMPtr<nsISelection> selection;
    1:     PRInt32 selOffset;
    1:     root = do_QueryInterface(rootElem);
43806:     NS_ENSURE_TRUE(root, NS_ERROR_NO_INTERFACE);
    1:     res = mHTMLEditor->GetSelection(getter_AddRefs(selection));
43805:     NS_ENSURE_SUCCESS(res, res);
43806:     NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
    1:     
    1:     // test start parent hierarchy
43518:     res = mHTMLEditor->GetStartNodeAndOffset(selection, getter_AddRefs(parent), &selOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     while (parent && (parent!=root))
    1:     {
    1:       if (nsHTMLEditUtils::IsNodeThatCanOutdent(parent))
    1:       {
    1:         *aCanOutdent = PR_TRUE;
    1:         break;
    1:       }
    1:       tmp=parent;
    1:       tmp->GetParentNode(getter_AddRefs(parent));
    1:     }
    1: 
    1:     // test end parent hierarchy
43518:     res = mHTMLEditor->GetEndNodeAndOffset(selection, getter_AddRefs(parent), &selOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     while (parent && (parent!=root))
    1:     {
    1:       if (nsHTMLEditUtils::IsNodeThatCanOutdent(parent))
    1:       {
    1:         *aCanOutdent = PR_TRUE;
    1:         break;
    1:       }
    1:       tmp=parent;
    1:       tmp->GetParentNode(getter_AddRefs(parent));
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditRules::GetParagraphState(PRBool *aMixed, nsAString &outFormat)
    1: {
    1:   // This routine is *heavily* tied to our ui choices in the paragraph
    1:   // style popup.  I can't see a way around that.
43807:   NS_ENSURE_TRUE(aMixed, NS_ERROR_NULL_POINTER);
    1:   *aMixed = PR_TRUE;
    1:   outFormat.Truncate(0);
    1:   
    1:   PRBool bMixed = PR_FALSE;
    1:   // using "x" as an uninitialized value, since "" is meaningful
    1:   nsAutoString formatStr(NS_LITERAL_STRING("x")); 
    1:   
    1:   nsCOMArray<nsIDOMNode> arrayOfNodes;
    1:   nsresult res = GetParagraphFormatNodes(arrayOfNodes, PR_TRUE);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // post process list.  We need to replace any block nodes that are not format
41545:   // nodes with their content.  This is so we only have to look "up" the hierarchy
    1:   // to find format nodes, instead of both up and down.
    1:   PRInt32 listCount = arrayOfNodes.Count();
    1:   PRInt32 i;
    1:   for (i=listCount-1; i>=0; i--)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> curNode = arrayOfNodes[i];
    1:     nsAutoString format;
    1:     // if it is a known format node we have it easy
    1:     if (IsBlockNode(curNode) && !nsHTMLEditUtils::IsFormatNode(curNode))
    1:     {
    1:       // arrayOfNodes.RemoveObject(curNode);
    1:       res = AppendInnerFormatNodes(arrayOfNodes, curNode);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:   }
    1:   
    1:   // we might have an empty node list.  if so, find selection parent
    1:   // and put that on the list
    1:   listCount = arrayOfNodes.Count();
    1:   if (!listCount)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> selNode;
    1:     PRInt32 selOffset;
    1:     nsCOMPtr<nsISelection>selection;
    1:     res = mHTMLEditor->GetSelection(getter_AddRefs(selection));
43805:     NS_ENSURE_SUCCESS(res, res);
43518:     res = mHTMLEditor->GetStartNodeAndOffset(selection, getter_AddRefs(selNode), &selOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
43806:     NS_ENSURE_TRUE(selNode, NS_ERROR_NULL_POINTER);
    1:     arrayOfNodes.AppendObject(selNode);
    1:     listCount = 1;
    1:   }
    1: 
    1:   // remember root node
    1:   nsIDOMElement *rootElem = mHTMLEditor->GetRoot();
43806:   NS_ENSURE_TRUE(rootElem, NS_ERROR_NULL_POINTER);
    1: 
    1:   // loop through the nodes in selection and examine their paragraph format
    1:   for (i=listCount-1; i>=0; i--)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> curNode = arrayOfNodes[i];
    1:     nsAutoString format;
    1:     // if it is a known format node we have it easy
    1:     if (nsHTMLEditUtils::IsFormatNode(curNode))
    1:       GetFormatString(curNode, format);
    1:     else if (IsBlockNode(curNode))
    1:     {
    1:       // this is a div or some other non-format block.
    1:       // we should ignore it.  It's children were appended to this list
    1:       // by AppendInnerFormatNodes() call above.  We will get needed
    1:       // info when we examine them instead.
    1:       continue;
    1:     }
    1:     else
    1:     {
    1:       nsCOMPtr<nsIDOMNode> node, tmp = curNode;
    1:       tmp->GetParentNode(getter_AddRefs(node));
    1:       while (node)
    1:       {
    1:         if (node == rootElem)
    1:         {
    1:           format.Truncate(0);
    1:           break;
    1:         }
    1:         else if (nsHTMLEditUtils::IsFormatNode(node))
    1:         {
    1:           GetFormatString(node, format);
    1:           break;
    1:         }
    1:         // else keep looking up
    1:         tmp = node;
    1:         tmp->GetParentNode(getter_AddRefs(node));
    1:       }
    1:     }
    1:     
    1:     // if this is the first node, we've found, remember it as the format
    1:     if (formatStr.EqualsLiteral("x"))
    1:       formatStr = format;
    1:     // else make sure it matches previously found format
    1:     else if (format != formatStr) 
    1:     {
    1:       bMixed = PR_TRUE;
    1:       break; 
    1:     }
    1:   }  
    1:   
    1:   *aMixed = bMixed;
    1:   outFormat = formatStr;
    1:   return res;
    1: }
    1: 
    1: nsresult 
    1: nsHTMLEditRules::AppendInnerFormatNodes(nsCOMArray<nsIDOMNode>& aArray,
    1:                                         nsIDOMNode *aNode)
    1: {
43806:   NS_ENSURE_TRUE(aNode, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsCOMPtr<nsIDOMNodeList> childList;
    1:   nsCOMPtr<nsIDOMNode> child;
    1: 
    1:   aNode->GetChildNodes(getter_AddRefs(childList));
43806:   NS_ENSURE_TRUE(childList, NS_OK);
    1:   PRUint32 len, j=0;
    1:   childList->GetLength(&len);
    1: 
    1:   // we only need to place any one inline inside this node onto 
    1:   // the list.  They are all the same for purposes of determining
    1:   // paragraph style.  We use foundInline to track this as we are 
    1:   // going through the children in the loop below.
    1:   PRBool foundInline = PR_FALSE;
    1:   while (j < len)
    1:   {
    1:     childList->Item(j, getter_AddRefs(child));
    1:     PRBool isBlock = IsBlockNode(child);
    1:     PRBool isFormat = nsHTMLEditUtils::IsFormatNode(child);
    1:     if (isBlock && !isFormat)  // if it's a div, etc, recurse
    1:       AppendInnerFormatNodes(aArray, child);
    1:     else if (isFormat)
    1:     {
    1:       aArray.AppendObject(child);
    1:     }
    1:     else if (!foundInline)  // if this is the first inline we've found, use it
    1:     {
    1:       foundInline = PR_TRUE;      
    1:       aArray.AppendObject(child);
    1:     }
    1:     j++;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult 
    1: nsHTMLEditRules::GetFormatString(nsIDOMNode *aNode, nsAString &outFormat)
    1: {
43806:   NS_ENSURE_TRUE(aNode, NS_ERROR_NULL_POINTER);
    1: 
    1:   if (nsHTMLEditUtils::IsFormatNode(aNode))
    1:   {
    1:     nsCOMPtr<nsIAtom> atom = nsEditor::GetTag(aNode);
    1:     atom->ToString(outFormat);
    1:   }
    1:   else
    1:     outFormat.Truncate();
    1: 
    1:   return NS_OK;
    1: }    
    1: 
    1: /********************************************************
    1:  *  Protected rules methods 
    1:  ********************************************************/
    1: 
    1: nsresult
    1: nsHTMLEditRules::WillInsert(nsISelection *aSelection, PRBool *aCancel)
    1: {
    1:   nsresult res = nsTextEditRules::WillInsert(aSelection, aCancel);
43805:   NS_ENSURE_SUCCESS(res, res); 
    1:   
    1:   // Adjust selection to prevent insertion after a moz-BR.
    1:   // this next only works for collapsed selections right now,
    1:   // because selection is a pain to work with when not collapsed.
    1:   // (no good way to extend start or end of selection)
    1:   PRBool bCollapsed;
    1:   res = aSelection->GetIsCollapsed(&bCollapsed);
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(bCollapsed, NS_OK);
    1: 
    1:   // if we are after a mozBR in the same block, then move selection
    1:   // to be before it
    1:   nsCOMPtr<nsIDOMNode> selNode, priorNode;
    1:   PRInt32 selOffset;
    1:   // get the (collapsed) selection location
43518:   res = mHTMLEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(selNode),
    1:                                            &selOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   // get prior node
    1:   res = mHTMLEditor->GetPriorHTMLNode(selNode, selOffset,
    1:                                       address_of(priorNode));
    1:   if (NS_SUCCEEDED(res) && priorNode && nsTextEditUtils::IsMozBR(priorNode))
    1:   {
    1:     nsCOMPtr<nsIDOMNode> block1, block2;
    1:     if (IsBlockNode(selNode)) block1 = selNode;
    1:     else block1 = mHTMLEditor->GetBlockNodeParent(selNode);
    1:     block2 = mHTMLEditor->GetBlockNodeParent(priorNode);
    1:   
    1:     if (block1 == block2)
    1:     {
    1:       // if we are here then the selection is right after a mozBR
    1:       // that is in the same block as the selection.  We need to move
    1:       // the selection start to be before the mozBR.
    1:       res = nsEditor::GetNodeLocation(priorNode, address_of(selNode), &selOffset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = aSelection->Collapse(selNode,selOffset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:   }
    1: 
    1:   // we need to get the doc
    1:   nsCOMPtr<nsIDOMDocument>doc;
    1:   res = mHTMLEditor->GetDocument(getter_AddRefs(doc));
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(doc, NS_ERROR_NULL_POINTER);
    1:     
    1:   // for every property that is set, insert a new inline style node
    1:   return CreateStyleForInsertText(aSelection, doc);
    1: }    
    1: 
    1: #ifdef XXX_DEAD_CODE
    1: nsresult
    1: nsHTMLEditRules::DidInsert(nsISelection *aSelection, nsresult aResult)
    1: {
    1:   return nsTextEditRules::DidInsert(aSelection, aResult);
    1: }
    1: #endif
    1: 
    1: nsresult
    1: nsHTMLEditRules::WillInsertText(PRInt32          aAction,
    1:                                 nsISelection *aSelection, 
    1:                                 PRBool          *aCancel,
    1:                                 PRBool          *aHandled,
    1:                                 const nsAString *inString,
    1:                                 nsAString       *outString,
    1:                                 PRInt32          aMaxLength)
    1: {  
    1:   if (!aSelection || !aCancel || !aHandled) { return NS_ERROR_NULL_POINTER; }
    1: 
    1: 
    1: 
    1:   if (inString->IsEmpty() && (aAction != kInsertTextIME))
    1:   {
    1:     // HACK: this is a fix for bug 19395
    1:     // I can't outlaw all empty insertions
    1:     // because IME transaction depend on them
    1:     // There is more work to do to make the 
    1:     // world safe for IME.
    1:     *aCancel = PR_TRUE;
    1:     *aHandled = PR_FALSE;
    1:     return NS_OK;
    1:   }
    1:   
    1:   // initialize out param
    1:   *aCancel = PR_FALSE;
    1:   *aHandled = PR_TRUE;
    1:   nsresult res;
    1:   nsCOMPtr<nsIDOMNode> selNode;
    1:   PRInt32 selOffset;
    1: 
    1:   // if the selection isn't collapsed, delete it.
    1:   PRBool bCollapsed;
    1:   res = aSelection->GetIsCollapsed(&bCollapsed);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (!bCollapsed)
    1:   {
    1:     res = mHTMLEditor->DeleteSelection(nsIEditor::eNone);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1: 
    1:   res = WillInsert(aSelection, aCancel);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   // initialize out param
    1:   // we want to ignore result of WillInsert()
    1:   *aCancel = PR_FALSE;
    1:   
    1:   // get the (collapsed) selection location
43518:   res = mHTMLEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(selNode), &selOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // dont put text in places that can't have it
    1:   if (!mHTMLEditor->IsTextNode(selNode) &&
    1:       !mHTMLEditor->CanContainTag(selNode, NS_LITERAL_STRING("#text")))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // we need to get the doc
    1:   nsCOMPtr<nsIDOMDocument>doc;
    1:   res = mHTMLEditor->GetDocument(getter_AddRefs(doc));
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(doc, NS_ERROR_NULL_POINTER);
    1:     
    1:   if (aAction == kInsertTextIME) 
    1:   { 
    1:     // Right now the nsWSRunObject code bails on empty strings, but IME needs 
    1:     // the InsertTextImpl() call to still happen since empty strings are meaningful there.
    1:     if (inString->IsEmpty())
    1:     {
    1:       res = mHTMLEditor->InsertTextImpl(*inString, address_of(selNode), &selOffset, doc);
    1:     }
    1:     else
    1:     {
    1:       nsWSRunObject wsObj(mHTMLEditor, selNode, selOffset);
    1:       res = wsObj.InsertText(*inString, address_of(selNode), &selOffset, doc);
    1:     }
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   else // aAction == kInsertText
    1:   {
    1:     // find where we are
    1:     nsCOMPtr<nsIDOMNode> curNode = selNode;
    1:     PRInt32 curOffset = selOffset;
    1:     
    1:     // is our text going to be PREformatted?  
    1:     // We remember this so that we know how to handle tabs.
    1:     PRBool isPRE;
    1:     res = mHTMLEditor->IsPreformatted(selNode, &isPRE);
43805:     NS_ENSURE_SUCCESS(res, res);    
    1:     
    1:     // turn off the edit listener: we know how to
    1:     // build the "doc changed range" ourselves, and it's
    1:     // must faster to do it once here than to track all
    1:     // the changes one at a time.
    1:     nsAutoLockListener lockit(&mListenerEnabled); 
    1:     
    1:     // don't spaz my selection in subtransactions
    1:     nsAutoTxnsConserveSelection dontSpazMySelection(mHTMLEditor);
    1:     nsAutoString tString(*inString);
    1:     const PRUnichar *unicodeBuf = tString.get();
    1:     nsCOMPtr<nsIDOMNode> unused;
    1:     PRInt32 pos = 0;
    1:     NS_NAMED_LITERAL_STRING(newlineStr, LFSTR);
    1:         
    1:     // for efficiency, break out the pre case separately.  This is because
    1:     // its a lot cheaper to search the input string for only newlines than
    1:     // it is to search for both tabs and newlines.
40703:     if (isPRE || IsPlaintextEditor())
    1:     {
    1:       while (unicodeBuf && (pos != -1) && (pos < (PRInt32)(*inString).Length()))
    1:       {
    1:         PRInt32 oldPos = pos;
    1:         PRInt32 subStrLen;
    1:         pos = tString.FindChar(nsCRT::LF, oldPos);
    1: 
    1:         if (pos != -1) 
    1:         {
    1:           subStrLen = pos - oldPos;
    1:           // if first char is newline, then use just it
    1:           if (subStrLen == 0)
    1:             subStrLen = 1;
    1:         }
    1:         else
    1:         {
    1:           subStrLen = tString.Length() - oldPos;
    1:           pos = tString.Length();
    1:         }
    1: 
    1:         nsDependentSubstring subStr(tString, oldPos, subStrLen);
    1:         
    1:         // is it a return?
    1:         if (subStr.Equals(newlineStr))
    1:         {
    1:           res = mHTMLEditor->CreateBRImpl(address_of(curNode), &curOffset, address_of(unused), nsIEditor::eNone);
    1:           pos++;
    1:         }
    1:         else
    1:         {
    1:           res = mHTMLEditor->InsertTextImpl(subStr, address_of(curNode), &curOffset, doc);
    1:         }
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:     }
    1:     else
    1:     {
    1:       NS_NAMED_LITERAL_STRING(tabStr, "\t");
    1:       NS_NAMED_LITERAL_STRING(spacesStr, "    ");
    1:       char specialChars[] = {TAB, nsCRT::LF, 0};
    1:       while (unicodeBuf && (pos != -1) && (pos < (PRInt32)inString->Length()))
    1:       {
    1:         PRInt32 oldPos = pos;
    1:         PRInt32 subStrLen;
    1:         pos = tString.FindCharInSet(specialChars, oldPos);
    1:         
    1:         if (pos != -1) 
    1:         {
    1:           subStrLen = pos - oldPos;
    1:           // if first char is newline, then use just it
    1:           if (subStrLen == 0)
    1:             subStrLen = 1;
    1:         }
    1:         else
    1:         {
    1:           subStrLen = tString.Length() - oldPos;
    1:           pos = tString.Length();
    1:         }
    1: 
    1:         nsDependentSubstring subStr(tString, oldPos, subStrLen);
    1:         nsWSRunObject wsObj(mHTMLEditor, curNode, curOffset);
    1: 
    1:         // is it a tab?
    1:         if (subStr.Equals(tabStr))
    1:         {
    1:           res = wsObj.InsertText(spacesStr, address_of(curNode), &curOffset, doc);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           pos++;
    1:         }
    1:         // is it a return?
    1:         else if (subStr.Equals(newlineStr))
    1:         {
    1:           res = wsObj.InsertBreak(address_of(curNode), &curOffset, address_of(unused), nsIEditor::eNone);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           pos++;
    1:         }
    1:         else
    1:         {
    1:           res = wsObj.InsertText(subStr, address_of(curNode), &curOffset, doc);
43805:           NS_ENSURE_SUCCESS(res, res);
43805:         }
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:     }
    1:     nsCOMPtr<nsISelection> selection(aSelection);
    1:     nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(selection));
    1:     selPriv->SetInterlinePosition(PR_FALSE);
    1:     if (curNode) aSelection->Collapse(curNode, curOffset);
    1:     // manually update the doc changed range so that AfterEdit will clean up
    1:     // the correct portion of the document.
    1:     if (!mDocChangeRange)
    1:     {
    1:       mDocChangeRange = do_CreateInstance("@mozilla.org/content/range;1");
43806:       NS_ENSURE_TRUE(mDocChangeRange, NS_ERROR_NULL_POINTER);
    1:     }
    1:     res = mDocChangeRange->SetStart(selNode, selOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (curNode)
    1:       res = mDocChangeRange->SetEnd(curNode, curOffset);
    1:     else
    1:       res = mDocChangeRange->SetEnd(selNode, selOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   return res;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditRules::WillLoadHTML(nsISelection *aSelection, PRBool *aCancel)
    1: {
43806:   NS_ENSURE_TRUE(aSelection && aCancel, NS_ERROR_NULL_POINTER);
    1: 
    1:   *aCancel = PR_FALSE;
    1: 
    1:   // Delete mBogusNode if it exists. If we really need one,
    1:   // it will be added during post-processing in AfterEditInner().
    1: 
    1:   if (mBogusNode)
    1:   {
    1:     mEditor->DeleteNode(mBogusNode);
    1:     mBogusNode = nsnull;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditRules::WillInsertBreak(nsISelection *aSelection, PRBool *aCancel, PRBool *aHandled)
    1: {
    1:   if (!aSelection || !aCancel || !aHandled) { return NS_ERROR_NULL_POINTER; }
    1:   // initialize out param
    1:   *aCancel = PR_FALSE;
    1:   *aHandled = PR_FALSE;
    1: 
    1:   // if the selection isn't collapsed, delete it.
    1:   PRBool bCollapsed;
    1:   nsresult res = aSelection->GetIsCollapsed(&bCollapsed);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (!bCollapsed)
    1:   {
    1:     res = mHTMLEditor->DeleteSelection(nsIEditor::eNone);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   
    1:   res = WillInsert(aSelection, aCancel);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   // initialize out param
    1:   // we want to ignore result of WillInsert()
    1:   *aCancel = PR_FALSE;
    1:   
    1:   // split any mailcites in the way.
    1:   // should we abort this if we encounter table cell boundaries?
40703:   if (IsMailEditor())
40703:   {
40703:     res = SplitMailCites(aSelection, IsPlaintextEditor(), aHandled);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (*aHandled) return NS_OK;
    1:   }
    1: 
    1:   // smart splitting rules
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   PRInt32 offset;
    1:   
43518:   res = mHTMLEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(node), &offset);
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
    1:     
    1:   // identify the block
    1:   nsCOMPtr<nsIDOMNode> blockParent;
    1:   
    1:   if (IsBlockNode(node)) 
    1:     blockParent = node;
    1:   else 
    1:     blockParent = mHTMLEditor->GetBlockNodeParent(node);
    1:     
43806:   NS_ENSURE_TRUE(blockParent, NS_ERROR_FAILURE);
    1:   
 2896:   // do nothing if the node is read-only
 2896:   if (!mHTMLEditor->IsModifiableNode(blockParent))
 2896:   {
 2896:     *aCancel = PR_TRUE;
 2896:     return NS_OK;
 2896:   }
 2896: 
    1:   // if block is empty, populate with br.
    1:   // (for example, imagine a div that contains the word "text".  the user selects
    1:   // "text" and types return.  "text" is deleted leaving an empty block.  we want
    1:   // to put in one br to make block have a line.  then code further below will put 
    1:   // in a second br.)
    1:   PRBool isEmpty;
    1:   res = IsEmptyBlock(blockParent, &isEmpty);
    1:   if (isEmpty)
    1:   {
    1:     PRUint32 blockLen;
    1:     res = mHTMLEditor->GetLengthOfDOMNode(blockParent, blockLen);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     nsCOMPtr<nsIDOMNode> brNode;
    1:     res = mHTMLEditor->CreateBR(blockParent, blockLen, address_of(brNode));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   
    1:   nsCOMPtr<nsIDOMNode> listItem = IsInListItem(blockParent);
    1:   if (listItem)
    1:   {
    1:     res = ReturnInListItem(aSelection, listItem, node, offset);
    1:     *aHandled = PR_TRUE;
    1:     return NS_OK;
    1:   }
    1:   
    1:   // headers: close (or split) header
    1:   else if (nsHTMLEditUtils::IsHeader(blockParent))
    1:   {
    1:     res = ReturnInHeader(aSelection, blockParent, node, offset);
    1:     *aHandled = PR_TRUE;
    1:     return NS_OK;
    1:   }
    1:   
    1:   // paragraphs: special rules to look for <br>s
    1:   else if (nsHTMLEditUtils::IsParagraph(blockParent))
    1:   {
    1:     res = ReturnInParagraph(aSelection, blockParent, node, offset, aCancel, aHandled);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     // fall through, we may not have handled it in ReturnInParagraph()
    1:   }
    1:   
    1:   // if not already handled then do the standard thing
    1:   if (!(*aHandled))
    1:   {
    1:     res = StandardBreakImpl(node, offset, aSelection);
    1:     *aHandled = PR_TRUE;
    1:   }
    1:   return res;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditRules::StandardBreakImpl(nsIDOMNode *aNode, PRInt32 aOffset, nsISelection *aSelection)
    1: {
    1:   nsCOMPtr<nsIDOMNode> brNode;
    1:   PRBool bAfterBlock = PR_FALSE;
    1:   PRBool bBeforeBlock = PR_FALSE;
    1:   nsresult res = NS_OK;
    1:   nsCOMPtr<nsIDOMNode> node(aNode);
    1:   nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(aSelection));
    1:   
40703:   if (IsPlaintextEditor())
    1:   {
    1:     res = mHTMLEditor->CreateBR(node, aOffset, address_of(brNode));
    1:   }
    1:   else
    1:   {
    1:     nsWSRunObject wsObj(mHTMLEditor, node, aOffset);
    1:     nsCOMPtr<nsIDOMNode> visNode, linkNode;
    1:     PRInt32 visOffset=0, newOffset;
    1:     PRInt16 wsType;
    1:     res = wsObj.PriorVisibleNode(node, aOffset, address_of(visNode), &visOffset, &wsType);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (wsType & nsWSRunObject::eBlock)
    1:       bAfterBlock = PR_TRUE;
    1:     res = wsObj.NextVisibleNode(node, aOffset, address_of(visNode), &visOffset, &wsType);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (wsType & nsWSRunObject::eBlock)
    1:       bBeforeBlock = PR_TRUE;
    1:     if (mHTMLEditor->IsInLink(node, address_of(linkNode)))
    1:     {
    1:       // split the link
    1:       nsCOMPtr<nsIDOMNode> linkParent;
    1:       res = linkNode->GetParentNode(getter_AddRefs(linkParent));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = mHTMLEditor->SplitNodeDeep(linkNode, node, aOffset, &newOffset, PR_TRUE);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       // reset {node,aOffset} to the point where link was split
    1:       node = linkParent;
    1:       aOffset = newOffset;
    1:     }
    1:     res = wsObj.InsertBreak(address_of(node), &aOffset, address_of(brNode), nsIEditor::eNone);
    1:   }
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = nsEditor::GetNodeLocation(brNode, address_of(node), &aOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (bAfterBlock && bBeforeBlock)
    1:   {
    1:     // we just placed a br between block boundaries.  
    1:     // This is the one case where we want the selection to be before 
    1:     // the br we just placed, as the br will be on a new line,
    1:     // rather than at end of prior line.
    1:     selPriv->SetInterlinePosition(PR_TRUE);
    1:     res = aSelection->Collapse(node, aOffset);
    1:   }
    1:   else
    1:   {
    1:      nsWSRunObject wsObj(mHTMLEditor, node, aOffset+1);
    1:      nsCOMPtr<nsIDOMNode> secondBR;
    1:      PRInt32 visOffset=0;
    1:      PRInt16 wsType;
    1:      res = wsObj.NextVisibleNode(node, aOffset+1, address_of(secondBR), &visOffset, &wsType);
43805:      NS_ENSURE_SUCCESS(res, res);
    1:      if (wsType==nsWSRunObject::eBreak)
    1:      {
    1:        // the next thing after the break we inserted is another break.  Move the 2nd 
    1:        // break to be the first breaks sibling.  This will prevent them from being
    1:        // in different inline nodes, which would break SetInterlinePosition().  It will
    1:        // also assure that if the user clicks away and then clicks back on their new
    1:        // blank line, they will still get the style from the line above.  
    1:        nsCOMPtr<nsIDOMNode> brParent;
    1:        PRInt32 brOffset;
    1:        res = nsEditor::GetNodeLocation(secondBR, address_of(brParent), &brOffset);
43805:        NS_ENSURE_SUCCESS(res, res);
    1:        if ((brParent != node) || (brOffset != (aOffset+1)))
    1:        {
    1:          res = mHTMLEditor->MoveNode(secondBR, node, aOffset+1);
43805:          NS_ENSURE_SUCCESS(res, res);
    1:        }
    1:      }
    1:     // SetInterlinePosition(PR_TRUE) means we want the caret to stick to the content on the "right".
    1:     // We want the caret to stick to whatever is past the break.  This is
    1:     // because the break is on the same line we were on, but the next content
    1:     // will be on the following line.
    1:     
    1:     // An exception to this is if the break has a next sibling that is a block node.
    1:     // Then we stick to the left to avoid an uber caret.
    1:     nsCOMPtr<nsIDOMNode> siblingNode;
    1:     brNode->GetNextSibling(getter_AddRefs(siblingNode));
    1:     if (siblingNode && IsBlockNode(siblingNode))
    1:       selPriv->SetInterlinePosition(PR_FALSE);
    1:     else 
    1:       selPriv->SetInterlinePosition(PR_TRUE);
    1:     res = aSelection->Collapse(node, aOffset+1);
    1:   }
    1:   return res;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditRules::DidInsertBreak(nsISelection *aSelection, nsresult aResult)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsHTMLEditRules::SplitMailCites(nsISelection *aSelection, PRBool aPlaintext, PRBool *aHandled)
    1: {
43807:   NS_ENSURE_TRUE(aSelection && aHandled, NS_ERROR_NULL_POINTER);
    1:   nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(aSelection));
    1:   nsCOMPtr<nsIDOMNode> citeNode, selNode, leftCite, rightCite;
    1:   PRInt32 selOffset, newOffset;
43518:   nsresult res = mHTMLEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(selNode), &selOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = GetTopEnclosingMailCite(selNode, address_of(citeNode), aPlaintext);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (citeNode)
    1:   {
    1:     // If our selection is just before a break, nudge it to be
    1:     // just after it.  This does two things for us.  It saves us the trouble of having to add
    1:     // a break here ourselves to preserve the "blockness" of the inline span mailquote
    1:     // (in the inline case), and :
    1:     // it means the break won't end up making an empty line that happens to be inside a
    1:     // mailquote (in either inline or block case).  
    1:     // The latter can confuse a user if they click there and start typing,
    1:     // because being in the mailquote may affect wrapping behavior, or font color, etc.
    1:     nsWSRunObject wsObj(mHTMLEditor, selNode, selOffset);
    1:     nsCOMPtr<nsIDOMNode> visNode;
    1:     PRInt32 visOffset=0;
    1:     PRInt16 wsType;
    1:     res = wsObj.NextVisibleNode(selNode, selOffset, address_of(visNode), &visOffset, &wsType);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (wsType==nsWSRunObject::eBreak)
    1:     {
    1:       // ok, we are just before a break.  is it inside the mailquote?
    1:       PRInt32 unused;
    1:       if (nsEditorUtils::IsDescendantOf(visNode, citeNode, &unused))
    1:       {
    1:         // it is.  so lets reset our selection to be just after it.
    1:         res = mHTMLEditor->GetNodeLocation(visNode, address_of(selNode), &selOffset);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         ++selOffset;
    1:       }
    1:     }
    1:      
    1:     nsCOMPtr<nsIDOMNode> brNode;
    1:     res = mHTMLEditor->SplitNodeDeep(citeNode, selNode, selOffset, &newOffset, 
    1:                        PR_TRUE, address_of(leftCite), address_of(rightCite));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     res = citeNode->GetParentNode(getter_AddRefs(selNode));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     res = mHTMLEditor->CreateBR(selNode, newOffset, address_of(brNode));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     // want selection before the break, and on same line
    1:     selPriv->SetInterlinePosition(PR_TRUE);
    1:     res = aSelection->Collapse(selNode, newOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     // if citeNode wasn't a block, we might also want another break before it.
    1:     // We need to examine the content both before the br we just added and also
    1:     // just after it.  If we don't have another br or block boundary adjacent,
    1:     // then we will need a 2nd br added to achieve blank line that user expects.
    1:     if (IsInlineNode(citeNode))
    1:     {
    1:       nsWSRunObject wsObj(mHTMLEditor, selNode, newOffset);
    1:       nsCOMPtr<nsIDOMNode> visNode;
    1:       PRInt32 visOffset=0;
    1:       PRInt16 wsType;
    1:       res = wsObj.PriorVisibleNode(selNode, newOffset, address_of(visNode), &visOffset, &wsType);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       if ((wsType==nsWSRunObject::eNormalWS) || 
    1:           (wsType==nsWSRunObject::eText)     ||
    1:           (wsType==nsWSRunObject::eSpecial))
    1:       {
    1:         nsWSRunObject wsObjAfterBR(mHTMLEditor, selNode, newOffset+1);
    1:         res = wsObjAfterBR.NextVisibleNode(selNode, newOffset+1, address_of(visNode), &visOffset, &wsType);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         if ((wsType==nsWSRunObject::eNormalWS) || 
    1:             (wsType==nsWSRunObject::eText)     ||
    1:             (wsType==nsWSRunObject::eSpecial))
    1:         {
    1:           res = mHTMLEditor->CreateBR(selNode, newOffset, address_of(brNode));
43805:           NS_ENSURE_SUCCESS(res, res);
    1:         }
    1:       }
    1:     }
    1:     // delete any empty cites
    1:     PRBool bEmptyCite = PR_FALSE;
    1:     if (leftCite)
    1:     {
    1:       res = mHTMLEditor->IsEmptyNode(leftCite, &bEmptyCite, PR_TRUE, PR_FALSE);
    1:       if (NS_SUCCEEDED(res) && bEmptyCite)
    1:         res = mHTMLEditor->DeleteNode(leftCite);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     if (rightCite)
    1:     {
    1:       res = mHTMLEditor->IsEmptyNode(rightCite, &bEmptyCite, PR_TRUE, PR_FALSE);
    1:       if (NS_SUCCEEDED(res) && bEmptyCite)
    1:         res = mHTMLEditor->DeleteNode(rightCite);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     *aHandled = PR_TRUE;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsHTMLEditRules::WillDeleteSelection(nsISelection *aSelection, 
    1:                                      nsIEditor::EDirection aAction, 
    1:                                      PRBool *aCancel,
    1:                                      PRBool *aHandled)
    1: {
    1: 
    1:   if (!aSelection || !aCancel || !aHandled) { return NS_ERROR_NULL_POINTER; }
    1:   // initialize out param
    1:   *aCancel = PR_FALSE;
    1:   *aHandled = PR_FALSE;
    1: 
    1:   // remember that we did a selection deletion.  Used by CreateStyleForInsertText()
    1:   mDidDeleteSelection = PR_TRUE;
    1:   
    1:   // if there is only bogus content, cancel the operation
    1:   if (mBogusNode) 
    1:   {
    1:     *aCancel = PR_TRUE;
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsresult res = NS_OK;
39735:   PRBool bCollapsed, join = PR_FALSE;
    1:   res = aSelection->GetIsCollapsed(&bCollapsed);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
39735:   // origCollapsed is used later to determine whether we should join 
39735:   // blocks. We don't really care about bCollapsed because it will be 
39735:   // modified by ExtendSelectionForDelete later. JoinBlocks should 
39735:   // happen if the original selection is collapsed and the cursor is 
39735:   // at the end of a block element, in which case ExtendSelectionForDelete 
39735:   // would always make the selection not collapsed.
39735:   PRBool origCollapsed = bCollapsed;
    1:   nsCOMPtr<nsIDOMNode> startNode, selNode;
    1:   PRInt32 startOffset, selOffset;
    1:   
    1:   // first check for table selection mode.  If so,
    1:   // hand off to table editor.
    1:   {
    1:     nsCOMPtr<nsIDOMElement> cell;
    1:     res = mHTMLEditor->GetFirstSelectedCell(nsnull, getter_AddRefs(cell));
    1:     if (NS_SUCCEEDED(res) && cell)
    1:     {
    1:       res = mHTMLEditor->DeleteTableCellContents();
    1:       *aHandled = PR_TRUE;
    1:       return res;
    1:     }
    1:   }
    1:   
43518:   res = mHTMLEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(startNode), &startOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(startNode, NS_ERROR_FAILURE);
    1:     
    1:   // get the root element  
    1:   nsIDOMElement *rootNode = mHTMLEditor->GetRoot();
43806:   NS_ENSURE_TRUE(rootNode, NS_ERROR_UNEXPECTED);
    1: 
    1:   if (bCollapsed)
    1:   {
    1:     // if we are inside an empty block, delete it.
    1:     res = CheckForEmptyBlock(startNode, rootNode, aSelection, aHandled);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (*aHandled) return NS_OK;
    1:         
    1:     // Test for distance between caret and text that will be deleted
    1:     res = CheckBidiLevelForDeletion(aSelection, startNode, startOffset, aAction, aCancel);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (*aCancel) return NS_OK;
    1: 
24233:     res = mHTMLEditor->ExtendSelectionForDelete(aSelection, &aAction);
24233:     NS_ENSURE_SUCCESS(res, res);
24233: 
24169:     // We should delete nothing.
24169:     if (aAction == nsIEditor::eNone)
24169:       return NS_OK;
24169: 
24233:     // ExtendSelectionForDelete() may have changed the selection, update it
43518:     res = mHTMLEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(startNode), &startOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
43806:     NS_ENSURE_TRUE(startNode, NS_ERROR_FAILURE);
24233:     
24233:     res = aSelection->GetIsCollapsed(&bCollapsed);
43805:     NS_ENSURE_SUCCESS(res, res);
24233:   }
24233: 
24233:   if (bCollapsed)
24233:   {
    1:     // what's in the direction we are deleting?
    1:     nsWSRunObject wsObj(mHTMLEditor, startNode, startOffset);
    1:     nsCOMPtr<nsIDOMNode> visNode;
    1:     PRInt32 visOffset;
    1:     PRInt16 wsType;
    1: 
    1:     // find next visible node
    1:     if (aAction == nsIEditor::eNext)
    1:       res = wsObj.NextVisibleNode(startNode, startOffset, address_of(visNode), &visOffset, &wsType);
    1:     else
    1:       res = wsObj.PriorVisibleNode(startNode, startOffset, address_of(visNode), &visOffset, &wsType);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     
    1:     if (!visNode) // can't find anything to delete!
    1:     {
    1:       *aCancel = PR_TRUE;
    1:       return res;
    1:     }
    1:     
    1:     if (wsType==nsWSRunObject::eNormalWS)
    1:     {
    1:       // we found some visible ws to delete.  Let ws code handle it.
    1:       if (aAction == nsIEditor::eNext)
    1:         res = wsObj.DeleteWSForward();
    1:       else
    1:         res = wsObj.DeleteWSBackward();
    1:       *aHandled = PR_TRUE;
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = InsertBRIfNeeded(aSelection);
    1:       return res;
    1:     } 
    1:     else if (wsType==nsWSRunObject::eText)
    1:     {
    1:       // found normal text to delete.  
    1:       PRInt32 so = visOffset;
    1:       PRInt32 eo = visOffset+1;
    1:       if (aAction == nsIEditor::ePrevious) 
    1:       { 
    1:         if (so == 0) return NS_ERROR_UNEXPECTED;
    1:         so--; 
    1:         eo--; 
    1:       }
20532:       else
20532:       {
20532:         nsCOMPtr<nsIDOMRange> range;
20532:         res = aSelection->GetRangeAt(0, getter_AddRefs(range));
20532:         NS_ENSURE_SUCCESS(res, res);
20532: 
20532: #ifdef DEBUG
20532:         nsIDOMNode *container;
20532: 
20532:         res = range->GetStartContainer(&container);
20532:         NS_ENSURE_SUCCESS(res, res);
20532:         NS_ASSERTION(container == visNode, "selection start not in visNode");
20532: 
20532:         res = range->GetEndContainer(&container);
20532:         NS_ENSURE_SUCCESS(res, res);
20532:         NS_ASSERTION(container == visNode, "selection end not in visNode");
20532: #endif
20532: 
24233:         res = range->GetStartOffset(&so);
24233:         NS_ENSURE_SUCCESS(res, res);
20532:         res = range->GetEndOffset(&eo);
20532:         NS_ENSURE_SUCCESS(res, res);
20532:       }
    1:       res = nsWSRunObject::PrepareToDeleteRange(mHTMLEditor, address_of(visNode), &so, address_of(visNode), &eo);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       nsCOMPtr<nsIDOMCharacterData> nodeAsText(do_QueryInterface(visNode));
38053:       res = mHTMLEditor->DeleteText(nodeAsText, NS_MIN(so, eo), PR_ABS(eo - so));
    1:       *aHandled = PR_TRUE;
43805:       NS_ENSURE_SUCCESS(res, res);    
    1:       res = InsertBRIfNeeded(aSelection);
    1:       return res;
    1:     }
    1:     else if ( (wsType==nsWSRunObject::eSpecial)  || 
    1:               (wsType==nsWSRunObject::eBreak)    ||
    1:               nsHTMLEditUtils::IsHR(visNode) ) 
    1:     {
    1:       // short circuit for invisible breaks.  delete them and recurse.
    1:       if (nsTextEditUtils::IsBreak(visNode) && !mHTMLEditor->IsVisBreak(visNode))
    1:       {
    1:         res = mHTMLEditor->DeleteNode(visNode);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         return WillDeleteSelection(aSelection, aAction, aCancel, aHandled);
    1:       }
    1:       
    1:       // special handling for backspace when positioned after <hr>
    1:       if (aAction == nsIEditor::ePrevious && nsHTMLEditUtils::IsHR(visNode))
    1:       {
    1:         /*
    1:           Only if the caret is positioned at the end-of-hr-line position,
    1:           we want to delete the <hr>.
    1:           
    1:           In other words, we only want to delete, if
    1:           our selection position (indicated by startNode and startOffset)
    1:           is the position directly after the <hr>,
    1:           on the same line as the <hr>.
    1: 
    1:           To detect this case we check:
    1:           startNode == parentOfVisNode
    1:           and
    1:           startOffset -1 == visNodeOffsetToVisNodeParent
    1:           and
    1:           interline position is false (left)
    1: 
    1:           In any other case we set the position to 
    1:           startnode -1 and interlineposition to false,
    1:           only moving the caret to the end-of-hr-line position.
    1:         */
    1: 
    1:         PRBool moveOnly = PR_TRUE;
    1: 
    1:         res = nsEditor::GetNodeLocation(visNode, address_of(selNode), &selOffset);
43805:         NS_ENSURE_SUCCESS(res, res);
    1: 
    1:         PRBool interLineIsRight;
    1:         nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(aSelection));
    1:         res = selPriv->GetInterlinePosition(&interLineIsRight);
43805:         NS_ENSURE_SUCCESS(res, res);
    1: 
    1:         if (startNode == selNode &&
    1:             startOffset -1 == selOffset &&
    1:             !interLineIsRight)
    1:         {
    1:           moveOnly = PR_FALSE;
    1:         }
    1:         
    1:         if (moveOnly)
    1:         {
    1:           // Go to the position after the <hr>, but to the end of the <hr> line
    1:           // by setting the interline position to left.
    1:           ++selOffset;
    1:           res = aSelection->Collapse(selNode, selOffset);
    1:           selPriv->SetInterlinePosition(PR_FALSE);
    1:           mDidExplicitlySetInterline = PR_TRUE;
    1:           *aHandled = PR_TRUE;
    1: 
    1:           // There is one exception to the move only case.
    1:           // If the <hr> is followed by a <br> we want to delete the <br>.
    1: 
    1:           PRInt16 otherWSType;
    1:           nsCOMPtr<nsIDOMNode> otherNode;
    1:           PRInt32 otherOffset;
    1: 
    1:           res = wsObj.NextVisibleNode(startNode, startOffset, address_of(otherNode), &otherOffset, &otherWSType);
43805:           NS_ENSURE_SUCCESS(res, res);
    1: 
    1:           if (otherWSType == nsWSRunObject::eBreak)
    1:           {
    1:             // Delete the <br>
    1: 
    1:             res = nsWSRunObject::PrepareToDeleteNode(mHTMLEditor, otherNode);
43805:             NS_ENSURE_SUCCESS(res, res);
    1:             res = mHTMLEditor->DeleteNode(otherNode);
43805:             NS_ENSURE_SUCCESS(res, res);
    1:           }
    1: 
    1:           return NS_OK;
    1:         }
    1:         // else continue with normal delete code
    1:       }
    1: 
    1:       // found break or image, or hr.  
    1:       res = nsWSRunObject::PrepareToDeleteNode(mHTMLEditor, visNode);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       // remember sibling to visnode, if any
    1:       nsCOMPtr<nsIDOMNode> sibling, stepbrother;
    1:       mHTMLEditor->GetPriorHTMLSibling(visNode, address_of(sibling));
    1:       // delete the node, and join like nodes if appropriate
    1:       res = mHTMLEditor->DeleteNode(visNode);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       // we did something, so lets say so.
    1:       *aHandled = PR_TRUE;
    1:       // is there a prior node and are they siblings?
    1:       if (sibling)
    1:          mHTMLEditor->GetNextHTMLSibling(sibling, address_of(stepbrother));
    1:       if (startNode == stepbrother) 
    1:       {
    1:         // are they both text nodes?
    1:         if (mHTMLEditor->IsTextNode(startNode) && mHTMLEditor->IsTextNode(sibling))
    1:         {
    1:           // if so, join them!
    1:           res = JoinNodesSmart(sibling, startNode, address_of(selNode), &selOffset);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           // fix up selection
    1:           res = aSelection->Collapse(selNode, selOffset);
    1:         }
    1:       }
43805:       NS_ENSURE_SUCCESS(res, res);    
    1:       res = InsertBRIfNeeded(aSelection);
    1:       return res;
    1:     }
    1:     else if (wsType==nsWSRunObject::eOtherBlock)
    1:     {
    1:       // make sure it's not a table element.  If so, cancel the operation 
    1:       // (translation: users cannot backspace or delete across table cells)
    1:       if (nsHTMLEditUtils::IsTableElement(visNode))
    1:       {
    1:         *aCancel = PR_TRUE;
    1:         return NS_OK;
    1:       }
    1:       
    1:       // next to a block.  See if we are between a block and a br.  If so, we really
    1:       // want to delete the br.  Else join content at selection to the block.
    1:       
    1:       PRBool bDeletedBR = PR_FALSE;
    1:       PRInt16 otherWSType;
    1:       nsCOMPtr<nsIDOMNode> otherNode;
    1:       PRInt32 otherOffset;
    1:       
    1:       // find node in other direction
    1:       if (aAction == nsIEditor::eNext)
    1:         res = wsObj.PriorVisibleNode(startNode, startOffset, address_of(otherNode), &otherOffset, &otherWSType);
    1:       else
    1:         res = wsObj.NextVisibleNode(startNode, startOffset, address_of(otherNode), &otherOffset, &otherWSType);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       
    1:       // first find the adjacent node in the block
    1:       nsCOMPtr<nsIDOMNode> leafNode, leftNode, rightNode, leftParent, rightParent;
    1:       if (aAction == nsIEditor::ePrevious) 
    1:       {
    1:         res = mHTMLEditor->GetLastEditableLeaf( visNode, address_of(leafNode));
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         leftNode = leafNode;
    1:         rightNode = startNode;
    1:       }
    1:       else
    1:       {
    1:         res = mHTMLEditor->GetFirstEditableLeaf( visNode, address_of(leafNode));
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         leftNode = startNode;
    1:         rightNode = leafNode;
    1:       }
    1:       
    1:       if (nsTextEditUtils::IsBreak(otherNode))
    1:       {
    1:         res = mHTMLEditor->DeleteNode(otherNode);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         *aHandled = PR_TRUE;
    1:         bDeletedBR = PR_TRUE;
    1:       }
    1:       
    1:       // don't cross table boundaries
    1:       if (leftNode && rightNode)
    1:       {
    1:         PRBool bInDifTblElems;
    1:         res = InDifferentTableElements(leftNode, rightNode, &bInDifTblElems);
    1:         if (NS_FAILED(res) || bInDifTblElems) return res;
    1:       }
    1:       
    1:       if (bDeletedBR)
    1:       {
    1:         // put selection at edge of block and we are done.
    1:         nsCOMPtr<nsIDOMNode> newSelNode;
    1:         PRInt32 newSelOffset;
    1:         res = GetGoodSelPointForNode(leafNode, aAction, address_of(newSelNode), &newSelOffset);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         aSelection->Collapse(newSelNode, newSelOffset);
    1:         return res;
    1:       }
    1:       
    1:       // else we are joining content to block
    1:       
    1:       // find the relavent blocks
    1:       if (IsBlockNode(leftNode))
    1:         leftParent = leftNode;
    1:       else
    1:         leftParent = mHTMLEditor->GetBlockNodeParent(leftNode);
    1:       if (IsBlockNode(rightNode))
    1:         rightParent = rightNode;
    1:       else
    1:         rightParent = mHTMLEditor->GetBlockNodeParent(rightNode);
    1:       
    1:       // sanity checks
43807:       NS_ENSURE_TRUE(leftParent && rightParent, NS_ERROR_NULL_POINTER);  
    1:       if (leftParent == rightParent)
    1:         return NS_ERROR_UNEXPECTED;  
    1:       
    1:       // now join them
    1:       nsCOMPtr<nsIDOMNode> selPointNode = startNode;
    1:       PRInt32 selPointOffset = startOffset;
    1:       {
    1:         nsAutoTrackDOMPoint tracker(mHTMLEditor->mRangeUpdater, address_of(selPointNode), &selPointOffset);
    1:         res = JoinBlocks(address_of(leftParent), address_of(rightParent), aCancel);
    1:         *aHandled = PR_TRUE;
    1:       }
    1:       aSelection->Collapse(selPointNode, selPointOffset);
    1:       return res;
    1:     }
    1:     else if (wsType==nsWSRunObject::eThisBlock)
    1:     {
    1:       // at edge of our block.  Look beside it and see if we can join to an adjacent block
    1:       
    1:       // make sure it's not a table element.  If so, cancel the operation 
    1:       // (translation: users cannot backspace or delete across table cells)
    1:       if (nsHTMLEditUtils::IsTableElement(visNode))
    1:       {
    1:         *aCancel = PR_TRUE;
    1:         return NS_OK;
    1:       }
    1:       
    1:       // first find the relavent nodes
    1:       nsCOMPtr<nsIDOMNode> leftNode, rightNode, leftParent, rightParent;
    1:       if (aAction == nsIEditor::ePrevious) 
    1:       {
    1:         res = mHTMLEditor->GetPriorHTMLNode(visNode, address_of(leftNode));
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         rightNode = startNode;
    1:       }
    1:       else
    1:       {
    1:         res = mHTMLEditor->GetNextHTMLNode( visNode, address_of(rightNode));
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         leftNode = startNode;
    1:       }
    1: 
    1:       // nothing to join
    1:       if (!leftNode || !rightNode)
    1:       {
    1:         *aCancel = PR_TRUE;
    1:         return NS_OK;
    1:       }
    1: 
    1:       // don't cross table boundaries
    1:       PRBool bInDifTblElems;
    1:       res = InDifferentTableElements(leftNode, rightNode, &bInDifTblElems);
    1:       if (NS_FAILED(res) || bInDifTblElems) return res;
    1: 
    1:       // find the relavent blocks
    1:       if (IsBlockNode(leftNode))
    1:         leftParent = leftNode;
    1:       else
    1:         leftParent = mHTMLEditor->GetBlockNodeParent(leftNode);
    1:       if (IsBlockNode(rightNode))
    1:         rightParent = rightNode;
    1:       else
    1:         rightParent = mHTMLEditor->GetBlockNodeParent(rightNode);
    1:       
    1:       // sanity checks
43807:       NS_ENSURE_TRUE(leftParent && rightParent, NS_ERROR_NULL_POINTER);  
    1:       if (leftParent == rightParent)
    1:         return NS_ERROR_UNEXPECTED;  
    1:       
    1:       // now join them
    1:       nsCOMPtr<nsIDOMNode> selPointNode = startNode;
    1:       PRInt32 selPointOffset = startOffset;
    1:       {
    1:         nsAutoTrackDOMPoint tracker(mHTMLEditor->mRangeUpdater, address_of(selPointNode), &selPointOffset);
    1:         res = JoinBlocks(address_of(leftParent), address_of(rightParent), aCancel);
    1:         *aHandled = PR_TRUE;
    1:       }
    1:       aSelection->Collapse(selPointNode, selPointOffset);
    1:       return res;
    1:     }
    1:   }
    1: 
    1:   
    1:   // else we have a non collapsed selection
    1:   // first adjust the selection
    1:   res = ExpandSelectionForDeletion(aSelection);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   // remember that we did a ranged delete for the benefit of AfterEditInner().
    1:   mDidRangedDelete = PR_TRUE;
    1:   
    1:   // refresh start and end points
43518:   res = mHTMLEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(startNode), &startOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(startNode, NS_ERROR_FAILURE);
    1:   nsCOMPtr<nsIDOMNode> endNode;
    1:   PRInt32 endOffset;
43518:   res = mHTMLEditor->GetEndNodeAndOffset(aSelection, getter_AddRefs(endNode), &endOffset);
43805:   NS_ENSURE_SUCCESS(res, res); 
43806:   NS_ENSURE_TRUE(endNode, NS_ERROR_FAILURE);
    1: 
    1:   // figure out if the endpoints are in nodes that can be merged  
    1:   // adjust surrounding whitespace in preperation to delete selection
40703:   if (!IsPlaintextEditor())
    1:   {
    1:     nsAutoTxnsConserveSelection dontSpazMySelection(mHTMLEditor);
    1:     res = nsWSRunObject::PrepareToDeleteRange(mHTMLEditor,
    1:                                             address_of(startNode), &startOffset, 
    1:                                             address_of(endNode), &endOffset);
43805:     NS_ENSURE_SUCCESS(res, res); 
    1:   }
    1:   
    1:   {
    1:     // track end location of where we are deleting
    1:     nsAutoTrackDOMPoint tracker(mHTMLEditor->mRangeUpdater, address_of(endNode), &endOffset);
    1:     // we are handling all ranged deletions directly now.
    1:     *aHandled = PR_TRUE;
    1:     
    1:     if (endNode == startNode)
    1:     {
    1:       res = mHTMLEditor->DeleteSelectionImpl(aAction);
43805:       NS_ENSURE_SUCCESS(res, res); 
    1:     }
    1:     else
    1:     {
    1:       // figure out mailcite ancestors
    1:       nsCOMPtr<nsIDOMNode> endCiteNode, startCiteNode;
    1:       res = GetTopEnclosingMailCite(startNode, address_of(startCiteNode), 
40703:                                     IsPlaintextEditor());
43805:       NS_ENSURE_SUCCESS(res, res); 
    1:       res = GetTopEnclosingMailCite(endNode, address_of(endCiteNode), 
40703:                                     IsPlaintextEditor());
43805:       NS_ENSURE_SUCCESS(res, res); 
    1:       
    1:       // if we only have a mailcite at one of the two endpoints, set the directionality
    1:       // of the deletion so that the selection will end up outside the mailcite.
    1:       if (startCiteNode && !endCiteNode)
    1:       {
    1:         aAction = nsIEditor::eNext;
    1:       }
    1:       else if (!startCiteNode && endCiteNode)
    1:       {
    1:         aAction = nsIEditor::ePrevious;
    1:       }
    1:       
    1:       // figure out block parents
    1:       nsCOMPtr<nsIDOMNode> leftParent;
    1:       nsCOMPtr<nsIDOMNode> rightParent;
    1:       if (IsBlockNode(startNode))
    1:         leftParent = startNode;
    1:       else
    1:         leftParent = mHTMLEditor->GetBlockNodeParent(startNode);
    1:       if (IsBlockNode(endNode))
    1:         rightParent = endNode;
    1:       else
    1:         rightParent = mHTMLEditor->GetBlockNodeParent(endNode);
    1:         
    1:       // are endpoint block parents the same?  use default deletion
    1:       if (leftParent == rightParent) 
    1:       {
    1:         res = mHTMLEditor->DeleteSelectionImpl(aAction);
    1:       }
    1:       else
    1:       {
    1:         // deleting across blocks
    1:         // are the blocks of same type?
28067:         NS_ENSURE_STATE(leftParent && rightParent);
    1:         
    1:         // are the blocks siblings?
    1:         nsCOMPtr<nsIDOMNode> leftBlockParent;
    1:         nsCOMPtr<nsIDOMNode> rightBlockParent;
    1:         leftParent->GetParentNode(getter_AddRefs(leftBlockParent));
    1:         rightParent->GetParentNode(getter_AddRefs(rightBlockParent));
    1: 
    1:         // MOOSE: this could conceivably screw up a table.. fix me.
    1:         if (   (leftBlockParent == rightBlockParent)
    1:             && (mHTMLEditor->NodesSameType(leftParent, rightParent))  )
    1:         {
    1:           if (nsHTMLEditUtils::IsParagraph(leftParent))
    1:           {
    1:             // first delete the selection
    1:             res = mHTMLEditor->DeleteSelectionImpl(aAction);
43805:             NS_ENSURE_SUCCESS(res, res);
    1:             // then join para's, insert break
    1:             res = mHTMLEditor->JoinNodeDeep(leftParent,rightParent,address_of(selNode),&selOffset);
43805:             NS_ENSURE_SUCCESS(res, res);
    1:             // fix up selection
    1:             res = aSelection->Collapse(selNode,selOffset);
    1:             return res;
    1:           }
    1:           if (nsHTMLEditUtils::IsListItem(leftParent)
    1:               || nsHTMLEditUtils::IsHeader(leftParent))
    1:           {
    1:             // first delete the selection
    1:             res = mHTMLEditor->DeleteSelectionImpl(aAction);
43805:             NS_ENSURE_SUCCESS(res, res);
    1:             // join blocks
    1:             res = mHTMLEditor->JoinNodeDeep(leftParent,rightParent,address_of(selNode),&selOffset);
43805:             NS_ENSURE_SUCCESS(res, res);
    1:             // fix up selection
    1:             res = aSelection->Collapse(selNode,selOffset);
    1:             return res;
    1:           }
    1:         }
    1:         
    1:         // else blocks not same type, or not siblings.  Delete everything except
    1:         // table elements.
    1:         nsCOMPtr<nsIEnumerator> enumerator;
    1:         nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(aSelection));
    1:         res = selPriv->GetEnumerator(getter_AddRefs(enumerator));
43805:         NS_ENSURE_SUCCESS(res, res);
43806:         NS_ENSURE_TRUE(enumerator, NS_ERROR_UNEXPECTED);
    1: 
39735:         join = PR_TRUE;
39735: 
    1:         for (enumerator->First(); NS_OK!=enumerator->IsDone(); enumerator->Next())
    1:         {
    1:           nsCOMPtr<nsISupports> currentItem;
    1:           res = enumerator->CurrentItem(getter_AddRefs(currentItem));
43805:           NS_ENSURE_SUCCESS(res, res);
43806:           NS_ENSURE_TRUE(currentItem, NS_ERROR_UNEXPECTED);
    1: 
    1:           // build a list of nodes in the range
    1:           nsCOMPtr<nsIDOMRange> range( do_QueryInterface(currentItem) );
    1:           nsCOMArray<nsIDOMNode> arrayOfNodes;
    1:           nsTrivialFunctor functor;
    1:           nsDOMSubtreeIterator iter;
    1:           res = iter.Init(range);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           res = iter.AppendList(functor, arrayOfNodes);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:       
    1:           // now that we have the list, delete non table elements
    1:           PRInt32 listCount = arrayOfNodes.Count();
    1:           PRInt32 j;
    1: 
    1:           for (j = 0; j < listCount; j++)
    1:           {
    1:             nsIDOMNode* somenode = arrayOfNodes[0];
    1:             res = DeleteNonTableElements(somenode);
    1:             arrayOfNodes.RemoveObjectAt(0);
39735:             // If something visible is deleted, no need to join.
39735:             // Visible means all nodes except non-visible textnodes and breaks.
39735:             if (join && origCollapsed) {
39735:               if (mHTMLEditor->IsTextNode(somenode)) {
39735:                 mHTMLEditor->IsVisTextNode(somenode, &join, PR_TRUE);
39735:               }
39735:               else {
39735:                 join = nsTextEditUtils::IsBreak(somenode) && 
39735:                        !mHTMLEditor->IsVisBreak(somenode);
39735:               }
39735:             }
    1:           }
    1:         }
    1:         
    1:         // check endopints for possible text deletion.
    1:         // we can assume that if text node is found, we can
    1:         // delete to end or to begining as appropriate,
    1:         // since the case where both sel endpoints in same
    1:         // text node was already handled (we wouldn't be here)
    1:         if ( mHTMLEditor->IsTextNode(startNode) )
    1:         {
    1:           // delete to last character
    1:           nsCOMPtr<nsIDOMCharacterData>nodeAsText;
    1:           PRUint32 len;
    1:           nodeAsText = do_QueryInterface(startNode);
    1:           nodeAsText->GetLength(&len);
    1:           if (len > (PRUint32)startOffset)
    1:           {
    1:             res = mHTMLEditor->DeleteText(nodeAsText,startOffset,len-startOffset);
43805:             NS_ENSURE_SUCCESS(res, res);
    1:           }
    1:         }
    1:         if ( mHTMLEditor->IsTextNode(endNode) )
    1:         {
    1:           // delete to first character
    1:           nsCOMPtr<nsIDOMCharacterData>nodeAsText;
    1:           nodeAsText = do_QueryInterface(endNode);
    1:           if (endOffset)
    1:           {
    1:             res = mHTMLEditor->DeleteText(nodeAsText,0,endOffset);
43805:             NS_ENSURE_SUCCESS(res, res);
    1:           }
    1:         }
20532: 
20532:         if (join) {
20532:           res = JoinBlocks(address_of(leftParent), address_of(rightParent),
20532:                            aCancel);
43805:           NS_ENSURE_SUCCESS(res, res);
20532:         }
    1:       }
    1:     }
    1:   }
39735:   //If we're joining blocks: if deleting forward the selection should be 
39735:   //collapsed to the end of the selection, if deleting backward the selection 
39735:   //should be collapsed to the beginning of the selection. But if we're not 
39735:   //joining then the selection should collapse to the beginning of the 
39735:   //selection if we'redeleting forward, because the end of the selection will 
39735:   //still be in the next block. And same thing for deleting backwards 
39735:   //(selection should collapse to the end, because the beginning will still 
39735:   //be in the first block). See Bug 507936
39735:   if (join ? aAction == nsIEditor::eNext : aAction == nsIEditor::ePrevious)
    1:   {
    1:     res = aSelection->Collapse(endNode,endOffset);
    1:   }
    1:   else
    1:   {
    1:     res = aSelection->Collapse(startNode,startOffset);
    1:   }
    1:   return res;
    1: }  
    1: 
    1: 
    1: /*****************************************************************************************************
    1: *    InsertBRIfNeeded: determines if a br is needed for current selection to not be spastic.
    1: *    If so, it inserts one.  Callers responsibility to only call with collapsed selection.
    1: *         nsISelection *aSelection      the collapsed selection 
    1: */
    1: nsresult
    1: nsHTMLEditRules::InsertBRIfNeeded(nsISelection *aSelection)
    1: {
43807:   NS_ENSURE_TRUE(aSelection, NS_ERROR_NULL_POINTER);
    1:   
    1:   // get selection  
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   PRInt32 offset;
43518:   nsresult res = mEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(node), &offset);
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
    1: 
    1:   // examine selection
    1:   nsWSRunObject wsObj(mHTMLEditor, node, offset);
    1:   if (((wsObj.mStartReason & nsWSRunObject::eBlock) || (wsObj.mStartReason & nsWSRunObject::eBreak))
    1:       && (wsObj.mEndReason & nsWSRunObject::eBlock))
    1:   {
    1:     // if we are tucked between block boundaries then insert a br
    1:     // first check that we are allowed to
    1:     if (mHTMLEditor->CanContainTag(node, NS_LITERAL_STRING("br")))
    1:     {
    1:       nsCOMPtr<nsIDOMNode> brNode;
    1:       res = mHTMLEditor->CreateBR(node, offset, address_of(brNode), nsIEditor::ePrevious);
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: /*****************************************************************************************************
    1: *    GetGoodSelPointForNode: Finds where at a node you would want to set the selection if you were
    1: *    trying to have a caret next to it.
    1: *         nsIDOMNode *aNode                  the node 
    1: *         nsIEditor::EDirection aAction      which edge to find: eNext indicates beginning, ePrevious ending
    1: *         nsCOMPtr<nsIDOMNode> *outSelNode   desired sel node
    1: *         PRInt32 *outSelOffset              desired sel offset
    1: */
    1: nsresult
    1: nsHTMLEditRules::GetGoodSelPointForNode(nsIDOMNode *aNode, nsIEditor::EDirection aAction, 
    1:                                         nsCOMPtr<nsIDOMNode> *outSelNode, PRInt32 *outSelOffset)
    1: {
43807:   NS_ENSURE_TRUE(aNode && outSelNode && outSelOffset, NS_ERROR_NULL_POINTER);
    1:   
    1:   nsresult res = NS_OK;
    1:   
    1:   // default values
    1:   *outSelNode = aNode;
    1:   *outSelOffset = 0;
    1:   
    1:   if (mHTMLEditor->IsTextNode(aNode) || mHTMLEditor->IsContainer(aNode))
    1:   {
    1:     if (aAction == nsIEditor::ePrevious)
    1:     {
    1:       PRUint32 len;
    1:       res = mHTMLEditor->GetLengthOfDOMNode(aNode, len);
    1:       *outSelOffset = PRInt32(len);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:   }
    1:   else 
    1:   {
    1:     res = nsEditor::GetNodeLocation(aNode, outSelNode, outSelOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (!nsTextEditUtils::IsBreak(aNode) || mHTMLEditor->IsVisBreak(aNode))
    1:     {
    1:       if (aAction == nsIEditor::ePrevious)
    1:         (*outSelOffset)++;
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: /*****************************************************************************************************
    1: *    JoinBlocks: this method is used to join two block elements.  The right element is always joined
    1: *    to the left element.  If the elements are the same type and not nested within each other, 
    1: *    JoinNodesSmart is called (example, joining two list items together into one).  If the elements
    1: *    are not the same type, or one is a descendant of the other, we instead destroy the right block
    1: *    placing it's children into leftblock.  DTD containment rules are followed throughout.
    1: *         nsCOMPtr<nsIDOMNode> *aLeftBlock         pointer to the left block
    1: *         nsCOMPtr<nsIDOMNode> *aRightBlock        pointer to the right block; will have contents moved to left block
    1: *         PRBool *aCanceled                        return TRUE if we had to cancel operation
    1: */
    1: nsresult
    1: nsHTMLEditRules::JoinBlocks(nsCOMPtr<nsIDOMNode> *aLeftBlock, 
    1:                             nsCOMPtr<nsIDOMNode> *aRightBlock, 
    1:                             PRBool *aCanceled)
    1: {
43806:   NS_ENSURE_TRUE(aLeftBlock && aRightBlock && *aLeftBlock  && *aRightBlock, NS_ERROR_NULL_POINTER);
    1:   if (nsHTMLEditUtils::IsTableElement(*aLeftBlock) || nsHTMLEditUtils::IsTableElement(*aRightBlock))
    1:   {
    1:     // do not try to merge table elements
    1:     *aCanceled = PR_TRUE;
    1:     return NS_OK;
    1:   }
    1: 
    1:   // make sure we don't try to move thing's into HR's, which look like blocks but aren't containers
    1:   if (nsHTMLEditUtils::IsHR(*aLeftBlock))
    1:   {
    1:     nsCOMPtr<nsIDOMNode> realLeft = mHTMLEditor->GetBlockNodeParent(*aLeftBlock);
    1:     *aLeftBlock = realLeft;
    1:   }
    1:   if (nsHTMLEditUtils::IsHR(*aRightBlock))
    1:   {
    1:     nsCOMPtr<nsIDOMNode> realRight = mHTMLEditor->GetBlockNodeParent(*aRightBlock);
    1:     *aRightBlock = realRight;
    1:   }
    1: 
    1:   // bail if both blocks the same
    1:   if (*aLeftBlock == *aRightBlock)
    1:   {
    1:     *aCanceled = PR_TRUE;
    1:     return NS_OK;
    1:   }
    1:   
28295:   // Joining a list item to its parent is a NOP.
28295:   if (nsHTMLEditUtils::IsList(*aLeftBlock) && nsHTMLEditUtils::IsListItem(*aRightBlock))
28295:   {
28295:     nsCOMPtr<nsIDOMNode> rightParent;
28295:     (*aRightBlock)->GetParentNode(getter_AddRefs(rightParent));
28295:     if (rightParent == *aLeftBlock)
28295:       return NS_OK;
28295:   }
28295: 
    1:   // special rule here: if we are trying to join list items, and they are in different lists,
    1:   // join the lists instead.
    1:   PRBool bMergeLists = PR_FALSE;
    1:   nsAutoString existingListStr;
    1:   PRInt32 theOffset;
    1:   nsCOMPtr<nsIDOMNode> leftList, rightList;
    1:   if (nsHTMLEditUtils::IsListItem(*aLeftBlock) && nsHTMLEditUtils::IsListItem(*aRightBlock))
    1:   {
    1:     (*aLeftBlock)->GetParentNode(getter_AddRefs(leftList));
    1:     (*aRightBlock)->GetParentNode(getter_AddRefs(rightList));
    1:     if (leftList && rightList && (leftList!=rightList))
    1:     {
    1:       // there are some special complications if the lists are descendants of
    1:       // the other lists' items.  Note that it is ok for them to be descendants
    1:       // of the other lists themselves, which is the usual case for sublists
    1:       // in our impllementation.
    1:       if (!nsEditorUtils::IsDescendantOf(leftList, *aRightBlock, &theOffset) &&
    1:           !nsEditorUtils::IsDescendantOf(rightList, *aLeftBlock, &theOffset))
    1:       {
    1:         *aLeftBlock = leftList;
    1:         *aRightBlock = rightList;
    1:         bMergeLists = PR_TRUE;
    1:         mHTMLEditor->GetTagString(leftList, existingListStr);
    1:         ToLowerCase(existingListStr);
    1:       }
    1:     }
    1:   }
    1:   
    1:   nsAutoTxnsConserveSelection dontSpazMySelection(mHTMLEditor);
    1:   
    1:   nsresult res = NS_OK;
    1:   PRInt32  rightOffset = 0;
    1:   PRInt32  leftOffset  = -1;
    1: 
    1:   // theOffset below is where you find yourself in aRightBlock when you traverse upwards
    1:   // from aLeftBlock
    1:   if (nsEditorUtils::IsDescendantOf(*aLeftBlock, *aRightBlock, &rightOffset))
    1:   {
    1:     // tricky case.  left block is inside right block.
    1:     // Do ws adjustment.  This just destroys non-visible ws at boundaries we will be joining.
    1:     rightOffset++;
    1:     res = nsWSRunObject::ScrubBlockBoundary(mHTMLEditor, aLeftBlock, nsWSRunObject::kBlockEnd);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     res = nsWSRunObject::ScrubBlockBoundary(mHTMLEditor, aRightBlock, nsWSRunObject::kAfterBlock, &rightOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     // Do br adjustment.
    1:     nsCOMPtr<nsIDOMNode> brNode;
    1:     res = CheckForInvisibleBR(*aLeftBlock, kBlockEnd, address_of(brNode));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (bMergeLists)
    1:     {
    1:       // idea here is to take all children in  rightList that are past
    1:       // theOffset, and pull them into leftlist.
    1:       nsCOMPtr<nsIDOMNode> childToMove;
    1:       nsCOMPtr<nsIContent> parent(do_QueryInterface(rightList));
43807:       NS_ENSURE_TRUE(parent, NS_ERROR_NULL_POINTER);
    1: 
    1:       nsIContent *child = parent->GetChildAt(theOffset);
    1:       while (child)
    1:       {
    1:         childToMove = do_QueryInterface(child);
    1:         res = mHTMLEditor->MoveNode(childToMove, leftList, -1);
43808:         NS_ENSURE_SUCCESS(res, res);
    1: 
    1:         child = parent->GetChildAt(rightOffset);
    1:       }
    1:     }
    1:     else
    1:     {
    1:       res = MoveBlock(*aLeftBlock, *aRightBlock, leftOffset, rightOffset);
    1:     }
    1:     if (brNode) mHTMLEditor->DeleteNode(brNode);
    1:   }
    1:   // theOffset below is where you find yourself in aLeftBlock when you traverse upwards
    1:   // from aRightBlock
    1:   else if (nsEditorUtils::IsDescendantOf(*aRightBlock, *aLeftBlock, &leftOffset))
    1:   {
    1:     // tricky case.  right block is inside left block.
    1:     // Do ws adjustment.  This just destroys non-visible ws at boundaries we will be joining.
    1:     res = nsWSRunObject::ScrubBlockBoundary(mHTMLEditor, aRightBlock, nsWSRunObject::kBlockStart);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     res = nsWSRunObject::ScrubBlockBoundary(mHTMLEditor, aLeftBlock, nsWSRunObject::kBeforeBlock, &leftOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     // Do br adjustment.
    1:     nsCOMPtr<nsIDOMNode> brNode;
    1:     res = CheckForInvisibleBR(*aLeftBlock, kBeforeBlock, address_of(brNode), leftOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (bMergeLists)
    1:     {
    1:       res = MoveContents(rightList, leftList, &leftOffset);
    1:     }
    1:     else
    1:     {
    1:       res = MoveBlock(*aLeftBlock, *aRightBlock, leftOffset, rightOffset);
    1:     }
    1:     if (brNode) mHTMLEditor->DeleteNode(brNode);
    1:   }
    1:   else
    1:   {
    1:     // normal case.  blocks are siblings, or at least close enough to siblings.  An example
    1:     // of the latter is a <p>paragraph</p><ul><li>one<li>two<li>three</ul>.  The first
    1:     // li and the p are not true siblings, but we still want to join them if you backspace
    1:     // from li into p.
    1:     
    1:     // adjust whitespace at block boundaries
    1:     res = nsWSRunObject::PrepareToJoinBlocks(mHTMLEditor, *aLeftBlock, *aRightBlock);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     // Do br adjustment.
    1:     nsCOMPtr<nsIDOMNode> brNode;
    1:     res = CheckForInvisibleBR(*aLeftBlock, kBlockEnd, address_of(brNode));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (bMergeLists || mHTMLEditor->NodesSameType(*aLeftBlock, *aRightBlock))
    1:     {
    1:       // nodes are same type.  merge them.
    1:       nsCOMPtr<nsIDOMNode> parent;
    1:       PRInt32 offset;
    1:       res = JoinNodesSmart(*aLeftBlock, *aRightBlock, address_of(parent), &offset);
    1:       if (NS_SUCCEEDED(res) && bMergeLists)
    1:       {
    1:         nsCOMPtr<nsIDOMNode> newBlock;
    1:         res = ConvertListType(*aRightBlock, address_of(newBlock), existingListStr, NS_LITERAL_STRING("li"));
    1:       }
    1:     }
    1:     else
    1:     {
    1:       // nodes are disimilar types. 
    1:       res = MoveBlock(*aLeftBlock, *aRightBlock, leftOffset, rightOffset);
    1:     }
    1:     if (NS_SUCCEEDED(res) && brNode)
    1:     {
    1:       res = mHTMLEditor->DeleteNode(brNode);
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: /*****************************************************************************************************
    1: *    MoveBlock: this method is used to move the content from rightBlock into leftBlock
    1: *    Note that the "block" might merely be inline nodes between <br>s, or between blocks, etc.
    1: *    DTD containment rules are followed throughout.
    1: *         nsIDOMNode *aLeftBlock         parent to receive moved content
    1: *         nsIDOMNode *aRightBlock        parent to provide moved content
    1: *         PRInt32 aLeftOffset            offset in aLeftBlock to move content to
28295: *         PRInt32 aRightOffset           offset in aRightBlock to move content from
    1: */
    1: nsresult
    1: nsHTMLEditRules::MoveBlock(nsIDOMNode *aLeftBlock, nsIDOMNode *aRightBlock, PRInt32 aLeftOffset, PRInt32 aRightOffset)
    1: {
    1:   nsCOMArray<nsIDOMNode> arrayOfNodes;
    1:   nsCOMPtr<nsISupports> isupports;
    1:   // GetNodesFromPoint is the workhorse that figures out what we wnat to move.
    1:   nsresult res = GetNodesFromPoint(DOMPoint(aRightBlock,aRightOffset), kMakeList, arrayOfNodes, PR_TRUE);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   PRInt32 listCount = arrayOfNodes.Count();
    1:   PRInt32 i;
    1:   for (i=0; i<listCount; i++)
    1:   {
    1:     // get the node to act on
    1:     nsIDOMNode* curNode = arrayOfNodes[i];
    1:     if (IsBlockNode(curNode))
    1:     {
    1:       // For block nodes, move their contents only, then delete block.
    1:       res = MoveContents(curNode, aLeftBlock, &aLeftOffset); 
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = mHTMLEditor->DeleteNode(curNode);
    1:     }
    1:     else
    1:     {
    1:       // otherwise move the content as is, checking against the dtd.
    1:       res = MoveNodeSmart(curNode, aLeftBlock, &aLeftOffset);
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: /*****************************************************************************************************
    1: *    MoveNodeSmart: this method is used to move node aSource to (aDest,aOffset).
    1: *    DTD containment rules are followed throughout.  aOffset is updated to point _after_
    1: *    inserted content.
    1: *         nsIDOMNode *aSource       the selection.  
    1: *         nsIDOMNode *aDest         parent to receive moved content
28295: *         PRInt32 *aOffset          offset in aDest to move content to
    1: */
    1: nsresult
    1: nsHTMLEditRules::MoveNodeSmart(nsIDOMNode *aSource, nsIDOMNode *aDest, PRInt32 *aOffset)
    1: {
43806:   NS_ENSURE_TRUE(aSource && aDest && aOffset, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsAutoString tag;
    1:   nsresult res;
    1:   res = mHTMLEditor->GetTagString(aSource, tag);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   ToLowerCase(tag);
    1:   // check if this node can go into the destination node
    1:   if (mHTMLEditor->CanContainTag(aDest, tag))
    1:   {
    1:     // if it can, move it there
    1:     res = mHTMLEditor->MoveNode(aSource, aDest, *aOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (*aOffset != -1) ++(*aOffset);
    1:   }
    1:   else
    1:   {
    1:     // if it can't, move it's children, and then delete it.
    1:     res = MoveContents(aSource, aDest, aOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     res = mHTMLEditor->DeleteNode(aSource);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: /*****************************************************************************************************
    1: *    MoveContents: this method is used to move node the _contents_ of aSource to (aDest,aOffset).
    1: *    DTD containment rules are followed throughout.  aOffset is updated to point _after_
    1: *    inserted content.  aSource is deleted.
    1: *         nsIDOMNode *aSource       the selection.  
    1: *         nsIDOMNode *aDest         parent to receive moved content
28295: *         PRInt32 *aOffset          offset in aDest to move content to
    1: */
    1: nsresult
    1: nsHTMLEditRules::MoveContents(nsIDOMNode *aSource, nsIDOMNode *aDest, PRInt32 *aOffset)
    1: {
43806:   NS_ENSURE_TRUE(aSource && aDest && aOffset, NS_ERROR_NULL_POINTER);
    1:   if (aSource == aDest) return NS_ERROR_ILLEGAL_VALUE;
28295:   NS_ASSERTION(!mHTMLEditor->IsTextNode(aSource), "#text does not have contents");
    1:   
    1:   nsCOMPtr<nsIDOMNode> child;
    1:   nsAutoString tag;
    1:   nsresult res;
    1:   aSource->GetFirstChild(getter_AddRefs(child));
    1:   while (child)
    1:   {
    1:     res = MoveNodeSmart(child, aDest, aOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     aSource->GetFirstChild(getter_AddRefs(child));
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsHTMLEditRules::DeleteNonTableElements(nsIDOMNode *aNode)
    1: {
43806:   NS_ENSURE_TRUE(aNode, NS_ERROR_NULL_POINTER);
    1:   nsresult res = NS_OK;
    1:   if (nsHTMLEditUtils::IsTableElementButNotTable(aNode))
    1:   {
    1:     nsCOMPtr<nsIDOMNodeList> children;
    1:     aNode->GetChildNodes(getter_AddRefs(children));
    1:     if (children)
    1:     {
    1:       PRUint32 len;
    1:       children->GetLength(&len);
43806:       NS_ENSURE_TRUE(len, NS_OK);
    1:       PRInt32 j;
    1:       for (j=len-1; j>=0; j--)
    1:       {
    1:         nsCOMPtr<nsIDOMNode> node;
    1:         children->Item(j,getter_AddRefs(node));
    1:         res = DeleteNonTableElements(node);
43805:         NS_ENSURE_SUCCESS(res, res);
    1: 
    1:       }
    1:     }
    1:   }
    1:   else
    1:   {
    1:     res = mHTMLEditor->DeleteNode(aNode);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   return res;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditRules::DidDeleteSelection(nsISelection *aSelection, 
    1:                                     nsIEditor::EDirection aDir, 
    1:                                     nsresult aResult)
    1: {
    1:   if (!aSelection) { return NS_ERROR_NULL_POINTER; }
    1:   
    1:   // find where we are
    1:   nsCOMPtr<nsIDOMNode> startNode;
    1:   PRInt32 startOffset;
43518:   nsresult res = mEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(startNode), &startOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(startNode, NS_ERROR_FAILURE);
    1:   
    1:   // find any enclosing mailcite
    1:   nsCOMPtr<nsIDOMNode> citeNode;
    1:   res = GetTopEnclosingMailCite(startNode, address_of(citeNode), 
40703:                                 IsPlaintextEditor());
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (citeNode)
    1:   {
    1:     PRBool isEmpty = PR_TRUE, seenBR = PR_FALSE;
    1:     mHTMLEditor->IsEmptyNodeImpl(citeNode, &isEmpty, PR_TRUE, PR_TRUE, PR_FALSE, &seenBR);
    1:     if (isEmpty)
    1:     {
    1:       nsCOMPtr<nsIDOMNode> parent, brNode;
    1:       PRInt32 offset;
    1:       nsEditor::GetNodeLocation(citeNode, address_of(parent), &offset);
    1:       res = mHTMLEditor->DeleteNode(citeNode);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       if (parent && seenBR)
    1:       {
    1:         res = mHTMLEditor->CreateBR(parent, offset, address_of(brNode));
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         aSelection->Collapse(parent, offset);
    1:       }
    1:     }
    1:   }
    1:   
    1:   // call through to base class
    1:   return nsTextEditRules::DidDeleteSelection(aSelection, aDir, aResult);
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditRules::WillMakeList(nsISelection *aSelection, 
    1:                               const nsAString *aListType, 
    1:                               PRBool aEntireList,
    1:                               const nsAString *aBulletType,
    1:                               PRBool *aCancel,
    1:                               PRBool *aHandled,
    1:                               const nsAString *aItemType)
    1: {
    1:   if (!aSelection || !aListType || !aCancel || !aHandled) { return NS_ERROR_NULL_POINTER; }
    1: 
    1:   nsresult res = WillInsert(aSelection, aCancel);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // initialize out param
    1:   // we want to ignore result of WillInsert()
    1:   *aCancel = PR_FALSE;
    1:   *aHandled = PR_FALSE;
    1: 
    1:   // deduce what tag to use for list items
    1:   nsAutoString itemType;
    1:   if (aItemType) 
    1:     itemType = *aItemType;
    1:   else if (aListType->LowerCaseEqualsLiteral("dl"))
    1:     itemType.AssignLiteral("dd");
    1:   else
    1:     itemType.AssignLiteral("li");
    1:     
    1:   // convert the selection ranges into "promoted" selection ranges:
    1:   // this basically just expands the range to include the immediate
    1:   // block parent, and then further expands to include any ancestors
    1:   // whose children are all in the range
    1:   
    1:   *aHandled = PR_TRUE;
    1: 
    1:   res = NormalizeSelection(aSelection);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   nsAutoSelectionReset selectionResetter(aSelection, mHTMLEditor);
    1:   
    1:   nsCOMArray<nsIDOMNode> arrayOfNodes;
    1:   res = GetListActionNodes(arrayOfNodes, aEntireList);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   PRInt32 listCount = arrayOfNodes.Count();
    1:   
    1:   // check if all our nodes are <br>s, or empty inlines
    1:   PRBool bOnlyBreaks = PR_TRUE;
    1:   PRInt32 j;
    1:   for (j=0; j<listCount; j++)
    1:   {
    1:     nsIDOMNode* curNode = arrayOfNodes[j];
    1:     // if curNode is not a Break or empty inline, we're done
    1:     if ( (!nsTextEditUtils::IsBreak(curNode)) && (!IsEmptyInline(curNode)) )
    1:     {
    1:       bOnlyBreaks = PR_FALSE;
    1:       break;
    1:     }
    1:   }
    1:   
    1:   // if no nodes, we make empty list.  Ditto if the user tried to make a list of some # of breaks.
    1:   if (!listCount || bOnlyBreaks) 
    1:   {
    1:     nsCOMPtr<nsIDOMNode> parent, theList, theListItem;
    1:     PRInt32 offset;
    1: 
    1:     // if only breaks, delete them
    1:     if (bOnlyBreaks)
    1:     {
    1:       for (j=0; j<(PRInt32)listCount; j++)
    1:       {
    1:         res = mHTMLEditor->DeleteNode(arrayOfNodes[j]);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:     }
    1:     
    1:     // get selection location
43518:     res = mHTMLEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(parent), &offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     
    1:     // make sure we can put a list here
43896:     if (!mHTMLEditor->CanContainTag(parent, *aListType)) {
43896:       *aCancel = PR_TRUE;
43896:       return NS_OK;
43896:     }
    1:     res = SplitAsNeeded(aListType, address_of(parent), &offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     res = mHTMLEditor->CreateNode(*aListType, parent, offset, getter_AddRefs(theList));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     res = mHTMLEditor->CreateNode(itemType, theList, 0, getter_AddRefs(theListItem));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     // remember our new block for postprocessing
    1:     mNewBlock = theListItem;
    1:     // put selection in new list item
    1:     res = aSelection->Collapse(theListItem,0);
    1:     selectionResetter.Abort();  // to prevent selection reseter from overriding us.
    1:     *aHandled = PR_TRUE;
    1:     return res;
    1:   }
    1: 
    1:   // if there is only one node in the array, and it is a list, div, or blockquote,
    1:   // then look inside of it until we find inner list or content.
    1: 
    1:   res = LookInsideDivBQandList(arrayOfNodes);
43805:   NS_ENSURE_SUCCESS(res, res);                                 
    1: 
    1:   // Ok, now go through all the nodes and put then in the list, 
    1:   // or whatever is approriate.  Wohoo!
    1: 
    1:   listCount = arrayOfNodes.Count();
    1:   nsCOMPtr<nsIDOMNode> curParent;
    1:   nsCOMPtr<nsIDOMNode> curList;
    1:   nsCOMPtr<nsIDOMNode> prevListItem;
    1:   
    1:   PRInt32 i;
    1:   for (i=0; i<listCount; i++)
    1:   {
    1:     // here's where we actually figure out what to do
    1:     nsCOMPtr<nsIDOMNode> newBlock;
    1:     nsCOMPtr<nsIDOMNode> curNode = arrayOfNodes[i];
    1:     PRInt32 offset;
    1:     res = nsEditor::GetNodeLocation(curNode, address_of(curParent), &offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   
    1:     // make sure we don't assemble content that is in different table cells into the same list.
    1:     // respect table cell boundaries when listifying.
    1:     if (curList)
    1:     {
    1:       PRBool bInDifTblElems;
    1:       res = InDifferentTableElements(curList, curNode, &bInDifTblElems);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       if (bInDifTblElems)
    1:         curList = nsnull;
    1:     }
    1:     
    1:     // if curNode is a Break, delete it, and quit remembering prev list item
    1:     if (nsTextEditUtils::IsBreak(curNode)) 
    1:     {
    1:       res = mHTMLEditor->DeleteNode(curNode);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       prevListItem = 0;
    1:       continue;
    1:     }
    1:     // if curNode is an empty inline container, delete it
    1:     else if (IsEmptyInline(curNode)) 
    1:     {
    1:       res = mHTMLEditor->DeleteNode(curNode);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       continue;
    1:     }
    1:     
    1:     if (nsHTMLEditUtils::IsList(curNode))
    1:     {
    1:       nsAutoString existingListStr;
    1:       res = mHTMLEditor->GetTagString(curNode, existingListStr);
    1:       ToLowerCase(existingListStr);
    1:       // do we have a curList already?
    1:       if (curList && !nsEditorUtils::IsDescendantOf(curNode, curList))
    1:       {
    1:         // move all of our children into curList.
    1:         // cheezy way to do it: move whole list and then
    1:         // RemoveContainer() on the list.
    1:         // ConvertListType first: that routine
    1:         // handles converting the list item types, if needed
    1:         res = mHTMLEditor->MoveNode(curNode, curList, -1);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         res = ConvertListType(curNode, address_of(newBlock), *aListType, itemType);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         res = mHTMLEditor->RemoveBlockContainer(newBlock);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:       else
    1:       {
    1:         // replace list with new list type
    1:         res = ConvertListType(curNode, address_of(newBlock), *aListType, itemType);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         curList = newBlock;
    1:       }
    1:       prevListItem = 0;
    1:       continue;
    1:     }
    1: 
    1:     if (nsHTMLEditUtils::IsListItem(curNode))
    1:     {
    1:       nsAutoString existingListStr;
    1:       res = mHTMLEditor->GetTagString(curParent, existingListStr);
    1:       ToLowerCase(existingListStr);
    1:       if ( existingListStr != *aListType )
    1:       {
    1:         // list item is in wrong type of list.  
    1:         // if we don't have a curList, split the old list
    1:         // and make a new list of correct type.
    1:         if (!curList || nsEditorUtils::IsDescendantOf(curNode, curList))
    1:         {
    1:           res = mHTMLEditor->SplitNode(curParent, offset, getter_AddRefs(newBlock));
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           nsCOMPtr<nsIDOMNode> p;
    1:           PRInt32 o;
    1:           res = nsEditor::GetNodeLocation(curParent, address_of(p), &o);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           res = mHTMLEditor->CreateNode(*aListType, p, o, getter_AddRefs(curList));
43805:           NS_ENSURE_SUCCESS(res, res);
    1:         }
    1:         // move list item to new list
    1:         res = mHTMLEditor->MoveNode(curNode, curList, -1);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         // convert list item type if needed
    1:         if (!mHTMLEditor->NodeIsTypeString(curNode,itemType))
    1:         {
    1:           res = mHTMLEditor->ReplaceContainer(curNode, address_of(newBlock), itemType);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:         }
    1:       }
    1:       else
    1:       {
    1:         // item is in right type of list.  But we might still have to move it.
    1:         // and we might need to convert list item types.
    1:         if (!curList)
    1:           curList = curParent;
    1:         else
    1:         {
    1:           if (curParent != curList)
    1:           {
    1:             // move list item to new list
    1:             res = mHTMLEditor->MoveNode(curNode, curList, -1);
43805:             NS_ENSURE_SUCCESS(res, res);
    1:           }
    1:         }
    1:         if (!mHTMLEditor->NodeIsTypeString(curNode,itemType))
    1:         {
    1:           res = mHTMLEditor->ReplaceContainer(curNode, address_of(newBlock), itemType);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:         }
    1:       }
    1:       nsCOMPtr<nsIDOMElement> curElement = do_QueryInterface(curNode);
    1:       NS_NAMED_LITERAL_STRING(typestr, "type");
    1:       if (aBulletType && !aBulletType->IsEmpty()) {
    1:         res = mHTMLEditor->SetAttribute(curElement, typestr, *aBulletType);
    1:       }
    1:       else {
    1:         res = mHTMLEditor->RemoveAttribute(curElement, typestr);
    1:       }
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       continue;
    1:     }
    1:     
    1:     // if we hit a div clear our prevListItem, insert divs contents
    1:     // into our node array, and remove the div
    1:     if (nsHTMLEditUtils::IsDiv(curNode))
    1:     {
    1:       prevListItem = nsnull;
    1:       PRInt32 j=i+1;
    1:       res = GetInnerContent(curNode, arrayOfNodes, &j);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = mHTMLEditor->RemoveContainer(curNode);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       listCount = arrayOfNodes.Count();
    1:       continue;
    1:     }
    1:       
    1:     // need to make a list to put things in if we haven't already,
    1:     if (!curList)
    1:     {
    1:       res = SplitAsNeeded(aListType, address_of(curParent), &offset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = mHTMLEditor->CreateNode(*aListType, curParent, offset, getter_AddRefs(curList));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       // remember our new block for postprocessing
    1:       mNewBlock = curList;
    1:       // curList is now the correct thing to put curNode in
    1:       prevListItem = 0;
    1:     }
    1:   
    1:     // if curNode isn't a list item, we must wrap it in one
    1:     nsCOMPtr<nsIDOMNode> listItem;
    1:     if (!nsHTMLEditUtils::IsListItem(curNode))
    1:     {
    1:       if (IsInlineNode(curNode) && prevListItem)
    1:       {
    1:         // this is a continuation of some inline nodes that belong together in
    1:         // the same list item.  use prevListItem
    1:         res = mHTMLEditor->MoveNode(curNode, prevListItem, -1);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:       else
    1:       {
    1:         // don't wrap li around a paragraph.  instead replace paragraph with li
    1:         if (nsHTMLEditUtils::IsParagraph(curNode))
    1:         {
    1:           res = mHTMLEditor->ReplaceContainer(curNode, address_of(listItem), itemType);
    1:         }
    1:         else
    1:         {
    1:           res = mHTMLEditor->InsertContainerAbove(curNode, address_of(listItem), itemType);
    1:         }
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         if (IsInlineNode(curNode)) 
    1:           prevListItem = listItem;
    1:         else
    1:           prevListItem = nsnull;
    1:       }
    1:     }
    1:     else
    1:     {
    1:       listItem = curNode;
    1:     }
    1:   
    1:     if (listItem)  // if we made a new list item, deal with it
    1:     {
    1:       // tuck the listItem into the end of the active list
    1:       res = mHTMLEditor->MoveNode(listItem, curList, -1);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:   }
    1: 
    1:   return res;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsHTMLEditRules::WillRemoveList(nsISelection *aSelection, 
    1:                                 PRBool aOrdered, 
    1:                                 PRBool *aCancel,
    1:                                 PRBool *aHandled)
    1: {
    1:   if (!aSelection || !aCancel || !aHandled) { return NS_ERROR_NULL_POINTER; }
    1:   // initialize out param
    1:   *aCancel = PR_FALSE;
    1:   *aHandled = PR_TRUE;
    1:   
    1:   nsresult res = NormalizeSelection(aSelection);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   nsAutoSelectionReset selectionResetter(aSelection, mHTMLEditor);
    1:   
    1:   nsCOMArray<nsIDOMRange> arrayOfRanges;
    1:   res = GetPromotedRanges(aSelection, arrayOfRanges, kMakeList);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   // use these ranges to contruct a list of nodes to act on.
    1:   nsCOMArray<nsIDOMNode> arrayOfNodes;
    1:   res = GetListActionNodes(arrayOfNodes, PR_FALSE);
43805:   NS_ENSURE_SUCCESS(res, res);                                 
    1:                                      
    1:   // Remove all non-editable nodes.  Leave them be.
    1:   PRInt32 listCount = arrayOfNodes.Count();
    1:   PRInt32 i;
    1:   for (i=listCount-1; i>=0; i--)
    1:   {
    1:     nsIDOMNode* testNode = arrayOfNodes[i];
    1:     if (!mHTMLEditor->IsEditable(testNode))
    1:     {
    1:       arrayOfNodes.RemoveObjectAt(i);
    1:     }
    1:   }
    1:   
    1:   // reset list count
    1:   listCount = arrayOfNodes.Count();
    1:   
    1:   // Only act on lists or list items in the array
    1:   nsCOMPtr<nsIDOMNode> curParent;
    1:   for (i=0; i<listCount; i++)
    1:   {
    1:     // here's where we actually figure out what to do
    1:     nsIDOMNode* curNode = arrayOfNodes[i];
    1:     PRInt32 offset;
    1:     res = nsEditor::GetNodeLocation(curNode, address_of(curParent), &offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     
    1:     if (nsHTMLEditUtils::IsListItem(curNode))  // unlist this listitem
    1:     {
    1:       PRBool bOutOfList;
    1:       do
    1:       {
    1:         res = PopListItem(curNode, &bOutOfList);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       } while (!bOutOfList); // keep popping it out until it's not in a list anymore
    1:     }
    1:     else if (nsHTMLEditUtils::IsList(curNode)) // node is a list, move list items out
    1:     {
    1:       res = RemoveListStructure(curNode);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsHTMLEditRules::WillMakeDefListItem(nsISelection *aSelection, 
    1:                                      const nsAString *aItemType, 
    1:                                      PRBool aEntireList, 
    1:                                      PRBool *aCancel,
    1:                                      PRBool *aHandled)
    1: {
    1:   // for now we let WillMakeList handle this
    1:   NS_NAMED_LITERAL_STRING(listType, "dl");
    1:   return WillMakeList(aSelection, &listType, aEntireList, nsnull, aCancel, aHandled, aItemType);
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditRules::WillMakeBasicBlock(nsISelection *aSelection, 
    1:                                     const nsAString *aBlockType, 
    1:                                     PRBool *aCancel,
    1:                                     PRBool *aHandled)
    1: {
    1:   if (!aSelection || !aCancel || !aHandled) { return NS_ERROR_NULL_POINTER; }
    1:   // initialize out param
    1:   *aCancel = PR_FALSE;
    1:   *aHandled = PR_FALSE;
    1:   
    1:   nsresult res = WillInsert(aSelection, aCancel);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   // initialize out param
    1:   // we want to ignore result of WillInsert()
    1:   *aCancel = PR_FALSE;
    1:   res = NormalizeSelection(aSelection);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   nsAutoSelectionReset selectionResetter(aSelection, mHTMLEditor);
    1:   nsAutoTxnsConserveSelection dontSpazMySelection(mHTMLEditor);
    1:   *aHandled = PR_TRUE;
    1:   nsString tString(*aBlockType);
    1: 
    1:   // contruct a list of nodes to act on.
    1:   nsCOMArray<nsIDOMNode> arrayOfNodes;
    1:   res = GetNodesFromSelection(aSelection, kMakeBasicBlock, arrayOfNodes);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // Remove all non-editable nodes.  Leave them be.
    1:   PRInt32 listCount = arrayOfNodes.Count();
    1:   PRInt32 i;
    1:   for (i=listCount-1; i>=0; i--)
    1:   {
    1:     if (!mHTMLEditor->IsEditable(arrayOfNodes[i]))
    1:     {
    1:       arrayOfNodes.RemoveObjectAt(i);
    1:     }
    1:   }
    1:   
    1:   // reset list count
    1:   listCount = arrayOfNodes.Count();
    1:   
    1:   // if nothing visible in list, make an empty block
    1:   if (ListIsEmptyLine(arrayOfNodes))
    1:   {
    1:     nsCOMPtr<nsIDOMNode> parent, theBlock;
    1:     PRInt32 offset;
    1:     
    1:     // get selection location
43518:     res = mHTMLEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(parent), &offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (tString.EqualsLiteral("normal") ||
    1:         tString.IsEmpty() ) // we are removing blocks (going to "body text")
    1:     {
    1:       nsCOMPtr<nsIDOMNode> curBlock = parent;
    1:       if (!IsBlockNode(curBlock))
    1:         curBlock = mHTMLEditor->GetBlockNodeParent(parent);
    1:       nsCOMPtr<nsIDOMNode> curBlockPar;
43806:       NS_ENSURE_TRUE(curBlock, NS_ERROR_NULL_POINTER);
    1:       curBlock->GetParentNode(getter_AddRefs(curBlockPar));
    1:       if (nsHTMLEditUtils::IsFormatNode(curBlock))
    1:       {
    1:         // if the first editable node after selection is a br, consume it.  Otherwise
    1:         // it gets pushed into a following block after the split, which is visually bad.
    1:         nsCOMPtr<nsIDOMNode> brNode;
    1:         res = mHTMLEditor->GetNextHTMLNode(parent, offset, address_of(brNode));
43805:         NS_ENSURE_SUCCESS(res, res);        
    1:         if (brNode && nsTextEditUtils::IsBreak(brNode))
    1:         {
    1:           res = mHTMLEditor->DeleteNode(brNode);
43805:           NS_ENSURE_SUCCESS(res, res); 
    1:         }
    1:         // do the splits!
    1:         res = mHTMLEditor->SplitNodeDeep(curBlock, parent, offset, &offset, PR_TRUE);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         // put a br at the split point
    1:         res = mHTMLEditor->CreateBR(curBlockPar, offset, address_of(brNode));
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         // put selection at the split point
    1:         res = aSelection->Collapse(curBlockPar, offset);
    1:         selectionResetter.Abort();  // to prevent selection reseter from overriding us.
    1:         *aHandled = PR_TRUE;
    1:       }
    1:       // else nothing to do!
    1:     }
    1:     else  // we are making a block
    1:     {   
    1:       // consume a br, if needed
    1:       nsCOMPtr<nsIDOMNode> brNode;
    1:       res = mHTMLEditor->GetNextHTMLNode(parent, offset, address_of(brNode), PR_TRUE);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       if (brNode && nsTextEditUtils::IsBreak(brNode))
    1:       {
    1:         res = mHTMLEditor->DeleteNode(brNode);
43805:         NS_ENSURE_SUCCESS(res, res);
29062:         // we don't need to act on this node any more
29062:         arrayOfNodes.RemoveObject(brNode);
    1:       }
    1:       // make sure we can put a block here
    1:       res = SplitAsNeeded(aBlockType, address_of(parent), &offset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = mHTMLEditor->CreateNode(*aBlockType, parent, offset, getter_AddRefs(theBlock));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       // remember our new block for postprocessing
    1:       mNewBlock = theBlock;
    1:       // delete anything that was in the list of nodes
    1:       for (PRInt32 j = arrayOfNodes.Count() - 1; j >= 0; --j) 
    1:       {
    1:         nsCOMPtr<nsIDOMNode> curNode = arrayOfNodes[0];
    1:         res = mHTMLEditor->DeleteNode(curNode);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         res = arrayOfNodes.RemoveObjectAt(0);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:       // put selection in new block
    1:       res = aSelection->Collapse(theBlock,0);
    1:       selectionResetter.Abort();  // to prevent selection reseter from overriding us.
    1:       *aHandled = PR_TRUE;
    1:     }
    1:     return res;    
    1:   }
    1:   else
    1:   {
    1:     // Ok, now go through all the nodes and make the right kind of blocks, 
    1:     // or whatever is approriate.  Wohoo! 
    1:     // Note: blockquote is handled a little differently
    1:     if (tString.EqualsLiteral("blockquote"))
    1:       res = MakeBlockquote(arrayOfNodes);
    1:     else if (tString.EqualsLiteral("normal") ||
    1:              tString.IsEmpty() )
    1:       res = RemoveBlockStyle(arrayOfNodes);
    1:     else
    1:       res = ApplyBlockStyle(arrayOfNodes, aBlockType);
    1:     return res;
    1:   }
    1:   return res;
    1: }
    1: 
    1: nsresult 
    1: nsHTMLEditRules::DidMakeBasicBlock(nsISelection *aSelection,
    1:                                    nsRulesInfo *aInfo, nsresult aResult)
    1: {
43806:   NS_ENSURE_TRUE(aSelection, NS_ERROR_NULL_POINTER);
    1:   // check for empty block.  if so, put a moz br in it.
    1:   PRBool isCollapsed;
    1:   nsresult res = aSelection->GetIsCollapsed(&isCollapsed);
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(isCollapsed, NS_OK);
    1: 
    1:   nsCOMPtr<nsIDOMNode> parent;
    1:   PRInt32 offset;
43518:   res = nsEditor::GetStartNodeAndOffset(aSelection, getter_AddRefs(parent), &offset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = InsertMozBRIfNeeded(parent);
    1:   return res;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditRules::WillIndent(nsISelection *aSelection, PRBool *aCancel, PRBool * aHandled)
    1: {
    1:   PRBool useCSS;
    1:   nsresult res;
    1:   mHTMLEditor->GetIsCSSEnabled(&useCSS);
    1:   
    1:   if (useCSS) {
    1:     res = WillCSSIndent(aSelection, aCancel, aHandled);
    1:   }
    1:   else {
    1:     res = WillHTMLIndent(aSelection, aCancel, aHandled);
    1:   }
    1:   return res;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditRules::WillCSSIndent(nsISelection *aSelection, PRBool *aCancel, PRBool * aHandled)
    1: {
    1:   if (!aSelection || !aCancel || !aHandled) { return NS_ERROR_NULL_POINTER; }
    1:   
    1:   nsresult res = WillInsert(aSelection, aCancel);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // initialize out param
    1:   // we want to ignore result of WillInsert()
    1:   *aCancel = PR_FALSE;
    1:   *aHandled = PR_TRUE;
    1: 
    1:   res = NormalizeSelection(aSelection);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   nsAutoSelectionReset selectionResetter(aSelection, mHTMLEditor);
    1:   nsCOMArray<nsIDOMRange>  arrayOfRanges;
    1:   nsCOMArray<nsIDOMNode> arrayOfNodes;
    1:   
    1:   // short circuit: detect case of collapsed selection inside an <li>.
    1:   // just sublist that <li>.  This prevents bug 97797.
    1:   
    1:   PRBool bCollapsed;
    1:   nsCOMPtr<nsIDOMNode> liNode;
    1:   res = aSelection->GetIsCollapsed(&bCollapsed);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (bCollapsed) 
    1:   {
    1:     nsCOMPtr<nsIDOMNode> node, block;
    1:     PRInt32 offset;
43518:     nsresult res = mHTMLEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(node), &offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (IsBlockNode(node)) 
    1:       block = node;
    1:     else
    1:       block = mHTMLEditor->GetBlockNodeParent(node);
    1:     if (block && nsHTMLEditUtils::IsListItem(block))
    1:       liNode = block;
    1:   }
    1:   
    1:   if (liNode)
    1:   {
    1:     arrayOfNodes.AppendObject(liNode);
    1:   }
    1:   else
    1:   {
    1:     // convert the selection ranges into "promoted" selection ranges:
    1:     // this basically just expands the range to include the immediate
    1:     // block parent, and then further expands to include any ancestors
    1:     // whose children are all in the range
    1:     res = GetNodesFromSelection(aSelection, kIndent, arrayOfNodes);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   
    1:   NS_NAMED_LITERAL_STRING(quoteType, "blockquote");
    1:   // if nothing visible in list, make an empty block
    1:   if (ListIsEmptyLine(arrayOfNodes))
    1:   {
    1:     nsCOMPtr<nsIDOMNode> parent, theBlock;
    1:     PRInt32 offset;
    1:     nsAutoString quoteType(NS_LITERAL_STRING("div"));
    1:     // get selection location
43518:     res = mHTMLEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(parent), &offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     // make sure we can put a block here
    1:     res = SplitAsNeeded(&quoteType, address_of(parent), &offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     res = mHTMLEditor->CreateNode(quoteType, parent, offset, getter_AddRefs(theBlock));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     // remember our new block for postprocessing
    1:     mNewBlock = theBlock;
    1:     RelativeChangeIndentationOfElementNode(theBlock, +1);
    1:     // delete anything that was in the list of nodes
    1:     for (PRInt32 j = arrayOfNodes.Count() - 1; j >= 0; --j) 
    1:     {
    1:       nsCOMPtr<nsIDOMNode> curNode = arrayOfNodes[0];
    1:       res = mHTMLEditor->DeleteNode(curNode);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = arrayOfNodes.RemoveObjectAt(0);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     // put selection in new block
    1:     res = aSelection->Collapse(theBlock,0);
    1:     selectionResetter.Abort();  // to prevent selection reseter from overriding us.
    1:     *aHandled = PR_TRUE;
    1:     return res;
    1:   }
    1:   
    1:   // Ok, now go through all the nodes and put them in a blockquote, 
    1:   // or whatever is appropriate.  Wohoo!
    1:   PRInt32 i;
    1:   nsCOMPtr<nsIDOMNode> curParent;
    1:   nsCOMPtr<nsIDOMNode> curQuote;
    1:   nsCOMPtr<nsIDOMNode> curList;
 7921:   nsCOMPtr<nsIDOMNode> sibling;
    1:   PRInt32 listCount = arrayOfNodes.Count();
    1:   for (i=0; i<listCount; i++)
    1:   {
    1:     // here's where we actually figure out what to do
    1:     nsCOMPtr<nsIDOMNode> curNode = arrayOfNodes[i];
    1: 
    1:     // Ignore all non-editable nodes.  Leave them be.
    1:     if (!mHTMLEditor->IsEditable(curNode)) continue;
    1: 
    1:     PRInt32 offset;
    1:     res = nsEditor::GetNodeLocation(curNode, address_of(curParent), &offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     
    1:     // some logic for putting list items into nested lists...
    1:     if (nsHTMLEditUtils::IsList(curParent))
    1:     {
 7921:       sibling = nsnull;
 7921: 
 7921:       // Check for whether we should join a list that follows curNode.
 7921:       // We do this if the next element is a list, and the list is of the
 7921:       // same type (li/ol) as curNode was a part it.
 7921:       mHTMLEditor->GetNextHTMLSibling(curNode, address_of(sibling));
 7921:       if (sibling && nsHTMLEditUtils::IsList(sibling))
 7921:       {
 7921:         nsAutoString curListTag, siblingListTag;
 7921:         nsEditor::GetTagString(curParent, curListTag);
 7921:         nsEditor::GetTagString(sibling, siblingListTag);
 7921:         if (curListTag == siblingListTag)
 7921:         {
 7921:           res = mHTMLEditor->MoveNode(curNode, sibling, 0);
43805:           NS_ENSURE_SUCCESS(res, res);
 7921:           continue;
 7921:         }
 7921:       }
 7921:       // Check for whether we should join a list that preceeds curNode.
 7921:       // We do this if the previous element is a list, and the list is of
 7921:       // the same type (li/ol) as curNode was a part of.
 7921:       mHTMLEditor->GetPriorHTMLSibling(curNode, address_of(sibling));
 7921:       if (sibling && nsHTMLEditUtils::IsList(sibling))
 7921:       {
 7921:         nsAutoString curListTag, siblingListTag;
 7921:         nsEditor::GetTagString(curParent, curListTag);
 7921:         nsEditor::GetTagString(sibling, siblingListTag);
 7921:         if (curListTag == siblingListTag)
 7921:         {
 7921:           res = mHTMLEditor->MoveNode(curNode, sibling, -1);
43805:           NS_ENSURE_SUCCESS(res, res);
 7921:           continue;
 7921:         }
 7921:       }
 7921:       sibling = nsnull;
 7921:       
 7921:       // check to see if curList is still appropriate.  Which it is if
 7921:       // curNode is still right after it in the same list.
 7921:       if (curList)
 7921:         mHTMLEditor->GetPriorHTMLSibling(curNode, address_of(sibling));
 7921: 
 7921:       if (!curList || (sibling && sibling != curList))
    1:       {
    1:         nsAutoString listTag;
    1:         nsEditor::GetTagString(curParent,listTag);
    1:         ToLowerCase(listTag);
    1:         // create a new nested list of correct type
    1:         res = SplitAsNeeded(&listTag, address_of(curParent), &offset);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         res = mHTMLEditor->CreateNode(listTag, curParent, offset, getter_AddRefs(curList));
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         // curList is now the correct thing to put curNode in
    1:         // remember our new block for postprocessing
    1:         mNewBlock = curList;
    1:       }
    1:       // tuck the node into the end of the active list
    1:       PRUint32 listLen;
    1:       res = mHTMLEditor->GetLengthOfDOMNode(curList, listLen);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = mHTMLEditor->MoveNode(curNode, curList, listLen);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     
    1:     else // not a list item
    1:     {
    1:       if (IsBlockNode(curNode)) {
    1:         RelativeChangeIndentationOfElementNode(curNode, +1);
    1:         curQuote = nsnull;
    1:       }
    1:       else {
 7921:         if (!curQuote)
    1:         {
    1:           NS_NAMED_LITERAL_STRING(divquoteType, "div");
    1:           res = SplitAsNeeded(&divquoteType, address_of(curParent), &offset);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           res = mHTMLEditor->CreateNode(divquoteType, curParent, offset, getter_AddRefs(curQuote));
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           RelativeChangeIndentationOfElementNode(curQuote, +1);
    1:           // remember our new block for postprocessing
    1:           mNewBlock = curQuote;
    1:           // curQuote is now the correct thing to put curNode in
    1:         }
    1:         
    1:         // tuck the node into the end of the active blockquote
    1:         PRUint32 quoteLen;
    1:         res = mHTMLEditor->GetLengthOfDOMNode(curQuote, quoteLen);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         res = mHTMLEditor->MoveNode(curNode, curQuote, quoteLen);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditRules::WillHTMLIndent(nsISelection *aSelection, PRBool *aCancel, PRBool * aHandled)
    1: {
    1:   if (!aSelection || !aCancel || !aHandled) { return NS_ERROR_NULL_POINTER; }
    1:   nsresult res = WillInsert(aSelection, aCancel);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // initialize out param
    1:   // we want to ignore result of WillInsert()
    1:   *aCancel = PR_FALSE;
    1:   *aHandled = PR_TRUE;
    1: 
    1:   res = NormalizeSelection(aSelection);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   nsAutoSelectionReset selectionResetter(aSelection, mHTMLEditor);
    1:   
    1:   // convert the selection ranges into "promoted" selection ranges:
    1:   // this basically just expands the range to include the immediate
    1:   // block parent, and then further expands to include any ancestors
    1:   // whose children are all in the range
    1:   
    1:   nsCOMArray<nsIDOMRange> arrayOfRanges;
    1:   res = GetPromotedRanges(aSelection, arrayOfRanges, kIndent);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   // use these ranges to contruct a list of nodes to act on.
    1:   nsCOMArray<nsIDOMNode> arrayOfNodes;
    1:   res = GetNodesForOperation(arrayOfRanges, arrayOfNodes, kIndent);
43805:   NS_ENSURE_SUCCESS(res, res);                                 
    1:                                      
    1:   NS_NAMED_LITERAL_STRING(quoteType, "blockquote");
    1: 
    1:   // if nothing visible in list, make an empty block
    1:   if (ListIsEmptyLine(arrayOfNodes))
    1:   {
    1:     nsCOMPtr<nsIDOMNode> parent, theBlock;
    1:     PRInt32 offset;
    1:     
    1:     // get selection location
43518:     res = mHTMLEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(parent), &offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     // make sure we can put a block here
    1:     res = SplitAsNeeded(&quoteType, address_of(parent), &offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     res = mHTMLEditor->CreateNode(quoteType, parent, offset, getter_AddRefs(theBlock));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     // remember our new block for postprocessing
    1:     mNewBlock = theBlock;
    1:     // delete anything that was in the list of nodes
    1:     for (PRInt32 j = arrayOfNodes.Count() - 1; j >= 0; --j) 
    1:     {
    1:       nsCOMPtr<nsIDOMNode> curNode = arrayOfNodes[0];
    1:       res = mHTMLEditor->DeleteNode(curNode);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = arrayOfNodes.RemoveObjectAt(0);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     // put selection in new block
    1:     res = aSelection->Collapse(theBlock,0);
    1:     selectionResetter.Abort();  // to prevent selection reseter from overriding us.
    1:     *aHandled = PR_TRUE;
    1:     return res;
    1:   }
    1: 
    1:   // Ok, now go through all the nodes and put them in a blockquote, 
    1:   // or whatever is appropriate.  Wohoo!
    1:   PRInt32 i;
    1:   nsCOMPtr<nsIDOMNode> curParent, curQuote, curList, indentedLI, sibling;
    1:   PRInt32 listCount = arrayOfNodes.Count();
    1:   for (i=0; i<listCount; i++)
    1:   {
    1:     // here's where we actually figure out what to do
    1:     nsCOMPtr<nsIDOMNode> curNode = arrayOfNodes[i];
    1: 
    1:     // Ignore all non-editable nodes.  Leave them be.
    1:     if (!mHTMLEditor->IsEditable(curNode)) continue;
    1: 
    1:     PRInt32 offset;
    1:     res = nsEditor::GetNodeLocation(curNode, address_of(curParent), &offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:      
    1:     // some logic for putting list items into nested lists...
    1:     if (nsHTMLEditUtils::IsList(curParent))
    1:     {
 6523:       sibling = nsnull;
 6523: 
 6523:       // Check for whether we should join a list that follows curNode.
 6523:       // We do this if the next element is a list, and the list is of the
 6523:       // same type (li/ol) as curNode was a part it.
 6523:       mHTMLEditor->GetNextHTMLSibling(curNode, address_of(sibling));
 6523:       if (sibling && nsHTMLEditUtils::IsList(sibling))
 6523:       {
 6523:         nsAutoString curListTag, siblingListTag;
 6523:         nsEditor::GetTagString(curParent, curListTag);
 6523:         nsEditor::GetTagString(sibling, siblingListTag);
 6523:         if (curListTag == siblingListTag)
 6523:         {
 6523:           res = mHTMLEditor->MoveNode(curNode, sibling, 0);
43805:           NS_ENSURE_SUCCESS(res, res);
 6523:           continue;
 6523:         }
 6523:       }
 6523: 
 6523:       // Check for whether we should join a list that preceeds curNode.
 6523:       // We do this if the previous element is a list, and the list is of
 6523:       // the same type (li/ol) as curNode was a part of.
 6523:       mHTMLEditor->GetPriorHTMLSibling(curNode, address_of(sibling));
 6523:       if (sibling && nsHTMLEditUtils::IsList(sibling))
 6523:       {
 6523:         nsAutoString curListTag, siblingListTag;
 6523:         nsEditor::GetTagString(curParent, curListTag);
 6523:         nsEditor::GetTagString(sibling, siblingListTag);
 6523:         if (curListTag == siblingListTag)
 6523:         {
 6523:           res = mHTMLEditor->MoveNode(curNode, sibling, -1);
43805:           NS_ENSURE_SUCCESS(res, res);
 6523:           continue;
 6523:         }
 6523:       }
 6523: 
 6523:       sibling = nsnull;
 6523: 
    1:       // check to see if curList is still appropriate.  Which it is if
    1:       // curNode is still right after it in the same list.
    1:       if (curList)
    1:         mHTMLEditor->GetPriorHTMLSibling(curNode, address_of(sibling));
    1: 
    1:       if (!curList || (sibling && sibling != curList) )
    1:       {
    1:         nsAutoString listTag;
    1:         nsEditor::GetTagString(curParent,listTag);
    1:         ToLowerCase(listTag);
    1:         // create a new nested list of correct type
    1:         res = SplitAsNeeded(&listTag, address_of(curParent), &offset);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         res = mHTMLEditor->CreateNode(listTag, curParent, offset, getter_AddRefs(curList));
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         // curList is now the correct thing to put curNode in
    1:         // remember our new block for postprocessing
    1:         mNewBlock = curList;
    1:       }
    1:       // tuck the node into the end of the active list
    1:       res = mHTMLEditor->MoveNode(curNode, curList, -1);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       // forget curQuote, if any
    1:       curQuote = nsnull;
    1:     }
    1:     
    1:     else // not a list item, use blockquote?
    1:     {
    1:       // if we are inside a list item, we don't want to blockquote, we want
    1:       // to sublist the list item.  We may have several nodes listed in the
    1:       // array of nodes to act on, that are in the same list item.  Since
    1:       // we only want to indent that li once, we must keep track of the most
    1:       // recent indented list item, and not indent it if we find another node
    1:       // to act on that is still inside the same li.
    1:       nsCOMPtr<nsIDOMNode> listitem=IsInListItem(curNode);
    1:       if (listitem)
    1:       {
    1:         if (indentedLI == listitem) continue;  // already indented this list item
    1:         res = nsEditor::GetNodeLocation(listitem, address_of(curParent), &offset);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         // check to see if curList is still appropriate.  Which it is if
    1:         // curNode is still right after it in the same list.
    1:         if (curList)
    1:         {
    1:           sibling = nsnull;
    1:           mHTMLEditor->GetPriorHTMLSibling(curNode, address_of(sibling));
    1:         }
    1:          
    1:         if (!curList || (sibling && sibling != curList) )
    1:         {
    1:           nsAutoString listTag;
    1:           nsEditor::GetTagString(curParent,listTag);
    1:           ToLowerCase(listTag);
    1:           // create a new nested list of correct type
    1:           res = SplitAsNeeded(&listTag, address_of(curParent), &offset);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           res = mHTMLEditor->CreateNode(listTag, curParent, offset, getter_AddRefs(curList));
43805:           NS_ENSURE_SUCCESS(res, res);
    1:         }
    1:         res = mHTMLEditor->MoveNode(listitem, curList, -1);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         // remember we indented this li
    1:         indentedLI = listitem;
    1:       }
    1:       
    1:       else
    1:       {
    1:         // need to make a blockquote to put things in if we haven't already,
    1:         // or if this node doesn't go in blockquote we used earlier.
    1:         // One reason it might not go in prio blockquote is if we are now
    1:         // in a different table cell. 
    1:         if (curQuote)
    1:         {
    1:           PRBool bInDifTblElems;
    1:           res = InDifferentTableElements(curQuote, curNode, &bInDifTblElems);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           if (bInDifTblElems)
    1:             curQuote = nsnull;
    1:         }
    1:         
    1:         if (!curQuote) 
    1:         {
    1:           res = SplitAsNeeded(&quoteType, address_of(curParent), &offset);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           res = mHTMLEditor->CreateNode(quoteType, curParent, offset, getter_AddRefs(curQuote));
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           // remember our new block for postprocessing
    1:           mNewBlock = curQuote;
    1:           // curQuote is now the correct thing to put curNode in
    1:         }
    1:           
    1:         // tuck the node into the end of the active blockquote
    1:         res = mHTMLEditor->MoveNode(curNode, curQuote, -1);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         // forget curList, if any
    1:         curList = nsnull;
    1:       }
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsHTMLEditRules::WillOutdent(nsISelection *aSelection, PRBool *aCancel, PRBool *aHandled)
    1: {
    1:   if (!aSelection || !aCancel || !aHandled) { return NS_ERROR_NULL_POINTER; }
    1:   // initialize out param
    1:   *aCancel = PR_FALSE;
    1:   *aHandled = PR_TRUE;
    1:   nsresult res = NS_OK;
    1:   nsCOMPtr<nsIDOMNode> rememberedLeftBQ, rememberedRightBQ;
    1:   PRBool useCSS;
    1:   mHTMLEditor->GetIsCSSEnabled(&useCSS);
    1: 
    1:   res = NormalizeSelection(aSelection);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   // some scoping for selection resetting - we may need to tweak it
    1:   {
    1:     nsAutoSelectionReset selectionResetter(aSelection, mHTMLEditor);
    1:     
    1:     // convert the selection ranges into "promoted" selection ranges:
    1:     // this basically just expands the range to include the immediate
    1:     // block parent, and then further expands to include any ancestors
    1:     // whose children are all in the range
    1:     nsCOMArray<nsIDOMNode> arrayOfNodes;
    1:     res = GetNodesFromSelection(aSelection, kOutdent, arrayOfNodes);
43805:     NS_ENSURE_SUCCESS(res, res);
    1: 
    1:     // Ok, now go through all the nodes and remove a level of blockquoting, 
    1:     // or whatever is appropriate.  Wohoo!
    1: 
    1:     nsCOMPtr<nsIDOMNode> curBlockQuote, firstBQChild, lastBQChild;
    1:     PRBool curBlockQuoteIsIndentedWithCSS = PR_FALSE;
    1:     PRInt32 listCount = arrayOfNodes.Count();
    1:     PRInt32 i;
    1:     nsCOMPtr<nsIDOMNode> curParent;
    1:     for (i=0; i<listCount; i++)
    1:     {
    1:       // here's where we actually figure out what to do
    1:       nsCOMPtr<nsIDOMNode> curNode = arrayOfNodes[i];
    1:       PRInt32 offset;
    1:       res = nsEditor::GetNodeLocation(curNode, address_of(curParent), &offset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       
    1:       // is it a blockquote?
    1:       if (nsHTMLEditUtils::IsBlockquote(curNode)) 
    1:       {
    1:         // if it is a blockquote, remove it.
    1:         // So we need to finish up dealng with any curBlockQuote first.
    1:         if (curBlockQuote)
    1:         {
    1:           res = OutdentPartOfBlock(curBlockQuote, firstBQChild, lastBQChild,
    1:                                    curBlockQuoteIsIndentedWithCSS,
    1:                                    address_of(rememberedLeftBQ),
    1:                                    address_of(rememberedRightBQ));
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           curBlockQuote = 0;  firstBQChild = 0;  lastBQChild = 0;
    1:           curBlockQuoteIsIndentedWithCSS = PR_FALSE;
    1:         }
    1:         res = mHTMLEditor->RemoveBlockContainer(curNode);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         continue;
    1:       }
    1:       // is it a list item?
    1:       if (nsHTMLEditUtils::IsListItem(curNode)) 
    1:       {
    1:         // if it is a list item, that means we are not outdenting whole list.
    1:         // So we need to finish up dealng with any curBlockQuote, and then
    1:         // pop this list item.
    1:         if (curBlockQuote)
    1:         {
    1:           res = OutdentPartOfBlock(curBlockQuote, firstBQChild, lastBQChild,
    1:                                    curBlockQuoteIsIndentedWithCSS,
    1:                                    address_of(rememberedLeftBQ),
    1:                                    address_of(rememberedRightBQ));
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           curBlockQuote = 0;  firstBQChild = 0;  lastBQChild = 0;
    1:           curBlockQuoteIsIndentedWithCSS = PR_FALSE;
    1:         }
    1:         PRBool bOutOfList;
    1:         res = PopListItem(curNode, &bOutOfList);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         continue;
    1:       }
    1:       // do we have a blockquote that we are already committed to removing?
    1:       if (curBlockQuote)
    1:       {
    1:         // if so, is this node a descendant?
    1:         if (nsEditorUtils::IsDescendantOf(curNode, curBlockQuote))
    1:         {
    1:           lastBQChild = curNode;
    1:           continue;  // then we don't need to do anything different for this node
    1:         }
    1:         else
    1:         {
    1:           // otherwise, we have progressed beyond end of curBlockQuote,
    1:           // so lets handle it now.  We need to remove the portion of 
    1:           // curBlockQuote that contains [firstBQChild - lastBQChild].
    1:           res = OutdentPartOfBlock(curBlockQuote, firstBQChild, lastBQChild,
    1:                                    curBlockQuoteIsIndentedWithCSS,
    1:                                    address_of(rememberedLeftBQ),
    1:                                    address_of(rememberedRightBQ));
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           curBlockQuote = 0;  firstBQChild = 0;  lastBQChild = 0;
    1:           curBlockQuoteIsIndentedWithCSS = PR_FALSE;
    1:           // fall out and handle curNode
    1:         }
    1:       }
    1:       
    1:       // are we inside a blockquote?
    1:       nsCOMPtr<nsIDOMNode> n = curNode;
    1:       nsCOMPtr<nsIDOMNode> tmp;
    1:       curBlockQuoteIsIndentedWithCSS = PR_FALSE;
41545:       // keep looking up the hierarchy as long as we don't hit the body or a table element
    1:       // (other than an entire table)
    1:       while (!nsTextEditUtils::IsBody(n) &&   
    1:              (nsHTMLEditUtils::IsTable(n) || !nsHTMLEditUtils::IsTableElement(n)))
    1:       {
    1:         n->GetParentNode(getter_AddRefs(tmp));
 2794:         if (!tmp) {
 2794:           break;
 2794:         }
    1:         n = tmp;
    1:         if (nsHTMLEditUtils::IsBlockquote(n))
    1:         {
    1:           // if so, remember it, and remember first node we are taking out of it.
    1:           curBlockQuote = n;
    1:           firstBQChild  = curNode;
    1:           lastBQChild   = curNode;
    1:           break;
    1:         }
    1:         else if (useCSS)
    1:         {
    1:           nsIAtom* marginProperty = MarginPropertyAtomForIndent(mHTMLEditor->mHTMLCSSUtils, curNode);
    1:           nsAutoString value;
    1:           mHTMLEditor->mHTMLCSSUtils->GetSpecifiedProperty(n, marginProperty, value);
    1:           float f;
 8936:           nsCOMPtr<nsIAtom> unit;
 8936:           mHTMLEditor->mHTMLCSSUtils->ParseLength(value, &f, getter_AddRefs(unit));
    1:           if (f > 0)
    1:           {
    1:             curBlockQuote = n;
    1:             firstBQChild  = curNode;
    1:             lastBQChild   = curNode;
    1:             curBlockQuoteIsIndentedWithCSS = PR_TRUE;
    1:             break;
    1:           }
    1:         }
    1:       }
    1: 
    1:       if (!curBlockQuote)
    1:       {
    1:         // could not find an enclosing blockquote for this node.  handle list cases.
    1:         if (nsHTMLEditUtils::IsList(curParent))  // move node out of list
    1:         {
    1:           if (nsHTMLEditUtils::IsList(curNode))  // just unwrap this sublist
    1:           {
    1:             res = mHTMLEditor->RemoveBlockContainer(curNode);
43805:             NS_ENSURE_SUCCESS(res, res);
    1:           }
    1:           // handled list item case above
    1:         }
    1:         else if (nsHTMLEditUtils::IsList(curNode)) // node is a list, but parent is non-list: move list items out
    1:         {
    1:           nsCOMPtr<nsIDOMNode> child;
    1:           curNode->GetLastChild(getter_AddRefs(child));
    1:           while (child)
    1:           {
    1:             if (nsHTMLEditUtils::IsListItem(child))
    1:             {
    1:               PRBool bOutOfList;
    1:               res = PopListItem(child, &bOutOfList);
43805:               NS_ENSURE_SUCCESS(res, res);
    1:             }
    1:             else if (nsHTMLEditUtils::IsList(child))
    1:             {
    1:               // We have an embedded list, so move it out from under the
    1:               // parent list. Be sure to put it after the parent list
    1:               // because this loop iterates backwards through the parent's
    1:               // list of children.
    1: 
    1:               res = mHTMLEditor->MoveNode(child, curParent, offset + 1);
43805:               NS_ENSURE_SUCCESS(res, res);
    1:             }
    1:             else
    1:             {
    1:               // delete any non- list items for now
    1:               res = mHTMLEditor->DeleteNode(child);
43805:               NS_ENSURE_SUCCESS(res, res);
    1:             }
    1:             curNode->GetLastChild(getter_AddRefs(child));
    1:           }
    1:           // delete the now-empty list
    1:           res = mHTMLEditor->RemoveBlockContainer(curNode);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:         }
    1:         else if (useCSS) {
38284:           nsCOMPtr<nsIDOMElement> element;
38284:           nsCOMPtr<nsIDOMText> textNode = do_QueryInterface(curNode);
38284:           if (textNode) {
38284:             // We want to outdent the parent of text nodes
38284:             nsCOMPtr<nsIDOMNode> parent;
38284:             textNode->GetParentNode(getter_AddRefs(parent));
38284:             element = do_QueryInterface(parent);
38284:           } else {
38284:             element = do_QueryInterface(curNode);
38284:           }
38284:           if (element) {
38284:             RelativeChangeIndentationOfElementNode(element, -1);
38284:           }
    1:         }
    1:       }
    1:     }
    1:     if (curBlockQuote)
    1:     {
    1:       // we have a blockquote we haven't finished handling
    1:       res = OutdentPartOfBlock(curBlockQuote, firstBQChild, lastBQChild,
    1:                                curBlockQuoteIsIndentedWithCSS,
    1:                                address_of(rememberedLeftBQ),
    1:                                address_of(rememberedRightBQ));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:   }
    1:   // make sure selection didn't stick to last piece of content in old bq
    1:   // (only a problem for collapsed selections)
    1:   if (rememberedLeftBQ || rememberedRightBQ)
    1:   {
    1:     PRBool bCollapsed;
    1:     res = aSelection->GetIsCollapsed(&bCollapsed);
    1:     if (bCollapsed)
    1:     {
    1:       // push selection past end of rememberedLeftBQ
    1:       nsCOMPtr<nsIDOMNode> sNode;
    1:       PRInt32 sOffset;
43518:       mHTMLEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(sNode), &sOffset);
    1:       if (rememberedLeftBQ &&
    1:           ((sNode == rememberedLeftBQ) || nsEditorUtils::IsDescendantOf(sNode, rememberedLeftBQ)))
    1:       {
    1:         // selection is inside rememberedLeftBQ - push it past it.
    1:         nsEditor::GetNodeLocation(rememberedLeftBQ, address_of(sNode), &sOffset);
    1:         sOffset++;
    1:         aSelection->Collapse(sNode, sOffset);
    1:       }
    1:       // and pull selection before beginning of rememberedRightBQ
43518:       mHTMLEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(sNode), &sOffset);
    1:       if (rememberedRightBQ &&
    1:           ((sNode == rememberedRightBQ) || nsEditorUtils::IsDescendantOf(sNode, rememberedRightBQ)))
    1:       {
    1:         // selection is inside rememberedRightBQ - push it before it.
    1:         nsEditor::GetNodeLocation(rememberedRightBQ, address_of(sNode), &sOffset);
    1:         aSelection->Collapse(sNode, sOffset);
    1:       }
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // RemovePartOfBlock:  split aBlock and move aStartChild to aEndChild out
    1: //                     of aBlock.  return left side of block (if any) in
    1: //                     aLeftNode.  return right side of block (if any) in
    1: //                     aRightNode.  
    1: //                  
    1: nsresult 
    1: nsHTMLEditRules::RemovePartOfBlock(nsIDOMNode *aBlock, 
    1:                                    nsIDOMNode *aStartChild, 
    1:                                    nsIDOMNode *aEndChild,
    1:                                    nsCOMPtr<nsIDOMNode> *aLeftNode,
    1:                                    nsCOMPtr<nsIDOMNode> *aRightNode)
    1: {
    1:   nsCOMPtr<nsIDOMNode> middleNode;
    1:   nsresult res = SplitBlock(aBlock, aStartChild, aEndChild,
    1:                             aLeftNode, aRightNode,
    1:                             address_of(middleNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   // get rid of part of blockquote we are outdenting
    1: 
    1:   return mHTMLEditor->RemoveBlockContainer(aBlock);
    1: }
    1: 
    1: nsresult 
    1: nsHTMLEditRules::SplitBlock(nsIDOMNode *aBlock, 
    1:                             nsIDOMNode *aStartChild, 
    1:                             nsIDOMNode *aEndChild,
    1:                             nsCOMPtr<nsIDOMNode> *aLeftNode,
    1:                             nsCOMPtr<nsIDOMNode> *aRightNode,
    1:                             nsCOMPtr<nsIDOMNode> *aMiddleNode)
    1: {
43807:   NS_ENSURE_TRUE(aBlock && aStartChild && aEndChild, NS_ERROR_NULL_POINTER);
    1:   
    1:   nsCOMPtr<nsIDOMNode> startParent, endParent, leftNode, rightNode;
    1:   PRInt32 startOffset, endOffset, offset;
    1:   nsresult res;
    1: 
    1:   // get split point location
    1:   res = nsEditor::GetNodeLocation(aStartChild, address_of(startParent), &startOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   // do the splits!
    1:   res = mHTMLEditor->SplitNodeDeep(aBlock, startParent, startOffset, &offset, 
    1:                                    PR_TRUE, address_of(leftNode), address_of(rightNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (rightNode)  aBlock = rightNode;
    1: 
    1:   // remember left portion of block if caller requested
    1:   if (aLeftNode) 
    1:     *aLeftNode = leftNode;
    1: 
    1:   // get split point location
    1:   res = nsEditor::GetNodeLocation(aEndChild, address_of(endParent), &endOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   endOffset++;  // want to be after lastBQChild
    1: 
    1:   // do the splits!
    1:   res = mHTMLEditor->SplitNodeDeep(aBlock, endParent, endOffset, &offset, 
    1:                                    PR_TRUE, address_of(leftNode), address_of(rightNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (leftNode)  aBlock = leftNode;
    1:   
    1:   // remember right portion of block if caller requested
    1:   if (aRightNode) 
    1:     *aRightNode = rightNode;
    1: 
    1:   if (aMiddleNode)
    1:     *aMiddleNode = aBlock;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditRules::OutdentPartOfBlock(nsIDOMNode *aBlock, 
    1:                                     nsIDOMNode *aStartChild, 
    1:                                     nsIDOMNode *aEndChild,
    1:                                     PRBool aIsBlockIndentedWithCSS,
    1:                                     nsCOMPtr<nsIDOMNode> *aLeftNode,
    1:                                     nsCOMPtr<nsIDOMNode> *aRightNode)
    1: {
    1:   nsCOMPtr<nsIDOMNode> middleNode;
    1:   nsresult res = SplitBlock(aBlock, aStartChild, aEndChild, 
    1:                             aLeftNode,
    1:                             aRightNode,
    1:                             address_of(middleNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (aIsBlockIndentedWithCSS)
    1:     res = RelativeChangeIndentationOfElementNode(middleNode, -1);
    1:   else
    1:     res = mHTMLEditor->RemoveBlockContainer(middleNode);
    1:   return res;
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // ConvertListType:  convert list type and list item type.
    1: //                
    1: //                  
    1: nsresult 
    1: nsHTMLEditRules::ConvertListType(nsIDOMNode *aList, 
    1:                                  nsCOMPtr<nsIDOMNode> *outList,
    1:                                  const nsAString& aListType, 
    1:                                  const nsAString& aItemType) 
    1: {
43806:   NS_ENSURE_TRUE(aList && outList, NS_ERROR_NULL_POINTER);
    1:   *outList = aList;  // we might not need to change the list
    1:   nsresult res = NS_OK;
    1:   nsCOMPtr<nsIDOMNode> child, temp;
    1:   aList->GetFirstChild(getter_AddRefs(child));
    1:   while (child)
    1:   {
    1:     if (nsHTMLEditUtils::IsListItem(child) && !nsEditor::NodeIsTypeString(child, aItemType))
    1:     {
    1:       res = mHTMLEditor->ReplaceContainer(child, address_of(temp), aItemType);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       child = temp;
    1:     }
    1:     else if (nsHTMLEditUtils::IsList(child) && !nsEditor::NodeIsTypeString(child, aListType))
    1:     {
    1:       res = ConvertListType(child, address_of(temp), aListType, aItemType);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       child = temp;
    1:     }
    1:     child->GetNextSibling(getter_AddRefs(temp));
    1:     child = temp;
    1:   }
    1:   if (!nsEditor::NodeIsTypeString(aList, aListType))
    1:   {
    1:     res = mHTMLEditor->ReplaceContainer(aList, outList, aListType);
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // CreateStyleForInsertText:  take care of clearing and setting appropriate
    1: //                            style nodes for text insertion.
    1: //                
    1: //                  
    1: nsresult 
    1: nsHTMLEditRules::CreateStyleForInsertText(nsISelection *aSelection, nsIDOMDocument *aDoc) 
    1: {
43806:   NS_ENSURE_TRUE(aSelection && aDoc, NS_ERROR_NULL_POINTER);
43806:   NS_ENSURE_TRUE(mHTMLEditor->mTypeInState, NS_ERROR_NULL_POINTER);
    1:   
    1:   PRBool weDidSometing = PR_FALSE;
    1:   nsCOMPtr<nsIDOMNode> node, tmp;
    1:   PRInt32 offset;
43518:   nsresult res = mHTMLEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(node), &offset);
 8943:   NS_ENSURE_SUCCESS(res, res);
 8943:   nsAutoPtr<PropItem> item;
    1:   
    1:   // if we deleted selection then also for cached styles
    1:   if (mDidDeleteSelection && 
    1:       ((mTheAction == nsEditor::kOpInsertText ) ||
    1:        (mTheAction == nsEditor::kOpInsertIMEText) ||
    1:        (mTheAction == nsEditor::kOpInsertBreak) ||
    1:        (mTheAction == nsEditor::kOpDeleteSelection)))
    1:   {
    1:     res = ReapplyCachedStyles();
 8943:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   // either way we clear the cached styles array
    1:   res = ClearCachedStyles();  
 8943:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // next examine our present style and make sure default styles are either present or
    1:   // explicitly overridden.  If neither, add the default style to the TypeInState
27986:   PRInt32 j, defcon = mHTMLEditor->mDefaultStyles.Length();
    1:   for (j=0; j<defcon; j++)
    1:   {
27986:     PropItem *propItem = mHTMLEditor->mDefaultStyles[j];
43807:     NS_ENSURE_TRUE(propItem, NS_ERROR_NULL_POINTER);
    1:     PRBool bFirst, bAny, bAll;
    1: 
    1:     // GetInlineProperty also examine TypeInState.  The only gotcha here is that a cleared
    1:     // property looks like an unset property.  For now I'm assuming that's not a problem:
    1:     // that default styles will always be multivalue styles (like font face or size) where
    1:     // clearing the style means we want to go back to the default.  If we ever wanted a 
    1:     // "toggle" style like bold for a default, though, I'll have to add code to detect the
    1:     // difference between unset and explicitly cleared, else user would never be able to
    1:     // unbold, for instance.
    1:     nsAutoString curValue;
    1:     res = mHTMLEditor->GetInlinePropertyBase(propItem->tag, &(propItem->attr), nsnull, 
    1:                                              &bFirst, &bAny, &bAll, &curValue, PR_FALSE);
 8943:     NS_ENSURE_SUCCESS(res, res);
    1:     
    1:     if (!bAny)  // no style set for this prop/attr
    1:     {
    1:       mHTMLEditor->mTypeInState->SetProp(propItem->tag, propItem->attr, propItem->value);
    1:     }
    1:   }
    1:   
39468:   nsCOMPtr<nsIDOMElement> rootElement;
39468:   res = aDoc->GetDocumentElement(getter_AddRefs(rootElement));
39468:   NS_ENSURE_SUCCESS(res, res);
39468: 
    1:   // process clearing any styles first
 8943:   mHTMLEditor->mTypeInState->TakeClearProperty(getter_Transfers(item));
39468:   while (item && node != rootElement)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> leftNode, rightNode, secondSplitParent, newSelParent, savedBR;
    1:     res = mHTMLEditor->SplitStyleAbovePoint(address_of(node), &offset, item->tag, &item->attr, address_of(leftNode), address_of(rightNode));
 8943:     NS_ENSURE_SUCCESS(res, res);
    1:     PRBool bIsEmptyNode;
    1:     if (leftNode)
    1:     {
    1:       mHTMLEditor->IsEmptyNode(leftNode, &bIsEmptyNode, PR_FALSE, PR_TRUE);
    1:       if (bIsEmptyNode)
    1:       {
    1:         // delete leftNode if it became empty
    1:         res = mEditor->DeleteNode(leftNode);
 8943:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:     }
    1:     if (rightNode)
    1:     {
    1:       secondSplitParent = mHTMLEditor->GetLeftmostChild(rightNode);
    1:       // don't try to split non-containers (br's, images, hr's, etc)
    1:       if (!secondSplitParent) secondSplitParent = rightNode;
    1:       if (!mHTMLEditor->IsContainer(secondSplitParent))
    1:       {
    1:         if (nsTextEditUtils::IsBreak(secondSplitParent))
    1:           savedBR = secondSplitParent;
    1: 
    1:         secondSplitParent->GetParentNode(getter_AddRefs(tmp));
    1:         secondSplitParent = tmp;
    1:       }
    1:       offset = 0;
    1:       res = mHTMLEditor->SplitStyleAbovePoint(address_of(secondSplitParent), &offset, item->tag, &(item->attr), address_of(leftNode), address_of(rightNode));
 8943:       NS_ENSURE_SUCCESS(res, res);
    1:       // should be impossible to not get a new leftnode here
43806:       NS_ENSURE_TRUE(leftNode, NS_ERROR_FAILURE);
    1:       newSelParent = mHTMLEditor->GetLeftmostChild(leftNode);
    1:       if (!newSelParent) newSelParent = leftNode;
    1:       // if rightNode starts with a br, suck it out of right node and into leftNode.
    1:       // This is so we you don't revert back to the previous style if you happen to click at the end of a line.
    1:       if (savedBR)
    1:       {
    1:         res = mEditor->MoveNode(savedBR, newSelParent, 0);
 8943:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:       mHTMLEditor->IsEmptyNode(rightNode, &bIsEmptyNode, PR_FALSE, PR_TRUE);
    1:       if (bIsEmptyNode)
    1:       {
    1:         // delete rightNode if it became empty
    1:         res = mEditor->DeleteNode(rightNode);
 8943:         NS_ENSURE_SUCCESS(res, res);
    1:       }
41545:       // remove the style on this new hierarchy
    1:       PRInt32 newSelOffset = 0;
    1:       {
41545:         // track the point at the new hierarchy.
    1:         // This is so we can know where to put the selection after we call
    1:         // RemoveStyleInside().  RemoveStyleInside() could remove any and all of those nodes,
    1:         // so I have to use the range tracking system to find the right spot to put selection.
    1:         nsAutoTrackDOMPoint tracker(mHTMLEditor->mRangeUpdater, address_of(newSelParent), &newSelOffset);
    1:         res = mHTMLEditor->RemoveStyleInside(leftNode, item->tag, &(item->attr));
 8943:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:       // reset our node offset values to the resulting new sel point
    1:       node = newSelParent;
    1:       offset = newSelOffset;
    1:     }
 8943:     mHTMLEditor->mTypeInState->TakeClearProperty(getter_Transfers(item));
    1:     weDidSometing = PR_TRUE;
    1:   }
    1:   
    1:   // then process setting any styles
    1:   PRInt32 relFontSize;
    1:   
    1:   res = mHTMLEditor->mTypeInState->TakeRelativeFontSize(&relFontSize);
 8943:   NS_ENSURE_SUCCESS(res, res);
 8943:   res = mHTMLEditor->mTypeInState->TakeSetProperty(getter_Transfers(item));
 8943:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   if (item || relFontSize) // we have at least one style to add; make a
    1:   {                        // new text node to insert style nodes above.
    1:     if (mHTMLEditor->IsTextNode(node))
    1:     {
    1:       // if we are in a text node, split it
    1:       res = mHTMLEditor->SplitNodeDeep(node, node, offset, &offset);
 8943:       NS_ENSURE_SUCCESS(res, res);
    1:       node->GetParentNode(getter_AddRefs(tmp));
    1:       node = tmp;
    1:     }
43891:     if (!mHTMLEditor->IsContainer(node))
43891:     {
43891:       return NS_OK;
43891:     }
    1:     nsCOMPtr<nsIDOMNode> newNode;
    1:     nsCOMPtr<nsIDOMText> nodeAsText;
    1:     res = aDoc->CreateTextNode(EmptyString(), getter_AddRefs(nodeAsText));
 8943:     NS_ENSURE_SUCCESS(res, res);
43806:     NS_ENSURE_TRUE(nodeAsText, NS_ERROR_NULL_POINTER);
    1:     newNode = do_QueryInterface(nodeAsText);
    1:     res = mHTMLEditor->InsertNode(newNode, node, offset);
 8943:     NS_ENSURE_SUCCESS(res, res);
    1:     node = newNode;
    1:     offset = 0;
    1:     weDidSometing = PR_TRUE;
    1: 
    1:     if (relFontSize)
    1:     {
    1:       PRInt32 j, dir;
    1:       // dir indicated bigger versus smaller.  1 = bigger, -1 = smaller
    1:       if (relFontSize > 0) dir=1;
    1:       else dir = -1;
    1:       for (j=0; j<abs(relFontSize); j++)
    1:       {
    1:         res = mHTMLEditor->RelativeFontChangeOnTextNode(dir, nodeAsText, 0, -1);
 8943:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:     }
    1:     
    1:     while (item)
    1:     {
    1:       res = mHTMLEditor->SetInlinePropertyOnNode(node, item->tag, &item->attr, &item->value);
 8943:       NS_ENSURE_SUCCESS(res, res);
 8943:       mHTMLEditor->mTypeInState->TakeSetProperty(getter_Transfers(item));
    1:     }
    1:   }
    1:   if (weDidSometing)
    1:     return aSelection->Collapse(node, offset);
    1:     
    1:   return res;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // IsEmptyBlock: figure out if aNode is (or is inside) an empty block.
    1: //               A block can have children and still be considered empty,
    1: //               if the children are empty or non-editable.
    1: //                  
    1: nsresult 
    1: nsHTMLEditRules::IsEmptyBlock(nsIDOMNode *aNode, 
    1:                               PRBool *outIsEmptyBlock, 
    1:                               PRBool aMozBRDoesntCount,
    1:                               PRBool aListItemsNotEmpty) 
    1: {
43806:   NS_ENSURE_TRUE(aNode && outIsEmptyBlock, NS_ERROR_NULL_POINTER);
    1:   *outIsEmptyBlock = PR_TRUE;
    1:   
    1: //  nsresult res = NS_OK;
    1:   nsCOMPtr<nsIDOMNode> nodeToTest;
    1:   if (IsBlockNode(aNode)) nodeToTest = do_QueryInterface(aNode);
    1: //  else nsCOMPtr<nsIDOMElement> block;
    1: //  looks like I forgot to finish this.  Wonder what I was going to do?
    1: 
43806:   NS_ENSURE_TRUE(nodeToTest, NS_ERROR_NULL_POINTER);
    1:   return mHTMLEditor->IsEmptyNode(nodeToTest, outIsEmptyBlock,
    1:                      aMozBRDoesntCount, aListItemsNotEmpty);
    1: }
    1: 
    1: 
    1: nsresult
    1: nsHTMLEditRules::WillAlign(nsISelection *aSelection, 
    1:                            const nsAString *alignType, 
    1:                            PRBool *aCancel,
    1:                            PRBool *aHandled)
    1: {
    1:   if (!aSelection || !aCancel || !aHandled) { return NS_ERROR_NULL_POINTER; }
    1: 
    1:   nsresult res = WillInsert(aSelection, aCancel);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // initialize out param
    1:   // we want to ignore result of WillInsert()
    1:   *aCancel = PR_FALSE;
    1:   *aHandled = PR_FALSE;
    1: 
    1:   res = NormalizeSelection(aSelection);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   nsAutoSelectionReset selectionResetter(aSelection, mHTMLEditor);
    1: 
    1:   // convert the selection ranges into "promoted" selection ranges:
    1:   // this basically just expands the range to include the immediate
    1:   // block parent, and then further expands to include any ancestors
    1:   // whose children are all in the range
    1:   *aHandled = PR_TRUE;
    1:   nsCOMArray<nsIDOMNode> arrayOfNodes;
    1:   res = GetNodesFromSelection(aSelection, kAlign, arrayOfNodes);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // if we don't have any nodes, or we have only a single br, then we are
    1:   // creating an empty alignment div.  We have to do some different things for these.
    1:   PRBool emptyDiv = PR_FALSE;
    1:   PRInt32 listCount = arrayOfNodes.Count();
    1:   if (!listCount) emptyDiv = PR_TRUE;
    1:   if (listCount == 1)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> theNode = arrayOfNodes[0];
    1: 
    1:     if (nsHTMLEditUtils::SupportsAlignAttr(theNode))
    1:     {
    1:       // the node is a table element, an horiz rule, a paragraph, a div
    1:       // or a section header; in HTML 4, it can directly carry the ALIGN
    1:       // attribute and we don't need to make a div! If we are in CSS mode,
    1:       // all the work is done in AlignBlock
    1:       nsCOMPtr<nsIDOMElement> theElem = do_QueryInterface(theNode);
    1:       res = AlignBlock(theElem, alignType, PR_TRUE);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       return NS_OK;
    1:     }
    1: 
    1:     if (nsTextEditUtils::IsBreak(theNode))
    1:     {
    1:       // The special case emptyDiv code (below) that consumes BRs can
    1:       // cause tables to split if the start node of the selection is
    1:       // not in a table cell or caption, for example parent is a <tr>.
    1:       // Avoid this unnecessary splitting if possible by leaving emptyDiv
    1:       // FALSE so that we fall through to the normal case alignment code.
    1:       //
    1:       // XXX: It seems a little error prone for the emptyDiv special
    1:       //      case code to assume that the start node of the selection
    1:       //      is the parent of the single node in the arrayOfNodes, as
    1:       //      the paragraph above points out. Do we rely on the selection
    1:       //      start node because of the fact that arrayOfNodes can be empty?
    1:       //      We should probably revisit this issue. - kin
    1: 
    1:       nsCOMPtr<nsIDOMNode> parent;
    1:       PRInt32 offset;
43518:       res = mHTMLEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(parent), &offset);
    1: 
    1:       if (!nsHTMLEditUtils::IsTableElement(parent) || nsHTMLEditUtils::IsTableCellOrCaption(parent))
    1:         emptyDiv = PR_TRUE;
    1:     }
    1:   }
    1:   if (emptyDiv)
    1:   {
    1:     PRInt32 offset;
    1:     nsCOMPtr<nsIDOMNode> brNode, parent, theDiv, sib;
    1:     NS_NAMED_LITERAL_STRING(divType, "div");
43518:     res = mHTMLEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(parent), &offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     res = SplitAsNeeded(&divType, address_of(parent), &offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     // consume a trailing br, if any.  This is to keep an alignment from
    1:     // creating extra lines, if possible.
    1:     res = mHTMLEditor->GetNextHTMLNode(parent, offset, address_of(brNode));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (brNode && nsTextEditUtils::IsBreak(brNode))
    1:     {
    1:       // making use of html structure... if next node after where
    1:       // we are putting our div is not a block, then the br we 
    1:       // found is in same block we are, so its safe to consume it.
    1:       res = mHTMLEditor->GetNextHTMLSibling(parent, offset, address_of(sib));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       if (!IsBlockNode(sib))
    1:       {
    1:         res = mHTMLEditor->DeleteNode(brNode);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:     }
    1:     res = mHTMLEditor->CreateNode(divType, parent, offset, getter_AddRefs(theDiv));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     // remember our new block for postprocessing
    1:     mNewBlock = theDiv;
    1:     // set up the alignment on the div, using HTML or CSS
    1:     nsCOMPtr<nsIDOMElement> divElem = do_QueryInterface(theDiv);
    1:     res = AlignBlock(divElem, alignType, PR_TRUE);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     *aHandled = PR_TRUE;
    1:     // put in a moz-br so that it won't get deleted
    1:     res = CreateMozBR(theDiv, 0, address_of(brNode));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     res = aSelection->Collapse(theDiv, 0);
    1:     selectionResetter.Abort();  // don't reset our selection in this case.
    1:     return res;
    1:   }
    1: 
    1:   // Next we detect all the transitions in the array, where a transition
    1:   // means that adjacent nodes in the array don't have the same parent.
    1: 
27986:   nsTArray<PRPackedBool> transitionList;
    1:   res = MakeTransitionList(arrayOfNodes, transitionList);
43805:   NS_ENSURE_SUCCESS(res, res);                                 
    1: 
    1:   // Ok, now go through all the nodes and give them an align attrib or put them in a div, 
    1:   // or whatever is appropriate.  Wohoo!
    1: 
    1:   PRInt32 i;
    1:   nsCOMPtr<nsIDOMNode> curParent;
    1:   nsCOMPtr<nsIDOMNode> curDiv;
    1:   PRBool useCSS;
    1:   mHTMLEditor->GetIsCSSEnabled(&useCSS);
    1:   for (i=0; i<listCount; i++)
    1:   {
    1:     // here's where we actually figure out what to do
    1:     nsCOMPtr<nsIDOMNode> curNode = arrayOfNodes[i];
    1:     PRInt32 offset;
    1:     res = nsEditor::GetNodeLocation(curNode, address_of(curParent), &offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1: 
    1:     // the node is a table element, an horiz rule, a paragraph, a div
    1:     // or a section header; in HTML 4, it can directly carry the ALIGN
    1:     // attribute and we don't need to nest it, just set the alignment.
    1:     // In CSS, assign the corresponding CSS styles in AlignBlock
    1:     if (nsHTMLEditUtils::SupportsAlignAttr(curNode))
    1:     {
    1:       nsCOMPtr<nsIDOMElement> curElem = do_QueryInterface(curNode);
    1:       res = AlignBlock(curElem, alignType, PR_FALSE);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       // clear out curDiv so that we don't put nodes after this one into it
    1:       curDiv = 0;
    1:       continue;
    1:     }
    1: 
    1:     // Skip insignificant formatting text nodes to prevent
    1:     // unnecessary structure splitting!
    1:     if (nsEditor::IsTextNode(curNode) &&
    1:        ((nsHTMLEditUtils::IsTableElement(curParent) && !nsHTMLEditUtils::IsTableCellOrCaption(curParent)) ||
    1:         nsHTMLEditUtils::IsList(curParent)))
    1:       continue;
    1: 
    1:     // if it's a list item, or a list
    1:     // inside a list, forget any "current" div, and instead put divs inside
    1:     // the appropriate block (td, li, etc)
    1:     if ( nsHTMLEditUtils::IsListItem(curNode)
    1:          || nsHTMLEditUtils::IsList(curNode))
    1:     {
    1:       res = RemoveAlignment(curNode, *alignType, PR_TRUE);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       if (useCSS) {
    1:         nsCOMPtr<nsIDOMElement> curElem = do_QueryInterface(curNode);
    1:         NS_NAMED_LITERAL_STRING(attrName, "align");
    1:         PRInt32 count;
    1:         mHTMLEditor->mHTMLCSSUtils->SetCSSEquivalentToHTMLStyle(curNode, nsnull,
    1:                                                                 &attrName, alignType,
    1:                                                                 &count, PR_FALSE);
    1:         curDiv = 0;
    1:         continue;
    1:       }
    1:       else if (nsHTMLEditUtils::IsList(curParent)) {
    1:         // if we don't use CSS, add a contraint to list element : they have
    1:         // to be inside another list, ie >= second level of nesting
    1:         res = AlignInnerBlocks(curNode, alignType);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         curDiv = 0;
    1:         continue;
    1:       }
    1:       // clear out curDiv so that we don't put nodes after this one into it
    1:     }      
    1: 
    1:     // need to make a div to put things in if we haven't already,
    1:     // or if this node doesn't go in div we used earlier.
    1:     if (!curDiv || transitionList[i])
    1:     {
    1:       NS_NAMED_LITERAL_STRING(divType, "div");
    1:       res = SplitAsNeeded(&divType, address_of(curParent), &offset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = mHTMLEditor->CreateNode(divType, curParent, offset, getter_AddRefs(curDiv));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       // remember our new block for postprocessing
    1:       mNewBlock = curDiv;
    1:       // set up the alignment on the div
    1:       nsCOMPtr<nsIDOMElement> divElem = do_QueryInterface(curDiv);
    1:       res = AlignBlock(divElem, alignType, PR_TRUE);
    1: //      nsAutoString attr(NS_LITERAL_STRING("align"));
    1: //      res = mHTMLEditor->SetAttribute(divElem, attr, *alignType);
43805: //      NS_ENSURE_SUCCESS(res, res);
    1:       // curDiv is now the correct thing to put curNode in
    1:     }
    1: 
    1:     // tuck the node into the end of the active div
    1:     res = mHTMLEditor->MoveNode(curNode, curDiv, -1);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1: 
    1:   return res;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // AlignInnerBlocks: align inside table cells or list items
    1: //       
    1: nsresult
    1: nsHTMLEditRules::AlignInnerBlocks(nsIDOMNode *aNode, const nsAString *alignType)
    1: {
43806:   NS_ENSURE_TRUE(aNode && alignType, NS_ERROR_NULL_POINTER);
    1:   nsresult res;
    1:   
    1:   // gather list of table cells or list items
    1:   nsCOMArray<nsIDOMNode> arrayOfNodes;
    1:   nsTableCellAndListItemFunctor functor;
    1:   nsDOMIterator iter;
    1:   res = iter.Init(aNode);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = iter.AppendList(functor, arrayOfNodes);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   // now that we have the list, align their contents as requested
    1:   PRInt32 listCount = arrayOfNodes.Count();
    1:   PRInt32 j;
    1: 
    1:   for (j = 0; j < listCount; j++)
    1:   {
    1:     nsIDOMNode* node = arrayOfNodes[0];
    1:     res = AlignBlockContents(node, alignType);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     arrayOfNodes.RemoveObjectAt(0);
    1:   }
    1: 
    1:   return res;  
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // AlignBlockContents: align contents of a block element
    1: //                  
    1: nsresult
    1: nsHTMLEditRules::AlignBlockContents(nsIDOMNode *aNode, const nsAString *alignType)
    1: {
43806:   NS_ENSURE_TRUE(aNode && alignType, NS_ERROR_NULL_POINTER);
    1:   nsresult res;
    1:   nsCOMPtr <nsIDOMNode> firstChild, lastChild, divNode;
    1:   
    1:   PRBool useCSS;
    1:   mHTMLEditor->GetIsCSSEnabled(&useCSS);
    1: 
    1:   res = mHTMLEditor->GetFirstEditableChild(aNode, address_of(firstChild));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = mHTMLEditor->GetLastEditableChild(aNode, address_of(lastChild));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   NS_NAMED_LITERAL_STRING(attr, "align");
    1:   if (!firstChild)
    1:   {
    1:     // this cell has no content, nothing to align
    1:   }
    1:   else if ((firstChild==lastChild) && nsHTMLEditUtils::IsDiv(firstChild))
    1:   {
    1:     // the cell already has a div containing all of it's content: just
    1:     // act on this div.
    1:     nsCOMPtr<nsIDOMElement> divElem = do_QueryInterface(firstChild);
    1:     if (useCSS) {
    1:       res = mHTMLEditor->SetAttributeOrEquivalent(divElem, attr, *alignType, PR_FALSE); 
    1:     }
    1:     else {
    1:       res = mHTMLEditor->SetAttribute(divElem, attr, *alignType);
    1:     }
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   else
    1:   {
    1:     // else we need to put in a div, set the alignment, and toss in all the children
    1:     res = mHTMLEditor->CreateNode(NS_LITERAL_STRING("div"), aNode, 0, getter_AddRefs(divNode));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     // set up the alignment on the div
    1:     nsCOMPtr<nsIDOMElement> divElem = do_QueryInterface(divNode);
    1:     if (useCSS) {
    1:       res = mHTMLEditor->SetAttributeOrEquivalent(divElem, attr, *alignType, PR_FALSE); 
    1:     }
    1:     else {
    1:       res = mHTMLEditor->SetAttribute(divElem, attr, *alignType);
    1:     }
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     // tuck the children into the end of the active div
    1:     while (lastChild && (lastChild != divNode))
    1:     {
    1:       res = mHTMLEditor->MoveNode(lastChild, divNode, 0);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = mHTMLEditor->GetLastEditableChild(aNode, address_of(lastChild));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // CheckForEmptyBlock: Called by WillDeleteSelection to detect and handle
    1: //                     case of deleting from inside an empty block.
    1: //                  
    1: nsresult
    1: nsHTMLEditRules::CheckForEmptyBlock(nsIDOMNode *aStartNode, 
    1:                                     nsIDOMNode *aBodyNode,
    1:                                     nsISelection *aSelection,
    1:                                     PRBool *aHandled)
    1: {
    1:   // if we are inside an empty block, delete it.
    1:   // Note: do NOT delete table elements this way.
    1:   nsresult res = NS_OK;
    1:   nsCOMPtr<nsIDOMNode> block, emptyBlock;
    1:   if (IsBlockNode(aStartNode)) 
    1:     block = aStartNode;
    1:   else
    1:     block = mHTMLEditor->GetBlockNodeParent(aStartNode);
    1:   PRBool bIsEmptyNode;
    1:   if (block != aBodyNode)  // efficiency hack. avoiding IsEmptyNode() call when in body
    1:   {
    1:     res = mHTMLEditor->IsEmptyNode(block, &bIsEmptyNode, PR_TRUE, PR_FALSE);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     while (bIsEmptyNode && !nsHTMLEditUtils::IsTableElement(block) && (block != aBodyNode))
    1:     {
    1:       emptyBlock = block;
    1:       block = mHTMLEditor->GetBlockNodeParent(emptyBlock);
    1:       res = mHTMLEditor->IsEmptyNode(block, &bIsEmptyNode, PR_TRUE, PR_FALSE);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:   }
    1:   
    1:   if (emptyBlock)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> blockParent;
    1:     PRInt32 offset;
    1:     res = nsEditor::GetNodeLocation(emptyBlock, address_of(blockParent), &offset);
43805:     NS_ENSURE_SUCCESS(res, res);
43806:     NS_ENSURE_TRUE(blockParent && offset >= 0, NS_ERROR_FAILURE);
    1: 
    1:     if (nsHTMLEditUtils::IsListItem(emptyBlock))
    1:     {
    1:       // are we the first list item in the list?
    1:       PRBool bIsFirst;
    1:       res = mHTMLEditor->IsFirstEditableChild(emptyBlock, &bIsFirst);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       if (bIsFirst)
    1:       {
    1:         nsCOMPtr<nsIDOMNode> listParent;
    1:         PRInt32 listOffset;
    1:         res = nsEditor::GetNodeLocation(blockParent, address_of(listParent), &listOffset);
43805:         NS_ENSURE_SUCCESS(res, res);
43806:         NS_ENSURE_TRUE(listParent && listOffset >= 0, NS_ERROR_FAILURE);
    1:         // if we are a sublist, skip the br creation
    1:         if (!nsHTMLEditUtils::IsList(listParent))
    1:         {
    1:           // create a br before list
    1:           nsCOMPtr<nsIDOMNode> brNode;
    1:           res = mHTMLEditor->CreateBR(listParent, listOffset, address_of(brNode));
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           // adjust selection to be right before it
    1:           res = aSelection->Collapse(listParent, listOffset);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:         }
    1:         // else just let selection perculate up.  We'll adjust it in AfterEdit()
    1:       }
    1:     }
    1:     else
    1:     {
    1:       // adjust selection to be right after it
    1:       res = aSelection->Collapse(blockParent, offset+1);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     res = mHTMLEditor->DeleteNode(emptyBlock);
    1:     *aHandled = PR_TRUE;
    1:   }
    1:   return res;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditRules::CheckForInvisibleBR(nsIDOMNode *aBlock, 
    1:                                      BRLocation aWhere, 
    1:                                      nsCOMPtr<nsIDOMNode> *outBRNode,
    1:                                      PRInt32 aOffset)
    1: {
43806:   NS_ENSURE_TRUE(aBlock && outBRNode, NS_ERROR_NULL_POINTER);
    1:   *outBRNode = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMNode> testNode;
    1:   PRInt32 testOffset = 0;
    1:   PRBool runTest = PR_FALSE;
    1: 
    1:   if (aWhere == kBlockEnd)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> rightmostNode;
    1:     rightmostNode = mHTMLEditor->GetRightmostChild(aBlock, PR_TRUE); // no block crossing
    1: 
    1:     if (rightmostNode)
    1:     {
    1:       nsCOMPtr<nsIDOMNode> nodeParent;
    1:       PRInt32 nodeOffset;
    1: 
    1:       if (NS_SUCCEEDED(nsEditor::GetNodeLocation(rightmostNode,
    1:                                                  address_of(nodeParent), 
    1:                                                  &nodeOffset)))
    1:       {
    1:         runTest = PR_TRUE;
    1:         testNode = nodeParent;
    1:         // use offset + 1, because we want the last node included in our evaluation
    1:         testOffset = nodeOffset + 1;
    1:       }
    1:     }
    1:   }
    1:   else if (aOffset)
    1:   {
    1:     runTest = PR_TRUE;
    1:     testNode = aBlock;
    1:     // we'll check everything to the left of the input position
    1:     testOffset = aOffset;
    1:   }
    1: 
    1:   if (runTest)
    1:   {
    1:     nsWSRunObject wsTester(mHTMLEditor, testNode, testOffset);
    1:     if (nsWSRunObject::eBreak == wsTester.mStartReason)
    1:     {
    1:       *outBRNode = wsTester.mStartReasonNode;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetInnerContent: aList and aTbl allow the caller to specify what kind 
    1: //                  of content to "look inside".  If aTbl is true, look inside
    1: //                  any table content, and insert the inner content into the
    1: //                  supplied issupportsarray at offset aIndex.  
    1: //                  Similarly with aList and list content.
    1: //                  aIndex is updated to point past inserted elements.
    1: //                  
    1: nsresult
    1: nsHTMLEditRules::GetInnerContent(nsIDOMNode *aNode, nsCOMArray<nsIDOMNode> &outArrayOfNodes, 
    1:                                  PRInt32 *aIndex, PRBool aList, PRBool aTbl)
    1: {
43806:   NS_ENSURE_TRUE(aNode && aIndex, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   
    1:   nsresult res = mHTMLEditor->GetFirstEditableChild(aNode, address_of(node));
    1:   while (NS_SUCCEEDED(res) && node)
    1:   {
    1:     if (  ( aList && (nsHTMLEditUtils::IsList(node)     || 
    1:                       nsHTMLEditUtils::IsListItem(node) ) )
    1:        || ( aTbl && nsHTMLEditUtils::IsTableElement(node) )  )
    1:     {
    1:       res = GetInnerContent(node, outArrayOfNodes, aIndex, aList, aTbl);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     else
    1:     {
    1:       outArrayOfNodes.InsertObjectAt(node, *aIndex);
    1:       (*aIndex)++;
    1:     }
    1:     nsCOMPtr<nsIDOMNode> tmp;
    1:     res = node->GetNextSibling(getter_AddRefs(tmp));
    1:     node = tmp;
    1:   }
    1: 
    1:   return res;
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // ExpandSelectionForDeletion: this promotes our selection to include blocks
    1: // that have all their children selected.
    1: //                  
    1: PRBool
    1: nsHTMLEditRules::ExpandSelectionForDeletion(nsISelection *aSelection)
    1: {
43807:   NS_ENSURE_TRUE(aSelection, NS_ERROR_NULL_POINTER);
    1:   
    1:   // don't need to touch collapsed selections
    1:   PRBool bCollapsed;
    1:   nsresult res = aSelection->GetIsCollapsed(&bCollapsed);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (bCollapsed) return res;
    1: 
    1:   PRInt32 rangeCount;
    1:   res = aSelection->GetRangeCount(&rangeCount);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   // we don't need to mess with cell selections, and we assume multirange selections are those.
    1:   if (rangeCount != 1) return NS_OK;
    1:   
    1:   // find current sel start and end
    1:   nsCOMPtr<nsIDOMRange> range;
    1:   res = aSelection->GetRangeAt(0, getter_AddRefs(range));
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(range, NS_ERROR_NULL_POINTER);
    1:   nsCOMPtr<nsIDOMNode> selStartNode, selEndNode, selCommon;
    1:   PRInt32 selStartOffset, selEndOffset;
    1:   
    1:   res = range->GetStartContainer(getter_AddRefs(selStartNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = range->GetStartOffset(&selStartOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = range->GetEndContainer(getter_AddRefs(selEndNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = range->GetEndOffset(&selEndOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // find current selection common block parent
    1:   res = range->GetCommonAncestorContainer(getter_AddRefs(selCommon));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (!IsBlockNode(selCommon))
    1:     selCommon = nsHTMLEditor::GetBlockNodeParent(selCommon);
    1: 
    1:   // set up for loops and cache our root element
    1:   PRBool stillLooking = PR_TRUE;
    1:   nsCOMPtr<nsIDOMNode> visNode, firstBRParent;
    1:   PRInt32 visOffset=0, firstBROffset=0;
    1:   PRInt16 wsType;
    1:   nsIDOMElement *rootElement = mHTMLEditor->GetRoot();
43807:   NS_ENSURE_TRUE(rootElement, NS_ERROR_FAILURE);
    1: 
    1:   // find previous visible thingy before start of selection
    1:   if ((selStartNode!=selCommon) && (selStartNode!=rootElement))
    1:   {
    1:     while (stillLooking)
    1:     {
    1:       nsWSRunObject wsObj(mHTMLEditor, selStartNode, selStartOffset);
    1:       res = wsObj.PriorVisibleNode(selStartNode, selStartOffset, address_of(visNode), &visOffset, &wsType);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       if (wsType == nsWSRunObject::eThisBlock)
    1:       {
    1:         // we want to keep looking up.  But stop if we are crossing table element
    1:         // boundaries, or if we hit the root.
    1:         if ( nsHTMLEditUtils::IsTableElement(wsObj.mStartReasonNode) ||
    1:             (selCommon == wsObj.mStartReasonNode)                    ||
    1:             (rootElement == wsObj.mStartReasonNode) )
    1:         {
    1:           stillLooking = PR_FALSE;
    1:         }
    1:         else
    1:         { 
    1:           nsEditor::GetNodeLocation(wsObj.mStartReasonNode, address_of(selStartNode), &selStartOffset);
    1:         }
    1:       }
    1:       else
    1:       {
    1:         stillLooking = PR_FALSE;
    1:       }
    1:     }
    1:   }
    1:   
    1:   stillLooking = PR_TRUE;
    1:   // find next visible thingy after end of selection
    1:   if ((selEndNode!=selCommon) && (selEndNode!=rootElement))
    1:   {
    1:     while (stillLooking)
    1:     {
    1:       nsWSRunObject wsObj(mHTMLEditor, selEndNode, selEndOffset);
    1:       res = wsObj.NextVisibleNode(selEndNode, selEndOffset, address_of(visNode), &visOffset, &wsType);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       if (wsType == nsWSRunObject::eBreak)
    1:       {
    1:         if (mHTMLEditor->IsVisBreak(wsObj.mEndReasonNode))
    1:         {
    1:           stillLooking = PR_FALSE;
    1:         }
    1:         else
    1:         { 
    1:           if (!firstBRParent)
    1:           {
    1:             firstBRParent = selEndNode;
    1:             firstBROffset = selEndOffset;
    1:           }
    1:           nsEditor::GetNodeLocation(wsObj.mEndReasonNode, address_of(selEndNode), &selEndOffset);
    1:           ++selEndOffset;
    1:         }
    1:       }
    1:       else if (wsType == nsWSRunObject::eThisBlock)
    1:       {
    1:         // we want to keep looking up.  But stop if we are crossing table element
    1:         // boundaries, or if we hit the root.
    1:         if ( nsHTMLEditUtils::IsTableElement(wsObj.mEndReasonNode) ||
    1:             (selCommon == wsObj.mEndReasonNode)                    ||
    1:             (rootElement == wsObj.mEndReasonNode) )
    1:         {
    1:           stillLooking = PR_FALSE;
    1:         }
    1:         else
    1:         { 
    1:           nsEditor::GetNodeLocation(wsObj.mEndReasonNode, address_of(selEndNode), &selEndOffset);
    1:           ++selEndOffset;
    1:         }
    1:        }
    1:       else
    1:       {
    1:         stillLooking = PR_FALSE;
    1:       }
    1:     }
    1:   }
    1:   // now set the selection to the new range
    1:   aSelection->Collapse(selStartNode, selStartOffset);
    1:   
    1:   // expand selection endpoint only if we didnt pass a br,
    1:   // or if we really needed to pass that br (ie, it's block is now 
    1:   // totally selected)
    1:   PRBool doEndExpansion = PR_TRUE;
    1:   if (firstBRParent)
    1:   {
    1:     // find block node containing br
    1:     nsCOMPtr<nsIDOMNode> brBlock = firstBRParent;
    1:     if (!IsBlockNode(brBlock))
    1:       brBlock = nsHTMLEditor::GetBlockNodeParent(brBlock);
    1:     PRBool nodeBefore=PR_FALSE, nodeAfter=PR_FALSE;
    1:     
    1:     // create a range that represents expanded selection
    1:     nsCOMPtr<nsIDOMRange> range = do_CreateInstance("@mozilla.org/content/range;1");
43806:     NS_ENSURE_TRUE(range, NS_ERROR_NULL_POINTER);
    1:     res = range->SetStart(selStartNode, selStartOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     res = range->SetEnd(selEndNode, selEndOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     
    1:     // check if block is entirely inside range
    1:     nsCOMPtr<nsIContent> brContentBlock = do_QueryInterface(brBlock);
    1:     res = mHTMLEditor->sRangeHelper->CompareNodeToRange(brContentBlock, range, &nodeBefore, &nodeAfter);
    1:     
    1:     // if block isn't contained, forgo grabbing the br in the expanded selection
    1:     if (nodeBefore || nodeAfter)
    1:       doEndExpansion = PR_FALSE;
    1:   }
    1:   if (doEndExpansion)
    1:   {
    1:     res = aSelection->Extend(selEndNode, selEndOffset);
    1:   }
    1:   else
    1:   {
    1:     // only expand to just before br
    1:     res = aSelection->Extend(firstBRParent, firstBROffset);
    1:   }
    1:   
    1:   return res;
    1: }
    1: 
    1: #ifdef XXX_DEAD_CODE
    1: ///////////////////////////////////////////////////////////////////////////
    1: // AtStartOfBlock: is node/offset at the start of the editable material in this block?
    1: //                  
    1: PRBool
    1: nsHTMLEditRules::AtStartOfBlock(nsIDOMNode *aNode, PRInt32 aOffset, nsIDOMNode *aBlock)
    1: {
    1:   nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(aNode);
    1:   if (nodeAsText && aOffset) return PR_FALSE;  // there are chars in front of us
    1:   
    1:   nsCOMPtr<nsIDOMNode> priorNode;
    1:   nsresult  res = mHTMLEditor->GetPriorHTMLNode(aNode, aOffset, address_of(priorNode));
43805:   NS_ENSURE_SUCCESS(res, PR_TRUE);
43806:   NS_ENSURE_TRUE(priorNode, PR_TRUE);
    1:   nsCOMPtr<nsIDOMNode> blockParent = mHTMLEditor->GetBlockNodeParent(priorNode);
    1:   if (blockParent && (blockParent == aBlock)) return PR_FALSE;
    1:   return PR_TRUE;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // AtEndOfBlock: is node/offset at the end of the editable material in this block?
    1: //                  
    1: PRBool
    1: nsHTMLEditRules::AtEndOfBlock(nsIDOMNode *aNode, PRInt32 aOffset, nsIDOMNode *aBlock)
    1: {
    1:   nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(aNode);
    1:   if (nodeAsText)   
    1:   {
    1:     PRUint32 strLength;
    1:     nodeAsText->GetLength(&strLength);
    1:     if ((PRInt32)strLength > aOffset) return PR_FALSE;  // there are chars in after us
    1:   }
    1:   nsCOMPtr<nsIDOMNode> nextNode;
    1:   nsresult  res = mHTMLEditor->GetNextHTMLNode(aNode, aOffset, address_of(nextNode));
43805:   NS_ENSURE_SUCCESS(res, PR_TRUE);
43806:   NS_ENSURE_TRUE(nextNode, PR_TRUE);
    1:   nsCOMPtr<nsIDOMNode> blockParent = mHTMLEditor->GetBlockNodeParent(nextNode);
    1:   if (blockParent && (blockParent == aBlock)) return PR_FALSE;
    1:   return PR_TRUE;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // CreateMozDiv: makes a div with type = _moz
    1: //                       
    1: nsresult
    1: nsHTMLEditRules::CreateMozDiv(nsIDOMNode *inParent, PRInt32 inOffset, nsCOMPtr<nsIDOMNode> *outDiv)
    1: {
43806:   NS_ENSURE_TRUE(inParent && outDiv, NS_ERROR_NULL_POINTER);
    1:   nsAutoString divType= "div";
    1:   *outDiv = nsnull;
    1:   nsresult res = mHTMLEditor->CreateNode(divType, inParent, inOffset, getter_AddRefs(*outDiv));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   // give it special moz attr
    1:   nsCOMPtr<nsIDOMElement> mozDivElem = do_QueryInterface(*outDiv);
    1:   res = mHTMLEditor->SetAttribute(mozDivElem, "type", "_moz");
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = AddTrailerBR(*outDiv);
    1:   return res;
    1: }
    1: #endif    
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // NormalizeSelection:  tweak non-collapsed selections to be more "natural".
    1: //    Idea here is to adjust selection endpoint so that they do not cross
    1: //    breaks or block boundaries unless something editable beyond that boundary
    1: //    is also selected.  This adjustment makes it much easier for the various
    1: //    block operations to determine what nodes to act on.
    1: //                       
    1: nsresult 
    1: nsHTMLEditRules::NormalizeSelection(nsISelection *inSelection)
    1: {
43806:   NS_ENSURE_TRUE(inSelection, NS_ERROR_NULL_POINTER);
    1: 
    1:   // don't need to touch collapsed selections
    1:   PRBool bCollapsed;
    1:   nsresult res = inSelection->GetIsCollapsed(&bCollapsed);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (bCollapsed) return res;
    1: 
    1:   PRInt32 rangeCount;
    1:   res = inSelection->GetRangeCount(&rangeCount);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   // we don't need to mess with cell selections, and we assume multirange selections are those.
    1:   if (rangeCount != 1) return NS_OK;
    1:   
    1:   nsCOMPtr<nsIDOMRange> range;
    1:   res = inSelection->GetRangeAt(0, getter_AddRefs(range));
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(range, NS_ERROR_NULL_POINTER);
    1:   nsCOMPtr<nsIDOMNode> startNode, endNode;
    1:   PRInt32 startOffset, endOffset;
    1:   nsCOMPtr<nsIDOMNode> newStartNode, newEndNode;
    1:   PRInt32 newStartOffset, newEndOffset;
    1:   
    1:   res = range->GetStartContainer(getter_AddRefs(startNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = range->GetStartOffset(&startOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = range->GetEndContainer(getter_AddRefs(endNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = range->GetEndOffset(&endOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   // adjusted values default to original values
    1:   newStartNode = startNode; 
    1:   newStartOffset = startOffset;
    1:   newEndNode = endNode; 
    1:   newEndOffset = endOffset;
    1:   
    1:   // some locals we need for whitespace code
    1:   nsCOMPtr<nsIDOMNode> someNode;
    1:   PRInt32 offset;
    1:   PRInt16 wsType;
    1: 
    1:   // let the whitespace code do the heavy lifting
    1:   nsWSRunObject wsEndObj(mHTMLEditor, endNode, endOffset);
    1:   // is there any intervening visible whitespace?  if so we can't push selection past that,
    1:   // it would visibly change maening of users selection
    1:   res = wsEndObj.PriorVisibleNode(endNode, endOffset, address_of(someNode), &offset, &wsType);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if ((wsType != nsWSRunObject::eText) && (wsType != nsWSRunObject::eNormalWS))
    1:   {
    1:     // eThisBlock and eOtherBlock conveniently distinquish cases
    1:     // of going "down" into a block and "up" out of a block.
    1:     if (wsEndObj.mStartReason == nsWSRunObject::eOtherBlock) 
    1:     {
    1:       // endpoint is just after the close of a block.
    1:       nsCOMPtr<nsIDOMNode> child = mHTMLEditor->GetRightmostChild(wsEndObj.mStartReasonNode, PR_TRUE);
    1:       if (child)
    1:       {
    1:         res = nsEditor::GetNodeLocation(child, address_of(newEndNode), &newEndOffset);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         ++newEndOffset; // offset *after* child
    1:       }
    1:       // else block is empty - we can leave selection alone here, i think.
    1:     }
    1:     else if (wsEndObj.mStartReason == nsWSRunObject::eThisBlock)
    1:     {
    1:       // endpoint is just after start of this block
    1:       nsCOMPtr<nsIDOMNode> child;
    1:       res = mHTMLEditor->GetPriorHTMLNode(endNode, endOffset, address_of(child));
    1:       if (child)
    1:       {
    1:         res = nsEditor::GetNodeLocation(child, address_of(newEndNode), &newEndOffset);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         ++newEndOffset; // offset *after* child
    1:       }
    1:       // else block is empty - we can leave selection alone here, i think.
    1:     }
    1:     else if (wsEndObj.mStartReason == nsWSRunObject::eBreak)
    1:     {                                       
    1:       // endpoint is just after break.  lets adjust it to before it.
    1:       res = nsEditor::GetNodeLocation(wsEndObj.mStartReasonNode, address_of(newEndNode), &newEndOffset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:   }
    1:   
    1:   
    1:   // similar dealio for start of range
    1:   nsWSRunObject wsStartObj(mHTMLEditor, startNode, startOffset);
    1:   // is there any intervening visible whitespace?  if so we can't push selection past that,
    1:   // it would visibly change maening of users selection
    1:   res = wsStartObj.NextVisibleNode(startNode, startOffset, address_of(someNode), &offset, &wsType);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if ((wsType != nsWSRunObject::eText) && (wsType != nsWSRunObject::eNormalWS))
    1:   {
    1:     // eThisBlock and eOtherBlock conveniently distinquish cases
    1:     // of going "down" into a block and "up" out of a block.
    1:     if (wsStartObj.mEndReason == nsWSRunObject::eOtherBlock) 
    1:     {
    1:       // startpoint is just before the start of a block.
    1:       nsCOMPtr<nsIDOMNode> child = mHTMLEditor->GetLeftmostChild(wsStartObj.mEndReasonNode, PR_TRUE);
    1:       if (child)
    1:       {
    1:         res = nsEditor::GetNodeLocation(child, address_of(newStartNode), &newStartOffset);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:       // else block is empty - we can leave selection alone here, i think.
    1:     }
    1:     else if (wsStartObj.mEndReason == nsWSRunObject::eThisBlock)
    1:     {
    1:       // startpoint is just before end of this block
    1:       nsCOMPtr<nsIDOMNode> child;
    1:       res = mHTMLEditor->GetNextHTMLNode(startNode, startOffset, address_of(child));
    1:       if (child)
    1:       {
    1:         res = nsEditor::GetNodeLocation(child, address_of(newStartNode), &newStartOffset);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:       // else block is empty - we can leave selection alone here, i think.
    1:     }
    1:     else if (wsStartObj.mEndReason == nsWSRunObject::eBreak)
    1:     {                                       
    1:       // startpoint is just before a break.  lets adjust it to after it.
    1:       res = nsEditor::GetNodeLocation(wsStartObj.mEndReasonNode, address_of(newStartNode), &newStartOffset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       ++newStartOffset; // offset *after* break
    1:     }
    1:   }
    1:   
    1:   // there is a demented possiblity we have to check for.  We might have a very strange selection
    1:   // that is not collapsed and yet does not contain any editable content, and satisfies some of the
    1:   // above conditions that cause tweaking.  In this case we don't want to tweak the selection into
    1:   // a block it was never in, etc.  There are a variety of strategies one might use to try to
    1:   // detect these cases, but I think the most straightforward is to see if the adjusted locations
    1:   // "cross" the old values: ie, new end before old start, or new start after old end.  If so 
    1:   // then just leave things alone.
    1:   
    1:   PRInt16 comp;
    1:   comp = mHTMLEditor->sRangeHelper->ComparePoints(startNode, startOffset, newEndNode, newEndOffset);
    1:   if (comp == 1) return NS_OK;  // new end before old start
    1:   comp = mHTMLEditor->sRangeHelper->ComparePoints(newStartNode, newStartOffset, endNode, endOffset);
    1:   if (comp == 1) return NS_OK;  // new start after old end
    1:   
    1:   // otherwise set selection to new values.  
    1:   inSelection->Collapse(newStartNode, newStartOffset);
    1:   inSelection->Extend(newEndNode, newEndOffset);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetPromotedPoint: figure out where a start or end point for a block
    1: //                   operation really is
    1: nsresult
    1: nsHTMLEditRules::GetPromotedPoint(RulesEndpoint aWhere, nsIDOMNode *aNode, PRInt32 aOffset, 
    1:                                   PRInt32 actionID, nsCOMPtr<nsIDOMNode> *outNode, PRInt32 *outOffset)
    1: {
    1:   nsresult res = NS_OK;
    1:   nsCOMPtr<nsIDOMNode> nearNode, node = aNode;
    1:   nsCOMPtr<nsIDOMNode> parent = aNode;
    1:   PRInt32 pOffset, offset = aOffset;
    1:   
    1:   // default values
    1:   *outNode = node;
    1:   *outOffset = offset;
    1: 
    1:   // we do one thing for InsertText actions, something else entirely for other actions
    1:   if (actionID == kInsertText)
    1:   {
    1:     PRBool isSpace, isNBSP; 
    1:     nsCOMPtr<nsIDOMNode> temp;   
    1:     // for insert text or delete actions, we want to look backwards (or forwards, as appropriate)
    1:     // for additional whitespace or nbsp's.  We may have to act on these later even though
    1:     // they are outside of the initial selection.  Even if they are in another node!
    1:     if (aWhere == kStart)
    1:     {
    1:       do
    1:       {
    1:         res = mHTMLEditor->IsPrevCharWhitespace(node, offset, &isSpace, &isNBSP, address_of(temp), &offset);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         if (isSpace || isNBSP) node = temp;
    1:         else break;
    1:       } while (node);
    1:   
    1:       *outNode = node;
    1:       *outOffset = offset;
    1:     }
    1:     else if (aWhere == kEnd)
    1:     {
    1:       do
    1:       {
    1:         res = mHTMLEditor->IsNextCharWhitespace(node, offset, &isSpace, &isNBSP, address_of(temp), &offset);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         if (isSpace || isNBSP) node = temp;
    1:         else break;
    1:       } while (node);
    1:   
    1:       *outNode = node;
    1:       *outOffset = offset;
    1:     }
    1:     return res;
    1:   }
    1:   
    1:   // else not kInsertText.  In this case we want to see if we should
    1:   // grab any adjacent inline nodes and/or parents and other ancestors
    1:   if (aWhere == kStart)
    1:   {
    1:     // some special casing for text nodes
    1:     if (nsEditor::IsTextNode(aNode))  
    1:     {
    1:       res = nsEditor::GetNodeLocation(aNode, address_of(node), &offset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1: 
    1:     // look back through any further inline nodes that
    1:     // aren't across a <br> from us, and that are enclosed in the same block.
    1:     nsCOMPtr<nsIDOMNode> priorNode;
    1:     res = mHTMLEditor->GetPriorHTMLNode(node, offset, address_of(priorNode), PR_TRUE);
    1:       
    1:     while (priorNode && NS_SUCCEEDED(res))
    1:     {
    1:       if (mHTMLEditor->IsVisBreak(priorNode))
    1:         break;
    1:       if (IsBlockNode(priorNode))
    1:         break;
    1:       res = nsEditor::GetNodeLocation(priorNode, address_of(node), &offset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = mHTMLEditor->GetPriorHTMLNode(node, offset, address_of(priorNode), PR_TRUE);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     
    1:         
    1:     // finding the real start for this point.  look up the tree for as long as we are the 
    1:     // first node in the container, and as long as we haven't hit the body node.
    1:     res = mHTMLEditor->GetPriorHTMLNode(node, offset, address_of(nearNode), PR_TRUE);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     while (!nearNode && !nsTextEditUtils::IsBody(node))
    1:     {
    1:       // some cutoffs are here: we don't need to also include them in the aWhere == kEnd case.
    1:       // as long as they are in one or the other it will work.
    1:       // special case for outdent: don't keep looking up 
    1:       // if we have found a blockquote element to act on
    1:       if ((actionID == kOutdent) && nsHTMLEditUtils::IsBlockquote(node))
    1:         break;
    1: 
    1:       res = nsEditor::GetNodeLocation(node, address_of(parent), &pOffset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       node = parent;
    1:       offset = pOffset;
    1:       res = mHTMLEditor->GetPriorHTMLNode(node, offset, address_of(nearNode), PR_TRUE);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     } 
    1:     *outNode = node;
    1:     *outOffset = offset;
    1:     return res;
    1:   }
    1:   
    1:   if (aWhere == kEnd)
    1:   {
    1:     // some special casing for text nodes
    1:     if (nsEditor::IsTextNode(aNode))  
    1:     {
    1:       res = nsEditor::GetNodeLocation(aNode, address_of(node), &offset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       offset++; // want to be after the text node
    1:     }
    1: 
    1:     // look ahead through any further inline nodes that
    1:     // aren't across a <br> from us, and that are enclosed in the same block.
    1:     nsCOMPtr<nsIDOMNode> nextNode;
    1:     res = mHTMLEditor->GetNextHTMLNode(node, offset, address_of(nextNode), PR_TRUE);
    1:       
    1:     while (nextNode && NS_SUCCEEDED(res))
    1:     {
    1:       if (IsBlockNode(nextNode))
    1:         break;
    1:       res = nsEditor::GetNodeLocation(nextNode, address_of(node), &offset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       offset++;
    1:       if (mHTMLEditor->IsVisBreak(nextNode))
    1:         break;
    1:       res = mHTMLEditor->GetNextHTMLNode(node, offset, address_of(nextNode), PR_TRUE);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     
    1:     // finding the real end for this point.  look up the tree for as long as we are the 
    1:     // last node in the container, and as long as we haven't hit the body node.
    1:     res = mHTMLEditor->GetNextHTMLNode(node, offset, address_of(nearNode), PR_TRUE);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     while (!nearNode && !nsTextEditUtils::IsBody(node))
    1:     {
    1:       res = nsEditor::GetNodeLocation(node, address_of(parent), &pOffset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       node = parent;
    1:       offset = pOffset+1;  // we want to be AFTER nearNode
    1:       res = mHTMLEditor->GetNextHTMLNode(node, offset, address_of(nearNode), PR_TRUE);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     } 
    1:     *outNode = node;
    1:     *outOffset = offset;
    1:     return res;
    1:   }
    1:   
    1:   return res;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetPromotedRanges: run all the selection range endpoint through 
    1: //                    GetPromotedPoint()
    1: //                       
    1: nsresult 
    1: nsHTMLEditRules::GetPromotedRanges(nsISelection *inSelection, 
    1:                                    nsCOMArray<nsIDOMRange> &outArrayOfRanges, 
    1:                                    PRInt32 inOperationType)
    1: {
43806:   NS_ENSURE_TRUE(inSelection, NS_ERROR_NULL_POINTER);
    1: 
    1:   PRInt32 rangeCount;
    1:   nsresult res = inSelection->GetRangeCount(&rangeCount);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   PRInt32 i;
    1:   nsCOMPtr<nsIDOMRange> selectionRange;
    1:   nsCOMPtr<nsIDOMRange> opRange;
    1: 
    1:   for (i = 0; i < rangeCount; i++)
    1:   {
    1:     res = inSelection->GetRangeAt(i, getter_AddRefs(selectionRange));
43805:     NS_ENSURE_SUCCESS(res, res);
    1: 
    1:     // clone range so we don't muck with actual selection ranges
    1:     res = selectionRange->CloneRange(getter_AddRefs(opRange));
43805:     NS_ENSURE_SUCCESS(res, res);
    1: 
    1:     // make a new adjusted range to represent the appropriate block content.
    1:     // The basic idea is to push out the range endpoints
    1:     // to truly enclose the blocks that we will affect.
    1:     // This call alters opRange.
    1:     res = PromoteRange(opRange, inOperationType);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:       
    1:     // stuff new opRange into array
    1:     outArrayOfRanges.AppendObject(opRange);
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // PromoteRange: expand a range to include any parents for which all
    1: //               editable children are already in range. 
    1: //                       
    1: nsresult 
    1: nsHTMLEditRules::PromoteRange(nsIDOMRange *inRange, 
    1:                               PRInt32 inOperationType)
    1: {
43806:   NS_ENSURE_TRUE(inRange, NS_ERROR_NULL_POINTER);
    1:   nsresult res;
    1:   nsCOMPtr<nsIDOMNode> startNode, endNode;
    1:   PRInt32 startOffset, endOffset;
    1:   
    1:   res = inRange->GetStartContainer(getter_AddRefs(startNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->GetStartOffset(&startOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->GetEndContainer(getter_AddRefs(endNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->GetEndOffset(&endOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   // MOOSE major hack:
    1:   // GetPromotedPoint doesn't really do the right thing for collapsed ranges
    1:   // inside block elements that contain nothing but a solo <br>.  It's easier
    1:   // to put a workaround here than to revamp GetPromotedPoint.  :-(
    1:   if ( (startNode == endNode) && (startOffset == endOffset))
    1:   {
    1:     nsCOMPtr<nsIDOMNode> block;
    1:     if (IsBlockNode(startNode)) 
    1:       block = startNode;
    1:     else
    1:       block = mHTMLEditor->GetBlockNodeParent(startNode);
    1:     if (block)
    1:     {
    1:       PRBool bIsEmptyNode = PR_FALSE;
    1:       // check for body
    1:       nsIDOMElement *rootElement = mHTMLEditor->GetRoot();
43892:       nsCOMPtr<nsINode> rootNode = do_QueryInterface(rootElement);
43892:       nsCOMPtr<nsINode> blockNode = do_QueryInterface(block);
43892:       NS_ENSURE_TRUE(rootNode && blockNode, NS_ERROR_UNEXPECTED);
43892:       // Make sure we don't go higher than our root element in the content tree
43892:       if (!nsContentUtils::ContentIsDescendantOf(rootNode, blockNode))
43892:       {
    1:         res = mHTMLEditor->IsEmptyNode(block, &bIsEmptyNode, PR_TRUE, PR_FALSE);
    1:       }
    1:       if (bIsEmptyNode)
    1:       {
    1:         PRUint32 numChildren;
    1:         nsEditor::GetLengthOfDOMNode(block, numChildren); 
    1:         startNode = block;
    1:         endNode = block;
    1:         startOffset = 0;
    1:         endOffset = numChildren;
    1:       }
    1:     }
    1:   }
    1: 
    1:   // make a new adjusted range to represent the appropriate block content.
    1:   // this is tricky.  the basic idea is to push out the range endpoints
    1:   // to truly enclose the blocks that we will affect
    1:   
    1:   nsCOMPtr<nsIDOMNode> opStartNode;
    1:   nsCOMPtr<nsIDOMNode> opEndNode;
    1:   PRInt32 opStartOffset, opEndOffset;
    1:   nsCOMPtr<nsIDOMRange> opRange;
    1:   
    1:   res = GetPromotedPoint( kStart, startNode, startOffset, inOperationType, address_of(opStartNode), &opStartOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = GetPromotedPoint( kEnd, endNode, endOffset, inOperationType, address_of(opEndNode), &opEndOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->SetStart(opStartNode, opStartOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->SetEnd(opEndNode, opEndOffset);
    1:   return res;
    1: } 
    1: 
 3074: class nsUniqueFunctor : public nsBoolDomIterFunctor
 3074: {
 3074: public:
 3074:   nsUniqueFunctor(nsCOMArray<nsIDOMNode> &aArray) : mArray(aArray)
 3074:   {
 3074:   }
 3074:   virtual PRBool operator()(nsIDOMNode* aNode)  // used to build list of all nodes iterator covers
 3074:   {
 3074:     return mArray.IndexOf(aNode) < 0;
 3074:   }
 3074: 
 3074: private:
 3074:   nsCOMArray<nsIDOMNode> &mArray;
 3074: };
 3074: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetNodesForOperation: run through the ranges in the array and construct 
    1: //                       a new array of nodes to be acted on.
    1: //                       
    1: nsresult 
    1: nsHTMLEditRules::GetNodesForOperation(nsCOMArray<nsIDOMRange>& inArrayOfRanges, 
    1:                                       nsCOMArray<nsIDOMNode>& outArrayOfNodes, 
    1:                                       PRInt32 inOperationType,
    1:                                       PRBool aDontTouchContent)
    1: {
    1:   PRInt32 rangeCount = inArrayOfRanges.Count();
    1:   
    1:   PRInt32 i;
    1:   nsCOMPtr<nsIDOMRange> opRange;
    1: 
    1:   PRBool useCSS;
    1:   mHTMLEditor->GetIsCSSEnabled(&useCSS);
    1: 
    1:   nsresult res = NS_OK;
    1:   
    1:   // bust up any inlines that cross our range endpoints,
    1:   // but only if we are allowed to touch content.
    1:   
    1:   if (!aDontTouchContent)
    1:   {
23148:     nsAutoTArray<nsRangeStore, 16> rangeItemArray;
23148:     if (!rangeItemArray.AppendElements(rangeCount)) {
23148:       return NS_ERROR_OUT_OF_MEMORY;
23148:     }
23148: 
23148:     NS_ASSERTION(rangeCount == rangeItemArray.Length(), "How did that happen?");
23148: 
    1:     // first register ranges for special editor gravity
56879:     for (i = 0; i < rangeCount; i++)
    1:     {
    1:       opRange = inArrayOfRanges[0];
23148:       nsRangeStore *item = rangeItemArray.Elements() + i;
    1:       item->StoreRange(opRange);
    1:       mHTMLEditor->mRangeUpdater.RegisterRangeItem(item);
    1:       inArrayOfRanges.RemoveObjectAt(0);
    1:     }    
23148:     // now bust up inlines.  Safe to start at rangeCount-1, since we
23148:     // asserted we have enough items above.
23148:     for (i = rangeCount-1; i >= 0 && NS_SUCCEEDED(res); i--)
23148:     {
23148:       res = BustUpInlinesAtRangeEndpoints(rangeItemArray[i]);
    1:     } 
    1:     // then unregister the ranges
    1:     for (i = 0; i < rangeCount; i++)
    1:     {
23148:       nsRangeStore *item = rangeItemArray.Elements() + i;
    1:       mHTMLEditor->mRangeUpdater.DropRangeItem(item);
23148:       nsresult res2 = item->GetRange(address_of(opRange));
23148:       if (NS_FAILED(res2) && NS_SUCCEEDED(res)) {
23148:         // Remember the failure, but keep going so we make sure to unregister
23148:         // all our range items.
23148:         res = res2;
23148:       }
    1:       inArrayOfRanges.AppendObject(opRange);
    1:     }
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   // gather up a list of all the nodes
    1:   for (i = 0; i < rangeCount; i++)
    1:   {
    1:     opRange = inArrayOfRanges[i];
    1:     
    1:     nsDOMSubtreeIterator iter;
    1:     res = iter.Init(opRange);
43805:     NS_ENSURE_SUCCESS(res, res);
 3074:     if (outArrayOfNodes.Count() == 0) {
 3074:       nsTrivialFunctor functor;
    1:       res = iter.AppendList(functor, outArrayOfNodes);
43805:       NS_ENSURE_SUCCESS(res, res);    
    1:     }
 3074:     else {
 3074:       // We don't want duplicates in outArrayOfNodes, so we use an
 3074:       // iterator/functor that only return nodes that are not already in
 3074:       // outArrayOfNodes.
 3074:       nsCOMArray<nsIDOMNode> nodes;
 3074:       nsUniqueFunctor functor(outArrayOfNodes);
 3074:       res = iter.AppendList(functor, nodes);
43805:       NS_ENSURE_SUCCESS(res, res);
 3074:       if (!outArrayOfNodes.AppendObjects(nodes))
 3074:         return NS_ERROR_OUT_OF_MEMORY;
 3074:     }
 3074:   }    
    1: 
    1:   // certain operations should not act on li's and td's, but rather inside 
    1:   // them.  alter the list as needed
    1:   if (inOperationType == kMakeBasicBlock)
    1:   {
    1:     PRInt32 listCount = outArrayOfNodes.Count();
    1:     for (i=listCount-1; i>=0; i--)
    1:     {
    1:       nsCOMPtr<nsIDOMNode> node = outArrayOfNodes[i];
    1:       if (nsHTMLEditUtils::IsListItem(node))
    1:       {
    1:         PRInt32 j=i;
    1:         outArrayOfNodes.RemoveObjectAt(i);
    1:         res = GetInnerContent(node, outArrayOfNodes, &j);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:     }
    1:   }
    1:   // indent/outdent already do something special for list items, but
    1:   // we still need to make sure we don't act on table elements
    1:   else if ( (inOperationType == kOutdent)  ||
    1:             (inOperationType == kIndent)   ||
    1:             (inOperationType == kSetAbsolutePosition))
    1:   {
    1:     PRInt32 listCount = outArrayOfNodes.Count();
    1:     for (i=listCount-1; i>=0; i--)
    1:     {
    1:       nsCOMPtr<nsIDOMNode> node = outArrayOfNodes[i];
    1:       if (nsHTMLEditUtils::IsTableElementButNotTable(node))
    1:       {
    1:         PRInt32 j=i;
    1:         outArrayOfNodes.RemoveObjectAt(i);
    1:         res = GetInnerContent(node, outArrayOfNodes, &j);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:     }
    1:   }
    1:   // outdent should look inside of divs.
    1:   if (inOperationType == kOutdent && !useCSS) 
    1:   {
    1:     PRInt32 listCount = outArrayOfNodes.Count();
    1:     for (i=listCount-1; i>=0; i--)
    1:     {
    1:       nsCOMPtr<nsIDOMNode> node = outArrayOfNodes[i];
    1:       if (nsHTMLEditUtils::IsDiv(node))
    1:       {
    1:         PRInt32 j=i;
    1:         outArrayOfNodes.RemoveObjectAt(i);
    1:         res = GetInnerContent(node, outArrayOfNodes, &j, PR_FALSE, PR_FALSE);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:     }
    1:   }
    1: 
    1: 
    1:   // post process the list to break up inline containers that contain br's.
    1:   // but only for operations that might care, like making lists or para's...
    1:   if ( (inOperationType == kMakeBasicBlock)   ||
    1:        (inOperationType == kMakeList)         ||
    1:        (inOperationType == kAlign)            ||
    1:        (inOperationType == kSetAbsolutePosition) ||
    1:        (inOperationType == kIndent)           ||
    1:        (inOperationType == kOutdent) )
    1:   {
    1:     PRInt32 listCount = outArrayOfNodes.Count();
    1:     for (i=listCount-1; i>=0; i--)
    1:     {
    1:       nsCOMPtr<nsIDOMNode> node = outArrayOfNodes[i];
    1:       if (!aDontTouchContent && IsInlineNode(node) 
    1:            && mHTMLEditor->IsContainer(node) && !mHTMLEditor->IsTextNode(node))
    1:       {
    1:         nsCOMArray<nsIDOMNode> arrayOfInlines;
    1:         res = BustUpInlinesAtBRs(node, arrayOfInlines);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         // put these nodes in outArrayOfNodes, replacing the current node
    1:         outArrayOfNodes.RemoveObjectAt(i);
    1:         outArrayOfNodes.InsertObjectsAt(arrayOfInlines, i);
    1:       }
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetChildNodesForOperation: 
    1: //                       
    1: nsresult 
    1: nsHTMLEditRules::GetChildNodesForOperation(nsIDOMNode *inNode, 
    1:                                            nsCOMArray<nsIDOMNode>& outArrayOfNodes)
    1: {
43806:   NS_ENSURE_TRUE(inNode, NS_ERROR_NULL_POINTER);
    1:   
    1:   nsCOMPtr<nsIDOMNodeList> childNodes;
    1:   nsresult res = inNode->GetChildNodes(getter_AddRefs(childNodes));
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(childNodes, NS_ERROR_NULL_POINTER);
    1:   PRUint32 childCount;
    1:   res = childNodes->GetLength(&childCount);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   PRUint32 i;
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   for (i = 0; i < childCount; i++)
    1:   {
    1:     res = childNodes->Item( i, getter_AddRefs(node));
43806:     NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
    1:     if (!outArrayOfNodes.AppendObject(node))
    1:       return NS_ERROR_FAILURE;
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetListActionNodes: 
    1: //                       
    1: nsresult 
    1: nsHTMLEditRules::GetListActionNodes(nsCOMArray<nsIDOMNode> &outArrayOfNodes, 
    1:                                     PRBool aEntireList,
    1:                                     PRBool aDontTouchContent)
    1: {
    1:   nsresult res = NS_OK;
    1:   
    1:   nsCOMPtr<nsISelection>selection;
    1:   res = mHTMLEditor->GetSelection(getter_AddRefs(selection));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(selection));
43807:   NS_ENSURE_TRUE(selPriv, NS_ERROR_FAILURE);
    1:   // added this in so that ui code can ask to change an entire list, even if selection
    1:   // is only in part of it.  used by list item dialog.
    1:   if (aEntireList)
    1:   {       
    1:     nsCOMPtr<nsIEnumerator> enumerator;
    1:     res = selPriv->GetEnumerator(getter_AddRefs(enumerator));
43805:     NS_ENSURE_SUCCESS(res, res);
43806:     NS_ENSURE_TRUE(enumerator, NS_ERROR_UNEXPECTED);
    1: 
    1:     for (enumerator->First(); NS_OK!=enumerator->IsDone(); enumerator->Next())
    1:     {
    1:       nsCOMPtr<nsISupports> currentItem;
    1:       res = enumerator->CurrentItem(getter_AddRefs(currentItem));
43805:       NS_ENSURE_SUCCESS(res, res);
43806:       NS_ENSURE_TRUE(currentItem, NS_ERROR_UNEXPECTED);
    1: 
    1:       nsCOMPtr<nsIDOMRange> range( do_QueryInterface(currentItem) );
    1:       nsCOMPtr<nsIDOMNode> commonParent, parent, tmp;
    1:       range->GetCommonAncestorContainer(getter_AddRefs(commonParent));
    1:       if (commonParent)
    1:       {
    1:         parent = commonParent;
    1:         while (parent)
    1:         {
    1:           if (nsHTMLEditUtils::IsList(parent))
    1:           {
    1:             outArrayOfNodes.AppendObject(parent);
    1:             break;
    1:           }
    1:           parent->GetParentNode(getter_AddRefs(tmp));
    1:           parent = tmp;
    1:         }
    1:       }
    1:     }
    1:     // if we didn't find any nodes this way, then try the normal way.  perhaps the
    1:     // selection spans multiple lists but with no common list parent.
    1:     if (outArrayOfNodes.Count()) return NS_OK;
    1:   }
    1:   
    1:   // contruct a list of nodes to act on.
    1:   res = GetNodesFromSelection(selection, kMakeList, outArrayOfNodes, aDontTouchContent);
43805:   NS_ENSURE_SUCCESS(res, res);                                 
    1:                
    1:   // pre process our list of nodes...                      
    1:   PRInt32 listCount = outArrayOfNodes.Count();
    1:   PRInt32 i;
    1:   for (i=listCount-1; i>=0; i--)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> testNode = outArrayOfNodes[i];
    1: 
    1:     // Remove all non-editable nodes.  Leave them be.
    1:     if (!mHTMLEditor->IsEditable(testNode))
    1:     {
    1:       outArrayOfNodes.RemoveObjectAt(i);
    1:     }
    1:     
    1:     // scan for table elements and divs.  If we find table elements other than table,
    1:     // replace it with a list of any editable non-table content.
    1:     if (nsHTMLEditUtils::IsTableElementButNotTable(testNode))
    1:     {
    1:       PRInt32 j=i;
    1:       outArrayOfNodes.RemoveObjectAt(i);
    1:       res = GetInnerContent(testNode, outArrayOfNodes, &j, PR_FALSE);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:   }
    1: 
    1:   // if there is only one node in the array, and it is a list, div, or blockquote,
    1:   // then look inside of it until we find inner list or content.
    1:   res = LookInsideDivBQandList(outArrayOfNodes);
    1:   return res;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // LookInsideDivBQandList: 
    1: //                       
    1: nsresult 
    1: nsHTMLEditRules::LookInsideDivBQandList(nsCOMArray<nsIDOMNode>& aNodeArray)
    1: {
    1:   // if there is only one node in the array, and it is a list, div, or blockquote,
    1:   // then look inside of it until we find inner list or content.
    1:   nsresult res = NS_OK;
    1:   PRInt32 listCount = aNodeArray.Count();
    1:   if (listCount == 1)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> curNode = aNodeArray[0];
    1:     
    1:     while (nsHTMLEditUtils::IsDiv(curNode)
    1:            || nsHTMLEditUtils::IsList(curNode)
    1:            || nsHTMLEditUtils::IsBlockquote(curNode))
    1:     {
    1:       // dive as long as there is only one child, and it is a list, div, blockquote
    1:       PRUint32 numChildren;
    1:       res = mHTMLEditor->CountEditableChildren(curNode, numChildren);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       
    1:       if (numChildren == 1)
    1:       {
    1:         // keep diving
    1:         nsCOMPtr <nsIDOMNode> tmpNode = nsEditor::GetChildAt(curNode, 0);
    1:         if (nsHTMLEditUtils::IsDiv(tmpNode)
    1:             || nsHTMLEditUtils::IsList(tmpNode)
    1:             || nsHTMLEditUtils::IsBlockquote(tmpNode))
    1:         {
    1:           // check editablility XXX floppy moose
    1:           curNode = tmpNode;
    1:         }
    1:         else break;
    1:       }
    1:       else break;
    1:     }
    1:     // we've found innermost list/blockquote/div: 
    1:     // replace the one node in the array with these nodes
    1:     aNodeArray.RemoveObjectAt(0);
    1:     if ((nsHTMLEditUtils::IsDiv(curNode) || nsHTMLEditUtils::IsBlockquote(curNode)))
    1:     {
    1:       PRInt32 j=0;
    1:       res = GetInnerContent(curNode, aNodeArray, &j, PR_FALSE, PR_FALSE);
    1:     }
    1:     else
    1:     {
    1:       aNodeArray.AppendObject(curNode);
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetDefinitionListItemTypes: 
    1: //                       
    1: nsresult 
    1: nsHTMLEditRules::GetDefinitionListItemTypes(nsIDOMNode *aNode, PRBool &aDT, PRBool &aDD)
    1: {
43806:   NS_ENSURE_TRUE(aNode, NS_ERROR_NULL_POINTER);
    1:   aDT = aDD = PR_FALSE;
    1:   nsresult res = NS_OK;
    1:   nsCOMPtr<nsIDOMNode> child, temp;
    1:   res = aNode->GetFirstChild(getter_AddRefs(child));
    1:   while (child && NS_SUCCEEDED(res))
    1:   {
    1:     if (nsEditor::NodeIsType(child, nsEditProperty::dt)) aDT = PR_TRUE;
    1:     else if (nsEditor::NodeIsType(child, nsEditProperty::dd)) aDD = PR_TRUE;
    1:     res = child->GetNextSibling(getter_AddRefs(temp));
    1:     child = temp;
    1:   }
    1:   return res;
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetParagraphFormatNodes: 
    1: //                       
    1: nsresult 
    1: nsHTMLEditRules::GetParagraphFormatNodes(nsCOMArray<nsIDOMNode>& outArrayOfNodes,
    1:                                          PRBool aDontTouchContent)
    1: {  
    1:   nsCOMPtr<nsISelection>selection;
    1:   nsresult res = mHTMLEditor->GetSelection(getter_AddRefs(selection));
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // contruct a list of nodes to act on.
    1:   res = GetNodesFromSelection(selection, kMakeBasicBlock, outArrayOfNodes, aDontTouchContent);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // pre process our list of nodes...                      
    1:   PRInt32 listCount = outArrayOfNodes.Count();
    1:   PRInt32 i;
    1:   for (i=listCount-1; i>=0; i--)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> testNode = outArrayOfNodes[i];
    1: 
    1:     // Remove all non-editable nodes.  Leave them be.
    1:     if (!mHTMLEditor->IsEditable(testNode))
    1:     {
    1:       outArrayOfNodes.RemoveObjectAt(i);
    1:     }
    1:     
    1:     // scan for table elements.  If we find table elements other than table,
    1:     // replace it with a list of any editable non-table content.  Ditto for list elements.
    1:     if (nsHTMLEditUtils::IsTableElement(testNode) ||
    1:         nsHTMLEditUtils::IsList(testNode) || 
    1:         nsHTMLEditUtils::IsListItem(testNode) )
    1:     {
    1:       PRInt32 j=i;
    1:       outArrayOfNodes.RemoveObjectAt(i);
    1:       res = GetInnerContent(testNode, outArrayOfNodes, &j);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // BustUpInlinesAtRangeEndpoints: 
    1: //                       
    1: nsresult 
    1: nsHTMLEditRules::BustUpInlinesAtRangeEndpoints(nsRangeStore &item)
    1: {
    1:   nsresult res = NS_OK;
    1:   PRBool isCollapsed = ((item.startNode == item.endNode) && (item.startOffset == item.endOffset));
    1: 
    1:   nsCOMPtr<nsIDOMNode> endInline = GetHighestInlineParent(item.endNode);
    1:   
    1:   // if we have inline parents above range endpoints, split them
    1:   if (endInline && !isCollapsed)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> resultEndNode;
    1:     PRInt32 resultEndOffset;
    1:     endInline->GetParentNode(getter_AddRefs(resultEndNode));
    1:     res = mHTMLEditor->SplitNodeDeep(endInline, item.endNode, item.endOffset,
    1:                           &resultEndOffset, PR_TRUE);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     // reset range
    1:     item.endNode = resultEndNode; item.endOffset = resultEndOffset;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMNode> startInline = GetHighestInlineParent(item.startNode);
    1: 
    1:   if (startInline)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> resultStartNode;
    1:     PRInt32 resultStartOffset;
    1:     startInline->GetParentNode(getter_AddRefs(resultStartNode));
    1:     res = mHTMLEditor->SplitNodeDeep(startInline, item.startNode, item.startOffset,
    1:                           &resultStartOffset, PR_TRUE);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     // reset range
    1:     item.startNode = resultStartNode; item.startOffset = resultStartOffset;
    1:   }
    1:   
    1:   return res;
    1: }
    1: 
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // BustUpInlinesAtBRs: 
    1: //                       
    1: nsresult 
    1: nsHTMLEditRules::BustUpInlinesAtBRs(nsIDOMNode *inNode, 
    1:                                     nsCOMArray<nsIDOMNode>& outArrayOfNodes)
    1: {
43806:   NS_ENSURE_TRUE(inNode, NS_ERROR_NULL_POINTER);
    1: 
    1:   // first step is to build up a list of all the break nodes inside 
    1:   // the inline container.
    1:   nsCOMArray<nsIDOMNode> arrayOfBreaks;
    1:   nsBRNodeFunctor functor;
    1:   nsDOMIterator iter;
    1:   nsresult res = iter.Init(inNode);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = iter.AppendList(functor, arrayOfBreaks);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   // if there aren't any breaks, just put inNode itself in the array
    1:   PRInt32 listCount = arrayOfBreaks.Count();
    1:   if (!listCount)
    1:   {
    1:     if (!outArrayOfNodes.AppendObject(inNode))
    1:       return NS_ERROR_FAILURE;
    1:   }
    1:   else
    1:   {
    1:     // else we need to bust up inNode along all the breaks
    1:     nsCOMPtr<nsIDOMNode> breakNode;
    1:     nsCOMPtr<nsIDOMNode> inlineParentNode;
    1:     nsCOMPtr<nsIDOMNode> leftNode;
    1:     nsCOMPtr<nsIDOMNode> rightNode;
    1:     nsCOMPtr<nsIDOMNode> splitDeepNode = inNode;
    1:     nsCOMPtr<nsIDOMNode> splitParentNode;
    1:     PRInt32 splitOffset, resultOffset, i;
    1:     inNode->GetParentNode(getter_AddRefs(inlineParentNode));
    1:     
    1:     for (i=0; i< listCount; i++)
    1:     {
    1:       breakNode = arrayOfBreaks[i];
43806:       NS_ENSURE_TRUE(breakNode, NS_ERROR_NULL_POINTER);
43806:       NS_ENSURE_TRUE(splitDeepNode, NS_ERROR_NULL_POINTER);
    1:       res = nsEditor::GetNodeLocation(breakNode, address_of(splitParentNode), &splitOffset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = mHTMLEditor->SplitNodeDeep(splitDeepNode, splitParentNode, splitOffset,
    1:                           &resultOffset, PR_FALSE, address_of(leftNode), address_of(rightNode));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       // put left node in node list
    1:       if (leftNode)
    1:       {
    1:         // might not be a left node.  a break might have been at the very
    1:         // beginning of inline container, in which case splitnodedeep
    1:         // would not actually split anything
    1:         if (!outArrayOfNodes.AppendObject(leftNode))
    1:           return NS_ERROR_FAILURE;
    1:       }
    1:       // move break outside of container and also put in node list
    1:       res = mHTMLEditor->MoveNode(breakNode, inlineParentNode, resultOffset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       if (!outArrayOfNodes.AppendObject(breakNode))
    1:         return  NS_ERROR_FAILURE;
    1:       // now rightNode becomes the new node to split
    1:       splitDeepNode = rightNode;
    1:     }
    1:     // now tack on remaining rightNode, if any, to the list
    1:     if (rightNode)
    1:     {
    1:       if (!outArrayOfNodes.AppendObject(rightNode))
    1:         return NS_ERROR_FAILURE;
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: nsCOMPtr<nsIDOMNode> 
    1: nsHTMLEditRules::GetHighestInlineParent(nsIDOMNode* aNode)
    1: {
43806:   NS_ENSURE_TRUE(aNode, nsnull);
    1:   if (IsBlockNode(aNode)) return nsnull;
    1:   nsCOMPtr<nsIDOMNode> inlineNode, node=aNode;
    1: 
    1:   while (node && IsInlineNode(node))
    1:   {
    1:     inlineNode = node;
    1:     inlineNode->GetParentNode(getter_AddRefs(node));
    1:   }
    1:   return inlineNode;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetNodesFromPoint: given a particular operation, construct a list  
    1: //                     of nodes from a point that will be operated on. 
    1: //                       
    1: nsresult 
    1: nsHTMLEditRules::GetNodesFromPoint(DOMPoint point,
    1:                                    PRInt32 operation,
    1:                                    nsCOMArray<nsIDOMNode> &arrayOfNodes,
    1:                                    PRBool dontTouchContent)
    1: {
    1:   nsresult res;
    1: 
    1:   // get our point
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   PRInt32 offset;
    1:   point.GetPoint(node, offset);
    1:   
    1:   // use it to make a range
    1:   nsCOMPtr<nsIDOMRange> range = do_CreateInstance("@mozilla.org/content/range;1");
    1:   res = range->SetStart(node, offset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   /* SetStart() will also set the end for this new range
    1:   res = range->SetEnd(node, offset);
43805:   NS_ENSURE_SUCCESS(res, res); */
    1:   
    1:   // expand the range to include adjacent inlines
    1:   res = PromoteRange(range, operation);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:       
    1:   // make array of ranges
    1:   nsCOMArray<nsIDOMRange> arrayOfRanges;
    1:   
    1:   // stuff new opRange into array
    1:   arrayOfRanges.AppendObject(range);
    1:   
    1:   // use these ranges to contruct a list of nodes to act on.
    1:   res = GetNodesForOperation(arrayOfRanges, arrayOfNodes, operation, dontTouchContent); 
    1:   return res;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetNodesFromSelection: given a particular operation, construct a list  
    1: //                     of nodes from the selection that will be operated on. 
    1: //                       
    1: nsresult 
    1: nsHTMLEditRules::GetNodesFromSelection(nsISelection *selection,
    1:                                        PRInt32 operation,
    1:                                        nsCOMArray<nsIDOMNode>& arrayOfNodes,
    1:                                        PRBool dontTouchContent)
    1: {
43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
    1:   nsresult res;
    1:   
    1:   // promote selection ranges
    1:   nsCOMArray<nsIDOMRange> arrayOfRanges;
    1:   res = GetPromotedRanges(selection, arrayOfRanges, operation);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   // use these ranges to contruct a list of nodes to act on.
    1:   res = GetNodesForOperation(arrayOfRanges, arrayOfNodes, operation, dontTouchContent); 
    1:   return res;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // MakeTransitionList: detect all the transitions in the array, where a 
    1: //                     transition means that adjacent nodes in the array 
    1: //                     don't have the same parent.
    1: //                       
    1: nsresult 
    1: nsHTMLEditRules::MakeTransitionList(nsCOMArray<nsIDOMNode>& inArrayOfNodes, 
27986:                                     nsTArray<PRPackedBool> &inTransitionArray)
27986: {
27986:   PRUint32 listCount = inArrayOfNodes.Count();
27986:   inTransitionArray.EnsureLengthAtLeast(listCount);
27986:   PRUint32 i;
    1:   nsCOMPtr<nsIDOMNode> prevElementParent;
    1:   nsCOMPtr<nsIDOMNode> curElementParent;
    1:   
    1:   for (i=0; i<listCount; i++)
    1:   {
    1:     nsIDOMNode* transNode = inArrayOfNodes[i];
    1:     transNode->GetParentNode(getter_AddRefs(curElementParent));
    1:     if (curElementParent != prevElementParent)
    1:     {
    1:       // different parents, or separated by <br>: transition point
27986:       inTransitionArray[i] = PR_TRUE;
    1:     }
    1:     else
    1:     {
    1:       // same parents: these nodes grew up together
27986:       inTransitionArray[i] = PR_FALSE;
    1:     }
    1:     prevElementParent = curElementParent;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: 
    1: /********************************************************
    1:  *  main implementation methods 
    1:  ********************************************************/
    1:  
    1: ///////////////////////////////////////////////////////////////////////////
    1: // IsInListItem: if aNode is the descendant of a listitem, return that li.
    1: //               But table element boundaries are stoppers on the search.
    1: //               Also test if aNode is an li itself.
    1: //                       
    1: nsCOMPtr<nsIDOMNode> 
    1: nsHTMLEditRules::IsInListItem(nsIDOMNode *aNode)
    1: {
43806:   NS_ENSURE_TRUE(aNode, nsnull);  
    1:   if (nsHTMLEditUtils::IsListItem(aNode)) return aNode;
    1:   
    1:   nsCOMPtr<nsIDOMNode> parent, tmp;
    1:   aNode->GetParentNode(getter_AddRefs(parent));
    1:   
    1:   while (parent)
    1:   {
    1:     if (nsHTMLEditUtils::IsTableElement(parent)) return nsnull;
    1:     if (nsHTMLEditUtils::IsListItem(parent)) return parent;
    1:     tmp=parent; tmp->GetParentNode(getter_AddRefs(parent));
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // ReturnInHeader: do the right thing for returns pressed in headers
    1: //                       
    1: nsresult 
    1: nsHTMLEditRules::ReturnInHeader(nsISelection *aSelection, 
    1:                                 nsIDOMNode *aHeader, 
    1:                                 nsIDOMNode *aNode, 
    1:                                 PRInt32 aOffset)
    1: {
43806:   NS_ENSURE_TRUE(aSelection && aHeader && aNode, NS_ERROR_NULL_POINTER);  
    1:   
    1:   // remeber where the header is
    1:   nsCOMPtr<nsIDOMNode> headerParent;
    1:   PRInt32 offset;
    1:   nsresult res = nsEditor::GetNodeLocation(aHeader, address_of(headerParent), &offset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // get ws code to adjust any ws
    1:   nsCOMPtr<nsIDOMNode> selNode = aNode;
    1:   res = nsWSRunObject::PrepareToSplitAcrossBlocks(mHTMLEditor, address_of(selNode), &aOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // split the header
    1:   PRInt32 newOffset;
    1:   res = mHTMLEditor->SplitNodeDeep( aHeader, selNode, aOffset, &newOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // if the leftand heading is empty, put a mozbr in it
    1:   nsCOMPtr<nsIDOMNode> prevItem;
    1:   mHTMLEditor->GetPriorHTMLSibling(aHeader, address_of(prevItem));
    1:   if (prevItem && nsHTMLEditUtils::IsHeader(prevItem))
    1:   {
    1:     PRBool bIsEmptyNode;
    1:     res = mHTMLEditor->IsEmptyNode(prevItem, &bIsEmptyNode);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (bIsEmptyNode)
    1:     {
    1:       nsCOMPtr<nsIDOMNode> brNode;
    1:       res = CreateMozBR(prevItem, 0, address_of(brNode));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:   }
    1:   
    1:   // if the new (righthand) header node is empty, delete it
    1:   PRBool isEmpty;
    1:   res = IsEmptyBlock(aHeader, &isEmpty, PR_TRUE);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (isEmpty)
    1:   {
    1:     res = mHTMLEditor->DeleteNode(aHeader);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     // layout tells the caret to blink in a weird place
    1:     // if we don't place a break after the header.
    1:     nsCOMPtr<nsIDOMNode> sibling;
    1:     res = mHTMLEditor->GetNextHTMLSibling(headerParent, offset+1, address_of(sibling));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (!sibling || !nsTextEditUtils::IsBreak(sibling))
    1:     {
    1:       res = CreateMozBR(headerParent, offset+1, address_of(sibling));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     res = nsEditor::GetNodeLocation(sibling, address_of(headerParent), &offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     // put selection after break
    1:     res = aSelection->Collapse(headerParent,offset+1);
    1:   }
    1:   else
    1:   {
    1:     // put selection at front of righthand heading
    1:     res = aSelection->Collapse(aHeader,0);
    1:   }
    1:   return res;
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // ReturnInParagraph: do the right thing for returns pressed in paragraphs
    1: //                       
    1: nsresult 
    1: nsHTMLEditRules::ReturnInParagraph(nsISelection *aSelection, 
    1:                                    nsIDOMNode *aPara, 
    1:                                    nsIDOMNode *aNode, 
    1:                                    PRInt32 aOffset,
    1:                                    PRBool *aCancel,
    1:                                    PRBool *aHandled)
    1: {
    1:   if (!aSelection || !aPara || !aNode || !aCancel || !aHandled) 
    1:     { return NS_ERROR_NULL_POINTER; }
    1:   *aCancel = PR_FALSE;
    1:   *aHandled = PR_FALSE;
    1: 
    1:   nsCOMPtr<nsIDOMNode> parent;
    1:   PRInt32 offset;
    1:   nsresult res = nsEditor::GetNodeLocation(aNode, address_of(parent), &offset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   PRBool  doesCRCreateNewP;
    1:   res = mHTMLEditor->GetReturnInParagraphCreatesNewParagraph(&doesCRCreateNewP);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   PRBool newBRneeded = PR_FALSE;
    1:   nsCOMPtr<nsIDOMNode> sibling;
    1: 
10746:   if (aNode == aPara && doesCRCreateNewP) {
10746:     // we are at the edges of the block, newBRneeded not needed!
10746:     sibling = aNode;
10746:   }
10746:   else if (mHTMLEditor->IsTextNode(aNode))
    1:   {
    1:     nsCOMPtr<nsIDOMText> textNode = do_QueryInterface(aNode);
    1:     PRUint32 strLength;
    1:     res = textNode->GetLength(&strLength);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     
    1:     // at beginning of text node?
    1:     if (!aOffset)
    1:     {
    1:       // is there a BR prior to it?
    1:       mHTMLEditor->GetPriorHTMLSibling(aNode, address_of(sibling));
    1:       if (!sibling ||
    1:           !mHTMLEditor->IsVisBreak(sibling) || nsTextEditUtils::HasMozAttr(sibling))
    1:       {
    1:         newBRneeded = PR_TRUE;
    1:       }
    1:     }
    1:     else if (aOffset == (PRInt32)strLength)
    1:     {
    1:       // we're at the end of text node...
    1:       // is there a BR after to it?
    1:       res = mHTMLEditor->GetNextHTMLSibling(aNode, address_of(sibling));
    1:       if (!sibling ||
    1:           !mHTMLEditor->IsVisBreak(sibling) || nsTextEditUtils::HasMozAttr(sibling)) 
    1:       {
    1:         newBRneeded = PR_TRUE;
    1:         offset++;
    1:       }
    1:     }
    1:     else
    1:     {
    1:       if (doesCRCreateNewP)
    1:       {
    1:         nsCOMPtr<nsIDOMNode> tmp;
    1:         res = mEditor->SplitNode(aNode, aOffset, getter_AddRefs(tmp));
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         aNode = tmp;
    1:       }
    1: 
    1:       newBRneeded = PR_TRUE;
    1:       offset++;
    1:     }
    1:   }
    1:   else
    1:   {
    1:     // not in a text node.  
    1:     // is there a BR prior to it?
    1:     nsCOMPtr<nsIDOMNode> nearNode, selNode = aNode;
    1:     res = mHTMLEditor->GetPriorHTMLNode(aNode, aOffset, address_of(nearNode));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (!nearNode || !mHTMLEditor->IsVisBreak(nearNode) || nsTextEditUtils::HasMozAttr(nearNode)) 
    1:     {
    1:       // is there a BR after it?
    1:       res = mHTMLEditor->GetNextHTMLNode(aNode, aOffset, address_of(nearNode));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       if (!nearNode || !mHTMLEditor->IsVisBreak(nearNode) || nsTextEditUtils::HasMozAttr(nearNode)) 
    1:       {
    1:         newBRneeded = PR_TRUE;
    1:       }
    1:     }
    1:     if (!newBRneeded)
    1:       sibling = nearNode;
    1:   }
    1:   if (newBRneeded)
    1:   {
    1:     // if CR does not create a new P, default to BR creation
43807:     NS_ENSURE_TRUE(doesCRCreateNewP, NS_OK);
    1: 
    1:     nsCOMPtr<nsIDOMNode> brNode;
    1:     res =  mHTMLEditor->CreateBR(parent, offset, address_of(brNode));
    1:     sibling = brNode;
    1:   }
    1:   nsCOMPtr<nsIDOMNode> selNode = aNode;
    1:   *aHandled = PR_TRUE;
    1:   return SplitParagraph(aPara, sibling, aSelection, address_of(selNode), &aOffset);
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // SplitParagraph: split a paragraph at selection point, possibly deleting a br
    1: //                       
    1: nsresult 
    1: nsHTMLEditRules::SplitParagraph(nsIDOMNode *aPara,
    1:                                 nsIDOMNode *aBRNode, 
    1:                                 nsISelection *aSelection,
    1:                                 nsCOMPtr<nsIDOMNode> *aSelNode, 
    1:                                 PRInt32 *aOffset)
    1: {
43807:   NS_ENSURE_TRUE(aPara && aBRNode && aSelNode && *aSelNode && aOffset && aSelection, NS_ERROR_NULL_POINTER);
    1:   nsresult res = NS_OK;
    1:   
    1:   // split para
    1:   PRInt32 newOffset;
    1:   // get ws code to adjust any ws
    1:   nsCOMPtr<nsIDOMNode> leftPara, rightPara;
    1:   res = nsWSRunObject::PrepareToSplitAcrossBlocks(mHTMLEditor, aSelNode, aOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   // split the paragraph
    1:   res = mHTMLEditor->SplitNodeDeep(aPara, *aSelNode, *aOffset, &newOffset, PR_FALSE,
    1:                                    address_of(leftPara), address_of(rightPara));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   // get rid of the break, if it is visible (otherwise it may be needed to prevent an empty p)
    1:   if (mHTMLEditor->IsVisBreak(aBRNode))
    1:   {
    1:     res = mHTMLEditor->DeleteNode(aBRNode);  
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1: 
56873:   // remove ID attribute on the paragraph we just created
56873:   nsCOMPtr<nsIDOMElement> rightElt = do_QueryInterface(rightPara);
56873:   res = mHTMLEditor->RemoveAttribute(rightElt, NS_LITERAL_STRING("id"));
56873:   NS_ENSURE_SUCCESS(res, res);
56873: 
    1:   // check both halves of para to see if we need mozBR
    1:   res = InsertMozBRIfNeeded(leftPara);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = InsertMozBRIfNeeded(rightPara);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // selection to beginning of right hand para;
    1:   // look inside any containers that are up front.
    1:   nsCOMPtr<nsIDOMNode> child = mHTMLEditor->GetLeftmostChild(rightPara, PR_TRUE);
    1:   if (mHTMLEditor->IsTextNode(child) || mHTMLEditor->IsContainer(child))
    1:   {
    1:     aSelection->Collapse(child,0);
    1:   }
    1:   else
    1:   {
    1:     nsCOMPtr<nsIDOMNode> parent;
    1:     PRInt32 offset;
    1:     res = nsEditor::GetNodeLocation(child, address_of(parent), &offset);
    1:     aSelection->Collapse(parent,offset);
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // ReturnInListItem: do the right thing for returns pressed in list items
    1: //                       
    1: nsresult 
    1: nsHTMLEditRules::ReturnInListItem(nsISelection *aSelection, 
    1:                                   nsIDOMNode *aListItem, 
    1:                                   nsIDOMNode *aNode, 
    1:                                   PRInt32 aOffset)
    1: {
43806:   NS_ENSURE_TRUE(aSelection && aListItem && aNode, NS_ERROR_NULL_POINTER);
    1:   nsCOMPtr<nsISelection> selection(aSelection);
    1:   nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(selection));
    1:   nsresult res = NS_OK;
    1:   
    1:   nsCOMPtr<nsIDOMNode> listitem;
    1:   
    1:   // sanity check
    1:   NS_PRECONDITION(PR_TRUE == nsHTMLEditUtils::IsListItem(aListItem),
    1:                   "expected a list item and didn't get one");
    1:   
    1:   // if we are in an empty listitem, then we want to pop up out of the list
    1:   PRBool isEmpty;
    1:   res = IsEmptyBlock(aListItem, &isEmpty, PR_TRUE, PR_FALSE);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (isEmpty && mReturnInEmptyLIKillsList)   // but only if prefs says it's ok
    1:   {
    1:     nsCOMPtr<nsIDOMNode> list, listparent;
    1:     PRInt32 offset, itemOffset;
    1:     res = nsEditor::GetNodeLocation(aListItem, address_of(list), &itemOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     res = nsEditor::GetNodeLocation(list, address_of(listparent), &offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     
    1:     // are we the last list item in the list?
    1:     PRBool bIsLast;
    1:     res = mHTMLEditor->IsLastEditableChild(aListItem, &bIsLast);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (!bIsLast)
    1:     {
    1:       // we need to split the list!
    1:       nsCOMPtr<nsIDOMNode> tempNode;
    1:       res = mHTMLEditor->SplitNode(list, itemOffset, getter_AddRefs(tempNode));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     // are we in a sublist?
    1:     if (nsHTMLEditUtils::IsList(listparent))  //in a sublist
    1:     {
    1:       // if so, move this list item out of this list and into the grandparent list
    1:       res = mHTMLEditor->MoveNode(aListItem,listparent,offset+1);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = aSelection->Collapse(aListItem,0);
    1:     }
    1:     else
    1:     {
    1:       // otherwise kill this listitem
    1:       res = mHTMLEditor->DeleteNode(aListItem);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       
    1:       // time to insert a break
    1:       nsCOMPtr<nsIDOMNode> brNode;
    1:       res = CreateMozBR(listparent, offset+1, address_of(brNode));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       
    1:       // set selection to before the moz br
    1:       selPriv->SetInterlinePosition(PR_TRUE);
    1:       res = aSelection->Collapse(listparent,offset+1);
    1:     }
    1:     return res;
    1:   }
    1:   
    1:   // else we want a new list item at the same list level.
    1:   // get ws code to adjust any ws
    1:   nsCOMPtr<nsIDOMNode> selNode = aNode;
    1:   res = nsWSRunObject::PrepareToSplitAcrossBlocks(mHTMLEditor, address_of(selNode), &aOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   // now split list item
    1:   PRInt32 newOffset;
    1:   res = mHTMLEditor->SplitNodeDeep( aListItem, selNode, aOffset, &newOffset, PR_FALSE);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   // hack: until I can change the damaged doc range code back to being
    1:   // extra inclusive, I have to manually detect certain list items that
    1:   // may be left empty.
    1:   nsCOMPtr<nsIDOMNode> prevItem;
    1:   mHTMLEditor->GetPriorHTMLSibling(aListItem, address_of(prevItem));
    1: 
    1:   if (prevItem && nsHTMLEditUtils::IsListItem(prevItem))
    1:   {
    1:     PRBool bIsEmptyNode;
    1:     res = mHTMLEditor->IsEmptyNode(prevItem, &bIsEmptyNode);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (bIsEmptyNode)
    1:     {
    1:       nsCOMPtr<nsIDOMNode> brNode;
    1:       res = CreateMozBR(prevItem, 0, address_of(brNode));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     else 
    1:     {
    1:       res = mHTMLEditor->IsEmptyNode(aListItem, &bIsEmptyNode, PR_TRUE);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       if (bIsEmptyNode) 
    1:       {
    1:         nsCOMPtr<nsIAtom> nodeAtom = nsEditor::GetTag(aListItem);
    1:         if (nodeAtom == nsEditProperty::dd || nodeAtom == nsEditProperty::dt)
    1:         {
    1:           nsCOMPtr<nsIDOMNode> list;
    1:           PRInt32 itemOffset;
    1:           res = nsEditor::GetNodeLocation(aListItem, address_of(list), &itemOffset);
43805:           NS_ENSURE_SUCCESS(res, res);
    1: 
    1:           nsAutoString listTag((nodeAtom == nsEditProperty::dt) ? NS_LITERAL_STRING("dd") : NS_LITERAL_STRING("dt"));
    1:           nsCOMPtr<nsIDOMNode> newListItem;
    1:           res = mHTMLEditor->CreateNode(listTag, list, itemOffset+1, getter_AddRefs(newListItem));
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           res = mEditor->DeleteNode(aListItem);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           return aSelection->Collapse(newListItem, 0);
    1:         }
    1: 
    1:         nsCOMPtr<nsIDOMNode> brNode;
    1:         res = mHTMLEditor->CopyLastEditableChildStyles(prevItem, aListItem, getter_AddRefs(brNode));
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         if (brNode) 
    1:         {
    1:           nsCOMPtr<nsIDOMNode> brParent;
    1:           PRInt32 offset;
    1:           res = nsEditor::GetNodeLocation(brNode, address_of(brParent), &offset);
    1:           return aSelection->Collapse(brParent, offset);
    1:         }
    1:       }
    1:       else
    1:       {
    1:         nsWSRunObject wsObj(mHTMLEditor, aListItem, 0);
    1:         nsCOMPtr<nsIDOMNode> visNode;
    1:         PRInt32 visOffset = 0;
    1:         PRInt16 wsType;
    1:         res = wsObj.NextVisibleNode(aListItem, 0, address_of(visNode), &visOffset, &wsType);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         if ( (wsType==nsWSRunObject::eSpecial)  || 
    1:              (wsType==nsWSRunObject::eBreak)    ||
    1:              nsHTMLEditUtils::IsHR(visNode) ) 
    1:         {
    1:           nsCOMPtr<nsIDOMNode> parent;
    1:           PRInt32 offset;
    1:           res = nsEditor::GetNodeLocation(visNode, address_of(parent), &offset);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           return aSelection->Collapse(parent, offset);
    1:         }
    1:         else
    1:         {
    1:           return aSelection->Collapse(visNode, visOffset);
    1:         }
    1:       }
    1:     }
    1:   }
    1:   res = aSelection->Collapse(aListItem,0);
    1:   return res;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // MakeBlockquote:  put the list of nodes into one or more blockquotes.  
    1: //                       
    1: nsresult 
    1: nsHTMLEditRules::MakeBlockquote(nsCOMArray<nsIDOMNode>& arrayOfNodes)
    1: {
    1:   // the idea here is to put the nodes into a minimal number of 
    1:   // blockquotes.  When the user blockquotes something, they expect
    1:   // one blockquote.  That may not be possible (for instance, if they
    1:   // have two table cells selected, you need two blockquotes inside the cells).
    1:   
    1:   nsresult res = NS_OK;
    1:   
    1:   nsCOMPtr<nsIDOMNode> curNode, curParent, curBlock, newBlock;
    1:   PRInt32 offset;
    1:   PRInt32 listCount = arrayOfNodes.Count();
    1:   
    1:   nsCOMPtr<nsIDOMNode> prevParent;
    1:   
    1:   PRInt32 i;
    1:   for (i=0; i<listCount; i++)
    1:   {
    1:     // get the node to act on, and it's location
    1:     curNode = arrayOfNodes[i];
    1:     res = nsEditor::GetNodeLocation(curNode, address_of(curParent), &offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1: 
    1:     // if the node is a table element or list item, dive inside
    1:     if (nsHTMLEditUtils::IsTableElementButNotTable(curNode) || 
    1:         nsHTMLEditUtils::IsListItem(curNode))
    1:     {
    1:       curBlock = 0;  // forget any previous block
    1:       // recursion time
    1:       nsCOMArray<nsIDOMNode> childArray;
    1:       res = GetChildNodesForOperation(curNode, childArray);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = MakeBlockquote(childArray);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     
    1:     // if the node has different parent than previous node,
    1:     // further nodes in a new parent
    1:     if (prevParent)
    1:     {
    1:       nsCOMPtr<nsIDOMNode> temp;
    1:       curNode->GetParentNode(getter_AddRefs(temp));
    1:       if (temp != prevParent)
    1:       {
    1:         curBlock = 0;  // forget any previous blockquote node we were using
    1:         prevParent = temp;
    1:       }
    1:     }
    1:     else     
    1: 
    1:     {
    1:       curNode->GetParentNode(getter_AddRefs(prevParent));
    1:     }
    1:     
    1:     // if no curBlock, make one
    1:     if (!curBlock)
    1:     {
    1:       NS_NAMED_LITERAL_STRING(quoteType, "blockquote");
    1:       res = SplitAsNeeded(&quoteType, address_of(curParent), &offset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = mHTMLEditor->CreateNode(quoteType, curParent, offset, getter_AddRefs(curBlock));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       // remember our new block for postprocessing
    1:       mNewBlock = curBlock;
    1:       // note: doesn't matter if we set mNewBlock multiple times.
    1:     }
    1:       
    1:     res = mHTMLEditor->MoveNode(curNode, curBlock, -1);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // RemoveBlockStyle:  make the nodes have no special block type.  
    1: //                       
    1: nsresult 
    1: nsHTMLEditRules::RemoveBlockStyle(nsCOMArray<nsIDOMNode>& arrayOfNodes)
    1: {
    1:   // intent of this routine is to be used for converting to/from
    1:   // headers, paragraphs, pre, and address.  Those blocks
    1:   // that pretty much just contain inline things...
    1:   
    1:   nsresult res = NS_OK;
    1:   
    1:   nsCOMPtr<nsIDOMNode> curNode, curParent, curBlock, firstNode, lastNode;
    1:   PRInt32 offset;
    1:   PRInt32 listCount = arrayOfNodes.Count();
    1:     
    1:   PRInt32 i;
    1:   for (i=0; i<listCount; i++)
    1:   {
    1:     // get the node to act on, and it's location
    1:     curNode = arrayOfNodes[i];
    1:     res = nsEditor::GetNodeLocation(curNode, address_of(curParent), &offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     nsAutoString curNodeTag, curBlockTag;
    1:     nsEditor::GetTagString(curNode, curNodeTag);
    1:     ToLowerCase(curNodeTag);
    1:  
    1:     // if curNode is a address, p, header, address, or pre, remove it 
    1:     if (nsHTMLEditUtils::IsFormatNode(curNode))
    1:     {
    1:       // process any partial progress saved
    1:       if (curBlock)
    1:       {
    1:         res = RemovePartOfBlock(curBlock, firstNode, lastNode);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         curBlock = 0;  firstNode = 0;  lastNode = 0;
    1:       }
    1:       // remove curent block
    1:       res = mHTMLEditor->RemoveBlockContainer(curNode); 
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     else if (nsHTMLEditUtils::IsTable(curNode)                    || 
    1:              nsHTMLEditUtils::IsTableRow(curNode)                 ||
    1:              (curNodeTag.EqualsLiteral("tbody"))      ||
    1:              (curNodeTag.EqualsLiteral("td"))         ||
    1:              nsHTMLEditUtils::IsList(curNode)                     ||
    1:              (curNodeTag.EqualsLiteral("li"))         ||
    1:              nsHTMLEditUtils::IsBlockquote(curNode)               ||
    1:              nsHTMLEditUtils::IsDiv(curNode))
    1:     {
    1:       // process any partial progress saved
    1:       if (curBlock)
    1:       {
    1:         res = RemovePartOfBlock(curBlock, firstNode, lastNode);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         curBlock = 0;  firstNode = 0;  lastNode = 0;
    1:       }
    1:       // recursion time
    1:       nsCOMArray<nsIDOMNode> childArray;
    1:       res = GetChildNodesForOperation(curNode, childArray);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = RemoveBlockStyle(childArray);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     else if (IsInlineNode(curNode))
    1:     {
    1:       if (curBlock)
    1:       {
    1:         // if so, is this node a descendant?
    1:         if (nsEditorUtils::IsDescendantOf(curNode, curBlock))
    1:         {
    1:           lastNode = curNode;
    1:           continue;  // then we don't need to do anything different for this node
    1:         }
    1:         else
    1:         {
    1:           // otherwise, we have progressed beyond end of curBlock,
    1:           // so lets handle it now.  We need to remove the portion of 
    1:           // curBlock that contains [firstNode - lastNode].
    1:           res = RemovePartOfBlock(curBlock, firstNode, lastNode);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           curBlock = 0;  firstNode = 0;  lastNode = 0;
    1:           // fall out and handle curNode
    1:         }
    1:       }
    1:       curBlock = mHTMLEditor->GetBlockNodeParent(curNode);
    1:       if (nsHTMLEditUtils::IsFormatNode(curBlock))
    1:       {
    1:         firstNode = curNode;  
    1:         lastNode = curNode;
    1:       }
    1:       else
    1:         curBlock = 0;  // not a block kind that we care about.
    1:     }
    1:     else
    1:     { // some node that is already sans block style.  skip over it and
    1:       // process any partial progress saved
    1:       if (curBlock)
    1:       {
    1:         res = RemovePartOfBlock(curBlock, firstNode, lastNode);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         curBlock = 0;  firstNode = 0;  lastNode = 0;
    1:       }
    1:     }
    1:   }
    1:   // process any partial progress saved
    1:   if (curBlock)
    1:   {
    1:     res = RemovePartOfBlock(curBlock, firstNode, lastNode);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     curBlock = 0;  firstNode = 0;  lastNode = 0;
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // ApplyBlockStyle:  do whatever it takes to make the list of nodes into 
    1: //                   one or more blocks of type blockTag.  
    1: //                       
    1: nsresult 
    1: nsHTMLEditRules::ApplyBlockStyle(nsCOMArray<nsIDOMNode>& arrayOfNodes, const nsAString *aBlockTag)
    1: {
    1:   // intent of this routine is to be used for converting to/from
    1:   // headers, paragraphs, pre, and address.  Those blocks
    1:   // that pretty much just contain inline things...
    1:   
43806:   NS_ENSURE_TRUE(aBlockTag, NS_ERROR_NULL_POINTER);
    1:   nsresult res = NS_OK;
    1:   
    1:   nsCOMPtr<nsIDOMNode> curNode, curParent, curBlock, newBlock;
    1:   PRInt32 offset;
    1:   PRInt32 listCount = arrayOfNodes.Count();
    1:   nsString tString(*aBlockTag);////MJUDGE SCC NEED HELP
    1: 
    1:   // Remove all non-editable nodes.  Leave them be.
    1:   PRInt32 j;
    1:   for (j=listCount-1; j>=0; j--)
    1:   {
    1:     if (!mHTMLEditor->IsEditable(arrayOfNodes[j]))
    1:     {
    1:       arrayOfNodes.RemoveObjectAt(j);
    1:     }
    1:   }
    1:   
    1:   // reset list count
    1:   listCount = arrayOfNodes.Count();
    1:   
    1:   PRInt32 i;
    1:   for (i=0; i<listCount; i++)
    1:   {
    1:     // get the node to act on, and it's location
    1:     curNode = arrayOfNodes[i];
    1:     res = nsEditor::GetNodeLocation(curNode, address_of(curParent), &offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     nsAutoString curNodeTag;
    1:     nsEditor::GetTagString(curNode, curNodeTag);
    1:     ToLowerCase(curNodeTag);
    1:  
    1:     // is it already the right kind of block?
    1:     if (curNodeTag == *aBlockTag)
    1:     {
    1:       curBlock = 0;  // forget any previous block used for previous inline nodes
    1:       continue;  // do nothing to this block
    1:     }
    1:         
    1:     // if curNode is a address, p, header, address, or pre, replace 
    1:     // it with a new block of correct type.
    1:     // xxx floppy moose: pre can't hold everything the others can
    1:     if (nsHTMLEditUtils::IsMozDiv(curNode)     ||
    1:         nsHTMLEditUtils::IsFormatNode(curNode))
    1:     {
    1:       curBlock = 0;  // forget any previous block used for previous inline nodes
    1:       res = mHTMLEditor->ReplaceContainer(curNode, address_of(newBlock), *aBlockTag,
    1:                                           nsnull, nsnull, PR_TRUE);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     else if (nsHTMLEditUtils::IsTable(curNode)                    || 
    1:              (curNodeTag.EqualsLiteral("tbody"))      ||
    1:              (curNodeTag.EqualsLiteral("tr"))         ||
    1:              (curNodeTag.EqualsLiteral("td"))         ||
    1:              nsHTMLEditUtils::IsList(curNode)                     ||
    1:              (curNodeTag.EqualsLiteral("li"))         ||
    1:              nsHTMLEditUtils::IsBlockquote(curNode)               ||
    1:              nsHTMLEditUtils::IsDiv(curNode))
    1:     {
    1:       curBlock = 0;  // forget any previous block used for previous inline nodes
    1:       // recursion time
    1:       nsCOMArray<nsIDOMNode> childArray;
    1:       res = GetChildNodesForOperation(curNode, childArray);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       PRInt32 childCount = childArray.Count();
    1:       if (childCount)
    1:       {
    1:         res = ApplyBlockStyle(childArray, aBlockTag);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:       else
    1:       {
    1:         // make sure we can put a block here
    1:         res = SplitAsNeeded(aBlockTag, address_of(curParent), &offset);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         nsCOMPtr<nsIDOMNode> theBlock;
    1:         res = mHTMLEditor->CreateNode(*aBlockTag, curParent, offset, getter_AddRefs(theBlock));
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         // remember our new block for postprocessing
    1:         mNewBlock = theBlock;
    1:       }
    1:     }
    1:     
    1:     // if the node is a break, we honor it by putting further nodes in a new parent
    1:     else if (curNodeTag.EqualsLiteral("br"))
    1:     {
    1:       if (curBlock)
    1:       {
    1:         curBlock = 0;  // forget any previous block used for previous inline nodes
    1:         res = mHTMLEditor->DeleteNode(curNode);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:       else
    1:       {
    1:         // the break is the first (or even only) node we encountered.  Create a
    1:         // block for it.
    1:         res = SplitAsNeeded(aBlockTag, address_of(curParent), &offset);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         res = mHTMLEditor->CreateNode(*aBlockTag, curParent, offset, getter_AddRefs(curBlock));
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         // remember our new block for postprocessing
    1:         mNewBlock = curBlock;
    1:         // note: doesn't matter if we set mNewBlock multiple times.
    1:         res = mHTMLEditor->MoveNode(curNode, curBlock, -1);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:     }
    1:         
    1:     
    1:     // if curNode is inline, pull it into curBlock
    1:     // note: it's assumed that consecutive inline nodes in the 
    1:     // arrayOfNodes are actually members of the same block parent.
    1:     // this happens to be true now as a side effect of how
    1:     // arrayOfNodes is contructed, but some additional logic should
    1:     // be added here if that should change
    1:     
    1:     else if (IsInlineNode(curNode))
    1:     {
    1:       // if curNode is a non editable, drop it if we are going to <pre>
    1:       if (tString.LowerCaseEqualsLiteral("pre") 
    1:         && (!mHTMLEditor->IsEditable(curNode)))
    1:         continue; // do nothing to this block
    1:       
    1:       // if no curBlock, make one
    1:       if (!curBlock)
    1:       {
    1:         res = SplitAsNeeded(aBlockTag, address_of(curParent), &offset);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         res = mHTMLEditor->CreateNode(*aBlockTag, curParent, offset, getter_AddRefs(curBlock));
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         // remember our new block for postprocessing
    1:         mNewBlock = curBlock;
    1:         // note: doesn't matter if we set mNewBlock multiple times.
    1:       }
    1:       
    1:       // if curNode is a Break, replace it with a return if we are going to <pre>
    1:       // xxx floppy moose
    1:  
    1:       // this is a continuation of some inline nodes that belong together in
    1:       // the same block item.  use curBlock
    1:       res = mHTMLEditor->MoveNode(curNode, curBlock, -1);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // SplitAsNeeded:  given a tag name, split inOutParent up to the point   
    1: //                 where we can insert the tag.  Adjust inOutParent and
    1: //                 inOutOffset to pint to new location for tag.
    1: nsresult 
    1: nsHTMLEditRules::SplitAsNeeded(const nsAString *aTag, 
    1:                                nsCOMPtr<nsIDOMNode> *inOutParent,
    1:                                PRInt32 *inOutOffset)
    1: {
43806:   NS_ENSURE_TRUE(aTag && inOutParent && inOutOffset, NS_ERROR_NULL_POINTER);
43806:   NS_ENSURE_TRUE(*inOutParent, NS_ERROR_NULL_POINTER);
    1:   nsCOMPtr<nsIDOMNode> tagParent, temp, splitNode, parent = *inOutParent;
    1:   nsresult res = NS_OK;
    1:    
    1:   // check that we have a place that can legally contain the tag
    1:   while (!tagParent)
    1:   {
    1:     // sniffing up the parent tree until we find 
    1:     // a legal place for the block
    1:     if (!parent) break;
    1:     if (mHTMLEditor->CanContainTag(parent, *aTag))
    1:     {
    1:       tagParent = parent;
    1:       break;
    1:     }
    1:     splitNode = parent;
    1:     parent->GetParentNode(getter_AddRefs(temp));
    1:     parent = temp;
    1:   }
    1:   if (!tagParent)
    1:   {
    1:     // could not find a place to build tag!
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   if (splitNode)
    1:   {
    1:     // we found a place for block, but above inOutParent.  We need to split nodes.
    1:     res = mHTMLEditor->SplitNodeDeep(splitNode, *inOutParent, *inOutOffset, inOutOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     *inOutParent = tagParent;
    1:   }
    1:   return res;
    1: }      
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // JoinNodesSmart:  join two nodes, doing whatever makes sense for their  
    1: //                  children (which often means joining them, too).
    1: //                  aNodeLeft & aNodeRight must be same type of node.
    1: nsresult 
    1: nsHTMLEditRules::JoinNodesSmart( nsIDOMNode *aNodeLeft, 
    1:                                  nsIDOMNode *aNodeRight, 
    1:                                  nsCOMPtr<nsIDOMNode> *aOutMergeParent, 
    1:                                  PRInt32 *aOutMergeOffset)
    1: {
    1:   // check parms
43807:   NS_ENSURE_TRUE(aNodeLeft &&  
43807:       aNodeRight && 
43807:       aOutMergeParent &&
43807:       aOutMergeOffset, NS_ERROR_NULL_POINTER);
    1:   
    1:   nsresult res = NS_OK;
    1:   // caller responsible for:
    1:   //   left & right node are same type
    1:   PRInt32 parOffset;
    1:   nsCOMPtr<nsIDOMNode> parent, rightParent;
    1:   res = nsEditor::GetNodeLocation(aNodeLeft, address_of(parent), &parOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   aNodeRight->GetParentNode(getter_AddRefs(rightParent));
    1: 
    1:   // if they don't have the same parent, first move the 'right' node 
    1:   // to after the 'left' one
    1:   if (parent != rightParent)
    1:   {
    1:     res = mHTMLEditor->MoveNode(aNodeRight, parent, parOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   
    1:   // defaults for outParams
    1:   *aOutMergeParent = aNodeRight;
    1:   res = mHTMLEditor->GetLengthOfDOMNode(aNodeLeft, *((PRUint32*)aOutMergeOffset));
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // separate join rules for differing blocks
    1:   if (nsHTMLEditUtils::IsList(aNodeLeft) ||
    1:       mHTMLEditor->IsTextNode(aNodeLeft))
    1:   {
    1:     // for list's, merge shallow (wouldn't want to combine list items)
    1:     res = mHTMLEditor->JoinNodes(aNodeLeft, aNodeRight, parent);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     return res;
    1:   }
    1:   else
    1:   {
    1:     // remember the last left child, and firt right child
    1:     nsCOMPtr<nsIDOMNode> lastLeft, firstRight;
    1:     res = mHTMLEditor->GetLastEditableChild(aNodeLeft, address_of(lastLeft));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     res = mHTMLEditor->GetFirstEditableChild(aNodeRight, address_of(firstRight));
43805:     NS_ENSURE_SUCCESS(res, res);
    1: 
    1:     // for list items, divs, etc, merge smart
    1:     res = mHTMLEditor->JoinNodes(aNodeLeft, aNodeRight, parent);
43805:     NS_ENSURE_SUCCESS(res, res);
    1: 
    1:     if (lastLeft && firstRight &&
    1:         mHTMLEditor->NodesSameType(lastLeft, firstRight) &&
    1:         (nsEditor::IsTextNode(lastLeft) ||
    1:          mHTMLEditor->mHTMLCSSUtils->ElementsSameStyle(lastLeft, firstRight)))
    1:       return JoinNodesSmart(lastLeft, firstRight, aOutMergeParent, aOutMergeOffset);
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsHTMLEditRules::GetTopEnclosingMailCite(nsIDOMNode *aNode, 
    1:                                          nsCOMPtr<nsIDOMNode> *aOutCiteNode,
    1:                                          PRBool aPlainText)
    1: {
    1:   // check parms
43807:   NS_ENSURE_TRUE(aNode && aOutCiteNode, NS_ERROR_NULL_POINTER);
    1:   
    1:   nsresult res = NS_OK;
    1:   nsCOMPtr<nsIDOMNode> node, parentNode;
    1:   node = do_QueryInterface(aNode);
    1:   
    1:   while (node)
    1:   {
    1:     if ( (aPlainText && nsHTMLEditUtils::IsPre(node)) ||
    1:          nsHTMLEditUtils::IsMailCite(node) )
    1:       *aOutCiteNode = node;
    1:     if (nsTextEditUtils::IsBody(node)) break;
    1:     
    1:     res = node->GetParentNode(getter_AddRefs(parentNode));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     node = parentNode;
    1:   }
    1: 
    1:   return res;
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsHTMLEditRules::CacheInlineStyles(nsIDOMNode *aNode)
    1: {
43806:   NS_ENSURE_TRUE(aNode, NS_ERROR_NULL_POINTER);
    1: 
    1:   PRBool useCSS;
    1:   mHTMLEditor->GetIsCSSEnabled(&useCSS);
    1: 
    1:   PRInt32 j;
    1:   for (j=0; j<SIZE_STYLE_TABLE; j++)
    1:   {
    1:     PRBool isSet = PR_FALSE;
    1:     nsAutoString outValue;
    1:     nsCOMPtr<nsIDOMNode> resultNode;
    1:     if (!useCSS)
    1:     {
    1:       mHTMLEditor->IsTextPropertySetByContent(aNode, mCachedStyles[j].tag, &(mCachedStyles[j].attr), nsnull,
    1:                                isSet, getter_AddRefs(resultNode), &outValue);
    1:     }
    1:     else
    1:     {
    1:       mHTMLEditor->mHTMLCSSUtils->IsCSSEquivalentToHTMLInlineStyleSet(aNode, mCachedStyles[j].tag, &(mCachedStyles[j].attr),
    1:                                                     isSet, outValue, COMPUTED_STYLE_TYPE);
    1:     }
    1:     if (isSet)
    1:     {
    1:       mCachedStyles[j].mPresent = PR_TRUE;
    1:       mCachedStyles[j].value.Assign(outValue);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsHTMLEditRules::ReapplyCachedStyles()
    1: {
    1:   // The idea here is to examine our cached list of styles
    1:   // and see if any have been removed.  If so, add typeinstate
    1:   // for them, so that they will be reinserted when new 
    1:   // content is added.
    1:   
    1:   // When we apply cached styles to TypeInState, we always want
    1:   // to blow away prior TypeInState:
    1:   mHTMLEditor->mTypeInState->Reset();
    1: 
    1:   // remember if we are in css mode
    1:   PRBool useCSS;
    1:   mHTMLEditor->GetIsCSSEnabled(&useCSS);
    1: 
    1:   // get selection point
    1:   nsCOMPtr<nsISelection>selection;
    1:   nsresult res = mHTMLEditor->GetSelection(getter_AddRefs(selection));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   nsCOMPtr<nsIDOMNode> selNode;
    1:   PRInt32 selOffset;
43518:   res = mHTMLEditor->GetStartNodeAndOffset(selection, getter_AddRefs(selNode), &selOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   res = NS_OK;
    1:   PRInt32 j;
    1:   for (j=0; j<SIZE_STYLE_TABLE; j++)
    1:   {
    1:     if (mCachedStyles[j].mPresent)
    1:     {
    1:       PRBool bFirst, bAny, bAll;
    1:       bFirst = bAny = bAll = PR_FALSE;
    1:       
    1:       nsAutoString curValue;
    1:       if (useCSS) // check computed style first in css case
    1:       {
    1:         mHTMLEditor->mHTMLCSSUtils->IsCSSEquivalentToHTMLInlineStyleSet(selNode, mCachedStyles[j].tag, &(mCachedStyles[j].attr),
    1:                                                     bAny, curValue, COMPUTED_STYLE_TYPE);
    1:       }
    1:       if (!bAny) // then check typeinstate and html style
    1:       {
    1:         res = mHTMLEditor->GetInlinePropertyBase(mCachedStyles[j].tag, &(mCachedStyles[j].attr), &(mCachedStyles[j].value), 
    1:                                                         &bFirst, &bAny, &bAll, &curValue, PR_FALSE);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:       // this style has disappeared through deletion.  Add it onto our typeinstate:
    1:       if (!bAny) 
    1:       {
    1:         mHTMLEditor->mTypeInState->SetProp(mCachedStyles[j].tag, mCachedStyles[j].attr, mCachedStyles[j].value);
    1:       }
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsHTMLEditRules::ClearCachedStyles()
    1: {
    1:   // clear the mPresent bits in mCachedStyles array
    1:   
    1:   PRInt32 j;
    1:   for (j=0; j<SIZE_STYLE_TABLE; j++)
    1:   {
    1:     mCachedStyles[j].mPresent = PR_FALSE;
    1:     mCachedStyles[j].value.Truncate(0);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsHTMLEditRules::AdjustSpecialBreaks(PRBool aSafeToAskFrames)
    1: {
    1:   nsCOMArray<nsIDOMNode> arrayOfNodes;
    1:   nsCOMPtr<nsISupports> isupports;
    1:   PRInt32 nodeCount,j;
    1:   
    1:   // gather list of empty nodes
 8716:   nsEmptyEditableFunctor functor(mHTMLEditor);
    1:   nsDOMIterator iter;
    1:   nsresult res = iter.Init(mDocChangeRange);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = iter.AppendList(functor, arrayOfNodes);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // put moz-br's into these empty li's and td's
    1:   nodeCount = arrayOfNodes.Count();
    1:   for (j = 0; j < nodeCount; j++)
    1:   {
    1:     // need to put br at END of node.  It may have
    1:     // empty containers in it and still pass the "IsEmptynode" test,
    1:     // and we want the br's to be after them.  Also, we want the br
    1:     // to be after the selection if the selection is in this node.
    1:     PRUint32 len;
    1:     nsCOMPtr<nsIDOMNode> brNode, theNode = arrayOfNodes[0];
    1:     arrayOfNodes.RemoveObjectAt(0);
    1:     res = nsEditor::GetLengthOfDOMNode(theNode, len);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     res = CreateMozBR(theNode, (PRInt32)len, address_of(brNode));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   
    1:   return res;
    1: }
    1: 
    1: nsresult 
    1: nsHTMLEditRules::AdjustWhitespace(nsISelection *aSelection)
    1: {
    1:   // get selection point
    1:   nsCOMPtr<nsIDOMNode> selNode;
    1:   PRInt32 selOffset;
43518:   nsresult res = mHTMLEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(selNode), &selOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   // ask whitespace object to tweak nbsp's
    1:   return nsWSRunObject(mHTMLEditor, selNode, selOffset).AdjustWhitespace();
    1: }
    1: 
    1: nsresult 
    1: nsHTMLEditRules::PinSelectionToNewBlock(nsISelection *aSelection)
    1: {
43806:   NS_ENSURE_TRUE(aSelection, NS_ERROR_NULL_POINTER);
    1:   PRBool bCollapsed;
    1:   nsresult res = aSelection->GetIsCollapsed(&bCollapsed);
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(bCollapsed, res);
    1: 
    1:   // get the (collapsed) selection location
    1:   nsCOMPtr<nsIDOMNode> selNode, temp;
    1:   PRInt32 selOffset;
43518:   res = mHTMLEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(selNode), &selOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   temp = selNode;
    1:   
    1:   // use ranges and sRangeHelper to compare sel point to new block
    1:   nsCOMPtr<nsIDOMRange> range = do_CreateInstance("@mozilla.org/content/range;1");
    1:   res = range->SetStart(selNode, selOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = range->SetEnd(selNode, selOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   nsCOMPtr<nsIContent> block (do_QueryInterface(mNewBlock));
43806:   NS_ENSURE_TRUE(block, NS_ERROR_NO_INTERFACE);
    1:   PRBool nodeBefore, nodeAfter;
    1:   res = mHTMLEditor->sRangeHelper->CompareNodeToRange(block, range, &nodeBefore, &nodeAfter);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   if (nodeBefore && nodeAfter)
    1:     return NS_OK;  // selection is inside block
    1:   else if (nodeBefore)
    1:   {
    1:     // selection is after block.  put at end of block.
    1:     nsCOMPtr<nsIDOMNode> tmp = mNewBlock;
    1:     mHTMLEditor->GetLastEditableChild(mNewBlock, address_of(tmp));
    1:     PRUint32 endPoint;
    1:     if (mHTMLEditor->IsTextNode(tmp) || mHTMLEditor->IsContainer(tmp))
    1:     {
    1:       res = nsEditor::GetLengthOfDOMNode(tmp, endPoint);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     else
    1:     {
    1:       nsCOMPtr<nsIDOMNode> tmp2;
    1:       res = nsEditor::GetNodeLocation(tmp, address_of(tmp2), (PRInt32*)&endPoint);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       tmp = tmp2;
    1:       endPoint++;  // want to be after this node
    1:     }
    1:     return aSelection->Collapse(tmp, (PRInt32)endPoint);
    1:   }
    1:   else
    1:   {
    1:     // selection is before block.  put at start of block.
    1:     nsCOMPtr<nsIDOMNode> tmp = mNewBlock;
    1:     mHTMLEditor->GetFirstEditableChild(mNewBlock, address_of(tmp));
    1:     PRInt32 offset;
    1:     if (!(mHTMLEditor->IsTextNode(tmp) || mHTMLEditor->IsContainer(tmp)))
    1:     {
    1:       nsCOMPtr<nsIDOMNode> tmp2;
    1:       res = nsEditor::GetNodeLocation(tmp, address_of(tmp2), &offset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       tmp = tmp2;
    1:     }
    1:     return aSelection->Collapse(tmp, 0);
    1:   }
    1: }
    1: 
    1: nsresult 
    1: nsHTMLEditRules::CheckInterlinePosition(nsISelection *aSelection)
    1: {
43806:   NS_ENSURE_TRUE(aSelection, NS_ERROR_NULL_POINTER);
    1:   nsCOMPtr<nsISelection> selection(aSelection);
    1:   nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(selection));
    1: 
    1:   // if the selection isn't collapsed, do nothing.
    1:   PRBool bCollapsed;
    1:   nsresult res = aSelection->GetIsCollapsed(&bCollapsed);
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(bCollapsed, res);
    1: 
    1:   // get the (collapsed) selection location
    1:   nsCOMPtr<nsIDOMNode> selNode, node;
    1:   PRInt32 selOffset;
43518:   res = mHTMLEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(selNode), &selOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   // are we after a block?  If so try set caret to following content
    1:   mHTMLEditor->GetPriorHTMLSibling(selNode, selOffset, address_of(node));
    1:   if (node && IsBlockNode(node))
    1:   {
    1:     selPriv->SetInterlinePosition(PR_TRUE);
    1:     return NS_OK;
    1:   }
    1: 
    1:   // are we before a block?  If so try set caret to prior content
    1:   mHTMLEditor->GetNextHTMLSibling(selNode, selOffset, address_of(node));
    1:   if (node && IsBlockNode(node))
    1:   {
    1:     selPriv->SetInterlinePosition(PR_FALSE);
    1:     return NS_OK;
    1:   }
    1:   
    1:   // are we after a <br>?  If so we want to stick to whatever is after <br>.
    1:   mHTMLEditor->GetPriorHTMLNode(selNode, selOffset, address_of(node), PR_TRUE);
    1:   if (node && nsTextEditUtils::IsBreak(node))
    1:       selPriv->SetInterlinePosition(PR_TRUE);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult 
    1: nsHTMLEditRules::AdjustSelection(nsISelection *aSelection, nsIEditor::EDirection aAction)
    1: {
43806:   NS_ENSURE_TRUE(aSelection, NS_ERROR_NULL_POINTER);
    1:   nsCOMPtr<nsISelection> selection(aSelection);
    1:   nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(selection));
    1:  
    1:   // if the selection isn't collapsed, do nothing.
    1:   // moose: one thing to do instead is check for the case of
    1:   // only a single break selected, and collapse it.  Good thing?  Beats me.
    1:   PRBool bCollapsed;
    1:   nsresult res = aSelection->GetIsCollapsed(&bCollapsed);
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(bCollapsed, res);
    1: 
    1:   // get the (collapsed) selection location
    1:   nsCOMPtr<nsIDOMNode> selNode, temp;
    1:   PRInt32 selOffset;
43518:   res = mHTMLEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(selNode), &selOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   temp = selNode;
    1:   
    1:   // are we in an editable node?
    1:   while (!mHTMLEditor->IsEditable(selNode))
    1:   {
    1:     // scan up the tree until we find an editable place to be
    1:     res = nsEditor::GetNodeLocation(temp, address_of(selNode), &selOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
43806:     NS_ENSURE_TRUE(selNode, NS_ERROR_FAILURE);
    1:     temp = selNode;
    1:   }
    1:   
    1:   // make sure we aren't in an empty block - user will see no cursor.  If this
    1:   // is happening, put a <br> in the block if allowed.
    1:   nsCOMPtr<nsIDOMNode> theblock;
    1:   if (IsBlockNode(selNode)) theblock = selNode;
    1:   else theblock = mHTMLEditor->GetBlockNodeParent(selNode);
20297:   if (theblock && mHTMLEditor->IsEditable(theblock)) {
    1:     PRBool bIsEmptyNode;
    1:     res = mHTMLEditor->IsEmptyNode(theblock, &bIsEmptyNode, PR_FALSE, PR_FALSE);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     // check if br can go into the destination node
    1:     if (bIsEmptyNode && mHTMLEditor->CanContainTag(selNode, NS_LITERAL_STRING("br")))
    1:     {
    1:       nsIDOMElement *rootElement = mHTMLEditor->GetRoot();
43806:       NS_ENSURE_TRUE(rootElement, NS_ERROR_FAILURE);
    1:       nsCOMPtr<nsIDOMNode> rootNode(do_QueryInterface(rootElement));
    1:       if (selNode == rootNode)
    1:       {
    1:         // Our root node is completely empty. Don't add a <br> here.
    1:         // AfterEditInner() will add one for us when it calls
    1:         // CreateBogusNodeIfNeeded()!
    1:         return NS_OK;
    1:       }
    1: 
    1:       nsCOMPtr<nsIDOMNode> brNode;
    1:       // we know we can skip the rest of this routine given the cirumstance
    1:       return CreateMozBR(selNode, selOffset, address_of(brNode));
    1:     }
20297:   }
    1:   
    1:   // are we in a text node? 
    1:   nsCOMPtr<nsIDOMCharacterData> textNode = do_QueryInterface(selNode);
    1:   if (textNode)
    1:     return NS_OK; // we LIKE it when we are in a text node.  that RULZ
    1:   
    1:   // do we need to insert a special mozBR?  We do if we are:
    1:   // 1) prior node is in same block where selection is AND
    1:   // 2) prior node is a br AND
    1:   // 3) that br is not visible
    1: 
    1:   nsCOMPtr<nsIDOMNode> nearNode;
    1:   res = mHTMLEditor->GetPriorHTMLNode(selNode, selOffset, address_of(nearNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (nearNode) 
    1:   {
    1:     // is nearNode also a descendant of same block?
    1:     nsCOMPtr<nsIDOMNode> block, nearBlock;
    1:     if (IsBlockNode(selNode)) block = selNode;
    1:     else block = mHTMLEditor->GetBlockNodeParent(selNode);
    1:     nearBlock = mHTMLEditor->GetBlockNodeParent(nearNode);
    1:     if (block == nearBlock)
    1:     {
    1:       if (nearNode && nsTextEditUtils::IsBreak(nearNode) )
    1:       {   
    1:         if (!mHTMLEditor->IsVisBreak(nearNode))
    1:         {
    1:           // need to insert special moz BR. Why?  Because if we don't
    1:           // the user will see no new line for the break.  Also, things
    1:           // like table cells won't grow in height.
    1:           nsCOMPtr<nsIDOMNode> brNode;
    1:           res = CreateMozBR(selNode, selOffset, address_of(brNode));
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           res = nsEditor::GetNodeLocation(brNode, address_of(selNode), &selOffset);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           // selection stays *before* moz-br, sticking to it
    1:           selPriv->SetInterlinePosition(PR_TRUE);
    1:           res = aSelection->Collapse(selNode,selOffset);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:         }
    1:         else
    1:         {
    1:           nsCOMPtr<nsIDOMNode> nextNode;
    1:           mHTMLEditor->GetNextHTMLNode(nearNode, address_of(nextNode), PR_TRUE);
    1:           if (nextNode && nsTextEditUtils::IsMozBR(nextNode))
    1:           {
    1:             // selection between br and mozbr.  make it stick to mozbr
    1:             // so that it will be on blank line.   
    1:             selPriv->SetInterlinePosition(PR_TRUE);
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   // we aren't in a textnode: are we adjacent to text or a break or an image?
    1:   res = mHTMLEditor->GetPriorHTMLNode(selNode, selOffset, address_of(nearNode), PR_TRUE);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (nearNode && (nsTextEditUtils::IsBreak(nearNode)
    1:                    || nsEditor::IsTextNode(nearNode)
    1:                    || nsHTMLEditUtils::IsImage(nearNode)
    1:                    || nsHTMLEditUtils::IsHR(nearNode)))
    1:     return NS_OK; // this is a good place for the caret to be
    1:   res = mHTMLEditor->GetNextHTMLNode(selNode, selOffset, address_of(nearNode), PR_TRUE);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (nearNode && (nsTextEditUtils::IsBreak(nearNode)
    1:                    || nsEditor::IsTextNode(nearNode)
    1:                    || nsHTMLEditUtils::IsImage(nearNode)
    1:                    || nsHTMLEditUtils::IsHR(nearNode)))
    1:     return NS_OK; // this is a good place for the caret to be
    1: 
    1:   // look for a nearby text node.
    1:   // prefer the correct direction.
    1:   res = FindNearSelectableNode(selNode, selOffset, aAction, address_of(nearNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   if (nearNode)
    1:   {
    1:     // is the nearnode a text node?
    1:     textNode = do_QueryInterface(nearNode);
    1:     if (textNode)
    1:     {
    1:       PRInt32 offset = 0;
    1:       // put selection in right place:
    1:       if (aAction == nsIEditor::ePrevious)
    1:         textNode->GetLength((PRUint32*)&offset);
    1:       res = aSelection->Collapse(nearNode,offset);
    1:     }
    1:     else  // must be break or image
    1:     {
    1:       res = nsEditor::GetNodeLocation(nearNode, address_of(selNode), &selOffset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       if (aAction == nsIEditor::ePrevious) selOffset++;  // want to be beyond it if we backed up to it
    1:       res = aSelection->Collapse(selNode, selOffset);
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsHTMLEditRules::FindNearSelectableNode(nsIDOMNode *aSelNode, 
    1:                                         PRInt32 aSelOffset, 
    1:                                         nsIEditor::EDirection &aDirection,
    1:                                         nsCOMPtr<nsIDOMNode> *outSelectableNode)
    1: {
43806:   NS_ENSURE_TRUE(aSelNode && outSelectableNode, NS_ERROR_NULL_POINTER);
    1:   *outSelectableNode = nsnull;
    1:   nsresult res = NS_OK;
    1:   
    1:   nsCOMPtr<nsIDOMNode> nearNode, curNode;
    1:   if (aDirection == nsIEditor::ePrevious)
    1:     res = mHTMLEditor->GetPriorHTMLNode(aSelNode, aSelOffset, address_of(nearNode));
    1:   else
    1:     res = mHTMLEditor->GetNextHTMLNode(aSelNode, aSelOffset, address_of(nearNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   if (!nearNode) // try the other direction then
    1:   {
    1:     if (aDirection == nsIEditor::ePrevious)
    1:       aDirection = nsIEditor::eNext;
    1:     else
    1:       aDirection = nsIEditor::ePrevious;
    1:     
    1:     if (aDirection == nsIEditor::ePrevious)
    1:       res = mHTMLEditor->GetPriorHTMLNode(aSelNode, aSelOffset, address_of(nearNode));
    1:     else
    1:       res = mHTMLEditor->GetNextHTMLNode(aSelNode, aSelOffset, address_of(nearNode));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   
    1:   // scan in the right direction until we find an eligible text node,
    1:   // but don't cross any breaks, images, or table elements.
    1:   while (nearNode && !(mHTMLEditor->IsTextNode(nearNode)
    1:                        || nsTextEditUtils::IsBreak(nearNode)
    1:                        || nsHTMLEditUtils::IsImage(nearNode)))
    1:   {
    1:     curNode = nearNode;
    1:     if (aDirection == nsIEditor::ePrevious)
    1:       res = mHTMLEditor->GetPriorHTMLNode(curNode, address_of(nearNode));
    1:     else
    1:       res = mHTMLEditor->GetNextHTMLNode(curNode, address_of(nearNode));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   
    1:   if (nearNode)
    1:   {
    1:     // don't cross any table elements
    1:     PRBool bInDifTblElems;
    1:     res = InDifferentTableElements(nearNode, aSelNode, &bInDifTblElems);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (bInDifTblElems) return NS_OK;  
    1:     
    1:     // otherwise, ok, we have found a good spot to put the selection
    1:     *outSelectableNode = do_QueryInterface(nearNode);
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsHTMLEditRules::InDifferentTableElements(nsIDOMNode *aNode1, nsIDOMNode *aNode2, PRBool *aResult)
    1: {
    1:   NS_ASSERTION(aNode1 && aNode2 && aResult, "null args");
43806:   NS_ENSURE_TRUE(aNode1 && aNode2 && aResult, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsCOMPtr<nsIDOMNode> tn1, tn2, node = aNode1, temp;
    1:   *aResult = PR_FALSE;
    1:   
    1:   while (node && !nsHTMLEditUtils::IsTableElement(node))
    1:   {
    1:     node->GetParentNode(getter_AddRefs(temp));
    1:     node = temp;
    1:   }
    1:   tn1 = node;
    1:   
    1:   node = aNode2;
    1:   while (node && !nsHTMLEditUtils::IsTableElement(node))
    1:   {
    1:     node->GetParentNode(getter_AddRefs(temp));
    1:     node = temp;
    1:   }
    1:   tn2 = node;
    1:   
    1:   *aResult = (tn1 != tn2);
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsHTMLEditRules::RemoveEmptyNodes()
    1: {
    1:   nsCOMArray<nsIDOMNode> arrayOfEmptyNodes, arrayOfEmptyCites;
    1:   nsCOMPtr<nsISupports> isupports;
    1:   PRInt32 nodeCount,j;
    1:   
    1:   // some general notes on the algorithm used here: the goal is to examine all the
    1:   // nodes in mDocChangeRange, and remove the empty ones.  We do this by using a
    1:   // content iterator to traverse all the nodes in the range, and placing the empty
    1:   // nodes into an array.  After finishing the iteration, we delete the empty nodes
    1:   // in the array.  (they cannot be deleted as we find them becasue that would 
    1:   // invalidate the iterator.)  
    1:   // Since checking to see if a node is empty can be costly for nodes with many
    1:   // descendants, there are some optimizations made.  I rely on the fact that the
    1:   // iterator is post-order: it will visit children of a node before visiting the 
    1:   // parent node.  So if I find that a child node is not empty, I know that it's
    1:   // parent is not empty without even checking.  So I put the parent on a "skipList"
    1:   // which is just a voidArray of nodes I can skip the empty check on.  If I 
    1:   // encounter a node on the skiplist, i skip the processing for that node and replace
    1:   // it's slot in the skiplist with that node's parent.
    1:   // An interseting idea is to go ahead and regard parent nodes that are NOT on the
    1:   // skiplist as being empty (without even doing the IsEmptyNode check) on the theory
    1:   // that if they weren't empty, we would have encountered a non-empty child earlier
    1:   // and thus put this parent node on the skiplist.
    1:   // Unfortunately I can't use that strategy here, because the range may include 
    1:   // some children of a node while excluding others.  Thus I could find all the 
    1:   // _examined_ children empty, but still not have an empty parent.
    1:   
    1:   // need an iterator
    1:   nsCOMPtr<nsIContentIterator> iter =
    1:                   do_CreateInstance("@mozilla.org/content/post-content-iterator;1");
43806:   NS_ENSURE_TRUE(iter, NS_ERROR_NULL_POINTER);
    1:   
    1:   nsresult res = iter->Init(mDocChangeRange);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
27986:   nsTArray<nsIDOMNode*> skipList;
    1: 
    1:   // check for empty nodes
    1:   while (!iter->IsDone())
    1:   {
    1:     nsCOMPtr<nsIDOMNode> node, parent;
    1: 
    1:     node = do_QueryInterface(iter->GetCurrentNode());
43807:     NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
    1: 
    1:     node->GetParentNode(getter_AddRefs(parent));
    1:     
27986:     PRUint32 idx = skipList.IndexOf(node);
27986:     if (idx != skipList.NoIndex)
    1:     {
    1:       // this node is on our skip list.  Skip processing for this node, 
    1:       // and replace it's value in the skip list with the value of it's parent
27986:       skipList[idx] = parent;
    1:     }
    1:     else
    1:     {
    1:       PRBool bIsCandidate = PR_FALSE;
    1:       PRBool bIsEmptyNode = PR_FALSE;
    1:       PRBool bIsMailCite = PR_FALSE;
    1: 
    1:       // don't delete the body
    1:       if (!nsTextEditUtils::IsBody(node))
    1:       {
    1:         // only consider certain nodes to be empty for purposes of removal
    1:         if (  (bIsMailCite = nsHTMLEditUtils::IsMailCite(node))  ||
    1:               nsEditor::NodeIsType(node, nsEditProperty::a)      ||
    1:               nsHTMLEditUtils::IsInlineStyle(node)               ||
    1:               nsHTMLEditUtils::IsList(node)                      ||
    1:               nsHTMLEditUtils::IsDiv(node)  )
    1:         {
    1:           bIsCandidate = PR_TRUE;
    1:         }
    1:         // these node types are candidates if selection is not in them
    1:         else if (nsHTMLEditUtils::IsFormatNode(node) ||
    1:             nsHTMLEditUtils::IsListItem(node)  ||
    1:             nsHTMLEditUtils::IsBlockquote(node) )
    1:         {
    1:           // if it is one of these, don't delete if selection inside.
    1:           // this is so we can create empty headings, etc, for the
    1:           // user to type into.
    1:           PRBool bIsSelInNode;
    1:           res = SelectionEndpointInNode(node, &bIsSelInNode);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           if (!bIsSelInNode)
    1:           {
    1:             bIsCandidate = PR_TRUE;
    1:           }
    1:         }
    1:       }
    1:       
    1:       if (bIsCandidate)
    1:       {
    1:         if (bIsMailCite)  // we delete mailcites even if they have a solo br in them
    1:           res = mHTMLEditor->IsEmptyNode(node, &bIsEmptyNode, PR_TRUE, PR_TRUE);  
    1:         else  // other nodes we require to be empty
    1:           res = mHTMLEditor->IsEmptyNode(node, &bIsEmptyNode, PR_FALSE, PR_TRUE);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         if (bIsEmptyNode)
    1:         {
    1:           if (bIsMailCite)  // mailcites go on a separate list from other empty nodes
    1:           {
    1:             arrayOfEmptyCites.AppendObject(node);
    1:           }
    1:           else
    1:           {
    1:             arrayOfEmptyNodes.AppendObject(node);
    1:           }
    1:         }
    1:       }
    1:       
    1:       if (!bIsEmptyNode)
    1:       {
    1:         // put parent on skip list
27986:         skipList.AppendElement(parent);
    1:       }
    1:     }
    1: 
    1:     iter->Next();
    1:   }
    1:   
    1:   // now delete the empty nodes
    1:   nodeCount = arrayOfEmptyNodes.Count();
    1:   for (j = 0; j < nodeCount; j++)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> delNode = arrayOfEmptyNodes[0];
    1:     arrayOfEmptyNodes.RemoveObjectAt(0);
42995:     if (mHTMLEditor->IsModifiableNode(delNode)) {
    1:       res = mHTMLEditor->DeleteNode(delNode);
42995:       NS_ENSURE_SUCCESS(res, res);
42995:     }
    1:   }
    1:   
    1:   // now delete the empty mailcites
    1:   // this is a separate step because we want to pull out any br's and preserve them.
    1:   nodeCount = arrayOfEmptyCites.Count();
    1:   for (j = 0; j < nodeCount; j++)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> delNode = arrayOfEmptyCites[0];
    1:     arrayOfEmptyCites.RemoveObjectAt(0);
    1:     PRBool bIsEmptyNode;
    1:     res = mHTMLEditor->IsEmptyNode(delNode, &bIsEmptyNode, PR_FALSE, PR_TRUE);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (!bIsEmptyNode)
    1:     {
    1:       // we are deleting a cite that has just a br.  We want to delete cite, 
    1:       // but preserve br.
    1:       nsCOMPtr<nsIDOMNode> parent, brNode;
    1:       PRInt32 offset;
    1:       res = nsEditor::GetNodeLocation(delNode, address_of(parent), &offset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = mHTMLEditor->CreateBR(parent, offset, address_of(brNode));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     res = mHTMLEditor->DeleteNode(delNode);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   
    1:   return res;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditRules::SelectionEndpointInNode(nsIDOMNode *aNode, PRBool *aResult)
    1: {
43806:   NS_ENSURE_TRUE(aNode && aResult, NS_ERROR_NULL_POINTER);
    1:   
    1:   *aResult = PR_FALSE;
    1:   
    1:   nsCOMPtr<nsISelection>selection;
    1:   nsresult res = mHTMLEditor->GetSelection(getter_AddRefs(selection));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   nsCOMPtr<nsISelectionPrivate>selPriv(do_QueryInterface(selection));
    1:   
    1:   nsCOMPtr<nsIEnumerator> enumerator;
    1:   res = selPriv->GetEnumerator(getter_AddRefs(enumerator));
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(enumerator, NS_ERROR_UNEXPECTED);
    1: 
    1:   for (enumerator->First(); NS_OK!=enumerator->IsDone(); enumerator->Next())
    1:   {
    1:     nsCOMPtr<nsISupports> currentItem;
    1:     res = enumerator->CurrentItem(getter_AddRefs(currentItem));
43805:     NS_ENSURE_SUCCESS(res, res);
43806:     NS_ENSURE_TRUE(currentItem, NS_ERROR_UNEXPECTED);
    1: 
    1:     nsCOMPtr<nsIDOMRange> range( do_QueryInterface(currentItem) );
    1:     nsCOMPtr<nsIDOMNode> startParent, endParent;
    1:     range->GetStartContainer(getter_AddRefs(startParent));
    1:     if (startParent)
    1:     {
    1:       if (aNode == startParent)
    1:       {
    1:         *aResult = PR_TRUE;
    1:         return NS_OK;
    1:       }
    1:       if (nsEditorUtils::IsDescendantOf(startParent, aNode)) 
    1:       {
    1:         *aResult = PR_TRUE;
    1:         return NS_OK;
    1:       }
    1:     }
    1:     range->GetEndContainer(getter_AddRefs(endParent));
    1:     if (startParent == endParent) continue;
    1:     if (endParent)
    1:     {
    1:       if (aNode == endParent) 
    1:       {
    1:         *aResult = PR_TRUE;
    1:         return NS_OK;
    1:       }
    1:       if (nsEditorUtils::IsDescendantOf(endParent, aNode))
    1:       {
    1:         *aResult = PR_TRUE;
    1:         return NS_OK;
    1:       }
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // IsEmptyInline:  return true if aNode is an empty inline container
    1: //                
    1: //                  
    1: PRBool 
    1: nsHTMLEditRules::IsEmptyInline(nsIDOMNode *aNode)
    1: {
    1:   if (aNode && IsInlineNode(aNode) && mHTMLEditor->IsContainer(aNode)) 
    1:   {
    1:     PRBool bEmpty;
    1:     mHTMLEditor->IsEmptyNode(aNode, &bEmpty);
    1:     return bEmpty;
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: 
    1: PRBool 
    1: nsHTMLEditRules::ListIsEmptyLine(nsCOMArray<nsIDOMNode> &arrayOfNodes)
    1: {
    1:   // we have a list of nodes which we are candidates for being moved
    1:   // into a new block.  Determine if it's anything more than a blank line.
    1:   // Look for editable content above and beyond one single BR.
    1:   PRInt32 listCount = arrayOfNodes.Count();
43806:   NS_ENSURE_TRUE(listCount, PR_TRUE);
    1:   nsCOMPtr<nsIDOMNode> somenode;
    1:   PRInt32 j, brCount=0;
    1:   for (j = 0; j < listCount; j++)
    1:   {
    1:     somenode = arrayOfNodes[j];
    1:     if (somenode && mHTMLEditor->IsEditable(somenode))
    1:     {
    1:       if (nsTextEditUtils::IsBreak(somenode))
    1:       {
    1:         // first break doesn't count
    1:         if (brCount) return PR_FALSE;
    1:         brCount++;
    1:       }
    1:       else if (IsEmptyInline(somenode)) 
    1:       {
    1:         // empty inline, keep looking
    1:       }
    1:       else return PR_FALSE;
    1:     }
    1:   }
    1:   return PR_TRUE;
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsHTMLEditRules::PopListItem(nsIDOMNode *aListItem, PRBool *aOutOfList)
    1: {
    1:   // check parms
43807:   NS_ENSURE_TRUE(aListItem && aOutOfList, NS_ERROR_NULL_POINTER);
    1:   
    1:   // init out params
    1:   *aOutOfList = PR_FALSE;
    1:   
    1:   nsCOMPtr<nsIDOMNode> curParent;
    1:   nsCOMPtr<nsIDOMNode> curNode( do_QueryInterface(aListItem));
    1:   PRInt32 offset;
    1:   nsresult res = nsEditor::GetNodeLocation(curNode, address_of(curParent), &offset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:     
    1:   if (!nsHTMLEditUtils::IsListItem(curNode))
    1:     return NS_ERROR_FAILURE;
    1:     
    1:   // if it's first or last list item, don't need to split the list
    1:   // otherwise we do.
    1:   nsCOMPtr<nsIDOMNode> curParPar;
    1:   PRInt32 parOffset;
    1:   res = nsEditor::GetNodeLocation(curParent, address_of(curParPar), &parOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   PRBool bIsFirstListItem;
    1:   res = mHTMLEditor->IsFirstEditableChild(curNode, &bIsFirstListItem);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   PRBool bIsLastListItem;
    1:   res = mHTMLEditor->IsLastEditableChild(curNode, &bIsLastListItem);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:     
    1:   if (!bIsFirstListItem && !bIsLastListItem)
    1:   {
    1:     // split the list
    1:     nsCOMPtr<nsIDOMNode> newBlock;
    1:     res = mHTMLEditor->SplitNode(curParent, offset, getter_AddRefs(newBlock));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   
    1:   if (!bIsFirstListItem) parOffset++;
    1:   
    1:   res = mHTMLEditor->MoveNode(curNode, curParPar, parOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:     
    1:   // unwrap list item contents if they are no longer in a list
    1:   if (!nsHTMLEditUtils::IsList(curParPar)
    1:       && nsHTMLEditUtils::IsListItem(curNode)) 
    1:   {
    1:     res = mHTMLEditor->RemoveBlockContainer(curNode);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     *aOutOfList = PR_TRUE;
    1:   }
    1:   return res;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditRules::RemoveListStructure(nsIDOMNode *aList)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aList);
    1: 
    1:   nsresult res;
    1: 
    1:   nsCOMPtr<nsIDOMNode> child;
    1:   aList->GetFirstChild(getter_AddRefs(child));
    1: 
    1:   while (child)
    1:   {
    1:     if (nsHTMLEditUtils::IsListItem(child))
    1:     {
    1:       PRBool bOutOfList;
    1:       do
    1:       {
    1:         res = PopListItem(child, &bOutOfList);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       } while (!bOutOfList);   // keep popping it out until it's not in a list anymore
    1:     }
    1:     else if (nsHTMLEditUtils::IsList(child))
    1:     {
    1:       res = RemoveListStructure(child);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     else
    1:     {
    1:       // delete any non- list items for now
    1:       res = mHTMLEditor->DeleteNode(child);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     aList->GetFirstChild(getter_AddRefs(child));
    1:   }
    1:   // delete the now-empty list
    1:   res = mHTMLEditor->RemoveBlockContainer(aList);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   return res;
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsHTMLEditRules::ConfirmSelectionInBody()
    1: {
    1:   nsresult res = NS_OK;
    1: 
    1:   // get the body  
    1:   nsIDOMElement *rootElement = mHTMLEditor->GetRoot();
43806:   NS_ENSURE_TRUE(rootElement, NS_ERROR_UNEXPECTED);
    1: 
    1:   // get the selection
    1:   nsCOMPtr<nsISelection>selection;
    1:   res = mHTMLEditor->GetSelection(getter_AddRefs(selection));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   // get the selection start location
    1:   nsCOMPtr<nsIDOMNode> selNode, temp, parent;
    1:   PRInt32 selOffset;
43518:   res = mHTMLEditor->GetStartNodeAndOffset(selection, getter_AddRefs(selNode), &selOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   temp = selNode;
    1:   
    1:   // check that selNode is inside body
    1:   while (temp && !nsTextEditUtils::IsBody(temp))
    1:   {
    1:     res = temp->GetParentNode(getter_AddRefs(parent));
    1:     temp = parent;
    1:   }
    1:   
    1:   // if we aren't in the body, force the issue
    1:   if (!temp) 
    1:   {
    1: //    uncomment this to see when we get bad selections
    1: //    NS_NOTREACHED("selection not in body");
    1:     selection->Collapse(rootElement, 0);
    1:   }
    1:   
    1:   // get the selection end location
43518:   res = mHTMLEditor->GetEndNodeAndOffset(selection, getter_AddRefs(selNode), &selOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   temp = selNode;
    1:   
    1:   // check that selNode is inside body
    1:   while (temp && !nsTextEditUtils::IsBody(temp))
    1:   {
    1:     res = temp->GetParentNode(getter_AddRefs(parent));
    1:     temp = parent;
    1:   }
    1:   
    1:   // if we aren't in the body, force the issue
    1:   if (!temp) 
    1:   {
    1: //    uncomment this to see when we get bad selections
    1: //    NS_NOTREACHED("selection not in body");
    1:     selection->Collapse(rootElement, 0);
    1:   }
    1:   
    1:   return res;
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsHTMLEditRules::UpdateDocChangeRange(nsIDOMRange *aRange)
    1: {
    1:   nsresult res = NS_OK;
    1: 
    1:   // first make sure aRange is in the document.  It might not be if
    1:   // portions of our editting action involved manipulating nodes
    1:   // prior to placing them in the document (e.g., populating a list item
    1:   // before placing it in it's list)
    1:   nsCOMPtr<nsIDOMNode> startNode;
    1:   res = aRange->GetStartContainer(getter_AddRefs(startNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (!mHTMLEditor->IsDescendantOfBody(startNode))
    1:   {
    1:     // just return - we don't need to adjust mDocChangeRange in this case
    1:     return NS_OK;
    1:   }
    1:   
    1:   if (!mDocChangeRange)
    1:   {
    1:     // clone aRange.  
    1:     res = aRange->CloneRange(getter_AddRefs(mDocChangeRange));
    1:     return res;
    1:   }
    1:   else
    1:   {
    1:     PRInt16 result;
    1:     
    1:     // compare starts of ranges
    1:     res = mDocChangeRange->CompareBoundaryPoints(nsIDOMRange::START_TO_START, aRange, &result);
    1:     if (res == NS_ERROR_NOT_INITIALIZED) {
    1:       // This will happen is mDocChangeRange is non-null, but the range is
    1:       // uninitialized. In this case we'll set the start to aRange start.
    1:       // The same test won't be needed further down since after we've set
    1:       // the start the range will be collapsed to that point.
    1:       result = 1;
    1:       res = NS_OK;
    1:     }
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (result > 0)  // positive result means mDocChangeRange start is after aRange start
    1:     {
    1:       PRInt32 startOffset;
    1:       res = aRange->GetStartOffset(&startOffset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = mDocChangeRange->SetStart(startNode, startOffset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     
    1:     // compare ends of ranges
    1:     res = mDocChangeRange->CompareBoundaryPoints(nsIDOMRange::END_TO_END, aRange, &result);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (result < 0)  // negative result means mDocChangeRange end is before aRange end
    1:     {
    1:       nsCOMPtr<nsIDOMNode> endNode;
    1:       PRInt32 endOffset;
    1:       res = aRange->GetEndContainer(getter_AddRefs(endNode));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = aRange->GetEndOffset(&endOffset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = mDocChangeRange->SetEnd(endNode, endOffset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: nsresult 
    1: nsHTMLEditRules::InsertMozBRIfNeeded(nsIDOMNode *aNode)
    1: {
43806:   NS_ENSURE_TRUE(aNode, NS_ERROR_NULL_POINTER);
    1:   if (!IsBlockNode(aNode)) return NS_OK;
    1:   
    1:   PRBool isEmpty;
    1:   nsCOMPtr<nsIDOMNode> brNode;
    1:   nsresult res = mHTMLEditor->IsEmptyNode(aNode, &isEmpty);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (isEmpty)
    1:   {
    1:     res = CreateMozBR(aNode, 0, address_of(brNode));
    1:   }
    1:   return res;
    1: }
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  nsIEditActionListener methods 
    1: #pragma mark -
    1: #endif
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditRules::WillCreateNode(const nsAString& aTag, nsIDOMNode *aParent, PRInt32 aPosition)
    1: {
    1:   return NS_OK;  
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditRules::DidCreateNode(const nsAString& aTag, 
    1:                                nsIDOMNode *aNode, 
    1:                                nsIDOMNode *aParent, 
    1:                                PRInt32 aPosition, 
    1:                                nsresult aResult)
    1: {
43806:   NS_ENSURE_TRUE(mListenerEnabled, NS_OK);
    1:   // assumption that Join keeps the righthand node
    1:   nsresult res = mUtilRange->SelectNode(aNode);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = UpdateDocChangeRange(mUtilRange);
    1:   return res;  
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditRules::WillInsertNode(nsIDOMNode *aNode, nsIDOMNode *aParent, PRInt32 aPosition)
    1: {
    1:   return NS_OK;  
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditRules::DidInsertNode(nsIDOMNode *aNode, 
    1:                                nsIDOMNode *aParent, 
    1:                                PRInt32 aPosition, 
    1:                                nsresult aResult)
    1: {
43806:   NS_ENSURE_TRUE(mListenerEnabled, NS_OK);
    1:   nsresult res = mUtilRange->SelectNode(aNode);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = UpdateDocChangeRange(mUtilRange);
    1:   return res;  
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditRules::WillDeleteNode(nsIDOMNode *aChild)
    1: {
43806:   NS_ENSURE_TRUE(mListenerEnabled, NS_OK);
    1:   nsresult res = mUtilRange->SelectNode(aChild);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = UpdateDocChangeRange(mUtilRange);
    1:   return res;  
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditRules::DidDeleteNode(nsIDOMNode *aChild, nsresult aResult)
    1: {
    1:   return NS_OK;  
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditRules::WillSplitNode(nsIDOMNode *aExistingRightNode, PRInt32 aOffset)
    1: {
    1:   return NS_OK;  
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditRules::DidSplitNode(nsIDOMNode *aExistingRightNode, 
    1:                               PRInt32 aOffset, 
    1:                               nsIDOMNode *aNewLeftNode, 
    1:                               nsresult aResult)
    1: {
43806:   NS_ENSURE_TRUE(mListenerEnabled, NS_OK);
    1:   nsresult res = mUtilRange->SetStart(aNewLeftNode, 0);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = mUtilRange->SetEnd(aExistingRightNode, 0);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = UpdateDocChangeRange(mUtilRange);
    1:   return res;  
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditRules::WillJoinNodes(nsIDOMNode *aLeftNode, nsIDOMNode *aRightNode, nsIDOMNode *aParent)
    1: {
43806:   NS_ENSURE_TRUE(mListenerEnabled, NS_OK);
    1:   // remember split point
    1:   nsresult res = nsEditor::GetLengthOfDOMNode(aLeftNode, mJoinOffset);
    1:   return res;  
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditRules::DidJoinNodes(nsIDOMNode  *aLeftNode, 
    1:                               nsIDOMNode *aRightNode, 
    1:                               nsIDOMNode *aParent, 
    1:                               nsresult aResult)
    1: {
43806:   NS_ENSURE_TRUE(mListenerEnabled, NS_OK);
    1:   // assumption that Join keeps the righthand node
    1:   nsresult res = mUtilRange->SetStart(aRightNode, mJoinOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = mUtilRange->SetEnd(aRightNode, mJoinOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = UpdateDocChangeRange(mUtilRange);
    1:   return res;  
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditRules::WillInsertText(nsIDOMCharacterData *aTextNode, PRInt32 aOffset, const nsAString &aString)
    1: {
    1:   return NS_OK;  
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditRules::DidInsertText(nsIDOMCharacterData *aTextNode, 
    1:                                   PRInt32 aOffset, 
    1:                                   const nsAString &aString, 
    1:                                   nsresult aResult)
    1: {
43806:   NS_ENSURE_TRUE(mListenerEnabled, NS_OK);
    1:   PRInt32 length = aString.Length();
    1:   nsCOMPtr<nsIDOMNode> theNode = do_QueryInterface(aTextNode);
    1:   nsresult res = mUtilRange->SetStart(theNode, aOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = mUtilRange->SetEnd(theNode, aOffset+length);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = UpdateDocChangeRange(mUtilRange);
    1:   return res;  
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditRules::WillDeleteText(nsIDOMCharacterData *aTextNode, PRInt32 aOffset, PRInt32 aLength)
    1: {
    1:   return NS_OK;  
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditRules::DidDeleteText(nsIDOMCharacterData *aTextNode, 
    1:                                   PRInt32 aOffset, 
    1:                                   PRInt32 aLength, 
    1:                                   nsresult aResult)
    1: {
43806:   NS_ENSURE_TRUE(mListenerEnabled, NS_OK);
    1:   nsCOMPtr<nsIDOMNode> theNode = do_QueryInterface(aTextNode);
    1:   nsresult res = mUtilRange->SetStart(theNode, aOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = mUtilRange->SetEnd(theNode, aOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = UpdateDocChangeRange(mUtilRange);
    1:   return res;  
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditRules::WillDeleteRange(nsIDOMRange *aRange)
    1: {
43806:   NS_ENSURE_TRUE(mListenerEnabled, NS_OK);
    1:   // get the (collapsed) selection location
    1:   return UpdateDocChangeRange(aRange);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditRules::DidDeleteRange(nsIDOMRange *aRange)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditRules::WillDeleteSelection(nsISelection *aSelection)
    1: {
43806:   NS_ENSURE_TRUE(mListenerEnabled, NS_OK);
    1:   // get the (collapsed) selection location
    1:   nsCOMPtr<nsIDOMNode> selNode;
    1:   PRInt32 selOffset;
    1: 
43518:   nsresult res = mHTMLEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(selNode), &selOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = mUtilRange->SetStart(selNode, selOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
43518:   res = mHTMLEditor->GetEndNodeAndOffset(aSelection, getter_AddRefs(selNode), &selOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = mUtilRange->SetEnd(selNode, selOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = UpdateDocChangeRange(mUtilRange);
    1:   return res;  
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditRules::DidDeleteSelection(nsISelection *aSelection)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: // Let's remove all alignment hints in the children of aNode; it can
    1: // be an ALIGN attribute (in case we just remove it) or a CENTER
    1: // element (here we have to remove the container and keep its
    1: // children). We break on tables and don't look at their children.
    1: nsresult
    1: nsHTMLEditRules::RemoveAlignment(nsIDOMNode * aNode, const nsAString & aAlignType, PRBool aChildrenOnly)
    1: {
43806:   NS_ENSURE_TRUE(aNode, NS_ERROR_NULL_POINTER);
    1: 
    1:   if (mHTMLEditor->IsTextNode(aNode) || nsHTMLEditUtils::IsTable(aNode)) return NS_OK;
    1:   nsresult res = NS_OK;
    1: 
    1:   nsCOMPtr<nsIDOMNode> child = aNode,tmp;
    1:   if (aChildrenOnly)
    1:   {
    1:     aNode->GetFirstChild(getter_AddRefs(child));
    1:   }
    1:   PRBool useCSS;
    1:   mHTMLEditor->GetIsCSSEnabled(&useCSS);
    1: 
    1:   while (child)
    1:   {
    1:     if (aChildrenOnly) {
    1:       // get the next sibling right now because we could have to remove child
    1:       child->GetNextSibling(getter_AddRefs(tmp));
    1:     }
    1:     else
    1:     {
    1:       tmp = nsnull;
    1:     }
    1:     PRBool isBlock;
    1:     res = mHTMLEditor->NodeIsBlockStatic(child, &isBlock);
43805:     NS_ENSURE_SUCCESS(res, res);
    1: 
    1:     if ((isBlock && !nsHTMLEditUtils::IsDiv(child)) || nsHTMLEditUtils::IsHR(child))
    1:     {
    1:       // the current node is a block element
    1:       nsCOMPtr<nsIDOMElement> curElem = do_QueryInterface(child);
    1:       if (nsHTMLEditUtils::SupportsAlignAttr(child))
    1:       {
    1:         // remove the ALIGN attribute if this element can have it
    1:         res = mHTMLEditor->RemoveAttribute(curElem, NS_LITERAL_STRING("align"));
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:       if (useCSS)
    1:       {
    1:         if (nsHTMLEditUtils::IsTable(child) || nsHTMLEditUtils::IsHR(child))
    1:         {
    1:           res = mHTMLEditor->SetAttributeOrEquivalent(curElem, NS_LITERAL_STRING("align"), aAlignType, PR_FALSE); 
    1:         }
    1:         else
    1:         {
    1:           nsAutoString dummyCssValue;
    1:           res = mHTMLEditor->mHTMLCSSUtils->RemoveCSSInlineStyle(child, nsEditProperty::cssTextAlign, dummyCssValue);
    1:         }
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:       if (!nsHTMLEditUtils::IsTable(child))
    1:       {
    1:         // unless this is a table, look at children
    1:         res = RemoveAlignment(child, aAlignType, PR_TRUE);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:     }
    1:     else if (nsEditor::NodeIsType(child, nsEditProperty::center)
    1:              || nsHTMLEditUtils::IsDiv(child))
    1:     {
    1:       // this is a CENTER or a DIV element and we have to remove it
    1:       // first remove children's alignment
    1:       res = RemoveAlignment(child, aAlignType, PR_TRUE);
43805:       NS_ENSURE_SUCCESS(res, res);
    1: 
    1:       if (useCSS && nsHTMLEditUtils::IsDiv(child))
    1:       {
    1:         // if we are in CSS mode and if the element is a DIV, let's remove it
    1:         // if it does not carry any style hint (style attr, class or ID)
    1:         nsAutoString dummyCssValue;
    1:         res = mHTMLEditor->mHTMLCSSUtils->RemoveCSSInlineStyle(child, nsEditProperty::cssTextAlign, dummyCssValue);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         nsCOMPtr<nsIDOMElement> childElt = do_QueryInterface(child);
    1:         PRBool hasStyleOrIdOrClass;
    1:         res = mHTMLEditor->HasStyleOrIdOrClass(childElt, &hasStyleOrIdOrClass);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         if (!hasStyleOrIdOrClass)
    1:         {
    1:           // we may have to insert BRs in first and last position of DIV's children
    1:           // if the nodes before/after are not blocks and not BRs
    1:           res = MakeSureElemStartsOrEndsOnCR(child);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           res = mHTMLEditor->RemoveContainer(child);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:         }
    1:       }
    1:       else
    1:       {
    1:         // we may have to insert BRs in first and last position of element's children
    1:         // if the nodes before/after are not blocks and not BRs
    1:         res = MakeSureElemStartsOrEndsOnCR(child);
43805:         NS_ENSURE_SUCCESS(res, res);
    1: 
    1:         // in HTML mode, let's remove the element
    1:         res = mHTMLEditor->RemoveContainer(child);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:     }
    1:     child = tmp;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // Let's insert a BR as first (resp. last) child of aNode if its
    1: // first (resp. last) child is not a block nor a BR, and if the
    1: // previous (resp. next) sibling is not a block nor a BR
    1: nsresult
    1: nsHTMLEditRules::MakeSureElemStartsOrEndsOnCR(nsIDOMNode *aNode, PRBool aStarts)
    1: {
43806:   NS_ENSURE_TRUE(aNode, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsCOMPtr<nsIDOMNode> child;
    1:   nsresult res;
    1:   if (aStarts)
    1:   {
    1:     res = mHTMLEditor->GetFirstEditableChild(aNode, address_of(child));
    1:   }
    1:   else
    1:   {
    1:     res = mHTMLEditor->GetLastEditableChild(aNode, address_of(child));
    1:   }
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(child, NS_OK);
    1:   PRBool isChildBlock;
    1:   res = mHTMLEditor->NodeIsBlockStatic(child, &isChildBlock);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   PRBool foundCR = PR_FALSE;
    1:   if (isChildBlock || nsTextEditUtils::IsBreak(child))
    1:   {
    1:     foundCR = PR_TRUE;
    1:   }
    1:   else
    1:   {
    1:     nsCOMPtr<nsIDOMNode> sibling;
    1:     if (aStarts)
    1:     {
    1:       res = mHTMLEditor->GetPriorHTMLSibling(aNode, address_of(sibling));
    1:     }
    1:     else
    1:     {
    1:       res = mHTMLEditor->GetNextHTMLSibling(aNode, address_of(sibling));
    1:     }
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (sibling)
    1:     {
    1:       PRBool isBlock;
    1:       res = mHTMLEditor->NodeIsBlockStatic(sibling, &isBlock);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       if (isBlock || nsTextEditUtils::IsBreak(sibling))
    1:       {
    1:         foundCR = PR_TRUE;
    1:       }
    1:     }
    1:     else
    1:     {
    1:       foundCR = PR_TRUE;
    1:     }
    1:   }
    1:   if (!foundCR)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> brNode;
    1:     PRInt32 offset = 0;
    1:     if (!aStarts)
    1:     {
    1:       nsCOMPtr<nsIDOMNodeList> childNodes;
    1:       res = aNode->GetChildNodes(getter_AddRefs(childNodes));
43805:       NS_ENSURE_SUCCESS(res, res);
43806:       NS_ENSURE_TRUE(childNodes, NS_ERROR_NULL_POINTER);
    1:       PRUint32 childCount;
    1:       res = childNodes->GetLength(&childCount);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       offset = childCount;
    1:     }
    1:     res = mHTMLEditor->CreateBR(aNode, offset, address_of(brNode));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditRules::MakeSureElemStartsOrEndsOnCR(nsIDOMNode *aNode)
    1: {
    1:   nsresult res = MakeSureElemStartsOrEndsOnCR(aNode, PR_FALSE);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = MakeSureElemStartsOrEndsOnCR(aNode, PR_TRUE);
    1:   return res;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditRules::AlignBlock(nsIDOMElement * aElement, const nsAString * aAlignType, PRBool aContentsOnly)
    1: {
43806:   NS_ENSURE_TRUE(aElement, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsCOMPtr<nsIDOMNode> node = do_QueryInterface(aElement);
    1:   PRBool isBlock = IsBlockNode(node);
    1:   if (!isBlock && !nsHTMLEditUtils::IsHR(node)) {
    1:     // we deal only with blocks; early way out
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsresult res = RemoveAlignment(node, *aAlignType, aContentsOnly);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   NS_NAMED_LITERAL_STRING(attr, "align");
    1:   PRBool useCSS;
    1:   mHTMLEditor->GetIsCSSEnabled(&useCSS);
    1:   if (useCSS) {
    1:     // let's use CSS alignment; we use margin-left and margin-right for tables
    1:     // and text-align for other block-level elements
    1:     res = mHTMLEditor->SetAttributeOrEquivalent(aElement, attr, *aAlignType, PR_FALSE); 
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   else {
    1:     // HTML case; this code is supposed to be called ONLY if the element
    1:     // supports the align attribute but we'll never know...
    1:     if (nsHTMLEditUtils::SupportsAlignAttr(node)) {
    1:       res = mHTMLEditor->SetAttribute(aElement, attr, *aAlignType);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditRules::RelativeChangeIndentationOfElementNode(nsIDOMNode *aNode, PRInt8 aRelativeChange)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aNode);
    1: 
    1:   if ( !( (aRelativeChange==1) || (aRelativeChange==-1) ) )
    1:     return NS_ERROR_ILLEGAL_VALUE;
    1: 
    1:   nsCOMPtr<nsIDOMElement> element = do_QueryInterface(aNode);
    1:   NS_ASSERTION(element, "not an element node");
    1: 
    1:   if (element) {
    1:     nsIAtom* marginProperty = MarginPropertyAtomForIndent(mHTMLEditor->mHTMLCSSUtils, element);    
    1:     nsAutoString value;
    1:     nsresult res;
    1:     mHTMLEditor->mHTMLCSSUtils->GetSpecifiedProperty(aNode, marginProperty, value);
    1:     float f;
    1:     nsIAtom * unit;
    1:     mHTMLEditor->mHTMLCSSUtils->ParseLength(value, &f, &unit);
    1:     if (0 == f) {
    1:       NS_IF_RELEASE(unit);
    1:       nsAutoString defaultLengthUnit;
    1:       mHTMLEditor->mHTMLCSSUtils->GetDefaultLengthUnit(defaultLengthUnit);
    1:       unit = NS_NewAtom(defaultLengthUnit);
    1:     }
    1:     nsAutoString unitString;
    1:     unit->ToString(unitString);
    1:     if      (nsEditProperty::cssInUnit == unit)
    1:               f += NS_EDITOR_INDENT_INCREMENT_IN * aRelativeChange;
    1:     else if (nsEditProperty::cssCmUnit == unit)
    1:               f += NS_EDITOR_INDENT_INCREMENT_CM * aRelativeChange;
    1:     else if (nsEditProperty::cssMmUnit == unit)
    1:               f += NS_EDITOR_INDENT_INCREMENT_MM * aRelativeChange;
    1:     else if (nsEditProperty::cssPtUnit == unit)
    1:               f += NS_EDITOR_INDENT_INCREMENT_PT * aRelativeChange;
    1:     else if (nsEditProperty::cssPcUnit == unit)
    1:               f += NS_EDITOR_INDENT_INCREMENT_PC * aRelativeChange;
    1:     else if (nsEditProperty::cssEmUnit == unit)
    1:               f += NS_EDITOR_INDENT_INCREMENT_EM * aRelativeChange;
    1:     else if (nsEditProperty::cssExUnit == unit)
    1:               f += NS_EDITOR_INDENT_INCREMENT_EX * aRelativeChange;
    1:     else if (nsEditProperty::cssPxUnit == unit)
    1:               f += NS_EDITOR_INDENT_INCREMENT_PX * aRelativeChange;
    1:     else if (nsEditProperty::cssPercentUnit == unit)
    1:               f += NS_EDITOR_INDENT_INCREMENT_PERCENT * aRelativeChange;    
    1: 
    1:     NS_IF_RELEASE(unit);
    1: 
    1:     if (0 < f) {
    1:       nsAutoString newValue;
    1:       newValue.AppendFloat(f);
    1:       newValue.Append(unitString);
    1:       mHTMLEditor->mHTMLCSSUtils->SetCSSProperty(element, marginProperty, newValue, PR_FALSE);
    1:     }
    1:     else {
    1:       mHTMLEditor->mHTMLCSSUtils->RemoveCSSProperty(element, marginProperty, value, PR_FALSE);
    1:       if (nsHTMLEditUtils::IsDiv(aNode)) {
    1:         // we deal with a DIV ; let's see if it is useless and if we can remove it
    1:         nsCOMPtr<nsIDOMNamedNodeMap> attributeList;
    1:         res = element->GetAttributes(getter_AddRefs(attributeList));
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         PRUint32 count;
    1:         attributeList->GetLength(&count);
    1:         if (!count) {
    1:           // the DIV has no attribute at all, let's remove it
    1:           res = mHTMLEditor->RemoveContainer(element);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:         }
    1:         else if (1 == count) {
    1:           nsCOMPtr<nsIDOMNode> styleAttributeNode;
    1:           res = attributeList->GetNamedItem(NS_LITERAL_STRING("style"), 
    1:                                             getter_AddRefs(styleAttributeNode));
    1:           if (!styleAttributeNode) {
    1:             res = mHTMLEditor->RemoveContainer(element);
43805:             NS_ENSURE_SUCCESS(res, res);
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: //
    1: // Support for Absolute Positioning
    1: //
    1: 
    1: nsresult
    1: nsHTMLEditRules::WillAbsolutePosition(nsISelection *aSelection, PRBool *aCancel, PRBool * aHandled)
    1: {
    1:   if (!aSelection || !aCancel || !aHandled) { return NS_ERROR_NULL_POINTER; }
    1:   nsresult res = WillInsert(aSelection, aCancel);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // initialize out param
    1:   // we want to ignore result of WillInsert()
    1:   *aCancel = PR_FALSE;
    1:   *aHandled = PR_TRUE;
    1:   
    1:   nsCOMPtr<nsIDOMElement> focusElement;
    1:   res = mHTMLEditor->GetSelectionContainer(getter_AddRefs(focusElement));
    1:   if (focusElement) {
    1:     nsCOMPtr<nsIDOMNode> node = do_QueryInterface(focusElement);
    1:     if (nsHTMLEditUtils::IsImage(node)) {
    1:       mNewBlock = node;
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   res = NormalizeSelection(aSelection);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   nsAutoSelectionReset selectionResetter(aSelection, mHTMLEditor);
    1:   
    1:   // convert the selection ranges into "promoted" selection ranges:
    1:   // this basically just expands the range to include the immediate
    1:   // block parent, and then further expands to include any ancestors
    1:   // whose children are all in the range
    1:   
    1:   nsCOMArray<nsIDOMRange> arrayOfRanges;
    1:   res = GetPromotedRanges(aSelection, arrayOfRanges, kSetAbsolutePosition);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   // use these ranges to contruct a list of nodes to act on.
    1:   nsCOMArray<nsIDOMNode> arrayOfNodes;
    1:   res = GetNodesForOperation(arrayOfRanges, arrayOfNodes, kSetAbsolutePosition);
43805:   NS_ENSURE_SUCCESS(res, res);                                 
    1:                                      
    1:   NS_NAMED_LITERAL_STRING(divType, "div");
    1: 
    1: 
    1:   // if nothing visible in list, make an empty block
    1:   if (ListIsEmptyLine(arrayOfNodes))
    1:   {
    1:     nsCOMPtr<nsIDOMNode> parent, thePositionedDiv;
    1:     PRInt32 offset;
    1:     
    1:     // get selection location
43518:     res = mHTMLEditor->GetStartNodeAndOffset(aSelection, getter_AddRefs(parent), &offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     // make sure we can put a block here
    1:     res = SplitAsNeeded(&divType, address_of(parent), &offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     res = mHTMLEditor->CreateNode(divType, parent, offset, getter_AddRefs(thePositionedDiv));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     // remember our new block for postprocessing
    1:     mNewBlock = thePositionedDiv;
    1:     // delete anything that was in the list of nodes
    1:     for (PRInt32 j = arrayOfNodes.Count() - 1; j >= 0; --j) 
    1:     {
    1:       nsCOMPtr<nsIDOMNode> curNode = arrayOfNodes[0];
    1:       res = mHTMLEditor->DeleteNode(curNode);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = arrayOfNodes.RemoveObjectAt(0);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     // put selection in new block
    1:     res = aSelection->Collapse(thePositionedDiv,0);
    1:     selectionResetter.Abort();  // to prevent selection reseter from overriding us.
    1:     *aHandled = PR_TRUE;
    1:     return res;
    1:   }
    1: 
    1:   // Ok, now go through all the nodes and put them in a blockquote, 
    1:   // or whatever is appropriate.  Wohoo!
    1:   PRInt32 i;
    1:   nsCOMPtr<nsIDOMNode> curParent, curPositionedDiv, curList, indentedLI, sibling;
    1:   PRInt32 listCount = arrayOfNodes.Count();
    1:   for (i=0; i<listCount; i++)
    1:   {
    1:     // here's where we actually figure out what to do
    1:     nsCOMPtr<nsIDOMNode> curNode = arrayOfNodes[i];
    1: 
    1:     // Ignore all non-editable nodes.  Leave them be.
    1:     if (!mHTMLEditor->IsEditable(curNode)) continue;
    1: 
    1:     PRInt32 offset;
    1:     res = nsEditor::GetNodeLocation(curNode, address_of(curParent), &offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:      
    1:     // some logic for putting list items into nested lists...
    1:     if (nsHTMLEditUtils::IsList(curParent))
    1:     {
    1:       // check to see if curList is still appropriate.  Which it is if
    1:       // curNode is still right after it in the same list.
    1:       if (curList)
    1:       {
    1:         sibling = nsnull;
    1:         mHTMLEditor->GetPriorHTMLSibling(curNode, address_of(sibling));
    1:       }
    1:       
    1:       if (!curList || (sibling && sibling != curList) )
    1:       {
    1:         nsAutoString listTag;
    1:         nsEditor::GetTagString(curParent,listTag);
    1:         ToLowerCase(listTag);
    1:         // create a new nested list of correct type
    1:         res = SplitAsNeeded(&listTag, address_of(curParent), &offset);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         if (!curPositionedDiv) {
    1:           PRInt32 parentOffset;
    1:           nsCOMPtr<nsIDOMNode> curParentParent;
    1:           res = nsEditor::GetNodeLocation(curParent, address_of(curParentParent), &parentOffset);
    1:           res = mHTMLEditor->CreateNode(divType, curParentParent, parentOffset, getter_AddRefs(curPositionedDiv));
    1:           mNewBlock = curPositionedDiv;
    1:         }
    1:         res = mHTMLEditor->CreateNode(listTag, curPositionedDiv, -1, getter_AddRefs(curList));
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         // curList is now the correct thing to put curNode in
    1:         // remember our new block for postprocessing
    1:         // mNewBlock = curList;
    1:       }
    1:       // tuck the node into the end of the active list
    1:       res = mHTMLEditor->MoveNode(curNode, curList, -1);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       // forget curPositionedDiv, if any
    1:       // curPositionedDiv = nsnull;
    1:     }
    1:     
    1:     else // not a list item, use blockquote?
    1:     {
    1:       // if we are inside a list item, we don't want to blockquote, we want
    1:       // to sublist the list item.  We may have several nodes listed in the
    1:       // array of nodes to act on, that are in the same list item.  Since
    1:       // we only want to indent that li once, we must keep track of the most
    1:       // recent indented list item, and not indent it if we find another node
    1:       // to act on that is still inside the same li.
    1:       nsCOMPtr<nsIDOMNode> listitem=IsInListItem(curNode);
    1:       if (listitem)
    1:       {
    1:         if (indentedLI == listitem) continue;  // already indented this list item
    1:         res = nsEditor::GetNodeLocation(listitem, address_of(curParent), &offset);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         // check to see if curList is still appropriate.  Which it is if
    1:         // curNode is still right after it in the same list.
    1:         if (curList)
    1:         {
    1:           sibling = nsnull;
    1:           mHTMLEditor->GetPriorHTMLSibling(curNode, address_of(sibling));
    1:         }
    1:          
    1:         if (!curList || (sibling && sibling != curList) )
    1:         {
    1:           nsAutoString listTag;
    1:           nsEditor::GetTagString(curParent,listTag);
    1:           ToLowerCase(listTag);
    1:           // create a new nested list of correct type
    1:           res = SplitAsNeeded(&listTag, address_of(curParent), &offset);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           if (!curPositionedDiv) {
    1:           PRInt32 parentOffset;
    1:           nsCOMPtr<nsIDOMNode> curParentParent;
    1:           res = nsEditor::GetNodeLocation(curParent, address_of(curParentParent), &parentOffset);
    1:           res = mHTMLEditor->CreateNode(divType, curParentParent, parentOffset, getter_AddRefs(curPositionedDiv));
    1:             mNewBlock = curPositionedDiv;
    1:           }
    1:           res = mHTMLEditor->CreateNode(listTag, curPositionedDiv, -1, getter_AddRefs(curList));
43805:           NS_ENSURE_SUCCESS(res, res);
    1:         }
    1:         res = mHTMLEditor->MoveNode(listitem, curList, -1);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         // remember we indented this li
    1:         indentedLI = listitem;
    1:       }
    1:       
    1:       else
    1:       {
    1:         // need to make a div to put things in if we haven't already
    1: 
    1:         if (!curPositionedDiv) 
    1:         {
    1:           if (nsHTMLEditUtils::IsDiv(curNode))
    1:           {
    1:             curPositionedDiv = curNode;
    1:             mNewBlock = curPositionedDiv;
    1:             curList = nsnull;
    1:             continue;
    1:           }
    1:           res = SplitAsNeeded(&divType, address_of(curParent), &offset);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           res = mHTMLEditor->CreateNode(divType, curParent, offset, getter_AddRefs(curPositionedDiv));
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           // remember our new block for postprocessing
    1:           mNewBlock = curPositionedDiv;
    1:           // curPositionedDiv is now the correct thing to put curNode in
    1:         }
    1:           
    1:         // tuck the node into the end of the active blockquote
    1:         res = mHTMLEditor->MoveNode(curNode, curPositionedDiv, -1);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         // forget curList, if any
    1:         curList = nsnull;
    1:       }
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditRules::DidAbsolutePosition()
    1: {
    1:   nsCOMPtr<nsIHTMLAbsPosEditor> absPosHTMLEditor = mHTMLEditor;
    1:   nsCOMPtr<nsIDOMElement> elt = do_QueryInterface(mNewBlock);
    1:   return absPosHTMLEditor->AbsolutelyPositionElement(elt, PR_TRUE);
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditRules::WillRemoveAbsolutePosition(nsISelection *aSelection, PRBool *aCancel, PRBool * aHandled)
    1: {
    1:   if (!aSelection || !aCancel || !aHandled) { return NS_ERROR_NULL_POINTER; }
    1:   nsresult res = WillInsert(aSelection, aCancel);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // initialize out param
    1:   // we want to ignore aCancel from WillInsert()
    1:   *aCancel = PR_FALSE;
    1:   *aHandled = PR_TRUE;
    1: 
    1:   nsCOMPtr<nsIDOMElement>  elt;
    1:   res = mHTMLEditor->GetAbsolutelyPositionedSelectionContainer(getter_AddRefs(elt));
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   nsAutoSelectionReset selectionResetter(aSelection, mHTMLEditor);
    1: 
    1:   nsCOMPtr<nsIHTMLAbsPosEditor> absPosHTMLEditor = mHTMLEditor;
    1:   return absPosHTMLEditor->AbsolutelyPositionElement(elt, PR_FALSE);
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditRules::WillRelativeChangeZIndex(nsISelection *aSelection,
    1:                                           PRInt32 aChange,
    1:                                           PRBool *aCancel,
    1:                                           PRBool * aHandled)
    1: {
    1:   if (!aSelection || !aCancel || !aHandled) { return NS_ERROR_NULL_POINTER; }
    1:   nsresult res = WillInsert(aSelection, aCancel);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // initialize out param
    1:   // we want to ignore aCancel from WillInsert()
    1:   *aCancel = PR_FALSE;
    1:   *aHandled = PR_TRUE;
    1: 
    1:   nsCOMPtr<nsIDOMElement>  elt;
    1:   res = mHTMLEditor->GetAbsolutelyPositionedSelectionContainer(getter_AddRefs(elt));
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   nsAutoSelectionReset selectionResetter(aSelection, mHTMLEditor);
    1: 
    1:   nsCOMPtr<nsIHTMLAbsPosEditor> absPosHTMLEditor = mHTMLEditor;
    1:   PRInt32 zIndex;
    1:   return absPosHTMLEditor->RelativeChangeElementZIndex(elt, aChange, &zIndex);
    1: }
57481: 
57481: NS_IMETHODIMP
57481: nsHTMLEditRules::DocumentModified()
57481: {
57481:   nsContentUtils::AddScriptRunner(NS_NewRunnableMethod(this, &nsHTMLEditRules::DocumentModifiedWorker));
57481:   return NS_OK;
57481: }
57481: 
57481: void
57481: nsHTMLEditRules::DocumentModifiedWorker()
57481: {
57960:   nsCOMPtr<nsIHTMLEditor> kungFuDeathGrip(mHTMLEditor);
57960: 
57481:   nsCOMPtr<nsISelection> selection;
57481:   nsresult res = mHTMLEditor->GetSelection(getter_AddRefs(selection));
57481:   NS_ENSURE_SUCCESS(res, );
57481: 
57481:   // Delete our bogus node, if we have one, since the document might not be
57481:   // empty any more.
57481:   if (mBogusNode) {
57481:     mEditor->DeleteNode(mBogusNode);
57481:     mBogusNode = nsnull;
57481:   }
57481: 
57481:   // Try to recreate the bogus node if needed.
57481:   CreateBogusNodeIfNeeded(selection);
57481: }
