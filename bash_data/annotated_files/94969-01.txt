  314: /* -*- Mode: c; c-basic-offset: 4; indent-tabs-mode: t; tab-width: 8; -*- */
    1: /* cairo - a vector graphics library with display and print output
    1:  *
10414:  * Copyright ï¿½ 2006, 2007 Mozilla Corporation
    1:  *
    1:  * This library is free software; you can redistribute it and/or
    1:  * modify it either under the terms of the GNU Lesser General Public
    1:  * License version 2.1 as published by the Free Software Foundation
    1:  * (the "LGPL") or, at your option, under the terms of the Mozilla
    1:  * Public License Version 1.1 (the "MPL"). If you do not alter this
    1:  * notice, a recipient may use your version of this file under either
    1:  * the MPL or the LGPL.
    1:  *
    1:  * You should have received a copy of the LGPL along with this library
    1:  * in the file COPYING-LGPL-2.1; if not, write to the Free Software
70960:  * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA 02110-1335, USA
    1:  * You should have received a copy of the MPL along with this library
    1:  * in the file COPYING-MPL-1.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License
    1:  * Version 1.1 (the "License"); you may not use this file except in
    1:  * compliance with the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
    1:  * OF ANY KIND, either express or implied. See the LGPL or the MPL for
    1:  * the specific language governing rights and limitations.
    1:  *
    1:  * The Original Code is the cairo graphics library.
    1:  *
36532:  * The Initial Developer of the Original Code is Mozilla Foundation.
    1:  *
    1:  * Contributor(s):
  314:  *	Vladimir Vukicevic <vladimir@mozilla.com>
    1:  */
    1: 
26419: #define _GNU_SOURCE /* required for RTLD_DEFAULT */
    1: #include "cairoint.h"
  314: 
    1: #include "cairo-quartz-private.h"
70960: 
70960: #include "cairo-error-private.h"
41340: #include "cairo-surface-clipper-private.h"
41340: #include "cairo-gstate-private.h"
41340: #include "cairo-private.h"
    1: 
12588: #include <dlfcn.h>
12588: 
26419: #ifndef RTLD_DEFAULT
26419: #define RTLD_DEFAULT ((void *) 0)
26419: #endif
26419: 
 7123: #include <limits.h>
 4133: 
  314: #undef QUARTZ_DEBUG
  314: 
  314: #ifdef QUARTZ_DEBUG
  314: #define ND(_x)	fprintf _x
  314: #else
  314: #define ND(_x)	do {} while(0)
  314: #endif
  314: 
10414: #define IS_EMPTY(s) ((s)->extents.width == 0 || (s)->extents.height == 0)
10414: 
70960: /**
70960:  * SECTION:cairo-quartz
70960:  * @Title: Quartz Surfaces
70960:  * @Short_Description: Rendering to Quartz surfaces
70960:  * @See_Also: #cairo_surface_t
70960:  *
70960:  * The Quartz surface is used to render cairo graphics targeting the
70960:  * Apple OS X Quartz rendering system.
70960:  */
70960: 
70960: /**
70960:  * CAIRO_HAS_QUARTZ_SURFACE:
70960:  *
70960:  * Defined if the Quartz surface backend is available.
70960:  * This macro can be used to conditionally compile backend-specific code.
70960:  */
70960: 
41340: /* Here are some of the differences between cairo and CoreGraphics
41340:    - cairo has only a single source active at once vs. CoreGraphics having
41340:      separate sources for stroke and fill
41340: */
41340: 
  314: /* This method is private, but it exists.  Its params are are exposed
  314:  * as args to the NS* method, but not as CG.
  314:  */
  314: enum PrivateCGCompositeMode {
  314:     kPrivateCGCompositeClear		= 0,
  314:     kPrivateCGCompositeCopy		= 1,
  314:     kPrivateCGCompositeSourceOver	= 2,
  314:     kPrivateCGCompositeSourceIn		= 3,
  314:     kPrivateCGCompositeSourceOut	= 4,
  314:     kPrivateCGCompositeSourceAtop	= 5,
  314:     kPrivateCGCompositeDestinationOver	= 6,
  314:     kPrivateCGCompositeDestinationIn	= 7,
  314:     kPrivateCGCompositeDestinationOut	= 8,
  314:     kPrivateCGCompositeDestinationAtop	= 9,
  314:     kPrivateCGCompositeXOR		= 10,
  314:     kPrivateCGCompositePlusDarker	= 11, // (max (0, (1-d) + (1-s)))
  314:     kPrivateCGCompositePlusLighter	= 12, // (min (1, s + d))
  314: };
  314: typedef enum PrivateCGCompositeMode PrivateCGCompositeMode;
  314: CG_EXTERN void CGContextSetCompositeOperation (CGContextRef, PrivateCGCompositeMode);
  314: CG_EXTERN void CGContextSetCTM (CGContextRef, CGAffineTransform);
  314: 
  314: /* We need to work with the 10.3 SDK as well (and 10.3 machines; luckily, 10.3.9
  314:  * has all the stuff we care about, just some of it isn't exported in the SDK.
  314:  */
  314: #ifndef kCGBitmapByteOrder32Host
  314: #define USE_10_3_WORKAROUNDS
  314: #define kCGBitmapAlphaInfoMask 0x1F
  314: #define kCGBitmapByteOrderMask 0x7000
  314: #define kCGBitmapByteOrder32Host 0
  314: 
  314: typedef uint32_t CGBitmapInfo;
  314: 
  314: /* public in 10.4, present in 10.3.9 */
  314: CG_EXTERN void CGContextReplacePathWithStrokedPath (CGContextRef);
  314: CG_EXTERN CGImageRef CGBitmapContextCreateImage (CGContextRef);
  314: #endif
  314: 
13979: /* Some of these are present in earlier versions of the OS than where
70960:  * they are public; others are not public at all (CGContextCopyPath,
70960:  * CGContextReplacePathWithClipPath, many of the getters, etc.)
13979:  */
10415: static void (*CGContextClipToMaskPtr) (CGContextRef, CGRect, CGImageRef) = NULL;
10415: static void (*CGContextDrawTiledImagePtr) (CGContextRef, CGRect, CGImageRef) = NULL;
12588: static unsigned int (*CGContextGetTypePtr) (CGContextRef) = NULL;
13107: static void (*CGContextSetShouldAntialiasFontsPtr) (CGContextRef, bool) = NULL;
13107: static void (*CGContextSetAllowsFontSmoothingPtr) (CGContextRef, bool) = NULL;
13107: static bool (*CGContextGetAllowsFontSmoothingPtr) (CGContextRef) = NULL;
70960: static CGPathRef (*CGContextCopyPathPtr) (CGContextRef) = NULL;
57384: static CGFloat (*CGContextGetAlphaPtr) (CGContextRef) = NULL;
  314: 
94969: static SInt32 _cairo_quartz_osx_version = 0x0;
94969: 
10415: static cairo_bool_t _cairo_quartz_symbol_lookup_done = FALSE;
10414: 
  314: /*
  314:  * Utility functions
  314:  */
  314: 
13107: #ifdef QUARTZ_DEBUG
  314: static void quartz_surface_to_png (cairo_quartz_surface_t *nq, char *dest);
  314: static void quartz_image_to_png (CGImageRef, char *dest);
13107: #endif
  314: 
10414: static cairo_quartz_surface_t *
10414: _cairo_quartz_surface_create_internal (CGContextRef cgContext,
10414: 				       cairo_content_t content,
10414: 				       unsigned int width,
10414: 				       unsigned int height);
10414: 
70960: static cairo_bool_t
70960: _cairo_surface_is_quartz (const cairo_surface_t *surface);
70960: 
10415: /* Load all extra symbols */
10694: static void quartz_ensure_symbols(void)
10415: {
10415:     if (_cairo_quartz_symbol_lookup_done)
10415: 	return;
10415: 
10415:     CGContextClipToMaskPtr = dlsym(RTLD_DEFAULT, "CGContextClipToMask");
10415:     CGContextDrawTiledImagePtr = dlsym(RTLD_DEFAULT, "CGContextDrawTiledImage");
13107:     CGContextGetTypePtr = dlsym(RTLD_DEFAULT, "CGContextGetType");
13107:     CGContextSetShouldAntialiasFontsPtr = dlsym(RTLD_DEFAULT, "CGContextSetShouldAntialiasFonts");
70960:     CGContextCopyPathPtr = dlsym(RTLD_DEFAULT, "CGContextCopyPath");
13107:     CGContextGetAllowsFontSmoothingPtr = dlsym(RTLD_DEFAULT, "CGContextGetAllowsFontSmoothing");
13107:     CGContextSetAllowsFontSmoothingPtr = dlsym(RTLD_DEFAULT, "CGContextSetAllowsFontSmoothing");
57384:     CGContextGetAlphaPtr = dlsym(RTLD_DEFAULT, "CGContextGetAlpha");
10415: 
94969:     if (Gestalt(gestaltSystemVersion, &_cairo_quartz_osx_version) != noErr) {
94969:         // assume 10.5
94969:         _cairo_quartz_osx_version = 0x1050;
94969:     }
94969: 
10415:     _cairo_quartz_symbol_lookup_done = TRUE;
10415: }
10415: 
21379: CGImageRef
21379: _cairo_quartz_create_cgimage (cairo_format_t format,
21379: 			      unsigned int width,
21379: 			      unsigned int height,
21379: 			      unsigned int stride,
21379: 			      void *data,
21379: 			      cairo_bool_t interpolate,
21379: 			      CGColorSpaceRef colorSpaceOverride,
21379: 			      CGDataProviderReleaseDataCallback releaseCallback,
21379: 			      void *releaseInfo)
21379: {
21379:     CGImageRef image = NULL;
21379:     CGDataProviderRef dataProvider = NULL;
21379:     CGColorSpaceRef colorSpace = colorSpaceOverride;
70960:     CGBitmapInfo bitinfo = kCGBitmapByteOrder32Host;
21379:     int bitsPerComponent, bitsPerPixel;
21379: 
21379:     switch (format) {
21379: 	case CAIRO_FORMAT_ARGB32:
21379: 	    if (colorSpace == NULL)
21379: 		colorSpace = CGColorSpaceCreateDeviceRGB();
70960: 	    bitinfo |= kCGImageAlphaPremultipliedFirst;
21379: 	    bitsPerComponent = 8;
21379: 	    bitsPerPixel = 32;
21379: 	    break;
21379: 
21379: 	case CAIRO_FORMAT_RGB24:
21379: 	    if (colorSpace == NULL)
21379: 		colorSpace = CGColorSpaceCreateDeviceRGB();
70960: 	    bitinfo |= kCGImageAlphaNoneSkipFirst;
21379: 	    bitsPerComponent = 8;
21379: 	    bitsPerPixel = 32;
21379: 	    break;
21379: 
21379: 	case CAIRO_FORMAT_A8:
21379: 	    bitsPerComponent = 8;
21379: 	    bitsPerPixel = 8;
21379: 	    break;
21379: 
21379: 	case CAIRO_FORMAT_A1:
70960: #ifdef WORDS_BIGENDIAN
41340: 	    bitsPerComponent = 1;
41340: 	    bitsPerPixel = 1;
41340: 	    break;
70960: #endif
70960: 
70960:         case CAIRO_FORMAT_RGB16_565:
70960:         case CAIRO_FORMAT_INVALID:
21379: 	default:
21379: 	    return NULL;
21379:     }
21379: 
21379:     dataProvider = CGDataProviderCreateWithData (releaseInfo,
21379: 						 data,
21379: 						 height * stride,
21379: 						 releaseCallback);
21379: 
21379:     if (!dataProvider) {
21379: 	// manually release
21379: 	if (releaseCallback)
21379: 	    releaseCallback (releaseInfo, data, height * stride);
21379: 	goto FINISH;
21379:     }
21379: 
41340:     if (format == CAIRO_FORMAT_A8 || format == CAIRO_FORMAT_A1) {
70960: 	cairo_quartz_float_t decode[] = {1.0, 0.0};
41340: 	image = CGImageMaskCreate (width, height,
41340: 				   bitsPerComponent,
41340: 				   bitsPerPixel,
41340: 				   stride,
41340: 				   dataProvider,
41340: 				   decode,
41340: 				   interpolate);
41340:     } else
21379: 	image = CGImageCreate (width, height,
21379: 			       bitsPerComponent,
21379: 			       bitsPerPixel,
21379: 			       stride,
21379: 			       colorSpace,
21379: 			       bitinfo,
21379: 			       dataProvider,
21379: 			       NULL,
21379: 			       interpolate,
21379: 			       kCGRenderingIntentDefault);
21379: 
21379: FINISH:
21379: 
21379:     CGDataProviderRelease (dataProvider);
21379: 
21379:     if (colorSpace != colorSpaceOverride)
21379: 	CGColorSpaceRelease (colorSpace);
21379: 
21379:     return image;
21379: }
21379: 
12588: static inline cairo_bool_t
12588: _cairo_quartz_is_cgcontext_bitmap_context (CGContextRef cgc) {
13264:     if (cgc == NULL)
13264: 	return FALSE;
13264: 
12588:     if (CGContextGetTypePtr) {
12588: 	/* 4 is the type value of a bitmap context */
12588: 	if (CGContextGetTypePtr(cgc) == 4)
12588: 	    return TRUE;
12588: 	return FALSE;
12588:     }
12588: 
12588:     /* This will cause a (harmless) warning to be printed if called on a non-bitmap context */
12589:     return CGBitmapContextGetBitsPerPixel(cgc) != 0;
12588: }
12588: 
 7123: /* CoreGraphics limitation with flipped CTM surfaces: height must be less than signed 16-bit max */
 7123: 
 7123: #define CG_MAX_HEIGHT   SHRT_MAX
 7123: #define CG_MAX_WIDTH    USHRT_MAX
 7123: 
 7123: /* is the desired size of the surface within bounds? */
11244: cairo_bool_t
11244: _cairo_quartz_verify_surface_size(int width, int height)
 7123: {
 7123:     /* hmmm, allow width, height == 0 ? */
 7123:     if (width < 0 || height < 0) {
 7123: 	return FALSE;
 7123:     }
 7123: 
 7123:     if (width > CG_MAX_WIDTH || height > CG_MAX_HEIGHT) {
 7123: 	return FALSE;
 7123:     }
 7123: 
 7123:     return TRUE;
 7123: }
 7123: 
  314: /*
  314:  * Cairo path -> Quartz path conversion helpers
  314:  */
  314: 
  314: /* cairo path -> execute in context */
  314: static cairo_status_t
26419: _cairo_path_to_quartz_context_move_to (void *closure,
26419: 				       const cairo_point_t *point)
  314: {
  314:     //ND((stderr, "moveto: %f %f\n", _cairo_fixed_to_double(point->x), _cairo_fixed_to_double(point->y)));
 4133:     double x = _cairo_fixed_to_double (point->x);
 4133:     double y = _cairo_fixed_to_double (point->y);
 4133: 
70960:     CGContextMoveToPoint (closure, x, y);
  314:     return CAIRO_STATUS_SUCCESS;
  314: }
  314: 
  314: static cairo_status_t
26419: _cairo_path_to_quartz_context_line_to (void *closure,
26419: 				       const cairo_point_t *point)
  314: {
  314:     //ND((stderr, "lineto: %f %f\n",  _cairo_fixed_to_double(point->x), _cairo_fixed_to_double(point->y)));
 4133:     double x = _cairo_fixed_to_double (point->x);
 4133:     double y = _cairo_fixed_to_double (point->y);
 4133: 
70960:     CGContextAddLineToPoint (closure, x, y);
  314:     return CAIRO_STATUS_SUCCESS;
  314: }
  314: 
  314: static cairo_status_t
26419: _cairo_path_to_quartz_context_curve_to (void *closure,
26419: 					const cairo_point_t *p0,
26419: 					const cairo_point_t *p1,
26419: 					const cairo_point_t *p2)
  314: {
  314:     //ND( (stderr, "curveto: %f,%f %f,%f %f,%f\n",
  314:     //		   _cairo_fixed_to_double(p0->x), _cairo_fixed_to_double(p0->y),
  314:     //		   _cairo_fixed_to_double(p1->x), _cairo_fixed_to_double(p1->y),
  314:     //		   _cairo_fixed_to_double(p2->x), _cairo_fixed_to_double(p2->y)));
 4133:     double x0 = _cairo_fixed_to_double (p0->x);
 4133:     double y0 = _cairo_fixed_to_double (p0->y);
 4133:     double x1 = _cairo_fixed_to_double (p1->x);
 4133:     double y1 = _cairo_fixed_to_double (p1->y);
 4133:     double x2 = _cairo_fixed_to_double (p2->x);
 4133:     double y2 = _cairo_fixed_to_double (p2->y);
  314: 
70960:     CGContextAddCurveToPoint (closure,
 4133: 			      x0, y0, x1, y1, x2, y2);
  314:     return CAIRO_STATUS_SUCCESS;
  314: }
  314: 
  314: static cairo_status_t
  314: _cairo_path_to_quartz_context_close_path (void *closure)
  314: {
  314:     //ND((stderr, "closepath\n"));
70960:     CGContextClosePath (closure);
  314:     return CAIRO_STATUS_SUCCESS;
  314: }
  314: 
70960: static void
  314: _cairo_quartz_cairo_path_to_quartz_context (cairo_path_fixed_t *path,
70960: 					    CGContextRef closure)
  314: {
70960:     cairo_status_t status;
70960: 
70960:     CGContextBeginPath (closure);
70960:     status = _cairo_path_fixed_interpret (path,
  314: 					  CAIRO_DIRECTION_FORWARD,
  314: 					  _cairo_path_to_quartz_context_move_to,
  314: 					  _cairo_path_to_quartz_context_line_to,
  314: 					  _cairo_path_to_quartz_context_curve_to,
  314: 					  _cairo_path_to_quartz_context_close_path,
70960: 					  closure);
70960: 
70960:     assert (status == CAIRO_STATUS_SUCCESS);
  314: }
  314: 
  314: /*
  314:  * Misc helpers/callbacks
  314:  */
  314: 
  314: static PrivateCGCompositeMode
41340: _cairo_quartz_cairo_operator_to_quartz_composite (cairo_operator_t op)
  314: {
  314:     switch (op) {
  314: 	case CAIRO_OPERATOR_CLEAR:
  314: 	    return kPrivateCGCompositeClear;
  314: 	case CAIRO_OPERATOR_SOURCE:
  314: 	    return kPrivateCGCompositeCopy;
  314: 	case CAIRO_OPERATOR_OVER:
  314: 	    return kPrivateCGCompositeSourceOver;
  314: 	case CAIRO_OPERATOR_IN:
  314: 	    return kPrivateCGCompositeSourceIn;
  314: 	case CAIRO_OPERATOR_OUT:
  314: 	    return kPrivateCGCompositeSourceOut;
  314: 	case CAIRO_OPERATOR_ATOP:
  314: 	    return kPrivateCGCompositeSourceAtop;
  314: 	case CAIRO_OPERATOR_DEST_OVER:
  314: 	    return kPrivateCGCompositeDestinationOver;
  314: 	case CAIRO_OPERATOR_DEST_IN:
  314: 	    return kPrivateCGCompositeDestinationIn;
  314: 	case CAIRO_OPERATOR_DEST_OUT:
  314: 	    return kPrivateCGCompositeDestinationOut;
  314: 	case CAIRO_OPERATOR_DEST_ATOP:
  314: 	    return kPrivateCGCompositeDestinationAtop;
  314: 	case CAIRO_OPERATOR_XOR:
41340: 	    return kPrivateCGCompositeXOR;
  314: 	case CAIRO_OPERATOR_ADD:
  314: 	    return kPrivateCGCompositePlusLighter;
41340: 
41340: 	case CAIRO_OPERATOR_DEST:
  314: 	case CAIRO_OPERATOR_SATURATE:
41340: 	case CAIRO_OPERATOR_MULTIPLY:
41340: 	case CAIRO_OPERATOR_SCREEN:
41340: 	case CAIRO_OPERATOR_OVERLAY:
41340: 	case CAIRO_OPERATOR_DARKEN:
41340: 	case CAIRO_OPERATOR_LIGHTEN:
41340: 	case CAIRO_OPERATOR_COLOR_DODGE:
41340: 	case CAIRO_OPERATOR_COLOR_BURN:
41340: 	case CAIRO_OPERATOR_HARD_LIGHT:
41340: 	case CAIRO_OPERATOR_SOFT_LIGHT:
41340: 	case CAIRO_OPERATOR_DIFFERENCE:
41340: 	case CAIRO_OPERATOR_EXCLUSION:
41340: 	case CAIRO_OPERATOR_HSL_HUE:
41340: 	case CAIRO_OPERATOR_HSL_SATURATION:
41340: 	case CAIRO_OPERATOR_HSL_COLOR:
41340: 	case CAIRO_OPERATOR_HSL_LUMINOSITY:
41340:         default:
41340: 	    assert (0);
93747: 	    return kPrivateCGCompositeClear;
  314:     }
41340: }
41340: 
41340: static cairo_int_status_t
41340: _cairo_quartz_surface_set_cairo_operator (cairo_quartz_surface_t *surface, cairo_operator_t op)
41340: {
41340:     ND((stderr, "%p _cairo_quartz_surface_set_cairo_operator %d\n", surface, op));
41340: 
41340:     if (surface->base.content == CAIRO_CONTENT_ALPHA) {
41340: 	/* For some weird reason, some compositing operators are
41340: 	   swapped when operating on masks */
41340: 	switch (op) {
41340: 	    case CAIRO_OPERATOR_CLEAR:
41340: 	    case CAIRO_OPERATOR_SOURCE:
41340: 	    case CAIRO_OPERATOR_OVER:
41340: 	    case CAIRO_OPERATOR_DEST_IN:
41340: 	    case CAIRO_OPERATOR_DEST_OUT:
41340: 	    case CAIRO_OPERATOR_ADD:
41340: 		CGContextSetCompositeOperation (surface->cgContext, _cairo_quartz_cairo_operator_to_quartz_composite (op));
41340: 		return CAIRO_STATUS_SUCCESS;
41340: 
41340: 	    case CAIRO_OPERATOR_IN:
41340: 		CGContextSetCompositeOperation (surface->cgContext, kPrivateCGCompositeDestinationAtop);
41340: 		return CAIRO_STATUS_SUCCESS;
41340: 
41340: 	    case CAIRO_OPERATOR_DEST_OVER:
41340: 	    case CAIRO_OPERATOR_MULTIPLY:
41340: 	    case CAIRO_OPERATOR_SCREEN:
41340: 	    case CAIRO_OPERATOR_OVERLAY:
41340: 	    case CAIRO_OPERATOR_DARKEN:
41340: 	    case CAIRO_OPERATOR_LIGHTEN:
41340: 	    case CAIRO_OPERATOR_COLOR_DODGE:
41340: 	    case CAIRO_OPERATOR_COLOR_BURN:
41340: 	    case CAIRO_OPERATOR_HARD_LIGHT:
41340: 	    case CAIRO_OPERATOR_SOFT_LIGHT:
41340: 	    case CAIRO_OPERATOR_DIFFERENCE:
41340: 	    case CAIRO_OPERATOR_EXCLUSION:
41340: 	    case CAIRO_OPERATOR_HSL_HUE:
41340: 	    case CAIRO_OPERATOR_HSL_SATURATION:
41340: 	    case CAIRO_OPERATOR_HSL_COLOR:
41340: 	    case CAIRO_OPERATOR_HSL_LUMINOSITY:
41340: 		CGContextSetCompositeOperation (surface->cgContext, kPrivateCGCompositeSourceOver);
41340: 		return CAIRO_STATUS_SUCCESS;
41340: 
41340: 	    case CAIRO_OPERATOR_DEST_ATOP:
41340: 		CGContextSetCompositeOperation (surface->cgContext, kPrivateCGCompositeSourceIn);
41340: 		return CAIRO_STATUS_SUCCESS;
41340: 
41340: 	    case CAIRO_OPERATOR_SATURATE:
41340: 		CGContextSetCompositeOperation (surface->cgContext, kPrivateCGCompositePlusLighter);
41340: 		return CAIRO_STATUS_SUCCESS;
41340: 
41340: 
41340: 	    case CAIRO_OPERATOR_ATOP:
41340: 		/*
41340: 		CGContextSetCompositeOperation (surface->cgContext, kPrivateCGCompositeDestinationOver);
41340: 		return CAIRO_STATUS_SUCCESS;
41340: 		*/
41340: 	    case CAIRO_OPERATOR_DEST:
41340: 		return CAIRO_INT_STATUS_NOTHING_TO_DO;
41340: 
41340: 	    case CAIRO_OPERATOR_OUT:
41340: 	    case CAIRO_OPERATOR_XOR:
41340: 	    default:
41340: 		return CAIRO_INT_STATUS_UNSUPPORTED;
41340: 	}
41340:     } else {
41340: 	switch (op) {
41340: 	    case CAIRO_OPERATOR_CLEAR:
41340: 	    case CAIRO_OPERATOR_SOURCE:
41340: 	    case CAIRO_OPERATOR_OVER:
41340: 	    case CAIRO_OPERATOR_IN:
41340: 	    case CAIRO_OPERATOR_OUT:
41340: 	    case CAIRO_OPERATOR_ATOP:
41340: 	    case CAIRO_OPERATOR_DEST_OVER:
41340: 	    case CAIRO_OPERATOR_DEST_IN:
41340: 	    case CAIRO_OPERATOR_DEST_OUT:
41340: 	    case CAIRO_OPERATOR_DEST_ATOP:
41340: 	    case CAIRO_OPERATOR_XOR:
41340: 	    case CAIRO_OPERATOR_ADD:
41340: 		CGContextSetCompositeOperation (surface->cgContext, _cairo_quartz_cairo_operator_to_quartz_composite (op));
41340: 		return CAIRO_STATUS_SUCCESS;
41340: 
41340: 	    case CAIRO_OPERATOR_DEST:
41340: 		return CAIRO_INT_STATUS_NOTHING_TO_DO;
41340: 
41340: 	    case CAIRO_OPERATOR_SATURATE:
41340: 	    /* TODO: the following are mostly supported by CGContextSetBlendMode*/
41340: 	    case CAIRO_OPERATOR_MULTIPLY:
41340: 	    case CAIRO_OPERATOR_SCREEN:
41340: 	    case CAIRO_OPERATOR_OVERLAY:
41340: 	    case CAIRO_OPERATOR_DARKEN:
41340: 	    case CAIRO_OPERATOR_LIGHTEN:
41340: 	    case CAIRO_OPERATOR_COLOR_DODGE:
41340: 	    case CAIRO_OPERATOR_COLOR_BURN:
41340: 	    case CAIRO_OPERATOR_HARD_LIGHT:
41340: 	    case CAIRO_OPERATOR_SOFT_LIGHT:
41340: 	    case CAIRO_OPERATOR_DIFFERENCE:
41340: 	    case CAIRO_OPERATOR_EXCLUSION:
41340: 	    case CAIRO_OPERATOR_HSL_HUE:
41340: 	    case CAIRO_OPERATOR_HSL_SATURATION:
41340: 	    case CAIRO_OPERATOR_HSL_COLOR:
41340: 	    case CAIRO_OPERATOR_HSL_LUMINOSITY:
41340: 	    default:
41340: 		return CAIRO_INT_STATUS_UNSUPPORTED;
41340: 	}
41340:     }
  314: }
  314: 
12588: static inline CGLineCap
  314: _cairo_quartz_cairo_line_cap_to_quartz (cairo_line_cap_t ccap)
  314: {
  314:     switch (ccap) {
  314: 	case CAIRO_LINE_CAP_BUTT: return kCGLineCapButt; break;
  314: 	case CAIRO_LINE_CAP_ROUND: return kCGLineCapRound; break;
  314: 	case CAIRO_LINE_CAP_SQUARE: return kCGLineCapSquare; break;
  314:     }
  314: 
  314:     return kCGLineCapButt;
  314: }
  314: 
12588: static inline CGLineJoin
  314: _cairo_quartz_cairo_line_join_to_quartz (cairo_line_join_t cjoin)
  314: {
  314:     switch (cjoin) {
  314: 	case CAIRO_LINE_JOIN_MITER: return kCGLineJoinMiter; break;
  314: 	case CAIRO_LINE_JOIN_ROUND: return kCGLineJoinRound; break;
  314: 	case CAIRO_LINE_JOIN_BEVEL: return kCGLineJoinBevel; break;
  314:     }
  314: 
  314:     return kCGLineJoinMiter;
  314: }
  314: 
12588: static inline CGInterpolationQuality
12588: _cairo_quartz_filter_to_quartz (cairo_filter_t filter)
12588: {
12588:     switch (filter) {
12588: 	case CAIRO_FILTER_NEAREST:
12588: 	    return kCGInterpolationNone;
12588: 
12588: 	case CAIRO_FILTER_FAST:
12588: 	    return kCGInterpolationLow;
12588: 
12588: 	case CAIRO_FILTER_BEST:
12588: 	case CAIRO_FILTER_GOOD:
12588: 	case CAIRO_FILTER_BILINEAR:
12588: 	case CAIRO_FILTER_GAUSSIAN:
12588: 	    return kCGInterpolationDefault;
12588:     }
12588: 
12588:     return kCGInterpolationDefault;
12588: }
12588: 
12588: static inline void
  314: _cairo_quartz_cairo_matrix_to_quartz (const cairo_matrix_t *src,
  314: 				      CGAffineTransform *dst)
  314: {
  314:     dst->a = src->xx;
 4133:     dst->b = src->yx;
 4133:     dst->c = src->xy;
  314:     dst->d = src->yy;
  314:     dst->tx = src->x0;
  314:     dst->ty = src->y0;
  314: }
  314: 
70960: typedef struct {
70960:     bool isClipping;
70960:     CGGlyph *cg_glyphs;
70960:     CGSize *cg_advances;
70960:     size_t nglyphs;
70960:     CGAffineTransform textTransform;
70960:     CGFontRef font;
70960:     CGPoint origin;
70960: } unbounded_show_glyphs_t;
70960: 
70960: typedef struct {
70960:     CGPathRef cgPath;
70960:     cairo_fill_rule_t fill_rule;
70960: } unbounded_stroke_fill_t;
70960: 
70960: typedef struct {
70960:     CGImageRef mask;
70960:     CGAffineTransform maskTransform;
70960: } unbounded_mask_t;
70960: 
70960: typedef enum {
70960:     UNBOUNDED_STROKE_FILL,
70960:     UNBOUNDED_SHOW_GLYPHS,
70960:     UNBOUNDED_MASK
70960: } unbounded_op_t;
70960: 
70960: typedef struct {
70960:     unbounded_op_t op;
70960:     union {
70960: 	unbounded_stroke_fill_t stroke_fill;
70960: 	unbounded_show_glyphs_t show_glyphs;
70960: 	unbounded_mask_t mask;
70960:     } u;
70960: } unbounded_op_data_t;
70960: 
70960: static void
70960: _cairo_quartz_fixup_unbounded_operation (cairo_quartz_surface_t *surface,
70960: 					 unbounded_op_data_t *op,
70960: 					 cairo_antialias_t antialias)
70960: {
70960:     CGRect clipBox, clipBoxRound;
70960:     CGContextRef cgc;
70960:     CGImageRef maskImage;
70960: 
70960:     /* TODO: handle failure */
70960:     if (!CGContextClipToMaskPtr)
70960: 	return;
70960: 
70960:     clipBox = CGContextGetClipBoundingBox (surface->cgContext);
70960:     clipBoxRound = CGRectIntegral (clipBox);
70960: 
70960:     cgc = CGBitmapContextCreate (NULL,
70960: 				 clipBoxRound.size.width,
70960: 				 clipBoxRound.size.height,
70960: 				 8,
70960: 				 (((size_t) clipBoxRound.size.width) + 15) & (~15),
70960: 				 NULL,
70960: 				 kCGImageAlphaOnly);
70960: 
70960:     if (!cgc)
70960: 	return;
70960: 
70960:     CGContextSetCompositeOperation (cgc, kPrivateCGCompositeCopy);
70960:     /* We want to mask out whatever we just rendered, so we fill the
70960:      * surface opaque, and then we'll render transparent.
70960:      */
70960:     CGContextSetAlpha (cgc, 1.0f);
70960:     CGContextFillRect (cgc, CGRectMake (0, 0, clipBoxRound.size.width, clipBoxRound.size.height));
70960: 
70960:     CGContextSetCompositeOperation (cgc, kPrivateCGCompositeClear);
70960:     CGContextSetShouldAntialias (cgc, (antialias != CAIRO_ANTIALIAS_NONE));
70960: 
70960:     CGContextTranslateCTM (cgc, -clipBoxRound.origin.x, -clipBoxRound.origin.y);
70960: 
70960:     /* We need to either render the path that was given to us, or the glyph op */
70960:     if (op->op == UNBOUNDED_STROKE_FILL) {
70960: 	CGContextBeginPath (cgc);
70960: 	CGContextAddPath (cgc, op->u.stroke_fill.cgPath);
70960: 
70960: 	if (op->u.stroke_fill.fill_rule == CAIRO_FILL_RULE_WINDING)
70960: 	    CGContextFillPath (cgc);
70960: 	else
70960: 	    CGContextEOFillPath (cgc);
70960:     } else if (op->op == UNBOUNDED_SHOW_GLYPHS) {
70960: 	CGContextSetFont (cgc, op->u.show_glyphs.font);
70960: 	CGContextSetFontSize (cgc, 1.0);
70960: 	CGContextSetTextMatrix (cgc, CGAffineTransformIdentity);
70960: 	CGContextTranslateCTM (cgc, op->u.show_glyphs.origin.x, op->u.show_glyphs.origin.y);
70960: 	CGContextConcatCTM (cgc, op->u.show_glyphs.textTransform);
70960: 
70960: 	if (op->u.show_glyphs.isClipping) {
70960: 	    /* Note that the comment in show_glyphs about kCGTextClip
70960: 	     * and the text transform still applies here; however, the
70960: 	     * cg_advances we have were already transformed, so we
70960: 	     * don't have to do anything. */
70960: 	    CGContextSetTextDrawingMode (cgc, kCGTextClip);
70960: 	    CGContextSaveGState (cgc);
70960: 	}
70960: 
70960: 	CGContextShowGlyphsWithAdvances (cgc,
70960: 					 op->u.show_glyphs.cg_glyphs,
70960: 					 op->u.show_glyphs.cg_advances,
70960: 					 op->u.show_glyphs.nglyphs);
70960: 
70960: 	if (op->u.show_glyphs.isClipping) {
70960: 	    CGContextClearRect (cgc, clipBoxRound);
70960: 	    CGContextRestoreGState (cgc);
70960: 	}
70960:     } else if (op->op == UNBOUNDED_MASK) {
70960: 	CGAffineTransform ctm = CGContextGetCTM (cgc);
70960: 	CGContextSaveGState (cgc);
70960: 	CGContextConcatCTM (cgc, op->u.mask.maskTransform);
70960: 	CGContextClipToMask (cgc, CGRectMake (0.0f, 0.0f,
70960: 					      CGImageGetWidth(op->u.mask.mask), CGImageGetHeight(op->u.mask.mask)),
70960: 			     op->u.mask.mask);
70960: 	CGContextSetCTM (cgc, ctm);
70960: 	CGContextClearRect (cgc, clipBoxRound);
70960: 	CGContextRestoreGState (cgc);
70960:     }
70960: 
70960:     /* Also mask out the portion of the clipbox that we rounded out, if any */
70960:     if (!CGRectEqualToRect (clipBox, clipBoxRound)) {
70960: 	CGContextBeginPath (cgc);
70960: 	CGContextAddRect (cgc, clipBoxRound);
70960: 	CGContextAddRect (cgc, clipBox);
70960: 	CGContextEOFillPath (cgc);
70960:     }
70960: 
70960:     maskImage = CGBitmapContextCreateImage (cgc);
70960:     CGContextRelease (cgc);
70960: 
70960:     if (!maskImage)
70960: 	return;
70960: 
70960:     /* Then render with the mask */
70960:     CGContextSaveGState (surface->cgContext);
70960: 
70960:     CGContextSetCompositeOperation (surface->cgContext, kPrivateCGCompositeCopy);
70960:     CGContextClipToMaskPtr (surface->cgContext, clipBoxRound, maskImage);
70960:     CGImageRelease (maskImage);
70960: 
70960:     /* Finally, clear out the entire clipping region through our mask */
70960:     CGContextClearRect (surface->cgContext, clipBoxRound);
70960: 
70960:     CGContextRestoreGState (surface->cgContext);
70960: }
70960: 
  314: /*
  314:  * Source -> Quartz setup and finish functions
  314:  */
  314: 
  314: static void
70960: ComputeGradientValue (void *info,
70960:                       const cairo_quartz_float_t *in,
70960:                       cairo_quartz_float_t *out)
  314: {
13107:     double fdist = *in;
26419:     const cairo_gradient_pattern_t *grad = (cairo_gradient_pattern_t*) info;
  314:     unsigned int i;
  314: 
13107:     /* Put fdist back in the 0.0..1.0 range if we're doing
13107:      * REPEAT/REFLECT
13107:      */
13107:     if (grad->base.extend == CAIRO_EXTEND_REPEAT) {
13107: 	fdist = fdist - floor(fdist);
13107:     } else if (grad->base.extend == CAIRO_EXTEND_REFLECT) {
13107: 	fdist = fmod(fabs(fdist), 2.0);
13107: 	if (fdist > 1.0) {
13107: 	    fdist = 2.0 - fdist;
13107: 	}
13107:     }
13107: 
  314:     for (i = 0; i < grad->n_stops; i++) {
13979: 	if (grad->stops[i].offset > fdist)
  314: 	    break;
  314:     }
  314: 
  314:     if (i == 0 || i == grad->n_stops) {
  314: 	if (i == grad->n_stops)
  314: 	    --i;
 8452: 	out[0] = grad->stops[i].color.red;
 8452: 	out[1] = grad->stops[i].color.green;
 8452: 	out[2] = grad->stops[i].color.blue;
 8452: 	out[3] = grad->stops[i].color.alpha;
  314:     } else {
70960: 	cairo_quartz_float_t ax = grad->stops[i-1].offset;
70960: 	cairo_quartz_float_t bx = grad->stops[i].offset - ax;
70960: 	cairo_quartz_float_t bp = (fdist - ax)/bx;
70960: 	cairo_quartz_float_t ap = 1.0 - bp;
  314: 
  314: 	out[0] =
 8452: 	    grad->stops[i-1].color.red * ap +
 8452: 	    grad->stops[i].color.red * bp;
  314: 	out[1] =
 8452: 	    grad->stops[i-1].color.green * ap +
 8452: 	    grad->stops[i].color.green * bp;
  314: 	out[2] =
 8452: 	    grad->stops[i-1].color.blue * ap +
 8452: 	    grad->stops[i].color.blue * bp;
  314: 	out[3] =
 8452: 	    grad->stops[i-1].color.alpha * ap +
 8452: 	    grad->stops[i].color.alpha * bp;
  314:     }
  314: }
  314: 
70960: static const cairo_quartz_float_t gradient_output_value_ranges[8] = {
31998:     0.f, 1.f, 0.f, 1.f, 0.f, 1.f, 0.f, 1.f
31998: };
31998: static const CGFunctionCallbacks gradient_callbacks = {
31998:     0, ComputeGradientValue, (CGFunctionReleaseInfoCallback) cairo_pattern_destroy
31998: };
34472: /* Quartz will clamp input values to the input range.
34472: 
34472:    Our stops are all in the range 0.0 to 1.0. However, the color before the
34472:    beginning of the gradient line is obtained by Quartz computing a negative
34472:    position on the gradient line, clamping it to the input range we specified
34472:    for our color function, and then calling our color function (actually it
34472:    pre-samples the color function into an array, but that doesn't matter just
34472:    here). Therefore if we set the lower bound to 0.0, a negative position
34472:    on the gradient line will pass 0.0 to ComputeGradientValue, which will
34472:    select the last color stop with position 0, although it should select
34472:    the first color stop (this matters when there are multiple color stops with
34472:    position 0).
34472: 
34472:    Therefore we pass a small negative number as the lower bound of the input
34472:    range, so this value gets passed into ComputeGradientValue, which will
34472:    return the color of the first stop. The number should be small because
34472:    as far as I can tell, Quartz pre-samples the entire input range of the color
34472:    function into an array of fixed size, so if the input range is larger
34472:    than needed, the resolution of the gradient will be unnecessarily low.
34472: */
70960: static const cairo_quartz_float_t nonrepeating_gradient_input_value_range[2] = { -0.001f, 1.f };
31998: 
  314: static CGFunctionRef
26419: CreateGradientFunction (const cairo_gradient_pattern_t *gpat)
  314: {
26419:     cairo_pattern_t *pat;
  314: 
26419:     if (_cairo_pattern_create_copy (&pat, &gpat->base))
26419: 	/* quartz doesn't deal very well with malloc failing, so there's
26419: 	 * not much point in us trying either */
26419: 	return NULL;
26419: 
26419:     return CGFunctionCreate (pat,
  314: 			     1,
34472: 			     nonrepeating_gradient_input_value_range,
  314: 			     4,
31998: 			     gradient_output_value_ranges,
31998: 			     &gradient_callbacks);
  314: }
  314: 
31999: static void
31999: UpdateLinearParametersToIncludePoint(double *min_t, double *max_t, CGPoint *start,
31999:                                      double dx, double dy,
31999:                                      double x, double y)
31999: {
31999:     /* Compute a parameter t such that a line perpendicular to the (dx,dy)
31999:        vector, passing through (start->x + dx*t, start->y + dy*t), also
31999:        passes through (x,y).
31999: 
31999:        Let px = x - start->x, py = y - start->y.
31999:        t is given by
31999:          (px - dx*t)*dx + (py - dy*t)*dy = 0
31999: 
31999:        Solving for t we get
31999:          numerator = dx*px + dy*py
31999:          denominator = dx^2 + dy^2
31999:          t = numerator/denominator
31999: 
31999:        In CreateRepeatingLinearGradientFunction we know the length of (dx,dy)
31999:        is not zero. (This is checked in _cairo_quartz_setup_linear_source.)
31999:     */
31999:     double px = x - start->x;
31999:     double py = y - start->y;
31999:     double numerator = dx*px + dy*py;
31999:     double denominator = dx*dx + dy*dy;
31999:     double t = numerator/denominator;
31999: 
31999:     if (*min_t > t) {
31999:         *min_t = t;
31999:     }
31999:     if (*max_t < t) {
31999:         *max_t = t;
31999:     }
31999: }
31999: 
13107: static CGFunctionRef
31997: CreateRepeatingLinearGradientFunction (cairo_quartz_surface_t *surface,
26419: 				       const cairo_gradient_pattern_t *gpat,
13107: 				       CGPoint *start, CGPoint *end,
31999: 				       cairo_rectangle_int_t *extents)
13107: {
26419:     cairo_pattern_t *pat;
70960:     cairo_quartz_float_t input_value_range[2];
31999:     double t_min = 0.;
31999:     double t_max = 0.;
31999:     double dx = end->x - start->x;
31999:     double dy = end->y - start->y;
31999:     double bounds_x1, bounds_x2, bounds_y1, bounds_y2;
31999: 
31999:     if (!extents) {
31999:         extents = &surface->extents;
13107:     }
31999:     bounds_x1 = extents->x;
31999:     bounds_y1 = extents->y;
31999:     bounds_x2 = extents->x + extents->width;
31999:     bounds_y2 = extents->y + extents->height;
31999:     _cairo_matrix_transform_bounding_box (&gpat->base.matrix,
31999:                                           &bounds_x1, &bounds_y1,
31999:                                           &bounds_x2, &bounds_y2,
31999:                                           NULL);
31999: 
31999:     UpdateLinearParametersToIncludePoint(&t_min, &t_max, start, dx, dy,
31999:                                          bounds_x1, bounds_y1);
31999:     UpdateLinearParametersToIncludePoint(&t_min, &t_max, start, dx, dy,
31999:                                          bounds_x2, bounds_y1);
31999:     UpdateLinearParametersToIncludePoint(&t_min, &t_max, start, dx, dy,
31999:                                          bounds_x2, bounds_y2);
31999:     UpdateLinearParametersToIncludePoint(&t_min, &t_max, start, dx, dy,
31999:                                          bounds_x1, bounds_y2);
31999: 
31999:     /* Move t_min and t_max to the nearest usable integer to try to avoid
31999:        subtle variations due to numerical instability, especially accidentally
31999:        cutting off a pixel. Extending the gradient repetitions is always safe. */
31999:     t_min = floor (t_min);
31999:     t_max = ceil (t_max);
31999:     end->x = start->x + dx*t_max;
31999:     end->y = start->y + dy*t_max;
31999:     start->x = start->x + dx*t_min;
31999:     start->y = start->y + dy*t_min;
13107: 
13107:     // set the input range for the function -- the function knows how to
13107:     // map values outside of 0.0 .. 1.0 to that range for REPEAT/REFLECT.
31999:     input_value_range[0] = t_min;
31999:     input_value_range[1] = t_max;
13107: 
26419:     if (_cairo_pattern_create_copy (&pat, &gpat->base))
26419: 	/* quartz doesn't deal very well with malloc failing, so there's
26419: 	 * not much point in us trying either */
26419: 	return NULL;
26419: 
26419:     return CGFunctionCreate (pat,
13107: 			     1,
13107: 			     input_value_range,
13107: 			     4,
31998: 			     gradient_output_value_ranges,
31998: 			     &gradient_callbacks);
13107: }
13107: 
31997: static void
31997: UpdateRadialParameterToIncludePoint(double *max_t, CGPoint *center,
31997:                                     double dr, double dx, double dy,
31997:                                     double x, double y)
31997: {
31997:     /* Compute a parameter t such that a circle centered at
31997:        (center->x + dx*t, center->y + dy*t) with radius dr*t contains the
31997:        point (x,y).
31997: 
31997:        Let px = x - center->x, py = y - center->y.
31997:        Parameter values for which t is on the circle are given by
31997:          (px - dx*t)^2 + (py - dy*t)^2 = (t*dr)^2
31997: 
31997:        Solving for t using the quadratic formula, and simplifying, we get
31997:          numerator = dx*px + dy*py +-
31997:                      sqrt( dr^2*(px^2 + py^2) - (dx*py - dy*px)^2 )
31997:          denominator = dx^2 + dy^2 - dr^2
31997:          t = numerator/denominator
31997: 
31997:        In CreateRepeatingRadialGradientFunction we know the outer circle
31997:        contains the inner circle. Therefore the distance between the circle
31997:        centers plus the radius of the inner circle is less than the radius of
31997:        the outer circle. (This is checked in _cairo_quartz_setup_radial_source.)
31997:        Therefore
31997:          dx^2 + dy^2 < dr^2
31997:        So the denominator is negative and the larger solution for t is given by
31997:          numerator = dx*px + dy*py -
31997:                      sqrt( dr^2*(px^2 + py^2) - (dx*py - dy*px)^2 )
31997:          denominator = dx^2 + dy^2 - dr^2
31997:          t = numerator/denominator
31997:        dx^2 + dy^2 < dr^2 also ensures that the operand of sqrt is positive.
31997:     */
31997:     double px = x - center->x;
31997:     double py = y - center->y;
31997:     double dx_py_minus_dy_px = dx*py - dy*px;
31997:     double numerator = dx*px + dy*py -
31997:         sqrt (dr*dr*(px*px + py*py) - dx_py_minus_dy_px*dx_py_minus_dy_px);
31997:     double denominator = dx*dx + dy*dy - dr*dr;
31997:     double t = numerator/denominator;
31997: 
31997:     if (*max_t < t) {
31997:         *max_t = t;
31997:     }
31997: }
31997: 
31997: /* This must only be called when one of the circles properly contains the other */
31997: static CGFunctionRef
31997: CreateRepeatingRadialGradientFunction (cairo_quartz_surface_t *surface,
31997:                                        const cairo_gradient_pattern_t *gpat,
31997:                                        CGPoint *start, double *start_radius,
31999:                                        CGPoint *end, double *end_radius,
31999:                                        cairo_rectangle_int_t *extents)
31997: {
31997:     cairo_pattern_t *pat;
70960:     cairo_quartz_float_t input_value_range[2];
31997:     CGPoint *inner;
31997:     double *inner_radius;
31997:     CGPoint *outer;
31997:     double *outer_radius;
31997:     /* minimum and maximum t-parameter values that will make our gradient
31997:        cover the clipBox */
31997:     double t_min, t_max, t_temp;
31997:     /* outer minus inner */
31997:     double dr, dx, dy;
31999:     double bounds_x1, bounds_x2, bounds_y1, bounds_y2;
31999: 
31999:     if (!extents) {
31999:         extents = &surface->extents;
31999:     }
31999:     bounds_x1 = extents->x;
31999:     bounds_y1 = extents->y;
31999:     bounds_x2 = extents->x + extents->width;
31999:     bounds_y2 = extents->y + extents->height;
31999:     _cairo_matrix_transform_bounding_box (&gpat->base.matrix,
31999:                                           &bounds_x1, &bounds_y1,
31999:                                           &bounds_x2, &bounds_y2,
31999:                                           NULL);
31997: 
31997:     if (*start_radius < *end_radius) {
31997:         /* end circle contains start circle */
31997:         inner = start;
31997:         outer = end;
31997:         inner_radius = start_radius;
31997:         outer_radius = end_radius;
31997:     } else {
31997:         /* start circle contains end circle */
31997:         inner = end;
31997:         outer = start;
31997:         inner_radius = end_radius;
31997:         outer_radius = start_radius;
31997:     }
31997: 
31997:     dr = *outer_radius - *inner_radius;
31997:     dx = outer->x - inner->x;
31997:     dy = outer->y - inner->y;
31997: 
31999:     /* We can't round or fudge t_min here, it has to be as accurate as possible. */
31997:     t_min = -(*inner_radius/dr);
31997:     inner->x += t_min*dx;
31997:     inner->y += t_min*dy;
31997:     *inner_radius = 0.;
31997: 
31997:     t_temp = 0.;
31997:     UpdateRadialParameterToIncludePoint(&t_temp, inner, dr, dx, dy,
31999:                                         bounds_x1, bounds_y1);
31997:     UpdateRadialParameterToIncludePoint(&t_temp, inner, dr, dx, dy,
31999:                                         bounds_x2, bounds_y1);
31997:     UpdateRadialParameterToIncludePoint(&t_temp, inner, dr, dx, dy,
31999:                                         bounds_x2, bounds_y2);
31997:     UpdateRadialParameterToIncludePoint(&t_temp, inner, dr, dx, dy,
31999:                                         bounds_x1, bounds_y2);
31997:     /* UpdateRadialParameterToIncludePoint assumes t=0 means radius 0.
31997:        But for the parameter values we use with Quartz, t_min means radius 0.
31999:        Since the circles are alway expanding and contain the earlier circles,
31999:        it's safe to extend t_max/t_temp as much as we want, so round t_temp up
31999:        to the nearest integer. This may help us give stable results. */
31999:     t_temp = ceil (t_temp);
31997:     t_max = t_min + t_temp;
31997:     outer->x = inner->x + t_temp*dx;
31997:     outer->y = inner->y + t_temp*dy;
31997:     *outer_radius = t_temp*dr;
31997: 
31997:     /* set the input range for the function -- the function knows how to
31997:        map values outside of 0.0 .. 1.0 to that range for REPEAT/REFLECT. */
31997:     if (*start_radius < *end_radius) {
31997:         input_value_range[0] = t_min;
31997:         input_value_range[1] = t_max;
31997:     } else {
70960:         input_value_range[0] = 1 - t_max;
70960:         input_value_range[1] = 1 - t_min;
31997:     }
31997: 
31997:     if (_cairo_pattern_create_copy (&pat, &gpat->base))
31997:   /* quartz doesn't deal very well with malloc failing, so there's
31997:    * not much point in us trying either */
31997:   return NULL;
31997: 
31997:     return CGFunctionCreate (pat,
31997:            1,
31997:            input_value_range,
31997:            4,
31998:            gradient_output_value_ranges,
31998:            &gradient_callbacks);
31997: }
31997: 
12588: /* Obtain a CGImageRef from a #cairo_surface_t * */
11244: 
70960: typedef struct {
70960:     cairo_surface_t *surface;
70960:     cairo_image_surface_t *image_out;
70960:     void *image_extra;
70960: } quartz_source_image_t;
70960: 
16122: static void
16122: DataProviderReleaseCallback (void *info, const void *data, size_t size)
16122: {
70960:     quartz_source_image_t *source_img = info;
70960:     _cairo_surface_release_source_image (source_img->surface, source_img->image_out, source_img->image_extra);
74713:     cairo_surface_destroy (source_img->surface);
70960:     free (source_img);
16122: }
16122: 
13264: static cairo_status_t
42959: _cairo_surface_to_cgimage (cairo_surface_t *source,
13264: 			   CGImageRef *image_out)
  314: {
70960:     cairo_status_t status;
70960:     quartz_source_image_t *source_img;
70960: 
70960:     if (source->backend && source->backend->type == CAIRO_SURFACE_TYPE_QUARTZ_IMAGE) {
11244: 	cairo_quartz_image_surface_t *surface = (cairo_quartz_image_surface_t *) source;
13264: 	*image_out = CGImageRetain (surface->image);
13264: 	return CAIRO_STATUS_SUCCESS;
 7173:     }
 8452: 
70960:     if (_cairo_surface_is_quartz (source)) {
11244: 	cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) source;
13264: 	if (IS_EMPTY(surface)) {
13264: 	    *image_out = NULL;
13264: 	    return CAIRO_STATUS_SUCCESS;
13264: 	}
13264: 
13107: 	if (_cairo_quartz_is_cgcontext_bitmap_context (surface->cgContext)) {
42954: 	    if (!surface->bitmapContextImage) {
42954: 	        surface->bitmapContextImage =
42954: 	            CGBitmapContextCreateImage (surface->cgContext);
42954: 	    }
42954: 	    if (surface->bitmapContextImage) {
42954:                 *image_out = CGImageRetain (surface->bitmapContextImage);
13264:                 return CAIRO_STATUS_SUCCESS;
  314:             }
13107: 	}
42954:     }
  314: 
70960:     source_img = malloc (sizeof (quartz_source_image_t));
70960:     if (source_img == NULL)
70960: 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
70960: 
94969:     source_img->surface = cairo_surface_reference(source);
70960: 
70960:     status = _cairo_surface_acquire_source_image (source_img->surface, &source_img->image_out, &source_img->image_extra);
70960:     if (status) {
74713: 	cairo_surface_destroy (source_img->surface);
70960: 	free (source_img);
13264: 	return status;
70960:     }
70960: 
70960:     if (source_img->image_out->width == 0 || source_img->image_out->height == 0) {
70960: 	*image_out = NULL;
70960: 	DataProviderReleaseCallback (source_img,
70960: 				     source_img->image_out->data,
70960: 				     source_img->image_out->height * source_img->image_out->stride);
70918:     } else {
70960: 	*image_out = _cairo_quartz_create_cgimage (source_img->image_out->format,
70960: 						   source_img->image_out->width,
70960: 						   source_img->image_out->height,
70960: 						   source_img->image_out->stride,
70960: 						   source_img->image_out->data,
13107: 						   TRUE,
16122: 						   NULL,
16122: 						   DataProviderReleaseCallback,
70960: 						   source_img);
70960: 
70960: 	/* TODO: differentiate memory error and unsupported surface type */
70960: 	if (*image_out == NULL)
41340: 	    status = CAIRO_INT_STATUS_UNSUPPORTED;
13264:     }
11244: 
13264:     return status;
 4133: }
 4133: 
12588: /* Generic #cairo_pattern_t -> CGPattern function */
11244: 
11244: typedef struct {
11244:     CGImageRef image;
11244:     CGRect imageBounds;
11244:     cairo_bool_t do_reflect;
11244: } SurfacePatternDrawInfo;
11244: 
 4133: static void
11244: SurfacePatternDrawFunc (void *ainfo, CGContextRef context)
 4133: {
11244:     SurfacePatternDrawInfo *info = (SurfacePatternDrawInfo*) ainfo;
 4133: 
11244:     CGContextTranslateCTM (context, 0, info->imageBounds.size.height);
11244:     CGContextScaleCTM (context, 1, -1);
 8452: 
11244:     CGContextDrawImage (context, info->imageBounds, info->image);
11244:     if (info->do_reflect) {
12588: 	/* draw 3 more copies of the image, flipped.
12588: 	 * DrawImage draws the image according to the current Y-direction into the rectangle given
12588: 	 * (imageBounds); at the time of the first DrawImage above, the origin is at the bottom left
12588: 	 * of the base image position, and the Y axis is extending upwards.
12588: 	 */
12588: 
12588: 	/* Make the y axis extend downwards, and draw a flipped image below */
11244: 	CGContextScaleCTM (context, 1, -1);
11244: 	CGContextDrawImage (context, info->imageBounds, info->image);
12588: 
12588: 	/* Shift over to the right, and flip vertically (translation is 2x,
12588: 	 * since we'll be flipping and thus rendering the rectangle "backwards"
12588: 	 */
11244: 	CGContextTranslateCTM (context, 2 * info->imageBounds.size.width, 0);
11244: 	CGContextScaleCTM (context, -1, 1);
11244: 	CGContextDrawImage (context, info->imageBounds, info->image);
12588: 
12588: 	/* Then unflip the Y-axis again, and draw the image above the point. */
11244: 	CGContextScaleCTM (context, 1, -1);
11244: 	CGContextDrawImage (context, info->imageBounds, info->image);
11244:     }
  314: }
  314: 
11244: static void
11244: SurfacePatternReleaseInfoFunc (void *ainfo)
11244: {
11244:     SurfacePatternDrawInfo *info = (SurfacePatternDrawInfo*) ainfo;
  314: 
11244:     CGImageRelease (info->image);
11244:     free (info);
  314: }
  314: 
 8452: static cairo_int_status_t
  314: _cairo_quartz_cairo_repeating_surface_pattern_to_quartz (cairo_quartz_surface_t *dest,
26419: 							 const cairo_pattern_t *apattern,
 8452: 							 CGPatternRef *cgpat)
  314: {
11244:     cairo_surface_pattern_t *spattern;
  314:     cairo_surface_t *pat_surf;
 4133:     cairo_rectangle_int_t extents;
  314: 
11244:     CGImageRef image;
  314:     CGRect pbounds;
  314:     CGAffineTransform ptransform, stransform;
  314:     CGPatternCallbacks cb = { 0,
  314: 			      SurfacePatternDrawFunc,
11244: 			      SurfacePatternReleaseInfoFunc };
11244:     SurfacePatternDrawInfo *info;
70960:     cairo_quartz_float_t rw, rh;
 8452:     cairo_status_t status;
41340:     cairo_bool_t is_bounded;
  314: 
11244:     cairo_matrix_t m;
  314: 
  314:     /* SURFACE is the only type we'll handle here */
11244:     if (apattern->type != CAIRO_PATTERN_TYPE_SURFACE)
 8452: 	return CAIRO_INT_STATUS_UNSUPPORTED;
  314: 
11244:     spattern = (cairo_surface_pattern_t *) apattern;
11244:     pat_surf = spattern->surface;
  314: 
41340:     is_bounded = _cairo_surface_get_extents (pat_surf, &extents);
41340:     assert (is_bounded);
41340: 
42959:     status = _cairo_surface_to_cgimage (pat_surf, &image);
 8452:     if (status)
 8452: 	return status;
11244:     if (image == NULL)
13264: 	return CAIRO_INT_STATUS_NOTHING_TO_DO;
11244: 
11244:     info = malloc(sizeof(SurfacePatternDrawInfo));
11244:     if (!info)
11244: 	return CAIRO_STATUS_NO_MEMORY;
11244: 
11244:     /* XXX -- if we're printing, we may need to call CGImageCreateCopy to make sure
11244:      * that the data will stick around for this image when the printer gets to it.
11244:      * Otherwise, the underlying data store may disappear from under us!
11244:      *
11244:      * _cairo_surface_to_cgimage will copy when it converts non-Quartz surfaces,
11244:      * since the Quartz surfaces have a higher chance of sticking around.  If the
11244:      * source is a quartz image surface, then it's set up to retain a ref to the
11244:      * image surface that it's backed by.
11244:      */
11244:     info->image = image;
11244:     info->imageBounds = CGRectMake (0, 0, extents.width, extents.height);
20223:     info->do_reflect = FALSE;
11244: 
  314:     pbounds.origin.x = 0;
  314:     pbounds.origin.y = 0;
 4133: 
11244:     if (spattern->base.extend == CAIRO_EXTEND_REFLECT) {
12588: 	pbounds.size.width = 2.0 * extents.width;
12588: 	pbounds.size.height = 2.0 * extents.height;
12588: 	info->do_reflect = TRUE;
 4133:     } else {
  314: 	pbounds.size.width = extents.width;
  314: 	pbounds.size.height = extents.height;
 4133:     }
 4133:     rw = pbounds.size.width;
 4133:     rh = pbounds.size.height;
  314: 
11244:     m = spattern->base.matrix;
  314:     cairo_matrix_invert(&m);
  314:     _cairo_quartz_cairo_matrix_to_quartz (&m, &stransform);
  314: 
  314:     /* The pattern matrix is relative to the bottom left, again; the
  314:      * incoming cairo pattern matrix is relative to the upper left.
  314:      * So we take the pattern matrix and the original context matrix,
  314:      * which gives us the correct base translation/y flip.
  314:      */
  314:     ptransform = CGAffineTransformConcat(stransform, dest->cgContextBaseCTM);
  314: 
  314: #ifdef QUARTZ_DEBUG
  314:     ND((stderr, "  pbounds: %f %f %f %f\n", pbounds.origin.x, pbounds.origin.y, pbounds.size.width, pbounds.size.height));
  314:     ND((stderr, "  pattern xform: t: %f %f xx: %f xy: %f yx: %f yy: %f\n", ptransform.tx, ptransform.ty, ptransform.a, ptransform.b, ptransform.c, ptransform.d));
  314:     CGAffineTransform xform = CGContextGetCTM(dest->cgContext);
  314:     ND((stderr, "  context xform: t: %f %f xx: %f xy: %f yx: %f yy: %f\n", xform.tx, xform.ty, xform.a, xform.b, xform.c, xform.d));
  314: #endif
  314: 
11244:     *cgpat = CGPatternCreate (info,
  314: 			      pbounds,
  314: 			      ptransform,
  314: 			      rw, rh,
  314: 			      kCGPatternTilingConstantSpacing, /* kCGPatternTilingNoDistortion, */
  314: 			      TRUE,
  314: 			      &cb);
11244: 
 8452:     return CAIRO_STATUS_SUCCESS;
  314: }
  314: 
  314: typedef enum {
  314:     DO_SOLID,
  314:     DO_SHADING,
  314:     DO_PATTERN,
 4133:     DO_IMAGE,
42521:     DO_TILED_IMAGE,
42959:     DO_LAYER,
10414:     DO_UNSUPPORTED,
42521:     DO_NOTHING
  314: } cairo_quartz_action_t;
  314: 
42521: /* State used during a drawing operation. */
42521: typedef struct {
42521:     CGContextRef context;
42521:     cairo_quartz_action_t action;
42521: 
42959:     // Used with DO_SHADING, DO_IMAGE, DO_TILED_IMAGE and DO_LAYER
42521:     CGAffineTransform transform;
42521: 
42521:     // Used with DO_IMAGE and DO_TILED_IMAGE
42521:     CGImageRef image;
42521:     cairo_surface_t *imageSurface;
42959: 
42959:     // Used with DO_IMAGE, DO_TILED_IMAGE and DO_LAYER
42521:     CGRect imageRect;
42521: 
42959:     // Used with DO_LAYER
42959:     CGLayerRef layer;
42959: 
42521:     // Used with DO_SHADING
42521:     CGShadingRef shading;
42521: 
42521:     // Used with DO_PATTERN
42521:     CGPatternRef pattern;
42521: } cairo_quartz_drawing_state_t;
42521: 
42521: static void
13107: _cairo_quartz_setup_fallback_source (cairo_quartz_surface_t *surface,
42521: 				     const cairo_pattern_t *source,
42521: 				     cairo_quartz_drawing_state_t *state)
13107: {
42521:     CGRect clipBox = CGContextGetClipBoundingBox (state->context);
13107:     double x0, y0, w, h;
13107: 
13107:     cairo_surface_t *fallback;
13107:     CGImageRef img;
13107: 
13264:     cairo_status_t status;
13264: 
13107:     if (clipBox.size.width == 0.0f ||
42521: 	clipBox.size.height == 0.0f) {
42521: 	state->action = DO_NOTHING;
42521: 	return;
42521:     }
13107: 
13107:     x0 = floor(clipBox.origin.x);
13107:     y0 = floor(clipBox.origin.y);
13107:     w = ceil(clipBox.origin.x + clipBox.size.width) - x0;
13107:     h = ceil(clipBox.origin.y + clipBox.size.height) - y0;
13107: 
13107:     /* Create a temporary the size of the clip surface, and position
13107:      * it so that the device origin coincides with the original surface */
13107:     fallback = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, (int) w, (int) h);
13107:     cairo_surface_set_device_offset (fallback, -x0, -y0);
13107: 
41340: #if 0
41340:     {
41340: 	cairo_t *fallback_cr;
41340: 	cairo_pattern_t *source_copy;
41340: 
13107: 	/* Paint the source onto our temporary */
13107: 	fallback_cr = cairo_create (fallback);
13107: 	cairo_set_operator (fallback_cr, CAIRO_OPERATOR_SOURCE);
26419: 
26419: 	/* Use a copy of the pattern because it is const and could be allocated
26419: 	 * on the stack */
26419: 	status = _cairo_pattern_create_copy (&source_copy, source);
26419: 	cairo_set_source (fallback_cr, source_copy);
26419: 	cairo_pattern_destroy (source_copy);
26419: 
13107: 	cairo_paint (fallback_cr);
13107: 	cairo_destroy (fallback_cr);
41340:     }
41340: #else
41340:     {
41340: 	cairo_pattern_union_t pattern;
41340: 
41340: 	_cairo_pattern_init_static_copy (&pattern.base, source);
41340: 	_cairo_pattern_transform (&pattern.base,
41340: 				  &fallback->device_transform_inverse);
41340: 	status = _cairo_surface_paint (fallback,
41340: 				       CAIRO_OPERATOR_SOURCE,
41340: 				       &pattern.base, NULL);
41340:     }
41340: #endif
41340: 
42959:     status = _cairo_surface_to_cgimage (fallback, &img);
42521:     if (status) {
42521:         state->action = DO_UNSUPPORTED;
42521: 	return;
42521:     }
42521:     if (img == NULL) {
42521:         state->action = DO_NOTHING;
42521: 	return;
42521:     }
42521: 
42521:     state->imageRect = CGRectMake (0.0, 0.0, w, h);
42521:     state->image = img;
42521:     state->imageSurface = fallback;
42521:     state->transform = CGAffineTransformMakeTranslation (x0, y0);
42521:     state->action = DO_IMAGE;
13107: }
13107: 
31999: /*
31999: Quartz does not support repeating radients. We handle repeating gradients
31999: by manually extending the gradient and repeating color stops. We need to
31999: minimize the number of repetitions since Quartz seems to sample our color
31999: function across the entire range, even if part of that range is not needed
31999: for the visible area of the gradient, and it samples with some fixed resolution,
31999: so if the gradient range is too large it samples with very low resolution and
31999: the gradient is very coarse. CreateRepeatingLinearGradientFunction and
31999: CreateRepeatingRadialGradientFunction compute the number of repetitions needed
31999: based on the extents of the object (the clip region cannot be used here since
31999: we don't want the rasterization of the entire gradient to depend on the
31999: clip region).
31999: */
42521: static void
10414: _cairo_quartz_setup_linear_source (cairo_quartz_surface_t *surface,
31999: 				   const cairo_linear_pattern_t *lpat,
42521: 				   cairo_rectangle_int_t *extents,
42521: 				   cairo_quartz_drawing_state_t *state)
10414: {
26419:     const cairo_pattern_t *abspat = &lpat->base.base;
10414:     cairo_matrix_t mat;
10414:     CGPoint start, end;
10414:     CGFunctionRef gradFunc;
10414:     CGColorSpaceRef rgb;
10414:     bool extend = abspat->extend == CAIRO_EXTEND_PAD;
10414: 
13107:     if (lpat->base.n_stops == 0) {
42521: 	CGContextSetRGBStrokeColor (state->context, 0., 0., 0., 0.);
42521: 	CGContextSetRGBFillColor (state->context, 0., 0., 0., 0.);
42521: 	state->action = DO_SOLID;
42521: 	return;
10414:     }
10414: 
31999:     if (lpat->p1.x == lpat->p2.x &&
31999:         lpat->p1.y == lpat->p2.y) {
31999: 	/* Quartz handles cases where the vector has no length very
31999: 	 * differently from pixman.
31999: 	 * Whatever the correct behaviour is, let's at least have only pixman's
31999: 	 * implementation to worry about.
31999: 	 */
42521: 	_cairo_quartz_setup_fallback_source (surface, abspat, state);
42521: 	return;
31999:     }
31999: 
26419:     mat = abspat->matrix;
13107:     cairo_matrix_invert (&mat);
42521:     _cairo_quartz_cairo_matrix_to_quartz (&mat, &state->transform);
13107: 
10414:     rgb = CGColorSpaceCreateDeviceRGB();
10414: 
13107:     start = CGPointMake (_cairo_fixed_to_double (lpat->p1.x),
13107: 			 _cairo_fixed_to_double (lpat->p1.y));
13107:     end = CGPointMake (_cairo_fixed_to_double (lpat->p2.x),
13107: 		       _cairo_fixed_to_double (lpat->p2.y));
13107: 
13107:     if (abspat->extend == CAIRO_EXTEND_NONE ||
13107:         abspat->extend == CAIRO_EXTEND_PAD)
13107:     {
26419: 	gradFunc = CreateGradientFunction (&lpat->base);
13107:     } else {
31997: 	gradFunc = CreateRepeatingLinearGradientFunction (surface,
26419: 						          &lpat->base,
31997: 						          &start, &end,
31999: 						          extents);
13107:     }
13107: 
42521:     state->shading = CGShadingCreateAxial (rgb,
10414: 					   start, end,
10414: 					   gradFunc,
10414: 					   extend, extend);
13107: 
10414:     CGColorSpaceRelease(rgb);
10414:     CGFunctionRelease(gradFunc);
10414: 
42521:     state->action = DO_SHADING;
10414: }
10414: 
42521: static void
10414: _cairo_quartz_setup_radial_source (cairo_quartz_surface_t *surface,
31999: 				   const cairo_radial_pattern_t *rpat,
42521: 				   cairo_rectangle_int_t *extents,
42521: 				   cairo_quartz_drawing_state_t *state)
10414: {
26419:     const cairo_pattern_t *abspat = &rpat->base.base;
10414:     cairo_matrix_t mat;
10414:     CGPoint start, end;
10414:     CGFunctionRef gradFunc;
13107:     CGColorSpaceRef rgb;
10414:     bool extend = abspat->extend == CAIRO_EXTEND_PAD;
31997:     double c1x = _cairo_fixed_to_double (rpat->c1.x);
31997:     double c1y = _cairo_fixed_to_double (rpat->c1.y);
31997:     double c2x = _cairo_fixed_to_double (rpat->c2.x);
31997:     double c2y = _cairo_fixed_to_double (rpat->c2.y);
31997:     double r1 = _cairo_fixed_to_double (rpat->r1);
31997:     double r2 = _cairo_fixed_to_double (rpat->r2);
31997:     double dx = c1x - c2x;
31997:     double dy = c1y - c2y;
31997:     double centerDistance = sqrt (dx*dx + dy*dy);
10414: 
13107:     if (rpat->base.n_stops == 0) {
42521: 	CGContextSetRGBStrokeColor (state->context, 0., 0., 0., 0.);
42521: 	CGContextSetRGBFillColor (state->context, 0., 0., 0., 0.);
42521: 	state->action = DO_SOLID;
42521: 	return;
10414:     }
10414: 
31997:     if (r2 <= centerDistance + r1 + 1e-6 && /* circle 2 doesn't contain circle 1 */
31997:         r1 <= centerDistance + r2 + 1e-6) { /* circle 1 doesn't contain circle 2 */
31997: 	/* Quartz handles cases where neither circle contains the other very
31997: 	 * differently from pixman.
31997: 	 * Whatever the correct behaviour is, let's at least have only pixman's
31997: 	 * implementation to worry about.
31997: 	 * Note that this also catches the cases where r1 == r2.
13107: 	 */
42521: 	_cairo_quartz_setup_fallback_source (surface, abspat, state);
42521: 	return;
13107:     }
13107: 
26419:     mat = abspat->matrix;
13107:     cairo_matrix_invert (&mat);
42521:     _cairo_quartz_cairo_matrix_to_quartz (&mat, &state->transform);
13107: 
10414:     rgb = CGColorSpaceCreateDeviceRGB();
10414: 
31997:     start = CGPointMake (c1x, c1y);
31997:     end = CGPointMake (c2x, c2y);
31997: 
31997:     if (abspat->extend == CAIRO_EXTEND_NONE ||
31997:         abspat->extend == CAIRO_EXTEND_PAD)
31997:     {
26419: 	gradFunc = CreateGradientFunction (&rpat->base);
31997:     } else {
31997: 	gradFunc = CreateRepeatingRadialGradientFunction (surface,
31997: 						          &rpat->base,
31997: 						          &start, &r1,
31999: 						          &end, &r2,
31999: 						          extents);
31997:     }
13107: 
42521:     state->shading = CGShadingCreateRadial (rgb,
10414: 					    start,
31997: 					    r1,
10414: 					    end,
31997: 					    r2,
10414: 					    gradFunc,
10414: 					    extend, extend);
13107: 
10414:     CGColorSpaceRelease(rgb);
10414:     CGFunctionRelease(gradFunc);
10414: 
42521:     state->action = DO_SHADING;
10414: }
10414: 
57379: static void
57379: _cairo_quartz_setup_surface_source (cairo_quartz_surface_t *surface,
57379: 				    const cairo_surface_pattern_t *spat,
57379: 				    cairo_rectangle_int_t *extents,
57379: 				    cairo_quartz_drawing_state_t *state)
57379: {
57379:     const cairo_pattern_t *source = &spat->base;
57379:     CGContextRef context = state->context;
57379: 
57380:     if (source->extend == CAIRO_EXTEND_NONE || source->extend == CAIRO_EXTEND_PAD ||
57379:         (CGContextDrawTiledImagePtr && source->extend == CAIRO_EXTEND_REPEAT))
57379:     {
57379: 	cairo_surface_t *pat_surf = spat->surface;
57379: 	CGImageRef img;
57379: 	cairo_matrix_t m = spat->base.matrix;
57379: 	cairo_rectangle_int_t extents;
57379: 	CGAffineTransform xform;
57379: 	CGRect srcRect;
57379: 	cairo_fixed_t fw, fh;
57379: 	cairo_bool_t is_bounded;
57380: 	cairo_bool_t repeat = source->extend == CAIRO_EXTEND_REPEAT;
57379:         cairo_status_t status;
57379: 
57379:         cairo_matrix_invert(&m);
57379:         _cairo_quartz_cairo_matrix_to_quartz (&m, &state->transform);
57379: 
57379:         /* Draw nonrepeating CGLayer surface using DO_LAYER */
57380:         if (!repeat && cairo_surface_get_type (pat_surf) == CAIRO_SURFACE_TYPE_QUARTZ) {
57379:             cairo_quartz_surface_t *quartz_surf = (cairo_quartz_surface_t *) pat_surf;
57379:             if (quartz_surf->cgLayer) {
57379:          	state->imageRect = CGRectMake (0, 0, quartz_surf->extents.width, quartz_surf->extents.height);
57379:                 state->layer = quartz_surf->cgLayer;
57379:                 state->action = DO_LAYER;
57379:                 return;
57379:             }
57379:         }
57379: 
57379: 	status = _cairo_surface_to_cgimage (pat_surf, &img);
57379:         if (status) {
57379:             state->action = DO_UNSUPPORTED;
57379: 	    return;
57379:         }
57379:         if (img == NULL) {
57379:             state->action = DO_NOTHING;
57379: 	    return;
57379:         }
57379: 
57379:         /* XXXroc what is this for? */
57379: 	CGContextSetRGBFillColor (surface->cgContext, 0, 0, 0, 1);
57379: 
57379: 	state->image = img;
57379: 
57379: 	is_bounded = _cairo_surface_get_extents (pat_surf, &extents);
57379: 	assert (is_bounded);
57379: 
57380: 	if (!repeat) {
57379: 	    state->imageRect = CGRectMake (0, 0, extents.width, extents.height);
57379: 	    state->action = DO_IMAGE;
57379: 	    return;
57379: 	}
57379: 
57379: 	/* Quartz seems to tile images at pixel-aligned regions only -- this
57379: 	 * leads to seams if the image doesn't end up scaling to fill the
57379: 	 * space exactly.  The CGPattern tiling approach doesn't have this
57379: 	 * problem.  Check if we're going to fill up the space (within some
57379: 	 * epsilon), and if not, fall back to the CGPattern type.
57379: 	 */
57379: 
57379: 	xform = CGAffineTransformConcat (CGContextGetCTM (context),
57379: 					 state->transform);
57379: 
57379: 	srcRect = CGRectMake (0, 0, extents.width, extents.height);
57379: 	srcRect = CGRectApplyAffineTransform (srcRect, xform);
57379: 
57379: 	fw = _cairo_fixed_from_double (srcRect.size.width);
57379: 	fh = _cairo_fixed_from_double (srcRect.size.height);
57379: 
57379: 	if ((fw & CAIRO_FIXED_FRAC_MASK) <= CAIRO_FIXED_EPSILON &&
57379: 	    (fh & CAIRO_FIXED_FRAC_MASK) <= CAIRO_FIXED_EPSILON)
57379: 	{
57379: 	    /* We're good to use DrawTiledImage, but ensure that
57379: 	     * the math works out */
57379: 
57379: 	    srcRect.size.width = round(srcRect.size.width);
57379: 	    srcRect.size.height = round(srcRect.size.height);
57379: 
57379: 	    xform = CGAffineTransformInvert (xform);
57379: 
57379: 	    srcRect = CGRectApplyAffineTransform (srcRect, xform);
57379: 
57379: 	    state->imageRect = srcRect;
57379:             state->action = DO_TILED_IMAGE;
57379:             return;
57379: 	}
57379: 
57379: 	/* Fall through to generic SURFACE case */
57379:     }
57379: 
57379:     CGFloat patternAlpha = 1.0f;
57379:     CGColorSpaceRef patternSpace;
57379:     CGPatternRef pattern;
57379:     cairo_int_status_t status;
57379: 
57379:     status = _cairo_quartz_cairo_repeating_surface_pattern_to_quartz (surface, source, &pattern);
57379:     if (status == CAIRO_INT_STATUS_NOTHING_TO_DO) {
57379:         state->action = DO_NOTHING;
57379: 	return;
57379:     }
57379:     if (status) {
57379: 	state->action = DO_UNSUPPORTED;
57379: 	return;
57379:     }
57379: 
57379:     patternSpace = CGColorSpaceCreatePattern (NULL);
57379:     CGContextSetFillColorSpace (context, patternSpace);
57379:     CGContextSetFillPattern (context, pattern, &patternAlpha);
57379:     CGContextSetStrokeColorSpace (context, patternSpace); 
57379:     CGContextSetStrokePattern (context, pattern, &patternAlpha);
57379:     CGColorSpaceRelease (patternSpace);
57379: 
57379:     /* Quartz likes to munge the pattern phase (as yet unexplained
57379:      * why); force it to 0,0 as we've already baked in the correct
57379:      * pattern translation into the pattern matrix
57379:      */
57379:     CGContextSetPatternPhase (context, CGSizeMake(0,0));
57379: 
57379:     state->pattern = pattern;
57379:     state->action = DO_PATTERN;
57379:     return;
57379: }
57379: 
42521: /**
42954:  * Call this before any operation that can modify the contents of a
42954:  * cairo_quartz_surface_t.
42954:  */
42954: static void
42954: _cairo_quartz_surface_will_change (cairo_quartz_surface_t *surface)
42954: {
42954:     if (surface->bitmapContextImage) {
42954:         CGImageRelease (surface->bitmapContextImage);
42954:         surface->bitmapContextImage = NULL;
42954:     }
42954: }
42954: 
42954: /**
42521:  * Sets up internal state to be used to draw the source mask, stored in
42521:  * cairo_quartz_state_t. Guarantees to call CGContextSaveGState on
42521:  * surface->cgContext.
42521:  */
42521: static cairo_quartz_drawing_state_t
42521: _cairo_quartz_setup_state (cairo_quartz_surface_t *surface,
31999: 			   const cairo_pattern_t *source,
42521: 			   cairo_operator_t op,
31999: 			   cairo_rectangle_int_t *extents)
  314: {
42521:     CGContextRef context = surface->cgContext;
42521:     cairo_quartz_drawing_state_t state;
42521:     cairo_status_t status;
42521: 
42521:     state.context = context;
42521:     state.image = NULL;
42521:     state.imageSurface = NULL;
42959:     state.layer = NULL;
42521:     state.shading = NULL;
42521:     state.pattern = NULL;
42521: 
42954:     _cairo_quartz_surface_will_change (surface);
42954: 
42521:     // Save before we change the pattern, colorspace, etc. so that
42521:     // we can restore and make sure that quartz releases our
42521:     // pattern (which may be stack allocated)
42521:     CGContextSaveGState(context);
42521: 
70960:     CGContextSetInterpolationQuality (context, _cairo_quartz_filter_to_quartz (source->filter));
70960: 
42521:     status = _cairo_quartz_surface_set_cairo_operator (surface, op);
42521:     if (status == CAIRO_INT_STATUS_NOTHING_TO_DO) {
42521:         state.action = DO_NOTHING;
42521:         return state;
42521:     }
42521:     if (status) {
42521:         state.action = DO_UNSUPPORTED;
42521:         return state;
42521:     }
12588: 
  314:     if (source->type == CAIRO_PATTERN_TYPE_SOLID) {
  314: 	cairo_solid_pattern_t *solid = (cairo_solid_pattern_t *) source;
  314: 
42521: 	CGContextSetRGBStrokeColor (context,
  314: 				    solid->color.red,
  314: 				    solid->color.green,
  314: 				    solid->color.blue,
  314: 				    solid->color.alpha);
42521: 	CGContextSetRGBFillColor (context,
  314: 				  solid->color.red,
  314: 				  solid->color.green,
  314: 				  solid->color.blue,
  314: 				  solid->color.alpha);
  314: 
42521:         state.action = DO_SOLID;
42521:         return state;
10803:     }
10803: 
10803:     if (source->type == CAIRO_PATTERN_TYPE_LINEAR) {
26419: 	const cairo_linear_pattern_t *lpat = (const cairo_linear_pattern_t *)source;
42521: 	_cairo_quartz_setup_linear_source (surface, lpat, extents, &state);
42521: 	return state;
10803:     }
10803: 
10803:     if (source->type == CAIRO_PATTERN_TYPE_RADIAL) {
26419: 	const cairo_radial_pattern_t *rpat = (const cairo_radial_pattern_t *)source;
42521: 	_cairo_quartz_setup_radial_source (surface, rpat, extents, &state);
42521: 	return state;
10803:     }
10803: 
57379:     if (source->type == CAIRO_PATTERN_TYPE_SURFACE) {
70960:         if (op == CAIRO_OPERATOR_OVER && _cairo_pattern_is_opaque (source, NULL) &&
57384:             CGContextGetAlphaPtr &&
57384:             CGContextGetAlphaPtr (surface->cgContext) == 1.0) {
57384:             // Quartz won't touch pixels outside the bounds of the
57384:             // source surface, so we can just go ahead and use Copy here
57384:             // to accelerate things.
57384:             // Quartz won't necessarily be able to do this optimization internally;
57384:             // for CGLayer surfaces, we can know all the pixels are opaque
57384:             // (because it's CONTENT_COLOR), but Quartz won't know.
57384:             CGContextSetCompositeOperation (context, kPrivateCGCompositeCopy);
57384:         }
57384: 
26419: 	const cairo_surface_pattern_t *spat = (const cairo_surface_pattern_t *) source;
57379:         _cairo_quartz_setup_surface_source (surface, spat, extents, &state);
42521:         return state;
  314:     }
  314: 
42521:     state.action = DO_UNSUPPORTED;
42521:     return state;
  314: }
  314: 
42521: /**
42521:  * 1) Tears down internal state used to draw the source
70960:  * 2) Does CGContextRestoreGState(state->context)
42521:  */
  314: static void
42521: _cairo_quartz_teardown_state (cairo_quartz_drawing_state_t *state)
  314: {
42521:     if (state->image) {
42521: 	CGImageRelease(state->image);
  314:     }
  314: 
42521:     if (state->imageSurface) {
42521: 	cairo_surface_destroy(state->imageSurface);
  314:     }
  314: 
42521:     if (state->shading) {
42521: 	CGShadingRelease(state->shading);
  314:     }
42521: 
42521:     if (state->pattern) {
42521: 	CGPatternRelease(state->pattern);
  314:     }
  314: 
42521:     CGContextRestoreGState(state->context);
42521: }
42521: 
41340: 
41340: static void
70960: _cairo_quartz_draw_image (cairo_quartz_drawing_state_t *state, cairo_operator_t op)
41340: {
42959:     assert (state &&
42959:             ((state->image && (state->action == DO_IMAGE || state->action == DO_TILED_IMAGE)) ||
42959:              (state->layer && state->action == DO_LAYER)));
42521: 
42521:     CGContextConcatCTM (state->context, state->transform);
42521:     CGContextTranslateCTM (state->context, 0, state->imageRect.size.height);
42521:     CGContextScaleCTM (state->context, 1, -1);
42521: 
42959:     if (state->action == DO_TILED_IMAGE) {
42959: 	CGContextDrawTiledImagePtr (state->context, state->imageRect, state->image);
42959: 	/* no need to worry about unbounded operators, since tiled images
42959: 	   fill the entire clip region */
42959:     } else {
42959:         if (state->action == DO_LAYER) {
42959:             /* Note that according to Apple docs it's completely legal
42959:              * to draw a CGLayer to any CGContext, even one it wasn't
42959:              * created for.
42959:              */
42959:             CGContextDrawLayerAtPoint (state->context, state->imageRect.origin,
42959:                                        state->layer);
42959:         } else {
42521:             CGContextDrawImage (state->context, state->imageRect, state->image);
42959:         }
70960: 
70960: 	/* disable this EXTEND_NONE correctness code because we use this path
70960: 	 * for both EXTEND_NONE and EXTEND_PAD */
70960: 	if (0 && !_cairo_operator_bounded_by_source (op)) {
70960: 	    CGContextBeginPath (state->context);
70960: 	    CGContextAddRect (state->context, state->imageRect);
70960: 	    CGContextAddRect (state->context, CGContextGetClipBoundingBox (state->context));
70960: 	    CGContextSetRGBFillColor (state->context, 0, 0, 0, 0);
70960: 	    CGContextEOFillPath (state->context);
70960: 	}
42959:     }
41340: }
41340: 
41340: 
  314: /*
  314:  * get source/dest image implementation
  314:  */
  314: 
  314: /* Read the image from the surface's front buffer */
  314: static cairo_int_status_t
  314: _cairo_quartz_get_image (cairo_quartz_surface_t *surface,
10694: 			 cairo_image_surface_t **image_out)
  314: {
  314:     unsigned char *imageData;
  314:     cairo_image_surface_t *isurf;
  314: 
10414:     if (IS_EMPTY(surface)) {
10414: 	*image_out = (cairo_image_surface_t*) cairo_image_surface_create (CAIRO_FORMAT_ARGB32, 0, 0);
10414: 	return CAIRO_STATUS_SUCCESS;
10414:     }
10414: 
77287:     if (surface->imageSurfaceEquiv) {
57345: 	CGContextFlush(surface->cgContext);
10842: 	*image_out = (cairo_image_surface_t*) cairo_surface_reference(surface->imageSurfaceEquiv);
10842: 	return CAIRO_STATUS_SUCCESS;
10842:     }
10842: 
12588:     if (_cairo_quartz_is_cgcontext_bitmap_context(surface->cgContext)) {
  314: 	unsigned int stride;
  314: 	unsigned int bitinfo;
  314: 	unsigned int bpc, bpp;
  314: 	CGColorSpaceRef colorspace;
  314: 	unsigned int color_comps;
  314: 
77287: 	CGContextFlush(surface->cgContext);
  314: 	imageData = (unsigned char *) CGBitmapContextGetData(surface->cgContext);
10842: 
  314: #ifdef USE_10_3_WORKAROUNDS
  314: 	bitinfo = CGBitmapContextGetAlphaInfo (surface->cgContext);
  314: #else
  314: 	bitinfo = CGBitmapContextGetBitmapInfo (surface->cgContext);
  314: #endif
  314: 	stride = CGBitmapContextGetBytesPerRow (surface->cgContext);
  314: 	bpp = CGBitmapContextGetBitsPerPixel (surface->cgContext);
  314: 	bpc = CGBitmapContextGetBitsPerComponent (surface->cgContext);
  314: 
  314: 	// let's hope they don't add YUV under us
  314: 	colorspace = CGBitmapContextGetColorSpace (surface->cgContext);
  314: 	color_comps = CGColorSpaceGetNumberOfComponents(colorspace);
  314: 
  314: 	// XXX TODO: We can handle all of these by converting to
  314: 	// pixman masks, including non-native-endian masks
  314: 	if (bpc != 8)
  314: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
  314: 
  314: 	if (bpp != 32 && bpp != 8)
  314: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
  314: 
  314: 	if (color_comps != 3 && color_comps != 1)
  314: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
  314: 
  314: 	if (bpp == 32 && color_comps == 3 &&
  314: 	    (bitinfo & kCGBitmapAlphaInfoMask) == kCGImageAlphaPremultipliedFirst &&
  314: 	    (bitinfo & kCGBitmapByteOrderMask) == kCGBitmapByteOrder32Host)
  314: 	{
  314: 	    isurf = (cairo_image_surface_t *)
  314: 		cairo_image_surface_create_for_data (imageData,
  314: 						     CAIRO_FORMAT_ARGB32,
  314: 						     surface->extents.width,
  314: 						     surface->extents.height,
  314: 						     stride);
  314: 	} else if (bpp == 32 && color_comps == 3 &&
  314: 		   (bitinfo & kCGBitmapAlphaInfoMask) == kCGImageAlphaNoneSkipFirst &&
  314: 		   (bitinfo & kCGBitmapByteOrderMask) == kCGBitmapByteOrder32Host)
  314: 	{
  314: 	    isurf = (cairo_image_surface_t *)
  314: 		cairo_image_surface_create_for_data (imageData,
  314: 						     CAIRO_FORMAT_RGB24,
  314: 						     surface->extents.width,
  314: 						     surface->extents.height,
  314: 						     stride);
  314: 	} else if (bpp == 8 && color_comps == 1)
  314: 	{
  314: 	    isurf = (cairo_image_surface_t *)
  314: 		cairo_image_surface_create_for_data (imageData,
  314: 						     CAIRO_FORMAT_A8,
  314: 						     surface->extents.width,
  314: 						     surface->extents.height,
  314: 						     stride);
  314: 	} else {
  314: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
  314: 	}
  314:     } else {
  314: 	return CAIRO_INT_STATUS_UNSUPPORTED;
  314:     }
  314: 
  314:     *image_out = isurf;
  314:     return CAIRO_STATUS_SUCCESS;
  314: }
  314: 
  314: /*
  314:  * Cairo surface backend implementations
  314:  */
  314: 
    1: static cairo_status_t
    1: _cairo_quartz_surface_finish (void *abstract_surface)
    1: {
  314:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
    1: 
  314:     ND((stderr, "_cairo_quartz_surface_finish[%p] cgc: %p\n", surface, surface->cgContext));
  314: 
10414:     if (IS_EMPTY(surface))
10414: 	return CAIRO_STATUS_SUCCESS;
10414: 
  314:     /* Restore our saved gstate that we use to reset clipping */
  314:     CGContextRestoreGState (surface->cgContext);
41340:     _cairo_surface_clipper_reset (&surface->clipper);
  314: 
  314:     CGContextRelease (surface->cgContext);
  314: 
  314:     surface->cgContext = NULL;
  314: 
42954:     if (surface->bitmapContextImage) {
42954:         CGImageRelease (surface->bitmapContextImage);
42954:         surface->bitmapContextImage = NULL;
42954:     }
42954: 
10842:     if (surface->imageSurfaceEquiv) {
59440:         if (surface->ownsData)
57346:             _cairo_image_surface_assume_ownership_of_data (surface->imageSurfaceEquiv);
10842: 	cairo_surface_destroy (surface->imageSurfaceEquiv);
10842: 	surface->imageSurfaceEquiv = NULL;
59440:     } else if (surface->imageData && surface->ownsData) {
57346:         free (surface->imageData);
10842:     }
10842: 
  314:     surface->imageData = NULL;
    1: 
42959:     if (surface->cgLayer) {
42959:         CGLayerRelease (surface->cgLayer);
42959:     }
42959: 
    1:     return CAIRO_STATUS_SUCCESS;
    1: }
    1: 
    1: static cairo_status_t
42959: _cairo_quartz_surface_acquire_image (void *abstract_surface,
    1:                                      cairo_image_surface_t **image_out,
    1:                                      void **image_extra)
    1: {
 8452:     cairo_int_status_t status;
  314:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
    1: 
42959:     *image_extra = NULL;
42959: 
42959:     /* ND((stderr, "%p _cairo_quartz_surface_acquire_image\n", surface)); */
    1: 
10694:     status = _cairo_quartz_get_image (surface, image_out);
42959: 
42959:     if (status == CAIRO_INT_STATUS_UNSUPPORTED && surface->cgLayer) {
42959:         /* copy the layer into a Quartz bitmap context so we can get the data */
42959:         cairo_surface_t *tmp =
43778:             cairo_quartz_surface_create (CAIRO_FORMAT_ARGB32,
42959:                                          surface->extents.width,
42959:                                          surface->extents.height);
42959:         cairo_quartz_surface_t *tmp_surface = (cairo_quartz_surface_t *) tmp;
42959: 
42959:         /* if surface creation failed, we won't have a Quartz surface here */
42959:         if (cairo_surface_get_type (tmp) == CAIRO_SURFACE_TYPE_QUARTZ &&
42959:             tmp_surface->imageSurfaceEquiv) {
42959:             CGContextSaveGState (tmp_surface->cgContext);
42959:             CGContextTranslateCTM (tmp_surface->cgContext, 0, surface->extents.height);
42959:             CGContextScaleCTM (tmp_surface->cgContext, 1, -1);
42959:             /* Note that according to Apple docs it's completely legal
42959:              * to draw a CGLayer to any CGContext, even one it wasn't
42959:              * created for.
42959:              */
42959:             CGContextDrawLayerAtPoint (tmp_surface->cgContext,
42959:                                        CGPointMake (0.0, 0.0),
42959:                                        surface->cgLayer);
42959:             CGContextRestoreGState (tmp_surface->cgContext);
42959: 
42959:             *image_out = (cairo_image_surface_t*)
42959:                 cairo_surface_reference(tmp_surface->imageSurfaceEquiv);
42959:             *image_extra = tmp;
43778:             status = CAIRO_STATUS_SUCCESS;
42959:         } else {
42959:             cairo_surface_destroy (tmp);
42959:         }
42959:     }
42959: 
 8452:     if (status)
 8452: 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 8452: 
 8452:     return CAIRO_STATUS_SUCCESS;
    1: }
    1: 
 4133: static void
 4133: _cairo_quartz_surface_release_source_image (void *abstract_surface,
 4133: 					     cairo_image_surface_t *image,
 4133: 					     void *image_extra)
 4133: {
 4133:     cairo_surface_destroy ((cairo_surface_t *) image);
42959: 
42959:     if (image_extra) {
42959:         cairo_surface_destroy ((cairo_surface_t *) image_extra);
42959:     }
 4133: }
 4133: 
 4133: 
    1: static cairo_status_t
    1: _cairo_quartz_surface_acquire_dest_image (void *abstract_surface,
 4133: 					  cairo_rectangle_int_t *interest_rect,
    1: 					  cairo_image_surface_t **image_out,
 4133: 					  cairo_rectangle_int_t *image_rect,
    1: 					  void **image_extra)
    1: {
  314:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
    1: 
  314:     ND((stderr, "%p _cairo_quartz_surface_acquire_dest_image\n", surface));
    1: 
10694:     *image_rect = surface->extents;
10694:     *image_extra = NULL;
    1: 
42959:     _cairo_quartz_surface_will_change (surface);
42959: 
42959:     return _cairo_quartz_surface_acquire_image (abstract_surface,
42959:         image_out, image_extra);
    1: }
    1: 
    1: static void
    1: _cairo_quartz_surface_release_dest_image (void *abstract_surface,
 4133: 					  cairo_rectangle_int_t *interest_rect,
    1: 					  cairo_image_surface_t *image,
 4133: 					  cairo_rectangle_int_t *image_rect,
    1: 					  void *image_extra)
    1: {
42959:     /* ND((stderr, "%p _cairo_quartz_surface_release_dest_image\n", surface)); */
    1: 
    1:     cairo_surface_destroy ((cairo_surface_t *) image);
42959: 
42959:     if (image_extra) {
42959:         /* we need to write the data from the temp surface back to the layer */
42959:         cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
42959:         cairo_quartz_surface_t *tmp_surface = (cairo_quartz_surface_t *) image_extra;
42959:         CGImageRef img;
42959:         cairo_status_t status = _cairo_surface_to_cgimage (&tmp_surface->base, &img);
42959:         if (status) {
42959:             cairo_surface_destroy (&tmp_surface->base);
42959:             return;
42959:         }
42959: 
42959:         CGContextSaveGState (surface->cgContext);
42959:         CGContextTranslateCTM (surface->cgContext, 0, surface->extents.height);
42959:         CGContextScaleCTM (surface->cgContext, 1, -1);
42959:         CGContextDrawImage (surface->cgContext,
42959:                             CGRectMake (0.0, 0.0, surface->extents.width, surface->extents.height),
42959:                             img);
42959:         CGContextRestoreGState (surface->cgContext);
42959: 
42959:         cairo_surface_destroy (&tmp_surface->base);
42959:     }
    1: }
    1: 
  314: static cairo_surface_t *
  314: _cairo_quartz_surface_create_similar (void *abstract_surface,
  314: 				       cairo_content_t content,
  314: 				       int width,
  314: 				       int height)
    1: {
42959:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
  314:     cairo_format_t format;
    1: 
42959:     if (surface->cgLayer)
57382:         return cairo_quartz_surface_create_cg_layer (abstract_surface, content,
57382:                                                      width, height);
42959: 
  314:     if (content == CAIRO_CONTENT_COLOR_ALPHA)
  314: 	format = CAIRO_FORMAT_ARGB32;
  314:     else if (content == CAIRO_CONTENT_COLOR)
  314: 	format = CAIRO_FORMAT_RGB24;
  314:     else if (content == CAIRO_CONTENT_ALPHA)
  314: 	format = CAIRO_FORMAT_A8;
  314:     else
  314: 	return NULL;
  314: 
 7123:     // verify width and height of surface
11244:     if (!_cairo_quartz_verify_surface_size(width, height)) {
21379: 	return _cairo_surface_create_in_error (_cairo_error
26419: 					       (CAIRO_STATUS_INVALID_SIZE));
 7123:     }
 7123: 
  314:     return cairo_quartz_surface_create (format, width, height);
  314: }
  314: 
  314: static cairo_status_t
  314: _cairo_quartz_surface_clone_similar (void *abstract_surface,
  314: 				     cairo_surface_t *src,
  314: 				     int              src_x,
  314: 				     int              src_y,
  314: 				     int              width,
  314: 				     int              height,
21379: 				     int             *clone_offset_x,
21379: 				     int             *clone_offset_y,
  314: 				     cairo_surface_t **clone_out)
  314: {
  314:     cairo_quartz_surface_t *new_surface = NULL;
  314:     cairo_format_t new_format;
10414:     CGImageRef quartz_image = NULL;
13264:     cairo_status_t status;
  314: 
 7123:     *clone_out = NULL;
 7123: 
 7123:     // verify width and height of surface
11244:     if (!_cairo_quartz_verify_surface_size(width, height)) {
 7123: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 7123:     }
 7123: 
11244:     if (width == 0 || height == 0) {
11244: 	*clone_out = (cairo_surface_t*)
11244: 	    _cairo_quartz_surface_create_internal (NULL, CAIRO_CONTENT_COLOR_ALPHA,
11244: 						   width, height);
21379: 	*clone_offset_x = 0;
21379: 	*clone_offset_y = 0;
11244: 	return CAIRO_STATUS_SUCCESS;
11244:     }
11244: 
70960:     if (_cairo_surface_is_quartz (src)) {
  314: 	cairo_quartz_surface_t *qsurf = (cairo_quartz_surface_t *) src;
10414: 
10414: 	if (IS_EMPTY(qsurf)) {
11244: 	    *clone_out = (cairo_surface_t*)
11244: 		_cairo_quartz_surface_create_internal (NULL, CAIRO_CONTENT_COLOR_ALPHA,
11244: 						       qsurf->extents.width, qsurf->extents.height);
21379: 	    *clone_offset_x = 0;
21379: 	    *clone_offset_y = 0;
10414: 	    return CAIRO_STATUS_SUCCESS;
10414: 	}
10414:     }
10414: 
42959:     status = _cairo_surface_to_cgimage (src, &quartz_image);
13264:     if (status)
  314: 	return CAIRO_INT_STATUS_UNSUPPORTED;
  314: 
11244:     new_format = CAIRO_FORMAT_ARGB32;  /* assumed */
11244:     if (_cairo_surface_is_image (src)) {
11244: 	new_format = ((cairo_image_surface_t *) src)->format;
11244:     }
11244: 
  314:     new_surface = (cairo_quartz_surface_t *)
11244: 	cairo_quartz_surface_create (new_format, width, height);
13264: 
13264:     if (quartz_image == NULL)
13264: 	goto FINISH;
13264: 
 7173:     if (!new_surface || new_surface->base.status) {
 7173: 	CGImageRelease (quartz_image);
  314: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 7173:     }
  314: 
11244:     CGContextSaveGState (new_surface->cgContext);
11244: 
  314:     CGContextSetCompositeOperation (new_surface->cgContext,
  314: 				    kPrivateCGCompositeCopy);
  314: 
11244:     CGContextTranslateCTM (new_surface->cgContext, -src_x, -src_y);
11244:     CGContextDrawImage (new_surface->cgContext,
11244: 			CGRectMake (0, 0, CGImageGetWidth(quartz_image), CGImageGetHeight(quartz_image)),
11244: 			quartz_image);
  314: 
11244:     CGContextRestoreGState (new_surface->cgContext);
11244: 
  314:     CGImageRelease (quartz_image);
  314: 
13264: FINISH:
21379:     *clone_offset_x = src_x;
21379:     *clone_offset_y = src_y;
  314:     *clone_out = (cairo_surface_t*) new_surface;
    1: 
    1:     return CAIRO_STATUS_SUCCESS;
    1: }
    1: 
41340: static cairo_bool_t
    1: _cairo_quartz_surface_get_extents (void *abstract_surface,
 4133: 				   cairo_rectangle_int_t *extents)
    1: {
  314:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
    1: 
  314:     *extents = surface->extents;
41340:     return TRUE;
    1: }
    1: 
  314: static cairo_int_status_t
70960: _cairo_quartz_surface_paint_cg (void *abstract_surface,
  314: 				cairo_operator_t op,
26419: 				const cairo_pattern_t *source,
41340: 				cairo_clip_t *clip)
  314: {
  314:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
  314:     cairo_int_status_t rv = CAIRO_STATUS_SUCCESS;
42521:     cairo_quartz_drawing_state_t state;
  314: 
  314:     ND((stderr, "%p _cairo_quartz_surface_paint op %d source->type %d\n", surface, op, source->type));
  314: 
10414:     if (IS_EMPTY(surface))
10414: 	return CAIRO_STATUS_SUCCESS;
10414: 
41340:     rv = _cairo_surface_clipper_set_clip (&surface->clipper, clip);
41340:     if (unlikely (rv))
41340: 	return rv;
41340: 
42521:     state = _cairo_quartz_setup_state (surface, source, op, NULL);
42521: 
70960:     if (state.action == DO_SOLID || state.action == DO_PATTERN) {
70960: 	CGContextFillRect (state.context, CGRectMake(surface->extents.x,
70960: 						     surface->extents.y,
70960: 						     surface->extents.width,
70960: 						     surface->extents.height));
70960:     } else if (state.action == DO_SHADING) {
70960: 	CGContextConcatCTM (state.context, state.transform);
70960: 	CGContextDrawShading (state.context, state.shading);
70960:     } else if (state.action == DO_IMAGE || state.action == DO_TILED_IMAGE ||
70960:                state.action == DO_LAYER) {
70960: 	_cairo_quartz_draw_image (&state, op);
70960:     } else if (state.action != DO_NOTHING) {
70960: 	rv = CAIRO_INT_STATUS_UNSUPPORTED;
70960:     }
  314: 
42521:     _cairo_quartz_teardown_state (&state);
  314: 
  314:     ND((stderr, "-- paint\n"));
  314:     return rv;
  314: }
  314: 
31999: static cairo_bool_t
31999: _cairo_quartz_source_needs_extents (const cairo_pattern_t *source)
31999: {
31999:     /* For repeating gradients we need to manually extend the gradient and
31999:        repeat stops, since Quartz doesn't support repeating gradients natively.
31999:        We need to minimze the number of repeated stops, and since rasterization
31999:        depends on the number of repetitions we use (even if some of the
31999:        repetitions go beyond the extents of the object or outside the clip
31999:        region), it's important to use the same number of repetitions when
31999:        rendering an object no matter what the clip region is. So the
31999:        computation of the repetition count cannot depended on the clip region,
31999:        and should only depend on the object extents, so we need to compute
31999:        the object extents for repeating gradients. */
31999:     return (source->type == CAIRO_PATTERN_TYPE_LINEAR ||
31999:             source->type == CAIRO_PATTERN_TYPE_RADIAL) &&
31999:            (source->extend == CAIRO_EXTEND_REPEAT ||
31999:             source->extend == CAIRO_EXTEND_REFLECT);
31999: }
31999: 
  314: static cairo_int_status_t
70960: _cairo_quartz_surface_paint (void *abstract_surface,
70960: 			     cairo_operator_t op,
70960: 			     const cairo_pattern_t *source,
70960: 			     cairo_clip_t *clip)
70960: {
70960:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
70960:     cairo_int_status_t rv;
70960:     cairo_image_surface_t *image;
70960: 
70960:     rv = _cairo_quartz_surface_paint_cg (abstract_surface,
70960: 					 op,
70960: 					 source,
70960: 					 clip);
70960: 
70960:     if (likely (rv != CAIRO_INT_STATUS_UNSUPPORTED))
70960: 	return rv;
70960: 
70960:     rv = _cairo_quartz_get_image (surface, &image);
70960:     if (rv == CAIRO_STATUS_SUCCESS) {
70960: 	rv = _cairo_surface_paint (&image->base, op, source, clip);
70960: 	cairo_surface_destroy (&image->base);
70960:     }
70960: 
70960:     return rv;
70960: }
70960: 
70960: static cairo_int_status_t
70960: _cairo_quartz_surface_fill_cg (void *abstract_surface,
  314: 			       cairo_operator_t op,
26419: 			       const cairo_pattern_t *source,
  314: 			       cairo_path_fixed_t *path,
  314: 			       cairo_fill_rule_t fill_rule,
  314: 			       double tolerance,
26419: 			       cairo_antialias_t antialias,
41340: 			       cairo_clip_t *clip)
  314: {
  314:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
  314:     cairo_int_status_t rv = CAIRO_STATUS_SUCCESS;
42521:     cairo_quartz_drawing_state_t state;
70960:     CGPathRef path_for_unbounded = NULL;
  314: 
  314:     ND((stderr, "%p _cairo_quartz_surface_fill op %d source->type %d\n", surface, op, source->type));
  314: 
10414:     if (IS_EMPTY(surface))
10414: 	return CAIRO_STATUS_SUCCESS;
10414: 
41340:     rv = _cairo_surface_clipper_set_clip (&surface->clipper, clip);
41340:     if (unlikely (rv))
41340: 	return rv;
41340: 
31999:     if (_cairo_quartz_source_needs_extents (source))
31999:     {
31999:         /* We don't need precise extents since these are only used to
31999:            compute the number of gradient reptitions needed to cover the
31999:            object. */
31999:         cairo_rectangle_int_t path_extents;
31999:         _cairo_path_fixed_approximate_fill_extents (path, &path_extents);
42521:         state = _cairo_quartz_setup_state (surface, source, op, &path_extents);
31999:     } else {
42521:         state = _cairo_quartz_setup_state (surface, source, op, NULL);
31999:     }
  314: 
42521:     CGContextSetShouldAntialias (state.context, (antialias != CAIRO_ANTIALIAS_NONE));
42521: 
70960:     _cairo_quartz_cairo_path_to_quartz_context (path, state.context);
70960: 
70960:     if (!_cairo_operator_bounded_by_mask(op) && CGContextCopyPathPtr)
70960: 	path_for_unbounded = CGContextCopyPathPtr (state.context);
  314: 
42521:     if (state.action == DO_SOLID || state.action == DO_PATTERN) {
  314: 	if (fill_rule == CAIRO_FILL_RULE_WINDING)
42521: 	    CGContextFillPath (state.context);
  314: 	else
42521: 	    CGContextEOFillPath (state.context);
42521:     } else if (state.action == DO_SHADING) {
  314: 
  314: 	// we have to clip and then paint the shading; we can't fill
  314: 	// with the shading
  314: 	if (fill_rule == CAIRO_FILL_RULE_WINDING)
42521: 	    CGContextClip (state.context);
  314: 	else
42521:             CGContextEOClip (state.context);
42521: 
42521: 	CGContextConcatCTM (state.context, state.transform);
42521: 	CGContextDrawShading (state.context, state.shading);
42959:     } else if (state.action == DO_IMAGE || state.action == DO_TILED_IMAGE ||
42959:                state.action == DO_LAYER) {
 4133: 	if (fill_rule == CAIRO_FILL_RULE_WINDING)
42521: 	    CGContextClip (state.context);
 4133: 	else
42521: 	    CGContextEOClip (state.context);
42521: 
70960: 	_cairo_quartz_draw_image (&state, op);
42521:     } else if (state.action != DO_NOTHING) {
  314: 	rv = CAIRO_INT_STATUS_UNSUPPORTED;
  314:     }
  314: 
42521:     _cairo_quartz_teardown_state (&state);
  314: 
70960:     if (path_for_unbounded) {
70960: 	unbounded_op_data_t ub;
70960: 	ub.op = UNBOUNDED_STROKE_FILL;
70960: 	ub.u.stroke_fill.cgPath = path_for_unbounded;
70960: 	ub.u.stroke_fill.fill_rule = fill_rule;
70960: 
70960: 	_cairo_quartz_fixup_unbounded_operation (surface, &ub, antialias);
70960: 	CGPathRelease (path_for_unbounded);
70960:     }
70960: 
  314:     ND((stderr, "-- fill\n"));
  314:     return rv;
  314: }
  314: 
  314: static cairo_int_status_t
70960: _cairo_quartz_surface_fill (void *abstract_surface,
  314: 			    cairo_operator_t op,
26419: 			    const cairo_pattern_t *source,
  314: 			    cairo_path_fixed_t *path,
70960: 			    cairo_fill_rule_t fill_rule,
70960: 			    double tolerance,
70960: 			    cairo_antialias_t antialias,
70960: 			    cairo_clip_t *clip)
70960: {
70960:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
70960:     cairo_int_status_t rv;
70960:     cairo_image_surface_t *image;
70960: 
70960:     rv = _cairo_quartz_surface_fill_cg (abstract_surface,
70960: 					op,
70960: 					source,
70960: 					path,
70960: 					fill_rule,
70960: 					tolerance,
70960: 					antialias,
70960: 					clip);
70960: 
70960:     if (likely (rv != CAIRO_INT_STATUS_UNSUPPORTED))
70960: 	return rv;
70960: 
70960:     rv = _cairo_quartz_get_image (surface, &image);
70960:     if (rv == CAIRO_STATUS_SUCCESS) {
70960: 	rv = _cairo_surface_fill (&image->base, op, source,
70960: 				  path, fill_rule, tolerance, antialias,
70960: 				  clip);
70960: 	cairo_surface_destroy (&image->base);
70960:     }
70960: 
70960:     return rv;
70960: }
70960: 
70960: static cairo_int_status_t
70960: _cairo_quartz_surface_stroke_cg (void *abstract_surface,
70960: 				 cairo_operator_t op,
70960: 				 const cairo_pattern_t *source,
70960: 				 cairo_path_fixed_t *path,
70960: 				 const cairo_stroke_style_t *style,
70960: 				 const cairo_matrix_t *ctm,
70960: 				 const cairo_matrix_t *ctm_inverse,
  314: 				 double tolerance,
26419: 				 cairo_antialias_t antialias,
41340: 				 cairo_clip_t *clip)
  314: {
  314:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
  314:     cairo_int_status_t rv = CAIRO_STATUS_SUCCESS;
42521:     cairo_quartz_drawing_state_t state;
13979:     CGAffineTransform origCTM, strokeTransform;
70960:     CGPathRef path_for_unbounded = NULL;
  314: 
  314:     ND((stderr, "%p _cairo_quartz_surface_stroke op %d source->type %d\n", surface, op, source->type));
  314: 
10414:     if (IS_EMPTY(surface))
10414: 	return CAIRO_STATUS_SUCCESS;
10414: 
41340:     rv = _cairo_surface_clipper_set_clip (&surface->clipper, clip);
41340:     if (unlikely (rv))
41340: 	return rv;
41340: 
70960:     rv = _cairo_quartz_surface_set_cairo_operator (surface, op);
70960:     if (unlikely (rv))
70960: 	return rv == CAIRO_INT_STATUS_NOTHING_TO_DO ? CAIRO_STATUS_SUCCESS : rv;
70960: 
42521:     if (_cairo_quartz_source_needs_extents (source))
42521:     {
42521: 	cairo_rectangle_int_t path_extents;
42521: 	_cairo_path_fixed_approximate_stroke_extents (path, style, ctm, &path_extents);
42521: 	state = _cairo_quartz_setup_state (surface, source, op, &path_extents);
42521:     } else {
42521: 	state = _cairo_quartz_setup_state (surface, source, op, NULL);
42521:     }
  314: 
13107:     // Turning antialiasing off used to cause misrendering with
13107:     // single-pixel lines (e.g. 20,10.5 -> 21,10.5 end up being rendered as 2 pixels).
13107:     // That's been since fixed in at least 10.5, and in the latest 10.4 dot releases.
42521:     CGContextSetShouldAntialias (state.context, (antialias != CAIRO_ANTIALIAS_NONE));
42521:     CGContextSetLineWidth (state.context, style->line_width);
42521:     CGContextSetLineCap (state.context, _cairo_quartz_cairo_line_cap_to_quartz (style->line_cap));
42521:     CGContextSetLineJoin (state.context, _cairo_quartz_cairo_line_join_to_quartz (style->line_join));
42521:     CGContextSetMiterLimit (state.context, style->miter_limit);
42521: 
42521:     origCTM = CGContextGetCTM (state.context);
13979: 
  314:     if (style->dash && style->num_dashes) {
  314: #define STATIC_DASH 32
70960: 	cairo_quartz_float_t sdash[STATIC_DASH];
70960: 	cairo_quartz_float_t *fdash = sdash;
 8452: 	unsigned int max_dashes = style->num_dashes;
  314: 	unsigned int k;
  314: 
 8452: 	if (style->num_dashes%2)
 8452: 	    max_dashes *= 2;
 8452: 	if (max_dashes > STATIC_DASH)
70960: 	    fdash = _cairo_malloc_ab (max_dashes, sizeof (cairo_quartz_float_t));
 8452: 	if (fdash == NULL)
 8452: 	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
  314: 
 8452: 	for (k = 0; k < max_dashes; k++)
70960: 	    fdash[k] = (cairo_quartz_float_t) style->dash[k % style->num_dashes];
70960: 
70960: 	CGContextSetLineDash (surface->cgContext, style->dash_offset, fdash, max_dashes);
  314: 	if (fdash != sdash)
  314: 	    free (fdash);
41340:     } else
42521: 	CGContextSetLineDash (state.context, 0, NULL, 0);
  314: 
70960: 
70960:     _cairo_quartz_cairo_path_to_quartz_context (path, state.context);
70960: 
41340:     _cairo_quartz_cairo_matrix_to_quartz (ctm, &strokeTransform);
42521:     CGContextConcatCTM (state.context, strokeTransform);
42521: 
70960:     if (!_cairo_operator_bounded_by_mask (op) && CGContextCopyPathPtr)
70960: 	path_for_unbounded = CGContextCopyPathPtr (state.context);
  314: 
42521:     if (state.action == DO_SOLID || state.action == DO_PATTERN) {
42521: 	CGContextStrokePath (state.context);
42959:     } else if (state.action == DO_IMAGE || state.action == DO_TILED_IMAGE ||
42959:                state.action == DO_LAYER) {
42521: 	CGContextReplacePathWithStrokedPath (state.context);
42521: 	CGContextClip (state.context);
42521: 
42521: 	CGContextSetCTM (state.context, origCTM);
70960: 	_cairo_quartz_draw_image (&state, op);
42521:     } else if (state.action == DO_SHADING) {
42521: 	CGContextReplacePathWithStrokedPath (state.context);
42521: 	CGContextClip (state.context);
42521: 
42521: 	CGContextSetCTM (state.context, origCTM);
42521: 
42521: 	CGContextConcatCTM (state.context, state.transform);
42521: 	CGContextDrawShading (state.context, state.shading);
42521:     } else if (state.action != DO_NOTHING) {
  314: 	rv = CAIRO_INT_STATUS_UNSUPPORTED;
42521: 	goto BAIL;
  314:     }
  314: 
70960:     if (path_for_unbounded) {
70960: 	unbounded_op_data_t ub;
70960: 	ub.op = UNBOUNDED_STROKE_FILL;
70960: 	ub.u.stroke_fill.fill_rule = CAIRO_FILL_RULE_WINDING;
70960: 
70960: 	CGContextBeginPath (state.context);
70960: 	CGContextAddPath (state.context, path_for_unbounded);
70960: 	CGPathRelease (path_for_unbounded);
70960: 
70960: 	CGContextSaveGState (state.context);
70960: 	CGContextConcatCTM (state.context, strokeTransform);
70960: 	CGContextReplacePathWithStrokedPath (state.context);
70960: 	CGContextRestoreGState (state.context);
70960: 
70960: 	ub.u.stroke_fill.cgPath = CGContextCopyPathPtr (state.context);
70960: 
70960: 	_cairo_quartz_fixup_unbounded_operation (surface, &ub, antialias);
70960: 	CGPathRelease (ub.u.stroke_fill.cgPath);
70960:     }
70960: 
42449:   BAIL:
42521:     _cairo_quartz_teardown_state (&state);
42439: 
  314:     ND((stderr, "-- stroke\n"));
  314:     return rv;
  314: }
  314: 
70960: static cairo_int_status_t
70960: _cairo_quartz_surface_stroke (void *abstract_surface,
70960: 			      cairo_operator_t op,
70960: 			      const cairo_pattern_t *source,
70960: 			      cairo_path_fixed_t *path,
70960: 			      const cairo_stroke_style_t *style,
70960: 			      const cairo_matrix_t *ctm,
70960: 			      const cairo_matrix_t *ctm_inverse,
70960: 			      double tolerance,
70960: 			      cairo_antialias_t antialias,
70960: 			      cairo_clip_t *clip)
70960: {
70960:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
70960:     cairo_int_status_t rv;
70960:     cairo_image_surface_t *image;
70960: 
70960:     rv = _cairo_quartz_surface_stroke_cg (abstract_surface, op, source,
70960: 					  path, style, ctm, ctm_inverse,
70960: 					  tolerance, antialias,
70960: 					  clip);
70960: 
70960:     if (likely (rv != CAIRO_INT_STATUS_UNSUPPORTED))
70960: 	return rv;
70960: 
70960:     rv = _cairo_quartz_get_image (surface, &image);
70960:     if (rv == CAIRO_STATUS_SUCCESS) {
70960: 	rv = _cairo_surface_stroke (&image->base, op, source,
70960: 				    path, style, ctm, ctm_inverse,
70960: 				    tolerance, antialias,
70960: 				    clip);
70960: 	cairo_surface_destroy (&image->base);
70960:     }
70960: 
70960:     return rv;
70960: }
70960: 
13979: #if CAIRO_HAS_QUARTZ_FONT
  314: static cairo_int_status_t
70960: _cairo_quartz_surface_show_glyphs_cg (void *abstract_surface,
  314: 				      cairo_operator_t op,
26419: 				      const cairo_pattern_t *source,
  314: 				      cairo_glyph_t *glyphs,
  314: 				      int num_glyphs,
16122: 				      cairo_scaled_font_t *scaled_font,
41340: 				      cairo_clip_t *clip,
41340: 				      int *remaining_glyphs)
  314: {
70960:     CGAffineTransform textTransform, ctm, invTextTransform;
 4133: #define STATIC_BUF_SIZE 64
 4133:     CGGlyph glyphs_static[STATIC_BUF_SIZE];
 4133:     CGSize cg_advances_static[STATIC_BUF_SIZE];
 4133:     CGGlyph *cg_glyphs = &glyphs_static[0];
 4133:     CGSize *cg_advances = &cg_advances_static[0];
 4133: 
70960:     cairo_rectangle_int_t glyph_extents;
  314:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
  314:     cairo_int_status_t rv = CAIRO_STATUS_SUCCESS;
42521:     cairo_quartz_drawing_state_t state;
70960:     cairo_quartz_float_t xprev, yprev;
  314:     int i;
13107:     CGFontRef cgfref = NULL;
13107: 
13107:     cairo_bool_t isClipping = FALSE;
13111:     cairo_bool_t didForceFontSmoothing = FALSE;
59761:     cairo_antialias_t effective_antialiasing;
  314: 
10414:     if (IS_EMPTY(surface))
10414: 	return CAIRO_STATUS_SUCCESS;
10414: 
  314:     if (num_glyphs <= 0)
  314: 	return CAIRO_STATUS_SUCCESS;
  314: 
13979:     if (cairo_scaled_font_get_type (scaled_font) != CAIRO_FONT_TYPE_QUARTZ)
  314: 	return CAIRO_INT_STATUS_UNSUPPORTED;
  314: 
41340:     rv = _cairo_surface_clipper_set_clip (&surface->clipper, clip);
41340:     if (unlikely (rv))
41340: 	return rv;
41340: 
70960:     if (_cairo_quartz_source_needs_extents (source) &&
70960: 	!_cairo_scaled_font_glyph_device_extents (scaled_font, glyphs, num_glyphs,
70960: 						  &glyph_extents, NULL))
31999:     {
42521:         state = _cairo_quartz_setup_state (surface, source, op, &glyph_extents);
31999:     } else {
42521:         state = _cairo_quartz_setup_state (surface, source, op, NULL);
31999:     }
31999: 
42521:     if (state.action == DO_SOLID || state.action == DO_PATTERN) {
42521: 	CGContextSetTextDrawingMode (state.context, kCGTextFill);
42959:     } else if (state.action == DO_IMAGE || state.action == DO_TILED_IMAGE ||
42959:                state.action == DO_SHADING || state.action == DO_LAYER) {
42521: 	CGContextSetTextDrawingMode (state.context, kCGTextClip);
13107: 	isClipping = TRUE;
  314:     } else {
42521: 	if (state.action != DO_NOTHING)
 8452: 	    rv = CAIRO_INT_STATUS_UNSUPPORTED;
 8452: 	goto BAIL;
  314:     }
  314: 
10414:     /* this doesn't addref */
13979:     cgfref = _cairo_quartz_scaled_font_get_cg_font_ref (scaled_font);
42521:     CGContextSetFont (state.context, cgfref);
42521:     CGContextSetFontSize (state.context, 1.0);
  314: 
59761:     effective_antialiasing = scaled_font->options.antialias;
59761:     if (effective_antialiasing == CAIRO_ANTIALIAS_SUBPIXEL &&
59761:         !surface->base.permit_subpixel_antialiasing) {
59761:         effective_antialiasing = CAIRO_ANTIALIAS_GRAY;
59761:     }
59761: 
13107:     switch (scaled_font->options.antialias) {
13107: 	case CAIRO_ANTIALIAS_SUBPIXEL:
42521: 	    CGContextSetShouldAntialias (state.context, TRUE);
42521: 	    CGContextSetShouldSmoothFonts (state.context, TRUE);
13107: 	    if (CGContextSetAllowsFontSmoothingPtr &&
42521: 		!CGContextGetAllowsFontSmoothingPtr (state.context))
13107: 	    {
13107: 		didForceFontSmoothing = TRUE;
42521: 		CGContextSetAllowsFontSmoothingPtr (state.context, TRUE);
13107: 	    }
13107: 	    break;
13107: 	case CAIRO_ANTIALIAS_NONE:
42521: 	    CGContextSetShouldAntialias (state.context, FALSE);
13107: 	    break;
13107: 	case CAIRO_ANTIALIAS_GRAY:
42521: 	    CGContextSetShouldAntialias (state.context, TRUE);
42521: 	    CGContextSetShouldSmoothFonts (state.context, FALSE);
13107: 	    break;
13107: 	case CAIRO_ANTIALIAS_DEFAULT:
13107: 	    /* Don't do anything */
13107: 	    break;
13107:     }
13107: 
  314:     if (num_glyphs > STATIC_BUF_SIZE) {
 4133: 	cg_glyphs = (CGGlyph*) _cairo_malloc_ab (num_glyphs, sizeof(CGGlyph));
 8452: 	if (cg_glyphs == NULL) {
 8452: 	    rv = _cairo_error (CAIRO_STATUS_NO_MEMORY);
 8452: 	    goto BAIL;
 8452: 	}
 8452: 
 4133: 	cg_advances = (CGSize*) _cairo_malloc_ab (num_glyphs, sizeof(CGSize));
 8452: 	if (cg_advances == NULL) {
 8452: 	    rv = _cairo_error (CAIRO_STATUS_NO_MEMORY);
 8452: 	    goto BAIL;
 8452: 	}
  314:     }
  314: 
70960:     /* scale(1,-1) * scaled_font->scale */
70960:     textTransform = CGAffineTransformMake (scaled_font->scale.xx,
70960: 					   scaled_font->scale.yx,
70960: 					   -scaled_font->scale.xy,
70960: 					   -scaled_font->scale.yy,
70960: 					   0, 0);
70960: 
70960:     /* scaled_font->scale_inverse * scale(1,-1) */
70960:     invTextTransform = CGAffineTransformMake (scaled_font->scale_inverse.xx,
70960: 					      -scaled_font->scale_inverse.yx,
70960: 					      scaled_font->scale_inverse.xy,
70960: 					      -scaled_font->scale_inverse.yy,
70960: 					      0.0, 0.0);
70960: 
70960:     CGContextSetTextMatrix (state.context, CGAffineTransformIdentity);
13107: 
13107:     /* Convert our glyph positions to glyph advances.  We need n-1 advances,
13107:      * since the advance at index 0 is applied after glyph 0. */
 4133:     xprev = glyphs[0].x;
 4133:     yprev = glyphs[0].y;
  361: 
  361:     cg_glyphs[0] = glyphs[0].index;
  361: 
  361:     for (i = 1; i < num_glyphs; i++) {
70960: 	cairo_quartz_float_t xf = glyphs[i].x;
70960: 	cairo_quartz_float_t yf = glyphs[i].y;
 4133: 	cg_glyphs[i] = glyphs[i].index;
70960: 	cg_advances[i - 1] = CGSizeApplyAffineTransform(CGSizeMake (xf - xprev, yf - yprev), invTextTransform);
  361: 	xprev = xf;
  361: 	yprev = yf;
  361:     }
  314: 
13107:     /* Translate to the first glyph's position before drawing */
42521:     ctm = CGContextGetCTM (state.context);
42521:     CGContextTranslateCTM (state.context, glyphs[0].x, glyphs[0].y);
70960:     CGContextConcatCTM (state.context, textTransform);
42521: 
42521:     CGContextShowGlyphsWithAdvances (state.context,
  314: 				     cg_glyphs,
  314: 				     cg_advances,
  314: 				     num_glyphs);
  314: 
42521:     CGContextSetCTM (state.context, ctm);
42521: 
42959:     if (state.action == DO_IMAGE || state.action == DO_TILED_IMAGE ||
42959:         state.action == DO_LAYER) {
70960: 	_cairo_quartz_draw_image (&state, op);
42521:     } else if (state.action == DO_SHADING) {
42521: 	CGContextConcatCTM (state.context, state.transform);
42521: 	CGContextDrawShading (state.context, state.shading);
 4133:     }
  314: 
 8452: BAIL:
13107:     if (didForceFontSmoothing)
42521:         CGContextSetAllowsFontSmoothingPtr (state.context, FALSE);
42521: 
42521:     _cairo_quartz_teardown_state (&state);
13107: 
70960:     if (rv == CAIRO_STATUS_SUCCESS &&
70960: 	cgfref &&
70960: 	!_cairo_operator_bounded_by_mask (op))
70960:     {
70960: 	unbounded_op_data_t ub;
70960: 	ub.op = UNBOUNDED_SHOW_GLYPHS;
70960: 
70960: 	ub.u.show_glyphs.isClipping = isClipping;
70960: 	ub.u.show_glyphs.cg_glyphs = cg_glyphs;
70960: 	ub.u.show_glyphs.cg_advances = cg_advances;
70960: 	ub.u.show_glyphs.nglyphs = num_glyphs;
70960: 	ub.u.show_glyphs.textTransform = textTransform;
70960: 	ub.u.show_glyphs.font = cgfref;
70960: 	ub.u.show_glyphs.origin = CGPointMake (glyphs[0].x, glyphs[0].y);
70960: 
70960: 	_cairo_quartz_fixup_unbounded_operation (surface, &ub, scaled_font->options.antialias);
70960:     }
70960: 
70960: 
 8452:     if (cg_advances != &cg_advances_static[0]) {
 8452: 	free (cg_advances);
 8452:     }
 8452: 
 8452:     if (cg_glyphs != &glyphs_static[0]) {
 8452: 	free (cg_glyphs);
 8452:     }
 8452: 
  314:     return rv;
  314: }
13979: #endif /* CAIRO_HAS_QUARTZ_FONT */
  314: 
  314: static cairo_int_status_t
70960: _cairo_quartz_surface_show_glyphs (void *abstract_surface,
70960: 				   cairo_operator_t op,
70960: 				   const cairo_pattern_t *source,
70960: 				   cairo_glyph_t *glyphs,
70960: 				   int num_glyphs,
70960: 				   cairo_scaled_font_t *scaled_font,
70960: 				   cairo_clip_t *clip,
70960: 				   int *remaining_glyphs)
70960: {
70960:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
70960:     cairo_int_status_t rv = CAIRO_INT_STATUS_UNSUPPORTED;
70960:     cairo_image_surface_t *image;
70960: 
70960: #if CAIRO_HAS_QUARTZ_FONT
70960:     rv = _cairo_quartz_surface_show_glyphs_cg (abstract_surface, op, source,
70960: 					       glyphs, num_glyphs,
70960: 					       scaled_font, clip, remaining_glyphs);
70960: 
70960:     if (likely (rv != CAIRO_INT_STATUS_UNSUPPORTED))
70960: 	return rv;
70960: 
70960: #endif
70960: 
70960:     rv = _cairo_quartz_get_image (surface, &image);
70960:     if (rv == CAIRO_STATUS_SUCCESS) {
70960: 	rv = _cairo_surface_show_text_glyphs (&image->base, op, source,
70960: 					      NULL, 0,
70960: 					      glyphs, num_glyphs,
70960: 					      NULL, 0, 0,
70960: 					      scaled_font, clip);
70960: 	cairo_surface_destroy (&image->base);
70960:     }
70960: 
70960:     return rv;
70960: }
70960: 
70960: static cairo_int_status_t
 8452: _cairo_quartz_surface_mask_with_surface (cairo_quartz_surface_t *surface,
 8452:                                          cairo_operator_t op,
26419:                                          const cairo_pattern_t *source,
26419:                                          const cairo_surface_pattern_t *mask,
41340: 					 cairo_clip_t *clip)
 8452: {
 8452:     CGRect rect;
 8452:     CGImageRef img;
 8452:     cairo_surface_t *pat_surf = mask->surface;
 8452:     cairo_status_t status = CAIRO_STATUS_SUCCESS;
12588:     CGAffineTransform ctm, mask_matrix;
 8452: 
42959:     status = _cairo_surface_to_cgimage (pat_surf, &img);
 8452:     if (status)
 8452: 	return status;
41340:     if (img == NULL) {
41340: 	if (!_cairo_operator_bounded_by_mask (op))
41340: 	    CGContextClearRect (surface->cgContext, CGContextGetClipBoundingBox (surface->cgContext));
13264: 	return CAIRO_STATUS_SUCCESS;
41340:     }
41340: 
41340:     rect = CGRectMake (0.0f, 0.0f, CGImageGetWidth (img) , CGImageGetHeight (img));
12588: 
70960:     CGContextSaveGState (surface->cgContext);
12588: 
12588:     /* ClipToMask is essentially drawing an image, so we need to flip the CTM
12588:      * to get the image to appear oriented the right way */
70960:     ctm = CGContextGetCTM (surface->cgContext);
12588: 
12588:     _cairo_quartz_cairo_matrix_to_quartz (&mask->base.matrix, &mask_matrix);
41340:     mask_matrix = CGAffineTransformInvert(mask_matrix);
41340:     mask_matrix = CGAffineTransformTranslate (mask_matrix, 0.0, CGImageGetHeight (img));
41340:     mask_matrix = CGAffineTransformScale (mask_matrix, 1.0, -1.0);
41340: 
70960:     CGContextConcatCTM (surface->cgContext, mask_matrix);
70960:     CGContextClipToMaskPtr (surface->cgContext, rect, img);
70960: 
70960:     CGContextSetCTM (surface->cgContext, ctm);
70960: 
70960:     status = _cairo_quartz_surface_paint_cg (surface, op, source, clip);
70960: 
70960:     CGContextRestoreGState (surface->cgContext);
70960: 
70960:     if (!_cairo_operator_bounded_by_mask (op)) {
70960: 	unbounded_op_data_t ub;
70960: 	ub.op = UNBOUNDED_MASK;
70960: 	ub.u.mask.mask = img;
70960: 	ub.u.mask.maskTransform = mask_matrix;
70960: 	_cairo_quartz_fixup_unbounded_operation (surface, &ub, CAIRO_ANTIALIAS_NONE);
70960:     }
13107: 
 8452:     CGImageRelease (img);
13264: 
 8452:     return status;
 8452: }
 8452: 
12588: /* This is somewhat less than ideal, but it gets the job done;
12588:  * it would be better to avoid calling back into cairo.  This
12588:  * creates a temporary surface to use as the mask.
12588:  */
12588: static cairo_int_status_t
12588: _cairo_quartz_surface_mask_with_generic (cairo_quartz_surface_t *surface,
12588: 					 cairo_operator_t op,
26419: 					 const cairo_pattern_t *source,
26419: 					 const cairo_pattern_t *mask,
41340: 					 cairo_clip_t *clip)
12588: {
41340:     int width = surface->extents.width;
41340:     int height = surface->extents.height;
12588: 
12588:     cairo_surface_t *gradient_surf = NULL;
16122:     cairo_surface_pattern_t surface_pattern;
12588:     cairo_int_status_t status;
12588: 
12588:     /* Render the gradient to a surface */
41340:     gradient_surf = cairo_quartz_surface_create (CAIRO_FORMAT_A8,
12588: 						 width,
12588: 						 height);
41340: 
41340:     status = _cairo_quartz_surface_paint (gradient_surf, CAIRO_OPERATOR_SOURCE, mask, NULL);
12588:     if (status)
12588: 	goto BAIL;
12588: 
16122:     _cairo_pattern_init_for_surface (&surface_pattern, gradient_surf);
16122: 
41340:     status = _cairo_quartz_surface_mask_with_surface (surface, op, source, &surface_pattern, clip);
12588: 
12588:     _cairo_pattern_fini (&surface_pattern.base);
12588: 
12588:   BAIL:
12588:     if (gradient_surf)
12588: 	cairo_surface_destroy (gradient_surf);
12588: 
12588:     return status;
12588: }
12588: 
 8452: static cairo_int_status_t
70960: _cairo_quartz_surface_mask_cg (void *abstract_surface,
70960: 			       cairo_operator_t op,
70960: 			       const cairo_pattern_t *source,
70960: 			       const cairo_pattern_t *mask,
70960: 			       cairo_clip_t *clip)
70960: {
70960:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
70960:     cairo_int_status_t rv = CAIRO_STATUS_SUCCESS;
70960: 
70960:     ND((stderr, "%p _cairo_quartz_surface_mask op %d source->type %d mask->type %d\n", surface, op, source->type, mask->type));
70960: 
70960:     if (IS_EMPTY(surface))
70960: 	return CAIRO_STATUS_SUCCESS;
70960: 
70960:     rv = _cairo_surface_clipper_set_clip (&surface->clipper, clip);
70960:     if (unlikely (rv))
70960: 	return rv;
70960: 
70960:     /* Using CGContextSetAlpha to implement mask alpha doesn't work for all operators. */
70960:     if (mask->type == CAIRO_PATTERN_TYPE_SOLID &&
70960:         op == CAIRO_OPERATOR_OVER) {
70960: 	/* This is easy; we just need to paint with the alpha. */
70960: 	cairo_solid_pattern_t *solid_mask = (cairo_solid_pattern_t *) mask;
70960: 
70960: 	CGContextSetAlpha (surface->cgContext, solid_mask->color.alpha);
70960: 	rv = _cairo_quartz_surface_paint_cg (surface, op, source, clip);
70960: 	CGContextSetAlpha (surface->cgContext, 1.0);
70960: 
70960: 	return rv;
70960:     }
70960: 
70960:     /* If we have CGContextClipToMask, we can do more complex masks */
70960:     if (CGContextClipToMaskPtr) {
70960: 	/* For these, we can skip creating a temporary surface, since we already have one */
94969: 	/* For some reason this doesn't work reliably on OS X 10.5.  See bug 721663. */
94969: 	if (_cairo_quartz_osx_version >= 0x1060 && mask->type == CAIRO_PATTERN_TYPE_SURFACE &&
94969: 	    mask->extend == CAIRO_EXTEND_NONE) {
70960: 	    return _cairo_quartz_surface_mask_with_surface (surface, op, source, (cairo_surface_pattern_t *) mask, clip);
94969: 	}
70960: 
70960: 	return _cairo_quartz_surface_mask_with_generic (surface, op, source, mask, clip);
70960:     }
70960: 
70960:     /* So, CGContextClipToMask is not present in 10.3.9, so we're
70960:      * doomed; if we have imageData, we can do fallback, otherwise
70960:      * just pretend success.
70960:      */
70960:     if (surface->imageData)
70960: 	return CAIRO_INT_STATUS_UNSUPPORTED;
70960: 
70960:     return CAIRO_STATUS_SUCCESS;
70960: }
70960: 
70960: static cairo_int_status_t
70918: _cairo_quartz_surface_mask (void *abstract_surface,
70871: 			    cairo_operator_t op,
70871: 			    const cairo_pattern_t *source,
70871: 			    const cairo_pattern_t *mask,
70871: 			    cairo_clip_t *clip)
70871: {
70871:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
70960:     cairo_int_status_t rv;
70960:     cairo_image_surface_t *image;
70960: 
70960:     rv = _cairo_quartz_surface_mask_cg (abstract_surface,
70960: 					op,
70960: 					source,
70960: 					mask,
70960: 					clip);
70960: 
70960:     if (likely (rv != CAIRO_INT_STATUS_UNSUPPORTED))
70871: 	return rv;
70871: 
70960:     rv = _cairo_quartz_get_image (surface, &image);
70960:     if (rv == CAIRO_STATUS_SUCCESS) {
70960: 	rv = _cairo_surface_mask (&image->base, op, source, mask, clip);
70960: 	cairo_surface_destroy (&image->base);
70960:     }
70871: 
70871:     return rv;
70871: }
70871: 
41340: static cairo_status_t
41340: _cairo_quartz_surface_clipper_intersect_clip_path (cairo_surface_clipper_t *clipper,
  314: 						   cairo_path_fixed_t *path,
  314: 						   cairo_fill_rule_t fill_rule,
  314: 						   double tolerance,
  314: 						   cairo_antialias_t antialias)
  314: {
41340:     cairo_quartz_surface_t *surface =
41340: 	cairo_container_of (clipper, cairo_quartz_surface_t, clipper);
  314: 
  314:     ND((stderr, "%p _cairo_quartz_surface_intersect_clip_path path: %p\n", surface, path));
  314: 
10414:     if (IS_EMPTY(surface))
10414: 	return CAIRO_STATUS_SUCCESS;
10414: 
  314:     if (path == NULL) {
  314: 	/* If we're being asked to reset the clip, we can only do it
  314: 	 * by restoring the gstate to our previous saved one, and
  314: 	 * saving it again.
  314: 	 *
  314: 	 * Note that this assumes that ALL quartz surface creation
  314: 	 * functions will do a SaveGState first; we do this in create_internal.
  314: 	 */
  314: 	CGContextRestoreGState (surface->cgContext);
  314: 	CGContextSaveGState (surface->cgContext);
  314:     } else {
13107: 	CGContextSetShouldAntialias (surface->cgContext, (antialias != CAIRO_ANTIALIAS_NONE));
13107: 
70960: 	_cairo_quartz_cairo_path_to_quartz_context (path, surface->cgContext);
 8452: 
  314: 	if (fill_rule == CAIRO_FILL_RULE_WINDING)
  314: 	    CGContextClip (surface->cgContext);
  314: 	else
  314: 	    CGContextEOClip (surface->cgContext);
  314:     }
  314: 
  314:     ND((stderr, "-- intersect_clip_path\n"));
  314: 
  314:     return CAIRO_STATUS_SUCCESS;
  314: }
  314: 
86771: static cairo_status_t
86771: _cairo_quartz_surface_mark_dirty_rectangle (void *abstract_surface,
86771: 					    int x, int y,
86771: 					    int width, int height)
86771: {
86771:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
86771:     _cairo_quartz_surface_will_change (surface);
86771:     return CAIRO_STATUS_SUCCESS;
86771: }
86771: 
86771: 
  314: // XXXtodo implement show_page; need to figure out how to handle begin/end
  314: 
    1: static const struct _cairo_surface_backend cairo_quartz_surface_backend = {
    1:     CAIRO_SURFACE_TYPE_QUARTZ,
  314:     _cairo_quartz_surface_create_similar,
    1:     _cairo_quartz_surface_finish,
42959:     _cairo_quartz_surface_acquire_image,
 4133:     _cairo_quartz_surface_release_source_image,
    1:     _cairo_quartz_surface_acquire_dest_image,
    1:     _cairo_quartz_surface_release_dest_image,
  314:     _cairo_quartz_surface_clone_similar,
    1:     NULL, /* composite */
    1:     NULL, /* fill_rectangles */
    1:     NULL, /* composite_trapezoids */
26419:     NULL, /* create_span_renderer */
26419:     NULL, /* check_span_renderer */
    1:     NULL, /* copy_page */
    1:     NULL, /* show_page */
    1:     _cairo_quartz_surface_get_extents,
  314:     NULL, /* old_show_glyphs */
  314:     NULL, /* get_font_options */
  314:     NULL, /* flush */
86771:     _cairo_quartz_surface_mark_dirty_rectangle,
  314:     NULL, /* scaled_font_fini */
  314:     NULL, /* scaled_glyph_fini */
  314: 
  314:     _cairo_quartz_surface_paint,
  314:     _cairo_quartz_surface_mask,
  314:     _cairo_quartz_surface_stroke,
  314:     _cairo_quartz_surface_fill,
  314:     _cairo_quartz_surface_show_glyphs,
  314: 
42958:     NULL, /* snapshot */
 7173:     NULL, /* is_similar */
 7173:     NULL  /* fill_stroke */
    1: };
    1: 
10414: cairo_quartz_surface_t *
  314: _cairo_quartz_surface_create_internal (CGContextRef cgContext,
  314: 					cairo_content_t content,
  314: 					unsigned int width,
  314: 					unsigned int height)
    1: {
    1:     cairo_quartz_surface_t *surface;
    1: 
10415:     quartz_ensure_symbols();
10415: 
  314:     /* Init the base surface */
    1:     surface = malloc(sizeof(cairo_quartz_surface_t));
10694:     if (surface == NULL)
10694: 	return (cairo_quartz_surface_t*) _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_NO_MEMORY));
  314: 
  314:     memset(surface, 0, sizeof(cairo_quartz_surface_t));
  314: 
70960:     _cairo_surface_init (&surface->base,
70960: 			 &cairo_quartz_surface_backend,
70960: 			 NULL, /* device */
  314: 			 content);
  314: 
41340:     _cairo_surface_clipper_init (&surface->clipper,
41340: 				 _cairo_quartz_surface_clipper_intersect_clip_path);
41340: 
  314:     /* Save our extents */
  314:     surface->extents.x = surface->extents.y = 0;
  314:     surface->extents.width = width;
  314:     surface->extents.height = height;
  314: 
10414:     if (IS_EMPTY(surface)) {
10414: 	surface->cgContext = NULL;
10414: 	surface->cgContextBaseCTM = CGAffineTransformIdentity;
10414: 	surface->imageData = NULL;
10414: 	return surface;
10414:     }
10414: 
  314:     /* Save so we can always get back to a known-good CGContext -- this is
  314:      * required for proper behaviour of intersect_clip_path(NULL)
  314:      */
  314:     CGContextSaveGState (cgContext);
  314: 
  314:     surface->cgContext = cgContext;
  314:     surface->cgContextBaseCTM = CGContextGetCTM (cgContext);
  314: 
  314:     surface->imageData = NULL;
10842:     surface->imageSurfaceEquiv = NULL;
42954:     surface->bitmapContextImage = NULL;
42959:     surface->cgLayer = NULL;
59440:     surface->ownsData = TRUE;
  314: 
  314:     return surface;
  314: }
  314: 
  314: /**
  314:  * cairo_quartz_surface_create_for_cg_context
  314:  * @cgContext: the existing CGContext for which to create the surface
  314:  * @width: width of the surface, in pixels
  314:  * @height: height of the surface, in pixels
  314:  *
  314:  * Creates a Quartz surface that wraps the given CGContext.  The
13979:  * CGContext is assumed to be in the standard Cairo coordinate space
13979:  * (that is, with the origin at the upper left and the Y axis
13979:  * increasing downward).  If the CGContext is in the Quartz coordinate
13979:  * space (with the origin at the bottom left), then it should be
13979:  * flipped before this function is called.  The flip can be accomplished
13979:  * using a translate and a scale; for example:
  314:  *
  314:  * <informalexample><programlisting>
10414:  * CGContextTranslateCTM (cgContext, 0.0, height);
  314:  * CGContextScaleCTM (cgContext, 1.0, -1.0);
  314:  * </programlisting></informalexample>
  314:  *
13979:  * All Cairo operations are implemented in terms of Quartz operations,
13979:  * as long as Quartz-compatible elements are used (such as Quartz fonts).
  314:  *
  314:  * Return value: the newly created Cairo surface.
  314:  *
  314:  * Since: 1.4
  314:  **/
  314: 
  314: cairo_surface_t *
  314: cairo_quartz_surface_create_for_cg_context (CGContextRef cgContext,
  314: 					    unsigned int width,
  314: 					    unsigned int height)
  314: {
  314:     cairo_quartz_surface_t *surf;
  314: 
  314:     CGContextRetain (cgContext);
  314: 
  314:     surf = _cairo_quartz_surface_create_internal (cgContext, CAIRO_CONTENT_COLOR_ALPHA,
  314: 						  width, height);
10694:     if (surf->base.status) {
  314: 	CGContextRelease (cgContext);
  314: 	// create_internal will have set an error
10694: 	return (cairo_surface_t*) surf;
  314:     }
  314: 
  314:     return (cairo_surface_t *) surf;
  314: }
  314: 
  314: /**
42959:  * cairo_quartz_cglayer_surface_create_similar
42959:  * @surface: The returned surface can be efficiently drawn into this
42959:  * destination surface (if tiling is not used)."
57382:  * @content: the content type of the surface
42959:  * @width: width of the surface, in pixels
42959:  * @height: height of the surface, in pixels
42959:  *
42959:  * Creates a Quartz surface backed by a CGLayer, if the given surface
42959:  * is a Quartz surface; the CGLayer is created to match the surface's
57382:  * Quartz context. Otherwise just calls cairo_surface_create_similar.
42959:  * The returned surface can be efficiently blitted to the given surface,
42959:  * but tiling and 'extend' modes other than NONE are not so efficient.
42959:  *
42959:  * Return value: the newly created surface.
42959:  *
42959:  * Since: 1.10
42959:  **/
42959: cairo_surface_t *
42959: cairo_quartz_surface_create_cg_layer (cairo_surface_t *surface,
57382:                                       cairo_content_t content,
42959:                                       unsigned int width,
42959:                                       unsigned int height)
42959: {
42959:     cairo_quartz_surface_t *surf;
42959:     CGLayerRef layer;
42959:     CGContextRef ctx;
42959:     CGContextRef cgContext;
42959: 
42959:     cgContext = cairo_quartz_surface_get_cg_context (surface);
42959:     if (!cgContext)
57382:         return cairo_surface_create_similar (surface, content,
42959:                                              width, height);
42959: 
42959:     if (!_cairo_quartz_verify_surface_size(width, height))
42959:         return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_INVALID_SIZE));
42959: 
42959:     /* If we pass zero width or height into CGLayerCreateWithContext below,
42959:      * it will fail.
42959:      */
42959:     if (width == 0 || height == 0) {
42959:         return (cairo_surface_t*)
57382:             _cairo_quartz_surface_create_internal (NULL, content,
42959:                                                    width, height);
42959:     }
42959: 
42959:     layer = CGLayerCreateWithContext (cgContext,
42959:                                       CGSizeMake (width, height),
42959:                                       NULL);
42959:     if (!layer)
42959:       return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_NO_MEMORY));
42959: 
42959:     ctx = CGLayerGetContext (layer);
42959:     /* Flip it when we draw into it, so that when we finally composite it
42959:      * to a flipped target, the directions match and Quartz will optimize
42959:      * the composition properly
42959:      */
42959:     CGContextTranslateCTM (ctx, 0, height);
42959:     CGContextScaleCTM (ctx, 1, -1);
42959: 
42959:     CGContextRetain (ctx);
57382:     surf = _cairo_quartz_surface_create_internal (ctx, content,
42959:                                                   width, height);
42959:     if (surf->base.status) {
42959:         CGLayerRelease (layer);
42959:         // create_internal will have set an error
42959:         return (cairo_surface_t*) surf;
42959:     }
42959:     surf->cgLayer = layer;
42959: 
42959:     return (cairo_surface_t *) surf;
42959: }
42959: 
42959: /**
  314:  * cairo_quartz_surface_create
  314:  * @format: format of pixels in the surface to create
  314:  * @width: width of the surface, in pixels
  314:  * @height: height of the surface, in pixels
  314:  *
  314:  * Creates a Quartz surface backed by a CGBitmap.  The surface is
  314:  * created using the Device RGB (or Device Gray, for A8) color space.
  314:  * All Cairo operations, including those that require software
  314:  * rendering, will succeed on this surface.
  314:  *
  314:  * Return value: the newly created surface.
  314:  *
  314:  * Since: 1.4
  314:  **/
  314: cairo_surface_t *
  314: cairo_quartz_surface_create (cairo_format_t format,
  314: 			     unsigned int width,
  314: 			     unsigned int height)
  314: {
59440:     int stride;
59440:     unsigned char *data;
59440: 
59440:     if (!_cairo_quartz_verify_surface_size(width, height))
59440: 	return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_INVALID_SIZE));
59440: 
59440:     if (width == 0 || height == 0) {
59440: 	return (cairo_surface_t*) _cairo_quartz_surface_create_internal (NULL, _cairo_content_from_format (format),
59440: 									 width, height);
59440:     }
59440: 
59440:     if (format == CAIRO_FORMAT_ARGB32 ||
59440: 	format == CAIRO_FORMAT_RGB24)
59440:     {
59440: 	stride = width * 4;
59440:     } else if (format == CAIRO_FORMAT_A8) {
59440: 	stride = width;
59440:     } else if (format == CAIRO_FORMAT_A1) {
59440: 	/* I don't think we can usefully support this, as defined by
59440: 	 * cairo_format_t -- these are 1-bit pixels stored in 32-bit
59440: 	 * quantities.
59440: 	 */
59440: 	return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_INVALID_FORMAT));
59440:     } else {
59440: 	return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_INVALID_FORMAT));
59440:     }
59440: 
59440:     /* The Apple docs say that for best performance, the stride and the data
59440:      * pointer should be 16-byte aligned.  malloc already aligns to 16-bytes,
59440:      * so we don't have to anything special on allocation.
59440:      */
59440:     stride = (stride + 15) & ~15;
59440: 
59440:     data = _cairo_malloc_ab (height, stride);
59440:     if (!data) {
59440: 	return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_NO_MEMORY));
59440:     }
59440: 
59440:     /* zero the memory to match the image surface behaviour */
59440:     memset (data, 0, height * stride);
59440: 
59440:     cairo_quartz_surface_t *surf;
59440:     surf = (cairo_quartz_surface_t *) cairo_quartz_surface_create_for_data
59440:                                            (data, format, width, height, stride);
59440:     if (surf->base.status) {
59440:         free (data);
59440:         return (cairo_surface_t *) surf;
59440:     }
59440: 
59440:     // We created this data, so we can delete it.
59440:     surf->ownsData = TRUE;
59440: 
59440:     return (cairo_surface_t *) surf;
59440: }
59440: 
59440: /**
59440:  * cairo_quartz_surface_create_for_data
59440:  * @data: a pointer to a buffer supplied by the application in which
59440:  *     to write contents. This pointer must be suitably aligned for any
59440:  *     kind of variable, (for example, a pointer returned by malloc).
59440:  * @format: format of pixels in the surface to create
59440:  * @width: width of the surface, in pixels
59440:  * @height: height of the surface, in pixels
59440:  *
59440:  * Creates a Quartz surface backed by a CGBitmap.  The surface is
59440:  * created using the Device RGB (or Device Gray, for A8) color space.
59440:  * All Cairo operations, including those that require software
59440:  * rendering, will succeed on this surface.
59440:  *
59440:  * Return value: the newly created surface.
59440:  *
59440:  * Since: 1.12
59440:  **/
59440: cairo_surface_t *
59440: cairo_quartz_surface_create_for_data (unsigned char *data,
59440: 				      cairo_format_t format,
59440: 				      unsigned int width,
59440: 				      unsigned int height,
59440: 				      unsigned int stride)
59440: {
  314:     cairo_quartz_surface_t *surf;
  314:     CGContextRef cgc;
  314:     CGColorSpaceRef cgColorspace;
  314:     CGBitmapInfo bitinfo;
59440:     void *imageData = data;
  314:     int bitsPerComponent;
59440:     unsigned int i;
  314: 
 7123:     // verify width and height of surface
11244:     if (!_cairo_quartz_verify_surface_size(width, height))
26419: 	return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_INVALID_SIZE));
 7123: 
10414:     if (width == 0 || height == 0) {
10414: 	return (cairo_surface_t*) _cairo_quartz_surface_create_internal (NULL, _cairo_content_from_format (format),
10414: 									 width, height);
10414:     }
10414: 
13107:     if (format == CAIRO_FORMAT_ARGB32 ||
13107: 	format == CAIRO_FORMAT_RGB24)
13107:     {
  314: 	cgColorspace = CGColorSpaceCreateDeviceRGB();
13107: 	bitinfo = kCGBitmapByteOrder32Host;
13107: 	if (format == CAIRO_FORMAT_ARGB32)
13107: 	    bitinfo |= kCGImageAlphaPremultipliedFirst;
13107: 	else
13107: 	    bitinfo |= kCGImageAlphaNoneSkipFirst;
13107: 	bitsPerComponent = 8;
  314:     } else if (format == CAIRO_FORMAT_A8) {
41340: 	cgColorspace = NULL;
41340: 	bitinfo = kCGImageAlphaOnly;
  314: 	bitsPerComponent = 8;
  314:     } else if (format == CAIRO_FORMAT_A1) {
  314: 	/* I don't think we can usefully support this, as defined by
  314: 	 * cairo_format_t -- these are 1-bit pixels stored in 32-bit
  314: 	 * quantities.
  314: 	 */
10694: 	return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_INVALID_FORMAT));
  314:     } else {
10694: 	return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_INVALID_FORMAT));
  314:     }
  314: 
  314:     cgc = CGBitmapContextCreate (imageData,
  314: 				 width,
  314: 				 height,
  314: 				 bitsPerComponent,
  314: 				 stride,
  314: 				 cgColorspace,
  314: 				 bitinfo);
  314:     CGColorSpaceRelease (cgColorspace);
    1: 
  314:     if (!cgc) {
 7173: 	free (imageData);
10694: 	return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_NO_MEMORY));
    1:     }
    1: 
  314:     /* flip the Y axis */
  314:     CGContextTranslateCTM (cgc, 0.0, height);
  314:     CGContextScaleCTM (cgc, 1.0, -1.0);
  314: 
  314:     surf = _cairo_quartz_surface_create_internal (cgc, _cairo_content_from_format (format),
 6154: 						  width, height);
10694:     if (surf->base.status) {
  314: 	CGContextRelease (cgc);
 8452: 	free (imageData);
  314: 	// create_internal will have set an error
10694: 	return (cairo_surface_t*) surf;
  314:     }
  314: 
  314:     surf->imageData = imageData;
57901: 
57901:     cairo_surface_t* tmpImageSurfaceEquiv =
57901:       cairo_image_surface_create_for_data (imageData, format,
57901:                                            width, height, stride);
57901: 
57901:     if (cairo_surface_status (tmpImageSurfaceEquiv)) {
57901:         // Tried & failed to create an imageSurfaceEquiv!
57901:         cairo_surface_destroy (tmpImageSurfaceEquiv);
57901:         surf->imageSurfaceEquiv = NULL;
57901:     } else {
57901:         surf->imageSurfaceEquiv = tmpImageSurfaceEquiv;
59440:         surf->ownsData = FALSE;
57901:     }
  314: 
  314:     return (cairo_surface_t *) surf;
  314: }
  314: 
  314: /**
  314:  * cairo_quartz_surface_get_cg_context
  314:  * @surface: the Cairo Quartz surface
  314:  *
  314:  * Returns the CGContextRef that the given Quartz surface is backed
  314:  * by.
  314:  *
  314:  * Return value: the CGContextRef for the given surface.
  314:  *
  314:  * Since: 1.4
  314:  **/
  314: CGContextRef
  314: cairo_quartz_surface_get_cg_context (cairo_surface_t *surface)
  301: {
70960:     if (surface && _cairo_surface_is_quartz (surface)) {
  314: 	cairo_quartz_surface_t *quartz = (cairo_quartz_surface_t *) surface;
70960: 	return quartz->cgContext;
70960:     } else
70918: 	return NULL;
70960: }
70960: 
70960: static cairo_bool_t
70960: _cairo_surface_is_quartz (const cairo_surface_t *surface)
70960: {
70960:     return surface->backend == &cairo_quartz_surface_backend;
  299: }
  314: 
41340: CGContextRef
41340: cairo_quartz_get_cg_context_with_clip (cairo_t *cr)
41340: {
41340: 
41340:     cairo_surface_t *surface = cr->gstate->target;
41340:     cairo_clip_t *clip = &cr->gstate->clip;
41340:     cairo_status_t status;
41340: 
41340:     cairo_quartz_surface_t *quartz = (cairo_quartz_surface_t*)surface;
41340: 
41340:     if (cairo_surface_get_type(surface) != CAIRO_SURFACE_TYPE_QUARTZ)
41340: 	return NULL;
41340: 
41340:     if (!clip->path) {
41340: 	if (clip->all_clipped) {
41623: 	    /* Save the state before we set an empty clip rect so that
41623: 	     * our previous clip will be restored */
41623: 
41340: 	    /* _cairo_surface_clipper_set_clip doesn't deal with
41340: 	     * clip->all_clipped because drawing is normally discarded earlier */
41340: 	    CGRect empty = {{0,0}, {0,0}};
41340: 	    CGContextClipToRect (quartz->cgContext, empty);
70960: 	    CGContextSaveGState (quartz->cgContext);
41340: 
41340: 	    return quartz->cgContext;
41340: 	}
41340: 
41340: 	/* an empty clip is represented by NULL */
41340: 	clip = NULL;
41340:     }
41340: 
41340:     status = _cairo_surface_clipper_set_clip (&quartz->clipper, clip);
41623: 
41623:     /* Save the state after we set the clip so that it persists
41623:      * after we restore */
41623:     CGContextSaveGState (quartz->cgContext);
41623: 
41340:     if (unlikely (status))
41340: 	return NULL;
41340: 
41340:     return quartz->cgContext;
41340: }
41340: 
41623: void
41623: cairo_quartz_finish_cg_context_with_clip (cairo_t *cr)
41623: {
41623:     cairo_surface_t *surface = cr->gstate->target;
41623: 
41623:     cairo_quartz_surface_t *quartz = (cairo_quartz_surface_t*)surface;
41623: 
41623:     if (cairo_surface_get_type(surface) != CAIRO_SURFACE_TYPE_QUARTZ)
41623: 	return;
41623: 
41623:     CGContextRestoreGState (quartz->cgContext);
41623: }
  314: 
57346: cairo_surface_t *
57346: cairo_quartz_surface_get_image (cairo_surface_t *surface)
57346: {
57346:     cairo_quartz_surface_t *quartz = (cairo_quartz_surface_t *)surface;
57346:     cairo_image_surface_t *image;
57346: 
57346:     if (_cairo_quartz_get_image(quartz, &image))
57346:         return NULL;
57346: 
57346:     return (cairo_surface_t *)image;
57346: }
57346: 
  314: /* Debug stuff */
  314: 
  314: #ifdef QUARTZ_DEBUG
  314: 
  314: #include <Movies.h>
  314: 
  314: void ExportCGImageToPNGFile(CGImageRef inImageRef, char* dest)
  314: {
  314:     Handle  dataRef = NULL;
  314:     OSType  dataRefType;
  314:     CFStringRef inPath = CFStringCreateWithCString(NULL, dest, kCFStringEncodingASCII);
  314: 
  314:     GraphicsExportComponent grex = 0;
  314:     unsigned long sizeWritten;
  314: 
  314:     ComponentResult result;
  314: 
  314:     // create the data reference
  314:     result = QTNewDataReferenceFromFullPathCFString(inPath, kQTNativeDefaultPathStyle,
  314: 						    0, &dataRef, &dataRefType);
  314: 
  314:     if (NULL != dataRef && noErr == result) {
  314: 	// get the PNG exporter
  314: 	result = OpenADefaultComponent(GraphicsExporterComponentType, kQTFileTypePNG,
  314: 				       &grex);
  314: 
  314: 	if (grex) {
  314: 	    // tell the exporter where to find its source image
  314: 	    result = GraphicsExportSetInputCGImage(grex, inImageRef);
  314: 
  314: 	    if (noErr == result) {
  314: 		// tell the exporter where to save the exporter image
  314: 		result = GraphicsExportSetOutputDataReference(grex, dataRef,
  314: 							      dataRefType);
  314: 
  314: 		if (noErr == result) {
  314: 		    // write the PNG file
  314: 		    result = GraphicsExportDoExport(grex, &sizeWritten);
  314: 		}
  314: 	    }
  314: 
  314: 	    // remember to close the component
  314: 	    CloseComponent(grex);
  314: 	}
  314: 
  314: 	// remember to dispose of the data reference handle
  314: 	DisposeHandle(dataRef);
  314:     }
  314: }
  314: 
  314: void
  314: quartz_image_to_png (CGImageRef imgref, char *dest)
  314: {
  314:     static int sctr = 0;
  314:     char sptr[] = "/Users/vladimir/Desktop/barXXXXX.png";
  314: 
  314:     if (dest == NULL) {
  314: 	fprintf (stderr, "** Writing %p to bar%d\n", imgref, sctr);
  314: 	sprintf (sptr, "/Users/vladimir/Desktop/bar%d.png", sctr);
  314: 	sctr++;
  314: 	dest = sptr;
  314:     }
  314: 
  314:     ExportCGImageToPNGFile(imgref, dest);
  314: }
  314: 
  314: void
  314: quartz_surface_to_png (cairo_quartz_surface_t *nq, char *dest)
  314: {
  314:     static int sctr = 0;
  314:     char sptr[] = "/Users/vladimir/Desktop/fooXXXXX.png";
  314: 
  314:     if (nq->base.type != CAIRO_SURFACE_TYPE_QUARTZ) {
  314: 	fprintf (stderr, "** quartz_surface_to_png: surface %p isn't quartz!\n", nq);
  314: 	return;
  314:     }
  314: 
  314:     if (dest == NULL) {
  314: 	fprintf (stderr, "** Writing %p to foo%d\n", nq, sctr);
  314: 	sprintf (sptr, "/Users/vladimir/Desktop/foo%d.png", sctr);
  314: 	sctr++;
  314: 	dest = sptr;
  314:     }
  314: 
  314:     CGImageRef imgref = CGBitmapContextCreateImage (nq->cgContext);
  314:     if (imgref == NULL) {
  314: 	fprintf (stderr, "quartz surface at %p is not a bitmap context!\n", nq);
  314: 	return;
  314:     }
  314: 
  314:     ExportCGImageToPNGFile(imgref, dest);
  314: 
  314:     CGImageRelease(imgref);
  314: }
13107: 
13107: #endif /* QUARTZ_DEBUG */
