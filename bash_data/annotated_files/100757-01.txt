     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "nsXULMenuAccessible.h"
 41384: 
 95352: #include "Accessible-inl.h"
 41384: #include "nsAccessibilityService.h"
 41384: #include "nsAccUtils.h"
 99568: #include "DocAccessible.h"
 87094: #include "Role.h"
 67790: #include "States.h"
 95360: #include "XULFormControlAccessible.h"
 41384: 
     1: #include "nsIDOMElement.h"
     1: #include "nsIDOMXULElement.h"
     1: #include "nsIMutableArray.h"
  8282: #include "nsIDOMXULContainerElement.h"
     1: #include "nsIDOMXULSelectCntrlItemEl.h"
     1: #include "nsIDOMXULMultSelectCntrlEl.h"
     1: #include "nsIDOMKeyEvent.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsIPresShell.h"
     1: #include "nsIContent.h"
     1: #include "nsGUIEvent.h"
 79384: #include "nsMenuBarFrame.h"
 79384: #include "nsMenuPopupFrame.h"
     1: 
 71199: #include "mozilla/Preferences.h"
 78122: #include "mozilla/LookAndFeel.h"
 74131: #include "mozilla/dom/Element.h"
 71199: 
 71199: using namespace mozilla;
 74618: using namespace mozilla::a11y;
     1: 
 43504: ////////////////////////////////////////////////////////////////////////////////
 43504: // nsXULMenuitemAccessible
 43504: ////////////////////////////////////////////////////////////////////////////////
     1: 
 43504: nsXULMenuitemAccessible::
 99568:   nsXULMenuitemAccessible(nsIContent* aContent, DocAccessible* aDoc) :
 99648:   AccessibleWrap(aContent, aDoc)
     1: {
     1: }
     1: 
 67790: PRUint64
 67790: nsXULMenuitemAccessible::NativeState()
     1: {
 99648:   PRUint64 state = Accessible::NativeState();
     1: 
     1:   // Has Popup?
 78350:   if (mContent->NodeInfo()->Equals(nsGkAtoms::menu, kNameSpaceID_XUL)) {
 67790:     state |= states::HASPOPUP;
 78350:     if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::open))
 67790:       state |= states::EXPANDED;
 43504:     else
 67790:       state |= states::COLLAPSED;
  2089:   }
     1: 
 43504:   // Checkable/checked?
 43504:   static nsIContent::AttrValuesArray strings[] =
 78350:     { &nsGkAtoms::radio, &nsGkAtoms::checkbox, nsnull };
     1: 
 78350:   if (mContent->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::type, strings,
 78350:                                 eCaseMatters) >= 0) {
 43504: 
     1:     // Checkable?
 67790:     state |= states::CHECKABLE;
     1: 
     1:     // Checked?
 78350:     if (mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::checked,
 78350:                               nsGkAtoms::_true, eCaseMatters))
 67790:       state |= states::CHECKED;
     1:   }
     1: 
  2346:   // Combo box listitem
 87094:   bool isComboboxOption = (Role() == roles::COMBOBOX_OPTION);
 10350:   if (isComboboxOption) {
  2346:     // Is selected?
 79445:     bool isSelected = false;
  2346:     nsCOMPtr<nsIDOMXULSelectControlItemElement>
 43504:       item(do_QueryInterface(mContent));
 67790:     NS_ENSURE_TRUE(item, state);
  2346:     item->GetSelected(&isSelected);
  2346: 
  2346:     // Is collapsed?
 79445:     bool isCollapsed = false;
 99648:     Accessible* parent = Parent();
 74545:     if (parent && parent->State() & states::INVISIBLE)
 80486:       isCollapsed = true;
     1: 
  2346:     if (isSelected) {
 67790:       state |= states::SELECTED;
  2346: 
  2346:       // Selected and collapsed?
  2346:       if (isCollapsed) {
  2346:         // Set selected option offscreen/invisible according to combobox state
 99648:         Accessible* grandParent = parent->Parent();
 74545:         if (!grandParent)
 74545:           return state;
 87094:         NS_ASSERTION(grandParent->Role() == roles::COMBOBOX,
  2346:                      "grandparent of combobox listitem is not combobox");
 74545:         PRUint64 grandParentState = grandParent->State();
 67790:         state &= ~(states::OFFSCREEN | states::INVISIBLE);
 67790:         state |= (grandParentState & states::OFFSCREEN) |
 67790:                  (grandParentState & states::INVISIBLE) |
 67790:                  (grandParentState & states::OPAQUE1);
  2346:       } // isCollapsed
  2346:     } // isSelected
  8051:   } // ROLE_COMBOBOX_OPTION
  2346: 
 67790:   return state;
 10350: }
100246: 
100246: PRUint64
100246: nsXULMenuitemAccessible::NativeInteractiveState() const
100246: {
100246:   if (NativelyUnavailable()) {
100246:     // Note: keep in sinc with nsXULPopupManager::IsValidMenuItem() logic.
100246:     bool skipNavigatingDisabledMenuItem = true;
100246:     nsMenuFrame* menuFrame = do_QueryFrame(GetFrame());
100757:     if (menuFrame && !menuFrame->IsOnMenuBar()) {
100246:       skipNavigatingDisabledMenuItem = LookAndFeel::
100246:         GetInt(LookAndFeel::eIntID_SkipNavigatingDisabledMenuItem, 0) != 0;
 10350:     }
 79384: 
100246:     if (skipNavigatingDisabledMenuItem)
100246:       return states::UNAVAILABLE;
 10350: 
100246:     return states::UNAVAILABLE | states::FOCUSABLE | states::SELECTABLE;
100246:   }
100246: 
100246:   return states::FOCUSABLE | states::SELECTABLE;
     1: }
     1: 
 20246: nsresult
 20246: nsXULMenuitemAccessible::GetNameInternal(nsAString& aName)
     1: {
 78350:   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::label, aName);
     1:   return NS_OK;
     1: }
     1: 
 69342: void
 69342: nsXULMenuitemAccessible::Description(nsString& aDescription)
     1: {
 78350:   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::description,
 43504:                     aDescription);
     1: }
     1: 
 74014: KeyBinding
 74014: nsXULMenuitemAccessible::AccessKey() const
     1: {
 74014:   // Return menu accesskey: N or Alt+F.
     1:   static PRInt32 gMenuAccesskeyModifier = -1;  // magic value of -1 indicates unitialized state
     1: 
 20521:   // We do not use nsCoreUtils::GetAccesskeyFor() because accesskeys for
 68780:   // menu are't registered by nsEventStateManager.
 43504:   nsAutoString accesskey;
 78350:   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::accesskey,
 43504:                     accesskey);
     1:   if (accesskey.IsEmpty())
 74014:     return KeyBinding();
 74014: 
 74014:   PRUint32 modifierKey = 0;
     1: 
 99648:   Accessible* parentAcc = Parent();
 36989:   if (parentAcc) {
 87094:     if (parentAcc->NativeRole() == roles::MENUBAR) {
     1:       // If top level menu item, add Alt+ or whatever modifier text to string
     1:       // No need to cache pref service, this happens rarely
     1:       if (gMenuAccesskeyModifier == -1) {
     1:         // Need to initialize cached global accesskey pref
 71199:         gMenuAccesskeyModifier = Preferences::GetInt("ui.key.menuAccessKey", 0);
     1:       }
 43504: 
     1:       switch (gMenuAccesskeyModifier) {
 43504:         case nsIDOMKeyEvent::DOM_VK_CONTROL:
 74014:           modifierKey = KeyBinding::kControl;
 43504:           break;
 43504:         case nsIDOMKeyEvent::DOM_VK_ALT:
 74014:           modifierKey = KeyBinding::kAlt;
 43504:           break;
 43504:         case nsIDOMKeyEvent::DOM_VK_META:
 74014:           modifierKey = KeyBinding::kMeta;
 43504:           break;
     1:       }
     1:     }
     1:   }
 43504: 
 74014:   return KeyBinding(accesskey[0], modifierKey);
     1: }
     1: 
 74014: KeyBinding
 74014: nsXULMenuitemAccessible::KeyboardShortcut() const
     1: {
 74014:   nsAutoString keyElmId;
 74014:   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::key, keyElmId);
 74014:   if (keyElmId.IsEmpty())
 74014:     return KeyBinding();
     1: 
 80527:   nsIContent* keyElm = mContent->OwnerDoc()->GetElementById(keyElmId);
 74014:   if (!keyElm)
 74014:     return KeyBinding();
     1: 
 74014:   PRUint32 key = 0;
 74014: 
 74014:   nsAutoString keyStr;
 74014:   keyElm->GetAttr(kNameSpaceID_None, nsGkAtoms::key, keyStr);
 74014:   if (keyStr.IsEmpty()) {
 74014:     nsAutoString keyCodeStr;
 74014:     keyElm->GetAttr(kNameSpaceID_None, nsGkAtoms::keycode, keyCodeStr);
 74014:     PRUint32 errorCode;
 74014:     key = keyStr.ToInteger(&errorCode, kAutoDetect);
 74014:   } else {
 74014:     key = keyStr[0];
 74014:   }
 74014: 
 74014:   nsAutoString modifiersStr;
 74014:   keyElm->GetAttr(kNameSpaceID_None, nsGkAtoms::modifiers, modifiersStr);
 74014: 
 74014:   PRUint32 modifierMask = 0;
 74014:   if (modifiersStr.Find("shift") != -1)
 74231:     modifierMask |= KeyBinding::kShift;
 74014:   if (modifiersStr.Find("alt") != -1)
 74014:     modifierMask |= KeyBinding::kAlt;
 74014:   if (modifiersStr.Find("meta") != -1)
 74014:     modifierMask |= KeyBinding::kMeta;
 74014:   if (modifiersStr.Find("control") != -1)
 74014:     modifierMask |= KeyBinding::kControl;
 74014:   if (modifiersStr.Find("accel") != -1) {
 74014:     // Get the accelerator key value from prefs, overriding the default.
 74014:     switch (Preferences::GetInt("ui.key.accelKey", 0)) {
 74014:       case nsIDOMKeyEvent::DOM_VK_META:
 74014:         modifierMask |= KeyBinding::kMeta;
 74014:         break;
 74014: 
 74014:       case nsIDOMKeyEvent::DOM_VK_ALT:
 74014:         modifierMask |= KeyBinding::kAlt;
 74014:         break;
 74014: 
 74014:       case nsIDOMKeyEvent::DOM_VK_CONTROL:
 74014:         modifierMask |= KeyBinding::kControl;
 74014:         break;
 74014: 
 74014:       default:
 74014: #ifdef XP_MACOSX
 74014:         modifierMask |= KeyBinding::kMeta;
 74014: #else
 74014:         modifierMask |= KeyBinding::kControl;
 74014: #endif
 74014:     }
 74014:   }
 74014: 
 74014:   return KeyBinding(key, modifierMask);
     1: }
     1: 
 87094: role
 52027: nsXULMenuitemAccessible::NativeRole()
     1: {
 43504:   nsCOMPtr<nsIDOMXULContainerElement> xulContainer(do_QueryInterface(mContent));
 52027:   if (xulContainer)
 87094:     return roles::PARENT_MENUITEM;
  8282: 
 87094:   if (mParent && mParent->Role() == roles::COMBOBOX_LIST)
 87094:     return roles::COMBOBOX_OPTION;
 52027: 
 78350:   if (mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::type,
 87094:                             nsGkAtoms::radio, eCaseMatters)) 
 87094:     return roles::RADIO_MENU_ITEM;
  8282: 
 78350:   if (mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::type,
 78350:                             nsGkAtoms::checkbox,
 87094:                             eCaseMatters)) 
 87094:     return roles::CHECK_MENU_ITEM;
     1: 
 87094:   return roles::MENUITEM;
     1: }
     1: 
 36879: PRInt32
 36879: nsXULMenuitemAccessible::GetLevelInternal()
   144: {
 43504:   return nsAccUtils::GetLevelForXULContainerItem(mContent);
 36879: }
   144: 
 79445: bool
 89679: nsXULMenuitemAccessible::CanHaveAnonChildren()
     1: {
     1:   // That indicates we don't walk anonymous children for menuitems
 80486:   return false;
     1: }
     1: 
     1: NS_IMETHODIMP nsXULMenuitemAccessible::DoAction(PRUint8 index)
     1: {
     1:   if (index == eAction_Click) {   // default action
     1:     DoCommand();
     1:     return NS_OK;
     1:   }
     1: 
     1:   return NS_ERROR_INVALID_ARG;
     1: }
     1: 
     1: /** select us! close combo box if necessary*/
     1: NS_IMETHODIMP nsXULMenuitemAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
     1: {
     1:   if (aIndex == eAction_Click) {
     1:     aName.AssignLiteral("click"); 
     1:     return NS_OK;
     1:   }
     1:   return NS_ERROR_INVALID_ARG;
     1: }
     1: 
 74781: PRUint8
 74781: nsXULMenuitemAccessible::ActionCount()
     1: {
 74781:   return 1;
     1: }
     1: 
 79384: ////////////////////////////////////////////////////////////////////////////////
 79384: // nsXULMenuitemAccessible: Widgets
 79384: 
 79384: bool
 79384: nsXULMenuitemAccessible::IsActiveWidget() const
 79384: {
 79384:   // Parent menu item is a widget, it's active when its popup is open.
 79384:   nsIContent* menuPopupContent = mContent->GetFirstChild();
 79384:   if (menuPopupContent) {
 79384:     nsMenuPopupFrame* menuPopupFrame =
 79384:       do_QueryFrame(menuPopupContent->GetPrimaryFrame());
 79384:     return menuPopupFrame && menuPopupFrame->IsOpen();
 79384:   }
 79384:   return false;
 79384: }
 79384: 
 79384: bool
 79384: nsXULMenuitemAccessible::AreItemsOperable() const
 79384: {
 79384:   // Parent menu item is a widget, its items are operable when its popup is open.
 79384:   nsIContent* menuPopupContent = mContent->GetFirstChild();
 79384:   if (menuPopupContent) {
 79384:     nsMenuPopupFrame* menuPopupFrame =
 79384:       do_QueryFrame(menuPopupContent->GetPrimaryFrame());
 79384:     return menuPopupFrame && menuPopupFrame->IsOpen();
 79384:   }
 79384:   return false;
 79384: }
 79384: 
 99648: Accessible*
 79384: nsXULMenuitemAccessible::ContainerWidget() const
 79384: {
 79384:   nsMenuFrame* menuFrame = do_QueryFrame(GetFrame());
 79384:   if (menuFrame) {
 79384:     nsMenuParent* menuParent = menuFrame->GetMenuParent();
 79384:     if (menuParent) {
 79384:       if (menuParent->IsMenuBar()) // menubar menu
 79384:         return mParent;
 79384: 
 79384:       // a menupoup or parent menu item
 79384:       if (menuParent->IsMenu())
 79384:         return mParent;
 79384: 
 79384:       // otherwise it's different kind of popups (like panel or tooltip), it
 79384:       // shouldn't be a real case.
 79384:     }
 79384:   }
 79384:   return nsnull;
 79384: }
 79384: 
     1: 
 43504: ////////////////////////////////////////////////////////////////////////////////
 43504: // nsXULMenuSeparatorAccessible
 43504: ////////////////////////////////////////////////////////////////////////////////
     1: 
 43504: nsXULMenuSeparatorAccessible::
 99568:   nsXULMenuSeparatorAccessible(nsIContent* aContent, DocAccessible* aDoc) :
 89799:   nsXULMenuitemAccessible(aContent, aDoc)
     1: {
     1: }
     1: 
 67790: PRUint64
 67790: nsXULMenuSeparatorAccessible::NativeState()
     1: {
  2346:   // Isn't focusable, but can be offscreen/invisible -- only copy those states
 67790:   return nsXULMenuitemAccessible::NativeState() &
 67790:     (states::OFFSCREEN | states::INVISIBLE);
     1: }
     1: 
 20246: nsresult
 20246: nsXULMenuSeparatorAccessible::GetNameInternal(nsAString& aName)
     1: {
     1:   return NS_OK;
     1: }
     1: 
 87094: role
 52027: nsXULMenuSeparatorAccessible::NativeRole()
     1: {
 87094:   return roles::SEPARATOR;
     1: }
     1: 
     1: NS_IMETHODIMP nsXULMenuSeparatorAccessible::DoAction(PRUint8 index)
     1: {
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: NS_IMETHODIMP nsXULMenuSeparatorAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
     1: {
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
 74781: PRUint8
 74781: nsXULMenuSeparatorAccessible::ActionCount()
     1: {
 74781:   return 0;
     1: }
     1: 
 43504: ////////////////////////////////////////////////////////////////////////////////
 43504: // nsXULMenupopupAccessible
 43504: ////////////////////////////////////////////////////////////////////////////////
 43504: 
 43504: nsXULMenupopupAccessible::
 99568:   nsXULMenupopupAccessible(nsIContent* aContent, DocAccessible* aDoc) :
 89799:   XULSelectControlAccessible(aContent, aDoc)
     1: {
 79384:   nsMenuPopupFrame* menuPopupFrame = do_QueryFrame(GetFrame());
 79384:   if (menuPopupFrame && menuPopupFrame->IsMenu())
 79384:     mFlags |= eMenuPopupAccessible;
 79384: 
     1:   // May be the anonymous <menupopup> inside <menulist> (a combobox)
 43504:   mSelectControl = do_QueryInterface(mContent->GetParent());
     1: }
     1: 
 67790: PRUint64
 67790: nsXULMenupopupAccessible::NativeState()
     1: {
 99648:   PRUint64 state = Accessible::NativeState();
  2346: 
 97936: #ifdef DEBUG
     1:   // We are onscreen if our parent is active
 97936:   bool isActive = mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::menuactive);
 43504:   if (!isActive) {
 99648:     Accessible* parent = Parent();
 97936:     if (parent) {
 97936:       nsIContent* parentContent = parent->GetContent();
 97936:       if (parentContent)
 97936:         isActive = parentContent->HasAttr(kNameSpaceID_None, nsGkAtoms::open);
 97936:     }
     1:   }
 43504: 
 97936:   NS_ASSERTION(isActive || (state & states::INVISIBLE),
 67790:                "XULMenupopup doesn't have INVISIBLE when it's inactive");
  6324: #endif
     1: 
 67790:   if (state & states::INVISIBLE)
 67790:     state |= states::OFFSCREEN | states::COLLAPSED;
     1: 
 67790:   return state;
     1: }
     1: 
 20246: nsresult
 20246: nsXULMenupopupAccessible::GetNameInternal(nsAString& aName)
     1: {
 43504:   nsIContent *content = mContent;
  5143:   while (content && aName.IsEmpty()) {
 78350:     content->GetAttr(kNameSpaceID_None, nsGkAtoms::label, aName);
  5143:     content = content->GetParent();
     1:   }
     1: 
  5143:   return NS_OK;
     1: }
     1: 
 87094: role
 52027: nsXULMenupopupAccessible::NativeRole()
     1: {
 51991:   // If accessible is not bound to the tree (this happens while children are
 51991:   // cached) return general role.
 51991:   if (mParent) {
 87094:     roles::Role role = mParent->Role();
 87094:     if (role == roles::COMBOBOX || role == roles::AUTOCOMPLETE)
 87094:       return roles::COMBOBOX_LIST;
 87094: 
 87094:     if (role == roles::PUSHBUTTON) {
 87094:       // Some widgets like the search bar have several popups, owned by buttons.
 99648:       Accessible* grandParent = mParent->Parent();
 87094:       if (grandParent && grandParent->Role() == roles::AUTOCOMPLETE)
 87094:         return roles::COMBOBOX_LIST;
 87094:     }
 52027:   }
 34719: 
 87094:   return roles::MENUPOPUP;
     1: }
     1: 
 79384: ////////////////////////////////////////////////////////////////////////////////
 79384: // nsXULMenupopupAccessible: Widgets
 79384: 
 79384: bool
 79384: nsXULMenupopupAccessible::IsWidget() const
 79384: {
 79384:   return true;
 79384: }
 79384: 
 79384: bool
 79384: nsXULMenupopupAccessible::IsActiveWidget() const
 79384: {
 79384:   // If menupopup is a widget (the case of context menus) then active when open.
 79384:   nsMenuPopupFrame* menuPopupFrame = do_QueryFrame(GetFrame());
 79384:   return menuPopupFrame && menuPopupFrame->IsOpen();
 79384: }
 79384: 
 79384: bool
 79384: nsXULMenupopupAccessible::AreItemsOperable() const
 79384: {
 79384:   nsMenuPopupFrame* menuPopupFrame = do_QueryFrame(GetFrame());
 79384:   return menuPopupFrame && menuPopupFrame->IsOpen();
 79384: }
 79384: 
 99648: Accessible*
 79384: nsXULMenupopupAccessible::ContainerWidget() const
 79384: {
 99568:   DocAccessible* document = Document();
 79384: 
 79384:   nsMenuPopupFrame* menuPopupFrame = do_QueryFrame(GetFrame());
 79384:   while (menuPopupFrame) {
 99648:     Accessible* menuPopup =
 79384:       document->GetAccessible(menuPopupFrame->GetContent());
 79384:     if (!menuPopup) // shouldn't be a real case
 79384:       return nsnull;
 79384: 
 79384:     nsMenuFrame* menuFrame = menuPopupFrame->GetParentMenu();
 79384:     if (!menuFrame) // context menu or popups
 79384:       return nsnull;
 79384: 
 79384:     nsMenuParent* menuParent = menuFrame->GetMenuParent();
 79384:     if (!menuParent) // menulist or menubutton
 79384:       return menuPopup->Parent();
 79384: 
 79384:     if (menuParent->IsMenuBar()) { // menubar menu
 79384:       nsMenuBarFrame* menuBarFrame = static_cast<nsMenuBarFrame*>(menuParent);
 79384:       return document->GetAccessible(menuBarFrame->GetContent());
 79384:     }
 79384: 
 79384:     // different kind of popups like panel or tooltip
 79384:     if (!menuParent->IsMenu())
 79384:       return nsnull;
 79384: 
 79384:     menuPopupFrame = static_cast<nsMenuPopupFrame*>(menuParent);
 79384:   }
 79384: 
 79384:   NS_NOTREACHED("Shouldn't be a real case.");
 79384:   return nsnull;
 79384: }
     1: 
 43504: ////////////////////////////////////////////////////////////////////////////////
 43504: // nsXULMenubarAccessible
 43504: ////////////////////////////////////////////////////////////////////////////////
 43504: 
 43504: nsXULMenubarAccessible::
 99568:   nsXULMenubarAccessible(nsIContent* aContent, DocAccessible* aDoc) :
 99648:   AccessibleWrap(aContent, aDoc)
     1: {
     1: }
     1: 
 20246: nsresult
 20246: nsXULMenubarAccessible::GetNameInternal(nsAString& aName)
     1: {
 18347:   aName.AssignLiteral("Application");
     1:   return NS_OK;
     1: }
     1: 
 87094: role
 52027: nsXULMenubarAccessible::NativeRole()
     1: {
 87094:   return roles::MENUBAR;
     1: }
     1: 
 79384: ////////////////////////////////////////////////////////////////////////////////
 79384: // nsXULMenubarAccessible: Widgets
 79384: 
 79384: bool
 79384: nsXULMenubarAccessible::IsActiveWidget() const
 79384: {
 79384:   nsMenuBarFrame* menuBarFrame = do_QueryFrame(GetFrame());
 79384:   return menuBarFrame && menuBarFrame->IsActive();
 79384: }
 79384: 
 79384: bool
 79384: nsXULMenubarAccessible::AreItemsOperable() const
 79384: {
 79384:   return true;
 79384: }
 79384: 
 99648: Accessible*
 79384: nsXULMenubarAccessible::CurrentItem()
 79384: {
 79384:   nsMenuBarFrame* menuBarFrame = do_QueryFrame(GetFrame());
 79384:   if (menuBarFrame) {
 79384:     nsMenuFrame* menuFrame = menuBarFrame->GetCurrentMenuItem();
 79384:     if (menuFrame) {
 79384:       nsIContent* menuItemNode = menuFrame->GetContent();
 90150:       return mDoc->GetAccessible(menuItemNode);
 79384:     }
 79384:   }
 79384:   return nsnull;
 79384: }
 84259: 
 84259: void
 99648: nsXULMenubarAccessible::SetCurrentItem(Accessible* aItem)
 84259: {
 84259:   NS_ERROR("nsXULMenubarAccessible::SetCurrentItem not implemented");
 84259: }
