 89965: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 69223:  * vim: set ts=4 sw=4 et tw=79 ft=cpp:
 69223:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 69223: 
 69223: #ifndef Stack_h__
 69223: #define Stack_h__
 69223: 
 69223: #include "jsfun.h"
 97878: #include "jsautooplen.h"
 69223: 
 70320: struct JSContext;
 76885: struct JSCompartment;
 70320: 
101075: extern void js_DumpStackFrame(JSContext *, js::StackFrame *);
 87949: 
 69223: namespace js {
 69223: 
 69223: class StackFrame;
 69223: class FrameRegs;
 69223: class StackSegment;
 69223: class StackSpace;
 69223: class ContextStack;
 69223: 
 69223: class InvokeArgsGuard;
 69223: class InvokeFrameGuard;
 69223: class FrameGuard;
 69223: class ExecuteFrameGuard;
 69223: class DummyFrameGuard;
 69223: class GeneratorFrameGuard;
 69223: 
 71697: class CallIter;
 97161: class ScriptFrameIter;
 71697: class AllFramesIter;
 71697: 
 69827: class ArgumentsObject;
101073: class ScopeObject;
 86483: class StaticBlockObject;
 69827: 
101160: struct ScopeCoordinate;
101160: 
 88040: #ifdef JS_METHODJIT
 87949: namespace mjit {
101075:     class CallCompiler;
101075:     class GetPropCompiler;
101075:     struct CallSite;
 87949:     struct JITScript;
 87949:     jsbytecode *NativeToPC(JITScript *jit, void *ncode, CallSite **pinline);
101075:     namespace ic { struct GetElementIC; }
 87949: }
101075: typedef mjit::CallSite InlinedSite;
101075: #else
101075: struct InlinedSite {};
 88040: #endif
101075: typedef size_t FrameRejoinState;
 88040: 
 87949: namespace detail {
 87949:     struct OOMCheck;
 87949: }
 76185: 
 87949: /*****************************************************************************/
 69223: 
 69223: /*
 69223:  * VM stack layout
 69223:  *
101075:  * SpiderMonkey uses a per-runtime stack to store the activation records,
 69223:  * parameters, locals, and expression temporaries for the stack of actively
101075:  * executing scripts, functions and generators.
 69223:  *
 90857:  * The stack is subdivided into contiguous segments of memory which
 69223:  * have a memory layout invariant that allows fixed offsets to be used for stack
 71697:  * access (by jit code) as well as fast call/return. This memory layout is
 71697:  * encapsulated by a set of types that describe different regions of memory.
 71697:  * This encapsulation has holes: to avoid calling into C++ from generated code,
 71697:  * JIT compilers generate code that simulates analogous operations in C++.
 69223:  *
 71697:  * A sample memory layout of a segment looks like:
 69223:  *
 71697:  *                          regs
101075:  *       .------------------------------------------------.
 71697:  *       |                                                V
 71697:  *       |                                      fp .--FrameRegs--. sp
 71697:  *       |                                         V             V
101075:  * |StackSegment| values |StackFrame| values |StackFrame| values |
 69223:  *                         |      ^            |
101075:  *           ? <-----------'      `------------'
 69223:  *                 prev               prev
 69223:  *
 69223:  * A segment starts with a fixed-size header (js::StackSegment) which logically
 69223:  * describes the segment, links it to the rest of the stack, and points to the
 71697:  * end of the stack.
 69223:  *
 69223:  * Each script activation (global or function code) is given a fixed-size header
101075:  * (js::StackFrame) which is associated with the values before and after it.
101075:  * The frame contains bookkeeping information about the activation and links to
101075:  * the previous frame.
 69223:  *
101075:  * The value preceding a (function) StackFrame in memory are the arguments of
101075:  * the call. The values after a StackFrame in memory are its locals followed by
 71697:  * its expression stack. There is no clean line between the arguments of a
101075:  * frame and the expression stack of the previous frame since the top values of
 69223:  * the expression become the arguments of a call. There are also layout
 69223:  * invariants concerning the arguments and StackFrame; see "Arguments" comment
 69223:  * in StackFrame for more details.
 69223:  *
 69223:  * The top of a segment's current frame's expression stack is pointed to by the
 69223:  * segment's "current regs", which contains the stack pointer 'sp'. In the
 69223:  * interpreter, sp is adjusted as individual values are pushed and popped from
 69223:  * the stack and the FrameRegs struct (pointed by the StackSegment) is a local
 69223:  * var of js::Interpret. JIT code simulates this by lazily updating FrameRegs
 69223:  * when calling from JIT code into the VM. Ideally, we'd like to remove all
 69223:  * dependence on FrameRegs outside the interpreter.
 69223:  *
 69223:  * A call to a native (C++) function does not push a frame. Instead, an array
 71697:  * of values is passed to the native. The layout of this array is abstracted by
 71697:  * js::CallArgs. With respect to the StackSegment layout above, the args to a
101075:  * native call are inserted anywhere there can be values. A sample memory layout
 71697:  * looks like:
 71697:  *
 71697:  *                          regs
101075:  *       .------------------------------------------.
 71697:  *       |                                          V
 71697:  *       |                                fp .--FrameRegs--. sp
 71697:  *       |                                   V             V
101075:  * |StackSegment| native call | values |StackFrame| values | native call |
 71697:  *       |       vp <--argc--> end                        vp <--argc--> end
 71697:  *       |           CallArgs <------------------------------ CallArgs
 71697:  *       |                                 prev                  ^
101075:  *       `-------------------------------------------------------'
 71697:  *                                    calls
 71697:  *
 71697:  * Here there are two native calls on the stack. The start of each native arg
 71697:  * range is recorded by a CallArgs element which is prev-linked like stack
 71697:  * frames. Note that, in full generality, native and scripted calls can
 71697:  * interleave arbitrarily. Thus, the end of a segment is the maximum of its
 71697:  * current frame and its current native call. Similarly, the top of the entire
 71697:  * thread stack is the end of its current segment.
 71697:  *
 71697:  * Note that, between any two StackFrames there may be any number
 71697:  * of native calls, so the meaning of 'prev' is not 'directly called by'.
 69223:  *
 69223:  * An additional feature (perhaps not for much longer: bug 650361) is that
 69223:  * multiple independent "contexts" can interleave (LIFO) on a single contiguous
 99837:  * stack. "Independent" here means that each context has its own callstack.
 99837:  * Note, though, that eval-in-frame allows one context's callstack to join
 99837:  * another context's callstack. Thus, in general, the structure of calls in a
 99837:  * StackSpace is a forest.
 99837:  *
 99837:  * More concretely, an embedding may enter the JS engine on cx1 and then, from
 99837:  * a native called by the JS engine, reenter the VM on cx2. Changing from cx1
 99837:  * to cx2 causes a new segment to be started for cx2's stack on top of cx1's
 99837:  * current segment. These two segments are linked from the perspective of
 69223:  * StackSpace, since they are adjacent on the thread's stack, but not from the
 71697:  * perspective of cx1 and cx2. Thus, each segment has two links: prevInMemory
 71697:  * and prevInContext. Each independent stack is encapsulated and managed by
 71697:  * the js::ContextStack object stored in JSContext. ContextStack is the primary
 71697:  * interface to the rest of the engine for pushing and popping the stack.
 69223:  */
 69223: 
 69223: /*****************************************************************************/
 69223: 
 69223: class CallReceiver
 69223: {
 71695:   protected:
 69223: #ifdef DEBUG
 69223:     mutable bool usedRval_;
 71695:     void setUsedRval() const { usedRval_ = true; }
 71695:     void clearUsedRval() const { usedRval_ = false; }
 71695: #else
 71695:     void setUsedRval() const {}
 71695:     void clearUsedRval() const {}
 69223: #endif
 69223:     Value *argv_;
 69223:   public:
 69223:     friend CallReceiver CallReceiverFromVp(Value *);
 69223:     friend CallReceiver CallReceiverFromArgv(Value *);
 69223:     Value *base() const { return argv_ - 2; }
 69223:     JSObject &callee() const { JS_ASSERT(!usedRval_); return argv_[-2].toObject(); }
 69223:     Value &calleev() const { JS_ASSERT(!usedRval_); return argv_[-2]; }
 69223:     Value &thisv() const { return argv_[-1]; }
 69223: 
 69223:     Value &rval() const {
 71695:         setUsedRval();
 69223:         return argv_[-2];
 69223:     }
 69223: 
 71695:     Value *spAfterCall() const {
 71695:         setUsedRval();
 71695:         return argv_ - 1;
 71695:     }
 71695: 
 82027:     void setCallee(Value calleev) {
 71695:         clearUsedRval();
 82027:         this->calleev() = calleev;
 69223:     }
 69223: };
 69223: 
 69223: JS_ALWAYS_INLINE CallReceiver
 71695: CallReceiverFromArgv(Value *argv)
 69223: {
 71695:     CallReceiver receiver;
 71695:     receiver.clearUsedRval();
 71695:     receiver.argv_ = argv;
 71695:     return receiver;
 69223: }
 69223: 
 69223: JS_ALWAYS_INLINE CallReceiver
 71695: CallReceiverFromVp(Value *vp)
 69223: {
 71695:     return CallReceiverFromArgv(vp + 2);
 69223: }
 69223: 
 69223: /*****************************************************************************/
 69223: 
 69223: class CallArgs : public CallReceiver
 69223: {
 71697:   protected:
 91237:     unsigned argc_;
 69223:   public:
 91237:     friend CallArgs CallArgsFromVp(unsigned, Value *);
 91237:     friend CallArgs CallArgsFromArgv(unsigned, Value *);
 91237:     friend CallArgs CallArgsFromSp(unsigned, Value *);
 69223:     Value &operator[](unsigned i) const { JS_ASSERT(i < argc_); return argv_[i]; }
 79387:     Value *array() const { return argv_; }
 91237:     unsigned length() const { return argc_; }
 71695:     Value *end() const { return argv_ + argc_; }
 91388:     bool hasDefined(unsigned i) const { return i < argc_ && !argv_[i].isUndefined(); }
 69223: };
 69223: 
 69223: JS_ALWAYS_INLINE CallArgs
 91237: CallArgsFromArgv(unsigned argc, Value *argv)
 71695: {
 71695:     CallArgs args;
 71695:     args.clearUsedRval();
 71695:     args.argv_ = argv;
 71695:     args.argc_ = argc;
 71695:     return args;
 71695: }
 71695: 
 71695: JS_ALWAYS_INLINE CallArgs
 91237: CallArgsFromVp(unsigned argc, Value *vp)
 69223: {
 71695:     return CallArgsFromArgv(argc, vp + 2);
 69223: }
 69223: 
 69223: JS_ALWAYS_INLINE CallArgs
 91237: CallArgsFromSp(unsigned argc, Value *sp)
 69223: {
 71695:     return CallArgsFromArgv(argc, sp - argc);
 69223: }
 69223: 
 69223: /*****************************************************************************/
 69223: 
 76829: /*
 76829:  * For calls to natives, the InvokeArgsGuard object provides a record of the
 76829:  * call for the debugger's callstack. For this to work, the InvokeArgsGuard
 76829:  * record needs to know when the call is actually active (because the
 76829:  * InvokeArgsGuard can be pushed long before and popped long after the actual
 76829:  * call, during which time many stack-observing things can happen).
 76829:  */
 71697: class CallArgsList : public CallArgs
 71697: {
 71697:     friend class StackSegment;
 71697:     CallArgsList *prev_;
 71697:     bool active_;
 71697:   public:
 91237:     friend CallArgsList CallArgsListFromVp(unsigned, Value *, CallArgsList *);
 91237:     friend CallArgsList CallArgsListFromArgv(unsigned, Value *, CallArgsList *);
 71697:     CallArgsList *prev() const { return prev_; }
 71697:     bool active() const { return active_; }
 71697:     void setActive() { active_ = true; }
 71697:     void setInactive() { active_ = false; }
 71697: };
 71697: 
 71697: JS_ALWAYS_INLINE CallArgsList
 91237: CallArgsListFromArgv(unsigned argc, Value *argv, CallArgsList *prev)
 71697: {
 71697:     CallArgsList args;
 71697: #ifdef DEBUG
 71697:     args.usedRval_ = false;
 71697: #endif
 71697:     args.argv_ = argv;
 71697:     args.argc_ = argc;
 71697:     args.prev_ = prev;
 71697:     args.active_ = false;
 71697:     return args;
 71697: }
 71697: 
 71697: JS_ALWAYS_INLINE CallArgsList
 91237: CallArgsListFromVp(unsigned argc, Value *vp, CallArgsList *prev)
 71697: {
 71697:     return CallArgsListFromArgv(argc, vp + 2, prev);
 71697: }
 71697: 
 71697: /*****************************************************************************/
 71697: 
101075: enum MaybeCheckAliasing { CHECK_ALIASING = true, DONT_CHECK_ALIASING = false };
101075: 
101075: /*****************************************************************************/
101075: 
 87949: /* Flags specified for a frame as it is constructed. */
 87949: enum InitialFrameFlags {
 87949:     INITIAL_NONE           =          0,
101075:     INITIAL_CONSTRUCT      =       0x40, /* == StackFrame::CONSTRUCTING, asserted below */
100006:     INITIAL_LOWERED        =   0x200000  /* == StackFrame::LOWERED_CALL_APPLY, asserted below */
 87949: };
 87949: 
 87949: enum ExecuteType {
 87949:     EXECUTE_GLOBAL         =        0x1, /* == StackFrame::GLOBAL */
 87949:     EXECUTE_DIRECT_EVAL    =        0x8, /* == StackFrame::EVAL */
 87949:     EXECUTE_INDIRECT_EVAL  =        0x9, /* == StackFrame::GLOBAL | EVAL */
 87949:     EXECUTE_DEBUG          =       0x18  /* == StackFrame::EVAL | DEBUGGER */
 87949: };
 87949: 
 87949: /*****************************************************************************/
 87949: 
 69223: class StackFrame
 69223: {
 69223:   public:
 69223:     enum Flags {
 69223:         /* Primary frame type */
 69223:         GLOBAL             =        0x1,  /* frame pushed for a global script */
 69223:         FUNCTION           =        0x2,  /* frame pushed for a scripted call */
 69223:         DUMMY              =        0x4,  /* frame pushed for bookkeeping */
 69223: 
 69223:         /* Frame subtypes */
 69223:         EVAL               =        0x8,  /* frame pushed for eval() or debugger eval */
 69223:         DEBUGGER           =       0x10,  /* frame pushed for debugger eval */
 69223:         GENERATOR          =       0x20,  /* frame is associated with a generator */
101075:         CONSTRUCTING       =       0x40,  /* frame is for a constructor invocation */
 69223: 
 69223:         /* Temporary frame states */
101075:         YIELDING           =       0x80,  /* Interpret dispatched JSOP_YIELD */
101075:         FINISHED_IN_INTERP =      0x100,  /* set if frame finished in Interpret() */
 69223: 
 91174:         /* Function arguments */
101075:         OVERFLOW_ARGS      =      0x200,  /* numActualArgs > numFormalArgs */
101075:         UNDERFLOW_ARGS     =      0x400,  /* numActualArgs < numFormalArgs */
101075: 
101075:         /* Function prologue state */
101075:         HAS_CALL_OBJ       =      0x800,  /* CallObject created for heavyweight fun */
101075:         HAS_ARGS_OBJ       =     0x1000,  /* ArgumentsObject created for needsArgsObj script */
101075:         HAS_NESTING        =     0x2000,  /* NestingPrologue called for frame */
 69223: 
 69223:         /* Lazy frame initialization */
100006:         HAS_HOOK_DATA      =     0x4000,  /* frame has hookData_ set */
100006:         HAS_ANNOTATION     =     0x8000,  /* frame has annotation_ set */
100006:         HAS_RVAL           =    0x10000,  /* frame has rval_ set */
100006:         HAS_SCOPECHAIN     =    0x20000,  /* frame has scopeChain_ set */
100006:         HAS_PREVPC         =    0x40000,  /* frame has prevpc_ and prevInline_ set */
100006:         HAS_BLOCKCHAIN     =    0x80000,  /* frame has blockChain_ set */
 76185: 
 77341:         /* Method JIT state */
100006:         DOWN_FRAMES_EXPANDED = 0x100000,  /* inlining in down frames has been expanded */
101071:         LOWERED_CALL_APPLY   = 0x200000,  /* Pushed by a lowered call/apply */
101071: 
101071:         /* Debugger state */
101071:         PREV_UP_TO_DATE    =   0x400000   /* see DebugScopes::updateLiveScopes */
 69223:     };
 69223: 
 69223:   private:
 84755:     mutable uint32_t    flags_;         /* bits described by Flags */
 69223:     union {                             /* describes what code is executing in a */
 69223:         JSScript        *script;        /*   global frame */
 69223:         JSFunction      *fun;           /*   function frame, pre GetScopeChain */
 69223:     } exec;
 69223:     union {                             /* describes the arguments of a function */
 91237:         unsigned        nactual;        /*   for non-eval frames */
 87583:         JSScript        *evalScript;    /*   the script of an eval-in-function */
 87583:     } u;
101075:     mutable JSObject    *scopeChain_;   /* if HAS_SCOPECHAIN, current scope chain */
101075:     StackFrame          *prev_;         /* if HAS_PREVPC, previous cx->regs->fp */
101075:     void                *ncode_;        /* for a jit frame, return address for method JIT */
101075:     Value               rval_;          /* if HAS_RVAL, return value of the frame */
101075:     StaticBlockObject   *blockChain_;   /* if HAS_BLOCKCHAIN, innermost let block */
101075:     ArgumentsObject     *argsObj_;      /* if HAS_ARGS_OBJ, the call's arguments object */
101075:     jsbytecode          *prevpc_;       /* if HAS_PREVPC, pc of previous frame*/
101075:     InlinedSite         *prevInline_;   /* for a jit frame, inlined site in previous frame */
101075:     void                *hookData_;     /* if HAS_HOOK_DATA, closure returned by call hook */
101075:     void                *annotation_;   /* if HAS_ANNOTATION, perhaps remove with bug 546848 */
101075:     FrameRejoinState    rejoin_;        /* for a jit frame rejoining the interpreter
 76185:                                          * from JIT code, state at rejoin. */
 69223: 
 69223:     static void staticAsserts() {
 71696:         JS_STATIC_ASSERT(offsetof(StackFrame, rval_) % sizeof(Value) == 0);
 71696:         JS_STATIC_ASSERT(sizeof(StackFrame) % sizeof(Value) == 0);
 69223:     }
 69223: 
 69223:     inline void initPrev(JSContext *cx);
101075:     jsbytecode *prevpcSlow(InlinedSite **pinlined);
101075:     void writeBarrierPost();
 69223: 
 69223:     /*
101075:      * These utilities provide raw access to the values associated with a
101075:      * StackFrame (see "VM stack layout" comment). The utilities are private
101075:      * since they are not able to assert that only unaliased vars/formals are
101075:      * accessed. Normal code should prefer the StackFrame::unaliased* members
101075:      * (or FrameRegs::stackDepth for the usual "depth is at least" assertions).
101075:      */
101075:     Value *slots() const { return (Value *)(this + 1); }
101075:     Value *base() const { return slots() + script()->nfixed; }
101075:     Value *formals() const { return (Value *)this - fun()->nargs; }
101075:     Value *actuals() const { return formals() - (flags_ & OVERFLOW_ARGS ? 2 + u.nactual : 0); }
101075: 
101075:     friend class FrameRegs;
101075:     friend class ContextStack;
101075:     friend class StackSpace;
101075:     friend class StackIter;
101075:     friend class CallObject;
101075:     friend class ClonedBlockObject;
101075:     friend class ArgumentsObject;
101075:     friend void ::js_DumpStackFrame(JSContext *, StackFrame *);
101075:     friend void ::js_ReportIsNotFunction(JSContext *, const js::Value *, unsigned);
101075: #ifdef JS_METHODJIT
101075:     friend class mjit::CallCompiler;
101075:     friend class mjit::GetPropCompiler;
101160:     friend struct mjit::ic::GetElementIC;
101075: #endif
101075: 
101075:     /*
101075:      * Frame initialization, called by ContextStack operations after acquiring
101075:      * the raw memory for the frame:
 69223:      */
 69223: 
 69223:     /* Used for Invoke, Interpret, trace-jit LeaveTree, and method-jit stubs. */
 83283:     void initCallFrame(JSContext *cx, JSFunction &callee,
 84755:                        JSScript *script, uint32_t nactual, StackFrame::Flags flags);
 69223: 
 89722:     /* Used for getFixupFrame (for FixupArity). */
 91237:     void initFixupFrame(StackFrame *prev, StackFrame::Flags flags, void *ncode, unsigned nactual);
 69223: 
 69223:     /* Used for eval. */
 71697:     void initExecuteFrame(JSScript *script, StackFrame *prev, FrameRegs *regs,
 71697:                           const Value &thisv, JSObject &scopeChain, ExecuteType type);
 69223: 
 69223:     /* Perhaps one fine day we will remove dummy frames. */
 71695:     void initDummyFrame(JSContext *cx, JSObject &chain);
 69223: 
101075:   public:
101075:     /*
101075:      * Frame prologue/epilogue
101075:      *
101075:      * Every stack frame must have 'prologue' called before executing the
101075:      * first op and 'epilogue' called after executing the last op and before
101075:      * popping the frame (whether the exit is exceptional or not).
101075:      *
101075:      * For inline JS calls/returns, it is easy to call the prologue/epilogue
101075:      * exactly once. When calling JS from C++, Invoke/Execute push the stack
101075:      * frame but do *not* call the prologue/epilogue. That means Interpret
101075:      * must call the prologue/epilogue for the entry frame. This scheme
101075:      * simplifies jit compilation.
101075:      *
101075:      * An important corner case is what happens when an error occurs (OOM,
101075:      * over-recursed) after pushing the stack frame but before 'prologue' is
101075:      * called or completes fully. To simplify usage, 'epilogue' does not assume
101075:      * 'prologue' has completed and handles all the intermediate state details.
101075:      *
101075:      * The 'newType' option indicates whether the constructed 'this' value (if
101075:      * there is one) should be given a new singleton type.
101075:      */
101075: 
101075:     bool prologue(JSContext *cx, bool newType);
101075:     void epilogue(JSContext *cx);
101075: 
101075:     /* Subsets of 'prologue' called from jit code. */
101075:     inline bool jitHeavyweightFunctionPrologue(JSContext *cx);
101075:     inline void jitTypeNestingPrologue(JSContext *cx);
101075:     bool jitStrictEvalPrologue(JSContext *cx);
101075: 
101075:     /* Initialize local variables of newly-pushed frame. */
101075:     void initVarsToUndefined();
101075: 
 69223:     /*
 69223:      * Stack frame type
 69223:      *
 69223:      * A stack frame may have one of three types, which determines which
 69223:      * members of the frame may be accessed and other invariants:
 69223:      *
 69223:      *  global frame:   execution of global code or an eval in global code
 69223:      *  function frame: execution of function code or an eval in a function
 69223:      *  dummy frame:    bookkeeping frame (to be removed in bug 625199)
 69223:      */
 69223: 
 69223:     bool isFunctionFrame() const {
 69223:         return !!(flags_ & FUNCTION);
 69223:     }
 69223: 
 69223:     bool isGlobalFrame() const {
 69223:         return !!(flags_ & GLOBAL);
 69223:     }
 69223: 
 69223:     bool isDummyFrame() const {
 69223:         return !!(flags_ & DUMMY);
 69223:     }
 69223: 
 69223:     bool isScriptFrame() const {
 69223:         bool retval = !!(flags_ & (FUNCTION | GLOBAL));
 69223:         JS_ASSERT(retval == !isDummyFrame());
 69223:         return retval;
 69223:     }
 69223: 
 69223:     /*
 69223:      * Eval frames
 69223:      *
 69223:      * As noted above, global and function frames may optionally be 'eval
 69223:      * frames'. Eval code shares its parent's arguments which means that the
 69223:      * arg-access members of StackFrame may not be used for eval frames.
 69223:      * Search for 'hasArgs' below for more details.
 69223:      *
 69223:      * A further sub-classification of eval frames is whether the frame was
 69223:      * pushed for an ES5 strict-mode eval().
 69223:      */
 69223: 
 69223:     bool isEvalFrame() const {
 69223:         JS_ASSERT_IF(flags_ & EVAL, isScriptFrame());
 69223:         return flags_ & EVAL;
 69223:     }
 69223: 
 71697:     bool isEvalInFunction() const {
 71697:         return (flags_ & (EVAL | FUNCTION)) == (EVAL | FUNCTION);
 71697:     }
 71697: 
 69223:     bool isNonEvalFunctionFrame() const {
 69223:         return (flags_ & (FUNCTION | EVAL)) == FUNCTION;
 69223:     }
 69223: 
 69223:     inline bool isStrictEvalFrame() const {
 69223:         return isEvalFrame() && script()->strictModeCode;
 69223:     }
 69223: 
 69223:     bool isNonStrictEvalFrame() const {
 69223:         return isEvalFrame() && !script()->strictModeCode;
 69223:     }
 69223: 
 98921:     bool isDirectEvalFrame() const {
 98921:         return isEvalFrame() && script()->staticLevel > 0;
 98921:     }
 98921: 
 98921:     bool isNonStrictDirectEvalFrame() const {
 98921:         return isNonStrictEvalFrame() && isDirectEvalFrame();
 98921:     }
 98921: 
 69223:     /*
 69223:      * Previous frame
 69223:      *
 69223:      * A frame's 'prev' frame is either null or the previous frame pointed to
 69223:      * by cx->regs->fp when this frame was pushed. Often, given two prev-linked
 69223:      * frames, the next-frame is a function or eval that was called by the
 69223:      * prev-frame, but not always: the prev-frame may have called a native that
 69223:      * reentered the VM through JS_CallFunctionValue on the same context
 69223:      * (without calling JS_SaveFrameChain) which pushed the next-frame. Thus,
 69223:      * 'prev' has little semantic meaning and basically just tells the VM what
 69223:      * to set cx->regs->fp to when this frame is popped.
 69223:      */
 69223: 
 69223:     StackFrame *prev() const {
 69223:         return prev_;
 69223:     }
 69223: 
 69223:     inline void resetGeneratorPrev(JSContext *cx);
 76185: 
101075:     /*
101075:      * (Unaliased) locals and arguments
101075:      *
101075:      * Only non-eval function frames have arguments. The arguments pushed by
101075:      * the caller are the 'actual' arguments. The declared arguments of the
101075:      * callee are the 'formal' arguments. When the caller passes less or equal
101075:      * actual arguments, the actual and formal arguments are the same array
101075:      * (but with different extents). When the caller passes too many arguments,
101075:      * the formal subset of the actual arguments is copied onto the top of the
101075:      * stack. This allows the engine to maintain a jit-time constant offset of
101075:      * arguments from the frame pointer. Since the formal subset of the actual
101075:      * arguments is potentially on the stack twice, it is important for all
101075:      * reads/writes to refer to the same canonical memory location. This is
101075:      * abstracted by the unaliased{Formal,Actual} methods.
101075:      *
101075:      * When a local/formal variable is "aliased" (accessed by nested closures,
101075:      * dynamic scope operations, or 'arguments), the canonical location for
101075:      * that value is the slot of an activation object (scope or arguments).
101075:      * Currently, all variables are given slots in *both* the stack frame and
101075:      * heap objects, even though, as just described, only one should ever be
101075:      * accessed. Thus, it is up to the code performing an access to access the
101075:      * correct value. These functions assert that accesses to stack values are
101075:      * unaliased. For more about canonical values locations.
101075:      */
101075: 
101075:     inline Value &unaliasedVar(unsigned i, MaybeCheckAliasing = CHECK_ALIASING);
101075:     inline Value &unaliasedLocal(unsigned i, MaybeCheckAliasing = CHECK_ALIASING);
101075: 
101075:     bool hasArgs() const { return isNonEvalFunctionFrame(); }
101075:     inline Value &unaliasedFormal(unsigned i, MaybeCheckAliasing = CHECK_ALIASING);
102445:     inline Value &unaliasedActual(unsigned i, MaybeCheckAliasing = CHECK_ALIASING);
101075:     template <class Op> inline void forEachUnaliasedActual(Op op);
101075: 
101075:     inline unsigned numFormalArgs() const;
101075:     inline unsigned numActualArgs() const;
101075: 
101075:     /*
101075:      * Arguments object
101075:      *
101075:      * If a non-eval function has script->needsArgsObj, an arguments object is
101075:      * created in the prologue and stored in the local variable for the
101075:      * 'arguments' binding (script->argumentsLocal). Since this local is
101075:      * mutable, the arguments object can be overwritten and we can "lose" the
101075:      * arguments object. Thus, StackFrame keeps an explicit argsObj_ field so
101075:      * that the original arguments object is always available.
101075:      */
101075: 
101075:     ArgumentsObject &argsObj() const;
101075:     void initArgsObj(ArgumentsObject &argsobj);
 69223: 
 99225:     inline JSObject *createRestParameter(JSContext *cx);
 99225: 
 69223:     /*
101075:      * Scope chain
 69223:      *
101075:      * In theory, the scope chain would contain an object for every lexical
101075:      * scope. However, only objects that are required for dynamic lookup are
101075:      * actually created.
101075:      *
101075:      * Given that a (non-dummy) StackFrame corresponds roughly to a ES5
101075:      * Execution Context (ES5 10.3), StackFrame::varObj corresponds to the
101075:      * VariableEnvironment component of a Exection Context. Intuitively, the
101075:      * variables object is where new bindings (variables and functions) are
101075:      * stored. One might expect that this is either the Call object or
101075:      * scopeChain.globalObj for function or global code, respectively, however
101075:      * the JSAPI allows calls of Execute to specify a variables object on the
101075:      * scope chain other than the call/global object. This allows embeddings to
101075:      * run multiple scripts under the same global, each time using a new
101075:      * variables object to collect and discard the script's global variables.
 69223:      */
 69223: 
101075:     inline HandleObject scopeChain() const;
101075: 
101075:     inline ScopeObject &aliasedVarScope(ScopeCoordinate sc) const;
101075:     inline GlobalObject &global() const;
101075:     inline CallObject &callObj() const;
101075:     inline JSObject &varObj();
101075: 
101075:     inline void pushOnScopeChain(ScopeObject &scope);
101075:     inline void popOffScopeChain();
101075: 
101075:     /*
101075:      * Block chain
101075:      *
101075:      * Entering/leaving a let (or exception) block may do 1 or 2 things: First,
101075:      * a static block object (created at compiled time and stored in the
101075:      * script) is pushed on StackFrame::blockChain. Second, if the static block
101075:      * may be cloned to hold the dynamic values if this is needed for dynamic
101075:      * scope access. A clone is created for a static block iff
101075:      * StaticBlockObject::needsClone.
101075:      */
101075: 
101075:     bool hasBlockChain() const {
101075:         return (flags_ & HAS_BLOCKCHAIN) && blockChain_;
 69223:     }
 69223: 
101075:     StaticBlockObject *maybeBlockChain() {
101075:         return (flags_ & HAS_BLOCKCHAIN) ? blockChain_ : NULL;
 69223:     }
 69223: 
101075:     StaticBlockObject &blockChain() const {
101075:         JS_ASSERT(hasBlockChain());
101075:         return *blockChain_;
 69223:     }
 69223: 
101075:     bool pushBlock(JSContext *cx, StaticBlockObject &block);
101075:     void popBlock(JSContext *cx);
101075: 
101075:     /*
101075:      * With 
101075:      *
101075:      * Entering/leaving a with (or E4X filter) block pushes/pops an object 
101075:      * on the scope chain. Pushing uses pushOnScopeChain, popping should use
101075:      * popWith.
101075:      */
101075: 
101075:     void popWith(JSContext *cx);
 89723: 
 69223:     /*
 69223:      * Script
 69223:      *
 69223:      * All function and global frames have an associated JSScript which holds
 76185:      * the bytecode being executed for the frame. This script/bytecode does
 76185:      * not reflect any inlining that has been performed by the method JIT.
 76185:      * If other frames were inlined into this one, the script/pc reflect the
 76185:      * point of the outermost call. Inlined frame invariants:
 76185:      *
 76185:      * - Inlined frames have the same scope chain as the outer frame.
 76185:      * - Inlined frames have the same strictness as the outer frame.
 77377:      * - Inlined frames can only make calls to other JIT frames associated with
 77377:      *   the same VMFrame. Other calls force expansion of the inlined frames.
 69223:      */
 69223: 
101075:     JSScript *script() const {
101075:         JS_ASSERT(isScriptFrame());
101075:         return isFunctionFrame()
101075:                ? isEvalFrame() ? u.evalScript : fun()->script()
101075:                : exec.script;
101075:     }
101075: 
101075:     JSScript *maybeScript() const {
101075:         return isScriptFrame() ? script() : NULL;
101075:     }
101075: 
 69223:     /*
102812:      * Get the frame's current bytecode, assuming 'this' is in 'stack'. Beware,
102812:      * as the name implies, pcQuadratic can lead to quadratic behavior in loops
102812:      * such as:
 71363:      *
 71363:      *   for ( ...; fp; fp = fp->prev())
 76185:      *     ... fp->pcQuadratic(cx->stack);
 71363:      *
102812:      * This can be avoided in three ways:
102812:      *  - use ScriptFrameIter, it has O(1) iteration
102812:      *  - if you know the next frame (i.e., next s.t. next->prev == fp
102812:      *  - pcQuadratic will only iterate maxDepth frames (before giving up and
102812:      *    returning fp->script->code), making it O(1), but incorrect.
 69223:      */
101075: 
102812:     jsbytecode *pcQuadratic(const ContextStack &stack, size_t maxDepth = SIZE_MAX);
 99994: 
102812:     /* Return the previous frame's pc. Unlike pcQuadratic, this is O(1). */
102812:     jsbytecode *prevpc(InlinedSite **pinlined = NULL) {
 76185:         if (flags_ & HAS_PREVPC) {
 76185:             if (pinlined)
 76185:                 *pinlined = prevInline_;
 69223:             return prevpc_;
 76185:         }
 76185:         return prevpcSlow(pinlined);
 76185:     }
 76185: 
101075:     InlinedSite *prevInline() {
 76185:         JS_ASSERT(flags_ & HAS_PREVPC);
 76185:         return prevInline_;
 69223:     }
 69223: 
 69223:     /*
 69223:      * Function
 69223:      *
 83474:      * All function frames have an associated interpreted JSFunction. The
 83474:      * function returned by fun() and maybeFun() is not necessarily the
 83474:      * original canonical function which the frame's script was compiled
 83474:      * against. To get this function, use maybeScriptFunction().
 69223:      */
 69223: 
 69223:     JSFunction* fun() const {
 69223:         JS_ASSERT(isFunctionFrame());
 69223:         return exec.fun;
 69223:     }
 69223: 
 69223:     JSFunction* maybeFun() const {
 69223:         return isFunctionFrame() ? fun() : NULL;
 69223:     }
 69223: 
 83474:     JSFunction* maybeScriptFunction() const {
 83474:         if (!isFunctionFrame())
 83474:             return NULL;
 83474:         const StackFrame *fp = this;
 83474:         while (fp->isEvalFrame())
 83474:             fp = fp->prev();
 83474:         return fp->script()->function();
 83474:     }
 83474: 
 69223:     /*
 69223:      * This value
 69223:      *
 69223:      * Every frame has a this value although, until 'this' is computed, the
 69223:      * value may not be the semantically-correct 'this' value.
 69223:      *
 69223:      * The 'this' value is stored before the formal arguments for function
 69223:      * frames and directly before the frame for global frames. The *Args
 69223:      * members assert !isEvalFrame(), so we implement specialized inline
 69223:      * methods for accessing 'this'. When the caller has static knowledge that
101075:      * a frame is a function, 'functionThis' allows more efficient access.
 69223:      */
 69223: 
 71696:     Value &functionThis() const {
 69223:         JS_ASSERT(isFunctionFrame());
 69223:         if (isEvalFrame())
 71696:             return ((Value *)this)[-1];
101075:         return formals()[-1];
 69223:     }
 69223: 
 69223:     JSObject &constructorThis() const {
 69223:         JS_ASSERT(hasArgs());
101075:         return formals()[-1].toObject();
 69223:     }
 69223: 
 71696:     Value &thisValue() const {
 69223:         if (flags_ & (EVAL | GLOBAL))
 71696:             return ((Value *)this)[-1];
101075:         return formals()[-1];
 69223:     }
 69223: 
 69223:     /*
 69223:      * Callee
 69223:      *
 69223:      * Only function frames have a callee. An eval frame in a function has the
 98134:      * same callee as its containing function frame. maybeCalleev can be used
 98134:      * to return a value that is either the callee object (for function frames) or
 71695:      * null (for global frames).
 69223:      */
 69223: 
 98921:     JSFunction &callee() const {
 69223:         JS_ASSERT(isFunctionFrame());
 98921:         return *calleev().toObject().toFunction();
 69223:     }
 69223: 
 71696:     const Value &calleev() const {
 71695:         JS_ASSERT(isFunctionFrame());
 71695:         return mutableCalleev();
 69223:     }
 69223: 
 71696:     const Value &maybeCalleev() const {
 71695:         JS_ASSERT(isScriptFrame());
 71695:         Value &calleev = flags_ & (EVAL | GLOBAL)
 71696:                          ? ((Value *)this)[-2]
101075:                          : formals()[-2];
 71695:         JS_ASSERT(calleev.isObjectOrNull());
 71695:         return calleev;
 71695:     }
 71695: 
 71696:     Value &mutableCalleev() const {
 71695:         JS_ASSERT(isFunctionFrame());
 71695:         if (isEvalFrame())
 71696:             return ((Value *)this)[-2];
101075:         return formals()[-2];
 69223:     }
 69223: 
 71696:     CallReceiver callReceiver() const {
101075:         return CallReceiverFromArgv(formals());
 71695:     }
 71695: 
 69223:     /*
 69223:      * Frame compartment
 69223:      *
 69223:      * A stack frame's compartment is the frame's containing context's
 69223:      * compartment when the frame was pushed.
 69223:      */
 69223: 
 83239:     inline JSCompartment *compartment() const;
 69223: 
 69223:     /* Annotation (will be removed after bug 546848) */
 69223: 
 69223:     void* annotation() const {
 69223:         return (flags_ & HAS_ANNOTATION) ? annotation_ : NULL;
 69223:     }
 69223: 
 69223:     void setAnnotation(void *annot) {
 69223:         flags_ |= HAS_ANNOTATION;
 69223:         annotation_ = annot;
 69223:     }
 69223: 
 76185:     /* JIT rejoin state */
 76185: 
101075:     FrameRejoinState rejoin() const {
 76185:         return rejoin_;
 76185:     }
 76185: 
101075:     void setRejoin(FrameRejoinState state) {
 76185:         rejoin_ = state;
 76185:     }
 76185: 
 76185:     /* Down frame expansion state */
 76185: 
 76185:     void setDownFramesExpanded() {
 76185:         flags_ |= DOWN_FRAMES_EXPANDED;
 76185:     }
 76185: 
 76185:     bool downFramesExpanded() {
 77341:         return !!(flags_ & DOWN_FRAMES_EXPANDED);
 76185:     }
 76185: 
 69223:     /* Debugger hook data */
 69223: 
 69223:     bool hasHookData() const {
 69223:         return !!(flags_ & HAS_HOOK_DATA);
 69223:     }
 69223: 
 69223:     void* hookData() const {
 69223:         JS_ASSERT(hasHookData());
 69223:         return hookData_;
 69223:     }
 69223: 
 69223:     void* maybeHookData() const {
 69223:         return hasHookData() ? hookData_ : NULL;
 69223:     }
 69223: 
 69223:     void setHookData(void *v) {
 69223:         hookData_ = v;
 69223:         flags_ |= HAS_HOOK_DATA;
 69223:     }
 69223: 
 69223:     /* Return value */
 69223: 
 90005:     bool hasReturnValue() const {
 90005:         return !!(flags_ & HAS_RVAL);
 90005:     }
 90005: 
 90302:     Value &returnValue() {
 69223:         if (!(flags_ & HAS_RVAL))
 69223:             rval_.setUndefined();
 69223:         return rval_;
 69223:     }
 69223: 
 69223:     void markReturnValue() {
 69223:         flags_ |= HAS_RVAL;
 69223:     }
 69223: 
 71696:     void setReturnValue(const Value &v) {
 69223:         rval_ = v;
 69223:         markReturnValue();
 69223:     }
 69223: 
 69223:     void clearReturnValue() {
 69223:         rval_.setUndefined();
 69223:         markReturnValue();
 69223:     }
 69223: 
 69223:     /* Native-code return address */
 69223: 
 69223:     void *nativeReturnAddress() const {
 69223:         return ncode_;
 69223:     }
 69223: 
 69223:     void setNativeReturnAddress(void *addr) {
 69223:         ncode_ = addr;
 69223:     }
 69223: 
 69223:     void **addressOfNativeReturnAddress() {
 69223:         return &ncode_;
 69223:     }
 69223: 
 69223:     /*
101075:      * A "generator" frame is a function frame associated with a generator.
101075:      * Since generators are not executed LIFO, the VM copies a single abstract
101075:      * generator frame back and forth between the LIFO VM stack (when the
101075:      * generator is active) and a snapshot stored in JSGenerator (when the
101075:      * generator is inactive). A generator frame is comprised of a StackFrame
101075:      * structure and the values that make up the arguments, locals, and
101075:      * expression stack. The layout in the JSGenerator snapshot matches the
101075:      * layout on the stack (see the "VM stack layout" comment above).
 69223:      */
 69223: 
 69223:     bool isGeneratorFrame() const {
101075:         bool ret = flags_ & GENERATOR;
101075:         JS_ASSERT_IF(ret, isNonEvalFunctionFrame());
101075:         return ret;
 69223:     }
 69223: 
101075:     void initGeneratorFrame() const {
101075:         JS_ASSERT(!isGeneratorFrame());
101075:         JS_ASSERT(isNonEvalFunctionFrame());
101075:         flags_ |= GENERATOR;
 69223:     }
 69223: 
101075:     Value *generatorArgsSnapshotBegin() const {
101075:         JS_ASSERT(isGeneratorFrame());
101075:         return actuals() - 2;
 69223:     }
 69223: 
101075:     Value *generatorArgsSnapshotEnd() const {
101075:         JS_ASSERT(isGeneratorFrame());
101075:         return (Value *)this;
 69223:     }
 69223: 
101075:     Value *generatorSlotsSnapshotBegin() const {
101075:         JS_ASSERT(isGeneratorFrame());
101075:         return (Value *)(this + 1);
 69223:     }
 69223: 
101075:     enum TriggerPostBarriers {
101075:         DoPostBarrier = true,
101075:         NoPostBarrier = false
101075:     };
102714:     template <TriggerPostBarriers doPostBarrier>
102714:     void copyFrameAndValues(JSContext *cx, Value *vp, StackFrame *otherfp,
102714:                             const Value *othervp, Value *othersp);
101075: 
101075:     JSGenerator *maybeSuspendedGenerator(JSRuntime *rt);
101075: 
 69223:     /*
 69223:      * js::Execute pushes both global and function frames (since eval() in a
 69223:      * function pushes a frame with isFunctionFrame() && isEvalFrame()). Most
 69223:      * code should not care where a frame was pushed, but if it is necessary to
 69223:      * pick out frames pushed by js::Execute, this is the right query:
 69223:      */
 69223: 
 69223:     bool isFramePushedByExecute() const {
 69223:         return !!(flags_ & (GLOBAL | EVAL));
 69223:     }
 69223: 
 69223:     /*
 69223:      * Other flags
 69223:      */
 69223: 
 77341:     InitialFrameFlags initialFlags() const {
 77341:         JS_STATIC_ASSERT((int)INITIAL_NONE == 0);
 77341:         JS_STATIC_ASSERT((int)INITIAL_CONSTRUCT == (int)CONSTRUCTING);
 77341:         JS_STATIC_ASSERT((int)INITIAL_LOWERED == (int)LOWERED_CALL_APPLY);
 84755:         uint32_t mask = CONSTRUCTING | LOWERED_CALL_APPLY;
 77341:         JS_ASSERT((flags_ & mask) != mask);
 77341:         return InitialFrameFlags(flags_ & mask);
 77341:     }
 77341: 
 77341:     bool isConstructing() const {
 77341:         return !!(flags_ & CONSTRUCTING);
 77341:     }
 77341: 
102445:     /*
102445:      * These two queries should not be used in general: the presence/absence of
102445:      * the call/args object is determined by the static(ish) properties of the
102445:      * JSFunction/JSScript. These queries should only be performed when probing
102445:      * a stack frame that may be in the middle of the prologue (during which
102445:      * time the call/args object are created).
102445:      */
102445: 
101075:     bool hasCallObj() const {
101075:         JS_ASSERT(isStrictEvalFrame() || fun()->isHeavyweight());
101075:         return flags_ & HAS_CALL_OBJ;
101075:     }
101075: 
102445:     bool hasArgsObj() const {
102445:         JS_ASSERT(script()->needsArgsObj());
102445:         return flags_ & HAS_ARGS_OBJ;
102445:     }
102445: 
 77341:     /*
 77341:      * The method JIT call/apply optimization can erase Function.{call,apply}
 77341:      * invocations from the stack and push the callee frame directly. The base
 77341:      * of these frames will be offset by one value, however, which the
 77341:      * interpreter needs to account for if it ends up popping the frame.
 77341:      */
 77341:     bool loweredCallOrApply() const {
 77341:         return !!(flags_ & LOWERED_CALL_APPLY);
 69223:     }
 69223: 
 69223:     bool isDebuggerFrame() const {
 69223:         return !!(flags_ & DEBUGGER);
 69223:     }
 69223: 
101071:     bool prevUpToDate() const {
101071:         return !!(flags_ & PREV_UP_TO_DATE);
101071:     }
101071: 
101071:     void setPrevUpToDate() {
101071:         flags_ |= PREV_UP_TO_DATE;
101071:     }
101071: 
 69223:     bool isYielding() {
 69223:         return !!(flags_ & YIELDING);
 69223:     }
 69223: 
 69223:     void setYielding() {
 69223:         flags_ |= YIELDING;
 69223:     }
 69223: 
 69223:     void clearYielding() {
 69223:         flags_ &= ~YIELDING;
 69223:     }
 69223: 
 69223:     void setFinishedInInterpreter() {
 69223:         flags_ |= FINISHED_IN_INTERP;
 69223:     }
 69223: 
 69223:     bool finishedInInterpreter() const {
 69223:         return !!(flags_ & FINISHED_IN_INTERP);
 69223:     }
 69223: 
 69223:   public:
 69223:     /* Public, but only for JIT use: */
 69223: 
101075:     inline void resetInlinePrev(StackFrame *prevfp, jsbytecode *prevpc);
101075:     inline void initInlineFrame(JSFunction *fun, StackFrame *prevfp, jsbytecode *prevpc);
101075: 
 69223:     static size_t offsetOfFlags() {
 69223:         return offsetof(StackFrame, flags_);
 69223:     }
 69223: 
 69223:     static size_t offsetOfExec() {
 69223:         return offsetof(StackFrame, exec);
 69223:     }
 69223: 
 87583:     static size_t offsetOfNumActual() {
 87583:         return offsetof(StackFrame, u.nactual);
 69223:     }
 69223: 
 69223:     static size_t offsetOfScopeChain() {
 69223:         return offsetof(StackFrame, scopeChain_);
 69223:     }
 69223: 
 69223:     static size_t offsetOfPrev() {
 69223:         return offsetof(StackFrame, prev_);
 69223:     }
 69223: 
 69223:     static size_t offsetOfReturnValue() {
 69223:         return offsetof(StackFrame, rval_);
 69223:     }
 69223: 
101075:     static ptrdiff_t offsetOfNcode() {
101075:         return offsetof(StackFrame, ncode_);
100006:     }
100006: 
101075:     static ptrdiff_t offsetOfArgsObj() {
101075:         return offsetof(StackFrame, argsObj_);
 87583:     }
 87583: 
 69223:     static ptrdiff_t offsetOfCallee(JSFunction *fun) {
 69223:         JS_ASSERT(fun != NULL);
 71696:         return -(fun->nargs + 2) * sizeof(Value);
 69223:     }
 69223: 
 69223:     static ptrdiff_t offsetOfThis(JSFunction *fun) {
 69223:         return fun == NULL
 71696:                ? -1 * ptrdiff_t(sizeof(Value))
 71696:                : -(fun->nargs + 1) * ptrdiff_t(sizeof(Value));
 69223:     }
 69223: 
 91237:     static ptrdiff_t offsetOfFormalArg(JSFunction *fun, unsigned i) {
 69223:         JS_ASSERT(i < fun->nargs);
 71696:         return (-(int)fun->nargs + i) * sizeof(Value);
 69223:     }
 69223: 
 91237:     static size_t offsetOfFixed(unsigned i) {
 71696:         return sizeof(StackFrame) + i * sizeof(Value);
 69223:     }
 69223: 
 69223: #ifdef JS_METHODJIT
 98147:     inline mjit::JITScript *jit();
 69223: #endif
 69223: 
 69223:     void methodjitStaticAsserts();
 89965: 
 89965:   public:
 89965:     void mark(JSTracer *trc);
 69223: };
 69223: 
 69223: static const size_t VALUES_PER_STACK_FRAME = sizeof(StackFrame) / sizeof(Value);
 69223: 
 91237: static inline unsigned
 77341: ToReportFlags(InitialFrameFlags initial)
 71695: {
 91237:     return unsigned(initial & StackFrame::CONSTRUCTING);
 71695: }
 71695: 
 71695: static inline StackFrame::Flags
 77341: ToFrameFlags(InitialFrameFlags initial)
 71695: {
 77341:     return StackFrame::Flags(initial);
 71695: }
 71695: 
 77341: static inline InitialFrameFlags
 77341: InitialFrameFlagsFromConstructing(bool b)
 71695: {
 77341:     return b ? INITIAL_CONSTRUCT : INITIAL_NONE;
 77341: }
 77341: 
 77341: static inline bool
 77341: InitialFrameFlagsAreConstructing(InitialFrameFlags initial)
 77341: {
 77341:     return !!(initial & INITIAL_CONSTRUCT);
 77341: }
 77341: 
 77341: static inline bool
 77341: InitialFrameFlagsAreLowered(InitialFrameFlags initial)
 77341: {
 77341:     return !!(initial & INITIAL_LOWERED);
 71695: }
 71695: 
 69223: inline StackFrame *          Valueify(JSStackFrame *fp) { return (StackFrame *)fp; }
 69223: static inline JSStackFrame * Jsvalify(StackFrame *fp)   { return (JSStackFrame *)fp; }
 69223: 
 69223: /*****************************************************************************/
 69223: 
 69223: class FrameRegs
 69223: {
 69223:   public:
 69223:     Value *sp;
 69223:     jsbytecode *pc;
 69223:   private:
101075:     InlinedSite *inlined_;
 69223:     StackFrame *fp_;
 69223:   public:
 69223:     StackFrame *fp() const { return fp_; }
101075:     InlinedSite *inlined() const { return inlined_; }
 69223: 
 69223:     /* For jit use (need constant): */
 76185:     static const size_t offsetOfFp = 3 * sizeof(void *);
 76185:     static const size_t offsetOfInlined = 2 * sizeof(void *);
 69223:     static void staticAssert() {
 69223:         JS_STATIC_ASSERT(offsetOfFp == offsetof(FrameRegs, fp_));
 76185:         JS_STATIC_ASSERT(offsetOfInlined == offsetof(FrameRegs, inlined_));
 69223:     }
 76185:     void clearInlined() { inlined_ = NULL; }
 69223: 
101075:     unsigned stackDepth() const {
101075:         JS_ASSERT(sp >= fp_->base());
101075:         return sp - fp_->base();
101075:     }
101075: 
101075:     Value *spForStackDepth(unsigned depth) const {
101075:         JS_ASSERT(fp_->script()->nfixed + depth <= fp_->script()->nslots);
101075:         return fp_->base() + depth;
101075:     }
101075: 
 69223:     /* For generator: */
 71697:     void rebaseFromTo(const FrameRegs &from, StackFrame &to) {
 71697:         fp_ = &to;
 71697:         sp = to.slots() + (from.sp - from.fp_->slots());
 71695:         pc = from.pc;
 76185:         inlined_ = from.inlined_;
 71697:         JS_ASSERT(fp_);
 69223:     }
 69223: 
 69223:     /* For ContextStack: */
 69223:     void popFrame(Value *newsp) {
 76185:         pc = fp_->prevpc(&inlined_);
 69223:         sp = newsp;
 69223:         fp_ = fp_->prev();
 71697:         JS_ASSERT(fp_);
 69223:     }
 69223: 
 69223:     /* For FixupArity: */
 69223:     void popPartialFrame(Value *newsp) {
 69223:         sp = newsp;
 69223:         fp_ = fp_->prev();
 71697:         JS_ASSERT(fp_);
 69223:     }
 69223: 
 76185:     /* For InternalInterpret: */
 76185:     void restorePartialFrame(Value *newfp) {
 76185:         fp_ = (StackFrame *) newfp;
 76185:     }
 76185: 
 97878:     /* For EnterMethodJIT: */
 97878:     void refreshFramePointer(StackFrame *fp) {
 97878:         fp_ = fp;
 97878:     }
 97878: 
 69223:     /* For stubs::CompileFunction, ContextStack: */
 71697:     void prepareToRun(StackFrame &fp, JSScript *script) {
 69223:         pc = script->code;
 71697:         sp = fp.slots() + script->nfixed;
 71697:         fp_ = &fp;
 76185:         inlined_ = NULL;
 69223:     }
 69223: 
 97878:     void setToEndOfScript() {
 97878:         JSScript *script = fp()->script();
 97878:         sp = fp()->base();
 97878:         pc = script->code + script->length - JSOP_STOP_LENGTH;
 97878:         JS_ASSERT(*pc == JSOP_STOP);
 97878:     }
 97878: 
 69223:     /* For pushDummyFrame: */
 71697:     void initDummyFrame(StackFrame &fp) {
 69223:         pc = NULL;
 71697:         sp = fp.slots();
 71697:         fp_ = &fp;
 76185:         inlined_ = NULL;
 69223:     }
 76185: 
 76185:     /* For expandInlineFrames: */
 76185:     void expandInline(StackFrame *innerfp, jsbytecode *innerpc) {
 76185:         pc = innerpc;
 76185:         fp_ = innerfp;
 76185:         inlined_ = NULL;
 76185:     }
 76185: 
 76185: #ifdef JS_METHODJIT
 76185:     /* For LimitCheck: */
 76185:     void updateForNcode(mjit::JITScript *jit, void *ncode) {
 76185:         pc = mjit::NativeToPC(jit, ncode, &inlined_);
 76185:     }
 76185: #endif
 69223: };
 69223: 
 69223: /*****************************************************************************/
 69223: 
 71697: class StackSegment
 69223: {
 71697:     /* Previous segment within same context stack. */
 71697:     StackSegment *const prevInContext_;
 71697: 
 71697:     /* Previous segment sequentially in memory. */
 71697:     StackSegment *const prevInMemory_;
 71697: 
 71697:     /* Execution registers for most recent script in this segment (or null). */
 71697:     FrameRegs *regs_;
 71697: 
 71697:     /* Call args for most recent native call in this segment (or null). */
 71697:     CallArgsList *calls_;
 71697: 
 71697:   public:
 71697:     StackSegment(StackSegment *prevInContext,
 71697:                  StackSegment *prevInMemory,
 71697:                  FrameRegs *regs,
 71697:                  CallArgsList *calls)
 71697:       : prevInContext_(prevInContext),
 71697:         prevInMemory_(prevInMemory),
 71697:         regs_(regs),
 71697:         calls_(calls)
 71697:     {}
 71697: 
 71697:     /* A segment is followed in memory by the arguments of the first call. */
 71697: 
 71697:     Value *slotsBegin() const {
 71697:         return (Value *)(this + 1);
 71697:     }
 71697: 
 71697:     /* Accessors. */
 71697: 
 71697:     FrameRegs &regs() const {
 71697:         JS_ASSERT(regs_);
 71697:         return *regs_;
 71697:     }
 71697: 
 71697:     FrameRegs *maybeRegs() const {
 71697:         return regs_;
 71697:     }
 71697: 
 71697:     StackFrame *fp() const {
 71697:         return regs_->fp();
 71697:     }
 71697: 
 71697:     StackFrame *maybefp() const {
 71697:         return regs_ ? regs_->fp() : NULL;
 71697:     }
 71697: 
 89965:     jsbytecode *maybepc() const {
 89965:         return regs_ ? regs_->pc : NULL;
 89965:     }
 89965: 
 71697:     CallArgsList &calls() const {
 71697:         JS_ASSERT(calls_);
 71697:         return *calls_;
 71697:     }
 71697: 
 71697:     CallArgsList *maybeCalls() const {
 71697:         return calls_;
 71697:     }
 71697: 
 71697:     Value *callArgv() const {
 79387:         return calls_->array();
 71697:     }
 71697: 
 71697:     Value *maybeCallArgv() const {
 79387:         return calls_ ? calls_->array() : NULL;
 71697:     }
 71697: 
 71697:     StackSegment *prevInContext() const {
 71697:         return prevInContext_;
 71697:     }
 71697: 
 71697:     StackSegment *prevInMemory() const {
 71697:         return prevInMemory_;
 71697:     }
 71697: 
 71697:     void repointRegs(FrameRegs *regs) {
 71697:         JS_ASSERT_IF(regs, regs->fp());
 71697:         regs_ = regs;
 71697:     }
 71697: 
 71697:     bool isEmpty() const {
 71697:         return !calls_ && !regs_;
 71697:     }
 71697: 
 71697:     bool contains(const StackFrame *fp) const;
 71697:     bool contains(const FrameRegs *regs) const;
 71697:     bool contains(const CallArgsList *call) const;
 71697: 
102812:     StackFrame *computeNextFrame(const StackFrame *fp, size_t maxDepth) const;
 71697: 
 71697:     Value *end() const;
 71697: 
 71697:     FrameRegs *pushRegs(FrameRegs &regs);
 71697:     void popRegs(FrameRegs *regs);
 71697:     void pushCall(CallArgsList &callList);
 71767:     void pointAtCall(CallArgsList &callList);
 71697:     void popCall();
 71697: 
 71697:     /* For jit access: */
 71697: 
 71697:     static const size_t offsetOfRegs() { return offsetof(StackSegment, regs_); }
 69223: };
 69223: 
 71697: static const size_t VALUES_PER_STACK_SEGMENT = sizeof(StackSegment) / sizeof(Value);
 71697: JS_STATIC_ASSERT(sizeof(StackSegment) % sizeof(Value) == 0);
 71697: 
 87949: /*****************************************************************************/
 69223: 
 87949: class StackSpace
 87949: {
 87949:     StackSegment  *seg_;
 87949:     Value         *base_;
 87949:     mutable Value *conservativeEnd_;
 87949: #ifdef XP_WIN
 87949:     mutable Value *commitEnd_;
 87949: #endif
 87949:     Value         *defaultEnd_;
 87949:     Value         *trustedEnd_;
 69223: 
 87949:     void assertInvariants() const {
 87949:         JS_ASSERT(base_ <= conservativeEnd_);
 87949: #ifdef XP_WIN
 87949:         JS_ASSERT(conservativeEnd_ <= commitEnd_);
 87949:         JS_ASSERT(commitEnd_ <= trustedEnd_);
 87949: #endif
 87949:         JS_ASSERT(conservativeEnd_ <= defaultEnd_);
 87949:         JS_ASSERT(defaultEnd_ <= trustedEnd_);
 87949:     }
 73495: 
 87949:     /* The total number of values/bytes reserved for the stack. */
 87949:     static const size_t CAPACITY_VALS  = 512 * 1024;
 87949:     static const size_t CAPACITY_BYTES = CAPACITY_VALS * sizeof(Value);
 73495: 
 87949:     /* How much of the stack is initially committed. */
 87949:     static const size_t COMMIT_VALS    = 16 * 1024;
 87949:     static const size_t COMMIT_BYTES   = COMMIT_VALS * sizeof(Value);
 69223: 
 87949:     /* How much space is reserved at the top of the stack for trusted JS. */
 87949:     static const size_t BUFFER_VALS    = 16 * 1024;
 87949:     static const size_t BUFFER_BYTES   = BUFFER_VALS * sizeof(Value);
 87949: 
 87949:     static void staticAsserts() {
 87949:         JS_STATIC_ASSERT(CAPACITY_VALS % COMMIT_VALS == 0);
 87949:     }
 87949: 
 87949:     friend class AllFramesIter;
 87949:     friend class ContextStack;
 87949:     friend class StackFrame;
 87949: 
 87949:     /*
 87949:      * Except when changing compartment (see pushDummyFrame), the 'dest'
 87949:      * parameter of ensureSpace is cx->compartment. Ideally, we'd just pass
 87949:      * this directly (and introduce a helper that supplies cx->compartment when
 87949:      * no 'dest' is given). For some compilers, this really hurts performance,
 87949:      * so, instead, a trivially sinkable magic constant is used to indicate
 87949:      * that dest should be cx->compartment.
 87949:      */
 87949:     static const size_t CX_COMPARTMENT = 0xc;
 87949: 
 87949:     inline bool ensureSpace(JSContext *cx, MaybeReportError report,
 87949:                             Value *from, ptrdiff_t nvals,
 87949:                             JSCompartment *dest = (JSCompartment *)CX_COMPARTMENT) const;
 87949:     JS_FRIEND_API(bool) ensureSpaceSlow(JSContext *cx, MaybeReportError report,
 87949:                                         Value *from, ptrdiff_t nvals,
 87949:                                         JSCompartment *dest) const;
 87949: 
 87949:     StackSegment &findContainingSegment(const StackFrame *target) const;
 87949: 
101075:     bool containsFast(StackFrame *fp) {
101075:         return (Value *)fp >= base_ && (Value *)fp <= trustedEnd_;
101075:     }
101075: 
 87949:   public:
 87949:     StackSpace();
 87949:     bool init();
 87949:     ~StackSpace();
 87949: 
 87949:     /*
 87949:      * Maximum supported value of arguments.length. This bounds the maximum
 87949:      * number of arguments that can be supplied to Function.prototype.apply.
 87949:      * This value also bounds the number of elements parsed in an array
 87949:      * initialiser.
 87949:      *
 87949:      * Since arguments are copied onto the stack, the stack size is the
 87949:      * limiting factor for this constant. Use the max stack size (available to
 87949:      * untrusted code) with an extra buffer so that, after such an apply, the
 87949:      * callee can do a little work without OOMing.
 87949:      */
 91237:     static const unsigned ARGS_LENGTH_MAX = CAPACITY_VALS - (2 * BUFFER_VALS);
 87949: 
 87949:     /* See stack layout comment in Stack.h. */
 87949:     inline Value *firstUnused() const { return seg_ ? seg_->end() : base_; }
 87949: 
 87949:     StackSegment &containingSegment(const StackFrame *target) const;
 87949: 
 87949:     /*
 87949:      * Extra space to reserve on the stack for method JIT frames, beyond the
 87949:      * frame's nslots. This may be used for inlined stack frames, slots storing
 87949:      * loop invariant code, or to reserve space for pushed callee frames. Note
 87949:      * that this space should be reserved when pushing interpreter frames as
 87949:      * well, so that we don't need to check the stack when entering the method
 87949:      * JIT at loop heads or safe points.
 87949:      */
 87949:     static const size_t STACK_JIT_EXTRA = (/*~VALUES_PER_STACK_FRAME*/ 8 + 18) * 10;
 87949: 
 87949:     /*
 87949:      * Return a limit against which jit code can check for. This limit is not
 87949:      * necessarily the end of the stack since we lazily commit stack memory on
 87949:      * some platforms. Thus, when the stack limit is exceeded, the caller should
 87949:      * use tryBumpLimit to attempt to increase the stack limit by committing
 87949:      * more memory. If the stack is truly exhausted, tryBumpLimit will report an
 87949:      * error and return NULL.
 87949:      *
 87949:      * An invariant of the methodjit is that there is always space to push a
 87949:      * frame on top of the current frame's expression stack (which can be at
 87949:      * most script->nslots deep). getStackLimit ensures that the returned limit
 87949:      * does indeed have this required space and reports an error and returns
 87949:      * NULL if this reserve space cannot be allocated.
 87949:      */
 87949:     inline Value *getStackLimit(JSContext *cx, MaybeReportError report);
 91237:     bool tryBumpLimit(JSContext *cx, Value *from, unsigned nvals, Value **limit);
 87949: 
 87949:     /* Called during GC: mark segments, frames, and slots under firstUnused. */
 87949:     void mark(JSTracer *trc);
101075:     void markFrameValues(JSTracer *trc, StackFrame *fp, Value *slotsEnd, jsbytecode *pc);
 87949: 
 90410:     /* Called during GC: sets active flag on compartments with active frames. */
 90410:     void markActiveCompartments();
 90410: 
 87949:     /* We only report the committed size;  uncommitted size is uninteresting. */
 87949:     JS_FRIEND_API(size_t) sizeOfCommitted();
 98783: 
 98783: #ifdef DEBUG
 98783:     bool containsSlow(StackFrame *fp);
 98783: #endif
 87949: };
 87949: 
 87949: /*****************************************************************************/
 87949: 
 87949: class ContextStack
 87949: {
 87949:     StackSegment *seg_;
 91250:     StackSpace *const space_;
 87949:     JSContext *cx_;
 87949: 
 87949:     /*
 87949:      * Return whether this ContextStack is at the top of the contiguous stack.
 87949:      * This is a precondition for extending the current segment by pushing
 87949:      * stack frames or overrides etc.
 87949:      *
 87949:      * NB: Just because a stack is onTop() doesn't mean there is necessarily
 87949:      * a frame pushed on the stack. For this, use hasfp().
 87949:      */
 87949:     bool onTop() const;
 87949: 
 87949: #ifdef DEBUG
 87949:     void assertSpaceInSync() const;
 87949: #else
 87949:     void assertSpaceInSync() const {}
 87949: #endif
 87949: 
 87949:     /* Implementation details of push* public interface. */
 87949:     StackSegment *pushSegment(JSContext *cx);
 87949:     enum MaybeExtend { CAN_EXTEND = true, CANT_EXTEND = false };
 91237:     Value *ensureOnTop(JSContext *cx, MaybeReportError report, unsigned nvars,
 87949:                        MaybeExtend extend, bool *pushedSeg,
 87949:                        JSCompartment *dest = (JSCompartment *)StackSpace::CX_COMPARTMENT);
 87949: 
 87949:     inline StackFrame *
 87949:     getCallFrame(JSContext *cx, MaybeReportError report, const CallArgs &args,
 89722:                  JSFunction *fun, JSScript *script, StackFrame::Flags *pflags) const;
 87949: 
 87949:     /* Make pop* functions private since only called by guard classes. */
 87949:     void popSegment();
 87949:     friend class InvokeArgsGuard;
 87949:     void popInvokeArgs(const InvokeArgsGuard &iag);
 87949:     friend class FrameGuard;
 87949:     void popFrame(const FrameGuard &fg);
 87949:     friend class GeneratorFrameGuard;
 87949:     void popGeneratorFrame(const GeneratorFrameGuard &gfg);
 87949: 
 87949:     friend class StackIter;
 87949: 
 87949:   public:
 87949:     ContextStack(JSContext *cx);
 87949:     ~ContextStack();
 87949: 
 87949:     /*** Stack accessors ***/
 87949: 
 87949:     /*
 87949:      * A context's stack is "empty" if there are no scripts or natives
 87949:      * executing. Note that JS_SaveFrameChain does not factor into this definition.
 87949:      */
 87949:     bool empty() const                { return !seg_; }
 87949: 
 87949:     /*
 87949:      * Return whether there has been at least one frame pushed since the most
 87949:      * recent call to JS_SaveFrameChain. Note that natives do not have frames
 87949:      * and dummy frames are frames that do not represent script execution hence
 87949:      * this query has little semantic meaning past "you can call fp()".
 87949:      */
 87949:     inline bool hasfp() const { return seg_ && seg_->maybeRegs(); }
 87949: 
 87949:     /*
 87949:      * Return the most recent script activation's registers with the same
 87949:      * caveat as hasfp regarding JS_SaveFrameChain.
 87949:      */
 87949:     inline FrameRegs *maybeRegs() const { return seg_ ? seg_->maybeRegs() : NULL; }
 87949:     inline StackFrame *maybefp() const { return seg_ ? seg_->maybefp() : NULL; }
 87949: 
 87949:     /* Faster alternatives to maybe* functions. */
 87949:     inline FrameRegs &regs() const { JS_ASSERT(hasfp()); return seg_->regs(); }
 87949:     inline StackFrame *fp() const { JS_ASSERT(hasfp()); return seg_->fp(); }
 87949: 
 87949:     /* The StackSpace currently hosting this ContextStack. */
 87949:     StackSpace &space() const { return *space_; }
 87949: 
 87949:     /* Return whether the given frame is in this context's stack. */
 87949:     bool containsSlow(const StackFrame *target) const;
 87949: 
 87949:     /*** Stack manipulation ***/
 87949: 
 87949:     /*
 87949:      * pushInvokeArgs allocates |argc + 2| rooted values that will be passed as
 87949:      * the arguments to Invoke. A single allocation can be used for multiple
 87949:      * Invoke calls. The InvokeArgumentsGuard passed to Invoke must come from
 87949:      * an immediately-enclosing (stack-wise) call to pushInvokeArgs.
 87949:      */
 91237:     bool pushInvokeArgs(JSContext *cx, unsigned argc, InvokeArgsGuard *ag);
 87949: 
 87949:     /* Called by Invoke for a scripted function call. */
 87949:     bool pushInvokeFrame(JSContext *cx, const CallArgs &args,
 87949:                          InitialFrameFlags initial, InvokeFrameGuard *ifg);
 87949: 
 87949:     /* Called by Execute for execution of eval or global code. */
 87949:     bool pushExecuteFrame(JSContext *cx, JSScript *script, const Value &thisv,
 87949:                           JSObject &scopeChain, ExecuteType type,
 87949:                           StackFrame *evalInFrame, ExecuteFrameGuard *efg);
 87949: 
 87949:     /*
 87949:      * Called by SendToGenerator to resume a yielded generator. In addition to
 87949:      * pushing a frame onto the VM stack, this function copies over the
 87949:      * floating frame stored in 'gen'. When 'gfg' is destroyed, the destructor
 87949:      * will copy the frame back to the floating frame.
 87949:      */
 87949:     bool pushGeneratorFrame(JSContext *cx, JSGenerator *gen, GeneratorFrameGuard *gfg);
 87949: 
 87949:     /*
 87949:      * When changing the compartment of a cx, it is necessary to immediately
 87949:      * change the scope chain to a global in the right compartment since any
 87949:      * amount of general VM code can run before the first scripted frame is
 87949:      * pushed (if at all). This is currently and hackily accomplished by
 87949:      * pushing a "dummy frame" with the correct scope chain. On success, this
 87949:      * function will change the compartment to 'scopeChain.compartment()' and
 87949:      * push a dummy frame for 'scopeChain'. On failure, nothing is changed.
 87949:      */
 87949:     bool pushDummyFrame(JSContext *cx, JSCompartment *dest, JSObject &scopeChain, DummyFrameGuard *dfg);
 87949: 
 87949:     /*
 87949:      * An "inline frame" may only be pushed from within the top, active
 87949:      * segment. This is the case for calls made inside mjit code and Interpret.
 87949:      * The 'stackLimit' overload updates 'stackLimit' if it changes.
 87949:      */
 87949:     bool pushInlineFrame(JSContext *cx, FrameRegs &regs, const CallArgs &args,
 87949:                          JSFunction &callee, JSScript *script,
 87949:                          InitialFrameFlags initial);
 87949:     bool pushInlineFrame(JSContext *cx, FrameRegs &regs, const CallArgs &args,
 87949:                          JSFunction &callee, JSScript *script,
 87949:                          InitialFrameFlags initial, Value **stackLimit);
 87949:     void popInlineFrame(FrameRegs &regs);
 87949: 
 87949:     /* Pop a partially-pushed frame after hitting the limit before throwing. */
 87949:     void popFrameAfterOverflow();
 87949: 
 87949:     /* Get the topmost script and optional pc on the stack. */
 87949:     inline JSScript *currentScript(jsbytecode **pc = NULL) const;
 87949: 
 87949:     /* Get the scope chain for the topmost scripted call on the stack. */
 96793:     inline HandleObject currentScriptedScopeChain() const;
 87949: 
 87949:     /*
 87949:      * Called by the methodjit for an arity mismatch. Arity mismatch can be
 87949:      * hot, so getFixupFrame avoids doing call setup performed by jit code when
 89722:      * FixupArity returns.
 87949:      */
 87949:     StackFrame *getFixupFrame(JSContext *cx, MaybeReportError report,
 87949:                               const CallArgs &args, JSFunction *fun, JSScript *script,
 87949:                               void *ncode, InitialFrameFlags initial, Value **stackLimit);
 87949: 
 87949:     bool saveFrameChain();
 87949:     void restoreFrameChain();
 87949: 
 87949:     /*
 87949:      * As an optimization, the interpreter/mjit can operate on a local
 87949:      * FrameRegs instance repoint the ContextStack to this local instance.
 87949:      */
 87949:     inline void repointRegs(FrameRegs *regs) { JS_ASSERT(hasfp()); seg_->repointRegs(regs); }
 87949: 
 87949:     /*** For JSContext: ***/
 87949: 
 87949:     /*
 87949:      * To avoid indirection, ContextSpace caches a pointer to the StackSpace.
 87949:      * This must be kept coherent with cx->thread->data.space by calling
 87949:      * 'threadReset' whenver cx->thread changes.
 87949:      */
 87949:     void threadReset();
 87949: 
 87949:     /*** For jit compiler: ***/
 87949: 
 87949:     static size_t offsetOfSeg() { return offsetof(ContextStack, seg_); }
 87949: };
 69223: 
 69223: /*****************************************************************************/
 69223: 
 71697: class InvokeArgsGuard : public CallArgsList
 69223: {
 69223:     friend class ContextStack;
 71697:     ContextStack *stack_;
 71697:     bool pushedSeg_;
 71697:     void setPushed(ContextStack &stack) { JS_ASSERT(!pushed()); stack_ = &stack; }
 69223:   public:
 71697:     InvokeArgsGuard() : CallArgsList(), stack_(NULL), pushedSeg_(false) {}
 71697:     ~InvokeArgsGuard() { if (pushed()) stack_->popInvokeArgs(*this); }
 71697:     bool pushed() const { return !!stack_; }
 71697:     void pop() { stack_->popInvokeArgs(*this); stack_ = NULL; }
 69223: };
 69223: 
 69223: class FrameGuard
 69223: {
 71695:   protected:
 69223:     friend class ContextStack;
 71697:     ContextStack *stack_;
 71697:     bool pushedSeg_;
 71695:     FrameRegs regs_;
 71697:     FrameRegs *prevRegs_;
 71697:     void setPushed(ContextStack &stack) { stack_ = &stack; }
 69223:   public:
 71697:     FrameGuard() : stack_(NULL), pushedSeg_(false) {}
 71697:     ~FrameGuard() { if (pushed()) stack_->popFrame(*this); }
 71697:     bool pushed() const { return !!stack_; }
 71697:     void pop() { stack_->popFrame(*this); stack_ = NULL; }
 71697: 
 71695:     StackFrame *fp() const { return regs_.fp(); }
 69223: };
 69223: 
 71697: class InvokeFrameGuard : public FrameGuard
 71697: {};
 71697: 
 69223: class ExecuteFrameGuard : public FrameGuard
 71695: {};
 71695: 
 71695: class DummyFrameGuard : public FrameGuard
 71695: {};
 71695: 
 71695: class GeneratorFrameGuard : public FrameGuard
 69223: {
 69223:     friend class ContextStack;
 71695:     JSGenerator *gen_;
 71695:     Value *stackvp_;
 71695:   public:
 71697:     ~GeneratorFrameGuard() { if (pushed()) stack_->popGeneratorFrame(*this); }
 69223: };
 69223: 
 69223: /*****************************************************************************/
 69223: 
 69223: /*
 99837:  * Iterate through the callstack (following fp->prev) of the given context.
 99837:  * Each element of said callstack can either be the execution of a script
 99837:  * (scripted function call, global code, eval code, debugger code) or the
 99837:  * invocation of a (C++) native. Example usage:
 69223:  *
 71697:  *   for (Stackiter i(cx); !i.done(); ++i) {
 71697:  *     if (i.isScript()) {
 69223:  *       ... i.fp() ... i.sp() ... i.pc()
 71697:  *     } else {
 71697:  *       JS_ASSERT(i.isNativeCall());
 71697:  *       ... i.args();
 71697:  *     }
 87949:  *   }
 71697:  *
 71697:  * The SavedOption parameter additionally lets the iterator continue through
 71697:  * breaks in the callstack (from JS_SaveFrameChain). The default is to stop.
 69223:  */
 71697: class StackIter
 71697: {
 71697:     friend class ContextStack;
 98784:     JSContext    *maybecx_;
 71697:   public:
 71697:     enum SavedOption { STOP_AT_SAVED, GO_THROUGH_SAVED };
 71697:   private:
 71697:     SavedOption  savedOption_;
 71697: 
103273:     enum State { DONE, SCRIPTED, NATIVE };
 71697:     State        state_;
 71697: 
 71697:     StackFrame   *fp_;
 71697:     CallArgsList *calls_;
 71697: 
 71697:     StackSegment *seg_;
 71697:     Value        *sp_;
 71697:     jsbytecode   *pc_;
 92133:     JSScript     *script_;
 71697:     CallArgs     args_;
 71697: 
 71697:     void poisonRegs();
 71697:     void popFrame();
 71697:     void popCall();
 71697:     void settleOnNewSegment();
 71697:     void settleOnNewState();
 71697:     void startOnSegment(StackSegment *seg);
 71697: 
 71697:   public:
 71697:     StackIter(JSContext *cx, SavedOption = STOP_AT_SAVED);
 98784:     StackIter(JSRuntime *rt, StackSegment &seg);
 71697: 
 71697:     bool done() const { return state_ == DONE; }
 71697:     StackIter &operator++();
 71697: 
 71697:     bool operator==(const StackIter &rhs) const;
 71697:     bool operator!=(const StackIter &rhs) const { return !(*this == rhs); }
 71697: 
 71697:     bool isScript() const { JS_ASSERT(!done()); return state_ == SCRIPTED; }
 95385:     bool isNativeCall() const {
 95385:         JS_ASSERT(!done());
103273:         return state_ == NATIVE;
 95385:     }
 71697: 
 95385:     bool isFunctionFrame() const;
 95385:     bool isEvalFrame() const;
 95385:     bool isNonEvalFunctionFrame() const;
 97160:     bool isConstructing() const;
 95385: 
 95385:     StackFrame *fp() const { JS_ASSERT(isScript()); return fp_; }
 95385:     jsbytecode *pc() const { JS_ASSERT(isScript()); return pc_; }
 95385:     JSScript   *script() const { JS_ASSERT(isScript()); return script_; }
 97160:     JSFunction *callee() const;
 95385:     Value       calleev() const;
 97160:     Value       thisv() const;
 95385: 
103273:     /*
103273:      * 'spFuzzy' is a best-effort approximiation of the frame's sp. It is only
103273:      * guaranteed to point to a safe range above fp's base and below fp's next.
103273:      * Ideally, we'd remove this altogether... wait, I'll do that in the next
103273:      * patch.
103273:      */
103273:     Value      *spFuzzy() const { JS_ASSERT(isScript()); return sp_; }
103273: 
 95385:     CallArgs nativeArgs() const { JS_ASSERT(isNativeCall()); return args_; }
 71697: };
 71697: 
 71697: /* A filtering of the StackIter to only stop at scripts. */
 97161: class ScriptFrameIter : public StackIter
 69223: {
 71697:     void settle() {
 97160:         while (!done() && !isScript())
 97160:             StackIter::operator++();
 71697:     }
 69223: 
 69223:   public:
 97161:     ScriptFrameIter(JSContext *cx, StackIter::SavedOption opt = StackIter::STOP_AT_SAVED)
 97160:         : StackIter(cx, opt) { settle(); }
 69223: 
 97161:     ScriptFrameIter &operator++() { StackIter::operator++(); settle(); return *this; }
 69223: };
 69223: 
 71697: /*****************************************************************************/
 71697: 
 69223: /*
 71697:  * Blindly iterate over all frames in the current thread's stack. These frames
 71697:  * can be from different contexts and compartments, so beware.
 69223:  */
 69223: class AllFramesIter
 69223: {
 69223:   public:
 71697:     AllFramesIter(StackSpace &space);
 69223: 
 69223:     bool done() const { return fp_ == NULL; }
 69223:     AllFramesIter& operator++();
 69223: 
 69223:     StackFrame *fp() const { return fp_; }
 69223: 
 69223:   private:
 87854:     void settle();
 69223:     StackSegment *seg_;
 69223:     StackFrame *fp_;
 69223: };
 69223: 
 69223: }  /* namespace js */
 69223: #endif /* Stack_h__ */
