111706: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
111706:  * vim: set ts=4 sw=4 et tw=79:
111706:  *
111706:  * ***** BEGIN LICENSE BLOCK *****
111706:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
111706:  *
111706:  * The contents of this file are subject to the Mozilla Public License Version
111706:  * 1.1 (the "License"); you may not use this file except in compliance with
111706:  * the License. You may obtain a copy of the License at
111706:  * http://www.mozilla.org/MPL/
111706:  *
111706:  * Software distributed under the License is distributed on an "AS IS" basis,
111706:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
111706:  * for the specific language governing rights and limitations under the
111706:  * License.
111706:  *
111706:  * The Original Code is Mozilla Communicator client code, released
111706:  * March 31, 1998.
111706:  *
111706:  * The Initial Developer of the Original Code is
111706:  * Netscape Communications Corporation.
111706:  * Portions created by the Initial Developer are Copyright (C) 1998
111706:  * the Initial Developer. All Rights Reserved.
111706:  *
111706:  * Contributor(s):
111706:  *   David Anderson <danderson@mozilla.com>
111706:  *
111706:  * Alternatively, the contents of this file may be used under the terms of
111706:  * either of the GNU General Public License Version 2 or later (the "GPL"),
111706:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
111706:  * in which case the provisions of the GPL or the LGPL are applicable instead
111706:  * of those above. If you wish to allow use of your version of this file only
111706:  * under the terms of either the GPL or the LGPL, and not to allow others to
111706:  * use your version of this file under the terms of the MPL, indicate your
111706:  * decision by deleting the provisions above and replace them with the notice
111706:  * and other provisions required by the GPL or the LGPL. If you do not delete
111706:  * the provisions above, a recipient may use your version of this file under
111706:  * the terms of any one of the MPL, the GPL or the LGPL.
111706:  *
111706:  * ***** END LICENSE BLOCK ***** */
111706: 
111706: #include "ion/MIR.h"
111961: #include "ion/Lowering.h"
111962: #include "Assembler-x86.h"
111962: #include "ion/shared/Lowering-shared-inl.h"
111707: #include "Lowering-x86-inl.h"
111706: 
111706: using namespace js;
111706: using namespace js::ion;
111706: 
111706: bool
111706: LIRGeneratorX86::visitConstant(MConstant *ins)
111706: {
111962:     if (!ins->isEmittedAtUses() && ins->type() != MIRType_Double)
111706:         return emitAtUses(ins);
111706: 
111962:     if (ins->type() == MIRType_Double)
111962:         return define(new LDouble(ins->value().toDouble()), ins);
111962: 
111962:     return LIRGeneratorShared::visitConstant(ins);
111706: }
111706: 
111706: bool
111706: LIRGeneratorX86::visitBox(MBox *box)
111706: {
111920:     MDefinition *inner = box->getOperand(0);
111920: 
111920:     // If the box wrapped a double, it needs a new register.
111920:     if (inner->type() == MIRType_Double)
111920:         return defineBox(new LBoxDouble(use(inner)), box);
111920: 
111838:     if (!box->isEmittedAtUses())
111707:         return emitAtUses(box);
111707: 
111753:     if (inner->isConstant())
111768:         return defineBox(new LValue(inner->toConstant()->value()), box);
111768: 
111768:     LBox *lir = new LBox(use(inner), inner->type());
111768: 
111753:     // Otherwise, we should not define a new register for the payload portion
111753:     // of the output, so bypass defineBox().
111753:     uint32 vreg = getVirtualRegister();
111753:     if (vreg >= MAX_VIRTUAL_REGISTERS)
111753:         return false;
111753: 
111753:     lir->setDef(0, LDefinition(vreg, LDefinition::TYPE));
111753:     lir->setDef(1, LDefinition(inner->id(), LDefinition::PAYLOAD, LDefinition::REDEFINED));
111753:     box->setId(vreg);
111753:     return add(lir);
111707: }
111707: 
111707: bool
111707: LIRGeneratorX86::visitUnbox(MUnbox *unbox)
111707: {
111707:     // An unbox on x86 reads in a type tag (either in memory or a register) and
111707:     // a payload. Unlike most instructions conusming a box, we ask for the type
111707:     // second, so that the result can re-use the first input.
111795:     MDefinition *inner = unbox->getOperand(0);
111707: 
111707:     if (unbox->type() == MIRType_Double) {
111720:         if (!ensureDefined(inner))
111720:             return false;
111920: 
111920:         if (Assembler::HasSSE41()) {
111920:             // With SSE4.1, we can emit a faster sequence of instructions that
111920:             // does not need a temporary register.
111920:             LUnboxDoubleSSE41 *lir = new LUnboxDoubleSSE41();
111758:             lir->setOperand(0, useType(inner, LUse::ANY));
111753:             lir->setOperand(1, usePayloadInRegister(inner));
111935:             if (!assignSnapshot(lir))
111935:                 return false;
111920:             return define(lir, unbox, LDefinition::DEFAULT);
111920:         }
111920: 
111920:         // With SSE < 4.1, use a slower (but still very efficient) sequence of
111920:         // instructions that needs a temporary register. Note that it also
111920:         // needs to read the type twice so we keep it in a register.
111920:         LUnboxDouble *lir = new LUnboxDouble();
111920:         lir->setOperand(0, useType(inner, LUse::REGISTER));
111920:         lir->setOperand(1, usePayloadInRegister(inner));
111935:         if (!assignSnapshot(lir))
111935:             return false;
111707:         return define(lir, unbox, LDefinition::DEFAULT);
111707:     }
111707: 
111707:     LUnbox *lir = new LUnbox(unbox->type());
111758:     lir->setOperand(0, useType(inner, LUse::ANY));
111753:     lir->setOperand(1, usePayloadInRegister(inner));
111753: 
111753:     // Re-use the inner payload's def, for better register allocation.
111753:     LDefinition::Type type = LDefinition::TypeFrom(unbox->type());
111753:     lir->setDef(0, LDefinition(VirtualRegisterOfPayload(inner), type, LDefinition::REDEFINED));
111753:     unbox->setId(VirtualRegisterOfPayload(inner));
111753: 
111753:     return assignSnapshot(lir) && add(lir);
111706: }
111706: 
111706: bool
111706: LIRGeneratorX86::visitReturn(MReturn *ret)
111706: {
111795:     MDefinition *opd = ret->getOperand(0);
111706:     JS_ASSERT(opd->type() == MIRType_Value);
111706: 
111706:     LReturn *ins = new LReturn;
111708:     ins->setOperand(0, LUse(JSReturnReg_Type));
111708:     ins->setOperand(1, LUse(JSReturnReg_Data));
111720:     return fillBoxUses(ins, 0, opd) && add(ins);
111720: }
111720: 
111720: bool
111720: LIRGeneratorX86::preparePhi(MPhi *phi)
111720: {
111732:     uint32 first_vreg = getVirtualRegister();
111720:     if (first_vreg >= MAX_VIRTUAL_REGISTERS)
111720:         return false;
111720: 
111720:     phi->setId(first_vreg);
111720: 
111720:     if (phi->type() == MIRType_Value) {
111732:         uint32 payload_vreg = getVirtualRegister();
111720:         if (payload_vreg >= MAX_VIRTUAL_REGISTERS)
111720:             return false;
111753:         JS_ASSERT(first_vreg + VREG_DATA_OFFSET == payload_vreg);
111720:     }
111720: 
111720:     return true;
111720: }
111720: 
111720: bool
111795: LIRGeneratorX86::lowerPhi(MPhi *ins)
111720: {
111838:     JS_ASSERT(ins->isInWorklist() && ins->id());
111720: 
111720:     // Typed phis can be handled much simpler.
111720:     if (ins->type() != MIRType_Value)
111962:         return LIRGeneratorShared::lowerPhi(ins);
111720: 
111720:     // Otherwise, we create two phis: one for the set of types and one for the
111720:     // set of payloads. They form two separate instructions but their
111720:     // definitions are paired such that they act as one. That is, the type phi
111720:     // has vreg V and the data phi has vreg V++.
111720:     LPhi *type = LPhi::New(gen, ins);
111720:     LPhi *payload = LPhi::New(gen, ins);
111720:     if (!type || !payload)
111720:         return false;
111720: 
111720:     for (size_t i = 0; i < ins->numOperands(); i++) {
111795:         MDefinition *opd = ins->getOperand(i);
111720:         JS_ASSERT(opd->type() == MIRType_Value);
111720:         JS_ASSERT(opd->id());
111838:         JS_ASSERT(opd->isInWorklist());
111720: 
111753:         type->setOperand(i, LUse(opd->id() + VREG_TYPE_OFFSET, LUse::ANY));
111753:         payload->setOperand(i, LUse(VirtualRegisterOfPayload(opd), LUse::ANY));
111720:     }
111720: 
111753:     type->setDef(0, LDefinition(ins->id() + VREG_TYPE_OFFSET, LDefinition::TYPE));
111753:     payload->setDef(0, LDefinition(ins->id() + VREG_DATA_OFFSET, LDefinition::PAYLOAD));
111720:     return addPhi(type) && addPhi(payload);
111706: }
111706: 
111962: bool
111962: LIRGeneratorX86::assignSnapshot(LInstruction *ins)
111711: {
111962:     LSnapshot *snapshot = LSnapshot::New(gen, last_snapshot_);
111962:     if (!snapshot)
111962:         return false;
111962: 
111711:     MSnapshot *mir = snapshot->mir();
111711:     for (size_t i = 0; i < mir->numOperands(); i++) {
111795:         MDefinition *ins = mir->getOperand(i);
111711:         LAllocation *type = snapshot->getEntry(i * 2);
111711:         LAllocation *payload = snapshot->getEntry(i * 2 + 1);
111711: 
111711:         // The register allocation will fill these fields in with actual
111711:         // register/stack assignments. During code generation, we can restore
111711:         // interpreter state with the given information. Note that for
111711:         // constants, including known types, we record a dummy placeholder,
111711:         // since we can recover the same information, much cleaner, from MIR.
111711:         if (ins->isConstant()) {
111711:             *type = LConstantIndex(0);
111711:             *payload = LConstantIndex(0);
111711:         } else if (ins->type() != MIRType_Value) {
111711:             *type = LConstantIndex(0);
111758:             *payload = use(ins, LUse::KEEPALIVE);
111711:         } else {
111758:             *type = useType(ins, LUse::KEEPALIVE);
111758:             *payload = usePayload(ins, LUse::KEEPALIVE);
111711:         }
111711:     }
111962: 
111962:     ins->assignSnapshot(snapshot);
111962:     return true;
111711: }
111711: 
111722: bool
111962: LIRGeneratorX86::lowerForALU(LInstructionHelper<1, 2, 0> *ins, MDefinition *mir, MDefinition *lhs, MDefinition *rhs)
111722: {
111722:     ins->setOperand(0, useRegister(lhs));
111722:     ins->setOperand(1, useOrConstant(rhs));
111722:     return defineReuseInput(ins, mir);
111722: }
111722: 
111920: bool
111962: LIRGeneratorX86::lowerForFPU(LInstructionHelper<1, 2, 0> *ins, MDefinition *mir, MDefinition *lhs, MDefinition *rhs)
111920: {
111920:     ins->setOperand(0, useRegister(lhs));
111920:     ins->setOperand(1, use(rhs));
111920:     return defineReuseInput(ins, mir);
111920: }
111920: 
