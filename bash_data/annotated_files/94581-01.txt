69270: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
69270:  * vim: sw=2 ts=8 et :
69270:  */
69270: /* ***** BEGIN LICENSE BLOCK *****
69270:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
69270:  *
69270:  * The contents of this file are subject to the Mozilla Public License Version
69270:  * 1.1 (the "License"); you may not use this file except in compliance with
69270:  * the License. You may obtain a copy of the License at:
69270:  * http://www.mozilla.org/MPL/
69270:  *
69270:  * Software distributed under the License is distributed on an "AS IS" basis,
69270:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
69270:  * for the specific language governing rights and limitations under the
69270:  * License.
69270:  *
69270:  * The Original Code is Mozilla Code.
69270:  *
69270:  * The Initial Developer of the Original Code is
69270:  *   The Mozilla Foundation
69270:  * Portions created by the Initial Developer are Copyright (C) 2011
69270:  * the Initial Developer. All Rights Reserved.
69270:  *
69270:  * Contributor(s):
69270:  *
69270:  * Alternatively, the contents of this file may be used under the terms of
69270:  * either the GNU General Public License Version 2 or later (the "GPL"), or
69270:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
69270:  * in which case the provisions of the GPL or the LGPL are applicable instead
69270:  * of those above. If you wish to allow use of your version of this file only
69270:  * under the terms of either the GPL or the LGPL, and not to allow others to
69270:  * use your version of this file under the terms of the MPL, indicate your
69270:  * decision by deleting the provisions above and replace them with the notice
69270:  * and other provisions required by the GPL or the LGPL. If you do not delete
69270:  * the provisions above, a recipient may use your version of this file under
69270:  * the terms of any one of the MPL, the GPL or the LGPL.
69270:  *
69270:  * ***** END LICENSE BLOCK ***** */
69270: 
69270: #include <unistd.h>
69270: #include <sys/types.h>
69270: #include <sys/wait.h>
69270: #include <errno.h>
94581: #include <sys/utsname.h>
69270: #include "nsCRTGlue.h"
69270: #include "prenv.h"
69270: 
69270: #include "GfxInfoX11.h"
69270: 
70448: #ifdef MOZ_CRASHREPORTER
69270: #include "nsExceptionHandler.h"
69270: #include "nsICrashReporter.h"
69270: #endif
69270: 
69270: namespace mozilla {
69270: namespace widget {
69270: 
84610: #ifdef DEBUG
84610: NS_IMPL_ISUPPORTS_INHERITED1(GfxInfo, GfxInfoBase, nsIGfxInfoDebug)
84610: #endif
84610: 
69270: // these global variables will be set when firing the glxtest process
69270: int glxtest_pipe = 0;
69270: pid_t glxtest_pid = 0;
69270: 
69270: nsresult
69270: GfxInfo::Init()
69270: {
90956:     mGLMajorVersion = 0;
69270:     mMajorVersion = 0;
69270:     mMinorVersion = 0;
74903:     mRevisionVersion = 0;
69270:     mIsMesa = false;
69270:     mIsNVIDIA = false;
69270:     mIsFGLRX = false;
90957:     mIsNouveau = false;
74904:     mHasTextureFromPixmap = false;
69270:     return GfxInfoBase::Init();
69270: }
69270: 
69270: void
69270: GfxInfo::GetData()
69270: {
69270:     // to understand this function, see bug 639842. We retrieve the OpenGL driver information in a
69270:     // separate process to protect against bad drivers.
69270: 
69270:     // if glxtest_pipe == 0, that means that we already read the information
69270:     if (!glxtest_pipe)
69270:         return;
69270: 
69270:     enum { buf_size = 1024 };
69270:     char buf[buf_size];
69270:     ssize_t bytesread = read(glxtest_pipe,
69270:                              &buf,
69270:                              buf_size-1); // -1 because we'll append a zero
69270:     close(glxtest_pipe);
69270:     glxtest_pipe = 0;
69270: 
89142:     // bytesread < 0 would mean that the above read() call failed.
89142:     // This should never happen. If it did, the outcome would be to blacklist anyway.
69270:     if (bytesread < 0)
69270:         bytesread = 0;
69270: 
69270:     // let buf be a zero-terminated string
69270:     buf[bytesread] = 0;
69270: 
69270:     // Wait for the glxtest process to finish. This serves 2 purposes:
69270:     // * avoid having a zombie glxtest process laying around
69270:     // * get the glxtest process status info.
69270:     int glxtest_status = 0;
69270:     bool wait_for_glxtest_process = true;
69270:     bool waiting_for_glxtest_process_failed = false;
87586:     int waitpid_errno = 0;
69270:     while(wait_for_glxtest_process) {
69270:         wait_for_glxtest_process = false;
69270:         if (waitpid(glxtest_pid, &glxtest_status, 0) == -1) {
87586:             waitpid_errno = errno;
89142:             if (waitpid_errno == EINTR) {
69270:                 wait_for_glxtest_process = true;
89142:             } else {
89142:                 // Bug 718629
89142:                 // ECHILD happens when the glxtest process got reaped got reaped after a PR_CreateProcess
89142:                 // as per bug 227246. This shouldn't matter, as we still seem to get the data
89142:                 // from the pipe, and if we didn't, the outcome would be to blacklist anyway.
89142:                 waiting_for_glxtest_process_failed = (waitpid_errno != ECHILD);
89142:             }
69270:         }
69270:     }
69270: 
69270:     bool exited_with_error_code = !waiting_for_glxtest_process_failed &&
69270:                                   WIFEXITED(glxtest_status) && 
69270:                                   WEXITSTATUS(glxtest_status) != EXIT_SUCCESS;
69270:     bool received_signal = !waiting_for_glxtest_process_failed &&
69270:                            WIFSIGNALED(glxtest_status);
69270: 
69270:     bool error = waiting_for_glxtest_process_failed || exited_with_error_code || received_signal;
69270: 
74904:     nsCString textureFromPixmap; 
69270:     nsCString *stringToFill = nsnull;
69270:     char *bufptr = buf;
69270:     if (!error) {
69270:         while(true) {
69270:             char *line = NS_strtok("\n", &bufptr);
69270:             if (!line)
69270:                 break;
69270:             if (stringToFill) {
69270:                 stringToFill->Assign(line);
69270:                 stringToFill = nsnull;
69270:             }
69270:             else if(!strcmp(line, "VENDOR"))
69270:                 stringToFill = &mVendor;
69270:             else if(!strcmp(line, "RENDERER"))
69270:                 stringToFill = &mRenderer;
69270:             else if(!strcmp(line, "VERSION"))
69270:                 stringToFill = &mVersion;
74904:             else if(!strcmp(line, "TFP"))
74904:                 stringToFill = &textureFromPixmap;
69270:         }
69270:     }
69270: 
74904:     if (!strcmp(textureFromPixmap.get(), "TRUE"))
74904:         mHasTextureFromPixmap = true;
74904: 
94581:     // only useful for Linux kernel version check for FGLRX driver.
94581:     // assumes X client == X server, which is sad.
94581:     utsname unameobj;
94581:     if (!uname(&unameobj))
94581:     {
94581:       mOS.Assign(unameobj.sysname);
94581:       mOSRelease.Assign(unameobj.release);
94581:     }
94581: 
69270:     const char *spoofedVendor = PR_GetEnv("MOZ_GFX_SPOOF_GL_VENDOR");
69270:     if (spoofedVendor)
69270:         mVendor.Assign(spoofedVendor);
69270:     const char *spoofedRenderer = PR_GetEnv("MOZ_GFX_SPOOF_GL_RENDERER");
69270:     if (spoofedRenderer)
69270:         mRenderer.Assign(spoofedRenderer);
69270:     const char *spoofedVersion = PR_GetEnv("MOZ_GFX_SPOOF_GL_VERSION");
69270:     if (spoofedVersion)
69270:         mVersion.Assign(spoofedVersion);
94581:     const char *spoofedOS = PR_GetEnv("MOZ_GFX_SPOOF_OS");
94581:     if (spoofedOS)
94581:         mOS.Assign(spoofedOS);
94581:     const char *spoofedOSRelease = PR_GetEnv("MOZ_GFX_SPOOF_OS_RELEASE");
94581:     if (spoofedOSRelease)
94581:         mOSRelease.Assign(spoofedOSRelease);
69270: 
69270:     if (error ||
69270:         mVendor.IsEmpty() ||
69270:         mRenderer.IsEmpty() ||
94581:         mVersion.IsEmpty() ||
94581:         mOS.IsEmpty() ||
94581:         mOSRelease.IsEmpty())
69270:     {
69270:         mAdapterDescription.AppendLiteral("GLXtest process failed");
69270:         if (waiting_for_glxtest_process_failed)
87586:             mAdapterDescription.AppendPrintf(" (waitpid failed with errno=%d for pid %d)", waitpid_errno, glxtest_pid);
69270:         if (exited_with_error_code)
69270:             mAdapterDescription.AppendPrintf(" (exited with status %d)", WEXITSTATUS(glxtest_status));
69270:         if (received_signal)
69270:             mAdapterDescription.AppendPrintf(" (received signal %d)", WTERMSIG(glxtest_status));
69270:         if (bytesread) {
69270:             mAdapterDescription.AppendLiteral(": ");
69270:             mAdapterDescription.Append(nsDependentCString(buf));
69270:             mAdapterDescription.AppendLiteral("\n");
69270:         }
70448: #ifdef MOZ_CRASHREPORTER
69270:         CrashReporter::AppendAppNotesToCrashReport(mAdapterDescription);
69270: #endif
69270:         return;
69270:     }
69270: 
69270:     mAdapterDescription.Append(mVendor);
69270:     mAdapterDescription.AppendLiteral(" -- ");
69270:     mAdapterDescription.Append(mRenderer);
69270: 
69270:     nsCAutoString note;
69270:     note.Append("OpenGL: ");
69270:     note.Append(mAdapterDescription);
69270:     note.Append(" -- ");
69270:     note.Append(mVersion);
74904:     if (mHasTextureFromPixmap)
74904:         note.Append(" -- texture_from_pixmap");
69270:     note.Append("\n");
70448: #ifdef MOZ_CRASHREPORTER
69270:     CrashReporter::AppendAppNotesToCrashReport(note);
69270: #endif
69270: 
90956:     // determine the major OpenGL version. That's the first integer in the version string.
90956:     mGLMajorVersion = strtol(mVersion.get(), 0, 10);
90956: 
69270:     // determine driver type (vendor) and where in the version string
69270:     // the actual driver version numbers should be expected to be found (whereToReadVersionNumbers)
69270:     const char *whereToReadVersionNumbers = nsnull;
69270:     const char *Mesa_in_version_string = strstr(mVersion.get(), "Mesa");
69270:     if (Mesa_in_version_string) {
69270:         mIsMesa = true;
69270:         // with Mesa, the version string contains "Mesa major.minor" and that's all the version information we get:
69270:         // there is no actual driver version info.
69270:         whereToReadVersionNumbers = Mesa_in_version_string + strlen("Mesa");
90957:         if (strcasestr(mVendor.get(), "nouveau"))
90957:             mIsNouveau = true;
69270:     } else if (strstr(mVendor.get(), "NVIDIA Corporation")) {
69270:         mIsNVIDIA = true;
69270:         // with the NVIDIA driver, the version string contains "NVIDIA major.minor"
69270:         // note that here the vendor and version strings behave differently, that's why we don't put this above
69270:         // alongside Mesa_in_version_string.
69270:         const char *NVIDIA_in_version_string = strstr(mVersion.get(), "NVIDIA");
69270:         if (NVIDIA_in_version_string)
69270:             whereToReadVersionNumbers = NVIDIA_in_version_string + strlen("NVIDIA");
69270:     } else if (strstr(mVendor.get(), "ATI Technologies Inc")) {
69270:         mIsFGLRX = true;
69270:         // with the FGLRX driver, the version string only gives a OpenGL version :/ so let's return that.
69270:         // that can at least give a rough idea of how old the driver is.
69270:         whereToReadVersionNumbers = mVersion.get();
69270:     }
69270: 
90956:     // read major.minor version numbers of the driver (not to be confused with the OpenGL version)
69270:     if (whereToReadVersionNumbers) {
69270:         // copy into writable buffer, for tokenization
69270:         strncpy(buf, whereToReadVersionNumbers, buf_size);
69270:         bufptr = buf;
69270: 
69270:         // now try to read major.minor version numbers. In case of failure, gracefully exit: these numbers have
69270:         // been initialized as 0 anyways
69270:         char *token = NS_strtok(".", &bufptr);
69270:         if (token) {
69270:             mMajorVersion = strtol(token, 0, 10);
69270:             token = NS_strtok(".", &bufptr);
74903:             if (token) {
74903:                 mMinorVersion = strtol(token, 0, 10);
74903:                 token = NS_strtok(".", &bufptr);
69270:                 if (token)
74903:                     mRevisionVersion = strtol(token, 0, 10);
74903:             }
69270:         }
69270:     }
69270: }
69270: 
74903: static inline PRUint64 version(PRUint32 major, PRUint32 minor, PRUint32 revision = 0)
69270: {
74903:     return (PRUint64(major) << 32) + (PRUint64(minor) << 16) + PRUint64(revision);
69270: }
69270: 
84603: const nsTArray<GfxDriverInfo>&
81328: GfxInfo::GetGfxDriverInfo()
81328: {
84603:   // Nothing here yet.
84603:   //if (!mDriverInfo->Length()) {
84603:   //
84603:   //}
84603:   return *mDriverInfo;
81328: }
81328: 
69270: nsresult
81328: GfxInfo::GetFeatureStatusImpl(PRInt32 aFeature, 
81328:                               PRInt32 *aStatus, 
81328:                               nsAString & aSuggestedDriverVersion, 
84603:                               const nsTArray<GfxDriverInfo>& aDriverInfo, 
81328:                               OperatingSystem* aOS /* = nsnull */)
81328: 
69270: {
91733:   GetData();
91733: 
84607:   NS_ENSURE_ARG_POINTER(aStatus);
84603:   *aStatus = nsIGfxInfo::FEATURE_STATUS_UNKNOWN;
80486:   aSuggestedDriverVersion.SetIsVoid(true);
84607:   OperatingSystem os = DRIVER_OS_LINUX;
84607:   if (aOS)
84607:     *aOS = os;
69270: 
90956:   if (mGLMajorVersion == 1) {
90956:     // We're on OpenGL 1. In most cases that indicates really old hardware.
90956:     // We better block them, rather than rely on them to fail gracefully, because they don't!
90956:     // see bug 696636
90956:     *aStatus = nsIGfxInfo::FEATURE_BLOCKED_DEVICE;
90956:     return NS_OK;
90956:   }
90956: 
69270: #ifdef MOZ_PLATFORM_MAEMO
84603:   *aStatus = nsIGfxInfo::FEATURE_NO_INFO;
69270:   // on Maemo, the glxtest probe doesn't build, and we don't really need GfxInfo anyway
69270:   return NS_OK;
69270: #endif
69270: 
84607:   // Don't evaluate any special cases if we're checking the downloaded blocklist.
84607:   if (!aDriverInfo.Length()) {
84609:     // Only check features relevant to Linux.
84609:     if (aFeature == nsIGfxInfo::FEATURE_OPENGL_LAYERS ||
84609:         aFeature == nsIGfxInfo::FEATURE_WEBGL_OPENGL ||
84609:         aFeature == nsIGfxInfo::FEATURE_WEBGL_MSAA) {
81328: 
74904:       // Disable OpenGL layers when we don't have texture_from_pixmap because it regresses performance. 
74904:       if (aFeature == nsIGfxInfo::FEATURE_OPENGL_LAYERS && !mHasTextureFromPixmap) {
74904:         *aStatus = nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION;
74904:         aSuggestedDriverVersion.AssignLiteral("<Anything with EXT_texture_from_pixmap support>");
74904:         return NS_OK;
74904:       }
74904: 
69270:       // whitelist the linux test slaves' current configuration.
69270:       // this is necessary as they're still using the slightly outdated 190.42 driver.
69270:       // this isn't a huge risk, as at least this is the exact setting in which we do continuous testing,
69270:       // and this only affects GeForce 9400 cards on linux on this precise driver version, which is very few users.
86545:       // We do the same thing on Windows XP, see in widget/windows/GfxInfo.cpp
69270:       if (mIsNVIDIA &&
69270:           !strcmp(mRenderer.get(), "GeForce 9400/PCI/SSE2") &&
69270:           !strcmp(mVersion.get(), "3.2.0 NVIDIA 190.42"))
69270:       {
84603:         *aStatus = nsIGfxInfo::FEATURE_NO_INFO;
69270:         return NS_OK;
69270:       }
69270: 
69270:       if (mIsMesa) {
91881:         if (mIsNouveau && version(mMajorVersion, mMinorVersion) < version(8,0)) {
90957:           *aStatus = nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION;
91881:           aSuggestedDriverVersion.AssignLiteral("Mesa 8.0");
90957:         } else if (version(mMajorVersion, mMinorVersion, mRevisionVersion) < version(7,10,3)) {
69270:           *aStatus = nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION;
74903:           aSuggestedDriverVersion.AssignLiteral("Mesa 7.10.3");
69270:         }
69270:       } else if (mIsNVIDIA) {
74903:         if (version(mMajorVersion, mMinorVersion, mRevisionVersion) < version(257,21)) {
69270:           *aStatus = nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION;
69270:           aSuggestedDriverVersion.AssignLiteral("NVIDIA 257.21");
69270:         }
69270:       } else if (mIsFGLRX) {
69270:         // FGLRX does not report a driver version number, so we have the OpenGL version instead.
69270:         // by requiring OpenGL 3, we effectively require recent drivers.
74903:         if (version(mMajorVersion, mMinorVersion, mRevisionVersion) < version(3, 0)) {
69270:           *aStatus = nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION;
94581:           aSuggestedDriverVersion.AssignLiteral("<Something recent>");
94581:         }
94581:         // Bug 724640: FGLRX + Linux 2.6.32 is a crashy combo
94581:         bool unknownOS = mOS.IsEmpty() || mOSRelease.IsEmpty();
94581:         bool badOS = mOS.Find("Linux", true) != -1 &&
94581:                      mOSRelease.Find("2.6.32") != -1;
94581:         if (unknownOS || badOS) {
94581:           *aStatus = nsIGfxInfo::FEATURE_BLOCKED_OS_VERSION;
69270:         }
69270:       } else {
69270:         // like on windows, let's block unknown vendors. Think of virtual machines.
69270:         // Also, this case is hit whenever the GLXtest probe failed to get driver info or crashed.
69270:         *aStatus = nsIGfxInfo::FEATURE_BLOCKED_DEVICE;
69270:       }
84607:     }
84609:   }
81328: 
81328:   return GfxInfoBase::GetFeatureStatusImpl(aFeature, aStatus, aSuggestedDriverVersion, aDriverInfo, &os);
69270: }
69270: 
69270: 
69270: NS_IMETHODIMP
79445: GfxInfo::GetD2DEnabled(bool *aEnabled)
69270: {
69270:   return NS_ERROR_FAILURE;
69270: }
69270: 
69270: NS_IMETHODIMP
79445: GfxInfo::GetDWriteEnabled(bool *aEnabled)
69270: {
69270:   return NS_ERROR_FAILURE;
69270: }
69270: 
72430: NS_IMETHODIMP
79445: GfxInfo::GetAzureEnabled(bool *aEnabled)
72430: {
72430:   return NS_ERROR_FAILURE;
72430: }
72430: 
69270: /* readonly attribute DOMString DWriteVersion; */
69270: NS_IMETHODIMP
69270: GfxInfo::GetDWriteVersion(nsAString & aDwriteVersion)
69270: {
69270:   return NS_ERROR_FAILURE;
69270: }
69270: 
69664: /* readonly attribute DOMString cleartypeParameters; */
69664: NS_IMETHODIMP
69664: GfxInfo::GetCleartypeParameters(nsAString & aCleartypeParams)
69664: {
69664:   return NS_ERROR_FAILURE;
69664: }
69664: 
69270: /* readonly attribute DOMString adapterDescription; */
69270: NS_IMETHODIMP
69270: GfxInfo::GetAdapterDescription(nsAString & aAdapterDescription)
69270: {
69270:   GetData();
69270:   AppendASCIItoUTF16(mAdapterDescription, aAdapterDescription);
69270:   return NS_OK;
69270: }
69270: 
76321: /* readonly attribute DOMString adapterDescription2; */
76321: NS_IMETHODIMP
76321: GfxInfo::GetAdapterDescription2(nsAString & aAdapterDescription)
76321: {
76321:   return NS_ERROR_FAILURE;
76321: }
76321: 
69270: /* readonly attribute DOMString adapterRAM; */
69270: NS_IMETHODIMP
69270: GfxInfo::GetAdapterRAM(nsAString & aAdapterRAM)
69270: {
69270:   aAdapterRAM.AssignLiteral("");
69270:   return NS_OK;
69270: }
69270: 
76321: /* readonly attribute DOMString adapterRAM2; */
76321: NS_IMETHODIMP
76321: GfxInfo::GetAdapterRAM2(nsAString & aAdapterRAM)
76321: {
76321:   return NS_ERROR_FAILURE;
76321: }
76321: 
69270: /* readonly attribute DOMString adapterDriver; */
69270: NS_IMETHODIMP
69270: GfxInfo::GetAdapterDriver(nsAString & aAdapterDriver)
69270: {
69270:   aAdapterDriver.AssignLiteral("");
69270:   return NS_OK;
69270: }
69270: 
76321: /* readonly attribute DOMString adapterDriver2; */
76321: NS_IMETHODIMP
76321: GfxInfo::GetAdapterDriver2(nsAString & aAdapterDriver)
76321: {
76321:   return NS_ERROR_FAILURE;
76321: }
76321: 
69270: /* readonly attribute DOMString adapterDriverVersion; */
69270: NS_IMETHODIMP
69270: GfxInfo::GetAdapterDriverVersion(nsAString & aAdapterDriverVersion)
69270: {
69270:   GetData();
69270:   CopyASCIItoUTF16(mVersion, aAdapterDriverVersion);
69270:   return NS_OK;
69270: }
69270: 
76321: /* readonly attribute DOMString adapterDriverVersion2; */
76321: NS_IMETHODIMP
76321: GfxInfo::GetAdapterDriverVersion2(nsAString & aAdapterDriverVersion)
76321: {
76321:   return NS_ERROR_FAILURE;
76321: }
76321: 
69270: /* readonly attribute DOMString adapterDriverDate; */
69270: NS_IMETHODIMP
69270: GfxInfo::GetAdapterDriverDate(nsAString & aAdapterDriverDate)
69270: {
69270:   aAdapterDriverDate.AssignLiteral("");
69270:   return NS_OK;
69270: }
69270: 
76321: /* readonly attribute DOMString adapterDriverDate2; */
76321: NS_IMETHODIMP
76321: GfxInfo::GetAdapterDriverDate2(nsAString & aAdapterDriverDate)
76321: {
76321:   return NS_ERROR_FAILURE;
76321: }
76321: 
84604: /* readonly attribute DOMString adapterVendorID; */
69270: NS_IMETHODIMP
84604: GfxInfo::GetAdapterVendorID(nsAString & aAdapterVendorID)
69270: {
84609:   GetData();
84609:   CopyUTF8toUTF16(mVendor, aAdapterVendorID);
69270:   return NS_OK;
69270: }
69270: 
84604: /* readonly attribute DOMString adapterVendorID2; */
76321: NS_IMETHODIMP
84604: GfxInfo::GetAdapterVendorID2(nsAString & aAdapterVendorID)
76321: {
76321:   return NS_ERROR_FAILURE;
76321: }
76321: 
84604: /* readonly attribute DOMString adapterDeviceID; */
69270: NS_IMETHODIMP
84604: GfxInfo::GetAdapterDeviceID(nsAString & aAdapterDeviceID)
69270: {
84609:   GetData();
84609:   CopyUTF8toUTF16(mRenderer, aAdapterDeviceID);
69270:   return NS_OK;
69270: }
69270: 
84604: /* readonly attribute DOMString adapterDeviceID2; */
76321: NS_IMETHODIMP
84604: GfxInfo::GetAdapterDeviceID2(nsAString & aAdapterDeviceID)
76321: {
76321:   return NS_ERROR_FAILURE;
76321: }
76321: 
76321: /* readonly attribute boolean isGPU2Active; */
76321: NS_IMETHODIMP
79445: GfxInfo::GetIsGPU2Active(bool* aIsGPU2Active)
76321: {
76321:   return NS_ERROR_FAILURE;
76321: }
76321: 
84610: #ifdef DEBUG
84610: 
84610: // Implement nsIGfxInfoDebug
84610: // We don't support spoofing anything on Linux
84610: 
84610: /* void spoofVendorID (in DOMString aVendorID); */
84610: NS_IMETHODIMP GfxInfo::SpoofVendorID(const nsAString & aVendorID)
84610: {
84610:   CopyUTF16toUTF8(aVendorID, mVendor);
84610:   return NS_OK;
84610: }
84610: 
84610: /* void spoofDeviceID (in unsigned long aDeviceID); */
84610: NS_IMETHODIMP GfxInfo::SpoofDeviceID(const nsAString & aDeviceID)
84610: {
84610:   CopyUTF16toUTF8(aDeviceID, mRenderer);
84610:   return NS_OK;
84610: }
84610: 
84610: /* void spoofDriverVersion (in DOMString aDriverVersion); */
84610: NS_IMETHODIMP GfxInfo::SpoofDriverVersion(const nsAString & aDriverVersion)
84610: {
84610:   CopyUTF16toUTF8(aDriverVersion, mVersion);
84610:   return NS_OK;
84610: }
84610: 
84610: /* void spoofOSVersion (in unsigned long aVersion); */
84610: NS_IMETHODIMP GfxInfo::SpoofOSVersion(PRUint32 aVersion)
84610: {
84610:   // We don't support OS versioning on Linux. There's just "Linux".
84610:   return NS_OK;
84610: }
84610: 
84610: #endif
69270: 
69270: } // end namespace widget
69270: } // end namespace mozilla
