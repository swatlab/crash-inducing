    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set ts=2 sw=2 et tw=78: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Simon Fraser   <sfraser@netscape.com>
    1:  *   Michael Judge  <mjudge@netscape.com>
    1:  *   Charles Manske <cmanske@netscape.com>
    1:  *   Kathleen Brade <brade@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIDOMWindowUtils.h"
    1: #include "nsIDOMWindowInternal.h"
    1: #include "nsIDOMNSHTMLDocument.h"
    1: #include "nsIDocument.h"
    1: #include "nsIHTMLDocument.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIURI.h"
    1: #include "nsISelectionPrivate.h"
    1: #include "nsITransactionManager.h"
    1: 
    1: #include "nsIEditorDocShell.h"
    1: #include "nsIDocShell.h"
    1: 
    1: #include "nsIChannel.h"
    1: #include "nsIWebProgress.h"
    1: #include "nsIWebNavigation.h"
    1: #include "nsIRefreshURI.h"
    1: 
    1: #include "nsIControllers.h"
    1: #include "nsIController.h"
    1: #include "nsIControllerContext.h"
    1: #include "nsICommandManager.h"
    1: #include "nsPICommandUpdater.h"
    1: 
    1: #include "nsIPresShell.h"
    1: 
    1: #include "nsComposerCommandsUpdater.h"
    1: #include "nsEditingSession.h"
    1: 
    1: #include "nsComponentManagerUtils.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: 
    1: #include "nsIContentViewer.h"
    1: #include "nsISelectionController.h"
    1: #include "nsIPlaintextEditor.h"
    1: #include "nsIEditor.h"
    1: 
    1: #include "nsIDOMNSDocument.h"
    1: #include "nsIScriptContext.h"
    1: #include "imgIContainer.h"
    1: 
    1: #if DEBUG
    1: //#define NOISY_DOC_LOADING  1
    1: #endif
    1: 
    1: /*---------------------------------------------------------------------------
    1: 
    1:   nsEditingSession
    1: 
    1: ----------------------------------------------------------------------------*/
    1: nsEditingSession::nsEditingSession()
    1: : mDoneSetup(PR_FALSE)
    1: , mCanCreateEditor(PR_FALSE)
 2896: , mInteractive(PR_FALSE)
 3199: , mMakeWholeDocumentEditable(PR_TRUE)
 7856: , mDisabledJSAndPlugins(PR_FALSE)
    1: , mScriptsEnabled(PR_TRUE)
    1: , mPluginsEnabled(PR_TRUE)
    1: , mProgressListenerRegistered(PR_FALSE)
    1: , mImageAnimationMode(0)
    1: , mEditorFlags(0)
    1: , mEditorStatus(eEditorOK)
    1: , mBaseCommandControllerId(0)
    1: , mDocStateControllerId(0)
    1: , mHTMLCommandControllerId(0)
    1: {
    1: }
    1: 
    1: /*---------------------------------------------------------------------------
    1: 
    1:   ~nsEditingSession
    1: 
    1: ----------------------------------------------------------------------------*/
    1: nsEditingSession::~nsEditingSession()
    1: {
    1:   // Must cancel previous timer?
    1:   if (mLoadBlankDocTimer)
    1:     mLoadBlankDocTimer->Cancel();
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS3(nsEditingSession, nsIEditingSession, nsIWebProgressListener, 
    1:                    nsISupportsWeakReference)
    1: 
    1: /*---------------------------------------------------------------------------
    1: 
    1:   MakeWindowEditable
    1: 
    1:   aEditorType string, "html" "htmlsimple" "text" "textsimple"
    1:   void makeWindowEditable(in nsIDOMWindow aWindow, in string aEditorType, 
 2896:                           in boolean aDoAfterUriLoad,
 2896:                           in boolean aMakeWholeDocumentEditable,
 2896:                           in boolean aInteractive);
    1: ----------------------------------------------------------------------------*/
    1: #define DEFAULT_EDITOR_TYPE "html"
    1: 
    1: NS_IMETHODIMP
    1: nsEditingSession::MakeWindowEditable(nsIDOMWindow *aWindow,
    1:                                      const char *aEditorType, 
 2896:                                      PRBool aDoAfterUriLoad,
 2896:                                      PRBool aMakeWholeDocumentEditable,
 2896:                                      PRBool aInteractive)
    1: {
    1:   mEditorType.Truncate();
    1:   mEditorFlags = 0;
    1: 
    1:   // disable plugins
    1:   nsIDocShell *docShell = GetDocShellFromWindow(aWindow);
43806:   NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
    1: 
56162:   mDocShell = do_GetWeakReference(docShell);
 3199:   mInteractive = aInteractive;
 3199:   mMakeWholeDocumentEditable = aMakeWholeDocumentEditable;
 3199: 
    1:   nsresult rv;
 2896:   if (!mInteractive) {
 7856:     rv = DisableJSAndPlugins(aWindow);
    1:     NS_ENSURE_SUCCESS(rv, rv);
 2896:   }
    1: 
    1:   // Always remove existing editor
 7856:   TearDownEditorOnWindow(aWindow);
    1:   
    1:   // Tells embedder that startup is in progress
    1:   mEditorStatus = eEditorCreationInProgress;
    1: 
    1:   //temporary to set editor type here. we will need different classes soon.
    1:   if (!aEditorType)
    1:     aEditorType = DEFAULT_EDITOR_TYPE;
    1:   mEditorType = aEditorType;
    1: 
    1:   // if all this does is setup listeners and I don't need listeners, 
    1:   // can't this step be ignored?? (based on aDoAfterURILoad)
    1:   rv = PrepareForEditing(aWindow);
43805:   NS_ENSURE_SUCCESS(rv, rv);  
    1:   
    1:   nsCOMPtr<nsIEditorDocShell> editorDocShell;
    1:   rv = GetEditorDocShellFromWindow(aWindow, getter_AddRefs(editorDocShell));
43805:   NS_ENSURE_SUCCESS(rv, rv);  
    1:   
    1:   // set the flag on the docShell to say that it's editable
    1:   rv = editorDocShell->MakeEditable(aDoAfterUriLoad);
43805:   NS_ENSURE_SUCCESS(rv, rv);  
    1: 
    1:   // Setup commands common to plaintext and html editors,
    1:   //  including the document creation observers
    1:   // the first is an editor controller
    1:   rv = SetupEditorCommandController("@mozilla.org/editor/editorcontroller;1",
    1:                                     aWindow,
 3233:                                     static_cast<nsIEditingSession*>(this),
    1:                                     &mBaseCommandControllerId);
43805:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // The second is a controller to monitor doc state,
    1:   // such as creation and "dirty flag"
    1:   rv = SetupEditorCommandController("@mozilla.org/editor/editordocstatecontroller;1",
    1:                                     aWindow,
 3233:                                     static_cast<nsIEditingSession*>(this),
    1:                                     &mDocStateControllerId);
43805:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // aDoAfterUriLoad can be false only when making an existing window editable
    1:   if (!aDoAfterUriLoad)
    1:   {
    1:     rv = SetupEditorOnWindow(aWindow);
    1: 
    1:     // mEditorStatus is set to the error reason
    1:     // Since this is used only when editing an existing page,
    1:     //  it IS ok to destroy current editor
    1:     if (NS_FAILED(rv))
 7856:       TearDownEditorOnWindow(aWindow);
    1:   }
    1:   return rv;
    1: }
    1: 
 7856: NS_IMETHODIMP
 7856: nsEditingSession::DisableJSAndPlugins(nsIDOMWindow *aWindow)
 7856: {
 7856:   nsIDocShell *docShell = GetDocShellFromWindow(aWindow);
43806:   NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
 7856: 
 7856:   PRBool tmp;
 7856:   nsresult rv = docShell->GetAllowJavascript(&tmp);
 7856:   NS_ENSURE_SUCCESS(rv, rv);
 7856: 
 7856:   mScriptsEnabled = tmp;
 7856: 
 7856:   rv = docShell->SetAllowJavascript(PR_FALSE);
 7856:   NS_ENSURE_SUCCESS(rv, rv);
 7856: 
 7856:   // Disable plugins in this document:
 7856:   rv = docShell->GetAllowPlugins(&tmp);
 7856:   NS_ENSURE_SUCCESS(rv, rv);
 7856: 
 7856:   mPluginsEnabled = tmp;
 7856: 
 7856:   rv = docShell->SetAllowPlugins(PR_FALSE);
 7856:   NS_ENSURE_SUCCESS(rv, rv);
 7856: 
 7856:   mDisabledJSAndPlugins = PR_TRUE;
 7856: 
 7856:   return NS_OK;
 7856: }
 7856: 
 7856: NS_IMETHODIMP
 7856: nsEditingSession::RestoreJSAndPlugins(nsIDOMWindow *aWindow)
 7856: {
43807:   NS_ENSURE_TRUE(mDisabledJSAndPlugins, NS_OK);
14631: 
 7856:   mDisabledJSAndPlugins = PR_FALSE;
 7856: 
 7856:   nsIDocShell *docShell = GetDocShellFromWindow(aWindow);
43806:   NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
 7856: 
 7856:   nsresult rv = docShell->SetAllowJavascript(mScriptsEnabled);
 7856:   NS_ENSURE_SUCCESS(rv, rv);
 7856: 
 7856:   // Disable plugins in this document:
 7856:   return docShell->SetAllowPlugins(mPluginsEnabled);
 7856: }
 7856: 
46407: NS_IMETHODIMP
46407: nsEditingSession::GetJsAndPluginsDisabled(PRBool *aResult)
46407: {
46407:   NS_ENSURE_ARG_POINTER(aResult);
46407:   *aResult = mDisabledJSAndPlugins;
46407:   return NS_OK;
46407: }
46407: 
    1: /*---------------------------------------------------------------------------
    1: 
    1:   WindowIsEditable
    1: 
    1:   boolean windowIsEditable (in nsIDOMWindow aWindow);
    1: ----------------------------------------------------------------------------*/
    1: NS_IMETHODIMP
    1: nsEditingSession::WindowIsEditable(nsIDOMWindow *aWindow, PRBool *outIsEditable)
    1: {
    1:   nsCOMPtr<nsIEditorDocShell> editorDocShell;
    1:   nsresult rv = GetEditorDocShellFromWindow(aWindow,
    1:                                             getter_AddRefs(editorDocShell));
43805:   NS_ENSURE_SUCCESS(rv, rv);  
    1: 
    1:   return editorDocShell->GetEditable(outIsEditable);
    1: }
    1: 
    1: 
    1: // These are MIME types that are automatically parsed as "text/plain"
    1: //   and thus we can edit them as plaintext
    1: // Note: in older versions, we attempted to convert the mimetype of
    1: //   the network channel for these and "text/xml" to "text/plain", 
    1: //   but further investigation reveals that strategy doesn't work
    1: const char* const gSupportedTextTypes[] = {
    1:   "text/plain",
    1:   "text/css",
    1:   "text/rdf",
    1:   "text/xsl",
    1:   "text/javascript",           // obsolete type
    1:   "text/ecmascript",           // obsolete type
    1:   "application/javascript",
    1:   "application/ecmascript",
    1:   "application/x-javascript",  // obsolete type
    1:   "text/xul",                  // obsolete type
    1:   "application/vnd.mozilla.xul+xml",
    1:   NULL      // IMPORTANT! Null must be at end
    1: };
    1: 
    1: PRBool
    1: IsSupportedTextType(const char* aMIMEType)
    1: {
43807:   NS_ENSURE_TRUE(aMIMEType, PR_FALSE);
    1: 
    1:   PRInt32 i = 0;
    1:   while (gSupportedTextTypes[i])
    1:   {
    1:     if (strcmp(gSupportedTextTypes[i], aMIMEType) == 0)
    1:     {
    1:       return PR_TRUE;
    1:     }
    1: 
    1:     i ++;
    1:   }
    1:   
    1:   return PR_FALSE;
    1: }
    1: 
    1: /*---------------------------------------------------------------------------
    1: 
    1:   SetupEditorOnWindow
    1: 
    1:   nsIEditor setupEditorOnWindow (in nsIDOMWindow aWindow);
    1: ----------------------------------------------------------------------------*/
    1: NS_IMETHODIMP
    1: nsEditingSession::SetupEditorOnWindow(nsIDOMWindow *aWindow)
    1: {
    1:   mDoneSetup = PR_TRUE;
    1: 
    1:   nsresult rv;
    1: 
    1:   //MIME CHECKING
    1:   //must get the content type
    1:   // Note: the doc gets this from the network channel during StartPageLoad,
    1:   //    so we don't have to get it from there ourselves
    1:   nsCOMPtr<nsIDOMDocument> doc;
    1:   nsCAutoString mimeCType;
    1: 
    1:   //then lets check the mime type
    1:   if (NS_SUCCEEDED(aWindow->GetDocument(getter_AddRefs(doc))) && doc)
    1:   {
    1:     nsCOMPtr<nsIDOMNSDocument> nsdoc = do_QueryInterface(doc);
    1:     if (nsdoc)
    1:     {
    1:       nsAutoString mimeType;
    1:       if (NS_SUCCEEDED(nsdoc->GetContentType(mimeType)))
    1:         AppendUTF16toUTF8(mimeType, mimeCType);
    1: 
    1:       if (IsSupportedTextType(mimeCType.get()))
    1:       {
    1:         mEditorType.AssignLiteral("text");
    1:         mimeCType = "text/plain";
    1:       }
 7983:       else if (!mimeCType.EqualsLiteral("text/html") &&
 7983:                !mimeCType.EqualsLiteral("application/xhtml+xml"))
    1:       {
    1:         // Neither an acceptable text or html type.
    1:         mEditorStatus = eEditorErrorCantEditMimeType;
    1: 
    1:         // Turn editor into HTML -- we will load blank page later
    1:         mEditorType.AssignLiteral("html");
    1:         mimeCType.AssignLiteral("text/html");
    1:       }
    1:     }
    1: 
    1:     // Flush out frame construction to make sure that the subframe's
    1:     // presshell is set up if it needs to be.
    1:     nsCOMPtr<nsIDocument> document(do_QueryInterface(doc));
    1:     if (document) {
    1:       document->FlushPendingNotifications(Flush_Frames);
 3199:       if (mMakeWholeDocumentEditable) {
 3199:         document->SetEditableFlag(PR_TRUE);
 3199:       }
    1:     }
    1:   }
    1:   PRBool needHTMLController = PR_FALSE;
    1: 
    1:   const char *classString = "@mozilla.org/editor/htmleditor;1";
    1:   if (mEditorType.EqualsLiteral("textmail"))
    1:   {
    1:     mEditorFlags = nsIPlaintextEditor::eEditorPlaintextMask | 
    1:                    nsIPlaintextEditor::eEditorEnableWrapHackMask | 
    1:                    nsIPlaintextEditor::eEditorMailMask;
    1:   }
    1:   else if (mEditorType.EqualsLiteral("text"))
    1:   {
    1:     mEditorFlags = nsIPlaintextEditor::eEditorPlaintextMask | 
    1:                    nsIPlaintextEditor::eEditorEnableWrapHackMask;
    1:   }
    1:   else if (mEditorType.EqualsLiteral("htmlmail"))
    1:   {
    1:     if (mimeCType.EqualsLiteral("text/html"))
    1:     {
    1:       needHTMLController = PR_TRUE;
    1:       mEditorFlags = nsIPlaintextEditor::eEditorMailMask;
    1:     }
    1:     else //set the flags back to textplain.
    1:       mEditorFlags = nsIPlaintextEditor::eEditorPlaintextMask | 
    1:                      nsIPlaintextEditor::eEditorEnableWrapHackMask;
    1:   }
    1:   else // Defaulted to html
    1:   {
    1:     needHTMLController = PR_TRUE;
    1:   }
    1: 
 2896:   if (mInteractive) {
 2896:     mEditorFlags |= nsIPlaintextEditor::eEditorAllowInteraction;
 2896:   }
 2896: 
    1:   // make the UI state maintainer
14631:   mStateMaintainer = new nsComposerCommandsUpdater();
    1: 
    1:   // now init the state maintainer
    1:   // This allows notification of error state
    1:   //  even if we don't create an editor
14631:   rv = mStateMaintainer->Init(aWindow);
43805:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (mEditorStatus != eEditorCreationInProgress)
    1:   {
14631:     mStateMaintainer->NotifyDocumentCreated();
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // Create editor and do other things 
    1:   //  only if we haven't found some error above,
    1:   nsIDocShell *docShell = GetDocShellFromWindow(aWindow);
43806:   NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);  
    1: 
 2896:   if (!mInteractive) {
    1:     // Disable animation of images in this document:
    1:     nsCOMPtr<nsIDOMWindowUtils> utils(do_GetInterface(aWindow));
43806:     NS_ENSURE_TRUE(utils, NS_ERROR_FAILURE);
    1: 
    1:     rv = utils->GetImageAnimationMode(&mImageAnimationMode);
43805:     NS_ENSURE_SUCCESS(rv, rv);
    1:     utils->SetImageAnimationMode(imgIContainer::kDontAnimMode);
 2896:   }
    1: 
    1:   // create and set editor
    1:   nsCOMPtr<nsIEditorDocShell> editorDocShell = do_QueryInterface(docShell, &rv);
43805:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
57958:   // Try to reuse an existing editor
57958:   nsCOMPtr<nsIEditor> editor = do_QueryReferent(mExistingEditor);
57958:   if (!editor) {
57958:     editor = do_CreateInstance(classString, &rv);
43805:     NS_ENSURE_SUCCESS(rv, rv);
57958:     mExistingEditor = do_GetWeakReference(editor);
57958:   }
    1:   // set the editor on the docShell. The docShell now owns it.
    1:   rv = editorDocShell->SetEditor(editor);
43805:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // setup the HTML editor command controller
    1:   if (needHTMLController)
    1:   {
    1:     // The third controller takes an nsIEditor as the context
    1:     rv = SetupEditorCommandController("@mozilla.org/editor/htmleditorcontroller;1",
    1:                                       aWindow, editor,
    1:                                       &mHTMLCommandControllerId);
43805:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   // Set mimetype on editor
    1:   rv = editor->SetContentsMIMEType(mimeCType.get());
43805:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIContentViewer> contentViewer;
    1:   rv = docShell->GetContentViewer(getter_AddRefs(contentViewer));
43805:   NS_ENSURE_SUCCESS(rv, rv);
43806:   NS_ENSURE_TRUE(contentViewer, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIDOMDocument> domDoc;  
    1:   rv = contentViewer->GetDOMDocument(getter_AddRefs(domDoc));
43805:   NS_ENSURE_SUCCESS(rv, rv);
43806:   NS_ENSURE_TRUE(domDoc, NS_ERROR_FAILURE);
    1: 
    1:   // Set up as a doc state listener
    1:   // Important! We must have this to broadcast the "obs_documentCreated" message
14631:   rv = editor->AddDocumentStateListener(mStateMaintainer);
43805:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // XXXbz we really shouldn't need a presShell here!
    1:   nsCOMPtr<nsIPresShell> presShell;
    1:   rv = docShell->GetPresShell(getter_AddRefs(presShell));
43805:   NS_ENSURE_SUCCESS(rv, rv);
43806:   NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsISelectionController> selCon = do_QueryInterface(presShell);
    1:   rv = editor->Init(domDoc, presShell, nsnull /* root content */,
    1:                     selCon, mEditorFlags);
43805:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsISelection> selection;
    1:   editor->GetSelection(getter_AddRefs(selection));
    1:   nsCOMPtr<nsISelectionPrivate> selPriv = do_QueryInterface(selection);
43806:   NS_ENSURE_TRUE(selPriv, NS_ERROR_FAILURE);
    1: 
14631:   rv = selPriv->AddSelectionListener(mStateMaintainer);
43805:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // and as a transaction listener
    1:   nsCOMPtr<nsITransactionManager> txnMgr;
    1:   editor->GetTransactionManager(getter_AddRefs(txnMgr));
    1:   if (txnMgr)
14631:     txnMgr->AddListener(mStateMaintainer);
    1: 
    1:   // Set context on all controllers to be the editor
    1:   rv = SetEditorOnControllers(aWindow, editor);
43805:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Everything went fine!
    1:   mEditorStatus = eEditorOK;
    1: 
    1:   // This will trigger documentCreation notification
    1:   return editor->PostCreate();
    1: }
    1: 
14631: // Removes all listeners and controllers from aWindow and aEditor.
14631: void
14631: nsEditingSession::RemoveListenersAndControllers(nsIDOMWindow *aWindow,
14631:                                                 nsIEditor *aEditor)
14631: {
14631:   if (!mStateMaintainer || !aEditor)
14631:     return;
14631: 
14631:   // Remove all the listeners
14631:   nsCOMPtr<nsISelection> selection;
14631:   aEditor->GetSelection(getter_AddRefs(selection));
14631:   nsCOMPtr<nsISelectionPrivate> selPriv = do_QueryInterface(selection);
14631:   if (selPriv)
14631:     selPriv->RemoveSelectionListener(mStateMaintainer);
14631: 
14631:   aEditor->RemoveDocumentStateListener(mStateMaintainer);
14631: 
14631:   nsCOMPtr<nsITransactionManager> txnMgr;
14631:   aEditor->GetTransactionManager(getter_AddRefs(txnMgr));
14631:   if (txnMgr)
14631:     txnMgr->RemoveListener(mStateMaintainer);
14631: 
14631:   // Remove editor controllers from the window now that we're not
14631:   // editing in that window any more.
14631:   RemoveEditorControllers(aWindow);
14631: }
14631: 
    1: /*---------------------------------------------------------------------------
    1: 
    1:   TearDownEditorOnWindow
    1: 
 7856:   void tearDownEditorOnWindow (in nsIDOMWindow aWindow);
    1: ----------------------------------------------------------------------------*/
    1: NS_IMETHODIMP
 7856: nsEditingSession::TearDownEditorOnWindow(nsIDOMWindow *aWindow)
    1: {
43807:   NS_ENSURE_TRUE(mDoneSetup, NS_OK);
    1: 
43807:   NS_ENSURE_TRUE(aWindow, NS_ERROR_NULL_POINTER);
14631: 
    1:   nsresult rv;
    1:   
    1:   // Kill any existing reload timer
    1:   if (mLoadBlankDocTimer)
    1:   {
    1:     mLoadBlankDocTimer->Cancel();
    1:     mLoadBlankDocTimer = nsnull;
    1:   }
    1: 
    1:   mDoneSetup = PR_FALSE;
    1: 
 7856:   // Check if we're turning off editing (from contentEditable or designMode).
 7856:   nsCOMPtr<nsIDOMDocument> domDoc;
 7856:   aWindow->GetDocument(getter_AddRefs(domDoc));
 7856:   nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(domDoc);
 7856:   PRBool stopEditing = htmlDoc && htmlDoc->IsEditingOn();
14631:   if (stopEditing)
14631:     RemoveWebProgressListener(aWindow);
    1: 
    1:   nsCOMPtr<nsIEditorDocShell> editorDocShell;
    1:   rv = GetEditorDocShellFromWindow(aWindow, getter_AddRefs(editorDocShell));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   nsCOMPtr<nsIEditor> editor;
    1:   rv = editorDocShell->GetEditor(getter_AddRefs(editor));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
14450:   if (stopEditing)
11925:     htmlDoc->TearingDownEditor(editor);
11925: 
    1:   if (mStateMaintainer && editor)
    1:   {
14631:     // Null out the editor on the controllers first to prevent their weak 
14631:     // references from pointing to a destroyed editor.
    1:     SetEditorOnControllers(aWindow, nsnull);
    1:   }
    1: 
14631:   // Null out the editor on the docShell to trigger PreDestroy which
14631:   // needs to happen before document state listeners are removed below.
    1:   editorDocShell->SetEditor(nsnull);
    1: 
14631:   RemoveListenersAndControllers(aWindow, editor);
14631: 
14631:   if (stopEditing)
    1:   {
    1:     // Make things the way they were before we started editing.
 7856:     RestoreJSAndPlugins(aWindow);
14631:     RestoreAnimationMode(aWindow);
    1: 
14631:     if (mMakeWholeDocumentEditable)
14631:     {
 3199:       nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc, &rv);
 3199:       NS_ENSURE_SUCCESS(rv, rv);
 3199: 
 3199:       doc->SetEditableFlag(PR_FALSE);
 3199:     }
 3199:   }
 3199: 
    1:   return rv;
    1: }
    1: 
    1: /*---------------------------------------------------------------------------
    1: 
    1:   GetEditorForFrame
    1: 
    1:   nsIEditor getEditorForFrame (in nsIDOMWindow aWindow);
    1: ----------------------------------------------------------------------------*/
    1: NS_IMETHODIMP 
    1: nsEditingSession::GetEditorForWindow(nsIDOMWindow *aWindow,
    1:                                      nsIEditor **outEditor)
    1: {
    1:   nsCOMPtr<nsIEditorDocShell> editorDocShell;
    1:   nsresult rv = GetEditorDocShellFromWindow(aWindow,
    1:                                             getter_AddRefs(editorDocShell));
43805:   NS_ENSURE_SUCCESS(rv, rv);  
    1:   
    1:   return editorDocShell->GetEditor(outEditor);
    1: }
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #endif
    1: 
    1: /*---------------------------------------------------------------------------
    1: 
    1:   OnStateChange
    1: 
    1: ----------------------------------------------------------------------------*/
    1: NS_IMETHODIMP
    1: nsEditingSession::OnStateChange(nsIWebProgress *aWebProgress,
    1:                                 nsIRequest *aRequest,
    1:                                 PRUint32 aStateFlags, nsresult aStatus)
    1: {
    1: 
    1: #ifdef NOISY_DOC_LOADING
    1:   nsCOMPtr<nsIChannel> channel(do_QueryInterface(aRequest));
    1:   if (channel)
    1:   {
    1:     nsCAutoString contentType;
    1:     channel->GetContentType(contentType);
    1:     if (!contentType.IsEmpty())
    1:       printf(" ++++++ MIMETYPE = %s\n", contentType.get());
    1:   }
    1: #endif
    1: 
    1:   //
    1:   // A Request has started...
    1:   //
    1:   if (aStateFlags & nsIWebProgressListener::STATE_START)
    1:   {
    1: #ifdef NOISY_DOC_LOADING
    1:   {
    1:     nsCOMPtr<nsIChannel> channel(do_QueryInterface(aRequest));
    1:     if (channel)
    1:     {
    1:       nsCOMPtr<nsIURI> uri;
    1:       channel->GetURI(getter_AddRefs(uri));
    1:       if (uri)
    1:       {
    1:         nsXPIDLCString spec;
    1:         uri->GetSpec(spec);
    1:         printf(" **** STATE_START: CHANNEL URI=%s, flags=%x\n",
    1:                spec.get(), aStateFlags);
    1:       }
    1:     }
    1:     else
    1:       printf("    STATE_START: NO CHANNEL flags=%x\n", aStateFlags);
    1:   }
    1: #endif
    1:     // Page level notification...
    1:     if (aStateFlags & nsIWebProgressListener::STATE_IS_NETWORK)
    1:     {
    1:       nsCOMPtr<nsIChannel> channel(do_QueryInterface(aRequest));
    1:       StartPageLoad(channel);
    1: #ifdef NOISY_DOC_LOADING
    1:       printf("STATE_START & STATE_IS_NETWORK flags=%x\n", aStateFlags);
    1: #endif
    1:     }
    1: 
    1:     // Document level notification...
 8709:     if (aStateFlags & nsIWebProgressListener::STATE_IS_DOCUMENT &&
 8709:         !(aStateFlags & nsIWebProgressListener::STATE_RESTORING)) {
    1: #ifdef NOISY_DOC_LOADING
    1:       printf("STATE_START & STATE_IS_DOCUMENT flags=%x\n", aStateFlags);
    1: #endif
    1: 
    1:       PRBool progressIsForTargetDocument =
    1:         IsProgressForTargetDocument(aWebProgress);
    1: 
    1:       if (progressIsForTargetDocument)
    1:       {
    1:         nsCOMPtr<nsIDOMWindow> window;
    1:         aWebProgress->GetDOMWindow(getter_AddRefs(window));
    1: 
    1:         nsCOMPtr<nsIDOMDocument> doc;
    1:         window->GetDocument(getter_AddRefs(doc));
    1: 
    1:         nsCOMPtr<nsIHTMLDocument> htmlDoc(do_QueryInterface(doc));
    1: 
    1:         if (htmlDoc && htmlDoc->IsWriting())
    1:         {
    1:           nsCOMPtr<nsIDOMNSHTMLDocument> htmlDomDoc(do_QueryInterface(doc));
    1:           nsAutoString designMode;
    1: 
    1:           htmlDomDoc->GetDesignMode(designMode);
    1: 
    1:           if (designMode.EqualsLiteral("on"))
    1:           {
    1:             // This notification is for data coming in through
    1:             // document.open/write/close(), ignore it.
    1: 
    1:             return NS_OK;
    1:           }
    1:         }
    1: 
    1:         mCanCreateEditor = PR_TRUE;
    1:         StartDocumentLoad(aWebProgress, progressIsForTargetDocument);
    1:       }
    1:     }
    1:   }
    1:   //
    1:   // A Request is being processed
    1:   //
    1:   else if (aStateFlags & nsIWebProgressListener::STATE_TRANSFERRING)
    1:   {
    1:     if (aStateFlags & nsIWebProgressListener::STATE_IS_DOCUMENT)
    1:     {
    1:       // document transfer started
    1:     }
    1:   }
    1:   //
    1:   // Got a redirection
    1:   //
    1:   else if (aStateFlags & nsIWebProgressListener::STATE_REDIRECTING)
    1:   {
    1:     if (aStateFlags & nsIWebProgressListener::STATE_IS_DOCUMENT)
    1:     {
    1:       // got a redirect
    1:     }
    1:   }
    1:   //
29080:   // A network or document Request has finished...
    1:   //
    1:   else if (aStateFlags & nsIWebProgressListener::STATE_STOP)
    1:   {
    1: 
    1: #ifdef NOISY_DOC_LOADING
    1:   {
    1:     nsCOMPtr<nsIChannel> channel(do_QueryInterface(aRequest));
    1:     if (channel)
    1:     {
    1:       nsCOMPtr<nsIURI> uri;
    1:       channel->GetURI(getter_AddRefs(uri));
    1:       if (uri)
    1:       {
    1:         nsXPIDLCString spec;
    1:         uri->GetSpec(spec);
    1:         printf(" **** STATE_STOP: CHANNEL URI=%s, flags=%x\n",
    1:                spec.get(), aStateFlags);
    1:       }
    1:     }
    1:     else
    1:       printf("     STATE_STOP: NO CHANNEL  flags=%x\n", aStateFlags);
    1:   }
    1: #endif
    1: 
    1:     // Document level notification...
    1:     if (aStateFlags & nsIWebProgressListener::STATE_IS_DOCUMENT)
    1:     {
    1:       nsCOMPtr<nsIChannel> channel = do_QueryInterface(aRequest);
    1:       EndDocumentLoad(aWebProgress, channel, aStatus,
    1:                       IsProgressForTargetDocument(aWebProgress));
    1: #ifdef NOISY_DOC_LOADING
    1:       printf("STATE_STOP & STATE_IS_DOCUMENT flags=%x\n", aStateFlags);
    1: #endif
    1:     }
    1: 
    1:     // Page level notification...
    1:     if (aStateFlags & nsIWebProgressListener::STATE_IS_NETWORK)
    1:     {
    1:       nsCOMPtr<nsIChannel> channel = do_QueryInterface(aRequest);
    1:       (void)EndPageLoad(aWebProgress, channel, aStatus);
    1: #ifdef NOISY_DOC_LOADING
    1:       printf("STATE_STOP & STATE_IS_NETWORK flags=%x\n", aStateFlags);
    1: #endif
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /*---------------------------------------------------------------------------
    1: 
    1:   OnProgressChange
    1: 
    1: ----------------------------------------------------------------------------*/
    1: NS_IMETHODIMP
    1: nsEditingSession::OnProgressChange(nsIWebProgress *aWebProgress,
    1:                                    nsIRequest *aRequest,
    1:                                    PRInt32 aCurSelfProgress,
    1:                                    PRInt32 aMaxSelfProgress,
    1:                                    PRInt32 aCurTotalProgress,
    1:                                    PRInt32 aMaxTotalProgress)
    1: {
    1:     NS_NOTREACHED("notification excluded in AddProgressListener(...)");
    1:     return NS_OK;
    1: }
    1: 
    1: /*---------------------------------------------------------------------------
    1: 
    1:   OnLocationChange
    1: 
    1: ----------------------------------------------------------------------------*/
    1: NS_IMETHODIMP
    1: nsEditingSession::OnLocationChange(nsIWebProgress *aWebProgress, 
    1:                                    nsIRequest *aRequest, nsIURI *aURI)
    1: {
    1:   nsCOMPtr<nsIDOMWindow> domWindow;
    1:   nsresult rv = aWebProgress->GetDOMWindow(getter_AddRefs(domWindow));
43805:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIDOMDocument> domDoc;
    1:   rv = domWindow->GetDocument(getter_AddRefs(domDoc));
43805:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
43806:   NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
    1: 
    1:   doc->SetDocumentURI(aURI);
    1: 
    1:   // Notify the location-changed observer that
    1:   //  the document URL has changed
    1:   nsIDocShell *docShell = GetDocShellFromWindow(domWindow);
43806:   NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsICommandManager> commandManager = do_GetInterface(docShell);
    1:   nsCOMPtr<nsPICommandUpdater> commandUpdater =
    1:                                   do_QueryInterface(commandManager);
43806:   NS_ENSURE_TRUE(commandUpdater, NS_ERROR_FAILURE);
    1: 
    1:   return commandUpdater->CommandStatusChanged("obs_documentLocationChanged");
    1: }
    1: 
    1: /*---------------------------------------------------------------------------
    1: 
    1:   OnStatusChange
    1: 
    1: ----------------------------------------------------------------------------*/
    1: NS_IMETHODIMP
    1: nsEditingSession::OnStatusChange(nsIWebProgress *aWebProgress,
    1:                                  nsIRequest *aRequest,
    1:                                  nsresult aStatus,
    1:                                  const PRUnichar *aMessage)
    1: {
    1:     NS_NOTREACHED("notification excluded in AddProgressListener(...)");
    1:     return NS_OK;
    1: }
    1: 
    1: /*---------------------------------------------------------------------------
    1: 
    1:   OnSecurityChange
    1: 
    1: ----------------------------------------------------------------------------*/
    1: NS_IMETHODIMP
    1: nsEditingSession::OnSecurityChange(nsIWebProgress *aWebProgress,
    1:                                    nsIRequest *aRequest, PRUint32 state)
    1: {
    1:     NS_NOTREACHED("notification excluded in AddProgressListener(...)");
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #endif
    1: 
    1: 
    1: /*---------------------------------------------------------------------------
    1: 
    1:   IsProgressForTargetDocument
    1: 
    1:   Check that this notification is for our document.
    1: ----------------------------------------------------------------------------*/
    1: 
    1: PRBool
    1: nsEditingSession::IsProgressForTargetDocument(nsIWebProgress *aWebProgress)
    1: {
56162:   nsCOMPtr<nsIWebProgress> editedWebProgress = do_QueryReferent(mDocShell);
56162:   return editedWebProgress == aWebProgress;
    1: }
    1: 
    1: 
    1: /*---------------------------------------------------------------------------
    1: 
    1:   GetEditorStatus
    1: 
    1:   Called during GetCommandStateParams("obs_documentCreated"...) 
    1:   to determine if editor was created and document 
    1:   was loaded successfully
    1: ----------------------------------------------------------------------------*/
    1: NS_IMETHODIMP
    1: nsEditingSession::GetEditorStatus(PRUint32 *aStatus)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aStatus);
    1:   *aStatus = mEditorStatus;
    1:   return NS_OK;
    1: }
    1: 
    1: /*---------------------------------------------------------------------------
    1: 
    1:   StartDocumentLoad
    1: 
    1:   Called on start of load in a single frame
    1: ----------------------------------------------------------------------------*/
    1: nsresult
    1: nsEditingSession::StartDocumentLoad(nsIWebProgress *aWebProgress, 
    1:                                     PRBool aIsToBeMadeEditable)
    1: {
    1: #ifdef NOISY_DOC_LOADING
    1:   printf("======= StartDocumentLoad ========\n");
    1: #endif
    1: 
    1:   NS_ENSURE_ARG_POINTER(aWebProgress);
    1:   
    1:   // If we have an editor here, then we got a reload after making the editor.
    1:   // We need to blow it away and make a new one at the end of the load.
    1:   nsCOMPtr<nsIDOMWindow> domWindow;
    1:   aWebProgress->GetDOMWindow(getter_AddRefs(domWindow));
    1:   if (domWindow)
    1:   {
14631:     nsIDocShell *docShell = GetDocShellFromWindow(domWindow);
43806:     NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
14631:     docShell->DetachEditorFromWindow();
    1:   }
    1:     
    1:   if (aIsToBeMadeEditable)
    1:     mEditorStatus = eEditorCreationInProgress;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /*---------------------------------------------------------------------------
    1: 
    1:   EndDocumentLoad
    1: 
    1:   Called on end of load in a single frame
    1: ----------------------------------------------------------------------------*/
    1: nsresult
    1: nsEditingSession::EndDocumentLoad(nsIWebProgress *aWebProgress,
    1:                                   nsIChannel* aChannel, nsresult aStatus,
    1:                                   PRBool aIsToBeMadeEditable)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aWebProgress);
    1:   
    1: #ifdef NOISY_DOC_LOADING
    1:   printf("======= EndDocumentLoad ========\n");
    1:   printf("with status %d, ", aStatus);
    1:   nsCOMPtr<nsIURI> uri;
    1:   nsXPIDLCString spec;
    1:   if (NS_SUCCEEDED(aChannel->GetURI(getter_AddRefs(uri)))) {
    1:     uri->GetSpec(spec);
    1:     printf(" uri %s\n", spec.get());
    1:   }
    1: #endif
    1: 
    1:   // We want to call the base class EndDocumentLoad,
    1:   // but avoid some of the stuff
28078:   // that nsDocShell does (need to refactor).
    1:   
    1:   // OK, time to make an editor on this document
    1:   nsCOMPtr<nsIDOMWindow> domWindow;
    1:   aWebProgress->GetDOMWindow(getter_AddRefs(domWindow));
    1:   
    1:   // Set the error state -- we will create an editor 
    1:   // anyway and load empty doc later
    1:   if (aIsToBeMadeEditable) {
    1:     if (aStatus == NS_ERROR_FILE_NOT_FOUND)
    1:       mEditorStatus = eEditorErrorFileNotFound;
    1:   }
    1: 
    1:   nsIDocShell *docShell = GetDocShellFromWindow(domWindow);
43806:   NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);       // better error handling?
    1: 
    1:   // cancel refresh from meta tags
    1:   // we need to make sure that all pages in editor (whether editable or not)
    1:   // can't refresh contents being edited
    1:   nsCOMPtr<nsIRefreshURI> refreshURI = do_QueryInterface(docShell);
    1:   if (refreshURI)
    1:     refreshURI->CancelRefreshURITimers();
    1: 
    1:   nsCOMPtr<nsIEditorDocShell> editorDocShell = do_QueryInterface(docShell);
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   // did someone set the flag to make this shell editable?
    1:   if (aIsToBeMadeEditable && mCanCreateEditor && editorDocShell)
    1:   {
    1:     PRBool  makeEditable;
    1:     editorDocShell->GetEditable(&makeEditable);
    1:   
    1:     if (makeEditable)
    1:     {
14976:       // To keep pre Gecko 1.9 behavior, setup editor always when
14976:       // mMakeWholeDocumentEditable.
56879:       bool needsSetup = false;
14976:       if (mMakeWholeDocumentEditable) {
56879:         needsSetup = true;
14976:       } else {
 2896:         // do we already have an editor here?
 2896:         nsCOMPtr<nsIEditor> editor;
 2896:         rv = editorDocShell->GetEditor(getter_AddRefs(editor));
43808:         NS_ENSURE_SUCCESS(rv, rv);
14976: 
14976:         needsSetup = !editor;
14976:       }
14976: 
14976:       if (needsSetup)
 2896:       {
    1:         mCanCreateEditor = PR_FALSE;
    1:         rv = SetupEditorOnWindow(domWindow);
    1:         if (NS_FAILED(rv))
    1:         {
    1:           // If we had an error, setup timer to load a blank page later
    1:           if (mLoadBlankDocTimer)
    1:           {
    1:             // Must cancel previous timer?
    1:             mLoadBlankDocTimer->Cancel();
    1:             mLoadBlankDocTimer = NULL;
    1:           }
    1:   
    1:           mLoadBlankDocTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
43805:           NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:           mEditorStatus = eEditorCreationInProgress;
    1:           mLoadBlankDocTimer->InitWithFuncCallback(
    1:                                           nsEditingSession::TimerCallback,
39590:                                           static_cast<void*> (mDocShell.get()),
    1:                                           10, nsITimer::TYPE_ONE_SHOT);
    1:         }
    1:       }
 2896:     }
    1:   }
    1:   return rv;
    1: }
    1: 
    1: 
    1: void
    1: nsEditingSession::TimerCallback(nsITimer* aTimer, void* aClosure)
    1: {
39590:   nsCOMPtr<nsIDocShell> docShell = do_QueryReferent(static_cast<nsIWeakReference*> (aClosure));
    1:   if (docShell)
    1:   {
    1:     nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(docShell));
    1:     if (webNav)
    1:       webNav->LoadURI(NS_LITERAL_STRING("about:blank").get(),
    1:                       0, nsnull, nsnull, nsnull);
    1:   }
    1: }
    1: 
    1: /*---------------------------------------------------------------------------
    1: 
    1:   StartPageLoad
    1: 
    1:   Called on start load of the entire page (incl. subframes)
    1: ----------------------------------------------------------------------------*/
    1: nsresult
    1: nsEditingSession::StartPageLoad(nsIChannel *aChannel)
    1: {
    1: #ifdef NOISY_DOC_LOADING
    1:   printf("======= StartPageLoad ========\n");
    1: #endif
    1:   return NS_OK;
    1: }
    1: 
    1: /*---------------------------------------------------------------------------
    1: 
    1:   EndPageLoad
    1: 
    1:   Called on end load of the entire page (incl. subframes)
    1: ----------------------------------------------------------------------------*/
    1: nsresult
    1: nsEditingSession::EndPageLoad(nsIWebProgress *aWebProgress,
    1:                               nsIChannel* aChannel, nsresult aStatus)
    1: {
    1: #ifdef NOISY_DOC_LOADING
    1:   printf("======= EndPageLoad ========\n");
    1:   printf("  with status %d, ", aStatus);
    1:   nsCOMPtr<nsIURI> uri;
    1:   nsXPIDLCString spec;
    1:   if (NS_SUCCEEDED(aChannel->GetURI(getter_AddRefs(uri)))) {
    1:     uri->GetSpec(spec);
    1:     printf("uri %s\n", spec.get());
    1:   }
    1:  
    1:   nsCAutoString contentType;
    1:   aChannel->GetContentType(contentType);
    1:   if (!contentType.IsEmpty())
    1:     printf("   flags = %d, status = %d, MIMETYPE = %s\n", 
    1:                mEditorFlags, mEditorStatus, contentType.get());
    1: #endif
    1: 
    1:   // Set the error state -- we will create an editor anyway 
    1:   // and load empty doc later
    1:   if (aStatus == NS_ERROR_FILE_NOT_FOUND)
    1:     mEditorStatus = eEditorErrorFileNotFound;
    1: 
    1:   nsCOMPtr<nsIDOMWindow> domWindow;
    1:   aWebProgress->GetDOMWindow(getter_AddRefs(domWindow));
    1: 
    1:   nsIDocShell *docShell = GetDocShellFromWindow(domWindow);
43806:   NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
    1: 
    1:   // cancel refresh from meta tags
    1:   // we need to make sure that all pages in editor (whether editable or not)
    1:   // can't refresh contents being edited
    1:   nsCOMPtr<nsIRefreshURI> refreshURI = do_QueryInterface(docShell);
    1:   if (refreshURI)
    1:     refreshURI->CancelRefreshURITimers();
    1: 
    1: #if 0
    1:   // Shouldn't we do this when we want to edit sub-frames?
 2896:   return MakeWindowEditable(domWindow, "html", PR_FALSE, mInteractive);
    1: #else
    1:   return NS_OK;
    1: #endif
    1: }
    1: 
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #endif
    1: 
    1: /*---------------------------------------------------------------------------
    1: 
    1:   GetDocShellFromWindow
    1: 
    1:   Utility method. This will always return nsnull if no docShell is found.
    1: ----------------------------------------------------------------------------*/
    1: nsIDocShell *
    1: nsEditingSession::GetDocShellFromWindow(nsIDOMWindow *aWindow)
    1: {
    1:   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(aWindow);
43807:   NS_ENSURE_TRUE(window, nsnull);
    1: 
    1:   return window->GetDocShell();
    1: }
    1: 
    1: /*---------------------------------------------------------------------------
    1: 
    1:   GetEditorDocShellFromWindow
    1: 
    1:   Utility method. This will always return an error if no docShell
    1:   is returned.
    1: ----------------------------------------------------------------------------*/
    1: nsresult
    1: nsEditingSession::GetEditorDocShellFromWindow(nsIDOMWindow *aWindow,
    1:                                               nsIEditorDocShell** outDocShell)
    1: {
    1:   nsIDocShell *docShell = GetDocShellFromWindow(aWindow);
43806:   NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
    1:   
    1:   return docShell->QueryInterface(NS_GET_IID(nsIEditorDocShell), 
    1:                                   (void **)outDocShell);
    1: }
    1: 
    1: /*---------------------------------------------------------------------------
    1: 
    1:   PrepareForEditing
    1: 
    1:   Set up this editing session for one or more editors
    1: ----------------------------------------------------------------------------*/
    1: nsresult
    1: nsEditingSession::PrepareForEditing(nsIDOMWindow *aWindow)
    1: {
    1:   if (mProgressListenerRegistered)
    1:     return NS_OK;
    1:     
    1:   nsIDocShell *docShell = GetDocShellFromWindow(aWindow);
    1:   
    1:   // register callback
    1:   nsCOMPtr<nsIWebProgress> webProgress = do_GetInterface(docShell);
43806:   NS_ENSURE_TRUE(webProgress, NS_ERROR_FAILURE);
    1: 
    1:   nsresult rv =
    1:     webProgress->AddProgressListener(this,
    1:                                      (nsIWebProgress::NOTIFY_STATE_NETWORK  | 
    1:                                       nsIWebProgress::NOTIFY_STATE_DOCUMENT |
    1:                                       nsIWebProgress::NOTIFY_LOCATION));
    1: 
    1:   mProgressListenerRegistered = NS_SUCCEEDED(rv);
    1: 
    1:   return rv;
    1: }
    1: 
    1: /*---------------------------------------------------------------------------
    1: 
    1:   SetupEditorCommandController
    1: 
    1:   Create a command controller, append to controllers,
    1:   get and return the controller ID, and set the context
    1: ----------------------------------------------------------------------------*/
    1: nsresult
    1: nsEditingSession::SetupEditorCommandController(
    1:                                   const char *aControllerClassName,
    1:                                   nsIDOMWindow *aWindow,
    1:                                   nsISupports *aContext,
    1:                                   PRUint32 *aControllerId)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aControllerClassName);
    1:   NS_ENSURE_ARG_POINTER(aWindow);
    1:   NS_ENSURE_ARG_POINTER(aContext);
    1:   NS_ENSURE_ARG_POINTER(aControllerId);
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIDOMWindowInternal> domWindowInt =
    1:                                     do_QueryInterface(aWindow, &rv);
43805:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   nsCOMPtr<nsIControllers> controllers;      
    1:   rv = domWindowInt->GetControllers(getter_AddRefs(controllers));
43805:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // We only have to create each singleton controller once
    1:   // We know this has happened once we have a controllerId value
    1:   if (!*aControllerId)
    1:   {
    1:     nsresult rv;
    1:     nsCOMPtr<nsIController> controller;
    1:     controller = do_CreateInstance(aControllerClassName, &rv);
43805:     NS_ENSURE_SUCCESS(rv, rv);  
    1: 
    1:     // We must insert at head of the list to be sure our
    1:     //   controller is found before other implementations
    1:     //   (e.g., not-implemented versions by browser)
    1:     rv = controllers->InsertControllerAt(0, controller);
43805:     NS_ENSURE_SUCCESS(rv, rv);  
    1: 
    1:     // Remember the ID for the controller
    1:     rv = controllers->GetControllerId(controller, aControllerId);
43805:     NS_ENSURE_SUCCESS(rv, rv);  
    1:   }  
    1: 
    1:   // Set the context
    1:   return SetContextOnControllerById(controllers, aContext, *aControllerId);
    1: }
    1: 
    1: /*---------------------------------------------------------------------------
    1: 
    1:   SetEditorOnControllers
    1: 
    1:   Set the editor on the controller(s) for this window
    1: ----------------------------------------------------------------------------*/
    1: NS_IMETHODIMP
    1: nsEditingSession::SetEditorOnControllers(nsIDOMWindow *aWindow,
    1:                                          nsIEditor* aEditor)
    1: {
    1:   nsresult rv;
    1:   
    1:   // set the editor on the controller
    1:   nsCOMPtr<nsIDOMWindowInternal> domWindowInt =
    1:                                      do_QueryInterface(aWindow, &rv);
43805:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   nsCOMPtr<nsIControllers> controllers;      
    1:   rv = domWindowInt->GetControllers(getter_AddRefs(controllers));
43805:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsISupports> editorAsISupports = do_QueryInterface(aEditor);
    1:   if (mBaseCommandControllerId)
    1:   {
    1:     rv = SetContextOnControllerById(controllers, editorAsISupports,
    1:                                     mBaseCommandControllerId);
43805:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   if (mDocStateControllerId)
    1:   {
    1:     rv = SetContextOnControllerById(controllers, editorAsISupports,
    1:                                     mDocStateControllerId);
43805:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   if (mHTMLCommandControllerId)
    1:     rv = SetContextOnControllerById(controllers, editorAsISupports,
    1:                                     mHTMLCommandControllerId);
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsEditingSession::SetContextOnControllerById(nsIControllers* aControllers,
    1:                                              nsISupports* aContext,
    1:                                              PRUint32 aID)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aControllers);
    1: 
    1:   // aContext can be null (when destroying editor)
    1:   nsCOMPtr<nsIController> controller;    
    1:   aControllers->GetControllerById(aID, getter_AddRefs(controller));
    1:   
    1:   // ok with nil controller
    1:   nsCOMPtr<nsIControllerContext> editorController =
    1:                                        do_QueryInterface(controller);
43806:   NS_ENSURE_TRUE(editorController, NS_ERROR_FAILURE);
    1: 
    1:   return editorController->SetCommandContext(aContext);
    1: }
14631: 
14631: void
14631: nsEditingSession::RemoveEditorControllers(nsIDOMWindow *aWindow)
14631: {
14631:   // Remove editor controllers from the aWindow, call when we're 
14631:   // tearing down/detaching editor.
14631:   nsCOMPtr<nsIDOMWindowInternal> domWindowInt(do_QueryInterface(aWindow));
14631: 
14631:   nsCOMPtr<nsIControllers> controllers;
14631:   if (domWindowInt)
14631:     domWindowInt->GetControllers(getter_AddRefs(controllers));
14631: 
14631:   if (controllers)
14631:   {
14631:     nsCOMPtr<nsIController> controller;
14631:     if (mBaseCommandControllerId)
14631:     {
14631:       controllers->GetControllerById(mBaseCommandControllerId,
14631:                                      getter_AddRefs(controller));
14631:       if (controller)
14631:         controllers->RemoveController(controller);
14631:     }
14631: 
14631:     if (mDocStateControllerId)
14631:     {
14631:       controllers->GetControllerById(mDocStateControllerId,
14631:                                      getter_AddRefs(controller));
14631:       if (controller)
14631:         controllers->RemoveController(controller);
14631:     }
14631: 
14631:     if (mHTMLCommandControllerId)
14631:     {
14631:       controllers->GetControllerById(mHTMLCommandControllerId,
14631:                                      getter_AddRefs(controller));
14631:       if (controller)
14631:         controllers->RemoveController(controller);
14631:     }
14631:   }
14631: 
14631:   // Clear IDs to trigger creation of new controllers.
14631:   mBaseCommandControllerId = 0;
14631:   mDocStateControllerId = 0;
14631:   mHTMLCommandControllerId = 0;
14631: }
14631: 
14631: void
14631: nsEditingSession::RemoveWebProgressListener(nsIDOMWindow *aWindow)
14631: {
14631:   nsIDocShell *docShell = GetDocShellFromWindow(aWindow);
14631:   nsCOMPtr<nsIWebProgress> webProgress = do_GetInterface(docShell);
14631:   if (webProgress)
14631:   {
14631:     webProgress->RemoveProgressListener(this);
14631:     mProgressListenerRegistered = PR_FALSE;
14631:   }
14631: }
14631: 
14631: void
14631: nsEditingSession::RestoreAnimationMode(nsIDOMWindow *aWindow)
14631: {
14631:   if (!mInteractive)
14631:   {
14631:     nsCOMPtr<nsIDOMWindowUtils> utils(do_GetInterface(aWindow));
14631:     if (utils)
14631:       utils->SetImageAnimationMode(mImageAnimationMode);
14631:   }
14631: }
14631: 
14631: nsresult
14631: nsEditingSession::DetachFromWindow(nsIDOMWindow* aWindow)
14631: {
43807:   NS_ENSURE_TRUE(mDoneSetup, NS_OK);
14835: 
14631:   NS_ASSERTION(mStateMaintainer, "mStateMaintainer should exist.");
14631: 
14631:   // Kill any existing reload timer
14631:   if (mLoadBlankDocTimer)
14631:   {
14631:     mLoadBlankDocTimer->Cancel();
14631:     mLoadBlankDocTimer = nsnull;
14631:   }
14631: 
14631:   // Remove controllers, webprogress listener, and otherwise
14631:   // make things the way they were before we started editing.
14631:   RemoveEditorControllers(aWindow);
14631:   RemoveWebProgressListener(aWindow);
14631:   RestoreJSAndPlugins(aWindow);
14631:   RestoreAnimationMode(aWindow);
14631: 
14631:   // Kill our weak reference to our original window, in case
14631:   // it changes on restore, or otherwise dies.
56162:   mDocShell = nsnull;
14631: 
14631:   return NS_OK;
14631: }
14631: 
14631: nsresult
14631: nsEditingSession::ReattachToWindow(nsIDOMWindow* aWindow)
14631: {
43807:   NS_ENSURE_TRUE(mDoneSetup, NS_OK);
14835: 
14631:   NS_ASSERTION(mStateMaintainer, "mStateMaintainer should exist.");
14631: 
14631:   // Imitate nsEditorDocShell::MakeEditable() to reattach the
14631:   // old editor ot the window.
14631:   nsresult rv;
14631: 
56162:   nsIDocShell *docShell = GetDocShellFromWindow(aWindow);
56162:   NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
56162:   mDocShell = do_GetWeakReference(docShell);
14631: 
14631:   // Disable plugins.
14631:   if (!mInteractive)
14631:   {
14631:     rv = DisableJSAndPlugins(aWindow);
14631:     NS_ENSURE_SUCCESS(rv, rv);
14631:   }
14631: 
14631:   // Tells embedder that startup is in progress.
14631:   mEditorStatus = eEditorCreationInProgress;
14631: 
14631:   // Adds back web progress listener.
14631:   rv = PrepareForEditing(aWindow);
14631:   NS_ENSURE_SUCCESS(rv, rv);
14631: 
14631:   // Setup the command controllers again.
14631:   rv = SetupEditorCommandController("@mozilla.org/editor/editorcontroller;1",
14631:                                     aWindow,
14631:                                     static_cast<nsIEditingSession*>(this),
14631:                                     &mBaseCommandControllerId);
14631:   NS_ENSURE_SUCCESS(rv, rv);
14631: 
14631:   rv = SetupEditorCommandController("@mozilla.org/editor/editordocstatecontroller;1",
14631:                                     aWindow,
14631:                                     static_cast<nsIEditingSession*>(this),
14631:                                     &mDocStateControllerId);
14631:   NS_ENSURE_SUCCESS(rv, rv);
14631: 
14631:   if (mStateMaintainer)
14631:     mStateMaintainer->Init(aWindow);
14631: 
14631:   // Get editor
14631:   nsCOMPtr<nsIEditor> editor;
14631:   rv = GetEditorForWindow(aWindow, getter_AddRefs(editor));
43807:   NS_ENSURE_TRUE(editor, NS_ERROR_FAILURE);
14631: 
14631:   if (!mInteractive)
14631:   {
14631:     // Disable animation of images in this document:
14631:     nsCOMPtr<nsIDOMWindowUtils> utils(do_GetInterface(aWindow));
43806:     NS_ENSURE_TRUE(utils, NS_ERROR_FAILURE);
14631: 
14631:     rv = utils->GetImageAnimationMode(&mImageAnimationMode);
14631:     NS_ENSURE_SUCCESS(rv, rv);
14631:     utils->SetImageAnimationMode(imgIContainer::kDontAnimMode);
14631:   }
14631: 
14631:   // The third controller takes an nsIEditor as the context
14631:   rv = SetupEditorCommandController("@mozilla.org/editor/htmleditorcontroller;1",
14631:                                     aWindow, editor,
14631:                                     &mHTMLCommandControllerId);
14631:   NS_ENSURE_SUCCESS(rv, rv);
14631: 
14631:   // Set context on all controllers to be the editor
14631:   rv = SetEditorOnControllers(aWindow, editor);
14631:   NS_ENSURE_SUCCESS(rv, rv);
14631: 
14631: #ifdef DEBUG
14631:   {
14631:     PRBool isEditable;
14631:     rv = WindowIsEditable(aWindow, &isEditable);
14631:     NS_ENSURE_SUCCESS(rv, rv);
14631:     NS_ASSERTION(isEditable, "Window is not editable after reattaching editor.");
14631:   }
14631: #endif // DEBUG
14631: 
14631:   return NS_OK;
14631: }
