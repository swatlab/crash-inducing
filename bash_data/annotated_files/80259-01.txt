35729: // Copyright (c) 2009 The Chromium Authors. All rights reserved.
35729: // Use of this source code is governed by a BSD-style license that can be
35729: // found in the LICENSE file.
35729: 
35729: #include "base/file_descriptor_shuffle.h"
35729: 
35729: #include <errno.h>
35729: #include <unistd.h>
35729: 
35729: #include "base/eintr_wrapper.h"
35729: #include "base/logging.h"
35729: 
35729: namespace base {
35729: 
80259: bool PerformInjectiveMultimapDestructive(
80259:     InjectiveMultimap* m, InjectionDelegate* delegate) {
80259:   static const size_t kMaxExtraFDs = 16;
80259:   int extra_fds[kMaxExtraFDs];
80259:   unsigned next_extra_fd = 0;
35729: 
80259:   // DANGER: this function may not allocate.
80259: 
80259:   for (InjectiveMultimap::iterator i = m->begin(); i != m->end(); ++i) {
35729:     int temp_fd = -1;
35729: 
35729:     // We DCHECK the injectiveness of the mapping.
80259:     for (InjectiveMultimap::iterator j = i + 1; j != m->end(); ++j) {
80259:       DCHECK(i->dest != j->dest) << "Both fd " << i->source
80259:           << " and " << j->source << " map to " << i->dest;
80259:     }
35729: 
35729:     const bool is_identity = i->source == i->dest;
35729: 
80259:     for (InjectiveMultimap::iterator j = i + 1; j != m->end(); ++j) {
35729:       if (!is_identity && i->dest == j->source) {
35729:         if (temp_fd == -1) {
35729:           if (!delegate->Duplicate(&temp_fd, i->dest))
35729:             return false;
80259:           if (next_extra_fd < kMaxExtraFDs) {
80259:             extra_fds[next_extra_fd++] = temp_fd;
80259:           } else {
80259:               DLOG(ERROR) << "PerformInjectiveMultimapDestructive overflowed "
80259:                           << "extra_fds. Leaking file descriptors!";
80259:           }
35729:         }
35729: 
35729:         j->source = temp_fd;
35729:         j->close = false;
35729:       }
35729: 
35729:       if (i->close && i->source == j->dest)
35729:         i->close = false;
35729: 
35729:       if (i->close && i->source == j->source) {
35729:         i->close = false;
35729:         j->close = true;
35729:       }
35729:     }
35729: 
35729:     if (!is_identity) {
35729:       if (!delegate->Move(i->source, i->dest))
35729:         return false;
35729:     }
35729: 
35729:     if (!is_identity && i->close)
35729:       delegate->Close(i->source);
35729:   }
35729: 
80259:   for (unsigned i = 0; i < next_extra_fd; i++)
80259:     delegate->Close(extra_fds[i]);
80259: 
80259:   return true;
35729: }
35729: 
80259: bool PerformInjectiveMultimap(const InjectiveMultimap& m_in,
80259:                               InjectionDelegate* delegate) {
80259:     InjectiveMultimap m(m_in);
80259:     return PerformInjectiveMultimapDestructive(&m, delegate);
35729: }
35729: 
35729: bool FileDescriptorTableInjection::Duplicate(int* result, int fd) {
35729:   *result = HANDLE_EINTR(dup(fd));
35729:   return *result >= 0;
35729: }
35729: 
35729: bool FileDescriptorTableInjection::Move(int src, int dest) {
35729:   return HANDLE_EINTR(dup2(src, dest)) != -1;
35729: }
35729: 
35729: void FileDescriptorTableInjection::Close(int fd) {
35729:   HANDLE_EINTR(close(fd));
35729: }
35729: 
35729: }  // namespace base
