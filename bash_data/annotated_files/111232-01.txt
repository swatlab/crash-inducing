 93202: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 72428: 
 72428: #include "base/basictypes.h"
103251: #include "nsCanvasRenderingContext2DAzure.h"
 72428: 
 72428: #include "nsIDOMXULElement.h"
 72428: 
 72428: #include "prmem.h"
 72428: #include "prenv.h"
 72428: 
 72428: #include "nsIServiceManager.h"
 72428: #include "nsMathUtils.h"
 72428: 
 72428: #include "nsContentUtils.h"
 72428: 
 72428: #include "nsIDocument.h"
 72428: #include "nsHTMLCanvasElement.h"
 72428: #include "nsSVGEffects.h"
 72428: #include "nsPresContext.h"
 72428: #include "nsIPresShell.h"
 72428: #include "nsIVariant.h"
 72428: 
 72428: #include "nsIInterfaceRequestorUtils.h"
 72428: #include "nsIFrame.h"
108290: #include "nsError.h"
 72428: #include "nsIScriptError.h"
 72428: 
 72428: #include "nsCSSParser.h"
 72428: #include "mozilla/css/StyleRule.h"
 72428: #include "mozilla/css/Declaration.h"
 72428: #include "nsComputedDOMStyle.h"
 72428: #include "nsStyleSet.h"
 72428: 
 72428: #include "nsPrintfCString.h"
 72428: 
 72428: #include "nsReadableUtils.h"
 72428: 
 72428: #include "nsColor.h"
 72428: #include "nsGfxCIID.h"
 72428: #include "nsIScriptSecurityManager.h"
 72428: #include "nsIDocShell.h"
 72428: #include "nsIDOMWindow.h"
 72428: #include "nsPIDOMWindow.h"
 72428: #include "nsIDocShellTreeItem.h"
 72428: #include "nsIDocShellTreeNode.h"
 72428: #include "nsIXPConnect.h"
 72428: #include "nsDisplayList.h"
 72428: 
 72428: #include "nsTArray.h"
 72428: 
 72428: #include "imgIEncoder.h"
 72428: 
 72428: #include "gfxContext.h"
 72428: #include "gfxASurface.h"
 72428: #include "gfxImageSurface.h"
 72428: #include "gfxPlatform.h"
 72428: #include "gfxFont.h"
 72428: #include "gfxBlur.h"
 72428: #include "gfxUtils.h"
 72428: 
 72428: #include "nsFrameManager.h"
 72428: #include "nsFrameLoader.h"
 73724: #include "nsBidi.h"
 72428: #include "nsBidiPresUtils.h"
 72428: #include "Layers.h"
 72428: #include "CanvasUtils.h"
 72428: #include "nsIMemoryReporter.h"
 72428: #include "nsStyleUtil.h"
 72428: #include "CanvasImageCache.h"
 72428: 
 72428: #include <algorithm>
 93202: 
 93202: #include "jsapi.h"
 95834: #include "jsfriendapi.h"
 93202: 
 93202: #include "mozilla/Assertions.h"
 98543: #include "mozilla/CheckedInt.h"
 72428: #include "mozilla/dom/ContentParent.h"
 93202: #include "mozilla/dom/ImageData.h"
 72428: #include "mozilla/dom/PBrowserParent.h"
103359: #include "mozilla/dom/TypedArray.h"
 72428: #include "mozilla/gfx/2D.h"
 81282: #include "mozilla/gfx/PathHelpers.h"
 93202: #include "mozilla/ipc/DocumentRendererParent.h"
 93202: #include "mozilla/ipc/PDocumentRendererParent.h"
 82414: #include "mozilla/Preferences.h"
101129: #include "mozilla/unused.h"
102303: #include "nsCCUncollectableMarker.h"
102303: #include "nsWrapperCacheInlines.h"
103251: #include "nsJSUtils.h"
103251: #include "XPCQuickStubs.h"
103251: #include "mozilla/dom/BindingUtils.h"
103251: #include "nsHTMLImageElement.h"
103251: #include "nsHTMLVideoElement.h"
103330: #include "mozilla/dom/CanvasRenderingContext2DBinding.h"
 72428: 
 72428: #ifdef XP_WIN
 72428: #include "gfxWindowsPlatform.h"
 72428: #endif
 72428: 
 72428: // windows.h (included by chromium code) defines this, in its infinite wisdom
 72428: #undef DrawText
 72428: 
 72428: using namespace mozilla;
 72739: using namespace mozilla::CanvasUtils;
 72739: using namespace mozilla::css;
 72428: using namespace mozilla::dom;
 72428: using namespace mozilla::gfx;
 72428: using namespace mozilla::ipc;
 72739: using namespace mozilla::layers;
 72428: 
 72428: namespace mgfx = mozilla::gfx;
 72428: 
 72428: static float kDefaultFontSize = 10.0;
 72428: static NS_NAMED_LITERAL_STRING(kDefaultFontName, "sans-serif");
 72428: static NS_NAMED_LITERAL_STRING(kDefaultFontStyle, "10px sans-serif");
 72428: 
 72428: /* Memory reporter stuff */
106838: static nsIMemoryReporter *gCanvasAzureMemoryReporter = nullptr;
108991: static int64_t gCanvasAzureMemoryUsed = 0;
108991: 
108991: static int64_t GetCanvasAzureMemoryUsed() {
 72428:   return gCanvasAzureMemoryUsed;
 72428: }
 72428: 
 72640: // This is KIND_OTHER because it's not always clear where in memory the pixels
 72640: // of a canvas are stored.  Furthermore, this memory will be tracked by the
 72428: // underlying surface implementations.  See bug 655638 for details.
 72428: NS_MEMORY_REPORTER_IMPLEMENT(CanvasAzureMemory,
 72428:   "canvas-2d-pixel-bytes",
 72640:   KIND_OTHER,
 72640:   UNITS_BYTES,
 72640:   GetCanvasAzureMemoryUsed,
 72428:   "Memory used by 2D canvases. Each canvas requires (width * height * 4) "
 72640:   "bytes.")
 72428: 
 72428: class nsCanvasRadialGradientAzure : public nsCanvasGradientAzure
 72428: {
 72428: public:
 72428:   nsCanvasRadialGradientAzure(const Point &aBeginOrigin, Float aBeginRadius,
 72428:                               const Point &aEndOrigin, Float aEndRadius)
 72428:     : nsCanvasGradientAzure(RADIAL)
 73619:     , mCenter1(aBeginOrigin)
 73619:     , mCenter2(aEndOrigin)
 73619:     , mRadius1(aBeginRadius)
 73619:     , mRadius2(aEndRadius)
 72428:   {
 73619:   }
 73619: 
 73619:   Point mCenter1;
 73619:   Point mCenter2;
 73619:   Float mRadius1;
 73619:   Float mRadius2;
 72428: };
 72428: 
 72428: class nsCanvasLinearGradientAzure : public nsCanvasGradientAzure
 72428: {
 72428: public:
 72428:   nsCanvasLinearGradientAzure(const Point &aBegin, const Point &aEnd)
 72428:     : nsCanvasGradientAzure(LINEAR)
 72428:     , mBegin(aBegin)
 72428:     , mEnd(aEnd)
 72428:   {
 72428:   }
 72428: 
 72428: protected:
103252:   friend class CanvasGeneralPattern;
 72428: 
 72428:   // Beginning of linear gradient.
 72428:   Point mBegin;
 72428:   // End of linear gradient.
 72428:   Point mEnd;
 72428: };
 72428: 
103252: // This class is named 'GeneralCanvasPattern' instead of just
103252: // 'GeneralPattern' to keep Windows PGO builds from confusing the
103252: // GeneralPattern class in gfxContext.cpp with this one.
103252: 
103252: class CanvasGeneralPattern
 72428: {
 72428: public:
103251:   typedef nsCanvasRenderingContext2DAzure::Style Style;
103251:   typedef nsCanvasRenderingContext2DAzure::ContextState ContextState;
103251: 
106838:   CanvasGeneralPattern() : mPattern(nullptr) {}
103252:   ~CanvasGeneralPattern()
 72428:   {
 72428:     if (mPattern) {
 72428:       mPattern->~Pattern();
 72428:     }
 72428:   }
 72428: 
 72428:   Pattern& ForStyle(nsCanvasRenderingContext2DAzure *aCtx,
 72428:                     Style aStyle,
 72428:                     DrawTarget *aRT)
 72428:   {
 72428:     // This should only be called once or the mPattern destructor will
 72428:     // not be executed.
103252:     NS_ASSERTION(!mPattern, "ForStyle() should only be called once on CanvasGeneralPattern!");
 72428: 
103251:     const ContextState &state = aCtx->CurrentState();
 72428: 
 72428:     if (state.StyleIsColor(aStyle)) {
 72428:       mPattern = new (mColorPattern.addr()) ColorPattern(Color::FromABGR(state.colorStyles[aStyle]));
 72428:     } else if (state.gradientStyles[aStyle] &&
 72428:                state.gradientStyles[aStyle]->GetType() == nsCanvasGradientAzure::LINEAR) {
 72428:       nsCanvasLinearGradientAzure *gradient =
 72428:         static_cast<nsCanvasLinearGradientAzure*>(state.gradientStyles[aStyle].get());
 72428: 
 72428:       mPattern = new (mLinearGradientPattern.addr())
 72428:         LinearGradientPattern(gradient->mBegin, gradient->mEnd,
 72428:                               gradient->GetGradientStopsForTarget(aRT));
 72428:     } else if (state.gradientStyles[aStyle] &&
 72428:                state.gradientStyles[aStyle]->GetType() == nsCanvasGradientAzure::RADIAL) {
 72428:       nsCanvasRadialGradientAzure *gradient =
 72428:         static_cast<nsCanvasRadialGradientAzure*>(state.gradientStyles[aStyle].get());
 72428: 
 72428:       mPattern = new (mRadialGradientPattern.addr())
 73619:         RadialGradientPattern(gradient->mCenter1, gradient->mCenter2, gradient->mRadius1,
 73619:                               gradient->mRadius2, gradient->GetGradientStopsForTarget(aRT));
 72428:     } else if (state.patternStyles[aStyle]) {
 72428:       if (aCtx->mCanvasElement) {
101146:         CanvasUtils::DoDrawImageSecurityCheck(aCtx->mCanvasElement,
 72428:                                               state.patternStyles[aStyle]->mPrincipal,
 78159:                                               state.patternStyles[aStyle]->mForceWriteOnly,
 78159:                                               state.patternStyles[aStyle]->mCORSUsed);
 72428:       }
 72428: 
 72428:       ExtendMode mode;
 72428:       if (state.patternStyles[aStyle]->mRepeat == nsCanvasPatternAzure::NOREPEAT) {
 72428:         mode = EXTEND_CLAMP;
 72428:       } else {
 86250:         mode = EXTEND_REPEAT;
 72428:       }
 72428:       mPattern = new (mSurfacePattern.addr())
 72428:         SurfacePattern(state.patternStyles[aStyle]->mSurface, mode);
 72428:     }
 72428: 
 72428:     return *mPattern;
 72428:   }
 72428: 
 72428:   union {
 72428:     AlignedStorage2<ColorPattern> mColorPattern;
 72428:     AlignedStorage2<LinearGradientPattern> mLinearGradientPattern;
 72428:     AlignedStorage2<RadialGradientPattern> mRadialGradientPattern;
 72428:     AlignedStorage2<SurfacePattern> mSurfacePattern;
 72428:   };
 72428:   Pattern *mPattern;
 72428: };
 72428: 
 72428: /* This is an RAII based class that can be used as a drawtarget for
 72428:  * operations that need a shadow drawn. It will automatically provide a
 72428:  * temporary target when needed, and if so blend it back with a shadow.
 73777:  *
 73777:  * aBounds specifies the bounds of the drawing operation that will be
 73777:  * drawn to the target, it is given in device space! This function will
 73777:  * change aBounds to incorporate shadow bounds. If this is NULL the drawing
 73777:  * operation will be assumed to cover an infinite rect.
 72428:  */
 72428: class AdjustedTarget
 72428: {
 72428: public:
103251:   typedef nsCanvasRenderingContext2DAzure::ContextState ContextState;
103251: 
 72428:   AdjustedTarget(nsCanvasRenderingContext2DAzure *ctx,
106838:                  mgfx::Rect *aBounds = nullptr)
106838:     : mCtx(nullptr)
 72428:   {
 72428:     if (!ctx->NeedToDrawShadow()) {
 72428:       mTarget = ctx->mTarget;
 72428:       return;
 72428:     }
 72428:     mCtx = ctx;
 72428: 
 72428:     const ContextState &state = mCtx->CurrentState();
 72428: 
 72428:     mSigma = state.shadowBlur / 2.0f;
 72428: 
 72428:     if (mSigma > SIGMA_MAX) {
 72428:       mSigma = SIGMA_MAX;
 72428:     }
 72428:       
 72428:     Matrix transform = mCtx->mTarget->GetTransform();
 73777: 
 73777:     mTempRect = mgfx::Rect(0, 0, ctx->mWidth, ctx->mHeight);
 73777: 
110999:     static const gfxFloat GAUSSIAN_SCALE_FACTOR = (3 * sqrt(2 * M_PI) / 4) * 1.5;
110999:     int32_t blurRadius = (int32_t) floor(mSigma * GAUSSIAN_SCALE_FACTOR + 0.5);
 73777: 
 73777:     // We need to enlarge and possibly offset our temporary surface
 72428:     // so that things outside of the canvas may cast shadows.
 73777:     mTempRect.Inflate(Margin(blurRadius + NS_MAX<Float>(state.shadowOffset.x, 0),
 73777:                              blurRadius + NS_MAX<Float>(state.shadowOffset.y, 0),
 73777:                              blurRadius + NS_MAX<Float>(-state.shadowOffset.x, 0),
 73777:                              blurRadius + NS_MAX<Float>(-state.shadowOffset.y, 0)));
 73777: 
 73777:     if (aBounds) {
 73777:       // We actually include the bounds of the shadow blur, this makes it
 73777:       // easier to execute the actual blur on hardware, and shouldn't affect
 73777:       // the amount of pixels that need to be touched.
 73777:       aBounds->Inflate(Margin(blurRadius, blurRadius,
 73777:                               blurRadius, blurRadius));
 73777:       mTempRect = mTempRect.Intersect(*aBounds);
 73777:     }
 73777: 
 73777:     mTempRect.ScaleRoundOut(1.0f);
 73777: 
 73777:     transform._31 -= mTempRect.x;
 73777:     transform._32 -= mTempRect.y;
 72428:       
 72428:     mTarget =
110998:       mCtx->mTarget->CreateShadowDrawTarget(IntSize(int32_t(mTempRect.width), int32_t(mTempRect.height)),
111000:                                              FORMAT_B8G8R8A8, mSigma);
 72428: 
 72428:     if (!mTarget) {
 72428:       // XXX - Deal with the situation where our temp size is too big to
 72428:       // fit in a texture.
 72428:       mTarget = ctx->mTarget;
106838:       mCtx = nullptr;
 73777:     } else {
 73777:       mTarget->SetTransform(transform);
 72428:     }
 72428:   }
 72428: 
 72428:   ~AdjustedTarget()
 72428:   {
 72428:     if (!mCtx) {
 72428:       return;
 72428:     }
 72428: 
 72428:     RefPtr<SourceSurface> snapshot = mTarget->Snapshot();
 72428:     
 73777:     mCtx->mTarget->DrawSurfaceWithShadow(snapshot, mTempRect.TopLeft(),
 72428:                                          Color::FromABGR(mCtx->CurrentState().shadowColor),
 73032:                                          mCtx->CurrentState().shadowOffset, mSigma,
 73032:                                          mCtx->CurrentState().op);
 72428:   }
 72428: 
 72428:   DrawTarget* operator->()
 72428:   {
 72428:     return mTarget;
 72428:   }
 72428: 
 72428: private:
 72428:   RefPtr<DrawTarget> mTarget;
 72428:   nsCanvasRenderingContext2DAzure *mCtx;
 72428:   Float mSigma;
 73777:   mgfx::Rect mTempRect;
 72428: };
 72428: 
103251: NS_IMETHODIMP
103251: nsCanvasGradientAzure::AddColorStop(float offset, const nsAString& colorstr)
103251: {
103251:   if (!FloatValidate(offset) || offset < 0.0 || offset > 1.0) {
103251:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
103251:   }
103251: 
103251:   nsCSSValue value;
103251:   nsCSSParser parser;
106838:   if (!parser.ParseColorString(colorstr, nullptr, 0, value)) {
103251:     return NS_ERROR_DOM_SYNTAX_ERR;
103251:   }
103251: 
103251:   nscolor color;
106838:   if (!nsRuleNode::ComputeColor(value, nullptr, nullptr, color)) {
103251:     return NS_ERROR_DOM_SYNTAX_ERR;
103251:   }
103251: 
106838:   mStops = nullptr;
103251: 
103251:   GradientStop newStop;
103251: 
103251:   newStop.offset = offset;
103251:   newStop.color = Color::FromABGR(color);
103251: 
103251:   mRawStops.AppendElement(newStop);
103251: 
103251:   return NS_OK;
103251: }
103251: 
103251: NS_DEFINE_STATIC_IID_ACCESSOR(nsCanvasGradientAzure, NS_CANVASGRADIENTAZURE_PRIVATE_IID)
103251: 
103251: NS_IMPL_ADDREF(nsCanvasGradientAzure)
103251: NS_IMPL_RELEASE(nsCanvasGradientAzure)
103251: 
103251: // XXX
103251: // DOMCI_DATA(CanvasGradient, nsCanvasGradientAzure)
103251: 
103251: NS_INTERFACE_MAP_BEGIN(nsCanvasGradientAzure)
103251:   NS_INTERFACE_MAP_ENTRY(nsCanvasGradientAzure)
103251:   NS_INTERFACE_MAP_ENTRY(nsIDOMCanvasGradient)
103251:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CanvasGradient)
103251:   NS_INTERFACE_MAP_ENTRY(nsISupports)
103251: NS_INTERFACE_MAP_END
103251: 
103251: NS_DEFINE_STATIC_IID_ACCESSOR(nsCanvasPatternAzure, NS_CANVASPATTERNAZURE_PRIVATE_IID)
103251: 
103251: NS_IMPL_ADDREF(nsCanvasPatternAzure)
103251: NS_IMPL_RELEASE(nsCanvasPatternAzure)
103251: 
103251: // XXX
103251: // DOMCI_DATA(CanvasPattern, nsCanvasPatternAzure)
103251: 
103251: NS_INTERFACE_MAP_BEGIN(nsCanvasPatternAzure)
103251:   NS_INTERFACE_MAP_ENTRY(nsCanvasPatternAzure)
103251:   NS_INTERFACE_MAP_ENTRY(nsIDOMCanvasPattern)
103251:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CanvasPattern)
103251:   NS_INTERFACE_MAP_ENTRY(nsISupports)
103251: NS_INTERFACE_MAP_END
103251: 
103251: /**
103251:  ** nsTextMetricsAzure
103251:  **/
103251: #define NS_TEXTMETRICSAZURE_PRIVATE_IID \
103251:   {0x9793f9e7, 0x9dc1, 0x4e9c, {0x81, 0xc8, 0xfc, 0xa7, 0x14, 0xf4, 0x30, 0x79}}
103251: class nsTextMetricsAzure : public nsIDOMTextMetrics
103251: {
103251: public:
103251:   nsTextMetricsAzure(float w) : width(w) { }
103251: 
103251:   virtual ~nsTextMetricsAzure() { }
103251: 
103251:   NS_DECLARE_STATIC_IID_ACCESSOR(NS_TEXTMETRICSAZURE_PRIVATE_IID)
103251: 
103251:   NS_IMETHOD GetWidth(float* w) {
103251:     *w = width;
103251:     return NS_OK;
103251:   }
103251: 
103251:   NS_DECL_ISUPPORTS
103251: 
103251: private:
103251:   float width;
 72428: };
 72428: 
103251: NS_DEFINE_STATIC_IID_ACCESSOR(nsTextMetricsAzure, NS_TEXTMETRICSAZURE_PRIVATE_IID)
103251: 
103251: NS_IMPL_ADDREF(nsTextMetricsAzure)
103251: NS_IMPL_RELEASE(nsTextMetricsAzure)
103251: 
103251: // XXX
103251: // DOMCI_DATA(TextMetrics, nsTextMetricsAzure)
103251: 
103251: NS_INTERFACE_MAP_BEGIN(nsTextMetricsAzure)
103251:   NS_INTERFACE_MAP_ENTRY(nsTextMetricsAzure)
103251:   NS_INTERFACE_MAP_ENTRY(nsIDOMTextMetrics)
103251:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(TextMetrics)
103251:   NS_INTERFACE_MAP_ENTRY(nsISupports)
103251: NS_INTERFACE_MAP_END
103251: 
103251: // Cap sigma to avoid overly large temp surfaces.
103251: const Float SIGMA_MAX = 100;
103251: 
102689: class CanvasRenderingContext2DUserDataAzure : public LayerUserData {
102689: public:
102689:     CanvasRenderingContext2DUserDataAzure(nsCanvasRenderingContext2DAzure *aContext)
102689:     : mContext(aContext)
102689:   {
102689:     aContext->mUserDatas.AppendElement(this);
102689:   }
102689:   ~CanvasRenderingContext2DUserDataAzure()
102689:   {
102689:     if (mContext) {
102689:       mContext->mUserDatas.RemoveElement(this);
102689:     }
102689:   }
102689:   static void DidTransactionCallback(void* aData)
102689:   {
102689:       CanvasRenderingContext2DUserDataAzure* self =
102689:       static_cast<CanvasRenderingContext2DUserDataAzure*>(aData);
102689:     if (self->mContext) {
102689:       self->mContext->MarkContextClean();
102689:     }
102689:   }
102689:   bool IsForContext(nsCanvasRenderingContext2DAzure *aContext)
102689:   {
102689:     return mContext == aContext;
102689:   }
102689:   void Forget()
102689:   {
106838:     mContext = nullptr;
102689:   }
102689: 
102689: private:
102689:   nsCanvasRenderingContext2DAzure *mContext;
102689: };
102689: 
 72428: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsCanvasRenderingContext2DAzure)
 72428: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsCanvasRenderingContext2DAzure)
 72428: 
 72428: NS_IMPL_CYCLE_COLLECTION_CLASS(nsCanvasRenderingContext2DAzure)
 72428: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsCanvasRenderingContext2DAzure)
 72428:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mCanvasElement)
102303:   NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
 72428: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
102303: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(nsCanvasRenderingContext2DAzure)
102303:   NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
102303: NS_IMPL_CYCLE_COLLECTION_TRACE_END
 72428: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsCanvasRenderingContext2DAzure)
101146:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mCanvasElement, nsINode)
102303:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
 72428: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 72428: 
102303: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN(nsCanvasRenderingContext2DAzure)
102303:  if (nsCCUncollectableMarker::sGeneration && tmp->IsBlack()) {
102303:     nsGenericElement* canvasElement = tmp->mCanvasElement;
102303:     if (canvasElement) {
102303:       if (canvasElement->IsPurple()) {
102303:         canvasElement->RemovePurple();
102303:       }
102303:       nsGenericElement::MarkNodeChildren(canvasElement);
102303:     }
102303:     return true;
102303:   }
102303: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
102303: 
102303: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN(nsCanvasRenderingContext2DAzure)
102303:   return nsCCUncollectableMarker::sGeneration && tmp->IsBlack();
102303: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
102303: 
102303: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN(nsCanvasRenderingContext2DAzure)
102303:   return nsCCUncollectableMarker::sGeneration && tmp->IsBlack();
102303: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
102303: 
 72428: // XXX
 72428: // DOMCI_DATA(CanvasRenderingContext2D, nsCanvasRenderingContext2DAzure)
 72428: 
 72428: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsCanvasRenderingContext2DAzure)
102303:   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
 72428:   NS_INTERFACE_MAP_ENTRY(nsIDOMCanvasRenderingContext2D)
 72428:   NS_INTERFACE_MAP_ENTRY(nsICanvasRenderingContextInternal)
102303:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports,
102303:                                    nsICanvasRenderingContextInternal)
 72428:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CanvasRenderingContext2D)
 72428: NS_INTERFACE_MAP_END
 72428: 
 72428: /**
 72428:  ** CanvasRenderingContext2D impl
 72428:  **/
 72428: 
 72428: 
 72428: // Initialize our static variables.
108991: uint32_t nsCanvasRenderingContext2DAzure::sNumLivingContexts = 0;
108991: uint8_t (*nsCanvasRenderingContext2DAzure::sUnpremultiplyTable)[256] = nullptr;
108991: uint8_t (*nsCanvasRenderingContext2DAzure::sPremultiplyTable)[256] = nullptr;
 72428: 
103330: namespace mozilla {
103330: namespace dom {
103330: 
103330: bool
103330: AzureCanvasEnabled()
103330: {
107129:   return gfxPlatform::GetPlatform()->SupportsAzureCanvas();
103330: }
103330: 
103330: }
103330: }
103330: 
 72428: nsresult
 72428: NS_NewCanvasRenderingContext2DAzure(nsIDOMCanvasRenderingContext2D** aResult)
 72428: {
106615:   // XXX[nrc] remove this check when Thebes canvas is removed
106615:   // (because we will always support Azure)
106615:   if (!AzureCanvasEnabled()) {
 82173:     return NS_ERROR_NOT_AVAILABLE;
 82173:   }
 72428: 
 72428:   nsRefPtr<nsIDOMCanvasRenderingContext2D> ctx = new nsCanvasRenderingContext2DAzure();
 72428:   if (!ctx)
 72428:     return NS_ERROR_OUT_OF_MEMORY;
 72428: 
 72428:   *aResult = ctx.forget().get();
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: nsCanvasRenderingContext2DAzure::nsCanvasRenderingContext2DAzure()
111232:   : mValid(false), mZero(false), mOpaque(false), mResetLayer(true)
 80486:   , mIPC(false)
 80486:   , mIsEntireFrameInvalid(false)
 80486:   , mPredictManyRedrawCalls(false), mPathTransformWillUpdate(false)
 72428:   , mInvalidateCount(0)
 72428: {
 72428:   sNumLivingContexts++;
103330:   SetIsDOMBinding();
 72428: }
 72428: 
 72428: nsCanvasRenderingContext2DAzure::~nsCanvasRenderingContext2DAzure()
 72428: {
 72428:   Reset();
102689:   // Drop references from all CanvasRenderingContext2DUserDataAzure to this context
108991:   for (uint32_t i = 0; i < mUserDatas.Length(); ++i) {
102689:     mUserDatas[i]->Forget();
102689:   }
 72428:   sNumLivingContexts--;
 72428:   if (!sNumLivingContexts) {
 72428:     delete[] sUnpremultiplyTable;
 72428:     delete[] sPremultiplyTable;
106838:     sUnpremultiplyTable = nullptr;
106838:     sPremultiplyTable = nullptr;
 72428:   }
 72428: }
 72428: 
103330: JSObject*
103330: nsCanvasRenderingContext2DAzure::WrapObject(JSContext *cx, JSObject *scope,
103330:                                             bool *triedToWrap)
103330: {
103330:   return CanvasRenderingContext2DBinding::Wrap(cx, scope, this, triedToWrap);
103330: }
103330: 
101129: bool
101129: nsCanvasRenderingContext2DAzure::ParseColor(const nsAString& aString,
101129:                                             nscolor* aColor)
101129: {
101146:   nsIDocument* document = mCanvasElement
101146:                           ? mCanvasElement->OwnerDoc()
106838:                           : nullptr;
101129: 
101129:   // Pass the CSS Loader object to the parser, to allow parser error
101129:   // reports to include the outer window ID.
106838:   nsCSSParser parser(document ? document->CSSLoader() : nullptr);
101129:   nsCSSValue value;
106838:   if (!parser.ParseColorString(aString, nullptr, 0, value)) {
101129:     return false;
101129:   }
101129: 
101129:   nsIPresShell* presShell = GetPresShell();
101129:   nsRefPtr<nsStyleContext> parentContext;
101146:   if (mCanvasElement && mCanvasElement->IsInDoc()) {
101129:     // Inherit from the canvas element.
101129:     parentContext = nsComputedDOMStyle::GetStyleContextForElement(
106838:       mCanvasElement, nullptr, presShell);
101129:   }
101129: 
101129:   unused << nsRuleNode::ComputeColor(
106838:     value, presShell ? presShell->GetPresContext() : nullptr, parentContext,
101129:     *aColor);
101129:   return true;
101129: }
101129: 
 72428: nsresult
 72428: nsCanvasRenderingContext2DAzure::Reset()
 72428: {
 72428:   if (mCanvasElement) {
101146:     mCanvasElement->InvalidateCanvas();
 72428:   }
 72428: 
 72428:   // only do this for non-docshell created contexts,
 72428:   // since those are the ones that we created a surface for
111232:   if (mValid && !mDocShell) {
 72428:     gCanvasAzureMemoryUsed -= mWidth * mHeight * 4;
 72428:   }
 72428: 
106838:   mTarget = nullptr;
 72767: 
 72767:   // Since the target changes the backing texture will change, and this will
 72767:   // no longer be valid.
106838:   mThebesSurface = nullptr;
111232:   mValid = false;
 80486:   mIsEntireFrameInvalid = false;
 80486:   mPredictManyRedrawCalls = false;
 72767: 
 72428:   return NS_OK;
 72428: }
 72428: 
103251: static void
103251: WarnAboutUnexpectedStyle(nsHTMLCanvasElement* canvasElement)
103251: {
103251:   nsContentUtils::ReportToConsole(
103251:     nsIScriptError::warningFlag,
103251:     "Canvas",
106838:     canvasElement ? canvasElement->OwnerDoc() : nullptr,
103251:     nsContentUtils::eDOM_PROPERTIES,
103251:     "UnexpectedCanvasVariantStyle");
103251: }
103251: 
103251: void
103251: nsCanvasRenderingContext2DAzure::SetStyleFromString(const nsAString& str,
103251:                                                     Style whichStyle)
103251: {
103251:   MOZ_ASSERT(!str.IsVoid());
103251: 
103251:   nscolor color;
103251:   if (!ParseColor(str, &color)) {
103251:     return;
103251:   }
103251: 
103251:   CurrentState().SetColorStyle(whichStyle, color);
103251: }
103251: 
103251: void
 72428: nsCanvasRenderingContext2DAzure::SetStyleFromStringOrInterface(const nsAString& aStr,
 72428:                                                                nsISupports *aInterface,
 72428:                                                                Style aWhichStyle)
 72428: {
101129:   if (!aStr.IsVoid()) {
103251:     SetStyleFromString(aStr, aWhichStyle);
103251:     return;
 72428:   }
 72428: 
 72428:   if (aInterface) {
 72428:     nsCOMPtr<nsCanvasGradientAzure> grad(do_QueryInterface(aInterface));
 72428:     if (grad) {
103251:       SetStyleFromGradient(grad, aWhichStyle);
103251:       return;
 72428:     }
 72428: 
 72428:     nsCOMPtr<nsCanvasPatternAzure> pattern(do_QueryInterface(aInterface));
 72428:     if (pattern) {
103251:       SetStyleFromPattern(pattern, aWhichStyle);
103251:       return;
103251:     }
103251:   }
103251: 
103251:   WarnAboutUnexpectedStyle(mCanvasElement);
103251: }
103251: 
103251: nsISupports*
 72428: nsCanvasRenderingContext2DAzure::GetStyleAsStringOrInterface(nsAString& aStr,
103251:                                                              CanvasMultiGetterType& aType,
 72428:                                                              Style aWhichStyle)
 72428: {
 72428:   const ContextState &state = CurrentState();
103251:   nsISupports* supports;
 72428:   if (state.patternStyles[aWhichStyle]) {
 80486:     aStr.SetIsVoid(true);
103251:     supports = state.patternStyles[aWhichStyle];
103251:     aType = CMG_STYLE_PATTERN;
 72428:   } else if (state.gradientStyles[aWhichStyle]) {
 80486:     aStr.SetIsVoid(true);
103251:     supports = state.gradientStyles[aWhichStyle];
103251:     aType = CMG_STYLE_GRADIENT;
 72428:   } else {
 72428:     StyleColorToString(state.colorStyles[aWhichStyle], aStr);
106838:     supports = nullptr;
103251:     aType = CMG_STYLE_STRING;
103251:   }
103251:   return supports;
103251: }
103251: 
103251: // static
 72428: void
 72428: nsCanvasRenderingContext2DAzure::StyleColorToString(const nscolor& aColor, nsAString& aStr)
 72428: {
 72428:   // We can't reuse the normal CSS color stringification code,
 72428:   // because the spec calls for a different algorithm for canvas.
 72428:   if (NS_GET_A(aColor) == 255) {
 96873:     CopyUTF8toUTF16(nsPrintfCString("#%02x%02x%02x",
 72428:                                     NS_GET_R(aColor),
 72428:                                     NS_GET_G(aColor),
 72428:                                     NS_GET_B(aColor)),
 72428:                     aStr);
 72428:   } else {
 96873:     CopyUTF8toUTF16(nsPrintfCString("rgba(%d, %d, %d, ",
 72428:                                     NS_GET_R(aColor),
 72428:                                     NS_GET_G(aColor),
 72428:                                     NS_GET_B(aColor)),
 72428:                     aStr);
 72428:     aStr.AppendFloat(nsStyleUtil::ColorComponentToFloat(NS_GET_A(aColor)));
 72428:     aStr.Append(')');
 72428:   }
 72428: }
 72428: 
 72428: nsresult
 72428: nsCanvasRenderingContext2DAzure::Redraw()
 72428: {
 72428:   if (mIsEntireFrameInvalid) {
 72428:     return NS_OK;
 72428:   }
 72428: 
 80486:   mIsEntireFrameInvalid = true;
 72428: 
 72428:   if (!mCanvasElement) {
 72428:     NS_ASSERTION(mDocShell, "Redraw with no canvas element or docshell!");
 72428:     return NS_OK;
 72428:   }
 72428: 
 87516:   if (!mThebesSurface)
 87516:     mThebesSurface =
 87516:       gfxPlatform::GetPlatform()->GetThebesSurfaceForDrawTarget(mTarget);
 86770:   mThebesSurface->MarkDirty();
 86770: 
101146:   nsSVGEffects::InvalidateDirectRenderingObservers(mCanvasElement);
101146: 
106838:   mCanvasElement->InvalidateCanvasContent(nullptr);
 72428: 
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: void
 72428: nsCanvasRenderingContext2DAzure::Redraw(const mgfx::Rect &r)
 72428: {
 72428:   ++mInvalidateCount;
 72428: 
 72428:   if (mIsEntireFrameInvalid) {
 72428:     return;
 72428:   }
 72428: 
 72428:   if (mPredictManyRedrawCalls ||
 72428:     mInvalidateCount > kCanvasMaxInvalidateCount) {
 72428:     Redraw();
 72428:     return;
 72428:   }
 72428: 
 72428:   if (!mCanvasElement) {
 72428:     NS_ASSERTION(mDocShell, "Redraw with no canvas element or docshell!");
 72428:     return;
 72428:   }
 72428: 
 87516:   if (!mThebesSurface)
 87516:     mThebesSurface =
 87516:       gfxPlatform::GetPlatform()->GetThebesSurfaceForDrawTarget(mTarget);
 86770:   mThebesSurface->MarkDirty();
 86770: 
101146:   nsSVGEffects::InvalidateDirectRenderingObservers(mCanvasElement);
 72428: 
 86660:   gfxRect tmpR = ThebesRect(r);
101146:   mCanvasElement->InvalidateCanvasContent(&tmpR);
 72428: 
 72428:   return;
 72428: }
 72428: 
103251: void
 72428: nsCanvasRenderingContext2DAzure::RedrawUser(const gfxRect& r)
 72428: {
 72428:   if (mIsEntireFrameInvalid) {
 72428:     ++mInvalidateCount;
103251:     return;
 72428:   }
 72428: 
 72428:   mgfx::Rect newr =
 72428:     mTarget->GetTransform().TransformBounds(ToRect(r));
 72428:   Redraw(newr);
 72428: }
 72428: 
111232: NS_IMETHODIMP
111232: nsCanvasRenderingContext2DAzure::SetDimensions(int32_t width, int32_t height)
 72428: {
111232:   RefPtr<DrawTarget> target;
111232: 
111232:   // Zero sized surfaces cause issues, so just go with 1x1.
111232:   if (height == 0 || width == 0) {
111232:     mZero = true;
111232:     height = 1;
111232:     width = 1;
111232:   } else {
111232:     mZero = false;
 72428:   }
 72428: 
 72428:   // Check that the dimensions are sane
111232:   IntSize size(width, height);
 72428:   if (size.width <= 0xFFFF && size.height <= 0xFFFF &&
 72428:       size.width >= 0 && size.height >= 0) {
 72428:     SurfaceFormat format = GetSurfaceFormat();
106838:     nsIDocument* ownerDoc = nullptr;
102303:     if (mCanvasElement) {
102303:       ownerDoc = mCanvasElement->OwnerDoc();
 72428:     }
 72428: 
106838:     nsRefPtr<LayerManager> layerManager = nullptr;
 72428: 
 72428:     if (ownerDoc) {
 72428:       layerManager =
 72428:         nsContentUtils::PersistentLayerManagerForDocument(ownerDoc);
 72428:     }
 72428: 
 72428:     if (layerManager) {
111232:       target = layerManager->CreateDrawTarget(size, format);
 72428:     } else {
111232:       target = gfxPlatform::GetPlatform()->CreateOffscreenDrawTarget(size, format);
111232:     }
111232:   }
111232: 
111232:   if (target) {
106838:     if (gCanvasAzureMemoryReporter == nullptr) {
 72428:         gCanvasAzureMemoryReporter = new NS_MEMORY_REPORTER_NAME(CanvasAzureMemory);
 72428:       NS_RegisterMemoryReporter(gCanvasAzureMemoryReporter);
 72428:     }
 72428: 
111232:     gCanvasAzureMemoryUsed += width * height * 4;
 80870:     JSContext* context = nsContentUtils::GetCurrentJSContext();
 80870:     if (context) {
111232:       JS_updateMallocCounter(context, width * height * 4);
111232:     }
111232:   }
111232: 
111232:   return InitializeWithTarget(target, width, height);
111232: }
111232: 
111232: nsresult
111232: nsCanvasRenderingContext2DAzure::Initialize(int32_t width, int32_t height)
106611: {
106611:   mWidth = width;
106611:   mHeight = height;
111232: 
111232:   if (!mValid) {
111232:     // Create a dummy target in the hopes that it will help us deal with users
111232:     // calling into us after having changed the size where the size resulted
111232:     // in an inability to create a correct DrawTarget.
111232:     mTarget = gfxPlatform::GetPlatform()->CreateOffscreenDrawTarget(IntSize(1, 1), FORMAT_B8G8R8A8);
111232:   }
106611: 
106611:   mResetLayer = true;
106611: 
106611:   // set up the initial canvas defaults
106611:   mStyleStack.Clear();
106838:   mPathBuilder = nullptr;
106838:   mPath = nullptr;
106838:   mDSPathBuilder = nullptr;
106611: 
106611:   ContextState *state = mStyleStack.AppendElement();
106611:   state->globalAlpha = 1.0;
106611: 
106611:   state->colorStyles[STYLE_FILL] = NS_RGB(0,0,0);
106611:   state->colorStyles[STYLE_STROKE] = NS_RGB(0,0,0);
106611:   state->shadowColor = NS_RGBA(0,0,0,0);
111232: 
111232:   if (mTarget) {
111232:     mTarget->ClearRect(mgfx::Rect(Point(0, 0), Size(mWidth, mHeight)));
111232:     // always force a redraw, because if the surface dimensions were reset
111232:     // then the surface became cleared, and we need to redraw everything.
111232:     Redraw();
111232:   }
111232: 
111232:   return mValid ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
111232: }
111232: 
111232: nsresult
111232: nsCanvasRenderingContext2DAzure::InitializeWithTarget(DrawTarget *target, int32_t width, int32_t height)
111232: {
111232:   Reset();
111232: 
111232:   NS_ASSERTION(mCanvasElement, "Must have a canvas element!");
111232:   mDocShell = nullptr;
111232: 
111232:   // This first time this is called on this object is via
111232:   // nsHTMLCanvasElement::GetContext. If target was non-null then mTarget is
111232:   // non-null, otherwise we'll return an error here and GetContext won't
111232:   // return this context object and we'll never enter this code again.
111232:   // All other times this method is called, if target is null then
111232:   // mTarget won't be changed, i.e. it will remain non-null, or else it
111232:   // will be set to non-null.
111232:   // In all cases, any usable canvas context will have non-null mTarget.
111232: 
111232:   if (target) {
111232:     mValid = true;
111232:     mTarget = target;
111232:   } else {
111232:     mValid = false;
111232:   }
111232: 
111232:   return Initialize(width, height);
106611: }
106611: 
106611: NS_IMETHODIMP
108991: nsCanvasRenderingContext2DAzure::InitializeWithSurface(nsIDocShell *shell, gfxASurface *surface, int32_t width, int32_t height)
106611: {
106611:   mDocShell = shell;
106611:   mThebesSurface = surface;
106611: 
106611:   mTarget = gfxPlatform::GetPlatform()->CreateDrawTargetForSurface(surface, IntSize(width, height));
111232:   mValid = mTarget != nullptr;
111232: 
111232:   return Initialize(width, height);
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 79445: nsCanvasRenderingContext2DAzure::SetIsOpaque(bool isOpaque)
 72428: {
111232:   if (isOpaque == mOpaque)
111232:     return NS_OK;
111232: 
 72428:   mOpaque = isOpaque;
111232: 
111232:   if (mValid) {
111232:     /* If we've already been created, let SetDimensions take care of
111232:       * recreating our surface
111232:       */
111232:     return SetDimensions(mWidth, mHeight);
 72428:   }
 72428: 
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 79445: nsCanvasRenderingContext2DAzure::SetIsIPC(bool isIPC)
 72428: {
111232:   if (isIPC == mIPC)
111232:       return NS_OK;
111232: 
 72428:   mIPC = isIPC;
111232: 
111232:   if (mValid) {
111232:     /* If we've already been created, let SetDimensions take care of
111232:       * recreating our surface
111232:       */
111232:     return SetDimensions(mWidth, mHeight);
 72428:   }
 72428: 
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
108991: nsCanvasRenderingContext2DAzure::Render(gfxContext *ctx, gfxPattern::GraphicsFilter aFilter, uint32_t aFlags)
 72428: {
 72428:   nsresult rv = NS_OK;
 72428: 
111232:   if (!mValid || !mTarget) {
 72428:     return NS_ERROR_FAILURE;
 72428:   }
 72428: 
 72428:   nsRefPtr<gfxASurface> surface;
 72428:   
 72428:   if (NS_FAILED(GetThebesSurface(getter_AddRefs(surface)))) {
 72428:     return NS_ERROR_FAILURE;
 72428:   }
 72428: 
 72428:   nsRefPtr<gfxPattern> pat = new gfxPattern(surface);
 72428: 
 72428:   pat->SetFilter(aFilter);
 72428:   pat->SetExtend(gfxPattern::EXTEND_PAD);
 72428: 
 72428:   gfxContext::GraphicsOperator op = ctx->CurrentOperator();
 72428:   if (mOpaque)
 72428:       ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
 72428: 
 72428:   // XXX I don't want to use PixelSnapped here, but layout doesn't guarantee
 72428:   // pixel alignment for this stuff!
 72428:   ctx->NewPath();
 72428:   ctx->PixelSnappedRectangleAndSetPattern(gfxRect(0, 0, mWidth, mHeight), pat);
 72428:   ctx->Fill();
 72428: 
 72428:   if (mOpaque)
 72428:       ctx->SetOperator(op);
 72428: 
 93959:   if (!(aFlags & RenderFlagPremultAlpha)) {
 93959:       nsRefPtr<gfxASurface> curSurface = ctx->CurrentSurface();
 93959:       nsRefPtr<gfxImageSurface> gis = curSurface->GetAsImageSurface();
 93959:       NS_ABORT_IF_FALSE(gis, "If non-premult alpha, must be able to get image surface!");
 93959: 
 93959:       gfxUtils::UnpremultiplyImageSurface(gis);
 93959:   }
 93959: 
 72428:   return rv;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::GetInputStream(const char *aMimeType,
 72428:                                                 const PRUnichar *aEncoderOptions,
 72428:                                                 nsIInputStream **aStream)
 72428: {
111232:   if (!mValid || !mTarget) {
 72428:     return NS_ERROR_FAILURE;
 72428:   }
 72428: 
 72428:   nsRefPtr<gfxASurface> surface;
 72428: 
 72428:   if (NS_FAILED(GetThebesSurface(getter_AddRefs(surface)))) {
 72428:     return NS_ERROR_FAILURE;
 72428:   }
 72428: 
 72428:   nsresult rv;
 72428:   const char encoderPrefix[] = "@mozilla.org/image/encoder;2?type=";
 72428:   nsAutoArrayPtr<char> conid(new (std::nothrow) char[strlen(encoderPrefix) + strlen(aMimeType) + 1]);
 72428: 
 72428:   if (!conid) {
 72428:     return NS_ERROR_OUT_OF_MEMORY;
 72428:   }
 72428: 
 72428:   strcpy(conid, encoderPrefix);
 72428:   strcat(conid, aMimeType);
 72428: 
 72428:   nsCOMPtr<imgIEncoder> encoder = do_CreateInstance(conid);
 72428:   if (!encoder) {
 72428:     return NS_ERROR_FAILURE;
 72428:   }
 72428: 
108991:   nsAutoArrayPtr<uint8_t> imageBuffer(new (std::nothrow) uint8_t[mWidth * mHeight * 4]);
 72428:   if (!imageBuffer) {
 72428:     return NS_ERROR_OUT_OF_MEMORY;
 72428:   }
 72428: 
 72428:   nsRefPtr<gfxImageSurface> imgsurf =
 72428:     new gfxImageSurface(imageBuffer.get(),
 72428:                         gfxIntSize(mWidth, mHeight),
 72428:                         mWidth * 4,
 72428:                         gfxASurface::ImageFormatARGB32);
 72428: 
 72428:   if (!imgsurf || imgsurf->CairoStatus()) {
 72428:     return NS_ERROR_FAILURE;
 72428:   }
 72428: 
 72428:   nsRefPtr<gfxContext> ctx = new gfxContext(imgsurf);
 72428: 
 72428:   if (!ctx || ctx->HasError()) {
 72428:     return NS_ERROR_FAILURE;
 72428:   }
 72428: 
 72428:   ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
 72428:   ctx->SetSource(surface, gfxPoint(0, 0));
 72428:   ctx->Paint();
 72428: 
 72428:   rv = encoder->InitFromData(imageBuffer.get(),
 72428:                               mWidth * mHeight * 4, mWidth, mHeight, mWidth * 4,
 72428:                               imgIEncoder::INPUT_FORMAT_HOSTARGB,
 72428:                               nsDependentString(aEncoderOptions));
 72428:   NS_ENSURE_SUCCESS(rv, rv);
 72428: 
 72428:   return CallQueryInterface(encoder, aStream);
 72428: }
 72428: 
 72428: SurfaceFormat
 72428: nsCanvasRenderingContext2DAzure::GetSurfaceFormat() const
 72428: {
 72428:   return mOpaque ? FORMAT_B8G8R8X8 : FORMAT_B8G8R8A8;
 72428: }
 72428: 
 72428: //
 72428: // nsCanvasRenderingContext2DAzure impl
 72428: //
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::GetCanvas(nsIDOMHTMLCanvasElement **canvas)
 72428: {
111089:   if (mCanvasElement) {
111089:     NS_IF_ADDREF(*canvas = mCanvasElement->GetOriginalCanvas());
111089:   }
 72428: 
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: //
 72428: // state
 72428: //
 72428: 
103251: void
 72428: nsCanvasRenderingContext2DAzure::Save()
 72428: {
 72428:   mStyleStack[mStyleStack.Length() - 1].transform = mTarget->GetTransform();
 72428:   mStyleStack.SetCapacity(mStyleStack.Length() + 1);
 72428:   mStyleStack.AppendElement(CurrentState());
103251: }
103251: 
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::MozSave()
103251: {
103251:   Save();
103101:   return NS_OK;
103059: }
103059: 
103251: void
 72428: nsCanvasRenderingContext2DAzure::Restore()
 72428: {
 72428:   if (mStyleStack.Length() - 1 == 0)
103251:     return;
 72428: 
108991:   for (uint32_t i = 0; i < CurrentState().clipsPushed.size(); i++) {
 72428:     mTarget->PopClip();
 72428:   }
 72428: 
 72428:   mStyleStack.RemoveElementAt(mStyleStack.Length() - 1);
 72428: 
111232:   TransformWillUpdate();
111232: 
 72428:   mTarget->SetTransform(CurrentState().transform);
103251: }
103251: 
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::MozRestore()
103251: {
103251:   Restore();
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: //
 72428: // transformations
 72428: //
 72428: 
103251: void
103251: nsCanvasRenderingContext2DAzure::Scale(double x, double y, ErrorResult& error)
103251: {
111232:   if (!mTarget) {
111232:     error.Throw(NS_ERROR_FAILURE);
111232:     return;
111232:   }
111232: 
111214:   if (!FloatValidate(x,y)) {
111214:     return;
111214:   }
111214: 
111214:   TransformWillUpdate();
103251: 
103251:   Matrix newMatrix = mTarget->GetTransform();
103251:   mTarget->SetTransform(newMatrix.Scale(x, y));
103251: }
103251: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::Scale(float x, float y)
 72428: {
103251:   ErrorResult rv;
103251:   Scale((double)x, (double)y, rv);
103251:   return rv.ErrorCode();
103251: }
103251: 
103251: void
103251: nsCanvasRenderingContext2DAzure::Rotate(double angle, ErrorResult& error)
103251: {
111232:   if (!mTarget) {
111232:     error.Throw(NS_ERROR_FAILURE);
111232:     return;
111232:   }
111232: 
111214:   if (!FloatValidate(angle)) {
111214:     return;
111214:   }
111214: 
111214:   TransformWillUpdate();
 72428: 
103251:   Matrix rotation = Matrix::Rotation(angle);
103251:   mTarget->SetTransform(rotation * mTarget->GetTransform());
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::Rotate(float angle)
 72428: {
103251:   ErrorResult rv;
103251:   Rotate((double)angle, rv);
103251:   return rv.ErrorCode();
103251: }
103251: 
103251: void
103251: nsCanvasRenderingContext2DAzure::Translate(double x, double y, ErrorResult& error)
103251: {
111232:   if (!mTarget) {
111232:     error.Throw(NS_ERROR_FAILURE);
111232:     return;
111232:   }
111232: 
111214:   if (!FloatValidate(x,y)) {
111214:     return;
111214:   }
111214: 
111214:   TransformWillUpdate();
103251: 
103251:   Matrix newMatrix = mTarget->GetTransform();
103251:   mTarget->SetTransform(newMatrix.Translate(x, y));
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::Translate(float x, float y)
 72428: {
103251:   ErrorResult rv;
103251:   Translate((double)x, (double)y, rv);
103251:   return rv.ErrorCode();
103251: }
103251: 
103251: void
103251: nsCanvasRenderingContext2DAzure::Transform(double m11, double m12, double m21,
103251:                                            double m22, double dx, double dy,
103251:                                            ErrorResult& error)
103251: {
111232:   if (!mTarget) {
111232:     error.Throw(NS_ERROR_FAILURE);
111232:     return;
111232:   }
111232: 
111214:   if (!FloatValidate(m11,m12,m21,m22,dx,dy)) {
111214:     return;
111214:   }
111214: 
111214:   TransformWillUpdate();
103251: 
103251:   Matrix matrix(m11, m12, m21, m22, dx, dy);
103251:   mTarget->SetTransform(matrix * mTarget->GetTransform());
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::Transform(float m11, float m12, float m21, float m22, float dx, float dy)
 72428: {
103251:   ErrorResult rv;
103251:   Transform((double)m11, (double)m12, (double)m21, (double)m22, (double)dx,
103251:             (double)dy, rv);
103251:   return rv.ErrorCode();
103251: }
103251: 
103251: void
103251: nsCanvasRenderingContext2DAzure::SetTransform(double m11, double m12,
103251:                                               double m21, double m22,
103251:                                               double dx, double dy,
103251:                                               ErrorResult& error)
103251: {
111232:   if (!mTarget) {
111232:     error.Throw(NS_ERROR_FAILURE);
111232:     return;
111232:   }
111232: 
111214:   if (!FloatValidate(m11,m12,m21,m22,dx,dy)) {
111214:     return;
111214:   }
111214: 
111214:   TransformWillUpdate();
103251: 
 72428:   Matrix matrix(m11, m12, m21, m22, dx, dy);
103251:   mTarget->SetTransform(matrix);
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::SetTransform(float m11, float m12, float m21, float m22, float dx, float dy)
 72428: {
103251:   ErrorResult rv;
103251:   SetTransform((double)m11, (double)m12, (double)m21, (double)m22, (double)dx,
103251:                (double)dy, rv);
103251:   return rv.ErrorCode();
103251: }
103251: 
103251: JSObject*
103251: MatrixToJSObject(JSContext* cx, const Matrix& matrix, ErrorResult& error)
103251: {
103251:   jsval elts[] = {
103251:       DOUBLE_TO_JSVAL(matrix._11), DOUBLE_TO_JSVAL(matrix._12),
103251:       DOUBLE_TO_JSVAL(matrix._21), DOUBLE_TO_JSVAL(matrix._22),
103251:       DOUBLE_TO_JSVAL(matrix._31), DOUBLE_TO_JSVAL(matrix._32)
103251:   };
103251: 
103251:   // XXX Should we enter GetWrapper()'s compartment?
103251:   JSObject* obj = JS_NewArrayObject(cx, 6, elts);
103251:   if  (!obj) {
103251:       error.Throw(NS_ERROR_OUT_OF_MEMORY);
103251:   }
103251:   return obj;
103251: }
103251: 
103251: bool
103251: ObjectToMatrix(JSContext* cx, JSObject& obj, Matrix& matrix, ErrorResult& error)
103251: {
103251:   uint32_t length;
103251:   if (!JS_GetArrayLength(cx, &obj, &length) || length != 6) {
103251:     // Not an array-like thing or wrong size
103251:     error.Throw(NS_ERROR_INVALID_ARG);
103251:     return false;
103251:   }
103251: 
103251:   Float* elts[] = { &matrix._11, &matrix._12, &matrix._21, &matrix._22,
103251:                     &matrix._31, &matrix._32 };
108991:   for (uint32_t i = 0; i < 6; ++i) {
103251:     jsval elt;
103251:     double d;
103251:     if (!JS_GetElement(cx, &obj, i, &elt)) {
103251:       error.Throw(NS_ERROR_FAILURE);
103251:       return false;
103251:     }
103251:     if (!CoerceDouble(elt, &d)) {
103251:       error.Throw(NS_ERROR_INVALID_ARG);
103251:       return false;
103251:     }
103251:     if (!FloatValidate(d)) {
103251:       // This is weird, but it's the behavior of SetTransform()
103251:       return false;
103251:     }
103251:     *elts[i] = Float(d);
103251:   }
103251:   return true;
103251: }
103251: 
103251: void
103251: nsCanvasRenderingContext2DAzure::SetMozCurrentTransform(JSContext* cx,
103251:                                                         JSObject& currentTransform,
103251:                                                         ErrorResult& error)
103251: {
111232:   if (!mTarget) {
103251:     error.Throw(NS_ERROR_FAILURE);
103251:     return;
103251:   }
103251: 
103251:   Matrix newCTM;
103251:   if (ObjectToMatrix(cx, currentTransform, newCTM, error)) {
103251:     mTarget->SetTransform(newCTM);
103251:   }
 72428: }
 72428: 
 72739: NS_IMETHODIMP
 72739: nsCanvasRenderingContext2DAzure::SetMozCurrentTransform(JSContext* cx,
 72739:                                                         const jsval& matrix)
 72739: {
103251:   if (!matrix.isObject()) {
103251:     return NS_ERROR_INVALID_ARG;
103251:   }
103251: 
103251:   ErrorResult rv;
103251:   SetMozCurrentTransform(cx, matrix.toObject(), rv);
103251:   return rv.ErrorCode();
103251: }
103251: 
103251: JSObject*
103251: nsCanvasRenderingContext2DAzure::GetMozCurrentTransform(JSContext* cx,
103251:                                                         ErrorResult& error) const
103251: {
111232:   if (!mTarget) {
111232:     error.Throw(NS_ERROR_FAILURE);
111232:     return NULL;
111232:   }
111232: 
111232:   return MatrixToJSObject(cx, mTarget->GetTransform(), error);
 72739: }
 72739: 
 72739: NS_IMETHODIMP
 72739: nsCanvasRenderingContext2DAzure::GetMozCurrentTransform(JSContext* cx,
 72739:                                                         jsval* matrix)
 72739: {
103251:   ErrorResult rv;
103251:   JSObject* obj = GetMozCurrentTransform(cx, rv);
103251:   if (!rv.Failed()) {
103251:     *matrix = OBJECT_TO_JSVAL(obj);
103251:   }
103251:   return rv.ErrorCode();
103251: }
103251: 
103251: void
103251: nsCanvasRenderingContext2DAzure::SetMozCurrentTransformInverse(JSContext* cx,
103251:                                                                JSObject& currentTransform,
103251:                                                                ErrorResult& error)
103251: {
111232:   if (!mTarget) {
103251:     error.Throw(NS_ERROR_FAILURE);
103251:     return;
103251:   }
103251: 
103251:   Matrix newCTMInverse;
103251:   if (ObjectToMatrix(cx, currentTransform, newCTMInverse, error)) {
103251:     // XXX ERRMSG we need to report an error to developers here! (bug 329026)
103251:     if (newCTMInverse.Invert()) {
103251:       mTarget->SetTransform(newCTMInverse);
103251:     }
103251:   }
 72739: }
 72739: 
 72739: NS_IMETHODIMP
 72739: nsCanvasRenderingContext2DAzure::SetMozCurrentTransformInverse(JSContext* cx,
 72739:                                                                const jsval& matrix)
 72739: {
103251:   if (!matrix.isObject()) {
103251:     return NS_ERROR_INVALID_ARG;
103251:   }
103251: 
103251:   ErrorResult rv;
103251:   SetMozCurrentTransformInverse(cx, matrix.toObject(), rv);
103251:   return rv.ErrorCode();
103251: }
103251: 
103251: JSObject*
103251: nsCanvasRenderingContext2DAzure::GetMozCurrentTransformInverse(JSContext* cx,
103251:                                                                ErrorResult& error) const
103251: {
101785:   if (!mTarget) {
111232:     error.Throw(NS_ERROR_FAILURE);
111232:     return NULL;
103251:   }
103251: 
103251:   Matrix ctm = mTarget->GetTransform();
103251: 
103251:   if (!ctm.Invert()) {
103251:     double NaN = JSVAL_TO_DOUBLE(JS_GetNaNValue(cx));
103251:     ctm = Matrix(NaN, NaN, NaN, NaN, NaN, NaN);
103251:   }
103251: 
103251:   return MatrixToJSObject(cx, ctm, error);
 72739: }
 72739: 
 72739: NS_IMETHODIMP
 72739: nsCanvasRenderingContext2DAzure::GetMozCurrentTransformInverse(JSContext* cx,
 72739:                                                                jsval* matrix)
 72739: {
103251:   ErrorResult rv;
103251:   JSObject* obj = GetMozCurrentTransformInverse(cx, rv);
103251:   if (!rv.Failed()) {
103251:     *matrix = OBJECT_TO_JSVAL(obj);
103251:   }
103251:   return rv.ErrorCode();
 72739: }
 72739: 
 72428: //
 72428: // colors
 72428: //
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::SetGlobalAlpha(float aGlobalAlpha)
 72428: {
103251:   SetGlobalAlpha((double)aGlobalAlpha);
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::GetGlobalAlpha(float *aGlobalAlpha)
 72428: {
103251:   *aGlobalAlpha = GetGlobalAlpha();
 72428:   return NS_OK;
 72428: }
 72428: 
103251: void
103251: nsCanvasRenderingContext2DAzure::SetStyleFromJSValue(JSContext* cx,
103251:                                                      JS::Value& value,
103251:                                                      Style whichStyle)
103251: {
103251:   if (value.isString()) {
103251:     nsDependentJSString strokeStyle;
103251:     if (strokeStyle.init(cx, value.toString())) {
103251:       SetStyleFromString(strokeStyle, whichStyle);
103251:     }
103251:     return;
103251:   }
103251: 
103251:   if (value.isObject()) {
103251:     nsCOMPtr<nsISupports> holder;
103251: 
103251:     nsCanvasGradientAzure* gradient;
103251:     nsresult rv = xpc_qsUnwrapArg<nsCanvasGradientAzure>(cx, value, &gradient,
103251:                                                          static_cast<nsISupports**>(getter_AddRefs(holder)),
103251:                                                          &value);
103251:     if (NS_SUCCEEDED(rv)) {
103251:       SetStyleFromGradient(gradient, whichStyle);
103251:       return;
103251:     }
103251: 
103251:     nsCanvasPatternAzure* pattern;
103251:     rv = xpc_qsUnwrapArg<nsCanvasPatternAzure>(cx, value, &pattern,
103251:                                                static_cast<nsISupports**>(getter_AddRefs(holder)),
103251:                                                &value);
103251:     if (NS_SUCCEEDED(rv)) {
103251:       SetStyleFromPattern(pattern, whichStyle);
103251:       return;
103251:     }
103251:   }
103251: 
103251:   WarnAboutUnexpectedStyle(mCanvasElement);
103251: }
103251: 
103251: static JS::Value
103251: WrapStyle(JSContext* cx, JSObject* obj,
103251:           nsIDOMCanvasRenderingContext2D::CanvasMultiGetterType type,
103251:           nsAString& str, nsISupports* supports, ErrorResult& error)
103251: {
103251:   JS::Value v;
103251:   bool ok;
103251:   switch (type) {
103251:     case nsIDOMCanvasRenderingContext2D::CMG_STYLE_STRING:
103251:     {
103251:       ok = xpc::StringToJsval(cx, str, &v);
103251:       break;
103251:     }
103251:     case nsIDOMCanvasRenderingContext2D::CMG_STYLE_PATTERN:
103251:     case nsIDOMCanvasRenderingContext2D::CMG_STYLE_GRADIENT:
103251:     {
103251:       ok = dom::WrapObject(cx, obj, supports, &v);
103251:       break;
103251:     }
103359:     default:
103359:       MOZ_NOT_REACHED("unexpected CanvasMultiGetterType");
103251:   }
103251:   if (!ok) {
103251:     error.Throw(NS_ERROR_FAILURE);
103251:   }
103251:   return v;
103251: }
103251: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::SetStrokeStyle(nsIVariant *aValue)
 72428: {
 72428:   if (!aValue)
 72428:       return NS_ERROR_FAILURE;
 72428: 
 72428:   nsString str;
 72428: 
 72428:   nsresult rv;
108991:   uint16_t vtype;
 72428:   rv = aValue->GetDataType(&vtype);
 72428:   NS_ENSURE_SUCCESS(rv, rv);
 72428: 
 72428:   if (vtype == nsIDataType::VTYPE_INTERFACE ||
 72428:       vtype == nsIDataType::VTYPE_INTERFACE_IS)
 72428:   {
 72428:     nsIID *iid;
 72428:     nsCOMPtr<nsISupports> sup;
 72428:     rv = aValue->GetAsInterface(&iid, getter_AddRefs(sup));
 72428:     NS_ENSURE_SUCCESS(rv, rv);
 72428:     if (iid) {
 72428:       NS_Free(iid);
 72428:     }
 72428: 
 80486:     str.SetIsVoid(true);
 72428:     return SetStrokeStyle_multi(str, sup);
 72428:   }
 72428: 
 72428:   rv = aValue->GetAsAString(str);
 72428:   NS_ENSURE_SUCCESS(rv, rv);
 72428: 
106838:   return SetStrokeStyle_multi(str, nullptr);
 72428: }
 72428: 
103251: JS::Value
103251: nsCanvasRenderingContext2DAzure::GetStrokeStyle(JSContext* cx,
103251:                                                 ErrorResult& error)
103251: {
103251:   nsString str;
103251:   CanvasMultiGetterType t;
103251:   nsISupports* supports = GetStyleAsStringOrInterface(str, t, STYLE_STROKE);
103251:   return WrapStyle(cx, GetWrapper(), t, str, supports, error);
103251: }
103251: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::GetStrokeStyle(nsIVariant **aResult)
 72428: {
 72428:   nsCOMPtr<nsIWritableVariant> wv = do_CreateInstance(NS_VARIANT_CONTRACTID);
 72428: 
 72428:   nsCOMPtr<nsISupports> sup;
 72428:   nsString str;
108991:   int32_t t;
 72428:   nsresult rv = GetStrokeStyle_multi(str, getter_AddRefs(sup), &t);
 72428:   NS_ENSURE_SUCCESS(rv, rv);
 72428: 
 72428:   if (t == CMG_STYLE_STRING) {
 72428:     rv = wv->SetAsAString(str);
 72428:   } else if (t == CMG_STYLE_PATTERN) {
 72428:     rv = wv->SetAsInterface(NS_GET_IID(nsIDOMCanvasPattern),
 72428:                             sup);
 72428:   } else if (t == CMG_STYLE_GRADIENT) {
 72428:     rv = wv->SetAsInterface(NS_GET_IID(nsIDOMCanvasGradient),
 72428:                             sup);
 72428:   } else {
 72428:     NS_ERROR("Unknown type from GetStroke/FillStyle_multi!");
 72428:     return NS_ERROR_FAILURE;
 72428:   }
 72428:   NS_ENSURE_SUCCESS(rv, rv);
 72428: 
 72428:   NS_IF_ADDREF(*aResult = wv.get());
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::SetFillStyle(nsIVariant *aValue)
 72428: {
 72428:   if (!aValue) {
 72428:     return NS_ERROR_FAILURE;
 72428:   }
 72428: 
 72428:   nsString str;
 72428:   nsresult rv;
108991:   uint16_t vtype;
 72428:   rv = aValue->GetDataType(&vtype);
 72428:   NS_ENSURE_SUCCESS(rv, rv);
 72428: 
 72428:   if (vtype == nsIDataType::VTYPE_INTERFACE ||
 72428:       vtype == nsIDataType::VTYPE_INTERFACE_IS)
 72428:   {
 72428:     nsIID *iid;
 72428:     nsCOMPtr<nsISupports> sup;
 72428:     rv = aValue->GetAsInterface(&iid, getter_AddRefs(sup));
 72428:     NS_ENSURE_SUCCESS(rv, rv);
 72428: 
 80486:     str.SetIsVoid(true);
 72428:     return SetFillStyle_multi(str, sup);
 72428:   }
 72428: 
 72428:   rv = aValue->GetAsAString(str);
 72428:   NS_ENSURE_SUCCESS(rv, rv);
 72428: 
106838:   return SetFillStyle_multi(str, nullptr);
 72428: }
 72428: 
103251: JS::Value
103251: nsCanvasRenderingContext2DAzure::GetFillStyle(JSContext* cx,
103251:                                               ErrorResult& error)
103251: {
103251:   nsString str;
103251:   CanvasMultiGetterType t;
103251:   nsISupports* supports = GetStyleAsStringOrInterface(str, t, STYLE_FILL);
103251:   return WrapStyle(cx, GetWrapper(), t, str, supports, error);
103251: }
103251: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::GetFillStyle(nsIVariant **aResult)
 72428: {
 72428:   nsCOMPtr<nsIWritableVariant> wv = do_CreateInstance(NS_VARIANT_CONTRACTID);
 72428: 
 72428:   nsCOMPtr<nsISupports> sup;
 72428:   nsString str;
108991:   int32_t t;
 72428:   nsresult rv = GetFillStyle_multi(str, getter_AddRefs(sup), &t);
 72428:   NS_ENSURE_SUCCESS(rv, rv);
 72428: 
 72428:   if (t == CMG_STYLE_STRING) {
 72428:     rv = wv->SetAsAString(str);
 72428:   } else if (t == CMG_STYLE_PATTERN) {
 72428:     rv = wv->SetAsInterface(NS_GET_IID(nsIDOMCanvasPattern),
 72428:                             sup);
 72428:   } else if (t == CMG_STYLE_GRADIENT) {
 72428:     rv = wv->SetAsInterface(NS_GET_IID(nsIDOMCanvasGradient),
 72428:                             sup);
 72428:   } else {
 72428:     NS_ERROR("Unknown type from GetStroke/FillStyle_multi!");
 72428:     return NS_ERROR_FAILURE;
 72428:   }
 72428:   NS_ENSURE_SUCCESS(rv, rv);
 72428: 
 72428:   NS_IF_ADDREF(*aResult = wv.get());
 72428:   return NS_OK;
 72428: }
 72428: 
103251: void
103251: nsCanvasRenderingContext2DAzure::SetFillRule(const nsAString& aString)
 72428: {
 72428:   FillRule rule;
 72428: 
 72428:   if (aString.EqualsLiteral("evenodd"))
 72428:     rule = FILL_EVEN_ODD;
 72428:   else if (aString.EqualsLiteral("nonzero"))
 72428:     rule = FILL_WINDING;
 72428:   else
103251:     return;
103251: 
103251:   CurrentState().fillRule = rule;
103251: }
103251: 
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::SetMozFillRule(const nsAString& aString)
103251: {
103251:   SetFillRule(aString);
103101:   return NS_OK;
103251: }
103251: 
103251: void
103251: nsCanvasRenderingContext2DAzure::GetFillRule(nsAString& aString)
 72428: {
 72428:     switch (CurrentState().fillRule) {
 72428:     case FILL_WINDING:
 72428:         aString.AssignLiteral("nonzero"); break;
 72428:     case FILL_EVEN_ODD:
 72428:         aString.AssignLiteral("evenodd"); break;
 72428:     }
103251: }
103251: 
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::GetMozFillRule(nsAString& aString)
103251: {
103251:   GetFillRule(aString);
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::SetStrokeStyle_multi(const nsAString& aStr, nsISupports *aInterface)
 72428: {
103251:   SetStyleFromStringOrInterface(aStr, aInterface, STYLE_STROKE);
103251:   return NS_OK;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
108991: nsCanvasRenderingContext2DAzure::GetStrokeStyle_multi(nsAString& aStr, nsISupports **aInterface, int32_t *aType)
 72428: {
103251:   CanvasMultiGetterType type;
103251:   NS_IF_ADDREF(*aInterface = GetStyleAsStringOrInterface(aStr, type, STYLE_STROKE));
103251:   *aType = type;
103251:   return NS_OK;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::SetFillStyle_multi(const nsAString& aStr, nsISupports *aInterface)
 72428: {
103251:   SetStyleFromStringOrInterface(aStr, aInterface, STYLE_FILL);
103251:   return NS_OK;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
108991: nsCanvasRenderingContext2DAzure::GetFillStyle_multi(nsAString& aStr, nsISupports **aInterface, int32_t *aType)
 72428: {
103251:   CanvasMultiGetterType type;
103251:   NS_IF_ADDREF(*aInterface = GetStyleAsStringOrInterface(aStr, type, STYLE_FILL));
103251:   *aType = type;
103251:   return NS_OK;
 72428: }
 72428: 
 72428: //
 72428: // gradients and patterns
 72428: //
103251: already_AddRefed<nsIDOMCanvasGradient>
103251: nsCanvasRenderingContext2DAzure::CreateLinearGradient(double x0, double y0, double x1, double y1,
103251:                                                       ErrorResult& aError)
103251: {
103251:   if (!FloatValidate(x0,y0,x1,y1)) {
103251:     aError.Throw(NS_ERROR_DOM_NOT_SUPPORTED_ERR);
106838:     return nullptr;
103251:   }
103251: 
103251:   nsRefPtr<nsIDOMCanvasGradient> grad =
103251:     new nsCanvasLinearGradientAzure(Point(x0, y0), Point(x1, y1));
103251: 
103251:   return grad.forget();
103251: }
103251: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::CreateLinearGradient(float x0, float y0, float x1, float y1,
 72428:                                                       nsIDOMCanvasGradient **_retval)
 72428: {
103251:   ErrorResult rv;
103251:   *_retval = CreateLinearGradient(x0, y0, x1, y1, rv).get();
103251:   return rv.ErrorCode();
103251: }
103251: 
103251: already_AddRefed<nsIDOMCanvasGradient>
103251: nsCanvasRenderingContext2DAzure::CreateRadialGradient(double x0, double y0, double r0,
103251:                                                       double x1, double y1, double r1,
103251:                                                       ErrorResult& aError)
103251: {
103251:   if (!FloatValidate(x0,y0,r0,x1,y1,r1)) {
103251:     aError.Throw(NS_ERROR_DOM_NOT_SUPPORTED_ERR);
106838:     return nullptr;
103251:   }
103251: 
103251:   if (r0 < 0.0 || r1 < 0.0) {
103251:     aError.Throw(NS_ERROR_DOM_INDEX_SIZE_ERR);
106838:     return nullptr;
 72428:   }
 72428: 
 72428:   nsRefPtr<nsIDOMCanvasGradient> grad =
103251:     new nsCanvasRadialGradientAzure(Point(x0, y0), r0, Point(x1, y1), r1);
103251: 
103251:   return grad.forget();
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::CreateRadialGradient(float x0, float y0, float r0,
 72428:                                                       float x1, float y1, float r1,
 72428:                                                       nsIDOMCanvasGradient **_retval)
 72428: {
103251:   ErrorResult rv;
103251:   *_retval = CreateRadialGradient(x0, y0, r0, x1, y1, r1, rv).get();
103251:   return rv.ErrorCode();
103251: }
103251: 
103251: already_AddRefed<nsIDOMCanvasPattern>
103251: nsCanvasRenderingContext2DAzure::CreatePattern(const HTMLImageOrCanvasOrVideoElement& element,
 72428:                                                const nsAString& repeat,
103251:                                                ErrorResult& error)
 72428: {
 72428:   nsCanvasPatternAzure::RepeatMode repeatMode =
 72428:     nsCanvasPatternAzure::NOREPEAT;
 72428: 
 72428:   if (repeat.IsEmpty() || repeat.EqualsLiteral("repeat")) {
 72428:     repeatMode = nsCanvasPatternAzure::REPEAT;
 72428:   } else if (repeat.EqualsLiteral("repeat-x")) {
 72428:     repeatMode = nsCanvasPatternAzure::REPEATX;
 72428:   } else if (repeat.EqualsLiteral("repeat-y")) {
 72428:     repeatMode = nsCanvasPatternAzure::REPEATY;
 72428:   } else if (repeat.EqualsLiteral("no-repeat")) {
 72428:     repeatMode = nsCanvasPatternAzure::NOREPEAT;
 72428:   } else {
103251:     error.Throw(NS_ERROR_DOM_SYNTAX_ERR);
103251:     return NULL;
103251:   }
103251: 
103251:   Element* htmlElement;
103251:   if (element.IsHTMLCanvasElement()) {
103251:     nsHTMLCanvasElement* canvas = element.GetAsHTMLCanvasElement();
103251:     htmlElement = canvas;
103251: 
 72428:     nsIntSize size = canvas->GetSize();
 72428:     if (size.width == 0 || size.height == 0) {
103251:       error.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
103251:       return NULL;
 72428:     }
 72428: 
 72428:     // Special case for Canvas, which could be an Azure canvas!
 72428:     nsICanvasRenderingContextInternal *srcCanvas = canvas->GetContextAtIndex(0);
 84360:     if (srcCanvas) {
 72428:       // This might not be an Azure canvas!
 72428:       RefPtr<SourceSurface> srcSurf = srcCanvas->GetSurfaceSnapshot();
 72428: 
 72428:       nsRefPtr<nsCanvasPatternAzure> pat =
103251:         new nsCanvasPatternAzure(srcSurf, repeatMode, htmlElement->NodePrincipal(), canvas->IsWriteOnly(), false);
103251: 
103251:       return pat.forget();
103251:     }
103251:   } else if (element.IsHTMLImageElement()) {
103251:     htmlElement = element.GetAsHTMLImageElement();
103251:   } else {
103251:     htmlElement = element.GetAsHTMLVideoElement();
 72428:   }
 72428: 
 72428:   // The canvas spec says that createPattern should use the first frame
 72428:   // of animated images
 72428:   nsLayoutUtils::SurfaceFromElementResult res =
103251:     nsLayoutUtils::SurfaceFromElement(htmlElement,
 83345:       nsLayoutUtils::SFE_WANT_FIRST_FRAME | nsLayoutUtils::SFE_WANT_NEW_SURFACE);
 72428: 
 72428:   if (!res.mSurface) {
103251:     error.Throw(NS_ERROR_NOT_AVAILABLE);
103251:     return NULL;
 72428:   }
 72428: 
106838:   // Ignore nullptr cairo surfaces! See bug 666312.
 95896:   if (!res.mSurface->CairoSurface() || res.mSurface->CairoStatus()) {
103251:     return NULL;
 72428:   }
 72428: 
 72428:   RefPtr<SourceSurface> srcSurf =
 72428:     gfxPlatform::GetPlatform()->GetSourceSurfaceForSurface(mTarget, res.mSurface);
 72428: 
 72428:   nsRefPtr<nsCanvasPatternAzure> pat =
 78159:     new nsCanvasPatternAzure(srcSurf, repeatMode, res.mPrincipal,
 78159:                              res.mIsWriteOnly, res.mCORSUsed);
 72428: 
103251:   return pat.forget();
103251: }
103251: 
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::CreatePattern(nsIDOMHTMLElement *image,
103251:                                                const nsAString& repeat,
103251:                                                nsIDOMCanvasPattern **_retval)
103251: {
103251:   HTMLImageOrCanvasOrVideoElement element;
103251:   if (!ToHTMLImageOrCanvasOrVideoElement(image, element)) {
103251:     return NS_ERROR_DOM_TYPE_MISMATCH_ERR;
103251:   }
103251: 
103251:   ErrorResult rv;
103251:   *_retval = CreatePattern(element, repeat, rv).get();
103251:   return rv.ErrorCode();
 72428: }
 72428: 
 72428: //
 72428: // shadows
 72428: //
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::SetShadowOffsetX(float x)
 72428: {
103251:   SetShadowOffsetX((double)x);
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::GetShadowOffsetX(float *x)
 72428: {
103251:   *x = static_cast<float>(GetShadowOffsetX());
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::SetShadowOffsetY(float y)
 72428: {
103251:   SetShadowOffsetY((double)y);
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::GetShadowOffsetY(float *y)
 72428: {
103251:   *y = static_cast<float>(GetShadowOffsetY());
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::SetShadowBlur(float blur)
 72428: {
103251:   SetShadowBlur((double)blur);
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::GetShadowBlur(float *blur)
 72428: {
103251:   *blur = GetShadowBlur();
 72428:   return NS_OK;
 72428: }
 72428: 
103251: void
103251: nsCanvasRenderingContext2DAzure::SetShadowColor(const nsAString& shadowColor)
 72428: {
 72428:   nscolor color;
103251:   if (!ParseColor(shadowColor, &color)) {
103251:     return;
103251:   }
103251: 
103251:   CurrentState().shadowColor = color;
103251: }
103251: 
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::SetMozShadowColor(const nsAString& colorstr)
103251: {
103251:   SetShadowColor(colorstr);
103101:   return NS_OK;
103059: }
103059: 
103059: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::GetMozShadowColor(nsAString& color)
103059: {
103251:   GetShadowColor(color);
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: //
 72428: // rects
 72428: //
 72428: 
103251: void
103251: nsCanvasRenderingContext2DAzure::ClearRect(double x, double y, double w,
103251:                                            double h)
103251: {
111232:   if (!FloatValidate(x,y,w,h)) {
103251:     return;
103251:   }
103251:  
103251:   mTarget->ClearRect(mgfx::Rect(x, y, w, h));
103251: 
103251:   RedrawUser(gfxRect(x, y, w, h));
103251: }
103251: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::ClearRect(float x, float y, float w, float h)
 72428: {
103251:   ClearRect((double)x, (double)y, (double)w, (double)h);
 72428:   return NS_OK;
 72428: }
 72428: 
103251: void
103251: nsCanvasRenderingContext2DAzure::FillRect(double x, double y, double w,
103251:                                           double h)
 72428: {
 72428:   if (!FloatValidate(x,y,w,h)) {
103251:     return;
 72428:   }
 72428: 
 72428:   const ContextState &state = CurrentState();
 72428: 
 72428:   if (state.patternStyles[STYLE_FILL]) {
 72428:     nsCanvasPatternAzure::RepeatMode repeat = 
 72428:       state.patternStyles[STYLE_FILL]->mRepeat;
 72428:     // In the FillRect case repeat modes are easy to deal with.
 72428:     bool limitx = repeat == nsCanvasPatternAzure::NOREPEAT || repeat == nsCanvasPatternAzure::REPEATY;
 72428:     bool limity = repeat == nsCanvasPatternAzure::NOREPEAT || repeat == nsCanvasPatternAzure::REPEATX;
 72428: 
 72428:     IntSize patternSize =
 72428:       state.patternStyles[STYLE_FILL]->mSurface->GetSize();
 72428: 
 72428:     // We always need to execute painting for non-over operators, even if
 72428:     // we end up with w/h = 0.
 72428:     if (limitx) {
 72428:       if (x < 0) {
 72428:         w += x;
 72428:         if (w < 0) {
 72428:           w = 0;
 72428:         }
 72428: 
 72428:         x = 0;
 72428:       }
 72428:       if (x + w > patternSize.width) {
 72428:         w = patternSize.width - x;
 72428:         if (w < 0) {
 72428:           w = 0;
 72428:         }
 72428:       }
 72428:     }
 72428:     if (limity) {
 72428:       if (y < 0) {
 72428:         h += y;
 72428:         if (h < 0) {
 72428:           h = 0;
 72428:         }
 72428: 
 72428:         y = 0;
 72428:       }
 72428:       if (y + h > patternSize.height) {
 72428:         h = patternSize.height - y;
 72428:         if (h < 0) {
 72428:           h = 0;
 72428:         }
 72428:       }
 72428:     }
 72428:   }
 72428: 
 73777:   mgfx::Rect bounds;
 73777:   
 73777:   if (NeedToDrawShadow()) {
 73777:     bounds = mgfx::Rect(x, y, w, h);
 73777:     bounds = mTarget->GetTransform().TransformBounds(bounds);
 73777:   }
 73777: 
106838:   AdjustedTarget(this, bounds.IsEmpty() ? nullptr : &bounds)->
 73777:     FillRect(mgfx::Rect(x, y, w, h),
103252:              CanvasGeneralPattern().ForStyle(this, STYLE_FILL, mTarget),
 73032:              DrawOptions(state.globalAlpha, UsedOperation()));
 72428: 
103251:   RedrawUser(gfxRect(x, y, w, h));
 72428: }
 72428: 
 72428: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::FillRect(float x, float y, float w, float h)
103251: {
103251:   FillRect((double)x, (double)y, (double)w, (double)h);
103251:   return NS_OK;
103251: }
103251: 
103251: void
103251: nsCanvasRenderingContext2DAzure::StrokeRect(double x, double y, double w,
103251:                                             double h)
 72428: {
 72428:   if (!FloatValidate(x,y,w,h)) {
103251:     return;
 72428:   }
 72428: 
 72428:   const ContextState &state = CurrentState();
 72428: 
 73777:   mgfx::Rect bounds;
 73777:   
 73777:   if (NeedToDrawShadow()) {
 73777:     bounds = mgfx::Rect(x - state.lineWidth / 2.0f, y - state.lineWidth / 2.0f,
 73777:                         w + state.lineWidth, h + state.lineWidth);
 73777:     bounds = mTarget->GetTransform().TransformBounds(bounds);
 73777:   }
 73777: 
111232:   if (!w && !h) {
111232:     return;
111232:   }
111232: 
103251:   if (!h) {
 72428:     CapStyle cap = CAP_BUTT;
 72428:     if (state.lineJoin == JOIN_ROUND) {
 72428:       cap = CAP_ROUND;
 72428:     }
106838:     AdjustedTarget(this, bounds.IsEmpty() ? nullptr : &bounds)->
 72428:       StrokeLine(Point(x, y), Point(x + w, y),
103252:                   CanvasGeneralPattern().ForStyle(this, STYLE_STROKE, mTarget),
 72428:                   StrokeOptions(state.lineWidth, state.lineJoin,
 72744:                                 cap, state.miterLimit,
 72744:                                 state.dash.Length(),
 72744:                                 state.dash.Elements(),
 72744:                                 state.dashOffset),
 73032:                   DrawOptions(state.globalAlpha, UsedOperation()));
103251:     return;
103251:   }
103251: 
103251:   if (!w) {
 72428:     CapStyle cap = CAP_BUTT;
 72428:     if (state.lineJoin == JOIN_ROUND) {
 72428:       cap = CAP_ROUND;
 72428:     }
106838:     AdjustedTarget(this, bounds.IsEmpty() ? nullptr : &bounds)->
 72428:       StrokeLine(Point(x, y), Point(x, y + h),
103252:                   CanvasGeneralPattern().ForStyle(this, STYLE_STROKE, mTarget),
 72428:                   StrokeOptions(state.lineWidth, state.lineJoin,
 72744:                                 cap, state.miterLimit,
 72744:                                 state.dash.Length(),
 72744:                                 state.dash.Elements(),
 72744:                                 state.dashOffset),
 73032:                   DrawOptions(state.globalAlpha, UsedOperation()));
103251:     return;
 72428:   }
 72428: 
106838:   AdjustedTarget(this, bounds.IsEmpty() ? nullptr : &bounds)->
 72428:     StrokeRect(mgfx::Rect(x, y, w, h),
103252:                 CanvasGeneralPattern().ForStyle(this, STYLE_STROKE, mTarget),
 72428:                 StrokeOptions(state.lineWidth, state.lineJoin,
 72744:                               state.lineCap, state.miterLimit,
 72744:                               state.dash.Length(),
 72744:                               state.dash.Elements(),
 72744:                               state.dashOffset),
 73032:                 DrawOptions(state.globalAlpha, UsedOperation()));
 72428: 
103251:   Redraw();
103251: }
103251: 
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::StrokeRect(float x, float y, float w, float h)
103251: {
103251:   StrokeRect((double)x, (double)y, (double)w, (double)h);
103251:   return NS_OK;
 72428: }
 72428: 
 72428: //
 72428: // path bits
 72428: //
 72428: 
103251: void
 72428: nsCanvasRenderingContext2DAzure::BeginPath()
 72428: {
106838:   mPath = nullptr;
106838:   mPathBuilder = nullptr;
106838:   mDSPathBuilder = nullptr;
 72428:   mPathTransformWillUpdate = false;
103251: }
103251: 
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::MozBeginPath()
103251: {
103251:   BeginPath();
103101:   return NS_OK;
103059: }
103059: 
103059: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::MozClosePath()
103059: {
103251:   ClosePath();
 72428:   return NS_OK;
 72428: }
 72428: 
103251: void
 72428: nsCanvasRenderingContext2DAzure::Fill()
 72428: {
 72428:   EnsureUserSpacePath();
 72428: 
 72428:   if (!mPath) {
103251:     return;
 72428:   }
 72428: 
 73777:   mgfx::Rect bounds;
 73777: 
 73777:   if (NeedToDrawShadow()) {
 73777:     bounds = mPath->GetBounds(mTarget->GetTransform());
 73777:   }
 73777: 
106838:   AdjustedTarget(this, bounds.IsEmpty() ? nullptr : &bounds)->
103252:     Fill(mPath, CanvasGeneralPattern().ForStyle(this, STYLE_FILL, mTarget),
 73032:          DrawOptions(CurrentState().globalAlpha, UsedOperation()));
 72428: 
103251:   Redraw();
 72428: }
 72428: 
 72428: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::MozFill()
103251: {
103251:   Fill();
103251:   return NS_OK;
103251: }
103251: 
103251: void
 72428: nsCanvasRenderingContext2DAzure::Stroke()
 72428: {
 72428:   EnsureUserSpacePath();
 72428: 
 72428:   if (!mPath) {
103251:     return;
 72428:   }
 72428: 
 72428:   const ContextState &state = CurrentState();
 72428: 
 73777:   StrokeOptions strokeOptions(state.lineWidth, state.lineJoin,
 73777:                               state.lineCap, state.miterLimit,
 73777:                               state.dash.Length(), state.dash.Elements(),
 73777:                               state.dashOffset);
 73777: 
 73777:   mgfx::Rect bounds;
 73777:   if (NeedToDrawShadow()) {
 73777:     bounds =
 73777:       mPath->GetStrokedBounds(strokeOptions, mTarget->GetTransform());
 73777:   }
 73777: 
106838:   AdjustedTarget(this, bounds.IsEmpty() ? nullptr : &bounds)->
103252:     Stroke(mPath, CanvasGeneralPattern().ForStyle(this, STYLE_STROKE, mTarget),
 73777:            strokeOptions, DrawOptions(state.globalAlpha, UsedOperation()));
 72428: 
103251:   Redraw();
 72428: }
 72428: 
 72428: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::MozStroke()
103251: {
103251:   Stroke();
103251:   return NS_OK;
103251: }
103251: 
103251: void
 72428: nsCanvasRenderingContext2DAzure::Clip()
 72428: {
 72428:   EnsureUserSpacePath();
 72428: 
 72428:   if (!mPath) {
103251:     return;
 72428:   }
 72428: 
 72428:   mTarget->PushClip(mPath);
 72428:   CurrentState().clipsPushed.push_back(mPath);
103251: }
103251: 
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::MozClip()
103251: {
103251:   Clip();
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::MoveTo(float x, float y)
 72428: {
103251:   MoveTo((double)x, (double)y);
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::LineTo(float x, float y)
 72428: {
103251:   LineTo((double)x, (double)y);
 72428:   return NS_OK;
103251: }
103251:   
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::QuadraticCurveTo(float cpx, float cpy, float x,
103251:                                                   float y)
103101: {
103251:   QuadraticCurveTo((double)cpx, (double)cpy, (double)x, (double)y);
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::BezierCurveTo(float cp1x, float cp1y,
 72428:                                                float cp2x, float cp2y,
 72428:                                                float x, float y)
 72428: {
103251:   BezierCurveTo((double)cp1x, (double)cp1y, (double)cp2x, (double)cp2y,
103251:                 (double)x, (double)y);
 72428:   return NS_OK;
 72428: }
 72428: 
103251: void
103251: nsCanvasRenderingContext2DAzure::ArcTo(double x1, double y1, double x2,
103251:                                        double y2, double radius,
103251:                                        ErrorResult& error)
 72428: {
 72428:   if (!FloatValidate(x1, y1, x2, y2, radius)) {
103251:     return;
 72428:   }
 72428: 
 72428:   if (radius < 0) {
103251:     error.Throw(NS_ERROR_DOM_INDEX_SIZE_ERR);
103251:     return;
 72428:   }
 72428: 
 72428:   EnsureWritablePath();
 72428: 
 72428:   // Current point in user space!
 72428:   Point p0;
 72428:   if (mPathBuilder) {
 72428:     p0 = mPathBuilder->CurrentPoint();
 72428:   } else {
 72428:     Matrix invTransform = mTarget->GetTransform();
 72428:     if (!invTransform.Invert()) {
103251:       return;
 72428:     }
 72428: 
 72428:     p0 = invTransform * mDSPathBuilder->CurrentPoint();
 72428:   }
 72428: 
 72428:   Point p1(x1, y1);
 72428:   Point p2(x2, y2);
 72428: 
 72428:   // Execute these calculations in double precision to avoid cumulative
 72428:   // rounding errors.
 72428:   double dir, a2, b2, c2, cosx, sinx, d, anx, any,
 72428:           bnx, bny, x3, y3, x4, y4, cx, cy, angle0, angle1;
 72428:   bool anticlockwise;
 72428: 
 72428:   if (p0 == p1 || p1 == p2 || radius == 0) {
 72428:     LineTo(p1.x, p1.y);
103251:     return;
 72428:   }
 72428: 
 72428:   // Check for colinearity
 72428:   dir = (p2.x - p1.x) * (p0.y - p1.y) + (p2.y - p1.y) * (p1.x - p0.x);
 72428:   if (dir == 0) {
 72428:     LineTo(p1.x, p1.y);
103251:     return;
 72428:   }
 72428: 
 72428: 
 72428:   // XXX - Math for this code was already available from the non-azure code
 72428:   // and would be well tested. Perhaps converting to bezier directly might
 72428:   // be more efficient longer run.
 72428:   a2 = (p0.x-x1)*(p0.x-x1) + (p0.y-y1)*(p0.y-y1);
 72428:   b2 = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);
 72428:   c2 = (p0.x-x2)*(p0.x-x2) + (p0.y-y2)*(p0.y-y2);
 72428:   cosx = (a2+b2-c2)/(2*sqrt(a2*b2));
 72428: 
 72428:   sinx = sqrt(1 - cosx*cosx);
 72428:   d = radius / ((1 - cosx) / sinx);
 72428: 
 72428:   anx = (x1-p0.x) / sqrt(a2);
 72428:   any = (y1-p0.y) / sqrt(a2);
 72428:   bnx = (x1-x2) / sqrt(b2);
 72428:   bny = (y1-y2) / sqrt(b2);
 72428:   x3 = x1 - anx*d;
 72428:   y3 = y1 - any*d;
 72428:   x4 = x1 - bnx*d;
 72428:   y4 = y1 - bny*d;
 72428:   anticlockwise = (dir < 0);
 72428:   cx = x3 + any*radius*(anticlockwise ? 1 : -1);
 72428:   cy = y3 - anx*radius*(anticlockwise ? 1 : -1);
 72428:   angle0 = atan2((y3-cy), (x3-cx));
 72428:   angle1 = atan2((y4-cy), (x4-cx));
 72428: 
 72428: 
 72428:   LineTo(x3, y3);
 72428: 
 72428:   Arc(cx, cy, radius, angle0, angle1, anticlockwise);
103251: }
103251: 
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::ArcTo(float x1, float y1, float x2, float y2, float radius)
103251: {
103251:   ErrorResult rv;
103251:   ArcTo(x1, y1, x2, y2, radius, rv);
103251:   return rv.ErrorCode();
103251: }
103251: 
103251: void
103251: nsCanvasRenderingContext2DAzure::Arc(double x, double y, double r,
103251:                                      double startAngle, double endAngle,
103251:                                      bool anticlockwise, ErrorResult& error)
103251: {
103251:   if (!FloatValidate(x, y, r, startAngle, endAngle)) {
103251:     return;
103251:   }
103251: 
103251:   if (r < 0.0) {
103251:     error.Throw(NS_ERROR_DOM_INDEX_SIZE_ERR);
103251:     return;
103251:   }
103251: 
103251:   EnsureWritablePath();
103251: 
103251:   ArcToBezier(this, Point(x, y), r, startAngle, endAngle, anticlockwise);
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::Arc(float x, float y,
 72428:                                      float r,
 72428:                                      float startAngle, float endAngle,
 79445:                                      bool ccw)
 72428: {
103251:   ErrorResult rv;
103251:   Arc(x, y, r, startAngle, endAngle, ccw, rv);
103251:   return rv.ErrorCode();
103251: }
103251: 
103251: void
103251: nsCanvasRenderingContext2DAzure::Rect(double x, double y, double w, double h)
 72428: {
 72428:   if (!FloatValidate(x, y, w, h)) {
103251:     return;
 72428:   }
 72428: 
 72428:   EnsureWritablePath();
 72428: 
 72428:   if (mPathBuilder) {
 72428:     mPathBuilder->MoveTo(Point(x, y));
 72428:     mPathBuilder->LineTo(Point(x + w, y));
 72428:     mPathBuilder->LineTo(Point(x + w, y + h));
 72428:     mPathBuilder->LineTo(Point(x, y + h));
 72428:     mPathBuilder->Close();
 72428:   } else {
 72428:     mDSPathBuilder->MoveTo(mTarget->GetTransform() * Point(x, y));
 72428:     mDSPathBuilder->LineTo(mTarget->GetTransform() * Point(x + w, y));
 72428:     mDSPathBuilder->LineTo(mTarget->GetTransform() * Point(x + w, y + h));
 72428:     mDSPathBuilder->LineTo(mTarget->GetTransform() * Point(x, y + h));
 72428:     mDSPathBuilder->Close();
 72428:   }
103251: }
103251: 
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::Rect(float x, float y, float w, float h)
103251: {
103251:   Rect((double)x, (double)y, (double)w, (double)h);
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: void
 72428: nsCanvasRenderingContext2DAzure::EnsureWritablePath()
 72428: {
 72428:   if (mDSPathBuilder) {
 72428:     return;
 72428:   }
 72428: 
 72428:   FillRule fillRule = CurrentState().fillRule;
 72428: 
 72428:   if (mPathBuilder) {
 72428:     if (mPathTransformWillUpdate) {
 72428:       mPath = mPathBuilder->Finish();
 72428:       mDSPathBuilder =
 72428:         mPath->TransformedCopyToBuilder(mPathToDS, fillRule);
106838:       mPath = nullptr;
106838:       mPathBuilder = nullptr;
 99194:       mPathTransformWillUpdate = false;
 72428:     }
 72428:     return;
 72428:   }
 72428: 
 72428:   if (!mPath) {
106604:     NS_ASSERTION(!mPathTransformWillUpdate, "mPathTransformWillUpdate should be false, if all paths are null");
 72428:     mPathBuilder = mTarget->CreatePathBuilder(fillRule);
 72428:   } else if (!mPathTransformWillUpdate) {
 72428:     mPathBuilder = mPath->CopyToBuilder(fillRule);
 72428:   } else {
 72428:     mDSPathBuilder =
 72428:       mPath->TransformedCopyToBuilder(mPathToDS, fillRule);
 97096:     mPathTransformWillUpdate = false;
 72428:   }
 72428: }
 72428: 
 72428: void
106604: nsCanvasRenderingContext2DAzure::EnsureUserSpacePath(bool aCommitTransform /* = true */)
 72428: {
 72428:   FillRule fillRule = CurrentState().fillRule;
 72428: 
 72428:   if (!mPath && !mPathBuilder && !mDSPathBuilder) {
 72428:     mPathBuilder = mTarget->CreatePathBuilder(fillRule);
 72428:   }
 72428: 
 72428:   if (mPathBuilder) {
 72428:     mPath = mPathBuilder->Finish();
106838:     mPathBuilder = nullptr;
 72428:   }
 72428: 
106604:   if (aCommitTransform &&
106604:       mPath &&
106604:       mPathTransformWillUpdate) {
 72428:     mDSPathBuilder =
 72428:       mPath->TransformedCopyToBuilder(mPathToDS, fillRule);
106838:     mPath = nullptr;
 72428:     mPathTransformWillUpdate = false;
 72428:   }
 72428: 
 72428:   if (mDSPathBuilder) {
 72428:     RefPtr<Path> dsPath;
 72428:     dsPath = mDSPathBuilder->Finish();
106838:     mDSPathBuilder = nullptr;
 72428: 
 72428:     Matrix inverse = mTarget->GetTransform();
 72428:     if (!inverse.Invert()) {
106604:       NS_WARNING("Could not invert transform");
 72428:       return;
 72428:     }
 72428: 
 72428:     mPathBuilder =
 72428:       dsPath->TransformedCopyToBuilder(inverse, fillRule);
 72428:     mPath = mPathBuilder->Finish();
106838:     mPathBuilder = nullptr;
 72428:   }
 72428: 
 72428:   if (mPath && mPath->GetFillRule() != fillRule) {
 72428:     mPathBuilder = mPath->CopyToBuilder(fillRule);
 72428:     mPath = mPathBuilder->Finish();
 72428:   }
106604: 
106604:   NS_ASSERTION(mPath, "mPath should exist");
 72428: }
 72428: 
 72428: void
 72428: nsCanvasRenderingContext2DAzure::TransformWillUpdate()
 72428: {
 72428:   // Store the matrix that would transform the current path to device
 72428:   // space.
 72428:   if (mPath || mPathBuilder) {
 72428:     if (!mPathTransformWillUpdate) {
 72428:       // If the transform has already been updated, but a device space builder
 72428:       // has not been created yet mPathToDS contains the right transform to
 72428:       // transform the current mPath into device space.
 72428:       // We should leave it alone.
 72428:       mPathToDS = mTarget->GetTransform();
 72428:     }
 72428:     mPathTransformWillUpdate = true;
 72428:   }
 72428: }
 72428: 
 72428: //
 72428: // text
 72428: //
 72428: 
 72428: /**
 72428:  * Helper function for SetFont that creates a style rule for the given font.
 72428:  * @param aFont The CSS font string
 72428:  * @param aNode The canvas element
 72428:  * @param aResult Pointer in which to place the new style rule.
 72428:  * @remark Assumes all pointer arguments are non-null.
 72428:  */
 72428: static nsresult
 72428: CreateFontStyleRule(const nsAString& aFont,
 72428:                     nsINode* aNode,
 72428:                     StyleRule** aResult)
 72428: {
 72428:   nsRefPtr<StyleRule> rule;
 79445:   bool changed;
 72428: 
 72428:   nsIPrincipal* principal = aNode->NodePrincipal();
 80526:   nsIDocument* document = aNode->OwnerDoc();
 72428: 
 72428:   nsIURI* docURL = document->GetDocumentURI();
 72428:   nsIURI* baseURL = document->GetDocBaseURI();
 72428: 
 72428:   // Pass the CSS Loader object to the parser, to allow parser error reports
 72428:   // to include the outer window ID.
 72428:   nsCSSParser parser(document->CSSLoader());
 72428: 
 72428:   nsresult rv = parser.ParseStyleAttribute(EmptyString(), docURL, baseURL,
 72428:                                             principal, getter_AddRefs(rule));
 72428:   if (NS_FAILED(rv)) {
 72428:     return rv;
 72428:   }
 72428: 
 72428:   rv = parser.ParseProperty(eCSSProperty_font, aFont, docURL, baseURL,
 72428:                             principal, rule->GetDeclaration(), &changed,
 80486:                             false);
 72428:   if (NS_FAILED(rv))
 72428:     return rv;
 72428: 
 72428:   rv = parser.ParseProperty(eCSSProperty_line_height,
 72428:                             NS_LITERAL_STRING("normal"), docURL, baseURL,
 72428:                             principal, rule->GetDeclaration(), &changed,
 80486:                             false);
 72428:   if (NS_FAILED(rv)) {
 72428:     return rv;
 72428:   }
 72428: 
 72428:   rule->RuleMatched();
 72428: 
 72428:   rule.forget(aResult);
 72428:   return NS_OK;
 72428: }
 72428: 
103251: void
103251: nsCanvasRenderingContext2DAzure::SetFont(const nsAString& font,
103251:                                          ErrorResult& error)
 72428: {
 72428:   /*
 72428:     * If font is defined with relative units (e.g. ems) and the parent
 72428:     * style context changes in between calls, setting the font to the
 72428:     * same value as previous could result in a different computed value,
 72428:     * so we cannot have the optimization where we check if the new font
 72428:     * string is equal to the old one.
 72428:     */
 72428: 
101146:   if (!mCanvasElement && !mDocShell) {
101146:     NS_WARNING("Canvas element must be non-null or a docshell must be provided");
103251:     error.Throw(NS_ERROR_FAILURE);
103251:     return;
 72428:   }
 72428: 
 72428:   nsIPresShell* presShell = GetPresShell();
 72428:   if (!presShell) {
103251:     error.Throw(NS_ERROR_FAILURE);
103251:     return;
 72428:   }
 72428:   nsIDocument* document = presShell->GetDocument();
 72428: 
 72428:   nsCOMArray<nsIStyleRule> rules;
 72428: 
 72428:   nsRefPtr<css::StyleRule> rule;
103251:   error = CreateFontStyleRule(font, document, getter_AddRefs(rule));
103251: 
103251:   if (error.Failed()) {
103251:     return;
 72428:   }
 72428: 
 72428:   css::Declaration *declaration = rule->GetDeclaration();
 72428:   // The easiest way to see whether we got a syntax error or whether
 72428:   // we got 'inherit' or 'initial' is to look at font-size-adjust,
 72428:   // which the shorthand resets to either 'none' or
 72428:   // '-moz-system-font'.
 72428:   // We know the declaration is not !important, so we can use
 72428:   // GetNormalBlock().
 72428:   const nsCSSValue *fsaVal =
 72428:     declaration->GetNormalBlock()->ValueFor(eCSSProperty_font_size_adjust);
 72428:   if (!fsaVal || (fsaVal->GetUnit() != eCSSUnit_None &&
 72428:                   fsaVal->GetUnit() != eCSSUnit_System_Font)) {
 72428:       // We got an all-property value or a syntax error.  The spec says
 72428:       // this value must be ignored.
103251:     return;
 72428:   }
 72428: 
 72428:   rules.AppendObject(rule);
 72428: 
 72428:   nsStyleSet* styleSet = presShell->StyleSet();
 72428: 
 72428:   // have to get a parent style context for inherit-like relative
 72428:   // values (2em, bolder, etc.)
 72428:   nsRefPtr<nsStyleContext> parentContext;
 72428: 
101146:   if (mCanvasElement && mCanvasElement->IsInDoc()) {
 72428:       // inherit from the canvas element
 72428:       parentContext = nsComputedDOMStyle::GetStyleContextForElement(
101146:               mCanvasElement,
106838:               nullptr,
 72428:               presShell);
 72428:   } else {
 72428:     // otherwise inherit from default (10px sans-serif)
 72428:     nsRefPtr<css::StyleRule> parentRule;
103251:     error = CreateFontStyleRule(NS_LITERAL_STRING("10px sans-serif"),
 72428:                                 document,
 72428:                                 getter_AddRefs(parentRule));
 72428: 
103251:     if (error.Failed()) {
103251:       return;
 72428:     }
 72428: 
 72428:     nsCOMArray<nsIStyleRule> parentRules;
 72428:     parentRules.AppendObject(parentRule);
106838:     parentContext = styleSet->ResolveStyleForRules(nullptr, parentRules);
 72428:   }
 72428: 
 72428:   if (!parentContext) {
103251:     error.Throw(NS_ERROR_FAILURE);
103251:     return;
 72428:   }
 72428: 
 72428:   nsRefPtr<nsStyleContext> sc =
 72428:       styleSet->ResolveStyleForRules(parentContext, rules);
 72428:   if (!sc) {
103251:     error.Throw(NS_ERROR_FAILURE);
103251:     return;
 72428:   }
 72428: 
 72428:   const nsStyleFont* fontStyle = sc->GetStyleFont();
 72428: 
 72428:   NS_ASSERTION(fontStyle, "Could not obtain font style");
 72428: 
 88039:   nsIAtom* language = sc->GetStyleFont()->mLanguage;
 72428:   if (!language) {
 72428:     language = presShell->GetPresContext()->GetLanguageFromCharset();
 72428:   }
 72428: 
 72428:   // use CSS pixels instead of dev pixels to avoid being affected by page zoom
108991:   const uint32_t aupcp = nsPresContext::AppUnitsPerCSSPixel();
 72428:   // un-zoom the font size to avoid being affected by text-only zoom
 88469:   //
 88469:   // Purposely ignore the font size that respects the user's minimum
 88469:   // font preference (fontStyle->mFont.size) in favor of the computed
 88469:   // size (fontStyle->mSize).  See
 88469:   // https://bugzilla.mozilla.org/show_bug.cgi?id=698652.
 88469:   const nscoord fontSize = nsStyleFont::UnZoomText(parentContext->PresContext(), fontStyle->mSize);
 72428: 
 79445:   bool printerFont = (presShell->GetPresContext()->Type() == nsPresContext::eContext_PrintPreview ||
 72428:                         presShell->GetPresContext()->Type() == nsPresContext::eContext_Print);
 72428: 
 72428:   gfxFontStyle style(fontStyle->mFont.style,
 72428:                       fontStyle->mFont.weight,
 72428:                       fontStyle->mFont.stretch,
 72428:                       NSAppUnitsToFloatPixels(fontSize, float(aupcp)),
 72428:                       language,
 72428:                       fontStyle->mFont.sizeAdjust,
 72428:                       fontStyle->mFont.systemFont,
 72428:                       printerFont,
 72428:                       fontStyle->mFont.languageOverride);
 72428: 
 96988:   fontStyle->mFont.AddFontFeaturesToStyle(&style);
 96988: 
 72428:   CurrentState().fontGroup =
 72428:       gfxPlatform::GetPlatform()->CreateFontGroup(fontStyle->mFont.name,
 72428:                                                   &style,
 72428:                                                   presShell->GetPresContext()->GetUserFontSet());
 72428:   NS_ASSERTION(CurrentState().fontGroup, "Could not get font group");
 72428: 
 72428:   // The font getter is required to be reserialized based on what we
 72428:   // parsed (including having line-height removed).  (Older drafts of
 72428:   // the spec required font sizes be converted to pixels, but that no
 72428:   // longer seems to be required.)
 72428:   declaration->GetValue(eCSSProperty_font, CurrentState().font);
103251: }
103251: 
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::SetMozFont(const nsAString& font)
103251: {
103251:   ErrorResult rv;
103251:   SetFont(font, rv);
103251:   return rv.ErrorCode();
103251: }
103251: 
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::GetMozFont(nsAString& font)
103251: {
103251:   font = GetFont();
103101:   return NS_OK;
103059: }
103059: 
103251: void
 72428: nsCanvasRenderingContext2DAzure::SetTextAlign(const nsAString& ta)
 72428: {
 72428:   if (ta.EqualsLiteral("start"))
 72428:     CurrentState().textAlign = TEXT_ALIGN_START;
 72428:   else if (ta.EqualsLiteral("end"))
 72428:     CurrentState().textAlign = TEXT_ALIGN_END;
 72428:   else if (ta.EqualsLiteral("left"))
 72428:     CurrentState().textAlign = TEXT_ALIGN_LEFT;
 72428:   else if (ta.EqualsLiteral("right"))
 72428:     CurrentState().textAlign = TEXT_ALIGN_RIGHT;
 72428:   else if (ta.EqualsLiteral("center"))
 72428:     CurrentState().textAlign = TEXT_ALIGN_CENTER;
103251: }
103251: 
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::SetMozTextAlign(const nsAString& ta)
103251: {
103251:   SetTextAlign(ta);
103101:   return NS_OK;
103059: }
103059: 
103251: void
 72428: nsCanvasRenderingContext2DAzure::GetTextAlign(nsAString& ta)
 72428: {
 72428:   switch (CurrentState().textAlign)
 72428:   {
 72428:   case TEXT_ALIGN_START:
 72428:     ta.AssignLiteral("start");
 72428:     break;
 72428:   case TEXT_ALIGN_END:
 72428:     ta.AssignLiteral("end");
 72428:     break;
 72428:   case TEXT_ALIGN_LEFT:
 72428:     ta.AssignLiteral("left");
 72428:     break;
 72428:   case TEXT_ALIGN_RIGHT:
 72428:     ta.AssignLiteral("right");
 72428:     break;
 72428:   case TEXT_ALIGN_CENTER:
 72428:     ta.AssignLiteral("center");
 72428:     break;
 72428:   }
103251: }
103251: 
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::GetMozTextAlign(nsAString& ta)
103251: {
103251:   GetTextAlign(ta);
103101:   return NS_OK;
103059: }
103059: 
103251: void
 72428: nsCanvasRenderingContext2DAzure::SetTextBaseline(const nsAString& tb)
 72428: {
 72428:   if (tb.EqualsLiteral("top"))
 72428:     CurrentState().textBaseline = TEXT_BASELINE_TOP;
 72428:   else if (tb.EqualsLiteral("hanging"))
 72428:     CurrentState().textBaseline = TEXT_BASELINE_HANGING;
 72428:   else if (tb.EqualsLiteral("middle"))
 72428:     CurrentState().textBaseline = TEXT_BASELINE_MIDDLE;
 72428:   else if (tb.EqualsLiteral("alphabetic"))
 72428:     CurrentState().textBaseline = TEXT_BASELINE_ALPHABETIC;
 72428:   else if (tb.EqualsLiteral("ideographic"))
 72428:     CurrentState().textBaseline = TEXT_BASELINE_IDEOGRAPHIC;
 72428:   else if (tb.EqualsLiteral("bottom"))
 72428:     CurrentState().textBaseline = TEXT_BASELINE_BOTTOM;
103251: }
103251: 
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::SetMozTextBaseline(const nsAString& tb)
103251: {
103251:   SetTextBaseline(tb);
103101:   return NS_OK;
103059: }
103059: 
103251: void
 72428: nsCanvasRenderingContext2DAzure::GetTextBaseline(nsAString& tb)
 72428: {
 72428:   switch (CurrentState().textBaseline)
 72428:   {
 72428:   case TEXT_BASELINE_TOP:
 72428:     tb.AssignLiteral("top");
 72428:     break;
 72428:   case TEXT_BASELINE_HANGING:
 72428:     tb.AssignLiteral("hanging");
 72428:     break;
 72428:   case TEXT_BASELINE_MIDDLE:
 72428:     tb.AssignLiteral("middle");
 72428:     break;
 72428:   case TEXT_BASELINE_ALPHABETIC:
 72428:     tb.AssignLiteral("alphabetic");
 72428:     break;
 72428:   case TEXT_BASELINE_IDEOGRAPHIC:
 72428:     tb.AssignLiteral("ideographic");
 72428:     break;
 72428:   case TEXT_BASELINE_BOTTOM:
 72428:     tb.AssignLiteral("bottom");
 72428:     break;
 72428:   }
103251: }
103251: 
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::GetMozTextBaseline(nsAString& tb)
103251: {
103251:   GetTextBaseline(tb);
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: /*
 72428:  * Helper function that replaces the whitespace characters in a string
 72428:  * with U+0020 SPACE. The whitespace characters are defined as U+0020 SPACE,
 72428:  * U+0009 CHARACTER TABULATION (tab), U+000A LINE FEED (LF), U+000B LINE
 72428:  * TABULATION, U+000C FORM FEED (FF), and U+000D CARRIAGE RETURN (CR).
 72428:  * @param str The string whose whitespace characters to replace.
 72428:  */
 72428: static inline void
 72428: TextReplaceWhitespaceCharacters(nsAutoString& str)
 72428: {
 72428:   str.ReplaceChar("\x09\x0A\x0B\x0C\x0D", PRUnichar(' '));
 72428: }
 72428: 
103251: void
103251: nsCanvasRenderingContext2DAzure::FillText(const nsAString& text, double x,
103251:                                           double y,
103251:                                           const Optional<double>& maxWidth,
103251:                                           ErrorResult& error)
103251: {
106838:   error = DrawOrMeasureText(text, x, y, maxWidth, TEXT_DRAW_OPERATION_FILL, nullptr);
103251: }
103251: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::FillText(const nsAString& text, float x, float y, float maxWidth)
 72428: {
103251:   ErrorResult rv;
103251:   Optional<double> optionalMaxWidth;
103251:   optionalMaxWidth.Construct();
103251:   optionalMaxWidth.Value() = maxWidth;
103251:   FillText(text, x, y, optionalMaxWidth, rv);
103251:   return rv.ErrorCode();
103251: }
103251: 
103251: void
103251: nsCanvasRenderingContext2DAzure::StrokeText(const nsAString& text, double x,
103251:                                             double y,
103251:                                             const Optional<double>& maxWidth,
103251:                                             ErrorResult& error)
103251: {
106838:   error = DrawOrMeasureText(text, x, y, maxWidth, TEXT_DRAW_OPERATION_STROKE, nullptr);
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::StrokeText(const nsAString& text, float x, float y, float maxWidth)
 72428: {
103251:   ErrorResult rv;
103251:   Optional<double> optionalMaxWidth;
103251:   optionalMaxWidth.Construct();
103251:   optionalMaxWidth.Value() = maxWidth;
103251:   StrokeText(text, x, y, optionalMaxWidth, rv);
103251:   return rv.ErrorCode();
103251: }
103251: 
103251: already_AddRefed<nsIDOMTextMetrics>
103251: nsCanvasRenderingContext2DAzure::MeasureText(const nsAString& rawText,
103251:                                              ErrorResult& error)
103251: {
103251:   float width;
103251:   Optional<double> maxWidth;
103251:   error = DrawOrMeasureText(rawText, 0, 0, maxWidth, TEXT_DRAW_OPERATION_MEASURE, &width);
103251:   if (error.Failed()) {
103251:     return NULL;
103251:   }
103251: 
103251:   nsRefPtr<nsIDOMTextMetrics> textMetrics = new nsTextMetricsAzure(width);
103251: 
103251:   return textMetrics.forget();
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::MeasureText(const nsAString& rawText,
 72428:                                              nsIDOMTextMetrics** _retval)
 72428: {
103251:   ErrorResult rv;
103251:   *_retval = MeasureText(rawText, rv).get();
103251:   return rv.ErrorCode();
 72428: }
 72428: 
 72428: /**
 72428:  * Used for nsBidiPresUtils::ProcessText
 72428:  */
 72428: struct NS_STACK_CLASS nsCanvasBidiProcessorAzure : public nsBidiPresUtils::BidiProcessor
 72428: {
 72744:   typedef nsCanvasRenderingContext2DAzure::ContextState ContextState;
 72744: 
108991:   virtual void SetText(const PRUnichar* text, int32_t length, nsBidiDirection direction)
 72428:   {
 95666:     mFontgrp->UpdateFontList(); // ensure user font generation is current
 86690:     mTextRun = mFontgrp->MakeTextRun(text,
 72428:                                      length,
 72428:                                      mThebes,
 72428:                                      mAppUnitsPerDevPixel,
 72428:                                      direction==NSBIDI_RTL ? gfxTextRunFactory::TEXT_IS_RTL : 0);
 72428:   }
 72428: 
 72428:   virtual nscoord GetWidth()
 72428:   {
 72428:     gfxTextRun::Metrics textRunMetrics = mTextRun->MeasureText(0,
 72428:                                                                mTextRun->GetLength(),
 72428:                                                                mDoMeasureBoundingBox ?
 72428:                                                                  gfxFont::TIGHT_INK_EXTENTS :
 72428:                                                                  gfxFont::LOOSE_INK_EXTENTS,
 72428:                                                                mThebes,
106838:                                                                nullptr);
 72428: 
 72428:     // this only measures the height; the total width is gotten from the
 72428:     // the return value of ProcessText.
 72428:     if (mDoMeasureBoundingBox) {
 72428:       textRunMetrics.mBoundingBox.Scale(1.0 / mAppUnitsPerDevPixel);
 72428:       mBoundingBox = mBoundingBox.Union(textRunMetrics.mBoundingBox);
 72428:     }
 72428: 
 72880:     return NSToCoordRound(textRunMetrics.mAdvanceWidth);
 72428:   }
 72428: 
 72428:   virtual void DrawText(nscoord xOffset, nscoord width)
 72428:   {
 72428:     gfxPoint point = mPt;
 84284:     point.x += xOffset;
 72428: 
 72428:     // offset is given in terms of left side of string
 72428:     if (mTextRun->IsRightToLeft()) {
 72428:       // Bug 581092 - don't use rounded pixel width to advance to
 72428:       // right-hand end of run, because this will cause different
 72428:       // glyph positioning for LTR vs RTL drawing of the same
 72428:       // glyph string on OS X and DWrite where textrun widths may
 72428:       // involve fractional pixels.
 72428:       gfxTextRun::Metrics textRunMetrics =
 72428:         mTextRun->MeasureText(0,
 72428:                               mTextRun->GetLength(),
 72428:                               mDoMeasureBoundingBox ?
 72428:                                   gfxFont::TIGHT_INK_EXTENTS :
 72428:                                   gfxFont::LOOSE_INK_EXTENTS,
 72428:                               mThebes,
106838:                               nullptr);
 72428:       point.x += textRunMetrics.mAdvanceWidth;
 72428:       // old code was:
 72428:       //   point.x += width * mAppUnitsPerDevPixel;
 72428:       // TODO: restore this if/when we move to fractional coords
 72428:       // throughout the text layout process
 72428:     }
 72428: 
108991:     uint32_t numRuns;
 72428:     const gfxTextRun::GlyphRun *runs = mTextRun->GetGlyphRuns(&numRuns);
108991:     const uint32_t appUnitsPerDevUnit = mAppUnitsPerDevPixel;
 72428:     const double devUnitsPerAppUnit = 1.0/double(appUnitsPerDevUnit);
 72428:     Point baselineOrigin =
 72428:       Point(point.x * devUnitsPerAppUnit, point.y * devUnitsPerAppUnit);
 72428: 
 80261:     float advanceSum = 0;
 80261: 
108991:     for (uint32_t c = 0; c < numRuns; c++) {
 72428:       gfxFont *font = runs[c].mFont;
108991:       uint32_t endRun = 0;
 72428:       if (c + 1 < numRuns) {
 72428:         endRun = runs[c + 1].mCharacterOffset;
 72428:       } else {
 72428:         endRun = mTextRun->GetLength();
 72428:       }
 72428: 
 72428:       const gfxTextRun::CompressedGlyph *glyphs = mTextRun->GetCharacterGlyphs();
 72428: 
 72428:       RefPtr<ScaledFont> scaledFont =
106598:         gfxPlatform::GetPlatform()->GetScaledFontForFont(mCtx->mTarget, font);
 72428: 
 89584:       if (!scaledFont) {
 89584:         // This can occur when something switched DirectWrite off.
 89584:         return;
 89584:       }
 89584: 
 72428:       GlyphBuffer buffer;
 72428: 
 72428:       std::vector<Glyph> glyphBuf;
 72428: 
108991:       for (uint32_t i = runs[c].mCharacterOffset; i < endRun; i++) {
 72428:         Glyph newGlyph;
 72428:         if (glyphs[i].IsSimpleGlyph()) {
 72428:           newGlyph.mIndex = glyphs[i].GetSimpleGlyph();
 72428:           if (mTextRun->IsRightToLeft()) {
 72428:             newGlyph.mPosition.x = baselineOrigin.x - advanceSum -
 72428:               glyphs[i].GetSimpleAdvance() * devUnitsPerAppUnit;
 72428:           } else {
 72428:             newGlyph.mPosition.x = baselineOrigin.x + advanceSum;
 72428:           }
 72428:           newGlyph.mPosition.y = baselineOrigin.y;
 72428:           advanceSum += glyphs[i].GetSimpleAdvance() * devUnitsPerAppUnit;
 72428:           glyphBuf.push_back(newGlyph);
 72428:           continue;
 72428:         }
 72428: 
 72428:         if (!glyphs[i].GetGlyphCount()) {
 72428:           continue;
 72428:         }
 72428: 
 72428:         gfxTextRun::DetailedGlyph *detailedGlyphs =
 72428:           mTextRun->GetDetailedGlyphs(i);
 72428: 
108991:         for (uint32_t c = 0; c < glyphs[i].GetGlyphCount(); c++) {
 72428:           newGlyph.mIndex = detailedGlyphs[c].mGlyphID;
 72428:           if (mTextRun->IsRightToLeft()) {
 72428:             newGlyph.mPosition.x = baselineOrigin.x + detailedGlyphs[c].mXOffset * devUnitsPerAppUnit -
 72428:               advanceSum - detailedGlyphs[c].mAdvance * devUnitsPerAppUnit;
 72428:           } else {
 72428:             newGlyph.mPosition.x = baselineOrigin.x + detailedGlyphs[c].mXOffset * devUnitsPerAppUnit + advanceSum;
 72428:           }
 72428:           newGlyph.mPosition.y = baselineOrigin.y + detailedGlyphs[c].mYOffset * devUnitsPerAppUnit;
 72428:           glyphBuf.push_back(newGlyph);
 72428:           advanceSum += detailedGlyphs[c].mAdvance * devUnitsPerAppUnit;
 72428:         }
 72428:       }
 72428: 
 72520:       if (!glyphBuf.size()) {
 72520:         // This may happen for glyph runs for a 0 size font.
 72520:         continue;
 72520:       }
 72520: 
 72428:       buffer.mGlyphs = &glyphBuf.front();
 72428:       buffer.mNumGlyphs = glyphBuf.size();
 72428: 
110995:       Rect bounds(mBoundingBox.x, mBoundingBox.y, mBoundingBox.width, mBoundingBox.height);
 72428:       if (mOp == nsCanvasRenderingContext2DAzure::TEXT_DRAW_OPERATION_FILL) {
110995:         AdjustedTarget(mCtx, &bounds)->
 72428:           FillGlyphs(scaledFont, buffer,
103252:                      CanvasGeneralPattern().
 72428:                        ForStyle(mCtx, nsCanvasRenderingContext2DAzure::STYLE_FILL, mCtx->mTarget),
 73032:                      DrawOptions(mState->globalAlpha, mCtx->UsedOperation()));
 72428:       } else if (mOp == nsCanvasRenderingContext2DAzure::TEXT_DRAW_OPERATION_STROKE) {
 72428:         RefPtr<Path> path = scaledFont->GetPathForGlyphs(buffer, mCtx->mTarget);
 72428: 
 72744:         const ContextState& state = *mState;
110995:         AdjustedTarget(mCtx, &bounds)->
103252:           Stroke(path, CanvasGeneralPattern().
 72428:                    ForStyle(mCtx, nsCanvasRenderingContext2DAzure::STYLE_STROKE, mCtx->mTarget),
 72744:                  StrokeOptions(state.lineWidth, state.lineJoin,
 72744:                                state.lineCap, state.miterLimit,
 72744:                                state.dash.Length(),
 72744:                                state.dash.Elements(),
 72744:                                state.dashOffset),
 73032:                  DrawOptions(state.globalAlpha, mCtx->UsedOperation()));
 72428: 
 72428:       }
 72428:     }
 72428:   }
 72428: 
 72428:   // current text run
 86690:   nsAutoPtr<gfxTextRun> mTextRun;
 72428: 
 72428:   // pointer to a screen reference context used to measure text and such
 72428:   nsRefPtr<gfxContext> mThebes;
 72428: 
 72428:   // Pointer to the draw target we should fill our text to
 72428:   nsCanvasRenderingContext2DAzure *mCtx;
 72428: 
 72428:   // position of the left side of the string, alphabetic baseline
 72428:   gfxPoint mPt;
 72428: 
 72428:   // current font
 72428:   gfxFontGroup* mFontgrp;
 72428: 
 72428:   // dev pixel conversion factor
108991:   uint32_t mAppUnitsPerDevPixel;
 72428: 
 72428:   // operation (fill or stroke)
 72428:   nsCanvasRenderingContext2DAzure::TextDrawOperation mOp;
 72428: 
 72428:   // context state
 72744:   ContextState *mState;
 72428: 
 72428:   // union of bounding boxes of all runs, needed for shadows
 72428:   gfxRect mBoundingBox;
 72428: 
 72428:   // true iff the bounding box should be measured
 79445:   bool mDoMeasureBoundingBox;
 72428: };
 72428: 
 72428: nsresult
 72428: nsCanvasRenderingContext2DAzure::DrawOrMeasureText(const nsAString& aRawText,
 72428:                                                    float aX,
 72428:                                                    float aY,
103251:                                                    const Optional<double>& aMaxWidth,
 72428:                                                    TextDrawOperation aOp,
 72428:                                                    float* aWidth)
 72428: {
 72428:   nsresult rv;
 72428: 
103251:   if (!FloatValidate(aX, aY) ||
103251:       (aMaxWidth.WasPassed() && !FloatValidate(aMaxWidth.Value())))
 72428:       return NS_ERROR_DOM_SYNTAX_ERR;
 72428: 
 72428:   // spec isn't clear on what should happen if aMaxWidth <= 0, so
 72428:   // treat it as an invalid argument
 72428:   // technically, 0 should be an invalid value as well, but 0 is the default
 72428:   // arg, and there is no way to tell if the default was used
103251:   if (aMaxWidth.WasPassed() && aMaxWidth.Value() < 0)
 72428:     return NS_ERROR_INVALID_ARG;
 72428: 
101146:   if (!mCanvasElement && !mDocShell) {
101146:     NS_WARNING("Canvas element must be non-null or a docshell must be provided");
 72428:     return NS_ERROR_FAILURE;
 72428:   }
 72428: 
101739:   nsCOMPtr<nsIPresShell> presShell = GetPresShell();
 72428:   if (!presShell)
 72428:     return NS_ERROR_FAILURE;
 72428: 
 72428:   nsIDocument* document = presShell->GetDocument();
 72428: 
 72428:   // replace all the whitespace characters with U+0020 SPACE
 72428:   nsAutoString textToDraw(aRawText);
 72428:   TextReplaceWhitespaceCharacters(textToDraw);
 72428: 
 72428:   // for now, default to ltr if not in doc
 79445:   bool isRTL = false;
 72428: 
101146:   if (mCanvasElement && mCanvasElement->IsInDoc()) {
 72428:     // try to find the closest context
 72428:     nsRefPtr<nsStyleContext> canvasStyle =
101146:       nsComputedDOMStyle::GetStyleContextForElement(mCanvasElement,
106838:                                                     nullptr,
 72428:                                                     presShell);
 72428:     if (!canvasStyle) {
 72428:       return NS_ERROR_FAILURE;
 72428:     }
 72428: 
 72428:     isRTL = canvasStyle->GetStyleVisibility()->mDirection ==
 72428:       NS_STYLE_DIRECTION_RTL;
 72428:   } else {
 72428:     isRTL = GET_BIDI_OPTION_DIRECTION(document->GetBidiOptions()) == IBMBIDI_TEXTDIRECTION_RTL;
 72428:   }
 72428: 
111213:   gfxFontGroup* currentFontStyle = GetCurrentFontStyle();
111213:   NS_ASSERTION(currentFontStyle, "font group is null");
111213: 
111213:   if (currentFontStyle->GetStyle()->size == 0.0F) {
111213:     if (aWidth) {
111213:       *aWidth = 0;
111213:     }
111213:     return NS_OK;
111213:   }
111213: 
 72438:   const ContextState &state = CurrentState();
 72428: 
 72428:   // This is only needed to know if we can know the drawing bounding box easily.
 79445:   bool doDrawShadow = aOp == TEXT_DRAW_OPERATION_FILL && NeedToDrawShadow();
 72428: 
 72428:   nsCanvasBidiProcessorAzure processor;
 72428: 
106838:   GetAppUnitsValues(&processor.mAppUnitsPerDevPixel, nullptr);
 72428:   processor.mPt = gfxPoint(aX, aY);
 72428:   processor.mThebes =
 72428:     new gfxContext(gfxPlatform::GetPlatform()->ScreenReferenceSurface());
 72428:   Matrix matrix = mTarget->GetTransform();
 72428:   processor.mThebes->SetMatrix(gfxMatrix(matrix._11, matrix._12, matrix._21, matrix._22, matrix._31, matrix._32));
 72428:   processor.mCtx = this;
 72428:   processor.mOp = aOp;
 72428:   processor.mBoundingBox = gfxRect(0, 0, 0, 0);
 72428:   processor.mDoMeasureBoundingBox = doDrawShadow || !mIsEntireFrameInvalid;
 72428:   processor.mState = &CurrentState();
111213:   processor.mFontgrp = currentFontStyle;
 72428:     
 72880:   nscoord totalWidthCoord;
 72428: 
 72428:   // calls bidi algo twice since it needs the full text width and the
 72428:   // bounding boxes before rendering anything
 73724:   nsBidi bidiEngine;
 73724:   rv = nsBidiPresUtils::ProcessText(textToDraw.get(),
 72428:                                     textToDraw.Length(),
 72428:                                     isRTL ? NSBIDI_RTL : NSBIDI_LTR,
 72428:                                     presShell->GetPresContext(),
 72428:                                     processor,
 72428:                                     nsBidiPresUtils::MODE_MEASURE,
106838:                                     nullptr,
 72428:                                     0,
 73724:                                     &totalWidthCoord,
 73724:                                     &bidiEngine);
 72428:   if (NS_FAILED(rv)) {
 72428:     return rv;
 72428:   }
 72428: 
 72880:   float totalWidth = float(totalWidthCoord) / processor.mAppUnitsPerDevPixel;
 72428:   if (aWidth) {
 72880:     *aWidth = totalWidth;
 72428:   }
 72428: 
 72428:   // if only measuring, don't need to do any more work
 72428:   if (aOp==TEXT_DRAW_OPERATION_MEASURE) {
 72428:     return NS_OK;
 72428:   }
 72428: 
 72428:   // offset pt.x based on text align
 72428:   gfxFloat anchorX;
 72428: 
 72428:   if (state.textAlign == TEXT_ALIGN_CENTER) {
 72428:     anchorX = .5;
 72428:   } else if (state.textAlign == TEXT_ALIGN_LEFT ||
 72428:             (!isRTL && state.textAlign == TEXT_ALIGN_START) ||
 72428:             (isRTL && state.textAlign == TEXT_ALIGN_END)) {
 72428:     anchorX = 0;
 72428:   } else {
 72428:     anchorX = 1;
 72428:   }
 72428: 
 72428:   processor.mPt.x -= anchorX * totalWidth;
 72428: 
 72428:   // offset pt.y based on text baseline
 97471:   processor.mFontgrp->UpdateFontList(); // ensure user font generation is current
 72428:   NS_ASSERTION(processor.mFontgrp->FontListLength()>0, "font group contains no fonts");
 72428:   const gfxFont::Metrics& fontMetrics = processor.mFontgrp->GetFontAt(0)->GetMetrics();
 72428: 
 72428:   gfxFloat anchorY;
 72428: 
 72428:   switch (state.textBaseline)
 72428:   {
 72428:   case TEXT_BASELINE_HANGING:
 72428:       // fall through; best we can do with the information available
 72428:   case TEXT_BASELINE_TOP:
 72428:     anchorY = fontMetrics.emAscent;
 72428:     break;
 72428:   case TEXT_BASELINE_MIDDLE:
 72428:     anchorY = (fontMetrics.emAscent - fontMetrics.emDescent) * .5f;
 72428:     break;
 72428:   case TEXT_BASELINE_IDEOGRAPHIC:
 72428:     // fall through; best we can do with the information available
 72428:   case TEXT_BASELINE_ALPHABETIC:
 72428:     anchorY = 0;
 72428:     break;
 72428:   case TEXT_BASELINE_BOTTOM:
 72428:     anchorY = -fontMetrics.emDescent;
 72428:     break;
103359:   default:
103359:       MOZ_NOT_REACHED("unexpected TextBaseline");
 72428:   }
 72428: 
 72428:   processor.mPt.y += anchorY;
 72428: 
 72428:   // correct bounding box to get it to be the correct size/position
 72428:   processor.mBoundingBox.width = totalWidth;
 72428:   processor.mBoundingBox.MoveBy(processor.mPt);
 72428: 
 72428:   processor.mPt.x *= processor.mAppUnitsPerDevPixel;
 72428:   processor.mPt.y *= processor.mAppUnitsPerDevPixel;
 72428: 
 72428:   Matrix oldTransform = mTarget->GetTransform();
 72428:   // if text is over aMaxWidth, then scale the text horizontally such that its
 72428:   // width is precisely aMaxWidth
103251:   if (aMaxWidth.WasPassed() && aMaxWidth.Value() > 0 &&
103251:       totalWidth > aMaxWidth.Value()) {
 72428:     Matrix newTransform = oldTransform;
 72428: 
 72428:     // Translate so that the anchor point is at 0,0, then scale and then
 72428:     // translate back.
 72428:     newTransform.Translate(aX, 0);
103251:     newTransform.Scale(aMaxWidth.Value() / totalWidth, 1);
 72428:     newTransform.Translate(-aX, 0);
 72428:     /* we do this to avoid an ICE in the android compiler */
 72428:     Matrix androidCompilerBug = newTransform;
 72428:     mTarget->SetTransform(androidCompilerBug);
 72428:   }
 72428: 
 72428:   // save the previous bounding box
 72428:   gfxRect boundingBox = processor.mBoundingBox;
 72428: 
 72428:   // don't ever need to measure the bounding box twice
 80486:   processor.mDoMeasureBoundingBox = false;
 72428: 
 73724:   rv = nsBidiPresUtils::ProcessText(textToDraw.get(),
 72428:                                     textToDraw.Length(),
 72428:                                     isRTL ? NSBIDI_RTL : NSBIDI_LTR,
 72428:                                     presShell->GetPresContext(),
 72428:                                     processor,
 72428:                                     nsBidiPresUtils::MODE_DRAW,
106838:                                     nullptr,
 72428:                                     0,
106838:                                     nullptr,
 73724:                                     &bidiEngine);
 72428: 
 72428: 
 72428:   mTarget->SetTransform(oldTransform);
 72428: 
103251:   if (aOp == nsCanvasRenderingContext2DAzure::TEXT_DRAW_OPERATION_FILL &&
103251:       !doDrawShadow) {
103251:     RedrawUser(boundingBox);
103251:     return NS_OK;
103251:   }
103251: 
103251:   Redraw();
103251:   return NS_OK;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::SetTextStyle(const nsAString& textStyle)
 72428: {
103251:   ErrorResult rv;
103251:   SetMozTextStyle(textStyle, rv);
103251:   return rv.ErrorCode();
 72428: }
 72428: 
 72428: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::GetTextStyle(nsAString& textStyle)
 72428: {
103251:   GetMozTextStyle(textStyle);
103251:   return NS_OK;
 72428: }
 72428: 
 72428: gfxFontGroup *nsCanvasRenderingContext2DAzure::GetCurrentFontStyle()
 72428: {
 72428:   // use lazy initilization for the font group since it's rather expensive
 72428:   if (!CurrentState().fontGroup) {
103251:     nsresult rv = SetMozFont(kDefaultFontStyle);
 72428:     if (NS_FAILED(rv)) {
 72428:       gfxFontStyle style;
 72428:       style.size = kDefaultFontSize;
 72428:       CurrentState().fontGroup =
 72428:         gfxPlatform::GetPlatform()->CreateFontGroup(kDefaultFontName,
 72428:                                                     &style,
106838:                                                     nullptr);
 72428:       if (CurrentState().fontGroup) {
 72428:         CurrentState().font = kDefaultFontStyle;
 72428:         rv = NS_OK;
 72428:       } else {
 72428:         rv = NS_ERROR_OUT_OF_MEMORY;
 72428:       }
 72428:     }
 72428:             
 72428:     NS_ASSERTION(NS_SUCCEEDED(rv), "Default canvas font is invalid");
 72428:   }
 72428: 
 72428:   return CurrentState().fontGroup;
 72428: }
 72428: 
 72428: //
 72428: // line caps/joins
 72428: //
103251: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::SetLineWidth(float width)
 72428: {
103251:   SetLineWidth((double)width);
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::GetLineWidth(float *width)
 72428: {
103251:   *width = GetLineWidth();
 72428:   return NS_OK;
 72428: }
 72428: 
103251: void
 72428: nsCanvasRenderingContext2DAzure::SetLineCap(const nsAString& capstyle)
 72428: {
 72428:   CapStyle cap;
 72428: 
 72428:   if (capstyle.EqualsLiteral("butt")) {
 72428:     cap = CAP_BUTT;
 72428:   } else if (capstyle.EqualsLiteral("round")) {
 72428:     cap = CAP_ROUND;
 72428:   } else if (capstyle.EqualsLiteral("square")) {
 72428:     cap = CAP_SQUARE;
 72428:   } else {
 72428:     // XXX ERRMSG we need to report an error to developers here! (bug 329026)
103251:     return;
103251:   }
103251: 
103251:   CurrentState().lineCap = cap;
103251: }
103251: 
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::SetMozLineCap(const nsAString& capstyle)
103251: {
103251:   SetLineCap(capstyle);
103101:   return NS_OK;
103059: }
103059: 
103251: void
 72428: nsCanvasRenderingContext2DAzure::GetLineCap(nsAString& capstyle)
 72428: {
 72428:   switch (CurrentState().lineCap) {
 72428:   case CAP_BUTT:
 72428:     capstyle.AssignLiteral("butt");
 72428:     break;
 72428:   case CAP_ROUND:
 72428:     capstyle.AssignLiteral("round");
 72428:     break;
 72428:   case CAP_SQUARE:
 72428:     capstyle.AssignLiteral("square");
 72428:     break;
 72428:   }
103251: }
103251: 
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::GetMozLineCap(nsAString& capstyle)
103251: {
103251:   GetLineCap(capstyle);
103101:   return NS_OK;
103059: }
103059: 
103251: void
 72428: nsCanvasRenderingContext2DAzure::SetLineJoin(const nsAString& joinstyle)
 72428: {
 72428:   JoinStyle j;
 72428: 
 72428:   if (joinstyle.EqualsLiteral("round")) {
 72428:     j = JOIN_ROUND;
 72428:   } else if (joinstyle.EqualsLiteral("bevel")) {
 72428:     j = JOIN_BEVEL;
 72428:   } else if (joinstyle.EqualsLiteral("miter")) {
 72428:     j = JOIN_MITER_OR_BEVEL;
 72428:   } else {
 72428:     // XXX ERRMSG we need to report an error to developers here! (bug 329026)
103251:     return;
103251:   }
103251: 
103251:   CurrentState().lineJoin = j;
103251: }
103251: 
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::SetMozLineJoin(const nsAString& joinstyle)
103251: {
103251:   SetLineJoin(joinstyle);
103101:   return NS_OK;
103059: }
103059: 
103251: void
103251: nsCanvasRenderingContext2DAzure::GetLineJoin(nsAString& joinstyle, ErrorResult& error)
 72428: {
 72428:   switch (CurrentState().lineJoin) {
 72428:   case JOIN_ROUND:
 72428:     joinstyle.AssignLiteral("round");
 72428:     break;
 72428:   case JOIN_BEVEL:
 72428:     joinstyle.AssignLiteral("bevel");
 72428:     break;
 72428:   case JOIN_MITER_OR_BEVEL:
 72428:     joinstyle.AssignLiteral("miter");
 72428:     break;
 72428:   default:
103251:     error.Throw(NS_ERROR_FAILURE);
103251:   }
103251: }
103251: 
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::GetMozLineJoin(nsAString& joinstyle)
103251: {
103251:   ErrorResult rv;
103251:   nsString linejoin;
103251:   GetLineJoin(linejoin, rv);
103251:   if (!rv.Failed()) {
103251:     joinstyle = linejoin;
103251:   }
103251:   return rv.ErrorCode();
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::SetMiterLimit(float miter)
 72428: {
103251:   SetMiterLimit((double)miter);
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::GetMiterLimit(float *miter)
 72428: {
103251:   *miter = GetMiterLimit();
 72428:   return NS_OK;
 72428: }
 72428: 
103251: void
103251: nsCanvasRenderingContext2DAzure::SetMozDash(JSContext* cx,
103251:                                             const JS::Value& mozDash,
103251:                                             ErrorResult& error)
 72744: {
 72744:   FallibleTArray<Float> dash;
103251:   error = JSValToDashArray(cx, mozDash, dash);
103251:   if (!error.Failed()) {
 72744:     ContextState& state = CurrentState();
 72744:     state.dash = dash;
 72744:     if (state.dash.IsEmpty()) {
 72744:       state.dashOffset = 0;
 72744:     }
 72744:   }
103251: }
103251: 
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::SetMozDash(JSContext *cx, const jsval& patternArray)
103251: {
103251:   ErrorResult rv;
103251:   SetMozDash(cx, patternArray, rv);
103251:   return rv.ErrorCode();
103251: }
103251: 
103251: JS::Value
103251: nsCanvasRenderingContext2DAzure::GetMozDash(JSContext* cx, ErrorResult& error)
103251: {
103251:   JS::Value mozDash;
107551:   error = DashArrayToJSVal(CurrentState().dash, cx, &mozDash);
103251:   return mozDash;
 72744: }
 72744: 
 72744: NS_IMETHODIMP
 72744: nsCanvasRenderingContext2DAzure::GetMozDash(JSContext* cx, jsval* dashArray)
 72744: {
103251:   ErrorResult rv;
103251:   *dashArray = GetMozDash(cx, rv);
103251:   return rv.ErrorCode();
 72744: }
 72744:  
 72744: NS_IMETHODIMP
 72744: nsCanvasRenderingContext2DAzure::SetMozDashOffset(float offset)
 72744: {
 72744:   if (!FloatValidate(offset)) {
 72744:     return NS_ERROR_ILLEGAL_VALUE;
 72744:   }
 72744:   ContextState& state = CurrentState();
 72744:   if (!state.dash.IsEmpty()) {
 72744:     state.dashOffset = offset;
 72744:   }
 72744:   return NS_OK;
 72744: }
 72744:  
 72744: NS_IMETHODIMP
 72744: nsCanvasRenderingContext2DAzure::GetMozDashOffset(float* offset)
 72744: {
103251:   *offset = GetMozDashOffset();
 72744:   return NS_OK;
 72744: }
 72744: 
103251: bool
103251: nsCanvasRenderingContext2DAzure::IsPointInPath(double x, double y)
103251: {
103251:   if (!FloatValidate(x,y)) {
103251:     return false;
103251:   }
103251: 
106604:   EnsureUserSpacePath(false);
106604:   if (!mPath) {
106604:     return false;
106604:   }
106604:   if (mPathTransformWillUpdate) {
106604:     return mPath->ContainsPoint(Point(x, y), mPathToDS);
106604:   }
106604:   return mPath->ContainsPoint(Point(x, y), mTarget->GetTransform());
103251: }
103251: 
 72744: NS_IMETHODIMP
 79445: nsCanvasRenderingContext2DAzure::IsPointInPath(float x, float y, bool *retVal)
 72428: {
103251:   *retVal = IsPointInPath(x, y);
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: //
 72428: // image
 72428: //
 72428: 
 72428: // drawImage(in HTMLImageElement image, in float dx, in float dy);
 72428: //   -- render image from 0,0 at dx,dy top-left coords
 72428: // drawImage(in HTMLImageElement image, in float dx, in float dy, in float sw, in float sh);
 72428: //   -- render image from 0,0 at dx,dy top-left coords clipping it to sw,sh
 72428: // drawImage(in HTMLImageElement image, in float sx, in float sy, in float sw, in float sh, in float dx, in float dy, in float dw, in float dh);
 72428: //   -- render the region defined by (sx,sy,sw,wh) in image-local space into the region (dx,dy,dw,dh) on the canvas
 72428: 
103251: // If only dx and dy are passed in then optional_argc should be 0. If only
103251: // dx, dy, dw and dh are passed in then optional_argc should be 2. The only
103251: // other valid value for optional_argc is 6 if sx, sy, sw, sh, dx, dy, dw and dh
103251: // are all passed in.
103251: 
103251: void
103251: nsCanvasRenderingContext2DAzure::DrawImage(const HTMLImageOrCanvasOrVideoElement& image,
103251:                                            double sx, double sy, double sw,
103251:                                            double sh, double dx, double dy,
103251:                                            double dw, double dh, 
108991:                                            uint8_t optional_argc,
103251:                                            ErrorResult& error)
 72428: {
103251:   MOZ_ASSERT(optional_argc == 0 || optional_argc == 2 || optional_argc == 6);
 72428: 
 84360:   RefPtr<SourceSurface> srcSurf;
 84360:   gfxIntSize imgSize;
 84360: 
103251:   Element* element;
103251:   if (image.IsHTMLCanvasElement()) {
103251:     nsHTMLCanvasElement* canvas = image.GetAsHTMLCanvasElement();
103251:     element = canvas;
 72428:     nsIntSize size = canvas->GetSize();
 72428:     if (size.width == 0 || size.height == 0) {
103251:       error.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
103251:       return;
 72428:     }
 84360: 
 84360:     // Special case for Canvas, which could be an Azure canvas!
 84360:     nsICanvasRenderingContextInternal *srcCanvas = canvas->GetContextAtIndex(0);
 84360:     if (srcCanvas == this) {
 72428:       // Self-copy.
 72428:       srcSurf = mTarget->Snapshot();
 72428:       imgSize = gfxIntSize(mWidth, mHeight);
 84360:     } else if (srcCanvas) {
 79781:       // This might not be an Azure canvas!
 79781:       srcSurf = srcCanvas->GetSurfaceSnapshot();
 79781: 
106613:       if (srcSurf) {
106613:         if (mCanvasElement) {
 79781:           // Do security check here.
101146:           CanvasUtils::DoDrawImageSecurityCheck(mCanvasElement,
103251:                                                 element->NodePrincipal(),
103251:                                                canvas->IsWriteOnly(),
 79781:                                                 false);
106613:         }
 79781:         imgSize = gfxIntSize(srcSurf->GetSize().width, srcSurf->GetSize().height);
 79781:       }
 79781:     }
 84360:   } else {
103251:     if (image.IsHTMLImageElement()) {
103251:       nsHTMLImageElement* img = image.GetAsHTMLImageElement();
103251:       element = img;
103251:     } else {
103251:       nsHTMLVideoElement* video = image.GetAsHTMLVideoElement();
103251:       element = video;
103251:     }
103251: 
 84360:     gfxASurface* imgsurf =
103325:       CanvasImageCache::Lookup(element, mCanvasElement, &imgSize);
 84360:     if (imgsurf) {
 84360:       srcSurf = gfxPlatform::GetPlatform()->GetSourceSurfaceForSurface(mTarget, imgsurf);
 79781:     }
 79781:   }
 79781: 
 72428:   if (!srcSurf) {
 72428:     // The canvas spec says that drawImage should draw the first frame
 72428:     // of animated images
108991:     uint32_t sfeFlags = nsLayoutUtils::SFE_WANT_FIRST_FRAME;
 72428:     nsLayoutUtils::SurfaceFromElementResult res =
103251:       nsLayoutUtils::SurfaceFromElement(element, sfeFlags);
 72428: 
 72428:     if (!res.mSurface) {
 72428:       // Spec says to silently do nothing if the element is still loading.
103251:       if (!res.mIsStillLoading) {
103251:         error.Throw(NS_ERROR_NOT_AVAILABLE);
103251:       }
103251:       return;
 72428:     }
 72428: 
 82454:     // Ignore cairo surfaces that are bad! See bug 666312.
 82454:     if (res.mSurface->CairoStatus()) {
103251:       return;
 72428:     }
 72428: 
 72428:     imgSize = res.mSize;
 72428: 
 72428:     if (mCanvasElement) {
101146:       CanvasUtils::DoDrawImageSecurityCheck(mCanvasElement,
 78159:                                             res.mPrincipal, res.mIsWriteOnly,
 78159:                                             res.mCORSUsed);
 72428:     }
 72428: 
 72428:     if (res.mImageRequest) {
103325:       CanvasImageCache::NotifyDrawImage(element, mCanvasElement,
 84360:                                         res.mImageRequest, res.mSurface, imgSize);
 84360:     }
 84360: 
 84360:     srcSurf = gfxPlatform::GetPlatform()->GetSourceSurfaceForSurface(mTarget, res.mSurface);
 72428:   }
 72428: 
 72428:   if (optional_argc == 0) {
 72428:     sx = sy = 0.0;
 72428:     dw = sw = (double) imgSize.width;
 72428:     dh = sh = (double) imgSize.height;
 72428:   } else if (optional_argc == 2) {
 72428:     sx = sy = 0.0;
 72428:     sw = (double) imgSize.width;
 72428:     sh = (double) imgSize.height;
 72428:   }
 72428: 
 72428:   if (dw == 0.0 || dh == 0.0) {
 72428:     // not really failure, but nothing to do --
 72428:     // and noone likes a divide-by-zero
103251:     return;
 72428:   }
 72428: 
 74273:   if (sx < 0.0 || sy < 0.0 ||
 74273:       sw < 0.0 || sw > (double) imgSize.width ||
 74273:       sh < 0.0 || sh > (double) imgSize.height ||
 74273:       dw < 0.0 || dh < 0.0) {
 74273:     // XXX - Unresolved spec issues here, for now return error.
103251:     error.Throw(NS_ERROR_DOM_INDEX_SIZE_ERR);
103251:     return;
 72428:   }
 72428: 
 72428:   Filter filter;
 72428: 
 72428:   if (CurrentState().imageSmoothingEnabled)
 72428:     filter = mgfx::FILTER_LINEAR;
 72428:   else
 72428:     filter = mgfx::FILTER_POINT;
 72428: 
 73777:   mgfx::Rect bounds;
 73777:   
 73777:   if (NeedToDrawShadow()) {
 73777:     bounds = mgfx::Rect(dx, dy, dw, dh);
 73777:     bounds = mTarget->GetTransform().TransformBounds(bounds);
 73777:   }
 73777: 
106838:   AdjustedTarget(this, bounds.IsEmpty() ? nullptr : &bounds)->
 72428:     DrawSurface(srcSurf,
 72428:                 mgfx::Rect(dx, dy, dw, dh),
 72428:                 mgfx::Rect(sx, sy, sw, sh),
 72428:                 DrawSurfaceOptions(filter),
 73032:                 DrawOptions(CurrentState().globalAlpha, UsedOperation()));
 72428: 
103251:   RedrawUser(gfxRect(dx, dy, dw, dh));
 72428: }
 72428: 
 72428: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::DrawImage(nsIDOMElement *imgElt, float a1,
103251:                                            float a2, float a3, float a4, float a5,
103251:                                            float a6, float a7, float a8,
108991:                                            uint8_t optional_argc)
103251: {
103251:   if (!(optional_argc == 0 || optional_argc == 2 || optional_argc == 6)) {
103251:     return NS_ERROR_INVALID_ARG;
103251:   }
103251: 
103251:   HTMLImageOrCanvasOrVideoElement element;
103251:   if (!ToHTMLImageOrCanvasOrVideoElement(imgElt, element)) {
103251:     return NS_ERROR_DOM_TYPE_MISMATCH_ERR;
103251:   }
103251: 
103251:   ErrorResult rv;
103251:   if (optional_argc == 0) {
103251:     if (!FloatValidate(a1, a2)) {
103251:       return NS_OK;
103251:     }
103251:     DrawImage(element, 0, 0, 0, 0, a1, a2, 0, 0, 0, rv);
103251:   } else if (optional_argc == 2) {
103251:     if (!FloatValidate(a1, a2, a3, a4)) {
103251:       return NS_OK;
103251:     }
103251:     DrawImage(element, 0, 0, 0, 0, a1, a2, a3, a4, 2, rv);
103251:   } else if (optional_argc == 6) {
103251:     if (!FloatValidate(a1, a2, a3, a4) || !FloatValidate(a5, a6, a7, a8)) {
103251:       return NS_OK;
103251:     }
103251:     DrawImage(element, a1, a2, a3, a4, a5, a6, a7, a8, 6, rv);
103251:   }
103251:   return rv.ErrorCode();
103251: }
103251: 
103251: void
103251: nsCanvasRenderingContext2DAzure::SetGlobalCompositeOperation(const nsAString& op,
103251:                                                              ErrorResult& error)
 72428: {
 72428:   CompositionOp comp_op;
 72428: 
 72428: #define CANVAS_OP_TO_GFX_OP(cvsop, op2d) \
 72428:   if (op.EqualsLiteral(cvsop))   \
 72428:     comp_op = OP_##op2d;
 72428: 
 72428:   CANVAS_OP_TO_GFX_OP("copy", SOURCE)
 72428:   else CANVAS_OP_TO_GFX_OP("source-atop", ATOP)
 72428:   else CANVAS_OP_TO_GFX_OP("source-in", IN)
 72428:   else CANVAS_OP_TO_GFX_OP("source-out", OUT)
 72428:   else CANVAS_OP_TO_GFX_OP("source-over", OVER)
 72428:   else CANVAS_OP_TO_GFX_OP("destination-in", DEST_IN)
 72428:   else CANVAS_OP_TO_GFX_OP("destination-out", DEST_OUT)
 72428:   else CANVAS_OP_TO_GFX_OP("destination-over", DEST_OVER)
 72428:   else CANVAS_OP_TO_GFX_OP("destination-atop", DEST_ATOP)
 72428:   else CANVAS_OP_TO_GFX_OP("lighter", ADD)
 72428:   else CANVAS_OP_TO_GFX_OP("xor", XOR)
 72428:   // XXX ERRMSG we need to report an error to developers here! (bug 329026)
103251:   else return;
 72428: 
 72428: #undef CANVAS_OP_TO_GFX_OP
 72428:   CurrentState().op = comp_op;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::SetGlobalCompositeOperation(const nsAString& op)
103251: {
103251:   ErrorResult rv;
103251:   SetGlobalCompositeOperation(op, rv);
103251:   return rv.ErrorCode();
103251: }
103251: 
103251: void
103251: nsCanvasRenderingContext2DAzure::GetGlobalCompositeOperation(nsAString& op,
103251:                                                              ErrorResult& error)
 72428: {
 72428:   CompositionOp comp_op = CurrentState().op;
 72428: 
 72428: #define CANVAS_OP_TO_GFX_OP(cvsop, op2d) \
 72428:   if (comp_op == OP_##op2d) \
 72428:     op.AssignLiteral(cvsop);
 72428: 
 72428:   CANVAS_OP_TO_GFX_OP("copy", SOURCE)
 72428:   else CANVAS_OP_TO_GFX_OP("destination-atop", DEST_ATOP)
 72428:   else CANVAS_OP_TO_GFX_OP("destination-in", DEST_IN)
 72428:   else CANVAS_OP_TO_GFX_OP("destination-out", DEST_OUT)
 72428:   else CANVAS_OP_TO_GFX_OP("destination-over", DEST_OVER)
 72428:   else CANVAS_OP_TO_GFX_OP("lighter", ADD)
 72428:   else CANVAS_OP_TO_GFX_OP("source-atop", ATOP)
 72428:   else CANVAS_OP_TO_GFX_OP("source-in", IN)
 72428:   else CANVAS_OP_TO_GFX_OP("source-out", OUT)
 72428:   else CANVAS_OP_TO_GFX_OP("source-over", OVER)
 72428:   else CANVAS_OP_TO_GFX_OP("xor", XOR)
103251:   else {
103251:     error.Throw(NS_ERROR_FAILURE);
103251:   }
 72428: 
 72428: #undef CANVAS_OP_TO_GFX_OP
 72428: }
 72428: 
 72428: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::GetGlobalCompositeOperation(nsAString& op)
 72428: {
103251:   nsString globalCompositeOperation;
103251:   ErrorResult rv;
103251:   GetGlobalCompositeOperation(globalCompositeOperation, rv);
103251:   if (!rv.Failed()) {
103251:     op = globalCompositeOperation;
103251:   }
103251:   return rv.ErrorCode();
103251: }
103251: 
103251: void
103251: nsCanvasRenderingContext2DAzure::DrawWindow(nsIDOMWindow* window, double x,
103251:                                             double y, double w, double h,
103251:                                             const nsAString& bgColor,
103251:                                             uint32_t flags, ErrorResult& error)
103251: {
 72428:   // protect against too-large surfaces that will cause allocation
 72428:   // or overflow issues
108991:   if (!gfxASurface::CheckSurfaceSize(gfxIntSize(int32_t(w), int32_t(h)),
103251:                                      0xffff)) {
103251:     error.Throw(NS_ERROR_FAILURE);
103251:     return;
103251:   }
 72428: 
 72428:   nsRefPtr<gfxASurface> drawSurf;
 72428:   GetThebesSurface(getter_AddRefs(drawSurf));
 72428: 
 72428:   nsRefPtr<gfxContext> thebes = new gfxContext(drawSurf);
 72428: 
 72428:   Matrix matrix = mTarget->GetTransform();
 72428:   thebes->SetMatrix(gfxMatrix(matrix._11, matrix._12, matrix._21,
 72428:                               matrix._22, matrix._31, matrix._32));
 72428: 
 72428:   // We can't allow web apps to call this until we fix at least the
 72428:   // following potential security issues:
 72428:   // -- rendering cross-domain IFRAMEs and then extracting the results
 72428:   // -- rendering the user's theme and then extracting the results
 72428:   // -- rendering native anonymous content (e.g., file input paths;
 72428:   // scrollbars should be allowed)
 72428:   if (!nsContentUtils::IsCallerTrustedForRead()) {
 72428:     // not permitted to use DrawWindow
 72428:     // XXX ERRMSG we need to report an error to developers here! (bug 329026)
103251:     error.Throw(NS_ERROR_DOM_SECURITY_ERR);
103251:     return;
 72428:   }
 72428: 
 72428:   // Flush layout updates
 72428:   if (!(flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_DO_NOT_FLUSH))
103251:     nsContentUtils::FlushLayoutForTree(window);
 72428: 
 72428:   nsRefPtr<nsPresContext> presContext;
103251:   nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(window);
 72428:   if (win) {
 72428:     nsIDocShell* docshell = win->GetDocShell();
 72428:     if (docshell) {
 72428:       docshell->GetPresContext(getter_AddRefs(presContext));
 72428:     }
 72428:   }
103251:   if (!presContext) {
103251:     error.Throw(NS_ERROR_FAILURE);
103251:     return;
103251:   }
103251: 
103251:   nscolor backgroundColor;
103251:   if (!ParseColor(bgColor, &backgroundColor)) {
103251:     error.Throw(NS_ERROR_FAILURE);
103251:     return;
103251:   }
103251: 
103251:   nsRect r(nsPresContext::CSSPixelsToAppUnits((float)x),
103251:            nsPresContext::CSSPixelsToAppUnits((float)y),
103251:            nsPresContext::CSSPixelsToAppUnits((float)w),
103251:            nsPresContext::CSSPixelsToAppUnits((float)h));
108991:   uint32_t renderDocFlags = (nsIPresShell::RENDER_IGNORE_VIEWPORT_SCROLLING |
 72428:                              nsIPresShell::RENDER_DOCUMENT_RELATIVE);
 72428:   if (flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_DRAW_CARET) {
 72428:     renderDocFlags |= nsIPresShell::RENDER_CARET;
 72428:   }
 72428:   if (flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_DRAW_VIEW) {
 72428:     renderDocFlags &= ~(nsIPresShell::RENDER_IGNORE_VIEWPORT_SCROLLING |
 72428:                         nsIPresShell::RENDER_DOCUMENT_RELATIVE);
 72428:   }
 72428:   if (flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_USE_WIDGET_LAYERS) {
 72428:     renderDocFlags |= nsIPresShell::RENDER_USE_WIDGET_LAYERS;
 72428:   }
 72428:   if (flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_ASYNC_DECODE_IMAGES) {
 72428:     renderDocFlags |= nsIPresShell::RENDER_ASYNC_DECODE_IMAGES;
 72428:   }
 72428: 
101129:   unused << presContext->PresShell()->
103251:     RenderDocument(r, renderDocFlags, backgroundColor, thebes);
103251: 
103251:   // note that x and y are coordinates in the document that
103251:   // we're drawing; x and y are drawn to 0,0 in current user
 72428:   // space.
103251:   RedrawUser(gfxRect(0, 0, w, h));
 72428: }
 72428: 
 72428: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::DrawWindow(nsIDOMWindow* aWindow, float aX, float aY,
 72428:                                             float aW, float aH,
 72428:                                             const nsAString& aBGColor,
108991:                                             uint32_t flags)
 72428: {
103251:   NS_ENSURE_ARG(aWindow);
103251: 
103251:   ErrorResult rv;
103251:   DrawWindow(aWindow, aX, aY, aW, aH, aBGColor, flags, rv);
103251:   return rv.ErrorCode();
103251: }
103251: 
103251: void
103251: nsCanvasRenderingContext2DAzure::AsyncDrawXULElement(nsIDOMXULElement* elem,
103251:                                                      double x, double y,
103251:                                                      double w, double h,
103251:                                                      const nsAString& bgColor,
103251:                                                      uint32_t flags,
103251:                                                      ErrorResult& error)
103251: {
 72428:   // We can't allow web apps to call this until we fix at least the
 72428:   // following potential security issues:
 72428:   // -- rendering cross-domain IFRAMEs and then extracting the results
 72428:   // -- rendering the user's theme and then extracting the results
 72428:   // -- rendering native anonymous content (e.g., file input paths;
 72428:   // scrollbars should be allowed)
 72428:   if (!nsContentUtils::IsCallerTrustedForRead()) {
 72428:       // not permitted to use DrawWindow
 72428:       // XXX ERRMSG we need to report an error to developers here! (bug 329026)
103251:     error.Throw(NS_ERROR_DOM_SECURITY_ERR);
103251:     return;
 72428:   }
 72428: 
 73023: #if 0
103251:   nsCOMPtr<nsIFrameLoaderOwner> loaderOwner = do_QueryInterface(elem);
103251:   if (!loaderOwner) {
103251:     error.Throw(NS_ERROR_FAILURE);
103251:     return;
103251:   }
 72428: 
 72428:   nsRefPtr<nsFrameLoader> frameloader = loaderOwner->GetFrameLoader();
103251:   if (!frameloader) {
103251:     error.Throw(NS_ERROR_FAILURE);
103251:     return;
103251:   }
 72428: 
 72428:   PBrowserParent *child = frameloader->GetRemoteBrowser();
 72428:   if (!child) {
 72428:     nsCOMPtr<nsIDOMWindow> window =
 72428:       do_GetInterface(frameloader->GetExistingDocShell());
103251:     if (!window) {
103251:       error.Throw(NS_ERROR_FAILURE);
103251:       return;
103251:     }
103251: 
103251:     return DrawWindow(window, x, y, w, h, bgColor, flags);
 72428:   }
 72428: 
 72428:   // protect against too-large surfaces that will cause allocation
 72428:   // or overflow issues
103251:   if (!gfxASurface::CheckSurfaceSize(gfxIntSize(w, h), 0xffff)) {
103251:     error.Throw(NS_ERROR_FAILURE);
103251:     return;
103251:   }
 72428: 
 79445:   bool flush =
 72428:     (flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_DO_NOT_FLUSH) == 0;
 72428: 
108991:   uint32_t renderDocFlags = nsIPresShell::RENDER_IGNORE_VIEWPORT_SCROLLING;
 72428:   if (flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_DRAW_CARET) {
 72428:     renderDocFlags |= nsIPresShell::RENDER_CARET;
 72428:   }
 72428:   if (flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_DRAW_VIEW) {
 72428:     renderDocFlags &= ~nsIPresShell::RENDER_IGNORE_VIEWPORT_SCROLLING;
 72428:   }
 72428: 
103251:   nsRect rect(nsPresContext::CSSPixelsToAppUnits(x),
103251:               nsPresContext::CSSPixelsToAppUnits(y),
103251:               nsPresContext::CSSPixelsToAppUnits(w),
103251:               nsPresContext::CSSPixelsToAppUnits(h));
 72428:   if (mIPC) {
 72428:     PDocumentRendererParent *pdocrender =
 72428:       child->SendPDocumentRendererConstructor(rect,
 72428:                                               mThebes->CurrentMatrix(),
 72428:                                               nsString(aBGColor),
 72428:                                               renderDocFlags, flush,
 72428:                                               nsIntSize(mWidth, mHeight));
 72428:     if (!pdocrender)
 72428:       return NS_ERROR_FAILURE;
 72428: 
 72428:     DocumentRendererParent *docrender =
 72428:       static_cast<DocumentRendererParent *>(pdocrender);
 72428: 
 72428:     docrender->SetCanvasContext(this, mThebes);
 72428:   }
 72428: #endif
103251: }
103251: 
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::AsyncDrawXULElement(nsIDOMXULElement* aElem,
103251:                                                      float aX, float aY,
103251:                                                      float aW, float aH,
103251:                                                      const nsAString& aBGColor,
108991:                                                      uint32_t flags)
103251: {
103251:   NS_ENSURE_ARG(aElem);
103251: 
103251:   ErrorResult rv;
103251:   AsyncDrawXULElement(aElem, aX, aY, aW, aH, aBGColor, flags, rv);
103251:   return rv.ErrorCode();
 72428: }
 72428: 
 72428: //
 72428: // device pixel getting/setting
 72428: //
 72428: 
 72428: void
 72428: nsCanvasRenderingContext2DAzure::EnsureUnpremultiplyTable() {
 72428:   if (sUnpremultiplyTable)
 72428:     return;
 72428: 
 72428:   // Infallably alloc the unpremultiply table.
108991:   sUnpremultiplyTable = new uint8_t[256][256];
 72428: 
 72428:   // It's important that the array be indexed first by alpha and then by rgb
 72428:   // value.  When we unpremultiply a pixel, we're guaranteed to do three
 72428:   // lookups with the same alpha; indexing by alpha first makes it likely that
 72428:   // those three lookups will be close to one another in memory, thus
 72428:   // increasing the chance of a cache hit.
 72428: 
 72428:   // a == 0 case
108991:   for (uint32_t c = 0; c <= 255; c++) {
 72428:     sUnpremultiplyTable[0][c] = c;
 72428:   }
 72428: 
 72428:   for (int a = 1; a <= 255; a++) {
 72428:     for (int c = 0; c <= 255; c++) {
108991:       sUnpremultiplyTable[a][c] = (uint8_t)((c * 255) / a);
 72428:     }
 72428:   }
 72428: }
 72428: 
 72428: 
103251: already_AddRefed<ImageData>
103251: nsCanvasRenderingContext2DAzure::GetImageData(JSContext* aCx, double aSx,
103251:                                               double aSy, double aSw,
103251:                                               double aSh, ErrorResult& error)
 72428: {
111232:   if (!mValid) {
103251:     error.Throw(NS_ERROR_FAILURE);
103251:     return NULL;
103251:   }
 72428: 
 72428:   if (!mCanvasElement && !mDocShell) {
 72428:     NS_ERROR("No canvas element and no docshell in GetImageData!!!");
103251:     error.Throw(NS_ERROR_DOM_SECURITY_ERR);
103251:     return NULL;
 72428:   }
 72428: 
 72428:   // Check only if we have a canvas element; if we were created with a docshell,
 72428:   // then it's special internal use.
101146:   if (mCanvasElement && mCanvasElement->IsWriteOnly() &&
 72428:       !nsContentUtils::IsCallerTrustedForRead())
 72428:   {
 72428:     // XXX ERRMSG we need to report an error to developers here! (bug 329026)
103251:     error.Throw(NS_ERROR_DOM_SECURITY_ERR);
103251:     return NULL;
 72428:   }
 72428: 
 93202:   if (!NS_finite(aSx) || !NS_finite(aSy) ||
 93202:       !NS_finite(aSw) || !NS_finite(aSh)) {
103251:     error.Throw(NS_ERROR_DOM_NOT_SUPPORTED_ERR);
103251:     return NULL;
 93202:   }
 93202: 
 93202:   if (!aSw || !aSh) {
103251:     error.Throw(NS_ERROR_DOM_INDEX_SIZE_ERR);
103251:     return NULL;
 93202:   }
 93202: 
 93202:   int32_t x = JS_DoubleToInt32(aSx);
 93202:   int32_t y = JS_DoubleToInt32(aSy);
 93202:   int32_t wi = JS_DoubleToInt32(aSw);
 93202:   int32_t hi = JS_DoubleToInt32(aSh);
 93202: 
 93202:   // Handle negative width and height by flipping the rectangle over in the
 93202:   // relevant direction.
 93202:   uint32_t w, h;
 93202:   if (aSw < 0) {
 93202:     w = -wi;
 93202:     x -= w;
 93202:   } else {
 93202:     w = wi;
 93202:   }
 93202:   if (aSh < 0) {
 93202:     h = -hi;
 93202:     y -= h;
 93202:   } else {
 93202:     h = hi;
 93202:   }
 93202: 
 93202:   if (w == 0) {
 93202:     w = 1;
 93202:   }
 93202:   if (h == 0) {
 93202:     h = 1;
 93202:   }
 93202: 
 93202:   JSObject* array;
103251:   error = GetImageDataArray(aCx, x, y, w, h, &array);
103251:   if (error.Failed()) {
103251:     return NULL;
103251:   }
 93202:   MOZ_ASSERT(array);
 93202: 
 93202:   nsRefPtr<ImageData> imageData = new ImageData(w, h, *array);
103251:   return imageData.forget();
103251: }
103251: 
103251: NS_IMETHODIMP
103251: nsCanvasRenderingContext2DAzure::GetImageData(double aSx, double aSy,
103251:                                               double aSw, double aSh,
103251:                                               JSContext* aCx,
103251:                                               nsIDOMImageData** aRetval)
103251: {
103251:   ErrorResult rv;
103251:   *aRetval = GetImageData(aCx, aSx, aSy, aSw, aSh, rv).get();
103251:   return rv.ErrorCode();
 93202: }
 93202: 
 93202: nsresult
 93202: nsCanvasRenderingContext2DAzure::GetImageDataArray(JSContext* aCx,
 93202:                                                    int32_t aX,
 93202:                                                    int32_t aY,
 93202:                                                    uint32_t aWidth,
 93202:                                                    uint32_t aHeight,
 93202:                                                    JSObject** aRetval)
 93202: {
 93202:   MOZ_ASSERT(aWidth && aHeight);
 93202: 
 93202:   CheckedInt<uint32_t> len = CheckedInt<uint32_t>(aWidth) * aHeight * 4;
 98543:   if (!len.isValid()) {
 93202:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
 93202:   }
 93202: 
 93202:   CheckedInt<int32_t> rightMost = CheckedInt<int32_t>(aX) + aWidth;
 93202:   CheckedInt<int32_t> bottomMost = CheckedInt<int32_t>(aY) + aHeight;
 93202: 
 98543:   if (!rightMost.isValid() || !bottomMost.isValid()) {
 72428:     return NS_ERROR_DOM_SYNTAX_ERR;
 93202:   }
 93202: 
 95834:   JSObject* darray = JS_NewUint8ClampedArray(aCx, len.value());
 93202:   if (!darray) {
 93202:     return NS_ERROR_OUT_OF_MEMORY;
 93202:   }
 72428: 
 72428:   if (mZero) {
 93202:     *aRetval = darray;
 72428:     return NS_OK;
 72428:   }
 72428: 
 95834:   uint8_t* data = JS_GetUint8ClampedArrayData(darray, aCx);
 93202: 
 72428:   IntRect srcRect(0, 0, mWidth, mHeight);
 93202:   IntRect destRect(aX, aY, aWidth, aHeight);
 72428: 
 72428:   IntRect srcReadRect = srcRect.Intersect(destRect);
 72428:   IntRect dstWriteRect = srcReadRect;
 93202:   dstWriteRect.MoveBy(-aX, -aY);
 93202: 
 93202:   uint8_t* src = data;
 93202:   uint32_t srcStride = aWidth * 4;
 72428:   
 78290:   RefPtr<DataSourceSurface> readback;
 72428:   if (!srcReadRect.IsEmpty()) {
 72428:     RefPtr<SourceSurface> snapshot = mTarget->Snapshot();
106604:     if (snapshot) {
 78290:       readback = snapshot->GetDataSurface();
 72428: 
 72428:       srcStride = readback->Stride();
 72428:       src = readback->GetData() + srcReadRect.y * srcStride + srcReadRect.x * 4;
 72428:     }
106604:   }
 72428: 
 72428:   // make sure sUnpremultiplyTable has been created
 72428:   EnsureUnpremultiplyTable();
 72428: 
 72428:   // NOTE! dst is the same as src, and this relies on reading
 72428:   // from src and advancing that ptr before writing to dst.
106604:   // NOTE! I'm not sure that it is, I think this comment might have been
106604:   // inherited from Thebes canvas and is no longer true
 93202:   uint8_t* dst = data + dstWriteRect.y * (aWidth * 4) + dstWriteRect.x * 4;
 93202: 
 93202:   for (int32_t j = 0; j < dstWriteRect.height; ++j) {
 93202:     for (int32_t i = 0; i < dstWriteRect.width; ++i) {
 72428:       // XXX Is there some useful swizzle MMX we can use here?
 72428: #ifdef IS_LITTLE_ENDIAN
108991:       uint8_t b = *src++;
108991:       uint8_t g = *src++;
108991:       uint8_t r = *src++;
108991:       uint8_t a = *src++;
 72428: #else
108991:       uint8_t a = *src++;
108991:       uint8_t r = *src++;
108991:       uint8_t g = *src++;
108991:       uint8_t b = *src++;
 72428: #endif
 72428:       // Convert to non-premultiplied color
 72428:       *dst++ = sUnpremultiplyTable[a][r];
 72428:       *dst++ = sUnpremultiplyTable[a][g];
 72428:       *dst++ = sUnpremultiplyTable[a][b];
 72428:       *dst++ = a;
 72428:     }
 72428:     src += srcStride - (dstWriteRect.width * 4);
 93202:     dst += (aWidth * 4) - (dstWriteRect.width * 4);
 93202:   }
 93202: 
 93202:   *aRetval = darray;
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: void
 72428: nsCanvasRenderingContext2DAzure::EnsurePremultiplyTable() {
 72428:   if (sPremultiplyTable)
 72428:     return;
 72428: 
 72428:   // Infallably alloc the premultiply table.
108991:   sPremultiplyTable = new uint8_t[256][256];
 72428: 
 72428:   // Like the unpremultiply table, it's important that we index the premultiply
 72428:   // table with the alpha value as the first index to ensure good cache
 72428:   // performance.
 72428: 
 72428:   for (int a = 0; a <= 255; a++) {
 72428:     for (int c = 0; c <= 255; c++) {
 72428:       sPremultiplyTable[a][c] = (a * c + 254) / 255;
 72428:     }
 72428:   }
 72428: }
 72428: 
 72428: void
 72428: nsCanvasRenderingContext2DAzure::FillRuleChanged()
 72428: {
 72428:   if (mPath) {
 72428:     mPathBuilder = mPath->CopyToBuilder(CurrentState().fillRule);
106838:     mPath = nullptr;
 72428:   }
 72428: }
 72428: 
103251: void
103251: nsCanvasRenderingContext2DAzure::PutImageData(JSContext* cx,
103251:                                               ImageData* imageData, double dx,
103251:                                               double dy, ErrorResult& error)
103251: {
103251:   if (!FloatValidate(dx, dy)) {
103251:     error.Throw(NS_ERROR_DOM_NOT_SUPPORTED_ERR);
103251:     return;
103251:   }
103251: 
103251:   dom::Uint8ClampedArray arr(cx, imageData->GetDataObject());
103251: 
103251:   error = PutImageData_explicit(JS_DoubleToInt32(dx), JS_DoubleToInt32(dy),
103251:                                 imageData->GetWidth(), imageData->GetHeight(),
107061:                                 arr.Data(), arr.Length(), false, 0, 0, 0, 0);
103251: }
103251: 
103251: void
103251: nsCanvasRenderingContext2DAzure::PutImageData(JSContext* cx,
103251:                                               ImageData* imageData, double dx,
103251:                                               double dy, double dirtyX,
103251:                                               double dirtyY, double dirtyWidth,
103251:                                               double dirtyHeight,
103251:                                               ErrorResult& error)
103251: {
103251:   if (!FloatValidate(dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight)) {
103251:     error.Throw(NS_ERROR_DOM_NOT_SUPPORTED_ERR);
103251:     return;
103251:   }
103251: 
103251:   dom::Uint8ClampedArray arr(cx, imageData->GetDataObject());
103251: 
103251:   error = PutImageData_explicit(JS_DoubleToInt32(dx), JS_DoubleToInt32(dy),
103251:                                 imageData->GetWidth(), imageData->GetHeight(),
107061:                                 arr.Data(), arr.Length(), true,
103251:                                 JS_DoubleToInt32(dirtyX),
103251:                                 JS_DoubleToInt32(dirtyY),
103251:                                 JS_DoubleToInt32(dirtyWidth),
103251:                                 JS_DoubleToInt32(dirtyHeight));
103251: }
103251: 
 72428: // void putImageData (in ImageData d, in float x, in float y);
106988: // void putImageData (in ImageData d, in double x, in double y, in double dirtyX, in double dirtyY, in double dirtyWidth, in double dirtyHeight);
 72428: NS_IMETHODIMP
106988: nsCanvasRenderingContext2DAzure::PutImageData(const JS::Value&, double, double,
106988:                                               double, double, double, double,
108991:                                               JSContext*, uint8_t)
 72428: {
106988:   /* Should never be called -- the new binding code handles it, and
106988:      C++ callers should call PutImageData_explicit */
 72428:   return NS_ERROR_NOT_IMPLEMENTED;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
108991: nsCanvasRenderingContext2DAzure::PutImageData_explicit(int32_t x, int32_t y, uint32_t w, uint32_t h,
108991:                                                        unsigned char *aData, uint32_t aDataLen,
108991:                                                        bool hasDirtyRect, int32_t dirtyX, int32_t dirtyY,
108991:                                                        int32_t dirtyWidth, int32_t dirtyHeight)
 72428: {
111232:   if (!mValid) {
111232:     return NS_ERROR_FAILURE;
111232:   }
111232: 
 72428:   if (w == 0 || h == 0) {
 72428:     return NS_ERROR_DOM_SYNTAX_ERR;
 72428:   }
 72428: 
 72428:   IntRect dirtyRect;
 72428:   IntRect imageDataRect(0, 0, w, h);
 72428: 
 72428:   if (hasDirtyRect) {
 72428:     // fix up negative dimensions
 72428:     if (dirtyWidth < 0) {
 72428:       NS_ENSURE_TRUE(dirtyWidth != INT_MIN, NS_ERROR_DOM_INDEX_SIZE_ERR);
 72428: 
 72428:       CheckedInt32 checkedDirtyX = CheckedInt32(dirtyX) + dirtyWidth;
 72428: 
 98543:       if (!checkedDirtyX.isValid())
 72428:           return NS_ERROR_DOM_INDEX_SIZE_ERR;
 72428: 
 72428:       dirtyX = checkedDirtyX.value();
101116:       dirtyWidth = -dirtyWidth;
 72428:     }
 72428: 
 72428:     if (dirtyHeight < 0) {
 72428:       NS_ENSURE_TRUE(dirtyHeight != INT_MIN, NS_ERROR_DOM_INDEX_SIZE_ERR);
 72428: 
 72428:       CheckedInt32 checkedDirtyY = CheckedInt32(dirtyY) + dirtyHeight;
 72428: 
 98543:       if (!checkedDirtyY.isValid())
 72428:           return NS_ERROR_DOM_INDEX_SIZE_ERR;
 72428: 
 72428:       dirtyY = checkedDirtyY.value();
101116:       dirtyHeight = -dirtyHeight;
 72428:     }
 72428: 
 72428:     // bound the dirty rect within the imageData rectangle
 72428:     dirtyRect = imageDataRect.Intersect(IntRect(dirtyX, dirtyY, dirtyWidth, dirtyHeight));
 72428: 
 72428:     if (dirtyRect.Width() <= 0 || dirtyRect.Height() <= 0)
 72428:         return NS_OK;
 72428:   } else {
 72428:     dirtyRect = imageDataRect;
 72428:   }
 72428: 
 72428:   dirtyRect.MoveBy(IntPoint(x, y));
 72428:   dirtyRect = IntRect(0, 0, mWidth, mHeight).Intersect(dirtyRect);
 72428: 
 72428:   if (dirtyRect.Width() <= 0 || dirtyRect.Height() <= 0) {
 72428:     return NS_OK;
 72428:   }
 72428: 
108991:   uint32_t len = w * h * 4;
 72428:   if (aDataLen != len) {
 72428:     return NS_ERROR_DOM_SYNTAX_ERR;
 72428:   }
 72428: 
 72428:   nsRefPtr<gfxImageSurface> imgsurf = new gfxImageSurface(gfxIntSize(w, h),
 72428:                                                           gfxASurface::ImageFormatARGB32);
 72428:   if (!imgsurf || imgsurf->CairoStatus()) {
 72428:     return NS_ERROR_FAILURE;
 72428:   }
 72428: 
 72428:   // ensure premultiply table has been created
 72428:   EnsurePremultiplyTable();
 72428: 
108991:   uint8_t *src = aData;
108991:   uint8_t *dst = imgsurf->Data();
108991: 
108991:   for (uint32_t j = 0; j < h; j++) {
108991:     for (uint32_t i = 0; i < w; i++) {
108991:       uint8_t r = *src++;
108991:       uint8_t g = *src++;
108991:       uint8_t b = *src++;
108991:       uint8_t a = *src++;
 72428: 
 72428:       // Convert to premultiplied color (losslessly if the input came from getImageData)
 72428: #ifdef IS_LITTLE_ENDIAN
 72428:       *dst++ = sPremultiplyTable[a][b];
 72428:       *dst++ = sPremultiplyTable[a][g];
 72428:       *dst++ = sPremultiplyTable[a][r];
 72428:       *dst++ = a;
 72428: #else
 72428:       *dst++ = a;
 72428:       *dst++ = sPremultiplyTable[a][r];
 72428:       *dst++ = sPremultiplyTable[a][g];
 72428:       *dst++ = sPremultiplyTable[a][b];
 72428: #endif
 72428:     }
 72428:   }
 72428: 
 72428:   RefPtr<SourceSurface> sourceSurface =
 72428:     mTarget->CreateSourceSurfaceFromData(imgsurf->Data(), IntSize(w, h), imgsurf->Stride(), FORMAT_B8G8R8A8);
 72428: 
 72428: 
 72428:   mTarget->CopySurface(sourceSurface,
 72428:                        IntRect(dirtyRect.x - x, dirtyRect.y - y,
 72428:                                dirtyRect.width, dirtyRect.height),
 72428:                        IntPoint(dirtyRect.x, dirtyRect.y));
 72428: 
 72428:   Redraw(mgfx::Rect(dirtyRect.x, dirtyRect.y, dirtyRect.width, dirtyRect.height));
 72428: 
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 72428: nsCanvasRenderingContext2DAzure::GetThebesSurface(gfxASurface **surface)
 72428: {
111232:   if (!mTarget) {
111232:     nsRefPtr<gfxASurface> tmpSurf =
111232:       gfxPlatform::GetPlatform()->CreateOffscreenSurface(gfxIntSize(1, 1), gfxASurface::CONTENT_COLOR_ALPHA);
111232:     *surface = tmpSurf.forget().get();
111232:     return NS_OK;
111232:   }
111232: 
 72767:   if (!mThebesSurface) {
 72767:     mThebesSurface =
 72428:       gfxPlatform::GetPlatform()->GetThebesSurfaceForDrawTarget(mTarget);    
 72428: 
 72767:     if (!mThebesSurface) {
 72767:       return NS_ERROR_FAILURE;
 72767:     }
 72767:   } else {
 72767:     // Normally GetThebesSurfaceForDrawTarget will handle the flush, when
 72767:     // we're returning a cached ThebesSurface we need to flush here.
 72767:     mTarget->Flush();
 72767:   }
 72767: 
 72767:   *surface = mThebesSurface;
 78894:   NS_ADDREF(*surface);
 72428: 
 72428:   return NS_OK;
 72428: }
 72428: 
103251: static already_AddRefed<ImageData>
103251: CreateImageData(JSContext* cx, nsCanvasRenderingContext2DAzure* context,
103251:                 uint32_t w, uint32_t h, ErrorResult& error)
103251: {
103251:   if (w == 0)
103251:       w = 1;
103251:   if (h == 0)
103251:       h = 1;
103251: 
103251:   CheckedInt<uint32_t> len = CheckedInt<uint32_t>(w) * h * 4;
103251:   if (!len.isValid()) {
103251:     error.Throw(NS_ERROR_DOM_INDEX_SIZE_ERR);
103251:     return NULL;
103251:   }
103251: 
103251:   // Create the fast typed array; it's initialized to 0 by default.
103251:   JSObject* darray = Uint8ClampedArray::Create(cx, context, len.value());
103251:   if (!darray) {
103251:     error.Throw(NS_ERROR_OUT_OF_MEMORY);
103251:     return NULL;
103251:   }
103251: 
103251:   nsRefPtr<mozilla::dom::ImageData> imageData =
103251:     new mozilla::dom::ImageData(w, h, *darray);
103251:   return imageData.forget();
103251: }
103251: 
103251: already_AddRefed<ImageData>
103251: nsCanvasRenderingContext2DAzure::CreateImageData(JSContext* cx, double sw,
103251:                                                  double sh, ErrorResult& error)
103251: {
103251:   if (!FloatValidate(sw, sh)) {
103251:     error.Throw(NS_ERROR_DOM_NOT_SUPPORTED_ERR);
103251:     return NULL;
103251:   }
103251: 
103251:   if (!sw || !sh) {
103251:     error.Throw(NS_ERROR_DOM_INDEX_SIZE_ERR);
103251:     return NULL;
103251:   }
103251: 
103251:   int32_t wi = JS_DoubleToInt32(sw);
103251:   int32_t hi = JS_DoubleToInt32(sh);
103251: 
103251:   uint32_t w = NS_ABS(wi);
103251:   uint32_t h = NS_ABS(hi);
103251:   return ::CreateImageData(cx, this, w, h, error);
103251: }
103251: 
103251: already_AddRefed<ImageData>
103251: nsCanvasRenderingContext2DAzure::CreateImageData(JSContext* cx,
103251:                                                  ImageData* imagedata,
103251:                                                  ErrorResult& error)
103251: {
103251:   return ::CreateImageData(cx, this, imagedata->GetWidth(),
103251:                            imagedata->GetHeight(), error);
103251: }
103251: 
 72428: NS_IMETHODIMP
106988: nsCanvasRenderingContext2DAzure::CreateImageData(const JS::Value &arg1,
106988:                                                  const JS::Value &arg2,
106988:                                                  JSContext* cx,
108991:                                                  uint8_t optional_argc,
106988:                                                  nsIDOMImageData** retval)
 72428: {
106988:   /* Should never be called; handled entirely in new bindings */
 72428:   return NS_ERROR_NOT_IMPLEMENTED;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 79445: nsCanvasRenderingContext2DAzure::GetMozImageSmoothingEnabled(bool *retVal)
 72428: {
103251:   *retVal = GetImageSmoothingEnabled();
 72428:   return NS_OK;
 72428: }
 72428: 
 72428: NS_IMETHODIMP
 79445: nsCanvasRenderingContext2DAzure::SetMozImageSmoothingEnabled(bool val)
 72428: {
103251:   SetImageSmoothingEnabled(val);
 72428:   return NS_OK;
 72428: }
 72428: 
108991: static uint8_t g2DContextLayerUserData;
 72428: 
 72428: already_AddRefed<CanvasLayer>
 72428: nsCanvasRenderingContext2DAzure::GetCanvasLayer(nsDisplayListBuilder* aBuilder,
 72428:                                                 CanvasLayer *aOldLayer,
 72428:                                                 LayerManager *aManager)
 72428: {
111232:   if (!mValid) {
111150:     // No DidTransactionCallback will be received, so mark the context clean
111150:     // now so future invalidations will be dispatched.
111150:     MarkContextClean();
106838:     return nullptr;
 72428:   }
 72428: 
111232:   if (mTarget) {
 72428:     mTarget->Flush();
111232:   }
 72428: 
102689:   if (!mResetLayer && aOldLayer) {
102689:       CanvasRenderingContext2DUserDataAzure* userData =
102689:       static_cast<CanvasRenderingContext2DUserDataAzure*>(
102689:         aOldLayer->GetUserData(&g2DContextLayerUserData));
102689:     if (userData && userData->IsForContext(this)) {
 72428:       NS_ADDREF(aOldLayer);
 72428:       return aOldLayer;
 72428:     }
102689:   }
 72428: 
 72428:   nsRefPtr<CanvasLayer> canvasLayer = aManager->CreateCanvasLayer();
 72428:   if (!canvasLayer) {
 72428:     NS_WARNING("CreateCanvasLayer returned null!");
111150:     // No DidTransactionCallback will be received, so mark the context clean
111150:     // now so future invalidations will be dispatched.
111150:     MarkContextClean();
106838:     return nullptr;
106838:   }
106838:   CanvasRenderingContext2DUserDataAzure *userData = nullptr;
 72428:   // Make the layer tell us whenever a transaction finishes (including
 72428:   // the current transaction), so we can clear our invalidation state and
108195:   // start invalidating again. We need to do this for all layers since
108195:   // callers of DrawWindow may be expecting to receive normal invalidation
108195:   // notifications after this paint.
 72428: 
 72428:   // The layer will be destroyed when we tear down the presentation
 72428:   // (at the latest), at which time this userData will be destroyed,
 72428:   // releasing the reference to the element.
 72428:   // The userData will receive DidTransactionCallbacks, which flush the
 72428:   // the invalidation state to indicate that the canvas is up to date.
102689:   userData = new CanvasRenderingContext2DUserDataAzure(this);
 72428:   canvasLayer->SetDidTransactionCallback(
102689:           CanvasRenderingContext2DUserDataAzure::DidTransactionCallback, userData);
 72428:   canvasLayer->SetUserData(&g2DContextLayerUserData, userData);
 72428: 
 72428:   CanvasLayer::Data data;
 72428: 
 72428:   data.mDrawTarget = mTarget;
 72428:   data.mSize = nsIntSize(mWidth, mHeight);
 72428: 
 72428:   canvasLayer->Initialize(data);
108991:   uint32_t flags = mOpaque ? Layer::CONTENT_OPAQUE : 0;
 72428:   canvasLayer->SetContentFlags(flags);
 72428:   canvasLayer->Updated();
 72428: 
 80486:   mResetLayer = false;
 72428: 
 72428:   return canvasLayer.forget();
 72428: }
 72428: 
 72428: void
 72428: nsCanvasRenderingContext2DAzure::MarkContextClean()
 72428: {
 72428:   if (mInvalidateCount > 0) {
 72428:     mPredictManyRedrawCalls = mInvalidateCount > kCanvasMaxInvalidateCount;
 72428:   }
 80486:   mIsEntireFrameInvalid = false;
 72428:   mInvalidateCount = 0;
 72428: }
 72428: 
106596: 
106596: bool
106596: nsCanvasRenderingContext2DAzure::ShouldForceInactiveLayer(LayerManager *aManager)
106596: {
106596:     return !aManager->CanUseCanvasLayerForSize(gfxIntSize(mWidth, mHeight));
106596: }
