     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /* rendering object for CSS display:inline objects */
     1: 
     1: #include "nsCOMPtr.h"
     1: #include "nsInlineFrame.h"
     1: #include "nsBlockFrame.h"
 32107: #include "nsPlaceholderFrame.h"
     1: #include "nsGkAtoms.h"
     1: #include "nsHTMLParts.h"
     1: #include "nsStyleContext.h"
     1: #include "nsIPresShell.h"
     1: #include "nsPresContext.h"
 68481: #include "nsRenderingContext.h"
     1: #include "nsCSSAnonBoxes.h"
     1: #include "nsAutoPtr.h"
     1: #include "nsFrameManager.h"
     1: #ifdef ACCESSIBILITY
     1: #include "nsIServiceManager.h"
 61464: #include "nsAccessibilityService.h"
     1: #endif
     1: #include "nsDisplayList.h"
     1: 
     1: #ifdef DEBUG
     1: #undef NOISY_PUSHING
     1: #endif
     1: 
     1: 
     1: //////////////////////////////////////////////////////////////////////
     1: 
     1: // Basic nsInlineFrame methods
     1: 
     1: nsIFrame*
     1: NS_NewInlineFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
     1: {
     1:   return new (aPresShell) nsInlineFrame(aContext);
     1: }
     1: 
 90268: NS_IMETHODIMP
 90268: nsInlineFrame::Init(nsIContent*      aContent,
 90268:                     nsIFrame*        aParent,
 90268:                     nsIFrame*        aPrevInFlow)
 90268: {
 90268:   // Let the base class do its processing
 90268:   nsresult rv = nsContainerFrame::Init(aContent, aParent, aPrevInFlow);
 90268: 
 90268:   // Transforms do not affect regular inline elements (bug 722463)
 90268:   mState &= ~NS_FRAME_MAY_BE_TRANSFORMED;
 90268: 
 90268:   return rv;
 90268: }
 90268: 
 32423: NS_IMPL_FRAMEARENA_HELPERS(nsInlineFrame)
 32423: 
 23554: NS_QUERYFRAME_HEAD(nsInlineFrame)
 23554:   NS_QUERYFRAME_ENTRY(nsInlineFrame)
 86231: NS_QUERYFRAME_TAIL_INHERITING(nsContainerFrame)
     1: 
     1: #ifdef DEBUG
     1: NS_IMETHODIMP
     1: nsInlineFrame::GetFrameName(nsAString& aResult) const
     1: {
     1:   return MakeFrameName(NS_LITERAL_STRING("Inline"), aResult);
     1: }
     1: #endif
     1: 
     1: nsIAtom*
     1: nsInlineFrame::GetType() const
     1: {
     1:   return nsGkAtoms::inlineFrame;
     1: }
     1: 
 79445: static inline bool
 51776: IsMarginZero(const nsStyleCoord &aCoord)
     1: {
 51777:   return aCoord.GetUnit() == eStyleUnit_Auto ||
 52283:          nsLayoutUtils::IsMarginZero(aCoord);
     1: }
     1: 
 79445: /* virtual */ bool
     1: nsInlineFrame::IsSelfEmpty()
     1: {
     1: #if 0
     1:   // I used to think inline frames worked this way, but it seems they
     1:   // don't.  At least not in our codebase.
     1:   if (GetPresContext()->CompatibilityMode() == eCompatibility_FullStandards) {
 80486:     return false;
     1:   }
     1: #endif
     1:   const nsStyleMargin* margin = GetStyleMargin();
     1:   const nsStyleBorder* border = GetStyleBorder();
     1:   const nsStylePadding* padding = GetStylePadding();
     1:   // XXX Top and bottom removed, since they shouldn't affect things, but this
     1:   // doesn't really match with nsLineLayout.cpp's setting of
     1:   // ZeroEffectiveSpanBox, anymore, so what should this really be?
 79445:   bool haveRight =
 99856:     border->GetComputedBorderWidth(NS_SIDE_RIGHT) != 0 ||
 51777:     !nsLayoutUtils::IsPaddingZero(padding->mPadding.GetRight()) ||
 51776:     !IsMarginZero(margin->mMargin.GetRight());
 79445:   bool haveLeft =
 99856:     border->GetComputedBorderWidth(NS_SIDE_LEFT) != 0 ||
 51777:     !nsLayoutUtils::IsPaddingZero(padding->mPadding.GetLeft()) ||
 51776:     !IsMarginZero(margin->mMargin.GetLeft());
 34461:   if (haveLeft || haveRight) {
 34461:     if (GetStateBits() & NS_FRAME_IS_SPECIAL) {
 79445:       bool haveStart, haveEnd;
 34461:       if (NS_STYLE_DIRECTION_LTR == GetStyleVisibility()->mDirection) {
 34461:         haveStart = haveLeft;
 34461:         haveEnd = haveRight;
 34461:       } else {
 34461:         haveStart = haveRight;
 34461:         haveEnd = haveLeft;
 34461:       }
 34461:       // For special frames, ignore things we know we'll skip in GetSkipSides.
 34461:       // XXXbz should we be doing this for non-special frames too, in a more
 34461:       // general way?
 34461: 
 34461:       // Get the first continuation eagerly, as a performance optimization, to
 34461:       // avoid having to get it twice..
 34461:       nsIFrame* firstCont = GetFirstContinuation();
 34461:       return
 34461:         (!haveStart || nsLayoutUtils::FrameIsNonFirstInIBSplit(firstCont)) &&
 34461:         (!haveEnd || nsLayoutUtils::FrameIsNonLastInIBSplit(firstCont));
 34461:     }
 80486:     return false;
     1:   }
 80486:   return true;
     1: }
     1: 
 79445: bool
     1: nsInlineFrame::IsEmpty()
     1: {
     1:   if (!IsSelfEmpty()) {
 80486:     return false;
     1:   }
     1: 
     1:   for (nsIFrame *kid = mFrames.FirstChild(); kid; kid = kid->GetNextSibling()) {
     1:     if (!kid->IsEmpty())
 80486:       return false;
     1:   }
     1: 
 80486:   return true;
     1: }
     1: 
 79445: bool
108991: nsInlineFrame::PeekOffsetCharacter(bool aForward, int32_t* aOffset,
 79445:                                    bool aRespectClusters)
     1: {
     1:   // Override the implementation in nsFrame, to skip empty inline frames
     1:   NS_ASSERTION (aOffset && *aOffset <= 1, "aOffset out of range");
108991:   int32_t startOffset = *aOffset;
     1:   if (startOffset < 0)
     1:     startOffset = 1;
     1:   if (aForward == (startOffset == 0)) {
     1:     // We're before the frame and moving forward, or after it and moving backwards:
     1:     // skip to the other side, but keep going.
     1:     *aOffset = 1 - startOffset;
     1:   }
 80486:   return false;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsInlineFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
     1:                                 const nsRect&           aDirtyRect,
     1:                                 const nsDisplayListSet& aLists)
     1: {
 86231:   nsresult rv = BuildDisplayListForInline(aBuilder, aDirtyRect, aLists);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   // The sole purpose of this is to trigger display of the selection
     1:   // window for Named Anchors, which don't have any children and
     1:   // normally don't have any size, but in Editor we use CSS to display
     1:   // an image to represent this "hidden" element.
     1:   if (!mFrames.FirstChild()) {
 52291:     rv = DisplaySelectionOverlay(aBuilder, aLists.Content());
     1:   }
     1:   return rv;
     1: }
     1: 
     1: //////////////////////////////////////////////////////////////////////
     1: // Reflow methods
     1: 
     1: /* virtual */ void
 68481: nsInlineFrame::AddInlineMinWidth(nsRenderingContext *aRenderingContext,
     1:                                  nsIFrame::InlineMinWidthData *aData)
     1: {
     1:   DoInlineIntrinsicWidth(aRenderingContext, aData, nsLayoutUtils::MIN_WIDTH);
     1: }
     1: 
     1: /* virtual */ void
 68481: nsInlineFrame::AddInlinePrefWidth(nsRenderingContext *aRenderingContext,
     1:                                   nsIFrame::InlinePrefWidthData *aData)
     1: {
     1:   DoInlineIntrinsicWidth(aRenderingContext, aData, nsLayoutUtils::PREF_WIDTH);
     1: }
     1: 
     1: /* virtual */ nsSize
 68481: nsInlineFrame::ComputeSize(nsRenderingContext *aRenderingContext,
     1:                            nsSize aCBSize, nscoord aAvailableWidth,
     1:                            nsSize aMargin, nsSize aBorder, nsSize aPadding,
108991:                            uint32_t aFlags)
     1: {
     1:   // Inlines and text don't compute size before reflow.
     1:   return nsSize(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
     1: }
     1: 
  6862: nsRect
  6862: nsInlineFrame::ComputeTightBounds(gfxContext* aContext) const
  6862: {
  6862:   // be conservative
 68819:   if (GetStyleContext()->HasTextDecorationLines()) {
 55035:     return GetVisualOverflowRect();
 68819:   }
  6862:   return ComputeSimpleTightBounds(aContext);
  6862: }
  6862: 
   686: void
   686: nsInlineFrame::ReparentFloatsForInlineChild(nsIFrame* aOurLineContainer,
   686:                                             nsIFrame* aFrame,
 79445:                                             bool aReparentSiblings)
   686: {
 30781:   // XXXbz this would be better if it took a nsFrameList or a frame
 30781:   // list slice....
   686:   NS_ASSERTION(aOurLineContainer->GetNextContinuation() ||
   686:                aOurLineContainer->GetPrevContinuation(),
   686:                "Don't call this when we have no continuation, it's a waste");
  3667:   if (!aFrame) {
  3667:     NS_ASSERTION(aReparentSiblings, "Why did we get called?");
  3667:     return;
  3667:   }
   686: 
   686:   nsIFrame* ancestor = aFrame;
   686:   nsIFrame* ancestorBlockChild;
   686:   do {
   686:     ancestorBlockChild = ancestor;
   686:     ancestor = ancestor->GetParent();
   686:     if (!ancestor)
   686:       return;
   686:   } while (!ancestor->IsFloatContainingBlock());
   686: 
   686:   if (ancestor == aOurLineContainer)
   686:     return;
   686: 
 15909:   nsBlockFrame* ourBlock = nsLayoutUtils::GetAsBlock(aOurLineContainer);
 15909:   NS_ASSERTION(ourBlock, "Not a block, but broke vertically?");
 15909:   nsBlockFrame* frameBlock = nsLayoutUtils::GetAsBlock(ancestor);
 15909:   NS_ASSERTION(frameBlock, "ancestor not a block");
   686: 
 77154:   const nsFrameList& blockChildren(ancestor->PrincipalChildList());
 79445:   bool isOverflow = !blockChildren.ContainsFrame(ancestorBlockChild);
   686: 
 80486:   while (true) {
 80486:     ourBlock->ReparentFloats(aFrame, frameBlock, isOverflow, false);
   686: 
   686:     if (!aReparentSiblings)
   686:       return;
   686:     nsIFrame* next = aFrame->GetNextSibling();
   686:     if (!next)
   686:       return;
   686:     if (next->GetParent() == aFrame->GetParent()) {
   686:       aFrame = next;
   686:       continue;
   686:     }
   686:     // This is paranoid and will hardly ever get hit ... but we can't actually
   686:     // trust that the frames in the sibling chain all have the same parent,
   686:     // because lazy reparenting may be going on. If we find a different
   686:     // parent we need to redo our analysis.
   686:     ReparentFloatsForInlineChild(aOurLineContainer, next, aReparentSiblings);
   686:     return;
   686:   }
   686: }
   686: 
 36803: static void
 40137: ReparentChildListStyle(nsPresContext* aPresContext,
 36803:                        const nsFrameList::Slice& aFrames,
 36803:                        nsIFrame* aParentFrame)
 36803: {
 36803:   nsFrameManager *frameManager = aPresContext->FrameManager();
 36803: 
 36803:   for (nsFrameList::Enumerator e(aFrames); !e.AtEnd(); e.Next()) {
 36803:     NS_ASSERTION(e.get()->GetParent() == aParentFrame, "Bogus parentage");
 40137:     frameManager->ReparentStyleContext(e.get());
 36803:   }
 36803: }
 36803: 
     1: NS_IMETHODIMP
     1: nsInlineFrame::Reflow(nsPresContext*          aPresContext,
     1:                       nsHTMLReflowMetrics&     aMetrics,
     1:                       const nsHTMLReflowState& aReflowState,
     1:                       nsReflowStatus&          aStatus)
     1: {
     1:   DO_GLOBAL_REFLOW_COUNT("nsInlineFrame");
     1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
106838:   if (nullptr == aReflowState.mLineLayout) {
     1:     return NS_ERROR_INVALID_ARG;
     1:   }
110158:   if (IsFrameTreeTooDeep(aReflowState, aMetrics, aStatus)) {
110158:     return NS_OK;
110158:   }
     1: 
 79445:   bool    lazilySetParentPointer = false;
     1: 
   686:   nsIFrame* lineContainer = aReflowState.mLineLayout->GetLineContainerFrame();
   686: 
     1:    // Check for an overflow list with our prev-in-flow
     1:   nsInlineFrame* prevInFlow = (nsInlineFrame*)GetPrevInFlow();
106838:   if (nullptr != prevInFlow) {
 30781:     nsAutoPtr<nsFrameList> prevOverflowFrames(prevInFlow->StealOverflowFrames());
     1: 
     1:     if (prevOverflowFrames) {
     1:       // When pushing and pulling frames we need to check for whether any
     1:       // views need to be reparented.
 68656:       nsContainerFrame::ReparentFrameViewList(aPresContext,
 30781:                                               *prevOverflowFrames,
     1:                                               prevInFlow, this);
     1: 
 24722:       // Check if we should do the lazilySetParentPointer optimization.
 24722:       // Only do it in simple cases where we're being reflowed for the
 24722:       // first time, nothing (e.g. bidi resolution) has already given
 24722:       // us children, and there's no next-in-flow, so all our frames
 24722:       // will be taken from prevOverflowFrames.
 24722:       if ((GetStateBits() & NS_FRAME_FIRST_REFLOW) && mFrames.IsEmpty() &&
 24722:           !GetNextInFlow()) {
 30781:         // If our child list is empty, just put the new frames into it.
     1:         // Note that we don't set the parent pointer for the new frames. Instead wait
     1:         // to do this until we actually reflow the frame. If the overflow list contains
     1:         // thousands of frames this is a big performance issue (see bug #5588)
 30790:         mFrames.SetFrames(*prevOverflowFrames);
 80486:         lazilySetParentPointer = true;
     1:       } else {
   686:         // Assign all floats to our block if necessary
   686:         if (lineContainer && lineContainer->GetPrevContinuation()) {
 30781:           ReparentFloatsForInlineChild(lineContainer,
 30781:                                        prevOverflowFrames->FirstChild(),
 80486:                                        true);
   686:         }
     1:         // Insert the new frames at the beginning of the child list
     1:         // and set their parent pointer
 36803:         const nsFrameList::Slice& newFrames =
106838:           mFrames.InsertFrames(this, nullptr, *prevOverflowFrames);
 36803:         // If our prev in flow was under the first continuation of a first-line
 36803:         // frame then we need to reparent the style contexts to remove the
 36803:         // the special first-line styling. In the lazilySetParentPointer case
 36803:         // we reparent the style contexts when we set their parents in
 36803:         // nsInlineFrame::ReflowFrames and nsInlineFrame::ReflowInlineFrame.
 36803:         if (aReflowState.mLineLayout->GetInFirstLine()) {
 40137:           ReparentChildListStyle(aPresContext, newFrames, this);
 36803:         }
     1:       }
     1:     }
     1:   }
     1: 
     1:   // It's also possible that we have an overflow list for ourselves
     1: #ifdef DEBUG
     1:   if (GetStateBits() & NS_FRAME_FIRST_REFLOW) {
     1:     // If it's our initial reflow, then we should not have an overflow list.
     1:     // However, add an assertion in case we get reflowed more than once with
     1:     // the initial reflow reason
 30781:     nsFrameList* overflowFrames = GetOverflowFrames();
 30781:     NS_ASSERTION(!overflowFrames || overflowFrames->IsEmpty(),
 30781:                  "overflow list is not empty for initial reflow");
     1:   }
     1: #endif
     1:   if (!(GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
 30781:     nsAutoPtr<nsFrameList> overflowFrames(StealOverflowFrames());
     1:     if (overflowFrames) {
     1:       NS_ASSERTION(mFrames.NotEmpty(), "overflow list w/o frames");
110158:       if (!lazilySetParentPointer) {
110158:         // The frames on our own overflowlist may have been pushed by a
110158:         // previous lazilySetParentPointer Reflow so we need to ensure
110158:         // the correct parent pointer now since we're not setting it
110158:         // lazily in this Reflow.
110158:         nsIFrame* firstChild = overflowFrames->FirstChild();
110158:         if (lineContainer && lineContainer->GetPrevContinuation()) {
110158:           ReparentFloatsForInlineChild(lineContainer, firstChild, true);
     1:         }
110158:         const bool inFirstLine = aReflowState.mLineLayout->GetInFirstLine();
110158:         nsFrameManager* fm = PresContext()->FrameManager();
110158:         for (nsIFrame* f = firstChild; f; f = f->GetNextSibling()) {
110158:           f->SetParent(this);
110158:           if (inFirstLine) {
110158:             fm->ReparentStyleContext(f);
     1:           }
110158:         }
110158:       }
110158:       mFrames.AppendFrames(nullptr, *overflowFrames);
110158:     }
     1:   }
     1: 
     1:   // Set our own reflow state (additional state above and beyond
     1:   // aReflowState)
     1:   InlineReflowState irs;
106838:   irs.mPrevFrame = nullptr;
   686:   irs.mLineContainer = lineContainer;
 34500:   irs.mLineLayout = aReflowState.mLineLayout;
     1:   irs.mNextInFlow = (nsInlineFrame*) GetNextInFlow();
     1:   irs.mSetParentPointer = lazilySetParentPointer;
     1: 
     1:   nsresult rv;
     1:   if (mFrames.IsEmpty()) {
     1:     // Try to pull over one frame before starting so that we know
     1:     // whether we have an anonymous block or not.
 79445:     bool complete;
     1:     (void) PullOneFrame(aPresContext, irs, &complete);
     1:   }
     1: 
     1:   rv = ReflowFrames(aPresContext, aReflowState, irs, aMetrics, aStatus);
     1: 
 79483:   ReflowAbsoluteFrames(aPresContext, aMetrics, aReflowState, aStatus);
 79483: 
     1:   // Note: the line layout code will properly compute our
 26950:   // overflow-rect state for us.
     1: 
     1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);
     1:   return rv;
     1: }
     1: 
 79445: /* virtual */ bool
     1: nsInlineFrame::CanContinueTextRun() const
     1: {
     1:   // We can continue a text run through an inline frame
 80486:   return true;
     1: }
     1: 
 30638: /* virtual */ void
 30638: nsInlineFrame::PullOverflowsFromPrevInFlow()
 30638: {
 30638:   nsInlineFrame* prevInFlow = static_cast<nsInlineFrame*>(GetPrevInFlow());
 30638:   if (prevInFlow) {
 30781:     nsAutoPtr<nsFrameList> prevOverflowFrames(prevInFlow->StealOverflowFrames());
 30638:     if (prevOverflowFrames) {
 30638:       // Assume that our prev-in-flow has the same line container that we do.
 68656:       nsContainerFrame::ReparentFrameViewList(PresContext(),
 31288:                                               *prevOverflowFrames,
 31288:                                               prevInFlow, this);
106838:       mFrames.InsertFrames(this, nullptr, *prevOverflowFrames);
 30638:     }
 30638:   }
 30638: }
 30638: 
     1: nsresult
     1: nsInlineFrame::ReflowFrames(nsPresContext* aPresContext,
     1:                             const nsHTMLReflowState& aReflowState,
     1:                             InlineReflowState& irs,
     1:                             nsHTMLReflowMetrics& aMetrics,
     1:                             nsReflowStatus& aStatus)
     1: {
     1:   nsresult rv = NS_OK;
     1:   aStatus = NS_FRAME_COMPLETE;
     1: 
     1:   nsLineLayout* lineLayout = aReflowState.mLineLayout;
 79445:   bool inFirstLine = aReflowState.mLineLayout->GetInFirstLine();
 36803:   nsFrameManager* frameManager = aPresContext->FrameManager();
 79445:   bool ltr = (NS_STYLE_DIRECTION_LTR == aReflowState.mStyleVisibility->mDirection);
     1:   nscoord leftEdge = 0;
 28217:   // Don't offset by our start borderpadding if we have a prev continuation or
 34460:   // if we're in a part of an {ib} split other than the first one.
 28217:   if (!GetPrevContinuation() &&
 34460:       !nsLayoutUtils::FrameIsNonFirstInIBSplit(this)) {
     1:     leftEdge = ltr ? aReflowState.mComputedBorderPadding.left
     1:                    : aReflowState.mComputedBorderPadding.right;
     1:   }
     1:   nscoord availableWidth = aReflowState.availableWidth;
  8982:   NS_ASSERTION(availableWidth != NS_UNCONSTRAINEDSIZE,
  8982:                "should no longer use available widths");
     1:   // Subtract off left and right border+padding from availableWidth
     1:   availableWidth -= leftEdge;
     1:   availableWidth -= ltr ? aReflowState.mComputedBorderPadding.right
     1:                         : aReflowState.mComputedBorderPadding.left;
 74800:   lineLayout->BeginSpan(this, &aReflowState, leftEdge,
 74800:                         leftEdge + availableWidth, &mBaseline);
     1: 
     1:   // First reflow our current children
     1:   nsIFrame* frame = mFrames.FirstChild();
 79445:   bool done = false;
106838:   while (nullptr != frame) {
 79445:     bool reflowingFirstLetter = lineLayout->GetFirstLetterStyleOK();
     1: 
     1:     // Check if we should lazily set the child frame's parent pointer
     1:     if (irs.mSetParentPointer) {
 79445:       bool havePrevBlock =
   686:         irs.mLineContainer && irs.mLineContainer->GetPrevContinuation();
110158:       nsIFrame* child = frame;
110158:       do {
   686:         // If our block is the first in flow, then any floats under the pulled
   686:         // frame must already belong to our block.
   686:         if (havePrevBlock) {
   686:           // This has to happen before we update frame's parent; we need to
   686:           // know frame's ancestry under its old block.
   686:           // The blockChildren.ContainsFrame check performed by
   686:           // ReparentFloatsForInlineChild here may be slow, but we can't
   686:           // easily avoid it because we don't know where 'frame' originally
   686:           // came from. If we really really have to optimize this we could
   686:           // cache whether frame->GetParent() is under its containing blocks
   686:           // overflowList or not.
110158:           ReparentFloatsForInlineChild(irs.mLineContainer, child, false);
   686:         }
110158:         child->SetParent(this);
 36803:         if (inFirstLine) {
110158:           frameManager->ReparentStyleContext(child);
 36803:         }
110158:         // We also need to do the same for |frame|'s next-in-flows that are in
110158:         // the sibling list. Otherwise, if we reflow |frame| and it's complete
110158:         // we'll crash when trying to delete its next-in-flow.
110158:         // This scenario doesn't happen often, but it can happen.
110158:         nsIFrame* nextSibling = child->GetNextSibling();
110158:         child = child->GetNextInFlow();
110158:         if (NS_UNLIKELY(child)) {
110158:           while (child != nextSibling && nextSibling) {
110158:             nextSibling = nextSibling->GetNextSibling();
   686:           }
110158:           if (!nextSibling) {
110158:             child = nullptr;
 36803:           }
 22469:         }
110158:         MOZ_ASSERT(!child || mFrames.ContainsFrame(child));
110158:       } while (child);
 22469: 
 22469:       // Fix the parent pointer for ::first-letter child frame next-in-flows,
 22469:       // so nsFirstLetterFrame::Reflow can destroy them safely (bug 401042).
 22469:       nsIFrame* realFrame = nsPlaceholderFrame::GetRealFrameFor(frame);
 22469:       if (realFrame->GetType() == nsGkAtoms::letterFrame) {
 77154:         nsIFrame* child = realFrame->GetFirstPrincipalChild();
 22469:         if (child) {
 22469:           NS_ASSERTION(child->GetType() == nsGkAtoms::textFrame,
 22469:                        "unexpected frame type");
 22469:           nsIFrame* nextInFlow = child->GetNextInFlow();
 22469:           for ( ; nextInFlow; nextInFlow = nextInFlow->GetNextInFlow()) {
 22469:             NS_ASSERTION(nextInFlow->GetType() == nsGkAtoms::textFrame,
 22469:                          "unexpected frame type");
 22469:             if (mFrames.ContainsFrame(nextInFlow)) {
 22469:               nextInFlow->SetParent(this);
 36803:               if (inFirstLine) {
 40137:                 frameManager->ReparentStyleContext(nextInFlow);
 36803:               }
 22469:             }
 22469:             else {
 22469: #ifdef DEBUG              
 22469:               // Once we find a next-in-flow that isn't ours none of the
 22469:               // remaining next-in-flows should be either.
 22469:               for ( ; nextInFlow; nextInFlow = nextInFlow->GetNextInFlow()) {
 22469:                 NS_ASSERTION(!mFrames.ContainsFrame(nextInFlow),
 22469:                              "unexpected letter frame flow");
 22469:               }
 22469: #endif
 22469:               break;
 22469:             }
 22469:           }
 22469:         }
     1:       }
     1:     }
110158:     MOZ_ASSERT(frame->GetParent() == this);
110158: 
110158:     if (!done) {
     1:       rv = ReflowInlineFrame(aPresContext, aReflowState, irs, frame, aStatus);
110158:       done = NS_FAILED(rv) ||
110158:              NS_INLINE_IS_BREAK(aStatus) || 
110158:              (!reflowingFirstLetter && NS_FRAME_IS_NOT_COMPLETE(aStatus));
110158:       if (done) {
110158:         if (!irs.mSetParentPointer) {
     1:           break;
     1:         }
110158:         // Keep reparenting the remaining siblings, but don't reflow them.
110158:         nsFrameList* pushedFrames = GetOverflowFrames();
110158:         if (pushedFrames && pushedFrames->FirstChild() == frame) {
110158:           // Don't bother if |frame| was pushed to our overflow list.
     1:           break;
     1:         }
110158:       } else {
     1:         irs.mPrevFrame = frame;
110158:       }
110158:     }
     1:     frame = frame->GetNextSibling();
     1:   }
     1: 
     1:   // Attempt to pull frames from our next-in-flow until we can't
110158:   if (!done && GetNextInFlow()) {
110158:     while (true) {
 79445:       bool reflowingFirstLetter = lineLayout->GetFirstLetterStyleOK();
 79445:       bool isComplete;
     1:       if (!frame) { // Could be non-null if we pulled a first-letter frame and
     1:                     // it created a continuation, since we don't push those.
     1:         frame = PullOneFrame(aPresContext, irs, &isComplete);
     1:       }
     1: #ifdef NOISY_PUSHING
     1:       printf("%p pulled up %p\n", this, frame);
     1: #endif
106838:       if (nullptr == frame) {
     1:         if (!isComplete) {
     1:           aStatus = NS_FRAME_NOT_COMPLETE;
     1:         }
     1:         break;
     1:       }
     1:       rv = ReflowInlineFrame(aPresContext, aReflowState, irs, frame, aStatus);
110158:       if (NS_FAILED(rv) ||
110158:           NS_INLINE_IS_BREAK(aStatus) || 
     1:           (!reflowingFirstLetter && NS_FRAME_IS_NOT_COMPLETE(aStatus))) {
     1:         break;
     1:       }
     1:       irs.mPrevFrame = frame;
     1:       frame = frame->GetNextSibling();
     1:     }
     1:   }
110158: 
110158:   NS_ASSERTION(!NS_FRAME_IS_COMPLETE(aStatus) || !GetOverflowFrames(),
110158:                "We can't be complete AND have overflow frames!");
     1: 
     1:   // If after reflowing our children they take up no area then make
     1:   // sure that we don't either.
     1:   //
     1:   // Note: CSS demands that empty inline elements still affect the
     1:   // line-height calculations. However, continuations of an inline
     1:   // that are empty we force to empty so that things like collapsed
     1:   // whitespace in an inline element don't affect the line-height.
  8983:   aMetrics.width = lineLayout->EndSpan(this);
  1123: 
 28217:   // Compute final width.
 28217: 
 28217:   // Make sure to not include our start border and padding if we have a prev
 34460:   // continuation or if we're in a part of an {ib} split other than the first
 34460:   // one.
 28217:   if (!GetPrevContinuation() &&
 34460:       !nsLayoutUtils::FrameIsNonFirstInIBSplit(this)) {
     1:     aMetrics.width += ltr ? aReflowState.mComputedBorderPadding.left
     1:                           : aReflowState.mComputedBorderPadding.right;
     1:   }
 28217: 
 28217:   /*
 28217:    * We want to only apply the end border and padding if we're the last
 34460:    * continuation and either not in an {ib} split or the last part of it.  To
 34460:    * be the last continuation we have to be complete (so that we won't get a
 34460:    * next-in-flow) and have no non-fluid continuations on our continuation
 34460:    * chain.
 28217:    */
 28217:   if (NS_FRAME_IS_COMPLETE(aStatus) &&
 28290:       !GetLastInFlow()->GetNextContinuation() &&
 34460:       !nsLayoutUtils::FrameIsNonLastInIBSplit(this)) {
     1:     aMetrics.width += ltr ? aReflowState.mComputedBorderPadding.right
     1:                           : aReflowState.mComputedBorderPadding.left;
     1:   }
     1: 
 76295:   nsRefPtr<nsFontMetrics> fm;
 98995:   float inflation = nsLayoutUtils::FontSizeInflationFor(this);
 82678:   nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fm), inflation);
 76295:   aReflowState.rendContext->SetFont(fm);
     1: 
     1:   if (fm) {
     1:     // Compute final height of the frame.
     1:     //
     1:     // Do things the standard css2 way -- though it's hard to find it
     1:     // in the css2 spec! It's actually found in the css1 spec section
     1:     // 4.4 (you will have to read between the lines to really see
     1:     // it).
     1:     //
     1:     // The height of our box is the sum of our font size plus the top
     1:     // and bottom border and padding. The height of children do not
     1:     // affect our height.
 68495:     aMetrics.ascent = fm->MaxAscent();
 68495:     aMetrics.height = fm->MaxHeight();
     1:   } else {
     1:     NS_WARNING("Cannot get font metrics - defaulting sizes to 0");
     1:     aMetrics.ascent = aMetrics.height = 0;
     1:   }
     1:   aMetrics.ascent += aReflowState.mComputedBorderPadding.top;
     1:   aMetrics.height += aReflowState.mComputedBorderPadding.top +
     1:     aReflowState.mComputedBorderPadding.bottom;
     1: 
     1:   // For now our overflow area is zero. The real value will be
 11780:   // computed in |nsLineLayout::RelativePositionFrames|.
 55039:   aMetrics.mOverflowAreas.Clear();
     1: 
     1: #ifdef NOISY_FINAL_SIZE
     1:   ListTag(stdout);
     1:   printf(": metrics=%d,%d ascent=%d\n",
     1:          aMetrics.width, aMetrics.height, aMetrics.ascent);
     1: #endif
     1: 
     1:   return rv;
     1: }
     1: 
     1: nsresult
     1: nsInlineFrame::ReflowInlineFrame(nsPresContext* aPresContext,
     1:                                  const nsHTMLReflowState& aReflowState,
     1:                                  InlineReflowState& irs,
     1:                                  nsIFrame* aFrame,
     1:                                  nsReflowStatus& aStatus)
     1: {
     1:   nsLineLayout* lineLayout = aReflowState.mLineLayout;
 79445:   bool reflowingFirstLetter = lineLayout->GetFirstLetterStyleOK();
 79445:   bool pushedFrame;
     1:   nsresult rv =
106838:     lineLayout->ReflowFrame(aFrame, aStatus, nullptr, pushedFrame);
     1:   
     1:   if (NS_FAILED(rv)) {
     1:     return rv;
     1:   }
 46400: 
     1:   if (NS_INLINE_IS_BREAK_BEFORE(aStatus)) {
     1:     if (aFrame != mFrames.FirstChild()) {
     1:       // Change break-before status into break-after since we have
     1:       // already placed at least one child frame. This preserves the
     1:       // break-type so that it can be propagated upward.
     1:       aStatus = NS_FRAME_NOT_COMPLETE |
     1:         NS_INLINE_BREAK | NS_INLINE_BREAK_AFTER |
     1:         (aStatus & NS_INLINE_BREAK_TYPE_MASK);
 34500:       PushFrames(aPresContext, aFrame, irs.mPrevFrame, irs);
     1:     }
     1:     else {
     1:       // Preserve reflow status when breaking-before our first child
     1:       // and propagate it upward without modification.
     1:     }
 46400:     return NS_OK;
     1:   }
 46400: 
 46400:   // Create a next-in-flow if needed.
 46400:   if (!NS_FRAME_IS_FULLY_COMPLETE(aStatus)) {
     1:     nsIFrame* newFrame;
 32841:     rv = CreateNextInFlow(aPresContext, aFrame, newFrame);
     1:     if (NS_FAILED(rv)) {
     1:       return rv;
     1:     }
     1:   }
 46400: 
 46400:   if (NS_INLINE_IS_BREAK_AFTER(aStatus)) {
     1:     nsIFrame* nextFrame = aFrame->GetNextSibling();
     1:     if (nextFrame) {
  4006:       NS_FRAME_SET_INCOMPLETE(aStatus);
 34500:       PushFrames(aPresContext, nextFrame, aFrame, irs);
     1:     }
 46400:     else {
     1:       // We must return an incomplete status if there are more child
     1:       // frames remaining in a next-in-flow that follows this frame.
 46400:       nsInlineFrame* nextInFlow = static_cast<nsInlineFrame*>(GetNextInFlow());
 46400:       while (nextInFlow) {
     1:         if (nextInFlow->mFrames.NotEmpty()) {
  4006:           NS_FRAME_SET_INCOMPLETE(aStatus);
     1:           break;
     1:         }
 46400:         nextInFlow = static_cast<nsInlineFrame*>(nextInFlow->GetNextInFlow());
     1:       }
     1:     }
 46400:     return NS_OK;
     1:   }
 46400: 
 46400:   if (!NS_FRAME_IS_FULLY_COMPLETE(aStatus) && !reflowingFirstLetter) {
     1:     nsIFrame* nextFrame = aFrame->GetNextSibling();
     1:     if (nextFrame) {
 34500:       PushFrames(aPresContext, nextFrame, aFrame, irs);
     1:     }
     1:   }
 46400:   return NS_OK;
     1: }
     1: 
     1: nsIFrame*
     1: nsInlineFrame::PullOneFrame(nsPresContext* aPresContext,
     1:                             InlineReflowState& irs,
 79445:                             bool* aIsComplete)
     1: {
 79445:   bool isComplete = true;
     1: 
106838:   nsIFrame* frame = nullptr;
     1:   nsInlineFrame* nextInFlow = irs.mNextInFlow;
106838:   while (nullptr != nextInFlow) {
   686:     frame = nextInFlow->mFrames.FirstChild();
 37866:     if (!frame) {
110158:       // The nextInFlow's principal list has no frames, try its overflow list.
110158:       nsFrameList* overflowFrames = nextInFlow->GetOverflowFrames();
 37866:       if (overflowFrames) {
110158:         frame = overflowFrames->FirstChild();
110158:         if (!frame->GetNextSibling()) {
110158:           // We're stealing the only frame - delete the overflow list.
110158:           delete nextInFlow->StealOverflowFrames();
110158:         } else {
110158:           // We leave the remaining frames on the overflow list (rather than
110158:           // putting them on nextInFlow's principal list) so we don't have to
110158:           // set up the parent for them.
110158:           overflowFrames->RemoveFirstChild();
110158:         }
110158:         // ReparentFloatsForInlineChild needs it to be on a child list -
110158:         // we remove it again below.
110158:         nextInFlow->mFrames.SetFrames(frame);
 37866:       }
 37866:     }
 37866: 
106838:     if (nullptr != frame) {
   686:       // If our block has no next continuation, then any floats belonging to
   686:       // the pulled frame must belong to our block already. This check ensures
   686:       // we do no extra work in the common non-vertical-breaking case.
   686:       if (irs.mLineContainer && irs.mLineContainer->GetNextContinuation()) {
   686:         // The blockChildren.ContainsFrame check performed by
   686:         // ReparentFloatsForInlineChild will be fast because frame's ancestor
   686:         // will be the first child of its containing block.
 80486:         ReparentFloatsForInlineChild(irs.mLineContainer, frame, false);
   686:       }
   686:       nextInFlow->mFrames.RemoveFirstChild();
110158:       // nsFirstLineFrame::PullOneFrame calls ReparentStyleContext.
 36452: 
   686:       mFrames.InsertFrame(this, irs.mPrevFrame, frame);
 80486:       isComplete = false;
 34500:       if (irs.mLineLayout) {
 34500:         irs.mLineLayout->SetDirtyNextLine();
 34500:       }
 68656:       nsContainerFrame::ReparentFrameView(aPresContext, frame, nextInFlow, this);
     1:       break;
     1:     }
     1:     nextInFlow = (nsInlineFrame*) nextInFlow->GetNextInFlow();
     1:     irs.mNextInFlow = nextInFlow;
     1:   }
     1: 
     1:   *aIsComplete = isComplete;
     1:   return frame;
     1: }
     1: 
     1: void
     1: nsInlineFrame::PushFrames(nsPresContext* aPresContext,
     1:                           nsIFrame* aFromChild,
 34500:                           nsIFrame* aPrevSibling,
 34500:                           InlineReflowState& aState)
     1: {
 32841:   NS_PRECONDITION(aFromChild, "null pointer");
 32841:   NS_PRECONDITION(aPrevSibling, "pushing first child");
     1:   NS_PRECONDITION(aPrevSibling->GetNextSibling() == aFromChild, "bad prev sibling");
     1: 
     1: #ifdef NOISY_PUSHING
     1:   printf("%p pushing aFromChild %p, disconnecting from prev sib %p\n", 
     1:          this, aFromChild, aPrevSibling);
     1: #endif
     1: 
     1:   // Add the frames to our overflow list (let our next in flow drain
     1:   // our overflow list when it is ready)
 32841:   SetOverflowFrames(aPresContext, mFrames.RemoveFramesAfter(aPrevSibling));
 34500:   if (aState.mLineLayout) {
 34500:     aState.mLineLayout->SetDirtyNextLine();
 34500:   }
     1: }
     1: 
     1: 
     1: //////////////////////////////////////////////////////////////////////
     1: 
107846: int
     1: nsInlineFrame::GetSkipSides() const
     1: {
107846:   int skip = 0;
     1:   if (!IsLeftMost()) {
     1:     nsInlineFrame* prev = (nsInlineFrame*) GetPrevContinuation();
     1:     if ((GetStateBits() & NS_INLINE_FRAME_BIDI_VISUAL_STATE_IS_SET) ||
     1:         (prev && (prev->mRect.height || prev->mRect.width))) {
     1:       // Prev continuation is not empty therefore we don't render our left
     1:       // border edge.
     1:       skip |= 1 << NS_SIDE_LEFT;
     1:     }
     1:     else {
     1:       // If the prev continuation is empty, then go ahead and let our left
     1:       // edge border render.
     1:     }
     1:   }
     1:   if (!IsRightMost()) {
     1:     nsInlineFrame* next = (nsInlineFrame*) GetNextContinuation();
     1:     if ((GetStateBits() & NS_INLINE_FRAME_BIDI_VISUAL_STATE_IS_SET) ||
     1:         (next && (next->mRect.height || next->mRect.width))) {
     1:       // Next continuation is not empty therefore we don't render our right
     1:       // border edge.
     1:       skip |= 1 << NS_SIDE_RIGHT;
     1:     }
     1:     else {
     1:       // If the next continuation is empty, then go ahead and let our right
     1:       // edge border render.
     1:     }
     1:   }
 28217: 
 28217:   if (GetStateBits() & NS_FRAME_IS_SPECIAL) {
 34460:     // All but the last part of an {ib} split should skip the "end" side (as
 34460:     // determined by this frame's direction) and all but the first part of such
 34460:     // a split should skip the "start" side.  But figuring out which part of
 34460:     // the split we are involves getting our first continuation, which might be
 28217:     // expensive.  So don't bother if we already have the relevant bits set.
 79445:     bool ltr = (NS_STYLE_DIRECTION_LTR == GetStyleVisibility()->mDirection);
107846:     int startBit = (1 << (ltr ? NS_SIDE_LEFT : NS_SIDE_RIGHT));
107846:     int endBit = (1 << (ltr ? NS_SIDE_RIGHT : NS_SIDE_LEFT));
 28217:     if (((startBit | endBit) & skip) != (startBit | endBit)) {
 28217:       // We're missing one of the skip bits, so check whether we need to set it.
 34460:       // Only get the first continuation once, as an optimization.
 34460:       nsIFrame* firstContinuation = GetFirstContinuation();
 34460:       if (nsLayoutUtils::FrameIsNonLastInIBSplit(firstContinuation)) {
 28217:         skip |= endBit;
 34460:       }
 34460:       if (nsLayoutUtils::FrameIsNonFirstInIBSplit(firstContinuation)) {
 28217:         skip |= startBit;
 28217:       }
 28217:     }
 28217:   }
 28217: 
     1:   return skip;
     1: }
     1: 
 56866: nscoord
 56866: nsInlineFrame::GetBaseline() const
 56866: {
 74800:   return mBaseline;
 64444: }
 64444: 
 79483: void
 79483: nsInlineFrame::DestroyFrom(nsIFrame* aDestructRoot)
 79483: {
 79483:   DestroyAbsoluteFrames(aDestructRoot);
 86231:   nsContainerFrame::DestroyFrom(aDestructRoot);
 79483: }
 79483: 
     1: #ifdef ACCESSIBILITY
 99648: already_AddRefed<Accessible>
 46338: nsInlineFrame::CreateAccessible()
     1: {
     1:   // Broken image accessibles are created here, because layout
     1:   // replaces the image or image control frame with an inline frame
     1:   nsIAtom *tagAtom = mContent->Tag();
     1:   if ((tagAtom == nsGkAtoms::img || tagAtom == nsGkAtoms::input || 
 33329:        tagAtom == nsGkAtoms::label) && mContent->IsHTML()) {
     1:     // Only get accessibility service if we're going to use it
 61464: 
 61464:     nsAccessibilityService* accService = nsIPresShell::AccService();
     1:     if (!accService)
106838:       return nullptr;
     1:     if (tagAtom == nsGkAtoms::input)  // Broken <input type=image ... />
 46338:       return accService->CreateHTMLButtonAccessible(mContent,
 46338:                                                     PresContext()->PresShell());
     1:     else if (tagAtom == nsGkAtoms::img)  // Create accessible for broken <img>
 46338:       return accService->CreateHTMLImageAccessible(mContent,
 46338:                                                    PresContext()->PresShell());
     1:     else if (tagAtom == nsGkAtoms::label)  // Creat accessible for <label>
 46338:       return accService->CreateHTMLLabelAccessible(mContent,
 46338:                                                    PresContext()->PresShell());
     1:   }
     1: 
106838:   return nullptr;
     1: }
     1: #endif
     1: 
     1: //////////////////////////////////////////////////////////////////////
     1: 
     1: // nsLineFrame implementation
     1: 
     1: nsIFrame*
     1: NS_NewFirstLineFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
     1: {
     1:   return new (aPresShell) nsFirstLineFrame(aContext);
     1: }
     1: 
 32423: NS_IMPL_FRAMEARENA_HELPERS(nsFirstLineFrame)
 32423: 
     1: #ifdef DEBUG
     1: NS_IMETHODIMP
     1: nsFirstLineFrame::GetFrameName(nsAString& aResult) const
     1: {
     1:   return MakeFrameName(NS_LITERAL_STRING("Line"), aResult);
     1: }
     1: #endif
     1: 
     1: nsIAtom*
     1: nsFirstLineFrame::GetType() const
     1: {
     1:   return nsGkAtoms::lineFrame;
     1: }
     1: 
     1: nsIFrame*
   686: nsFirstLineFrame::PullOneFrame(nsPresContext* aPresContext, InlineReflowState& irs,
 79445:                                bool* aIsComplete)
     1: {
     1:   nsIFrame* frame = nsInlineFrame::PullOneFrame(aPresContext, irs, aIsComplete);
     1:   if (frame && !GetPrevInFlow()) {
     1:     // We are a first-line frame. Fixup the child frames
     1:     // style-context that we just pulled.
     1:     NS_ASSERTION(frame->GetParent() == this, "Incorrect parent?");
 40137:     aPresContext->FrameManager()->ReparentStyleContext(frame);
     1:   }
     1:   return frame;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsFirstLineFrame::Reflow(nsPresContext* aPresContext,
     1:                          nsHTMLReflowMetrics& aMetrics,
     1:                          const nsHTMLReflowState& aReflowState,
     1:                          nsReflowStatus& aStatus)
     1: {
106838:   if (nullptr == aReflowState.mLineLayout) {
     1:     return NS_ERROR_INVALID_ARG;
     1:   }
     1: 
   686:   nsIFrame* lineContainer = aReflowState.mLineLayout->GetLineContainerFrame();
   686: 
     1:   // Check for an overflow list with our prev-in-flow
     1:   nsFirstLineFrame* prevInFlow = (nsFirstLineFrame*)GetPrevInFlow();
106838:   if (nullptr != prevInFlow) {
 30781:     nsAutoPtr<nsFrameList> prevOverflowFrames(prevInFlow->StealOverflowFrames());
     1:     if (prevOverflowFrames) {
   686:       // Assign all floats to our block if necessary
   686:       if (lineContainer && lineContainer->GetPrevContinuation()) {
 30781:         ReparentFloatsForInlineChild(lineContainer,
 30781:                                      prevOverflowFrames->FirstChild(),
 80486:                                      true);
   686:       }
 30781:       const nsFrameList::Slice& newFrames =
106838:         mFrames.InsertFrames(this, nullptr, *prevOverflowFrames);
 40137:       ReparentChildListStyle(aPresContext, newFrames, this);
     1:     }
     1:   }
     1: 
     1:   // It's also possible that we have an overflow list for ourselves
 30781:   nsAutoPtr<nsFrameList> overflowFrames(StealOverflowFrames());
     1:   if (overflowFrames) {
     1:     NS_ASSERTION(mFrames.NotEmpty(), "overflow list w/o frames");
     1: 
 30781:     const nsFrameList::Slice& newFrames =
106838:       mFrames.AppendFrames(nullptr, *overflowFrames);
 40137:     ReparentChildListStyle(aPresContext, newFrames, this);
     1:   }
     1: 
     1:   // Set our own reflow state (additional state above and beyond
     1:   // aReflowState)
     1:   InlineReflowState irs;
106838:   irs.mPrevFrame = nullptr;
   686:   irs.mLineContainer = lineContainer;
 36220:   irs.mLineLayout = aReflowState.mLineLayout;
     1:   irs.mNextInFlow = (nsInlineFrame*) GetNextInFlow();
     1: 
     1:   nsresult rv;
 79445:   bool wasEmpty = mFrames.IsEmpty();
     1:   if (wasEmpty) {
     1:     // Try to pull over one frame before starting so that we know
     1:     // whether we have an anonymous block or not.
 79445:     bool complete;
     1:     PullOneFrame(aPresContext, irs, &complete);
     1:   }
     1: 
106838:   if (nullptr == GetPrevInFlow()) {
     1:     // XXX This is pretty sick, but what we do here is to pull-up, in
     1:     // advance, all of the next-in-flows children. We re-resolve their
     1:     // style while we are at at it so that when we reflow they have
     1:     // the right style.
     1:     //
     1:     // All of this is so that text-runs reflow properly.
     1:     irs.mPrevFrame = mFrames.LastChild();
     1:     for (;;) {
 79445:       bool complete;
     1:       nsIFrame* frame = PullOneFrame(aPresContext, irs, &complete);
     1:       if (!frame) {
     1:         break;
     1:       }
     1:       irs.mPrevFrame = frame;
     1:     }
106838:     irs.mPrevFrame = nullptr;
     1:   }
     1:   else {
     1: // XXX do this in the Init method instead
     1:     // For continuations, we need to check and see if our style
     1:     // context is right. If its the same as the first-in-flow, then
     1:     // we need to fix it up (that way :first-line style doesn't leak
     1:     // into this continuation since we aren't the first line).
     1:     nsFirstLineFrame* first = (nsFirstLineFrame*) GetFirstInFlow();
     1:     if (mStyleContext == first->mStyleContext) {
     1:       // Fixup our style context and our children. First get the
     1:       // proper parent context.
     1:       nsStyleContext* parentContext = first->GetParent()->GetStyleContext();
     1:       if (parentContext) {
     1:         // Create a new style context that is a child of the parent
     1:         // style context thus removing the :first-line style. This way
     1:         // we behave as if an anonymous (unstyled) span was the child
     1:         // of the parent frame.
     1:         nsRefPtr<nsStyleContext> newSC;
     1:         newSC = aPresContext->StyleSet()->
 35554:           ResolveAnonymousBoxStyle(nsCSSAnonBoxes::mozLineFrame, parentContext);
     1:         if (newSC) {
     1:           // Switch to the new style context.
     1:           SetStyleContext(newSC);
     1: 
     1:           // Re-resolve all children
 40137:           ReparentChildListStyle(aPresContext, mFrames, this);
     1:         }
     1:       }
     1:     }
     1:   }
     1: 
     1:   NS_ASSERTION(!aReflowState.mLineLayout->GetInFirstLine(),
     1:                "Nested first-line frames? BOGUS");
 80486:   aReflowState.mLineLayout->SetInFirstLine(true);
     1:   rv = ReflowFrames(aPresContext, aReflowState, irs, aMetrics, aStatus);
 80486:   aReflowState.mLineLayout->SetInFirstLine(false);
     1: 
 79483:   ReflowAbsoluteFrames(aPresContext, aMetrics, aReflowState, aStatus);
 79483: 
     1:   // Note: the line layout code will properly compute our overflow state for us
     1: 
     1:   return rv;
     1: }
     1: 
 30638: /* virtual */ void
 30638: nsFirstLineFrame::PullOverflowsFromPrevInFlow()
 30638: {
 30638:   nsFirstLineFrame* prevInFlow = static_cast<nsFirstLineFrame*>(GetPrevInFlow());
 30638:   if (prevInFlow) {
 30781:     nsAutoPtr<nsFrameList> prevOverflowFrames(prevInFlow->StealOverflowFrames());
 30638:     if (prevOverflowFrames) {
 30638:       // Assume that our prev-in-flow has the same line container that we do.
 30781:       const nsFrameList::Slice& newFrames =
106838:         mFrames.InsertFrames(this, nullptr, *prevOverflowFrames);
 40137:       ReparentChildListStyle(PresContext(), newFrames, this);
 30638:     }
 30638:   }
 30638: }
 30638: 
