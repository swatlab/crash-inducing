53178: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
53178:  * vim: set ts=4 sw=4 et tw=99:
53178:  *
53178:  * ***** BEGIN LICENSE BLOCK *****
53168:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
53168:  *
53168:  * The contents of this file are subject to the Mozilla Public License Version
53168:  * 1.1 (the "License"); you may not use this file except in compliance with
53168:  * the License. You may obtain a copy of the License at
53168:  * http://www.mozilla.org/MPL/
53168:  *
53168:  * Software distributed under the License is distributed on an "AS IS" basis,
53168:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
53168:  * for the specific language governing rights and limitations under the
53168:  * License.
53168:  *
53168:  * The Original Code is Mozilla Jaegermonkey.
53168:  *
53168:  * The Initial Developer of the Original Code is the Mozilla Foundation.
53168:  *
53168:  * Portions created by the Initial Developer are Copyright (C) 2010
53168:  * the Initial Developer. All Rights Reserved.
53168:  *
53168:  * Contributor(s):
53168:  *   Andrew Drake <drakedevel@gmail.com>
53168:  *
53168:  * Alternatively, the contents of this file may be used under the terms of
53168:  * either the GNU General Public License Version 2 or later (the "GPL"), or
53168:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
53168:  * in which case the provisions of the GPL or the LGPL are applicable instead
53168:  * of those above. If you wish to allow use of your version of this file only
53168:  * under the terms of either the GPL or the LGPL, and not to allow others to
53168:  * use your version of this file under the terms of the MPL, indicate your
53168:  * decision by deleting the provisions above and replace them with the notice
53168:  * and other provisions required by the GPL or the LGPL. If you do not delete
53168:  * the provisions above, a recipient may use your version of this file under
53168:  * the terms of any one of the MPL, the GPL or the LGPL.
53168:  *
53168:  * ***** END LICENSE BLOCK ***** */
53168: 
53168: /*
53168:  * Retroactive continuity ("retcon") refers to the retroactive modification
53168:  * or reinterpretation of established facts. 
53168:  */
53168: 
53178: #if !defined jsjaeger_retcon_h__ && defined JS_METHODJIT
53178: #define jsjaeger_retcon_h__
53168: 
53168: #include "jscntxt.h"
53168: #include "jsscript.h"
53168: #include "MethodJIT.h"
53168: #include "Compiler.h"
53168: 
53168: namespace js {
53168: namespace mjit {
53168: 
53168: /*
53168:  * A problem often arises where, for one reason or another, a piece of code
53168:  * wants to touch the script->code, but isn't expecting JSOP_TRAP. This allows
53168:  * one to temporarily remove JSOP_TRAPs from the instruction stream (without
53168:  * copying) and automatically re-add them on scope exit.
53168:  */
53168: class AutoScriptRetrapper
53168: {
53168:   public:
53168:     AutoScriptRetrapper(JSContext *cx1, JSScript *script1) :
53168:         cx(cx1), script(script1), traps(cx) {};
53168:     ~AutoScriptRetrapper();
53168: 
53168:     bool untrap(jsbytecode *pc);
53168: 
53168:   private:
53168:     JSContext *cx;
53168:     JSScript *script;
53168:     Vector<jsbytecode*> traps;
53168: };
53168: 
53168: /*
53168:  * This class is responsible for sanely re-JITing a script and fixing up
53168:  * the world. If you ever change the code associated with a JSScript, or
53168:  * otherwise would cause existing JITed code to be incorrect, you /must/ use
53168:  * this to invalidate and potentially re-compile the existing JITed code,
53168:  * fixing up the stack in the process.
53168:  */
53168: class Recompiler {
53168:     struct PatchableAddress {
53168:         void **location;
53168:         CallSite callSite;
53168:     };
53168: 
75636:     struct PatchableNative {
75636:         jsbytecode *pc;
75636:         JSObject *guardedNative;
75636:         JSC::ExecutablePool *pool;
75636:         JSC::CodeLocationLabel nativeStart;
75636:         JSC::CodeLocationJump nativeFunGuard;
75636:         JSC::CodeLocationJump nativeJump;
75636:     };
75636: 
53168: public:
53168:     Recompiler(JSContext *cx, JSScript *script);
53168:     
53168:     bool recompile();
53168: 
75864:     static void
75864:     expandInlineFrames(JSContext *cx, JSStackFrame *fp, mjit::CallSite *inlined,
75864:                        JSStackFrame *next, VMFrame *f);
75864: 
53168: private:
53168:     JSContext *cx;
53168:     JSScript *script;
53168: 
75864:     static PatchableAddress findPatch(JITScript *jit, void **location);
75864:     static void * findCallSite(JITScript *jit, const CallSite &callSite);
75864: 
75864:     static void applyPatch(JITScript *jit, PatchableAddress& toPatch);
75636:     PatchableNative stealNative(JITScript *jit, jsbytecode *pc);
75636:     void patchNative(JITScript *jit, PatchableNative &native);
75910:     bool recompile(JSScript *script, bool isConstructing,
75910:                    Vector<PatchableFrame> &frames,
75708:                    Vector<PatchableAddress> &patches, Vector<CallSite> &sites,
75883:                    Vector<PatchableNative> &natives);
75636: 
75864:     static JSStackFrame *
75864:     expandInlineFrameChain(JSContext *cx, JSStackFrame *outer, InlineFrame *inner);
75864: 
75636:     /* Detach jit from any IC callers and save any traps to sites. */
75883:     bool cleanup(JITScript *jit, Vector<CallSite> *sites);
53168: };
53168: 
53170: } /* namespace mjit */
53170: } /* namespace js */
53168: 
53168: #endif
53178: 
