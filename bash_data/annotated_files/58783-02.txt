    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <pavlov@netscape.com>
    1:  *   Chris Saari <saari@netscape.com>
 7009:  *   Federico Mena-Quintero <federico@novell.com>
32424:  *   Bobby Holley <bobbyholley@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /** @file
50549:  * This file declares the RasterImage class, which
50549:  * handles static and animated rasterized images.
    1:  *
    1:  * @author  Stuart Parmenter <pavlov@netscape.com>
    1:  * @author  Chris Saari <saari@netscape.com>
    1:  * @author  Arron Mogge <paper@animecity.nu>
    1:  * @author  Andrew Smith <asmith15@learn.senecac.on.ca>
    1:  */
    1: 
50549: #ifndef mozilla_imagelib_RasterImage_h_
50549: #define mozilla_imagelib_RasterImage_h_
    1: 
50545: #include "Image.h"
    1: #include "nsCOMArray.h"
    1: #include "nsCOMPtr.h"
    1: #include "imgIContainer.h"
    1: #include "nsIProperties.h"
    1: #include "nsITimer.h"
    1: #include "nsWeakReference.h"
 7009: #include "nsTArray.h"
30479: #include "imgFrame.h"
32424: #include "nsThreadUtils.h"
50548: #include "DiscardTracker.h"
52150: #ifdef DEBUG
52150:   #include "imgIContainerDebug.h"
52150: #endif
    1: 
50546: class imgIDecoder;
50546: class nsIInputStream;
50546: 
50549: #define NS_RASTERIMAGE_CID \
48934: { /* 376ff2c1-9bf6-418a-b143-3340c00112f7 */         \
30479:      0x376ff2c1,                                     \
30479:      0x9bf6,                                         \
30479:      0x418a,                                         \
30479:     {0xb1, 0x43, 0x33, 0x40, 0xc0, 0x01, 0x12, 0xf7} \
    1: }
    1: 
    1: /**
    1:  * Handles static and animated image containers.
    1:  *
    1:  *
    1:  * @par A Quick Walk Through
    1:  * The decoder initializes this class and calls AppendFrame() to add a frame.
50549:  * Once RasterImage detects more than one frame, it starts the animation
    1:  * with StartAnimation().
    1:  *
    1:  * @par
52149:  * StartAnimation() creates a timer.  The timer calls Notify when the
52149:  * specified frame delay time is up.
    1:  *
    1:  * @par
    1:  * Notify() moves on to the next frame, sets up the new timer delay, destroys
    1:  * the old frame, and forces a redraw via observer->FrameChanged().
    1:  *
    1:  * @par
    1:  * Each frame can have a different method of removing itself. These are
    1:  * listed as imgIContainer::cDispose... constants.  Notify() calls 
    1:  * DoComposite() to handle any special frame destruction.
    1:  *
    1:  * @par
    1:  * The basic path through DoComposite() is:
    1:  * 1) Calculate Area that needs updating, which is at least the area of
    1:  *    aNextFrame.
    1:  * 2) Dispose of previous frame.
    1:  * 3) Draw new image onto compositingFrame.
    1:  * See comments in DoComposite() for more information and optimizations.
    1:  *
    1:  * @par
50549:  * The rest of the RasterImage specific functions are used by DoComposite to
    1:  * destroy the old frame and build the new one.
    1:  *
    1:  * @note
42263:  * <li> "Mask", "Alpha", and "Alpha Level" are interchangeable phrases in
50549:  * respects to RasterImage.
    1:  *
    1:  * @par
    1:  * <li> GIFs never have more than a 1 bit alpha.
    1:  * <li> APNGs may have a full alpha channel.
    1:  *
    1:  * @par
    1:  * <li> Background color specified in GIF is ignored by web browsers.
    1:  *
    1:  * @par
    1:  * <li> If Frame 3 wants to dispose by restoring previous, what it wants is to
    1:  * restore the composition up to and including Frame 2, as well as Frame 2s
    1:  * disposal.  So, in the middle of DoComposite when composing Frame 3, right
    1:  * after destroying Frame 2's area, we copy compositingFrame to
    1:  * prevCompositingFrame.  When DoComposite gets called to do Frame 4, we
    1:  * copy prevCompositingFrame back, and then draw Frame 4 on top.
    1:  *
    1:  * @par
    1:  * The mAnim structure has members only needed for animated images, so
    1:  * it's not allocated until the second frame is added.
    1:  *
    1:  * @note
    1:  * mAnimationMode, mLoopCount and mObserver are not in the mAnim structure
    1:  * because the first two have public setters and the observer we only get
    1:  * in Init().
    1:  */
50549: 
50549: namespace mozilla {
50549: namespace imagelib {
50549: 
32424: class imgDecodeWorker;
51242: class Decoder;
50549: 
52150: class RasterImage : public mozilla::imagelib::Image
52150:                   , public nsITimerCallback
52150:                   , public nsIProperties
52150:                   , public nsSupportsWeakReference
52150: #ifdef DEBUG
52150:                   , public imgIContainerDebug
52150: #endif
    1: {
    1: public:
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSITIMERCALLBACK
 2663:   NS_DECL_NSIPROPERTIES
52150: #ifdef DEBUG
52150:   NS_DECL_IMGICONTAINERDEBUG
52150: #endif
    1: 
57656:   // BEGIN NS_DECL_IMGICONTAINER (minus GetAnimationMode/SetAnimationMode)
57655:   // ** Don't edit this chunk except to mirror changes in imgIContainer.idl **
57655:   NS_SCRIPTABLE NS_IMETHOD GetWidth(PRInt32 *aWidth);
57655:   NS_SCRIPTABLE NS_IMETHOD GetHeight(PRInt32 *aHeight);
57655:   NS_SCRIPTABLE NS_IMETHOD GetType(PRUint16 *aType);
58783:   NS_IMETHOD_(PRUint16) GetType(void);
57655:   NS_SCRIPTABLE NS_IMETHOD GetAnimated(PRBool *aAnimated);
57655:   NS_SCRIPTABLE NS_IMETHOD GetCurrentFrameIsOpaque(PRBool *aCurrentFrameIsOpaque);
57655:   NS_IMETHOD GetFrame(PRUint32 aWhichFrame, PRUint32 aFlags, gfxASurface **_retval NS_OUTPARAM);
57655:   NS_IMETHOD CopyFrame(PRUint32 aWhichFrame, PRUint32 aFlags, gfxImageSurface **_retval NS_OUTPARAM);
57655:   NS_IMETHOD ExtractFrame(PRUint32 aWhichFrame, const nsIntRect & aRect, PRUint32 aFlags, imgIContainer **_retval NS_OUTPARAM);
57655:   NS_IMETHOD Draw(gfxContext *aContext, gfxPattern::GraphicsFilter aFilter, const gfxMatrix & aUserSpaceToImageSpace, const gfxRect & aFill, const nsIntRect & aSubimage, const nsIntSize & aViewportSize, PRUint32 aFlags);
57655:   NS_IMETHOD_(nsIFrame *) GetRootLayoutFrame(void);
57655:   NS_SCRIPTABLE NS_IMETHOD RequestDecode(void);
57655:   NS_SCRIPTABLE NS_IMETHOD LockImage(void);
57655:   NS_SCRIPTABLE NS_IMETHOD UnlockImage(void);
57655:   NS_SCRIPTABLE NS_IMETHOD ResetAnimation(void);
57655:   // END NS_DECL_IMGICONTAINER
57655: 
51296:   RasterImage(imgStatusTracker* aStatusTracker = nsnull);
50549:   virtual ~RasterImage();
    1: 
52149:   virtual nsresult StartAnimation();
52149:   virtual nsresult StopAnimation();
52149: 
50555:   // Methods inherited from Image
50555:   nsresult Init(imgIDecoderObserver* aObserver,
50555:                 const char* aMimeType,
53660:                 const char* aURIString,
50555:                 PRUint32 aFlags);
51294:   void     GetCurrentFrameRect(nsIntRect& aRect);
50555: 
50555:   // Raster-specific methods
50556:   static NS_METHOD WriteToRasterImage(nsIInputStream* aIn, void* aClosure,
50556:                                       const char* aFromRawSegment,
50556:                                       PRUint32 aToOffset, PRUint32 aCount,
50556:                                       PRUint32* aWriteCount);
32424: 
51295:   /* The index of the current frame that would be drawn if the image was to be
51295:    * drawn now. */
51295:   PRUint32 GetCurrentFrameIndex();
51295: 
51295:   /* The total number of frames in this image. */
51295:   PRUint32 GetNumFrames();
51295: 
42553:   PRUint32 GetDecodedDataSize();
42553:   PRUint32 GetSourceDataSize();
42553: 
46991:   /* Triggers discarding. */
46991:   void Discard();
46991: 
50553:   /* Callbacks for decoders */
50553:   nsresult SetFrameDisposalMethod(PRUint32 aFrameNum,
50553:                                   PRInt32 aDisposalMethod);
50553:   nsresult SetFrameTimeout(PRUint32 aFrameNum, PRInt32 aTimeout);
50553:   nsresult SetFrameBlendMethod(PRUint32 aFrameNum, PRInt32 aBlendMethod);
50553:   nsresult SetFrameHasNoAlpha(PRUint32 aFrameNum);
50553: 
50553:   /**
50553:    * Sets the size of the container. This should only be called by the
50553:    * decoder. This function may be called multiple times, but will throw an
50553:    * error if subsequent calls do not match the first.
50553:    */
50553:   nsresult SetSize(PRInt32 aWidth, PRInt32 aHeight);
50553: 
50553:   nsresult EnsureCleanFrame(PRUint32 aFramenum, PRInt32 aX, PRInt32 aY,
50553:                             PRInt32 aWidth, PRInt32 aHeight,
50553:                             gfxASurface::gfxImageFormat aFormat,
50553:                             PRUint8** imageData,
50553:                             PRUint32* imageLength);
50553: 
50553:   /**
50553:    * Adds to the end of the list of frames.
50553:    */
50553:   nsresult AppendFrame(PRInt32 aX, PRInt32 aY,
50553:                        PRInt32 aWidth, PRInt32 aHeight,
50553:                        gfxASurface::gfxImageFormat aFormat,
50553:                        PRUint8** imageData,
50553:                        PRUint32* imageLength);
50553: 
50553:   nsresult AppendPalettedFrame(PRInt32 aX, PRInt32 aY,
50553:                                PRInt32 aWidth, PRInt32 aHeight,
50553:                                gfxASurface::gfxImageFormat aFormat,
50553:                                PRUint8 aPaletteDepth,
50553:                                PRUint8**  imageData,
50553:                                PRUint32*  imageLength,
50553:                                PRUint32** paletteData,
50553:                                PRUint32*  paletteLength);
50553: 
51592:   void FrameUpdated(PRUint32 aFrameNum, nsIntRect& aUpdatedRect);
50553: 
50553:   /* notification that the entire image has been decoded */
50553:   nsresult DecodingComplete();
50553: 
50553:   /**
50553:    * Number of times to loop the image.
50553:    * @note -1 means forever.
50553:    */
50553:   void     SetLoopCount(PRInt32 aLoopCount);
50553: 
50553:   /* Add compressed source data to the imgContainer.
50553:    *
50553:    * The decoder will use this data, either immediately or at draw time, to
50553:    * decode the image.
50553:    *
50553:    * XXX This method's only caller (WriteToContainer) ignores the return
50553:    * value. Should this just return void?
50553:    */
50553:   nsresult AddSourceData(const char *aBuffer, PRUint32 aCount);
50553: 
50553:   /* Called after the all the source data has been added with addSourceData. */
50553:   virtual nsresult SourceDataComplete();
50553: 
50553:   /* Called for multipart images when there's a new source image to add. */
50553:   virtual nsresult NewSourceData();
50553: 
50553:   /**
50553:    * A hint of the number of bytes of source data that the image contains. If
50553:    * called early on, this can help reduce copying and reallocations by
50553:    * appropriately preallocating the source data buffer.
50553:    *
50553:    * We take this approach rather than having the source data management code do
50553:    * something more complicated (like chunklisting) because HTTP is by far the
50553:    * dominant source of images, and the Content-Length header is quite reliable.
50553:    * Thus, pre-allocation simplifies code and reduces the total number of
50553:    * allocations.
50553:    */
50553:   virtual nsresult SetSourceSizeHint(PRUint32 sizeHint);
50553: 
50553:   // "Blend" method indicates how the current image is combined with the
50553:   // previous image.
50553:   enum {
50553:     // All color components of the frame, including alpha, overwrite the current
50553:     // contents of the frame's output buffer region
50553:     kBlendSource =  0,
50553: 
50553:     // The frame should be composited onto the output buffer based on its alpha,
50553:     // using a simple OVER operation
50553:     kBlendOver
50553:   };
50553: 
50553:   enum {
50553:     kDisposeClearAll         = -1, // Clear the whole image, revealing
50553:                                    // what was there before the gif displayed
50553:     kDisposeNotSpecified,   // Leave frame, let new frame draw on top
50553:     kDisposeKeep,           // Leave frame, let new frame draw on top
50553:     kDisposeClear,          // Clear the frame's area, revealing bg
50553:     kDisposeRestorePrevious // Restore the previous (composited) frame
50553:   };
50553: 
51590:   // Progressive decoding knobs
51590:   static void SetDecodeBytesAtATime(PRUint32 aBytesAtATime);
51590:   static void SetMaxMSBeforeYield(PRUint32 aMaxMS);
51595:   static void SetMaxBytesForSyncDecode(PRUint32 aMaxBytes);
51590: 
53674:   const char* GetURIString() { return mURIString.get();}
53674: 
    1: private:
    1:   struct Anim
    1:   {
    1:     //! Area of the first frame that needs to be redrawn on subsequent loops.
    1:     nsIntRect                  firstFrameRefreshArea;
32424:     PRUint32                   currentAnimationFrameIndex; // 0 to numFrames-1
    1:     //! Track the last composited frame for Optimizations (See DoComposite code)
    1:     PRInt32                    lastCompositedFrameIndex;
    1:     /** For managing blending of frames
    1:      *
    1:      * Some animations will use the compositingFrame to composite images
    1:      * and just hand this back to the caller when it is time to draw the frame.
    1:      * NOTE: When clearing compositingFrame, remember to set
    1:      *       lastCompositedFrameIndex to -1.  Code assume that if
    1:      *       lastCompositedFrameIndex >= 0 then compositingFrame exists.
    1:      */
30479:     nsAutoPtr<imgFrame>        compositingFrame;
    1:     /** the previous composited frame, for DISPOSE_RESTORE_PREVIOUS
    1:      *
    1:      * The Previous Frame (all frames composited up to the current) needs to be
    1:      * stored in cases where the image specifies it wants the last frame back
    1:      * when it's done with the current frame.
    1:      */
30479:     nsAutoPtr<imgFrame>        compositingPrevFrame;
    1:     //! Timer to animate multiframed images
    1:     nsCOMPtr<nsITimer>         timer;
    1: 
    1:     Anim() :
    1:       firstFrameRefreshArea(),
    1:       currentAnimationFrameIndex(0),
53666:       lastCompositedFrameIndex(-1)
    1:     {
    1:       ;
    1:     }
    1:     ~Anim()
    1:     {
    1:       if (timer)
    1:         timer->Cancel();
    1:     }
    1:   };
    1: 
39120:   /**
39120:    * Deletes and nulls out the frame in mFrames[framenum].
39120:    *
39120:    * Does not change the size of mFrames.
39120:    *
39120:    * @param framenum The index of the frame to be deleted. 
39120:    *                 Must lie in [0, mFrames.Length() )
39120:    */
39120:   void DeleteImgFrame(PRUint32 framenum);
39120: 
30479:   imgFrame* GetImgFrame(PRUint32 framenum);
34809:   imgFrame* GetDrawableImgFrame(PRUint32 framenum);
30479:   imgFrame* GetCurrentImgFrame();
34809:   imgFrame* GetCurrentDrawableImgFrame();
32424:   PRUint32 GetCurrentImgFrameIndex() const;
    1:   
32424:   inline Anim* ensureAnimExists()
32424:   {
32424:     if (!mAnim) {
32424: 
32424:       // Create the animation context
    1:       mAnim = new Anim();
32424: 
32515:       // We don't support discarding animated images (See bug 414259).
32515:       // Lock the image and throw away the key.
32515:       // 
32515:       // Note that this is inefficient, since we could get rid of the source
32515:       // data too. However, doing this is actually hard, because we're probably
32515:       // calling ensureAnimExists mid-decode, and thus we're decoding out of
32515:       // the source buffer. Since we're going to fix this anyway later, and
32515:       // since we didn't kill the source data in the old world either, locking
32515:       // is acceptable for the moment.
32515:       LockImage();
32424:     }
    1:     return mAnim;
    1:   }
    1:   
    1:   /** Function for doing the frame compositing of animations
    1:    *
    1:    * @param aFrameToUse Set by DoComposite
    1:    *                   (aNextFrame, compositingFrame, or compositingPrevFrame)
    1:    * @param aDirtyRect  Area that the display will need to update
    1:    * @param aPrevFrame  Last Frame seen/processed
    1:    * @param aNextFrame  Frame we need to incorperate/display
    1:    * @param aNextFrameIndex Position of aNextFrame in mFrames list
    1:    */
30479:   nsresult DoComposite(imgFrame** aFrameToUse, nsIntRect* aDirtyRect,
30479:                        imgFrame* aPrevFrame,
30479:                        imgFrame* aNextFrame,
    1:                        PRInt32 aNextFrameIndex);
    1:   
 2200:   /** Clears an area of <aFrame> with transparent black.
    1:    *
    1:    * @param aFrame Target Frame
    1:    *
 2200:    * @note Does also clears the transparancy mask
    1:    */
30479:   static void ClearFrame(imgFrame* aFrame);
 2200:   
    1:   //! @overload
30479:   static void ClearFrame(imgFrame* aFrame, nsIntRect &aRect);
    1:   
30479:   //! Copy one frames's image and mask into another
30479:   static PRBool CopyFrameImage(imgFrame *aSrcFrame,
30479:                                imgFrame *aDstFrame);
    1:   
30479:   /** Draws one frames's image to into another,
 5275:    * at the position specified by aRect
 5275:    *
 5275:    * @param aSrcFrame  Frame providing the source image
 5275:    * @param aDstFrame  Frame where the image is drawn into
 5275:    * @param aRect      The position and size to draw the image
 5275:    */
30479:   static nsresult DrawFrameTo(imgFrame *aSrcFrame,
30479:                               imgFrame *aDstFrame,
 5275:                               nsIntRect& aRect);
 5275: 
30479:   nsresult InternalAddFrameHelper(PRUint32 framenum, imgFrame *frame,
30479:                                   PRUint8 **imageData, PRUint32 *imageLength,
30479:                                   PRUint32 **paletteData, PRUint32 *paletteLength);
30479:   nsresult InternalAddFrame(PRUint32 framenum, PRInt32 aX, PRInt32 aY, PRInt32 aWidth, PRInt32 aHeight,
30479:                             gfxASurface::gfxImageFormat aFormat, PRUint8 aPaletteDepth,
30479:                             PRUint8 **imageData, PRUint32 *imageLength,
30479:                             PRUint32 **paletteData, PRUint32 *paletteLength);
30479: 
30479: private: // data
30479: 
    1:   nsIntSize                  mSize;
    1:   
30479:   //! All the frames of the image
32424:   // IMPORTANT: if you use mFrames in a method, call EnsureImageIsDecoded() first 
32424:   // to ensure that the frames actually exist (they may have been discarded to save
32424:   // memory, or we may be decoding on draw).
30479:   nsTArray<imgFrame *>       mFrames;
    1:   
    1:   nsCOMPtr<nsIProperties>    mProperties;
    1: 
32424:   // IMPORTANT: if you use mAnim in a method, call EnsureImageIsDecoded() first to ensure
32424:   // that the frames actually exist (they may have been discarded to save memory, or
32424:   // we maybe decoding on draw).
50549:   RasterImage::Anim*        mAnim;
    1:   
    1:   //! # loops remaining before animation stops (-1 no stop)
    1:   PRInt32                    mLoopCount;
    1:   
32424:   //! imgIDecoderObserver
    1:   nsWeakPtr                  mObserver;
 7009: 
32424:   // Discard members
32424:   PRUint32                   mLockCount;
50549:   DiscardTrackerNode         mDiscardTrackerNode;
 7009: 
32424:   // Source data members
32424:   nsTArray<char>             mSourceData;
32424:   nsCString                  mSourceDataMimeType;
53660:   nsCString                  mURIString;
32424: 
32424:   friend class imgDecodeWorker;
50549:   friend class DiscardTracker;
32424: 
32424:   // Decoder and friends
51242:   nsRefPtr<Decoder>              mDecoder;
32424:   nsRefPtr<imgDecodeWorker>      mWorker;
32424:   PRUint32                       mBytesDecoded;
32424: 
52150: #ifdef DEBUG
52150:   PRUint32                       mFramesNotified;
52150: #endif
52150: 
42233:   // Boolean flags (clustered together to conserve space):
42233:   PRPackedBool               mHasSize:1;       // Has SetSize() been called?
42233:   PRPackedBool               mDecodeOnDraw:1;  // Decoding on draw?
42233:   PRPackedBool               mMultipart:1;     // Multipart?
42233:   PRPackedBool               mDiscardable:1;   // Is container discardable?
42233:   PRPackedBool               mHasSourceData:1; // Do we have source data?
42233: 
42233:   // Do we have the frames in decoded form?
42233:   PRPackedBool               mDecoded:1;
42233:   PRPackedBool               mHasBeenDecoded:1;
42233: 
42233:   // Helpers for decoder
42233:   PRPackedBool               mWorkerPending:1;
42233:   PRPackedBool               mInDecoder:1;
42233: 
52149:   // Whether the animation can stop, due to running out
52149:   // of frames, or no more owning request
52149:   PRPackedBool               mAnimationFinished:1;
52149: 
32424:   // Decoding
32424:   nsresult WantDecodedFrames();
32424:   nsresult SyncDecode();
51244:   nsresult InitDecoder(bool aDoSizeDecode);
32424:   nsresult WriteToDecoder(const char *aBuffer, PRUint32 aCount);
32424:   nsresult DecodeSomeData(PRUint32 aMaxBytes);
32424:   PRBool   IsDecodeFinished();
32424: 
32424:   // Decoder shutdown
32424:   enum eShutdownIntent {
32424:     eShutdownIntent_Done        = 0,
32424:     eShutdownIntent_Interrupted = 1,
32424:     eShutdownIntent_Error       = 2,
32424:     eShutdownIntent_AllCount    = 3
32424:   };
32424:   nsresult ShutdownDecoder(eShutdownIntent aIntent);
32424: 
32424:   // Helpers
32424:   void DoError();
32424:   PRBool CanDiscard();
46991:   PRBool DiscardingActive();
32424:   PRBool StoringSourceData();
32424: 
52149: protected:
52149:   PRBool ShouldAnimate();
    1: };
    1: 
50549: // XXXdholbert These helper classes should move to be inside the
50549: // scope of the RasterImage class.
32424: // Decoding Helper Class
32424: //
32424: // We use this class to mimic the interactivity benefits of threading
32424: // in a single-threaded event loop. We want to progressively decode
32424: // and keep a responsive UI while we're at it, so we have a runnable
32424: // class that does a bit of decoding, and then "yields" by dispatching
32424: // itself to the end of the event queue.
32424: class imgDecodeWorker : public nsRunnable
32424: {
32424:   public:
32424:     imgDecodeWorker(imgIContainer* aContainer) {
32424:       mContainer = do_GetWeakReference(aContainer);
32424:     }
32424:     NS_IMETHOD Run();
32424:     NS_METHOD  Dispatch();
32424: 
32424:   private:
32424:     nsWeakPtr mContainer;
32424: };
32424: 
32424: // Asynchronous Decode Requestor
32424: //
32424: // We use this class when someone calls requestDecode() from within a decode
32424: // notification. Since requestDecode() involves modifying the decoder's state
32424: // (for example, possibly shutting down a header-only decode and starting a
32424: // full decode), we don't want to do this from inside a decoder.
32424: class imgDecodeRequestor : public nsRunnable
32424: {
32424:   public:
32424:     imgDecodeRequestor(imgIContainer *aContainer) {
32424:       mContainer = do_GetWeakReference(aContainer);
32424:     }
32424:     NS_IMETHOD Run() {
32424:       nsCOMPtr<imgIContainer> con = do_QueryReferent(mContainer);
32424:       if (con)
32424:         con->RequestDecode();
32424:       return NS_OK;
32424:     }
32424: 
32424:   private:
32424:     nsWeakPtr mContainer;
32424: };
32424: 
50549: } // namespace imagelib
50549: } // namespace mozilla
32424: 
50549: #endif /* mozilla_imagelib_RasterImage_h_ */
