    1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Foundation code.
    1:  *
    1:  * The Initial Developer of the Original Code is Mozilla Foundation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <stuart@mozilla.com>
    1:  *   Vladimir Vukicevic <vladimir@pobox.com>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
    1:  *   Masatoshi Kimura <VYV03354@nifty.ne.jp>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "gfxWindowsPlatform.h"
    1: 
    1: #include "gfxImageSurface.h"
    1: #include "gfxWindowsSurface.h"
43347: #include "gfxTextRunWordCache.h"
    1: 
    1: #include "nsUnicharUtils.h"
    1: 
26915: #include "nsIPrefService.h"
26915: #include "nsIPrefBranch2.h"
    1: #include "nsServiceManagerUtils.h"
23904: #include "nsTArray.h"
    1: 
    1: #include "nsIWindowsRegKey.h"
19962: #include "nsILocalFile.h"
19962: #include "plbase64.h"
51658: #include "nsIXULRuntime.h"
    1: 
51736: #include "nsIGfxInfo.h"
51736: 
24104: #ifdef MOZ_FT2_FONTS
24104: #include "ft2build.h"
24104: #include FT_FREETYPE_H
24104: #include "gfxFT2Fonts.h"
38727: #include "gfxFT2FontList.h"
24104: #include "cairo-ft.h"
31344: #include "nsAppDirectoryServiceDefs.h"
24104: #else
36949: #include "gfxGDIFontList.h"
39447: #include "gfxGDIFont.h"
38782: #ifdef CAIRO_HAS_DWRITE_FONT
38727: #include "gfxDWriteFontList.h"
38727: #include "gfxDWriteFonts.h"
38727: #include "gfxDWriteCommon.h"
38727: #include <dwrite.h>
24104: #endif
38782: #endif
24104: 
61929: #include <shlobj.h>
61929: #include <shlwapi.h>
61635: 
38727: #ifdef CAIRO_HAS_D2D_SURFACE
38727: #include "gfxD2DSurface.h"
46438: 
50585: #include <d3d10_1.h>
50585: 
46438: #include "nsIMemoryReporter.h"
46438: #include "nsMemory.h"
46438: 
46438: class D2DCacheReporter :
46438:     public nsIMemoryReporter
46438: {
46438: public:
46438:     D2DCacheReporter()
46438:     { }
46438: 
46438:     NS_DECL_ISUPPORTS
46438: 
46438:     NS_IMETHOD GetPath(char **memoryPath) {
46438:         *memoryPath = strdup("gfx/d2d/surfacecache");
46438:         return NS_OK;
46438:     }
46438: 
46438:     NS_IMETHOD GetDescription(char **desc) {
46438:         *desc = strdup("Memory used by Direct2D internal surface cache.");
46438:         return NS_OK;
46438:     }
46438: 
46438:     NS_IMETHOD GetMemoryUsed(PRInt64 *memoryUsed) {
46438:         *memoryUsed = cairo_d2d_get_image_surface_cache_usage();
46438:         return NS_OK;
46438:     }
46438: }; 
46438: 
46438: NS_IMPL_ISUPPORTS1(D2DCacheReporter, nsIMemoryReporter)
50776: 
50776: class D2DVRAMReporter :
50776:     public nsIMemoryReporter
50776: {
50776: public:
50776:     D2DVRAMReporter()
50776:     { }
50776: 
50776:     NS_DECL_ISUPPORTS
50776: 
50776:     NS_IMETHOD GetPath(char **memoryPath) {
50776:         *memoryPath = strdup("gfx/d2d/surfacevram");
50776:         return NS_OK;
50776:     }
50776: 
50776:     NS_IMETHOD GetDescription(char **desc) {
50776:         *desc = strdup("Video memory used by D2D surfaces");
50776:         return NS_OK;
50776:     }
50776: 
50776:     NS_IMETHOD GetMemoryUsed(PRInt64 *memoryUsed) {
50875:         cairo_device_t *device =
50875:             gfxWindowsPlatform::GetPlatform()->GetD2DDevice();
50875:         if (device) {
50875:             *memoryUsed = cairo_d2d_get_surface_vram_usage(device);
50875:         } else {
50875:             *memoryUsed = 0;
50875:         }
50776:         return NS_OK;
50776:     }
50776: };
50776: 
50776: NS_IMPL_ISUPPORTS1(D2DVRAMReporter, nsIMemoryReporter)
38727: #endif
30086: 
24104: #ifdef WINCE
24104: #include <shlwapi.h>
24104: #endif
24104: 
19962: #include "gfxUserFontSet.h"
  270: 
    1: #include <string>
    1: 
42854: #define GFX_USE_CLEARTYPE_ALWAYS "gfx.font_rendering.cleartype.always_use_for_content"
42854: #define GFX_DOWNLOADABLE_FONTS_USE_CLEARTYPE "gfx.font_rendering.cleartype.use_for_downloadable_fonts"
42854: 
24104: #ifdef MOZ_FT2_FONTS
24104: static FT_Library gPlatformFTLibrary = NULL;
24104: #endif
 1959: 
38727: #ifdef CAIRO_HAS_DWRITE_FONT
38727: // DirectWrite is not available on all platforms, we need to use the function
38727: // pointer.
38727: typedef HRESULT (WINAPI*DWriteCreateFactoryFunc)(
38727:   __in   DWRITE_FACTORY_TYPE factoryType,
38727:   __in   REFIID iid,
38727:   __out  IUnknown **factory
38727: );
38727: #endif
38727: 
50585: #ifdef CAIRO_HAS_D2D_SURFACE
50585: typedef HRESULT (WINAPI*D3D10CreateDevice1Func)(
50585:   IDXGIAdapter *pAdapter,
50585:   D3D10_DRIVER_TYPE DriverType,
50585:   HMODULE Software,
50585:   UINT Flags,
50585:   D3D10_FEATURE_LEVEL1 HardwareLevel,
50585:   UINT SDKVersion,
50585:   ID3D10Device1 **ppDevice
50585: );
50585: #endif
50585: 
13578: static __inline void
13578: BuildKeyNameFromFontName(nsAString &aName)
13578: {
13578:     if (aName.Length() >= LF_FACESIZE)
13578:         aName.Truncate(LF_FACESIZE - 1);
13578:     ToLowerCase(aName);
13578: }
13280: 
36949: gfxWindowsPlatform::gfxWindowsPlatform()
 5254: {
36949:     mPrefFonts.Init(50);
 5254: 
42854:     mUseClearTypeForDownloadableFonts = UNINITIALIZED_VALUE;
42854:     mUseClearTypeAlways = UNINITIALIZED_VALUE;
42854: 
57104:     mUsingGDIFonts = PR_FALSE;
57104: 
51527:     /* 
51527:      * Initialize COM 
51527:      */ 
51527:     CoInitialize(NULL); 
51527: 
51035:     mScreenDC = GetDC(NULL);
51035: 
24104: #ifdef MOZ_FT2_FONTS
24104:     FT_Init_FreeType(&gPlatformFTLibrary);
24104: #endif
24104: 
53984: #ifdef CAIRO_HAS_D2D_SURFACE
53984:     NS_RegisterMemoryReporter(new D2DCacheReporter());
53984:     NS_RegisterMemoryReporter(new D2DVRAMReporter());
53984:     mD2DDevice = nsnull;
53984: #endif
53984: 
53984:     UpdateRenderMode();
53984: }
53984: 
53984: gfxWindowsPlatform::~gfxWindowsPlatform()
53984: {
53984:     ::ReleaseDC(NULL, mScreenDC);
53984:     // not calling FT_Done_FreeType because cairo may still hold references to
53984:     // these FT_Faces.  See bug 458169.
53984: #ifdef CAIRO_HAS_D2D_SURFACE
53984:     if (mD2DDevice) {
53984:         cairo_release_device(mD2DDevice);
53984:     }
53984: #endif
53984: 
53984:     /* 
53984:      * Uninitialize COM 
53984:      */ 
53984:     CoUninitialize();
53984: }
53984: 
53984: void
53984: gfxWindowsPlatform::UpdateRenderMode()
53984: {
30087: /* Pick the default render mode differently between
30087:  * desktop, Windows Mobile, and Windows CE.
30087:  */
30087: #if defined(WINCE_WINDOWS_MOBILE)
30087:     mRenderMode = RENDER_IMAGE_DDRAW16;
30087: #elif defined(WINCE)
30087:     mRenderMode = RENDER_DDRAW_GL;
30087: #else
30087:     mRenderMode = RENDER_GDI;
30087: #endif
30087: 
50585:     OSVERSIONINFOA versionInfo;
50585:     versionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
50585:     ::GetVersionExA(&versionInfo);
50585:     bool isVistaOrHigher = versionInfo.dwMajorVersion >= 6;
50585: 
51751:     PRBool safeMode = PR_FALSE;
51751:     nsCOMPtr<nsIXULRuntime> xr = do_GetService("@mozilla.org/xre/runtime;1");
51751:     if (xr)
51751:       xr->GetInSafeMode(&safeMode);
51751: 
53984:     nsCOMPtr<nsIPrefBranch2> pref = do_GetService(NS_PREFSERVICE_CONTRACTID);
53984:     nsresult rv;
53984: 
53984:     PRBool preferDirectWrite = PR_FALSE;
53984: 
53984:     rv = pref->GetBoolPref(
53984:         "gfx.font_rendering.directwrite.enabled", &preferDirectWrite);
53984:     if (NS_FAILED(rv)) {
53984:         preferDirectWrite = PR_FALSE;
53984:     }
53984: 
53984:     mUseDirectWrite = preferDirectWrite;
53984: 
51736: #ifdef CAIRO_HAS_D2D_SURFACE
51736:     PRBool d2dDisabled = PR_FALSE;
53984:     PRBool d2dForceEnabled = PR_FALSE;
51736:     PRBool d2dBlocked = PR_FALSE;
51736: 
51736:     nsCOMPtr<nsIGfxInfo> gfxInfo = do_GetService("@mozilla.org/gfx/info;1");
51736:     if (gfxInfo) {
51736:         PRInt32 status;
51736:         if (NS_SUCCEEDED(gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_DIRECT2D, &status))) {
55059:             if (status != nsIGfxInfo::FEATURE_NO_INFO) {
55059:                 d2dDisabled = PR_TRUE;
55059:                 if (status == nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION ||
55059:                     status == nsIGfxInfo::FEATURE_BLOCKED_DEVICE)
54964:                 {
51736:                     d2dBlocked = PR_TRUE;
51736:                 }
51736:             }
51736:         }
51736:     }
51736: 
53984:     rv = pref->GetBoolPref("gfx.direct2d.disabled", &d2dDisabled);
53984:     if (NS_FAILED(rv))
53984:         d2dDisabled = PR_FALSE;
53984:     rv = pref->GetBoolPref("gfx.direct2d.force-enabled", &d2dForceEnabled);
51656:     if (NS_FAILED(rv))
57104:         d2dForceEnabled = PR_FALSE;
51656: 
53984:     bool tryD2D = !d2dBlocked || d2dForceEnabled;
53984:     
57104:     // Do not ever try if d2d is explicitly disabled,
57104:     // or if we're not using DWrite fonts.
57104:     if (d2dDisabled || mUsingGDIFonts) {
53984:         tryD2D = false;
53984:     }
53984: 
53984:     if (isVistaOrHigher  && !safeMode && tryD2D) {
53984:         VerifyD2DDevice(d2dForceEnabled);
53984:         if (mD2DDevice) {
53984:             mRenderMode = RENDER_DIRECT2D;
53984:             mUseDirectWrite = PR_TRUE;
53984:         }
53984:     } else {
53984:         mD2DDevice = nsnull;
53984:     }
53984: #endif
53984: 
53984: #ifdef CAIRO_HAS_DWRITE_FONT
53984:     // Enable when it's preffed on -and- we're using Vista or higher. Or when
53984:     // we're going to use D2D.
53984:     if (!mDWriteFactory && (mUseDirectWrite && isVistaOrHigher)) {
53984:         DWriteCreateFactoryFunc createDWriteFactory = (DWriteCreateFactoryFunc)
53984:             GetProcAddress(LoadLibraryW(L"dwrite.dll"), "DWriteCreateFactory");
53984: 
53984:         if (createDWriteFactory) {
53984:             /**
53984:              * I need a direct pointer to be able to cast to IUnknown**, I also
53984:              * need to remember to release this because the nsRefPtr will
53984:              * AddRef it.
53984:              */
53984:             IDWriteFactory *factory;
53984:             HRESULT hr = createDWriteFactory(
53984:                 DWRITE_FACTORY_TYPE_SHARED,
53984:                 __uuidof(IDWriteFactory),
53984:                 reinterpret_cast<IUnknown**>(&factory));
53984:             mDWriteFactory = factory;
53984:             factory->Release();
53984:         }
53984:     }
53984: #endif
53984: }
53984: 
53984: void
53984: gfxWindowsPlatform::VerifyD2DDevice(PRBool aAttemptForce)
53984: {
53984: #ifdef CAIRO_HAS_D2D_SURFACE
53984:     if (mD2DDevice) {
53984:         ID3D10Device1 *device = cairo_d2d_device_get_device(mD2DDevice);
53984: 
53984:         if (SUCCEEDED(device->GetDeviceRemovedReason())) {
53984:             return;
53984:         }
53984:         mD2DDevice = nsnull;
53984:     }
53984: 
50585:     HMODULE d3d10module = LoadLibraryA("d3d10_1.dll");
50585:     D3D10CreateDevice1Func createD3DDevice = (D3D10CreateDevice1Func)
50585:         GetProcAddress(d3d10module, "D3D10CreateDevice1");
50585:     nsRefPtr<ID3D10Device1> device;
50585: 
50585:     if (createD3DDevice) {
50585:         // We try 10.0 first even though we prefer 10.1, since we want to
50585:         // fail as fast as possible if 10.x isn't supported.
50585:         HRESULT hr = createD3DDevice(
50585:             NULL, 
50585:             D3D10_DRIVER_TYPE_HARDWARE,
50585:             NULL,
50585:             D3D10_CREATE_DEVICE_BGRA_SUPPORT |
50585:             D3D10_CREATE_DEVICE_PREVENT_INTERNAL_THREADING_OPTIMIZATIONS,
50585:             D3D10_FEATURE_LEVEL_10_0,
50585:             D3D10_1_SDK_VERSION,
50585:             getter_AddRefs(device));
50585: 
50585:         if (SUCCEEDED(hr)) {
50585:             // We have 10.0, let's try 10.1.
50585:             // XXX - This adds an additional 10-20ms for people who are
50585:             // getting direct2d. We'd really like to do something more
50585:             // clever.
50585:             nsRefPtr<ID3D10Device1> device1;
50585:             hr = createD3DDevice(
50585:                 NULL, 
50585:                 D3D10_DRIVER_TYPE_HARDWARE,
50585:                 NULL,
50585:                 D3D10_CREATE_DEVICE_BGRA_SUPPORT |
50585:                 D3D10_CREATE_DEVICE_PREVENT_INTERNAL_THREADING_OPTIMIZATIONS,
50585:                 D3D10_FEATURE_LEVEL_10_1,
50585:                 D3D10_1_SDK_VERSION,
50585:                 getter_AddRefs(device1));
50585: 
50585:             if (SUCCEEDED(hr)) {
50585:                 device = device1;
50585:             }
50585: 
50585:             mD2DDevice = cairo_d2d_create_device_from_d3d10device(device);
50585:         }
50585:     }
53984: 
53984:     if (!mD2DDevice && aAttemptForce) {
53984:         mD2DDevice = cairo_d2d_create_device();
50585:     }
46438: #endif
38727: }
57104: 
36949: gfxPlatformFontList*
36949: gfxWindowsPlatform::CreatePlatformFontList()
36949: {
57104:     mUsingGDIFonts = PR_FALSE;
57104:     gfxPlatformFontList *pfl;
36949: #ifdef MOZ_FT2_FONTS
57104:     pfl = new gfxFT2FontList();
36949: #else
38727: #ifdef CAIRO_HAS_DWRITE_FONT
57104:     if (GetDWriteFactory()) {
57104:         pfl = new gfxDWriteFontList();
57104:         if (NS_SUCCEEDED(pfl->InitFontList())) {
57104:             return pfl;
57104:         }
57104:         // DWrite font initialization failed! Don't know why this would happen,
57104:         // but apparently it can - see bug 594865.
57104:         // So we're going to fall back to GDI fonts & rendering.
57104:         gfxPlatformFontList::Shutdown();
57104:         SetRenderMode(RENDER_GDI);
38727:     }
38727: #endif
57104:     pfl = new gfxGDIFontList();
57104:     mUsingGDIFonts = PR_TRUE;
36949: #endif
57104: 
57104:     if (NS_SUCCEEDED(pfl->InitFontList())) {
57104:         return pfl;
57104:     }
57104: 
57104:     gfxPlatformFontList::Shutdown();
57104:     return nsnull;
36949: }
36949: 
    1: already_AddRefed<gfxASurface>
    1: gfxWindowsPlatform::CreateOffscreenSurface(const gfxIntSize& size,
54253:                                            gfxASurface::gfxContentType contentType)
    1: {
30087:     gfxASurface *surf = nsnull;
30087: 
30087: #ifdef CAIRO_HAS_WIN32_SURFACE
30087:     if (mRenderMode == RENDER_GDI)
54253:         surf = new gfxWindowsSurface(size, gfxASurface::FormatFromContent(contentType));
30086: #endif
30087: 
38727: #ifdef CAIRO_HAS_D2D_SURFACE
38727:     if (mRenderMode == RENDER_DIRECT2D)
54253:         surf = new gfxD2DSurface(size, gfxASurface::FormatFromContent(contentType));
38727: #endif
38727: 
30087:     if (surf == nsnull)
54253:         surf = new gfxImageSurface(size, gfxASurface::FormatFromContent(contentType));
30087: 
    1:     NS_IF_ADDREF(surf);
30087: 
    1:     return surf;
    1: }
    1: 
    1: nsresult
38493: gfxWindowsPlatform::GetFontList(nsIAtom *aLangGroup,
    1:                                 const nsACString& aGenericFamily,
23904:                                 nsTArray<nsString>& aListOfFonts)
    1: {
36949:     gfxPlatformFontList::PlatformFontList()->GetFontList(aLangGroup, aGenericFamily, aListOfFonts);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: static void
    1: RemoveCharsetFromFontSubstitute(nsAString &aName)
    1: {
    1:     PRInt32 comma = aName.FindChar(PRUnichar(','));
    1:     if (comma >= 0)
    1:         aName.Truncate(comma);
    1: }
    1: 
    1: nsresult
    1: gfxWindowsPlatform::UpdateFontList()
    1: {
36949:     gfxPlatformFontList::PlatformFontList()->UpdateFontList();
12989: 
    1:     return NS_OK;
    1: }
    1: 
    1: struct ResolveData {
    1:     ResolveData(gfxPlatform::FontResolverCallback aCallback,
    1:                 gfxWindowsPlatform *aCaller, const nsAString *aFontName,
    1:                 void *aClosure) :
    1:         mFoundCount(0), mCallback(aCallback), mCaller(aCaller),
    1:         mFontName(aFontName), mClosure(aClosure) {}
    1:     PRUint32 mFoundCount;
    1:     gfxPlatform::FontResolverCallback mCallback;
    1:     gfxWindowsPlatform *mCaller;
    1:     const nsAString *mFontName;
    1:     void *mClosure;
    1: };
    1: 
    1: nsresult
    1: gfxWindowsPlatform::ResolveFontName(const nsAString& aFontName,
    1:                                     FontResolverCallback aCallback,
38727:                                     void *aClosure,
38727:                                     PRBool& aAborted)
    1: {
36949:     nsAutoString resolvedName;
36949:     if (!gfxPlatformFontList::PlatformFontList()->
36949:              ResolveFontName(aFontName, resolvedName)) {
36949:         aAborted = PR_FALSE;
36949:         return NS_OK;
36949:     }
36949:     aAborted = !(*aCallback)(resolvedName, aClosure);
    1:     return NS_OK;
    1: }
    1: 
36949: nsresult
36949: gfxWindowsPlatform::GetStandardFamilyName(const nsAString& aFontName, nsAString& aFamilyName)
36949: {
36949:     gfxPlatformFontList::PlatformFontList()->GetStandardFamilyName(aFontName, aFamilyName);
    1:     return NS_OK;
    1: }
    1: 
  270: gfxFontGroup *
  270: gfxWindowsPlatform::CreateFontGroup(const nsAString &aFamilies,
19962:                                     const gfxFontStyle *aStyle,
19962:                                     gfxUserFontSet *aUserFontSet)
  270: {
24104: #ifdef MOZ_FT2_FONTS
24104:     return new gfxFT2FontGroup(aFamilies, aStyle);
24104: #else
39447:     return new gfxFontGroup(aFamilies, aStyle, aUserFontSet);
24104: #endif
19962: }
19962: 
19962: gfxFontEntry* 
23273: gfxWindowsPlatform::LookupLocalFont(const gfxProxyFontEntry *aProxyEntry,
23273:                                     const nsAString& aFontName)
19962: {
36949:     return gfxPlatformFontList::PlatformFontList()->LookupLocalFont(aProxyEntry, 
36949:                                                                     aFontName);
19962: }
19962: 
19962: gfxFontEntry* 
22397: gfxWindowsPlatform::MakePlatformFont(const gfxProxyFontEntry *aProxyEntry,
21067:                                      const PRUint8 *aFontData, PRUint32 aLength)
19962: {
36949:     return gfxPlatformFontList::PlatformFontList()->MakePlatformFont(aProxyEntry,
36949:                                                                      aFontData,
36949:                                                                      aLength);
19962: }
19962: 
19962: PRBool
19962: gfxWindowsPlatform::IsFontFormatSupported(nsIURI *aFontURI, PRUint32 aFormatFlags)
19962: {
23576:     // check for strange format flags
23576:     NS_ASSERTION(!(aFormatFlags & gfxUserFontSet::FLAG_FORMAT_NOT_USED),
23576:                  "strange font format hint set");
23576: 
23576:     // accept supported formats
32809:     if (aFormatFlags & (gfxUserFontSet::FLAG_FORMAT_WOFF     |
32809:                         gfxUserFontSet::FLAG_FORMAT_OPENTYPE | 
23576:                         gfxUserFontSet::FLAG_FORMAT_TRUETYPE)) {
23576:         return PR_TRUE;
23576:     }
23576: 
23576:     // reject all other formats, known and unknown
23576:     if (aFormatFlags != 0) {
19962:         return PR_FALSE;
19962:     }
19962: 
23576:     // no format hint set, need to look at data
19962:     return PR_TRUE;
  270: }
 1959: 
36949: gfxFontFamily *
13280: gfxWindowsPlatform::FindFontFamily(const nsAString& aName)
 1959: {
36949:     return gfxPlatformFontList::PlatformFontList()->FindFamily(aName);
13280: }
13280: 
36949: gfxFontEntry *
13578: gfxWindowsPlatform::FindFontEntry(const nsAString& aName, const gfxFontStyle& aFontStyle)
13280: {
36949:     nsRefPtr<gfxFontFamily> ff = FindFontFamily(aName);
13280:     if (!ff)
13280:         return nsnull;
13280: 
36949:     PRBool aNeedsBold;
36949:     return ff->FindFontForStyle(aFontStyle, aNeedsBold);
 1959: }
 3787: 
27035: qcms_profile*
 3787: gfxWindowsPlatform::GetPlatformCMSOutputProfile()
 3787: {
24104: #ifndef MOZ_FT2_FONTS
37454:     WCHAR str[MAX_PATH];
37454:     DWORD size = MAX_PATH;
37454:     BOOL res;
 3787: 
 3787:     HDC dc = GetDC(nsnull);
36860:     if (!dc)
36860:         return nsnull;
36860: 
37454: #if _MSC_VER
36860:     __try {
37454:         res = GetICMProfileW(dc, &size, (LPWSTR)&str);
36860:     } __except(GetExceptionCode() == EXCEPTION_ILLEGAL_INSTRUCTION) {
37454:         res = FALSE;
36860:     }
37454: #else
37454:     res = GetICMProfileW(dc, &size, (LPWSTR)&str);
37454: #endif
36860: 
 3787:     ReleaseDC(nsnull, dc);
37454:     if (!res)
37454:         return nsnull;
 3787: 
27035:     qcms_profile* profile =
27035:         qcms_profile_from_path(NS_ConvertUTF16toUTF8(str).get());
 3787: #ifdef DEBUG_tor
 3787:     if (profile)
 3787:         fprintf(stderr,
 3787:                 "ICM profile read from %s successfully\n",
 3787:                 NS_ConvertUTF16toUTF8(str).get());
 3787: #endif
 3787:     return profile;
22248: #else
22248:     return nsnull;
22248: #endif
 3787: }
 5254: 
 5254: PRBool
36949: gfxWindowsPlatform::GetPrefFontEntries(const nsCString& aKey, nsTArray<nsRefPtr<gfxFontEntry> > *array)
 5254: {
13280:     return mPrefFonts.Get(aKey, array);
 5254: }
 5254: 
 5254: void
36949: gfxWindowsPlatform::SetPrefFontEntries(const nsCString& aKey, nsTArray<nsRefPtr<gfxFontEntry> >& array)
 5254: {
13280:     mPrefFonts.Put(aKey, array);
 5254: }
13877: 
24104: #ifdef MOZ_FT2_FONTS
24104: FT_Library
24104: gfxWindowsPlatform::GetFTLibrary()
24104: {
24104:     return gPlatformFTLibrary;
24104: }
24104: #endif
32950: 
42854: PRBool
42854: gfxWindowsPlatform::UseClearTypeForDownloadableFonts()
42854: {
42854:     if (mUseClearTypeForDownloadableFonts == UNINITIALIZED_VALUE) {
42854:         mUseClearTypeForDownloadableFonts = GetBoolPref(GFX_DOWNLOADABLE_FONTS_USE_CLEARTYPE, PR_TRUE);
42854:     }
42854: 
42854:     return mUseClearTypeForDownloadableFonts;
42854: }
42854: 
42854: PRBool
42854: gfxWindowsPlatform::UseClearTypeAlways()
42854: {
42854:     if (mUseClearTypeAlways == UNINITIALIZED_VALUE) {
42854:         mUseClearTypeAlways = GetBoolPref(GFX_USE_CLEARTYPE_ALWAYS, PR_FALSE);
42854:     }
42854: 
42854:     return mUseClearTypeAlways;
42854: }
42854: 
42854: PRInt32
42854: gfxWindowsPlatform::WindowsOSVersion()
42854: {
42854:     static PRInt32 winVersion = UNINITIALIZED_VALUE;
42854: 
42854:     OSVERSIONINFO vinfo;
42854: 
42854:     if (winVersion == UNINITIALIZED_VALUE) {
42854:         vinfo.dwOSVersionInfoSize = sizeof (vinfo);
42854:         if (!GetVersionEx(&vinfo)) {
42854:             winVersion = kWindowsUnknown;
42854:         } else {
42854:             winVersion = PRInt32(vinfo.dwMajorVersion << 16) + vinfo.dwMinorVersion;
42854:         }
42854:     }
42854:     return winVersion;
42854: }
42854: 
32950: void 
61526: gfxWindowsPlatform::GetDLLVersion(const PRUnichar *aDLLPath, nsAString& aVersion)
60493: {
60493:     DWORD versInfoSize, vers[4] = {0};
60493:     // version info not available case
60493:     aVersion.Assign(NS_LITERAL_STRING("0.0.0.0"));
60493:     versInfoSize = GetFileVersionInfoSizeW(aDLLPath, NULL);
60493:     nsAutoTArray<BYTE,512> versionInfo;
60493:     
62539:     if (versInfoSize == 0 ||
62539:         !versionInfo.AppendElements(PRUint32(versInfoSize)))
62539:     {
60493:         return;
60493:     }
60493: 
62539:     if (!GetFileVersionInfoW(aDLLPath, 0, versInfoSize, 
62539:            LPBYTE(versionInfo.Elements())))
62539:     {
62539:         return;
62539:     } 
62539: 
62539:     UINT len = 0;
62539:     VS_FIXEDFILEINFO *fileInfo = nsnull;
60493:     if (!VerQueryValue(LPBYTE(versionInfo.Elements()), TEXT("\\"),
62539:            (LPVOID *)&fileInfo, &len) ||
62539:         len == 0 ||
62539:         fileInfo == nsnull)
62539:     {
60493:         return;
60493:     }
60493: 
60493:     DWORD fileVersMS = fileInfo->dwFileVersionMS; 
60493:     DWORD fileVersLS = fileInfo->dwFileVersionLS;
60493: 
60493:     vers[0] = HIWORD(fileVersMS);
60493:     vers[1] = LOWORD(fileVersMS);
60493:     vers[2] = HIWORD(fileVersLS);
60493:     vers[3] = LOWORD(fileVersLS);
60493: 
60493:     char buf[256];
60493:     sprintf(buf, "%d.%d.%d.%d", vers[0], vers[1], vers[2], vers[3]);
60493:     aVersion.Assign(NS_ConvertUTF8toUTF16(buf));
60493: }
60493: 
60493: void
61635: gfxWindowsPlatform::GetFontCacheSize(nsAString& aSize)
61635: {
61635:     WIN32_FIND_DATAW findFileData;
61635:     HANDLE file;
61635:     WCHAR path[MAX_PATH];
61635: 
61635:     aSize.Assign(L"n/a");
61635: 
61635:     if (FAILED(SHGetFolderPathW(NULL, CSIDL_WINDOWS, NULL, 0, path))) {
61635:         return;
61635:     }
61635: 
61635:     PathAppendW(path, 
61635:         L"ServiceProfiles\\LocalService\\AppData\\Local\\FontCache-*-*.dat");
61635:     file = FindFirstFileW(path, &findFileData);
61635:     if (file == INVALID_HANDLE_VALUE) {
61635:         return;
61635:     }
61635:      
61635:     WCHAR size[256];
61635: 
61635:     double sizeMB = (double(findFileData.nFileSizeLow) +
61635:                      findFileData.nFileSizeHigh * (double(MAXDWORD) + 1))
61635:                     / 1000000.0;
62127:     swprintf_s(size, sizeof(size), L"%.2f MB", sizeMB);
61635:     aSize.Assign(size);
62127:     FindClose(file);
61635: }
61635: 
61635: void
42854: gfxWindowsPlatform::FontsPrefsChanged(nsIPrefBranch *aPrefBranch, const char *aPref)
42854: {
43347:     PRBool clearTextFontCaches = PR_TRUE;
42854: 
42854:     gfxPlatform::FontsPrefsChanged(aPrefBranch, aPref);
42854: 
42854:     if (!aPref) {
42854:         mUseClearTypeForDownloadableFonts = UNINITIALIZED_VALUE;
42854:         mUseClearTypeAlways = UNINITIALIZED_VALUE;
42854:     } else if (!strcmp(GFX_DOWNLOADABLE_FONTS_USE_CLEARTYPE, aPref)) {
42854:         mUseClearTypeForDownloadableFonts = UNINITIALIZED_VALUE;
42854:     } else if (!strcmp(GFX_USE_CLEARTYPE_ALWAYS, aPref)) {
42854:         mUseClearTypeAlways = UNINITIALIZED_VALUE;
42854:     } else {
43347:         clearTextFontCaches = PR_FALSE;
42854:     }
42854: 
43347:     if (clearTextFontCaches) {    
42854:         gfxFontCache *fc = gfxFontCache::GetCache();
43347:         if (fc) {
43347:             fc->Flush();
43347:         }
43347:         gfxTextRunWordCache::Flush();
42854:     }
50598: }
