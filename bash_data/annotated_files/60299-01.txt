43066: /* -*- Mode: c++; tab-width: 40; indent-tabs-mode: nil; c-basic-offset: 4; -*- */
43066: /* ***** BEGIN LICENSE BLOCK *****
43066:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43066:  *
43066:  * The contents of this file are subject to the Mozilla Public License Version
43066:  * 1.1 (the "License"); you may not use this file except in compliance with
43066:  * the License. You may obtain a copy of the License at
43066:  * http://www.mozilla.org/MPL/
43066:  *
43066:  * Software distributed under the License is distributed on an "AS IS" basis,
43066:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43066:  * for the specific language governing rights and limitations under the
43066:  * License.
43066:  *
43066:  * The Original Code is mozilla.org code.
43066:  *
43066:  * The Initial Developer of the Original Code is
43066:  *   Mozilla Foundation
43066:  * Portions created by the Initial Developer are Copyright (C) 2009-2010
43066:  * the Initial Developer. All Rights Reserved.
43066:  *
43066:  * Contributor(s):
43066:  *   Vladimir Vukicevic <vladimir@pobox.com>
43066:  *
43066:  * Alternatively, the contents of this file may be used under the terms of
43066:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43066:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43066:  * in which case the provisions of the GPL or the LGPL are applicable instead
43066:  * of those above. If you wish to allow use of your version of this file only
43066:  * under the terms of either the GPL or the LGPL, and not to allow others to
43066:  * use your version of this file under the terms of the MPL, indicate your
43066:  * decision by deleting the provisions above and replace them with the notice
43066:  * and other provisions required by the GPL or the LGPL. If you do not delete
43066:  * the provisions above, a recipient may use your version of this file under
43066:  * the terms of any one of the MPL, the GPL or the LGPL.
43066:  *
43066:  * ***** END LICENSE BLOCK ***** */
43066: 
43066: #include "nsAppShell.h"
43066: #include "nsWindow.h"
43066: #include "nsThreadUtils.h"
43811: #include "nsICommandLineRunner.h"
43066: #include "nsIObserverService.h"
43066: #include "nsIAppStartup.h"
43107: #include "nsIGeolocationProvider.h"
44157: #include "nsIPrefService.h"
43066: 
43741: #include "mozilla/Services.h"
43066: #include "prenv.h"
43066: 
43066: #include "AndroidBridge.h"
46218: #include "nsAccelerometerSystem.h"
43066: #include <android/log.h>
43066: #include <pthread.h>
43066: 
43066: #ifdef MOZ_LOGGING
43066: #define FORCE_PR_LOG
43066: #include "prlog.h"
43066: #endif
43066: 
43066: #ifdef ANDROID_DEBUG_EVENTS
43066: #define EVLOG(args...)  ALOG(args)
43066: #else
43066: #define EVLOG(args...) do { } while (0)
43066: #endif
43066: 
43066: using namespace mozilla;
43066: 
43066: #ifdef PR_LOGGING
43066: PRLogModuleInfo *gWidgetLog = nsnull;
43066: #endif
43066: 
46218: nsAccelerometerSystem *gAccel = nsnull;
43107: nsIGeolocationUpdate *gLocationCallback = nsnull;
43066: 
43066: nsAppShell *nsAppShell::gAppShell = nsnull;
43066: 
60299: NS_IMPL_ISUPPORTS_INHERITED1(nsAppShell, nsBaseAppShell, nsIObserver)
60299: 
43066: nsAppShell::nsAppShell()
43066:     : mQueueLock(nsnull),
43066:       mCondLock(nsnull),
43066:       mQueueCond(nsnull),
43066:       mNumDraws(0)
43066: {
43066:     gAppShell = this;
43066: }
43066: 
43066: nsAppShell::~nsAppShell()
43066: {
43066:     gAppShell = nsnull;
43066: }
43066: 
43066: void
43066: nsAppShell::NotifyNativeEvent()
43066: {
43066:     PR_Lock(mCondLock);
43066:     PR_NotifyCondVar(mQueueCond);
43066:     PR_Unlock(mCondLock);
43066: }
43066: 
43066: nsresult
43066: nsAppShell::Init()
43066: {
43066: #ifdef PR_LOGGING
43066:     if (!gWidgetLog)
43066:         gWidgetLog = PR_NewLogModule("Widget");
43066: #endif
43066: 
43066:     mQueueLock = PR_NewLock();
43066:     mCondLock = PR_NewLock();
43066:     mQueueCond = PR_NewCondVar(mCondLock);
43066: 
51723:     mObserversHash.Init();
51723: 
56483:     nsresult rv = nsBaseAppShell::Init();
56483:     if (AndroidBridge::Bridge())
56483:         AndroidBridge::Bridge()->NotifyAppShellReady();
60299: 
60299:     nsCOMPtr<nsIObserverService> obsServ =
60299:             mozilla::services::GetObserverService();
60299:     if (obsServ) {
60299:         obsServ->AddObserver(this, "xpcom-shutdown", PR_FALSE);
60299:     }
56483:     return rv;
43066: }
43066: 
60299: NS_IMETHODIMP
60299: nsAppShell::Observe(nsISupports* aSubject,
60299:                     const char* aTopic,
60299:                     const PRUnichar* aData)
60299: {
60299:     if (!strcmp(aTopic, "xpcom-shutdown")) {
60299:         // We need to ensure no observers stick around after XPCOM shuts down
60299:         // or we'll see crashes, as the app shell outlives XPConnect.
60299:         mObserversHash.Clear();
60299:     }
60299:     return nsBaseAppShell::Observe(aSubject, aTopic, aData);
60299: }
43066: 
43066: void
43066: nsAppShell::ScheduleNativeEventCallback()
43066: {
43066:     EVLOG("nsAppShell::ScheduleNativeEventCallback pth: %p thread: %p main: %d", (void*) pthread_self(), (void*) NS_GetCurrentThread(), NS_IsMainThread());
43066: 
43066:     // this is valid to be called from any thread, so do so.
43066:     PostEvent(new AndroidGeckoEvent(AndroidGeckoEvent::NATIVE_POKE));
43066: }
43066: 
43066: PRBool
43066: nsAppShell::ProcessNextNativeEvent(PRBool mayWait)
43066: {
43066:     EVLOG("nsAppShell::ProcessNextNativeEvent %d", mayWait);
43066: 
43066:     PR_Lock(mCondLock);
43066: 
43066:     nsAutoPtr<AndroidGeckoEvent> curEvent;
43066:     AndroidGeckoEvent *nextEvent;
43066: 
43066:     curEvent = GetNextEvent();
43066:     if (!curEvent && mayWait) {
43066:         // hmm, should we really hardcode this 10s?
43066: #if defined(ANDROID_DEBUG_EVENTS)
43066:         PRTime t0, t1;
43066:         EVLOG("nsAppShell: waiting on mQueueCond");
43066:         t0 = PR_Now();
43066: 
43066:         PR_WaitCondVar(mQueueCond, PR_MillisecondsToInterval(10000));
43066:         t1 = PR_Now();
43066:         EVLOG("nsAppShell: wait done, waited %d ms", (int)(t1-t0)/1000);
43066: #else
43066:         PR_WaitCondVar(mQueueCond, PR_INTERVAL_NO_TIMEOUT);
43066: #endif
43066: 
43066:         curEvent = GetNextEvent();
43066:     }
43066: 
43066:     PR_Unlock(mCondLock);
43066: 
43066:     if (!curEvent)
43066:         return false;
43066: 
43066:     // Combine subsequent events of the same type
43066: 
43066:     nextEvent = PeekNextEvent();
43066: 
43066:     while (nextEvent) {
43066:         int curType = curEvent->Type();
43066:         int nextType = nextEvent->Type();
43066: 
43066:         while (nextType == AndroidGeckoEvent::DRAW &&
43066:                mNumDraws > 1)
43066:         {
43066:             // skip this draw, since there's a later one already in the queue.. this will let us
43066:             // deal with sequences that look like:
43066:             //   MOVE DRAW MOVE DRAW MOVE DRAW
43066:             // and end up with just
43066:             //   MOVE DRAW
43066:             // when we process all the events.
43066:             RemoveNextEvent();
47828:             delete nextEvent;
43066: 
43066: #if defined(ANDROID_DEBUG_EVENTS)
43066:             ALOG("# Removing DRAW event (%d outstanding)", mNumDraws);
43066: #endif
43066: 
43066:             nextEvent = PeekNextEvent();
43066:             nextType = nextEvent->Type();
43066:         }
43066: 
43066:         // If the next type of event isn't the same as the current type,
43066:         // we don't coalesce.
43066:         if (nextType != curType)
43066:             break;
43066: 
43066:         // Can only coalesce motion move events, for motion events
43066:         if (curType != AndroidGeckoEvent::MOTION_EVENT)
43066:             break;
43066: 
43066:         if (!(curEvent->Action() == AndroidMotionEvent::ACTION_MOVE &&
43066:               nextEvent->Action() == AndroidMotionEvent::ACTION_MOVE))
43066:             break;
43066: 
43066: #if defined(ANDROID_DEBUG_EVENTS)
43066:         ALOG("# Removing % 2d event", curType);
43066: #endif
43066: 
43066:         RemoveNextEvent();
43066:         curEvent = nextEvent;
43066:         nextEvent = PeekNextEvent();
43066:     }
43066: 
43066:     EVLOG("nsAppShell: event %p %d [ndraws %d]", (void*)curEvent.get(), curEvent->Type(), mNumDraws);
43066: 
43066:     nsWindow *target = (nsWindow*) curEvent->NativeWindow();
43066: 
43066:     switch (curEvent->Type()) {
43066:     case AndroidGeckoEvent::NATIVE_POKE:
43066:         NativeEventCallback();
43066:         break;
43066: 
43066:     case AndroidGeckoEvent::SENSOR_EVENT:
43066:         gAccel->AccelerationChanged(-curEvent->X(), curEvent->Y(), curEvent->Z());
43066:         break;
43066: 
43107:     case AndroidGeckoEvent::LOCATION_EVENT:
43107:         if (!gLocationCallback)
43107:             break;
43107: 
43107:         if (curEvent->GeoPosition())
43107:             gLocationCallback->Update(curEvent->GeoPosition());
43107:         else
43107:             NS_WARNING("Received location event without geoposition!");
43107:         break;
43107: 
43066:     case AndroidGeckoEvent::ACTIVITY_STOPPING: {
59123:         nsCOMPtr<nsIObserverService> obsServ =
59123:           mozilla::services::GetObserverService();
59123:         NS_NAMED_LITERAL_STRING(minimize, "heap-minimize");
59123:         obsServ->NotifyObservers(nsnull, "memory-pressure", minimize.get());
59123: 
59122:         break;
59122:     }
59122: 
59122:     case AndroidGeckoEvent::ACTIVITY_SHUTDOWN: {
43741:         nsCOMPtr<nsIObserverService> obsServ =
43741:           mozilla::services::GetObserverService();
43741:         NS_NAMED_LITERAL_STRING(context, "shutdown-persist");
43741:         obsServ->NotifyObservers(nsnull, "quit-application-granted", nsnull);
43741:         obsServ->NotifyObservers(nsnull, "quit-application-forced", nsnull);
43741:         obsServ->NotifyObservers(nsnull, "profile-change-net-teardown", context.get());
43741:         obsServ->NotifyObservers(nsnull, "profile-change-teardown", context.get());
43741:         obsServ->NotifyObservers(nsnull, "profile-before-change", context.get());
43066:         nsCOMPtr<nsIAppStartup> appSvc = do_GetService("@mozilla.org/toolkit/app-startup;1");
43066:         if (appSvc)
43066:             appSvc->Quit(nsIAppStartup::eForceQuit);
43066:         break;
43066:     }
43066: 
43741:     case AndroidGeckoEvent::ACTIVITY_PAUSING: {
44157:         // We really want to send a notification like profile-before-change,
44157:         // but profile-before-change ends up shutting some things down instead
44157:         // of flushing data
44157:         nsCOMPtr<nsIPrefService> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
44157:         if (prefs)
44157:             prefs->SavePrefFile(nsnull);
44134: 
43741:         break;
43741:     }
43741: 
43811:     case AndroidGeckoEvent::LOAD_URI: {
43811:         nsCOMPtr<nsICommandLineRunner> cmdline
43811:             (do_CreateInstance("@mozilla.org/toolkit/command-line;1"));
43811:         if (!cmdline)
43811:             break;
43811: 
43811:         char *uri = ToNewUTF8String(curEvent->Characters());
43811:         if (!uri)
43811:             break;
43811: 
43811:         char* argv[3] = {
43811:             "dummyappname",
43811:             "-remote",
43811:             uri
43811:         };
43811:         nsresult rv = cmdline->Init(3, argv, nsnull, nsICommandLine::STATE_REMOTE_AUTO);
43811:         if (NS_SUCCEEDED(rv))
43811:             cmdline->Run();
43811:         nsMemory::Free(uri);
43811:         break;
43811:     }
43811: 
43066:     default:
43066:         if (target)
43066:             target->OnAndroidEvent(curEvent);
43066:         else
43066:             nsWindow::OnGlobalAndroidEvent(curEvent);
43066:     }
43066: 
43066:     EVLOG("nsAppShell: -- done event %p %d", (void*)curEvent.get(), curEvent->Type());
43066: 
43066:     return true;
43066: }
43066: 
43066: AndroidGeckoEvent*
43066: nsAppShell::GetNextEvent()
43066: {
43066:     AndroidGeckoEvent *ae = nsnull;
43066:     PR_Lock(mQueueLock);
43066:     if (mEventQueue.Length()) {
43066:         ae = mEventQueue[0];
43066:         mEventQueue.RemoveElementAt(0);
43066:         if (ae->Type() == AndroidGeckoEvent::DRAW) {
43066:             mNumDraws--;
43066:         }
43066:     }
43066:     PR_Unlock(mQueueLock);
43066: 
43066:     return ae;
43066: }
43066: 
43066: AndroidGeckoEvent*
43066: nsAppShell::PeekNextEvent()
43066: {
43066:     AndroidGeckoEvent *ae = nsnull;
43066:     PR_Lock(mQueueLock);
43066:     if (mEventQueue.Length()) {
43066:         ae = mEventQueue[0];
43066:     }
43066:     PR_Unlock(mQueueLock);
43066: 
43066:     return ae;
43066: }
43066: 
43066: void
43066: nsAppShell::PostEvent(AndroidGeckoEvent *ae)
43066: {
43066:     PR_Lock(mQueueLock);
43066:     mEventQueue.AppendElement(ae);
43066:     if (ae->Type() == AndroidGeckoEvent::DRAW) {
43066:         mNumDraws++;
43066:     }
43066:     PR_Unlock(mQueueLock);
43066:     NotifyNativeEvent();
43066: }
43066: 
43066: void
43066: nsAppShell::RemoveNextEvent()
43066: {
43066:     AndroidGeckoEvent *ae = nsnull;
43066:     PR_Lock(mQueueLock);
43066:     if (mEventQueue.Length()) {
43066:         ae = mEventQueue[0];
43066:         mEventQueue.RemoveElementAt(0);
43066:         if (ae->Type() == AndroidGeckoEvent::DRAW) {
43066:             mNumDraws--;
43066:         }
43066:     }
43066:     PR_Unlock(mQueueLock);
43066: }
43066: 
44134: void
44134: nsAppShell::OnResume()
44134: {
44134: }
44134: 
51723: nsresult
51723: nsAppShell::AddObserver(const nsAString &aObserverKey, nsIObserver *aObserver)
51723: {
51723:     NS_ASSERTION(aObserver != nsnull, "nsAppShell::AddObserver: aObserver is null!");
51723:     return mObserversHash.Put(aObserverKey, aObserver) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
51723: }
51723: 
51723: /**
51723:  * The XPCOM event that will call the observer on the main thread.
51723:  */
51723: class ObserverCaller : public nsRunnable {
51723: public:
51723:     ObserverCaller(nsIObserver *aObserver, const char *aTopic, const PRUnichar *aData) :
51723:         mObserver(aObserver), mTopic(aTopic), mData(aData) {
51723:         NS_ASSERTION(aObserver != nsnull, "ObserverCaller: aObserver is null!");
51723:     }
51723: 
51723:     NS_IMETHOD Run() {
51723:         ALOG("ObserverCaller::Run: observer = %p, topic = '%s')",
51723:              (nsIObserver*)mObserver, mTopic.get());
51723:         mObserver->Observe(nsnull, mTopic.get(), mData.get());
51723:         return NS_OK;
51723:     }
51723: 
51723: private:
51723:     nsCOMPtr<nsIObserver> mObserver;
51723:     nsCString mTopic;
51723:     nsString mData;
51723: };
51723: 
51723: void
51723: nsAppShell::CallObserver(const nsAString &aObserverKey, const nsAString &aTopic, const nsAString &aData)
51723: {
51723:     nsCOMPtr<nsIObserver> observer;
51723:     mObserversHash.Get(aObserverKey, getter_AddRefs(observer));
51723: 
51723:     if (!observer) {
51723:         ALOG("nsAppShell::CallObserver: Observer was not found!");
51723:         return;
51723:     }
51723: 
51723:     const NS_ConvertUTF16toUTF8 sTopic(aTopic);
51723:     const nsPromiseFlatString& sData = PromiseFlatString(aData);
51723:     
51723:     if (NS_IsMainThread()) {
51723:         // This branch will unlikely be hit, have it just in case
51723:         observer->Observe(nsnull, sTopic.get(), sData.get());
51723:     } else {
51723:         // Java is not running on main thread, so we have to use NS_DispatchToMainThread
51723:         nsCOMPtr<nsIRunnable> observerCaller = new ObserverCaller(observer, sTopic.get(), sData.get());
51723:         nsresult rv = NS_DispatchToMainThread(observerCaller);
51723:         ALOG("NS_DispatchToMainThread result: %d", rv);
51723:     }
51723: }
51723: 
51723: void
51723: nsAppShell::RemoveObserver(const nsAString &aObserverKey)
51723: {
51723:     mObserversHash.Remove(aObserverKey);
51723: }
51723: 
60059: // NotifyObservers support.  NotifyObservers only works on main thread.
60059: 
60059: class NotifyObserversCaller : public nsRunnable {
60059: public:
60059:     NotifyObserversCaller(nsISupports *aSupports,
60059:                           const char *aTopic, const PRUnichar *aData) :
60059:          mSupports(aSupports), mTopic(aTopic), mData(aData) {
60059:     }
60059: 
60059:     NS_IMETHOD Run() {
60059:         nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
60059:         if (os)
60059:             os->NotifyObservers(mSupports, mTopic.get(), mData.get());
60059: 
60059:         return NS_OK;
60059:     }
60059: 
60059: private:
60059:     nsCOMPtr<nsISupports> mSupports;
60059:     nsCString mTopic;
60059:     nsString mData;
60059: };
60059: 
60059: void
60059: nsAppShell::NotifyObservers(nsISupports *aSupports,
60059:                             const char *aTopic,
60059:                             const PRUnichar *aData)
60059: {
60059:     // This isn't main thread, so post this to main thread
60059:     nsCOMPtr<nsIRunnable> caller =
60059:         new NotifyObserversCaller(aSupports, aTopic, aData);
60059:     NS_DispatchToMainThread(caller);
60059: }
60059: 
43066: // Used by IPC code
43066: namespace mozilla {
43066: 
43066: bool ProcessNextEvent()
43066: {
43066:     return nsAppShell::gAppShell->ProcessNextNativeEvent(PR_TRUE) ? true : false;
43066: }
43066: 
43066: void NotifyEvent()
43066: {
43066:     nsAppShell::gAppShell->NotifyNativeEvent();
43066: }
43066: 
43066: }
