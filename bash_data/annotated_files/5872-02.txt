   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: /*
   1:  * construction of a frame tree that is nearly isomorphic to the content
   1:  * tree and updating of that tree in response to dynamic changes
   1:  */
   1: 
   1: #ifndef nsCSSFrameConstructor_h___
   1: #define nsCSSFrameConstructor_h___
   1: 
   1: #include "nsCOMPtr.h"
   1: #include "nsILayoutHistoryState.h"
   1: #include "nsIXBLService.h"
   1: #include "nsQuoteList.h"
   1: #include "nsCounterManager.h"
   1: #include "nsDataHashtable.h"
   1: #include "nsHashKeys.h"
   1: #include "nsThreadUtils.h"
4347: #include "nsPageContentFrame.h"
   1: 
   1: class nsIDocument;
   1: struct nsFrameItems;
   1: struct nsAbsoluteItems;
   1: class nsStyleContext;
   1: struct nsStyleContent;
   1: struct nsStyleDisplay;
   1: class nsIPresShell;
   1: class nsVoidArray;
   1: class nsFrameManager;
   1: class nsIDOMHTMLSelectElement;
   1: class nsPresContext;
   1: class nsStyleChangeList;
   1: class nsIFrame;
   1: 
   1: struct nsFindFrameHint
   1: {
   1:   nsIFrame *mPrimaryFrameForPrevSibling;  // weak ref to the primary frame for the content for which we need a frame
   1:   nsFindFrameHint() : mPrimaryFrameForPrevSibling(nsnull) { }
   1: };
   1: 
3129: typedef void (PR_CALLBACK nsLazyFrameConstructionCallback)
3129:              (nsIContent* aContent, nsIFrame* aFrame, void* aArg);
3129: 
   1: class nsFrameConstructorState;
   1: class nsFrameConstructorSaveState;
   1:   
   1: class nsCSSFrameConstructor
   1: {
   1: public:
   1:   nsCSSFrameConstructor(nsIDocument *aDocument, nsIPresShell* aPresShell);
   1:   ~nsCSSFrameConstructor(void) { }
   1: 
   1:   // Maintain global objects - gXBLService
   1:   static nsIXBLService * GetXBLService();
   1:   static void ReleaseGlobals() { NS_IF_RELEASE(gXBLService); }
   1: 
   1:   // get the alternate text for a content node
   1:   static void GetAlternateTextFor(nsIContent*    aContent,
   1:                                   nsIAtom*       aTag,  // content object's tag
   1:                                   nsXPIDLString& aAltText);
   1: private: 
   1:   // These are not supported and are not implemented! 
   1:   nsCSSFrameConstructor(const nsCSSFrameConstructor& aCopy); 
   1:   nsCSSFrameConstructor& operator=(const nsCSSFrameConstructor& aCopy); 
   1: 
   1: public:
   1:   // XXXbz this method needs to actually return errors!
   1:   nsresult ConstructRootFrame(nsIContent*     aDocElement,
   1:                               nsIFrame**      aNewFrame);
   1: 
   1:   nsresult ReconstructDocElementHierarchy();
   1: 
   1:   nsresult ContentAppended(nsIContent*     aContainer,
   1:                            PRInt32         aNewIndexInContainer);
   1: 
   1:   nsresult ContentInserted(nsIContent*            aContainer,
   1:                            nsIContent*            aChild,
   1:                            PRInt32                aIndexInContainer,
4696:                            nsILayoutHistoryState* aFrameState);
   1: 
   1:   nsresult ContentRemoved(nsIContent*     aContainer,
   1:                           nsIContent*     aChild,
   1:                           PRInt32         aIndexInContainer,
   1:                           PRBool          aInReinsertContent);
   1: 
   1:   nsresult CharacterDataChanged(nsIContent*     aContent,
   1:                                 PRBool          aAppend);
   1: 
   1:   nsresult ContentStatesChanged(nsIContent*     aContent1,
   1:                                 nsIContent*     aContent2,
   1:                                 PRInt32         aStateMask);
   1: 
3129:   // Process the children of aContent and indicate that frames should be
3129:   // created for them. This is used for lazily built content such as that
3129:   // inside popups so that it is only created when the popup is opened.
3129:   // This method constructs the frames asynchronously.
3129:   // aCallback will be called with three arguments, the first is the value
3129:   // of aContent, the second is aContent's primary frame, and the third is
3129:   // the value of aArg.
3129:   nsresult AddLazyChildren(nsIContent* aContent,
3129:                            nsLazyFrameConstructionCallback* aCallback,
3129:                            void* aArg);
3129: 
   1:   // Should be called when a frame is going to be destroyed and
   1:   // WillDestroyFrameTree hasn't been called yet.
   1:   void NotifyDestroyingFrame(nsIFrame* aFrame);
   1: 
   1:   nsresult AttributeChanged(nsIContent* aContent,
   1:                             PRInt32     aNameSpaceID,
   1:                             nsIAtom*    aAttribute,
3410:                             PRInt32     aModType,
3410:                             PRUint32    aStateMask);
   1: 
   1:   void BeginUpdate() { ++mUpdateCount; }
   1:   void EndUpdate();
 550:   void RecalcQuotesAndCounters();
   1: 
   1:   void WillDestroyFrameTree();
   1: 
   1:   // Note: It's the caller's responsibility to make sure to wrap a
   1:   // ProcessRestyledFrames call in a view update batch.
   1:   // This function does not call ProcessAttachedQueue() on the binding manager.
   1:   // If the caller wants that to happen synchronously, it needs to handle that
   1:   // itself.
   1:   nsresult ProcessRestyledFrames(nsStyleChangeList& aRestyleArray);
   1: 
   1: private:
   1:   // Note: It's the caller's responsibility to make sure to wrap a
   1:   // ProcessOneRestyle call in a view update batch.
   1:   // This function does not call ProcessAttachedQueue() on the binding manager.
   1:   // If the caller wants that to happen synchronously, it needs to handle that
   1:   // itself.
   1:   void ProcessOneRestyle(nsIContent* aContent, nsReStyleHint aRestyleHint,
   1:                          nsChangeHint aChangeHint);
   1: 
   1: public:
   1:   // Note: It's the caller's responsibility to make sure to wrap a
   1:   // ProcessPendingRestyles call in a view update batch.
5872:   // This function does not call ProcessAttachedQueue() on the binding manager.
5872:   // If the caller wants that to happen synchronously, it needs to handle that
5872:   // itself.
   1:   void ProcessPendingRestyles();
   1: 
   1:   void PostRestyleEvent(nsIContent* aContent, nsReStyleHint aRestyleHint,
   1:                         nsChangeHint aMinChangeHint);
   1: 
   1:   // Request to create a continuing frame
   1:   nsresult CreateContinuingFrame(nsPresContext* aPresContext,
   1:                                  nsIFrame*       aFrame,
   1:                                  nsIFrame*       aParentFrame,
   1:                                  nsIFrame**      aContinuingFrame,
   1:                                  PRBool          aIsFluid = PR_TRUE);
   1: 
4347:   // Copy over fixed frames from aParentFrame's prev-in-flow
4347:   nsresult ReplicateFixedFrames(nsPageContentFrame* aParentFrame);
4347: 
   1:   // Request to find the primary frame associated with a given content object.
   1:   // This is typically called by the pres shell when there is no mapping in
   1:   // the pres shell hash table
   1:   nsresult FindPrimaryFrameFor(nsFrameManager*  aFrameManager,
   1:                                nsIContent*      aContent,
   1:                                nsIFrame**       aFrame,
   1:                                nsFindFrameHint* aHint);
   1: 
   1:   // Get the XBL insertion point for a child
   1:   nsresult GetInsertionPoint(nsIFrame*     aParentFrame,
   1:                              nsIContent*   aChildContent,
   1:                              nsIFrame**    aInsertionPoint,
   1:                              PRBool*       aMultiple = nsnull);
   1: 
   1:   nsresult CreateListBoxContent(nsPresContext* aPresContext,
   1:                                 nsIFrame*       aParentFrame,
   1:                                 nsIFrame*       aPrevFrame,
   1:                                 nsIContent*     aChild,
   1:                                 nsIFrame**      aResult,
   1:                                 PRBool          aIsAppend,
   1:                                 PRBool          aIsScrollbar,
   1:                                 nsILayoutHistoryState* aFrameState);
   1: 
   1:   nsresult RemoveMappingsForFrameSubtree(nsIFrame* aRemovedFrame);
   1: 
   1:   nsIFrame* GetInitialContainingBlock() { return mInitialContainingBlock; }
   1:   nsIFrame* GetPageSequenceFrame() { return mPageSequenceFrame; }
   1: 
   1: private:
   1: 
   1:   nsresult ReconstructDocElementHierarchyInternal();
   1: 
   1:   nsresult ReinsertContent(nsIContent*    aContainer,
   1:                            nsIContent*    aChild);
   1: 
   1:   nsresult ConstructPageFrame(nsIPresShell*  aPresShell, 
   1:                               nsPresContext* aPresContext,
   1:                               nsIFrame*      aParentFrame,
   1:                               nsIFrame*      aPrevPageFrame,
   1:                               nsIFrame*&     aPageFrame,
   1:                               nsIFrame*&     aPageContentFrame);
   1: 
   1:   void DoContentStateChanged(nsIContent*     aContent,
   1:                              PRInt32         aStateMask);
   1: 
   1:   /* aMinHint is the minimal change that should be made to the element */
   1:   void RestyleElement(nsIContent*     aContent,
   1:                       nsIFrame*       aPrimaryFrame,
   1:                       nsChangeHint    aMinHint);
   1: 
   1:   void RestyleLaterSiblings(nsIContent*     aContent);
   1: 
   1:   nsresult InitAndRestoreFrame (const nsFrameConstructorState& aState,
   1:                                 nsIContent*                    aContent,
   1:                                 nsIFrame*                      aParentFrame,
   1:                                 nsIFrame*                      aPrevInFlow,
   1:                                 nsIFrame*                      aNewFrame,
   1:                                 PRBool                         aAllowCounters = PR_TRUE);
   1: 
   1:   already_AddRefed<nsStyleContext>
   1:   ResolveStyleContext(nsIFrame*         aParentFrame,
   1:                       nsIContent*       aContent);
   1: 
   1:   nsresult ConstructFrame(nsFrameConstructorState& aState,
   1:                           nsIContent*              aContent,
   1:                           nsIFrame*                aParentFrame,
   1:                           nsFrameItems&            aFrameItems);
   1: 
   1:   nsresult ConstructDocElementFrame(nsFrameConstructorState& aState,
   1:                                     nsIContent*              aDocElement,
   1:                                     nsIFrame*                aParentFrame,
   1:                                     nsIFrame**               aNewFrame);
   1: 
   1:   nsresult ConstructDocElementTableFrame(nsIContent*            aDocElement,
   1:                                          nsIFrame*              aParentFrame,
   1:                                          nsIFrame**             aNewTableFrame,
   1:                                          nsFrameConstructorState& aState);
   1: 
   1:   /**
   1:    * CreateAttributeContent creates a single content/frame combination for an
   1:    * |attr(foo)| generated content.
   1:    *
   1:    * @param aParentContent the parent content for the generated content
   1:    * @param aParentFrame the parent frame for the generated frame
   1:    * @param aAttrNamespace the namespace of the attribute in question
   1:    * @param aAttrName the localname of the attribute
   1:    * @param aStyleContext the style context to use
3793:    * @param aGeneratedContent the array of generated content to append the
3793:    *                          created content to.
   1:    * @param [out] aNewContent the content node we create
   1:    * @param [out] aNewFrame the new frame we create
   1:    */
   1:   nsresult CreateAttributeContent(nsIContent* aParentContent,
   1:                                   nsIFrame* aParentFrame,
   1:                                   PRInt32 aAttrNamespace,
   1:                                   nsIAtom* aAttrName,
   1:                                   nsStyleContext* aStyleContext,
3793:                                   nsCOMArray<nsIContent>& aGeneratedContent,
   1:                                   nsIContent** aNewContent,
   1:                                   nsIFrame** aNewFrame);
   1:   
   1:   nsresult CreateGeneratedFrameFor(nsIFrame*             aParentFrame,
   1:                                    nsIContent*           aContent,
   1:                                    nsStyleContext*       aStyleContext,
   1:                                    const nsStyleContent* aStyleContent,
   1:                                    PRUint32              aContentIndex,
3793:                                    nsCOMArray<nsIContent>& aGeneratedContent,
   1:                                    nsIFrame**            aFrame);
   1: 
   1:   PRBool CreateGeneratedContentFrame(nsFrameConstructorState& aState,
   1:                                      nsIFrame*                aFrame,
   1:                                      nsIContent*              aContent,
   1:                                      nsStyleContext*          aStyleContext,
   1:                                      nsIAtom*                 aPseudoElement,
   1:                                      nsIFrame**               aResult);
   1: 
4696:   // This method can change aFrameList: it can chop off the end and
4696:   // put it in a special sibling of aParentFrame.  It can also change
4696:   // aState by moving some floats out of it.
4696:   nsresult AppendFrames(nsFrameConstructorState&       aState,
   1:                         nsIContent*                    aContainer,
   1:                         nsIFrame*                      aParentFrame,
4696:                         nsFrameItems&                  aFrameList,
   1:                         nsIFrame*                      aAfterFrame);
   1: 
   1:   // BEGIN TABLE SECTION
   1:   /**
   1:    * ConstructTableFrame will construct the outer and inner table frames and
   1:    * return them.  Unless aIsPseudo is PR_TRUE, it will put the inner frame in
   1:    * the child list of the outer frame, and will put any pseudo frames it had
   1:    * to create into aChildItems.  The newly-created outer frame will either be
   1:    * in aChildItems or a descendant of a pseudo in aChildItems (unless it's
   1:    * positioned or floated, in which case its placeholder will be in
   1:    * aChildItems).  If aAllowOutOfFlow is false, the table frame will be forced
   1:    * to be in-flow no matter what its float or position values are.
   1:    */ 
   1:   nsresult ConstructTableFrame(nsFrameConstructorState& aState,
   1:                                nsIContent*              aContent,
   1:                                nsIFrame*                aContentParent,
   1:                                nsStyleContext*          aStyleContext,
   1:                                PRInt32                  aNameSpaceID,
   1:                                PRBool                   aIsPseudo,
   1:                                nsFrameItems&            aChildItems,
   1:                                PRBool                   aAllowOutOfFlow,
   1:                                nsIFrame*&               aNewOuterFrame,
   1:                                nsIFrame*&               aNewInnerFrame);
   1: 
   1:   nsresult ConstructTableCaptionFrame(nsFrameConstructorState& aState,
   1:                                       nsIContent*              aContent,
   1:                                       nsIFrame*                aParent,
   1:                                       nsStyleContext*          aStyleContext,
   1:                                       PRInt32                  aNameSpaceID,
   1:                                       nsFrameItems&            aChildItems,
   1:                                       nsIFrame*&               aNewFrame,
   1:                                       PRBool&                  aIsPseudoParent);
   1: 
   1:   nsresult ConstructTableRowGroupFrame(nsFrameConstructorState& aState,
   1:                                        nsIContent*              aContent,
   1:                                        nsIFrame*                aParent,
   1:                                        nsStyleContext*          aStyleContext,
   1:                                        PRInt32                  aNameSpaceID,
   1:                                        PRBool                   aIsPseudo,
   1:                                        nsFrameItems&            aChildItems,
   1:                                        nsIFrame*&               aNewFrame,
   1:                                        PRBool&                  aIsPseudoParent);
   1: 
   1:   nsresult ConstructTableColGroupFrame(nsFrameConstructorState& aState,
   1:                                        nsIContent*              aContent,
   1:                                        nsIFrame*                aParent,
   1:                                        nsStyleContext*          aStyleContext,
   1:                                        PRInt32                  aNameSpaceID,
   1:                                        PRBool                   aIsPseudo,
   1:                                        nsFrameItems&            aChildItems,
   1:                                        nsIFrame*&               aNewFrame,
   1:                                        PRBool&                  aIsPseudoParent);
   1: 
   1:   nsresult ConstructTableRowFrame(nsFrameConstructorState& aState,
   1:                                   nsIContent*              aContent,
   1:                                   nsIFrame*                aParent,
   1:                                   nsStyleContext*          aStyleContext,
   1:                                   PRInt32                  aNameSpaceID,
   1:                                   PRBool                   aIsPseudo,
   1:                                   nsFrameItems&            aChildItems,
   1:                                   nsIFrame*&               aNewFrame,
   1:                                   PRBool&                  aIsPseudoParent);
   1: 
   1:   nsresult ConstructTableColFrame(nsFrameConstructorState& aState,
   1:                                   nsIContent*              aContent,
   1:                                   nsIFrame*                aParent,
   1:                                   nsStyleContext*          aStyleContext,
   1:                                   PRInt32                  aNameSpaceID,
   1:                                   PRBool                   aIsPseudo,
   1:                                   nsFrameItems&            aChildItems,
   1:                                   nsIFrame*&               aNewFrame,
   1:                                   PRBool&                  aIsPseudoParent);
   1: 
   1:   nsresult ConstructTableCellFrame(nsFrameConstructorState& aState,
   1:                                    nsIContent*              aContent,
   1:                                    nsIFrame*                aParentFrame,
   1:                                    nsStyleContext*          aStyleContext,
   1:                                    PRInt32                  aNameSpaceID,
   1:                                    PRBool                   aIsPseudo,
   1:                                    nsFrameItems&            aChildItems,
   1:                                    nsIFrame*&               aNewCellOuterFrame,
   1:                                    nsIFrame*&               aNewCellInnerFrame,
   1:                                    PRBool&                  aIsPseudoParent);
   1: 
   1:   nsresult CreatePseudoTableFrame(PRInt32                  aNameSpaceID,
   1:                                   nsFrameConstructorState& aState, 
   1:                                   nsIFrame*                aParentFrameIn = nsnull);
   1: 
   1:   nsresult CreatePseudoRowGroupFrame(PRInt32                  aNameSpaceID,
   1:                                      nsFrameConstructorState& aState, 
   1:                                      nsIFrame*                aParentFrameIn = nsnull);
   1: 
   1:   nsresult CreatePseudoColGroupFrame(PRInt32                  aNameSpaceID,
   1:                                      nsFrameConstructorState& aState, 
   1:                                      nsIFrame*                aParentFrameIn = nsnull);
   1: 
   1:   nsresult CreatePseudoRowFrame(PRInt32                  aNameSpaceID,
   1:                                 nsFrameConstructorState& aState, 
   1:                                 nsIFrame*                aParentFrameIn = nsnull);
   1: 
   1:   nsresult CreatePseudoCellFrame(PRInt32                  aNameSpaceID,
   1:                                  nsFrameConstructorState& aState, 
   1:                                  nsIFrame*                aParentFrameIn = nsnull);
   1: 
   1:   nsresult GetPseudoTableFrame(PRInt32                  aNameSpaceID,
   1:                                nsFrameConstructorState& aState, 
   1:                                nsIFrame&                aParentFrameIn);
   1: 
   1:   nsresult GetPseudoColGroupFrame(PRInt32                  aNameSpaceID,
   1:                                   nsFrameConstructorState& aState, 
   1:                                   nsIFrame&                aParentFrameIn);
   1: 
   1:   nsresult GetPseudoRowGroupFrame(PRInt32                  aNameSpaceID,
   1:                                   nsFrameConstructorState& aState, 
   1:                                   nsIFrame&                aParentFrameIn);
   1: 
   1:   nsresult GetPseudoRowFrame(PRInt32                  aNameSpaceID,
   1:                              nsFrameConstructorState& aState, 
   1:                              nsIFrame&                aParentFrameIn);
   1: 
   1:   nsresult GetPseudoCellFrame(PRInt32                  aNameSpaceID,
   1:                               nsFrameConstructorState& aState, 
   1:                               nsIFrame&                aParentFrameIn);
   1: 
   1:   nsresult GetParentFrame(PRInt32                  aNameSpaceID,
   1:                           nsIFrame&                aParentFrameIn, 
   1:                           nsIAtom*                 aChildFrameType, 
   1:                           nsFrameConstructorState& aState, 
   1:                           nsIFrame*&               aParentFrame,
   1:                           PRBool&                  aIsPseudoParent);
   1: 
   1:   /**
   1:    * Function to adjust aParentFrame and aFrameItems to deal with table
   1:    * pseudo-frames that may have to be inserted.
   1:    * @param aState the nsFrameConstructorState we're using.
   1:    * @param aChildContent the content node we want to construct a frame for
   1:    * @param aParentFrame the frame we think should be the parent.  This will be
   1:    *        adjusted to point to a pseudo-frame if needed.
   1:    * @param aTag tag that would be used for frame construction
   1:    * @param aNameSpaceID namespace that will be used for frame construction
   1:    * @param aChildStyle the style context for aChildContent
   1:    * @param aFrameItems the framelist we think we need to put the child frame
   1:    *        into.  If we have to construct pseudo-frames, we'll modify the
   1:    *        pointer to point to the list the child frame should go into.
   1:    * @param aSaveState the nsFrameConstructorSaveState we can use for pushing a
   1:    *        float containing block if we have to do it.
   1:    * @param aSuppressFrame whether we should not create a frame below this
   1:    *        parent
   1:    * @param aCreatedPseudo whether we had to create a pseudo-parent
   1:    * @return NS_OK on success, NS_ERROR_OUT_OF_MEMORY and such as needed.
   1:    */
   1:   // XXXbz this function should really go away once we rework pseudo-frame
   1:   // handling to be better. This should simply be part of the job of
   1:   // GetGeometricParent, and stuff like the frameitems and parent frame should
   1:   // be kept track of in the state...
   1:   nsresult AdjustParentFrame(nsFrameConstructorState&     aState,
   1:                              nsIContent*                  aChildContent,
   1:                              nsIFrame* &                  aParentFrame,
   1:                              nsIAtom*                     aTag,
   1:                              PRInt32                      aNameSpaceID,
   1:                              nsStyleContext*              aChildStyle,
   1:                              nsFrameItems* &              aFrameItems,
   1:                              nsFrameConstructorSaveState& aSaveState,
   1:                              PRBool&                      aSuppressFrame,
   1:                              PRBool&                      aCreatedPseudo);
   1: 
   1:   const nsStyleDisplay* GetDisplay(nsIFrame* aFrame);
   1: 
   1:   // END TABLE SECTION
   1: 
   1: protected:
   1:   static nsresult CreatePlaceholderFrameFor(nsIPresShell*    aPresShell, 
   1:                                             nsPresContext*  aPresContext,
   1:                                             nsFrameManager*  aFrameManager,
   1:                                             nsIContent*      aContent,
   1:                                             nsIFrame*        aFrame,
   1:                                             nsStyleContext*  aStyleContext,
   1:                                             nsIFrame*        aParentFrame,
   1:                                             nsIFrame**       aPlaceholderFrame);
   1: 
   1: private:
   1:   // @param OUT aNewFrame the new radio control frame
   1:   nsresult ConstructRadioControlFrame(nsIFrame**         aNewFrame,
   1:                                       nsIContent*        aContent,
   1:                                       nsStyleContext*    aStyleContext);
   1: 
   1:   // @param OUT aNewFrame the new checkbox control frame
   1:   nsresult ConstructCheckboxControlFrame(nsIFrame**       aNewFrame,
   1:                                          nsIContent*      aContent,
   1:                                          nsStyleContext*  aStyleContext);
   1:   // ConstructButtonFrame puts the new frame in aFrameItems and
   1:   // handles the kids of the button.
   1:   nsresult ConstructButtonFrame(nsFrameConstructorState& aState,
   1:                                 nsIContent*              aContent,
   1:                                 nsIFrame*                aParentFrame,
   1:                                 nsIAtom*                 aTag,
   1:                                 nsStyleContext*          aStyleContext,
   1:                                 nsIFrame**               aNewFrame,
   1:                                 const nsStyleDisplay*    aStyleDisplay,
4461:                                 nsFrameItems&            aFrameItems,
4461:                                 PRBool                   aHasPseudoParent);
   1: 
   1:   // ConstructSelectFrame puts the new frame in aFrameItems and
   1:   // handles the kids of the select.
   1:   nsresult ConstructSelectFrame(nsFrameConstructorState& aState,
   1:                                 nsIContent*              aContent,
   1:                                 nsIFrame*                aParentFrame,
   1:                                 nsIAtom*                 aTag,
   1:                                 nsStyleContext*          aStyleContext,
   1:                                 nsIFrame*&               aNewFrame,
   1:                                 const nsStyleDisplay*    aStyleDisplay,
   1:                                 PRBool&                  aFrameHasBeenInitialized,
   1:                                 nsFrameItems&            aFrameItems);
   1: 
   1:   // ConstructFieldSetFrame puts the new frame in aFrameItems and
   1:   // handles the kids of the fieldset
   1:   nsresult ConstructFieldSetFrame(nsFrameConstructorState& aState,
   1:                                   nsIContent*              aContent,
   1:                                   nsIFrame*                aParentFrame,
   1:                                   nsIAtom*                 aTag,
   1:                                   nsStyleContext*          aStyleContext,
   1:                                   nsIFrame*&               aNewFrame,
   1:                                   nsFrameItems&            aFrameItems,
   1:                                   const nsStyleDisplay*    aStyleDisplay,
   1:                                   PRBool&                  aFrameHasBeenInitialized);
   1: 
   1:   nsresult ConstructTextFrame(nsFrameConstructorState& aState,
   1:                               nsIContent*              aContent,
   1:                               nsIFrame*                aParentFrame,
   1:                               nsStyleContext*          aStyleContext,
   1:                               nsFrameItems&            aFrameItems,
   1:                               PRBool                   aPseudoParent);
   1: 
   1:   nsresult ConstructPageBreakFrame(nsFrameConstructorState& aState,
   1:                                    nsIContent*              aContent,
   1:                                    nsIFrame*                aParentFrame,
   1:                                    nsStyleContext*          aStyleContext,
   1:                                    nsFrameItems&            aFrameItems);
   1: 
   1:   // Construct a page break frame if page-break-before:always is set in aStyleContext
   1:   // and add it to aFrameItems. Return true if page-break-after:always is set on aStyleContext.
   1:   // Don't do this for row groups, rows or cell, because tables handle those internally.
   1:   PRBool PageBreakBefore(nsFrameConstructorState& aState,
   1:                          nsIContent*              aContent,
   1:                          nsIFrame*                aParentFrame,
   1:                          nsStyleContext*          aStyleContext,
   1:                          nsFrameItems&            aFrameItems);
   1: 
   1:   nsresult ConstructHTMLFrame(nsFrameConstructorState& aState,
   1:                               nsIContent*              aContent,
   1:                               nsIFrame*                aParentFrame,
   1:                               nsIAtom*                 aTag,
   1:                               PRInt32                  aNameSpaceID,
   1:                               nsStyleContext*          aStyleContext,
   1:                               nsFrameItems&            aFrameItems,
   1:                               PRBool                   aHasPseudoParent);
   1: 
   1:   nsresult ConstructFrameInternal( nsFrameConstructorState& aState,
   1:                                    nsIContent*              aContent,
   1:                                    nsIFrame*                aParentFrame,
   1:                                    nsIAtom*                 aTag,
   1:                                    PRInt32                  aNameSpaceID,
   1:                                    nsStyleContext*          aStyleContext,
   1:                                    nsFrameItems&            aFrameItems,
   1:                                    PRBool                   aXBLBaseTag);
   1: 
   1:   nsresult CreateAnonymousFrames(nsIAtom*                 aTag,
   1:                                  nsFrameConstructorState& aState,
   1:                                  nsIContent*              aParent,
   1:                                  nsIFrame*                aNewFrame,
   1:                                  PRBool                   aAppendToExisting,
   1:                                  nsFrameItems&            aChildItems,
   1:                                  PRBool                   aIsRoot = PR_FALSE);
   1: 
   1:   nsresult CreateAnonymousFrames(nsFrameConstructorState& aState,
   1:                                  nsIContent*              aParent,
   1:                                  nsIDocument*             aDocument,
   1:                                  nsIFrame*                aNewFrame,
   1:                                  PRBool                   aAppendToExisting,
   1:                                  nsFrameItems&            aChildItems);
   1: 
   1: //MathML Mod - RBS
   1: #ifdef MOZ_MATHML
   1:   nsresult ConstructMathMLFrame(nsFrameConstructorState& aState,
   1:                                 nsIContent*              aContent,
   1:                                 nsIFrame*                aParentFrame,
   1:                                 nsIAtom*                 aTag,
   1:                                 PRInt32                  aNameSpaceID,
   1:                                 nsStyleContext*          aStyleContext,
   1:                                 nsFrameItems&            aFrameItems,
   1:                                 PRBool                   aHasPseudoParent);
   1: #endif
   1: 
   1:   nsresult ConstructXULFrame(nsFrameConstructorState& aState,
   1:                              nsIContent*              aContent,
   1:                              nsIFrame*                aParentFrame,
   1:                              nsIAtom*                 aTag,
   1:                              PRInt32                  aNameSpaceID,
   1:                              nsStyleContext*          aStyleContext,
   1:                              nsFrameItems&            aFrameItems,
   1:                              PRBool                   aXBLBaseTag,
   1:                              PRBool                   aHasPseudoParent,
   1:                              PRBool*                  aHaltProcessing);
   1: 
   1: 
   1: // XTF
   1: #ifdef MOZ_XTF
   1:   nsresult ConstructXTFFrame(nsFrameConstructorState& aState,
   1:                              nsIContent*              aContent,
   1:                              nsIFrame*                aParentFrame,
   1:                              nsIAtom*                 aTag,
   1:                              PRInt32                  aNameSpaceID,
   1:                              nsStyleContext*          aStyleContext,
   1:                              nsFrameItems&            aFrameItems,
   1:                              PRBool                   aHasPseudoParent);
   1: #endif
   1: 
   1: // SVG - rods
   1: #ifdef MOZ_SVG
   1:   nsresult TestSVGConditions(nsIContent* aContent,
   1:                              PRBool&     aHasRequiredExtensions,
   1:                              PRBool&     aHasRequiredFeatures,
   1:                              PRBool&     aHasSystemLanguage);
   1:  
   1:   nsresult SVGSwitchProcessChildren(nsFrameConstructorState& aState,
   1:                                     nsIContent*              aContent,
   1:                                     nsIFrame*                aFrame,
   1:                                     nsFrameItems&            aFrameItems);
   1: 
   1:   nsresult ConstructSVGFrame(nsFrameConstructorState& aState,
   1:                              nsIContent*              aContent,
   1:                              nsIFrame*                aParentFrame,
   1:                              nsIAtom*                 aTag,
   1:                              PRInt32                  aNameSpaceID,
   1:                              nsStyleContext*          aStyleContext,
   1:                              nsFrameItems&            aFrameItems,
   1:                              PRBool                   aHasPseudoParent,
   1:                              PRBool*                  aHaltProcessing);
   1: #endif
   1: 
   1:   nsresult ConstructFrameByDisplayType(nsFrameConstructorState& aState,
   1:                                        const nsStyleDisplay*    aDisplay,
   1:                                        nsIContent*              aContent,
   1:                                        PRInt32                  aNameSpaceID,
   1:                                        nsIAtom*                 aTag,
   1:                                        nsIFrame*                aParentFrame,
   1:                                        nsStyleContext*          aStyleContext,
   1:                                        nsFrameItems&            aFrameItems,
   1:                                        PRBool                   aHasPseudoParent);
   1: 
   1:   nsresult ProcessChildren(nsFrameConstructorState& aState,
   1:                            nsIContent*              aContent,
   1:                            nsIFrame*                aFrame,
   1:                            PRBool                   aCanHaveGeneratedContent,
   1:                            nsFrameItems&            aFrameItems,
   1:                            PRBool                   aParentIsBlock);
   1: 
   1:   // @param OUT aFrame the newly created frame
   1:   nsresult CreateInputFrame(nsFrameConstructorState& aState,
   1:                             nsIContent*              aContent,
   1:                             nsIFrame*                aParentFrame,
   1:                             nsIAtom*                 aTag,
   1:                             nsStyleContext*          aStyleContext,
   1:                             nsIFrame**               aFrame,
   1:                             const nsStyleDisplay*    aStyleDisplay,
   1:                             PRBool&                  aFrameHasBeenInitialized,
   1:                             PRBool&                  aAddedToFrameList,
4461:                             nsFrameItems&            aFrameItems,
4461:                             PRBool                   aHasPseudoParent);
   1: 
   1:   // A function that can be invoked to create some sort of image frame.
   1:   typedef nsIFrame* (* ImageFrameCreatorFunc)(nsIPresShell*, nsStyleContext*);
   1: 
   1:   /**
   1:    * CreateHTMLImageFrame will do some tests on aContent, and if it determines
   1:    * that the content should get an image frame it'll create one via aFunc and
   1:    * return it in *aFrame.  Note that if this content node isn't supposed to
   1:    * have an image frame this method will return NS_OK and set *aFrame to null.
   1:    */
   1:   nsresult CreateHTMLImageFrame(nsIContent*           aContent,
   1:                                 nsStyleContext*       aStyleContext,
   1:                                 ImageFrameCreatorFunc aFunc,
   1:                                 nsIFrame**            aFrame);
   1: 
   1:   nsIFrame* GetFrameFor(nsIContent* aContent);
   1: 
   1:   /**
   1:    * These functions are used when we start frame creation from a non-root
   1:    * element. They should recreate the same state that we would have
   1:    * arrived at if we had built frames from the root frame to aFrame.
   1:    * Therefore, any calls to PushFloatContainingBlock and
   1:    * PushAbsoluteContainingBlock during frame construction should get
   1:    * corresponding logic in these functions.
   1:    */
   1:   nsIFrame* GetAbsoluteContainingBlock(nsIFrame* aFrame);
   1:   nsIFrame* GetFloatContainingBlock(nsIFrame* aFrame);
   1: 
   1:   nsIContent* PropagateScrollToViewport();
   1: 
   1:   // Build a scroll frame: 
   1:   //  Calls BeginBuildingScrollFrame, InitAndRestoreFrame, and then FinishBuildingScrollFrame.
   1:   //  Sets the primary frame for the content to the output aNewFrame.
   1:   // @param aNewFrame the created scrollframe --- output only
   1:   nsresult
   1:   BuildScrollFrame(nsFrameConstructorState& aState,
   1:                    nsIContent*              aContent,
   1:                    nsStyleContext*          aContentStyle,
   1:                    nsIFrame*                aScrolledFrame,
   1:                    nsIFrame*                aParentFrame,
   1:                    nsIFrame*                aContentParentFrame,
   1:                    nsIFrame*&               aNewFrame,
   1:                    nsStyleContext*&         aScrolledChildStyle);
   1: 
   1:   // Builds the initial ScrollFrame
   1:   already_AddRefed<nsStyleContext>
   1:   BeginBuildingScrollFrame(nsFrameConstructorState& aState,
   1:                            nsIContent*              aContent,
   1:                            nsStyleContext*          aContentStyle,
   1:                            nsIFrame*                aParentFrame,
   1:                            nsIFrame*                aContentParentFrame,
   1:                            nsIAtom*                 aScrolledPseudo,
   1:                            PRBool                   aIsRoot,
   1:                            nsIFrame*&               aNewFrame);
   1: 
   1:   // Completes the building of the scrollframe:
   1:   // Creates a view for the scrolledframe and makes it the child of the scrollframe.
   1:   void
   1:   FinishBuildingScrollFrame(nsIFrame* aScrollFrame,
   1:                             nsIFrame* aScrolledFrame);
   1: 
   1:   // InitializeSelectFrame puts scrollFrame in aFrameItems if aBuildCombobox is false
   1:   nsresult
   1:   InitializeSelectFrame(nsFrameConstructorState& aState,
   1:                         nsIFrame*                scrollFrame,
   1:                         nsIFrame*                scrolledFrame,
   1:                         nsIContent*              aContent,
   1:                         nsIFrame*                aParentFrame,
   1:                         nsStyleContext*          aStyleContext,
   1:                         PRBool                   aBuildCombobox,
   1:                         nsFrameItems&            aFrameItems);
   1: 
   1:   nsresult MaybeRecreateFramesForContent(nsIContent*      aContent);
   1: 
   1:   nsresult RecreateFramesForContent(nsIContent*      aContent);
   1: 
4696:   // If removal of aFrame from the frame tree requires reconstruction of some
4696:   // containing block (either of aFrame or of its parent) due to {ib} splits,
4696:   // recreate the relevant containing block.  The return value indicates
4696:   // whether this happened.  If this method returns true, *aResult is the
4696:   // return value of ReframeContainingBlock.  If this method returns false, the
4696:   // value of *aResult is no affected.  aFrame and aResult must not be null.
4696:   // aFrame must be the result of a GetPrimaryFrameFor() call (which means its
4696:   // parent is also not null).
4696:   PRBool MaybeRecreateContainerForIBSplitterFrame(nsIFrame* aFrame,
4696:                                                   nsresult* aResult);
   1: 
   1:   nsresult CreateContinuingOuterTableFrame(nsIPresShell*    aPresShell, 
   1:                                            nsPresContext*  aPresContext,
   1:                                            nsIFrame*        aFrame,
   1:                                            nsIFrame*        aParentFrame,
   1:                                            nsIContent*      aContent,
   1:                                            nsStyleContext*  aStyleContext,
   1:                                            nsIFrame**       aContinuingFrame);
   1: 
   1:   nsresult CreateContinuingTableFrame(nsIPresShell*    aPresShell, 
   1:                                       nsPresContext*  aPresContext,
   1:                                       nsIFrame*        aFrame,
   1:                                       nsIFrame*        aParentFrame,
   1:                                       nsIContent*      aContent,
   1:                                       nsStyleContext*  aStyleContext,
   1:                                       nsIFrame**       aContinuingFrame);
   1: 
   1:   //----------------------------------------
   1: 
   1:   // Methods support creating block frames and their children
   1: 
   1:   already_AddRefed<nsStyleContext>
   1:   GetFirstLetterStyle(nsIContent*      aContent,
   1:                       nsStyleContext*  aStyleContext);
   1: 
   1:   already_AddRefed<nsStyleContext>
   1:   GetFirstLineStyle(nsIContent*      aContent,
   1:                     nsStyleContext*  aStyleContext);
   1: 
1254:   PRBool ShouldHaveFirstLetterStyle(nsIContent*      aContent,
   1:                                     nsStyleContext*  aStyleContext);
   1: 
 551:   // Check whether a given block has first-letter style.  Make sure to
 551:   // only pass in blocks!  And don't pass in null either.
1254:   PRBool HasFirstLetterStyle(nsIFrame* aBlockFrame);
 551: 
1254:   PRBool ShouldHaveFirstLineStyle(nsIContent*      aContent,
   1:                                   nsStyleContext*  aStyleContext);
   1: 
1254:   void ShouldHaveSpecialBlockStyle(nsIContent*      aContent,
   1:                                    nsStyleContext*  aStyleContext,
   1:                                    PRBool*          aHaveFirstLetterStyle,
   1:                                    PRBool*          aHaveFirstLineStyle);
   1: 
   1:   // |aContentParentFrame| should be null if it's really the same as
   1:   // |aParentFrame|.
   1:   // @param aFrameItems where we want to put the block in case it's in-flow.
   1:   // @param aNewFrame an in/out parameter. On input it is the block to be
   1:   // constructed. On output it is reset to the outermost
   1:   // frame constructed (e.g. if we need to wrap the block in an
   1:   // nsColumnSetFrame.
   1:   // @param aParentFrame is the desired parent for the (possibly wrapped)
   1:   // block
   1:   // @param aContentParent is the parent the block would have if it
   1:   // were in-flow
   1:   nsresult ConstructBlock(nsFrameConstructorState& aState,
   1:                           const nsStyleDisplay*    aDisplay,
   1:                           nsIContent*              aContent,
   1:                           nsIFrame*                aParentFrame,
   1:                           nsIFrame*                aContentParentFrame,
   1:                           nsStyleContext*          aStyleContext,
   1:                           nsIFrame**               aNewFrame,
   1:                           nsFrameItems&            aFrameItems,
   1:                           PRBool                   aAbsPosContainer);
   1: 
   1:   nsresult ConstructInline(nsFrameConstructorState& aState,
   1:                            const nsStyleDisplay*    aDisplay,
   1:                            nsIContent*              aContent,
   1:                            nsIFrame*                aParentFrame,
   1:                            nsStyleContext*          aStyleContext,
   1:                            PRBool                   aIsPositioned,
   1:                            nsIFrame*                aNewFrame);
   1: 
4696:   /**
4696:    * Move an already-constructed framelist into the inline frame at
4696:    * the tail end of an {ib} split.  Creates said inline if it doesn't
4696:    * already exist.
4696:    *
4696:    * @param aState the frame construction state we're using right now.
4696:    * @param aExistingEndFrame if non-null, the already-existing end frame.
4696:    * @param aIsPositioned Whether the end frame should be positioned.
4696:    * @param aContent the content node for this {ib} split.
4696:    * @param aStyleContext the style context to use for the new frame
4696:    * @param aFramesToMove The frame list to move over
4696:    * @param aBlockPart the block part of the {ib} split.
4696:    * @param aTargetState if non-null, the target state to pass to
4696:    *        MoveChildrenTo for float reparenting.
4696:    * XXXbz test float reparenting?
4696:    *
4696:    * @note aIsPositioned, aContent, aStyleContext, are
4696:    *       only used if aExistingEndFrame is null.
4696:    */
4696:   nsIFrame* MoveFramesToEndOfIBSplit(nsFrameConstructorState& aState,
4696:                                      nsIFrame* aExistingEndFrame,
4696:                                      PRBool aIsPositioned,
4696:                                      nsIContent* aContent,
4696:                                      nsStyleContext* aStyleContext,
4696:                                      nsIFrame* aFramesToMove,
4696:                                      nsIFrame* aBlockPart,
4696:                                      nsFrameConstructorState* aTargetState);
4696: 
   1:   nsresult ProcessInlineChildren(nsFrameConstructorState& aState,
   1:                                  nsIContent*              aContent,
   1:                                  nsIFrame*                aFrame,
   1:                                  PRBool                   aCanHaveGeneratedContent,
   1:                                  nsFrameItems&            aFrameItems,
   1:                                  PRBool*                  aKidsAllInline);
   1: 
   1:   PRBool AreAllKidsInline(nsIFrame* aFrameList);
   1: 
4696:   // Determine whether we need to wipe out what we just did and start over
4696:   // because we're doing something like adding block kids to an inline frame
4696:   // (and therefore need an {ib} split).  If aIsAppend is true, aPrevSibling is
4696:   // ignored.  Otherwise it may be used to determine whether to reframe when
4696:   // inserting into the block of an {ib} split.
4696:   // @return PR_TRUE if we reconstructed the containing block, PR_FALSE
4696:   // otherwise
   1:   PRBool WipeContainingBlock(nsFrameConstructorState& aState,
4696:                              nsIFrame*                aContainingBlock,
   1:                              nsIFrame*                aFrame,
4696:                              const nsFrameItems&      aFrameList,
4696:                              PRBool                   aIsAppend,
4696:                              nsIFrame*                aPrevSibling);
   1: 
   1:   nsresult ReframeContainingBlock(nsIFrame* aFrame);
   1: 
2724:   nsresult StyleChangeReflow(nsIFrame* aFrame);
   1: 
   1:   /** Helper function that searches the immediate child frames 
   1:     * (and their children if the frames are "special")
   1:     * for a frame that maps the specified content object
   1:     *
   1:     * @param aParentFrame   the primary frame for aParentContent
   1:     * @param aContent       the content node for which we seek a frame
   1:     * @param aParentContent the parent for aContent 
   1:     * @param aHint          an optional hint used to make the search for aFrame faster
   1:     */
   1:   nsIFrame* FindFrameWithContent(nsFrameManager*  aFrameManager,
   1:                                  nsIFrame*        aParentFrame,
   1:                                  nsIContent*      aParentContent,
   1:                                  nsIContent*      aContent,
   1:                                  nsFindFrameHint* aHint);
   1: 
   1:   //----------------------------------------
   1: 
   1:   // Methods support :first-letter style
   1: 
   1:   void CreateFloatingLetterFrame(nsFrameConstructorState& aState,
   1:                                  nsIFrame*                aBlockFrame,
   1:                                  nsIContent*              aTextContent,
   1:                                  nsIFrame*                aTextFrame,
   1:                                  nsIContent*              aBlockContent,
   1:                                  nsIFrame*                aParentFrame,
   1:                                  nsStyleContext*          aStyleContext,
   1:                                  nsFrameItems&            aResult);
   1: 
   1:   nsresult CreateLetterFrame(nsFrameConstructorState& aState,
   1:                              nsIFrame*                aBlockFrame,
   1:                              nsIContent*              aTextContent,
   1:                              nsIFrame*                aParentFrame,
   1:                              nsFrameItems&            aResult);
   1: 
   1:   nsresult WrapFramesInFirstLetterFrame(nsFrameConstructorState& aState,
   1:                                         nsIContent*              aBlockContent,
   1:                                         nsIFrame*                aBlockFrame,
   1:                                         nsFrameItems&            aBlockFrames);
   1: 
   1:   nsresult WrapFramesInFirstLetterFrame(nsFrameConstructorState& aState,
   1:                                         nsIFrame*                aBlockFrame,
   1:                                         nsIFrame*                aParentFrame,
   1:                                         nsIFrame*                aParentFrameList,
   1:                                         nsIFrame**               aModifiedParent,
   1:                                         nsIFrame**               aTextFrame,
   1:                                         nsIFrame**               aPrevFrame,
   1:                                         nsFrameItems&            aLetterFrame,
   1:                                         PRBool*                  aStopLooking);
   1: 
   1:   nsresult RecoverLetterFrames(nsFrameConstructorState& aState,
   1:                                nsIFrame*                aBlockFrame);
   1: 
   1:   // 
   1:   nsresult RemoveLetterFrames(nsPresContext*  aPresContext,
   1:                               nsIPresShell*    aPresShell,
   1:                               nsFrameManager*  aFrameManager,
   1:                               nsIFrame*        aBlockFrame);
   1: 
   1:   // Recursive helper for RemoveLetterFrames
   1:   nsresult RemoveFirstLetterFrames(nsPresContext*  aPresContext,
   1:                                    nsIPresShell*    aPresShell,
   1:                                    nsFrameManager*  aFrameManager,
   1:                                    nsIFrame*        aFrame,
   1:                                    PRBool*          aStopLooking);
   1: 
   1:   // Special remove method for those pesky floating first-letter frames
   1:   nsresult RemoveFloatingFirstLetterFrames(nsPresContext*  aPresContext,
   1:                                            nsIPresShell*    aPresShell,
   1:                                            nsFrameManager*  aFrameManager,
   1:                                            nsIFrame*        aBlockFrame,
   1:                                            PRBool*          aStopLooking);
   1: 
   1:   // Capture state for the frame tree rooted at the frame associated with the
   1:   // content object, aContent
   1:   nsresult CaptureStateForFramesOf(nsIContent* aContent,
   1:                                    nsILayoutHistoryState* aHistoryState);
   1: 
   1:   // Capture state for the frame tree rooted at aFrame.
   1:   nsresult CaptureStateFor(nsIFrame*              aFrame,
   1:                            nsILayoutHistoryState* aHistoryState);
   1: 
   1:   //----------------------------------------
   1: 
   1:   // Methods support :first-line style
   1: 
   1:   nsresult WrapFramesInFirstLineFrame(nsFrameConstructorState& aState,
   1:                                       nsIContent*              aBlockContent,
   1:                                       nsIFrame*                aBlockFrame,
   1:                                       nsFrameItems&            aFrameItems);
   1: 
   1:   nsresult AppendFirstLineFrames(nsFrameConstructorState& aState,
   1:                                  nsIContent*              aContent,
   1:                                  nsIFrame*                aBlockFrame,
   1:                                  nsFrameItems&            aFrameItems);
   1: 
   1:   nsresult InsertFirstLineFrames(nsFrameConstructorState& aState,
   1:                                  nsIContent*              aContent,
   1:                                  nsIFrame*                aBlockFrame,
   1:                                  nsIFrame**               aParentFrame,
   1:                                  nsIFrame*                aPrevSibling,
   1:                                  nsFrameItems&            aFrameItems);
   1: 
   1:   nsresult RemoveFixedItems(const nsFrameConstructorState& aState);
   1: 
   1:   // Find the ``rightmost'' frame for the content immediately preceding
   1:   // aIndexInContainer, following continuations if necessary. If aChild is
   1:   // not null, make sure it passes the call to IsValidSibling
   1:   nsIFrame* FindPreviousSibling(nsIContent*       aContainer,
   1:                                 nsIFrame*         aContainerFrame,
   1:                                 PRInt32           aIndexInContainer,
   1:                                 const nsIContent* aChild = nsnull);
   1: 
   1:   // Find the frame for the content node immediately following aIndexInContainer.
   1:   // If aChild is not null, make sure it passes the call to IsValidSibling
   1:   nsIFrame* FindNextSibling(nsIContent*       aContainer,
   1:                             nsIFrame*         aContainerFrame,
   1:                             PRInt32           aIndexInContainer,
   1:                             const nsIContent* aChild = nsnull);
   1: 
   1:   // see if aContent and aSibling are legitimate siblings due to restrictions
   1:   // imposed by table columns
1502:   // XXXbz this code is generally wrong, since the frame for aContent
1502:   // may be constructed based on tag, not based on aDisplay!
   1:   PRBool IsValidSibling(nsIFrame*              aParentFrame,
1502:                         nsIFrame*              aSibling,
   1:                         PRUint8                aSiblingDisplay,
   1:                         nsIContent&            aContent,
   1:                         PRUint8&               aDisplay);
   1: 
   1:   void QuotesDirty() {
   1:     if (mUpdateCount != 0)
   1:       mQuotesDirty = PR_TRUE;
   1:     else
   1:       mQuoteList.RecalcAll();
   1:   }
   1: 
   1:   void CountersDirty() {
   1:     if (mUpdateCount != 0)
   1:       mCountersDirty = PR_TRUE;
   1:     else
   1:       mCounterManager.RecalcAll();
   1:   }
   1: 
   1: public:
   1:   struct RestyleData;
   1:   friend struct RestyleData;
   1: 
   1:   struct RestyleData {
   1:     nsReStyleHint mRestyleHint;  // What we want to restyle
   1:     nsChangeHint  mChangeHint;   // The minimal change hint for "self"
   1:   };
   1: 
   1:   struct RestyleEnumerateData : public RestyleData {
   1:     nsCOMPtr<nsIContent> mContent;
   1:   };
   1: 
   1:   class RestyleEvent;
   1:   friend class RestyleEvent;
   1: 
   1:   class RestyleEvent : public nsRunnable {
   1:   public:
   1:     NS_DECL_NSIRUNNABLE
   1:     RestyleEvent(nsCSSFrameConstructor *aConstructor)
   1:       : mConstructor(aConstructor) {
   1:       NS_PRECONDITION(aConstructor, "Must have a constructor!");
   1:     }
   1:     void Revoke() { mConstructor = nsnull; }
   1:   private:
   1:     nsCSSFrameConstructor *mConstructor;
   1:   };
   1: 
   1:   friend class nsFrameConstructorState;
   1: 
   1: private:
3129: 
3129:   class LazyGenerateChildrenEvent;
3129:   friend class LazyGenerateChildrenEvent;
3129: 
3129:   class LazyGenerateChildrenEvent : public nsRunnable {
3129:   public:
3129:     NS_DECL_NSIRUNNABLE
3129:     LazyGenerateChildrenEvent(nsIContent *aContent,
3129:                               nsIPresShell *aPresShell,
3129:                               nsLazyFrameConstructionCallback* aCallback,
3129:                               void* aArg)
3129:       : mContent(aContent), mPresShell(aPresShell), mCallback(aCallback), mArg(aArg)
3129:     {}
3129: 
3129:   private:
3129:     nsCOMPtr<nsIContent> mContent;
3129:     nsCOMPtr<nsIPresShell> mPresShell;
3129:     nsLazyFrameConstructionCallback* mCallback;
3129:     void* mArg;
3129:   };
3129: 
   1:   nsIDocument*        mDocument;  // Weak ref
   1:   nsIPresShell*       mPresShell; // Weak ref
   1: 
   1:   nsIFrame*           mInitialContainingBlock;
   1:   nsIFrame*           mFixedContainingBlock;
   1:   nsIFrame*           mDocElementContainingBlock;
   1:   nsIFrame*           mGfxScrollFrame;
   1:   nsIFrame*           mPageSequenceFrame;
   1:   nsQuoteList         mQuoteList;
   1:   nsCounterManager    mCounterManager;
   1:   PRUint16            mUpdateCount;
   1:   PRPackedBool        mQuotesDirty : 1;
   1:   PRPackedBool        mCountersDirty : 1;
   1:   PRPackedBool        mInitialContainingBlockIsAbsPosContainer : 1;
   1:   PRPackedBool        mIsDestroyingFrameTree : 1;
   1: 
   1:   nsRevocableEventPtr<RestyleEvent> mRestyleEvent;
   1: 
   1:   nsCOMPtr<nsILayoutHistoryState> mTempFrameTreeState;
   1: 
   1:   nsDataHashtable<nsISupportsHashKey, RestyleData> mPendingRestyles;
   1: 
   1:   static nsIXBLService * gXBLService;
   1: };
   1: 
   1: #endif /* nsCSSFrameConstructor_h___ */
