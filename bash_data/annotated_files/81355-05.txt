42611: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
42611:  * ***** BEGIN LICENSE BLOCK *****
42611:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
42611:  *
42611:  * The contents of this file are subject to the Mozilla Public License Version
42611:  * 1.1 (the "License"); you may not use this file except in compliance with
42611:  * the License. You may obtain a copy of the License at
42611:  * http://www.mozilla.org/MPL/
42611:  *
42611:  * Software distributed under the License is distributed on an "AS IS" basis,
42611:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
42611:  * for the specific language governing rights and limitations under the
42611:  * License.
42611:  *
42611:  * The Original Code is Mozilla Corporation code.
42611:  *
42611:  * The Initial Developer of the Original Code is Mozilla Foundation.
42611:  * Portions created by the Initial Developer are Copyright (C) 2009
42611:  * the Initial Developer. All Rights Reserved.
42611:  *
42611:  * Contributor(s):
42611:  *   Bas Schouten <bschouten@mozilla.com>
42611:  *
42611:  * Alternatively, the contents of this file may be used under the terms of
42611:  * either the GNU General Public License Version 2 or later (the "GPL"), or
42611:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
42611:  * in which case the provisions of the GPL or the LGPL are applicable instead
42611:  * of those above. If you wish to allow use of your version of this file only
42611:  * under the terms of either the GPL or the LGPL, and not to allow others to
42611:  * use your version of this file under the terms of the MPL, indicate your
42611:  * decision by deleting the provisions above and replace them with the notice
42611:  * and other provisions required by the GPL or the LGPL. If you do not delete
42611:  * the provisions above, a recipient may use your version of this file under
42611:  * the terms of any one of the MPL, the GPL or the LGPL.
42611:  *
42611:  * ***** END LICENSE BLOCK ***** */
42611: 
42611: #include "ContainerLayerD3D9.h"
58580: #include "gfxUtils.h"
58580: #include "nsRect.h"
62701: #include "ThebesLayerD3D9.h"
62701: #include "ReadbackProcessor.h"
42611: 
42611: namespace mozilla {
42611: namespace layers {
42611: 
72995: template<class Container>
72995: static void
72995: ContainerInsertAfter(Container* aContainer, Layer* aChild, Layer* aAfter)
42611: {
72995:   aChild->SetParent(aContainer);
42611:   if (!aAfter) {
72995:     Layer *oldFirstChild = aContainer->GetFirstChild();
72995:     aContainer->mFirstChild = aChild;
42793:     aChild->SetNextSibling(oldFirstChild);
42793:     aChild->SetPrevSibling(nsnull);
42793:     if (oldFirstChild) {
42793:       oldFirstChild->SetPrevSibling(aChild);
57614:     } else {
72995:       aContainer->mLastChild = aChild;
42793:     }
42790:     NS_ADDREF(aChild);
72995:     aContainer->DidInsertChild(aChild);
42611:     return;
42611:   }
72995:   for (Layer *child = aContainer->GetFirstChild(); 
42611:        child; child = child->GetNextSibling()) {
42793:     if (aAfter == child) {
42793:       Layer *oldNextSibling = child->GetNextSibling();
42793:       child->SetNextSibling(aChild);
42793:       aChild->SetNextSibling(oldNextSibling);
42793:       if (oldNextSibling) {
42793:         oldNextSibling->SetPrevSibling(aChild);
57614:       } else {
72995:         aContainer->mLastChild = aChild;
42793:       }
42793:       aChild->SetPrevSibling(child);
42790:       NS_ADDREF(aChild);
72995:       aContainer->DidInsertChild(aChild);
42611:       return;
42611:     }
42611:   }
42611:   NS_WARNING("Failed to find aAfter layer!");
42611: }
42611: 
72995: template<class Container>
72995: static void
72995: ContainerRemoveChild(Container* aContainer, Layer* aChild)
42611: {
72995:   if (aContainer->GetFirstChild() == aChild) {
72995:     aContainer->mFirstChild = aContainer->GetFirstChild()->GetNextSibling();
72995:     if (aContainer->mFirstChild) {
72995:       aContainer->mFirstChild->SetPrevSibling(nsnull);
57614:     } else {
72995:       aContainer->mLastChild = nsnull;
42793:     }
42957:     aChild->SetNextSibling(nsnull);
42957:     aChild->SetPrevSibling(nsnull);
42957:     aChild->SetParent(nsnull);
72995:     aContainer->DidRemoveChild(aChild);
42790:     NS_RELEASE(aChild);
42611:     return;
42611:   }
42793:   Layer *lastChild = nsnull;
72995:   for (Layer *child = aContainer->GetFirstChild(); child; 
42611:        child = child->GetNextSibling()) {
42793:     if (child == aChild) {
42611:       // We're sure this is not our first child. So lastChild != NULL.
42611:       lastChild->SetNextSibling(child->GetNextSibling());
42793:       if (child->GetNextSibling()) {
42793:         child->GetNextSibling()->SetPrevSibling(lastChild);
57614:       } else {
72995:         aContainer->mLastChild = lastChild;
42793:       }
42793:       child->SetNextSibling(nsnull);
42793:       child->SetPrevSibling(nsnull);
42793:       child->SetParent(nsnull);
72995:       aContainer->DidRemoveChild(aChild);
42790:       NS_RELEASE(aChild);
42611:       return;
42611:     }
42611:     lastChild = child;
42611:   }
42611: }
42611: 
58580: static inline LayerD3D9*
72995: GetNextSibling(LayerD3D9* aLayer)
58580: {
58580:    Layer* layer = aLayer->GetLayer()->GetNextSibling();
58580:    return layer ? static_cast<LayerD3D9*>(layer->
58580:                                          ImplData())
58580:                  : nsnull;
58580: }
58580: 
79445: static bool
59776: HasOpaqueAncestorLayer(Layer* aLayer)
59776: {
59776:   for (Layer* l = aLayer->GetParent(); l; l = l->GetParent()) {
59776:     if (l->GetContentFlags() & Layer::CONTENT_OPAQUE)
80486:       return true;
59776:   }
80486:   return false;
59776: }
59776: 
72995: static inline LayerD3D9*
72995: GetNextSiblingD3D9(LayerD3D9* aLayer)
72995: {
72995:    Layer* layer = aLayer->GetLayer()->GetNextSibling();
72995:    return layer ? static_cast<LayerD3D9*>(layer->
72995:                                           ImplData())
72995:                  : nsnull;
72995: }
72995: 
72995: template<class Container>
72995: static void
72995: ContainerRender(Container* aContainer,
72995:                 LayerManagerD3D9* aManager)
42611: {
42611:   nsRefPtr<IDirect3DSurface9> previousRenderTarget;
42611:   nsRefPtr<IDirect3DTexture9> renderTexture;
42611:   float previousRenderTargetOffset[4];
42611:   float renderTargetOffset[] = { 0, 0, 0, 0 };
42611:   float oldViewMatrix[4][4];
42611: 
63846:   RECT containerD3D9ClipRect; 
72995:   aManager->device()->GetScissorRect(&containerD3D9ClipRect);
63846:   // Convert scissor to an nsIntRect. RECT's are exclusive on the bottom and
63846:   // right values.
63846:   nsIntRect oldScissor(containerD3D9ClipRect.left, 
63846:                        containerD3D9ClipRect.top,
63846:                        containerD3D9ClipRect.right - containerD3D9ClipRect.left,
63846:                        containerD3D9ClipRect.bottom - containerD3D9ClipRect.top);
61179: 
62701:   ReadbackProcessor readback;
72995:   readback.BuildUpdates(aContainer);
62701: 
72995:   nsIntRect visibleRect = aContainer->GetEffectiveVisibleRegion().GetBounds();
79445:   bool useIntermediate = aContainer->UseIntermediateSurface();
42611: 
80486:   aContainer->mSupportsComponentAlphaChildren = false;
42611:   if (useIntermediate) {
72995:     aManager->device()->GetRenderTarget(0, getter_AddRefs(previousRenderTarget));
81355:     HRESULT hr = aManager->device()->CreateTexture(visibleRect.width, visibleRect.height, 1,
42611:                                                    D3DUSAGE_RENDERTARGET, D3DFMT_A8R8G8B8,
42611:                                                    D3DPOOL_DEFAULT, getter_AddRefs(renderTexture),
42611:                                                    NULL);
81355:     if (FAILED(hr)) {
81355:       aManager->ReportFailure(NS_LITERAL_CSTRING("ContainerLayerD3D9::ContainerRender(): Failed to create texture"),
81355:                               hr);
81355:       return;
81355:     }
81355: 
42611:     nsRefPtr<IDirect3DSurface9> renderSurface;
42611:     renderTexture->GetSurfaceLevel(0, getter_AddRefs(renderSurface));
72995:     aManager->device()->SetRenderTarget(0, renderSurface);
59776: 
72995:     if (aContainer->mVisibleRegion.GetNumRects() == 1 && 
72995:         (aContainer->GetContentFlags() & aContainer->CONTENT_OPAQUE)) {
59776:       // don't need a background, we're going to paint all opaque stuff
80486:       aContainer->mSupportsComponentAlphaChildren = true;
59776:     } else {
72995:       const gfx3DMatrix& transform3D = aContainer->GetEffectiveTransform();
59776:       gfxMatrix transform;
59776:       // If we have an opaque ancestor layer, then we can be sure that
59776:       // all the pixels we draw into are either opaque already or will be
59776:       // covered by something opaque. Otherwise copying up the background is
59776:       // not safe.
59776:       HRESULT hr = E_FAIL;
72995:       if (HasOpaqueAncestorLayer(aContainer) &&
59776:           transform3D.Is2D(&transform) && !transform.HasNonIntegerTranslation()) {
59776:         // Copy background up from below
59776:         RECT dest = { 0, 0, visibleRect.width, visibleRect.height };
59776:         RECT src = dest;
59776:         ::OffsetRect(&src,
59776:                      visibleRect.x + PRInt32(transform.x0),
59776:                      visibleRect.y + PRInt32(transform.y0));
72995:         hr = aManager->device()->
59776:           StretchRect(previousRenderTarget, &src, renderSurface, &dest, D3DTEXF_NONE);
59776:       }
59776:       if (hr == S_OK) {
80486:         aContainer->mSupportsComponentAlphaChildren = true;
59776:       } else {
72995:         aManager->device()->
72995:           Clear(0, 0, D3DCLEAR_TARGET, D3DCOLOR_RGBA(0, 0, 0, 0), 0, 0);
59776:       }
59776:     }
59776: 
72995:     aManager->device()->
72995:       GetVertexShaderConstantF(CBvRenderTargetOffset, previousRenderTargetOffset, 1);
42956:     renderTargetOffset[0] = (float)visibleRect.x;
42956:     renderTargetOffset[1] = (float)visibleRect.y;
72995:     aManager->device()->
72995:       SetVertexShaderConstantF(CBvRenderTargetOffset, renderTargetOffset, 1);
42611: 
54880:     gfx3DMatrix viewMatrix;
42611:     /*
42611:      * Matrix to transform to viewport space ( <-1.0, 1.0> topleft,
42611:      * <1.0, -1.0> bottomright)
42611:      */
54880:     viewMatrix._11 = 2.0f / visibleRect.width;
54880:     viewMatrix._22 = -2.0f / visibleRect.height;
54880:     viewMatrix._41 = -1.0f;
54880:     viewMatrix._42 = 1.0f;
42611: 
72995:     aManager->device()->
72995:       GetVertexShaderConstantF(CBmProjection, &oldViewMatrix[0][0], 4);
72995:     aManager->device()->
72995:       SetVertexShaderConstantF(CBmProjection, &viewMatrix._11, 4);
59559:   } else {
72995:     aContainer->mSupportsComponentAlphaChildren = 
72995:         (aContainer->GetContentFlags() & aContainer->CONTENT_OPAQUE) ||
72995:         (aContainer->mParent && 
72995:          aContainer->mParent->SupportsComponentAlphaChildren());
42611:   }
42611: 
79927:   nsAutoTArray<Layer*, 12> children;
79927:   aContainer->SortChildrenBy3DZOrder(children);
79927: 
42611:   /*
42611:    * Render this container's contents.
42611:    */
79927:   for (PRUint32 i = 0; i < children.Length(); i++) {
79927:     LayerD3D9* layerToRender = static_cast<LayerD3D9*>(children.ElementAt(i)->ImplData());
58580: 
63846:     if (layerToRender->GetLayer()->GetEffectiveVisibleRegion().IsEmpty()) {
58580:       continue;
58580:     }
58580:     
63846:     nsIntRect scissorRect =
70348:       layerToRender->GetLayer()->CalculateScissorRect(oldScissor, nsnull);
63846:     if (scissorRect.IsEmpty()) {
63846:       continue;
42611:     }
42611: 
63846:     RECT d3drect;
63846:     d3drect.left = scissorRect.x;
63846:     d3drect.top = scissorRect.y;
63846:     d3drect.right = scissorRect.x + scissorRect.width;
63846:     d3drect.bottom = scissorRect.y + scissorRect.height;
72995:     aManager->device()->SetScissorRect(&d3drect);
42611: 
72995:     if (layerToRender->GetLayer()->GetType() == aContainer->TYPE_THEBES) {
62701:       static_cast<ThebesLayerD3D9*>(layerToRender)->RenderThebesLayer(&readback);
62701:     } else {
57097:       layerToRender->RenderLayer();
62701:     }
63846:   }
61303:     
72995:   aManager->device()->SetScissorRect(&containerD3D9ClipRect);
42611: 
42611:   if (useIntermediate) {
72995:     aManager->device()->SetRenderTarget(0, previousRenderTarget);
72995:     aManager->device()->SetVertexShaderConstantF(CBvRenderTargetOffset, previousRenderTargetOffset, 1);
72995:     aManager->device()->SetVertexShaderConstantF(CBmProjection, &oldViewMatrix[0][0], 4);
42611: 
72995:     aManager->device()->SetVertexShaderConstantF(CBvLayerQuad,
54880:                                        ShaderConstantRect(visibleRect.x,
54880:                                                           visibleRect.y,
54880:                                                           visibleRect.width,
54880:                                                           visibleRect.height),
54880:                                        1);
42611: 
72995:     aContainer->SetShaderTransformAndOpacity();
42611: 
72995:     aManager->SetShaderMode(DeviceManagerD3D9::RGBALAYER);
42611: 
72995:     aManager->device()->SetTexture(0, renderTexture);
72995:     aManager->device()->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);
42611:   }
42611: }
42611: 
72995: 
72995: ContainerLayerD3D9::ContainerLayerD3D9(LayerManagerD3D9 *aManager)
72995:   : ContainerLayer(aManager, NULL)
72995:   , LayerD3D9(aManager)
72995: {
72995:   mImplData = static_cast<LayerD3D9*>(this);
72995: }
72995: 
72995: ContainerLayerD3D9::~ContainerLayerD3D9()
72995: {
72995:   while (mFirstChild) {
72995:     RemoveChild(mFirstChild);
72995:   }
72995: }
72995: 
72995: void
72995: ContainerLayerD3D9::InsertAfter(Layer* aChild, Layer* aAfter)
72995: {
72995:   ContainerInsertAfter(this, aChild, aAfter);
72995: }
72995: 
72995: void
72995: ContainerLayerD3D9::RemoveChild(Layer *aChild)
72995: {
72995:   ContainerRemoveChild(this, aChild);
72995: }
72995: 
72995: Layer*
72995: ContainerLayerD3D9::GetLayer()
72995: {
72995:   return this;
72995: }
72995: 
72995: LayerD3D9*
72995: ContainerLayerD3D9::GetFirstChildD3D9()
72995: {
72995:   if (!mFirstChild) {
72995:     return nsnull;
72995:   }
72995:   return static_cast<LayerD3D9*>(mFirstChild->ImplData());
72995: }
72995: 
72995: void
72995: ContainerLayerD3D9::RenderLayer()
72995: {
72995:   ContainerRender(this, mD3DManager);
72995: }
72995: 
53979: void
53979: ContainerLayerD3D9::LayerManagerDestroyed()
53979: {
53979:   while (mFirstChild) {
53979:     GetFirstChildD3D9()->LayerManagerDestroyed();
53979:     RemoveChild(mFirstChild);
53979:   }
53979: }
53979: 
72995: ShadowContainerLayerD3D9::ShadowContainerLayerD3D9(LayerManagerD3D9 *aManager)
72995:   : ShadowContainerLayer(aManager, NULL)
72995:   , LayerD3D9(aManager)
72995: {
72995:   mImplData = static_cast<LayerD3D9*>(this);
72995: }
72995:  
72995: ShadowContainerLayerD3D9::~ShadowContainerLayerD3D9()
72995: {
72995:   Destroy();
72995: }
72995: 
72995: void
72995: ShadowContainerLayerD3D9::InsertAfter(Layer* aChild, Layer* aAfter)
72995: {
72995:   ContainerInsertAfter(this, aChild, aAfter);
72995: }
72995: 
72995: void
72995: ShadowContainerLayerD3D9::RemoveChild(Layer *aChild)
72995: {
72995:   ContainerRemoveChild(this, aChild);
72995: }
72995: 
72995: void
72995: ShadowContainerLayerD3D9::Destroy()
72995: {
72995:   while (mFirstChild) {
72995:     RemoveChild(mFirstChild);
72995:   }
72995: }
72995: 
72995: LayerD3D9*
72995: ShadowContainerLayerD3D9::GetFirstChildD3D9()
72995: {
72995:   if (!mFirstChild) {
72995:     return nsnull;
72995:    }
72995:   return static_cast<LayerD3D9*>(mFirstChild->ImplData());
72995: }
72995:  
72995: void
72995: ShadowContainerLayerD3D9::RenderLayer()
72995: {
72995:   ContainerRender(this, mD3DManager);
72995: }
72995: 
42611: } /* layers */
42611: } /* mozilla */
