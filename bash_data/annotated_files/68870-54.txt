    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Original Author: Daniel Glazman <glazman@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsHTMLEditor.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsHTMLEditUtils.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPrefService.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsEditProperty.h"
    1: #include "ChangeCSSInlineStyleTxn.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMElementCSSInlineStyle.h"
    1: #include "nsIDOMDocument.h"
68870: #include "nsIDOMDocumentView.h"
    1: #include "nsIContent.h"
    1: #include "nsIAtom.h"
    1: #include "nsTextEditUtils.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsHTMLCSSUtils.h"
    1: #include "nsColor.h"
    1: #include "nsAttrName.h"
 3030: #include "nsAutoPtr.h"
    1: 
    1: static
    1: void ProcessBValue(const nsAString * aInputString, nsAString & aOutputString,
    1:                    const char * aDefaultValueString,
    1:                    const char * aPrependString, const char* aAppendString)
    1: {
    1:   if (aInputString && aInputString->EqualsLiteral("-moz-editor-invert-value")) {
    1:       aOutputString.AssignLiteral("normal");
    1:   }
    1:   else {
    1:     aOutputString.AssignLiteral("bold");
    1:   }
    1: }
    1: 
    1: static
    1: void ProcessDefaultValue(const nsAString * aInputString, nsAString & aOutputString,
    1:                          const char * aDefaultValueString,
    1:                          const char * aPrependString, const char* aAppendString)
    1: {
    1:   CopyASCIItoUTF16(aDefaultValueString, aOutputString);
    1: }
    1: 
    1: static
    1: void ProcessSameValue(const nsAString * aInputString, nsAString & aOutputString,
    1:                       const char * aDefaultValueString,
    1:                       const char * aPrependString, const char* aAppendString)
    1: {
    1:   if (aInputString) {
    1:     aOutputString.Assign(*aInputString);
    1:   }
    1:   else
    1:     aOutputString.Truncate();
    1: }
    1: 
    1: static
    1: void ProcessExtendedValue(const nsAString * aInputString, nsAString & aOutputString,
    1:                           const char * aDefaultValueString,
    1:                           const char * aPrependString, const char* aAppendString)
    1: {
    1:   aOutputString.Truncate();
    1:   if (aInputString) {
    1:     if (aPrependString) {
    1:       AppendASCIItoUTF16(aPrependString, aOutputString);
    1:     }
    1:     aOutputString.Append(*aInputString);
    1:     if (aAppendString) {
    1:       AppendASCIItoUTF16(aAppendString, aOutputString);
    1:     }
    1:   }
    1: }
    1: 
    1: static
    1: void ProcessLengthValue(const nsAString * aInputString, nsAString & aOutputString,
    1:                         const char * aDefaultValueString,
    1:                         const char * aPrependString, const char* aAppendString)
    1: {
    1:   aOutputString.Truncate();
    1:   if (aInputString) {
    1:     aOutputString.Append(*aInputString);
    1:     if (-1 == aOutputString.FindChar(PRUnichar('%'))) {
    1:       aOutputString.AppendLiteral("px");
    1:     }
    1:   }
    1: }
    1: 
    1: static
    1: void ProcessListStyleTypeValue(const nsAString * aInputString, nsAString & aOutputString,
    1:                                const char * aDefaultValueString,
    1:                                const char * aPrependString, const char* aAppendString)
    1: {
    1:   aOutputString.Truncate();
    1:   if (aInputString) {
    1:     if (aInputString->EqualsLiteral("1")) {
    1:       aOutputString.AppendLiteral("decimal");
    1:     }
    1:     else if (aInputString->EqualsLiteral("a")) {
    1:       aOutputString.AppendLiteral("lower-alpha");
    1:     }
    1:     else if (aInputString->EqualsLiteral("A")) {
    1:       aOutputString.AppendLiteral("upper-alpha");
    1:     }
    1:     else if (aInputString->EqualsLiteral("i")) {
    1:       aOutputString.AppendLiteral("lower-roman");
    1:     }
    1:     else if (aInputString->EqualsLiteral("I")) {
    1:       aOutputString.AppendLiteral("upper-roman");
    1:     }
    1:     else if (aInputString->EqualsLiteral("square")
    1:              || aInputString->EqualsLiteral("circle")
    1:              || aInputString->EqualsLiteral("disc")) {
    1:       aOutputString.Append(*aInputString);
    1:     }
    1:   }
    1: }
    1: 
    1: static
    1: void ProcessMarginLeftValue(const nsAString * aInputString, nsAString & aOutputString,
    1:                             const char * aDefaultValueString,
    1:                             const char * aPrependString, const char* aAppendString)
    1: {
    1:   aOutputString.Truncate();
    1:   if (aInputString) {
    1:     if (aInputString->EqualsLiteral("center") ||
    1:         aInputString->EqualsLiteral("-moz-center")) {
    1:       aOutputString.AppendLiteral("auto"); 
    1:     }
    1:     else if (aInputString->EqualsLiteral("right") ||
    1:              aInputString->EqualsLiteral("-moz-right")) {
    1:       aOutputString.AppendLiteral("auto"); 
    1:     }
    1:     else {
    1:       aOutputString.AppendLiteral("0px"); 
    1:     }
    1:   }
    1: }
    1: 
    1: static
    1: void ProcessMarginRightValue(const nsAString * aInputString, nsAString & aOutputString,
    1:                              const char * aDefaultValueString,
    1:                              const char * aPrependString, const char* aAppendString)
    1: {
    1:   aOutputString.Truncate();
    1:   if (aInputString) {
    1:     if (aInputString->EqualsLiteral("center") ||
    1:         aInputString->EqualsLiteral("-moz-center")) {
    1:       aOutputString.AppendLiteral("auto"); 
    1:     }
    1:     else if (aInputString->EqualsLiteral("left") ||
    1:              aInputString->EqualsLiteral("-moz-left")) {
    1:       aOutputString.AppendLiteral("auto"); 
    1:     }
    1:     else {
    1:       aOutputString.AppendLiteral("0px"); 
    1:     }
    1:   }
    1: }
    1: 
    1: const nsHTMLCSSUtils::CSSEquivTable boldEquivTable[] = {
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_font_weight, ProcessBValue, nsnull, nsnull, nsnull, PR_TRUE, PR_FALSE },
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_NONE, 0 }
    1: };
    1: 
    1: const nsHTMLCSSUtils::CSSEquivTable italicEquivTable[] = {
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_font_style, ProcessDefaultValue, "italic", nsnull, nsnull, PR_TRUE, PR_FALSE },
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_NONE, 0 }
    1: };
    1: 
    1: const nsHTMLCSSUtils::CSSEquivTable underlineEquivTable[] = {
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_text_decoration, ProcessDefaultValue, "underline", nsnull, nsnull, PR_TRUE, PR_FALSE },
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_NONE, 0 }
    1: };
    1: 
    1: const nsHTMLCSSUtils::CSSEquivTable strikeEquivTable[] = {
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_text_decoration, ProcessDefaultValue, "line-through", nsnull, nsnull, PR_TRUE, PR_FALSE },
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_NONE, 0 }
    1: };
    1: 
    1: const nsHTMLCSSUtils::CSSEquivTable ttEquivTable[] = {
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_font_family, ProcessDefaultValue, "monospace", nsnull, nsnull, PR_TRUE, PR_FALSE },
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_NONE, 0 }
    1: };
    1: 
    1: const nsHTMLCSSUtils::CSSEquivTable fontColorEquivTable[] = {
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_color, ProcessSameValue, nsnull, nsnull, nsnull, PR_TRUE, PR_FALSE },
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_NONE, 0 }
    1: };
    1: 
    1: const nsHTMLCSSUtils::CSSEquivTable fontFaceEquivTable[] = {
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_font_family, ProcessSameValue, nsnull, nsnull, nsnull, PR_TRUE, PR_FALSE },
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_NONE, 0 }
    1: };
    1: 
    1: const nsHTMLCSSUtils::CSSEquivTable bgcolorEquivTable[] = {
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_background_color, ProcessSameValue, nsnull, nsnull, nsnull, PR_TRUE, PR_FALSE },
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_NONE, 0 }
    1: };
    1: 
    1: const nsHTMLCSSUtils::CSSEquivTable backgroundImageEquivTable[] = {
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_background_image, ProcessExtendedValue, nsnull, "url(", ")", PR_TRUE, PR_TRUE },
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_NONE, 0 }
    1: };
    1: 
    1: const nsHTMLCSSUtils::CSSEquivTable textColorEquivTable[] = {
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_color, ProcessSameValue, nsnull, nsnull, nsnull, PR_TRUE, PR_FALSE },
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_NONE, 0 }
    1: };
    1: 
    1: const nsHTMLCSSUtils::CSSEquivTable borderEquivTable[] = {
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_border, ProcessExtendedValue, nsnull, nsnull, "px solid", PR_TRUE, PR_FALSE },
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_NONE, 0 }
    1: };
    1: 
    1: const nsHTMLCSSUtils::CSSEquivTable textAlignEquivTable[] = {
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_text_align, ProcessSameValue, nsnull, nsnull, nsnull, PR_TRUE, PR_FALSE },
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_NONE, 0 }
    1: };
    1: 
    1: const nsHTMLCSSUtils::CSSEquivTable captionAlignEquivTable[] = {
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_caption_side, ProcessSameValue, nsnull, nsnull, nsnull, PR_TRUE, PR_FALSE },
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_NONE, 0 }
    1: };
    1: 
    1: const nsHTMLCSSUtils::CSSEquivTable verticalAlignEquivTable[] = {
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_vertical_align, ProcessSameValue, nsnull, nsnull, nsnull, PR_TRUE, PR_FALSE },
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_NONE, 0 }
    1: };
    1: 
    1: const nsHTMLCSSUtils::CSSEquivTable nowrapEquivTable[] = {
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_whitespace, ProcessDefaultValue, "nowrap", nsnull, nsnull, PR_TRUE, PR_FALSE },
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_NONE, 0 }
    1: };
    1: 
    1: const nsHTMLCSSUtils::CSSEquivTable widthEquivTable[] = {
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_width, ProcessLengthValue, nsnull, nsnull, nsnull, PR_TRUE, PR_FALSE },
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_NONE, 0 }
    1: };
    1: 
    1: const nsHTMLCSSUtils::CSSEquivTable heightEquivTable[] = {
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_height, ProcessLengthValue, nsnull, nsnull, nsnull, PR_TRUE, PR_FALSE },
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_NONE, 0 }
    1: };
    1: 
    1: const nsHTMLCSSUtils::CSSEquivTable listStyleTypeEquivTable[] = {
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_list_style_type, ProcessListStyleTypeValue, nsnull, nsnull, nsnull, PR_TRUE, PR_TRUE },
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_NONE, 0 }
    1: };
    1: 
    1: const nsHTMLCSSUtils::CSSEquivTable tableAlignEquivTable[] = {
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_text_align, ProcessDefaultValue, "left", nsnull, nsnull, PR_FALSE, PR_FALSE },
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_margin_left, ProcessMarginLeftValue, nsnull, nsnull, nsnull, PR_TRUE, PR_FALSE },
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_margin_right, ProcessMarginRightValue, nsnull, nsnull, nsnull, PR_TRUE, PR_FALSE },
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_NONE, 0 }
    1: };
    1: 
    1: const nsHTMLCSSUtils::CSSEquivTable hrAlignEquivTable[] = {
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_margin_left, ProcessMarginLeftValue, nsnull, nsnull, nsnull, PR_TRUE, PR_FALSE },
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_margin_right, ProcessMarginRightValue, nsnull, nsnull, nsnull, PR_TRUE, PR_FALSE },
    1:   { nsHTMLCSSUtils::eCSSEditableProperty_NONE, 0 }
    1: };
    1: 
    1: nsHTMLCSSUtils::nsHTMLCSSUtils()
    1: : mIsCSSPrefChecked(PR_FALSE)
    1: {
    1: }
    1: 
    1: nsHTMLCSSUtils::~nsHTMLCSSUtils()
    1: {
    1: }
    1: 
    1: nsresult
    1: nsHTMLCSSUtils::Init(nsHTMLEditor *aEditor)
    1: {
    1:   nsresult result = NS_OK;
 3233:   mHTMLEditor = static_cast<nsHTMLEditor*>(aEditor);
    1: 
    1:   // let's retrieve the value of the "CSS editing" pref
    1:   nsCOMPtr<nsIPrefBranch> prefBranch =
    1:     do_GetService(NS_PREFSERVICE_CONTRACTID, &result);
    1:   if (NS_SUCCEEDED(result) && prefBranch) {
    1:     result = prefBranch->GetBoolPref("editor.use_css", &mIsCSSPrefChecked);
43805:     NS_ENSURE_SUCCESS(result, result);
    1:   }
    1:   return result;
    1: }
    1: 
    1: // Answers true if we have some CSS equivalence for the HTML style defined
    1: // by aProperty and/or aAttribute for the node aNode
    1: PRBool
    1: nsHTMLCSSUtils::IsCSSEditableProperty(nsIDOMNode * aNode,
    1:                                       nsIAtom * aProperty,
    1:                                       const nsAString * aAttribute)
    1: {
    1:   NS_ASSERTION(aNode, "Shouldn't you pass aNode? - Bug 214025");
    1: 
    1:   nsCOMPtr<nsIDOMNode> node = aNode;
    1:   // we need an element node here
    1:   if (mHTMLEditor->IsTextNode(aNode)) {
    1:     aNode->GetParentNode(getter_AddRefs(node));
    1:   }
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(node);
43806:   NS_ENSURE_TRUE(content, PR_FALSE);
    1: 
    1:   nsIAtom *tagName = content->Tag();
    1:   // brade: should the above use nsEditor::GetTag(aNode)?
    1:   // brade: shouldn't some of the above go below the next block?
    1: 
    1:   // html inline styles B I TT U STRIKE and COLOR/FACE on FONT
    1:   if (nsEditProperty::b == aProperty
    1:       || nsEditProperty::i == aProperty
    1:       || nsEditProperty::tt == aProperty
    1:       || nsEditProperty::u == aProperty
    1:       || nsEditProperty::strike == aProperty
    1:       || ((nsEditProperty::font == aProperty) && aAttribute &&
    1:            (aAttribute->EqualsLiteral("color") ||
    1:             aAttribute->EqualsLiteral("face")))) {
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   // ALIGN attribute on elements supporting it
    1:   if (aAttribute && (aAttribute->EqualsLiteral("align")) &&
    1:       (nsEditProperty::div == tagName
    1:        || nsEditProperty::p   == tagName
    1:        || nsEditProperty::h1  == tagName
    1:        || nsEditProperty::h2  == tagName
    1:        || nsEditProperty::h3  == tagName
    1:        || nsEditProperty::h4  == tagName
    1:        || nsEditProperty::h5  == tagName
    1:        || nsEditProperty::h6  == tagName
    1:        || nsEditProperty::td  == tagName
    1:        || nsEditProperty::th  == tagName
    1:        || nsEditProperty::table  == tagName
    1:        || nsEditProperty::hr  == tagName
    1:        // brade: for the above, why not use nsHTMLEditUtils::SupportsAlignAttr
    1:        // brade: but it also checks for tbody, tfoot, thead
    1:        // Let's add the following elements here even if ALIGN has not
    1:        // the same meaning for them
    1:        || nsEditProperty::legend  == tagName
    1:        || nsEditProperty::caption == tagName)) {
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   if (aAttribute && (aAttribute->EqualsLiteral("valign")) &&
    1:       (nsEditProperty::col == tagName
    1:        || nsEditProperty::colgroup   == tagName
    1:        || nsEditProperty::tbody  == tagName
    1:        || nsEditProperty::td  == tagName
    1:        || nsEditProperty::th  == tagName
    1:        || nsEditProperty::tfoot  == tagName
    1:        || nsEditProperty::thead  == tagName
    1:        || nsEditProperty::tr  == tagName)) {
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   // attributes TEXT, BACKGROUND and BGCOLOR on BODY
    1:   if (aAttribute && (nsEditProperty::body == tagName) &&
    1:       (aAttribute->EqualsLiteral("text")
    1:        || aAttribute->EqualsLiteral("background")
    1:        || aAttribute->EqualsLiteral("bgcolor"))) {
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   // attribute BGCOLOR on other elements
    1:   if (aAttribute && aAttribute->EqualsLiteral("bgcolor")) {
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   // attributes HEIGHT, WIDTH and NOWRAP on TD and TH
    1:   if (aAttribute && ((nsEditProperty::td == tagName)
    1:                       || (nsEditProperty::th == tagName)) &&
    1:       (aAttribute->EqualsLiteral("height")
    1:        || aAttribute->EqualsLiteral("width")
    1:        || aAttribute->EqualsLiteral("nowrap"))) {
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   // attributes HEIGHT and WIDTH on TABLE
    1:   if (aAttribute && (nsEditProperty::table == tagName) &&
    1:       (aAttribute->EqualsLiteral("height")
    1:        || aAttribute->EqualsLiteral("width"))) {
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   // attributes SIZE and WIDTH on HR
    1:   if (aAttribute && (nsEditProperty::hr == tagName) &&
    1:       (aAttribute->EqualsLiteral("size")
    1:        || aAttribute->EqualsLiteral("width"))) {
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   // attribute TYPE on OL UL LI
    1:   if (aAttribute && (nsEditProperty::ol == tagName
    1:                      || nsEditProperty::ul == tagName
    1:                      || nsEditProperty::li == tagName) &&
    1:       aAttribute->EqualsLiteral("type")) {
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   if (aAttribute && nsEditProperty::img == tagName &&
    1:       (aAttribute->EqualsLiteral("border")
    1:        || aAttribute->EqualsLiteral("width")
    1:        || aAttribute->EqualsLiteral("height"))) {
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   // other elements that we can align using CSS even if they
    1:   // can't carry the html ALIGN attribute
    1:   if (aAttribute && aAttribute->EqualsLiteral("align") &&
    1:       (nsEditProperty::ul == tagName
    1:        || nsEditProperty::ol == tagName
    1:        || nsEditProperty::dl == tagName
    1:        || nsEditProperty::li == tagName
    1:        || nsEditProperty::dd == tagName
    1:        || nsEditProperty::dt == tagName
    1:        || nsEditProperty::address == tagName
    1:        || nsEditProperty::pre == tagName
    1:        || nsEditProperty::ul == tagName)) {
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: // the lowest level above the transaction; adds the css declaration "aProperty : aValue" to
    1: // the inline styles carried by aElement
    1: nsresult
    1: nsHTMLCSSUtils::SetCSSProperty(nsIDOMElement *aElement, nsIAtom * aProperty, const nsAString & aValue,
    1:                                PRBool aSuppressTransaction)
    1: {
 3030:   nsRefPtr<ChangeCSSInlineStyleTxn> txn;
 3030:   nsresult result = CreateCSSPropertyTxn(aElement, aProperty, aValue,
 3030:                                          getter_AddRefs(txn), PR_FALSE);
    1:   if (NS_SUCCEEDED(result))  {
    1:     if (aSuppressTransaction) {
    1:       result = txn->DoTransaction();
    1:     }
    1:     else {
    1:       result = mHTMLEditor->DoTransaction(txn);
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: nsresult
    1: nsHTMLCSSUtils::SetCSSPropertyPixels(nsIDOMElement *aElement,
    1:                                      nsIAtom *aProperty,
    1:                                      PRInt32 aIntValue,
    1:                                      PRBool aSuppressTransaction)
    1: {
    1:   nsAutoString s;
    1:   s.AppendInt(aIntValue);
    1:   return SetCSSProperty(aElement, aProperty, s + NS_LITERAL_STRING("px"),
    1:                         aSuppressTransaction);
    1: }
    1: 
    1: // the lowest level above the transaction; removes the value aValue from the list of values
    1: // specified for the CSS property aProperty, or totally remove the declaration if this
    1: // property accepts only one value
    1: nsresult
    1: nsHTMLCSSUtils::RemoveCSSProperty(nsIDOMElement *aElement, nsIAtom * aProperty, const nsAString & aValue,
    1:                                   PRBool aSuppressTransaction)
    1: {
 3030:   nsRefPtr<ChangeCSSInlineStyleTxn> txn;
 3030:   nsresult result = CreateCSSPropertyTxn(aElement, aProperty, aValue,
 3030:                                          getter_AddRefs(txn), PR_TRUE);
    1:   if (NS_SUCCEEDED(result))  {
    1:     if (aSuppressTransaction) {
    1:       result = txn->DoTransaction();
    1:     }
    1:     else {
    1:       result = mHTMLEditor->DoTransaction(txn);
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: nsresult 
    1: nsHTMLCSSUtils::CreateCSSPropertyTxn(nsIDOMElement *aElement, 
    1:                                      nsIAtom * aAttribute,
    1:                                      const nsAString& aValue,
    1:                                      ChangeCSSInlineStyleTxn ** aTxn,
    1:                                      PRBool aRemoveProperty)
    1: {
43807:   NS_ENSURE_TRUE(aElement, NS_ERROR_NULL_POINTER);
27825: 
27825:   *aTxn = new ChangeCSSInlineStyleTxn();
43807:   NS_ENSURE_TRUE(*aTxn, NS_ERROR_OUT_OF_MEMORY);
27825:   NS_ADDREF(*aTxn);
27825:   return (*aTxn)->Init(mHTMLEditor, aElement, aAttribute, aValue, aRemoveProperty);
    1: }
    1: 
    1: nsresult
    1: nsHTMLCSSUtils::GetSpecifiedProperty(nsIDOMNode *aNode, nsIAtom *aProperty,
    1:                                      nsAString & aValue)
    1: {
    1:   return GetCSSInlinePropertyBase(aNode, aProperty, aValue, nsnull, SPECIFIED_STYLE_TYPE);
    1: }
    1: 
    1: nsresult
    1: nsHTMLCSSUtils::GetComputedProperty(nsIDOMNode *aNode, nsIAtom *aProperty,
    1:                                     nsAString & aValue)
    1: {
68870:   nsCOMPtr<nsIDOMViewCSS> viewCSS = nsnull;
68870:   nsresult res = GetDefaultViewCSS(aNode, getter_AddRefs(viewCSS));
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
68870:   return GetCSSInlinePropertyBase(aNode, aProperty, aValue, viewCSS, COMPUTED_STYLE_TYPE);
    1: }
    1: 
    1: nsresult
    1: nsHTMLCSSUtils::GetCSSInlinePropertyBase(nsIDOMNode *aNode, nsIAtom *aProperty,
    1:                                         nsAString &aValue,
68870:                                         nsIDOMViewCSS *aViewCSS,
    1:                                         PRUint8 aStyleType)
    1: {
    1:   aValue.Truncate();
    1:   NS_ENSURE_TRUE(aProperty, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsCOMPtr<nsIDOMElement>element;
    1:   nsresult res = GetElementContainerOrSelf(aNode, getter_AddRefs(element));
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   switch (aStyleType) {
    1:     case COMPUTED_STYLE_TYPE:
68870:       if (element && aViewCSS) {
    1:         nsAutoString value, propString;
    1:         nsCOMPtr<nsIDOMCSSStyleDeclaration> cssDecl;
    1:         aProperty->ToString(propString);
    1:         // Get the all the computed css styles attached to the element node
68870:         res = aViewCSS->GetComputedStyle(element, EmptyString(), getter_AddRefs(cssDecl));
68870:         if (NS_FAILED(res) || !cssDecl) return res;
    1:         // from these declarations, get the one we want and that one only
    1:         res = cssDecl->GetPropertyValue(propString, value);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         aValue.Assign(value);
    1:       }
    1:       break;
    1:     case SPECIFIED_STYLE_TYPE:
    1:       if (element) {
    1:         nsCOMPtr<nsIDOMCSSStyleDeclaration> cssDecl;
    1:         PRUint32 length;
    1:         res = GetInlineStyles(element, getter_AddRefs(cssDecl), &length);
    1:         if (NS_FAILED(res) || !cssDecl) return res;
    1:         nsAutoString value, propString;
    1:         aProperty->ToString(propString);
    1:         res = cssDecl->GetPropertyValue(propString, value);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         aValue.Assign(value);
    1:       }
    1:       break;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
68870: nsHTMLCSSUtils::GetDefaultViewCSS(nsIDOMNode *aNode, nsIDOMViewCSS **aViewCSS)
    1: {
    1:   nsCOMPtr<nsIDOMElement>element;
    1:   nsresult res = GetElementContainerOrSelf(aNode, getter_AddRefs(element));
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
68870:   // if we have an element node
68870:   if (element) {
    1:     // find the owner document
    1:     nsCOMPtr<nsIDOMDocument> doc;
    1:     nsCOMPtr<nsIDOMNode> node = do_QueryInterface(element);
    1:     res = node->GetOwnerDocument(getter_AddRefs(doc));
43805:     NS_ENSURE_SUCCESS(res, res);
68870:     if (doc) {
68870:       nsCOMPtr<nsIDOMDocumentView> documentView = do_QueryInterface(doc);
68870:       nsCOMPtr<nsIDOMAbstractView> abstractView;
68870:       // from the document, get the abtractView
68870:       res = documentView->GetDefaultView(getter_AddRefs(abstractView));
68870:       NS_ENSURE_SUCCESS(res, res);
68870:       if (abstractView) {
68870:         // from the abstractView, get the CSS view
68870:         CallQueryInterface(abstractView, aViewCSS);
    1:         return NS_OK;
    1:       }
68870:     }
68870:   }
68870:   *aViewCSS = nsnull;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: NS_NewHTMLCSSUtils(nsHTMLCSSUtils** aInstancePtrResult)
    1: {
    1:   nsHTMLCSSUtils * rules = new nsHTMLCSSUtils();
    1:   if (rules) {
    1:     *aInstancePtrResult = rules;
    1:     return NS_OK;
    1:   }
    1: 
    1:   *aInstancePtrResult = nsnull;
    1:   return NS_ERROR_OUT_OF_MEMORY;
    1: }
    1: 
    1: // remove the CSS style "aProperty : aPropertyValue" and possibly remove the whole node
    1: // if it is a span and if its only attribute is _moz_dirty
    1: nsresult
    1: nsHTMLCSSUtils::RemoveCSSInlineStyle(nsIDOMNode *aNode, nsIAtom *aProperty, const nsAString & aPropertyValue)
    1: {
    1:   nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(aNode);
    1: 
    1:   // remove the property from the style attribute
    1:   nsresult res = RemoveCSSProperty(elem, aProperty, aPropertyValue, PR_FALSE);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   if (nsEditor::NodeIsType(aNode, nsEditProperty::span)) {
    1:     nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
    1:     PRUint32 attrCount = content->GetAttrCount();
    1: 
    1:     if (0 == attrCount) {
    1:       // no more attributes on this span, let's remove the element
    1:       res = mHTMLEditor->RemoveContainer(aNode);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     else if (1 == attrCount) {
    1:       // incredible hack in case the only remaining attribute is a _moz_dirty...
    1:       if (content->GetAttrNameAt(0)->Equals(nsEditProperty::mozdirty)) {
    1:         res = mHTMLEditor->RemoveContainer(aNode);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // Answers true is the property can be removed by setting a "none" CSS value
    1: // on a node
    1: PRBool
    1: nsHTMLCSSUtils::IsCSSInvertable(nsIAtom *aProperty, const nsAString *aAttribute)
    1: {
    1:   return PRBool(nsEditProperty::b == aProperty);
    1: }
    1: 
    1: // Get the default browser background color if we need it for GetCSSBackgroundColorState
    1: nsresult
    1: nsHTMLCSSUtils::GetDefaultBackgroundColor(nsAString & aColor)
    1: {
    1:   nsresult result;
    1:   nsCOMPtr<nsIPrefBranch> prefBranch =
    1:     do_GetService(NS_PREFSERVICE_CONTRACTID, &result);
43805:   NS_ENSURE_SUCCESS(result, result);
    1:   aColor.AssignLiteral("#ffffff");
    1:   nsXPIDLCString returnColor;
    1:   if (prefBranch) {
    1:     PRBool useCustomColors;
    1:     result = prefBranch->GetBoolPref("editor.use_custom_colors", &useCustomColors);
43805:     NS_ENSURE_SUCCESS(result, result);
    1:     if (useCustomColors) {
    1:       result = prefBranch->GetCharPref("editor.background_color",
    1:                                        getter_Copies(returnColor));
43805:       NS_ENSURE_SUCCESS(result, result);
    1:     }
    1:     else {
    1:       PRBool useSystemColors;
    1:       result = prefBranch->GetBoolPref("browser.display.use_system_colors", &useSystemColors);
43805:       NS_ENSURE_SUCCESS(result, result);
    1:       if (!useSystemColors) {
    1:         result = prefBranch->GetCharPref("browser.display.background_color",
    1:                                          getter_Copies(returnColor));
43805:         NS_ENSURE_SUCCESS(result, result);
    1:       }
    1:     }
    1:   }
    1:   if (returnColor) {
    1:     CopyASCIItoUTF16(returnColor, aColor);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // Get the default length unit used for CSS Indent/Outdent
    1: nsresult
    1: nsHTMLCSSUtils::GetDefaultLengthUnit(nsAString & aLengthUnit)
    1: {
    1:   nsresult result;
    1:   nsCOMPtr<nsIPrefBranch> prefBranch =
    1:     do_GetService(NS_PREFSERVICE_CONTRACTID, &result);
43805:   NS_ENSURE_SUCCESS(result, result);
    1:   aLengthUnit.AssignLiteral("px");
    1:   if (NS_SUCCEEDED(result) && prefBranch) {
    1:     nsXPIDLCString returnLengthUnit;
    1:     result = prefBranch->GetCharPref("editor.css.default_length_unit",
    1:                                      getter_Copies(returnLengthUnit));
43805:     NS_ENSURE_SUCCESS(result, result);
    1:     if (returnLengthUnit) {
    1:       CopyASCIItoUTF16(returnLengthUnit, aLengthUnit);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // Unfortunately, CSSStyleDeclaration::GetPropertyCSSValue is not yet implemented...
    1: // We need then a way to determine the number part and the unit from aString, aString
    1: // being the result of a GetPropertyValue query...
    1: void
    1: nsHTMLCSSUtils::ParseLength(const nsAString & aString, float * aValue, nsIAtom ** aUnit)
    1: {
    1:   nsAString::const_iterator iter;
    1:   aString.BeginReading(iter);
    1: 
    1:   float a = 10.0f , b = 1.0f, value = 0;
    1:   PRInt8 sign = 1;
    1:   PRInt32 i = 0, j = aString.Length();
    1:   PRUnichar c;
    1:   PRBool floatingPointFound = PR_FALSE;
    1:   c = *iter;
    1:   if (PRUnichar('-') == c) { sign = -1; iter++; i++; }
    1:   else if (PRUnichar('+') == c) { iter++; i++; }
    1:   while (i < j) {
    1:     c = *iter;
    1:     if ((PRUnichar('0') == c) ||
    1:         (PRUnichar('1') == c) ||
    1:         (PRUnichar('2') == c) ||
    1:         (PRUnichar('3') == c) ||
    1:         (PRUnichar('4') == c) ||
    1:         (PRUnichar('5') == c) ||
    1:         (PRUnichar('6') == c) ||
    1:         (PRUnichar('7') == c) ||
    1:         (PRUnichar('8') == c) ||
    1:         (PRUnichar('9') == c)) {
    1:       value = (value * a) + (b * (c - PRUnichar('0')));
    1:       b = b / 10 * a;
    1:     }
    1:     else if (!floatingPointFound && (PRUnichar('.') == c)) {
    1:       floatingPointFound = PR_TRUE;
    1:       a = 1.0f; b = 0.1f;
    1:     }
    1:     else break;
    1:     iter++;
    1:     i++;
    1:   }
    1:   *aValue = value * sign;
43337:   *aUnit = NS_NewAtom(StringTail(aString, j-i)); 
    1: }
    1: 
    1: void
    1: nsHTMLCSSUtils::GetCSSPropertyAtom(nsCSSEditableProperty aProperty, nsIAtom ** aAtom)
    1: {
    1:   *aAtom = nsnull;
    1:   switch (aProperty) {
    1:     case eCSSEditableProperty_background_color:
    1:       *aAtom = nsEditProperty::cssBackgroundColor;
    1:       break;
    1:     case eCSSEditableProperty_background_image:
    1:       *aAtom = nsEditProperty::cssBackgroundImage;
    1:       break;
    1:     case eCSSEditableProperty_border:
    1:       *aAtom = nsEditProperty::cssBorder;
    1:       break;
    1:     case eCSSEditableProperty_caption_side:
    1:       *aAtom = nsEditProperty::cssCaptionSide;
    1:       break;
    1:     case eCSSEditableProperty_color:
    1:       *aAtom = nsEditProperty::cssColor;
    1:       break;
    1:     case eCSSEditableProperty_float:
    1:       *aAtom = nsEditProperty::cssFloat;
    1:       break;
    1:     case eCSSEditableProperty_font_family:
    1:       *aAtom = nsEditProperty::cssFontFamily;
    1:       break;
    1:     case eCSSEditableProperty_font_size:
    1:       *aAtom = nsEditProperty::cssFontSize;
    1:       break;
    1:     case eCSSEditableProperty_font_style:
    1:       *aAtom = nsEditProperty::cssFontStyle;
    1:       break;
    1:     case eCSSEditableProperty_font_weight:
    1:       *aAtom = nsEditProperty::cssFontWeight;
    1:       break;
    1:     case eCSSEditableProperty_height:
    1:       *aAtom = nsEditProperty::cssHeight;
    1:       break;
    1:     case eCSSEditableProperty_list_style_type:
    1:       *aAtom = nsEditProperty::cssListStyleType;
    1:       break;
    1:     case eCSSEditableProperty_margin_left:
    1:       *aAtom = nsEditProperty::cssMarginLeft;
    1:       break;
    1:     case eCSSEditableProperty_margin_right:
    1:       *aAtom = nsEditProperty::cssMarginRight;
    1:       break;
    1:     case eCSSEditableProperty_text_align:
    1:       *aAtom = nsEditProperty::cssTextAlign;
    1:       break;
    1:     case eCSSEditableProperty_text_decoration:
    1:       *aAtom = nsEditProperty::cssTextDecoration;
    1:       break;
    1:     case eCSSEditableProperty_vertical_align:
    1:       *aAtom = nsEditProperty::cssVerticalAlign;
    1:       break;
    1:     case eCSSEditableProperty_whitespace:
    1:       *aAtom = nsEditProperty::cssWhitespace;
    1:       break;
    1:     case eCSSEditableProperty_width:
    1:       *aAtom = nsEditProperty::cssWidth;
    1:       break;
25181:     case eCSSEditableProperty_NONE:
25181:       // intentionally empty
25181:       break;
    1:   }
    1: }
    1: 
    1: // Populate aProperty and aValueArray with the CSS declarations equivalent to the
    1: // value aValue according to the equivalence table aEquivTable
    1: void
27986: nsHTMLCSSUtils::BuildCSSDeclarations(nsTArray<nsIAtom*> & aPropertyArray,
23904:                                      nsTArray<nsString> & aValueArray,
    1:                                      const CSSEquivTable * aEquivTable,
    1:                                      const nsAString * aValue,
    1:                                      PRBool aGetOrRemoveRequest)
    1: {
    1:   // clear arrays
    1:   aPropertyArray.Clear();
    1:   aValueArray.Clear();
    1: 
    1:   // if we have an input value, let's use it
    1:   nsAutoString value, lowerCasedValue;
    1:   if (aValue) {
    1:     value.Assign(*aValue);
    1:     lowerCasedValue.Assign(*aValue);
    1:     ToLowerCase(lowerCasedValue);
    1:   }
    1: 
    1:   PRInt8 index = 0;
    1:   nsCSSEditableProperty cssProperty = aEquivTable[index].cssProperty;
    1:   while (cssProperty) {
    1:     if (!aGetOrRemoveRequest|| aEquivTable[index].gettable) {
    1:       nsAutoString cssValue, cssPropertyString;
    1:       nsIAtom * cssPropertyAtom;
    1:       // find the equivalent css value for the index-th property in
    1:       // the equivalence table
    1:       (*aEquivTable[index].processValueFunctor) ((!aGetOrRemoveRequest || aEquivTable[index].caseSensitiveValue) ? &value : &lowerCasedValue,
    1:                                                  cssValue,
    1:                                                  aEquivTable[index].defaultValue,
    1:                                                  aEquivTable[index].prependValue,
    1:                                                  aEquivTable[index].appendValue);
    1:       GetCSSPropertyAtom(cssProperty, &cssPropertyAtom);
    1:       aPropertyArray.AppendElement(cssPropertyAtom);
23904:       aValueArray.AppendElement(cssValue);
    1:     }
    1:     index++;
    1:     cssProperty = aEquivTable[index].cssProperty;
    1:   }
    1: }
    1: 
    1: // Populate cssPropertyArray and cssValueArray with the declarations equivalent
    1: // to aHTMLProperty/aAttribute/aValue for the node aNode
    1: void
    1: nsHTMLCSSUtils::GenerateCSSDeclarationsFromHTMLStyle(nsIDOMNode * aNode,
    1:                                                      nsIAtom *aHTMLProperty,
    1:                                                      const nsAString * aAttribute,
    1:                                                      const nsAString * aValue,
27986:                                                      nsTArray<nsIAtom*> & cssPropertyArray,
23904:                                                      nsTArray<nsString> & cssValueArray,
    1:                                                      PRBool aGetOrRemoveRequest)
    1: {
    1:   nsCOMPtr<nsIDOMNode> node = aNode;
    1:   if (mHTMLEditor->IsTextNode(aNode)) {
    1:     aNode->GetParentNode(getter_AddRefs(node));
    1:   }
    1:   if (!node) return;
    1: 
    1:   nsIAtom *tagName = nsEditor::GetTag(node);
    1: 
    1:   if (nsEditProperty::b == aHTMLProperty) {
    1:     BuildCSSDeclarations(cssPropertyArray, cssValueArray, boldEquivTable, aValue, aGetOrRemoveRequest);
    1:   }
    1:   else if (nsEditProperty::i == aHTMLProperty) {
    1:     BuildCSSDeclarations(cssPropertyArray, cssValueArray, italicEquivTable, aValue, aGetOrRemoveRequest);
    1:   }
    1:   else if (nsEditProperty::u == aHTMLProperty) {
    1:     BuildCSSDeclarations(cssPropertyArray, cssValueArray, underlineEquivTable, aValue, aGetOrRemoveRequest);
    1:   }
    1:   else if (nsEditProperty::strike == aHTMLProperty) {
    1:     BuildCSSDeclarations(cssPropertyArray, cssValueArray, strikeEquivTable, aValue, aGetOrRemoveRequest);
    1:   }
    1:   else if (nsEditProperty::tt == aHTMLProperty) {
    1:     BuildCSSDeclarations(cssPropertyArray, cssValueArray, ttEquivTable, aValue, aGetOrRemoveRequest);
    1:   }
    1:   else if (aAttribute) {
    1:     if (nsEditProperty::font == aHTMLProperty &&
    1:         aAttribute->EqualsLiteral("color")) {
    1:       BuildCSSDeclarations(cssPropertyArray, cssValueArray, fontColorEquivTable, aValue, aGetOrRemoveRequest);
    1:     }
    1:     else if (nsEditProperty::font == aHTMLProperty &&
    1:              aAttribute->EqualsLiteral("face")) {
    1:       BuildCSSDeclarations(cssPropertyArray, cssValueArray, fontFaceEquivTable, aValue, aGetOrRemoveRequest);
    1:     }
    1:     else if (aAttribute->EqualsLiteral("bgcolor")) {
    1:       BuildCSSDeclarations(cssPropertyArray, cssValueArray, bgcolorEquivTable, aValue, aGetOrRemoveRequest);
    1:     }
    1:     else if (aAttribute->EqualsLiteral("background")) {
    1:       BuildCSSDeclarations(cssPropertyArray, cssValueArray, backgroundImageEquivTable, aValue, aGetOrRemoveRequest);
    1:     }
    1:     else if (aAttribute->EqualsLiteral("text")) {
    1:       BuildCSSDeclarations(cssPropertyArray, cssValueArray, textColorEquivTable, aValue, aGetOrRemoveRequest);
    1:     }
    1:     else if (aAttribute->EqualsLiteral("border")) {
    1:       BuildCSSDeclarations(cssPropertyArray, cssValueArray, borderEquivTable, aValue, aGetOrRemoveRequest);
    1:     }
    1:     else if (aAttribute->EqualsLiteral("align")) {
    1:       if (nsEditProperty::table  == tagName) {
    1:         BuildCSSDeclarations(cssPropertyArray, cssValueArray, tableAlignEquivTable, aValue, aGetOrRemoveRequest);
    1:       }
    1:       else if (nsEditProperty::hr  == tagName) {
    1:         BuildCSSDeclarations(cssPropertyArray, cssValueArray, hrAlignEquivTable, aValue, aGetOrRemoveRequest);
    1:       }
    1:       else if (nsEditProperty::legend  == tagName ||
    1:                nsEditProperty::caption == tagName) {
    1:         BuildCSSDeclarations(cssPropertyArray, cssValueArray, captionAlignEquivTable, aValue, aGetOrRemoveRequest);
    1:       }
    1:       else {
    1:         BuildCSSDeclarations(cssPropertyArray, cssValueArray, textAlignEquivTable, aValue, aGetOrRemoveRequest);
    1:       }
    1:     }
    1:     else if (aAttribute->EqualsLiteral("valign")) {
    1:       BuildCSSDeclarations(cssPropertyArray, cssValueArray, verticalAlignEquivTable, aValue, aGetOrRemoveRequest);
    1:     }
    1:     else if (aAttribute->EqualsLiteral("nowrap")) {
    1:       BuildCSSDeclarations(cssPropertyArray, cssValueArray, nowrapEquivTable, aValue, aGetOrRemoveRequest);
    1:     }
    1:     else if (aAttribute->EqualsLiteral("width")) {
    1:       BuildCSSDeclarations(cssPropertyArray, cssValueArray, widthEquivTable, aValue, aGetOrRemoveRequest);
    1:     }
    1:     else if (aAttribute->EqualsLiteral("height") ||
    1:              (nsEditProperty::hr == tagName && aAttribute->EqualsLiteral("size"))) {
    1:       BuildCSSDeclarations(cssPropertyArray, cssValueArray, heightEquivTable, aValue, aGetOrRemoveRequest);
    1:     }
    1:     else if (aAttribute->EqualsLiteral("type") &&
    1:              (nsEditProperty::ol == tagName
    1:               || nsEditProperty::ul == tagName
    1:               || nsEditProperty::li == tagName)) {
    1:       BuildCSSDeclarations(cssPropertyArray, cssValueArray, listStyleTypeEquivTable, aValue, aGetOrRemoveRequest);
    1:     }
    1:   }
    1: }
    1: 
    1: // Add to aNode the CSS inline style equivalent to HTMLProperty/aAttribute/aValue for the node,
    1: // and return in aCount the number of CSS properties set by the call
    1: nsresult
    1: nsHTMLCSSUtils::SetCSSEquivalentToHTMLStyle(nsIDOMNode * aNode,
    1:                                             nsIAtom *aHTMLProperty,
    1:                                             const nsAString *aAttribute,
    1:                                             const nsAString *aValue,
    1:                                             PRInt32 * aCount,
    1:                                             PRBool aSuppressTransaction)
    1: {
    1:   nsCOMPtr<nsIDOMElement> theElement = do_QueryInterface(aNode);
    1:   nsresult res = NS_OK;
    1:   *aCount = 0;
    1:   if (theElement && IsCSSEditableProperty(aNode, aHTMLProperty, aAttribute)) {
    1:     // we can apply the styles only if the node is an element and if we have
    1:     // an equivalence for the requested HTML style in this implementation
    1: 
    1:     // Find the CSS equivalence to the HTML style
27986:     nsTArray<nsIAtom*> cssPropertyArray;
23904:     nsTArray<nsString> cssValueArray;
    1:     GenerateCSSDeclarationsFromHTMLStyle(aNode, aHTMLProperty, aAttribute, aValue,
    1:                                          cssPropertyArray, cssValueArray, PR_FALSE);
    1: 
    1:     // set the individual CSS inline styles
27986:     *aCount = cssPropertyArray.Length();
    1:     PRInt32 index;
    1:     for (index = 0; index < *aCount; index++) {
    1:       nsCOMPtr<nsIDOMElement> theElement = do_QueryInterface(aNode);
27986:       res = SetCSSProperty(theElement, cssPropertyArray[index],
23904:                            cssValueArray[index], aSuppressTransaction);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // Remove from aNode the CSS inline style equivalent to HTMLProperty/aAttribute/aValue for the node
    1: nsresult
    1: nsHTMLCSSUtils::RemoveCSSEquivalentToHTMLStyle(nsIDOMNode * aNode,
    1:                                                nsIAtom *aHTMLProperty,
    1:                                                const nsAString *aAttribute,
    1:                                                const nsAString *aValue,
    1:                                                PRBool aSuppressTransaction)
    1: {
    1:   nsCOMPtr<nsIDOMElement> theElement = do_QueryInterface(aNode);
    1:   nsresult res = NS_OK;
    1:   PRInt32 count = 0;
    1:   if (theElement && IsCSSEditableProperty(aNode, aHTMLProperty, aAttribute)) {
    1:     // we can apply the styles only if the node is an element and if we have
    1:     // an equivalence for the requested HTML style in this implementation
    1: 
    1:     // Find the CSS equivalence to the HTML style
27986:     nsTArray<nsIAtom*> cssPropertyArray;
23904:     nsTArray<nsString> cssValueArray;
    1:     GenerateCSSDeclarationsFromHTMLStyle(aNode, aHTMLProperty, aAttribute, aValue,
    1:                                          cssPropertyArray, cssValueArray, PR_TRUE);
    1: 
    1:     // remove the individual CSS inline styles
27986:     count = cssPropertyArray.Length();
    1:     PRInt32 index;
    1:     for (index = 0; index < count; index++) {
23904:       res = RemoveCSSProperty(theElement,
27986:                               cssPropertyArray[index],
23904:                               cssValueArray[index],
    1:                               aSuppressTransaction);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // aReturn is true if the element aElement carries an ID or a class.
    1: nsresult
    1: nsHTMLCSSUtils::HasClassOrID(nsIDOMElement * aElement, PRBool & aReturn)
    1: {
    1:   nsAutoString classVal, idVal;
    1:   PRBool isClassSet, isIdSet;
    1:   aReturn = PR_FALSE;
    1: 
    1:   nsresult res = mHTMLEditor->GetAttributeValue(aElement,  NS_LITERAL_STRING("class"), classVal, &isClassSet);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = mHTMLEditor->GetAttributeValue(aElement,  NS_LITERAL_STRING("id"), idVal, &isIdSet);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // we need to make sure that if the element has an id or a class attribute,
    1:   // the attribute is not the empty string
    1:   aReturn = ((isClassSet && !classVal.IsEmpty()) ||
    1:              (isIdSet    && !idVal.IsEmpty()));
    1:   return NS_OK;
    1: }
    1: 
    1: // returns in aValueString the list of values for the CSS equivalences to
    1: // the HTML style aHTMLProperty/aAttribute/aValueString for the node aNode;
    1: // the value of aStyleType controls the styles we retrieve : specified or
    1: // computed.
    1: nsresult
    1: nsHTMLCSSUtils::GetCSSEquivalentToHTMLInlineStyleSet(nsIDOMNode * aNode,
    1:                                                      nsIAtom *aHTMLProperty,
    1:                                                      const nsAString *aAttribute,
    1:                                                      nsAString & aValueString,
    1:                                                      PRUint8 aStyleType)
    1: {
    1:   aValueString.Truncate();
    1:   nsCOMPtr<nsIDOMElement> theElement;
    1:   nsresult res = GetElementContainerOrSelf(aNode, getter_AddRefs(theElement));
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   if (theElement && IsCSSEditableProperty(theElement, aHTMLProperty, aAttribute)) {
    1:     // Yes, the requested HTML style has a CSS equivalence in this implementation
    1:     // Retrieve the default ViewCSS if we are asked for computed styles
68870:     nsCOMPtr<nsIDOMViewCSS> viewCSS = nsnull;
    1:     if (COMPUTED_STYLE_TYPE == aStyleType) {
68870:       res = GetDefaultViewCSS(theElement, getter_AddRefs(viewCSS));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
27986:     nsTArray<nsIAtom*> cssPropertyArray;
23904:     nsTArray<nsString> cssValueArray;
    1:     // get the CSS equivalence with last param PR_TRUE indicating we want only the
    1:     // "gettable" properties
    1:     GenerateCSSDeclarationsFromHTMLStyle(theElement, aHTMLProperty, aAttribute, nsnull,
    1:                                          cssPropertyArray, cssValueArray, PR_TRUE);
27986:     PRInt32 count = cssPropertyArray.Length();
    1:     PRInt32 index;
    1:     for (index = 0; index < count; index++) {
    1:       nsAutoString valueString;
    1:       // retrieve the specified/computed value of the property
27986:       res = GetCSSInlinePropertyBase(theElement, cssPropertyArray[index],
68870:                                      valueString, viewCSS, aStyleType);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       // append the value to aValueString (possibly with a leading whitespace)
    1:       if (index) aValueString.Append(PRUnichar(' '));
    1:       aValueString.Append(valueString);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // Does the node aNode (or his parent if it is not an element node) carries
    1: // the CSS equivalent styles to the HTML style aHTMLProperty/aAttribute/
    1: // aValueString for this node ?
    1: // The value of aStyleType controls the styles we retrieve : specified or
    1: // computed. The return value aIsSet is true is the CSS styles are set.
    1: nsresult
    1: nsHTMLCSSUtils::IsCSSEquivalentToHTMLInlineStyleSet(nsIDOMNode * aNode,
    1:                                                     nsIAtom *aHTMLProperty,
    1:                                                     const nsAString * aHTMLAttribute,
    1:                                                     PRBool & aIsSet,
    1:                                                     nsAString & valueString,
    1:                                                     PRUint8 aStyleType)
    1: {
    1:   NS_ENSURE_TRUE(aNode, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsAutoString htmlValueString(valueString);
    1:   aIsSet = PR_FALSE;
    1:   nsCOMPtr<nsIDOMNode> node = aNode;
    1:   NS_NAMED_LITERAL_STRING(boldStr, "bold");
    1:   do {
    1:     valueString.Assign(htmlValueString);
    1:     // get the value of the CSS equivalent styles
    1:     nsresult res = GetCSSEquivalentToHTMLInlineStyleSet(node, aHTMLProperty, aHTMLAttribute,
    1:                                                         valueString, aStyleType);
43805:     NS_ENSURE_SUCCESS(res, res);
    1: 
    1:     // early way out if we can
    1:     if (valueString.IsEmpty()) return NS_OK;
    1: 
    1:     if (nsEditProperty::b == aHTMLProperty) {
    1:       if (valueString.Equals(boldStr)) {
    1:         aIsSet = PR_TRUE;
    1:       }
    1:       else if (valueString.EqualsLiteral("normal")) {
    1:         aIsSet = PR_FALSE;
    1:       }
    1:       else if (valueString.EqualsLiteral("bolder")) {
    1:         aIsSet = PR_TRUE;
    1:         valueString.Assign(boldStr);
    1:       }
    1:       else {
    1:         PRInt32 weight = 0;
    1:         PRInt32 errorCode;
    1:         nsAutoString value(valueString);
    1:         weight = value.ToInteger(&errorCode, 10);
    1:         if (400 < weight) {
    1:           aIsSet = PR_TRUE;
    1:           valueString.Assign(boldStr);
    1:         }
    1:         else {
    1:           aIsSet = PR_FALSE;
    1:           valueString.AssignLiteral("normal");
    1:         }
    1:       }
    1:     }
    1:     
    1:     else if (nsEditProperty::i == aHTMLProperty) {
    1:       if (valueString.EqualsLiteral("italic") ||
    1:           valueString.EqualsLiteral("oblique")) {
    1:         aIsSet= PR_TRUE;
    1:       }
    1:     }
    1: 
    1:     else if (nsEditProperty::u == aHTMLProperty) {
    1:       nsAutoString val;
    1:       val.AssignLiteral("underline");
    1:       aIsSet = PRBool(ChangeCSSInlineStyleTxn::ValueIncludes(valueString, val, PR_FALSE));
    1:     }
    1: 
    1:     else if (nsEditProperty::strike == aHTMLProperty) {
    1:       nsAutoString val;
    1:       val.AssignLiteral("line-through");
    1:       aIsSet = PRBool(ChangeCSSInlineStyleTxn::ValueIncludes(valueString, val, PR_FALSE));
    1:     }
    1: 
    1:     else if (aHTMLAttribute &&
    1:              ( (nsEditProperty::font == aHTMLProperty && 
    1:                 aHTMLAttribute->EqualsLiteral("color")) ||
    1:                aHTMLAttribute->EqualsLiteral("bgcolor"))) {
    1:       if (htmlValueString.IsEmpty())
    1:         aIsSet = PR_TRUE;
    1:       else {
    1:         nscolor rgba;
    1:         nsAutoString subStr;
    1:         htmlValueString.Right(subStr, htmlValueString.Length()-1);
    1:         if (NS_ColorNameToRGB(htmlValueString, &rgba) ||
    1:             NS_HexToRGB(subStr, &rgba)) {
    1:           nsAutoString htmlColor, tmpStr;
    1:           htmlColor.AppendLiteral("rgb(");
    1: 
    1:           NS_NAMED_LITERAL_STRING(comma, ", ");
    1: 
    1:           tmpStr.AppendInt(NS_GET_R(rgba), 10);
    1:           htmlColor.Append(tmpStr + comma);
    1: 
    1:           tmpStr.Truncate();
    1:           tmpStr.AppendInt(NS_GET_G(rgba), 10);
    1:           htmlColor.Append(tmpStr + comma);
    1: 
    1:           tmpStr.Truncate();
    1:           tmpStr.AppendInt(NS_GET_B(rgba), 10);
    1:           htmlColor.Append(tmpStr);
    1: 
    1:           htmlColor.Append(PRUnichar(')'));
    1:           aIsSet = htmlColor.Equals(valueString,
    1:                                     nsCaseInsensitiveStringComparator());
    1:         }
    1:         else
    1:           aIsSet = htmlValueString.Equals(valueString,
    1:                                     nsCaseInsensitiveStringComparator());
    1:       }
    1:     }
    1: 
    1:     else if (nsEditProperty::tt == aHTMLProperty) {
    1:       aIsSet = StringBeginsWith(valueString, NS_LITERAL_STRING("monospace"));
    1:     }
    1:     
    1:     else if ((nsEditProperty::font == aHTMLProperty) && aHTMLAttribute
    1:              && aHTMLAttribute->EqualsLiteral("face")) {
    1:       if (!htmlValueString.IsEmpty()) {
    1:         const PRUnichar commaSpace[] = { PRUnichar(','), PRUnichar(' '), 0 };
    1:         const PRUnichar comma[] = { PRUnichar(','), 0 };
    1:         htmlValueString.ReplaceSubstring(commaSpace, comma);
    1:         nsAutoString valueStringNorm(valueString);
    1:         valueStringNorm.ReplaceSubstring(commaSpace, comma);
    1:         aIsSet = htmlValueString.Equals(valueStringNorm,
    1:                                         nsCaseInsensitiveStringComparator());
    1:       }
    1:       else {
    1:         // ignore this, it's TT or our default
    1:         nsAutoString valueStringLower;
    1:         ToLowerCase(valueString, valueStringLower);
    1:         aIsSet = !valueStringLower.EqualsLiteral("monospace") &&
    1:                  !valueStringLower.EqualsLiteral("serif");
    1:       }
    1:       return NS_OK;
    1:     }
    1:     else if (aHTMLAttribute
    1:              && aHTMLAttribute->EqualsLiteral("align")) {
    1:       aIsSet = PR_TRUE;
    1:     }
    1:     else {
    1:       aIsSet = PR_FALSE;
    1:       return NS_OK;
    1:     }
    1: 
    1:     if (!htmlValueString.IsEmpty()) {
    1:       if (htmlValueString.Equals(valueString,
    1:                                  nsCaseInsensitiveStringComparator())) {
    1:         aIsSet = PR_TRUE;
    1:       }
    1:     }
    1: 
    1:     if (nsEditProperty::u == aHTMLProperty || nsEditProperty::strike == aHTMLProperty) {
    1:       // unfortunately, the value of the text-decoration property is not inherited.
    1:       // that means that we have to look at ancestors of node to see if they are underlined
    1:       nsCOMPtr<nsIDOMNode> tmp;
    1:       res = node->GetParentNode(getter_AddRefs(tmp));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       nsCOMPtr<nsIDOMElement> element = do_QueryInterface(tmp);
    1:       node = element;  // set to null if it's not a dom element
    1:     }
    1:   } while ((nsEditProperty::u == aHTMLProperty || nsEditProperty::strike == aHTMLProperty) &&
    1:            !aIsSet && node);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHTMLCSSUtils::SetCSSEnabled(PRBool aIsCSSPrefChecked)
    1: {
    1:   mIsCSSPrefChecked = aIsCSSPrefChecked;
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsHTMLCSSUtils::IsCSSPrefChecked()
    1: {
    1:   return mIsCSSPrefChecked ;
    1: }
    1: 
    1: // ElementsSameStyle compares two elements and checks if they have the same
    1: // specified CSS declarations in the STYLE attribute 
    1: // The answer is always negative if at least one of them carries an ID or a class
    1: PRBool
    1: nsHTMLCSSUtils::ElementsSameStyle(nsIDOMNode *aFirstNode, nsIDOMNode *aSecondNode)
    1: {
    1:   nsresult res;
    1:   nsCOMPtr<nsIDOMElement> firstElement  = do_QueryInterface(aFirstNode);
    1:   nsCOMPtr<nsIDOMElement> secondElement = do_QueryInterface(aSecondNode);
    1: 
    1:   NS_ASSERTION((firstElement && secondElement), "Non element nodes passed to ElementsSameStyle.");
    1: 
    1:   nsAutoString firstID, secondID;
    1:   PRBool isFirstIDSet, isSecondIDSet;
    1:   res = mHTMLEditor->GetAttributeValue(firstElement,  NS_LITERAL_STRING("id"), firstID,  &isFirstIDSet);
    1:   res = mHTMLEditor->GetAttributeValue(secondElement, NS_LITERAL_STRING("id"), secondID, &isSecondIDSet);
    1:   if (isFirstIDSet || isSecondIDSet) {
    1:     // at least one of the spans carries an ID ; suspect a CSS rule applies to it and
    1:     // refuse to merge the nodes
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   nsAutoString firstClass, secondClass;
    1:   PRBool isFirstClassSet, isSecondClassSet;
    1:   res = mHTMLEditor->GetAttributeValue(firstElement,  NS_LITERAL_STRING("class"), firstClass,  &isFirstClassSet);
    1:   res = mHTMLEditor->GetAttributeValue(secondElement, NS_LITERAL_STRING("class"), secondClass, &isSecondClassSet);
    1:   if (isFirstClassSet && isSecondClassSet) {
    1:     // both spans carry a class, let's compare them
    1:     if (!firstClass.Equals(secondClass)) {
    1:       // WARNING : technically, the comparison just above is questionable :
    1:       // from a pure HTML/CSS point of view class="a b" is NOT the same than
    1:       // class="b a" because a CSS rule could test the exact value of the class
    1:       // attribute to be "a b" for instance ; from a user's point of view, a
    1:       // wysiwyg editor should probably NOT make any difference. CSS people
    1:       // need to discuss this issue before any modification.
    1:       return PR_FALSE;
    1:     }
    1:   }
    1:   else if (isFirstClassSet || isSecondClassSet) {
    1:     // one span only carries a class, early way out
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMCSSStyleDeclaration> firstCSSDecl, secondCSSDecl;
    1:   PRUint32 firstLength, secondLength;
    1:   res = GetInlineStyles(firstElement,  getter_AddRefs(firstCSSDecl),  &firstLength);
    1:   if (NS_FAILED(res) || !firstCSSDecl) return PR_FALSE;
    1:   res = GetInlineStyles(secondElement, getter_AddRefs(secondCSSDecl), &secondLength);
    1:   if (NS_FAILED(res) || !secondCSSDecl) return PR_FALSE;
    1: 
    1:   if (firstLength != secondLength) {
    1:     // early way out if we can
    1:     return PR_FALSE;
    1:   }
    1:   else if (0 == firstLength) {
    1:     // no inline style !
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   PRUint32 i;
    1:   nsAutoString propertyNameString;
    1:   nsAutoString firstValue, secondValue;
    1:   for (i=0; i<firstLength; i++) {
    1:     firstCSSDecl->Item(i, propertyNameString);
    1:     firstCSSDecl->GetPropertyValue(propertyNameString, firstValue);
    1:     secondCSSDecl->GetPropertyValue(propertyNameString, secondValue);
    1:     if (!firstValue.Equals(secondValue)) {
    1:       return PR_FALSE;
    1:     }
    1:   }
    1:   for (i=0; i<secondLength; i++) {
    1:     secondCSSDecl->Item(i, propertyNameString);
    1:     secondCSSDecl->GetPropertyValue(propertyNameString, secondValue);
    1:     firstCSSDecl->GetPropertyValue(propertyNameString, firstValue);
    1:     if (!firstValue.Equals(secondValue)) {
    1:       return PR_FALSE;
    1:     }
    1:   }
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: nsresult
    1: nsHTMLCSSUtils::GetInlineStyles(nsIDOMElement *aElement,
    1:                                 nsIDOMCSSStyleDeclaration **aCssDecl,
    1:                                 PRUint32 *aLength)
    1: {
43806:   NS_ENSURE_TRUE(aElement && aLength, NS_ERROR_NULL_POINTER);
    1:   *aLength = 0;
    1:   nsCOMPtr<nsIDOMElementCSSInlineStyle> inlineStyles = do_QueryInterface(aElement);
43806:   NS_ENSURE_TRUE(inlineStyles, NS_ERROR_NULL_POINTER);
    1:   nsresult res = inlineStyles->GetStyle(aCssDecl);
    1:   if (NS_FAILED(res) || !aCssDecl) return NS_ERROR_NULL_POINTER;
    1:   (*aCssDecl)->GetLength(aLength);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHTMLCSSUtils::GetElementContainerOrSelf(nsIDOMNode * aNode, nsIDOMElement ** aElement)
    1: {
    1:   NS_ENSURE_TRUE(aNode, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsCOMPtr<nsIDOMNode> node=aNode, parentNode;
    1:   PRUint16 type;
    1:   nsresult res;
    1:   res = node->GetNodeType(&type);
43805:   NS_ENSURE_SUCCESS(res, res);
25181: 
25181:   if (nsIDOMNode::DOCUMENT_NODE == type) {
25181:     return NS_ERROR_NULL_POINTER;
25181:   }
25181: 
    1:   // loop until we find an element
    1:   while (node && nsIDOMNode::ELEMENT_NODE != type) {
    1:     parentNode = node;
    1:     res = parentNode->GetParentNode(getter_AddRefs(node));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (node) {
    1:       res = node->GetNodeType(&type);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:   }
    1:   NS_ASSERTION(node, "we reached a null node ancestor !");
    1:   NS_ENSURE_TRUE(node, NS_ERROR_NULL_POINTER);
    1:   nsCOMPtr<nsIDOMElement> element = do_QueryInterface(node);
    1:   (*aElement) = element;
    1:   NS_IF_ADDREF(*aElement);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHTMLCSSUtils::SetCSSProperty(nsIDOMElement * aElement,
    1:                                const nsAString & aProperty,
    1:                                const nsAString & aValue)
    1: {
    1:   nsCOMPtr<nsIDOMCSSStyleDeclaration> cssDecl;
    1:   PRUint32 length;
    1:   nsresult res = GetInlineStyles(aElement, getter_AddRefs(cssDecl), &length);
    1:   if (NS_FAILED(res) || !cssDecl) return res;
    1: 
    1:   return cssDecl->SetProperty(aProperty,
    1:                               aValue,
    1:                               EmptyString());
    1: }
    1: 
    1: nsresult
    1: nsHTMLCSSUtils::SetCSSPropertyPixels(nsIDOMElement * aElement,
    1:                                      const nsAString & aProperty,
    1:                                      PRInt32 aIntValue)
    1: {
    1:   nsAutoString s;
    1:   s.AppendInt(aIntValue);
    1:   return SetCSSProperty(aElement, aProperty, s + NS_LITERAL_STRING("px"));
    1: }
    1: 
    1: nsresult
    1: nsHTMLCSSUtils::RemoveCSSProperty(nsIDOMElement * aElement,
    1:                                   const nsAString & aProperty)
    1: {
    1:   nsCOMPtr<nsIDOMCSSStyleDeclaration> cssDecl;
    1:   PRUint32 length;
    1:   nsresult res = GetInlineStyles(aElement, getter_AddRefs(cssDecl), &length);
    1:   if (NS_FAILED(res) || !cssDecl) return res;
    1: 
    1:   nsAutoString returnString;
    1:   return cssDecl->RemoveProperty(aProperty, returnString);
    1: }
    1: 
