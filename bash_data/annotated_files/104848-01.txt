 93205: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 32836: 
 32195: #include "WebGLContext.h"
 32195: 
 32195: #include "nsString.h"
 73526: #include "nsDebug.h"
 32195: 
 32195: #include "gfxImageSurface.h"
 32195: #include "gfxContext.h"
 32195: #include "gfxPlatform.h"
 32195: 
 32195: #include "nsContentUtils.h"
 32195: #include "nsDOMError.h"
 32195: #include "nsLayoutUtils.h"
 32195: 
 32195: #include "CanvasUtils.h"
 32195: 
 95834: #include "jsfriendapi.h"
 37417: 
 55904: #include "WebGLTexelConversions.h"
 78164: #include "WebGLValidateStrings.h"
 55904: 
 81619: // needed to check if current OS is lower than 10.7
 81619: #if defined(MOZ_WIDGET_COCOA)
 81619: #include "nsCocoaFeatures.h"
 81619: #endif
 81619: 
 97698: #include "mozilla/dom/BindingUtils.h"
 97698: 
 32195: using namespace mozilla;
 91975: using namespace mozilla::dom;
 32195: 
 79445: static bool BaseTypeAndSizeFromUniformType(WebGLenum uType, WebGLenum *baseType, WebGLint *unitSize);
 70163: static WebGLenum InternalFormatForFormatAndType(WebGLenum format, WebGLenum type, bool isGLES2);
 32195: 
 32195: /* Helper macros for when we're just wrapping a gl method, so that
 32195:  * we can avoid having to type this 500 times.  Note that these MUST
 32195:  * NOT BE USED if we need to check any of the parameters.
 32195:  */
 32195: 
 32195: #define GL_SAME_METHOD_0(glname, name)                               \
 97698: NS_IMETHODIMP WebGLContext::Moz##name() {                            \
 97698:     name();                                                          \
 97698:     return NS_OK;                                                    \
 32195: }
 32195: 
 32195: #define GL_SAME_METHOD_1(glname, name, t1)                           \
 97698: NS_IMETHODIMP WebGLContext::Moz##name(t1 a1) {                       \
 97698:     name(a1);                                                        \
 97698:     return NS_OK;                                                    \
 32195: }
 32195: 
 32195: #define GL_SAME_METHOD_2(glname, name, t1, t2)                       \
 97698: NS_IMETHODIMP WebGLContext::Moz##name(t1 a1, t2 a2) {                \
 97698:     name(a1, a2);                                                    \
 97698:     return NS_OK;                                                    \
 32195: }
 32195: 
 32195: #define GL_SAME_METHOD_3(glname, name, t1, t2, t3)                   \
 97698: NS_IMETHODIMP WebGLContext::Moz##name(t1 a1, t2 a2, t3 a3) {         \
 97698:     name(a1, a2, a3);                                                \
 97698:     return NS_OK;                                                    \
 32195: }
 32195: 
 32195: #define GL_SAME_METHOD_4(glname, name, t1, t2, t3, t4)               \
 97698: NS_IMETHODIMP WebGLContext::Moz##name(t1 a1, t2 a2, t3 a3, t4 a4) {  \
 97698:     name(a1, a2, a3, a4);                                            \
 97698:     return NS_OK;                                                    \
 32195: }
 32195: 
 32195: //
 32195: //  WebGL API
 32195: //
 32195: 
 32835: 
 42916: /* void GlActiveTexture (in GLenum texture); */
 32195: NS_IMETHODIMP
 97698: WebGLContext::MozActiveTexture(WebGLenum texture)
 97698: {
 97698:     ActiveTexture(texture);
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 42916: WebGLContext::ActiveTexture(WebGLenum texture)
 32195: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 95061:     if (texture < LOCAL_GL_TEXTURE0 ||
 99228:         texture >= LOCAL_GL_TEXTURE0 + uint32_t(mGLMaxTextureUnits))
 95061:     {
 95061:         return ErrorInvalidEnum(
 95061:             "ActiveTexture: texture unit %d out of range. "
 95061:             "Accepted values range from TEXTURE0 to TEXTURE0 + %d. "
 95061:             "Notice that TEXTURE0 != 0.",
 95061:             texture, mGLMaxTextureUnits);
 95061:     }
 32195: 
 32195:     MakeContextCurrent();
 32195:     mActiveTexture = texture - LOCAL_GL_TEXTURE0;
 32195:     gl->fActiveTexture(texture);
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 42471: WebGLContext::AttachShader(nsIWebGLProgram *pobj, nsIWebGLShader *shobj)
 32195: {
 97698:     AttachShader(static_cast<WebGLProgram*>(pobj),
 97698:                  static_cast<WebGLShader*>(shobj));
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::AttachShader(WebGLProgram *program, WebGLShader *shader)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return;
 97698: 
 97698:     if (!ValidateObject("attachShader: program", program) ||
 97698:         !ValidateObject("attachShader: shader", shader))
 97698:         return;
 32195: 
 57637:     // Per GLSL ES 2.0, we can only have one of each type of shader
 57637:     // attached.  This renders the next test somewhat moot, but we'll
 57637:     // leave it for when we support more than one shader of each type.
 57637:     if (program->HasAttachedShaderOfType(shader->ShaderType()))
 99232:         return ErrorInvalidOperation("attachShader: only one of each type of shader may be attached to a program");
 57637: 
 43098:     if (!program->AttachShader(shader))
 99232:         return ErrorInvalidOperation("attachShader: shader is already attached");
 32195: }
 32195: 
 32195: 
 32195: NS_IMETHODIMP
 42916: WebGLContext::BindAttribLocation(nsIWebGLProgram *pobj, WebGLuint location, const nsAString& name)
 32195: {
 97698:     BindAttribLocation(static_cast<WebGLProgram*>(pobj), location, name);
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::BindAttribLocation(WebGLProgram *prog, WebGLuint location,
 97698:                                  const nsAString& name)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return;
 97698: 
 97698:     if (!ValidateObject("bindAttribLocation: program", prog))
 97698:         return;
 97698: 
 97698:     WebGLuint progname = prog->GLName();
 42471: 
 78164:     if (!ValidateGLSLVariableName(name, "bindAttribLocation"))
 97698:         return;
 32195: 
 63071:     if (!ValidateAttribIndex(location, "bindAttribLocation"))
 97698:         return;
 63071: 
 91439:     NS_LossyConvertUTF16toASCII cname(name);
 91439:     nsCString mappedName;
 91439:     prog->MapIdentifier(cname, &mappedName);
 91439:     
 32195:     MakeContextCurrent();
 91439:     gl->fBindAttribLocation(progname, location, mappedName.get());
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 42916: WebGLContext::BindBuffer(WebGLenum target, nsIWebGLBuffer *bobj)
 32195: {
 97698:     BindBuffer(target, static_cast<WebGLBuffer*>(bobj));
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::BindBuffer(WebGLenum target, WebGLBuffer *buf)
 97698: {
 95822:     if (!IsContextStable())
 97698:         return;
 97698: 
 97698:     if (!ValidateObjectAllowDeletedOrNull("bindBuffer", buf))
 97698:         return;
 97698: 
 97698:     WebGLuint bufname = buf ? buf->GLName() : 0;
 77721: 
 77721:     // silently ignore a deleted buffer
 97698:     if (buf && buf->IsDeleted())
 97698:         return;
 35488: 
 69944:     if (target != LOCAL_GL_ARRAY_BUFFER &&
 69944:         target != LOCAL_GL_ELEMENT_ARRAY_BUFFER)
 69944:     {
 69944:         return ErrorInvalidEnumInfo("bindBuffer: target", target);
 32195:     }
 32195: 
 97698:     if (buf) {
 43009:         if ((buf->Target() != LOCAL_GL_NONE) && (target != buf->Target()))
 99232:             return ErrorInvalidOperation("bindBuffer: buffer already bound to a different target");
 43009:         buf->SetTarget(target);
 80486:         buf->SetHasEverBeenBound(true);
 43009:     }
 43009: 
 69944:     // we really want to do this AFTER all the validation is done, otherwise our bookkeeping could get confused.
 69944:     // see bug 656752
 69944:     if (target == LOCAL_GL_ARRAY_BUFFER) {
 69944:         mBoundArrayBuffer = buf;
 69944:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
 69944:         mBoundElementArrayBuffer = buf;
 69944:     }
 69944: 
 42472:     MakeContextCurrent();
 42472: 
 42472:     gl->fBindBuffer(target, bufname);
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 42916: WebGLContext::BindFramebuffer(WebGLenum target, nsIWebGLFramebuffer *fbobj)
 32195: {
 97698:     BindFramebuffer(target, static_cast<WebGLFramebuffer*>(fbobj));
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::BindFramebuffer(WebGLenum target, WebGLFramebuffer *wfb)
 97698: {
 95822:     if (!IsContextStable())
 97698:         return;
 42473: 
 42473:     if (target != LOCAL_GL_FRAMEBUFFER)
 99232:         return ErrorInvalidEnum("bindFramebuffer: target must be GL_FRAMEBUFFER");
 42473: 
 97698:     if (!ValidateObjectAllowDeletedOrNull("bindFramebuffer", wfb))
 97698:         return;
 77721: 
 77721:     // silently ignore a deleted frame buffer
 97698:     if (wfb && wfb->IsDeleted())
 97698:         return;
 32195: 
 42472:     MakeContextCurrent();
 42472: 
 97698:     if (!wfb) {
 47910:         gl->fBindFramebuffer(target, gl->GetOffscreenFBO());
 47910:     } else {
 97698:         WebGLuint framebuffername = wfb->GLName();
 42472:         gl->fBindFramebuffer(target, framebuffername);
 80486:         wfb->SetHasEverBeenBound(true);
 47910:     }
 32195: 
 42473:     mBoundFramebuffer = wfb;
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 42916: WebGLContext::BindRenderbuffer(WebGLenum target, nsIWebGLRenderbuffer *rbobj)
 32195: {
 97698:     BindRenderbuffer(target, static_cast<WebGLRenderbuffer*>(rbobj));
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::BindRenderbuffer(WebGLenum target, WebGLRenderbuffer *wrb)
 97698: {
 95822:     if (!IsContextStable())
 97698:         return;
 42473: 
 42477:     if (target != LOCAL_GL_RENDERBUFFER)
 47813:         return ErrorInvalidEnumInfo("bindRenderbuffer: target", target);
 42477: 
 97698:     if (!ValidateObjectAllowDeletedOrNull("bindRenderbuffer", wrb))
 97698:         return;
 77721: 
 77721:     // silently ignore a deleted buffer
 97698:     if (wrb && wrb->IsDeleted())
 97698:         return;
 97698: 
 97698:     if (wrb)
 80486:         wrb->SetHasEverBeenBound(true);
 62489: 
 32195:     MakeContextCurrent();
 32195: 
 97698:     WebGLuint renderbuffername = wrb ? wrb->GLName() : 0;
 42472:     gl->fBindRenderbuffer(target, renderbuffername);
 32195: 
 42473:     mBoundRenderbuffer = wrb;
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 42916: WebGLContext::BindTexture(WebGLenum target, nsIWebGLTexture *tobj)
 32195: {
 97698:     BindTexture(target, static_cast<WebGLTexture*>(tobj));
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::BindTexture(WebGLenum target, WebGLTexture *tex)
 97698: {
 95822:     if (!IsContextStable())
 97698:         return;
 97698: 
 97698:     if (!ValidateObjectAllowDeletedOrNull("bindTexture", tex))
 97698:         return;
 77721: 
 77721:     // silently ignore a deleted texture
 97698:     if (tex && tex->IsDeleted())
 97698:         return;
 32195: 
 32195:     if (target == LOCAL_GL_TEXTURE_2D) {
 42472:         mBound2DTextures[mActiveTexture] = tex;
 32195:     } else if (target == LOCAL_GL_TEXTURE_CUBE_MAP) {
 42472:         mBoundCubeMapTextures[mActiveTexture] = tex;
 32195:     } else {
 47813:         return ErrorInvalidEnumInfo("bindTexture: target", target);
 32195:     }
 32195: 
 42472:     MakeContextCurrent();
 42472: 
 51422:     if (tex)
 51422:         tex->Bind(target);
 51422:     else
 51422:         gl->fBindTexture(target, 0 /* == texturename */);
 97698: }
 97698: 
 97698: GL_SAME_METHOD_4(BlendColor, BlendColor, WebGLclampf, WebGLclampf, WebGLclampf, WebGLclampf)
 97698: 
 97698: NS_IMETHODIMP WebGLContext::MozBlendEquation(WebGLenum mode)
 97698: {
 97698:     BlendEquation(mode);
 32195:     return NS_OK;
 32195: }
 32195: 
 97698: void WebGLContext::BlendEquation(WebGLenum mode)
 43855: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 46443:     if (!ValidateBlendEquationEnum(mode, "blendEquation: mode"))
 97698:         return;
 43855: 
 43855:     MakeContextCurrent();
 43855:     gl->fBlendEquation(mode);
 97698: }
 97698: 
 97698: NS_IMETHODIMP WebGLContext::MozBlendEquationSeparate(WebGLenum modeRGB, WebGLenum modeAlpha)
 97698: {
 97698:     BlendEquationSeparate(modeRGB, modeAlpha);
 43855:     return NS_OK;
 43855: }
 43855: 
 97698: void WebGLContext::BlendEquationSeparate(WebGLenum modeRGB, WebGLenum modeAlpha)
 43855: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 46443:     if (!ValidateBlendEquationEnum(modeRGB, "blendEquationSeparate: modeRGB") ||
 46443:         !ValidateBlendEquationEnum(modeAlpha, "blendEquationSeparate: modeAlpha"))
 97698:         return;
 43855: 
 43855:     MakeContextCurrent();
 43855:     gl->fBlendEquationSeparate(modeRGB, modeAlpha);
 97698: }
 97698: 
 97698: NS_IMETHODIMP WebGLContext::MozBlendFunc(WebGLenum sfactor, WebGLenum dfactor)
 97698: {
 97698:     BlendFunc(sfactor, dfactor);
 43855:     return NS_OK;
 43855: }
 43855: 
 97698: void WebGLContext::BlendFunc(WebGLenum sfactor, WebGLenum dfactor)
 43855: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 46443:     if (!ValidateBlendFuncSrcEnum(sfactor, "blendFunc: sfactor") ||
 46443:         !ValidateBlendFuncDstEnum(dfactor, "blendFunc: dfactor"))
 97698:         return;
 43855: 
 58667:     if (!ValidateBlendFuncEnumsCompatibility(sfactor, dfactor, "blendFuncSeparate: srcRGB and dstRGB"))
 97698:         return;
 58667: 
 43855:     MakeContextCurrent();
 43855:     gl->fBlendFunc(sfactor, dfactor);
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozBlendFuncSeparate(WebGLenum srcRGB, WebGLenum dstRGB,
 97698:                                    WebGLenum srcAlpha, WebGLenum dstAlpha)
 97698: {
 97698:     BlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
 43855:     return NS_OK;
 43855: }
 43855: 
 97698: void
 43855: WebGLContext::BlendFuncSeparate(WebGLenum srcRGB, WebGLenum dstRGB,
 43855:                                 WebGLenum srcAlpha, WebGLenum dstAlpha)
 43855: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 46443:     if (!ValidateBlendFuncSrcEnum(srcRGB, "blendFuncSeparate: srcRGB") ||
 46443:         !ValidateBlendFuncSrcEnum(srcAlpha, "blendFuncSeparate: srcAlpha") ||
 46443:         !ValidateBlendFuncDstEnum(dstRGB, "blendFuncSeparate: dstRGB") ||
 46443:         !ValidateBlendFuncDstEnum(dstAlpha, "blendFuncSeparate: dstAlpha"))
 97698:         return;
 43855: 
 58667:     // note that we only check compatibity for the RGB enums, no need to for the Alpha enums, see
 58667:     // "Section 6.8 forgetting to mention alpha factors?" thread on the public_webgl mailing list
 58667:     if (!ValidateBlendFuncEnumsCompatibility(srcRGB, dstRGB, "blendFuncSeparate: srcRGB and dstRGB"))
 97698:         return;
 58667: 
 43855:     MakeContextCurrent();
 43855:     gl->fBlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
 43855: }
 32195: 
 73526: GLenum WebGLContext::CheckedBufferData(GLenum target,
 73526:                                        GLsizeiptr size,
 73526:                                        const GLvoid *data,
 73526:                                        GLenum usage)
 73526: {
 73526:     WebGLBuffer *boundBuffer = NULL;
 73526:     if (target == LOCAL_GL_ARRAY_BUFFER) {
 73526:         boundBuffer = mBoundArrayBuffer;
 73526:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
 73526:         boundBuffer = mBoundElementArrayBuffer;
 73526:     }
 73526:     NS_ABORT_IF_FALSE(boundBuffer != nsnull, "no buffer bound for this target");
 73526:     
 99228:     bool sizeChanges = uint32_t(size) != boundBuffer->ByteLength();
 73526:     if (sizeChanges) {
 73526:         UpdateWebGLErrorAndClearGLError();
 73526:         gl->fBufferData(target, size, data, usage);
 73526:         GLenum error = LOCAL_GL_NO_ERROR;
 73526:         UpdateWebGLErrorAndClearGLError(&error);
 73526:         return error;
 73526:     } else {
 73526:         gl->fBufferData(target, size, data, usage);
 73526:         return LOCAL_GL_NO_ERROR;
 73526:     }
 73526: }
 73526: 
 32195: NS_IMETHODIMP
 99228: WebGLContext::BufferData(WebGLenum target, const JS::Value& data, GLenum usage,
 93205:                          JSContext* cx)
 93205: {
104848:     if (!IsContextStable())
104848:         return NS_OK;
104848: 
 93205:     if (data.isNull()) {
 97698:         BufferData(target, static_cast<ArrayBuffer*>(nsnull), usage);
 97698:         return NS_OK;
 58665:     }
 58665: 
 93205:     if (data.isObject()) {
 93205:         JSObject& dataObj = data.toObject();
 95834:         if (JS_IsArrayBufferObject(&dataObj, cx)) {
 97698:             ArrayBuffer buf(cx, &dataObj);
 97698:             BufferData(target, &buf, usage);
 97698:             return NS_OK;
 95834:         }
 95834: 
 95834:         if (JS_IsTypedArrayObject(&dataObj, cx)) {
 97698:             ArrayBufferView view(cx, &dataObj);
 97698:             BufferData(target, view, usage);
 97698:             return NS_OK;
 97698:         }
 97698: 
 97698:         ErrorInvalidValue("bufferData: object passed that is not an "
 93205:                           "ArrayBufferView or ArrayBuffer");
 97698:         return NS_OK;
 93205:     }
 93205: 
 93205:     MOZ_ASSERT(data.isPrimitive());
 93205:     int32_t size;
 93205:     // ToInt32 cannot fail for primitives.
 93205:     MOZ_ALWAYS_TRUE(JS_ValueToECMAInt32(cx, data, &size));
 97698:     BufferData(target, WebGLsizeiptr(size), usage);
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::BufferData(WebGLenum target, WebGLsizeiptr size,
 97698:                          WebGLenum usage)
 32195: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 32195:     WebGLBuffer *boundBuffer = NULL;
 32195: 
 32195:     if (target == LOCAL_GL_ARRAY_BUFFER) {
 32195:         boundBuffer = mBoundArrayBuffer;
 32195:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
 32195:         boundBuffer = mBoundElementArrayBuffer;
 32195:     } else {
 47813:         return ErrorInvalidEnumInfo("bufferData: target", target);
 32195:     }
 32195: 
 47206:     if (size < 0)
 47206:         return ErrorInvalidValue("bufferData: negative size");
 47206: 
 47206:     if (!ValidateBufferUsageEnum(usage, "bufferData: usage"))
 97698:         return;
 47206: 
 42477:     if (!boundBuffer)
 99232:         return ErrorInvalidOperation("bufferData: no buffer bound!");
 37417: 
 37417:     MakeContextCurrent();
 37417:     
 73526:     GLenum error = CheckedBufferData(target, size, 0, usage);
 73526:     if (error) {
 99231:         GenerateWarning("bufferData generated error %s", ErrorName(error));
 97698:         return;
 73526:     }
 73526: 
 37417:     boundBuffer->SetByteLength(size);
 73526:     boundBuffer->InvalidateCachedMaxElements();
 63070:     if (!boundBuffer->ZeroDataIfElementArray())
 63070:         return ErrorOutOfMemory("bufferData: out of memory");
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::BufferData(WebGLenum target, ArrayBuffer *data, WebGLenum usage)
 37417: {
 86627:     if (!IsContextStable())
 97698:         return;
 97698: 
 97698:     if (!data) {
 97698:         // see http://www.khronos.org/bugzilla/show_bug.cgi?id=386
 97698:         return ErrorInvalidValue("bufferData: null object passed");
 97698:     }
 95834: 
 37417:     WebGLBuffer *boundBuffer = NULL;
 37417: 
 37417:     if (target == LOCAL_GL_ARRAY_BUFFER) {
 37417:         boundBuffer = mBoundArrayBuffer;
 37417:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
 37417:         boundBuffer = mBoundElementArrayBuffer;
 37417:     } else {
 47813:         return ErrorInvalidEnumInfo("bufferData: target", target);
 37417:     }
 37417: 
 47206:     if (!ValidateBufferUsageEnum(usage, "bufferData: usage"))
 97698:         return;
 47206: 
 42477:     if (!boundBuffer)
 99232:         return ErrorInvalidOperation("bufferData: no buffer bound!");
 37417: 
 37417:     MakeContextCurrent();
 37417: 
 97698:     GLenum error = CheckedBufferData(target, data->mLength, data->mData, usage);
 97698: 
 73526:     if (error) {
 99231:         GenerateWarning("bufferData generated error %s", ErrorName(error));
 97698:         return;
 97698:     }
 97698: 
 97698:     boundBuffer->SetByteLength(data->mLength);
 73526:     boundBuffer->InvalidateCachedMaxElements();
 97698:     if (!boundBuffer->CopyDataIfElementArray(data->mData))
 63070:         return ErrorOutOfMemory("bufferData: out of memory");
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::BufferData(WebGLenum target, ArrayBufferView& data, WebGLenum usage)
 37417: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 37417:     WebGLBuffer *boundBuffer = NULL;
 37417: 
 37417:     if (target == LOCAL_GL_ARRAY_BUFFER) {
 37417:         boundBuffer = mBoundArrayBuffer;
 37417:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
 37417:         boundBuffer = mBoundElementArrayBuffer;
 37417:     } else {
 47813:         return ErrorInvalidEnumInfo("bufferData: target", target);
 37417:     }
 37417: 
 47206:     if (!ValidateBufferUsageEnum(usage, "bufferData: usage"))
 97698:         return;
 47206: 
 42477:     if (!boundBuffer)
 99232:         return ErrorInvalidOperation("bufferData: no buffer bound!");
 37417: 
 37417:     MakeContextCurrent();
 37417: 
 97698:     GLenum error = CheckedBufferData(target, data.mLength, data.mData, usage);
 73526:     if (error) {
 99231:         GenerateWarning("bufferData generated error %s", ErrorName(error));
 97698:         return;
 97698:     }
 97698: 
 97698:     boundBuffer->SetByteLength(data.mLength);
 73526:     boundBuffer->InvalidateCachedMaxElements();
 97698:     if (!boundBuffer->CopyDataIfElementArray(data.mData))
 63070:         return ErrorOutOfMemory("bufferData: out of memory");
 37417: }
 37417: 
 37417: NS_IMETHODIMP
 99228: WebGLContext::BufferSubData(WebGLenum target, WebGLintptr offset, const JS::Value& data, JSContext *cx)
 93206: {
 95822:     if (!IsContextStable())
 95822:         return NS_OK;
 95822: 
 93206:     if (data.isNull()) {
 97698:         BufferSubData(target, offset, nsnull);
 93206:         return NS_OK;
 93206:     }
 93206: 
 93206:     if (!data.isObject()) {
 32195:         return NS_ERROR_FAILURE;
 32195:     }
 37417: 
 93206:     JSObject& dataObj = data.toObject();
 95834:     if (JS_IsArrayBufferObject(&dataObj, cx)) {
 97698:         ArrayBuffer buf(cx, &dataObj);
 97698:         BufferSubData(target, offset, &buf);
 97698:         return NS_OK;
 95834:     }
 95834: 
 95834:     if (JS_IsTypedArrayObject(&dataObj, cx)) {
 97698:         ArrayBufferView view(cx, &dataObj);
 97698:         BufferSubData(target, offset, view);
 97698:         return NS_OK;
 93206:     }
 93206: 
 93206:     return NS_ERROR_FAILURE;
 93206: }
 93206: 
 97698: void
 97698: WebGLContext::BufferSubData(GLenum target, WebGLsizeiptr byteOffset,
 97698:                             ArrayBuffer *data)
 37417: {
 86627:     if (!IsContextStable())
 97698:         return;
 97698: 
 97698:     if (!data) {
 97698:         // see http://www.khronos.org/bugzilla/show_bug.cgi?id=386
 97698:         return;
 97698:     }
 95834: 
 37417:     WebGLBuffer *boundBuffer = NULL;
 37417: 
 37417:     if (target == LOCAL_GL_ARRAY_BUFFER) {
 37417:         boundBuffer = mBoundArrayBuffer;
 37417:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
 37417:         boundBuffer = mBoundElementArrayBuffer;
 37417:     } else {
 47813:         return ErrorInvalidEnumInfo("bufferSubData: target", target);
 32195:     }
 37417: 
 62488:     if (byteOffset < 0)
 62488:         return ErrorInvalidValue("bufferSubData: negative offset");
 62488: 
 42477:     if (!boundBuffer)
 99232:         return ErrorInvalidOperation("bufferData: no buffer bound!");
 37417: 
 97698:     CheckedUint32 checked_neededByteLength = CheckedUint32(byteOffset) + data->mLength;
 98543:     if (!checked_neededByteLength.isValid())
 47204:         return ErrorInvalidOperation("bufferSubData: integer overflow computing the needed byte length");
 47204: 
 47204:     if (checked_neededByteLength.value() > boundBuffer->ByteLength())
 99232:         return ErrorInvalidOperation("bufferSubData: not enough data - operation requires %d bytes, but buffer only has %d bytes",
 97698:                                      checked_neededByteLength.value(), boundBuffer->ByteLength());
 32195: 
 32195:     MakeContextCurrent();
 32195: 
 97698:     boundBuffer->CopySubDataIfElementArray(byteOffset, data->mLength, data->mData);
 61295:     boundBuffer->InvalidateCachedMaxElements();
 43009: 
 97698:     gl->fBufferSubData(target, byteOffset, data->mLength, data->mData);
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::BufferSubData(WebGLenum target, WebGLsizeiptr byteOffset,
 97698:                             ArrayBufferView& data)
 37417: {
 86627:     if (!IsContextStable())
 97698:         return;
 95834: 
 37417:     WebGLBuffer *boundBuffer = NULL;
 37417: 
 37417:     if (target == LOCAL_GL_ARRAY_BUFFER) {
 37417:         boundBuffer = mBoundArrayBuffer;
 37417:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
 37417:         boundBuffer = mBoundElementArrayBuffer;
 34453:     } else {
 47813:         return ErrorInvalidEnumInfo("bufferSubData: target", target);
 34453:     }
 37417: 
 62488:     if (byteOffset < 0)
 62488:         return ErrorInvalidValue("bufferSubData: negative offset");
 62488: 
 42477:     if (!boundBuffer)
 99232:         return ErrorInvalidOperation("bufferSubData: no buffer bound!");
 97698: 
 97698:     CheckedUint32 checked_neededByteLength = CheckedUint32(byteOffset) + data.mLength;
 98543:     if (!checked_neededByteLength.isValid())
 47204:         return ErrorInvalidOperation("bufferSubData: integer overflow computing the needed byte length");
 47204: 
 47204:     if (checked_neededByteLength.value() > boundBuffer->ByteLength())
 99232:         return ErrorInvalidOperation("bufferSubData: not enough data -- operation requires %d bytes, but buffer only has %d bytes",
 97698:                                      checked_neededByteLength.value(), boundBuffer->ByteLength());
 34453: 
 34453:     MakeContextCurrent();
 34453: 
 97698:     boundBuffer->CopySubDataIfElementArray(byteOffset, data.mLength, data.mData);
 61295:     boundBuffer->InvalidateCachedMaxElements();
 43009: 
 97698:     gl->fBufferSubData(target, byteOffset, data.mLength, data.mData);
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 42916: WebGLContext::CheckFramebufferStatus(WebGLenum target, WebGLenum *retval)
 32195: {
 97698:     *retval = CheckFramebufferStatus(target);
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: WebGLenum
 97698: WebGLContext::CheckFramebufferStatus(WebGLenum target)
 97698: {
 86627:     if (!IsContextStable())
 80903:     {
 97698:         return LOCAL_GL_FRAMEBUFFER_UNSUPPORTED;
 97698:     }
 97698: 
 97698:     MakeContextCurrent();
 97698:     if (target != LOCAL_GL_FRAMEBUFFER) {
 97698:         ErrorInvalidEnum("checkFramebufferStatus: target must be FRAMEBUFFER");
 97698:         return 0;
 97698:     }
 97698: 
 97698:     if (!mBoundFramebuffer)
 97698:         return LOCAL_GL_FRAMEBUFFER_COMPLETE;
 97698:     if(mBoundFramebuffer->HasDepthStencilConflict())
 97698:         return LOCAL_GL_FRAMEBUFFER_UNSUPPORTED;
 97698:     if(!mBoundFramebuffer->ColorAttachment().IsDefined())
 97698:         return LOCAL_GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;
 97698:     if(mBoundFramebuffer->HasIncompleteAttachment())
 97698:         return LOCAL_GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
 97698:     if(mBoundFramebuffer->HasAttachmentsOfMismatchedDimensions())
 97698:         return LOCAL_GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS;
 97698:     return gl->fCheckFramebufferStatus(target);
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 99228: WebGLContext::MozClear(uint32_t mask)
 97698: {
 97698:     Clear(mask);
 80903:     return NS_OK;
 80903: }
 80903: 
 97698: void
 97698: WebGLContext::Clear(WebGLbitfield mask)
 34453: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 34453:     MakeContextCurrent();
 56959: 
 99228:     uint32_t m = mask & (LOCAL_GL_COLOR_BUFFER_BIT | LOCAL_GL_DEPTH_BUFFER_BIT | LOCAL_GL_STENCIL_BUFFER_BIT);
 70168:     if (mask != m)
 70168:         return ErrorInvalidValue("clear: invalid mask bits");
 70168: 
 79445:     bool needClearCallHere = true;
 70168: 
 70168:     if (mBoundFramebuffer) {
 70168:         if (!mBoundFramebuffer->CheckAndInitializeRenderbuffers())
 88091:             return ErrorInvalidFramebufferOperation("clear: incomplete framebuffer");
 70168:     } else {
 70168:         // no FBO is bound, so we are clearing the backbuffer here
 70168:         EnsureBackbufferClearedAsNeeded();
 79445:         bool valuesAreDefault = mColorClearValue[0] == 0.0f &&
 70168:                                   mColorClearValue[1] == 0.0f &&
 70168:                                   mColorClearValue[2] == 0.0f &&
 70168:                                   mColorClearValue[3] == 0.0f &&
 70168:                                   mDepthClearValue    == 1.0f &&
 70168:                                   mStencilClearValue  == 0;
 70168:         if (valuesAreDefault &&
 70168:             mBackbufferClearingStatus == BackbufferClearingStatus::ClearedToDefaultValues)
 70168:         {
 80486:             needClearCallHere = false;
 70168:         }
 70168:     }
 70168: 
 70168:     if (needClearCallHere) {
 34453:         gl->fClear(mask);
 70168:         mBackbufferClearingStatus = BackbufferClearingStatus::HasBeenDrawnTo;
 34453:         Invalidate();
 70168:     }
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozClearColor(WebGLfloat r, WebGLfloat g, WebGLfloat b, WebGLfloat a)
 97698: {
 97698:     ClearColor(r, g, b, a);
 34453:     return NS_OK;
 34453: }
 32195: 
 97698: void
 97698: WebGLContext::ClearColor(WebGLclampf r, WebGLclampf g,
 97698:                          WebGLclampf b, WebGLclampf a)
 70166: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 70166:     MakeContextCurrent();
 70166:     mColorClearValue[0] = r;
 70166:     mColorClearValue[1] = g;
 70166:     mColorClearValue[2] = b;
 70166:     mColorClearValue[3] = a;
 70166:     gl->fClearColor(r, g, b, a);
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozClearDepth(WebGLfloat v)
 97698: {
 97698:     ClearDepth(v);
 70166:     return NS_OK;
 70166: }
 70166: 
 97698: void
 97698: WebGLContext::ClearDepth(WebGLclampf v)
 70166: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 70166:     MakeContextCurrent();
 70166:     mDepthClearValue = v;
 70166:     gl->fClearDepth(v);
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozClearStencil(WebGLint v)
 97698: {
 97698:     ClearStencil(v);
 70166:     return NS_OK;
 70166: }
 70166: 
 97698: void
 70166: WebGLContext::ClearStencil(WebGLint v)
 70166: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 70166:     MakeContextCurrent();
 70166:     mStencilClearValue = v;
 70166:     gl->fClearStencil(v);
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozColorMask(WebGLboolean r, WebGLboolean g, WebGLboolean b, WebGLboolean a)
 97698: {
 97698:     ColorMask(r, g, b, a);
 70166:     return NS_OK;
 70166: }
 70166: 
 97698: void
 70166: WebGLContext::ColorMask(WebGLboolean r, WebGLboolean g, WebGLboolean b, WebGLboolean a)
 70166: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 70166:     MakeContextCurrent();
 70166:     mColorWriteMask[0] = r;
 70166:     mColorWriteMask[1] = g;
 70166:     mColorWriteMask[2] = b;
 70166:     mColorWriteMask[3] = a;
 70166:     gl->fColorMask(r, g, b, a);
 97698: }
 97698: 
 97698: void
 60093: WebGLContext::CopyTexSubImage2D_base(WebGLenum target,
 60093:                                      WebGLint level,
 60093:                                      WebGLenum internalformat,
 60093:                                      WebGLint xoffset,
 60093:                                      WebGLint yoffset,
 60093:                                      WebGLint x,
 60093:                                      WebGLint y,
 60093:                                      WebGLsizei width,
 60093:                                      WebGLsizei height,
 60093:                                      bool sub)
 60093: {
 88090:     const WebGLRectangleObject *framebufferRect = FramebufferRectangleObject();
 88090:     WebGLsizei framebufferWidth = framebufferRect ? framebufferRect->Width() : 0;
 88090:     WebGLsizei framebufferHeight = framebufferRect ? framebufferRect->Height() : 0;
 60093: 
 60093:     const char *info = sub ? "copyTexSubImage2D" : "copyTexImage2D";
 60093: 
 60093:     MakeContextCurrent();
 60093: 
 60093:     if (CanvasUtils::CheckSaneSubrectSize(x, y, width, height, framebufferWidth, framebufferHeight)) {
 60093:         if (sub)
 60093:             gl->fCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
 60093:         else
 60093:             gl->fCopyTexImage2D(target, level, internalformat, x, y, width, height, 0);
 60093:     } else {
 60093: 
 60093:         // the rect doesn't fit in the framebuffer
 60093: 
 60093:         /*** first, we initialize the texture as black ***/
 60093: 
 60093:         // first, compute the size of the buffer we should allocate to initialize the texture as black
 60093: 
 99228:         uint32_t texelSize = 0;
 70163:         if (!ValidateTexFormatAndType(internalformat, LOCAL_GL_UNSIGNED_BYTE, -1, &texelSize, info))
 97698:             return;
 60093: 
 77722:         CheckedUint32 checked_neededByteLength = 
 77722:             GetImageSize(height, width, texelSize, mPixelStoreUnpackAlignment);
 60093: 
 98543:         if (!checked_neededByteLength.isValid())
 60093:             return ErrorInvalidOperation("%s: integer overflow computing the needed buffer size", info);
 60093: 
 99228:         uint32_t bytesNeeded = checked_neededByteLength.value();
 60093: 
 60093:         // now that the size is known, create the buffer
 60093: 
 60093:         // We need some zero pages, because GL doesn't guarantee the
 60093:         // contents of a texture allocated with NULL data.
 60093:         // Hopefully calloc will just mmap zero pages here.
 60093:         void *tempZeroData = calloc(1, bytesNeeded);
 60093:         if (!tempZeroData)
 63070:             return ErrorOutOfMemory("%s: could not allocate %d bytes (for zero fill)", info, bytesNeeded);
 60093: 
 60093:         // now initialize the texture as black
 60093: 
 60093:         if (sub)
 73531:             gl->fTexSubImage2D(target, level, 0, 0, width, height,
 73531:                                internalformat, LOCAL_GL_UNSIGNED_BYTE, tempZeroData);
 60093:         else
 73531:             gl->fTexImage2D(target, level, internalformat, width, height,
 73531:                             0, internalformat, LOCAL_GL_UNSIGNED_BYTE, tempZeroData);
 60093:         free(tempZeroData);
 60093: 
 60093:         // if we are completely outside of the framebuffer, we can exit now with our black texture
 60093:         if (   x >= framebufferWidth
 60093:             || x+width <= 0
 60093:             || y >= framebufferHeight
 60093:             || y+height <= 0)
 60093:         {
 60093:             // we are completely outside of range, can exit now with buffer filled with zeros
 88091:             return DummyFramebufferOperation(info);
 60093:         }
 60093: 
 81029:         GLint   actual_x             = clamped(x, 0, framebufferWidth);
 81029:         GLint   actual_x_plus_width  = clamped(x + width, 0, framebufferWidth);
 60093:         GLsizei actual_width   = actual_x_plus_width  - actual_x;
 60093:         GLint   actual_xoffset = xoffset + actual_x - x;
 60093: 
 81029:         GLint   actual_y             = clamped(y, 0, framebufferHeight);
 81029:         GLint   actual_y_plus_height = clamped(y + height, 0, framebufferHeight);
 60093:         GLsizei actual_height  = actual_y_plus_height - actual_y;
 60093:         GLint   actual_yoffset = yoffset + actual_y - y;
 60093: 
 60093:         gl->fCopyTexSubImage2D(target, level, actual_xoffset, actual_yoffset, actual_x, actual_y, actual_width, actual_height);
 60093:     }
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozCopyTexImage2D(WebGLenum target,
 97698:                                 WebGLint level,
 97698:                                 WebGLenum internalformat,
 97698:                                 WebGLint x,
 97698:                                 WebGLint y,
 97698:                                 WebGLsizei width,
 97698:                                 WebGLsizei height,
 97698:                                 WebGLint border)
 97698: {
 97698:     CopyTexImage2D(target, level, internalformat, x, y, width, height, border);
 60093:     return NS_OK;
 60093: }
 60093: 
 97698: void
 42916: WebGLContext::CopyTexImage2D(WebGLenum target,
 42916:                              WebGLint level,
 42916:                              WebGLenum internalformat,
 42916:                              WebGLint x,
 42916:                              WebGLint y,
 42916:                              WebGLsizei width,
 42916:                              WebGLsizei height,
 42916:                              WebGLint border)
 32195: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 32195:     switch (target) {
 32195:         case LOCAL_GL_TEXTURE_2D:
 32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X:
 32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
 32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
 32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
 32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
 32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
 32195:             break;
 32195:         default:
 47813:             return ErrorInvalidEnumInfo("copyTexImage2D: target", target);
 32195:     }
 32195: 
 58673: 
 32195:     switch (internalformat) {
 32195:         case LOCAL_GL_RGB:
 58673:         case LOCAL_GL_LUMINANCE:
 32195:         case LOCAL_GL_RGBA:
 32195:         case LOCAL_GL_ALPHA:
 32195:         case LOCAL_GL_LUMINANCE_ALPHA:
 32195:             break;
 32195:         default:
 99232:             return ErrorInvalidEnumInfo("copyTexImage2D: internal format", internalformat);
 32195:     }
 32195: 
 51422:     if (border != 0)
 51422:         return ErrorInvalidValue("copyTexImage2D: border must be 0");
 51422: 
 60093:     if (width < 0 || height < 0)
 60093:         return ErrorInvalidValue("copyTexImage2D: width and height may not be negative");
 60093: 
 51422:     if (level < 0)
 51422:         return ErrorInvalidValue("copyTexImage2D: level may not be negative");
 32195: 
 63067:     WebGLsizei maxTextureSize = MaxTextureSizeForTarget(target);
 63067:     if (!(maxTextureSize >> level))
 63067:         return ErrorInvalidValue("copyTexImage2D: 2^level exceeds maximum texture size");
 63067: 
 51894:     if (level >= 1) {
 51894:         if (!(is_pot_assuming_nonnegative(width) &&
 51894:               is_pot_assuming_nonnegative(height)))
 51894:             return ErrorInvalidValue("copyTexImage2D: with level > 0, width and height must be powers of two");
 51894:     }
 51894: 
 79445:     bool texFormatRequiresAlpha = internalformat == LOCAL_GL_RGBA ||
 58673:                                     internalformat == LOCAL_GL_ALPHA ||
 58673:                                     internalformat == LOCAL_GL_LUMINANCE_ALPHA;
 79445:     bool fboFormatHasAlpha = mBoundFramebuffer ? mBoundFramebuffer->ColorAttachment().HasAlpha()
 79445:                                                  : bool(gl->ActualFormat().alpha > 0);
 58673:     if (texFormatRequiresAlpha && !fboFormatHasAlpha)
 58673:         return ErrorInvalidOperation("copyTexImage2D: texture format requires an alpha channel "
 58673:                                      "but the framebuffer doesn't have one");
 58673: 
 88091:     if (mBoundFramebuffer)
 88091:         if (!mBoundFramebuffer->CheckAndInitializeRenderbuffers())
 88091:             return ErrorInvalidFramebufferOperation("copyTexImage2D: incomplete framebuffer");
 58666: 
 51422:     WebGLTexture *tex = activeBoundTextureForTarget(target);
 51422:     if (!tex)
 51418:         return ErrorInvalidOperation("copyTexImage2D: no texture bound to this target");
 51418: 
 73531:     // copyTexImage2D only generates textures with type = UNSIGNED_BYTE
 73531:     GLenum type = LOCAL_GL_UNSIGNED_BYTE;
 73531: 
 78609:     // check if the memory size of this texture may change with this call
 78609:     bool sizeMayChange = true;
 78609:     size_t face = WebGLTexture::FaceForTarget(target);
 78609:     if (tex->HasImageInfoAt(level, face)) {
 78609:         const WebGLTexture::ImageInfo& imageInfo = tex->ImageInfoAt(level, face);
 78609: 
 88090:         sizeMayChange = width != imageInfo.Width() ||
 88090:                         height != imageInfo.Height() ||
 88090:                         internalformat != imageInfo.Format() ||
 88090:                         type != imageInfo.Type();
 78609:     }
 73531: 
 73531:     if (sizeMayChange) {
 73531:         UpdateWebGLErrorAndClearGLError();
 73531:         CopyTexSubImage2D_base(target, level, internalformat, 0, 0, x, y, width, height, false);
 73531:         GLenum error = LOCAL_GL_NO_ERROR;
 73531:         UpdateWebGLErrorAndClearGLError(&error);
 73531:         if (error) {
 99231:             GenerateWarning("copyTexImage2D generated error %s", ErrorName(error));
 97698:             return;
 73531:         }          
 73531:     } else {
 73531:         CopyTexSubImage2D_base(target, level, internalformat, 0, 0, x, y, width, height, false);
 73531:     }
 73531:     
 73531:     tex->SetImageInfo(target, level, width, height, internalformat, type);
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozCopyTexSubImage2D(WebGLenum target,
 97698:                                    WebGLint level,
 97698:                                    WebGLint xoffset,
 97698:                                    WebGLint yoffset,
 97698:                                    WebGLint x,
 97698:                                    WebGLint y,
 97698:                                    WebGLsizei width,
 97698:                                    WebGLsizei height)
 97698: {
 97698:     CopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
 73531:     return NS_OK;
 32195: }
 32195: 
 97698: void
 42916: WebGLContext::CopyTexSubImage2D(WebGLenum target,
 42916:                                 WebGLint level,
 42916:                                 WebGLint xoffset,
 42916:                                 WebGLint yoffset,
 42916:                                 WebGLint x,
 42916:                                 WebGLint y,
 42916:                                 WebGLsizei width,
 42916:                                 WebGLsizei height)
 32195: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 32195:     switch (target) {
 32195:         case LOCAL_GL_TEXTURE_2D:
 32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X:
 32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
 32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
 32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
 32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
 32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
 32195:             break;
 32195:         default:
 99232:             return ErrorInvalidEnumInfo("copyTexSubImage2D: target", target);
 32195:     }
 32195: 
 60093:     if (level < 0)
 60093:         return ErrorInvalidValue("copyTexSubImage2D: level may not be negative");
 60093: 
 63067:     WebGLsizei maxTextureSize = MaxTextureSizeForTarget(target);
 63067:     if (!(maxTextureSize >> level))
 63067:         return ErrorInvalidValue("copyTexSubImage2D: 2^level exceeds maximum texture size");
 63067: 
 60093:     if (width < 0 || height < 0)
 60093:         return ErrorInvalidValue("copyTexSubImage2D: width and height may not be negative");
 60093: 
 60093:     if (xoffset < 0 || yoffset < 0)
 60093:         return ErrorInvalidValue("copyTexSubImage2D: xoffset and yoffset may not be negative");
 60093: 
 58673:     WebGLTexture *tex = activeBoundTextureForTarget(target);
 58673:     if (!tex)
 58673:         return ErrorInvalidOperation("copyTexSubImage2D: no texture bound to this target");
 58673: 
 63068:     WebGLint face = WebGLTexture::FaceForTarget(target);
 63069:     if (!tex->HasImageInfoAt(level, face))
 78609:         return ErrorInvalidOperation("copyTexSubImage2D: no texture image previously defined for this level and face");
 63069: 
 88090:     const WebGLTexture::ImageInfo &imageInfo = tex->ImageInfoAt(level, face);
 88090:     WebGLsizei texWidth = imageInfo.Width();
 88090:     WebGLsizei texHeight = imageInfo.Height();
 60093: 
 60093:     if (xoffset + width > texWidth || xoffset + width < 0)
 60093:       return ErrorInvalidValue("copyTexSubImage2D: xoffset+width is too large");
 60093: 
 60093:     if (yoffset + height > texHeight || yoffset + height < 0)
 60093:       return ErrorInvalidValue("copyTexSubImage2D: yoffset+height is too large");
 60093: 
 88090:     WebGLenum format = imageInfo.Format();
 79445:     bool texFormatRequiresAlpha = format == LOCAL_GL_RGBA ||
 58673:                                   format == LOCAL_GL_ALPHA ||
 58673:                                   format == LOCAL_GL_LUMINANCE_ALPHA;
 79445:     bool fboFormatHasAlpha = mBoundFramebuffer ? mBoundFramebuffer->ColorAttachment().HasAlpha()
 79445:                                                  : bool(gl->ActualFormat().alpha > 0);
 58673: 
 58673:     if (texFormatRequiresAlpha && !fboFormatHasAlpha)
 58673:         return ErrorInvalidOperation("copyTexSubImage2D: texture format requires an alpha channel "
 58673:                                      "but the framebuffer doesn't have one");
 58673: 
 88091:     if (mBoundFramebuffer)
 88091:         if (!mBoundFramebuffer->CheckAndInitializeRenderbuffers())
 88091:             return ErrorInvalidFramebufferOperation("copyTexSubImage2D: incomplete framebuffer");
 58666: 
 60093:     return CopyTexSubImage2D_base(target, level, format, xoffset, yoffset, x, y, width, height, true);
 32195: }
 32195: 
 32195: 
 32195: NS_IMETHODIMP
 32195: WebGLContext::CreateProgram(nsIWebGLProgram **retval)
 32195: {
 97698:     *retval = CreateProgram().get();
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: already_AddRefed<WebGLProgram>
 97698: WebGLContext::CreateProgram()
 97698: {
 86627:     if (!IsContextStable())
 97698:         return nsnull;
 97698:     nsRefPtr<WebGLProgram> globj = new WebGLProgram(this);
 97698:     return globj.forget();
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 42916: WebGLContext::CreateShader(WebGLenum type, nsIWebGLShader **retval)
 32195: {
 97698:     *retval = CreateShader(type).get();
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: already_AddRefed<WebGLShader>
 97698: WebGLContext::CreateShader(WebGLenum type)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return nsnull;
 51424: 
 43098:     if (type != LOCAL_GL_VERTEX_SHADER &&
 43098:         type != LOCAL_GL_FRAGMENT_SHADER)
 43098:     {
 97698:         ErrorInvalidEnumInfo("createShader: type", type);
 97698:         return nsnull;
 97698:     }
 97698: 
 97698:     nsRefPtr<WebGLShader> shader = new WebGLShader(this, type);
 97698:     return shader.forget();
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozCullFace(WebGLenum face)
 97698: {
 97698:     CullFace(face);
 32195:     return NS_OK;
 32195: }
 32195: 
 97698: void
 47205: WebGLContext::CullFace(WebGLenum face)
 47205: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 47205:     if (!ValidateFaceEnum(face, "cullFace"))
 97698:         return;
 47205: 
 47205:     MakeContextCurrent();
 47205:     gl->fCullFace(face);
 47205: }
 32195: 
 32195: NS_IMETHODIMP
 42472: WebGLContext::DeleteBuffer(nsIWebGLBuffer *bobj)
 32195: {
 97698:     DeleteBuffer(static_cast<WebGLBuffer*>(bobj));
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::DeleteBuffer(WebGLBuffer *buf)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return;
 97698: 
 97698:     if (!ValidateObjectAllowDeletedOrNull("deleteBuffer", buf))
 97698:         return;
 97698: 
 97698:     if (!buf || buf->IsDeleted())
 97698:         return;
 32195: 
 83393:     if (mBoundArrayBuffer == buf)
 97698:         BindBuffer(LOCAL_GL_ARRAY_BUFFER,
 97698:                    static_cast<WebGLBuffer*>(nsnull));
 83393:     if (mBoundElementArrayBuffer == buf)
 97698:         BindBuffer(LOCAL_GL_ELEMENT_ARRAY_BUFFER,
 97698:                    static_cast<WebGLBuffer*>(nsnull));
 83393: 
 99228:     for (int32_t i = 0; i < mGLMaxVertexAttribs; i++) {
 83393:         if (mAttribBuffers[i].buf == buf)
 83393:             mAttribBuffers[i].buf = nsnull;
 83393:     }
 83393: 
 83393:     buf->RequestDelete();
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 42472: WebGLContext::DeleteFramebuffer(nsIWebGLFramebuffer *fbobj)
 32195: {
 97698:     DeleteFramebuffer(static_cast<WebGLFramebuffer*>(fbobj));
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::DeleteFramebuffer(WebGLFramebuffer* fbuf)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return;
 97698: 
 97698:     if (!ValidateObjectAllowDeletedOrNull("deleteFramebuffer", fbuf))
 97698:         return;
 97698: 
 97698:     if (!fbuf || fbuf->IsDeleted())
 97698:         return;
 32195: 
 83393:     fbuf->RequestDelete();
 32195: 
 83393:     if (mBoundFramebuffer == fbuf)
 97698:         BindFramebuffer(LOCAL_GL_FRAMEBUFFER,
 97698:                         static_cast<WebGLFramebuffer*>(nsnull));
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 42472: WebGLContext::DeleteRenderbuffer(nsIWebGLRenderbuffer *rbobj)
 32195: {
 97698:     DeleteRenderbuffer(static_cast<WebGLRenderbuffer*>(rbobj));
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::DeleteRenderbuffer(WebGLRenderbuffer *rbuf)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return;
 97698: 
 97698:     if (!ValidateObjectAllowDeletedOrNull("deleteRenderbuffer", rbuf))
 97698:         return;
 97698: 
 97698:     if (!rbuf || rbuf->IsDeleted())
 97698:         return;
 32195: 
 83396:     if (mBoundFramebuffer)
 83396:         mBoundFramebuffer->DetachRenderbuffer(rbuf);
 83396: 
 83393:     if (mBoundRenderbuffer == rbuf)
 97698:         BindRenderbuffer(LOCAL_GL_RENDERBUFFER,
 97698:                          static_cast<WebGLRenderbuffer*>(nsnull));
 83393: 
 83393:     rbuf->RequestDelete();
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 42472: WebGLContext::DeleteTexture(nsIWebGLTexture *tobj)
 32195: {
 97698:     DeleteTexture(static_cast<WebGLTexture*>(tobj));
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::DeleteTexture(WebGLTexture *tex)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return;
 97698: 
 97698:     if (!ValidateObjectAllowDeletedOrNull("deleteTexture", tex))
 97698:         return;
 97698: 
 97698:     if (!tex || tex->IsDeleted())
 97698:         return;
 32195: 
 83396:     if (mBoundFramebuffer)
 83396:         mBoundFramebuffer->DetachTexture(tex);
 83396: 
 99228:     for (int32_t i = 0; i < mGLMaxTextureUnits; i++) {
 83393:         if ((tex->Target() == LOCAL_GL_TEXTURE_2D && mBound2DTextures[i] == tex) ||
 83393:             (tex->Target() == LOCAL_GL_TEXTURE_CUBE_MAP && mBoundCubeMapTextures[i] == tex))
 83393:         {
 83393:             ActiveTexture(LOCAL_GL_TEXTURE0 + i);
 97698:             BindTexture(tex->Target(), static_cast<WebGLTexture*>(nsnull));
 83393:         }
 83393:     }
 83393:     ActiveTexture(LOCAL_GL_TEXTURE0 + mActiveTexture);
 83393: 
 83393:     tex->RequestDelete();
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 42472: WebGLContext::DeleteProgram(nsIWebGLProgram *pobj)
 32195: {
 97698:     DeleteProgram(static_cast<WebGLProgram*>(pobj));
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::DeleteProgram(WebGLProgram *prog)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return;
 97698: 
 97698:     if (!ValidateObjectAllowDeletedOrNull("deleteProgram", prog))
 97698:         return;
 97698: 
 97698:     if (!prog || prog->IsDeleted())
 97698:         return;
 32195: 
 83393:     prog->RequestDelete();
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 42472: WebGLContext::DeleteShader(nsIWebGLShader *sobj)
 32195: {
 97698:     DeleteShader(static_cast<WebGLShader*>(sobj));
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::DeleteShader(WebGLShader *shader)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return;
 97698: 
 97698:     if (!ValidateObjectAllowDeletedOrNull("deleteShader", shader))
 97698:         return;
 97698: 
 97698:     if (!shader || shader->IsDeleted())
 97698:         return;
 32195: 
 83393:     shader->RequestDelete();
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 42471: WebGLContext::DetachShader(nsIWebGLProgram *pobj, nsIWebGLShader *shobj)
 32195: {
 97698:     DetachShader(static_cast<WebGLProgram*>(pobj),
 97698:                  static_cast<WebGLShader*>(shobj));
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::DetachShader(WebGLProgram *program, WebGLShader *shader)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return;
 97698: 
 97698:     if (!ValidateObject("detachShader: program", program) ||
 97698:         // it's valid to attempt to detach a deleted shader, since it's
 97698:         // still a shader
 97698:         !ValidateObjectAllowDeleted("detashShader: shader", shader))
 97698:         return;
 97698: 
 43098:     if (!program->DetachShader(shader))
 99232:         return ErrorInvalidOperation("detachShader: shader is not attached");
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozDepthFunc(WebGLenum func)
 97698: {
 97698:     DepthFunc(func);
 32195:     return NS_OK;
 32195: }
 32195: 
 97698: void
 46442: WebGLContext::DepthFunc(WebGLenum func)
 46442: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 46443:     if (!ValidateComparisonEnum(func, "depthFunc"))
 97698:         return;
 46442: 
 46442:     MakeContextCurrent();
 46442:     gl->fDepthFunc(func);
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozDepthMask(WebGLboolean b)
 97698: {
 97698:     DepthMask(b);
 46442:     return NS_OK;
 46442: }
 42916: 
 97698: void
 70166: WebGLContext::DepthMask(WebGLboolean b)
 70166: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 70166:     MakeContextCurrent();
 70166:     mDepthWriteMask = b;
 70166:     gl->fDepthMask(b);
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozDepthRange(WebGLclampf zNear, WebGLclampf zFar)
 97698: {
 97698:     DepthRange(zNear, zFar);
 70166:     return NS_OK;
 70166: }
 32195: 
 97698: void
 58670: WebGLContext::DepthRange(WebGLfloat zNear, WebGLfloat zFar)
 58670: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 58670:     if (zNear > zFar)
 58670:         return ErrorInvalidOperation("depthRange: the near value is greater than the far value!");
 58670: 
 58670:     MakeContextCurrent();
 58670:     gl->fDepthRange(zNear, zFar);
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozDisableVertexAttribArray(WebGLuint index)
 97698: {
 97698:     DisableVertexAttribArray(index);
 58670:     return NS_OK;
 58670: }
 32195: 
 97698: void
 42916: WebGLContext::DisableVertexAttribArray(WebGLuint index)
 32195: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 63071:     if (!ValidateAttribIndex(index, "disableVertexAttribArray"))
 97698:         return;
 32195: 
 32195:     MakeContextCurrent();
 32195: 
 51898:     if (index || gl->IsGLES2())
 32195:         gl->fDisableVertexAttribArray(index);
 51898: 
 80486:     mAttribBuffers[index].enabled = false;
 32195: }
 32195: 
 63064: int
 63064: WebGLContext::WhatDoesVertexAttrib0Need()
 51898: {
 63064:   // here we may assume that mCurrentProgram != null
 63064: 
 63064:     // work around Mac OSX crash, see bug 631420
 63064: #ifdef XP_MACOSX
 95058:     if (gl->WorkAroundDriverBugs() &&
 95058:         mAttribBuffers[0].enabled &&
 63064:         !mCurrentProgram->IsAttribInUse(0))
 95058:     {
 63064:         return VertexAttrib0Status::EmulatedUninitializedArray;
 95058:     }
 63064: #endif
 63064: 
 63064:     return (gl->IsGLES2() || mAttribBuffers[0].enabled) ? VertexAttrib0Status::Default
 63064:          : mCurrentProgram->IsAttribInUse(0)            ? VertexAttrib0Status::EmulatedInitializedArray
 63064:                                                         : VertexAttrib0Status::EmulatedUninitializedArray;
 51898: }
 51898: 
 78608: bool
 51898: WebGLContext::DoFakeVertexAttrib0(WebGLuint vertexCount)
 51898: {
 63064:     int whatDoesAttrib0Need = WhatDoesVertexAttrib0Need();
 63064: 
 63064:     if (whatDoesAttrib0Need == VertexAttrib0Status::Default)
 78608:         return true;
 78608: 
 78608:     CheckedUint32 checked_dataSize = CheckedUint32(vertexCount) * 4 * sizeof(WebGLfloat);
 78608:     
 98543:     if (!checked_dataSize.isValid()) {
 78608:         ErrorOutOfMemory("Integer overflow trying to construct a fake vertex attrib 0 array for a draw-operation "
 78608:                          "with %d vertices. Try reducing the number of vertices.", vertexCount);
 78608:         return false;
 78608:     }
 78608:     
 78608:     WebGLuint dataSize = checked_dataSize.value();
 63064: 
 63064:     if (!mFakeVertexAttrib0BufferObject) {
 63064:         gl->fGenBuffers(1, &mFakeVertexAttrib0BufferObject);
 63064:     }
 63064: 
 63064:     // if the VBO status is already exactly what we need, or if the only difference is that it's initialized and
 63064:     // we don't need it to be, then consider it OK
 79445:     bool vertexAttrib0BufferStatusOK =
 63064:         mFakeVertexAttrib0BufferStatus == whatDoesAttrib0Need ||
 63064:         (mFakeVertexAttrib0BufferStatus == VertexAttrib0Status::EmulatedInitializedArray &&
 63064:          whatDoesAttrib0Need == VertexAttrib0Status::EmulatedUninitializedArray);
 63064: 
 63064:     if (!vertexAttrib0BufferStatusOK ||
 63064:         mFakeVertexAttrib0BufferObjectSize < dataSize ||
 63064:         mFakeVertexAttrib0BufferObjectVector[0] != mVertexAttrib0Vector[0] ||
 63064:         mFakeVertexAttrib0BufferObjectVector[1] != mVertexAttrib0Vector[1] ||
 63064:         mFakeVertexAttrib0BufferObjectVector[2] != mVertexAttrib0Vector[2] ||
 63064:         mFakeVertexAttrib0BufferObjectVector[3] != mVertexAttrib0Vector[3])
 63064:     {
 63064:         mFakeVertexAttrib0BufferStatus = whatDoesAttrib0Need;
 63064:         mFakeVertexAttrib0BufferObjectSize = dataSize;
 63064:         mFakeVertexAttrib0BufferObjectVector[0] = mVertexAttrib0Vector[0];
 63064:         mFakeVertexAttrib0BufferObjectVector[1] = mVertexAttrib0Vector[1];
 63064:         mFakeVertexAttrib0BufferObjectVector[2] = mVertexAttrib0Vector[2];
 63064:         mFakeVertexAttrib0BufferObjectVector[3] = mVertexAttrib0Vector[3];
 63064: 
 63064:         gl->fBindBuffer(LOCAL_GL_ARRAY_BUFFER, mFakeVertexAttrib0BufferObject);
 63064: 
 78608:         GLenum error = LOCAL_GL_NO_ERROR;
 78608:         UpdateWebGLErrorAndClearGLError();
 63064: 
 63064:         if (mFakeVertexAttrib0BufferStatus == VertexAttrib0Status::EmulatedInitializedArray) {
 63064:             nsAutoArrayPtr<WebGLfloat> array(new WebGLfloat[4 * vertexCount]);
 51898:             for(size_t i = 0; i < vertexCount; ++i) {
 63064:                 array[4 * i + 0] = mVertexAttrib0Vector[0];
 63064:                 array[4 * i + 1] = mVertexAttrib0Vector[1];
 63064:                 array[4 * i + 2] = mVertexAttrib0Vector[2];
 63064:                 array[4 * i + 3] = mVertexAttrib0Vector[3];
 63064:             }
 63064:             gl->fBufferData(LOCAL_GL_ARRAY_BUFFER, dataSize, array, LOCAL_GL_DYNAMIC_DRAW);
 63064:         } else {
 63064:             gl->fBufferData(LOCAL_GL_ARRAY_BUFFER, dataSize, nsnull, LOCAL_GL_DYNAMIC_DRAW);
 63064:         }
 78608:         UpdateWebGLErrorAndClearGLError(&error);
 63064:         
 63064:         gl->fBindBuffer(LOCAL_GL_ARRAY_BUFFER, mBoundArrayBuffer ? mBoundArrayBuffer->GLName() : 0);
 78608: 
 78608:         // note that we do this error checking and early return AFTER having restored the buffer binding above
 78608:         if (error) {
 78608:             ErrorOutOfMemory("Ran out of memory trying to construct a fake vertex attrib 0 array for a draw-operation "
 78608:                              "with %d vertices. Try reducing the number of vertices.", vertexCount);
 78608:             return false;
 78608:         }
 63064:     }
 63064: 
 63064:     gl->fBindBuffer(LOCAL_GL_ARRAY_BUFFER, mFakeVertexAttrib0BufferObject);
 63064:     gl->fVertexAttribPointer(0, 4, LOCAL_GL_FLOAT, LOCAL_GL_FALSE, 0, 0);
 78608:     
 78608:     return true;
 51898: }
 51898: 
 51898: void
 51898: WebGLContext::UndoFakeVertexAttrib0()
 51898: {
 63064:     int whatDoesAttrib0Need = WhatDoesVertexAttrib0Need();
 63064: 
 63064:     if (whatDoesAttrib0Need == VertexAttrib0Status::Default)
 51898:         return;
 51898: 
 63064:     gl->fBindBuffer(LOCAL_GL_ARRAY_BUFFER, mAttribBuffers[0].buf ? mAttribBuffers[0].buf->GLName() : 0);
 51898:     gl->fVertexAttribPointer(0,
 51898:                              mAttribBuffers[0].size,
 51898:                              mAttribBuffers[0].type,
 51898:                              mAttribBuffers[0].normalized,
 51898:                              mAttribBuffers[0].stride,
 87420:                              reinterpret_cast<const GLvoid *>(mAttribBuffers[0].byteOffset));
 52048: 
 52048:     gl->fBindBuffer(LOCAL_GL_ARRAY_BUFFER, mBoundArrayBuffer ? mBoundArrayBuffer->GLName() : 0);
 51898: }
 51898: 
 79445: bool
 51422: WebGLContext::NeedFakeBlack()
 51422: {
 51422:     // handle this case first, it's the generic case
 51422:     if (mFakeBlackStatus == DoNotNeedFakeBlack)
 80486:         return false;
 51422: 
 51422:     if (mFakeBlackStatus == DontKnowIfNeedFakeBlack) {
 99228:         for (int32_t i = 0; i < mGLMaxTextureUnits; ++i) {
 51422:             if ((mBound2DTextures[i] && mBound2DTextures[i]->NeedFakeBlack()) ||
 51422:                 (mBoundCubeMapTextures[i] && mBoundCubeMapTextures[i]->NeedFakeBlack()))
 51422:             {
 51422:                 mFakeBlackStatus = DoNeedFakeBlack;
 51422:                 break;
 51422:             }
 51422:         }
 51422: 
 51422:         // we have exhausted all cases where we do need fakeblack, so if the status is still unknown,
 51422:         // that means that we do NOT need it.
 51422:         if (mFakeBlackStatus == DontKnowIfNeedFakeBlack)
 51422:             mFakeBlackStatus = DoNotNeedFakeBlack;
 51422:     }
 51422: 
 51422:     return mFakeBlackStatus == DoNeedFakeBlack;
 51422: }
 51422: 
 51422: void
 51422: WebGLContext::BindFakeBlackTextures()
 51422: {
 51422:     // this is the generic case: try to return early
 51422:     if (!NeedFakeBlack())
 51422:         return;
 51422: 
 51422:     if (!mBlackTexturesAreInitialized) {
 81132:         GLuint bound2DTex = 0;
 81132:         GLuint boundCubeTex = 0;
 81132:         gl->fGetIntegerv(LOCAL_GL_TEXTURE_BINDING_2D, (GLint*) &bound2DTex);
 81132:         gl->fGetIntegerv(LOCAL_GL_TEXTURE_BINDING_CUBE_MAP, (GLint*) &boundCubeTex);
 81132: 
 99228:         const uint8_t black[] = {0, 0, 0, 255};
 51422: 
 51422:         gl->fGenTextures(1, &mBlackTexture2D);
 51422:         gl->fBindTexture(LOCAL_GL_TEXTURE_2D, mBlackTexture2D);
 51422:         gl->fTexImage2D(LOCAL_GL_TEXTURE_2D, 0, LOCAL_GL_RGBA, 1, 1,
 51422:                         0, LOCAL_GL_RGBA, LOCAL_GL_UNSIGNED_BYTE, &black);
 51422: 
 51422:         gl->fGenTextures(1, &mBlackTextureCubeMap);
 51422:         gl->fBindTexture(LOCAL_GL_TEXTURE_CUBE_MAP, mBlackTextureCubeMap);
 51422:         for (WebGLuint i = 0; i < 6; ++i) {
 51422:             gl->fTexImage2D(LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, LOCAL_GL_RGBA, 1, 1,
 51422:                             0, LOCAL_GL_RGBA, LOCAL_GL_UNSIGNED_BYTE, &black);
 51422:         }
 51422: 
 81132:         // Reset bound textures
 81132:         gl->fBindTexture(LOCAL_GL_TEXTURE_2D, bound2DTex);
 81132:         gl->fBindTexture(LOCAL_GL_TEXTURE_CUBE_MAP, boundCubeTex);
 51422: 
 80486:         mBlackTexturesAreInitialized = true;
 51422:     }
 51422: 
 99228:     for (int32_t i = 0; i < mGLMaxTextureUnits; ++i) {
 51422:         if (mBound2DTextures[i] && mBound2DTextures[i]->NeedFakeBlack()) {
 51422:             gl->fActiveTexture(LOCAL_GL_TEXTURE0 + i);
 51422:             gl->fBindTexture(LOCAL_GL_TEXTURE_2D, mBlackTexture2D);
 51422:         }
 51422:         if (mBoundCubeMapTextures[i] && mBoundCubeMapTextures[i]->NeedFakeBlack()) {
 51422:             gl->fActiveTexture(LOCAL_GL_TEXTURE0 + i);
 51422:             gl->fBindTexture(LOCAL_GL_TEXTURE_CUBE_MAP, mBlackTextureCubeMap);
 51422:         }
 51422:     }
 51422: }
 51422: 
 51422: void
 51422: WebGLContext::UnbindFakeBlackTextures()
 51422: {
 51422:     // this is the generic case: try to return early
 51422:     if (!NeedFakeBlack())
 51422:         return;
 51422: 
 99228:     for (int32_t i = 0; i < mGLMaxTextureUnits; ++i) {
 51422:         if (mBound2DTextures[i] && mBound2DTextures[i]->NeedFakeBlack()) {
 51422:             gl->fActiveTexture(LOCAL_GL_TEXTURE0 + i);
 51422:             gl->fBindTexture(LOCAL_GL_TEXTURE_2D, mBound2DTextures[i]->GLName());
 51422:         }
 51422:         if (mBoundCubeMapTextures[i] && mBoundCubeMapTextures[i]->NeedFakeBlack()) {
 51422:             gl->fActiveTexture(LOCAL_GL_TEXTURE0 + i);
 51422:             gl->fBindTexture(LOCAL_GL_TEXTURE_CUBE_MAP, mBoundCubeMapTextures[i]->GLName());
 51422:         }
 51422:     }
 51422: 
 51422:     gl->fActiveTexture(LOCAL_GL_TEXTURE0 + mActiveTexture);
 51422: }
 51422: 
 32195: NS_IMETHODIMP
 97698: WebGLContext::MozDrawArrays(GLenum mode, WebGLint first, WebGLsizei count)
 97698: {
 97698:     DrawArrays(mode, first, count);
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 43009: WebGLContext::DrawArrays(GLenum mode, WebGLint first, WebGLsizei count)
 32195: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 47813:     if (!ValidateDrawModeEnum(mode, "drawArrays: mode"))
 97698:         return;
 32195: 
 43333:     if (first < 0 || count < 0)
 99232:         return ErrorInvalidValue("drawArrays: negative first or count");
 43333: 
 70170:     if (!ValidateStencilParamsForDrawCall())
 97698:         return;
 70170: 
 58219:     // If count is 0, there's nothing to do.
 58219:     if (count == 0)
 97698:         return;
 58219: 
 43098:     // If there is no current program, this is silently ignored.
 43098:     // Any checks below this depend on a program being available.
 43098:     if (!mCurrentProgram)
 97698:         return;
 43098: 
 99228:     int32_t maxAllowedCount = 0;
 61295:     if (!ValidateBuffers(&maxAllowedCount, "drawArrays"))
 97698:         return;
 61295: 
 47204:     CheckedInt32 checked_firstPlusCount = CheckedInt32(first) + count;
 47204: 
 98543:     if (!checked_firstPlusCount.isValid())
 47204:         return ErrorInvalidOperation("drawArrays: overflow in first+count");
 47204: 
 61295:     if (checked_firstPlusCount.value() > maxAllowedCount)
 61295:         return ErrorInvalidOperation("drawArrays: bound vertex attribute buffers do not have sufficient size for given first and count");
 47809: 
 32195:     MakeContextCurrent();
 32195: 
 70168:     if (mBoundFramebuffer) {
 70168:         if (!mBoundFramebuffer->CheckAndInitializeRenderbuffers())
 88091:             return ErrorInvalidFramebufferOperation("drawArrays: incomplete framebuffer");
 70168:     } else {
 70168:         EnsureBackbufferClearedAsNeeded();
 70168:     }
 56959: 
 51422:     BindFakeBlackTextures();
 78608:     if (!DoFakeVertexAttrib0(checked_firstPlusCount.value()))
 97698:         return;
 51898: 
 95823:     SetupContextLossTimer();
 43009:     gl->fDrawArrays(mode, first, count);
 51898: 
 51898:     UndoFakeVertexAttrib0();
 51422:     UnbindFakeBlackTextures();
 32195: 
 70168:     mBackbufferClearingStatus = BackbufferClearingStatus::HasBeenDrawnTo;
 32195:     Invalidate();
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozDrawElements(WebGLenum mode, WebGLsizei count, WebGLenum type, WebGLintptr byteOffset)
 97698: {
 97698:     DrawElements(mode, count, type, byteOffset);
 32195:     return NS_OK;
 32195: }
 32195: 
 97698: void
 97698: WebGLContext::DrawElements(WebGLenum mode, WebGLsizei count, WebGLenum type,
 97698:                            WebGLintptr byteOffset)
 32195: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 47813:     if (!ValidateDrawModeEnum(mode, "drawElements: mode"))
 97698:         return;
 32195: 
 43333:     if (count < 0 || byteOffset < 0)
 99232:         return ErrorInvalidValue("drawElements: negative count or offset");
 43333: 
 70170:     if (!ValidateStencilParamsForDrawCall())
 97698:         return;
 70170: 
 58219:     // If count is 0, there's nothing to do.
 58219:     if (count == 0)
 97698:         return;
 58219: 
 47204:     CheckedUint32 checked_byteCount;
 47204: 
 43333:     if (type == LOCAL_GL_UNSIGNED_SHORT) {
 47204:         checked_byteCount = 2 * CheckedUint32(count);
 43009:         if (byteOffset % 2 != 0)
 99232:             return ErrorInvalidOperation("drawElements: invalid byteOffset for UNSIGNED_SHORT (must be a multiple of 2)");
 43333:     } else if (type == LOCAL_GL_UNSIGNED_BYTE) {
 47204:         checked_byteCount = count;
 43333:     } else {
 99232:         return ErrorInvalidEnum("drawElements: type must be UNSIGNED_SHORT or UNSIGNED_BYTE");
 32195:     }
 32195: 
 98543:     if (!checked_byteCount.isValid())
 99232:         return ErrorInvalidValue("drawElements: overflow in byteCount");
 47204: 
 43098:     // If there is no current program, this is silently ignored.
 43098:     // Any checks below this depend on a program being available.
 43098:     if (!mCurrentProgram)
 97698:         return;
 43098: 
 43333:     if (!mBoundElementArrayBuffer)
 99232:         return ErrorInvalidOperation("drawElements: must have element array buffer binding");
 43333: 
 57469:     if (!mBoundElementArrayBuffer->Data())
 57469:         return ErrorInvalidOperation("drawElements: bound element array buffer doesn't have any data");
 57469: 
 47204:     CheckedUint32 checked_neededByteCount = checked_byteCount + byteOffset;
 47204: 
 98543:     if (!checked_neededByteCount.isValid())
 99232:         return ErrorInvalidOperation("drawElements: overflow in byteOffset+byteCount");
 43333: 
 47204:     if (checked_neededByteCount.value() > mBoundElementArrayBuffer->ByteLength())
 99232:         return ErrorInvalidOperation("drawElements: bound element array buffer is too small for given count and offset");
 43333: 
 99228:     int32_t maxAllowedCount = 0;
 61295:     if (!ValidateBuffers(&maxAllowedCount, "drawElements"))
 97698:       return;
 61295: 
 99228:     int32_t maxIndex
 61295:       = type == LOCAL_GL_UNSIGNED_SHORT
 61295:         ? mBoundElementArrayBuffer->FindMaxUshortElement()
 61295:         : mBoundElementArrayBuffer->FindMaxUbyteElement();
 61295: 
 61295:     CheckedInt32 checked_maxIndexPlusOne = CheckedInt32(maxIndex) + 1;
 61295: 
 98543:     if (!checked_maxIndexPlusOne.isValid() ||
 61295:         checked_maxIndexPlusOne.value() > maxAllowedCount)
 61295:     {
 61295:         // the index array contains invalid indices for the current drawing state, but they
 61295:         // might not be used by the present drawElements call, depending on first and count.
 61295: 
 99228:         int32_t maxIndexInSubArray
 61295:           = type == LOCAL_GL_UNSIGNED_SHORT
 61295:             ? mBoundElementArrayBuffer->FindMaxElementInSubArray<GLushort>(count, byteOffset)
 61295:             : mBoundElementArrayBuffer->FindMaxElementInSubArray<GLubyte>(count, byteOffset);
 61295: 
 61295:         CheckedInt32 checked_maxIndexInSubArrayPlusOne = CheckedInt32(maxIndexInSubArray) + 1;
 61295: 
 98543:         if (!checked_maxIndexInSubArrayPlusOne.isValid() ||
 61295:             checked_maxIndexInSubArrayPlusOne.value() > maxAllowedCount)
 61295:         {
 61295:             return ErrorInvalidOperation(
 61295:                 "DrawElements: bound vertex attribute buffers do not have sufficient "
 47809:                 "size for given indices from the bound element array");
 43009:         }
 61295:     }
 43009: 
 32195:     MakeContextCurrent();
 32195: 
 70168:     if (mBoundFramebuffer) {
 70168:         if (!mBoundFramebuffer->CheckAndInitializeRenderbuffers())
 88091:             return ErrorInvalidFramebufferOperation("drawElements: incomplete framebuffer");
 70168:     } else {
 70168:         EnsureBackbufferClearedAsNeeded();
 70168:     }
 56959: 
 51422:     BindFakeBlackTextures();
 78608:     if (!DoFakeVertexAttrib0(checked_maxIndexPlusOne.value()))
 97698:         return;
 51898: 
 95823:     SetupContextLossTimer();
 87420:     gl->fDrawElements(mode, count, type, reinterpret_cast<GLvoid*>(byteOffset));
 51898: 
 51898:     UndoFakeVertexAttrib0();
 51422:     UnbindFakeBlackTextures();
 32195: 
 70168:     mBackbufferClearingStatus = BackbufferClearingStatus::HasBeenDrawnTo;
 32195:     Invalidate();
 97698: }
 97698: 
 97698: NS_IMETHODIMP WebGLContext::MozEnable(WebGLenum cap)
 97698: {
 97698:     Enable(cap);
 32195:     return NS_OK;
 32195: }
 32195: 
 97698: void
 97698: WebGLContext::Enable(WebGLenum cap)
 43317: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 46443:     if (!ValidateCapabilityEnum(cap, "enable"))
 97698:         return;
 43317: 
 70166:     switch(cap) {
 70166:         case LOCAL_GL_SCISSOR_TEST:
 70166:             mScissorTestEnabled = 1;
 70166:             break;
 70166:         case LOCAL_GL_DITHER:
 70166:             mDitherEnabled = 1;
 70166:             break;
 70166:     }
 70166: 
 43317:     MakeContextCurrent();
 43317:     gl->fEnable(cap);
 97698: }
 97698: 
 97698: NS_IMETHODIMP WebGLContext::MozDisable(WebGLenum cap)
 97698: {
 97698:     Disable(cap);
 43317:     return NS_OK;
 43317: }
 43317: 
 97698: void
 97698: WebGLContext::Disable(WebGLenum cap)
 43317: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 46443:     if (!ValidateCapabilityEnum(cap, "disable"))
 97698:         return;
 43317: 
 70166:     switch(cap) {
 70166:         case LOCAL_GL_SCISSOR_TEST:
 70166:             mScissorTestEnabled = 0;
 70166:             break;
 70166:         case LOCAL_GL_DITHER:
 70166:             mDitherEnabled = 0;
 70166:             break;
 70166:     }
 70166: 
 43317:     MakeContextCurrent();
 43317:     gl->fDisable(cap);
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozEnableVertexAttribArray(WebGLuint index)
 97698: {
 97698:     EnableVertexAttribArray(index);
 43317:     return NS_OK;
 43317: }
 32195: 
 97698: void
 42916: WebGLContext::EnableVertexAttribArray(WebGLuint index)
 32195: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 63071:     if (!ValidateAttribIndex(index, "enableVertexAttribArray"))
 97698:         return;
 32195: 
 32195:     MakeContextCurrent();
 32195: 
 32195:     gl->fEnableVertexAttribArray(index);
 80486:     mAttribBuffers[index].enabled = true;
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 42916: WebGLContext::FramebufferRenderbuffer(WebGLenum target, WebGLenum attachment, WebGLenum rbtarget, nsIWebGLRenderbuffer *rbobj)
 32195: {
 97698:     FramebufferRenderbuffer(target, attachment, rbtarget,
 97698:                             static_cast<WebGLRenderbuffer*>(rbobj));
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::FramebufferRenderbuffer(WebGLenum target, WebGLenum attachment, WebGLenum rbtarget, WebGLRenderbuffer *wrb)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 60039:     if (!mBoundFramebuffer)
 60039:         return ErrorInvalidOperation("framebufferRenderbuffer: cannot modify framebuffer 0");
 60039: 
 97698:     return mBoundFramebuffer->FramebufferRenderbuffer(target, attachment, rbtarget, wrb);
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 42916: WebGLContext::FramebufferTexture2D(WebGLenum target,
 42916:                                    WebGLenum attachment,
 42916:                                    WebGLenum textarget,
 42472:                                    nsIWebGLTexture *tobj,
 42916:                                    WebGLint level)
 32195: {
 97698:     FramebufferTexture2D(target, attachment, textarget,
 97698:                          static_cast<WebGLTexture*>(tobj), level);
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::FramebufferTexture2D(WebGLenum target,
 97698:                                    WebGLenum attachment,
 97698:                                    WebGLenum textarget,
 97698:                                    WebGLTexture *tobj,
 97698:                                    WebGLint level)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 79447:     if (mBoundFramebuffer)
 79447:         return mBoundFramebuffer->FramebufferTexture2D(target, attachment, textarget, tobj, level);
 79447:     else
 78715:         return ErrorInvalidOperation("framebufferTexture2D: cannot modify framebuffer 0");
 32195: }
 32195: 
 32195: GL_SAME_METHOD_0(Flush, Flush)
 32195: 
 32195: GL_SAME_METHOD_0(Finish, Finish)
 32195: 
 46442: NS_IMETHODIMP
 97698: WebGLContext::MozFrontFace(WebGLenum mode)
 97698: {
 97698:     FrontFace(mode);
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 46442: WebGLContext::FrontFace(WebGLenum mode)
 46442: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 46442:     switch (mode) {
 46442:         case LOCAL_GL_CW:
 46442:         case LOCAL_GL_CCW:
 46442:             break;
 46442:         default:
 47813:             return ErrorInvalidEnumInfo("frontFace: mode", mode);
 46442:     }
 46442: 
 46442:     MakeContextCurrent();
 46442:     gl->fFrontFace(mode);
 46442: }
 32195: 
 32195: // returns an object: { size: ..., type: ..., name: ... }
 32195: NS_IMETHODIMP
 99228: WebGLContext::GetActiveAttrib(nsIWebGLProgram *pobj, uint32_t index, nsIWebGLActiveInfo **retval)
 32195: {
 97698:     *retval = GetActiveAttrib(static_cast<WebGLProgram*>(pobj), index).get();
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: already_AddRefed<WebGLActiveInfo>
 99228: WebGLContext::GetActiveAttrib(WebGLProgram *prog, uint32_t index)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return nsnull;
 97698: 
 97698:     if (!ValidateObject("getActiveAttrib: program", prog))
 97698:         return nsnull;
 42471: 
 32195:     MakeContextCurrent();
 32195: 
 32195:     GLint len = 0;
 97698:     WebGLuint progname = prog->GLName();;
 42472:     gl->fGetProgramiv(progname, LOCAL_GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, &len);
 51424:     if (len == 0)
 97698:         return nsnull;
 32195: 
 43474:     nsAutoArrayPtr<char> name(new char[len]);
 72540:     GLint attrsize = 0;
 72540:     GLuint attrtype = 0;
 72540: 
 72540:     gl->fGetActiveAttrib(progname, index, len, &len, &attrsize, &attrtype, name);
 43333:     if (attrsize == 0 || attrtype == 0) {
 97698:         return nsnull;
 43333:     }
 32195: 
 91439:     nsCString reverseMappedName;
 91439:     prog->ReverseMapIdentifier(nsDependentCString(name), &reverseMappedName);
 91439: 
 97698:     nsRefPtr<WebGLActiveInfo> retActiveInfo =
 97698:         new WebGLActiveInfo(attrsize, attrtype, reverseMappedName);
 97698:     return retActiveInfo.forget();
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozGenerateMipmap(WebGLenum target)
 97698: {
 97698:     GenerateMipmap(target);
 32195:     return NS_OK;
 32195: }
 32195: 
 97698: void
 46442: WebGLContext::GenerateMipmap(WebGLenum target)
 46442: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 46443:     if (!ValidateTextureTargetEnum(target, "generateMipmap"))
 97698:         return;
 46442: 
 51418:     WebGLTexture *tex = activeBoundTextureForTarget(target);
 51418: 
 51422:     if (!tex)
 94682:         return ErrorInvalidOperation("generateMipmap: No texture is bound to this target.");
 94682: 
 94682:     if (!tex->HasImageInfoAt(0, 0))
 94682:         return ErrorInvalidOperation("generateMipmap: Level zero of texture is not defined.");
 94682: 
 94682:     if (!tex->IsFirstImagePowerOfTwo())
 94682:         return ErrorInvalidOperation("generateMipmap: Level zero of texture does not have power-of-two width and height.");
 94682: 
 94682:     GLenum format = tex->ImageInfoAt(0, 0).Format();
 94682:     if (IsTextureFormatCompressed(format))
 94682:         return ErrorInvalidOperation("generateMipmap: Texture data at level zero is compressed.");
 94682: 
 94682:     if (!tex->AreAllLevel0ImageInfosEqual())
 94682:         return ErrorInvalidOperation("generateMipmap: The six faces of this cube map have different dimensions, format, or type.");
 51418: 
 51422:     tex->SetGeneratedMipmap();
 51422: 
 46442:     MakeContextCurrent();
 95763: 
 95763:     if (gl->WorkAroundDriverBugs()) {
 95763:         // bug 696495 - to work around failures in the texture-mips.html test on various drivers, we
 95763:         // set the minification filter before calling glGenerateMipmap. This should not carry a significant performance
 95763:         // overhead so we do it unconditionally.
 95763:         //
 95763:         // note that the choice of GL_NEAREST_MIPMAP_NEAREST really matters. See Chromium bug 101105.
 95763:         gl->fTexParameteri(target, LOCAL_GL_TEXTURE_MIN_FILTER, LOCAL_GL_NEAREST_MIPMAP_NEAREST);
 46442:         gl->fGenerateMipmap(target);
 95763:         gl->fTexParameteri(target, LOCAL_GL_TEXTURE_MIN_FILTER, tex->MinFilter());
 95763:     } else {
 95763:         gl->fGenerateMipmap(target);
 95763:     }
 46442: }
 46442: 
 46442: NS_IMETHODIMP
 99228: WebGLContext::GetActiveUniform(nsIWebGLProgram *pobj, uint32_t index, nsIWebGLActiveInfo **retval)
 32195: {
 97698:     *retval = GetActiveUniform(static_cast<WebGLProgram*>(pobj), index).get();
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: already_AddRefed<WebGLActiveInfo>
 99228: WebGLContext::GetActiveUniform(WebGLProgram *prog, uint32_t index)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return nsnull;
 97698: 
 97698:     if (!ValidateObject("getActiveUniform: program", prog))
 97698:         return nsnull;
 42471: 
 32195:     MakeContextCurrent();
 32195: 
 32195:     GLint len = 0;
 97698:     WebGLuint progname = prog->GLName();
 42472:     gl->fGetProgramiv(progname, LOCAL_GL_ACTIVE_UNIFORM_MAX_LENGTH, &len);
 51424:     if (len == 0)
 97698:         return nsnull;
 43474: 
 91439:     nsAutoArrayPtr<char> name(new char[len]);
 91439: 
 91439:     GLint usize = 0;
 91439:     GLuint utype = 0;
 91439: 
 91439:     gl->fGetActiveUniform(progname, index, len, &len, &usize, &utype, name);
 91439:     if (len == 0 || usize == 0 || utype == 0) {
 97698:         return nsnull;
 43474:     }
 32195: 
 91439:     nsCString reverseMappedName;
 91439:     prog->ReverseMapIdentifier(nsDependentCString(name), &reverseMappedName);
 91439: 
 47814:     // OpenGL ES 2.0 specifies that if foo is a uniform array, GetActiveUniform returns its name as "foo[0]".
 47814:     // See section 2.10 page 35 in the OpenGL ES 2.0.24 specification:
 47814:     //
 47814:     // > If the active uniform is an array, the uniform name returned in name will always
 47814:     // > be the name of the uniform array appended with "[0]".
 47814:     //
 47814:     // There is no such requirement in the OpenGL (non-ES) spec and indeed we have OpenGL implementations returning
 47814:     // "foo" instead of "foo[0]". So, when implementing WebGL on top of desktop OpenGL, we must check if the
 47814:     // returned name ends in [0], and if it doesn't, append that.
 47814:     //
 47814:     // In principle we don't need to do that on OpenGL ES, but this is such a tricky difference between the ES and non-ES
 47814:     // specs that it seems probable that some ES implementers will overlook it. Since the work-around is quite cheap,
 47814:     // we do it unconditionally.
 91439:     if (usize > 1 && reverseMappedName.CharAt(reverseMappedName.Length()-1) != ']')
 91439:         reverseMappedName.AppendLiteral("[0]");
 91439: 
 97698:     nsRefPtr<WebGLActiveInfo> retActiveInfo =
 97698:         new WebGLActiveInfo(usize, utype, reverseMappedName);
 97698:     return retActiveInfo.forget();
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 43637: WebGLContext::GetAttachedShaders(nsIWebGLProgram *pobj, nsIVariant **retval)
 32195: {
 97698:     Nullable< nsTArray<WebGLShader*> > arr;
 97698:     GetAttachedShaders(static_cast<WebGLProgram*>(pobj), arr);
 97698:     if (arr.IsNull()) {
 97698:         *retval = nsnull;
 80903:         return NS_OK;
 97698:     }
 43637: 
 43637:     nsCOMPtr<nsIWritableVariant> wrval = do_CreateInstance("@mozilla.org/variant;1");
 43637:     NS_ENSURE_TRUE(wrval, NS_ERROR_FAILURE);
 32195: 
 97698:     if (arr.Value().IsEmpty()) {
 43637:         wrval->SetAsEmptyArray();
 53696:     } else {
 43637:         wrval->SetAsArray(nsIDataType::VTYPE_INTERFACE,
 43637:                           &NS_GET_IID(nsIWebGLShader),
 97698:                           arr.Value().Length(),
 43637:                           const_cast<void*>( // @#$% SetAsArray doesn't accept a const void*
 43637:                               static_cast<const void*>(
 97698:                                   arr.Value().Elements()
 43637:                               )
 43637:                           )
 43637:                           );
 43637:     }
 43637: 
 97698:     wrval.forget(retval);
 32195:     return NS_OK;
 32195: }
 32195: 
 97698: void
 97698: WebGLContext::GetAttachedShaders(WebGLProgram *prog,
 97698:                                  Nullable< nsTArray<WebGLShader*> > &retval)
 97698: {
 97698:     retval.SetNull();
 97698:     if (!IsContextStable())
 97698:         return;
 97698: 
 97698:     if (!ValidateObjectAllowNull("getAttachedShaders", prog))
 97698:         return;
 97698: 
 97698:     MakeContextCurrent();
 97698: 
 97698:     if (!prog) {
 97698:         retval.SetNull();
 97698:         ErrorInvalidValue("getAttachedShaders: invalid program");
 97698:     } else if (prog->AttachedShaders().Length() == 0) {
 97698:         retval.SetValue().TruncateLength(0);
 97698:     } else {
 97698:         retval.SetValue().AppendElements(prog->AttachedShaders());
 97698:     }
 97698: }
 97698: 
 32195: NS_IMETHODIMP
 42471: WebGLContext::GetAttribLocation(nsIWebGLProgram *pobj,
 32195:                                 const nsAString& name,
 99228:                                 WebGLint *retval)
 32195: {
 97698:     *retval = GetAttribLocation(static_cast<WebGLProgram*>(pobj), name);
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: WebGLint
 97698: WebGLContext::GetAttribLocation(WebGLProgram *prog, const nsAString& name)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return -1;
 97698: 
 97698:     if (!ValidateObject("getAttribLocation: program", prog))
 97698:         return -1;
 42471: 
 78164:     if (!ValidateGLSLVariableName(name, "getAttribLocation"))
 97698:         return -1; 
 74514: 
 91439:     NS_LossyConvertUTF16toASCII cname(name);
 91439:     nsCString mappedName;
 91439:     prog->MapIdentifier(cname, &mappedName);
 91439: 
 97698:     WebGLuint progname = prog->GLName();
 97698: 
 32195:     MakeContextCurrent();
 97698:     return gl->fGetAttribLocation(progname, mappedName.get());
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 99228: WebGLContext::GetParameter(uint32_t pname, JSContext* cx, JS::Value *retval)
 97698: {
 97819:     ErrorResult rv;
 97698:     JS::Value v = GetParameter(cx, pname, rv);
 97819:     if (rv.Failed())
 97819:         return rv.ErrorCode();
 97698:     *retval = v;
 32195:     return NS_OK;
 32195: }
 32195: 
 97698: static JS::Value
 97819: StringValue(JSContext* cx, const char* chars, ErrorResult& rv)
 97698: {
 97698:     JSString* str = JS_NewStringCopyZ(cx, chars);
 97698:     if (!str) {
 97819:         rv.Throw(NS_ERROR_OUT_OF_MEMORY);
 97698:         return JS::NullValue();
 97698:     }
 97698: 
 97698:     return JS::StringValue(str);
 97698: }
 97698: 
 97698: JS::Value
 97819: WebGLContext::GetParameter(JSContext* cx, WebGLenum pname, ErrorResult& rv)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return JS::NullValue();
 32195: 
 32195:     MakeContextCurrent();
 32195:     
 80338:     if (MinCapabilityMode()) {
 80338:         switch(pname) {
 80338:             //
 80338:             // Single-value params
 80338:             //
 80338:                 
 80338: // int
 80338:             case LOCAL_GL_MAX_VERTEX_ATTRIBS:
 97698:                 return JS::Int32Value(MINVALUE_GL_MAX_VERTEX_ATTRIBS);
 97698:             
 97698:             case LOCAL_GL_MAX_FRAGMENT_UNIFORM_VECTORS:
 97698:                 return JS::Int32Value(MINVALUE_GL_MAX_FRAGMENT_UNIFORM_VECTORS);
 97698:             
 97698:             case LOCAL_GL_MAX_VERTEX_UNIFORM_VECTORS:
 97698:                 return JS::Int32Value(MINVALUE_GL_MAX_VERTEX_UNIFORM_VECTORS);
 97698:             
 97698:             case LOCAL_GL_MAX_VARYING_VECTORS:
 97698:                 return JS::Int32Value(MINVALUE_GL_MAX_VARYING_VECTORS);
 97698:             
 97698:             case LOCAL_GL_MAX_TEXTURE_SIZE:
 97698:                 return JS::Int32Value(MINVALUE_GL_MAX_TEXTURE_SIZE);
 97698:             
 97698:             case LOCAL_GL_MAX_CUBE_MAP_TEXTURE_SIZE:
 97698:                 return JS::Int32Value(MINVALUE_GL_MAX_CUBE_MAP_TEXTURE_SIZE);
 97698:             
 97698:             case LOCAL_GL_MAX_TEXTURE_IMAGE_UNITS:
 97698:                 return JS::Int32Value(MINVALUE_GL_MAX_TEXTURE_IMAGE_UNITS);
 97698:             
 97698:             case LOCAL_GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS:
 97698:                 return JS::Int32Value(MINVALUE_GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS);
 97698:                 
 97698:             case LOCAL_GL_MAX_RENDERBUFFER_SIZE:
 97698:                 return JS::Int32Value(MINVALUE_GL_MAX_RENDERBUFFER_SIZE);
 97698:             
 97698:             default:
 97698:                 // Return the real value; we're not overriding this one
 80338:                 break;
 80338:         }
 80338:     }
 80338:     
 32195:     switch (pname) {
 32195:         //
 32195:         // String params
 32195:         //
 32195:         case LOCAL_GL_VENDOR:
 97698:             return StringValue(cx, "Mozilla", rv);
 32195:         case LOCAL_GL_RENDERER:
 97698:             return StringValue(cx, "Mozilla", rv);
 32195:         case LOCAL_GL_VERSION:
 97698:             return StringValue(cx, "WebGL 1.0", rv);
 32195:         case LOCAL_GL_SHADING_LANGUAGE_VERSION:
 97698:             return StringValue(cx, "WebGL GLSL ES 1.0", rv);
 32195: 
 32195:         //
 32195:         // Single-value params
 32195:         //
 32195: 
 97698:         // unsigned int
 32195:         case LOCAL_GL_CULL_FACE_MODE:
 32195:         case LOCAL_GL_FRONT_FACE:
 32195:         case LOCAL_GL_ACTIVE_TEXTURE:
 32195:         case LOCAL_GL_STENCIL_FUNC:
 32195:         case LOCAL_GL_STENCIL_FAIL:
 32195:         case LOCAL_GL_STENCIL_PASS_DEPTH_FAIL:
 32195:         case LOCAL_GL_STENCIL_PASS_DEPTH_PASS:
 32195:         case LOCAL_GL_STENCIL_BACK_FUNC:
 32195:         case LOCAL_GL_STENCIL_BACK_FAIL:
 32195:         case LOCAL_GL_STENCIL_BACK_PASS_DEPTH_FAIL:
 32195:         case LOCAL_GL_STENCIL_BACK_PASS_DEPTH_PASS:
 32195:         case LOCAL_GL_DEPTH_FUNC:
 32195:         case LOCAL_GL_BLEND_SRC_RGB:
 32195:         case LOCAL_GL_BLEND_SRC_ALPHA:
 32195:         case LOCAL_GL_BLEND_DST_RGB:
 32195:         case LOCAL_GL_BLEND_DST_ALPHA:
 32195:         case LOCAL_GL_BLEND_EQUATION_RGB:
 32195:         case LOCAL_GL_BLEND_EQUATION_ALPHA:
 97698:         case LOCAL_GL_GENERATE_MIPMAP_HINT:
 97698:         {
 97698:             GLint i = 0;
 97698:             gl->fGetIntegerv(pname, &i);
 99240:             return JS::NumberValue(uint32_t(i));
 97698:         }
 97698:         // int
 97698:         case LOCAL_GL_STENCIL_CLEAR_VALUE:
 97698:         case LOCAL_GL_STENCIL_REF:
 97698:         case LOCAL_GL_STENCIL_BACK_REF:
 46442:         case LOCAL_GL_UNPACK_ALIGNMENT:
 46442:         case LOCAL_GL_PACK_ALIGNMENT:
 32195:         case LOCAL_GL_SUBPIXEL_BITS:
 32195:         case LOCAL_GL_MAX_TEXTURE_SIZE:
 32195:         case LOCAL_GL_MAX_CUBE_MAP_TEXTURE_SIZE:
 32195:         case LOCAL_GL_SAMPLE_BUFFERS:
 32195:         case LOCAL_GL_SAMPLES:
 32195:         case LOCAL_GL_MAX_VERTEX_ATTRIBS:
 32195:         case LOCAL_GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS:
 32195:         case LOCAL_GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS:
 32195:         case LOCAL_GL_MAX_TEXTURE_IMAGE_UNITS:
 32195:         case LOCAL_GL_MAX_RENDERBUFFER_SIZE:
 32195:         case LOCAL_GL_RED_BITS:
 32195:         case LOCAL_GL_GREEN_BITS:
 32195:         case LOCAL_GL_BLUE_BITS:
 32195:         case LOCAL_GL_ALPHA_BITS:
 32195:         case LOCAL_GL_DEPTH_BITS:
 32195:         case LOCAL_GL_STENCIL_BITS:
 32195:         {
 43305:             GLint i = 0;
 43305:             gl->fGetIntegerv(pname, &i);
 97698:             return JS::Int32Value(i);
 97698:         }
 79603:         case LOCAL_GL_FRAGMENT_SHADER_DERIVATIVE_HINT:
102165:             if (IsExtensionEnabled(OES_standard_derivatives)) {
 79603:                 GLint i = 0;
 79603:                 gl->fGetIntegerv(pname, &i);
 97698:                 return JS::Int32Value(i);
 97698:             }
 97698:             else {
 97698:                 ErrorInvalidEnum("getParameter: parameter", pname);
 97698:                 return JS::NullValue();
 97698:             }
 43305: 
 62529:         case LOCAL_GL_MAX_VERTEX_UNIFORM_VECTORS:
 97698:             return JS::Int32Value(mGLMaxVertexUniformVectors);
 62529: 
 62529:         case LOCAL_GL_MAX_FRAGMENT_UNIFORM_VECTORS:
 97698:             return JS::Int32Value(mGLMaxFragmentUniformVectors);
 62529: 
 46442:         case LOCAL_GL_MAX_VARYING_VECTORS:
 97698:             return JS::Int32Value(mGLMaxVaryingVectors);
 46442: 
 43533:         case LOCAL_GL_NUM_COMPRESSED_TEXTURE_FORMATS:
 97698:             return JS::Int32Value(0);
 46442:         case LOCAL_GL_COMPRESSED_TEXTURE_FORMATS:
 97698:         {
 99228:             uint32_t length = mCompressedTextureFormats.Length();
103052:             JSObject* obj = Uint32Array::Create(cx, this, length, mCompressedTextureFormats.Elements());
 97698:             if (!obj) {
 97698:                 rv = NS_ERROR_OUT_OF_MEMORY;
 97698:             }
 97698:             return JS::ObjectOrNullValue(obj);
 97698:         }
 43533: 
 43305: // unsigned int. here we may have to return very large values like 2^32-1 that can't be represented as
 43533: // javascript integer values. We just return them as doubles and javascript doesn't care.
 43305:         case LOCAL_GL_STENCIL_BACK_VALUE_MASK:
 43305:         case LOCAL_GL_STENCIL_BACK_WRITEMASK:
 43305:         case LOCAL_GL_STENCIL_VALUE_MASK:
 43305:         case LOCAL_GL_STENCIL_WRITEMASK:
 43305:         {
 43305:             GLint i = 0; // the GL api (glGetIntegerv) only does signed ints
 43305:             gl->fGetIntegerv(pname, &i);
 43305:             GLuint i_unsigned(i); // this is where -1 becomes 2^32-1
 43533:             double i_double(i_unsigned); // pass as FP value to allow large values such as 2^32-1.
 97698:             return JS::DoubleValue(i_double);
 97698:         }
 32195: 
 32195: // float
 90800:         case LOCAL_GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT:
102165:             if (IsExtensionEnabled(EXT_texture_filter_anisotropic)) {
 90800:                 GLfloat f = 0.f;
 90800:                 gl->fGetFloatv(pname, &f);
 97698:                 return JS::DoubleValue(f);
 90800:             } else {
 97698:                 ErrorInvalidEnum("getParameter: parameter", pname);
 97698:                 return JS::NullValue();
 97698:             }
 57633:         case LOCAL_GL_DEPTH_CLEAR_VALUE:
 32195:         case LOCAL_GL_LINE_WIDTH:
 32195:         case LOCAL_GL_POLYGON_OFFSET_FACTOR:
 32195:         case LOCAL_GL_POLYGON_OFFSET_UNITS:
 32195:         case LOCAL_GL_SAMPLE_COVERAGE_VALUE:
 32195:         {
 43533:             GLfloat f = 0.f;
 43533:             gl->fGetFloatv(pname, &f);
 97698:             return JS::DoubleValue(f);
 97698:         }
 43305: 
 32195: // bool
 43305:         case LOCAL_GL_BLEND:
 43305:         case LOCAL_GL_DEPTH_TEST:
 43305:         case LOCAL_GL_STENCIL_TEST:
 43305:         case LOCAL_GL_CULL_FACE:
 43305:         case LOCAL_GL_DITHER:
 43305:         case LOCAL_GL_POLYGON_OFFSET_FILL:
 43305:         case LOCAL_GL_SCISSOR_TEST:
 32195:         case LOCAL_GL_SAMPLE_COVERAGE_INVERT:
 32195:         case LOCAL_GL_DEPTH_WRITEMASK:
 32195:         {
 43533:             realGLboolean b = 0;
 43533:             gl->fGetBooleanv(pname, &b);
 97698:             return JS::BooleanValue(bool(b));
 97698:         }
 32195: 
 46442: // bool, WebGL-specific
 46442:         case UNPACK_FLIP_Y_WEBGL:
 97698:             return JS::BooleanValue(mPixelStoreFlipY);
 46442:         case UNPACK_PREMULTIPLY_ALPHA_WEBGL:
 97698:             return JS::BooleanValue(mPixelStorePremultiplyAlpha);
 46442: 
 58672: // uint, WebGL-specific
 58672:         case UNPACK_COLORSPACE_CONVERSION_WEBGL:
 99240:             return JS::NumberValue(uint32_t(mPixelStoreColorspaceConversion));
 58672: 
 32195:         //
 32195:         // Complex values
 32195:         //
 32195:         case LOCAL_GL_DEPTH_RANGE: // 2 floats
 32195:         case LOCAL_GL_ALIASED_POINT_SIZE_RANGE: // 2 floats
 32195:         case LOCAL_GL_ALIASED_LINE_WIDTH_RANGE: // 2 floats
 32195:         {
 43533:             GLfloat fv[2] = { 0 };
 43533:             gl->fGetFloatv(pname, fv);
103052:             JSObject* obj = Float32Array::Create(cx, this, 2, fv);
 97698:             if (!obj) {
 97698:                 rv = NS_ERROR_OUT_OF_MEMORY;
 97698:             }
 97698:             return JS::ObjectOrNullValue(obj);
 97698:         }
 32195:         
 32195:         case LOCAL_GL_COLOR_CLEAR_VALUE: // 4 floats
 32195:         case LOCAL_GL_BLEND_COLOR: // 4 floats
 32195:         {
 43533:             GLfloat fv[4] = { 0 };
 43533:             gl->fGetFloatv(pname, fv);
103052:             JSObject* obj = Float32Array::Create(cx, this, 4, fv);
 97698:             if (!obj) {
 97698:                 rv = NS_ERROR_OUT_OF_MEMORY;
 97698:             }
 97698:             return JS::ObjectOrNullValue(obj);
 97698:         }
 32195: 
 32195:         case LOCAL_GL_MAX_VIEWPORT_DIMS: // 2 ints
 32195:         {
 43533:             GLint iv[2] = { 0 };
 43533:             gl->fGetIntegerv(pname, iv);
103052:             JSObject* obj = Int32Array::Create(cx, this, 2, iv);
 97698:             if (!obj) {
 97698:                 rv = NS_ERROR_OUT_OF_MEMORY;
 97698:             }
 97698:             return JS::ObjectOrNullValue(obj);
 97698:         }
 32195: 
 32195:         case LOCAL_GL_SCISSOR_BOX: // 4 ints
 32195:         case LOCAL_GL_VIEWPORT: // 4 ints
 32195:         {
 56811:             GLint iv[4] = { 0 };
 43533:             gl->fGetIntegerv(pname, iv);
103052:             JSObject* obj = Int32Array::Create(cx, this, 4, iv);
 97698:             if (!obj) {
 97698:                 rv = NS_ERROR_OUT_OF_MEMORY;
 97698:             }
 97698:             return JS::ObjectOrNullValue(obj);
 97698:         }
 32195: 
 43305:         case LOCAL_GL_COLOR_WRITEMASK: // 4 bools
 43305:         {
 43533:             realGLboolean gl_bv[4] = { 0 };
 43533:             gl->fGetBooleanv(pname, gl_bv);
 97698:             JS::Value vals[4] = { JS::BooleanValue(bool(gl_bv[0])),
 97698:                                   JS::BooleanValue(bool(gl_bv[1])),
 97698:                                   JS::BooleanValue(bool(gl_bv[2])),
 97698:                                   JS::BooleanValue(bool(gl_bv[3])) };
 97698:             JSObject* obj = JS_NewArrayObject(cx, 4, vals);
 97698:             if (!obj) {
 97698:                 rv = NS_ERROR_OUT_OF_MEMORY;
 97698:             }
 97698:             return JS::ObjectOrNullValue(obj);
 97698:         }
 43305: 
 43533:         case LOCAL_GL_ARRAY_BUFFER_BINDING:
 97698:         {
 97698:             JS::Value v;
 97698:             if (!dom::WrapObject(cx, GetWrapper(),
 97698:                                  mBoundArrayBuffer.get(), &v)) {
 97698:                 rv = NS_ERROR_FAILURE;
 97698:                 return JS::NullValue();
 97698:             }
 97698:             return v;
 97698:         }
 43305: 
 43533:         case LOCAL_GL_ELEMENT_ARRAY_BUFFER_BINDING:
 97698:         {
 97698:             JS::Value v;
 97698:             if (!dom::WrapObject(cx, GetWrapper(),
 97698:                                  mBoundElementArrayBuffer.get(), &v)) {
 97698:                 rv = NS_ERROR_FAILURE;
 97698:                 return JS::NullValue();
 97698:             }
 97698:             return v;
 97698:         }
 43533: 
 43533:         case LOCAL_GL_RENDERBUFFER_BINDING:
 97698:         {
 97698:             JS::Value v;
 97698:             if (!dom::WrapObject(cx, GetWrapper(),
 97698:                                  mBoundRenderbuffer.get(), &v)) {
 97698:                 rv = NS_ERROR_FAILURE;
 97698:                 return JS::NullValue();
 97698:             }
 97698:             return v;
 97698:         }
 43533: 
 43533:         case LOCAL_GL_FRAMEBUFFER_BINDING:
 97698:         {
 97698:             JS::Value v;
 97698:             if (!dom::WrapObject(cx, GetWrapper(),
 97698:                                  mBoundFramebuffer.get(), &v)) {
 97698:                 rv = NS_ERROR_FAILURE;
 97698:                 return JS::NullValue();
 97698:             }
 97698:             return v;
 97698:         }
 43533: 
 43533:         case LOCAL_GL_CURRENT_PROGRAM:
 97698:         {
 97698:             JS::Value v;
 97698:             if (!dom::WrapObject(cx, GetWrapper(), mCurrentProgram.get(), &v)) {
 97698:                 rv = NS_ERROR_FAILURE;
 97698:                 return JS::NullValue();
 97698:             }
 97698:             return v;
 97698:         }
 43533: 
 43533:         case LOCAL_GL_TEXTURE_BINDING_2D:
 97698:         {
 97698:             JS::Value v;
 97698:             if (!dom::WrapObject(cx, GetWrapper(),
 97698:                                  mBound2DTextures[mActiveTexture].get(), &v)) {
 97698:                 rv = NS_ERROR_FAILURE;
 97698:                 return JS::NullValue();
 97698:             }
 97698:             return v;
 97698:         }
 43533: 
 43533:         case LOCAL_GL_TEXTURE_BINDING_CUBE_MAP:
 97698:         {
 97698:             JS::Value v;
 97698:             if (!dom::WrapObject(cx, GetWrapper(),
 97698:                                  mBoundCubeMapTextures[mActiveTexture].get(),
 97698:                                  &v)) {
 97698:                 rv = NS_ERROR_FAILURE;
 97698:                 return JS::NullValue();
 97698:             }
 97698:             return v;
 97698:         }
 43305: 
 32195:         default:
 97698:             ErrorInvalidEnumInfo("getParameter: parameter", pname);
 97698:     }
 97698: 
 97698:     return JS::NullValue();
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::GetBufferParameter(WebGLenum target, WebGLenum pname, JS::Value *retval)
 97698: {
 97698:     *retval = GetBufferParameter(target, pname);
 32195:     return NS_OK;
 32195: }
 32195: 
 97698: JS::Value
 97698: WebGLContext::GetBufferParameter(WebGLenum target, WebGLenum pname)
 32195: {
 86627:     if (!IsContextStable())
 97698:         return JS::NullValue();
 97698: 
 97698:     if (target != LOCAL_GL_ARRAY_BUFFER && target != LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
 97698:         ErrorInvalidEnumInfo("getBufferParameter: target", target);
 97698:         return JS::NullValue();
 97698:     }
 42477: 
 32195:     MakeContextCurrent();
 32195: 
 32195:     switch (pname) {
 32195:         case LOCAL_GL_BUFFER_SIZE:
 32195:         case LOCAL_GL_BUFFER_USAGE:
 32195:         {
 43851:             GLint i = 0;
 43851:             gl->fGetBufferParameteriv(target, pname, &i);
 97698:             if (pname == LOCAL_GL_BUFFER_SIZE) {
 97698:                 return JS::Int32Value(i);
 97698:             }
 97698: 
 97698:             MOZ_ASSERT(pname == LOCAL_GL_BUFFER_USAGE);
 99240:             return JS::NumberValue(uint32_t(i));
 32195:         }
 32195:             break;
 32195: 
 32195:         default:
 97698:             ErrorInvalidEnumInfo("getBufferParameter: parameter", pname);
 97698:     }
 97698: 
 97698:     return JS::NullValue();
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::GetFramebufferAttachmentParameter(WebGLenum target, WebGLenum attachment, WebGLenum pname, JSContext* cx, JS::Value *retval)
 97698: {
 97819:     ErrorResult rv;
 97698:     JS::Value v =
 97698:         GetFramebufferAttachmentParameter(cx, target, attachment, pname, rv);
 97819:     if (rv.Failed())
 97819:         return rv.ErrorCode();
 97698:     *retval = v;
 32195:     return NS_OK;
 32195: }
 32195: 
 97698: JS::Value
 97698: WebGLContext::GetFramebufferAttachmentParameter(JSContext* cx,
 97698:                                                 WebGLenum target,
 97698:                                                 WebGLenum attachment,
 97698:                                                 WebGLenum pname,
 97819:                                                 ErrorResult& rv)
 32195: {
 86627:     if (!IsContextStable())
 97698:         return JS::NullValue();
 97698: 
 97698:     if (target != LOCAL_GL_FRAMEBUFFER) {
 97698:         ErrorInvalidEnumInfo("getFramebufferAttachmentParameter: target", target);
 97698:         return JS::NullValue();
 97698:     }
 32195: 
 32195:     switch (attachment) {
 32195:         case LOCAL_GL_COLOR_ATTACHMENT0:
 32195:         case LOCAL_GL_DEPTH_ATTACHMENT:
 32195:         case LOCAL_GL_STENCIL_ATTACHMENT:
 60039:         case LOCAL_GL_DEPTH_STENCIL_ATTACHMENT:
 32195:             break;
 32195:         default:
 99232:             ErrorInvalidEnumInfo("getFramebufferAttachmentParameter: attachment", attachment);
 97698:             return JS::NullValue();
 97698:     }
 97698: 
 97698:     if (!mBoundFramebuffer) {
 99232:         ErrorInvalidOperation("getFramebufferAttachmentParameter: cannot query framebuffer 0");
 97698:         return JS::NullValue();
 97698:     }
 47910: 
 42477:     MakeContextCurrent();
 42477: 
 60039:     const WebGLFramebufferAttachment& fba = mBoundFramebuffer->GetAttachment(attachment);
 60039: 
 60039:     if (fba.Renderbuffer()) {
 32195:         switch (pname) {
 32195:             case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:
 99240:                 return JS::NumberValue(uint32_t(LOCAL_GL_RENDERBUFFER));
 47910: 
 60039:             case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:
 97698:             {
 97698:                 JS::Value v;
 97698:                 if (!dom::WrapObject(cx, GetWrapper(),
 97698:                                      const_cast<WebGLRenderbuffer*>(fba.Renderbuffer()),
 97698:                                      &v)) {
 97819:                     rv.Throw(NS_ERROR_FAILURE);
 97698:                     return JS::NullValue();
 97698:                 }
 97698:                 return v;
 97698:             }
 47910: 
 47910:             default:
 99232:                 ErrorInvalidEnumInfo("getFramebufferAttachmentParameter: pname", pname);
 97698:                 return JS::NullValue();
 47910:         }
 60039:     } else if (fba.Texture()) {
 47910:         switch (pname) {
 47910:             case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:
 99240:                 return JS::NumberValue(uint32_t(LOCAL_GL_TEXTURE));
 47910: 
 60039:             case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:
 97698:             {
 97698:                 JS::Value v;
 97698:                 if (!dom::WrapObject(cx, GetWrapper(),
 97698:                                      const_cast<WebGLTexture*>(fba.Texture()),
 97698:                                      &v)) {
 97698:                     rv = NS_ERROR_FAILURE;
 97698:                     return JS::NullValue();
 97698:                 }
 97698:                 return v;
 97698:             }
 47910: 
 32195:             case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:
 97698:                 return JS::Int32Value(fba.TextureLevel());
 60039: 
 60039:             case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:
 97698:                 return JS::Int32Value(fba.TextureCubeMapFace());
 32195: 
 32195:             default:
 99232:                 ErrorInvalidEnumInfo("getFramebufferAttachmentParameter: pname", pname);
 97698:                 return JS::NullValue();
 51899:         }
 60039:     } else {
 51899:         switch (pname) {
 51899:             case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:
 99240:                 return JS::NumberValue(uint32_t(LOCAL_GL_NONE));
 51899: 
 51899:             default:
 99232:                 ErrorInvalidEnumInfo("getFramebufferAttachmentParameter: pname", pname);
 97698:                 return JS::NullValue();
 97698:         }
 97698:     }
 97698: 
 97698:     return JS::NullValue();
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::GetRenderbufferParameter(WebGLenum target, WebGLenum pname, JS::Value *retval)
 97698: {
 97698:     *retval = GetRenderbufferParameter(target, pname);
 32195:     return NS_OK;    
 32195: }
 32195: 
 97698: JS::Value
 97698: WebGLContext::GetRenderbufferParameter(WebGLenum target, WebGLenum pname)
 32195: {
 86627:     if (!IsContextStable())
 97698:         return JS::NullValue();
 97698: 
 97698:     if (target != LOCAL_GL_RENDERBUFFER) {
 99232:         ErrorInvalidEnumInfo("getRenderbufferParameter: target", target);
 97698:         return JS::NullValue();
 97698:     }
 42477: 
 32195:     MakeContextCurrent();
 32195: 
 32195:     switch (pname) {
 32195:         case LOCAL_GL_RENDERBUFFER_WIDTH:
 32195:         case LOCAL_GL_RENDERBUFFER_HEIGHT:
 32195:         case LOCAL_GL_RENDERBUFFER_RED_SIZE:
 32195:         case LOCAL_GL_RENDERBUFFER_GREEN_SIZE:
 32195:         case LOCAL_GL_RENDERBUFFER_BLUE_SIZE:
 32195:         case LOCAL_GL_RENDERBUFFER_ALPHA_SIZE:
 32195:         case LOCAL_GL_RENDERBUFFER_DEPTH_SIZE:
 32195:         case LOCAL_GL_RENDERBUFFER_STENCIL_SIZE:
 32195:         {
 43851:             GLint i = 0;
 43851:             gl->fGetRenderbufferParameteriv(target, pname, &i);
 97698:             return JS::Int32Value(i);
 97698:         }
 58664:         case LOCAL_GL_RENDERBUFFER_INTERNAL_FORMAT:
 58664:         {
 58664:             GLint i = 0;
 58664:             gl->fGetRenderbufferParameteriv(target, pname, &i);
 58664:             if (i == LOCAL_GL_DEPTH24_STENCIL8)
 58664:             {
 58664:                 i = LOCAL_GL_DEPTH_STENCIL;
 58664:             }
 99240:             return JS::NumberValue(uint32_t(i));
 97698:         }
 32195:         default:
 99232:             ErrorInvalidEnumInfo("getRenderbufferParameter: parameter", pname);
 97698:     }
 97698: 
 97698:     return JS::NullValue();
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 32835: WebGLContext::CreateBuffer(nsIWebGLBuffer **retval)
 32195: {
 97698:     *retval = CreateBuffer().get();
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: already_AddRefed<WebGLBuffer>
 97698: WebGLContext::CreateBuffer()
 97698: {
 86627:     if (!IsContextStable())
 97698:         return nsnull;
 97698:     nsRefPtr<WebGLBuffer> globj = new WebGLBuffer(this);
 97698:     return globj.forget();
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 32835: WebGLContext::CreateTexture(nsIWebGLTexture **retval)
 32195: {
 97698:     *retval = CreateTexture().get();
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: already_AddRefed<WebGLTexture>
 97698: WebGLContext::CreateTexture()
 97698: {
 86627:     if (!IsContextStable())
 97698:         return nsnull;
 97698:     nsRefPtr<WebGLTexture> globj = new WebGLTexture(this);
 97698:     return globj.forget();
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozGetError(WebGLenum *_retval)
 97698: {
 97698:     *_retval = GetError();
 80903:     return NS_OK;
 97698: }
 97698: 
 97698: WebGLenum
 97698: WebGLContext::GetError()
 32195: {
 86626:     if (mContextStatus == ContextStable) {
 32195:         MakeContextCurrent();
 73523:         UpdateWebGLErrorAndClearGLError();
 86626:     } else if (!mContextLostErrorSet) {
 86626:         mWebGLError = LOCAL_GL_CONTEXT_LOST;
 86626:         mContextLostErrorSet = true;
 80903:     }
 80903: 
 97698:     WebGLenum err = mWebGLError;
 73522:     mWebGLError = LOCAL_GL_NO_ERROR;
 97698:     return err;
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 99228: WebGLContext::GetProgramParameter(nsIWebGLProgram *pobj, uint32_t pname, JS::Value *retval)
 97698: {
 97698:     *retval = GetProgramParameter(static_cast<WebGLProgram*>(pobj), pname);
 32195:     return NS_OK;
 32195: }
 32195: 
 97698: JS::Value
 97698: WebGLContext::GetProgramParameter(WebGLProgram *prog, WebGLenum pname)
 35013: {
 86627:     if (!IsContextStable())
 97698:         return JS::NullValue();
 97698: 
 97698:     if (!ValidateObjectAllowDeleted("getProgramParameter: program", prog))
 97698:         return JS::NullValue();
 97698: 
 97698:     WebGLuint progname = prog->GLName();
 35013: 
 35013:     MakeContextCurrent();
 35013: 
 35013:     switch (pname) {
 35013:         case LOCAL_GL_ATTACHED_SHADERS:
 35013:         case LOCAL_GL_ACTIVE_UNIFORMS:
 35013:         case LOCAL_GL_ACTIVE_ATTRIBUTES:
 35013:         {
 43851:             GLint i = 0;
 43851:             gl->fGetProgramiv(progname, pname, &i);
 97698:             return JS::Int32Value(i);
 97698:         }
 43011:         case LOCAL_GL_DELETE_STATUS:
 97698:             return JS::BooleanValue(prog->IsDeleteRequested());
 43011:         case LOCAL_GL_LINK_STATUS:
 81332:         {
 81332:             GLint i = 0;
 81332:             gl->fGetProgramiv(progname, pname, &i);
 97698:             return JS::BooleanValue(bool(i));
 97698:         }
 43011:         case LOCAL_GL_VALIDATE_STATUS:
 43011:         {
 43851:             GLint i = 0;
 61294: #ifdef XP_MACOSX
 61294:             // See comment in ValidateProgram below.
 95058:             if (gl->WorkAroundDriverBugs())
 61294:                 i = 1;
 95058:             else
 95058:                 gl->fGetProgramiv(progname, pname, &i);
 61294: #else
 61294:             gl->fGetProgramiv(progname, pname, &i);
 61294: #endif
 97698:             return JS::BooleanValue(bool(i));
 43011:         }
 43011:             break;
 35013: 
 35013:         default:
 99232:             ErrorInvalidEnumInfo("getProgramParameter: parameter", pname);
 97698:     }
 97698: 
 97698:     return JS::NullValue();
 35013: }
 35013: 
 35013: NS_IMETHODIMP
 42471: WebGLContext::GetProgramInfoLog(nsIWebGLProgram *pobj, nsAString& retval)
 32195: {
 97819:     ErrorResult rv;
 97698:     GetProgramInfoLog(static_cast<WebGLProgram*>(pobj), retval, rv);
 97819:     return rv.ErrorCode();
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::GetProgramInfoLog(WebGLProgram *prog, nsAString& retval,
 97819:                                 ErrorResult& rv)
 97698: {
 99787:     nsCAutoString s;
 99787:     GetProgramInfoLog(prog, s, rv);
 99787:     if (s.IsVoid())
 99787:         retval.SetIsVoid(true);
 99787:     else
 99787:         CopyASCIItoUTF16(s, retval);
 99787: }
 99787: 
 99787: void
 99787: WebGLContext::GetProgramInfoLog(WebGLProgram *prog, nsACString& retval,
 99787:                                 ErrorResult& rv)
 99787: {
 86627:     if (!IsContextStable())
 80903:     {
 80903:         retval.SetIsVoid(true);
 97698:         return;
 97698:     }
 97698: 
 97698:     if (!ValidateObject("getProgramInfoLog: program", prog)) {
 97698:         retval.Truncate();
 97698:         return;
 97698:     }
 97698:         
 97698:     WebGLuint progname = prog->GLName();
 42471: 
 32195:     MakeContextCurrent();
 32195: 
 72540:     GLint k = -1;
 72540:     gl->fGetProgramiv(progname, LOCAL_GL_INFO_LOG_LENGTH, &k);
 97698:     if (k == -1) {
 99835:         // If GetProgramiv doesn't modify |k|,
 99835:         // it's because there was a GL error.
 99835:         // GetProgramInfoLog should return null on error. (Bug 746740)
 99835:         retval.SetIsVoid(true);
 97698:         return;
 97698:     }
 32195: 
 32195:     if (k == 0) {
 32195:         retval.Truncate();
 97698:         return;
 32195:     }
 32195: 
 99787:     retval.SetCapacity(k);
 99787:     gl->fGetProgramInfoLog(progname, k, &k, (char*) retval.BeginWriting());
 99787:     retval.SetLength(k);
 32195: }
 32195: 
 51420: // here we have to support all pnames with both int and float params.
 51420: // See this discussion:
 51420: //  https://www.khronos.org/webgl/public-mailing-list/archives/1008/msg00014.html
 97698: void WebGLContext::TexParameter_base(WebGLenum target, WebGLenum pname,
 97698:                                      WebGLint *intParamPtr,
 97698:                                      WebGLfloat *floatParamPtr)
 97698: {
 97698:     MOZ_ASSERT(intParamPtr || floatParamPtr);
 97698: 
 97698:     if (!IsContextStable())
 97698:         return;
 51420: 
 51420:     WebGLint intParam = intParamPtr ? *intParamPtr : WebGLint(*floatParamPtr);
 55267:     WebGLfloat floatParam = floatParamPtr ? *floatParamPtr : WebGLfloat(*intParamPtr);
 51420: 
 51420:     if (!ValidateTextureTargetEnum(target, "texParameter: target"))
 97698:         return;
 51420: 
 51422:     WebGLTexture *tex = activeBoundTextureForTarget(target);
 51422:     if (!tex)
 51422:         return ErrorInvalidOperation("texParameter: no texture is bound to this target");
 51422: 
 79445:     bool pnameAndParamAreIncompatible = false;
 90800:     bool paramValueInvalid = false;
 51420: 
 51420:     switch (pname) {
 51420:         case LOCAL_GL_TEXTURE_MIN_FILTER:
 51420:             switch (intParam) {
 51420:                 case LOCAL_GL_NEAREST:
 51420:                 case LOCAL_GL_LINEAR:
 51420:                 case LOCAL_GL_NEAREST_MIPMAP_NEAREST:
 51420:                 case LOCAL_GL_LINEAR_MIPMAP_NEAREST:
 51420:                 case LOCAL_GL_NEAREST_MIPMAP_LINEAR:
 51420:                 case LOCAL_GL_LINEAR_MIPMAP_LINEAR:
 51422:                     tex->SetMinFilter(intParam);
 51420:                     break;
 51420:                 default:
 80486:                     pnameAndParamAreIncompatible = true;
 51420:             }
 51420:             break;
 51420:         case LOCAL_GL_TEXTURE_MAG_FILTER:
 51420:             switch (intParam) {
 51420:                 case LOCAL_GL_NEAREST:
 51420:                 case LOCAL_GL_LINEAR:
 51422:                     tex->SetMagFilter(intParam);
 51420:                     break;
 51420:                 default:
 80486:                     pnameAndParamAreIncompatible = true;
 51420:             }
 51420:             break;
 51420:         case LOCAL_GL_TEXTURE_WRAP_S:
 51422:             switch (intParam) {
 51422:                 case LOCAL_GL_CLAMP_TO_EDGE:
 51422:                 case LOCAL_GL_MIRRORED_REPEAT:
 51422:                 case LOCAL_GL_REPEAT:
 51422:                     tex->SetWrapS(intParam);
 51422:                     break;
 51422:                 default:
 80486:                     pnameAndParamAreIncompatible = true;
 51422:             }
 51422:             break;
 51420:         case LOCAL_GL_TEXTURE_WRAP_T:
 51420:             switch (intParam) {
 51420:                 case LOCAL_GL_CLAMP_TO_EDGE:
 51420:                 case LOCAL_GL_MIRRORED_REPEAT:
 51420:                 case LOCAL_GL_REPEAT:
 51422:                     tex->SetWrapT(intParam);
 51420:                     break;
 51420:                 default:
 80486:                     pnameAndParamAreIncompatible = true;
 51420:             }
 51420:             break;
 90800:         case LOCAL_GL_TEXTURE_MAX_ANISOTROPY_EXT:
102165:             if (IsExtensionEnabled(EXT_texture_filter_anisotropic)) {
 90800:                 if (floatParamPtr && floatParam < 1.f)
 90800:                     paramValueInvalid = true;
 90800:                 else if (intParamPtr && intParam < 1)
 90800:                     paramValueInvalid = true;
 90800:             }
 90800:             else
 90800:                 pnameAndParamAreIncompatible = true;
 90800:             break;
 51420:         default:
 51420:             return ErrorInvalidEnumInfo("texParameter: pname", pname);
 51420:     }
 51420: 
 51420:     if (pnameAndParamAreIncompatible) {
 51420:         if (intParamPtr)
 51420:             return ErrorInvalidEnum("texParameteri: pname %x and param %x (decimal %d) are mutually incompatible",
 51420:                                     pname, intParam, intParam);
 51420:         else
 90800:             return ErrorInvalidEnum("texParameterf: pname %x and param %g are mutually incompatible",
 90800:                                     pname, floatParam);
 90800:     } else if (paramValueInvalid) {
 90800:         if (intParamPtr)
 90800:             return ErrorInvalidValue("texParameteri: pname %x and param %x (decimal %d) is invalid",
 90800:                                     pname, intParam, intParam);
 90800:         else
 90800:             return ErrorInvalidValue("texParameterf: pname %x and param %g is invalid",
 51420:                                     pname, floatParam);
 51420:     }
 51420: 
 51420:     MakeContextCurrent();
 51420:     if (intParamPtr)
 79447:         gl->fTexParameteri(target, pname, intParam);
 51420:     else
 79447:         gl->fTexParameterf(target, pname, floatParam);
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozTexParameterf(WebGLenum target, WebGLenum pname, WebGLfloat param)
 97698: {
 97698:     TexParameterf(target, pname, param);
 51420:     return NS_OK;
 51420: }
 51420: 
 32195: NS_IMETHODIMP
 97698: WebGLContext::MozTexParameteri(WebGLenum target, WebGLenum pname, WebGLint param)
 97698: {
 97698:     TexParameteri(target, pname, param);
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::GetTexParameter(WebGLenum target, WebGLenum pname, JS::Value *retval)
 97698: {
 97698:     *retval = GetTexParameter(target, pname);
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: JS::Value
 97698: WebGLContext::GetTexParameter(WebGLenum target, WebGLenum pname)
 32835: {
 86627:     if (!IsContextStable())
 97698:         return JS::NullValue();
 80903: 
 53701:     MakeContextCurrent();
 53701: 
 53701:     if (!ValidateTextureTargetEnum(target, "getTexParameter: target"))
 97698:         return JS::NullValue();
 97698: 
 97698:     if (!activeBoundTextureForTarget(target)) {
 97698:         ErrorInvalidOperation("getTexParameter: no texture bound");
 97698:         return JS::NullValue();
 97698:     }
 32835: 
 32835:     switch (pname) {
 32835:         case LOCAL_GL_TEXTURE_MIN_FILTER:
 32835:         case LOCAL_GL_TEXTURE_MAG_FILTER:
 32835:         case LOCAL_GL_TEXTURE_WRAP_S:
 32835:         case LOCAL_GL_TEXTURE_WRAP_T:
 79447:         {
 79447:             GLint i = 0;
 79447:             gl->fGetTexParameteriv(target, pname, &i);
 99240:             return JS::NumberValue(uint32_t(i));
 97698:         }
 90800:         case LOCAL_GL_TEXTURE_MAX_ANISOTROPY_EXT:
102165:             if (IsExtensionEnabled(EXT_texture_filter_anisotropic)) {
 90800:                 GLfloat f = 0.f;
 90800:                 gl->fGetTexParameterfv(target, pname, &f);
 97698:                 return JS::DoubleValue(f);
 97698:             }
 97698: 
 97698:             
 97698:             ErrorInvalidEnumInfo("getTexParameter: parameter", pname);
 90800:             break;
 32835: 
 32835:         default:
 97698:             ErrorInvalidEnumInfo("getTexParameter: parameter", pname);
 97698:     }
 97698: 
 97698:     return JS::NullValue();
 32835: }
 32835: 
 35013: /* any getUniform(in WebGLProgram program, in WebGLUniformLocation location) raises(DOMException); */
 32195: NS_IMETHODIMP
 97698: WebGLContext::GetUniform(nsIWebGLProgram *pobj, nsIWebGLUniformLocation *ploc,
 97698:                          JSContext *cx, JS::Value *retval)
 97698: {
 97819:     ErrorResult rv;
 97698:     JS::Value v = GetUniform(cx, static_cast<WebGLProgram*>(pobj),
 97698:                              static_cast<WebGLUniformLocation*>(ploc), rv);
 97819:     if (rv.Failed())
 97819:         return rv.ErrorCode();
 97698:     *retval = v;
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: JS::Value
 97698: WebGLContext::GetUniform(JSContext* cx, WebGLProgram *prog,
 97819:                          WebGLUniformLocation *location, ErrorResult& rv)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return JS::NullValue();
 97698: 
 97698:     if (!ValidateObject("getUniform: program", prog))
 97698:         return JS::NullValue();
 97698: 
 97698:     if (!ValidateObject("getUniform: location", location))
 97698:         return JS::NullValue();
 97698: 
 97698:     if (location->Program() != prog) {
 99232:         ErrorInvalidValue("getUniform: this uniform location corresponds to another program");
 97698:         return JS::NullValue();
 97698:     }
 97698: 
 97698:     if (location->ProgramGeneration() != prog->Generation()) {
 99232:         ErrorInvalidOperation("getUniform: this uniform location is obsolete since the program has been relinked");
 97698:         return JS::NullValue();
 97698:     }
 97698: 
 97698:     WebGLuint progname = prog->GLName();
 32195: 
 32195:     MakeContextCurrent();
 32195: 
 43010:     GLint uniforms = 0;
 43474:     GLint uniformNameMaxLength = 0;
 43010:     gl->fGetProgramiv(progname, LOCAL_GL_ACTIVE_UNIFORMS, &uniforms);
 43474:     gl->fGetProgramiv(progname, LOCAL_GL_ACTIVE_UNIFORM_MAX_LENGTH, &uniformNameMaxLength);
 43010: 
 43010:     // we now need the type info to switch between fGetUniformfv and fGetUniformiv
 43010:     // the only way to get that is to iterate through all active uniforms by index until
 43010:     // one matches the given uniform location.
 43010:     GLenum uniformType = 0;
 43474:     nsAutoArrayPtr<GLchar> uniformName(new GLchar[uniformNameMaxLength]);
 47814:     // this buffer has 16 more bytes to be able to store [index] at the end.
 47814:     nsAutoArrayPtr<GLchar> uniformNameBracketIndex(new GLchar[uniformNameMaxLength + 16]);
 47814: 
 43010:     GLint index;
 43010:     for (index = 0; index < uniforms; ++index) {
 47814:         GLsizei length;
 47814:         GLint size;
 47814:         gl->fGetActiveUniform(progname, index, uniformNameMaxLength, &length,
 47814:                               &size, &uniformType, uniformName);
 43010:         if (gl->fGetUniformLocation(progname, uniformName) == location->Location())
 43010:             break;
 47814: 
 47814:         // now we handle the case of array uniforms. In that case, fGetActiveUniform returned as 'size'
 47814:         // the biggest index used plus one, so we need to loop over that. The 0 index has already been handled above,
 47814:         // so we can start at one. For each index, we construct the string uniformName + "[" + index + "]".
 47814:         if (size > 1) {
 47814:             bool found_it = false;
 47814:             if (uniformName[length - 1] == ']') { // if uniformName ends in [0]
 47814:                 // remove the [0] at the end
 47814:                 length -= 3;
 47814:                 uniformName[length] = 0;
 47814:             }
 47814:             for (GLint arrayIndex = 1; arrayIndex < size; arrayIndex++) {
 47814:                 sprintf(uniformNameBracketIndex.get(), "%s[%d]", uniformName.get(), arrayIndex);
 47814:                 if (gl->fGetUniformLocation(progname, uniformNameBracketIndex) == location->Location()) {
 47814:                     found_it = true;
 47814:                     break;
 47814:                 }
 47814:             }
 47814:             if (found_it) break;
 47814:         }
 43010:     }
 43010: 
 97698:     if (index == uniforms) {
 97819:         rv.Throw(NS_ERROR_FAILURE); // XXX GL error? shouldn't happen.
 97698:         return JS::NullValue();
 97698:     }
 32195: 
 32195:     GLenum baseType;
 32195:     GLint unitSize;
 97698:     if (!BaseTypeAndSizeFromUniformType(uniformType, &baseType, &unitSize)) {
 97819:         rv.Throw(NS_ERROR_FAILURE);
 97698:         return JS::NullValue();
 97698:     }
 32195: 
 32195:     // this should never happen
 97698:     if (unitSize > 16) {
 97819:         rv.Throw(NS_ERROR_FAILURE);
 97698:         return JS::NullValue();
 97698:     }
 32195: 
 32195:     if (baseType == LOCAL_GL_FLOAT) {
 51424:         GLfloat fv[16] = { GLfloat(0) };
 43010:         gl->fGetUniformfv(progname, location->Location(), fv);
 43852:         if (unitSize == 1) {
 97698:             return JS::DoubleValue(fv[0]);
 43852:         } else {
103052:             JSObject* obj = Float32Array::Create(cx, this, unitSize, fv);
 97698:             if (!obj) {
 97819:                 rv.Throw(NS_ERROR_OUT_OF_MEMORY);
 97698:             }
 97698:             return JS::ObjectOrNullValue(obj);
 43852:         }
 32195:     } else if (baseType == LOCAL_GL_INT) {
 51424:         GLint iv[16] = { 0 };
 43010:         gl->fGetUniformiv(progname, location->Location(), iv);
 43852:         if (unitSize == 1) {
 97698:             return JS::Int32Value(iv[0]);
 32195:         } else {
103052:             JSObject* obj = Int32Array::Create(cx, this, unitSize, iv);
 97698:             if (!obj) {
 97819:                 rv.Throw(NS_ERROR_OUT_OF_MEMORY);
 97698:             }
 97698:             return JS::ObjectOrNullValue(obj);
 32195:         }
 43852:     } else if (baseType == LOCAL_GL_BOOL) {
 51424:         GLint iv[16] = { 0 };
 43852:         gl->fGetUniformiv(progname, location->Location(), iv);
 43852:         if (unitSize == 1) {
 97698:             return JS::BooleanValue(iv[0] ? true : false);
 43852:         } else {
 97698:             JS::Value uv[16];
 43852:             for (int k = 0; k < unitSize; k++)
 97698:                 uv[k] = JS::BooleanValue(iv[k] ? true : false);
 97698:             JSObject* obj = JS_NewArrayObject(cx, unitSize, uv);
 97698:             if (!obj) {
 97819:                 rv.Throw(NS_ERROR_OUT_OF_MEMORY);
 97698:             }
 97698:             return JS::ObjectOrNullValue(obj);
 97698:         }
 97698:     }
 97698: 
 97698:     // Else preserving behavior, but I'm not sure this is correct per spec
 97698:     return JS::UndefinedValue();
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 43010: WebGLContext::GetUniformLocation(nsIWebGLProgram *pobj, const nsAString& name, nsIWebGLUniformLocation **retval)
 32195: {
 97698:     *retval = GetUniformLocation(static_cast<WebGLProgram*>(pobj), name).get();
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: already_AddRefed<WebGLUniformLocation>
 97698: WebGLContext::GetUniformLocation(WebGLProgram *prog, const nsAString& name)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return nsnull;
 97698: 
 97698:     if (!ValidateObject("getUniformLocation: program", prog))
 97698:         return nsnull;
 42471: 
 78164:     if (!ValidateGLSLVariableName(name, "getUniformLocation"))
 97698:         return nsnull;
 74514: 
 91439:     NS_LossyConvertUTF16toASCII cname(name);
 91439:     nsCString mappedName;
 91439:     prog->MapIdentifier(cname, &mappedName);
 91439: 
 97698:     WebGLuint progname = prog->GLName();
 32195:     MakeContextCurrent();
 91439:     GLint intlocation = gl->fGetUniformLocation(progname, mappedName.get());
 43010: 
 83405:     WebGLUniformLocation *loc = nsnull;
 95497:     if (intlocation >= 0) {
 95497:         WebGLUniformInfo info = prog->GetUniformInfoForMappedIdentifier(mappedName);
 95497:         loc = new WebGLUniformLocation(this,
 95497:                                        prog,
 95497:                                        intlocation,
 95497:                                        info);
 95497:         NS_ADDREF(loc);
 95497:     }
 97698:     return loc;
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::GetVertexAttrib(WebGLuint index, WebGLenum pname, JSContext* cx,
 97698:                               JS::Value *retval)
 97698: {
 97819:     ErrorResult rv;
 97698:     JS::Value v = GetVertexAttrib(cx, index, pname, rv);
 97819:     if (rv.Failed())
 97819:         return rv.ErrorCode();
 97698:     *retval = v;
 32195:     return NS_OK;
 32195: }
 32195: 
 97698: JS::Value
 97698: WebGLContext::GetVertexAttrib(JSContext* cx, WebGLuint index, WebGLenum pname,
 97819:                               ErrorResult& rv)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return JS::NullValue();
 80903: 
 63071:     if (!ValidateAttribIndex(index, "getVertexAttrib"))
 97698:         return JS::NullValue();
 32195: 
 32195:     MakeContextCurrent();
 32195: 
 32195:     switch (pname) {
 53696:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
 97698:         {
 97698:             JS::Value v;
 97698:             if (!dom::WrapObject(cx, GetWrapper(),
 97698:                                  mAttribBuffers[index].buf.get(), &v)) {
 97819:                 rv.Throw(NS_ERROR_FAILURE);
 97698:                 return JS::NullValue();
 97698:             }
 97698:             return v;
 97698:         }
 53696: 
 81331:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_STRIDE:
 97698:             return JS::Int32Value(mAttribBuffers[index].stride);
 81331: 
 81136:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_SIZE:
 32195:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_TYPE:
 32195:         {
 72540:             GLint i = 0;
 72540:             gl->fGetVertexAttribiv(index, pname, &i);
 97698:             if (pname == LOCAL_GL_VERTEX_ATTRIB_ARRAY_SIZE)
 97698:                 return JS::Int32Value(i);
 97698:             MOZ_ASSERT(pname == LOCAL_GL_VERTEX_ATTRIB_ARRAY_TYPE);
 99240:             return JS::NumberValue(uint32_t(i));
 97698:         }
 32195: 
 32195:         case LOCAL_GL_CURRENT_VERTEX_ATTRIB:
 32195:         {
 51898:             WebGLfloat vec[4] = {0, 0, 0, 1};
 51898:             if (index) {
 51898:                 gl->fGetVertexAttribfv(index, LOCAL_GL_CURRENT_VERTEX_ATTRIB, &vec[0]);
 51898:             } else {
 51898:                 vec[0] = mVertexAttrib0Vector[0];
 51898:                 vec[1] = mVertexAttrib0Vector[1];
 51898:                 vec[2] = mVertexAttrib0Vector[2];
 51898:                 vec[3] = mVertexAttrib0Vector[3];
 51898:             }
103052:             JSObject* obj = Float32Array::Create(cx, this, 4, vec);
 97698:             if (!obj) {
 97819:                 rv.Throw(NS_ERROR_OUT_OF_MEMORY);
 97698:             }
 97698:             return JS::ObjectOrNullValue(obj);
 97698:         }
 53696: 
 43011:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_ENABLED:
 43011:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_NORMALIZED:
 43011:         {
 72540:             GLint i = 0;
 72540:             gl->fGetVertexAttribiv(index, pname, &i);
 97698:             return JS::BooleanValue(bool(i));
 97698:         }
 32195: 
 32195:         default:
 97698:             ErrorInvalidEnumInfo("getVertexAttrib: parameter", pname);
 97698:     }
 97698: 
 97698:     return JS::NullValue();
 32195: }
 32195: 
 32835: /* GLuint getVertexAttribOffset (in GLuint index, in GLenum pname); */
 32835: NS_IMETHODIMP
 42916: WebGLContext::GetVertexAttribOffset(WebGLuint index, WebGLenum pname, WebGLuint *retval)
 32835: {
 97698:     *retval = GetVertexAttribOffset(index, pname);
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: WebGLsizeiptr
 97698: WebGLContext::GetVertexAttribOffset(WebGLuint index, WebGLenum pname)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return 0;
 97698: 
 97698:     if (!ValidateAttribIndex(index, "getVertexAttribOffset"))
 97698:         return 0;
 97698: 
 97698:     if (pname != LOCAL_GL_VERTEX_ATTRIB_ARRAY_POINTER) {
 97698:         ErrorInvalidEnum("getVertexAttribOffset: bad parameter");
 97698:         return 0;
 97698:     }
 97698: 
 97698:     return mAttribBuffers[index].byteOffset;
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozHint(WebGLenum target, WebGLenum mode)
 97698: {
 97698:     Hint(target, mode);
 80903:     return NS_OK;
 97698: }
 97698: 
 97698: void
 79603: WebGLContext::Hint(WebGLenum target, WebGLenum mode)
 32195: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 79603:     bool isValid = false;
 79603: 
 79603:     switch (target) {
 94797:         case LOCAL_GL_GENERATE_MIPMAP_HINT:
 94797:             isValid = true;
 94797:             break;
 79603:         case LOCAL_GL_FRAGMENT_SHADER_DERIVATIVE_HINT:
102165:             if (IsExtensionEnabled(OES_standard_derivatives))
 79603:                 isValid = true;
 79603:             break;
 79603:     }
 79603: 
 94797:     if (!isValid)
 94797:         return ErrorInvalidEnum("hint: invalid hint");
 94797: 
 79603:     gl->fHint(target, mode);
 79603: }
 79603: 
 32195: NS_IMETHODIMP
 42916: WebGLContext::IsBuffer(nsIWebGLBuffer *bobj, WebGLboolean *retval)
 32195: {
 97698:     *retval = IsBuffer(static_cast<WebGLBuffer*>(bobj));
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: bool
 97698: WebGLContext::IsBuffer(WebGLBuffer *buffer)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return false;
 97698: 
 97698:     return ValidateObjectAllowDeleted("isBuffer", buffer) &&
 97698:         !buffer->IsDeleted() &&
 62489:         buffer->HasEverBeenBound();
 42471: }
 42471: 
 42472: NS_IMETHODIMP
 42916: WebGLContext::IsFramebuffer(nsIWebGLFramebuffer *fbobj, WebGLboolean *retval)
 42472: {
 97698:     *retval = IsFramebuffer(static_cast<WebGLFramebuffer*>(fbobj));
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: bool
 97698: WebGLContext::IsFramebuffer(WebGLFramebuffer *fb)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return false;
 97698: 
 97698:     return ValidateObjectAllowDeleted("isFramebuffer", fb) &&
 97698:         !fb->IsDeleted() &&
 62489:         fb->HasEverBeenBound();
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 42916: WebGLContext::IsProgram(nsIWebGLProgram *pobj, WebGLboolean *retval)
 32195: {
 97698:     *retval = IsProgram(static_cast<WebGLProgram*>(pobj));
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: bool
 97698: WebGLContext::IsProgram(WebGLProgram *prog)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return false;
 97698: 
 97698:     return ValidateObjectAllowDeleted("isProgram", prog) && !prog->IsDeleted();
 42471: }
 42471: 
 42472: NS_IMETHODIMP
 42916: WebGLContext::IsRenderbuffer(nsIWebGLRenderbuffer *rbobj, WebGLboolean *retval)
 42472: {
 97698:     *retval = IsRenderbuffer(static_cast<WebGLRenderbuffer*>(rbobj));
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: bool
 97698: WebGLContext::IsRenderbuffer(WebGLRenderbuffer *rb)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return false;
 97698: 
 97698:     return ValidateObjectAllowDeleted("isRenderBuffer", rb) &&
 97698:         !rb->IsDeleted() &&
 62489:         rb->HasEverBeenBound();
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 42916: WebGLContext::IsShader(nsIWebGLShader *sobj, WebGLboolean *retval)
 32195: {
 97698:     *retval = IsShader(static_cast<WebGLShader*>(sobj));
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: bool
 97698: WebGLContext::IsShader(WebGLShader *shader)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return false;
 97698: 
 97698:     return ValidateObjectAllowDeleted("isShader", shader) &&
 97698:         !shader->IsDeleted();
 42471: }
 42471: 
 32195: NS_IMETHODIMP
 42916: WebGLContext::IsTexture(nsIWebGLTexture *tobj, WebGLboolean *retval)
 32195: {
 97698:     *retval = IsTexture(static_cast<WebGLTexture*>(tobj));
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: bool
 97698: WebGLContext::IsTexture(WebGLTexture *tex)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return false;
 97698: 
 97698:     return ValidateObjectAllowDeleted("isTexture", tex) &&
 97698:         !tex->IsDeleted() &&
 62489:         tex->HasEverBeenBound();
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 43317: WebGLContext::IsEnabled(WebGLenum cap, WebGLboolean *retval)
 32195: {
 97698:     *retval = IsEnabled(cap);
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: bool
 97698: WebGLContext::IsEnabled(WebGLenum cap)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return false;
 51424: 
 51424:     if (!ValidateCapabilityEnum(cap, "isEnabled"))
 97698:         return false;
 43317: 
 32195:     MakeContextCurrent();
 97698:     return gl->fIsEnabled(cap);
 32195: }
 32195: 
 47205: GL_SAME_METHOD_1(LineWidth, LineWidth, WebGLfloat)
 32195: 
 32195: NS_IMETHODIMP
 42471: WebGLContext::LinkProgram(nsIWebGLProgram *pobj)
 32195: {
 97819:     ErrorResult rv;
 97698:     LinkProgram(static_cast<WebGLProgram*>(pobj), rv);
 97819:     return rv.ErrorCode();
 97698: }
 97698: 
 97698: void
 97819: WebGLContext::LinkProgram(WebGLProgram *program, ErrorResult& rv)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return;
 97698: 
 97698:     if (!ValidateObject("linkProgram", program))
 97698:         return;
 97698:     
 97698:     GLuint progname = program->GLName();
 97698: 
 97698:     if (!program->NextGeneration()) {
 97819:         return rv.Throw(NS_ERROR_FAILURE);
 97698:     }
 32195: 
 43637:     if (!program->HasBothShaderTypesAttached()) {
 99787:         GenerateWarning("linkProgram: this program doesn't have both a vertex shader"
 99787:                         " and a fragment shader");
 80486:         program->SetLinkStatus(false);
 97698:         return;
 43637:     }
 43637: 
 43637:     MakeContextCurrent();
 43637:     gl->fLinkProgram(progname);
 43637: 
 43098:     GLint ok;
 43098:     gl->fGetProgramiv(progname, LOCAL_GL_LINK_STATUS, &ok);
 43474:     if (ok) {
 91439:         bool updateInfoSucceeded = program->UpdateInfo();
 91439:         program->SetLinkStatus(updateInfoSucceeded);
 99838: 
 99838:         // Bug 750527
 99838:         if (gl->WorkAroundDriverBugs() &&
 99838:             updateInfoSucceeded &&
 99838:             gl->Vendor() == gl::GLContext::VendorNVIDIA)
 99838:         {
 99838:             if (program == mCurrentProgram)
 99838:                 gl->fUseProgram(progname);
 99838:         }
 43474:     } else {
 80486:         program->SetLinkStatus(false);
 99787: 
 99787:         if (ShouldGenerateWarnings()) {
 99787: 
 99787:             // report shader/program infoLogs as warnings.
 99787:             // note that shader compilation errors can be deferred to linkProgram,
 99787:             // which is why we can't do anything in compileShader. In practice we could
 99787:             // report in compileShader the translation errors generated by ANGLE,
 99787:             // but it seems saner to keep a single way of obtaining shader infologs.
 99787: 
 99787:             ErrorResult rv;
 99787:             nsCAutoString log;
 99787: 
 99787:             bool alreadyReportedShaderInfoLog = false;
 99787: 
 99787:             for (size_t i = 0; i < program->AttachedShaders().Length(); i++) {
 99787: 
 99787:                 WebGLShader* shader = program->AttachedShaders()[i];
 99787:                 GetShaderInfoLog(shader, log, rv);
 99787:                 if (rv.Failed() || log.IsEmpty())
 99787:                     continue;
 99787: 
 99787:                 const char *shaderTypeName = nsnull;
 99787:                 if (shader->ShaderType() == LOCAL_GL_VERTEX_SHADER) {
 99787:                     shaderTypeName = "vertex";
 99787:                 } else if (shader->ShaderType() == LOCAL_GL_FRAGMENT_SHADER) {
 99787:                     shaderTypeName = "fragment";
 99787:                 } else {
 99787:                     // should have been validated earlier
 99787:                     NS_ABORT();
 99787:                     shaderTypeName = "<unknown>";
 99787:                 }
 99787: 
 99787:                 GenerateWarning("linkProgram: a %s shader used in this program failed to "
 99787:                                 "compile, with this log:\n%s\n",
 99787:                                 shaderTypeName,
 99787:                                 log.get());
 99787:                 alreadyReportedShaderInfoLog = true;
 99787:             }
 99787: 
 99787:             if (!alreadyReportedShaderInfoLog) {
 99787:                 GetProgramInfoLog(program, log, rv);
 99787:                 if (!(rv.Failed() || log.IsEmpty())) {
 99787:                     GenerateWarning("linkProgram failed, with this log:\n%s\n",
 99787:                                     log.get());
 99787:                 }
 99787:             }
 99787:         }
 43474:     }
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozPixelStorei(WebGLenum pname, WebGLint param)
 97698: {
 97698:     PixelStorei(pname, param);
 32195:     return NS_OK;
 32195: }
 32195: 
 97698: void
 42916: WebGLContext::PixelStorei(WebGLenum pname, WebGLint param)
 32195: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 43639:     switch (pname) {
 43639:         case UNPACK_FLIP_Y_WEBGL:
 43639:             mPixelStoreFlipY = (param != 0);
 43639:             break;
 43639:         case UNPACK_PREMULTIPLY_ALPHA_WEBGL:
 43639:             mPixelStorePremultiplyAlpha = (param != 0);
 43639:             break;
 58672:         case UNPACK_COLORSPACE_CONVERSION_WEBGL:
 58672:             if (param == LOCAL_GL_NONE || param == BROWSER_DEFAULT_WEBGL)
 58672:                 mPixelStoreColorspaceConversion = param;
 58672:             else
 58672:                 return ErrorInvalidEnumInfo("pixelStorei: colorspace conversion parameter", param);
 58672:             break;
 43639:         case LOCAL_GL_PACK_ALIGNMENT:
 43639:         case LOCAL_GL_UNPACK_ALIGNMENT:
 43639:             if (param != 1 &&
 43639:                 param != 2 &&
 43639:                 param != 4 &&
 43639:                 param != 8)
 99232:                 return ErrorInvalidValue("pixelStorei: invalid pack/unpack alignment value");
 55904:             if (pname == LOCAL_GL_PACK_ALIGNMENT)
 55904:                 mPixelStorePackAlignment = param;
 55904:             else if (pname == LOCAL_GL_UNPACK_ALIGNMENT)
 55904:                 mPixelStoreUnpackAlignment = param;
 32195:             MakeContextCurrent();
 32195:             gl->fPixelStorei(pname, param);
 43639:             break;
 43639:         default:
 99232:             return ErrorInvalidEnumInfo("pixelStorei: parameter", pname);
 43639:     }
 97698: }
 32195: 
 47205: GL_SAME_METHOD_2(PolygonOffset, PolygonOffset, WebGLfloat, WebGLfloat)
 32195: 
 32195: NS_IMETHODIMP
 93208: WebGLContext::ReadPixels(WebGLint x, WebGLint y, WebGLsizei width, WebGLsizei height,
 95834:                          WebGLenum format, WebGLenum type, const JS::Value& pixelsVal, JSContext *cx)
 95834: {
 95834:     if (!pixelsVal.isObject()) {
 95834:         return NS_ERROR_FAILURE;
 95834:     }
 95834: 
 95834:     if (!JS_IsTypedArrayObject(&pixelsVal.toObject(), cx)) {
 43853:         return NS_ERROR_FAILURE;
 43853:     }
 43853: 
 97698:     ArrayBufferView pixels(cx, &pixelsVal.toObject());
 97819:     ErrorResult rv;
 97698:     ReadPixels(x, y, width, height, format, type, &pixels, rv);
 97819:     return rv.ErrorCode();
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::ReadPixels(WebGLint x, WebGLint y, WebGLsizei width,
 97698:                          WebGLsizei height, WebGLenum format,
 97698:                          WebGLenum type, ArrayBufferView* pixels,
 97819:                          ErrorResult& rv)
 97698: {
 93208:     if (!IsContextStable()) {
 97698:         return;
 93208:     }
 93208: 
101146:     if (mCanvasElement->IsWriteOnly() && !nsContentUtils::IsCallerTrustedForRead()) {
 99232:         GenerateWarning("readPixels: Not allowed");
 97819:         return rv.Throw(NS_ERROR_DOM_SECURITY_ERR);
 32195:     }
 32195: 
 43853:     if (width < 0 || height < 0)
 99232:         return ErrorInvalidValue("readPixels: negative size passed");
 43853: 
102147:     if (!pixels)
102147:         return ErrorInvalidValue("readPixels: null destination buffer");
102147: 
 88090:     const WebGLRectangleObject *framebufferRect = FramebufferRectangleObject();
 88090:     WebGLsizei framebufferWidth = framebufferRect ? framebufferRect->Width() : 0;
 88090:     WebGLsizei framebufferHeight = framebufferRect ? framebufferRect->Height() : 0;
 32195: 
 97698:     void* data = pixels->mData;
 99228:     uint32_t dataByteLen = JS_GetTypedArrayByteLength(pixels->mObj, NULL);
 97698:     int dataType = JS_GetTypedArrayType(pixels->mObj, NULL);
 81131: 
 99228:     uint32_t channels = 0;
 81131: 
 81131:     // Check the format param
 32195:     switch (format) {
 81131:         case LOCAL_GL_ALPHA:
 81131:             channels = 1;
 81131:             break;
 81131:         case LOCAL_GL_RGB:
 81131:             channels = 3;
 81131:             break;
 32195:         case LOCAL_GL_RGBA:
 81131:             channels = 4;
 32195:             break;
 32195:         default:
 81131:             return ErrorInvalidEnum("readPixels: Bad format");
 81131:     }
 81131: 
 99228:     uint32_t bytesPerPixel = 0;
 81131:     int requiredDataType = 0;
 81131: 
 81131:     // Check the type param
 81131:     switch (type) {
 81131:         case LOCAL_GL_UNSIGNED_BYTE:
 81131:             bytesPerPixel = 1 * channels;
 95834:             requiredDataType = js::ArrayBufferView::TYPE_UINT8;
 57639:             break;
 81131:         case LOCAL_GL_UNSIGNED_SHORT_4_4_4_4:
 81131:         case LOCAL_GL_UNSIGNED_SHORT_5_5_5_1:
 81131:         case LOCAL_GL_UNSIGNED_SHORT_5_6_5:
 81131:             bytesPerPixel = 2;
 95834:             requiredDataType = js::ArrayBufferView::TYPE_UINT16;
 81131:             break;
 81131:         default:
 81131:             return ErrorInvalidEnum("readPixels: Bad type");
 81131:     }
 81131: 
 81131:     // Check the pixels param type
 81131:     if (dataType != requiredDataType)
 81131:         return ErrorInvalidOperation("readPixels: Mismatched type/pixels types");
 81131: 
 81131:     // Check the pixels param size
 81131:     CheckedUint32 checked_neededByteLength =
 81131:         GetImageSize(height, width, bytesPerPixel, mPixelStorePackAlignment);
 81131: 
 81131:     CheckedUint32 checked_plainRowSize = CheckedUint32(width) * bytesPerPixel;
 81131: 
 81131:     CheckedUint32 checked_alignedRowSize =
 81131:         RoundedToNextMultipleOf(checked_plainRowSize, mPixelStorePackAlignment);
 81131: 
 98543:     if (!checked_neededByteLength.isValid())
 99232:         return ErrorInvalidOperation("readPixels: integer overflow computing the needed buffer size");
 81131: 
 81131:     if (checked_neededByteLength.value() > dataByteLen)
 99232:         return ErrorInvalidOperation("readPixels: buffer too small");
 81131: 
 81131:     // Check the format and type params to assure they are an acceptable pair (as per spec)
 81131:     switch (format) {
 81131:         case LOCAL_GL_RGBA: {
 32195:             switch (type) {
 32195:                 case LOCAL_GL_UNSIGNED_BYTE:
 32195:                     break;
 32195:                 default:
 81131:                     return ErrorInvalidOperation("readPixels: Invalid format/type pair");
 81131:             }
 57639:             break;
 57639:         }
 81131:         default:
 81131:             return ErrorInvalidOperation("readPixels: Invalid format/type pair");
 81131:     }
 81131: 
 56959:     MakeContextCurrent();
 56959: 
 70168:     if (mBoundFramebuffer) {
 56959:         // prevent readback of arbitrary video memory through uninitialized renderbuffers!
 70168:         if (!mBoundFramebuffer->CheckAndInitializeRenderbuffers())
 88091:             return ErrorInvalidFramebufferOperation("readPixels: incomplete framebuffer");
 70168:     }
 81133:     // Now that the errors are out of the way, on to actually reading
 81133: 
 81133:     // If we won't be reading any pixels anyways, just skip the actual reading
 81133:     if (width == 0 || height == 0)
 88091:         return DummyFramebufferOperation("readPixels");
 70168: 
 88090:     if (CanvasUtils::CheckSaneSubrectSize(x, y, width, height, framebufferWidth, framebufferHeight)) {
 43853:         // the easy case: we're not reading out-of-range pixels
 43853:         gl->fReadPixels(x, y, width, height, format, type, data);
 43853:     } else {
 43853:         // the rectangle doesn't fit entirely in the bound buffer. We then have to set to zero the part
 43853:         // of the buffer that correspond to out-of-range pixels. We don't want to rely on system OpenGL
 43853:         // to do that for us, because passing out of range parameters to a buggy OpenGL implementation
 43853:         // could conceivably allow to read memory we shouldn't be allowed to read. So we manually initialize
 43853:         // the buffer to zero and compute the parameters to pass to OpenGL. We have to use an intermediate buffer
 43853:         // to accomodate the potentially different strides (widths).
 43853: 
 43853:         // zero the whole destination buffer. Too bad for the part that's going to be overwritten, we're not
 43853:         // 100% efficient here, but in practice this is a quite rare case anyway.
 81131:         memset(data, 0, dataByteLen);
 43853: 
 88090:         if (   x >= framebufferWidth
 43853:             || x+width <= 0
 88090:             || y >= framebufferHeight
 43853:             || y+height <= 0)
 43853:         {
 43853:             // we are completely outside of range, can exit now with buffer filled with zeros
 88091:             return DummyFramebufferOperation("readPixels");
 43853:         }
 43853: 
 43853:         // compute the parameters of the subrect we're actually going to call glReadPixels on
 71173:         GLint   subrect_x      = NS_MAX(x, 0);
 88090:         GLint   subrect_end_x  = NS_MIN(x+width, framebufferWidth);
 43853:         GLsizei subrect_width  = subrect_end_x - subrect_x;
 43853: 
 71173:         GLint   subrect_y      = NS_MAX(y, 0);
 88090:         GLint   subrect_end_y  = NS_MIN(y+height, framebufferHeight);
 43853:         GLsizei subrect_height = subrect_end_y - subrect_y;
 43853: 
 47204:         if (subrect_width < 0 || subrect_height < 0 ||
 51423:             subrect_width > width || subrect_height > height)
 99232:             return ErrorInvalidOperation("readPixels: integer overflow computing clipped rect size");
 47204: 
 47204:         // now we know that subrect_width is in the [0..width] interval, and same for heights.
 47204: 
 43853:         // now, same computation as above to find the size of the intermediate buffer to allocate for the subrect
 47204:         // no need to check again for integer overflow here, since we already know the sizes aren't greater than before
 99228:         uint32_t subrect_plainRowSize = subrect_width * bytesPerPixel;
 77722: 	// There are checks above to ensure that this doesn't overflow.
 99228:         uint32_t subrect_alignedRowSize = 
 77722:             RoundedToNextMultipleOf(subrect_plainRowSize, mPixelStorePackAlignment).value();
 99228:         uint32_t subrect_byteLength = (subrect_height-1)*subrect_alignedRowSize + subrect_plainRowSize;
 43853: 
 43853:         // create subrect buffer, call glReadPixels, copy pixels into destination buffer, delete subrect buffer
 43853:         GLubyte *subrect_data = new GLubyte[subrect_byteLength];
 43853:         gl->fReadPixels(subrect_x, subrect_y, subrect_width, subrect_height, format, type, subrect_data);
 47204: 
 47204:         // notice that this for loop terminates because we already checked that subrect_height is at most height
 43853:         for (GLint y_inside_subrect = 0; y_inside_subrect < subrect_height; ++y_inside_subrect) {
 43853:             GLint subrect_x_in_dest_buffer = subrect_x - x;
 43853:             GLint subrect_y_in_dest_buffer = subrect_y - y;
 43853:             memcpy(static_cast<GLubyte*>(data)
 47204:                      + checked_alignedRowSize.value() * (subrect_y_in_dest_buffer + y_inside_subrect)
 81131:                      + bytesPerPixel * subrect_x_in_dest_buffer, // destination
 43853:                    subrect_data + subrect_alignedRowSize * y_inside_subrect, // source
 43853:                    subrect_plainRowSize); // size
 43853:         }
 43853:         delete [] subrect_data;
 43853:     }
 57631: 
 59619:     // if we're reading alpha, we may need to do fixup.  Note that we don't allow
 59619:     // GL_ALPHA to readpixels currently, but we had the code written for it already.
 57631:     if (format == LOCAL_GL_ALPHA ||
 57631:         format == LOCAL_GL_RGBA)
 57631:     {
 79445:         bool needAlphaFixup;
 57631:         if (mBoundFramebuffer) {
 58673:             needAlphaFixup = !mBoundFramebuffer->ColorAttachment().HasAlpha();
 57631:         } else {
 57631:             needAlphaFixup = gl->ActualFormat().alpha == 0;
 57631:         }
 57631: 
 57631:         if (needAlphaFixup) {
 57631:             if (format == LOCAL_GL_ALPHA && type == LOCAL_GL_UNSIGNED_BYTE) {
 57631:                 // this is easy; it's an 0xff memset per row
 99228:                 uint8_t *row = static_cast<uint8_t*>(data);
 57631:                 for (GLint j = 0; j < height; ++j) {
 57631:                     memset(row, 0xff, checked_plainRowSize.value());
 57631:                     row += checked_alignedRowSize.value();
 57631:                 }
 57631:             } else if (format == LOCAL_GL_RGBA && type == LOCAL_GL_UNSIGNED_BYTE) {
 57631:                 // this is harder, we need to just set the alpha byte here
 99228:                 uint8_t *row = static_cast<uint8_t*>(data);
 57631:                 for (GLint j = 0; j < height; ++j) {
 99228:                     uint8_t *rowp = row;
 57631: #ifdef IS_LITTLE_ENDIAN
 57631:                     // offset to get the alpha byte; we're always going to
 57631:                     // move by 4 bytes
 57631:                     rowp += 3;
 57631: #endif
 99228:                     uint8_t *endrowp = rowp + 4 * width;
 57631:                     while (rowp != endrowp) {
 57631:                         *rowp = 0xff;
 57631:                         rowp += 4;
 57631:                     }
 57631: 
 57631:                     row += checked_alignedRowSize.value();
 57631:                 }
 57631:             } else {
 57631:                 NS_WARNING("Unhandled case, how'd we get here?");
 97819:                 return rv.Throw(NS_ERROR_FAILURE);
 97698:             }
 97698:         }            
 97698:     }
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozRenderbufferStorage(WebGLenum target, WebGLenum internalformat, WebGLsizei width, WebGLsizei height)
 97698: {
 97698:     RenderbufferStorage(target, internalformat, width, height);
 43853:     return NS_OK;
 43853: }
 43853: 
 97698: void
 42916: WebGLContext::RenderbufferStorage(WebGLenum target, WebGLenum internalformat, WebGLsizei width, WebGLsizei height)
 42473: {
 86627:     if (!IsContextStable())
 97698:         return;
 56959: 
 56959:     if (!mBoundRenderbuffer || !mBoundRenderbuffer->GLName())
 56959:         return ErrorInvalidOperation("renderbufferStorage called on renderbuffer 0");
 56959: 
 42477:     if (target != LOCAL_GL_RENDERBUFFER)
 56959:         return ErrorInvalidEnumInfo("renderbufferStorage: target", target);
 56959: 
 77217:     if (width < 0 || height < 0)
 77217:         return ErrorInvalidValue("renderbufferStorage: width and height must be >= 0");
 56959: 
 56959:     if (!mBoundRenderbuffer || !mBoundRenderbuffer->GLName())
 56959:         return ErrorInvalidOperation("renderbufferStorage called on renderbuffer 0");
 56959: 
 56959:     // certain OpenGL ES renderbuffer formats may not exist on desktop OpenGL
 56959:     WebGLenum internalformatForGL = internalformat;
 42477: 
 42477:     switch (internalformat) {
 42477:     case LOCAL_GL_RGBA4:
 42477:     case LOCAL_GL_RGB5_A1:
 56959:         // 16-bit RGBA formats are not supported on desktop GL
 56959:         if (!gl->IsGLES2()) internalformatForGL = LOCAL_GL_RGBA8;
 56959:         break;
 56959:     case LOCAL_GL_RGB565:
 56959:         // the RGB565 format is not supported on desktop GL
 56959:         if (!gl->IsGLES2()) internalformatForGL = LOCAL_GL_RGB8;
 56959:         break;
 42477:     case LOCAL_GL_DEPTH_COMPONENT16:
 61296:         if (!gl->IsGLES2() || gl->IsExtensionSupported(gl::GLContext::OES_depth24))
 61296:             internalformatForGL = LOCAL_GL_DEPTH_COMPONENT24;
 61296:         else if (gl->IsExtensionSupported(gl::GLContext::OES_packed_depth_stencil))
 61296:             internalformatForGL = LOCAL_GL_DEPTH24_STENCIL8;
 58664:         break;
 42477:     case LOCAL_GL_STENCIL_INDEX8:
 56959:         break;
 56959:     case LOCAL_GL_DEPTH_STENCIL:
 56959:         // this one is available in newer OpenGL (at least since 3.1); will probably become available
 56959:         // in OpenGL ES 3 (at least it will have some DEPTH_STENCIL) and is the same value that
 56959:         // is otherwise provided by EXT_packed_depth_stencil and OES_packed_depth_stencil extensions
 56959:         // which means it's supported on most GL and GL ES systems already.
 56959:         //
 56959:         // So we just use it hoping that it's available (perhaps as an extension) and if it's not available,
 56959:         // we just let the GL generate an error and don't do anything about it ourselves.
 56959:         internalformatForGL = LOCAL_GL_DEPTH24_STENCIL8;
 42477:         break;
 42477:     default:
 58586:         return ErrorInvalidEnumInfo("renderbufferStorage: internalformat", internalformat);
 56959:     }
 56959: 
 73527:     MakeContextCurrent();
 73527: 
 88090:     bool sizeChanges = width != mBoundRenderbuffer->Width() ||
 88090:                        height != mBoundRenderbuffer->Height() ||
 73527:                        internalformat != mBoundRenderbuffer->InternalFormat();
 73527:     if (sizeChanges) {
 73527:         UpdateWebGLErrorAndClearGLError();
 56959:         gl->fRenderbufferStorage(target, internalformatForGL, width, height);
 73527:         GLenum error = LOCAL_GL_NO_ERROR;
 73527:         UpdateWebGLErrorAndClearGLError(&error);
 73527:         if (error) {
 99231:             GenerateWarning("renderbufferStorage generated error %s", ErrorName(error));
 97698:             return;
 73527:         }
 73527:     } else {
 73527:         gl->fRenderbufferStorage(target, internalformatForGL, width, height);
 73527:     }
 56959: 
 56959:     mBoundRenderbuffer->SetInternalFormat(internalformat);
 73516:     mBoundRenderbuffer->SetInternalFormatForGL(internalformatForGL);
 42473:     mBoundRenderbuffer->setDimensions(width, height);
 80486:     mBoundRenderbuffer->SetInitialized(false);
 97698: }
 97698: 
 97698: GL_SAME_METHOD_2(SampleCoverage, SampleCoverage, WebGLclampf, WebGLboolean)
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozScissor(WebGLint x, WebGLint y, WebGLsizei width, WebGLsizei height)
 97698: {
 97698:     Scissor(x, y, width, height);
 42473:     return NS_OK;
 42473: }
 32195: 
 97698: void
 46442: WebGLContext::Scissor(WebGLint x, WebGLint y, WebGLsizei width, WebGLsizei height)
 46442: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 46442:     if (width < 0 || height < 0)
 99232:         return ErrorInvalidValue("scissor: negative size");
 46442: 
 46442:     MakeContextCurrent();
 46442:     gl->fScissor(x, y, width, height);
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozStencilFunc(WebGLenum func, WebGLint ref, WebGLuint mask)
 97698: {
 97698:     StencilFunc(func, ref, mask);
 46442:     return NS_OK;
 46442: }
 46442: 
 97698: void
 46442: WebGLContext::StencilFunc(WebGLenum func, WebGLint ref, WebGLuint mask)
 46442: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 46443:     if (!ValidateComparisonEnum(func, "stencilFunc: func"))
 97698:         return;
 46442: 
 70170:     mStencilRefFront = ref;
 70170:     mStencilRefBack = ref;
 70170:     mStencilValueMaskFront = mask;
 70170:     mStencilValueMaskBack = mask;
 58671: 
 46442:     MakeContextCurrent();
 46442:     gl->fStencilFunc(func, ref, mask);
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozStencilFuncSeparate(WebGLenum face, WebGLenum func, WebGLint ref, WebGLuint mask)
 97698: {
 97698:     StencilFuncSeparate(face, func, ref, mask);
 46442:     return NS_OK;
 46442: }
 46442: 
 97698: void
 46442: WebGLContext::StencilFuncSeparate(WebGLenum face, WebGLenum func, WebGLint ref, WebGLuint mask)
 46442: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 46443:     if (!ValidateFaceEnum(face, "stencilFuncSeparate: face") ||
 46443:         !ValidateComparisonEnum(func, "stencilFuncSeparate: func"))
 97698:         return;
 46442: 
 70170:     switch (face) {
 70170:         case LOCAL_GL_FRONT_AND_BACK:
 70170:             mStencilRefFront = ref;
 70170:             mStencilRefBack = ref;
 70170:             mStencilValueMaskFront = mask;
 70170:             mStencilValueMaskBack = mask;
 70170:             break;
 70170:         case LOCAL_GL_FRONT:
 70170:             mStencilRefFront = ref;
 70170:             mStencilValueMaskFront = mask;
 70170:             break;
 70170:         case LOCAL_GL_BACK:
 70170:             mStencilRefBack = ref;
 70170:             mStencilValueMaskBack = mask;
 70170:             break;
 70170:     }
 58671: 
 46442:     MakeContextCurrent();
 46442:     gl->fStencilFuncSeparate(face, func, ref, mask);
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozStencilMask(WebGLuint mask)
 97698: {
 97698:     StencilMask(mask);
 46442:     return NS_OK;
 46442: }
 42916: 
 97698: void
 58671: WebGLContext::StencilMask(WebGLuint mask)
 58671: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 70170:     mStencilWriteMaskFront = mask;
 70170:     mStencilWriteMaskBack = mask;
 58671: 
 58671:     MakeContextCurrent();
 58671:     gl->fStencilMask(mask);
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozStencilMaskSeparate(WebGLenum face, WebGLuint mask)
 97698: {
 97698:     StencilMaskSeparate(face, mask);
 58671:     return NS_OK;
 58671: }
 42916: 
 97698: void
 46442: WebGLContext::StencilMaskSeparate(WebGLenum face, WebGLuint mask)
 46442: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 46443:     if (!ValidateFaceEnum(face, "stencilMaskSeparate: face"))
 97698:         return;
 46442: 
 70170:     switch (face) {
 70170:         case LOCAL_GL_FRONT_AND_BACK:
 70170:             mStencilWriteMaskFront = mask;
 70170:             mStencilWriteMaskBack = mask;
 70170:             break;
 70170:         case LOCAL_GL_FRONT:
 70170:             mStencilWriteMaskFront = mask;
 70170:             break;
 70170:         case LOCAL_GL_BACK:
 70170:             mStencilWriteMaskBack = mask;
 70170:             break;
 70170:     }
 58671: 
 46442:     MakeContextCurrent();
 46442:     gl->fStencilMaskSeparate(face, mask);
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozStencilOp(WebGLenum sfail, WebGLenum dpfail, WebGLenum dppass)
 97698: {
 97698:     StencilOp(sfail, dpfail, dppass);
 46442:     return NS_OK;
 46442: }
 46442: 
 97698: void
 46442: WebGLContext::StencilOp(WebGLenum sfail, WebGLenum dpfail, WebGLenum dppass)
 46442: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 46443:     if (!ValidateStencilOpEnum(sfail, "stencilOp: sfail") ||
 46443:         !ValidateStencilOpEnum(dpfail, "stencilOp: dpfail") ||
 46443:         !ValidateStencilOpEnum(dppass, "stencilOp: dppass"))
 97698:         return;
 46442: 
 46442:     MakeContextCurrent();
 46442:     gl->fStencilOp(sfail, dpfail, dppass);
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozStencilOpSeparate(WebGLenum face, WebGLenum sfail, WebGLenum dpfail, WebGLenum dppass)
 97698: {
 97698:     StencilOpSeparate(face, sfail, dpfail, dppass);
 46442:     return NS_OK;
 46442: }
 46442: 
 97698: void
 46442: WebGLContext::StencilOpSeparate(WebGLenum face, WebGLenum sfail, WebGLenum dpfail, WebGLenum dppass)
 46442: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 46443:     if (!ValidateFaceEnum(face, "stencilOpSeparate: face") ||
 46443:         !ValidateStencilOpEnum(sfail, "stencilOpSeparate: sfail") ||
 46443:         !ValidateStencilOpEnum(dpfail, "stencilOpSeparate: dpfail") ||
 46443:         !ValidateStencilOpEnum(dppass, "stencilOpSeparate: dppass"))
 97698:         return;
 46442: 
 46442:     MakeContextCurrent();
 46442:     gl->fStencilOpSeparate(face, sfail, dpfail, dppass);
 46442: }
 32195: 
 32195: nsresult
100046: WebGLContext::SurfaceFromElementResultToImageSurface(nsLayoutUtils::SurfaceFromElementResult& res,
 98002:                                                      gfxImageSurface **imageOut, WebGLTexelFormat *format)
 32195: {
 32195:     if (!res.mSurface)
 32195:         return NS_ERROR_FAILURE;
 32195:     if (res.mSurface->GetType() != gfxASurface::SurfaceTypeImage) {
 32195:         // SurfaceFromElement lied!
 32195:         return NS_ERROR_FAILURE;
 32195:     }
 32195: 
 88218:     // We disallow loading cross-domain images and videos that have not been validated
 73881:     // with CORS as WebGL textures. The reason for doing that is that timing
 73881:     // attacks on WebGL shaders are able to retrieve approximations of the
 73881:     // pixel values in WebGL textures; see bug 655987.
 71405:     //
 73881:     // To prevent a loophole where a Canvas2D would be used as a proxy to load
 73881:     // cross-domain textures, we also disallow loading textures from write-only
 73881:     // Canvas2D's.
 73881: 
 73881:     // part 1: check that the DOM element is same-origin, or has otherwise been
 73881:     // validated for cross-domain use.
 78533:     if (!res.mCORSUsed) {
 79445:         bool subsumes;
101146:         nsresult rv = mCanvasElement->NodePrincipal()->Subsumes(res.mPrincipal, &subsumes);
 71405:         if (NS_FAILED(rv) || !subsumes) {
 99231:             GenerateWarning("It is forbidden to load a WebGL texture from a cross-domain element that has not been validated with CORS. "
 71405:                                 "See https://developer.mozilla.org/en/WebGL/Cross-Domain_Textures");
 71405:             return NS_ERROR_DOM_SECURITY_ERR;
 71405:         }
 71405:     }
 71405: 
100046:     // part 2: if the DOM element is write-only, it might contain
 83345:     // cross-domain image data.
100046:     if (res.mIsWriteOnly) {
 99231:         GenerateWarning("The canvas used as source for texImage2D here is tainted (write-only). It is forbidden "
 71405:                         "to load a WebGL texture from a tainted canvas. A Canvas becomes tainted for example "
 71405:                         "when a cross-domain image is drawn on it. "
 71405:                         "See https://developer.mozilla.org/en/WebGL/Cross-Domain_Textures");
 71405:         return NS_ERROR_DOM_SECURITY_ERR;
 71405:     }
 71405: 
 71405:     // End of security checks, now we should be safe regarding cross-domain images
 71405:     // Notice that there is never a need to mark the WebGL canvas as write-only, since we reject write-only/cross-domain
 71405:     // texture sources in the first place.
 71405: 
 83345:     gfxImageSurface* surf = static_cast<gfxImageSurface*>(res.mSurface.get());
 32195: 
 32195:     res.mSurface.forget();
 32195:     *imageOut = surf;
 32195: 
 55904:     switch (surf->Format()) {
 55904:         case gfxASurface::ImageFormatARGB32:
 98002:             *format = WebGLTexelConversions::BGRA8; // careful, our ARGB means BGRA
 55904:             break;
 55904:         case gfxASurface::ImageFormatRGB24:
 98002:             *format = WebGLTexelConversions::BGRX8; // careful, our RGB24 is not tightly packed. Whence BGRX8.
 55904:             break;
 55904:         case gfxASurface::ImageFormatA8:
 98002:             *format = WebGLTexelConversions::A8;
 55904:             break;
 55904:         case gfxASurface::ImageFormatRGB16_565:
 98002:             *format = WebGLTexelConversions::RGB565;
 55904:             break;
 55904:         default:
 80486:             NS_ASSERTION(false, "Unsupported image format. Unimplemented.");
 55904:             return NS_ERROR_NOT_IMPLEMENTED;
 55904:     }
 55904: 
 32195:     return NS_OK;
 32195: }
 32195: 
 95834: template<JSBool TypedArrayTest(JSObject* obj, JSContext* cx),
 95834:          JSObject* TypedArrayCopy(JSContext* cx, JSObject* src)>
 93210: static JSObject*
 93210: GetTypedArray(JSContext* aCx, const JS::Value& aValue)
 93210: {
 93210:     if (!aValue.isObject()) {
 93210:         return NULL;
 93210:     }
 93210: 
 93210:     JSObject& value = aValue.toObject();
 93210: 
 95834:     if (TypedArrayTest(&value, aCx)) {
 93210:         return &value;
 93210:     }
 93210: 
 93210:     if (JS_IsArrayObject(aCx, &value)) {
 95834:         return TypedArrayCopy(aCx, &value);
 93210:     }
 93210: 
 93210:     return NULL;
 93210: }
 93210: 
 93210: static JSObject*
 93210: GetFloat32Array(JSContext* aCx, const JS::Value& aValue)
 93210: {
 95834:     return GetTypedArray<JS_IsFloat32Array, JS_NewFloat32ArrayFromArray>(aCx, aValue);
 93210: }
 93210: 
 47811: #define OBTAIN_UNIFORM_LOCATION(info)                                   \
 97698:     if (!ValidateObjectAllowNull(info, location_object))                \
 97698:         return;                                                         \
 97698:     if (!location_object)                                               \
 97698:         return;                                                         \
 70174:     /* the need to check specifically for !mCurrentProgram here is explained in bug 657556 */ \
 70174:     if (!mCurrentProgram) \
 70174:         return ErrorInvalidOperation("%s: no program is currently bound", info); \
 43010:     if (mCurrentProgram != location_object->Program()) \
 47814:         return ErrorInvalidOperation("%s: this uniform location doesn't correspond to the current program", info); \
 43331:     if (mCurrentProgram->Generation() != location_object->ProgramGeneration())            \
 47814:         return ErrorInvalidOperation("%s: This uniform location is obsolete since the program has been relinked", info); \
 43010:     GLint location = location_object->Location();
 43010: 
 97842: #define SIMPLE_ARRAY_METHOD_UNIFORM(name, expectedElemSize, arrayType, ptrType) \
 37417: NS_IMETHODIMP                                                                   \
 93210: WebGLContext::name(nsIWebGLUniformLocation *aLocation, const JS::Value& aValue, \
 93210:                    JSContext* aCx)                                              \
 93210: {                                                                               \
 95834:     JSObject* wa = GetTypedArray<JS_Is ## arrayType ## Array, JS_New ## arrayType ## ArrayFromArray>(aCx, aValue); \
 93210:     if (!wa) {                                                                  \
 93210:         return NS_ERROR_FAILURE;                                                \
 37417:     }                                                                           \
 97698:     arrayType ## Array arr(aCx, wa);                                            \
 97698:     name(static_cast<WebGLUniformLocation*>(aLocation), arr);                   \
 93210:     return NS_OK;                                                               \
 93210: }                                                                               \
 97698: void                                                                            \
 97698: WebGLContext::name##_base(WebGLUniformLocation *location_object,                \
 99322:                         uint32_t arrayLength, const ptrType* data) {            \
 97698:     if (!IsContextStable()) {                                                   \
 97698:         return;                                                                 \
 97698:     }                                                                           \
 93210:                                                                                 \
 93210:     OBTAIN_UNIFORM_LOCATION(#name ": location")                                 \
 97842:     int uniformElemSize = location_object->ElementSize();                           \
 97842:     if (expectedElemSize != uniformElemSize) {                                                   \
 95497:         return ErrorInvalidOperation(                                           \
 95497:             #name ": this function expected a uniform of element size %d,"      \
 95497:             " got a uniform of element size %d",                                \
 97842:             expectedElemSize,                                                                \
 97842:             uniformElemSize);                                                       \
 95497:     }                                                                           \
 95497:     const WebGLUniformInfo& info = location_object->Info();                     \
 97842:     if (arrayLength == 0 ||                                                     \
 97842:         arrayLength % expectedElemSize)                                                      \
 95497:     {                                                                           \
 95497:         return ErrorInvalidValue("%s: expected an array of length a multiple of" \
 97842:                                  " %d, got an array of length %d",              \
 95497:                                  #name,                                         \
 97842:                                  expectedElemSize,                                           \
 95497:                                  arrayLength);                                  \
 95497:     }                                                                           \
 95497:     if (!info.isArray &&                                                        \
 97842:         arrayLength != expectedElemSize) {                                                   \
 95497:         return ErrorInvalidOperation("%s: expected an array of length exactly %d" \
 95497:                                      " (since this uniform is not an array uniform)," \
 95497:                                      " got an array of length %d",              \
 95497:                                  #name,                                         \
 97842:                                  expectedElemSize,                           \
 95497:                                  arrayLength);                                  \
 93210:     }                                                                           \
 93210:                                                                                 \
 99228:     uint32_t numElementsToUpload = NS_MIN(info.arraySize, arrayLength/expectedElemSize);     \
 97842:     gl->f##name(location, numElementsToUpload, data);    \
 93210: }
 93210: 
 93210: #define SIMPLE_MATRIX_METHOD_UNIFORM(name, dim)                                 \
 37417: NS_IMETHODIMP                                                                   \
 93210: WebGLContext::name(nsIWebGLUniformLocation* aLocation, bool aTranspose,         \
 93210:                    const JS::Value& aValue, JSContext* aCx)                     \
 37417: {                                                                               \
 93210:     JSObject* wa = GetFloat32Array(aCx, aValue);                                \
 93210:     if (!wa) {                                                                  \
 93210:         return NS_ERROR_FAILURE;                                                \
 93210:     }                                                                           \
 97698:     Float32Array arr(aCx, wa);                                                  \
 97698:     name(static_cast<WebGLUniformLocation*>(aLocation), aTranspose, arr);       \
 80903:     return NS_OK;                                                               \
 93210: }                                                                               \
 97698: void                                                                            \
 97698: WebGLContext::name##_base(WebGLUniformLocation* location_object,                \
 97698:                           WebGLboolean aTranspose, uint32_t arrayLength,        \
 99322:                           const float* data)                                    \
 97698: {                                                                               \
 99228:     uint32_t expectedElemSize = (dim)*(dim);                                                     \
 97698:     if (!IsContextStable()) {                                                   \
 97698:         return;                                                                 \
 97698:     }                                                                           \
 93210:                                                                                 \
 47811:     OBTAIN_UNIFORM_LOCATION(#name ": location")                                 \
 99228:     uint32_t uniformElemSize = location_object->ElementSize();                           \
 97842:     if (expectedElemSize != uniformElemSize) {                                               \
 95497:         return ErrorInvalidOperation(                                           \
 95497:             #name ": this function expected a uniform of element size %d,"      \
 95497:             " got a uniform of element size %d",                                \
 97842:             expectedElemSize,                                                            \
 97842:             uniformElemSize);                                                       \
 95497:     }                                                                           \
 95497:     const WebGLUniformInfo& info = location_object->Info();                     \
 97842:     if (arrayLength == 0 ||                                                     \
 97842:         arrayLength % expectedElemSize)                                                \
 95497:     {                                                                           \
 95497:         return ErrorInvalidValue("%s: expected an array of length a multiple of" \
 97842:                                  " %d, got an array of length %d",              \
 95497:                                  #name,                                         \
 97842:                                  expectedElemSize,                                       \
 95497:                                  arrayLength);                                  \
 95497:     }                                                                           \
 95497:     if (!info.isArray &&                                                        \
 97842:         arrayLength != expectedElemSize) {                                               \
 95497:         return ErrorInvalidOperation("%s: expected an array of length exactly %d" \
 95497:                                      " (since this uniform is not an array uniform)," \
 95497:                                      " got an array of length %d", \
 95497:                                  #name,                                         \
 97842:                                  expectedElemSize,                           \
 95497:                                  arrayLength);                                  \
 93210:     }                                                                           \
 93210:     if (aTranspose) {                                                           \
 93210:         return ErrorInvalidValue(#name ": transpose must be FALSE as per the "  \
 93210:                                  "OpenGL ES 2.0 spec");                         \
 93210:     }                                                                           \
 93210:                                                                                 \
 37417:     MakeContextCurrent();                                                       \
 99228:     uint32_t numElementsToUpload = NS_MIN(info.arraySize, arrayLength/(expectedElemSize));  \
 97842:     gl->f##name(location, numElementsToUpload, false, data); \
 37417: }
 37417: 
 43010: #define SIMPLE_METHOD_UNIFORM_1(glname, name, t1)        \
 43010: NS_IMETHODIMP WebGLContext::name(nsIWebGLUniformLocation *ploc, t1 a1) {      \
 97698:     name(static_cast<WebGLUniformLocation*>(ploc), a1);                 \
 97698:     return NS_OK;                                                       \
 97698: }                                                                       \
 97698: void WebGLContext::name(WebGLUniformLocation *location_object, t1 a1) { \
 86627:     if (!IsContextStable())                                             \
 97698:         return;                                                         \
 47811:     OBTAIN_UNIFORM_LOCATION(#name ": location")                         \
 97698:     MakeContextCurrent(); gl->f##glname(location, a1);                  \
 43010: }
 43010: 
 43010: #define SIMPLE_METHOD_UNIFORM_2(glname, name, t1, t2)        \
 43010: NS_IMETHODIMP WebGLContext::name(nsIWebGLUniformLocation *ploc, t1 a1, t2 a2) {      \
 97698:     name(static_cast<WebGLUniformLocation*>(ploc), a1, a2);             \
 97698:     return NS_OK;                                                       \
 97698: }                                                                       \
 97698: void WebGLContext::name(WebGLUniformLocation *location_object, t1 a1, t2 a2) {\
 86627:     if (!IsContextStable())                                             \
 97698:         return;                                                         \
 47811:     OBTAIN_UNIFORM_LOCATION(#name ": location")                         \
 97698:     MakeContextCurrent(); gl->f##glname(location, a1, a2);              \
 43010: }
 43010: 
 43010: #define SIMPLE_METHOD_UNIFORM_3(glname, name, t1, t2, t3)        \
 43010: NS_IMETHODIMP WebGLContext::name(nsIWebGLUniformLocation *ploc, t1 a1, t2 a2, t3 a3) {      \
 97698:     name(static_cast<WebGLUniformLocation*>(ploc), a1, a2, a3);         \
 97698:     return NS_OK;                                                       \
 97698: }                                                                       \
 97698: void WebGLContext::name(WebGLUniformLocation *location_object, t1 a1, t2 a2, t3 a3) {\
 86627:     if (!IsContextStable())                                             \
 97698:         return;                                                         \
 47811:     OBTAIN_UNIFORM_LOCATION(#name ": location")                         \
 97698:     MakeContextCurrent(); gl->f##glname(location, a1, a2, a3);          \
 43010: }
 43010: 
 43010: #define SIMPLE_METHOD_UNIFORM_4(glname, name, t1, t2, t3, t4)        \
 43010: NS_IMETHODIMP WebGLContext::name(nsIWebGLUniformLocation *ploc, t1 a1, t2 a2, t3 a3, t4 a4) {      \
 97698:     name(static_cast<WebGLUniformLocation*>(ploc), a1, a2, a3, a4);     \
 97698:     return NS_OK;                                                       \
 97698: }                                                                       \
 97698: void WebGLContext::name(WebGLUniformLocation *location_object, t1 a1, t2 a2, t3 a3, t4 a4) {\
 86627:     if (!IsContextStable())                                             \
 97698:         return;                                                         \
 47811:     OBTAIN_UNIFORM_LOCATION(#name ": location")                         \
 97698:     MakeContextCurrent(); gl->f##glname(location, a1, a2, a3, a4);      \
 43010: }
 43010: 
 43010: SIMPLE_METHOD_UNIFORM_1(Uniform1i, Uniform1i, WebGLint)
 43010: SIMPLE_METHOD_UNIFORM_2(Uniform2i, Uniform2i, WebGLint, WebGLint)
 43010: SIMPLE_METHOD_UNIFORM_3(Uniform3i, Uniform3i, WebGLint, WebGLint, WebGLint)
 43010: SIMPLE_METHOD_UNIFORM_4(Uniform4i, Uniform4i, WebGLint, WebGLint, WebGLint, WebGLint)
 43010: 
 43010: SIMPLE_METHOD_UNIFORM_1(Uniform1f, Uniform1f, WebGLfloat)
 43010: SIMPLE_METHOD_UNIFORM_2(Uniform2f, Uniform2f, WebGLfloat, WebGLfloat)
 43010: SIMPLE_METHOD_UNIFORM_3(Uniform3f, Uniform3f, WebGLfloat, WebGLfloat, WebGLfloat)
 43010: SIMPLE_METHOD_UNIFORM_4(Uniform4f, Uniform4f, WebGLfloat, WebGLfloat, WebGLfloat, WebGLfloat)
 43010: 
 95834: SIMPLE_ARRAY_METHOD_UNIFORM(Uniform1iv, 1, Int32, WebGLint)
 95834: SIMPLE_ARRAY_METHOD_UNIFORM(Uniform2iv, 2, Int32, WebGLint)
 95834: SIMPLE_ARRAY_METHOD_UNIFORM(Uniform3iv, 3, Int32, WebGLint)
 95834: SIMPLE_ARRAY_METHOD_UNIFORM(Uniform4iv, 4, Int32, WebGLint)
 95834: 
 95834: SIMPLE_ARRAY_METHOD_UNIFORM(Uniform1fv, 1, Float32, WebGLfloat)
 95834: SIMPLE_ARRAY_METHOD_UNIFORM(Uniform2fv, 2, Float32, WebGLfloat)
 95834: SIMPLE_ARRAY_METHOD_UNIFORM(Uniform3fv, 3, Float32, WebGLfloat)
 95834: SIMPLE_ARRAY_METHOD_UNIFORM(Uniform4fv, 4, Float32, WebGLfloat)
 43010: 
 93210: SIMPLE_MATRIX_METHOD_UNIFORM(UniformMatrix2fv, 2)
 93210: SIMPLE_MATRIX_METHOD_UNIFORM(UniformMatrix3fv, 3)
 93210: SIMPLE_MATRIX_METHOD_UNIFORM(UniformMatrix4fv, 4)
 42916: 
 51898: NS_IMETHODIMP
 99228: WebGLContext::MozVertexAttrib1f(uint32_t index, WebGLfloat x0)
 97698: {
 97698:     VertexAttrib1f(index, x0);
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::VertexAttrib1f(WebGLuint index, WebGLfloat x0)
 51898: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 51898:     MakeContextCurrent();
 51898: 
 51898:     if (index) {
 51898:         gl->fVertexAttrib1f(index, x0);
 51898:     } else {
 51898:         mVertexAttrib0Vector[0] = x0;
 51898:         mVertexAttrib0Vector[1] = 0;
 51898:         mVertexAttrib0Vector[2] = 0;
 51898:         mVertexAttrib0Vector[3] = 1;
 51898:         if (gl->IsGLES2())
 51898:             gl->fVertexAttrib1f(index, x0);
 51898:     }
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 99228: WebGLContext::MozVertexAttrib2f(uint32_t index, WebGLfloat x0, WebGLfloat x1)
 97698: {
 97698:     VertexAttrib2f(index, x0, x1);
 51898:     return NS_OK;
 51898: }
 51898: 
 97698: void
 97698: WebGLContext::VertexAttrib2f(WebGLuint index, WebGLfloat x0, WebGLfloat x1)
 51898: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 51898:     MakeContextCurrent();
 51898: 
 51898:     if (index) {
 51898:         gl->fVertexAttrib2f(index, x0, x1);
 51898:     } else {
 51898:         mVertexAttrib0Vector[0] = x0;
 51898:         mVertexAttrib0Vector[1] = x1;
 51898:         mVertexAttrib0Vector[2] = 0;
 51898:         mVertexAttrib0Vector[3] = 1;
 51898:         if (gl->IsGLES2())
 51898:             gl->fVertexAttrib2f(index, x0, x1);
 51898:     }
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 99228: WebGLContext::MozVertexAttrib3f(uint32_t index, WebGLfloat x0, WebGLfloat x1, WebGLfloat x2)
 97698: {
 97698:     VertexAttrib3f(index, x0, x1, x2);
 51898:     return NS_OK;
 51898: }
 51898: 
 97698: void
 97698: WebGLContext::VertexAttrib3f(WebGLuint index, WebGLfloat x0, WebGLfloat x1, WebGLfloat x2)
 51898: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 51898:     MakeContextCurrent();
 51898: 
 51898:     if (index) {
 51898:         gl->fVertexAttrib3f(index, x0, x1, x2);
 51898:     } else {
 51898:         mVertexAttrib0Vector[0] = x0;
 51898:         mVertexAttrib0Vector[1] = x1;
 51898:         mVertexAttrib0Vector[2] = x2;
 51898:         mVertexAttrib0Vector[3] = 1;
 51898:         if (gl->IsGLES2())
 51898:             gl->fVertexAttrib3f(index, x0, x1, x2);
 51898:     }
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 99228: WebGLContext::MozVertexAttrib4f(uint32_t index, WebGLfloat x0, WebGLfloat x1,
 97698:                                                 WebGLfloat x2, WebGLfloat x3)
 97698: {
 97698:     VertexAttrib4f(index, x0, x1, x2, x3);
 51898:     return NS_OK;
 51898: }
 51898: 
 97698: void
 97698: WebGLContext::VertexAttrib4f(WebGLuint index, WebGLfloat x0, WebGLfloat x1,
 51898:                                               WebGLfloat x2, WebGLfloat x3)
 51898: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 51898:     MakeContextCurrent();
 51898: 
 51898:     if (index) {
 51898:         gl->fVertexAttrib4f(index, x0, x1, x2, x3);
 51898:     } else {
 51898:         mVertexAttrib0Vector[0] = x0;
 51898:         mVertexAttrib0Vector[1] = x1;
 51898:         mVertexAttrib0Vector[2] = x2;
 51898:         mVertexAttrib0Vector[3] = x3;
 51898:         if (gl->IsGLES2())
 51898:             gl->fVertexAttrib4f(index, x0, x1, x2, x3);
 51898:     }
 51898: }
 51898: 
 95834: #define SIMPLE_ARRAY_METHOD_NO_COUNT(name, cnt, ptrType)                        \
 51898: NS_IMETHODIMP                                                                   \
 93211: WebGLContext::name(WebGLuint idx, const JS::Value& aValue, JSContext* aCx)      \
 93211: {                                                                               \
 93211:     JSObject* wa = GetFloat32Array(aCx, aValue);                                \
 93211:     if (!wa) {                                                                  \
 93211:         return NS_ERROR_FAILURE;                                                \
 51898:     }                                                                           \
 97698:     Float32Array arr(aCx, wa);                                                  \
 97698:     name(idx, arr);                                                             \
 80903:     return NS_OK;                                                               \
 93211: }                                                                               \
 97698: void                                                                            \
 97698: WebGLContext::name##_base(WebGLuint idx, uint32_t arrayLength,                  \
 99322:                           const WebGLfloat* ptr)                                \
 97698: {                                                                               \
 97698:     if (!IsContextStable()) {                                                   \
 97698:         return;                                                                 \
 97698:     }                                                                           \
 97698:     if (arrayLength < cnt) {                                                    \
 93211:         return ErrorInvalidOperation(#name ": array must be >= %d elements",    \
 93211:                                      cnt);                                      \
 93211:     }                                                                           \
 93211:                                                                                 \
 51898:     MakeContextCurrent();                                                       \
 51898:     if (idx) {                                                                  \
 51898:         gl->f##name(idx, ptr);                                                  \
 51898:     } else {                                                                    \
 51898:         mVertexAttrib0Vector[0] = ptr[0];                                       \
 51898:         mVertexAttrib0Vector[1] = cnt > 1 ? ptr[1] : ptrType(0);                \
 51898:         mVertexAttrib0Vector[2] = cnt > 2 ? ptr[2] : ptrType(0);                \
 51898:         mVertexAttrib0Vector[3] = cnt > 3 ? ptr[3] : ptrType(1);                \
 51898:         if (gl->IsGLES2())                                                      \
 51898:             gl->f##name(idx, ptr);                                              \
 51898:     }                                                                           \
 51898: }
 42916: 
 95834: SIMPLE_ARRAY_METHOD_NO_COUNT(VertexAttrib1fv, 1, WebGLfloat)
 95834: SIMPLE_ARRAY_METHOD_NO_COUNT(VertexAttrib2fv, 2, WebGLfloat)
 95834: SIMPLE_ARRAY_METHOD_NO_COUNT(VertexAttrib3fv, 3, WebGLfloat)
 95834: SIMPLE_ARRAY_METHOD_NO_COUNT(VertexAttrib4fv, 4, WebGLfloat)
 32195: 
 32195: NS_IMETHODIMP
 42471: WebGLContext::UseProgram(nsIWebGLProgram *pobj)
 32195: {
 97698:     UseProgram(static_cast<WebGLProgram*>(pobj));
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::UseProgram(WebGLProgram *prog)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return;
 97698: 
 97698:     if (!ValidateObjectAllowNull("useProgram", prog))
 97698:         return;
 97698: 
 97698:     WebGLuint progname = prog ? prog->GLName() : 0;;
 32195:     MakeContextCurrent();
 32195: 
 60037:     if (prog && !prog->LinkStatus())
 99232:         return ErrorInvalidOperation("useProgram: program was not linked successfully");
 60037: 
 42472:     gl->fUseProgram(progname);
 60037: 
 42472:     mCurrentProgram = prog;
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 42471: WebGLContext::ValidateProgram(nsIWebGLProgram *pobj)
 32195: {
 97698:     ValidateProgram(static_cast<WebGLProgram*>(pobj));
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::ValidateProgram(WebGLProgram *prog)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return;
 97698: 
 97698:     if (!ValidateObject("validateProgram", prog))
 97698:         return;
 42471: 
 32195:     MakeContextCurrent();
 32195: 
 56958: #ifdef XP_MACOSX
 70162:     // see bug 593867 for NVIDIA and bug 657201 for ATI. The latter is confirmed with Mac OS 10.6.7
 95058:     if (gl->WorkAroundDriverBugs()) {
 99231:         GenerateWarning("validateProgram: implemented as a no-operation on Mac to work around crashes");
 97698:         return;
 95058:     }
 56958: #endif
 56958: 
 97698:     WebGLuint progname = prog->GLName();
 42472:     gl->fValidateProgram(progname);
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 32835: WebGLContext::CreateFramebuffer(nsIWebGLFramebuffer **retval)
 32195: {
 97698:     *retval = CreateFramebuffer().get();
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: already_AddRefed<WebGLFramebuffer>
 97698: WebGLContext::CreateFramebuffer()
 97698: {
 86627:     if (!IsContextStable())
 97698:         return nsnull;
 97698:     nsRefPtr<WebGLFramebuffer> globj = new WebGLFramebuffer(this);
 97698:     return globj.forget();
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 32835: WebGLContext::CreateRenderbuffer(nsIWebGLRenderbuffer **retval)
 32195: {
 97698:     *retval = CreateRenderbuffer().get();
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: already_AddRefed<WebGLRenderbuffer>
 97698: WebGLContext::CreateRenderbuffer()
 97698: {
 86627:     if (!IsContextStable())
 97698:         return nsnull;
 97698:     nsRefPtr<WebGLRenderbuffer> globj = new WebGLRenderbuffer(this);
 97698:     return globj.forget();
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozViewport(WebGLint x, WebGLint y, WebGLsizei width, WebGLsizei height)
 97698: {
 97698:     Viewport(x, y, width, height);
 80903:     return NS_OK;
 97698: }
 97698: 
 97698: void
 46442: WebGLContext::Viewport(WebGLint x, WebGLint y, WebGLsizei width, WebGLsizei height)
 46442: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 46442:     if (width < 0 || height < 0)
 99232:         return ErrorInvalidValue("viewport: negative size");
 46442: 
 46442:     MakeContextCurrent();
 46442:     gl->fViewport(x, y, width, height);
 46442: }
 32195: 
 32195: NS_IMETHODIMP
 42472: WebGLContext::CompileShader(nsIWebGLShader *sobj)
 32195: {
 97698:     CompileShader(static_cast<WebGLShader*>(sobj));
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::CompileShader(WebGLShader *shader)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return;
 97698: 
 97698:     if (!ValidateObject("compileShader", shader))
 97698:         return;
 97698: 
 97698:     WebGLuint shadername = shader->GLName();
 60037: 
 32195:     MakeContextCurrent();
 32195: 
 91439:     ShShaderOutput targetShaderSourceLanguage = gl->IsGLES2() ? SH_ESSL_OUTPUT : SH_GLSL_OUTPUT;
 91439:     bool useShaderSourceTranslation = true;
 91439: 
 49256: #if defined(USE_ANGLE)
 47653:     if (shader->NeedsTranslation() && mShaderValidation) {
 47653:         ShHandle compiler = 0;
 55267:         ShBuiltInResources resources;
 55267:         memset(&resources, 0, sizeof(ShBuiltInResources));
 55267: 
 55267:         resources.MaxVertexAttribs = mGLMaxVertexAttribs;
 55267:         resources.MaxVertexUniformVectors = mGLMaxVertexUniformVectors;
 55267:         resources.MaxVaryingVectors = mGLMaxVaryingVectors;
 55267:         resources.MaxVertexTextureImageUnits = mGLMaxVertexTextureImageUnits;
 55267:         resources.MaxCombinedTextureImageUnits = mGLMaxTextureUnits;
 55267:         resources.MaxTextureImageUnits = mGLMaxTextureImageUnits;
 55267:         resources.MaxFragmentUniformVectors = mGLMaxFragmentUniformVectors;
 55267:         resources.MaxDrawBuffers = 1;
102165:         if (IsExtensionEnabled(OES_standard_derivatives))
 79603:             resources.OES_standard_derivatives = 1;
 55267: 
 78164:         // We're storing an actual instance of StripComments because, if we don't, the 
 78164:         // cleanSource nsAString instance will be destroyed before the reference is
 78164:         // actually used.
 78164:         StripComments stripComments(shader->Source());
 78164:         const nsAString& cleanSource = nsString(stripComments.result().Elements(), stripComments.length());
 78164:         if (!ValidateGLSLString(cleanSource, "compileShader"))
 97698:             return;
 78164: 
 78164:         const nsPromiseFlatString& flatSource = PromiseFlatString(cleanSource);
 78164: 
 78164:         // shaderSource() already checks that the source stripped of comments is in the
 78164:         // 7-bit ASCII range, so we can skip the NS_IsAscii() check.
 78164:         const nsCString& sourceCString = NS_LossyConvertUTF16toASCII(flatSource);
 78164: 
 95058:         if (gl->WorkAroundDriverBugs()) {
 99228:             const uint32_t maxSourceLength = 0x3ffff;
 78164:             if (sourceCString.Length() > maxSourceLength)
 95058:                 return ErrorInvalidValue("compileShader: source has more than %d characters", 
 95058:                                          maxSourceLength);
 95058:         }
 78164: 
 78164:         const char *s = sourceCString.get();
 47653: 
 91439:         compiler = ShConstructCompiler((ShShaderType) shader->ShaderType(),
 91439:                                        SH_WEBGL_SPEC,
 91439:                                        targetShaderSourceLanguage,
 91439:                                        &resources);
 91439: 
 95497:         int compileOptions = SH_ATTRIBUTES_UNIFORMS;
 91439:         if (useShaderSourceTranslation) {
 91439:             compileOptions |= SH_OBJECT_CODE
 95497:                             | SH_MAP_LONG_VARIABLE_NAMES;
 81619: #ifdef XP_MACOSX
103772:             if (gl->WorkAroundDriverBugs()) {
103772:                 // Work around bug 665578 and bug 769810
103772:                 if (gl->Vendor() == gl::GLContext::VendorATI) {
 80779:                     compileOptions |= SH_EMULATE_BUILT_IN_FUNCTIONS;
 95058:                 }
103772: 
103772:                 // Work around bug 735560
103772:                 if (gl->Vendor() == gl::GLContext::VendorIntel) {
103772:                     compileOptions |= SH_EMULATE_BUILT_IN_FUNCTIONS;
103772:                 }
103772:             }
 81619: #endif
 91439:         }
 80779: 
 80779:         if (!ShCompile(compiler, &s, 1, compileOptions)) {
 55267:             int len = 0;
 55267:             ShGetInfo(compiler, SH_INFO_LOG_LENGTH, &len);
 55267: 
 55267:             if (len) {
 55299:                 nsCAutoString info;
 55299:                 info.SetLength(len);
 55267:                 ShGetInfoLog(compiler, info.BeginWriting());
 55267:                 shader->SetTranslationFailure(info);
 49256:             } else {
 49256:                 shader->SetTranslationFailure(NS_LITERAL_CSTRING("Internal error: failed to get shader info log"));
 49256:             }
 47653:             ShDestruct(compiler);
 97698:             return;
 47653:         }
 47653: 
 91439:         int num_attributes = 0;
 91439:         ShGetInfo(compiler, SH_ACTIVE_ATTRIBUTES, &num_attributes);
 91439:         int num_uniforms = 0;
 91439:         ShGetInfo(compiler, SH_ACTIVE_UNIFORMS, &num_uniforms);
 91439:         int attrib_max_length = 0;
 91439:         ShGetInfo(compiler, SH_ACTIVE_ATTRIBUTE_MAX_LENGTH, &attrib_max_length);
 91439:         int uniform_max_length = 0;
 91439:         ShGetInfo(compiler, SH_ACTIVE_UNIFORM_MAX_LENGTH, &uniform_max_length);
 91439:         int mapped_max_length = 0;
 91439:         ShGetInfo(compiler, SH_MAPPED_NAME_MAX_LENGTH, &mapped_max_length);
 91439: 
 91439:         shader->mAttribMaxNameLength = attrib_max_length;
 91439: 
 91439:         shader->mAttributes.Clear();
 91439:         shader->mUniforms.Clear();
 95497:         shader->mUniformInfos.Clear();
 95497: 
 91439:         nsAutoArrayPtr<char> attribute_name(new char[attrib_max_length+1]);
 91439:         nsAutoArrayPtr<char> uniform_name(new char[uniform_max_length+1]);
 91439:         nsAutoArrayPtr<char> mapped_name(new char[mapped_max_length+1]);
 91439: 
 95497: 
 95497:         for (int i = 0; i < num_uniforms; i++) {
 95497:             int length, size;
 95497:             ShDataType type;
 95497:             ShGetActiveUniform(compiler, i,
 95497:                                 &length, &size, &type,
 95497:                                 uniform_name,
 95497:                                 mapped_name);
 91439:             if (useShaderSourceTranslation) {
 95497:                 shader->mUniforms.AppendElement(WebGLMappedIdentifier(
 95497:                                                     nsDependentCString(uniform_name),
 95497:                                                     nsDependentCString(mapped_name)));
 95497:             }
 95497: 
 95497:             // we always query uniform info, regardless of useShaderSourceTranslation,
 95497:             // as we need it to validate uniform setter calls, and it doesn't rely on
 95497:             // shader translation.
 95497:             shader->mUniformInfos.AppendElement(WebGLUniformInfo(
 95497:                                                     size,
 95497:                                                     length > 1 && mapped_name[length - 1] == ']',
 95497:                                                     type));
 95497:         }
 95497: 
 95497:         if (useShaderSourceTranslation) {
 95497: 
 91439:             for (int i = 0; i < num_attributes; i++) {
 91439:                 int length, size;
 91439:                 ShDataType type;
 91439:                 ShGetActiveAttrib(compiler, i,
 91439:                                   &length, &size, &type,
 91439:                                   attribute_name,
 91439:                                   mapped_name);
 91439:                 shader->mAttributes.AppendElement(WebGLMappedIdentifier(
 91439:                                                     nsDependentCString(attribute_name),
 91439:                                                     nsDependentCString(mapped_name)));
 91439:             }
 91439: 
 55267:             int len = 0;
 55267:             ShGetInfo(compiler, SH_OBJECT_CODE_LENGTH, &len);
 55267: 
 55299:             nsCAutoString translatedSrc;
 55299:             translatedSrc.SetLength(len);
 55267:             ShGetObjectCode(compiler, translatedSrc.BeginWriting());
 55267: 
 55267:             nsPromiseFlatCString translatedSrc2(translatedSrc);
 55267:             const char *ts = translatedSrc2.get();
 55267: 
 55267:             gl->fShaderSource(shadername, 1, &ts, NULL);
 91439:         } else { // not useShaderSourceTranslation
 91439:             // we just pass the raw untranslated shader source. We then can't use ANGLE idenfier mapping.
 91439:             // that's really bad, as that means we can't be 100% conformant. We should work towards always
 91439:             // using ANGLE identifier mapping.
 47653:             gl->fShaderSource(shadername, 1, &s, NULL);
 55267:         }
 55267: 
 47653:         shader->SetTranslationSuccess();
 47653: 
 47653:         ShDestruct(compiler);
 78164: 
 78164:         gl->fCompileShader(shadername);
 78164:     }
 78007: #endif
 32195: }
 32195: 
 88492: NS_IMETHODIMP
 93207: WebGLContext::CompressedTexImage2D(WebGLenum target, WebGLint level, WebGLenum internalformat,
 93207:                                    WebGLsizei width, WebGLsizei height, WebGLint border,
 95834:                                    const JS::Value& pixels, JSContext *cx)
 95834: {
 95834:     if (!pixels.isObject() || !JS_IsTypedArrayObject(&pixels.toObject(), cx)) {
 88492:         return NS_ERROR_FAILURE;
 88492:     }
 88492: 
 97698:     ArrayBufferView view(cx, &pixels.toObject());
 97698:     CompressedTexImage2D(target, level, internalformat, width, height, border, view);
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::CompressedTexImage2D(WebGLenum target, WebGLint level, WebGLenum internalformat,
 97698:                                    WebGLsizei width, WebGLsizei height, WebGLint border,
 97698:                                    ArrayBufferView& view)
 97698: {
 93207:     if (!IsContextStable()) {
 97698:         return;
 93207:     }
 88492: 
 98021:     if (!ValidateTexImage2DTarget(target, width, height, "compressedTexImage2D")) {
 98021:         return;
 98021:     }
 98021: 
 88492:     WebGLTexture *tex = activeBoundTextureForTarget(target);
 98021:     if (!tex) {
 98021:         ErrorInvalidOperation("compressedTexImage2D: no texture is bound to this target");
 98021:         return;
 98021:     }
 98021: 
 98021:     if (!mCompressedTextureFormats.Contains(internalformat)) {
 98021:         ErrorInvalidEnum("compressedTexImage2D: compressed texture format 0x%x is not supported", internalformat);
 98021:         return;
 98021:     }
 98021: 
 98021:     if (!ValidateLevelWidthHeightForTarget(target, level, width, height, "compressedTexImage2D")) {
 98021:         return;
 98021:     }
 98021: 
 98021:     if (border) {
 98021:         ErrorInvalidValue("compressedTexImage2D: border is not 0");
 98021:         return;
 98021:     }
 98021: 
 98021:     uint32_t byteLength = view.mLength;
 98021:     if (!ValidateCompressedTextureSize(level, internalformat, width, height, byteLength, "compressedTexImage2D")) {
 98021:         return;
 98021:     }
 98021: 
 98021:     gl->fCompressedTexImage2D(target, level, internalformat, width, height, border, byteLength, view.mData);
 98021:     tex->SetImageInfo(target, level, width, height, internalformat, LOCAL_GL_UNSIGNED_BYTE);
 88492: }
 88492: 
 88492: NS_IMETHODIMP
 93207: WebGLContext::CompressedTexSubImage2D(WebGLenum target, WebGLint level, WebGLint xoffset,
 93207:                                       WebGLint yoffset, WebGLsizei width, WebGLsizei height,
 95834:                                       WebGLenum format, const JS::Value& pixels, JSContext *cx)
 95834: {
 95834:     if (!pixels.isObject() || !JS_IsTypedArrayObject(&pixels.toObject(), cx)) {
 88492:         return NS_ERROR_FAILURE;
 88492:     }
 88492: 
 97698:     ArrayBufferView view(cx, &pixels.toObject());
 97698:     CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height,
 97698:                             format, view);
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::CompressedTexSubImage2D(WebGLenum target, WebGLint level, WebGLint xoffset,
 97698:                                       WebGLint yoffset, WebGLsizei width, WebGLsizei height,
 97698:                                       WebGLenum format, ArrayBufferView& view)
 97698: {
 93207:     if (!IsContextStable()) {
 97698:         return;
 93207:     }
 88492: 
 98021:     switch (target) {
 98021:         case LOCAL_GL_TEXTURE_2D:
 98021:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X:
 98021:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
 98021:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
 98021:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
 98021:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
 98021:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
 98021:             break;
 98021:         default:
 98021:             return ErrorInvalidEnumInfo("texSubImage2D: target", target);
 98021:     }
 98021: 
 88492:     WebGLTexture *tex = activeBoundTextureForTarget(target);
 93207:     if (!tex) {
 98021:         ErrorInvalidOperation("compressedTexSubImage2D: no texture is bound to this target");
 98021:         return;
 98021:     }
 98021: 
 98021:     if (!mCompressedTextureFormats.Contains(format)) {
 98021:         ErrorInvalidEnum("compressedTexSubImage2D: compressed texture format 0x%x is not supported", format);
 98021:         return;
 98021:     }
 98021: 
 98021:     if (!ValidateLevelWidthHeightForTarget(target, level, width, height, "compressedTexSubImage2D")) {
 98021:         return;
 98021:     }
 98021: 
 98021:     uint32_t byteLength = view.mLength;
 98021:     if (!ValidateCompressedTextureSize(level, format, width, height, byteLength, "compressedTexSubImage2D")) {
 98021:         return;
 98021:     }
 98021: 
 98021:     size_t face = WebGLTexture::FaceForTarget(target);
 98021: 
 98021:     if (!tex->HasImageInfoAt(level, face)) {
 98021:         ErrorInvalidOperation("compressedTexSubImage2D: no texture image previously defined for this level and face");
 98021:         return;
 98021:     }
 98021: 
 98021:     const WebGLTexture::ImageInfo &imageInfo = tex->ImageInfoAt(level, face);
 98021: 
 98021:     if (!CanvasUtils::CheckSaneSubrectSize(xoffset, yoffset, width, height, imageInfo.Width(), imageInfo.Height())) {
 98021:         ErrorInvalidValue("compressedTexSubImage2D: subtexture rectangle out of bounds");
 98021:         return;
 98021:     }
 98021: 
 98021:     switch (format) {
 98021:         case LOCAL_GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
 98021:         case LOCAL_GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
 98021:         case LOCAL_GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
 98021:         case LOCAL_GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
 98021:         {
 98021:             if (xoffset < 0 || xoffset % 4 != 0) {
 98021:                 ErrorInvalidOperation("compressedTexSubImage2D: xoffset is not a multiple of 4");
 98021:                 return;
 98021:             }
 98021:             if (yoffset < 0 || yoffset % 4 != 0) {
 98021:                 ErrorInvalidOperation("compressedTexSubImage2D: yoffset is not a multiple of 4");
 98021:                 return;
 98021:             }
 98021:             if (width % 4 != 0 && width != imageInfo.Width()) {
 98021:                 ErrorInvalidOperation("compressedTexSubImage2D: width is not a multiple of 4 or equal to texture width");
 98021:                 return;
 98021:             }
 98021:             if (height % 4 != 0 && height != imageInfo.Height()) {
 98021:                 ErrorInvalidOperation("compressedTexSubImage2D: height is not a multiple of 4 or equal to texture height");
 98021:                 return;
 98021:             }
 98021:             break;
 98021:         }
 98021:     }
 98021: 
 98021:     gl->fCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, byteLength, view.mData);
 98021: 
 98021:     return;
 88492: }
 32195: 
 32195: NS_IMETHODIMP
 97698: WebGLContext::GetShaderParameter(nsIWebGLShader *sobj, WebGLenum pname, JS::Value *retval)
 97698: {
 97698:     *retval = GetShaderParameter(static_cast<WebGLShader*>(sobj), pname);
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: JS::Value
 97698: WebGLContext::GetShaderParameter(WebGLShader *shader, WebGLenum pname)
 32835: {
 86627:     if (!IsContextStable())
 97698:         return JS::NullValue();
 97698: 
 97698:     if (!ValidateObject("getShaderParameter: shader", shader))
 97698:         return JS::NullValue();
 97698: 
 97698:     WebGLuint shadername = shader->GLName();
 35013: 
 35013:     MakeContextCurrent();
 35013: 
 35013:     switch (pname) {
 35013:         case LOCAL_GL_SHADER_TYPE:
 35013:         {
 43851:             GLint i = 0;
 43851:             gl->fGetShaderiv(shadername, pname, &i);
 99240:             return JS::NumberValue(uint32_t(i));
 47653:         }
 47653:             break;
 43011:         case LOCAL_GL_DELETE_STATUS:
 97698:             return JS::BooleanValue(shader->IsDeleteRequested());
 83394:             break;
 43011:         case LOCAL_GL_COMPILE_STATUS:
 43011:         {
 43851:             GLint i = 0;
 43851:             gl->fGetShaderiv(shadername, pname, &i);
 97698:             return JS::BooleanValue(bool(i));
 43011:         }
 43011:             break;
 35013:         default:
 99232:             ErrorInvalidEnumInfo("getShaderParameter: parameter", pname);
 97698:     }
 97698: 
 97698:     return JS::NullValue();
 35013: }
 35013: 
 32195: NS_IMETHODIMP
 42472: WebGLContext::GetShaderInfoLog(nsIWebGLShader *sobj, nsAString& retval)
 32195: {
 97819:     ErrorResult rv;
 97698:     GetShaderInfoLog(static_cast<WebGLShader*>(sobj), retval, rv);
 97819:     return rv.ErrorCode();
 97698: }
 97698: 
 97698: void
 97819: WebGLContext::GetShaderInfoLog(WebGLShader *shader, nsAString& retval,
 97819:                                ErrorResult& rv)
 97698: {
 99787:     nsCAutoString s;
 99787:     GetShaderInfoLog(shader, s, rv);
 99787:     if (s.IsVoid())
 99787:         retval.SetIsVoid(true);
 99787:     else
 99787:         CopyASCIItoUTF16(s, retval);
 99787: }
 99787: 
 99787: void
 99787: WebGLContext::GetShaderInfoLog(WebGLShader *shader, nsACString& retval,
 99787:                                ErrorResult& rv)
 99787: {
 86627:     if (!IsContextStable())
 80903:     {
 80903:         retval.SetIsVoid(true);
 97698:         return;
 97698:     }
 97698: 
 97698:     if (!ValidateObject("getShaderInfoLog: shader", shader))
 97698:         return;
 42471: 
 99787:     retval = shader->TranslationLog();
 99787:     if (!retval.IsVoid()) {
 97698:         return;
 47653:     }
 47653: 
 32195:     MakeContextCurrent();
 32195: 
 97698:     WebGLuint shadername = shader->GLName();
 72540:     GLint k = -1;
 72540:     gl->fGetShaderiv(shadername, LOCAL_GL_INFO_LOG_LENGTH, &k);
 97698:     if (k == -1) {
 97819:         return rv.Throw(NS_ERROR_FAILURE); // XXX GL Error? should never happen.
 97698:     }
 32195: 
 32195:     if (k == 0) {
 32195:         retval.Truncate();
 97698:         return;
 32195:     }
 32195: 
 99787:     retval.SetCapacity(k);
 99787:     gl->fGetShaderInfoLog(shadername, k, &k, (char*) retval.BeginWriting());
 99787:     retval.SetLength(k);
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 84804: WebGLContext::GetShaderPrecisionFormat(WebGLenum shadertype, WebGLenum precisiontype, nsIWebGLShaderPrecisionFormat **retval)
 84804: {
 97698:     *retval = GetShaderPrecisionFormat(shadertype, precisiontype).get();
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: already_AddRefed<WebGLShaderPrecisionFormat>
 97698: WebGLContext::GetShaderPrecisionFormat(WebGLenum shadertype, WebGLenum precisiontype)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return nsnull;
 84804: 
 84804:     switch (shadertype) {
 84804:         case LOCAL_GL_FRAGMENT_SHADER:
 84804:         case LOCAL_GL_VERTEX_SHADER:
 84804:             break;
 84804:         default:
 97698:             ErrorInvalidEnumInfo("getShaderPrecisionFormat: shadertype", shadertype);
 97698:             return nsnull;
 84804:     }
 84804: 
 84804:     switch (precisiontype) {
 84804:         case LOCAL_GL_LOW_FLOAT:
 84804:         case LOCAL_GL_MEDIUM_FLOAT:
 84804:         case LOCAL_GL_HIGH_FLOAT:
 84804:         case LOCAL_GL_LOW_INT:
 84804:         case LOCAL_GL_MEDIUM_INT:
 84804:         case LOCAL_GL_HIGH_INT:
 84804:             break;
 84804:         default:
 97698:             ErrorInvalidEnumInfo("getShaderPrecisionFormat: precisiontype", precisiontype);
 97698:             return nsnull;
 84804:     }
 84804: 
 84804:     MakeContextCurrent();
 84804: 
 84804:     GLint range[2], precision;
 84804:     gl->fGetShaderPrecisionFormat(shadertype, precisiontype, range, &precision);
 84804: 
 84804:     WebGLShaderPrecisionFormat *retShaderPrecisionFormat
 84804:         = new WebGLShaderPrecisionFormat(range[0], range[1], precision);
 97698:     NS_ADDREF(retShaderPrecisionFormat);
 97698:     return retShaderPrecisionFormat;
 84804: }
 84804: 
 84804: NS_IMETHODIMP
 42472: WebGLContext::GetShaderSource(nsIWebGLShader *sobj, nsAString& retval)
 32195: {
 97698:     GetShaderSource(static_cast<WebGLShader*>(sobj), retval);
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::GetShaderSource(WebGLShader *shader, nsAString& retval)
 97698: {
 86627:     if (!IsContextStable())
 80903:     {
 80903:         retval.SetIsVoid(true);
 97698:         return;
 97698:     }
 97698: 
 97698:     if (!ValidateObject("getShaderSource: shader", shader))
 97698:         return;
 42471: 
 78164:     retval.Assign(shader->Source());
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 42472: WebGLContext::ShaderSource(nsIWebGLShader *sobj, const nsAString& source)
 32195: {
 97698:     ShaderSource(static_cast<WebGLShader*>(sobj), source);
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::ShaderSource(WebGLShader *shader, const nsAString& source)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return;
 97698: 
 97698:     if (!ValidateObject("shaderSource: shader", shader))
 97698:         return;
 42471: 
 78164:     // We're storing an actual instance of StripComments because, if we don't, the 
 78164:     // cleanSource nsAString instance will be destroyed before the reference is
 78164:     // actually used.
 78164:     StripComments stripComments(source);
 78164:     const nsAString& cleanSource = nsString(stripComments.result().Elements(), stripComments.length());
 78164:     if (!ValidateGLSLString(cleanSource, "compileShader"))
 97698:         return;
 97698: 
 97698:     shader->SetSource(source);
 97698: 
 97698:     shader->SetNeedsTranslation();
 97698: }
 97698: 
 97698: NS_IMETHODIMP
 97698: WebGLContext::MozVertexAttribPointer(WebGLuint index, WebGLint size, WebGLenum type,
 97698:                                      WebGLboolean normalized, WebGLsizei stride,
 97698:                                      WebGLintptr byteOffset)
 97698: {
 97698:     VertexAttribPointer(index, size, type, normalized, stride, byteOffset);
 78164:     return NS_OK;
 97698: }
 97698: 
 97698: void
 42916: WebGLContext::VertexAttribPointer(WebGLuint index, WebGLint size, WebGLenum type,
 51899:                                   WebGLboolean normalized, WebGLsizei stride,
 97698:                                   WebGLintptr byteOffset)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 32195:     if (mBoundArrayBuffer == nsnull)
 99232:         return ErrorInvalidOperation("vertexAttribPointer: must have valid GL_ARRAY_BUFFER binding");
 42477: 
 51899:     WebGLsizei requiredAlignment = 1;
 42477:     switch (type) {
 42477:       case LOCAL_GL_BYTE:
 42477:       case LOCAL_GL_UNSIGNED_BYTE:
 51899:           requiredAlignment = 1;
 51899:           break;
 42477:       case LOCAL_GL_SHORT:
 42477:       case LOCAL_GL_UNSIGNED_SHORT:
 51899:           requiredAlignment = 2;
 51899:           break;
 42477:       // XXX case LOCAL_GL_FIXED:
 42477:       case LOCAL_GL_FLOAT:
 51899:           requiredAlignment = 4;
 42477:           break;
 42477:       default:
 99232:           return ErrorInvalidEnumInfo("vertexAttribPointer: type", type);
 42477:     }
 32195: 
 51899:     // requiredAlignment should always be a power of two.
 51899:     WebGLsizei requiredAlignmentMask = requiredAlignment - 1;
 51899: 
 63071:     if (!ValidateAttribIndex(index, "vertexAttribPointer"))
 97698:         return;
 32195: 
 32195:     if (size < 1 || size > 4)
 99232:         return ErrorInvalidValue("vertexAttribPointer: invalid element size");
 42477: 
 51899:     if (stride < 0 || stride > 255) // see WebGL spec section 6.6 "Vertex Attribute Data Stride"
 99232:         return ErrorInvalidValue("vertexAttribPointer: negative or too large stride");
 51899: 
 51899:     if (byteOffset < 0)
 99232:         return ErrorInvalidValue("vertexAttribPointer: negative offset");
 51899: 
 51899:     if (stride & requiredAlignmentMask) {
 99232:         return ErrorInvalidOperation("vertexAttribPointer: stride doesn't satisfy the alignment "
 51899:                                      "requirement of given type");
 51899:     }
 51899: 
 51899:     if (byteOffset & requiredAlignmentMask) {
 99232:         return ErrorInvalidOperation("vertexAttribPointer: byteOffset doesn't satisfy the alignment "
 51899:                                      "requirement of given type");
 51899: 
 51899:     }
 51899:     
 34453:     /* XXX make work with bufferSubData & heterogeneous types 
 32195:     if (type != mBoundArrayBuffer->GLType())
 99232:         return ErrorInvalidOperation("vertexAttribPointer: type must match bound VBO type: %d != %d", type, mBoundArrayBuffer->GLType());
 34453:     */
 32195: 
 32195:     WebGLVertexAttribData &vd = mAttribBuffers[index];
 32195: 
 32195:     vd.buf = mBoundArrayBuffer;
 32195:     vd.stride = stride;
 32195:     vd.size = size;
 43009:     vd.byteOffset = byteOffset;
 43009:     vd.type = type;
 51898:     vd.normalized = normalized;
 32195: 
 32195:     MakeContextCurrent();
 32195: 
 32195:     gl->fVertexAttribPointer(index, size, type, normalized,
 34453:                              stride,
 87420:                              reinterpret_cast<void*>(byteOffset));
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 99228: WebGLContext::TexImage2D(int32_t)
 32195: {
 86627:     if (!IsContextStable())
 80903:         return NS_OK;
 80903: 
 37417:     return NS_ERROR_FAILURE;
 32195: }
 32195: 
 73528: GLenum WebGLContext::CheckedTexImage2D(GLenum target,
 73528:                                        GLint level,
 73528:                                        GLenum internalFormat,
 73528:                                        GLsizei width,
 73528:                                        GLsizei height,
 73528:                                        GLint border,
 73528:                                        GLenum format,
 73528:                                        GLenum type,
 73528:                                        const GLvoid *data)
 73528: {
 73528:     WebGLTexture *tex = activeBoundTextureForTarget(target);
 73528:     NS_ABORT_IF_FALSE(tex != nsnull, "no texture bound");
 78609: 
 78609:     bool sizeMayChange = true;
 78609:     size_t face = WebGLTexture::FaceForTarget(target);
 78609:     
 78609:     if (tex->HasImageInfoAt(level, face)) {
 78609:         const WebGLTexture::ImageInfo& imageInfo = tex->ImageInfoAt(level, face);
 88090:         sizeMayChange = width != imageInfo.Width() ||
 88090:                         height != imageInfo.Height() ||
 88090:                         format != imageInfo.Format() ||
 88090:                         type != imageInfo.Type();
 78609:     }
 78609:     
 73528:     if (sizeMayChange) {
 73528:         UpdateWebGLErrorAndClearGLError();
 73528:         gl->fTexImage2D(target, level, internalFormat, width, height, border, format, type, data);
 73528:         GLenum error = LOCAL_GL_NO_ERROR;
 73528:         UpdateWebGLErrorAndClearGLError(&error);
 73528:         return error;
 73528:     } else {
 73528:         gl->fTexImage2D(target, level, internalFormat, width, height, border, format, type, data);
 73528:         return LOCAL_GL_NO_ERROR;
 73528:     }
 73528: }
 73528: 
 97698: void
 42916: WebGLContext::TexImage2D_base(WebGLenum target, WebGLint level, WebGLenum internalformat,
 55904:                               WebGLsizei width, WebGLsizei height, WebGLsizei srcStrideOrZero,
 55904:                               WebGLint border,
 42916:                               WebGLenum format, WebGLenum type,
 99228:                               void *data, uint32_t byteLength,
 70163:                               int jsArrayType, // a TypedArray format enum, or -1 if not relevant
 98002:                               WebGLTexelFormat srcFormat, bool srcPremultiplied)
 34454: {
 98021:     if (!ValidateTexImage2DTarget(target, width, height, "texImage2D")) {
 98021:         return;
 34454:     }
 37417: 
 77722:     switch (format) {
 37417:         case LOCAL_GL_RGB:
 37417:         case LOCAL_GL_RGBA:
 37417:         case LOCAL_GL_ALPHA:
 37417:         case LOCAL_GL_LUMINANCE:
 37417:         case LOCAL_GL_LUMINANCE_ALPHA:
 37417:             break;
 37417:         default:
 51418:             return ErrorInvalidEnumInfo("texImage2D: internal format", internalformat);
 37417:     }
 37417: 
 51418:     if (format != internalformat)
 51418:         return ErrorInvalidOperation("texImage2D: format does not match internalformat");
 51418: 
 98021:     if (!ValidateLevelWidthHeightForTarget(target, level, width, height, "texImage2D")) {
 98021:         return;
 98021:     }
 51418: 
 51418:     if (level >= 1) {
 51422:         if (!(is_pot_assuming_nonnegative(width) &&
 51422:               is_pot_assuming_nonnegative(height)))
 51418:             return ErrorInvalidValue("texImage2D: with level > 0, width and height must be powers of two");
 51418:     }
 37417: 
 37417:     if (border != 0)
 99232:         return ErrorInvalidValue("texImage2D: border must be 0");
 37417: 
 99228:     uint32_t dstTexelSize = 0;
 98002:     if (!ValidateTexFormatAndType(format, type, jsArrayType, &dstTexelSize, "texImage2D"))
 98002:         return;
 98002: 
 98002:     WebGLTexelFormat dstFormat = GetWebGLTexelFormat(format, type);
 98002:     WebGLTexelFormat actualSrcFormat = srcFormat == WebGLTexelConversions::Auto ? dstFormat : srcFormat;
 98002: 
 99228:     uint32_t srcTexelSize = WebGLTexelConversions::TexelBytesForFormat(actualSrcFormat);
 37417: 
 77722:     CheckedUint32 checked_neededByteLength = 
 98002:         GetImageSize(height, width, srcTexelSize, mPixelStoreUnpackAlignment);
 98002: 
 98002:     CheckedUint32 checked_plainRowSize = CheckedUint32(width) * srcTexelSize;
 55904: 
 77722:     CheckedUint32 checked_alignedRowSize =
 77722:         RoundedToNextMultipleOf(checked_plainRowSize.value(), mPixelStoreUnpackAlignment);
 55904: 
 98543:     if (!checked_neededByteLength.isValid())
 47204:         return ErrorInvalidOperation("texImage2D: integer overflow computing the needed buffer size");
 47204: 
 99228:     uint32_t bytesNeeded = checked_neededByteLength.value();
 37417: 
 37417:     if (byteLength && byteLength < bytesNeeded)
 99232:         return ErrorInvalidOperation("texImage2D: not enough data for operation (need %d, have %d)",
 42477:                                  bytesNeeded, byteLength);
 37417: 
 51418:     WebGLTexture *tex = activeBoundTextureForTarget(target);
 51418: 
 51418:     if (!tex)
 51418:         return ErrorInvalidOperation("texImage2D: no texture is bound to this target");
 51418: 
 37417:     MakeContextCurrent();
 37417: 
 70163:     // Handle ES2 and GL differences in floating point internal formats.  Note that
 70163:     // format == internalformat, as checked above and as required by ES.
 70163:     internalformat = InternalFormatForFormatAndType(format, type, gl->IsGLES2());
 70163: 
 73528:     GLenum error = LOCAL_GL_NO_ERROR;
 73528: 
 37417:     if (byteLength) {
 55906:         size_t srcStride = srcStrideOrZero ? srcStrideOrZero : checked_alignedRowSize.value();
 55906: 
 98002:         size_t dstPlainRowSize = dstTexelSize * width;
 55906:         size_t unpackAlignment = mPixelStoreUnpackAlignment;
 55906:         size_t dstStride = ((dstPlainRowSize + unpackAlignment-1) / unpackAlignment) * unpackAlignment;
 55906: 
 55906:         if (actualSrcFormat == dstFormat &&
 55906:             srcPremultiplied == mPixelStorePremultiplyAlpha &&
 55906:             srcStride == dstStride &&
 55906:             !mPixelStoreFlipY)
 55906:         {
 55906:             // no conversion, no flipping, so we avoid copying anything and just pass the source pointer
 73528:             error = CheckedTexImage2D(target, level, internalformat,
 73528:                                       width, height, border, format, type, data);
 55906:         }
 55906:         else
 55906:         {
 98002:             size_t convertedDataSize = height * dstStride;
 99228:             nsAutoArrayPtr<uint8_t> convertedData(new uint8_t[convertedDataSize]);
 55906:             ConvertImage(width, height, srcStride, dstStride,
 99228:                         static_cast<uint8_t*>(data), convertedData,
 55904:                         actualSrcFormat, srcPremultiplied,
 98002:                         dstFormat, mPixelStorePremultiplyAlpha, dstTexelSize);
 73528:             error = CheckedTexImage2D(target, level, internalformat,
 73528:                                       width, height, border, format, type, convertedData);
 55906:         }
 37417:     } else {
 42476:         // We need some zero pages, because GL doesn't guarantee the
 42476:         // contents of a texture allocated with NULL data.
 42476:         // Hopefully calloc will just mmap zero pages here.
 42476:         void *tempZeroData = calloc(1, bytesNeeded);
 42476:         if (!tempZeroData)
 63070:             return ErrorOutOfMemory("texImage2D: could not allocate %d bytes (for zero fill)", bytesNeeded);
 42476: 
 73528:         error = CheckedTexImage2D(target, level, internalformat,
 73528:                                   width, height, border, format, type, tempZeroData);
 42476: 
 42476:         free(tempZeroData);
 37417:     }
 37417:     
 73528:     if (error) {
 99231:         GenerateWarning("texImage2D generated error %s", ErrorName(error));
 97698:         return;
 73528:     }
 73528: 
 73528:     tex->SetImageInfo(target, level, width, height, format, type);
 37417: }
 37417: 
 37417: NS_IMETHODIMP
 42916: WebGLContext::TexImage2D_array(WebGLenum target, WebGLint level, WebGLenum internalformat,
 42916:                                WebGLsizei width, WebGLsizei height, WebGLint border,
 42916:                                WebGLenum format, WebGLenum type,
 95834:                                JSObject *pixels, JSContext *cx)
 37417: {
 97819:     ErrorResult rv;
 97698:     if (!pixels) {
 97698:         TexImage2D(cx, target, level, internalformat, width, height, border,
 97698:                    format, type, nsnull, rv);
 97698:     } else {
 97698:         ArrayBufferView view(cx, pixels);
 97698:         TexImage2D(cx, target, level, internalformat, width, height, border,
 97698:                    format, type, &view, rv);
 97698:     }
 97819:     return rv.ErrorCode();
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::TexImage2D(JSContext* cx, WebGLenum target, WebGLint level,
 97698:                          WebGLenum internalformat, WebGLsizei width,
 97698:                          WebGLsizei height, WebGLint border, WebGLenum format,
 97819:                          WebGLenum type, ArrayBufferView *pixels, ErrorResult& rv)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return;
 95834: 
 55904:     return TexImage2D_base(target, level, internalformat, width, height, 0, border, format, type,
 97698:                            pixels ? pixels->mData : 0,
 97698:                            pixels ? pixels->mLength : 0,
 97698:                            pixels ? (int)JS_GetTypedArrayType(pixels->mObj, cx) : -1,
 98002:                            WebGLTexelConversions::Auto, false);
 55904: }
 55904: 
 55904: NS_IMETHODIMP
 55904: WebGLContext::TexImage2D_imageData(WebGLenum target, WebGLint level, WebGLenum internalformat,
 55904:                                    WebGLsizei width, WebGLsizei height, WebGLint border,
 55904:                                    WebGLenum format, WebGLenum type,
 95834:                                    JSObject *pixels, JSContext *cx)
 55904: {
 86627:     if (!IsContextStable())
 80903:         return NS_OK;
 80903: 
 95834:     NS_ABORT_IF_FALSE(JS_IsTypedArrayObject(pixels, cx), "bad pixels object");
 95834: 
 97698:     TexImage2D_base(target, level, internalformat, width, height, 4*width, border, format, type,
 95834:                     pixels ? JS_GetArrayBufferViewData(pixels, cx) : 0,
 95834:                     pixels ? JS_GetArrayBufferViewByteLength(pixels, cx) : 0,
 70163:                     -1,
 98002:                     WebGLTexelConversions::RGBA8, false);
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::TexImage2D(JSContext* cx, WebGLenum target, WebGLint level,
 97698:                          WebGLenum internalformat, WebGLenum format,
 97819:                          WebGLenum type, ImageData* pixels, ErrorResult& rv)
 97698: {
 97698:     if (!IsContextStable())
 97698:         return;
 97698: 
 97698:     if (!pixels) {
 97698:         // Spec says to generate an INVALID_VALUE error
 97698:         return ErrorInvalidValue("texImage2D: null ImageData");
 97698:     }
 97698:     
 97698:     Uint8ClampedArray arr(cx, pixels->GetDataObject());
 97698:     return TexImage2D_base(target, level, internalformat, pixels->GetWidth(),
 97698:                            pixels->GetHeight(), 4*pixels->GetWidth(), 0,
 97698:                            format, type, arr.mData, arr.mLength, -1,
 98002:                            WebGLTexelConversions::RGBA8, false);
 97698: }
 97698: 
 37417: 
 37417: NS_IMETHODIMP
 43638: WebGLContext::TexImage2D_dom(WebGLenum target, WebGLint level, WebGLenum internalformat,
 91975:                              WebGLenum format, GLenum type, Element* elt)
 37417: {
 97819:     ErrorResult rv;
 97698:     TexImage2D(NULL, target, level, internalformat, format, type, elt, rv);
 97819:     return rv.ErrorCode();
 97698: }
 97698: 
 43638: NS_IMETHODIMP
 99228: WebGLContext::TexSubImage2D(int32_t)
 32195: {
 86627:     if (!IsContextStable())
 80903:         return NS_OK;
 80903: 
 37417:     return NS_ERROR_FAILURE;
 32195: }
 32195: 
 97698: void
 42916: WebGLContext::TexSubImage2D_base(WebGLenum target, WebGLint level,
 42916:                                  WebGLint xoffset, WebGLint yoffset,
 55904:                                  WebGLsizei width, WebGLsizei height, WebGLsizei srcStrideOrZero,
 42916:                                  WebGLenum format, WebGLenum type,
 99228:                                  void *pixels, uint32_t byteLength,
 70163:                                  int jsArrayType,
 98002:                                  WebGLTexelFormat srcFormat, bool srcPremultiplied)
 37417: {
 37417:     switch (target) {
 32195:         case LOCAL_GL_TEXTURE_2D:
 32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X:
 32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
 32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
 32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
 32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
 32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
 32195:             break;
 32195:         default:
 47813:             return ErrorInvalidEnumInfo("texSubImage2D: target", target);
 32195:     }
 32195: 
 98021:     if (!ValidateLevelWidthHeightForTarget(target, level, width, height, "texSubImage2D")) {
 98021:         return;
 98021:     }
 51418: 
 51418:     if (level >= 1) {
 51422:         if (!(is_pot_assuming_nonnegative(width) &&
 51422:               is_pot_assuming_nonnegative(height)))
 51418:             return ErrorInvalidValue("texSubImage2D: with level > 0, width and height must be powers of two");
 51418:     }
 42477: 
 99228:     uint32_t dstTexelSize = 0;
 98002:     if (!ValidateTexFormatAndType(format, type, jsArrayType, &dstTexelSize, "texSubImage2D"))
 98002:         return;
 98002: 
 98002:     WebGLTexelFormat dstFormat = GetWebGLTexelFormat(format, type);
 98002:     WebGLTexelFormat actualSrcFormat = srcFormat == WebGLTexelConversions::Auto ? dstFormat : srcFormat;
 98002: 
 99228:     uint32_t srcTexelSize = WebGLTexelConversions::TexelBytesForFormat(actualSrcFormat);
 46443: 
 42477:     if (width == 0 || height == 0)
 97698:         return; // ES 2.0 says it has no effect, we better return right now
 37417: 
 77722:     CheckedUint32 checked_neededByteLength = 
 98002:         GetImageSize(height, width, srcTexelSize, mPixelStoreUnpackAlignment);
 98002: 
 98002:     CheckedUint32 checked_plainRowSize = CheckedUint32(width) * srcTexelSize;
 55904: 
 77722:     CheckedUint32 checked_alignedRowSize = 
 77722:         RoundedToNextMultipleOf(checked_plainRowSize.value(), mPixelStoreUnpackAlignment);
 55904: 
 98543:     if (!checked_neededByteLength.isValid())
 47204:         return ErrorInvalidOperation("texSubImage2D: integer overflow computing the needed buffer size");
 47204: 
 99228:     uint32_t bytesNeeded = checked_neededByteLength.value();
 47204:  
 37417:     if (byteLength < bytesNeeded)
 57638:         return ErrorInvalidOperation("texSubImage2D: not enough data for operation (need %d, have %d)", bytesNeeded, byteLength);
 51418: 
 51418:     WebGLTexture *tex = activeBoundTextureForTarget(target);
 51418: 
 51418:     if (!tex)
 51418:         return ErrorInvalidOperation("texSubImage2D: no texture is bound to this target");
 51418: 
 73529:     size_t face = WebGLTexture::FaceForTarget(target);
 78609:     
 78609:     if (!tex->HasImageInfoAt(level, face))
 78609:         return ErrorInvalidOperation("texSubImage2D: no texture image previously defined for this level and face");
 78609:     
 73529:     const WebGLTexture::ImageInfo &imageInfo = tex->ImageInfoAt(level, face);
 88090:     if (!CanvasUtils::CheckSaneSubrectSize(xoffset, yoffset, width, height, imageInfo.Width(), imageInfo.Height()))
 51418:         return ErrorInvalidValue("texSubImage2D: subtexture rectangle out of bounds");
 35422:     
 74443:     // Require the format and type in texSubImage2D to match that of the existing texture as created by texImage2D
 88090:     if (imageInfo.Format() != format || imageInfo.Type() != type)
 74443:         return ErrorInvalidOperation("texSubImage2D: format or type doesn't match the existing texture");
 74443: 
 32195:     MakeContextCurrent();
 37417: 
 55906:     size_t srcStride = srcStrideOrZero ? srcStrideOrZero : checked_alignedRowSize.value();
 55906: 
 98002:     size_t dstPlainRowSize = dstTexelSize * width;
 77722:     // There are checks above to ensure that this won't overflow.
 77722:     size_t dstStride = RoundedToNextMultipleOf(dstPlainRowSize, mPixelStoreUnpackAlignment).value();
 55906: 
 55906:     if (actualSrcFormat == dstFormat &&
 55906:         srcPremultiplied == mPixelStorePremultiplyAlpha &&
 55906:         srcStride == dstStride &&
 55906:         !mPixelStoreFlipY)
 55906:     {
 55906:         // no conversion, no flipping, so we avoid copying anything and just pass the source pointer
 55906:         gl->fTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
 55906:     }
 55906:     else
 55906:     {
 98002:         size_t convertedDataSize = height * dstStride;
 99228:         nsAutoArrayPtr<uint8_t> convertedData(new uint8_t[convertedDataSize]);
 55906:         ConvertImage(width, height, srcStride, dstStride,
 99228:                     static_cast<const uint8_t*>(pixels), convertedData,
 55904:                     actualSrcFormat, srcPremultiplied,
 98002:                     dstFormat, mPixelStorePremultiplyAlpha, dstTexelSize);
 55904: 
 55904:         gl->fTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, convertedData);
 55906:     }
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 42916: WebGLContext::TexSubImage2D_array(WebGLenum target, WebGLint level,
 42916:                                   WebGLint xoffset, WebGLint yoffset,
 42916:                                   WebGLsizei width, WebGLsizei height,
 42916:                                   WebGLenum format, WebGLenum type,
 95834:                                   JSObject *pixels, JSContext *cx)
 32195: {
 97819:     ErrorResult rv;
 97698:     if (!pixels) {
 97698:         TexSubImage2D(cx, target, level, xoffset, yoffset, width, height,
 97698:                       format, type, nsnull, rv);
 97698:     } else {
 97698:         ArrayBufferView view(cx, pixels);
 97698:         TexSubImage2D(cx, target, level, xoffset, yoffset, width, height,
 97698:                       format, type, &view, rv);
 97698:     }
 97819:     return rv.ErrorCode();
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::TexSubImage2D(JSContext* cx, WebGLenum target, WebGLint level,
 97698:                             WebGLint xoffset, WebGLint yoffset,
 97698:                             WebGLsizei width, WebGLsizei height,
 97698:                             WebGLenum format, WebGLenum type,
 97698:                             ArrayBufferView* pixels,
 97819:                             ErrorResult& rv)
 97698: {
 86627:     if (!IsContextStable())
 97698:         return;
 80903: 
 37417:     if (!pixels)
 99232:         return ErrorInvalidValue("texSubImage2D: pixels must not be null!");
 37417: 
 37417:     return TexSubImage2D_base(target, level, xoffset, yoffset,
 55904:                               width, height, 0, format, type,
 97698:                               pixels->mData, pixels->mLength,
 97698:                               JS_GetTypedArrayType(pixels->mObj, cx),
 98002:                               WebGLTexelConversions::Auto, false);
 55904: }
 55904: 
 55904: NS_IMETHODIMP
 55904: WebGLContext::TexSubImage2D_imageData(WebGLenum target, WebGLint level,
 55904:                                       WebGLint xoffset, WebGLint yoffset,
 55904:                                       WebGLsizei width, WebGLsizei height,
 55904:                                       WebGLenum format, WebGLenum type,
 95834:                                       JSObject *pixels, JSContext *cx)
 55904: {
 86627:     if (!IsContextStable())
 80903:         return NS_OK;
 80903: 
 97698:     if (!pixels) {
 99232:         ErrorInvalidValue("texSubImage2D: pixels must not be null!");
 97698:         return NS_OK;
 97698:     }
 97698: 
 97698:     NS_ABORT_IF_FALSE(JS_IsTypedArrayObject(pixels, cx), "bad pixels object");
 97698: 
 97698:     TexSubImage2D_base(target, level, xoffset, yoffset,
 97698:                        width, height, 4*width, format, type,
 97698:                        JS_GetArrayBufferViewData(pixels, cx), JS_GetArrayBufferViewByteLength(pixels, cx),
 97698:                        -1,
 98002:                        WebGLTexelConversions::RGBA8, false);
 97698:     return NS_OK;
 97698: }
 97698: 
 97698: void
 97698: WebGLContext::TexSubImage2D(JSContext* cx, WebGLenum target, WebGLint level,
 97698:                             WebGLint xoffset, WebGLint yoffset,
 97698:                             WebGLenum format, WebGLenum type, ImageData* pixels,
 97819:                             ErrorResult& rv)
 97698: {
 97698:     if (!IsContextStable())
 97698:         return;
 97698: 
 55904:     if (!pixels)
 99232:         return ErrorInvalidValue("texSubImage2D: pixels must not be null!");
 55904: 
 97698:     Uint8ClampedArray arr(cx, pixels->GetDataObject());
 55904:     return TexSubImage2D_base(target, level, xoffset, yoffset,
 97698:                               pixels->GetWidth(), pixels->GetHeight(),
 97698:                               4*pixels->GetWidth(), format, type,
 97698:                               arr.mData, arr.mLength,
 70163:                               -1,
 98002:                               WebGLTexelConversions::RGBA8, false);
 32195: }
 37417: 
 37417: NS_IMETHODIMP
 42916: WebGLContext::TexSubImage2D_dom(WebGLenum target, WebGLint level,
 42916:                                 WebGLint xoffset, WebGLint yoffset,
 43638:                                 WebGLenum format, WebGLenum type,
 91975:                                 Element *elt)
 37417: {
 97819:     ErrorResult rv;
 97698:     TexSubImage2D(NULL, target, level, xoffset, yoffset, format, type, elt, rv);
 97819:     return rv.ErrorCode();
 97698: }
 97698: 
 79445: bool
 80903: WebGLContext::LoseContext()
 80903: {
 86627:     if (!IsContextStable())
 80903:         return false;
 86626: 
 80903:     ForceLoseContext();
 80903: 
 80903:     return true;
 80903: }
 80903: 
 80903: bool
 80903: WebGLContext::RestoreContext()
 80903: {
 86626:     if (IsContextStable() || !mAllowRestore) {
 80903:         return false;
 80903:     }
 80903: 
 80903:     ForceRestoreContext();
 80903: 
 80903:     return true;
 80903: }
 80903: 
 80903: bool
 42916: BaseTypeAndSizeFromUniformType(WebGLenum uType, WebGLenum *baseType, WebGLint *unitSize)
 32195: {
 32195:     switch (uType) {
 32195:         case LOCAL_GL_INT:
 32195:         case LOCAL_GL_INT_VEC2:
 32195:         case LOCAL_GL_INT_VEC3:
 32195:         case LOCAL_GL_INT_VEC4:
 32195:         case LOCAL_GL_SAMPLER_2D:
 32195:         case LOCAL_GL_SAMPLER_CUBE:
 32195:             *baseType = LOCAL_GL_INT;
 32195:             break;
 32195:         case LOCAL_GL_FLOAT:
 32195:         case LOCAL_GL_FLOAT_VEC2:
 32195:         case LOCAL_GL_FLOAT_VEC3:
 32195:         case LOCAL_GL_FLOAT_VEC4:
 32195:         case LOCAL_GL_FLOAT_MAT2:
 32195:         case LOCAL_GL_FLOAT_MAT3:
 32195:         case LOCAL_GL_FLOAT_MAT4:
 32195:             *baseType = LOCAL_GL_FLOAT;
 32195:             break;
 32195:         case LOCAL_GL_BOOL:
 32195:         case LOCAL_GL_BOOL_VEC2:
 32195:         case LOCAL_GL_BOOL_VEC3:
 32195:         case LOCAL_GL_BOOL_VEC4:
 43852:             *baseType = LOCAL_GL_BOOL; // pretend these are int
 32195:             break;
 32195:         default:
 80486:             return false;
 32195:     }
 32195: 
 32195:     switch (uType) {
 32195:         case LOCAL_GL_INT:
 32195:         case LOCAL_GL_FLOAT:
 32195:         case LOCAL_GL_BOOL:
 32195:         case LOCAL_GL_SAMPLER_2D:
 32195:         case LOCAL_GL_SAMPLER_CUBE:
 32195:             *unitSize = 1;
 32195:             break;
 32195:         case LOCAL_GL_INT_VEC2:
 32195:         case LOCAL_GL_FLOAT_VEC2:
 32195:         case LOCAL_GL_BOOL_VEC2:
 32195:             *unitSize = 2;
 32195:             break;
 32195:         case LOCAL_GL_INT_VEC3:
 32195:         case LOCAL_GL_FLOAT_VEC3:
 32195:         case LOCAL_GL_BOOL_VEC3:
 32195:             *unitSize = 3;
 32195:             break;
 32195:         case LOCAL_GL_INT_VEC4:
 32195:         case LOCAL_GL_FLOAT_VEC4:
 32195:         case LOCAL_GL_BOOL_VEC4:
 32195:             *unitSize = 4;
 32195:             break;
 32195:         case LOCAL_GL_FLOAT_MAT2:
 32195:             *unitSize = 4;
 32195:             break;
 32195:         case LOCAL_GL_FLOAT_MAT3:
 32195:             *unitSize = 9;
 32195:             break;
 32195:         case LOCAL_GL_FLOAT_MAT4:
 32195:             *unitSize = 16;
 32195:             break;
 32195:         default:
 80486:             return false;
 80486:     }
 80486: 
 80486:     return true;
 32195: }
 55904: 
 55904: 
 98002: WebGLTexelFormat mozilla::GetWebGLTexelFormat(GLenum format, GLenum type)
 55904: {
 70163:     if (type == LOCAL_GL_UNSIGNED_BYTE) {
 55904:         switch (format) {
 55904:             case LOCAL_GL_RGBA:
 98002:                 return WebGLTexelConversions::RGBA8;
 55904:             case LOCAL_GL_RGB:
 98002:                 return WebGLTexelConversions::RGB8;
 55904:             case LOCAL_GL_ALPHA:
 98002:                 return WebGLTexelConversions::A8;
 55904:             case LOCAL_GL_LUMINANCE:
 98002:                 return WebGLTexelConversions::R8;
 55904:             case LOCAL_GL_LUMINANCE_ALPHA:
 98002:                 return WebGLTexelConversions::RA8;
 55904:             default:
 98002:                 NS_ABORT_IF_FALSE(false, "Coding mistake?! Should never reach this point.");
 98002:                 return WebGLTexelConversions::BadFormat;
 55904:         }
 70163:     } else if (type == LOCAL_GL_FLOAT) {
 70163:         // OES_texture_float
 70163:         switch (format) {
 70163:             case LOCAL_GL_RGBA:
 98002:                 return WebGLTexelConversions::RGBA32F;
 70163:             case LOCAL_GL_RGB:
 98002:                 return WebGLTexelConversions::RGB32F;
 70163:             case LOCAL_GL_ALPHA:
 98002:                 return WebGLTexelConversions::A32F;
 70163:             case LOCAL_GL_LUMINANCE:
 98002:                 return WebGLTexelConversions::R32F;
 70163:             case LOCAL_GL_LUMINANCE_ALPHA:
 98002:                 return WebGLTexelConversions::RA32F;
 70163:             default:
 98002:                 NS_ABORT_IF_FALSE(false, "Coding mistake?! Should never reach this point.");
 98002:                 return WebGLTexelConversions::BadFormat;
 70163:         }
 55904:     } else {
 55904:         switch (type) {
 55904:             case LOCAL_GL_UNSIGNED_SHORT_4_4_4_4:
 98002:                 return WebGLTexelConversions::RGBA4444;
 55904:             case LOCAL_GL_UNSIGNED_SHORT_5_5_5_1:
 98002:                 return WebGLTexelConversions::RGBA5551;
 55904:             case LOCAL_GL_UNSIGNED_SHORT_5_6_5:
 98002:                 return WebGLTexelConversions::RGB565;
 55904:             default:
 98002:                 NS_ABORT_IF_FALSE(false, "Coding mistake?! Should never reach this point.");
 98002:                 return WebGLTexelConversions::BadFormat;
 55904:         }
 55904:     }
 55904: }
 70163: 
 70163: WebGLenum
 70163: InternalFormatForFormatAndType(WebGLenum format, WebGLenum type, bool isGLES2)
 70163: {
 70163:     // ES2 requires that format == internalformat; floating-point is
 70163:     // indicated purely by the type that's loaded.  For desktop GL, we
 70163:     // have to specify a floating point internal format.
 70163:     if (isGLES2)
 70163:         return format;
 70163: 
 70163:     switch (type) {
 70163:     case LOCAL_GL_UNSIGNED_BYTE:
 70163:     case LOCAL_GL_UNSIGNED_SHORT_4_4_4_4:
 70163:     case LOCAL_GL_UNSIGNED_SHORT_5_5_5_1:
 70163:     case LOCAL_GL_UNSIGNED_SHORT_5_6_5:
 70163:         return format;
 70163: 
 70163:     case LOCAL_GL_FLOAT:
 70163:         switch (format) {
 70163:         case LOCAL_GL_RGBA:
 70163:             return LOCAL_GL_RGBA32F_ARB;
 70163:         case LOCAL_GL_RGB:
 70163:             return LOCAL_GL_RGB32F_ARB;
 70163:         case LOCAL_GL_ALPHA:
 70163:             return LOCAL_GL_ALPHA32F_ARB;
 70163:         case LOCAL_GL_LUMINANCE:
 70163:             return LOCAL_GL_LUMINANCE32F_ARB;
 70163:         case LOCAL_GL_LUMINANCE_ALPHA:
 70163:             return LOCAL_GL_LUMINANCE_ALPHA32F_ARB;
 70163:         }
 70163:         break;
 70163: 
 70163:     default:
 70163:         break;
 70163:     }
 70163: 
 80486:     NS_ASSERTION(false, "Coding mistake -- bad format/type passed?");
 70163:     return 0;
 70163: }
 70163: 
