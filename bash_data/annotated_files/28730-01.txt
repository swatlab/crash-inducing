    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 2106: /* vim: set ts=2 sw=2 et tw=78: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * The Mozilla Foundation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Johnny Stenback <jst@mozilla.org> (original author)
    1:  *   Brendan Eich <brendan@mozilla.org>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "xpcprivate.h"
    1: #include "XPCNativeWrapper.h"
12582: #include "XPCWrapper.h"
    1: #include "jsdbgapi.h"
    1: 
18907: static JSBool
    1: XPC_NW_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
    1: 
18907: static JSBool
    1: XPC_NW_DelProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
    1: 
18907: static JSBool
    1: XPC_NW_GetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
    1: 
18907: static JSBool
    1: XPC_NW_SetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
    1: 
18907: static JSBool
    1: XPC_NW_Enumerate(JSContext *cx, JSObject *obj);
    1: 
18907: static JSBool
    1: XPC_NW_NewResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
    1:                   JSObject **objp);
    1: 
18907: static JSBool
    1: XPC_NW_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp);
    1: 
18907: static void
    1: XPC_NW_Finalize(JSContext *cx, JSObject *obj);
    1: 
18907: static JSBool
    1: XPC_NW_CheckAccess(JSContext *cx, JSObject *obj, jsval id,
    1:                    JSAccessMode mode, jsval *vp);
    1: 
18907: static JSBool
    1: XPC_NW_Call(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
    1:             jsval *rval);
    1: 
18907: static JSBool
    1: XPC_NW_Construct(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
    1:                  jsval *rval);
    1: 
18907: static JSBool
    1: XPC_NW_HasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp);
    1: 
18907: static void
 1025: XPC_NW_Trace(JSTracer *trc, JSObject *obj);
    1: 
18907: static JSBool
    1: XPC_NW_Equality(JSContext *cx, JSObject *obj, jsval v, JSBool *bp);
    1: 
18907: static JSBool
    1: XPC_NW_FunctionWrapper(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
    1:                        jsval *rval);
    1: 
    1: // JS class for XPCNativeWrapper (and this doubles as the constructor
    1: // for XPCNativeWrapper for the moment too...)
    1: 
    1: JSExtendedClass XPCNativeWrapper::sXPC_NW_JSClass = {
    1:   // JSClass (JSExtendedClass.base) initialization
    1:   { "XPCNativeWrapper",
    1:     JSCLASS_HAS_PRIVATE | JSCLASS_PRIVATE_IS_NSISUPPORTS |
    1:     // Our one reserved slot holds a jsint of flag bits
    1:     JSCLASS_NEW_RESOLVE | JSCLASS_HAS_RESERVED_SLOTS(1) |
 1025:     JSCLASS_MARK_IS_TRACE | JSCLASS_IS_EXTENDED,
    1:     XPC_NW_AddProperty, XPC_NW_DelProperty,
    1:     XPC_NW_GetProperty, XPC_NW_SetProperty,
    1:     XPC_NW_Enumerate,   (JSResolveOp)XPC_NW_NewResolve,
    1:     XPC_NW_Convert,     XPC_NW_Finalize,
    1:     nsnull,             XPC_NW_CheckAccess,
    1:     XPC_NW_Call,        XPC_NW_Construct,
    1:     nsnull,             XPC_NW_HasInstance,
 1025:     JS_CLASS_TRACE(XPC_NW_Trace), nsnull
    1:   },
    1:   // JSExtendedClass initialization
    1:   XPC_NW_Equality
    1: };
    1: 
    1: // If one of our class hooks is ever called from a non-system script, bypass
    1: // the hook by calling the same hook on our wrapped native, with obj reset to
    1: // the wrapped native's flat JSObject, so the hook and args macro parameters
    1: // can be simply:
    1: //
    1: //      convert, (cx, obj, type, vp)
    1: //
    1: // in the call from XPC_NW_Convert, for example.
    1: 
10858: #define XPC_NW_CALL_HOOK(obj, hook, args)                                 \
10858:   return STOBJ_GET_CLASS(obj)->hook args;
    1: 
10858: #define XPC_NW_CAST_HOOK(obj, type, hook, args)                           \
10858:   return ((type) STOBJ_GET_CLASS(obj)->hook) args;
    1: 
    1: static JSBool
    1: ShouldBypassNativeWrapper(JSContext *cx, JSObject *obj)
    1: {
10858:   NS_ASSERTION(XPCNativeWrapper::IsNativeWrapper(obj),
    1:                "Unexpected object");
    1:   jsval flags;
    1: 
    1:   ::JS_GetReservedSlot(cx, obj, 0, &flags);
    1:   if (HAS_FLAGS(flags, FLAG_EXPLICIT))
    1:     return JS_FALSE;
    1: 
    1:   // Check what the script calling us looks like
22652:   JSStackFrame *fp = JS_GetScriptedCaller(cx, NULL);
22652:   JSScript *script = fp ? fp->script : NULL;
    1: 
    1:   // If there's no script, bypass for now because that's what the old code did.
    1:   // XXX FIXME: bug 341477 covers figuring out what we _should_ do.
    1:   return !script || !(::JS_GetScriptFilenameFlags(script) & JSFILENAME_SYSTEM);
    1: }
    1: 
    1: #define XPC_NW_BYPASS_BASE(cx, obj, code)                                     \
    1:   JS_BEGIN_MACRO                                                              \
    1:     if (ShouldBypassNativeWrapper(cx, obj)) {                                 \
24010:       /* Use SafeGetWrappedNative since obj can't be an explicit native       \
24010:          wrapper. */                                                          \
24010:       XPCWrappedNative *wn_ = XPCNativeWrapper::SafeGetWrappedNative(obj);    \
    1:       if (!wn_) {                                                             \
    1:         return JS_TRUE;                                                       \
    1:       }                                                                       \
    1:       obj = wn_->GetFlatJSObject();                                           \
    1:       code                                                                    \
    1:     }                                                                         \
    1:   JS_END_MACRO
    1: 
    1: #define XPC_NW_BYPASS(cx, obj, hook, args)                                    \
10858:   XPC_NW_BYPASS_BASE(cx, obj, XPC_NW_CALL_HOOK(obj, hook, args))
    1: 
    1: #define XPC_NW_BYPASS_CAST(cx, obj, type, hook, args)                         \
10858:   XPC_NW_BYPASS_BASE(cx, obj, XPC_NW_CAST_HOOK(obj, type, hook, args))
    1: 
    1: #define XPC_NW_BYPASS_TEST(cx, obj, hook, args)                               \
    1:   XPC_NW_BYPASS_BASE(cx, obj,                                                 \
10858:     JSClass *clasp_ = STOBJ_GET_CLASS(obj);                                  \
    1:     return !clasp_->hook || clasp_->hook args;                                \
    1:   )
    1: 
18907: static JSBool
    1: XPC_NW_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
    1:                 jsval *rval);
    1: 
    1: static inline
    1: JSBool
    1: ThrowException(nsresult ex, JSContext *cx)
    1: {
    1:   XPCThrower::Throw(ex, cx);
    1: 
    1:   return JS_FALSE;
    1: }
    1: 
 3162: static inline
 3162: JSBool
25743: EnsureLegalActivity(JSContext *cx, JSObject *obj,
25743:                     jsval id = JSVAL_VOID, PRUint32 accessType = 0)
 3162: {
24010:   nsIScriptSecurityManager *ssm = XPCWrapper::GetSecurityManager();
24010:   if (!ssm) {
24010:     // If there's no security manager, then we're not running in a browser
24010:     // context: allow access.
24010:     return JS_TRUE;
24010:   }
24010: 
24010:   JSStackFrame *fp;
24010:   nsIPrincipal *subjectPrincipal = ssm->GetCxSubjectPrincipalAndFrame(cx, &fp);
24010:   if (!subjectPrincipal || !fp) {
24010:     // We must allow the access if there is no code running.
24010:     return JS_TRUE;
24010:   }
24010: 
24010:   // This might be chrome code or content code with UniversalXPConnect.
24010:   void *annotation = JS_GetFrameAnnotation(cx, fp);
24010:   PRBool isPrivileged = PR_FALSE;
24010:   nsresult rv = subjectPrincipal->IsCapabilityEnabled("UniversalXPConnect",
24010:                                                       annotation,
24010:                                                       &isPrivileged);
24010:   if (NS_SUCCEEDED(rv) && isPrivileged) {
24010:     return JS_TRUE;
24010:   }
24010: 
24010:   // We're in unprivileged code, ensure that we're allowed to access the
24010:   // underlying object.
24010:   XPCWrappedNative *wn = XPCNativeWrapper::SafeGetWrappedNative(obj);
24010:   if (wn) {
24010:     nsIPrincipal *objectPrincipal = wn->GetScope()->GetPrincipal();
24010:     PRBool subsumes;
24010:     if (NS_FAILED(subjectPrincipal->Subsumes(objectPrincipal, &subsumes)) ||
24010:         !subsumes) {
25743: 
25743:       JSObject* flatObj;
25743:       if (!JSVAL_IS_VOID(id) &&
25743:           (accessType & (XPCWrapper::sSecMgrSetProp |
25743:                          XPCWrapper::sSecMgrGetProp)) &&
25743:           (flatObj = wn->GetFlatJSObject())) {
25743:         rv = ssm->CheckPropertyAccess(cx, flatObj,
25743:                                       STOBJ_GET_CLASS(flatObj)->name,
25743:                                       id, accessType);
25743:         return NS_SUCCEEDED(rv);
25743:       }
25743: 
24010:       return ThrowException(NS_ERROR_XPC_SECURITY_MANAGER_VETO, cx);
24010:     }
24010:   }
24010: 
24010:   // The underlying object is accessible, but this might be the wrong
24010:   // type of wrapper to access it through.
24010:   // TODO This should just be an assertion now.
 3162:   jsval flags;
 3162: 
 3162:   ::JS_GetReservedSlot(cx, obj, 0, &flags);
 3162:   if (HAS_FLAGS(flags, FLAG_EXPLICIT)) {
 3162:     // Can't make any assertions about the owner of this wrapper.
 3162:     return JS_TRUE;
 3162:   }
 3162: 
24010:   JSScript *script = JS_GetFrameScript(cx, fp);
24010:   uint32 fileFlags = JS_GetScriptFilenameFlags(script);
24010:   if (fileFlags == JSFILENAME_NULL || (fileFlags & JSFILENAME_SYSTEM)) {
 3162:     // We expect implicit native wrappers in system files.
 3162:     return JS_TRUE;
 3162:   }
 3162: 
 3162:   // Otherwise, we're looking at a non-system file with a handle on an
 3163:   // implicit wrapper. This is a bug! Deny access.
 3162:   return ThrowException(NS_ERROR_XPC_SECURITY_MANAGER_VETO, cx);
 3162: }
 3162: 
24010: // static
24010: JSBool
24010: XPCNativeWrapper::GetWrappedNative(JSContext *cx, JSObject *obj,
24010:                                    XPCWrappedNative **aWrappedNative)
24010: {
24010:   XPCWrappedNative *wn = static_cast<XPCWrappedNative *>(xpc_GetJSPrivate(obj));
24010:   *aWrappedNative = wn;
24010:   if (!wn) {
24010:     return JS_TRUE;
24010:   }
24010: 
24010:   nsIScriptSecurityManager *ssm = XPCWrapper::GetSecurityManager();
24010:   if (!ssm) {
24010:     return JS_TRUE;
24010:   }
24010: 
24010:   JSStackFrame *fp;
24010:   nsIPrincipal *subjectPrincipal = ssm->GetCxSubjectPrincipalAndFrame(cx, &fp);
24010:   if (!subjectPrincipal) {
24010:     return JS_TRUE;
24010:   }
24010: 
24010:   if (fp) {
24010:     void *annotation = JS_GetFrameAnnotation(cx, fp);
24010: 
24010:     PRBool isPrivileged;
24010:     nsresult rv =
24010:       subjectPrincipal->IsCapabilityEnabled("UniversalXPConnect",
24010:                                             annotation,
24010:                                             &isPrivileged);
24010:     if (NS_SUCCEEDED(rv) && isPrivileged) {
24010:       return JS_TRUE;
24010:     }
24010:   }
24010: 
24010:   XPCWrappedNativeScope *scope = wn->GetScope();
24010:   nsIPrincipal *objectPrincipal = scope->GetPrincipal();
24010: 
24010:   PRBool subsumes;
24010:   nsresult rv = subjectPrincipal->Subsumes(objectPrincipal, &subsumes);
24010:   if (NS_FAILED(rv) || !subsumes) {
24010:     return JS_FALSE;
24010:   }
24010: 
24010:   return JS_TRUE;
24010: }
24010: 
 4042: JSBool
 4042: XPC_NW_WrapFunction(JSContext* cx, JSObject* funobj, jsval *rval)
    1: {
    1:   // If funobj is already a wrapped function, just return it.
    1:   if (JS_GetFunctionNative(cx,
    1:                            JS_ValueToFunction(cx, OBJECT_TO_JSVAL(funobj))) ==
    1:       XPC_NW_FunctionWrapper) {
    1:     *rval = OBJECT_TO_JSVAL(funobj);
    1:     return JS_TRUE;
    1:   }
    1: 
 2106:   // Ensure that we've been called from JS. Native code should extract
 2106:   // the wrapped native and deal with that directly.
 2106:   // XXX Can we simply trust |cx| here?
 2106:   JSStackFrame *iterator = nsnull;
 2106:   if (!::JS_FrameIterator(cx, &iterator)) {
 2106:     ::JS_ReportError(cx, "XPCNativeWrappers must be used from script");
 2106:     return JS_FALSE;
 2106:   }
 2106:   
    1:   // Create a new function that'll call our given function.  This new
    1:   // function's parent will be the original function and that's how we
    1:   // get the right thing to call when this function is called.
 2106:   // Note that we pass nsnull as the nominal parent so that we'll inherit
 2106:   // our caller's Function.prototype.
    1:   JSFunction *funWrapper =
 2106:     ::JS_NewFunction(cx, XPC_NW_FunctionWrapper, 0, 0, nsnull,
    1:                      "XPCNativeWrapper function wrapper");
    1:   if (!funWrapper) {
    1:     return JS_FALSE;
    1:   }
    1: 
 2106:   JSObject* funWrapperObj = ::JS_GetFunctionObject(funWrapper);
 2106:   ::JS_SetParent(cx, funWrapperObj, funobj);
 2106:   *rval = OBJECT_TO_JSVAL(funWrapperObj);
25743: 
25743:   JS_SetReservedSlot(cx, funWrapperObj, XPCWrapper::eAllAccessSlot, JSVAL_FALSE);
25743: 
    1:   return JS_TRUE;
    1: }
    1: 
18907: static JSBool
    1: XPC_NW_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
 9833:   jsid idAsId;
26167:   JSPropertyDescriptor desc;
 9833: 
26167:   if (!JS_ValueToId(cx, id, &idAsId) ||
26167:       !JS_GetPropertyDescriptorById(cx, obj, idAsId, JSRESOLVE_QUALIFIED,
26167:                                     &desc)) {
 9833:     return JS_FALSE;
 9833:   }
 9833: 
 9833:   // Do not allow scripted getters or setters on XPCNativeWrappers.
26167:   if (desc.attrs & (JSPROP_GETTER | JSPROP_SETTER)) {
 9833:     return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
 9833:   }
 9833: 
26167:   jsval flags = JSVAL_VOID;
26167:   JS_GetReservedSlot(cx, obj, 0, &flags);
25743:   // The purpose of XPC_NW_AddProperty is to wrap any object set on the
25743:   // XPCNativeWrapper by the wrapped object's scriptable helper, so bail
25743:   // here if the scriptable helper is not currently adding a property.
25743:   // See comment above #define FLAG_RESOLVING in XPCWrapper.h.
    1:   if (!HAS_FLAGS(flags, FLAG_RESOLVING)) {
    1:     return JS_TRUE;
    1:   }
    1: 
    1:   // Note: no need to protect *vp from GC here, since it's already in the slot
    1:   // on |obj|.
25743:   return EnsureLegalActivity(cx, obj, id, XPCWrapper::sSecMgrSetProp) &&
 4042:          XPC_NW_RewrapIfDeepWrapper(cx, obj, *vp, vp);
    1: }
    1: 
18907: static JSBool
    1: XPC_NW_DelProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
 3162:   if (!EnsureLegalActivity(cx, obj)) {
 3162:     return JS_FALSE;
 3162:   }
 3162: 
    1:   XPC_NW_BYPASS_BASE(cx, obj,
    1:     // We're being notified of a delete operation on id in this
    1:     // XPCNativeWrapper, so forward to the right high-level hook,
    1:     // OBJ_DELETE_PROPERTY, on the XPCWrappedNative's object.
    1:     {
    1:       jsid interned_id;
    1: 
26167:       if (!JS_ValueToId(cx, id, &interned_id)) {
    1:         return JS_FALSE;
    1:       }
    1: 
26167:       return JS_DeletePropertyById(cx, obj, interned_id);
    1:     }
    1:   );
    1: 
    1:   return ThrowException(NS_ERROR_XPC_SECURITY_MANAGER_VETO, cx);
    1: }
    1: 
 4042: JSBool
 4042: XPC_NW_RewrapIfDeepWrapper(JSContext *cx, JSObject *obj, jsval v, jsval *rval)
    1: {
10858:   NS_ASSERTION(XPCNativeWrapper::IsNativeWrapper(obj),
    1:                "Unexpected object");
    1: 
    1:   JSBool primitive = JSVAL_IS_PRIMITIVE(v);
    1:   JSObject* nativeObj = primitive ? nsnull : JSVAL_TO_OBJECT(v);
    1:   
    1:   // We always want to wrap function objects, no matter whether we're deep.
    1:   if (!primitive && JS_ObjectIsFunction(cx, nativeObj)) {
 4042:     return XPC_NW_WrapFunction(cx, nativeObj, rval);
    1:   }
    1: 
    1:   jsval flags;
    1:   ::JS_GetReservedSlot(cx, obj, 0, &flags);
    1: 
    1:   // Re-wrap non-primitive values if this is a deep wrapper, i.e.
    1:   // if (HAS_FLAGS(flags, FLAG_DEEP).
    1:   if (HAS_FLAGS(flags, FLAG_DEEP) && !primitive) {
 4042:     // Unwrap a cross origin wrapper, since we're more restrictive.
10858:     if (STOBJ_GET_CLASS(nativeObj) == &sXPC_XOW_JSClass.base) {
 4042:       if (!::JS_GetReservedSlot(cx, nativeObj, XPCWrapper::sWrappedObjSlot,
 4042:                                 &v)) {
 4042:         return JS_FALSE;
 4042:       }
 4042: 
 4042:       // If v is primitive, allow nativeObj to remain a cross origin wrapper,
 4042:       // which will fail below (since it isn't a wrapped native).
 4042:       if (!JSVAL_IS_PRIMITIVE(v)) {
 4042:         nativeObj = JSVAL_TO_OBJECT(v);
 4042:       }
 4042:     }
    1: 
    1:     XPCWrappedNative* wrappedNative =
    1:       XPCWrappedNative::GetWrappedNativeOfJSObject(cx, nativeObj);
27520:     if (!wrappedNative)
27520:       return XPC_SJOW_Construct(cx, nsnull, 1, &v, rval);
    1: 
    1:     if (HAS_FLAGS(flags, FLAG_EXPLICIT)) {
    1: #ifdef DEBUG_XPCNativeWrapper
    1:       printf("Rewrapping for deep explicit wrapper\n");
    1: #endif
24010:       if (wrappedNative == XPCNativeWrapper::SafeGetWrappedNative(obj)) {
    1:         // Already wrapped, return the wrapper.
    1:         *rval = OBJECT_TO_JSVAL(obj);
    1:         return JS_TRUE;
    1:       }
    1: 
    1:       // |obj| is an explicit deep wrapper.  We want to construct another
    1:       // explicit deep wrapper for |v|.  Just call XPCNativeWrapperCtor by hand
    1:       // (passing null as the pre-created object it doesn't use anyway) so we
    1:       // don't have to create an object we never use.
    1: 
    1:       return XPCNativeWrapperCtor(cx, nsnull, 1, &v, rval);
    1:     }
    1:     
    1: #ifdef DEBUG_XPCNativeWrapper
    1:     printf("Rewrapping for deep implicit wrapper\n");
    1: #endif
    1:     // Just using GetNewOrUsed on the return value of
    1:     // GetWrappedNativeOfJSObject will give the right thing -- the unique deep
    1:     // implicit wrapper associated with wrappedNative.
16566:     JSObject* wrapperObj = XPCNativeWrapper::GetNewOrUsed(cx, wrappedNative,
16566:                                                           nsnull);
    1:     if (!wrapperObj) {
    1:       return JS_FALSE;
    1:     }
    1: 
    1:     *rval = OBJECT_TO_JSVAL(wrapperObj);
    1:   } else {
    1:     *rval = v;
    1:   }
    1: 
    1:   return JS_TRUE;
    1: }
    1: 
18907: static JSBool
    1: XPC_NW_FunctionWrapper(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
    1:                        jsval *rval)
    1: {
    1:   JSObject *funObj = JSVAL_TO_OBJECT(argv[-2]);
    1:   if (!::JS_ObjectIsFunction(cx, funObj)) {
    1:     obj = nsnull;
    1:   }
    1: 
10858:   while (obj && !XPCNativeWrapper::IsNativeWrapper(obj)) {
10858:     obj = STOBJ_GET_PROTO(obj);
    1:   }
    1: 
    1:   if (!obj) {
    1:     return ThrowException(NS_ERROR_UNEXPECTED, cx);
    1:   }
    1: 
    1:   // The real method we're going to call is the parent of this
    1:   // function's JSObject.
10858:   JSObject *methodToCallObj = STOBJ_GET_PARENT(funObj);
25743:   XPCWrappedNative* wrappedNative = nsnull;
    1: 
25743:   jsval isAllAccess;
25743:   if (::JS_GetReservedSlot(cx, funObj,
25743:                            XPCWrapper::eAllAccessSlot,
25743:                            &isAllAccess) &&
25743:       JSVAL_TO_BOOLEAN(isAllAccess)) {
25743:     wrappedNative = XPCNativeWrapper::SafeGetWrappedNative(obj);
25743:   } else if (!XPCNativeWrapper::GetWrappedNative(cx, obj, &wrappedNative)) {
25743:     wrappedNative = nsnull;
25743:   }
25743: 
25743:   if (!wrappedNative || !::JS_ObjectIsFunction(cx, methodToCallObj)) {
    1:     return ThrowException(NS_ERROR_UNEXPECTED, cx);
    1:   }
    1: 
    1:   jsval v;
    1:   if (!::JS_CallFunctionValue(cx, wrappedNative->GetFlatJSObject(),
    1:                               OBJECT_TO_JSVAL(methodToCallObj), argc, argv,
    1:                               &v)) {
    1:     return JS_FALSE;
    1:   }
    1: 
    1:   XPCCallContext ccx(JS_CALLER, cx, obj);
    1: 
    1:   // Make sure v doesn't get collected while we're re-wrapping it.
    1:   AUTO_MARK_JSVAL(ccx, v);
    1: 
 4042:   return XPC_NW_RewrapIfDeepWrapper(cx, obj, v, rval);
    1: }
    1: 
    1: static JSBool
    1: XPC_NW_GetOrSetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp,
    1:                         JSBool aIsSet)
    1: {
    1:   // We don't deal with the following properties here.
    1:   if (id == GetRTStringByIndex(cx, XPCJSRuntime::IDX_PROTOTYPE) ||
    1:       id == GetRTStringByIndex(cx, XPCJSRuntime::IDX_TO_STRING)) {
    1:     return JS_TRUE;
    1:   }
    1: 
10858:   while (!XPCNativeWrapper::IsNativeWrapper(obj)) {
10858:     obj = STOBJ_GET_PROTO(obj);
    1:     if (!obj) {
    1:       return ThrowException(NS_ERROR_UNEXPECTED, cx);
    1:     }
    1:   }
    1: 
25743:   if (!EnsureLegalActivity(cx, obj, id,
25743:                            aIsSet ? XPCWrapper::sSecMgrSetProp
25743:                                   : XPCWrapper::sSecMgrGetProp)) {
 3162:     return JS_FALSE;
 3162:   }
 3162: 
24010:   // Protected by EnsureLegalActivity.
24010:   XPCWrappedNative *wrappedNative = XPCNativeWrapper::SafeGetWrappedNative(obj);
    1: 
    1:   if (!wrappedNative) {
    1:     return ThrowException(NS_ERROR_INVALID_ARG, cx);
    1:   }
    1: 
    1:   JSObject *nativeObj = wrappedNative->GetFlatJSObject();
    1: 
    1:   // We can't use XPC_NW_BYPASS here, because we need to do a full
    1:   // OBJ_SET_PROPERTY or OBJ_GET_PROPERTY on the wrapped native's
    1:   // object, in order to trigger reflection done by the underlying
    1:   // OBJ_LOOKUP_PROPERTY done by SET and GET.
    1: 
    1:   if (ShouldBypassNativeWrapper(cx, obj)) {
    1:     jsid interned_id;
    1: 
    1:     if (!::JS_ValueToId(cx, id, &interned_id)) {
    1:       return JS_FALSE;
    1:     }
    1: 
    1:     return aIsSet
26167:            ? JS_SetPropertyById(cx, nativeObj, interned_id, vp)
26167:            : JS_GetPropertyById(cx, nativeObj, interned_id, vp);
    1:   }
    1: 
    1:   if (!aIsSet &&
    1:       id == GetRTStringByIndex(cx, XPCJSRuntime::IDX_WRAPPED_JSOBJECT)) {
11024:     // If we're wrapping an untrusted content wrapper, then we should
11024:     // return a safe wrapper for the underlying native object. Otherwise,
11024:     // such a wrapper would be superfluous.
    1: 
    1:     jsval nativeVal = OBJECT_TO_JSVAL(nativeObj);
11024: 
11024:     nsIScriptSecurityManager *ssm = XPCWrapper::GetSecurityManager();
11024:     nsCOMPtr<nsIPrincipal> prin;
11024:     nsresult rv = ssm->GetObjectPrincipal(cx, nativeObj,
11024:                                           getter_AddRefs(prin));
11024:     if (NS_FAILED(rv)) {
11024:       return ThrowException(rv, cx);
11024:     }
11024: 
11024:     PRBool isSystem;
11024:     if (NS_SUCCEEDED(ssm->IsSystemPrincipal(prin, &isSystem)) && isSystem) {
11024:       *vp = nativeVal;
11024:       return JS_TRUE;
11024:     }
11024: 
    1:     return XPC_SJOW_Construct(cx, nsnull, 1, &nativeVal, vp);
    1:   }
    1: 
 4042:   return XPCWrapper::GetOrSetNativeProperty(cx, obj, wrappedNative, id, vp,
 4042:                                             aIsSet, JS_TRUE);
    1: }
    1: 
18907: static JSBool
    1: XPC_NW_GetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:   return XPC_NW_GetOrSetProperty(cx, obj, id, vp, PR_FALSE);
    1: }
    1: 
18907: static JSBool
    1: XPC_NW_SetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:   return XPC_NW_GetOrSetProperty(cx, obj, id, vp, PR_TRUE);
    1: }
    1: 
18907: static JSBool
    1: XPC_NW_Enumerate(JSContext *cx, JSObject *obj)
    1: {
    1:   // We are being notified of a for-in loop or similar operation on this
    1:   // XPCNativeWrapper, so forward to the correct high-level object hook,
    1:   // OBJ_ENUMERATE on the XPCWrappedNative's object, called via the
    1:   // JS_Enumerate API.  Then reflect properties named by the enumerated
    1:   // identifiers from the wrapped native to the native wrapper.
    1: 
 3162:   if (!EnsureLegalActivity(cx, obj)) {
 3162:     return JS_FALSE;
 3162:   }
 3162: 
24010:   // Protected by EnsureLegalActivity.
24010:   XPCWrappedNative *wn = XPCNativeWrapper::SafeGetWrappedNative(obj);
    1:   if (!wn) {
    1:     return JS_TRUE;
    1:   }
    1: 
 4042:   return XPCWrapper::Enumerate(cx, obj, wn->GetFlatJSObject());
    1: }
    1: 
18907: static JSBool
    1: XPC_NW_NewResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
    1:                   JSObject **objp)
    1: {
    1:   // No need to preserve on sets of wrappedJSObject or toString, since callers
    1:   // couldn't get at those values anyway.  Also, we always deal with
    1:   // wrappedJSObject and toString before looking at our scriptable hooks, so no
    1:   // need to mess with our flags yet.
 8391:   if (id == GetRTStringByIndex(cx, XPCJSRuntime::IDX_WRAPPED_JSOBJECT)) {
    1:     return JS_TRUE;
    1:   }
    1: 
 8391:   if (id == GetRTStringByIndex(cx, XPCJSRuntime::IDX_TO_STRING)) {
 8391:     *objp = obj;
25525: 
25525:     // See the comment in XPC_NW_WrapFunction for why we create this function
25525:     // like this.
25525:     JSFunction *fun = JS_NewFunction(cx, XPC_NW_toString, 0, 0, nsnull,
25525:                                      "toString");
25525:     if (!fun) {
25525:       return JS_FALSE;
25525:     }
25525: 
25525:     JSObject *funobj = JS_GetFunctionObject(fun);
25525:     STOBJ_SET_PARENT(funobj, obj);
25525: 
25525:     return JS_DefineProperty(cx, obj, "toString", OBJECT_TO_JSVAL(funobj),
25525:                              nsnull, nsnull, 0);
 8391:   }
 8391: 
25743:   PRUint32 accessType =
25743:     (flags & JSRESOLVE_ASSIGNING) ? XPCWrapper::sSecMgrSetProp
25743:                                   : XPCWrapper::sSecMgrGetProp;
25743:   if (!EnsureLegalActivity(cx, obj, id, accessType)) {
 3162:     return JS_FALSE;
 3162:   }
 3162: 
    1:   // We can't use XPC_NW_BYPASS here, because we need to do a full
    1:   // OBJ_LOOKUP_PROPERTY on the wrapped native's object, in order to
    1:   // trigger reflection along the wrapped native prototype chain.
    1:   // All we need to do is define the property in obj if it exists in
    1:   // the wrapped native's object.
    1: 
    1:   if (ShouldBypassNativeWrapper(cx, obj)) {
24010:     // Protected by EnsureLegalActivity.
24010:     XPCWrappedNative *wn = XPCNativeWrapper::SafeGetWrappedNative(obj);
    1:     if (!wn) {
    1:       return JS_TRUE;
    1:     }
    1: 
    1:     JSAutoRequest ar(cx);
    1: 
    1:     jsid interned_id;
    1:     JSObject *pobj;
26167:     jsval val;
26167:     if (!JS_ValueToId(cx, id, &interned_id) ||
26167:         !JS_LookupPropertyWithFlagsById(cx, wn->GetFlatJSObject(), interned_id,
26167:                                         JSRESOLVE_QUALIFIED, &pobj, &val)) {
    1:       return JS_FALSE;
    1:     }
    1: 
26167:     if (pobj) {
26167:       if (!JS_DefinePropertyById(cx, obj, interned_id, JSVAL_VOID, nsnull,
26167:                                  nsnull, 0)) {
    1:         return JS_FALSE;
    1:       }
    1: 
    1:       *objp = obj;
    1:     }
    1:     return JS_TRUE;
    1:   }
    1: 
10858:   while (!XPCNativeWrapper::IsNativeWrapper(obj)) {
10858:     obj = STOBJ_GET_PROTO(obj);
    1:     if (!obj) {
    1:       return ThrowException(NS_ERROR_UNEXPECTED, cx);
    1:     }
    1:   }
    1: 
24010:   // Protected by EnsureLegalActivity.
24010:   XPCWrappedNative *wrappedNative = XPCNativeWrapper::SafeGetWrappedNative(obj);
    1: 
    1:   if (!wrappedNative) {
    1:     // No wrapped native, no properties.
    1: 
    1:     return JS_TRUE;
    1:   }
    1: 
 4042:   return XPCWrapper::ResolveNativeProperty(cx, obj,
 4042:                                            wrappedNative->GetFlatJSObject(),
 4042:                                            wrappedNative, id, flags, objp,
 4042:                                            JS_TRUE);
    1: }
    1: 
18907: static JSBool
    1: XPC_NW_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
    1: {
 3162:   if (!EnsureLegalActivity(cx, obj)) {
 3162:     return JS_FALSE;
 3162:   }
 3162: 
 3056:   XPC_NW_BYPASS(cx, obj, convert, (cx, obj, type, vp));
    1:   return JS_TRUE;
    1: }
    1: 
18907: static void
    1: XPC_NW_Finalize(JSContext *cx, JSObject *obj)
    1: {
    1:   // We must not use obj's private data here since it's likely that it
    1:   // has already been finalized.
20312:   XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    1: 
    1:   {
    1:     // scoped lock
    1:     XPCAutoLock lock(rt->GetMapLock());
    1:     rt->GetExplicitNativeWrapperMap()->Remove(obj);
    1:   }
    1: }
    1: 
18907: static JSBool
    1: XPC_NW_CheckAccess(JSContext *cx, JSObject *obj, jsval id,
    1:                    JSAccessMode mode, jsval *vp)
    1: {
    1:   // Prevent setting __proto__ on an XPCNativeWrapper
    1:   if ((mode & JSACC_WATCH) == JSACC_PROTO && (mode & JSACC_WRITE)) {
    1:     return ThrowException(NS_ERROR_XPC_SECURITY_MANAGER_VETO, cx);
    1:   }
    1: 
    1:   // Forward to the checkObjectAccess hook in the JSContext, if any.
18871:   JSSecurityCallbacks *callbacks = JS_GetSecurityCallbacks(cx);
18871:   if (callbacks && callbacks->checkObjectAccess &&
18871:       !callbacks->checkObjectAccess(cx, obj, id, mode, vp)) {
    1:     return JS_FALSE;
    1:   }
    1: 
24010:   // This function does its own security checks.
24010:   XPCWrappedNative *wrappedNative = XPCNativeWrapper::SafeGetWrappedNative(obj);
    1:   if (!wrappedNative) {
    1:     return JS_TRUE;
    1:   }
    1: 
    1:   JSObject *wrapperJSObject = wrappedNative->GetFlatJSObject();
    1: 
10858:   JSClass *clazz = STOBJ_GET_CLASS(wrapperJSObject);
    1:   return !clazz->checkAccess ||
    1:     clazz->checkAccess(cx, wrapperJSObject, id, mode, vp);
    1: }
    1: 
18907: static JSBool
    1: XPC_NW_Call(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
10858:   if (!XPCNativeWrapper::IsNativeWrapper(obj)) {
    1:     // If obj is not an XPCNativeWrapper, then someone's probably trying to call
    1:     // our prototype (i.e., XPCNativeWrapper.prototype()). In this case, it is
    1:     // safe to simply ignore the call, since that's what would happen anyway.
    1: 
    1: #ifdef DEBUG
    1:     if (!JS_ObjectIsFunction(cx, obj)) {
    1:       NS_WARNING("Ignoring a call for a weird object");
    1:     }
    1: #endif
    1:     return JS_TRUE;
    1:   }
    1: 
    1:   XPC_NW_BYPASS_TEST(cx, obj, call, (cx, obj, argc, argv, rval));
    1: 
    1:   return JS_TRUE;
    1: }
    1: 
18907: static JSBool
    1: XPC_NW_Construct(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
    1:                  jsval *rval)
    1: {
    1:   // The object given to us by the JS engine is actually a stub object (the
    1:   // "new" object). This isn't any help to us, so instead use the function
    1:   // object of the constructor that we're calling (which is the native
    1:   // wrapper).
    1:   obj = JSVAL_TO_OBJECT(argv[-2]);
    1: 
    1:   XPC_NW_BYPASS_TEST(cx, obj, construct, (cx, obj, argc, argv, rval));
    1: 
24010:   if (!EnsureLegalActivity(cx, obj)) {
24010:     return JS_FALSE;
24010:   }
24010: 
24010:   // Protected by EnsureLegalActivity.
24010:   XPCWrappedNative *wrappedNative = XPCNativeWrapper::SafeGetWrappedNative(obj);
    1:   if (!wrappedNative) {
    1:     return JS_TRUE;
    1:   }
    1: 
    1:   JSBool retval = JS_TRUE;
    1: 
    1:   if (!NATIVE_HAS_FLAG(wrappedNative, WantConstruct)) {
    1:     return ThrowException(NS_ERROR_INVALID_ARG, cx);
    1:   }
    1: 
    1:   nsresult rv = wrappedNative->GetScriptableInfo()->
    1:     GetCallback()->Construct(wrappedNative, cx, obj, argc, argv, rval,
    1:                              &retval);
    1:   if (NS_FAILED(rv)) {
    1:     return ThrowException(rv, cx);
    1:   }
    1: 
    1:   if (!retval) {
    1:     return JS_FALSE;
    1:   }
    1: 
    1:   if (JSVAL_IS_PRIMITIVE(*rval)) {
    1:     return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
    1:   }
    1: 
 4042:   return XPC_NW_RewrapIfDeepWrapper(cx, obj, *rval, rval);
    1: }
    1: 
18907: static JSBool
    1: XPC_NW_HasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
    1: {
    1:   XPC_NW_BYPASS_TEST(cx, obj, hasInstance, (cx, obj, v, bp));
    1: 
    1:   return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: MirrorWrappedNativeParent(JSContext *cx, XPCWrappedNative *wrapper,
28730:                           JSObject **result NS_OUTPARAM)
    1: {
10858:   JSObject *wn_parent = STOBJ_GET_PARENT(wrapper->GetFlatJSObject());
    1:   if (!wn_parent) {
    1:     *result = nsnull;
    1:   } else {
    1:     XPCWrappedNative *parent_wrapper =
    1:       XPCWrappedNative::GetWrappedNativeOfJSObject(cx, wn_parent);
    1: 
20445:     // parent_wrapper can be null if we're in a Components.utils.evalInSandbox
20445:     // scope. In that case, the best we can do is just use the
20445:     // non-native-wrapped sandbox global object for our parent.
20445:     if (parent_wrapper) {
16566:       *result = XPCNativeWrapper::GetNewOrUsed(cx, parent_wrapper, nsnull);
    1:       if (!*result)
    1:         return JS_FALSE;
28730:     } else {
28730:       *result = nsnull;
    1:     }
20445:   }
    1:   return JS_TRUE;
    1: }
    1: 
21405: JSBool
    1: XPCNativeWrapperCtor(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
    1:                      jsval *rval)
    1: {
    1:   if (argc < 1) {
    1:     return ThrowException(NS_ERROR_XPC_NOT_ENOUGH_ARGS, cx);
    1:   }
    1: 
    1:   // |obj| almost always has the wrong proto and parent so we have to create
    1:   // our own object anyway.  Set |obj| to null so we don't use it by accident.
    1:   obj = nsnull;
    1: 
    1:   jsval native = argv[0];
    1: 
    1:   if (JSVAL_IS_PRIMITIVE(native)) {
24834:     JSStackFrame *fp = nsnull;
24834:     if (JS_FrameIterator(cx, &fp) && JS_IsConstructorFrame(cx, fp)) {
24834:       return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
24834:     }
24834: 
24834:     *rval = native;
24834:     return JS_TRUE;
    1:   }
    1: 
    1:   JSObject *nativeObj = JSVAL_TO_OBJECT(native);
    1: 
24010:   // Unwrap a cross origin wrapper, since we're more restrictive than it is.
24010:   if (STOBJ_GET_CLASS(nativeObj) == &sXPC_XOW_JSClass.base) {
24010:     jsval v;
24010:     if (!::JS_GetReservedSlot(cx, nativeObj, XPCWrapper::sWrappedObjSlot, &v)) {
24010:       return JS_FALSE;
24010:     }
24010:     // If v is primitive, allow nativeObj to remain a cross origin wrapper,
24010:     // which will fail below (since it isn't a wrapped native).
24010:     if (!JSVAL_IS_PRIMITIVE(v)) {
24010:       nativeObj = JSVAL_TO_OBJECT(v);
24010:     }
24010:   } else if (STOBJ_GET_CLASS(nativeObj) == &sXPC_SJOW_JSClass.base) {
24010:     // Also unwrap SJOWs.
24010:     nativeObj = JS_GetParent(cx, nativeObj);
24010:     if (!nativeObj) {
12584:       return ThrowException(NS_ERROR_XPC_BAD_CONVERT_JS, cx);
 4042:     }
24010:   }
12584: 
    1:   XPCWrappedNative *wrappedNative;
    1: 
10858:   if (XPCNativeWrapper::IsNativeWrapper(nativeObj)) {
    1:     // We're asked to wrap an already wrapped object. Re-wrap the
    1:     // object wrapped by the given wrapper.
    1: 
    1: #ifdef DEBUG_XPCNativeWrapper
    1:     printf("Wrapping already wrapped object\n");
    1: #endif
    1: 
24010:     // It's always safe to re-wrap an object.
24010:     wrappedNative = XPCNativeWrapper::SafeGetWrappedNative(nativeObj);
    1: 
    1:     if (!wrappedNative) {
    1:       return ThrowException(NS_ERROR_INVALID_ARG, cx);
    1:     }
    1: 
    1:     nativeObj = wrappedNative->GetFlatJSObject();
    1:     native = OBJECT_TO_JSVAL(nativeObj);
    1:   } else {
    1:     wrappedNative
    1:       = XPCWrappedNative::GetWrappedNativeOfJSObject(cx, nativeObj);
    1: 
    1:     if (!wrappedNative) {
    1:       return ThrowException(NS_ERROR_INVALID_ARG, cx);
    1:     }
    1: 
    1:     // Prevent wrapping a double-wrapped JS object in an
    1:     // XPCNativeWrapper!
    1:     nsCOMPtr<nsIXPConnectWrappedJS> xpcwrappedjs =
    1:       do_QueryWrappedNative(wrappedNative);
    1: 
    1:     if (xpcwrappedjs) {
    1:       return ThrowException(NS_ERROR_INVALID_ARG, cx);
    1:     }
    1:   }
    1: 
    1:   JSObject *wrapperObj;
    1: 
    1:   // Don't use the object the JS engine created for us, it is in most
    1:   // cases incorectly parented and has a proto from the wrong scope.
    1: #ifdef DEBUG_XPCNativeWrapper
    1:   printf("Creating new JSObject\n");
    1: #endif
11700:   wrapperObj = ::JS_NewObjectWithGivenProto(cx, XPCNativeWrapper::GetJSClass(),
11700:                                             nsnull,
11700:                                             wrappedNative->GetScope()
11700:                                                          ->GetGlobalJSObject());
    1: 
11700:   if (!wrapperObj) {
    1:     // JS_NewObject already threw (or reported OOM).
    1:     return JS_FALSE;
    1:   }
    1: 
    1:   PRBool hasStringArgs = PR_FALSE;
    1:   for (uintN i = 1; i < argc; ++i) {
    1:     if (!JSVAL_IS_STRING(argv[i])) {
    1:       hasStringArgs = PR_FALSE;
    1: 
    1:       break;
    1:     }
    1: 
    1:     if (i == 1) {
    1: #ifdef DEBUG_XPCNativeWrapper
    1:       printf("Constructing XPCNativeWrapper() with string args\n");
    1: #endif
    1:     }
    1: 
    1: #ifdef DEBUG_XPCNativeWrapper
    1:     printf("  %s\n", ::JS_GetStringBytes(JSVAL_TO_STRING(argv[i])));
    1: #endif
    1: 
    1:     hasStringArgs = PR_TRUE;
    1:   }
    1: 
    1:   JSBool isDeep = !hasStringArgs;
    1:   jsuint flags = isDeep ? FLAG_DEEP | FLAG_EXPLICIT : FLAG_EXPLICIT;
    1:   if (!::JS_SetReservedSlot(cx, wrapperObj, 0, INT_TO_JSVAL(flags))) {
    1:     return JS_FALSE;
    1:   }
    1: 
    1:   JSObject *parent = nsnull;
    1: 
    1:   if (isDeep) {
    1:     // Make sure wrapperObj doesn't get collected while we're wrapping
    1:     // parents for it.
    1:     ::JS_LockGCThing(cx, wrapperObj);
    1: 
    1:     // A deep XPCNativeWrapper has a __parent__ chain that mirrors its
    1:     // XPCWrappedNative's chain.
    1:     if (!MirrorWrappedNativeParent(cx, wrappedNative, &parent))
    1:       return JS_FALSE;
    1: 
    1:     ::JS_UnlockGCThing(cx, wrapperObj);
    1: 
    1:     if (argc == 2 && !JSVAL_IS_PRIMITIVE(argv[1])) {
    1:       // An object was passed as the second argument to the
    1:       // constructor. In this case we check that the object we're
    1:       // wrapping is an instance of the assumed constructor that we
    1:       // got. If not, throw an exception.
    1:       JSBool hasInstance;
    1:       if (!::JS_HasInstance(cx, JSVAL_TO_OBJECT(argv[1]), native,
    1:                             &hasInstance)) {
    1:         return ThrowException(NS_ERROR_UNEXPECTED, cx);
    1:       }
    1: 
    1:       if (!hasInstance) {
    1:         return ThrowException(NS_ERROR_INVALID_ARG, cx);
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (!parent) {
    1:     parent = wrappedNative->GetScope()->GetGlobalJSObject();
    1:   }
    1:     
    1:   if (!::JS_SetParent(cx, wrapperObj, parent))
    1:     return JS_FALSE;
    1: 
    1:   // Set the XPCWrappedNative as private data in the native wrapper.
    1:   if (!::JS_SetPrivate(cx, wrapperObj, wrappedNative)) {
    1:     return JS_FALSE;
    1:   }
    1: 
    1: #if defined(DEBUG_XPCNativeWrapper) || defined(DEBUG_xpc_leaks)
    1:   {
    1:     XPCCallContext ccx(JS_CALLER, cx);
    1: 
    1:     // Keep wrapperObj alive while we mess with strings
    1:     AUTO_MARK_JSVAL(ccx, OBJECT_TO_JSVAL(wrapperObj));
    1: 
    1:     char *s = wrappedNative->ToString(ccx);
    1:     printf("Created new XPCNativeWrapper %p for wrapped native %s\n",
    1:            (void*)wrapperObj, s);
    1:     if (s)
    1:       JS_smprintf_free(s);
    1:   }
    1: #endif
    1:   
    1:   *rval = OBJECT_TO_JSVAL(wrapperObj);
    1: 
    1:   {
    1:     XPCJSRuntime *rt = wrappedNative->GetRuntime();
    1: 
    1:     // scoped lock
    1:     XPCAutoLock lock(rt->GetMapLock());
    1:     rt->GetExplicitNativeWrapperMap()->Add(wrapperObj);
    1:   }
    1: 
    1:   return JS_TRUE;
    1: }
    1: 
18907: static void
 1025: XPC_NW_Trace(JSTracer *trc, JSObject *obj)
    1: {
24010:   // Untrusted code can't trigger this.
24010:   XPCWrappedNative *wrappedNative = XPCNativeWrapper::SafeGetWrappedNative(obj);
    1: 
    1:   if (wrappedNative && wrappedNative->IsValid()) {
 1025:     JS_CALL_OBJECT_TRACER(trc, wrappedNative->GetFlatJSObject(),
 1025:                           "wrappedNative.flatJSObject");
    1:   }
    1: }
    1: 
18907: static JSBool
    1: XPC_NW_Equality(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
    1: {
10858:   NS_ASSERTION(XPCNativeWrapper::IsNativeWrapper(obj),
    1:                "Uh, we should only ever be called for XPCNativeWrapper "
    1:                "objects!");
    1: 
24010:   if (!EnsureLegalActivity(cx, obj)) {
24010:     return JS_FALSE;
24010:   }
24010: 
    1:   if (JSVAL_IS_PRIMITIVE(v)) {
    1:     *bp = JS_FALSE;
    1: 
    1:     return JS_TRUE;
    1:   }
    1: 
24010:   // Protected by EnsureLegalActivity.
24010:   XPCWrappedNative *wrappedNative = XPCNativeWrapper::SafeGetWrappedNative(obj);
    1: 
    1:   if (wrappedNative && wrappedNative->IsValid() &&
    1:       NATIVE_HAS_FLAG(wrappedNative, WantEquality)) {
    1:     // Forward the call to the wrapped native's Equality() hook.
    1:     nsresult rv = wrappedNative->GetScriptableCallback()->
    1:       Equality(wrappedNative, cx, obj, v, bp);
    1: 
    1:     if (NS_FAILED(rv)) {
    1:       return ThrowException(rv, cx);
    1:     }
    1:   } else {
    1:     JSObject *other = JSVAL_TO_OBJECT(v);
    1: 
    1:     *bp = (obj == other ||
    1:            XPC_GetIdentityObject(cx, obj) == XPC_GetIdentityObject(cx, other));
    1:   }
    1: 
    1:   return JS_TRUE;
    1: }
    1: 
18907: static JSBool
    1: XPC_NW_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
    1:                 jsval *rval)
    1: {
10858:   while (!XPCNativeWrapper::IsNativeWrapper(obj)) {
10858:     obj = STOBJ_GET_PROTO(obj);
    1:     if (!obj) {
    1:       return ThrowException(NS_ERROR_UNEXPECTED, cx);
    1:     }
    1:   }
    1: 
 3162:   if (!EnsureLegalActivity(cx, obj)) {
 3162:     return JS_FALSE;
 3162:   }
 3162: 
24010:   // Protected by EnsureLegalActivity.
24010:   XPCWrappedNative *wrappedNative = XPCNativeWrapper::SafeGetWrappedNative(obj);
    1: 
    1:   if (!wrappedNative) {
    1:     // toString() called on XPCNativeWrapper.prototype
    1:     NS_NAMED_LITERAL_STRING(protoString, "[object XPCNativeWrapper]");
    1:     JSString *str =
 3233:       ::JS_NewUCStringCopyN(cx, reinterpret_cast<const jschar*>
 3233:                                                 (protoString.get()),
    1:                             protoString.Length());
    1:     NS_ENSURE_TRUE(str, JS_FALSE);
    1:     *rval = STRING_TO_JSVAL(str);
    1:     return JS_TRUE;
    1:   }
    1: 
 4042:   return XPCWrapper::NativeToString(cx, wrappedNative, argc, argv, rval,
 4042:                                     JS_TRUE);
    1: }
    1: 
    1: // static
    1: PRBool
    1: XPCNativeWrapper::AttachNewConstructorObject(XPCCallContext &ccx,
    1:                                              JSObject *aGlobalObject)
    1: {
    1:   JSObject *class_obj =
    1:     ::JS_InitClass(ccx, aGlobalObject, nsnull, &sXPC_NW_JSClass.base,
 8391:                    XPCNativeWrapperCtor, 0, nsnull, nsnull,
    1:                    nsnull, nsnull);
    1:   if (!class_obj) {
    1:     NS_WARNING("can't initialize the XPCNativeWrapper class");
    1:     return PR_FALSE;
    1:   }
    1:   
    1:   // Make sure our prototype chain is empty and that people can't mess
    1:   // with XPCNativeWrapper.prototype.
    1:   ::JS_SetPrototype(ccx, class_obj, nsnull);
    1:   if (!::JS_SealObject(ccx, class_obj, JS_FALSE)) {
    1:     NS_WARNING("Failed to seal XPCNativeWrapper.prototype");
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   JSBool found;
    1:   return ::JS_SetPropertyAttributes(ccx, aGlobalObject,
    1:                                     sXPC_NW_JSClass.base.name,
    1:                                     JSPROP_READONLY | JSPROP_PERMANENT,
    1:                                     &found);
    1: }
    1: 
    1: // static
    1: JSObject *
16566: XPCNativeWrapper::GetNewOrUsed(JSContext *cx, XPCWrappedNative *wrapper,
20762:                                nsIPrincipal *aObjectPrincipal)
    1: {
20762:   if (aObjectPrincipal) {
20762:     nsIScriptSecurityManager *ssm = XPCWrapper::GetSecurityManager();
16566: 
16566:     PRBool isSystem;
20762:     nsresult rv = ssm->IsSystemPrincipal(aObjectPrincipal, &isSystem);
16566:     if (NS_SUCCEEDED(rv) && !isSystem) {
16566:       jsval v = OBJECT_TO_JSVAL(wrapper->GetFlatJSObject());
16566:       if (!XPCNativeWrapperCtor(cx, JSVAL_TO_OBJECT(v), 1, &v, &v))
16566:         return nsnull;
16566:       return JSVAL_TO_OBJECT(v);
16566:     }
16566:   }
16566: 
    1:   // Prevent wrapping a double-wrapped JS object in an
    1:   // XPCNativeWrapper!
    1:   nsCOMPtr<nsIXPConnectWrappedJS> xpcwrappedjs(do_QueryWrappedNative(wrapper));
    1: 
    1:   if (xpcwrappedjs) {
25423:     JSObject *flat = wrapper->GetFlatJSObject();
25423:     jsval v = OBJECT_TO_JSVAL(flat);
25423: 
25423:     XPCCallContext ccx(JS_CALLER, cx);
25423: 
25423:     // Make sure v doesn't get collected while we're re-wrapping it.
25423:     AUTO_MARK_JSVAL(ccx, v);
25423: 
25423:     if (XPC_SJOW_Construct(cx, nsnull, 1, &v, &v))
25423:         return JSVAL_TO_OBJECT(v);
    1: 
    1:     return nsnull;
    1:   }
    1: 
 4042:   JSObject *obj = wrapper->GetWrapper();
    1:   if (obj) {
    1:     return obj;
    1:   }
    1: 
    1:   JSObject *nw_parent;
    1:   if (!MirrorWrappedNativeParent(cx, wrapper, &nw_parent)) {
    1:     return nsnull;
    1:   }
    1: 
    1:   PRBool lock;
    1: 
    1:   if (!nw_parent) {
    1:     nw_parent = wrapper->GetScope()->GetGlobalJSObject();
    1: 
    1:     lock = PR_FALSE;
    1:   } else {
    1:     lock = PR_TRUE;
    1:   }
    1: 
    1:   if (lock) {
    1:     // Make sure nw_parent doesn't get collected while we're creating
    1:     // the new wrapper.
    1:     ::JS_LockGCThing(cx, nw_parent);
    1:   }
    1: 
11700:   obj = ::JS_NewObjectWithGivenProto(cx, GetJSClass(), nsnull, nw_parent);
    1: 
    1:   if (lock) {
    1:     ::JS_UnlockGCThing(cx, nw_parent);
    1:   }
    1: 
    1:   if (!obj ||
    1:       !::JS_SetPrivate(cx, obj, wrapper) ||
    1:       !::JS_SetReservedSlot(cx, obj, 0, INT_TO_JSVAL(FLAG_DEEP))) {
    1:     return nsnull;
    1:   }
    1: 
 4042:   wrapper->SetWrapper(obj);
    1: 
    1: #if defined(DEBUG_XPCNativeWrapper) || defined(DEBUG_xpc_leaks)
    1:   {
    1:     XPCCallContext ccx(NATIVE_CALLER, cx);
    1: 
    1:     // Keep obj alive while we mess with strings
    1:     AUTO_MARK_JSVAL(ccx, OBJECT_TO_JSVAL(obj));
    1: 
    1:     char *s = wrapper->ToString(ccx);
    1:     printf("Created new XPCNativeWrapper %p for wrapped native %s\n",
    1:            (void*)obj, s);
    1:     if (s)
    1:       JS_smprintf_free(s);
    1:   }
    1: #endif
    1:   
    1:   return obj;
    1: }
    1: 
    1: struct WrapperAndCxHolder
    1: {
    1:     XPCWrappedNative* wrapper;
    1:     JSContext* cx;
    1: };
    1: 
18907: static JSDHashOperator
    1: ClearNativeWrapperScope(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                         uint32 number, void *arg)
    1: {
    1:     JSDHashEntryStub* entry = (JSDHashEntryStub*)hdr;
    1:     WrapperAndCxHolder* d = (WrapperAndCxHolder*)arg;
    1: 
 4042:     if (d->wrapper->GetWrapper() == (JSObject*)entry->key)
    1:     {
    1:         ::JS_ClearScope(d->cx, (JSObject*)entry->key);
    1:     }
    1: 
    1:     return JS_DHASH_NEXT;
    1: }
    1: 
    1: // static
    1: void
    1: XPCNativeWrapper::ClearWrappedNativeScopes(JSContext* cx,
    1:                                            XPCWrappedNative* wrapper)
    1: {
 4042:   JSObject *nativeWrapper = wrapper->GetWrapper();
    1: 
    1:   if (nativeWrapper) {
    1:     ::JS_ClearScope(cx, nativeWrapper);
    1:   }
    1: 
    1:   WrapperAndCxHolder d =
    1:     {
    1:       wrapper,
    1:       cx
    1:     };
    1: 
    1:   wrapper->GetRuntime()->GetExplicitNativeWrapperMap()->
    1:     Enumerate(ClearNativeWrapperScope, &d);
    1: }
