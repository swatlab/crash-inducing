57301: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
57301: /* vim: set ts=2 et sw=2 tw=80: */
57301: /* ***** BEGIN LICENSE BLOCK *****
57301:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
57301:  *
57301:  * The contents of this file are subject to the Mozilla Public License Version
57301:  * 1.1 (the "License"); you may not use this file except in compliance with
57301:  * the License. You may obtain a copy of the License at
57301:  * http://www.mozilla.org/MPL/
57301:  *
57301:  * Software distributed under the License is distributed on an "AS IS" basis,
57301:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
57301:  * for the specific language governing rights and limitations under the
57301:  * License.
57301:  *
57301:  * The Original Code is Indexed Database.
57301:  *
57301:  * The Initial Developer of the Original Code is
57301:  * The Mozilla Foundation.
57301:  * Portions created by the Initial Developer are Copyright (C) 2010
57301:  * the Initial Developer. All Rights Reserved.
57301:  *
57301:  * Contributor(s):
57301:  *   Ben Turner <bent.mozilla@gmail.com>
57301:  *
57301:  * Alternatively, the contents of this file may be used under the terms of
57301:  * either the GNU General Public License Version 2 or later (the "GPL"), or
57301:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
57301:  * in which case the provisions of the GPL or the LGPL are applicable instead
57301:  * of those above. If you wish to allow use of your version of this file only
57301:  * under the terms of either the GPL or the LGPL, and not to allow others to
57301:  * use your version of this file under the terms of the MPL, indicate your
57301:  * decision by deleting the provisions above and replace them with the notice
57301:  * and other provisions required by the GPL or the LGPL. If you do not delete
57301:  * the provisions above, a recipient may use your version of this file under
57301:  * the terms of any one of the MPL, the GPL or the LGPL.
57301:  *
57301:  * ***** END LICENSE BLOCK ***** */
57301: 
57301: #ifndef mozilla_dom_indexeddb_key_h__
57301: #define mozilla_dom_indexeddb_key_h__
57301: 
57301: #include "mozilla/dom/indexedDB/IndexedDatabase.h"
57301: 
81334: #include "mozIStorageStatement.h"
81334: 
57301: BEGIN_INDEXEDDB_NAMESPACE
57301: 
57301: class Key
57301: {
57301: public:
57301:   Key()
57301:   {
81334:     Unset();
57301:   }
57301: 
57301:   Key& operator=(const nsAString& aString)
57301:   {
81334:     SetFromString(aString);
57301:     return *this;
57301:   }
57301: 
57301:   Key& operator=(PRInt64 aInt)
57301:   {
81334:     SetFromInteger(aInt);
57301:     return *this;
57301:   }
57301: 
57301:   bool operator==(const Key& aOther) const
57301:   {
85022:     NS_ASSERTION(!mBuffer.IsVoid() && !aOther.mBuffer.IsVoid(),
81334:                  "Don't compare unset keys!");
81334: 
85022:     return mBuffer.Equals(aOther.mBuffer);
57301:   }
57301: 
57301:   bool operator!=(const Key& aOther) const
57301:   {
85022:     NS_ASSERTION(!mBuffer.IsVoid() && !aOther.mBuffer.IsVoid(),
85022:                  "Don't compare unset keys!");
85022: 
85022:     return !mBuffer.Equals(aOther.mBuffer);
57301:   }
57301: 
57301:   bool operator<(const Key& aOther) const
57301:   {
85022:     NS_ASSERTION(!mBuffer.IsVoid() && !aOther.mBuffer.IsVoid(),
81334:                  "Don't compare unset keys!");
81334: 
85022:     return Compare(mBuffer, aOther.mBuffer) < 0;
57301:   }
57301: 
57301:   bool operator>(const Key& aOther) const
57301:   {
85022:     NS_ASSERTION(!mBuffer.IsVoid() && !aOther.mBuffer.IsVoid(),
85022:                  "Don't compare unset keys!");
85022: 
85022:     return Compare(mBuffer, aOther.mBuffer) > 0;
57301:   }
57301: 
59038:   bool operator<=(const Key& aOther) const
59038:   {
85022:     NS_ASSERTION(!mBuffer.IsVoid() && !aOther.mBuffer.IsVoid(),
85022:                  "Don't compare unset keys!");
85022: 
85022:     return Compare(mBuffer, aOther.mBuffer) <= 0;
59038:   }
59038: 
59038:   bool operator>=(const Key& aOther) const
59038:   {
85022:     NS_ASSERTION(!mBuffer.IsVoid() && !aOther.mBuffer.IsVoid(),
85022:                  "Don't compare unset keys!");
85022: 
85022:     return Compare(mBuffer, aOther.mBuffer) >= 0;
59038:   }
59038: 
81334:   void
81334:   Unset()
81334:   {
85022:     mBuffer.SetIsVoid(true);
57301:   }
57301: 
85022:   bool IsUnset() const
81334:   {
85022:     return mBuffer.IsVoid();
57301:   }
57301: 
85022:   bool IsFloat() const
81334:   {
85022:     return !mBuffer.IsVoid() && mBuffer.First() == eFloat;
85022:   }
85022: 
85022:   double ToFloat() const
85022:   {
85022:     NS_ASSERTION(IsFloat(), "Why'd you call this?");
85022:     const unsigned char* pos = BufferStart();
85022:     double res = DecodeNumber(pos, BufferEnd());
85022:     NS_ASSERTION(pos >= BufferEnd(), "Should consume whole buffer");
85022:     return res;
85022:   }
85022: 
85022:   void SetFromString(const nsAString& aString)
85022:   {
85022:     mBuffer.Truncate();
85022:     EncodeString(aString, 0);
85022:     TrimBuffer();
85022:   }
85022: 
85022:   void SetFromInteger(PRInt64 aInt)
85022:   {
85022:     mBuffer.Truncate();
85022:     EncodeNumber(double(aInt), eFloat);
85022:     TrimBuffer();
57301:   }
57301: 
81334:   nsresult SetFromJSVal(JSContext* aCx,
85022:                         const jsval aVal)
81334:   {
85022:     mBuffer.Truncate();
81334: 
81334:     if (JSVAL_IS_NULL(aVal) || JSVAL_IS_VOID(aVal)) {
81334:       Unset();
81334:       return NS_OK;
81334:     }
81334: 
85022:     nsresult rv = EncodeJSVal(aCx, aVal, 0);
85022:     if (NS_FAILED(rv)) {
85022:       Unset();
85022:       return rv;
85022:     }
85022:     TrimBuffer();
85022: 
85022:     return NS_OK;
81334:   }
81334: 
81334:   nsresult ToJSVal(JSContext* aCx,
81334:                    jsval* aVal) const
81334:   {
85022:     if (IsUnset()) {
81334:       *aVal = JSVAL_VOID;
81334:       return NS_OK;
81334:     }
81334: 
85022:     const unsigned char* pos = BufferStart();
85022:     nsresult rv = DecodeJSVal(pos, BufferEnd(), aCx, 0, aVal);
85022:     NS_ENSURE_SUCCESS(rv, rv);
85022: 
85022:     NS_ASSERTION(pos >= BufferEnd(),
85022:                  "Didn't consume whole buffer");
85022: 
85022:     return NS_OK;
81334:   }
81334: 
85023:   nsresult AppendArrayItem(JSContext* aCx,
85023:                            bool aFirst,
85023:                            const jsval aVal)
85023:   {
85023:     if (aFirst) {
85023:       Unset();
85023:     }
85023: 
85023:     nsresult rv = EncodeJSVal(aCx, aVal, aFirst ? eMaxType : 0);
85023:     if (NS_FAILED(rv)) {
85023:       Unset();
85023:       return rv;
85023:     }
85023: 
85023:     return NS_OK;
85023:   }
85023: 
85023:   void FinishArray()
85023:   {
85023:     TrimBuffer();
85023:   }
85023: 
85022:   const nsCString& GetBuffer() const
81334:   {
85022:     return mBuffer;
81334:   }
81334: 
81334:   nsresult BindToStatement(mozIStorageStatement* aStatement,
81334:                            const nsACString& aParamName) const
81334:   {
85022:     nsresult rv = aStatement->BindBlobByName(aParamName,
85022:       reinterpret_cast<const PRUint8*>(mBuffer.get()), mBuffer.Length());
81334: 
81334:     return NS_SUCCEEDED(rv) ? NS_OK : NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR;
81334:   }
81334: 
81334:   nsresult SetFromStatement(mozIStorageStatement* aStatement,
81334:                             PRUint32 aIndex)
81334:   {
85022:     PRUint8* data;
85022:     PRUint32 dataLength = 0;
85022: 
85022:     nsresult rv = aStatement->GetBlob(aIndex, &dataLength, &data);
81334:     NS_ENSURE_SUCCESS(rv, NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR);
81334: 
85022:     mBuffer.Adopt(
85022:       reinterpret_cast<char*>(const_cast<PRUint8*>(data)), dataLength);
81334: 
85022:     return NS_OK;
57301:   }
57301: 
57301:   static
85022:   PRInt16 CompareKeys(Key& aFirst, Key& aSecond)
81334:   {
85022:     PRInt32 result = Compare(aFirst.mBuffer, aSecond.mBuffer);
85022: 
85022:     if (result < 0) {
85022:       return -1;
85022:     }
85022: 
85022:     if (result > 0) {
85022:       return 1;
85022:     }
85022: 
85022:     return 0;
57301:   }
57301: 
57301: private:
85022:   const unsigned char* BufferStart() const
85022:   {
85022:     return reinterpret_cast<const unsigned char*>(mBuffer.BeginReading());
85022:   }
85022: 
85022:   const unsigned char* BufferEnd() const
85022:   {
85022:     return reinterpret_cast<const unsigned char*>(mBuffer.EndReading());
85022:   }
85022: 
85022:   enum {
85022:     eTerminator = 0,
85022:     eFloat = 1,
85022:     eDate = 2,
85022:     eString = 3,
85022:     eArray = 4,
85022:     eMaxType = eArray
81334:   };
81334: 
85022:   // Encoding helper. Trims trailing zeros off of mBuffer as a post-processing
85022:   // step.
85022:   void TrimBuffer()
85022:   {
85022:     const char* end = mBuffer.EndReading() - 1;
85022:     while (!*end) {
85022:       --end;
85022:     }
81334: 
85022:     mBuffer.Truncate(end + 1 - mBuffer.BeginReading());
85022:   }
81334: 
85022:   // Encoding functions. These append the encoded value to the end of mBuffer
98279:   inline nsresult EncodeJSVal(JSContext* aCx, const jsval aVal,
98279:                               PRUint8 aTypeOffset)
98279:   {
98279:     return EncodeJSValInternal(aCx, aVal, aTypeOffset, 0);
98279:   }
85022:   void EncodeString(const nsAString& aString, PRUint8 aTypeOffset);
85022:   void EncodeNumber(double aFloat, PRUint8 aType);
85022: 
85022:   // Decoding functions. aPos points into mBuffer and is adjusted to point
85022:   // past the consumed value.
98279:   static inline nsresult DecodeJSVal(const unsigned char*& aPos,
85022:                                      const unsigned char* aEnd, JSContext* aCx,
98279:                                      PRUint8 aTypeOffset, jsval* aVal)
98279:   {
98279:     return DecodeJSValInternal(aPos, aEnd, aCx, aTypeOffset, aVal, 0);
98279:   }
98279: 
85022:   static void DecodeString(const unsigned char*& aPos,
85022:                            const unsigned char* aEnd,
85022:                            nsString& aString);
85022:   static double DecodeNumber(const unsigned char*& aPos,
85022:                              const unsigned char* aEnd);
85022: 
85022:   nsCString mBuffer;
98279: 
98279: private:
98279:   nsresult EncodeJSValInternal(JSContext* aCx, const jsval aVal,
98279:                                PRUint8 aTypeOffset, PRUint16 aRecursionDepth);
98279: 
98279:   static nsresult DecodeJSValInternal(const unsigned char*& aPos,
98279:                                       const unsigned char* aEnd,
98279:                                       JSContext* aCx, PRUint8 aTypeOffset,
98279:                                       jsval* aVal, PRUint16 aRecursionDepth);
57301: };
57301: 
57301: END_INDEXEDDB_NAMESPACE
57301: 
57301: #endif /* mozilla_dom_indexeddb_key_h__ */
