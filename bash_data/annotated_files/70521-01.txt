70088: /* ***** BEGIN LICENSE BLOCK *****
70088:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
70088:  *
70088:  * The contents of this file are subject to the Mozilla Public License Version
70088:  * 1.1 (the "License"); you may not use this file except in compliance with
70088:  * the License. You may obtain a copy of the License at
70088:  * http://www.mozilla.org/MPL/
70088:  *
70088:  * Software distributed under the License is distributed on an "AS IS" basis,
70088:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
70088:  * for the specific language governing rights and limitations under the
70088:  * License.
70088:  *
70088:  * The Original Code is about:permissions code.
70088:  *
70088:  * The Initial Developer of the Original Code is
70088:  * the Mozilla Foundation.
70088:  * Portions created by the Initial Developer are Copyright (C) 2011
70088:  * the Initial Developer. All Rights Reserved.
70088:  *
70088:  * Contributor(s):
70088:  *  Margaret Leibovic <margaret.leibovic@gmail.com>
70088:  *
70088:  * Alternatively, the contents of this file may be used under the terms of
70088:  * either the GNU General Public License Version 2 or later (the "GPL"), or
70088:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
70088:  * in which case the provisions of the GPL or the LGPL are applicable instead
70088:  * of those above. If you wish to allow use of your version of this file only
70088:  * under the terms of either the GPL or the LGPL, and not to allow others to
70088:  * use your version of this file under the terms of the MPL, indicate your
70088:  * decision by deleting the provisions above and replace them with the notice
70088:  * and other provisions required by the GPL or the LGPL. If you do not delete
70088:  * the provisions above, a recipient may use your version of this file under
70088:  * the terms of any one of the MPL, the GPL or the LGPL.
70088:  *
70088:  * ***** END LICENSE BLOCK ***** */
70088: 
70088: let Ci = Components.interfaces;
70088: let Cc = Components.classes;
70088: let Cu = Components.utils;
70088: 
70088: Cu.import("resource://gre/modules/Services.jsm");
70088: Cu.import("resource://gre/modules/PluralForm.jsm");
70088: Cu.import("resource://gre/modules/DownloadUtils.jsm");
70088: Cu.import("resource://gre/modules/NetUtil.jsm");
70088: 
70088: let gFaviconService = Cc["@mozilla.org/browser/favicon-service;1"].
70088:                       getService(Ci.nsIFaviconService);
70088: 
70088: let gPlacesDatabase = Cc["@mozilla.org/browser/nav-history-service;1"].
70088:                       getService(Ci.nsPIPlacesDatabase).
70088:                       DBConnection.
70088:                       clone(true);
70088: 
70088: let gSitesStmt = gPlacesDatabase.createAsyncStatement(
70088:                   "SELECT get_unreversed_host(rev_host) AS host " +
70088:                   "FROM moz_places " +
70088:                   "WHERE rev_host > '.' " +
70088:                   "AND visit_count > 0 " +
70088:                   "GROUP BY rev_host " +
70088:                   "ORDER BY MAX(frecency) DESC " +
70088:                   "LIMIT :limit");
70088: 
70088: let gVisitStmt = gPlacesDatabase.createAsyncStatement(
70088:                   "SELECT SUM(visit_count) AS count " +
70088:                   "FROM moz_places " +
70088:                   "WHERE rev_host = :rev_host");
70088: 
70088: /**
70088:  * Permission types that should be tested with testExactPermission, as opposed
70088:  * to testPermission. This is based on what consumers use to test these permissions.
70088:  */
70088: let TEST_EXACT_PERM_TYPES = ["geo"];
70088: 
70088: /**
70088:  * Site object represents a single site, uniquely identified by a host.
70088:  */
70088: function Site(host) {
70088:   this.host = host;
70088:   this.listitem = null;
70088: 
70088:   this.httpURI = NetUtil.newURI("http://" + this.host);
70088:   this.httpsURI = NetUtil.newURI("https://" + this.host);
70088: 
70088:   this._favicon = "";
70088: }
70088: 
70088: Site.prototype = {
70088:   /**
70088:    * Gets the favicon to use for the site. This will return the default favicon
70088:    * if there is no favicon stored for the site.
70088:    *
70088:    * @return A favicon image URL.
70088:    */
70088:   get favicon() {
70088:     if (!this._favicon) {
70088:       // TODO: Bug 657961: Make this async when bug 655270 is fixed.
70088:       try {
70088:         // First try to see if a favicon is stored for the http URI.
70088:         this._favicon = gFaviconService.getFaviconForPage(this.httpURI).spec;
70088:       } catch (e) {
70088:         // getFaviconImageForPage returns the default favicon if no stored favicon is found.
70088:         this._favicon = gFaviconService.getFaviconImageForPage(this.httpsURI).spec;
70088:       }
70088:     }
70088:     return this._favicon;
70088:   },
70088: 
70088:   /**
70088:    * Gets the number of history visits for the site.
70088:    *
70088:    * @param aCallback
70088:    *        A function that takes the visit count (a number) as a parameter.
70088:    */
70088:   getVisitCount: function Site_getVisitCount(aCallback) {
70088:     let rev_host = this.host.split("").reverse().join("") + ".";
70088:     gVisitStmt.params.rev_host = rev_host;
70088:     gVisitStmt.executeAsync({
70088:       handleResult: function(aResults) {
70088:         let row = aResults.getNextRow();
70088:         let count = row.getResultByName("count") || 0;
70088:         try {
70088:           aCallback(count);
70088:         } catch (e) {
70088:           Cu.reportError("AboutPermissions: " + e);
70088:         }
70088:       },
70088:       handleError: function(aError) {
70088:         Cu.reportError("AboutPermissions: " + aError);
70088:       },
70088:       handleCompletion: function(aReason) {
70088:       }
70088:     });
70088:   },
70088: 
70088:   /**
70088:    * Gets the permission value stored for a specified permission type.
70088:    *
70088:    * @param aType
70088:    *        The permission type string stored in permission manager.
70088:    *        e.g. "cookie", "geo", "indexedDB", "popup", "image"
70088:    * @param aResultObj
70088:    *        An object that stores the permission value set for aType.
70088:    *
70088:    * @return A boolean indicating whether or not a permission is set.
70088:    */
70088:   getPermission: function Site_getPermission(aType, aResultObj) {
70088:     let permissionValue;
70088:     if (TEST_EXACT_PERM_TYPES.indexOf(aType) == -1) {
70088:       permissionValue = Services.perms.testPermission(this.httpURI, aType);
70088:     } else {
70088:       permissionValue = Services.perms.testExactPermission(this.httpURI, aType);
70088:     }
70088:     aResultObj.value = permissionValue;
70088: 
70088:     return permissionValue != Ci.nsIPermissionManager.UNKNOWN_ACTION;
70088:   },
70088: 
70088:   /**
70088:    * Sets a permission for the site given a permission type and value.
70088:    *
70088:    * @param aType
70088:    *        The permission type string stored in permission manager.
70088:    *        e.g. "cookie", "geo", "indexedDB", "popup", "image"
70088:    * @param aPerm
70088:    *        The permission value to set for the permission type. This should
70088:    *        be one of the constants defined in nsIPermissionManager.
70088:    */
70088:   setPermission: function Site_setPermission(aType, aPerm) {
70088:     // Using httpURI is kind of bogus, but the permission manager stores the
70088:     // permission for the host, so the right thing happens in the end.
70088:     Services.perms.add(this.httpURI, aType, aPerm);
70088:   },
70088: 
70088:   /**
70088:    * Clears a user-set permission value for the site given a permission type.
70088:    *
70088:    * @param aType
70088:    *        The permission type string stored in permission manager.
70088:    *        e.g. "cookie", "geo", "indexedDB", "popup", "image"
70088:    */
70088:   clearPermission: function Site_clearPermission(aType) {
70088:     Services.perms.remove(this.host, aType);
70088:   },
70088: 
70088:   /**
70088:    * Gets cookies stored for the site. This does not return cookies stored
70088:    * for the base domain, only the exact hostname stored for the site.
70088:    *
70088:    * @return An array of the cookies set for the site.
70088:    */
70088:   get cookies() {
70088:     let cookies = [];
70088:     let enumerator = Services.cookies.getCookiesFromHost(this.host);
70088:     while (enumerator.hasMoreElements()) {
70088:       let cookie = enumerator.getNext().QueryInterface(Ci.nsICookie2);
70088:       // getCookiesFromHost returns cookies for base domain, but we only want
70088:       // the cookies for the exact domain.
70088:       if (cookie.rawHost == this.host) {
70088:         cookies.push(cookie);
70088:       }
70088:     }
70088:     return cookies;
70088:   },
70088: 
70088:   /**
70088:    * Removes a set of specific cookies from the browser.
70088:    */
70088:   clearCookies: function Site_clearCookies() {
70088:     this.cookies.forEach(function(aCookie) {
70088:       Services.cookies.remove(aCookie.host, aCookie.name, aCookie.path, false);
70088:     });
70088:   },
70088: 
70088:   /**
70088:    * Gets logins stored for the site.
70088:    *
70088:    * @return An array of the logins stored for the site.
70088:    */
70088:   get logins() {
70088:     // There could be more logins for different schemes/ports, but this covers
70088:     // the vast majority of cases.
70088:     let httpLogins = Services.logins.findLogins({}, this.httpURI.prePath, "", null);
70088:     let httpsLogins = Services.logins.findLogins({}, this.httpsURI.prePath, "", null);
70088:     return httpLogins.concat(httpsLogins);
70088:   },
70088: 
70088:   get loginSavingEnabled() {
70088:     // Only say that login saving is blocked if it is blocked for both http and https.
70088:     return Services.logins.getLoginSavingEnabled(this.httpURI.prePath) &&
70088:            Services.logins.getLoginSavingEnabled(this.httpsURI.prePath);
70088:   },
70088: 
70088:   set loginSavingEnabled(isEnabled) {
70088:     Services.logins.setLoginSavingEnabled(this.httpURI.prePath, isEnabled);
70088:     Services.logins.setLoginSavingEnabled(this.httpsURI.prePath, isEnabled);
70088:   },
70088: 
70088:   /**
70088:    * Removes all data from the browser corresponding to the site.
70088:    */
70088:   forgetSite: function Site_forgetSite() {
70088:     let pb = Cc["@mozilla.org/privatebrowsing;1"].
70088:              getService(Ci.nsIPrivateBrowsingService);
70088:     pb.removeDataFromDomain(this.host);
70088:   }
70088: }
70088: 
70088: /**
70088:  * PermissionDefaults object keeps track of default permissions for sites based
70088:  * on global preferences.
70088:  *
70088:  * Inspired by pageinfo/permissions.js
70088:  */
70088: let PermissionDefaults = {
70088:   UNKNOWN: Ci.nsIPermissionManager.UNKNOWN_ACTION, // 0
70088:   ALLOW: Ci.nsIPermissionManager.ALLOW_ACTION, // 1
70088:   DENY: Ci.nsIPermissionManager.DENY_ACTION, // 2
70088:   SESSION: Ci.nsICookiePermission.ACCESS_SESSION, // 8
70088: 
70088:   get password() {
70088:     if (Services.prefs.getBoolPref("signon.rememberSignons")) {
70088:       return this.ALLOW;
70088:     }
70088:     return this.DENY;
70088:   },
70088:   set password(aValue) {
70489:     let value = (aValue != this.DENY);
70088:     Services.prefs.setBoolPref("signon.rememberSignons", value);
70088:   },
70088: 
70088:   // For use with network.cookie.* prefs.
70088:   COOKIE_ACCEPT: 0,
70088:   COOKIE_DENY: 2,
70088:   COOKIE_NORMAL: 0,
70088:   COOKIE_SESSION: 2,
70088: 
70088:   get cookie() {
70088:     if (Services.prefs.getIntPref("network.cookie.cookieBehavior") == this.COOKIE_DENY) {
70088:       return this.DENY;
70088:     }
70088: 
70489:     if (Services.prefs.getIntPref("network.cookie.lifetimePolicy") == this.COOKIE_SESSION) {
70088:       return this.SESSION;
70088:     }
70088:     return this.ALLOW;
70088:   },
70088:   set cookie(aValue) {
70088:     let value = (aValue == this.DENY) ? this.COOKIE_DENY : this.COOKIE_ACCEPT;
70088:     Services.prefs.setIntPref("network.cookie.cookieBehavior", value);
70088: 
70088:     let lifetimeValue = aValue == this.SESSION ? this.COOKIE_SESSION :
70088:                                                  this.COOKIE_NORMAL;
70088:     Services.prefs.setIntPref("network.cookie.lifetimePolicy", lifetimeValue);
70088:   },
70088: 
70088:   get geo() {
70088:     if (!Services.prefs.getBoolPref("geo.enabled")) {
70088:       return this.DENY;
70088:     }
70088:     // We always ask for permission to share location with a specific site, so
70088:     // there is no global ALLOW.
70088:     return this.UNKNOWN;
70088:   },
70088:   set geo(aValue) {
70489:     let value = (aValue != this.DENY);
70088:     Services.prefs.setBoolPref("geo.enabled", value);
70088:   },
70088: 
70088:   get indexedDB() {
70088:     if (!Services.prefs.getBoolPref("dom.indexedDB.enabled")) {
70088:       return this.DENY;
70088:     }
70088:     // We always ask for permission to enable indexedDB storage for a specific
70088:     // site, so there is no global ALLOW.
70088:     return this.UNKNOWN;
70088:   },
70088:   set indexedDB(aValue) {
70489:     let value = (aValue != this.DENY);
70088:     Services.prefs.setBoolPref("dom.indexedDB.enabled", value);
70088:   },
70088: 
70088:   get popup() {
70088:     if (Services.prefs.getBoolPref("dom.disable_open_during_load")) {
70088:       return this.DENY;
70088:     }
70088:     return this.ALLOW;
70088:   },
70088:   set popup(aValue) {
70088:     let value = (aValue == this.DENY);
70088:     Services.prefs.setBoolPref("dom.disable_open_during_load", value);
70088:   }
70088: }
70088: 
70088: /**
70088:  * AboutPermissions manages the about:permissions page.
70088:  */
70088: let AboutPermissions = {
70088:   /**
70088:    * Number of sites to return from the places database.
70088:    */  
70088:   PLACES_SITES_LIMIT: 50,
70088: 
70088:   /**
70088:    * Stores a mapping of host strings to Site objects.
70088:    */
70088:   _sites: {},
70088: 
70088:   sitesList: null,
70088:   _selectedSite: null,
70088: 
70088:   /**
70088:    * This reflects the permissions that we expose in the UI. These correspond
70088:    * to permission type strings in the permission manager, PermissionDefaults,
70088:    * and element ids in aboutPermissions.xul.
70088:    *
70088:    * Potential future additions: "sts/use", "sts/subd"
70088:    */
70088:   _supportedPermissions: ["password", "cookie", "geo", "indexedDB", "popup"],
70088: 
70088:   /**
70088:    * Permissions that don't have a global "Allow" option.
70088:    */
70088:   _noGlobalAllow: ["geo", "indexedDB"],
70088: 
70088:   _stringBundle: Services.strings.
70088:                  createBundle("chrome://browser/locale/preferences/aboutPermissions.properties"),
70088: 
70088:   /**
70088:    * Called on page load.
70088:    */
70088:   init: function() {
70088:     this.sitesList = document.getElementById("sites-list");
70088: 
70088:     this.getSitesFromPlaces();
70088:     this.enumerateServices();
70088: 
70088:     // Attach observers in case data changes while the page is open.
70088:     Services.prefs.addObserver("signon.rememberSignons", this, false);
70088:     Services.prefs.addObserver("network.cookie.", this, false);
70088:     Services.prefs.addObserver("geo.enabled", this, false);
70088:     Services.prefs.addObserver("dom.indexedDB.enabled", this, false);
70088:     Services.prefs.addObserver("dom.disable_open_during_load", this, false);
70088: 
70088:     Services.obs.addObserver(this, "perm-changed", false);
70088:     Services.obs.addObserver(this, "passwordmgr-storage-changed", false);
70088:     Services.obs.addObserver(this, "cookie-changed", false);
70088:     Services.obs.addObserver(this, "browser:purge-domain-data", false);
70088:     
70088:     this._observersInitialized = true;
70088:   },
70088: 
70088:   /**
70088:    * Called on page unload.
70088:    */
70088:   cleanUp: function() {
70088:     if (this._observersInitialized) {
70088:       Services.prefs.removeObserver("signon.rememberSignons", this, false);
70088:       Services.prefs.removeObserver("network.cookie.", this, false);
70088:       Services.prefs.removeObserver("geo.enabled", this, false);
70088:       Services.prefs.removeObserver("dom.indexedDB.enabled", this, false);
70088:       Services.prefs.removeObserver("dom.disable_open_during_load", this, false);
70088: 
70088:       Services.obs.removeObserver(this, "perm-changed", false);
70088:       Services.obs.removeObserver(this, "passwordmgr-storage-changed", false);
70088:       Services.obs.removeObserver(this, "cookie-changed", false);
70088:       Services.obs.removeObserver(this, "browser:purge-domain-data", false);
70088:     }
70088: 
70088:     gSitesStmt.finalize();
70088:     gVisitStmt.finalize();
70521:     gPlacesDatabase.asyncClose(null);
70088:   },
70088: 
70088:   observe: function (aSubject, aTopic, aData) {
70088:     switch(aTopic) {
70088:       case "perm-changed":
70088:         // Permissions changes only affect individual sites.
70088:         if (!this._selectedSite) {
70088:           break;
70088:         }
70088:         // aSubject is null when nsIPermisionManager::removeAll() is called.
70088:         if (!aSubject) {
70088:           this._supportedPermissions.forEach(function(aType){
70088:             this.updatePermission(aType);
70088:           }, this);
70088:           break;
70088:         }
70088:         let permission = aSubject.QueryInterface(Ci.nsIPermission);
70088:         // We can't compare selectedSite.host and permission.host here because
70088:         // we need to handle the case where a parent domain was changed in a
70088:         // way that affects the subdomain.
70088:         if (this._supportedPermissions.indexOf(permission.type) != -1) {
70088:           this.updatePermission(permission.type);
70088:         }
70088:         break;
70088:       case "nsPref:changed":
70088:         this._supportedPermissions.forEach(function(aType){
70088:           this.updatePermission(aType);
70088:         }, this);
70088:         break;
70088:       case "passwordmgr-storage-changed":
70088:         this.updatePermission("password");
70088:         if (this._selectedSite) {
70088:           this.updatePasswordsCount();
70088:         }
70088:         break;
70088:       case "cookie-changed":
70088:         if (this._selectedSite) {
70088:           this.updateCookiesCount();
70088:         }
70088:         break;
70088:       case "browser:purge-domain-data":
70088:         this.deleteFromSitesList(aData);
70088:         break;
70088:     }
70088:   },
70088: 
70088:   /**
70088:    * Creates Site objects for the top-frecency sites in the places database and stores
70088:    * them in _sites. The number of sites created is controlled by PLACES_SITES_LIMIT.
70088:    */
70088:   getSitesFromPlaces: function() {
70088:     gSitesStmt.params.limit = this.PLACES_SITES_LIMIT;
70088:     gSitesStmt.executeAsync({
70088:       handleResult: function(aResults) {
70088:         let row;
70088:         while (row = aResults.getNextRow()) {
70088:           let host = row.getResultByName("host");
70088:           AboutPermissions.addHost(host);
70088:         }
70088:       },
70088:       handleError: function(aError) {
70088:         Cu.reportError("AboutPermissions: " + aError);
70088:       },
70088:       handleCompletion: function(aReason) {
70088:         // Notify oberservers for testing purposes.
70088:         Services.obs.notifyObservers(null, "browser-permissions-initialized", null);
70088:       }
70088:     });
70088:   },
70088: 
70088:   /**
70088:    * Finds sites that have non-default permissions and creates Site objects for
70088:    * them if they are not already stored in _sites.
70088:    */
70088:   enumerateServices: function() {
70088:     let logins = Services.logins.getAllLogins();
70088:     logins.forEach(function(aLogin) {
70088:       try {
70088:         // aLogin.hostname is a string in origin URL format (e.g. "http://foo.com")
70088:         let uri = NetUtil.newURI(aLogin.hostname);
70088:         this.addHost(uri.host);
70088:       } catch (e) {
70088:         // newURI will throw for add-ons logins stored in chrome:// URIs 
70088:       }
70088:     }, this);
70088: 
70088:     let disabledHosts = Services.logins.getAllDisabledHosts();
70088:     disabledHosts.forEach(function(aHostname) {
70088:       try {
70088:         // aHostname is a string in origin URL format (e.g. "http://foo.com")
70088:         let uri = NetUtil.newURI(aHostname);
70088:         this.addHost(uri.host);
70088:       } catch (e) {
70088:         // newURI will throw for add-ons logins stored in chrome:// URIs 
70088:       }
70088:     }, this);
70088: 
70088:     let (enumerator = Services.perms.enumerator) {
70088:       while (enumerator.hasMoreElements()) {
70088:         let permission = enumerator.getNext().QueryInterface(Ci.nsIPermission);
70088:         // Only include sites with exceptions set for supported permission types.
70088:         if (this._supportedPermissions.indexOf(permission.type) != -1) {
70088:           this.addHost(permission.host);
70088:         }
70088:       }
70088:     }
70088:   },
70088: 
70088:   /**
70088:    * Creates a new Site and adds it to _sites if it's not already there.
70088:    *
70088:    * @param aHost
70088:    *        A host string.
70088:    */
70088:   addHost: function(aHost) {
70088:     if (aHost in this._sites) {
70088:       return;
70088:     }
70088:     let site = new Site(aHost);
70088:     this._sites[aHost] = site;
70088:     this.addToSitesList(site);
70088:   },
70088: 
70088:   /**
70088:    * Populates sites-list richlistbox with data from Site object.
70088:    *
70088:    * @param aSite
70088:    *        A Site object.
70088:    */
70088:   addToSitesList: function(aSite) {
70088:     let item = document.createElement("richlistitem");
70088:     item.setAttribute("class", "site");
70088:     item.setAttribute("value", aSite.host);
70088:     item.setAttribute("favicon", aSite.favicon);
70088:     aSite.listitem = item;
70088: 
70088:     this.sitesList.appendChild(item);    
70088:   },
70088: 
70088:   /**
70088:    * Hides sites in richlistbox based on search text in sites-filter textbox.
70088:    */
70088:   filterSitesList: function() {
70088:     let siteItems = this.sitesList.children;
70088:     let filterValue = document.getElementById("sites-filter").value.toLowerCase();
70088: 
70088:     if (filterValue == "") {
70088:       for (let i = 0; i < siteItems.length; i++) {
70088:         siteItems[i].collapsed = false;
70088:       }
70088:       return;
70088:     }
70088: 
70088:     for (let i = 0; i < siteItems.length; i++) {
70088:       let siteValue = siteItems[i].value.toLowerCase();
70088:       siteItems[i].collapsed = siteValue.indexOf(filterValue) == -1;
70088:     }
70088:   },
70088: 
70088:   /**
70088:    * Removes all evidence of the selected site. The "forget this site" observer
70088:    * will call deleteFromSitesList to update the UI.
70088:    */
70088:   forgetSite: function() {
70088:     this._selectedSite.forgetSite();
70088:   },
70088: 
70088:   /**
70088:    * Deletes sites for a host and all of its sub-domains. Removes these sites
70088:    * from _sites and removes their corresponding elements from the DOM.
70088:    *
70088:    * @param aHost
70088:    *        The host string corresponding to the site to delete.
70088:    */
70088:   deleteFromSitesList: function(aHost) {
70088:     for each (let site in this._sites) {
70088:       if (site.host.hasRootDomain(aHost)) {
70088:         if (site == this._selectedSite) {
70193:           // Replace site-specific interface with "All Sites" interface.
70193:           this.sitesList.selectedItem = document.getElementById("all-sites-item");
70088:         }
70088: 
70088:         this.sitesList.removeChild(site.listitem);
70088:         delete this._sites[site.host];
70088:       }
70088:     }    
70088:   },
70088: 
70088:   /**
70088:    * Shows interface for managing site-specific permissions.
70088:    */
70088:   onSitesListSelect: function(event) {
70088:     if (event.target.selectedItem.id == "all-sites-item") {
70193:       // Clear the header label value from the previously selected site.
70193:       document.getElementById("site-label").value = "";
70088:       this.manageDefaultPermissions();
70088:       return;
70088:     }
70088: 
70088:     let host = event.target.value;
70088:     let site = this._selectedSite = this._sites[host];
70088:     document.getElementById("site-label").value = host;
70088:     document.getElementById("header-deck").selectedPanel =
70088:       document.getElementById("site-header");
70088: 
70088:     this.updateVisitCount();
70088:     this.updatePermissionsBox();
70088:   },
70088: 
70088:   /**
70088:    * Shows interface for managing default permissions. This corresponds to
70088:    * the "All Sites" list item.
70088:    */
70088:   manageDefaultPermissions: function() {
70088:     this._selectedSite = null;
70088: 
70088:     document.getElementById("header-deck").selectedPanel =
70088:       document.getElementById("defaults-header");
70088: 
70088:     this.updatePermissionsBox();
70088:   },
70088: 
70088:   /**
70088:    * Updates permissions interface based on selected site.
70088:    */
70088:   updatePermissionsBox: function() {
70088:     this._supportedPermissions.forEach(function(aType){
70088:       this.updatePermission(aType);
70088:     }, this);
70088: 
70088:     this.updatePasswordsCount();
70088:     this.updateCookiesCount();
70088:   },
70088: 
70088:   /**
70088:    * Sets menulist for a given permission to the correct state, based on the
70088:    * stored permission.
70088:    *
70088:    * @param aType
70088:    *        The permission type string stored in permission manager.
70088:    *        e.g. "cookie", "geo", "indexedDB", "popup", "image"
70088:    */
70088:   updatePermission: function(aType) {
70088:     let allowItem = document.getElementById(aType + "-" + PermissionDefaults.ALLOW);
70088:     if (!this._selectedSite &&
70088:         this._noGlobalAllow.indexOf(aType) != -1) {
70088:       allowItem.hidden = true;
70088:       return;
70088:     }
70088: 
70088:     allowItem.hidden = false;
70088: 
70088:     let permissionMenulist = document.getElementById(aType + "-menulist");
70088:     let permissionValue;    
70088:     if (!this._selectedSite) {
70088: 
70088:       // If there is no selected site, we are updating the default permissions interface.
70088:       permissionValue = PermissionDefaults[aType];
70088:     } else if (aType == "password") {
70088:       // Services.logins.getLoginSavingEnabled already looks at the default
70088:       // permission, so we don't need to.
70088:       permissionValue = this._selectedSite.loginSavingEnabled ?
70088:                         PermissionDefaults.ALLOW : PermissionDefaults.DENY;
70088:     } else {
70088:       let result = {};
70088:       permissionValue = this._selectedSite.getPermission(aType, result) ?
70088:                         result.value : PermissionDefaults[aType];
70088:     }
70088: 
70088:     permissionMenulist.selectedItem = document.getElementById(aType + "-" + permissionValue);
70088:   },
70088: 
70088:   onPermissionCommand: function(event) {
70088:     let permissionType = event.currentTarget.getAttribute("type");
70088:     let permissionValue = event.target.value;
70088: 
70088:     if (!this._selectedSite) {
70088:       // If there is no selected site, we are setting the default permission.
70088:       PermissionDefaults[permissionType] = permissionValue;
70088:     } else if (permissionType == "password") {
70088:       let isEnabled = permissionValue == PermissionDefaults.ALLOW;
70088:       this._selectedSite.loginSavingEnabled = isEnabled;
70088:     } else {
70088:       this._selectedSite.setPermission(permissionType, permissionValue);
70088:     }
70088:   },
70088: 
70088:   updateVisitCount: function() {
70088:     this._selectedSite.getVisitCount(function(aCount) {
70088:       let visitForm = AboutPermissions._stringBundle.GetStringFromName("visitCount");
70088:       let visitLabel = PluralForm.get(aCount, visitForm)
70088:                                   .replace("#1", aCount);
70088:       document.getElementById("site-visit-count").value = visitLabel;
70088:     });  
70088:   },
70088: 
70088:   updatePasswordsCount: function() {
70088:     if (!this._selectedSite) {
70088:       document.getElementById("passwords-count").hidden = true;
70088:       document.getElementById("passwords-manage-all-button").hidden = false;
70088:       return;
70088:     }
70088: 
70088:     let passwordsCount = this._selectedSite.logins.length;
70088:     let passwordsForm = this._stringBundle.GetStringFromName("passwordsCount");
70088:     let passwordsLabel = PluralForm.get(passwordsCount, passwordsForm)
70088:                                    .replace("#1", passwordsCount);
70088: 
70088:     document.getElementById("passwords-label").value = passwordsLabel;
70088:     document.getElementById("passwords-manage-button").disabled = (passwordsCount < 1);
70088:     document.getElementById("passwords-manage-all-button").hidden = true;
70088:     document.getElementById("passwords-count").hidden = false;
70088:   },
70088: 
70088:   /**
70088:    * Opens password manager dialog.
70088:    */
70088:   managePasswords: function() {
70088:     let selectedHost = "";
70088:     if (this._selectedSite) {
70088:       selectedHost = this._selectedSite.host;
70088:     }
70088: 
70088:     let win = Services.wm.getMostRecentWindow("Toolkit:PasswordManager");
70088:     if (win) {
70088:       win.setFilter(selectedHost);
70088:       win.focus();
70088:     } else {
70088:       window.openDialog("chrome://passwordmgr/content/passwordManager.xul",
70088:                         "Toolkit:PasswordManager", "", {filterString : selectedHost});
70088:     }
70088:   },
70088: 
70088:   updateCookiesCount: function() {
70088:     if (!this._selectedSite) {
70088:       document.getElementById("cookies-count").hidden = true;
70088:       document.getElementById("cookies-clear-all-button").hidden = false;
70088:       document.getElementById("cookies-manage-all-button").hidden = false;
70088:       return;
70088:     }
70088: 
70088:     let cookiesCount = this._selectedSite.cookies.length;
70088:     let cookiesForm = this._stringBundle.GetStringFromName("cookiesCount");
70088:     let cookiesLabel = PluralForm.get(cookiesCount, cookiesForm)
70088:                                  .replace("#1", cookiesCount);
70088: 
70088:     document.getElementById("cookies-label").value = cookiesLabel;
70088:     document.getElementById("cookies-clear-button").disabled = (cookiesCount < 1);
70088:     document.getElementById("cookies-manage-button").disabled = (cookiesCount < 1);
70088:     document.getElementById("cookies-clear-all-button").hidden = true;
70088:     document.getElementById("cookies-manage-all-button").hidden = true;
70088:     document.getElementById("cookies-count").hidden = false;
70088:   },
70088: 
70088:   /**
70088:    * Clears cookies for the selected site.
70088:    */
70088:   clearCookies: function() {
70088:     if (!this._selectedSite) {
70088:       return;
70088:     }
70088:     let site = this._selectedSite;
70088:     site.clearCookies(site.cookies);
70088:     this.updateCookiesCount();
70088:   },
70088: 
70088:   /**
70088:    * Opens cookie manager dialog.
70088:    */
70088:   manageCookies: function() {
70088:     let selectedHost = "";
70088:     if (this._selectedSite) {
70088:       selectedHost = this._selectedSite.host;
70088:     }
70088: 
70088:     let win = Services.wm.getMostRecentWindow("Browser:Cookies");
70088:     if (win) {
70088:       win.gCookiesWindow.setFilter(selectedHost);
70088:       win.focus();
70088:     } else {
70088:       window.openDialog("chrome://browser/content/preferences/cookies.xul",
70088:                         "Browser:Cookies", "", {filterString : selectedHost});
70088:     }
70088:   }
70088: }
70088: 
70088: // See nsPrivateBrowsingService.js
70088: String.prototype.hasRootDomain = function hasRootDomain(aDomain) {
70088:   let index = this.indexOf(aDomain);
70088:   if (index == -1)
70088:     return false;
70088: 
70088:   if (this == aDomain)
70088:     return true;
70088: 
70088:   let prevChar = this[index - 1];
70088:   return (index == (this.length - aDomain.length)) &&
70088:          (prevChar == "." || prevChar == "/");
70088: }
