    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * nsBaseContentList is a basic list of content nodes; nsContentList
    1:  * is a commonly used NodeList implementation (used for
    1:  * getElementsByTagName, some properties on nsIDOMHTMLDocument, etc).
    1:  */
    1: 
    1: #ifndef nsContentList_h___
    1: #define nsContentList_h___
    1: 
    1: #include "nsISupports.h"
81138: #include "nsTArray.h"
    1: #include "nsString.h"
21159: #include "nsIHTMLCollection.h"
    1: #include "nsIDOMNodeList.h"
19130: #include "nsINodeList.h"
    1: #include "nsStubMutationObserver.h"
    1: #include "nsIAtom.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsCycleCollectionParticipant.h"
21618: #include "nsWrapperCache.h"
74131: #include "nsHashKeys.h"
92143: #include "mozilla/HashFunctions.h"
    1: 
    1: // Magic namespace id that means "match all namespaces".  This is
    1: // negative so it won't collide with actual namespace constants.
    1: #define kNameSpaceID_Wildcard PR_INT32_MIN
    1: 
    1: // This is a callback function type that can be used to implement an
    1: // arbitrary matching algorithm.  aContent is the content that may
    1: // match the list, while aNamespaceID, aAtom, and aData are whatever
    1: // was passed to the list's constructor.
79445: typedef bool (*nsContentListMatchFunc)(nsIContent* aContent,
    1:                                          PRInt32 aNamespaceID,
    1:                                          nsIAtom* aAtom,
    1:                                          void* aData);
    1: 
    1: typedef void (*nsContentListDestroyFunc)(void* aData);
    1: 
    1: class nsIDocument;
74131: namespace mozilla {
74131: namespace dom {
74131: class Element;
74131: }
74131: }
    1: 
    1: 
20752: class nsBaseContentList : public nsINodeList
    1: {
    1: public:
80075:   nsBaseContentList()
80075:   {
93879:     SetIsDOMBinding();
80075:   }
    1:   virtual ~nsBaseContentList();
    1: 
    1:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
    1: 
    1:   // nsIDOMNodeList
    1:   NS_DECL_NSIDOMNODELIST
19130: 
19130:   // nsINodeList
24403:   virtual PRInt32 IndexOf(nsIContent* aContent);
19130:   
30639:   PRUint32 Length() const { 
81138:     return mElements.Length();
30639:   }
30639: 
89872:   NS_DECL_CYCLE_COLLECTION_SKIPPABLE_SCRIPT_HOLDER_CLASS(nsBaseContentList)
    1: 
81138:   void AppendElement(nsIContent *aContent)
81138:   {
96415:     NS_ASSERTION(aContent, "Element to append must not be null");
81138:     mElements.AppendElement(aContent);
81138:   }
38069:   void MaybeAppendElement(nsIContent* aContent)
38069:   {
38069:     if (aContent)
38069:       AppendElement(aContent);
38069:   }
30639: 
30639:   /**
30639:    * Insert the element at a given index, shifting the objects at
30639:    * the given index and later to make space.
30639:    * @param aContent Element to insert, must not be null
30639:    * @param aIndex Index to insert the element at.
30639:    */
81138:   void InsertElementAt(nsIContent* aContent, PRInt32 aIndex)
81138:   {
81138:     NS_ASSERTION(aContent, "Element to insert must not be null");
81138:     mElements.InsertElementAt(aIndex, aContent);
81138:   }
30639: 
81138:   void RemoveElement(nsIContent *aContent)
81138:   {
81138:     mElements.RemoveElement(aContent);
81138:   }
30639: 
30639:   void Reset() {
30639:     mElements.Clear();
30639:   }
30639: 
80075:   virtual PRInt32 IndexOf(nsIContent *aContent, bool aDoFlush);
30639: 
93129:   virtual JSObject* WrapObject(JSContext *cx, JSObject *scope,
80085:                                bool *triedToWrap) = 0;
    1: 
    1: protected:
81138:   nsTArray< nsCOMPtr<nsIContent> > mElements;
    1: };
    1: 
    1: 
69024: class nsSimpleContentList : public nsBaseContentList
69024: {
69024: public:
69024:   nsSimpleContentList(nsINode *aRoot) : nsBaseContentList(),
69024:                                         mRoot(aRoot)
69024:   {
69024:   }
69024: 
69024:   NS_DECL_ISUPPORTS_INHERITED
69024:   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsSimpleContentList,
69024:                                            nsBaseContentList)
69024: 
69024:   virtual nsINode* GetParentObject()
69024:   {
69024:     return mRoot;
69024:   }
93129:   virtual JSObject* WrapObject(JSContext *cx, JSObject *scope,
80085:                                bool *triedToWrap);
69024: 
69024: private:
69024:   // This has to be a strong reference, the root might go away before the list.
69024:   nsCOMPtr<nsINode> mRoot;
69024: };
69024: 
    1: // This class is used only by form element code and this is a static
    1: // list of elements. NOTE! This list holds strong references to
    1: // the elements in the list.
69024: class nsFormContentList : public nsSimpleContentList
    1: {
    1: public:
69024:   nsFormContentList(nsIContent *aForm,
    1:                     nsBaseContentList& aContentList);
    1: };
    1: 
    1: /**
    1:  * Class that's used as the key to hash nsContentList implementations
    1:  * for fast retrieval
    1:  */
63637: struct nsContentListKey
    1: {
    1:   nsContentListKey(nsINode* aRootNode,
63637:                    PRInt32 aMatchNameSpaceId,
63637:                    const nsAString& aTagname)
63637:     : mRootNode(aRootNode),
    1:       mMatchNameSpaceId(aMatchNameSpaceId),
63637:       mTagname(aTagname)
    1:   {
    1:   }
    1: 
    1:   nsContentListKey(const nsContentListKey& aContentListKey)
63637:     : mRootNode(aContentListKey.mRootNode),
    1:       mMatchNameSpaceId(aContentListKey.mMatchNameSpaceId),
63637:       mTagname(aContentListKey.mTagname)
    1:   {
    1:   }
    1: 
    1:   inline PRUint32 GetHash(void) const
    1:   {
92143:     PRUint32 hash = mozilla::HashString(mTagname);
92143:     return mozilla::AddToHash(hash, mRootNode, mMatchNameSpaceId);
    1:   }
    1:   
63637:   nsINode* const mRootNode; // Weak ref
63637:   const PRInt32 mMatchNameSpaceId;
63637:   const nsAString& mTagname;
    1: };
    1: 
    1: /**
    1:  * LIST_UP_TO_DATE means that the list is up to date and need not do
    1:  * any walking to be able to answer any questions anyone may have.
    1:  */
    1: #define LIST_UP_TO_DATE 0
    1: /**
    1:  * LIST_DIRTY means that the list contains no useful information and
    1:  * if anyone asks it anything it will have to populate itself before
    1:  * answering.
    1:  */
    1: #define LIST_DIRTY 1
    1: /**
    1:  * LIST_LAZY means that the list has populated itself to a certain
    1:  * extent and that that part of the list is still valid.  Requests for
    1:  * things outside that part of the list will require walking the tree
    1:  * some more.  When a list is in this state, the last thing in
    1:  * mElements is the last node in the tree that the list looked at.
    1:  */
    1: #define LIST_LAZY 2
    1: 
    1: /**
19198:  * Class that implements a live NodeList that matches Elements in the
19198:  * tree based on some criterion.
    1:  */
    1: class nsContentList : public nsBaseContentList,
21159:                       public nsIHTMLCollection,
69024:                       public nsStubMutationObserver
    1: {
    1: public:
    1:   NS_DECL_ISUPPORTS_INHERITED
    1: 
    1:   /**
    1:    * @param aRootNode The node under which to limit our search.
    1:    * @param aMatchAtom An atom whose meaning depends on aMatchNameSpaceId.
    1:    *                   The special value "*" always matches whatever aMatchAtom
    1:    *                   is matched against.
    1:    * @param aMatchNameSpaceId If kNameSpaceID_Unknown, then aMatchAtom is the
    1:    *                          tagName to match.
    1:    *                          If kNameSpaceID_Wildcard, then aMatchAtom is the
    1:    *                          localName to match.
    1:    *                          Otherwise we match nodes whose namespace is
    1:    *                          aMatchNameSpaceId and localName matches
    1:    *                          aMatchAtom.
    1:    * @param aDeep If false, then look only at children of the root, nothing
    1:    *              deeper.  If true, then look at the whole subtree rooted at
    1:    *              our root.
    1:    */  
    1:   nsContentList(nsINode* aRootNode,
    1:                 PRInt32 aMatchNameSpaceId,
53966:                 nsIAtom* aHTMLMatchAtom,
53966:                 nsIAtom* aXMLMatchAtom,
79445:                 bool aDeep = true);
    1: 
    1:   /**
    1:    * @param aRootNode The node under which to limit our search.
19198:    * @param aFunc the function to be called to determine whether we match.
19198:    *              This function MUST NOT ever cause mutation of the DOM.
19198:    *              The nsContentList implementation guarantees that everything
41633:    *              passed to the function will be IsElement().
    1:    * @param aDestroyFunc the function that will be called to destroy aData
    1:    * @param aData closure data that will need to be passed back to aFunc
    1:    * @param aDeep If false, then look only at children of the root, nothing
    1:    *              deeper.  If true, then look at the whole subtree rooted at
    1:    *              our root.
    1:    * @param aMatchAtom an atom to be passed back to aFunc
    1:    * @param aMatchNameSpaceId a namespace id to be passed back to aFunc
    1:    * @param aFuncMayDependOnAttr a boolean that indicates whether this list is
    1:    *                             sensitive to attribute changes.
    1:    */  
    1:   nsContentList(nsINode* aRootNode,
    1:                 nsContentListMatchFunc aFunc,
    1:                 nsContentListDestroyFunc aDestroyFunc,
    1:                 void* aData,
79445:                 bool aDeep = true,
    1:                 nsIAtom* aMatchAtom = nsnull,
    1:                 PRInt32 aMatchNameSpaceId = kNameSpaceID_None,
79445:                 bool aFuncMayDependOnAttr = true);
    1:   virtual ~nsContentList();
    1: 
80067:   // nsWrapperCache
93129:   virtual JSObject* WrapObject(JSContext *cx, JSObject *scope,
80085:                                bool *triedToWrap);
80067: 
    1:   // nsIDOMHTMLCollection
    1:   NS_DECL_NSIDOMHTMLCOLLECTION
    1: 
    1:   // nsBaseContentList overrides
79445:   virtual PRInt32 IndexOf(nsIContent *aContent, bool aDoFlush);
24403:   virtual PRInt32 IndexOf(nsIContent* aContent);
69024:   virtual nsINode* GetParentObject()
69024:   {
69024:     return mRootNode;
69024:   }
19130: 
    1:   // nsContentList public methods
79445:   NS_HIDDEN_(PRUint32) Length(bool aDoFlush);
79445:   NS_HIDDEN_(nsIContent*) Item(PRUint32 aIndex, bool aDoFlush);
79445:   NS_HIDDEN_(nsIContent*) NamedItem(const nsAString& aName, bool aDoFlush);
    1: 
    1:   // nsIMutationObserver
 3410:   NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTECHANGED
 3410:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
 3410:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
 3410:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
 3410:   NS_DECL_NSIMUTATIONOBSERVER_NODEWILLBEDESTROYED
    1:   
20752:   static nsContentList* FromSupports(nsISupports* aSupports)
20752:   {
20752:     nsINodeList* list = static_cast<nsINodeList*>(aSupports);
20752: #ifdef DEBUG
20752:     {
20752:       nsCOMPtr<nsINodeList> list_qi = do_QueryInterface(aSupports);
20752: 
20752:       // If this assertion fires the QI implementation for the object in
20752:       // question doesn't use the nsINodeList pointer as the nsISupports
20752:       // pointer. That must be fixed, or we'll crash...
20752:       NS_ASSERTION(list_qi == list, "Uh, fix QI!");
20752:     }
20752: #endif
20752:     return static_cast<nsContentList*>(list);
20752:   }
20752: 
79445:   bool MatchesKey(const nsContentListKey& aKey) const
63637:   {
63637:     // The root node is most commonly the same: the document.  And the
63637:     // most common namespace id is kNameSpaceID_Unknown.  So check the
63637:     // string first.
63637:     NS_PRECONDITION(mXMLMatchAtom,
63637:                     "How did we get here with a null match atom on our list?");
63637:     return
63637:       mXMLMatchAtom->Equals(aKey.mTagname) &&
63637:       mRootNode == aKey.mRootNode &&
63637:       mMatchNameSpaceId == aKey.mMatchNameSpaceId;
63637:   }
63637: 
    1: protected:
    1:   /**
41633:    * Returns whether the element matches our criterion
    1:    *
41633:    * @param  aElement the element to attempt to match
    1:    * @return whether we match
    1:    */
79445:   bool Match(mozilla::dom::Element *aElement);
    1:   /**
42106:    * See if anything in the subtree rooted at aContent, including
42106:    * aContent itself, matches our criterion.
    1:    *
    1:    * @param  aContent the root of the subtree to match against
    1:    * @return whether we match something in the tree rooted at aContent
    1:    */
79445:   bool MatchSelf(nsIContent *aContent);
    1: 
    1:   /**
    1:    * Populate our list.  Stop once we have at least aNeededLength
    1:    * elements.  At the end of PopulateSelf running, either the last
    1:    * node we examined is the last node in our array or we have
    1:    * traversed the whole document (or both).
    1:    *
    1:    * @param aNeededLength the length the list should have when we are
    1:    *        done (unless it exhausts the document)   
    1:    */
    1:   void PopulateSelf(PRUint32 aNeededLength);
    1: 
    1:   /**
    1:    * @param  aContainer a content node which must be a descendant of
    1:    *         mRootNode
80486:    * @return true if children or descendants of aContainer could match our
    1:    *                 criterion.
80486:    *         false otherwise.
    1:    */
79445:   bool MayContainRelevantNodes(nsINode* aContainer)
    1:   {
    1:     return mDeep || aContainer == mRootNode;
    1:   }
    1: 
    1:   /**
    1:    * Remove ourselves from the hashtable that caches commonly accessed
    1:    * content lists.  Generally done on destruction.
    1:    */
    1:   void RemoveFromHashtable();
    1:   /**
    1:    * If state is not LIST_UP_TO_DATE, fully populate ourselves with
    1:    * all the nodes we can find.
    1:    */
79445:   inline void BringSelfUpToDate(bool aDoFlush);
    1: 
    1:   /**
    1:    * Sets the state to LIST_DIRTY and clears mElements array.
    1:    * @note This is the only acceptable way to set state to LIST_DIRTY.
    1:    */
    1:   void SetDirty()
    1:   {
    1:     mState = LIST_DIRTY;
    1:     Reset();
    1:   }
    1: 
    1:   /**
38013:    * To be called from non-destructor locations that want to remove from caches.
38013:    * Needed because if subclasses want to have cache behavior they can't just
38013:    * override RemoveFromHashtable(), since we call that in our destructor.
38013:    */
38013:   virtual void RemoveFromCaches() {
38013:     RemoveFromHashtable();
38013:   }
38013: 
63637:   nsINode* mRootNode; // Weak ref
63637:   PRInt32 mMatchNameSpaceId;
63637:   nsCOMPtr<nsIAtom> mHTMLMatchAtom;
63637:   nsCOMPtr<nsIAtom> mXMLMatchAtom;
63637: 
38013:   /**
    1:    * Function to use to determine whether a piece of content matches
    1:    * our criterion
    1:    */
    1:   nsContentListMatchFunc mFunc;
    1:   /**
    1:    * Cleanup closure data with this.
    1:    */
    1:   nsContentListDestroyFunc mDestroyFunc;
    1:   /**
    1:    * Closure data to pass to mFunc when we call it
    1:    */
    1:   void* mData;
    1:   /**
    1:    * The current state of the list (possible values are:
    1:    * LIST_UP_TO_DATE, LIST_LAZY, LIST_DIRTY
    1:    */
    1:   PRUint8 mState;
63638: 
63638:   // The booleans have to use PRUint8 to pack with mState, because MSVC won't
63638:   // pack different typedefs together.  Once we no longer have to worry about
79445:   // flushes in XML documents, we can go back to using bool for the
63638:   // booleans.
63638:   
63638:   /**
63638:    * True if we are looking for elements named "*"
63638:    */
63638:   PRUint8 mMatchAll : 1;
    1:   /**
    1:    * Whether to actually descend the tree.  If this is false, we won't
    1:    * consider grandkids of mRootNode.
    1:    */
63638:   PRUint8 mDeep : 1;
    1:   /**
    1:    * Whether the return value of mFunc could depend on the values of
    1:    * attributes.
    1:    */
63638:   PRUint8 mFuncMayDependOnAttr : 1;
63638:   /**
63638:    * Whether we actually need to flush to get our state correct.
63638:    */
63638:   PRUint8 mFlushesNeeded : 1;
    1: 
    1: #ifdef DEBUG_CONTENT_LIST
    1:   void AssertInSync();
    1: #endif
    1: };
    1: 
38013: /**
38013:  * A class of cacheable content list; cached on the combination of aRootNode + aFunc + aDataString
38013:  */
38013: class nsCacheableFuncStringContentList;
38013: 
38013: class NS_STACK_CLASS nsFuncStringCacheKey {
38013: public:
38013:   nsFuncStringCacheKey(nsINode* aRootNode,
38013:                        nsContentListMatchFunc aFunc,
38013:                        const nsAString& aString) :
38013:     mRootNode(aRootNode),
38013:     mFunc(aFunc),
38013:     mString(aString)
38013:     {}
38013: 
38013:   PRUint32 GetHash(void) const
38013:   {
92143:     PRUint32 hash = mozilla::HashString(mString);
92143:     return mozilla::AddToHash(hash, mRootNode, mFunc);
38013:   }
38013: 
38013: private:
38013:   friend class nsCacheableFuncStringContentList;
38013: 
38013:   nsINode* const mRootNode;
38013:   const nsContentListMatchFunc mFunc;
38013:   const nsAString& mString;
38013: };
38013: 
43324: /**
43324:  * A function that allocates the matching data for this
43324:  * FuncStringContentList.  Returning aString is perfectly fine; in
43324:  * that case the destructor function should be a no-op.
43324:  */
43324: typedef void* (*nsFuncStringContentListDataAllocator)(nsINode* aRootNode,
43324:                                                       const nsString* aString);
43324: 
43324: // aDestroyFunc is allowed to be null
38013: class nsCacheableFuncStringContentList : public nsContentList {
38013: public:
38013:   nsCacheableFuncStringContentList(nsINode* aRootNode,
38013:                                    nsContentListMatchFunc aFunc,
38013:                                    nsContentListDestroyFunc aDestroyFunc,
43324:                                    nsFuncStringContentListDataAllocator aDataAllocator,
38013:                                    const nsAString& aString) :
43324:     nsContentList(aRootNode, aFunc, aDestroyFunc, nsnull),
38013:     mString(aString)
43324:   {
43324:     mData = (*aDataAllocator)(aRootNode, &mString);
43324:   }
38013: 
38013:   virtual ~nsCacheableFuncStringContentList();
38013: 
79445:   bool Equals(const nsFuncStringCacheKey* aKey) {
38013:     return mRootNode == aKey->mRootNode && mFunc == aKey->mFunc &&
38013:       mString == aKey->mString;
38013:   }
43324: 
79445:   bool AllocatedData() const { return !!mData; }
38013: protected:
38013:   virtual void RemoveFromCaches() {
38013:     RemoveFromFuncStringHashtable();
38013:   }
38013:   void RemoveFromFuncStringHashtable();
38013: 
38013:   nsString mString;
38013: };
38013: 
63637: // If aMatchNameSpaceId is kNameSpaceID_Unknown, this will return a
63637: // content list which matches ASCIIToLower(aTagname) against HTML
63637: // elements in HTML documents and aTagname against everything else.
63637: // For any other value of aMatchNameSpaceId, the list will match
63637: // aTagname against all elements.
    1: already_AddRefed<nsContentList>
53966: NS_GetContentList(nsINode* aRootNode,
53966:                   PRInt32 aMatchNameSpaceId,
63637:                   const nsAString& aTagname);
    1: 
38013: already_AddRefed<nsContentList>
38013: NS_GetFuncStringContentList(nsINode* aRootNode,
38013:                             nsContentListMatchFunc aFunc,
38013:                             nsContentListDestroyFunc aDestroyFunc,
43324:                             nsFuncStringContentListDataAllocator aDataAllocator,
38013:                             const nsAString& aString);
    1: #endif // nsContentList_h___
