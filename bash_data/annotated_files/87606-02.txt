52560: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52560:  * vim: set ts=4 sw=4 et tw=99:
52560:  *
52560:  * ***** BEGIN LICENSE BLOCK *****
52560:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52560:  *
52560:  * The contents of this file are subject to the Mozilla Public License Version
52560:  * 1.1 (the "License"); you may not use this file except in compliance with
52560:  * the License. You may obtain a copy of the License at
52560:  * http://www.mozilla.org/MPL/
52560:  *
52560:  * Software distributed under the License is distributed on an "AS IS" basis,
52560:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52560:  * for the specific language governing rights and limitations under the
52560:  * License.
52560:  *
52560:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52560:  * May 28, 2008.
52560:  *
52560:  * The Initial Developer of the Original Code is
52560:  *   Brendan Eich <brendan@mozilla.org>
52560:  *
52560:  * Contributor(s):
52560:  *   David Anderson <danderson@mozilla.com>
52560:  *   David Mandelin <dmandelin@mozilla.com>
52560:  *
52560:  * Alternatively, the contents of this file may be used under the terms of
52560:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52560:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52560:  * in which case the provisions of the GPL or the LGPL are applicable instead
52560:  * of those above. If you wish to allow use of your version of this file only
52560:  * under the terms of either the GPL or the LGPL, and not to allow others to
52560:  * use your version of this file under the terms of the MPL, indicate your
52560:  * decision by deleting the provisions above and replace them with the notice
52560:  * and other provisions required by the GPL or the LGPL. If you do not delete
52560:  * the provisions above, a recipient may use your version of this file under
52560:  * the terms of any one of the MPL, the GPL or the LGPL.
52560:  *
52560:  * ***** END LICENSE BLOCK ***** */
80506: 
52734: #include "jsbool.h"
58056: #include "jscntxt.h"
52842: #include "jslibmath.h"
52808: #include "jsnum.h"
53228: #include "jsscope.h"
53531: #include "jsobjinlines.h"
59968: #include "jsscriptinlines.h"
77344: #include "jstypedarrayinlines.h"
59968: 
80964: #include "frontend/BytecodeEmitter.h"
52606: #include "methodjit/MethodJIT.h"
52606: #include "methodjit/Compiler.h"
52608: #include "methodjit/StubCalls.h"
52618: #include "methodjit/FrameState-inl.h"
52560: 
52560: #include "jsautooplen.h"
52560: 
52560: using namespace js;
52608: using namespace js::mjit;
52560: 
53230: typedef JSC::MacroAssembler::RegisterID RegisterID;
53230: 
77343: void
77343: mjit::Compiler::ensureInteger(FrameEntry *fe, Uses uses)
76206: {
77343:     if (fe->isConstant()) {
77343:         if (!fe->isType(JSVAL_TYPE_INT32)) {
77343:             JS_ASSERT(fe->isType(JSVAL_TYPE_DOUBLE));
77343:             fe->convertConstantDoubleToInt32(cx);
77343:         }
77343:     } else if (fe->isType(JSVAL_TYPE_DOUBLE)) {
77343:         FPRegisterID fpreg = frame.tempFPRegForData(fe);
77343:         FPRegisterID fptemp = frame.allocFPReg();
77343:         RegisterID data = frame.allocReg();
77343:         Jump truncateGuard = masm.branchTruncateDoubleToInt32(fpreg, data);
77343: 
77343:         Label syncPath = stubcc.syncExitAndJump(uses);
77343:         stubcc.linkExitDirect(truncateGuard, stubcc.masm.label());
77343: 
76206:         /*
77343:          * Try an OOL path to convert doubles representing integers within 2^32
77343:          * of a signed integer, by adding/subtracting 2^32 and then trying to
77343:          * convert to int32. This has to be an exact conversion, as otherwise
77343:          * the truncation works incorrectly on the modified value.
76206:          */
76206: 
77343:         stubcc.masm.zeroDouble(fptemp);
77343:         Jump positive = stubcc.masm.branchDouble(Assembler::DoubleGreaterThan, fpreg, fptemp);
77343:         stubcc.masm.slowLoadConstantDouble(double(4294967296.0), fptemp);
77343:         Jump skip = stubcc.masm.jump();
77343:         positive.linkTo(stubcc.masm.label(), &stubcc.masm);
77343:         stubcc.masm.slowLoadConstantDouble(double(-4294967296.0), fptemp);
77343:         skip.linkTo(stubcc.masm.label(), &stubcc.masm);
76206: 
77343:         JumpList isDouble;
77343:         stubcc.masm.addDouble(fpreg, fptemp);
77343:         stubcc.masm.branchConvertDoubleToInt32(fptemp, data, isDouble, Registers::FPConversionTemp);
77343:         stubcc.crossJump(stubcc.masm.jump(), masm.label());
77343:         isDouble.linkTo(syncPath, &stubcc.masm);
64345: 
77343:         frame.freeReg(fptemp);
77343:         frame.learnType(fe, JSVAL_TYPE_INT32, data);
77343:     } else if (!fe->isType(JSVAL_TYPE_INT32)) {
87590:         if (masm.supportsFloatingPoint()) {
77343:             FPRegisterID fptemp = frame.allocFPReg();
77343:             RegisterID typeReg = frame.tempRegForType(fe);
77343:             frame.pinReg(typeReg);
77343:             RegisterID dataReg = frame.copyDataIntoReg(fe);
77343:             frame.unpinReg(typeReg);
64345: 
77343:             Jump intGuard = masm.testInt32(Assembler::NotEqual, typeReg);
53230: 
77343:             Label syncPath = stubcc.syncExitAndJump(uses);
77343:             stubcc.linkExitDirect(intGuard, stubcc.masm.label());
53230: 
77343:             /* Try an OOL path to truncate doubles representing int32s. */
77343:             Jump doubleGuard = stubcc.masm.testDouble(Assembler::NotEqual, typeReg);
77343:             doubleGuard.linkTo(syncPath, &stubcc.masm);
53230: 
77343:             frame.loadDouble(fe, fptemp, stubcc.masm);
77343:             Jump truncateGuard = stubcc.masm.branchTruncateDoubleToInt32(fptemp, dataReg);
77343:             truncateGuard.linkTo(syncPath, &stubcc.masm);
53230:             stubcc.crossJump(stubcc.masm.jump(), masm.label());
53230: 
77343:             frame.freeReg(fptemp);
77343:             frame.learnType(fe, JSVAL_TYPE_INT32, dataReg);
87590:         } else {
87590:             RegisterID typeReg = frame.tempRegForType(fe);
87590:             frame.pinReg(typeReg);
87590:             RegisterID dataReg = frame.copyDataIntoReg(fe);
87590:             frame.unpinReg(typeReg);
87590: 
87590:             Jump intGuard = masm.testInt32(Assembler::NotEqual, typeReg);
87590: 
87590:             Label syncPath = stubcc.syncExitAndJump(uses);
87590:             stubcc.linkExitDirect(intGuard, syncPath);
87590: 
87590:             frame.learnType(fe, JSVAL_TYPE_INT32, dataReg);
87590:         }
53230:     }
53230: }
53230: 
52560: void
52724: mjit::Compiler::jsop_bitnot()
52724: {
52724:     FrameEntry *top = frame.peek(-1);
52724: 
52724:     /* We only want to handle integers here. */
77343:     if (top->isNotType(JSVAL_TYPE_INT32) && top->isNotType(JSVAL_TYPE_DOUBLE)) {
53087:         prepareStubCall(Uses(1));
77343:         INLINE_STUBCALL(stubs::BitNot, REJOIN_FALLTHROUGH);
52724:         frame.pop();
77343:         frame.pushSynced(JSVAL_TYPE_INT32);
52724:         return;
52724:     }
52724: 
77343:     ensureInteger(top, Uses(1));
52724: 
52724:     stubcc.leave();
77343:     OOL_STUBCALL(stubs::BitNot, REJOIN_FALLTHROUGH);
52724: 
52724:     RegisterID reg = frame.ownRegForData(top);
52724:     masm.not32(reg);
52724:     frame.pop();
53025:     frame.pushTypedPayload(JSVAL_TYPE_INT32, reg);
52724: 
53088:     stubcc.rejoin(Changes(1));
52724: }
52724: 
52724: void
52617: mjit::Compiler::jsop_bitop(JSOp op)
52617: {
52617:     FrameEntry *rhs = frame.peek(-1);
52617:     FrameEntry *lhs = frame.peek(-2);
52617: 
77343:     /* The operands we ensure are integers cannot be copied by each other. */
77343:     frame.separateBinaryEntries(lhs, rhs);
71320: 
52685:     VoidStub stub;
52685:     switch (op) {
52721:       case JSOP_BITOR:
52721:         stub = stubs::BitOr;
52721:         break;
52685:       case JSOP_BITAND:
52685:         stub = stubs::BitAnd;
52685:         break;
52718:       case JSOP_BITXOR:
52718:         stub = stubs::BitXor;
52718:         break;
52685:       case JSOP_LSH:
52685:         stub = stubs::Lsh;
52685:         break;
77343:       case JSOP_RSH:
77343:         stub = stubs::Rsh;
77343:         break;
53581:       case JSOP_URSH:
53581:         stub = stubs::Ursh;
53581:         break;
52685:       default:
52685:         JS_NOT_REACHED("wat");
52722:         return;
52685:     }
52685: 
77343:     /* Convert a double RHS to integer if it's constant for the test below. */
77343:     if (rhs->isConstant() && rhs->getValue().isDouble())
77343:         rhs->convertConstantDoubleToInt32(cx);
77343: 
52617:     /* We only want to handle integers here. */
77343:     if ((lhs->isNotType(JSVAL_TYPE_INT32) && lhs->isNotType(JSVAL_TYPE_DOUBLE)) ||
77343:         (rhs->isNotType(JSVAL_TYPE_INT32) && rhs->isNotType(JSVAL_TYPE_DOUBLE)) ||
77343:         (op == JSOP_URSH && rhs->isConstant() && rhs->getValue().toInt32() % 32 == 0)) {
53087:         prepareStubCall(Uses(2));
77343:         INLINE_STUBCALL(stub, REJOIN_FALLTHROUGH);
52617:         frame.popn(2);
77343:         frame.pushSynced(op != JSOP_URSH ? JSVAL_TYPE_INT32 : knownPushedType(0));
52617:         return;
52617:     }
52617: 
77343:     ensureInteger(lhs, Uses(2));
77343:     ensureInteger(rhs, Uses(2));
77343: 
77343:     if (lhs->isConstant() && rhs->isConstant()) {
84755:         int32_t L = lhs->getValue().toInt32();
84755:         int32_t R = rhs->getValue().toInt32();
77343: 
77343:         frame.popn(2);
77343:         switch (op) {
77343:           case JSOP_BITOR:
77343:             frame.push(Int32Value(L | R));
77343:             return;
77343:           case JSOP_BITXOR:
77343:             frame.push(Int32Value(L ^ R));
77343:             return;
77343:           case JSOP_BITAND:
77343:             frame.push(Int32Value(L & R));
77343:             return;
77343:           case JSOP_LSH:
77343:             frame.push(Int32Value(L << (R & 31)));
77343:             return;
77343:           case JSOP_RSH:
77343:             frame.push(Int32Value(L >> (R & 31)));
77343:             return;
77343:           case JSOP_URSH:
77343:           {
84755:             uint32_t unsignedL;
84161:             ToUint32(cx, Int32Value(L), (uint32_t*)&unsignedL);  /* Can't fail. */
84755:             Value v = NumberValue(uint32_t(unsignedL >> (R & 31)));
77343:             JS_ASSERT(v.isInt32());
77343:             frame.push(v);
77343:             return;
52617:           }
77343:           default:
77343:             JS_NOT_REACHED("say wat");
77343:         }
52617:     }
52617: 
52620:     RegisterID reg;
52620: 
52620:     switch (op) {
52721:       case JSOP_BITOR:
52718:       case JSOP_BITXOR:
52620:       case JSOP_BITAND:
52620:       {
52620:         /* Commutative, and we're guaranteed both are ints. */
77343:         if (lhs->isConstant()) {
52620:             JS_ASSERT(!rhs->isConstant());
52620:             FrameEntry *temp = rhs;
52620:             rhs = lhs;
52620:             lhs = temp;
52620:         }
52620: 
52620:         reg = frame.ownRegForData(lhs);
77343:         if (rhs->isConstant()) {
84755:             int32_t rhsInt = rhs->getValue().toInt32();
52718:             if (op == JSOP_BITAND)
71320:                 masm.and32(Imm32(rhsInt), reg);
52718:             else if (op == JSOP_BITXOR)
71320:                 masm.xor32(Imm32(rhsInt), reg);
80790:             else if (rhsInt != 0)
71320:                 masm.or32(Imm32(rhsInt), reg);
52620:         } else if (frame.shouldAvoidDataRemat(rhs)) {
77343:             Address rhsAddr = masm.payloadOf(frame.addressOf(rhs));
52718:             if (op == JSOP_BITAND)
77343:                 masm.and32(rhsAddr, reg);
52718:             else if (op == JSOP_BITXOR)
77343:                 masm.xor32(rhsAddr, reg);
52721:             else
77343:                 masm.or32(rhsAddr, reg);
52620:         } else {
52620:             RegisterID rhsReg = frame.tempRegForData(rhs);
52718:             if (op == JSOP_BITAND)
52620:                 masm.and32(rhsReg, reg);
52718:             else if (op == JSOP_BITXOR)
52718:                 masm.xor32(rhsReg, reg);
52721:             else
52721:                 masm.or32(rhsReg, reg);
52620:         }
52620: 
52620:         break;
52620:       }
52620: 
52685:       case JSOP_LSH:
77343:       case JSOP_RSH:
53581:       case JSOP_URSH:
52685:       {
52685:         /* Not commutative. */
77343:         if (rhs->isConstant()) {
53230:             RegisterID reg = frame.ownRegForData(lhs);
77343:             int shift = rhs->getValue().toInt32() & 0x1F;
77343: 
77343:             stubcc.leave();
77343:             OOL_STUBCALL(stub, REJOIN_FALLTHROUGH);
52783: 
53581:             if (shift) {
53581:                 if (op == JSOP_LSH)
52685:                     masm.lshift32(Imm32(shift), reg);
77343:                 else if (op == JSOP_RSH)
77343:                     masm.rshift32(Imm32(shift), reg);
53581:                 else
53581:                     masm.urshift32(Imm32(shift), reg);
53581:             }
53581:             frame.popn(2);
53230:             
53581:             /* x >>> 0 may result in a double, handled above. */
53581:             JS_ASSERT_IF(op == JSOP_URSH, shift >= 1);
53230:             frame.pushTypedPayload(JSVAL_TYPE_INT32, reg);
53258: 
53258:             stubcc.rejoin(Changes(1));
53230:             return;
52685:         }
52685: #if defined(JS_CPU_X86) || defined(JS_CPU_X64)
52685:         /* Grosssssss! RHS _must_ be in ECX, on x86 */
53230:         RegisterID rr = frame.tempRegInMaskForData(rhs,
77343:                                                    Registers::maskReg(JSC::X86Registers::ecx)).reg();
52685: #else
52685:         RegisterID rr = frame.tempRegForData(rhs);
52685: #endif
52685: 
56538:         if (frame.haveSameBacking(lhs, rhs)) {
56538:             // It's okay to allocReg(). If |rr| is evicted, it won't result in
56538:             // a load, and |rr == reg| is fine since this is (x << x).
56538:             reg = frame.allocReg();
56538:             if (rr != reg)
56538:                 masm.move(rr, reg);
56538:         } else {
56538:             frame.pinReg(rr);
77343:             if (lhs->isConstant()) {
52685:                 reg = frame.allocReg();
77343:                 masm.move(Imm32(lhs->getValue().toInt32()), reg);
52685:             } else {
53581:                 reg = frame.copyDataIntoReg(lhs);
52685:             }
56538:             frame.unpinReg(rr);
56538:         }
52685:         
53581:         if (op == JSOP_LSH) {
52685:             masm.lshift32(rr, reg);
77343:         } else if (op == JSOP_RSH) {
77343:             masm.rshift32(rr, reg);
53581:         } else {
53581:             masm.urshift32(rr, reg);
53581:             
53581:             Jump isNegative = masm.branch32(Assembler::LessThan, reg, Imm32(0));
53581:             stubcc.linkExit(isNegative, Uses(2));
53581:         }
52685:         break;
52685:       }
52685: 
52620:       default:
52620:         JS_NOT_REACHED("NYI");
52620:         return;
52620:     }
52620: 
53581:     stubcc.leave();
77343:     OOL_STUBCALL(stub, REJOIN_FALLTHROUGH);
53581: 
77343:     frame.pop();
77343:     frame.pop();
53581: 
77343:     JSValueType type = knownPushedType(0);
77343: 
77343:     if (type != JSVAL_TYPE_UNKNOWN && type != JSVAL_TYPE_DOUBLE)
77343:         frame.pushTypedPayload(type, reg);
77343:     else if (op == JSOP_URSH)
53581:         frame.pushNumber(reg, true);
53581:     else
53025:         frame.pushTypedPayload(JSVAL_TYPE_INT32, reg);
52620: 
53088:     stubcc.rejoin(Changes(1));
52620: }
52620: 
52842: static inline bool
53025: CheckNullOrUndefined(FrameEntry *fe)
52879: {
52879:     if (!fe->isTypeKnown())
52879:         return false;
53025:     JSValueType type = fe->getKnownType();
53025:     return type == JSVAL_TYPE_NULL || type == JSVAL_TYPE_UNDEFINED;
52879: }
52879: 
79902: CompileStatus
79902: mjit::Compiler::jsop_equality_obj_obj(JSOp op, jsbytecode *target, JSOp fused)
79902: {
79902:     FrameEntry *rhs = frame.peek(-1);
79902:     FrameEntry *lhs = frame.peek(-2);
79902: 
79902:     JS_ASSERT(cx->typeInferenceEnabled() &&
79902:               lhs->isType(JSVAL_TYPE_OBJECT) && rhs->isType(JSVAL_TYPE_OBJECT));
79902: 
79902:     /*
79902:      * Handle equality between two objects. We have to ensure there is no
79902:      * special equality operator on either object, if that passes then
79902:      * this is a pointer comparison.
79902:      */
79902:     types::TypeSet *lhsTypes = analysis->poppedTypes(PC, 1);
79902:     types::TypeSet *rhsTypes = analysis->poppedTypes(PC, 0);
79902:     if (!lhsTypes->hasObjectFlags(cx, types::OBJECT_FLAG_SPECIAL_EQUALITY) &&
79902:         !rhsTypes->hasObjectFlags(cx, types::OBJECT_FLAG_SPECIAL_EQUALITY)) {
79902:         /* :TODO: Merge with jsop_relational_int? */
79902:         JS_ASSERT_IF(!target, fused != JSOP_IFEQ);
79902:         frame.forgetMismatchedObject(lhs);
79902:         frame.forgetMismatchedObject(rhs);
79902:         Assembler::Condition cond = GetCompareCondition(op, fused);
79902:         if (target) {
79902:             Jump sj = stubcc.masm.branchTest32(GetStubCompareCondition(fused),
79902:                                                Registers::ReturnReg, Registers::ReturnReg);
79902:             if (!frame.syncForBranch(target, Uses(2)))
79902:                 return Compile_Error;
79902:             RegisterID lreg = frame.tempRegForData(lhs);
79902:             frame.pinReg(lreg);
79902:             RegisterID rreg = frame.tempRegForData(rhs);
79902:             frame.unpinReg(lreg);
79902:             Jump fast = masm.branchPtr(cond, lreg, rreg);
79902:             frame.popn(2);
82738:             return jumpAndRun(fast, target, &sj) ? Compile_Okay : Compile_Error;
79902:         } else {
79902:             RegisterID result = frame.allocReg();
79902:             RegisterID lreg = frame.tempRegForData(lhs);
79902:             frame.pinReg(lreg);
79902:             RegisterID rreg = frame.tempRegForData(rhs);
79902:             frame.unpinReg(lreg);
79902:             masm.branchValue(cond, lreg, rreg, result);
79902: 
79902:             frame.popn(2);
79902:             frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, result);
79902:             return Compile_Okay;
79902:         }
79902:     }
79902: 
79902:     return Compile_Skipped;
79902: }
79902: 
56766: bool
52879: mjit::Compiler::jsop_equality(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused)
52879: {
52879:     FrameEntry *rhs = frame.peek(-1);
52879:     FrameEntry *lhs = frame.peek(-2);
52879: 
52879:     /* The compiler should have handled constant folding. */
52879:     JS_ASSERT(!(rhs->isConstant() && lhs->isConstant()));
52879: 
52879:     bool lhsTest;
53025:     if ((lhsTest = CheckNullOrUndefined(lhs)) || CheckNullOrUndefined(rhs)) {
52879:         /* What's the other mask? */
52879:         FrameEntry *test = lhsTest ? rhs : lhs;
52879: 
77343:         if (test->isType(JSVAL_TYPE_NULL) || test->isType(JSVAL_TYPE_UNDEFINED)) {
56766:             return emitStubCmpOp(stub, target, fused);
77343:         } else if (test->isTypeKnown()) {
77343:             /* The test will not succeed, constant fold the compare. */
77343:             bool result = GetCompareCondition(op, fused) == Assembler::NotEqual;
77343:             frame.pop();
77343:             frame.pop();
77343:             if (target)
77343:                 return constantFoldBranch(target, result);
77343:             frame.push(BooleanValue(result));
77343:             return true;
77343:         }
52879: 
52879:         /* The other side must be null or undefined. */
52879:         RegisterID reg = frame.ownRegForType(test);
52954:         frame.pop();
52954:         frame.pop();
52879: 
52954:         /*
52954:          * :FIXME: Easier test for undefined || null?
52954:          * Maybe put them next to each other, subtract, do a single compare?
52954:          */
52879: 
52879:         if (target) {
77343:             frame.syncAndKillEverything();
77343:             frame.freeReg(reg);
77343: 
77343:             Jump sj = stubcc.masm.branchTest32(GetStubCompareCondition(fused),
77343:                                                Registers::ReturnReg, Registers::ReturnReg);
52879: 
52954:             if ((op == JSOP_EQ && fused == JSOP_IFNE) ||
52954:                 (op == JSOP_NE && fused == JSOP_IFEQ)) {
56217:                 Jump b1 = masm.branchPtr(Assembler::Equal, reg, ImmType(JSVAL_TYPE_UNDEFINED));
56217:                 Jump b2 = masm.branchPtr(Assembler::Equal, reg, ImmType(JSVAL_TYPE_NULL));
56217:                 Jump j1 = masm.jump();
56217:                 b1.linkTo(masm.label(), &masm);
56217:                 b2.linkTo(masm.label(), &masm);
56217:                 Jump j2 = masm.jump();
82738:                 if (!jumpAndRun(j2, target, &sj))
56766:                     return false;
56217:                 j1.linkTo(masm.label(), &masm);
52879:             } else {
53162:                 Jump j = masm.branchPtr(Assembler::Equal, reg, ImmType(JSVAL_TYPE_UNDEFINED));
53162:                 Jump j2 = masm.branchPtr(Assembler::NotEqual, reg, ImmType(JSVAL_TYPE_NULL));
82738:                 if (!jumpAndRun(j2, target, &sj))
56766:                     return false;
52954:                 j.linkTo(masm.label(), &masm);
52954:             }
52954:         } else {
53162:             Jump j = masm.branchPtr(Assembler::Equal, reg, ImmType(JSVAL_TYPE_UNDEFINED));
53162:             Jump j2 = masm.branchPtr(Assembler::Equal, reg, ImmType(JSVAL_TYPE_NULL));
52954:             masm.move(Imm32(op == JSOP_NE), reg);
52954:             Jump j3 = masm.jump();
52954:             j2.linkTo(masm.label(), &masm);
52954:             j.linkTo(masm.label(), &masm);
52954:             masm.move(Imm32(op == JSOP_EQ), reg);
52954:             j3.linkTo(masm.label(), &masm);
53025:             frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, reg);
52879:         }
56766:         return true;
52879:     }
52879: 
77343:     if (cx->typeInferenceEnabled() &&
79902:         lhs->isType(JSVAL_TYPE_OBJECT) && rhs->isType(JSVAL_TYPE_OBJECT))
79902:     {
79902:         CompileStatus status = jsop_equality_obj_obj(op, target, fused);
79902:         if (status == Compile_Okay) return true;
79902:         else if (status == Compile_Error) return false;
77343:     }
77343: 
56766:     return emitStubCmpOp(stub, target, fused);
52879: }
52879: 
56766: bool
77343: mjit::Compiler::jsop_relational(JSOp op, BoolStub stub,
77343:                                 jsbytecode *target, JSOp fused)
52651: {
52652:     FrameEntry *rhs = frame.peek(-1);
52652:     FrameEntry *lhs = frame.peek(-2);
52652: 
52653:     /* The compiler should have handled constant folding. */
52653:     JS_ASSERT(!(rhs->isConstant() && lhs->isConstant()));
77438:     JS_ASSERT(fused == JSOP_NOP || fused == JSOP_IFEQ || fused == JSOP_IFNE);
52653: 
52653:     /* Always slow path... */
54160:     if ((lhs->isNotType(JSVAL_TYPE_INT32) && lhs->isNotType(JSVAL_TYPE_DOUBLE) &&
54160:          lhs->isNotType(JSVAL_TYPE_STRING)) ||
54160:         (rhs->isNotType(JSVAL_TYPE_INT32) && rhs->isNotType(JSVAL_TYPE_DOUBLE) &&
54160:          rhs->isNotType(JSVAL_TYPE_STRING))) {
52879:         if (op == JSOP_EQ || op == JSOP_NE)
56766:             return jsop_equality(op, stub, target, fused);
56766:         return emitStubCmpOp(stub, target, fused);
52653:     }
52653: 
53201:     if (op == JSOP_EQ || op == JSOP_NE) {
54160:         if ((lhs->isNotType(JSVAL_TYPE_INT32) && lhs->isNotType(JSVAL_TYPE_STRING)) ||
54160:             (rhs->isNotType(JSVAL_TYPE_INT32) && rhs->isNotType(JSVAL_TYPE_STRING))) {
56766:             return emitStubCmpOp(stub, target, fused);
54160:         } else if (!target && (lhs->isType(JSVAL_TYPE_STRING) || rhs->isType(JSVAL_TYPE_STRING))) {
56766:             return emitStubCmpOp(stub, target, fused);
54717:         } else if (frame.haveSameBacking(lhs, rhs)) {
56766:             return emitStubCmpOp(stub, target, fused);
54160:         } else {
56766:             return jsop_equality_int_string(op, stub, target, fused);
54160:         }
52651:     }
52651: 
53201:     if (frame.haveSameBacking(lhs, rhs)) {
77343:         return emitStubCmpOp(stub, target, fused);
54160:     } else if (lhs->isType(JSVAL_TYPE_STRING) || rhs->isType(JSVAL_TYPE_STRING)) {
56766:         return emitStubCmpOp(stub, target, fused);
53201:     } else if (lhs->isType(JSVAL_TYPE_DOUBLE) || rhs->isType(JSVAL_TYPE_DOUBLE)) {
87590:         if (!masm.supportsFloatingPoint())
87590:             return emitStubCmpOp(stub, target, fused);
56766:         return jsop_relational_double(op, stub, target, fused);
77343:     } else if (cx->typeInferenceEnabled() &&
77343:                lhs->isType(JSVAL_TYPE_INT32) && rhs->isType(JSVAL_TYPE_INT32)) {
77343:         return jsop_relational_int(op, target, fused);
52653:     } else {
56766:         return jsop_relational_full(op, stub, target, fused);
52653:     }
52653: }
52653: 
52713: void
52734: mjit::Compiler::jsop_not()
52734: {
52734:     FrameEntry *top = frame.peek(-1);
52734: 
52734:     if (top->isConstant()) {
52734:         const Value &v = top->getValue();
52734:         frame.pop();
53081:         frame.push(BooleanValue(!js_ValueToBoolean(v)));
52734:         return;
52734:     }
52734: 
52734:     if (top->isTypeKnown()) {
53025:         JSValueType type = top->getKnownType();
53025:         switch (type) {
53025:           case JSVAL_TYPE_INT32:
52975:           {
77343:             RegisterID data = frame.allocReg(Registers::SingleByteRegs).reg();
52975:             if (frame.shouldAvoidDataRemat(top))
53144:                 masm.loadPayload(frame.addressOf(top), data);
52975:             else
52975:                 masm.move(frame.tempRegForData(top), data);
52975: 
52975:             masm.set32(Assembler::Equal, data, Imm32(0), data);
52975: 
52975:             frame.pop();
53025:             frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, data);
52975:             break;
52975:           }
52975: 
53025:           case JSVAL_TYPE_BOOLEAN:
52734:           {
52734:             RegisterID reg = frame.ownRegForData(top);
52975: 
52975:             masm.xor32(Imm32(1), reg);
52975: 
52734:             frame.pop();
53025:             frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, reg);
52734:             break;
52734:           }
52734: 
53025:           case JSVAL_TYPE_OBJECT:
52734:           {
77343:             RegisterID reg = frame.allocReg();
77343:             masm.move(Imm32(0), reg);
77343: 
52734:             frame.pop();
77343:             frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, reg);
52734:             break;
52734:           }
52734: 
52734:           default:
52734:           {
53087:             prepareStubCall(Uses(1));
78454:             INLINE_STUBCALL_USES(stubs::ValueToBoolean, REJOIN_NONE, Uses(1));
52975: 
52975:             RegisterID reg = Registers::ReturnReg;
52734:             frame.takeReg(reg);
52975:             masm.xor32(Imm32(1), reg);
52975: 
52734:             frame.pop();
53025:             frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, reg);
52734:             break;
52734:           }
52734:         }
52734: 
52734:         return;
52734:     }
52734: 
77343:     RegisterID data = frame.allocReg(Registers::SingleByteRegs).reg();
52956:     if (frame.shouldAvoidDataRemat(top))
53144:         masm.loadPayload(frame.addressOf(top), data);
52956:     else
52956:         masm.move(frame.tempRegForData(top), data);
52956:     RegisterID type = frame.tempRegForType(top);
53088:     Label syncTarget = stubcc.syncExitAndJump(Uses(1));
52734: 
52975: 
52975:     /* Inline path is for booleans. */
52975:     Jump jmpNotBool = masm.testBoolean(Assembler::NotEqual, type);
52975:     masm.xor32(Imm32(1), data);
52975: 
52975: 
52975:     /* OOL path is for int + object. */
52975:     Label lblMaybeInt32 = stubcc.masm.label();
52975: 
52975:     Jump jmpNotInt32 = stubcc.masm.testInt32(Assembler::NotEqual, type);
52975:     stubcc.masm.set32(Assembler::Equal, data, Imm32(0), data);
52975:     Jump jmpInt32Exit = stubcc.masm.jump();
52975: 
52975:     Label lblMaybeObject = stubcc.masm.label();
52975:     Jump jmpNotObject = stubcc.masm.testPrimitive(Assembler::Equal, type);
52975:     stubcc.masm.move(Imm32(0), data);
52975:     Jump jmpObjectExit = stubcc.masm.jump();
52975: 
52975: 
52975:     /* Rejoin location. */
52975:     Label lblRejoin = masm.label();
52975: 
52975:     /* Patch up jumps. */
52975:     stubcc.linkExitDirect(jmpNotBool, lblMaybeInt32);
52975: 
52975:     jmpNotInt32.linkTo(lblMaybeObject, &stubcc.masm);
52975:     stubcc.crossJump(jmpInt32Exit, lblRejoin);
52975: 
52975:     jmpNotObject.linkTo(syncTarget, &stubcc.masm);
52975:     stubcc.crossJump(jmpObjectExit, lblRejoin);
52975:     
52975: 
52975:     /* Leave. */
52734:     stubcc.leave();
77343:     OOL_STUBCALL(stubs::Not, REJOIN_FALLTHROUGH);
52734: 
52734:     frame.pop();
53025:     frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, data);
52734: 
53088:     stubcc.rejoin(Changes(1));
52734: }
52734: 
52738: void
52738: mjit::Compiler::jsop_typeof()
52738: {
52738:     FrameEntry *fe = frame.peek(-1);
52738: 
52738:     if (fe->isTypeKnown()) {
52738:         JSRuntime *rt = cx->runtime;
52738: 
52738:         JSAtom *atom = NULL;
53025:         switch (fe->getKnownType()) {
53025:           case JSVAL_TYPE_STRING:
52738:             atom = rt->atomState.typeAtoms[JSTYPE_STRING];
52738:             break;
53025:           case JSVAL_TYPE_UNDEFINED:
52738:             atom = rt->atomState.typeAtoms[JSTYPE_VOID];
52738:             break;
53025:           case JSVAL_TYPE_NULL:
52738:             atom = rt->atomState.typeAtoms[JSTYPE_OBJECT];
52738:             break;
53025:           case JSVAL_TYPE_OBJECT:
52738:             atom = NULL;
52738:             break;
53025:           case JSVAL_TYPE_BOOLEAN:
52738:             atom = rt->atomState.typeAtoms[JSTYPE_BOOLEAN];
52738:             break;
52738:           default:
52738:             atom = rt->atomState.typeAtoms[JSTYPE_NUMBER];
52738:             break;
52738:         }
52738: 
52738:         if (atom) {
52738:             frame.pop();
64345:             frame.push(StringValue(atom));
52738:             return;
52738:         }
52738:     }
52738: 
58690:     JSOp fused = JSOp(PC[JSOP_TYPEOF_LENGTH]);
58690:     if (fused == JSOP_STRING && !fe->isTypeKnown()) {
58690:         JSOp op = JSOp(PC[JSOP_TYPEOF_LENGTH + JSOP_STRING_LENGTH]);
58690: 
58690:         if (op == JSOP_STRICTEQ || op == JSOP_EQ || op == JSOP_STRICTNE || op == JSOP_NE) {
58690:             JSAtom *atom = script->getAtom(fullAtomIndex(PC + JSOP_TYPEOF_LENGTH));
58690:             JSRuntime *rt = cx->runtime;
86532:             JSValueType type = JSVAL_TYPE_UNKNOWN;
58690:             Assembler::Condition cond = (op == JSOP_STRICTEQ || op == JSOP_EQ)
58690:                                         ? Assembler::Equal
58690:                                         : Assembler::NotEqual;
58690:             
58690:             if (atom == rt->atomState.typeAtoms[JSTYPE_VOID]) {
58690:                 type = JSVAL_TYPE_UNDEFINED;
58690:             } else if (atom == rt->atomState.typeAtoms[JSTYPE_STRING]) {
58690:                 type = JSVAL_TYPE_STRING;
58690:             } else if (atom == rt->atomState.typeAtoms[JSTYPE_BOOLEAN]) {
58690:                 type = JSVAL_TYPE_BOOLEAN;
58690:             } else if (atom == rt->atomState.typeAtoms[JSTYPE_NUMBER]) {
58690:                 type = JSVAL_TYPE_INT32;
58690: 
58690:                 /* JSVAL_TYPE_DOUBLE is 0x0 and JSVAL_TYPE_INT32 is 0x1, use <= or > to match both */
58690:                 cond = (cond == Assembler::Equal) ? Assembler::BelowOrEqual : Assembler::Above;
58690:             }
58690: 
86532:             if (type != JSVAL_TYPE_UNKNOWN) {
58690:                 PC += JSOP_STRING_LENGTH;;
58690:                 PC += JSOP_EQ_LENGTH;
58690: 
77343:                 RegisterID result = frame.allocReg(Registers::SingleByteRegs).reg();
58690: 
58690: #if defined JS_NUNBOX32
58690:                 if (frame.shouldAvoidTypeRemat(fe))
58690:                     masm.set32(cond, masm.tagOf(frame.addressOf(fe)), ImmType(type), result);
58690:                 else
58690:                     masm.set32(cond, frame.tempRegForType(fe), ImmType(type), result);
58690: #elif defined JS_PUNBOX64
58690:                 masm.setPtr(cond, frame.tempRegForType(fe), ImmType(type), result);
58690: #endif
58690: 
58690:                 frame.pop();
58690:                 frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, result);
58690:                 return;
58690:             }
58690:         }
58690:     }
58690: 
53087:     prepareStubCall(Uses(1));
77343:     INLINE_STUBCALL(stubs::TypeOf, REJOIN_NONE);
52738:     frame.pop();
52738:     frame.takeReg(Registers::ReturnReg);
53025:     frame.pushTypedPayload(JSVAL_TYPE_STRING, Registers::ReturnReg);
52738: }
52738: 
56766: bool
53102: mjit::Compiler::booleanJumpScript(JSOp op, jsbytecode *target)
53086: {
77829:     // JSOP_AND and JSOP_OR may leave the value on the stack (despite
77829:     // the frame.pop() below), so we need to sync it.
77829:     if (op == JSOP_AND || op == JSOP_OR) {
77829:         frame.syncForBranch(target, Uses(0));
77829:     } else {
86877:         JS_ASSERT(op == JSOP_IFEQ || op == JSOP_IFNE);
77829:         frame.syncForBranch(target, Uses(1));
77829:     }
77829: 
53086:     FrameEntry *fe = frame.peek(-1);
86877:     Assembler::Condition cond = (op == JSOP_IFNE || op == JSOP_OR)
53086:                                 ? Assembler::NonZero
53086:                                 : Assembler::Zero;
77829: 
77829:     // Load data register and pin it so that frame.testBoolean
77829:     // below cannot evict it.
77829:     MaybeRegisterID data;
77829:     if (!fe->isType(JSVAL_TYPE_DOUBLE)) {
77829:         data = frame.tempRegForData(fe);
77829:         frame.pinReg(data.reg());
53086:     }
77829: 
77829:     // Test for boolean if needed.
77829:     bool needStub = false;
77829:     if (!fe->isType(JSVAL_TYPE_BOOLEAN) && !fe->isType(JSVAL_TYPE_INT32)) {
77829:         Jump notBool;
77829:         if (fe->mightBeType(JSVAL_TYPE_BOOLEAN))
77829:             notBool = frame.testBoolean(Assembler::NotEqual, fe);
77829:         else
77829:             notBool = masm.jump();
77829: 
77829:         stubcc.linkExitForBranch(notBool);
77829:         needStub = true;
53086:     }
77829:     if (data.isSet())
77829:         frame.unpinReg(data.reg());
77829: 
77829:     // Test + branch.
77829:     Jump branch;
77343:     if (!fe->isType(JSVAL_TYPE_DOUBLE))
77829:         branch = masm.branchTest32(cond, data.reg());
77829:     else
77829:         branch = masm.jump(); // dummy jump
77829: 
77829:     // OOL path: call ValueToBoolean and branch.
77829:     if (needStub) {
77829:         stubcc.leave();
77829: 
77829:         // Note: this cannot overwrite slots holding loop invariants.
57766:         stubcc.masm.infallibleVMCall(JS_FUNC_TO_DATA_PTR(void *, stubs::ValueToBoolean),
77343:                                      frame.totalDepth());
53086:     }
53086: 
77829:     Jump stubBranch = stubcc.masm.branchTest32(cond, Registers::ReturnReg);
77829: 
77829:     // Rejoin from the stub call fallthrough.
77829:     if (needStub)
77829:         stubcc.rejoin(Changes(0));
53086: 
53086:     frame.pop();
53133: 
82738:     return jumpAndRun(branch, target, &stubBranch);
53086: }
53086: 
56766: bool
53102: mjit::Compiler::jsop_ifneq(JSOp op, jsbytecode *target)
53102: {
53102:     FrameEntry *fe = frame.peek(-1);
53102: 
53102:     if (fe->isConstant()) {
53102:         JSBool b = js_ValueToBoolean(fe->getValue());
53102: 
53133:         frame.pop();
53133: 
86877:         if (op == JSOP_IFEQ)
53102:             b = !b;
53102:         if (b) {
77343:             if (!frame.syncForBranch(target, Uses(0)))
77343:                 return false;
82738:             if (!jumpAndRun(masm.jump(), target))
56766:                 return false;
77343:         } else {
77343:             if (target < PC && !finishLoop(target))
77343:                 return false;
53102:         }
56766:         return true;
53102:     }
53102: 
56766:     return booleanJumpScript(op, target);
53102: }
53102: 
56766: bool
53102: mjit::Compiler::jsop_andor(JSOp op, jsbytecode *target)
53102: {
53102:     FrameEntry *fe = frame.peek(-1);
53102: 
53102:     if (fe->isConstant()) {
53102:         JSBool b = js_ValueToBoolean(fe->getValue());
53102:         
53102:         /* Short-circuit. */
53102:         if ((op == JSOP_OR && b == JS_TRUE) ||
53102:             (op == JSOP_AND && b == JS_FALSE)) {
77343:             if (!frame.syncForBranch(target, Uses(0)))
77343:                 return false;
82738:             if (!jumpAndRun(masm.jump(), target))
56766:                 return false;
53102:         }
53102: 
53102:         frame.pop();
56766:         return true;
53102:     }
53102: 
56766:     return booleanJumpScript(op, target);
53102: }
53102: 
77343: bool
84755: mjit::Compiler::jsop_localinc(JSOp op, uint32_t slot)
52808: {
77343:     restoreVarType();
52808: 
77343:     types::TypeSet *types = pushedTypeSet(0);
77343:     JSValueType type = types ? types->getKnownTypeTag(cx) : JSVAL_TYPE_UNKNOWN;
77343: 
77343:     int amt = (op == JSOP_LOCALINC || op == JSOP_INCLOCAL) ? 1 : -1;
77343: 
77343:     if (!analysis->incrementInitialValueObserved(PC)) {
58721:         // Before: 
58721:         // After:  V
52808:         frame.pushLocal(slot);
52808: 
58721:         // Before: V
58721:         // After:  V 1
77343:         frame.push(Int32Value(-amt));
52808: 
58721:         // Note, SUB will perform integer conversion for us.
58721:         // Before: V 1
58721:         // After:  N+1
77343:         if (!jsop_binary(JSOP_SUB, stubs::Sub, type, types))
77343:             return false;
52808: 
58721:         // Before: N+1
58721:         // After:  N+1
77343:         frame.storeLocal(slot, analysis->popGuaranteed(PC));
58721:     } else {
58721:         // Before:
58721:         // After: V
58721:         frame.pushLocal(slot);
58721: 
58721:         // Before: V
58721:         // After:  N
58721:         jsop_pos();
58721: 
58721:         // Before: N
58721:         // After:  N N
58721:         frame.dup();
58721: 
58721:         // Before: N N
58721:         // After:  N N 1
58721:         frame.push(Int32Value(amt));
58721: 
58721:         // Before: N N 1
58721:         // After:  N N+1
77343:         if (!jsop_binary(JSOP_ADD, stubs::Add, type, types))
77343:             return false;
58721: 
58721:         // Before: N N+1
58721:         // After:  N N+1
58721:         frame.storeLocal(slot, true);
58721: 
58721:         // Before: N N+1
58721:         // After:  N
58721:         frame.pop();
58721:     }
77343: 
77343:     updateVarType();
77343:     return true;
52808: }
52808: 
77343: bool
84755: mjit::Compiler::jsop_arginc(JSOp op, uint32_t slot)
52804: {
77343:     restoreVarType();
52804: 
77343:     types::TypeSet *types = pushedTypeSet(0);
77343:     JSValueType type = types ? types->getKnownTypeTag(cx) : JSVAL_TYPE_UNKNOWN;
77343: 
77343:     int amt = (op == JSOP_ARGINC || op == JSOP_INCARG) ? 1 : -1;
77343: 
77343:     if (!analysis->incrementInitialValueObserved(PC)) {
57787:         // Before: 
57787:         // After:  V
57787:         frame.pushArg(slot);
57787: 
57787:         // Before: V
57787:         // After:  V 1
77343:         frame.push(Int32Value(-amt));
57787: 
57787:         // Note, SUB will perform integer conversion for us.
57787:         // Before: V 1
57787:         // After:  N+1
77343:         if (!jsop_binary(JSOP_SUB, stubs::Sub, type, types))
77343:             return false;
57787: 
57787:         // Before: N+1
57787:         // After:  N+1
77343:         frame.storeArg(slot, analysis->popGuaranteed(PC));
57787:     } else {
57787:         // Before:
57787:         // After: V
57787:         frame.pushArg(slot);
57787: 
57787:         // Before: V
57787:         // After:  N
57787:         jsop_pos();
57787: 
57787:         // Before: N
57787:         // After:  N N
52804:         frame.dup();
52804: 
57787:         // Before: N N
57787:         // After:  N N 1
57787:         frame.push(Int32Value(amt));
52804: 
57787:         // Before: N N 1
57787:         // After:  N N+1
77343:         if (!jsop_binary(JSOP_ADD, stubs::Add, type, types))
77343:             return false;
57787: 
57787:         // Before: N N+1
57787:         // After:  N N+1
57787:         frame.storeArg(slot, true);
57787: 
57787:         // Before: N N+1
57787:         // After:  N
52804:         frame.pop();
57787:     }
77343: 
77343:     updateVarType();
77343:     return true;
52804: }
52804: 
57671: static inline bool
57671: IsCacheableSetElem(FrameEntry *obj, FrameEntry *id, FrameEntry *value)
57671: {
57671:     if (obj->isNotType(JSVAL_TYPE_OBJECT))
57671:         return false;
81336:     if (id->isNotType(JSVAL_TYPE_INT32) && id->isNotType(JSVAL_TYPE_DOUBLE))
81336:         return false;
81336:     if (id->isConstant()) {
81196:         if (id->isNotType(JSVAL_TYPE_INT32))
81189:             return false;
77343:         if (id->getValue().toInt32() < 0)
57671:             return false;
77343:         if (id->getValue().toInt32() + 1 < 0)  // watch for overflow in hole paths
77343:             return false;
77343:     }
57671: 
57671:     // obj[obj] * is not allowed, since it will never optimize.
57671:     // obj[id] = id is allowed.
57671:     // obj[id] = obj is allowed.
57671:     if (obj->hasSameBacking(id))
57671:         return false;
57671: 
57671:     return true;
57671: }
57671: 
77343: void
77343: mjit::Compiler::jsop_setelem_dense()
77343: {
77343:     FrameEntry *obj = frame.peek(-3);
77343:     FrameEntry *id = frame.peek(-2);
77343:     FrameEntry *value = frame.peek(-1);
77343: 
77343:     // We might not know whether this is an object, but if it is an object we
77343:     // know it is a dense array.
77343:     if (!obj->isTypeKnown()) {
77343:         Jump guard = frame.testObject(Assembler::NotEqual, obj);
77343:         stubcc.linkExit(guard, Uses(3));
77343:     }
77343: 
81336:     if (id->isType(JSVAL_TYPE_DOUBLE))
81336:         tryConvertInteger(id, Uses(2));
81336: 
77343:     // Test for integer index.
77343:     if (!id->isTypeKnown()) {
77343:         Jump guard = frame.testInt32(Assembler::NotEqual, id);
77343:         stubcc.linkExit(guard, Uses(3));
77343:     }
77343: 
77343:     // Allocate registers.
77343: 
77343:     ValueRemat vr;
77343:     frame.pinEntry(value, vr, /* breakDouble = */ false);
77343: 
77343:     Int32Key key = id->isConstant()
77343:                  ? Int32Key::FromConstant(id->getValue().toInt32())
77343:                  : Int32Key::FromRegister(frame.tempRegForData(id));
77343:     bool pinKey = !key.isConstant() && !frame.haveSameBacking(id, value);
77343:     if (pinKey)
77343:         frame.pinReg(key.reg());
77343: 
77343:     // Register to hold the computed slots pointer for the object. If we can
77343:     // hoist the initialized length check, we make the slots pointer loop
77343:     // invariant and never access the object itself.
77343:     RegisterID slotsReg;
77343:     analyze::CrossSSAValue objv(a->inlineIndex, analysis->poppedValue(PC, 2));
77343:     analyze::CrossSSAValue indexv(a->inlineIndex, analysis->poppedValue(PC, 1));
77343:     bool hoisted = loop && id->isType(JSVAL_TYPE_INT32) &&
77390:         loop->hoistArrayLengthCheck(DENSE_ARRAY, objv, indexv);
77343: 
82129:     MaybeJump initlenExit;
82129: 
77343:     if (hoisted) {
77343:         FrameEntry *slotsFe = loop->invariantArraySlots(objv);
77343:         slotsReg = frame.tempRegForData(slotsFe);
77343: 
77343:         frame.unpinEntry(vr);
77343:         if (pinKey)
77343:             frame.unpinReg(key.reg());
77343:     } else {
83231:         // Get a register for the object which we can clobber, and load its elements.
77343:         if (frame.haveSameBacking(obj, value)) {
83231:             slotsReg = frame.allocReg();
83231:             masm.move(vr.dataReg(), slotsReg);
77343:         } else if (frame.haveSameBacking(obj, id)) {
83231:             slotsReg = frame.allocReg();
83231:             masm.move(key.reg(), slotsReg);
77343:         } else {
83231:             slotsReg = frame.copyDataIntoReg(obj);
77343:         }
83231:         masm.loadPtr(Address(slotsReg, JSObject::offsetOfElements()), slotsReg);
77343: 
77343:         frame.unpinEntry(vr);
77343:         if (pinKey)
77343:             frame.unpinReg(key.reg());
77343: 
77343:         // Make an OOL path for setting exactly the initialized length.
77343:         Label syncTarget = stubcc.syncExitAndJump(Uses(3));
77343: 
83231:         Jump initlenGuard = masm.guardArrayExtent(ObjectElements::offsetOfInitializedLength(),
83231:                                                   slotsReg, key, Assembler::BelowOrEqual);
77343:         stubcc.linkExitDirect(initlenGuard, stubcc.masm.label());
77343: 
77343:         // Recheck for an exact initialized length. :TODO: would be nice to
77343:         // reuse the condition bits from the previous test.
83231:         Jump exactlenGuard = stubcc.masm.guardArrayExtent(ObjectElements::offsetOfInitializedLength(),
83231:                                                           slotsReg, key, Assembler::NotEqual);
77343:         exactlenGuard.linkTo(syncTarget, &stubcc.masm);
77343: 
77343:         // Check array capacity.
83231:         Jump capacityGuard = stubcc.masm.guardArrayExtent(ObjectElements::offsetOfCapacity(),
83231:                                                           slotsReg, key, Assembler::BelowOrEqual);
77343:         capacityGuard.linkTo(syncTarget, &stubcc.masm);
77343: 
77343:         // Bump the index for setting the array length.  The above guard
77343:         // ensures this won't overflow, due to NSLOTS_LIMIT.
77343:         stubcc.masm.bumpKey(key, 1);
77343: 
77343:         // Update the initialized length.
83231:         stubcc.masm.storeKey(key, Address(slotsReg, ObjectElements::offsetOfInitializedLength()));
77343: 
77343:         // Update the array length if needed.
83231:         Jump lengthGuard = stubcc.masm.guardArrayExtent(ObjectElements::offsetOfLength(),
83231:                                                         slotsReg, key, Assembler::AboveOrEqual);
83231:         stubcc.masm.storeKey(key, Address(slotsReg, ObjectElements::offsetOfLength()));
77343:         lengthGuard.linkTo(stubcc.masm.label(), &stubcc.masm);
77343: 
77343:         // Restore the index.
77343:         stubcc.masm.bumpKey(key, -1);
77343: 
82129:         initlenExit = stubcc.masm.jump();
77343:     }
77343: 
82129: #ifdef JSGC_INCREMENTAL_MJ
82129:     /*
82129:      * Write barrier.
82129:      * We skip over the barrier if we incremented initializedLength above,
82129:      * because in that case the slot we're overwriting was previously
82129:      * undefined.
82129:      */
82129:     types::TypeSet *types = frame.extra(obj).types;
82129:     if (cx->compartment->needsBarrier() && (!types || types->propertyNeedsBarrier(cx, JSID_VOID))) {
82129:         Label barrierStart = stubcc.masm.label();
82475:         stubcc.linkExitDirect(masm.jump(), barrierStart);
82475: 
82475:         /*
82475:          * The sync call below can potentially clobber key.reg() and slotsReg.
87606:          * So we save and restore them. Additionally, the WriteBarrier stub can
87606:          * clobber both registers. The rejoin call will restore key.reg() but
87606:          * not slotsReg. So we restore it again after the stub call.
82475:          */
82475:         stubcc.masm.storePtr(slotsReg, FrameAddress(offsetof(VMFrame, scratch)));
82475:         if (!key.isConstant())
87606:             stubcc.masm.push(key.reg());
82129:         frame.sync(stubcc.masm, Uses(3));
82475:         if (!key.isConstant())
87606:             stubcc.masm.pop(key.reg());
84671:         stubcc.masm.loadPtr(FrameAddress(offsetof(VMFrame, scratch)), slotsReg);
82475: 
82129:         if (key.isConstant())
82129:             stubcc.masm.lea(Address(slotsReg, key.index() * sizeof(Value)), Registers::ArgReg1);
82129:         else
82129:             stubcc.masm.lea(BaseIndex(slotsReg, key.reg(), masm.JSVAL_SCALE), Registers::ArgReg1);
82129:         OOL_STUBCALL(stubs::WriteBarrier, REJOIN_NONE);
82129:         stubcc.masm.loadPtr(FrameAddress(offsetof(VMFrame, scratch)), slotsReg);
82129:         stubcc.rejoin(Changes(0));
82129:     }
82129: #endif
82129: 
82129:     /* Jump over the write barrier in the initlen case. */
82129:     if (initlenExit.isSet())
82129:         stubcc.crossJump(initlenExit.get(), masm.label());
82129: 
77343:     // Fully store the value. :TODO: don't need to do this in the non-initlen case
77343:     // if the array is packed and monomorphic.
77343:     if (key.isConstant())
77343:         masm.storeValue(vr, Address(slotsReg, key.index() * sizeof(Value)));
77343:     else
77343:         masm.storeValue(vr, BaseIndex(slotsReg, key.reg(), masm.JSVAL_SCALE));
77343: 
77343:     stubcc.leave();
77343:     OOL_STUBCALL(STRICT_VARIANT(stubs::SetElem), REJOIN_FALLTHROUGH);
77343: 
77343:     if (!hoisted)
77343:         frame.freeReg(slotsReg);
77343:     frame.shimmy(2);
77343:     stubcc.rejoin(Changes(2));
77343: }
77343: 
77345: #ifdef JS_METHODJIT_TYPED_ARRAY
77344: void
77344: mjit::Compiler::convertForTypedArray(int atype, ValueRemat *vr, bool *allocated)
77344: {
77344:     FrameEntry *value = frame.peek(-1);
77344:     bool floatArray = (atype == TypedArray::TYPE_FLOAT32 ||
77344:                        atype == TypedArray::TYPE_FLOAT64);
77344:     *allocated = false;
77344: 
77344:     if (value->isConstant()) {
77344:         Value v = value->getValue();
77344:         if (floatArray) {
77344:             double d = v.isDouble() ? v.toDouble() : v.toInt32();
77344:             *vr = ValueRemat::FromConstant(DoubleValue(d));
77344:         } else {
77344:             int i32;
77344:             if (v.isInt32()) {
77344:                 i32 = v.toInt32();
77344:                 if (atype == TypedArray::TYPE_UINT8_CLAMPED)
77344:                     i32 = ClampIntForUint8Array(i32);
77344:             } else {
77344:                 i32 = (atype == TypedArray::TYPE_UINT8_CLAMPED)
77344:                     ? js_TypedArray_uint8_clamp_double(v.toDouble())
77344:                     : js_DoubleToECMAInt32(v.toDouble());
77344:             }
77344:             *vr = ValueRemat::FromConstant(Int32Value(i32));
77344:         }
77344:     } else {
77344:         if (floatArray) {
77344:             FPRegisterID fpReg;
77344:             MaybeJump notNumber = loadDouble(value, &fpReg, allocated);
77344:             if (notNumber.isSet())
77344:                 stubcc.linkExit(notNumber.get(), Uses(3));
77344: 
77344:             if (atype == TypedArray::TYPE_FLOAT32) {
77344:                 if (!*allocated) {
77344:                     frame.pinReg(fpReg);
77344:                     FPRegisterID newFpReg = frame.allocFPReg();
77344:                     masm.convertDoubleToFloat(fpReg, newFpReg);
77344:                     frame.unpinReg(fpReg);
77344:                     fpReg = newFpReg;
77344:                     *allocated = true;
77344:                 } else {
77344:                     masm.convertDoubleToFloat(fpReg, fpReg);
77344:                 }
77344:             }
77344:             *vr = ValueRemat::FromFPRegister(fpReg);
77344:         } else {
77344:             /*
77344:              * Allocate a register with the following properties:
77344:              * 1) For byte arrays the value must be in a byte register.
77344:              * 2) For Uint8ClampedArray the register must be writable.
84755:              * 3) If the value is definitely int32_t (and the array is not
77344:              *    Uint8ClampedArray) we don't have to allocate a new register.
77345:              * 4) If id and value have the same backing (e.g. arr[i] = i) and
77345:              *    we need a byte register, we have to allocate a new register
77345:              *    because we've already pinned a key register and can't use
77345:              *    tempRegInMaskForData.
77344:              */
77445:             MaybeRegisterID reg, dataReg;
77344:             bool needsByteReg = (atype == TypedArray::TYPE_INT8 ||
77344:                                  atype == TypedArray::TYPE_UINT8 ||
77344:                                  atype == TypedArray::TYPE_UINT8_CLAMPED);
77345:             FrameEntry *id = frame.peek(-2);
77345:             if (!value->isType(JSVAL_TYPE_INT32) || atype == TypedArray::TYPE_UINT8_CLAMPED ||
77345:                 (needsByteReg && frame.haveSameBacking(id, value))) {
77445:                 // Grab data register before branching.
77445:                 if (value->mightBeType(JSVAL_TYPE_INT32)) {
77345:                     dataReg = frame.tempRegForData(value);
77445: 
77445:                     // Make sure it's not clobbered by allocReg or tempRegForType.
77445:                     if (!frame.haveSameBacking(id, value))
77345:                         frame.pinReg(dataReg.reg());
77345:                 }
77345: 
77344:                 // x86 has 4 single byte registers. Worst case we've pinned 3
77344:                 // registers, one for each of object, key and value. This means
77344:                 // there must be at least one single byte register available.
77344:                 if (needsByteReg)
77344:                     reg = frame.allocReg(Registers::SingleByteRegs).reg();
77344:                 else
77344:                     reg = frame.allocReg();
77344:                 *allocated = true;
77344:             } else {
77344:                 if (needsByteReg)
77344:                     reg = frame.tempRegInMaskForData(value, Registers::SingleByteRegs).reg();
77344:                 else
77344:                     reg = frame.tempRegForData(value);
77344:             }
77344: 
77445:             // Get type register before branching.
77445:             MaybeRegisterID typeReg;
77445:             if (!value->isTypeKnown()) {
77445:                 // Note: we don't need to pin reg, it's never a temporary register if the
77445:                 // type of value is not known.
77445:                 JS_ASSERT(*allocated);
77445:                 typeReg = frame.tempRegForType(value);
77445:             }
77445: 
77344:             MaybeJump intDone;
77344:             if (value->mightBeType(JSVAL_TYPE_INT32)) {
77344:                 // Check if the value is an integer.
77344:                 MaybeJump notInt;
77344:                 if (!value->isTypeKnown()) {
77344:                     JS_ASSERT(*allocated);
77445:                     notInt = masm.testInt32(Assembler::NotEqual, typeReg.reg());
77344:                 }
77344: 
77445:                 if (*allocated) {
77445:                     masm.move(dataReg.reg(), reg.reg());
77445:                     if (!frame.haveSameBacking(id, value))
77445:                         frame.unpinReg(dataReg.reg());
77445:                 }
77344: 
77344:                 if (atype == TypedArray::TYPE_UINT8_CLAMPED)
77344:                     masm.clampInt32ToUint8(reg.reg());
77344: 
77344:                 if (notInt.isSet()) {
77344:                     intDone = masm.jump();
77344:                     notInt.get().linkTo(masm.label(), &masm);
77344:                 }
77344:             }
77344:             if (value->mightBeType(JSVAL_TYPE_DOUBLE)) {
77344:                 // Check if the value is a double.
77344:                 if (!value->isTypeKnown()) {
77445:                     Jump notNumber = masm.testDouble(Assembler::NotEqual, typeReg.reg());
77344:                     stubcc.linkExit(notNumber, Uses(3));
77344:                 }
77344: 
77344:                 // Load value in fpReg.
77344:                 FPRegisterID fpReg;
77344:                 if (value->isTypeKnown()) {
77344:                     fpReg = frame.tempFPRegForData(value);
77344:                 } else {
77344:                     fpReg = frame.allocFPReg();
77344:                     frame.loadDouble(value, fpReg, masm);
77344:                 }
77344: 
77344:                 // Convert double to integer.
77344:                 if (atype == TypedArray::TYPE_UINT8_CLAMPED) {
77344:                     if (value->isTypeKnown())
77344:                         frame.pinReg(fpReg);
77344:                     FPRegisterID fpTemp = frame.allocFPReg();
77344:                     if (value->isTypeKnown())
77344:                         frame.unpinReg(fpReg);
77344:                     masm.clampDoubleToUint8(fpReg, fpTemp, reg.reg());
77344:                     frame.freeReg(fpTemp);
77344:                 } else {
77344:                     Jump j = masm.branchTruncateDoubleToInt32(fpReg, reg.reg());
77344:                     stubcc.linkExit(j, Uses(3));
77344:                 }
77344:                 if (!value->isTypeKnown())
77344:                     frame.freeReg(fpReg);
77344:             }
77344:             if (intDone.isSet())
77344:                 intDone.get().linkTo(masm.label(), &masm);
77344:             *vr = ValueRemat::FromKnownType(JSVAL_TYPE_INT32, reg.reg());
77344:         }
77344:     }
77344: }
77345: 
77344: void
77344: mjit::Compiler::jsop_setelem_typed(int atype)
77344: {
77344:     FrameEntry *obj = frame.peek(-3);
77344:     FrameEntry *id = frame.peek(-2);
77344:     FrameEntry *value = frame.peek(-1);
77344: 
77344:     // We might not know whether this is an object, but if it is an object we
77344:     // know it's a typed array.
77344:     if (!obj->isTypeKnown()) {
77344:         Jump guard = frame.testObject(Assembler::NotEqual, obj);
77344:         stubcc.linkExit(guard, Uses(3));
77344:     }
77344: 
81336:     if (id->isType(JSVAL_TYPE_DOUBLE))
81336:         tryConvertInteger(id, Uses(2));
81336: 
77344:     // Test for integer index.
77344:     if (!id->isTypeKnown()) {
77344:         Jump guard = frame.testInt32(Assembler::NotEqual, id);
77344:         stubcc.linkExit(guard, Uses(3));
77344:     }
77344: 
77345:     // Pin value.
77345:     ValueRemat vr;
77345:     frame.pinEntry(value, vr, /* breakDouble = */ false);
77344: 
77344:     // Allocate and pin object and key regs.
77344:     Int32Key key = id->isConstant()
77344:                  ? Int32Key::FromConstant(id->getValue().toInt32())
77344:                  : Int32Key::FromRegister(frame.tempRegForData(id));
77344: 
77344:     bool pinKey = !key.isConstant() && !frame.haveSameBacking(id, value);
77344:     if (pinKey)
77344:         frame.pinReg(key.reg());
77390: 
77390:     analyze::CrossSSAValue objv(a->inlineIndex, analysis->poppedValue(PC, 1));
77390:     analyze::CrossSSAValue indexv(a->inlineIndex, analysis->poppedValue(PC, 0));
77390:     bool hoisted = loop && id->isType(JSVAL_TYPE_INT32) &&
77390:         loop->hoistArrayLengthCheck(TYPED_ARRAY, objv, indexv);
77390: 
77390:     RegisterID objReg;
77390:     if (hoisted) {
77390:         FrameEntry *slotsFe = loop->invariantArraySlots(objv);
77390:         objReg = frame.tempRegForData(slotsFe);
77390:         frame.pinReg(objReg);
77390:     } else {
77390:         objReg = frame.copyDataIntoReg(obj);
77344: 
77344:         // Bounds check.
80867:         int lengthOffset = TypedArray::lengthOffset() + offsetof(jsval_layout, s.payload);
80867:         Jump lengthGuard = masm.guardArrayExtent(lengthOffset,
77344:                                                  objReg, key, Assembler::BelowOrEqual);
77344:         stubcc.linkExit(lengthGuard, Uses(3));
77344: 
77344:         // Load the array's packed data vector.
77415:         masm.loadPtr(Address(objReg, TypedArray::dataOffset()), objReg);
77390:     }
77344: 
77345:     // Unpin value so that convertForTypedArray can assign a new data
77345:     // register using tempRegInMaskForData.
77345:     frame.unpinEntry(vr);
77345: 
77345:     // Make sure key is pinned.
77345:     if (frame.haveSameBacking(id, value)) {
77345:         frame.pinReg(key.reg());
77345:         pinKey = true;
77345:     }
77345:     JS_ASSERT(pinKey == !id->isConstant());
77345: 
77344:     bool allocated;
77344:     convertForTypedArray(atype, &vr, &allocated);
77344: 
77344:     // Store the value.
77344:     masm.storeToTypedArray(atype, objReg, key, vr);
77344:     if (allocated) {
77344:         if (vr.isFPRegister())
77344:             frame.freeReg(vr.fpReg());
77344:         else
77344:             frame.freeReg(vr.dataReg());
77344:     }
77344:     if (pinKey)
77344:         frame.unpinReg(key.reg());
77390:     if (hoisted)
77390:         frame.unpinReg(objReg);
77390:     else
77344:         frame.freeReg(objReg);
77344: 
77344:     stubcc.leave();
77344:     OOL_STUBCALL(STRICT_VARIANT(stubs::SetElem), REJOIN_FALLTHROUGH);
77344: 
77344:     frame.shimmy(2);
77344:     stubcc.rejoin(Changes(2));
77344: }
77345: #endif /* JS_METHODJIT_TYPED_ARRAY */
77344: 
81336: void
81336: mjit::Compiler::tryConvertInteger(FrameEntry *fe, Uses uses)
81336: {
81336:     JS_ASSERT(fe->isType(JSVAL_TYPE_DOUBLE));
81336: 
81336:     JumpList isDouble;
81336:     FPRegisterID fpreg = frame.tempFPRegForData(fe);
81336:     RegisterID reg = frame.allocReg();
81336:     masm.branchConvertDoubleToInt32(fpreg, reg, isDouble, Registers::FPConversionTemp);
81336:     Jump j = masm.jump();
81336:     isDouble.linkTo(masm.label(), &masm);
81336:     stubcc.linkExit(masm.jump(), uses);
81336:     j.linkTo(masm.label(), &masm);
81336:     frame.learnType(fe, JSVAL_TYPE_INT32, reg);
81336: }
81336: 
83321: /* Get the common shape used by all dense arrays with a prototype at globalObj. */
83321: static inline Shape *
83321: GetDenseArrayShape(JSContext *cx, JSObject *globalObj)
83321: {
83321:     JS_ASSERT(globalObj);
83321: 
83321:     JSObject *proto;
83321:     if (!js_GetClassPrototype(cx, globalObj, JSProto_Array, &proto, NULL))
84159:         return NULL;
83321: 
83321:     return EmptyShape::getInitialShape(cx, &ArrayClass, proto,
83321:                                        proto->getParent(), gc::FINALIZE_OBJECT0);
83321: }
83321: 
57671: bool
60164: mjit::Compiler::jsop_setelem(bool popGuaranteed)
52838: {
52838:     FrameEntry *obj = frame.peek(-3);
52838:     FrameEntry *id = frame.peek(-2);
57671:     FrameEntry *value = frame.peek(-1);
52838: 
77343:     if (!IsCacheableSetElem(obj, id, value) || monitored(PC)) {
52838:         jsop_setelem_slow();
57671:         return true;
52838:     }
52838: 
77343:     frame.forgetMismatchedObject(obj);
77343: 
77344:     // If the object is definitely a dense array or a typed array we can generate
77344:     // code directly without using an inline cache.
81336:     if (cx->typeInferenceEnabled()) {
77343:         types::TypeSet *types = analysis->poppedTypes(PC, 2);
77344: 
77344:         if (!types->hasObjectFlags(cx, types::OBJECT_FLAG_NON_DENSE_ARRAY) &&
86292:             !types::ArrayPrototypeHasIndexedProperty(cx, outerScript)) {
77344:             // Inline dense array path.
77343:             jsop_setelem_dense();
77343:             return true;
77343:         }
77345: 
77345: #ifdef JS_METHODJIT_TYPED_ARRAY
77346:         if ((value->mightBeType(JSVAL_TYPE_INT32) || value->mightBeType(JSVAL_TYPE_DOUBLE)) &&
77347:             !types->hasObjectFlags(cx, types::OBJECT_FLAG_NON_TYPED_ARRAY)) {
77347:             // Inline typed array path.
77347:             int atype = types->getTypedArrayType(cx);
77347:             if (atype != TypedArray::TYPE_MAX) {
77344:                 jsop_setelem_typed(atype);
77344:                 return true;
77344:             }
77347:         }
77345: #endif
77343:     }
77343: 
83321:     if (id->isType(JSVAL_TYPE_DOUBLE) || !globalObj) {
81336:         jsop_setelem_slow();
81336:         return true;
81336:     }
81336: 
82129: #ifdef JSGC_INCREMENTAL_MJ
82129:     // Write barrier.
82129:     if (cx->compartment->needsBarrier()) {
82129:         jsop_setelem_slow();
82129:         return true;
82129:     }
82129: #endif
82129: 
57671:     SetElementICInfo ic = SetElementICInfo(JSOp(*PC));
57671: 
57671:     // One by one, check if the most important stack entries have registers,
57671:     // and if so, pin them. This is to avoid spilling and reloading from the
57671:     // stack as we incrementally allocate other registers.
57671:     MaybeRegisterID pinnedValueType = frame.maybePinType(value);
57671:     MaybeRegisterID pinnedValueData = frame.maybePinData(value);
57671: 
57671:     // Pin |obj| if it doesn't share a backing with |value|.
57671:     MaybeRegisterID pinnedObjData;
57671:     if (!obj->hasSameBacking(value))
57671:         pinnedObjData = frame.maybePinData(obj);
57671: 
57671:     // Pin |id| if it doesn't share a backing with |value|.
57671:     MaybeRegisterID pinnedIdData;
57671:     if (!id->hasSameBacking(value))
57671:         pinnedIdData = frame.maybePinData(id);
57671: 
57671:     // Note: The fact that |obj| and |value|, or |id| and |value| can be
57671:     // copies, is a little complicated, but it is safe. Explanations
57671:     // follow at each point. Keep in mind two points:
57671:     //  1) maybePin() never allocates a register, it only pins if a register
57671:     //     already existed.
57671:     //  2) tempRegForData() will work fine on a pinned register.
57671:  
57671:     // Guard that the object is an object.
57671:     if (!obj->isTypeKnown()) {
57671:         Jump j = frame.testObject(Assembler::NotEqual, obj);
57671:         stubcc.linkExit(j, Uses(3));
57671:     }
57671: 
57671:     // Guard that the id is int32.
52838:     if (!id->isTypeKnown()) {
52838:         Jump j = frame.testInt32(Assembler::NotEqual, id);
53088:         stubcc.linkExit(j, Uses(3));
52838:     }
52838: 
57671:     // Grab a register for the object. It's safe to unpin |obj| because it
57671:     // won't have been pinned if it shares a backing with |value|. However,
57671:     // it would not be safe to copyDataIntoReg() if the value was pinned,
57671:     // since this could evict the register. So we special case.
57671:     frame.maybeUnpinReg(pinnedObjData);
57671:     if (obj->hasSameBacking(value) && pinnedValueData.isSet()) {
57671:         ic.objReg = frame.allocReg();
57671:         masm.move(pinnedValueData.reg(), ic.objReg);
57671:     } else {
57671:         ic.objReg = frame.copyDataIntoReg(obj);
52838:     }
52838: 
57671:     // pinEntry() will ensure pinned registers for |value|. To avoid a
57671:     // double-pin assert, first unpin any registers that |value| had.
57671:     frame.maybeUnpinReg(pinnedValueType);
57671:     frame.maybeUnpinReg(pinnedValueData);
57671:     frame.pinEntry(value, ic.vr);
52838: 
57671:     // Store rematerialization information about the key. This is the final
57671:     // register we allocate, and thus it can use tempRegForData() without
57671:     // the worry of being spilled. Once again, this is safe even if |id|
57671:     // shares a backing with |value|, because tempRegForData() will work on
57671:     // the pinned register, and |pinnedIdData| will not double-pin.
57671:     frame.maybeUnpinReg(pinnedIdData);
57671:     if (id->isConstant())
57671:         ic.key = Int32Key::FromConstant(id->getValue().toInt32());
57671:     else
57671:         ic.key = Int32Key::FromRegister(frame.tempRegForData(id));
53227: 
57671:     // Unpin the value since register allocation is complete.
57671:     frame.unpinEntry(ic.vr);
57671: 
57671:     // Now it's also safe to grab remat info for obj (all exits that can
57671:     // generate stubs must have the same register state).
57671:     ic.objRemat = frame.dataRematInfo(obj);
57671: 
57671:     // All patchable guards must occur after this point.
60597:     RESERVE_IC_SPACE(masm);
57671:     ic.fastPathStart = masm.label();
57671: 
57671:     // Create the common out-of-line sync block, taking care to link previous
57671:     // guards here after.
60597:     RESERVE_OOL_SPACE(stubcc.masm);
57671:     ic.slowPathStart = stubcc.syncExit(Uses(3));
57671: 
57671:     // Guard obj is a dense array.
83321:     Shape *shape = GetDenseArrayShape(cx, globalObj);
83321:     if (!shape)
83321:         return false;
83321:     ic.shapeGuard = masm.guardShape(ic.objReg, shape);
83222:     stubcc.linkExitDirect(ic.shapeGuard, ic.slowPathStart);
79680: 
83231:     // Load the dynamic elements vector.
83231:     masm.loadPtr(Address(ic.objReg, JSObject::offsetOfElements()), ic.objReg);
57671: 
77343:     // Guard in range of initialized length.
83231:     Jump initlenGuard = masm.guardArrayExtent(ObjectElements::offsetOfInitializedLength(),
77343:                                               ic.objReg, ic.key, Assembler::BelowOrEqual);
77343:     stubcc.linkExitDirect(initlenGuard, ic.slowPathStart);
57671: 
57671:     // Guard there's no hole, then store directly to the slot.
57671:     if (ic.key.isConstant()) {
57671:         Address slot(ic.objReg, ic.key.index() * sizeof(Value));
57671:         ic.holeGuard = masm.guardNotHole(slot);
57671:         masm.storeValue(ic.vr, slot);
53227:     } else {
57671:         BaseIndex slot(ic.objReg, ic.key.reg(), Assembler::JSVAL_SCALE);
57671:         ic.holeGuard = masm.guardNotHole(slot);
57671:         masm.storeValue(ic.vr, slot);
53227:     }
57671:     stubcc.linkExitDirect(ic.holeGuard, ic.slowPathStart);
52838: 
52838:     stubcc.leave();
60598: #if defined JS_POLYIC
57671:     passICAddress(&ic);
77343:     ic.slowPathCall = OOL_STUBCALL(STRICT_VARIANT(ic::SetElement), REJOIN_FALLTHROUGH);
57671: #else
77343:     OOL_STUBCALL(STRICT_VARIANT(stubs::SetElem), REJOIN_FALLTHROUGH);
53162: #endif
53228: 
57671:     ic.fastPathRejoin = masm.label();
53228: 
60164:     // When generating typed array stubs, it may be necessary to call
60164:     // js_DoubleToECMAInt32(), which would clobber registers. To deal with
60164:     // this, we tell the IC exactly which registers need to be saved
60164:     // across calls.
62019:     ic.volatileMask = frame.regsInUse();
60164: 
60164:     // If the RHS will be popped, and doesn't overlap any live values, then
60164:     // there's no need to save it across calls. Note that this is not true of
60164:     // |obj| or |key|, which will be used to compute the LHS reference for
60164:     // assignment.
60164:     //
60164:     // Note that the IC wants to clobber |vr.dataReg| to convert for typed
60164:     // arrays. If this clobbering is necessary, we must preserve dataReg,
60164:     // even if it's not in a volatile register.
60164:     if (popGuaranteed &&
60164:         !ic.vr.isConstant() &&
60164:         !value->isCopy() &&
60164:         !frame.haveSameBacking(value, obj) &&
60164:         !frame.haveSameBacking(value, id))
60164:     {
60164:         ic.volatileMask &= ~Registers::maskReg(ic.vr.dataReg());
60164:         if (!ic.vr.isTypeKnown())
60164:             ic.volatileMask &= ~Registers::maskReg(ic.vr.typeReg());
60164:     } else if (!ic.vr.isConstant()) {
60164:         ic.volatileMask |= Registers::maskReg(ic.vr.dataReg());
60164:     }
60164: 
57671:     frame.freeReg(ic.objReg);
57671:     frame.shimmy(2);
57671:     stubcc.rejoin(Changes(2));
53228: 
60598: #if defined JS_POLYIC
57671:     if (!setElemICs.append(ic))
57671:         return false;
57671: #endif
53228: 
56831:     return true;
56831: }
56831: 
56766: static inline bool
56766: IsCacheableGetElem(FrameEntry *obj, FrameEntry *id)
56766: {
53137:     if (id->isTypeKnown() &&
81336:         !(id->isType(JSVAL_TYPE_INT32) || id->isType(JSVAL_TYPE_DOUBLE)
60598: #if defined JS_POLYIC
81336:           || id->isType(JSVAL_TYPE_STRING)
53137: #endif
53137:          )) {
56766:         return false;
53137:     }
53137: 
81336:     if (id->isType(JSVAL_TYPE_DOUBLE) && id->isConstant())
81336:         return false;
81336: 
81336:     if (id->isType(JSVAL_TYPE_INT32) && id->isConstant() &&
53137:         id->getValue().toInt32() < 0) {
56766:         return false;
56766:     }
56766: 
57671:     // obj[obj] is not allowed, since it will never optimize.
57671:     if (obj->hasSameBacking(id))
57671:         return false;
57671: 
56766:     return true;
56766: }
56766: 
77343: void
77343: mjit::Compiler::jsop_getelem_dense(bool isPacked)
77343: {
77343:     FrameEntry *obj = frame.peek(-2);
77343:     FrameEntry *id = frame.peek(-1);
77343: 
77343:     // We might not know whether this is an object, but if it is an object we
77343:     // know it is a dense array.
77343:     if (!obj->isTypeKnown()) {
77343:         Jump guard = frame.testObject(Assembler::NotEqual, obj);
77343:         stubcc.linkExit(guard, Uses(2));
77343:     }
77343: 
81336:     if (id->isType(JSVAL_TYPE_DOUBLE))
81336:         tryConvertInteger(id, Uses(2));
81336: 
77343:     // Test for integer index.
77343:     if (!id->isTypeKnown()) {
77343:         Jump guard = frame.testInt32(Assembler::NotEqual, id);
77343:         stubcc.linkExit(guard, Uses(2));
77343:     }
77343: 
77343:     JSValueType type = knownPushedType(0);
77343: 
77343:     // Allocate registers.
77343: 
77343:     // If we know the result of the GETELEM may be undefined, then misses on the
77343:     // initialized length or hole checks can just produce an undefined value.
77343:     // We checked in the caller that prototypes do not have indexed properties.
77343:     bool allowUndefined = mayPushUndefined(0);
77343: 
77343:     analyze::CrossSSAValue objv(a->inlineIndex, analysis->poppedValue(PC, 1));
77343:     analyze::CrossSSAValue indexv(a->inlineIndex, analysis->poppedValue(PC, 0));
77343:     bool hoisted = loop && id->isType(JSVAL_TYPE_INT32) &&
77390:         loop->hoistArrayLengthCheck(DENSE_ARRAY, objv, indexv);
77343: 
77343:     // Get a register with either the object or its slots, depending on whether
83231:     // we are hoisting the slots computation.
77343:     RegisterID baseReg;
77343:     if (hoisted) {
77343:         FrameEntry *slotsFe = loop->invariantArraySlots(objv);
77343:         baseReg = frame.tempRegForData(slotsFe);
77343:     } else {
77343:         baseReg = frame.tempRegForData(obj);
77343:     }
77343:     frame.pinReg(baseReg);
77343: 
77343:     Int32Key key = id->isConstant()
77343:                  ? Int32Key::FromConstant(id->getValue().toInt32())
77343:                  : Int32Key::FromRegister(frame.tempRegForData(id));
77343:     bool pinKey = !key.isConstant() && key.reg() != baseReg;
77343:     if (pinKey)
77343:         frame.pinReg(key.reg());
77343: 
77343:     RegisterID dataReg = frame.allocReg();
77343: 
77343:     MaybeRegisterID typeReg;
77343:     if (type == JSVAL_TYPE_UNKNOWN || type == JSVAL_TYPE_DOUBLE || hasTypeBarriers(PC))
77343:         typeReg = frame.allocReg();
77343: 
77343:     frame.unpinReg(baseReg);
77343:     if (pinKey)
77343:         frame.unpinReg(key.reg());
77343: 
77343:     RegisterID slotsReg;
77343:     if (hoisted) {
77343:         slotsReg = baseReg;
77343:     } else {
83231:         masm.loadPtr(Address(baseReg, JSObject::offsetOfElements()), dataReg);
83231:         slotsReg = dataReg;
83231:     }
83231: 
83231:     // Guard on the array's initialized length.
83231:     MaybeJump initlenGuard;
83231:     if (!hoisted) {
83231:         initlenGuard = masm.guardArrayExtent(ObjectElements::offsetOfInitializedLength(),
83231:                                              slotsReg, key, Assembler::BelowOrEqual);
77343:         if (!allowUndefined)
77343:             stubcc.linkExit(initlenGuard.get(), Uses(2));
77343:     }
77343: 
77343:     // Get the slot, skipping the hole check if the array is known to be packed.
77343:     Jump holeCheck;
77343:     if (key.isConstant()) {
77343:         Address slot(slotsReg, key.index() * sizeof(Value));
77343:         holeCheck = masm.fastArrayLoadSlot(slot, !isPacked, typeReg, dataReg);
77343:     } else {
77343:         JS_ASSERT(key.reg() != dataReg);
77343:         BaseIndex slot(slotsReg, key.reg(), masm.JSVAL_SCALE);
77343:         holeCheck = masm.fastArrayLoadSlot(slot, !isPacked, typeReg, dataReg);
77343:     }
77343: 
77343:     if (!isPacked && !allowUndefined)
77343:         stubcc.linkExit(holeCheck, Uses(2));
77343: 
77343:     stubcc.leave();
77343:     OOL_STUBCALL(stubs::GetElem, REJOIN_FALLTHROUGH);
78456:     testPushedType(REJOIN_FALLTHROUGH, -2);
77343: 
77343:     frame.popn(2);
77343: 
77343:     BarrierState barrier;
77343:     if (typeReg.isSet()) {
77343:         frame.pushRegs(typeReg.reg(), dataReg, type);
77343:         barrier = testBarrier(typeReg.reg(), dataReg, false);
77343:     } else {
77343:         frame.pushTypedPayload(type, dataReg);
77343:     }
77343: 
77343:     stubcc.rejoin(Changes(2));
77343: 
77343:     if (allowUndefined) {
77343:         if (!hoisted)
77343:             stubcc.linkExitDirect(initlenGuard.get(), stubcc.masm.label());
77343:         if (!isPacked)
77343:             stubcc.linkExitDirect(holeCheck, stubcc.masm.label());
77343:         JS_ASSERT(type == JSVAL_TYPE_UNKNOWN || type == JSVAL_TYPE_UNDEFINED);
77343:         if (type == JSVAL_TYPE_UNDEFINED)
77343:             stubcc.masm.loadValuePayload(UndefinedValue(), dataReg);
77343:         else
77343:             stubcc.masm.loadValueAsComponents(UndefinedValue(), typeReg.reg(), dataReg);
77343:         stubcc.linkRejoin(stubcc.masm.jump());
77343:     }
77343: 
77343:     finishBarrier(barrier, REJOIN_FALLTHROUGH, 0);
77343: }
77343: 
77343: void
77343: mjit::Compiler::jsop_getelem_args()
77343: {
77343:     FrameEntry *id = frame.peek(-1);
77343: 
81336:     if (id->isType(JSVAL_TYPE_DOUBLE))
81336:         tryConvertInteger(id, Uses(2));
81336: 
77343:     // Test for integer index.
77343:     if (!id->isTypeKnown()) {
77343:         Jump guard = frame.testInt32(Assembler::NotEqual, id);
77343:         stubcc.linkExit(guard, Uses(2));
77343:     }
77343: 
77343:     // Allocate registers.
77343: 
77343:     analyze::CrossSSAValue indexv(a->inlineIndex, analysis->poppedValue(PC, 0));
77343:     bool hoistedLength = loop && id->isType(JSVAL_TYPE_INT32) &&
77343:         loop->hoistArgsLengthCheck(indexv);
77343:     FrameEntry *actualsFe = loop ? loop->invariantArguments() : NULL;
77343: 
77343:     Int32Key key = id->isConstant()
77343:                  ? Int32Key::FromConstant(id->getValue().toInt32())
77343:                  : Int32Key::FromRegister(frame.tempRegForData(id));
77343:     if (!key.isConstant())
77343:         frame.pinReg(key.reg());
77343: 
77343:     RegisterID dataReg = frame.allocReg();
77343:     RegisterID typeReg = frame.allocReg();
77343: 
77343:     // Guard on nactual.
77343:     if (!hoistedLength) {
87583:         Address nactualAddr(JSFrameReg, StackFrame::offsetOfNumActual());
77343:         MaybeJump rangeGuard;
77343:         if (key.isConstant()) {
77343:             JS_ASSERT(key.index() >= 0);
77343:             rangeGuard = masm.branch32(Assembler::BelowOrEqual, nactualAddr, Imm32(key.index()));
77343:         } else {
77343:             rangeGuard = masm.branch32(Assembler::BelowOrEqual, nactualAddr, key.reg());
77343:         }
77343:         stubcc.linkExit(rangeGuard.get(), Uses(2));
77343:     }
77343: 
77343:     RegisterID actualsReg;
77343:     if (actualsFe) {
77343:         actualsReg = frame.tempRegForData(actualsFe);
77343:     } else {
77343:         actualsReg = dataReg;
77391:         masm.loadFrameActuals(outerScript->function(), actualsReg);
77343:     }
77343: 
77515:     if (!key.isConstant())
77515:         frame.unpinReg(key.reg());
77515: 
77343:     if (key.isConstant()) {
77343:         Address arg(actualsReg, key.index() * sizeof(Value));
77343:         masm.loadValueAsComponents(arg, typeReg, dataReg);
77343:     } else {
77343:         JS_ASSERT(key.reg() != dataReg);
77343:         BaseIndex arg(actualsReg, key.reg(), masm.JSVAL_SCALE);
77343:         masm.loadValueAsComponents(arg, typeReg, dataReg);
77343:     }
77343: 
77343:     stubcc.leave();
77343:     OOL_STUBCALL(stubs::GetElem, REJOIN_FALLTHROUGH);
78456:     testPushedType(REJOIN_FALLTHROUGH, -2);
77343: 
77343:     frame.popn(2);
77343:     frame.pushRegs(typeReg, dataReg, knownPushedType(0));
77343:     BarrierState barrier = testBarrier(typeReg, dataReg, false);
77343: 
77343:     stubcc.rejoin(Changes(2));
77343: 
77343:     finishBarrier(barrier, REJOIN_FALLTHROUGH, 0);
77343: }
77343: 
77345: #ifdef JS_METHODJIT_TYPED_ARRAY
77442: bool
77344: mjit::Compiler::jsop_getelem_typed(int atype)
77344: {
77442:     // Unlike dense arrays, the types of elements in typed arrays are not
77442:     // guaranteed to be present in the object's type, and we need to use
77442:     // knowledge about the possible contents of the array vs. the types
77442:     // that have been read out of it to figure out how to do the load.
77442: 
77442:     //                          Array contents
84755:     //                   Float     Uint32_t         Int32
77442:     // Observed types
77442:     //
77442:     // {int}             XXX       reg pair+test  reg
77442:     // {int,float}       FP reg    FP reg         reg pair
77442:     // {X,int}           XXX       reg pair+test  reg pair
77442:     // {X,int,float}     reg pair  reg pair       reg pair
77442:     // {X}               XXX       XXX            XXX
77442: 
77442:     // Reject entries marked 'XXX' above, and compile a normal GETELEM.
77442:     types::TypeSet *pushedTypes = pushedTypeSet(0);
77442:     if (atype == TypedArray::TYPE_FLOAT32 || atype == TypedArray::TYPE_FLOAT64) {
77442:         if (!pushedTypes->hasType(types::Type::DoubleType()))
77442:             return false;
77442:     } else {
77442:         if (!pushedTypes->hasType(types::Type::Int32Type()))
77442:             return false;
77442:     }
77442: 
77344:     FrameEntry *obj = frame.peek(-2);
77344:     FrameEntry *id = frame.peek(-1);
77344: 
77344:     // We might not know whether this is an object, but if it's an object we
77344:     // know it is a typed array.
77344:     if (!obj->isTypeKnown()) {
77344:         Jump guard = frame.testObject(Assembler::NotEqual, obj);
77344:         stubcc.linkExit(guard, Uses(2));
77344:     }
77344: 
81336:     if (id->isType(JSVAL_TYPE_DOUBLE))
81336:         tryConvertInteger(id, Uses(2));
81336: 
77344:     // Test for integer index.
77344:     if (!id->isTypeKnown()) {
77344:         Jump guard = frame.testInt32(Assembler::NotEqual, id);
77344:         stubcc.linkExit(guard, Uses(2));
77344:     }
77344: 
77344:     // Load object and key.
77344:     Int32Key key = id->isConstant()
77344:                  ? Int32Key::FromConstant(id->getValue().toInt32())
77344:                  : Int32Key::FromRegister(frame.tempRegForData(id));
77344:     if (!key.isConstant())
77344:         frame.pinReg(key.reg());
77390: 
77390:     analyze::CrossSSAValue objv(a->inlineIndex, analysis->poppedValue(PC, 1));
77390:     analyze::CrossSSAValue indexv(a->inlineIndex, analysis->poppedValue(PC, 0));
77390:     bool hoisted = loop && id->isType(JSVAL_TYPE_INT32) &&
77390:         loop->hoistArrayLengthCheck(TYPED_ARRAY, objv, indexv);
77390: 
77390:     RegisterID objReg;
77390:     if (hoisted) {
77390:         FrameEntry *slotsFe = loop->invariantArraySlots(objv);
77390:         objReg = frame.tempRegForData(slotsFe);
77390:         frame.pinReg(objReg);
77390:     } else {
77390:         objReg = frame.copyDataIntoReg(obj);
77390: 
77390:         // Bounds check.
80867:         int lengthOffset = TypedArray::lengthOffset() + offsetof(jsval_layout, s.payload);
80867:         Jump lengthGuard = masm.guardArrayExtent(lengthOffset,
77390:                                                  objReg, key, Assembler::BelowOrEqual);
77390:         stubcc.linkExit(lengthGuard, Uses(2));
77390: 
77390:         // Load the array's packed data vector.
77415:         masm.loadPtr(Address(objReg, TypedArray::dataOffset()), objReg);
77390:     }
77344: 
77344:     // We can load directly into an FP-register if the following conditions
77344:     // are met:
77344:     // 1) The array is an Uint32Array or a float array (loadFromTypedArray
77344:     //    can't load into an FP-register for other arrays).
77344:     // 2) The result is definitely a double (the result type set can include
77344:     //    other types after reading out-of-bound values).
77344:     AnyRegisterID dataReg;
77344:     MaybeRegisterID typeReg, tempReg;
77344:     JSValueType type = knownPushedType(0);
77344:     bool maybeReadFloat = (atype == TypedArray::TYPE_FLOAT32 ||
77344:                            atype == TypedArray::TYPE_FLOAT64 ||
77344:                            atype == TypedArray::TYPE_UINT32);
77362:     if (maybeReadFloat && type == JSVAL_TYPE_DOUBLE) {
77344:         dataReg = frame.allocFPReg();
84755:         // Need an extra reg to convert uint32_t to double.
77344:         if (atype == TypedArray::TYPE_UINT32)
77344:             tempReg = frame.allocReg();
77344:     } else {
77344:         dataReg = frame.allocReg();
77344:         // loadFromTypedArray expects a type register for Uint32Array or
77344:         // float arrays. Also allocate a type register if the result may not
84755:         // be int32_t (due to reading out-of-bound values) or if there's a
77344:         // type barrier.
77362:         if (maybeReadFloat || type != JSVAL_TYPE_INT32)
77344:             typeReg = frame.allocReg();
77344:     }
77344: 
77344:     // Load value from the array.
77344:     masm.loadFromTypedArray(atype, objReg, key, typeReg, dataReg, tempReg);
77344: 
77390:     if (hoisted)
77390:         frame.unpinReg(objReg);
77390:     else
77344:         frame.freeReg(objReg);
77344:     if (!key.isConstant())
77344:         frame.unpinReg(key.reg());
77344:     if (tempReg.isSet())
77344:         frame.freeReg(tempReg.reg());
77344: 
77442:     if (atype == TypedArray::TYPE_UINT32 &&
77442:         !pushedTypes->hasType(types::Type::DoubleType())) {
77442:         Jump isDouble = masm.testDouble(Assembler::Equal, typeReg.reg());
77442:         stubcc.linkExit(isDouble, Uses(2));
77442:     }
77442: 
77344:     stubcc.leave();
77344:     OOL_STUBCALL(stubs::GetElem, REJOIN_FALLTHROUGH);
78456:     testPushedType(REJOIN_FALLTHROUGH, -2);
77344: 
77344:     frame.popn(2);
77344: 
80962:     BarrierState barrier;
77344:     if (dataReg.isFPReg()) {
77344:         frame.pushDouble(dataReg.fpreg());
77344:     } else if (typeReg.isSet()) {
77344:         frame.pushRegs(typeReg.reg(), dataReg.reg(), knownPushedType(0));
77344:     } else {
77344:         JS_ASSERT(type == JSVAL_TYPE_INT32);
77344:         frame.pushTypedPayload(JSVAL_TYPE_INT32, dataReg.reg());
77344:     }
77344:     stubcc.rejoin(Changes(2));
77344: 
80962:     finishBarrier(barrier, REJOIN_FALLTHROUGH, 0);
80962: 
77442:     return true;
77344: }
77345: #endif /* JS_METHODJIT_TYPED_ARRAY */
77344: 
56766: bool
86855: mjit::Compiler::jsop_getelem()
56766: {
56766:     FrameEntry *obj = frame.peek(-2);
56766:     FrameEntry *id = frame.peek(-1);
56766: 
56766:     if (!IsCacheableGetElem(obj, id)) {
53137:         jsop_getelem_slow();
56037:         return true;
53137:     }
53137: 
77344:     // If the object is definitely an arguments object, a dense array or a typed array
77344:     // we can generate code directly without using an inline cache.
86855:     if (cx->typeInferenceEnabled() && !id->isType(JSVAL_TYPE_STRING)) {
77343:         types::TypeSet *types = analysis->poppedTypes(PC, 1);
77391:         if (types->isLazyArguments(cx) && !outerScript->analysis()->modifiesArguments()) {
80962:             // Inline arguments path.
77343:             jsop_getelem_args();
77343:             return true;
77343:         }
77345: 
77343:         if (obj->mightBeType(JSVAL_TYPE_OBJECT) &&
77343:             !types->hasObjectFlags(cx, types::OBJECT_FLAG_NON_DENSE_ARRAY) &&
86292:             !types::ArrayPrototypeHasIndexedProperty(cx, outerScript)) {
77344:             // Inline dense array path.
77343:             bool packed = !types->hasObjectFlags(cx, types::OBJECT_FLAG_NON_PACKED_ARRAY);
77343:             jsop_getelem_dense(packed);
77343:             return true;
77343:         }
77345: 
77345: #ifdef JS_METHODJIT_TYPED_ARRAY
77344:         if (obj->mightBeType(JSVAL_TYPE_OBJECT) &&
77442:             !types->hasObjectFlags(cx, types::OBJECT_FLAG_NON_TYPED_ARRAY)) {
77347:             // Inline typed array path.
77347:             int atype = types->getTypedArrayType(cx);
77347:             if (atype != TypedArray::TYPE_MAX) {
77442:                 if (jsop_getelem_typed(atype))
77344:                     return true;
77442:                 // Fallthrough to the normal GETELEM path.
77344:             }
77347:         }
77345: #endif
77343:     }
77343: 
77343:     frame.forgetMismatchedObject(obj);
77343: 
83321:     if (id->isType(JSVAL_TYPE_DOUBLE) || !globalObj) {
81336:         jsop_getelem_slow();
81336:         return true;
81336:     }
81336: 
56738:     GetElementICInfo ic = GetElementICInfo(JSOp(*PC));
56738: 
56738:     // Pin the top of the stack to avoid spills, before allocating registers.
56738:     MaybeRegisterID pinnedIdData = frame.maybePinData(id);
56738:     MaybeRegisterID pinnedIdType = frame.maybePinType(id);
56738: 
56738:     MaybeJump objTypeGuard;
56738:     if (!obj->isTypeKnown()) {
56738:         // Test the type of the object without spilling the payload.
56738:         MaybeRegisterID pinnedObjData = frame.maybePinData(obj);
56738:         Jump guard = frame.testObject(Assembler::NotEqual, obj);
56738:         frame.maybeUnpinReg(pinnedObjData);
56738: 
56738:         // Create a sync path, which we'll rejoin manually later. This is safe
56738:         // as long as the IC does not build a stub; it won't, because |obj|
56738:         // won't be an object. If we extend this IC to support strings, all
56738:         // that needs to change is a little code movement.
56738:         stubcc.linkExit(guard, Uses(2));
56738:         objTypeGuard = stubcc.masm.jump();
53137:     }
53137: 
56738:     // Get a mutable register for the object. This will be the data reg.
56738:     ic.objReg = frame.copyDataIntoReg(obj);
56738: 
56738:     // Get a mutable register for pushing the result type. We kill two birds
56738:     // with one stone by making sure, if the key type is not known, to be loaded
56738:     // into this register. In this case it is both an input and an output.
56738:     frame.maybeUnpinReg(pinnedIdType);
56738:     if (id->isConstant() || id->isTypeKnown())
56738:         ic.typeReg = frame.allocReg();
56738:     else
56738:         ic.typeReg = frame.copyTypeIntoReg(id);
56738: 
56738:     // Fill in the id value.
56738:     frame.maybeUnpinReg(pinnedIdData);
56738:     if (id->isConstant()) {
56738:         ic.id = ValueRemat::FromConstant(id->getValue());
53137:     } else {
56738:         RegisterID dataReg = frame.tempRegForData(id);
56738:         if (id->isTypeKnown())
56738:             ic.id = ValueRemat::FromKnownType(id->getKnownType(), dataReg);
56738:         else
56738:             ic.id = ValueRemat::FromRegisters(ic.typeReg, dataReg);
53137:     }
53137: 
60597:     RESERVE_IC_SPACE(masm);
56738:     ic.fastPathStart = masm.label();
56738: 
56738:     // Note: slow path here is safe, since the frame will not be modified.
60597:     RESERVE_OOL_SPACE(stubcc.masm);
56738:     ic.slowPathStart = stubcc.masm.label();
56738:     frame.sync(stubcc.masm, Uses(2));
56738: 
56738:     if (id->mightBeType(JSVAL_TYPE_INT32)) {
56738:         // Always test the type first (see comment in PolyIC.h).
56738:         if (!id->isTypeKnown()) {
56738:             ic.typeGuard = masm.testInt32(Assembler::NotEqual, ic.typeReg);
56738:             stubcc.linkExitDirect(ic.typeGuard.get(), ic.slowPathStart);
56738:         }
56738: 
83222:         // Guard obj is a dense array.
83321:         Shape *shape = GetDenseArrayShape(cx, globalObj);
83321:         if (!shape)
83321:             return false;
83321:         ic.shapeGuard = masm.guardShape(ic.objReg, shape);
83222:         stubcc.linkExitDirect(ic.shapeGuard, ic.slowPathStart);
56738: 
56738:         Int32Key key = id->isConstant()
56738:                        ? Int32Key::FromConstant(id->getValue().toInt32())
56738:                        : Int32Key::FromRegister(ic.id.dataReg());
56738: 
56738:         Assembler::FastArrayLoadFails fails =
56738:             masm.fastArrayLoad(ic.objReg, key, ic.typeReg, ic.objReg);
56738: 
56738:         stubcc.linkExitDirect(fails.rangeCheck, ic.slowPathStart);
56738:         stubcc.linkExitDirect(fails.holeCheck, ic.slowPathStart);
56738:     } else {
56738:         // The type is known to not be dense-friendly ahead of time, so always
56738:         // fall back to a slow path.
83222:         ic.shapeGuard = masm.jump();
83222:         stubcc.linkExitDirect(ic.shapeGuard, ic.slowPathStart);
56738:     }
56738: 
56738:     stubcc.leave();
56738:     if (objTypeGuard.isSet())
56738:         objTypeGuard.get().linkTo(stubcc.masm.label(), &stubcc.masm);
60598: #ifdef JS_POLYIC
56738:     passICAddress(&ic);
77343:     ic.slowPathCall = OOL_STUBCALL(ic::GetElement, REJOIN_FALLTHROUGH);
56738: #else
77343:     ic.slowPathCall = OOL_STUBCALL(stubs::GetElem, REJOIN_FALLTHROUGH);
56738: #endif
56738: 
78456:     testPushedType(REJOIN_FALLTHROUGH, -2);
78456: 
56738:     ic.fastPathRejoin = masm.label();
78456:     ic.forcedTypeBarrier = analysis->getCode(PC).getStringElement;
78372: 
78455:     CHECK_IC_SPACE();
78455: 
56738:     frame.popn(2);
77343:     frame.pushRegs(ic.typeReg, ic.objReg, knownPushedType(0));
78456:     BarrierState barrier = testBarrier(ic.typeReg, ic.objReg, false, false,
78456:                                        /* force = */ ic.forcedTypeBarrier);
86855: 
86855:     stubcc.rejoin(Changes(1));
53137: 
60598: #ifdef JS_POLYIC
56738:     if (!getElemICs.append(ic))
56738:         return false;
56738: #endif
56738: 
86855:     finishBarrier(barrier, REJOIN_FALLTHROUGH, 0);
56735:     return true;
53137: }
52843: 
52855: static inline bool
53025: ReallySimpleStrictTest(FrameEntry *fe)
52855: {
52855:     if (!fe->isTypeKnown())
52855:         return false;
53025:     JSValueType type = fe->getKnownType();
53025:     return type == JSVAL_TYPE_NULL || type == JSVAL_TYPE_UNDEFINED;
52855: }
52855: 
52856: static inline bool
52856: BooleanStrictTest(FrameEntry *fe)
52856: {
53025:     return fe->isConstant() && fe->getKnownType() == JSVAL_TYPE_BOOLEAN;
52856: }
52856: 
52855: void
52855: mjit::Compiler::jsop_stricteq(JSOp op)
52855: {
52855:     FrameEntry *rhs = frame.peek(-1);
52855:     FrameEntry *lhs = frame.peek(-2);
52855: 
52855:     Assembler::Condition cond = (op == JSOP_STRICTEQ) ? Assembler::Equal : Assembler::NotEqual;
52855: 
53513:     /*
53513:      * NB: x64 can do full-Value comparisons. This is beneficial
53513:      * to do if the payload/type are not yet in registers.
53513:      */
53513: 
53513:     /* Constant-fold. */
53513:     if (lhs->isConstant() && rhs->isConstant()) {
59890:         JSBool b;
59890:         StrictlyEqual(cx, lhs->getValue(), rhs->getValue(), &b);
53513:         frame.popn(2);
53513:         frame.push(BooleanValue((op == JSOP_STRICTEQ) ? b : !b));
53513:         return;
53513:     }
53513: 
53513:     if (frame.haveSameBacking(lhs, rhs)) {
53513:         /* False iff NaN. */
79680:         frame.pop();
79680: 
53513:         if (lhs->isTypeKnown() && lhs->isNotType(JSVAL_TYPE_DOUBLE)) {
79680:             frame.pop();
56183:             frame.push(BooleanValue(op == JSOP_STRICTEQ));
53513:             return;
53513:         }
53513: 
77343:         if (lhs->isType(JSVAL_TYPE_DOUBLE))
77343:             frame.forgetKnownDouble(lhs);
77343: 
68966:         /* Assume NaN is either in canonical form or has the sign bit set (by jsop_neg). */
77343:         RegisterID result = frame.allocReg(Registers::SingleByteRegs).reg();
68966:         RegisterID treg = frame.copyTypeIntoReg(lhs);
53521: 
53521:         Assembler::Condition oppositeCond = (op == JSOP_STRICTEQ) ? Assembler::NotEqual : Assembler::Equal;
53521: 
68966:         /* Ignore the sign bit. */
68966:         masm.lshiftPtr(Imm32(1), treg);
69844: #ifdef JS_CPU_SPARC
69844:         /* On Sparc the result 0/0 is 0x7FFFFFFF not 0x7FF80000 */
77435:         static const int ShiftedCanonicalNaNType1 = 0x7FFFFFFF << 1;
77435:         static const int ShiftedCanonicalNaNType2 = 0x7FF80000 << 1;
77435:         RegisterID result1 = frame.allocReg();
77435:         masm.setPtr(oppositeCond, treg, Imm32(ShiftedCanonicalNaNType1), result1);
77435:         masm.setPtr(oppositeCond, treg, Imm32(ShiftedCanonicalNaNType2), result);
77435:         if(op == JSOP_STRICTEQ) {
77435:             masm.and32(result1, result);
77435:         } else {
77435:             masm.or32(result1, result);
77435:         }
77435:         frame.freeReg(result1);
87250: #elif defined(JS_CPU_MIPS)
87250:         /* On MIPS the result 0.0/0.0 is 0x7FF7FFFF.
87250:            We need to manually set it to 0x7FF80000. */
87250:         static const int ShiftedCanonicalNaNType = 0x7FF80000 << 1;
87250:         masm.setShiftedCanonicalNaN(treg, treg);
87250:         masm.setPtr(oppositeCond, treg, Imm32(ShiftedCanonicalNaNType), result);
77435: #elif !defined(JS_CPU_X64)
77435:         static const int ShiftedCanonicalNaNType = 0x7FF80000 << 1;
68966:         masm.setPtr(oppositeCond, treg, Imm32(ShiftedCanonicalNaNType), result);
68931: #else
68966:         static const void *ShiftedCanonicalNaNType = (void *)(0x7FF8000000000000 << 1);
68966:         masm.move(ImmPtr(ShiftedCanonicalNaNType), Registers::ScratchReg);
68931:         masm.setPtr(oppositeCond, treg, Registers::ScratchReg, result);
53521: #endif
68966:         frame.freeReg(treg);
53521: 
79680:         frame.pop();
53521:         frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, result);
53521:         return;
53513:     }
53513: 
52855:     /* Comparison against undefined or null is super easy. */
52855:     bool lhsTest;
53025:     if ((lhsTest = ReallySimpleStrictTest(lhs)) || ReallySimpleStrictTest(rhs)) {
52855:         FrameEntry *test = lhsTest ? rhs : lhs;
53513:         FrameEntry *known = lhsTest ? lhs : rhs;
77343:         RegisterID result = frame.allocReg(Registers::SingleByteRegs).reg();
52855: 
52855:         if (test->isTypeKnown()) {
77343:             masm.move(Imm32((test->getKnownType() == known->getKnownType()) ==
77343:                             (op == JSOP_STRICTEQ)), result);
52855:             frame.popn(2);
77343:             frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, result);
52855:             return;
52855:         }
52855: 
52855:         /* This is only true if the other side is |null|. */
68931: #ifndef JS_CPU_X64
53162:         JSValueTag mask = known->getKnownTag();
52855:         if (frame.shouldAvoidTypeRemat(test))
52856:             masm.set32(cond, masm.tagOf(frame.addressOf(test)), Imm32(mask), result);
52855:         else
52855:             masm.set32(cond, frame.tempRegForType(test), Imm32(mask), result);
68931: #else
53162:         RegisterID maskReg = frame.allocReg();
56004:         masm.move(ImmTag(known->getKnownTag()), maskReg);
55742: 
53162:         RegisterID r = frame.tempRegForType(test);
53162:         masm.setPtr(cond, r, maskReg, result);
55514: 
53162:         frame.freeReg(maskReg);
53162: #endif
52855:         frame.popn(2);
53025:         frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, result);
52855:         return;
52855:     }
52855: 
52856:     /* Hardcoded booleans are easy too. */
52856:     if ((lhsTest = BooleanStrictTest(lhs)) || BooleanStrictTest(rhs)) {
52856:         FrameEntry *test = lhsTest ? rhs : lhs;
52856: 
53513:         if (test->isTypeKnown() && test->isNotType(JSVAL_TYPE_BOOLEAN)) {
77343:             RegisterID result = frame.allocReg(Registers::SingleByteRegs).reg();
52856:             frame.popn(2);
77343: 
77343:             masm.move(Imm32(op == JSOP_STRICTNE), result);
77343:             frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, result);
52856:             return;
52856:         }
52856: 
52856:         if (test->isConstant()) {
52856:             frame.popn(2);
52856:             const Value &L = lhs->getValue();
52856:             const Value &R = rhs->getValue();
53081:             frame.push(BooleanValue((L.toBoolean() == R.toBoolean()) == (op == JSOP_STRICTEQ)));
52856:             return;
52856:         }
52856: 
58289:         RegisterID data = frame.copyDataIntoReg(test);
52856: 
58289:         RegisterID result = data;
58289:         if (!(Registers::maskReg(data) & Registers::SingleByteRegs))
77343:             result = frame.allocReg(Registers::SingleByteRegs).reg();
58289:         
52856:         Jump notBoolean;
52856:         if (!test->isTypeKnown())
52856:            notBoolean = frame.testBoolean(Assembler::NotEqual, test);
52856: 
52856:         /* Do a dynamic test. */
53081:         bool val = lhsTest ? lhs->getValue().toBoolean() : rhs->getValue().toBoolean();
57781:         masm.set32(cond, data, Imm32(val), result);
52856: 
52856:         if (!test->isTypeKnown()) {
52856:             Jump done = masm.jump();
52856:             notBoolean.linkTo(masm.label(), &masm);
52856:             masm.move(Imm32((op == JSOP_STRICTNE)), result);
52856:             done.linkTo(masm.label(), &masm);
52856:         }
52856: 
58289:         if (data != result)
58289:             frame.freeReg(data);
58289: 
52856:         frame.popn(2);
53025:         frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, result);
52856:         return;
52856:     }
52856: 
79902:     if (lhs->isType(JSVAL_TYPE_STRING) || rhs->isType(JSVAL_TYPE_STRING)) {
79902:         FrameEntry *maybeNotStr = lhs->isType(JSVAL_TYPE_STRING) ? rhs : lhs;
79902: 
79902:         if (maybeNotStr->isNotType(JSVAL_TYPE_STRING)) {
79902:             frame.popn(2);
80153:             frame.push(BooleanValue(op == JSOP_STRICTNE));
79902:             return;
79902:         }
79902: 
79902:         if (!maybeNotStr->isTypeKnown()) {
79902:             JS_ASSERT(!maybeNotStr->isConstant());
79902:             Jump j = frame.testString(Assembler::NotEqual, maybeNotStr);
79902:             stubcc.linkExit(j, Uses(2));
79902:         }
79902: 
79902:         FrameEntry *op1 = lhs->isConstant() ? rhs : lhs;
79902:         FrameEntry *op2 = lhs->isConstant() ? lhs : rhs;
79902:         JS_ASSERT(!op1->isConstant());
79902: 
79902:         /* ReturnReg is safely usable with set32, since %ah can be accessed. */
79902:         RegisterID resultReg = Registers::ReturnReg;
79902:         frame.takeReg(resultReg);
79902:         RegisterID tmpReg = frame.allocReg();
79902:         RegisterID reg1 = frame.tempRegForData(op1);
79902:         frame.pinReg(reg1);
79902: 
79902:         RegisterID reg2;
79902:         if (op2->isConstant()) {
79902:             reg2 = frame.allocReg();
79902:             JSString *str = op2->getValue().toString();
79902:             JS_ASSERT(str->isAtom());
79902:             masm.move(ImmPtr(str), reg2);
79902:         } else {
79902:             reg2 = frame.tempRegForData(op2);
79902:             frame.pinReg(reg2);
79902:         }
79902: 
79902:         JS_ASSERT(reg1 != resultReg);
79902:         JS_ASSERT(reg1 != tmpReg);
79902:         JS_ASSERT(reg2 != resultReg);
79902:         JS_ASSERT(reg2 != tmpReg);
79902: 
79902:         /* JSString::isAtom === (lengthAndFlags & ATOM_MASK == 0) */
79902:         JS_STATIC_ASSERT(JSString::ATOM_FLAGS == 0);
79902:         Imm32 atomMask(JSString::ATOM_MASK);
79902: 
79902:         masm.load32(Address(reg1, JSString::offsetOfLengthAndFlags()), tmpReg);
79902:         Jump op1NotAtomized = masm.branchTest32(Assembler::NonZero, tmpReg, atomMask);
79902:         stubcc.linkExit(op1NotAtomized, Uses(2));
79902: 
79902:         if (!op2->isConstant()) {
79902:             masm.load32(Address(reg2, JSString::offsetOfLengthAndFlags()), tmpReg);
79902:             Jump op2NotAtomized = masm.branchTest32(Assembler::NonZero, tmpReg, atomMask);
79902:             stubcc.linkExit(op2NotAtomized, Uses(2));
79902:         }
79902: 
79902:         masm.set32(cond, reg1, reg2, resultReg);
79902: 
79902:         frame.unpinReg(reg1);
79902:         if (op2->isConstant())
79902:             frame.freeReg(reg2);
79902:         else
79902:             frame.unpinReg(reg2);
79902:         frame.freeReg(tmpReg);
79902: 
79902:         stubcc.leave();
79902:         if (op == JSOP_STRICTEQ)
79902:             OOL_STUBCALL_USES(stubs::StrictEq, REJOIN_NONE, Uses(2));
79902:         else
79902:             OOL_STUBCALL_USES(stubs::StrictNe, REJOIN_NONE, Uses(2));
79902: 
79902:         frame.popn(2);
79902:         frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, resultReg);
79902: 
79902:         stubcc.rejoin(Changes(1));
79902:         return;
79902:     }
79902: 
79902:     if (cx->typeInferenceEnabled() &&
79902:         lhs->isType(JSVAL_TYPE_OBJECT) && rhs->isType(JSVAL_TYPE_OBJECT))
79902:     {
79902:         CompileStatus status = jsop_equality_obj_obj(op, NULL, JSOP_NOP);
79902:         if (status == Compile_Okay) return;
79902:         JS_ASSERT(status == Compile_Skipped);
79902:     }
79902: 
53513:     /* Is it impossible that both Values are ints? */
53513:     if ((lhs->isTypeKnown() && lhs->isNotType(JSVAL_TYPE_INT32)) ||
53513:         (rhs->isTypeKnown() && rhs->isNotType(JSVAL_TYPE_INT32))) {
53087:         prepareStubCall(Uses(2));
53513: 
52855:         if (op == JSOP_STRICTEQ)
78454:             INLINE_STUBCALL_USES(stubs::StrictEq, REJOIN_NONE, Uses(2));
52855:         else
78454:             INLINE_STUBCALL_USES(stubs::StrictNe, REJOIN_NONE, Uses(2));
53513: 
52855:         frame.popn(2);
77343:         frame.pushSynced(JSVAL_TYPE_BOOLEAN);
53513:         return;
53513:     }
53513: 
68931: #if !defined JS_CPU_ARM && !defined JS_CPU_SPARC
53513:     /* Try an integer fast-path. */
53513:     bool needStub = false;
53513:     if (!lhs->isTypeKnown()) {
53513:         Jump j = frame.testInt32(Assembler::NotEqual, lhs);
53513:         stubcc.linkExit(j, Uses(2));
53513:         needStub = true;
53513:     }
53513: 
53513:     if (!rhs->isTypeKnown() && !frame.haveSameBacking(lhs, rhs)) {
53513:         Jump j = frame.testInt32(Assembler::NotEqual, rhs);
53513:         stubcc.linkExit(j, Uses(2));
53513:         needStub = true;
53513:     }
53513: 
53513:     FrameEntry *test  = lhs->isConstant() ? rhs : lhs;
53513:     FrameEntry *other = lhs->isConstant() ? lhs : rhs;
53513: 
53513:     /* ReturnReg is safely usable with set32, since %ah can be accessed. */
53513:     RegisterID resultReg = Registers::ReturnReg;
53513:     frame.takeReg(resultReg);
53513:     RegisterID testReg = frame.tempRegForData(test);
53513:     frame.pinReg(testReg);
53513: 
53513:     JS_ASSERT(resultReg != testReg);
53513: 
53513:     /* Set boolean in resultReg. */
53513:     if (other->isConstant()) {
53513:         masm.set32(cond, testReg, Imm32(other->getValue().toInt32()), resultReg);
53513:     } else if (frame.shouldAvoidDataRemat(other)) {
53513:         masm.set32(cond, testReg, frame.addressOf(other), resultReg);
53513:     } else {
53513:         RegisterID otherReg = frame.tempRegForData(other);
53513: 
53513:         JS_ASSERT(otherReg != resultReg);
53513:         JS_ASSERT(otherReg != testReg);
53513: 
53513:         masm.set32(cond, testReg, otherReg, resultReg);
53513:     }
53513: 
53513:     frame.unpinReg(testReg);
53513: 
53513:     if (needStub) {
53513:         stubcc.leave();
53513:         if (op == JSOP_STRICTEQ)
78454:             OOL_STUBCALL_USES(stubs::StrictEq, REJOIN_NONE, Uses(2));
53513:         else
78454:             OOL_STUBCALL_USES(stubs::StrictNe, REJOIN_NONE, Uses(2));
53513:     }
53513: 
53513:     frame.popn(2);
53513:     frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, resultReg);
53513: 
53513:     if (needStub)
53513:         stubcc.rejoin(Changes(1));
53513: #else
53513:     /* TODO: Port set32() logic to ARM. */
53513:     prepareStubCall(Uses(2));
53513: 
53513:     if (op == JSOP_STRICTEQ)
78454:         INLINE_STUBCALL_USES(stubs::StrictEq, REJOIN_NONE, Uses(2));
53513:     else
78454:         INLINE_STUBCALL_USES(stubs::StrictNe, REJOIN_NONE, Uses(2));
53513: 
53513:     frame.popn(2);
77343:     frame.pushSynced(JSVAL_TYPE_BOOLEAN);
53513:     return;
53513: #endif
52855: }
52855: 
52916: void
52916: mjit::Compiler::jsop_pos()
52916: {
52916:     FrameEntry *top = frame.peek(-1);
52916: 
52916:     if (top->isTypeKnown()) {
53025:         if (top->getKnownType() <= JSVAL_TYPE_INT32)
52916:             return;
53087:         prepareStubCall(Uses(1));
77343:         INLINE_STUBCALL(stubs::Pos, REJOIN_POS);
52916:         frame.pop();
77343:         frame.pushSynced(knownPushedType(0));
52916:         return;
52916:     }
52916: 
53052:     frame.giveOwnRegs(top);
53052: 
52916:     Jump j;
52916:     if (frame.shouldAvoidTypeRemat(top))
53052:         j = masm.testNumber(Assembler::NotEqual, frame.addressOf(top));
52916:     else
53052:         j = masm.testNumber(Assembler::NotEqual, frame.tempRegForType(top));
53088:     stubcc.linkExit(j, Uses(1));
52916: 
52916:     stubcc.leave();
77343:     OOL_STUBCALL(stubs::Pos, REJOIN_POS);
52916: 
53088:     stubcc.rejoin(Changes(1));
52916: }
52916: 
58056: void
58056: mjit::Compiler::jsop_initmethod()
58056: {
58061: #ifdef DEBUG
58056:     FrameEntry *obj = frame.peek(-2);
58061: #endif
58056:     JSAtom *atom = script->getAtom(fullAtomIndex(PC));
58056: 
58056:     /* Initializers with INITMETHOD are not fast yet. */
77343:     JS_ASSERT(!frame.extra(obj).initObject);
58056: 
58056:     prepareStubCall(Uses(2));
58056:     masm.move(ImmPtr(atom), Registers::ArgReg1);
77343:     INLINE_STUBCALL(stubs::InitMethod, REJOIN_FALLTHROUGH);
58056: }
58056: 
58056: void
58056: mjit::Compiler::jsop_initprop()
58056: {
58056:     FrameEntry *obj = frame.peek(-2);
58056:     FrameEntry *fe = frame.peek(-1);
58056:     JSAtom *atom = script->getAtom(fullAtomIndex(PC));
58056: 
77343:     JSObject *baseobj = frame.extra(obj).initObject;
58056: 
77343:     if (!baseobj || monitored(PC)) {
58056:         prepareStubCall(Uses(2));
58056:         masm.move(ImmPtr(atom), Registers::ArgReg1);
77343:         INLINE_STUBCALL(stubs::InitProp, REJOIN_FALLTHROUGH);
58056:         return;
58056:     }
58056: 
58056:     JSObject *holder;
58056:     JSProperty *prop = NULL;
58056: #ifdef DEBUG
69855:     bool res =
58056: #endif
69855:     LookupPropertyWithFlags(cx, baseobj, ATOM_TO_JSID(atom),
58056:                             JSRESOLVE_QUALIFIED, &holder, &prop);
69855:     JS_ASSERT(res && prop && holder == baseobj);
58056: 
58056:     RegisterID objReg = frame.copyDataIntoReg(obj);
58056: 
58056:     /* Perform the store. */
58056:     Shape *shape = (Shape *) prop;
83221:     Address address = masm.objPropAddress(baseobj, objReg, shape->slot());
77343:     frame.storeTo(fe, address);
58056:     frame.freeReg(objReg);
58056: }
58056: 
58056: void
58056: mjit::Compiler::jsop_initelem()
58056: {
58056:     FrameEntry *obj = frame.peek(-3);
58056:     FrameEntry *id = frame.peek(-2);
58056:     FrameEntry *fe = frame.peek(-1);
58056: 
58056:     /*
58056:      * The initialized index is always a constant, but we won't remember which
58056:      * constant if there are branches inside the code computing the initializer
58056:      * expression (e.g. the expression uses the '?' operator).  Slow path those
58056:      * cases, as well as those where INITELEM is used on an object initializer
58056:      * or a non-fast array initializer.
58056:      */
77343:     if (!id->isConstant() || !frame.extra(obj).initArray) {
58056:         JSOp next = JSOp(PC[JSOP_INITELEM_LENGTH]);
58056: 
58056:         prepareStubCall(Uses(3));
58056:         masm.move(Imm32(next == JSOP_ENDINIT ? 1 : 0), Registers::ArgReg1);
77343:         INLINE_STUBCALL(stubs::InitElem, REJOIN_FALLTHROUGH);
58056:         return;
58056:     }
58056: 
84755:     int32_t idx = id->getValue().toInt32();
76206: 
77343:     RegisterID objReg = frame.copyDataIntoReg(obj);
83231:     masm.loadPtr(Address(objReg, JSObject::offsetOfElements()), objReg);
83231: 
77343:     /* Update the initialized length. */
83231:     masm.store32(Imm32(idx + 1), Address(objReg, ObjectElements::offsetOfInitializedLength()));
58056: 
77343:     /* Perform the store. */
77343:     frame.storeTo(fe, Address(objReg, idx * sizeof(Value)));
58056:     frame.freeReg(objReg);
58056: }
