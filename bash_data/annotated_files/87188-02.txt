78065: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
78065:  * vim: set ts=8 sw=4 et tw=78:
78065:  *
78065:  * ***** BEGIN LICENSE BLOCK *****
78065:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
78065:  *
78065:  * The contents of this file are subject to the Mozilla Public License Version
78065:  * 1.1 (the "License"); you may not use this file except in compliance with
78065:  * the License. You may obtain a copy of the License at
78065:  * http://www.mozilla.org/MPL/
78065:  *
78065:  * Software distributed under the License is distributed on an "AS IS" basis,
78065:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
78065:  * for the specific language governing rights and limitations under the
78065:  * License.
78065:  *
78065:  * The Original Code is SpiderMonkey call object code.
78065:  *
78065:  * The Initial Developer of the Original Code is
78065:  * the Mozilla Foundation.
78065:  * Portions created by the Initial Developer are Copyright (C) 2011
78065:  * the Initial Developer. All Rights Reserved.
78065:  *
78065:  * Contributor(s):
78065:  *   Paul Biggar <pbiggar@mozilla.com> (original author)
78065:  *
78065:  * Alternatively, the contents of this file may be used under the terms of
78065:  * either of the GNU General Public License Version 2 or later (the "GPL"),
78065:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
78065:  * in which case the provisions of the GPL or the LGPL are applicable instead
78065:  * of those above. If you wish to allow use of your version of this file only
78065:  * under the terms of either the GPL or the LGPL, and not to allow others to
78065:  * use your version of this file under the terms of the MPL, indicate your
78065:  * decision by deleting the provisions above and replace them with the notice
78065:  * and other provisions required by the GPL or the LGPL. If you do not delete
78065:  * the provisions above, a recipient may use your version of this file under
78065:  * the terms of any one of the MPL, the GPL or the LGPL.
78065:  *
78065:  * ***** END LICENSE BLOCK ***** */
78065: 
86483: #include "jscompartment.h"
86483: #include "jsiter.h"
86483: #include "jsscope.h"
86483: #if JS_HAS_XDR
86483: #include "jsxdrapi.h"
86483: #endif
86483: 
86483: #include "GlobalObject.h"
86483: #include "ScopeObject.h"
86483: 
86483: #include "jsatominlines.h"
78065: #include "jsobjinlines.h"
78065: 
86483: #include "ScopeObject-inl.h"
78065: 
86483: using namespace js;
86483: using namespace js::types;
78065: 
78065: /*
78065:  * Construct a call object for the given bindings.  If this is a call object
78065:  * for a function invocation, callee should be the function being called.
78065:  * Otherwise it must be a call object for eval of strict mode code, and callee
78065:  * must be null.
78065:  */
78065: CallObject *
86483: CallObject::create(JSContext *cx, JSScript *script, JSObject &enclosing, JSObject *callee)
78065: {
78065:     Bindings &bindings = script->bindings;
83247:     gc::AllocKind kind = gc::GetGCObjectKind(bindings.lastShape()->numFixedSlots() + 1);
78065: 
86437:     RootedVarTypeObject type(cx);
86437: 
86437:     type = cx->compartment->getEmptyType(cx);
83275:     if (!type)
83275:         return NULL;
83275: 
83301:     HeapValue *slots;
83314:     if (!PreallocateObjectDynamicSlots(cx, bindings.lastShape(), &slots))
83275:         return NULL;
78065: 
86437:     RootedVarShape shape(cx);
86437:     shape = bindings.lastShape();
86437: 
86437:     JSObject *obj = JSObject::create(cx, kind, shape, type, slots);
78065:     if (!obj)
78065:         return NULL;
78065: 
83275:     /*
83275:      * Update the parent for bindings associated with non-compileAndGo scripts,
83275:      * whose call objects do not have a consistent global variable and need
83275:      * to be updated dynamically.
83275:      */
86483:     JSObject &global = enclosing.global();
86483:     if (&global != obj->getParent()) {
83287:         JS_ASSERT(obj->getParent() == NULL);
86483:         if (!obj->setParent(cx, &global))
78065:             return NULL;
83275:     }
78065: 
78065: #ifdef DEBUG
86483:     JS_ASSERT(!obj->inDictionaryMode());
82129:     for (Shape::Range r = obj->lastProperty(); !r.empty(); r.popFront()) {
78065:         const Shape &s = r.front();
83221:         if (s.hasSlot()) {
83221:             JS_ASSERT(s.slot() + 1 == obj->slotSpan());
78065:             break;
78065:         }
78065:     }
78065: #endif
78065: 
86483:     if (!obj->asScope().setEnclosingScope(cx, enclosing))
86483:         return NULL;
83275: 
86483:     JS_ASSERT_IF(callee, callee->isFunction());
86483:     obj->initFixedSlot(CALLEE_SLOT, ObjectOrNullValue(callee));
83275: 
83275:     /*
83275:      * If |bindings| is for a function that has extensible parents, that means
86483:      * its Call should have its own shape; see BaseShape::extensibleParents.
83275:      */
83275:     if (obj->lastProperty()->extensibleParents() && !obj->generateOwnShape(cx))
83275:         return NULL;
83275: 
86483:     return &obj->asCall();
78065: }
78065: 
86483: Class js::DeclEnvClass = {
86483:     js_Object_str,
86483:     JSCLASS_HAS_PRIVATE |
86483:     JSCLASS_HAS_RESERVED_SLOTS(DeclEnvObject::RESERVED_SLOTS) |
86483:     JSCLASS_HAS_CACHED_PROTO(JSProto_Object),
86483:     JS_PropertyStub,         /* addProperty */
86483:     JS_PropertyStub,         /* delProperty */
86483:     JS_PropertyStub,         /* getProperty */
86483:     JS_StrictPropertyStub,   /* setProperty */
86483:     JS_EnumerateStub,
86483:     JS_ResolveStub,
86483:     JS_ConvertStub
86483: };
86483: 
86483: DeclEnvObject *
86483: DeclEnvObject::create(JSContext *cx, StackFrame *fp)
86483: {
86483:     RootedVarTypeObject type(cx);
86483:     type = cx->compartment->getEmptyType(cx);
86483:     if (!type)
86483:         return NULL;
86483: 
86483:     RootedVarShape emptyDeclEnvShape(cx);
86483:     emptyDeclEnvShape = EmptyShape::getInitialShape(cx, &DeclEnvClass, NULL,
86483:                                                     &fp->scopeChain().global(),
86483:                                                     FINALIZE_KIND);
86483:     if (!emptyDeclEnvShape)
86483:         return NULL;
86483: 
86483:     JSObject *obj = JSObject::create(cx, FINALIZE_KIND, emptyDeclEnvShape, type, NULL);
86483:     if (!obj)
86483:         return NULL;
86483: 
86483:     obj->setPrivate(fp);
86483:     if (!obj->asScope().setEnclosingScope(cx, fp->scopeChain()))
86483:         return NULL;
86483: 
86483:     return &obj->asDeclEnv();
78065: }
86483: 
86483: WithObject *
86483: WithObject::create(JSContext *cx, StackFrame *fp, JSObject &proto, JSObject &enclosing,
86483:                    uint32_t depth)
86483: {
86483:     RootedVarTypeObject type(cx);
86483:     type = proto.getNewType(cx);
86483:     if (!type)
86483:         return NULL;
86483: 
86483:     RootedVarShape emptyWithShape(cx);
86483:     emptyWithShape = EmptyShape::getInitialShape(cx, &WithClass, &proto,
86483:                                                  &enclosing.global(), FINALIZE_KIND);
86483:     if (!emptyWithShape)
86483:         return NULL;
86483: 
86483:     JSObject *obj = JSObject::create(cx, FINALIZE_KIND, emptyWithShape, type, NULL);
86483:     if (!obj)
86483:         return NULL;
86483: 
86483:     if (!obj->asScope().setEnclosingScope(cx, enclosing))
86483:         return NULL;
86483: 
86483:     obj->setReservedSlot(DEPTH_SLOT, PrivateUint32Value(depth));
86483:     obj->setPrivate(js_FloatingFrameIfGenerator(cx, fp));
86483: 
86483:     JSObject *thisp = proto.thisObject(cx);
86483:     if (!thisp)
86483:         return NULL;
86483: 
86483:     obj->setFixedSlot(THIS_SLOT, ObjectValue(*thisp));
86483: 
86483:     return &obj->asWith();
86483: }
86483: 
86483: static JSBool
86483: with_LookupGeneric(JSContext *cx, JSObject *obj, jsid id, JSObject **objp, JSProperty **propp)
86483: {
86483:     /* Fixes bug 463997 */
86483:     uintN flags = cx->resolveFlags;
86483:     if (flags == RESOLVE_INFER)
86483:         flags = js_InferFlags(cx, flags);
86483:     flags |= JSRESOLVE_WITH;
86483:     JSAutoResolveFlags rf(cx, flags);
86483:     return obj->asWith().object().lookupGeneric(cx, id, objp, propp);
86483: }
86483: 
86483: static JSBool
86483: with_LookupProperty(JSContext *cx, JSObject *obj, PropertyName *name, JSObject **objp, JSProperty **propp)
86483: {
86483:     return with_LookupGeneric(cx, obj, ATOM_TO_JSID(name), objp, propp);
86483: }
86483: 
86483: static JSBool
86483: with_LookupElement(JSContext *cx, JSObject *obj, uint32_t index, JSObject **objp,
86483:                    JSProperty **propp)
86483: {
86483:     jsid id;
86483:     if (!IndexToId(cx, index, &id))
86483:         return false;
86483:     return with_LookupGeneric(cx, obj, id, objp, propp);
86483: }
86483: 
86483: static JSBool
86483: with_LookupSpecial(JSContext *cx, JSObject *obj, SpecialId sid, JSObject **objp, JSProperty **propp)
86483: {
86483:     return with_LookupGeneric(cx, obj, SPECIALID_TO_JSID(sid), objp, propp);
86483: }
86483: 
86483: static JSBool
86483: with_GetGeneric(JSContext *cx, JSObject *obj, JSObject *receiver, jsid id, Value *vp)
86483: {
86483:     return obj->asWith().object().getGeneric(cx, id, vp);
86483: }
86483: 
86483: static JSBool
86483: with_GetProperty(JSContext *cx, JSObject *obj, JSObject *receiver, PropertyName *name, Value *vp)
86483: {
86483:     return with_GetGeneric(cx, obj, receiver, ATOM_TO_JSID(name), vp);
86483: }
86483: 
86483: static JSBool
86483: with_GetElement(JSContext *cx, JSObject *obj, JSObject *receiver, uint32_t index, Value *vp)
86483: {
86483:     jsid id;
86483:     if (!IndexToId(cx, index, &id))
86483:         return false;
86483:     return with_GetGeneric(cx, obj, receiver, id, vp);
86483: }
86483: 
86483: static JSBool
86483: with_GetSpecial(JSContext *cx, JSObject *obj, JSObject *receiver, SpecialId sid, Value *vp)
86483: {
86483:     return with_GetGeneric(cx, obj, receiver, SPECIALID_TO_JSID(sid), vp);
86483: }
86483: 
86483: static JSBool
86483: with_SetGeneric(JSContext *cx, JSObject *obj, jsid id, Value *vp, JSBool strict)
86483: {
86483:     return obj->asWith().object().setGeneric(cx, id, vp, strict);
86483: }
86483: 
86483: static JSBool
86483: with_SetProperty(JSContext *cx, JSObject *obj, PropertyName *name, Value *vp, JSBool strict)
86483: {
86483:     return obj->asWith().object().setProperty(cx, name, vp, strict);
86483: }
86483: 
86483: static JSBool
86483: with_SetElement(JSContext *cx, JSObject *obj, uint32_t index, Value *vp, JSBool strict)
86483: {
86483:     return obj->asWith().object().setElement(cx, index, vp, strict);
86483: }
86483: 
86483: static JSBool
86483: with_SetSpecial(JSContext *cx, JSObject *obj, SpecialId sid, Value *vp, JSBool strict)
86483: {
86483:     return obj->asWith().object().setSpecial(cx, sid, vp, strict);
86483: }
86483: 
86483: static JSBool
86483: with_GetGenericAttributes(JSContext *cx, JSObject *obj, jsid id, uintN *attrsp)
86483: {
86483:     return obj->asWith().object().getGenericAttributes(cx, id, attrsp);
86483: }
86483: 
86483: static JSBool
86483: with_GetPropertyAttributes(JSContext *cx, JSObject *obj, PropertyName *name, uintN *attrsp)
86483: {
86483:     return obj->asWith().object().getPropertyAttributes(cx, name, attrsp);
86483: }
86483: 
86483: static JSBool
86483: with_GetElementAttributes(JSContext *cx, JSObject *obj, uint32_t index, uintN *attrsp)
86483: {
86483:     return obj->asWith().object().getElementAttributes(cx, index, attrsp);
86483: }
86483: 
86483: static JSBool
86483: with_GetSpecialAttributes(JSContext *cx, JSObject *obj, SpecialId sid, uintN *attrsp)
86483: {
86483:     return obj->asWith().object().getSpecialAttributes(cx, sid, attrsp);
86483: }
86483: 
86483: static JSBool
86483: with_SetGenericAttributes(JSContext *cx, JSObject *obj, jsid id, uintN *attrsp)
86483: {
86483:     return obj->asWith().object().setGenericAttributes(cx, id, attrsp);
86483: }
86483: 
86483: static JSBool
86483: with_SetPropertyAttributes(JSContext *cx, JSObject *obj, PropertyName *name, uintN *attrsp)
86483: {
86483:     return obj->asWith().object().setPropertyAttributes(cx, name, attrsp);
86483: }
86483: 
86483: static JSBool
86483: with_SetElementAttributes(JSContext *cx, JSObject *obj, uint32_t index, uintN *attrsp)
86483: {
86483:     return obj->asWith().object().setElementAttributes(cx, index, attrsp);
86483: }
86483: 
86483: static JSBool
86483: with_SetSpecialAttributes(JSContext *cx, JSObject *obj, SpecialId sid, uintN *attrsp)
86483: {
86483:     return obj->asWith().object().setSpecialAttributes(cx, sid, attrsp);
86483: }
86483: 
86483: static JSBool
86483: with_DeleteProperty(JSContext *cx, JSObject *obj, PropertyName *name, Value *rval, JSBool strict)
86483: {
86483:     return obj->asWith().object().deleteProperty(cx, name, rval, strict);
86483: }
86483: 
86483: static JSBool
86483: with_DeleteElement(JSContext *cx, JSObject *obj, uint32_t index, Value *rval, JSBool strict)
86483: {
86483:     return obj->asWith().object().deleteElement(cx, index, rval, strict);
86483: }
86483: 
86483: static JSBool
86483: with_DeleteSpecial(JSContext *cx, JSObject *obj, SpecialId sid, Value *rval, JSBool strict)
86483: {
86483:     return obj->asWith().object().deleteSpecial(cx, sid, rval, strict);
86483: }
86483: 
86483: static JSBool
86483: with_Enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
86483:                Value *statep, jsid *idp)
86483: {
86483:     return obj->asWith().object().enumerate(cx, enum_op, statep, idp);
86483: }
86483: 
86483: static JSType
86483: with_TypeOf(JSContext *cx, JSObject *obj)
86483: {
86483:     return JSTYPE_OBJECT;
86483: }
86483: 
86483: static JSObject *
86483: with_ThisObject(JSContext *cx, JSObject *obj)
86483: {
86483:     return &obj->asWith().withThis();
86483: }
86483: 
86483: Class js::WithClass = {
86483:     "With",
86483:     JSCLASS_HAS_PRIVATE |
86483:     JSCLASS_HAS_RESERVED_SLOTS(WithObject::RESERVED_SLOTS) |
86483:     JSCLASS_IS_ANONYMOUS,
86483:     JS_PropertyStub,         /* addProperty */
86483:     JS_PropertyStub,         /* delProperty */
86483:     JS_PropertyStub,         /* getProperty */
86483:     JS_StrictPropertyStub,   /* setProperty */
86483:     JS_EnumerateStub,
86483:     JS_ResolveStub,
86483:     JS_ConvertStub,
86483:     NULL,                    /* finalize */
86483:     NULL,                    /* reserved    */
86483:     NULL,                    /* checkAccess */
86483:     NULL,                    /* call        */
86483:     NULL,                    /* construct   */
86483:     NULL,                    /* xdrObject   */
86483:     NULL,                    /* hasInstance */
86483:     NULL,                    /* trace       */
86483:     JS_NULL_CLASS_EXT,
86483:     {
86483:         with_LookupGeneric,
86483:         with_LookupProperty,
86483:         with_LookupElement,
86483:         with_LookupSpecial,
86483:         NULL,             /* defineGeneric */
86483:         NULL,             /* defineProperty */
86483:         NULL,             /* defineElement */
86483:         NULL,             /* defineSpecial */
86483:         with_GetGeneric,
86483:         with_GetProperty,
86483:         with_GetElement,
86483:         NULL,             /* getElementIfPresent */
86483:         with_GetSpecial,
86483:         with_SetGeneric,
86483:         with_SetProperty,
86483:         with_SetElement,
86483:         with_SetSpecial,
86483:         with_GetGenericAttributes,
86483:         with_GetPropertyAttributes,
86483:         with_GetElementAttributes,
86483:         with_GetSpecialAttributes,
86483:         with_SetGenericAttributes,
86483:         with_SetPropertyAttributes,
86483:         with_SetElementAttributes,
86483:         with_SetSpecialAttributes,
86483:         with_DeleteProperty,
86483:         with_DeleteElement,
86483:         with_DeleteSpecial,
86483:         with_Enumerate,
86483:         with_TypeOf,
86483:         NULL,             /* fix   */
86483:         with_ThisObject,
86483:         NULL,             /* clear */
86483:     }
86483: };
86483: 
86483: ClonedBlockObject *
86483: ClonedBlockObject::create(JSContext *cx, StaticBlockObject &block, StackFrame *fp)
86483: {
86483:     RootedVarTypeObject type(cx);
86483:     type = block.getNewType(cx);
86483:     if (!type)
86483:         return NULL;
86483: 
86483:     HeapValue *slots;
86483:     if (!PreallocateObjectDynamicSlots(cx, block.lastProperty(), &slots))
86483:         return NULL;
86483: 
86483:     RootedVarShape shape(cx);
86483:     shape = block.lastProperty();
86483: 
86483:     JSObject *obj = JSObject::create(cx, FINALIZE_KIND, shape, type, slots);
86483:     if (!obj)
86483:         return NULL;
86483: 
86483:     /* Set the parent if necessary, as for call objects. */
86483:     JSObject &global = fp->scopeChain().global();
86483:     if (&global != obj->getParent()) {
86483:         JS_ASSERT(obj->getParent() == NULL);
86483:         if (!obj->setParent(cx, &global))
86483:             return NULL;
86483:     }
86483: 
86483:     JS_ASSERT(!obj->inDictionaryMode());
86483:     JS_ASSERT(obj->slotSpan() >= block.slotCount() + RESERVED_SLOTS);
86483: 
86483:     obj->setReservedSlot(DEPTH_SLOT, PrivateUint32Value(block.stackDepth()));
86483:     obj->setPrivate(js_FloatingFrameIfGenerator(cx, fp));
86483: 
86483:     if (obj->lastProperty()->extensibleParents() && !obj->generateOwnShape(cx))
86483:         return NULL;
86483: 
86483:     return &obj->asClonedBlock();
86483: }
86483: 
86484: void
86484: ClonedBlockObject::put(JSContext *cx)
86483: {
86483:     StackFrame *fp = cx->fp();
86483:     JS_ASSERT(maybeStackFrame() == js_FloatingFrameIfGenerator(cx, fp));
86483: 
86483:     uint32_t count = slotCount();
86483:     uint32_t depth = stackDepth();
86483: 
86483:     /* The block and its locals must be on the current stack for GC safety. */
86483:     JS_ASSERT(depth <= uint32_t(cx->regs().sp - fp->base()));
86483:     JS_ASSERT(count <= uint32_t(cx->regs().sp - fp->base() - depth));
86483: 
86483:     /* See comments in CheckDestructuring in frontend/Parser.cpp. */
86483:     JS_ASSERT(count >= 1);
86483: 
86483:     copySlotRange(RESERVED_SLOTS, fp->base() + depth, count);
86483: 
86483:     /* We must clear the private slot even with errors. */
86483:     setPrivate(NULL);
86483:     fp->setScopeChainNoCallObj(enclosingScope());
86483: }
86483: 
86483: static JSBool
86483: block_getProperty(JSContext *cx, JSObject *obj, jsid id, Value *vp)
86483: {
86483:     /*
86483:      * Block objects are never exposed to script, and the engine handles them
86483:      * with care. So unlike other getters, this one can assert (rather than
86483:      * check) certain invariants about obj.
86483:      */
86483:     ClonedBlockObject &block = obj->asClonedBlock();
86483:     uintN index = (uintN) JSID_TO_INT(id);
86483:     JS_ASSERT(index < block.slotCount());
86483: 
86483:     if (StackFrame *fp = block.maybeStackFrame()) {
86483:         fp = js_LiveFrameIfGenerator(fp);
86483:         index += fp->numFixed() + block.stackDepth();
86483:         JS_ASSERT(index < fp->numSlots());
86483:         *vp = fp->slots()[index];
86483:         return true;
86483:     }
86483: 
86483:     /* Values are in slots immediately following the class-reserved ones. */
86483:     JS_ASSERT(block.closedSlot(index) == *vp);
86483:     return true;
86483: }
86483: 
86483: static JSBool
86483: block_setProperty(JSContext *cx, JSObject *obj, jsid id, JSBool strict, Value *vp)
86483: {
86483:     ClonedBlockObject &block = obj->asClonedBlock();
86483:     uintN index = (uintN) JSID_TO_INT(id);
86483:     JS_ASSERT(index < block.slotCount());
86483: 
86483:     if (StackFrame *fp = block.maybeStackFrame()) {
86483:         fp = js_LiveFrameIfGenerator(fp);
86483:         index += fp->numFixed() + block.stackDepth();
86483:         JS_ASSERT(index < fp->numSlots());
86483:         fp->slots()[index] = *vp;
86483:         return true;
86483:     }
86483: 
86483:     /*
86483:      * The value in *vp will be written back to the slot in obj that was
86483:      * allocated when this let binding was defined.
86483:      */
86483:     return true;
86483: }
86483: 
86483: StaticBlockObject *
86483: StaticBlockObject::create(JSContext *cx)
86483: {
86483:     RootedVarTypeObject type(cx);
86483:     type = cx->compartment->getEmptyType(cx);
86483:     if (!type)
86483:         return NULL;
86483: 
86483:     RootedVarShape emptyBlockShape(cx);
86483:     emptyBlockShape = EmptyShape::getInitialShape(cx, &BlockClass, NULL, NULL, FINALIZE_KIND);
86483:     if (!emptyBlockShape)
86483:         return NULL;
86483: 
86483:     JSObject *obj = JSObject::create(cx, FINALIZE_KIND, emptyBlockShape, type, NULL);
86483:     if (!obj)
86483:         return NULL;
86483: 
86483:     return &obj->asStaticBlock();
86483: }
86483: 
86483: const Shape *
86483: StaticBlockObject::addVar(JSContext *cx, jsid id, intN index, bool *redeclared)
86483: {
87188:     JS_ASSERT(JSID_IS_ATOM(id) || (JSID_IS_INT(id) && JSID_TO_INT(id) == index));
87188: 
86483:     *redeclared = false;
86483: 
86483:     /* Inline JSObject::addProperty in order to trap the redefinition case. */
86483:     Shape **spp;
86483:     if (Shape::search(cx, lastProperty(), id, &spp, true)) {
86483:         *redeclared = true;
86483:         return NULL;
86483:     }
86483: 
86483:     /*
86483:      * Don't convert this object to dictionary mode so that we can clone the
86483:      * block's shape later.
86483:      */
86483:     uint32_t slot = JSSLOT_FREE(&BlockClass) + index;
86483:     return addPropertyInternal(cx, id, block_getProperty, block_setProperty,
86483:                                slot, JSPROP_ENUMERATE | JSPROP_PERMANENT,
86483:                                Shape::HAS_SHORTID, index, spp,
86483:                                /* allowDictionary = */ false);
86483: }
86483: 
86483: Class js::BlockClass = {
86483:     "Block",
86483:     JSCLASS_HAS_PRIVATE |
86483:     JSCLASS_HAS_RESERVED_SLOTS(BlockObject::RESERVED_SLOTS) |
86483:     JSCLASS_IS_ANONYMOUS,
86483:     JS_PropertyStub,         /* addProperty */
86483:     JS_PropertyStub,         /* delProperty */
86483:     JS_PropertyStub,         /* getProperty */
86483:     JS_StrictPropertyStub,   /* setProperty */
86483:     JS_EnumerateStub,
86483:     JS_ResolveStub,
86483:     JS_ConvertStub
86483: };
86483: 
86483: #if JS_HAS_XDR
86483: 
86483: #define NO_PARENT_INDEX UINT32_MAX
86483: 
86483: static uint32_t
86483: FindObjectIndex(JSObjectArray *array, JSObject *obj)
86483: {
86483:     size_t i;
86483: 
86483:     if (array) {
86483:         i = array->length;
86483:         do {
86483: 
86483:             if (array->vector[--i] == obj)
86483:                 return i;
86483:         } while (i != 0);
86483:     }
86483: 
86483:     return NO_PARENT_INDEX;
86483: }
86483: 
86483: bool
86483: js_XDRStaticBlockObject(JSXDRState *xdr, StaticBlockObject **objp)
86483: {
87187:     JSContext *cx = xdr->cx;
86483: 
87187:     StaticBlockObject *obj = NULL;
87187:     uint32_t parentId = 0;
87187:     uint32_t count = 0;
87187:     uint32_t depthAndCount = 0;
86483:     if (xdr->mode == JSXDR_ENCODE) {
86483:         obj = *objp;
86483:         parentId = JSScript::isValidOffset(xdr->script->objectsOffset)
87187:                    ? FindObjectIndex(xdr->script->objects(), obj->enclosingBlock())
86483:                    : NO_PARENT_INDEX;
87187:         uint32_t depth = obj->stackDepth();
87187:         JS_ASSERT(depth <= UINT16_MAX);
87187:         count = obj->slotCount();
87187:         JS_ASSERT(count <= UINT16_MAX);
87187:         depthAndCount = (depth << 16) | uint16_t(count);
86483:     }
86483: 
86483:     /* First, XDR the parent atomid. */
86483:     if (!JS_XDRUint32(xdr, &parentId))
87187:         return false;
86483: 
86483:     if (xdr->mode == JSXDR_DECODE) {
86483:         obj = StaticBlockObject::create(cx);
86483:         if (!obj)
87187:             return false;
86483:         *objp = obj;
86483: 
86483:         /*
86483:          * If there's a parent id, then get the parent out of our script's
86483:          * object array. We know that we XDR block object in outer-to-inner
86483:          * order, which means that getting the parent now will work.
86483:          */
87187:         obj->setEnclosingBlock(parentId == NO_PARENT_INDEX
87187:                                ? NULL
87187:                                : &xdr->script->getObject(parentId)->asStaticBlock());
86483:     }
86483: 
86483:     AutoObjectRooter tvr(cx, obj);
86483: 
86483:     if (!JS_XDRUint32(xdr, &depthAndCount))
86483:         return false;
86483: 
86483:     if (xdr->mode == JSXDR_DECODE) {
87187:         uint32_t depth = uint16_t(depthAndCount >> 16);
86483:         count = uint16_t(depthAndCount);
86483:         obj->setStackDepth(depth);
86483: 
86483:         /*
86483:          * XDR the block object's properties. We know that there are 'count'
86483:          * properties to XDR, stored as id/shortid pairs.
86483:          */
86483:         for (uintN i = 0; i < count; i++) {
86483:             JSAtom *atom;
86483:             if (!js_XDRAtom(xdr, &atom))
86483:                 return false;
86483: 
87188:             /* The empty string indicates an int id. */
87188:             jsid id = atom != cx->runtime->emptyString
87188:                       ? ATOM_TO_JSID(atom)
87188:                       : INT_TO_JSID(i);
87188: 
86483:             bool redeclared;
87188:             if (!obj->addVar(cx, id, i, &redeclared)) {
86483:                 JS_ASSERT(!redeclared);
86483:                 return false;
86483:             }
86483:         }
86483:     } else {
86483:         AutoShapeVector shapes(cx);
86483:         shapes.growBy(count);
86483: 
86483:         for (Shape::Range r(obj->lastProperty()); !r.empty(); r.popFront()) {
87187:             const Shape *shape = &r.front();
86483:             shapes[shape->shortid()] = shape;
86483:         }
86483: 
86483:         /*
86483:          * XDR the block object's properties. We know that there are 'count'
86483:          * properties to XDR, stored as id/shortid pairs.
86483:          */
86483:         for (uintN i = 0; i < count; i++) {
87187:             const Shape *shape = shapes[i];
86483:             JS_ASSERT(shape->getter() == block_getProperty);
87187:             JS_ASSERT(uintN(shape->shortid()) == i);
86483: 
86483:             jsid propid = shape->propid();
87188:             JS_ASSERT(JSID_IS_ATOM(propid) || JSID_IS_INT(propid));
86483: 
87188:             /* The empty string indicates an int id. */
87188:             JSAtom *atom = JSID_IS_ATOM(propid)
87188:                            ? JSID_TO_ATOM(propid)
87188:                            : cx->runtime->emptyString;
87188: 
86483:             if (!js_XDRAtom(xdr, &atom))
86483:                 return false;
86483:         }
86483:     }
86483:     return true;
86483: }
86483: 
86483: #endif  /* JS_HAS_XDR */
