 98983: # This Source Code Form is subject to the terms of the Mozilla Public
 98983: # License, v. 2.0. If a copy of the MPL was not distributed with this
 98983: # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 35742: 
 35864: import os, sys
 35742: 
 42566: from ipdl.ast import CxxInclude, Decl, Loc, QualifiedId, State, StructDecl, TransitionStmt, TypeSpec, UnionDecl, UsingStmt, Visitor, ASYNC, SYNC, RPC, IN, OUT, INOUT, ANSWER, CALL, RECV, SEND
 35742: import ipdl.builtin as builtin
 35742: 
 36138: _DELETE_MSG = '__delete__'
 35990: 
 42560: 
 42560: def _otherside(side):
 42560:     if side == 'parent':  return 'child'
 42560:     elif side == 'child': return 'parent'
 42560:     else:  assert 0 and 'unknown side "%s"'% (side)
 42560: 
 42560: def unique_pairs(s):
 42560:     n = len(s)
 42560:     for i, e1 in enumerate(s):
 42560:         for j in xrange(i+1, n):
 42560:             yield (e1, s[j])
 42560: 
 42560: def cartesian_product(s1, s2):
 42560:     for e1 in s1:
 42560:         for e2 in s2:
 42560:             yield (e1, e2)
 42560: 
 42560: 
 35990: class TypeVisitor:
 42566:     def __init__(self):
 42566:         self.visited = set()
 42566: 
 35990:     def defaultVisit(self, node, *args):
 35990:         raise Exception, "INTERNAL ERROR: no visitor for node type `%s'"% (
 35990:             node.__class__.__name__)
 35990: 
 35990:     def visitVoidType(self, v, *args):
 35990:         pass
 35990: 
 35990:     def visitBuiltinCxxType(self, t, *args):
 35990:         pass
 35990: 
 35990:     def visitImportedCxxType(self, t, *args):
 35990:         pass
 35990: 
 35990:     def visitStateType(self, s, *args):
 35990:         pass
 35990: 
 35990:     def visitMessageType(self, m, *args):
 35990:         for param in m.params:
 35990:             param.accept(self, *args)
 35990:         for ret in m.returns:
 35990:             ret.accept(self, *args)
 35990:         if m.cdtype is not None:
 35990:             m.cdtype.accept(self, *args)
 35990: 
 35990:     def visitProtocolType(self, p, *args):
 35990:         # NB: don't visit manager and manages. a naive default impl
 35990:         # could result in an infinite loop
 35990:         pass
 35990: 
 35990:     def visitActorType(self, a, *args):
 35990:         a.protocol.accept(self, *args)
 35990:         a.state.accept(self, *args)
 35990: 
 42564:     def visitStructType(self, s, *args):
 42566:         if s in self.visited:
 42566:             return
 42566: 
 42566:         self.visited.add(s)
 42564:         for field in s.fields:
 42564:             field.accept(self, *args)
 42564: 
 42566:     def visitUnionType(self, u, *args):
 42566:         if u in self.visited:
 42566:             return
 42564: 
 42566:         self.visited.add(u)
 35990:         for component in u.components:
 35990:             component.accept(self, *args)
 35990: 
 35990:     def visitArrayType(self, a, *args):
 35990:         a.basetype.accept(self, *args)
 35990: 
 36134:     def visitShmemType(self, s, *args):
 36134:         pass
 36134: 
 36153:     def visitShmemChmodType(self, c, *args):
 36153:         c.shmem.accept(self)
 35990: 
 42566: 
 35742: class Type:
 35990:     def __cmp__(self, o):
 35990:         return cmp(self.fullname(), o.fullname())
 35990:     def __eq__(self, o):
 35990:         return (self.__class__ == o.__class__
 35990:                 and self.fullname() == o.fullname())
 35990:     def __hash__(self):
 35990:         return hash(self.fullname())
 35990: 
 35742:     # Is this a C++ type?
 35764:     def isCxx(self):
 35742:         return False
 35742:     # Is this an IPDL type?
 35764:     def isIPDL(self):
 35742:         return False
 42566:     # Is this type neither compound nor an array?
 42566:     def isAtom(self):
 42566:         return False
 35742:     # Can this type appear in IPDL programs?
 35764:     def isVisible(self):
 35742:         return False
 35742:     def isVoid(self):
 35742:         return False
 35742:     def typename(self):
 35742:         return self.__class__.__name__
 35742: 
 35742:     def name(self): raise Exception, 'NYI'
 35742:     def fullname(self): raise Exception, 'NYI'
 35742: 
 35990:     def accept(self, visitor, *args):
 35990:         visit = getattr(visitor, 'visit'+ self.__class__.__name__, None)
 35990:         if visit is None:
 35990:             return getattr(visitor, 'defaultVisit')(self, *args)
 35990:         return visit(self, *args)
 35990: 
 35742: class VoidType(Type):
 42566:     def isCxx(self):
 35742:         return True
 42566:     def isIPDL(self):
 42566:         return False
 42566:     def isAtom(self):
 35742:         return True
 35742:     def isVisible(self):
 42566:         return False
 35742:     def isVoid(self):
 35742:         return True
 35742: 
 35742:     def name(self): return 'void'
 35742:     def fullname(self): return 'void'
 35742: 
 35742: VOID = VoidType()
 35742: 
 35742: ##--------------------
 35742: class CxxType(Type):
 35742:     def isCxx(self):
 35742:         return True
 42566:     def isAtom(self):
 42566:         return True
 35742:     def isBuiltin(self):
 35742:         return False
 35742:     def isImported(self):
 35742:         return False
 35742:     def isGenerated(self):
 35742:         return False
 35742:     def isVisible(self):
 35742:         return True
 35742: 
 35742: class BuiltinCxxType(CxxType):
 35742:     def __init__(self, qname):
 35742:         assert isinstance(qname, QualifiedId)
 35742:         self.loc = qname.loc
 35742:         self.qname = qname
 35742:     def isBuiltin(self):  return True
 35742: 
 35742:     def name(self):
 35742:         return self.qname.baseid
 35742:     def fullname(self):
 35742:         return str(self.qname)
 35742: 
 35742: class ImportedCxxType(CxxType):
 35742:     def __init__(self, qname):
 35742:         assert isinstance(qname, QualifiedId)
 35742:         self.loc = qname.loc
 35742:         self.qname = qname
 35742:     def isImported(self): return True
 35742: 
 35742:     def name(self):
 35742:         return self.qname.baseid
 35742:     def fullname(self):
 35742:         return str(self.qname)
 35742: 
 35742: ##--------------------
 35742: class IPDLType(Type):
 35742:     def isIPDL(self):  return True
 35742:     def isVisible(self): return True
 35763:     def isState(self): return False
 35763:     def isMessage(self): return False
 35759:     def isProtocol(self): return False
 35764:     def isActor(self): return False
 42564:     def isStruct(self): return False
 35900:     def isUnion(self): return False
 35990:     def isArray(self): return False
 42566:     def isAtom(self):  return True
 42566:     def isCompound(self): return False
 36134:     def isShmem(self): return False
 36153:     def isChmod(self): return False
 35742: 
 35742:     def isAsync(self): return self.sendSemantics is ASYNC
 35742:     def isSync(self): return self.sendSemantics is SYNC
 35742:     def isRpc(self): return self.sendSemantics is RPC
 35742: 
 35742:     def talksAsync(self): return True
 35742:     def talksSync(self): return self.isSync() or self.isRpc()
 35742:     def talksRpc(self): return self.isRpc()
 35742: 
 35742:     def hasReply(self):  return self.isSync() or self.isRpc()
 35742: 
 35742:     def needsMoreJuiceThan(self, o):
 35742:         return (o.isAsync() and not self.isAsync()
 35742:                 or o.isSync() and self.isRpc())
 35742: 
 35763: class StateType(IPDLType):
 36134:     def __init__(self, protocol, name, start=False):
 36134:         self.protocol = protocol
 36134:         self.name = name
 35868:         self.start = start
 36134:     def isState(self): return True
 36134:     def name(self):
 36134:         return self.name
 36134:     def fullname(self):
 36134:         return self.name()
 35763: 
 35742: class MessageType(IPDLType):
 35742:     def __init__(self, sendSemantics, direction,
 35742:                  ctor=False, dtor=False, cdtype=None):
 35742:         assert not (ctor and dtor)
 35742:         assert not (ctor or dtor) or type is not None
 35742: 
 35742:         self.sendSemantics = sendSemantics
 35742:         self.direction = direction
 35742:         self.params = [ ]
 35742:         self.returns = [ ]
 35742:         self.ctor = ctor
 35742:         self.dtor = dtor
 35742:         self.cdtype = cdtype
 35742:     def isMessage(self): return True
 35742: 
 35742:     def isCtor(self): return self.ctor
 35742:     def isDtor(self): return self.dtor
 35742:     def constructedType(self):  return self.cdtype
 35742: 
 35742:     def isIn(self): return self.direction is IN
 35742:     def isOut(self): return self.direction is OUT
 35742:     def isInout(self): return self.direction is INOUT
 35742: 
 35744:     def hasImplicitActorParam(self):
 35744:         return self.isCtor() or self.isDtor()
 35744: 
 42560: class Bridge:
 42560:     def __init__(self, parentPtype, childPtype):
 42560:         assert parentPtype.isToplevel() and childPtype.isToplevel()
 42560:         self.parent = parentPtype
 42560:         self.child = childPtype
 42560: 
 42560:     def __cmp__(self, o):
 42560:         return cmp(self.parent, o.parent) or cmp(self.child, o.child)
 42560:     def __eq__(self, o):
 42560:         return self.parent == o.parent and self.child == o.child
 42560:     def __hash__(self):
 42560:         return hash(self.parent) + hash(self.child)
 42560: 
 35742: class ProtocolType(IPDLType):
 36138:     def __init__(self, qname, sendSemantics, stateless=False):
 35742:         self.qname = qname
 35742:         self.sendSemantics = sendSemantics
 42560:         self.spawns = set()             # ProtocolType
 71249:         self.opens = set()              # ProtocolType
 38096:         self.managers = set()           # ProtocolType
 35742:         self.manages = [ ]
 36138:         self.stateless = stateless
 47710:         self.hasDelete = False
100756:         self.hasReentrantDelete = False
 35742:     def isProtocol(self): return True
 35742: 
 35742:     def name(self):
 35742:         return self.qname.baseid
 35742:     def fullname(self):
 35742:         return str(self.qname)
 35742: 
 38096:     def addManager(self, mgrtype):
 38096:         assert mgrtype.isIPDL() and mgrtype.isProtocol()
 38096:         self.managers.add(mgrtype)
 38096: 
 42560:     def addSpawn(self, ptype):
 42560:         assert self.isToplevel() and  ptype.isToplevel()
 42560:         self.spawns.add(ptype)
 42560: 
 71249:     def addOpen(self, ptype):
 71249:         assert self.isToplevel() and  ptype.isToplevel()
 71249:         self.opens.add(ptype)
 71249: 
 35742:     def managedBy(self, mgr):
 38096:         self.managers = mgr
 35742: 
 35849:     def toplevel(self):
 35849:         if self.isToplevel():
 35849:             return self
 38096:         for mgr in self.managers:
 41368:             if mgr is not self:
 38096:                 return mgr.toplevel()
 35849: 
 35744:     def isManagerOf(self, pt):
 35742:         for managed in self.manages:
 35742:             if pt is managed:
 35742:                 return True
 35742:         return False
 38096:     def isManagedBy(self, pt):
 38096:         return pt in self.managers
 38096: 
 35744:     def isManager(self):
 35744:         return len(self.manages) > 0
 35742:     def isManaged(self):
 38096:         return 0 < len(self.managers)
 35742:     def isToplevel(self):
 35742:         return not self.isManaged()
 35742: 
 41368:     def manager(self):
 41368:         assert 1 == len(self.managers)
 41368:         for mgr in self.managers: return mgr
 41368: 
 35764: class ActorType(IPDLType):
 36135:     def __init__(self, protocol, state=None, nullable=0):
 35764:         self.protocol = protocol
 35764:         self.state = state
 36135:         self.nullable = nullable
 35764:     def isActor(self): return True
 35764: 
 35764:     def name(self):
 35764:         return self.protocol.name()
 35764:     def fullname(self):
 35764:         return self.protocol.fullname()
 35764: 
 42566: class _CompoundType(IPDLType):
 42566:     def __init__(self):
 42566:         self.defined = False            # bool
 42566:         self.mutualRec = set()          # set(_CompoundType | ArrayType)
 42566:     def isAtom(self):
 42566:         return False
 42566:     def isCompound(self):
 42566:         return True
 42566:     def itercomponents(self):
 63949:         raise Exception('"pure virtual" method')
 42566: 
 42566:     def mutuallyRecursiveWith(self, t, exploring=None):
 42566:         '''|self| is mutually recursive with |t| iff |self| and |t|
 42566: are in a cycle in the type graph rooted at |self|.  This function
 42566: looks for such a cycle and returns True if found.'''
 42566:         if exploring is None:
 42566:             exploring = set()
 42566: 
 42566:         if t.isAtom():
 42566:             return False
 42566:         elif t is self or t in self.mutualRec:
 42566:             return True
 42566:         elif t.isArray():
 42566:             isrec = self.mutuallyRecursiveWith(t.basetype, exploring)
 42566:             if isrec:  self.mutualRec.add(t)
 42566:             return isrec
 42566:         elif t in exploring:
 42566:             return False
 42566: 
 42566:         exploring.add(t)
 42566:         for c in t.itercomponents():
 42566:             if self.mutuallyRecursiveWith(c, exploring):
 42566:                 self.mutualRec.add(c)
 42566:                 return True
 42566:         exploring.remove(t)
 42566: 
 42566:         return False
 42566: 
 42566: class StructType(_CompoundType):
 42564:     def __init__(self, qname, fields):
 42566:         _CompoundType.__init__(self)
 42564:         self.qname = qname
 42564:         self.fields = fields            # [ Type ]
 42564: 
 42564:     def isStruct(self):   return True
 42566:     def itercomponents(self):
 42566:         for f in self.fields:
 42566:             yield f
 42566:     
 42564:     def name(self): return self.qname.baseid
 42564:     def fullname(self): return str(self.qname)
 42564: 
 42566: class UnionType(_CompoundType):
 35900:     def __init__(self, qname, components):
 42566:         _CompoundType.__init__(self)
 35900:         self.qname = qname
 42566:         self.components = components    # [ Type ]
 35900: 
 35907:     def isUnion(self):    return True
 42566:     def itercomponents(self):
 42566:         for c in self.components:
 42566:             yield c
 42566: 
 35900:     def name(self): return self.qname.baseid
 35900:     def fullname(self): return str(self.qname)
 35900: 
 35990: class ArrayType(IPDLType):
 35990:     def __init__(self, basetype):
 35990:         self.basetype = basetype
 42566:     def isAtom(self):  return False
 42566:     def isArray(self): return True
 35990: 
 35990:     def name(self): return self.basetype.name() +'[]'
 35990:     def fullname(self): return self.basetype.fullname() +'[]'
 35990: 
 36134: class ShmemType(IPDLType):
 36134:     def __init__(self, qname):
 36134:         self.qname = qname
 36134:     def isShmem(self): return True
 36134: 
 36134:     def name(self):
 36134:         return self.qname.baseid
 36134:     def fullname(self):
 36134:         return str(self.qname)
 36134: 
 42566: def iteractortypes(t, visited=None):
 35990:     """Iterate over any actor(s) buried in |type|."""
 42566:     if visited is None:
 42566:         visited = set()
 42566: 
 35990:     # XXX |yield| semantics makes it hard to use TypeVisitor
 42566:     if not t.isIPDL():
 35990:         return
 42566:     elif t.isActor():
 42566:         yield t
 42566:     elif t.isArray():
 42566:         for actor in iteractortypes(t.basetype, visited):
 35990:             yield actor
 42566:     elif t.isCompound() and t not in visited:
 42566:         visited.add(t)
 42566:         for c in t.itercomponents():
 42566:             for actor in iteractortypes(c, visited):
 42564:                 yield actor
 36153: 
 35990: def hasactor(type):
 35990:     """Return true iff |type| is an actor or has one buried within."""
 35990:     for _ in iteractortypes(type): return True
 35990:     return False
 35990: 
 36134: def hasshmem(type):
 36134:     """Return true iff |type| is shmem or has it buried within."""
 36134:     class found: pass
 36134:     class findShmem(TypeVisitor):
 36134:         def visitShmemType(self, s):  raise found()
 36134:     try:
 36134:         type.accept(findShmem())
 36134:     except found:
 36134:         return True
 36134:     return False
 36134: 
 35742: ##--------------------
 35742: _builtinloc = Loc('<builtin>', 0)
 35742: def makeBuiltinUsing(tname):
 35742:     quals = tname.split('::')
 35742:     base = quals.pop()
 35742:     quals = quals[0:]
 35742:     return UsingStmt(_builtinloc,
 35742:                      TypeSpec(_builtinloc,
 35742:                               QualifiedId(_builtinloc, base, quals)))
 35742: 
 35742: builtinUsing = [ makeBuiltinUsing(t) for t in builtin.Types ]
 35742: builtinIncludes = [ CxxInclude(_builtinloc, f) for f in builtin.Includes ]
 35742: 
 35845: def errormsg(loc, fmt, *args):
 35845:     while not isinstance(loc, Loc):
 35845:         if loc is None:  loc = Loc.NONE
 35845:         else:            loc = loc.loc
 35845:     return '%s: error: %s'% (str(loc), fmt % args)
 35845: 
 35742: ##--------------------
 35742: class SymbolTable:
 35742:     def __init__(self, errors):
 35742:         self.errors = errors
 35742:         self.scopes = [ { } ]   # stack({})
 35742:         self.globalScope = self.scopes[0]
 35742:         self.currentScope = self.globalScope
 35742:     
 35742:     def enterScope(self, node):
 35742:         assert (isinstance(self.scopes[0], dict)
 35742:                 and self.globalScope is self.scopes[0])
 35742:         assert (isinstance(self.currentScope, dict))
 35742: 
 35742:         if not hasattr(node, 'symtab'):
 35742:             node.symtab = { }
 35742: 
 35742:         self.scopes.append(node.symtab)
 35742:         self.currentScope = self.scopes[-1]
 35742: 
 35742:     def exitScope(self, node):
 35742:         symtab = self.scopes.pop()
 35742:         assert self.currentScope is symtab
 35742: 
 35742:         self.currentScope = self.scopes[-1]
 35742: 
 35742:         assert (isinstance(self.scopes[0], dict)
 35742:                 and self.globalScope is self.scopes[0])
 35742:         assert isinstance(self.currentScope, dict)
 35742: 
 35742:     def lookup(self, sym):
 35742:         # NB: since IPDL doesn't allow any aliased names of different types,
 35742:         # it doesn't matter in which order we walk the scope chain to resolve
 35742:         # |sym|
 35742:         for scope in self.scopes:
 35742:             decl = scope.get(sym, None)
 35742:             if decl is not None:  return decl
 35742:         return None
 35742: 
 35742:     def declare(self, decl):
 35742:         assert decl.progname or decl.shortname or decl.fullname
 35742:         assert decl.loc
 35742:         assert decl.type
 35742: 
 35742:         def tryadd(name):
 35742:             olddecl = self.lookup(name)
 35742:             if olddecl is not None:
 35742:                 self.errors.append(errormsg(
 35742:                         decl.loc,
 35742:                         "redeclaration of symbol `%s', first declared at %s",
 35742:                         name, olddecl.loc))
 35742:                 return
 35742:             self.currentScope[name] = decl
 35742:             decl.scope = self.currentScope
 35742: 
 35742:         if decl.progname:  tryadd(decl.progname)
 35742:         if decl.shortname: tryadd(decl.shortname)
 35742:         if decl.fullname:  tryadd(decl.fullname)
 35742: 
 35742: 
 35793: class TypeCheck:
 35742:     '''This pass sets the .type attribute of every AST node.  For some
 35742: nodes, the type is meaningless and it is set to "VOID."  This pass
 35742: also sets the .decl attribute of AST nodes for which that is relevant;
 35742: a decl says where, with what type, and under what name(s) a node was
 35742: declared.
 35742: 
 35742: With this information, it finally type checks the AST.'''
 35742: 
 35742:     def __init__(self):
 35742:         # NB: no IPDL compile will EVER print a warning.  A program has
 35742:         # one of two attributes: it is either well typed, or not well typed.
 35742:         self.errors = [ ]       # [ string ]
 35742: 
 35742:     def check(self, tu, errout=sys.stderr):
 35793:         def runpass(tcheckpass):
 35793:             tu.accept(tcheckpass)
 35793:             if len(self.errors):
 35793:                 self.reportErrors(errout)
 35793:                 return False
 35793:             return True
 35793: 
 35742:         tu.cxxIncludes = builtinIncludes + tu.cxxIncludes
 35742: 
 35742:         # tag each relevant node with "decl" information, giving type, name,
 35742:         # and location of declaration
 35852:         if not runpass(GatherDecls(builtinUsing, self.errors)):
 35742:             return False
 35742: 
 35742:         # now that the nodes have decls, type checking is much easier.
 35852:         if not runpass(CheckTypes(self.errors)):
 35793:             return False
 35793: 
 42560:         if not (runpass(BuildProcessGraph(self.errors))
 42560:                 and runpass(CheckProcessGraph(self.errors))):
 42560:             return False
 42560: 
 35867:         if (len(tu.protocol.startStates)
 35852:             and not runpass(CheckStateMachine(self.errors))):
 35742:             return False
 35742:         return True
 35742: 
 35742:     def reportErrors(self, errout):
 35742:         for error in self.errors:
 35742:             print >>errout, error
 35742: 
 35742: 
 35793: class TcheckVisitor(Visitor):
 35793:     def __init__(self, symtab, errors):
 35742:         self.symtab = symtab
 35742:         self.errors = errors
 35793: 
 35793:     def error(self, loc, fmt, *args):
 35845:         self.errors.append(errormsg(loc, fmt, *args))
 35793: 
 35793:     def declare(self, loc, type, shortname=None, fullname=None, progname=None):
 35793:         d = Decl(loc)
 35793:         d.type = type
 35793:         d.progname = progname
 35793:         d.shortname = shortname
 35793:         d.fullname = fullname
 35793:         self.symtab.declare(d)
 35793:         return d
 35793: 
 35793: class GatherDecls(TcheckVisitor):
 35852:     def __init__(self, builtinUsing, errors):
 35852:         # |self.symtab| is the symbol table for the translation unit
 35852:         # currently being visited
 35852:         TcheckVisitor.__init__(self, None, errors)
 35793:         self.builtinUsing = builtinUsing
 35742: 
 35852:     def visitTranslationUnit(self, tu):
 35852:         # all TranslationUnits declare symbols in global scope
 35852:         if hasattr(tu, 'symtab'):
 35852:             return
 35852:         tu.symtab = SymbolTable(self.errors)
 35852:         savedSymtab = self.symtab
 35852:         self.symtab = tu.symtab
 35852: 
 35852:         # pretend like the translation unit "using"-ed these for the
 35852:         # sake of type checking and C++ code generation
 35852:         tu.using = self.builtinUsing + tu.using
 35742: 
 35742:         p = tu.protocol
 35742: 
 35864:         # for everyone's sanity, enforce that the filename and
 35864:         # protocol name match
 35864:         basefilename = os.path.basename(tu.filename)
 35864:         expectedfilename = '%s.ipdl'% (p.name)
 35864: 
 35864:         if basefilename != expectedfilename:
 35864:             self.error(p.loc,
 35864:                        "expected file defining protocol `%s' to be named `%s'; instead it's named `%s'",
 35864:                        p.name, expectedfilename, basefilename)
 35864: 
 35742:         # FIXME/cjones: it's a little weird and counterintuitive to put
 35742:         # both the namespace and non-namespaced name in the global scope.
 35742:         # try to figure out something better; maybe a type-neutral |using|
 35742:         # that works for C++ and protocol types?
 35900:         qname = p.qname()
 35793:         if 0 == len(qname.quals):
 35793:             fullname = None
 35793:         else:
 35793:             fullname = str(qname)
 35793:         p.decl = self.declare(
 35793:             loc=p.loc,
 36138:             type=ProtocolType(qname, p.sendSemantics,
 36138:                               stateless=(0 == len(p.transitionStmts))),
 35793:             shortname=p.name,
 35793:             fullname=fullname)
 35742: 
 35998:         # XXX ugh, this sucks.  but we need this information to compute
 35998:         # what friend decls we need in generated C++
 35998:         p.decl.type._p = p
 35998: 
 35742:         # make sure we have decls for all dependent protocols
 35742:         for pinc in tu.protocolIncludes:
 35742:             pinc.accept(self)
 35742: 
 35852:         # declare imported (and builtin) C++ types
 35742:         for using in tu.using:
 35742:             using.accept(self)
 35742: 
 42566:         # first pass to "forward-declare" all structs and unions in
 42566:         # order to support recursive definitions
 42566:         for su in tu.structsAndUnions:
 42566:             qname = su.qname()
 42566:             if 0 == len(qname.quals):
 42566:                 fullname = None
 42566:             else:
 42566:                 fullname = str(qname)
 42566: 
 42566:             if isinstance(su, StructDecl):
 42566:                 sutype = StructType(qname, [ ])
 42566:             elif isinstance(su, UnionDecl):
 42566:                 sutype = UnionType(qname, [ ])
 42566:             else: assert 0 and 'unknown type'
 42566: 
 42566:             su.decl = self.declare(
 42566:                 loc=su.loc,
 42566:                 type=sutype,
 42566:                 shortname=su.name,
 42566:                 fullname=fullname)
 42566: 
 42566:         # second pass to check each definition
 42564:         for su in tu.structsAndUnions:
 42564:             su.accept(self)
 35900: 
 35742:         # grab symbols in the protocol itself
 35742:         p.accept(self)
 35742: 
 35852:         tu.type = VOID
 35742: 
 35852:         self.symtab = savedSymtab
 35852: 
 35742: 
 35742:     def visitProtocolInclude(self, pi):
 36138:         if pi.tu is None:
 36138:             self.error(
 36138:                 pi.loc,
 36138:                 "(type checking here will be unreliable because of an earlier error)")
 36138:             return
 35742:         pi.tu.accept(self)
 35852:         self.symtab.declare(pi.tu.protocol.decl)
 35742: 
 42564:     def visitStructDecl(self, sd):
 42564:         stype = sd.decl.type
 42564: 
 42564:         self.symtab.enterScope(sd)
 42564: 
 42564:         for f in sd.fields:
 42564:             ftypedecl = self.symtab.lookup(str(f.type))
 42564:             if ftypedecl is None:
 42564:                 self.error(f.loc, "field `%s' of struct `%s' has unknown type `%s'",
 42564:                            f.name, sd.name, str(f.type))
 42564:                 continue
 42564: 
 42564:             f.decl = self.declare(
 42564:                 loc=f.loc,
 42564:                 type=self._canonicalType(ftypedecl.type, f.type),
 42564:                 shortname=f.name,
 42564:                 fullname=None)
 42564:             stype.fields.append(f.decl.type)
 42564: 
 42564:         self.symtab.exitScope(sd)
 42564: 
 35900:     def visitUnionDecl(self, ud):
 42566:         utype = ud.decl.type
 35900:         
 35900:         for c in ud.components:
 35990:             cdecl = self.symtab.lookup(str(c))
 35990:             if cdecl is None:
 35990:                 self.error(c.loc, "unknown component type `%s' of union `%s'",
 35990:                            str(c), ud.name)
 35990:                 continue
 42566:             utype.components.append(self._canonicalType(cdecl.type, c))
 35900: 
 35742:     def visitUsingStmt(self, using):
 35742:         fullname = str(using.type)
 35793:         if using.type.basename() == fullname:
 35793:             fullname = None
 36134:         if fullname == 'mozilla::ipc::Shmem':
 36134:             ipdltype = ShmemType(using.type.spec)
 36134:         else:
 36134:             ipdltype = ImportedCxxType(using.type.spec)
 35793:         using.decl = self.declare(
 35793:             loc=using.loc,
 36134:             type=ipdltype,
 35793:             shortname=using.type.basename(),
 35793:             fullname=fullname)
 35742: 
 35742:     def visitProtocol(self, p):
 35742:         # protocol scope
 35742:         self.symtab.enterScope(p)
 35742: 
 42560:         for spawns in p.spawnsStmts:
 42560:             spawns.accept(self)
 42560: 
 42560:         for bridges in p.bridgesStmts:
 42560:             bridges.accept(self)
 42560: 
 71249:         for opens in p.opensStmts:
 71249:             opens.accept(self)
 71249: 
 38096:         seenmgrs = set()
 38096:         for mgr in p.managers:
 38096:             if mgr.name in seenmgrs:
 38096:                 self.error(mgr.loc, "manager `%s' appears multiple times",
 38096:                            mgr.name)
 38096:                 continue
 38096: 
 38096:             seenmgrs.add(mgr.name)
 38096:             mgr.of = p
 38096:             mgr.accept(self)
 35742: 
 35742:         for managed in p.managesStmts:
 35742:             managed.manager = p
 35742:             managed.accept(self)
 35742: 
 38096:         if 0 == len(p.managers) and 0 == len(p.messageDecls):
 35863:             self.error(p.loc,
 35863:                        "top-level protocol `%s' cannot be empty",
 35863:                        p.name)
 35863: 
 35742:         setattr(self, 'currentProtocolDecl', p.decl)
 35742:         for msg in p.messageDecls:
 35742:             msg.accept(self)
 35742:         del self.currentProtocolDecl
 35742: 
 47710:         p.decl.type.hasDelete = (not not self.symtab.lookup(_DELETE_MSG))
 47710:         if not (p.decl.type.hasDelete or p.decl.type.isToplevel()):
 36138:             self.error(
 36138:                 p.loc,
 38096:                 "destructor declaration `%s(...)' required for managed protocol `%s'",
 38096:                 _DELETE_MSG, p.name)
 36138: 
100756:         p.decl.type.hasReentrantDelete = p.decl.type.hasDelete and self.symtab.lookup(_DELETE_MSG).type.isRpc()
100756: 
 35762:         for managed in p.managesStmts:
 35762:             mgdname = managed.name
 35762:             ctordecl = self.symtab.lookup(mgdname +'Constructor')
 35762: 
 36138:             if not (ctordecl and ctordecl.type.isCtor()):
 35793:                 self.error(
 35762:                     managed.loc,
 36138:                     "constructor declaration required for managed protocol `%s' (managed by protocol `%s')",
 35793:                     mgdname, p.name)
 35762: 
 35793:         p.states = { }
 35868:         
 35793:         if len(p.transitionStmts):
 35867:             p.startStates = [ ts for ts in p.transitionStmts
 35867:                               if ts.state.start ]
 35867:             if 0 == len(p.startStates):
 35867:                 p.startStates = [ p.transitionStmts[0] ]
 35867: 
100756:         # declare implicit "any", "dead", and "dying" states
 36138:         self.declare(loc=State.ANY.loc,
 36138:                      type=StateType(p.decl.type, State.ANY.name, start=False),
 36138:                      progname=State.ANY.name)
 36138:         self.declare(loc=State.DEAD.loc,
 36138:                      type=StateType(p.decl.type, State.DEAD.name, start=False),
 36138:                      progname=State.DEAD.name)
100756:         if p.decl.type.hasReentrantDelete:
100756:             self.declare(loc=State.DYING.loc,
100756:                          type=StateType(p.decl.type, State.DYING.name, start=False),
100756:                          progname=State.DYING.name)
 36138: 
 35763:         # declare each state before decorating their mention
 35763:         for trans in p.transitionStmts:
 35793:             p.states[trans.state] = trans
 35793:             trans.state.decl = self.declare(
 35793:                 loc=trans.state.loc,
 36134:                 type=StateType(p.decl.type, trans.state, trans.state.start),
 35793:                 progname=trans.state.name)
 35763: 
 35742:         for trans in p.transitionStmts:
 35868:             self.seentriggers = set()
 35742:             trans.accept(self)
 35742: 
 36138:         if not (p.decl.type.stateless
 36138:                 or (p.decl.type.isToplevel()
 36138:                     and None is self.symtab.lookup(_DELETE_MSG))):
 36138:             # add a special state |state DEAD: null goto DEAD;|
 36138:             deadtrans = TransitionStmt.makeNullStmt(State.DEAD)
 36138:             p.states[State.DEAD] = deadtrans           
100756:             if p.decl.type.hasReentrantDelete:
100756:                 dyingtrans = TransitionStmt.makeNullStmt(State.DYING)
100756:                 p.states[State.DYING] = dyingtrans
 36138: 
 35764:         # visit the message decls once more and resolve the state names
 35764:         # attached to actor params and returns
 35990:         def resolvestate(loc, actortype):
 35990:             assert actortype.isIPDL() and actortype.isActor()
 35990: 
 35990:             # already resolved this guy's state
 35990:             if isinstance(actortype.state, Decl):
 35990:                 return
 35990:             
 35990:             if actortype.state is None:
 35894:                 # we thought this was a C++ type until type checking,
 35894:                 # when we realized it was an IPDL actor type.  But
 35894:                 # that means that the actor wasn't specified to be in
 35894:                 # any particular state
 35990:                 actortype.state = State.ANY
 35894: 
 35990:             statename = actortype.state.name
 35990:             # FIXME/cjones: this is just wrong.  we need the symbol table
 35990:             # of the protocol this actor refers to.  low priority bug
 35990:             # since nobody's using this feature yet
 35764:             statedecl = self.symtab.lookup(statename)
 35764:             if statedecl is None:
 35793:                 self.error(
 35764:                     loc,
 35764:                     "protocol `%s' does not have the state `%s'",
 35990:                     actortype.protocol.name(),
 35793:                     statename)
 35764:             elif not statedecl.type.isState():
 35793:                 self.error(
 35764:                     loc,
 35764:                     "tag `%s' is supposed to be of state type, but is instead of type `%s'",
 35764:                     statename,
 35793:                     statedecl.type.typename())
 35764:             else:
 36134:                 actortype.state = statedecl.type
 35764: 
 35764:         for msg in p.messageDecls:
 35764:             for iparam in msg.inParams:
 35990:                 loc = iparam.loc
 35990:                 for actortype in iteractortypes(iparam.type):
 35990:                     resolvestate(loc, actortype)
 35764:             for oparam in msg.outParams:
 35990:                 loc = oparam.loc
 35990:                 for actortype in iteractortypes(oparam.type):
 35990:                     resolvestate(loc, actortype)
 35764: 
 35762:         # FIXME/cjones declare all the little C++ thingies that will
 35762:         # be generated.  they're not relevant to IPDL itself, but
 35762:         # those ("invisible") symbols can clash with others in the
 35762:         # IPDL spec, and we'd like to catch those before C++ compilers
 35762:         # are allowed to obfuscate the error
 35742: 
 35742:         self.symtab.exitScope(p)
 35742: 
 35742: 
 42560:     def visitSpawnsStmt(self, spawns):
 42560:         pname = spawns.proto
 42560:         spawns.proto = self.symtab.lookup(pname)
 42560:         if spawns.proto is None:
 42560:             self.error(spawns.loc,
 42560:                        "spawned protocol `%s' has not been declared",
 42560:                        pname)
 42560: 
 42560:     def visitBridgesStmt(self, bridges):
 42560:         def lookup(p):
 42560:             decl = self.symtab.lookup(p)
 42560:             if decl is None:
 42560:                 self.error(bridges.loc,
 42560:                            "bridged protocol `%s' has not been declared", p)
 42560:             return decl
 42560:         bridges.parentSide = lookup(bridges.parentSide)
 42560:         bridges.childSide = lookup(bridges.childSide)
 42560: 
 71249:     def visitOpensStmt(self, opens):
 71249:         pname = opens.proto
 71249:         opens.proto = self.symtab.lookup(pname)
 71249:         if opens.proto is None:
 71249:             self.error(opens.loc,
 71249:                        "opened protocol `%s' has not been declared",
 71249:                        pname)
 71249: 
 42560: 
 38096:     def visitManager(self, mgr):
 35742:         mgrdecl = self.symtab.lookup(mgr.name)
 35742:         pdecl = mgr.of.decl
 35742:         assert pdecl
 35742: 
 35742:         pname, mgrname = pdecl.shortname, mgr.name
 35742:         loc = mgr.loc
 35742: 
 35742:         if mgrdecl is None:
 35793:             self.error(
 35742:                 loc,
 35742:                 "protocol `%s' referenced as |manager| of `%s' has not been declared",
 35793:                 mgrname, pname)
 35742:         elif not isinstance(mgrdecl.type, ProtocolType):
 35793:             self.error(
 35742:                 loc,
 35742:                 "entity `%s' referenced as |manager| of `%s' is not of `protocol' type; instead it is of type `%s'",
 35793:                 mgrname, pname, mgrdecl.type.typename())
 35742:         else:
 35742:             mgr.decl = mgrdecl
 38096:             pdecl.type.addManager(mgrdecl.type)
 35742: 
 35742: 
 35742:     def visitManagesStmt(self, mgs):
 35742:         mgsdecl = self.symtab.lookup(mgs.name)
 35742:         pdecl = mgs.manager.decl
 35742:         assert pdecl
 35742: 
 35742:         pname, mgsname = pdecl.shortname, mgs.name
 35742:         loc = mgs.loc
 35742: 
 35742:         if mgsdecl is None:
 35793:             self.error(loc,
 35742:                        "protocol `%s', managed by `%s', has not been declared",
 35844:                        mgsname, pname)
 35742:         elif not isinstance(mgsdecl.type, ProtocolType):
 35793:             self.error(
 35742:                 loc,
 35742:                 "%s declares itself managing a non-`protocol' entity `%s' of type `%s'",
 35844:                 pname, mgsname, mgsdecl.type.typename())
 35742:         else:
 35742:             mgs.decl = mgsdecl
 35742:             pdecl.type.manages.append(mgsdecl.type)
 35742: 
 35742: 
 35742:     def visitMessageDecl(self, md):
 35742:         msgname = md.name
 35742:         loc = md.loc
 35742: 
 35742:         isctor = False
 35742:         isdtor = False
 35742:         cdtype = None
 35742: 
 35742:         decl = self.symtab.lookup(msgname)
 35742:         if decl is not None and decl.type.isProtocol():
 35742:             # probably a ctor.  we'll check validity later.
 35742:             msgname += 'Constructor'
 35742:             isctor = True
 35742:             cdtype = decl.type
 35742:         elif decl is not None:
 35793:             self.error(loc, "message name `%s' already declared as `%s'",
 35793:                        msgname, decl.type.typename())
 35742:             # if we error here, no big deal; move on to find more
 36138: 
 36138:         if _DELETE_MSG == msgname:
 36138:             isdtor = True
 36138:             cdtype = self.currentProtocolDecl.type
 36138: 
 35742: 
 35742:         # enter message scope
 35742:         self.symtab.enterScope(md)
 35742: 
 35742:         msgtype = MessageType(md.sendSemantics, md.direction,
 35742:                               ctor=isctor, dtor=isdtor, cdtype=cdtype)
 35742: 
 35742:         # replace inparam Param nodes with proper Decls
 35764:         def paramToDecl(param):
 35764:             ptname = param.typespec.basename()
 35764:             ploc = param.typespec.loc
 35742: 
 35764:             ptdecl = self.symtab.lookup(ptname)
 35764:             if ptdecl is None:
 35793:                 self.error(
 35764:                     ploc,
 35764:                     "argument typename `%s' of message `%s' has not been declared",
 35793:                     ptname, msgname)
 42566:                 ptype = VOID
 35742:             else:
 36135:                 ptype = self._canonicalType(ptdecl.type, param.typespec,
 36135:                                             chmodallowed=1)
 42566:             return self.declare(loc=ploc,
 35793:                                 type=ptype,
 35793:                                 progname=param.name)
 35742: 
 35764:         for i, inparam in enumerate(md.inParams):
 35764:             pdecl = paramToDecl(inparam)
 35764:             msgtype.params.append(pdecl.type)
 35764:             md.inParams[i] = pdecl
 35742:         for i, outparam in enumerate(md.outParams):
 35764:             pdecl = paramToDecl(outparam)
 35764:             msgtype.returns.append(pdecl.type)
 35764:             md.outParams[i] = pdecl
 35742: 
 35742:         self.symtab.exitScope(md)
 35742: 
 35793:         md.decl = self.declare(
 35793:             loc=loc,
 35793:             type=msgtype,
 35793:             progname=msgname)
 35742:         md.protocolDecl = self.currentProtocolDecl
 47710:         md.decl._md = md
 35742: 
 35742: 
 35868:     def visitTransitionStmt(self, ts):
 35868:         self.seentriggers = set()
 35868:         TcheckVisitor.visitTransitionStmt(self, ts)
 35868: 
 35763:     def visitTransition(self, t):
 35763:         loc = t.loc
 35763: 
 35868:         # check the trigger message
 35868:         mname = t.msg
 36171:         if t in self.seentriggers:
 36171:             self.error(loc, "trigger `%s' appears multiple times", t.msg)
 36171:         self.seentriggers.add(t)
 35763: 
 35763:         mdecl = self.symtab.lookup(mname)
 36171:         if mdecl is not None and mdecl.type.isIPDL() and mdecl.type.isProtocol():
 36140:             mdecl = self.symtab.lookup(mname +'Constructor')
 36140:         
 35763:         if mdecl is None:
 35793:             self.error(loc, "message `%s' has not been declared", mname)
 35763:         elif not mdecl.type.isMessage():
 35793:             self.error(
 35763:                 loc,
 35763:                 "`%s' should have message type, but instead has type `%s'",
 35793:                 mname, mdecl.type.typename())
 35763:         else:
 35763:             t.msg = mdecl
 35763: 
 35868:         # check the to-states
 35868:         seenstates = set()
 35868:         for toState in t.toStates:
 35868:             sname = toState.name
 35868:             sdecl = self.symtab.lookup(sname)
 35868: 
 35868:             if sname in seenstates:
 35868:                 self.error(loc, "to-state `%s' appears multiple times", sname)
 35868:             seenstates.add(sname)
 35868: 
 35868:             if sdecl is None:
 35868:                 self.error(loc, "state `%s' has not been declared", sname)
 35868:             elif not sdecl.type.isState():
 35868:                 self.error(
 35868:                     loc, "`%s' should have state type, but instead has type `%s'",
 35868:                     sname, sdecl.type.typename())
 35868:             else:
 35868:                 toState.decl = sdecl
 35868:                 toState.start = sdecl.type.start
 35868: 
 35868:         t.toStates = set(t.toStates)
 35868: 
 36135: 
 36135:     def _canonicalType(self, itype, typespec, chmodallowed=0):
 36135:         loc = typespec.loc
 36135:         
 36135:         if itype.isIPDL():
 36135:             if itype.isProtocol():
 36135:                 itype = ActorType(itype,
 36135:                                   state=typespec.state,
 36135:                                   nullable=typespec.nullable)
 36153:             # FIXME/cjones: ShmemChmod is disabled until bug 524193
 36153:             if 0 and chmodallowed and itype.isShmem():
 36135:                 itype = ShmemChmodType(
 36135:                     itype,
 36135:                     myChmod=typespec.myChmod,
 36135:                     otherChmod=typespec.otherChmod)
 36135: 
 36135:         if ((typespec.myChmod or typespec.otherChmod)
 36135:             and not (itype.isIPDL() and (itype.isShmem() or itype.isChmod()))):
 36135:             self.error(
 36135:                 loc,
 36135:                 "fine-grained access controls make no sense for type `%s'",
 36135:                 itype.name())
 36135: 
 36135:         if not chmodallowed and (typespec.myChmod or typespec.otherChmod):
 36135:             self.error(loc, "fine-grained access controls not allowed here")
 36135: 
 36135:         if typespec.nullable and not (itype.isIPDL() and itype.isActor()):
 36135:             self.error(
 36135:                 loc,
 36135:                 "`nullable' qualifier for type `%s' makes no sense",
 36135:                 itype.name())
 36135: 
 36135:         if typespec.array:
 36135:             itype = ArrayType(itype)
 36135: 
 36135:         return itype
 36135: 
 36135: 
 35793: ##-----------------------------------------------------------------------------
 35763: 
 41429: def checkcycles(p, stack=None):
 41429:     cycles = []
 41429: 
 41429:     if stack is None:
 41429:         stack = []
 41429: 
 41429:     for cp in p.manages:
 41432:         # special case for self-managed protocols
 41432:         if cp is p:
 41432:             continue
 41432:         
 41429:         if cp in stack:
 41429:             return [stack + [p, cp]]
 41429:         cycles += checkcycles(cp, stack + [p])
 41429: 
 41429:     return cycles
 41429: 
 41429: def formatcycles(cycles):
 41429:     r = []
 41429:     for cycle in cycles:
 41429:         s = " -> ".join([ptype.name() for ptype in cycle])
 41429:         r.append("`%s'" % s)
 41429:     return ", ".join(r)
 41429: 
 42566: 
 42566: def fullyDefined(t, exploring=None):
 42566:     '''The rules for "full definition" of a type are
 42566:   defined(atom)             := true
 42566:   defined(array basetype)   := defined(basetype)
 42566:   defined(struct f1 f2...)  := defined(f1) and defined(f2) and ...
 42566:   defined(union c1 c2 ...)  := defined(c1) or defined(c2) or ...
 42566: '''
 42566:     if exploring is None:
 42566:         exploring = set()
 42566: 
 42566:     if t.isAtom():
 42566:         return True
 42566:     elif t.isArray():
 42566:         return fullyDefined(t.basetype, exploring)
 42566:     elif t.defined:
 42566:         return True
 42566:     assert t.isCompound()
 42566: 
 42566:     if t in exploring:
 42566:         return False
 42566: 
 42566:     exploring.add(t)
 42566:     for c in t.itercomponents():
 42566:         cdefined = fullyDefined(c, exploring)
 42566:         if t.isStruct() and not cdefined:
 42566:             t.defined = False
 42566:             break
 42566:         elif t.isUnion() and cdefined:
 42566:             t.defined = True
 42566:             break
 42566:     else:
 42566:         if t.isStruct():   t.defined = True
 42566:         elif t.isUnion():  t.defined = False
 42566:     exploring.remove(t)
 42566: 
 42566:     return t.defined
 42566: 
 42566: 
 35793: class CheckTypes(TcheckVisitor):
 35852:     def __init__(self, errors):
 35852:         # don't need the symbol table, we just want the error reporting
 35852:         TcheckVisitor.__init__(self, None, errors)
 35742:         self.visited = set()
 42560:         self.ptype = None
 35742: 
 35742:     def visitProtocolInclude(self, inc):
 35742:         if inc.tu.filename in self.visited:
 35742:             return
 35742:         self.visited.add(inc.tu.filename)
 35742:         inc.tu.protocol.accept(self)
 35742: 
 35742: 
 42566:     def visitStructDecl(self, sd):
 42566:         if not fullyDefined(sd.decl.type):
 42566:             self.error(sd.decl.loc,
 42566:                        "struct `%s' is only partially defined", sd.name)
 42566: 
 42566:     def visitUnionDecl(self, ud):
 42566:         if not fullyDefined(ud.decl.type):
 42566:             self.error(ud.decl.loc,
 42566:                        "union `%s' is only partially defined", ud.name)
 42566: 
 42566: 
 35742:     def visitProtocol(self, p):
 42560:         self.ptype = p.decl.type
 42560:         
 38096:         # check that we require no more "power" than our manager protocols
 35742:         ptype, pname = p.decl.type, p.decl.shortname
 42560: 
 42560:         if len(p.spawnsStmts) and not ptype.isToplevel():
 42560:             self.error(p.decl.loc,
 42560:                        "protocol `%s' is not top-level and so cannot declare |spawns|",
 42560:                        pname)
 42560: 
 42560:         if len(p.bridgesStmts) and not ptype.isToplevel():
 42560:             self.error(p.decl.loc,
 42560:                        "protocol `%s' is not top-level and so cannot declare |bridges|",
 42560:                        pname)
 42560: 
 71249:         if len(p.opensStmts) and not ptype.isToplevel():
 71249:             self.error(p.decl.loc,
 71249:                        "protocol `%s' is not top-level and so cannot declare |opens|",
 71249:                        pname)
 71249: 
 38096:         for mgrtype in ptype.managers:
 35742:             if mgrtype is not None and ptype.needsMoreJuiceThan(mgrtype):
 35793:                 self.error(
 35742:                     p.decl.loc,
 35742:                     "protocol `%s' requires more powerful send semantics than its manager `%s' provides",
 38096:                     pname, mgrtype.name())
 35742: 
 36138:         # XXX currently we don't require a delete() message of top-level
 36138:         # actors.  need to let experience guide this decision
 41368:         if not ptype.isToplevel():
 36138:             for md in p.messageDecls:
 36138:                 if _DELETE_MSG == md.name: break
 36138:             else:
 36138:                 self.error(
 36138:                     p.decl.loc,
 36138:                    "managed protocol `%s' requires a `delete()' message to be declared",
 36138:                     p.name)
 41429:         else:
 41429:             cycles = checkcycles(p.decl.type)
 41429:             if cycles:
 41429:                 self.error(
 41429:                     p.decl.loc,
 41429:                     "cycle(s) detected in manager/manages heirarchy: %s",
 41429:                     formatcycles(cycles))
 36138: 
 41368:         if 1 == len(ptype.managers) and ptype is ptype.manager():
 41368:             self.error(
 41368:                 p.decl.loc,
 41368:                 "top-level protocol `%s' cannot manage itself",
 41368:                 p.name)
 41368: 
 35742:         return Visitor.visitProtocol(self, p)
 35742: 
 35742: 
 42560:     def visitSpawnsStmt(self, spawns):
 42560:         if not self.ptype.isToplevel():
 42560:             self.error(spawns.loc,
 42560:                        "only top-level protocols can have |spawns| statements; `%s' cannot",
 42560:                        self.ptype.name())
 42560:             return
 42560: 
 42560:         spawnedType = spawns.proto.type
 42560:         if not (spawnedType.isIPDL() and spawnedType.isProtocol()
 42560:                 and spawnedType.isToplevel()):
 42560:             self.error(spawns.loc,
 42560:                        "cannot spawn non-top-level-protocol `%s'",
 42560:                        spawnedType.name())
 42560:         else:
 42560:             self.ptype.addSpawn(spawnedType)
 42560: 
 42560: 
 42560:     def visitBridgesStmt(self, bridges):
 42560:         if not self.ptype.isToplevel():
 42560:             self.error(bridges.loc,
 42560:                        "only top-level protocols can have |bridges| statements; `%s' cannot",
 42560:                        self.ptype.name())
 42560:             return
 42560: 
 42560:         parentType = bridges.parentSide.type
 42560:         childType = bridges.childSide.type
 42560:         if not (parentType.isIPDL() and parentType.isProtocol()
 42560:                 and childType.isIPDL() and childType.isProtocol()
 42560:                 and parentType.isToplevel() and childType.isToplevel()):
 42560:             self.error(bridges.loc,
 42560:                        "cannot bridge non-top-level-protocol(s) `%s' and `%s'",
 42560:                        parentType.name(), childType.name())
 42560: 
 42560: 
 71249:     def visitOpensStmt(self, opens):
 71249:         if not self.ptype.isToplevel():
 71249:             self.error(opens.loc,
 71249:                        "only top-level protocols can have |opens| statements; `%s' cannot",
 71249:                        self.ptype.name())
 71249:             return
 71249: 
 71249:         openedType = opens.proto.type
 71249:         if not (openedType.isIPDL() and openedType.isProtocol()
 71249:                 and openedType.isToplevel()):
 71249:             self.error(opens.loc,
 71249:                        "cannot open non-top-level-protocol `%s'",
 71249:                        openedType.name())
 71249:         else:
 71249:             self.ptype.addOpen(openedType)
 71249: 
 71249: 
 35742:     def visitManagesStmt(self, mgs):
 35742:         pdecl = mgs.manager.decl
 35742:         ptype, pname = pdecl.type, pdecl.shortname
 35742: 
 35742:         mgsdecl = mgs.decl
 35742:         mgstype, mgsname = mgsdecl.type, mgsdecl.shortname
 35742: 
 35742:         loc = mgs.loc
 35742: 
 35742:         # we added this information; sanity check it
 38096:         assert ptype.isManagerOf(mgstype)
 35742: 
 35742:         # check that the "managed" protocol agrees
 38096:         if not mgstype.isManagedBy(ptype):
 35793:             self.error(
 35742:                 loc,
 35742:                 "|manages| declaration in protocol `%s' does not match any |manager| declaration in protocol `%s'",
 35793:                 pname, mgsname)
 35742: 
 35742: 
 38096:     def visitManager(self, mgr):
 38096:         # FIXME/bug 541126: check that the protocol graph is acyclic
 38096:         
 35742:         pdecl = mgr.of.decl
 35742:         ptype, pname = pdecl.type, pdecl.shortname
 35742: 
 35742:         mgrdecl = mgr.decl
 35742:         mgrtype, mgrname = mgrdecl.type, mgrdecl.shortname
 35742: 
 35742:         # we added this information; sanity check it
 38096:         assert ptype.isManagedBy(mgrtype)
 35742: 
 35742:         loc = mgr.loc
 35742: 
 35742:         # check that the "manager" protocol agrees
 35744:         if not mgrtype.isManagerOf(ptype):
 35793:             self.error(
 35742:                 loc,
 35742:                 "|manager| declaration in protocol `%s' does not match any |manages| declaration in protocol `%s'",
 35793:                 pname, mgrname)
 35742: 
 35742: 
 35742:     def visitMessageDecl(self, md):
 35742:         mtype, mname = md.decl.type, md.decl.progname
 35742:         ptype, pname = md.protocolDecl.type, md.protocolDecl.shortname
 35742: 
 35742:         loc = md.decl.loc
 35742: 
 35871:         if mtype.isSync() and (mtype.isOut() or mtype.isInout()):
 35871:             self.error(
 35871:                 loc,
 35871:                 "sync parent-to-child messages are verboten (here, message `%s' in protocol `%s')",
 35871:                 mname, pname)
 35871: 
 35742:         if mtype.needsMoreJuiceThan(ptype):
 35793:             self.error(
 35742:                 loc,
 35742:                 "message `%s' requires more powerful send semantics than its protocol `%s' provides",
 35793:                 mname, pname)
 35742: 
 35742:         if mtype.isAsync() and len(mtype.returns):
 35742:             # XXX/cjones could modify grammar to disallow this ...
 35793:             self.error(loc,
 35793:                        "asynchronous message `%s' declares return values",
 35793:                        mname)
 35742: 
 36138:         if mtype.isCtor() and not ptype.isManagerOf(mtype.constructedType()):
 35793:             self.error(
 35742:                 loc,
 36138:                 "ctor for protocol `%s', which is not managed by protocol `%s'", 
 35793:                 mname[:-len('constructor')], pname)
 35763: 
 35763: 
 35763:     def visitTransition(self, t):
 35763:         _YNC = [ ASYNC, SYNC ]
 35763: 
 35763:         loc = t.loc
 35763:         impliedDirection, impliedSems = {
 35763:             SEND: [ OUT, _YNC ], RECV: [ IN, _YNC ],
 36138:             CALL: [ OUT, RPC ],  ANSWER: [ IN, RPC ],
 35763:          } [t.trigger]
 35763:         
 35763:         if (OUT is impliedDirection and t.msg.type.isIn()
 35763:             or IN is impliedDirection and t.msg.type.isOut()
 35763:             or _YNC is impliedSems and t.msg.type.isRpc()
 35763:             or RPC is impliedSems and (not t.msg.type.isRpc())):
 35763:             mtype = t.msg.type
 35763: 
 35793:             self.error(
 35763:                 loc, "%s %s message `%s' is not `%s'd",
 35763:                 mtype.sendSemantics.pretty, mtype.direction.pretty,
 35763:                 t.msg.progname,
 35793:                 t.trigger.pretty)
 35793: 
 35793: ##-----------------------------------------------------------------------------
 35793: 
 42560: class Process:
 42560:     def __init__(self):
 42560:         self.actors = set()         # set(Actor)
 42560:         self.edges = { }            # Actor -> [ SpawnsEdge ]
 42560:         self.spawn = set()          # set(Actor)
 35868: 
 42560:     def edge(self, spawner, spawn):
 42560:         if spawner not in self.edges:  self.edges[spawner] = [ ]
 42560:         self.edges[spawner].append(SpawnsEdge(spawner, spawn))
 42560:         self.spawn.add(spawn)
 35868: 
 42560:     def iteredges(self):
 42560:         for edgelist in self.edges.itervalues():
 42560:             for edge in edgelist:
 42560:                 yield edge
 42560: 
 42560:     def merge(self, o):
 42560:         'Merge the Process |o| into this Process'
 42560:         if self == o:
 42560:             return
 42560:         for actor in o.actors:
 42560:             ProcessGraph.actorToProcess[actor] = self
 42560:         self.actors.update(o.actors)
 42560:         self.edges.update(o.edges)
 42560:         self.spawn.update(o.spawn)
 42560:         ProcessGraph.processes.remove(o)
 42560: 
 42560:     def spawns(self, actor):
 42560:         return actor in self.spawn
 42560: 
 42560:     def __cmp__(self, o):  return cmp(self.actors, o.actors)
 42560:     def __eq__(self, o):   return self.actors == o.actors
 42560:     def __hash__(self):    return hash(id(self))
 42560:     def __repr__(self):
 42560:         return reduce(lambda a, x: str(a) + str(x) +'|', self.actors, '|')
 42560:     def __str__(self):     return repr(self)
 42560: 
 42560: class Actor:
 42560:     def __init__(self, ptype, side):
 42560:         self.ptype = ptype
 42560:         self.side = side
 42560: 
 71238:     def asType(self):
 71238:         return ActorType(self.ptype)
 42560:     def other(self):
 42560:         return Actor(self.ptype, _otherside(self.side))
 42560: 
 42560:     def __cmp__(self, o):
 42560:         return cmp(self.ptype, o.ptype) or cmp(self.side, o.side)
 42560:     def __eq__(self, o):
 42560:         return self.ptype == o.ptype and self.side == o.side
 42560:     def __hash__(self):  return hash(repr(self))
 42560:     def __repr__(self):  return '%s%s'% (self.ptype.name(), self.side.title())
 42560:     def __str__(self):   return repr(self)
 42560: 
 42560: class SpawnsEdge:
 42560:     def __init__(self, spawner, spawn):
 42560:         self.spawner = spawner      # Actor
 42560:         self.spawn = spawn          # Actor
 42560:     def __repr__(self):
 42560:         return '(%r)--spawns-->(%r)'% (self.spawner, self.spawn)
 42560:     def __str__(self):  return repr(self)
 42560: 
 42560: class BridgeEdge:
 42560:     def __init__(self, bridgeProto, parent, child):
 42560:         self.bridgeProto = bridgeProto # ProtocolType
 42560:         self.parent = parent           # Actor
 42560:         self.child = child             # Actor
 42560:     def __repr__(self):
 42560:         return '(%r)--%s bridge-->(%r)'% (
 42560:             self.parent, self.bridgeProto.name(), self.child)
 42560:     def __str__(self):  return repr(self)
 42560: 
 71249: class OpensEdge:
 71249:     def __init__(self, opener, openedProto):
 71249:         self.opener = opener            # Actor
 71249:         self.openedProto = openedProto  # ProtocolType
 71249:     def __repr__(self):
 71249:         return '(%r)--opens-->(%s)'% (self.opener, self.openedProto.name())
 71249:     def __str__(self):  return repr(self)
 71249: 
 42560: # "singleton" class with state that persists across type checking of
 42560: # all protocols
 42560: class ProcessGraph:
 42560:     processes = set()                   # set(Process)
 71238:     bridges = { }                       # ProtocolType -> [ BridgeEdge ]
 71249:     opens = { }                         # ProtocolType -> [ OpensEdge ]
 42560:     actorToProcess = { }                # Actor -> Process
 42560:     visitedSpawns = set()               # set(ActorType)
 42560:     visitedBridges = set()              # set(ActorType)
 42560: 
 42560:     @classmethod
 42560:     def findProcess(cls, actor):
 42560:         return cls.actorToProcess.get(actor, None)
 42560: 
 42560:     @classmethod
 42560:     def getProcess(cls, actor):
 42560:         if actor not in cls.actorToProcess:
 42560:             p = Process()
 42560:             p.actors.add(actor)
 42560:             cls.processes.add(p)
 42560:             cls.actorToProcess[actor] = p
 42560:         return cls.actorToProcess[actor]
 42560: 
 42560:     @classmethod
 71238:     def bridgesOf(cls, bridgeP):
 71238:         return cls.bridges.get(bridgeP, [])
 71238: 
 71238:     @classmethod
 71238:     def bridgeEndpointsOf(cls, ptype, side):
 71238:         actor = Actor(ptype, side)
 71238:         endpoints = []
 71238:         for b in cls.iterbridges():
 71238:             if b.parent == actor:
 71238:                 endpoints.append(Actor(b.bridgeProto, 'parent'))
 71238:             elif b.child == actor:
 71238:                 endpoints.append(Actor(b.bridgeProto, 'child'))
 71238:         return endpoints
 71238: 
 71238:     @classmethod
 71238:     def iterbridges(cls):
 71238:         for edges in cls.bridges.itervalues():
 71238:             for bridge in edges:
 71238:                 yield bridge
 71238: 
 71238:     @classmethod
 71249:     def opensOf(cls, openedP):
 71249:         return cls.opens.get(openedP, [])
 71249: 
 71249:     @classmethod
 71249:     def opensEndpointsOf(cls, ptype, side):
 71249:         actor = Actor(ptype, side)
 71249:         endpoints = []
 71249:         for o in cls.iteropens():
 71249:             if actor == o.opener:
 71249:                 endpoints.append(Actor(o.openedProto, o.opener.side))
 71249:             elif actor == o.opener.other():
 71249:                 endpoints.append(Actor(o.openedProto, o.opener.other().side))
 71249:         return endpoints
 71249: 
 71249:     @classmethod
 71249:     def iteropens(cls):
 71249:         for edges in cls.opens.itervalues():
 71249:             for opens in edges:
 71249:                 yield opens
 71249: 
 71249:     @classmethod
 42560:     def spawn(cls, spawner, remoteSpawn):
 42560:         localSpawn = remoteSpawn.other()
 42560:         spawnerProcess = ProcessGraph.getProcess(spawner)
 42560:         spawnerProcess.merge(ProcessGraph.getProcess(localSpawn))
 42560:         spawnerProcess.edge(spawner, remoteSpawn)
 42560: 
 42560:     @classmethod
 42560:     def bridge(cls, parent, child, bridgeP):
 71249:         bridgeParent = Actor(bridgeP, 'parent')
 71249:         parentProcess = ProcessGraph.getProcess(parent)
 71249:         parentProcess.merge(ProcessGraph.getProcess(bridgeParent))
 71249:         bridgeChild = Actor(bridgeP, 'child')
 71249:         childProcess = ProcessGraph.getProcess(child)
 71249:         childProcess.merge(ProcessGraph.getProcess(bridgeChild))
 71238:         if bridgeP not in cls.bridges:
 71238:             cls.bridges[bridgeP] = [ ]
 71238:         cls.bridges[bridgeP].append(BridgeEdge(bridgeP, parent, child))
 42560: 
 71249:     @classmethod
 71249:     def open(cls, opener, opened, openedP):
 71249:         remoteOpener, remoteOpened, = opener.other(), opened.other()
 71249:         openerProcess = ProcessGraph.getProcess(opener)
 71249:         openerProcess.merge(ProcessGraph.getProcess(opened))
 71249:         remoteOpenerProcess = ProcessGraph.getProcess(remoteOpener)
 71249:         remoteOpenerProcess.merge(ProcessGraph.getProcess(remoteOpened))
 71249:         if openedP not in cls.opens:
 71249:             cls.opens[openedP] = [ ]
 71249:         cls.opens[openedP].append(OpensEdge(opener, openedP))
 71249: 
 42560: 
 42560: class BuildProcessGraph(TcheckVisitor):
 42560:     class findSpawns(TcheckVisitor):
 42560:         def __init__(self, errors):
 42560:             TcheckVisitor.__init__(self, None, errors)
 42560: 
 42560:         def visitTranslationUnit(self, tu):
 42560:             TcheckVisitor.visitTranslationUnit(self, tu)
 42560: 
 42560:         def visitProtocolInclude(self, pi):
 42560:             pi.tu.protocol.accept(self)
 42560: 
 42560:         def visitProtocol(self, p):
 42560:             ptype = p.decl.type
 42560:             # non-top-level protocols don't add any information
 42560:             if not ptype.isToplevel() or ptype in ProcessGraph.visitedSpawns:
 42560:                 return
 42560: 
 42560:             ProcessGraph.visitedSpawns.add(ptype)
 42560:             self.visiting = ptype
 42560:             ProcessGraph.getProcess(Actor(ptype, 'parent'))
 42560:             ProcessGraph.getProcess(Actor(ptype, 'child'))
 42560:             return TcheckVisitor.visitProtocol(self, p)
 42560: 
 42560:         def visitSpawnsStmt(self, spawns):
 42560:             # The picture here is:
 42560:             #  [ spawner | localSpawn | ??? ]  (process 1)
 42560:             #                  |
 42560:             #                  |
 42560:             #            [ remoteSpawn | ???]  (process 2)
 42560:             #
 42560:             # A spawns stmt tells us that |spawner| and |localSpawn|
 42560:             # are in the same process.
 42560:             spawner = Actor(self.visiting, spawns.side)
 42560:             remoteSpawn = Actor(spawns.proto.type, spawns.spawnedAs)
 42560:             ProcessGraph.spawn(spawner, remoteSpawn)
 42560: 
 42560:     def __init__(self, errors):
 42560:         TcheckVisitor.__init__(self, None, errors)
 42560:         self.visiting = None            # ActorType
 42560:         self.visited = set()            # set(ActorType)
 42560: 
 42560:     def visitTranslationUnit(self, tu):
 42560:         tu.accept(self.findSpawns(self.errors))
 42560:         TcheckVisitor.visitTranslationUnit(self, tu)
 42560: 
 42560:     def visitProtocolInclude(self, pi):
 42560:         pi.tu.protocol.accept(self)
 42560: 
 42560:     def visitProtocol(self, p):
 42560:         ptype = p.decl.type
 42560:         # non-top-level protocols don't add any information
 42560:         if not ptype.isToplevel() or ptype in ProcessGraph.visitedBridges:
 42560:             return
 42560: 
 42560:         ProcessGraph.visitedBridges.add(ptype)
 42560:         self.visiting = ptype
 42560:         return TcheckVisitor.visitProtocol(self, p)
 42560: 
 42560:     def visitBridgesStmt(self, bridges):
 42560:         bridgeProto = self.visiting
 42560:         parentSideProto = bridges.parentSide.type
 42560:         childSideProto = bridges.childSide.type
 42560: 
 42560:         # the picture here is:
 42560:         #                                                   (process 1|
 42560:         #  [ parentSide(Parent|Child) | childSide(Parent|Child) | ... ]
 42560:         #         |                                       |
 42560:         #         |                        (process 2|    |
 42560:         #  [ parentSide(Child|Parent) | bridgeParent ]    |
 42560:         #                                   |             |
 42560:         #                                   |             |       (process 3|
 42560:         #                           [ bridgeChild | childSide(Child|Parent) ]
 42560:         #
 42560:         # First we have to figure out which parentSide/childSide
 42560:         # actors live in the same process.  The possibilities are {
 42560:         # parent, child } x { parent, child }.  (Multiple matches
 42560:         # aren't allowed yet.)  Then we make ProcessGraph aware of the
 42560:         # new bridge.
 42560:         parentSideActor, childSideActor = None, None
 42560:         pc = ( 'parent', 'child' )
 42560:         for parentSide, childSide in cartesian_product(pc, pc):
 42560:             pactor = Actor(parentSideProto, parentSide)
 42560:             pproc = ProcessGraph.findProcess(pactor)
 42560:             cactor = Actor(childSideProto, childSide)
 42560:             cproc = ProcessGraph.findProcess(cactor)
 42560:             assert pproc and cproc
 42560: 
 42560:             if pproc == cproc:
 42560:                 if parentSideActor is not None:
 42560:                     self.error(bridges.loc,
 42560:                                "ambiguous bridge `%s' between `%s' and `%s'",
 42560:                                bridgeProto.type.name(),
 42560:                                parentSideProto.name(),
 42560:                                childSideProto.name())
 42560:                 else:
 42560:                     parentSideActor, childSideActor = pactor.other(), cactor.other()
 42560: 
 42560:         if parentSideActor is None:
 42560:             self.error(bridges.loc,
 42560:                        "`%s' and `%s' cannot be bridged by `%s' ",
 42560:                        parentSideProto.name(), childSideProto.name(),
 42560:                        bridgeProto.name())
 42560: 
 42560:         ProcessGraph.bridge(parentSideActor, childSideActor, bridgeProto)
 42560: 
 71249:     def visitOpensStmt(self, opens):
 71249:         openedP = opens.proto.type
 71249:         opener = Actor(self.visiting, opens.side)
 71249:         opened = Actor(openedP, opens.side)
 71249: 
 71249:         # The picture here is:
 71249:         #  [ opener       | opened ]   (process 1)
 71249:         #      |               |
 71249:         #      |               |
 71249:         #  [ remoteOpener | remoteOpened ]  (process 2)
 71249:         #
 71249:         # An opens stmt tells us that the pairs |opener|/|opened|
 71249:         # and |remoteOpener|/|remoteOpened| are each in the same
 71249:         # process.
 71249:         ProcessGraph.open(opener, opened, openedP)
 71249: 
 42560: 
 42560: class CheckProcessGraph(TcheckVisitor):
 42560:     def __init__(self, errors):
 42560:         TcheckVisitor.__init__(self, None, errors)
 42560: 
 42560:     # TODO: verify spawns-per-process assumption and check that graph
 42560:     # is a dag
 42560:     def visitTranslationUnit(self, tu):
 42560:         if 0:
 42560:             print 'Processes'
 42560:             for process in ProcessGraph.processes:
 42560:                 print '  ', process
 42560:                 for edge in process.iteredges():
 42560:                     print '    ', edge
 42560:             print 'Bridges'
 71238:             for bridgeList in ProcessGraph.bridges.itervalues():
 71238:                 for bridge in bridgeList:
 42560:                     print '  ', bridge
 71249:             print 'Opens'
 71249:             for opensList in ProcessGraph.opens.itervalues():
 71249:                 for opens in opensList:
 71249:                     print '  ', opens
 42560: 
 42560: ##-----------------------------------------------------------------------------
 35868: 
 35793: class CheckStateMachine(TcheckVisitor):
 35852:     def __init__(self, errors):
 35852:         # don't need the symbol table, we just want the error reporting
 35852:         TcheckVisitor.__init__(self, None, errors)
 35796:         self.p = None
 35793: 
 35793:     def visitProtocol(self, p):
 35796:         self.p = p
 35793:         self.checkReachability(p)
 35796:         for ts in p.transitionStmts:
 35796:             ts.accept(self)
 35793: 
 35796:     def visitTransitionStmt(self, ts):
 35796:         # We want to disallow "race conditions" in protocols.  These
 35928:         # can occur when a protocol state machine has a state that
 35928:         # allows triggers of opposite direction.  That declaration
 35928:         # allows the parent to send the child a message at the
 35928:         # exact instance the child sends the parent a message.  One of
 35928:         # those messages would (probably) violate the state machine
 35928:         # and cause the child to be terminated.  It's obviously very
 35928:         # nice if we can forbid this at the level of IPDL state
 35928:         # machines, rather than resorting to static or dynamic
 35928:         # checking of C++ implementation code.
 35796:         #
 35796:         # An easy way to avoid this problem in IPDL is to only allow
 35796:         # "unidirectional" protocol states; that is, from each state,
 35796:         # only send or only recv triggers are allowed.  This approach
 35796:         # is taken by the Singularity project's "contract-based
 35928:         # message channels."  However, this can be something of a
 35928:         # notational burden for stateful protocols.
 35796:         #
 35928:         # If two messages race, the effect is that the parent's and
 35928:         # child's states get temporarily out of sync.  Informally,
 35928:         # IPDL allows this *only if* the state machines get out of
 35928:         # sync for only *one* step (state machine transition), then
 35928:         # sync back up.  This is a design decision: the states could
 35928:         # be allowd to get out of sync for any constant k number of
 35928:         # steps.  (If k is unbounded, there's no point in presenting
 35928:         # the abstraction of parent and child actor states being
 35928:         # "entangled".)  The working hypothesis is that the more steps
 35928:         # the states are allowed to be out of sync, the harder it is
 35928:         # to reason about the protocol.
 35928:         #
 35928:         # Slightly less informally, two messages are allowed to race
 35928:         # only if processing them in either order leaves the protocol
 35928:         # in the same state.  That is, messages A and B are allowed to
 35928:         # race only if processing A then B leaves the protocol in
 35928:         # state S, *and* processing B then A also leaves the protocol
 35928:         # in state S.  Technically, if this holds, then messages A and
 36172:         # B could be called "commutative" wrt to actor state.
 35928:         #
 35928:         # "Formally", state machine definitions must adhere to two
 35928:         # rules.
 35796:         #
 35796:         #   *Rule 1*: from a state S, all sync triggers must be of the same
 35796:         # "direction," i.e. only |send| or only |recv|
 35796:         #
 35796:         # (Pairs of sync messages can't commute, because otherwise
 35796:         # deadlock can occur from simultaneously in-flight sync
 35796:         # requests.)
 35796:         #
 35796:         #   *Rule 2*: the "Diamond Rule".
 35796:         #   from a state S,
 35796:         #     for any pair of triggers t1 and t2,
 35796:         #         where t1 and t2 have opposite direction,
 35796:         #         and t1 transitions to state T1 and t2 to T2,
 35796:         #       then the following must be true:
 35928:         #         (T2 allows the trigger t1, transitioning to state U)
 35928:         #         and
 35928:         #         (T1 allows the trigger t2, transitioning to state U)
 35928:         #         and
 35928:         #         (
 35928:         #           (
 35928:         #             (all of T1's triggers have the same direction as t2)
 35928:         #             and
 35928:         #             (all of T2's triggers have the same direction as t1)
 35928:         #           )
 35928:         #           or
 35928:         #           (T1, T2, and U are the same "terminal state")
 35928:         #         )
 35796:         #
 35928:         # A "terminal state" S is one from which all triggers
 35928:         # transition back to S itself.
 35868:         #
 35868:         # The presence of triggers with multiple out states complicates
 35868:         # this check slightly, but doesn't fundamentally change it.
 35868:         #
 35868:         #   from a state S,
 35868:         #     for any pair of triggers t1 and t2,
 35868:         #         where t1 and t2 have opposite direction,
 35868:         #       for each pair of states (T1, T2) \in t1_out x t2_out,
 35868:         #           where t1_out is the set of outstates from t1
 35868:         #                 t2_out is the set of outstates from t2
 35868:         #                 t1_out x t2_out is their Cartesian product
 35868:         #                 and t1 transitions to state T1 and t2 to T2,
 35868:         #         then the following must be true:
 35928:         #           (T2 allows the trigger t1, with out-state set { U })
 35928:         #           and
 35928:         #           (T1 allows the trigger t2, with out-state set { U })
 35928:         #           and
 35928:         #           (
 35928:         #             (
 35928:         #               (all of T1's triggers have the same direction as t2)
 35928:         #               and
 35928:         #               (all of T2's triggers have the same direction as t1)
 35928:         #             )
 35928:         #             or
 35928:         #             (T1, T2, and U are the same "terminal state")
 35928:         #           )
 35928: 
 35928:         # check Rule 1
 35796:         syncdirection = None
 35796:         syncok = True
 35796:         for trans in ts.transitions:
 35796:             if not trans.msg.type.isSync(): continue
 35796:             if syncdirection is None:
 35796:                 syncdirection = trans.trigger.direction()
 35796:             elif syncdirection is not trans.trigger.direction():
 35796:                 self.error(
 35796:                     trans.loc,
 35796:                     "sync trigger at state `%s' in protocol `%s' has different direction from earlier sync trigger at same state",
 35796:                     ts.state.name, self.p.name)
 35796:                 syncok = False
 35796:         # don't check the Diamond Rule if Rule 1 doesn't hold
 35796:         if not syncok:
 35796:             return
 35796: 
 35928:         # helper functions
 35868:         def triggerTargets(S, t):
 35868:             '''Return the set of states transitioned to from state |S|
 35868: upon trigger |t|, or { } if |t| is not a trigger in |S|.'''
 35796:             for trans in self.p.states[S].transitions:
 35796:                 if t.trigger is trans.trigger and t.msg is trans.msg:
 35868:                     return trans.toStates
 35868:             return set()
 35796: 
 35928:         def allTriggersSameDirectionAs(S, t):
 35928:             '''Return true iff all the triggers from state |S| have the same
 35928: direction as trigger |t|'''
 35928:             direction = t.direction()
 35928:             for trans in self.p.states[S].transitions:
 35928:                 if direction != trans.trigger.direction():
 35928:                     return False
 35928:             return True
 35868: 
 35928:         def terminalState(S):
 35928:             '''Return true iff |S| is a "terminal state".'''
 35928:             for trans in self.p.states[S].transitions:
 35928:                 for S_ in trans.toStates:
 35928:                     if S_ != S:  return False
 35928:             return True
 35928: 
 35928:         def sameTerminalState(S1, S2, S3):
 35928:             '''Return true iff states |S1|, |S2|, and |S3| are all the same
 35928: "terminal state".'''
 35928:             if isinstance(S3, set):
 35928:                 assert len(S3) == 1
 35928:                 for S3_ in S3: pass
 35928:                 S3 = S3_
 35928: 
 35928:             return (S1 == S2 == S3) and terminalState(S1)
 35928: 
 36172:         S = ts.state.name
 35928: 
 35928:         # check the Diamond Rule
 35868:         for (t1, t2) in unique_pairs(ts.transitions):
 35796:             # if the triggers have the same direction, they can't race,
 35796:             # since only one endpoint can initiate either (and delivery
 35796:             # is in-order)
 35796:             if t1.trigger.direction() == t2.trigger.direction():
 35796:                 continue
 35796: 
 36172:             loc = t1.loc
 35868:             t1_out = t1.toStates
 35868:             t2_out = t2.toStates
 35796: 
 35871:             for (T1, T2) in cartesian_product(t1_out, t2_out):
 36172:                 # U1 <- { u | T1 --t2--> u }
 35868:                 U1 = triggerTargets(T1, t2)
 36172:                 # U2 <- { u | T2 --t1--> u }
 35868:                 U2 = triggerTargets(T2, t1)
 35796: 
 36172:                 # don't report more than one Diamond Rule violation
 36172:                 # per state. there may be O(n^4) total, way too many
 36172:                 # for a human to parse
 36172:                 #
 36172:                 # XXX/cjones: could set a limit on #printed and stop
 36172:                 # after that limit ...
 36172:                 raceError = False
 36172:                 errT1 = None
 36172:                 errT2 = None
 36172: 
 36172:                 if 0 == len(U1) or 0 == len(U2):
 36172:                     print "******* case 1"
 36172:                     raceError = True
 36172:                 elif 1 < len(U1) or 1 < len(U2):
 36172:                     raceError = True
 36172:                     # there are potentially many unpaired states; just
 36172:                     # pick two
 36172:                     print "******* case 2"
 36172:                     for u1, u2 in cartesian_product(U1, U2):
 36172:                         if u1 != u2:
 36172:                             errT1, errT2 = u1, u2
 36172:                             break
 36172:                 elif U1 != U2:
 36172:                     print "******* case 3"
 36172:                     raceError = True
 36172:                     for errT1 in U1: pass
 36172:                     for errT2 in U2: pass
 36172: 
 36172:                 if raceError:
 36172:                     self.reportRaceError(loc, S,
 36172:                                          [ T1, t1, errT1 ],
 36172:                                          [ T2, t2, errT2 ])
 36172:                     return
 36172: 
 36172:                 if not ((allTriggersSameDirectionAs(T1, t2.trigger)
 35928:                            and allTriggersSameDirectionAs(T2, t1.trigger))
 36172:                           or sameTerminalState(T1, T2, U1)):
 36172:                     self.reportRunawayError(loc, S, [ T1, t1, None ], [ T2, t2, None ])
 35796:                     return
 35793: 
 35793:     def checkReachability(self, p):
 36138:         def explore(ts, visited):
 35793:             if ts.state in visited:
 35793:                 return
 35793:             visited.add(ts.state)
 35793:             for outedge in ts.transitions:
 35868:                 for toState in outedge.toStates:
 36138:                     explore(p.states[toState], visited)
 35793: 
 36138:         checkfordelete = (State.DEAD in p.states)
 36138: 
 36138:         allvisited = set()         # set(State)
 35867:         for root in p.startStates:
 36138:             visited = set()
 36138: 
 36138:             explore(root, visited)
 36138:             allvisited.update(visited)
 36138: 
 36138:             if checkfordelete and State.DEAD not in visited:
 36138:                 self.error(
 36138:                     root.loc,
 36138:                     "when starting from state `%s', actors of protocol `%s' cannot be deleted", root.state.name, p.name)
 36138: 
 36138:         for ts in p.states.itervalues():
 36138:             if ts.state is not State.DEAD and ts.state not in allvisited:
 36138:                 self.error(ts.loc,
 36138:                            "unreachable state `%s' in protocol `%s'",
 35793:                            ts.state.name, p.name)
 36172: 
 36172: 
 36172:     def _normalizeTransitionSequences(self, t1Seq, t2Seq):
 36172:         T1, M1, U1 = t1Seq
 36172:         T2, M2, U2 = t2Seq
 36172:         assert M1 is not None and M2 is not None
 36172: 
 36172:         # make sure that T1/M1/U1 is the parent side of the race
 36172:         if M1.trigger is RECV or M1.trigger is ANSWER:
 36172:             T1, M1, U1, T2, M2, U2 = T2, M2, U2, T1, M1, U1
 36172: 
 36172:         def stateName(S):
 36172:             if S: return S.name
 36172:             return '[error]'
 36172: 
 36172:         T1 = stateName(T1)
 36172:         T2 = stateName(T2)
 36172:         U1 = stateName(U1)
 36172:         U2 = stateName(U2)
 36172: 
 36172:         return T1, M1.msg.progname, U1, T2, M2.msg.progname, U2
 36172:         
 36172: 
 36172:     def reportRaceError(self, loc, S, t1Seq, t2Seq):
 36172:         T1, M1, U1, T2, M2, U2 = self._normalizeTransitionSequences(t1Seq, t2Seq)
 36172:         self.error(
 36172:             loc,
 36172: """in protocol `%(P)s', the sequence of events
 36172:      parent:    +--`send %(M1)s'-->( state `%(T1)s' )--`recv %(M2)s'-->( state %(U1)s )
 36172:                /
 36172:  ( state `%(S)s' )
 36172:                \\
 36172:       child:    +--`send %(M2)s'-->( state `%(T2)s' )--`recv %(M1)s'-->( state %(U2)s )
 36172: results in error(s) or leaves parent/child state out of sync for more than one step and is thus a race hazard; i.e., triggers `%(M1)s' and `%(M2)s' fail to commute in state `%(S)s'"""% {
 36172:                 'P': self.p.name, 'S': S, 'M1': M1, 'M2': M2,
 36172:                 'T1': T1, 'T2': T2, 'U1': U1, 'U2': U2
 36172:         })
 36172: 
 36172: 
 36172:     def reportRunawayError(self, loc, S, t1Seq, t2Seq):
 36172:         T1, M1, _, T2, M2, __ = self._normalizeTransitionSequences(t1Seq, t2Seq)
 36172:         self.error(
 36172:             loc,
 36172:         """in protocol `%(P)s', the sequence of events
 36172:      parent:    +--`send %(M1)s'-->( state `%(T1)s' )
 36172:                /
 36172:  ( state `%(S)s' )
 36172:                \\
 36172:       child:    +--`send %(M2)s'-->( state `%(T2)s' )
 36172: lead to parent/child states in which parent/child state can become more than one step out of sync (though this divergence might not lead to error conditions)"""% {
 36172:                 'P': self.p.name, 'S': S, 'M1': M1, 'M2': M2, 'T1': T1, 'T2': T2
 36172:         })
