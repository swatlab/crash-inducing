    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsDeque.h"
    1: #include "nsCRT.h"
    1: #include <stdio.h>
    1: 
    1: /**************************************************************
    1:   Now define the token deallocator class...
    1:  **************************************************************/
    1: class _TestDeque {
    1: public:
87648:   _TestDeque() {
87648:     SelfTest();
87648:   }
87648:   int SelfTest();
87648:   nsresult OriginalTest();
87648:   nsresult OriginalFlaw();
87648:   nsresult AssignFlaw();
    1: };
    1: static _TestDeque sTestDeque;
    1: 
    1: class _Dealloc: public nsDequeFunctor {
    1:   virtual void* operator()(void* aObject) {
    1:     return 0;
    1:   }
    1: };
    1: 
    1: /**
    1:  * conduct automated self test for this class
    1:  *
    1:  * @param
    1:  * @return
    1:  */
87648: int _TestDeque::SelfTest() {
    1:   /* the old deque should have failed a bunch of these tests */
    1:   int results=0;
    1:   results+=OriginalTest();
    1:   results+=OriginalFlaw();
    1:   results+=AssignFlaw();
    1:   return results;
    1: }
    1: 
87648: nsresult _TestDeque::OriginalTest() {
87648:   int ints[200];
87648:   int count=sizeof(ints)/sizeof(int);
    1:   int i=0;
87648:   int* temp;
    1:   nsDeque theDeque(new _Dealloc); //construct a simple one...
    1:  
87648:   for (i=0;i<count;i++) { //initialize'em
87648:     ints[i]=10*(1+i);
    1:   }
    1:   for (i=0;i<70;i++) {
    1:     theDeque.Push(&ints[i]);
    1:   }
87648:   for (i=0;i<56;i++) {
87648:     temp=(int*)theDeque.Pop();
    1:   }
    1:   for (i=0;i<55;i++) {
    1:     theDeque.Push(&ints[i]);
    1:   }
87648:   for (i=0;i<35;i++) {
87648:     temp=(int*)theDeque.Pop();
    1:   }
    1:   for (i=0;i<35;i++) {
    1:     theDeque.Push(&ints[i]);
87648:   }
87648:   for (i=0;i<38;i++) {
87648:     temp=(int*)theDeque.Pop();
87648:   }
87648:   return NS_OK;
    1: }
    1: 
87648: nsresult _TestDeque::OriginalFlaw() {
    1:   int ints[200];
    1:   int i=0;
87648:   int* temp;
87648:   nsDeque secondDeque(new _Dealloc);
    1:   /**
    1:    * Test 1. Origin near end, semi full, call Peek().
    1:    * you start, mCapacity is 8
    1:    */
    1:   printf("fill array\n");
87648:   for (i=32; i; --i)
87648:     ints[i]=i*3+10;
87648:   printf("push 6 times\n");
87648:   for (i=0; i<6; i++)
87648:     secondDeque.Push(&ints[i]);
87648:   printf("popfront 4 times:\n");
87648:   for (i=4; i; --i) {
87648:     temp=(int*)secondDeque.PopFront();
87648:     printf("%d\t",*temp);
87648:   }
87648:   printf("push 4 times\n");
87648:   for (int j=4; j; --j)
87648:     secondDeque.Push(&ints[++i]);
87648:   printf("origin should now be about 4\n");
87648:   printf("and size should be 6\n");
87648:   printf("origin+size>capacity\n");
87633: 
87648:    /*<akk> Oh, I see ... it's a circular buffer */
87648:   printf("but the old code wasn't behaving accordingly.\n");
    1: 
87648:    /*right*/
87648:   printf("we shouldn't crash or anything interesting, ");
    1: 
87648:   temp=(int*)secondDeque.Peek();
87648:   printf("peek: %d\n",*temp);
87648:   return NS_OK;
    1: }
    1: 
87648: nsresult _TestDeque::AssignFlaw() {
    1:   nsDeque src(new _Dealloc),dest(new _Dealloc);
87648:   return NS_OK;
    1: }
    1: 
    1: int main (void) {
    1:   _TestDeque test;
    1:   return 0;
    1: }
