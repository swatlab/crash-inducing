29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
18084:  * vim: set ts=8 sw=4 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS parser.
    1:  *
    1:  * This is a recursive-descent parser for the JavaScript language specified by
    1:  * "The JavaScript 1.5 Language Specification".  It uses lexical and semantic
    1:  * feedback to disambiguate non-LL(1) structures.  It generates trees of nodes
    1:  * induced by the recursive parsing (not precise syntax trees, see jsparse.h).
    1:  * After tree construction, it rewrites trees to fold constants and evaluate
    1:  * compile-time expressions.  Finally, it calls js_EmitTree (see jsemit.h) to
    1:  * generate bytecode.
    1:  *
    1:  * This parser attempts no error recovery.
    1:  */
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include <math.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
55477: #include "jsarena.h"
55477: #include "jsutil.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsemit.h"
    1: #include "jsfun.h"
68933: #include "jsgc.h"
68933: #include "jsgcmark.h"
    1: #include "jsinterp.h"
15613: #include "jsiter.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
    1: #include "jsparse.h"
    1: #include "jsscan.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
    1: #include "jsstr.h"
18989: #include "jsstaticcheck.h"
30268: #include "jslibmath.h"
31925: #include "jsvector.h"
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: #include "jsxml.h"
    1: #endif
    1: 
    1: #if JS_HAS_DESTRUCTURING
    1: #include "jsdhash.h"
    1: #endif
    1: 
48470: #include "jsatominlines.h"
52802: #include "jsobjinlines.h"
50491: #include "jsregexpinlines.h"
59968: #include "jsscriptinlines.h"
50491: 
50491: // Grr, windows.h or something under it #defines CONST...
50491: #ifdef CONST
50491: #undef CONST
50491: #endif
48470: 
40221: using namespace js;
54707: using namespace js::gc;
40221: 
    1: /*
10466:  * Asserts to verify assumptions behind pn_ macros.
10466:  */
27012: #define pn_offsetof(m)  offsetof(JSParseNode, m)
27012: 
27012: JS_STATIC_ASSERT(pn_offsetof(pn_link) == pn_offsetof(dn_uses));
27012: JS_STATIC_ASSERT(pn_offsetof(pn_u.name.atom) == pn_offsetof(pn_u.apair.atom));
27012: 
27012: #undef pn_offsetof
10466: 
10466: /*
    1:  * Insist that the next token be of type tt, or report errno and return null.
    1:  * NB: this macro uses cx and ts from its lexical environment.
    1:  */
40854: #define MUST_MATCH_TOKEN_WITH_FLAGS(tt, errno, __flags)                                     \
    1:     JS_BEGIN_MACRO                                                                          \
40854:         if (tokenStream.getToken((__flags)) != tt) {                                        \
42671:             reportErrorNumber(NULL, JSREPORT_ERROR, errno);                                 \
    1:             return NULL;                                                                    \
    1:         }                                                                                   \
    1:     JS_END_MACRO
40854: #define MUST_MATCH_TOKEN(tt, errno) MUST_MATCH_TOKEN_WITH_FLAGS(tt, errno, 0)
    1: 
27012: void
27012: JSParseNode::become(JSParseNode *pn2)
27012: {
27012:     JS_ASSERT(!pn_defn);
27012:     JS_ASSERT(!pn2->pn_defn);
27012: 
27012:     JS_ASSERT(!pn_used);
27012:     if (pn2->pn_used) {
27012:         JSParseNode **pnup = &pn2->pn_lexdef->dn_uses;
27012:         while (*pnup != pn2)
27012:             pnup = &(*pnup)->pn_link;
27012:         *pnup = this;
27012:         pn_link = pn2->pn_link;
27012:         pn_used = true;
27012:         pn2->pn_link = NULL;
27012:         pn2->pn_used = false;
27012:     }
27012: 
27012:     pn_type = pn2->pn_type;
27012:     pn_op = pn2->pn_op;
27012:     pn_arity = pn2->pn_arity;
31479:     pn_parens = pn2->pn_parens;
27012:     pn_u = pn2->pn_u;
61049: 
61049:     /*
61049:      * If any pointers are pointing to pn2, change them to point to this
61049:      * instead, since pn2 will be cleared and probably recycled.
61049:      */
61049:     if (PN_TYPE(this) == TOK_FUNCTION && pn_arity == PN_FUNC) {
61049:         /* Function node: fix up the pn_funbox->node back-pointer. */
61049:         JS_ASSERT(pn_funbox->node == pn2);
61049:         pn_funbox->node = this;
61049:     } else if (pn_arity == PN_LIST && !pn_head) {
61049:         /* Empty list: fix up the pn_tail pointer. */
61063:         JS_ASSERT(pn_count == 0);
61049:         JS_ASSERT(pn_tail == &pn2->pn_head);
61049:         pn_tail = &pn_head;
61049:     }
61049: 
27012:     pn2->clear();
27012: }
27012: 
27012: void
27012: JSParseNode::clear()
27012: {
27012:     pn_type = TOK_EOF;
27012:     pn_op = JSOP_NOP;
27012:     pn_used = pn_defn = false;
27012:     pn_arity = PN_NULLARY;
31479:     pn_parens = false;
27012: }
27012: 
72098: Parser::Parser(JSContext *cx, JSPrincipals *prin, StackFrame *cfp, bool foldConstants)
53840:   : js::AutoGCRooter(cx, PARSER),
53840:     context(cx),
53840:     aleFreeList(NULL),
53840:     tokenStream(cx),
53840:     principals(NULL),
53840:     callerFrame(cfp),
71694:     callerVarObj(cfp ? &cfp->varObj() : NULL),
53840:     nodeList(NULL),
53840:     functionCount(0),
53840:     traceListHead(NULL),
53840:     tc(NULL),
64242:     emptyCallShape(NULL),
72098:     keepAtoms(cx->runtime),
72098:     foldConstants(foldConstants)
53840: {
53840:     js::PodArrayZero(tempFreeList);
53840:     setPrincipals(prin);
53840:     JS_ASSERT_IF(cfp, cfp->isScriptFrame());
53840: }
53840: 
27012: bool
61450: Parser::init(const jschar *base, size_t length, const char *filename, uintN lineno,
61450:              JSVersion version)
 3235: {
27012:     JSContext *cx = context;
64242:     emptyCallShape = EmptyShape::getEmptyCallShape(cx);
64242:     if (!emptyCallShape)
64242:         return false;
47609:     tempPoolMark = JS_ARENA_MARK(&cx->tempPool);
61450:     if (!tokenStream.init(base, length, filename, lineno, version)) {
47609:         JS_ARENA_RELEASE(&cx->tempPool, tempPoolMark);
27012:         return false;
27012:     }
27012:     return true;
27012: }
27012: 
40860: Parser::~Parser()
27012: {
27012:     JSContext *cx = context;
27012: 
27012:     if (principals)
27012:         JSPRINCIPALS_DROP(cx, principals);
47609:     JS_ARENA_RELEASE(&cx->tempPool, tempPoolMark);
26970: }
26970: 
26970: void
40860: Parser::setPrincipals(JSPrincipals *prin)
27012: {
27012:     JS_ASSERT(!principals);
27012:     if (prin)
27012:         JSPRINCIPALS_HOLD(context, prin);
27012:     principals = prin;
27012: }
27012: 
27012: JSObjectBox *
40860: Parser::newObjectBox(JSObject *obj)
27012: {
27012:     JS_ASSERT(obj);
 3235: 
 3235:     /*
 3235:      * We use JSContext.tempPool to allocate parsed objects and place them on
40860:      * a list in this Parser to ensure GC safety. Thus the tempPool arenas
11534:      * containing the entries must be alive until we are done with scanning,
 3235:      * parsing and code generation for the whole script or top-level function.
 3235:      */
27012:     JSObjectBox *objbox;
47609:     JS_ARENA_ALLOCATE_TYPE(objbox, JSObjectBox, &context->tempPool);
27012:     if (!objbox) {
71371:         js_ReportOutOfMemory(context);
27012:         return NULL;
27012:     }
27012:     objbox->traceLink = traceListHead;
27012:     traceListHead = objbox;
27012:     objbox->emitLink = NULL;
27012:     objbox->object = obj;
59968:     objbox->isFunctionBox = false;
27012:     return objbox;
27012: }
27012: 
27012: JSFunctionBox *
40860: Parser::newFunctionBox(JSObject *obj, JSParseNode *fn, JSTreeContext *tc)
27012: {
26970:     JS_ASSERT(obj);
40430:     JS_ASSERT(obj->isFunction());
27012: 
27012:     /*
27012:      * We use JSContext.tempPool to allocate parsed objects and place them on
40860:      * a list in this Parser to ensure GC safety. Thus the tempPool arenas
27012:      * containing the entries must be alive until we are done with scanning,
27012:      * parsing and code generation for the whole script or top-level function.
27012:      */
27012:     JSFunctionBox *funbox;
47609:     JS_ARENA_ALLOCATE_TYPE(funbox, JSFunctionBox, &context->tempPool);
27012:     if (!funbox) {
71371:         js_ReportOutOfMemory(context);
27012:         return NULL;
27012:     }
27012:     funbox->traceLink = traceListHead;
27012:     traceListHead = funbox;
27012:     funbox->emitLink = NULL;
27012:     funbox->object = obj;
59968:     funbox->isFunctionBox = true;
27012:     funbox->node = fn;
27012:     funbox->siblings = tc->functionList;
27012:     tc->functionList = funbox;
40860:     ++tc->parser->functionCount;
27012:     funbox->kids = NULL;
27012:     funbox->parent = tc->funbox;
37685:     funbox->methods = NULL;
64242:     new (&funbox->bindings) Bindings(context, emptyCallShape);
27012:     funbox->queued = false;
28814:     funbox->inLoop = false;
28814:     for (JSStmtInfo *stmt = tc->topStmt; stmt; stmt = stmt->down) {
28814:         if (STMT_IS_LOOP(stmt)) {
28814:             funbox->inLoop = true;
28814:             break;
28814:         }
28814:     }
27012:     funbox->level = tc->staticLevel;
35113:     funbox->tcflags = (TCF_IN_FUNCTION | (tc->flags & (TCF_COMPILE_N_GO | TCF_STRICT_MODE_CODE)));
61210:     if (tc->innermostWith)
61210:         funbox->tcflags |= TCF_IN_WITH;
27012:     return funbox;
27012: }
26970: 
37685: bool
37685: JSFunctionBox::joinable() const
37685: {
64294:     return FUN_NULL_CLOSURE(function()) &&
64291:            !(tcflags & (TCF_FUN_USES_ARGUMENTS | TCF_FUN_USES_OWN_NAME));
37685: }
37685: 
37685: bool
61210: JSFunctionBox::inAnyDynamicScope() const
61210: {
61210:     for (const JSFunctionBox *funbox = this; funbox; funbox = funbox->parent) {
61210:         if (funbox->tcflags & (TCF_IN_WITH | TCF_FUN_CALLS_EVAL))
61210:             return true;
61210:     }
61210:     return false;
61210: }
61210: 
61210: bool
64296: JSFunctionBox::scopeIsExtensible() const
64296: {
64296:     return tcflags & TCF_FUN_EXTENSIBLE_SCOPE;
64296: }
64296: 
64296: bool
37685: JSFunctionBox::shouldUnbrand(uintN methods, uintN slowMethods) const
37685: {
37685:     if (slowMethods != 0) {
37685:         for (const JSFunctionBox *funbox = this; funbox; funbox = funbox->parent) {
38549:             if (!(funbox->tcflags & TCF_FUN_MODULE_PATTERN))
37685:                 return true;
37685:             if (funbox->inLoop)
37685:                 return true;
37685:         }
37685:     }
37685:     return false;
37685: }
37685: 
26970: void
40860: Parser::trace(JSTracer *trc)
27012: {
40398:     JSObjectBox *objbox = traceListHead;
27012:     while (objbox) {
54707:         MarkObject(trc, *objbox->object, "parser.object");
59968:         if (objbox->isFunctionBox)
59968:             static_cast<JSFunctionBox *>(objbox)->bindings.trace(trc);
27012:         objbox = objbox->traceLink;
27012:     }
59968: 
64282:     if (emptyCallShape)
64360:         MarkShape(trc, emptyCallShape, "emptyCallShape");
64282: 
59968:     for (JSTreeContext *tc = this->tc; tc; tc = tc->parent)
59968:         tc->trace(trc);
27012: }
27012: 
60789: /* Add |node| to |parser|'s free node list. */
60789: static inline void
60789: AddNodeToFreeList(JSParseNode *pn, js::Parser *parser)
60789: {
60789:     /* Catch back-to-back dup recycles. */
60789:     JS_ASSERT(pn != parser->nodeList);
60789: 
60789:     /* 
60789:      * It's too hard to clear these nodes from the JSAtomLists, etc. that
60789:      * hold references to them, so we never free them. It's our caller's
60789:      * job to recognize and process these, since their children do need to
60789:      * be dealt with.
60789:      */
60789:     JS_ASSERT(!pn->pn_used);
38608:     JS_ASSERT(!pn->pn_defn);
60789: 
60789: #ifdef DEBUG
60789:     /* Poison the node, to catch attempts to use it without initializing it. */
60789:     memset(pn, 0xab, sizeof(*pn));
60789: #endif
60789: 
60789:     pn->pn_next = parser->nodeList;
60789:     parser->nodeList = pn;
27012: }
60789: 
60789: /* Add |node| to |tc|'s parser's free node list. */
60789: static inline void
60789: AddNodeToFreeList(JSParseNode *pn, JSTreeContext *tc)
60789: {
60789:     AddNodeToFreeList(pn, tc->parser);
60789: }
60789: 
60789: /*
60789:  * Walk the function box list at |*funboxHead|, removing boxes for deleted
60789:  * functions and cleaning up method lists. We do this once, before
60789:  * performing function analysis, to avoid traversing possibly long function
60789:  * lists repeatedly when recycling nodes.
60789:  *
60789:  * There are actually three possible states for function boxes and their
60789:  * nodes:
60789:  *
60789:  * - Live: funbox->node points to the node, and funbox->node->pn_funbox
60789:  *   points back to the funbox.
60789:  *
60789:  * - Recycled: funbox->node points to the node, but funbox->node->pn_funbox
60789:  *   is NULL. When a function node is part of a tree that gets recycled, we
60789:  *   must avoid corrupting any method list the node is on, so we leave the
60789:  *   function node unrecycled until we call cleanFunctionList. At recycle
60789:  *   time, we clear such nodes' pn_funbox pointers to indicate that they
60789:  *   are deleted and should be recycled once we get here.
60789:  *
60789:  * - Mutated: funbox->node is NULL; the contents of the node itself could
60789:  *   be anything. When we mutate a function node into some other kind of
60789:  *   node, we lose all indication that the node was ever part of the
60789:  *   function box tree; it could later be recycled, reallocated, and turned
60789:  *   into anything at all. (Fortunately, method list members never get
60789:  *   mutated, so we don't have to worry about that case.)
60789:  *   PrepareNodeForMutation clears the node's function box's node pointer,
60789:  *   disconnecting it entirely from the function box tree, and marking the
60789:  *   function box to be trimmed out.
60789:  */
60789: void
60789: Parser::cleanFunctionList(JSFunctionBox **funboxHead)
60789: {
60789:     JSFunctionBox **link = funboxHead;
60789:     while (JSFunctionBox *box = *link) {
60789:         if (!box->node) {
60789:             /*
60789:              * This funbox's parse node was mutated into something else. Drop the box,
60789:              * and stay at the same link.
60789:              */
60789:             *link = box->siblings;
60789:         } else if (!box->node->pn_funbox) {
60789:             /*
60789:              * This funbox's parse node is ready to be recycled. Drop the box, recycle
60789:              * the node, and stay at the same link.
60789:              */
60789:             *link = box->siblings;
60789:             AddNodeToFreeList(box->node, this);
60789:         } else {
60789:             /* The function is still live. */
60789: 
60789:             /* First, remove nodes for deleted functions from our methods list. */
60789:             {
60789:                 JSParseNode **methodLink = &box->methods;
60789:                 while (JSParseNode *method = *methodLink) {
60789:                     /* Method nodes are never rewritten in place to be other kinds of nodes. */
60789:                     JS_ASSERT(method->pn_arity == PN_FUNC);
60789:                     if (!method->pn_funbox) {
60789:                         /* Deleted: drop the node, and stay on this link. */
60789:                         *methodLink = method->pn_link;
60789:                     } else {
60789:                         /* Live: keep the node, and move to the next link. */
60789:                         methodLink = &method->pn_link;
60789:                     }
60789:                 }
60789:             }
60789: 
60789:             /* Second, remove boxes for deleted functions from our kids list. */
60789:             cleanFunctionList(&box->kids);
60789: 
60789:             /* Keep the box on the list, and move to the next link. */
60789:             link = &box->siblings;
60789:         }
60789:     }
60789: }
60789: 
60789: namespace js {
60789: 
60789: /*
60789:  * A work pool of JSParseNodes. The work pool is a stack, chained together
60789:  * by nodes' pn_next fields. We use this to avoid creating deep C++ stacks
60789:  * when recycling deep parse trees.
60789:  *
60789:  * Since parse nodes are probably allocated in something close to the order
60789:  * they appear in a depth-first traversal of the tree, making the work pool
60789:  * a stack should give us pretty good locality.
60789:  */
60789: class NodeStack {
60789:   public:
60789:     NodeStack() : top(NULL) { }
60789:     bool empty() { return top == NULL; }
60789:     void push(JSParseNode *pn) {
60789:         pn->pn_next = top;
60789:         top = pn;
60789:     }
60789:     void pushUnlessNull(JSParseNode *pn) { if (pn) push(pn); }
60789:     /* Push the children of the PN_LIST node |pn| on the stack. */
60789:     void pushList(JSParseNode *pn) {
60789:         /* This clobbers pn->pn_head if the list is empty; should be okay. */
60789:         *pn->pn_tail = top;
60789:         top = pn->pn_head;
60789:     }
60789:     JSParseNode *pop() {
60789:         JS_ASSERT(!empty());
60789:         JSParseNode *hold = top; /* my kingdom for a prog1 */
60789:         top = top->pn_next;
60789:         return hold;
60789:     }
60789:   private:
60789:     JSParseNode *top;
60789: };
60789: 
60789: } /* namespace js */
60789: 
60789: /*
60789:  * Push the children of |pn| on |stack|. Return true if |pn| itself could be
60789:  * safely recycled, or false if it must be cleaned later (pn_used and pn_defn
60789:  * nodes, and all function nodes; see comments for
60789:  * js::Parser::cleanFunctionList). Some callers want to free |pn|; others
60789:  * (PrepareNodeForMutation) don't care about |pn|, and just need to take care of
60789:  * its children.
60789:  */
60789: static bool
60789: PushNodeChildren(JSParseNode *pn, NodeStack *stack)
27012: {
27012:     switch (pn->pn_arity) {
27012:       case PN_FUNC:
60789:         /*
60789:          * Function nodes are linked into the function box tree, and may
60789:          * appear on method lists. Both of those lists are singly-linked,
60789:          * so trying to update them now could result in quadratic behavior
60789:          * when recycling trees containing many functions; and the lists
60789:          * can be very long. So we put off cleaning the lists up until just
60789:          * before function analysis, when we call
60789:          * js::Parser::cleanFunctionList.
60789:          *
60789:          * In fact, we can't recycle the parse node yet, either: it may
60789:          * appear on a method list, and reusing the node would corrupt
60789:          * that. Instead, we clear its pn_funbox pointer to mark it as
60789:          * deleted; js::Parser::cleanFunctionList recycles it as well.
60789:          *
60789:          * We do recycle the nodes around it, though, so we must clear
60789:          * pointers to them to avoid leaving dangling references where
60789:          * someone can find them.
60789:          */
60789:         pn->pn_funbox = NULL;
60789:         stack->pushUnlessNull(pn->pn_body);
60789:         pn->pn_body = NULL;
60789:         return false;
27012: 
27012:       case PN_NAME:
27012:         /*
60789:          * Because used/defn nodes appear in JSAtomLists and elsewhere, we
60789:          * don't recycle them. (We'll recover their storage when we free
60789:          * the temporary arena.) However, we do recycle the nodes around
60789:          * them, so clean up the pointers to avoid dangling references. The
60789:          * top-level decls table carries references to them that later
60789:          * iterations through the compileScript loop may find, so they need
60789:          * to be neat.
60789:          *
60789:          * pn_expr and pn_lexdef share storage; the latter isn't an owning
60789:          * reference.
60789:          */
60789:         if (!pn->pn_used) {
60789:             stack->pushUnlessNull(pn->pn_expr);
27012:             pn->pn_expr = NULL;
27012:         }
60789:         return !pn->pn_used && !pn->pn_defn;
60789: 
60789:       case PN_LIST:
60789:         stack->pushList(pn);
60789:         break;
60789:       case PN_TERNARY:
60789:         stack->pushUnlessNull(pn->pn_kid1);
60789:         stack->pushUnlessNull(pn->pn_kid2);
60789:         stack->pushUnlessNull(pn->pn_kid3);
60789:         break;
60789:       case PN_BINARY:
60789:         if (pn->pn_left != pn->pn_right)
60789:             stack->pushUnlessNull(pn->pn_left);
60789:         stack->pushUnlessNull(pn->pn_right);
60789:         break;
60789:       case PN_UNARY:
60789:         stack->pushUnlessNull(pn->pn_kid);
60789:         break;
60789:       case PN_NULLARY:
60789:         /* 
60789:          * E4X function namespace nodes are PN_NULLARY, but can appear on use
60789:          * lists.
60789:          */
60789:         return !pn->pn_used && !pn->pn_defn;
60789:     }
60789: 
60789:     return true;
60789: }
60789: 
60789: /*
60789:  * Prepare |pn| to be mutated in place into a new kind of node. Recycle all
60789:  * |pn|'s recyclable children (but not |pn| itself!), and disconnect it from
60789:  * metadata structures (the function box tree).
60789:  */
60789: static void
60789: PrepareNodeForMutation(JSParseNode *pn, JSTreeContext *tc)
60789: {
60789:     if (pn->pn_arity != PN_NULLARY) {
60789:         if (pn->pn_arity == PN_FUNC) {
60789:             /*
60789:              * Since this node could be turned into anything, we can't
60789:              * ensure it won't be subsequently recycled, so we must
60789:              * disconnect it from the funbox tree entirely.
60789:              *
60789:              * Note that pn_funbox may legitimately be NULL. functionDef
60789:              * applies MakeDefIntoUse to definition nodes, which can come
60789:              * from prior iterations of the big loop in compileScript. In
60789:              * such cases, the defn nodes have been visited by the recycler
60789:              * (but not actually recycled!), and their funbox pointers
60789:              * cleared. But it's fine to mutate them into uses of some new
60789:              * definition.
60789:              */
60789:             if (pn->pn_funbox)
60789:                 pn->pn_funbox->node = NULL;
60789:         }
60789: 
60789:         /* Put |pn|'s children (but not |pn| itself) on a work stack. */
60789:         NodeStack stack;
60789:         PushNodeChildren(pn, &stack);
60789:         /*
60789:          * For each node on the work stack, push its children on the work stack,
60789:          * and free the node if we can.
60789:          */
60789:         while (!stack.empty()) {
60789:             pn = stack.pop();
60789:             if (PushNodeChildren(pn, &stack))
60789:                 AddNodeToFreeList(pn, tc);
60789:         }
60789:     }
60789: }
60789: 
60789: /*
60789:  * Return the nodes in the subtree |pn| to the parser's free node list, for
60789:  * reallocation.
60789:  *
60789:  * Note that all functions in |pn| that are not enclosed by other functions
60789:  * in |pn| must be direct children of |tc|, because we only clean up |tc|'s
60789:  * function and method lists. You must not reach into a function and
60789:  * recycle some part of it (unless you've updated |tc|->functionList, the
60789:  * way js_FoldConstants does).
60789:  */
60789: static JSParseNode *
60789: RecycleTree(JSParseNode *pn, JSTreeContext *tc)
60789: {
60789:     if (!pn)
60789:         return NULL;
60789: 
60789:     JSParseNode *savedNext = pn->pn_next;
60789: 
60789:     NodeStack stack;
60789:     for (;;) {
60789:         if (PushNodeChildren(pn, &stack))
60789:             AddNodeToFreeList(pn, tc);
60789:         if (stack.empty())
60789:             break;
60789:         pn = stack.pop();
60789:     }
60789: 
60789:     return savedNext;
60789: }
60789: 
60789: /*
60789:  * Allocate a JSParseNode from tc's node freelist or, failing that, from
60789:  * cx's temporary arena.
40232:  */
26970: static JSParseNode *
27012: NewOrRecycledNode(JSTreeContext *tc)
27012: {
60789:     JSParseNode *pn;
27012: 
40860:     pn = tc->parser->nodeList;
    1:     if (!pn) {
40860:         JSContext *cx = tc->parser->context;
27012: 
47609:         JS_ARENA_ALLOCATE_TYPE(pn, JSParseNode, &cx->tempPool);
    1:         if (!pn)
71371:             js_ReportOutOfMemory(cx);
    1:     } else {
40860:         tc->parser->nodeList = pn->pn_next;
60789:     }
60789: 
 2567:     if (pn) {
27012:         pn->pn_used = pn->pn_defn = false;
 1577:         memset(&pn->pn_u, 0, sizeof pn->pn_u);
 1577:         pn->pn_next = NULL;
 2567:     }
    1:     return pn;
    1: }
    1: 
40232: /* used only by static create methods of subclasses */
40232: 
40232: JSParseNode *
40232: JSParseNode::create(JSParseNodeArity arity, JSTreeContext *tc)
40221: {
40270:     JSParseNode *pn = NewOrRecycledNode(tc);
    1:     if (!pn)
    1:         return NULL;
40860:     const Token &tok = tc->parser->tokenStream.currentToken();
40854:     pn->init(tok.type, JSOP_NOP, arity);
40854:     pn->pn_pos = tok.pos;
    1:     return pn;
    1: }
    1: 
40232: JSParseNode *
40320: JSParseNode::newBinaryOrAppend(TokenKind tt, JSOp op, JSParseNode *left, JSParseNode *right,
    1:                                JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn, *pn1, *pn2;
    1: 
    1:     if (!left || !right)
    1:         return NULL;
    1: 
    1:     /*
    1:      * Flatten a left-associative (left-heavy) tree of a given operator into
    1:      * a list, to reduce js_FoldConstants and js_EmitTree recursion.
    1:      */
27012:     if (PN_TYPE(left) == tt &&
27012:         PN_OP(left) == op &&
    1:         (js_CodeSpec[op].format & JOF_LEFTASSOC)) {
    1:         if (left->pn_arity != PN_LIST) {
    1:             pn1 = left->pn_left, pn2 = left->pn_right;
    1:             left->pn_arity = PN_LIST;
31479:             left->pn_parens = false;
27012:             left->initList(pn1);
27012:             left->append(pn2);
    1:             if (tt == TOK_PLUS) {
    1:                 if (pn1->pn_type == TOK_STRING)
27012:                     left->pn_xflags |= PNX_STRCAT;
    1:                 else if (pn1->pn_type != TOK_NUMBER)
27012:                     left->pn_xflags |= PNX_CANTFOLD;
    1:                 if (pn2->pn_type == TOK_STRING)
27012:                     left->pn_xflags |= PNX_STRCAT;
    1:                 else if (pn2->pn_type != TOK_NUMBER)
27012:                     left->pn_xflags |= PNX_CANTFOLD;
27012:             }
27012:         }
27012:         left->append(right);
    1:         left->pn_pos.end = right->pn_pos.end;
    1:         if (tt == TOK_PLUS) {
    1:             if (right->pn_type == TOK_STRING)
27012:                 left->pn_xflags |= PNX_STRCAT;
    1:             else if (right->pn_type != TOK_NUMBER)
27012:                 left->pn_xflags |= PNX_CANTFOLD;
    1:         }
    1:         return left;
    1:     }
    1: 
    1:     /*
    1:      * Fold constant addition immediately, to conserve node space and, what's
    1:      * more, so js_FoldConstants never sees mixed addition and concatenation
    1:      * operations with more than one leading non-string operand in a PN_LIST
    1:      * generated for expressions such as 1 + 2 + "pt" (which should evaluate
    1:      * to "3pt", not "12pt").
    1:      */
    1:     if (tt == TOK_PLUS &&
    1:         left->pn_type == TOK_NUMBER &&
72098:         right->pn_type == TOK_NUMBER &&
72098:         tc->parser->foldConstants) {
    1:         left->pn_dval += right->pn_dval;
    1:         left->pn_pos.end = right->pn_pos.end;
    1:         RecycleTree(right, tc);
    1:         return left;
    1:     }
    1: 
27012:     pn = NewOrRecycledNode(tc);
    1:     if (!pn)
    1:         return NULL;
40232:     pn->init(tt, op, PN_BINARY);
    1:     pn->pn_pos.begin = left->pn_pos.begin;
    1:     pn->pn_pos.end = right->pn_pos.end;
    1:     pn->pn_left = left;
    1:     pn->pn_right = right;
40232:     return (BinaryNode *)pn;
40232: }
40232: 
40232: namespace js {
40232: 
40232: inline void
40232: NameNode::initCommon(JSTreeContext *tc)
40232: {
40232:     pn_expr = NULL;
47573:     pn_cookie.makeFree();
59228:     pn_dflags = (!tc->topStmt || tc->topStmt->type == STMT_BLOCK)
59228:                 ? PND_BLOCKCHILD
59228:                 : 0;
40232:     pn_blockid = tc->blockid();
40232: }
40232: 
40232: NameNode *
40232: NameNode::create(JSAtom *atom, JSTreeContext *tc)
40232: {
40232:     JSParseNode *pn;
40232: 
40232:     pn = JSParseNode::create(PN_NAME, tc);
40232:     if (pn) {
40232:         pn->pn_atom = atom;
40232:         ((NameNode *)pn)->initCommon(tc);
40232:     }
40232:     return (NameNode *)pn;
40232: }
40232: 
40232: } /* namespace js */
    1: 
27012: static bool
27012: GenerateBlockId(JSTreeContext *tc, uint32& blockid)
27012: {
27012:     if (tc->blockidGen == JS_BIT(20)) {
40860:         JS_ReportErrorNumber(tc->parser->context, js_GetErrorMessage, NULL,
27012:                              JSMSG_NEED_DIET, "program");
27012:         return false;
27012:     }
27012:     blockid = tc->blockidGen++;
27012:     return true;
27012: }
27012: 
27012: static bool
27012: GenerateBlockIdForStmtNode(JSParseNode *pn, JSTreeContext *tc)
27012: {
27012:     JS_ASSERT(tc->topStmt);
27012:     JS_ASSERT(STMT_MAYBE_SCOPE(tc->topStmt));
27012:     JS_ASSERT(pn->pn_type == TOK_LC || pn->pn_type == TOK_LEXICALSCOPE);
27012:     if (!GenerateBlockId(tc, tc->topStmt->blockid))
27012:         return false;
27012:     pn->pn_blockid = tc->topStmt->blockid;
27012:     return true;
27012: }
27012: 
    1: /*
    1:  * Parse a top-level JS script.
    1:  */
 8444: JSParseNode *
40860: Parser::parse(JSObject *chain)
27012: {
    1:     /*
    1:      * Protect atoms from being collected by a GC activation, which might
    1:      * - nest on this thread due to out of memory (the so-called "last ditch"
    1:      *   GC attempted within js_NewGCThing), or
    1:      * - run for any reason on another thread if this thread is suspended on
    1:      *   an object lock before it finishes generating bytecode into a script
    1:      *   protected from the GC by a root or a stack frame reference.
    1:      */
40263:     JSTreeContext globaltc(this);
57829:     globaltc.setScopeChain(chain);
40263:     if (!GenerateBlockId(&globaltc, globaltc.bodyid))
40263:         return NULL;
40263: 
40263:     JSParseNode *pn = statements();
    1:     if (pn) {
40354:         if (!tokenStream.matchToken(TOK_EOF)) {
42671:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_SYNTAX_ERROR);
    1:             pn = NULL;
72098:         } else if (foldConstants) {
40263:             if (!js_FoldConstants(context, pn, &globaltc))
    1:                 pn = NULL;
    1:         }
    1:     }
    1:     return pn;
    1: }
    1: 
47573: JS_STATIC_ASSERT(UpvarCookie::FREE_LEVEL == JS_BITMASK(JSFB_LEVEL_BITS));
28814: 
27012: static inline bool
27012: SetStaticLevel(JSTreeContext *tc, uintN staticLevel)
27012: {
27012:     /*
47573:      * This is a lot simpler than error-checking every UpvarCookie::set, and
47573:      * practically speaking it leaves more than enough room for upvars.
47573:      */
47573:     if (UpvarCookie::isLevelReserved(staticLevel)) {
40860:         JS_ReportErrorNumber(tc->parser->context, js_GetErrorMessage, NULL,
27012:                              JSMSG_TOO_DEEP, js_function_str);
27012:         return false;
27012:     }
27012:     tc->staticLevel = staticLevel;
27012:     return true;
27012: }
27012: 
    1: /*
    1:  * Compile a top-level script.
    1:  */
69223: Compiler::Compiler(JSContext *cx, JSPrincipals *prin, StackFrame *cfp)
53840:   : parser(cx, prin, cfp)
53840: {
53840: }
53840: 
27012: JSScript *
69223: Compiler::compileScript(JSContext *cx, JSObject *scopeChain, StackFrame *callerFrame,
18955:                         JSPrincipals *principals, uint32 tcflags,
18955:                         const jschar *chars, size_t length,
61450:                         const char *filename, uintN lineno, JSVersion version,
33751:                         JSString *source /* = NULL */,
53125:                         uintN staticLevel /* = 0 */)
27012: {
 6561:     JSArenaPool codePool, notePool;
40320:     TokenKind tt;
    1:     JSParseNode *pn;
 6561:     JSScript *script;
35113:     bool inDirectivePrologue;
    1: 
52555:     JS_ASSERT(!(tcflags & ~(TCF_COMPILE_N_GO | TCF_NO_SCRIPT_RVAL | TCF_NEED_MUTABLE_SCRIPT |
52555:                             TCF_COMPILE_FOR_EVAL)));
 8444: 
    1:     /*
18955:      * The scripted callerFrame can only be given for compile-and-go scripts
27012:      * and non-zero static level requires callerFrame.
    1:      */
18955:     JS_ASSERT_IF(callerFrame, tcflags & TCF_COMPILE_N_GO);
33751:     JS_ASSERT_IF(staticLevel != 0, callerFrame);
27012: 
41867:     Compiler compiler(cx, principals, callerFrame);
61450:     if (!compiler.init(chars, length, filename, lineno, version))
27012:         return NULL;
    1: 
71371:     JS_InitArenaPool(&codePool, "code", 1024, sizeof(jsbytecode));
71371:     JS_InitArenaPool(&notePool, "note", 1024, sizeof(jssrcnote));
27012: 
40860:     Parser &parser = compiler.parser;
40860:     TokenStream &tokenStream = parser.tokenStream;
40860: 
40860:     JSCodeGenerator cg(&parser, &codePool, &notePool, tokenStream.getLineno());
41867:     if (!cg.init())
41867:         return NULL;
 6561: 
18989:     MUST_FLOW_THROUGH("out");
28817: 
53198:     // We can specialize a bit for the given scope chain if that scope chain is the global object.
53198:     JSObject *globalObj = scopeChain && scopeChain == scopeChain->getGlobal()
53198:                         ? scopeChain->getGlobal()
53198:                         : NULL;
52555:     js::GlobalScope globalScope(cx, globalObj, &cg);
52555:     if (globalObj) {
52555:         JS_ASSERT(globalObj->isNative());
52555:         JS_ASSERT((globalObj->getClass()->flags & JSCLASS_GLOBAL_FLAGS) == JSCLASS_GLOBAL_FLAGS);
52555:     }
52555: 
28817:     /* Null script early in case of error, to reduce our code footprint. */
28817:     script = NULL;
28817: 
52555:     globalScope.cg = &cg;
33752:     cg.flags |= tcflags;
57829:     cg.setScopeChain(scopeChain);
52555:     compiler.globalScope = &globalScope;
33751:     if (!SetStaticLevel(&cg, staticLevel))
28817:         goto out;
27012: 
35303:     /* If this is a direct call to eval, inherit the caller's strictness.  */
35303:     if (callerFrame &&
53840:         callerFrame->isScriptFrame() &&
53840:         callerFrame->script()->strictModeCode) {
35303:         cg.flags |= TCF_STRICT_MODE_CODE;
40860:         tokenStream.setStrictMode();
35303:     }
35303: 
27012:     /*
27012:      * If funbox is non-null after we create the new script, callerFrame->fun
24375:      * was saved in the 0th object table entry.
21449:      */
28817:     JSObjectBox *funbox;
28817:     funbox = NULL;
24375: 
24375:     if (tcflags & TCF_COMPILE_N_GO) {
24375:         if (source) {
24375:             /*
24375:              * Save eval program source in script->atomMap.vector[0] for the
56010:              * eval cache (see EvalCacheLookup in jsobj.cpp).
24375:              */
70270:             JSAtom *atom = js_AtomizeString(cx, source);
40860:             if (!atom || !cg.atomList.add(&parser, atom))
28817:                 goto out;
24375:         }
24375: 
53840:         if (callerFrame && callerFrame->isFunctionFrame()) {
24375:             /*
24375:              * An eval script in a caller frame needs to have its enclosing
27012:              * function captured in case it refers to an upvar, and someone
27012:              * wishes to decompile it while it's running.
27012:              */
53840:             funbox = parser.newObjectBox(FUN_OBJECT(callerFrame->fun()));
27012:             if (!funbox)
28817:                 goto out;
27012:             funbox->emitLink = cg.objectList.lastbox;
27012:             cg.objectList.lastbox = funbox;
21449:             cg.objectList.length++;
21449:         }
24375:     }
21449: 
27012:     /*
40239:      * Inline this->statements to emit as we go to save AST space. We must
40239:      * generate our script-body blockid since we aren't calling Statements.
27012:      */
27012:     uint32 bodyid;
27012:     if (!GenerateBlockId(&cg, bodyid))
28817:         goto out;
27012:     cg.bodyid = bodyid;
27012: 
27903: #if JS_HAS_XML_SUPPORT
27903:     pn = NULL;
28817:     bool onlyXML;
28817:     onlyXML = true;
27903: #endif
27903: 
35113:     inDirectivePrologue = true;
59219:     tokenStream.setOctalCharacterEscape(false);
 9604:     for (;;) {
40860:         tt = tokenStream.peekToken(TSF_OPERAND);
 9604:         if (tt <= TOK_EOF) {
 9604:             if (tt == TOK_EOF)
 9604:                 break;
 9604:             JS_ASSERT(tt == TOK_ERROR);
 9604:             goto out;
 9604:         }
 9604: 
40860:         pn = parser.statement();
27012:         if (!pn)
 6561:             goto out;
27012:         JS_ASSERT(!cg.blockNode);
27012: 
59219:         if (inDirectivePrologue && !parser.recognizeDirectivePrologue(pn, &inDirectivePrologue))
59219:             goto out;
35113: 
27012:         if (!js_FoldConstants(cx, pn, &cg))
 6561:             goto out;
27012: 
60788:         if (!parser.analyzeFunctions(&cg))
27012:             goto out;
27012:         cg.functionList = NULL;
27012: 
27012:         if (!js_EmitTree(cx, &cg, pn))
27012:             goto out;
61450: 
27903: #if JS_HAS_XML_SUPPORT
27903:         if (PN_TYPE(pn) != TOK_SEMI ||
27903:             !pn->pn_kid ||
40320:             !TreeTypeIsXML(PN_TYPE(pn->pn_kid))) {
27903:             onlyXML = false;
27903:         }
27903: #endif
27012:         RecycleTree(pn, &cg);
 9604:     }
 9604: 
27903: #if JS_HAS_XML_SUPPORT
27903:     /*
27903:      * Prevent XML data theft via <script src="http://victim.com/foo.xml">.
27903:      * For background, see:
27903:      *
27903:      * https://bugzilla.mozilla.org/show_bug.cgi?id=336551
27903:      */
43195:     if (pn && onlyXML && !callerFrame) {
42671:         parser.reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_XML_WHOLE_PROGRAM);
27903:         goto out;
27903:     }
27903: #endif
27903: 
16072:     /*
37029:      * Global variables (gvars) share the atom index space with locals. Due to
17947:      * incremental code generation we need to patch the bytecode to adjust the
17947:      * local references to skip the globals.
16072:      */
54477:     if (cg.hasSharps()) {
16072:         jsbytecode *code, *end;
16072:         JSOp op;
16072:         const JSCodeSpec *cs;
16072:         uintN len, slot;
16072: 
16072:         code = CG_BASE(&cg);
16072:         for (end = code + CG_OFFSET(&cg); code != end; code += len) {
16072:             JS_ASSERT(code < end);
16072:             op = (JSOp) *code;
16072:             cs = &js_CodeSpec[op];
17947:             len = (cs->length > 0)
16072:                   ? (uintN) cs->length
16072:                   : js_GetVariableBytecodeLength(code);
32729:             if ((cs->format & JOF_SHARPSLOT) ||
32729:                 JOF_TYPE(cs->format) == JOF_LOCAL ||
16072:                 (JOF_TYPE(cs->format) == JOF_SLOTATOM)) {
69659:                 /*
69659:                  * JSOP_GETARGPROP also has JOF_SLOTATOM type, but it may be
69659:                  * emitted only for a function.
69659:                  */
32729:                 JS_ASSERT_IF(!(cs->format & JOF_SHARPSLOT),
69659:                              (JOF_TYPE(cs->format) == JOF_SLOTATOM) ==
69659:                              (op == JSOP_GETLOCALPROP));
16072:                 slot = GET_SLOTNO(code);
32729:                 if (!(cs->format & JOF_SHARPSLOT))
32729:                     slot += cg.sharpSlots();
16072:                 if (slot >= SLOTNO_LIMIT)
16072:                     goto too_many_slots;
16072:                 SET_SLOTNO(code, slot);
16072:             }
16072:         }
16072:     }
16072: 
    1:     /*
    1:      * Nowadays the threaded interpreter needs a stop instruction, so we
    1:      * do have to emit that here.
    1:      */
27012:     if (js_Emit1(cx, &cg, JSOP_STOP) < 0)
 6561:         goto out;
61450: 
61450:     JS_ASSERT(cg.version() == version);
61450: 
54840:     script = JSScript::NewScriptFromCG(cx, &cg);
71685:     if (!script)
71685:         goto out;
71685: 
71685:     if (funbox)
33750:         script->savedCallerFun = true;
 6561: 
71359:     {
71359:         AutoShapeRooter shapeRoot(cx, script->bindings.lastShape());
54477:         if (!defineGlobals(cx, globalScope, script))
54477:             goto late_error;
71359:     }
54477: 
 6561:   out:
47609:     JS_FinishArenaPool(&codePool);
47609:     JS_FinishArenaPool(&notePool);
 6561:     return script;
16072: 
16072:   too_many_slots:
42671:     parser.reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_TOO_MANY_LOCALS);
54477:     /* Fall through. */
54477: 
54477:   late_error:
54477:     if (script) {
54477:         js_DestroyScript(cx, script);
16072:         script = NULL;
54477:     }
16072:     goto out;
    1: }
    1: 
54477: bool
54477: Compiler::defineGlobals(JSContext *cx, GlobalScope &globalScope, JSScript *script)
54477: {
54477:     if (!globalScope.defs.length())
54477:         return true;
54477: 
54477:     JSObject *globalObj = globalScope.globalObj;
54477: 
54477:     /* Define and update global properties. */
54477:     for (size_t i = 0; i < globalScope.defs.length(); i++) {
54477:         GlobalScope::GlobalDef &def = globalScope.defs[i];
54477: 
54477:         /* Names that could be resolved ahead of time can be skipped. */
54477:         if (!def.atom)
54477:             continue;
54477: 
54477:         jsid id = ATOM_TO_JSID(def.atom);
54477:         Value rval;
54477: 
54477:         if (def.funbox) {
64294:             JSFunction *fun = def.funbox->function();
54477: 
54477:             /*
54477:              * No need to check for redeclarations or anything, global
54477:              * optimizations only take place if the property is not defined.
54477:              */
54477:             rval.setObject(*fun);
54477:         } else {
54477:             rval.setUndefined();
54477:         }
54477: 
69855:         const Shape *shape =
69855:             DefineNativeProperty(cx, globalObj, id, rval, PropertyStub, StrictPropertyStub,
69855:                                  JSPROP_ENUMERATE | JSPROP_PERMANENT, 0, 0);
69855:         if (!shape)
54477:             return false;
54477:         def.knownSlot = shape->slot;
54477:     }
54477: 
72091:     js::Vector<JSScript *, 16> worklist(cx);
54477:     if (!worklist.append(script))
54477:         return false;
54477: 
54477:     /*
54477:      * Recursively walk through all scripts we just compiled. For each script,
54477:      * go through all global uses. Each global use indexes into globalScope->defs.
54477:      * Use this information to repoint each use to the correct slot in the global
54477:      * object.
54477:      */
54477:     while (worklist.length()) {
54477:         JSScript *inner = worklist.back();
54477:         worklist.popBack();
54477: 
59221:         if (JSScript::isValidOffset(inner->objectsOffset)) {
54477:             JSObjectArray *arr = inner->objects();
54477:             for (size_t i = 0; i < arr->length; i++) {
54477:                 JSObject *obj = arr->vector[i];
54477:                 if (!obj->isFunction())
54477:                     continue;
54477:                 JSFunction *fun = obj->getFunctionPrivate();
54477:                 JS_ASSERT(fun->isInterpreted());
70311:                 JSScript *inner = fun->script();
59221:                 if (!JSScript::isValidOffset(inner->globalsOffset) &&
59221:                     !JSScript::isValidOffset(inner->objectsOffset)) {
54477:                     continue;
59221:                 }
54477:                 if (!worklist.append(inner))
54477:                     return false;
54477:             }
54477:         }
54477: 
59221:         if (!JSScript::isValidOffset(inner->globalsOffset))
54477:             continue;
54477: 
54477:         GlobalSlotArray *globalUses = inner->globals();
54477:         uint32 nGlobalUses = globalUses->length;
54477:         for (uint32 i = 0; i < nGlobalUses; i++) {
54477:             uint32 index = globalUses->vector[i].slot;
54477:             JS_ASSERT(index < globalScope.defs.length());
54477:             globalUses->vector[i].slot = globalScope.defs[index].knownSlot;
54477:         }
54477:     }
54477: 
54477:     return true;
54477: }
54477: 
    1: /*
    1:  * Insist on a final return before control flows out of pn.  Try to be a bit
    1:  * smart about loops: do {...; return e2;} while(0) at the end of a function
    1:  * that contains an early return e1 will get a strict warning.  Similarly for
    1:  * iloops: while (true){...} is treated as though ... returns.
    1:  */
    1: #define ENDS_IN_OTHER   0
    1: #define ENDS_IN_RETURN  1
    1: #define ENDS_IN_BREAK   2
    1: 
    1: static int
    1: HasFinalReturn(JSParseNode *pn)
    1: {
    1:     JSParseNode *pn2, *pn3;
    1:     uintN rv, rv2, hasDefault;
    1: 
    1:     switch (pn->pn_type) {
    1:       case TOK_LC:
    1:         if (!pn->pn_head)
    1:             return ENDS_IN_OTHER;
27012:         return HasFinalReturn(pn->last());
    1: 
    1:       case TOK_IF:
    1:         if (!pn->pn_kid3)
    1:             return ENDS_IN_OTHER;
    1:         return HasFinalReturn(pn->pn_kid2) & HasFinalReturn(pn->pn_kid3);
    1: 
    1:       case TOK_WHILE:
    1:         pn2 = pn->pn_left;
    1:         if (pn2->pn_type == TOK_PRIMARY && pn2->pn_op == JSOP_TRUE)
    1:             return ENDS_IN_RETURN;
    1:         if (pn2->pn_type == TOK_NUMBER && pn2->pn_dval)
    1:             return ENDS_IN_RETURN;
    1:         return ENDS_IN_OTHER;
    1: 
    1:       case TOK_DO:
    1:         pn2 = pn->pn_right;
    1:         if (pn2->pn_type == TOK_PRIMARY) {
    1:             if (pn2->pn_op == JSOP_FALSE)
    1:                 return HasFinalReturn(pn->pn_left);
    1:             if (pn2->pn_op == JSOP_TRUE)
    1:                 return ENDS_IN_RETURN;
    1:         }
    1:         if (pn2->pn_type == TOK_NUMBER) {
    1:             if (pn2->pn_dval == 0)
    1:                 return HasFinalReturn(pn->pn_left);
    1:             return ENDS_IN_RETURN;
    1:         }
    1:         return ENDS_IN_OTHER;
    1: 
    1:       case TOK_FOR:
    1:         pn2 = pn->pn_left;
    1:         if (pn2->pn_arity == PN_TERNARY && !pn2->pn_kid2)
    1:             return ENDS_IN_RETURN;
    1:         return ENDS_IN_OTHER;
    1: 
    1:       case TOK_SWITCH:
    1:         rv = ENDS_IN_RETURN;
    1:         hasDefault = ENDS_IN_OTHER;
    1:         pn2 = pn->pn_right;
    1:         if (pn2->pn_type == TOK_LEXICALSCOPE)
27012:             pn2 = pn2->expr();
    1:         for (pn2 = pn2->pn_head; rv && pn2; pn2 = pn2->pn_next) {
    1:             if (pn2->pn_type == TOK_DEFAULT)
    1:                 hasDefault = ENDS_IN_RETURN;
    1:             pn3 = pn2->pn_right;
    1:             JS_ASSERT(pn3->pn_type == TOK_LC);
    1:             if (pn3->pn_head) {
27012:                 rv2 = HasFinalReturn(pn3->last());
    1:                 if (rv2 == ENDS_IN_OTHER && pn2->pn_next)
    1:                     /* Falling through to next case or default. */;
    1:                 else
    1:                     rv &= rv2;
    1:             }
    1:         }
    1:         /* If a final switch has no default case, we judge it harshly. */
    1:         rv &= hasDefault;
    1:         return rv;
    1: 
    1:       case TOK_BREAK:
    1:         return ENDS_IN_BREAK;
    1: 
    1:       case TOK_WITH:
    1:         return HasFinalReturn(pn->pn_right);
    1: 
    1:       case TOK_RETURN:
    1:         return ENDS_IN_RETURN;
    1: 
    1:       case TOK_COLON:
    1:       case TOK_LEXICALSCOPE:
27012:         return HasFinalReturn(pn->expr());
    1: 
    1:       case TOK_THROW:
    1:         return ENDS_IN_RETURN;
    1: 
    1:       case TOK_TRY:
    1:         /* If we have a finally block that returns, we are done. */
    1:         if (pn->pn_kid3) {
    1:             rv = HasFinalReturn(pn->pn_kid3);
    1:             if (rv == ENDS_IN_RETURN)
    1:                 return rv;
    1:         }
    1: 
    1:         /* Else check the try block and any and all catch statements. */
    1:         rv = HasFinalReturn(pn->pn_kid1);
    1:         if (pn->pn_kid2) {
    1:             JS_ASSERT(pn->pn_kid2->pn_arity == PN_LIST);
    1:             for (pn2 = pn->pn_kid2->pn_head; pn2; pn2 = pn2->pn_next)
    1:                 rv &= HasFinalReturn(pn2);
    1:         }
    1:         return rv;
    1: 
    1:       case TOK_CATCH:
    1:         /* Check this catch block's body. */
    1:         return HasFinalReturn(pn->pn_kid3);
    1: 
    1:       case TOK_LET:
    1:         /* Non-binary let statements are let declarations. */
    1:         if (pn->pn_arity != PN_BINARY)
    1:             return ENDS_IN_OTHER;
    1:         return HasFinalReturn(pn->pn_right);
    1: 
    1:       default:
    1:         return ENDS_IN_OTHER;
    1:     }
    1: }
    1: 
    1: static JSBool
64214: ReportBadReturn(JSContext *cx, JSTreeContext *tc, JSParseNode *pn, uintN flags, uintN errnum,
    1:                 uintN anonerrnum)
    1: {
57812:     JSAutoByteString name;
57829:     if (tc->fun()->atom) {
57829:         if (!js_AtomToPrintableString(cx, tc->fun()->atom, &name))
57812:             return false;
    1:     } else {
    1:         errnum = anonerrnum;
57812:     }
64214:     return ReportCompileErrorNumber(cx, TS(tc->parser), pn, flags, errnum, name.ptr());
    1: }
    1: 
    1: static JSBool
 8444: CheckFinalReturn(JSContext *cx, JSTreeContext *tc, JSParseNode *pn)
    1: {
41884:     JS_ASSERT(tc->inFunction());
    1:     return HasFinalReturn(pn) == ENDS_IN_RETURN ||
64214:            ReportBadReturn(cx, tc, pn, JSREPORT_WARNING | JSREPORT_STRICT,
    1:                            JSMSG_NO_RETURN_VALUE, JSMSG_ANON_NO_RETURN_VALUE);
    1: }
    1: 
35323: /*
35324:  * Check that it is permitted to assign to lhs.  Strict mode code may not
35324:  * assign to 'eval' or 'arguments'.
35324:  */
35324: bool
35324: CheckStrictAssignment(JSContext *cx, JSTreeContext *tc, JSParseNode *lhs)
35324: {
51097:     if (tc->needStrictChecks() && lhs->pn_type == TOK_NAME) {
35324:         JSAtom *atom = lhs->pn_atom;
35324:         JSAtomState *atomState = &cx->runtime->atomState;
35324:         if (atom == atomState->evalAtom || atom == atomState->argumentsAtom) {
57812:             JSAutoByteString name;
57812:             if (!js_AtomToPrintableString(cx, atom, &name) ||
40860:                 !ReportStrictModeError(cx, TS(tc->parser), tc, lhs, JSMSG_DEPRECATED_ASSIGN,
57812:                                        name.ptr())) {
35324:                 return false;
35324:             }
35324:         }
35324:     }
35324:     return true;
35324: }
35324: 
35324: /*
62048:  * Check that it is permitted to introduce a binding for atom.  Strict mode
62048:  * forbids introducing new definitions for 'eval', 'arguments', or for any
62048:  * strict mode reserved keyword.  Use pn for reporting error locations, or use
62048:  * tc's token stream if pn is NULL.
35325:  */
35325: bool
40232: CheckStrictBinding(JSContext *cx, JSTreeContext *tc, JSAtom *atom, JSParseNode *pn)
35325: {
35325:     if (!tc->needStrictChecks())
35325:         return true;
35325: 
35325:     JSAtomState *atomState = &cx->runtime->atomState;
62048:     if (atom == atomState->evalAtom ||
62048:         atom == atomState->argumentsAtom ||
62048:         FindKeyword(atom->charsZ(), atom->length()))
62048:     {
57812:         JSAutoByteString name;
57812:         if (!js_AtomToPrintableString(cx, atom, &name))
35325:             return false;
57812:         return ReportStrictModeError(cx, TS(tc->parser), tc, pn, JSMSG_BAD_BINDING, name.ptr());
35325:     }
62048: 
35325:     return true;
35325: }
35325: 
35323: static bool
62048: ReportBadParameter(JSContext *cx, JSTreeContext *tc, JSAtom *name, uintN errorNumber)
62048: {
62048:     JSDefinition *dn = ALE_DEFN(tc->decls.lookup(name));
62048:     JSAutoByteString bytes;
62048:     return js_AtomToPrintableString(cx, name, &bytes) &&
62048:            ReportStrictModeError(cx, TS(tc->parser), tc, dn, errorNumber, bytes.ptr());
62048: }
62048: 
62048: /*
62048:  * In strict mode code, all parameter names must be distinct, must not be
62048:  * strict mode reserved keywords, and must not be 'eval' or 'arguments'.  We
62048:  * must perform these checks here, and not eagerly during parsing, because a
62048:  * function's body may turn on strict mode for the function head.
62048:  */
62048: static bool
62048: CheckStrictParameters(JSContext *cx, JSTreeContext *tc)
62048: {
62048:     JS_ASSERT(tc->inFunction());
62048: 
62048:     if (!tc->needStrictChecks() || tc->bindings.countArgs() == 0)
35323:         return true;
35323: 
62048:     JSAtom *argumentsAtom = cx->runtime->atomState.argumentsAtom;
62048:     JSAtom *evalAtom = cx->runtime->atomState.evalAtom;
62048: 
62063:     /* name => whether we've warned about the name already */
62063:     HashMap<JSAtom *, bool> parameters(cx);
62048:     if (!parameters.init(tc->bindings.countArgs()))
35323:         return false;
62048: 
62048:     /* Start with lastVariable(), not lastArgument(), for destructuring. */
62048:     for (Shape::Range r = tc->bindings.lastVariable(); !r.empty(); r.popFront()) {
69637:         jsid id = r.front().propid;
62048:         if (!JSID_IS_ATOM(id))
62048:             continue;
62048: 
62048:         JSAtom *name = JSID_TO_ATOM(id);
62048: 
62048:         if (name == argumentsAtom || name == evalAtom) {
62048:             if (!ReportBadParameter(cx, tc, name, JSMSG_BAD_BINDING))
35325:                 return false;
35325:         }
62048: 
62048:         if (tc->inStrictMode() && FindKeyword(name->charsZ(), name->length())) {
62048:             /*
62048:              * JSOPTION_STRICT is supposed to warn about future keywords, too,
62048:              * but we took care of that in the scanner.
62048:              */
62048:             JS_ALWAYS_TRUE(!ReportBadParameter(cx, tc, name, JSMSG_RESERVED_ID));
62048:             return false;
62048:         }
62048: 
62063:         /*
62063:          * Check for a duplicate parameter: warn or report an error exactly
62063:          * once for each duplicated parameter.
62063:          */
62063:         if (HashMap<JSAtom *, bool>::AddPtr p = parameters.lookupForAdd(name)) {
62063:             if (!p->value && !ReportBadParameter(cx, tc, name, JSMSG_DUPLICATE_FORMAL))
62048:                 return false;
62063:             p->value = true;
62063:         } else {
62063:             if (!parameters.add(p, name, false))
62048:                 return false;
35325:         }
62063:     }
35323: 
35323:     return true;
35323: }
35323: 
40239: JSParseNode *
40860: Parser::functionBody()
    1: {
    1:     JSStmtInfo stmtInfo;
    1:     uintN oldflags, firstLine;
    1:     JSParseNode *pn;
    1: 
41884:     JS_ASSERT(tc->inFunction());
    1:     js_PushStatement(tc, &stmtInfo, STMT_BLOCK, -1);
    1:     stmtInfo.flags = SIF_BODY_BLOCK;
    1: 
    1:     oldflags = tc->flags;
    1:     tc->flags &= ~(TCF_RETURN_EXPR | TCF_RETURN_VOID);
    1: 
    1:     /*
    1:      * Save the body's first line, and store it in pn->pn_pos.begin.lineno
40239:      * later, because we may have not peeked in tokenStream yet, so statements
40239:      * won't acquire a valid pn->pn_pos.begin from the current token.
40239:      */
40270:     firstLine = tokenStream.getLineno();
 1967: #if JS_HAS_EXPR_CLOSURES
40270:     if (tokenStream.currentToken().type == TOK_LC) {
40263:         pn = statements();
 1967:     } else {
40232:         pn = UnaryNode::create(tc);
 1967:         if (pn) {
40263:             pn->pn_kid = assignExpr();
 1967:             if (!pn->pn_kid) {
 1967:                 pn = NULL;
 1967:             } else {
 1967:                 if (tc->flags & TCF_FUN_IS_GENERATOR) {
64214:                     ReportBadReturn(context, tc, pn, JSREPORT_ERROR,
 1967:                                     JSMSG_BAD_GENERATOR_RETURN,
 1967:                                     JSMSG_BAD_ANON_GENERATOR_RETURN);
 1967:                     pn = NULL;
 1967:                 } else {
 1967:                     pn->pn_type = TOK_RETURN;
 1967:                     pn->pn_op = JSOP_RETURN;
 1967:                     pn->pn_pos.end = pn->pn_kid->pn_pos.end;
 1967:                 }
 1967:             }
 1967:         }
 1967:     }
 1967: #else
40263:     pn = statements();
 1967: #endif
    1: 
10299:     if (pn) {
27012:         JS_ASSERT(!(tc->topStmt->flags & SIF_SCOPE));
    1:         js_PopStatement(tc);
10299:         pn->pn_pos.begin.lineno = firstLine;
    1: 
    1:         /* Check for falling off the end of a function that returns a value. */
61450:         if (context->hasStrictOption() && (tc->flags & TCF_RETURN_EXPR) &&
40239:             !CheckFinalReturn(context, tc, pn)) {
    1:             pn = NULL;
    1:         }
10299:     }
 8444: 
26827:     tc->flags = oldflags | (tc->flags & TCF_FUN_FLAGS);
    1:     return pn;
    1: }
    1: 
27012: static JSAtomListElement *
27012: MakePlaceholder(JSParseNode *pn, JSTreeContext *tc)
27012: {
40860:     JSAtomListElement *ale = tc->lexdeps.add(tc->parser, pn->pn_atom);
27012:     if (!ale)
27012:         return NULL;
27012: 
40232:     JSDefinition *dn = (JSDefinition *)NameNode::create(pn->pn_atom, tc);
27012:     if (!dn)
27012:         return NULL;
27012: 
27012:     ALE_SET_DEFN(ale, dn);
57762:     dn->pn_type = TOK_NAME;
57762:     dn->pn_op = JSOP_NOP;
27012:     dn->pn_defn = true;
28557:     dn->pn_dflags |= PND_PLACEHOLDER;
27012:     return ale;
27012: }
27012: 
27012: static bool
27012: Define(JSParseNode *pn, JSAtom *atom, JSTreeContext *tc, bool let = false)
27012: {
27012:     JS_ASSERT(!pn->pn_used);
27012:     JS_ASSERT_IF(pn->pn_defn, pn->isPlaceholder());
27012: 
27012:     JSHashEntry **hep;
27012:     JSAtomListElement *ale = NULL;
27012:     JSAtomList *list = NULL;
27012: 
27012:     if (let)
27012:         ale = (list = &tc->decls)->rawLookup(atom, hep);
27012:     if (!ale)
27012:         ale = (list = &tc->lexdeps)->rawLookup(atom, hep);
27012: 
27012:     if (ale) {
27012:         JSDefinition *dn = ALE_DEFN(ale);
27012:         if (dn != pn) {
27012:             JSParseNode **pnup = &dn->dn_uses;
27012:             JSParseNode *pnu;
27012:             uintN start = let ? pn->pn_blockid : tc->bodyid;
27012: 
27012:             while ((pnu = *pnup) != NULL && pnu->pn_blockid >= start) {
27012:                 JS_ASSERT(pnu->pn_used);
27012:                 pnu->pn_lexdef = (JSDefinition *) pn;
30457:                 pn->pn_dflags |= pnu->pn_dflags & PND_USE2DEF_FLAGS;
27012:                 pnup = &pnu->pn_link;
27012:             }
27012: 
27012:             if (pnu != dn->dn_uses) {
27012:                 *pnup = pn->dn_uses;
27012:                 pn->dn_uses = dn->dn_uses;
27012:                 dn->dn_uses = pnu;
27012: 
27371:                 if ((!pnu || pnu->pn_blockid < tc->bodyid) && list != &tc->decls)
40860:                     list->rawRemove(tc->parser, ale, hep);
40860:             }
40860:         }
40860:     }
40860: 
40860:     ale = tc->decls.add(tc->parser, atom, let ? JSAtomList::SHADOW : JSAtomList::UNIQUE);
27012:     if (!ale)
27012:         return false;
27012:     ALE_SET_DEFN(ale, pn);
27012:     pn->pn_defn = true;
27012:     pn->pn_dflags &= ~PND_PLACEHOLDER;
59228:     if (!tc->parent)
59228:         pn->pn_dflags |= PND_TOPLEVEL;
27012:     return true;
27012: }
27012: 
27012: static void
27012: LinkUseToDef(JSParseNode *pn, JSDefinition *dn, JSTreeContext *tc)
27012: {
27012:     JS_ASSERT(!pn->pn_used);
27012:     JS_ASSERT(!pn->pn_defn);
27012:     JS_ASSERT(pn != dn->dn_uses);
27012:     pn->pn_link = dn->dn_uses;
27012:     dn->dn_uses = pn;
33115:     dn->pn_dflags |= pn->pn_dflags & PND_USE2DEF_FLAGS;
27012:     pn->pn_used = true;
27012:     pn->pn_lexdef = dn;
27012: }
27012: 
27012: static void
27012: ForgetUse(JSParseNode *pn)
27012: {
27012:     if (!pn->pn_used) {
27012:         JS_ASSERT(!pn->pn_defn);
27012:         return;
27012:     }
27012: 
27012:     JSParseNode **pnup = &pn->lexdef()->dn_uses;
27012:     JSParseNode *pnu;
27012:     while ((pnu = *pnup) != pn)
27012:         pnup = &pnu->pn_link;
27012:     *pnup = pn->pn_link;
27012:     pn->pn_used = false;
27012: }
27012: 
27012: static JSParseNode *
27012: MakeAssignment(JSParseNode *pn, JSParseNode *rhs, JSTreeContext *tc)
27012: {
27012:     JSParseNode *lhs = NewOrRecycledNode(tc);
27012:     if (!lhs)
27012:         return NULL;
27012:     *lhs = *pn;
27012: 
27012:     if (pn->pn_used) {
27012:         JSDefinition *dn = pn->pn_lexdef;
27012:         JSParseNode **pnup = &dn->dn_uses;
27012: 
27012:         while (*pnup != pn)
27012:             pnup = &(*pnup)->pn_link;
27012:         *pnup = lhs;
27012:         lhs->pn_link = pn->pn_link;
27012:         pn->pn_link = NULL;
27012:     }
27012: 
27012:     pn->pn_type = TOK_ASSIGN;
27012:     pn->pn_op = JSOP_NOP;
27012:     pn->pn_arity = PN_BINARY;
31479:     pn->pn_parens = false;
27012:     pn->pn_used = pn->pn_defn = false;
27012:     pn->pn_left = lhs;
27012:     pn->pn_right = rhs;
27012:     return lhs;
27012: }
27012: 
27012: static JSParseNode *
27012: MakeDefIntoUse(JSDefinition *dn, JSParseNode *pn, JSAtom *atom, JSTreeContext *tc)
27012: {
27012:     /*
54840:      * If dn is arg, or in [var, const, let] and has an initializer, then we
54840:      * must rewrite it to be an assignment node, whose freshly allocated
54840:      * left-hand side becomes a use of pn.
27012:      */
27012:     if (dn->isBindingForm()) {
27012:         JSParseNode *rhs = dn->expr();
27012:         if (rhs) {
27012:             JSParseNode *lhs = MakeAssignment(dn, rhs, tc);
27012:             if (!lhs)
27012:                 return NULL;
27012:             //pn->dn_uses = lhs;
27012:             dn = (JSDefinition *) lhs;
27012:         }
27012: 
27012:         dn->pn_op = (js_CodeSpec[dn->pn_op].format & JOF_SET) ? JSOP_SETNAME : JSOP_NAME;
27012:     } else if (dn->kind() == JSDefinition::FUNCTION) {
27012:         JS_ASSERT(dn->pn_op == JSOP_NOP);
60789:         PrepareNodeForMutation(dn, tc);
27012:         dn->pn_type = TOK_NAME;
27012:         dn->pn_arity = PN_NAME;
27012:         dn->pn_atom = atom;
27012:     }
27012: 
27012:     /* Now make dn no longer a definition, rather a use of pn. */
27012:     JS_ASSERT(dn->pn_type == TOK_NAME);
27012:     JS_ASSERT(dn->pn_arity == PN_NAME);
27012:     JS_ASSERT(dn->pn_atom == atom);
27012: 
27012:     for (JSParseNode *pnu = dn->dn_uses; pnu; pnu = pnu->pn_link) {
27012:         JS_ASSERT(pnu->pn_used);
27012:         JS_ASSERT(!pnu->pn_defn);
27012:         pnu->pn_lexdef = (JSDefinition *) pn;
30457:         pn->pn_dflags |= pnu->pn_dflags & PND_USE2DEF_FLAGS;
30457:     }
30457:     pn->pn_dflags |= dn->pn_dflags & PND_USE2DEF_FLAGS;
27012:     pn->dn_uses = dn;
27012: 
27012:     dn->pn_defn = false;
27012:     dn->pn_used = true;
27012:     dn->pn_lexdef = (JSDefinition *) pn;
47573:     dn->pn_cookie.makeFree();
27012:     dn->pn_dflags &= ~PND_BOUND;
27012:     return dn;
27012: }
27012: 
27012: static bool
27012: DefineArg(JSParseNode *pn, JSAtom *atom, uintN i, JSTreeContext *tc)
27012: {
27012:     JSParseNode *argpn, *argsbody;
27012: 
27012:     /* Flag tc so we don't have to lookup arguments on every use. */
40860:     if (atom == tc->parser->context->runtime->atomState.argumentsAtom)
27012:         tc->flags |= TCF_FUN_PARAM_ARGUMENTS;
27012: 
27012:     /*
27012:      * Make an argument definition node, distinguished by being in tc->decls
27012:      * but having TOK_NAME type and JSOP_NOP op. Insert it in a TOK_ARGSBODY
27012:      * list node returned via pn->pn_body.
27012:      */
40232:     argpn = NameNode::create(atom, tc);
27012:     if (!argpn)
27012:         return false;
27012:     JS_ASSERT(PN_TYPE(argpn) == TOK_NAME && PN_OP(argpn) == JSOP_NOP);
27012: 
27012:     /* Arguments are initialized by definition. */
27012:     argpn->pn_dflags |= PND_INITIALIZED;
27012:     if (!Define(argpn, atom, tc))
27012:         return false;
27012: 
27012:     argsbody = pn->pn_body;
27012:     if (!argsbody) {
40232:         argsbody = ListNode::create(tc);
27012:         if (!argsbody)
27012:             return false;
27012:         argsbody->pn_type = TOK_ARGSBODY;
27012:         argsbody->pn_op = JSOP_NOP;
27012:         argsbody->makeEmpty();
27012:         pn->pn_body = argsbody;
27012:     }
27012:     argsbody->append(argpn);
27012: 
27012:     argpn->pn_op = JSOP_GETARG;
47573:     argpn->pn_cookie.set(tc->staticLevel, i);
27012:     argpn->pn_dflags |= PND_BOUND;
27012:     return true;
27012: }
27012: 
    1: /*
    1:  * Compile a JS function body, which might appear as the value of an event
    1:  * handler attribute in an HTML <INPUT> tag.
    1:  */
27012: bool
40860: Compiler::compileFunctionBody(JSContext *cx, JSFunction *fun, JSPrincipals *principals,
59968:                               Bindings *bindings, const jschar *chars, size_t length,
61450:                               const char *filename, uintN lineno, JSVersion version)
    1: {
40860:     Compiler compiler(cx, principals);
40860: 
61450:     if (!compiler.init(chars, length, filename, lineno, version))
27012:         return false;
27012: 
27012:     /* No early return from after here until the js_FinishArenaPool calls. */
    1:     JSArenaPool codePool, notePool;
71371:     JS_InitArenaPool(&codePool, "code", 1024, sizeof(jsbytecode));
71371:     JS_InitArenaPool(&notePool, "note", 1024, sizeof(jssrcnote));
27012: 
40860:     Parser &parser = compiler.parser;
40860:     TokenStream &tokenStream = parser.tokenStream;
40860: 
40860:     JSCodeGenerator funcg(&parser, &codePool, &notePool, tokenStream.getLineno());
41868:     if (!funcg.init())
64242:         return false;
41868: 
27012:     funcg.flags |= TCF_IN_FUNCTION;
57829:     funcg.setFunction(fun);
59968:     funcg.bindings.transfer(cx, bindings);
59968:     fun->setArgCount(funcg.bindings.countArgs());
27012:     if (!GenerateBlockId(&funcg, funcg.bodyid))
64242:         return false;
27012: 
27012:     /* FIXME: make Function format the source for a function definition. */
40860:     tokenStream.mungeCurrentToken(TOK_NAME);
40232:     JSParseNode *fn = FunctionNode::create(&funcg);
27012:     if (fn) {
27012:         fn->pn_body = NULL;
47573:         fn->pn_cookie.makeFree();
27012: 
27012:         uintN nargs = fun->nargs;
27012:         if (nargs) {
52503:             /*
52503:              * NB: do not use AutoLocalNameArray because it will release space
52503:              * allocated from cx->tempPool by DefineArg.
52503:              */
59968:             jsuword *names = funcg.bindings.getLocalNameArray(cx, &cx->tempPool);
27012:             if (!names) {
27012:                 fn = NULL;
27012:             } else {
27012:                 for (uintN i = 0; i < nargs; i++) {
27012:                     JSAtom *name = JS_LOCAL_NAME_TO_ATOM(names[i]);
27012:                     if (!DefineArg(fn, name, i, &funcg)) {
27012:                         fn = NULL;
27012:                         break;
27012:                     }
27012:                 }
27012:             }
27012:         }
27012:     }
    1: 
    1:     /*
    1:      * Farble the body so that it looks like a block statement to js_EmitTree,
27012:      * which is called from js_EmitFunctionBody (see jsemit.cpp).  After we're
27012:      * done parsing, we must fold constants, analyze any nested functions, and
27012:      * generate code for this function, including a stop opcode at the end.
27012:      */
40860:     tokenStream.mungeCurrentToken(TOK_LC);
40860:     JSParseNode *pn = fn ? parser.functionBody() : NULL;
    1:     if (pn) {
62048:         if (!CheckStrictParameters(cx, &funcg)) {
35323:             pn = NULL;
40860:         } else if (!tokenStream.matchToken(TOK_EOF)) {
42671:             parser.reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_SYNTAX_ERROR);
    1:             pn = NULL;
27012:         } else if (!js_FoldConstants(cx, pn, &funcg)) {
27012:             /* js_FoldConstants reported the error already. */
27012:             pn = NULL;
60788:         } else if (!parser.analyzeFunctions(&funcg)) {
27012:             pn = NULL;
26970:         } else {
27012:             if (fn->pn_body) {
27012:                 JS_ASSERT(PN_TYPE(fn->pn_body) == TOK_ARGSBODY);
27012:                 fn->pn_body->append(pn);
28816:                 fn->pn_body->pn_pos = pn->pn_pos;
27012:                 pn = fn->pn_body;
27012:             }
27012: 
27012:             if (!js_EmitFunctionScript(cx, &funcg, pn))
26968:                 pn = NULL;
26970:         }
    1:     }
    1: 
    1:     /* Restore saved state and release code generation arenas. */
47609:     JS_FinishArenaPool(&codePool);
47609:     JS_FinishArenaPool(&notePool);
    1:     return pn != NULL;
    1: }
    1: 
    1: /*
    1:  * Parameter block types for the several Binder functions.  We use a common
    1:  * helper function signature in order to share code among destructuring and
    1:  * simple variable declaration parsers.  In the destructuring case, the binder
    1:  * function is called indirectly from the variable declaration parser by way
    1:  * of CheckDestructuring and its friends.
    1:  */
    1: typedef JSBool
    1: (*Binder)(JSContext *cx, BindData *data, JSAtom *atom, JSTreeContext *tc);
    1: 
    1: struct BindData {
29379:     BindData() : fresh(true) {}
29379: 
27012:     JSParseNode     *pn;        /* name node for definition processing and
27012:                                    error source coordinates */
    1:     JSOp            op;         /* prolog bytecode or nop */
    1:     Binder          binder;     /* binder, discriminates u */
    1:     union {
    1:         struct {
    1:             uintN   overflow;
    1:         } let;
27012:     };
29379:     bool fresh;
    1: };
    1: 
59968: static bool
59968: BindLocalVariable(JSContext *cx, JSTreeContext *tc, JSAtom *atom, BindingKind kind, bool isArg)
59968: {
59968:     JS_ASSERT(kind == VARIABLE || kind == CONSTANT);
    1: 
    1:     /*
    1:      * Don't bind a variable with the hidden name 'arguments', per ECMA-262.
    1:      * Instead 'var arguments' always restates the predefined property of the
27012:      * activation objects whose name is 'arguments'. Assignment to such a
27012:      * variable must be handled specially.
35332:      *
35332:      * Special case: an argument named 'arguments' *does* shadow the predefined
35332:      * arguments property.
35332:      */
35332:     if (atom == cx->runtime->atomState.argumentsAtom && !isArg)
59968:         return true;
59968: 
59968:     return tc->bindings.add(cx, atom, kind);
    1: }
    1: 
    1: #if JS_HAS_DESTRUCTURING
    1: static JSBool
59968: BindDestructuringArg(JSContext *cx, BindData *data, JSAtom *atom, JSTreeContext *tc)
    1: {
29009:     /* Flag tc so we don't have to lookup arguments on every use. */
40860:     if (atom == tc->parser->context->runtime->atomState.argumentsAtom)
29009:         tc->flags |= TCF_FUN_PARAM_ARGUMENTS;
29009: 
41884:     JS_ASSERT(tc->inFunction());
27012: 
59968:     /*
59968:      * NB: Check tc->decls rather than tc->bindings, because destructuring
59968:      *     bindings aren't added to tc->bindings until after all arguments have
59968:      *     been parsed.
59968:      */
59952:     if (tc->decls.lookup(atom)) {
40860:         ReportCompileErrorNumber(cx, TS(tc->parser), NULL, JSREPORT_ERROR,
40320:                                  JSMSG_DESTRUCT_DUP_ARG);
    1:         return JS_FALSE;
    1:     }
59952: 
59955:     JSParseNode *pn = data->pn;
59955: 
59952:     /*
59952:      * Distinguish destructured-to binding nodes as vars, not args, by setting
59952:      * pn_op to JSOP_SETLOCAL. Parser::functionDef checks for this pn_op value
59952:      * when processing the destructuring-assignment AST prelude induced by such
59952:      * destructuring args in Parser::functionArguments.
59955:      *
59955:      * We must set the PND_BOUND flag too to prevent pn_op from being reset to
59955:      * JSOP_SETNAME by BindDestructuringVar. The only field not initialized is
59955:      * pn_cookie; it gets set in functionDef in the first "if (prelude)" block.
59957:      * We have to wait to set the cookie until we can call JSFunction::addLocal
59957:      * with kind = JSLOCAL_VAR, after all JSLOCAL_ARG locals have been added.
59957:      *
59957:      * Thus a destructuring formal parameter binds an ARG (as in arguments[i]
59957:      * element) with a null atom name for the object or array passed in to be
59957:      * destructured, and zero or more VARs (as in named local variables) for
59957:      * the destructured-to identifiers in the property value positions within
59957:      * the object or array destructuring pattern, and all ARGs for the formal
59957:      * parameter list bound as locals before any VAR for a destructured name.
59955:      */
59955:     pn->pn_op = JSOP_SETLOCAL;
59955:     pn->pn_dflags |= PND_BOUND;
59955: 
59955:     return Define(pn, atom, tc);
    1: }
    1: #endif /* JS_HAS_DESTRUCTURING */
    1: 
27012: JSFunction *
40860: Parser::newFunction(JSTreeContext *tc, JSAtom *atom, uintN lambda)
 8444: {
 8444:     JSObject *parent;
13702:     JSFunction *fun;
 9481: 
 9481:     JS_ASSERT((lambda & ~JSFUN_LAMBDA) == 0);
27012: 
27012:     /*
27012:      * Find the global compilation context in order to pre-set the newborn
27012:      * function's parent slot to tc->scopeChain. If the global context is a
27012:      * compile-and-go one, we leave the pre-set parent intact; otherwise we
27012:      * clear parent and proto.
27012:      */
27012:     while (tc->parent)
27012:         tc = tc->parent;
57829:     parent = tc->inFunction() ? NULL : tc->scopeChain();
57829: 
57829:     fun = js_NewFunction(context, NULL, NULL, 0, JSFUN_INTERPRETED | lambda, parent, atom);
41884:     if (fun && !tc->compileAndGo()) {
39930:         FUN_OBJECT(fun)->clearParent();
39928:         FUN_OBJECT(fun)->clearProto();
13691:     }
13691:     return fun;
 8444: }
 8444: 
25110: static JSBool
40320: MatchOrInsertSemicolon(JSContext *cx, TokenStream *ts)
40320: {
40854:     TokenKind tt = ts->peekTokenSameLine(TSF_OPERAND);
25110:     if (tt == TOK_ERROR)
25110:         return JS_FALSE;
25110:     if (tt != TOK_EOF && tt != TOK_EOL && tt != TOK_SEMI && tt != TOK_RC) {
54158:         /* Advance the scanner for proper error location reporting. */
54158:         ts->getToken(TSF_OPERAND);
40320:         ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR, JSMSG_SEMI_BEFORE_STMNT);
25110:         return JS_FALSE;
25110:     }
40354:     (void) ts->matchToken(TOK_SEMI);
25110:     return JS_TRUE;
25110: }
25110: 
27012: bool
60788: Parser::analyzeFunctions(JSTreeContext *tc)
60788: {
60789:     cleanFunctionList(&tc->functionList);
60788:     if (!tc->functionList)
60788:         return true;
60788:     if (!markFunArgs(tc->functionList))
27012:         return false;
64296:     markExtensibleScopeDescendants(tc->functionList, false);
60788:     setFunctionKinds(tc->functionList, &tc->flags);
27012:     return true;
27012: }
27012: 
27012: /*
27012:  * Mark as funargs any functions that reach up to one or more upvars across an
27012:  * already-known funarg. The parser will flag the o_m lambda as a funarg in:
27012:  *
27012:  *   function f(o, p) {
27012:  *       o.m = function o_m(a) {
27012:  *           function g() { return p; }
27012:  *           function h() { return a; }
27012:  *           return g() + h();
27012:  *       }
27012:  *   }
27012:  *
27012:  * but without this extra marking phase, function g will not be marked as a
27012:  * funarg since it is called from within its parent scope. But g reaches up to
27012:  * f's parameter p, so if o_m escapes f's activation scope, g does too and
60254:  * cannot assume that p's stack slot is still alive. In contast function h
60254:  * neither escapes nor uses an upvar "above" o_m's level.
27012:  *
27012:  * If function g itself contained lambdas that contained non-lambdas that reach
27012:  * up above its level, then those non-lambdas would have to be marked too. This
27012:  * process is potentially exponential in the number of functions, but generally
27012:  * not so complex. But it can't be done during a single recursive traversal of
27012:  * the funbox tree, so we must use a work queue.
28952:  *
28952:  * Return the minimal "skipmin" for funbox and its siblings. This is the delta
28952:  * between the static level of the bodies of funbox and its peers (which must
28952:  * be funbox->level + 1), and the static level of the nearest upvar among all
28952:  * the upvars contained by funbox and its peers. If there are no upvars, return
28952:  * FREE_STATIC_LEVEL. Thus this function never returns 0.
28952:  */
28952: static uintN
27012: FindFunArgs(JSFunctionBox *funbox, int level, JSFunctionBoxQueue *queue)
27012: {
47573:     uintN allskipmin = UpvarCookie::FREE_LEVEL;
28952: 
27012:     do {
27012:         JSParseNode *fn = funbox->node;
60789:         JS_ASSERT(fn->pn_arity == PN_FUNC);
64294:         JSFunction *fun = funbox->function();
27012:         int fnlevel = level;
27012: 
27109:         /*
27109:          * An eval can leak funbox, functions along its ancestor line, and its
27109:          * immediate kids. Since FindFunArgs uses DFS and the parser propagates
27109:          * TCF_FUN_HEAVYWEIGHT bottom up, funbox's ancestor function nodes have
27109:          * already been marked as funargs by this point. Therefore we have to
27109:          * flag only funbox->node and funbox->kids' nodes here.
62365:          *
62365:          * Generators need to be treated in the same way. Even if the value
62365:          * of a generator function doesn't escape, anything defined or referred
62365:          * to inside the generator can escape through a call to the generator.
62365:          * We could imagine doing static analysis to track the calls and see
62365:          * if any iterators or values returned by iterators escape, but that
62365:          * would be hard, so instead we just assume everything might escape.
62365:          */
62365:         if (funbox->tcflags & (TCF_FUN_HEAVYWEIGHT | TCF_FUN_IS_GENERATOR)) {
27111:             fn->setFunArg();
27109:             for (JSFunctionBox *kid = funbox->kids; kid; kid = kid->siblings)
27111:                 kid->node->setFunArg();
27109:         }
27109: 
28952:         /*
28952:          * Compute in skipmin the least distance from fun's static level up to
28952:          * an upvar, whether used directly by fun, or indirectly by a function
28952:          * nested in fun.
28952:          */
47573:         uintN skipmin = UpvarCookie::FREE_LEVEL;
28952:         JSParseNode *pn = fn->pn_body;
28952: 
28952:         if (pn->pn_type == TOK_UPVARS) {
28952:             JSAtomList upvars(pn->pn_names);
28952:             JS_ASSERT(upvars.count != 0);
28952: 
28952:             JSAtomListIterator iter(&upvars);
28952:             JSAtomListElement *ale;
28952: 
28952:             while ((ale = iter()) != NULL) {
28952:                 JSDefinition *lexdep = ALE_DEFN(ale)->resolve();
28952: 
28952:                 if (!lexdep->isFreeVar()) {
28952:                     uintN upvarLevel = lexdep->frameLevel();
28952: 
28952:                     if (int(upvarLevel) <= fnlevel)
28952:                         fn->setFunArg();
28952: 
28952:                     uintN skip = (funbox->level + 1) - upvarLevel;
28952:                     if (skip < skipmin)
28952:                         skipmin = skip;
28952:                 }
28952:             }
28952:         }
28952: 
28952:         /*
28952:          * If this function escapes, whether directly (the parser detects such
28952:          * escapes) or indirectly (because this non-escaping function uses an
28952:          * upvar that reaches across an outer function boundary where the outer
28952:          * function escapes), enqueue it for further analysis, and bump fnlevel
28952:          * to trap any non-escaping children.
28952:          */
27012:         if (fn->isFunArg()) {
27012:             queue->push(funbox);
27012:             fnlevel = int(funbox->level);
28952:         }
28952: 
28952:         /*
28952:          * Now process the current function's children, and recalibrate their
28952:          * cumulative skipmin to be relative to the current static level.
28952:          */
28952:         if (funbox->kids) {
28952:             uintN kidskipmin = FindFunArgs(funbox->kids, fnlevel, queue);
28952: 
28952:             JS_ASSERT(kidskipmin != 0);
47573:             if (kidskipmin != UpvarCookie::FREE_LEVEL) {
28952:                 --kidskipmin;
28952:                 if (kidskipmin != 0 && kidskipmin < skipmin)
28952:                     skipmin = kidskipmin;
28952:             }
28952:         }
28952: 
28952:         /*
28952:          * Finally, after we've traversed all of the current function's kids,
28952:          * minimize fun's skipmin against our accumulated skipmin. Do likewise
28952:          * with allskipmin, but minimize across funbox and all of its siblings,
28952:          * to compute our return value.
28952:          */
47573:         if (skipmin != UpvarCookie::FREE_LEVEL) {
28952:             fun->u.i.skipmin = skipmin;
28952:             if (skipmin < allskipmin)
28952:                 allskipmin = skipmin;
28952:         }
27012:     } while ((funbox = funbox->siblings) != NULL);
28952: 
28952:     return allskipmin;
27012: }
27012: 
27012: bool
60788: Parser::markFunArgs(JSFunctionBox *funbox)
27012: {
27012:     JSFunctionBoxQueue queue;
71686:     if (!queue.init(functionCount)) {
71686:         js_ReportOutOfMemory(context);
27012:         return false;
71686:     }
27012: 
27012:     FindFunArgs(funbox, -1, &queue);
27012:     while ((funbox = queue.pull()) != NULL) {
27012:         JSParseNode *fn = funbox->node;
27012:         JS_ASSERT(fn->isFunArg());
27012: 
27012:         JSParseNode *pn = fn->pn_body;
27012:         if (pn->pn_type == TOK_UPVARS) {
27012:             JSAtomList upvars(pn->pn_names);
27012:             JS_ASSERT(upvars.count != 0);
27012: 
27012:             JSAtomListIterator iter(&upvars);
27012:             JSAtomListElement *ale;
27012: 
27012:             while ((ale = iter()) != NULL) {
27012:                 JSDefinition *lexdep = ALE_DEFN(ale)->resolve();
27012: 
27012:                 if (!lexdep->isFreeVar() &&
27012:                     !lexdep->isFunArg() &&
38597:                     (lexdep->kind() == JSDefinition::FUNCTION ||
38597:                      PN_OP(lexdep) == JSOP_CALLEE)) {
27012:                     /*
28952:                      * Mark this formerly-Algol-like function as an escaping
60254:                      * function (i.e., as a funarg), because it is used from
60254:                      * another funarg.
27012:                      *
28952:                      * Progress is guaranteed because we set the funarg flag
28952:                      * here, which suppresses revisiting this function (thanks
28952:                      * to the !lexdep->isFunArg() test just above).
27012:                      */
27111:                     lexdep->setFunArg();
27012: 
38597:                     JSFunctionBox *afunbox;
38597:                     if (PN_OP(lexdep) == JSOP_CALLEE) {
38597:                         /*
38597:                          * A named function expression will not appear to be a
38597:                          * funarg if it is immediately applied. However, if its
38597:                          * name is used in an escaping function nested within
38597:                          * it, then it must become flagged as a funarg again.
38597:                          * See bug 545980.
38597:                          */
38597:                         afunbox = funbox;
47573:                         uintN calleeLevel = lexdep->pn_cookie.level();
38597:                         uintN staticLevel = afunbox->level + 1U;
38597:                         while (staticLevel != calleeLevel) {
38597:                             afunbox = afunbox->parent;
38597:                             --staticLevel;
38597:                         }
57762:                         JS_ASSERT(afunbox->level + 1U == calleeLevel);
38597:                         afunbox->node->setFunArg();
38597:                     } else {
38597:                        afunbox = lexdep->pn_funbox;
38597:                     }
27012:                     queue.push(afunbox);
27012: 
27012:                     /*
27012:                      * Walk over nested functions again, now that we have
27012:                      * changed the level across which it is unsafe to access
27012:                      * upvars using the runtime dynamic link (frame chain).
27012:                      */
27012:                     if (afunbox->kids)
27012:                         FindFunArgs(afunbox->kids, afunbox->level, &queue);
27012:                 }
27012:             }
27012:         }
27012:     }
27012:     return true;
27012: }
27012: 
27012: static uint32
27012: MinBlockId(JSParseNode *fn, uint32 id)
27012: {
27012:     if (fn->pn_blockid < id)
27012:         return false;
27012:     if (fn->pn_defn) {
27012:         for (JSParseNode *pn = fn->dn_uses; pn; pn = pn->pn_link) {
27012:             if (pn->pn_blockid < id)
27012:                 return false;
27012:         }
27012:     }
27012:     return true;
27012: }
27012: 
38549: static inline bool
38549: CanFlattenUpvar(JSDefinition *dn, JSFunctionBox *funbox, uint32 tcflags)
38549: {
38549:     /*
38549:      * Consider the current function (the lambda, innermost below) using a var
38549:      * x defined two static levels up:
27012:      *
27012:      *  function f() {
27012:      *      // z = g();
27012:      *      var x = 42;
27012:      *      function g() {
27012:      *          return function () { return x; };
27012:      *      }
27012:      *      return g();
27012:      *  }
27012:      *
38549:      * So long as (1) the initialization in 'var x = 42' dominates all uses of
38549:      * g and (2) x is not reassigned, it is safe to optimize the lambda to a
38549:      * flat closure. Uncommenting the early call to g makes this optimization
38549:      * unsafe (z could name a global setter that calls its argument).
27012:      */
27012:     JSFunctionBox *afunbox = funbox;
38549:     uintN dnLevel = dn->frameLevel();
38549: 
38549:     JS_ASSERT(dnLevel <= funbox->level);
38549:     while (afunbox->level != dnLevel) {
27012:         afunbox = afunbox->parent;
27012: 
27012:         /*
38549:          * NB: afunbox can't be null because we are sure to find a function box
38549:          * whose level == dnLevel before we would try to walk above the root of
38549:          * the funbox tree. See bug 493260 comments 16-18.
38549:          *
38549:          * Assert but check anyway, to protect future changes that bind eval
38549:          * upvars in the parser.
28740:          */
28740:         JS_ASSERT(afunbox);
28740: 
28740:         /*
38549:          * If this function is reaching up across an enclosing funarg, then we
38549:          * cannot copy dn's value into a flat closure slot (the display stops
38549:          * working once the funarg escapes).
28740:          */
28740:         if (!afunbox || afunbox->node->isFunArg())
38549:             return false;
41861: 
41861:         /*
41861:          * Reaching up for dn across a generator also means we can't flatten,
41861:          * since the generator iterator does not run until later, in general.
41861:          * See bug 563034.
41861:          */
41861:         if (afunbox->tcflags & TCF_FUN_IS_GENERATOR)
41861:             return false;
38549:     }
38549: 
38549:     /*
38549:      * If afunbox's function (which is at the same level as dn) is in a loop,
38549:      * pessimistically assume the variable initializer may be in the same loop.
38549:      * A flat closure would then be unsafe, as the captured variable could be
38549:      * assigned after the closure is created. See bug 493232.
28814:      */
28814:     if (afunbox->inLoop)
38549:         return false;
38549: 
38549:     /*
38549:      * |with| and eval used as an operator defeat lexical scoping: they can be
38549:      * used to assign to any in-scope variable. Therefore they must disable
38549:      * flat closures that use such upvars.  The parser detects these as special
38549:      * forms and marks the function heavyweight.
38549:      */
38549:     if ((afunbox->parent ? afunbox->parent->tcflags : tcflags) & TCF_FUN_HEAVYWEIGHT)
38549:         return false;
38549: 
38549:     /*
38549:      * If afunbox's function is not a lambda, it will be hoisted, so it could
38549:      * capture the undefined value that by default initializes var, let, and
38549:      * const bindings. And if dn is a function that comes at (meaning a
38549:      * function refers to its own name) or strictly after afunbox, we also
38549:      * defeat the flat closure optimization for this dn.
27012:      */
64294:     JSFunction *afun = afunbox->function();
27012:     if (!(afun->flags & JSFUN_LAMBDA)) {
38549:         if (dn->isBindingForm() || dn->pn_pos >= afunbox->node->pn_pos)
38549:             return false;
38549:     }
38549: 
38549:     if (!dn->isInitialized())
38549:         return false;
38549: 
38549:     JSDefinition::Kind dnKind = dn->kind();
38549:     if (dnKind != JSDefinition::CONST) {
38549:         if (dn->isAssigned())
38549:             return false;
38549: 
38549:         /*
38549:          * Any formal could be mutated behind our back via the arguments
38549:          * object, so deoptimize if the outer function uses arguments.
38549:          *
38549:          * In a Function constructor call where the final argument -- the body
38549:          * source for the function to create -- contains a nested function
38549:          * definition or expression, afunbox->parent will be null. The body
38549:          * source might use |arguments| outside of any nested functions it may
38549:          * contain, so we have to check the tcflags parameter that was passed
40860:          * in from Compiler::compileFunctionBody.
38549:          */
38549:         if (dnKind == JSDefinition::ARG &&
38549:             ((afunbox->parent ? afunbox->parent->tcflags : tcflags) & TCF_FUN_USES_ARGUMENTS)) {
38549:             return false;
38549:         }
38549:     }
38549: 
38549:     /*
38549:      * Check quick-and-dirty dominance relation. Function definitions dominate
38549:      * their uses thanks to hoisting.  Other binding forms hoist as undefined,
38549:      * of course, so check forward-reference and blockid relations.
38549:      */
38549:     if (dnKind != JSDefinition::FUNCTION) {
27012:         /*
27012:          * Watch out for code such as
27012:          *
27012:          *   (function () {
27012:          *   ...
27012:          *   var jQuery = ... = function (...) {
27012:          *       return new jQuery.foo.bar(baz);
27012:          *   }
27012:          *   ...
27012:          *   })();
27012:          *
38549:          * where the jQuery variable is not reassigned, but of course is not
38549:          * initialized at the time that the would-be-flat closure containing
38549:          * the jQuery upvar is formed.
38549:          */
38560:         if (dn->pn_pos.end >= afunbox->node->pn_pos.end)
38549:             return false;
38560:         if (!MinBlockId(afunbox->node, dn->pn_blockid))
38560:             return false;
38549:     }
38549:     return true;
38549: }
38549: 
38549: static void
60788: FlagHeavyweights(JSDefinition *dn, JSFunctionBox *funbox, uint32 *tcflags)
38549: {
38549:     uintN dnLevel = dn->frameLevel();
38549: 
41849:     while ((funbox = funbox->parent) != NULL) {
41849:         /*
41849:          * Notice that funbox->level is the static level of the definition or
41849:          * expression of the function parsed into funbox, not the static level
38549:          * of its body. Therefore we must add 1 to match dn's level to find the
41849:          * funbox whose body contains the dn definition.
41849:          */
41849:         if (funbox->level + 1U == dnLevel || (dnLevel == 0 && dn->isLet())) {
41849:             funbox->tcflags |= TCF_FUN_HEAVYWEIGHT;
41849:             break;
41849:         }
41849:         funbox->tcflags |= TCF_FUN_ENTRAINS_SCOPES;
41849:     }
41849: 
60788:     if (!funbox && (*tcflags & TCF_IN_FUNCTION))
60788:         *tcflags |= TCF_FUN_HEAVYWEIGHT;
38549: }
38549: 
52554: static bool
52554: DeoptimizeUsesWithin(JSDefinition *dn, const TokenPos &pos)
38549: {
38549:     uintN ndeoptimized = 0;
38563: 
38563:     for (JSParseNode *pnu = dn->dn_uses; pnu; pnu = pnu->pn_link) {
38549:         JS_ASSERT(pnu->pn_used);
38549:         JS_ASSERT(!pnu->pn_defn);
38563:         if (pnu->pn_pos.begin >= pos.begin && pnu->pn_pos.end <= pos.end) {
38549:             pnu->pn_dflags |= PND_DEOPTIMIZED;
38549:             ++ndeoptimized;
38563:         }
38549:     }
38549: 
52554:     return ndeoptimized != 0;
38549: }
38549: 
38549: void
60788: Parser::setFunctionKinds(JSFunctionBox *funbox, uint32 *tcflags)
38549: {
38549:     for (;;) {
38549:         JSParseNode *fn = funbox->node;
38549:         JSParseNode *pn = fn->pn_body;
38549: 
38549:         if (funbox->kids) {
38549:             setFunctionKinds(funbox->kids, tcflags);
38549: 
38549:             /*
38549:              * We've unwound from recursively setting our kids' kinds, which
38549:              * also classifies enclosing functions holding upvars referenced in
38549:              * those descendants' bodies. So now we can check our "methods".
38549:              *
52503:              * Despecialize from branded method-identity-based shape to shape-
38549:              * or slot-based shape if this function smells like a constructor
38549:              * and too many of its methods are *not* joinable null closures
38549:              * (i.e., they have one or more upvars fetched via the display).
38549:              */
38549:             JSParseNode *pn2 = pn;
38549:             if (PN_TYPE(pn2) == TOK_UPVARS)
38549:                 pn2 = pn2->pn_tree;
38549:             if (PN_TYPE(pn2) == TOK_ARGSBODY)
38549:                 pn2 = pn2->last();
38549: 
38549: #if JS_HAS_EXPR_CLOSURES
38549:             if (PN_TYPE(pn2) == TOK_LC)
38549: #endif
38549:             if (!(funbox->tcflags & TCF_RETURN_EXPR)) {
38549:                 uintN methodSets = 0, slowMethodSets = 0;
38549: 
38549:                 for (JSParseNode *method = funbox->methods; method; method = method->pn_link) {
38549:                     JS_ASSERT(PN_OP(method) == JSOP_LAMBDA || PN_OP(method) == JSOP_LAMBDA_FC);
38549:                     ++methodSets;
38549:                     if (!method->pn_funbox->joinable())
38549:                         ++slowMethodSets;
38549:                 }
38549: 
38549:                 if (funbox->shouldUnbrand(methodSets, slowMethodSets))
38549:                     funbox->tcflags |= TCF_FUN_UNBRAND_THIS;
38549:             }
38549:         }
38549: 
64294:         JSFunction *fun = funbox->function();
38549: 
60539:         JS_ASSERT(FUN_KIND(fun) == JSFUN_INTERPRETED);
41849: 
38549:         if (funbox->tcflags & TCF_FUN_HEAVYWEIGHT) {
72559:             /* nothing to do */
61210:         } else if (funbox->inAnyDynamicScope()) {
61210:             JS_ASSERT(!FUN_NULL_CLOSURE(fun));
38549:         } else if (pn->pn_type != TOK_UPVARS) {
38549:             /*
38549:              * No lexical dependencies => null closure, for best performance.
38549:              * A null closure needs no scope chain, but alas we've coupled
38549:              * principals-finding to scope (for good fundamental reasons, but
38549:              * the implementation overloads the parent slot and we should fix
38549:              * that). See, e.g., the JSOP_LAMBDA case in jsinterp.cpp.
38549:              *
38549:              * In more detail: the ES3 spec allows the implementation to create
38549:              * "joined function objects", or not, at its discretion. But real-
38549:              * world implementations always create unique function objects for
38549:              * closures, and this can be detected via mutation. Open question:
38549:              * do popular implementations create unique function objects for
38549:              * null closures?
38549:              *
38549:              * FIXME: bug 476950.
38549:              */
38549:             FUN_SET_KIND(fun, JSFUN_NULL_CLOSURE);
38549:         } else {
38549:             JSAtomList upvars(pn->pn_names);
38549:             JS_ASSERT(upvars.count != 0);
38549: 
38549:             JSAtomListIterator iter(&upvars);
38549:             JSAtomListElement *ale;
38549: 
38549:             if (!fn->isFunArg()) {
38549:                 /*
60254:                  * This function is Algol-like, it never escapes.
60254:                  *
38549:                  * Check that at least one outer lexical binding was assigned
38549:                  * to (global variables don't count). This is conservative: we
38549:                  * could limit assignments to those in the current function,
38549:                  * but that's too much work. As with flat closures (handled
38549:                  * below), we optimize for the case where outer bindings are
38549:                  * not reassigned anywhere.
38549:                  */
38549:                 while ((ale = iter()) != NULL) {
38549:                     JSDefinition *lexdep = ALE_DEFN(ale)->resolve();
38549: 
38549:                     if (!lexdep->isFreeVar()) {
40887:                         JS_ASSERT(lexdep->frameLevel() <= funbox->level);
60254:                         break;
60254:                     }
60254:                 }
60254: 
72559:                 if (!ale)
27012:                     FUN_SET_KIND(fun, JSFUN_NULL_CLOSURE);
38549:             } else {
38549:                 uintN nupvars = 0, nflattened = 0;
38549: 
38549:                 /*
38549:                  * For each lexical dependency from this closure to an outer
38549:                  * binding, analyze whether it is safe to copy the binding's
38549:                  * value into a flat closure slot when the closure is formed.
38549:                  */
38549:                 while ((ale = iter()) != NULL) {
38549:                     JSDefinition *lexdep = ALE_DEFN(ale)->resolve();
38549: 
38549:                     if (!lexdep->isFreeVar()) {
38549:                         ++nupvars;
60788:                         if (CanFlattenUpvar(lexdep, funbox, *tcflags)) {
38549:                             ++nflattened;
38549:                             continue;
38549:                         }
60547: 
60547:                         /*
60547:                          * FIXME bug 545759: to test nflattened != 0 instead of
60547:                          * nflattened == nupvars below, we'll need to avoid n^2
60547:                          * bugs such as 617430 in uncommenting the following:
60547:                          *
60547:                          * if (DeoptimizeUsesWithin(lexdep, funbox->node->pn_body->pn_pos))
60547:                          *     FlagHeavyweights(lexdep, funbox, tcflags);
60547:                          *
60547:                          * For now it's best to avoid this tedious, use-wise
60547:                          * deoptimization and let fun remain an unoptimized
60547:                          * closure. This is safe because we leave fun's kind
60547:                          * set to interpreted, so all functions holding its
60547:                          * upvars will be flagged as heavyweight.
60547:                          */
38549:                     }
38549:                 }
38549: 
38549:                 if (nupvars == 0) {
38549:                     FUN_SET_KIND(fun, JSFUN_NULL_CLOSURE);
39787:                 } else if (nflattened == nupvars) {
27012:                     /*
27012:                      * We made it all the way through the upvar loop, so it's
27012:                      * safe to optimize to a flat closure.
27012:                      */
27012:                     FUN_SET_KIND(fun, JSFUN_FLAT_CLOSURE);
27012:                     switch (PN_OP(fn)) {
27012:                       case JSOP_DEFFUN:
27012:                         fn->pn_op = JSOP_DEFFUN_FC;
27012:                         break;
27012:                       case JSOP_DEFLOCALFUN:
27012:                         fn->pn_op = JSOP_DEFLOCALFUN_FC;
27012:                         break;
27012:                       case JSOP_LAMBDA:
27012:                         fn->pn_op = JSOP_LAMBDA_FC;
27012:                         break;
27012:                       default:
27012:                         /* js_EmitTree's case TOK_FUNCTION: will select op. */
27012:                         JS_ASSERT(PN_OP(fn) == JSOP_NOP);
27012:                     }
27012:                 }
27012:             }
27012:         }
27012: 
60539:         if (FUN_KIND(fun) == JSFUN_INTERPRETED && pn->pn_type == TOK_UPVARS) {
27012:             /*
27012:              * One or more upvars cannot be safely snapshot into a flat
52503:              * closure's non-reserved slot (see JSOP_GETFCSLOT), so we loop
52503:              * again over all upvars, and for each non-free upvar, ensure that
52503:              * its containing function has been flagged as heavyweight.
27012:              *
27012:              * The emitter must see TCF_FUN_HEAVYWEIGHT accurately before
27012:              * generating any code for a tree of nested functions.
27012:              */
37685:             JSAtomList upvars(pn->pn_names);
37685:             JS_ASSERT(upvars.count != 0);
37685: 
37685:             JSAtomListIterator iter(&upvars);
37685:             JSAtomListElement *ale;
37685: 
27012:             while ((ale = iter()) != NULL) {
27012:                 JSDefinition *lexdep = ALE_DEFN(ale)->resolve();
38549:                 if (!lexdep->isFreeVar())
38549:                     FlagHeavyweights(lexdep, funbox, tcflags);
27012:             }
27012:         }
27012: 
48676:         if (funbox->joinable())
48676:             fun->setJoinable();
48676: 
27012:         funbox = funbox->siblings;
27012:         if (!funbox)
27012:             break;
37685:     }
27012: }
27012: 
64296: /*
64296:  * Walk the JSFunctionBox tree looking for functions whose call objects may
64296:  * acquire new bindings as they execute: non-strict functions that call eval,
64296:  * and functions that contain function statements (definitions not appearing
64296:  * within the top statement list, which don't take effect unless they are
64296:  * evaluated). Such call objects may acquire bindings that shadow variables
64296:  * defined in enclosing scopes, so any enclosed functions must have their
64296:  * bindings' extensibleParents flags set, and enclosed compiler-created blocks
64296:  * must have their OWN_SHAPE flags set; the comments for
64296:  * js::Bindings::extensibleParents explain why.
64296:  */
64296: void
64296: Parser::markExtensibleScopeDescendants(JSFunctionBox *funbox, bool hasExtensibleParent) 
64296: {
64296:     for (; funbox; funbox = funbox->siblings) {
64296:         /*
64296:          * It would be nice to use FUN_KIND(fun) here to recognize functions
64296:          * that will never consult their parent chains, and thus don't need
64296:          * their 'extensible parents' flag set. Filed as bug 619750. 
64296:          */
64296: 
64296:         JS_ASSERT(!funbox->bindings.extensibleParents());
64296:         if (hasExtensibleParent)
64296:             funbox->bindings.setExtensibleParents();
64296: 
64296:         if (funbox->kids) {
64296:             markExtensibleScopeDescendants(funbox->kids,
64296:                                            hasExtensibleParent || funbox->scopeIsExtensible());
64296:         }
64296:     }
64296: }
64296: 
27012: const char js_argument_str[] = "argument";
27012: const char js_variable_str[] = "variable";
27012: const char js_unknown_str[]  = "unknown";
27012: 
27012: const char *
27012: JSDefinition::kindString(Kind kind)
27012: {
27012:     static const char *table[] = {
27012:         js_var_str, js_const_str, js_let_str,
27012:         js_function_str, js_argument_str, js_unknown_str
27012:     };
27012: 
27012:     JS_ASSERT(unsigned(kind) <= unsigned(ARG));
27012:     return table[kind];
27012: }
27012: 
27012: static JSFunctionBox *
40263: EnterFunction(JSParseNode *fn, JSTreeContext *funtc, JSAtom *funAtom = NULL,
40263:               uintN lambda = JSFUN_LAMBDA)
40263: {
40263:     JSTreeContext *tc = funtc->parent;
40860:     JSFunction *fun = tc->parser->newFunction(tc, funAtom, lambda);
27012:     if (!fun)
27012:         return NULL;
27012: 
27012:     /* Create box for fun->object early to protect against last-ditch GC. */
40860:     JSFunctionBox *funbox = tc->parser->newFunctionBox(FUN_OBJECT(fun), fn, tc);
27012:     if (!funbox)
27012:         return NULL;
27012: 
27012:     /* Initialize non-default members of funtc. */
27012:     funtc->flags |= funbox->tcflags;
27012:     funtc->blockidGen = tc->blockidGen;
27012:     if (!GenerateBlockId(funtc, funtc->bodyid))
27012:         return NULL;
57829:     funtc->setFunction(fun);
27012:     funtc->funbox = funbox;
27012:     if (!SetStaticLevel(funtc, tc->staticLevel + 1))
27012:         return NULL;
27012: 
27012:     return funbox;
27012: }
27012: 
27012: static bool
40263: LeaveFunction(JSParseNode *fn, JSTreeContext *funtc, JSAtom *funAtom = NULL,
40263:               uintN lambda = JSFUN_LAMBDA)
40263: {
40263:     JSTreeContext *tc = funtc->parent;
27012:     tc->blockidGen = funtc->blockidGen;
27012: 
37685:     JSFunctionBox *funbox = fn->pn_funbox;
37685:     funbox->tcflags |= funtc->flags & (TCF_FUN_FLAGS | TCF_COMPILE_N_GO | TCF_RETURN_EXPR);
27012: 
27012:     fn->pn_dflags |= PND_INITIALIZED;
27012:     if (!tc->topStmt || tc->topStmt->type == STMT_BLOCK)
27012:         fn->pn_dflags |= PND_BLOCKCHILD;
27012: 
27012:     /*
27012:      * Propagate unresolved lexical names up to tc->lexdeps, and save a copy
27371:      * of funtc->lexdeps in a TOK_UPVARS node wrapping the function's formal
27371:      * params and body. We do this only if there are lexical dependencies not
27371:      * satisfied by the function's declarations, to avoid penalizing functions
27371:      * that use only their arguments and other local bindings.
27012:      */
27012:     if (funtc->lexdeps.count != 0) {
27012:         JSAtomListIterator iter(&funtc->lexdeps);
27012:         JSAtomListElement *ale;
27371:         int foundCallee = 0;
27012: 
27012:         while ((ale = iter()) != NULL) {
27012:             JSAtom *atom = ALE_ATOM(ale);
27012:             JSDefinition *dn = ALE_DEFN(ale);
27012:             JS_ASSERT(dn->isPlaceholder());
27012: 
27012:             if (atom == funAtom && lambda != 0) {
27012:                 dn->pn_op = JSOP_CALLEE;
47573:                 dn->pn_cookie.set(funtc->staticLevel, UpvarCookie::CALLEE_SLOT);
27012:                 dn->pn_dflags |= PND_BOUND;
27052: 
27052:                 /*
27052:                  * If this named function expression uses its own name other
32658:                  * than to call itself, flag this function specially.
27052:                  */
27052:                 if (dn->isFunArg())
37685:                     funbox->tcflags |= TCF_FUN_USES_OWN_NAME;
27371:                 foundCallee = 1;
27012:                 continue;
27012:             }
27012: 
37685:             if (!(funbox->tcflags & TCF_FUN_SETS_OUTER_NAME) &&
27012:                 dn->isAssigned()) {
27012:                 /*
27012:                  * Make sure we do not fail to set TCF_FUN_SETS_OUTER_NAME if
27012:                  * any use of dn in funtc assigns. See NoteLValue for the easy
27012:                  * backward-reference case; this is the hard forward-reference
27012:                  * case where we pay a higher price.
27012:                  */
27012:                 for (JSParseNode *pnu = dn->dn_uses; pnu; pnu = pnu->pn_link) {
27012:                     if (pnu->isAssigned() && pnu->pn_blockid >= funtc->bodyid) {
37685:                         funbox->tcflags |= TCF_FUN_SETS_OUTER_NAME;
27012:                         break;
27012:                     }
27012:                 }
27012:             }
27012: 
27371:             JSAtomListElement *outer_ale = tc->decls.lookup(atom);
52554: 
52554:             /*
52554:              * Make sure to deoptimize lexical dependencies that are polluted
60547:              * by eval or with, to safely bind globals (see bug 561923).
52554:              */
54840:             if (funtc->callsEval() ||
52554:                 (outer_ale && tc->innermostWith &&
52554:                  ALE_DEFN(outer_ale)->pn_pos < tc->innermostWith->pn_pos)) {
52554:                 DeoptimizeUsesWithin(dn, fn->pn_pos);
52554:             }
52554: 
27371:             if (!outer_ale)
27371:                 outer_ale = tc->lexdeps.lookup(atom);
57762:             if (!outer_ale) {
57762:                 /* 
57762:                  * Create a new placeholder for our outer lexdep. We could simply re-use
57762:                  * the inner placeholder, but that introduces subtleties in the case where
57762:                  * we find a later definition that captures an existing lexdep. For
57762:                  * example:
57762:                  *
57762:                  *   function f() { function g() { x; } let x; }
57762:                  *
57762:                  * Here, g's TOK_UPVARS node lists the placeholder for x, which must be
57762:                  * captured by the 'let' declaration later, since 'let's are hoisted.
57762:                  * Taking g's placeholder as our own would work fine. But consider:
57762:                  *
57762:                  *   function f() { x; { function g() { x; } let x; } }
57762:                  *
57762:                  * Here, the 'let' must not capture all the uses of f's lexdep entry for
57762:                  * x, but it must capture the x node referred to from g's TOK_UPVARS node.
57762:                  * Always turning inherited lexdeps into uses of a new outer definition
57762:                  * allows us to handle both these cases in a natural way.
57762:                  */
57762:                 outer_ale = MakePlaceholder(dn, tc);
71687:                 if (!outer_ale)
71687:                     return false;
71687:             }
71687: 
57762: 
57762:             JSDefinition *outer_dn = ALE_DEFN(outer_ale);
57762: 
27012:             /*
27012:              * Insert dn's uses list at the front of outer_dn's list.
27012:              *
27012:              * Without loss of generality or correctness, we allow a dn to
27012:              * be in inner and outer lexdeps, since the purpose of lexdeps
27012:              * is one-pass coordination of name use and definition across
27012:              * functions, and if different dn's are used we'll merge lists
27012:              * when leaving the inner function.
27012:              *
27012:              * The dn == outer_dn case arises with generator expressions
27012:              * (see CompExprTransplanter::transplant, the PN_FUNC/PN_NAME
27012:              * case), and nowhere else, currently.
27012:              */
27012:             if (dn != outer_dn) {
27012:                 JSParseNode **pnup = &dn->dn_uses;
27012:                 JSParseNode *pnu;
27012: 
27012:                 while ((pnu = *pnup) != NULL) {
27012:                     pnu->pn_lexdef = outer_dn;
27012:                     pnup = &pnu->pn_link;
27012:                 }
27012: 
27012:                 /*
27012:                  * Make dn be a use that redirects to outer_dn, because we
27012:                  * can't replace dn with outer_dn in all the pn_namesets in
27012:                  * the AST where it may be. Instead we make it forward to
27012:                  * outer_dn. See JSDefinition::resolve.
27012:                  */
27012:                 *pnup = outer_dn->dn_uses;
27012:                 outer_dn->dn_uses = dn;
28557:                 outer_dn->pn_dflags |= dn->pn_dflags & ~PND_PLACEHOLDER;
27012:                 dn->pn_defn = false;
27012:                 dn->pn_used = true;
27012:                 dn->pn_lexdef = outer_dn;
57762:             }
52878: 
52878:             /* Mark the outer dn as escaping. */
52878:             outer_dn->pn_dflags |= PND_CLOSED;
27012:         }
27012: 
27371:         if (funtc->lexdeps.count - foundCallee != 0) {
27012:             JSParseNode *body = fn->pn_body;
27012: 
40232:             fn->pn_body = NameSetNode::create(tc);
27012:             if (!fn->pn_body)
27012:                 return false;
27371: 
27012:             fn->pn_body->pn_type = TOK_UPVARS;
27109:             fn->pn_body->pn_pos = body->pn_pos;
27371:             if (foundCallee)
40860:                 funtc->lexdeps.remove(tc->parser, funAtom);
27371:             fn->pn_body->pn_names = funtc->lexdeps;
27012:             fn->pn_body->pn_tree = body;
27371:         }
27371: 
27371:         funtc->lexdeps.clear();
27012:     }
27012: 
51096:     /*
51096:      * Check whether any parameters have been assigned within this function.
51096:      * In strict mode parameters do not alias arguments[i], and to make the
51096:      * arguments object reflect initial parameter values prior to any mutation
51096:      * we create it eagerly whenever parameters are (or might, in the case of
51096:      * calls to eval) be assigned.
51096:      */
51096:     if (funtc->inStrictMode() && funbox->object->getFunctionPrivate()->nargs > 0) {
51096:         JSAtomListIterator iter(&funtc->decls);
51096:         JSAtomListElement *ale;
51096: 
51096:         while ((ale = iter()) != NULL) {
51096:             JSDefinition *dn = ALE_DEFN(ale);
51096:             if (dn->kind() == JSDefinition::ARG && dn->isAssigned()) {
51096:                 funbox->tcflags |= TCF_FUN_MUTATES_PARAMETER;
51096:                 break;
51096:             }
51096:         }
51096:     }
51096: 
59968:     funbox->bindings.transfer(funtc->parser->context, &funtc->bindings);
59968: 
27012:     return true;
27012: }
27012: 
52818: static bool
52818: DefineGlobal(JSParseNode *pn, JSCodeGenerator *cg, JSAtom *atom);
52818: 
59952: /*
59952:  * FIXME? this Parser method was factored from Parser::functionDef with minimal
59968:  * change, hence the funtc ref param and funbox. It probably should match
59968:  * functionBody, etc., and use tc and tc->funbox instead of taking explicit
59968:  * parameters.
59952:  */
51088: bool
59968: Parser::functionArguments(JSTreeContext &funtc, JSFunctionBox *funbox, JSParseNode **listp)
51088: {
51088:     if (tokenStream.getToken() != TOK_LP) {
51088:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_PAREN_BEFORE_FORMAL);
51088:         return false;
51088:     }
51088: 
51088:     if (!tokenStream.matchToken(TOK_RP)) {
51088: #if JS_HAS_DESTRUCTURING
51088:         JSAtom *duplicatedArg = NULL;
51088:         bool destructuringArg = false;
51088:         JSParseNode *list = NULL;
51088: #endif
52503: 
51088:         do {
51088:             switch (TokenKind tt = tokenStream.getToken()) {
51088: #if JS_HAS_DESTRUCTURING
51088:               case TOK_LB:
51088:               case TOK_LC:
51088:               {
51088:                 /* See comment below in the TOK_NAME case. */
51088:                 if (duplicatedArg)
51088:                     goto report_dup_and_destructuring;
51088:                 destructuringArg = true;
51088: 
51088:                 /*
51088:                  * A destructuring formal parameter turns into one or more
51088:                  * local variables initialized from properties of a single
51088:                  * anonymous positional parameter, so here we must tweak our
51088:                  * binder and its data.
51088:                  */
51088:                 BindData data;
51088:                 data.pn = NULL;
51088:                 data.op = JSOP_DEFVAR;
51088:                 data.binder = BindDestructuringArg;
51088:                 JSParseNode *lhs = destructuringExpr(&data, tt);
51088:                 if (!lhs)
51088:                     return false;
51088: 
51088:                 /*
51088:                  * Adjust fun->nargs to count the single anonymous positional
51088:                  * parameter that is to be destructured.
51088:                  */
59968:                 uint16 slot;
59968:                 if (!funtc.bindings.addDestructuring(context, &slot))
51088:                     return false;
51088: 
51088:                 /*
51088:                  * Synthesize a destructuring assignment from the single
51088:                  * anonymous positional parameter into the destructuring
51088:                  * left-hand-side expression and accumulate it in list.
51088:                  */
51088:                 JSParseNode *rhs = NameNode::create(context->runtime->atomState.emptyAtom, &funtc);
51088:                 if (!rhs)
51088:                     return false;
51088:                 rhs->pn_type = TOK_NAME;
51088:                 rhs->pn_op = JSOP_GETARG;
59952:                 rhs->pn_cookie.set(funtc.staticLevel, slot);
51088:                 rhs->pn_dflags |= PND_BOUND;
51088: 
52503:                 JSParseNode *item =
52503:                     JSParseNode::newBinaryOrAppend(TOK_ASSIGN, JSOP_NOP, lhs, rhs, &funtc);
51088:                 if (!item)
51088:                     return false;
51088:                 if (!list) {
51088:                     list = ListNode::create(&funtc);
51088:                     if (!list)
51088:                         return false;
54840:                     list->pn_type = TOK_VAR;
51088:                     list->makeEmpty();
51088:                     *listp = list;
51088:                 }
51088:                 list->append(item);
51088:                 break;
51088:               }
51088: #endif /* JS_HAS_DESTRUCTURING */
51088: 
51088:               case TOK_NAME:
51088:               {
51088:                 JSAtom *atom = tokenStream.currentToken().t_atom;
59952: 
51088: #ifdef JS_HAS_DESTRUCTURING
51088:                 /*
59968:                  * ECMA-262 requires us to support duplicate parameter names,
59968:                  * but if the parameter list includes destructuring, we
59968:                  * consider the code to have "opted in" to higher standards and
59968:                  * forbid duplicates. We may see a destructuring parameter
59968:                  * later, so always note duplicates now.
59968:                  *
59968:                  * Duplicates are warned about (strict option) or cause errors
59968:                  * (strict mode code), but we do those tests in one place
59968:                  * below, after having parsed the body in case it begins with a
59968:                  * "use strict"; directive.
59968:                  *
59968:                  * NB: Check funtc.decls rather than funtc.bindings, because
59968:                  *     destructuring bindings aren't added to funtc.bindings
59968:                  *     until after all arguments have been parsed.
52503:                  */
59952:                 if (funtc.decls.lookup(atom)) {
51088:                     duplicatedArg = atom;
51088:                     if (destructuringArg)
51088:                         goto report_dup_and_destructuring;
51088:                 }
51088: #endif
59952: 
59968:                 uint16 slot;
59968:                 if (!funtc.bindings.addArgument(context, atom, &slot))
59952:                     return false;
59968:                 if (!DefineArg(funbox->node, atom, slot, &funtc))
51088:                     return false;
51088:                 break;
51088:               }
51088: 
51088:               default:
51088:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_MISSING_FORMAL);
51088:                 /* FALL THROUGH */
51088:               case TOK_ERROR:
51088:                 return false;
51088: 
51088: #if JS_HAS_DESTRUCTURING
51088:               report_dup_and_destructuring:
51088:                 JSDefinition *dn = ALE_DEFN(funtc.decls.lookup(duplicatedArg));
51088:                 reportErrorNumber(dn, JSREPORT_ERROR, JSMSG_DESTRUCT_DUP_ARG);
51088:                 return false;
51088: #endif
51088:             }
51088:         } while (tokenStream.matchToken(TOK_COMMA));
51088: 
51088:         if (tokenStream.getToken() != TOK_RP) {
51088:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_PAREN_AFTER_FORMAL);
51088:             return false;
51088:         }
51088:     }
51088: 
51088:     return true;
51088: }
51088: 
40239: JSParseNode *
51089: Parser::functionDef(JSAtom *funAtom, FunctionType type, uintN lambda)
40855: {
    1:     /* Make a TOK_FUNCTION node. */
51087:     tokenStream.mungeCurrentToken(TOK_FUNCTION, JSOP_NOP);
51085:     JSParseNode *pn = FunctionNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
27012:     pn->pn_body = NULL;
47573:     pn->pn_cookie.makeFree();
27012: 
27012:     /*
60254:      * If a lambda, mark this function as escaping (as a "funarg") unless it is
60254:      * immediately applied (we clear PND_FUNARG if so -- see memberExpr).
27012:      *
59229:      * Treat function sub-statements (non-lambda, non-body-level functions) as
59229:      * escaping funargs, since we can't statically analyze their definitions
27012:      * and uses.
27012:      */
59229:     bool bodyLevel = tc->atBodyLevel();
59229:     pn->pn_dflags = (lambda || !bodyLevel) ? PND_FUNARG : 0;
    1: 
    1:     /*
    1:      * Record names for function statements in tc->decls so we know when to
    1:      * avoid optimizing variable references that might name a function.
    1:      */
 9481:     if (lambda == 0 && funAtom) {
51085:         if (JSAtomListElement *ale = tc->decls.lookup(funAtom)) {
27012:             JSDefinition *dn = ALE_DEFN(ale);
27012:             JSDefinition::Kind dn_kind = dn->kind();
27012: 
27012:             JS_ASSERT(!dn->pn_used);
27012:             JS_ASSERT(dn->pn_defn);
27012: 
61450:             if (context->hasStrictOption() || dn_kind == JSDefinition::CONST) {
57812:                 JSAutoByteString name;
57812:                 if (!js_AtomToPrintableString(context, funAtom, &name) ||
42671:                     !reportErrorNumber(NULL,
27012:                                        (dn_kind != JSDefinition::CONST)
27012:                                        ? JSREPORT_WARNING | JSREPORT_STRICT
 7984:                                        : JSREPORT_ERROR,
    1:                                        JSMSG_REDECLARED_VAR,
27012:                                        JSDefinition::kindString(dn_kind),
57812:                                        name.ptr())) {
    1:                     return NULL;
    1:                 }
    1:             }
27012: 
59229:             if (bodyLevel) {
27012:                 ALE_SET_DEFN(ale, pn);
27012:                 pn->pn_defn = true;
27012:                 pn->dn_uses = dn;               /* dn->dn_uses is now pn_link */
27012: 
27012:                 if (!MakeDefIntoUse(dn, pn, funAtom, tc))
27012:                     return NULL;
27012:             }
59229:         } else if (bodyLevel) {
27012:             /*
27012:              * If this function was used before it was defined, claim the
40239:              * pre-created definition node for this function that primaryExpr
27012:              * put in tc->lexdeps on first forward reference, and recycle pn.
27012:              */
27012:             JSHashEntry **hep;
27012: 
27012:             ale = tc->lexdeps.rawLookup(funAtom, hep);
27012:             if (ale) {
27012:                 JSDefinition *fn = ALE_DEFN(ale);
27012: 
27012:                 JS_ASSERT(fn->pn_defn);
27012:                 fn->pn_type = TOK_FUNCTION;
27012:                 fn->pn_arity = PN_FUNC;
27012:                 fn->pn_pos.begin = pn->pn_pos.begin;
64260: 
64260:                 /*
64260:                  * Set fn->pn_pos.end too, in case of error before we parse the
64260:                  * closing brace.  See bug 640075.
64260:                  */
64260:                 fn->pn_pos.end = pn->pn_pos.end;
64260: 
27012:                 fn->pn_body = NULL;
47573:                 fn->pn_cookie.makeFree();
27012: 
40860:                 tc->lexdeps.rawRemove(tc->parser, ale, hep);
27012:                 RecycleTree(pn, tc);
27012:                 pn = fn;
27012:             }
27012: 
27012:             if (!Define(pn, funAtom, tc))
27012:                 return NULL;
27012:         }
    1: 
    1:         /*
59228:          * A function directly inside another's body needs only a local
59228:          * variable to bind its name to its value, and not an activation object
59228:          * property (it might also need the activation property, if the outer
59228:          * function contains with statements, e.g., but the stack slot wins
59228:          * when jsemit.cpp's BindNameToSlot can optimize a JSOP_NAME into a
16429:          * JSOP_GETLOCAL bytecode).
    1:          */
59229:         if (bodyLevel && tc->inFunction()) {
27012:             /*
27012:              * Define a local in the outer function so that BindNameToSlot
27012:              * can properly optimize accesses. Note that we need a local
27012:              * variable, not an argument, for the function statement. Thus
27012:              * we add a variable even if a parameter with the given name
27012:              * already exists.
27012:              */
59228:             uintN index;
59992:             switch (tc->bindings.lookup(context, funAtom, &index)) {
59968:               case NONE:
59968:               case ARGUMENT:
59968:                 index = tc->bindings.countVars();
59968:                 if (!tc->bindings.addVariable(context, funAtom))
27012:                     return NULL;
27012:                 /* FALL THROUGH */
27012: 
59968:               case VARIABLE:
47573:                 pn->pn_cookie.set(tc->staticLevel, index);
27012:                 pn->pn_dflags |= PND_BOUND;
27012:                 break;
27012: 
27012:               default:;
27012:             }
27012:         }
27012:     }
27012: 
40263:     JSTreeContext *outertc = tc;
40263: 
40239:     /* Initialize early for possible flags mutation via destructuringExpr. */
40860:     JSTreeContext funtc(tc->parser);
27012: 
40263:     JSFunctionBox *funbox = EnterFunction(pn, &funtc, funAtom, lambda);
27012:     if (!funbox)
27012:         return NULL;
27012: 
64294:     JSFunction *fun = funbox->function();
 8179: 
    1:     /* Now parse formal argument list and compute fun->nargs. */
59952:     JSParseNode *prelude = NULL;
59968:     if (!functionArguments(funtc, funbox, &prelude))
59968:         return NULL;
59968: 
59968:     fun->setArgCount(funtc.bindings.countArgs());
59952: 
59952: #if JS_HAS_DESTRUCTURING
59952:     /*
59952:      * If there were destructuring formal parameters, bind the destructured-to
59952:      * local variables now that we've parsed all the regular and destructuring
59968:      * formal parameters. Because js::Bindings::add must be called first for
59968:      * all ARGUMENTs, then all VARIABLEs and CONSTANTs, and finally all UPVARs,
59968:      * we can't bind vars induced by formal parameter destructuring until after
59968:      * Parser::functionArguments has returned.
59952:      */
59952:     if (prelude) {
59952:         JSAtomListIterator iter(&funtc.decls);
59952: 
59952:         while (JSAtomListElement *ale = iter()) {
59952:             JSParseNode *apn = ALE_DEFN(ale);
59952: 
59952:             /* Filter based on pn_op -- see BindDestructuringArg, above. */
59952:             if (apn->pn_op != JSOP_SETLOCAL)
59952:                 continue;
59952: 
59968:             uint16 index = funtc.bindings.countVars();
59968:             if (!BindLocalVariable(context, &funtc, apn->pn_atom, VARIABLE, true))
59952:                 return NULL;
59952:             apn->pn_cookie.set(funtc.staticLevel, index);
59952:         }
59952:     }
59952: #endif
    1: 
51089:     if (type == GETTER && fun->nargs > 0) {
51089:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_ACCESSOR_WRONG_ARGS,
51089:                           "getter", "no", "s");
51089:         return NULL;
51089:     }
51089:     if (type == SETTER && fun->nargs != 1) {
51089:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_ACCESSOR_WRONG_ARGS,
51089:                           "setter", "one", "");
51089:         return NULL;
51089:     }
51089: 
 1967: #if JS_HAS_EXPR_CLOSURES
51085:     TokenKind tt = tokenStream.getToken(TSF_OPERAND);
 1967:     if (tt != TOK_LC) {
40354:         tokenStream.ungetToken();
 1967:         fun->flags |= JSFUN_EXPR_CLOSURE;
 1967:     }
 1967: #else
    1:     MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_BODY);
 1967: #endif
    1: 
51085:     JSParseNode *body = functionBody();
    1:     if (!body)
    1:         return NULL;
    1: 
62048:     if (funAtom && !CheckStrictBinding(context, &funtc, funAtom, pn))
62048:         return NULL;
62048: 
62048:     if (!CheckStrictParameters(context, &funtc))
35323:         return NULL;
35323: 
 1967: #if JS_HAS_EXPR_CLOSURES
 1967:     if (tt == TOK_LC)
    1:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_BODY);
40239:     else if (lambda == 0 && !MatchOrInsertSemicolon(context, &tokenStream))
25110:         return NULL;
 1967: #else
 1967:     MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_BODY);
 1967: #endif
40270:     pn->pn_pos.end = tokenStream.currentToken().pos.end;
    1: 
51097:     /*
53520:      * Fruit of the poisonous tree: if a closure calls eval, we consider the
53520:      * parent to call eval. We need this for two reasons: (1) the Jaegermonkey
53520:      * optimizations really need to know if eval is called transitively, and
53520:      * (2) in strict mode, eval called transitively requires eager argument
53520:      * creation in strict mode parent functions. 
53520:      *
53520:      * For the latter, we really only need to propagate callsEval if both 
53520:      * functions are strict mode, but we don't lose much by always propagating. 
53520:      * The only optimization we lose this way is in the case where a function 
53520:      * is strict, does not mutate arguments, does not call eval directly, but
53520:      * calls eval transitively.
53520:      */
51097:     if (funtc.callsEval())
51097:         outertc->noteCallsEval();
51097: 
    1: #if JS_HAS_DESTRUCTURING
    1:     /*
    1:      * If there were destructuring formal parameters, prepend the initializing
51110:      * comma expression that we synthesized to body. If the body is a return
51110:      * node, we must make a special TOK_SEQ node, to prepend the destructuring
51110:      * code without bracing the decompilation of the function body.
    1:      */
59952:     if (prelude) {
    1:         if (body->pn_arity != PN_LIST) {
    1:             JSParseNode *block;
    1: 
40263:             block = ListNode::create(outertc);
    1:             if (!block)
    1:                 return NULL;
20413:             block->pn_type = TOK_SEQ;
    1:             block->pn_pos = body->pn_pos;
27012:             block->initList(body);
    1: 
    1:             body = block;
    1:         }
    1: 
51085:         JSParseNode *item = UnaryNode::create(outertc);
    1:         if (!item)
    1:             return NULL;
    1: 
    1:         item->pn_type = TOK_SEMI;
    1:         item->pn_pos.begin = item->pn_pos.end = body->pn_pos.begin;
59952:         item->pn_kid = prelude;
    1:         item->pn_next = body->pn_head;
    1:         body->pn_head = item;
    1:         if (body->pn_tail == &body->pn_head)
    1:             body->pn_tail = &item->pn_next;
    1:         ++body->pn_count;
27012:         body->pn_xflags |= PNX_DESTRUCT;
    1:     }
    1: #endif
    1: 
    1:     /*
    1:      * If we collected flags that indicate nested heavyweight functions, or
27012:      * this function contains heavyweight-making statements (with statement,
27012:      * visible eval call, or assignment to 'arguments'), flag the function as
27012:      * heavyweight (requiring a call object per invocation).
    1:      */
    1:     if (funtc.flags & TCF_FUN_HEAVYWEIGHT) {
    1:         fun->flags |= JSFUN_HEAVYWEIGHT;
40263:         outertc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:     } else {
    1:         /*
59229:          * If this function is not at body level of a program or function (i.e.
59229:          * it is a function statement that is not a direct child of a program
59229:          * or function), then our enclosing function, if any, must be
59229:          * heavyweight.
59229:          */
59229:         if (!bodyLevel && lambda == 0 && funAtom)
40263:             outertc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:     }
    1: 
51085:     JSParseNode *result = pn;
51086:     JSOp op = JSOP_NOP;
 9481:     if (lambda != 0) {
    1:         /*
    1:          * ECMA ed. 3 standard: function expression, possibly anonymous.
    1:          */
27012:         op = JSOP_LAMBDA;
    1:     } else if (!funAtom) {
    1:         /*
    1:          * If this anonymous function definition is *not* embedded within a
    1:          * larger expression, we treat it as an expression statement, not as
    1:          * a function declaration -- and not as a syntax error (as ECMA-262
 1967:          * Edition 3 would have it).  Backward compatibility must trump all,
 1967:          * unless JSOPTION_ANONFUNFIX is set.
    1:          */
40263:         result = UnaryNode::create(outertc);
    1:         if (!result)
    1:             return NULL;
    1:         result->pn_type = TOK_SEMI;
    1:         result->pn_pos = pn->pn_pos;
    1:         result->pn_kid = pn;
27012:         op = JSOP_LAMBDA;
59229:     } else if (!bodyLevel) {
    1:         /*
    1:          * ECMA ed. 3 extension: a function expression statement not at the
    1:          * top level, e.g., in a compound statement such as the "then" part
    1:          * of an "if" statement, binds a closure only if control reaches that
    1:          * sub-statement.
    1:          */
18965:         op = JSOP_DEFFUN;
58291:         outertc->noteMightAliasLocals();
    1:     }
    1: 
27012:     funbox->kids = funtc.functionList;
27012: 
27012:     pn->pn_funbox = funbox;
    1:     pn->pn_op = op;
28816:     if (pn->pn_body) {
27012:         pn->pn_body->append(body);
28816:         pn->pn_body->pn_pos = body->pn_pos;
28816:     } else {
    1:         pn->pn_body = body;
28816:     }
27012: 
59229:     if (!outertc->inFunction() && bodyLevel && funAtom && !lambda && outertc->compiling()) {
53081:         JS_ASSERT(pn->pn_cookie.isFree());
59218:         if (!DefineGlobal(pn, outertc->asCodeGenerator(), funAtom))
68902:             return NULL;
52818:     }
52818: 
40263:     pn->pn_blockid = outertc->blockid();
40263: 
40263:     if (!LeaveFunction(pn, &funtc, funAtom, lambda))
27012:         return NULL;
27012: 
35113:     /* If the surrounding function is not strict code, reset the lexer. */
51096:     if (!outertc->inStrictMode())
40854:         tokenStream.setStrictMode(false);
35113: 
    1:     return result;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::functionStmt()
40263: {
51087:     JSAtom *name = NULL;
51087:     if (tokenStream.getToken(TSF_KEYWORD_IS_NAME) == TOK_NAME) {
51087:         name = tokenStream.currentToken().t_atom;
51087:     } else {
61450:         if (hasAnonFunFix()) {
51087:             /* Extension: accept unnamed function expressions as statements. */
51087:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_SYNTAX_ERROR);
51087:             return NULL;
51087:         }
51087:         tokenStream.ungetToken();
51087:     }
60253: 
60253:     /* We forbid function statements in strict mode code. */
60253:     if (!tc->atBodyLevel() && tc->inStrictMode()) {
60253:         reportErrorNumber(NULL, JSREPORT_STRICT_MODE_ERROR, JSMSG_STRICT_FUNCTION_STATEMENT);
60253:         return NULL;
60253:     }
60253: 
51089:     return functionDef(name, GENERAL, 0);
40239: }
40239: 
40239: JSParseNode *
40860: Parser::functionExpr()
40263: {
51087:     JSAtom *name = NULL;
51087:     if (tokenStream.getToken(TSF_KEYWORD_IS_NAME) == TOK_NAME)
51087:         name = tokenStream.currentToken().t_atom;
51087:     else
51087:         tokenStream.ungetToken();
51089:     return functionDef(name, GENERAL, JSFUN_LAMBDA);
    1: }
    1: 
    1: /*
60792:  * Recognize Directive Prologue members and directives. Assuming |pn| is a
60792:  * candidate for membership in a directive prologue, recognize directives and
60792:  * set |tc|'s flags accordingly. If |pn| is indeed part of a prologue, set its
60792:  * |pn_prologue| flag.
35113:  *
35113:  * Note that the following is a strict mode function:
35113:  *
35113:  * function foo() {
35113:  *   "blah" // inserted semi colon
35113:  *        "blurgh"
35113:  *   "use\x20loose"
35113:  *   "use strict"
35113:  * }
35113:  *
60792:  * That is, even though "use\x20loose" can never be a directive, now or in the
60792:  * future (because of the hex escape), the Directive Prologue extends through it
60792:  * to the "use strict" statement, which is indeed a directive.
35113:  */
40239: bool
59219: Parser::recognizeDirectivePrologue(JSParseNode *pn, bool *isDirectivePrologueMember)
59219: {
60792:     *isDirectivePrologueMember = pn->isStringExprStatement();
59219:     if (!*isDirectivePrologueMember)
59219:         return true;
60792: 
60792:     JSParseNode *kid = pn->pn_kid;
60792:     if (kid->isEscapeFreeStringLiteral()) {
60792:         /*
60792:          * Mark this statement as being a possibly legitimate part of a
60792:          * directive prologue, so the byte code emitter won't warn about it
60792:          * being useless code. (We mustn't just omit the statement entirely yet,
60792:          * as it could be producing the value of an eval or JSScript execution.)
60792:          *
60792:          * Note that even if the string isn't one we recognize as a directive,
60792:          * the emitter still shouldn't flag it as useless, as it could become a
60792:          * directive in the future. We don't want to interfere with people
60792:          * taking advantage of directive-prologue-enabled features that appear
60792:          * in other browsers first.
60792:          */
60792:         pn->pn_prologue = true;
60792: 
60792:         JSAtom *directive = kid->pn_atom;
40239:         if (directive == context->runtime->atomState.useStrictAtom) {
59219:             /*
59219:              * Unfortunately, Directive Prologue members in general may contain
59219:              * escapes, even while "use strict" directives may not.  Therefore
59219:              * we must check whether an octal character escape has been seen in
59219:              * any previous directives whenever we encounter a "use strict"
59219:              * directive, so that the octal escape is properly treated as a
59219:              * syntax error.  An example of this case:
59219:              *
59219:              *   function error()
59219:              *   {
59219:              *     "\145"; // octal escape
59219:              *     "use strict"; // retroactively makes "\145" a syntax error
59219:              *   }
59219:              */
59219:             if (tokenStream.hasOctalCharacterEscape()) {
59219:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_DEPRECATED_OCTAL);
59219:                 return false;
59219:             }
59219: 
35113:             tc->flags |= TCF_STRICT_MODE_CODE;
40854:             tokenStream.setStrictMode();
35113:         }
35113:     }
35113:     return true;
35113: }
35113: 
35113: /*
    1:  * Parse the statements in a block, creating a TOK_LC node that lists the
    1:  * statements' trees.  If called from block-parsing code, the caller must
    1:  * match { before and } after.
    1:  */
40239: JSParseNode *
40860: Parser::statements()
    1: {
    1:     JSParseNode *pn, *pn2, *saveBlock;
40320:     TokenKind tt;
    1: 
40239:     JS_CHECK_RECURSION(context, return NULL);
40221: 
40232:     pn = ListNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
27012:     pn->pn_type = TOK_LC;
27012:     pn->makeEmpty();
27012:     pn->pn_blockid = tc->blockid();
    1:     saveBlock = tc->blockNode;
    1:     tc->blockNode = pn;
    1: 
59229:     bool inDirectivePrologue = tc->atBodyLevel();
59219:     tokenStream.setOctalCharacterEscape(false);
 9604:     for (;;) {
40854:         tt = tokenStream.peekToken(TSF_OPERAND);
10466:         if (tt <= TOK_EOF || tt == TOK_RC) {
24241:             if (tt == TOK_ERROR) {
40854:                 if (tokenStream.isEOF())
40854:                     tokenStream.setUnexpectedEOF();
40239:                 return NULL;
40239:             }
40239:             break;
40239:         }
40263:         pn2 = statement();
    1:         if (!pn2) {
40854:             if (tokenStream.isEOF())
40854:                 tokenStream.setUnexpectedEOF();
    1:             return NULL;
    1:         }
    1: 
59219:         if (inDirectivePrologue && !recognizeDirectivePrologue(pn2, &inDirectivePrologue))
59219:             return NULL;
35113: 
10466:         if (pn2->pn_type == TOK_FUNCTION) {
10466:             /*
59229:              * PNX_FUNCDEFS notifies the emitter that the block contains body-
10466:              * level function definitions that should be processed before the
10466:              * rest of nodes.
10466:              *
10466:              * TCF_HAS_FUNCTION_STMT is for the TOK_LC case in Statement. It
59229:              * is relevant only for function definitions not at body-level,
10466:              * which we call function statements.
10466:              */
59229:             if (tc->atBodyLevel())
27012:                 pn->pn_xflags |= PNX_FUNCDEFS;
64296:             else {
    1:                 tc->flags |= TCF_HAS_FUNCTION_STMT;
64296:                 /* Function statements extend the Call object at runtime. */
64296:                 tc->noteHasExtensibleScope();
64296:             }
10466:         }
27012:         pn->append(pn2);
    1:     }
    1: 
    1:     /*
    1:      * Handle the case where there was a let declaration under this block.  If
    1:      * it replaced tc->blockNode with a new block node then we must refresh pn
    1:      * and then restore tc->blockNode.
    1:      */
    1:     if (tc->blockNode != pn)
    1:         pn = tc->blockNode;
    1:     tc->blockNode = saveBlock;
    1: 
40270:     pn->pn_pos.end = tokenStream.currentToken().pos.end;
    1:     return pn;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::condition()
    1: {
    1:     JSParseNode *pn;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_COND);
61058:     pn = parenExpr();
    1:     if (!pn)
    1:         return NULL;
    1:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_COND);
    1: 
31479:     /* Check for (a = b) and warn about possible (a == b) mistype. */
    1:     if (pn->pn_type == TOK_ASSIGN &&
    1:         pn->pn_op == JSOP_NOP &&
31479:         !pn->pn_parens &&
42671:         !reportErrorNumber(NULL, JSREPORT_WARNING | JSREPORT_STRICT, JSMSG_EQUAL_AS_ASSIGN, "")) {
    1:         return NULL;
    1:     }
    1:     return pn;
    1: }
    1: 
    1: static JSBool
40320: MatchLabel(JSContext *cx, TokenStream *ts, JSParseNode *pn)
    1: {
    1:     JSAtom *label;
40320:     TokenKind tt;
40320: 
64316:     tt = ts->peekTokenSameLine(TSF_OPERAND);
    1:     if (tt == TOK_ERROR)
    1:         return JS_FALSE;
    1:     if (tt == TOK_NAME) {
40354:         (void) ts->getToken();
40270:         label = ts->currentToken().t_atom;
    1:     } else {
    1:         label = NULL;
    1:     }
    1:     pn->pn_atom = label;
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: BindLet(JSContext *cx, BindData *data, JSAtom *atom, JSTreeContext *tc)
    1: {
27012:     JSParseNode *pn;
    1:     JSObject *blockObj;
    1:     JSAtomListElement *ale;
27012:     jsint n;
27012: 
27012:     /*
59229:      * Body-level 'let' is the same as 'var' currently -- this may change in a
59229:      * successor standard to ES5 that specifies 'let'.
59229:      */
59229:     JS_ASSERT(!tc->atBodyLevel());
27012: 
27012:     pn = data->pn;
35325:     if (!CheckStrictBinding(cx, tc, atom, pn))
35325:         return false;
35325: 
54855:     blockObj = tc->blockChain();
27012:     ale = tc->decls.lookup(atom);
27012:     if (ale && ALE_DEFN(ale)->pn_blockid == tc->blockid()) {
57812:         JSAutoByteString name;
57812:         if (js_AtomToPrintableString(cx, atom, &name)) {
40860:             ReportCompileErrorNumber(cx, TS(tc->parser), pn,
 7984:                                      JSREPORT_ERROR, JSMSG_REDECLARED_VAR,
27012:                                      (ale && ALE_DEFN(ale)->isConst())
    1:                                      ? js_const_str
27012:                                      : js_variable_str,
57812:                                      name.ptr());
    1:         }
47497:         return false;
    1:     }
    1: 
14688:     n = OBJ_BLOCK_COUNT(cx, blockObj);
14688:     if (n == JS_BIT(16)) {
40860:         ReportCompileErrorNumber(cx, TS(tc->parser), pn,
27012:                                  JSREPORT_ERROR, data->let.overflow);
47497:         return false;
    1:     }
    1: 
27012:     /*
27012:      * Pass push = true to Define so it pushes an ale ahead of any outer scope.
27012:      * This is balanced by PopStatement, defined immediately below.
27012:      */
27012:     if (!Define(pn, atom, tc, true))
47497:         return false;
27012: 
27012:     /*
27012:      * Assign block-local index to pn->pn_cookie right away, encoding it as an
27012:      * upvar cookie whose skip tells the current static level. The emitter will
27012:      * adjust the node's slot based on its stack depth model -- and, for global
40860:      * and eval code, Compiler::compileScript will adjust the slot again to
27012:      * include script->nfixed.
27012:      */
27012:     pn->pn_op = JSOP_GETLOCAL;
48585:     pn->pn_cookie.set(tc->staticLevel, uint16(n));
27012:     pn->pn_dflags |= PND_LET | PND_BOUND;
27012: 
27012:     /*
53650:      * Define the let binding's property before storing pn in the the binding's
53650:      * slot indexed by n off the class-reserved slot base.
53650:      */
53650:     const Shape *shape = blockObj->defineBlockVariable(cx, ATOM_TO_JSID(atom), n);
53650:     if (!shape)
47497:         return false;
27012: 
27012:     /*
53650:      * Store pn temporarily in what would be shape-mapped slots in a cloned
53650:      * block object (once the prototype's final population is known, after all
53650:      * 'let' bindings for this block have been parsed). We free these slots in
53650:      * jsemit.cpp:EmitEnterBlock so they don't tie up unused space in the so-
53650:      * called "static" prototype Block.
53650:      */
53650:     blockObj->setSlot(shape->slot, PrivateValue(pn));
47497:     return true;
27012: }
27012: 
27012: static void
27012: PopStatement(JSTreeContext *tc)
27012: {
27012:     JSStmtInfo *stmt = tc->topStmt;
27012: 
27012:     if (stmt->flags & SIF_SCOPE) {
54855:         JSObject *obj = stmt->blockBox->object;
53650:         JS_ASSERT(!obj->isClonedBlock());
27012: 
52503:         for (Shape::Range r = obj->lastProperty()->all(); !r.empty(); r.popFront()) {
69637:             JSAtom *atom = JSID_TO_ATOM(r.front().propid);
27012: 
27012:             /* Beware the empty destructuring dummy. */
40860:             if (atom == tc->parser->context->runtime->atomState.emptyAtom)
27012:                 continue;
40860:             tc->decls.remove(tc->parser, atom);
27012:         }
27012:     }
27012:     js_PopStatement(tc);
    1: }
    1: 
27112: static inline bool
27112: OuterLet(JSTreeContext *tc, JSStmtInfo *stmt, JSAtom *atom)
27112: {
27112:     while (stmt->downScope) {
27112:         stmt = js_LexicalLookup(tc, atom, NULL, stmt->downScope);
27112:         if (!stmt)
27112:             return false;
27112:         if (stmt->type == STMT_BLOCK)
27112:             return true;
27112:     }
27112:     return false;
27112: }
27112: 
41817: /*
41817:  * If we are generating global or eval-called-from-global code, bind a "gvar"
41817:  * here, as soon as possible. The JSOP_GETGVAR, etc., ops speed up interpreted
41817:  * global variable access by memoizing name-to-slot mappings during execution
41817:  * of the script prolog (via JSOP_DEFVAR/JSOP_DEFCONST). If the memoization
41817:  * can't be done due to a pre-existing property of the same name as the var or
41817:  * const but incompatible attributes/getter/setter/etc, these ops devolve to
41817:  * JSOP_NAME, etc.
41817:  *
41817:  * For now, don't try to lookup eval frame variables at compile time. This is
41817:  * sub-optimal: we could handle eval-called-from-global-code gvars since eval
41817:  * gets its own script and frame. The eval-from-function-code case is harder,
41817:  * since functions do not atomize gvars and then reserve their atom indexes as
41817:  * stack frame slots.
41817:  */
41817: static bool
52555: DefineGlobal(JSParseNode *pn, JSCodeGenerator *cg, JSAtom *atom)
52555: {
52555:     GlobalScope *globalScope = cg->compiler()->globalScope;
52555:     JSObject *globalObj = globalScope->globalObj;
52555: 
52555:     if (!cg->compileAndGo() || !globalObj || cg->compilingForEval())
52555:         return true;
52555: 
54477:     JSAtomListElement *ale = globalScope->names.lookup(atom);
54477:     if (!ale) {
54477:         JSContext *cx = cg->parser->context;
54477: 
54477:         JSObject *holder;
54477:         JSProperty *prop;
54477:         if (!globalObj->lookupProperty(cx, ATOM_TO_JSID(atom), &holder, &prop))
52555:             return false;
54477: 
54477:         JSFunctionBox *funbox = (pn->pn_type == TOK_FUNCTION) ? pn->pn_funbox : NULL;
54477: 
54477:         GlobalScope::GlobalDef def;
54477:         if (prop) {
54477:             /*
54477:              * A few cases where we don't bother aggressively caching:
54477:              *   1) Function value changes.
54477:              *   2) Configurable properties.
54477:              *   3) Properties without slots, or with getters/setters.
54477:              */
54477:             const Shape *shape = (const Shape *)prop;
54477:             if (funbox ||
54477:                 globalObj != holder ||
54477:                 shape->configurable() ||
54477:                 !shape->hasSlot() ||
54477:                 !shape->hasDefaultGetterOrIsMethod() ||
54477:                 !shape->hasDefaultSetter()) {
52818:                 return true;
52818:             }
54477:             
54477:             def = GlobalScope::GlobalDef(shape->slot);
54477:         } else {
54477:             def = GlobalScope::GlobalDef(atom, funbox);
54477:         }
54477: 
54477:         if (!globalScope->defs.append(def))
54477:             return false;
54477: 
54477:         ale = globalScope->names.add(cg->parser, atom);
54477:         if (!ale)
54477:             return false;
54477: 
54477:         JS_ASSERT(ALE_INDEX(ale) == globalScope->defs.length() - 1);
54477:     } else {
54477:         /*
54477:          * Functions can be redeclared, and the last one takes effect. Check
54477:          * for this and make sure to rewrite the definition.
54477:          *
54477:          * Note: This could overwrite an existing variable declaration, for
54477:          * example:
53540:          *   var c = []
53540:          *   function c() { }
53540:          *
54477:          * This rewrite is allowed because the function will be statically
54477:          * hoisted to the top of the script, and the |c = []| will just
54477:          * overwrite it at runtime.
54477:          */
52818:         if (pn->pn_type == TOK_FUNCTION) {
54477:             JS_ASSERT(pn->pn_arity = PN_FUNC);
52818:             uint32 index = ALE_INDEX(ale);
54477:             globalScope->defs[index].funbox = pn->pn_funbox;
54477:         }
52818:     }
52818: 
52818:     pn->pn_dflags |= PND_GVAR;
52555: 
52555:     return true;
52555: }
52555: 
52795: static bool
60145: BindTopLevelVar(JSContext *cx, BindData *data, JSAtomListElement *ale, JSParseNode *pn,
60145:                 JSAtom *varname, JSTreeContext *tc)
41817: {
41817:     JS_ASSERT(pn->pn_op == JSOP_NAME);
41884:     JS_ASSERT(!tc->inFunction());
41884: 
60145:     /* There's no need to optimize bindings if we're not compiling code. */
60145:     if (!tc->compiling())
52555:         return true;
52555: 
60145:     /*
60145:      * Bindings at top level in eval code aren't like bindings at top level in
60145:      * regular code, and we must handle them specially.
60145:      */
60145:     if (tc->parser->callerFrame) {
60145:         /*
60145:          * If the eval code is not strict mode code, such bindings are created
60145:          * from scratch in the the caller's environment (if the eval is direct)
60145:          * or in the global environment (if the eval is indirect) -- and they
60145:          * can be deleted.  Therefore we can't bind early.
60145:          */
60145:         if (!tc->inStrictMode())
60145:             return true;
60145: 
60145:         /*
60145:          * But if the eval code is strict mode code, bindings are added to a
60145:          * new environment specifically for that eval code's compilation, and
60145:          * they can't be deleted.  Thus strict mode eval code does not affect
60145:          * the caller's environment, and we can bind such names early.  (But
60145:          * note: strict mode eval code can still affect the global environment
60145:          * by performing an indirect eval of non-strict mode code.)
60145:          *
60145:          * However, optimizing such bindings requires either precarious
60145:          * type-punning or, ideally, a new kind of Call object specifically for
60145:          * strict mode eval frames.  Further, strict mode eval is not (yet)
60145:          * common.  So for now (until we rewrite the scope chain to not use
60145:          * objects?) just disable optimizations for top-level names in eval
60145:          * code.
60145:          */
60145:         return true;
60145:     }
41817: 
52825:     if (pn->pn_dflags & PND_CONST)
41817:         return true;
41817: 
60145:     /*
60145:      * If this is a global variable, we're compile-and-go, and a global object
60145:      * is present, try to bake in either an already available slot or a
60145:      * predicted slot that will be defined after compiling is completed.
60145:      */
60145:     return DefineGlobal(pn, tc->asCodeGenerator(), pn->pn_atom);
60145: }
60145: 
60145: static bool
60145: BindFunctionLocal(JSContext *cx, BindData *data, JSAtomListElement *ale, JSParseNode *pn,
60145:                   JSAtom *name, JSTreeContext *tc)
60145: {
60145:     JS_ASSERT(tc->inFunction());
60145: 
60145:     if (name == cx->runtime->atomState.argumentsAtom) {
60145:         pn->pn_op = JSOP_ARGUMENTS;
60145:         pn->pn_dflags |= PND_BOUND;
60145:         return true;
60145:     }
60145: 
60145:     BindingKind kind = tc->bindings.lookup(cx, name, NULL);
60145:     if (kind == NONE) {
60145:         /*
60145:          * Property not found in current variable scope: we have not seen this
60145:          * variable before, so bind a new local variable for it. Any locals
60145:          * declared in a with statement body are handled at runtime, by script
60145:          * prolog JSOP_DEFVAR opcodes generated for global and heavyweight-
60145:          * function-local vars.
60145:          */
60145:         kind = (data->op == JSOP_DEFCONST) ? CONSTANT : VARIABLE;
60145: 
60145:         uintN index = tc->bindings.countVars();
60145:         if (!BindLocalVariable(cx, tc, name, kind, false))
60145:             return false;
60145:         pn->pn_op = JSOP_GETLOCAL;
60145:         pn->pn_cookie.set(tc->staticLevel, index);
60145:         pn->pn_dflags |= PND_BOUND;
60145:         return true;
60145:     }
60145: 
60145:     if (kind == ARGUMENT) {
60145:         JS_ASSERT(tc->inFunction());
60145:         JS_ASSERT(ale && ALE_DEFN(ale)->kind() == JSDefinition::ARG);
60145:     } else {
60145:         JS_ASSERT(kind == VARIABLE || kind == CONSTANT);
60145:     }
60145: 
60145:     return true;
41817: }
41817: 
    1: static JSBool
    1: BindVarOrConst(JSContext *cx, BindData *data, JSAtom *atom, JSTreeContext *tc)
    1: {
35325:     JSParseNode *pn = data->pn;
35325: 
41817:     /* Default best op for pn is JSOP_NAME; we'll try to improve below. */
41817:     pn->pn_op = JSOP_NAME;
41817: 
35325:     if (!CheckStrictBinding(cx, tc, atom, pn))
35325:         return false;
35325: 
64237:     JSStmtInfo *stmt = js_LexicalLookup(tc, atom, NULL);
64237: 
64237:     if (stmt && stmt->type == STMT_WITH) {
29379:         data->fresh = false;
54755:         pn->pn_dflags |= PND_DEOPTIMIZED;
58291:         tc->noteMightAliasLocals();
52825:         return true;
27012:     }
27012: 
27012:     JSAtomListElement *ale = tc->decls.lookup(atom);
27012:     JSOp op = data->op;
27012: 
27012:     if (stmt || ale) {
27012:         JSDefinition *dn = ale ? ALE_DEFN(ale) : NULL;
27012:         JSDefinition::Kind dn_kind = dn ? dn->kind() : JSDefinition::VAR;
27012: 
27012:         if (dn_kind == JSDefinition::ARG) {
57812:             JSAutoByteString name;
57812:             if (!js_AtomToPrintableString(cx, atom, &name))
 8179:                 return JS_FALSE;
 8179: 
 8179:             if (op == JSOP_DEFCONST) {
40860:                 ReportCompileErrorNumber(cx, TS(tc->parser), pn,
 8179:                                          JSREPORT_ERROR, JSMSG_REDECLARED_PARAM,
57812:                                          name.ptr());
 8179:                 return JS_FALSE;
 8179:             }
40860:             if (!ReportCompileErrorNumber(cx, TS(tc->parser), pn,
 8179:                                           JSREPORT_WARNING | JSREPORT_STRICT,
57812:                                           JSMSG_VAR_HIDES_ARG, name.ptr())) {
 8179:                 return JS_FALSE;
 8179:             }
 8179:         } else {
28167:             bool error = (op == JSOP_DEFCONST ||
28167:                           dn_kind == JSDefinition::CONST ||
28167:                           (dn_kind == JSDefinition::LET &&
28167:                            (stmt->type != STMT_CATCH || OuterLet(tc, stmt, atom))));
28167: 
61450:             if (cx->hasStrictOption()
27012:                 ? op != JSOP_DEFVAR || dn_kind != JSDefinition::VAR
28167:                 : error) {
57812:                 JSAutoByteString name;
57812:                 if (!js_AtomToPrintableString(cx, atom, &name) ||
40860:                     !ReportCompileErrorNumber(cx, TS(tc->parser), pn,
28167:                                               !error
27012:                                               ? JSREPORT_WARNING | JSREPORT_STRICT
27012:                                               : JSREPORT_ERROR,
27012:                                               JSMSG_REDECLARED_VAR,
27012:                                               JSDefinition::kindString(dn_kind),
57812:                                               name.ptr())) {
27012:                     return JS_FALSE;
27012:                 }
27012:             }
27012:         }
27012:     }
27012: 
27012:     if (!ale) {
27012:         if (!Define(pn, atom, tc))
27012:             return JS_FALSE;
27012:     } else {
27012:         /*
27012:          * A var declaration never recreates an existing binding, it restates
27012:          * it and possibly reinitializes its value. Beware that if pn becomes a
27012:          * use of ALE_DEFN(ale), and if we have an initializer for this var or
27012:          * const (typically a const would ;-), then pn must be rewritten into a
27012:          * TOK_ASSIGN node. See Variables, further below.
27012:          *
27012:          * A case such as let (x = 1) { var x = 2; print(x); } is even harder.
27012:          * There the x definition is hoisted but the x = 2 assignment mutates
27012:          * the block-local binding of x.
27012:          */
27012:         JSDefinition *dn = ALE_DEFN(ale);
27012: 
29379:         data->fresh = false;
29379: 
27012:         if (!pn->pn_used) {
27012:             /* Make pnu be a fresh name node that uses dn. */
27012:             JSParseNode *pnu = pn;
27012: 
27012:             if (pn->pn_defn) {
40232:                 pnu = NameNode::create(atom, tc);
27012:                 if (!pnu)
27012:                     return JS_FALSE;
27012:             }
27012: 
27012:             LinkUseToDef(pnu, dn, tc);
27012:             pnu->pn_op = JSOP_NAME;
27012:         }
27012: 
27012:         while (dn->kind() == JSDefinition::LET) {
27012:             do {
27012:                 ale = ALE_NEXT(ale);
27012:             } while (ale && ALE_ATOM(ale) != atom);
27012:             if (!ale)
27012:                 break;
27012:             dn = ALE_DEFN(ale);
27012:         }
27012: 
27012:         if (ale) {
27012:             JS_ASSERT_IF(data->op == JSOP_DEFCONST,
27012:                          dn->kind() == JSDefinition::CONST);
27012:             return JS_TRUE;
27012:         }
27012: 
27012:         /*
27012:          * A var or const that is shadowed by one or more let bindings of the
27012:          * same name, but that has not been declared until this point, must be
27012:          * hoisted above the let bindings.
27012:          */
27012:         if (!pn->pn_defn) {
27012:             JSHashEntry **hep;
27012: 
27012:             ale = tc->lexdeps.rawLookup(atom, hep);
27012:             if (ale) {
27012:                 pn = ALE_DEFN(ale);
40860:                 tc->lexdeps.rawRemove(tc->parser, ale, hep);
27012:             } else {
40232:                 JSParseNode *pn2 = NameNode::create(atom, tc);
27012:                 if (!pn2)
27012:                     return JS_FALSE;
27012: 
27012:                 /* The token stream may be past the location for pn. */
27012:                 pn2->pn_type = TOK_NAME;
27012:                 pn2->pn_pos = pn->pn_pos;
27012:                 pn = pn2;
27012:             }
27012:             pn->pn_op = JSOP_NAME;
27012:         }
27012: 
40860:         ale = tc->decls.add(tc->parser, atom, JSAtomList::HOIST);
27012:         if (!ale)
27012:             return JS_FALSE;
27012:         ALE_SET_DEFN(ale, pn);
27012:         pn->pn_defn = true;
27012:         pn->pn_dflags &= ~PND_PLACEHOLDER;
27012:     }
27012: 
27012:     if (data->op == JSOP_DEFCONST)
27012:         pn->pn_dflags |= PND_CONST;
27012: 
60145:     if (tc->inFunction())
60145:         return BindFunctionLocal(cx, data, ale, pn, atom, tc);
60145: 
60145:     return BindTopLevelVar(cx, data, ale, pn, atom, tc);
    1: }
    1: 
57742: static bool
20908: MakeSetCall(JSContext *cx, JSParseNode *pn, JSTreeContext *tc, uintN msg)
20908: {
20908:     JS_ASSERT(pn->pn_arity == PN_LIST);
57712:     JS_ASSERT(pn->pn_op == JSOP_CALL || pn->pn_op == JSOP_EVAL ||
57712:               pn->pn_op == JSOP_FUNCALL || pn->pn_op == JSOP_FUNAPPLY);
57742:     if (!ReportStrictModeError(cx, TS(tc->parser), tc, pn, msg))
57742:         return false;
57742: 
57742:     JSParseNode *pn2 = pn->pn_head;
27012:     if (pn2->pn_type == TOK_FUNCTION && (pn2->pn_funbox->tcflags & TCF_GENEXP_LAMBDA)) {
40860:         ReportCompileErrorNumber(cx, TS(tc->parser), pn, JSREPORT_ERROR, msg);
57742:         return false;
57742:     }
57742:     pn->pn_xflags |= PNX_SETCALL;
57742:     return true;
20908: }
20908: 
27012: static void
27012: NoteLValue(JSContext *cx, JSParseNode *pn, JSTreeContext *tc, uintN dflag = PND_ASSIGNED)
27012: {
27012:     if (pn->pn_used) {
27012:         JSDefinition *dn = pn->pn_lexdef;
27012: 
27012:         /*
27012:          * Save the win of PND_INITIALIZED if we can prove 'var x;' and 'x = y'
27012:          * occur as direct kids of the same block with no forward refs to x.
27012:          */
28920:         if (!(dn->pn_dflags & (PND_INITIALIZED | PND_CONST | PND_PLACEHOLDER)) &&
28557:             dn->isBlockChild() &&
27012:             pn->isBlockChild() &&
27012:             dn->pn_blockid == pn->pn_blockid &&
28557:             dn->pn_pos.end <= pn->pn_pos.begin &&
27012:             dn->dn_uses == pn) {
27012:             dflag = PND_INITIALIZED;
27012:         }
27012: 
27012:         dn->pn_dflags |= dflag;
27012: 
47573:         if (dn->pn_cookie.isFree() || dn->frameLevel() < tc->staticLevel)
27012:             tc->flags |= TCF_FUN_SETS_OUTER_NAME;
27012:     }
27012: 
27012:     pn->pn_dflags |= dflag;
27012: 
59940:     /*
59940:      * Both arguments and the enclosing function's name are immutable bindings
59940:      * in ES5, so assignments to them must do nothing or throw a TypeError
59940:      * depending on code strictness.  Assignment to arguments is a syntax error
59940:      * in strict mode and thus cannot happen.  Outside strict mode, we optimize
59940:      * away assignment to the function name.  For assignment to function name
59940:      * to fail in strict mode, we must have a binding for it in the scope
59940:      * chain; we ensure this happens by making such functions heavyweight.
59940:      */
51096:     JSAtom *lname = pn->pn_atom;
72073:     if (lname == cx->runtime->atomState.argumentsAtom) {
72073:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
72073:         tc->countArgumentsUse(pn);
72073:     } else if (tc->inFunction() && lname == tc->fun()->atom) {
27012:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
27012:     }
59940: }
27012: 
    1: #if JS_HAS_DESTRUCTURING
    1: 
    1: static JSBool
    1: BindDestructuringVar(JSContext *cx, BindData *data, JSParseNode *pn,
    1:                      JSTreeContext *tc)
    1: {
    1:     JSAtom *atom;
    1: 
    1:     /*
    1:      * Destructuring is a form of assignment, so just as for an initialized
    1:      * simple variable, we must check for assignment to 'arguments' and flag
    1:      * the enclosing function (if any) as heavyweight.
    1:      */
    1:     JS_ASSERT(pn->pn_type == TOK_NAME);
    1:     atom = pn->pn_atom;
    1:     if (atom == cx->runtime->atomState.argumentsAtom)
    1:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1: 
    1:     data->pn = pn;
    1:     if (!data->binder(cx, data, atom, tc))
    1:         return JS_FALSE;
27012: 
27012:     /*
27012:      * Select the appropriate name-setting opcode, respecting eager selection
27012:      * done by the data->binder function.
27012:      */
27012:     if (pn->pn_dflags & PND_BOUND) {
60526:         JS_ASSERT(!(pn->pn_dflags & PND_GVAR));
27012:         pn->pn_op = (pn->pn_op == JSOP_ARGUMENTS)
27012:                     ? JSOP_SETNAME
27012:                     : JSOP_SETLOCAL;
 8444:     } else {
27012:         pn->pn_op = (data->op == JSOP_DEFCONST)
27012:                     ? JSOP_SETCONST
27012:                     : JSOP_SETNAME;
27012:     }
27012: 
27012:     if (data->op == JSOP_DEFCONST)
27012:         pn->pn_dflags |= PND_CONST;
27012: 
27012:     NoteLValue(cx, pn, tc, PND_INITIALIZED);
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * Here, we are destructuring {... P: Q, ...} = R, where P is any id, Q is any
    1:  * LHS expression except a destructuring initialiser, and R is on the stack.
    1:  * Because R is already evaluated, the usual LHS-specialized bytecodes won't
    1:  * work.  After pushing R[P] we need to evaluate Q's "reference base" QB and
    1:  * then push its property name QN.  At this point the stack looks like
    1:  *
    1:  *   [... R, R[P], QB, QN]
    1:  *
    1:  * We need to set QB[QN] = R[P].  This is a job for JSOP_ENUMELEM, which takes
    1:  * its operands with left-hand side above right-hand side:
    1:  *
    1:  *   [rval, lval, xval]
    1:  *
    1:  * and pops all three values, setting lval[xval] = rval.  But we cannot select
    1:  * JSOP_ENUMELEM yet, because the LHS may turn out to be an arg or local var,
    1:  * which can be optimized further.  So we select JSOP_SETNAME.
    1:  */
    1: static JSBool
    1: BindDestructuringLHS(JSContext *cx, JSParseNode *pn, JSTreeContext *tc)
    1: {
    1:     switch (pn->pn_type) {
    1:       case TOK_NAME:
27012:         NoteLValue(cx, pn, tc);
    1:         /* FALL THROUGH */
27012: 
    1:       case TOK_DOT:
    1:       case TOK_LB:
42747:         /*
42747:          * We may be called on a name node that has already been specialized,
42747:          * in the very weird and ECMA-262-required "for (var [x] = i in o) ..."
42747:          * case. See bug 558633.
42747:          */
42747:         if (!(js_CodeSpec[pn->pn_op].format & JOF_SET))
    1:             pn->pn_op = JSOP_SETNAME;
    1:         break;
    1: 
    1:       case TOK_LP:
 7984:         if (!MakeSetCall(cx, pn, tc, JSMSG_BAD_LEFTSIDE_OF_ASS))
 1577:             return JS_FALSE;
    1:         break;
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_UNARYOP:
    1:         if (pn->pn_op == JSOP_XMLNAME) {
    1:             pn->pn_op = JSOP_BINDXMLNAME;
    1:             break;
    1:         }
    1:         /* FALL THROUGH */
    1: #endif
    1: 
    1:       default:
40860:         ReportCompileErrorNumber(cx, TS(tc->parser), pn,
 7984:                                  JSREPORT_ERROR, JSMSG_BAD_LEFTSIDE_OF_ASS);
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
33753:  * Destructuring patterns can appear in two kinds of contexts:
28995:  *
33753:  * - assignment-like: assignment expressions and |for| loop heads.  In
33753:  *   these cases, the patterns' property value positions can be
33753:  *   arbitrary lvalue expressions; the destructuring is just a fancy
33753:  *   assignment.
33753:  *
33753:  * - declaration-like: |var| and |let| declarations, functions' formal
33753:  *   parameter lists, |catch| clauses, and comprehension tails.  In
33753:  *   these cases, the patterns' property value positions must be
33753:  *   simple names; the destructuring defines them as new variables.
33753:  *
33753:  * In both cases, other code parses the pattern as an arbitrary
40239:  * primaryExpr, and then, here in CheckDestructuring, verify that the
33753:  * tree is a valid destructuring expression.
33753:  *
33753:  * In assignment-like contexts, we parse the pattern with the
33753:  * TCF_DECL_DESTRUCTURING flag clear, so the lvalue expressions in the
40239:  * pattern are parsed normally.  primaryExpr links variable references
33753:  * into the appropriate use chains; creates placeholder definitions;
33753:  * and so on.  CheckDestructuring is called with |data| NULL (since we
33753:  * won't be binding any new names), and we specialize lvalues as
68922:  * appropriate.
33753:  *
33753:  * In declaration-like contexts, the normal variable reference
33753:  * processing would just be an obstruction, because we're going to
33753:  * define the names that appear in the property value positions as new
33753:  * variables anyway.  In this case, we parse the pattern with
40239:  * TCF_DECL_DESTRUCTURING set, which directs primaryExpr to leave
33753:  * whatever name nodes it creates unconnected.  Then, here in
33753:  * CheckDestructuring, we require the pattern's property value
33753:  * positions to be simple names, and define them as appropriate to the
33753:  * context.  For these calls, |data| points to the right sort of
33753:  * BindData.
33753:  *
33753:  * See also UndominateInitializers, immediately below. If you change
33753:  * either of these functions, you might have to change the other to
33753:  * match.
    1:  */
68922: static bool
68922: CheckDestructuring(JSContext *cx, BindData *data, JSParseNode *left, JSTreeContext *tc)
68922: {
68922:     bool ok;
    1: 
    1:     if (left->pn_type == TOK_ARRAYCOMP) {
40860:         ReportCompileErrorNumber(cx, TS(tc->parser), left, JSREPORT_ERROR,
40320:                                  JSMSG_ARRAY_COMP_LEFTSIDE);
68922:         return false;
68922:     }
68922: 
    1:     if (left->pn_type == TOK_RB) {
68922:         for (JSParseNode *pn = left->pn_head; pn; pn = pn->pn_next) {
    1:             /* Nullary comma is an elision; binary comma is an expression.*/
    1:             if (pn->pn_type != TOK_COMMA || pn->pn_arity != PN_NULLARY) {
    1:                 if (pn->pn_type == TOK_RB || pn->pn_type == TOK_RC) {
68922:                     ok = CheckDestructuring(cx, data, pn, tc);
    1:                 } else {
    1:                     if (data) {
68922:                         if (pn->pn_type != TOK_NAME) {
68922:                             ReportCompileErrorNumber(cx, TS(tc->parser), pn, JSREPORT_ERROR,
68922:                                                      JSMSG_NO_VARIABLE_NAME);
68922:                             return false;
68922:                         }
    1:                         ok = BindDestructuringVar(cx, data, pn, tc);
    1:                     } else {
    1:                         ok = BindDestructuringLHS(cx, pn, tc);
    1:                     }
    1:                 }
    1:                 if (!ok)
68922:                     return false;
68922:             }
    1:         }
    1:     } else {
    1:         JS_ASSERT(left->pn_type == TOK_RC);
68922:         for (JSParseNode *pair = left->pn_head; pair; pair = pair->pn_next) {
68922:             JS_ASSERT(pair->pn_type == TOK_COLON);
68922:             JSParseNode *pn = pair->pn_right;
    1: 
    1:             if (pn->pn_type == TOK_RB || pn->pn_type == TOK_RC) {
68922:                 ok = CheckDestructuring(cx, data, pn, tc);
    1:             } else if (data) {
68922:                 if (pn->pn_type != TOK_NAME) {
68922:                     ReportCompileErrorNumber(cx, TS(tc->parser), pn, JSREPORT_ERROR,
68922:                                              JSMSG_NO_VARIABLE_NAME);
68922:                     return false;
68922:                 }
    1:                 ok = BindDestructuringVar(cx, data, pn, tc);
    1:             } else {
    1:                 ok = BindDestructuringLHS(cx, pn, tc);
    1:             }
    1:             if (!ok)
68922:                 return false;
    1:         }
    1:     }
    1: 
14688:     /*
14688:      * The catch/finally handler implementation in the interpreter assumes
14688:      * that any operation that introduces a new scope (like a "let" or "with"
14688:      * block) increases the stack depth. This way, it is possible to restore
14688:      * the scope chain based on stack depth of the handler alone. "let" with
14688:      * an empty destructuring pattern like in
14688:      *
14688:      *   let [] = 1;
14688:      *
14688:      * would violate this assumption as the there would be no let locals to
14688:      * store on the stack. To satisfy it we add an empty property to such
14688:      * blocks so that OBJ_BLOCK_COUNT(cx, blockObj), which gives the number of
14688:      * slots, would be always positive.
14688:      *
14688:      * Note that we add such a property even if the block has locals due to
14688:      * later let declarations in it. We optimize for code simplicity here,
14688:      * not the fastest runtime performance with empty [] or {}.
14688:      */
14688:     if (data &&
14688:         data->binder == BindLet &&
68922:         OBJ_BLOCK_COUNT(cx, tc->blockChain()) == 0 &&
69855:         !DefineNativeProperty(cx, tc->blockChain(),
53650:                               ATOM_TO_JSID(cx->runtime->atomState.emptyAtom),
48470:                               UndefinedValue(), NULL, NULL,
53650:                               JSPROP_ENUMERATE | JSPROP_PERMANENT,
69855:                               Shape::HAS_SHORTID, 0)) {
68922:         return false;
68922:     }
68922: 
68922:     return true;
    1: }
    1: 
28995: /*
68923:  * Extend the pn_pos.end source coordinate of each name in a destructuring
68923:  * binding such as
28995:  *
28995:  *   var [x, y] = [function () y, 42];
28995:  *
68923:  * to cover the entire initializer, so that the initialized bindings do not
68923:  * appear to dominate any closures in the initializer. See bug 496134.
28995:  *
40860:  * The quick-and-dirty dominance computation in Parser::setFunctionKinds is not
40860:  * very precise. With one-pass SSA construction from structured source code
28995:  * (see "Single-Pass Generation of Static Single Assignment Form for Structured
28995:  * Languages", Brandis and Mössenböck), we could do much better.
28995:  *
28995:  * See CheckDestructuring, immediately above. If you change either of these
28995:  * functions, you might have to change the other to match.
28995:  */
68923: static void
68923: UndominateInitializers(JSParseNode *left, const TokenPtr &end, JSTreeContext *tc)
68923: {
28995:     if (left->pn_type == TOK_RB) {
68923:         for (JSParseNode *pn = left->pn_head; pn; pn = pn->pn_next) {
28995:             /* Nullary comma is an elision; binary comma is an expression.*/
68923:             if (pn->pn_type != TOK_COMMA || pn->pn_arity != PN_NULLARY) {
68923:                 if (pn->pn_type == TOK_RB || pn->pn_type == TOK_RC)
68923:                     UndominateInitializers(pn, end, tc);
68923:                 else
68923:                     pn->pn_pos.end = end;
68923:             }
28995:         }
28995:     } else {
28995:         JS_ASSERT(left->pn_type == TOK_RC);
68923: 
68923:         for (JSParseNode *pair = left->pn_head; pair; pair = pair->pn_next) {
68923:             JS_ASSERT(pair->pn_type == TOK_COLON);
68923:             JSParseNode *pn = pair->pn_right;
68923:             if (pn->pn_type == TOK_RB || pn->pn_type == TOK_RC)
68923:                 UndominateInitializers(pn, end, tc);
68923:             else
68923:                 pn->pn_pos.end = end;
68923:         }
68923:     }
28995: }
28995: 
40239: JSParseNode *
40860: Parser::destructuringExpr(BindData *data, TokenKind tt)
40239: {
    1:     JSParseNode *pn;
    1: 
33753:     tc->flags |= TCF_DECL_DESTRUCTURING;
40263:     pn = primaryExpr(tt, JS_FALSE);
33753:     tc->flags &= ~TCF_DECL_DESTRUCTURING;
    1:     if (!pn)
    1:         return NULL;
68922:     if (!CheckDestructuring(context, data, pn, tc))
    1:         return NULL;
    1:     return pn;
    1: }
    1: 
27012: /*
27012:  * Currently used only #if JS_HAS_DESTRUCTURING, in Statement's TOK_FOR case.
27012:  * This function assumes the cloned tree is for use in the same statement and
27012:  * binding context as the original tree.
27012:  */
20413: static JSParseNode *
27012: CloneParseTree(JSParseNode *opn, JSTreeContext *tc)
20413: {
20413:     JSParseNode *pn, *pn2, *opn2;
20413: 
27012:     pn = NewOrRecycledNode(tc);
20413:     if (!pn)
20413:         return NULL;
20413:     pn->pn_type = opn->pn_type;
20413:     pn->pn_pos = opn->pn_pos;
20413:     pn->pn_op = opn->pn_op;
27012:     pn->pn_used = opn->pn_used;
27012:     pn->pn_defn = opn->pn_defn;
20413:     pn->pn_arity = opn->pn_arity;
31479:     pn->pn_parens = opn->pn_parens;
20413: 
20413:     switch (pn->pn_arity) {
20419: #define NULLCHECK(e)    JS_BEGIN_MACRO if (!(e)) return NULL; JS_END_MACRO
20413: 
20413:       case PN_FUNC:
27012:         NULLCHECK(pn->pn_funbox =
40860:                   tc->parser->newFunctionBox(opn->pn_funbox->object, pn, tc));
27012:         NULLCHECK(pn->pn_body = CloneParseTree(opn->pn_body, tc));
27012:         pn->pn_cookie = opn->pn_cookie;
27012:         pn->pn_dflags = opn->pn_dflags;
27012:         pn->pn_blockid = opn->pn_blockid;
20413:         break;
20413: 
20413:       case PN_LIST:
27012:         pn->makeEmpty();
20413:         for (opn2 = opn->pn_head; opn2; opn2 = opn2->pn_next) {
27012:             NULLCHECK(pn2 = CloneParseTree(opn2, tc));
27012:             pn->append(pn2);
27012:         }
27012:         pn->pn_xflags = opn->pn_xflags;
20413:         break;
20413: 
20413:       case PN_TERNARY:
27012:         NULLCHECK(pn->pn_kid1 = CloneParseTree(opn->pn_kid1, tc));
27012:         NULLCHECK(pn->pn_kid2 = CloneParseTree(opn->pn_kid2, tc));
27012:         NULLCHECK(pn->pn_kid3 = CloneParseTree(opn->pn_kid3, tc));
20413:         break;
20413: 
20413:       case PN_BINARY:
27012:         NULLCHECK(pn->pn_left = CloneParseTree(opn->pn_left, tc));
20413:         if (opn->pn_right != opn->pn_left)
27012:             NULLCHECK(pn->pn_right = CloneParseTree(opn->pn_right, tc));
20413:         else
20413:             pn->pn_right = pn->pn_left;
48470:         pn->pn_pval = opn->pn_pval;
20413:         pn->pn_iflags = opn->pn_iflags;
20413:         break;
20413: 
20413:       case PN_UNARY:
27012:         NULLCHECK(pn->pn_kid = CloneParseTree(opn->pn_kid, tc));
20413:         pn->pn_num = opn->pn_num;
20413:         pn->pn_hidden = opn->pn_hidden;
20413:         break;
20413: 
20413:       case PN_NAME:
20413:         // PN_NAME could mean several arms in pn_u, so copy the whole thing.
20413:         pn->pn_u = opn->pn_u;
27012:         if (opn->pn_used) {
27012:             /*
27012:              * The old name is a use of its pn_lexdef. Make the clone also be a
27012:              * use of that definition.
27012:              */
27012:             JSDefinition *dn = pn->pn_lexdef;
27012: 
27012:             pn->pn_link = dn->dn_uses;
27012:             dn->dn_uses = pn;
27012:         } else if (opn->pn_expr) {
27012:             NULLCHECK(pn->pn_expr = CloneParseTree(opn->pn_expr, tc));
27012: 
27012:             /*
27012:              * If the old name is a definition, the new one has pn_defn set.
27012:              * Make the old name a use of the new node.
27012:              */
27012:             if (opn->pn_defn) {
27012:                 opn->pn_defn = false;
27012:                 LinkUseToDef(opn, (JSDefinition *) pn, tc);
27012:             }
27012:         }
27012:         break;
27012: 
27012:       case PN_NAMESET:
27012:         pn->pn_names = opn->pn_names;
27012:         NULLCHECK(pn->pn_tree = CloneParseTree(opn->pn_tree, tc));
20413:         break;
20413: 
20413:       case PN_NULLARY:
20413:         // Even PN_NULLARY may have data (apair for E4X -- what a botch).
20413:         pn->pn_u = opn->pn_u;
20413:         break;
20413: 
20413: #undef NULLCHECK
20413:     }
20413:     return pn;
20413: }
20413: 
    1: #endif /* JS_HAS_DESTRUCTURING */
    1: 
64291: extern const char js_with_statement_str[];
64291: 
    1: static JSParseNode *
40320: ContainsStmt(JSParseNode *pn, TokenKind tt)
    1: {
    1:     JSParseNode *pn2, *pnt;
    1: 
    1:     if (!pn)
    1:         return NULL;
27012:     if (PN_TYPE(pn) == tt)
    1:         return pn;
    1:     switch (pn->pn_arity) {
    1:       case PN_LIST:
    1:         for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
    1:             pnt = ContainsStmt(pn2, tt);
    1:             if (pnt)
    1:                 return pnt;
    1:         }
    1:         break;
    1:       case PN_TERNARY:
    1:         pnt = ContainsStmt(pn->pn_kid1, tt);
    1:         if (pnt)
    1:             return pnt;
    1:         pnt = ContainsStmt(pn->pn_kid2, tt);
    1:         if (pnt)
    1:             return pnt;
    1:         return ContainsStmt(pn->pn_kid3, tt);
    1:       case PN_BINARY:
    1:         /*
    1:          * Limit recursion if pn is a binary expression, which can't contain a
    1:          * var statement.
    1:          */
    1:         if (pn->pn_op != JSOP_NOP)
    1:             return NULL;
    1:         pnt = ContainsStmt(pn->pn_left, tt);
    1:         if (pnt)
    1:             return pnt;
    1:         return ContainsStmt(pn->pn_right, tt);
    1:       case PN_UNARY:
    1:         if (pn->pn_op != JSOP_NOP)
    1:             return NULL;
    1:         return ContainsStmt(pn->pn_kid, tt);
    1:       case PN_NAME:
27012:         return ContainsStmt(pn->maybeExpr(), tt);
27012:       case PN_NAMESET:
27012:         return ContainsStmt(pn->pn_tree, tt);
    1:       default:;
    1:     }
    1:     return NULL;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::returnOrYield(bool useAssignExpr)
40221: {
40320:     TokenKind tt, tt2;
    1:     JSParseNode *pn, *pn2;
    1: 
40270:     tt = tokenStream.currentToken().type;
72073:     if (!tc->inFunction()) {
72073:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_RETURN_OR_YIELD,
72073:                           (tt == TOK_RETURN) ? js_return_str : js_yield_str);
    1:         return NULL;
    1:     }
    1: 
40232:     pn = UnaryNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
    1: 
    1: #if JS_HAS_GENERATORS
72073:     if (tt == TOK_YIELD) {
72073:         /*
72073:          * If we're within parens, we won't know if this is a generator expression until we see
72073:          * a |for| token, so we have to delay flagging the current function.
72073:          */
72073:         if (tc->parenDepth == 0) {
    1:             tc->flags |= TCF_FUN_IS_GENERATOR;
72073:         } else {
72073:             tc->yieldCount++;
72073:             tc->yieldNode = pn;
72073:         }
72073:     }
    1: #endif
    1: 
    1:     /* This is ugly, but we don't want to require a semicolon. */
40854:     tt2 = tokenStream.peekTokenSameLine(TSF_OPERAND);
    1:     if (tt2 == TOK_ERROR)
    1:         return NULL;
    1: 
    1:     if (tt2 != TOK_EOF && tt2 != TOK_EOL && tt2 != TOK_SEMI && tt2 != TOK_RC
    1: #if JS_HAS_GENERATORS
  339:         && (tt != TOK_YIELD ||
11844:             (tt2 != tt && tt2 != TOK_RB && tt2 != TOK_RP &&
11844:              tt2 != TOK_COLON && tt2 != TOK_COMMA))
    1: #endif
    1:         ) {
40263:         pn2 = useAssignExpr ? assignExpr() : expr();
    1:         if (!pn2)
    1:             return NULL;
    1: #if JS_HAS_GENERATORS
    1:         if (tt == TOK_RETURN)
    1: #endif
    1:             tc->flags |= TCF_RETURN_EXPR;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         pn->pn_kid = pn2;
    1:     } else {
    1: #if JS_HAS_GENERATORS
    1:         if (tt == TOK_RETURN)
    1: #endif
    1:             tc->flags |= TCF_RETURN_VOID;
    1:     }
    1: 
    1:     if ((~tc->flags & (TCF_RETURN_EXPR | TCF_FUN_IS_GENERATOR)) == 0) {
    1:         /* As in Python (see PEP-255), disallow return v; in generators. */
64214:         ReportBadReturn(context, tc, pn, JSREPORT_ERROR,
    1:                         JSMSG_BAD_GENERATOR_RETURN,
    1:                         JSMSG_BAD_ANON_GENERATOR_RETURN);
    1:         return NULL;
    1:     }
    1: 
61450:     if (context->hasStrictOption() &&
    1:         (~tc->flags & (TCF_RETURN_EXPR | TCF_RETURN_VOID)) == 0 &&
64214:         !ReportBadReturn(context, tc, pn, JSREPORT_WARNING | JSREPORT_STRICT,
    1:                          JSMSG_NO_RETURN_VALUE,
    1:                          JSMSG_ANON_NO_RETURN_VALUE)) {
    1:         return NULL;
    1:     }
    1: 
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
40320: PushLexicalScope(JSContext *cx, TokenStream *ts, JSTreeContext *tc,
27012:                  JSStmtInfo *stmt)
    1: {
    1:     JSParseNode *pn;
    1:     JSObject *obj;
27012:     JSObjectBox *blockbox;
27012: 
40232:     pn = LexicalScopeNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
    1: 
    1:     obj = js_NewBlockObject(cx);
    1:     if (!obj)
    1:         return NULL;
    1: 
40860:     blockbox = tc->parser->newObjectBox(obj);
27012:     if (!blockbox)
27012:         return NULL;
27012: 
54855:     js_PushBlockScope(tc, stmt, blockbox, -1);
    1:     pn->pn_type = TOK_LEXICALSCOPE;
    1:     pn->pn_op = JSOP_LEAVEBLOCK;
27012:     pn->pn_objbox = blockbox;
47573:     pn->pn_cookie.makeFree();
27012:     pn->pn_dflags = 0;
27012:     if (!GenerateBlockId(tc, stmt->blockid))
27012:         return NULL;
27012:     pn->pn_blockid = stmt->blockid;
    1:     return pn;
    1: }
    1: 
    1: #if JS_HAS_BLOCK_SCOPE
    1: 
40239: JSParseNode *
40860: Parser::letBlock(JSBool statement)
    1: {
    1:     JSParseNode *pn, *pnblock, *pnlet;
    1:     JSStmtInfo stmtInfo;
    1: 
40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_LET);
    1: 
    1:     /* Create the let binary node. */
40232:     pnlet = BinaryNode::create(tc);
    1:     if (!pnlet)
    1:         return NULL;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_LET);
    1: 
    1:     /* This is a let block or expression of the form: let (a, b, c) .... */
40239:     pnblock = PushLexicalScope(context, &tokenStream, tc, &stmtInfo);
    1:     if (!pnblock)
    1:         return NULL;
    1:     pn = pnblock;
    1:     pn->pn_expr = pnlet;
    1: 
40263:     pnlet->pn_left = variables(true);
    1:     if (!pnlet->pn_left)
    1:         return NULL;
27012:     pnlet->pn_left->pn_xflags = PNX_POPVAR;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_LET);
    1: 
40854:     if (statement && !tokenStream.matchToken(TOK_LC, TSF_OPERAND)) {
    1:         /*
54158:          * Strict mode eliminates a grammar ambiguity with unparenthesized
54158:          * LetExpressions in an ExpressionStatement. If followed immediately
54158:          * by an arguments list, it's ambiguous whether the let expression
54158:          * is the callee or the call is inside the let expression body.
54158:          *
54158:          * See bug 569464.
54158:          */
54158:         if (!ReportStrictModeError(context, &tokenStream, tc, pnlet,
54158:                                    JSMSG_STRICT_CODE_LET_EXPR_STMT)) {
54158:             return NULL;
54158:         }
54158: 
54158:         /*
    1:          * If this is really an expression in let statement guise, then we
    1:          * need to wrap the TOK_LET node in a TOK_SEMI node so that we pop
    1:          * the return value of the expression.
    1:          */
40232:         pn = UnaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_SEMI;
    1:         pn->pn_num = -1;
    1:         pn->pn_kid = pnblock;
    1: 
    1:         statement = JS_FALSE;
    1:     }
    1: 
    1:     if (statement) {
40263:         pnlet->pn_right = statements();
    1:         if (!pnlet->pn_right)
    1:             return NULL;
    1:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_LET);
    1:     } else {
    1:         /*
    1:          * Change pnblock's opcode to the variant that propagates the last
    1:          * result down after popping the block, and clear statement.
    1:          */
    1:         pnblock->pn_op = JSOP_LEAVEBLOCKEXPR;
40263:         pnlet->pn_right = assignExpr();
    1:         if (!pnlet->pn_right)
    1:             return NULL;
    1:     }
    1: 
27012:     PopStatement(tc);
    1:     return pn;
    1: }
    1: 
    1: #endif /* JS_HAS_BLOCK_SCOPE */
    1: 
27012: static bool
27012: PushBlocklikeStatement(JSStmtInfo *stmt, JSStmtType type, JSTreeContext *tc)
27012: {
27012:     js_PushStatement(tc, stmt, type, -1);
27012:     return GenerateBlockId(tc, stmt->blockid);
27012: }
27012: 
27012: static JSParseNode *
33754: NewBindingNode(JSAtom *atom, JSTreeContext *tc, bool let = false)
27012: {
27012:     JSParseNode *pn = NULL;
27012: 
27012:     JSAtomListElement *ale = tc->decls.lookup(atom);
27012:     if (ale) {
27012:         pn = ALE_DEFN(ale);
27012:         JS_ASSERT(!pn->isPlaceholder());
27012:     } else {
27012:         ale = tc->lexdeps.lookup(atom);
27012:         if (ale) {
27012:             pn = ALE_DEFN(ale);
27012:             JS_ASSERT(pn->isPlaceholder());
27012:         }
27012:     }
27012: 
27012:     if (pn) {
27012:         JS_ASSERT(pn->pn_defn);
27012: 
27012:         /*
27012:          * A let binding at top level becomes a var before we get here, so if
27012:          * pn and tc have the same blockid then that id must not be the bodyid.
27012:          * If pn is a forward placeholder definition from the same or a higher
27012:          * block then we claim it.
27012:          */
27012:         JS_ASSERT_IF(let && pn->pn_blockid == tc->blockid(),
27012:                      pn->pn_blockid != tc->bodyid);
27012: 
27012:         if (pn->isPlaceholder() && pn->pn_blockid >= (let ? tc->blockid() : tc->bodyid)) {
27012:             if (let)
27012:                 pn->pn_blockid = tc->blockid();
27012: 
40860:             tc->lexdeps.remove(tc->parser, atom);
27012:             return pn;
27012:         }
27012:     }
27012: 
27012:     /* Make a new node for this declarator name (or destructuring pattern). */
40232:     pn = NameNode::create(atom, tc);
27012:     if (!pn)
27012:         return NULL;
72073: 
72073:     if (atom == tc->parser->context->runtime->atomState.argumentsAtom)
72073:         tc->countArgumentsUse(pn);
72073: 
27012:     return pn;
27012: }
27012: 
40239: JSParseNode *
57728: Parser::switchStatement()
    1: {
    1:     JSParseNode *pn5, *saveBlock;
    1:     JSBool seenDefault = JS_FALSE;
    1: 
57728:     JSParseNode *pn = BinaryNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
    1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_SWITCH);
    1: 
    1:     /* pn1 points to the switch's discriminant. */
61058:     JSParseNode *pn1 = parenExpr();
    1:     if (!pn1)
    1:         return NULL;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_SWITCH);
    1:     MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_SWITCH);
    1: 
27012:     /*
27012:      * NB: we must push stmtInfo before calling GenerateBlockIdForStmtNode
27012:      * because that function states tc->topStmt->blockid.
27012:      */
57728:     JSStmtInfo stmtInfo;
27012:     js_PushStatement(tc, &stmtInfo, STMT_SWITCH, -1);
27012: 
    1:     /* pn2 is a list of case nodes. The default case has pn_left == NULL */
57728:     JSParseNode *pn2 = ListNode::create(tc);
    1:     if (!pn2)
    1:         return NULL;
27012:     pn2->makeEmpty();
27012:     if (!GenerateBlockIdForStmtNode(pn2, tc))
27012:         return NULL;
    1:     saveBlock = tc->blockNode;
    1:     tc->blockNode = pn2;
    1: 
57728:     TokenKind tt;
40354:     while ((tt = tokenStream.getToken()) != TOK_RC) {
57728:         JSParseNode *pn3;
    1:         switch (tt) {
    1:           case TOK_DEFAULT:
    1:             if (seenDefault) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_TOO_MANY_DEFAULTS);
    1:                 return NULL;
    1:             }
    1:             seenDefault = JS_TRUE;
 1577:             /* FALL THROUGH */
    1: 
    1:           case TOK_CASE:
57728:           {
40232:             pn3 = BinaryNode::create(tc);
    1:             if (!pn3)
    1:                 return NULL;
 1577:             if (tt == TOK_CASE) {
40263:                 pn3->pn_left = expr();
    1:                 if (!pn3->pn_left)
    1:                     return NULL;
    1:             }
27012:             pn2->append(pn3);
    1:             if (pn2->pn_count == JS_BIT(16)) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_TOO_MANY_CASES);
    1:                 return NULL;
    1:             }
    1:             break;
57728:           }
    1: 
    1:           case TOK_ERROR:
    1:             return NULL;
    1: 
    1:           default:
42671:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_SWITCH);
    1:             return NULL;
    1:         }
    1:         MUST_MATCH_TOKEN(TOK_COLON, JSMSG_COLON_AFTER_CASE);
    1: 
57728:         JSParseNode *pn4 = ListNode::create(tc);
    1:         if (!pn4)
    1:             return NULL;
    1:         pn4->pn_type = TOK_LC;
27012:         pn4->makeEmpty();
40854:         while ((tt = tokenStream.peekToken(TSF_OPERAND)) != TOK_RC &&
    1:                tt != TOK_CASE && tt != TOK_DEFAULT) {
    1:             if (tt == TOK_ERROR)
    1:                 return NULL;
40263:             pn5 = statement();
    1:             if (!pn5)
    1:                 return NULL;
    1:             pn4->pn_pos.end = pn5->pn_pos.end;
27012:             pn4->append(pn5);
40854:         }
    1: 
    1:         /* Fix the PN_LIST so it doesn't begin at the TOK_COLON. */
    1:         if (pn4->pn_head)
    1:             pn4->pn_pos.begin = pn4->pn_head->pn_pos.begin;
    1:         pn3->pn_pos.end = pn4->pn_pos.end;
    1:         pn3->pn_right = pn4;
    1:     }
    1: 
    1:     /*
    1:      * Handle the case where there was a let declaration in any case in
    1:      * the switch body, but not within an inner block.  If it replaced
    1:      * tc->blockNode with a new block node then we must refresh pn2 and
    1:      * then restore tc->blockNode.
    1:      */
    1:     if (tc->blockNode != pn2)
    1:         pn2 = tc->blockNode;
    1:     tc->blockNode = saveBlock;
27012:     PopStatement(tc);
    1: 
40270:     pn->pn_pos.end = pn2->pn_pos.end = tokenStream.currentToken().pos.end;
    1:     pn->pn_left = pn1;
    1:     pn->pn_right = pn2;
    1:     return pn;
    1: }
    1: 
57728: JSParseNode *
57728: Parser::forStatement()
    1: {
20413:     JSParseNode *pnseq = NULL;
    1: #if JS_HAS_BLOCK_SCOPE
20413:     JSParseNode *pnlet = NULL;
    1:     JSStmtInfo blockInfo;
    1: #endif
    1: 
    1:     /* A FOR node is binary, left is loop control and right is the body. */
57728:     JSParseNode *pn = BinaryNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
57728:     JSStmtInfo stmtInfo;
    1:     js_PushStatement(tc, &stmtInfo, STMT_FOR_LOOP, -1);
    1: 
15613:     pn->pn_op = JSOP_ITER;
15613:     pn->pn_iflags = 0;
40354:     if (tokenStream.matchToken(TOK_NAME)) {
40270:         if (tokenStream.currentToken().t_atom == context->runtime->atomState.eachAtom)
15613:             pn->pn_iflags = JSITER_FOREACH;
    1:         else
40354:             tokenStream.ungetToken();
    1:     }
    1: 
    1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_AFTER_FOR);
57728:     TokenKind tt = tokenStream.peekToken(TSF_OPERAND);
27012: 
27012: #if JS_HAS_BLOCK_SCOPE
27012:     bool let = false;
27012: #endif
27012: 
57728:     JSParseNode *pn1;
    1:     if (tt == TOK_SEMI) {
15613:         if (pn->pn_iflags & JSITER_FOREACH)
    1:             goto bad_for_each;
    1: 
    1:         /* No initializer -- set first kid of left sub-node to null. */
    1:         pn1 = NULL;
    1:     } else {
    1:         /*
    1:          * Set pn1 to a var list or an initializing expression.
    1:          *
    1:          * Set the TCF_IN_FOR_INIT flag during parsing of the first clause
    1:          * of the for statement.  This flag will be used by the RelExpr
    1:          * production; if it is set, then the 'in' keyword will not be
    1:          * recognized as an operator, leaving it available to be parsed as
    1:          * part of a for/in loop.
    1:          *
    1:          * A side effect of this restriction is that (unparenthesized)
    1:          * expressions involving an 'in' operator are illegal in the init
    1:          * clause of an ordinary for loop.
    1:          */
    1:         tc->flags |= TCF_IN_FOR_INIT;
    1:         if (tt == TOK_VAR) {
40354:             (void) tokenStream.getToken();
40263:             pn1 = variables(false);
    1: #if JS_HAS_BLOCK_SCOPE
    1:         } else if (tt == TOK_LET) {
27012:             let = true;
40354:             (void) tokenStream.getToken();
40354:             if (tokenStream.peekToken() == TOK_LP) {
40263:                 pn1 = letBlock(JS_FALSE);
    1:                 tt = TOK_LEXICALSCOPE;
    1:             } else {
40239:                 pnlet = PushLexicalScope(context, &tokenStream, tc, &blockInfo);
    1:                 if (!pnlet)
    1:                     return NULL;
 9976:                 blockInfo.flags |= SIF_FOR_BLOCK;
40263:                 pn1 = variables(false);
    1:             }
    1: #endif
    1:         } else {
40263:             pn1 = expr();
    1:         }
    1:         tc->flags &= ~TCF_IN_FOR_INIT;
    1:         if (!pn1)
    1:             return NULL;
    1:     }
    1: 
    1:     /*
    1:      * We can be sure that it's a for/in loop if there's still an 'in'
    1:      * keyword here, even if JavaScript recognizes 'in' as an operator,
    1:      * as we've excluded 'in' from being parsed in RelExpr by setting
    1:      * the TCF_IN_FOR_INIT flag in our JSTreeContext.
    1:      */
40354:     if (pn1 && tokenStream.matchToken(TOK_IN)) {
15613:         pn->pn_iflags |= JSITER_ENUMERATE;
    1:         stmtInfo.type = STMT_FOR_IN_LOOP;
    1: 
    1:         /* Check that the left side of the 'in' is valid. */
40320:         JS_ASSERT(!TokenKindIsDecl(tt) || PN_TYPE(pn1) == tt);
40320:         if (TokenKindIsDecl(tt)
    1:             ? (pn1->pn_count > 1 || pn1->pn_op == JSOP_DEFCONST
    1: #if JS_HAS_DESTRUCTURING
61450:                || (versionNumber() == JSVERSION_1_7 &&
15613:                    pn->pn_op == JSOP_ITER &&
15613:                    !(pn->pn_iflags & JSITER_FOREACH) &&
    1:                    (pn1->pn_head->pn_type == TOK_RC ||
    1:                     (pn1->pn_head->pn_type == TOK_RB &&
    1:                      pn1->pn_head->pn_count != 2) ||
    1:                     (pn1->pn_head->pn_type == TOK_ASSIGN &&
    1:                      (pn1->pn_head->pn_left->pn_type != TOK_RB ||
    1:                       pn1->pn_head->pn_left->pn_count != 2))))
    1: #endif
    1:               )
    1:             : (pn1->pn_type != TOK_NAME &&
    1:                pn1->pn_type != TOK_DOT &&
    1: #if JS_HAS_DESTRUCTURING
61450:                ((versionNumber() == JSVERSION_1_7 &&
15613:                  pn->pn_op == JSOP_ITER &&
15613:                  !(pn->pn_iflags & JSITER_FOREACH))
    1:                 ? (pn1->pn_type != TOK_RB || pn1->pn_count != 2)
    1:                 : (pn1->pn_type != TOK_RB && pn1->pn_type != TOK_RC)) &&
    1: #endif
    1:                pn1->pn_type != TOK_LP &&
    1: #if JS_HAS_XML_SUPPORT
    1:                (pn1->pn_type != TOK_UNARYOP ||
    1:                 pn1->pn_op != JSOP_XMLNAME) &&
    1: #endif
    1:                pn1->pn_type != TOK_LB)) {
42671:             reportErrorNumber(pn1, JSREPORT_ERROR, JSMSG_BAD_FOR_LEFTSIDE);
    1:             return NULL;
    1:         }
    1: 
20413:         /* pn2 points to the name or destructuring pattern on in's left. */
57728:         JSParseNode *pn2 = NULL;
27012:         uintN dflag = PND_ASSIGNED;
20413: 
40320:         if (TokenKindIsDecl(tt)) {
    1:             /* Tell js_EmitTree(TOK_VAR) that pn1 is part of a for/in. */
27012:             pn1->pn_xflags |= PNX_FORINVAR;
    1: 
    1:             /*
60541:              * Rewrite 'for (<decl> x = i in o)' where <decl> is 'var' or
60541:              * 'const' to hoist the initializer or the entire decl out of
60541:              * the loop head. TOK_VAR is the type for both 'var' and 'const'.
    1:              */
    1:             pn2 = pn1->pn_head;
27012:             if ((pn2->pn_type == TOK_NAME && pn2->maybeExpr())
20413: #if JS_HAS_DESTRUCTURING
20413:                 || pn2->pn_type == TOK_ASSIGN
20413: #endif
20413:                 ) {
60541: #if JS_HAS_BLOCK_SCOPE
60541:                 if (tt == TOK_LET) {
60541:                     reportErrorNumber(pn2, JSREPORT_ERROR, JSMSG_INVALID_FOR_IN_INIT);
60541:                     return NULL;
60541:                 }
60541: #endif /* JS_HAS_BLOCK_SCOPE */
60541: 
40232:                 pnseq = ListNode::create(tc);
20413:                 if (!pnseq)
20413:                     return NULL;
20413:                 pnseq->pn_type = TOK_SEQ;
20413:                 pnseq->pn_pos.begin = pn->pn_pos.begin;
27012: 
27012:                 dflag = PND_INITIALIZED;
27012: 
20413:                 /*
20413:                  * All of 'var x = i' is hoisted above 'for (x in o)',
20413:                  * so clear PNX_FORINVAR.
20413:                  *
20413:                  * Request JSOP_POP here since the var is for a simple
20413:                  * name (it is not a destructuring binding's left-hand
20413:                  * side) and it has an initializer.
20413:                  */
27012:                 pn1->pn_xflags &= ~PNX_FORINVAR;
27012:                 pn1->pn_xflags |= PNX_POPVAR;
27012:                 pnseq->initList(pn1);
20413: 
20413: #if JS_HAS_DESTRUCTURING
20413:                 if (pn2->pn_type == TOK_ASSIGN) {
27012:                     pn1 = CloneParseTree(pn2->pn_left, tc);
20413:                     if (!pn1)
20413:                         return NULL;
20413:                 } else
20413: #endif
20413:                 {
27012:                     JS_ASSERT(pn2->pn_type == TOK_NAME);
40232:                     pn1 = NameNode::create(pn2->pn_atom, tc);
20413:                     if (!pn1)
20413:                         return NULL;
20413:                     pn1->pn_type = TOK_NAME;
20413:                     pn1->pn_op = JSOP_NAME;
20413:                     pn1->pn_pos = pn2->pn_pos;
27012:                     if (pn2->pn_defn)
27012:                         LinkUseToDef(pn1, (JSDefinition *) pn2, tc);
20413:                 }
20413:                 pn2 = pn1;
20413:             }
20413:         }
20413: 
20413:         if (!pn2) {
    1:             pn2 = pn1;
 1577:             if (pn2->pn_type == TOK_LP &&
40239:                 !MakeSetCall(context, pn2, tc, JSMSG_BAD_LEFTSIDE_OF_ASS)) {
 1577:                 return NULL;
 1577:             }
    1: #if JS_HAS_XML_SUPPORT
    1:             if (pn2->pn_type == TOK_UNARYOP)
    1:                 pn2->pn_op = JSOP_BINDXMLNAME;
    1: #endif
    1:         }
    1: 
    1:         switch (pn2->pn_type) {
    1:           case TOK_NAME:
    1:             /* Beware 'for (arguments in ...)' with or without a 'var'. */
40239:             NoteLValue(context, pn2, tc, dflag);
    1:             break;
    1: 
    1: #if JS_HAS_DESTRUCTURING
    1:           case TOK_ASSIGN:
    1:             pn2 = pn2->pn_left;
    1:             JS_ASSERT(pn2->pn_type == TOK_RB || pn2->pn_type == TOK_RC);
    1:             /* FALL THROUGH */
    1:           case TOK_RB:
    1:           case TOK_RC:
    1:             /* Check for valid lvalues in var-less destructuring for-in. */
68922:             if (pn1 == pn2 && !CheckDestructuring(context, NULL, pn2, tc))
40239:                 return NULL;
40239: 
61450:             if (versionNumber() == JSVERSION_1_7) {
 1599:                 /*
 1599:                  * Destructuring for-in requires [key, value] enumeration
 1599:                  * in JS1.7.
 1599:                  */
15613:                 JS_ASSERT(pn->pn_op == JSOP_ITER);
15613:                 if (!(pn->pn_iflags & JSITER_FOREACH))
15613:                     pn->pn_iflags |= JSITER_FOREACH | JSITER_KEYVALUE;
 1599:             }
    1:             break;
    1: #endif
    1: 
    1:           default:;
    1:         }
    1: 
27012:         /*
27012:          * Parse the object expression as the right operand of 'in', first
27012:          * removing the top statement from the statement-stack if this is a
27012:          * 'for (let x in y)' loop.
27012:          */
27012: #if JS_HAS_BLOCK_SCOPE
27012:         JSStmtInfo *save = tc->topStmt;
27012:         if (let)
27012:             tc->topStmt = save->down;
27012: #endif
40263:         pn2 = expr();
27012: #if JS_HAS_BLOCK_SCOPE
27012:         if (let)
27012:             tc->topStmt = save;
27012: #endif
27012: 
40232:         pn2 = JSParseNode::newBinaryOrAppend(TOK_IN, JSOP_NOP, pn1, pn2, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_left = pn2;
    1:     } else {
15613:         if (pn->pn_iflags & JSITER_FOREACH)
    1:             goto bad_for_each;
    1:         pn->pn_op = JSOP_NOP;
    1: 
    1:         /* Parse the loop condition or null into pn2. */
    1:         MUST_MATCH_TOKEN(TOK_SEMI, JSMSG_SEMI_AFTER_FOR_INIT);
40854:         tt = tokenStream.peekToken(TSF_OPERAND);
57728:         JSParseNode *pn2;
    1:         if (tt == TOK_SEMI) {
    1:             pn2 = NULL;
    1:         } else {
40263:             pn2 = expr();
    1:             if (!pn2)
    1:                 return NULL;
    1:         }
    1: 
    1:         /* Parse the update expression or null into pn3. */
    1:         MUST_MATCH_TOKEN(TOK_SEMI, JSMSG_SEMI_AFTER_FOR_COND);
40854:         tt = tokenStream.peekToken(TSF_OPERAND);
57728:         JSParseNode *pn3;
    1:         if (tt == TOK_RP) {
    1:             pn3 = NULL;
    1:         } else {
40263:             pn3 = expr();
    1:             if (!pn3)
    1:                 return NULL;
    1:         }
    1: 
20902:         /* Build the FORHEAD node to use as the left kid of pn. */
57728:         JSParseNode *pn4 = TernaryNode::create(tc);
    1:         if (!pn4)
    1:             return NULL;
20902:         pn4->pn_type = TOK_FORHEAD;
    1:         pn4->pn_op = JSOP_NOP;
    1:         pn4->pn_kid1 = pn1;
    1:         pn4->pn_kid2 = pn2;
    1:         pn4->pn_kid3 = pn3;
    1:         pn->pn_left = pn4;
    1:     }
    1: 
    1:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_FOR_CTRL);
    1: 
    1:     /* Parse the loop body into pn->pn_right. */
57728:     JSParseNode *pn2;
40263:     pn2 = statement();
    1:     if (!pn2)
    1:         return NULL;
    1:     pn->pn_right = pn2;
    1: 
    1:     /* Record the absolute line number for source note emission. */
    1:     pn->pn_pos.end = pn2->pn_pos.end;
    1: 
    1: #if JS_HAS_BLOCK_SCOPE
    1:     if (pnlet) {
27012:         PopStatement(tc);
    1:         pnlet->pn_expr = pn;
    1:         pn = pnlet;
    1:     }
    1: #endif
20413:     if (pnseq) {
20413:         pnseq->pn_pos.end = pn->pn_pos.end;
27012:         pnseq->append(pn);
20413:         pn = pnseq;
20413:     }
27012:     PopStatement(tc);
    1:     return pn;
    1: 
    1:   bad_for_each:
42671:     reportErrorNumber(pn, JSREPORT_ERROR, JSMSG_BAD_FOR_EACH_LOOP);
    1:     return NULL;
    1: }
    1: 
57728: JSParseNode *
57728: Parser::tryStatement()
57728: {
    1:     JSParseNode *catchList, *lastCatch;
    1: 
    1:     /*
    1:      * try nodes are ternary.
40239:      * kid1 is the try statement
    1:      * kid2 is the catch node list or null
40239:      * kid3 is the finally statement
    1:      *
    1:      * catch nodes are ternary.
    1:      * kid1 is the lvalue (TOK_NAME, TOK_LB, or TOK_LC)
    1:      * kid2 is the catch guard or null if no guard
    1:      * kid3 is the catch block
    1:      *
    1:      * catch lvalue nodes are either:
    1:      *   TOK_NAME for a single identifier
    1:      *   TOK_RB or TOK_RC for a destructuring left-hand side
    1:      *
40239:      * finally nodes are TOK_LC statement lists.
40221:      */
57728:     JSParseNode *pn = TernaryNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
    1:     pn->pn_op = JSOP_NOP;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_TRY);
57728:     JSStmtInfo stmtInfo;
27012:     if (!PushBlocklikeStatement(&stmtInfo, STMT_TRY, tc))
27012:         return NULL;
40263:     pn->pn_kid1 = statements();
    1:     if (!pn->pn_kid1)
    1:         return NULL;
    1:     MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_TRY);
27012:     PopStatement(tc);
    1: 
    1:     catchList = NULL;
57728:     TokenKind tt = tokenStream.getToken();
    1:     if (tt == TOK_CATCH) {
40232:         catchList = ListNode::create(tc);
    1:         if (!catchList)
    1:             return NULL;
    1:         catchList->pn_type = TOK_RESERVED;
27012:         catchList->makeEmpty();
    1:         lastCatch = NULL;
    1: 
    1:         do {
    1:             JSParseNode *pnblock;
    1:             BindData data;
    1: 
    1:             /* Check for another catch after unconditional catch. */
    1:             if (lastCatch && !lastCatch->pn_kid2) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_CATCH_AFTER_GENERAL);
    1:                 return NULL;
    1:             }
    1: 
    1:             /*
    1:              * Create a lexical scope node around the whole catch clause,
    1:              * including the head.
    1:              */
40239:             pnblock = PushLexicalScope(context, &tokenStream, tc, &stmtInfo);
    1:             if (!pnblock)
    1:                 return NULL;
    1:             stmtInfo.type = STMT_CATCH;
    1: 
    1:             /*
    1:              * Legal catch forms are:
    1:              *   catch (lhs)
    1:              *   catch (lhs if <boolean_expression>)
    1:              * where lhs is a name or a destructuring left-hand side.
    1:              * (the latter is legal only #ifdef JS_HAS_CATCH_GUARD)
    1:              */
57728:             JSParseNode *pn2 = TernaryNode::create(tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:             pnblock->pn_expr = pn2;
    1:             MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_CATCH);
    1: 
    1:             /*
    1:              * Contrary to ECMA Ed. 3, the catch variable is lexically
    1:              * scoped, not a property of a new Object instance.  This is
    1:              * an intentional change that anticipates ECMA Ed. 4.
    1:              */
    1:             data.pn = NULL;
    1:             data.op = JSOP_NOP;
    1:             data.binder = BindLet;
27012:             data.let.overflow = JSMSG_TOO_MANY_CATCH_VARS;
    1: 
40354:             tt = tokenStream.getToken();
57728:             JSParseNode *pn3;
    1:             switch (tt) {
    1: #if JS_HAS_DESTRUCTURING
    1:               case TOK_LB:
    1:               case TOK_LC:
40263:                 pn3 = destructuringExpr(&data, tt);
    1:                 if (!pn3)
    1:                     return NULL;
    1:                 break;
    1: #endif
    1: 
    1:               case TOK_NAME:
57728:               {
57728:                 JSAtom *label = tokenStream.currentToken().t_atom;
33754:                 pn3 = NewBindingNode(label, tc, true);
27012:                 if (!pn3)
27012:                     return NULL;
27012:                 data.pn = pn3;
40239:                 if (!data.binder(context, &data, label, tc))
26970:                     return NULL;
    1:                 break;
57728:               }
    1: 
    1:               default:
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_CATCH_IDENTIFIER);
    1:                 return NULL;
    1:             }
    1: 
    1:             pn2->pn_kid1 = pn3;
    1: #if JS_HAS_CATCH_GUARD
    1:             /*
    1:              * We use 'catch (x if x === 5)' (not 'catch (x : x === 5)')
    1:              * to avoid conflicting with the JS2/ECMAv4 type annotation
    1:              * catchguard syntax.
    1:              */
40354:             if (tokenStream.matchToken(TOK_IF)) {
40263:                 pn2->pn_kid2 = expr();
    1:                 if (!pn2->pn_kid2)
    1:                     return NULL;
    1:             }
    1: #endif
    1:             MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_CATCH);
    1: 
    1:             MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_CATCH);
40263:             pn2->pn_kid3 = statements();
    1:             if (!pn2->pn_kid3)
    1:                 return NULL;
    1:             MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_CATCH);
27012:             PopStatement(tc);
27012: 
27012:             catchList->append(pnblock);
    1:             lastCatch = pn2;
40854:             tt = tokenStream.getToken(TSF_OPERAND);
    1:         } while (tt == TOK_CATCH);
    1:     }
    1:     pn->pn_kid2 = catchList;
    1: 
    1:     if (tt == TOK_FINALLY) {
    1:         MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_FINALLY);
27012:         if (!PushBlocklikeStatement(&stmtInfo, STMT_FINALLY, tc))
27012:             return NULL;
40263:         pn->pn_kid3 = statements();
    1:         if (!pn->pn_kid3)
    1:             return NULL;
    1:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_FINALLY);
27012:         PopStatement(tc);
    1:     } else {
40354:         tokenStream.ungetToken();
    1:     }
    1:     if (!catchList && !pn->pn_kid3) {
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_CATCH_OR_FINALLY);
    1:         return NULL;
    1:     }
    1:     return pn;
    1: }
    1: 
57728: JSParseNode *
57728: Parser::withStatement()
52554: {
35305:     /*
35305:      * In most cases, we want the constructs forbidden in strict mode
35305:      * code to be a subset of those that JSOPTION_STRICT warns about, and
40320:      * we should use ReportStrictModeError.  However, 'with' is the sole
35305:      * instance of a construct that is forbidden in strict mode code, but
35305:      * doesn't even merit a warning under JSOPTION_STRICT.  See
35305:      * https://bugzilla.mozilla.org/show_bug.cgi?id=514576#c1.
35305:      */
35305:     if (tc->flags & TCF_STRICT_MODE_CODE) {
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_STRICT_CODE_WITH);
35305:         return NULL;
35305:     }
35305: 
57728:     JSParseNode *pn = BinaryNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
    1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_WITH);
61058:     JSParseNode *pn2 = parenExpr();
    1:     if (!pn2)
    1:         return NULL;
    1:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_WITH);
    1:     pn->pn_left = pn2;
    1: 
52554:     JSParseNode *oldWith = tc->innermostWith;
52554:     tc->innermostWith = pn;
52554: 
57728:     JSStmtInfo stmtInfo;
    1:     js_PushStatement(tc, &stmtInfo, STMT_WITH, -1);
40263:     pn2 = statement();
    1:     if (!pn2)
    1:         return NULL;
27012:     PopStatement(tc);
    1: 
    1:     pn->pn_pos.end = pn2->pn_pos.end;
    1:     pn->pn_right = pn2;
    1:     tc->flags |= TCF_FUN_HEAVYWEIGHT;
52554:     tc->innermostWith = oldWith;
52554: 
52554:     /*
52554:      * Make sure to deoptimize lexical dependencies inside the |with|
52554:      * to safely optimize binding globals (see bug 561923).
52554:      */
52554:     JSAtomListIterator iter(&tc->lexdeps);
52554:     while (JSAtomListElement *ale = iter()) {
52554:         JSDefinition *lexdep = ALE_DEFN(ale)->resolve();
52554:         DeoptimizeUsesWithin(lexdep, pn->pn_pos);
52554:     }
52554: 
    1:     return pn;
52554: }
    1: 
    1: #if JS_HAS_BLOCK_SCOPE
57728: JSParseNode *
57728: Parser::letStatement()
    1: {
27012:     JSObjectBox *blockbox;
    1: 
57728:     JSParseNode *pn;
57728:     do {
    1:         /* Check for a let statement or let expression. */
40354:         if (tokenStream.peekToken() == TOK_LP) {
40263:             pn = letBlock(JS_TRUE);
    1:             if (!pn || pn->pn_op == JSOP_LEAVEBLOCK)
    1:                 return pn;
    1: 
    1:             /* Let expressions require automatic semicolon insertion. */
    1:             JS_ASSERT(pn->pn_type == TOK_SEMI ||
    1:                       pn->pn_op == JSOP_LEAVEBLOCKEXPR);
    1:             break;
    1:         }
    1: 
    1:         /*
 9976:          * This is a let declaration. We must be directly under a block per
 9976:          * the proposed ES4 specs, but not an implicit block created due to
 9976:          * 'for (let ...)'. If we pass this error test, make the enclosing
 9976:          * JSStmtInfo be our scope. Further let declarations in this block
 9976:          * will find this scope statement and use the same block object.
 9976:          *
 9976:          * If we are the first let declaration in this block (i.e., when the
 9976:          * enclosing maybe-scope JSStmtInfo isn't yet a scope statement) then
 9976:          * we also need to set tc->blockNode to be our TOK_LEXICALSCOPE.
    1:          */
57728:         JSStmtInfo *stmt = tc->topStmt;
 9976:         if (stmt &&
 9976:             (!STMT_MAYBE_SCOPE(stmt) || (stmt->flags & SIF_FOR_BLOCK))) {
42671:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_LET_DECL_NOT_IN_BLOCK);
 9832:             return NULL;
    1:         }
    1: 
    1:         if (stmt && (stmt->flags & SIF_SCOPE)) {
54855:             JS_ASSERT(tc->blockChainBox == stmt->blockBox);
    1:         } else {
16379:             if (!stmt || (stmt->flags & SIF_BODY_BLOCK)) {
    1:                 /*
16379:                  * ES4 specifies that let at top level and at body-block scope
16379:                  * does not shadow var, so convert back to var.
    1:                  */
40854:                 tokenStream.mungeCurrentToken(TOK_VAR, JSOP_DEFVAR);
40239: 
40263:                 pn = variables(false);
    1:                 if (!pn)
    1:                     return NULL;
27012:                 pn->pn_xflags |= PNX_POPVAR;
    1:                 break;
    1:             }
    1: 
18084:             /*
18084:              * Some obvious assertions here, but they may help clarify the
18084:              * situation. This stmt is not yet a scope, so it must not be a
27012:              * catch block (catch is a lexical scope by definition).
18084:              */
18084:             JS_ASSERT(!(stmt->flags & SIF_SCOPE));
18084:             JS_ASSERT(stmt != tc->topScopeStmt);
18084:             JS_ASSERT(stmt->type == STMT_BLOCK ||
18084:                       stmt->type == STMT_SWITCH ||
18084:                       stmt->type == STMT_TRY ||
18084:                       stmt->type == STMT_FINALLY);
18084:             JS_ASSERT(!stmt->downScope);
18084: 
    1:             /* Convert the block statement into a scope statement. */
40860:             JSObject *obj = js_NewBlockObject(tc->parser->context);
    1:             if (!obj)
    1:                 return NULL;
27012: 
40860:             blockbox = tc->parser->newObjectBox(obj);
27012:             if (!blockbox)
    1:                 return NULL;
    1: 
    1:             /*
    1:              * Insert stmt on the tc->topScopeStmt/stmtInfo.downScope linked
    1:              * list stack, if it isn't already there.  If it is there, but it
    1:              * lacks the SIF_SCOPE flag, it must be a try, catch, or finally
    1:              * block.
    1:              */
    1:             stmt->flags |= SIF_SCOPE;
 9832:             stmt->downScope = tc->topScopeStmt;
 9832:             tc->topScopeStmt = stmt;
    1: 
54855:             obj->setParent(tc->blockChain());
56177:             blockbox->parent = tc->blockChainBox;
54855:             tc->blockChainBox = blockbox;
54855:             stmt->blockBox = blockbox;
    1: 
    1: #ifdef DEBUG
57728:             JSParseNode *tmp = tc->blockNode;
57728:             JS_ASSERT(!tmp || tmp->pn_type != TOK_LEXICALSCOPE);
    1: #endif
    1: 
    1:             /* Create a new lexical scope node for these statements. */
57728:             JSParseNode *pn1 = LexicalScopeNode::create(tc);
    1:             if (!pn1)
    1:                 return NULL;
    1: 
    1:             pn1->pn_type = TOK_LEXICALSCOPE;
    1:             pn1->pn_op = JSOP_LEAVEBLOCK;
    1:             pn1->pn_pos = tc->blockNode->pn_pos;
27012:             pn1->pn_objbox = blockbox;
    1:             pn1->pn_expr = tc->blockNode;
27012:             pn1->pn_blockid = tc->blockNode->pn_blockid;
    1:             tc->blockNode = pn1;
    1:         }
    1: 
40263:         pn = variables(false);
    1:         if (!pn)
    1:             return NULL;
27012:         pn->pn_xflags = PNX_POPVAR;
57728:     } while (0);
57728: 
57728:     /* Check termination of this primitive statement. */
57728:     return MatchOrInsertSemicolon(context, &tokenStream) ? pn : NULL;
57728: }
    1: #endif
    1: 
57728: JSParseNode *
57728: Parser::expressionStatement()
57728: {
40354:     tokenStream.ungetToken();
57728:     JSParseNode *pn2 = expr();
    1:     if (!pn2)
    1:         return NULL;
    1: 
40354:     if (tokenStream.peekToken() == TOK_COLON) {
    1:         if (pn2->pn_type != TOK_NAME) {
42671:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_LABEL);
    1:             return NULL;
    1:         }
57728:         JSAtom *label = pn2->pn_atom;
57728:         for (JSStmtInfo *stmt = tc->topStmt; stmt; stmt = stmt->down) {
27012:             if (stmt->type == STMT_LABEL && stmt->label == label) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_DUPLICATE_LABEL);
    1:                 return NULL;
    1:             }
    1:         }
27012:         ForgetUse(pn2);
27012: 
40354:         (void) tokenStream.getToken();
    1: 
    1:         /* Push a label struct and parse the statement. */
57728:         JSStmtInfo stmtInfo;
    1:         js_PushStatement(tc, &stmtInfo, STMT_LABEL, -1);
27012:         stmtInfo.label = label;
57728:         JSParseNode *pn = statement();
    1:         if (!pn)
    1:             return NULL;
    1: 
    1:         /* Normalize empty statement to empty block for the decompiler. */
    1:         if (pn->pn_type == TOK_SEMI && !pn->pn_kid) {
    1:             pn->pn_type = TOK_LC;
    1:             pn->pn_arity = PN_LIST;
27012:             pn->makeEmpty();
    1:         }
    1: 
    1:         /* Pop the label, set pn_expr, and return early. */
27012:         PopStatement(tc);
    1:         pn2->pn_type = TOK_COLON;
    1:         pn2->pn_pos.end = pn->pn_pos.end;
    1:         pn2->pn_expr = pn;
    1:         return pn2;
    1:     }
    1: 
57728:     JSParseNode *pn = UnaryNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
    1:     pn->pn_type = TOK_SEMI;
    1:     pn->pn_pos = pn2->pn_pos;
    1:     pn->pn_kid = pn2;
32658: 
37685:     switch (PN_TYPE(pn2)) {
37685:       case TOK_LP:
37685:         /*
37685:          * Flag lambdas immediately applied as statements as instances of
37685:          * the JS "module pattern". See CheckForImmediatelyAppliedLambda.
37685:          */
37685:         if (PN_TYPE(pn2->pn_head) == TOK_FUNCTION &&
37685:             !pn2->pn_head->pn_funbox->node->isFunArg()) {
38549:             pn2->pn_head->pn_funbox->tcflags |= TCF_FUN_MODULE_PATTERN;
37685:         }
37685:         break;
37685:       case TOK_ASSIGN:
37685:         /*
37685:          * Keep track of all apparent methods created by assignments such
37685:          * as this.foo = function (...) {...} in a function that could end
40860:          * up a constructor function. See Parser::setFunctionKinds.
37685:          */
37685:         if (tc->funbox &&
37685:             PN_OP(pn2) == JSOP_NOP &&
32658:             PN_OP(pn2->pn_left) == JSOP_SETPROP &&
37685:             PN_OP(pn2->pn_left->pn_expr) == JSOP_THIS &&
37685:             PN_OP(pn2->pn_right) == JSOP_LAMBDA) {
37685:             JS_ASSERT(!pn2->pn_defn);
37685:             JS_ASSERT(!pn2->pn_used);
37685:             pn2->pn_right->pn_link = tc->funbox->methods;
37685:             tc->funbox->methods = pn2->pn_right;
37685:         }
37685:         break;
37685:       default:;
32658:     }
57728: 
57728:     /* Check termination of this primitive statement. */
57728:     return MatchOrInsertSemicolon(context, &tokenStream) ? pn : NULL;
57728: }
57728: 
57728: JSParseNode *
57728: Parser::statement()
57728: {
57728:     JSParseNode *pn;
57728: 
57728:     JS_CHECK_RECURSION(context, return NULL);
57728: 
57728:     switch (tokenStream.getToken(TSF_OPERAND)) {
57728:       case TOK_FUNCTION:
57728:       {
57728: #if JS_HAS_XML_SUPPORT
57728:         TokenKind tt = tokenStream.peekToken(TSF_KEYWORD_IS_NAME);
57728:         if (tt == TOK_DBLCOLON)
57728:             goto expression;
57728: #endif
57728:         return functionStmt();
57728:       }
57728: 
57728:       case TOK_IF:
57728:       {
57728:         /* An IF node has three kids: condition, then, and optional else. */
57728:         pn = TernaryNode::create(tc);
57728:         if (!pn)
57728:             return NULL;
57728:         JSParseNode *pn1 = condition();
57728:         if (!pn1)
57728:             return NULL;
57728:         JSStmtInfo stmtInfo;
57728:         js_PushStatement(tc, &stmtInfo, STMT_IF, -1);
57728:         JSParseNode *pn2 = statement();
57728:         if (!pn2)
57728:             return NULL;
57728:         JSParseNode *pn3;
57728:         if (tokenStream.matchToken(TOK_ELSE, TSF_OPERAND)) {
57728:             stmtInfo.type = STMT_ELSE;
57728:             pn3 = statement();
57728:             if (!pn3)
57728:                 return NULL;
57728:             pn->pn_pos.end = pn3->pn_pos.end;
57728:         } else {
57728:             pn3 = NULL;
57728:             pn->pn_pos.end = pn2->pn_pos.end;
57728:         }
57728:         PopStatement(tc);
57728:         pn->pn_kid1 = pn1;
57728:         pn->pn_kid2 = pn2;
57728:         pn->pn_kid3 = pn3;
57728:         return pn;
57728:       }
57728: 
57728:       case TOK_SWITCH:
57728:         return switchStatement();
57728: 
57728:       case TOK_WHILE:
57728:       {
57728:         pn = BinaryNode::create(tc);
57728:         if (!pn)
57728:             return NULL;
57728:         JSStmtInfo stmtInfo;
57728:         js_PushStatement(tc, &stmtInfo, STMT_WHILE_LOOP, -1);
57728:         JSParseNode *pn2 = condition();
57728:         if (!pn2)
57728:             return NULL;
57728:         pn->pn_left = pn2;
57728:         JSParseNode *pn3 = statement();
57728:         if (!pn3)
57728:             return NULL;
57728:         PopStatement(tc);
57728:         pn->pn_pos.end = pn3->pn_pos.end;
57728:         pn->pn_right = pn3;
57728:         return pn;
57728:       }
57728: 
57728:       case TOK_DO:
57728:       {
57728:         pn = BinaryNode::create(tc);
57728:         if (!pn)
57728:             return NULL;
57728:         JSStmtInfo stmtInfo;
57728:         js_PushStatement(tc, &stmtInfo, STMT_DO_LOOP, -1);
57728:         JSParseNode *pn2 = statement();
57728:         if (!pn2)
57728:             return NULL;
57728:         pn->pn_left = pn2;
57728:         MUST_MATCH_TOKEN(TOK_WHILE, JSMSG_WHILE_AFTER_DO);
57728:         JSParseNode *pn3 = condition();
57728:         if (!pn3)
57728:             return NULL;
57728:         PopStatement(tc);
57728:         pn->pn_pos.end = pn3->pn_pos.end;
57728:         pn->pn_right = pn3;
61450:         if (versionNumber() != JSVERSION_ECMA_3) {
57728:             /*
57728:              * All legacy and extended versions must do automatic semicolon
57728:              * insertion after do-while.  See the testcase and discussion in
57728:              * http://bugzilla.mozilla.org/show_bug.cgi?id=238945.
57728:              */
57728:             (void) tokenStream.matchToken(TOK_SEMI);
57728:             return pn;
57728:         }
57728:         break;
57728:       }
57728: 
57728:       case TOK_FOR:
57728:         return forStatement();
57728: 
57728:       case TOK_TRY:
57728:         return tryStatement();
57728: 
57728:       case TOK_THROW:
57728:       {
57728:         pn = UnaryNode::create(tc);
57728:         if (!pn)
57728:             return NULL;
57728: 
57728:         /* ECMA-262 Edition 3 says 'throw [no LineTerminator here] Expr'. */
57728:         TokenKind tt = tokenStream.peekTokenSameLine(TSF_OPERAND);
57728:         if (tt == TOK_ERROR)
57728:             return NULL;
57728:         if (tt == TOK_EOF || tt == TOK_EOL || tt == TOK_SEMI || tt == TOK_RC) {
57728:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_SYNTAX_ERROR);
57728:             return NULL;
57728:         }
57728: 
57728:         JSParseNode *pn2 = expr();
57728:         if (!pn2)
57728:             return NULL;
57728:         pn->pn_pos.end = pn2->pn_pos.end;
57728:         pn->pn_op = JSOP_THROW;
57728:         pn->pn_kid = pn2;
57728:         break;
57728:       }
57728: 
57728:       /* TOK_CATCH and TOK_FINALLY are both handled in the TOK_TRY case */
57728:       case TOK_CATCH:
57728:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_CATCH_WITHOUT_TRY);
57728:         return NULL;
57728: 
57728:       case TOK_FINALLY:
57728:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_FINALLY_WITHOUT_TRY);
57728:         return NULL;
57728: 
57728:       case TOK_BREAK:
57728:       {
57728:         pn = NullaryNode::create(tc);
57728:         if (!pn)
57728:             return NULL;
57728:         if (!MatchLabel(context, &tokenStream, pn))
57728:             return NULL;
57728:         JSStmtInfo *stmt = tc->topStmt;
57728:         JSAtom *label = pn->pn_atom;
57728:         if (label) {
57728:             for (; ; stmt = stmt->down) {
57728:                 if (!stmt) {
57728:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_LABEL_NOT_FOUND);
57728:                     return NULL;
57728:                 }
57728:                 if (stmt->type == STMT_LABEL && stmt->label == label)
57728:                     break;
57728:             }
57728:         } else {
57728:             for (; ; stmt = stmt->down) {
57728:                 if (!stmt) {
57728:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_TOUGH_BREAK);
57728:                     return NULL;
57728:                 }
57728:                 if (STMT_IS_LOOP(stmt) || stmt->type == STMT_SWITCH)
57728:                     break;
57728:             }
57728:         }
57728:         if (label)
57728:             pn->pn_pos.end = tokenStream.currentToken().pos.end;
57728:         break;
57728:       }
57728: 
57728:       case TOK_CONTINUE:
57728:       {
57728:         pn = NullaryNode::create(tc);
57728:         if (!pn)
57728:             return NULL;
57728:         if (!MatchLabel(context, &tokenStream, pn))
57728:             return NULL;
57728:         JSStmtInfo *stmt = tc->topStmt;
57728:         JSAtom *label = pn->pn_atom;
57728:         if (label) {
57728:             for (JSStmtInfo *stmt2 = NULL; ; stmt = stmt->down) {
57728:                 if (!stmt) {
57728:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_LABEL_NOT_FOUND);
57728:                     return NULL;
57728:                 }
57728:                 if (stmt->type == STMT_LABEL) {
57728:                     if (stmt->label == label) {
57728:                         if (!stmt2 || !STMT_IS_LOOP(stmt2)) {
57728:                             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_CONTINUE);
57728:                             return NULL;
57728:                         }
57728:                         break;
57728:                     }
57728:                 } else {
57728:                     stmt2 = stmt;
57728:                 }
57728:             }
57728:         } else {
57728:             for (; ; stmt = stmt->down) {
57728:                 if (!stmt) {
57728:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_CONTINUE);
57728:                     return NULL;
57728:                 }
57728:                 if (STMT_IS_LOOP(stmt))
57728:                     break;
57728:             }
57728:         }
57728:         if (label)
57728:             pn->pn_pos.end = tokenStream.currentToken().pos.end;
57728:         break;
57728:       }
57728: 
57728:       case TOK_WITH:
57728:         return withStatement();
57728: 
57728:       case TOK_VAR:
57728:         pn = variables(false);
57728:         if (!pn)
57728:             return NULL;
57728: 
57728:         /* Tell js_EmitTree to generate a final POP. */
57728:         pn->pn_xflags |= PNX_POPVAR;
57728:         break;
57728: 
57728: #if JS_HAS_BLOCK_SCOPE
57728:       case TOK_LET:
57728:         return letStatement();
57728: #endif /* JS_HAS_BLOCK_SCOPE */
57728: 
57728:       case TOK_RETURN:
57728:         pn = returnOrYield(false);
57728:         if (!pn)
57728:             return NULL;
57728:         break;
57728: 
57728:       case TOK_LC:
57728:       {
57728:         uintN oldflags;
57728: 
57728:         oldflags = tc->flags;
57728:         tc->flags = oldflags & ~TCF_HAS_FUNCTION_STMT;
57728:         JSStmtInfo stmtInfo;
57728:         if (!PushBlocklikeStatement(&stmtInfo, STMT_BLOCK, tc))
57728:             return NULL;
57728:         pn = statements();
57728:         if (!pn)
57728:             return NULL;
57728: 
57728:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_IN_COMPOUND);
57728:         PopStatement(tc);
57728: 
57728:         /*
57728:          * If we contain a function statement and our container is top-level
57728:          * or another block, flag pn to preserve braces when decompiling.
57728:          */
57728:         if ((tc->flags & TCF_HAS_FUNCTION_STMT) &&
57728:             (!tc->topStmt || tc->topStmt->type == STMT_BLOCK)) {
57728:             pn->pn_xflags |= PNX_NEEDBRACES;
57728:         }
57728:         tc->flags = oldflags | (tc->flags & (TCF_FUN_FLAGS | TCF_RETURN_FLAGS));
57728:         return pn;
57728:       }
57728: 
57728:       case TOK_SEMI:
57728:         pn = UnaryNode::create(tc);
57728:         if (!pn)
57728:             return NULL;
57728:         pn->pn_type = TOK_SEMI;
57728:         return pn;
57728: 
57728:       case TOK_DEBUGGER:
57728:         pn = NullaryNode::create(tc);
57728:         if (!pn)
57728:             return NULL;
57728:         pn->pn_type = TOK_DEBUGGER;
57728:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
57728:         break;
57728: 
57728: #if JS_HAS_XML_SUPPORT
57728:       case TOK_DEFAULT:
57728:       {
57728:         pn = UnaryNode::create(tc);
57728:         if (!pn)
57728:             return NULL;
57728:         if (!tokenStream.matchToken(TOK_NAME) ||
57728:             tokenStream.currentToken().t_atom != context->runtime->atomState.xmlAtom ||
57728:             !tokenStream.matchToken(TOK_NAME) ||
57728:             tokenStream.currentToken().t_atom != context->runtime->atomState.namespaceAtom ||
57728:             !tokenStream.matchToken(TOK_ASSIGN) ||
57728:             tokenStream.currentToken().t_op != JSOP_NOP) {
57728:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_DEFAULT_XML_NAMESPACE);
57728:             return NULL;
57728:         }
57728: 
57728:         /* Is this an E4X dagger I see before me? */
57728:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
57728:         JSParseNode *pn2 = expr();
57728:         if (!pn2)
57728:             return NULL;
57728:         pn->pn_op = JSOP_DEFXMLNS;
57728:         pn->pn_pos.end = pn2->pn_pos.end;
57728:         pn->pn_kid = pn2;
57728:         break;
57728:       }
57728: #endif
57728: 
57728:       case TOK_ERROR:
57728:         return NULL;
57728: 
57728:       default:
57728: #if JS_HAS_XML_SUPPORT
57728:       expression:
57728: #endif
57728:         return expressionStatement();
    1:     }
    1: 
    1:     /* Check termination of this primitive statement. */
40239:     return MatchOrInsertSemicolon(context, &tokenStream) ? pn : NULL;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::variables(bool inLetHead)
40221: {
40320:     TokenKind tt;
27012:     bool let;
    1:     JSStmtInfo *scopeStmt;
    1:     BindData data;
    1:     JSParseNode *pn, *pn2;
    1:     JSAtom *atom;
    1: 
    1:     /*
    1:      * The three options here are:
    1:      * - TOK_LET: We are parsing a let declaration.
    1:      * - TOK_LP: We are parsing the head of a let block.
    1:      * - Otherwise, we're parsing var declarations.
    1:      */
40270:     tt = tokenStream.currentToken().type;
    1:     let = (tt == TOK_LET || tt == TOK_LP);
    1:     JS_ASSERT(let || tt == TOK_VAR);
    1: 
27012: #if JS_HAS_BLOCK_SCOPE
27012:     bool popScope = (inLetHead || (let && (tc->flags & TCF_IN_FOR_INIT)));
27012:     JSStmtInfo *save = tc->topStmt, *saveScope = tc->topScopeStmt;
27012: #endif
27012: 
40239:     /* Make sure that statement set up the tree context correctly. */
    1:     scopeStmt = tc->topScopeStmt;
    1:     if (let) {
    1:         while (scopeStmt && !(scopeStmt->flags & SIF_SCOPE)) {
    1:             JS_ASSERT(!STMT_MAYBE_SCOPE(scopeStmt));
    1:             scopeStmt = scopeStmt->downScope;
    1:         }
    1:         JS_ASSERT(scopeStmt);
    1:     }
    1: 
40270:     data.op = let ? JSOP_NOP : tokenStream.currentToken().t_op;
40232:     pn = ListNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
    1:     pn->pn_op = data.op;
27012:     pn->makeEmpty();
27012: 
27012:     /*
27012:      * SpiderMonkey const is really "write once per initialization evaluation"
27012:      * var, whereas let is block scoped. ES-Harmony wants block-scoped const so
27012:      * this code will change soon.
    1:      */
    1:     if (let) {
54855:         JS_ASSERT(tc->blockChainBox == scopeStmt->blockBox);
 8444:         data.binder = BindLet;
27012:         data.let.overflow = JSMSG_TOO_MANY_LOCALS;
    1:     } else {
 8444:         data.binder = BindVarOrConst;
    1:     }
    1: 
    1:     do {
40354:         tt = tokenStream.getToken();
    1: #if JS_HAS_DESTRUCTURING
    1:         if (tt == TOK_LB || tt == TOK_LC) {
33753:             tc->flags |= TCF_DECL_DESTRUCTURING;
40263:             pn2 = primaryExpr(tt, JS_FALSE);
33753:             tc->flags &= ~TCF_DECL_DESTRUCTURING;
    1:             if (!pn2)
    1:                 return NULL;
    1: 
68922:             if (!CheckDestructuring(context, &data, pn2, tc))
28995:                 return NULL;
    1:             if ((tc->flags & TCF_IN_FOR_INIT) &&
40354:                 tokenStream.peekToken() == TOK_IN) {
27012:                 pn->append(pn2);
    1:                 continue;
    1:             }
    1: 
    1:             MUST_MATCH_TOKEN(TOK_ASSIGN, JSMSG_BAD_DESTRUCT_DECL);
40270:             if (tokenStream.currentToken().t_op != JSOP_NOP)
    1:                 goto bad_var_init;
    1: 
27012: #if JS_HAS_BLOCK_SCOPE
27012:             if (popScope) {
27012:                 tc->topStmt = save->down;
27012:                 tc->topScopeStmt = saveScope->downScope;
27012:             }
27012: #endif
40263:             JSParseNode *init = assignExpr();
27012: #if JS_HAS_BLOCK_SCOPE
27012:             if (popScope) {
27012:                 tc->topStmt = save;
27012:                 tc->topScopeStmt = saveScope;
27012:             }
27012: #endif
27012: 
68923:             if (!init)
68923:                 return NULL;
68923:             UndominateInitializers(pn2, init->pn_pos.end, tc);
28995: 
40232:             pn2 = JSParseNode::newBinaryOrAppend(TOK_ASSIGN, JSOP_NOP, pn2, init, tc);
28995:             if (!pn2)
28995:                 return NULL;
27012:             pn->append(pn2);
    1:             continue;
    1:         }
27012: #endif /* JS_HAS_DESTRUCTURING */
    1: 
    1:         if (tt != TOK_NAME) {
27012:             if (tt != TOK_ERROR) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_NO_VARIABLE_NAME);
27012:             }
27012:             return NULL;
27012:         }
27012: 
40270:         atom = tokenStream.currentToken().t_atom;
33754:         pn2 = NewBindingNode(atom, tc, let);
27012:         if (!pn2)
27012:             return NULL;
27012:         if (data.op == JSOP_DEFCONST)
27012:             pn2->pn_dflags |= PND_CONST;
27012:         data.pn = pn2;
40239:         if (!data.binder(context, &data, atom, tc))
26970:             return NULL;
27012:         pn->append(pn2);
    1: 
40354:         if (tokenStream.matchToken(TOK_ASSIGN)) {
40270:             if (tokenStream.currentToken().t_op != JSOP_NOP)
    1:                 goto bad_var_init;
    1: 
27012: #if JS_HAS_BLOCK_SCOPE
27012:             if (popScope) {
27012:                 tc->topStmt = save->down;
27012:                 tc->topScopeStmt = saveScope->downScope;
27012:             }
27012: #endif
40263:             JSParseNode *init = assignExpr();
27012: #if JS_HAS_BLOCK_SCOPE
27012:             if (popScope) {
27012:                 tc->topStmt = save;
27012:                 tc->topScopeStmt = saveScope;
27012:             }
27012: #endif
27012:             if (!init)
27012:                 return NULL;
27012: 
27012:             if (pn2->pn_used) {
27012:                 pn2 = MakeAssignment(pn2, init, tc);
27012:                 if (!pn2)
27012:                     return NULL;
27012:             } else {
27012:                 pn2->pn_expr = init;
27012:             }
27012: 
60526:             JS_ASSERT_IF(pn2->pn_dflags & PND_GVAR, !(pn2->pn_dflags & PND_BOUND));
52555: 
27012:             pn2->pn_op = (PN_OP(pn2) == JSOP_ARGUMENTS)
27012:                          ? JSOP_SETNAME
27012:                          : (pn2->pn_dflags & PND_BOUND)
27012:                          ? JSOP_SETLOCAL
27012:                          : (data.op == JSOP_DEFCONST)
    1:                          ? JSOP_SETCONST
    1:                          : JSOP_SETNAME;
27012: 
40239:             NoteLValue(context, pn2, tc, data.fresh ? PND_INITIALIZED : PND_ASSIGNED);
27012: 
27012:             /* The declarator's position must include the initializer. */
27012:             pn2->pn_pos.end = init->pn_pos.end;
27012: 
41884:             if (tc->inFunction() &&
40239:                 atom == context->runtime->atomState.argumentsAtom) {
72073:                 tc->noteArgumentsUse(pn2);
27012:                 if (!let)
    1:                     tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:             }
27012:         }
40354:     } while (tokenStream.matchToken(TOK_COMMA));
    1: 
27012:     pn->pn_pos.end = pn->last()->pn_pos.end;
    1:     return pn;
    1: 
    1: bad_var_init:
42671:     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_VAR_INIT);
    1:     return NULL;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::expr()
    1: {
42671:     JSParseNode *pn = assignExpr();
40354:     if (pn && tokenStream.matchToken(TOK_COMMA)) {
42671:         JSParseNode *pn2 = ListNode::create(tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         pn2->pn_pos.begin = pn->pn_pos.begin;
27012:         pn2->initList(pn);
    1:         pn = pn2;
    1:         do {
    1: #if JS_HAS_GENERATORS
27012:             pn2 = pn->last();
31479:             if (pn2->pn_type == TOK_YIELD && !pn2->pn_parens) {
42671:                 reportErrorNumber(pn2, JSREPORT_ERROR, JSMSG_BAD_GENERATOR_SYNTAX, js_yield_str);
    1:                 return NULL;
    1:             }
    1: #endif
40263:             pn2 = assignExpr();
    1:             if (!pn2)
    1:                 return NULL;
27012:             pn->append(pn2);
40354:         } while (tokenStream.matchToken(TOK_COMMA));
27012:         pn->pn_pos.end = pn->last()->pn_pos.end;
    1:     }
    1:     return pn;
    1: }
    1: 
64367: /*
64367:  * For a number of the expression parsers we define an always-inlined version
64367:  * and a never-inlined version (which just calls the always-inlined version).
64367:  * Using the always-inlined version in the hot call-sites givs a ~5% parsing
64367:  * speedup.  These macros help avoid some boilerplate code.
64367:  */
64367: #define BEGIN_EXPR_PARSER(name)                                               \
64367:     JS_ALWAYS_INLINE JSParseNode *                                            \
64367:     Parser::name##i()
64367: 
64367: #define END_EXPR_PARSER(name)                                                 \
64367:     JS_NEVER_INLINE JSParseNode *                                             \
64367:     Parser::name##n() {                                                       \
64367:         return name##i();                                                     \
64367:     }
64367: 
64367: BEGIN_EXPR_PARSER(mulExpr1)
64367: {
64367:     TokenKind tt;
64367:     JSParseNode *pn = unaryExpr();
64367: 
64367:     /*
64367:      * Note: unlike addExpr1() et al, we use getToken() here instead of
64367:      * isCurrentTokenType() because unaryExpr() doesn't leave the TokenStream
64367:      * state one past the end of the unary expression.
64367:      */
64367:     while (pn && ((tt = tokenStream.getToken()) == TOK_STAR || tt == TOK_DIVOP)) {
64367:         tt = tokenStream.currentToken().type;
64367:         JSOp op = tokenStream.currentToken().t_op;
64367:         pn = JSParseNode::newBinaryOrAppend(tt, op, pn, unaryExpr(), tc);
64367:     }
    1:     return pn;
    1: }
64367: END_EXPR_PARSER(mulExpr1)
64367: 
64367: BEGIN_EXPR_PARSER(addExpr1)
64367: {
64367:     JSParseNode *pn = mulExpr1i();
64367:     while (pn && tokenStream.isCurrentTokenType(TOK_PLUS, TOK_MINUS)) {
64367:         TokenKind tt = tokenStream.currentToken().type;
64367:         JSOp op = (tt == TOK_PLUS) ? JSOP_ADD : JSOP_SUB;
64367:         pn = JSParseNode::newBinaryOrAppend(tt, op, pn, mulExpr1n(), tc);
64367:     }
64367:     return pn;
64367: }
64367: END_EXPR_PARSER(addExpr1)
64367: 
64367: BEGIN_EXPR_PARSER(shiftExpr1)
64367: {
64367:     JSParseNode *pn = addExpr1i();
64367:     while (pn && tokenStream.isCurrentTokenType(TOK_SHOP)) {
42671:         JSOp op = tokenStream.currentToken().t_op;
64367:         pn = JSParseNode::newBinaryOrAppend(TOK_SHOP, op, pn, addExpr1n(), tc);
64367:     }
64367:     return pn;
64367: }
64367: END_EXPR_PARSER(shiftExpr1)
64367: 
64367: BEGIN_EXPR_PARSER(relExpr1)
64367: {
64367:     uintN inForInitFlag = tc->flags & TCF_IN_FOR_INIT;
64367: 
64367:     /*
64367:      * Uses of the in operator in shiftExprs are always unambiguous,
64367:      * so unset the flag that prohibits recognizing it.
64367:      */
64367:     tc->flags &= ~TCF_IN_FOR_INIT;
64367: 
64367:     JSParseNode *pn = shiftExpr1i();
64367:     while (pn &&
64367:            (tokenStream.isCurrentTokenType(TOK_RELOP) ||
64367:             /*
64367:              * Recognize the 'in' token as an operator only if we're not
64367:              * currently in the init expr of a for loop.
64367:              */
64367:             (inForInitFlag == 0 && tokenStream.isCurrentTokenType(TOK_IN)) ||
64367:             tokenStream.isCurrentTokenType(TOK_INSTANCEOF))) {
64367:         TokenKind tt = tokenStream.currentToken().type;
64367:         JSOp op = tokenStream.currentToken().t_op;
64367:         pn = JSParseNode::newBinaryOrAppend(tt, op, pn, shiftExpr1n(), tc);
64367:     }
64367:     /* Restore previous state of inForInit flag. */
64367:     tc->flags |= inForInitFlag;
64367: 
64367:     return pn;
64367: }
64367: END_EXPR_PARSER(relExpr1)
64367: 
64367: BEGIN_EXPR_PARSER(eqExpr1)
64367: {
64367:     JSParseNode *pn = relExpr1i();
64367:     while (pn && tokenStream.isCurrentTokenType(TOK_EQOP)) {
64367:         JSOp op = tokenStream.currentToken().t_op;
64367:         pn = JSParseNode::newBinaryOrAppend(TOK_EQOP, op, pn, relExpr1n(), tc);
64367:     }
64367:     return pn;
64367: }
64367: END_EXPR_PARSER(eqExpr1)
64367: 
64367: BEGIN_EXPR_PARSER(bitAndExpr1)
64367: {
64367:     JSParseNode *pn = eqExpr1i();
64367:     while (pn && tokenStream.isCurrentTokenType(TOK_BITAND))
64367:         pn = JSParseNode::newBinaryOrAppend(TOK_BITAND, JSOP_BITAND, pn, eqExpr1n(), tc);
64367:     return pn;
64367: }
64367: END_EXPR_PARSER(bitAndExpr1)
64367: 
64367: BEGIN_EXPR_PARSER(bitXorExpr1)
64367: {
64367:     JSParseNode *pn = bitAndExpr1i();
64367:     while (pn && tokenStream.isCurrentTokenType(TOK_BITXOR))
64367:         pn = JSParseNode::newBinaryOrAppend(TOK_BITXOR, JSOP_BITXOR, pn, bitAndExpr1n(), tc);
64367:     return pn;
64367: }
64367: END_EXPR_PARSER(bitXorExpr1)
64367: 
64367: BEGIN_EXPR_PARSER(bitOrExpr1)
64367: {
64367:     JSParseNode *pn = bitXorExpr1i();
64367:     while (pn && tokenStream.isCurrentTokenType(TOK_BITOR))
64367:         pn = JSParseNode::newBinaryOrAppend(TOK_BITOR, JSOP_BITOR, pn, bitXorExpr1n(), tc);
64367:     return pn;
64367: }
64367: END_EXPR_PARSER(bitOrExpr1)
64367: 
64367: BEGIN_EXPR_PARSER(andExpr1)
64367: {
64367:     JSParseNode *pn = bitOrExpr1i();
64367:     while (pn && tokenStream.isCurrentTokenType(TOK_AND))
64367:         pn = JSParseNode::newBinaryOrAppend(TOK_AND, JSOP_AND, pn, bitOrExpr1n(), tc);
64367:     return pn;
64367: }
64367: END_EXPR_PARSER(andExpr1)
64367: 
64367: JS_ALWAYS_INLINE JSParseNode *
64367: Parser::orExpr1()
64367: {
64367:     JSParseNode *pn = andExpr1i();
64367:     while (pn && tokenStream.isCurrentTokenType(TOK_OR))
64367:         pn = JSParseNode::newBinaryOrAppend(TOK_OR, JSOP_OR, pn, andExpr1n(), tc);
64367:     return pn;
64367: }
64367: 
64367: JS_ALWAYS_INLINE JSParseNode *
64366: Parser::condExpr1()
64366: {
64366:     JSParseNode *pn = orExpr1();
64366:     if (pn && tokenStream.isCurrentTokenType(TOK_HOOK)) {
42671:         JSParseNode *pn1 = pn;
40232:         pn = TernaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
40327: 
    1:         /*
    1:          * Always accept the 'in' operator in the middle clause of a ternary,
    1:          * where it's unambiguous, even if we might be parsing the init of a
    1:          * for statement.
    1:          */
42671:         uintN oldflags = tc->flags;
    1:         tc->flags &= ~TCF_IN_FOR_INIT;
42671:         JSParseNode *pn2 = assignExpr();
    1:         tc->flags = oldflags | (tc->flags & TCF_FUN_FLAGS);
    1: 
    1:         if (!pn2)
    1:             return NULL;
    1:         MUST_MATCH_TOKEN(TOK_COLON, JSMSG_COLON_IN_COND);
42671:         JSParseNode *pn3 = assignExpr();
    1:         if (!pn3)
    1:             return NULL;
    1:         pn->pn_pos.begin = pn1->pn_pos.begin;
    1:         pn->pn_pos.end = pn3->pn_pos.end;
    1:         pn->pn_kid1 = pn1;
    1:         pn->pn_kid2 = pn2;
    1:         pn->pn_kid3 = pn3;
64366:         tokenStream.getToken();     /* need to read one token past the end */
    1:     }
    1:     return pn;
    1: }
    1: 
40239: JSParseNode *
64367: Parser::assignExpr()
64367: {
64367:     JS_CHECK_RECURSION(context, return NULL);
64367: 
64367: #if JS_HAS_GENERATORS
64367:     if (tokenStream.matchToken(TOK_YIELD, TSF_OPERAND))
64367:         return returnOrYield(true);
64367: #endif
64367: 
64367:     JSParseNode *pn = condExpr1();
64367:     if (!pn)
64367:         return NULL;
64367: 
64367:     if (!tokenStream.isCurrentTokenType(TOK_ASSIGN)) {
64367:         tokenStream.ungetToken();
    1:         return pn;
    1:     }
    1: 
42671:     JSOp op = tokenStream.currentToken().t_op;
64367:     switch (pn->pn_type) {
64367:       case TOK_NAME:
64367:         if (!CheckStrictAssignment(context, tc, pn))
64367:             return NULL;
64367:         pn->pn_op = JSOP_SETNAME;
64367:         NoteLValue(context, pn, tc);
64367:         break;
64367:       case TOK_DOT:
64367:         pn->pn_op = JSOP_SETPROP;
64367:         break;
64367:       case TOK_LB:
64367:         pn->pn_op = JSOP_SETELEM;
64367:         break;
64367: #if JS_HAS_DESTRUCTURING
64367:       case TOK_RB:
64367:       case TOK_RC:
64367:       {
64367:         if (op != JSOP_NOP) {
64367:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_DESTRUCT_ASS);
64367:             return NULL;
64367:         }
64367:         JSParseNode *rhs = assignExpr();
68922:         if (!rhs || !CheckDestructuring(context, NULL, pn, tc))
64367:             return NULL;
64367:         return JSParseNode::newBinaryOrAppend(TOK_ASSIGN, op, pn, rhs, tc);
64367:       }
64367: #endif
64367:       case TOK_LP:
64367:         if (!MakeSetCall(context, pn, tc, JSMSG_BAD_LEFTSIDE_OF_ASS))
64367:             return NULL;
64367:         break;
64367: #if JS_HAS_XML_SUPPORT
64367:       case TOK_UNARYOP:
64367:         if (pn->pn_op == JSOP_XMLNAME) {
64367:             pn->pn_op = JSOP_SETXMLNAME;
64367:             break;
64367:         }
64367:         /* FALL THROUGH */
64367: #endif
64367:       default:
64367:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_LEFTSIDE_OF_ASS);
64367:         return NULL;
64367:     }
64367: 
64367:     JSParseNode *rhs = assignExpr();
64367:     if (rhs && PN_TYPE(pn) == TOK_NAME && pn->pn_used) {
64367:         JSDefinition *dn = pn->pn_lexdef;
64367: 
64367:         /*
64367:          * If the definition is not flagged as assigned, we must have imputed
64367:          * the initialized flag to it, to optimize for flat closures. But that
64367:          * optimization uses source coordinates to check dominance relations,
64367:          * so we must extend the end of the definition to cover the right-hand
64367:          * side of this assignment, i.e., the initializer.
64367:          */
64367:         if (!dn->isAssigned()) {
64367:             JS_ASSERT(dn->isInitialized());
64367:             dn->pn_pos.end = rhs->pn_pos.end;
64367:         }
64367:     }
64367: 
64367:     return JSParseNode::newBinaryOrAppend(TOK_ASSIGN, op, pn, rhs, tc);
40221: }
40221: 
    1: static JSParseNode *
40320: SetLvalKid(JSContext *cx, TokenStream *ts, JSTreeContext *tc,
35324:            JSParseNode *pn, JSParseNode *kid, const char *name)
    1: {
    1:     if (kid->pn_type != TOK_NAME &&
    1:         kid->pn_type != TOK_DOT &&
  279:         (kid->pn_type != TOK_LP ||
57712:          (kid->pn_op != JSOP_CALL && kid->pn_op != JSOP_EVAL &&
57712:           kid->pn_op != JSOP_FUNCALL && kid->pn_op != JSOP_FUNAPPLY)) &&
    1: #if JS_HAS_XML_SUPPORT
    1:         (kid->pn_type != TOK_UNARYOP || kid->pn_op != JSOP_XMLNAME) &&
    1: #endif
    1:         kid->pn_type != TOK_LB) {
40320:         ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR, JSMSG_BAD_OPERAND, name);
    1:         return NULL;
    1:     }
35324:     if (!CheckStrictAssignment(cx, tc, kid))
35324:         return NULL;
    1:     pn->pn_kid = kid;
    1:     return kid;
    1: }
    1: 
    1: static const char incop_name_str[][10] = {"increment", "decrement"};
    1: 
    1: static JSBool
40320: SetIncOpKid(JSContext *cx, TokenStream *ts, JSTreeContext *tc,
    1:             JSParseNode *pn, JSParseNode *kid,
40320:             TokenKind tt, JSBool preorder)
    1: {
    1:     JSOp op;
    1: 
35324:     kid = SetLvalKid(cx, ts, tc, pn, kid, incop_name_str[tt == TOK_DEC]);
    1:     if (!kid)
    1:         return JS_FALSE;
    1:     switch (kid->pn_type) {
    1:       case TOK_NAME:
    1:         op = (tt == TOK_INC)
    1:              ? (preorder ? JSOP_INCNAME : JSOP_NAMEINC)
    1:              : (preorder ? JSOP_DECNAME : JSOP_NAMEDEC);
27012:         NoteLValue(cx, kid, tc);
    1:         break;
    1: 
    1:       case TOK_DOT:
    1:         op = (tt == TOK_INC)
    1:              ? (preorder ? JSOP_INCPROP : JSOP_PROPINC)
    1:              : (preorder ? JSOP_DECPROP : JSOP_PROPDEC);
    1:         break;
    1: 
    1:       case TOK_LP:
 7984:         if (!MakeSetCall(cx, kid, tc, JSMSG_BAD_INCOP_OPERAND))
 1577:             return JS_FALSE;
    1:         /* FALL THROUGH */
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_UNARYOP:
    1:         if (kid->pn_op == JSOP_XMLNAME)
    1:             kid->pn_op = JSOP_SETXMLNAME;
    1:         /* FALL THROUGH */
    1: #endif
    1:       case TOK_LB:
    1:         op = (tt == TOK_INC)
    1:              ? (preorder ? JSOP_INCELEM : JSOP_ELEMINC)
    1:              : (preorder ? JSOP_DECELEM : JSOP_ELEMDEC);
    1:         break;
    1: 
    1:       default:
    1:         JS_ASSERT(0);
    1:         op = JSOP_NOP;
    1:     }
    1:     pn->pn_op = op;
    1:     return JS_TRUE;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::unaryExpr()
40221: {
    1:     JSParseNode *pn, *pn2;
    1: 
40239:     JS_CHECK_RECURSION(context, return NULL);
40239: 
40854:     TokenKind tt = tokenStream.getToken(TSF_OPERAND);
    1:     switch (tt) {
    1:       case TOK_UNARYOP:
    1:       case TOK_PLUS:
    1:       case TOK_MINUS:
40232:         pn = UnaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_UNARYOP;      /* PLUS and MINUS are binary */
40270:         pn->pn_op = tokenStream.currentToken().t_op;
40263:         pn2 = unaryExpr();
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         pn->pn_kid = pn2;
    1:         break;
    1: 
    1:       case TOK_INC:
    1:       case TOK_DEC:
40232:         pn = UnaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
40263:         pn2 = memberExpr(JS_TRUE);
    1:         if (!pn2)
    1:             return NULL;
40239:         if (!SetIncOpKid(context, &tokenStream, tc, pn, pn2, tt, JS_TRUE))
    1:             return NULL;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         break;
    1: 
    1:       case TOK_DELETE:
41983:       {
40232:         pn = UnaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
40263:         pn2 = unaryExpr();
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1: 
    1:         /*
    1:          * Under ECMA3, deleting any unary expression is valid -- it simply
31479:          * returns true. Here we fold constants before checking for a call
31479:          * expression, in order to rule out delete of a generator expression.
31479:          */
72098:         if (foldConstants && !js_FoldConstants(context, pn2, tc))
 1962:             return NULL;
27012:         switch (pn2->pn_type) {
27012:           case TOK_LP:
57742:             if (!(pn2->pn_xflags & PNX_SETCALL)) {
57742:                 /*
57742:                  * Call MakeSetCall to check for errors, but clear PNX_SETCALL
57742:                  * because the optimizer will eliminate the useless delete.
57742:                  */
57742:                 if (!MakeSetCall(context, pn2, tc, JSMSG_BAD_DELETE_OPERAND))
57742:                     return NULL;
57742:                 pn2->pn_xflags &= ~PNX_SETCALL;
 1577:             }
27012:             break;
27012:           case TOK_NAME:
40320:             if (!ReportStrictModeError(context, &tokenStream, tc, pn,
57742:                                        JSMSG_DEPRECATED_DELETE_OPERAND)) {
57742:                 return NULL;
57742:             }
27012:             pn2->pn_op = JSOP_DELNAME;
72073:             if (pn2->pn_atom == context->runtime->atomState.argumentsAtom) {
41983:                 tc->flags |= TCF_FUN_HEAVYWEIGHT;
72073:                 tc->countArgumentsUse(pn2);
72073:             }
27012:             break;
27012:           default:;
27012:         }
    1:         pn->pn_kid = pn2;
    1:         break;
41983:       }
    1:       case TOK_ERROR:
    1:         return NULL;
    1: 
    1:       default:
40354:         tokenStream.ungetToken();
40263:         pn = memberExpr(JS_TRUE);
    1:         if (!pn)
    1:             return NULL;
    1: 
    1:         /* Don't look across a newline boundary for a postfix incop. */
40270:         if (tokenStream.onCurrentLine(pn->pn_pos)) {
40854:             tt = tokenStream.peekTokenSameLine(TSF_OPERAND);
    1:             if (tt == TOK_INC || tt == TOK_DEC) {
40354:                 (void) tokenStream.getToken();
40232:                 pn2 = UnaryNode::create(tc);
    1:                 if (!pn2)
    1:                     return NULL;
40239:                 if (!SetIncOpKid(context, &tokenStream, tc, pn2, pn, tt, JS_FALSE))
    1:                     return NULL;
    1:                 pn2->pn_pos.begin = pn->pn_pos.begin;
    1:                 pn = pn2;
    1:             }
    1:         }
    1:         break;
    1:     }
    1:     return pn;
    1: }
    1: 
 1577: #if JS_HAS_GENERATORS
 1577: 
 1577: /*
27012:  * A dedicated helper for transplanting the comprehension expression E in
27012:  *
27012:  *   [E for (V in I)]   // array comprehension
27012:  *   (E for (V in I))   // generator expression
27012:  *
27012:  * from its initial location in the AST, on the left of the 'for', to its final
27012:  * position on the right. To avoid a separate pass we do this by adjusting the
27012:  * blockids and name binding links that were established when E was parsed.
27012:  *
27012:  * A generator expression desugars like so:
27012:  *
27012:  *   (E for (V in I)) => (function () { for (var V in I) yield E; })()
27012:  *
27012:  * so the transplanter must adjust static level as well as blockid. E's source
27012:  * coordinates in root->pn_pos are critical to deciding which binding links to
27012:  * preserve and which to cut.
27012:  *
27012:  * NB: This is not a general tree transplanter -- it knows in particular that
27012:  * the one or more bindings induced by V have not yet been created.
27012:  */
27012: class CompExprTransplanter {
27012:     JSParseNode     *root;
27012:     JSTreeContext   *tc;
27012:     bool            genexp;
27012:     uintN           adjust;
27012:     uintN           funcLevel;
27012: 
27012:   public:
27012:     CompExprTransplanter(JSParseNode *pn, JSTreeContext *tc, bool ge, uintN adj)
27012:       : root(pn), tc(tc), genexp(ge), adjust(adj), funcLevel(0)
27012:     {
27012:     }
27012: 
27012:     bool transplant(JSParseNode *pn);
27012: };
27012: 
27012: /*
72073:  * A helper for lazily checking for the presence of illegal |yield| or |arguments|
72073:  * tokens inside of generator expressions.
72073:  *
72073:  * Use when entering a parenthesized context. If the nested expression is followed
72073:  * by a |for| token (indicating that the parenthesized expression is a generator
72073:  * expression), use the checkValidBody() method to see if any illegal tokens were
72073:  * found.
72073:  */
72073: class GenexpGuard {
72073:     JSTreeContext   *tc;
72073:     uint32          startYieldCount;
72073:     uint32          startArgumentsCount;
72073: 
72073:   public:
72073:     explicit GenexpGuard(JSTreeContext *tc)
72073:       : tc(tc)
72073:     {
72073:         if (tc->parenDepth == 0) {
72073:             tc->yieldCount = tc->argumentsCount = 0;
72073:             tc->yieldNode = tc->argumentsNode = NULL;
72073:         }
72073:         startYieldCount = tc->yieldCount;
72073:         startArgumentsCount = tc->argumentsCount;
72073:         tc->parenDepth++;
72073:     }
72073: 
72073:     void endBody();
72073:     bool checkValidBody(JSParseNode *pn);
72073: };
72073: 
72073: void
72073: GenexpGuard::endBody()
72073: {
72073:     tc->parenDepth--;
72073: }
72073: 
72073: bool
72073: GenexpGuard::checkValidBody(JSParseNode *pn)
72073: {
72073:     if (tc->yieldCount > startYieldCount) {
72073:         JSParseNode *errorNode = tc->yieldNode;
72073:         if (!errorNode)
72073:             errorNode = pn;
72073:         tc->parser->reportErrorNumber(errorNode, JSREPORT_ERROR, JSMSG_BAD_GENEXP_BODY, js_yield_str);
72073:         return false;
72073:     }
72073: 
72073:     if (tc->argumentsCount > startArgumentsCount) {
72073:         JSParseNode *errorNode = tc->argumentsNode;
72073:         if (!errorNode)
72073:             errorNode = pn;
72073:         tc->parser->reportErrorNumber(errorNode, JSREPORT_ERROR, JSMSG_BAD_GENEXP_BODY, js_arguments_str);
72073:         return false;
72073:     }
72073: 
72073:     return true;
72073: }
72073: 
72073: /*
27012:  * Any definitions nested within the comprehension expression of a generator
27012:  * expression must move "down" one static level, which of course increases the
27012:  * upvar-frame-skip count.
27012:  */
28814: static bool
27012: BumpStaticLevel(JSParseNode *pn, JSTreeContext *tc)
27012: {
47573:     if (!pn->pn_cookie.isFree()) {
47573:         uintN level = pn->pn_cookie.level() + 1;
27012: 
27012:         JS_ASSERT(level >= tc->staticLevel);
47573:         if (level >= UpvarCookie::FREE_LEVEL) {
40860:             JS_ReportErrorNumber(tc->parser->context, js_GetErrorMessage, NULL,
28814:                                  JSMSG_TOO_DEEP, js_function_str);
28814:             return false;
28814:         }
28814: 
47573:         pn->pn_cookie.set(level, pn->pn_cookie.slot());
27012:     }
28814:     return true;
27012: }
27012: 
28122: static void
28122: AdjustBlockId(JSParseNode *pn, uintN adjust, JSTreeContext *tc)
28122: {
28122:     JS_ASSERT(pn->pn_arity == PN_LIST || pn->pn_arity == PN_FUNC || pn->pn_arity == PN_NAME);
28122:     pn->pn_blockid += adjust;
28122:     if (pn->pn_blockid >= tc->blockidGen)
28122:         tc->blockidGen = pn->pn_blockid + 1;
28122: }
28122: 
27012: bool
27012: CompExprTransplanter::transplant(JSParseNode *pn)
27012: {
27012:     if (!pn)
27012:         return true;
27012: 
27012:     switch (pn->pn_arity) {
27012:       case PN_LIST:
61059:         for (JSParseNode *pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
61059:             if (!transplant(pn2))
61059:                 return false;
61059:         }
27012:         if (pn->pn_pos >= root->pn_pos)
28122:             AdjustBlockId(pn, adjust, tc);
27012:         break;
27012: 
27012:       case PN_TERNARY:
61059:         if (!transplant(pn->pn_kid1) ||
61059:             !transplant(pn->pn_kid2) ||
61059:             !transplant(pn->pn_kid3))
61059:             return false;
27012:         break;
27012: 
27012:       case PN_BINARY:
61059:         if (!transplant(pn->pn_left))
61059:             return false;
28354: 
28354:         /* Binary TOK_COLON nodes can have left == right. See bug 492714. */
61059:         if (pn->pn_right != pn->pn_left) {
61059:             if (!transplant(pn->pn_right))
61059:                 return false;
61059:         }
27012:         break;
27012: 
27012:       case PN_UNARY:
61059:         if (!transplant(pn->pn_kid))
61059:             return false;
27012:         break;
27012: 
27012:       case PN_FUNC:
27012:       {
27012:         /*
27012:          * Only the first level of transplant recursion through functions needs
27012:          * to reparent the funbox, since all descendant functions are correctly
27012:          * linked under the top-most funbox. But every visit to this case needs
27012:          * to update funbox->level.
27012:          *
27012:          * Recall that funbox->level is the static level of the code containing
27012:          * the definition or expression of the function and not the static level
27012:          * of the function's body.
27012:          */
27012:         JSFunctionBox *funbox = pn->pn_funbox;
27012: 
27012:         funbox->level = tc->staticLevel + funcLevel;
27012:         if (++funcLevel == 1 && genexp) {
27012:             JSFunctionBox *parent = tc->funbox;
27012: 
27012:             JSFunctionBox **funboxp = &tc->parent->functionList;
27012:             while (*funboxp != funbox)
27012:                 funboxp = &(*funboxp)->siblings;
27012:             *funboxp = funbox->siblings;
27012: 
27012:             funbox->parent = parent;
27012:             funbox->siblings = parent->kids;
27012:             parent->kids = funbox;
27012:             funbox->level = tc->staticLevel;
27012:         }
27012:         /* FALL THROUGH */
27012:       }
27012: 
27012:       case PN_NAME:
61059:         if (!transplant(pn->maybeExpr()))
61059:             return false;
27012:         if (pn->pn_arity == PN_FUNC)
27012:             --funcLevel;
27012: 
27012:         if (pn->pn_defn) {
28814:             if (genexp && !BumpStaticLevel(pn, tc))
28814:                 return false;
27012:         } else if (pn->pn_used) {
27012:             JS_ASSERT(pn->pn_op != JSOP_NOP);
47573:             JS_ASSERT(pn->pn_cookie.isFree());
27012: 
27012:             JSDefinition *dn = pn->pn_lexdef;
27012:             JS_ASSERT(dn->pn_defn);
27012: 
27012:             /*
27012:              * Adjust the definition's block id only if it is a placeholder not
27012:              * to the left of the root node, and if pn is the last use visited
27012:              * in the comprehension expression (to avoid adjusting the blockid
27012:              * multiple times).
27012:              *
27012:              * Non-placeholder definitions within the comprehension expression
27012:              * will be visited further below.
27012:              */
27012:             if (dn->isPlaceholder() && dn->pn_pos >= root->pn_pos && dn->dn_uses == pn) {
28814:                 if (genexp && !BumpStaticLevel(dn, tc))
28814:                     return false;
28122:                 AdjustBlockId(dn, adjust, tc);
27012:             }
27012: 
27012:             JSAtom *atom = pn->pn_atom;
27012: #ifdef DEBUG
27012:             JSStmtInfo *stmt = js_LexicalLookup(tc, atom, NULL);
27012:             JS_ASSERT(!stmt || stmt != tc->topStmt);
27012: #endif
27012:             if (genexp && PN_OP(dn) != JSOP_CALLEE) {
27012:                 JS_ASSERT(!tc->decls.lookup(atom));
27012: 
27012:                 if (dn->pn_pos < root->pn_pos || dn->isPlaceholder()) {
61060:                     JSAtomListElement *ale = tc->lexdeps.add(tc->parser, atom);
27012:                     if (!ale)
28814:                         return false;
27371: 
27574:                     if (dn->pn_pos >= root->pn_pos) {
40860:                         tc->parent->lexdeps.remove(tc->parser, atom);
27574:                     } else {
61060:                         JSDefinition *dn2 = (JSDefinition *)NameNode::create(atom, tc);
27371:                         if (!dn2)
28814:                             return false;
27371: 
61060:                         dn2->pn_type = TOK_NAME;
61060:                         dn2->pn_op = JSOP_NOP;
27371:                         dn2->pn_defn = true;
28557:                         dn2->pn_dflags |= PND_PLACEHOLDER;
61060:                         dn2->pn_pos = root->pn_pos;
27371: 
27371:                         JSParseNode **pnup = &dn->dn_uses;
27371:                         JSParseNode *pnu;
27371:                         while ((pnu = *pnup) != NULL && pnu->pn_pos >= root->pn_pos) {
27371:                             pnu->pn_lexdef = dn2;
30457:                             dn2->pn_dflags |= pnu->pn_dflags & PND_USE2DEF_FLAGS;
27371:                             pnup = &pnu->pn_link;
27371:                         }
27371:                         dn2->dn_uses = dn->dn_uses;
27371:                         dn->dn_uses = *pnup;
27371:                         *pnup = NULL;
27371: 
27371:                         dn = dn2;
27371:                     }
27371: 
27012:                     ALE_SET_DEFN(ale, dn);
27012:                 }
27012:             }
27012:         }
27012: 
27012:         if (pn->pn_pos >= root->pn_pos)
28122:             AdjustBlockId(pn, adjust, tc);
27012:         break;
27012: 
27012:       case PN_NAMESET:
61059:         if (!transplant(pn->pn_tree))
61059:             return false;
27012:         break;
27012:     }
27012:     return true;
27012: }
27012: 
27012: /*
 1577:  * Starting from a |for| keyword after the first array initialiser element or
 1577:  * an expression in an open parenthesis, parse the tail of the comprehension
 1577:  * or generator expression signified by this |for| keyword in context.
 1577:  *
 1577:  * Return null on failure, else return the top-most parse node for the array
 1577:  * comprehension or generator expression, with a unary node as the body of the
 1577:  * (possibly nested) for-loop, initialized by |type, op, kid|.
 1577:  */
40239: JSParseNode *
72073: Parser::comprehensionTail(JSParseNode *kid, uintN blockid, bool isGenexp,
40320:                           TokenKind type, JSOp op)
40239: {
27012:     uintN adjust;
 1577:     JSParseNode *pn, *pn2, *pn3, **pnp;
 1577:     JSStmtInfo stmtInfo;
 1577:     BindData data;
40320:     TokenKind tt;
 1577:     JSAtom *atom;
 1577: 
40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_FOR);
 1577: 
27012:     if (type == TOK_SEMI) {
27012:         /*
27012:          * Generator expression desugars to an immediately applied lambda that
27012:          * yields the next value from a for-in loop (possibly nested, and with
27012:          * optional if guard). Make pn be the TOK_LC body node.
 1577:          */
40239:         pn = PushLexicalScope(context, &tokenStream, tc, &stmtInfo);
 1577:         if (!pn)
 1577:             return NULL;
27012:         adjust = pn->pn_blockid - blockid;
27012:     } else {
27012:         JS_ASSERT(type == TOK_ARRAYPUSH);
27012: 
27012:         /*
27012:          * Make a parse-node and literal object representing the block scope of
40239:          * this array comprehension. Our caller in primaryExpr, the TOK_LB case
27012:          * aka the array initialiser case, has passed the blockid to claim for
27012:          * the comprehension's block scope. We allocate that id or one above it
27012:          * here, by calling js_PushLexicalScope.
27012:          *
27012:          * In the case of a comprehension expression that has nested blocks
27012:          * (e.g., let expressions), we will allocate a higher blockid but then
27012:          * slide all blocks "to the right" to make room for the comprehension's
27012:          * block scope.
27012:          */
27012:         adjust = tc->blockid();
40239:         pn = PushLexicalScope(context, &tokenStream, tc, &stmtInfo);
27012:         if (!pn)
27012:             return NULL;
27012: 
27012:         JS_ASSERT(blockid <= pn->pn_blockid);
27012:         JS_ASSERT(blockid < tc->blockidGen);
27012:         JS_ASSERT(tc->bodyid < blockid);
27012:         pn->pn_blockid = stmtInfo.blockid = blockid;
27012:         JS_ASSERT(adjust < blockid);
27012:         adjust = blockid - adjust;
27012:     }
27012: 
 1577:     pnp = &pn->pn_expr;
 1577: 
27012:     CompExprTransplanter transplanter(kid, tc, type == TOK_SEMI, adjust);
27012:     transplanter.transplant(kid);
27012: 
 1577:     data.pn = NULL;
 1577:     data.op = JSOP_NOP;
 1577:     data.binder = BindLet;
27012:     data.let.overflow = JSMSG_ARRAY_INIT_TOO_BIG;
27012: 
 1577:     do {
 1577:         /*
 1577:          * FOR node is binary, left is loop control and right is body.  Use
 1577:          * index to count each block-local let-variable on the left-hand side
 1577:          * of the IN.
 1577:          */
40232:         pn2 = BinaryNode::create(tc);
 1577:         if (!pn2)
 1577:             return NULL;
 1577: 
15613:         pn2->pn_op = JSOP_ITER;
15613:         pn2->pn_iflags = JSITER_ENUMERATE;
40354:         if (tokenStream.matchToken(TOK_NAME)) {
40270:             if (tokenStream.currentToken().t_atom == context->runtime->atomState.eachAtom)
15613:                 pn2->pn_iflags |= JSITER_FOREACH;
 1577:             else
40354:                 tokenStream.ungetToken();
 1577:         }
 1577:         MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_AFTER_FOR);
 1577: 
72073:         GenexpGuard guard(tc);
72073: 
27012:         atom = NULL;
40354:         tt = tokenStream.getToken();
 1577:         switch (tt) {
 1577: #if JS_HAS_DESTRUCTURING
 1577:           case TOK_LB:
 1577:           case TOK_LC:
33753:             tc->flags |= TCF_DECL_DESTRUCTURING;
40263:             pn3 = primaryExpr(tt, JS_FALSE);
33753:             tc->flags &= ~TCF_DECL_DESTRUCTURING;
 1577:             if (!pn3)
 1577:                 return NULL;
 1577:             break;
 1577: #endif
 1577: 
 1577:           case TOK_NAME:
40270:             atom = tokenStream.currentToken().t_atom;
 1577: 
 1577:             /*
 1577:              * Create a name node with pn_op JSOP_NAME.  We can't set pn_op to
 1577:              * JSOP_GETLOCAL here, because we don't yet know the block's depth
 1577:              * in the operand stack frame.  The code generator computes that,
 1577:              * and it tries to bind all names to slots, so we must let it do
 1577:              * the deed.
 1577:              */
33754:             pn3 = NewBindingNode(atom, tc, true);
 1577:             if (!pn3)
 1577:                 return NULL;
 1577:             break;
 1577: 
 1577:           default:
42671:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_NO_VARIABLE_NAME);
 1607: 
 1607:           case TOK_ERROR:
 1577:             return NULL;
 1577:         }
 1577: 
 1577:         MUST_MATCH_TOKEN(TOK_IN, JSMSG_IN_AFTER_FOR_NAME);
40263:         JSParseNode *pn4 = expr();
27012:         if (!pn4)
27012:             return NULL;
 1577:         MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_FOR_CTRL);
27012: 
72073:         guard.endBody();
72073: 
72073:         if (isGenexp && !guard.checkValidBody(pn2))
72073:             return NULL;
72073: 
27012:         switch (tt) {
27012: #if JS_HAS_DESTRUCTURING
27012:           case TOK_LB:
27012:           case TOK_LC:
68922:             if (!CheckDestructuring(context, &data, pn3, tc))
40239:                 return NULL;
40239: 
61450:             if (versionNumber() == JSVERSION_1_7) {
27012:                 /* Destructuring requires [key, value] enumeration in JS1.7. */
27012:                 if (pn3->pn_type != TOK_RB || pn3->pn_count != 2) {
42671:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_FOR_LEFTSIDE);
27012:                     return NULL;
27012:                 }
27012: 
27012:                 JS_ASSERT(pn2->pn_op == JSOP_ITER);
27012:                 JS_ASSERT(pn2->pn_iflags & JSITER_ENUMERATE);
27012:                 if (!(pn2->pn_iflags & JSITER_FOREACH))
27012:                     pn2->pn_iflags |= JSITER_FOREACH | JSITER_KEYVALUE;
27012:             }
27012:             break;
27012: #endif
27012: 
27012:           case TOK_NAME:
27012:             data.pn = pn3;
40239:             if (!data.binder(context, &data, atom, tc))
27012:                 return NULL;
27012:             break;
27012: 
27012:           default:;
27012:         }
27012: 
40232:         pn2->pn_left = JSParseNode::newBinaryOrAppend(TOK_IN, JSOP_NOP, pn3, pn4, tc);
27012:         if (!pn2->pn_left)
27012:             return NULL;
 1577:         *pnp = pn2;
 1577:         pnp = &pn2->pn_right;
40354:     } while (tokenStream.matchToken(TOK_FOR));
40354: 
40354:     if (tokenStream.matchToken(TOK_IF)) {
40232:         pn2 = TernaryNode::create(tc);
 1577:         if (!pn2)
 1577:             return NULL;
40263:         pn2->pn_kid1 = condition();
 1577:         if (!pn2->pn_kid1)
 1577:             return NULL;
 1577:         *pnp = pn2;
 1577:         pnp = &pn2->pn_kid2;
 1577:     }
 1577: 
40232:     pn2 = UnaryNode::create(tc);
 1577:     if (!pn2)
 1577:         return NULL;
 1577:     pn2->pn_type = type;
 1577:     pn2->pn_op = op;
 1577:     pn2->pn_kid = kid;
 1577:     *pnp = pn2;
 1577: 
27012:     PopStatement(tc);
 1577:     return pn;
 1577: }
 1577: 
 1577: #if JS_HAS_GENERATOR_EXPRS
 1577: 
 1577: /*
 1577:  * Starting from a |for| keyword after an expression, parse the comprehension
 1577:  * tail completing this generator expression. Wrap the expression at kid in a
 1577:  * generator function that is immediately called to evaluate to the generator
 1577:  * iterator that is the value of this generator expression.
 1577:  *
61058:  * |kid| must be the expression before the |for| keyword; we return an
61058:  * application of a generator function that includes the |for| loops and
61058:  * |if| guards, with |kid| as the operand of a |yield| expression as the
61058:  * innermost loop body.
 1577:  *
 1577:  * Note how unlike Python, we do not evaluate the expression to the right of
 1577:  * the first |in| in the chain of |for| heads. Instead, a generator expression
 1577:  * is merely sugar for a generator function expression and its application.
 1577:  */
40239: JSParseNode *
61058: Parser::generatorExpr(JSParseNode *kid)
61058: {
61058:     /* Create a |yield| node for |kid|. */
61058:     JSParseNode *pn = UnaryNode::create(tc);
61058:     if (!pn)
61058:         return NULL;
 1577:     pn->pn_type = TOK_YIELD;
 1577:     pn->pn_op = JSOP_YIELD;
31479:     pn->pn_parens = true;
 1577:     pn->pn_pos = kid->pn_pos;
 1577:     pn->pn_kid = kid;
31479:     pn->pn_hidden = true;
 1577: 
27012:     /* Make a new node for the desugared generator function. */
40232:     JSParseNode *genfn = FunctionNode::create(tc);
27012:     if (!genfn)
27012:         return NULL;
27012:     genfn->pn_type = TOK_FUNCTION;
27012:     genfn->pn_op = JSOP_LAMBDA;
27012:     JS_ASSERT(!genfn->pn_body);
27012:     genfn->pn_dflags = PND_FUNARG;
27012: 
27012:     {
40263:         JSTreeContext *outertc = tc;
40860:         JSTreeContext gentc(tc->parser);
27012: 
40263:         JSFunctionBox *funbox = EnterFunction(genfn, &gentc);
27012:         if (!funbox)
27012:             return NULL;
27012: 
27236:         /*
40263:          * We have to dance around a bit to propagate sharp variables from
40263:          * outertc to gentc before setting TCF_HAS_SHARPS implicitly by
40263:          * propagating all of outertc's TCF_FUN_FLAGS flags. As below, we have
40263:          * to be conservative by leaving TCF_HAS_SHARPS set in outertc if we
40263:          * do propagate to gentc.
40263:          */
40263:         if (outertc->flags & TCF_HAS_SHARPS) {
32757:             gentc.flags |= TCF_IN_FUNCTION;
32757:             if (!gentc.ensureSharpSlots())
32757:                 return NULL;
32757:         }
32757: 
32757:         /*
27236:          * We assume conservatively that any deoptimization flag in tc->flags
27236:          * besides TCF_FUN_PARAM_ARGUMENTS can come from the kid. So we
27236:          * propagate these flags into genfn. For code simplicity we also do
27236:          * not detect if the flags were only set in the kid and could be
27236:          * removed from tc->flags.
27236:          */
27236:         gentc.flags |= TCF_FUN_IS_GENERATOR | TCF_GENEXP_LAMBDA |
27236:                        (tc->flags & (TCF_FUN_FLAGS & ~TCF_FUN_PARAM_ARGUMENTS));
27012:         funbox->tcflags |= gentc.flags;
27012:         genfn->pn_funbox = funbox;
27012:         genfn->pn_blockid = gentc.bodyid;
27012: 
72073:         JSParseNode *body = comprehensionTail(pn, outertc->blockid(), true);
 1577:         if (!body)
 1577:             return NULL;
27012:         JS_ASSERT(!genfn->pn_body);
27012:         genfn->pn_body = body;
27012:         genfn->pn_pos.begin = body->pn_pos.begin = kid->pn_pos.begin;
40270:         genfn->pn_pos.end = body->pn_pos.end = tokenStream.currentToken().pos.end;
40221: 
40263:         if (!LeaveFunction(genfn, &gentc))
27012:             return NULL;
27012:     }
27012: 
27012:     /*
27012:      * Our result is a call expression that invokes the anonymous generator
27012:      * function object.
27012:      */
40232:     JSParseNode *result = ListNode::create(tc);
27012:     if (!result)
27012:         return NULL;
27012:     result->pn_type = TOK_LP;
27012:     result->pn_op = JSOP_CALL;
27012:     result->pn_pos.begin = genfn->pn_pos.begin;
27012:     result->initList(genfn);
27012:     return result;
 1577: }
 1577: 
 1577: static const char js_generator_str[] = "generator";
 1577: 
 1577: #endif /* JS_HAS_GENERATOR_EXPRS */
 1577: #endif /* JS_HAS_GENERATORS */
 1577: 
72565: /*
72565:  * Check whether a |yield| token has been encountered since the last reset point
72565:  * (the creation of the tree context or the current GenexpGuard), and if so,
72565:  * note that the current function is a generator function.
72565:  *
72565:  * Call this after the current GenexpGuard has determined whether it was inside
72565:  * of a generator expression.
72565:  */
72565: bool
72565: Parser::maybeNoteGenerator()
72565: {
72565:     if (tc->yieldCount > 0) {
72565:         tc->flags |= TCF_FUN_IS_GENERATOR;
72565:         if (!tc->inFunction()) {
72565:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_RETURN_OR_YIELD, js_yield_str);
72565:             return false;
72565:         }
72565:     }
72565:     return true;
72565: }
72565: 
40239: JSBool
40860: Parser::argumentList(JSParseNode *listNode)
    1: {
40854:     if (tokenStream.matchToken(TOK_RP, TSF_OPERAND))
40854:         return JS_TRUE;
40854: 
72073:     GenexpGuard guard(tc);
72565:     bool arg0 = true;
72073: 
    1:     do {
40263:         JSParseNode *argNode = assignExpr();
    1:         if (!argNode)
    1:             return JS_FALSE;
72565:         if (arg0) {
72565:             guard.endBody();
72565:             arg0 = false;
72565:         }
72565: 
    1: #if JS_HAS_GENERATORS
11844:         if (argNode->pn_type == TOK_YIELD &&
31479:             !argNode->pn_parens &&
40354:             tokenStream.peekToken() == TOK_COMMA) {
42671:             reportErrorNumber(argNode, JSREPORT_ERROR, JSMSG_BAD_GENERATOR_SYNTAX, js_yield_str);
    1:             return JS_FALSE;
    1:         }
    1: #endif
 1577: #if JS_HAS_GENERATOR_EXPRS
40354:         if (tokenStream.matchToken(TOK_FOR)) {
72073:             if (!guard.checkValidBody(argNode))
72073:                 return JS_FALSE;
61058:             argNode = generatorExpr(argNode);
 1577:             if (!argNode)
 1577:                 return JS_FALSE;
 1577:             if (listNode->pn_count > 1 ||
40354:                 tokenStream.peekToken() == TOK_COMMA) {
42671:                 reportErrorNumber(argNode, JSREPORT_ERROR, JSMSG_BAD_GENERATOR_SYNTAX,
 1577:                                   js_generator_str);
 1577:                 return JS_FALSE;
 1577:             }
 1577:         }
 1577: #endif
27012:         listNode->append(argNode);
40354:     } while (tokenStream.matchToken(TOK_COMMA));
40354: 
72565:     if (!maybeNoteGenerator())
72565:         return NULL;
72565: 
40354:     if (tokenStream.getToken() != TOK_RP) {
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_PAREN_AFTER_ARGS);
    1:         return JS_FALSE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
27012: /* Check for an immediately-applied (new'ed) lambda and clear PND_FUNARG. */
27012: static JSParseNode *
27012: CheckForImmediatelyAppliedLambda(JSParseNode *pn)
27012: {
27012:     if (pn->pn_type == TOK_FUNCTION) {
27012:         JS_ASSERT(pn->pn_arity == PN_FUNC);
27051: 
27051:         JSFunctionBox *funbox = pn->pn_funbox;
64294:         JS_ASSERT((funbox->function())->flags & JSFUN_LAMBDA);
32658:         if (!(funbox->tcflags & (TCF_FUN_USES_ARGUMENTS | TCF_FUN_USES_OWN_NAME)))
27012:             pn->pn_dflags &= ~PND_FUNARG;
27012:     }
27012:     return pn;
27012: }
27012: 
40239: JSParseNode *
40860: Parser::memberExpr(JSBool allowCallSyntax)
    1: {
    1:     JSParseNode *pn, *pn2, *pn3;
40221: 
40239:     JS_CHECK_RECURSION(context, return NULL);
    1: 
    1:     /* Check for new expression first. */
40854:     TokenKind tt = tokenStream.getToken(TSF_OPERAND);
    1:     if (tt == TOK_NEW) {
40232:         pn = ListNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
40263:         pn2 = memberExpr(JS_FALSE);
    1:         if (!pn2)
    1:             return NULL;
27012:         pn2 = CheckForImmediatelyAppliedLambda(pn2);
    1:         pn->pn_op = JSOP_NEW;
27012:         pn->initList(pn2);
    1:         pn->pn_pos.begin = pn2->pn_pos.begin;
    1: 
40354:         if (tokenStream.matchToken(TOK_LP) && !argumentList(pn))
    1:             return NULL;
    1:         if (pn->pn_count > ARGC_LIMIT) {
40239:             JS_ReportErrorNumber(context, js_GetErrorMessage, NULL,
    1:                                  JSMSG_TOO_MANY_CON_ARGS);
    1:             return NULL;
    1:         }
27012:         pn->pn_pos.end = pn->last()->pn_pos.end;
    1:     } else {
40263:         pn = primaryExpr(tt, JS_FALSE);
    1:         if (!pn)
    1:             return NULL;
    1: 
    1:         if (pn->pn_type == TOK_ANYNAME ||
    1:             pn->pn_type == TOK_AT ||
    1:             pn->pn_type == TOK_DBLCOLON) {
27012:             pn2 = NewOrRecycledNode(tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:             pn2->pn_type = TOK_UNARYOP;
    1:             pn2->pn_pos = pn->pn_pos;
    1:             pn2->pn_op = JSOP_XMLNAME;
    1:             pn2->pn_arity = PN_UNARY;
31479:             pn2->pn_parens = false;
    1:             pn2->pn_kid = pn;
    1:             pn = pn2;
    1:         }
    1:     }
    1: 
40354:     while ((tt = tokenStream.getToken()) > TOK_EOF) {
    1:         if (tt == TOK_DOT) {
40232:             pn2 = NameNode::create(NULL, tc);
    1:             if (!pn2)
    1:                 return NULL;
    1: #if JS_HAS_XML_SUPPORT
40854:             tt = tokenStream.getToken(TSF_OPERAND | TSF_KEYWORD_IS_NAME);
64241: 
64241:             /* Treat filters as 'with' statements for name deoptimization. */
64241:             JSParseNode *oldWith = tc->innermostWith;
64241:             JSStmtInfo stmtInfo;
64241:             if (tt == TOK_LP) {
64241:                 tc->innermostWith = pn;
64241:                 js_PushStatement(tc, &stmtInfo, STMT_WITH, -1);
64241:             }
64241: 
40263:             pn3 = primaryExpr(tt, JS_TRUE);
    1:             if (!pn3)
    1:                 return NULL;
31479: 
64241:             if (tt == TOK_LP) {
64241:                 tc->innermostWith = oldWith;
64241:                 PopStatement(tc);
64241:             }
64241: 
31479:             /* Check both tt and pn_type, to distinguish |x.(y)| and |x.y::z| from |x.y|. */
31479:             if (tt == TOK_NAME && pn3->pn_type == TOK_NAME) {
    1:                 pn2->pn_op = JSOP_GETPROP;
    1:                 pn2->pn_expr = pn;
    1:                 pn2->pn_atom = pn3->pn_atom;
    1:                 RecycleTree(pn3, tc);
    1:             } else {
31479:                 if (tt == TOK_LP) {
31479:                     pn2->pn_type = TOK_FILTER;
31479:                     pn2->pn_op = JSOP_FILTER;
31479: 
31479:                     /* A filtering predicate is like a with statement. */
31479:                     tc->flags |= TCF_FUN_HEAVYWEIGHT;
40320:                 } else if (TokenKindIsXML(PN_TYPE(pn3))) {
    1:                     pn2->pn_type = TOK_LB;
    1:                     pn2->pn_op = JSOP_GETELEM;
    1:                 } else {
42671:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_NAME_AFTER_DOT);
    1:                     return NULL;
    1:                 }
    1:                 pn2->pn_arity = PN_BINARY;
    1:                 pn2->pn_left = pn;
    1:                 pn2->pn_right = pn3;
    1:             }
    1: #else
40854:             MUST_MATCH_TOKEN_WITH_FLAGS(TOK_NAME, JSMSG_NAME_AFTER_DOT, TSF_KEYWORD_IS_NAME);
    1:             pn2->pn_op = JSOP_GETPROP;
    1:             pn2->pn_expr = pn;
40270:             pn2->pn_atom = tokenStream.currentToken().t_atom;
    1: #endif
    1:             pn2->pn_pos.begin = pn->pn_pos.begin;
40270:             pn2->pn_pos.end = tokenStream.currentToken().pos.end;
    1: #if JS_HAS_XML_SUPPORT
    1:         } else if (tt == TOK_DBLDOT) {
40232:             pn2 = BinaryNode::create(tc);
    1:             if (!pn2)
    1:                 return NULL;
40854:             tt = tokenStream.getToken(TSF_OPERAND | TSF_KEYWORD_IS_NAME);
40263:             pn3 = primaryExpr(tt, JS_TRUE);
    1:             if (!pn3)
    1:                 return NULL;
 3164:             tt = PN_TYPE(pn3);
32579:             if (tt == TOK_NAME && !pn3->pn_parens) {
    1:                 pn3->pn_type = TOK_STRING;
    1:                 pn3->pn_arity = PN_NULLARY;
    1:                 pn3->pn_op = JSOP_QNAMEPART;
40320:             } else if (!TokenKindIsXML(tt)) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_NAME_AFTER_DOT);
    1:                 return NULL;
    1:             }
    1:             pn2->pn_op = JSOP_DESCENDANTS;
    1:             pn2->pn_left = pn;
    1:             pn2->pn_right = pn3;
    1:             pn2->pn_pos.begin = pn->pn_pos.begin;
40270:             pn2->pn_pos.end = tokenStream.currentToken().pos.end;
    1: #endif
    1:         } else if (tt == TOK_LB) {
40232:             pn2 = BinaryNode::create(tc);
    1:             if (!pn2)
    1:                 return NULL;
40263:             pn3 = expr();
    1:             if (!pn3)
    1:                 return NULL;
    1: 
    1:             MUST_MATCH_TOKEN(TOK_RB, JSMSG_BRACKET_IN_INDEX);
    1:             pn2->pn_pos.begin = pn->pn_pos.begin;
40270:             pn2->pn_pos.end = tokenStream.currentToken().pos.end;
    1: 
18392:             /*
18392:              * Optimize o['p'] to o.p by rewriting pn2, but avoid rewriting
18392:              * o['0'] to use JSOP_GETPROP, to keep fast indexing disjoint in
18392:              * the interpreter from fast property access. However, if the
18392:              * bracketed string is a uint32, we rewrite pn3 to be a number
18392:              * instead of a string.
18392:              */
18392:             do {
    1:                 if (pn3->pn_type == TOK_STRING) {
18392:                     jsuint index;
18392: 
18392:                     if (!js_IdIsIndex(ATOM_TO_JSID(pn3->pn_atom), &index)) {
    1:                         pn2->pn_type = TOK_DOT;
    1:                         pn2->pn_op = JSOP_GETPROP;
    1:                         pn2->pn_arity = PN_NAME;
    1:                         pn2->pn_expr = pn;
    1:                         pn2->pn_atom = pn3->pn_atom;
18392:                         break;
18392:                     }
18392:                     pn3->pn_type = TOK_NUMBER;
20902:                     pn3->pn_op = JSOP_DOUBLE;
18392:                     pn3->pn_dval = index;
18392:                 }
    1:                 pn2->pn_op = JSOP_GETELEM;
    1:                 pn2->pn_left = pn;
    1:                 pn2->pn_right = pn3;
18392:             } while (0);
    1:         } else if (allowCallSyntax && tt == TOK_LP) {
40232:             pn2 = ListNode::create(tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:             pn2->pn_op = JSOP_CALL;
27012: 
27012:             pn = CheckForImmediatelyAppliedLambda(pn);
27012:             if (pn->pn_op == JSOP_NAME) {
40239:                 if (pn->pn_atom == context->runtime->atomState.evalAtom) {
27012:                     /* Select JSOP_EVAL and flag tc as heavyweight. */
    1:                     pn2->pn_op = JSOP_EVAL;
51096:                     tc->noteCallsEval();
42780:                     tc->flags |= TCF_FUN_HEAVYWEIGHT;
64296:                     /*
64296:                      * In non-strict mode code, direct calls to eval can add
64296:                      * variables to the call object.
64296:                      */
64296:                     if (!tc->inStrictMode())
64296:                         tc->noteHasExtensibleScope();
27012:                 }
27012:             } else if (pn->pn_op == JSOP_GETPROP) {
57712:                 /* Select JSOP_FUNAPPLY given foo.apply(...). */
57712:                 if (pn->pn_atom == context->runtime->atomState.applyAtom)
57712:                     pn2->pn_op = JSOP_FUNAPPLY;
57712:                 else if (pn->pn_atom == context->runtime->atomState.callAtom)
57712:                     pn2->pn_op = JSOP_FUNCALL;
27012:             }
27012: 
27012:             pn2->initList(pn);
    1:             pn2->pn_pos.begin = pn->pn_pos.begin;
    1: 
40263:             if (!argumentList(pn2))
    1:                 return NULL;
    1:             if (pn2->pn_count > ARGC_LIMIT) {
40239:                 JS_ReportErrorNumber(context, js_GetErrorMessage, NULL,
    1:                                      JSMSG_TOO_MANY_FUN_ARGS);
    1:                 return NULL;
    1:             }
40270:             pn2->pn_pos.end = tokenStream.currentToken().pos.end;
    1:         } else {
40354:             tokenStream.ungetToken();
    1:             return pn;
    1:         }
    1: 
    1:         pn = pn2;
    1:     }
    1:     if (tt == TOK_ERROR)
    1:         return NULL;
    1:     return pn;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::bracketedExpr()
    1: {
    1:     uintN oldflags;
    1:     JSParseNode *pn;
    1: 
    1:     /*
    1:      * Always accept the 'in' operator in a parenthesized expression,
    1:      * where it's unambiguous, even if we might be parsing the init of a
    1:      * for statement.
    1:      */
    1:     oldflags = tc->flags;
    1:     tc->flags &= ~TCF_IN_FOR_INIT;
40263:     pn = expr();
    1:     tc->flags = oldflags | (tc->flags & TCF_FUN_FLAGS);
    1:     return pn;
    1: }
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: 
40239: JSParseNode *
40860: Parser::endBracketedExpr()
    1: {
    1:     JSParseNode *pn;
    1: 
40263:     pn = bracketedExpr();
    1:     if (!pn)
    1:         return NULL;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_RB, JSMSG_BRACKET_AFTER_ATTR_EXPR);
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * From the ECMA-357 grammar in 11.1.1 and 11.1.2:
    1:  *
    1:  *      AttributeIdentifier:
    1:  *              @ PropertySelector
    1:  *              @ QualifiedIdentifier
    1:  *              @ [ Expression ]
    1:  *
    1:  *      PropertySelector:
    1:  *              Identifier
    1:  *              *
    1:  *
    1:  *      QualifiedIdentifier:
    1:  *              PropertySelector :: PropertySelector
    1:  *              PropertySelector :: [ Expression ]
    1:  *
    1:  * We adapt AttributeIdentifier and QualifiedIdentier to be LL(1), like so:
    1:  *
    1:  *      AttributeIdentifier:
    1:  *              @ QualifiedIdentifier
    1:  *              @ [ Expression ]
    1:  *
    1:  *      PropertySelector:
    1:  *              Identifier
    1:  *              *
    1:  *
    1:  *      QualifiedIdentifier:
    1:  *              PropertySelector :: PropertySelector
    1:  *              PropertySelector :: [ Expression ]
    1:  *              PropertySelector
    1:  *
    1:  * As PrimaryExpression: Identifier is in ECMA-262 and we want the semantics
    1:  * for that rule to result in a name node, but ECMA-357 extends the grammar
    1:  * to include PrimaryExpression: QualifiedIdentifier, we must factor further:
    1:  *
    1:  *      QualifiedIdentifier:
    1:  *              PropertySelector QualifiedSuffix
    1:  *
    1:  *      QualifiedSuffix:
    1:  *              :: PropertySelector
    1:  *              :: [ Expression ]
    1:  *              /nothing/
    1:  *
    1:  * And use this production instead of PrimaryExpression: QualifiedIdentifier:
    1:  *
    1:  *      PrimaryExpression:
    1:  *              Identifier QualifiedSuffix
    1:  *
    1:  * We hoist the :: match into callers of QualifiedSuffix, in order to tweak
    1:  * PropertySelector vs. Identifier pn_arity, pn_op, and other members.
    1:  */
40239: JSParseNode *
40860: Parser::propertySelector()
    1: {
    1:     JSParseNode *pn;
    1: 
40232:     pn = NullaryNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
    1:     if (pn->pn_type == TOK_STAR) {
    1:         pn->pn_type = TOK_ANYNAME;
    1:         pn->pn_op = JSOP_ANYNAME;
40239:         pn->pn_atom = context->runtime->atomState.starAtom;
    1:     } else {
    1:         JS_ASSERT(pn->pn_type == TOK_NAME);
    1:         pn->pn_op = JSOP_QNAMEPART;
    1:         pn->pn_arity = PN_NAME;
40270:         pn->pn_atom = tokenStream.currentToken().t_atom;
47573:         pn->pn_cookie.makeFree();
    1:     }
    1:     return pn;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::qualifiedSuffix(JSParseNode *pn)
    1: {
    1:     JSParseNode *pn2, *pn3;
40320:     TokenKind tt;
40221: 
40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_DBLCOLON);
40232:     pn2 = NameNode::create(NULL, tc);
    1:     if (!pn2)
    1:         return NULL;
    1: 
    1:     /* Left operand of :: must be evaluated if it is an identifier. */
    1:     if (pn->pn_op == JSOP_QNAMEPART)
    1:         pn->pn_op = JSOP_NAME;
    1: 
40854:     tt = tokenStream.getToken(TSF_KEYWORD_IS_NAME);
    1:     if (tt == TOK_STAR || tt == TOK_NAME) {
40239:         /* Inline and specialize propertySelector for JSOP_QNAMECONST. */
    1:         pn2->pn_op = JSOP_QNAMECONST;
27012:         pn2->pn_pos.begin = pn->pn_pos.begin;
    1:         pn2->pn_atom = (tt == TOK_STAR)
40239:                        ? context->runtime->atomState.starAtom
40270:                        : tokenStream.currentToken().t_atom;
    1:         pn2->pn_expr = pn;
47573:         pn2->pn_cookie.makeFree();
    1:         return pn2;
    1:     }
    1: 
    1:     if (tt != TOK_LB) {
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_SYNTAX_ERROR);
    1:         return NULL;
    1:     }
40263:     pn3 = endBracketedExpr();
    1:     if (!pn3)
    1:         return NULL;
    1: 
    1:     pn2->pn_op = JSOP_QNAME;
    1:     pn2->pn_arity = PN_BINARY;
27012:     pn2->pn_pos.begin = pn->pn_pos.begin;
27012:     pn2->pn_pos.end = pn3->pn_pos.end;
    1:     pn2->pn_left = pn;
    1:     pn2->pn_right = pn3;
    1:     return pn2;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::qualifiedIdentifier()
    1: {
    1:     JSParseNode *pn;
    1: 
40263:     pn = propertySelector();
    1:     if (!pn)
    1:         return NULL;
40354:     if (tokenStream.matchToken(TOK_DBLCOLON)) {
28948:         /* Hack for bug 496316. Slowing down E4X won't make it go away, alas. */
28948:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
40263:         pn = qualifiedSuffix(pn);
28948:     }
    1:     return pn;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::attributeIdentifier()
    1: {
    1:     JSParseNode *pn, *pn2;
40320:     TokenKind tt;
40221: 
40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_AT);
40232:     pn = UnaryNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
    1:     pn->pn_op = JSOP_TOATTRNAME;
40854:     tt = tokenStream.getToken(TSF_KEYWORD_IS_NAME);
    1:     if (tt == TOK_STAR || tt == TOK_NAME) {
40263:         pn2 = qualifiedIdentifier();
    1:     } else if (tt == TOK_LB) {
40263:         pn2 = endBracketedExpr();
    1:     } else {
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_SYNTAX_ERROR);
    1:         return NULL;
    1:     }
    1:     if (!pn2)
    1:         return NULL;
    1:     pn->pn_kid = pn2;
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * Make a TOK_LC unary node whose pn_kid is an expression.
    1:  */
40239: JSParseNode *
40860: Parser::xmlExpr(JSBool inTag)
    1: {
    1:     JSParseNode *pn, *pn2;
    1: 
40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_LC);
40232:     pn = UnaryNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
    1: 
    1:     /*
38596:      * Turn off XML tag mode. We save the old value of the flag because it may
38596:      * already be off: XMLExpr is called both from within a tag, and from
38596:      * within text contained in an element, but outside of any start, end, or
38596:      * point tag.
38596:      */
40854:     bool oldflag = tokenStream.isXMLTagMode();
40854:     tokenStream.setXMLTagMode(false);
40263:     pn2 = expr();
    1:     if (!pn2)
    1:         return NULL;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_IN_XML_EXPR);
40854:     tokenStream.setXMLTagMode(oldflag);
    1:     pn->pn_kid = pn2;
    1:     pn->pn_op = inTag ? JSOP_XMLTAGEXPR : JSOP_XMLELTEXPR;
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * Make a terminal node for one of TOK_XMLNAME, TOK_XMLATTR, TOK_XMLSPACE,
    1:  * TOK_XMLTEXT, TOK_XMLCDATA, TOK_XMLCOMMENT, or TOK_XMLPI.  When converting
    1:  * parse tree to XML, we preserve a TOK_XMLSPACE node only if it's the sole
    1:  * child of a container tag.
    1:  */
40239: JSParseNode *
40860: Parser::xmlAtomNode()
40221: {
40270:     JSParseNode *pn = NullaryNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
40854:     const Token &tok = tokenStream.currentToken();
40854:     pn->pn_op = tok.t_op;
40854:     pn->pn_atom = tok.t_atom;
40854:     if (tok.type == TOK_XMLPI)
40854:         pn->pn_atom2 = tok.t_atom2;
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * Parse the productions:
    1:  *
    1:  *      XMLNameExpr:
    1:  *              XMLName XMLNameExpr?
    1:  *              { Expr } XMLNameExpr?
    1:  *
    1:  * Return a PN_LIST, PN_UNARY, or PN_NULLARY according as XMLNameExpr produces
    1:  * a list of names and/or expressions, a single expression, or a single name.
    1:  * If PN_LIST or PN_NULLARY, pn_type will be TOK_XMLNAME; if PN_UNARY, pn_type
    1:  * will be TOK_LC.
    1:  */
40239: JSParseNode *
40860: Parser::xmlNameExpr()
    1: {
    1:     JSParseNode *pn, *pn2, *list;
40320:     TokenKind tt;
    1: 
    1:     pn = list = NULL;
    1:     do {
40270:         tt = tokenStream.currentToken().type;
    1:         if (tt == TOK_LC) {
40263:             pn2 = xmlExpr(JS_TRUE);
    1:             if (!pn2)
    1:                 return NULL;
    1:         } else {
    1:             JS_ASSERT(tt == TOK_XMLNAME);
40263:             pn2 = xmlAtomNode();
    1:             if (!pn2)
    1:                 return NULL;
    1:         }
    1: 
    1:         if (!pn) {
    1:             pn = pn2;
    1:         } else {
    1:             if (!list) {
40232:                 list = ListNode::create(tc);
    1:                 if (!list)
    1:                     return NULL;
    1:                 list->pn_type = TOK_XMLNAME;
    1:                 list->pn_pos.begin = pn->pn_pos.begin;
27012:                 list->initList(pn);
27012:                 list->pn_xflags = PNX_CANTFOLD;
    1:                 pn = list;
    1:             }
    1:             pn->pn_pos.end = pn2->pn_pos.end;
27012:             pn->append(pn2);
    1:         }
40354:     } while ((tt = tokenStream.getToken()) == TOK_XMLNAME || tt == TOK_LC);
40354: 
40354:     tokenStream.ungetToken();
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * Macro to test whether an XMLNameExpr or XMLTagContent node can be folded
    1:  * at compile time into a JSXML tree.
    1:  */
    1: #define XML_FOLDABLE(pn)        ((pn)->pn_arity == PN_LIST                    \
27012:                                  ? ((pn)->pn_xflags & PNX_CANTFOLD) == 0      \
    1:                                  : (pn)->pn_type != TOK_LC)
    1: 
    1: /*
    1:  * Parse the productions:
    1:  *
    1:  *      XMLTagContent:
    1:  *              XMLNameExpr
    1:  *              XMLTagContent S XMLNameExpr S? = S? XMLAttr
    1:  *              XMLTagContent S XMLNameExpr S? = S? { Expr }
    1:  *
    1:  * Return a PN_LIST, PN_UNARY, or PN_NULLARY according to how XMLTagContent
    1:  * produces a list of name and attribute values and/or braced expressions, a
    1:  * single expression, or a single name.
    1:  *
    1:  * If PN_LIST or PN_NULLARY, pn_type will be TOK_XMLNAME for the case where
    1:  * XMLTagContent: XMLNameExpr.  If pn_type is not TOK_XMLNAME but pn_arity is
    1:  * PN_LIST, pn_type will be tagtype.  If PN_UNARY, pn_type will be TOK_LC and
    1:  * we parsed exactly one expression.
    1:  */
40239: JSParseNode *
40860: Parser::xmlTagContent(TokenKind tagtype, JSAtom **namep)
    1: {
    1:     JSParseNode *pn, *pn2, *list;
40320:     TokenKind tt;
40221: 
40263:     pn = xmlNameExpr();
    1:     if (!pn)
    1:         return NULL;
    1:     *namep = (pn->pn_arity == PN_NULLARY) ? pn->pn_atom : NULL;
    1:     list = NULL;
    1: 
40354:     while (tokenStream.matchToken(TOK_XMLSPACE)) {
40354:         tt = tokenStream.getToken();
    1:         if (tt != TOK_XMLNAME && tt != TOK_LC) {
40354:             tokenStream.ungetToken();
40239:             break;
40239:         }
40239: 
40263:         pn2 = xmlNameExpr();
    1:         if (!pn2)
    1:             return NULL;
    1:         if (!list) {
40232:             list = ListNode::create(tc);
    1:             if (!list)
    1:                 return NULL;
    1:             list->pn_type = tagtype;
    1:             list->pn_pos.begin = pn->pn_pos.begin;
27012:             list->initList(pn);
    1:             pn = list;
    1:         }
27012:         pn->append(pn2);
    1:         if (!XML_FOLDABLE(pn2))
27012:             pn->pn_xflags |= PNX_CANTFOLD;
    1: 
40354:         tokenStream.matchToken(TOK_XMLSPACE);
    1:         MUST_MATCH_TOKEN(TOK_ASSIGN, JSMSG_NO_ASSIGN_IN_XML_ATTR);
40354:         tokenStream.matchToken(TOK_XMLSPACE);
40354: 
40354:         tt = tokenStream.getToken();
    1:         if (tt == TOK_XMLATTR) {
40263:             pn2 = xmlAtomNode();
    1:         } else if (tt == TOK_LC) {
40263:             pn2 = xmlExpr(JS_TRUE);
27012:             pn->pn_xflags |= PNX_CANTFOLD;
    1:         } else {
42671:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_XML_ATTR_VALUE);
    1:             return NULL;
    1:         }
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
27012:         pn->append(pn2);
    1:     }
    1: 
    1:     return pn;
    1: }
    1: 
    1: #define XML_CHECK_FOR_ERROR_AND_EOF(tt,result)                                              \
    1:     JS_BEGIN_MACRO                                                                          \
    1:         if ((tt) <= TOK_EOF) {                                                              \
    1:             if ((tt) == TOK_EOF) {                                                          \
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_END_OF_XML_SOURCE);           \
    1:             }                                                                               \
    1:             return result;                                                                  \
    1:         }                                                                                   \
    1:     JS_END_MACRO
    1: 
    1: /*
    1:  * Consume XML element tag content, including the TOK_XMLETAGO (</) sequence
    1:  * that opens the end tag for the container.
    1:  */
40239: JSBool
40860: Parser::xmlElementContent(JSParseNode *pn)
40221: {
40854:     tokenStream.setXMLTagMode(false);
    1:     for (;;) {
40854:         TokenKind tt = tokenStream.getToken(TSF_XMLTEXTMODE);
    1:         XML_CHECK_FOR_ERROR_AND_EOF(tt, JS_FALSE);
    1: 
    1:         JS_ASSERT(tt == TOK_XMLSPACE || tt == TOK_XMLTEXT);
40854:         JSAtom *textAtom = tokenStream.currentToken().t_atom;
    1:         if (textAtom) {
    1:             /* Non-zero-length XML text scanned. */
40854:             JSParseNode *pn2 = xmlAtomNode();
    1:             if (!pn2)
    1:                 return JS_FALSE;
    1:             pn->pn_pos.end = pn2->pn_pos.end;
27012:             pn->append(pn2);
    1:         }
    1: 
40854:         tt = tokenStream.getToken(TSF_OPERAND);
    1:         XML_CHECK_FOR_ERROR_AND_EOF(tt, JS_FALSE);
    1:         if (tt == TOK_XMLETAGO)
    1:             break;
    1: 
40854:         JSParseNode *pn2;
    1:         if (tt == TOK_LC) {
40263:             pn2 = xmlExpr(JS_FALSE);
27012:             pn->pn_xflags |= PNX_CANTFOLD;
    1:         } else if (tt == TOK_XMLSTAGO) {
40263:             pn2 = xmlElementOrList(JS_FALSE);
    1:             if (pn2) {
27012:                 pn2->pn_xflags &= ~PNX_XMLROOT;
27012:                 pn->pn_xflags |= pn2->pn_xflags;
    1:             }
    1:         } else {
    1:             JS_ASSERT(tt == TOK_XMLCDATA || tt == TOK_XMLCOMMENT ||
    1:                       tt == TOK_XMLPI);
40263:             pn2 = xmlAtomNode();
    1:         }
    1:         if (!pn2)
    1:             return JS_FALSE;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
27012:         pn->append(pn2);
    1:     }
40854:     tokenStream.setXMLTagMode(true);
    1: 
40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_XMLETAGO);
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * Return a PN_LIST node containing an XML or XMLList Initialiser.
    1:  */
40239: JSParseNode *
40860: Parser::xmlElementOrList(JSBool allowList)
    1: {
    1:     JSParseNode *pn, *pn2, *list;
40320:     TokenKind tt;
    1:     JSAtom *startAtom, *endAtom;
    1: 
40239:     JS_CHECK_RECURSION(context, return NULL);
40239: 
40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_XMLSTAGO);
40232:     pn = ListNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
    1: 
40854:     tokenStream.setXMLTagMode(true);
40354:     tt = tokenStream.getToken();
    1:     if (tt == TOK_ERROR)
    1:         return NULL;
    1: 
    1:     if (tt == TOK_XMLNAME || tt == TOK_LC) {
    1:         /*
    1:          * XMLElement.  Append the tag and its contents, if any, to pn.
    1:          */
40263:         pn2 = xmlTagContent(TOK_XMLSTAGO, &startAtom);
    1:         if (!pn2)
    1:             return NULL;
40354:         tokenStream.matchToken(TOK_XMLSPACE);
40354: 
40354:         tt = tokenStream.getToken();
    1:         if (tt == TOK_XMLPTAGC) {
    1:             /* Point tag (/>): recycle pn if pn2 is a list of tag contents. */
    1:             if (pn2->pn_type == TOK_XMLSTAGO) {
27012:                 pn->makeEmpty();
    1:                 RecycleTree(pn, tc);
    1:                 pn = pn2;
    1:             } else {
    1:                 JS_ASSERT(pn2->pn_type == TOK_XMLNAME ||
    1:                           pn2->pn_type == TOK_LC);
27012:                 pn->initList(pn2);
    1:                 if (!XML_FOLDABLE(pn2))
27012:                     pn->pn_xflags |= PNX_CANTFOLD;
    1:             }
    1:             pn->pn_type = TOK_XMLPTAGC;
27012:             pn->pn_xflags |= PNX_XMLROOT;
    1:         } else {
    1:             /* We had better have a tag-close (>) at this point. */
    1:             if (tt != TOK_XMLTAGC) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_XML_TAG_SYNTAX);
    1:                 return NULL;
    1:             }
40270:             pn2->pn_pos.end = tokenStream.currentToken().pos.end;
    1: 
    1:             /* Make sure pn2 is a TOK_XMLSTAGO list containing tag contents. */
    1:             if (pn2->pn_type != TOK_XMLSTAGO) {
27012:                 pn->initList(pn2);
    1:                 if (!XML_FOLDABLE(pn2))
27012:                     pn->pn_xflags |= PNX_CANTFOLD;
    1:                 pn2 = pn;
40232:                 pn = ListNode::create(tc);
    1:                 if (!pn)
    1:                     return NULL;
    1:             }
    1: 
    1:             /* Now make pn a nominal-root TOK_XMLELEM list containing pn2. */
    1:             pn->pn_type = TOK_XMLELEM;
27012:             pn->pn_pos.begin = pn2->pn_pos.begin;
27012:             pn->initList(pn2);
    1:             if (!XML_FOLDABLE(pn2))
27012:                 pn->pn_xflags |= PNX_CANTFOLD;
27012:             pn->pn_xflags |= PNX_XMLROOT;
    1: 
    1:             /* Get element contents and delimiting end-tag-open sequence. */
40263:             if (!xmlElementContent(pn))
40239:                 return NULL;
40239: 
40354:             tt = tokenStream.getToken();
    1:             XML_CHECK_FOR_ERROR_AND_EOF(tt, NULL);
    1:             if (tt != TOK_XMLNAME && tt != TOK_LC) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_XML_TAG_SYNTAX);
    1:                 return NULL;
    1:             }
    1: 
    1:             /* Parse end tag; check mismatch at compile-time if we can. */
40263:             pn2 = xmlTagContent(TOK_XMLETAGO, &endAtom);
    1:             if (!pn2)
    1:                 return NULL;
    1:             if (pn2->pn_type == TOK_XMLETAGO) {
    1:                 /* Oops, end tag has attributes! */
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_XML_TAG_SYNTAX);
    1:                 return NULL;
    1:             }
    1:             if (endAtom && startAtom && endAtom != startAtom) {
    1:                 /* End vs. start tag name mismatch: point to the tag name. */
42671:                 reportErrorNumber(pn2, JSREPORT_UC | JSREPORT_ERROR, JSMSG_XML_TAG_NAME_MISMATCH,
59890:                                   startAtom->chars());
    1:                 return NULL;
    1:             }
    1: 
    1:             /* Make a TOK_XMLETAGO list with pn2 as its single child. */
    1:             JS_ASSERT(pn2->pn_type == TOK_XMLNAME || pn2->pn_type == TOK_LC);
40232:             list = ListNode::create(tc);
    1:             if (!list)
    1:                 return NULL;
    1:             list->pn_type = TOK_XMLETAGO;
27012:             list->initList(pn2);
27012:             pn->append(list);
    1:             if (!XML_FOLDABLE(pn2)) {
27012:                 list->pn_xflags |= PNX_CANTFOLD;
27012:                 pn->pn_xflags |= PNX_CANTFOLD;
    1:             }
    1: 
40354:             tokenStream.matchToken(TOK_XMLSPACE);
    1:             MUST_MATCH_TOKEN(TOK_XMLTAGC, JSMSG_BAD_XML_TAG_SYNTAX);
    1:         }
    1: 
    1:         /* Set pn_op now that pn has been updated to its final value. */
    1:         pn->pn_op = JSOP_TOXML;
    1:     } else if (allowList && tt == TOK_XMLTAGC) {
    1:         /* XMLList Initialiser. */
    1:         pn->pn_type = TOK_XMLLIST;
    1:         pn->pn_op = JSOP_TOXMLLIST;
27012:         pn->makeEmpty();
27012:         pn->pn_xflags |= PNX_XMLROOT;
40263:         if (!xmlElementContent(pn))
    1:             return NULL;
    1: 
    1:         MUST_MATCH_TOKEN(TOK_XMLTAGC, JSMSG_BAD_XML_LIST_SYNTAX);
    1:     } else {
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_XML_NAME_SYNTAX);
    1:         return NULL;
    1:     }
40854:     tokenStream.setXMLTagMode(false);
    1: 
40270:     pn->pn_pos.end = tokenStream.currentToken().pos.end;
    1:     return pn;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::xmlElementOrListRoot(JSBool allowList)
    1: {
    1:     /*
    1:      * Force XML support to be enabled so that comments and CDATA literals
    1:      * are recognized, instead of <! followed by -- starting an HTML comment
    1:      * to end of line (used in script tags to hide content from old browsers
    1:      * that don't recognize <script>).
    1:      */
61450:     bool hadXML = tokenStream.hasXML();
61450:     tokenStream.setXML(true);
61450:     JSParseNode *pn = xmlElementOrList(allowList);
61450:     tokenStream.setXML(hadXML);
    1:     return pn;
    1: }
    1: 
27012: JSParseNode *
40860: Parser::parseXMLText(JSObject *chain, bool allowList)
27012: {
    1:     /*
    1:      * Push a compiler frame if we have no frames, or if the top frame is a
    1:      * lightweight function activation, or if its scope chain doesn't match
    1:      * the one passed to us.
    1:      */
40263:     JSTreeContext xmltc(this);
57829:     xmltc.setScopeChain(chain);
    1: 
    1:     /* Set XML-only mode to turn off special treatment of {expr} in XML. */
40854:     tokenStream.setXMLOnlyMode();
40854:     TokenKind tt = tokenStream.getToken(TSF_OPERAND);
27012: 
27012:     JSParseNode *pn;
    1:     if (tt != TOK_XMLSTAGO) {
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_XML_MARKUP);
    1:         pn = NULL;
    1:     } else {
40263:         pn = xmlElementOrListRoot(allowList);
40239:     }
40854:     tokenStream.setXMLOnlyMode(false);
40854: 
    1:     return pn;
    1: }
    1: 
    1: #endif /* JS_HAS_XMLSUPPORT */
    1: 
27012: #if JS_HAS_BLOCK_SCOPE
27012: /*
27012:  * Check whether blockid is an active scoping statement in tc. This code is
40239:  * necessary to qualify tc->decls.lookup() hits in primaryExpr's TOK_NAME case
27012:  * (below) where the hits come from Scheme-ish let bindings in for loop heads
27012:  * and let blocks and expressions (not let declarations).
27012:  *
27012:  * Unlike let declarations ("let as the new var"), which is a kind of letrec
27012:  * due to hoisting, let in a for loop head, let block, or let expression acts
27012:  * like Scheme's let: initializers are evaluated without the new let bindings
27012:  * being in scope.
27012:  *
27012:  * Name binding analysis is eager with fixups, rather than multi-pass, and let
27012:  * bindings push on the front of the tc->decls JSAtomList (either the singular
27012:  * list or on a hash chain -- see JSAtomList::AddHow) in order to shadow outer
27012:  * scope bindings of the same name.
27012:  *
27012:  * This simplifies binding lookup code at the price of a linear search here,
27012:  * but only if code uses let (var predominates), and even then this function's
27012:  * loop iterates more than once only in crazy cases.
27012:  */
27371: static inline bool
27371: BlockIdInScope(uintN blockid, JSTreeContext *tc)
27371: {
27371:     if (blockid > tc->blockid())
27371:         return false;
27012:     for (JSStmtInfo *stmt = tc->topScopeStmt; stmt; stmt = stmt->downScope) {
27012:         if (stmt->blockid == blockid)
27012:             return true;
27012:     }
27012:     return false;
27012: }
27012: #endif
27012: 
59962: bool
59962: JSParseNode::isConstant()
59962: {
59962:     switch (pn_type) {
59962:       case TOK_NUMBER:
59962:       case TOK_STRING:
59962:         return true;
59962:       case TOK_PRIMARY:
59962:         switch (pn_op) {
59962:           case JSOP_NULL:
59962:           case JSOP_FALSE:
59962:           case JSOP_TRUE:
59962:             return true;
59962:           default:
59962:             return false;
59962:         }
59962:       case TOK_RB:
59962:       case TOK_RC:
59962:         return (pn_op == JSOP_NEWINIT) && !(pn_xflags & PNX_NONCONST);
59962:       default:
59962:         return false;
59962:     }
59962: }
59962: 
40239: JSParseNode *
40860: Parser::primaryExpr(TokenKind tt, JSBool afterDot)
    1: {
    1:     JSParseNode *pn, *pn2, *pn3;
    1:     JSOp op;
11139: 
40239:     JS_CHECK_RECURSION(context, return NULL);
11139: 
    1:     switch (tt) {
    1:       case TOK_FUNCTION:
    1: #if JS_HAS_XML_SUPPORT
40854:         if (tokenStream.matchToken(TOK_DBLCOLON, TSF_KEYWORD_IS_NAME)) {
40232:             pn2 = NullaryNode::create(tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:             pn2->pn_type = TOK_FUNCTION;
40263:             pn = qualifiedSuffix(pn2);
    1:             if (!pn)
    1:                 return NULL;
    1:             break;
    1:         }
    1: #endif
40263:         pn = functionExpr();
    1:         if (!pn)
    1:             return NULL;
    1:         break;
    1: 
    1:       case TOK_LB:
    1:       {
    1:         JSBool matched;
    1:         jsuint index;
    1: 
40232:         pn = ListNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_RB;
20902:         pn->pn_op = JSOP_NEWINIT;
27012:         pn->makeEmpty();
27012: 
27012: #if JS_HAS_GENERATORS
27012:         pn->pn_blockid = tc->blockidGen;
27012: #endif
    1: 
40854:         matched = tokenStream.matchToken(TOK_RB, TSF_OPERAND);
    1:         if (!matched) {
    1:             for (index = 0; ; index++) {
31823:                 if (index == JS_ARGS_LENGTH_MAX) {
42671:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_ARRAY_INIT_TOO_BIG);
    1:                     return NULL;
    1:                 }
    1: 
40854:                 tt = tokenStream.peekToken(TSF_OPERAND);
    1:                 if (tt == TOK_RB) {
27012:                     pn->pn_xflags |= PNX_ENDCOMMA;
    1:                     break;
    1:                 }
    1: 
    1:                 if (tt == TOK_COMMA) {
    1:                     /* So CURRENT_TOKEN gets TOK_COMMA and not TOK_LB. */
40354:                     tokenStream.matchToken(TOK_COMMA);
40232:                     pn2 = NullaryNode::create(tc);
59962:                     pn->pn_xflags |= PNX_HOLEY | PNX_NONCONST;
    1:                 } else {
40263:                     pn2 = assignExpr();
59962:                     if (pn2 && !pn2->isConstant())
59962:                         pn->pn_xflags |= PNX_NONCONST;
    1:                 }
    1:                 if (!pn2)
    1:                     return NULL;
27012:                 pn->append(pn2);
    1: 
    1:                 if (tt != TOK_COMMA) {
    1:                     /* If we didn't already match TOK_COMMA in above case. */
40354:                     if (!tokenStream.matchToken(TOK_COMMA))
    1:                         break;
    1:                 }
    1:             }
    1: 
    1: #if JS_HAS_GENERATORS
    1:             /*
    1:              * At this point, (index == 0 && pn->pn_count != 0) implies one
26959:              * element initialiser was parsed.
    1:              *
    1:              * An array comprehension of the form:
    1:              *
    1:              *   [i * j for (i in o) for (j in p) if (i != j)]
    1:              *
    1:              * translates to roughly the following let expression:
    1:              *
    1:              *   let (array = new Array, i, j) {
    1:              *     for (i in o) let {
    1:              *       for (j in p)
    1:              *         if (i != j)
    1:              *           array.push(i * j)
    1:              *     }
    1:              *     array
    1:              *   }
    1:              *
    1:              * where array is a nameless block-local variable.  The "roughly"
    1:              * means that an implementation may optimize away the array.push.
    1:              * An array comprehension opens exactly one block scope, no matter
    1:              * how many for heads it contains.
    1:              *
    1:              * Each let () {...} or for (let ...) ... compiles to:
    1:              *
    1:              *   JSOP_ENTERBLOCK <o> ... JSOP_LEAVEBLOCK <n>
    1:              *
    1:              * where <o> is a literal object representing the block scope,
    1:              * with <n> properties, naming each var declared in the block.
    1:              *
    1:              * Each var declaration in a let-block binds a name in <o> at
    1:              * compile time, and allocates a slot on the operand stack at
    1:              * runtime via JSOP_ENTERBLOCK.  A block-local var is accessed
    1:              * by the JSOP_GETLOCAL and JSOP_SETLOCAL ops, and iterated with
    1:              * JSOP_FORLOCAL.  These ops all have an immediate operand, the
    1:              * local slot's stack index from fp->spbase.
    1:              *
    1:              * The array comprehension iteration step, array.push(i * j) in
    1:              * the example above, is done by <i * j>; JSOP_ARRAYCOMP <array>,
    1:              * where <array> is the index of array's stack slot.
    1:              */
40354:             if (index == 0 && pn->pn_count != 0 && tokenStream.matchToken(TOK_FOR)) {
 1577:                 JSParseNode *pnexp, *pntop;
    1: 
    1:                 /* Relabel pn as an array comprehension node. */
    1:                 pn->pn_type = TOK_ARRAYCOMP;
    1: 
    1:                 /*
    1:                  * Remove the comprehension expression from pn's linked list
    1:                  * and save it via pnexp.  We'll re-install it underneath the
    1:                  * ARRAYPUSH node after we parse the rest of the comprehension.
    1:                  */
27012:                 pnexp = pn->last();
51110:                 JS_ASSERT(pn->pn_count == 1);
51110:                 pn->pn_count = 0;
51110:                 pn->pn_tail = &pn->pn_head;
    1:                 *pn->pn_tail = NULL;
    1: 
72073:                 pntop = comprehensionTail(pnexp, pn->pn_blockid, false,
27012:                                           TOK_ARRAYPUSH, JSOP_ARRAYPUSH);
    1:                 if (!pntop)
    1:                     return NULL;
27012:                 pn->append(pntop);
    1:             }
    1: #endif /* JS_HAS_GENERATORS */
    1: 
    1:             MUST_MATCH_TOKEN(TOK_RB, JSMSG_BRACKET_AFTER_LIST);
    1:         }
40270:         pn->pn_pos.end = tokenStream.currentToken().pos.end;
    1:         return pn;
    1:       }
    1: 
    1:       case TOK_LC:
    1:       {
    1:         JSBool afterComma;
11039:         JSParseNode *pnval;
    1: 
35310:         /*
60213:          * A map from property names we've seen thus far to a mask of property
60213:          * assignment types, stored and retrieved with ALE_SET_INDEX/ALE_INDEX.
35310:          */
40860:         JSAutoAtomList seen(tc->parser);
60213:         enum AssignmentType {
60213:             GET     = 0x1,
60213:             SET     = 0x2,
60213:             VALUE   = 0x4 | GET | SET
60213:         };
35310: 
40232:         pn = ListNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_RC;
20902:         pn->pn_op = JSOP_NEWINIT;
27012:         pn->makeEmpty();
    1: 
    1:         afterComma = JS_FALSE;
    1:         for (;;) {
35310:             JSAtom *atom;
40854:             tt = tokenStream.getToken(TSF_KEYWORD_IS_NAME);
    1:             switch (tt) {
    1:               case TOK_NUMBER:
40232:                 pn3 = NullaryNode::create(tc);
33749:                 if (!pn3)
33749:                     return NULL;
40270:                 pn3->pn_dval = tokenStream.currentToken().t_dval;
48470:                 if (!js_ValueToAtom(context, DoubleValue(pn3->pn_dval), &atom))
40794:                     return NULL;
    1:                 break;
    1:               case TOK_NAME:
    1:                 {
40270:                     atom = tokenStream.currentToken().t_atom;
40239:                     if (atom == context->runtime->atomState.getAtom)
 1478:                         op = JSOP_GETTER;
40239:                     else if (atom == context->runtime->atomState.setAtom)
 1478:                         op = JSOP_SETTER;
 1478:                     else
 1478:                         goto property_name;
 1478: 
40854:                     tt = tokenStream.getToken(TSF_KEYWORD_IS_NAME);
40794:                     if (tt == TOK_NAME || tt == TOK_STRING) {
40270:                         atom = tokenStream.currentToken().t_atom;
40232:                         pn3 = NameNode::create(atom, tc);
    1:                         if (!pn3)
    1:                             return NULL;
40794:                     } else if (tt == TOK_NUMBER) {
40794:                         pn3 = NullaryNode::create(tc);
40794:                         if (!pn3)
40794:                             return NULL;
40794:                         pn3->pn_dval = tokenStream.currentToken().t_dval;
48470:                         if (!js_ValueToAtom(context, DoubleValue(pn3->pn_dval), &atom))
40794:                             return NULL;
40794:                     } else {
40794:                         tokenStream.ungetToken();
40794:                         goto property_name;
40794:                     }
    1: 
59962:                     pn->pn_xflags |= PNX_NONCONST;
59962: 
51087:                     /* NB: Getter function in { get x(){} } is unnamed. */
51089:                     pn2 = functionDef(NULL, op == JSOP_SETTER ? SETTER : GETTER, JSFUN_LAMBDA);
40232:                     pn2 = JSParseNode::newBinaryOrAppend(TOK_COLON, op, pn3, pn2, tc);
    1:                     goto skip;
    1:                 }
 1478:               property_name:
    1:               case TOK_STRING:
40270:                 atom = tokenStream.currentToken().t_atom;
40232:                 pn3 = NullaryNode::create(tc);
33749:                 if (!pn3)
33749:                     return NULL;
35310:                 pn3->pn_atom = atom;
    1:                 break;
    1:               case TOK_RC:
    1:                 goto end_obj_init;
    1:               default:
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_PROP_ID);
    1:                 return NULL;
    1:             }
    1: 
40855:             op = JSOP_INITPROP;
40354:             tt = tokenStream.getToken();
37685:             if (tt == TOK_COLON) {
40263:                 pnval = assignExpr();
59962:                 if (pnval && !pnval->isConstant())
59962:                     pn->pn_xflags |= PNX_NONCONST;
37685:             } else {
11039: #if JS_HAS_DESTRUCTURING_SHORTHAND
11039:                 if (tt != TOK_COMMA && tt != TOK_RC) {
11039: #endif
42671:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_COLON_AFTER_ID);
    1:                     return NULL;
11039: #if JS_HAS_DESTRUCTURING_SHORTHAND
11039:                 }
11039: 
11039:                 /*
11039:                  * Support, e.g., |var {x, y} = o| as destructuring shorthand
11039:                  * for |var {x: x, y: y} = o|, per proposed JS2/ES4 for JS1.8.
11039:                  */
40354:                 tokenStream.ungetToken();
59962:                 pn->pn_xflags |= PNX_DESTRUCT | PNX_NONCONST;
11039:                 pnval = pn3;
11039:                 if (pnval->pn_type == TOK_NAME) {
11039:                     pnval->pn_arity = PN_NAME;
40232:                     ((NameNode *)pnval)->initCommon(tc);
11039:                 }
11039: #endif
11039:             }
11039: 
40232:             pn2 = JSParseNode::newBinaryOrAppend(TOK_COLON, op, pn3, pnval, tc);
    1:           skip:
    1:             if (!pn2)
    1:                 return NULL;
27012:             pn->append(pn2);
    1: 
35310:             /*
60213:              * Check for duplicate property names.  Duplicate data properties
60213:              * only conflict in strict mode.  Duplicate getter or duplicate
60213:              * setter halves always conflict.  A data property conflicts with
60213:              * any part of an accessor property.
60213:              */
60213:             AssignmentType assignType;
37685:             if (op == JSOP_INITPROP) {
60213:                 assignType = VALUE;
37685:             } else if (op == JSOP_GETTER) {
60213:                 assignType = GET;
37685:             } else if (op == JSOP_SETTER) {
60213:                 assignType = SET;
37685:             } else {
35310:                 JS_NOT_REACHED("bad opcode in object initializer");
60213:                 assignType = VALUE; /* try to error early */
60213:             }
60213: 
60213:             if (JSAtomListElement *ale = seen.lookup(atom)) {
60213:                 AssignmentType oldAssignType = AssignmentType(ALE_INDEX(ale));
60213:                 if ((oldAssignType & assignType) &&
60213:                     (oldAssignType != VALUE || assignType != VALUE || tc->needStrictChecks()))
60213:                 {
57812:                     JSAutoByteString name;
60213:                     if (!js_AtomToPrintableString(context, atom, &name))
60213:                         return NULL;
60213: 
60213:                     uintN flags = (oldAssignType == VALUE &&
60213:                                    assignType == VALUE &&
60213:                                    !tc->inStrictMode())
60213:                                   ? JSREPORT_WARNING
60213:                                   : JSREPORT_ERROR;
60213:                     if (!ReportCompileErrorNumber(context, &tokenStream, NULL, flags,
60213:                                                   JSMSG_DUPLICATE_PROPERTY, name.ptr()))
60213:                     {
60213:                         return NULL;
60213:                     }
60213:                 }
60213:                 ALE_SET_INDEX(ale, assignType | oldAssignType);
35310:             } else {
40860:                 ale = seen.add(tc->parser, atom);
35310:                 if (!ale)
35310:                     return NULL;
60213:                 ALE_SET_INDEX(ale, assignType);
35310:             }
35310: 
40354:             tt = tokenStream.getToken();
    1:             if (tt == TOK_RC)
    1:                 goto end_obj_init;
    1:             if (tt != TOK_COMMA) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_CURLY_AFTER_LIST);
    1:                 return NULL;
    1:             }
    1:             afterComma = JS_TRUE;
    1:         }
 1967: 
    1:       end_obj_init:
40270:         pn->pn_pos.end = tokenStream.currentToken().pos.end;
    1:         return pn;
    1:       }
    1: 
 1967: #if JS_HAS_BLOCK_SCOPE
 1967:       case TOK_LET:
40263:         pn = letBlock(JS_FALSE);
 1967:         if (!pn)
 1967:             return NULL;
 1967:         break;
 1967: #endif
 1967: 
    1: #if JS_HAS_SHARP_VARS
    1:       case TOK_DEFSHARP:
40232:         pn = UnaryNode::create(tc);
26959:         if (!pn)
26959:             return NULL;
40270:         pn->pn_num = (jsint) tokenStream.currentToken().t_dval;
40854:         tt = tokenStream.getToken(TSF_OPERAND);
40263:         pn->pn_kid = primaryExpr(tt, JS_FALSE);
26959:         if (!pn->pn_kid)
26959:             return NULL;
42711:         if (PN_TYPE(pn->pn_kid) == TOK_USESHARP ||
42711:             PN_TYPE(pn->pn_kid) == TOK_DEFSHARP ||
42711:             PN_TYPE(pn->pn_kid) == TOK_STRING ||
42711:             PN_TYPE(pn->pn_kid) == TOK_NUMBER ||
42711:             PN_TYPE(pn->pn_kid) == TOK_PRIMARY) {
42719:             reportErrorNumber(pn->pn_kid, JSREPORT_ERROR, JSMSG_BAD_SHARP_VAR_DEF);
42711:             return NULL;
42711:         }
32729:         if (!tc->ensureSharpSlots())
32729:             return NULL;
26959:         break;
    1: 
    1:       case TOK_USESHARP:
    1:         /* Check for forward/dangling references at runtime, to allow eval. */
40232:         pn = NullaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
32729:         if (!tc->ensureSharpSlots())
32729:             return NULL;
40270:         pn->pn_num = (jsint) tokenStream.currentToken().t_dval;
    1:         break;
    1: #endif /* JS_HAS_SHARP_VARS */
    1: 
    1:       case TOK_LP:
 1577:       {
 1577:         JSBool genexp;
 1577: 
61058:         pn = parenExpr(&genexp);
    1:         if (!pn)
    1:             return NULL;
31479:         pn->pn_parens = true;
31479:         if (!genexp)
    1:             MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_IN_PAREN);
    1:         break;
 1577:       }
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_STAR:
40263:         pn = qualifiedIdentifier();
    1:         if (!pn)
    1:             return NULL;
    1:         break;
    1: 
    1:       case TOK_AT:
40263:         pn = attributeIdentifier();
    1:         if (!pn)
    1:             return NULL;
    1:         break;
    1: 
    1:       case TOK_XMLSTAGO:
40263:         pn = xmlElementOrListRoot(JS_TRUE);
    1:         if (!pn)
    1:             return NULL;
    1:         break;
    1: #endif /* JS_HAS_XML_SUPPORT */
    1: 
    1:       case TOK_STRING:
    1: #if JS_HAS_SHARP_VARS
    1:         /* FALL THROUGH */
    1: #endif
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_XMLCDATA:
    1:       case TOK_XMLCOMMENT:
    1:       case TOK_XMLPI:
    1: #endif
40232:         pn = NullaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
40270:         pn->pn_atom = tokenStream.currentToken().t_atom;
    1: #if JS_HAS_XML_SUPPORT
    1:         if (tt == TOK_XMLPI)
40270:             pn->pn_atom2 = tokenStream.currentToken().t_atom2;
    1:         else
    1: #endif
40270:             pn->pn_op = tokenStream.currentToken().t_op;
27012:         break;
27012: 
27012:       case TOK_NAME:
40270:         pn = NameNode::create(tokenStream.currentToken().t_atom, tc);
27012:         if (!pn)
27012:             return NULL;
40270:         JS_ASSERT(tokenStream.currentToken().t_op == JSOP_NAME);
27012:         pn->pn_op = JSOP_NAME;
27012: 
27012:         if ((tc->flags & (TCF_IN_FUNCTION | TCF_FUN_PARAM_ARGUMENTS)) == TCF_IN_FUNCTION &&
40239:             pn->pn_atom == context->runtime->atomState.argumentsAtom) {
27012:             /*
27012:              * Flag arguments usage so we can avoid unsafe optimizations such
27012:              * as formal parameter assignment analysis (because of the hated
27012:              * feature whereby arguments alias formals). We do this even for
27012:              * a reference of the form foo.arguments, which ancient code may
27012:              * still use instead of arguments (more hate).
27012:              */
72073:             tc->noteArgumentsUse(pn);
27012: 
27012:             /*
27012:              * Bind early to JSOP_ARGUMENTS to relieve later code from having
27012:              * to do this work (new rule for the emitter to count on).
27012:              */
64237:             if (!afterDot && !(tc->flags & TCF_DECL_DESTRUCTURING) && !tc->inStatement(STMT_WITH)) {
27012:                 pn->pn_op = JSOP_ARGUMENTS;
27012:                 pn->pn_dflags |= PND_BOUND;
27012:             }
27595:         } else if ((!afterDot
27595: #if JS_HAS_XML_SUPPORT
40354:                     || tokenStream.peekToken() == TOK_DBLCOLON
27595: #endif
33753:                    ) && !(tc->flags & TCF_DECL_DESTRUCTURING)) {
72073:             /* In case this is a generator expression outside of any function. */
72073:             if (!tc->inFunction() &&
72073:                 pn->pn_atom == context->runtime->atomState.argumentsAtom) {
72073:                 tc->countArgumentsUse(pn);
72073:             }
72073: 
27371:             JSStmtInfo *stmt = js_LexicalLookup(tc, pn->pn_atom, NULL);
54755: 
27012:             JSDefinition *dn;
27012: 
27371:             JSAtomListElement *ale = tc->decls.lookup(pn->pn_atom);
27012:             if (ale) {
27012:                 dn = ALE_DEFN(ale);
27012: #if JS_HAS_BLOCK_SCOPE
28967:                 /*
28967:                  * Skip out-of-scope let bindings along an ALE list or hash
28967:                  * chain. These can happen due to |let (x = x) x| block and
28967:                  * expression bindings, where the x on the right of = comes
28967:                  * from an outer scope. See bug 496532.
28967:                  */
28967:                 while (dn->isLet() && !BlockIdInScope(dn->pn_blockid, tc)) {
28967:                     do {
28967:                         ale = ALE_NEXT(ale);
28967:                     } while (ale && ALE_ATOM(ale) != pn->pn_atom);
28967:                     if (!ale)
28967:                         break;
28967:                     dn = ALE_DEFN(ale);
28967:                 }
27012: #endif
27012:             }
27012: 
27371:             if (ale) {
27371:                 dn = ALE_DEFN(ale);
27371:             } else {
27012:                 ale = tc->lexdeps.lookup(pn->pn_atom);
27371:                 if (ale) {
27371:                     dn = ALE_DEFN(ale);
27371:                 } else {
27371:                     /*
27371:                      * No definition before this use in any lexical scope.
27371:                      * Add a mapping in tc->lexdeps from pn->pn_atom to a
27371:                      * new node for the forward-referenced definition. This
27371:                      * placeholder definition node will be adopted when we
27371:                      * parse the real defining declaration form, or left as
27371:                      * a free variable definition if we never see the real
27371:                      * definition.
27012:                      */
27012:                     ale = MakePlaceholder(pn, tc);
27012:                     if (!ale)
27012:                         return NULL;
27012:                     dn = ALE_DEFN(ale);
27012: 
27012:                     /*
27371:                      * In case this is a forward reference to a function,
27371:                      * we pessimistically set PND_FUNARG if the next token
27371:                      * is not a left parenthesis.
27371:                      *
27371:                      * If the definition eventually parsed into dn is not a
27371:                      * function, this flag won't hurt, and if we do parse a
27371:                      * function with pn's name, then the PND_FUNARG flag is
40239:                      * necessary for safe context->display-based optimiza-
40239:                      * tion of the closure's static link.
27012:                      */
40354:                     if (tokenStream.peekToken() != TOK_LP)
27012:                         dn->pn_dflags |= PND_FUNARG;
27012:                 }
27012:             }
27012: 
27012:             JS_ASSERT(dn->pn_defn);
27012:             LinkUseToDef(pn, dn, tc);
27012: 
27012:             /* Here we handle the backward function reference case. */
40354:             if (tokenStream.peekToken() != TOK_LP)
27012:                 dn->pn_dflags |= PND_FUNARG;
27012: 
27012:             pn->pn_dflags |= (dn->pn_dflags & PND_FUNARG);
64237:             if (stmt && stmt->type == STMT_WITH)
54755:                 pn->pn_dflags |= PND_DEOPTIMIZED;
27371:         }
27371: 
    1: #if JS_HAS_XML_SUPPORT
40354:         if (tokenStream.matchToken(TOK_DBLCOLON)) {
    1:             if (afterDot) {
    1:                 /*
40239:                  * Here primaryExpr is called after . or .. followed by a name
27012:                  * followed by ::. This is the only case where a keyword after
27012:                  * . or .. is not treated as a property name.
    1:                  */
62048:                 const KeywordInfo *ki = FindKeyword(pn->pn_atom->charsZ(), pn->pn_atom->length());
62048:                 if (ki) {
62048:                     if (ki->tokentype != TOK_FUNCTION) {
62048:                         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_KEYWORD_NOT_NS);
62048:                         return NULL;
62048:                     }
62048: 
    1:                     pn->pn_arity = PN_NULLARY;
    1:                     pn->pn_type = TOK_FUNCTION;
    1:                 }
    1:             }
40263:             pn = qualifiedSuffix(pn);
    1:             if (!pn)
    1:                 return NULL;
    1:         }
    1: #endif
    1:         break;
    1: 
 6561:       case TOK_REGEXP:
 6561:       {
40232:         pn = NullaryNode::create(tc);
 6561:         if (!pn)
 6561:             return NULL;
 6561: 
53858:         JSObject *obj;
71696:         if (context->hasfp()) {
62876:             obj = RegExp::createObject(context, context->regExpStatics(),
53858:                                        tokenStream.getTokenbuf().begin(),
40270:                                        tokenStream.getTokenbuf().length(),
40270:                                        tokenStream.currentToken().t_reflags);
53858:         } else {
53858:             obj = RegExp::createObjectNoStatics(context,
53858:                                                 tokenStream.getTokenbuf().begin(),
53858:                                                 tokenStream.getTokenbuf().length(),
53858:                                                 tokenStream.currentToken().t_reflags);
53858:         }
53858: 
 6561:         if (!obj)
 6561:             return NULL;
41884:         if (!tc->compileAndGo()) {
39930:             obj->clearParent();
39928:             obj->clearProto();
 9481:         }
 6561: 
40860:         pn->pn_objbox = tc->parser->newObjectBox(obj);
27012:         if (!pn->pn_objbox)
 6561:             return NULL;
 6561: 
 6561:         pn->pn_op = JSOP_REGEXP;
 6561:         break;
 6561:       }
 6561: 
    1:       case TOK_NUMBER:
40232:         pn = NullaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
20902:         pn->pn_op = JSOP_DOUBLE;
40270:         pn->pn_dval = tokenStream.currentToken().t_dval;
    1:         break;
    1: 
    1:       case TOK_PRIMARY:
40232:         pn = NullaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
40270:         pn->pn_op = tokenStream.currentToken().t_op;
    1:         break;
    1: 
    1:       case TOK_ERROR:
    1:         /* The scanner or one of its subroutines reported the error. */
    1:         return NULL;
    1: 
    1:       default:
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_SYNTAX_ERROR);
    1:         return NULL;
    1:     }
    1:     return pn;
    1: }
    1: 
40239: JSParseNode *
61058: Parser::parenExpr(JSBool *genexp)
40221: {
40320:     TokenPtr begin;
 1577:     JSParseNode *pn;
 1577: 
40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_LP);
40270:     begin = tokenStream.currentToken().pos.begin;
 1577: 
 1577:     if (genexp)
 1577:         *genexp = JS_FALSE;
72073: 
72073:     GenexpGuard guard(tc);
72073: 
40263:     pn = bracketedExpr();
 1577:     if (!pn)
 1577:         return NULL;
72073:     guard.endBody();
 1577: 
 1577: #if JS_HAS_GENERATOR_EXPRS
40354:     if (tokenStream.matchToken(TOK_FOR)) {
72073:         if (!guard.checkValidBody(pn))
72073:             return NULL;
72073:         JS_ASSERT(pn->pn_type != TOK_YIELD);
31479:         if (pn->pn_type == TOK_COMMA && !pn->pn_parens) {
42671:             reportErrorNumber(pn->last(), JSREPORT_ERROR, JSMSG_BAD_GENERATOR_SYNTAX,
42671:                               js_generator_str);
 1577:             return NULL;
 1577:         }
61058:         pn = generatorExpr(pn);
27012:         if (!pn)
27012:             return NULL;
26970:         pn->pn_pos.begin = begin;
 1577:         if (genexp) {
40354:             if (tokenStream.getToken() != TOK_RP) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_GENERATOR_SYNTAX,
42671:                                   js_generator_str);
40221:                 return NULL;
40221:             }
40270:             pn->pn_pos.end = tokenStream.currentToken().pos.end;
 1577:             *genexp = JS_TRUE;
 1577:         }
 1577:     }
 1577: #endif /* JS_HAS_GENERATOR_EXPRS */
 1577: 
72565:     if (!maybeNoteGenerator())
72565:         return NULL;
72073: 
 1577:     return pn;
 1577: }
 1577: 
    1: /*
    1:  * Fold from one constant type to another.
    1:  * XXX handles only strings and numbers for now
    1:  */
    1: static JSBool
40320: FoldType(JSContext *cx, JSParseNode *pn, TokenKind type)
    1: {
27012:     if (PN_TYPE(pn) != type) {
    1:         switch (type) {
    1:           case TOK_NUMBER:
    1:             if (pn->pn_type == TOK_STRING) {
    1:                 jsdouble d;
64345:                 if (!ValueToNumber(cx, StringValue(pn->pn_atom), &d))
    1:                     return JS_FALSE;
    1:                 pn->pn_dval = d;
    1:                 pn->pn_type = TOK_NUMBER;
 3328:                 pn->pn_op = JSOP_DOUBLE;
    1:             }
    1:             break;
    1: 
    1:           case TOK_STRING:
    1:             if (pn->pn_type == TOK_NUMBER) {
    1:                 JSString *str = js_NumberToString(cx, pn->pn_dval);
    1:                 if (!str)
    1:                     return JS_FALSE;
70270:                 pn->pn_atom = js_AtomizeString(cx, str);
    1:                 if (!pn->pn_atom)
    1:                     return JS_FALSE;
    1:                 pn->pn_type = TOK_STRING;
    1:                 pn->pn_op = JSOP_STRING;
    1:             }
    1:             break;
    1: 
    1:           default:;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * Fold two numeric constants.  Beware that pn1 and pn2 are recycled, unless
    1:  * one of them aliases pn, so you can't safely fetch pn2->pn_next, e.g., after
    1:  * a successful call to this function.
    1:  */
    1: static JSBool
    1: FoldBinaryNumeric(JSContext *cx, JSOp op, JSParseNode *pn1, JSParseNode *pn2,
    1:                   JSParseNode *pn, JSTreeContext *tc)
    1: {
    1:     jsdouble d, d2;
    1:     int32 i, j;
    1: 
    1:     JS_ASSERT(pn1->pn_type == TOK_NUMBER && pn2->pn_type == TOK_NUMBER);
    1:     d = pn1->pn_dval;
    1:     d2 = pn2->pn_dval;
    1:     switch (op) {
    1:       case JSOP_LSH:
    1:       case JSOP_RSH:
 9613:         i = js_DoubleToECMAInt32(d);
 9613:         j = js_DoubleToECMAInt32(d2);
    1:         j &= 31;
    1:         d = (op == JSOP_LSH) ? i << j : i >> j;
    1:         break;
    1: 
    1:       case JSOP_URSH:
 9613:         j = js_DoubleToECMAInt32(d2);
    1:         j &= 31;
 9613:         d = js_DoubleToECMAUint32(d) >> j;
    1:         break;
    1: 
    1:       case JSOP_ADD:
    1:         d += d2;
    1:         break;
    1: 
    1:       case JSOP_SUB:
    1:         d -= d2;
    1:         break;
    1: 
    1:       case JSOP_MUL:
    1:         d *= d2;
    1:         break;
    1: 
    1:       case JSOP_DIV:
    1:         if (d2 == 0) {
    1: #if defined(XP_WIN)
    1:             /* XXX MSVC miscompiles such that (NaN == 0) */
    1:             if (JSDOUBLE_IS_NaN(d2))
34372:                 d = js_NaN;
    1:             else
    1: #endif
    1:             if (d == 0 || JSDOUBLE_IS_NaN(d))
34372:                 d = js_NaN;
32586:             else if (JSDOUBLE_IS_NEG(d) != JSDOUBLE_IS_NEG(d2))
34372:                 d = js_NegativeInfinity;
    1:             else
34372:                 d = js_PositiveInfinity;
    1:         } else {
    1:             d /= d2;
    1:         }
    1:         break;
    1: 
    1:       case JSOP_MOD:
    1:         if (d2 == 0) {
34372:             d = js_NaN;
    1:         } else {
30268:             d = js_fmod(d, d2);
    1:         }
    1:         break;
    1: 
    1:       default:;
    1:     }
    1: 
    1:     /* Take care to allow pn1 or pn2 to alias pn. */
    1:     if (pn1 != pn)
    1:         RecycleTree(pn1, tc);
    1:     if (pn2 != pn)
    1:         RecycleTree(pn2, tc);
    1:     pn->pn_type = TOK_NUMBER;
 3328:     pn->pn_op = JSOP_DOUBLE;
    1:     pn->pn_arity = PN_NULLARY;
    1:     pn->pn_dval = d;
    1:     return JS_TRUE;
    1: }
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: 
    1: static JSBool
    1: FoldXMLConstants(JSContext *cx, JSParseNode *pn, JSTreeContext *tc)
    1: {
40320:     TokenKind tt;
    1:     JSParseNode **pnp, *pn1, *pn2;
    1:     JSString *accum, *str;
    1:     uint32 i, j;
    1: 
    1:     JS_ASSERT(pn->pn_arity == PN_LIST);
 3164:     tt = PN_TYPE(pn);
    1:     pnp = &pn->pn_head;
    1:     pn1 = *pnp;
    1:     accum = NULL;
60569:     str = NULL;
27012:     if ((pn->pn_xflags & PNX_CANTFOLD) == 0) {
    1:         if (tt == TOK_XMLETAGO)
64345:             accum = cx->runtime->atomState.etagoAtom;
    1:         else if (tt == TOK_XMLSTAGO || tt == TOK_XMLPTAGC)
64345:             accum = cx->runtime->atomState.stagoAtom;
    1:     }
    1: 
12677:     /*
12677:      * GC Rooting here is tricky: for most of the loop, |accum| is safe via
12677:      * the newborn string root. However, when |pn2->pn_type| is TOK_XMLCDATA,
12677:      * TOK_XMLCOMMENT, or TOK_XMLPI it is knocked out of the newborn root.
12677:      * Therefore, we have to add additonal protection from GC nesting under
12677:      * js_ConcatStrings.
12677:      */
    1:     for (pn2 = pn1, i = j = 0; pn2; pn2 = pn2->pn_next, i++) {
    1:         /* The parser already rejected end-tags with attributes. */
    1:         JS_ASSERT(tt != TOK_XMLETAGO || i == 0);
    1:         switch (pn2->pn_type) {
    1:           case TOK_XMLATTR:
    1:             if (!accum)
    1:                 goto cantfold;
    1:             /* FALL THROUGH */
    1:           case TOK_XMLNAME:
    1:           case TOK_XMLSPACE:
    1:           case TOK_XMLTEXT:
    1:           case TOK_STRING:
    1:             if (pn2->pn_arity == PN_LIST)
    1:                 goto cantfold;
64345:             str = pn2->pn_atom;
    1:             break;
    1: 
    1:           case TOK_XMLCDATA:
64345:             str = js_MakeXMLCDATAString(cx, pn2->pn_atom);
    1:             if (!str)
    1:                 return JS_FALSE;
    1:             break;
    1: 
    1:           case TOK_XMLCOMMENT:
64345:             str = js_MakeXMLCommentString(cx, pn2->pn_atom);
    1:             if (!str)
    1:                 return JS_FALSE;
    1:             break;
    1: 
    1:           case TOK_XMLPI:
64345:             str = js_MakeXMLPIString(cx, pn2->pn_atom, pn2->pn_atom2);
    1:             if (!str)
    1:                 return JS_FALSE;
    1:             break;
    1: 
    1:           cantfold:
    1:           default:
    1:             JS_ASSERT(*pnp == pn1);
    1:             if ((tt == TOK_XMLSTAGO || tt == TOK_XMLPTAGC) &&
    1:                 (i & 1) ^ (j & 1)) {
    1: #ifdef DEBUG_brendanXXX
    1:                 printf("1: %d, %d => ", i, j);
    1:                 if (accum)
57721:                     FileEscapedString(stdout, accum, 0);
    1:                 else
    1:                     fputs("NULL", stdout);
    1:                 fputc('\n', stdout);
    1: #endif
    1:             } else if (accum && pn1 != pn2) {
    1:                 while (pn1->pn_next != pn2) {
    1:                     pn1 = RecycleTree(pn1, tc);
    1:                     --pn->pn_count;
    1:                 }
    1:                 pn1->pn_type = TOK_XMLTEXT;
    1:                 pn1->pn_op = JSOP_STRING;
    1:                 pn1->pn_arity = PN_NULLARY;
70270:                 pn1->pn_atom = js_AtomizeString(cx, accum);
    1:                 if (!pn1->pn_atom)
    1:                     return JS_FALSE;
    1:                 JS_ASSERT(pnp != &pn1->pn_next);
    1:                 *pnp = pn1;
    1:             }
    1:             pnp = &pn2->pn_next;
    1:             pn1 = *pnp;
    1:             accum = NULL;
    1:             continue;
    1:         }
    1: 
    1:         if (accum) {
40398:             {
48470:                 AutoStringRooter tvr(cx, accum);
    1:                 str = ((tt == TOK_XMLSTAGO || tt == TOK_XMLPTAGC) && i != 0)
    1:                       ? js_AddAttributePart(cx, i & 1, accum, str)
    1:                       : js_ConcatStrings(cx, accum, str);
40398:             }
    1:             if (!str)
    1:                 return JS_FALSE;
    1: #ifdef DEBUG_brendanXXX
    1:             printf("2: %d, %d => ", i, j);
57721:             FileEscapedString(stdout, str, 0);
29366:             printf(" (%u)\n", str->length());
    1: #endif
    1:             ++j;
    1:         }
    1:         accum = str;
    1:     }
    1: 
    1:     if (accum) {
    1:         str = NULL;
27012:         if ((pn->pn_xflags & PNX_CANTFOLD) == 0) {
    1:             if (tt == TOK_XMLPTAGC)
64345:                 str = cx->runtime->atomState.ptagcAtom;
    1:             else if (tt == TOK_XMLSTAGO || tt == TOK_XMLETAGO)
64345:                 str = cx->runtime->atomState.tagcAtom;
    1:         }
    1:         if (str) {
    1:             accum = js_ConcatStrings(cx, accum, str);
    1:             if (!accum)
    1:                 return JS_FALSE;
    1:         }
    1: 
    1:         JS_ASSERT(*pnp == pn1);
    1:         while (pn1->pn_next) {
    1:             pn1 = RecycleTree(pn1, tc);
    1:             --pn->pn_count;
    1:         }
    1:         pn1->pn_type = TOK_XMLTEXT;
    1:         pn1->pn_op = JSOP_STRING;
    1:         pn1->pn_arity = PN_NULLARY;
70270:         pn1->pn_atom = js_AtomizeString(cx, accum);
    1:         if (!pn1->pn_atom)
    1:             return JS_FALSE;
    1:         JS_ASSERT(pnp != &pn1->pn_next);
    1:         *pnp = pn1;
    1:     }
    1: 
    1:     if (pn1 && pn->pn_count == 1) {
    1:         /*
    1:          * Only one node under pn, and it has been folded: move pn1 onto pn
    1:          * unless pn is an XML root (in which case we need it to tell the code
    1:          * generator to emit a JSOP_TOXML or JSOP_TOXMLLIST op).  If pn is an
    1:          * XML root *and* it's a point-tag, rewrite it to TOK_XMLELEM to avoid
    1:          * extra "<" and "/>" bracketing at runtime.
    1:          */
27012:         if (!(pn->pn_xflags & PNX_XMLROOT)) {
27012:             pn->become(pn1);
    1:         } else if (tt == TOK_XMLPTAGC) {
    1:             pn->pn_type = TOK_XMLELEM;
    1:             pn->pn_op = JSOP_TOXML;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: #endif /* JS_HAS_XML_SUPPORT */
    1: 
20902: static int
20902: Boolish(JSParseNode *pn)
20902: {
20902:     switch (pn->pn_op) {
20902:       case JSOP_DOUBLE:
20918:         return pn->pn_dval != 0 && !JSDOUBLE_IS_NaN(pn->pn_dval);
20902: 
20902:       case JSOP_STRING:
64345:         return pn->pn_atom->length() != 0;
20902: 
20906: #if JS_HAS_GENERATOR_EXPRS
20902:       case JSOP_CALL:
20904:       {
20902:         /*
20902:          * A generator expression as an if or loop condition has no effects, it
20902:          * simply results in a truthy object reference. This condition folding
20903:          * is needed for the decompiler. See bug 442342 and bug 443074.
20902:          */
20902:         if (pn->pn_count != 1)
20902:             break;
20902:         JSParseNode *pn2 = pn->pn_head;
20902:         if (pn2->pn_type != TOK_FUNCTION)
20902:             break;
27012:         if (!(pn2->pn_funbox->tcflags & TCF_GENEXP_LAMBDA))
20902:             break;
20902:         /* FALL THROUGH */
20904:       }
20906: #endif
20902: 
20902:       case JSOP_DEFFUN:
27012:       case JSOP_LAMBDA:
20902:       case JSOP_TRUE:
20902:         return 1;
20902: 
20902:       case JSOP_NULL:
20902:       case JSOP_FALSE:
20902:         return 0;
20902: 
20902:       default:;
20902:     }
20902:     return -1;
20902: }
20902: 
    1: JSBool
20902: js_FoldConstants(JSContext *cx, JSParseNode *pn, JSTreeContext *tc, bool inCond)
    1: {
    1:     JSParseNode *pn1 = NULL, *pn2 = NULL, *pn3 = NULL;
11139: 
11139:     JS_CHECK_RECURSION(cx, return JS_FALSE);
    1: 
    1:     switch (pn->pn_arity) {
    1:       case PN_FUNC:
    1:       {
33752:         uint32 oldflags = tc->flags;
27012:         JSFunctionBox *oldlist = tc->functionList;
27012: 
33752:         tc->flags = pn->pn_funbox->tcflags;
27012:         tc->functionList = pn->pn_funbox->kids;
    1:         if (!js_FoldConstants(cx, pn->pn_body, tc))
    1:             return JS_FALSE;
27012:         pn->pn_funbox->kids = tc->functionList;
    1:         tc->flags = oldflags;
27012:         tc->functionList = oldlist;
    1:         break;
    1:       }
    1: 
    1:       case PN_LIST:
21457:       {
21457:         /* Propagate inCond through logical connectives. */
21457:         bool cond = inCond && (pn->pn_type == TOK_OR || pn->pn_type == TOK_AND);
21457: 
37657:         /* Don't fold a parenthesized call expression. See bug 537673. */
37657:         pn1 = pn2 = pn->pn_head;
37657:         if ((pn->pn_type == TOK_LP || pn->pn_type == TOK_NEW) && pn2->pn_parens)
37657:             pn2 = pn2->pn_next;
37657: 
    1:         /* Save the list head in pn1 for later use. */
37657:         for (; pn2; pn2 = pn2->pn_next) {
21457:             if (!js_FoldConstants(cx, pn2, tc, cond))
    1:                 return JS_FALSE;
    1:         }
    1:         break;
21457:       }
    1: 
    1:       case PN_TERNARY:
    1:         /* Any kid may be null (e.g. for (;;)). */
    1:         pn1 = pn->pn_kid1;
    1:         pn2 = pn->pn_kid2;
    1:         pn3 = pn->pn_kid3;
20902:         if (pn1 && !js_FoldConstants(cx, pn1, tc, pn->pn_type == TOK_IF))
    1:             return JS_FALSE;
20902:         if (pn2) {
20902:             if (!js_FoldConstants(cx, pn2, tc, pn->pn_type == TOK_FORHEAD))
    1:                 return JS_FALSE;
20902:             if (pn->pn_type == TOK_FORHEAD && pn2->pn_op == JSOP_TRUE) {
20902:                 RecycleTree(pn2, tc);
20902:                 pn->pn_kid2 = NULL;
20902:             }
20902:         }
    1:         if (pn3 && !js_FoldConstants(cx, pn3, tc))
    1:             return JS_FALSE;
    1:         break;
    1: 
    1:       case PN_BINARY:
    1:         pn1 = pn->pn_left;
    1:         pn2 = pn->pn_right;
20902: 
20902:         /* Propagate inCond through logical connectives. */
20909:         if (pn->pn_type == TOK_OR || pn->pn_type == TOK_AND) {
20902:             if (!js_FoldConstants(cx, pn1, tc, inCond))
    1:                 return JS_FALSE;
20902:             if (!js_FoldConstants(cx, pn2, tc, inCond))
20902:                 return JS_FALSE;
20902:             break;
20902:         }
20902: 
20902:         /* First kid may be null (for default case in switch). */
20902:         if (pn1 && !js_FoldConstants(cx, pn1, tc, pn->pn_type == TOK_WHILE))
20902:             return JS_FALSE;
20902:         if (!js_FoldConstants(cx, pn2, tc, pn->pn_type == TOK_DO))
    1:             return JS_FALSE;
    1:         break;
    1: 
    1:       case PN_UNARY:
    1:         pn1 = pn->pn_kid;
35096: 
35096:         /*
35096:          * Kludge to deal with typeof expressions: because constant folding
35096:          * can turn an expression into a name node, we have to check here,
35096:          * before folding, to see if we should throw undefined name errors.
35096:          *
35096:          * NB: We know that if pn->pn_op is JSOP_TYPEOF, pn1 will not be
35096:          * null. This assumption does not hold true for other unary
35096:          * expressions.
35096:          */
35096:         if (pn->pn_op == JSOP_TYPEOF && pn1->pn_type != TOK_NAME)
35096:             pn->pn_op = JSOP_TYPEOFEXPR;
35096: 
31479:         if (pn1 && !js_FoldConstants(cx, pn1, tc, pn->pn_op == JSOP_NOT))
    1:             return JS_FALSE;
    1:         break;
    1: 
    1:       case PN_NAME:
    1:         /*
    1:          * Skip pn1 down along a chain of dotted member expressions to avoid
    1:          * excessive recursion.  Our only goal here is to fold constants (if
    1:          * any) in the primary expression operand to the left of the first
    1:          * dot in the chain.
    1:          */
27012:         if (!pn->pn_used) {
    1:             pn1 = pn->pn_expr;
27012:             while (pn1 && pn1->pn_arity == PN_NAME && !pn1->pn_used)
    1:                 pn1 = pn1->pn_expr;
    1:             if (pn1 && !js_FoldConstants(cx, pn1, tc))
    1:                 return JS_FALSE;
27012:         }
27012:         break;
27012: 
27012:       case PN_NAMESET:
27012:         pn1 = pn->pn_tree;
27012:         if (!js_FoldConstants(cx, pn1, tc))
27012:             return JS_FALSE;
    1:         break;
    1: 
    1:       case PN_NULLARY:
    1:         break;
    1:     }
    1: 
    1:     switch (pn->pn_type) {
    1:       case TOK_IF:
    1:         if (ContainsStmt(pn2, TOK_VAR) || ContainsStmt(pn3, TOK_VAR))
    1:             break;
    1:         /* FALL THROUGH */
    1: 
    1:       case TOK_HOOK:
    1:         /* Reduce 'if (C) T; else E' into T for true C, E for false. */
    1:         switch (pn1->pn_type) {
    1:           case TOK_NUMBER:
  207:             if (pn1->pn_dval == 0 || JSDOUBLE_IS_NaN(pn1->pn_dval))
    1:                 pn2 = pn3;
    1:             break;
    1:           case TOK_STRING:
64345:             if (pn1->pn_atom->length() == 0)
    1:                 pn2 = pn3;
    1:             break;
    1:           case TOK_PRIMARY:
    1:             if (pn1->pn_op == JSOP_TRUE)
    1:                 break;
    1:             if (pn1->pn_op == JSOP_FALSE || pn1->pn_op == JSOP_NULL) {
    1:                 pn2 = pn3;
    1:                 break;
    1:             }
    1:             /* FALL THROUGH */
    1:           default:
    1:             /* Early return to dodge common code that copies pn2 to pn. */
    1:             return JS_TRUE;
    1:         }
    1: 
 1577: #if JS_HAS_GENERATOR_EXPRS
 1577:         /* Don't fold a trailing |if (0)| in a generator expression. */
 1577:         if (!pn2 && (tc->flags & TCF_GENEXP_LAMBDA))
 1577:             break;
 1577: #endif
 1577: 
31479:         if (pn2 && !pn2->pn_defn)
27012:             pn->become(pn2);
    1:         if (!pn2 || (pn->pn_type == TOK_SEMI && !pn->pn_kid)) {
    1:             /*
    1:              * False condition and no else, or an empty then-statement was
    1:              * moved up over pn.  Either way, make pn an empty block (not an
    1:              * empty statement, which does not decompile, even when labeled).
    1:              * NB: pn must be a TOK_IF as TOK_HOOK can never have a null kid
    1:              * or an empty statement for a child.
    1:              */
    1:             pn->pn_type = TOK_LC;
    1:             pn->pn_arity = PN_LIST;
27012:             pn->makeEmpty();
    1:         }
    1:         RecycleTree(pn2, tc);
    1:         if (pn3 && pn3 != pn2)
    1:             RecycleTree(pn3, tc);
    1:         break;
    1: 
20902:       case TOK_OR:
20905:       case TOK_AND:
20902:         if (inCond) {
20905:             if (pn->pn_arity == PN_LIST) {
20905:                 JSParseNode **pnp = &pn->pn_head;
20905:                 JS_ASSERT(*pnp == pn1);
20905:                 do {
20905:                     int cond = Boolish(pn1);
20905:                     if (cond == (pn->pn_type == TOK_OR)) {
20905:                         for (pn2 = pn1->pn_next; pn2; pn2 = pn3) {
20905:                             pn3 = pn2->pn_next;
20905:                             RecycleTree(pn2, tc);
20905:                             --pn->pn_count;
20905:                         }
20905:                         pn1->pn_next = NULL;
20905:                         break;
20905:                     }
20905:                     if (cond != -1) {
20905:                         JS_ASSERT(cond == (pn->pn_type == TOK_AND));
20905:                         if (pn->pn_count == 1)
20905:                             break;
20905:                         *pnp = pn1->pn_next;
20905:                         RecycleTree(pn1, tc);
20905:                         --pn->pn_count;
20905:                     } else {
20905:                         pnp = &pn1->pn_next;
20905:                     }
20905:                 } while ((pn1 = *pnp) != NULL);
20905: 
20905:                 // We may have to change arity from LIST to BINARY.
20911:                 pn1 = pn->pn_head;
20905:                 if (pn->pn_count == 2) {
20905:                     pn2 = pn1->pn_next;
20905:                     pn1->pn_next = NULL;
20905:                     JS_ASSERT(!pn2->pn_next);
20905:                     pn->pn_arity = PN_BINARY;
20905:                     pn->pn_left = pn1;
20905:                     pn->pn_right = pn2;
20905:                 } else if (pn->pn_count == 1) {
27012:                     pn->become(pn1);
20905:                     RecycleTree(pn1, tc);
20905:                 }
20905:             } else {
20905:                 int cond = Boolish(pn1);
20905:                 if (cond == (pn->pn_type == TOK_OR)) {
20902:                     RecycleTree(pn2, tc);
27012:                     pn->become(pn1);
20905:                 } else if (cond != -1) {
20905:                     JS_ASSERT(cond == (pn->pn_type == TOK_AND));
20902:                     RecycleTree(pn1, tc);
27012:                     pn->become(pn2);
20902:                 }
20902:             }
20902:         }
20902:         break;
20902: 
    1:       case TOK_ASSIGN:
    1:         /*
    1:          * Compound operators such as *= should be subject to folding, in case
    1:          * the left-hand side is constant, and so that the decompiler produces
    1:          * the same string that you get from decompiling a script or function
    1:          * compiled from that same string.  As with +, += is special.
    1:          */
    1:         if (pn->pn_op == JSOP_NOP)
    1:             break;
    1:         if (pn->pn_op != JSOP_ADD)
    1:             goto do_binary_op;
    1:         /* FALL THROUGH */
    1: 
    1:       case TOK_PLUS:
    1:         if (pn->pn_arity == PN_LIST) {
    1:             /*
    1:              * Any string literal term with all others number or string means
    1:              * this is a concatenation.  If any term is not a string or number
    1:              * literal, we can't fold.
    1:              */
    1:             JS_ASSERT(pn->pn_count > 2);
27012:             if (pn->pn_xflags & PNX_CANTFOLD)
    1:                 return JS_TRUE;
27012:             if (pn->pn_xflags != PNX_STRCAT)
    1:                 goto do_binary_op;
    1: 
    1:             /* Ok, we're concatenating: convert non-string constant operands. */
64345:             size_t length = 0;
    1:             for (pn2 = pn1; pn2; pn2 = pn2->pn_next) {
    1:                 if (!FoldType(cx, pn2, TOK_STRING))
    1:                     return JS_FALSE;
    1:                 /* XXX fold only if all operands convert to string */
    1:                 if (pn2->pn_type != TOK_STRING)
    1:                     return JS_TRUE;
64345:                 length += pn2->pn_atom->length();
    1:             }
    1: 
    1:             /* Allocate a new buffer and string descriptor for the result. */
64560:             jschar *chars = (jschar *) cx->malloc_((length + 1) * sizeof(jschar));
    1:             if (!chars)
    1:                 return JS_FALSE;
58991:             chars[length] = 0;
64345:             JSString *str = js_NewString(cx, chars, length);
    1:             if (!str) {
64560:                 cx->free_(chars);
    1:                 return JS_FALSE;
    1:             }
    1: 
    1:             /* Fill the buffer, advancing chars and recycling kids as we go. */
    1:             for (pn2 = pn1; pn2; pn2 = RecycleTree(pn2, tc)) {
64345:                 JSAtom *atom = pn2->pn_atom;
64345:                 size_t length2 = atom->length();
64345:                 js_strncpy(chars, atom->chars(), length2);
    1:                 chars += length2;
    1:             }
58991:             JS_ASSERT(*chars == 0);
    1: 
    1:             /* Atomize the result string and mutate pn to refer to it. */
70270:             pn->pn_atom = js_AtomizeString(cx, str);
    1:             if (!pn->pn_atom)
    1:                 return JS_FALSE;
    1:             pn->pn_type = TOK_STRING;
    1:             pn->pn_op = JSOP_STRING;
    1:             pn->pn_arity = PN_NULLARY;
    1:             break;
    1:         }
    1: 
    1:         /* Handle a binary string concatenation. */
    1:         JS_ASSERT(pn->pn_arity == PN_BINARY);
    1:         if (pn1->pn_type == TOK_STRING || pn2->pn_type == TOK_STRING) {
    1:             JSString *left, *right, *str;
    1: 
    1:             if (!FoldType(cx, (pn1->pn_type != TOK_STRING) ? pn1 : pn2,
    1:                           TOK_STRING)) {
    1:                 return JS_FALSE;
    1:             }
    1:             if (pn1->pn_type != TOK_STRING || pn2->pn_type != TOK_STRING)
    1:                 return JS_TRUE;
64345:             left = pn1->pn_atom;
64345:             right = pn2->pn_atom;
    1:             str = js_ConcatStrings(cx, left, right);
    1:             if (!str)
    1:                 return JS_FALSE;
70270:             pn->pn_atom = js_AtomizeString(cx, str);
    1:             if (!pn->pn_atom)
    1:                 return JS_FALSE;
    1:             pn->pn_type = TOK_STRING;
    1:             pn->pn_op = JSOP_STRING;
    1:             pn->pn_arity = PN_NULLARY;
    1:             RecycleTree(pn1, tc);
    1:             RecycleTree(pn2, tc);
    1:             break;
    1:         }
    1: 
    1:         /* Can't concatenate string literals, let's try numbers. */
    1:         goto do_binary_op;
    1: 
    1:       case TOK_STAR:
    1:       case TOK_SHOP:
    1:       case TOK_MINUS:
    1:       case TOK_DIVOP:
    1:       do_binary_op:
    1:         if (pn->pn_arity == PN_LIST) {
    1:             JS_ASSERT(pn->pn_count > 2);
    1:             for (pn2 = pn1; pn2; pn2 = pn2->pn_next) {
    1:                 if (!FoldType(cx, pn2, TOK_NUMBER))
    1:                     return JS_FALSE;
    1:             }
    1:             for (pn2 = pn1; pn2; pn2 = pn2->pn_next) {
    1:                 /* XXX fold only if all operands convert to number */
    1:                 if (pn2->pn_type != TOK_NUMBER)
    1:                     break;
    1:             }
    1:             if (!pn2) {
 3164:                 JSOp op = PN_OP(pn);
    1: 
    1:                 pn2 = pn1->pn_next;
    1:                 pn3 = pn2->pn_next;
    1:                 if (!FoldBinaryNumeric(cx, op, pn1, pn2, pn, tc))
    1:                     return JS_FALSE;
    1:                 while ((pn2 = pn3) != NULL) {
    1:                     pn3 = pn2->pn_next;
    1:                     if (!FoldBinaryNumeric(cx, op, pn, pn2, pn, tc))
    1:                         return JS_FALSE;
    1:                 }
    1:             }
    1:         } else {
    1:             JS_ASSERT(pn->pn_arity == PN_BINARY);
    1:             if (!FoldType(cx, pn1, TOK_NUMBER) ||
    1:                 !FoldType(cx, pn2, TOK_NUMBER)) {
    1:                 return JS_FALSE;
    1:             }
    1:             if (pn1->pn_type == TOK_NUMBER && pn2->pn_type == TOK_NUMBER) {
 3164:                 if (!FoldBinaryNumeric(cx, PN_OP(pn), pn1, pn2, pn, tc))
    1:                     return JS_FALSE;
    1:             }
    1:         }
    1:         break;
    1: 
    1:       case TOK_UNARYOP:
    1:         if (pn1->pn_type == TOK_NUMBER) {
    1:             jsdouble d;
    1: 
    1:             /* Operate on one numeric constant. */
    1:             d = pn1->pn_dval;
    1:             switch (pn->pn_op) {
    1:               case JSOP_BITNOT:
 9613:                 d = ~js_DoubleToECMAInt32(d);
    1:                 break;
    1: 
    1:               case JSOP_NEG:
    1:                 d = -d;
    1:                 break;
    1: 
    1:               case JSOP_POS:
    1:                 break;
    1: 
    1:               case JSOP_NOT:
    1:                 pn->pn_type = TOK_PRIMARY;
  207:                 pn->pn_op = (d == 0 || JSDOUBLE_IS_NaN(d)) ? JSOP_TRUE : JSOP_FALSE;
    1:                 pn->pn_arity = PN_NULLARY;
    1:                 /* FALL THROUGH */
    1: 
    1:               default:
    1:                 /* Return early to dodge the common TOK_NUMBER code. */
    1:                 return JS_TRUE;
    1:             }
    1:             pn->pn_type = TOK_NUMBER;
 3328:             pn->pn_op = JSOP_DOUBLE;
    1:             pn->pn_arity = PN_NULLARY;
    1:             pn->pn_dval = d;
    1:             RecycleTree(pn1, tc);
20918:         } else if (pn1->pn_type == TOK_PRIMARY) {
20918:             if (pn->pn_op == JSOP_NOT &&
20918:                 (pn1->pn_op == JSOP_TRUE ||
20918:                  pn1->pn_op == JSOP_FALSE)) {
27012:                 pn->become(pn1);
20918:                 pn->pn_op = (pn->pn_op == JSOP_TRUE) ? JSOP_FALSE : JSOP_TRUE;
20918:                 RecycleTree(pn1, tc);
20918:             }
    1:         }
    1:         break;
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_XMLELEM:
    1:       case TOK_XMLLIST:
    1:       case TOK_XMLPTAGC:
    1:       case TOK_XMLSTAGO:
    1:       case TOK_XMLETAGO:
    1:       case TOK_XMLNAME:
    1:         if (pn->pn_arity == PN_LIST) {
    1:             JS_ASSERT(pn->pn_type == TOK_XMLLIST || pn->pn_count != 0);
    1:             if (!FoldXMLConstants(cx, pn, tc))
    1:                 return JS_FALSE;
    1:         }
    1:         break;
    1: 
    1:       case TOK_AT:
    1:         if (pn1->pn_type == TOK_XMLNAME) {
27012:             JSObjectBox *xmlbox;
    1: 
64345:             Value v = StringValue(pn1->pn_atom);
    1:             if (!js_ToAttributeName(cx, &v))
    1:                 return JS_FALSE;
48470:             JS_ASSERT(v.isObject());
48470: 
48470:             xmlbox = tc->parser->newObjectBox(&v.toObject());
27012:             if (!xmlbox)
    1:                 return JS_FALSE;
    1: 
    1:             pn->pn_type = TOK_XMLNAME;
    1:             pn->pn_op = JSOP_OBJECT;
    1:             pn->pn_arity = PN_NULLARY;
27012:             pn->pn_objbox = xmlbox;
    1:             RecycleTree(pn1, tc);
    1:         }
    1:         break;
    1: #endif /* JS_HAS_XML_SUPPORT */
    1: 
    1:       default:;
    1:     }
    1: 
20902:     if (inCond) {
20902:         int cond = Boolish(pn);
20902:         if (cond >= 0) {
60789:             /*
60789:              * We can turn function nodes into constant nodes here, but mutating function
60789:              * nodes is tricky --- in particular, mutating a function node that appears on
60789:              * a method list corrupts the method list. However, methods are M's in
60789:              * statements of the form 'this.foo = M;', which we never fold, so we're okay.
60789:              */
60789:             PrepareNodeForMutation(pn, tc);
20902:             pn->pn_type = TOK_PRIMARY;
20902:             pn->pn_op = cond ? JSOP_TRUE : JSOP_FALSE;
20902:             pn->pn_arity = PN_NULLARY;
20902:         }
20902:     }
20902: 
    1:     return JS_TRUE;
    1: }
