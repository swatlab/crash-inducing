    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsMimeTypeArray.h"
    1: #include "nsContentUtils.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIDOMNavigator.h"
    1: #include "nsIDOMPluginArray.h"
    1: #include "nsIDOMPlugin.h"
    1: #include "nsDOMClassInfo.h"
    1: #include "nsIMIMEService.h"
    1: #include "nsIMIMEInfo.h"
    1: #include "nsIFile.h"
    1: 
    1: 
    1: nsMimeTypeArray::nsMimeTypeArray(nsIDOMNavigator* navigator)
21159:   : mNavigator(navigator),
21159:     mPluginMimeTypeCount(0),
21159:     mInited(PR_FALSE)
    1: {
    1: }
    1: 
    1: nsMimeTypeArray::~nsMimeTypeArray()
    1: {
    1:   Clear();
    1: }
    1: 
    1: 
    1: // QueryInterface implementation for nsMimeTypeArray
    1: NS_INTERFACE_MAP_BEGIN(nsMimeTypeArray)
    1:   NS_INTERFACE_MAP_ENTRY(nsISupports)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMMimeTypeArray)
    1:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(MimeTypeArray)
    1: NS_INTERFACE_MAP_END
    1: 
    1: 
    1: NS_IMPL_ADDREF(nsMimeTypeArray)
    1: NS_IMPL_RELEASE(nsMimeTypeArray)
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsMimeTypeArray::GetLength(PRUint32* aLength)
    1: {
21159:   if (!mInited) {
    1:     nsresult rv = GetMimeTypes();
    1:     if (rv != NS_OK)
    1:       return rv;
    1:   }
21159: 
21432:   NS_ASSERTION(mPluginMimeTypeCount <= (PRUint32)mMimeTypeArray.Count(),
21159:                "The number of total mimetypes should be equal to or higher "
21159:                "than the number of plugin mimetypes.");
21159:  
21159:   *aLength = mPluginMimeTypeCount;
    1:   return NS_OK;
    1: }
    1: 
20752: nsIDOMMimeType*
20752: nsMimeTypeArray::GetItemAt(PRUint32 aIndex, nsresult *aResult)
20752: {
21159:   if (!mInited) {
20752:     *aResult = GetMimeTypes();
20752:     if (*aResult != NS_OK)
20752:       return nsnull;
20752:   }
20752: 
21432:   NS_ASSERTION(mPluginMimeTypeCount <= (PRUint32)mMimeTypeArray.Count(),
21159:                "The number of total mimetypes should be equal to or higher "
21159:                "than the number of plugin mimetypes.");
21159: 
21159:   if (aIndex >= mPluginMimeTypeCount) {
20752:     *aResult = NS_ERROR_FAILURE;
20752: 
20752:     return nsnull;
20752:   }
20752: 
20752:   *aResult = NS_OK;
20752: 
20752:   return mMimeTypeArray[aIndex];
20752: }
20752: 
    1: NS_IMETHODIMP
    1: nsMimeTypeArray::Item(PRUint32 aIndex, nsIDOMMimeType** aReturn)
    1: {
20752:   nsresult rv;
20752: 
20752:   NS_IF_ADDREF(*aReturn = GetItemAt(aIndex, &rv));
20752: 
    1:   return rv;
    1: }
    1: 
21159: nsIDOMMimeType*
21159: nsMimeTypeArray::GetNamedItem(const nsAString& aName, nsresult* aResult)
    1: {
21159:   if (!mInited) {
21159:     *aResult = GetMimeTypes();
21159:     if (*aResult != NS_OK)
21159:       return nsnull;
21159:   }
21154: 
21432:   NS_ASSERTION(mPluginMimeTypeCount <= (PRUint32)mMimeTypeArray.Count(),
21159:                "The number of total mimetypes should be equal to or higher "
21159:                "than the number of plugin mimetypes.");
21159: 
21159:   *aResult = NS_OK;
    1: 
    1:   nsAutoString type;
    1: 
21159:   for (PRInt32 i = 0; i < mMimeTypeArray.Count(); i++) {
    1:     nsIDOMMimeType *mtype = mMimeTypeArray[i];
    1: 
    1:     mtype->GetType(type);
    1: 
    1:     if (type.Equals(aName)) {
21159:       return mtype;
    1:     }
    1:   }
    1: 
    1:   // Now let's check with the MIME service.
    1:   nsCOMPtr<nsIMIMEService> mimeSrv = do_GetService("@mozilla.org/mime;1");
    1:   if (mimeSrv) {
    1:     nsCOMPtr<nsIMIMEInfo> mimeInfo;
    1:     mimeSrv->GetFromTypeAndExtension(NS_ConvertUTF16toUTF8(aName), EmptyCString(),
    1:                                      getter_AddRefs(mimeInfo));
    1:     if (mimeInfo) {
    1:       // Now we check whether we can really claim to support this type
 3161:       nsHandlerInfoAction action = nsIHandlerInfo::saveToDisk;
    1:       mimeInfo->GetPreferredAction(&action);
    1:       if (action != nsIMIMEInfo::handleInternally) {
    1:         PRBool hasHelper = PR_FALSE;
    1:         mimeInfo->GetHasDefaultHandler(&hasHelper);
    1:         if (!hasHelper) {
 3161:           nsCOMPtr<nsIHandlerApp> helper;
    1:           mimeInfo->GetPreferredApplicationHandler(getter_AddRefs(helper));
    1:           if (!helper) {
    1:             // mime info from the OS may not have a PreferredApplicationHandler
    1:             // so just check for an empty default description
    1:             nsAutoString defaultDescription;
    1:             mimeInfo->GetDefaultDescription(defaultDescription);
    1:             if (defaultDescription.IsEmpty()) {
    1:               // no support; just leave
21159:               return nsnull;
    1:             }
    1:           }
    1:         }
    1:       }
    1: 
    1:       // If we got here, we support this type!  Say so.
21159:       nsCOMPtr<nsIDOMMimeType> helper, entry;
21159:       if (!(helper = new nsHelperMimeType(aName)) ||
21159:           !(entry = new nsMimeType(nsnull, helper)) ||
21159:           !mMimeTypeArray.AppendObject(entry)) {
21159:         *aResult = NS_ERROR_OUT_OF_MEMORY;
21159: 
21159:         return nsnull;
    1:       }
    1: 
21159:       return entry;
    1:     }
    1:   }
    1: 
21159:   return nsnull;
21159: }
21159: 
21159: NS_IMETHODIMP
21159: nsMimeTypeArray::NamedItem(const nsAString& aName, nsIDOMMimeType** aReturn)
21159: {
21159:   nsresult rv;
21159: 
21159:   NS_IF_ADDREF(*aReturn = GetNamedItem(aName, &rv));
21159: 
21159:   return rv;
    1: }
    1: 
    1: void  nsMimeTypeArray::Clear()
    1: {
21288:   mInited = PR_FALSE;
21159:   mMimeTypeArray.Clear();
21159:   mPluginMimeTypeCount = 0;
    1: }
    1: 
    1: nsresult nsMimeTypeArray::Refresh()
    1: {
    1:   Clear();
    1:   return GetMimeTypes();
    1: }
    1: 
    1: nsresult nsMimeTypeArray::GetMimeTypes()
    1: {
21159:   NS_PRECONDITION(!mInited && mPluginMimeTypeCount==0,
    1:                       "already initialized");
    1: 
    1:   nsIDOMPluginArray* pluginArray = nsnull;
    1:   nsresult rv = mNavigator->GetPlugins(&pluginArray);
    1:   if (rv == NS_OK) {
    1:     // count up all possible MimeTypes, and collect them here. Later,
    1:     // we'll remove duplicates.
21288:     PRUint32 pluginMimeTypeCount = 0;
    1:     PRUint32 pluginCount = 0;
    1:     rv = pluginArray->GetLength(&pluginCount);
    1:     if (rv == NS_OK) {
    1:       PRUint32 i;
    1:       for (i = 0; i < pluginCount; i++) {
    1:         nsCOMPtr<nsIDOMPlugin> plugin;
    1:         if (NS_SUCCEEDED(pluginArray->Item(i, getter_AddRefs(plugin))) &&
    1:             plugin) {
    1:           PRUint32 mimeTypeCount = 0;
    1:           if (plugin->GetLength(&mimeTypeCount) == NS_OK)
21288:             pluginMimeTypeCount += mimeTypeCount;
    1:         }
    1:       }
    1:       // now we know how many there are, start gathering them.
21288:       if (!mMimeTypeArray.SetCapacity(pluginMimeTypeCount))
    1:         return NS_ERROR_OUT_OF_MEMORY;
21288: 
21288:       mPluginMimeTypeCount = pluginMimeTypeCount;
21288:       mInited = PR_TRUE;
21288: 
    1:       PRUint32 k;
    1:       for (k = 0; k < pluginCount; k++) {
30053:         nsCOMPtr<nsIDOMPlugin> plugin;
30053:         if (NS_SUCCEEDED(pluginArray->Item(k, getter_AddRefs(plugin))) &&
30053:             plugin) {
    1:           PRUint32 mimeTypeCount = 0;
    1:           if (plugin->GetLength(&mimeTypeCount) == NS_OK) {
21159:             nsCOMPtr<nsIDOMMimeType> item;
21159:             for (PRUint32 j = 0; j < mimeTypeCount; j++) {
21159:               plugin->Item(j, getter_AddRefs(item));
21159:               mMimeTypeArray.AppendObject(item);
21159:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:     NS_RELEASE(pluginArray);
    1:   }
    1:   return rv;
    1: }
    1: 
    1: nsMimeType::nsMimeType(nsIDOMPlugin* aPlugin, nsIDOMMimeType* aMimeType)
    1: {
    1:   mPlugin = aPlugin;
    1:   mMimeType = aMimeType;
    1: }
    1: 
    1: nsMimeType::~nsMimeType()
    1: {
    1: }
    1: 
    1: 
    1: // QueryInterface implementation for nsMimeType
    1: NS_INTERFACE_MAP_BEGIN(nsMimeType)
    1:   NS_INTERFACE_MAP_ENTRY(nsISupports)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMMimeType)
    1:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(MimeType)
    1: NS_INTERFACE_MAP_END
    1: 
    1: 
    1: NS_IMPL_ADDREF(nsMimeType)
    1: NS_IMPL_RELEASE(nsMimeType)
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsMimeType::GetDescription(nsAString& aDescription)
    1: {
    1:   return mMimeType->GetDescription(aDescription);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMimeType::GetEnabledPlugin(nsIDOMPlugin** aEnabledPlugin)
    1: {
    1:   nsAutoString type;
    1:   GetType(type);
    1: 
    1:   PRBool disabled = PR_FALSE;
    1: 
    1:   if (type.Length() == 1 && type.First() == '*') {
    1:     // Check if the default plugin is disabled.
    1:     disabled = nsContentUtils::GetBoolPref("plugin.default_plugin_disabled");
    1:   }
    1: 
    1:   *aEnabledPlugin = disabled ? nsnull : mPlugin;
    1: 
    1:   NS_IF_ADDREF(*aEnabledPlugin);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMimeType::GetSuffixes(nsAString& aSuffixes)
    1: {
    1:   return mMimeType->GetSuffixes(aSuffixes);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMimeType::GetType(nsAString& aType)
    1: {
    1:   return mMimeType->GetType(aType);
    1: }
    1: 
    1: // QueryInterface implementation for nsHelperMimeType
    1: NS_IMPL_ISUPPORTS1(nsHelperMimeType, nsIDOMMimeType)
    1: 
    1: NS_IMETHODIMP
    1: nsHelperMimeType::GetDescription(nsAString& aDescription)
    1: {
    1:   aDescription.Truncate();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHelperMimeType::GetEnabledPlugin(nsIDOMPlugin** aEnabledPlugin)
    1: {
    1:   *aEnabledPlugin = nsnull;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHelperMimeType::GetSuffixes(nsAString& aSuffixes)
    1: {
    1:   aSuffixes.Truncate();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHelperMimeType::GetType(nsAString& aType)
    1: {
    1:   aType = mType;
    1:   return NS_OK;
    1: }
    1: 
