 23248: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
     1:  *
 99778:  * This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "stdlib.h"
     1: #include "plstr.h"
     1: #include "plbase64.h"
     1: 
     1: #include "nsMemory.h"
     1: #include "nsString.h"
     1: #include "nsCOMPtr.h"
     1: #include "nsThreadUtils.h"
     1: #include "nsIInterfaceRequestor.h"
     1: #include "nsIInterfaceRequestorUtils.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsITokenPasswordDialogs.h"
     1: 
     1: #include "nsISecretDecoderRing.h"
     1: #include "nsSDR.h"
     1: #include "nsNSSComponent.h"
     1: #include "nsNSSShutDown.h"
     1: 
     1: #include "pk11func.h"
     1: #include "pk11sdr.h" // For PK11SDR_Encrypt, PK11SDR_Decrypt
     1: 
     1: #include "ssl.h" // For SSL_ClearSessionCache
     1: 
     1: #include "nsNSSCleaner.h"
     1: NSSCleanupAutoPtrClass(PK11SlotInfo, PK11_FreeSlot)
     1: 
     1: // Standard ISupports implementation
     1: // NOTE: Should these be the thread-safe versions?
     1: NS_IMPL_ISUPPORTS2(nsSecretDecoderRing, nsISecretDecoderRing, nsISecretDecoderRingConfig)
     1: 
     1: // nsSecretDecoderRing constructor
     1: nsSecretDecoderRing::nsSecretDecoderRing()
     1: {
     1:   // initialize superclass
     1: }
     1: 
     1: // nsSecretDecoderRing destructor
     1: nsSecretDecoderRing::~nsSecretDecoderRing()
     1: {
     1: }
     1: 
     1: /* [noscript] long encrypt (in buffer data, in long dataLen, out buffer result); */
     1: NS_IMETHODIMP nsSecretDecoderRing::
108991: Encrypt(unsigned char * data, int32_t dataLen, unsigned char * *result, int32_t *_retval)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   nsresult rv = NS_OK;
     1:   PK11SlotInfo *slot = 0;
     1:   PK11SlotInfoCleaner tmpSlotCleaner(slot);
     1:   SECItem keyid;
     1:   SECItem request;
     1:   SECItem reply;
     1:   SECStatus s;
 81303:   nsCOMPtr<nsIInterfaceRequestor> ctx = new PipUIContext();
119832:   if (!ctx) { rv = NS_ERROR_OUT_OF_MEMORY; goto loser; }
     1: 
     1:   slot = PK11_GetInternalKeySlot();
     1:   if (!slot) { rv = NS_ERROR_NOT_AVAILABLE; goto loser; }
     1: 
     1:   /* Make sure token is initialized. */
     1:   rv = setPassword(slot, ctx);
     1:   if (NS_FAILED(rv))
     1:     goto loser;
     1: 
 23248:   /* Force authentication */
 80486:   s = PK11_Authenticate(slot, true, ctx);
     1:   if (s != SECSuccess) { rv = NS_ERROR_FAILURE; goto loser; }
     1: 
     1:   /* Use default key id */
     1:   keyid.data = 0;
     1:   keyid.len = 0;
     1:   request.data = data;
     1:   request.len = dataLen;
     1:   reply.data = 0;
     1:   reply.len = 0;
     1:   s= PK11SDR_Encrypt(&keyid, &request, &reply, ctx);
     1:   if (s != SECSuccess) { rv = NS_ERROR_FAILURE; goto loser; }
     1: 
     1:   *result = reply.data;
     1:   *_retval = reply.len;
     1: 
     1: loser:
     1:   return rv;
     1: }
     1: 
     1: /* [noscript] long decrypt (in buffer data, in long dataLen, out buffer result); */
     1: NS_IMETHODIMP nsSecretDecoderRing::
108991: Decrypt(unsigned char * data, int32_t dataLen, unsigned char * *result, int32_t *_retval)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   nsresult rv = NS_OK;
     1:   PK11SlotInfo *slot = 0;
     1:   PK11SlotInfoCleaner tmpSlotCleaner(slot);
     1:   SECStatus s;
     1:   SECItem request;
     1:   SECItem reply;
 81303:   nsCOMPtr<nsIInterfaceRequestor> ctx = new PipUIContext();
119832:   if (!ctx) { rv = NS_ERROR_OUT_OF_MEMORY; goto loser; }
     1: 
     1:   *result = 0;
     1:   *_retval = 0;
     1: 
     1:   /* Find token with SDR key */
     1:   slot = PK11_GetInternalKeySlot();
     1:   if (!slot) { rv = NS_ERROR_NOT_AVAILABLE; goto loser; }
     1: 
     1:   /* Force authentication */
 80486:   if (PK11_Authenticate(slot, true, ctx) != SECSuccess)
     1:   {
     1:     rv = NS_ERROR_NOT_AVAILABLE;
     1:     goto loser;
     1:   }
     1: 
     1:   request.data = data;
     1:   request.len = dataLen;
     1:   reply.data = 0;
     1:   reply.len = 0;
     1:   s = PK11SDR_Decrypt(&request, &reply, ctx);
     1:   if (s != SECSuccess) { rv = NS_ERROR_FAILURE; goto loser; }
     1: 
     1:   *result = reply.data;
     1:   *_retval = reply.len;
     1: 
     1: loser:
     1:   return rv;
     1: }
     1: 
     1: /* string encryptString (in string text); */
     1: NS_IMETHODIMP nsSecretDecoderRing::
     1: EncryptString(const char *text, char **_retval)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   nsresult rv = NS_OK;
     1:   unsigned char *encrypted = 0;
108991:   int32_t eLen;
     1: 
119832:   if (text == nullptr || _retval == nullptr) {
     1:     rv = NS_ERROR_INVALID_POINTER;
     1:     goto loser;
     1:   }
     1: 
     1:   rv = Encrypt((unsigned char *)text, PL_strlen(text), &encrypted, &eLen);
     1:   if (rv != NS_OK) { goto loser; }
     1: 
     1:   rv = encode(encrypted, eLen, _retval);
     1: 
     1: loser:
 27356:   if (encrypted) PORT_Free(encrypted);
     1: 
     1:   return rv;
     1: }
     1: 
     1: /* string decryptString (in string crypt); */
     1: NS_IMETHODIMP nsSecretDecoderRing::
     1: DecryptString(const char *crypt, char **_retval)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   nsresult rv = NS_OK;
     1:   char *r = 0;
     1:   unsigned char *decoded = 0;
108991:   int32_t decodedLen;
     1:   unsigned char *decrypted = 0;
108991:   int32_t decryptedLen;
     1: 
119832:   if (crypt == nullptr || _retval == nullptr) {
     1:     rv = NS_ERROR_INVALID_POINTER;
     1:     goto loser;
     1:   }
     1: 
     1:   rv = decode(crypt, &decoded, &decodedLen);
     1:   if (rv != NS_OK) goto loser;
     1: 
     1:   rv = Decrypt(decoded, decodedLen, &decrypted, &decryptedLen);
     1:   if (rv != NS_OK) goto loser;
     1: 
     1:   // Convert to NUL-terminated string
     1:   r = (char *)nsMemory::Alloc(decryptedLen+1);
     1:   if (!r) { rv = NS_ERROR_OUT_OF_MEMORY; goto loser; }
     1: 
     1:   memcpy(r, decrypted, decryptedLen);
     1:   r[decryptedLen] = 0;
     1: 
     1:   *_retval = r;
     1:   r = 0;
     1: 
     1: loser:
 27356:   if (decrypted) PORT_Free(decrypted);
 27356:   if (decoded) PR_DELETE(decoded);
     1: 
     1:   return rv;
     1: }
     1: 
     1: /* void changePassword(); */
     1: NS_IMETHODIMP nsSecretDecoderRing::
     1: ChangePassword()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   nsresult rv;
     1:   PK11SlotInfo *slot;
     1: 
     1:   slot = PK11_GetInternalKeySlot();
     1:   if (!slot) return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   /* Convert UTF8 token name to UCS2 */
     1:   NS_ConvertUTF8toUTF16 tokenName(PK11_GetTokenName(slot));
     1: 
     1:   PK11_FreeSlot(slot);
     1: 
     1:   /* Get the set password dialog handler imlementation */
     1:   nsCOMPtr<nsITokenPasswordDialogs> dialogs;
     1: 
     1:   rv = getNSSDialogs(getter_AddRefs(dialogs),
     1:                      NS_GET_IID(nsITokenPasswordDialogs),
     1:                      NS_TOKENPASSWORDSDIALOG_CONTRACTID);
     1:   if (NS_FAILED(rv)) return rv;
     1: 
 81303:   nsCOMPtr<nsIInterfaceRequestor> ctx = new PipUIContext();
 79445:   bool canceled;
     1: 
     1:   {
     1:     nsPSMUITracker tracker;
     1:     if (tracker.isUIForbidden()) {
     1:       rv = NS_ERROR_NOT_AVAILABLE;
     1:     }
     1:     else {
     1:       rv = dialogs->SetPassword(ctx, tokenName.get(), &canceled);
     1:     }
     1:   }
     1: 
     1:   /* canceled is ignored */
     1: 
     1:   return rv;
     1: }
     1: 
     1: static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID);
     1: 
     1: NS_IMETHODIMP nsSecretDecoderRing::
     1: Logout()
     1: {
     1:   nsresult rv;
     1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   {
     1:     nsNSSShutDownPreventionLock locker;
     1:     PK11_LogoutAll();
     1:     SSL_ClearSessionCache();
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP nsSecretDecoderRing::
     1: LogoutAndTeardown()
     1: {
     1:   nsresult rv;
     1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   {
     1:     nsNSSShutDownPreventionLock locker;
     1:     PK11_LogoutAll();
     1:     SSL_ClearSessionCache();
     1:   }
     1: 
 55823:   rv = nssComponent->LogoutAuthenticatedPK11();
 55823: 
 55823:   // After we just logged out, we need to prune dead connections to make
 55823:   // sure that all connections that should be stopped, are stopped. See
 55823:   // bug 517584.
 55823:   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
 55823:   if (os)
106838:     os->NotifyObservers(nullptr, "net:prune-dead-connections", nullptr);
 55823: 
 55823:   return rv;
     1: }
     1: 
     1: /* void setWindow(in nsISupports w); */
     1: NS_IMETHODIMP nsSecretDecoderRing::
     1: SetWindow(nsISupports *w)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: // Support routines
     1: 
     1: nsresult nsSecretDecoderRing::
108991: encode(const unsigned char *data, int32_t dataLen, char **_retval)
     1: {
     1:   nsresult rv = NS_OK;
     1: 
119832:   char *result = PL_Base64Encode((const char *)data, dataLen, NULL);
 27356:   if (!result) { rv = NS_ERROR_OUT_OF_MEMORY; goto loser; }
 27356: 
 27356:   *_retval = NS_strdup(result);
 27356:   PR_DELETE(result);
     1:   if (!*_retval) { rv = NS_ERROR_OUT_OF_MEMORY; goto loser; }
     1: 
     1: loser:
     1:   return rv;
     1: }
     1: 
     1: nsresult nsSecretDecoderRing::
108991: decode(const char *data, unsigned char **result, int32_t * _retval)
     1: {
     1:   nsresult rv = NS_OK;
108991:   uint32_t len = PL_strlen(data);
     1:   int adjust = 0;
     1: 
     1:   /* Compute length adjustment */
     1:   if (data[len-1] == '=') {
     1:     adjust++;
     1:     if (data[len-2] == '=') adjust++;
     1:   }
     1: 
119832:   *result = (unsigned char *)PL_Base64Decode(data, len, NULL);
     1:   if (!*result) { rv = NS_ERROR_ILLEGAL_VALUE; goto loser; }
     1: 
     1:   *_retval = (len*3)/4 - adjust;
     1: 
     1: loser:
     1:   return rv;
     1: }
