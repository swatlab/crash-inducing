54863: // -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
54863: // Any copyright is dedicated to the Public Domain.
54863: // http://creativecommons.org/licenses/publicdomain/
54863: 
54863: // Assert that cloning b does the right thing as far as we can tell.
54863: // Caveat: getters in b must produce the same value each time they're
54863: // called. We may call them several times.
54863: //
54863: // If desc is provided, then the very first thing we do to b is clone it.
54863: // (The self-modifying object test counts on this.)
54863: //
54863: function check(b, desc) {
54863:     function classOf(obj) {
54863:         return Object.prototype.toString.call(obj);
54863:     }
54863: 
54863:     function ownProperties(obj) {
54863:         return Object.getOwnPropertyNames(obj).
54863:             map(function (p) { return [p, Object.getOwnPropertyDescriptor(obj, p)]; });
54863:     }
54863: 
54863:     function isCloneable(pair) {
54863:         return typeof pair[0] === 'string' && pair[1].enumerable;
54863:     }
54863: 
54863:     function notIndex(p) {
54863:         var u = p >>> 0;
54863:         return !("" + u == p && u != 0xffffffff);
54863:     }
54863: 
54863:     function assertIsCloneOf(a, b, path) {
54863:         assertEq(a === b, false);
54863: 
54863:         var ca = classOf(a);
54863:         assertEq(ca, classOf(b), path);
54863: 
54863:         assertEq(Object.getPrototypeOf(a),
54863:                  ca == "[object Object]" ? Object.prototype : Array.prototype,
54863:                  path);
54863: 
54863:         // 'b', the original object, may have non-enumerable or XMLName
54863:         // properties; ignore them.  'a', the clone, should not have any
54863:         // non-enumerable properties (except .length, if it's an Array) or
54863:         // XMLName properties.
54863:         var pb = ownProperties(b).filter(isCloneable);
54863:         var pa = ownProperties(a);
54863:         for (var i = 0; i < pa.length; i++) {
54863:             assertEq(typeof pa[i][0], "string", "clone should not have E4X properties " + path);
54863:             if (!pa[i][1].enumerable) {
54863:                 if (Array.isArray(a) && pa[i][0] == "length") {
54863:                     // remove it so that the comparisons below will work
54863:                     pa.splice(i, 1);
54863:                     i--;
54863:                 } else {
54863:                     throw new Error("non-enumerable clone property " + uneval(pa[i][0]) + " " + path);
54863:                 }
54863:             }
54863:         }
54863: 
54863:         // Check that, apart from properties whose names are array indexes, 
54863:         // the enumerable properties appear in the same order.
54863:         var aNames = pa.map(function (pair) { return pair[1]; }).filter(notIndex);
54863:         var bNames = pa.map(function (pair) { return pair[1]; }).filter(notIndex);
54863:         assertEq(aNames.join(","), bNames.join(","), path);
54863: 
54863:         // Check that the lists are the same when including array indexes.
54863:         function byName(a, b) { a = a[0]; b = b[0]; return a < b ? -1 : a === b ? 0 : 1; }
54863:         pa.sort(byName);
54863:         pb.sort(byName);
54863:         assertEq(pa.length, pb.length, "should see the same number of properties " + path);
54863:         for (var i = 0; i < pa.length; i++) {
54863:             var aName = pa[i][0];
54863:             var bName = pb[i][0];
54863:             assertEq(aName, bName, path);
54863: 
54863:             var path2 = path + "." + aName;
54863:             var da = pa[i][1];
54863:             var db = pb[i][1];
54863:             assertEq(da.configurable, true, path2);
54863:             assertEq(da.writable, true, path2);
54863:             assertEq("value" in da, true, path2);
54863:             var va = da.value;
54863:             var vb = b[pb[i][0]];
54863:             if (typeof va === "object" && va !== null)
54863:                 queue.push([va, vb, path2]);
54863:             else
54863:                 assertEq(va, vb, path2);
54863:         }
54863:     }
54863: 
54863:     var banner = "while testing clone of " + (desc || uneval(b));
54863:     var a = deserialize(serialize(b));
54863:     var queue = [[a, b, banner]];
54863:     while (queue.length) {
54863:         var triple = queue.shift();
54863:         assertIsCloneOf(triple[0], triple[1], triple[2]);
54863:     }
54863: 
54863:     return a; // for further testing
54863: }
54863: 
54863: function test() {
54863:     check({});
54863:     check([]);
54863:     check({x: 0});
54863:     check({x: 0.7, p: "forty-two", y: null, z: undefined});
54863:     check(Array.prototype);
54863:     check(Object.prototype);
54863: 
54863:     // before and after
54863:     var b, a;
54863: 
54863:     // Slow array.
54863:     b = [, 1, 2, 3];
54863:     b.expando = true;
54863:     b[5] = 5;
54863:     b[0] = 0;
54863:     b[4] = 4;
54863:     delete b[2];
54863:     check(b);
54863: 
54863:     // Check cloning properties other than basic data properties. (check()
54863:     // asserts that the properties of the clone are configurable, writable,
54863:     // enumerable data properties.)
54863:     b = {};
54863:     Object.defineProperties(b, {
54863:         x: {enumerable: true, get: function () { return 12479; }},
54863:         y: {enumerable: true, configurable: true, writable: false, value: 0},
54863:         z: {enumerable: true, configurable: false, writable: true, value: 0},
54863:         hidden: {enumerable:false, value: 1334}});
54863:     check(b);
54863: 
54863:     // Check corner cases involving property names.
54863:     b = {"-1": -1,
54863:          0xffffffff: null,
54863:          0x100000000: null,
54863:          "": 0,
54863:          "\xff\x7f\u7fff\uffff\ufeff\ufffe": 1, // random unicode id
54863:          "\ud800 \udbff \udc00 \udfff": 2}; // busted surrogate pairs
54863:     check(b);
54863: 
54863:     b = [];
54863:     b[-1] = -1;
54863:     b[0xffffffff] = null;
54863:     b[0x100000000] = null;
54863:     b[""] = 0;
54863:     b["\xff\x7f\u7fff\uffff\ufeff\ufffe"] = 1;
54863:     b["\ud800 \udbff \udc00 \udfff"] = 2;
54863:     check(b);
54863: 
54863:     // An array's .length property is not enumerable, so it is not cloned.
54863:     b = Array(5);
54863:     assertEq(b.length, 5);
54863:     a = check(b);
54863:     assertEq(a.length, 0);
54863: 
54863:     b[1] = "ok";
54863:     a = check(b);
54863:     assertEq(a.length, 2);
54863: 
54863:     // Check that prototypes are not cloned, per spec.
54863:     b = Object.create({x:1});
54863:     b.y = 2;
54863:     b.z = 3;
54863:     check(b);
54863: 
54863:     // Check that cloning separates merge points in the tree, per spec.
54863:     var same = {};
54863:     b = {one: same, two: same};
54863:     a = check(b);
54863:     assertEq(a.one === a.two, false);
54863: 
54863:     b = [same, same];
54863:     a = check(b);
54863:     assertEq(a[0] === a[1], false);
54863: 
54863:     // Try cloning a deep object. Don't fail with "too much recursion".
54863:     b = {};
54863:     var current = b;
54863:     for (var i = 0; i < 10000; i++) {
54863:         var next = {};
54863:         current['x' + i] = next;
54863:         current = next;
54863:     }
54863:     check(b, "deepObject");  // takes 2 seconds :-\
54863: 
54863:     /*
54863:       XXX TODO spin this out into its own test
54863:     // This fails quickly with an OOM error. An exception would be nicer.
54863:     function Infinitree() {
54863:         return { get left() { return new Infinitree; },
54863:                  get right() { return new Infinitree; }};
54863:     }
54863:     var threw = false;
54863:     try {
54863:         serialize(new Infinitree);
54863:     } catch (exc) {
54863:         threw = true;
54863:     }
54863:     assertEq(threw, true);
54863:     */
54863: 
54863:     // Clone an array with holes.
54863:     check([0, 1, 2, , 4, 5, 6]);
54863: 
54863:     // Array holes should not take up space.
54863:     b = [];
54863:     b[255] = 1;
54863:     check(b);
54863:     assertEq(serialize(b).length < 255, true);
54863: 
54863:     // Self-modifying object.
54863:     // This should never read through to b's prototype.
54863:     b = Object.create({y: 2}, 
54863:                       {x: {enumerable: true,
54863:                            configurable: true,
54863:                            get: function() { if (this.hasOwnProperty("y")) delete this.y; return 1; }},
54863:                        y: {enumerable: true,
54863:                            configurable: true,
54863:                            writable: true,
54863:                            value: 3}});
54863:     check(b, "selfModifyingObject");
54863: 
54863:     // Ignore properties with object-ids.
54863:     var uri = "http://example.net";
54863:     b = {x: 1, y: 2};
60566:     Object.defineProperty(b, QName(uri, "x"), {enumerable: true, value: 3});
54863:     Object.defineProperty(b, QName(uri, "y"), {enumerable: true, value: 5});
54863:     check(b);
54863: }
54863: 
54863: test();
54863: reportCompare(0, 0, 'ok');
