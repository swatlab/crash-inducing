24823: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
24823: /* ***** BEGIN LICENSE BLOCK *****
24823:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
24823:  *
24823:  * The contents of this file are subject to the Mozilla Public License Version
24823:  * 1.1 (the "License"); you may not use this file except in compliance with
24823:  * the License. You may obtain a copy of the License at
24823:  * http://www.mozilla.org/MPL/
24823:  *
24823:  * Software distributed under the License is distributed on an "AS IS" basis,
24823:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
24823:  * for the specific language governing rights and limitations under the
24823:  * License.
24823:  *
24823:  * The Original Code is mozilla.org code.
24823:  *
24823:  * The Initial Developer of the Original Code is
24823:  * Netscape Communications Corporation.
24823:  * Portions created by the Initial Developer are Copyright (C) 1998
24823:  * the Initial Developer. All Rights Reserved.
24823:  *
24823:  * Contributor(s):
24823:  *   Ningjie Chen <chenn@email.uc.edu>
24823:  *
24823:  * Alternatively, the contents of this file may be used under the terms of
24823:  * either the GNU General Public License Version 2 or later (the "GPL"), or
24823:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
24823:  * in which case the provisions of the GPL or the LGPL are applicable instead
24823:  * of those above. If you wish to allow use of your version of this file only
24823:  * under the terms of either the GPL or the LGPL, and not to allow others to
24823:  * use your version of this file under the terms of the MPL, indicate your
24823:  * decision by deleting the provisions above and replace them with the notice
24823:  * and other provisions required by the GPL or the LGPL. If you do not delete
24823:  * the provisions above, a recipient may use your version of this file under
24823:  * the terms of any one of the MPL, the GPL or the LGPL.
24823:  *
24823:  * ***** END LICENSE BLOCK ***** */
24823: 
24823: 
24823: /* This tests Mozilla's Text Services Framework implementation (bug #88831)
24823:  *
24823:  * The Mozilla implementation interacts with the TSF system through a
24823:  * system-provided COM interface, ITfThreadMgr. This tests works by swapping
24823:  * the system version of the interface with a custom version implemented in
24823:  * here. This way the Mozilla implementation thinks it's interacting with the
24823:  * system but in fact is interacting with this test program. This allows the
24823:  * test program to access and test every aspect of the Mozilla implementation.
24823:  */
24823: 
35038: #include <ole2.h>
24823: #include <msctf.h>
24823: #include <textstor.h>
31281: #include <richedit.h>
24823: 
24823: #include "TestHarness.h"
24823: 
24823: #define WM_USER_TSF_TEXTCHANGE  (WM_USER + 0x100)
24823: 
24823: #ifndef MOZILLA_INTERNAL_API
24823: // some of the includes make use of internal string types
24823: #define nsAString_h___
24823: #define nsString_h___
31749: #define nsStringFwd_h___
29087: #define nsReadableUtils_h___
31749: class nsACString;
31749: class nsAString;
24823: class nsAFlatString;
24823: class nsAFlatCString;
29087: class nsAdoptingString;
29087: class nsAdoptingCString;
29087: class nsXPIDLString;
29087: template<class T> class nsReadingIterator;
24823: #endif
24823: 
29084: #include "nscore.h"
24823: #include "nsWeakReference.h"
24823: #include "nsIAppShell.h"
24823: #include "nsWidgetsCID.h"
24823: #include "nsIAppShellService.h"
24823: #include "nsAppShellCID.h"
24823: #include "nsNetUtil.h"
24823: #include "nsIWebBrowserChrome.h"
24823: #include "nsIXULWindow.h"
24823: #include "nsIBaseWindow.h"
73870: #include "nsIDOMWindow.h"
24823: #include "nsIDocShell.h"
24823: #include "nsIWidget.h"
24823: #include "nsIPresShell.h"
24823: #include "nsPresContext.h"
24823: #include "nsIFrame.h"
24823: #include "nsIWebProgress.h"
24823: #include "nsIWebProgressListener.h"
24823: #include "nsIInterfaceRequestorUtils.h"
24823: #include "nsIDOMHTMLDocument.h"
24823: #include "nsIDOMHTMLBodyElement.h"
24823: #include "nsIDOMHTMLElement.h"
24823: #include "nsIDOMHTMLInputElement.h"
24823: #include "nsIDOMHTMLTextAreaElement.h"
89079: #include "nsIDOMElement.h"
24823: #include "nsISelectionController.h"
24823: #include "nsIViewManager.h"
25395: #include "nsTArray.h"
28352: #include "nsGUIEvent.h"
24823: 
24823: #ifndef MOZILLA_INTERNAL_API
24823: #undef nsString_h___
24823: #undef nsAString_h___
29087: #undef nsReadableUtils_h___
24823: #endif
24823: 
24823: static NS_DEFINE_CID(kAppShellCID, NS_APPSHELL_CID);
24823: 
25857: class TSFMgrImpl;
25857: class TSFDocumentMgrImpl;
25857: class TSFContextImpl;
25395: class TSFRangeImpl;
25395: class TSFEnumRangeImpl;
25395: class TSFAttrPropImpl;
24823: 
24823: class TestApp : public nsIWebProgressListener, public nsSupportsWeakReference
24823: {
24823: public:
24823:   NS_DECL_ISUPPORTS
24823:   NS_DECL_NSIWEBPROGRESSLISTENER
24823: 
80486:   TestApp() : mFailed(false) {}
24823:   ~TestApp() {}
24823: 
24823:   nsresult Run(void);
79445:   bool CheckFailed(void);
79445: 
79445:   typedef bool (TestApp::*test_type)(void);
24823: 
24823: protected:
24823:   nsresult Init(void);
24823:   nsresult Term(void);
79445:   bool RunTest(test_type aTest, bool aLock = true);
79445: 
79445:   bool TestFocus(void);
79445:   bool TestClustering(void);
79445:   bool TestSelection(void);
79445:   bool TestText(void);
79445:   bool TestExtents(void);
79445:   bool TestComposition(void);
79445:   bool TestNotification(void);
79445:   bool TestEditMessages(void);
79445:   bool TestScrollMessages(void);
79445: 
79445:   bool TestSelectionInternal(char* aTestName,
24823:                                         LONG aStart,
24823:                                         LONG aEnd,
24823:                                         TsActiveSelEnd aSelEnd);
79445:   bool TestCompositionSelectionAndText(char* aTestName,
24823:                                          LONG aExpectedSelStart,
24823:                                          LONG aExpectedSelEnd,
24823:                                          nsString& aReferenceString);
79445:   bool TestNotificationTextChange(nsIWidget* aWidget,
24823:                                     PRUint32 aCode,
24823:                                     const nsAString& aCharacter,
24823:                                     LONG aStart,
24823:                                     LONG aOldEnd,
24823:                                     LONG aNewEnd);
24823:   nsresult GetSelCon(nsISelectionController** aSelCon);
24823: 
79445:   bool GetWidget(nsIWidget** aWidget);
79445: 
79445:   bool mFailed;
24823:   nsString mTestString;
25857:   nsRefPtr<TSFMgrImpl> mMgr;
24823:   nsCOMPtr<nsIAppShell> mAppShell;
24823:   nsCOMPtr<nsIXULWindow> mWindow;
24823:   nsCOMPtr<nsIDOMNode> mCurrentNode;
24823:   nsCOMPtr<nsIDOMHTMLInputElement> mInput;
24823:   nsCOMPtr<nsIDOMHTMLTextAreaElement> mTextArea;
24823:   nsCOMPtr<nsIDOMHTMLInputElement> mButton;
24823: };
24823: 
24823: NS_IMETHODIMP
24823: TestApp::OnProgressChange(nsIWebProgress *aWebProgress,
24823:                            nsIRequest *aRequest,
24823:                            PRInt32 aCurSelfProgress,
24823:                            PRInt32 aMaxSelfProgress,
24823:                            PRInt32 aCurTotalProgress,
24823:                            PRInt32 aMaxTotalProgress)
24823: {
24823:   return NS_OK;
24823: }
24823: 
24823: NS_IMETHODIMP
24823: TestApp::OnLocationChange(nsIWebProgress *aWebProgress,
24823:                            nsIRequest *aRequest,
82127:                            nsIURI *aLocation,
82127:                            PRUint32 aFlags)
24823: {
24823:   return NS_OK;
24823: }
24823: 
24823: NS_IMETHODIMP
24823: TestApp::OnStatusChange(nsIWebProgress *aWebProgress,
24823:                          nsIRequest *aRequest,
24823:                          nsresult aStatus,
24823:                          const PRUnichar *aMessage)
24823: {
24823:   return NS_OK;
24823: }
24823: 
24823: NS_IMETHODIMP
24823: TestApp::OnSecurityChange(nsIWebProgress *aWebProgress,
24823:                            nsIRequest *aRequest,
24823:                            PRUint32 aState)
24823: {
24823:   return NS_OK;
24823: }
24823: 
25395: static HRESULT
25395: GetRegularExtent(ITfRange *aRange, LONG &aStart, LONG &aEnd)
25395: {
25395:   NS_ENSURE_TRUE(aRange, E_INVALIDARG);
25395:   nsRefPtr<ITfRangeACP> rangeACP;
25395:   HRESULT hr = aRange->QueryInterface(IID_ITfRangeACP,
25395:                                       getter_AddRefs(rangeACP));
25395:   NS_ENSURE_TRUE(SUCCEEDED(hr) && rangeACP, E_FAIL);
25395: 
25395:   LONG start, length;
25395:   hr = rangeACP->GetExtent(&start, &length);
25395:   NS_ENSURE_TRUE(SUCCEEDED(hr), hr);
25395:   if (length >= 0) {
25395:     aStart = start;
25395:     aEnd = start + length;
25395:   } else {
25395:     aEnd = start;
25395:     aStart = start + length;
25395:   }
25395:   return S_OK;
25395: }
25395: 
25395: // {3B2DFDF5-2485-4858-8185-5C6B4EFD38F5}
25395: static const GUID GUID_COMPOSING_SELECTION_ATTR = 
25395:   { 0x3b2dfdf5, 0x2485, 0x4858,
25395:     { 0x81, 0x85, 0x5c, 0x6b, 0x4e, 0xfd, 0x38, 0xf5 } };
25395: #define GUID_ATOM_COMPOSING_SELECTION_ATTR \
25395:   (static_cast<TfGuidAtom>(0x3b2dfdf5))
25395: 
25395: /******************************************************************************
25395:  * TSFRangeImpl
25395:  ******************************************************************************/
25395: 
25395: class TSFRangeImpl : public ITfRangeACP
25395: {
25395: private:
25395:   ULONG mRefCnt;
25395: 
25395: public:
25395:   LONG mStart;
25395:   LONG mLength;
25395: 
25395:   TSFRangeImpl(LONG aStart = 0, LONG aLength = 0) :
25395:       mRefCnt(0), mStart(aStart), mLength(aLength)
25395:   {
25395:   }
25395: 
25395:   ~TSFRangeImpl()
25395:   {
25395:   }
25395: 
25395: public: // IUnknown
25395: 
25395:   STDMETHODIMP QueryInterface(REFIID riid, void** ppUnk)
25395:   {
25395:     *ppUnk = NULL;
25395:     if (IID_IUnknown == riid || IID_ITfRange == riid || IID_ITfRangeACP == riid)
25395:       *ppUnk = static_cast<ITfRangeACP*>(this);
25395:     if (*ppUnk)
25395:       AddRef();
25395:     return *ppUnk ? S_OK : E_NOINTERFACE;
25395:   }
25395: 
25395:   STDMETHODIMP_(ULONG) AddRef(void)
25395:   {
25395:     return ++mRefCnt;
25395:   }
25395: 
25395:   STDMETHODIMP_(ULONG) Release(void)
25395:   {
25395:     if (--mRefCnt) return mRefCnt;
25395:     delete this;
25395:     return 0;
25395:   }
25395: 
25395: public: // ITfRange
25395: 
25395:   STDMETHODIMP GetText(TfEditCookie ec, DWORD dwFlags, WCHAR *pchText,
25395:                        ULONG cchMax, ULONG *pcch)
25395:   {
25395:     NS_NOTREACHED("ITfRange::GetText");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP SetText(TfEditCookie ec, DWORD dwFlags, const WCHAR *pchText,
25395:                        LONG cch)
25395:   {
25395:     NS_NOTREACHED("ITfRange::SetText");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP GetFormattedText(TfEditCookie ec, IDataObject **ppDataObject)
25395:   {
25395:     NS_NOTREACHED("ITfRange::GetFormattedText");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP GetEmbedded(TfEditCookie ec, REFGUID rguidService, REFIID riid,
25395:                            IUnknown **ppunk)
25395:   {
25395:     NS_NOTREACHED("ITfRange::GetEmbedded");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP InsertEmbedded(TfEditCookie ec, DWORD dwFlags,
25395:                               IDataObject *pDataObject)
25395:   {
25395:     NS_NOTREACHED("ITfRange::InsertEmbedded");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP ShiftStart(TfEditCookie ec, LONG cchReq, LONG *pcch,
25395:                           const TF_HALTCOND *pHalt)
25395:   {
25395:     NS_NOTREACHED("ITfRange::ShiftStart");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP ShiftEnd(TfEditCookie ec, LONG cchReq, LONG *pcch,
25395:                         const TF_HALTCOND *pHalt)
25395:   {
25395:     NS_NOTREACHED("ITfRange::ShiftEnd");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP ShiftStartToRange(TfEditCookie ec, ITfRange *pRange,
25395:                                  TfAnchor aPos)
25395:   {
25395:     NS_NOTREACHED("ITfRange::ShiftStartToRange");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP ShiftEndToRange(TfEditCookie ec, ITfRange *pRange, TfAnchor aPos)
25395:   {
25395:     NS_NOTREACHED("ITfRange::ShiftEndToRange");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP ShiftStartRegion(TfEditCookie ec, TfShiftDir dir,
25395:                                 BOOL *pfNoRegion)
25395:   {
25395:     NS_NOTREACHED("ITfRange::ShiftStartRegion");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP ShiftEndRegion(TfEditCookie ec, TfShiftDir dir, BOOL *pfNoRegion)
25395:   {
25395:     NS_NOTREACHED("ITfRange::ShiftEndRegion");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP IsEmpty(TfEditCookie ec, BOOL *pfEmpty)
25395:   {
25395:     NS_NOTREACHED("ITfRange::IsEmpty");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP Collapse(TfEditCookie ec, TfAnchor aPos)
25395:   {
25395:     NS_NOTREACHED("ITfRange::Collapse");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP IsEqualStart(TfEditCookie ec, ITfRange *pWith, TfAnchor aPos,
25395:                             BOOL *pfEqual)
25395:   {
25395:     NS_NOTREACHED("ITfRange::IsEqualStart");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP IsEqualEnd(TfEditCookie ec, ITfRange *pWith, TfAnchor aPos,
25395:                           BOOL *pfEqual)
25395:   {
25395:     NS_NOTREACHED("ITfRange::IsEqualEnd");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP CompareStart(TfEditCookie ec, ITfRange *pWith, TfAnchor aPos,
25395:                             LONG *plResult)
25395:   {
25395:     NS_NOTREACHED("ITfRange::CompareStart");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP CompareEnd(TfEditCookie ec, ITfRange *pWith, TfAnchor aPos,
25395:                           LONG *plResult)
25395:   {
25395:     NS_NOTREACHED("ITfRange::CompareEnd");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP AdjustForInsert(TfEditCookie ec, ULONG cchInsert,
25395:                                BOOL *pfInsertOk)
25395:   {
25395:     NS_NOTREACHED("ITfRange::AdjustForInsert");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP GetGravity(TfGravity *pgStart, TfGravity *pgEnd)
25395:   {
25395:     NS_NOTREACHED("ITfRange::GetGravity");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP SetGravity(TfEditCookie ec, TfGravity gStart, TfGravity gEnd)
25395:   {
25395:     NS_NOTREACHED("ITfRange::SetGravity");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP Clone(ITfRange **ppClone)
25395:   {
25395:     NS_NOTREACHED("ITfRange::Clone");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP GetContext(ITfContext **ppContext)
25395:   {
25395:     NS_NOTREACHED("ITfRange::GetContext");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395: public: // ITfRangeACP
25395: 
25395:   STDMETHODIMP GetExtent(LONG *pacpAnchor, LONG *pcch)
25395:   {
25395:     NS_ENSURE_TRUE(pacpAnchor, E_FAIL);
25395:     NS_ENSURE_TRUE(pcch, E_FAIL);
25395:     *pacpAnchor = mStart;
25395:     *pcch = mLength;
25395:     return S_OK;
25395:   }
25395: 
25395:   STDMETHODIMP SetExtent(LONG acpAnchor, LONG cch)
25395:   {
25395:     mStart = acpAnchor;
25395:     mLength = cch;
25395:     return S_OK;
25395:   }
25395: };
25395: 
25395: /******************************************************************************
25395:  * TSFEnumRangeImpl
25395:  ******************************************************************************/
25395: 
25395: class TSFEnumRangeImpl : public IEnumTfRanges
25395: {
25395: private:
25395:   ULONG mRefCnt;
25395:   PRUint32 mCurrentIndex;
25395: 
25395: public:
25395:   nsTArray<nsRefPtr<TSFRangeImpl> > mRanges;
25395: 
25395:   TSFEnumRangeImpl() :
25395:       mRefCnt(0), mCurrentIndex(0)
25395:   {
25395:   }
25395: 
25395:   ~TSFEnumRangeImpl()
25395:   {
25395:   }
25395: 
25395: public: // IUnknown
25395: 
25395:   STDMETHODIMP QueryInterface(REFIID riid, void** ppUnk)
25395:   {
25395:     *ppUnk = NULL;
25395:     if (IID_IUnknown == riid || IID_IEnumTfRanges == riid)
25395:       *ppUnk = static_cast<IEnumTfRanges*>(this);
25395:     if (*ppUnk)
25395:       AddRef();
25395:     return *ppUnk ? S_OK : E_NOINTERFACE;
25395:   }
25395: 
25395:   STDMETHODIMP_(ULONG) AddRef(void)
25395:   {
25395:     return ++mRefCnt;
25395:   }
25395: 
25395:   STDMETHODIMP_(ULONG) Release(void)
25395:   {
25395:     if (--mRefCnt) return mRefCnt;
25395:     delete this;
25395:     return 0;
25395:   }
25395: 
25395: public: // IEnumTfRanges
25395: 
25395:   STDMETHODIMP Clone(IEnumTfRanges **ppEnum)
25395:   {
25395:     NS_NOTREACHED("IEnumTfRanges::Clone");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP Next(ULONG ulCount, ITfRange **ppRange, ULONG *pcFetched)
25395:   {
25395:     NS_ENSURE_TRUE(ppRange, E_FAIL);
25395:     if (pcFetched)
25395:       *pcFetched = 0;
25395:     if (mCurrentIndex + ulCount - 1 >= mRanges.Length())
25395:       return E_FAIL;
25395:     for (PRUint32 i = 0; i < ulCount; i++) {
25395:       ppRange[i] = mRanges[mCurrentIndex++];
25395:       ppRange[i]->AddRef();
25395:       if (pcFetched)
25395:         (*pcFetched)++;
25395:     }
25395:     return S_OK;
25395:   }
25395: 
25395:   STDMETHODIMP Reset()
25395:   {
25395:     mCurrentIndex = 0;
25395:     return S_OK;
25395:   }
25395: 
25395:   STDMETHODIMP Skip(ULONG ulCount)
25395:   {
25395:     mCurrentIndex += ulCount;
25395:     return S_OK;
25395:   }
25395: };
25395: 
25395: /******************************************************************************
25395:  * TSFDispAttrInfoImpl
25395:  ******************************************************************************/
25395: 
25395: class TSFDispAttrInfoImpl : public ITfDisplayAttributeInfo
25395: {
25395: private:
25395:   ULONG mRefCnt;
25395:   TF_DISPLAYATTRIBUTE mAttr;
25395: 
25395: public:
25395: 
25395:   TSFDispAttrInfoImpl(REFGUID aGUID) :
25395:       mRefCnt(0)
25395:   {
25395:     if (aGUID == GUID_COMPOSING_SELECTION_ATTR) {
25395:       mAttr.crText.type = TF_CT_NONE;
25395:       mAttr.crBk.type = TF_CT_NONE;
25395:       mAttr.lsStyle = TF_LS_SQUIGGLE;
25395:       mAttr.fBoldLine = FALSE;
25395:       mAttr.crLine.type = TF_CT_NONE;
25395:       mAttr.bAttr = TF_ATTR_INPUT;
25395:     } else {
25395:       NS_NOTREACHED("TSFDispAttrInfoImpl::TSFDispAttrInfoImpl");
25395:     }
25395:   }
25395: 
25395:   ~TSFDispAttrInfoImpl()
25395:   {
25395:   }
25395: 
25395: public: // IUnknown
25395: 
25395:   STDMETHODIMP QueryInterface(REFIID riid, void** ppUnk)
25395:   {
25395:     *ppUnk = NULL;
25395:     if (IID_IUnknown == riid || IID_ITfDisplayAttributeInfo == riid)
25395:       *ppUnk = static_cast<ITfDisplayAttributeInfo*>(this);
25395:     if (*ppUnk)
25395:       AddRef();
25395:     return *ppUnk ? S_OK : E_NOINTERFACE;
25395:   }
25395: 
25395:   STDMETHODIMP_(ULONG) AddRef(void)
25395:   {
25395:     return ++mRefCnt;
25395:   }
25395: 
25395:   STDMETHODIMP_(ULONG) Release(void)
25395:   {
25395:     if (--mRefCnt) return mRefCnt;
25395:     delete this;
25395:     return 0;
25395:   }
25395: 
25395: public: // ITfDisplayAttributeInfo
25395: 
25395:   STDMETHODIMP GetGUID(GUID *pguid)
25395:   {
25395:     NS_NOTREACHED("ITfDisplayAttributeInfo::GetGUID");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP GetDescription(BSTR *pbstrDesc)
25395:   {
25395:     NS_NOTREACHED("ITfDisplayAttributeInfo::GetDescription");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP GetAttributeInfo(TF_DISPLAYATTRIBUTE *pda)
25395:   {
25395:     NS_ENSURE_TRUE(pda, E_INVALIDARG);
25395:     *pda = mAttr;
25395:     return S_OK;
25395:   }
25395: 
25395:   STDMETHODIMP SetAttributeInfo(const TF_DISPLAYATTRIBUTE *pda)
25395:   {
25395:     NS_NOTREACHED("ITfDisplayAttributeInfo::SetAttributeInfo");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP Reset()
25395:   {
25395:     NS_NOTREACHED("ITfDisplayAttributeInfo::Reset");
25395:     return E_NOTIMPL;
25395:   }
25395: };
25395: 
25395: /******************************************************************************
25395:  * TSFAttrPropImpl
25395:  ******************************************************************************/
25395: 
25395: class TSFAttrPropImpl : public ITfProperty
25395: {
25395: private:
25395:   ULONG mRefCnt;
25395: 
25395: public:
25395:   nsTArray<nsRefPtr<TSFRangeImpl> > mRanges;
25395: 
25395:   TSFAttrPropImpl() :
25395:       mRefCnt(0)
25395:   {
25395:   }
25395: 
25395:   ~TSFAttrPropImpl()
25395:   {
25395:   }
25395: 
25395: public: // IUnknown
25395: 
25395:   STDMETHODIMP QueryInterface(REFIID riid, void** ppUnk)
25395:   {
25395:     *ppUnk = NULL;
25395:     if (IID_IUnknown == riid || IID_ITfProperty == riid ||
25395:         IID_ITfReadOnlyProperty == riid)
25395:       *ppUnk = static_cast<ITfProperty*>(this);
25395:     if (*ppUnk)
25395:       AddRef();
25395:     return *ppUnk ? S_OK : E_NOINTERFACE;
25395:   }
25395: 
25395:   STDMETHODIMP_(ULONG) AddRef(void)
25395:   {
25395:     return ++mRefCnt;
25395:   }
25395: 
25395:   STDMETHODIMP_(ULONG) Release(void)
25395:   {
25395:     if (--mRefCnt) return mRefCnt;
25395:     delete this;
25395:     return 0;
25395:   }
25395: 
25395: public: // ITfProperty
25395: 
25395:   STDMETHODIMP FindRange(TfEditCookie ec, ITfRange *pRange, ITfRange **ppRange,
25395:                          TfAnchor aPos)
25395:   {
25395:     NS_NOTREACHED("ITfProperty::FindRange");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP SetValueStore(TfEditCookie ec, ITfRange *pRange,
25395:                              ITfPropertyStore *pPropStore)
25395:   {
25395:     NS_NOTREACHED("ITfProperty::SetValueStore");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP SetValue(TfEditCookie ec, ITfRange *pRange,
25395:                         const VARIANT *pvarValue)
25395:   {
25395:     NS_NOTREACHED("ITfProperty::SetValue");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP Clear(TfEditCookie ec, ITfRange *pRange)
25395:   {
25395:     NS_NOTREACHED("ITfProperty::Clear");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395: public: // ITfReadOnlyProperty
25395: 
25395:   STDMETHODIMP GetType(GUID *pguid)
25395:   {
25395:     NS_NOTREACHED("ITfReadOnlyProperty::GetType");
25395:     return E_NOTIMPL;
25395:   }
25395: 
25395:   STDMETHODIMP EnumRanges(TfEditCookie ec, IEnumTfRanges **ppEnum,
25395:                           ITfRange *pTargetRange)
25395:   {
25395:     NS_ENSURE_TRUE(ppEnum, E_INVALIDARG);
25395:     NS_ENSURE_TRUE(pTargetRange, E_INVALIDARG);
25395: 
25395:     // XXX ec checking is not implemented yet.
25395: 
25395:     LONG targetStart = 0, targetEnd = 0;
25395:     if (pTargetRange) {
25395:       HRESULT hr = GetRegularExtent(pTargetRange, targetStart, targetEnd);
25395:       NS_ENSURE_TRUE(SUCCEEDED(hr), hr);
25395:     }
25395:     nsRefPtr<TSFEnumRangeImpl> er = new TSFEnumRangeImpl();
25395:     NS_ENSURE_TRUE(er, E_OUTOFMEMORY);
25395:     for (PRUint32 i = 0; i < mRanges.Length(); i++) {
25395:       LONG start, end;
25395:       HRESULT hr = GetRegularExtent(mRanges[i], start, end);
25395:       NS_ENSURE_TRUE(SUCCEEDED(hr), hr);
25395:       if (pTargetRange) {
25395:         // If pTargetRange is not null and the current range is not overlapped
25395:         // with it, we don't need to add range.
25395:         if (targetStart > end || targetEnd < start)
25395:           continue;
25395:         // Otherwise, shrink to the target range.
71173:         start = NS_MAX(targetStart, start);
71173:         end = NS_MIN(targetEnd, end);
25395:       }
25395:       nsRefPtr<TSFRangeImpl> range = new TSFRangeImpl(start, end - start);
25395:       NS_ENSURE_TRUE(range, E_OUTOFMEMORY);
25395:       er->mRanges.AppendElement(range);
25395:     }
25395:     *ppEnum = er;
25395:     (*ppEnum)->AddRef();
25395:     return S_OK;
25395:   }
25395: 
25395:   STDMETHODIMP GetValue(TfEditCookie ec, ITfRange *pRange, VARIANT *pvarValue)
25395:   {
25395:     NS_ENSURE_TRUE(pvarValue, E_INVALIDARG);
25395: 
25395:     LONG givenStart, givenEnd;
25395:     HRESULT hr = GetRegularExtent(pRange, givenStart, givenEnd);
25395:     NS_ENSURE_TRUE(SUCCEEDED(hr), hr);
25395:     for (PRUint32 i = 0; i < mRanges.Length(); i++) {
25395:       LONG start, end;
25395:       HRESULT hr = GetRegularExtent(mRanges[i], start, end);
25395:       NS_ENSURE_TRUE(SUCCEEDED(hr), hr);
25395:       // pRange must be same as (or included in) a range of mRanges.
25395:       if (givenStart > start || givenEnd < end)
25395:         continue;
25395:       pvarValue->vt = VT_I4;
25395:       pvarValue->lVal = static_cast<DWORD>(GUID_ATOM_COMPOSING_SELECTION_ATTR);
25395:       return S_OK;
25395:     }
25395:     return E_FAIL;
25395:   }
25395: 
25395:   STDMETHODIMP GetContext(ITfContext **ppContext)
25395:   {
25395:     NS_NOTREACHED("ITfReadOnlyProperty::GetContext");
25395:     return E_NOTIMPL;
25395:   }
25395: };
25395: 
25857: /******************************************************************************
25857:  * TSFContextImpl
25857:  ******************************************************************************/
25857: 
25857: class TSFContextImpl : public ITfContext,
25857:                        public ITfCompositionView, public ITextStoreACPSink
24823: {
24823: private:
24823:   ULONG mRefCnt;
24823: 
24823: public:
25395:   nsRefPtr<TSFAttrPropImpl> mAttrProp;
25857:   nsRefPtr<TSFDocumentMgrImpl> mDocMgr;
79445:   bool mTextChanged;
79445:   bool mSelChanged;
24823:   TS_TEXTCHANGE mTextChangeData;
24823: 
24823: public:
25857:   TSFContextImpl(TSFDocumentMgrImpl* aDocMgr) :
80486:       mDocMgr(aDocMgr), mRefCnt(0), mTextChanged(false),
80486:       mSelChanged(false)
24823:   {
25395:     mAttrProp = new TSFAttrPropImpl();
25395:     if (!mAttrProp) {
25857:       NS_NOTREACHED("TSFContextImpl::TSFContextImpl (OOM)");
25395:       return;
25395:     }
24823:   }
24823: 
25857:   ~TSFContextImpl()
24823:   {
24823:   }
24823: 
24823: public: // IUnknown
24823: 
24823:   STDMETHODIMP QueryInterface(REFIID riid, void** ppUnk)
24823:   {
24823:     *ppUnk = NULL;
25857:     if (IID_IUnknown == riid || IID_ITfContext == riid)
24823:       *ppUnk = static_cast<ITfContext*>(this);
24823:     else if (IID_ITextStoreACPSink == riid)
24823:       *ppUnk = static_cast<ITextStoreACPSink*>(this);
24823:     if (*ppUnk)
24823:       AddRef();
24823:     return *ppUnk ? S_OK : E_NOINTERFACE;
24823:   }
24823: 
24823:   STDMETHODIMP_(ULONG) AddRef(void)
24823:   {
24823:     return ++mRefCnt;
24823:   }
24823: 
24823:   STDMETHODIMP_(ULONG) Release(void)
24823:   {
24823:     if (--mRefCnt) return mRefCnt;
24823:     delete this;
24823:     return 0;
24823:   }
24823: 
24823: public: // ITfContext
24823: 
24823:   STDMETHODIMP RequestEditSession(TfClientId tid, ITfEditSession *pes,
24823:                                   DWORD dwFlags, HRESULT *phrSession)
24823:   {
24823:     NS_NOTREACHED("ITfContext::RequestEditSession");
24823:     return E_NOTIMPL;
24823:   }
24823: 
24823:   STDMETHODIMP InWriteSession(TfClientId tid, BOOL *pfWriteSession)
24823:   {
24823:     NS_NOTREACHED("ITfContext::InWriteSession");
24823:     return E_NOTIMPL;
24823:   }
24823: 
24823:   STDMETHODIMP GetSelection(TfEditCookie ec, ULONG ulIndex, ULONG ulCount,
24823:                             TF_SELECTION *pSelection, ULONG *pcFetched)
24823:   {
24823:     NS_NOTREACHED("ITfContext::GetSelection");
24823:     return E_NOTIMPL;
24823:   }
24823: 
24823:   STDMETHODIMP SetSelection(TfEditCookie ec, ULONG ulCount,
24823:                          const TF_SELECTION *pSelection)
24823:   {
24823:     NS_NOTREACHED("ITfContext::SetSelection");
24823:     return E_NOTIMPL;
24823:   }
24823: 
24823:   STDMETHODIMP GetStart(TfEditCookie ec, ITfRange **ppStart)
24823:   {
24823:     NS_NOTREACHED("ITfContext::GetStart");
24823:     return E_NOTIMPL;
24823:   }
24823: 
24823:   STDMETHODIMP GetEnd(TfEditCookie ec, ITfRange **ppEnd)
24823:   {
24823:     NS_NOTREACHED("ITfContext::GetEnd");
24823:     return E_NOTIMPL;
24823:   }
24823: 
24823:   STDMETHODIMP GetActiveView(ITfContextView **ppView)
24823:   {
24823:     NS_NOTREACHED("ITfContext::GetActiveView");
24823:     return E_NOTIMPL;
24823:   }
24823: 
24823:   STDMETHODIMP EnumViews(IEnumTfContextViews **ppEnum)
24823:   {
24823:     NS_NOTREACHED("ITfContext::EnumViews");
24823:     return E_NOTIMPL;
24823:   }
24823: 
24823:   STDMETHODIMP GetStatus(TF_STATUS *pdcs)
24823:   {
24823:     NS_NOTREACHED("ITfContext::GetStatus");
24823:     return E_NOTIMPL;
24823:   }
24823: 
24823:   STDMETHODIMP GetProperty(REFGUID guidProp, ITfProperty **ppProp)
24823:   {
25395:     NS_ENSURE_TRUE(ppProp, E_INVALIDARG);
25395:     if (guidProp == GUID_PROP_ATTRIBUTE) {
25395:       (*ppProp) = mAttrProp;
25395:       (*ppProp)->AddRef();
25395:       return S_OK;
25395:     }
24823:     NS_NOTREACHED("ITfContext::GetProperty");
24823:     return E_NOTIMPL;
24823:   }
24823: 
24823:   STDMETHODIMP GetAppProperty(REFGUID guidProp, ITfReadOnlyProperty **ppProp)
24823:   {
24823:     NS_NOTREACHED("ITfContext::GetAppProperty");
24823:     return E_NOTIMPL;
24823:   }
24823: 
24823:   STDMETHODIMP TrackProperties(const GUID **prgProp, ULONG cProp,
24823:                             const GUID **prgAppProp, ULONG cAppProp,
24823:                             ITfReadOnlyProperty **ppProperty)
24823:   {
24823:     NS_NOTREACHED("ITfContext::TrackProperties");
24823:     return E_NOTIMPL;
24823:   }
24823: 
24823:   STDMETHODIMP EnumProperties(IEnumTfProperties **ppEnum)
24823:   {
24823:     NS_NOTREACHED("ITfContext::EnumProperties");
24823:     return E_NOTIMPL;
24823:   }
24823: 
24823:   STDMETHODIMP GetDocumentMgr(ITfDocumentMgr **ppDm)
24823:   {
24823:     NS_NOTREACHED("ITfContext::GetDocumentMgr");
24823:     return E_NOTIMPL;
24823:   }
24823: 
24823:   STDMETHODIMP CreateRangeBackup(TfEditCookie ec, ITfRange *pRange,
24823:                               ITfRangeBackup **ppBackup)
24823:   {
24823:     NS_NOTREACHED("ITfContext::CreateRangeBackup");
24823:     return E_NOTIMPL;
24823:   }
24823: 
24823: public: // ITfCompositionView
24823: 
24823:   STDMETHODIMP GetOwnerClsid(CLSID* pclsid)
24823:   {
24823:     NS_NOTREACHED("ITfCompositionView::GetOwnerClsid");
24823:     return E_NOTIMPL;
24823:   }
24823: 
24823:   STDMETHODIMP GetRange(ITfRange** ppRange)
24823:   {
25395:     NS_ENSURE_TRUE(ppRange, E_INVALIDARG);
25395:     NS_ENSURE_TRUE(mAttrProp->mRanges.Length() > 0, E_FAIL);
25395:     LONG start = LONG_MAX, end = 0;
25395:     for (PRUint32 i = 0; i < mAttrProp->mRanges.Length(); i++) {
25395:       LONG tmpStart, tmpEnd;
25395:       HRESULT hr = GetRegularExtent(mAttrProp->mRanges[i], tmpStart, tmpEnd);
25395:       NS_ENSURE_TRUE(SUCCEEDED(hr), hr);
71173:       start = NS_MIN(start, tmpStart);
71173:       end = NS_MAX(end, tmpEnd);
25395:     }
25395:     nsRefPtr<TSFRangeImpl> range = new TSFRangeImpl();
25395:     NS_ENSURE_TRUE(range, E_OUTOFMEMORY);
25395:     HRESULT hr = range->SetExtent(start, end - start);
25395:     NS_ENSURE_TRUE(SUCCEEDED(hr), hr);
25395:     (*ppRange) = range;
24823:     (*ppRange)->AddRef();
24823:     return S_OK;
24823:   }
24823: 
24823: public: // ITextStoreACPSink
24823: 
24823:   STDMETHODIMP OnTextChange(DWORD dwFlags, const TS_TEXTCHANGE *pChange)
24823:   {
80486:     mTextChanged = true;
24823:     mTextChangeData = *pChange;
24823:     return S_OK;
24823:   }
24823: 
24823:   STDMETHODIMP OnSelectionChange(void)
24823:   {
80486:     mSelChanged = true;
24823:     return S_OK;
24823:   }
24823: 
24823:   STDMETHODIMP OnLayoutChange(TsLayoutCode lcode, TsViewCookie vcView)
24823:   {
24823:     return S_OK;
24823:   }
24823: 
24823:   STDMETHODIMP OnStatusChange(DWORD dwFlags)
24823:   {
24823:     return S_OK;
24823:   }
24823: 
24823:   STDMETHODIMP OnAttrsChange(LONG acpStart, LONG acpEnd, ULONG cAttrs,
24823:                           const TS_ATTRID *paAttrs)
24823:   {
24823:     return S_OK;
24823:   }
24823: 
25857:   STDMETHODIMP OnLockGranted(DWORD dwLockFlags);
24823: 
24823:   STDMETHODIMP OnStartEditTransaction(void)
24823:   {
24823:     return S_OK;
24823:   }
24823: 
24823:   STDMETHODIMP OnEndEditTransaction(void)
24823:   {
24823:     return S_OK;
24823:   }
24823: };
24823: 
25857: /******************************************************************************
25857:  * TSFDocumentMgrImpl
25857:  ******************************************************************************/
25857: 
25857: class TSFDocumentMgrImpl : public ITfDocumentMgr
25857: {
25857: private:
25857:   ULONG mRefCnt;
25857: 
25857: public:
25857:   nsRefPtr<TSFMgrImpl> mMgr;
25857:   nsRefPtr<ITextStoreACP> mStore;
25857:   nsRefPtr<TSFContextImpl> mContextBase;
25857:   nsRefPtr<TSFContextImpl> mContextTop; // XXX currently, we don't support this.
25857: 
25857: public:
25857:   TSFDocumentMgrImpl(TSFMgrImpl* aMgr) :
25857:       mRefCnt(0), mMgr(aMgr)
25857:   {
25857:   }
25857: 
25857:   ~TSFDocumentMgrImpl()
25857:   {
25857:   }
25857: 
25857: public: // IUnknown
25857: 
25857:   STDMETHODIMP QueryInterface(REFIID riid, void** ppUnk)
25857:   {
25857:     *ppUnk = NULL;
25857:     if (IID_IUnknown == riid || IID_ITfDocumentMgr == riid)
25857:       *ppUnk = static_cast<ITfDocumentMgr*>(this);
25857:     if (*ppUnk)
25857:       AddRef();
25857:     return *ppUnk ? S_OK : E_NOINTERFACE;
25857:   }
25857: 
25857:   STDMETHODIMP_(ULONG) AddRef(void)
25857:   {
25857:     return ++mRefCnt;
25857:   }
25857: 
25857:   STDMETHODIMP_(ULONG) Release(void);
25857: 
25857: public: // ITfDocumentMgr
25857: 
25857:   STDMETHODIMP CreateContext(TfClientId tidOwner, DWORD dwFlags,
25857:                              IUnknown *punk, ITfContext **ppic,
25857:                              TfEditCookie *pecTextStore)
25857:   {
25857:     nsRefPtr<TSFContextImpl> context = new TSFContextImpl(this);
25857:     punk->QueryInterface(IID_ITextStoreACP, getter_AddRefs(mStore));
25857:     NS_ENSURE_TRUE(mStore, E_FAIL);
25857:     HRESULT hr =
25857:       mStore->AdviseSink(IID_ITextStoreACPSink,
25857:                          static_cast<ITextStoreACPSink*>(context.get()),
25857:                          TS_AS_ALL_SINKS);
25857:     if (FAILED(hr)) mStore = NULL;
25857:     NS_ENSURE_TRUE(SUCCEEDED(hr), E_FAIL);
25857:     (*ppic) = context;
25857:     (*ppic)->AddRef();
25857:     *pecTextStore = 1;
25857:     return S_OK;
25857:   }
25857: 
25857:   STDMETHODIMP Push(ITfContext *pic)
25857:   {
25857:     if (mContextTop) {
25857:       NS_NOTREACHED("TSFDocumentMgrImpl::Push stack is already full");
25857:       return E_FAIL;
25857:     }
25857:     if (mContextBase) {
25857:       NS_WARNING("TSFDocumentMgrImpl::Push additional context is pushed, but we don't support that yet.");
25857:       if (mContextBase == pic) {
25857:         NS_NOTREACHED("TSFDocumentMgrImpl::Push same context is pused again");
25857:         return E_FAIL;
25857:       }
25857:       mContextTop = static_cast<TSFContextImpl*>(pic);
25857:       return S_OK;
25857:     }
25857:     mContextBase = static_cast<TSFContextImpl*>(pic);
25857:     return S_OK;
25857:   }
25857: 
25857:   STDMETHODIMP Pop(DWORD dwFlags)
25857:   {
25857:     if (!mStore)
25857:       return E_FAIL;
25857:     if (dwFlags == TF_POPF_ALL) {
25857:       NS_ENSURE_TRUE(mContextBase, E_FAIL);
25857:       mStore->UnadviseSink(static_cast<ITextStoreACPSink*>(mContextBase.get()));
25857:       mStore = NULL;
25857:       mContextBase = nsnull;
25857:       mContextTop = nsnull;
25857:       return S_OK;
25857:     }
25857:     if (dwFlags == 0) {
25857:       if (!mContextTop) {
25857:         NS_NOTREACHED("TSFDocumentMgrImpl::Pop there is non-base context");
25857:         return E_FAIL;
25857:       }
25857:       mContextTop = nsnull;
25857:       return S_OK;
25857:     }
25857:     NS_NOTREACHED("TSFDocumentMgrImpl::Pop invalid flag");
25857:     return E_FAIL;
25857:   }
25857: 
25857:   STDMETHODIMP GetTop(ITfContext **ppic)
25857:   {
25857:     (*ppic) = mContextTop ? mContextTop : mContextBase;
25857:     if (*ppic) (*ppic)->AddRef();
25857:     return S_OK;
25857:   }
25857: 
25857:   STDMETHODIMP GetBase(ITfContext **ppic)
25857:   {
25857:     (*ppic) = mContextBase;
25857:     if (*ppic) (*ppic)->AddRef();
25857:     return S_OK;
25857:   }
25857: 
25857:   STDMETHODIMP EnumContexts(IEnumTfContexts **ppEnum)
25857:   {
25857:     NS_NOTREACHED("ITfDocumentMgr::EnumContexts");
25857:     return E_NOTIMPL;
25857:   }
25857: 
25857: };
25857: 
25857: /******************************************************************************
25857:  * TSFMgrImpl
25857:  ******************************************************************************/
25857: 
25857: class TSFMgrImpl : public ITfThreadMgr,
25857:                    public ITfDisplayAttributeMgr, public ITfCategoryMgr
25857: {
25857: private:
25857:   ULONG mRefCnt;
25857: 
25857: public:
25857:   nsRefPtr<TestApp> mTestApp;
25857:   TestApp::test_type mTest;
79445:   bool mDeactivated;
25857:   TSFDocumentMgrImpl* mFocusedDocument; // Must be raw pointer, but strong.
25857:   PRInt32 mFocusCount;
25857: 
25857:   TSFMgrImpl(TestApp* test) : mTestApp(test), mTest(nsnull), mRefCnt(0),
80486:     mDeactivated(false), mFocusedDocument(nsnull), mFocusCount(0)
25857:   {
25857:   }
25857: 
25857:   ~TSFMgrImpl()
25857:   {
25857:   }
25857: 
25857: public: // IUnknown
25857: 
25857:   STDMETHODIMP QueryInterface(REFIID riid, void** ppUnk)
25857:   {
25857:     *ppUnk = NULL;
25857:     if (IID_IUnknown == riid || IID_ITfThreadMgr == riid)
25857:       *ppUnk = static_cast<ITfThreadMgr*>(this);
25857:     else if (IID_ITfDisplayAttributeMgr == riid)
25857:       *ppUnk = static_cast<ITfDisplayAttributeMgr*>(this);
25857:     else if (IID_ITfCategoryMgr == riid)
25857:       *ppUnk = static_cast<ITfCategoryMgr*>(this);
25857:     if (*ppUnk)
25857:       AddRef();
25857:     return *ppUnk ? S_OK : E_NOINTERFACE;
25857:   }
25857: 
25857:   STDMETHODIMP_(ULONG) AddRef(void)
25857:   {
25857:     return ++mRefCnt;
25857:   }
25857: 
25857:   STDMETHODIMP_(ULONG) Release(void)
25857:   {
25857:     if (--mRefCnt) return mRefCnt;
25857:     delete this;
25857:     return 0;
25857:   }
25857: 
25857: public: // ITfThreadMgr
25857: 
25857:   STDMETHODIMP Activate(TfClientId *ptid)
25857:   {
25857:     *ptid = 1;
25857:     return S_OK;
25857:   }
25857: 
25857:   STDMETHODIMP Deactivate(void)
25857:   {
80486:     mDeactivated = true;
25857:     return S_OK;
25857:   }
25857: 
25857:   STDMETHODIMP CreateDocumentMgr(ITfDocumentMgr **ppdim)
25857:   {
25857:     nsRefPtr<TSFDocumentMgrImpl> docMgr = new TSFDocumentMgrImpl(this);
25857:     if (!docMgr) {
25857:       NS_NOTREACHED("TSFMgrImpl::CreateDocumentMgr (OOM)");
25857:       return E_OUTOFMEMORY;
25857:     }
25857:     (*ppdim) = docMgr;
25857:     (*ppdim)->AddRef();
25857:     return S_OK;
25857:   }
25857: 
25857:   STDMETHODIMP EnumDocumentMgrs(IEnumTfDocumentMgrs **ppEnum)
25857:   {
25857:     NS_NOTREACHED("ITfThreadMgr::EnumDocumentMgrs");
25857:     return E_NOTIMPL;
25857:   }
25857: 
25857:   STDMETHODIMP GetFocus(ITfDocumentMgr **ppdimFocus)
25857:   {
25857:     (*ppdimFocus) = mFocusedDocument;
25857:     if (*ppdimFocus) (*ppdimFocus)->AddRef();
25857:     return S_OK;
25857:   }
25857: 
25857:   STDMETHODIMP SetFocus(ITfDocumentMgr *pdimFocus)
25857:   {
25857:     if (!pdimFocus) {
25857:       NS_NOTREACHED("ITfThreadMgr::SetFocus must not be called with NULL");
25857:       return E_FAIL;
25857:     }
25857:     mFocusCount++;
25857:     if (mFocusedDocument == pdimFocus) {
25857:       return S_OK;
25857:     }
25857:     mFocusedDocument = static_cast<TSFDocumentMgrImpl*>(pdimFocus);
25857:     mFocusedDocument->AddRef();
25857:     return S_OK;
25857:   }
25857: 
25857:   STDMETHODIMP AssociateFocus(HWND hwnd, ITfDocumentMgr *pdimNew,
25857:                            ITfDocumentMgr **ppdimPrev)
25857:   {
25857:     NS_NOTREACHED("ITfThreadMgr::AssociateFocus");
25857:     return E_NOTIMPL;
25857:   }
25857: 
25857:   STDMETHODIMP IsThreadFocus(BOOL *pfThreadFocus)
25857:   {
25857:     *pfThreadFocus = TRUE;
25857:     return S_OK;
25857:   }
25857: 
25857:   STDMETHODIMP GetFunctionProvider(REFCLSID clsid,
25857:                                 ITfFunctionProvider **ppFuncProv)
25857:   {
25857:     NS_NOTREACHED("ITfThreadMgr::GetFunctionProvider");
25857:     return E_NOTIMPL;
25857:   }
25857: 
25857:   STDMETHODIMP EnumFunctionProviders(IEnumTfFunctionProviders **ppEnum)
25857:   {
25857:     NS_NOTREACHED("ITfThreadMgr::EnumFunctionProviders");
25857:     return E_NOTIMPL;
25857:   }
25857: 
25857:   STDMETHODIMP GetGlobalCompartment(ITfCompartmentMgr **ppCompMgr)
25857:   {
25857:     NS_NOTREACHED("ITfThreadMgr::GetGlobalCompartment");
25857:     return E_NOTIMPL;
25857:   }
25857: 
25857: public: // ITfCategoryMgr
25857: 
25857:   STDMETHODIMP RegisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid)
25857:   {
25857:     NS_NOTREACHED("ITfCategoryMgr::RegisterCategory");
25857:     return E_NOTIMPL;
25857:   }
25857: 
25857:   STDMETHODIMP UnregisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid)
25857:   {
25857:     NS_NOTREACHED("ITfCategoryMgr::UnregisterCategory");
25857:     return E_NOTIMPL;
25857:   }
25857: 
25857:   STDMETHODIMP EnumCategoriesInItem(REFGUID rguid, IEnumGUID **ppEnum)
25857:   {
25857:     NS_NOTREACHED("ITfCategoryMgr::EnumCategoriesInItem");
25857:     return E_NOTIMPL;
25857:   }
25857: 
25857:   STDMETHODIMP EnumItemsInCategory(REFGUID rcatid, IEnumGUID **ppEnum)
25857:   {
25857:     NS_NOTREACHED("ITfCategoryMgr::EnumItemsInCategory");
25857:     return E_NOTIMPL;
25857:   }
25857: 
25857:   STDMETHODIMP FindClosestCategory(REFGUID rguid, GUID *pcatid,
25857:                                    const GUID **ppcatidList, ULONG ulCount)
25857:   {
25857:     NS_NOTREACHED("ITfCategoryMgr::FindClosestCategory");
25857:     return E_NOTIMPL;
25857:   }
25857: 
25857:   STDMETHODIMP RegisterGUIDDescription(REFCLSID rclsid, REFGUID rguid,
25857:                                        const WCHAR *pchDesc, ULONG cch)
25857:   {
25857:     NS_NOTREACHED("ITfCategoryMgr::RegisterGUIDDescription");
25857:     return E_NOTIMPL;
25857:   }
25857: 
25857:   STDMETHODIMP UnregisterGUIDDescription(REFCLSID rclsid, REFGUID rguid)
25857:   {
25857:     NS_NOTREACHED("ITfCategoryMgr::UnregisterGUIDDescription");
25857:     return E_NOTIMPL;
25857:   }
25857: 
25857:   STDMETHODIMP GetGUIDDescription(REFGUID rguid, BSTR *pbstrDesc)
25857:   {
25857:     NS_NOTREACHED("ITfCategoryMgr::GetGUIDDescription");
25857:     return E_NOTIMPL;
25857:   }
25857: 
25857:   STDMETHODIMP RegisterGUIDDWORD(REFCLSID rclsid, REFGUID rguid, DWORD dw)
25857:   {
25857:     NS_NOTREACHED("ITfCategoryMgr::RegisterGUIDDWORD");
25857:     return E_NOTIMPL;
25857:   }
25857: 
25857:   STDMETHODIMP UnregisterGUIDDWORD(REFCLSID rclsid, REFGUID rguid)
25857:   {
25857:     NS_NOTREACHED("ITfCategoryMgr::UnregisterGUIDDWORD");
25857:     return E_NOTIMPL;
25857:   }
25857: 
25857:   STDMETHODIMP GetGUIDDWORD(REFGUID rguid, DWORD *pdw)
25857:   {
25857:     NS_NOTREACHED("ITfCategoryMgr::GetGUIDDWORD");
25857:     return E_NOTIMPL;
25857:   }
25857: 
25857:   STDMETHODIMP RegisterGUID(REFGUID rguid, TfGuidAtom *pguidatom)
25857:   {
25857:     NS_NOTREACHED("ITfCategoryMgr::RegisterGUID");
25857:     return E_NOTIMPL;
25857:   }
25857: 
25857:   STDMETHODIMP GetGUID(TfGuidAtom guidatom, GUID *pguid)
25857:   {
25857:     if (guidatom == GUID_ATOM_COMPOSING_SELECTION_ATTR) {
25857:       *pguid = GUID_COMPOSING_SELECTION_ATTR;
25857:       return S_OK;
25857:     }
25857:     NS_NOTREACHED("ITfCategoryMgr::GetGUID");
25857:     return E_FAIL;
25857:   }
25857: 
25857:   STDMETHODIMP IsEqualTfGuidAtom(TfGuidAtom guidatom, REFGUID rguid,
25857:                                  BOOL *pfEqual)
25857:   {
25857:     NS_NOTREACHED("ITfCategoryMgr::IsEqualTfGuidAtom");
25857:     return E_NOTIMPL;
25857:   }
25857: 
25857: public: // ITfDisplayAttributeMgr
25857: 
25857:   STDMETHODIMP OnUpdateInfo()
25857:   {
25857:     NS_NOTREACHED("ITfDisplayAttributeMgr::OnUpdateInfo");
25857:     return E_NOTIMPL;
25857:   }
25857: 
25857:   STDMETHODIMP EnumDisplayAttributeInfo(IEnumTfDisplayAttributeInfo **ppEnum)
25857:   {
25857:     NS_NOTREACHED("ITfDisplayAttributeMgr::EnumDisplayAttributeInfo");
25857:     return E_NOTIMPL;
25857:   }
25857: 
25857:   STDMETHODIMP GetDisplayAttributeInfo(REFGUID guid,
25857:                                        ITfDisplayAttributeInfo **ppInfo,
25857:                                        CLSID *pclsidOwner)
25857:   {
25857:     NS_ENSURE_TRUE(ppInfo, E_INVALIDARG);
25857:     NS_ENSURE_TRUE(!pclsidOwner, E_INVALIDARG);
25857:     if (guid == GUID_COMPOSING_SELECTION_ATTR) {
25857:       (*ppInfo) = new TSFDispAttrInfoImpl(guid);
25857:       (*ppInfo)->AddRef();
25857:       return S_OK;
25857:     }
25857:     NS_NOTREACHED("ITfDisplayAttributeMgr::GetDisplayAttributeInfo");
25857:     return E_FAIL;
25857:   }
25857: 
25857: public:
25857: 
25857:   ITextStoreACP* GetFocusedStore()
25857:   {
25857:     return mFocusedDocument ? mFocusedDocument->mStore : nsnull;
25857:   }
25857: 
25857:   TSFContextImpl* GetFocusedContext()
25857:   {
25857:     return mFocusedDocument ? mFocusedDocument->mContextBase : nsnull;
25857:   }
25857: 
25857:   TSFAttrPropImpl* GetFocusedAttrProp()
25857:   {
25857:     TSFContextImpl* context = GetFocusedContext();
25857:     return context ? context->mAttrProp : nsnull;
25857:   }
25857: 
25857: };
25857: 
25857: STDMETHODIMP
25857: TSFContextImpl::OnLockGranted(DWORD dwLockFlags)
25857: {
25857:   // If we have a test, run it
25857:   if (mDocMgr->mMgr->mTest &&
36726:      !((*mDocMgr->mMgr->mTestApp).*(mDocMgr->mMgr->mTest))())
25857:     return S_FALSE;
25857:   return S_OK;
25857: }
25857: 
25857: 
25857: STDMETHODIMP_(ULONG)
25857: TSFDocumentMgrImpl::Release(void)
25857: {
25857:   --mRefCnt;
25857:   if (mRefCnt == 1 && mMgr->mFocusedDocument == this) {
25857:     mMgr->mFocusedDocument = nsnull;
25857:     --mRefCnt;
25857:   }
25857:   if (mRefCnt) return mRefCnt;
25857:   delete this;
25857:   return 0;
25857: }
25857: 
24823: NS_IMPL_ISUPPORTS2(TestApp, nsIWebProgressListener,
24823:                             nsISupportsWeakReference)
24823: 
24823: nsresult
24823: TestApp::Run(void)
24823: {
24823:   // Create a test window
24823:   // We need a full-fledged window to test for TSF functionality
24823:   nsresult rv;
24823:   mAppShell = do_GetService(kAppShellCID);
24823:   NS_ENSURE_TRUE(mAppShell, NS_ERROR_UNEXPECTED);
24823: 
24823:   nsCOMPtr<nsIAppShellService> appShellService(
24823:       do_GetService(NS_APPSHELLSERVICE_CONTRACTID));
24823:   NS_ENSURE_TRUE(appShellService, NS_ERROR_UNEXPECTED);
24823: 
24823:   nsCOMPtr<nsIURI> uri;
24823:   rv = NS_NewURI(getter_AddRefs(uri), "about:blank", nsnull);
24823:   NS_ENSURE_SUCCESS(rv, rv);
24823: 
24823:   rv = appShellService->CreateTopLevelWindow(nsnull, uri,
24823:                            nsIWebBrowserChrome::CHROME_DEFAULT,
24823:                            800 /*nsIAppShellService::SIZE_TO_CONTENT*/,
24823:                            600 /*nsIAppShellService::SIZE_TO_CONTENT*/,
80433:                            getter_AddRefs(mWindow));
24823:   NS_ENSURE_SUCCESS(rv, rv);
24823: 
24823:   nsCOMPtr<nsIDocShell> docShell;
24823:   rv = mWindow->GetDocShell(getter_AddRefs(docShell));
24823:   NS_ENSURE_TRUE(docShell, NS_ERROR_UNEXPECTED);
24823:   nsCOMPtr<nsIWebProgress> progress(do_GetInterface(docShell));
24823:   NS_ENSURE_TRUE(progress, NS_ERROR_UNEXPECTED);
24823:   rv = progress->AddProgressListener(this,
24823:                                      nsIWebProgress::NOTIFY_STATE_WINDOW |
24823:                                          nsIWebProgress::NOTIFY_STATUS);
24823:   NS_ENSURE_SUCCESS(rv, rv);
24823: 
24823:   mAppShell->Run();
24823:   return NS_OK;
24823: }
24823: 
79445: bool
24823: TestApp::CheckFailed(void)
24823: {
24823:   // All windows should be closed by now
25857:   if (mMgr && !mMgr->mDeactivated) {
24823:     fail("TSF not terminated properly");
80486:     mFailed = true;
24823:   }
25857:   mMgr = nsnull;
24823:   return mFailed;
24823: }
24823: 
24823: nsresult
24823: TestApp::Init(void)
24823: {
25395:   // Replace TSF manager pointer, category manager pointer and display
25395:   // attribute manager pointer.
24823:   nsCOMPtr<nsIBaseWindow> baseWindow(do_QueryInterface(mWindow));
24823:   NS_ENSURE_TRUE(baseWindow, NS_ERROR_UNEXPECTED);
24823:   nsCOMPtr<nsIWidget> widget;
24823:   nsresult rv = baseWindow->GetMainWidget(getter_AddRefs(widget));
24823:   NS_ENSURE_TRUE(widget, NS_ERROR_UNEXPECTED);
24823: 
25395:   ITfThreadMgr **threadMgr = reinterpret_cast<ITfThreadMgr**>(
25395:       widget->GetNativeData(NS_NATIVE_TSF_THREAD_MGR));
25395:   if (!threadMgr) {
25395:     fail("nsIWidget::GetNativeData(NS_NATIVE_TSF_THREAD_MGR) not supported");
24823:     return NS_ERROR_FAILURE;
24823:   }
25395:   if (*threadMgr) {
25395:     (*threadMgr)->Deactivate();
25395:     (*threadMgr)->Release();
25395:     (*threadMgr) = NULL;
24823:   } else {
24823:     // This is only for information. The test does not need TSF to run.
24823:     printf("TSF not initialized properly (TSF is not enabled/installed?)\n");
24823:   }
24823: 
25395:   ITfCategoryMgr **catMgr = reinterpret_cast<ITfCategoryMgr**>(
25395:       widget->GetNativeData(NS_NATIVE_TSF_CATEGORY_MGR));
25395:   if (*catMgr) {
25395:     (*catMgr)->Release();
25395:     (*catMgr) = NULL;
25395:   }
25395:   ITfDisplayAttributeMgr **daMgr = reinterpret_cast<ITfDisplayAttributeMgr**>(
25395:       widget->GetNativeData(NS_NATIVE_TSF_DISPLAY_ATTR_MGR));
25395:   if (*daMgr) {
25395:     (*daMgr)->Release();
25395:     (*daMgr) = NULL;
25395:   }
25395: 
25857:   mMgr = new TSFMgrImpl(this);
25857:   if (!mMgr) {
24823:     return NS_ERROR_OUT_OF_MEMORY;
24823:   }
25857:   (*threadMgr) = mMgr;
25395:   (*threadMgr)->AddRef();
25857:   (*catMgr) = mMgr;
25395:   (*catMgr)->AddRef();
25857:   (*daMgr) = mMgr;
25395:   (*daMgr)->AddRef();
24823: 
24823:   // Apply the change
24823:   reinterpret_cast<ITfThreadMgr**>(
25395:       widget->GetNativeData(NS_NATIVE_TSF_THREAD_MGR));
24823: 
24823:   // Create a couple of text boxes for testing
73870:   nsCOMPtr<nsIDOMWindow> win(do_GetInterface(mWindow));
24823:   NS_ENSURE_TRUE(win, NS_ERROR_UNEXPECTED);
24823:   nsCOMPtr<nsIDOMDocument> document;
24823:   rv = win->GetDocument(getter_AddRefs(document));
24823:   NS_ENSURE_TRUE(document, NS_ERROR_UNEXPECTED);
24823:   nsCOMPtr<nsIDOMHTMLDocument> htmlDoc(do_QueryInterface(document));
24823:   NS_ENSURE_TRUE(htmlDoc, NS_ERROR_UNEXPECTED);
24823:   nsCOMPtr<nsIDOMHTMLElement> htmlBody;
24823:   rv = htmlDoc->GetBody(getter_AddRefs(htmlBody));
24823:   NS_ENSURE_TRUE(htmlBody, NS_ERROR_UNEXPECTED);
24823: 
24823:   nsCOMPtr<nsIDOMElement> form;
24823:   rv = htmlDoc->CreateElementNS(
24823:                      NS_LITERAL_STRING("http://www.w3.org/1999/xhtml"),
24823:                      NS_LITERAL_STRING("form"),
24823:                      getter_AddRefs(form));
24823:   nsCOMPtr<nsIDOMElement> elem;
24823:   rv = htmlDoc->CreateElementNS(
24823:                      NS_LITERAL_STRING("http://www.w3.org/1999/xhtml"),
24823:                      NS_LITERAL_STRING("input"),
24823:                      getter_AddRefs(elem));
24823:   NS_ENSURE_SUCCESS(rv, rv);
24823:   elem->SetAttribute(NS_LITERAL_STRING("type"),
24823:                       NS_LITERAL_STRING("text"));
24823:   mInput = do_QueryInterface(elem);
24823:   NS_ENSURE_TRUE(mInput, NS_ERROR_UNEXPECTED);
24823:   rv = htmlDoc->CreateElementNS(
24823:                      NS_LITERAL_STRING("http://www.w3.org/1999/xhtml"),
24823:                      NS_LITERAL_STRING("textarea"),
24823:                      getter_AddRefs(elem));
24823:   NS_ENSURE_SUCCESS(rv, rv);
24823:   mTextArea = do_QueryInterface(elem);
24823:   NS_ENSURE_TRUE(mTextArea, NS_ERROR_UNEXPECTED);
24823:   rv = htmlDoc->CreateElementNS(
24823:                      NS_LITERAL_STRING("http://www.w3.org/1999/xhtml"),
24823:                      NS_LITERAL_STRING("input"),
24823:                      getter_AddRefs(elem));
24823:   NS_ENSURE_SUCCESS(rv, rv);
24823:   elem->SetAttribute(NS_LITERAL_STRING("type"),
24823:                      NS_LITERAL_STRING("button"));
24823:   mButton = do_QueryInterface(elem);
24823:   NS_ENSURE_TRUE(mButton, NS_ERROR_UNEXPECTED);
24823: 
24823:   nsCOMPtr<nsIDOMNode> node;
24823:   rv = form->AppendChild(mInput, getter_AddRefs(node));
24823:   NS_ENSURE_SUCCESS(rv, rv);
24823:   rv = form->AppendChild(mTextArea, getter_AddRefs(node));
24823:   NS_ENSURE_SUCCESS(rv, rv);
24823:   rv = form->AppendChild(mButton, getter_AddRefs(node));
24823:   NS_ENSURE_SUCCESS(rv, rv);
24823:   rv = htmlBody->AppendChild(form, getter_AddRefs(node));
24823:   NS_ENSURE_SUCCESS(rv, rv);
24823: 
24823:   // set a background color manually,
24823:   // otherwise the window might be transparent
24823:   nsCOMPtr<nsIDOMHTMLBodyElement>(do_QueryInterface(htmlBody))->
24823:       SetBgColor(NS_LITERAL_STRING("white"));
24823: 
80486:   widget->Show(true);
24823:   widget->SetFocus();
24823:   return NS_OK;
24823: }
24823: 
24823: nsresult
24823: TestApp::Term(void)
24823: {
24823:   mCurrentNode = nsnull;
24823:   mInput = nsnull;
24823:   mTextArea = nsnull;
24823:   mButton = nsnull;
24823: 
73870:   nsCOMPtr<nsIDOMWindow> win(do_GetInterface(mWindow));
24823:   if (win)
24823:     win->Close();
24823:   win = nsnull;
24823:   mWindow = nsnull;
24823: 
24823:   if (mAppShell)
24823:     mAppShell->Exit();
24823:   mAppShell = nsnull;
24823:   return NS_OK;
24823: }
24823: 
79445: bool
79445: TestApp::RunTest(test_type aTest, bool aLock)
24823: {
79445:   bool succeeded;
25857:   if (aLock && mMgr && mMgr->GetFocusedStore()) {
25857:     mMgr->mTest = aTest;
24823:     HRESULT hr = E_FAIL;
25857:     mMgr->GetFocusedStore()->RequestLock(TS_LF_READWRITE | TS_LF_SYNC, &hr);
24823:     succeeded = hr == S_OK;
24823:   } else {
24823:     succeeded = (this->*aTest)();
24823:   }
24823:   mFailed |= !succeeded;
24823:   return succeeded;
24823: }
24823: 
24823: NS_IMETHODIMP
24823: TestApp::OnStateChange(nsIWebProgress *aWebProgress,
24823:                         nsIRequest *aRequest,
24823:                         PRUint32 aStateFlags,
24823:                         nsresult aStatus)
24823: {
24823:   NS_ASSERTION(aStateFlags & nsIWebProgressListener::STATE_IS_WINDOW &&
24823:               aStateFlags & nsIWebProgressListener::STATE_STOP, "wrong state");
24823:   if (NS_SUCCEEDED(Init())) {
39629:     mCurrentNode = mTextArea;
39629:     mTextArea->Focus();
39629: 
31218:     if (RunTest(&TestApp::TestEditMessages))
31218:       passed("TestEditMessages");
39248:     if (RunTest(&TestApp::TestScrollMessages))
39248:       passed("TestScrollMessages");
28352: 
80486:     if (RunTest(&TestApp::TestFocus, false))
24823:       passed("TestFocus");
24823: 
24823:     mCurrentNode = mInput;
24823:     mInput->Focus();
25857:     if (mMgr->GetFocusedStore()) {
24823:       if (RunTest(&TestApp::TestClustering))
24823:         passed("TestClustering");
24823:     } else {
24823:       fail("no text store (clustering)");
80486:       mFailed = true;
24823:     }
24823: 
24823:     printf("Testing TSF support in text input element...\n");
24823:     mCurrentNode = mInput;
24823:     mTestString = NS_LITERAL_STRING(
24823:       "This is a test of the Text Services Framework implementation.");
24823:     mInput->SetValue(mTestString);
24823:     mInput->Focus();
25857:     if (mMgr->GetFocusedStore()) {
24823:       if (RunTest(&TestApp::TestSelection))
24823:         passed("TestSelection (input)");
24823:       if (RunTest(&TestApp::TestText))
24823:         passed("TestText (input)");
24823:       if (RunTest(&TestApp::TestExtents))
24823:         passed("TestExtents (input)");
24823:       if (RunTest(&TestApp::TestComposition))
24823:         passed("TestComposition (input)");
80486:       if (RunTest(&TestApp::TestNotification, false))
24823:         passed("TestNotification (input)");
24823:     } else {
24823:       fail("no text store (input)");
80486:       mFailed = true;
24823:     }
24823: 
24823:     printf("Testing TSF support in textarea element...\n");
24823:     mCurrentNode = mTextArea;
24823:     mTestString = NS_LITERAL_STRING(
24823:       "This is a test of the\r\nText Services Framework\r\nimplementation.");
24823:     mTextArea->SetValue(mTestString);
24823:     mTextArea->Focus();
25857:     if (mMgr->GetFocusedStore()) {
24823:       if (RunTest(&TestApp::TestSelection))
24823:         passed("TestSelection (textarea)");
24823:       if (RunTest(&TestApp::TestText))
24823:         passed("TestText (textarea)");
24823:       if (RunTest(&TestApp::TestExtents))
24823:         passed("TestExtents (textarea)");
24823:       if (RunTest(&TestApp::TestComposition))
24823:         passed("TestComposition (textarea)");
80486:       if (RunTest(&TestApp::TestNotification, false))
24823:         passed("TestNotification (textarea)");
24823:     } else {
24823:       fail("no text store (textarea)");
80486:       mFailed = true;
24823:     }
24823:   } else {
24823:     fail("initialization");
80486:     mFailed = true;
24823:   }
24823:   Term();
24823:   return NS_OK;
24823: }
24823: 
79445: bool
24823: TestApp::TestFocus(void)
24823: {
25857:   PRUint32 focus = mMgr->mFocusCount;
24823:   nsresult rv;
24823: 
24823:   /* If these fail the cause is probably one or more of:
24823:    * - nsIMEStateManager::OnTextStateFocus not called by nsEventStateManager
24823:    * - nsIMEStateManager::OnTextStateBlur not called by nsEventStateManager
24823:    * - nsWindow::OnIMEFocusChange (nsIWidget) not called by nsIMEStateManager
24823:    * - nsTextStore::Create/Focus/Destroy not called by nsWindow
24823:    * - ITfThreadMgr::CreateDocumentMgr/SetFocus not called by nsTextStore
24823:    * - ITfDocumentMgr::CreateContext/Push not called by nsTextStore
24823:    */
24823: 
24823:   rv = mInput->Focus();
24823:   if (!(NS_SUCCEEDED(rv) &&
25857:         mMgr->mFocusedDocument &&
25857:         mMgr->mFocusCount - focus == 1 &&
25857:         mMgr->GetFocusedStore())) {
24823:     fail("TestFocus: document focus was not set");
80486:     return false;
24823:   }
24823: 
24823:   rv = mTextArea->Focus();
24823:   if (!(NS_SUCCEEDED(rv) &&
25857:         mMgr->mFocusedDocument &&
25857:         mMgr->mFocusCount - focus == 2 &&
25857:         mMgr->GetFocusedStore())) {
24823:     fail("TestFocus: document focus was not changed");
80486:     return false;
24823:   }
24823: 
24823:   rv = mButton->Focus();
24823:   if (!(NS_SUCCEEDED(rv) &&
25857:         !mMgr->mFocusedDocument &&
25857:         mMgr->mFocusCount - focus == 2 &&
25857:         !mMgr->GetFocusedStore())) {
25857:     fail("TestFocus: document focus was changed");
80486:     return false;
80486:   }
80486:   return true;
24823: }
24823: 
79445: bool
24823: TestApp::TestClustering(void)
24823: {
24823:   // Text for testing
24823:   const PRUint32 STRING_LENGTH = 2;
24823:   PRUnichar string[3];
24823:   string[0] = 'e';
24823:   string[1] = 0x0301; // U+0301 'acute accent'
24823:   string[2] = nsnull;
24823: 
25857:   if (!mMgr->GetFocusedStore()) {
25857:     fail("TestClustering: GetFocusedStore returns null #1");
80486:     return false;
25857:   }
25857: 
24823:   // Replace entire string with our string
24823:   TS_TEXTCHANGE textChange;
25857:   HRESULT hr =
25857:     mMgr->GetFocusedStore()->SetText(0, 0, -1, string, STRING_LENGTH,
24823:                                      &textChange);
24823:   if (!(SUCCEEDED(hr) &&
24823:         0 == textChange.acpStart &&
24823:         STRING_LENGTH == textChange.acpNewEnd)) {
24823:     fail("TestClustering: SetText");
80486:     return false;
24823:   }
24823: 
24823:   TsViewCookie view;
24823:   RECT rectLetter, rectAccent, rectWhole, rectCombined;
24823:   BOOL clipped, nonEmpty;
24823: 
25857:   if (!mMgr->GetFocusedStore()) {
25857:     fail("TestClustering: GetFocusedStore returns null #2");
80486:     return false;
25857:   }
25857: 
25857:   hr = mMgr->GetFocusedStore()->GetActiveView(&view);
24823:   if (!(SUCCEEDED(hr))) {
24823:     fail("TestClustering: GetActiveView");
80486:     return false;
24823:   }
24823: 
25857:   if (!mMgr->GetFocusedStore()) {
25857:     fail("TestClustering: GetFocusedStore returns null #3");
80486:     return false;
25857:   }
25857: 
24823:   // Get rect of first char (the letter)
25857:   hr = mMgr->GetFocusedStore()->GetTextExt(view, 0, STRING_LENGTH / 2,
24823:                                            &rectLetter, &clipped);
24823:   if (!(SUCCEEDED(hr))) {
24823:     fail("TestClustering: GetTextExt (letter)");
80486:     return false;
24823:   }
24823: 
25857:   if (!mMgr->GetFocusedStore()) {
25857:     fail("TestClustering: GetFocusedStore returns null #4");
80486:     return false;
25857:   }
25857: 
24823:   // Get rect of second char (the accent)
25857:   hr = mMgr->GetFocusedStore()->GetTextExt(view, STRING_LENGTH / 2,
25857:                                            STRING_LENGTH,
24823:                                            &rectAccent, &clipped);
24823:   if (!(SUCCEEDED(hr))) {
24823:     fail("TestClustering: GetTextExt (accent)");
80486:     return false;
24823:   }
24823: 
25857:   if (!mMgr->GetFocusedStore()) {
25857:     fail("TestClustering: GetFocusedStore returns null #5");
80486:     return false;
25857:   }
25857: 
24823:   // Get rect of combined char
25857:   hr = mMgr->GetFocusedStore()->GetTextExt(view, 0, STRING_LENGTH,
24823:                                            &rectWhole, &clipped);
24823:   if (!(SUCCEEDED(hr))) {
24823:     fail("TestClustering: GetTextExt (whole)");
80486:     return false;
24823:   }
24823: 
24823:   nonEmpty = ::UnionRect(&rectCombined, &rectLetter, &rectAccent);
24823:   if (!(nonEmpty &&
24823:         ::EqualRect(&rectCombined, &rectWhole))) {
24823:     fail("TestClustering: unexpected combined rect");
80486:     return false;
80486:   }
80486:   return true;
24823: }
24823: 
79445: bool
24823: TestApp::TestSelectionInternal(char* aTestName,
24823:                                LONG aStart,
24823:                                LONG aEnd,
24823:                                TsActiveSelEnd aSelEnd)
24823: {
79445:   bool succeeded = true, continueTest = true;
24823:   TS_SELECTION_ACP sel, testSel;
24823:   ULONG selFetched;
24823: 
25857:   if (!mMgr->GetFocusedStore()) {
25857:     fail("TestSelectionInternal: GetFocusedStore returns null #1");
80486:     return false;
25857:   }
25857: 
24823:   sel.acpStart = aStart;
24823:   sel.acpEnd = aEnd;
24823:   sel.style.ase = aSelEnd;
24823:   sel.style.fInterimChar = FALSE;
25857:   HRESULT hr = mMgr->GetFocusedStore()->SetSelection(1, &sel);
24823:   if (!(SUCCEEDED(hr))) {
24823:     fail("TestSelection: SetSelection (%s)", aTestName);
80486:     continueTest = succeeded = false;
24823:   }
24823: 
24823:   if (continueTest) {
25857:     if (!mMgr->GetFocusedStore()) {
25857:       fail("TestSelectionInternal: GetFocusedStore returns null #2");
80486:       return false;
25857:     }
25857: 
25857:     hr = mMgr->GetFocusedStore()->GetSelection(TS_DEFAULT_SELECTION, 1,
24823:                                                &testSel, &selFetched);
24823:     if (!(SUCCEEDED(hr) &&
24823:           selFetched == 1 &&
24823:           !memcmp(&sel, &testSel, sizeof(sel)))) {
24823:       fail("TestSelection: unexpected GetSelection result (%s)", aTestName);
80486:       succeeded = false;
24823:     }
24823:   }
24823:   return succeeded;
24823: }
24823: 
79445: bool
24823: TestApp::TestSelection(void)
24823: {
79445:   bool succeeded = true;
24823: 
24823:   /* If these fail the cause is probably one or more of:
24823:    * nsTextStore::GetSelection not sending NS_QUERY_SELECTED_TEXT
24823:    * NS_QUERY_SELECTED_TEXT not handled by nsContentEventHandler
24823:    * Bug in NS_QUERY_SELECTED_TEXT handler
24823:    * nsTextStore::SetSelection not sending NS_SELECTION_SET
24823:    * NS_SELECTION_SET not handled by nsContentEventHandler
24823:    * Bug in NS_SELECTION_SET handler
24823:    */
24823: 
24823:   TS_SELECTION_ACP testSel;
24823:   ULONG selFetched;
24823: 
25857:   if (!mMgr->GetFocusedStore()) {
25857:     fail("TestSelection: GetFocusedStore returns null");
80486:     return false;
25857:   }
25857: 
25857:   HRESULT hr =
25857:     mMgr->GetFocusedStore()->GetSelection(0, 1, &testSel, &selFetched);
24823:   if (!(SUCCEEDED(hr) &&
24823:         selFetched == 1)) {
24823:     fail("TestSelection: GetSelection");
80486:     succeeded = false;
24823:   }
24823: 
24823:   const LONG SELECTION1_START            = 0;
24823:   const LONG SELECTION1_END              = mTestString.Length();
24823:   const TsActiveSelEnd SELECTION1_SELEND = TS_AE_END;
24823: 
24823:   if (!TestSelectionInternal("normal",
24823:                              SELECTION1_START,
24823:                              SELECTION1_END,
24823:                              SELECTION1_SELEND)) {
80486:     succeeded = false;
24823:   }
24823: 
24823:   const LONG SELECTION2_START            = mTestString.Length() / 2;
24823:   const LONG SELECTION2_END              = SELECTION2_START;
24823:   const TsActiveSelEnd SELECTION2_SELEND = TS_AE_END;
24823: 
24823:   if (!TestSelectionInternal("collapsed",
24823:                              SELECTION2_START,
24823:                              SELECTION2_END,
24823:                              SELECTION2_SELEND)) {
80486:     succeeded = false;
24823:   }
24823: 
24823:   const LONG SELECTION3_START            = 12;
24823:   const LONG SELECTION3_END              = mTestString.Length() - 20;
24823:   const TsActiveSelEnd SELECTION3_SELEND = TS_AE_START;
24823: 
24823:   if (!TestSelectionInternal("reversed",
24823:                              SELECTION3_START,
24823:                              SELECTION3_END,
24823:                              SELECTION3_SELEND)) {
80486:     succeeded = false;
24823:   }
24823:   return succeeded;
24823: }
24823: 
79445: bool
24823: TestApp::TestText(void)
24823: {
24823:   const PRUint32 BUFFER_SIZE  = (0x100);
24823:   const PRUint32 RUNINFO_SIZE = (0x10);
24823: 
79445:   bool succeeded = true, continueTest;
24823:   PRUnichar buffer[BUFFER_SIZE];
24823:   TS_RUNINFO runInfo[RUNINFO_SIZE];
24823:   ULONG bufferRet, runInfoRet;
24823:   LONG acpRet, acpCurrent;
24823:   TS_TEXTCHANGE textChange;
24823:   HRESULT hr;
24823: 
24823:   /* If these fail the cause is probably one or more of:
24823:    * nsTextStore::GetText not sending NS_QUERY_TEXT_CONTENT
24823:    * NS_QUERY_TEXT_CONTENT not handled by nsContentEventHandler
24823:    * Bug in NS_QUERY_TEXT_CONTENT handler
24823:    * nsTextStore::SetText not calling SetSelection or InsertTextAtSelection
24823:    * Bug in SetSelection or InsertTextAtSelection
24823:    *  NS_SELECTION_SET bug or NS_COMPOSITION_* / NS_TEXT_TEXT bug
24823:    */
24823: 
25857:   if (!mMgr->GetFocusedStore()) {
25857:     fail("TestText: GetFocusedStore returns null #1");
80486:     return false;
25857:   }
25857: 
24823:   // Get all text
25857:   hr = mMgr->GetFocusedStore()->GetText(0, -1, buffer, BUFFER_SIZE, &bufferRet,
25857:                                         runInfo, RUNINFO_SIZE, &runInfoRet,
25857:                                         &acpRet);
24823:   if (!(SUCCEEDED(hr) &&
24823:         bufferRet <= mTestString.Length() &&
24823:         !wcsncmp(mTestString.get(), buffer, bufferRet) &&
24823:         acpRet == LONG(bufferRet) &&
24823:         runInfoRet > 0)) {
24823:     fail("TestText: GetText 1");
80486:     succeeded = false;
24823:   }
24823: 
24823: 
25857:   if (!mMgr->GetFocusedStore()) {
25857:     fail("TestText: GetFocusedStore returns null #2");
80486:     return false;
25857:   }
25857: 
24823:   // Get text from GETTEXT2_START to GETTEXT2_END
24823:   const PRUint32 GETTEXT2_START       = (18);
24823:   const PRUint32 GETTEXT2_END         = (mTestString.Length() - 16);
24823:   const PRUint32 GETTEXT2_BUFFER_SIZE = (0x10);
24823: 
25857:   hr = mMgr->GetFocusedStore()->GetText(GETTEXT2_START, GETTEXT2_END,
25857:                                         buffer, GETTEXT2_BUFFER_SIZE,
25857:                                         &bufferRet, runInfo, RUNINFO_SIZE,
25857:                                         &runInfoRet, &acpRet);
24823:   if (!(SUCCEEDED(hr) &&
24823:         bufferRet <= GETTEXT2_BUFFER_SIZE &&
24823:         !wcsncmp(mTestString.get() + GETTEXT2_START, buffer, bufferRet) &&
24823:         acpRet == LONG(bufferRet) + GETTEXT2_START &&
24823:         runInfoRet > 0)) {
24823:     fail("TestText: GetText 2");
80486:     succeeded = false;
24823:   }
24823: 
24823: 
25857:   if (!mMgr->GetFocusedStore()) {
25857:     fail("TestText: GetFocusedStore returns null #3");
80486:     return false;
25857:   }
25857: 
24823:   // Replace text from SETTEXT1_START to SETTEXT1_END with insertString
24823:   const PRUint32 SETTEXT1_START        = (8);
24823:   const PRUint32 SETTEXT1_TAIL_LENGTH  = (40);
24823:   const PRUint32 SETTEXT1_END          = (mTestString.Length() -
24823:                                           SETTEXT1_TAIL_LENGTH);
24823:   NS_NAMED_LITERAL_STRING(insertString, "(Inserted string)");
24823: 
80486:   continueTest = true;
25857:   hr = mMgr->GetFocusedStore()->SetText(0, SETTEXT1_START, SETTEXT1_END,
25857:                                         insertString.get(),
25857:                                         insertString.Length(), &textChange);
24823:   if (!(SUCCEEDED(hr) &&
24823:         textChange.acpStart == SETTEXT1_START &&
24823:         textChange.acpOldEnd == LONG(SETTEXT1_END) &&
24823:         textChange.acpNewEnd == LONG(SETTEXT1_START +
24823:                                 insertString.Length()))) {
24823:     fail("TestText: SetText 1");
80486:     continueTest = succeeded = false;
24823:   }
24823: 
24823:   const PRUint32 SETTEXT1_FINAL_LENGTH = (SETTEXT1_START +
24823:                                           SETTEXT1_TAIL_LENGTH +
24823:                                           insertString.Length());
24823: 
24823:   if (continueTest) {
24823:     acpCurrent = 0;
24823:     while (acpCurrent < LONG(SETTEXT1_FINAL_LENGTH)) {
25857:       if (!mMgr->GetFocusedStore()) {
25857:         fail("TestText: GetFocusedStore returns null #4");
80486:         return false;
25857:       }
25857: 
25857:       hr = mMgr->GetFocusedStore()->GetText(acpCurrent, -1, &buffer[acpCurrent],
24823:                                             BUFFER_SIZE, &bufferRet, runInfo,
24823:                                             RUNINFO_SIZE, &runInfoRet, &acpRet);
24823:       if (!(SUCCEEDED(hr) &&
24823:             acpRet > acpCurrent &&
24823:             bufferRet <= SETTEXT1_FINAL_LENGTH &&
24823:             runInfoRet > 0)) {
24823:         fail("TestText: GetText failed after SetTest 1");
80486:         continueTest = succeeded = false;
24823:         break;
24823:       }
24823:       acpCurrent = acpRet;
24823:     }
24823:   }
24823: 
24823:   if (continueTest) {
24823:     if (!(acpCurrent == LONG(SETTEXT1_FINAL_LENGTH) &&
24823:           !wcsncmp(buffer, mTestString.get(), SETTEXT1_START) &&
24823:           !wcsncmp(&buffer[SETTEXT1_START], insertString.get(),
24823:                    insertString.Length()) &&
24823:           !wcsncmp(&buffer[SETTEXT1_START + insertString.Length()],
24823:                    mTestString.get() + SETTEXT1_END, SETTEXT1_TAIL_LENGTH))) {
24823:       fail("TestText: unexpected GetText result after SetText 1");
80486:       succeeded = false;
24823:     }
24823:   }
24823: 
24823: 
25857:   if (!mMgr->GetFocusedStore()) {
25857:     fail("TestText: GetFocusedStore returns null #5");
80486:     return false;
25857:   }
25857: 
24823:   // Restore entire text to original text (mTestString)
80486:   continueTest = true;
25857:   hr = mMgr->GetFocusedStore()->SetText(0, 0, -1, mTestString.get(),
24823:                                         mTestString.Length(), &textChange);
24823:   if (!(SUCCEEDED(hr) &&
24823:         textChange.acpStart == 0 &&
24823:         textChange.acpOldEnd == LONG(SETTEXT1_FINAL_LENGTH) &&
24823:         textChange.acpNewEnd == LONG(mTestString.Length()))) {
24823:     fail("TestText: SetText 2");
80486:     continueTest = succeeded = false;
24823:   }
24823: 
24823:   if (continueTest) {
24823:     acpCurrent = 0;
24823:     while (acpCurrent < LONG(mTestString.Length())) {
25857:       if (!mMgr->GetFocusedStore()) {
25857:         fail("TestText: GetFocusedStore returns null #6");
80486:         return false;
25857:       }
25857: 
25857:       hr = mMgr->GetFocusedStore()->GetText(acpCurrent, -1, &buffer[acpCurrent],
25857:                                             BUFFER_SIZE, &bufferRet, runInfo,
25857:                                             RUNINFO_SIZE, &runInfoRet, &acpRet);
24823:       if (!(SUCCEEDED(hr) &&
24823:             acpRet > acpCurrent &&
24823:             bufferRet <= mTestString.Length() &&
24823:             runInfoRet > 0)) {
24823:         fail("TestText: GetText failed after SetText 2");
80486:         continueTest = succeeded = false;
24823:         break;
24823:       }
24823:       acpCurrent = acpRet;
24823:     }
24823:   }
24823: 
24823:   if (continueTest) {
24823:     if (!(acpCurrent == LONG(mTestString.Length()) &&
24823:           !wcsncmp(buffer, mTestString.get(), mTestString.Length()))) {
24823:       fail("TestText: unexpected GetText result after SetText 2");
80486:       succeeded = false;
24823:     }
24823:   }
24823:   return succeeded;
24823: }
24823: 
79445: bool
24823: TestApp::TestExtents(void)
24823: {
25857:   if (!mMgr->GetFocusedStore()) {
25857:     fail("TestExtents: GetFocusedStore returns null #1");
80486:     return false;
25857:   }
25857: 
24823:   TS_SELECTION_ACP sel;
24823:   sel.acpStart = 0;
24823:   sel.acpEnd = 0;
24823:   sel.style.ase = TS_AE_END;
24823:   sel.style.fInterimChar = FALSE;
25857:   mMgr->GetFocusedStore()->SetSelection(1, &sel);
24823: 
24823:   nsCOMPtr<nsISelectionController> selCon;
24823:   if (!(NS_SUCCEEDED(GetSelCon(getter_AddRefs(selCon))) && selCon)) {
24823:     fail("TestExtents: get nsISelectionController");
80486:     return false;
24823:   }
24823:   selCon->ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL,
80486:               nsISelectionController::SELECTION_FOCUS_REGION, true);
24823: 
73870:   nsCOMPtr<nsIDOMWindow> window(do_GetInterface(mWindow));
24823:   if (!window) {
73870:     fail("TestExtents: get nsIDOMWindow");
80486:     return false;
24823:   }
24823:   RECT windowRect, screenRect, textRect1, textRect2;
24823:   BOOL clipped;
24823:   PRInt32 val;
24823:   TsViewCookie view;
24823:   HRESULT hr;
24823: 
24823:   nsresult nsr = window->GetScreenX(&val);
24823:   windowRect.left = val;
24823:   nsr |= window->GetScreenY(&val);
24823:   windowRect.top = val;
24823:   nsr |= window->GetOuterWidth(&val);
24823:   windowRect.right = windowRect.left + val;
24823:   nsr |= window->GetOuterHeight(&val);
24823:   windowRect.bottom = windowRect.top + val;
24823:   if (!(NS_SUCCEEDED(nsr))) {
24823:     fail("TestExtents: get window rect failed");
80486:     return false;
24823:   }
24823: 
25857:   if (!mMgr->GetFocusedStore()) {
25857:     fail("TestExtents: GetFocusedStore returns null #2");
80486:     return false;
25857:   }
25857: 
25857:   hr = mMgr->GetFocusedStore()->GetActiveView(&view);
24823:   if (!(SUCCEEDED(hr))) {
24823:     fail("TestExtents: GetActiveView");
80486:     return false;
24823:   }
24823: 
25857:   if (!mMgr->GetFocusedStore()) {
25857:     fail("TestExtents: GetFocusedStore returns null #3");
80486:     return false;
25857:   }
25857: 
79445:   bool succeeded = true;
24823:   HWND hwnd;
25857:   hr = mMgr->GetFocusedStore()->GetWnd(view, &hwnd);
24823:   if (!(SUCCEEDED(hr) &&
24823:         ::IsWindow(hwnd))) {
24823:     fail("TestExtents: GetWnd");
80486:     succeeded = false;
24823:   }
24823: 
24823:   ::SetRectEmpty(&screenRect);
25857: 
25857:   if (!mMgr->GetFocusedStore()) {
25857:     fail("TestExtents: GetFocusedStore returns null #4");
80486:     return false;
25857:   }
25857: 
25857:   hr = mMgr->GetFocusedStore()->GetScreenExt(view, &screenRect);
24823:   if (!(SUCCEEDED(hr) &&
24823:         screenRect.left > windowRect.left &&
24823:         screenRect.top > windowRect.top &&
24823:         screenRect.right > screenRect.left &&
24823:         screenRect.bottom > screenRect.top &&
24823:         screenRect.right < windowRect.right &&
24823:         screenRect.bottom < windowRect.bottom)) {
24823:     fail("TestExtents: GetScreenExt");
80486:     succeeded = false;
24823:   }
24823: 
24823:   const LONG GETTEXTEXT1_START = 0;
24823:   const LONG GETTEXTEXT1_END   = 0;
24823: 
24823:   ::SetRectEmpty(&textRect1);
25857: 
25857:   if (!mMgr->GetFocusedStore()) {
25857:     fail("TestExtents: GetFocusedStore returns null #5");
80486:     return false;
25857:   }
25857: 
25857:   hr = mMgr->GetFocusedStore()->GetTextExt(view, GETTEXTEXT1_START,
25857:                                            GETTEXTEXT1_END, &textRect1,
25857:                                            &clipped);
24823:   if (!(SUCCEEDED(hr) &&
24823:         textRect1.left >= screenRect.left &&
24823:         textRect1.top >= screenRect.top &&
24823:         textRect1.right < screenRect.right &&
24823:         textRect1.bottom <= screenRect.bottom &&
24823:         textRect1.right >= textRect1.left &&
24823:         textRect1.bottom > textRect1.top)) {
24823:     fail("TestExtents: GetTextExt (offset %ld to %ld)",
24823:          GETTEXTEXT1_START, GETTEXTEXT1_END);
80486:     succeeded = false;
24823:   }
24823: 
24823:   const LONG GETTEXTEXT2_START = 10;
24823:   const LONG GETTEXTEXT2_END   = 25;
24823: 
24823:   ::SetRectEmpty(&textRect2);
25857: 
25857:   if (!mMgr->GetFocusedStore()) {
25857:     fail("TestExtents: GetFocusedStore returns null #6");
80486:     return false;
25857:   }
25857: 
25857:   hr = mMgr->GetFocusedStore()->GetTextExt(view, GETTEXTEXT2_START,
25857:                                            GETTEXTEXT2_END, &textRect2,
25857:                                            &clipped);
24823:   if (!(SUCCEEDED(hr) &&
24823:         textRect2.left >= screenRect.left &&
24823:         textRect2.top >= screenRect.top &&
24823:         textRect2.right <= screenRect.right &&
24823:         textRect2.bottom <= screenRect.bottom &&
24823:         textRect2.right > textRect2.left &&
24823:         textRect2.bottom > textRect2.top)) {
24823:     fail("TestExtents: GetTextExt (offset %ld to %ld)",
24823:          GETTEXTEXT2_START, GETTEXTEXT2_END);
80486:     succeeded = false;
24823:   }
24823: 
24823:   // Offsets must be between GETTEXTEXT2_START and GETTEXTEXT2_END
24823:   const LONG GETTEXTEXT3_START = 23;
24823:   const LONG GETTEXTEXT3_END   = 23;
24823: 
24823:   ::SetRectEmpty(&textRect1);
25857: 
25857:   if (!mMgr->GetFocusedStore()) {
25857:     fail("TestExtents: GetFocusedStore returns null #7");
80486:     return false;
25857:   }
25857: 
25857:   hr = mMgr->GetFocusedStore()->GetTextExt(view, GETTEXTEXT3_START,
25857:                                            GETTEXTEXT3_END, &textRect1,
25857:                                            &clipped);
24823:   // Rectangle must be entirely inside the previous rectangle,
24823:   // since GETTEXTEXT3_START and GETTEXTEXT3_END are between
24823:   // GETTEXTEXT2_START and GETTEXTEXT2_START
24823:   if (!(SUCCEEDED(hr) && ::IsRectEmpty(&textRect1) ||
24823:         (textRect1.left >= textRect2.left &&
24823:         textRect1.top >= textRect2.top &&
24823:         textRect1.right <= textRect2.right &&
24823:         textRect1.bottom <= textRect2.bottom &&
24823:         textRect1.right >= textRect1.left &&
24823:         textRect1.bottom > textRect1.top))) {
24823:     fail("TestExtents: GetTextExt (offset %ld to %ld)",
24823:          GETTEXTEXT3_START, GETTEXTEXT3_END);
80486:     succeeded = false;
24823:   }
24823:   return succeeded;
24823: }
24823: 
79445: bool
24823: TestApp::TestCompositionSelectionAndText(char* aTestName,
24823:                                          LONG aExpectedSelStart,
24823:                                          LONG aExpectedSelEnd,
24823:                                          nsString& aReferenceString)
24823: {
25857:   if (!mMgr->GetFocusedStore()) {
25857:     fail("TestCompositionSelectionAndText: GetFocusedStore returns null #1");
80486:     return false;
25857:   }
25857: 
24823:   TS_SELECTION_ACP currentSel;
24823:   ULONG selFetched = 0;
25857:   HRESULT hr = mMgr->GetFocusedStore()->GetSelection(TF_DEFAULT_SELECTION, 1,
24823:                                                      &currentSel, &selFetched);
24823:   if (!(SUCCEEDED(hr) &&
24823:         1 == selFetched &&
24823:         currentSel.acpStart == aExpectedSelStart &&
24823:         currentSel.acpEnd == aExpectedSelEnd)) {
24823:     fail("TestComposition: GetSelection (%s)", aTestName);
80486:     return false;
24823:   }
24823: 
24823:   const PRUint32 bufferSize = 0x100, runInfoSize = 0x10;
24823:   PRUnichar buffer[bufferSize];
24823:   TS_RUNINFO runInfo[runInfoSize];
24823:   ULONG bufferRet, runInfoRet;
24823:   LONG acpRet, acpCurrent = 0;
24823:   while (acpCurrent < LONG(aReferenceString.Length())) {
25857:     if (!mMgr->GetFocusedStore()) {
25857:       fail("TestCompositionSelectionAndText: GetFocusedStore returns null #2");
80486:       return false;
25857:     }
25857: 
25857:     hr = mMgr->GetFocusedStore()->GetText(acpCurrent, aReferenceString.Length(),
25857:                                           &buffer[acpCurrent], bufferSize,
25857:                                           &bufferRet, runInfo, runInfoSize,
24823:                                           &runInfoRet, &acpRet);
24823:     if (!(SUCCEEDED(hr) &&
24823:           acpRet > acpCurrent &&
24823:           bufferRet <= aReferenceString.Length() &&
24823:           runInfoRet > 0)) {
24823:       fail("TestComposition: GetText (%s)", aTestName);
80486:       return false;
24823:     }
24823:     acpCurrent = acpRet;
24823:   }
24823:   if (!(acpCurrent == aReferenceString.Length() &&
24823:         !wcsncmp(buffer, aReferenceString.get(), aReferenceString.Length()))) {
24823:     fail("TestComposition: unexpected GetText result (%s)", aTestName);
80486:     return false;
80486:   }
80486:   return true;
24823: }
24823: 
79445: bool
24823: TestApp::TestComposition(void)
24823: {
25857:   if (!mMgr->GetFocusedStore()) {
25857:     fail("TestComposition: GetFocusedStore returns null #1");
80486:     return false;
25857:   }
25857: 
24823:   nsRefPtr<ITfContextOwnerCompositionSink> sink;
25857:   HRESULT hr =
25857:     mMgr->GetFocusedStore()->QueryInterface(IID_ITfContextOwnerCompositionSink,
24823:                                             getter_AddRefs(sink));
24823:   if (!(SUCCEEDED(hr))) {
24823:     fail("TestComposition: QueryInterface");
80486:     return false;
24823:   }
24823: 
24823:   const LONG PRECOMPOSITION_SEL_START            = 2;
24823:   const LONG PRECOMPOSITION_SEL_END              = PRECOMPOSITION_SEL_START;
24823:   const TsActiveSelEnd PRECOMPOSITION_SEL_SELEND = TS_AE_END;
24823: 
24823:   TS_SELECTION_ACP sel;
24823:   sel.acpStart = PRECOMPOSITION_SEL_START;
24823:   sel.acpEnd = PRECOMPOSITION_SEL_END;
24823:   sel.style.ase = PRECOMPOSITION_SEL_SELEND;
24823:   sel.style.fInterimChar = FALSE;
25857:   hr = mMgr->GetFocusedStore()->SetSelection(1, &sel);
24823:   if (!(SUCCEEDED(hr))) {
24823:     fail("TestComposition: SetSelection (pre-composition)");
80486:     return false;
24823:   }
24823: 
25857:   if (!mMgr->GetFocusedStore()) {
25857:     fail("TestComposition: GetFocusedStore returns null #2");
80486:     return false;
25857:   }
24823: 
24823:   TS_TEXTCHANGE textChange;
24823:   NS_NAMED_LITERAL_STRING(insertString1, "Compo1");
25857:   hr = mMgr->GetFocusedStore()->InsertTextAtSelection(TF_IAS_NOQUERY,
24823:                                                       insertString1.get(),
24823:                                                       insertString1.Length(),
24823:                                                       NULL, NULL, &textChange);
24823:   if (!(SUCCEEDED(hr) &&
24823:         sel.acpEnd == textChange.acpStart &&
24823:         sel.acpEnd == textChange.acpOldEnd &&
24823:         sel.acpEnd + insertString1.Length() == textChange.acpNewEnd)) {
24823:     fail("TestComposition: InsertTextAtSelection");
80486:     return false;
24823:   }
24823:   sel.acpEnd = textChange.acpNewEnd;
24823: 
25857:   if (!mMgr->GetFocusedAttrProp()) {
25857:     fail("TestComposition: GetFocusedAttrProp returns null #1");
80486:     return false;
25857:   }
25857:   mMgr->GetFocusedAttrProp()->mRanges.Clear();
25395:   nsRefPtr<TSFRangeImpl> range =
25395:     new TSFRangeImpl(textChange.acpStart,
25395:                      textChange.acpNewEnd - textChange.acpOldEnd);
25857:   if (!mMgr->GetFocusedAttrProp()) {
25857:     fail("TestComposition: GetFocusedAttrProp returns null #2");
80486:     return false;
25857:   }
25857:   mMgr->GetFocusedAttrProp()->mRanges.AppendElement(range);
25395: 
24823:   BOOL okay = FALSE;
25857:   hr = sink->OnStartComposition(mMgr->GetFocusedContext(), &okay);
24823:   if (!(SUCCEEDED(hr) &&
24823:         okay)) {
24823:     fail("TestComposition: OnStartComposition");
80486:     return false;
24823:   }
24823: 
24823: 
25857:   if (!mMgr->GetFocusedStore()) {
25857:     fail("TestComposition: GetFocusedStore returns null #3");
80486:     return false;
25857:   }
25857: 
24823:   NS_NAMED_LITERAL_STRING(insertString2, "Composition2");
25857:   hr = mMgr->GetFocusedStore()->SetText(0, range->mStart + range->mLength,
25395:                                         range->mStart + range->mLength,
25857:                                         insertString2.get(),
25857:                                         insertString2.Length(),
24823:                                         &textChange);
24823:   if (!(SUCCEEDED(hr) &&
24823:         sel.acpEnd == textChange.acpStart &&
24823:         sel.acpEnd == textChange.acpOldEnd &&
24823:         sel.acpEnd + insertString2.Length() == textChange.acpNewEnd)) {
24823:     fail("TestComposition: SetText 1");
80486:     return false;
24823:   }
24823:   sel.acpEnd = textChange.acpNewEnd;
25395:   range->mLength += textChange.acpNewEnd - textChange.acpOldEnd;
24823: 
24823: 
25857:   if (!mMgr->GetFocusedStore()) {
25857:     fail("TestComposition: GetFocusedStore returns null #4");
80486:     return false;
25857:   }
25857: 
24823:   const LONG COMPOSITION3_TEXT_START_OFFSET = -8; // offset 8 from the end
24823:   const LONG COMPOSITION3_TEXT_END_OFFSET   = 4;
24823: 
25395:   const LONG COMPOSITION3_TEXT_START = range->mStart + range->mLength +
24823:                                        COMPOSITION3_TEXT_START_OFFSET;
24823:   const LONG COMPOSITION3_TEXT_END   = COMPOSITION3_TEXT_START +
24823:                                        COMPOSITION3_TEXT_END_OFFSET;
24823: 
24823:   NS_NAMED_LITERAL_STRING(insertString3, "Compo3");
25857:   hr = mMgr->GetFocusedStore()->SetText(0, COMPOSITION3_TEXT_START,
24823:                                         COMPOSITION3_TEXT_END,
25857:                                         insertString3.get(),
25857:                                         insertString3.Length(),
24823:                                         &textChange);
24823:   if (!(SUCCEEDED(hr) &&
24823:         sel.acpEnd + COMPOSITION3_TEXT_START_OFFSET == textChange.acpStart &&
24823:         sel.acpEnd + COMPOSITION3_TEXT_START_OFFSET +
24823:             COMPOSITION3_TEXT_END_OFFSET == textChange.acpOldEnd &&
24823:         sel.acpEnd + insertString3.Length() + COMPOSITION3_TEXT_START_OFFSET ==
24823:             textChange.acpNewEnd)) {
24823:     fail("TestComposition: SetText 2");
80486:     return false;
24823:   }
24823:   sel.acpEnd = textChange.acpNewEnd;
25395:   range->mLength += textChange.acpNewEnd - textChange.acpOldEnd;
24823: 
24823: 
24823:   nsString referenceString;
24823:   referenceString.Append(mTestString.get(), sel.acpStart);
24823:   referenceString.Append(insertString1);
24823:   referenceString.Append(insertString2.get(),
24823:       insertString2.Length() + COMPOSITION3_TEXT_START_OFFSET);
24823:   referenceString.Append(insertString3);
24823:   referenceString.Append(insertString2.get() + insertString2.Length() -
24823:       COMPOSITION3_TEXT_END_OFFSET, COMPOSITION3_TEXT_END_OFFSET);
24823:   referenceString.Append(mTestString.get() + sel.acpStart,
24823:       COMPOSITION3_TEXT_END_OFFSET);
24823: 
24823:   if (!TestCompositionSelectionAndText("composition",
24823:            sel.acpEnd, sel.acpEnd,
24823:            referenceString))
80486:     return false;
24823: 
24823: 
25857:   if (!mMgr->GetFocusedStore()) {
25857:     fail("TestComposition: GetFocusedStore returns null #5");
80486:     return false;
25857:   }
25857: 
24823:   const LONG POSTCOMPOSITION_SEL_START = sel.acpEnd - 8;
24823:   const LONG POSTCOMPOSITION_SEL_END   = POSTCOMPOSITION_SEL_START + 2;
24823: 
24823:   sel.acpStart = POSTCOMPOSITION_SEL_START;
24823:   sel.acpEnd = POSTCOMPOSITION_SEL_END;
25857:   hr = mMgr->GetFocusedStore()->SetSelection(1, &sel);
24823:   if (!(SUCCEEDED(hr))) {
24823:     fail("TestComposition: SetSelection (composition)");
80486:     return false;
24823:   }
24823: 
25857:   if (!mMgr->GetFocusedAttrProp()) {
25857:     fail("TestComposition: GetFocusedAttrProp returns null #3");
80486:     return false;
25857:   }
25857:   mMgr->GetFocusedAttrProp()->mRanges.Clear();
25857: 
25857:   hr = sink->OnEndComposition(mMgr->GetFocusedContext());
24823:   if (!(SUCCEEDED(hr))) {
24823:     fail("TestComposition: OnEndComposition");
80486:     return false;
24823:   }
24823: 
24823:   if (!TestCompositionSelectionAndText("post-composition",
24823:            sel.acpStart, sel.acpEnd,
24823:            referenceString))
80486:     return false;
24823: 
25395:   const LONG EMPTYCOMPOSITION_START  = range->mStart + 2;
25395:   const LONG EMPTYCOMPOSITION_LENGTH = range->mLength - 4;
24823: 
25395:   range->mStart = EMPTYCOMPOSITION_START;
25395:   range->mLength = EMPTYCOMPOSITION_LENGTH;
25857:   if (!mMgr->GetFocusedAttrProp()) {
25857:     fail("TestComposition: GetFocusedAttrProp returns null #4");
80486:     return false;
25857:   }
25857:   mMgr->GetFocusedAttrProp()->mRanges.AppendElement(range);
24823: 
24823:   okay = FALSE;
25857:   hr = sink->OnStartComposition(mMgr->GetFocusedContext(), &okay);
24823:   if (!(SUCCEEDED(hr) &&
24823:         okay)) {
24823:     fail("TestComposition: OnStartComposition (empty composition)");
80486:     return false;
24823:   }
24823: 
25857:   if (!mMgr->GetFocusedAttrProp()) {
25857:     fail("TestComposition: GetFocusedAttrProp returns null #5");
80486:     return false;
25857:   }
25857:   mMgr->GetFocusedAttrProp()->mRanges.Clear();
25857: 
25857:   hr = sink->OnEndComposition(mMgr->GetFocusedContext());
24823:   if (!(SUCCEEDED(hr))) {
24823:     fail("TestComposition: OnEndComposition (empty composition)");
80486:     return false;
24823:   }
24823: 
24823:   if (!TestCompositionSelectionAndText("empty composition",
25395:            range->mStart, range->mStart + range->mLength,
24823:            referenceString))
80486:     return false;
80486: 
80486:   return true;
24823: }
24823: 
79445: bool
24823: TestApp::TestNotificationTextChange(nsIWidget* aWidget,
24823:                                     PRUint32 aCode,
24823:                                     const nsAString& aCharacter,
24823:                                     LONG aStart,
24823:                                     LONG aOldEnd,
24823:                                     LONG aNewEnd)
24823: {
24823:   MSG msg;
24823:   if (::PeekMessageW(&msg, NULL, WM_USER_TSF_TEXTCHANGE,
24823:                      WM_USER_TSF_TEXTCHANGE, PM_REMOVE))
24823:     ::DispatchMessageW(&msg);
25857:   if (!mMgr->GetFocusedContext()) {
25857:     fail("TestNotificationTextChange: GetFocusedContext returns null");
80486:     return false;
80486:   }
80486:   mMgr->GetFocusedContext()->mTextChanged = false;
24823:   nsresult nsr = aWidget->SynthesizeNativeKeyEvent(0, aCode, 0,
24823:                               aCharacter, aCharacter);
24823:   if (::PeekMessageW(&msg, NULL, WM_USER_TSF_TEXTCHANGE,
24823:                      WM_USER_TSF_TEXTCHANGE, PM_REMOVE))
24823:     ::DispatchMessageW(&msg);
24823:   return NS_SUCCEEDED(nsr) &&
25857:          mMgr->GetFocusedContext()->mTextChanged &&
25857:          aStart == mMgr->GetFocusedContext()->mTextChangeData.acpStart &&
25857:          aOldEnd == mMgr->GetFocusedContext()->mTextChangeData.acpOldEnd &&
25857:          aNewEnd == mMgr->GetFocusedContext()->mTextChangeData.acpNewEnd;
24823: }
24823: 
79445: bool
24823: TestApp::TestNotification(void)
24823: {
24823:   nsresult nsr;
24823:   // get selection to test notification support
24823:   nsCOMPtr<nsISelectionController> selCon;
24823:   if (!(NS_SUCCEEDED(GetSelCon(getter_AddRefs(selCon))) && selCon)) {
24823:     fail("TestNotification: get nsISelectionController");
80486:     return false;
80486:   }
80486: 
80486:   nsr = selCon->CompleteMove(false, false);
24823:   if (!(NS_SUCCEEDED(nsr))) {
24823:     fail("TestNotification: CompleteMove");
80486:     return false;
24823:   }
24823: 
25857:   if (!mMgr->GetFocusedContext()) {
25857:     fail("TestNotification: GetFocusedContext returns null #1");
80486:     return false;
80486:   }
80486: 
80486:   mMgr->GetFocusedContext()->mSelChanged = false;
80486:   nsr = selCon->CharacterMove(true, false);
24823:   if (!(NS_SUCCEEDED(nsr) &&
25857:         mMgr->GetFocusedContext()->mSelChanged)) {
24823:     fail("TestNotification: CharacterMove");
80486:     return false;
24823:   }
24823: 
25857:   if (!mMgr->GetFocusedContext()) {
25857:     fail("TestNotification: GetFocusedContext returns null #2");
80486:     return false;
80486:   }
80486: 
80486:   mMgr->GetFocusedContext()->mSelChanged = false;
80486:   nsr = selCon->CharacterMove(true, true);
24823:   if (!(NS_SUCCEEDED(nsr) &&
25857:         mMgr->GetFocusedContext()->mSelChanged)) {
24823:     fail("TestNotification: CharacterMove (extend)");
80486:     return false;
24823:   }
24823: 
24823:   nsCOMPtr<nsIWidget> widget;
31218:   if (!GetWidget(getter_AddRefs(widget))) {
24823:     fail("TestNotification: get nsIWidget");
80486:     return false;
24823:   }
24823: 
24823:   NS_NAMED_LITERAL_STRING(character, "");
24823:   NS_NAMED_LITERAL_STRING(characterA, "A");
24823: 
24823:   // The selection test code above placed the selection at offset 1 to 2
24823:   const LONG TEXTCHANGE1_START  = 1;
24823:   const LONG TEXTCHANGE1_OLDEND = 2;
24823:   const LONG TEXTCHANGE1_NEWEND = 2;
24823: 
24823:   // replace single selected character with 'A'
24823:   if (!TestNotificationTextChange(widget, 'A', characterA,
24823:         TEXTCHANGE1_START, TEXTCHANGE1_OLDEND, TEXTCHANGE1_NEWEND)) {
24823:     fail("TestNotification: text change 1");
80486:     return false;
24823:   }
24823: 
24823:   const LONG TEXTCHANGE2_START  = TEXTCHANGE1_NEWEND;
24823:   const LONG TEXTCHANGE2_OLDEND = TEXTCHANGE1_NEWEND;
24823:   const LONG TEXTCHANGE2_NEWEND = TEXTCHANGE1_NEWEND + 1;
24823: 
24823:   // insert 'A'
24823:   if (!TestNotificationTextChange(widget, 'A', characterA,
24823:         TEXTCHANGE2_START, TEXTCHANGE2_OLDEND, TEXTCHANGE2_NEWEND)) {
24823:     fail("TestNotification: text change 2");
80486:     return false;
24823:   }
24823: 
24823:   const LONG TEXTCHANGE3_START  = TEXTCHANGE2_NEWEND - 1;
24823:   const LONG TEXTCHANGE3_OLDEND = TEXTCHANGE2_NEWEND;
24823:   const LONG TEXTCHANGE3_NEWEND = TEXTCHANGE2_NEWEND - 1;
24823: 
24823:   // backspace
24823:   if (!TestNotificationTextChange(widget, '\b', character,
24823:         TEXTCHANGE3_START, TEXTCHANGE3_OLDEND, TEXTCHANGE3_NEWEND)) {
24823:     fail("TestNotification: text change 3");
80486:     return false;
80486:   }
80486:   return true;
24823: }
24823: 
79445: bool
31218: TestApp::TestEditMessages(void)
31218: {
31218:   mTestString = NS_LITERAL_STRING(
31218:     "This is a test of\nthe native editing command messages");
31218:   // 0123456789012345678901 2345678901234567890123456789012
31218:   // 0         1         2          3         4         5
31218: 
31218:   // The native text string is increased by converting \n to \r\n.
31218:   PRUint32 testStringLength = mTestString.Length() + 1;
31218: 
31218:   mTextArea->SetValue(mTestString);
31218:   mTextArea->Focus();
31218: 
31218:   nsCOMPtr<nsIWidget> widget;
31218:   if (!GetWidget(getter_AddRefs(widget))) {
31218:     fail("TestEditMessages: get nsIWidget");
80486:     return false;
31218:   }
31218: 
31218:   HWND wnd = (HWND)widget->GetNativeData(NS_NATIVE_WINDOW);
79445:   bool result = true;
31218: 
31218:   if (!::SendMessage(wnd, EM_CANUNDO, 0, 0)) {
31218:     fail("TestEditMessages: EM_CANUNDO");
80486:     return false;
31218:   }
31218: 
31218:   if (::SendMessage(wnd, EM_CANREDO, 0, 0)) {
31218:     fail("TestEditMessages: EM_CANREDO #1");
80486:     return false;
31218:   }
31218: 
31218: 
31218:   if (!::SendMessage(wnd, EM_UNDO, 0, 0)) {
31218:     fail("TestEditMessages: EM_UNDO #1");
80486:     return false;
31218:   }
31218: 
31218:   nsAutoString str;
31218:   mTextArea->GetValue(str);
31218:   if (str == mTestString) {
31218:     fail("TestEditMessage: EM_UNDO #1, failed to execute");
31218:     printf("Current Str: \"%s\"\n", NS_ConvertUTF16toUTF8(str).get());
80486:     return false;
31218:   }
31218: 
31218:   if (!::SendMessage(wnd, EM_CANREDO, 0, 0)) {
31218:     fail("TestEditMessages: EM_CANREDO #2");
80486:     return false;
31218:   }
31218: 
31218:   if (!::SendMessage(wnd, EM_REDO, 0, 0)) {
31218:     fail("TestEditMessages: EM_REDO #1");
80486:     return false;
31218:   }
31218: 
31218:   mTextArea->GetValue(str);
31218:   if (str != mTestString) {
31218:     fail("TestEditMessage: EM_REDO #1, failed to execute");
31218:     printf("Current Str: \"%s\"\n", NS_ConvertUTF16toUTF8(str).get());
80486:     return false;
31218:   }
31218: 
31218:   TS_SELECTION_ACP sel;
31218:   HRESULT hr;
31218: 
31218:   sel.acpStart = 0;
31218:   sel.acpEnd = testStringLength;
31218:   sel.style.ase = TS_AE_END;
31218:   sel.style.fInterimChar = FALSE;
31218:   hr = mMgr->GetFocusedStore()->SetSelection(1, &sel);
31218:   if (!(SUCCEEDED(hr))) {
31218:     fail("TestEditMessages: SetSelection #1");
80486:     return false;
31218:   }
31218: 
31218:   ::SendMessage(wnd, WM_CUT, 0, 0);
31218:   mTextArea->GetValue(str);
31218:   if (!str.IsEmpty()) {
31218:     fail("TestEditMessages: WM_CUT");
31218:     printf("Current Str: \"%s\"\n", NS_ConvertUTF16toUTF8(str).get());
80486:     return false;
31218:   }
31218: 
31218:   ::SendMessage(wnd, WM_PASTE, 0, 0);
31218:   mTextArea->GetValue(str);
31218:   if (str != mTestString) {
31218:     fail("TestEditMessages: WM_PASTE #1");
31218:     printf("Current Str: \"%s\"\n", NS_ConvertUTF16toUTF8(str).get());
80486:     return false;
31218:   }
31218: 
31218:   ::SendMessage(wnd, WM_PASTE, 0, 0);
31218:   mTextArea->GetValue(str);
31218:   nsAutoString expectedStr(mTestString);
31218:   expectedStr += mTestString;
31218:   if (str != expectedStr) {
31218:     fail("TestEditMessages: WM_PASTE #2");
31218:     printf("Current Str: \"%s\"\n", NS_ConvertUTF16toUTF8(str).get());
80486:     return false;
31218:   }
31218: 
31218:   sel.acpStart = 0;
31218:   sel.acpEnd = testStringLength;
31218:   hr = mMgr->GetFocusedStore()->SetSelection(1, &sel);
31218:   if (!(SUCCEEDED(hr))) {
31218:     fail("TestEditMessages: SetSelection #2");
80486:     return false;
31218:   }
31218: 
31218:   ::SendMessage(wnd, WM_CLEAR, 0, 0);
31218:   mTextArea->GetValue(str);
31218:   if (str != mTestString) {
31218:     fail("TestEditMessages: WM_CLEAR #1");
31218:     printf("Current Str: \"%s\"\n", NS_ConvertUTF16toUTF8(str).get());
80486:     return false;
31218:   }
31218: 
31218:   sel.acpStart = 4;
31218:   sel.acpEnd = testStringLength;
31218:   hr = mMgr->GetFocusedStore()->SetSelection(1, &sel);
31218:   if (!(SUCCEEDED(hr))) {
31218:     fail("TestEditMessages: SetSelection #3");
80486:     return false;
31218:   }
31218: 
31218:   ::SendMessage(wnd, WM_COPY, 0, 0);
31218:   mTextArea->GetValue(str);
31218:   if (str != mTestString) {
31218:     fail("TestEditMessages: WM_COPY");
31218:     printf("Current Str: \"%s\"\n", NS_ConvertUTF16toUTF8(str).get());
80486:     return false;
31218:   }
31218: 
31218:   if (!::SendMessage(wnd, EM_CANPASTE, 0, 0)) {
31218:     fail("TestEditMessages: EM_CANPASTE #1");
80486:     return false;
31218:   }
31218: 
31218:   if (!::SendMessage(wnd, EM_CANPASTE, CF_TEXT, 0)) {
31218:     fail("TestEditMessages: EM_CANPASTE #2");
80486:     return false;
31218:   }
31218: 
31218:   if (!::SendMessage(wnd, EM_CANPASTE, CF_UNICODETEXT, 0)) {
31218:     fail("TestEditMessages: EM_CANPASTE #3");
80486:     return false;
31218:   }
31218: 
31218:   ::SendMessage(wnd, WM_PASTE, 0, 0);
31218:   mTextArea->GetValue(str);
31218:   if (str != mTestString) {
31218:     fail("TestEditMessages: WM_PASTE #3");
31218:     printf("Current Str: \"%s\"\n", NS_ConvertUTF16toUTF8(str).get());
80486:     return false;
31218:   }
31218: 
31218:   sel.acpStart = 4;
31218:   sel.acpEnd = testStringLength;
31218:   hr = mMgr->GetFocusedStore()->SetSelection(1, &sel);
31218:   if (!(SUCCEEDED(hr))) {
31218:     fail("TestEditMessages: SetSelection #3");
80486:     return false;
31218:   }
31218: 
31218:   ::SendMessage(wnd, WM_CLEAR, 0, 0);
31218:   mTextArea->GetValue(str);
31218:   if (str != NS_LITERAL_STRING("This")) {
31218:     fail("TestEditMessages: WM_CLEAR #2");
31218:     printf("Current Str: \"%s\"\n", NS_ConvertUTF16toUTF8(str).get());
80486:     return false;
31218:   }
31218: 
31218:   ::SendMessage(wnd, WM_PASTE, 0, 0);
31218:   mTextArea->GetValue(str);
31218:   if (str != mTestString) {
31218:     fail("TestEditMessages: WM_PASTE #4");
31218:     printf("Current Str: \"%s\"\n", NS_ConvertUTF16toUTF8(str).get());
80486:     return false;
80486:   }
80486: 
80486:   return true;
31218: }
31218: 
79445: bool
39248: TestApp::TestScrollMessages(void)
39248: {
39248:   NS_NAMED_LITERAL_STRING(kLine, "ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\n");
39248:   mTestString.Truncate();
39248:   for (PRUint32 i = 0; i < 30; i++) {
39248:     mTestString.Append(kLine);
39248:   }
39248: 
39248:   mTextArea->SetAttribute(NS_LITERAL_STRING("style"),
39248:     NS_LITERAL_STRING("width:3em;height:3em;word-wrap:normal;"));
39248:   mTextArea->SetValue(mTestString);
39248:   mTextArea->Focus();
39248: 
39248:   nsCOMPtr<nsIWidget> widget;
39248:   if (!GetWidget(getter_AddRefs(widget))) {
39248:     fail("TestScrollMessages: get nsIWidget");
39248:     mTextArea->SetAttribute(NS_LITERAL_STRING("style"), EmptyString());
80486:     return false;
39248:   }
39248: 
89079:   nsCOMPtr<nsIDOMElement> textArea = do_QueryInterface(mTextArea);
89079:   if (!textArea) {
89079:     fail("TestScrollMessages: get nsIDOMElement");
39248:     mTextArea->SetAttribute(NS_LITERAL_STRING("style"), EmptyString());
80486:     return false;
39248:   }
39248: 
39248: #define DO_CHECK(aFailureCondition, aDescription) \
39248:   if (aFailureCondition) { \
39248:     nsCAutoString str(aDescription); \
39248:     str.Append(": "); \
39248:     str.Append(#aFailureCondition); \
39248:     fail(str.get()); \
39248:     mTextArea->SetAttribute(NS_LITERAL_STRING("style"), EmptyString()); \
80486:     return false; \
39248:   }
39248: 
39248:   HWND wnd = (HWND)widget->GetNativeData(NS_NATIVE_WINDOW);
39248: 
89079:   textArea->SetScrollTop(0);
89079:   textArea->SetScrollLeft(0);
39248: 
39248:   if (::SendMessage(wnd, WM_VSCROLL, SB_LINEDOWN, 0) != 0) {
39248:     fail("TestScrollMessages: SendMessage WM_VSCROLL #1");
39248:     mTextArea->SetAttribute(NS_LITERAL_STRING("style"), EmptyString());
80486:     return false;
39248:   }
39248: 
39248:   PRInt32 x, y, prevX, prevY;
89079:   textArea->GetScrollTop(&y);
89079:   textArea->GetScrollLeft(&x);
39248: 
39248:   DO_CHECK(x != 0, "TestScrollMessages: SendMessage WM_VSCROLL #1");
39248:   DO_CHECK(y == 0, "TestScrollMessages: SendMessage WM_VSCROLL #1");
39248: 
39248:   if (::SendMessage(wnd, WM_HSCROLL, SB_LINERIGHT, 0) != 0) {
39248:     fail("TestScrollMessages: SendMessage WM_HSCROLL #1");
39248:     mTextArea->SetAttribute(NS_LITERAL_STRING("style"), EmptyString());
80486:     return false;
39248:   }
39248: 
39248:   prevX = x;
39248:   prevY = y;
89079:   textArea->GetScrollTop(&y);
89079:   textArea->GetScrollLeft(&x);
39248: 
39248:   const PRInt32 kLineWidth  = x;
39248:   const PRInt32 kLineHeight = y;
39248: 
39248:   DO_CHECK(x == 0,     "TestScrollMessages: SendMessage WM_HSCROLL #1");
39248:   DO_CHECK(y != prevY, "TestScrollMessages: SendMessage WM_HSCROLL #1");
39248: 
39248:   if (::SendMessage(wnd, WM_VSCROLL, SB_LINEUP, 0) != 0) {
39248:     fail("TestScrollMessages: SendMessage WM_VSCROLL #2");
39248:     mTextArea->SetAttribute(NS_LITERAL_STRING("style"), EmptyString());
80486:     return false;
39248:   }
39248: 
39248:   prevX = x;
39248:   prevY = y;
89079:   textArea->GetScrollTop(&y);
89079:   textArea->GetScrollLeft(&x);
39248: 
39248:   DO_CHECK(x != prevX, "TestScrollMessages: SendMessage WM_VSCROLL #2");
39248:   DO_CHECK(y != 0,     "TestScrollMessages: SendMessage WM_VSCROLL #2");
39248: 
39248:   if (::SendMessage(wnd, WM_HSCROLL, SB_LINELEFT, 0) != 0) {
39248:     fail("TestScrollMessages: SendMessage WM_HSCROLL #2");
39248:     mTextArea->SetAttribute(NS_LITERAL_STRING("style"), EmptyString());
80486:     return false;
39248:   }
39248: 
39248:   prevX = x;
39248:   prevY = y;
89079:   textArea->GetScrollTop(&y);
89079:   textArea->GetScrollLeft(&x);
39248: 
39248:   DO_CHECK(x != 0, "TestScrollMessages: SendMessage WM_HSCROLL #2");
39248:   DO_CHECK(y != 0, "TestScrollMessages: SendMessage WM_HSCROLL #2");
39248: 
39248:   if (::SendMessage(wnd, WM_VSCROLL, SB_PAGEDOWN, 0) != 0) {
39248:     fail("TestScrollMessages: SendMessage WM_VSCROLL #3");
39248:     mTextArea->SetAttribute(NS_LITERAL_STRING("style"), EmptyString());
80486:     return false;
39248:   }
39248: 
39248:   prevX = x;
39248:   prevY = y;
89079:   textArea->GetScrollTop(&y);
89079:   textArea->GetScrollLeft(&x);
39248: 
39248:   DO_CHECK(x != 0,           "TestScrollMessages: SendMessage WM_VSCROLL #3");
39248:   DO_CHECK(y <= kLineHeight, "TestScrollMessages: SendMessage WM_VSCROLL #3");
39248: 
39248:   if (::SendMessage(wnd, WM_HSCROLL, SB_PAGERIGHT, 0) != 0) {
39248:     fail("TestScrollMessages: SendMessage WM_HSCROLL #3");
39248:     mTextArea->SetAttribute(NS_LITERAL_STRING("style"), EmptyString());
80486:     return false;
39248:   }
39248: 
39248:   prevX = x;
39248:   prevY = y;
89079:   textArea->GetScrollTop(&y);
89079:   textArea->GetScrollLeft(&x);
39248: 
39248:   DO_CHECK(x <= kLineWidth, "TestScrollMessages: SendMessage WM_HSCROLL #3");
39248:   DO_CHECK(y != prevY,      "TestScrollMessages: SendMessage WM_HSCROLL #3");
39248: 
39248:   const PRInt32 kPageWidth  = x;
39248:   const PRInt32 kPageHeight = y;
39248: 
39248:   ::SendMessage(wnd, WM_VSCROLL, SB_LINEDOWN, 0);
39248:   ::SendMessage(wnd, WM_VSCROLL, SB_LINEUP, 0);
39248:   ::SendMessage(wnd, WM_HSCROLL, SB_LINERIGHT, 0);
39248:   ::SendMessage(wnd, WM_HSCROLL, SB_LINELEFT, 0);
39248: 
39248:   prevX = x;
39248:   prevY = y;
89079:   textArea->GetScrollTop(&y);
89079:   textArea->GetScrollLeft(&x);
39248: 
39248:   DO_CHECK(x != prevX, "TestScrollMessages: SB_LINELEFT scrolled wrong amount");
39248:   DO_CHECK(y != prevY, "TestScrollMessages: SB_LINEUP scrolled wrong amount");
39248: 
39248:   if (::SendMessage(wnd, WM_VSCROLL, SB_PAGEUP, 0) != 0) {
39248:     fail("TestScrollMessages: SendMessage WM_VSCROLL #4");
39248:     mTextArea->SetAttribute(NS_LITERAL_STRING("style"), EmptyString());
80486:     return false;
39248:   }
39248: 
39248:   prevX = x;
39248:   prevY = y;
89079:   textArea->GetScrollTop(&y);
89079:   textArea->GetScrollLeft(&x);
39248: 
39248:   DO_CHECK(x != prevX, "TestScrollMessages: SendMessage WM_VSCROLL #4");
39248:   DO_CHECK(y != 0,     "TestScrollMessages: SendMessage WM_VSCROLL #4");
39248: 
39248:   if (::SendMessage(wnd, WM_HSCROLL, SB_PAGELEFT, 0) != 0) {
39248:     fail("TestScrollMessages: SendMessage WM_HSCROLL #4");
39248:     mTextArea->SetAttribute(NS_LITERAL_STRING("style"), EmptyString());
80486:     return false;
39248:   }
39248: 
39248:   prevX = x;
39248:   prevY = y;
89079:   textArea->GetScrollTop(&y);
89079:   textArea->GetScrollLeft(&x);
39248: 
39248:   DO_CHECK(x != 0, "TestScrollMessages: SendMessage WM_HSCROLL #4");
39248:   DO_CHECK(y != 0, "TestScrollMessages: SendMessage WM_HSCROLL #4");
39248: 
39248:   if (::SendMessage(wnd, WM_VSCROLL, SB_BOTTOM, 0) != 0) {
39248:     fail("TestScrollMessages: SendMessage WM_VSCROLL #5");
39248:     mTextArea->SetAttribute(NS_LITERAL_STRING("style"), EmptyString());
80486:     return false;
39248:   }
39248: 
39248:   prevX = x;
39248:   prevY = y;
89079:   textArea->GetScrollTop(&y);
89079:   textArea->GetScrollLeft(&x);
39248: 
39248:   DO_CHECK(x != 0,           "TestScrollMessages: SendMessage WM_VSCROLL #5");
39248:   DO_CHECK(y <= kPageHeight, "TestScrollMessages: SendMessage WM_VSCROLL #5");
39248: 
39248:   if (::SendMessage(wnd, WM_HSCROLL, SB_RIGHT, 0) != 0) {
39248:     fail("TestScrollMessages: SendMessage WM_HSCROLL #6");
39248:     mTextArea->SetAttribute(NS_LITERAL_STRING("style"), EmptyString());
80486:     return false;
39248:   }
39248: 
39248:   prevX = x;
39248:   prevY = y;
89079:   textArea->GetScrollTop(&y);
89079:   textArea->GetScrollLeft(&x);
39248: 
39248:   DO_CHECK(x <= kPageWidth, "TestScrollMessages: SendMessage WM_HSCROLL #5");
39248:   DO_CHECK(y != prevY,      "TestScrollMessages: SendMessage WM_HSCROLL #5");
39248: 
39248:   ::SendMessage(wnd, WM_VSCROLL, SB_LINEDOWN, 0);
39248:   ::SendMessage(wnd, WM_HSCROLL, SB_LINERIGHT, 0);
39248: 
39248:   prevX = x;
39248:   prevY = y;
89079:   textArea->GetScrollTop(&y);
89079:   textArea->GetScrollLeft(&x);
39248: 
39248:   DO_CHECK(x != prevX, "SB_RIGHT didn't scroll to right most");
39248:   DO_CHECK(y != prevY, "SB_BOTTOM didn't scroll to bottom most");
39248: 
39248:   ::SendMessage(wnd, WM_VSCROLL, SB_PAGEUP, 0);
39248:   ::SendMessage(wnd, WM_VSCROLL, SB_PAGEDOWN, 0);
39248:   ::SendMessage(wnd, WM_HSCROLL, SB_PAGELEFT, 0);
39248:   ::SendMessage(wnd, WM_HSCROLL, SB_PAGERIGHT, 0);
39248: 
39248:   prevX = x;
39248:   prevY = y;
89079:   textArea->GetScrollTop(&y);
89079:   textArea->GetScrollLeft(&x);
39248: 
39248:   DO_CHECK(x != prevX, "TestScrollMessages: SB_PAGELEFT scrolled wrong amount");
39248:   DO_CHECK(y != prevY, "TestScrollMessages: SB_PAGEUP scrolled wrong amount");
39248: 
39248:   if (::SendMessage(wnd, WM_VSCROLL, SB_TOP, 0) != 0) {
39248:     fail("TestScrollMessages: SendMessage WM_VSCROLL #6");
39248:     mTextArea->SetAttribute(NS_LITERAL_STRING("style"), EmptyString());
80486:     return false;
39248:   }
39248: 
39248:   prevX = x;
39248:   prevY = y;
89079:   textArea->GetScrollTop(&y);
89079:   textArea->GetScrollLeft(&x);
39248: 
39248:   DO_CHECK(x != prevX, "TestScrollMessages: SendMessage WM_VSCROLL #6");
39248:   DO_CHECK(y != 0,     "TestScrollMessages: SendMessage WM_VSCROLL #6");
39248: 
39248:   if (::SendMessage(wnd, WM_HSCROLL, SB_LEFT, 0) != 0) {
39248:     fail("TestScrollMessages: SendMessage WM_HSCROLL #4");
39248:     mTextArea->SetAttribute(NS_LITERAL_STRING("style"), EmptyString());
80486:     return false;
39248:   }
39248: 
39248:   prevX = x;
39248:   prevY = y;
89079:   textArea->GetScrollTop(&y);
89079:   textArea->GetScrollLeft(&x);
39248: 
39248:   DO_CHECK(x != 0, "TestScrollMessages: SendMessage WM_HSCROLL #6");
39248:   DO_CHECK(y != 0, "TestScrollMessages: SendMessage WM_HSCROLL #6");
39248: #undef DO_CHECK
39248: 
39248:   mTextArea->SetAttribute(NS_LITERAL_STRING("style"), EmptyString());
80486:   return true;
39248: }
39248: 
79445: bool
31218: TestApp::GetWidget(nsIWidget** aWidget)
31218: {
31218:   nsCOMPtr<nsIDocShell> docShell;
31218:   nsresult rv = mWindow->GetDocShell(getter_AddRefs(docShell));
31218:   if (NS_FAILED(rv) || !docShell) {
80486:     return false;
31218:   }
31218: 
31218:   nsCOMPtr<nsIPresShell> presShell;
31218:   rv = docShell->GetPresShell(getter_AddRefs(presShell));
31218:   if (NS_FAILED(rv) || !presShell) {
80486:     return false;
31218:   }
31218: 
31218:   nsCOMPtr<nsIViewManager> viewManager = presShell->GetViewManager();
31218:   if (!viewManager) {
80486:     return false;
31218:   }
31218: 
31218:   rv = viewManager->GetRootWidget(aWidget);
31218:   return (NS_SUCCEEDED(rv) && aWidget);
31218: }
31218: 
24823: nsresult
24823: TestApp::GetSelCon(nsISelectionController** aSelCon)
24823: {
24823:   nsCOMPtr<nsIDocShell> docShell;
24823:   nsresult nsr = mWindow->GetDocShell(getter_AddRefs(docShell));
24823:   if (NS_SUCCEEDED(nsr) && docShell) {
24823:     nsCOMPtr<nsIPresShell> presShell;
24823:     nsr = docShell->GetPresShell(getter_AddRefs(presShell));
24823:     if (NS_SUCCEEDED(nsr) && presShell) {
36657:       nsIFrame* frame = 
36657:         nsCOMPtr<nsIContent>(do_QueryInterface(mCurrentNode))->GetPrimaryFrame();
24823:       if (frame) {
24823:         nsPresContext* presContext = presShell->GetPresContext();
24823:         if (presContext) {
24823:           nsr = frame->GetSelectionController(presContext, aSelCon);
24823:         }
24823:       }
24823:     }
24823:   }
24823:   return nsr;
24823: }
24823: 
24823: int main(int argc, char** argv)
24823: {
24823:   ScopedXPCOM xpcom("TestWinTSF (bug #88831)");
24823:   if (xpcom.failed())
24823:     return 1;
24823: 
24823:   nsRefPtr<TestApp> tests = new TestApp();
24823:   if (!tests)
24823:     return 1;
24823: 
24823:   if (NS_FAILED(tests->Run())) {
24823:     fail("run failed");
24823:     return 1;
24823:   }
24823:   return int(tests->CheckFailed());
24823: }
