31532: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
31532:  *
31532:  * ***** BEGIN LICENSE BLOCK *****
31532:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
31532:  *
31532:  * The contents of this file are subject to the Mozilla Public License Version
31532:  * 1.1 (the "License"); you may not use this file except in compliance with
31532:  * the License. You may obtain a copy of the License at
31532:  * http://www.mozilla.org/MPL/
31532:  *
31532:  * Software distributed under the License is distributed on an "AS IS" basis,
31532:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
31532:  * for the specific language governing rights and limitations under the
31532:  * License.
31532:  *
31532:  * The Original Code is mozilla.org code.
31532:  *
31532:  * The Initial Developer of the Original Code is
31532:  * Mozilla Foundation
31532:  * Portions created by the Initial Developer are Copyright (C) 2009
31532:  * the Initial Developer. All Rights Reserved.
31532:  *
31532:  * Contributor(s):
31532:  *   Rob Arnold <tellrob@gmail.com>
31532:  *
31532:  * Alternatively, the contents of this file may be used under the terms of
31532:  * either the GNU General Public License Version 2 or later (the "GPL"), or
31532:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
31532:  * in which case the provisions of the GPL or the LGPL are applicable instead
31532:  * of those above. If you wish to allow use of your version of this file only
31532:  * under the terms of either the GPL or the LGPL, and not to allow others to
31532:  * use your version of this file under the terms of the MPL, indicate your
31532:  * decision by deleting the provisions above and replace them with the notice
31532:  * and other provisions required by the GPL or the LGPL. If you do not delete
31532:  * the provisions above, a recipient may use your version of this file under
31532:  * the terms of any one of the MPL, the GPL or the LGPL.
31532:  *
31532:  * ***** END LICENSE BLOCK ***** */
31532: 
31532: #include "WindowHook.h"
31532: #include "nsWindow.h"
31532: 
31532: namespace mozilla {
31532: namespace widget {
31532: 
31532: nsresult
31532: WindowHook::AddHook(UINT nMsg, Callback callback, void *context) {
31532:   MessageData *data = LookupOrCreate(nMsg);
31532: 
31532:   if (!data)
31532:     return NS_ERROR_OUT_OF_MEMORY;
31532: 
31532:   // Ensure we don't overwrite another hook
31532:   NS_ENSURE_TRUE(nsnull == data->hook.cb, NS_ERROR_UNEXPECTED);
31532: 
31532:   data->hook = CallbackData(callback, context);
31532: 
31532:   return NS_OK;
31532: }
31532: 
31532: nsresult
31532: WindowHook::RemoveHook(UINT nMsg, Callback callback, void *context) {
31532:   CallbackData cbdata(callback, context);
31532:   MessageData *data = Lookup(nMsg);
31532:   if (!data)
31532:     return NS_ERROR_UNEXPECTED;
31532:   if (data->hook != cbdata)
31532:     return NS_ERROR_UNEXPECTED;
31532:   data->hook = CallbackData();
31532: 
31532:   DeleteIfEmpty(data);
31532:   return NS_OK;
31532: }
31532: 
31532: nsresult
31532: WindowHook::AddMonitor(UINT nMsg, Callback callback, void *context) {
31532:   MessageData *data = LookupOrCreate(nMsg);
31532:   return (data && data->monitors.AppendElement(CallbackData(callback, context)))
31532:          ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
31532: }
31532: 
31532: nsresult
31532: WindowHook::RemoveMonitor(UINT nMsg, Callback callback, void *context) {
31532:   CallbackData cbdata(callback, context);
31532:   MessageData *data = Lookup(nMsg);
31532:   if (!data)
31532:     return NS_ERROR_UNEXPECTED;
31532:   CallbackDataArray::index_type idx = data->monitors.IndexOf(cbdata);
31532:   if (idx == CallbackDataArray::NoIndex)
31532:     return NS_ERROR_UNEXPECTED;
31532:   data->monitors.RemoveElementAt(idx);
31532:   DeleteIfEmpty(data);
31532:   return NS_OK;
31532: }
31532: 
31532: WindowHook::MessageData *
31532: WindowHook::Lookup(UINT nMsg) {
31532:   MessageDataArray::index_type idx;
31532:   for (idx = 0; idx < mMessageData.Length(); idx++) {
31532:     MessageData &data = mMessageData[idx];
31532:     if (data.nMsg == nMsg)
31532:       return &data;
31532:   }
31532:   return nsnull;
31532: }
31532: 
31532: WindowHook::MessageData *
31532: WindowHook::LookupOrCreate(UINT nMsg) {
31532:   MessageData *data = Lookup(nMsg);
31532:   if (!data) {
31532:     data = mMessageData.AppendElement();
31532: 
31532:     if (!data)
31532:       return nsnull;
31532: 
31532:     data->nMsg = nMsg;
31532:   }
31532:   return data;
31532: }
31532: 
31532: void
31532: WindowHook::DeleteIfEmpty(MessageData *data) {
40012:   // Never remove a MessageData that has still a hook or monitor entries.
40012:   if (data->hook || !data->monitors.IsEmpty())
31532:     return;
40012: 
31532:   MessageDataArray::index_type idx;
31532:   idx = data - mMessageData.Elements();
31532:   NS_ASSERTION(idx >= 0 && idx < mMessageData.Length(), "Attempted to delete MessageData that doesn't belong to this array!");
31532:   mMessageData.RemoveElementAt(idx);
31532: }
31532: 
31532: PRBool
31532: WindowHook::Notify(HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam,
31532:                    LRESULT *aResult) {
31532:   MessageData *data = Lookup(nMsg);
31532:   if (!data)
31532:     return PR_FALSE;
31532: 
31532:   PRUint32 length = data->monitors.Length();
31532:   for (PRUint32 midx = 0; midx < length; midx++) {
31532:     data->monitors[midx].Invoke(hWnd, nMsg, wParam, lParam, aResult);
31532:   }
31532: 
31532:   return data->hook.Invoke(hWnd, nMsg, wParam, lParam, aResult);
31532: }
31532: 
31532: PRBool
31532: WindowHook::CallbackData::Invoke(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam,
31532:                                  LRESULT *aResult) {
31532:   if (!cb)
31532:     return PR_FALSE;
31532:   return cb(context, hWnd, msg, wParam, lParam, aResult);
31532: }
31532: } // namespace widget
31532: } // namespace mozilla
31532: 
