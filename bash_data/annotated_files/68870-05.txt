    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications.
    1:  * Portions created by the Initial Developer are Copyright (C) 2002
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *  Mike Pinkerton <pinkerton@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsReadableUtils.h"
    1: 
    1: // Local Includes
    1: #include "nsContentAreaDragDrop.h"
    1: 
    1: // Helper Classes
    1: #include "nsString.h"
    1: 
    1: // Interfaces needed to be included
42637: #include "nsCopySupport.h"
    1: #include "nsIDOMNSUIEvent.h"
    1: #include "nsIDOMUIEvent.h"
    1: #include "nsISelection.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMEvent.h"
    1: #include "nsIDOMNSEvent.h"
18445: #include "nsIDOMDragEvent.h"
68870: #include "nsIDOMAbstractView.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMDocumentRange.h"
    1: #include "nsIDOMRange.h"
    1: #include "nsIFormControl.h"
    1: #include "nsIDOMHTMLAreaElement.h"
    1: #include "nsIDOMHTMLAnchorElement.h"
    1: #include "nsITransferable.h"
    1: #include "nsComponentManagerUtils.h"
    1: #include "nsXPCOM.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsServiceManagerUtils.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIFile.h"
    1: #include "nsIWebNavigation.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIContent.h"
    1: #include "nsIImageLoadingContent.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsIURL.h"
    1: #include "nsIDocument.h"
    1: #include "nsIScriptSecurityManager.h"
18445: #include "nsIPrincipal.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIWebBrowserPersist.h"
    1: #include "nsEscape.h"
    1: #include "nsContentUtils.h"
    1: #include "nsIMIMEService.h"
30479: #include "imgIContainer.h"
    1: #include "imgIRequest.h"
18445: #include "nsDOMDataTransfer.h"
    1: 
    1: // private clipboard data flavors for html copy, used by editor when pasting
    1: #define kHTMLContext   "text/_moz_htmlcontext"
    1: #define kHTMLInfo      "text/_moz_htmlinfo"
    1: 
47336: // if aNode is null, use the selection from the window
42637: static nsresult
42637: GetTransferableForNodeOrSelection(nsIDOMWindow*     aWindow,
42637:                                   nsIContent*       aNode,
42637:                                   nsITransferable** aTransferable)
42637: {
42637:   NS_ENSURE_ARG_POINTER(aWindow);
42637: 
42637:   nsCOMPtr<nsIDOMDocument> domDoc;
42637:   aWindow->GetDocument(getter_AddRefs(domDoc));
42637:   NS_ENSURE_TRUE(domDoc, NS_ERROR_FAILURE);
42637:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
42637: 
42637:   nsresult rv;
47336:   if (aNode) {
47336:     rv = nsCopySupport::GetTransferableForNode(aNode, doc, aTransferable);
47336:   } else {
42637:     nsCOMPtr<nsISelection> selection;
42637:     aWindow->GetSelection(getter_AddRefs(selection));
47336:     rv = nsCopySupport::GetTransferableForSelection(selection, doc,
47336:                                                     aTransferable);
42637:   }
42637: 
42637:   NS_ENSURE_SUCCESS(rv, rv);
42637:   return rv;
42637: }
    1: 
40970: class NS_STACK_CLASS DragDataProducer
    1: {
    1: public:
40970:   DragDataProducer(nsIDOMWindow* aWindow,
18445:                    nsIContent* aTarget,
18445:                    nsIContent* aSelectionTargetNode,
18445:                    PRBool aIsAltKeyPressed);
18445:   nsresult Produce(nsDOMDataTransfer* aDataTransfer,
18445:                    PRBool* aCanDrag,
18445:                    PRBool* aDragSelection,
18445:                    nsIContent** aDragNode);
    1: 
    1: private:
18445:   void AddString(nsDOMDataTransfer* aDataTransfer,
18445:                  const nsAString& aFlavor,
18445:                  const nsAString& aData,
18445:                  nsIPrincipal* aPrincipal);
18445:   nsresult AddStringsToDataTransfer(nsIContent* aDragNode,
18445:                                     nsDOMDataTransfer* aDataTransfer);
    1:   static nsresult GetDraggableSelectionData(nsISelection* inSelection,
18445:                                             nsIContent* inRealTargetNode,
18445:                                             nsIContent **outImageOrLinkNode,
    1:                                             PRBool* outDragSelectedText);
18445:   static already_AddRefed<nsIContent> FindParentLinkNode(nsIContent* inNode);
18445:   static void GetAnchorURL(nsIContent* inNode, nsAString& outURL);
18445:   static void GetNodeString(nsIContent* inNode, nsAString & outNodeString);
    1:   static void CreateLinkText(const nsAString& inURL, const nsAString & inText,
    1:                               nsAString& outLinkText);
    1:   static void GetSelectedLink(nsISelection* inSelection,
18445:                               nsIContent **outLinkNode);
    1: 
18445:   nsCOMPtr<nsIDOMWindow> mWindow;
18445:   nsCOMPtr<nsIContent> mTarget;
18445:   nsCOMPtr<nsIContent> mSelectionTargetNode;
18445:   PRPackedBool mIsAltKeyPressed;
    1: 
    1:   nsString mUrlString;
    1:   nsString mImageSourceString;
    1:   nsString mImageDestFileName;
    1:   nsString mTitleString;
    1:   // will be filled automatically if you fill urlstring
    1:   nsString mHtmlString;
    1:   nsString mContextString;
    1:   nsString mInfoString;
    1: 
    1:   PRBool mIsAnchor;
30479:   nsCOMPtr<imgIContainer> mImage;
    1: };
    1: 
    1: 
18445: nsresult
18445: nsContentAreaDragDrop::GetDragData(nsIDOMWindow* aWindow,
18445:                                    nsIContent* aTarget,
18445:                                    nsIContent* aSelectionTargetNode,
18445:                                    PRBool aIsAltKeyPressed,
18445:                                    nsDOMDataTransfer* aDataTransfer,
18445:                                    PRBool* aCanDrag,
18445:                                    PRBool* aDragSelection,
18445:                                    nsIContent** aDragNode)
18445: {
18445:   NS_ENSURE_TRUE(aSelectionTargetNode, NS_ERROR_INVALID_ARG);
    1: 
18445:   *aCanDrag = PR_TRUE;
    1: 
40970:   DragDataProducer
40970:     provider(aWindow, aTarget, aSelectionTargetNode, aIsAltKeyPressed);
40970:   return provider.Produce(aDataTransfer, aCanDrag, aDragSelection, aDragNode);
    1: }
    1: 
    1: 
18445: NS_IMPL_ISUPPORTS1(nsContentAreaDragDropDataProvider, nsIFlavorDataProvider)
18445: 
    1: // SaveURIToFile
    1: // used on platforms where it's possible to drag items (e.g. images)
    1: // into the file system
    1: nsresult
18445: nsContentAreaDragDropDataProvider::SaveURIToFile(nsAString& inSourceURIString,
    1:                                                  nsIFile* inDestFile)
    1: {
    1:   nsCOMPtr<nsIURI> sourceURI;
    1:   nsresult rv = NS_NewURI(getter_AddRefs(sourceURI), inSourceURIString);
    1:   if (NS_FAILED(rv)) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsCOMPtr<nsIURL> sourceURL = do_QueryInterface(sourceURI);
    1:   if (!sourceURL) {
    1:     return NS_ERROR_NO_INTERFACE;
    1:   }
    1: 
    1:   rv = inDestFile->CreateUnique(nsIFile::NORMAL_FILE_TYPE, 0600);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // we rely on the fact that the WPB is refcounted by the channel etc,
    1:   // so we don't keep a ref to it. It will die when finished.
    1:   nsCOMPtr<nsIWebBrowserPersist> persist =
    1:     do_CreateInstance("@mozilla.org/embedding/browser/nsWebBrowserPersist;1",
    1:                       &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
18445:   return persist->SaveURI(sourceURI, nsnull, nsnull, nsnull, nsnull, inDestFile);
    1: }
    1: 
    1: // This is our nsIFlavorDataProvider callback. There are several
    1: // assumptions here that make this work:
    1: //
    1: // 1. Someone put a kFilePromiseURLMime flavor into the transferable
    1: //    with the source URI of the file to save (as a string). We did
18445: //    that in AddStringsToDataTransfer.
    1: //
    1: // 2. Someone put a kFilePromiseDirectoryMime flavor into the
    1: //    transferable with an nsILocalFile for the directory we are to
    1: //    save in. That has to be done by platform-specific code (in
18445: //    widget), which gets the destination directory from
18445: //    OS-specific drag information.
    1: //
    1: NS_IMETHODIMP
18445: nsContentAreaDragDropDataProvider::GetFlavorData(nsITransferable *aTransferable,
18445:                                                  const char *aFlavor,
18445:                                                  nsISupports **aData,
    1:                                                  PRUint32 *aDataLen)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aData && aDataLen);
    1:   *aData = nsnull;
    1:   *aDataLen = 0;
    1: 
    1:   nsresult rv = NS_ERROR_NOT_IMPLEMENTED;
    1: 
    1:   if (strcmp(aFlavor, kFilePromiseMime) == 0) {
    1:     // get the URI from the kFilePromiseURLMime flavor
    1:     NS_ENSURE_ARG(aTransferable);
    1:     nsCOMPtr<nsISupports> tmp;
    1:     PRUint32 dataSize = 0;
    1:     aTransferable->GetTransferData(kFilePromiseURLMime,
    1:                                    getter_AddRefs(tmp), &dataSize);
    1:     nsCOMPtr<nsISupportsString> supportsString =
    1:       do_QueryInterface(tmp);
    1:     if (!supportsString)
    1:       return NS_ERROR_FAILURE;
    1: 
    1:     nsAutoString sourceURLString;
    1:     supportsString->GetData(sourceURLString);
    1:     if (sourceURLString.IsEmpty())
    1:       return NS_ERROR_FAILURE;
    1: 
    1:     aTransferable->GetTransferData(kFilePromiseDestFilename,
    1:                                    getter_AddRefs(tmp), &dataSize);
    1:     supportsString = do_QueryInterface(tmp);
    1:     if (!supportsString)
    1:       return NS_ERROR_FAILURE;
    1: 
    1:     nsAutoString targetFilename;
    1:     supportsString->GetData(targetFilename);
    1:     if (targetFilename.IsEmpty())
    1:       return NS_ERROR_FAILURE;
    1: 
    1:     // get the target directory from the kFilePromiseDirectoryMime
    1:     // flavor
    1:     nsCOMPtr<nsISupports> dirPrimitive;
    1:     dataSize = 0;
    1:     aTransferable->GetTransferData(kFilePromiseDirectoryMime,
    1:                                    getter_AddRefs(dirPrimitive), &dataSize);
    1:     nsCOMPtr<nsILocalFile> destDirectory = do_QueryInterface(dirPrimitive);
    1:     if (!destDirectory)
    1:       return NS_ERROR_FAILURE;
    1: 
    1:     nsCOMPtr<nsIFile> file;
    1:     rv = destDirectory->Clone(getter_AddRefs(file));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     file->Append(targetFilename);
    1: 
    1:     rv = SaveURIToFile(sourceURLString, file);
    1:     // send back an nsILocalFile
    1:     if (NS_SUCCEEDED(rv)) {
    1:       CallQueryInterface(file, aData);
    1:       *aDataLen = sizeof(nsIFile*);
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
40970: DragDataProducer::DragDataProducer(nsIDOMWindow* aWindow,
18445:                                    nsIContent* aTarget,
18445:                                    nsIContent* aSelectionTargetNode,
18445:                                    PRBool aIsAltKeyPressed)
18445:   : mWindow(aWindow),
18445:     mTarget(aTarget),
18445:     mSelectionTargetNode(aSelectionTargetNode),
40970:     mIsAltKeyPressed(aIsAltKeyPressed),
40970:     mIsAnchor(PR_FALSE)
    1: {
    1: }
    1: 
    1: 
    1: //
    1: // FindParentLinkNode
    1: //
    1: // Finds the parent with the given link tag starting at |inNode|. If
    1: // it gets up to the root without finding it, we stop looking and
    1: // return null.
    1: //
18445: already_AddRefed<nsIContent>
40970: DragDataProducer::FindParentLinkNode(nsIContent* inNode)
    1: {
18445:   nsIContent* content = inNode;
    1:   if (!content) {
    1:     // That must have been the document node; nothing else to do here;
    1:     return nsnull;
    1:   }
    1: 
    1:   for (; content; content = content->GetParent()) {
    1:     if (nsContentUtils::IsDraggableLink(content)) {
18445:       NS_ADDREF(content);
18445:       return content;
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: 
    1: //
    1: // GetAnchorURL
    1: //
    1: void
40970: DragDataProducer::GetAnchorURL(nsIContent* inNode, nsAString& outURL)
    1: {
    1:   nsCOMPtr<nsIURI> linkURI;
18445:   if (!inNode || !inNode->IsLink(getter_AddRefs(linkURI))) {
    1:     // Not a link
    1:     outURL.Truncate();
    1:     return;
    1:   }
    1: 
    1:   nsCAutoString spec;
    1:   linkURI->GetSpec(spec);
    1:   CopyUTF8toUTF16(spec, outURL);
    1: }
    1: 
    1: 
    1: //
    1: // CreateLinkText
    1: //
    1: // Creates the html for an anchor in the form
    1: //  <a href="inURL">inText</a>
    1: //
    1: void
40970: DragDataProducer::CreateLinkText(const nsAString& inURL,
    1:                                  const nsAString & inText,
    1:                                  nsAString& outLinkText)
    1: {
    1:   // use a temp var in case |inText| is the same string as
    1:   // |outLinkText| to avoid overwriting it while building up the
    1:   // string in pieces.
    1:   nsAutoString linkText(NS_LITERAL_STRING("<a href=\"") +
    1:                         inURL +
    1:                         NS_LITERAL_STRING("\">") +
    1:                         inText +
    1:                         NS_LITERAL_STRING("</a>") );
    1: 
    1:   outLinkText = linkText;
    1: }
    1: 
    1: 
    1: //
    1: // GetNodeString
    1: //
    1: // Gets the text associated with a node
    1: //
    1: void
40970: DragDataProducer::GetNodeString(nsIContent* inNode,
    1:                                 nsAString & outNodeString)
    1: {
18445:   nsCOMPtr<nsIDOMNode> node = do_QueryInterface(inNode);
18445: 
    1:   outNodeString.Truncate();
    1: 
    1:   // use a range to get the text-equivalent of the node
    1:   nsCOMPtr<nsIDOMDocument> doc;
18445:   node->GetOwnerDocument(getter_AddRefs(doc));
    1:   nsCOMPtr<nsIDOMDocumentRange> docRange(do_QueryInterface(doc));
    1:   if (docRange) {
    1:     nsCOMPtr<nsIDOMRange> range;
    1:     docRange->CreateRange(getter_AddRefs(range));
    1:     if (range) {
18445:       range->SelectNode(node);
    1:       range->ToString(outNodeString);
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
40970: DragDataProducer::Produce(nsDOMDataTransfer* aDataTransfer,
18445:                           PRBool* aCanDrag,
18445:                           PRBool* aDragSelection,
18445:                           nsIContent** aDragNode)
    1: {
18445:   NS_PRECONDITION(aCanDrag && aDragSelection && aDataTransfer && aDragNode,
18445:                   "null pointer passed to Produce");
18445:   NS_ASSERTION(mWindow, "window not set");
18445:   NS_ASSERTION(mSelectionTargetNode, "selection target node should have been set");
    1: 
18445:   *aDragNode = nsnull;
    1: 
42637:   nsresult rv;
18445:   nsIContent* dragNode = nsnull;
    1: 
    1:   // find the selection to see what we could be dragging and if
    1:   // what we're dragging is in what is selected.
    1:   nsCOMPtr<nsISelection> selection;
18445:   mWindow->GetSelection(getter_AddRefs(selection));
    1:   if (!selection) {
    1:     return NS_OK;
    1:   }
    1: 
18445:   // check if the node is inside a form control. If so, dragging will be
18445:   // handled in editor code (nsPlaintextDataTransfer::DoDrag). Don't set
18445:   // aCanDrag to false however, as we still want to allow the drag.
18445:   nsCOMPtr<nsIContent> findFormNode = mSelectionTargetNode;
18445:   nsIContent* findFormParent = findFormNode->GetParent();
18445:   while (findFormParent) {
18445:     nsCOMPtr<nsIFormControl> form(do_QueryInterface(findFormParent));
63767:     if (form && !form->AllowDraggableChildren()) {
18445:       return NS_OK;
63767:     }
18445:     findFormParent = findFormParent->GetParent();
18445:   }
18445:     
    1:   // if set, serialize the content under this node
18445:   nsCOMPtr<nsIContent> nodeToSerialize;
    1:   *aDragSelection = PR_FALSE;
    1: 
    1:   {
    1:     PRBool haveSelectedContent = PR_FALSE;
    1: 
    1:     // possible parent link node
18445:     nsCOMPtr<nsIContent> parentLink;
18445:     nsCOMPtr<nsIContent> draggedNode;
    1: 
    1:     {
    1:       // only drag form elements by using the alt key,
    1:       // otherwise buttons and select widgets are hard to use
    1: 
    1:       // Note that while <object> elements implement nsIFormControl, we should
    1:       // really allow dragging them if they happen to be images.
18445:       nsCOMPtr<nsIFormControl> form(do_QueryInterface(mTarget));
18445:       if (form && !mIsAltKeyPressed && form->GetType() != NS_FORM_OBJECT) {
18445:         *aCanDrag = PR_FALSE;
    1:         return NS_OK;
    1:       }
    1: 
18445:       draggedNode = mTarget;
    1:     }
    1: 
    1:     nsCOMPtr<nsIDOMHTMLAreaElement>   area;   // client-side image map
    1:     nsCOMPtr<nsIImageLoadingContent>  image;
    1:     nsCOMPtr<nsIDOMHTMLAnchorElement> link;
    1: 
18445:     nsCOMPtr<nsIContent> selectedImageOrLinkNode;
18445:     GetDraggableSelectionData(selection, mSelectionTargetNode,
    1:                               getter_AddRefs(selectedImageOrLinkNode),
    1:                               &haveSelectedContent);
    1: 
    1:     // either plain text or anchor text is selected
    1:     if (haveSelectedContent) {
    1:       link = do_QueryInterface(selectedImageOrLinkNode);
18445:       if (link && mIsAltKeyPressed) {
18445:         // if alt is pressed, select the link text instead of drag the link
18445:         *aCanDrag = PR_FALSE;
    1:         return NS_OK;
    1:       }
    1: 
    1:       *aDragSelection = PR_TRUE;
    1:     } else if (selectedImageOrLinkNode) {
    1:       // an image is selected
    1:       image = do_QueryInterface(selectedImageOrLinkNode);
    1:     } else {
    1:       // nothing is selected -
    1:       //
    1:       // look for draggable elements under the mouse
    1:       //
    1:       // if the alt key is down, don't start a drag if we're in an
    1:       // anchor because we want to do selection.
    1:       parentLink = FindParentLinkNode(draggedNode);
18445:       if (parentLink && mIsAltKeyPressed) {
18445:         *aCanDrag = PR_FALSE;
    1:         return NS_OK;
    1:       }
    1: 
    1:       area  = do_QueryInterface(draggedNode);
    1:       image = do_QueryInterface(draggedNode);
    1:       link  = do_QueryInterface(draggedNode);
    1:     }
    1: 
    1:     {
    1:       // set for linked images, and links
18445:       nsCOMPtr<nsIContent> linkNode;
    1: 
    1:       if (area) {
    1:         // use the alt text (or, if missing, the href) as the title
    1:         area->GetAttribute(NS_LITERAL_STRING("alt"), mTitleString);
    1:         if (mTitleString.IsEmpty()) {
    1:           // this can be a relative link
    1:           area->GetAttribute(NS_LITERAL_STRING("href"), mTitleString);
    1:         }
    1: 
    1:         // we'll generate HTML like <a href="absurl">alt text</a>
    1:         mIsAnchor = PR_TRUE;
    1: 
    1:         // gives an absolute link
18445:         GetAnchorURL(draggedNode, mUrlString);
    1: 
    1:         mHtmlString.AssignLiteral("<a href=\"");
    1:         mHtmlString.Append(mUrlString);
    1:         mHtmlString.AppendLiteral("\">");
    1:         mHtmlString.Append(mTitleString);
    1:         mHtmlString.AppendLiteral("</a>");
18445: 
18445:         dragNode = draggedNode;
    1:       } else if (image) {
    1:         mIsAnchor = PR_TRUE;
    1:         // grab the href as the url, use alt text as the title of the
    1:         // area if it's there.  the drag data is the image tag and src
    1:         // attribute.
    1:         nsCOMPtr<nsIURI> imageURI;
    1:         image->GetCurrentURI(getter_AddRefs(imageURI));
    1:         if (imageURI) {
    1:           nsCAutoString spec;
    1:           imageURI->GetSpec(spec);
    1:           CopyUTF8toUTF16(spec, mUrlString);
    1:         }
    1: 
    1:         nsCOMPtr<nsIDOMElement> imageElement(do_QueryInterface(image));
    1:         // XXXbz Shouldn't we use the "title" attr for title?  Using
    1:         // "alt" seems very wrong....
    1:         if (imageElement) {
    1:           imageElement->GetAttribute(NS_LITERAL_STRING("alt"), mTitleString);
    1:         }
    1: 
    1:         if (mTitleString.IsEmpty()) {
    1:           mTitleString = mUrlString;
    1:         }
    1: 
    1:         nsCOMPtr<imgIRequest> imgRequest;
    1: 
    1:         // grab the image data, and its request.
30479:         nsCOMPtr<imgIContainer> img =
    1:           nsContentUtils::GetImageFromContent(image,
    1:                                               getter_AddRefs(imgRequest));
    1: 
    1:         nsCOMPtr<nsIMIMEService> mimeService =
    1:           do_GetService("@mozilla.org/mime;1");
    1: 
    1:         // Fix the file extension in the URL if necessary
    1:         if (imgRequest && mimeService) {
    1:           nsCOMPtr<nsIURI> imgUri;
    1:           imgRequest->GetURI(getter_AddRefs(imgUri));
    1: 
    1:           nsCOMPtr<nsIURL> imgUrl(do_QueryInterface(imgUri));
    1: 
    1:           if (imgUrl) {
    1:             nsCAutoString extension;
    1:             imgUrl->GetFileExtension(extension);
    1: 
    1:             nsXPIDLCString mimeType;
    1:             imgRequest->GetMimeType(getter_Copies(mimeType));
    1: 
    1:             nsCOMPtr<nsIMIMEInfo> mimeInfo;
    1:             mimeService->GetFromTypeAndExtension(mimeType, EmptyCString(),
    1:                                                  getter_AddRefs(mimeInfo));
    1: 
    1:             if (mimeInfo) {
    1:               nsCAutoString spec;
    1:               imgUrl->GetSpec(spec);
    1: 
    1:               // pass out the image source string
    1:               CopyUTF8toUTF16(spec, mImageSourceString);
    1: 
    1:               PRBool validExtension;
    1:               if (extension.IsEmpty() || 
    1:                   NS_FAILED(mimeInfo->ExtensionExists(extension,
    1:                                                       &validExtension)) ||
    1:                   !validExtension) {
    1:                 // Fix the file extension in the URL
    1:                 nsresult rv = imgUrl->Clone(getter_AddRefs(imgUri));
    1:                 NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:                 imgUrl = do_QueryInterface(imgUri);
    1: 
    1:                 nsCAutoString primaryExtension;
    1:                 mimeInfo->GetPrimaryExtension(primaryExtension);
    1: 
    1:                 imgUrl->SetFileExtension(primaryExtension);
    1:               }
    1: 
    1:               nsCAutoString fileName;
    1:               imgUrl->GetFileName(fileName);
    1: 
    1:               NS_UnescapeURL(fileName);
    1: 
    1:               // make the filename safe for the filesystem
    1:               fileName.ReplaceChar(FILE_PATH_SEPARATOR FILE_ILLEGAL_CHARACTERS,
    1:                                    '-');
    1: 
    1:               CopyUTF8toUTF16(fileName, mImageDestFileName);
    1: 
    1:               // and the image object
    1:               mImage = img;
    1:             }
    1:           }
    1:         }
    1: 
    1:         if (parentLink) {
    1:           // If we are dragging around an image in an anchor, then we
    1:           // are dragging the entire anchor
    1:           linkNode = parentLink;
    1:           nodeToSerialize = linkNode;
    1:         } else {
18445:           nodeToSerialize = do_QueryInterface(draggedNode);
    1:         }
18445:         dragNode = nodeToSerialize;
    1:       } else if (link) {
    1:         // set linkNode. The code below will handle this
18445:         linkNode = do_QueryInterface(link);    // XXX test this
    1:         GetNodeString(draggedNode, mTitleString);
    1:       } else if (parentLink) {
    1:         // parentLink will always be null if there's selected content
    1:         linkNode = parentLink;
    1:         nodeToSerialize = linkNode;
    1:       } else if (!haveSelectedContent) {
    1:         // nothing draggable
    1:         return NS_OK;
    1:       }
    1: 
    1:       if (linkNode) {
    1:         mIsAnchor = PR_TRUE;
    1:         GetAnchorURL(linkNode, mUrlString);
18445:         dragNode = linkNode;
    1:       }
    1:     }
    1:   }
    1: 
18445:   if (nodeToSerialize || *aDragSelection) {
    1:     // if we have selected text, use it in preference to the node
18445:     if (*aDragSelection) {
    1:       nodeToSerialize = nsnull;
    1:     }
    1: 
42637:     mHtmlString.Truncate();
42637:     mContextString.Truncate();
42637:     mInfoString.Truncate();
42637:     mTitleString.Truncate();
42637:     nsCOMPtr<nsITransferable> transferable;
42637:     rv = ::GetTransferableForNodeOrSelection(mWindow, nodeToSerialize,
42637:                                              getter_AddRefs(transferable));
42637:     NS_ENSURE_SUCCESS(rv, rv);
42637:     nsCOMPtr<nsISupportsString> data;
42637:     PRUint32 dataSize;
42637:     rv = transferable->GetTransferData(kHTMLMime, getter_AddRefs(data), &dataSize);
42637:     if (NS_SUCCEEDED(rv)) {
42637:       data->GetData(mHtmlString);
42637:     }
42637:     rv = transferable->GetTransferData(kHTMLContext, getter_AddRefs(data), &dataSize);
42637:     if (NS_SUCCEEDED(rv)) {
42637:       data->GetData(mContextString);
42637:     }
42637:     rv = transferable->GetTransferData(kHTMLInfo, getter_AddRefs(data), &dataSize);
42637:     if (NS_SUCCEEDED(rv)) {
42637:       data->GetData(mInfoString);
42637:     }
42637:     rv = transferable->GetTransferData(kUnicodeMime, getter_AddRefs(data), &dataSize);
42637:     NS_ENSURE_SUCCESS(rv, rv); // require plain text at a minimum
42637:     data->GetData(mTitleString);
    1:   }
    1: 
    1:   // default text value is the URL
    1:   if (mTitleString.IsEmpty()) {
    1:     mTitleString = mUrlString;
    1:   }
    1: 
    1:   // if we haven't constructed a html version, make one now
    1:   if (mHtmlString.IsEmpty() && !mUrlString.IsEmpty())
    1:     CreateLinkText(mUrlString, mTitleString, mHtmlString);
    1: 
18445:   // if there is no drag node, which will be the case for a selection, just
18445:   // use the selection target node.
42637:   rv = AddStringsToDataTransfer(
18445:          dragNode ? dragNode : mSelectionTargetNode.get(), aDataTransfer);
18445:   NS_ENSURE_SUCCESS(rv, rv);
18445: 
18445:   NS_IF_ADDREF(*aDragNode = dragNode);
18445:   return NS_OK;
18445: }
18445: 
18445: void
40970: DragDataProducer::AddString(nsDOMDataTransfer* aDataTransfer,
18445:                             const nsAString& aFlavor,
18445:                             const nsAString& aData,
18445:                             nsIPrincipal* aPrincipal)
18445: {
18445:   nsCOMPtr<nsIWritableVariant> variant = do_CreateInstance(NS_VARIANT_CONTRACTID);
18445:   if (variant) {
18445:     variant->SetAsAString(aData);
18445:     aDataTransfer->SetDataWithPrincipal(aFlavor, variant, 0, aPrincipal);
18445:   }
    1: }
    1: 
    1: nsresult
40970: DragDataProducer::AddStringsToDataTransfer(nsIContent* aDragNode,
18445:                                            nsDOMDataTransfer* aDataTransfer)
    1: {
18445:   NS_ASSERTION(aDragNode, "adding strings for null node");
18445: 
18445:   // set all of the data to have the principal of the node where the data came from
18445:   nsIPrincipal* principal = aDragNode->NodePrincipal();
    1: 
    1:   // add a special flavor if we're an anchor to indicate that we have
    1:   // a URL in the drag data
    1:   if (!mUrlString.IsEmpty() && mIsAnchor) {
    1:     nsAutoString dragData(mUrlString);
    1:     dragData.AppendLiteral("\n");
    1:     dragData += mTitleString;
    1: 
18445:     AddString(aDataTransfer, NS_LITERAL_STRING(kURLMime), dragData, principal);
18445:     AddString(aDataTransfer, NS_LITERAL_STRING(kURLDataMime), mUrlString, principal);
18445:     AddString(aDataTransfer, NS_LITERAL_STRING(kURLDescriptionMime), mTitleString, principal);
18445:     AddString(aDataTransfer, NS_LITERAL_STRING("text/uri-list"), mUrlString, principal);
    1:   }
    1: 
    1:   // add a special flavor, even if we don't have html context data
18445:   AddString(aDataTransfer, NS_LITERAL_STRING(kHTMLContext), mContextString, principal);
    1: 
    1:   // add a special flavor if we have html info data
18445:   if (!mInfoString.IsEmpty())
18445:     AddString(aDataTransfer, NS_LITERAL_STRING(kHTMLInfo), mInfoString, principal);
    1: 
    1:   // add the full html
18445:   AddString(aDataTransfer, NS_LITERAL_STRING(kHTMLMime), mHtmlString, principal);
    1: 
18445:   // add the plain text. we use the url for text/plain data if an anchor is
18445:   // being dragged, rather than the title text of the link or the alt text for
18445:   // an anchor image.
18445:   AddString(aDataTransfer, NS_LITERAL_STRING(kTextMime),
18445:             mIsAnchor ? mUrlString : mTitleString, principal);
    1: 
    1:   // add image data, if present. For now, all we're going to do with
    1:   // this is turn it into a native data flavor, so indicate that with
    1:   // a new flavor so as not to confuse anyone who is really registered
    1:   // for image/gif or image/jpg.
    1:   if (mImage) {
18445:     nsCOMPtr<nsIWritableVariant> variant = do_CreateInstance(NS_VARIANT_CONTRACTID);
18445:     if (variant) {
18445:       variant->SetAsISupports(mImage);
18445:       aDataTransfer->SetDataWithPrincipal(NS_LITERAL_STRING(kNativeImageMime),
18445:                                           variant, 0, principal);
18445:     }
    1: 
    1:     // assume the image comes from a file, and add a file promise. We
    1:     // register ourselves as a nsIFlavorDataProvider, and will use the
    1:     // GetFlavorData callback to save the image to disk.
    1: 
18445:     nsCOMPtr<nsIFlavorDataProvider> dataProvider =
18445:       new nsContentAreaDragDropDataProvider();
18445:     if (dataProvider) {
18445:       nsCOMPtr<nsIWritableVariant> variant = do_CreateInstance(NS_VARIANT_CONTRACTID);
18445:       if (variant) {
18445:         variant->SetAsISupports(dataProvider);
18445:         aDataTransfer->SetDataWithPrincipal(NS_LITERAL_STRING(kFilePromiseMime),
18445:                                             variant, 0, principal);
18445:       }
18445:     }
    1: 
18445:     AddString(aDataTransfer, NS_LITERAL_STRING(kFilePromiseURLMime),
18445:               mImageSourceString, principal);
18445:     AddString(aDataTransfer, NS_LITERAL_STRING(kFilePromiseDestFilename),
18445:               mImageDestFileName, principal);
    1: 
    1:     // if not an anchor, add the image url
    1:     if (!mIsAnchor) {
18445:       AddString(aDataTransfer, NS_LITERAL_STRING(kURLDataMime), mUrlString, principal);
18445:       AddString(aDataTransfer, NS_LITERAL_STRING("text/uri-list"), mUrlString, principal);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // note that this can return NS_OK, but a null out param (by design)
    1: // static
    1: nsresult
40970: DragDataProducer::GetDraggableSelectionData(nsISelection* inSelection,
18445:                                             nsIContent* inRealTargetNode,
18445:                                             nsIContent **outImageOrLinkNode,
    1:                                             PRBool* outDragSelectedText)
    1: {
    1:   NS_ENSURE_ARG(inSelection);
    1:   NS_ENSURE_ARG(inRealTargetNode);
    1:   NS_ENSURE_ARG_POINTER(outImageOrLinkNode);
    1: 
    1:   *outImageOrLinkNode = nsnull;
    1:   *outDragSelectedText = PR_FALSE;
    1: 
    1:   PRBool selectionContainsTarget = PR_FALSE;
    1: 
    1:   PRBool isCollapsed = PR_FALSE;
    1:   inSelection->GetIsCollapsed(&isCollapsed);
    1:   if (!isCollapsed) {
18445:     nsCOMPtr<nsIDOMNode> realTargetNode = do_QueryInterface(inRealTargetNode);
18445:     inSelection->ContainsNode(realTargetNode, PR_FALSE,
    1:                               &selectionContainsTarget);
    1: 
    1:     if (selectionContainsTarget) {
    1:       // track down the anchor node, if any, for the url
    1:       nsCOMPtr<nsIDOMNode> selectionStart;
    1:       inSelection->GetAnchorNode(getter_AddRefs(selectionStart));
    1: 
    1:       nsCOMPtr<nsIDOMNode> selectionEnd;
    1:       inSelection->GetFocusNode(getter_AddRefs(selectionEnd));
    1: 
    1:       // look for a selection around a single node, like an image.
    1:       // in this case, drag the image, rather than a serialization of the HTML
    1:       // XXX generalize this to other draggable element types?
    1:       if (selectionStart == selectionEnd) {
    1:         PRBool hasChildren;
    1:         selectionStart->HasChildNodes(&hasChildren);
    1:         if (hasChildren) {
    1:           // see if just one node is selected
    1:           PRInt32 anchorOffset, focusOffset;
    1:           inSelection->GetAnchorOffset(&anchorOffset);
    1:           inSelection->GetFocusOffset(&focusOffset);
    1:           if (abs(anchorOffset - focusOffset) == 1) {
    1:             nsCOMPtr<nsIContent> selStartContent =
    1:               do_QueryInterface(selectionStart);
    1: 
    1:             if (selStartContent) {
    1:               PRInt32 childOffset =
    1:                 (anchorOffset < focusOffset) ? anchorOffset : focusOffset;
    1:               nsIContent *childContent =
    1:                 selStartContent->GetChildAt(childOffset);
    1:               // if we find an image, we'll fall into the node-dragging code,
    1:               // rather the the selection-dragging code
    1:               if (nsContentUtils::IsDraggableImage(childContent)) {
18445:                 NS_ADDREF(*outImageOrLinkNode = childContent);
    1:                 return NS_OK;
    1:               }
    1:             }
    1:           }
    1:         }
    1:       }
    1: 
    1:       // see if the selection is a link;  if so, its node will be returned
    1:       GetSelectedLink(inSelection, outImageOrLinkNode);
    1: 
    1:       // indicate that a link or text is selected
    1:       *outDragSelectedText = PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // static
40970: void
40970: DragDataProducer::GetSelectedLink(nsISelection* inSelection,
18445:                                   nsIContent **outLinkNode)
    1: {
    1:   *outLinkNode = nsnull;
    1: 
18445:   nsCOMPtr<nsIDOMNode> selectionStartNode;
18445:   inSelection->GetAnchorNode(getter_AddRefs(selectionStartNode));
18445:   nsCOMPtr<nsIDOMNode> selectionEndNode;
18445:   inSelection->GetFocusNode(getter_AddRefs(selectionEndNode));
    1: 
    1:   // simple case:  only one node is selected
    1:   // see if it or its parent is an anchor, then exit
    1: 
18445:   if (selectionStartNode == selectionEndNode) {
18445:     nsCOMPtr<nsIContent> selectionStart = do_QueryInterface(selectionStartNode);
18445:     nsCOMPtr<nsIContent> link = FindParentLinkNode(selectionStart);
    1:     if (link) {
    1:       link.swap(*outLinkNode);
    1:     }
    1: 
    1:     return;
    1:   }
    1: 
    1:   // more complicated case:  multiple nodes are selected
    1: 
    1:   // Unless you use the Alt key while selecting anchor text, it is
    1:   // nearly impossible to avoid overlapping into adjacent nodes.
    1:   // Deal with this by trimming off the leading and/or trailing
    1:   // nodes of the selection if the strings they produce are empty.
    1: 
    1:   // first, use a range determine if the selection was marked LTR or RTL;
    1:   // if the latter, swap endpoints so we trim in the right direction
    1: 
    1:   PRInt32 startOffset, endOffset;
    1:   {
    1:     nsCOMPtr<nsIDOMRange> range;
    1:     inSelection->GetRangeAt(0, getter_AddRefs(range));
    1:     if (!range) {
    1:       return;
    1:     }
    1: 
    1:     nsCOMPtr<nsIDOMNode> tempNode;
    1:     range->GetStartContainer( getter_AddRefs(tempNode));
18445:     if (tempNode != selectionStartNode) {
18445:       selectionEndNode = selectionStartNode;
18445:       selectionStartNode = tempNode;
    1:       inSelection->GetAnchorOffset(&endOffset);
    1:       inSelection->GetFocusOffset(&startOffset);
    1:     } else {
    1:       inSelection->GetAnchorOffset(&startOffset);
    1:       inSelection->GetFocusOffset(&endOffset);
    1:     }
    1:   }
    1: 
    1:   // trim leading node if the string is empty or
    1:   // the selection starts at the end of the text
    1: 
    1:   nsAutoString nodeStr;
18445:   selectionStartNode->GetNodeValue(nodeStr);
    1:   if (nodeStr.IsEmpty() ||
 3233:       startOffset+1 >= static_cast<PRInt32>(nodeStr.Length())) {
18445:     nsCOMPtr<nsIDOMNode> curr = selectionStartNode;
    1:     nsIDOMNode* next;
    1: 
    1:     while (curr) {
    1:       curr->GetNextSibling(&next);
    1: 
    1:       if (next) {
18445:         selectionStartNode = dont_AddRef(next);
    1:         break;
    1:       }
    1: 
    1:       curr->GetParentNode(&next);
    1:       curr = dont_AddRef(next);
    1:     }
    1:   }
    1: 
    1:   // trim trailing node if the selection ends before its text begins
    1: 
    1:   if (endOffset == 0) {
18445:     nsCOMPtr<nsIDOMNode> curr = selectionEndNode;
    1:     nsIDOMNode* next;
    1: 
    1:     while (curr) {
    1:       curr->GetPreviousSibling(&next);
    1: 
    1:       if (next){
18445:         selectionEndNode = dont_AddRef(next);
    1:         break;
    1:       }
    1: 
    1:       curr->GetParentNode(&next);
    1:       curr = dont_AddRef(next);
    1:     }
    1:   }
    1: 
    1:   // see if the leading & trailing nodes are part of the
    1:   // same anchor - if so, return the anchor node
18445:   nsCOMPtr<nsIContent> selectionStart = do_QueryInterface(selectionStartNode);
18445:   nsCOMPtr<nsIContent> link = FindParentLinkNode(selectionStart);
    1:   if (link) {
18445:     nsCOMPtr<nsIContent> selectionEnd = do_QueryInterface(selectionEndNode);
18445:     nsCOMPtr<nsIContent> link2 = FindParentLinkNode(selectionEnd);
    1: 
    1:     if (link == link2) {
    1:       NS_IF_ADDREF(*outLinkNode = link);
    1:     }
    1:   }
    1: 
    1:   return;
    1: }
