    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* nsJARInputStream.cpp
    1:  * 
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Netscape Communicator source code. 
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1999
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Mitch Stoltz <mstoltz@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsJARInputStream.h"
    1: #include "zipstruct.h"         // defines ZIP compression codes
    1: #include "nsZipArchive.h"
    1: 
    1: #include "nsNetUtil.h"
    1: #include "nsEscape.h"
    1: #include "nsIFile.h"
    1: 
    1: /*---------------------------------------------
    1:  *  nsISupports implementation
    1:  *--------------------------------------------*/
    1: 
    1: NS_IMPL_THREADSAFE_ISUPPORTS1(nsJARInputStream, nsIInputStream)
    1: 
    1: /*----------------------------------------------------------
    1:  * nsJARInputStream implementation
    1:  *--------------------------------------------------------*/
    1: 
    1: nsresult
    1: nsJARInputStream::InitFile(nsZipArchive* aZip, nsZipItem *item, PRFileDesc *fd)
    1: {
    1:     nsresult rv;
    1: 
    1:     // Keep the file handle, even on failure
    1:     mFd = fd;
    1:       
    1:     NS_ENSURE_ARG_POINTER(aZip);
    1:     NS_ENSURE_ARG_POINTER(item);
    1:     NS_ENSURE_ARG_POINTER(fd);
    1: 
    1:     // Mark it as closed, in case something fails in initialisation
    1:     mClosed = PR_TRUE;
    1: 
    1:     // Keep the important bits of nsZipItem only
    1:     mInSize = item->size;
    1:  
    1:     //-- prepare for the compression type
    1:     switch (item->compression) {
    1:        case STORED: 
    1:            break;
    1: 
    1:        case DEFLATED:
    1:            mInflate = (InflateStruct *) PR_Malloc(sizeof(InflateStruct));
    1:            NS_ENSURE_TRUE(mInflate, NS_ERROR_OUT_OF_MEMORY);
    1:     
    1:            rv = gZlibInit(&(mInflate->mZs));
    1:            NS_ENSURE_SUCCESS(rv, NS_ERROR_OUT_OF_MEMORY);
    1:     
    1:            mInflate->mOutSize = item->realsize;
    1:            mInflate->mInCrc = item->crc32;
    1:            mInflate->mOutCrc = crc32(0L, Z_NULL, 0);
    1:            break;
    1: 
    1:        default:
    1:            return NS_ERROR_NOT_IMPLEMENTED;
    1:     }
    1:    
    1:     //-- Set filepointer to start of item
    1:     rv = aZip->SeekToItem(item, mFd);
    1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FILE_CORRUPTED);
    1:         
    1:     // Open for reading
    1:     mClosed = PR_FALSE;
    1:     mCurPos = 0;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsJARInputStream::InitDirectory(nsZipArchive* aZip,
    1:                                 const nsACString& aJarDirSpec,
    1:                                 const char* aDir)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aZip);
    1:     NS_ENSURE_ARG_POINTER(aDir);
    1: 
    1:     // Mark it as closed, in case something fails in initialisation
    1:     mClosed = PR_TRUE;
    1:     mDirectory = PR_TRUE;
    1:     
    1:     // Keep the zipReader for getting the actual zipItems
    1:     mZip = aZip;
    1:     nsZipFind *find;
    1:     nsresult rv;
    1:     // We can get aDir's contents as strings via FindEntries
    1:     // with the following pattern (see nsIZipReader.findEntries docs)
    1:     // assuming dirName is properly escaped:
    1:     //
    1:     //   dirName + "?*~" + dirName + "?*/?*"
    1:     nsDependentCString dirName(aDir);
    1:     mNameLen = dirName.Length();
    1: 
    1:     // iterate through dirName and copy it to escDirName, escaping chars
    1:     // which are special at the "top" level of the regexp so FindEntries
    1:     // works correctly
    1:     nsCAutoString escDirName;
    1:     const char* curr = dirName.BeginReading();
    1:     const char* end  = dirName.EndReading();
    1:     while (curr != end) {
    1:         switch (*curr) {
    1:             case '*':
    1:             case '?':
    1:             case '$':
    1:             case '[':
    1:             case ']':
    1:             case '^':
    1:             case '~':
    1:             case '(':
    1:             case ')':
    1:             case '\\':
    1:                 escDirName.Append('\\');
    1:                 // fall through
    1:             default:
    1:                 escDirName.Append(*curr);
    1:         }
    1:         ++curr;
    1:     }
    1:     nsCAutoString pattern = escDirName + NS_LITERAL_CSTRING("?*~") +
    1:                             escDirName + NS_LITERAL_CSTRING("?*/?*");
    1:     rv = aZip->FindInit(pattern.get(), &find);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     const char *name;
    1:     while ((rv = find->FindNext( &name )) == NS_OK) {
    1:         // No need to copy string, just share the one from nsZipArchive
    1:         mArray.AppendCString(nsDependentCString(name));
    1:     }
    1:     delete find;
    1: 
    1:     if (rv != NS_ERROR_FILE_TARGET_DOES_NOT_EXIST && NS_FAILED(rv)) {
    1:         return NS_ERROR_FAILURE;    // no error translation
    1:     }
    1: 
    1:     // Sort it
    1:     mArray.Sort();
    1: 
    1:     mBuffer.AssignLiteral("300: ");
    1:     mBuffer.Append(aJarDirSpec);
    1:     mBuffer.AppendLiteral("\n200: filename content-length last-modified file-type\n");
    1: 
    1:     // Open for reading
    1:     mClosed = PR_FALSE;
    1:     mCurPos = 0;
    1:     mArrPos = 0;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsJARInputStream::Available(PRUint32 *_retval)
    1: {
    1:     if (mClosed)
    1:         return NS_BASE_STREAM_CLOSED;
    1: 
    1:     if (mDirectory)
    1:         *_retval = mBuffer.Length();
    1:     else if (mInflate) 
    1:         *_retval = mInflate->mOutSize - mInflate->mZs.total_out;
    1:     else 
    1:         *_retval = mInSize - mCurPos;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsJARInputStream::Read(char* aBuffer, PRUint32 aCount, PRUint32 *aBytesRead)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aBuffer);
    1:     NS_ENSURE_ARG_POINTER(aBytesRead);
    1: 
    1:     *aBytesRead = 0;
    1: 
    1:     nsresult rv = NS_OK;
    1:     if (mClosed)
    1:         return rv;
    1: 
    1:     if (mDirectory) {
    1:         rv = ReadDirectory(aBuffer, aCount, aBytesRead);
    1:     } else {
    1:         if (mInflate) {
    1:             rv = ContinueInflate(aBuffer, aCount, aBytesRead);
    1:         } else {
    1:             PRInt32 bytesRead = 0;
    1:             aCount = PR_MIN(aCount, mInSize - mCurPos);
    1:             if (aCount) {
    1:                 bytesRead = PR_Read(mFd, aBuffer, aCount);
    1:                 if (bytesRead < 0)
    1:                     return NS_ERROR_FILE_CORRUPTED;
    1:                 mCurPos += bytesRead;
13296:                 if (bytesRead != aCount) {
13296:                     // file is truncated or was lying about size, we're done
13296:                     PR_Close(mFd);
13296:                     mFd = nsnull;
13296:                     return NS_ERROR_FILE_CORRUPTED;
13296:                 }
    1:             }
    1:             *aBytesRead = bytesRead;
    1:         }
    1: 
    1:         // be aggressive about closing!
    1:         // note that sometimes, we will close mFd before we've finished
    1:         // deflating - this is because zlib buffers the input
    1:         // So, don't free the ReadBuf/InflateStruct yet.
    1:         if (mCurPos >= mInSize && mFd) {
    1:             PR_Close(mFd);
    1:             mFd = nsnull;
    1:         }
    1:     }
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsJARInputStream::ReadSegments(nsWriteSegmentFun writer, void * closure, PRUint32 count, PRUint32 *_retval)
    1: {
    1:     // don't have a buffer to read from, so this better not be called!
    1:     NS_NOTREACHED("Consumers should be using Read()!");
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsJARInputStream::IsNonBlocking(PRBool *aNonBlocking)
    1: {
    1:     *aNonBlocking = PR_FALSE;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsJARInputStream::Close()
    1: {
    1:     PR_FREEIF(mInflate);
    1:     if (mFd) {
    1:         PR_Close(mFd);
    1:         mFd = nsnull;
    1:     }
    1:     mClosed = PR_TRUE;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult 
    1: nsJARInputStream::ContinueInflate(char* aBuffer, PRUint32 aCount,
    1:                                   PRUint32* aBytesRead)
    1: {
    1:     // No need to check the args, ::Read did that, but assert them at least
    1:     NS_ASSERTION(mInflate,"inflate data structure missing");
    1:     NS_ASSERTION(aBuffer,"aBuffer parameter must not be null");
    1:     NS_ASSERTION(aBytesRead,"aBytesRead parameter must not be null");
    1: 
    1:     // Keep old total_out count
    1:     const PRUint32 oldTotalOut = mInflate->mZs.total_out;
    1:     
    1:     // make sure we aren't reading too much
    1:     mInflate->mZs.avail_out = (mInflate->mOutSize-oldTotalOut > aCount) ? aCount : mInflate->mOutSize-oldTotalOut;
    1:     mInflate->mZs.next_out = (unsigned char*)aBuffer;
    1: 
    1:     int zerr = Z_OK;
    1:     //-- inflate loop
    1:     while (mInflate->mZs.avail_out > 0 && zerr == Z_OK) {
    1: 
    1:         if (mInflate->mZs.avail_in == 0 && mCurPos < mInSize) {
    1:             // time to fill the buffer!
    1:             PRUint32 bytesToRead = PR_MIN(mInSize - mCurPos, ZIP_BUFLEN);
    1: 
    1:             NS_ASSERTION(mFd, "File handle missing");
    1:             PRInt32 bytesRead = PR_Read(mFd, mInflate->mReadBuf, bytesToRead);
    1:             if (bytesRead < 0) {
    1:                 zerr = Z_ERRNO;
    1:                 break;
    1:             }
    1:             mCurPos += bytesRead;
    1: 
    1:             // now set the state for 'inflate'
    1:             mInflate->mZs.next_in = mInflate->mReadBuf;
    1:             mInflate->mZs.avail_in = bytesRead;
    1:         }
    1: 
    1:         // now inflate
    1:         zerr = inflate(&(mInflate->mZs), Z_SYNC_FLUSH);
    1:     }
    1: 
    1:     if ((zerr != Z_OK) && (zerr != Z_STREAM_END))
    1:         return NS_ERROR_FILE_CORRUPTED;
    1: 
    1:     *aBytesRead = (mInflate->mZs.total_out - oldTotalOut);
    1: 
    1:     // Calculate the CRC on the output
    1:     mInflate->mOutCrc = crc32(mInflate->mOutCrc, (unsigned char*)aBuffer, *aBytesRead);
    1: 
    1:     // be aggressive about ending the inflation
    1:     // for some reason we don't always get Z_STREAM_END
    1:     if (zerr == Z_STREAM_END || mInflate->mZs.total_out == mInflate->mOutSize) {
    1:         inflateEnd(&(mInflate->mZs));
    1: 
    1:         // stop returning valid data as soon as we know we have a bad CRC
    1:         if (mInflate->mOutCrc != mInflate->mInCrc) {
    1:             // asserting because while this rarely happens, you definitely
    1:             // want to catch it in debug builds!
    1:             NS_NOTREACHED(0);
    1:             return NS_ERROR_FILE_CORRUPTED;
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsJARInputStream::ReadDirectory(char* aBuffer, PRUint32 aCount, PRUint32 *aBytesRead)
    1: {
    1:     // No need to check the args, ::Read did that, but assert them at least
    1:     NS_ASSERTION(aBuffer,"aBuffer parameter must not be null");
    1:     NS_ASSERTION(aBytesRead,"aBytesRead parameter must not be null");
    1: 
    1:     // If the buffer contains data, copy what's there up to the desired amount
    1:     PRUint32 numRead = CopyDataToBuffer(aBuffer, aCount);
    1: 
    1:     if (aCount > 0) {
    1:         // empty the buffer and start writing directory entry lines to it
    1:         mBuffer.Truncate();
    1:         mCurPos = 0;
    1:         const PRUint32 arrayLen = mArray.Count();
    1: 
    1:         for ( ;aCount > mBuffer.Length(); mArrPos++) {
    1:             // have we consumed all the directory contents?
    1:             if (arrayLen <= mArrPos)
    1:                 break;
    1: 
    1:             const char * entryName = mArray[mArrPos]->get();
    1:             PRUint32 entryNameLen = mArray[mArrPos]->Length();
    1:             nsZipItem* ze = mZip->GetItem(entryName);
    1:             NS_ENSURE_TRUE(ze, NS_ERROR_FILE_TARGET_DOES_NOT_EXIST);
    1: 
    1:             // Last Modified Time
    1:             PRExplodedTime tm;
    1:             PR_ExplodeTime(GetModTime(ze->date, ze->time), PR_GMTParameters, &tm);
    1:             char itemLastModTime[65];
    1:             PR_FormatTimeUSEnglish(itemLastModTime,
    1:                                    sizeof(itemLastModTime),
    1:                                    " %a,%%20%d%%20%b%%20%Y%%20%H:%M:%S%%20GMT ",
    1:                                    &tm);
    1: 
    1:             // write a 201: line to the buffer for this item
    1:             // 200: filename content-length last-modified file-type
    1:             mBuffer.AppendLiteral("201: ");
    1: 
    1:             // Names must be escaped and relative, so use the pre-calculated length
    1:             // of the directory name as the offset into the string
    1:             // NS_EscapeURL adds the escaped URL to the give string buffer
    1:             NS_EscapeURL(entryName + mNameLen,
    1:                          entryNameLen - mNameLen, 
    1:                          esc_Minimal | esc_AlwaysCopy,
    1:                          mBuffer);
    1: 
    1:             mBuffer.Append(' ');
    1:             mBuffer.AppendInt(ze->realsize, 10);
    1:             mBuffer.Append(itemLastModTime); // starts/ends with ' '
    1:             if (ze->isDirectory) 
    1:                 mBuffer.AppendLiteral("DIRECTORY\n");
    1:             else
    1:                 mBuffer.AppendLiteral("FILE\n");
    1:         }
    1: 
    1:         // Copy up to the desired amount of data to buffer
    1:         numRead += CopyDataToBuffer(aBuffer, aCount);
    1:     }
    1: 
    1:     *aBytesRead = numRead;
    1:     return NS_OK;
    1: }
    1: 
    1: PRUint32
    1: nsJARInputStream::CopyDataToBuffer(char* &aBuffer, PRUint32 &aCount)
    1: {
    1:     const PRUint32 writeLength = PR_MIN(aCount, mBuffer.Length() - mCurPos);
    1: 
    1:     if (writeLength > 0) {
    1:         memcpy(aBuffer, mBuffer.get() + mCurPos, writeLength);
    1:         mCurPos += writeLength;
    1:         aCount  -= writeLength;
    1:         aBuffer += writeLength;
    1:     }
    1: 
    1:     // return number of bytes copied to the buffer so the
    1:     // Read method can return the number of bytes copied
    1:     return writeLength;
    1: }
