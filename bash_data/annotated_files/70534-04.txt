29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
48470: 
18863: #include "jsversion.h"
    1: 
    1: #if JS_HAS_XDR
    1: 
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
55477: #include "jsutil.h"
    1: #include "jsdhash.h"
    1: #include "jsprf.h"
    1: #include "jsapi.h"
    1: #include "jscntxt.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"              /* js_XDRObject */
    1: #include "jsscript.h"           /* js_XDRScript */
    1: #include "jsstr.h"
    1: #include "jsxdrapi.h"
    1: 
42733: #include "jsobjinlines.h"
42733: 
48470: using namespace js;
48470: 
    1: #ifdef DEBUG
    1: #define DBG(x) x
    1: #else
    1: #define DBG(x) ((void)0)
    1: #endif
    1: 
    1: typedef struct JSXDRMemState {
    1:     JSXDRState  state;
    1:     char        *base;
    1:     uint32      count;
    1:     uint32      limit;
    1: } JSXDRMemState;
    1: 
    1: #define MEM_BLOCK       8192
    1: #define MEM_PRIV(xdr)   ((JSXDRMemState *)(xdr))
    1: 
    1: #define MEM_BASE(xdr)   (MEM_PRIV(xdr)->base)
    1: #define MEM_COUNT(xdr)  (MEM_PRIV(xdr)->count)
    1: #define MEM_LIMIT(xdr)  (MEM_PRIV(xdr)->limit)
    1: 
    1: #define MEM_LEFT(xdr, bytes)                                                  \
    1:     JS_BEGIN_MACRO                                                            \
    1:         if ((xdr)->mode == JSXDR_DECODE &&                                    \
    1:             MEM_COUNT(xdr) + bytes > MEM_LIMIT(xdr)) {                        \
    1:             JS_ReportErrorNumber((xdr)->cx, js_GetErrorMessage, NULL,         \
    1:                                  JSMSG_END_OF_DATA);                          \
    1:             return 0;                                                         \
    1:         }                                                                     \
    1:     JS_END_MACRO
    1: 
    1: #define MEM_NEED(xdr, bytes)                                                  \
    1:     JS_BEGIN_MACRO                                                            \
    1:         if ((xdr)->mode == JSXDR_ENCODE) {                                    \
    1:             if (MEM_LIMIT(xdr) &&                                             \
    1:                 MEM_COUNT(xdr) + bytes > MEM_LIMIT(xdr)) {                    \
    1:                 uint32 limit_ = JS_ROUNDUP(MEM_COUNT(xdr) + bytes, MEM_BLOCK);\
64560:                 void *data_ = (xdr)->cx->realloc_(MEM_BASE(xdr), limit_);      \
    1:                 if (!data_)                                                   \
    1:                     return 0;                                                 \
 3164:                 MEM_BASE(xdr) = (char *) data_;                               \
    1:                 MEM_LIMIT(xdr) = limit_;                                      \
    1:             }                                                                 \
    1:         } else {                                                              \
    1:             MEM_LEFT(xdr, bytes);                                             \
    1:         }                                                                     \
    1:     JS_END_MACRO
    1: 
    1: #define MEM_DATA(xdr)        ((void *)(MEM_BASE(xdr) + MEM_COUNT(xdr)))
    1: #define MEM_INCR(xdr,bytes)  (MEM_COUNT(xdr) += (bytes))
    1: 
    1: static JSBool
    1: mem_get32(JSXDRState *xdr, uint32 *lp)
    1: {
    1:     MEM_LEFT(xdr, 4);
    1:     *lp = *(uint32 *)MEM_DATA(xdr);
    1:     MEM_INCR(xdr, 4);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: mem_set32(JSXDRState *xdr, uint32 *lp)
    1: {
    1:     MEM_NEED(xdr, 4);
    1:     *(uint32 *)MEM_DATA(xdr) = *lp;
    1:     MEM_INCR(xdr, 4);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: mem_getbytes(JSXDRState *xdr, char *bytes, uint32 len)
    1: {
    1:     MEM_LEFT(xdr, len);
    1:     memcpy(bytes, MEM_DATA(xdr), len);
    1:     MEM_INCR(xdr, len);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: mem_setbytes(JSXDRState *xdr, char *bytes, uint32 len)
    1: {
    1:     MEM_NEED(xdr, len);
    1:     memcpy(MEM_DATA(xdr), bytes, len);
    1:     MEM_INCR(xdr, len);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static void *
    1: mem_raw(JSXDRState *xdr, uint32 len)
    1: {
    1:     void *data;
    1:     if (xdr->mode == JSXDR_ENCODE) {
    1:         MEM_NEED(xdr, len);
    1:     } else if (xdr->mode == JSXDR_DECODE) {
    1:         MEM_LEFT(xdr, len);
    1:     }
    1:     data = MEM_DATA(xdr);
    1:     MEM_INCR(xdr, len);
    1:     return data;
    1: }
    1: 
    1: static JSBool
    1: mem_seek(JSXDRState *xdr, int32 offset, JSXDRWhence whence)
    1: {
    1:     switch (whence) {
    1:       case JSXDR_SEEK_CUR:
    1:         if ((int32)MEM_COUNT(xdr) + offset < 0) {
    1:             JS_ReportErrorNumber(xdr->cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_SEEK_BEYOND_START);
    1:             return JS_FALSE;
    1:         }
    1:         if (offset > 0)
    1:             MEM_NEED(xdr, offset);
    1:         MEM_COUNT(xdr) += offset;
    1:         return JS_TRUE;
    1:       case JSXDR_SEEK_SET:
    1:         if (offset < 0) {
    1:             JS_ReportErrorNumber(xdr->cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_SEEK_BEYOND_START);
    1:             return JS_FALSE;
    1:         }
    1:         if (xdr->mode == JSXDR_ENCODE) {
    1:             if ((uint32)offset > MEM_COUNT(xdr))
    1:                 MEM_NEED(xdr, offset - MEM_COUNT(xdr));
    1:             MEM_COUNT(xdr) = offset;
    1:         } else {
    1:             if ((uint32)offset > MEM_LIMIT(xdr)) {
    1:                 JS_ReportErrorNumber(xdr->cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_SEEK_BEYOND_END);
    1:                 return JS_FALSE;
    1:             }
    1:             MEM_COUNT(xdr) = offset;
    1:         }
    1:         return JS_TRUE;
    1:       case JSXDR_SEEK_END:
    1:         if (offset >= 0 ||
    1:             xdr->mode == JSXDR_ENCODE ||
    1:             (int32)MEM_LIMIT(xdr) + offset < 0) {
    1:             JS_ReportErrorNumber(xdr->cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_END_SEEK);
    1:             return JS_FALSE;
    1:         }
    1:         MEM_COUNT(xdr) = MEM_LIMIT(xdr) + offset;
    1:         return JS_TRUE;
    1:       default: {
    1:         char numBuf[12];
    1:         JS_snprintf(numBuf, sizeof numBuf, "%d", whence);
    1:         JS_ReportErrorNumber(xdr->cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_WHITHER_WHENCE, numBuf);
    1:         return JS_FALSE;
    1:       }
    1:     }
    1: }
    1: 
    1: static uint32
    1: mem_tell(JSXDRState *xdr)
    1: {
    1:     return MEM_COUNT(xdr);
    1: }
    1: 
    1: static void
    1: mem_finalize(JSXDRState *xdr)
    1: {
64560:     xdr->cx->free_(MEM_BASE(xdr));
    1: }
    1: 
    1: static JSXDROps xdrmem_ops = {
    1:     mem_get32,      mem_set32,      mem_getbytes,   mem_setbytes,
    1:     mem_raw,        mem_seek,       mem_tell,       mem_finalize
    1: };
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_XDRInitBase(JSXDRState *xdr, JSXDRMode mode, JSContext *cx)
    1: {
    1:     xdr->mode = mode;
    1:     xdr->cx = cx;
    1:     xdr->registry = NULL;
    1:     xdr->numclasses = xdr->maxclasses = 0;
    1:     xdr->reghash = NULL;
    1:     xdr->userdata = NULL;
    1:     xdr->script = NULL;
    1: }
    1: 
    1: JS_PUBLIC_API(JSXDRState *)
    1: JS_XDRNewMem(JSContext *cx, JSXDRMode mode)
    1: {
64560:     JSXDRState *xdr = (JSXDRState *) cx->malloc_(sizeof(JSXDRMemState));
    1:     if (!xdr)
    1:         return NULL;
    1:     JS_XDRInitBase(xdr, mode, cx);
    1:     if (mode == JSXDR_ENCODE) {
64560:         if (!(MEM_BASE(xdr) = (char *) cx->malloc_(MEM_BLOCK))) {
64560:             cx->free_(xdr);
    1:             return NULL;
    1:         }
    1:     } else {
    1:         /* XXXbe ok, so better not deref MEM_BASE(xdr) if not ENCODE */
    1:         MEM_BASE(xdr) = NULL;
    1:     }
    1:     xdr->ops = &xdrmem_ops;
    1:     MEM_COUNT(xdr) = 0;
    1:     MEM_LIMIT(xdr) = MEM_BLOCK;
    1:     return xdr;
    1: }
    1: 
    1: JS_PUBLIC_API(void *)
    1: JS_XDRMemGetData(JSXDRState *xdr, uint32 *lp)
    1: {
    1:     if (xdr->ops != &xdrmem_ops)
    1:         return NULL;
    1:     *lp = MEM_COUNT(xdr);
    1:     return MEM_BASE(xdr);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_XDRMemSetData(JSXDRState *xdr, void *data, uint32 len)
    1: {
    1:     if (xdr->ops != &xdrmem_ops)
    1:         return;
    1:     MEM_LIMIT(xdr) = len;
 3164:     MEM_BASE(xdr) = (char *) data;
    1:     MEM_COUNT(xdr) = 0;
    1: }
    1: 
    1: JS_PUBLIC_API(uint32)
    1: JS_XDRMemDataLeft(JSXDRState *xdr)
    1: {
    1:     if (xdr->ops != &xdrmem_ops)
    1:         return 0;
    1:     return MEM_LIMIT(xdr) - MEM_COUNT(xdr);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_XDRMemResetData(JSXDRState *xdr)
    1: {
    1:     if (xdr->ops != &xdrmem_ops)
    1:         return;
    1:     MEM_COUNT(xdr) = 0;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_XDRDestroy(JSXDRState *xdr)
    1: {
    1:     JSContext *cx = xdr->cx;
    1:     xdr->ops->finalize(xdr);
    1:     if (xdr->registry) {
64560:         cx->free_(xdr->registry);
    1:         if (xdr->reghash)
 3164:             JS_DHashTableDestroy((JSDHashTable *) xdr->reghash);
    1:     }
64560:     cx->free_(xdr);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_XDRUint8(JSXDRState *xdr, uint8 *b)
    1: {
    1:     uint32 l = *b;
    1:     if (!JS_XDRUint32(xdr, &l))
    1:         return JS_FALSE;
    1:     *b = (uint8) l;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_XDRUint16(JSXDRState *xdr, uint16 *s)
    1: {
    1:     uint32 l = *s;
    1:     if (!JS_XDRUint32(xdr, &l))
    1:         return JS_FALSE;
    1:     *s = (uint16) l;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_XDRUint32(JSXDRState *xdr, uint32 *lp)
    1: {
    1:     JSBool ok = JS_TRUE;
    1:     if (xdr->mode == JSXDR_ENCODE) {
    1:         uint32 xl = JSXDR_SWAB32(*lp);
    1:         ok = xdr->ops->set32(xdr, &xl);
    1:     } else if (xdr->mode == JSXDR_DECODE) {
    1:         ok = xdr->ops->get32(xdr, lp);
    1:         *lp = JSXDR_SWAB32(*lp);
    1:     }
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_XDRBytes(JSXDRState *xdr, char *bytes, uint32 len)
    1: {
    1:     uint32 padlen;
    1:     static char padbuf[JSXDR_ALIGN-1];
    1: 
    1:     if (xdr->mode == JSXDR_ENCODE) {
    1:         if (!xdr->ops->setbytes(xdr, bytes, len))
    1:             return JS_FALSE;
    1:     } else {
    1:         if (!xdr->ops->getbytes(xdr, bytes, len))
    1:             return JS_FALSE;
    1:     }
    1:     len = xdr->ops->tell(xdr);
    1:     if (len % JSXDR_ALIGN) {
    1:         padlen = JSXDR_ALIGN - (len % JSXDR_ALIGN);
    1:         if (xdr->mode == JSXDR_ENCODE) {
    1:             if (!xdr->ops->setbytes(xdr, padbuf, padlen))
    1:                 return JS_FALSE;
    1:         } else {
    1:             if (!xdr->ops->seek(xdr, padlen, JSXDR_SEEK_CUR))
    1:                 return JS_FALSE;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: /**
    1:  * Convert between a C string and the XDR representation:
    1:  * leading 32-bit count, then counted vector of chars,
    1:  * then possibly \0 padding to multiple of 4.
    1:  */
    1: JS_PUBLIC_API(JSBool)
    1: JS_XDRCString(JSXDRState *xdr, char **sp)
    1: {
    1:     uint32 len;
    1: 
    1:     if (xdr->mode == JSXDR_ENCODE)
    1:         len = strlen(*sp);
    1:     JS_XDRUint32(xdr, &len);
    1:     if (xdr->mode == JSXDR_DECODE) {
64560:         if (!(*sp = (char *) xdr->cx->malloc_(len + 1)))
    1:             return JS_FALSE;
    1:     }
    1:     if (!JS_XDRBytes(xdr, *sp, len)) {
    1:         if (xdr->mode == JSXDR_DECODE)
64560:             xdr->cx->free_(*sp);
    1:         return JS_FALSE;
    1:     }
    1:     if (xdr->mode == JSXDR_DECODE) {
    1:         (*sp)[len] = '\0';
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_XDRCStringOrNull(JSXDRState *xdr, char **sp)
    1: {
    1:     uint32 null = (*sp == NULL);
    1:     if (!JS_XDRUint32(xdr, &null))
    1:         return JS_FALSE;
    1:     if (null) {
    1:         *sp = NULL;
    1:         return JS_TRUE;
    1:     }
    1:     return JS_XDRCString(xdr, sp);
    1: }
    1: 
70534: static JSBool
70534: XDRChars(JSXDRState *xdr, jschar *chars, uint32 nchars)
70534: {
70534:     uint32 i, padlen, nbytes;
70534:     jschar *raw;
70534: 
70534:     nbytes = nchars * sizeof(jschar);
70534:     padlen = nbytes % JSXDR_ALIGN;
70534:     if (padlen) {
70534:         padlen = JSXDR_ALIGN - padlen;
70534:         nbytes += padlen;
70534:     }
70534:     if (!(raw = (jschar *) xdr->ops->raw(xdr, nbytes)))
70534:         return JS_FALSE;
70534:     if (xdr->mode == JSXDR_ENCODE) {
70534:         for (i = 0; i != nchars; i++)
70534:             raw[i] = JSXDR_SWAB16(chars[i]);
70534:         if (padlen)
70534:             memset((char *)raw + nbytes - padlen, 0, padlen);
70534:     } else if (xdr->mode == JSXDR_DECODE) {
70534:         for (i = 0; i != nchars; i++)
70534:             chars[i] = JSXDR_SWAB16(raw[i]);
70534:     }
70534:     return JS_TRUE;
70534: }
70534: 
    1: /*
    1:  * Convert between a JS (Unicode) string and the XDR representation.
    1:  */
    1: JS_PUBLIC_API(JSBool)
    1: JS_XDRString(JSXDRState *xdr, JSString **strp)
    1: {
70534:     uint32 nchars;
70534:     jschar *chars;
    1: 
70534:     if (xdr->mode == JSXDR_ENCODE)
70534:         nchars = (*strp)->length();
70534:     if (!JS_XDRUint32(xdr, &nchars))
70534:         return JS_FALSE;
70534: 
70534:     if (xdr->mode == JSXDR_DECODE)
70534:         chars = (jschar *) xdr->cx->malloc_((nchars + 1) * sizeof(jschar));
70534:     else
70534:         chars = const_cast<jschar *>((*strp)->getChars(xdr->cx));
70534:     if (!chars)
70534:         return JS_FALSE;
70534: 
70534:     if (!XDRChars(xdr, chars, nchars))
70534:         goto bad;
70534:     if (xdr->mode == JSXDR_DECODE) {
70534:         chars[nchars] = 0;
70534:         *strp = JS_NewUCString(xdr->cx, chars, nchars);
70534:         if (!*strp)
70534:             goto bad;
64322:     }
70534:     return JS_TRUE;
    1: 
70534: bad:
70534:     if (xdr->mode == JSXDR_DECODE)
64560:         xdr->cx->free_(chars);
70534:     return JS_FALSE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_XDRStringOrNull(JSXDRState *xdr, JSString **strp)
    1: {
    1:     uint32 null = (*strp == NULL);
    1:     if (!JS_XDRUint32(xdr, &null))
    1:         return JS_FALSE;
    1:     if (null) {
    1:         *strp = NULL;
    1:         return JS_TRUE;
    1:     }
    1:     return JS_XDRString(xdr, strp);
    1: }
    1: 
    1: static JSBool
    1: XDRDoubleValue(JSXDRState *xdr, jsdouble *dp)
    1: {
    1:     jsdpun u;
    1: 
30032:     u.d = (xdr->mode == JSXDR_ENCODE) ? *dp : 0.0;
    1:     if (!JS_XDRUint32(xdr, &u.s.lo) || !JS_XDRUint32(xdr, &u.s.hi))
    1:         return JS_FALSE;
    1:     if (xdr->mode == JSXDR_DECODE)
    1:         *dp = u.d;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
48470: JS_XDRDouble(JSXDRState *xdr, jsdouble *dp)
    1: {
48470:     jsdouble d = (xdr->mode == JSXDR_ENCODE) ? *dp : 0.0;
    1:     if (!XDRDoubleValue(xdr, &d))
    1:         return JS_FALSE;
48470:     if (xdr->mode == JSXDR_DECODE)
48470:         *dp = d;
    1:     return JS_TRUE;
    1: }
    1: 
48480: enum XDRValueTag {
48497:     XDRTAG_OBJECT  = 0,
48497:     XDRTAG_INT     = 1,
48497:     XDRTAG_DOUBLE  = 2,
48497:     XDRTAG_STRING  = 3,
48497:     XDRTAG_SPECIAL = 4,
48497:     XDRTAG_XDRNULL = 5,
48497:     XDRTAG_XDRVOID = 6
48470: };
48470: 
48480: static XDRValueTag
48480: GetXDRTag(jsval v)
48470: {
48470:     if (JSVAL_IS_NULL(v))
48484:         return XDRTAG_XDRNULL;
48470:     if (JSVAL_IS_VOID(v))
48484:         return XDRTAG_XDRVOID;
48470:     if (JSVAL_IS_OBJECT(v))
48484:         return XDRTAG_OBJECT;
48470:     if (JSVAL_IS_INT(v))
48484:         return XDRTAG_INT;
48470:     if (JSVAL_IS_DOUBLE(v))
48484:         return XDRTAG_DOUBLE;
48470:     if (JSVAL_IS_STRING(v))
48484:         return XDRTAG_STRING;
48470:     JS_ASSERT(JSVAL_IS_BOOLEAN(v));
48484:     return XDRTAG_SPECIAL;
48470: }
    1: 
    1: static JSBool
    1: XDRValueBody(JSXDRState *xdr, uint32 type, jsval *vp)
    1: {
    1:     switch (type) {
48484:       case XDRTAG_XDRNULL:
    1:         *vp = JSVAL_NULL;
    1:         break;
48484:       case XDRTAG_XDRVOID:
    1:         *vp = JSVAL_VOID;
    1:         break;
48484:       case XDRTAG_STRING: {
    1:         JSString *str;
    1:         if (xdr->mode == JSXDR_ENCODE)
    1:             str = JSVAL_TO_STRING(*vp);
    1:         if (!JS_XDRString(xdr, &str))
    1:             return JS_FALSE;
    1:         if (xdr->mode == JSXDR_DECODE)
    1:             *vp = STRING_TO_JSVAL(str);
    1:         break;
    1:       }
48484:       case XDRTAG_DOUBLE: {
48470:         double d = xdr->mode == JSXDR_ENCODE ? JSVAL_TO_DOUBLE(*vp) : 0;
48470:         if (!JS_XDRDouble(xdr, &d))
    1:             return JS_FALSE;
    1:         if (xdr->mode == JSXDR_DECODE)
48470:             *vp = DOUBLE_TO_JSVAL(d);
    1:         break;
    1:       }
48484:       case XDRTAG_OBJECT: {
    1:         JSObject *obj;
    1:         if (xdr->mode == JSXDR_ENCODE)
    1:             obj = JSVAL_TO_OBJECT(*vp);
    1:         if (!js_XDRObject(xdr, &obj))
    1:             return JS_FALSE;
    1:         if (xdr->mode == JSXDR_DECODE)
    1:             *vp = OBJECT_TO_JSVAL(obj);
    1:         break;
    1:       }
48484:       case XDRTAG_SPECIAL: {
    1:         uint32 b;
    1:         if (xdr->mode == JSXDR_ENCODE)
    1:             b = (uint32) JSVAL_TO_BOOLEAN(*vp);
    1:         if (!JS_XDRUint32(xdr, &b))
    1:             return JS_FALSE;
    1:         if (xdr->mode == JSXDR_DECODE)
18998:             *vp = BOOLEAN_TO_JSVAL(!!b);
    1:         break;
    1:       }
    1:       default: {
    1:         uint32 i;
    1: 
48484:         JS_ASSERT(type == XDRTAG_INT);
    1:         if (xdr->mode == JSXDR_ENCODE)
    1:             i = (uint32) JSVAL_TO_INT(*vp);
    1:         if (!JS_XDRUint32(xdr, &i))
    1:             return JS_FALSE;
    1:         if (xdr->mode == JSXDR_DECODE)
    1:             *vp = INT_TO_JSVAL((int32) i);
    1:         break;
    1:       }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_XDRValue(JSXDRState *xdr, jsval *vp)
    1: {
    1:     uint32 type;
    1: 
48470:     if (xdr->mode == JSXDR_ENCODE)
48480:         type = GetXDRTag(*vp);
    1:     return JS_XDRUint32(xdr, &type) && XDRValueBody(xdr, type, vp);
    1: }
    1: 
48480: extern JSBool
    1: js_XDRAtom(JSXDRState *xdr, JSAtom **atomp)
    1: {
70534:     JSString *str;
70534:     uint32 nchars;
70534:     JSAtom *atom;
70534:     JSContext *cx;
70534:     jschar *chars;
70534:     jschar stackChars[256];
70534: 
64322:     if (xdr->mode == JSXDR_ENCODE) {
70534:         str = *atomp;
70534:         return JS_XDRString(xdr, &str);
64322:     }
    1: 
70534:     /*
70534:      * Inline JS_XDRString when decoding to avoid JSString allocation
70534:      * for already existing atoms. See bug 321985.
70534:      */
70534:     if (!JS_XDRUint32(xdr, &nchars))
70534:         return JS_FALSE;
70534:     atom = NULL;
70534:     cx = xdr->cx;
70534:     if (nchars <= JS_ARRAY_LENGTH(stackChars)) {
70534:         chars = stackChars;
64322:     } else {
70534:         /*
70534:          * This is very uncommon. Don't use the tempPool arena for this as
70534:          * most allocations here will be bigger than tempPool's arenasize.
70534:          */
70534:         chars = (jschar *) cx->malloc_(nchars * sizeof(jschar));
70534:         if (!chars)
70534:             return JS_FALSE;
    1:     }
    1: 
70534:     if (XDRChars(xdr, chars, nchars))
70534:         atom = js_AtomizeChars(cx, chars, nchars);
70534:     if (chars != stackChars)
70534:         cx->free_(chars);
70534: 
70534:     if (!atom)
70534:         return JS_FALSE;
70534:     *atomp = atom;
70534:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
64190: JS_XDRScriptObject(JSXDRState *xdr, JSObject **scriptObjp)
    1: {
64190:     JSScript *script;
64300:     uint32 magic;
64190:     if (xdr->mode == JSXDR_DECODE) {
64190:         script = NULL;
64190:         *scriptObjp = NULL;
64190:     } else {
64190:         script = (*scriptObjp)->getScript();
64300:         magic = JSXDR_MAGIC_SCRIPT_CURRENT;
64190:     }
64190: 
64300:     if (!JS_XDRUint32(xdr, &magic))
64300:         return false;
64300: 
64300:     if (magic != JSXDR_MAGIC_SCRIPT_CURRENT) {
64300:         /* We do not provide binary compatibility with older scripts. */
64300:         JS_ReportErrorNumber(xdr->cx, js_GetErrorMessage, NULL, JSMSG_BAD_SCRIPT_MAGIC);
64300:         return false;
64300:     }
64300: 
64372:     if (!js_XDRScript(xdr, &script))
64190:         return false;
51440: 
51440:     if (xdr->mode == JSXDR_DECODE) {
64190:         js_CallNewScriptHook(xdr->cx, script, NULL);
64190:         *scriptObjp = js_NewScriptObject(xdr->cx, script);
64190:         if (!*scriptObjp) {
64190:             js_DestroyScript(xdr->cx, script);
64190:             return false;
51440:         }
51440:     }
51440: 
64190:     return true;
    1: }
    1: 
    1: #define CLASS_REGISTRY_MIN      8
    1: #define CLASS_INDEX_TO_ID(i)    ((i)+1)
    1: #define CLASS_ID_TO_INDEX(id)   ((id)-1)
    1: 
    1: typedef struct JSRegHashEntry {
    1:     JSDHashEntryHdr hdr;
    1:     const char      *name;
    1:     uint32          index;
    1: } JSRegHashEntry;
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_XDRRegisterClass(JSXDRState *xdr, JSClass *clasp, uint32 *idp)
    1: {
    1:     uintN numclasses, maxclasses;
    1:     JSClass **registry;
    1: 
    1:     numclasses = xdr->numclasses;
    1:     maxclasses = xdr->maxclasses;
    1:     if (numclasses == maxclasses) {
    1:         maxclasses = (maxclasses == 0) ? CLASS_REGISTRY_MIN : maxclasses << 1;
    1:         registry = (JSClass **)
64560:             xdr->cx->realloc_(xdr->registry, maxclasses * sizeof(JSClass *));
    1:         if (!registry)
    1:             return JS_FALSE;
    1:         xdr->registry = registry;
    1:         xdr->maxclasses = maxclasses;
    1:     } else {
    1:         JS_ASSERT(numclasses && numclasses < maxclasses);
    1:         registry = xdr->registry;
    1:     }
    1: 
    1:     registry[numclasses] = clasp;
    1:     if (xdr->reghash) {
    1:         JSRegHashEntry *entry = (JSRegHashEntry *)
 3164:             JS_DHashTableOperate((JSDHashTable *) xdr->reghash,
 3164:                                  clasp->name, JS_DHASH_ADD);
    1:         if (!entry) {
    1:             JS_ReportOutOfMemory(xdr->cx);
    1:             return JS_FALSE;
    1:         }
    1:         entry->name = clasp->name;
    1:         entry->index = numclasses;
    1:     }
    1:     *idp = CLASS_INDEX_TO_ID(numclasses);
    1:     xdr->numclasses = ++numclasses;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(uint32)
    1: JS_XDRFindClassIdByName(JSXDRState *xdr, const char *name)
    1: {
    1:     uintN i, numclasses;
    1: 
    1:     numclasses = xdr->numclasses;
    1:     if (numclasses >= 10) {
    1:         JSRegHashEntry *entry;
    1: 
    1:         /* Bootstrap reghash from registry on first overpopulated Find. */
    1:         if (!xdr->reghash) {
    1:             xdr->reghash =
    1:                 JS_NewDHashTable(JS_DHashGetStubOps(), NULL,
    1:                                  sizeof(JSRegHashEntry),
    1:                                  JS_DHASH_DEFAULT_CAPACITY(numclasses));
    1:             if (xdr->reghash) {
    1:                 for (i = 0; i < numclasses; i++) {
    1:                     JSClass *clasp = xdr->registry[i];
    1:                     entry = (JSRegHashEntry *)
 3164:                         JS_DHashTableOperate((JSDHashTable *) xdr->reghash,
 3164:                                              clasp->name, JS_DHASH_ADD);
    1:                     entry->name = clasp->name;
    1:                     entry->index = i;
    1:                 }
    1:             }
    1:         }
    1: 
    1:         /* If we managed to create reghash, use it for O(1) Find. */
    1:         if (xdr->reghash) {
    1:             entry = (JSRegHashEntry *)
 3164:                 JS_DHashTableOperate((JSDHashTable *) xdr->reghash,
 3164:                                      name, JS_DHASH_LOOKUP);
    1:             if (JS_DHASH_ENTRY_IS_BUSY(&entry->hdr))
    1:                 return CLASS_INDEX_TO_ID(entry->index);
    1:         }
    1:     }
    1: 
    1:     /* Only a few classes, or we couldn't malloc reghash: use linear search. */
    1:     for (i = 0; i < numclasses; i++) {
    1:         if (!strcmp(name, xdr->registry[i]->name))
    1:             return CLASS_INDEX_TO_ID(i);
    1:     }
    1:     return 0;
    1: }
    1: 
    1: JS_PUBLIC_API(JSClass *)
    1: JS_XDRFindClassById(JSXDRState *xdr, uint32 id)
    1: {
    1:     uintN i = CLASS_ID_TO_INDEX(id);
    1: 
    1:     if (i >= xdr->numclasses)
    1:         return NULL;
    1:     return xdr->registry[i];
    1: }
    1: 
    1: #endif /* JS_HAS_XDR */
