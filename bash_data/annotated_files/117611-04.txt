 77659: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 52557:  * vim: set ts=4 sw=4 et tw=79 ft=cpp:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #ifndef jsscript_h___
     1: #define jsscript_h___
     1: /*
     1:  * JS script descriptor.
     1:  */
     1: #include "jsprvtd.h"
 25215: #include "jsdbgapi.h"
 53391: #include "jsclist.h"
 77343: #include "jsinfer.h"
 89372: #include "jsopcode.h"
 86437: #include "jsscope.h"
     1: 
 82129: #include "gc/Barrier.h"
 82129: 
105580: namespace js {
105580: 
113433: namespace ion {
113436:     struct IonScript;
113433: }
113433: 
112310: # define ION_DISABLED_SCRIPT ((js::ion::IonScript *)0x1)
113485: # define ION_COMPILING_SCRIPT ((js::ion::IonScript *)0x2)
112310: 
105580: struct Shape;
108243: 
108509: class BindingIter;
105580: 
105580: namespace mjit {
105580:     struct JITScript;
105580:     class CallCompiler;
105580: }
105580: 
105580: namespace analyze {
105580:     class ScriptAnalysis;
105580: }
105580: 
105580: }
105580: 
     1: /*
 17215:  * Type of try note associated with each catch or finally block, and also with
 17215:  * for-in loops.
  1825:  */
  1825: typedef enum JSTryNoteKind {
 20420:     JSTRY_CATCH,
 20420:     JSTRY_FINALLY,
 20420:     JSTRY_ITER
  1825: } JSTryNoteKind;
  1825: 
  1825: /*
  1825:  * Exception handling record.
     1:  */
     1: struct JSTryNote {
 84755:     uint8_t         kind;       /* one of JSTryNoteKind */
 84755:     uint8_t         padding;    /* explicit padding on uint16_t boundary */
 84755:     uint16_t        stackDepth; /* stack depth upon exception handler entry */
 84755:     uint32_t        start;      /* start of the try statement or for-in loop
  3025:                                    relative to script->main */
 84755:     uint32_t        length;     /* length of the try statement or for-in loop */
     1: };
     1: 
 97362: namespace js {
 97362: 
 97362: struct ConstArray {
 97362:     js::HeapValue   *vector;    /* array of indexed constant values */
 97362:     uint32_t        length;
 97362: };
 97362: 
 97362: struct ObjectArray {
 97362:     js::HeapPtrObject *vector;  /* array of indexed objects */
 97362:     uint32_t        length;     /* count of indexed objects */
 97362: };
 97362: 
 97362: struct TryNoteArray {
  3235:     JSTryNote       *vector;    /* array of indexed try notes */
 84755:     uint32_t        length;     /* count of indexed try notes */
 97362: };
 52555: 
105580: /*
105580:  * A "binding" is a formal, 'var' or 'const' declaration. A function's lexical
105580:  * scope is composed of these three kinds of bindings.
105580:  */
 59968: 
105580: enum BindingKind { ARGUMENT, VARIABLE, CONSTANT };
 59968: 
108509: class Binding
105580: {
108509:     /*
108509:      * One JSScript stores one Binding per formal/variable so we use a
108509:      * packed-word representation.
108509:      */
108580:     uintptr_t bits_;
108509: 
108580:     static const uintptr_t KIND_MASK = 0x3;
108580:     static const uintptr_t ALIASED_BIT = 0x4;
108580:     static const uintptr_t NAME_MASK = ~(KIND_MASK | ALIASED_BIT);
108509: 
108509:   public:
108509:     explicit Binding() : bits_(0) {}
108509: 
108509:     Binding(PropertyName *name, BindingKind kind, bool aliased) {
108509:         JS_STATIC_ASSERT(CONSTANT <= KIND_MASK);
108580:         JS_ASSERT((uintptr_t(name) & ~NAME_MASK) == 0);
108580:         JS_ASSERT((uintptr_t(kind) & ~KIND_MASK) == 0);
108580:         bits_ = uintptr_t(name) | uintptr_t(kind) | (aliased ? ALIASED_BIT : 0);
108509:     }
108509: 
108509:     PropertyName *name() const {
108509:         return (PropertyName *)(bits_ & NAME_MASK);
108509:     }
108509: 
108509:     BindingKind kind() const {
108509:         return BindingKind(bits_ & KIND_MASK);
108509:     }
108509: 
108509:     bool aliased() const {
108509:         return bool(bits_ & ALIASED_BIT);
108509:     }
 97297: };
 97297: 
108580: JS_STATIC_ASSERT(sizeof(Binding) == sizeof(uintptr_t));
 97297: 
115706: class Bindings;
115706: typedef InternalHandle<Bindings *> InternalBindingsHandle;
115706: 
 59968: /*
 93245:  * Formal parameters and local variables are stored in a shape tree
 59968:  * path encapsulated within this class.  This class represents bindings for
 59968:  * both function and top-level scripts (the latter is needed to track names in
 59968:  * strict mode eval code, to give such code its own lexical environment).
 59968:  */
 93245: class Bindings
 93245: {
105580:     friend class BindingIter;
108509:     friend class AliasedFormalIter;
105580: 
108509:     HeapPtr<Shape> callObjShape_;
108580:     uintptr_t bindingArrayAndFlag_;
108509:     uint16_t numArgs_;
108509:     uint16_t numVars_;
 59968: 
108580:     /*
108580:      * During parsing, bindings are allocated out of a temporary LifoAlloc.
108580:      * After parsing, a JSScript object is created and the bindings are
108580:      * permanently transferred to it. On error paths, the JSScript object may
108580:      * end up with bindings that still point to the (new released) LifoAlloc
108580:      * memory. To avoid tracing these bindings during GC, we keep track of
108580:      * whether the bindings are temporary or permanent in the low bit of
108580:      * bindingArrayAndFlag_.
108580:      */
108580:     static const uintptr_t TEMPORARY_STORAGE_BIT = 0x1;
108580:     bool bindingArrayUsingTemporaryStorage() const {
108580:         return bindingArrayAndFlag_ & TEMPORARY_STORAGE_BIT;
108580:     }
108580:     Binding *bindingArray() const {
108580:         return reinterpret_cast<Binding *>(bindingArrayAndFlag_ & ~TEMPORARY_STORAGE_BIT);
108580:     }
108580: 
 59968:   public:
102615:     inline Bindings();
 59968: 
 59968:     /*
108580:      * Initialize a Bindings with a pointer into temporary storage.
108580:      * bindingArray must have length numArgs+numVars. Before the temporary
108580:      * storage is release, switchToScriptStorage must be called, providing a
108580:      * pointer into the Binding array stored in script->data.
 59968:      */
115706:     static bool initWithTemporaryStorage(JSContext *cx, InternalBindingsHandle self,
111596:                                          unsigned numArgs, unsigned numVars,
111596:                                          Binding *bindingArray);
111596: 
108580:     uint8_t *switchToScriptStorage(Binding *newStorage);
 59968: 
 95101:     /*
108509:      * Clone srcScript's bindings (as part of js::CloneScript). dstScriptData
108509:      * is the pointer to what will eventually be dstScript->data.
 95101:      */
115706:     static bool clone(JSContext *cx, InternalBindingsHandle self, uint8_t *dstScriptData,
115706:                       HandleScript srcScript);
 95101: 
108509:     unsigned numArgs() const { return numArgs_; }
108509:     unsigned numVars() const { return numVars_; }
108509:     unsigned count() const { return numArgs() + numVars(); }
 77343: 
108509:     /* Return the initial shape of call objects created for this scope. */
108509:     Shape *callObjShape() const { return callObjShape_; }
 89745: 
103284:     /* Convenience method to get the var index of 'arguments'. */
115706:     static unsigned argumentsVarIndex(JSContext *cx, InternalBindingsHandle);
 59968: 
108509:     /* Return whether the binding at bindingIndex is aliased. */
108509:     bool bindingIsAliased(unsigned bindingIndex);
108509: 
108509:     /* Return whether this scope has any aliased bindings. */
108509:     bool hasAnyAliasedBindings() const { return !callObjShape_->isEmptyShape(); }
108509: 
 59968:     void trace(JSTracer *trc);
 86437: };
 59968: 
115073: template <>
115073: struct RootMethods<Bindings> {
115073:     static Bindings initial();
115073:     static ThingRootKind kind() { return THING_ROOT_BINDINGS; }
115073:     static bool poisoned(const Bindings &bindings) {
115073:         return IsPoisonedPtr(bindings.callObjShape());
115073:     }
115073: };
115073: 
 94574: class ScriptCounts
 82134: {
 82134:     friend struct ::JSScript;
 94574:     friend struct ScriptAndCounts;
 94574:     /*
 94574:      * This points to a single block that holds an array of PCCounts followed
 94574:      * by an array of doubles.  Each element in the PCCounts array has a
 94574:      * pointer into the array of doubles.
 94574:      */
 94574:     PCCounts *pcCountsVector;
 71699: 
 71699:  public:
 95113:     ScriptCounts() : pcCountsVector(NULL) { }
 71699: 
 94959:     inline void destroy(FreeOp *fop);
 84803: 
 95113:     void set(js::ScriptCounts counts) {
 95113:         pcCountsVector = counts.pcCountsVector;
 71699:     }
 82134: };
 71699: 
 95113: typedef HashMap<JSScript *,
 95113:                 ScriptCounts,
 95113:                 DefaultHasher<JSScript *>,
 95113:                 SystemAllocPolicy> ScriptCountsMap;
 95113: 
 84195: class DebugScript
 84195: {
 84195:     friend struct ::JSScript;
 84195: 
 84195:     /*
 84195:      * When non-zero, compile script in single-step mode. The top bit is set and
 84195:      * cleared by setStepMode, as used by JSD. The lower bits are a count,
 84195:      * adjusted by changeStepModeCount, used by the Debugger object. Only
 84195:      * when the bit is clear and the count is zero may we compile the script
 84195:      * without single-step support.
 84195:      */
 84755:     uint32_t        stepMode;
 84195: 
 84195:     /* Number of breakpoint sites at opcodes in the script. */
 84755:     uint32_t        numSites;
 84195: 
 84195:     /*
 84195:      * Array with all breakpoints installed at opcodes in the script, indexed
 84195:      * by the offset of the opcode into the script.
 84195:      */
 84195:     BreakpointSite  *breakpoints[1];
 84195: };
 84195: 
 95151: typedef HashMap<JSScript *,
 95151:                 DebugScript *,
 95151:                 DefaultHasher<JSScript *>,
 95151:                 SystemAllocPolicy> DebugScriptMap;
 95151: 
105944: struct ScriptSource;
105944: 
 82134: } /* namespace js */
 71699: 
 93250: struct JSScript : public js::gc::Cell
 93250: {
 94571:   private:
 94571:     static const uint32_t stepFlagMask = 0x80000000U;
 94571:     static const uint32_t stepCountMask = 0x7fffffffU;
 94571: 
 94809:   public:
 95024: #ifdef JS_METHODJIT
 94809:     // This type wraps JITScript.  It has three possible states.
 94809:     // - "Empty": no compilation has been attempted and there is no JITScript.
 94809:     // - "Unjittable": compilation failed and there is no JITScript.
 94809:     // - "Valid": compilation succeeded and there is a JITScript.
 94809:     class JITScriptHandle
 94809:     {
 94809:         // CallCompiler must be a friend because it generates code that uses
 94809:         // UNJITTABLE.
 94809:         friend class js::mjit::CallCompiler;
 54840: 
 94809:         // The exact representation:
 94809:         // - NULL means "empty".
 94809:         // - UNJITTABLE means "unjittable".
 94809:         // - Any other value means "valid".
 94809:         // UNJITTABLE = 1 so that we can check that a JITScript is valid
 94809:         // with a single |> 1| test.  It's defined outside the class because
 94809:         // non-integral static const fields can't be defined in the class.
 94809:         static const js::mjit::JITScript *UNJITTABLE;   // = (JITScript *)1;
 94809:         js::mjit::JITScript *value;
 94809: 
 94809:       public:
 94809:         JITScriptHandle()       { value = NULL; }
 94809: 
 94809:         bool isEmpty()          { return value == NULL; }
 94809:         bool isUnjittable()     { return value == UNJITTABLE; }
 94809:         bool isValid()          { return value  > UNJITTABLE; }
 94809: 
 94809:         js::mjit::JITScript *getValid() {
 94809:             JS_ASSERT(isValid());
 94809:             return value;
 94809:         }
 94809: 
 94809:         void setEmpty()         { value = NULL; }
 94809:         void setUnjittable()    { value = const_cast<js::mjit::JITScript *>(UNJITTABLE); }
 94809:         void setValid(js::mjit::JITScript *jit) {
 94809:             value = jit;
 94809:             JS_ASSERT(isValid());
 94809:         }
 94809: 
 94809:         static void staticAsserts();
 94809:     };
 99476: 
 99476:     // All the possible JITScripts that can simultaneously exist for a script.
 99476:     struct JITScriptSet
 99476:     {
 99476:         JITScriptHandle jitHandleNormal;          // JIT info for normal scripts
 99476:         JITScriptHandle jitHandleNormalBarriered; // barriered JIT info for normal scripts
 99476:         JITScriptHandle jitHandleCtor;            // JIT info for constructors
 99476:         JITScriptHandle jitHandleCtorBarriered;   // barriered JIT info for constructors
 99476: 
 99476:         static size_t jitHandleOffset(bool constructing, bool barriers) {
 99476:             return constructing
 99476:                 ? (barriers
 99476:                    ? offsetof(JITScriptSet, jitHandleCtorBarriered)
 99476:                    : offsetof(JITScriptSet, jitHandleCtor))
 99476:                 : (barriers
 99476:                    ? offsetof(JITScriptSet, jitHandleNormalBarriered)
 99476:                    : offsetof(JITScriptSet, jitHandleNormal));
 99476:         }
 99476:     };
 99476: 
 95024: #endif  // JS_METHODJIT
 94809: 
 94809:     //
 94809:     // We order fields according to their size in order to avoid wasting space
 94809:     // for alignment.
 94809:     //
 94809: 
 94809:     // Larger-than-word-sized fields.
 54840: 
 94571:   public:
 94571:     js::Bindings    bindings;   /* names of top-level variables in this script
 94571:                                    (and arguments if this is a function script) */
 94571: 
 94809:     // Word-sized fields.
 94571: 
 94571:   public:
     1:     jsbytecode      *code;      /* bytecodes and their immediate operands */
 94572:     uint8_t         *data;      /* pointer to variable-length data array (see
102045:                                    comment above Create() for details) */
 77659: 
 94571:     const char      *filename;  /* source filename or null */
 94934:     js::HeapPtrAtom *atoms;     /* maps immediate index to literal struct */
 94571: 
 94571:     JSPrincipals    *principals;/* principals for this script */
 94571:     JSPrincipals    *originPrincipals; /* see jsapi.h 'originPrincipals' comment */
 94571: 
 94571:     /* Persistent type information retained across GCs. */
 94571:     js::types::TypeScript *types;
 94571: 
 99476:   private:
106824:     js::ScriptSource *scriptSource_; /* source code */
 94571: #ifdef JS_METHODJIT
106782:     JITScriptSet *mJITInfo;
 94571: #endif
 94571:     js::HeapPtrFunction function_;
104378:     js::HeapPtrObject   enclosingScope_;
 94571: 
 94809:     // 32-bit fields.
 94571: 
 94571:   public:
 84755:     uint32_t        length;     /* length of code vector */
 94571: 
 94571:     uint32_t        lineno;     /* base line number of script */
 94571: 
 94571:     uint32_t        mainOffset; /* offset of main entry point from code, after
 94571:                                    predef'ing prolog */
 94571: 
 94571:     uint32_t        natoms;     /* length of atoms array */
 94571: 
105944:     uint32_t        sourceStart;
105944:     uint32_t        sourceEnd;
105944: 
105944: 
 97829:   private:
 97829:     uint32_t        useCount;   /* Number of times the script has been called
 97829:                                  * or has had backedges taken. Reset if the
 97829:                                  * script's JIT code is forcibly discarded. */
 97829: 
113567:     uint32_t        maxLoopCount; /* Maximum loop count that has been encountered. */
113567:     uint32_t        loopCount;    /* Number of times a LOOPHEAD has been encountered.
113567:                                      after a LOOPENTRY. Modified only by interpreter. */
110959: 
 94571: #ifdef DEBUG
 94809:     // Unique identifier within the compartment for this script, used for
 94809:     // printing analysis information.
 94571:     uint32_t        id_;
 94571:   private:
 95139:     uint32_t        idpad;
 94571: #endif
 94571: 
 94809:     // 16-bit fields.
 94571: 
 61450:   private:
114412:     uint16_t        PADDING;
114412: 
 84755:     uint16_t        version;    /* JS version under which script was compiled */
 61450: 
 61450:   public:
114412:     uint16_t        ndefaults;  /* number of defaults the function has */
114412: 
 84755:     uint16_t        nfixed;     /* number of slots besides stack operands in
 16072:                                    slot array */
 94571: 
 94571:     uint16_t        nTypeSets;  /* number of type sets used in this script for
 94571:                                    dynamic type monitoring */
 94571: 
 94571:     uint16_t        nslots;     /* vars plus maximum stack depth */
 94571:     uint16_t        staticLevel;/* static level for display maintenance */
 94571: 
 94809:     // 8-bit fields.
 94571: 
 97840:   public:
 97839:     // The kinds of the optional arrays.
 97839:     enum ArrayKind {
 97839:         CONSTS,
 97839:         OBJECTS,
 97839:         REGEXPS,
 97839:         TRYNOTES,
 97839:         LIMIT
 97839:     };
 97840: 
 97840:     typedef uint8_t ArrayBitsT;
 97840: 
 97840:   private:
 97840:     // The bits in this field indicate the presence/non-presence of several
102045:     // optional arrays in |data|.  See the comments above Create() for details.
 97840:     ArrayBitsT      hasArrayBits;
 77659: 
 94809:     // 1-bit fields.
 59221: 
 94571:   public:
 33750:     bool            noScriptRval:1; /* no need for result value of last
 33750:                                        expression statement */
 75519:     bool            savedCallerFun:1; /* can call getCallerFunction() */
 35113:     bool            strictModeCode:1; /* code is in strict mode */
105944:     bool            explicitUseStrict:1; /* code has "use strict"; explicitly */
 98464:     bool            compileAndGo:1;   /* see Parser::compileAndGo */
 98687:     bool            bindingsAccessedDynamically:1; /* see ContextFlags' field of the same name */
101616:     bool            funHasExtensibleScope:1;       /* see ContextFlags' field of the same name */
108509:     bool            funHasAnyAliasedFormal:1;      /* true if any formalIsAliased(i) */
 48589:     bool            warnedAboutTwoArgumentEval:1; /* have warned about use of
 48589:                                                      obsolete eval(s, o) in
 48589:                                                      this script */
 77343:     bool            warnedAboutUndefinedProp:1; /* have warned about uses of
 77343:                                                    undefined properties in this
 77343:                                                    script */
 59962:     bool            hasSingletons:1;  /* script has singleton objects */
 77343:     bool            isActiveEval:1;   /* script came from eval(), and is still active */
 77343:     bool            isCachedEval:1;   /* script came from eval(), and is in eval cache */
 77361:     bool            uninlineable:1;   /* script is considered uninlineable by analysis */
 53391: #ifdef JS_METHODJIT
 53391:     bool            debugMode:1;      /* script was compiled in debug mode */
 77343:     bool            failedBoundsCheck:1; /* script has had hoisted bounds checks fail */
 53391: #endif
113386:     bool            invalidatedIdempotentCache:1; /* idempotent cache has triggered invalidation */
 95100:     bool            isGenerator:1;    /* is a generator */
106311:     bool            isGeneratorExp:1; /* is a generator expression */
 95113:     bool            hasScriptCounts:1;/* script has an entry in
 95113:                                          JSCompartment::scriptCountsMap */
 95151:     bool            hasDebugScript:1; /* script has an entry in
 95151:                                          JSCompartment::debugScriptMap */
109045:     bool            hasFreezeConstraints:1; /* freeze constraints for stack
109045:                                              * type sets have been generated */
115898:     bool            userBit:1; /* Opaque, used by the embedding. */
109045: 
 93250:   private:
 95100:     /* See comments below. */
103284:     bool            argsHasVarBinding_:1;
 95100:     bool            needsArgsAnalysis_:1;
 93250:     bool            needsArgsObj_:1;
 94571: 
 94809:     //
 94809:     // End of fields.  Start methods.
 94809:     //
 94571: 
 93250:   public:
104378:     static JSScript *Create(JSContext *cx, js::HandleObject enclosingScope, bool savedCallerFun,
106508:                             const JS::CompileOptions &options, unsigned staticLevel,
105944:                             js::ScriptSource *ss, uint32_t sourceStart, uint32_t sourceEnd);
102045: 
102045:     // Three ways ways to initialize a JSScript.  Callers of partiallyInit()
102045:     // and fullyInitTrivial() are responsible for notifying the debugger after
102045:     // successfully creating any kind (function or other) of new JSScript.
102045:     // However, callers of fullyInitFromEmitter() do not need to do this.
104205:     static bool partiallyInit(JSContext *cx, JS::Handle<JSScript*> script,
104205:                               uint32_t length, uint32_t nsrcnotes, uint32_t natoms,
102045:                               uint32_t nobjects, uint32_t nregexps, uint32_t ntrynotes, uint32_t nconsts,
108509:                               uint32_t nTypeSets);
104205:     static bool fullyInitTrivial(JSContext *cx, JS::Handle<JSScript*> script);  // inits a JSOP_STOP-only script
105835:     static bool fullyInitFromEmitter(JSContext *cx, JS::Handle<JSScript*> script,
105835:                                      js::frontend::BytecodeEmitter *bce);
 94571: 
 97298:     void setVersion(JSVersion v) { version = v; }
 97298: 
 98687:     /* See ContextFlags::funArgumentsHasLocalBinding comment. */
103284:     bool argumentsHasVarBinding() const { return argsHasVarBinding_; }
 95100:     jsbytecode *argumentsBytecode() const { JS_ASSERT(code[0] == JSOP_ARGUMENTS); return code; }
103284:     void setArgumentsHasVarBinding();
 95100: 
 95100:     /*
 95100:      * As an optimization, even when argsHasLocalBinding, the function prologue
 95100:      * may not need to create an arguments object. This is determined by
 95100:      * needsArgsObj which is set by ScriptAnalysis::analyzeSSA before running
 95100:      * the script the first time. When !needsArgsObj, the prologue may simply
 95100:      * write MagicValue(JS_OPTIMIZED_ARGUMENTS) to 'arguments's slot and any
 95100:      * uses of 'arguments' will be guaranteed to handle this magic value.
 95100:      * So avoid spurious arguments object creation, we maintain the invariant
 95100:      * that needsArgsObj is only called after the script has been analyzed.
 95100:      */
 95100:     bool analyzedArgsUsage() const { return !needsArgsAnalysis_; }
 93250:     bool needsArgsObj() const { JS_ASSERT(analyzedArgsUsage()); return needsArgsObj_; }
 93250:     void setNeedsArgsObj(bool needsArgsObj);
116204:     static bool argumentsOptimizationFailed(JSContext *cx, js::HandleScript script);
 93250: 
 98892:     /*
 98892:      * Arguments access (via JSOP_*ARG* opcodes) must access the canonical
 98892:      * location for the argument. If an arguments object exists AND this is a
 98892:      * non-strict function (where 'arguments' aliases formals), then all access
 98892:      * must go through the arguments object. Otherwise, the local slot is the
 98892:      * canonical location for the arguments. Note: if a formal is aliased
108509:      * through the scope chain, then script->formalIsAliased and JSOP_*ARG*
108509:      * opcodes won't be emitted at all.
 98892:      */
 98892:     bool argsObjAliasesFormals() const {
 98892:         return needsArgsObj() && !strictModeCode;
 98892:     }
 98892: 
111782:     js::ion::IonScript *ion;          /* Information attached by Ion */
112310: 
113391: #if defined(JS_METHODJIT) && JS_BITS_PER_WORD == 32
112979:     void *padding_;
112979: #endif
112979: 
112310:     bool hasIonScript() const {
113582:         return ion && ion != ION_DISABLED_SCRIPT && ion != ION_COMPILING_SCRIPT;
112310:     }
112932:     bool canIonCompile() const {
112932:         return ion != ION_DISABLED_SCRIPT;
112932:     }
113582:     bool isIonCompilingOffThread() const {
113582:         return ion == ION_COMPILING_SCRIPT;
113582:     }
112756:     js::ion::IonScript *ionScript() const {
112756:         JS_ASSERT(hasIonScript());
112756:         return ion;
112756:     }
 77463: 
 83283:     /*
 83283:      * Original compiled function for the script, if it has a function.
 83283:      * NULL for global and eval scripts.
 83283:      */
 83256:     JSFunction *function() const { return function_; }
 84726:     void setFunction(JSFunction *fun);
 83256: 
114424:     JSFlatString *sourceData(JSContext *cx);
105944: 
105947:     bool loadSource(JSContext *cx, bool *worked);
105947: 
106824:     js::ScriptSource *scriptSource() {
106824:         return scriptSource_;
106824:     }
106824: 
115733:     void setScriptSource(js::ScriptSource *ss);
106824: 
106824:   public:
106824: 
104376:     /* Return whether this script was compiled for 'eval' */
104376:     bool isForEval() { return isCachedEval || isActiveEval; }
104376: 
 77343: #ifdef DEBUG
 80026:     unsigned id();
 77343: #else
 77343:     unsigned id() { return 0; }
 77343: #endif
 77343: 
 77884:     /* Ensure the script has a TypeScript. */
 83256:     inline bool ensureHasTypes(JSContext *cx);
 77884: 
 77884:     /*
104376:      * Ensure the script has bytecode analysis information. Performed when the
104376:      * script first runs, or first runs after a TypeScript GC purge.
 77884:      */
104376:     inline bool ensureRanAnalysis(JSContext *cx);
 77884: 
 77884:     /* Ensure the script has type inference analysis information. */
 77343:     inline bool ensureRanInference(JSContext *cx);
 77343: 
 77391:     inline bool hasAnalysis();
 77884:     inline void clearAnalysis();
 77391:     inline js::analyze::ScriptAnalysis *analysis();
 77343: 
113567:     /* Heuristic to check if the function is expected to be "short running". */
113567:     bool isShortRunning();
113567: 
109045:     inline void clearPropertyReadTypes();
109045: 
104376:     inline js::GlobalObject &global() const;
104333: 
104378:     /* See StaticScopeIter comment. */
106002:     JSObject *enclosingStaticScope() const {
106002:         JS_ASSERT(enclosingScriptsCompiledSuccessfully());
106002:         return enclosingScope_;
106002:     }
106002: 
106002:     /*
106002:      * If a compile error occurs in an enclosing function after parsing a
106002:      * nested function, the enclosing function's JSFunction, which appears on
106002:      * the nested function's enclosingScope chain, will be invalid. Normal VM
106002:      * operation only sees scripts where all enclosing scripts have been
106002:      * successfully compiled. Any path that may look at scripts left over from
106002:      * unsuccessful compilation (e.g., by iterating over all scripts in the
106002:      * compartment) should check this predicate before doing any operation that
106002:      * uses enclosingScope (e.g., ScopeCoordinateName).
106002:      */
106002:     bool enclosingScriptsCompiledSuccessfully() const;
104378: 
 77391:   private:
 83256:     bool makeTypes(JSContext *cx);
 77391:     bool makeAnalysis(JSContext *cx);
 77391: 
 52557: #ifdef JS_METHODJIT
 94809:   private:
 94809:     // CallCompiler must be a friend because it generates code that directly
 94809:     // accesses jitHandleNormal/jitHandleCtor, via jitHandleOffset().
 94809:     friend class js::mjit::CallCompiler;
 94809: 
 99476:   public:
106782:     bool hasMJITInfo() {
106782:         return mJITInfo != NULL;
 55503:     }
 55503: 
106782:     static size_t offsetOfMJITInfo() { return offsetof(JSScript, mJITInfo); }
 99476: 
106782:     inline bool ensureHasMJITInfo(JSContext *cx);
106782:     inline void destroyMJITInfo(js::FreeOp *fop);
 94809: 
 98147:     JITScriptHandle *jitHandle(bool constructing, bool barriers) {
106782:         JS_ASSERT(mJITInfo);
 98147:         return constructing
106782:                ? (barriers ? &mJITInfo->jitHandleCtorBarriered : &mJITInfo->jitHandleCtor)
106782:                : (barriers ? &mJITInfo->jitHandleNormalBarriered : &mJITInfo->jitHandleNormal);
 98147:     }
 98147: 
 98147:     js::mjit::JITScript *getJIT(bool constructing, bool barriers) {
106782:         if (!mJITInfo)
 99476:             return NULL;
 98147:         JITScriptHandle *jith = jitHandle(constructing, barriers);
 94809:         return jith->isValid() ? jith->getValid() : NULL;
 94809:     }
 94809: 
 94809:     static void ReleaseCode(js::FreeOp *fop, JITScriptHandle *jith);
 94809: 
 55687:     // These methods are implemented in MethodJIT.h.
 55687:     inline void **nativeMap(bool constructing);
 55687:     inline void *nativeCodeForPC(bool constructing, jsbytecode *pc);
 55503: 
 97829:     uint32_t getUseCount() const  { return useCount; }
116390:     uint32_t incUseCount(uint32_t amount = 1) { return useCount += amount; }
 97829:     uint32_t *addressOfUseCount() { return &useCount; }
 77659:     void resetUseCount() { useCount = 0; }
 62574: 
113567:     void resetLoopCount() {
113567:         if (loopCount > maxLoopCount)
113567:             maxLoopCount = loopCount;
113567:         loopCount = 0;
113567:     }
113567: 
113567:     void incrLoopCount() {
113567:         ++loopCount;
113567:     }
113567: 
113567:     uint32_t getMaxLoopCount() {
113567:         if (loopCount > maxLoopCount)
113567:             maxLoopCount = loopCount;
113567:         return maxLoopCount;
113567:     }
113567: 
 88300:     /*
 88300:      * Size of the JITScript and all sections.  If |mallocSizeOf| is NULL, the
 88300:      * size is computed analytically.  (This method is implemented in
 88300:      * MethodJIT.cpp.)
 88300:      */
 88145:     size_t sizeOfJitScripts(JSMallocSizeOfFun mallocSizeOf);
 53119: #endif
 32723: 
 94809:   public:
 95139:     bool initScriptCounts(JSContext *cx);
 95113:     js::PCCounts getPCCounts(jsbytecode *pc);
 95113:     js::ScriptCounts releaseScriptCounts();
 94740:     void destroyScriptCounts(js::FreeOp *fop);
 82134: 
 77659:     jsbytecode *main() {
 77659:         return code + mainOffset;
 77659:     }
 77659: 
 78016:     /*
 88145:      * computedSizeOfData() is the in-use size of all the data sections.
 88145:      * sizeOfData() is the size of the block allocated to hold all the data sections
 78016:      * (which can be larger than the in-use size).
 78016:      */
 88145:     size_t computedSizeOfData();
 88145:     size_t sizeOfData(JSMallocSizeOfFun mallocSizeOf);
 88145: 
 84755:     uint32_t numNotes();  /* Number of srcnote slots in the srcnotes section */
 72071: 
 32723:     /* Script notes are allocated right after the code. */
 32723:     jssrcnote *notes() { return (jssrcnote *)(code + length); }
 32723: 
 97839:     bool hasArray(ArrayKind kind)           { return (hasArrayBits & (1 << kind)); }
 97839:     void setHasArray(ArrayKind kind)        { hasArrayBits |= (1 << kind); }
 97839:     void cloneHasArray(JSScript *script)    { hasArrayBits = script->hasArrayBits; }
 59221: 
 97839:     bool hasConsts()        { return hasArray(CONSTS);      }
 97839:     bool hasObjects()       { return hasArray(OBJECTS);     }
 97839:     bool hasRegexps()       { return hasArray(REGEXPS);     }
 97839:     bool hasTrynotes()      { return hasArray(TRYNOTES);    }
 97839: 
 97839:     #define OFF(fooOff, hasFoo, t)   (fooOff() + (hasFoo() ? sizeof(t) : 0))
 97839: 
 97839:     size_t constsOffset()     { return 0; }
 97839:     size_t objectsOffset()    { return OFF(constsOffset,     hasConsts,     js::ConstArray);      }
 97839:     size_t regexpsOffset()    { return OFF(objectsOffset,    hasObjects,    js::ObjectArray);     }
 97839:     size_t trynotesOffset()   { return OFF(regexpsOffset,    hasRegexps,    js::ObjectArray);     }
 97361: 
 97362:     js::ConstArray *consts() {
 97361:         JS_ASSERT(hasConsts());
 97839:         return reinterpret_cast<js::ConstArray *>(data + constsOffset());
 94572:     }
 94572: 
 97362:     js::ObjectArray *objects() {
 97361:         JS_ASSERT(hasObjects());
 97839:         return reinterpret_cast<js::ObjectArray *>(data + objectsOffset());
 32723:     }
 32723: 
 97362:     js::ObjectArray *regexps() {
 97361:         JS_ASSERT(hasRegexps());
 97839:         return reinterpret_cast<js::ObjectArray *>(data + regexpsOffset());
 32723:     }
 32723: 
 97362:     js::TryNoteArray *trynotes() {
 97361:         JS_ASSERT(hasTrynotes());
 97839:         return reinterpret_cast<js::TryNoteArray *>(data + trynotesOffset());
 32723:     }
 32723: 
 94934:     js::HeapPtrAtom &getAtom(size_t index) const {
 77659:         JS_ASSERT(index < natoms);
 77659:         return atoms[index];
 32723:     }
 32723: 
103991:     js::HeapPtrAtom &getAtom(jsbytecode *pc) const {
103991:         JS_ASSERT(pc >= code && pc + sizeof(uint32_t) < code + length);
103991:         return getAtom(GET_UINT32_INDEX(pc));
103991:     }
103991: 
 86542:     js::PropertyName *getName(size_t index) {
 86542:         return getAtom(index)->asPropertyName();
 86542:     }
 86542: 
103991:     js::PropertyName *getName(jsbytecode *pc) const {
103991:         JS_ASSERT(pc >= code && pc + sizeof(uint32_t) < code + length);
103991:         return getAtom(GET_UINT32_INDEX(pc))->asPropertyName();
103991:     }
103991: 
 32723:     JSObject *getObject(size_t index) {
 97362:         js::ObjectArray *arr = objects();
 32723:         JS_ASSERT(index < arr->length);
 32723:         return arr->vector[index];
 32723:     }
 32723: 
103991:     JSObject *getObject(jsbytecode *pc) {
103991:         JS_ASSERT(pc >= code && pc + sizeof(uint32_t) < code + length);
103991:         return getObject(GET_UINT32_INDEX(pc));
103991:     }
103991: 
 53848:     JSVersion getVersion() const {
 53848:         return JSVersion(version);
 53848:     }
 53848: 
 32736:     inline JSFunction *getFunction(size_t index);
 75519:     inline JSFunction *getCallerFunction();
 32723: 
112541:     inline js::RegExpObject *getRegExp(size_t index);
 34290: 
 48470:     const js::Value &getConst(size_t index) {
 97362:         js::ConstArray *arr = consts();
 48470:         JS_ASSERT(index < arr->length);
 48470:         return arr->vector[index];
 48470:     }
 48470: 
 34290:     /*
 34290:      * The isEmpty method tells whether this script has code that computes any
 34290:      * result (not return value, result AKA normal completion value) other than
 59220:      * JSVAL_VOID, or any other effects.
 34290:      */
 34290:     inline bool isEmpty() const;
 34290: 
 95099:     bool varIsAliased(unsigned varSlot);
 98892:     bool formalIsAliased(unsigned argSlot);
 98892:     bool formalLivesInArgumentsObject(unsigned argSlot);
101072: 
 77169:   private:
 77169:     /*
 94740:      * Recompile with or without single-stepping support, as directed
 77169:      * by stepModeEnabled().
 77169:      */
 94740:     void recompileForStepMode(js::FreeOp *fop);
 77169: 
 77169:     /* Attempt to change this->stepMode to |newValue|. */
 84755:     bool tryNewStepMode(JSContext *cx, uint32_t newValue);
 77169: 
 95151:     bool ensureHasDebugScript(JSContext *cx);
 95151:     js::DebugScript *debugScript();
 95151:     js::DebugScript *releaseDebugScript();
 95151:     void destroyDebugScript(js::FreeOp *fop);
 84195: 
 77169:   public:
 84195:     bool hasBreakpointsAt(jsbytecode *pc) { return !!getBreakpointSite(pc); }
 95151:     bool hasAnyBreakpointsOrStepMode() { return hasDebugScript; }
 84195: 
 84195:     js::BreakpointSite *getBreakpointSite(jsbytecode *pc)
 84195:     {
 84195:         JS_ASSERT(size_t(pc - code) < length);
 95151:         return hasDebugScript ? debugScript()->breakpoints[pc - code] : NULL;
 84195:     }
 84195: 
104376:     js::BreakpointSite *getOrCreateBreakpointSite(JSContext *cx, jsbytecode *pc);
 84195: 
 94740:     void destroyBreakpointSite(js::FreeOp *fop, jsbytecode *pc);
 84195: 
116204:     void clearBreakpointsIn(js::FreeOp *fop, js::Debugger *dbg, js::RawObject handler);
 94740:     void clearTraps(js::FreeOp *fop);
 84195: 
 84195:     void markTrapClosures(JSTracer *trc);
 84195: 
 77169:     /*
 77169:      * Set or clear the single-step flag. If the flag is set or the count
 77169:      * (adjusted by changeStepModeCount) is non-zero, then the script is in
 77169:      * single-step mode. (JSD uses an on/off-style interface; Debugger uses a
 77169:      * count-style interface.)
 77169:      */
 77169:     bool setStepModeFlag(JSContext *cx, bool step);
 77169: 
 77169:     /*
 77169:      * Increment or decrement the single-step count. If the count is non-zero or
 77169:      * the flag (set by setStepModeFlag) is set, then the script is in
 77169:      * single-step mode. (JSD uses an on/off-style interface; Debugger uses a
 77169:      * count-style interface.)
 77169:      */
 77169:     bool changeStepModeCount(JSContext *cx, int delta);
 77169: 
 95151:     bool stepModeEnabled() { return hasDebugScript && !!debugScript()->stepMode; }
 77169: 
 77169: #ifdef DEBUG
 95151:     uint32_t stepModeCount() { return hasDebugScript ? (debugScript()->stepMode & stepCountMask) : 0; }
 77169: #endif
 77659: 
 94738:     void finalize(js::FreeOp *fop);
 82129: 
 82129:     static inline void writeBarrierPre(JSScript *script);
 82129:     static inline void writeBarrierPost(JSScript *script, void *addr);
 86437: 
 86437:     static inline js::ThingRootKind rootKind() { return js::THING_ROOT_SCRIPT; }
 90856: 
 90856:     static JSPrincipals *normalizeOriginPrincipals(JSPrincipals *principals,
 90856:                                                    JSPrincipals *originPrincipals) {
 90856:         return originPrincipals ? originPrincipals : principals;
 90856:     }
 91557: 
 91557:     void markChildren(JSTracer *trc);
     1: };
     1: 
 97840: JS_STATIC_ASSERT(sizeof(JSScript::ArrayBitsT) * 8 >= JSScript::LIMIT);
 97840: 
 95151: /* If this fails, add/remove padding within JSScript. */
 77659: JS_STATIC_ASSERT(sizeof(JSScript) % js::gc::Cell::CellSize == 0);
 77659: 
108509: namespace js {
108509: 
108509: /*
108509:  * Iterator over a script's bindings (formals and variables).
108509:  * The order of iteration is:
108509:  *  - first, formal arguments, from index 0 to numArgs
108509:  *  - next, variables, from index 0 to numVars
108509:  */
108509: class BindingIter
108509: {
115706:     const InternalBindingsHandle bindings_;
108509:     unsigned i_;
108509: 
108509:     friend class Bindings;
108509: 
108509:   public:
115706:     explicit BindingIter(const InternalBindingsHandle &bindings) : bindings_(bindings), i_(0) {}
115706:     explicit BindingIter(const HandleScript &script) : bindings_(script, &script->bindings), i_(0) {}
108509: 
108509:     bool done() const { return i_ == bindings_->count(); }
108509:     operator bool() const { return !done(); }
108509:     void operator++(int) { JS_ASSERT(!done()); i_++; }
108509:     BindingIter &operator++() { (*this)++; return *this; }
108509: 
108509:     unsigned frameIndex() const {
108509:         JS_ASSERT(!done());
108509:         return i_ < bindings_->numArgs() ? i_ : i_ - bindings_->numArgs();
108509:     }
108509: 
108580:     const Binding &operator*() const { JS_ASSERT(!done()); return bindings_->bindingArray()[i_]; }
108580:     const Binding *operator->() const { JS_ASSERT(!done()); return &bindings_->bindingArray()[i_]; }
108509: };
108509: 
108509: /*
108509:  * This helper function fills the given BindingVector with the sequential
108509:  * values of BindingIter.
108509:  */
108509: 
108509: typedef Vector<Binding, 32> BindingVector;
108509: 
108509: extern bool
115706: FillBindingVector(HandleScript fromScript, BindingVector *vec);
108509: 
108509: /*
108509:  * Iterator over the aliased formal bindings in ascending index order. This can
108509:  * be veiwed as a filtering of BindingIter with predicate
108509:  *   bi->aliased() && bi->kind() == ARGUMENT
108509:  */
108509: class AliasedFormalIter
108509: {
108509:     const Binding *begin_, *p_, *end_;
108509:     unsigned slot_;
108509: 
108509:     void settle() {
108509:         while (p_ != end_ && !p_->aliased())
108509:             p_++;
108509:     }
108509: 
108509:   public:
108509:     explicit inline AliasedFormalIter(JSScript *script);
108509: 
108509:     bool done() const { return p_ == end_; }
108509:     operator bool() const { return !done(); }
108509:     void operator++(int) { JS_ASSERT(!done()); p_++; slot_++; settle(); }
108509: 
108509:     const Binding &operator*() const { JS_ASSERT(!done()); return *p_; }
108509:     const Binding *operator->() const { JS_ASSERT(!done()); return p_; }
108509:     unsigned frameIndex() const { JS_ASSERT(!done()); return p_ - begin_; }
108509:     unsigned scopeSlot() const { JS_ASSERT(!done()); return slot_; }
108509: };
108509: 
108509: }  /* namespace js */
108509: 
     1: /*
102045:  * New-script-hook calling is factored from JSScript::fullyInitFromEmitter() so
102045:  * that it and callers of XDRScript() can share this code.  In the case of
102045:  * callers of XDRScript(), the hook should be invoked only after successful
102045:  * decode of any owning function (the fun parameter) or script object (null
102045:  * fun).
     1:  */
 13702: extern JS_FRIEND_API(void)
 13702: js_CallNewScriptHook(JSContext *cx, JSScript *script, JSFunction *fun);
     1: 
 94740: namespace js {
 94740: 
105944: struct SourceCompressionToken;
105944: 
105944: struct ScriptSource
105944: {
105944:     friend class SourceCompressorThread;
105944:   private:
105944:     union {
106897:         // When the script source is ready, compressedLength_ != 0 implies
105944:         // compressed holds the compressed data; otherwise, source holds the
105944:         // uncompressed source.
105944:         jschar *source;
105944:         unsigned char *compressed;
105944:     } data;
107564:     uint32_t refs;
105944:     uint32_t length_;
106897:     uint32_t compressedLength_;
108243:     jschar *sourceMap_;
107687: 
107687:     // True if we can call JSRuntime::sourceHook to load the source on
107687:     // demand. If sourceRetrievable_ and hasSourceData() are false, it is not
107687:     // possible to get source at all.
107687:     bool sourceRetrievable_:1;
105944:     bool argumentsNotIncluded_:1;
105944: #ifdef DEBUG
105944:     bool ready_:1;
105944: #endif
105944: 
105944:   public:
107053:     ScriptSource()
107564:       : refs(0),
107053:         length_(0),
107053:         compressedLength_(0),
108243:         sourceMap_(NULL),
107687:         sourceRetrievable_(false),
107053:         argumentsNotIncluded_(false)
107053: #ifdef DEBUG
107053:        ,ready_(true)
107053: #endif
107053:     {
107053:         data.source = NULL;
107053:     }
107564:     void incref() { refs++; }
107564:     void decref(JSRuntime *rt) {
107564:         JS_ASSERT(refs != 0);
107564:         if (--refs == 0)
107564:             destroy(rt);
107564:     }
107107:     bool setSourceCopy(JSContext *cx,
105944:                        const jschar *src,
105944:                        uint32_t length,
107107:                        bool argumentsNotIncluded,
107107:                        SourceCompressionToken *tok);
107107:     void setSource(const jschar *src, uint32_t length);
105944: #ifdef DEBUG
105944:     bool ready() const { return ready_; }
105944: #endif
107687:     void setSourceRetrievable() { sourceRetrievable_ = true; }
107687:     bool sourceRetrievable() const { return sourceRetrievable_; }
107053:     bool hasSourceData() const { return !!data.source; }
107053:     uint32_t length() const {
107053:         JS_ASSERT(hasSourceData());
107053:         return length_;
107053:     }
107053:     bool argumentsNotIncluded() const {
107053:         JS_ASSERT(hasSourceData());
107053:         return argumentsNotIncluded_;
107053:     }
114424:     JSFlatString *substring(JSContext *cx, uint32_t start, uint32_t stop);
105945:     size_t sizeOfIncludingThis(JSMallocSizeOfFun mallocSizeOf);
105944: 
105944:     // XDR handling
105944:     template <XDRMode mode>
107053:     bool performXDR(XDRState<mode> *xdr);
105944: 
108243:     // Source maps
108586:     bool setSourceMap(JSContext *cx, jschar *sourceMapURL, const char *filename);
108243:     const jschar *sourceMap();
108243:     bool hasSourceMap() const { return sourceMap_ != NULL; }
108243: 
105944:   private:
107053:     void destroy(JSRuntime *rt);
106897:     bool compressed() { return compressedLength_ != 0; }
105944: };
105944: 
107564: class ScriptSourceHolder
107564: {
107564:     JSRuntime *rt;
107564:     ScriptSource *ss;
107564:   public:
107564:     ScriptSourceHolder(JSRuntime *rt, ScriptSource *ss)
107564:       : rt(rt),
107564:         ss(ss)
107564:     {
107564:         ss->incref();
107564:     }
107564:     ~ScriptSourceHolder()
107564:     {
107564:         ss->decref(rt);
107564:     }
107564: };
107564: 
105944: #ifdef JS_THREADSAFE
105944: /*
105944:  * Background thread to compress JS source code. This happens only while parsing
105944:  * and bytecode generation is happening in the main thread. If needed, the
105944:  * compiler waits for compression to complete before returning.
105944:  *
105944:  * To use it, you have to have a SourceCompressionToken, tok, with tok.ss and
105944:  * tok.chars set to the proper values. When the SourceCompressionToken is
105944:  * destroyed, it makes sure the compression is complete. At this point tok.ss is
105944:  * ready to be attached to the runtime.
105944:  */
105944: class SourceCompressorThread
105944: {
105944:   private:
105944:     enum {
105944:         // The compression thread is in the process of compression some source.
105944:         COMPRESSING,
105944:         // The compression thread is not doing anything and available to
105944:         // compress source.
105944:         IDLE,
105944:         // Set by finish() to tell the compression thread to exit.
105944:         SHUTDOWN
105944:     } state;
105944:     SourceCompressionToken *tok;
105944:     PRThread *thread;
105944:     // Protects |state| and |tok| when it's non-NULL.
105944:     PRLock *lock;
105944:     // When it's idling, the compression thread blocks on this. The main thread
105944:     // uses it to notify the compression thread when it has source to be
105944:     // compressed.
105944:     PRCondVar *wakeup;
105944:     // The main thread can block on this to wait for compression to finish.
105944:     PRCondVar *done;
106917:     // Flag which can be set by the main thread to ask compression to abort.
106917:     volatile bool stop;
105944: 
105944:     void threadLoop();
105944:     static void compressorThread(void *arg);
105944: 
105944:   public:
105944:     explicit SourceCompressorThread(JSRuntime *rt)
105944:     : state(IDLE),
105944:       tok(NULL),
105944:       thread(NULL),
105944:       lock(NULL),
105944:       wakeup(NULL),
105944:       done(NULL) {}
105944:     void finish();
105944:     bool init();
105944:     void compress(SourceCompressionToken *tok);
105944:     void waitOnCompression(SourceCompressionToken *userTok);
106917:     void abort(SourceCompressionToken *userTok);
105944: };
105944: #endif
105944: 
105944: struct SourceCompressionToken
105944: {
105964:     friend struct ScriptSource;
105944:     friend class SourceCompressorThread;
105944:   private:
106917:     JSContext *cx;
105944:     ScriptSource *ss;
105944:     const jschar *chars;
105944:   public:
106917:     SourceCompressionToken(JSContext *cx)
106917:       : cx(cx), ss(NULL), chars(NULL) {}
105944:     ~SourceCompressionToken()
105944:     {
105944:         JS_ASSERT_IF(!ss, !chars);
105944:         if (ss)
105944:             ensureReady();
105944:     }
106917: 
105944:     void ensureReady();
106917:     void abort();
117611:     bool active() const { return !!ss; }
105944: };
105944: 
 62571: extern void
116204: CallDestroyScriptHook(FreeOp *fop, js::RawScript script);
     1: 
 94202: extern const char *
 94202: SaveScriptFilename(JSContext *cx, const char *filename);
 94202: 
 97463: struct ScriptFilenameEntry
 97463: {
 97463:     bool marked;
 97463:     char filename[1];
 97463: 
 97463:     static ScriptFilenameEntry *fromFilename(const char *filename) {
 97463:         return (ScriptFilenameEntry *)(filename - offsetof(ScriptFilenameEntry, filename));
 97463:     }
 97463: };
 97463: 
 97463: struct ScriptFilenameHasher
 97463: {
 97463:     typedef const char *Lookup;
107924:     static HashNumber hash(const char *l) { return mozilla::HashString(l); }
 97463:     static bool match(const ScriptFilenameEntry *e, const char *l) {
 97463:         return strcmp(e->filename, l) == 0;
 97463:     }
 97463: };
 97463: 
 97463: typedef HashSet<ScriptFilenameEntry *,
 97463:                 ScriptFilenameHasher,
 97463:                 SystemAllocPolicy> ScriptFilenameTable;
 97463: 
 97463: inline void
 97463: MarkScriptFilename(JSRuntime *rt, const char *filename);
 93970: 
 93970: extern void
 97463: SweepScriptFilenames(JSRuntime *rt);
 93970: 
 93970: extern void
 97463: FreeScriptFilenames(JSRuntime *rt);
 93970: 
 94574: struct ScriptAndCounts
 84803: {
 84803:     JSScript *script;
 94574:     ScriptCounts scriptCounts;
 84803: 
 94574:     PCCounts &getPCCounts(jsbytecode *pc) const {
 84803:         JS_ASSERT(unsigned(pc - script->code) < script->length);
 94574:         return scriptCounts.pcCountsVector[pc - script->code];
 84803:     }
 84803: };
 84803: 
 77659: } /* namespace js */
     1: 
     1: extern jssrcnote *
116204: js_GetSrcNote(JSContext *cx, js::RawScript script, jsbytecode *pc);
     1: 
     1: extern jsbytecode *
116204: js_LineNumberToPC(js::RawScript script, unsigned lineno);
     1: 
 91237: extern JS_FRIEND_API(unsigned)
116204: js_GetScriptLineExtent(js::RawScript script);
     1: 
 68894: namespace js {
 68894: 
 91237: extern unsigned
116204: PCToLineNumber(js::RawScript script, jsbytecode *pc, unsigned *columnp = NULL);
 91316: 
 91316: extern unsigned
109046: PCToLineNumber(unsigned startLine, jssrcnote *notes, jsbytecode *code, jsbytecode *pc,
109046:                unsigned *columnp = NULL);
 91316: 
 91316: extern unsigned
 71363: CurrentLine(JSContext *cx);
 71363: 
 68894: /*
 68894:  * This function returns the file and line number of the script currently
 68894:  * executing on cx. If there is no current script executing on cx (e.g., a
 68894:  * native called directly through JSAPI (e.g., by setTimeout)), NULL and 0 are
 68894:  * returned as the file and line. Additionally, this function avoids the full
 68894:  * linear scan to compute line number when the caller guarnatees that the
 68894:  * script compilation occurs at a JSOP_EVAL.
 68894:  */
 68894: 
 68894: enum LineOption {
 68894:     CALLED_FROM_JSOP_EVAL,
 68894:     NOT_CALLED_FROM_JSOP_EVAL
 68894: };
 68894: 
 84691: inline void
 91237: CurrentScriptFileLineOrigin(JSContext *cx, unsigned *linenop, LineOption = NOT_CALLED_FROM_JSOP_EVAL);
 68894: 
 55633: extern JSScript *
104378: CloneScript(JSContext *cx, HandleObject enclosingScope, HandleFunction fun, HandleScript script);
 55633: 
 94006: /*
 94006:  * NB: after a successful XDR_DECODE, XDRScript callers must do any required
 94006:  * subsequent set-up of owning function or script object and then call
 94006:  * js_CallNewScriptHook.
 94006:  */
 94006: template<XDRMode mode>
 94006: bool
104378: XDRScript(XDRState<mode> *xdr, HandleObject enclosingScope, HandleScript enclosingScript,
116202:           HandleFunction fun, MutableHandleScript scriptp);
 94006: 
 94006: } /* namespace js */
     1: 
     1: #endif /* jsscript_h___ */
