    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jsnum_h___
    1: #define jsnum_h___
20408: 
32596: #include <math.h>
32596: #if defined(XP_WIN) || defined(XP_OS2)
32592: #include <float.h>
32596: #endif
32622: #ifdef SOLARIS
32622: #include <ieeefp.h>
32622: #endif
48470: #include "jsvalue.h"
32545: 
40828: #include "jsstdint.h"
39941: #include "jsstr.h"
40901: #include "jsobj.h"
39941: 
    1: /*
    1:  * JS number (IEEE double) interface.
    1:  *
    1:  * JS numbers are optimistically stored in the top 31 bits of 32-bit integers,
    1:  * but floating point literals, results that overflow 31 bits, and division and
    1:  * modulus operands and results require a 64-bit IEEE double.  These are GC'ed
    1:  * and pointed to by 32-bit jsvals on the stack and in object properties.
    1:  */
    1: 
    1: /*
 2538:  * The ARM architecture supports two floating point models: VFP and FPA. When
 2538:  * targetting FPA, doubles are mixed-endian on little endian ARMs (meaning that
 2538:  * the high and low words are in big endian order).
    1:  */
    1: #if defined(__arm) || defined(__arm32__) || defined(__arm26__) || defined(__arm__)
 2538: #if !defined(__VFP_FP__)
 2538: #define FPU_IS_ARM_FPA
 2538: #endif
    1: #endif
    1: 
    1: typedef union jsdpun {
    1:     struct {
 2538: #if defined(IS_LITTLE_ENDIAN) && !defined(FPU_IS_ARM_FPA)
    1:         uint32 lo, hi;
    1: #else
    1:         uint32 hi, lo;
    1: #endif
    1:     } s;
17943:     uint64   u64;
    1:     jsdouble d;
    1: } jsdpun;
    1: 
32586: static inline int
32586: JSDOUBLE_IS_NaN(jsdouble d)
32586: {
32586: #ifdef WIN32
32586:     return _isnan(d);
32586: #else
32586:     return isnan(d);
32586: #endif
32586: }
    1: 
32586: static inline int
32586: JSDOUBLE_IS_FINITE(jsdouble d)
32586: {
32586: #ifdef WIN32
32586:     return _finite(d);
32586: #else
32586:     return finite(d);
32586: #endif
32586: }
    1: 
32586: static inline int
32596: JSDOUBLE_IS_INFINITE(jsdouble d)
32596: {
32596: #ifdef WIN32
32596:     int c = _fpclass(d);
32596:     return c == _FPCLASS_NINF || c == _FPCLASS_PINF;
32622: #elif defined(SOLARIS)
32622:     return !finite(d) && !isnan(d);
32596: #else
32596:     return isinf(d);
32596: #endif
32596: }
32596: 
    1: #define JSDOUBLE_HI32_SIGNBIT   0x80000000
    1: #define JSDOUBLE_HI32_EXPMASK   0x7ff00000
    1: #define JSDOUBLE_HI32_MANTMASK  0x000fffff
48497: #define JSDOUBLE_HI32_NAN       0x7ff80000
48497: #define JSDOUBLE_LO32_NAN       0x00000000
    1: 
48470: static inline bool
32586: JSDOUBLE_IS_NEG(jsdouble d)
32586: {
32586: #ifdef WIN32
32586:     return JSDOUBLE_IS_NEGZERO(d) || d < 0;
32622: #elif defined(SOLARIS)
32622:     return copysign(1, d) < 0;
32586: #else
32586:     return signbit(d);
32586: #endif
32586: }
    1: 
32586: static inline uint32
32586: JS_HASH_DOUBLE(jsdouble d)
32586: {
32586:     jsdpun u;
32586:     u.d = d;
32586:     return u.s.lo ^ u.s.hi;
32586: }
    1: 
    1: #if defined(XP_WIN)
    1: #define JSDOUBLE_COMPARE(LVAL, OP, RVAL, IFNAN)                               \
    1:     ((JSDOUBLE_IS_NaN(LVAL) || JSDOUBLE_IS_NaN(RVAL))                         \
    1:      ? (IFNAN)                                                                \
    1:      : (LVAL) OP (RVAL))
    1: #else
    1: #define JSDOUBLE_COMPARE(LVAL, OP, RVAL, IFNAN) ((LVAL) OP (RVAL))
    1: #endif
    1: 
18295: extern jsdouble js_NaN;
34372: extern jsdouble js_PositiveInfinity;
34372: extern jsdouble js_NegativeInfinity;
18295: 
    1: /* Initialize number constants and runtime state for the first context. */
    1: extern JSBool
    1: js_InitRuntimeNumberState(JSContext *cx);
    1: 
    1: extern void
    1: js_FinishRuntimeNumberState(JSContext *cx);
    1: 
    1: /* Initialize the Number class, returning its prototype object. */
48470: extern js::Class js_NumberClass;
    1: 
40901: inline bool
40901: JSObject::isNumber() const
40901: {
40901:     return getClass() == &js_NumberClass;
40901: }
40901: 
48470: extern JSObject *
    1: js_InitNumberClass(JSContext *cx, JSObject *obj);
    1: 
    1: /*
    1:  * String constants for global function names, used in jsapi.c and jsnum.c.
    1:  */
    1: extern const char js_Infinity_str[];
    1: extern const char js_NaN_str[];
    1: extern const char js_isNaN_str[];
    1: extern const char js_isFinite_str[];
    1: extern const char js_parseFloat_str[];
    1: extern const char js_parseInt_str[];
    1: 
42641: extern JSString * JS_FASTCALL
42641: js_IntToString(JSContext *cx, jsint i);
42641: 
18078: extern JSString * JS_FASTCALL
    1: js_NumberToString(JSContext *cx, jsdouble d);
    1: 
    1: /*
48470:  * Convert an integer or double (contained in the given value) to a string and
30023:  * append to the given buffer.
30023:  */
30023: extern JSBool JS_FASTCALL
48470: js_NumberValueToCharBuffer(JSContext *cx, const js::Value &v, JSCharBuffer &cb);
30023: 
40828: namespace js {
40828: 
30023: /*
40828:  * Convert a value to a number, returning the converted value in 'out' if the
48470:  * conversion succeeds.
    1:  */
40828: JS_ALWAYS_INLINE bool
48470: ValueToNumber(JSContext *cx, const js::Value &v, double *out)
40828: {
48470:     if (v.isNumber()) {
48470:         *out = v.toNumber();
40828:         return true;
40828:     }
48470:     extern bool ValueToNumberSlow(JSContext *, js::Value, double *);
48470:     return ValueToNumberSlow(cx, v, out);
40828: }
40828: 
48470: /* Convert a value to a number, replacing 'vp' with the converted value. */
40828: JS_ALWAYS_INLINE bool
48470: ValueToNumber(JSContext *cx, js::Value *vp)
40828: {
48470:     if (vp->isNumber())
40828:         return true;
48470:     double d;
48470:     extern bool ValueToNumberSlow(JSContext *, js::Value, double *);
48470:     if (!ValueToNumberSlow(cx, *vp, &d))
48470:         return false;
48470:     vp->setNumber(d);
40828:     return true;
40828: }
    1: 
    1: /*
12681:  * Convert a value to an int32 or uint32, according to the ECMA rules for
48470:  * ToInt32 and ToUint32. Return converted value in *out on success, !ok on
48470:  * failure.
    1:  */
40828: JS_ALWAYS_INLINE bool
48470: ValueToECMAInt32(JSContext *cx, const js::Value &v, int32_t *out)
40828: {
48470:     if (v.isInt32()) {
48470:         *out = v.toInt32();
40828:         return true;
40828:     }
48470:     extern bool ValueToECMAInt32Slow(JSContext *, const js::Value &, int32_t *);
40828:     return ValueToECMAInt32Slow(cx, v, out);
40828: }
    1: 
40828: JS_ALWAYS_INLINE bool
48470: ValueToECMAUint32(JSContext *cx, const js::Value &v, uint32_t *out)
40828: {
48470:     if (v.isInt32()) {
48470:         *out = (uint32_t)v.toInt32();
40828:         return true;
40828:     }
48470:     extern bool ValueToECMAUint32Slow(JSContext *, const js::Value &, uint32_t *);
40828:     return ValueToECMAUint32Slow(cx, v, out);
40828: }
40828: 
40828: /*
40828:  * Convert a value to a number, then to an int32 if it fits by rounding to
48470:  * nearest. Return converted value in *out on success, !ok on failure. As a
48470:  * side effect, *vp will be mutated to match *out.
40828:  */
40828: JS_ALWAYS_INLINE bool
48470: ValueToInt32(JSContext *cx, const js::Value &v, int32_t *out)
40828: {
48470:     if (v.isInt32()) {
48470:         *out = v.toInt32();
40828:         return true;
40828:     }
48470:     extern bool ValueToInt32Slow(JSContext *, const js::Value &, int32_t *);
40828:     return ValueToInt32Slow(cx, v, out);
40828: }
40828: 
40828: /*
40828:  * Convert a value to a number, then to a uint16 according to the ECMA rules
40828:  * for ToUint16. Return converted value on success, !ok on failure. v must be a
48470:  * copy of a rooted value.
40828:  */
40828: JS_ALWAYS_INLINE bool
48470: ValueToUint16(JSContext *cx, const js::Value &v, uint16_t *out)
40828: {
48470:     if (v.isInt32()) {
48470:         *out = (uint16_t)v.toInt32();
40828:         return true;
40828:     }
48470:     extern bool ValueToUint16Slow(JSContext *, const js::Value &, uint16_t *);
40828:     return ValueToUint16Slow(cx, v, out);
40828: }
40828: 
40828: }  /* namespace js */
12681: 
12681: /*
12681:  * Specialized ToInt32 and ToUint32 converters for doubles.
12681:  */
32544: /*
32544:  * From the ES3 spec, 9.5
32544:  *  2.  If Result(1) is NaN, +0, -0, +Inf, or -Inf, return +0.
32544:  *  3.  Compute sign(Result(1)) * floor(abs(Result(1))).
32544:  *  4.  Compute Result(3) modulo 2^32; that is, a finite integer value k of Number
32544:  *      type with positive sign and less than 2^32 in magnitude such the mathematical
32544:  *      difference of Result(3) and k is mathematically an integer multiple of 2^32.
32544:  *  5.  If Result(4) is greater than or equal to 2^31, return Result(4)- 2^32,
32544:  *  otherwise return Result(4).
32544:  */
32544: static inline int32
32544: js_DoubleToECMAInt32(jsdouble d)
32544: {
39733: #if defined(__i386__) || defined(__i386)
32544:     jsdpun du, duh, two32;
32544:     uint32 di_h, u_tmp, expon, shift_amount;
32544:     int32 mask32;
32544: 
32544:     /*
32544:      * Algorithm Outline
32544:      *  Step 1. If d is NaN, +/-Inf or |d|>=2^84 or |d|<1, then return 0
32544:      *          All of this is implemented based on an exponent comparison.
32544:      *  Step 2. If |d|<2^31, then return (int)d
32544:      *          The cast to integer (conversion in RZ mode) returns the correct result.
32544:      *  Step 3. If |d|>=2^32, d:=fmod(d, 2^32) is taken  -- but without a call
32544:      *  Step 4. If |d|>=2^31, then the fractional bits are cleared before
32544:      *          applying the correction by 2^32:  d - sign(d)*2^32
32544:      *  Step 5. Return (int)d
32544:      */
32544: 
32544:     du.d = d;
32544:     di_h = du.s.hi;
32544: 
32544:     u_tmp = (di_h & 0x7ff00000) - 0x3ff00000;
32544:     if (u_tmp >= (0x45300000-0x3ff00000)) {
32544:         // d is Nan, +/-Inf or +/-0, or |d|>=2^(32+52) or |d|<1, in which case result=0
32544:         return 0;
32544:     }
32544: 
32544:     if (u_tmp < 0x01f00000) {
32544:         // |d|<2^31
32544:         return int32_t(d);
32544:     }
32544: 
32544:     if (u_tmp > 0x01f00000) {
32544:         // |d|>=2^32
32544:         expon = u_tmp >> 20;
32544:         shift_amount = expon - 21;
32544:         duh.u64 = du.u64;
32544:         mask32 = 0x80000000;
32544:         if (shift_amount < 32) {
32544:             mask32 >>= shift_amount;
32544:             duh.s.hi = du.s.hi & mask32;
32544:             duh.s.lo = 0;
32544:         } else {
32544:             mask32 >>= (shift_amount-32);
32544:             duh.s.hi = du.s.hi;
32544:             duh.s.lo = du.s.lo & mask32;
32544:         }
32544:         du.d -= duh.d;
32544:     }
32544: 
32544:     di_h = du.s.hi;
32544: 
32544:     // eliminate fractional bits
32544:     u_tmp = (di_h & 0x7ff00000);
32544:     if (u_tmp >= 0x41e00000) {
32544:         // |d|>=2^31
32544:         expon = u_tmp >> 20;
32544:         shift_amount = expon - (0x3ff - 11);
32544:         mask32 = 0x80000000;
32544:         if (shift_amount < 32) {
32544:             mask32 >>= shift_amount;
32544:             du.s.hi &= mask32;
32544:             du.s.lo = 0;
32544:         } else {
32544:             mask32 >>= (shift_amount-32);
32544:             du.s.lo &= mask32;
32544:         }
32544:         two32.s.hi = 0x41f00000 ^ (du.s.hi & 0x80000000);
32544:         two32.s.lo = 0;
32544:         du.d -= two32.d;
32544:     }
32544: 
32544:     return int32(du.d);
41795: #elif defined (__arm__) && defined (__GNUC__)
41795:     int32_t i;
41795:     uint32_t    tmp0;
41795:     uint32_t    tmp1;
41795:     uint32_t    tmp2;
41795:     asm (
41795:     // We use a pure integer solution here. In the 'softfp' ABI, the argument
41795:     // will start in r0 and r1, and VFP can't do all of the necessary ECMA
41795:     // conversions by itself so some integer code will be required anyway. A
41795:     // hybrid solution is faster on A9, but this pure integer solution is
41795:     // notably faster for A8.
41795: 
41795:     // %0 is the result register, and may alias either of the %[QR]1 registers.
41795:     // %Q4 holds the lower part of the mantissa.
41795:     // %R4 holds the sign, exponent, and the upper part of the mantissa.
41795:     // %1, %2 and %3 are used as temporary values.
41795: 
41795:     // Extract the exponent.
41795: "   mov     %1, %R4, LSR #20\n"
41795: "   bic     %1, %1, #(1 << 11)\n"  // Clear the sign.
41795: 
41795:     // Set the implicit top bit of the mantissa. This clobbers a bit of the
41795:     // exponent, but we have already extracted that.
41795: "   orr     %R4, %R4, #(1 << 20)\n"
41795: 
41795:     // Special Cases
41795:     //   We should return zero in the following special cases:
41795:     //    - Exponent is 0x000 - 1023: +/-0 or subnormal.
41795:     //    - Exponent is 0x7ff - 1023: +/-INFINITY or NaN
41795:     //      - This case is implicitly handled by the standard code path anyway,
41795:     //        as shifting the mantissa up by the exponent will result in '0'.
41795:     //
41795:     // The result is composed of the mantissa, prepended with '1' and
41795:     // bit-shifted left by the (decoded) exponent. Note that because the r1[20]
41795:     // is the bit with value '1', r1 is effectively already shifted (left) by
41795:     // 20 bits, and r0 is already shifted by 52 bits.
41795:     
41795:     // Adjust the exponent to remove the encoding offset. If the decoded
41795:     // exponent is negative, quickly bail out with '0' as such values round to
41795:     // zero anyway. This also catches +/-0 and subnormals.
41795: "   sub     %1, %1, #0xff\n"
41795: "   subs    %1, %1, #0x300\n"
41795: "   bmi     8f\n"
41795: 
41795:     //  %1 = (decoded) exponent >= 0
41795:     //  %R4 = upper mantissa and sign
41795: 
41795:     // ---- Lower Mantissa ----
41795: "   subs    %3, %1, #52\n"         // Calculate exp-52
41795: "   bmi     1f\n"
41795: 
41795:     // Shift r0 left by exp-52.
41795:     // Ensure that we don't overflow ARM's 8-bit shift operand range.
41795:     // We need to handle anything up to an 11-bit value here as we know that
41795:     // 52 <= exp <= 1024 (0x400). Any shift beyond 31 bits results in zero
41795:     // anyway, so as long as we don't touch the bottom 5 bits, we can use
41795:     // a logical OR to push long shifts into the 32 <= (exp&0xff) <= 255 range.
41795: "   bic     %2, %3, #0xff\n"
41795: "   orr     %3, %3, %2, LSR #3\n"
41795:     // We can now perform a straight shift, avoiding the need for any
41795:     // conditional instructions or extra branches.
41795: "   mov     %Q4, %Q4, LSL %3\n"
41795: "   b       2f\n"
41795: "1:\n" // Shift r0 right by 52-exp.
41795:     // We know that 0 <= exp < 52, and we can shift up to 255 bits so 52-exp
41795:     // will always be a valid shift and we can sk%3 the range check for this case.
41795: "   rsb     %3, %1, #52\n"
41795: "   mov     %Q4, %Q4, LSR %3\n"
41795: 
41795:     //  %1 = (decoded) exponent
41795:     //  %R4 = upper mantissa and sign
41795:     //  %Q4 = partially-converted integer
41795: 
41795: "2:\n"
41795:     // ---- Upper Mantissa ----
41795:     // This is much the same as the lower mantissa, with a few different
41795:     // boundary checks and some masking to hide the exponent & sign bit in the
41795:     // upper word.
41795:     // Note that the upper mantissa is pre-shifted by 20 in %R4, but we shift
41795:     // it left more to remove the sign and exponent so it is effectively
41795:     // pre-shifted by 31 bits.
41795: "   subs    %3, %1, #31\n"          // Calculate exp-31
41795: "   mov     %1, %R4, LSL #11\n"     // Re-use %1 as a temporary register.
41795: "   bmi     3f\n"
41795: 
41795:     // Shift %R4 left by exp-31.
41795:     // Avoid overflowing the 8-bit shift range, as before.
41795: "   bic     %2, %3, #0xff\n"
41795: "   orr     %3, %3, %2, LSR #3\n"
41795:     // Perform the shift.
41795: "   mov     %2, %1, LSL %3\n"
41795: "   b       4f\n"
41795: "3:\n" // Shift r1 right by 31-exp.
41795:     // We know that 0 <= exp < 31, and we can shift up to 255 bits so 31-exp
41795:     // will always be a valid shift and we can skip the range check for this case.
41795: "   rsb     %3, %3, #0\n"          // Calculate 31-exp from -(exp-31)
41795: "   mov     %2, %1, LSR %3\n"      // Thumb-2 can't do "LSR %3" in "orr".
41795: 
41795:     //  %Q4 = partially-converted integer (lower)
41795:     //  %R4 = upper mantissa and sign
41795:     //  %2 = partially-converted integer (upper)
41795: 
41795: "4:\n"
41795:     // Combine the converted parts.
41795: "   orr     %Q4, %Q4, %2\n"
41795:     // Negate the result if we have to, and move it to %0 in the process. To
41795:     // avoid conditionals, we can do this by inverting on %R4[31], then adding
41795:     // %R4[31]>>31.
41795: "   eor     %Q4, %Q4, %R4, ASR #31\n"
41795: "   add     %0, %Q4, %R4, LSR #31\n"
41795: "   b       9f\n"
41795: "8:\n"
41795:     // +/-INFINITY, +/-0, subnormals, NaNs, and anything else out-of-range that
41795:     // will result in a conversion of '0'.
41795: "   mov     %0, #0\n"
41795: "9:\n"
41795:     : "=r" (i), "=&r" (tmp0), "=&r" (tmp1), "=&r" (tmp2)
41795:     : "r" (d)
41795:     : "cc"
41795:         );
41795:     return i;
32544: #else
32544:     int32 i;
32544:     jsdouble two32, two31;
32544: 
32544:     if (!JSDOUBLE_IS_FINITE(d))
32544:         return 0;
32544: 
32544:     i = (int32) d;
32544:     if ((jsdouble) i == d)
32544:         return i;
32544: 
32544:     two32 = 4294967296.0;
32544:     two31 = 2147483648.0;
32544:     d = fmod(d, two32);
32544:     d = (d >= 0) ? floor(d) : ceil(d) + two32;
32544:     return (int32) (d >= two31 ? d - two32 : d);
32544: #endif
32544: }
    1: 
40828: uint32
12681: js_DoubleToECMAUint32(jsdouble d);
12681: 
    1: /*
    1:  * Convert a jsdouble to an integral number, stored in a jsdouble.
    1:  * If d is NaN, return 0.  If d is an infinity, return it without conversion.
    1:  */
32610: static inline jsdouble
32610: js_DoubleToInteger(jsdouble d)
32610: {
32610:     if (d == 0)
32610:         return d;
32610: 
32610:     if (!JSDOUBLE_IS_FINITE(d)) {
32610:         if (JSDOUBLE_IS_NaN(d))
32610:             return 0;
32610:         return d;
32610:     }
32610: 
32610:     JSBool neg = (d < 0);
32610:     d = floor(neg ? -d : d);
32610: 
32610:     return neg ? -d : d;
32610: }
    1: 
    1: /*
    1:  * Similar to strtod except that it replaces overflows with infinities of the
    1:  * correct sign, and underflows with zeros of the correct sign.  Guaranteed to
    1:  * return the closest double number to the given input in dp.
    1:  *
    1:  * Also allows inputs of the form [+|-]Infinity, which produce an infinity of
    1:  * the appropriate sign.  The case of the "Infinity" string must match exactly.
    1:  * If the string does not contain a number, set *ep to s and return 0.0 in dp.
    1:  * Return false if out of memory.
    1:  */
    1: extern JSBool
 4281: js_strtod(JSContext *cx, const jschar *s, const jschar *send,
 4281:           const jschar **ep, jsdouble *dp);
    1: 
    1: /*
    1:  * Similar to strtol except that it handles integers of arbitrary size.
    1:  * Guaranteed to return the closest double number to the given input when radix
    1:  * is 10 or a power of 2.  Callers may see round-off errors for very large
    1:  * numbers of a different radix than 10 or a power of 2.
    1:  *
    1:  * If the string does not contain a number, set *ep to s and return 0.0 in dp.
    1:  * Return false if out of memory.
    1:  */
    1: extern JSBool
 4281: js_strtointeger(JSContext *cx, const jschar *s, const jschar *send,
 4281:                 const jschar **ep, jsint radix, jsdouble *dp);
    1: 
40828: namespace js {
    1: 
48470: static JS_ALWAYS_INLINE bool
48470: ValueFitsInInt32(const Value &v, int32_t *pi)
48470: {
48470:     if (v.isInt32()) {
48470:         *pi = v.toInt32();
48470:         return true;
48470:     }
48470:     return v.isDouble() && JSDOUBLE_IS_INT32(v.toDouble(), pi);
48470: }
48470: 
39941: template<typename T> struct NumberTraits { };
39941: template<> struct NumberTraits<int32> {
39941:   static JS_ALWAYS_INLINE int32 NaN() { return 0; }
39941:   static JS_ALWAYS_INLINE int32 toSelfType(int32 i) { return i; }
39941:   static JS_ALWAYS_INLINE int32 toSelfType(jsdouble d) { return js_DoubleToECMAUint32(d); }
39941: };
39941: template<> struct NumberTraits<jsdouble> {
39941:   static JS_ALWAYS_INLINE jsdouble NaN() { return js_NaN; }
39941:   static JS_ALWAYS_INLINE jsdouble toSelfType(int32 i) { return i; }
39941:   static JS_ALWAYS_INLINE jsdouble toSelfType(jsdouble d) { return d; }
39941: };
39941: 
39941: template<typename T>
39941: static JS_ALWAYS_INLINE T
39941: StringToNumberType(JSContext *cx, JSString *str)
39941: {
39941:     if (str->length() == 1) {
39941:         jschar c = str->chars()[0];
39941:         if ('0' <= c && c <= '9')
39945:             return NumberTraits<T>::toSelfType(T(c - '0'));
39945:         if (JS_ISSPACE(c))
39945:             return NumberTraits<T>::toSelfType(T(0));
39941:         return NumberTraits<T>::NaN();
39941:     }
39941: 
39941:     const jschar* bp;
39941:     const jschar* end;
39941:     const jschar* ep;
39941:     jsdouble d;
39941: 
39941:     str->getCharsAndEnd(bp, end);
39941:     bp = js_SkipWhiteSpace(bp, end);
39941: 
39941:     /* ECMA doesn't allow signed hex numbers (bug 273467). */
39941:     if (end - bp >= 2 && bp[0] == '0' && (bp[1] == 'x' || bp[1] == 'X')) {
39941:         /* Looks like a hex number. */
39941:         if (!js_strtointeger(cx, bp, end, &ep, 16, &d) ||
39941:             js_SkipWhiteSpace(ep, end) != end) {
39941:             return NumberTraits<T>::NaN();
39941:         }
39941:         return NumberTraits<T>::toSelfType(d);
39941:     }
39941: 
39941:     /*
39941:      * Note that ECMA doesn't treat a string beginning with a '0' as
39941:      * an octal number here. This works because all such numbers will
39941:      * be interpreted as decimal by js_strtod.  Also, any hex numbers
39941:      * that have made it here (which can only be negative ones) will
39941:      * be treated as 0 without consuming the 'x' by js_strtod.
39941:      */
39941:     if (!js_strtod(cx, bp, end, &ep, &d) ||
39941:         js_SkipWhiteSpace(ep, end) != end) {
39941:         return NumberTraits<T>::NaN();
39941:     }
39941: 
39941:     return NumberTraits<T>::toSelfType(d);
39941: }
39941: }
39941: 
    1: #endif /* jsnum_h___ */
