     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #ifndef Window_h__
     1: #define Window_h__
     1: 
 29841: /*
 29841:  * nsWindow - Native window management and event handling.
 29841:  */
 29841: 
 60730: #include "nsAutoPtr.h"
     1: #include "nsBaseWidget.h"
     1: #include "nsdefs.h"
 40944: #include "nsIdleService.h"
     1: #include "nsToolkit.h"
     1: #include "nsString.h"
 14476: #include "nsTArray.h"
 29835: #include "gfxWindowsSurface.h"
 29835: #include "nsWindowDbg.h"
 29506: #include "cairo.h"
 58814: #include "nsITimer.h"
 87254: #include "mozilla/TimeStamp.h"
 87254: 
 38727: #ifdef CAIRO_HAS_D2D_SURFACE
 38727: #include "gfxD2DSurface.h"
 38727: #endif
 29506: 
 29835: #include "nsWinGesture.h"
 27961: 
 31532: #include "WindowHook.h"
 33486: #include "TaskbarWindowPreview.h"
 31532: 
     1: #ifdef ACCESSIBILITY
     1: #include "OLEACC.H"
 99648: #include "mozilla/a11y/Accessible.h"
     1: #endif
     1: 
 39718: #include "nsUXThemeData.h"
 68855: 
 77227: #include "nsIDOMMouseEvent.h"
 77227: 
103224: #include "nsIIdleServiceInternal.h"
103224: 
 29835: /**
 29835:  * Forward class definitions
 29835:  */
 26874: 
 29835: class nsNativeDragTarget;
 29835: class nsIRollupListener;
 29835: class nsIFile;
 29835: class imgIContainer;
 18536: 
 97476: namespace mozilla {
 97476: namespace widget {
 97476: class NativeKey;
102101: class ModifierKeyState;
 97476: } // namespace widget
 97476: } // namespacw mozilla;
 97476: 
     1: /**
     1:  * Native WIN32 window wrapper.
     1:  */
     1: 
 31124: class nsWindow : public nsBaseWidget
     1: {
 87254:   typedef mozilla::TimeStamp TimeStamp;
 87254:   typedef mozilla::TimeDuration TimeDuration;
 31532:   typedef mozilla::widget::WindowHook WindowHook;
 33486:   typedef mozilla::widget::TaskbarWindowPreview TaskbarWindowPreview;
 97476:   typedef mozilla::widget::NativeKey NativeKey;
     1: public:
     1:   nsWindow();
     1:   virtual ~nsWindow();
     1: 
  4345:   NS_DECL_ISUPPORTS_INHERITED
     1: 
 29835:   friend class nsWindowGfx;
 29835: 
 29835:   /**
 29835:    * nsIWidget interface
 29835:    */
     1:   NS_IMETHOD              Create(nsIWidget *aParent,
 33013:                                  nsNativeWidget aNativeParent,
 23738:                                  const nsIntRect &aRect,
 68668:                                  nsDeviceContext *aContext,
106838:                                  nsWidgetInitData *aInitData = nullptr);
     1:   NS_IMETHOD              Destroy();
     1:   NS_IMETHOD              SetParent(nsIWidget *aNewParent);
     1:   virtual nsIWidget*      GetParent(void);
 50783:   virtual float           GetDPI();
 79445:   NS_IMETHOD              Show(bool bState);
105772:   virtual bool            IsVisible() const;
108991:   NS_IMETHOD              ConstrainPosition(bool aAllowSlop, int32_t *aX, int32_t *aY);
106923:   virtual void            SetSizeConstraints(const SizeConstraints& aConstraints);
108991:   NS_IMETHOD              Move(int32_t aX, int32_t aY);
108991:   NS_IMETHOD              Resize(int32_t aWidth, int32_t aHeight, bool aRepaint);
108991:   NS_IMETHOD              Resize(int32_t aX, int32_t aY, int32_t aWidth, int32_t aHeight, bool aRepaint);
108991:   NS_IMETHOD              BeginResizeDrag(nsGUIEvent* aEvent, int32_t aHorizontal, int32_t aVertical);
 79445:   NS_IMETHOD              PlaceBehind(nsTopLevelWidgetZPlacement aPlacement, nsIWidget *aWidget, bool aActivate);
108991:   NS_IMETHOD              SetSizeMode(int32_t aMode);
 79445:   NS_IMETHOD              Enable(bool aState);
106103:   virtual bool            IsEnabled() const;
 79445:   NS_IMETHOD              SetFocus(bool aRaise);
 23738:   NS_IMETHOD              GetBounds(nsIntRect &aRect);
 29835:   NS_IMETHOD              GetScreenBounds(nsIntRect &aRect);
 23738:   NS_IMETHOD              GetClientBounds(nsIntRect &aRect);
 48256:   virtual nsIntPoint      GetClientOffset();
     1:   NS_IMETHOD              SetBackgroundColor(const nscolor &aColor);
     1:   NS_IMETHOD              SetCursor(imgIContainer* aCursor,
108991:                                     uint32_t aHotspotX, uint32_t aHotspotY);
 29835:   NS_IMETHOD              SetCursor(nsCursor aCursor);
 30515:   virtual nsresult        ConfigureChildren(const nsTArray<Configuration>& aConfigurations);
 79445:   NS_IMETHOD              MakeFullScreen(bool aFullScreen);
 79445:   NS_IMETHOD              HideWindowChrome(bool aShouldHide);
 87336:   NS_IMETHOD              Invalidate(bool aEraseBackground = false,
 80035:                                      bool aUpdateNCArea = false,
 80035:                                      bool aIncludeChildren = false);
 87336:   NS_IMETHOD              Invalidate(const nsIntRect & aRect);
108991:   virtual void*           GetNativeData(uint32_t aDataType);
108991:   virtual void            FreeNativeData(void * data, uint32_t aDataType);
     1:   NS_IMETHOD              SetTitle(const nsAString& aTitle);
     1:   NS_IMETHOD              SetIcon(const nsAString& aIconSpec);
 25183:   virtual nsIntPoint      WidgetToScreenOffset();
 48256:   virtual nsIntSize       ClientToWindowSize(const nsIntSize& aClientSize);
     1:   NS_IMETHOD              DispatchEvent(nsGUIEvent* event, nsEventStatus & aStatus);
 79445:   NS_IMETHOD              EnableDragDrop(bool aEnable);
 79445:   NS_IMETHOD              CaptureMouse(bool aCapture);
 82030:   NS_IMETHOD              CaptureRollupEvents(nsIRollupListener * aListener,
 79445:                                               bool aDoCapture, bool aConsumeRollupEvent);
108991:   NS_IMETHOD              GetAttention(int32_t aCycleCount);
 79445:   virtual bool            HasPendingInputEvent();
106838:   virtual LayerManager*   GetLayerManager(PLayersChild* aShadowManager = nullptr,
105710:                                           LayersBackend aBackendHint = mozilla::layers::LAYERS_NONE,
 75149:                                           LayerManagerPersistence aPersistence = LAYER_MANAGER_CURRENT,
106838:                                           bool* aAllowRetaining = nullptr);
     1:   gfxASurface             *GetThebesSurface();
 30327:   NS_IMETHOD              OnDefaultButtonLoaded(const nsIntRect &aButtonRect);
108991:   NS_IMETHOD              OverrideSystemMouseScrollSpeed(int32_t aOriginalDelta, bool aIsHorizontal, int32_t &aOverriddenDelta);
 33016: 
108991:   virtual nsresult        SynthesizeNativeKeyEvent(int32_t aNativeKeyboardLayout,
108991:                                                    int32_t aNativeKeyCode,
108991:                                                    uint32_t aModifierFlags,
 29835:                                                    const nsAString& aCharacters,
 29835:                                                    const nsAString& aUnmodifiedCharacters);
 33863:   virtual nsresult        SynthesizeNativeMouseEvent(nsIntPoint aPoint,
108991:                                                      uint32_t aNativeMessage,
108991:                                                      uint32_t aModifierFlags);
 95203: 
 95203:   virtual nsresult        SynthesizeNativeMouseMove(nsIntPoint aPoint)
 95203:                           { return SynthesizeNativeMouseEvent(aPoint, MOUSEEVENTF_MOVE, 0); }
 95203: 
 93735:   virtual nsresult        SynthesizeNativeMouseScrollEvent(nsIntPoint aPoint,
108991:                                                            uint32_t aNativeMessage,
 93735:                                                            double aDeltaX,
 93735:                                                            double aDeltaY,
 93735:                                                            double aDeltaZ,
108991:                                                            uint32_t aModifierFlags,
108991:                                                            uint32_t aAdditionalFlags);
     1:   NS_IMETHOD              ResetInputState();
 82841:   NS_IMETHOD_(void)       SetInputContext(const InputContext& aContext,
 82841:                                           const InputContextAction& aAction);
 82841:   NS_IMETHOD_(InputContext) GetInputContext();
     1:   NS_IMETHOD              CancelIMEComposition();
108991:   NS_IMETHOD              GetToggledKeyState(uint32_t aKeyCode, bool* aLEDState);
 48711:   NS_IMETHOD              RegisterTouchWindow();
 48711:   NS_IMETHOD              UnregisterTouchWindow();
 29835: #ifdef MOZ_XUL
 29835:   virtual void            SetTransparencyMode(nsTransparencyMode aMode);
 29835:   virtual nsTransparencyMode GetTransparencyMode();
 69806:   virtual void            UpdateOpaqueRegion(const nsIntRegion& aOpaqueRegion);
 29835: #endif // MOZ_XUL
 24836: #ifdef NS_ENABLE_TSF
 79445:   NS_IMETHOD              OnIMEFocusChange(bool aFocus);
108991:   NS_IMETHOD              OnIMETextChange(uint32_t aStart, uint32_t aOldEnd, uint32_t aNewEnd);
 24836:   NS_IMETHOD              OnIMESelectionChange(void);
 24836: #endif // NS_ENABLE_TSF
 46200:   NS_IMETHOD              GetNonClientMargins(nsIntMargin &margins);
 46200:   NS_IMETHOD              SetNonClientMargins(nsIntMargin &margins);
 79445:   void                    SetDrawsInTitlebar(bool aState);
 24836: 
 29835:   /**
 29835:    * Event helpers
 29835:    */
106838:   void                    InitEvent(nsGUIEvent& event, nsIntPoint* aPoint = nullptr);
108991:   virtual bool            DispatchMouseEvent(uint32_t aEventType, WPARAM wParam,
     1:                                              LPARAM lParam,
 79445:                                              bool aIsContextMenuKey = false,
108991:                                              int16_t aButton = nsMouseEvent::eLeftButton,
108991:                                              uint16_t aInputSource = nsIDOMMouseEvent::MOZ_SOURCE_MOUSE);
 79445:   virtual bool            DispatchWindowEvent(nsGUIEvent* event);
 79445:   virtual bool            DispatchWindowEvent(nsGUIEvent*event, nsEventStatus &aStatus);
 97476:   void                    InitKeyEvent(nsKeyEvent& aKeyEvent,
 97476:                                        const NativeKey& aNativeKey,
102101:                                        const mozilla::widget::ModifierKeyState &aModKeyState);
 97476:   virtual bool            DispatchKeyEvent(nsKeyEvent& aKeyEvent,
 97476:                                            const MSG *aMsgSentToPlugin);
 49149:   void                    DispatchPendingEvents();
 79445:   bool                    DispatchPluginEvent(UINT aMessage,
 49149:                                               WPARAM aWParam,
 49149:                                               LPARAM aLParam,
 79445:                                               bool aDispatchPendingEvents);
 49149: 
 79445:   void                    SuppressBlurEvents(bool aSuppress); // Called from nsFilePicker
 79445:   bool                    BlurEventsSuppressed();
 29835: #ifdef ACCESSIBILITY
 99648:   Accessible* GetRootAccessible();
 29835: #endif // ACCESSIBILITY
 27961: 
 29835:   /**
 29835:    * Window utilities
 29835:    */
 79445:   nsWindow*               GetTopLevelWindow(bool aStopOnDialogOrPopup);
 29835:   HWND                    GetWindowHandle() { return mWnd; }
 29835:   WNDPROC                 GetPrevWindowProc() { return mPrevWndProc; }
 31532:   WindowHook&             GetWindowHook() { return mWindowHook; }
 79445:   nsWindow*               GetParentWindow(bool aIncludeOwner);
 58811:   // Get an array of all nsWindow*s on the main thread.
 58811:   typedef void            (WindowEnumCallback)(nsWindow*);
 58811:   static void             EnumAllWindows(WindowEnumCallback aCallback);
 29835: 
 29835:   /**
 29835:    * Misc.
 29835:    */
 79445:   virtual bool            AutoErase(HDC dc);
 23738:   nsIntPoint*             GetLastPoint() { return &mLastPoint; }
 29835:   // needed in nsIMM32Handler.cpp
 82840:   bool                    PluginHasFocus()
 82840:   {
 82842:     return (mInputContext.mIMEState.mEnabled == IMEState::PLUGIN);
 82840:   }
 79445:   bool                    IsTopLevelWidget() { return mIsTopWidgetWindow; }
 58814:   /**
 58814:    * Start allowing Direct3D9 to be used by widgets when GetLayerManager is
 58814:    * called.
 58814:    *
 58814:    * @param aReinitialize Call GetLayerManager on widgets to ensure D3D9 is
 58814:    *                      initialized, this is usually called when this function
 58814:    *                      is triggered by timeout and not user/web interaction.
 58814:    */
 58814:   static void             StartAllowingD3D9(bool aReinitialize);
 27961: 
 73536:   /**
 73536:    * AssociateDefaultIMC() associates or disassociates the default IMC for
 73536:    * the window.
 73536:    *
 73536:    * @param aAssociate    TRUE, associates the default IMC with the window.
 73536:    *                      Otherwise, disassociates the default IMC from the
 73536:    *                      window.
 73536:    * @return              TRUE if this method associated the default IMC with
 73536:    *                      disassociated window or disassociated the default IMC
 73536:    *                      from associated window.
 73536:    *                      Otherwise, i.e., if this method did nothing actually,
 73536:    *                      FALSE.
 73536:    */
 79445:   bool                    AssociateDefaultIMC(bool aAssociate);
 73536: 
 79445:   bool HasTaskbarIconBeenCreated() { return mHasTaskbarIconBeenCreated; }
 33486:   // Called when either the nsWindow or an nsITaskbarTabPreview receives the noticiation that this window
 33486:   // has its icon placed on the taskbar.
 79445:   void SetHasTaskbarIconBeenCreated(bool created = true) { mHasTaskbarIconBeenCreated = created; }
 33486: 
 33486:   // Getter/setter for the nsITaskbarWindowPreview for this nsWindow
 33486:   already_AddRefed<nsITaskbarWindowPreview> GetTaskbarPreview() {
 33486:     nsCOMPtr<nsITaskbarWindowPreview> preview(do_QueryReferent(mTaskbarPreview));
 33486:     return preview.forget();
 33486:   }
 33486:   void SetTaskbarPreview(nsITaskbarWindowPreview *preview) { mTaskbarPreview = do_GetWeakReference(preview); }
 33486: 
 54312:   NS_IMETHOD              ReparentNativeWidget(nsIWidget* aNewParent);
 84178: 
 84178:   // Open file picker tracking
 84178:   void                    PickerOpen();
 84178:   void                    PickerClosed();
 84178: 
 84575:   bool                    const DestroyCalled() { return mDestroyCalled; }
 93735: 
108991:   static void             SetupKeyModifiersSequence(nsTArray<KeyPair>* aArray, uint32_t aModifiers);
101914: 
101914:   virtual bool            UseOffMainThreadCompositing();
     1: protected:
     1: 
 59750:   // A magic number to identify the FAKETRACKPOINTSCROLLABLE window created
 59750:   // when the trackpoint hack is enabled.
 59750:   enum { eFakeTrackPointScrollableID = 0x46545053 };
 59750: 
 29835:   /**
 29835:    * Callbacks
 29835:    */
 29835:   static LRESULT CALLBACK WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
 50680:   static LRESULT CALLBACK WindowProcInternal(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
 50680: 
 29835:   static BOOL CALLBACK    BroadcastMsgToChildren(HWND aWnd, LPARAM aMsg);
 29835:   static BOOL CALLBACK    BroadcastMsg(HWND aTopWindow, LPARAM aMsg);
 29835:   static BOOL CALLBACK    DispatchStarvedPaints(HWND aTopWindow, LPARAM aMsg);
 48711:   static BOOL CALLBACK    RegisterTouchForDescendants(HWND aTopWindow, LPARAM aMsg);
 48711:   static BOOL CALLBACK    UnregisterTouchForDescendants(HWND aTopWindow, LPARAM aMsg);
     1:   static LRESULT CALLBACK MozSpecialMsgFilter(int code, WPARAM wParam, LPARAM lParam);
     1:   static LRESULT CALLBACK MozSpecialWndProc(int code, WPARAM wParam, LPARAM lParam);
     1:   static LRESULT CALLBACK MozSpecialMouseProc(int code, WPARAM wParam, LPARAM lParam);
     1:   static VOID    CALLBACK HookTimerForPopups( HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime );
 51000:   static BOOL    CALLBACK ClearResourcesCallback(HWND aChild, LPARAM aParam);
 58811:   static BOOL    CALLBACK EnumAllChildWindProc(HWND aWnd, LPARAM aParam);
 58811:   static BOOL    CALLBACK EnumAllThreadWindowProc(HWND aWnd, LPARAM aParam);
 58814:   static void             AllowD3D9Callback(nsWindow *aWindow);
 58814:   static void             AllowD3D9WithReinitializeCallback(nsWindow *aWindow);
     1: 
 29835:   /**
 29835:    * Window utilities
 29835:    */
 29835:   LPARAM                  lParamToScreen(LPARAM lParam);
 29835:   LPARAM                  lParamToClient(LPARAM lParam);
 29835:   virtual void            SubclassWindow(BOOL bState);
 79445:   bool                    CanTakeFocus();
108991:   bool                    UpdateNonClientMargins(int32_t aSizeMode = -1, bool aReflowWindow = true);
 79445:   void                    UpdateGetWindowInfoCaptionStatus(bool aActiveCaption);
 47788:   void                    ResetLayout();
 49251:   void                    InvalidateNonClientRegion();
 49251:   HRGN                    ExcludeNonClientFromPaintRegion(HRGN aRegion);
 57092:   static void             GetMainWindowClass(nsAString& aClass);
 79445:   bool                    HasGlass() const {
 50770:     return mTransparencyMode == eTransparencyGlass ||
 50770:            mTransparencyMode == eTransparencyBorderlessGlass;
 50770:   }
     1: 
 29835:   /**
 29835:    * Event processing helpers
 29835:    */
 79445:   bool                    DispatchPluginEvent(const MSG &aMsg);
108457:   void                    DispatchFocusToTopLevelWindow(bool aIsActivate);
108991:   bool                    DispatchStandardEvent(uint32_t aMsg);
108991:   bool                    DispatchCommandEvent(uint32_t aEventCommand);
 29835:   void                    RelayMouseEvent(UINT aMsg, WPARAM wParam, LPARAM lParam);
 60495:   static void             RemoveNextCharMessage(HWND aWnd);
 68737:   void                    RemoveMessageAndDispatchPluginEvent(UINT aFirstMsg,
 68737:                             UINT aLastMsg,
106838:                             nsFakeCharMessage* aFakeCharMessage = nullptr);
 79445:   virtual bool            ProcessMessage(UINT msg, WPARAM &wParam,
 27961:                                          LPARAM &lParam, LRESULT *aRetValue);
 79445:   bool                    ProcessMessageForPlugin(const MSG &aMsg,
 79445:                                                   LRESULT *aRetValue, bool &aCallDefWndProc);
 22788:   LRESULT                 ProcessCharMessage(const MSG &aMsg,
 79445:                                              bool *aEventDispatched);
 22788:   LRESULT                 ProcessKeyUpMessage(const MSG &aMsg,
 79445:                                               bool *aEventDispatched);
 22788:   LRESULT                 ProcessKeyDownMessage(const MSG &aMsg,
 79445:                                                 bool *aEventDispatched);
 79445:   static bool             EventIsInsideWindow(UINT Msg, nsWindow* aWindow);
 29835:   // Convert nsEventStatus value to a windows boolean
 79445:   static bool             ConvertStatus(nsEventStatus aStatus);
 82031:   static void             PostSleepWakeNotification(const bool aIsSleepMode);
108991:   int32_t                 ClientMarginHitTestPoint(int32_t mx, int32_t my);
 79445:   static bool             IsRedirectedKeyDownMessage(const MSG &aMsg);
 60495:   static void             ForgetRedirectedKeyDownMessage()
 60495:   {
 60495:     sRedirectedKeyDown.message = WM_NULL;
 60495:   }
 22788: 
 29835:   /**
 29835:    * Event handlers
 29835:    */
     1:   virtual void            OnDestroy();
108991:   virtual bool            OnMove(int32_t aX, int32_t aY);
 79445:   virtual bool            OnResize(nsIntRect &aWindowRect);
 97476:   /**
 97476:    * @param aVirtualKeyCode     If caller knows which key exactly caused the
 97476:    *                            aMsg, set the virtual key code.
 97476:    *                            Otherwise, 0.
 97476:    * @param aScanCode           If aVirutalKeyCode isn't 0, set the scan code.
 97476:    */
 27961:   LRESULT                 OnChar(const MSG &aMsg,
 97476:                                  const NativeKey& aNativeKey,
102101:                                  const mozilla::widget::ModifierKeyState &aModKeyState,
 79445:                                  bool *aEventDispatched,
108991:                                  uint32_t aFlags = 0);
 27961:   LRESULT                 OnKeyDown(const MSG &aMsg,
102101:                                     const mozilla::widget::ModifierKeyState &aModKeyState,
 79445:                                     bool *aEventDispatched,
 14962:                                     nsFakeCharMessage* aFakeCharMessage);
 27961:   LRESULT                 OnKeyUp(const MSG &aMsg,
102101:                                   const mozilla::widget::ModifierKeyState &aModKeyState,
 79445:                                   bool *aEventDispatched);
 79445:   bool                    OnGesture(WPARAM wParam, LPARAM lParam);
 79445:   bool                    OnTouch(WPARAM wParam, LPARAM lParam);
 79445:   bool                    OnHotKey(WPARAM wParam, LPARAM lParam);
 29835:   BOOL                    OnInputLangChange(HKL aHKL);
108991:   bool                    OnPaint(HDC aDC, uint32_t aNestingLevel);
 79445:   void                    OnWindowPosChanged(WINDOWPOS *wp, bool& aResult);
 29835:   void                    OnWindowPosChanging(LPWINDOWPOS& info);
 82569:   void                    OnSysColorChanged();
     1: 
 29835:   /**
 40944:    * Function that registers when the user has been active (used for detecting
 40944:    * when the user is idle).
 40944:    */
 40944:   void                    UserActivity();
 40944: 
108991:   int32_t                 GetHeight(int32_t aProposedHeight);
 57092:   void                    GetWindowClass(nsString& aWindowClass);
 57092:   void                    GetWindowPopupClass(nsString& aWindowClass);
 29835:   virtual DWORD           WindowStyle();
 57092:   DWORD                   WindowExStyle();
 57092: 
 57092:   void                    RegisterWindowClass(const nsString& aClassName,
 57092:                                               UINT aExtraStyle,
 57092:                                               LPWSTR aIconID);
     1: 
 29835:   /**
 29835:    * XP and Vista theming support for windows with rounded edges
 29835:    */
 26576:   void                    ClearThemeRegion();
 26576:   void                    SetThemeRegion();
 26616: 
 29835:   /**
 29835:    * Popup hooks
 29835:    */
 29835:   static void             ScheduleHookTimer(HWND aWnd, UINT aMsgId);
 29835:   static void             RegisterSpecialDropdownHooks();
 29835:   static void             UnregisterSpecialDropdownHooks();
 29835:   static BOOL             DealWithPopups(HWND inWnd, UINT inMsg, WPARAM inWParam, LPARAM inLParam, LRESULT* outResult);
 29835: 
 29835:   /**
 29835:    * Window transparency helpers
 29835:    */
 29835: #ifdef MOZ_XUL
 29835: private:
 29835:   void                    SetWindowTranslucencyInner(nsTransparencyMode aMode);
 29835:   nsTransparencyMode      GetWindowTranslucencyInner() const { return mTransparencyMode; }
108991:   void                    ResizeTranslucentWindow(int32_t aNewWidth, int32_t aNewHeight, bool force = false);
 29835:   nsresult                UpdateTranslucentWindow();
104347:   void                    ClearTranslucentWindow();
 29835:   void                    SetupTranslucentWindowMemoryBitmap(nsTransparencyMode aMode);
 39718:   void                    UpdateGlass();
 29835: protected:
 29835: #endif // MOZ_XUL
 29835: 
 38103:   static bool             IsAsyncResponseEvent(UINT aMsg, LRESULT& aResult);
 38400:   void                    IPCWindowProcHandler(UINT& msg, WPARAM& wParam, LPARAM& lParam);
 38103: 
 29835:   /**
 29835:    * Misc.
 29835:    */
 26616:   void                    StopFlashing();
 79445:   static bool             IsTopLevelMouseExit(HWND aWnd);
 30515:   nsresult                SetWindowClipRegion(const nsTArray<nsIntRect>& aRects,
 79445:                                               bool aIntersectWithExisting);
 79445:   nsIntRegion             GetRegionToPaint(bool aForceFullRepaint, 
 32038:                                            PAINTSTRUCT ps, HDC aDC);
 34786:   static void             ActivateOtherWindowHelper(HWND aWnd);
 51000:   void                    ClearCachedResources();
118265:   nsIWidgetListener*      GetPaintListener();
     1: 
     1: protected:
 43018:   nsCOMPtr<nsIWidget>   mParent;
 29835:   nsIntSize             mLastSize;
 29835:   nsIntPoint            mLastPoint;
 29835:   HWND                  mWnd;
 29835:   WNDPROC               mPrevWndProc;
 29835:   HBRUSH                mBrush;
 79445:   bool                  mIsTopWidgetWindow;
 79445:   bool                  mInDtor;
 79445:   bool                  mIsVisible;
 79445:   bool                  mUnicodeWidget;
 79445:   bool                  mPainting;
 79445:   bool                  mTouchWindow;
 79445:   bool                  mDisplayPanFeedback;
 79445:   bool                  mHideChrome;
 79445:   bool                  mIsRTL;
 79445:   bool                  mFullscreenMode;
 79445:   bool                  mMousePresent;
 84178:   bool                  mDestroyCalled;
108991:   uint32_t              mBlurSuppressLevel;
 29835:   DWORD_PTR             mOldStyle;
 29835:   DWORD_PTR             mOldExStyle;
 82840:   InputContext mInputContext;
 29835:   nsNativeDragTarget*   mNativeDragTarget;
 29835:   HKL                   mLastKeyboardLayout;
 46335:   nsSizeMode            mOldSizeMode;
 97778:   nsSizeMode            mLastSizeMode;
 31532:   WindowHook            mWindowHook;
 62480:   DWORD                 mAssumeWheelIsZoomUntil;
108991:   uint32_t              mPickerDisplayCount;
103754:   HICON                 mIconSmall;
103754:   HICON                 mIconBig;
 79445:   static bool           sDropShadowEnabled;
108991:   static uint32_t       sInstanceCount;
 29835:   static TriStateBool   sCanQuit;
 29835:   static nsWindow*      sCurrentWindow;
 29835:   static BOOL           sIsOleInitialized;
 29835:   static HCURSOR        sHCursor;
 29835:   static imgIContainer* sCursorImgContainer;
 79445:   static bool           sSwitchKeyboardLayout;
 79445:   static bool           sJustGotDeactivate;
 79445:   static bool           sJustGotActivate;
 79445:   static bool           sIsInMouseCapture;
 29835:   static int            sTrimOnMinimize;
 57092:   static const char*    sDefaultMainWindowClass;
 58814:   static bool           sAllowD3D9;
 63258: 
 63258:   // Always use the helper method to read this property.  See bug 603793.
 63258:   static TriStateBool   sHasBogusPopupsDropShadowOnMultiMonitor;
 63258:   static bool           HasBogusPopupsDropShadowOnMultiMonitor();
 63258: 
108991:   static uint32_t       sOOPPPluginFocusEvent;
     1: 
 46200:   // Non-client margin settings
 46200:   // Pre-calculated outward offset applied to default frames
 46200:   nsIntMargin           mNonClientOffset;
 46200:   // Margins set by the owner
 46200:   nsIntMargin           mNonClientMargins;
 51610: 
 46200:   // Indicates custom frames are enabled
 79445:   bool                  mCustomNonClient;
 46200:   // Cached copy of L&F's resize border  
108991:   int32_t               mHorResizeMargin;
108991:   int32_t               mVertResizeMargin;
 46200:   // Height of the caption plus border
108991:   int32_t               mCaptionHeight;
 46200: 
103224:   nsCOMPtr<nsIIdleServiceInternal> mIdleService;
 40944: 
 29835:   // Hook Data Memebers for Dropdowns. sProcessHook Tells the
 29835:   // hook methods whether they should be processing the hook
 29835:   // messages.
 29835:   static HHOOK          sMsgFilterHook;
 29835:   static HHOOK          sCallProcHook;
 29835:   static HHOOK          sCallMouseHook;
 79445:   static bool           sProcessHook;
 29835:   static UINT           sRollupMsgId;
 29835:   static HWND           sRollupMsgWnd;
 29835:   static UINT           sHookTimerId;
     1: 
 29835:   // Rollup Listener
 29835:   static nsIWidget*     sRollupWidget;
 79445:   static bool           sRollupConsumeEvent;
 29835:   static nsIRollupListener* sRollupListener;
     1: 
 29835:   // Mouse Clicks - static variable definitions for figuring
 29835:   // out 1 - 3 Clicks.
 29835:   static POINT          sLastMousePoint;
 29835:   static POINT          sLastMouseMovePoint;
 29835:   static LONG           sLastMouseDownTime;
 29835:   static LONG           sLastClickCount;
 29835:   static BYTE           sLastMouseButton;
 29835: 
 29835:   // Graphics
 29835:   HDC                   mPaintDC; // only set during painting
 30087: 
 38727: #ifdef CAIRO_HAS_D2D_SURFACE
 38727:   nsRefPtr<gfxD2DSurface>    mD2DWindowSurface; // Surface for this window.
 38727: #endif
 38727: 
 29835:   // Transparency
 29835: #ifdef MOZ_XUL
 29835:   // Use layered windows to support full 256 level alpha translucency
 43936:   nsRefPtr<gfxASurface> mTransparentSurface;
 29835:   HDC                   mMemoryDC;
 29835:   nsTransparencyMode    mTransparencyMode;
 39718:   nsIntRegion           mPossiblyTransparentRegion;
 39718:   MARGINS               mGlassMargins;
 29835: #endif // MOZ_XUL
 29835: 
 29835:   // Win7 Gesture processing and management
 29835:   nsWinGesture          mGesture;
 29835: 
 33486:   // Weak ref to the nsITaskbarWindowPreview associated with this window
 33486:   nsWeakPtr             mTaskbarPreview;
 33486:   // True if the taskbar (possibly through the tab preview) tells us that the
 33486:   // icon has been created on the taskbar.
 79445:   bool                  mHasTaskbarIconBeenCreated;
 33486: 
 87254:   // The point in time at which the last paint completed. We use this to avoid
 87254:   //  painting too rapidly in response to frequent input events.
 87254:   TimeStamp mLastPaintEndTime;
 87254: 
 60495:   // sRedirectedKeyDown is WM_KEYDOWN message or WM_SYSKEYDOWN message which
 60495:   // was reirected to SendInput() API by OnKeyDown().
 60495:   static MSG            sRedirectedKeyDown;
 60495: 
 79445:   static bool sNeedsToInitMouseWheelSettings;
 69947:   static void InitMouseWheelScrollData();
 69947: 
 60495:   // If a window receives WM_KEYDOWN message or WM_SYSKEYDOWM message which is
 60495:   // redirected message, OnKeyDowm() prevents to dispatch NS_KEY_DOWN event
 60495:   // because it has been dispatched before the message was redirected.
 60495:   // However, in some cases, ProcessKeyDownMessage() doesn't call OnKeyDown().
 60495:   // Then, ProcessKeyDownMessage() needs to forget the redirected message and
 60495:   // remove WM_CHAR message or WM_SYSCHAR message for the redirected keydown
 60495:   // message.  AutoForgetRedirectedKeyDownMessage struct is a helper struct
 60495:   // for doing that.  This must be created in stack.
 60495:   struct AutoForgetRedirectedKeyDownMessage
 60495:   {
 60495:     AutoForgetRedirectedKeyDownMessage(nsWindow* aWindow, const MSG &aMsg) :
 60495:       mCancel(!nsWindow::IsRedirectedKeyDownMessage(aMsg)),
 60495:       mWindow(aWindow), mMsg(aMsg)
 60495:     {
 60495:     }
 60495: 
 60495:     ~AutoForgetRedirectedKeyDownMessage()
 60495:     {
 60495:       if (mCancel) {
 60495:         return;
 60495:       }
 60495:       // Prevent unnecessary keypress event
 60495:       if (!mWindow->mOnDestroyCalled) {
 60495:         nsWindow::RemoveNextCharMessage(mWindow->mWnd);
 60495:       }
 60495:       // Foreget the redirected message
 60495:       nsWindow::ForgetRedirectedKeyDownMessage();
 60495:     }
 60495: 
 79445:     bool mCancel;
 60730:     nsRefPtr<nsWindow> mWindow;
 60495:     const MSG &mMsg;
 60495:   };
     1: };
     1: 
 29835: /**
 29835:  * A child window is a window with different style.
 29835:  */
     1: class ChildWindow : public nsWindow {
     1: 
     1: public:
     1:   ChildWindow() {}
     1: 
     1: protected:
     1:   virtual DWORD WindowStyle();
     1: };
     1: 
 30075: #endif // Window_h__
