 32195: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 42402: 
 32195: #include "WebGLContext.h"
 79603: #include "WebGLExtensions.h"
 32195: 
 32195: #include "nsIConsoleService.h"
 32195: #include "nsServiceManagerUtils.h"
 32195: #include "nsIClassInfoImpl.h"
 32195: #include "nsContentUtils.h"
 34453: #include "nsIXPConnect.h"
108290: #include "nsError.h"
 54216: #include "nsIGfxInfo.h"
 32195: 
 57631: #include "nsIPropertyBag.h"
 57631: #include "nsIVariant.h"
 57631: 
 57632: #include "imgIEncoder.h"
 57632: 
 32195: #include "gfxContext.h"
 32195: #include "gfxPattern.h"
 46990: #include "gfxUtils.h"
 32195: 
 34453: #include "CanvasUtils.h"
 64542: #include "nsDisplayList.h"
 34453: 
 42402: #include "GLContextProvider.h"
 42402: 
 63285: #include "gfxCrashReporterUtils.h"
 63285: 
 50430: #include "nsSVGEffects.h"
 50430: 
 49076: #include "prenv.h"
 49076: 
 73503: #include "mozilla/Preferences.h"
101135: #include "mozilla/Services.h"
 78509: #include "mozilla/Telemetry.h"
 73503: 
 95821: #include "nsIObserverService.h"
103385: #include "mozilla/Services.h"
100046: #include "mozilla/dom/WebGLRenderingContextBinding.h"
 95821: 
108884: #include "Layers.h"
108884: 
 32195: using namespace mozilla;
 42403: using namespace mozilla::gl;
 51950: using namespace mozilla::layers;
 32195: 
 95821: NS_IMPL_ISUPPORTS1(WebGLMemoryPressureObserver, nsIObserver)
 95821: 
 95821: NS_IMETHODIMP
 95821: WebGLMemoryPressureObserver::Observe(nsISupports* aSubject,
 95821:                                      const char* aTopic,
 95821:                                      const PRUnichar* aSomeData)
 95821: {
 95821:   if (strcmp(aTopic, "memory-pressure") == 0)
 95821:     mContext->ForceLoseContext();
 95821:   return NS_OK;
 95821: }
 95821: 
 73514: 
 57635: nsresult NS_NewCanvasRenderingContextWebGL(nsIDOMWebGLRenderingContext** aResult);
 32195: 
 32195: nsresult
 57635: NS_NewCanvasRenderingContextWebGL(nsIDOMWebGLRenderingContext** aResult)
 32195: {
 78509:     Telemetry::Accumulate(Telemetry::CANVAS_WEBGL_USED, 1);
 57635:     nsIDOMWebGLRenderingContext* ctx = new WebGLContext();
 32195:     if (!ctx)
 32195:         return NS_ERROR_OUT_OF_MEMORY;
 32195: 
 32195:     NS_ADDREF(*aResult = ctx);
 32195:     return NS_OK;
 32195: }
 32195: 
107137: WebGLContextOptions::WebGLContextOptions()
107165:     : alpha(true), depth(true), stencil(false),
107137:       premultipliedAlpha(true), antialias(true),
107137:       preserveDrawingBuffer(false)
107137: {
107137:     // Set default alpha state based on preference.
107165:     if (Preferences::GetBool("webgl.default-no-alpha", false))
107166:         alpha = false;
107137: }
107137: 
 32195: WebGLContext::WebGLContext()
106838:     : gl(nullptr)
 32195: {
100046:     SetIsDOMBinding();
102165:     mExtensions.SetLength(WebGLExtensionID_number_of_extensions);
 94084: 
 47653:     mGeneration = 0;
 80486:     mInvalidated = false;
 80486:     mResetLayer = true;
 80486:     mOptionsFrozen = false;
 47653: 
 47653:     mActiveTexture = 0;
 73522:     mWebGLError = LOCAL_GL_NO_ERROR;
 80486:     mPixelStoreFlipY = false;
 80486:     mPixelStorePremultiplyAlpha = false;
 58672:     mPixelStoreColorspaceConversion = BROWSER_DEFAULT_WEBGL;
 47653: 
 80486:     mShaderValidation = true;
 47653: 
 80486:     mBlackTexturesAreInitialized = false;
 51422:     mFakeBlackStatus = DoNotNeedFakeBlack;
 51898: 
 51898:     mVertexAttrib0Vector[0] = 0;
 51898:     mVertexAttrib0Vector[1] = 0;
 51898:     mVertexAttrib0Vector[2] = 0;
 51898:     mVertexAttrib0Vector[3] = 1;
 63064:     mFakeVertexAttrib0BufferObjectVector[0] = 0;
 63064:     mFakeVertexAttrib0BufferObjectVector[1] = 0;
 63064:     mFakeVertexAttrib0BufferObjectVector[2] = 0;
 63064:     mFakeVertexAttrib0BufferObjectVector[3] = 1;
 63064:     mFakeVertexAttrib0BufferObjectSize = 0;
 63064:     mFakeVertexAttrib0BufferObject = 0;
 63064:     mFakeVertexAttrib0BufferStatus = VertexAttrib0Status::Default;
 70166: 
 70166:     // these are de default values, see 6.2 State tables in the OpenGL ES 2.0.25 spec
 70166:     mColorWriteMask[0] = 1;
 70166:     mColorWriteMask[1] = 1;
 70166:     mColorWriteMask[2] = 1;
 70166:     mColorWriteMask[3] = 1;
 70166:     mDepthWriteMask = 1;
 70166:     mColorClearValue[0] = 0.f;
 70166:     mColorClearValue[1] = 0.f;
 70166:     mColorClearValue[2] = 0.f;
 70166:     mColorClearValue[3] = 0.f;
 70166:     mDepthClearValue = 1.f;
 70166:     mStencilClearValue = 0;
 70170:     mStencilRefFront = 0;
 70170:     mStencilRefBack = 0;
 70170:     mStencilValueMaskFront = 0xffffffff;
 70170:     mStencilValueMaskBack  = 0xffffffff;
 70170:     mStencilWriteMaskFront = 0xffffffff;
 70170:     mStencilWriteMaskBack  = 0xffffffff;
 70170: 
 70166:     mScissorTestEnabled = 0;
 70166:     mDitherEnabled = 1;
 70168:     mBackbufferClearingStatus = BackbufferClearingStatus::NotClearedSinceLastPresented;
 72544:     
 72544:     // initialize some GL values: we're going to get them from the GL and use them as the sizes of arrays,
 72544:     // so in case glGetIntegerv leaves them uninitialized because of a GL bug, we would have very weird crashes.
 72544:     mGLMaxVertexAttribs = 0;
 72544:     mGLMaxTextureUnits = 0;
 72544:     mGLMaxTextureSize = 0;
 72544:     mGLMaxCubeMapTextureSize = 0;
 72544:     mGLMaxTextureImageUnits = 0;
 72544:     mGLMaxVertexTextureImageUnits = 0;
 72544:     mGLMaxVaryingVectors = 0;
 72544:     mGLMaxFragmentUniformVectors = 0;
 72544:     mGLMaxVertexUniformVectors = 0;
 72544: 
 72544:     // See OpenGL ES 2.0.25 spec, 6.2 State Tables, table 6.13
 72544:     mPixelStorePackAlignment = 4;
 72544:     mPixelStoreUnpackAlignment = 4;
 73514: 
 90522:     WebGLMemoryMultiReporterWrapper::AddWebGLContext(this);
 80903: 
 86626:     mAllowRestore = true;
 95823:     mContextLossTimerRunning = false;
 95823:     mDrawSinceContextLossTimerSet = false;
 82479:     mContextRestorer = do_CreateInstance("@mozilla.org/timer;1");
 86626:     mContextStatus = ContextStable;
 86626:     mContextLostErrorSet = false;
 99229: 
 99787:     mAlreadyGeneratedWarnings = 0;
106451:     mAlreadyWarnedAboutFakeVertexAttrib0 = false;
107259: 
107259:     mLastUseIndex = 0;
 32195: }
 32195: 
 32195: WebGLContext::~WebGLContext()
 32195: {
 47910:     DestroyResourcesAndContext();
 90522:     WebGLMemoryMultiReporterWrapper::RemoveWebGLContext(this);
 95823:     TerminateContextLossTimer();
106838:     mContextRestorer = nullptr;
 47910: }
 47910: 
100046: JSObject*
100046: WebGLContext::WrapObject(JSContext *cx, JSObject *scope,
100046:                          bool *triedToWrap)
100046: {
100046:     return dom::WebGLRenderingContextBinding::Wrap(cx, scope, this,
100046:                                                    triedToWrap);
100046: }
100046: 
 47910: void
 47910: WebGLContext::DestroyResourcesAndContext()
 47910: {
 95824:     if (mMemoryPressureObserver) {
 95824:         nsCOMPtr<nsIObserverService> observerService
 95824:             = mozilla::services::GetObserverService();
 95824:         if (observerService) {
 95824:             observerService->RemoveObserver(mMemoryPressureObserver,
 95824:                                             "memory-pressure");
 95824:         }
106838:         mMemoryPressureObserver = nullptr;
 95824:     }
 95824: 
 47910:     if (!gl)
 47910:         return;
 47910: 
 47910:     gl->MakeCurrent();
 47910: 
 83393:     mBound2DTextures.Clear();
 83393:     mBoundCubeMapTextures.Clear();
106838:     mBoundArrayBuffer = nullptr;
106838:     mBoundElementArrayBuffer = nullptr;
106838:     mCurrentProgram = nullptr;
106838:     mBoundFramebuffer = nullptr;
106838:     mBoundRenderbuffer = nullptr;
 47910: 
 83393:     mAttribBuffers.Clear();
 47910: 
 99704:     while (!mTextures.isEmpty())
 99704:         mTextures.getLast()->DeleteOnce();
 99704:     while (!mBuffers.isEmpty())
 99704:         mBuffers.getLast()->DeleteOnce();
 99704:     while (!mRenderbuffers.isEmpty())
 99704:         mRenderbuffers.getLast()->DeleteOnce();
 99704:     while (!mFramebuffers.isEmpty())
 99704:         mFramebuffers.getLast()->DeleteOnce();
 99704:     while (!mShaders.isEmpty())
 99704:         mShaders.getLast()->DeleteOnce();
 99704:     while (!mPrograms.isEmpty())
 99704:         mPrograms.getLast()->DeleteOnce();
 47910: 
 51422:     if (mBlackTexturesAreInitialized) {
 51422:         gl->fDeleteTextures(1, &mBlackTexture2D);
 51422:         gl->fDeleteTextures(1, &mBlackTextureCubeMap);
 80486:         mBlackTexturesAreInitialized = false;
 51422:     }
 51422: 
 63064:     if (mFakeVertexAttrib0BufferObject) {
 63064:         gl->fDeleteBuffers(1, &mFakeVertexAttrib0BufferObject);
 63064:     }
 63064: 
 47910:     // We just got rid of everything, so the context had better
 47910:     // have been going away.
 53695: #ifdef DEBUG
101690:     if (gl->DebugMode()) {
 47910:         printf_stderr("--- WebGL context destroyed: %p\n", gl.get());
101690:     }
 53695: #endif
 47910: 
106838:     gl = nullptr;
 32195: }
 32195: 
 32195: void
 32195: WebGLContext::Invalidate()
 32195: {
 64542:     if (mInvalidated)
 64542:         return;
 64542: 
 32195:     if (!mCanvasElement)
 32195:         return;
 32195: 
101146:     nsSVGEffects::InvalidateDirectRenderingObservers(mCanvasElement);
 50430: 
 80486:     mInvalidated = true;
106838:     mCanvasElement->InvalidateCanvasContent(nullptr);
 39587: }
 39587: 
 32195: //
 32195: // nsICanvasRenderingContextInternal
 32195: //
 32195: 
 57631: static bool
 57631: GetBoolFromPropertyBag(nsIPropertyBag *bag, const char *propName, bool *boolResult)
 57631: {
 57631:     nsCOMPtr<nsIVariant> vv;
 79445:     bool bv;
 57631: 
 57631:     nsresult rv = bag->GetProperty(NS_ConvertASCIItoUTF16(propName), getter_AddRefs(vv));
 57631:     if (NS_FAILED(rv) || !vv)
 57631:         return false;
 57631: 
 57631:     rv = vv->GetAsBool(&bv);
 57631:     if (NS_FAILED(rv))
 57631:         return false;
 57631: 
 57631:     *boolResult = bv ? true : false;
 57631:     return true;
 57631: }
 57631: 
 57631: NS_IMETHODIMP
 57631: WebGLContext::SetContextOptions(nsIPropertyBag *aOptions)
 57631: {
 57631:     if (!aOptions)
 57631:         return NS_OK;
 57631: 
 57631:     WebGLContextOptions newOpts;
 57631: 
 70165:     GetBoolFromPropertyBag(aOptions, "stencil", &newOpts.stencil);
 70165:     GetBoolFromPropertyBag(aOptions, "depth", &newOpts.depth);
 70165:     GetBoolFromPropertyBag(aOptions, "premultipliedAlpha", &newOpts.premultipliedAlpha);
 70165:     GetBoolFromPropertyBag(aOptions, "antialias", &newOpts.antialias);
 70165:     GetBoolFromPropertyBag(aOptions, "preserveDrawingBuffer", &newOpts.preserveDrawingBuffer);
107137:     GetBoolFromPropertyBag(aOptions, "alpha", &newOpts.alpha);
105610: 
 57631:     // enforce that if stencil is specified, we also give back depth
 57631:     newOpts.depth |= newOpts.stencil;
 57631: 
 58583: #if 0
 99231:     GenerateWarning("aaHint: %d stencil: %d depth: %d alpha: %d premult: %d preserve: %d\n",
 70165:                newOpts.antialias ? 1 : 0,
 57631:                newOpts.stencil ? 1 : 0,
 57631:                newOpts.depth ? 1 : 0,
 57631:                newOpts.alpha ? 1 : 0,
 70165:                newOpts.premultipliedAlpha ? 1 : 0,
 70165:                newOpts.preserveDrawingBuffer ? 1 : 0);
 58583: #endif
 57631: 
 57631:     if (mOptionsFrozen && newOpts != mOptions) {
 57631:         // Error if the options are already frozen, and the ones that were asked for
 57631:         // aren't the same as what they were originally.
 57631:         return NS_ERROR_FAILURE;
 57631:     }
 57631: 
 57631:     mOptions = newOpts;
 57631:     return NS_OK;
 57631: }
 57631: 
 32195: NS_IMETHODIMP
108991: WebGLContext::SetDimensions(int32_t width, int32_t height)
 32195: {
 71572:     /*** early success return cases ***/
 71572: 
115176:     if (!GetCanvas())
115176:         return NS_ERROR_FAILURE;
115176: 
115176:     GetCanvas()->InvalidateCanvas();
 64542: 
 69417:     if (gl && mWidth == width && mHeight == height)
 47910:         return NS_OK;
 47910: 
 70071:     // Zero-sized surfaces can cause problems.
 70071:     if (width == 0 || height == 0) {
 70071:         width = 1;
 70071:         height = 1;
 70071:     }
 70071: 
 80612:     // If we already have a gl context, then we just need to resize it
 80612:     if (gl) {
 85066:         MakeContextCurrent();
 85066: 
 80612:         gl->ResizeOffscreen(gfxIntSize(width, height)); // Doesn't matter if it succeeds (soft-fail)
 80612:         // It's unlikely that we'll get a proper-sized context if we recreate if we didn't on resize
 80612: 
 47910:         // everything's good, we're done here
 80612:         mWidth = gl->OffscreenActualSize().width;
 80612:         mHeight = gl->OffscreenActualSize().height;
 80486:         mResetLayer = true;
 85066: 
 85066:         gl->ClearSafely();
 85066: 
 47910:         return NS_OK;
 47910:     }
 47910: 
107259:     /*** End of early success return cases.
107259:      *** At this point we know that we're not just resizing an existing context,
107259:      *** we are initializing a new context.
107259:      ***/
 71572: 
107259:     // if we exceeded either the global or the per-principal limit for WebGL contexts,
107259:     // lose the oldest-used context now to free resources. Note that we can't do that
107259:     // in the WebGLContext constructor as we don't have a canvas element yet there.
107259:     // Here is the right place to do so, as we are about to create the OpenGL context
107259:     // and that is what can fail if we already have too many.
107259:     LoseOldestWebGLContextIfLimitExceeded();
 71572: 
 71572:     // Get some prefs for some preferred/overriden things
 73503:     NS_ENSURE_TRUE(Preferences::GetRootBranch(), NS_ERROR_FAILURE);
 71572: 
 87420: #ifdef XP_WIN
 79445:     bool preferEGL =
 79445:         Preferences::GetBool("webgl.prefer-egl", false);
 79445:     bool preferOpenGL =
 79445:         Preferences::GetBool("webgl.prefer-native-gl", false);
 84913: #endif
 79445:     bool forceEnabled =
 79445:         Preferences::GetBool("webgl.force-enabled", false);
100167:     bool useMesaLlvmPipe =
100167:         Preferences::GetBool("gfx.prefer-mesa-llvmpipe", false);
 79445:     bool disabled =
 79445:         Preferences::GetBool("webgl.disabled", false);
105610:     bool prefer16bit =
105610:         Preferences::GetBool("webgl.prefer-16bpp", false);
 71572: 
 91135:     ScopedGfxFeatureReporter reporter("WebGL", forceEnabled);
 91135: 
 71572:     if (disabled)
 71572:         return NS_ERROR_FAILURE;
 71572: 
 47910:     // We're going to create an entirely new context.  If our
 47910:     // generation is not 0 right now (that is, if this isn't the first
 47910:     // context we're creating), we may have to dispatch a context lost
 47910:     // event.
 47910: 
 43099:     // If incrementing the generation would cause overflow,
 43099:     // don't allow it.  Allowing this would allow us to use
 43099:     // resource handles created from older context generations.
 98543:     if (!(mGeneration + 1).isValid())
 47204:         return NS_ERROR_FAILURE; // exit without changing the value of mGeneration
 43099: 
 47907:     gl::ContextFormat format(gl::ContextFormat::BasicRGBA32);
 57631:     if (mOptions.depth) {
 57631:         format.depth = 24;
 57631:         format.minDepth = 16;
 57631:     }
 57631: 
 57631:     if (mOptions.stencil) {
 57631:         format.stencil = 8;
 57631:         format.minStencil = 8;
 57631:     }
 57631: 
 57631:     if (!mOptions.alpha) {
105610:         format.alpha = 0;
105610:         format.minAlpha = 0;
105610:     }
105610: 
105610:     // we should really have this behind a
105610:     // |gfxPlatform::GetPlatform()->GetScreenDepth() == 16| check, but
105610:     // for now it's just behind a pref for testing/evaluation.
105610:     if (prefer16bit) {
105610:         // Select 4444 or 565 on 16-bit displays; we won't/shouldn't
105610:         // hit this on the desktop, but let mobile know we're ok with
105610:         // it.  Note that we don't just set this to 4440 if no alpha,
105610:         // because that might cause us to choose 4444 anyway and we
105610:         // don't want that.
105610:         if (mOptions.alpha) {
105610:             format.red = 4;
105610:             format.green = 4;
105610:             format.blue = 4;
105610:             format.alpha = 4;
105610:         } else {
104028:             format.red = 5;
104028:             format.green = 6;
104028:             format.blue = 5;
104016:             format.alpha = 0;
105610:         }
104016:     }
104016: 
 81330:     bool forceMSAA =
 81330:         Preferences::GetBool("webgl.msaa-force", false);
 81330: 
108991:     int32_t status;
 81329:     nsCOMPtr<nsIGfxInfo> gfxInfo = do_GetService("@mozilla.org/gfx/info;1");
 81329:     if (mOptions.antialias &&
 82628:         gfxInfo &&
 81329:         NS_SUCCEEDED(gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_WEBGL_MSAA, &status))) {
 81330:         if (status == nsIGfxInfo::FEATURE_NO_INFO || forceMSAA) {
108991:             uint32_t msaaLevel = Preferences::GetUint("webgl.msaa-level", 2);
 80615:             format.samples = msaaLevel*msaaLevel;
 80615:         }
 81329:     }
 80615: 
 87420: #ifdef XP_WIN
 58583:     if (PR_GetEnv("MOZ_WEBGL_PREFER_EGL")) {
 80486:         preferEGL = true;
 58583:     }
 87420: #endif
 51417: 
 55263:     // Ask GfxInfo about what we should use
 79445:     bool useOpenGL = true;
 87420: 
 87420: #ifdef XP_WIN
 79445:     bool useANGLE = true;
 87420: #endif
 54216: 
 61566:     if (gfxInfo && !forceEnabled) {
 54216:         if (NS_SUCCEEDED(gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_WEBGL_OPENGL, &status))) {
 61297:             if (status != nsIGfxInfo::FEATURE_NO_INFO) {
 80486:                 useOpenGL = false;
 54216:             }
 54216:         }
 87420: #ifdef XP_WIN
 54216:         if (NS_SUCCEEDED(gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_WEBGL_ANGLE, &status))) {
 61297:             if (status != nsIGfxInfo::FEATURE_NO_INFO) {
 80486:                 useANGLE = false;
 54216:             }
 54216:         }
 87420: #endif
 54216:     }
 54216: 
 87420: #ifdef XP_WIN
 58583:     // allow forcing GL and not EGL/ANGLE
100167:     if (useMesaLlvmPipe || PR_GetEnv("MOZ_WEBGL_FORCE_OPENGL")) {
 80486:         preferEGL = false;
 80486:         useANGLE = false;
 80486:         useOpenGL = true;
 58583:     }
 87420: #endif
 58583: 
 49076: #ifdef XP_WIN
 58583:     // if we want EGL, try it now
 58583:     if (!gl && (preferEGL || useANGLE) && !preferOpenGL) {
 49076:         gl = gl::GLContextProviderEGL::CreateOffscreen(gfxIntSize(width, height), format);
 94088:         if (!gl || !InitAndValidateGL()) {
 99231:             GenerateWarning("Error during ANGLE OpenGL ES initialization");
 87419:             return NS_ERROR_FAILURE;
 49076:         }
 49076:     }
 87419: #endif
 49076: 
 87419:     // try the default provider, whatever that is
 54216:     if (!gl && useOpenGL) {
100167:         GLContext::ContextFlags flag = useMesaLlvmPipe 
100167:                                        ? GLContext::ContextFlagsMesaLLVMPipe
100167:                                        : GLContext::ContextFlagsNone;
100167:         gl = gl::GLContextProvider::CreateOffscreen(gfxIntSize(width, height), 
100167:                                                                format, flag);
 49076:         if (gl && !InitAndValidateGL()) {
100167:             GenerateWarning("Error during %s initialization", 
100167:                             useMesaLlvmPipe ? "Mesa LLVMpipe" : "OpenGL");
 87419:             return NS_ERROR_FAILURE;
 49076:         }
 49076:     }
 49076: 
 49076:     if (!gl) {
 99231:         GenerateWarning("Can't get a usable WebGL context");
 49076:         return NS_ERROR_FAILURE;
 49076:     }
 47910: 
 53695: #ifdef DEBUG
101690:     if (gl->DebugMode()) {
 47910:         printf_stderr("--- WebGL context created: %p\n", gl.get());
101690:     }
 53695: #endif
 42402: 
 39587:     mWidth = width;
 39587:     mHeight = height;
 80486:     mResetLayer = true;
 80486:     mOptionsFrozen = true;
 39587: 
 82479:     mHasRobustness = gl->HasRobustness();
 82479: 
 43099:     // increment the generation number
 47204:     ++mGeneration;
 43099: 
 47910: #if 0
 47910:     if (mGeneration > 0) {
 47910:         // XXX dispatch context lost event
 47910:     }
 47910: #endif
 47910: 
 43099:     MakeContextCurrent();
 43099: 
 39587:     // Make sure that we clear this out, otherwise
 39587:     // we'll end up displaying random memory
 47910:     gl->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, gl->GetOffscreenFBO());
 85066: 
 39587:     gl->fViewport(0, 0, mWidth, mHeight);
 47910:     gl->fClearColor(0.0f, 0.0f, 0.0f, 0.0f);
 48029:     gl->fClearDepth(1.0f);
 47910:     gl->fClearStencil(0);
 85066: 
 85066:     gl->ClearSafely();
 32195: 
 63285:     reporter.SetSuccessful();
 32195:     return NS_OK;
 32195: }
 32195: 
 32195: NS_IMETHODIMP
108991: WebGLContext::Render(gfxContext *ctx, gfxPattern::GraphicsFilter f, uint32_t aFlags)
 32195: {
 42402:     if (!gl)
 32195:         return NS_OK;
 32195: 
 42402:     nsRefPtr<gfxImageSurface> surf = new gfxImageSurface(gfxIntSize(mWidth, mHeight),
 42402:                                                          gfxASurface::ImageFormatARGB32);
 42402:     if (surf->CairoStatus() != 0)
 42402:         return NS_ERROR_FAILURE;
 32195: 
108978:     gl->ReadPixelsIntoImageSurface(surf);
 93959: 
 93959:     bool srcPremultAlpha = mOptions.premultipliedAlpha;
 93959:     bool dstPremultAlpha = aFlags & RenderFlagPremultAlpha;
 93959: 
 93959:     if (!srcPremultAlpha && dstPremultAlpha) {
 42402:         gfxUtils::PremultiplyImageSurface(surf);
 93959:     } else if (srcPremultAlpha && !dstPremultAlpha) {
 93959:         gfxUtils::UnpremultiplyImageSurface(surf);
 93959:     }
 32195: 
 42402:     nsRefPtr<gfxPattern> pat = new gfxPattern(surf);
 42402:     pat->SetFilter(f);
 32195: 
 55265:     // Pixels from ReadPixels will be "upside down" compared to
 55265:     // what cairo wants, so draw with a y-flip and a translte to
 55265:     // flip them.
 55265:     gfxMatrix m;
 55265:     m.Translate(gfxPoint(0.0, mHeight));
 55265:     m.Scale(1.0, -1.0);
 55265:     pat->SetMatrix(m);
 55265: 
 32195:     ctx->NewPath();
 32195:     ctx->PixelSnappedRectangleAndSetPattern(gfxRect(0, 0, mWidth, mHeight), pat);
 32195:     ctx->Fill();
 32195: 
 42402:     return NS_OK;
 32195: }
 32195: 
107259: void WebGLContext::LoseOldestWebGLContextIfLimitExceeded()
107259: {
107259: #ifdef MOZ_GFX_OPTIMIZE_MOBILE
107259:     // some mobile devices can't have more than 8 GL contexts overall
107259:     const size_t kMaxWebGLContextsPerPrincipal = 2;
107259:     const size_t kMaxWebGLContexts             = 4;
107259: #else
114600:     const size_t kMaxWebGLContextsPerPrincipal = 16;
114600:     const size_t kMaxWebGLContexts             = 32;
107259: #endif
107259:     MOZ_ASSERT(kMaxWebGLContextsPerPrincipal < kMaxWebGLContexts);
107259: 
107259:     // it's important to update the index on a new context before losing old contexts,
107259:     // otherwise new unused contexts would all have index 0 and we couldn't distinguish older ones
107259:     // when choosing which one to lose first.
107259:     UpdateLastUseIndex();
107259: 
107259:     WebGLMemoryMultiReporterWrapper::ContextsArrayType &contexts
107259:       = WebGLMemoryMultiReporterWrapper::Contexts();
107259: 
107259:     // quick exit path, should cover a majority of cases
107259:     if (contexts.Length() <= kMaxWebGLContextsPerPrincipal) {
107259:         return;
107259:     }
107259: 
107259:     // note that here by "context" we mean "non-lost context". See the check for
107259:     // IsContextLost() below. Indeed, the point of this function is to maybe lose
107259:     // some currently non-lost context.
107259: 
107259:     uint64_t oldestIndex = UINT64_MAX;
107259:     uint64_t oldestIndexThisPrincipal = UINT64_MAX;
108282:     const WebGLContext *oldestContext = nullptr;
108282:     const WebGLContext *oldestContextThisPrincipal = nullptr;
107259:     size_t numContexts = 0;
107259:     size_t numContextsThisPrincipal = 0;
107259: 
107259:     for(size_t i = 0; i < contexts.Length(); ++i) {
107259: 
107259:         // don't want to lose ourselves.
107259:         if (contexts[i] == this)
107259:             continue;
107259: 
107259:         if (contexts[i]->IsContextLost())
107259:             continue;
107259: 
107259:         if (!contexts[i]->GetCanvas()) {
107259:             // Zombie context: the canvas is already destroyed, but something else
107259:             // (typically the compositor) is still holding on to the context.
107259:             // Killing zombies is a no-brainer.
107259:             const_cast<WebGLContext*>(contexts[i])->LoseContext();
107259:             continue;
107259:         }
107259: 
107259:         numContexts++;
107259:         if (contexts[i]->mLastUseIndex < oldestIndex) {
107259:             oldestIndex = contexts[i]->mLastUseIndex;
107259:             oldestContext = contexts[i];
107259:         }
107259: 
107259:         nsIPrincipal *ourPrincipal = GetCanvas()->NodePrincipal();
107259:         nsIPrincipal *theirPrincipal = contexts[i]->GetCanvas()->NodePrincipal();
107259:         bool samePrincipal;
107259:         nsresult rv = ourPrincipal->Equals(theirPrincipal, &samePrincipal);
107259:         if (NS_SUCCEEDED(rv) && samePrincipal) {
107259:             numContextsThisPrincipal++;
107259:             if (contexts[i]->mLastUseIndex < oldestIndexThisPrincipal) {
107259:                 oldestIndexThisPrincipal = contexts[i]->mLastUseIndex;
107259:                 oldestContextThisPrincipal = contexts[i];
107259:             }
107259:         }
107259:     }
107259: 
107259:     if (numContextsThisPrincipal > kMaxWebGLContextsPerPrincipal) {
107259:         GenerateWarning("Exceeded %d live WebGL contexts for this principal, losing the "
107259:                         "least recently used one.", kMaxWebGLContextsPerPrincipal);
107259:         MOZ_ASSERT(oldestContextThisPrincipal); // if we reach this point, this can't be null
107259:         const_cast<WebGLContext*>(oldestContextThisPrincipal)->LoseContext();
107259:     } else if (numContexts > kMaxWebGLContexts) {
107259:         GenerateWarning("Exceeded %d live WebGL contexts, losing the least recently used one.",
107259:                         kMaxWebGLContexts);
107259:         MOZ_ASSERT(oldestContext); // if we reach this point, this can't be null
107259:         const_cast<WebGLContext*>(oldestContext)->LoseContext();
107259:     }
107259: }
107259: 
 32195: NS_IMETHODIMP
 32195: WebGLContext::GetInputStream(const char* aMimeType,
 32195:                              const PRUnichar* aEncoderOptions,
 32195:                              nsIInputStream **aStream)
 32195: {
 57632:     NS_ASSERTION(gl, "GetInputStream on invalid context?");
 57632:     if (!gl)
 32195:         return NS_ERROR_FAILURE;
 32195: 
 57632:     nsRefPtr<gfxImageSurface> surf = new gfxImageSurface(gfxIntSize(mWidth, mHeight),
 57632:                                                          gfxASurface::ImageFormatARGB32);
 57632:     if (surf->CairoStatus() != 0)
 32195:         return NS_ERROR_FAILURE;
 32195: 
 61665:     nsRefPtr<gfxContext> tmpcx = new gfxContext(surf);
 61665:     // Use Render() to make sure that appropriate y-flip gets applied
108991:     uint32_t flags = mOptions.premultipliedAlpha ? RenderFlagPremultAlpha : 0;
 93959:     nsresult rv = Render(tmpcx, gfxPattern::FILTER_NEAREST, flags);
 61665:     if (NS_FAILED(rv))
 61665:         return rv;
 57632: 
 32195:     const char encoderPrefix[] = "@mozilla.org/image/encoder;2?type=";
 57632:     nsAutoArrayPtr<char> conid(new char[strlen(encoderPrefix) + strlen(aMimeType) + 1]);
 32195: 
 32195:     if (!conid)
 32195:         return NS_ERROR_OUT_OF_MEMORY;
 32195: 
 32195:     strcpy(conid, encoderPrefix);
 32195:     strcat(conid, aMimeType);
 32195: 
 32195:     nsCOMPtr<imgIEncoder> encoder = do_CreateInstance(conid);
 32195:     if (!encoder)
 32195:         return NS_ERROR_FAILURE;
 32195: 
 93959:     int format = imgIEncoder::INPUT_FORMAT_HOSTARGB;
 93959:     if (!mOptions.premultipliedAlpha) {
 93959:         // We need to convert to INPUT_FORMAT_RGBA, otherwise
 93959:         // we are automatically considered premult, and unpremult'd.
 93959:         // Yes, it is THAT silly.
 93959:         // Except for different lossy conversions by color,
 93959:         // we could probably just change the label, and not change the data.
 93959:         gfxUtils::ConvertBGRAtoRGBA(surf);
 93959:         format = imgIEncoder::INPUT_FORMAT_RGBA;
 93959:     }
 93959: 
 57632:     rv = encoder->InitFromData(surf->Data(),
 57632:                                mWidth * mHeight * 4,
 57632:                                mWidth, mHeight,
 57632:                                surf->Stride(),
 93959:                                format,
 32195:                                nsDependentString(aEncoderOptions));
 32195:     NS_ENSURE_SUCCESS(rv, rv);
 32195: 
 32195:     return CallQueryInterface(encoder, aStream);
 32195: }
 32195: 
 32195: NS_IMETHODIMP
 32195: WebGLContext::GetThebesSurface(gfxASurface **surface)
 32195: {
 32195:     return NS_ERROR_NOT_AVAILABLE;
 32195: }
 32195: 
107259: void WebGLContext::UpdateLastUseIndex()
107259: {
107259:     static CheckedInt<uint64_t> sIndex = 0;
107259: 
107259:     sIndex++;
107259: 
107259:     // should never happen with 64-bit; trying to handle this would be riskier than
107259:     // not handling it as the handler code would never get exercised.
107259:     if (!sIndex.isValid()) {
107259:         NS_RUNTIMEABORT("Can't believe it's been 2^64 transactions already!");
107259:     }
107259: 
107259:     mLastUseIndex = sIndex.value();
107259: }
107259: 
108991: static uint8_t gWebGLLayerUserData;
 47731: 
 81126: namespace mozilla {
 81126: 
 64542: class WebGLContextUserData : public LayerUserData {
 64542: public:
 64542:     WebGLContextUserData(nsHTMLCanvasElement *aContent)
 64542:     : mContent(aContent) {}
 81126: 
 81126:   /** DidTransactionCallback gets called by the Layers code everytime the WebGL canvas gets composite,
 81126:     * so it really is the right place to put actions that have to be performed upon compositing
 81126:     */
 64542:   static void DidTransactionCallback(void* aData)
 64542:   {
 81126:     WebGLContextUserData *userdata = static_cast<WebGLContextUserData*>(aData);
 81126:     nsHTMLCanvasElement *canvas = userdata->mContent;
 81126:     WebGLContext *context = static_cast<WebGLContext*>(canvas->GetContextAtIndex(0));
 81126: 
 81126:     context->mBackbufferClearingStatus = BackbufferClearingStatus::NotClearedSinceLastPresented;
 81126:     canvas->MarkContextClean();
107259: 
107259:     context->UpdateLastUseIndex();
 64542:   }
 64542: 
 64542: private:
 64542:   nsRefPtr<nsHTMLCanvasElement> mContent;
 64542: };
 64542: 
 81126: } // end namespace mozilla
 81126: 
 42402: already_AddRefed<layers::CanvasLayer>
 64542: WebGLContext::GetCanvasLayer(nsDisplayListBuilder* aBuilder,
 64542:                              CanvasLayer *aOldLayer,
 47731:                              LayerManager *aManager)
 42402: {
 86627:     if (!IsContextStable())
106838:         return nullptr;
 80903: 
 47731:     if (!mResetLayer && aOldLayer &&
 51946:         aOldLayer->HasUserData(&gWebGLLayerUserData)) {
 47731:         NS_ADDREF(aOldLayer);
 47731:         return aOldLayer;
 47731:     }
 47731: 
 47731:     nsRefPtr<CanvasLayer> canvasLayer = aManager->CreateCanvasLayer();
 42402:     if (!canvasLayer) {
 42402:         NS_WARNING("CreateCanvasLayer returned null!");
106838:         return nullptr;
 32195:     }
106838:     WebGLContextUserData *userData = nullptr;
 64542:     if (aBuilder->IsPaintingToWindow()) {
 64542:       // Make the layer tell us whenever a transaction finishes (including
 64542:       // the current transaction), so we can clear our invalidation state and
 64542:       // start invalidating again. We need to do this for the layer that is
 64542:       // being painted to a window (there shouldn't be more than one at a time,
 64542:       // and if there is, flushing the invalidation state more often than
 64542:       // necessary is harmless).
 64542: 
 64542:       // The layer will be destroyed when we tear down the presentation
 64542:       // (at the latest), at which time this userData will be destroyed,
 64542:       // releasing the reference to the element.
 64542:       // The userData will receive DidTransactionCallbacks, which flush the
 64542:       // the invalidation state to indicate that the canvas is up to date.
101146:       userData = new WebGLContextUserData(mCanvasElement);
 64542:       canvasLayer->SetDidTransactionCallback(
 64542:               WebGLContextUserData::DidTransactionCallback, userData);
 64542:     }
 64542:     canvasLayer->SetUserData(&gWebGLLayerUserData, userData);
 32195: 
 42402:     CanvasLayer::Data data;
 42402: 
 42474:     // the gl context may either provide a native PBuffer, in which case we want to initialize
 42474:     // data with the gl context directly, or may provide a surface to which it renders (this is the case
 42474:     // of OSMesa contexts), in which case we want to initialize data with that surface.
 42474: 
 42474:     void* native_surface = gl->GetNativeData(gl::GLContext::NativeImageSurface);
 42474: 
 47910:     if (native_surface) {
 47910:         data.mSurface = static_cast<gfxASurface*>(native_surface);
 47910:     } else {
 42402:         data.mGLContext = gl.get();
 42474:     }
 42474: 
 42402:     data.mSize = nsIntSize(mWidth, mHeight);
 80486:     data.mGLBufferIsPremultiplied = mOptions.premultipliedAlpha ? true : false;
 42402: 
 42402:     canvasLayer->Initialize(data);
108991:     uint32_t flags = gl->CreationFormat().alpha == 0 ? Layer::CONTENT_OPAQUE : 0;
 51950:     canvasLayer->SetContentFlags(flags);
 64540:     canvasLayer->Updated();
 42402: 
 80486:     mResetLayer = false;
 42402: 
 42402:     return canvasLayer.forget().get();
 39587: }
 46955: 
 97698: JSObject*
 97819: WebGLContext::GetContextAttributes(ErrorResult &rv)
 97698: {
 97698:     if (!IsContextStable())
 97698:     {
 97698:         return NULL;
 97698:     }
 97698: 
 57631:     JSContext *cx = nsContentUtils::GetCurrentJSContext();
 97698:     if (!cx) {
 97819:         rv.Throw(NS_ERROR_FAILURE);
 97698:         return NULL;
 97698:     }
 57631: 
 57631:     JSObject *obj = JS_NewObject(cx, NULL, NULL, NULL);
 97698:     if (!obj) {
 97819:         rv.Throw(NS_ERROR_FAILURE);
 97698:         return NULL;
 97698:     }
 57631: 
 57631:     gl::ContextFormat cf = gl->ActualFormat();
 57631: 
 57631:     if (!JS_DefineProperty(cx, obj, "alpha", cf.alpha > 0 ? JSVAL_TRUE : JSVAL_FALSE,
 57631:                            NULL, NULL, JSPROP_ENUMERATE) ||
 57631:         !JS_DefineProperty(cx, obj, "depth", cf.depth > 0 ? JSVAL_TRUE : JSVAL_FALSE,
 57631:                            NULL, NULL, JSPROP_ENUMERATE) ||
 57631:         !JS_DefineProperty(cx, obj, "stencil", cf.stencil > 0 ? JSVAL_TRUE : JSVAL_FALSE,
 57631:                            NULL, NULL, JSPROP_ENUMERATE) ||
 95764:         !JS_DefineProperty(cx, obj, "antialias", cf.samples > 1 ? JSVAL_TRUE : JSVAL_FALSE,
 57631:                            NULL, NULL, JSPROP_ENUMERATE) ||
 57631:         !JS_DefineProperty(cx, obj, "premultipliedAlpha",
 57631:                            mOptions.premultipliedAlpha ? JSVAL_TRUE : JSVAL_FALSE,
 70165:                            NULL, NULL, JSPROP_ENUMERATE) ||
 70165:         !JS_DefineProperty(cx, obj, "preserveDrawingBuffer",
 70165:                            mOptions.preserveDrawingBuffer ? JSVAL_TRUE : JSVAL_FALSE,
 57631:                            NULL, NULL, JSPROP_ENUMERATE))
 57631:     {
 97819:         rv.Throw(NS_ERROR_FAILURE);
 97698:         return NULL;
 57631:     }
 57631: 
 97698:     return obj;
 57631: }
 57631: 
 59414: /* [noscript] DOMString mozGetUnderlyingParamString(in WebGLenum pname); */
 59414: NS_IMETHODIMP
108991: WebGLContext::MozGetUnderlyingParamString(uint32_t pname, nsAString& retval)
 59414: {
 86627:     if (!IsContextStable())
 80903:         return NS_OK;
 80903: 
 80486:     retval.SetIsVoid(true);
 59414: 
 59414:     MakeContextCurrent();
 59414: 
 59414:     switch (pname) {
 59414:     case LOCAL_GL_VENDOR:
 59414:     case LOCAL_GL_RENDERER:
 59414:     case LOCAL_GL_VERSION:
 59414:     case LOCAL_GL_SHADING_LANGUAGE_VERSION:
 59414:     case LOCAL_GL_EXTENSIONS: {
 59414:         const char *s = (const char *) gl->fGetString(pname);
 59414:         retval.Assign(NS_ConvertASCIItoUTF16(nsDependentCString(s)));
 59414:     }
 59414:         break;
 59414: 
 59414:     default:
 59414:         return NS_ERROR_INVALID_ARG;
 59414:     }
 59414: 
 59414:     return NS_OK;
 59414: }
 59414: 
102165: bool WebGLContext::IsExtensionSupported(WebGLExtensionID ext)
 76318: {
102164:     bool isSupported = false;
 79603: 
102165:     switch (ext) {
102165:         case OES_standard_derivatives:
102165:         case WEBGL_lose_context:
102164:             // We always support these extensions.
102164:             isSupported = true;
102164:             break;
102165:         case OES_texture_float:
 79603:             isSupported = gl->IsExtensionSupported(gl->IsGLES2() ? GLContext::OES_texture_float 
 76318:                                                                  : GLContext::ARB_texture_float);
 79603:             break;
102165:         case EXT_texture_filter_anisotropic:
 90800:             isSupported = gl->IsExtensionSupported(GLContext::EXT_texture_filter_anisotropic);
 90800:             break;
102165:         case WEBGL_compressed_texture_s3tc:
102060:             if (gl->IsExtensionSupported(GLContext::EXT_texture_compression_s3tc)) {
102060:                 isSupported = true;
102164:             } else if (gl->IsExtensionSupported(GLContext::EXT_texture_compression_dxt1) &&
102060:                        gl->IsExtensionSupported(GLContext::ANGLE_texture_compression_dxt3) &&
102164:                        gl->IsExtensionSupported(GLContext::ANGLE_texture_compression_dxt5))
102164:             {
102164:                 isSupported = true;
102060:             }
 98021:             break;
114878:         case WEBGL_compressed_texture_atc:
114878:             if (gl->IsExtensionSupported(GLContext::AMD_compressed_ATC_texture)) {
114878:                 isSupported = true;
114878:             }
114878:             break;
114879:         case WEBGL_compressed_texture_pvrtc:
114879:             if (gl->IsExtensionSupported(GLContext::IMG_texture_compression_pvrtc)) {
114879:                 isSupported = true;
114879:             }
114879:             break;
108255:         case WEBGL_depth_texture:
108255:             if (gl->IsGLES2() && 
108255:                 gl->IsExtensionSupported(GLContext::OES_packed_depth_stencil) &&
108255:                 gl->IsExtensionSupported(GLContext::OES_depth_texture)) 
108255:             {
108255:                 isSupported = true;
108255:             } else if (!gl->IsGLES2() &&
108255:                        gl->IsExtensionSupported(GLContext::EXT_packed_depth_stencil)) 
108255:             {
108255:                 isSupported = true;
108255:             }
108255:             break;
 79603:         default:
102164:             MOZ_ASSERT(false, "should not get there.");
 76318:     }
 79603: 
 79603:     return isSupported;
 76318: }
 76318: 
 97698: nsIWebGLExtension*
 97698: WebGLContext::GetExtension(const nsAString& aName)
 97698: {
 86627:     if (!IsContextStable())
106838:         return nullptr;
 70163: 
 80338:     if (mDisableExtensions) {
106838:         return nullptr;
 80338:     }
 80338: 
102165:     WebGLExtensionID ext = WebGLExtensionID_unknown_extension;
102165: 
102163:     if (aName.Equals(NS_LITERAL_STRING("OES_texture_float"),
102163:         nsCaseInsensitiveStringComparator()))
102163:     {
102165:         if (IsExtensionSupported(OES_texture_float))
102165:             ext = OES_texture_float;
 70163:     }
102163:     else if (aName.Equals(NS_LITERAL_STRING("OES_standard_derivatives"),
102163:              nsCaseInsensitiveStringComparator()))
102163:     {
102165:         if (IsExtensionSupported(OES_standard_derivatives))
102165:             ext = OES_standard_derivatives;
 79603:     }
106440:     else if (aName.Equals(NS_LITERAL_STRING("EXT_texture_filter_anisotropic"),
106440:              nsCaseInsensitiveStringComparator()))
106440:     {
106440:         if (IsExtensionSupported(EXT_texture_filter_anisotropic))
106440:             ext = EXT_texture_filter_anisotropic;
106440:     }
102163:     else if (aName.Equals(NS_LITERAL_STRING("MOZ_WEBGL_lose_context"),
102163:              nsCaseInsensitiveStringComparator()))
102163:     {
102165:         if (IsExtensionSupported(WEBGL_lose_context))
102165:             ext = WEBGL_lose_context;
 98021:     }
102163:     else if (aName.Equals(NS_LITERAL_STRING("MOZ_WEBGL_compressed_texture_s3tc"),
102163:              nsCaseInsensitiveStringComparator()))
102163:     {
102165:         if (IsExtensionSupported(WEBGL_compressed_texture_s3tc))
102165:             ext = WEBGL_compressed_texture_s3tc;
 80903:     }
114878:     else if (aName.Equals(NS_LITERAL_STRING("MOZ_WEBGL_compressed_texture_atc"),
114878:              nsCaseInsensitiveStringComparator()))
114878:     {
114878:         if (IsExtensionSupported(WEBGL_compressed_texture_atc))
114878:             ext = WEBGL_compressed_texture_atc;
114878:     }
114879:     else if (aName.Equals(NS_LITERAL_STRING("MOZ_WEBGL_compressed_texture_pvrtc"),
114879:              nsCaseInsensitiveStringComparator()))
114879:     {
114879:         if (IsExtensionSupported(WEBGL_compressed_texture_pvrtc))
114879:             ext = WEBGL_compressed_texture_pvrtc;
114879:     }
108255:     else if (aName.Equals(NS_LITERAL_STRING("MOZ_WEBGL_depth_texture"),
108255:              nsCaseInsensitiveStringComparator()))
108255:     {
108255:         if (IsExtensionSupported(WEBGL_depth_texture))
108255:             ext = WEBGL_depth_texture;
108255:     }
 70163: 
102165:     if (ext == WebGLExtensionID_unknown_extension) {
106838:       return nullptr;
102165:     }
102165: 
102165:     if (!mExtensions[ext]) {
102165:         switch (ext) {
102165:             case OES_standard_derivatives:
102165:                 mExtensions[ext] = new WebGLExtensionStandardDerivatives(this);
 79603:                 break;
102165:             case EXT_texture_filter_anisotropic:
102165:                 mExtensions[ext] = new WebGLExtensionTextureFilterAnisotropic(this);
 90800:                 break;
102165:             case WEBGL_lose_context:
102165:                 mExtensions[ext] = new WebGLExtensionLoseContext(this);
 80903:                 break;
102165:             case WEBGL_compressed_texture_s3tc:
102165:                 mExtensions[ext] = new WebGLExtensionCompressedTextureS3TC(this);
 98021:                 break;
114878:             case WEBGL_compressed_texture_atc:
114878:                 mExtensions[ext] = new WebGLExtensionCompressedTextureATC(this);
114878:                 break;
114879:             case WEBGL_compressed_texture_pvrtc:
114879:                 mExtensions[ext] = new WebGLExtensionCompressedTexturePVRTC(this);
114879:                 break;
108255:             case WEBGL_depth_texture:
108255:                 mExtensions[ext] = new WebGLExtensionDepthTexture(this);
108255:                 break;
 79603:             default:
102165:                 // create a generic WebGLExtension object for any extensions that don't
102165:                 // have any additional tokens or methods. We still need these to be separate
102165:                 // objects in case the user might extend the corresponding JS objects with custom
102165:                 // properties.
102165:                 mExtensions[ext] = new WebGLExtension(this);
 79603:                 break;
 79603:         }
 70163:     }
 70163: 
102165:     return mExtensions[ext];
 70163: }
 59414: 
 70167: void
108991: WebGLContext::ForceClearFramebufferWithDefaultValues(uint32_t mask, const nsIntRect& viewportRect)
 70167: {
 70167:     MakeContextCurrent();
 70167: 
 79445:     bool initializeColorBuffer = 0 != (mask & LOCAL_GL_COLOR_BUFFER_BIT);
 79445:     bool initializeDepthBuffer = 0 != (mask & LOCAL_GL_DEPTH_BUFFER_BIT);
 79445:     bool initializeStencilBuffer = 0 != (mask & LOCAL_GL_STENCIL_BUFFER_BIT);
 70167: 
 87421:     // fun GL fact: no need to worry about the viewport here, glViewport is just setting up a coordinates transformation,
 87421:     // it doesn't affect glClear at all
 87421: 
 70167:     // prepare GL state for clearing
 70167:     gl->fDisable(LOCAL_GL_SCISSOR_TEST);
 70167:     gl->fDisable(LOCAL_GL_DITHER);
 70167: 
 70167:     if (initializeColorBuffer) {
 70167:         gl->fColorMask(1, 1, 1, 1);
 70167:         gl->fClearColor(0.f, 0.f, 0.f, 0.f);
 70167:     }
 70167: 
 70167:     if (initializeDepthBuffer) {
 70167:         gl->fDepthMask(1);
 70167:         gl->fClearDepth(1.0f);
 70167:     }
 70167: 
 70167:     if (initializeStencilBuffer) {
 70167:         gl->fStencilMask(0xffffffff);
 70167:         gl->fClearStencil(0);
 70167:     }
 70167: 
 70167:     // do clear
 70167:     gl->fClear(mask);
 70167: 
 70167:     // restore GL state after clearing
 70167:     if (initializeColorBuffer) {
 70167:         gl->fColorMask(mColorWriteMask[0],
 70167:                        mColorWriteMask[1],
 70167:                        mColorWriteMask[2],
 70167:                        mColorWriteMask[3]);
 70167:         gl->fClearColor(mColorClearValue[0],
 70167:                         mColorClearValue[1],
 70167:                         mColorClearValue[2],
 70167:                         mColorClearValue[3]);
 70167:     }
 70167: 
 70167:     if (initializeDepthBuffer) {
 70167:         gl->fDepthMask(mDepthWriteMask);
 70167:         gl->fClearDepth(mDepthClearValue);
 70167:     }
 70167: 
 70167:     if (initializeStencilBuffer) {
 70170:         gl->fStencilMaskSeparate(LOCAL_GL_FRONT, mStencilWriteMaskFront);
 70170:         gl->fStencilMaskSeparate(LOCAL_GL_BACK, mStencilWriteMaskBack);
 70167:         gl->fClearStencil(mStencilClearValue);
 70167:     }
 70167: 
 70167:     if (mDitherEnabled)
 70167:         gl->fEnable(LOCAL_GL_DITHER);
 70167:     else
 70167:         gl->fDisable(LOCAL_GL_DITHER);
 70167: 
 70167:     if (mScissorTestEnabled)
 70167:         gl->fEnable(LOCAL_GL_SCISSOR_TEST);
 70167:     else
 70167:         gl->fDisable(LOCAL_GL_SCISSOR_TEST);
 70167: }
 70167: 
 70168: void
 70168: WebGLContext::EnsureBackbufferClearedAsNeeded()
 70168: {
 70168:     if (mOptions.preserveDrawingBuffer)
 70168:         return;
 70168: 
 70168:     NS_ABORT_IF_FALSE(!mBoundFramebuffer,
 70168:                       "EnsureBackbufferClearedAsNeeded must not be called when a FBO is bound");
 70168: 
 70168:     if (mBackbufferClearingStatus != BackbufferClearingStatus::NotClearedSinceLastPresented)
 70168:         return;
 70168: 
 70168:     mBackbufferClearingStatus = BackbufferClearingStatus::ClearedToDefaultValues;
 70168: 
 70168:     ForceClearFramebufferWithDefaultValues(LOCAL_GL_COLOR_BUFFER_BIT |
 70168:                                            LOCAL_GL_DEPTH_BUFFER_BIT |
 70168:                                            LOCAL_GL_STENCIL_BUFFER_BIT,
 70168:                                            nsIntRect(0, 0, mWidth, mHeight));
 70168: 
 70168:     Invalidate();
 70168: }
 70168: 
 97698: void
 88091: WebGLContext::DummyFramebufferOperation(const char *info)
 88091: {
114347:     WebGLenum status = CheckFramebufferStatus(LOCAL_GL_FRAMEBUFFER);
 88091:     if (status == LOCAL_GL_FRAMEBUFFER_COMPLETE)
 97698:         return;
 88091:     else
 88091:         return ErrorInvalidFramebufferOperation("%s: incomplete framebuffer", info);
 88091: }
 88091: 
 86626: // We use this timer for many things. Here are the things that it is activated for:
 86626: // 1) If a script is using the MOZ_WEBGL_lose_context extension.
 86626: // 2) If we are using EGL and _NOT ANGLE_, we query periodically to see if the
 86626: //    CONTEXT_LOST_WEBGL error has been triggered.
 86626: // 3) If we are using ANGLE, or anything that supports ARB_robustness, query the
 86626: //    GPU periodically to see if the reset status bit has been set.
 86626: // In all of these situations, we use this timer to send the script context lost
 86626: // and restored events asynchronously. For example, if it triggers a context loss,
 86626: // the webglcontextlost event will be sent to it the next time the robustness timer
 86626: // fires.
 86626: // Note that this timer mechanism is not used unless one of these 3 criteria
 86626: // are met.
 86626: // At a bare minimum, from context lost to context restores, it would take 3
 86626: // full timer iterations: detection, webglcontextlost, webglcontextrestored.
 80903: NS_IMETHODIMP
 80903: WebGLContext::Notify(nsITimer* timer)
 80903: {
 95823:     TerminateContextLossTimer();
 95825: 
101146:     if (!mCanvasElement) {
 95825:         // the canvas is gone. That happens when the page was closed before we got
 95825:         // this timer event. In this case, there's nothing to do here, just don't crash.
 95825:         return NS_OK;
 95825:     }
 95825: 
 86626:     // If the context has been lost and we're waiting for it to be restored, do
 86626:     // that now.
 86626:     if (mContextStatus == ContextLostAwaitingEvent) {
 86626:         bool defaultAction;
101146:         nsContentUtils::DispatchTrustedEvent(mCanvasElement->OwnerDoc(),
101146:                                              static_cast<nsIDOMHTMLCanvasElement*>(mCanvasElement),
 86626:                                              NS_LITERAL_STRING("webglcontextlost"),
 90093:                                              true,
 90093:                                              true,
 86626:                                              &defaultAction);
 86626: 
 86626:         // If the script didn't handle the event, we don't allow restores.
 86626:         if (defaultAction)
 86626:             mAllowRestore = false;
 86626: 
 86626:         // If the script handled the event and we are allowing restores, then
 86626:         // mark it to be restored. Otherwise, leave it as context lost
 86626:         // (unusable).
 86626:         if (!defaultAction && mAllowRestore) {
 86626:             ForceRestoreContext();
 86626:             // Restart the timer so that it will be restored on the next
 86626:             // callback.
 95823:             SetupContextLossTimer();
 86626:         } else {
 86626:             mContextStatus = ContextLost;
 86626:         }
 86626:     } else if (mContextStatus == ContextLostAwaitingRestore) {
 86626:         // Try to restore the context. If it fails, try again later.
 86626:         if (NS_FAILED(SetDimensions(mWidth, mHeight))) {
 95823:             SetupContextLossTimer();
 86626:             return NS_OK;
 86626:         }
 86626:         mContextStatus = ContextStable;
101146:         nsContentUtils::DispatchTrustedEvent(mCanvasElement->OwnerDoc(),
101146:                                              static_cast<nsIDOMHTMLCanvasElement*>(mCanvasElement),
 86626:                                              NS_LITERAL_STRING("webglcontextrestored"),
 90093:                                              true,
 90093:                                              true);
 86626:         // Set all flags back to the state they were in before the context was
 86626:         // lost.
 86626:         mContextLostErrorSet = false;
 86626:         mAllowRestore = true;
 86626:     }
 86626: 
 80903:     MaybeRestoreContext();
 80903:     return NS_OK;
 80903: }
 80903: 
 80903: void
 80903: WebGLContext::MaybeRestoreContext()
 80903: {
 86626:     // Don't try to handle it if we already know it's busted.
106838:     if (mContextStatus != ContextStable || gl == nullptr)
 80903:         return;
 80903: 
 84592:     bool isEGL = gl->GetContextType() == GLContext::ContextTypeEGL,
 84592:          isANGLE = gl->IsANGLE();
 84592: 
 83211:     GLContext::ContextResetARB resetStatus = GLContext::CONTEXT_NO_ERROR;
 83211:     if (mHasRobustness) {
 82479:         gl->MakeCurrent();
 83211:         resetStatus = (GLContext::ContextResetARB) gl->fGetGraphicsResetStatus();
 84592:     } else if (isEGL) {
 83211:         // Simulate a ARB_robustness guilty context loss for when we
 83211:         // get an EGL_CONTEXT_LOST error. It may not actually be guilty,
 83211:         // but we can't make any distinction, so we must assume the worst
 83211:         // case.
 83211:         if (!gl->MakeCurrent(true) && gl->IsContextLost()) {
 83211:             resetStatus = GLContext::CONTEXT_GUILTY_CONTEXT_RESET_ARB;
 83211:         }
 83211:     }
 80903:     
 80903:     if (resetStatus != GLContext::CONTEXT_NO_ERROR) {
 80903:         // It's already lost, but clean up after it and signal to JS that it is
 80903:         // lost.
 80903:         ForceLoseContext();
 80903:     }
 80903: 
 80903:     switch (resetStatus) {
 80903:         case GLContext::CONTEXT_NO_ERROR:
 82479:             // If there has been activity since the timer was set, it's possible
 82479:             // that we did or are going to miss something, so clear this flag and
 82479:             // run it again some time later.
 95823:             if (mDrawSinceContextLossTimerSet)
 95823:                 SetupContextLossTimer();
 86626:             break;
 80903:         case GLContext::CONTEXT_GUILTY_CONTEXT_RESET_ARB:
 80903:             NS_WARNING("WebGL content on the page caused the graphics card to reset; not restoring the context");
 86626:             mAllowRestore = false;
 86626:             break;
 80903:         case GLContext::CONTEXT_INNOCENT_CONTEXT_RESET_ARB:
 80903:             break;
 80903:         case GLContext::CONTEXT_UNKNOWN_CONTEXT_RESET_ARB:
 80903:             NS_WARNING("WebGL content on the page might have caused the graphics card to reset");
 84592:             if (isEGL && isANGLE) {
 84592:                 // If we're using ANGLE, we ONLY get back UNKNOWN context resets, including for guilty contexts.
 84592:                 // This means that we can't restore it or risk restoring a guilty context. Should this ever change,
 84592:                 // we can get rid of the whole IsANGLE() junk from GLContext.h since, as of writing, this is the
 84592:                 // only use for it. See ANGLE issue 261.
 86626:                 mAllowRestore = false;
 84592:             }
 80903:             break;
 80903:     }
 80903: }
 80903: 
 80903: void
 80903: WebGLContext::ForceLoseContext()
 80903: {
 95826:     if (mContextStatus == ContextLostAwaitingEvent)
 95826:         return;
 95826: 
 86626:     mContextStatus = ContextLostAwaitingEvent;
 86626:     // Queue up a task to restore the event.
 95823:     SetupContextLossTimer();
 80903:     DestroyResourcesAndContext();
 80903: }
 80903: 
 80903: void
 80903: WebGLContext::ForceRestoreContext()
 80903: {
 86626:     mContextStatus = ContextLostAwaitingRestore;
 80903: }
 80903: 
 32195: //
 32195: // XPCOM goop
 32195: //
 32195: 
 67682: NS_IMPL_CYCLE_COLLECTING_ADDREF(WebGLContext)
 67682: NS_IMPL_CYCLE_COLLECTING_RELEASE(WebGLContext)
 32195: 
 43655: NS_IMPL_CYCLE_COLLECTION_CLASS(WebGLContext)
 97696: 
 97696: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(WebGLContext)
 97696:   NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
 97696: NS_IMPL_CYCLE_COLLECTION_TRACE_END
 97696: 
 43655: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(WebGLContext)
 43655:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mCanvasElement)
102165:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSTARRAY(mExtensions)
 97696:   NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
 43655: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 97696: 
 43655: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(WebGLContext)
101146:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mCanvasElement, nsINode)
102165:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSTARRAY_OF_NSCOMPTR(mExtensions)
 97696:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
 43655: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 39587: 
 43655: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(WebGLContext)
 97696:   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
 57635:   NS_INTERFACE_MAP_ENTRY(nsIDOMWebGLRenderingContext)
 32195:   NS_INTERFACE_MAP_ENTRY(nsICanvasRenderingContextInternal)
 32195:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
 80903:   NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
 97696:   // If the exact way we cast to nsISupports here ever changes, fix our
 97696:   // PreCreate hook!
102303:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports,
102303:                                    nsICanvasRenderingContextInternal)
 32195: NS_INTERFACE_MAP_END
 32195: 
 32195: NS_IMPL_ADDREF(WebGLBuffer)
 32195: NS_IMPL_RELEASE(WebGLBuffer)
 32195: 
 40490: DOMCI_DATA(WebGLBuffer, WebGLBuffer)
 40490: 
 32195: NS_INTERFACE_MAP_BEGIN(WebGLBuffer)
 32195:   NS_INTERFACE_MAP_ENTRY(nsIWebGLBuffer)
 32195:   NS_INTERFACE_MAP_ENTRY(nsISupports)
 39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLBuffer)
 32195: NS_INTERFACE_MAP_END
 32195: 
 32195: NS_IMPL_ADDREF(WebGLTexture)
 32195: NS_IMPL_RELEASE(WebGLTexture)
 32195: 
 40490: DOMCI_DATA(WebGLTexture, WebGLTexture)
 40490: 
 32195: NS_INTERFACE_MAP_BEGIN(WebGLTexture)
 32195:   NS_INTERFACE_MAP_ENTRY(nsIWebGLTexture)
 32195:   NS_INTERFACE_MAP_ENTRY(nsISupports)
 39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLTexture)
 32195: NS_INTERFACE_MAP_END
 32195: 
 32195: NS_IMPL_ADDREF(WebGLProgram)
 32195: NS_IMPL_RELEASE(WebGLProgram)
 32195: 
 40490: DOMCI_DATA(WebGLProgram, WebGLProgram)
 40490: 
 32195: NS_INTERFACE_MAP_BEGIN(WebGLProgram)
 32195:   NS_INTERFACE_MAP_ENTRY(nsIWebGLProgram)
 32195:   NS_INTERFACE_MAP_ENTRY(nsISupports)
 39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLProgram)
 32195: NS_INTERFACE_MAP_END
 32195: 
 32195: NS_IMPL_ADDREF(WebGLShader)
 32195: NS_IMPL_RELEASE(WebGLShader)
 32195: 
 40490: DOMCI_DATA(WebGLShader, WebGLShader)
 40490: 
 32195: NS_INTERFACE_MAP_BEGIN(WebGLShader)
 32195:   NS_INTERFACE_MAP_ENTRY(nsIWebGLShader)
 32195:   NS_INTERFACE_MAP_ENTRY(nsISupports)
 39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLShader)
 32195: NS_INTERFACE_MAP_END
 32195: 
 32195: NS_IMPL_ADDREF(WebGLFramebuffer)
 32195: NS_IMPL_RELEASE(WebGLFramebuffer)
 32195: 
 40490: DOMCI_DATA(WebGLFramebuffer, WebGLFramebuffer)
 40490: 
 32195: NS_INTERFACE_MAP_BEGIN(WebGLFramebuffer)
 32195:   NS_INTERFACE_MAP_ENTRY(nsIWebGLFramebuffer)
 32195:   NS_INTERFACE_MAP_ENTRY(nsISupports)
 39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLFramebuffer)
 32195: NS_INTERFACE_MAP_END
 32195: 
 32195: NS_IMPL_ADDREF(WebGLRenderbuffer)
 32195: NS_IMPL_RELEASE(WebGLRenderbuffer)
 32195: 
 40490: DOMCI_DATA(WebGLRenderbuffer, WebGLRenderbuffer)
 40490: 
 32195: NS_INTERFACE_MAP_BEGIN(WebGLRenderbuffer)
 32195:   NS_INTERFACE_MAP_ENTRY(nsIWebGLRenderbuffer)
 32195:   NS_INTERFACE_MAP_ENTRY(nsISupports)
 39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLRenderbuffer)
 32195: NS_INTERFACE_MAP_END
 32195: 
 43010: NS_IMPL_ADDREF(WebGLUniformLocation)
 43010: NS_IMPL_RELEASE(WebGLUniformLocation)
 43010: 
 43010: DOMCI_DATA(WebGLUniformLocation, WebGLUniformLocation)
 43010: 
 43010: NS_INTERFACE_MAP_BEGIN(WebGLUniformLocation)
 43010:   NS_INTERFACE_MAP_ENTRY(nsIWebGLUniformLocation)
 43010:   NS_INTERFACE_MAP_ENTRY(nsISupports)
 43010:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLUniformLocation)
 43010: NS_INTERFACE_MAP_END
 43010: 
102143: JSObject*
102143: WebGLUniformLocation::WrapObject(JSContext *cx, JSObject *scope)
102143: {
102143:     return dom::WebGLUniformLocationBinding::Wrap(cx, scope, this);
102143: }
102143: 
 84804: NS_IMPL_ADDREF(WebGLShaderPrecisionFormat)
 84804: NS_IMPL_RELEASE(WebGLShaderPrecisionFormat)
 84804: 
 84804: DOMCI_DATA(WebGLShaderPrecisionFormat, WebGLShaderPrecisionFormat)
 84804: 
 84804: NS_INTERFACE_MAP_BEGIN(WebGLShaderPrecisionFormat)
 84804:   NS_INTERFACE_MAP_ENTRY(nsIWebGLShaderPrecisionFormat)
 84804:   NS_INTERFACE_MAP_ENTRY(nsISupports)
 84804:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLShaderPrecisionFormat)
 84804: NS_INTERFACE_MAP_END
 84804: 
 51421: NS_IMPL_ADDREF(WebGLActiveInfo)
 51421: NS_IMPL_RELEASE(WebGLActiveInfo)
 51421: 
 51421: DOMCI_DATA(WebGLActiveInfo, WebGLActiveInfo)
 51421: 
 51421: NS_INTERFACE_MAP_BEGIN(WebGLActiveInfo)
 51421:   NS_INTERFACE_MAP_ENTRY(nsIWebGLActiveInfo)
 51421:   NS_INTERFACE_MAP_ENTRY(nsISupports)
 51421:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLActiveInfo)
 51421: NS_INTERFACE_MAP_END
 51421: 
 42916: #define NAME_NOT_SUPPORTED(base) \
 42916: NS_IMETHODIMP base::GetName(WebGLuint *aName) \
 42916: { return NS_ERROR_NOT_IMPLEMENTED; } \
 42916: NS_IMETHODIMP base::SetName(WebGLuint aName) \
 42916: { return NS_ERROR_NOT_IMPLEMENTED; }
 39587: 
 42916: NAME_NOT_SUPPORTED(WebGLTexture)
 42916: NAME_NOT_SUPPORTED(WebGLBuffer)
 42916: NAME_NOT_SUPPORTED(WebGLProgram)
 42916: NAME_NOT_SUPPORTED(WebGLShader)
 42916: NAME_NOT_SUPPORTED(WebGLFramebuffer)
 42916: NAME_NOT_SUPPORTED(WebGLRenderbuffer)
 43010: 
 94084: // WebGLExtension
 70163: 
 98387: NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_0(WebGLExtension)
 94084:   
 94084: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(WebGLExtension)
 94084:   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
 94084:   NS_INTERFACE_MAP_ENTRY(nsISupports)
 70163:   NS_INTERFACE_MAP_ENTRY(nsIWebGLExtension)
 70163:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLExtension)
 70163: NS_INTERFACE_MAP_END 
 70163: 
 94084: NS_IMPL_CYCLE_COLLECTING_ADDREF(WebGLExtension)
 94084: NS_IMPL_CYCLE_COLLECTING_RELEASE(WebGLExtension)
 79603: 
 94084: DOMCI_DATA(WebGLExtension, WebGLExtension)
 80903: 
 43010: /* [noscript] attribute WebGLint location; */
 59414: NS_IMETHODIMP
 59414: WebGLUniformLocation::GetLocation(WebGLint *aLocation)
 32195: {
 32195:     return NS_ERROR_NOT_IMPLEMENTED;
 32195: }
 59414: 
 59414: NS_IMETHODIMP
 59414: WebGLUniformLocation::SetLocation(WebGLint aLocation)
 32195: {
 32195:     return NS_ERROR_NOT_IMPLEMENTED;
 32195: }
 51421: 
 51421: /* readonly attribute WebGLint size; */
 59414: NS_IMETHODIMP
 59414: WebGLActiveInfo::GetSize(WebGLint *aSize)
 51421: {
 51421:     *aSize = mSize;
 51421:     return NS_OK;
 51421: }
 51421: 
 51421: /* readonly attribute WebGLenum type; */
 59414: NS_IMETHODIMP
 59414: WebGLActiveInfo::GetType(WebGLenum *aType)
 51421: {
 51421:     *aType = mType;
 51421:     return NS_OK;
 51421: }
 51421: 
 51421: /* readonly attribute DOMString name; */
 59414: NS_IMETHODIMP
 59414: WebGLActiveInfo::GetName(nsAString & aName)
 51421: {
 51421:     aName = mName;
 51421:     return NS_OK;
 51421: }
 63219: 
 84804: /* readonly attribute WebGLint rangeMin */
 84804: NS_IMETHODIMP
 84804: WebGLShaderPrecisionFormat::GetRangeMin(WebGLint *aRangeMin)
 84804: {
 84804:     *aRangeMin = mRangeMin;
 84804:     return NS_OK;
 84804: }
 84804: 
 84804: /* readonly attribute WebGLint rangeMax */
 84804: NS_IMETHODIMP
 84804: WebGLShaderPrecisionFormat::GetRangeMax(WebGLint *aRangeMax)
 84804: {
 84804:     *aRangeMax = mRangeMax;
 84804:     return NS_OK;
 84804: }
 84804: 
 84804: /* readonly attribute WebGLint precision */
 84804: NS_IMETHODIMP
 84804: WebGLShaderPrecisionFormat::GetPrecision(WebGLint *aPrecision)
 84804: {
 84804:     *aPrecision = mPrecision;
 84804:     return NS_OK;
 84804: }
 84804: 
 97698: void
 97698: WebGLContext::GetSupportedExtensions(Nullable< nsTArray<nsString> > &retval)
 97698: {
 97698:     retval.SetNull();
 97698:     if (!IsContextStable())
 97698:         return;
 97698:     
 97698:     if (mDisableExtensions) {
 97698:         return;
 97698:     }
 97698: 
 97698:     nsTArray<nsString>& arr = retval.SetValue();
 97698:     
102165:     if (IsExtensionSupported(OES_texture_float))
 97698:         arr.AppendElement(NS_LITERAL_STRING("OES_texture_float"));
102165:     if (IsExtensionSupported(OES_standard_derivatives))
 97698:         arr.AppendElement(NS_LITERAL_STRING("OES_standard_derivatives"));
106440:     if (IsExtensionSupported(EXT_texture_filter_anisotropic)) {
106440:         arr.AppendElement(NS_LITERAL_STRING("EXT_texture_filter_anisotropic"));
106440:     }
102165:     if (IsExtensionSupported(WEBGL_lose_context))
 97698:         arr.AppendElement(NS_LITERAL_STRING("MOZ_WEBGL_lose_context"));
102165:     if (IsExtensionSupported(WEBGL_compressed_texture_s3tc))
 98021:         arr.AppendElement(NS_LITERAL_STRING("MOZ_WEBGL_compressed_texture_s3tc"));
114878:     if (IsExtensionSupported(WEBGL_compressed_texture_atc))
114878:         arr.AppendElement(NS_LITERAL_STRING("MOZ_WEBGL_compressed_texture_atc"));
114879:     if (IsExtensionSupported(WEBGL_compressed_texture_pvrtc))
114879:         arr.AppendElement(NS_LITERAL_STRING("MOZ_WEBGL_compressed_texture_pvrtc"));
108255:     if (IsExtensionSupported(WEBGL_depth_texture))
108255:         arr.AppendElement(NS_LITERAL_STRING("MOZ_WEBGL_depth_texture"));
 63219: }
