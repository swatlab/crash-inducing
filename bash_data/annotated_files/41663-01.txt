    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is nsCacheService.cpp, released
    1:  * February 10, 2001.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Gordon Sheridan, 10-February-2001
20824:  *   Michael Ventnor <m.ventnor@gmail.com>
20824:  *   Ehsan Akhgari <ehsan.akhgari@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "necko-config.h"
    1: 
    1: #include "nsCache.h"
    1: #include "nsCacheService.h"
    1: #include "nsCacheRequest.h"
    1: #include "nsCacheEntry.h"
    1: #include "nsCacheEntryDescriptor.h"
    1: #include "nsCacheDevice.h"
    1: #include "nsMemoryCacheDevice.h"
    1: #include "nsICacheVisitor.h"
 1426: #include "nsDiskCacheDevice.h"
    1: 
 1426: #ifdef NECKO_OFFLINE_CACHE
    1: #include "nsDiskCacheDeviceSQL.h"
    1: #endif
    1: 
    1: #include "nsIObserverService.h"
    1: #include "nsIPrefService.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPrefBranch2.h"
    1: #include "nsILocalFile.h"
    1: #include "nsIOService.h"
    1: #include "nsDirectoryServiceDefs.h"
    1: #include "nsAppDirectoryServiceDefs.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsProxyRelease.h"
29263: #include "nsVoidArray.h"
    1: #include "nsDeleteDir.h"
20824: #include "nsIPrivateBrowsingService.h"
20824: #include "nsNetCID.h"
    1: #include <math.h>  // for log()
41540: #include "mozilla/Services.h"
    1: 
    1: 
    1: /******************************************************************************
    1:  * nsCacheProfilePrefObserver
    1:  *****************************************************************************/
    1: #ifdef XP_MAC
    1: #pragma mark nsCacheProfilePrefObserver
    1: #endif
    1: 
    1: #define DISK_CACHE_ENABLE_PREF      "browser.cache.disk.enable"
    1: #define DISK_CACHE_DIR_PREF         "browser.cache.disk.parent_directory"
    1: #define DISK_CACHE_CAPACITY_PREF    "browser.cache.disk.capacity"
    1: #define DISK_CACHE_MAX_ENTRY_SIZE_PREF "browser.cache.disk.max_entry_size"
38444: #define DISK_CACHE_CAPACITY         51200
    1: 
    1: #define OFFLINE_CACHE_ENABLE_PREF   "browser.cache.offline.enable"
    1: #define OFFLINE_CACHE_DIR_PREF      "browser.cache.offline.parent_directory"
    1: #define OFFLINE_CACHE_CAPACITY_PREF "browser.cache.offline.capacity"
 1426: #define OFFLINE_CACHE_CAPACITY      512000
    1: 
    1: #define MEMORY_CACHE_ENABLE_PREF    "browser.cache.memory.enable"
    1: #define MEMORY_CACHE_CAPACITY_PREF  "browser.cache.memory.capacity"
    1: #define MEMORY_CACHE_MAX_ENTRY_SIZE_PREF "browser.cache.memory.max_entry_size"
    1: 
11477: static const char * observerList[] = { 
11477:     "profile-before-change",
11477:     "profile-after-change",
20824:     NS_XPCOM_SHUTDOWN_OBSERVER_ID,
20824:     NS_PRIVATE_BROWSING_SWITCH_TOPIC
11477: };
11477: static const char * prefList[] = { 
11477: #ifdef NECKO_DISK_CACHE
11477:     DISK_CACHE_ENABLE_PREF,
11477:     DISK_CACHE_CAPACITY_PREF,
11477:     DISK_CACHE_DIR_PREF,
11477: #endif
11477: #ifdef NECKO_OFFLINE_CACHE
11477:     OFFLINE_CACHE_ENABLE_PREF,
11477:     OFFLINE_CACHE_CAPACITY_PREF,
11477:     OFFLINE_CACHE_DIR_PREF,
11477: #endif
11477:     MEMORY_CACHE_ENABLE_PREF,
11477:     MEMORY_CACHE_CAPACITY_PREF
11477: };
    1: 
    1: class nsCacheProfilePrefObserver : public nsIObserver
    1: {
    1: public:
    1:     NS_DECL_ISUPPORTS
    1:     NS_DECL_NSIOBSERVER
    1: 
    1:     nsCacheProfilePrefObserver()
    1:         : mHaveProfile(PR_FALSE)
    1:         , mDiskCacheEnabled(PR_FALSE)
    1:         , mDiskCacheCapacity(0)
    1:         , mOfflineCacheEnabled(PR_FALSE)
    1:         , mOfflineCacheCapacity(0)
    1:         , mMemoryCacheEnabled(PR_TRUE)
    1:         , mMemoryCacheCapacity(-1)
20824:         , mInPrivateBrowsing(PR_FALSE)
    1:     {
    1:     }
    1: 
    1:     virtual ~nsCacheProfilePrefObserver() {}
    1:     
    1:     nsresult        Install();
    1:     void            Remove();
    1:     nsresult        ReadPrefs(nsIPrefBranch* branch);
    1:     
    1:     PRBool          DiskCacheEnabled();
    1:     PRInt32         DiskCacheCapacity()         { return mDiskCacheCapacity; }
    1:     nsILocalFile *  DiskCacheParentDirectory()  { return mDiskCacheParentDirectory; }
    1: 
    1:     PRBool          OfflineCacheEnabled();
    1:     PRInt32         OfflineCacheCapacity()         { return mOfflineCacheCapacity; }
    1:     nsILocalFile *  OfflineCacheParentDirectory()  { return mOfflineCacheParentDirectory; }
    1:     
    1:     PRBool          MemoryCacheEnabled();
    1:     PRInt32         MemoryCacheCapacity();
    1: 
    1: private:
    1:     PRBool                  mHaveProfile;
    1:     
    1:     PRBool                  mDiskCacheEnabled;
22790:     PRInt32                 mDiskCacheCapacity; // in kilobytes
    1:     nsCOMPtr<nsILocalFile>  mDiskCacheParentDirectory;
    1: 
    1:     PRBool                  mOfflineCacheEnabled;
22790:     PRInt32                 mOfflineCacheCapacity; // in kilobytes
    1:     nsCOMPtr<nsILocalFile>  mOfflineCacheParentDirectory;
    1:     
    1:     PRBool                  mMemoryCacheEnabled;
22790:     PRInt32                 mMemoryCacheCapacity; // in kilobytes
20824: 
20824:     PRBool                  mInPrivateBrowsing;
    1: };
    1: 
    1: NS_IMPL_ISUPPORTS1(nsCacheProfilePrefObserver, nsIObserver)
    1: 
    1: 
    1: nsresult
    1: nsCacheProfilePrefObserver::Install()
    1: {
41540:     // install profile-change observer
41540:     nsCOMPtr<nsIObserverService> observerService =
41540:         mozilla::services::GetObserverService();
41540:     if (!observerService)
41540:         return NS_ERROR_FAILURE;
41540:     
    1:     nsresult rv, rv2 = NS_OK;
31140:     for (unsigned int i=0; i<NS_ARRAY_LENGTH(observerList); i++) {
11477:         rv = observerService->AddObserver(this, observerList[i], PR_FALSE);
11477:         if (NS_FAILED(rv)) 
11477:             rv2 = rv;
11477:     }
    1:     
    1:     // install preferences observer
    1:     nsCOMPtr<nsIPrefBranch2> branch = do_GetService(NS_PREFSERVICE_CONTRACTID);
    1:     if (!branch) return NS_ERROR_FAILURE;
    1: 
31140:     for (unsigned int i=0; i<NS_ARRAY_LENGTH(prefList); i++) {
    1:         rv = branch->AddObserver(prefList[i], this, PR_FALSE);
11477:         if (NS_FAILED(rv))
11477:             rv2 = rv;
    1:     }
    1: 
20824:     // determine the initial status of the private browsing mode
20824:     nsCOMPtr<nsIPrivateBrowsingService> pbs =
20824:       do_GetService(NS_PRIVATE_BROWSING_SERVICE_CONTRACTID);
20824:     if (pbs)
20824:       pbs->GetPrivateBrowsingEnabled(&mInPrivateBrowsing);
20824: 
    1:     // Determine if we have a profile already
    1:     //     Install() is called *after* the profile-after-change notification
    1:     //     when there is only a single profile, or it is specified on the
    1:     //     commandline at startup.
    1:     //     In that case, we detect the presence of a profile by the existence
    1:     //     of the NS_APP_USER_PROFILE_50_DIR directory.
    1: 
    1:     nsCOMPtr<nsIFile> directory;
    1:     rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
    1:                                 getter_AddRefs(directory));
41540:     if (NS_SUCCEEDED(rv))
    1:         mHaveProfile = PR_TRUE;
    1: 
    1:     rv = ReadPrefs(branch);
11477:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
11477:     return rv2;
    1: }
    1: 
    1: 
    1: void
    1: nsCacheProfilePrefObserver::Remove()
    1: {
    1:     // remove Observer Service observers
    1:     nsCOMPtr<nsIObserverService> obs =
41540:         mozilla::services::GetObserverService();
    1:     if (obs) {
31140:         for (unsigned int i=0; i<NS_ARRAY_LENGTH(observerList); i++) {
11477:             obs->RemoveObserver(this, observerList[i]);
11477:         }
    1:     }
    1: 
    1:     // remove Pref Service observers
    1:     nsCOMPtr<nsIPrefBranch2> prefs =
    1:         do_GetService(NS_PREFSERVICE_CONTRACTID);
41540:     if (!prefs)
41540:         return;
41540:     for (unsigned int i=0; i<NS_ARRAY_LENGTH(prefList); i++)
41540:         prefs->RemoveObserver(prefList[i], this); // remove cache pref observers
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsCacheProfilePrefObserver::Observe(nsISupports *     subject,
    1:                                     const char *      topic,
    1:                                     const PRUnichar * data_unicode)
    1: {
    1:     nsresult rv;
    1:     NS_ConvertUTF16toUTF8 data(data_unicode);
    1:     CACHE_LOG_ALWAYS(("Observe [topic=%s data=%s]\n", topic, data.get()));
    1: 
    1:     if (!strcmp(NS_XPCOM_SHUTDOWN_OBSERVER_ID, topic)) {
    1:         // xpcom going away, shutdown cache service
    1:         if (nsCacheService::GlobalInstance())
    1:             nsCacheService::GlobalInstance()->Shutdown();
    1:     
    1:     } else if (!strcmp("profile-before-change", topic)) {
    1:         // profile before change
    1:         mHaveProfile = PR_FALSE;
    1: 
    1:         // XXX shutdown devices
    1:         nsCacheService::OnProfileShutdown(!strcmp("shutdown-cleanse",
    1:                                                   data.get()));
    1:         
    1:     } else if (!strcmp("profile-after-change", topic)) {
    1:         // profile after change
    1:         mHaveProfile = PR_TRUE;
    1:         nsCOMPtr<nsIPrefBranch> branch = do_GetService(NS_PREFSERVICE_CONTRACTID);
    1:         ReadPrefs(branch);
    1:         nsCacheService::OnProfileChanged();
    1:     
    1:     } else if (!strcmp(NS_PREFBRANCH_PREFCHANGE_TOPIC_ID, topic)) {
    1: 
    1:         // ignore pref changes until we're done switch profiles
    1:         if (!mHaveProfile)  return NS_OK;
    1: 
    1:         nsCOMPtr<nsIPrefBranch> branch = do_QueryInterface(subject, &rv);
    1:         if (NS_FAILED(rv))  return rv;
    1: 
    1: #ifdef NECKO_DISK_CACHE
    1:         // which preference changed?
    1:         if (!strcmp(DISK_CACHE_ENABLE_PREF, data.get())) {
    1: 
20824:             if (!mInPrivateBrowsing) {
    1:                 rv = branch->GetBoolPref(DISK_CACHE_ENABLE_PREF,
    1:                                          &mDiskCacheEnabled);
    1:                 if (NS_FAILED(rv))  return rv;
    1:                 nsCacheService::SetDiskCacheEnabled(DiskCacheEnabled());
20824:             }
    1: 
    1:         } else if (!strcmp(DISK_CACHE_CAPACITY_PREF, data.get())) {
    1: 
    1:             PRInt32 capacity = 0;
    1:             rv = branch->GetIntPref(DISK_CACHE_CAPACITY_PREF, &capacity);
    1:             if (NS_FAILED(rv))  return rv;
    1:             mDiskCacheCapacity = PR_MAX(0, capacity);
    1:             nsCacheService::SetDiskCacheCapacity(mDiskCacheCapacity);
    1: #if 0            
    1:         } else if (!strcmp(DISK_CACHE_DIR_PREF, data.get())) {
    1:             // XXX We probaby don't want to respond to this pref except after
    1:             // XXX profile changes.  Ideally, there should be somekind of user
    1:             // XXX notification that the pref change won't take effect until
    1:             // XXX the next time the profile changes (browser launch)
    1: #endif            
    1:         } else 
11477: #endif // !NECKO_DISK_CACHE
    1: 
11477: #ifdef NECKO_OFFLINE_CACHE
    1:         // which preference changed?
    1:         if (!strcmp(OFFLINE_CACHE_ENABLE_PREF, data.get())) {
    1: 
20824:             if (!mInPrivateBrowsing) {
    1:                 rv = branch->GetBoolPref(OFFLINE_CACHE_ENABLE_PREF,
    1:                                          &mOfflineCacheEnabled);
    1:                 if (NS_FAILED(rv))  return rv;
    1:                 nsCacheService::SetOfflineCacheEnabled(OfflineCacheEnabled());
20824:             }
    1: 
    1:         } else if (!strcmp(OFFLINE_CACHE_CAPACITY_PREF, data.get())) {
    1: 
    1:             PRInt32 capacity = 0;
    1:             rv = branch->GetIntPref(OFFLINE_CACHE_CAPACITY_PREF, &capacity);
    1:             if (NS_FAILED(rv))  return rv;
    1:             mOfflineCacheCapacity = PR_MAX(0, capacity);
    1:             nsCacheService::SetOfflineCacheCapacity(mOfflineCacheCapacity);
    1: #if 0
11477:         } else if (!strcmp(OFFLINE_CACHE_DIR_PREF, data.get())) {
    1:             // XXX We probaby don't want to respond to this pref except after
    1:             // XXX profile changes.  Ideally, there should be some kind of user
    1:             // XXX notification that the pref change won't take effect until
    1:             // XXX the next time the profile changes (browser launch)
    1: #endif
    1:         } else
11477: #endif // !NECKO_OFFLINE_CACHE
    1: 
    1:         if (!strcmp(MEMORY_CACHE_ENABLE_PREF, data.get())) {
    1: 
    1:             rv = branch->GetBoolPref(MEMORY_CACHE_ENABLE_PREF,
    1:                                      &mMemoryCacheEnabled);
    1:             if (NS_FAILED(rv))  return rv;
    1:             nsCacheService::SetMemoryCache();
    1:             
    1:         } else if (!strcmp(MEMORY_CACHE_CAPACITY_PREF, data.get())) {
    1: 
    1:             mMemoryCacheCapacity = -1;
    1:             (void) branch->GetIntPref(MEMORY_CACHE_CAPACITY_PREF,
    1:                                       &mMemoryCacheCapacity);
    1:             nsCacheService::SetMemoryCache();
    1:         }
20824:     } else if (!strcmp(NS_PRIVATE_BROWSING_SWITCH_TOPIC, topic)) {
20824:         if (!strcmp(NS_PRIVATE_BROWSING_ENTER, data.get())) {
20824:             mInPrivateBrowsing = PR_TRUE;
20824: 
20824:             nsCacheService::OnEnterExitPrivateBrowsing();
20824: 
20824: #ifdef NECKO_DISK_CACHE
20824:             mDiskCacheEnabled = PR_FALSE;
20824:             nsCacheService::SetDiskCacheEnabled(DiskCacheEnabled());
20824: #endif // !NECKO_DISK_CACHE
20824: 
20824: #ifdef NECKO_OFFLINE_CACHE
20824:             mOfflineCacheEnabled = PR_FALSE;
20824:             nsCacheService::SetOfflineCacheEnabled(OfflineCacheEnabled());
20824: #endif // !NECKO_OFFLINE_CACHE
20824:         } else if (!strcmp(NS_PRIVATE_BROWSING_LEAVE, data.get())) {
20824:             mInPrivateBrowsing = PR_FALSE;
20824: 
20824:             nsCacheService::OnEnterExitPrivateBrowsing();
20824: 
20824: #if defined(NECKO_DISK_CACHE) || defined(NECKO_OFFLINE_CACHE)
20824:             nsCOMPtr<nsIPrefBranch> branch = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
20824:             if (NS_FAILED(rv))  return rv;
20824: #endif // !NECKO_DISK_CACHE && !NECKO_OFFLINE_CACHE
20824: 
20824: #ifdef NECKO_DISK_CACHE
20824:             mDiskCacheEnabled = PR_TRUE; // by default enabled
20824:             (void) branch->GetBoolPref(DISK_CACHE_ENABLE_PREF,
20824:                                        &mDiskCacheEnabled);
20824:             nsCacheService::SetDiskCacheEnabled(DiskCacheEnabled());
20824: #endif // !NECKO_DISK_CACHE
20824: 
20824: #ifdef NECKO_OFFLINE_CACHE
20824:             mOfflineCacheEnabled = PR_TRUE; // by default enabled
20824:             (void) branch->GetBoolPref(OFFLINE_CACHE_ENABLE_PREF,
20824:                                        &mOfflineCacheEnabled);
20824:             nsCacheService::SetOfflineCacheEnabled(OfflineCacheEnabled());
20824: #endif // !NECKO_OFFLINE_CACHE
20824:         }
    1:     }
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsCacheProfilePrefObserver::ReadPrefs(nsIPrefBranch* branch)
    1: {
    1:     nsresult rv = NS_OK;
    1: 
    1: #ifdef NECKO_DISK_CACHE
    1:     // read disk cache device prefs
20824:     if (!mInPrivateBrowsing) {
    1:         mDiskCacheEnabled = PR_TRUE;  // presume disk cache is enabled
    1:         (void) branch->GetBoolPref(DISK_CACHE_ENABLE_PREF, &mDiskCacheEnabled);
20824:     }
    1: 
    1:     mDiskCacheCapacity = DISK_CACHE_CAPACITY;
    1:     (void)branch->GetIntPref(DISK_CACHE_CAPACITY_PREF, &mDiskCacheCapacity);
    1:     mDiskCacheCapacity = PR_MAX(0, mDiskCacheCapacity);
    1: 
    1:     (void) branch->GetComplexValue(DISK_CACHE_DIR_PREF,     // ignore error
    1:                                    NS_GET_IID(nsILocalFile),
    1:                                    getter_AddRefs(mDiskCacheParentDirectory));
    1:     
    1:     if (!mDiskCacheParentDirectory) {
    1:         nsCOMPtr<nsIFile>  directory;
    1: 
    1:         // try to get the disk cache parent directory
    1:         rv = NS_GetSpecialDirectory(NS_APP_CACHE_PARENT_DIR,
    1:                                     getter_AddRefs(directory));
    1:         if (NS_FAILED(rv)) {
    1:             // try to get the profile directory (there may not be a profile yet)
    1:             nsCOMPtr<nsIFile> profDir;
    1:             NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
    1:                                    getter_AddRefs(profDir));
    1:             NS_GetSpecialDirectory(NS_APP_USER_PROFILE_LOCAL_50_DIR,
    1:                                    getter_AddRefs(directory));
    1:             if (!directory)
    1:                 directory = profDir;
    1:             else if (profDir) {
    1:                 PRBool same;
    1:                 if (NS_SUCCEEDED(profDir->Equals(directory, &same)) && !same) {
    1:                     // We no longer store the cache directory in the main
    1:                     // profile directory, so we should cleanup the old one.
    1:                     rv = profDir->AppendNative(NS_LITERAL_CSTRING("Cache"));
    1:                     if (NS_SUCCEEDED(rv)) {
    1:                         PRBool exists;
    1:                         if (NS_SUCCEEDED(profDir->Exists(&exists)) && exists)
    1:                             DeleteDir(profDir, PR_FALSE, PR_FALSE);
    1:                     }
    1:                 }
    1:             }
    1:         }
31140:         // use file cache in build tree only if asked, to avoid cache dir litter
31140:         if (!directory && PR_GetEnv("NECKO_DEV_ENABLE_DISK_CACHE")) {
    1:             rv = NS_GetSpecialDirectory(NS_XPCOM_CURRENT_PROCESS_DIR,
    1:                                         getter_AddRefs(directory));
    1:         }
    1:         if (directory)
    1:             mDiskCacheParentDirectory = do_QueryInterface(directory, &rv);
    1:     }
11477: #endif // !NECKO_DISK_CACHE
    1: 
11477: #ifdef NECKO_OFFLINE_CACHE
    1:     // read offline cache device prefs
20824:     if (!mInPrivateBrowsing) {
    1:         mOfflineCacheEnabled = PR_TRUE;  // presume offline cache is enabled
    1:         (void) branch->GetBoolPref(OFFLINE_CACHE_ENABLE_PREF,
    1:                                    &mOfflineCacheEnabled);
20824:     }
    1: 
    1:     mOfflineCacheCapacity = OFFLINE_CACHE_CAPACITY;
    1:     (void)branch->GetIntPref(OFFLINE_CACHE_CAPACITY_PREF,
    1:                              &mOfflineCacheCapacity);
    1:     mOfflineCacheCapacity = PR_MAX(0, mOfflineCacheCapacity);
    1: 
    1:     (void) branch->GetComplexValue(OFFLINE_CACHE_DIR_PREF,     // ignore error
    1:                                    NS_GET_IID(nsILocalFile),
    1:                                    getter_AddRefs(mOfflineCacheParentDirectory));
    1: 
    1:     if (!mOfflineCacheParentDirectory) {
    1:         nsCOMPtr<nsIFile>  directory;
    1: 
    1:         // try to get the offline cache parent directory
    1:         rv = NS_GetSpecialDirectory(NS_APP_CACHE_PARENT_DIR,
    1:                                     getter_AddRefs(directory));
    1:         if (NS_FAILED(rv)) {
    1:             // try to get the profile directory (there may not be a profile yet)
    1:             nsCOMPtr<nsIFile> profDir;
    1:             NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
    1:                                    getter_AddRefs(profDir));
    1:             NS_GetSpecialDirectory(NS_APP_USER_PROFILE_LOCAL_50_DIR,
    1:                                    getter_AddRefs(directory));
    1:             if (!directory)
    1:                 directory = profDir;
    1:         }
    1: #if DEBUG
    1:         if (!directory) {
    1:             // use current process directory during development
    1:             rv = NS_GetSpecialDirectory(NS_XPCOM_CURRENT_PROCESS_DIR,
    1:                                         getter_AddRefs(directory));
    1:         }
    1: #endif
    1:         if (directory)
    1:             mOfflineCacheParentDirectory = do_QueryInterface(directory, &rv);
    1:     }
11477: #endif // !NECKO_OFFLINE_CACHE
    1:     
    1:     // read memory cache device prefs
    1:     (void) branch->GetBoolPref(MEMORY_CACHE_ENABLE_PREF, &mMemoryCacheEnabled);
    1: 
    1:     mMemoryCacheCapacity = -1;
    1:     (void) branch->GetIntPref(MEMORY_CACHE_CAPACITY_PREF,
    1:                               &mMemoryCacheCapacity);
    1:         
    1:     return rv;
    1: }
    1: 
    1: 
    1: PRBool
    1: nsCacheProfilePrefObserver::DiskCacheEnabled()
    1: {
    1:     if ((mDiskCacheCapacity == 0) || (!mDiskCacheParentDirectory))  return PR_FALSE;
    1:     return mDiskCacheEnabled;
    1: }
    1: 
    1: 
    1: PRBool
    1: nsCacheProfilePrefObserver::OfflineCacheEnabled()
    1: {
    1:     if ((mOfflineCacheCapacity == 0) || (!mOfflineCacheParentDirectory))
    1:         return PR_FALSE;
    1: 
    1:     return mOfflineCacheEnabled;
    1: }
    1: 
    1: 
    1: PRBool
    1: nsCacheProfilePrefObserver::MemoryCacheEnabled()
    1: {
    1:     if (mMemoryCacheCapacity == 0)  return PR_FALSE;
    1:     return mMemoryCacheEnabled;
    1: }
    1: 
    1: 
    1: /**
    1:  * MemoryCacheCapacity
    1:  *
    1:  * If the browser.cache.memory.capacity preference is positive, we use that
    1:  * value for the amount of memory available for the cache.
    1:  *
    1:  * If browser.cache.memory.capacity is zero, the memory cache is disabled.
    1:  * 
    1:  * If browser.cache.memory.capacity is negative or not present, we use a
    1:  * formula that grows less than linearly with the amount of system memory, 
    1:  * with an upper limit on the cache size. No matter how much physical RAM is
    1:  * present, the default cache size would not exceed 32 MB. This maximum would
    1:  * apply only to systems with more than 4 GB of RAM (e.g. terminal servers)
    1:  *
    1:  *   RAM   Cache
    1:  *   ---   -----
    1:  *   32 Mb   2 Mb
    1:  *   64 Mb   4 Mb
    1:  *  128 Mb   6 Mb
    1:  *  256 Mb  10 Mb
    1:  *  512 Mb  14 Mb
    1:  * 1024 Mb  18 Mb
    1:  * 2048 Mb  24 Mb
    1:  * 4096 Mb  30 Mb
    1:  *
    1:  * The equation for this is (for cache size C and memory size K (kbytes)):
    1:  *  x = log2(K) - 14
    1:  *  C = x^2/3 + x + 2/3 + 0.1 (0.1 for rounding)
    1:  *  if (C > 32) C = 32
    1:  */
    1: 
    1: PRInt32
    1: nsCacheProfilePrefObserver::MemoryCacheCapacity()
    1: {
    1:     PRInt32 capacity = mMemoryCacheCapacity;
19178:     if (capacity >= 0) {
19178:         CACHE_LOG_DEBUG(("Memory cache capacity forced to %d\n", capacity));
    1:         return capacity;
19178:     }
    1: 
    1:     PRUint64 bytes = PR_GetPhysicalMemorySize();
19178:     CACHE_LOG_DEBUG(("Physical Memory size is %llu\n", bytes));
    1: 
19243:     // If getting the physical memory failed, arbitrarily assume
19243:     // 32 MB of RAM. We use a low default to have a reasonable
19243:     // size on all the devices we support.
19243:     if (bytes == 0)
19243:         bytes = 32 * 1024 * 1024;
    1: 
    1:     // Conversion from unsigned int64 to double doesn't work on all platforms.
    1:     // We need to truncate the value at LL_MAXINT to make sure we don't
    1:     // overflow.
    1:     if (LL_CMP(bytes, >, LL_MAXINT))
    1:         bytes = LL_MAXINT;
    1: 
    1:     PRUint64 kbytes;
    1:     LL_SHR(kbytes, bytes, 10);
    1: 
    1:     double kBytesD;
    1:     LL_L2D(kBytesD, (PRInt64) kbytes);
    1: 
    1:     double x = log(kBytesD)/log(2.0) - 14;
    1:     if (x > 0) {
    1:         capacity = (PRInt32)(x * x / 3.0 + x + 2.0 / 3 + 0.1); // 0.1 for rounding
    1:         if (capacity > 32)
    1:             capacity = 32;
    1:         capacity   *= 1024;
    1:     } else {
    1:         capacity    = 0;
    1:     }
    1: 
    1:     return capacity;
    1: }
    1: 
    1: /******************************************************************************
    1:  * nsCacheService
    1:  *****************************************************************************/
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark nsCacheService
    1: #endif
    1: 
    1: nsCacheService *   nsCacheService::gService = nsnull;
    1: 
    1: NS_IMPL_THREADSAFE_ISUPPORTS1(nsCacheService, nsICacheService)
    1: 
    1: nsCacheService::nsCacheService()
    1:     : mLock(nsnull),
    1:       mInitialized(PR_FALSE),
    1:       mEnableMemoryDevice(PR_TRUE),
    1:       mEnableDiskDevice(PR_TRUE),
    1:       mMemoryDevice(nsnull),
    1:       mDiskDevice(nsnull),
    1:       mOfflineDevice(nsnull),
    1:       mTotalEntries(0),
    1:       mCacheHits(0),
    1:       mCacheMisses(0),
    1:       mMaxKeyLength(0),
    1:       mMaxDataSize(0),
    1:       mMaxMetaSize(0),
    1:       mDeactivateFailures(0),
    1:       mDeactivatedUnboundEntries(0)
    1: {
    1:     NS_ASSERTION(gService==nsnull, "multiple nsCacheService instances!");
    1:     gService = this;
    1: 
    1:     // create list of cache devices
    1:     PR_INIT_CLIST(&mDoomedEntries);
    1:   
    1:     // allocate service lock
    1:     mLock = PR_NewLock();
    1: 
    1: #if defined(DEBUG)
    1:     mLockedThread = nsnull;
    1: #endif
    1: }
    1: 
    1: nsCacheService::~nsCacheService()
    1: {
    1:     if (mInitialized) // Shutdown hasn't been called yet.
    1:         (void) Shutdown();
    1: 
    1:     PR_DestroyLock(mLock);
    1:     gService = nsnull;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsCacheService::Init()
    1: {
    1:     NS_ASSERTION(!mInitialized, "nsCacheService already initialized.");
    1:     if (mInitialized)
    1:         return NS_ERROR_ALREADY_INITIALIZED;
    1: 
    1:     if (mLock == nsnull)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     CACHE_LOG_INIT();
    1: 
    1:     // initialize hashtable for active cache entries
    1:     nsresult rv = mActiveEntries.Init();
    1:     if (NS_FAILED(rv)) return rv;
    1:     
    1:     // create profile/preference observer
    1:     mObserver = new nsCacheProfilePrefObserver();
    1:     if (!mObserver)  return NS_ERROR_OUT_OF_MEMORY;
    1:     NS_ADDREF(mObserver);
    1:     
    1:     mObserver->Install();
    1:     mEnableDiskDevice    = mObserver->DiskCacheEnabled();
    1:     mEnableOfflineDevice = mObserver->OfflineCacheEnabled();
    1:     mEnableMemoryDevice  = mObserver->MemoryCacheEnabled();
    1: 
    1:     mInitialized = PR_TRUE;
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: void
    1: nsCacheService::Shutdown()
    1: {
    1:     nsCacheServiceAutoLock lock;
    1:     NS_ASSERTION(mInitialized, 
    1:                  "can't shutdown nsCacheService unless it has been initialized.");
    1: 
    1:     if (mInitialized) {
    1: 
    1:         mInitialized = PR_FALSE;
    1: 
    1:         mObserver->Remove();
    1:         NS_RELEASE(mObserver);
    1:         
    1:         // Clear entries
    1:         ClearDoomList();
    1:         ClearActiveEntries();
    1: 
    1:         // deallocate memory and disk caches
    1:         delete mMemoryDevice;
    1:         mMemoryDevice = nsnull;
    1: 
    1: #ifdef NECKO_DISK_CACHE
    1:         delete mDiskDevice;
    1:         mDiskDevice = nsnull;
 1426: #endif // !NECKO_DISK_CACHE
    1: 
 1426: #ifdef NECKO_OFFLINE_CACHE
18430:         NS_IF_RELEASE(mOfflineDevice);
 1426: #endif // !NECKO_OFFLINE_CACHE
    1: 
 1426: #if defined(NECKO_DISK_CACHE) && defined(PR_LOGGING)
    1:         LogCacheStatistics();
    1: #endif
    1:     }
    1: }
    1: 
    1: 
    1: NS_METHOD
    1: nsCacheService::Create(nsISupports* aOuter, const nsIID& aIID, void* *aResult)
    1: {
    1:     nsresult  rv;
    1: 
    1:     if (aOuter != nsnull)
    1:         return NS_ERROR_NO_AGGREGATION;
    1: 
    1:     nsCacheService * cacheService = new nsCacheService();
    1:     if (cacheService == nsnull)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     NS_ADDREF(cacheService);
    1:     rv = cacheService->Init();
    1:     if (NS_SUCCEEDED(rv)) {
    1:         rv = cacheService->QueryInterface(aIID, aResult);
    1:     }
    1:     NS_RELEASE(cacheService);
    1:     return rv;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsCacheService::CreateSession(const char *          clientID,
    1:                               nsCacheStoragePolicy  storagePolicy, 
    1:                               PRBool                streamBased,
    1:                               nsICacheSession     **result)
    1: {
    1:     *result = nsnull;
    1: 
    1:     if (this == nsnull)  return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     nsCacheSession * session = new nsCacheSession(clientID, storagePolicy, streamBased);
    1:     if (!session)  return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     NS_ADDREF(*result = session);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsCacheService::EvictEntriesForSession(nsCacheSession * session)
    1: {
    1:     NS_ASSERTION(gService, "nsCacheService::gService is null.");
    1:     return gService->EvictEntriesForClient(session->ClientID()->get(),
    1:                                  session->StoragePolicy());
    1: }
    1: 
    1: 
    1: nsresult
    1: nsCacheService::EvictEntriesForClient(const char *          clientID,
    1:                                       nsCacheStoragePolicy  storagePolicy)
    1: {
    1:     if (this == nsnull) return NS_ERROR_NOT_AVAILABLE; // XXX eh?
    1: 
    1:     nsCOMPtr<nsIObserverService> obsSvc =
41540:         mozilla::services::GetObserverService();
    1:     if (obsSvc) {
    1:         // Proxy to the UI thread since the observer service isn't thredsafe.
    1:         // We use an async proxy, since this it's not important whether this
    1:         // notification happens before or after the actual eviction.
    1: 
    1:         nsCOMPtr<nsIObserverService> obsProxy;
    1:         NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
    1:                              NS_GET_IID(nsIObserverService), obsSvc,
    1:                              NS_PROXY_ASYNC, getter_AddRefs(obsProxy));
    1: 
    1:         if (obsProxy) {
    1:             obsProxy->NotifyObservers(this,
    1:                                       NS_CACHESERVICE_EMPTYCACHE_TOPIC_ID,
    1:                                       nsnull);
    1:         }
    1:     }
    1: 
    1:     nsCacheServiceAutoLock lock;
    1:     nsresult rv = NS_OK;
    1: 
    1: #ifdef NECKO_DISK_CACHE
    1:     if (storagePolicy == nsICache::STORE_ANYWHERE ||
    1:         storagePolicy == nsICache::STORE_ON_DISK) {
    1: 
    1:         if (mEnableDiskDevice) {
    1:             if (!mDiskDevice) {
    1:                 rv = CreateDiskDevice();
    1:                 if (NS_FAILED(rv)) return rv;
    1:             }
    1:             rv = mDiskDevice->EvictEntries(clientID);
    1:             if (NS_FAILED(rv)) return rv;
    1:         }
    1:     }
 1426: #endif // ! NECKO_DISK_CACHE
    1: 
 1426: #ifdef NECKO_OFFLINE_CACHE
10563:     // Only clear the offline cache if it has been specifically asked for.
10563:     if (storagePolicy == nsICache::STORE_OFFLINE) {
    1:         if (mEnableOfflineDevice) {
    1:             if (!mOfflineDevice) {
    1:                 rv = CreateOfflineDevice();
    1:                 if (NS_FAILED(rv)) return rv;
    1:             }
    1:             rv = mOfflineDevice->EvictEntries(clientID);
    1:             if (NS_FAILED(rv)) return rv;
    1:         }
    1:     }
 1426: #endif // ! NECKO_OFFLINE_CACHE
    1: 
    1:     if (storagePolicy == nsICache::STORE_ANYWHERE ||
    1:         storagePolicy == nsICache::STORE_IN_MEMORY) {
    1: 
    1:         // If there is no memory device, there is no need to evict it...
    1:         if (mMemoryDevice) {
    1:             rv = mMemoryDevice->EvictEntries(clientID);
    1:             if (NS_FAILED(rv)) return rv;
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult        
    1: nsCacheService::IsStorageEnabledForPolicy(nsCacheStoragePolicy  storagePolicy,
    1:                                           PRBool *              result)
    1: {
    1:     if (gService == nsnull) return NS_ERROR_NOT_AVAILABLE;
    1:     nsCacheServiceAutoLock lock;
    1: 
    1:     *result = gService->IsStorageEnabledForPolicy_Locked(storagePolicy);
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: PRBool        
    1: nsCacheService::IsStorageEnabledForPolicy_Locked(nsCacheStoragePolicy  storagePolicy)
    1: {
    1:     if (gService->mEnableMemoryDevice &&
    1:         (storagePolicy == nsICache::STORE_ANYWHERE ||
    1:          storagePolicy == nsICache::STORE_IN_MEMORY)) {
    1:         return PR_TRUE;
    1:     }
    1:     if (gService->mEnableDiskDevice &&
    1:         (storagePolicy == nsICache::STORE_ANYWHERE ||
    1:          storagePolicy == nsICache::STORE_ON_DISK  ||
    1:          storagePolicy == nsICache::STORE_ON_DISK_AS_FILE)) {
    1:         return PR_TRUE;
    1:     }
    1:     if (gService->mEnableOfflineDevice &&
    1:         storagePolicy == nsICache::STORE_OFFLINE) {
    1:         return PR_TRUE;
    1:     }
    1:     
    1:     return PR_FALSE;
    1: }
    1: 
    1: NS_IMETHODIMP nsCacheService::VisitEntries(nsICacheVisitor *visitor)
    1: {
    1:     NS_ENSURE_ARG_POINTER(visitor);
    1: 
    1:     nsCacheServiceAutoLock lock;
    1: 
    1:     if (!(mEnableDiskDevice || mEnableMemoryDevice))
    1:         return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     // XXX record the fact that a visitation is in progress, 
    1:     // XXX i.e. keep list of visitors in progress.
    1:     
    1:     nsresult rv = NS_OK;
    1:     // If there is no memory device, there are then also no entries to visit...
    1:     if (mMemoryDevice) {
    1:         rv = mMemoryDevice->Visit(visitor);
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1: 
    1: #ifdef NECKO_DISK_CACHE
    1:     if (mEnableDiskDevice) {
    1:         if (!mDiskDevice) {
    1:             rv = CreateDiskDevice();
    1:             if (NS_FAILED(rv)) return rv;
    1:         }
    1:         rv = mDiskDevice->Visit(visitor);
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
 1426: #endif // !NECKO_DISK_CACHE
    1: 
 1426: #ifdef NECKO_OFFLINE_CACHE
    1:     if (mEnableOfflineDevice) {
    1:         if (!mOfflineDevice) {
    1:             rv = CreateOfflineDevice();
    1:             if (NS_FAILED(rv)) return rv;
    1:         }
    1:         rv = mOfflineDevice->Visit(visitor);
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
 1426: #endif // !NECKO_OFFLINE_CACHE
    1: 
    1:     // XXX notify any shutdown process that visitation is complete for THIS visitor.
    1:     // XXX keep queue of visitors
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsCacheService::EvictEntries(nsCacheStoragePolicy storagePolicy)
    1: {
    1:     return  EvictEntriesForClient(nsnull, storagePolicy);
    1: }
    1: 
    1: /**
    1:  * Internal Methods
    1:  */
    1: nsresult
    1: nsCacheService::CreateDiskDevice()
    1: {
    1: #ifdef NECKO_DISK_CACHE
18430:     if (!mInitialized)      return NS_ERROR_NOT_AVAILABLE;
    1:     if (!mEnableDiskDevice) return NS_ERROR_NOT_AVAILABLE;
    1:     if (mDiskDevice)        return NS_OK;
    1: 
    1:     mDiskDevice = new nsDiskCacheDevice;
    1:     if (!mDiskDevice)       return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     // set the preferences
    1:     mDiskDevice->SetCacheParentDirectory(mObserver->DiskCacheParentDirectory());
    1:     mDiskDevice->SetCapacity(mObserver->DiskCacheCapacity());
    1:     
    1:     nsresult rv = mDiskDevice->Init();
    1:     if (NS_FAILED(rv)) {
    1: #if DEBUG
    1:         printf("###\n");
    1:         printf("### mDiskDevice->Init() failed (0x%.8x)\n", rv);
    1:         printf("###    - disabling disk cache for this session.\n");
    1:         printf("###\n");
    1: #endif        
    1:         mEnableDiskDevice = PR_FALSE;
    1:         delete mDiskDevice;
    1:         mDiskDevice = nsnull;
    1:     }
    1:     return rv;
    1: #else // !NECKO_DISK_CACHE
    1:     NS_NOTREACHED("nsCacheService::CreateDiskDevice");
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: #endif
    1: }
    1: 
    1: nsresult
    1: nsCacheService::CreateOfflineDevice()
    1: {
 1426: #ifdef NECKO_OFFLINE_CACHE
    1:     CACHE_LOG_ALWAYS(("Creating offline device"));
    1: 
18430:     if (!mInitialized)         return NS_ERROR_NOT_AVAILABLE;
    1:     if (!mEnableOfflineDevice) return NS_ERROR_NOT_AVAILABLE;
    1:     if (mOfflineDevice)        return NS_OK;
    1: 
 1426:     mOfflineDevice = new nsOfflineCacheDevice;
    1:     if (!mOfflineDevice)       return NS_ERROR_OUT_OF_MEMORY;
    1: 
18430:     NS_ADDREF(mOfflineDevice);
18430: 
    1:     // set the preferences
 1426:     mOfflineDevice->SetCacheParentDirectory(
 1426:         mObserver->OfflineCacheParentDirectory());
    1:     mOfflineDevice->SetCapacity(mObserver->OfflineCacheCapacity());
    1: 
    1:     nsresult rv = mOfflineDevice->Init();
    1:     if (NS_FAILED(rv)) {
    1:         CACHE_LOG_DEBUG(("mOfflineDevice->Init() failed (0x%.8x)\n", rv));
    1:         CACHE_LOG_DEBUG(("    - disabling offline cache for this session.\n"));
    1: 
    1:         mEnableOfflineDevice = PR_FALSE;
18430:         NS_RELEASE(mOfflineDevice);
    1:     }
    1:     return rv;
    1: #else // !NECKO_DISK_CACHE
    1:     NS_NOTREACHED("nsCacheService::CreateOfflineDevice");
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: #endif
    1: }
    1: 
    1: nsresult
    1: nsCacheService::CreateMemoryDevice()
    1: {
18430:     if (!mInitialized)        return NS_ERROR_NOT_AVAILABLE;
    1:     if (!mEnableMemoryDevice) return NS_ERROR_NOT_AVAILABLE;
    1:     if (mMemoryDevice)        return NS_OK;
    1: 
    1:     mMemoryDevice = new nsMemoryCacheDevice;
    1:     if (!mMemoryDevice)       return NS_ERROR_OUT_OF_MEMORY;
    1:     
    1:     // set preference
19178:     PRInt32 capacity = mObserver->MemoryCacheCapacity();
19178:     CACHE_LOG_DEBUG(("Creating memory device with capacity %d\n", capacity));
19178:     mMemoryDevice->SetCapacity(capacity);
    1: 
    1:     nsresult rv = mMemoryDevice->Init();
    1:     if (NS_FAILED(rv)) {
    1:         NS_WARNING("Initialization of Memory Cache failed.");
    1:         delete mMemoryDevice;
    1:         mMemoryDevice = nsnull;
    1:     }
    1:     return rv;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsCacheService::CreateRequest(nsCacheSession *   session,
    1:                               const nsACString & clientKey,
    1:                               nsCacheAccessMode  accessRequested,
    1:                               PRBool             blockingMode,
    1:                               nsICacheListener * listener,
    1:                               nsCacheRequest **  request)
    1: {
    1:     NS_ASSERTION(request, "CreateRequest: request is null");
    1:      
    1:     nsCString * key = new nsCString(*session->ClientID());
    1:     if (!key)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     key->Append(':');
    1:     key->Append(clientKey);
    1: 
    1:     if (mMaxKeyLength < key->Length()) mMaxKeyLength = key->Length();
    1: 
    1:     // create request
    1:     *request = new  nsCacheRequest(key, listener, accessRequested, blockingMode, session);    
    1:     if (!*request) {
    1:         delete key;
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     if (!listener)  return NS_OK;  // we're sync, we're done.
    1: 
    1:     // get the request's thread
    1:     (*request)->mThread = do_GetCurrentThread();
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: class nsCacheListenerEvent : public nsRunnable
    1: {
    1: public:
    1:     nsCacheListenerEvent(nsICacheListener *listener,
    1:                          nsICacheEntryDescriptor *descriptor,
    1:                          nsCacheAccessMode accessGranted,
    1:                          nsresult status)
    1:         : mListener(listener)      // transfers reference
    1:         , mDescriptor(descriptor)  // transfers reference (may be null)
    1:         , mAccessGranted(accessGranted)
    1:         , mStatus(status)
    1:     {}
    1: 
    1:     NS_IMETHOD Run()
    1:     {
    1:         mListener->OnCacheEntryAvailable(mDescriptor, mAccessGranted, mStatus);
    1: 
    1:         NS_RELEASE(mListener);
    1:         NS_IF_RELEASE(mDescriptor);
    1:         return NS_OK;
    1:     }
    1: 
    1: private:
    1:     // We explicitly leak mListener or mDescriptor if Run is not called
    1:     // because otherwise we cannot guarantee that they are destroyed on
    1:     // the right thread.
    1: 
    1:     nsICacheListener        *mListener;
    1:     nsICacheEntryDescriptor *mDescriptor;
    1:     nsCacheAccessMode        mAccessGranted;
    1:     nsresult                 mStatus;
    1: };
    1: 
    1: 
    1: nsresult
    1: nsCacheService::NotifyListener(nsCacheRequest *          request,
    1:                                nsICacheEntryDescriptor * descriptor,
    1:                                nsCacheAccessMode         accessGranted,
    1:                                nsresult                  status)
    1: {
    1:     NS_ASSERTION(request->mThread, "no thread set in async request!");
    1: 
    1:     // Swap ownership, and release listener on target thread...
    1:     nsICacheListener *listener = request->mListener;
    1:     request->mListener = nsnull;
    1: 
    1:     nsCOMPtr<nsIRunnable> ev =
    1:             new nsCacheListenerEvent(listener, descriptor,
    1:                                      accessGranted, status);
    1:     if (!ev) {
    1:         // Better to leak listener and descriptor if we fail because we don't
    1:         // want to destroy them inside the cache service lock or on potentially
    1:         // the wrong thread.
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     return request->mThread->Dispatch(ev, NS_DISPATCH_NORMAL);
    1: }
    1: 
    1: 
    1: nsresult
    1: nsCacheService::ProcessRequest(nsCacheRequest *           request,
    1:                                PRBool                     calledFromOpenCacheEntry,
    1:                                nsICacheEntryDescriptor ** result)
    1: {
    1:     // !!! must be called with mLock held !!!
    1:     nsresult           rv;
    1:     nsCacheEntry *     entry = nsnull;
    1:     nsCacheAccessMode  accessGranted = nsICache::ACCESS_NONE;
    1:     if (result) *result = nsnull;
    1: 
    1:     while(1) {  // Activate entry loop
    1:         rv = ActivateEntry(request, &entry);  // get the entry for this request
    1:         if (NS_FAILED(rv))  break;
    1: 
    1:         while(1) { // Request Access loop
    1:             NS_ASSERTION(entry, "no entry in Request Access loop!");
    1:             // entry->RequestAccess queues request on entry
    1:             rv = entry->RequestAccess(request, &accessGranted);
    1:             if (rv != NS_ERROR_CACHE_WAIT_FOR_VALIDATION) break;
    1:             
    1:             if (request->mListener) // async exits - validate, doom, or close will resume
    1:                 return rv;
    1:             
    1:             if (request->IsBlocking()) {
    1:                 // XXX this is probably wrong...
    1:                 Unlock();
    1:                 rv = request->WaitForValidation();
    1:                 Lock();
    1:             }
    1: 
    1:             PR_REMOVE_AND_INIT_LINK(request);
    1:             if (NS_FAILED(rv)) break;   // non-blocking mode returns WAIT_FOR_VALIDATION error
    1:             // okay, we're ready to process this request, request access again
    1:         }
    1:         if (rv != NS_ERROR_CACHE_ENTRY_DOOMED)  break;
    1: 
    1:         if (entry->IsNotInUse()) {
    1:             // this request was the last one keeping it around, so get rid of it
    1:             DeactivateEntry(entry);
    1:         }
    1:         // loop back around to look for another entry
    1:     }
    1: 
    1:     nsICacheEntryDescriptor *descriptor = nsnull;
    1:     
    1:     if (NS_SUCCEEDED(rv))
    1:         rv = entry->CreateDescriptor(request, accessGranted, &descriptor);
    1: 
    1:     if (request->mListener) {  // Asynchronous
    1:     
    1:         if (NS_FAILED(rv) && calledFromOpenCacheEntry)
    1:             return rv;  // skip notifying listener, just return rv to caller
    1:             
    1:         // call listener to report error or descriptor
    1:         nsresult rv2 = NotifyListener(request, descriptor, accessGranted, rv);
    1:         if (NS_FAILED(rv2) && NS_SUCCEEDED(rv)) {
    1:             rv = rv2;  // trigger delete request
    1:         }
    1:     } else {        // Synchronous
    1:         *result = descriptor;
    1:     }
    1:     return rv;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsCacheService::OpenCacheEntry(nsCacheSession *           session,
    1:                                const nsACString &         key,
    1:                                nsCacheAccessMode          accessRequested,
    1:                                PRBool                     blockingMode,
    1:                                nsICacheListener *         listener,
    1:                                nsICacheEntryDescriptor ** result)
    1: {
19178:     CACHE_LOG_DEBUG(("Opening entry for session %p, key %s, mode %d, blocking %d\n",
19178:                      session, PromiseFlatCString(key).get(), accessRequested,
19178:                      blockingMode));
    1:     NS_ASSERTION(gService, "nsCacheService::gService is null.");
    1:     if (result)
    1:         *result = nsnull;
    1: 
 5397:     if (!gService->mInitialized)
 5397:         return NS_ERROR_NOT_INITIALIZED;
 5397: 
    1:     nsCacheRequest * request = nsnull;
    1: 
    1:     nsCacheServiceAutoLock lock;
    1:     nsresult rv = gService->CreateRequest(session,
    1:                                           key,
    1:                                           accessRequested,
    1:                                           blockingMode,
    1:                                           listener,
    1:                                           &request);
    1:     if (NS_FAILED(rv))  return rv;
    1: 
19178:     CACHE_LOG_DEBUG(("Created request %p\n", request));
19178: 
    1:     rv = gService->ProcessRequest(request, PR_TRUE, result);
    1: 
    1:     // delete requests that have completed
    1:     if (!(listener && (rv == NS_ERROR_CACHE_WAIT_FOR_VALIDATION)))
    1:         delete request;
    1: 
    1:     return rv;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsCacheService::ActivateEntry(nsCacheRequest * request, 
    1:                               nsCacheEntry ** result)
    1: {
19178:     CACHE_LOG_DEBUG(("Activate entry for request %p\n", request));
19178:     
    1:     nsresult        rv = NS_OK;
    1: 
    1:     NS_ASSERTION(request != nsnull, "ActivateEntry called with no request");
    1:     if (result) *result = nsnull;
    1:     if ((!request) || (!result))  return NS_ERROR_NULL_POINTER;
    1: 
    1:     // check if the request can be satisfied
    1:     if (!mEnableMemoryDevice && !request->IsStreamBased())
    1:         return NS_ERROR_FAILURE;
    1:     if (!IsStorageEnabledForPolicy_Locked(request->StoragePolicy()))
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     // search active entries (including those not bound to device)
    1:     nsCacheEntry *entry = mActiveEntries.GetEntry(request->mKey);
19178:     CACHE_LOG_DEBUG(("Active entry for request %p is %p\n", request, entry));
    1: 
    1:     if (!entry) {
    1:         // search cache devices for entry
    1:         PRBool collision = PR_FALSE;
    1:         entry = SearchCacheDevices(request->mKey, request->StoragePolicy(), &collision);
19178:         CACHE_LOG_DEBUG(("Device search for request %p returned %p\n",
19178:                          request, entry));
    1:         // When there is a hashkey collision just refuse to cache it...
    1:         if (collision) return NS_ERROR_CACHE_IN_USE;
    1: 
    1:         if (entry)  entry->MarkInitialized();
    1:     }
    1: 
    1:     if (entry) {
    1:         ++mCacheHits;
    1:         entry->Fetched();
    1:     } else {
    1:         ++mCacheMisses;
    1:     }
    1: 
    1:     if (entry &&
    1:         ((request->AccessRequested() == nsICache::ACCESS_WRITE) ||
14110:          ((request->StoragePolicy() != nsICache::STORE_OFFLINE) &&
    1:           (entry->mExpirationTime <= SecondsFromPRTime(PR_Now()) &&
14110:            request->WillDoomEntriesIfExpired()))))
14110: 
    1:     {
    1:         // this is FORCE-WRITE request or the entry has expired
    1:         rv = DoomEntry_Internal(entry);
    1:         if (NS_FAILED(rv)) {
    1:             // XXX what to do?  Increment FailedDooms counter?
    1:         }
    1:         entry = nsnull;
    1:     }
    1: 
    1:     if (!entry) {
    1:         if (! (request->AccessRequested() & nsICache::ACCESS_WRITE)) {
    1:             // this is a READ-ONLY request
    1:             rv = NS_ERROR_CACHE_KEY_NOT_FOUND;
    1:             goto error;
    1:         }
    1: 
    1:         entry = new nsCacheEntry(request->mKey,
    1:                                  request->IsStreamBased(),
    1:                                  request->StoragePolicy());
    1:         if (!entry)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:         
    1:         entry->Fetched();
    1:         ++mTotalEntries;
    1:         
    1:         // XXX  we could perform an early bind in some cases based on storage policy
    1:     }
    1: 
    1:     if (!entry->IsActive()) {
    1:         rv = mActiveEntries.AddEntry(entry);
    1:         if (NS_FAILED(rv)) goto error;
19178:         CACHE_LOG_DEBUG(("Added entry %p to mActiveEntries\n", entry));
    1:         entry->MarkActive();  // mark entry active, because it's now in mActiveEntries
    1:     }
    1:     *result = entry;
    1:     return NS_OK;
    1:     
    1:  error:
    1:     *result = nsnull;
    1:     if (entry) {
    1:         delete entry;
    1:     }
    1:     return rv;
    1: }
    1: 
    1: 
    1: nsCacheEntry *
    1: nsCacheService::SearchCacheDevices(nsCString * key, nsCacheStoragePolicy policy, PRBool *collision)
    1: {
    1:     nsCacheEntry * entry = nsnull;
    1: 
19178:     CACHE_LOG_DEBUG(("mMemoryDevice: 0x%p\n", mMemoryDevice));
19178: 
    1:     *collision = PR_FALSE;
    1:     if ((policy == nsICache::STORE_ANYWHERE) || (policy == nsICache::STORE_IN_MEMORY)) {
    1:         // If there is no memory device, then there is nothing to search...
19178:         if (mMemoryDevice) {
    1:             entry = mMemoryDevice->FindEntry(key, collision);
19178:             CACHE_LOG_DEBUG(("Searching mMemoryDevice for key %s found: 0x%p, "
19178:                              "collision: %d\n", key->get(), entry, collision));
19178:         }
    1:     }
    1: 
    1:     if (!entry && 
    1:         ((policy == nsICache::STORE_ANYWHERE) || (policy == nsICache::STORE_ON_DISK))) {
    1: 
    1: #ifdef NECKO_DISK_CACHE
    1:         if (mEnableDiskDevice) {
    1:             if (!mDiskDevice) {
    1:                 nsresult rv = CreateDiskDevice();
    1:                 if (NS_FAILED(rv))
    1:                     return nsnull;
    1:             }
    1:             
    1:             entry = mDiskDevice->FindEntry(key, collision);
    1:         }
    1: #endif // !NECKO_DISK_CACHE
    1:     }
    1: 
    1:     if (!entry && (policy == nsICache::STORE_OFFLINE ||
    1:                    (policy == nsICache::STORE_ANYWHERE &&
    1:                     gIOService->IsOffline()))) {
    1: 
 1426: #ifdef NECKO_OFFLINE_CACHE
    1:         if (mEnableOfflineDevice) {
    1:             if (!mOfflineDevice) {
    1:                 nsresult rv = CreateOfflineDevice();
    1:                 if (NS_FAILED(rv))
    1:                     return nsnull;
    1:             }
    1: 
    1:             entry = mOfflineDevice->FindEntry(key, collision);
    1:         }
 1426: #endif // !NECKO_OFFLINE_CACHE
    1:     }
    1: 
    1:     return entry;
    1: }
    1: 
    1: 
    1: nsCacheDevice *
    1: nsCacheService::EnsureEntryHasDevice(nsCacheEntry * entry)
    1: {
    1:     nsCacheDevice * device = entry->CacheDevice();
    1:     if (device)  return device;
    1: 
    1: #ifdef NECKO_DISK_CACHE
    1:     if (entry->IsStreamData() && entry->IsAllowedOnDisk() && mEnableDiskDevice) {
    1:         // this is the default
    1:         if (!mDiskDevice) {
    1:             (void)CreateDiskDevice();  // ignore the error (check for mDiskDevice instead)
    1:         }
    1: 
    1:         if (mDiskDevice) {
    1:             entry->MarkBinding();  // enter state of binding
    1:             nsresult rv = mDiskDevice->BindEntry(entry);
    1:             entry->ClearBinding(); // exit state of binding
    1:             if (NS_SUCCEEDED(rv))
    1:                 device = mDiskDevice;
    1:         }
    1:     }
    1: #endif // !NECKO_DISK_CACHE
    1:      
    1:     // if we can't use mDiskDevice, try mMemoryDevice
    1:     if (!device && mEnableMemoryDevice && entry->IsAllowedInMemory()) {        
    1:         if (!mMemoryDevice) {
    1:             (void)CreateMemoryDevice();  // ignore the error (check for mMemoryDevice instead)
    1:         }
    1:         if (mMemoryDevice) {
    1:             entry->MarkBinding();  // enter state of binding
    1:             nsresult rv = mMemoryDevice->BindEntry(entry);
    1:             entry->ClearBinding(); // exit state of binding
    1:             if (NS_SUCCEEDED(rv))
    1:                 device = mMemoryDevice;
    1:         }
    1:     }
    1: 
 1426: #ifdef NECKO_OFFLINE_CACHE
    1:     if (!device && entry->IsStreamData() &&
    1:         entry->IsAllowedOffline() && mEnableOfflineDevice) {
    1:         if (!mOfflineDevice) {
    1:             (void)CreateOfflineDevice(); // ignore the error (check for mOfflineDevice instead)
    1:         }
    1: 
    1:         if (mOfflineDevice) {
    1:             entry->MarkBinding();
    1:             nsresult rv = mOfflineDevice->BindEntry(entry);
    1:             entry->ClearBinding();
    1:             if (NS_SUCCEEDED(rv))
    1:                 device = mOfflineDevice;
    1:         }
    1:     }
 1426: #endif // ! NECKO_OFFLINE_CACHE
    1: 
    1:     if (device) 
    1:         entry->SetCacheDevice(device);
    1:     return device;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsCacheService::DoomEntry(nsCacheEntry * entry)
    1: {
    1:     return gService->DoomEntry_Internal(entry);
    1: }
    1: 
    1: 
    1: nsresult
    1: nsCacheService::DoomEntry_Internal(nsCacheEntry * entry)
    1: {
    1:     if (entry->IsDoomed())  return NS_OK;
    1:     
19178:     CACHE_LOG_DEBUG(("Dooming entry %p\n", entry));
    1:     nsresult  rv = NS_OK;
    1:     entry->MarkDoomed();
    1:     
    1:     NS_ASSERTION(!entry->IsBinding(), "Dooming entry while binding device.");
    1:     nsCacheDevice * device = entry->CacheDevice();
    1:     if (device)  device->DoomEntry(entry);
    1: 
    1:     if (entry->IsActive()) {
    1:         // remove from active entries
    1:         mActiveEntries.RemoveEntry(entry);
19178:         CACHE_LOG_DEBUG(("Removed entry %p from mActiveEntries\n", entry));
    1:         entry->MarkInactive();
    1:      }
    1: 
    1:     // put on doom list to wait for descriptors to close
    1:     NS_ASSERTION(PR_CLIST_IS_EMPTY(entry), "doomed entry still on device list");
    1:     PR_APPEND_LINK(entry, &mDoomedEntries);
    1: 
    1:     // tell pending requests to get on with their lives...
    1:     rv = ProcessPendingRequests(entry);
    1:     
    1:     // All requests have been removed, but there may still be open descriptors
    1:     if (entry->IsNotInUse()) {
    1:         DeactivateEntry(entry); // tell device to get rid of it
    1:     }
    1:     return rv;
    1: }
    1: 
    1: 
    1: void
    1: nsCacheService::OnProfileShutdown(PRBool cleanse)
    1: {
    1:     if (!gService)  return;
41663:     if (!gService->mInitialized) {
41663:         // The cache service has been shut down, but someone is still holding
41663:         // a reference to it. Ignore this call.
41663:         return;
41663:     }
    1:     nsCacheServiceAutoLock lock;
    1: 
    1:     gService->DoomActiveEntries();
    1:     gService->ClearDoomList();
    1: 
    1: #ifdef NECKO_DISK_CACHE
    1:     if (gService->mDiskDevice && gService->mEnableDiskDevice) {
    1:         if (cleanse)
    1:             gService->mDiskDevice->EvictEntries(nsnull);
    1: 
    1:         gService->mDiskDevice->Shutdown();
 2785:     }
    1:     gService->mEnableDiskDevice = PR_FALSE;
 1426: #endif // !NECKO_DISK_CACHE
    1: 
 1426: #ifdef NECKO_OFFLINE_CACHE
    1:     if (gService->mOfflineDevice && gService->mEnableOfflineDevice) {
    1:         if (cleanse)
    1:             gService->mOfflineDevice->EvictEntries(nsnull);
    1: 
    1:         gService->mOfflineDevice->Shutdown();
 2785:     }
    1:     gService->mEnableOfflineDevice = PR_FALSE;
 1426: #endif // !NECKO_OFFLINE_CACHE
    1: 
    1:     if (gService->mMemoryDevice) {
    1:         // clear memory cache
    1:         gService->mMemoryDevice->EvictEntries(nsnull);
    1:     }
    1: 
    1: }
    1: 
    1: 
    1: void
    1: nsCacheService::OnProfileChanged()
    1: {
    1:     if (!gService)  return;
    1: 
19178:     CACHE_LOG_DEBUG(("nsCacheService::OnProfileChanged"));
19178:  
    1:     nsCacheServiceAutoLock lock;
    1:     
    1:     gService->mEnableDiskDevice    = gService->mObserver->DiskCacheEnabled();
    1:     gService->mEnableOfflineDevice = gService->mObserver->OfflineCacheEnabled();
    1:     gService->mEnableMemoryDevice  = gService->mObserver->MemoryCacheEnabled();
    1: 
    1: #ifdef NECKO_DISK_CACHE
    1:     if (gService->mDiskDevice) {
    1:         gService->mDiskDevice->SetCacheParentDirectory(gService->mObserver->DiskCacheParentDirectory());
    1:         gService->mDiskDevice->SetCapacity(gService->mObserver->DiskCacheCapacity());
    1: 
    1:         // XXX initialization of mDiskDevice could be made lazily, if mEnableDiskDevice is false
    1:         nsresult rv = gService->mDiskDevice->Init();
    1:         if (NS_FAILED(rv)) {
    1:             NS_ERROR("nsCacheService::OnProfileChanged: Re-initializing disk device failed");
    1:             gService->mEnableDiskDevice = PR_FALSE;
    1:             // XXX delete mDiskDevice?
    1:         }
    1:     }
 1426: #endif // !NECKO_DISK_CACHE
    1: 
 1426: #ifdef NECKO_OFFLINE_CACHE
    1:     if (gService->mOfflineDevice) {
    1:         gService->mOfflineDevice->SetCacheParentDirectory(gService->mObserver->OfflineCacheParentDirectory());
    1:         gService->mOfflineDevice->SetCapacity(gService->mObserver->OfflineCacheCapacity());
    1: 
    1:         // XXX initialization of mOfflineDevice could be made lazily, if mEnableOfflineDevice is false
    1:         nsresult rv = gService->mOfflineDevice->Init();
    1:         if (NS_FAILED(rv)) {
    1:             NS_ERROR("nsCacheService::OnProfileChanged: Re-initializing offline device failed");
    1:             gService->mEnableOfflineDevice = PR_FALSE;
    1:             // XXX delete mOfflineDevice?
    1:         }
    1:     }
 1426: #endif // !NECKO_OFFLINE_CACHE
    1:     
    1:     // If memoryDevice exists, reset its size to the new profile
    1:     if (gService->mMemoryDevice) {
    1:         if (gService->mEnableMemoryDevice) {
    1:             // make sure that capacity is reset to the right value
19178:             PRInt32 capacity = gService->mObserver->MemoryCacheCapacity();
19178:             CACHE_LOG_DEBUG(("Resetting memory device capacity to %d\n",
19178:                              capacity));
19178:             gService->mMemoryDevice->SetCapacity(capacity);
    1:         } else {
    1:             // tell memory device to evict everything
19178:             CACHE_LOG_DEBUG(("memory device disabled\n"));
    1:             gService->mMemoryDevice->SetCapacity(0);
    1:             // Don't delete memory device, because some entries may be active still...
    1:         }
    1:     }
    1: }
    1: 
    1: 
    1: void
    1: nsCacheService::SetDiskCacheEnabled(PRBool  enabled)
    1: {
    1:     if (!gService)  return;
    1:     nsCacheServiceAutoLock lock;
    1:     gService->mEnableDiskDevice = enabled;
    1: }
    1: 
    1: 
    1: void
    1: nsCacheService::SetDiskCacheCapacity(PRInt32  capacity)
    1: {
    1:     if (!gService)  return;
    1:     nsCacheServiceAutoLock lock;
    1: 
    1: #ifdef NECKO_DISK_CACHE
    1:     if (gService->mDiskDevice) {
    1:         gService->mDiskDevice->SetCapacity(capacity);
    1:     }
    1: #endif // !NECKO_DISK_CACHE
    1:     
    1:     gService->mEnableDiskDevice = gService->mObserver->DiskCacheEnabled();
    1: }
    1: 
    1: void
    1: nsCacheService::SetOfflineCacheEnabled(PRBool  enabled)
    1: {
    1:     if (!gService)  return;
    1:     nsCacheServiceAutoLock lock;
    1:     gService->mEnableOfflineDevice = enabled;
    1: }
    1: 
    1: void
    1: nsCacheService::SetOfflineCacheCapacity(PRInt32  capacity)
    1: {
    1:     if (!gService)  return;
    1:     nsCacheServiceAutoLock lock;
    1: 
 1426: #ifdef NECKO_OFFLINE_CACHE
    1:     if (gService->mOfflineDevice) {
    1:         gService->mOfflineDevice->SetCapacity(capacity);
    1:     }
 1426: #endif // !NECKO_OFFLINE_CACHE
    1: 
    1:     gService->mEnableOfflineDevice = gService->mObserver->OfflineCacheEnabled();
    1: }
    1: 
    1: 
    1: void
    1: nsCacheService::SetMemoryCache()
    1: {
    1:     if (!gService)  return;
19178: 
19178:     CACHE_LOG_DEBUG(("nsCacheService::SetMemoryCache"));
19178: 
    1:     nsCacheServiceAutoLock lock;
    1: 
    1:     gService->mEnableMemoryDevice = gService->mObserver->MemoryCacheEnabled();
    1: 
    1:     if (gService->mEnableMemoryDevice) {
    1:         if (gService->mMemoryDevice) {
19179:             PRInt32 capacity = gService->mObserver->MemoryCacheCapacity();
    1:             // make sure that capacity is reset to the right value
19178:             CACHE_LOG_DEBUG(("Resetting memory device capacity to %d\n",
19178:                              capacity));
19178:             gService->mMemoryDevice->SetCapacity(capacity);
    1:         }
    1:     } else {
    1:         if (gService->mMemoryDevice) {
    1:             // tell memory device to evict everything
19178:             CACHE_LOG_DEBUG(("memory device disabled\n"));
    1:             gService->mMemoryDevice->SetCapacity(0);
    1:             // Don't delete memory device, because some entries may be active still...
    1:         }
    1:     }
    1: }
    1: 
    1: 
    1: /******************************************************************************
    1:  * static methods for nsCacheEntryDescriptor
    1:  *****************************************************************************/
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #endif
    1: 
    1: void
    1: nsCacheService::CloseDescriptor(nsCacheEntryDescriptor * descriptor)
    1: {
    1:     // ask entry to remove descriptor
    1:     nsCacheEntry * entry       = descriptor->CacheEntry();
    1:     PRBool         stillActive = entry->RemoveDescriptor(descriptor);
    1:     nsresult       rv          = NS_OK;
    1: 
    1:     if (!entry->IsValid()) {
    1:         rv = gService->ProcessPendingRequests(entry);
    1:     }
    1: 
    1:     if (!stillActive) {
    1:         gService->DeactivateEntry(entry);
    1:     }
    1: }
    1: 
    1: 
    1: nsresult        
    1: nsCacheService::GetFileForEntry(nsCacheEntry *         entry,
    1:                                 nsIFile **             result)
    1: {
    1:     nsCacheDevice * device = gService->EnsureEntryHasDevice(entry);
    1:     if (!device)  return  NS_ERROR_UNEXPECTED;
    1:     
    1:     return device->GetFileForEntry(entry, result);
    1: }
    1: 
    1: 
    1: nsresult
    1: nsCacheService::OpenInputStreamForEntry(nsCacheEntry *     entry,
    1:                                         nsCacheAccessMode  mode,
    1:                                         PRUint32           offset,
    1:                                         nsIInputStream  ** result)
    1: {
    1:     nsCacheDevice * device = gService->EnsureEntryHasDevice(entry);
    1:     if (!device)  return  NS_ERROR_UNEXPECTED;
    1: 
    1:     return device->OpenInputStreamForEntry(entry, mode, offset, result);
    1: }
    1: 
    1: nsresult
    1: nsCacheService::OpenOutputStreamForEntry(nsCacheEntry *     entry,
    1:                                          nsCacheAccessMode  mode,
    1:                                          PRUint32           offset,
    1:                                          nsIOutputStream ** result)
    1: {
    1:     nsCacheDevice * device = gService->EnsureEntryHasDevice(entry);
    1:     if (!device)  return  NS_ERROR_UNEXPECTED;
    1: 
    1:     return device->OpenOutputStreamForEntry(entry, mode, offset, result);
    1: }
    1: 
    1: 
    1: nsresult
    1: nsCacheService::OnDataSizeChange(nsCacheEntry * entry, PRInt32 deltaSize)
    1: {
    1:     nsCacheDevice * device = gService->EnsureEntryHasDevice(entry);
    1:     if (!device)  return  NS_ERROR_UNEXPECTED;
    1: 
    1:     return device->OnDataSizeChange(entry, deltaSize);
    1: }
    1: 
    1: void
    1: nsCacheService::Lock()
    1: {
    1:     PR_Lock(gService->mLock);
    1: 
    1: #if defined(DEBUG)
    1:     gService->mLockedThread = PR_GetCurrentThread();
    1: #endif
    1: }
    1: 
    1: void
    1: nsCacheService::Unlock()
    1: {
    1:     NS_ASSERTION(gService->mLockedThread == PR_GetCurrentThread(), "oops");
    1: 
    1:     nsTArray<nsISupports*> doomed;
    1:     doomed.SwapElements(gService->mDoomedObjects);
    1: 
    1: #if defined(DEBUG)
    1:     gService->mLockedThread = nsnull;
    1: #endif
    1:     PR_Unlock(gService->mLock);
    1: 
    1:     for (PRUint32 i = 0; i < doomed.Length(); ++i)
    1:         doomed[i]->Release();
    1: }
    1: 
    1: void
    1: nsCacheService::ReleaseObject_Locked(nsISupports * obj,
    1:                                      nsIEventTarget * target)
    1: {
    1:     NS_ASSERTION(gService->mLockedThread == PR_GetCurrentThread(), "oops");
    1: 
    1:     PRBool isCur;
    1:     if (!target || NS_SUCCEEDED(target->IsOnCurrentThread(&isCur)) && isCur) {
    1:         gService->mDoomedObjects.AppendElement(obj);
    1:     } else {
    1:         NS_ProxyRelease(target, obj);
    1:     }
    1: }
    1: 
    1: 
    1: nsresult
    1: nsCacheService::SetCacheElement(nsCacheEntry * entry, nsISupports * element)
    1: {
    1:     entry->SetData(element);
    1:     entry->TouchData();
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsCacheService::ValidateEntry(nsCacheEntry * entry)
    1: {
    1:     nsCacheDevice * device = gService->EnsureEntryHasDevice(entry);
    1:     if (!device)  return  NS_ERROR_UNEXPECTED;
    1: 
    1:     entry->MarkValid();
    1:     nsresult rv = gService->ProcessPendingRequests(entry);
    1:     NS_ASSERTION(rv == NS_OK, "ProcessPendingRequests failed.");
    1:     // XXX what else should be done?
    1: 
    1:     return rv;
    1: }
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #endif
    1: 
    1: 
    1: void
    1: nsCacheService::DeactivateEntry(nsCacheEntry * entry)
    1: {
19178:     CACHE_LOG_DEBUG(("Deactivating entry %p\n", entry));
    1:     nsresult  rv = NS_OK;
    1:     NS_ASSERTION(entry->IsNotInUse(), "### deactivating an entry while in use!");
    1:     nsCacheDevice * device = nsnull;
    1: 
    1:     if (mMaxDataSize < entry->DataSize() )     mMaxDataSize = entry->DataSize();
    1:     if (mMaxMetaSize < entry->MetaDataSize() ) mMaxMetaSize = entry->MetaDataSize();
    1: 
    1:     if (entry->IsDoomed()) {
    1:         // remove from Doomed list
    1:         PR_REMOVE_AND_INIT_LINK(entry);
    1:     } else if (entry->IsActive()) {
    1:         // remove from active entries
    1:         mActiveEntries.RemoveEntry(entry);
19178:         CACHE_LOG_DEBUG(("Removed deactivated entry %p from mActiveEntries\n",
19178:                          entry));
    1:         entry->MarkInactive();
    1: 
    1:         // bind entry if necessary to store meta-data
    1:         device = EnsureEntryHasDevice(entry); 
    1:         if (!device) {
19178:             CACHE_LOG_DEBUG(("DeactivateEntry: unable to bind active "
19178:                              "entry %p\n",
19178:                              entry));
    1:             NS_WARNING("DeactivateEntry: unable to bind active entry\n");
    1:             return;
    1:         }
    1:     } else {
    1:         // if mInitialized == PR_FALSE,
    1:         // then we're shutting down and this state is okay.
    1:         NS_ASSERTION(!mInitialized, "DeactivateEntry: bad cache entry state.");
    1:     }
    1: 
    1:     device = entry->CacheDevice();
    1:     if (device) {
    1:         rv = device->DeactivateEntry(entry);
    1:         if (NS_FAILED(rv)) {
    1:             // increment deactivate failure count
    1:             ++mDeactivateFailures;
    1:         }
    1:     } else {
    1:         // increment deactivating unbound entry statistic
    1:         ++mDeactivatedUnboundEntries;
    1:         delete entry; // because no one else will
    1:     }
    1: }
    1: 
    1: 
    1: nsresult
    1: nsCacheService::ProcessPendingRequests(nsCacheEntry * entry)
    1: {
    1:     nsresult            rv = NS_OK;
    1:     nsCacheRequest *    request = (nsCacheRequest *)PR_LIST_HEAD(&entry->mRequestQ);
    1:     nsCacheRequest *    nextRequest;
    1:     PRBool              newWriter = PR_FALSE;
    1:     
    1:     if (request == &entry->mRequestQ)  return NS_OK;    // no queued requests
    1: 
    1:     if (!entry->IsDoomed() && entry->IsInvalid()) {
    1:         // 1st descriptor closed w/o MarkValid()
    1:         NS_ASSERTION(PR_CLIST_IS_EMPTY(&entry->mDescriptorQ), "shouldn't be here with open descriptors");
    1: 
    1: #if DEBUG
    1:         // verify no ACCESS_WRITE requests(shouldn't have any of these)
    1:         while (request != &entry->mRequestQ) {
    1:             NS_ASSERTION(request->AccessRequested() != nsICache::ACCESS_WRITE,
    1:                          "ACCESS_WRITE request should have been given a new entry");
    1:             request = (nsCacheRequest *)PR_NEXT_LINK(request);
    1:         }
    1:         request = (nsCacheRequest *)PR_LIST_HEAD(&entry->mRequestQ);        
    1: #endif
    1:         // find first request with ACCESS_READ_WRITE (if any) and promote it to 1st writer
    1:         while (request != &entry->mRequestQ) {
    1:             if (request->AccessRequested() == nsICache::ACCESS_READ_WRITE) {
    1:                 newWriter = PR_TRUE;
    1:                 break;
    1:             }
    1: 
    1:             request = (nsCacheRequest *)PR_NEXT_LINK(request);
    1:         }
    1:         
    1:         if (request == &entry->mRequestQ)   // no requests asked for ACCESS_READ_WRITE, back to top
    1:             request = (nsCacheRequest *)PR_LIST_HEAD(&entry->mRequestQ);
    1:         
    1:         // XXX what should we do if there are only READ requests in queue?
    1:         // XXX serialize their accesses, give them only read access, but force them to check validate flag?
    1:         // XXX or do readers simply presume the entry is valid
    1:     }
    1: 
    1:     nsCacheAccessMode  accessGranted = nsICache::ACCESS_NONE;
    1: 
    1:     while (request != &entry->mRequestQ) {
    1:         nextRequest = (nsCacheRequest *)PR_NEXT_LINK(request);
    1: 
    1:         if (request->mListener) {
    1: 
    1:             // Async request
    1:             PR_REMOVE_AND_INIT_LINK(request);
    1: 
    1:             if (entry->IsDoomed()) {
    1:                 rv = ProcessRequest(request, PR_FALSE, nsnull);
    1:                 if (rv == NS_ERROR_CACHE_WAIT_FOR_VALIDATION)
    1:                     rv = NS_OK;
    1:                 else
    1:                     delete request;
    1: 
    1:                 if (NS_FAILED(rv)) {
    1:                     // XXX what to do?
    1:                 }
    1:             } else if (entry->IsValid() || newWriter) {
    1:                 rv = entry->RequestAccess(request, &accessGranted);
    1:                 NS_ASSERTION(NS_SUCCEEDED(rv),
    1:                              "if entry is valid, RequestAccess must succeed.");
    1:                 // XXX if (newWriter)  NS_ASSERTION( accessGranted == request->AccessRequested(), "why not?");
    1: 
    1:                 // entry->CreateDescriptor dequeues request, and queues descriptor
    1:                 nsICacheEntryDescriptor *descriptor = nsnull;
    1:                 rv = entry->CreateDescriptor(request,
    1:                                              accessGranted,
    1:                                              &descriptor);
    1:                 
    1:                 // post call to listener to report error or descriptor
    1:                 rv = NotifyListener(request, descriptor, accessGranted, rv);
    1:                 delete request;
    1:                 if (NS_FAILED(rv)) {
    1:                     // XXX what to do?
    1:                 }
    1:                 
    1:             } else {
    1:                 // XXX bad state
    1:             }
    1:         } else {
    1: 
    1:             // Synchronous request
    1:             request->WakeUp();
    1:         }
    1:         if (newWriter)  break;  // process remaining requests after validation
    1:         request = nextRequest;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: void
    1: nsCacheService::ClearPendingRequests(nsCacheEntry * entry)
    1: {
    1:     nsCacheRequest * request = (nsCacheRequest *)PR_LIST_HEAD(&entry->mRequestQ);
    1:     
    1:     while (request != &entry->mRequestQ) {
    1:         nsCacheRequest * next = (nsCacheRequest *)PR_NEXT_LINK(request);
    1: 
    1:         // XXX we're just dropping these on the floor for now...definitely wrong.
    1:         PR_REMOVE_AND_INIT_LINK(request);
    1:         delete request;
    1:         request = next;
    1:     }
    1: }
    1: 
    1: 
    1: void
    1: nsCacheService::ClearDoomList()
    1: {
    1:     nsCacheEntry * entry = (nsCacheEntry *)PR_LIST_HEAD(&mDoomedEntries);
    1: 
    1:     while (entry != &mDoomedEntries) {
    1:         nsCacheEntry * next = (nsCacheEntry *)PR_NEXT_LINK(entry);
    1:         
    1:          entry->DetachDescriptors();
    1:          DeactivateEntry(entry);
    1:          entry = next;
    1:     }        
    1: }
    1: 
    1: 
    1: void
    1: nsCacheService::ClearActiveEntries()
    1: {
12874:     mActiveEntries.VisitEntries(DeactivateAndClearEntry, nsnull);
    1:     mActiveEntries.Shutdown();
    1: }
    1: 
    1: 
20261: PLDHashOperator
    1: nsCacheService::DeactivateAndClearEntry(PLDHashTable *    table,
    1:                                         PLDHashEntryHdr * hdr,
    1:                                         PRUint32          number,
    1:                                         void *            arg)
    1: {
    1:     nsCacheEntry * entry = ((nsCacheEntryHashTableEntry *)hdr)->cacheEntry;
    1:     NS_ASSERTION(entry, "### active entry = nsnull!");
    1:     gService->ClearPendingRequests(entry);
    1:     entry->DetachDescriptors();
    1:     
    1:     entry->MarkInactive();  // so we don't call Remove() while we're enumerating
    1:     gService->DeactivateEntry(entry);
    1:     
    1:     return PL_DHASH_REMOVE; // and continue enumerating
    1: }
    1: 
    1: 
    1: void
    1: nsCacheService::DoomActiveEntries()
    1: {
25383:     nsAutoTArray<nsCacheEntry*, 8> array;
    1: 
12874:     mActiveEntries.VisitEntries(RemoveActiveEntry, &array);
    1: 
25383:     PRUint32 count = array.Length();
    1:     for (PRUint32 i=0; i < count; ++i)
25383:         DoomEntry_Internal(array[i]);
    1: }
    1: 
    1: 
20261: PLDHashOperator
    1: nsCacheService::RemoveActiveEntry(PLDHashTable *    table,
    1:                                   PLDHashEntryHdr * hdr,
    1:                                   PRUint32          number,
    1:                                   void *            arg)
    1: {
    1:     nsCacheEntry * entry = ((nsCacheEntryHashTableEntry *)hdr)->cacheEntry;
    1:     NS_ASSERTION(entry, "### active entry = nsnull!");
    1: 
25383:     nsTArray<nsCacheEntry*> * array = (nsTArray<nsCacheEntry*> *) arg;
    1:     NS_ASSERTION(array, "### array = nsnull!");
    1:     array->AppendElement(entry);
    1: 
    1:     // entry is being removed from the active entry list
    1:     entry->MarkInactive();
    1:     return PL_DHASH_REMOVE; // and continue enumerating
    1: }
    1: 
    1: 
    1: #if defined(PR_LOGGING)
    1: void
    1: nsCacheService::LogCacheStatistics()
    1: {
    1:     PRUint32 hitPercentage = (PRUint32)((((double)mCacheHits) /
    1:         ((double)(mCacheHits + mCacheMisses))) * 100);
    1:     CACHE_LOG_ALWAYS(("\nCache Service Statistics:\n\n"));
    1:     CACHE_LOG_ALWAYS(("    TotalEntries   = %d\n", mTotalEntries));
    1:     CACHE_LOG_ALWAYS(("    Cache Hits     = %d\n", mCacheHits));
    1:     CACHE_LOG_ALWAYS(("    Cache Misses   = %d\n", mCacheMisses));
    1:     CACHE_LOG_ALWAYS(("    Cache Hit %%    = %d%%\n", hitPercentage));
    1:     CACHE_LOG_ALWAYS(("    Max Key Length = %d\n", mMaxKeyLength));
    1:     CACHE_LOG_ALWAYS(("    Max Meta Size  = %d\n", mMaxMetaSize));
    1:     CACHE_LOG_ALWAYS(("    Max Data Size  = %d\n", mMaxDataSize));
    1:     CACHE_LOG_ALWAYS(("\n"));
    1:     CACHE_LOG_ALWAYS(("    Deactivate Failures         = %d\n",
    1:                       mDeactivateFailures));
    1:     CACHE_LOG_ALWAYS(("    Deactivated Unbound Entries = %d\n",
    1:                       mDeactivatedUnboundEntries));
    1: }
    1: #endif
20824: 
20824: 
20824: void
20824: nsCacheService::OnEnterExitPrivateBrowsing()
20824: {
20824:     if (!gService)  return;
20824:     nsCacheServiceAutoLock lock;
20824: 
20824:     gService->DoomActiveEntries();
20824: 
20824:     if (gService->mMemoryDevice) {
20824:         // clear memory cache
20824:         gService->mMemoryDevice->EvictEntries(nsnull);
20824:     }
20824: }
