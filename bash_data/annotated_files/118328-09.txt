114508: // Copyright (c) 2012, Google Inc.
114508: // All rights reserved.
114508: //
114508: // Redistribution and use in source and binary forms, with or without
114508: // modification, are permitted provided that the following conditions are
114508: // met:
114508: //
114508: //     * Redistributions of source code must retain the above copyright
114508: // notice, this list of conditions and the following disclaimer.
114508: //     * Redistributions in binary form must reproduce the above
114508: // copyright notice, this list of conditions and the following disclaimer
114508: // in the documentation and/or other materials provided with the
114508: // distribution.
114508: //     * Neither the name of Google Inc. nor the names of its
114508: // contributors may be used to endorse or promote products derived from
114508: // this software without specific prior written permission.
114508: //
114508: // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
114508: // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
114508: // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
114508: // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
114508: // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
114508: // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
114508: // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
114508: // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
114508: // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
114508: // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
114508: // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
114508: 
114508: // This contains Pthread-related functions not provided by the Android NDK
114508: // but required by the Breakpad unit test. The functions are inlined here
114508: // in a C++ anonymous namespace in order to keep the build files simples.
114508: 
114508: #ifndef GOOGLE_BREAKPAD_COMMON_ANDROID_TESTING_PTHREAD_FIXES_H
114508: #define GOOGLE_BREAKPAD_COMMON_ANDROID_TESTING_PTHREAD_FIXES_H
114508: 
114508: #include <pthread.h>
114508: 
114508: namespace {
114508: 
114508: // Android doesn't provide pthread_barrier_t for now.
114508: #ifndef PTHREAD_BARRIER_SERIAL_THREAD
114508: 
114508: // Anything except 0 will do here.
114508: #define PTHREAD_BARRIER_SERIAL_THREAD  0x12345
114508: 
114508: typedef struct {
114508:   pthread_mutex_t  mutex;
114508:   pthread_cond_t   cond;
114508:   unsigned         count;
114508: } pthread_barrier_t;
114508: 
114508: int pthread_barrier_init(pthread_barrier_t* barrier,
114508:                          const void* /* barrier_attr */,
114508:                          unsigned count) {
114508:   barrier->count = count;
114508:   pthread_mutex_init(&barrier->mutex, NULL);
114508:   pthread_cond_init(&barrier->cond, NULL);
114508:   return 0;
114508: }
114508: 
114508: int pthread_barrier_wait(pthread_barrier_t* barrier) {
114508:   // Lock the mutex
114508:   pthread_mutex_lock(&barrier->mutex);
114508:   // Decrement the count. If this is the first thread to reach 0, wake up
114508:   // waiters, unlock the mutex, then return PTHREAD_BARRIER_SERIAL_THREAD.
114508:   if (--barrier->count == 0) {
114508:     // First thread to reach the barrier
114508:     pthread_cond_broadcast(&barrier->cond);
114508:     pthread_mutex_unlock(&barrier->mutex);
114508:     return PTHREAD_BARRIER_SERIAL_THREAD;
114508:   }
114508:   // Otherwise, wait for other threads until the count reaches 0, then
114508:   // return 0 to indicate this is not the first thread.
114508:   do {
114508:     pthread_cond_wait(&barrier->cond, &barrier->mutex);
114508:   } while (barrier->count > 0);
114508: 
114508:   pthread_mutex_unlock(&barrier->mutex);
114508:   return 0;
114508: }
114508: 
114508: int pthread_barrier_destroy(pthread_barrier_t *barrier) {
114508:   barrier->count = 0;
114508:   pthread_cond_destroy(&barrier->cond);
114508:   pthread_mutex_destroy(&barrier->mutex);
118328:   return 0;
114508: }
114508: 
114508: #endif  // defined(PTHREAD_BARRIER_SERIAL_THREAD)
114508: 
114508: int pthread_yield(void) {
114508:   sched_yield();
114508:   return 0;
114508: }
114508: 
114508: }  // namespace
114508: 
114508: #endif  // GOOGLE_BREAKPAD_COMMON_ANDROID_TESTING_PTHREAD_FIXES_H
