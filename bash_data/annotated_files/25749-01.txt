    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Author: Kyle Yuan (kyle.yuan@sun.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsIBoxObject.h"
    1: #include "nsIDOMXULElement.h"
    1: #include "nsIDOMXULMultSelectCntrlEl.h"
  144: #include "nsIDOMXULTreeElement.h"
    1: #include "nsITreeSelection.h"
    1: #include "nsXULTreeAccessibleWrap.h"
    1: #include "nsIMutableArray.h"
    1: #include "nsComponentManagerUtils.h"
    1: 
    1: #ifdef MOZ_ACCESSIBILITY_ATK
    1: #include "nsIAccessibleTable.h"
    1: #endif
    1: 
    1: /* static */
    1: PRBool nsXULTreeAccessible::IsColumnHidden(nsITreeColumn *aColumn)
    1: {
    1:   nsCOMPtr<nsIDOMElement> element;
    1:   aColumn->GetElement(getter_AddRefs(element));
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(element);
    1:   return content->AttrValueIs(kNameSpaceID_None, nsAccessibilityAtoms::hidden,
    1:                               nsAccessibilityAtoms::_true, eCaseMatters);
    1: }
    1: 
    1: /* static */
    1: already_AddRefed<nsITreeColumn> nsXULTreeAccessible::GetNextVisibleColumn(nsITreeColumn *aColumn)
    1: {
    1:   // Skip hidden columns.
    1:   nsCOMPtr<nsITreeColumn> nextColumn;
    1:   aColumn->GetNext(getter_AddRefs(nextColumn));
    1:   while (nextColumn && IsColumnHidden(nextColumn)) {
    1:     nsCOMPtr<nsITreeColumn> tempColumn;
    1:     nextColumn->GetNext(getter_AddRefs(tempColumn));
    1:     nextColumn.swap(tempColumn);
    1:   }
    1: 
    1:   nsITreeColumn *retCol = nsnull;
    1:   nextColumn.swap(retCol);
    1:   return retCol;
    1: }
    1: 
    1: /* static */
    1: already_AddRefed<nsITreeColumn> nsXULTreeAccessible::GetFirstVisibleColumn(nsITreeBoxObject *aTree)
    1: {
    1:   nsCOMPtr<nsITreeColumns> cols;
    1:   nsCOMPtr<nsITreeColumn> column;
    1:   aTree->GetColumns(getter_AddRefs(cols));
    1:   if (cols) {
    1:     cols->GetFirstColumn(getter_AddRefs(column));
    1:   }
    1: 
    1:   if (column && IsColumnHidden(column)) {
    1:     column = GetNextVisibleColumn(column);
    1:   }
    1:   NS_ENSURE_TRUE(column, nsnull);
    1: 
    1:   nsITreeColumn *retCol = nsnull;
    1:   column.swap(retCol);
    1:   return retCol;
    1: }
    1: 
    1: /* static */
    1: already_AddRefed<nsITreeColumn> nsXULTreeAccessible::GetLastVisibleColumn(nsITreeBoxObject *aTree)
    1: {
    1:   nsCOMPtr<nsITreeColumns> cols;
    1:   nsCOMPtr<nsITreeColumn> column;
    1:   aTree->GetColumns(getter_AddRefs(cols));
    1:   if (cols) {
    1:     cols->GetLastColumn(getter_AddRefs(column));
    1:   }
    1: 
    1:   // Skip hidden columns.
    1:   while (column && IsColumnHidden(column)) {
    1:     nsCOMPtr<nsITreeColumn> tempColumn;
    1:     column->GetPrevious(getter_AddRefs(tempColumn));
    1:     column.swap(tempColumn);
    1:   }
    1:   NS_ENSURE_TRUE(column, nsnull);
    1: 
    1:   nsITreeColumn *retCol = nsnull;
    1:   column.swap(retCol);
    1:   return retCol;
    1: }
    1: 
    1: // ---------- nsXULTreeAccessible ----------
    1: 
    1: nsXULTreeAccessible::nsXULTreeAccessible(nsIDOMNode *aDOMNode, nsIWeakReference *aShell):
    1: nsXULSelectableAccessible(aDOMNode, aShell),
    1: mAccessNodeCache(nsnull)
    1: 
    1: {
    1:   GetTreeBoxObject(aDOMNode, getter_AddRefs(mTree));
    1:   if (mTree)
    1:     mTree->GetView(getter_AddRefs(mTreeView));
    1:   NS_ASSERTION(mTree && mTreeView, "Can't get mTree or mTreeView!\n");
 3466:   mAccessNodeCache = new nsAccessNodeHashtable;
    1:   mAccessNodeCache->Init(kDefaultTreeCacheSize);
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS_INHERITED1(nsXULTreeAccessible, nsXULSelectableAccessible, nsIAccessibleTreeCache)
    1:                                                                                                        
    1: 
    1: 
    1: // Get the nsITreeBoxObject interface from any levels DOMNode under the <tree>
    1: void nsXULTreeAccessible::GetTreeBoxObject(nsIDOMNode *aDOMNode, nsITreeBoxObject **aBoxObject)
    1: {
    1:   nsAutoString name;
    1:   nsCOMPtr<nsIDOMNode> parentNode, currentNode;
    1: 
    1:   // Find DOMNode's parents recursively until reach the <tree> tag
    1:   currentNode = aDOMNode;
    1:   while (currentNode) {
    1:     currentNode->GetLocalName(name);
    1:     if (name.EqualsLiteral("tree")) {
    1:       // We will get the nsITreeBoxObject from the tree node
    1:       nsCOMPtr<nsIDOMXULElement> xulElement(do_QueryInterface(currentNode));
    1:       if (xulElement) {
    1:         nsCOMPtr<nsIBoxObject> box;
    1:         xulElement->GetBoxObject(getter_AddRefs(box));
    1:         nsCOMPtr<nsITreeBoxObject> treeBox(do_QueryInterface(box));
    1:         if (treeBox) {
    1:           *aBoxObject = treeBox;
    1:           NS_ADDREF(*aBoxObject);
    1:           return;
    1:         }
    1:       }
    1:     }
    1:     currentNode->GetParentNode(getter_AddRefs(parentNode));
    1:     currentNode = parentNode;
    1:   }
    1: 
    1:   *aBoxObject = nsnull;
    1: }
    1: 
21256: nsresult
21256: nsXULTreeAccessible::GetStateInternal(PRUint32 *aState, PRUint32 *aExtraState)
    1: {
    1:   // Get focus status from base class
21256:   nsresult rv = nsAccessible::GetStateInternal(aState, aExtraState);
21984:   NS_ENSURE_A11Y_SUCCESS(rv, rv);
    1:   
    1:   // see if we are multiple select if so set ourselves as such
    1:   nsCOMPtr<nsIDOMElement> element (do_QueryInterface(mDOMNode));
    1:   if (element) {
    1:     // the default selection type is multiple
    1:     nsAutoString selType;
    1:     element->GetAttribute(NS_LITERAL_STRING("seltype"), selType);
    1:     if (selType.IsEmpty() || !selType.EqualsLiteral("single"))
  262:       *aState |= nsIAccessibleStates::STATE_MULTISELECTABLE;
    1:   }
    1: 
  262:   *aState |= nsIAccessibleStates::STATE_READONLY |
    1:              nsIAccessibleStates::STATE_FOCUSABLE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // The value is the first selected child
    1: NS_IMETHODIMP nsXULTreeAccessible::GetValue(nsAString& _retval)
    1: {
    1:   _retval.Truncate(0);
    1: 
    1:   NS_ENSURE_TRUE(mTree && mTreeView, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsITreeSelection> selection;
    1:   mTreeView->GetSelection(getter_AddRefs(selection));
    1:   if (! selection)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   PRInt32 currentIndex;
    1:   nsCOMPtr<nsIDOMElement> selectItem;
    1:   selection->GetCurrentIndex(&currentIndex);
    1:   if (currentIndex >= 0) {
    1:     nsCOMPtr<nsITreeColumn> keyCol;
    1: 
    1:     nsCOMPtr<nsITreeColumns> cols;
    1:     mTree->GetColumns(getter_AddRefs(cols));
    1:     if (cols)
    1:       cols->GetKeyColumn(getter_AddRefs(keyCol));
    1: 
    1:     return mTreeView->GetCellText(currentIndex, keyCol, _retval);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
21169: nsresult
21169: nsXULTreeAccessible::Shutdown()
    1: {
 1631:   mTree = nsnull;
 1631:   mTreeView = nsnull;
 1631: 
    1:   nsXULSelectableAccessible::Shutdown();
    1: 
    1:   if (mAccessNodeCache) {
    1:     ClearCache(*mAccessNodeCache);
    1:     delete mAccessNodeCache;
    1:     mAccessNodeCache = nsnull;
    1:   }
 1631: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULTreeAccessible::GetRole(PRUint32 *aRole)
    1: {
    1:   NS_ASSERTION(mTree, "No tree view");
    1:   PRInt32 colCount = 0;
    1:   if (NS_SUCCEEDED(GetColumnCount(mTree, &colCount)) && (colCount > 1))
    1:     *aRole = nsIAccessibleRole::ROLE_TREE_TABLE;
    1:   else
    1:     *aRole = nsIAccessibleRole::ROLE_OUTLINE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULTreeAccessible::GetFirstChild(nsIAccessible **aFirstChild)
    1: {
    1:   nsAccessible::GetFirstChild(aFirstChild);
    1: 
    1:   // in normal case, tree's first child should be treecols, if it is not here, 
    1:   //   use the first row as tree's first child
    1:   if (*aFirstChild == nsnull) {
    1:     NS_ENSURE_TRUE(mTree && mTreeView, NS_ERROR_FAILURE);
    1: 
    1:     PRInt32 rowCount;
    1:     mTreeView->GetRowCount(&rowCount);
    1:     if (rowCount > 0) {
    1:       nsCOMPtr<nsITreeColumn> column = GetFirstVisibleColumn(mTree);
    1:       return GetCachedTreeitemAccessible(0, column, aFirstChild);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULTreeAccessible::GetLastChild(nsIAccessible **aLastChild)
    1: {
    1:   NS_ENSURE_TRUE(mTree && mTreeView, NS_ERROR_FAILURE);
    1: 
    1:   PRInt32 rowCount;
    1:   mTreeView->GetRowCount(&rowCount);
    1:   if (rowCount > 0) {
    1:     nsCOMPtr<nsITreeColumn> column = GetLastVisibleColumn(mTree);
    1:     return GetCachedTreeitemAccessible(rowCount - 1, column, aLastChild);
    1:   }
    1:   else // if there is not any rows, use treecols as tree's last child
    1:     nsAccessible::GetLastChild(aLastChild);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // tree's children count is row count + treecols count
    1: NS_IMETHODIMP nsXULTreeAccessible::GetChildCount(PRInt32 *aAccChildCount)
    1: {
    1:   NS_ENSURE_TRUE(mTree && mTreeView, NS_ERROR_FAILURE);
    1: 
    1:   nsAccessible::GetChildCount(aAccChildCount);
    1: 
    1:   if (*aAccChildCount != eChildCountUninitialized) {
    1:     PRInt32 rowCount;
    1:     mTreeView->GetRowCount(&rowCount);
    1:     *aAccChildCount += rowCount;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULTreeAccessible::GetFocusedChild(nsIAccessible **aFocusedChild) 
    1: {
    1:   nsCOMPtr<nsIDOMXULMultiSelectControlElement> multiSelect =
    1:     do_QueryInterface(mDOMNode);
    1:   if (multiSelect) {
    1:     PRInt32 row;
    1:     multiSelect->GetCurrentIndex(&row);
    1:     if (row >= 0) {
    1:       GetCachedTreeitemAccessible(row, nsnull, aFocusedChild);
    1:       if (*aFocusedChild) {
    1:         return NS_OK;  // Already addref'd by getter
    1:       }
    1:     }
    1:   }
    1:   NS_ADDREF(*aFocusedChild = this);
    1:   return NS_OK;
    1: }
    1: 
25749: // nsIAccessible::getDeepestChildAtPoint(in long x, in long y)
 5680: NS_IMETHODIMP
25749: nsXULTreeAccessible::GetDeepestChildAtPoint(PRInt32 aX, PRInt32 aY,
 5680:                                             nsIAccessible **aAccessible)
 5680: {
 5680:   nsIFrame *frame = GetFrame();
 5680:   if (!frame)
 5680:     return NS_ERROR_FAILURE;
 5680: 
 5680:   nsPresContext *presContext = frame->PresContext();
 5680:   nsCOMPtr<nsIPresShell> presShell = presContext->PresShell();
 5680: 
 5680:   nsIFrame *rootFrame = presShell->GetRootFrame();
 5680:   NS_ENSURE_STATE(rootFrame);
 5680: 
 5680:   nsIntRect rootRect = rootFrame->GetScreenRectExternal();
 5680: 
 5680:   PRInt32 clientX = presContext->AppUnitsToIntCSSPixels(
 5680:     presContext->DevPixelsToAppUnits(aX - rootRect.x));
 5680:   PRInt32 clientY = presContext->AppUnitsToIntCSSPixels(
 5680:     presContext->DevPixelsToAppUnits(aY - rootRect.y));
 5680: 
 5680:   PRInt32 row = -1;
 5680:   nsCOMPtr<nsITreeColumn> column;
 5680:   nsCAutoString childEltUnused;
 5680:   mTree->GetCellAt(clientX, clientY, &row, getter_AddRefs(column),
 5680:                    childEltUnused);
 5680: 
 5680:   // If we failed to find tree cell for the given point then it might be
 5680:   // tree columns.
 5680:   if (row == -1 || !column)
25749:     return nsXULSelectableAccessible::
25749:       GetDeepestChildAtPoint(aX, aY, aAccessible);
 5680: 
 5680:   return GetCachedTreeitemAccessible(row, column, aAccessible);
 5680: }
 5680: 
    1: // Ask treeselection to get all selected children
    1: NS_IMETHODIMP nsXULTreeAccessible::GetSelectedChildren(nsIArray **_retval)
    1: {
    1:   *_retval = nsnull;
    1: 
    1:   NS_ENSURE_TRUE(mTree && mTreeView, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsITreeSelection> selection;
    1:   mTreeView->GetSelection(getter_AddRefs(selection));
    1:   if (!selection)
    1:     return NS_ERROR_FAILURE;
    1:   nsCOMPtr<nsIMutableArray> selectedAccessibles =
    1:     do_CreateInstance(NS_ARRAY_CONTRACTID);
    1:   NS_ENSURE_STATE(selectedAccessibles);
    1: 
    1:   PRInt32 rowIndex, rowCount;
    1:   PRBool isSelected;
    1:   mTreeView->GetRowCount(&rowCount);
    1:   for (rowIndex = 0; rowIndex < rowCount; rowIndex++) {
    1:     selection->IsSelected(rowIndex, &isSelected);
    1:     if (isSelected) {
    1:       nsCOMPtr<nsIAccessible> tempAccess;
    1:       if (NS_FAILED(GetCachedTreeitemAccessible(rowIndex, nsnull, getter_AddRefs(tempAccess))) || !tempAccess)
    1: 
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:       selectedAccessibles->AppendElement(tempAccess, PR_FALSE);
    1:     }
    1:   }
    1: 
    1:   PRUint32 length;
    1:   selectedAccessibles->GetLength(&length);
    1:   if (length != 0) {
    1:     *_retval = selectedAccessibles;
    1:     NS_IF_ADDREF(*_retval);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULTreeAccessible::GetSelectionCount(PRInt32 *aSelectionCount)
    1: {
    1:   *aSelectionCount = 0;
    1: 
    1:   NS_ENSURE_TRUE(mTree && mTreeView, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsITreeSelection> selection;
    1:   mTreeView->GetSelection(getter_AddRefs(selection));
    1:   if (selection)
    1:     selection->GetCount(aSelectionCount);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULTreeAccessible::ChangeSelection(PRInt32 aIndex, PRUint8 aMethod, PRBool *aSelState)
    1: {
    1:   NS_ENSURE_TRUE(mTree && mTreeView, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsITreeSelection> selection;
    1:   mTreeView->GetSelection(getter_AddRefs(selection));
    1:   if (selection) {
    1:     selection->IsSelected(aIndex, aSelState);
    1:     if ((!(*aSelState) && eSelection_Add == aMethod) || 
    1:         ((*aSelState) && eSelection_Remove == aMethod))
    1:       return selection->ToggleSelect(aIndex);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULTreeAccessible::AddChildToSelection(PRInt32 aIndex)
    1: {
    1:   PRBool isSelected;
    1:   return ChangeSelection(aIndex, eSelection_Add, &isSelected);
    1: }
    1: 
    1: NS_IMETHODIMP nsXULTreeAccessible::RemoveChildFromSelection(PRInt32 aIndex)
    1: {
    1:   PRBool isSelected;
    1:   return ChangeSelection(aIndex, eSelection_Remove, &isSelected);
    1: }
    1: 
    1: NS_IMETHODIMP nsXULTreeAccessible::IsChildSelected(PRInt32 aIndex, PRBool *_retval)
    1: {
    1:   return ChangeSelection(aIndex, eSelection_GetState, _retval);
    1: }
    1: 
    1: NS_IMETHODIMP nsXULTreeAccessible::ClearSelection()
    1: {
    1:   NS_ENSURE_TRUE(mTree && mTreeView, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsITreeSelection> selection;
    1:   mTreeView->GetSelection(getter_AddRefs(selection));
    1:   if (selection)
    1:     selection->ClearSelection();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULTreeAccessible::RefSelection(PRInt32 aIndex, nsIAccessible **_retval)
    1: {
    1:   *_retval = nsnull;
    1: 
    1:   NS_ENSURE_TRUE(mTree && mTreeView, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsITreeSelection> selection;
    1:   mTreeView->GetSelection(getter_AddRefs(selection));
    1:   if (!selection)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   PRInt32 rowIndex, rowCount;
    1:   PRInt32 selCount = 0;
    1:   PRBool isSelected;
    1:   mTreeView->GetRowCount(&rowCount);
    1:   for (rowIndex = 0; rowIndex < rowCount; rowIndex++) {
    1:     selection->IsSelected(rowIndex, &isSelected);
    1:     if (isSelected) {
    1:       if (selCount == aIndex) {
    1:         return GetCachedTreeitemAccessible(rowIndex, nsnull, _retval);
    1:       }
    1:       selCount++;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULTreeAccessible::SelectAllSelection(PRBool *_retval)
    1: {
    1:   *_retval = PR_FALSE;
    1: 
    1:   NS_ENSURE_TRUE(mTree && mTreeView, NS_ERROR_FAILURE);
    1: 
    1:   // see if we are multiple select if so set ourselves as such
    1:   nsCOMPtr<nsIDOMElement> element (do_QueryInterface(mDOMNode));
    1:   if (element) {
    1:     nsAutoString selType;
    1:     element->GetAttribute(NS_LITERAL_STRING("seltype"), selType);
    1:     if (selType.IsEmpty() || !selType.EqualsLiteral("single")) {
    1:       *_retval = PR_TRUE;
    1:       nsCOMPtr<nsITreeSelection> selection;
    1:       mTreeView->GetSelection(getter_AddRefs(selection));
    1:       if (selection)
    1:         selection->SelectAll();
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
 8868: // nsIAccessible nsIAccessibleTreeCache::
 8868: //   GetCachedTreeitemAccessible(in long aRow, nsITreeColumn* aColumn)
 6087: NS_IMETHODIMP
 6087: nsXULTreeAccessible::GetCachedTreeitemAccessible(PRInt32 aRow,
 6087:                                                  nsITreeColumn* aColumn,
 6087:                                                  nsIAccessible** aAccessible)
    1: {
 6087:   NS_ENSURE_ARG_POINTER(aAccessible);
    1:   *aAccessible = nsnull;
    1: 
    1:   NS_ASSERTION(mAccessNodeCache, "No accessibility cache for tree");
    1:   NS_ASSERTION(mTree && mTreeView, "Can't get mTree or mTreeView!\n");
    1: 
    1:   nsCOMPtr<nsITreeColumn> col;
    1: #ifdef MOZ_ACCESSIBILITY_ATK
    1:   col = aColumn;
    1: #endif
    1:   PRInt32 columnIndex = -1;
    1: 
    1:   if (!col && mTree) {
    1:     nsCOMPtr<nsITreeColumns> cols;
    1:     mTree->GetColumns(getter_AddRefs(cols));
    1:     if (cols)
    1:       cols->GetKeyColumn(getter_AddRefs(col));
    1:   }
    1: 
 6087:   // Do not create accessible for treeitem if there is no column in the tree
 6087:   // because it doesn't render treeitems properly.
 6087:   if (!col)
 6087:     return NS_OK;
 6087: 
    1:   col->GetIndex(&columnIndex);
    1: 
    1:   nsCOMPtr<nsIAccessNode> accessNode;
    1:   GetCacheEntry(*mAccessNodeCache, (void*)(aRow * kMaxTreeColumns + columnIndex), getter_AddRefs(accessNode));
    1:   if (!accessNode)
    1:   {
21169:     nsXULTreeitemAccessibleWrap* treeItemAcc =
21169:       new nsXULTreeitemAccessibleWrap(this, mDOMNode, mWeakShell, aRow, col);
21169:     NS_ENSURE_TRUE(treeItemAcc, NS_ERROR_OUT_OF_MEMORY);
21169: 
21169:     nsresult rv = treeItemAcc->Init();
    1:     NS_ENSURE_SUCCESS(rv, rv);
21169: 
21169:     accessNode = treeItemAcc;
    1:     PutCacheEntry(*mAccessNodeCache, (void*)(aRow * kMaxTreeColumns + columnIndex), accessNode);
    1:   }
    1:   nsCOMPtr<nsIAccessible> accessible(do_QueryInterface(accessNode));
    1:   NS_IF_ADDREF(*aAccessible = accessible);
    1:   return NS_OK;
    1: }
    1: 
 8868: // void nsIAccessibleTreeCache::
 8868: //   invalidateCache(in PRInt32 aRow, in PRInt32 aCount)
 8868: NS_IMETHODIMP
 8868: nsXULTreeAccessible::InvalidateCache(PRInt32 aRow, PRInt32 aCount)
 8868: {
 8868:   // Do not invalidate the cache if rows have been inserted.
 8868:   if (aCount > 0)
 8868:     return NS_OK;
 8868: 
10409:   NS_ENSURE_TRUE(mTree && mTreeView, NS_ERROR_FAILURE);
10409: 
 8868:   nsCOMPtr<nsITreeColumns> cols;
 8868:   nsresult rv = mTree->GetColumns(getter_AddRefs(cols));
10409:   NS_ENSURE_STATE(cols);
 8868: 
 8868: #ifdef MOZ_ACCESSIBILITY_ATK
 8868:   PRInt32 colsCount = 0;
 8868:   rv = cols->GetCount(&colsCount);
 8868:   NS_ENSURE_SUCCESS(rv, rv);
 8868: #else
 8868:   nsCOMPtr<nsITreeColumn> col;
 8868:   rv = cols->GetKeyColumn(getter_AddRefs(col));
 8868:   NS_ENSURE_SUCCESS(rv, rv);
 8868: 
 8868:   PRInt32 colIdx = 0;
 8868:   rv = col->GetIndex(&colIdx);
 8868:   NS_ENSURE_SUCCESS(rv, rv);
 8868: #endif
 8868: 
 8868:   for (PRInt32 rowIdx = aRow; rowIdx < aRow - aCount; rowIdx++) {
 8868: #ifdef MOZ_ACCESSIBILITY_ATK
 8868:     for (PRInt32 colIdx = 0; colIdx < colsCount; ++colIdx) {
 8868: #else
 8868:     {
 8868: #endif
 8868: 
 8868:       void *key = reinterpret_cast<void*>(rowIdx * kMaxTreeColumns + colIdx);
 8868: 
 8868:       nsCOMPtr<nsIAccessNode> accessNode;
 8868:       GetCacheEntry(*mAccessNodeCache, key, getter_AddRefs(accessNode));
 8868: 
 8868:       if (accessNode) {
 8868:         nsCOMPtr<nsIAccessible> accessible(do_QueryInterface(accessNode));
 8868:         nsCOMPtr<nsIAccessibleEvent> event =
 8868:           new nsAccEvent(nsIAccessibleEvent::EVENT_DOM_DESTROY,
10375:                          accessible, PR_FALSE);
 8868:         FireAccessibleEvent(event);
 8868: 
 8868:         mAccessNodeCache->Remove(key);
 8868:       }
 8868:     }
 8868:   }
 8868: 
 8868:   PRInt32 newRowCount = 0;
 8868:   rv = mTreeView->GetRowCount(&newRowCount);
 8868:   NS_ENSURE_SUCCESS(rv, rv);
 8868: 
 8868:   PRInt32 oldRowCount = newRowCount - aCount;
 8868: 
 8868:   for (PRInt32 rowIdx = newRowCount; rowIdx < oldRowCount; ++rowIdx) {
 8868: #ifdef MOZ_ACCESSIBILITY_ATK
 8868:     for (PRInt32 colIdx = 0; colIdx < colsCount; ++colIdx) {
 8868: #else
 8868:     {
 8868: #endif
 8868:       void *key = reinterpret_cast<void*>(rowIdx * kMaxTreeColumns + colIdx);
 8868:       mAccessNodeCache->Remove(key);
 8868:     }
 8868:   }
 8868: 
 8868:   return NS_OK;
 8868: }
 8868: 
11389: // void nsIAccessibleTreeCache::
11389: //   treeViewInvalidated(in long aStartRow, in long aEndRow,
11389: //                       in long aStartCol, in long aEndCol);
11389: NS_IMETHODIMP
11389: nsXULTreeAccessible::TreeViewInvalidated(PRInt32 aStartRow, PRInt32 aEndRow,
11389:                                          PRInt32 aStartCol, PRInt32 aEndCol)
11389: {
11389:   NS_ENSURE_TRUE(mTree && mTreeView, NS_ERROR_FAILURE);
11389: 
15375:   PRInt32 endRow = aEndRow;
11389: 
11389:   nsresult rv;
11389:   if (endRow == -1) {
11389:     PRInt32 rowCount = 0;
11389:     rv = mTreeView->GetRowCount(&rowCount);
11389:     NS_ENSURE_SUCCESS(rv, rv);
11389: 
11389:     endRow = rowCount - 1;
11389:   }
11389: 
11389:   nsCOMPtr<nsITreeColumns> treeColumns;
11389:   mTree->GetColumns(getter_AddRefs(treeColumns));
11389:   NS_ENSURE_STATE(treeColumns);
11389: 
11389: #ifdef MOZ_ACCESSIBILITY_ATK
15375:   PRInt32 endCol = aEndCol;
15375: 
11389:   if (endCol == -1) {
11389:     PRInt32 colCount = 0;
11389:     rv = treeColumns->GetCount(&colCount);
11389:     NS_ENSURE_SUCCESS(rv, rv);
11389: 
11389:     endCol = colCount - 1;
11389:   }
11389: #else
11389:   nsCOMPtr<nsITreeColumn> col;
11389:   rv = treeColumns->GetKeyColumn(getter_AddRefs(col));
11389:   NS_ENSURE_SUCCESS(rv, rv);
11389: 
11389:   PRInt32 colIdx = 0;
11389:   rv = col->GetIndex(&colIdx);
11389:   NS_ENSURE_SUCCESS(rv, rv);
11389: #endif
11389: 
11389:   for (PRInt32 rowIdx = aStartRow; rowIdx <= endRow; ++rowIdx) {
11389: #ifdef MOZ_ACCESSIBILITY_ATK
11395:     for (PRInt32 colIdx = aStartCol; colIdx <= endCol; ++colIdx)
11389: #endif
11389:     {
11389:       void *key = reinterpret_cast<void*>(rowIdx * kMaxTreeColumns + colIdx);
11389: 
11389:       nsCOMPtr<nsIAccessNode> accessNode;
11389:       GetCacheEntry(*mAccessNodeCache, key, getter_AddRefs(accessNode));
11389: 
11389:       if (accessNode) {
11389:         nsCOMPtr<nsIAccessible> acc(do_QueryInterface(accessNode));
11389:         NS_ENSURE_STATE(acc);
11389: 
11389:         nsCOMPtr<nsPIAccessibleTreeItem> treeItemAcc(
11389:           do_QueryInterface(accessNode));
11389:         NS_ENSURE_STATE(treeItemAcc);
11389: 
11389:         nsAutoString name, cachedName;
11389:         rv = acc->GetName(name);
11389:         NS_ENSURE_SUCCESS(rv, rv);
11389: 
11389:         rv = treeItemAcc->GetCachedName(cachedName);
11389:         NS_ENSURE_SUCCESS(rv, rv);
11389: 
11389:         if (name != cachedName) {
20536:           nsAccUtils::FireAccEvent(nsIAccessibleEvent::EVENT_NAME_CHANGE, acc);
11389:           treeItemAcc->SetCachedName(name);
11389:         }
11389:       }
11389:     }
11389:   }
11389: 
11389:   return NS_OK;
11389: }
11389: 
15375: // void nsIAccessibleTreeCache::treeViewChanged();
15375: NS_IMETHODIMP
15375: nsXULTreeAccessible::TreeViewChanged()
15375: {
15375:   if (!mTree)
15375:     return NS_ERROR_FAILURE;
15375: 
15375:   // Fire only notification destroy/create events on accessible tree to lie to
15375:   // AT because it should be expensive to fire destroy events for each tree item
15375:   // in cache.
15375:   nsCOMPtr<nsIAccessibleEvent> eventDestroy =
15375:     new nsAccEvent(nsIAccessibleEvent::EVENT_DOM_DESTROY,
15375:                    this, PR_FALSE);
15375:   NS_ENSURE_TRUE(eventDestroy, NS_ERROR_OUT_OF_MEMORY);
15375: 
15375:   nsresult rv = FirePlatformEvent(eventDestroy);
15375: 
15375:   ClearCache(*mAccessNodeCache);
15375: 
15375:   mTree->GetView(getter_AddRefs(mTreeView));
15375: 
15375:   NS_ENSURE_SUCCESS(rv, rv);
15375: 
15375:   nsCOMPtr<nsIAccessibleEvent> eventCreate =
15375:     new nsAccEvent(nsIAccessibleEvent::EVENT_DOM_CREATE,
15375:                    this, PR_FALSE);
15375:   NS_ENSURE_TRUE(eventCreate, NS_ERROR_OUT_OF_MEMORY);
15375: 
15375:   return FirePlatformEvent(eventCreate);
15375: }
15375: 
    1: nsresult nsXULTreeAccessible::GetColumnCount(nsITreeBoxObject* aBoxObject, PRInt32* aCount)
    1: {
    1:   NS_ENSURE_TRUE(aBoxObject, NS_ERROR_FAILURE);
    1:   nsCOMPtr<nsITreeColumns> treeColumns;
    1:   aBoxObject->GetColumns(getter_AddRefs(treeColumns));
    1:   NS_ENSURE_TRUE(treeColumns, NS_ERROR_FAILURE);
    1:   return treeColumns->GetCount(aCount);
    1: }
    1: 
15375: ////////////////////////////////////////////////////////////////////////////////
15375: // nsXULTreeitemAccessible
    1: 
    1: nsXULTreeitemAccessible::nsXULTreeitemAccessible(nsIAccessible *aParent, nsIDOMNode *aDOMNode, nsIWeakReference *aShell, PRInt32 aRow, nsITreeColumn* aColumn)
    1:   : nsLeafAccessible(aDOMNode, aShell)
    1: {
    1:   mParent = aParent;  // xxx todo: do we need this? We already have mParent on nsAccessible
    1: 
    1:   nsXULTreeAccessible::GetTreeBoxObject(aDOMNode, getter_AddRefs(mTree));
    1:   if (mTree)
    1:     mTree->GetView(getter_AddRefs(mTreeView));
    1:   NS_ASSERTION(mTree && mTreeView, "Can't get mTree or mTreeView!\n");
    1: 
    1:   // Since the real tree item does not correspond to any DOMNode, use the row index to distinguish each item
    1:   mRow = aRow;
    1:   mColumn = aColumn;
    1: 
    1:   if (!mColumn && mTree) {
    1:     nsCOMPtr<nsITreeColumns> cols;
    1:     mTree->GetColumns(getter_AddRefs(cols));
    1:     if (cols)
    1:       cols->GetKeyColumn(getter_AddRefs(mColumn));
    1:   }
    1: }
    1: 
11389: NS_IMPL_ISUPPORTS_INHERITED1(nsXULTreeitemAccessible, nsLeafAccessible,
11396:                              nsPIAccessibleTreeItem)
    1: 
21169: nsresult
21169: nsXULTreeitemAccessible::Shutdown()
    1: {
    1:   mTree = nsnull;
    1:   mTreeView = nsnull;
    1:   mColumn = nsnull;
    1:   return nsLeafAccessible::Shutdown();
    1: }
    1: 
18347: NS_IMETHODIMP
18347: nsXULTreeitemAccessible::GetName(nsAString& aName)
    1: {
20246:   // XXX: we should take into account ARIA usage for content tree. 
18347:   aName.Truncate();
18347: 
 9622:   if (IsDefunct())
 9378:     return NS_ERROR_FAILURE;
 9378: 
    1:   mTreeView->GetCellText(mRow, mColumn, aName);
    1:   
 7756:   // If there is still no name try the cell value:
 7756:   // This is for graphical cells. We need tree/table view implementors to implement
 7756:   // FooView::GetCellValue to return a meaningful string for cases where there is
 7756:   // something shown in the cell (non-text) such as a star icon; in which case
 7756:   // GetCellValue for that cell would return "starred" or "flagged" for example.
    1:   if (aName.IsEmpty()) {
    1:     mTreeView->GetCellValue(mRow, mColumn, aName);
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULTreeitemAccessible::GetUniqueID(void **aUniqueID)
    1: {
    1:   // Since mDOMNode is same for all tree item, use |this| pointer as the unique Id
 3233:   *aUniqueID = static_cast<void*>(this);
    1:   return NS_OK;
    1: }
    1: 
21169: // nsAccessNode::Init()
21169: nsresult
11389: nsXULTreeitemAccessible::Init()
11389: {
11389:   nsresult rv = nsLeafAccessible::Init();
11389:   NS_ENSURE_SUCCESS(rv, rv);
11389: 
11389:   return GetName(mCachedName);
11389: }
11389: 
    1: NS_IMETHODIMP nsXULTreeitemAccessible::GetRole(PRUint32 *aRole)
    1: {
    1:   PRInt32 colCount = 0;
    1:   if (NS_SUCCEEDED(nsXULTreeAccessible::GetColumnCount(mTree, &colCount)) && colCount > 1)
    1:     *aRole = nsIAccessibleRole::ROLE_CELL;
    1:   else
    1:     *aRole = nsIAccessibleRole::ROLE_OUTLINEITEM;
    1:   return NS_OK;
    1: }
    1: 
 1157: // Possible states: focused, focusable, selected, checkable, checked, 
 1157: // expanded/collapsed, invisible
21256: nsresult
21256: nsXULTreeitemAccessible::GetStateInternal(PRUint32 *aState,
21256:                                           PRUint32 *aExtraState)
    1: {
  262:   NS_ENSURE_ARG_POINTER(aState);
  262: 
  262:   *aState = 0;
  262:   if (aExtraState)
  262:     *aExtraState = 0;
  262: 
 9622:   if (IsDefunct()) {
 9111:     if (aExtraState)
 9111:       *aExtraState = nsIAccessibleStates::EXT_STATE_DEFUNCT;
21984:     return NS_OK_DEFUNCT_OBJECT;
 9111:   }
 9111: 
  262:   *aState = nsIAccessibleStates::STATE_FOCUSABLE |
    1:             nsIAccessibleStates::STATE_SELECTABLE;
    1: 
    1:   // get expanded/collapsed state
 5694:   if (IsExpandable()) {
 5694:     PRBool isContainerOpen;
    1:     mTreeView->IsContainerOpen(mRow, &isContainerOpen);
 1631:     *aState |= isContainerOpen? PRUint32(nsIAccessibleStates::STATE_EXPANDED):
 1631:                                 PRUint32(nsIAccessibleStates::STATE_COLLAPSED);
    1:   }
    1: 
    1:   // get selected state
    1:   nsCOMPtr<nsITreeSelection> selection;
    1:   mTreeView->GetSelection(getter_AddRefs(selection));
    1:   if (selection) {
    1:     PRBool isSelected;
    1:     selection->IsSelected(mRow, &isSelected);
    1:     if (isSelected)
  262:       *aState |= nsIAccessibleStates::STATE_SELECTED;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMXULMultiSelectControlElement> multiSelect =
    1:     do_QueryInterface(mDOMNode);
    1:   if (multiSelect) {
    1:     PRInt32 currentIndex;
    1:     multiSelect->GetCurrentIndex(&currentIndex);
    1:     if (currentIndex == mRow) {
  262:       *aState |= nsIAccessibleStates::STATE_FOCUSED;
    1:     }
    1:   }
    1: 
    1:   PRInt32 firstVisibleRow, lastVisibleRow;
    1:   mTree->GetFirstVisibleRow(&firstVisibleRow);
    1:   mTree->GetLastVisibleRow(&lastVisibleRow);
    1:   if (mRow < firstVisibleRow || mRow > lastVisibleRow)
  262:     *aState |= nsIAccessibleStates::STATE_INVISIBLE;
    1: 
 1157: 
 1157:   PRInt16 type;
 1157:   mColumn->GetType(&type);
 1157:   if (type == nsITreeColumn::TYPE_CHECKBOX) {
 1157:     *aState |= nsIAccessibleStates::STATE_CHECKABLE;
 1157:     nsAutoString checked;
 1157:     mTreeView->GetCellValue(mRow, mColumn, checked);
 1157:     if (checked.EqualsIgnoreCase("true")) {
 1157:       *aState |= nsIAccessibleStates::STATE_CHECKED;
 1157:     }
 1157:   }
 1157: 
    1:   return NS_OK;
    1: }
    1: 
 9622: PRBool
 9622: nsXULTreeitemAccessible::IsDefunct()
 9622: {
 9622:   if (!mTree || !mTreeView || !mColumn || mRow < 0)
 9622:     return PR_TRUE;
 9622: 
 9622:   PRInt32 rowCount = 0;
 9622:   nsresult rv = mTreeView->GetRowCount(&rowCount);
 9622:   return NS_FAILED(rv) || mRow >= rowCount;
 9622: }
 9622: 
 5694: PRBool nsXULTreeitemAccessible::IsExpandable()
 5694: {
 9622:   if (IsDefunct())
11916:     return PR_FALSE;
 9622: 
 5694:   PRBool isContainer;
 5694:   mTreeView->IsContainer(mRow, &isContainer);
 5694:   if (isContainer) {
 5694:     PRBool isEmpty; 
 5694:     mTreeView->IsContainerEmpty(mRow, &isEmpty);
 5694:     if (!isEmpty) {
 5694:       PRBool isPrimary;
 5694:       mColumn->GetPrimary(&isPrimary);
 5694:       if (isPrimary) {
 5694:         return PR_TRUE;
 5694:       }
 5694:     }
 5694:   }
 5694:   return PR_FALSE;
 5694: }
 5694: 
    1: // "activate" (xor "cycle") action is available for all treeitems
    1: // "expand/collapse" action is avaible for treeitem which is container
 5694: NS_IMETHODIMP nsXULTreeitemAccessible::GetNumActions(PRUint8 *aNumActions)
    1: {
 9622:   NS_ENSURE_ARG_POINTER(aNumActions);
 9622:   *aNumActions = 0;
 9622: 
 9622:   if (IsDefunct())
 9622:     return NS_ERROR_FAILURE;
 9622: 
 5694:   *aNumActions = IsExpandable() ? 2 : 1;
    1:   return NS_OK;
    1: }
    1: 
    1: // Return the name of our actions
    1: NS_IMETHODIMP nsXULTreeitemAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
    1: {
 9622:   if (IsDefunct())
 9622:     return NS_ERROR_FAILURE;
    1: 
    1:   if (aIndex == eAction_Click) {
    1:     PRBool isCycler;
    1:     mColumn->GetCycler(&isCycler);
    1:     if (isCycler) {
    1:       aName.AssignLiteral("cycle");
    1:     }
    1:     else {
    1:       aName.AssignLiteral("activate");
    1:     }
    1:     return NS_OK;
    1:   }
 5694:   else if (aIndex == eAction_Expand && IsExpandable()) {
 5694:     PRBool isContainerOpen;
    1:     mTreeView->IsContainerOpen(mRow, &isContainerOpen);
    1:     if (isContainerOpen)
    1:       aName.AssignLiteral("collapse");
    1:     else
    1:       aName.AssignLiteral("expand");
    1:     return NS_OK;
    1:   }
    1: 
    1:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
  401: nsresult
  401: nsXULTreeitemAccessible::GetAttributesInternal(nsIPersistentProperties *aAttributes)
  144: {
  144:   NS_ENSURE_ARG_POINTER(aAttributes);
 9622: 
 9622:   if (IsDefunct())
 9622:     return NS_ERROR_FAILURE;
  144: 
  401:   nsresult rv = nsLeafAccessible::GetAttributesInternal(aAttributes);
  144:   NS_ENSURE_SUCCESS(rv, rv);
  144: 
  144:   nsCOMPtr<nsIDOMXULTreeElement> tree(do_QueryInterface(mDOMNode));
  144:   NS_ENSURE_TRUE(tree, NS_OK);
  144: 
  144:   nsCOMPtr<nsITreeView> view;
  144:   tree->GetView(getter_AddRefs(view));
  144:   NS_ENSURE_TRUE(view, NS_OK);
  144: 
  144:   PRInt32 level;
  144:   rv = view->GetLevel(mRow, &level);
  144:   NS_ENSURE_SUCCESS(rv, rv);
  144: 
 5189:   PRInt32 topCount = 1;
 5189:   for (PRInt32 index = mRow - 1; index >= 0; index--) {
  144:     PRInt32 lvl = -1;
 5189:     if (NS_SUCCEEDED(view->GetLevel(index, &lvl))) {
 5189:       if (lvl < level)
 5189:         break;
  144: 
 5189:       if (lvl == level)
 5189:         topCount++;
 5189:     }
 5189:   }
  144: 
 5189:   PRInt32 rowCount = 0;
 5189:   rv = view->GetRowCount(&rowCount);
 5189:   NS_ENSURE_SUCCESS(rv, rv);
 5189: 
 5189:   PRInt32 bottomCount = 0;
 5189:   for (PRInt32 index = mRow + 1; index < rowCount; index++) {
 5189:     PRInt32 lvl = -1;
 5189:     if (NS_SUCCEEDED(view->GetLevel(index, &lvl))) {
 5189:       if (lvl < level)
 5189:         break;
 5189: 
 5189:       if (lvl == level)
 5189:         bottomCount++;
 5189:     }
 5189:   }
 5189: 
 5189:   PRInt32 setSize = topCount + bottomCount;
 5189:   PRInt32 posInSet = topCount;
  144: 
 1157:   // set the group attributes
20536:   nsAccUtils::SetAccGroupAttrs(aAttributes, level + 1, posInSet, setSize);
  144: 
 1157:   // set the "cycles" attribute
 1157:   PRBool isCycler;
 1157:   mColumn->GetCycler(&isCycler);
 1157:   if (isCycler) {
20536:     nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::cycles,
 1157:                            NS_LITERAL_STRING("true"));
 1157:   }
 1157: 
  144:   return NS_OK;
  144: }
  144: 
    1: NS_IMETHODIMP nsXULTreeitemAccessible::GetParent(nsIAccessible **aParent)
    1: {
 9622:   NS_ENSURE_ARG_POINTER(aParent);
    1:   *aParent = nsnull;
    1: 
 9622:   if (IsDefunct())
 9622:     return NS_ERROR_FAILURE;
 9622: 
    1:   if (mParent) {
    1:     *aParent = mParent;
    1:     NS_ADDREF(*aParent);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // Return the next row of tree if mColumn (if any),
    1: // otherwise return the next cell.
    1: NS_IMETHODIMP nsXULTreeitemAccessible::GetNextSibling(nsIAccessible **aNextSibling)
    1: {
 9622:   NS_ENSURE_ARG_POINTER(aNextSibling);
    1:   *aNextSibling = nsnull;
    1: 
 9622:   if (IsDefunct())
 9622:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIAccessibleTreeCache> treeCache(do_QueryInterface(mParent));
    1:   NS_ENSURE_TRUE(treeCache, NS_ERROR_FAILURE);
    1: 
    1:   PRInt32 rowCount;
    1:   mTreeView->GetRowCount(&rowCount);
    1: 
    1:   if (!mColumn) {
    1:     if (mRow < rowCount - 1)
    1:       return treeCache->GetCachedTreeitemAccessible(mRow + 1, nsnull, aNextSibling);
    1:     else
    1:       return NS_OK;
    1:   }
    1: 
    1:   nsresult rv = NS_OK;
    1:   PRInt32 row = mRow;
    1:   nsCOMPtr<nsITreeColumn> column;
    1: #ifdef MOZ_ACCESSIBILITY_ATK
    1:   column = nsXULTreeAccessible::GetNextVisibleColumn(mColumn);
    1: 
    1:   if (!column) {
    1:     if (mRow < rowCount -1) {
    1:       row++;
    1:       column = nsXULTreeAccessible::GetFirstVisibleColumn(mTree);
    1:     } else {
    1:       // the next sibling of the last treeitem is null
    1:       return NS_OK;
    1:     }
    1:   }
    1: #else
    1:   if (++row >= rowCount) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: #endif //MOZ_ACCESSIBILITY_ATK
    1: 
    1:   rv = treeCache->GetCachedTreeitemAccessible(row, column, aNextSibling);
    1:   
    1:   return rv;
    1: }
    1: 
    1: // Return the previous row of tree if mColumn (if any),
    1: // otherwise return the previous cell.
    1: NS_IMETHODIMP nsXULTreeitemAccessible::GetPreviousSibling(nsIAccessible **aPreviousSibling)
    1: {
 9622:   NS_ENSURE_ARG_POINTER(aPreviousSibling);
    1:   *aPreviousSibling = nsnull;
    1: 
 9622:   if (IsDefunct())
 9622:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIAccessibleTreeCache> treeCache(do_QueryInterface(mParent));
    1:   NS_ENSURE_TRUE(treeCache, NS_ERROR_FAILURE);
    1: 
    1:   if (!mColumn && mRow > 0)
    1:     return treeCache->GetCachedTreeitemAccessible(mRow - 1, nsnull, aPreviousSibling);
    1:   
    1:   nsresult rv = NS_OK;
    1: 
    1: 
    1:   PRInt32 row = mRow;
    1:   nsCOMPtr<nsITreeColumn> column;
    1: #ifdef MOZ_ACCESSIBILITY_ATK
    1:   rv = mColumn->GetPrevious(getter_AddRefs(column));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   if (!column && mRow > 0) {
    1:     row--;
    1:     column = nsXULTreeAccessible::GetLastVisibleColumn(mTree);
    1:   }
    1: #else
    1:   if (--row < 0) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: #endif
    1: 
    1:   rv = treeCache->GetCachedTreeitemAccessible(row, column, aPreviousSibling);
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULTreeitemAccessible::DoAction(PRUint8 index)
    1: {
 9622:   if (IsDefunct())
 9622:     return NS_ERROR_FAILURE;
    1: 
    1:   if (index == eAction_Click) {
    1:     nsresult rv = NS_OK;
    1:     PRBool isCycler;
    1:     mColumn->GetCycler(&isCycler);
    1:     if (isCycler) {
    1:       rv = mTreeView->CycleCell(mRow, mColumn);
    1:     } 
    1:     else {
    1:       nsCOMPtr<nsITreeSelection> selection;
    1:       mTreeView->GetSelection(getter_AddRefs(selection));
    1:       if (selection) {
    1:         rv = selection->Select(mRow);
    1:         mTree->EnsureRowIsVisible(mRow);
    1:       }
    1:     }
    1:     return rv;
    1:   }
 5694:   else if (index == eAction_Expand && IsExpandable()) {
    1:     return mTreeView->ToggleOpenState(mRow);
    1:   }
    1: 
    1:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULTreeitemAccessible::GetBounds(PRInt32 *x, PRInt32 *y, PRInt32 *width, PRInt32 *height)
    1: {
 9622:   NS_ENSURE_ARG_POINTER(x);
 9622:   *x = 0;
 9622:   NS_ENSURE_ARG_POINTER(y);
 9622:   *y = 0;
 9622:   NS_ENSURE_ARG_POINTER(width);
 9622:   *width = 0;
 9622:   NS_ENSURE_ARG_POINTER(height);
 9622:   *height = 0;
    1: 
 9622:   if (IsDefunct())
 9622:     return NS_ERROR_FAILURE;
    1: 
    1:   // This Bounds are based on Tree's coord
    1:   mTree->GetCoordsForCellItem(mRow, mColumn, EmptyCString(), x, y, width, height);
    1: 
    1:   // Get treechildren's BoxObject to adjust the Bounds' upper left corner
    1:   // XXXvarga consider using mTree->GetTreeBody()
    1:   nsCOMPtr<nsIBoxObject> boxObject(do_QueryInterface(mTree));
    1:   if (boxObject) {
    1:     nsCOMPtr<nsIDOMElement> boxElement;
    1:     boxObject->GetElement(getter_AddRefs(boxElement));
    1:     nsCOMPtr<nsIDOMNode> boxNode(do_QueryInterface(boxElement));
    1:     if (boxNode) {
    1:       nsCOMPtr<nsIDOMNodeList> childNodes;
    1:       boxNode->GetChildNodes(getter_AddRefs(childNodes));
    1:       if (childNodes) {
    1:         nsAutoString name;
    1:         nsCOMPtr<nsIDOMNode> childNode;
    1:         PRUint32 childCount, childIndex;
    1: 
    1:         childNodes->GetLength(&childCount);
    1:         for (childIndex = 0; childIndex < childCount; childIndex++) {
    1:           childNodes->Item(childIndex, getter_AddRefs(childNode));
    1:           childNode->GetLocalName(name);
    1:           if (name.EqualsLiteral("treechildren")) {
    1:             nsCOMPtr<nsIDOMXULElement> xulElement(do_QueryInterface(childNode));
    1:             if (xulElement) {
    1:               nsCOMPtr<nsIBoxObject> box;
    1:               xulElement->GetBoxObject(getter_AddRefs(box));
    1:               if (box) {
    1:                 PRInt32 myX, myY;
    1:                 box->GetScreenX(&myX);
    1:                 box->GetScreenY(&myY);
    1:                 *x += myX;
    1:                 *y += myY;
    1:               }
    1:             }
    1:             break;
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULTreeitemAccessible::SetSelected(PRBool aSelect)
    1: {
 9622:   if (IsDefunct())
 9622:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsITreeSelection> selection;
    1:   mTreeView->GetSelection(getter_AddRefs(selection));
    1:   if (selection) {
    1:     PRBool isSelected;
    1:     selection->IsSelected(mRow, &isSelected);
    1:     if (isSelected != aSelect)
    1:       selection->ToggleSelect(mRow);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULTreeitemAccessible::TakeFocus()
    1: {
 9622:   if (IsDefunct())
 9622:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsITreeSelection> selection;
    1:   mTreeView->GetSelection(getter_AddRefs(selection));
    1:   if (selection)
    1:     selection->SetCurrentIndex(mRow);
    1: 
    1:   // focus event will be fired here
    1:   return nsAccessible::TakeFocus();
    1: }
    1: 
24822: NS_IMETHODIMP
24822: nsXULTreeitemAccessible::GetRelationByType(PRUint32 aRelationType,
24822:                                            nsIAccessibleRelation **aRelation)
    1: {
24822:   NS_ENSURE_ARG_POINTER(aRelation);
24822:   *aRelation = nsnull;
24822: 
 9622:   if (IsDefunct())
 9622:     return NS_ERROR_FAILURE;
 9622: 
 1628:   if (aRelationType == nsIAccessibleRelation::RELATION_NODE_CHILD_OF) {
    1:     PRInt32 columnIndex;
    1:     if (NS_SUCCEEDED(mColumn->GetIndex(&columnIndex)) && columnIndex == 0) {
    1:       PRInt32 parentIndex;
    1:       if (NS_SUCCEEDED(mTreeView->GetParentIndex(mRow, &parentIndex))) {
24822:         if (parentIndex == -1)
24822:           return nsRelUtils::AddTarget(aRelationType, aRelation, mParent);
24822:   
    1:         nsCOMPtr<nsIAccessibleTreeCache> cache =
    1:           do_QueryInterface(mParent);
24822:         nsCOMPtr<nsIAccessible> accParent;
24822:         nsresult rv = cache->
24822:           GetCachedTreeitemAccessible(parentIndex, mColumn,
24822:                                       getter_AddRefs(accParent));
24822:         NS_ENSURE_SUCCESS(rv, rv);
24822: 
24822:         return nsRelUtils::AddTarget(aRelationType, aRelation, accParent);
    1:       }
    1:     }
24822: 
    1:     return NS_OK;
11438:   }
11438: 
24822:   return nsAccessible::GetRelationByType(aRelationType, aRelation);
    1: }
    1: 
11389: // attribute AString nsIAccessibleTreeItem::cachedName
11389: NS_IMETHODIMP
11389: nsXULTreeitemAccessible::GetCachedName(nsAString &aName)
11389: {
11389:   aName = mCachedName;
11389:   return NS_OK;
11389: }
11389: 
11389: // attribute AString nsIAccessibleTreeItem::cachedName
11389: NS_IMETHODIMP
11389: nsXULTreeitemAccessible::SetCachedName(const nsAString &aName)
11389: {
11389:   mCachedName = aName;
11389:   return NS_OK;
11389: }
11389: 
 6094: ////////////////////////////////////////////////////////////////////////////////
 6094: //  nsXULTreeColumnsAccessible
 6094: nsXULTreeColumnsAccessible::
 6094:   nsXULTreeColumnsAccessible(nsIDOMNode* aDOMNode, nsIWeakReference* aShell):
 6094:   nsXULColumnsAccessible(aDOMNode, aShell)
    1: {
    1: }
    1: 
  262: NS_IMETHODIMP
 6094: nsXULTreeColumnsAccessible::GetNextSibling(nsIAccessible **aNextSibling)
    1: {
13372:   NS_ENSURE_ARG_POINTER(aNextSibling);
13372:   *aNextSibling = nsnull;
    1: 
    1:   nsCOMPtr<nsITreeBoxObject> tree;
    1:   nsCOMPtr<nsITreeView> treeView;
    1: 
    1:   nsXULTreeAccessible::GetTreeBoxObject(mDOMNode, getter_AddRefs(tree));
    1:   if (tree) {
    1:     tree->GetView(getter_AddRefs(treeView));
    1:     if (treeView) {
    1:       PRInt32 rowCount;
    1:       treeView->GetRowCount(&rowCount);
    1:       if (rowCount > 0) {
13372:         nsCOMPtr<nsITreeColumn> column =
13372:           nsXULTreeAccessible::GetFirstVisibleColumn(tree);
13372: 
    1:         nsCOMPtr<nsIAccessibleTreeCache> treeCache(do_QueryInterface(mParent));
    1:         NS_ENSURE_TRUE(treeCache, NS_ERROR_FAILURE);
13372: 
13372:         return treeCache->GetCachedTreeitemAccessible(0, column, aNextSibling);
    1:       }
    1:     }
    1:   }
    1: 
13372:   return NS_OK;
    1: }
    1: 
