     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * the container for the style sheets that apply to a presentation, and
     1:  * the internal API that the style system exposes for creating (and
     1:  * potentially re-creating) style contexts
     1:  */
     1: 
 80467: #include "mozilla/Util.h"
 80467: 
     1: #include "nsStyleSet.h"
     1: #include "nsNetUtil.h"
 42163: #include "nsCSSStyleSheet.h"
129370: #include "nsIDocumentInlines.h"
     1: #include "nsRuleWalker.h"
     1: #include "nsStyleContext.h"
 63693: #include "mozilla/css/StyleRule.h"
     1: #include "nsCSSAnonBoxes.h"
     1: #include "nsCSSPseudoElements.h"
     1: #include "nsCSSRuleProcessor.h"
128826: #include "nsDataHashtable.h"
     1: #include "nsIContent.h"
 77005: #include "nsRuleData.h"
 30988: #include "nsRuleProcessorData.h"
 33649: #include "nsTransitionManager.h"
 67985: #include "nsAnimationManager.h"
 68780: #include "nsEventStates.h"
119108: #include "nsStyleSheetService.h"
 41930: #include "mozilla/dom/Element.h"
114005: #include "sampler.h"
 41643: 
 80467: using namespace mozilla;
 41643: using namespace mozilla::dom;
     1: 
 22737: NS_IMPL_ISUPPORTS1(nsEmptyStyleRule, nsIStyleRule)
 22737: 
 43120: /* virtual */ void
 22737: nsEmptyStyleRule::MapRuleInfoInto(nsRuleData* aRuleData)
 22737: {
 22737: }
 22737: 
 22737: #ifdef DEBUG
 43120: /* virtual */ void
108991: nsEmptyStyleRule::List(FILE* out, int32_t aIndent) const
 22737: {
123667:   for (int32_t index = aIndent; --index >= 0; ) fputs("  ", out);
123693:   fputs("[empty style rule] {}\n", out);
 22737: }
 22737: #endif
 22737: 
 77005: NS_IMPL_ISUPPORTS1(nsInitialStyleRule, nsIStyleRule)
 77005: 
 77005: /* virtual */ void
 77005: nsInitialStyleRule::MapRuleInfoInto(nsRuleData* aRuleData)
 77005: {
 77005:   // Iterate over the property groups
 77005:   for (nsStyleStructID sid = nsStyleStructID(0);
 77005:        sid < nsStyleStructID_Length; sid = nsStyleStructID(sid + 1)) {
 77005:     if (aRuleData->mSIDs & (1 << sid)) {
 77005:       // Iterate over nsCSSValues within the property group
 77005:       nsCSSValue * const value_start =
 77005:         aRuleData->mValueStorage + aRuleData->mValueOffsets[sid];
 77005:       for (nsCSSValue *value = value_start,
 77005:            *value_end = value + nsCSSProps::PropertyCountInStruct(sid);
 77005:            value != value_end; ++value) {
 77005:         // If MathML is disabled take care not to set MathML properties (or we
 77005:         // will trigger assertions in nsRuleNode)
 77005:         if (sid == eStyleStruct_Font &&
 77005:             !aRuleData->mPresContext->Document()->GetMathMLEnabled()) {
 77005:           size_t index = value - value_start;
 77005:           if (index == nsCSSProps::PropertyIndexInStruct(
 77005:                           eCSSProperty_script_level) ||
 77005:               index == nsCSSProps::PropertyIndexInStruct(
 77005:                           eCSSProperty_script_size_multiplier) ||
 77005:               index == nsCSSProps::PropertyIndexInStruct(
 77005:                           eCSSProperty_script_min_size)) {
 77005:             continue;
 77005:           }
 77005:         }
 77005:         if (value->GetUnit() == eCSSUnit_Null) {
 77005:           value->SetInitialValue();
 77005:         }
 77005:       }
 77005:     }
 77005:   }
 77005: }
 77005: 
 77005: #ifdef DEBUG
 77005: /* virtual */ void
108991: nsInitialStyleRule::List(FILE* out, int32_t aIndent) const
 77005: {
123667:   for (int32_t index = aIndent; --index >= 0; ) fputs("  ", out);
123693:   fputs("[initial style rule] {}\n", out);
 77005: }
 77005: #endif
 77005: 
 21924: static const nsStyleSet::sheetType gCSSSheetTypes[] = {
 21924:   nsStyleSet::eAgentSheet,
 21924:   nsStyleSet::eUserSheet,
 21924:   nsStyleSet::eDocSheet,
128825:   nsStyleSet::eScopedDocSheet,
 21924:   nsStyleSet::eOverrideSheet
 21924: };
 21924: 
     1: nsStyleSet::nsStyleSet()
106838:   : mRuleTree(nullptr),
     1:     mBatching(0),
 80486:     mInShutdown(false),
 80486:     mAuthorStyleDisabled(false),
 80486:     mInReconstruct(false),
 96761:     mDirty(0),
 96761:     mUnusedRuleNodeCount(0)
     1: {
     1: }
     1: 
 74692: size_t
 84365: nsStyleSet::SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf) const
 74692: {
 88300:   size_t n = aMallocSizeOf(this);
 74693: 
 74693:   for (int i = 0; i < eSheetTypeCount; i++) {
 74693:     if (mRuleProcessors[i]) {
 84365:       n += mRuleProcessors[i]->SizeOfIncludingThis(aMallocSizeOf);
 74693:     }
132230:     n += mSheets[i].SizeOfExcludingThis(nullptr, aMallocSizeOf);
 74693:   }
 74693: 
132233:   for (uint32_t i = 0; i < mScopedDocSheetRuleProcessors.Length(); i++) {
132230:     n += mScopedDocSheetRuleProcessors[i]->SizeOfIncludingThis(aMallocSizeOf);
132230:   }
132230:   n += mScopedDocSheetRuleProcessors.SizeOfExcludingThis(aMallocSizeOf);
132230: 
132230:   n += mRoots.SizeOfExcludingThis(aMallocSizeOf);
132230:   n += mOldRuleTrees.SizeOfExcludingThis(aMallocSizeOf);
132230: 
 74693:   return n;
 74692: }
 74692: 
     1: nsresult
     1: nsStyleSet::Init(nsPresContext *aPresContext)
     1: {
 22737:   mFirstLineRule = new nsEmptyStyleRule;
 22737:   mFirstLetterRule = new nsEmptyStyleRule;
121456:   mPlaceholderRule = new nsEmptyStyleRule;
 22737: 
     1:   mRuleTree = nsRuleNode::CreateRootNode(aPresContext);
     1: 
 67985:   GatherRuleProcessors(eAnimationSheet);
 33649:   GatherRuleProcessors(eTransitionSheet);
 33649: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
  3959: nsStyleSet::BeginReconstruct()
  3959: {
 24429:   NS_ASSERTION(!mInReconstruct, "Unmatched begin/end?");
  3959:   NS_ASSERTION(mRuleTree, "Reconstructing before first construction?");
  3959: 
  3959:   // Create a new rule tree root
  3959:   nsRuleNode* newTree =
132811:     nsRuleNode::CreateRootNode(mRuleTree->PresContext());
  3959:   if (!newTree)
  3959:     return NS_ERROR_OUT_OF_MEMORY;
 33399: 
 33399:   // Save the old rule tree so we can destroy it later
 33399:   if (!mOldRuleTrees.AppendElement(mRuleTree)) {
  3959:     newTree->Destroy();
  3959:     return NS_ERROR_OUT_OF_MEMORY;
  3959:   }
  3959: 
 24429:   // We need to keep mRoots so that the rule tree GC will only free the
 24429:   // rule trees that really aren't referenced anymore (which should be
 24429:   // all of them, if there are no bugs in reresolution code).
 24429: 
 80486:   mInReconstruct = true;
  3959:   mRuleTree = newTree;
  3959: 
  3959:   return NS_OK;
  3959: }
  3959: 
  3959: void
  3959: nsStyleSet::EndReconstruct()
  3959: {
 24429:   NS_ASSERTION(mInReconstruct, "Unmatched begin/end?");
 80486:   mInReconstruct = false;
 23831: #ifdef DEBUG
108991:   for (int32_t i = mRoots.Length() - 1; i >= 0; --i) {
132810:     nsRuleNode *n = mRoots[i]->RuleNode();
 23831:     while (n->GetParent()) {
 23831:       n = n->GetParent();
 23831:     }
 23831:     // Since nsStyleContext's mParent and mRuleNode are immutable, and
 23831:     // style contexts own their parents, and nsStyleContext asserts in
 23831:     // its constructor that the style context and its parent are in the
 23831:     // same rule tree, we don't need to check any of the children of
 23831:     // mRoots; we only need to check the rule nodes of mRoots
 23831:     // themselves.
 23831: 
 24429:     NS_ASSERTION(n == mRuleTree, "style context has old rule node");
 23831:   }
 23831: #endif
 24429:   // This *should* destroy the only element of mOldRuleTrees, but in
 24429:   // case of some bugs (which would trigger the above assertions), it
 24429:   // won't.
 24429:   GCRuleTrees();
  3959: }
  3959: 
 21209: void
 21209: nsStyleSet::SetQuirkStyleSheet(nsIStyleSheet* aQuirkStyleSheet)
 21209: {
 21209:   NS_ASSERTION(aQuirkStyleSheet, "Must have quirk sheet if this is called");
 21209:   NS_ASSERTION(!mQuirkStyleSheet, "Multiple calls to SetQuirkStyleSheet?");
 21209:   NS_ASSERTION(mSheets[eAgentSheet].IndexOf(aQuirkStyleSheet) != -1,
 21209:                "Quirk style sheet not one of our agent sheets?");
 21209:   mQuirkStyleSheet = aQuirkStyleSheet;
 21209: }
 21209: 
128826: typedef nsDataHashtable<nsPtrHashKey<nsINode>, uint32_t> ScopeDepthCache;
128826: 
128826: // Returns the depth of a style scope element, with 1 being the depth of
128826: // a style scope element that has no ancestor style scope elements.  The
128826: // depth does not count intervening non-scope elements.
128826: static uint32_t
128826: GetScopeDepth(nsINode* aScopeElement, ScopeDepthCache& aCache)
128826: {
128826:   nsINode* parent = aScopeElement->GetParent();
128826:   if (!parent || !parent->IsElementInStyleScope()) {
128826:     return 1;
128826:   }
128826: 
128826:   uint32_t depth = aCache.Get(aScopeElement);
128826:   if (!depth) {
128826:     for (nsINode* n = parent; n; n = n->GetParent()) {
128826:       if (n->IsScopedStyleRoot()) {
128826:         depth = GetScopeDepth(n, aCache) + 1;
128826:         aCache.Put(aScopeElement, depth);
128826:         break;
128826:       }
128826:     }
128826:   }
128826:   return depth;
128826: }
128826: 
128826: struct ScopedSheetOrder
128826: {
128826:   nsCSSStyleSheet* mSheet;
128826:   uint32_t mDepth;
128826:   uint32_t mOrder;
128826: 
128826:   bool operator==(const ScopedSheetOrder& aRHS) const
128826:   {
128826:     return mDepth == aRHS.mDepth &&
128826:            mOrder == aRHS.mOrder;
128826:   }
128826: 
128826:   bool operator<(const ScopedSheetOrder& aRHS) const
128826:   {
128826:     if (mDepth != aRHS.mDepth) {
128826:       return mDepth < aRHS.mDepth;
128826:     }
128826:     return mOrder < aRHS.mOrder;
128826:   }
128826: };
128826: 
128826: // Sorts aSheets such that style sheets for ancestor scopes come
128826: // before those for descendant scopes, and with sheets for a single
128826: // scope in document order.
128826: static void
128826: SortStyleSheetsByScope(nsTArray<nsCSSStyleSheet*>& aSheets)
128826: {
128826:   uint32_t n = aSheets.Length();
128826:   if (n == 1) {
128826:     return;
128826:   }
128826: 
128826:   ScopeDepthCache cache;
128826:   cache.Init();
128826: 
128826:   nsTArray<ScopedSheetOrder> sheets;
128826:   sheets.SetLength(n);
128826: 
128826:   // For each sheet, record the depth of its scope element and its original
128826:   // document order.
128826:   for (uint32_t i = 0; i < n; i++) {
128826:     sheets[i].mSheet = aSheets[i];
128826:     sheets[i].mDepth = GetScopeDepth(aSheets[i]->GetScopeElement(), cache);
128826:     sheets[i].mOrder = i;
128826:   }
128826: 
128826:   // Sort by depth first, then document order.
128826:   sheets.Sort();
128826: 
128826:   for (uint32_t i = 0; i < n; i++) {
128826:     aSheets[i] = sheets[i].mSheet;
128826:   }
128826: }
128826: 
  3959: nsresult
     1: nsStyleSet::GatherRuleProcessors(sheetType aType)
     1: {
106838:   mRuleProcessors[aType] = nullptr;
128826:   if (aType == eScopedDocSheet) {
129111:     for (uint32_t i = 0; i < mScopedDocSheetRuleProcessors.Length(); i++) {
128827:       nsIStyleRuleProcessor* processor = mScopedDocSheetRuleProcessors[i].get();
128827:       Element* scope =
128827:         static_cast<nsCSSRuleProcessor*>(processor)->GetScopeElement();
128827:       scope->ClearIsScopedStyleRoot();
128827:     }
128826:     mScopedDocSheetRuleProcessors.Clear();
128826:   }
     1:   if (mAuthorStyleDisabled && (aType == eDocSheet || 
128826:                                aType == eScopedDocSheet ||
 60634:                                aType == ePresHintSheet ||
     1:                                aType == eStyleAttrSheet)) {
     1:     //don't regather if this level is disabled
     1:     return NS_OK;
     1:   }
 67985:   if (aType == eAnimationSheet) {
 67985:     // We have no sheet for the animations level; just a rule
 67985:     // processor.  (XXX: We should probably do this for the other
 67985:     // non-CSS levels too!)
 67985:     mRuleProcessors[aType] = PresContext()->AnimationManager();
 67985:     return NS_OK;
 67985:   }
 33649:   if (aType == eTransitionSheet) {
 33649:     // We have no sheet for the transitions level; just a rule
 33649:     // processor.  (XXX: We should probably do this for the other
 33649:     // non-CSS levels too!)
 33649:     mRuleProcessors[aType] = PresContext()->TransitionManager();
 33649:     return NS_OK;
 33649:   }
128826:   if (aType == eScopedDocSheet) {
128826:     // Create a rule processor for each scope.
128826:     uint32_t count = mSheets[eScopedDocSheet].Count();
128826:     if (count) {
128826:       // Gather the scoped style sheets into an array as
128826:       // nsCSSStyleSheets, and mark all of their scope elements
128826:       // as scoped style roots.
128826:       nsTArray<nsCSSStyleSheet*> sheets(count);
129111:       for (uint32_t i = 0; i < count; i++) {
128826:         nsRefPtr<nsCSSStyleSheet> sheet =
128826:           do_QueryObject(mSheets[eScopedDocSheet].ObjectAt(i));
128826:         sheets.AppendElement(sheet);
128826: 
128826:         Element* scope = sheet->GetScopeElement();
128826:         scope->SetIsScopedStyleRoot();
128826:       }
128826: 
128826:       // Sort the scoped style sheets so that those for the same scope are
128826:       // adjacent and that ancestor scopes come before descendent scopes.
128826:       SortStyleSheetsByScope(sheets);
128826: 
128826:       uint32_t start = 0, end;
128826:       do {
128826:         // Find the range of style sheets with the same scope.
128826:         Element* scope = sheets[start]->GetScopeElement();
128826:         end = start + 1;
128826:         while (end < count && sheets[end]->GetScopeElement() == scope) {
128826:           end++;
128826:         }
128826: 
128827:         scope->SetIsScopedStyleRoot();
128827: 
128826:         // Create a rule processor for the scope.
128826:         nsTArray< nsRefPtr<nsCSSStyleSheet> > sheetsForScope;
128826:         sheetsForScope.AppendElements(sheets.Elements() + start, end - start);
128826:         mScopedDocSheetRuleProcessors.AppendElement
128826:           (new nsCSSRuleProcessor(sheetsForScope, uint8_t(aType), scope));
128826: 
128826:         start = end;
128826:       } while (start < count);
128826:     }
128826:     return NS_OK;
128826:   }
     1:   if (mSheets[aType].Count()) {
     1:     switch (aType) {
     1:       case eAgentSheet:
     1:       case eUserSheet:
     1:       case eDocSheet:
     1:       case eOverrideSheet: {
128826:         // levels containing CSS stylesheets (apart from eScopedDocSheet)
     1:         nsCOMArray<nsIStyleSheet>& sheets = mSheets[aType];
 42163:         nsTArray<nsRefPtr<nsCSSStyleSheet> > cssSheets(sheets.Count());
108991:         for (int32_t i = 0, i_end = sheets.Count(); i < i_end; ++i) {
 42163:           nsRefPtr<nsCSSStyleSheet> cssSheet = do_QueryObject(sheets[i]);
     1:           NS_ASSERTION(cssSheet, "not a CSS sheet");
 42163:           cssSheets.AppendElement(cssSheet);
     1:         }
128826:         mRuleProcessors[aType] =
128826:           new nsCSSRuleProcessor(cssSheets, uint8_t(aType), nullptr);
     1:       } break;
     1: 
     1:       default:
     1:         // levels containing non-CSS stylesheets
     1:         NS_ASSERTION(mSheets[aType].Count() == 1, "only one sheet per level");
     1:         mRuleProcessors[aType] = do_QueryInterface(mSheets[aType][0]);
     1:         break;
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
128825: static bool
128825: IsScopedStyleSheet(nsIStyleSheet* aSheet)
128825: {
128825:   nsRefPtr<nsCSSStyleSheet> cssSheet = do_QueryObject(aSheet);
128825:   NS_ASSERTION(cssSheet, "expected aSheet to be an nsCSSStyleSheet");
128825: 
128825:   return cssSheet->GetScopeElement();
128825: }
128825: 
     1: nsresult
     1: nsStyleSet::AppendStyleSheet(sheetType aType, nsIStyleSheet *aSheet)
     1: {
     1:   NS_PRECONDITION(aSheet, "null arg");
 42332:   NS_ASSERTION(aSheet->IsApplicable(),
 42232:                "Inapplicable sheet being placed in style set");
     1:   mSheets[aType].RemoveObject(aSheet);
     1:   if (!mSheets[aType].AppendObject(aSheet))
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:   if (!mBatching)
     1:     return GatherRuleProcessors(aType);
     1: 
     1:   mDirty |= 1 << aType;
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsStyleSet::PrependStyleSheet(sheetType aType, nsIStyleSheet *aSheet)
     1: {
     1:   NS_PRECONDITION(aSheet, "null arg");
 42332:   NS_ASSERTION(aSheet->IsApplicable(),
 42232:                "Inapplicable sheet being placed in style set");
     1:   mSheets[aType].RemoveObject(aSheet);
     1:   if (!mSheets[aType].InsertObjectAt(aSheet, 0))
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:   if (!mBatching)
     1:     return GatherRuleProcessors(aType);
     1: 
     1:   mDirty |= 1 << aType;
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsStyleSet::RemoveStyleSheet(sheetType aType, nsIStyleSheet *aSheet)
     1: {
     1:   NS_PRECONDITION(aSheet, "null arg");
 42332:   NS_ASSERTION(aSheet->IsComplete(),
 42232:                "Incomplete sheet being removed from style set");
     1:   mSheets[aType].RemoveObject(aSheet);
     1:   if (!mBatching)
     1:     return GatherRuleProcessors(aType);
     1: 
     1:   mDirty |= 1 << aType;
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsStyleSet::ReplaceSheets(sheetType aType,
     1:                           const nsCOMArray<nsIStyleSheet> &aNewSheets)
     1: {
     1:   mSheets[aType].Clear();
     1:   if (!mSheets[aType].AppendObjects(aNewSheets))
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:   if (!mBatching)
     1:     return GatherRuleProcessors(aType);
     1: 
     1:   mDirty |= 1 << aType;
     1:   return NS_OK;
     1: }
     1: 
120316: nsresult
120316: nsStyleSet::InsertStyleSheetBefore(sheetType aType, nsIStyleSheet *aNewSheet,
120316:                                    nsIStyleSheet *aReferenceSheet)
120316: {
120316:   NS_PRECONDITION(aNewSheet && aReferenceSheet, "null arg");
120316:   NS_ASSERTION(aNewSheet->IsApplicable(),
120316:                "Inapplicable sheet being placed in style set");
120316: 
120316:   mSheets[aType].RemoveObject(aNewSheet);
120316:   int32_t idx = mSheets[aType].IndexOf(aReferenceSheet);
120316:   if (idx < 0)
120316:     return NS_ERROR_INVALID_ARG;
120316:   
120316:   if (!mSheets[aType].InsertObjectAt(aNewSheet, idx))
120316:     return NS_ERROR_OUT_OF_MEMORY;
120316: 
120316:   if (!mBatching)
120316:     return GatherRuleProcessors(aType);
120316: 
120316:   mDirty |= 1 << aType;
120316:   return NS_OK;
120316: }
120316: 
 79445: bool
     1: nsStyleSet::GetAuthorStyleDisabled()
     1: {
     1:   return mAuthorStyleDisabled;
     1: }
     1: 
     1: nsresult
 79445: nsStyleSet::SetAuthorStyleDisabled(bool aStyleDisabled)
     1: {
     1:   if (aStyleDisabled == !mAuthorStyleDisabled) {
     1:     mAuthorStyleDisabled = aStyleDisabled;
     1:     BeginUpdate();
     1:     mDirty |= 1 << eDocSheet |
 60634:               1 << ePresHintSheet |
     1:               1 << eStyleAttrSheet;
     1:     return EndUpdate();
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: // -------- Doc Sheets
     1: 
     1: nsresult
     1: nsStyleSet::AddDocStyleSheet(nsIStyleSheet* aSheet, nsIDocument* aDocument)
     1: {
     1:   NS_PRECONDITION(aSheet && aDocument, "null arg");
 42332:   NS_ASSERTION(aSheet->IsApplicable(),
 42232:                "Inapplicable sheet being placed in style set");
     1: 
128825:   sheetType type = IsScopedStyleSheet(aSheet) ?
128825:                      eScopedDocSheet :
128825:                      eDocSheet;
128825:   nsCOMArray<nsIStyleSheet>& sheets = mSheets[type];
     1: 
128825:   sheets.RemoveObject(aSheet);
119109:   nsStyleSheetService *sheetService = nsStyleSheetService::GetInstance();
119108: 
     1:   // lowest index first
108991:   int32_t newDocIndex = aDocument->GetIndexOfStyleSheet(aSheet);
119108: 
128825:   int32_t count = sheets.Count();
108991:   int32_t index;
     1:   for (index = 0; index < count; index++) {
128825:     nsIStyleSheet* sheet = sheets.ObjectAt(index);
108991:     int32_t sheetDocIndex = aDocument->GetIndexOfStyleSheet(sheet);
     1:     if (sheetDocIndex > newDocIndex)
     1:       break;
119108: 
119108:     // If the sheet is not owned by the document it can be an author
120316:     // sheet registered at nsStyleSheetService or an additional author
120316:     // sheet on the document, which means the new 
119108:     // doc sheet should end up before it.
119108:     if (sheetDocIndex < 0 &&
120316:         ((sheetService &&
120316:         sheetService->AuthorStyleSheets()->IndexOf(sheet) >= 0) ||
120316:         sheet == aDocument->FirstAdditionalAuthorSheet()))
119108:         break;
     1:   }
128825:   if (!sheets.InsertObjectAt(aSheet, index))
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1:   if (!mBatching)
128825:     return GatherRuleProcessors(type);
     1: 
128825:   mDirty |= 1 << type;
     1:   return NS_OK;
     1: }
     1: 
128825: nsresult
128825: nsStyleSet::RemoveDocStyleSheet(nsIStyleSheet *aSheet)
128825: {
128825:   nsRefPtr<nsCSSStyleSheet> cssSheet = do_QueryObject(aSheet);
128825:   bool isScoped = cssSheet && cssSheet->GetScopeElement();
128825:   return RemoveStyleSheet(isScoped ? eScopedDocSheet : eDocSheet, aSheet);
128825: }
128825: 
     1: // Batching
     1: void
     1: nsStyleSet::BeginUpdate()
     1: {
     1:   ++mBatching;
     1: }
     1: 
     1: nsresult
     1: nsStyleSet::EndUpdate()
     1: {
     1:   NS_ASSERTION(mBatching > 0, "Unbalanced EndUpdate");
     1:   if (--mBatching) {
     1:     // We're not completely done yet.
     1:     return NS_OK;
     1:   }
     1: 
     1:   for (int i = 0; i < eSheetTypeCount; ++i) {
     1:     if (mDirty & (1 << i)) {
     1:       nsresult rv = GatherRuleProcessors(sheetType(i));
     1:       NS_ENSURE_SUCCESS(rv, rv);
     1:     }
     1:   }
     1: 
     1:   mDirty = 0;
     1:   return NS_OK;
     1: }
     1: 
     1: void
 79445: nsStyleSet::EnableQuirkStyleSheet(bool aEnable)
     1: {
 16438: #ifdef DEBUG
 79445:   bool oldEnabled;
 21896:   {
 21896:     nsCOMPtr<nsIDOMCSSStyleSheet> domSheet =
 21896:       do_QueryInterface(mQuirkStyleSheet);
 21896:     domSheet->GetDisabled(&oldEnabled);
 21896:     oldEnabled = !oldEnabled;
 21896:   }
 21896: #endif
 21896:   mQuirkStyleSheet->SetEnabled(aEnable);
 21896: #ifdef DEBUG
 21896:   // This should always be OK, since SetEnabled should call
 21896:   // ClearRuleCascades.
 21896:   // Note that we can hit this codepath multiple times when document.open()
 21896:   // (potentially implied) happens multiple times.
 21896:   if (mRuleProcessors[eAgentSheet] && aEnable != oldEnabled) {
 16438:     static_cast<nsCSSRuleProcessor*>(static_cast<nsIStyleRuleProcessor*>(
 16438:       mRuleProcessors[eAgentSheet]))->AssertQuirksChangeOK();
 16438:   }
 16438: #endif
     1: }
     1: 
 35558: template<class T>
 79445: static bool
     1: EnumRulesMatching(nsIStyleRuleProcessor* aProcessor, void* aData)
     1: {
 35558:   T* data = static_cast<T*>(aData);
     1:   aProcessor->RulesMatching(data);
 80486:   return true;
     1: }
     1: 
 69179: static inline bool
 69179: IsMoreSpecificThanAnimation(nsRuleNode *aRuleNode)
 69179: {
 69179:   return !aRuleNode->IsRoot() &&
 69179:          (aRuleNode->GetLevel() == nsStyleSet::eTransitionSheet ||
110719:           aRuleNode->IsImportantRule());
 69179: }
 69179: 
 69179: static nsIStyleRule*
 69179: GetAnimationRule(nsRuleNode *aRuleNode)
 69179: {
 69179:   nsRuleNode *n = aRuleNode;
 69179:   while (IsMoreSpecificThanAnimation(n)) {
 69179:     n = n->GetParent();
 69179:   }
 69179: 
 69179:   if (n->IsRoot() || n->GetLevel() != nsStyleSet::eAnimationSheet) {
106838:     return nullptr;
 69179:   }
 69179: 
 69179:   return n->GetRule();
 69179: }
 69179: 
 69179: static nsRuleNode*
 69179: ReplaceAnimationRule(nsRuleNode *aOldRuleNode,
 69179:                      nsIStyleRule *aOldAnimRule,
 69179:                      nsIStyleRule *aNewAnimRule)
 69179: {
 69179:   nsTArray<nsRuleNode*> moreSpecificNodes;
 69179: 
 69179:   nsRuleNode *n = aOldRuleNode;
 69179:   while (IsMoreSpecificThanAnimation(n)) {
 69179:     moreSpecificNodes.AppendElement(n);
 69179:     n = n->GetParent();
 69179:   }
 69179: 
 69179:   if (aOldAnimRule) {
 69179:     NS_ABORT_IF_FALSE(n->GetRule() == aOldAnimRule, "wrong rule");
 69179:     NS_ABORT_IF_FALSE(n->GetLevel() == nsStyleSet::eAnimationSheet,
 69179:                       "wrong level");
 69179:     n = n->GetParent();
 69179:   }
 69179: 
 69179:   NS_ABORT_IF_FALSE(!IsMoreSpecificThanAnimation(n) &&
126736:                     (n->IsRoot() ||
126736:                      n->GetLevel() != nsStyleSet::eAnimationSheet),
 69179:                     "wrong level");
 69179: 
 69179:   if (aNewAnimRule) {
 80486:     n = n->Transition(aNewAnimRule, nsStyleSet::eAnimationSheet, false);
 69179:   }
 69179: 
108991:   for (uint32_t i = moreSpecificNodes.Length(); i-- != 0; ) {
 69179:     nsRuleNode *oldNode = moreSpecificNodes[i];
 69179:     n = n->Transition(oldNode->GetRule(), oldNode->GetLevel(),
 69179:                       oldNode->IsImportantRule());
 69179:   }
 69179: 
 69179:   return n;
 69179: }
 69179: 
     1: /**
     1:  * |GetContext| implements sharing of style contexts (not just the data
     1:  * on the rule nodes) between siblings and cousins of the same
     1:  * generation.  (It works for cousins of the same generation since
     1:  * |aParentContext| could itself be a shared context.)
     1:  */
     1: already_AddRefed<nsStyleContext>
 40136: nsStyleSet::GetContext(nsStyleContext* aParentContext,
 33399:                        nsRuleNode* aRuleNode,
 40189:                        // aVisitedRuleNode may be null; if it is null
 40189:                        // it means that we don't need to force creation
 40189:                        // of a StyleIfVisited.  (But if we make one
 40189:                        // because aParentContext has one, then aRuleNode
 40189:                        // should be used.)
 40189:                        nsRuleNode* aVisitedRuleNode,
 35554:                        nsIAtom* aPseudoTag,
 67985:                        nsCSSPseudoElements::Type aPseudoType,
131259:                        Element* aElementForAnimation,
131259:                        uint32_t aFlags)
     1: {
 35554:   NS_PRECONDITION((!aPseudoTag &&
 35554:                    aPseudoType ==
 35554:                      nsCSSPseudoElements::ePseudo_NotPseudoElement) ||
 35554:                   (aPseudoTag &&
 35554:                    nsCSSPseudoElements::GetPseudoType(aPseudoTag) ==
 35554:                      aPseudoType),
 35554:                   "Pseudo mismatch");
 35554: 
 43603:   if (aVisitedRuleNode == aRuleNode) {
 43603:     // No need to force creation of a visited style in this case.
106838:     aVisitedRuleNode = nullptr;
 43603:   }
 43603: 
106838:   // Ensure |aVisitedRuleNode != nullptr| corresponds to the need to
 40189:   // create an if-visited style context, and that in that case, we have
 40189:   // parentIfVisited set correctly.
 40189:   nsStyleContext *parentIfVisited =
106838:     aParentContext ? aParentContext->GetStyleIfVisited() : nullptr;
 40189:   if (parentIfVisited) {
 40189:     if (!aVisitedRuleNode) {
 40189:       aVisitedRuleNode = aRuleNode;
 40189:     }
 40189:   } else {
 40189:     if (aVisitedRuleNode) {
 40189:       parentIfVisited = aParentContext;
 40189:     }
 40189:   }
     1: 
131259:   if (aFlags & eIsLink) {
 40189:     // If this node is a link, we want its visited's style context's
 40189:     // parent to be the regular style context of its parent, because
 40189:     // only the visitedness of the relevant link should influence style.
 40189:     parentIfVisited = aParentContext;
 40189:   }
 40189: 
 40189:   nsRefPtr<nsStyleContext> result;
     1:   if (aParentContext)
 40187:     result = aParentContext->FindChildWithRules(aPseudoTag, aRuleNode,
 40189:                                                 aVisitedRuleNode,
131259:                                                 aFlags & eIsVisitedLink);
     1: 
     1: #ifdef NOISY_DEBUG
     1:   if (result)
     1:     fprintf(stdout, "--- SharedSC %d ---\n", ++gSharedCount);
     1:   else
     1:     fprintf(stdout, "+++ NewSC %d +++\n", ++gNewCount);
     1: #endif
     1: 
     1:   if (!result) {
 35554:     result = NS_NewStyleContext(aParentContext, aPseudoTag, aPseudoType,
133733:                                 aRuleNode, aFlags & eSkipFlexItemStyleFixup);
 40189:     if (!result)
106838:       return nullptr;
 40189:     if (aVisitedRuleNode) {
 40189:       nsRefPtr<nsStyleContext> resultIfVisited =
 40189:         NS_NewStyleContext(parentIfVisited, aPseudoTag, aPseudoType,
133733:                            aVisitedRuleNode,
133733:                            aFlags & eSkipFlexItemStyleFixup);
 40189:       if (!resultIfVisited) {
106838:         return nullptr;
 40189:       }
 41614:       if (!parentIfVisited) {
 41614:         mRoots.AppendElement(resultIfVisited);
 41614:       }
 40497:       resultIfVisited->SetIsStyleIfVisited();
 40189:       result->SetStyleIfVisited(resultIfVisited.forget());
 40191: 
131259:       bool relevantLinkVisited = (aFlags & eIsLink) ?
131259:         (aFlags & eIsVisitedLink) :
131259:         (aParentContext && aParentContext->RelevantLinkVisited());
131259: 
 40191:       if (relevantLinkVisited) {
 40191:         result->AddStyleBit(NS_STYLE_RELEVANT_LINK_VISITED);
 40191:       }
 40189:     }
131259:     if (!aParentContext) {
     1:       mRoots.AppendElement(result);
     1:     }
131259:   }
 35554:   else {
 35554:     NS_ASSERTION(result->GetPseudoType() == aPseudoType, "Unexpected type");
 35554:     NS_ASSERTION(result->GetPseudo() == aPseudoTag, "Unexpected pseudo");
 35554:   }
     1: 
131259:   if (aFlags & eDoAnimation) {
 67985:     // Normally the animation manager has already added the correct
 67985:     // style rule.  However, if the animation-name just changed, it
 67985:     // might have been wrong.  So ask it to double-check based on the
 67985:     // resulting style context.
 69179:     nsIStyleRule *oldAnimRule = GetAnimationRule(aRuleNode);
 67985:     nsIStyleRule *animRule = PresContext()->AnimationManager()->
 67985:       CheckAnimationRule(result, aElementForAnimation);
132810:     NS_ABORT_IF_FALSE(result->RuleNode() == aRuleNode,
 67985:                       "unexpected rule node");
 67985:     NS_ABORT_IF_FALSE(!result->GetStyleIfVisited() == !aVisitedRuleNode,
 67985:                       "unexpected visited rule node");
 67985:     NS_ABORT_IF_FALSE(!aVisitedRuleNode ||
132810:                       result->GetStyleIfVisited()->RuleNode() ==
 67985:                         aVisitedRuleNode,
 67985:                       "unexpected visited rule node");
 69179:     if (oldAnimRule != animRule) {
 69179:       nsRuleNode *ruleNode =
 69179:         ReplaceAnimationRule(aRuleNode, oldAnimRule, animRule);
 69179:       nsRuleNode *visitedRuleNode = aVisitedRuleNode
 69179:         ? ReplaceAnimationRule(aVisitedRuleNode, oldAnimRule, animRule)
106838:         : nullptr;
 67985:       result = GetContext(aParentContext, ruleNode, visitedRuleNode,
131259:                           aPseudoTag, aPseudoType, nullptr,
131259:                           aFlags & ~eDoAnimation);
 67985:     }
 67985:   }
 67985: 
 71160:   if (aElementForAnimation && aElementForAnimation->IsHTML(nsGkAtoms::body) &&
 71160:       aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement &&
 71160:       PresContext()->CompatibilityMode() == eCompatibility_NavQuirks) {
 71160:     nsIDocument* doc = aElementForAnimation->GetCurrentDoc();
 71160:     if (doc && doc->GetBodyElement() == aElementForAnimation) {
 71160:       // Update the prescontext's body color
132812:       PresContext()->SetBodyTextColor(result->StyleColor()->mColor);
 71160:     }
 71160:   }
 71160: 
 40189:   return result.forget();
     1: }
     1: 
     1: void
     1: nsStyleSet::AddImportantRules(nsRuleNode* aCurrLevelNode,
 33399:                               nsRuleNode* aLastPrevLevelNode,
 33399:                               nsRuleWalker* aRuleWalker)
     1: {
 35613:   NS_ASSERTION(aCurrLevelNode &&
 35613:                aCurrLevelNode != aLastPrevLevelNode, "How did we get here?");
     1: 
 35529:   nsAutoTArray<nsIStyleRule*, 16> importantRules;
 15902:   for (nsRuleNode *node = aCurrLevelNode; node != aLastPrevLevelNode;
 15902:        node = node->GetParent()) {
 35529:     // We guarantee that we never walk the root node here, so no need
 70825:     // to null-check GetRule().  Furthermore, it must be a CSS rule.
 70825:     NS_ASSERTION(nsRefPtr<css::StyleRule>(do_QueryObject(node->GetRule())),
 70825:                  "Unexpected non-CSS rule");
 70825: 
 70825:     nsIStyleRule* impRule =
 70825:       static_cast<css::StyleRule*>(node->GetRule())->GetImportantRule();
     1:     if (impRule)
 15902:       importantRules.AppendElement(impRule);
 15902:   }
 35529: 
 35529:   NS_ASSERTION(importantRules.Length() != 0,
 35529:                "Why did we think there were important rules?");
 15902: 
108991:   for (uint32_t i = importantRules.Length(); i-- != 0; ) {
 33399:     aRuleWalker->Forward(importantRules[i]);
     1:   }
     1: }
     1: 
     1: #ifdef DEBUG
     1: void
     1: nsStyleSet::AssertNoImportantRules(nsRuleNode* aCurrLevelNode,
     1:                                    nsRuleNode* aLastPrevLevelNode)
     1: {
 15902:   if (!aCurrLevelNode)
     1:     return;
     1: 
 15902:   for (nsRuleNode *node = aCurrLevelNode; node != aLastPrevLevelNode;
 15902:        node = node->GetParent()) {
 70825:     nsRefPtr<css::StyleRule> rule(do_QueryObject(node->GetRule()));
 70825:     NS_ASSERTION(rule, "Unexpected non-CSS rule");
 70825: 
 35529:     NS_ASSERTION(!rule->GetImportantRule(), "Unexpected important rule");
     1:   }
     1: }
     1: 
     1: void
     1: nsStyleSet::AssertNoCSSRules(nsRuleNode* aCurrLevelNode,
     1:                              nsRuleNode* aLastPrevLevelNode)
     1: {
 15902:   if (!aCurrLevelNode)
     1:     return;
     1: 
 15902:   for (nsRuleNode *node = aCurrLevelNode; node != aLastPrevLevelNode;
 15902:        node = node->GetParent()) {
 15902:     nsIStyleRule *rule = node->GetRule();
 70825:     nsRefPtr<css::StyleRule> cssRule(do_QueryObject(rule));
     1:     NS_ASSERTION(!cssRule || !cssRule->Selector(), "Unexpected CSS rule");
     1:   }
 15902: }
     1: #endif
     1: 
     1: // Enumerate the rules in a way that cares about the order of the rules.
     1: void
     1: nsStyleSet::FileRules(nsIStyleRuleProcessor::EnumFunc aCollectorFunc, 
128824:                       RuleProcessorData* aData, Element* aElement,
 35556:                       nsRuleWalker* aRuleWalker)
     1: {
114005:   SAMPLE_LABEL("nsStyleSet", "FileRules");
114005: 
     1:   // Cascading order:
     1:   // [least important]
110719:   //  - UA normal rules                    = Agent        normal
110719:   //  - User normal rules                  = User         normal
110719:   //  - Presentation hints                 = PresHint     normal
110719:   //  - Author normal rules                = Document     normal
110719:   //  - Override normal rules              = Override     normal
110719:   //  - animation rules                    = Animation    normal
110719:   //  - Author !important rules            = Document     !important
110719:   //  - Override !important rules          = Override     !important
110719:   //  - User !important rules              = User         !important
110719:   //  - UA !important rules                = Agent        !important
110719:   //  - transition rules                   = Transition   normal
     1:   // [most important]
     1: 
 70824:   // Save off the last rule before we start walking our agent sheets;
 70824:   // this will be either the root or one of the restriction rules.
 70824:   nsRuleNode* lastRestrictionRN = aRuleWalker->CurrentNode();
 70824: 
 80486:   aRuleWalker->SetLevel(eAgentSheet, false, true);
     1:   if (mRuleProcessors[eAgentSheet])
     1:     (*aCollectorFunc)(mRuleProcessors[eAgentSheet], aData);
 35613:   nsRuleNode* lastAgentRN = aRuleWalker->CurrentNode();
 79445:   bool haveImportantUARules = !aRuleWalker->GetCheckForImportantRules();
     1: 
 80486:   aRuleWalker->SetLevel(eUserSheet, false, true);
 79445:   bool skipUserStyles =
128824:     aElement && aElement->IsInNativeAnonymousSubtree();
  1111:   if (!skipUserStyles && mRuleProcessors[eUserSheet]) // NOTE: different
     1:     (*aCollectorFunc)(mRuleProcessors[eUserSheet], aData);
 35613:   nsRuleNode* lastUserRN = aRuleWalker->CurrentNode();
 79445:   bool haveImportantUserRules = !aRuleWalker->GetCheckForImportantRules();
     1: 
 80486:   aRuleWalker->SetLevel(ePresHintSheet, false, false);
 60634:   if (mRuleProcessors[ePresHintSheet])
 60634:     (*aCollectorFunc)(mRuleProcessors[ePresHintSheet], aData);
 60634:   nsRuleNode* lastPresHintRN = aRuleWalker->CurrentNode();
     1:   
 80486:   aRuleWalker->SetLevel(eDocSheet, false, true);
 79445:   bool cutOffInheritance = false;
128824:   if (mBindingManager && aElement) {
     1:     // We can supply additional document-level sheets that should be walked.
 35556:     mBindingManager->WalkRules(aCollectorFunc,
121909:                                static_cast<ElementDependentRuleProcessorData*>(aData),
 35556:                                &cutOffInheritance);
     1:   }
128826:   if (!skipUserStyles && !cutOffInheritance && // NOTE: different
128826:       mRuleProcessors[eDocSheet])
128826:     (*aCollectorFunc)(mRuleProcessors[eDocSheet], aData);
128826:   nsRuleNode* lastDocRN = aRuleWalker->CurrentNode();
128826:   bool haveImportantDocRules = !aRuleWalker->GetCheckForImportantRules();
128826:   nsTArray<nsRuleNode*> lastScopedRNs;
128826:   nsTArray<bool> haveImportantScopedRules;
128826:   bool haveAnyImportantScopedRules = false;
128731:   if (!skipUserStyles && !cutOffInheritance &&
128826:       aElement && aElement->IsElementInStyleScope()) {
128826:     lastScopedRNs.SetLength(mScopedDocSheetRuleProcessors.Length());
128826:     haveImportantScopedRules.SetLength(mScopedDocSheetRuleProcessors.Length());
129111:     for (uint32_t i = 0; i < mScopedDocSheetRuleProcessors.Length(); i++) {
128826:       aRuleWalker->SetLevel(eScopedDocSheet, false, true);
128826:       nsCSSRuleProcessor* processor =
128826:         static_cast<nsCSSRuleProcessor*>(mScopedDocSheetRuleProcessors[i].get());
128829:       aData->mScope = processor->GetScopeElement();
128826:       (*aCollectorFunc)(mScopedDocSheetRuleProcessors[i], aData);
128826:       lastScopedRNs[i] = aRuleWalker->CurrentNode();
128826:       haveImportantScopedRules[i] = !aRuleWalker->GetCheckForImportantRules();
128826:       haveAnyImportantScopedRules = haveAnyImportantScopedRules || haveImportantScopedRules[i];
128826:     }
128829:     aData->mScope = nullptr;
128826:   }
128826:   nsRuleNode* lastScopedRN = aRuleWalker->CurrentNode();
128826:   aRuleWalker->SetLevel(eStyleAttrSheet, false, true);
128731:   if (mRuleProcessors[eStyleAttrSheet])
128731:     (*aCollectorFunc)(mRuleProcessors[eStyleAttrSheet], aData);
128826:   nsRuleNode* lastStyleAttrRN = aRuleWalker->CurrentNode();
128826:   bool haveImportantStyleAttrRules = !aRuleWalker->GetCheckForImportantRules();
     1: 
 80486:   aRuleWalker->SetLevel(eOverrideSheet, false, true);
     1:   if (mRuleProcessors[eOverrideSheet])
     1:     (*aCollectorFunc)(mRuleProcessors[eOverrideSheet], aData);
 35613:   nsRuleNode* lastOvrRN = aRuleWalker->CurrentNode();
 79445:   bool haveImportantOverrideRules = !aRuleWalker->GetCheckForImportantRules();
     1: 
110719:   // This needs to match IsMoreSpecificThanAnimation() above.
110719:   aRuleWalker->SetLevel(eAnimationSheet, false, false);
110719:   (*aCollectorFunc)(mRuleProcessors[eAnimationSheet], aData);
110719: 
128826:   if (haveAnyImportantScopedRules) {
128826:     for (uint32_t i = lastScopedRNs.Length(); i-- != 0; ) {
128826:       aRuleWalker->SetLevel(eScopedDocSheet, true, false);
128826:       nsRuleNode* startRN = lastScopedRNs[i];
128826:       nsRuleNode* endRN = i == 0 ? lastDocRN : lastScopedRNs[i - 1];
128826:       if (haveImportantScopedRules[i]) {
128826:         AddImportantRules(startRN, endRN, aRuleWalker);  // scoped
128826:       }
128826: #ifdef DEBUG
128826:       else {
128826:         AssertNoImportantRules(startRN, endRN);
128826:       }
128826: #endif
128826:     }
128826:   }
128826: #ifdef DEBUG
128826:   else {
128826:     AssertNoImportantRules(lastScopedRN, lastDocRN);
128826:   }
128826: #endif
128826: 
 35529:   if (haveImportantDocRules) {
 80486:     aRuleWalker->SetLevel(eDocSheet, true, false);
 60634:     AddImportantRules(lastDocRN, lastPresHintRN, aRuleWalker);  // doc
 35529:   }
 35529: #ifdef DEBUG
 35529:   else {
 60634:     AssertNoImportantRules(lastDocRN, lastPresHintRN);
 35529:   }
 35529: #endif
 35529: 
128826:   if (haveImportantStyleAttrRules) {
128826:     aRuleWalker->SetLevel(eStyleAttrSheet, true, false);
128826:     AddImportantRules(lastStyleAttrRN, lastScopedRN, aRuleWalker);  // style attr
 35529:   }
 35529: #ifdef DEBUG
 35529:   else {
128826:     AssertNoImportantRules(lastStyleAttrRN, lastScopedRN);
128826:   }
128826: #endif
128826: 
128826:   if (haveImportantOverrideRules) {
128826:     aRuleWalker->SetLevel(eOverrideSheet, true, false);
128826:     AddImportantRules(lastOvrRN, lastStyleAttrRN, aRuleWalker);  // override
128826:   }
128826: #ifdef DEBUG
128826:   else {
128826:     AssertNoImportantRules(lastOvrRN, lastStyleAttrRN);
 35529:   }
 35529: #endif
 35529: 
     1: #ifdef DEBUG
 60634:   AssertNoCSSRules(lastPresHintRN, lastUserRN);
     1: #endif
 35529: 
 35529:   if (haveImportantUserRules) {
 80486:     aRuleWalker->SetLevel(eUserSheet, true, false);
 60633:     AddImportantRules(lastUserRN, lastAgentRN, aRuleWalker); //user
 35529:   }
 35529: #ifdef DEBUG
 35529:   else {
 60633:     AssertNoImportantRules(lastUserRN, lastAgentRN);
 35529:   }
 35529: #endif
 35529: 
 35529:   if (haveImportantUARules) {
 80486:     aRuleWalker->SetLevel(eAgentSheet, true, false);
 70824:     AddImportantRules(lastAgentRN, lastRestrictionRN, aRuleWalker); //agent
 35529:   }
 35529: #ifdef DEBUG
 35529:   else {
 70824:     AssertNoImportantRules(lastAgentRN, lastRestrictionRN);
 35529:   }
 35529: #endif
     1: 
 33649: #ifdef DEBUG
 70824:   AssertNoCSSRules(lastRestrictionRN, mRuleTree);
 70824: #endif
 70824: 
 70824: #ifdef DEBUG
 35613:   nsRuleNode *lastImportantRN = aRuleWalker->CurrentNode();
 33649: #endif
 80486:   aRuleWalker->SetLevel(eTransitionSheet, false, false);
 33649:   (*aCollectorFunc)(mRuleProcessors[eTransitionSheet], aData);
 33649: #ifdef DEBUG
 35613:   AssertNoCSSRules(aRuleWalker->CurrentNode(), lastImportantRN);
 33649: #endif
 33649: 
     1: }
     1: 
     1: // Enumerate all the rules in a way that doesn't care about the order
     1: // of the rules and doesn't walk !important-rules.
     1: void
     1: nsStyleSet::WalkRuleProcessors(nsIStyleRuleProcessor::EnumFunc aFunc,
121909:                                ElementDependentRuleProcessorData* aData,
 79445:                                bool aWalkAllXBLStylesheets)
     1: {
     1:   if (mRuleProcessors[eAgentSheet])
     1:     (*aFunc)(mRuleProcessors[eAgentSheet], aData);
  1111: 
 79445:   bool skipUserStyles = aData->mElement->IsInNativeAnonymousSubtree();
  1111:   if (!skipUserStyles && mRuleProcessors[eUserSheet]) // NOTE: different
     1:     (*aFunc)(mRuleProcessors[eUserSheet], aData);
  1111: 
 60634:   if (mRuleProcessors[ePresHintSheet])
 60634:     (*aFunc)(mRuleProcessors[ePresHintSheet], aData);
     1:   
 79445:   bool cutOffInheritance = false;
     1:   if (mBindingManager) {
     1:     // We can supply additional document-level sheets that should be walked.
 39805:     if (aWalkAllXBLStylesheets) {
 39805:       mBindingManager->WalkAllRules(aFunc, aData);
 39805:     } else {
 16231:       mBindingManager->WalkRules(aFunc, aData, &cutOffInheritance);
     1:     }
 39805:   }
128826:   if (!skipUserStyles && !cutOffInheritance) {
128826:     if (mRuleProcessors[eDocSheet]) // NOTE: different
     1:       (*aFunc)(mRuleProcessors[eDocSheet], aData);
128826:     if (aData->mElement->IsElementInStyleScope()) {
129111:       for (uint32_t i = 0; i < mScopedDocSheetRuleProcessors.Length(); i++)
128826:         (*aFunc)(mScopedDocSheetRuleProcessors[i], aData);
128826:     }
128826:   }
     1:   if (mRuleProcessors[eStyleAttrSheet])
     1:     (*aFunc)(mRuleProcessors[eStyleAttrSheet], aData);
     1:   if (mRuleProcessors[eOverrideSheet])
     1:     (*aFunc)(mRuleProcessors[eOverrideSheet], aData);
 67985:   (*aFunc)(mRuleProcessors[eAnimationSheet], aData);
 69179:   (*aFunc)(mRuleProcessors[eTransitionSheet], aData);
     1: }
     1: 
     1: already_AddRefed<nsStyleContext>
 41643: nsStyleSet::ResolveStyleFor(Element* aElement,
     1:                             nsStyleContext* aParentContext)
     1: {
 80486:   TreeMatchContext treeContext(true, nsRuleWalker::eRelevantLinkUnvisited,
 80526:                                aElement->OwnerDoc());
 64158:   return ResolveStyleFor(aElement, aParentContext, treeContext);
 64158: }
 64158: 
 64158: already_AddRefed<nsStyleContext>
 64158: nsStyleSet::ResolveStyleFor(Element* aElement,
 64158:                             nsStyleContext* aParentContext,
 64158:                             TreeMatchContext& aTreeMatchContext)
 64158: {
106838:   NS_ENSURE_FALSE(mInShutdown, nullptr);
 41643:   NS_ASSERTION(aElement, "aElement must not be null");
     1: 
 33399:   nsRuleWalker ruleWalker(mRuleTree);
 64158:   aTreeMatchContext.ResetForUnvisitedMatching();
 64157:   ElementRuleProcessorData data(PresContext(), aElement, &ruleWalker,
 64158:                                 aTreeMatchContext);
 41643:   FileRules(EnumRulesMatching<ElementRuleProcessorData>, &data, aElement,
 35558:             &ruleWalker);
     1: 
 40189:   nsRuleNode *ruleNode = ruleWalker.CurrentNode();
106838:   nsRuleNode *visitedRuleNode = nullptr;
 40189: 
 64158:   if (aTreeMatchContext.HaveRelevantLink()) {
 64158:     aTreeMatchContext.ResetForVisitedMatching();
 64157:     ruleWalker.Reset();
 41643:     FileRules(EnumRulesMatching<ElementRuleProcessorData>, &data, aElement,
 40189:               &ruleWalker);
 40189:     visitedRuleNode = ruleWalker.CurrentNode();
 40189:   }
 40189: 
131259:   uint32_t flags = eDoAnimation;
131259:   if (nsCSSRuleProcessor::IsLink(aElement)) {
131259:     flags |= eIsLink;
131259:   }
131259:   if (nsCSSRuleProcessor::GetContentState(aElement, aTreeMatchContext).
131259:                             HasState(NS_EVENT_STATE_VISITED)) {
131259:     flags |= eIsVisitedLink;
131259:   }
131259: 
 40189:   return GetContext(aParentContext, ruleNode, visitedRuleNode,
106838:                     nullptr, nsCSSPseudoElements::ePseudo_NotPseudoElement,
131259:                     aElement, flags);
     1: }
     1: 
     1: already_AddRefed<nsStyleContext>
 31309: nsStyleSet::ResolveStyleForRules(nsStyleContext* aParentContext,
119242:                                  const nsTArray< nsCOMPtr<nsIStyleRule> > &aRules)
  3964: {
106838:   NS_ENSURE_FALSE(mInShutdown, nullptr);
  3964: 
 33399:   nsRuleWalker ruleWalker(mRuleTree);
 31309:   // FIXME: Perhaps this should be passed in, but it probably doesn't
 31309:   // matter.
 80486:   ruleWalker.SetLevel(eDocSheet, false, false);
119242:   for (uint32_t i = 0; i < aRules.Length(); i++) {
119242:     ruleWalker.ForwardOnPossiblyCSSRule(aRules.ElementAt(i));
  3964:   }
 40136: 
106838:   return GetContext(aParentContext, ruleWalker.CurrentNode(), nullptr,
106838:                     nullptr, nsCSSPseudoElements::ePseudo_NotPseudoElement,
131259:                     nullptr, eNoFlags);
 40171: }
 40171: 
 40171: already_AddRefed<nsStyleContext>
125555: nsStyleSet::ResolveStyleForRules(nsStyleContext* aParentContext,
125555:                                  nsStyleContext* aOldStyle,
125555:                                  const nsTArray<RuleAndLevel>& aRules)
125555: {
125555:   nsRuleWalker ruleWalker(mRuleTree);
125555:   for (int32_t i = aRules.Length() - 1; i >= 0; --i) {
125555:     ruleWalker.SetLevel(aRules[i].mLevel, false, false);
125555:     ruleWalker.ForwardOnPossiblyCSSRule(aRules[i].mRule);
125555:   }
125555: 
131259:   uint32_t flags = eNoFlags;
131259:   if (aOldStyle->IsLinkContext()) {
131259:     flags |= eIsLink;
131259:   }
131259:   if (aOldStyle->RelevantLinkVisited()) {
131259:     flags |= eIsVisitedLink;
131259:   }
131259: 
125555:   return GetContext(aParentContext, ruleWalker.CurrentNode(), nullptr,
125555:                     nullptr, nsCSSPseudoElements::ePseudo_NotPseudoElement,
131259:                     nullptr, flags);
125555: }
125555: 
125555: already_AddRefed<nsStyleContext>
 40171: nsStyleSet::ResolveStyleByAddingRules(nsStyleContext* aBaseContext,
 40171:                                       const nsCOMArray<nsIStyleRule> &aRules)
 40171: {
106838:   NS_ENSURE_FALSE(mInShutdown, nullptr);
 40171: 
 40171:   nsRuleWalker ruleWalker(mRuleTree);
132810:   ruleWalker.SetCurrentNode(aBaseContext->RuleNode());
 40171:   // FIXME: Perhaps this should be passed in, but it probably doesn't
 40171:   // matter.
 80486:   ruleWalker.SetLevel(eDocSheet, false, false);
108991:   for (int32_t i = 0; i < aRules.Count(); i++) {
 70891:     ruleWalker.ForwardOnPossiblyCSSRule(aRules.ObjectAt(i));
 40171:   }
 40189: 
 40189:   nsRuleNode *ruleNode = ruleWalker.CurrentNode();
106838:   nsRuleNode *visitedRuleNode = nullptr;
 40189: 
 40189:   if (aBaseContext->GetStyleIfVisited()) {
132810:     ruleWalker.SetCurrentNode(aBaseContext->GetStyleIfVisited()->RuleNode());
108991:     for (int32_t i = 0; i < aRules.Count(); i++) {
 70891:       ruleWalker.ForwardOnPossiblyCSSRule(aRules.ObjectAt(i));
 40189:     }
 40189:     visitedRuleNode = ruleWalker.CurrentNode();
 40189:   }
 40189: 
131259:   uint32_t flags = eNoFlags;
131259:   if (aBaseContext->IsLinkContext()) {
131259:     flags |= eIsLink;
131259:   }
131259:   if (aBaseContext->RelevantLinkVisited()) {
131259:     flags |= eIsVisitedLink;
131259:   }
 40189:   return GetContext(aBaseContext->GetParent(), ruleNode, visitedRuleNode,
 40171:                     aBaseContext->GetPseudo(),
 67985:                     aBaseContext->GetPseudoType(),
131259:                     nullptr, flags);
  3964: }
  3964: 
  3964: already_AddRefed<nsStyleContext>
     1: nsStyleSet::ResolveStyleForNonElement(nsStyleContext* aParentContext)
     1: {
106838:   return GetContext(aParentContext, mRuleTree, nullptr,
 35554:                     nsCSSAnonBoxes::mozNonElement,
131259:                     nsCSSPseudoElements::ePseudo_AnonBox, nullptr,
131259:                     eNoFlags);
     1: }
     1: 
 22737: void
 35555: nsStyleSet::WalkRestrictionRule(nsCSSPseudoElements::Type aPseudoType,
 33399:                                 nsRuleWalker* aRuleWalker)
 22737: {
 22737:   // This needs to match GetPseudoRestriction in nsRuleNode.cpp.
 80486:   aRuleWalker->SetLevel(eAgentSheet, false, false);
 35555:   if (aPseudoType == nsCSSPseudoElements::ePseudo_firstLetter)
 33399:     aRuleWalker->Forward(mFirstLetterRule);
 35555:   else if (aPseudoType == nsCSSPseudoElements::ePseudo_firstLine)
 33399:     aRuleWalker->Forward(mFirstLineRule);
121456:   else if (aPseudoType == nsCSSPseudoElements::ePseudo_mozPlaceholder)
121456:     aRuleWalker->Forward(mPlaceholderRule);
 22737: }
 35549: 
 35555: already_AddRefed<nsStyleContext>
 41643: nsStyleSet::ResolvePseudoElementStyle(Element* aParentElement,
 35555:                                       nsCSSPseudoElements::Type aType,
 35555:                                       nsStyleContext* aParentContext)
 35555: {
106838:   NS_ENSURE_FALSE(mInShutdown, nullptr);
 35555: 
 35555:   NS_ASSERTION(aType < nsCSSPseudoElements::ePseudo_PseudoElementCount,
 35555:                "must have pseudo element type");
 41643:   NS_ASSERTION(aParentElement, "Must have parent element");
 35555: 
 35555:   nsRuleWalker ruleWalker(mRuleTree);
 80486:   TreeMatchContext treeContext(true, nsRuleWalker::eRelevantLinkUnvisited,
 80526:                                aParentElement->OwnerDoc());
 41643:   PseudoElementRuleProcessorData data(PresContext(), aParentElement,
 64157:                                       &ruleWalker, aType, treeContext);
 35555:   WalkRestrictionRule(aType, &ruleWalker);
 35558:   FileRules(EnumRulesMatching<PseudoElementRuleProcessorData>, &data,
 41643:             aParentElement, &ruleWalker);
 35555: 
 40189:   nsRuleNode *ruleNode = ruleWalker.CurrentNode();
106838:   nsRuleNode *visitedRuleNode = nullptr;
 40189: 
 64157:   if (treeContext.HaveRelevantLink()) {
 64157:     treeContext.ResetForVisitedMatching();
 64157:     ruleWalker.Reset();
 70824:     WalkRestrictionRule(aType, &ruleWalker);
 40189:     FileRules(EnumRulesMatching<PseudoElementRuleProcessorData>, &data,
 41643:               aParentElement, &ruleWalker);
 40189:     visitedRuleNode = ruleWalker.CurrentNode();
 40189:   }
 40189: 
 40191:   // For pseudos, |data.IsLink()| being true means that
 40191:   // our parent node is a link.
133734:   // Also: Flex containers shouldn't have pseudo-elements, so given that we're
133734:   // looking up pseudo-element style, make sure we're not treating our node as
133734:   // a flex item.
133734:   uint32_t flags = eSkipFlexItemStyleFixup;
131259:   if (aType == nsCSSPseudoElements::ePseudo_before ||
131259:       aType == nsCSSPseudoElements::ePseudo_after) {
131259:     flags |= eDoAnimation;
131259:   }
131259: 
131259:   return GetContext(aParentContext, ruleNode, visitedRuleNode,
 67985:                     nsCSSPseudoElements::GetPseudoAtom(aType), aType,
131259:                     aParentElement, flags);
 35555: }
 35555: 
 35549: already_AddRefed<nsStyleContext>
 41643: nsStyleSet::ProbePseudoElementStyle(Element* aParentElement,
 35554:                                     nsCSSPseudoElements::Type aType,
 35549:                                     nsStyleContext* aParentContext)
 35549: {
 80486:   TreeMatchContext treeContext(true, nsRuleWalker::eRelevantLinkUnvisited,
 80526:                                aParentElement->OwnerDoc());
 64158:   return ProbePseudoElementStyle(aParentElement, aType, aParentContext,
 64158:                                  treeContext);
 64158: }
 64158: 
 64158: already_AddRefed<nsStyleContext>
 64158: nsStyleSet::ProbePseudoElementStyle(Element* aParentElement,
 64158:                                     nsCSSPseudoElements::Type aType,
 64158:                                     nsStyleContext* aParentContext,
 64158:                                     TreeMatchContext& aTreeMatchContext)
 64158: {
106838:   NS_ENSURE_FALSE(mInShutdown, nullptr);
 35549: 
 35555:   NS_ASSERTION(aType < nsCSSPseudoElements::ePseudo_PseudoElementCount,
 35555:                "must have pseudo element type");
 41643:   NS_ASSERTION(aParentElement, "aParentElement must not be null");
 35549: 
 35555:   nsIAtom* pseudoTag = nsCSSPseudoElements::GetPseudoAtom(aType);
 35549:   nsRuleWalker ruleWalker(mRuleTree);
 64158:   aTreeMatchContext.ResetForUnvisitedMatching();
 41643:   PseudoElementRuleProcessorData data(PresContext(), aParentElement,
 64158:                                       &ruleWalker, aType, aTreeMatchContext);
 35555:   WalkRestrictionRule(aType, &ruleWalker);
 35549:   // not the root if there was a restriction rule
 35613:   nsRuleNode *adjustedRoot = ruleWalker.CurrentNode();
 35558:   FileRules(EnumRulesMatching<PseudoElementRuleProcessorData>, &data,
 41643:             aParentElement, &ruleWalker);
 35549: 
 35613:   nsRuleNode *ruleNode = ruleWalker.CurrentNode();
 35555:   if (ruleNode == adjustedRoot) {
106838:     return nullptr;
 35549:   }
 35549: 
106838:   nsRuleNode *visitedRuleNode = nullptr;
 40189: 
 64158:   if (aTreeMatchContext.HaveRelevantLink()) {
 64158:     aTreeMatchContext.ResetForVisitedMatching();
 64157:     ruleWalker.Reset();
 70824:     WalkRestrictionRule(aType, &ruleWalker);
 40189:     FileRules(EnumRulesMatching<PseudoElementRuleProcessorData>, &data,
 41643:               aParentElement, &ruleWalker);
 40189:     visitedRuleNode = ruleWalker.CurrentNode();
 40189:   }
 40189: 
131259:   // For pseudos, |data.IsLink()| being true means that
131259:   // our parent node is a link.
133734:   // Also: Flex containers shouldn't have pseudo-elements, so given that we're
133734:   // looking up pseudo-element style, make sure we're not treating our node as
133734:   // a flex item.
133734:   uint32_t flags = eSkipFlexItemStyleFixup;
131259:   if (aType == nsCSSPseudoElements::ePseudo_before ||
131259:       aType == nsCSSPseudoElements::ePseudo_after) {
131259:     flags |= eDoAnimation;
131259:   }
131259: 
 35555:   nsRefPtr<nsStyleContext> result =
 40189:     GetContext(aParentContext, ruleNode, visitedRuleNode,
 67985:                pseudoTag, aType,
131259:                aParentElement, flags);
 35555: 
 35549:   // For :before and :after pseudo-elements, having display: none or no
 35549:   // 'content' property is equivalent to not having the pseudo-element
 35549:   // at all.
 35549:   if (result &&
 35554:       (pseudoTag == nsCSSPseudoElements::before ||
 35554:        pseudoTag == nsCSSPseudoElements::after)) {
132812:     const nsStyleDisplay *display = result->StyleDisplay();
132812:     const nsStyleContent *content = result->StyleContent();
 35549:     // XXXldb What is contentCount for |content: ""|?
 35549:     if (display->mDisplay == NS_STYLE_DISPLAY_NONE ||
 35549:         content->ContentCount() == 0) {
106838:       result = nullptr;
 35549:     }
 35549:   }
 35549: 
 35555:   return result.forget();
 35549: }
 35542: 
 35556: already_AddRefed<nsStyleContext>
 35556: nsStyleSet::ResolveAnonymousBoxStyle(nsIAtom* aPseudoTag,
 35556:                                      nsStyleContext* aParentContext)
 35556: {
106838:   NS_ENSURE_FALSE(mInShutdown, nullptr);
 35556: 
 35556: #ifdef DEBUG
 79445:     bool isAnonBox = nsCSSAnonBoxes::IsAnonBox(aPseudoTag)
 35556: #ifdef MOZ_XUL
 35556:                  && !nsCSSAnonBoxes::IsTreePseudoElement(aPseudoTag)
 35556: #endif
 35556:       ;
 35556:     NS_PRECONDITION(isAnonBox, "Unexpected pseudo");
 35556: #endif
 35556: 
 35556:   nsRuleWalker ruleWalker(mRuleTree);
 40136:   AnonBoxRuleProcessorData data(PresContext(), aPseudoTag, &ruleWalker);
106838:   FileRules(EnumRulesMatching<AnonBoxRuleProcessorData>, &data, nullptr,
 35558:             &ruleWalker);
 35556: 
121979:   if (aPseudoTag == nsCSSAnonBoxes::pageContent) {
121979:     // Add any @page rules that are specified.
121979:     nsTArray<nsCSSPageRule*> rules;
121979:     nsTArray<css::ImportantRule*> importantRules;
121979:     nsPresContext* presContext = PresContext();
121979:     presContext->StyleSet()->AppendPageRules(presContext, rules);
121979:     for (uint32_t i = 0, i_end = rules.Length(); i != i_end; ++i) {
121979:       ruleWalker.Forward(rules[i]);
121979:       css::ImportantRule* importantRule = rules[i]->GetImportantRule();
121979:       if (importantRule) {
121979:         importantRules.AppendElement(importantRule);
121979:       }
121979:     }
121979:     for (uint32_t i = 0, i_end = importantRules.Length(); i != i_end; ++i) {
121979:       ruleWalker.Forward(importantRules[i]);
121979:     }
121979:   }
121979: 
106838:   return GetContext(aParentContext, ruleWalker.CurrentNode(), nullptr,
 67985:                     aPseudoTag, nsCSSPseudoElements::ePseudo_AnonBox,
131259:                     nullptr, eNoFlags);
 35556: }
 35556: 
 35558: #ifdef MOZ_XUL
 35558: already_AddRefed<nsStyleContext>
 41643: nsStyleSet::ResolveXULTreePseudoStyle(Element* aParentElement,
 35558:                                       nsIAtom* aPseudoTag,
 35558:                                       nsStyleContext* aParentContext,
 35558:                                       nsICSSPseudoComparator* aComparator)
 35558: {
106838:   NS_ENSURE_FALSE(mInShutdown, nullptr);
 35558: 
 35558:   NS_ASSERTION(aPseudoTag, "must have pseudo tag");
 35558:   NS_ASSERTION(nsCSSAnonBoxes::IsTreePseudoElement(aPseudoTag),
 35558:                "Unexpected pseudo");
 35558: 
 35558:   nsRuleWalker ruleWalker(mRuleTree);
 80486:   TreeMatchContext treeContext(true, nsRuleWalker::eRelevantLinkUnvisited,
 80526:                                aParentElement->OwnerDoc());
 41643:   XULTreeRuleProcessorData data(PresContext(), aParentElement, &ruleWalker,
 64157:                                 aPseudoTag, aComparator, treeContext);
 41643:   FileRules(EnumRulesMatching<XULTreeRuleProcessorData>, &data, aParentElement,
 35558:             &ruleWalker);
 35558: 
 40189:   nsRuleNode *ruleNode = ruleWalker.CurrentNode();
106838:   nsRuleNode *visitedRuleNode = nullptr;
 40189: 
 64157:   if (treeContext.HaveRelevantLink()) {
 64157:     treeContext.ResetForVisitedMatching();
 64157:     ruleWalker.Reset();
 40189:     FileRules(EnumRulesMatching<XULTreeRuleProcessorData>, &data,
 41643:               aParentElement, &ruleWalker);
 40189:     visitedRuleNode = ruleWalker.CurrentNode();
 40189:   }
 40189: 
 40189:   return GetContext(aParentContext, ruleNode, visitedRuleNode,
 40191:                     // For pseudos, |data.IsLink()| being true means that
 40191:                     // our parent node is a link.
 67985:                     aPseudoTag, nsCSSPseudoElements::ePseudo_XULTree,
131259:                     nullptr, eNoFlags);
 35558: }
 35558: #endif
 35558: 
 79445: bool
 21924: nsStyleSet::AppendFontFaceRules(nsPresContext* aPresContext,
 21983:                                 nsTArray<nsFontFaceRuleContainer>& aArray)
 21924: {
 80486:   NS_ENSURE_FALSE(mInShutdown, false);
 21924: 
108991:   for (uint32_t i = 0; i < ArrayLength(gCSSSheetTypes); ++i) {
128825:     if (gCSSSheetTypes[i] == eScopedDocSheet)
128825:       continue;
 21924:     nsCSSRuleProcessor *ruleProc = static_cast<nsCSSRuleProcessor*>
 21924:                                     (mRuleProcessors[gCSSSheetTypes[i]].get());
 21924:     if (ruleProc && !ruleProc->AppendFontFaceRules(aPresContext, aArray))
 80486:       return false;
 21924:   }
 80486:   return true;
 21924: }
 21924: 
 79445: bool
 67980: nsStyleSet::AppendKeyframesRules(nsPresContext* aPresContext,
 67980:                                  nsTArray<nsCSSKeyframesRule*>& aArray)
 67980: {
 80486:   NS_ENSURE_FALSE(mInShutdown, false);
 67980: 
108991:   for (uint32_t i = 0; i < ArrayLength(gCSSSheetTypes); ++i) {
128825:     if (gCSSSheetTypes[i] == eScopedDocSheet)
128825:       continue;
 67980:     nsCSSRuleProcessor *ruleProc = static_cast<nsCSSRuleProcessor*>
 67980:                                     (mRuleProcessors[gCSSSheetTypes[i]].get());
 67980:     if (ruleProc && !ruleProc->AppendKeyframesRules(aPresContext, aArray))
 80486:       return false;
 67980:   }
 80486:   return true;
 67980: }
 67980: 
121979: bool
121979: nsStyleSet::AppendPageRules(nsPresContext* aPresContext,
121979:                             nsTArray<nsCSSPageRule*>& aArray)
121979: {
121979:   NS_ENSURE_FALSE(mInShutdown, false);
121979: 
121979:   for (uint32_t i = 0; i < NS_ARRAY_LENGTH(gCSSSheetTypes); ++i) {
128825:     if (gCSSSheetTypes[i] == eScopedDocSheet)
128825:       continue;
121979:     nsCSSRuleProcessor* ruleProc = static_cast<nsCSSRuleProcessor*>
121979:                                     (mRuleProcessors[gCSSSheetTypes[i]].get());
121979:     if (ruleProc && !ruleProc->AppendPageRules(aPresContext, aArray))
121979:       return false;
121979:   }
121979:   return true;
121979: }
121979: 
     1: void
     1: nsStyleSet::BeginShutdown(nsPresContext* aPresContext)
     1: {
     1:   mInShutdown = 1;
     1:   mRoots.Clear(); // no longer valid, since we won't keep it up to date
     1: }
     1: 
     1: void
     1: nsStyleSet::Shutdown(nsPresContext* aPresContext)
     1: {
     1:   mRuleTree->Destroy();
106838:   mRuleTree = nullptr;
     1: 
 24429:   // We can have old rule trees either because:
 24429:   //   (1) we failed the assertions in EndReconstruct, or
 24429:   //   (2) we're shutting down within a reconstruct (see bug 462392)
108991:   for (uint32_t i = mOldRuleTrees.Length(); i > 0; ) {
 24429:     --i;
 24429:     mOldRuleTrees[i]->Destroy();
 24429:   }
 24429:   mOldRuleTrees.Clear();
     1: }
     1: 
108991: static const uint32_t kGCInterval = 300;
     1: 
     1: void
     1: nsStyleSet::NotifyStyleContextDestroyed(nsPresContext* aPresContext,
     1:                                         nsStyleContext* aStyleContext)
     1: {
     1:   if (mInShutdown)
     1:     return;
     1: 
  8007:   // Remove style contexts from mRoots even if mOldRuleTree is non-null.  This
  8007:   // could be a style context from the new ruletree!
     1:   if (!aStyleContext->GetParent()) {
     1:     mRoots.RemoveElement(aStyleContext);
     1:   }
     1: 
 24429:   if (mInReconstruct)
  8007:     return;
  8007: 
 60838:   if (mUnusedRuleNodeCount >= kGCInterval) {
 24429:     GCRuleTrees();
 24429:   }
 24429: }
 24429: 
 24429: void
 24429: nsStyleSet::GCRuleTrees()
 24429: {
 33020:   mUnusedRuleNodeCount = 0;
     1: 
 24429:   // Mark the style context tree by marking all style contexts which
 24429:   // have no parent, which will mark all descendants.  This will reach
 24429:   // style contexts in the undisplayed map and "additional style
 24429:   // contexts" since they are descendants of the roots.
108991:   for (int32_t i = mRoots.Length() - 1; i >= 0; --i) {
  3959:     mRoots[i]->Mark();
     1:   }
     1: 
     1:   // Sweep the rule tree.
     1: #ifdef DEBUG
 79445:   bool deleted =
     1: #endif
     1:     mRuleTree->Sweep();
 24429:   NS_ASSERTION(!deleted, "Root node must not be gc'd");
 24418: 
 24429:   // Sweep the old rule trees.
108991:   for (uint32_t i = mOldRuleTrees.Length(); i > 0; ) {
 24429:     --i;
 24429:     if (mOldRuleTrees[i]->Sweep()) {
 24429:       // It was deleted, as it should be.
 24429:       mOldRuleTrees.RemoveElementAt(i);
 24429:     } else {
 24429:       NS_NOTREACHED("old rule tree still referenced");
 24429:     }
     1:   }
     1: }
     1: 
 44166: static inline nsRuleNode*
 79445: SkipAnimationRules(nsRuleNode* aRuleNode, Element* aElement, bool isPseudo)
 44166: {
 44166:   nsRuleNode* ruleNode = aRuleNode;
 44166:   while (!ruleNode->IsRoot() &&
 78544:          (ruleNode->GetLevel() == nsStyleSet::eTransitionSheet ||
 78544:           ruleNode->GetLevel() == nsStyleSet::eAnimationSheet)) {
 44166:     ruleNode = ruleNode->GetParent();
 44166:   }
 44166:   if (ruleNode != aRuleNode) {
 44166:     NS_ASSERTION(aElement, "How can we have transition rules but no element?");
 44166:     // Need to do an animation restyle, just like
 78544:     // nsTransitionManager::WalkTransitionRule and
 78544:     // nsAnimationManager::GetAnimationRule would.
 46468:     nsRestyleHint hint = isPseudo ? eRestyle_Subtree : eRestyle_Self;
132811:     aRuleNode->PresContext()->PresShell()->RestyleForAnimation(aElement, hint);
 44166:   }
 44166:   return ruleNode;
 44166: }
 44166: 
     1: already_AddRefed<nsStyleContext>
 40136: nsStyleSet::ReparentStyleContext(nsStyleContext* aStyleContext,
 44166:                                  nsStyleContext* aNewParentContext,
 44166:                                  Element* aElement)
     1: {
 40136:   if (!aStyleContext) {
 40136:     NS_NOTREACHED("must have style context");
106838:     return nullptr;
 40136:   }
     1: 
 44166:   // This short-circuit is OK because we don't call TryStartingTransition
 44166:   // during style reresolution if the style context pointer hasn't changed.
     1:   if (aStyleContext->GetParent() == aNewParentContext) {
     1:     aStyleContext->AddRef();
     1:     return aStyleContext;
     1:   }
 40136: 
 34387:   nsIAtom* pseudoTag = aStyleContext->GetPseudo();
 35554:   nsCSSPseudoElements::Type pseudoType = aStyleContext->GetPseudoType();
132810:   nsRuleNode* ruleNode = aStyleContext->RuleNode();
 44166: 
 44166:   // Skip transition rules as needed just like
 44166:   // nsTransitionManager::WalkTransitionRule would.
 79445:   bool skipAnimationRules = PresContext()->IsProcessingRestyles() &&
 44166:     !PresContext()->IsProcessingAnimationStyleChange();
 78544:   if (skipAnimationRules) {
 78544:     // Make sure that we're not using transition rules or animation rules for
 78544:     // our new style context.  If we need them, an animation restyle will
 78544:     // provide.
 46468:     ruleNode =
 78544:       SkipAnimationRules(ruleNode, aElement,
 46468:                          pseudoType !=
 46468:                            nsCSSPseudoElements::ePseudo_NotPseudoElement);
 44166:   }
 44166: 
106838:   nsRuleNode* visitedRuleNode = nullptr;
 40189:   nsStyleContext* visitedContext = aStyleContext->GetStyleIfVisited();
 43326:   // Reparenting a style context just changes where we inherit from,
 43326:   // not what rules we match or what our DOM looks like.  In
 43326:   // particular, it doesn't change whether this is a style context for
 43326:   // a link.
 40189:   if (visitedContext) {
132810:      visitedRuleNode = visitedContext->RuleNode();
 44166:      // Again, skip transition rules as needed
 78544:      if (skipAnimationRules) {
 67985:       // FIXME do something here for animations?
 46468:        visitedRuleNode =
 78544:          SkipAnimationRules(visitedRuleNode, aElement,
 46468:                             pseudoType !=
 46468:                               nsCSSPseudoElements::ePseudo_NotPseudoElement);
 44166:      }
 40189:   }
     1: 
131259:   uint32_t flags = eNoFlags;
131259:   if (aStyleContext->IsLinkContext()) {
131259:     flags |= eIsLink;
131259:   }
131259: 
 70190:   // If we're a style context for a link, then we already know whether
 70190:   // our relevant link is visited, since that does not depend on our
 70190:   // parent.  Otherwise, we need to match aNewParentContext.
 79445:   bool relevantLinkVisited = aStyleContext->IsLinkContext() ?
 70190:     aStyleContext->RelevantLinkVisited() :
 70190:     aNewParentContext->RelevantLinkVisited();
 70190: 
131259:   if (relevantLinkVisited) {
131259:     flags |= eIsVisitedLink;
131259:   }
131259: 
131259:   if (pseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement ||
131259:       pseudoType == nsCSSPseudoElements::ePseudo_before ||
131259:       pseudoType == nsCSSPseudoElements::ePseudo_after) {
131259:     flags |= eDoAnimation;
131259:   }
131259: 
 40189:   return GetContext(aNewParentContext, ruleNode, visitedRuleNode,
 67985:                     pseudoTag, pseudoType,
131259:                     aElement, flags);
     1: }
     1: 
     1: struct StatefulData : public StateRuleProcessorData {
 64157:   StatefulData(nsPresContext* aPresContext, Element* aElement,
 64157:                nsEventStates aStateMask, TreeMatchContext& aTreeMatchContext)
 64157:     : StateRuleProcessorData(aPresContext, aElement, aStateMask,
 64157:                              aTreeMatchContext),
 40075:       mHint(nsRestyleHint(0))
     1:   {}
 40075:   nsRestyleHint   mHint;
     1: };
     1: 
 79445: static bool SheetHasDocumentStateStyle(nsIStyleRuleProcessor* aProcessor,
 39698:                                          void *aData)
 39698: {
 39698:   StatefulData* data = (StatefulData*)aData;
 39698:   if (aProcessor->HasDocumentStateDependentStyle(data)) {
 43794:     data->mHint = eRestyle_Self;
 80486:     return false; // don't continue
 39698:   }
 80486:   return true; // continue
 39698: }
 39698: 
 39698: // Test if style is dependent on a document state.
 79445: bool
 39698: nsStyleSet::HasDocumentStateDependentStyle(nsPresContext* aPresContext,
 39698:                                            nsIContent*    aContent,
 56168:                                            nsEventStates  aStateMask)
 39698: {
 41643:   if (!aContent || !aContent->IsElement())
 80486:     return false;
 39698: 
 80486:   TreeMatchContext treeContext(false, nsRuleWalker::eLinksVisitedOrUnvisited,
 80526:                                aContent->OwnerDoc());
 64157:   StatefulData data(aPresContext, aContent->AsElement(), aStateMask,
 64157:                     treeContext);
 80486:   WalkRuleProcessors(SheetHasDocumentStateStyle, &data, true);
 39698:   return data.mHint != 0;
 39698: }
 39698: 
 79445: static bool SheetHasStatefulStyle(nsIStyleRuleProcessor* aProcessor,
     1:                                     void *aData)
     1: {
     1:   StatefulData* data = (StatefulData*)aData;
 40075:   nsRestyleHint hint = aProcessor->HasStateDependentStyle(data);
 40075:   data->mHint = nsRestyleHint(data->mHint | hint);
 80486:   return true; // continue
     1: }
     1: 
     1: // Test if style is dependent on content state
 40075: nsRestyleHint
     1: nsStyleSet::HasStateDependentStyle(nsPresContext*       aPresContext,
 42323:                                    Element*             aElement,
 56168:                                    nsEventStates        aStateMask)
     1: {
 80486:   TreeMatchContext treeContext(false, nsRuleWalker::eLinksVisitedOrUnvisited,
 80526:                                aElement->OwnerDoc());
 64157:   StatefulData data(aPresContext, aElement, aStateMask, treeContext);
 80486:   WalkRuleProcessors(SheetHasStatefulStyle, &data, false);
 42323:   return data.mHint;
     1: }
     1: 
     1: struct AttributeData : public AttributeRuleProcessorData {
     1:   AttributeData(nsPresContext* aPresContext,
108991:                 Element* aElement, nsIAtom* aAttribute, int32_t aModType,
 79445:                 bool aAttrHasChanged, TreeMatchContext& aTreeMatchContext)
 41644:     : AttributeRuleProcessorData(aPresContext, aElement, aAttribute, aModType,
 64157:                                  aAttrHasChanged, aTreeMatchContext),
 40075:       mHint(nsRestyleHint(0))
     1:   {}
 40075:   nsRestyleHint   mHint;
     1: }; 
     1: 
 79445: static bool
     1: SheetHasAttributeStyle(nsIStyleRuleProcessor* aProcessor, void *aData)
     1: {
     1:   AttributeData* data = (AttributeData*)aData;
 40075:   nsRestyleHint hint = aProcessor->HasAttributeDependentStyle(data);
 40075:   data->mHint = nsRestyleHint(data->mHint | hint);
 80486:   return true; // continue
     1: }
     1: 
     1: // Test if style is dependent on content state
 40075: nsRestyleHint
     1: nsStyleSet::HasAttributeDependentStyle(nsPresContext* aPresContext,
 42323:                                        Element*       aElement,
     1:                                        nsIAtom*       aAttribute,
108991:                                        int32_t        aModType,
 79445:                                        bool           aAttrHasChanged)
     1: {
 80486:   TreeMatchContext treeContext(false, nsRuleWalker::eLinksVisitedOrUnvisited,
 80526:                                aElement->OwnerDoc());
 42323:   AttributeData data(aPresContext, aElement, aAttribute,
 64157:                      aModType, aAttrHasChanged, treeContext);
 80486:   WalkRuleProcessors(SheetHasAttributeStyle, &data, false);
 42323:   return data.mHint;
     1: }
 16225: 
 79445: bool
 16225: nsStyleSet::MediumFeaturesChanged(nsPresContext* aPresContext)
 16225: {
 16225:   // We can't use WalkRuleProcessors without a content node.
 79445:   bool stylesChanged = false;
108991:   for (uint32_t i = 0; i < ArrayLength(mRuleProcessors); ++i) {
 16225:     nsIStyleRuleProcessor *processor = mRuleProcessors[i];
 16225:     if (!processor) {
 16225:       continue;
 16225:     }
 79445:     bool thisChanged = processor->MediumFeaturesChanged(aPresContext);
 16225:     stylesChanged = stylesChanged || thisChanged;
 16225:   }
132230:   for (uint32_t i = 0; i < mScopedDocSheetRuleProcessors.Length(); ++i) {
132230:     nsIStyleRuleProcessor *processor = mScopedDocSheetRuleProcessors[i];
132230:     bool thisChanged = processor->MediumFeaturesChanged(aPresContext);
132230:     stylesChanged = stylesChanged || thisChanged;
132230:   }
 16225: 
 16231:   if (mBindingManager) {
 79445:     bool thisChanged = false;
 16231:     mBindingManager->MediumFeaturesChanged(aPresContext, &thisChanged);
 16231:     stylesChanged = stylesChanged || thisChanged;
 16231:   }
 16231: 
 16225:   return stylesChanged;
 16225: }
 36785: 
 36785: nsCSSStyleSheet::EnsureUniqueInnerResult
 36785: nsStyleSet::EnsureUniqueInnerOnCSSSheets()
 36785: {
 36785:   nsAutoTArray<nsCSSStyleSheet*, 32> queue;
108991:   for (uint32_t i = 0; i < ArrayLength(gCSSSheetTypes); ++i) {
 36785:     nsCOMArray<nsIStyleSheet> &sheets = mSheets[gCSSSheetTypes[i]];
108991:     for (uint32_t j = 0, j_end = sheets.Count(); j < j_end; ++j) {
 36785:       nsCSSStyleSheet *sheet = static_cast<nsCSSStyleSheet*>(sheets[j]);
 36785:       if (!queue.AppendElement(sheet)) {
 36785:         return nsCSSStyleSheet::eUniqueInner_CloneFailed;
 36785:       }
 36785:     }
 36785:   }
 36785: 
 47849:   if (mBindingManager) {
 47849:     mBindingManager->AppendAllSheets(queue);
 47849:   }
 47849: 
 36785:   nsCSSStyleSheet::EnsureUniqueInnerResult res =
 36785:     nsCSSStyleSheet::eUniqueInner_AlreadyUnique;
 36785:   while (!queue.IsEmpty()) {
108991:     uint32_t idx = queue.Length() - 1;
 36785:     nsCSSStyleSheet *sheet = queue[idx];
 36785:     queue.RemoveElementAt(idx);
 36785: 
 36785:     nsCSSStyleSheet::EnsureUniqueInnerResult sheetRes =
 36785:       sheet->EnsureUniqueInner();
 36785:     if (sheetRes == nsCSSStyleSheet::eUniqueInner_CloneFailed) {
 36785:       return sheetRes;
 36785:     }
 36785:     if (sheetRes == nsCSSStyleSheet::eUniqueInner_ClonedInner) {
 36785:       res = sheetRes;
 36785:     }
 36785: 
 36785:     // Enqueue all the sheet's children.
 36785:     if (!sheet->AppendAllChildSheets(queue)) {
 36785:       return nsCSSStyleSheet::eUniqueInner_CloneFailed;
 36785:     }
 36785:   }
 36785:   return res;
 36785: }
 77005: 
 77005: nsIStyleRule*
 77005: nsStyleSet::InitialStyleRule()
 77005: {
 77005:   if (!mInitialStyleRule) {
 77005:     mInitialStyleRule = new nsInitialStyleRule;
 77005:   }
 77005:   return mInitialStyleRule;
 77005: }
