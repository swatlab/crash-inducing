 64127: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 73787: /* vim: set sw=4 ts=4 et : */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 35740: 
 38045: #ifdef MOZ_WIDGET_QT
110589: #include <unistd.h> // for _exit()
 43456: #include <QtCore/QTimer>
 40008: #include "nsQAppInstance.h"
 43456: #include "NestedLoopTimer.h"
 38045: #endif
 38045: 
 35893: #include "mozilla/plugins/PluginModuleChild.h"
 80467: 
 80467: /* This must occur *after* plugins/PluginModuleChild.h to avoid typedefs conflicts. */
 80467: #include "mozilla/Util.h"
 80467: 
 76704: #include "mozilla/ipc/SyncChannel.h"
 35740: 
103111: #ifdef MOZ_WIDGET_GTK
 35746: #include <gtk/gtk.h>
103111: #if (MOZ_WIDGET_GTK == 3)
103111: #include <gtk/gtkx.h>
103111: #endif
 35746: #endif
 35746: 
101111: #include "nsIFile.h"
 35740: 
 36078: #include "pratom.h"
 35740: #include "nsDebug.h"
 35740: #include "nsCOMPtr.h"
 35740: #include "nsPluginsDir.h"
 36140: #include "nsXULAppAPI.h"
 35740: 
 57138: #ifdef MOZ_X11
 57138: # include "mozilla/X11Util.h"
 57138: #endif
 35893: #include "mozilla/plugins/PluginInstanceChild.h"
 35919: #include "mozilla/plugins/StreamNotifyChild.h"
 35919: #include "mozilla/plugins/BrowserStreamChild.h"
 35938: #include "mozilla/plugins/PluginStreamChild.h"
 39742: #include "PluginIdentifierChild.h"
 79569: #include "mozilla/dom/CrashReporterChild.h"
 35740: 
 36125: #include "nsNPAPIPlugin.h"
 36125: 
 42538: #ifdef XP_WIN
 42538: #include "COMMessageFilter.h"
 58736: #include "nsWindowsDllInterceptor.h"
 72466: #include "mozilla/widget/AudioSession.h"
 42538: #endif
 42538: 
 72514: #ifdef MOZ_WIDGET_COCOA
 50439: #include "PluginInterposeOSX.h"
 48383: #include "PluginUtilsOSX.h"
 48383: #endif
 48383: 
 80467: using namespace mozilla;
 35913: using namespace mozilla::plugins;
 79569: using mozilla::dom::CrashReporterChild;
 79569: using mozilla::dom::PCrashReporterChild;
 35913: 
 42136: #if defined(XP_WIN)
 42416: const PRUnichar * kFlashFullscreenClass = L"ShockwaveFlashFullScreen";
 58736: const PRUnichar * kMozillaWindowClass = L"MozillaWindowClass";
 42136: #endif
 42136: 
 35913: namespace {
106838: PluginModuleChild* gInstance = nullptr;
 35913: }
 35740: 
 42531: #ifdef MOZ_WIDGET_QT
 42531: typedef void (*_gtk_init_fn)(int argc, char **argv);
106838: static _gtk_init_fn s_gtk_init = nullptr;
106838: static PRLibrary *sGtkLib = nullptr;
 42531: #endif
 42531: 
 42416: #ifdef XP_WIN
 42416: // Used with fix for flash fullscreen window loosing focus.
 42416: static bool gDelayFlashFocusReplyUntilEval = false;
 58736: // Used to fix GetWindowInfo problems with internal flash settings dialogs
 58736: static WindowsDllInterceptor sUser32Intercept;
 58736: typedef BOOL (WINAPI *GetWindowInfoPtr)(HWND hwnd, PWINDOWINFO pwi);
 58736: static GetWindowInfoPtr sGetWindowInfoPtrStub = NULL;
 58736: static HWND sBrowserHwnd = NULL;
 42416: #endif
 35940: 
 64127: PluginModuleChild::PluginModuleChild()
 64127:   : mLibrary(0)
 64609:   , mPluginFilename("")
 64127:   , mQuirks(QUIRKS_NOT_INITIALIZED)
 64127:   , mShutdownFunc(0)
 64127:   , mInitializeFunc(0)
 39534: #if defined(OS_WIN) || defined(OS_MACOSX)
 35746:   , mGetEntryPointsFunc(0)
103111: #elif defined(MOZ_WIDGET_GTK)
 38684:   , mNestedLoopTimerId(0)
 43456: #elif defined(MOZ_WIDGET_QT)
 43456:   , mNestedLoopTimerObject(0)
 35746: #endif
 41651: #ifdef OS_WIN
 41651:   , mNestedEventHook(NULL)
 42136:   , mGlobalCallWndProcHook(NULL)
 41651: #endif
 35740: {
 35925:     NS_ASSERTION(!gInstance, "Something terribly wrong here!");
 35740:     memset(&mFunctions, 0, sizeof(mFunctions));
 35740:     memset(&mSavedData, 0, sizeof(mSavedData));
 35913:     gInstance = this;
 80486:     mUserAgent.SetIsVoid(true);
 50439: #ifdef XP_MACOSX
 50439:     mac_plugin_interposing::child::SetUpCocoaInterposing();
 50439: #endif
 35740: }
 35740: 
 35893: PluginModuleChild::~PluginModuleChild()
 35740: {
 35925:     NS_ASSERTION(gInstance == this, "Something terribly wrong here!");
101890: 
101890:     // We don't unload the plugin library in case it uses atexit handlers or
101890:     // other similar hooks.
 62705: 
 62705:     DeinitGraphics();
 62705: 
106838:     gInstance = nullptr;
 35740: }
 35740: 
 35925: // static
 35925: PluginModuleChild*
 35925: PluginModuleChild::current()
 35925: {
 35925:     NS_ASSERTION(gInstance, "Null instance!");
 35925:     return gInstance;
 35925: }
 35925: 
 35740: bool
 35893: PluginModuleChild::Init(const std::string& aPluginFilename,
 36016:                         base::ProcessHandle aParentProcessHandle,
 35740:                         MessageLoop* aIOLoop,
 35740:                         IPC::Channel* aChannel)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_METHOD;
 35740: 
 42538: #ifdef XP_WIN
 42538:     COMMessageFilter::Initialize(this);
 42538: #endif
 42538: 
 35740:     NS_ASSERTION(aChannel, "need a channel");
 35740: 
 98908:     mObjectMap.Init();
 98908:     mStringIdentifiers.Init();
 98908:     mIntIdentifiers.Init();
 39742: 
 35746:     if (!InitGraphics())
 35746:         return false;
 35746: 
 64609:     mPluginFilename = aPluginFilename.c_str();
101111:     nsCOMPtr<nsIFile> localFile;
 67685:     NS_NewLocalFile(NS_ConvertUTF8toUTF16(mPluginFilename),
 80486:                     true,
 69479:                     getter_AddRefs(localFile));
 35740: 
 79445:     bool exists;
 69479:     localFile->Exists(&exists);
 35740:     NS_ASSERTION(exists, "plugin file ain't there");
 35740: 
 69479:     nsPluginFile pluginFile(localFile);
 35740: 
 69479:     // Maemo flash can render with any provided rectangle and so does not
 69479:     // require this quirk.
126057: #if (defined(MOZ_X11) && !defined(MOZ_PLATFORM_MAEMO)) || defined(OS_MACOSX)
 69479:     nsPluginInfo info = nsPluginInfo();
 78436:     if (NS_FAILED(pluginFile.GetPluginInfo(info, &mLibrary)))
 69479:         return false;
 35740: 
126057: #if defined(MOZ_X11) && !defined(MOZ_PLATFORM_MAEMO)
 69479:     NS_NAMED_LITERAL_CSTRING(flash10Head, "Shockwave Flash 10.");
 69479:     if (StringBeginsWith(nsDependentCString(info.fDescription), flash10Head)) {
 69479:         AddQuirk(QUIRK_FLASH_EXPOSE_COORD_TRANSLATION);
 69479:     }
126057: #else // defined(OS_MACOSX)
126057:     mozilla::plugins::PluginUtilsOSX::SetProcessName(info.fName);
126057: #endif
 69479: 
 69479:     if (!mLibrary)
 69479: #endif
 69479:     {
108908:         nsresult rv = pluginFile.LoadPlugin(&mLibrary);
108908:         if (NS_FAILED(rv))
108908:             return false;
 69479:     }
 35740:     NS_ASSERTION(mLibrary, "couldn't open shared object");
 35740: 
 36016:     if (!Open(aChannel, aParentProcessHandle, aIOLoop))
 35740:         return false;
 35740: 
 35740:     memset((void*) &mFunctions, 0, sizeof(mFunctions));
 35740:     mFunctions.size = sizeof(mFunctions);
 58535:     mFunctions.version = (NP_VERSION_MAJOR << 8) | NP_VERSION_MINOR;
 35740: 
 36039:     // TODO: use PluginPRLibrary here
 35740: 
110585: #if defined(OS_LINUX) || defined(OS_BSD)
 35740:     mShutdownFunc =
 35740:         (NP_PLUGINSHUTDOWN) PR_FindFunctionSymbol(mLibrary, "NP_Shutdown");
 35740: 
 35740:     // create the new plugin handler
 35740: 
 35740:     mInitializeFunc =
 35740:         (NP_PLUGINUNIXINIT) PR_FindFunctionSymbol(mLibrary, "NP_Initialize");
 35740:     NS_ASSERTION(mInitializeFunc, "couldn't find NP_Initialize()");
 35740: 
 39534: #elif defined(OS_WIN) || defined(OS_MACOSX)
 35746:     mShutdownFunc =
 35746:         (NP_PLUGINSHUTDOWN)PR_FindFunctionSymbol(mLibrary, "NP_Shutdown");
 35740: 
 35746:     mGetEntryPointsFunc =
 35746:         (NP_GETENTRYPOINTS)PR_FindSymbol(mLibrary, "NP_GetEntryPoints");
 35746:     NS_ENSURE_TRUE(mGetEntryPointsFunc, false);
 35746: 
 35746:     mInitializeFunc =
 35746:         (NP_PLUGININIT)PR_FindFunctionSymbol(mLibrary, "NP_Initialize");
 35746:     NS_ENSURE_TRUE(mInitializeFunc, false);
 35740: #else
 35740: 
 35740: #  error Please copy the initialization code from nsNPAPIPlugin.cpp
 35740: 
 35740: #endif
 72639: 
 35746:     return true;
 35746: }
 35746: 
103111: #if defined(MOZ_WIDGET_GTK)
 37346: typedef void (*GObjectDisposeFn)(GObject*);
 39854: typedef gboolean (*GtkWidgetScrollEventFn)(GtkWidget*, GdkEventScroll*);
 37347: typedef void (*GtkPlugEmbeddedFn)(GtkPlug*);
 37346: 
 37346: static GObjectDisposeFn real_gtk_plug_dispose;
 37347: static GtkPlugEmbeddedFn real_gtk_plug_embedded;
 37346: 
 37346: static void
 37346: undo_bogus_unref(gpointer data, GObject* object, gboolean is_last_ref) {
 37346:     if (!is_last_ref) // recursion in g_object_ref
 37346:         return;
 37346: 
 37346:     g_object_ref(object);
 37346: }
 37346: 
 37346: static void
 37346: wrap_gtk_plug_dispose(GObject* object) {
 37346:     // Work around Flash Player bug described in bug 538914.
 37346:     //
 37346:     // This function is called during gtk_widget_destroy and/or before
 37346:     // the object's last reference is removed.  A reference to the
 37346:     // object is held during the call so the ref count should not drop
 37346:     // to zero.  However, Flash Player tries to destroy the GtkPlug
 37346:     // using g_object_unref instead of gtk_widget_destroy.  The
 37346:     // reference that Flash is removing actually belongs to the
 37346:     // GtkPlug.  During real_gtk_plug_dispose, the GtkPlug removes its
 37346:     // reference.
 37346:     //
 37346:     // A toggle ref is added to prevent premature deletion of the object
 37346:     // caused by Flash Player's extra unref, and to detect when there are
 37346:     // unexpectedly no other references.
 37346:     g_object_add_toggle_ref(object, undo_bogus_unref, NULL);
 37346:     (*real_gtk_plug_dispose)(object);
 37346:     g_object_remove_toggle_ref(object, undo_bogus_unref, NULL);
 37346: }
 37347: 
 39854: static gboolean
 39854: gtk_plug_scroll_event(GtkWidget *widget, GdkEventScroll *gdk_event)
 39854: {
103111:     if (!gtk_widget_is_toplevel(widget)) // in same process as its GtkSocket
 39854:         return FALSE; // event not handled; propagate to GtkSocket
 39854: 
103111:     GdkWindow* socket_window = gtk_plug_get_socket_window(GTK_PLUG(widget));
 39854:     if (!socket_window)
 39854:         return FALSE;
 39854: 
 39854:     // Propagate the event to the embedder.
103111:     GdkScreen* screen = gdk_window_get_screen(socket_window);
103111:     GdkWindow* plug_window = gtk_widget_get_window(widget);
 39854:     GdkWindow* event_window = gdk_event->window;
 39854:     gint x = gdk_event->x;
 39854:     gint y = gdk_event->y;
 39854:     unsigned int button;
 39854:     unsigned int button_mask = 0;
 39854:     XEvent xevent;
 39854:     Display* dpy = GDK_WINDOW_XDISPLAY(socket_window);
 39854: 
 39854:     /* Translate the event coordinates to the plug window,
 39854:      * which should be aligned with the socket window.
 39854:      */
 39854:     while (event_window != plug_window)
 39854:     {
 39854:         gint dx, dy;
 39854: 
 39854:         gdk_window_get_position(event_window, &dx, &dy);
 39854:         x += dx;
 39854:         y += dy;
 39854: 
 39854:         event_window = gdk_window_get_parent(event_window);
 39854:         if (!event_window)
 39854:             return FALSE;
 39854:     }
 39854: 
 39854:     switch (gdk_event->direction) {
 39854:     case GDK_SCROLL_UP:
 39854:         button = 4;
 39854:         button_mask = Button4Mask;
 39854:         break;
 39854:     case GDK_SCROLL_DOWN:
 39854:         button = 5;
 39854:         button_mask = Button5Mask;
 39854:         break;
 39854:     case GDK_SCROLL_LEFT:
 39854:         button = 6;
 39854:         break;
 39854:     case GDK_SCROLL_RIGHT:
 39854:         button = 7;
 39854:         break;
 39854:     default:
 39854:         return FALSE; // unknown GdkScrollDirection
 39854:     }
 39854: 
 39854:     memset(&xevent, 0, sizeof(xevent));
 39854:     xevent.xbutton.type = ButtonPress;
103111:     xevent.xbutton.window = gdk_x11_window_get_xid(socket_window);
103111:     xevent.xbutton.root = gdk_x11_window_get_xid(gdk_screen_get_root_window(screen));
103111:     xevent.xbutton.subwindow = gdk_x11_window_get_xid(plug_window);
 39854:     xevent.xbutton.time = gdk_event->time;
 39854:     xevent.xbutton.x = x;
 39854:     xevent.xbutton.y = y;
 39854:     xevent.xbutton.x_root = gdk_event->x_root;
 39854:     xevent.xbutton.y_root = gdk_event->y_root;
 39854:     xevent.xbutton.state = gdk_event->state;
 39854:     xevent.xbutton.button = button;
 39854:     xevent.xbutton.same_screen = True;
 39854: 
 39854:     gdk_error_trap_push();
 39854: 
 39854:     XSendEvent(dpy, xevent.xbutton.window,
 39854:                True, ButtonPressMask, &xevent);
 39854: 
 39854:     xevent.xbutton.type = ButtonRelease;
 39854:     xevent.xbutton.state |= button_mask;
 39854:     XSendEvent(dpy, xevent.xbutton.window,
 39854:                True, ButtonReleaseMask, &xevent);
 39854: 
 39854:     gdk_display_sync(gdk_screen_get_display(screen));
 39854:     gdk_error_trap_pop();
 39854: 
 39854:     return TRUE; // event handled
 39854: }
 39854: 
 37347: static void
 37347: wrap_gtk_plug_embedded(GtkPlug* plug) {
103111:     GdkWindow* socket_window = gtk_plug_get_socket_window(plug);
 41542:     if (socket_window) {
 41542:         if (gtk_check_version(2,18,7) != NULL // older
 41542:             && g_object_get_data(G_OBJECT(socket_window),
 37347:                                  "moz-existed-before-set-window")) {
 37347:             // Add missing reference for
 37347:             // https://bugzilla.gnome.org/show_bug.cgi?id=607061
 37347:             g_object_ref(socket_window);
 37347:         }
 37347: 
 41542:         // Ensure the window exists to make this GtkPlug behave like an
 41542:         // in-process GtkPlug for Flash Player.  (Bugs 561308 and 539138).
 41542:         gtk_widget_realize(GTK_WIDGET(plug));
 41542:     }
 41542: 
 37347:     if (*real_gtk_plug_embedded) {
 37347:         (*real_gtk_plug_embedded)(plug);
 37347:     }
 37347: }
 38684: 
 38684: //
 38684: // The next four constants are knobs that can be tuned.  They trade
 38684: // off potential UI lag from delayed event processing with CPU time.
 38684: //
 38684: static const gint kNestedLoopDetectorPriority = G_PRIORITY_HIGH_IDLE;
 38684: // 90ms so that we can hopefully break livelocks before the user
 38684: // notices UI lag (100ms)
 38684: static const guint kNestedLoopDetectorIntervalMs = 90;
 38684: 
 38684: static const gint kBrowserEventPriority = G_PRIORITY_HIGH_IDLE;
 38684: static const guint kBrowserEventIntervalMs = 10;
 38684: 
 38684: // static
 38684: gboolean
 38684: PluginModuleChild::DetectNestedEventLoop(gpointer data)
 38684: {
 38684:     PluginModuleChild* pmc = static_cast<PluginModuleChild*>(data);
 38684: 
 38684:     NS_ABORT_IF_FALSE(0 != pmc->mNestedLoopTimerId,
 38684:                       "callback after descheduling");
 39856:     NS_ABORT_IF_FALSE(pmc->mTopLoopDepth < g_main_depth(),
 38684:                       "not canceled before returning to main event loop!");
 38684: 
 38684:     PLUGIN_LOG_DEBUG(("Detected nested glib event loop"));
 38684: 
 38684:     // just detected a nested loop; start a timer that will
 38684:     // periodically rpc-call back into the browser and process some
 38684:     // events
 38684:     pmc->mNestedLoopTimerId =
 38684:         g_timeout_add_full(kBrowserEventPriority,
 38684:                            kBrowserEventIntervalMs,
 38684:                            PluginModuleChild::ProcessBrowserEvents,
 38684:                            data,
 38684:                            NULL);
 38684:     // cancel the nested-loop detection timer
 38684:     return FALSE;
 38684: }
 38684: 
 38684: // static
 38684: gboolean
 38684: PluginModuleChild::ProcessBrowserEvents(gpointer data)
 38684: {
 39856:     PluginModuleChild* pmc = static_cast<PluginModuleChild*>(data);
 39856: 
 39856:     NS_ABORT_IF_FALSE(pmc->mTopLoopDepth < g_main_depth(),
 38684:                       "not canceled before returning to main event loop!");
 38684: 
 38685:     pmc->CallProcessSomeEvents();
 38684: 
 38684:     return TRUE;
 38684: }
 38684: 
 38684: void
 38684: PluginModuleChild::EnteredCxxStack()
 38684: {
 38684:     NS_ABORT_IF_FALSE(0 == mNestedLoopTimerId,
 38684:                       "previous timer not descheduled");
 38684: 
 38684:     mNestedLoopTimerId =
 38684:         g_timeout_add_full(kNestedLoopDetectorPriority,
 38684:                            kNestedLoopDetectorIntervalMs,
 38684:                            PluginModuleChild::DetectNestedEventLoop,
 38684:                            this,
 38684:                            NULL);
 39856: 
 39856: #ifdef DEBUG
 39856:     mTopLoopDepth = g_main_depth();
 39856: #endif
 38684: }
 38684: 
 38684: void
 38684: PluginModuleChild::ExitedCxxStack()
 38684: {
 38684:     NS_ABORT_IF_FALSE(0 < mNestedLoopTimerId,
 38684:                       "nested loop timeout not scheduled");
 38684: 
 38684:     g_source_remove(mNestedLoopTimerId);
 38684:     mNestedLoopTimerId = 0;
 38684: }
 43456: #elif defined (MOZ_WIDGET_QT)
 43456: 
 43456: void
 43456: PluginModuleChild::EnteredCxxStack()
 43456: {
 43456:     NS_ABORT_IF_FALSE(mNestedLoopTimerObject == NULL,
 43456:                       "previous timer not descheduled");
 43456:     mNestedLoopTimerObject = new NestedLoopTimer(this);
 43456:     QTimer::singleShot(kNestedLoopDetectorIntervalMs,
 43456:                        mNestedLoopTimerObject, SLOT(timeOut()));
 43456: }
 43456: 
 43456: void
 43456: PluginModuleChild::ExitedCxxStack()
 43456: {
 43456:     NS_ABORT_IF_FALSE(mNestedLoopTimerObject != NULL,
 43456:                       "nested loop timeout not scheduled");
 43456:     delete mNestedLoopTimerObject;
 43456:     mNestedLoopTimerObject = NULL;
 43456: }
 38684: 
 37346: #endif
 37346: 
 35746: bool
 76704: PluginModuleChild::RecvSetParentHangTimeout(const uint32_t& aSeconds)
 76704: {
 76704: #ifdef XP_WIN
 76704:     SetReplyTimeoutMs(((aSeconds > 0) ? (1000 * aSeconds) : 0));
 76704: #endif
 76704:     return true;
 76704: }
 76704: 
 76704: bool
 76704: PluginModuleChild::ShouldContinueFromReplyTimeout()
 76704: {
 76704: #ifdef XP_WIN
 76704:     NS_RUNTIMEABORT("terminating child process");
 76704: #endif
 76704:     return true;
 76704: }
 76704: 
 76704: bool
 35893: PluginModuleChild::InitGraphics()
 35746: {
103111: #if defined(MOZ_WIDGET_GTK)
 37820:     // Work around plugins that don't interact well with GDK
 37820:     // client-side windows.
 37820:     PR_SetEnv("GDK_NATIVE_WINDOWS=1");
 37820: 
 35746:     gtk_init(0, 0);
 37346: 
 37346:     // GtkPlug is a static class so will leak anyway but this ref makes sure.
 37346:     gpointer gtk_plug_class = g_type_class_ref(GTK_TYPE_PLUG);
 37347: 
 37346:     // The dispose method is a good place to hook into the destruction process
 37346:     // because the reference count should be 1 the last time dispose is
 37346:     // called.  (Toggle references wouldn't detect if the reference count
 37346:     // might be higher.)
 37346:     GObjectDisposeFn* dispose = &G_OBJECT_CLASS(gtk_plug_class)->dispose;
 37346:     NS_ABORT_IF_FALSE(*dispose != wrap_gtk_plug_dispose,
 37346:                       "InitGraphics called twice");
 37346:     real_gtk_plug_dispose = *dispose;
 37346:     *dispose = wrap_gtk_plug_dispose;
 37347: 
 39854:     // If we ever stop setting GDK_NATIVE_WINDOWS, we'll also need to
 39854:     // gtk_widget_add_events GDK_SCROLL_MASK or GDK client-side windows will
 39854:     // not tell us about the scroll events that it intercepts.  With native
 39854:     // windows, this is called when GDK intercepts the events; if GDK doesn't
 39854:     // intercept the events, then the X server will instead send them directly
 39854:     // to an ancestor (embedder) window.
 39854:     GtkWidgetScrollEventFn* scroll_event =
 39854:         &GTK_WIDGET_CLASS(gtk_plug_class)->scroll_event;
 39854:     if (!*scroll_event) {
 39854:         *scroll_event = gtk_plug_scroll_event;
 39854:     }
 39854: 
 37347:     GtkPlugEmbeddedFn* embedded = &GTK_PLUG_CLASS(gtk_plug_class)->embedded;
 37347:     real_gtk_plug_embedded = *embedded;
 37347:     *embedded = wrap_gtk_plug_embedded;
 39857: 
 37621: #elif defined(MOZ_WIDGET_QT)
 40008:     nsQAppInstance::AddRef();
 42531:     // Work around plugins that don't interact well without gtk initialized
 42531:     // see bug 566845
 42531: #if defined(MOZ_X11)
 42531:     if (!sGtkLib)
 42531:          sGtkLib = PR_LoadLibrary("libgtk-x11-2.0.so.0");
 42531: #endif
 42531:     if (sGtkLib) {
 42531:          s_gtk_init = (_gtk_init_fn)PR_FindFunctionSymbol(sGtkLib, "gtk_init");
 42531:          if (s_gtk_init)
 42531:              s_gtk_init(0, 0);
 42531:     }
 35746: #else
 35746:     // may not be necessary on all platforms
 35746: #endif
 38688: #ifdef MOZ_X11
 38688:     // Do this after initializing GDK, or GDK will install its own handler.
 38688:     XRE_InstallX11ErrorHandler();
 38688: #endif
 35746:     return true;
 35740: }
 35740: 
 62705: void
 62705: PluginModuleChild::DeinitGraphics()
 62705: {
 62705: #ifdef MOZ_WIDGET_QT
 62705:     nsQAppInstance::Release();
 62705:     if (sGtkLib) {
 62705:         PR_UnloadLibrary(sGtkLib);
106838:         sGtkLib = nullptr;
106838:         s_gtk_init = nullptr;
 62705:     }
 62705: #endif
 62705: 
 62705: #if defined(MOZ_X11) && defined(NS_FREE_PERMANENT_DATA)
 62705:     // We free some data off of XDisplay close hooks, ensure they're
 62705:     // run.  Closing the display is pretty scary, so we only do it to
 62705:     // silence leak checkers.
 62705:     XCloseDisplay(DefaultXDisplay());
 62705: #endif
 62705: }
 62705: 
 36039: bool
 36039: PluginModuleChild::AnswerNP_Shutdown(NPError *rv)
 36039: {
 36039:     AssertPluginThread();
 36039: 
 90760: #if defined XP_WIN
 72466:     mozilla::widget::StopAudioSession();
 72466: #endif
 72466: 
 36140:     // the PluginModuleParent shuts down this process after this RPC
 36140:     // call pops off its stack
 36039: 
 36064:     *rv = mShutdownFunc ? mShutdownFunc() : NPERR_NO_ERROR;
 36140: 
 36140:     // weakly guard against re-entry after NP_Shutdown
 36140:     memset(&mFunctions, 0, sizeof(mFunctions));
 36140: 
 41651: #ifdef OS_WIN
 42136:     ResetEventHooks();
 41651: #endif
 41651: 
 36039:     return true;
 36039: }
 36039: 
 60021: bool
 62174: PluginModuleChild::AnswerOptionalFunctionsSupported(bool *aURLRedirectNotify,
 62174:                                                     bool *aClearSiteData,
 62174:                                                     bool *aGetSitesWithData)
 60021: {
 62174:     *aURLRedirectNotify = !!mFunctions.urlredirectnotify;
 62174:     *aClearSiteData = !!mFunctions.clearsitedata;
 62174:     *aGetSitesWithData = !!mFunctions.getsiteswithdata;
 62174:     return true;
 62174: }
 62174: 
 62174: bool
 62174: PluginModuleChild::AnswerNPP_ClearSiteData(const nsCString& aSite,
 62174:                                            const uint64_t& aFlags,
 62174:                                            const uint64_t& aMaxAge,
 62174:                                            NPError* aResult)
 62174: {
 62174:     *aResult =
 62174:         mFunctions.clearsitedata(NullableStringGet(aSite), aFlags, aMaxAge);
 62174:     return true;
 62174: }
 62174: 
 62174: bool
 62174: PluginModuleChild::AnswerNPP_GetSitesWithData(InfallibleTArray<nsCString>* aResult)
 62174: {
 62174:     char** result = mFunctions.getsiteswithdata();
 62174:     if (!result)
 62174:         return true;
 62174: 
 62174:     char** iterator = result;
 62174:     while (*iterator) {
 62174:         aResult->AppendElement(*iterator);
 62174:         NS_Free(*iterator);
 62174:         ++iterator;
 62174:     }
 62174:     NS_Free(result);
 62174: 
 60021:     return true;
 60021: }
 60021: 
 72466: bool
 72466: PluginModuleChild::RecvSetAudioSessionData(const nsID& aId,
 72466:                                            const nsString& aDisplayName,
 72466:                                            const nsString& aIconPath)
 72466: {
 90760: #if !defined XP_WIN
 72466:     NS_RUNTIMEABORT("Not Reached!");
 72466:     return false;
 72466: #else
 78436:     nsresult rv = mozilla::widget::RecvAudioSessionData(aId, aDisplayName, aIconPath);
 72466:     NS_ENSURE_SUCCESS(rv, true); // Bail early if this fails
 72466: 
 72466:     // Ignore failures here; we can't really do anything about them
 72466:     mozilla::widget::StartAudioSession();
 72466:     return true;
 72466: #endif
 72466: }
 72466: 
 35740: void
 60014: PluginModuleChild::QuickExit()
 60014: {
 60014:     NS_WARNING("plugin process _exit()ing");
 60014:     _exit(0);
 60014: }
 60014: 
 79569: PCrashReporterChild*
 79569: PluginModuleChild::AllocPCrashReporter(mozilla::dom::NativeThreadId* id,
108991:                                        uint32_t* processType)
 79569: {
 79569:     return new CrashReporterChild();
 79569: }
 79569: 
 79569: bool
 79569: PluginModuleChild::DeallocPCrashReporter(PCrashReporterChild* actor)
 79569: {
 79569:     delete actor;
 79569:     return true;
 79569: }
 79569: 
 79569: bool
 79569: PluginModuleChild::AnswerPCrashReporterConstructor(
 79569:         PCrashReporterChild* actor,
 79569:         mozilla::dom::NativeThreadId* id,
108991:         uint32_t* processType)
 79569: {
 79569: #ifdef MOZ_CRASHREPORTER
 79569:     *id = CrashReporter::CurrentThreadId();
 79569:     *processType = XRE_GetProcessType();
 79569: #endif
 79569:     return true;
 79569: }
 79569: 
 60014: void
 36140: PluginModuleChild::ActorDestroy(ActorDestroyReason why)
 36140: {
 60014:     if (AbnormalShutdown == why) {
 60014:         NS_WARNING("shutting down early because of crash!");
 60014:         QuickExit();
 60014:     }
 60014: 
 36140:     // doesn't matter why we're being destroyed; it's up to us to
 36140:     // initiate (clean) shutdown
 36140:     XRE_ShutdownChildProcess();
 36140: }
 36140: 
 36140: void
 35893: PluginModuleChild::CleanUp()
 35740: {
 35740: }
 35740: 
 36099: const char*
 36099: PluginModuleChild::GetUserAgent()
 36099: {
 76891:     if (mUserAgent.IsVoid() && !CallNPN_UserAgent(&mUserAgent))
 36099:         return NULL;
 36099: 
 36099:     return NullableStringGet(mUserAgent);
 36099: }
 36099: 
 35925: bool
 37477: PluginModuleChild::RegisterActorForNPObject(NPObject* aObject,
 35925:                                             PluginScriptableObjectChild* aActor)
 35925: {
 35971:     AssertPluginThread();
 35925:     NS_ASSERTION(mObjectMap.IsInitialized(), "Not initialized!");
 35925:     NS_ASSERTION(aObject && aActor, "Null pointer!");
 37477: 
 37477:     NPObjectData* d = mObjectMap.GetEntry(aObject);
 37477:     if (!d) {
 37477:         NS_ERROR("NPObject not in object table");
 37477:         return false;
 37477:     }
 37477: 
 37477:     d->actor = aActor;
 37477:     return true;
 35925: }
 35925: 
 35925: void
 37477: PluginModuleChild::UnregisterActorForNPObject(NPObject* aObject)
 35925: {
 35971:     AssertPluginThread();
 35925:     NS_ASSERTION(mObjectMap.IsInitialized(), "Not initialized!");
 35925:     NS_ASSERTION(aObject, "Null pointer!");
 37477: 
134897:     NPObjectData* d = mObjectMap.GetEntry(aObject);
134897:     NS_ASSERTION(d, "NPObject not in object table");
134897:     if (d) {
134897:         d->actor = NULL;
134897:     }
 35925: }
 35925: 
 35925: PluginScriptableObjectChild*
 35925: PluginModuleChild::GetActorForNPObject(NPObject* aObject)
 35925: {
 35971:     AssertPluginThread();
 35925:     NS_ASSERTION(mObjectMap.IsInitialized(), "Not initialized!");
 35925:     NS_ASSERTION(aObject, "Null pointer!");
 37477: 
 37477:     NPObjectData* d = mObjectMap.GetEntry(aObject);
 37477:     if (!d) {
 37477:         NS_ERROR("Plugin using object not created with NPN_CreateObject?");
 37477:         return NULL;
 37477:     }
 37477: 
 37477:     return d->actor;
 35925: }
 35740: 
 36073: #ifdef DEBUG
 36073: bool
 37311: PluginModuleChild::NPObjectIsRegistered(NPObject* aObject)
 37311: {
 37477:     return !!mObjectMap.GetEntry(aObject);
 36073: }
 36073: #endif
 36073: 
 35740: //-----------------------------------------------------------------------------
 35740: // FIXME/cjones: just getting this out of the way for the moment ...
 35740: 
 36125: namespace mozilla {
 36125: namespace plugins {
 36125: namespace child {
 36125: 
 35740: static NPError NP_CALLBACK
 35740: _requestread(NPStream *pstream, NPByteRange *rangeList);
 35740: 
 35740: static NPError NP_CALLBACK
 35740: _geturlnotify(NPP aNPP, const char* relativeURL, const char* target,
 35740:               void* notifyData);
 35740: 
 35740: static NPError NP_CALLBACK
 35740: _getvalue(NPP aNPP, NPNVariable variable, void *r_value);
 35740: 
 35740: static NPError NP_CALLBACK
 35740: _setvalue(NPP aNPP, NPPVariable variable, void *r_value);
 35740: 
 35740: static NPError NP_CALLBACK
 35740: _geturl(NPP aNPP, const char* relativeURL, const char* target);
 35740: 
 35740: static NPError NP_CALLBACK
 35740: _posturlnotify(NPP aNPP, const char* relativeURL, const char *target,
 35740:                uint32_t len, const char *buf, NPBool file, void* notifyData);
 35740: 
 35740: static NPError NP_CALLBACK
 35740: _posturl(NPP aNPP, const char* relativeURL, const char *target, uint32_t len,
 35740:          const char *buf, NPBool file);
 35740: 
 35740: static NPError NP_CALLBACK
 35740: _newstream(NPP aNPP, NPMIMEType type, const char* window, NPStream** pstream);
 35740: 
 35740: static int32_t NP_CALLBACK
 35740: _write(NPP aNPP, NPStream *pstream, int32_t len, void *buffer);
 35740: 
 35740: static NPError NP_CALLBACK
 35740: _destroystream(NPP aNPP, NPStream *pstream, NPError reason);
 35740: 
 35740: static void NP_CALLBACK
 35740: _status(NPP aNPP, const char *message);
 35740: 
 35740: static void NP_CALLBACK
 35740: _memfree (void *ptr);
 35740: 
 35740: static uint32_t NP_CALLBACK
 35740: _memflush(uint32_t size);
 35740: 
 35740: static void NP_CALLBACK
 35740: _reloadplugins(NPBool reloadPages);
 35740: 
 35740: static void NP_CALLBACK
 35740: _invalidaterect(NPP aNPP, NPRect *invalidRect);
 35740: 
 35740: static void NP_CALLBACK
 35740: _invalidateregion(NPP aNPP, NPRegion invalidRegion);
 35740: 
 35740: static void NP_CALLBACK
 35740: _forceredraw(NPP aNPP);
 35740: 
 35740: static const char* NP_CALLBACK
 35740: _useragent(NPP aNPP);
 35740: 
 35740: static void* NP_CALLBACK
 35740: _memalloc (uint32_t size);
 35740: 
 35740: // Deprecated entry points for the old Java plugin.
 35740: static void* NP_CALLBACK /* OJI type: JRIEnv* */
 35740: _getjavaenv(void);
 35740: 
 35740: // Deprecated entry points for the old Java plugin.
 35740: static void* NP_CALLBACK /* OJI type: jref */
 35740: _getjavapeer(NPP aNPP);
 35740: 
 35740: static bool NP_CALLBACK
 35740: _invoke(NPP aNPP, NPObject* npobj, NPIdentifier method, const NPVariant *args,
 35740:         uint32_t argCount, NPVariant *result);
 35740: 
 35740: static bool NP_CALLBACK
 35740: _invokedefault(NPP aNPP, NPObject* npobj, const NPVariant *args,
 35740:                uint32_t argCount, NPVariant *result);
 35740: 
 35740: static bool NP_CALLBACK
 35740: _evaluate(NPP aNPP, NPObject* npobj, NPString *script, NPVariant *result);
 35740: 
 35740: static bool NP_CALLBACK
 35740: _getproperty(NPP aNPP, NPObject* npobj, NPIdentifier property,
 35740:              NPVariant *result);
 35740: 
 35740: static bool NP_CALLBACK
 35740: _setproperty(NPP aNPP, NPObject* npobj, NPIdentifier property,
 35740:              const NPVariant *value);
 35740: 
 35740: static bool NP_CALLBACK
 35740: _removeproperty(NPP aNPP, NPObject* npobj, NPIdentifier property);
 35740: 
 35740: static bool NP_CALLBACK
 35740: _hasproperty(NPP aNPP, NPObject* npobj, NPIdentifier propertyName);
 35740: 
 35740: static bool NP_CALLBACK
 35740: _hasmethod(NPP aNPP, NPObject* npobj, NPIdentifier methodName);
 35740: 
 35740: static bool NP_CALLBACK
 35740: _enumerate(NPP aNPP, NPObject *npobj, NPIdentifier **identifier,
 35740:            uint32_t *count);
 35740: 
 35740: static bool NP_CALLBACK
 35740: _construct(NPP aNPP, NPObject* npobj, const NPVariant *args,
 35740:            uint32_t argCount, NPVariant *result);
 35740: 
 35740: static void NP_CALLBACK
 35740: _releasevariantvalue(NPVariant *variant);
 35740: 
 35740: static void NP_CALLBACK
 35740: _setexception(NPObject* npobj, const NPUTF8 *message);
 35740: 
 39850: static void NP_CALLBACK
 35740: _pushpopupsenabledstate(NPP aNPP, NPBool enabled);
 35740: 
 39850: static void NP_CALLBACK
 35740: _poppopupsenabledstate(NPP aNPP);
 35740: 
 35740: static void NP_CALLBACK
 35740: _pluginthreadasynccall(NPP instance, PluginThreadCallback func,
 35740:                        void *userData);
 35740: 
 35956: static NPError NP_CALLBACK
 35956: _getvalueforurl(NPP npp, NPNURLVariable variable, const char *url,
 35956:                 char **value, uint32_t *len);
 35956: 
 35956: static NPError NP_CALLBACK
 35956: _setvalueforurl(NPP npp, NPNURLVariable variable, const char *url,
 35956:                 const char *value, uint32_t len);
 35956: 
 35956: static NPError NP_CALLBACK
 35956: _getauthenticationinfo(NPP npp, const char *protocol,
 35956:                        const char *host, int32_t port,
 35956:                        const char *scheme, const char *realm,
 35956:                        char **username, uint32_t *ulen,
 35956:                        char **password, uint32_t *plen);
 35956: 
 35956: static uint32_t NP_CALLBACK
 35956: _scheduletimer(NPP instance, uint32_t interval, NPBool repeat,
 35956:                void (*timerFunc)(NPP npp, uint32_t timerID));
 35956: 
 35956: static void NP_CALLBACK
 35956: _unscheduletimer(NPP instance, uint32_t timerID);
 35956: 
 35956: static NPError NP_CALLBACK
 35956: _popupcontextmenu(NPP instance, NPMenu* menu);
 35956: 
 35956: static NPBool NP_CALLBACK
 35956: _convertpoint(NPP instance, 
 35956:               double sourceX, double sourceY, NPCoordinateSpace sourceSpace,
 35956:               double *destX, double *destY, NPCoordinateSpace destSpace);
 35740: 
 60021: static void NP_CALLBACK
 60021: _urlredirectresponse(NPP instance, void* notifyData, NPBool allow);
 60021: 
 93035: static NPError NP_CALLBACK
 93035: _initasyncsurface(NPP instance, NPSize *size,
 93035:                   NPImageFormat format, void *initData,
 93035:                   NPAsyncSurface *surface);
 93035: 
 93035: static NPError NP_CALLBACK
 93035: _finalizeasyncsurface(NPP instance, NPAsyncSurface *surface);
 93035: 
 93035: static void NP_CALLBACK
 93035: _setcurrentasyncsurface(NPP instance, NPAsyncSurface *surface, NPRect *changed);
 93035: 
 36125: } /* namespace child */
 36125: } /* namespace plugins */
 36125: } /* namespace mozilla */
 35740: 
 35893: const NPNetscapeFuncs PluginModuleChild::sBrowserFuncs = {
 35740:     sizeof(sBrowserFuncs),
 35740:     (NP_VERSION_MAJOR << 8) + NP_VERSION_MINOR,
 36125:     mozilla::plugins::child::_geturl,
 36125:     mozilla::plugins::child::_posturl,
 36125:     mozilla::plugins::child::_requestread,
 36125:     mozilla::plugins::child::_newstream,
 36125:     mozilla::plugins::child::_write,
 36125:     mozilla::plugins::child::_destroystream,
 36125:     mozilla::plugins::child::_status,
 36125:     mozilla::plugins::child::_useragent,
 36125:     mozilla::plugins::child::_memalloc,
 36125:     mozilla::plugins::child::_memfree,
 36125:     mozilla::plugins::child::_memflush,
 36125:     mozilla::plugins::child::_reloadplugins,
 36125:     mozilla::plugins::child::_getjavaenv,
 36125:     mozilla::plugins::child::_getjavapeer,
 36125:     mozilla::plugins::child::_geturlnotify,
 36125:     mozilla::plugins::child::_posturlnotify,
 36125:     mozilla::plugins::child::_getvalue,
 36125:     mozilla::plugins::child::_setvalue,
 36125:     mozilla::plugins::child::_invalidaterect,
 36125:     mozilla::plugins::child::_invalidateregion,
 36125:     mozilla::plugins::child::_forceredraw,
 39742:     PluginModuleChild::NPN_GetStringIdentifier,
 39742:     PluginModuleChild::NPN_GetStringIdentifiers,
 39742:     PluginModuleChild::NPN_GetIntIdentifier,
 39742:     PluginModuleChild::NPN_IdentifierIsString,
 39742:     PluginModuleChild::NPN_UTF8FromIdentifier,
 39742:     PluginModuleChild::NPN_IntFromIdentifier,
 37477:     PluginModuleChild::NPN_CreateObject,
 37477:     PluginModuleChild::NPN_RetainObject,
 37477:     PluginModuleChild::NPN_ReleaseObject,
 36125:     mozilla::plugins::child::_invoke,
 36125:     mozilla::plugins::child::_invokedefault,
 36125:     mozilla::plugins::child::_evaluate,
 36125:     mozilla::plugins::child::_getproperty,
 36125:     mozilla::plugins::child::_setproperty,
 36125:     mozilla::plugins::child::_removeproperty,
 36125:     mozilla::plugins::child::_hasproperty,
 36125:     mozilla::plugins::child::_hasmethod,
 36125:     mozilla::plugins::child::_releasevariantvalue,
 36125:     mozilla::plugins::child::_setexception,
 36125:     mozilla::plugins::child::_pushpopupsenabledstate,
 36125:     mozilla::plugins::child::_poppopupsenabledstate,
 36125:     mozilla::plugins::child::_enumerate,
 36125:     mozilla::plugins::child::_pluginthreadasynccall,
 36125:     mozilla::plugins::child::_construct,
 36125:     mozilla::plugins::child::_getvalueforurl,
 36125:     mozilla::plugins::child::_setvalueforurl,
 36125:     mozilla::plugins::child::_getauthenticationinfo,
 36125:     mozilla::plugins::child::_scheduletimer,
 36125:     mozilla::plugins::child::_unscheduletimer,
 36125:     mozilla::plugins::child::_popupcontextmenu,
 57157:     mozilla::plugins::child::_convertpoint,
 57157:     NULL, // handleevent, unimplemented
 57157:     NULL, // unfocusinstance, unimplemented
 93035:     mozilla::plugins::child::_urlredirectresponse,
 93035:     mozilla::plugins::child::_initasyncsurface,
 93035:     mozilla::plugins::child::_finalizeasyncsurface,
 93035:     mozilla::plugins::child::_setcurrentasyncsurface
 35740: };
 35740: 
 35919: PluginInstanceChild*
 35740: InstCast(NPP aNPP)
 35740: {
 35968:     NS_ABORT_IF_FALSE(!!(aNPP->ndata), "nil instance");
 35919:     return static_cast<PluginInstanceChild*>(aNPP->ndata);
 35740: }
 35740: 
 36125: namespace mozilla {
 36125: namespace plugins {
 36125: namespace child {
 36125: 
 35740: NPError NP_CALLBACK
 35944: _requestread(NPStream* aStream,
 35740:              NPByteRange* aRangeList)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD(NPERR_INVALID_PARAM);
 35971: 
 35944:     BrowserStreamChild* bs =
 35944:         static_cast<BrowserStreamChild*>(static_cast<AStream*>(aStream->ndata));
 35944:     bs->EnsureCorrectStream(aStream);
 35944:     return bs->NPN_RequestRead(aRangeList);
 35740: }
 35740: 
 35740: NPError NP_CALLBACK
 35740: _geturlnotify(NPP aNPP,
 35740:               const char* aRelativeURL,
 35740:               const char* aTarget,
 35740:               void* aNotifyData)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD(NPERR_INVALID_PARAM);
 35919: 
 41490:     if (!aNPP) // NULL check for nspluginwrapper (bug 561690)
 41490:         return NPERR_INVALID_INSTANCE_ERROR;
 41490: 
 35940:     nsCString url = NullableString(aRelativeURL);
 36110:     StreamNotifyChild* sn = new StreamNotifyChild(url);
 36110: 
 35919:     NPError err;
 35919:     InstCast(aNPP)->CallPStreamNotifyConstructor(
 36110:         sn, url, NullableString(aTarget), false, nsCString(), false, &err);
 36110: 
 36110:     if (NPERR_NO_ERROR == err) {
 36110:         // If NPN_PostURLNotify fails, the parent will immediately send us
 36110:         // a PStreamNotifyDestructor, which should not call NPP_URLNotify.
 36110:         sn->SetValid(aNotifyData);
 36110:     }
 36110: 
 35919:     return err;
 35740: }
 35740: 
 35740: NPError NP_CALLBACK
 35740: _getvalue(NPP aNPP,
 35740:           NPNVariable aVariable,
 35740:           void* aValue)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD(NPERR_INVALID_PARAM);
 36125: 
 36125:     switch (aVariable) {
 37886:         // Copied from nsNPAPIPlugin.cpp
 37886:         case NPNVToolkit:
103111: #if defined(MOZ_WIDGET_GTK) || defined(MOZ_WIDGET_QT)
 37886:             *static_cast<NPNToolkitType*>(aValue) = NPNVGtk2;
 37886:             return NPERR_NO_ERROR;
 37886: #endif
 37886:             return NPERR_GENERIC_ERROR;
 37886: 
 36125:         case NPNVjavascriptEnabledBool: // Intentional fall-through
 36125:         case NPNVasdEnabledBool: // Intentional fall-through
 36125:         case NPNVisOfflineBool: // Intentional fall-through
 36125:         case NPNVSupportsXEmbedBool: // Intentional fall-through
 97311:         case NPNVSupportsWindowless: { // Intentional fall-through
 36125:             NPError result;
 36125:             bool value;
 36125:             PluginModuleChild::current()->
 36125:                 CallNPN_GetValue_WithBoolReturn(aVariable, &result, &value);
 36125:             *(NPBool*)aValue = value ? true : false;
 36125:             return result;
 36125:         }
107139: #if defined(MOZ_WIDGET_GTK)
107139:         case NPNVxDisplay: {
107139:             if (aNPP) {
107139:                 return InstCast(aNPP)->NPN_GetValue(aVariable, aValue);
107139:             } 
107139:             else {
107139:                 *(void **)aValue = xt_client_get_display();
107139:             }          
107139:             return NPERR_NO_ERROR;
107139:         }
107139:         case NPNVxtAppContext:
107139:             return NPERR_GENERIC_ERROR;
107139: #endif
 36125:         default: {
 36125:             if (aNPP) {
 35919:                 return InstCast(aNPP)->NPN_GetValue(aVariable, aValue);
 35740:             }
 35740: 
 36125:             NS_WARNING("Null NPP!");
 36125:             return NPERR_INVALID_INSTANCE_ERROR;
 36125:         }
 36125:     }
 36125: 
 36125:     NS_NOTREACHED("Shouldn't get here!");
 36125:     return NPERR_GENERIC_ERROR;
 36125: }
 35740: 
 35740: NPError NP_CALLBACK
 35740: _setvalue(NPP aNPP,
 35740:           NPPVariable aVariable,
 35740:           void* aValue)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD(NPERR_INVALID_PARAM);
 35951:     return InstCast(aNPP)->NPN_SetValue(aVariable, aValue);
 35740: }
 35740: 
 35740: NPError NP_CALLBACK
 35740: _geturl(NPP aNPP,
 35740:         const char* aRelativeURL,
 35740:         const char* aTarget)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD(NPERR_INVALID_PARAM);
 35971: 
 35919:     NPError err;
 35940:     InstCast(aNPP)->CallNPN_GetURL(NullableString(aRelativeURL),
 35940:                                    NullableString(aTarget), &err);
 35919:     return err;
 35740: }
 35740: 
 35740: NPError NP_CALLBACK
 35740: _posturlnotify(NPP aNPP,
 35740:                const char* aRelativeURL,
 35740:                const char* aTarget,
 35740:                uint32_t aLength,
 35740:                const char* aBuffer,
 35740:                NPBool aIsFile,
 35740:                void* aNotifyData)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD(NPERR_INVALID_PARAM);
 35919: 
 36110:     if (!aBuffer)
 36110:         return NPERR_INVALID_PARAM;
 36110: 
 35940:     nsCString url = NullableString(aRelativeURL);
 36110:     StreamNotifyChild* sn = new StreamNotifyChild(url);
 36110: 
 35919:     NPError err;
 36110:     InstCast(aNPP)->CallPStreamNotifyConstructor(
 36110:         sn, url, NullableString(aTarget), true,
 36110:         nsCString(aBuffer, aLength), aIsFile, &err);
 35978: 
 36110:     if (NPERR_NO_ERROR == err) {
 36110:         // If NPN_PostURLNotify fails, the parent will immediately send us
 36110:         // a PStreamNotifyDestructor, which should not call NPP_URLNotify.
 36110:         sn->SetValid(aNotifyData);
 36110:     }
 35978: 
 35919:     return err;
 35740: }
 35740: 
 35740: NPError NP_CALLBACK
 35740: _posturl(NPP aNPP,
 35740:          const char* aRelativeURL,
 35740:          const char* aTarget,
 35740:          uint32_t aLength,
 35740:          const char* aBuffer,
 35740:          NPBool aIsFile)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD(NPERR_INVALID_PARAM);
 35971: 
 35919:     NPError err;
 35940:     // FIXME what should happen when |aBuffer| is null?
 35940:     InstCast(aNPP)->CallNPN_PostURL(NullableString(aRelativeURL),
 35940:                                     NullableString(aTarget),
 35919:                                     nsDependentCString(aBuffer, aLength),
 35919:                                     aIsFile, &err);
 35919:     return err;
 35740: }
 35740: 
 35740: NPError NP_CALLBACK
 35740: _newstream(NPP aNPP,
 35740:            NPMIMEType aMIMEType,
 35740:            const char* aWindow,
 35740:            NPStream** aStream)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD(NPERR_INVALID_PARAM);
 35938:     return InstCast(aNPP)->NPN_NewStream(aMIMEType, aWindow, aStream);
 35740: }
 35740: 
 35740: int32_t NP_CALLBACK
 35740: _write(NPP aNPP,
 35740:        NPStream* aStream,
 35740:        int32_t aLength,
 35740:        void* aBuffer)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD(0);
 35971: 
 35938:     PluginStreamChild* ps =
 35938:         static_cast<PluginStreamChild*>(static_cast<AStream*>(aStream->ndata));
 35938:     ps->EnsureCorrectInstance(InstCast(aNPP));
 35938:     ps->EnsureCorrectStream(aStream);
 35938:     return ps->NPN_Write(aLength, aBuffer);
 35740: }
 35740: 
 35740: NPError NP_CALLBACK
 35740: _destroystream(NPP aNPP,
 35919:                NPStream* aStream,
 35740:                NPError aReason)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD(NPERR_INVALID_PARAM);
 35971: 
 35919:     PluginInstanceChild* p = InstCast(aNPP);
 35938:     AStream* s = static_cast<AStream*>(aStream->ndata);
 35938:     if (s->IsBrowserStream()) {
 35938:         BrowserStreamChild* bs = static_cast<BrowserStreamChild*>(s);
 35919:         bs->EnsureCorrectInstance(p);
 39282:         bs->NPN_DestroyStream(aReason);
 35938:     }
 35938:     else {
 35938:         PluginStreamChild* ps = static_cast<PluginStreamChild*>(s);
 35938:         ps->EnsureCorrectInstance(p);
 36138:         PPluginStreamChild::Call__delete__(ps, aReason, false);
 35938:     }
 35740:     return NPERR_NO_ERROR;
 35740: }
 35740: 
 35740: void NP_CALLBACK
 35740: _status(NPP aNPP,
 35740:         const char* aMessage)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD_VOID();
 39785:     NS_WARNING("Not yet implemented!");
 35740: }
 35740: 
 35740: void NP_CALLBACK
 35740: _memfree(void* aPtr)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     // Only assert plugin thread here for consistency with in-process plugins.
 35971:     AssertPluginThread();
 35740:     NS_Free(aPtr);
 35740: }
 35740: 
 35740: uint32_t NP_CALLBACK
 35740: _memflush(uint32_t aSize)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     // Only assert plugin thread here for consistency with in-process plugins.
 35971:     AssertPluginThread();
 35740:     return 0;
 35740: }
 35740: 
 35740: void NP_CALLBACK
 35740: _reloadplugins(NPBool aReloadPages)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD_VOID();
 99801: 
 99801:     PluginModuleChild::current()->SendNPN_ReloadPlugins(!!aReloadPages);
 35740: }
 35740: 
 35740: void NP_CALLBACK
 35740: _invalidaterect(NPP aNPP,
 35740:                 NPRect* aInvalidRect)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD_VOID();
 38717:     // NULL check for nspluginwrapper (bug 548434)
 38717:     if (aNPP) {
 36835:         InstCast(aNPP)->InvalidateRect(aInvalidRect);
 35740:     }
 38717: }
 35740: 
 35740: void NP_CALLBACK
 35740: _invalidateregion(NPP aNPP,
 35740:                   NPRegion aInvalidRegion)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD_VOID();
 39785:     NS_WARNING("Not yet implemented!");
 35740: }
 35740: 
 35740: void NP_CALLBACK
 35740: _forceredraw(NPP aNPP)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD_VOID();
 40032: 
 40032:     // We ignore calls to NPN_ForceRedraw. Such calls should
 40032:     // never be necessary.
 35740: }
 35740: 
 35740: const char* NP_CALLBACK
 35740: _useragent(NPP aNPP)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
106838:     ENSURE_PLUGIN_THREAD(nullptr);
 36099:     return PluginModuleChild::current()->GetUserAgent();
 35740: }
 35740: 
 35740: void* NP_CALLBACK
 35740: _memalloc(uint32_t aSize)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     // Only assert plugin thread here for consistency with in-process plugins.
 35971:     AssertPluginThread();
 35740:     return NS_Alloc(aSize);
 35740: }
 35740: 
 35740: // Deprecated entry points for the old Java plugin.
 35740: void* NP_CALLBACK /* OJI type: JRIEnv* */
 35740: _getjavaenv(void)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 35740:     return 0;
 35740: }
 35740: 
 35740: void* NP_CALLBACK /* OJI type: jref */
 35740: _getjavapeer(NPP aNPP)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 35740:     return 0;
 35740: }
 35740: 
 35740: bool NP_CALLBACK
 35740: _invoke(NPP aNPP,
 35740:         NPObject* aNPObj,
 35740:         NPIdentifier aMethod,
 35740:         const NPVariant* aArgs,
 35740:         uint32_t aArgCount,
 35740:         NPVariant* aResult)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD(false);
 35965: 
 35965:     if (!aNPP || !aNPObj || !aNPObj->_class || !aNPObj->_class->invoke)
 35740:         return false;
 35965: 
 35965:     return aNPObj->_class->invoke(aNPObj, aMethod, aArgs, aArgCount, aResult);
 35740: }
 35740: 
 35740: bool NP_CALLBACK
 35740: _invokedefault(NPP aNPP,
 35740:                NPObject* aNPObj,
 35740:                const NPVariant* aArgs,
 35740:                uint32_t aArgCount,
 35740:                NPVariant* aResult)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD(false);
 35965: 
 35965:     if (!aNPP || !aNPObj || !aNPObj->_class || !aNPObj->_class->invokeDefault)
 35740:         return false;
 35965: 
 35965:     return aNPObj->_class->invokeDefault(aNPObj, aArgs, aArgCount, aResult);
 35740: }
 35740: 
 35740: bool NP_CALLBACK
 35740: _evaluate(NPP aNPP,
 35983:           NPObject* aObject,
 35740:           NPString* aScript,
 35740:           NPVariant* aResult)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD(false);
 35971: 
 35983:     if (!(aNPP && aObject && aScript && aResult)) {
 35983:         NS_ERROR("Bad arguments!");
 35740:         return false;
 35740:     }
 35740: 
 35983:     PluginScriptableObjectChild* actor =
 35983:       InstCast(aNPP)->GetActorForNPObject(aObject);
 35983:     if (!actor) {
 35983:         NS_ERROR("Failed to create actor?!");
 35983:         return false;
 35983:     }
 35983: 
 42416: #ifdef XP_WIN
 42416:     if (gDelayFlashFocusReplyUntilEval) {
 42416:         ReplyMessage(0);
 42416:         gDelayFlashFocusReplyUntilEval = false;
 42416:     }
 42416: #endif
 42416: 
 35983:     return actor->Evaluate(aScript, aResult);
 35983: }
 35983: 
 35740: bool NP_CALLBACK
 35740: _getproperty(NPP aNPP,
 35740:              NPObject* aNPObj,
 35740:              NPIdentifier aPropertyName,
 35740:              NPVariant* aResult)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD(false);
 35965: 
 35965:     if (!aNPP || !aNPObj || !aNPObj->_class || !aNPObj->_class->getProperty)
 35740:         return false;
 35965: 
 35965:     return aNPObj->_class->getProperty(aNPObj, aPropertyName, aResult);
 35740: }
 35740: 
 35740: bool NP_CALLBACK
 35740: _setproperty(NPP aNPP,
 35740:              NPObject* aNPObj,
 35740:              NPIdentifier aPropertyName,
 35740:              const NPVariant* aValue)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD(false);
 35965: 
 35965:     if (!aNPP || !aNPObj || !aNPObj->_class || !aNPObj->_class->setProperty)
 35740:         return false;
 35965: 
 35965:     return aNPObj->_class->setProperty(aNPObj, aPropertyName, aValue);
 35740: }
 35740: 
 35740: bool NP_CALLBACK
 35740: _removeproperty(NPP aNPP,
 35740:                 NPObject* aNPObj,
 35740:                 NPIdentifier aPropertyName)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD(false);
 35965: 
 35965:     if (!aNPP || !aNPObj || !aNPObj->_class || !aNPObj->_class->removeProperty)
 35740:         return false;
 35965: 
 35965:     return aNPObj->_class->removeProperty(aNPObj, aPropertyName);
 35740: }
 35740: 
 35740: bool NP_CALLBACK
 35740: _hasproperty(NPP aNPP,
 35740:              NPObject* aNPObj,
 35740:              NPIdentifier aPropertyName)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD(false);
 35965: 
 35965:     if (!aNPP || !aNPObj || !aNPObj->_class || !aNPObj->_class->hasProperty)
 35740:         return false;
 35965: 
 35965:     return aNPObj->_class->hasProperty(aNPObj, aPropertyName);
 35740: }
 35740: 
 35740: bool NP_CALLBACK
 35740: _hasmethod(NPP aNPP,
 35740:            NPObject* aNPObj,
 35740:            NPIdentifier aMethodName)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD(false);
 35965: 
 35965:     if (!aNPP || !aNPObj || !aNPObj->_class || !aNPObj->_class->hasMethod)
 35740:         return false;
 35965: 
 35965:     return aNPObj->_class->hasMethod(aNPObj, aMethodName);
 35740: }
 35740: 
 35740: bool NP_CALLBACK
 35740: _enumerate(NPP aNPP,
 35740:            NPObject* aNPObj,
 35740:            NPIdentifier** aIdentifiers,
 35740:            uint32_t* aCount)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD(false);
 35965: 
 35965:     if (!aNPP || !aNPObj || !aNPObj->_class)
 35740:         return false;
 35965: 
 35965:     if (!NP_CLASS_STRUCT_VERSION_HAS_ENUM(aNPObj->_class) ||
 35965:         !aNPObj->_class->enumerate) {
 35965:         *aIdentifiers = 0;
 35965:         *aCount = 0;
 35965:         return true;
 35965:     }
 35965: 
 35965:     return aNPObj->_class->enumerate(aNPObj, aIdentifiers, aCount);
 35740: }
 35740: 
 35740: bool NP_CALLBACK
 35740: _construct(NPP aNPP,
 35740:            NPObject* aNPObj,
 35740:            const NPVariant* aArgs,
 35740:            uint32_t aArgCount,
 35740:            NPVariant* aResult)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD(false);
 35965: 
 35965:     if (!aNPP || !aNPObj || !aNPObj->_class ||
 35965:         !NP_CLASS_STRUCT_VERSION_HAS_CTOR(aNPObj->_class) ||
 35965:         !aNPObj->_class->construct) {
 35740:         return false;
 35740:     }
 35740: 
 35965:     return aNPObj->_class->construct(aNPObj, aArgs, aArgCount, aResult);
 35965: }
 35965: 
 35740: void NP_CALLBACK
 35740: _releasevariantvalue(NPVariant* aVariant)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     // Only assert plugin thread here for consistency with in-process plugins.
 35971:     AssertPluginThread();
 35971: 
 35965:     if (NPVARIANT_IS_STRING(*aVariant)) {
 35965:         NPString str = NPVARIANT_TO_STRING(*aVariant);
 35965:         free(const_cast<NPUTF8*>(str.UTF8Characters));
 35965:     }
 35965:     else if (NPVARIANT_IS_OBJECT(*aVariant)) {
 35965:         NPObject* object = NPVARIANT_TO_OBJECT(*aVariant);
 35965:         if (object) {
 37477:             PluginModuleChild::NPN_ReleaseObject(object);
 35965:         }
 35965:     }
 35965:     VOID_TO_NPVARIANT(*aVariant);
 35740: }
 35740: 
 35740: void NP_CALLBACK
 35740: _setexception(NPObject* aNPObj,
 35740:               const NPUTF8* aMessage)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39785:     ENSURE_PLUGIN_THREAD_VOID();
 74398: 
 74398:     PluginModuleChild* self = PluginModuleChild::current();
 74398:     PluginScriptableObjectChild* actor = NULL;
 74398:     if (aNPObj) {
 74398:         actor = self->GetActorForNPObject(aNPObj);
 74398:         if (!actor) {
 74398:             NS_ERROR("Failed to get actor!");
 74398:             return;
 74398:         }
 74398:     }
 74398: 
 74398:     self->SendNPN_SetException(static_cast<PPluginScriptableObjectChild*>(actor),
 74398:                                NullableString(aMessage));
 35740: }
 35740: 
 39850: void NP_CALLBACK
 35740: _pushpopupsenabledstate(NPP aNPP,
 35740:                         NPBool aEnabled)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39850:     ENSURE_PLUGIN_THREAD_VOID();
 39785: 
 39850:     InstCast(aNPP)->CallNPN_PushPopupsEnabledState(aEnabled ? true : false);
 35740: }
 35740: 
 39850: void NP_CALLBACK
 35740: _poppopupsenabledstate(NPP aNPP)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 39850:     ENSURE_PLUGIN_THREAD_VOID();
 39785: 
 39850:     InstCast(aNPP)->CallNPN_PopPopupsEnabledState();
 35740: }
 35740: 
 35740: void NP_CALLBACK
 35740: _pluginthreadasynccall(NPP aNPP,
 35740:                        PluginThreadCallback aFunc,
 35740:                        void* aUserData)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 36305:     if (!aFunc)
 36305:         return;
 36305: 
 39979:     InstCast(aNPP)->AsyncCall(aFunc, aUserData);
 35740: }
 35740: 
 35956: NPError NP_CALLBACK
 35956: _getvalueforurl(NPP npp, NPNURLVariable variable, const char *url,
 35956:                 char **value, uint32_t *len)
 35956: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 35971:     AssertPluginThread();
 37332: 
 37332:     if (!url)
 37332:         return NPERR_INVALID_URL;
 37332: 
 37332:     if (!npp || !value || !len)
 37332:         return NPERR_INVALID_PARAM;
 37332: 
 37332:     switch (variable) {
 37332:     case NPNURLVCookie:
 37332:     case NPNURLVProxy:
 37332:         nsCString v;
 37332:         NPError result;
 37332:         InstCast(npp)->
 37332:             CallNPN_GetValueForURL(variable, nsCString(url), &v, &result);
 37332:         if (NPERR_NO_ERROR == result) {
 37332:             *value = ToNewCString(v);
 37332:             *len = v.Length();
 37332:         }
 37332:         return result;
 37332:     }
 37332: 
 37332:     return NPERR_INVALID_PARAM;
 35956: }
 35956: 
 35956: NPError NP_CALLBACK
 35956: _setvalueforurl(NPP npp, NPNURLVariable variable, const char *url,
 35956:                 const char *value, uint32_t len)
 35956: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 35971:     AssertPluginThread();
 37332: 
 37332:     if (!value)
 37332:         return NPERR_INVALID_PARAM;
 37332: 
 37332:     if (!url)
 37332:         return NPERR_INVALID_URL;
 37332: 
 37332:     switch (variable) {
 37332:     case NPNURLVCookie:
 37332:     case NPNURLVProxy:
 37332:         NPError result;
 37332:         InstCast(npp)->CallNPN_SetValueForURL(variable, nsCString(url),
 37332:                                               nsDependentCString(value, len),
 37332:                                               &result);
 37332:         return result;
 37332:     }
 37332: 
 37332:     return NPERR_INVALID_PARAM;
 35956: }
 35956: 
 35956: NPError NP_CALLBACK
 35956: _getauthenticationinfo(NPP npp, const char *protocol,
 35956:                        const char *host, int32_t port,
 35956:                        const char *scheme, const char *realm,
 35956:                        char **username, uint32_t *ulen,
 35956:                        char **password, uint32_t *plen)
 35956: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 35971:     AssertPluginThread();
 37332: 
 37332:     if (!protocol || !host || !scheme || !realm || !username || !ulen ||
 37332:         !password || !plen)
 37332:         return NPERR_INVALID_PARAM;
 37332: 
 37332:     nsCString u;
 37332:     nsCString p;
 37332:     NPError result;
 37332:     InstCast(npp)->
 37332:         CallNPN_GetAuthenticationInfo(nsDependentCString(protocol),
 37332:                                       nsDependentCString(host),
 37332:                                       port,
 37332:                                       nsDependentCString(scheme),
 37332:                                       nsDependentCString(realm),
 37332:                                       &u, &p, &result);
 37332:     if (NPERR_NO_ERROR == result) {
 37332:         *username = ToNewCString(u);
 37332:         *ulen = u.Length();
 37332:         *password = ToNewCString(p);
 37332:         *plen = p.Length();
 37332:     }
 37332:     return result;
 35956: }
 35956: 
 35956: uint32_t NP_CALLBACK
 37348: _scheduletimer(NPP npp, uint32_t interval, NPBool repeat,
 35956:                void (*timerFunc)(NPP npp, uint32_t timerID))
 35956: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 35971:     AssertPluginThread();
 37348:     return InstCast(npp)->ScheduleTimer(interval, repeat, timerFunc);
 35956: }
 35956: 
 35956: void NP_CALLBACK
 37348: _unscheduletimer(NPP npp, uint32_t timerID)
 35956: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 35971:     AssertPluginThread();
 37348:     InstCast(npp)->UnscheduleTimer(timerID);
 35956: }
 35956: 
 48383: 
 48383: #ifdef OS_MACOSX
 48383: static void ProcessBrowserEvents(void* pluginModule) {
 48383:     PluginModuleChild* pmc = static_cast<PluginModuleChild*>(pluginModule);
 48383: 
 48383:     if (!pmc)
 48383:         return;
 48383: 
 48383:     pmc->CallProcessSomeEvents();
 48383: }
 48383: #endif
 48383: 
 35956: NPError NP_CALLBACK
 35956: _popupcontextmenu(NPP instance, NPMenu* menu)
 35956: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 35971:     AssertPluginThread();
 48383: 
 72514: #ifdef MOZ_WIDGET_COCOA
 48383:     double pluginX, pluginY; 
 48383:     double screenX, screenY;
 48383: 
 48383:     const NPCocoaEvent* currentEvent = InstCast(instance)->getCurrentEvent();
 48383:     if (!currentEvent) {
 35956:         return NPERR_GENERIC_ERROR;
 35956:     }
 35956: 
 48383:     // Ensure that the events has an x/y value.
 48383:     if (currentEvent->type != NPCocoaEventMouseDown    &&
 48383:         currentEvent->type != NPCocoaEventMouseUp      &&
 48383:         currentEvent->type != NPCocoaEventMouseMoved   &&
 48383:         currentEvent->type != NPCocoaEventMouseEntered &&
 48383:         currentEvent->type != NPCocoaEventMouseExited  &&
 48383:         currentEvent->type != NPCocoaEventMouseDragged) {
 48383:         return NPERR_GENERIC_ERROR;
 48383:     }
 48383: 
 48383:     pluginX = currentEvent->data.mouse.pluginX;
 48383:     pluginY = currentEvent->data.mouse.pluginY;
 48383: 
 48383:     if ((pluginX < 0.0) || (pluginY < 0.0))
 48383:         return NPERR_GENERIC_ERROR;
 48383: 
 48383:     NPBool success = _convertpoint(instance, 
 48383:                                   pluginX,  pluginY, NPCoordinateSpacePlugin, 
 48383:                                  &screenX, &screenY, NPCoordinateSpaceScreen);
 48383: 
 48383:     if (success) {
 48383:         return mozilla::plugins::PluginUtilsOSX::ShowCocoaContextMenu(menu,
 48383:                                     screenX, screenY,
 48383:                                     PluginModuleChild::current(),
 48383:                                     ProcessBrowserEvents);
 48383:     } else {
 48383:         NS_WARNING("Convertpoint failed, could not created contextmenu.");
 48383:         return NPERR_GENERIC_ERROR;
 48383:     }
 48383: 
 48383: #else
 48383:     NS_WARNING("Not supported on this platform!");
 48383:     return NPERR_GENERIC_ERROR;
 48383: #endif
 48383: }
 48383: 
 35956: NPBool NP_CALLBACK
 35956: _convertpoint(NPP instance, 
 35956:               double sourceX, double sourceY, NPCoordinateSpace sourceSpace,
 35956:               double *destX, double *destY, NPCoordinateSpace destSpace)
 35956: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
126567:     if (!IsPluginThread()) {
126567:         NS_WARNING("Not running on the plugin's main thread!");
126567:         return false;
126567:     }
 39885: 
 39885:     double rDestX = 0;
 39885:     bool ignoreDestX = !destX;
 39885:     double rDestY = 0;
 39885:     bool ignoreDestY = !destY;
 39885:     bool result = false;
 42507:     InstCast(instance)->CallNPN_ConvertPoint(sourceX, ignoreDestX, sourceY, ignoreDestY, sourceSpace, destSpace,
 42507:                                              &rDestX,  &rDestY, &result);
 39885:     if (result) {
 39885:         if (destX)
 39885:             *destX = rDestX;
 39885:         if (destY)
 39885:             *destY = rDestY;
 39885:     }
 39885: 
 39885:     return result;
 35956: }
 35956: 
 60021: void NP_CALLBACK
 60021: _urlredirectresponse(NPP instance, void* notifyData, NPBool allow)
 60021: {
 60021:     InstCast(instance)->NPN_URLRedirectResponse(notifyData, allow);
 60021: }
 60021: 
 93035: NPError NP_CALLBACK
 93035: _initasyncsurface(NPP instance, NPSize *size,
 93035:                   NPImageFormat format, void *initData,
 93035:                   NPAsyncSurface *surface)
 93035: {
 93035:     return InstCast(instance)->NPN_InitAsyncSurface(size, format, initData, surface);
 93035: }
 93035: 
 93035: NPError NP_CALLBACK
 93035: _finalizeasyncsurface(NPP instance, NPAsyncSurface *surface)
 93035: {
 93035:     return InstCast(instance)->NPN_FinalizeAsyncSurface(surface);
 93035: }
 93035: 
 93035: void NP_CALLBACK
 93035: _setcurrentasyncsurface(NPP instance, NPAsyncSurface *surface, NPRect *changed)
 93035: {
 93035:     InstCast(instance)->NPN_SetCurrentAsyncSurface(surface, changed);
 93035: }
 93035: 
 36125: } /* namespace child */
 36125: } /* namespace plugins */
 36125: } /* namespace mozilla */
 36125: 
 35956: //-----------------------------------------------------------------------------
 35740: 
 35926: bool
 60021: PluginModuleChild::AnswerNP_GetEntryPoints(NPError* _retval)
 60021: {
 60021:     PLUGIN_LOG_DEBUG_METHOD;
 60021:     AssertPluginThread();
 60021: 
110585: #if defined(OS_LINUX) || defined(OS_BSD)
 60021:     return true;
 60021: #elif defined(OS_WIN) || defined(OS_MACOSX)
 60021:     *_retval = mGetEntryPointsFunc(&mFunctions);
 60021:     return true;
 60021: #else
 60021: #  error Please implement me for your platform
 60021: #endif
 60021: }
 60021: 
 60021: bool
 93035: PluginModuleChild::AnswerNP_Initialize(const uint32_t& aFlags, NPError* _retval)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_METHOD;
 35971:     AssertPluginThread();
 35740: 
 93035:     mAsyncDrawingAllowed = aFlags & kAllowAsyncDrawing;
 93035: 
 41651: #ifdef OS_WIN
 42136:     SetEventHooks();
 41651: #endif
 41651: 
 57138: #ifdef MOZ_X11
108503:     // Send the parent our X socket to act as a proxy reference for our X
108503:     // resources.
 57138:     int xSocketFd = ConnectionNumber(DefaultXDisplay());
108503:     SendBackUpXResources(FileDescriptor(xSocketFd));
 57138: #endif
 57138: 
110585: #if defined(OS_LINUX) || defined(OS_BSD)
 35748:     *_retval = mInitializeFunc(&sBrowserFuncs, &mFunctions);
 35926:     return true;
 60021: #elif defined(OS_WIN) || defined(OS_MACOSX)
 39877:     *_retval = mInitializeFunc(&sBrowserFuncs);
 39877:     return true;
 35740: #else
 35740: #  error Please implement me for your platform
 35740: #endif
 35740: }
 35740: 
 39742: PPluginIdentifierChild*
 39742: PluginModuleChild::AllocPPluginIdentifier(const nsCString& aString,
 72341:                                           const int32_t& aInt,
 72341:                                           const bool& aTemporary)
 39742: {
 72341:     // We cannot call SetPermanent within this function because Manager() isn't
 72341:     // set up yet.
 72341:     if (aString.IsVoid()) {
 72341:         return new PluginIdentifierChildInt(aInt);
 72341:     }
 72341:     return new PluginIdentifierChildString(aString);
 72341: }
 71928: 
 72341: bool
 72341: PluginModuleChild::RecvPPluginIdentifierConstructor(PPluginIdentifierChild* actor,
 72341:                                                     const nsCString& aString,
 72341:                                                     const int32_t& aInt,
 72341:                                                     const bool& aTemporary)
 72341: {
 72341:     if (!aTemporary) {
 72341:         static_cast<PluginIdentifierChild*>(actor)->MakePermanent();
 71927:     }
 72341:     return true;
 39742: }
 39742: 
 39742: bool
 39742: PluginModuleChild::DeallocPPluginIdentifier(PPluginIdentifierChild* aActor)
 39742: {
 39742:     delete aActor;
 39742:     return true;
 39742: }
 39742: 
 58736: #if defined(XP_WIN)
 58736: BOOL WINAPI
 58736: PMCGetWindowInfoHook(HWND hWnd, PWINDOWINFO pwi)
 58736: {
 58736:   if (!pwi)
 58736:       return FALSE;
 58736: 
 58736:   if (!sGetWindowInfoPtrStub) {
 58736:      NS_ASSERTION(FALSE, "Something is horribly wrong in PMCGetWindowInfoHook!");
 58736:      return FALSE;
 58736:   }
 58736: 
 58736:   if (!sBrowserHwnd) {
 58736:       PRUnichar szClass[20];
 80467:       if (GetClassNameW(hWnd, szClass, ArrayLength(szClass)) &&
 58736:           !wcscmp(szClass, kMozillaWindowClass)) {
 58736:           sBrowserHwnd = hWnd;
 58736:       }
 58736:   }
 58736:   // Oddity: flash does strange rect comparisons for mouse input destined for
 58736:   // it's internal settings window. Post removing sub widgets for tabs, touch
 58736:   // this up so they get the rect they expect.
 58736:   // XXX potentially tie this to a specific major version?
 58736:   BOOL result = sGetWindowInfoPtrStub(hWnd, pwi);
 58736:   if (sBrowserHwnd && sBrowserHwnd == hWnd)
 58736:       pwi->rcWindow = pwi->rcClient;
 58736:   return result;
 58736: }
 58736: #endif
 58736: 
 35898: PPluginInstanceChild*
 35943: PluginModuleChild::AllocPPluginInstance(const nsCString& aMimeType,
 35740:                                         const uint16_t& aMode,
 57141:                                         const InfallibleTArray<nsCString>& aNames,
 57141:                                         const InfallibleTArray<nsCString>& aValues,
 35746:                                         NPError* rv)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_METHOD;
 35971:     AssertPluginThread();
 35740: 
 58734:     InitQuirksModes(aMimeType);
 58734: 
 58736: #ifdef XP_WIN
 77706:     if ((mQuirks & QUIRK_FLASH_HOOK_GETWINDOWINFO) &&
 77706:         !sGetWindowInfoPtrStub) {
 58736:         sUser32Intercept.Init("user32.dll");
 69198:         sUser32Intercept.AddHook("GetWindowInfo", reinterpret_cast<intptr_t>(PMCGetWindowInfoHook),
 58736:                                  (void**) &sGetWindowInfoPtrStub);
 58736:     }
 58736: #endif
 58736: 
107139:     return new PluginInstanceChild(&mFunctions);
 35925: }
 35925: 
 58734: void
 58734: PluginModuleChild::InitQuirksModes(const nsCString& aMimeType)
 58734: {
 58734:     if (mQuirks != QUIRKS_NOT_INITIALIZED)
 58734:       return;
 58734:     mQuirks = 0;
 58734:     // application/x-silverlight
 58734:     // application/x-silverlight-2
 58734:     NS_NAMED_LITERAL_CSTRING(silverlight, "application/x-silverlight");
 58734:     if (FindInReadable(silverlight, aMimeType)) {
 58734:         mQuirks |= QUIRK_SILVERLIGHT_DEFAULT_TRANSPARENT;
 58734: #ifdef OS_WIN
 58734:         mQuirks |= QUIRK_WINLESS_TRACKPOPUP_HOOK;
 74375:         mQuirks |= QUIRK_SILVERLIGHT_FOCUS_CHECK_PARENT;
 58734: #endif
 58734:     }
 58734: 
 58734: #ifdef OS_WIN
 58734:     // application/x-shockwave-flash
 58734:     NS_NAMED_LITERAL_CSTRING(flash, "application/x-shockwave-flash");
 58734:     if (FindInReadable(flash, aMimeType)) {
 58734:         mQuirks |= QUIRK_WINLESS_TRACKPOPUP_HOOK;
 58734:         mQuirks |= QUIRK_FLASH_THROTTLE_WMUSER_EVENTS; 
 58734:         mQuirks |= QUIRK_FLASH_HOOK_SETLONGPTR;
 60621:         mQuirks |= QUIRK_FLASH_HOOK_GETWINDOWINFO;
 62644:         mQuirks |= QUIRK_FLASH_FIXUP_MOUSE_CAPTURE;
 58734:     }
 62842: 
 62842:     // QuickTime plugin usually loaded with audio/mpeg mimetype
 64609:     NS_NAMED_LITERAL_CSTRING(quicktime, "npqtplugin");
 62842:     if (FindInReadable(quicktime, mPluginFilename)) {
 62842:       mQuirks |= QUIRK_QUICKTIME_AVOID_SETWINDOW;
 62842:     }
 58734: #endif
 80957: 
 80957: #ifdef XP_MACOSX
 80957:     // Whitelist Flash and Quicktime to support offline renderer
 80957:     NS_NAMED_LITERAL_CSTRING(flash, "application/x-shockwave-flash");
 80957:     NS_NAMED_LITERAL_CSTRING(quicktime, "QuickTime Plugin.plugin");
127237:     if (FindInReadable(flash, aMimeType)) {
127237:       mQuirks |= QUIRK_FLASH_AVOID_CGMODE_CRASHES;
127237:     }
 80957:     if (FindInReadable(flash, aMimeType) ||
 80957:         FindInReadable(quicktime, mPluginFilename)) {
 80957:         mQuirks |= QUIRK_ALLOW_OFFLINE_RENDERER;
 80957:     }
 80957: #endif
 58734: }
 58734: 
 35926: bool
 35925: PluginModuleChild::AnswerPPluginInstanceConstructor(PPluginInstanceChild* aActor,
 35925:                                                     const nsCString& aMimeType,
 35925:                                                     const uint16_t& aMode,
 57141:                                                     const InfallibleTArray<nsCString>& aNames,
 57141:                                                     const InfallibleTArray<nsCString>& aValues,
 35925:                                                     NPError* rv)
 35925: {
 37099:     PLUGIN_LOG_DEBUG_METHOD;
 35971:     AssertPluginThread();
 35925: 
 35925:     PluginInstanceChild* childInstance =
 35925:         reinterpret_cast<PluginInstanceChild*>(aActor);
 35925:     NS_ASSERTION(childInstance, "Null actor!");
 35740: 
 35740:     // unpack the arguments into a C format
 35820:     int argc = aNames.Length();
 35820:     NS_ASSERTION(argc == (int) aValues.Length(),
 35740:                  "argn.length != argv.length");
 35740: 
 35820:     nsAutoArrayPtr<char*> argn(new char*[1 + argc]);
 35820:     nsAutoArrayPtr<char*> argv(new char*[1 + argc]);
 35740:     argn[argc] = 0;
 35740:     argv[argc] = 0;
 35740: 
 35740:     for (int i = 0; i < argc; ++i) {
 35940:         argn[i] = const_cast<char*>(NullableStringGet(aNames[i]));
 35940:         argv[i] = const_cast<char*>(NullableStringGet(aValues[i]));
 35740:     }
 35740: 
 35740:     NPP npp = childInstance->GetNPP();
 35740: 
 35740:     // FIXME/cjones: use SAFE_CALL stuff
 35940:     *rv = mFunctions.newp((char*)NullableStringGet(aMimeType),
 35740:                           npp,
 35740:                           aMode,
 35740:                           argc,
 35740:                           argn,
 35740:                           argv,
 35740:                           0);
 35746:     if (NPERR_NO_ERROR != *rv) {
 74326:         return true;
 35746:     }
 35740: 
107139:     childInstance->Initialize();
107139: 
 62564: #if defined(XP_MACOSX) && defined(__i386__)
 54520:     // If an i386 Mac OS X plugin has selected the Carbon event model then
 54520:     // we have to fail. We do not support putting Carbon event model plugins
 54520:     // out of process. Note that Carbon is the default model so out of process
 54520:     // plugins need to actively negotiate something else in order to work
 54520:     // out of process.
 54520:     if (childInstance->EventModel() == NPEventModelCarbon) {
 61864:       // Send notification that a plugin tried to negotiate Carbon NPAPI so that
 61864:       // users can be notified that restarting the browser in i386 mode may allow
 61864:       // them to use the plugin.
 61864:       childInstance->SendNegotiatedCarbon();
 61864: 
 61864:       // Fail to instantiate.
 54520:       *rv = NPERR_MODULE_LOAD_FAILED_ERROR;
 54520:     }
 54520: #endif
 54520: 
 35927:     return true;
 35746: }
 35746: 
 35926: bool
 36138: PluginModuleChild::DeallocPPluginInstance(PPluginInstanceChild* aActor)
 35746: {
 37099:     PLUGIN_LOG_DEBUG_METHOD;
 35971:     AssertPluginThread();
 35747: 
 35965:     delete aActor;
 35965: 
 35965:     return true;
 35965: }
 35965: 
 37477: NPObject* NP_CALLBACK
 37477: PluginModuleChild::NPN_CreateObject(NPP aNPP, NPClass* aClass)
 37477: {
 37477:     PLUGIN_LOG_DEBUG_FUNCTION;
106838:     ENSURE_PLUGIN_THREAD(nullptr);
 37477: 
 37477:     PluginInstanceChild* i = InstCast(aNPP);
 38669:     if (i->mDeletingHash) {
 38669:         NS_ERROR("Plugin used NPP after NPP_Destroy");
 38669:         return NULL;
 38669:     }
 37477: 
 37477:     NPObject* newObject;
 37477:     if (aClass && aClass->allocate) {
 37477:         newObject = aClass->allocate(aNPP, aClass);
 37477:     }
 37477:     else {
 37477:         newObject = reinterpret_cast<NPObject*>(child::_memalloc(sizeof(NPObject)));
 37477:     }
 37477: 
 37477:     if (newObject) {
 37477:         newObject->_class = aClass;
 37477:         newObject->referenceCount = 1;
 37477:         NS_LOG_ADDREF(newObject, 1, "NPObject", sizeof(NPObject));
 37477:     }
 37477: 
 37477:     NPObjectData* d = static_cast<PluginModuleChild*>(i->Manager())
 37477:         ->mObjectMap.PutEntry(newObject);
 37477:     NS_ASSERTION(!d->instance, "New NPObject already mapped?");
 37477:     d->instance = i;
 37477: 
 37477:     return newObject;
 37477: }
 37477: 
 37477: NPObject* NP_CALLBACK
 37477: PluginModuleChild::NPN_RetainObject(NPObject* aNPObj)
 37477: {
 37477:     AssertPluginThread();
 37477: 
 78436: #ifdef NS_BUILD_REFCNT_LOGGING
 78436:     int32_t refCnt =
 78436: #endif
 78436:     PR_ATOMIC_INCREMENT((int32_t*)&aNPObj->referenceCount);
 37477:     NS_LOG_ADDREF(aNPObj, refCnt, "NPObject", sizeof(NPObject));
 37477: 
 37477:     return aNPObj;
 37477: }
 37477: 
 37477: void NP_CALLBACK
 37477: PluginModuleChild::NPN_ReleaseObject(NPObject* aNPObj)
 37477: {
 37477:     AssertPluginThread();
 37477: 
 38669:     NPObjectData* d = current()->mObjectMap.GetEntry(aNPObj);
 38669:     if (!d) {
 38669:         NS_ERROR("Releasing object not in mObjectMap?");
 38669:         return;
 38669:     }
 38669: 
 38669:     DeletingObjectEntry* doe = NULL;
 38669:     if (d->instance->mDeletingHash) {
 38669:         doe = d->instance->mDeletingHash->GetEntry(aNPObj);
 38669:         if (!doe) {
 38669:             NS_ERROR("An object for a destroyed instance isn't in the instance deletion hash");
 38669:             return;
 38669:         }
 38669:         if (doe->mDeleted)
 38669:             return;
 38669:     }
 38669: 
 64101:     int32_t refCnt = PR_ATOMIC_DECREMENT((int32_t*)&aNPObj->referenceCount);
 37477:     NS_LOG_RELEASE(aNPObj, refCnt, "NPObject");
 37477: 
 37477:     if (refCnt == 0) {
 37477:         DeallocNPObject(aNPObj);
 38669:         if (doe)
 38669:             doe->mDeleted = true;
 37477:     }
 37477:     return;
 37477: }
 37477: 
 37477: void
 37477: PluginModuleChild::DeallocNPObject(NPObject* aNPObj)
 37477: {
 37477:     if (aNPObj->_class && aNPObj->_class->deallocate) {
 37477:         aNPObj->_class->deallocate(aNPObj);
 37477:     } else {
 37477:         child::_memfree(aNPObj);
 37477:     }
 38669: 
 38669:     NPObjectData* d = current()->mObjectMap.GetEntry(aNPObj);
 38669:     if (d->actor)
 38669:         d->actor->NPObjectDestroyed();
 38669: 
 38669:     current()->mObjectMap.RemoveEntry(aNPObj);
 38669: }
 38669: 
 38669: void
 38669: PluginModuleChild::FindNPObjectsForInstance(PluginInstanceChild* instance)
 38669: {
 38669:     NS_ASSERTION(instance->mDeletingHash, "filling null mDeletingHash?");
 38669:     mObjectMap.EnumerateEntries(CollectForInstance, instance);
 37477: }
 37477: 
 37477: PLDHashOperator
 38669: PluginModuleChild::CollectForInstance(NPObjectData* d, void* userArg)
 37477: {
 38669:     PluginInstanceChild* instance = static_cast<PluginInstanceChild*>(userArg);
 38669:     if (d->instance == instance) {
 37477:         NPObject* o = d->GetKey();
 38669:         instance->mDeletingHash->PutEntry(o);
 37478:     }
 37477:     return PL_DHASH_NEXT;
 37477: }
 39742: 
 39742: NPIdentifier NP_CALLBACK
 39742: PluginModuleChild::NPN_GetStringIdentifier(const NPUTF8* aName)
 39742: {
 39742:     PLUGIN_LOG_DEBUG_FUNCTION;
 39742:     AssertPluginThread();
 39742: 
 39742:     if (!aName)
 39742:         return 0;
 39742: 
 39742:     PluginModuleChild* self = PluginModuleChild::current();
 39742:     nsDependentCString name(aName);
 39742: 
 72341:     PluginIdentifierChildString* ident = self->mStringIdentifiers.Get(name);
 72341:     if (!ident) {
 39742:         nsCString nameCopy(name);
 39742: 
 39742:         ident = new PluginIdentifierChildString(nameCopy);
 72341:         self->SendPPluginIdentifierConstructor(ident, nameCopy, -1, false);
 39742:     }
 72341:     ident->MakePermanent();
 39742:     return ident;
 39742: }
 39742: 
 39742: void NP_CALLBACK
 39742: PluginModuleChild::NPN_GetStringIdentifiers(const NPUTF8** aNames,
 39742:                                             int32_t aNameCount,
 39742:                                             NPIdentifier* aIdentifiers)
 39742: {
 39742:     PLUGIN_LOG_DEBUG_FUNCTION;
 39742:     AssertPluginThread();
 39742: 
 39742:     if (!(aNames && aNameCount > 0 && aIdentifiers)) {
 39742:         NS_RUNTIMEABORT("Bad input! Headed for a crash!");
 39742:     }
 39742: 
 39742:     PluginModuleChild* self = PluginModuleChild::current();
 39742: 
 39742:     for (int32_t index = 0; index < aNameCount; ++index) {
 39742:         if (!aNames[index]) {
 39742:             aIdentifiers[index] = 0;
 39742:             continue;
 39742:         }
 39742:         nsDependentCString name(aNames[index]);
 72341:         PluginIdentifierChildString* ident = self->mStringIdentifiers.Get(name);
 72341:         if (!ident) {
 39742:             nsCString nameCopy(name);
 39742: 
 39742:             ident = new PluginIdentifierChildString(nameCopy);
 72341:             self->SendPPluginIdentifierConstructor(ident, nameCopy, -1, false);
 39742:         }
 72341:         ident->MakePermanent();
 39742:         aIdentifiers[index] = ident;
 39742:     }
 39742: }
 39742: 
 39742: bool NP_CALLBACK
 39742: PluginModuleChild::NPN_IdentifierIsString(NPIdentifier aIdentifier)
 39742: {
 39742:     PLUGIN_LOG_DEBUG_FUNCTION;
 39742: 
 39742:     PluginIdentifierChild* ident =
 39742:         static_cast<PluginIdentifierChild*>(aIdentifier);
 39742:     return ident->IsString();
 39742: }
 39742: 
 39742: NPIdentifier NP_CALLBACK
 39742: PluginModuleChild::NPN_GetIntIdentifier(int32_t aIntId)
 39742: {
 39742:     PLUGIN_LOG_DEBUG_FUNCTION;
 39742:     AssertPluginThread();
 39742: 
 39742:     PluginModuleChild* self = PluginModuleChild::current();
 39742: 
 72341:     PluginIdentifierChildInt* ident = self->mIntIdentifiers.Get(aIntId);
 72341:     if (!ident) {
 39742:         nsCString voidString;
 80486:         voidString.SetIsVoid(true);
 39742: 
 39742:         ident = new PluginIdentifierChildInt(aIntId);
 72341:         self->SendPPluginIdentifierConstructor(ident, voidString, aIntId, false);
 39742:     }
 72341:     ident->MakePermanent();
 39742:     return ident;
 39742: }
 39742: 
 39742: NPUTF8* NP_CALLBACK
 39742: PluginModuleChild::NPN_UTF8FromIdentifier(NPIdentifier aIdentifier)
 39742: {
 39742:     PLUGIN_LOG_DEBUG_FUNCTION;
 39742: 
 39742:     if (static_cast<PluginIdentifierChild*>(aIdentifier)->IsString()) {
 39742:       return static_cast<PluginIdentifierChildString*>(aIdentifier)->ToString();
 39742:     }
106838:     return nullptr;
 39742: }
 39742: 
 39742: int32_t NP_CALLBACK
 39742: PluginModuleChild::NPN_IntFromIdentifier(NPIdentifier aIdentifier)
 39742: {
 39742:     PLUGIN_LOG_DEBUG_FUNCTION;
 39742: 
 42019:     if (!static_cast<PluginIdentifierChild*>(aIdentifier)->IsString()) {
 39742:       return static_cast<PluginIdentifierChildInt*>(aIdentifier)->ToInt();
 39742:     }
115367:     return INT32_MIN;
 39742: }
 41651: 
 41651: #ifdef OS_WIN
 41651: void
 41651: PluginModuleChild::EnteredCall()
 41651: {
 41652:     mIncallPumpingStack.AppendElement();
 41651: }
 41651: 
 41651: void
 41651: PluginModuleChild::ExitedCall()
 41651: {
 41651:     NS_ASSERTION(mIncallPumpingStack.Length(), "mismatched entered/exited");
108991:     uint32_t len = mIncallPumpingStack.Length();
 41652:     const IncallFrame& f = mIncallPumpingStack[len - 1];
 41652:     if (f._spinning)
 41652:         MessageLoop::current()->SetNestableTasksAllowed(f._savedNestableTasksAllowed);
 41652: 
 41652:     mIncallPumpingStack.TruncateLength(len - 1);
 41651: }
 41651: 
 41651: LRESULT CALLBACK
 42136: PluginModuleChild::CallWindowProcHook(int nCode, WPARAM wParam, LPARAM lParam)
 42136: {
 42136:     // Trap and reply to anything we recognize as the source of a
 42136:     // potential send message deadlock.
 42136:     if (nCode >= 0 &&
 42136:         (InSendMessageEx(NULL)&(ISMEX_REPLIED|ISMEX_SEND)) == ISMEX_SEND) {
 42136:         CWPSTRUCT* pCwp = reinterpret_cast<CWPSTRUCT*>(lParam);
 42423:         if (pCwp->message == WM_KILLFOCUS) {
 42416:             // Fix for flash fullscreen window loosing focus. On single
 42416:             // core systems, sync killfocus events need to be handled
 42416:             // after the flash fullscreen window procedure processes this
 42416:             // message, otherwise fullscreen focus will not work correctly.
 42416:             PRUnichar szClass[26];
 42416:             if (GetClassNameW(pCwp->hwnd, szClass,
 42416:                               sizeof(szClass)/sizeof(PRUnichar)) &&
 42416:                 !wcscmp(szClass, kFlashFullscreenClass)) {
 42416:                 gDelayFlashFocusReplyUntilEval = true;
 42416:             }
 42136:         }
 42136:     }
 42136: 
 42136:     return CallNextHookEx(NULL, nCode, wParam, lParam);
 42136: }
 42136: 
 42136: LRESULT CALLBACK
 41651: PluginModuleChild::NestedInputEventHook(int nCode, WPARAM wParam, LPARAM lParam)
 41651: {
 41651:     PluginModuleChild* self = current();
108991:     uint32_t len = self->mIncallPumpingStack.Length();
 41652:     if (nCode >= 0 && len && !self->mIncallPumpingStack[len - 1]._spinning) {
 74439:         MessageLoop* loop = MessageLoop::current();
 41651:         self->SendProcessNativeEventsInRPCCall();
 41652:         IncallFrame& f = self->mIncallPumpingStack[len - 1];
 41652:         f._spinning = true;
 41652:         f._savedNestableTasksAllowed = loop->NestableTasksAllowed();
 41652:         loop->SetNestableTasksAllowed(true);
 74439:         loop->set_os_modal_loop(true);
 41651:     }
 41651: 
 41651:     return CallNextHookEx(NULL, nCode, wParam, lParam);
 41651: }
 41651: 
 41651: void
 42136: PluginModuleChild::SetEventHooks()
 41651: {
 41651:     NS_ASSERTION(!mNestedEventHook,
 41651:         "mNestedEventHook already setup in call to SetNestedInputEventHook?");
 42136:     NS_ASSERTION(!mGlobalCallWndProcHook,
 42136:         "mGlobalCallWndProcHook already setup in call to CallWindowProcHook?");
 41651: 
 41651:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
 41651: 
 42136:     // WH_MSGFILTER event hook for detecting modal loops in the child.
 41651:     mNestedEventHook = SetWindowsHookEx(WH_MSGFILTER,
 41651:                                         NestedInputEventHook,
 41651:                                         NULL,
 41651:                                         GetCurrentThreadId());
 42136: 
 42136:     // WH_CALLWNDPROC event hook for trapping sync messages sent from
 42136:     // parent that can cause deadlocks.
 42136:     mGlobalCallWndProcHook = SetWindowsHookEx(WH_CALLWNDPROC,
 42136:                                               CallWindowProcHook,
 42136:                                               NULL,
 42136:                                               GetCurrentThreadId());
 41651: }
 41651: 
 41651: void
 42136: PluginModuleChild::ResetEventHooks()
 41651: {
 41651:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
 41651:     if (mNestedEventHook)
 41651:         UnhookWindowsHookEx(mNestedEventHook);
 41651:     mNestedEventHook = NULL;
 42136:     if (mGlobalCallWndProcHook)
 42136:         UnhookWindowsHookEx(mGlobalCallWndProcHook);
 42136:     mGlobalCallWndProcHook = NULL;
 41651: }
 41651: #endif
 48383: 
 70027: bool
 70027: PluginModuleChild::RecvProcessNativeEventsInRPCCall()
 70027: {
 70027:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
 70027: #if defined(OS_WIN)
 70027:     ProcessNativeEventsInRPCCall();
 70027:     return true;
 70027: #else
 70027:     NS_RUNTIMEABORT(
 70027:         "PluginModuleChild::RecvProcessNativeEventsInRPCCall not implemented!");
 70027:     return false;
 70027: #endif
 70027: }
 70027: 
 72514: #ifdef MOZ_WIDGET_COCOA
 48383: void
 48383: PluginModuleChild::ProcessNativeEvents() {
 48383:     CallProcessSomeEvents();    
 48383: }
 48383: #endif
