52873: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52873:  * vim: set ts=4 sw=4 et tw=99:
52873:  *
52873:  * ***** BEGIN LICENSE BLOCK *****
52873:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52873:  *
52873:  * The contents of this file are subject to the Mozilla Public License Version
52873:  * 1.1 (the "License"); you may not use this file except in compliance with
52873:  * the License. You may obtain a copy of the License at
52873:  * http://www.mozilla.org/MPL/
52873:  *
52873:  * Software distributed under the License is distributed on an "AS IS" basis,
52873:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52873:  * for the specific language governing rights and limitations under the
52873:  * License.
52873:  *
52873:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52873:  * May 28, 2008.
52873:  *
52873:  * The Initial Developer of the Original Code is
52873:  *   Brendan Eich <brendan@mozilla.org>
52873:  *
52873:  * Contributor(s):
52873:  *   David Anderson <danderson@mozilla.com>
52873:  *   David Mandelin <dmandelin@mozilla.com>
52873:  *
52873:  * Alternatively, the contents of this file may be used under the terms of
52873:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52873:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52873:  * in which case the provisions of the GPL or the LGPL are applicable instead
52873:  * of those above. If you wish to allow use of your version of this file only
52873:  * under the terms of either the GPL or the LGPL, and not to allow others to
52873:  * use your version of this file under the terms of the MPL, indicate your
52873:  * decision by deleting the provisions above and replace them with the notice
52873:  * and other provisions required by the GPL or the LGPL. If you do not delete
52873:  * the provisions above, a recipient may use your version of this file under
52873:  * the terms of any one of the MPL, the GPL or the LGPL.
52873:  *
52873:  * ***** END LICENSE BLOCK ***** */
52873: 
52873: #include "jscntxt.h"
52873: #include "jsscope.h"
52873: #include "jsobj.h"
52873: #include "jslibmath.h"
52873: #include "jsiter.h"
52873: #include "jsnum.h"
52873: #include "jsxml.h"
52873: #include "jsstaticcheck.h"
52873: #include "jsbool.h"
52873: #include "assembler/assembler/MacroAssemblerCodeRef.h"
53133: #include "assembler/assembler/CodeLocation.h"
53133: #include "assembler/assembler/RepatchBuffer.h"
52873: #include "jsiter.h"
52873: #include "jstypes.h"
52873: #include "methodjit/StubCalls.h"
52873: #include "jstracer.h"
52873: #include "jspropertycache.h"
53133: #include "methodjit/MonoIC.h"
53133: 
53840: #include "jsinterpinlines.h"
52873: #include "jspropertycacheinlines.h"
52873: #include "jsscopeinlines.h"
52873: #include "jsscriptinlines.h"
52873: #include "jsstrinlines.h"
52873: #include "jsobjinlines.h"
52873: #include "jscntxtinlines.h"
52873: #include "jsatominlines.h"
52873: 
52873: #include "jsautooplen.h"
52873: 
52873: using namespace js;
52873: using namespace js::mjit;
52873: using namespace JSC;
52873: 
52873: #define THROW()  \
52873:     do {         \
52873:         void *ptr = JS_FUNC_TO_DATA_PTR(void *, JaegerThrowpoline); \
53168:         *f.returnAddressLocation() = ptr; \
52873:         return;  \
52873:     } while (0)
52873: 
52873: #define THROWV(v)       \
52873:     do {                \
52873:         void *ptr = JS_FUNC_TO_DATA_PTR(void *, JaegerThrowpoline); \
53168:         *f.returnAddressLocation() = ptr; \
52873:         return v;       \
52873:     } while (0)
52873: 
52873: static bool
53422: InlineReturn(VMFrame &f, JSBool ok);
52873: 
52873: static jsbytecode *
52873: FindExceptionHandler(JSContext *cx)
52873: {
53482:     JSStackFrame *fp = cx->fp();
53840:     JSScript *script = fp->script();
52873: 
52873: top:
52873:     if (cx->throwing && script->trynotesOffset) {
52873:         // The PC is updated before every stub call, so we can use it here.
52873:         unsigned offset = cx->regs->pc - script->main;
52873: 
52873:         JSTryNoteArray *tnarray = script->trynotes();
52873:         for (unsigned i = 0; i < tnarray->length; ++i) {
52873:             JSTryNote *tn = &tnarray->vector[i];
52873:             JS_ASSERT(offset < script->length);
53496:             // The following if condition actually tests two separate conditions:
53496:             //   (1) offset - tn->start >= tn->length
53496:             //       means the PC is not in the range of this try note, so we
53496:             //       should continue searching, after considering:
53496:             //   (2) offset - tn->start == tn->length
53496:             //       means the PC is at the first op of the exception handler
53496:             //       for this try note. This happens when an exception is thrown
53496:             //       during recording: the interpreter sets the PC to the handler
53496:             //       and then exits. In this case, we are in fact at the right
53496:             //       exception handler. 
53496:             //      
53496:             //       Hypothetically, the op we are at might have thrown an
53496:             //       exception, in which case this would not be the right handler.
53496:             //       But the first ops of exception handlers generated by our
53496:             //       bytecode compiler cannot throw, so this is not possible.
53496:             if (offset - tn->start > tn->length)
52873:                 continue;
52873:             if (tn->stackDepth > cx->regs->sp - fp->base())
52873:                 continue;
52873: 
52873:             jsbytecode *pc = script->main + tn->start + tn->length;
52873:             JSBool ok = js_UnwindScope(cx, tn->stackDepth, JS_TRUE);
52873:             JS_ASSERT(cx->regs->sp == fp->base() + tn->stackDepth);
52873: 
52873:             switch (tn->kind) {
52873:                 case JSTRY_CATCH:
53840:                   JS_ASSERT(js_GetOpcode(cx, fp->script(), pc) == JSOP_ENTERBLOCK);
52873: 
52873: #if JS_HAS_GENERATORS
52873:                   /* Catch cannot intercept the closing of a generator. */
52873:                   if (JS_UNLIKELY(cx->exception.isMagic(JS_GENERATOR_CLOSING)))
52873:                       break;
52873: #endif
52873: 
52873:                   /*
52873:                    * Don't clear cx->throwing to save cx->exception from GC
52873:                    * until it is pushed to the stack via [exception] in the
52873:                    * catch block.
52873:                    */
52873:                   return pc;
52873: 
52873:                 case JSTRY_FINALLY:
52873:                   /*
52873:                    * Push (true, exception) pair for finally to indicate that
52873:                    * [retsub] should rethrow the exception.
52873:                    */
52873:                   cx->regs->sp[0].setBoolean(true);
52873:                   cx->regs->sp[1] = cx->exception;
52873:                   cx->regs->sp += 2;
52873:                   cx->throwing = JS_FALSE;
52873:                   return pc;
52873: 
52873:                 case JSTRY_ITER:
52873:                 {
52873:                   /*
52873:                    * This is similar to JSOP_ENDITER in the interpreter loop,
52873:                    * except the code now uses the stack slot normally used by
52873:                    * JSOP_NEXTITER, namely regs.sp[-1] before the regs.sp -= 2
52873:                    * adjustment and regs.sp[1] after, to save and restore the
52873:                    * pending exception.
52873:                    */
52873:                   AutoValueRooter tvr(cx, cx->exception);
53840:                   JS_ASSERT(js_GetOpcode(cx, fp->script(), pc) == JSOP_ENDITER);
52873:                   cx->throwing = JS_FALSE;
53100:                   ok = !!js_CloseIterator(cx, &cx->regs->sp[-1].toObject());
52873:                   cx->regs->sp -= 1;
52873:                   if (!ok)
52873:                       goto top;
52873:                   cx->throwing = JS_TRUE;
52873:                   cx->exception = tvr.value();
52873:                 }
52873:             }
52873:         }
52873:     }
52873: 
52873:     return NULL;
52873: }
52873: 
53590: static bool
53590: InlineReturn(VMFrame &f, JSBool ok)
53422: {
53590:     JSContext *cx = f.cx;
53590:     JSStackFrame *fp = f.regs.fp;
53590: 
53590:     JS_ASSERT(f.fp() != f.entryFp);
53590: 
53590:     JS_ASSERT(!fp->hasBlockChain());
53840:     JS_ASSERT(!js_IsActiveWithOrBlock(cx, &fp->scopeChain(), 0));
53590: 
53590:     // Marker for debug support.
53590:     if (JS_UNLIKELY(fp->hasHookData())) {
53590:         JSInterpreterHook hook;
53590:         JSBool status;
53590: 
53590:         hook = cx->debugHooks->callHook;
53590:         if (hook) {
53590:             /*
53590:              * Do not pass &ok directly as exposing the address inhibits
53590:              * optimizations and uninitialised warnings.
53590:              */
53590:             status = ok;
53840:             hook(cx, fp, JS_FALSE, &status, fp->hookData());
53590:             ok = (status == JS_TRUE);
53590:             // CHECK_INTERRUPT_HANDLER();
53590:         }
53422:     }
53422: 
53840:     PutActivationObjects(cx, fp);
53590: 
53840:     if (fp->isConstructing() && fp->returnValue().isPrimitive())
53840:         fp->setReturnValue(fp->thisValue());
53590: 
53840:     Value *newsp = fp->actualArgs() - 1;
53840:     newsp[-1] = fp->returnValue();
53840:     cx->stack().popInlineFrame(cx, fp->prev(), newsp);
53590: 
53590:     return ok;
53590: }
53590: 
53590: JSBool JS_FASTCALL
53590: stubs::NewObject(VMFrame &f, uint32 argc)
53590: {
53590:     JSContext *cx = f.cx;
53590:     Value *vp = f.regs.sp - (argc + 2);
53590: 
53590:     JSObject *funobj = &vp[0].toObject();
53590:     JS_ASSERT(funobj->isFunction());
53590: 
53590:     jsid id = ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom);
53590:     if (!funobj->getProperty(cx, id, &vp[1]))
53590:         THROWV(JS_FALSE);
53590: 
53590:     JSObject *proto = vp[1].isObject() ? &vp[1].toObject() : NULL;
53590:     JSObject *obj = NewNonFunction<WithProto::Class>(cx, &js_ObjectClass, proto, funobj->getParent());
53590:     if (!obj)
53590:         THROWV(JS_FALSE);
53590: 
53590:     vp[1].setObject(*obj);
53590: 
53590:     return JS_TRUE;
53590: }
53590: 
53590: void JS_FASTCALL
53590: stubs::SlowCall(VMFrame &f, uint32 argc)
53590: {
53590:     Value *vp = f.regs.sp - (argc + 2);
53590: 
53590:     if (!Invoke(f.cx, InvokeArgsAlreadyOnTheStack(vp, argc), 0))
53590:         THROW();
53590: }
53590: 
53590: void JS_FASTCALL
53590: stubs::SlowNew(VMFrame &f, uint32 argc)
53590: {
53590:     JSContext *cx = f.cx;
53590:     Value *vp = f.regs.sp - (argc + 2);
53590: 
53590:     if (!InvokeConstructor(cx, InvokeArgsAlreadyOnTheStack(vp, argc)))
53590:         THROW();
53590: }
53590: 
53840: /*
53840:  * This function must only be called after the early prologue, since it depends
53840:  * on fp->exec.fun.
53840:  */
53590: static inline void
53840: RemovePartialFrame(JSContext *cx, JSStackFrame *fp)
53590: {
53840:     JSStackFrame *prev = fp->prev();
53840:     Value *newsp = (Value *)fp;
53840:     cx->stack().popInlineFrame(cx, prev, newsp);
53590: }
53590: 
53840: /*
53840:  * HitStackQuota is called after the early prologue pushing the new frame would
53840:  * overflow f.stackLimit.
53840:  */
53590: void JS_FASTCALL
53840: stubs::HitStackQuota(VMFrame &f)
53590: {
53840:     /* Include space to push another frame. */
53840:     uintN nvals = f.fp()->script()->nslots + VALUES_PER_STACK_FRAME;
53840:     JS_ASSERT(f.regs.sp == f.fp()->base());
53840:     if (f.cx->stack().bumpCommitAndLimit(f.entryFp, f.regs.sp, nvals, &f.stackLimit))
53590:         return;
53590: 
53840:     /* Remove the current partially-constructed frame before throwing. */
53840:     RemovePartialFrame(f.cx, f.fp());
53590:     js_ReportOverRecursed(f.cx);
53590:     THROW();
53590: }
53590: 
53840: /*
53840:  * This function must only be called after the early prologue, since it depends
53840:  * on fp->exec.fun.
53840:  */
53590: void * JS_FASTCALL
53840: stubs::FixupArity(VMFrame &f, uint32 nactual)
53590: {
53590:     JSContext *cx = f.cx;
53840:     JSStackFrame *oldfp = f.fp();
53590: 
53840:     JS_ASSERT(nactual != oldfp->numFormalArgs());
53590: 
53590:     /*
53590:      * Grossssss! *move* the stack frame. If this ends up being perf-critical,
53840:      * we can figure out how to spot-optimize it. Be careful to touch only the
53840:      * members that have been initialized by initCallFrameCallerHalf and the
53840:      * early prologue.
53590:      */
53840:     uint32 flags         = oldfp->isConstructingFlag();
53840:     JSObject &scopeChain = oldfp->scopeChain();
53840:     JSFunction *fun      = oldfp->fun();
53840:     void *ncode          = oldfp->nativeReturnAddress();
53590: 
53590:     /* Pop the inline frame. */
53840:     RemovePartialFrame(cx, oldfp);
53590: 
53840:     /* Reserve enough space for a callee frame. */
53840:     JSStackFrame *newfp = cx->stack().getInlineFrameWithinLimit(cx, cx->regs->sp, nactual,
53840:                                                                 fun, fun->script(), &flags,
53840:                                                                 f.entryFp, &f.stackLimit);
53840:     if (!newfp)
53840:         THROWV(NULL);
53590: 
53840:     /* Reset the part of the stack frame set by the caller. */
53840:     newfp->initCallFrameCallerHalf(cx, scopeChain, nactual, flags);
53590: 
53840:     /* Reset the part of the stack frame set by the prologue up to now. */
53840:     newfp->initCallFrameEarlyPrologue(fun, ncode);
53590: 
53840:     /* The caller takes care of assigning fp to regs. */
53590:     return newfp;
53590: }
53590: 
53590: void * JS_FASTCALL
53840: stubs::CompileFunction(VMFrame &f, uint32 nactual)
53590: {
53590:     /*
53590:      * We have a partially constructed frame. That's not really good enough to
53590:      * compile though because we could throw, so get a full, adjusted frame.
53590:      */
53590:     JSContext *cx = f.cx;
53590:     JSStackFrame *fp = f.fp();
53590: 
53840:     /*
53840:      * Since we can only use members set by initCallFrameCallerHalf,
53840:      * we must carefully extract the callee from the nactual.
53840:      */
53840:     JSObject &callee = fp->formalArgsEnd()[-(int(nactual) + 2)].toObject();
53840:     JSFunction *fun = callee.getFunctionPrivate();
53840:     JSScript *script = fun->script();
53590: 
53840:     /*
53840:      * FixupArity/RemovePartialFrame expect to be called after the early
53840:      * prologue. Pass null for ncode: either we will jump into jit code, which
53840:      * will set ncode, or we will jump into js::Interpret, which does not care
53840:      * about ncode.
53840:      */
53840:     fp->initCallFrameEarlyPrologue(fun, NULL);
53590: 
53590:     /* Empty script does nothing. */
53590:     if (script->isEmpty()) {
53840:         bool callingNew = fp->isConstructing();
53840:         RemovePartialFrame(cx, fp);
53840:         Value *vp = f.regs.sp - (nactual + 2);
53590:         if (callingNew)
53840:             vp[0] = vp[1];
53590:         else
53840:             vp[0].setUndefined();
53590:         return NULL;
53590:     }
53590: 
53840:     if (nactual != fp->numFormalArgs()) {
53840:         fp = (JSStackFrame *)FixupArity(f, nactual);
53590:         if (!fp)
53590:             return NULL;
53590:     }
53590: 
53840:     /* Finish frame initialization. */
53840:     fp->initCallFrameLatePrologue();
53590: 
53840:     /* These would have been initialized by the prologue. */
53590:     f.regs.fp = fp;
53590:     f.regs.sp = fp->base();
53590:     f.regs.pc = script->code;
53590: 
53590:     if (fun->isHeavyweight() && !js_GetCallObject(cx, fp))
53590:         THROWV(NULL);
53590: 
53840:     CompileStatus status = CanMethodJIT(cx, script, fun, &fp->scopeChain());
53590:     if (status == Compile_Okay)
53590:         return script->jit->invoke;
53590: 
53590:     /* Function did not compile... interpret it. */
53590:     JSBool ok = Interpret(cx, fp);
53590:     InlineReturn(f, ok);
53590: 
53590:     if (!ok)
53590:         THROWV(NULL);
53590: 
53590:     return NULL;
53590: }
53590: 
53840: static inline bool
53840: UncachedInlineCall(VMFrame &f, uint32 flags, void **pret, uint32 argc)
52873: {
52873:     JSContext *cx = f.cx;
53482:     JSStackFrame *fp = f.fp();
52873:     Value *vp = f.regs.sp - (argc + 2);
53840:     JSObject &callee = vp->toObject();
53840:     JSFunction *newfun = callee.getFunctionPrivate();
53840:     JSScript *newscript = newfun->script();
52873: 
53840:     /* Get pointer to new frame/slots, prepare arguments. */
53840:     StackSpace &stack = cx->stack();
53840:     JSStackFrame *newfp = stack.getInlineFrameWithinLimit(cx, f.regs.sp, argc,
53840:                                                           newfun, newscript, &flags,
53840:                                                           f.entryFp, &f.stackLimit);
53840:     if (JS_UNLIKELY(!newfp))
53840:         return false;
53840:     JS_ASSERT_IF(!vp[1].isPrimitive(), IsSaneThisObject(vp[1].toObject()));
52873: 
53840:     /* Initialize frame, locals. */
53840:     newfp->initCallFrame(cx, callee, newfun, argc, flags);
53840:     SetValueRangeToUndefined(newfp->slots(), newscript->nfixed);
52873: 
53840:     /* Officially push the frame. */
53840:     stack.pushInlineFrame(cx, newscript, newfp, &f.regs);
53840:     JS_ASSERT(newfp == f.regs.fp);
53840: 
53840:     /* Scope with a call object parented by callee's parent. */
53840:     if (newfun->isHeavyweight() && !js_GetCallObject(cx, newfp))
53840:         return false;
53840: 
53840:     /* Marker for debug support. */
52873:     if (JSInterpreterHook hook = cx->debugHooks->callHook) {
53437:         newfp->setHookData(hook(cx, fp, JS_TRUE, 0,
53437:                                 cx->debugHooks->callHookData));
52873:     }
52873: 
53840:     /* Try to compile if not already compiled. */
53840:     if (!newscript->ncode) {
53840:         if (mjit::TryCompile(cx, newscript, newfp->fun(), &newfp->scopeChain()) == Compile_Error) {
53840:             /* A runtime exception was thrown, get out. */
53840:             InlineReturn(f, JS_FALSE);
53840:             return false;
53840:         }
53840:     }
52873: 
53840:     /* If newscript was successfully compiled, run it. */
53840:     JS_ASSERT(newscript->ncode);
53840:     if (newscript->ncode != JS_UNJITTABLE_METHOD) {
53840:         *pret = newscript->jit->invoke;
52873:         return true;
52873:     }
52873: 
53840:     /* Otherwise, run newscript in the interpreter. */
53482:     bool ok = !!Interpret(cx, cx->fp());
53422:     InlineReturn(f, JS_TRUE);
52873: 
52873:     *pret = NULL;
52873:     return ok;
52873: }
52873: 
53590: void * JS_FASTCALL
53590: stubs::UncachedNew(VMFrame &f, uint32 argc)
53523: {
54163:     UncachedCallResult ucr;
54163:     UncachedNewHelper(f, argc, &ucr);
54163:     return ucr.codeAddr;
54163: }
54163: 
54163: void
54163: stubs::UncachedNewHelper(VMFrame &f, uint32 argc, UncachedCallResult *ucr)
54163: {
54163:     ucr->init();
54163: 
53523:     JSContext *cx = f.cx;
53590:     Value *vp = f.regs.sp - (argc + 2);
53523: 
53840:     /* Try to do a fast inline call before the general Invoke path. */
54163:     if (IsFunctionObject(*vp, &ucr->fun) && ucr->fun->isInterpreted() && 
54163:         !ucr->fun->script()->isEmpty()) {
54163:         ucr->callee = &vp->toObject();
54163:         if (!UncachedInlineCall(f, JSFRAME_CONSTRUCTING, &ucr->codeAddr, argc))
54163:             THROW();
54163:         return;
53523:     }
53523: 
53590:     if (!InvokeConstructor(cx, InvokeArgsAlreadyOnTheStack(vp, argc)))
54163:         THROW();
54163:     return;
53523: }
53523: 
53522: void * JS_FASTCALL
53590: stubs::UncachedCall(VMFrame &f, uint32 argc)
53515: {
54163:     UncachedCallResult ucr;
54163:     UncachedCallHelper(f, argc, &ucr);
54163:     return ucr.codeAddr;
54163: }
54163: 
54163: void
54163: stubs::UncachedCallHelper(VMFrame &f, uint32 argc, UncachedCallResult *ucr)
54163: {
54163:     ucr->init();
54163: 
53515:     JSContext *cx = f.cx;
52873:     Value *vp = f.regs.sp - (argc + 2);
52873: 
54163:     if (IsFunctionObject(*vp, &ucr->callee)) {
54163:         ucr->callee = &vp->toObject();
54163:         ucr->fun = GET_FUNCTION_PRIVATE(cx, ucr->callee);
52873: 
54163:         if (ucr->fun->isInterpreted()) {
54163:             if (ucr->fun->u.i.script->isEmpty()) {
52873:                 vp->setUndefined();
52873:                 f.regs.sp = vp + 1;
54163:                 return;
52873:             }
52873: 
54163:             if (!UncachedInlineCall(f, 0, &ucr->codeAddr, argc))
54163:                 THROW();
54163:             return;
52873:         }
52873: 
54163:         if (ucr->fun->isNative()) {
54163:             if (!ucr->fun->u.n.native(cx, argc, vp))
54163:                 THROW();
54163:             return;
52873:         }
52873:     }
52873: 
53382:     if (!Invoke(f.cx, InvokeArgsAlreadyOnTheStack(vp, argc), 0))
54163:         THROW();
52873: 
54163:     return;
52873: }
52873: 
52873: void JS_FASTCALL
52873: stubs::PutCallObject(VMFrame &f)
52873: {
53482:     JS_ASSERT(f.fp()->hasCallObj());
53482:     js_PutCallObject(f.cx, f.fp());
52873: }
52873: 
52873: void JS_FASTCALL
53840: stubs::PutActivationObjects(VMFrame &f)
52873: {
53840:     JS_ASSERT(f.fp()->hasCallObj() || f.fp()->hasArgsObj());
53840:     js::PutActivationObjects(f.cx, f.fp());
52873: }
52873: 
52873: extern "C" void *
52873: js_InternalThrow(VMFrame &f)
52873: {
52873:     JSContext *cx = f.cx;
52873: 
52873:     // Make sure sp is up to date.
52873:     JS_ASSERT(cx->regs == &f.regs);
52873: 
53410:     // Call the throw hook if necessary
53410:     JSThrowHook handler = f.cx->debugHooks->throwHook;
53410:     if (handler) {
53410:         Value rval;
53840:         switch (handler(cx, cx->fp()->script(), cx->regs->pc, Jsvalify(&rval),
53410:                         cx->debugHooks->throwHookData)) {
53410:           case JSTRAP_ERROR:
53410:             cx->throwing = JS_FALSE;
53410:             return NULL;
53410: 
53410:           case JSTRAP_RETURN:
53410:             cx->throwing = JS_FALSE;
53482:             cx->fp()->setReturnValue(rval);
53410:             return JS_FUNC_TO_DATA_PTR(void *,
53410:                    JS_METHODJIT_DATA(cx).trampolines.forceReturn);
53410: 
53410:           case JSTRAP_THROW:
53410:             cx->exception = rval;
53410:             break;
53410: 
53410:           default:
53410:             break;
53410:         }
53410:     }
53410: 
52873:     jsbytecode *pc = NULL;
52873:     for (;;) {
52873:         pc = FindExceptionHandler(cx);
52873:         if (pc)
52873:             break;
52873: 
53422:         // If on the 'topmost' frame (where topmost means the first frame
53422:         // called into through js_Interpret). In this case, we still unwind,
53422:         // but we shouldn't return from a JS function, because we're not in a
53422:         // JS function.
53482:         bool lastFrame = (f.entryFp == f.fp());
52873:         js_UnwindScope(cx, 0, cx->throwing);
52873:         if (lastFrame)
52873:             break;
52873: 
52873:         JS_ASSERT(f.regs.sp == cx->regs->sp);
53422:         InlineReturn(f, JS_FALSE);
52873:     }
52873: 
52873:     JS_ASSERT(f.regs.sp == cx->regs->sp);
52873: 
53626:     if (!pc)
52873:         return NULL;
52873: 
53840:     return cx->fp()->script()->pcToNative(pc);
52873: }
52873: 
52873: void JS_FASTCALL
52873: stubs::GetCallObject(VMFrame &f)
52873: {
53840:     JS_ASSERT(f.fp()->fun()->isHeavyweight());
53482:     if (!js_GetCallObject(f.cx, f.fp()))
52873:         THROW();
52873: }
52873: 
53133: static inline void
53133: AdvanceReturnPC(JSContext *cx)
53133: {
53422:     /* Simulate an inline_return by advancing the pc. */
53133:     JS_ASSERT(*cx->regs->pc == JSOP_CALL ||
53133:               *cx->regs->pc == JSOP_NEW ||
53133:               *cx->regs->pc == JSOP_EVAL ||
53133:               *cx->regs->pc == JSOP_APPLY);
53133:     cx->regs->pc += JSOP_CALL_LENGTH;
53133: }
53133: 
53133: #ifdef JS_TRACER
53133: 
53133: static inline bool
53133: SwallowErrors(VMFrame &f, JSStackFrame *stopFp)
53133: {
53133:     JSContext *cx = f.cx;
53133: 
53133:     /* Remove the bottom frame. */
53133:     bool ok = false;
53133:     for (;;) {
53482:         JSStackFrame *fp = cx->fp();
53133: 
53133:         /* Look for an imacro with hard-coded exception handlers. */
53840:         if (fp->hasImacropc() && cx->throwing) {
53840:             cx->regs->pc = fp->imacropc();
53840:             fp->clearImacropc();
53133:             if (ok)
53133:                 break;
53133:         }
53840:         JS_ASSERT(!fp->hasImacropc());
53133: 
53133:         /* If there's an exception and a handler, set the pc and leave. */
53133:         jsbytecode *pc = FindExceptionHandler(cx);
53133:         if (pc) {
53133:             cx->regs->pc = pc;
53133:             ok = true;
53133:             break;
53133:         }
53133: 
53133:         /* Don't unwind if this was the entry frame. */
53133:         if (fp == stopFp)
53133:             break;
53133: 
53133:         /* Unwind and return. */
53373:         ok &= bool(js_UnwindScope(cx, 0, cx->throwing));
53422:         InlineReturn(f, ok);
53133:     }
53133: 
53133:     /* Update the VMFrame before leaving. */
53133:     JS_ASSERT(&f.regs == cx->regs);
53133: 
53482:     JS_ASSERT_IF(!ok, cx->fp() == stopFp);
53133:     return ok;
53133: }
53133: 
53133: static inline bool
53133: AtSafePoint(JSContext *cx)
53133: {
53482:     JSStackFrame *fp = cx->fp();
53840:     if (fp->hasImacropc())
53133:         return false;
53133: 
53840:     JSScript *script = fp->script();
53133:     if (!script->nmap)
53133:         return false;
53133: 
53133:     JS_ASSERT(cx->regs->pc >= script->code && cx->regs->pc < script->code + script->length);
53133:     return !!script->nmap[cx->regs->pc - script->code];
53133: }
53133: 
53133: static inline JSBool
53428: PartialInterpret(VMFrame &f)
53133: {
53428:     JSContext *cx = f.cx;
53482:     JSStackFrame *fp = cx->fp();
53133: 
53840:     JS_ASSERT(fp->hasImacropc() || !fp->script()->nmap ||
53840:               !fp->script()->nmap[cx->regs->pc - fp->script()->code]);
53133: 
53133:     JSBool ok = JS_TRUE;
53626:     ok = Interpret(cx, fp, 0, JSINTERP_SAFEPOINT);
53133: 
53133:     return ok;
53133: }
53133: 
53133: JS_STATIC_ASSERT(JSOP_NOP == 0);
53133: 
53133: static inline JSOp
53133: FrameIsFinished(JSContext *cx)
53133: {
53133:     JSOp op = JSOp(*cx->regs->pc);
53133:     return (op == JSOP_RETURN ||
53133:             op == JSOP_RETRVAL ||
53133:             op == JSOP_STOP)
53133:         ? op
53133:         : JSOP_NOP;
53133: }
53133: 
53133: static bool
53133: RemoveExcessFrames(VMFrame &f, JSStackFrame *entryFrame)
53133: {
53133:     JSContext *cx = f.cx;
53840:     while (cx->fp() != entryFrame || entryFrame->hasImacropc()) {
53482:         JSStackFrame *fp = cx->fp();
53133: 
53133:         if (AtSafePoint(cx)) {
53840:             JSScript *script = fp->script();
53471:             if (!JaegerShotAtSafePoint(cx, script->nmap[cx->regs->pc - script->code])) {
53133:                 if (!SwallowErrors(f, entryFrame))
53133:                     return false;
53133: 
53133:                 /* Could be anywhere - restart outer loop. */
53133:                 continue;
53133:             }
53422:             InlineReturn(f, JS_TRUE);
53133:             AdvanceReturnPC(cx);
53133:         } else {
53428:             if (!PartialInterpret(f)) {
53133:                 if (!SwallowErrors(f, entryFrame))
53133:                     return false;
53626:             } else if (cx->fp() != entryFrame) {
53133:                 /*
53133:                  * Partial interpret could have dropped us anywhere. Deduce the
53133:                  * edge case: at a RETURN, needing to pop a frame.
53133:                  */
53840:                 JS_ASSERT(!cx->fp()->hasImacropc());
53626:                 if (FrameIsFinished(cx)) {
53285:                     JSOp op = JSOp(*cx->regs->pc);
53840:                     if (op == JSOP_RETURN && !cx->fp()->isBailedAtReturn())
53626:                         cx->fp()->setReturnValue(f.regs.sp[-1]);
53422:                     InlineReturn(f, JS_TRUE);
53133:                     AdvanceReturnPC(cx);
53133:                 }
53133:             }
53133:         }
53133:     }
53133: 
53133:     return true;
53133: }
53133: 
53133: #if JS_MONOIC
53133: static void
54160: DisableTraceHintSingle(JSC::CodeLocationJump jump, JSC::CodeLocationLabel target)
53133: {
53133:     /*
53133:      * Hack: The value that will be patched is before the executable address,
53133:      * so to get protection right, just unprotect the general region around
53133:      * the jump.
53133:      */
54160:     uint8 *addr = (uint8 *)(jump.executableAddress());
53133:     JSC::RepatchBuffer repatch(addr - 64, 128);
54160:     repatch.relink(jump, target);
53277: 
53277:     JaegerSpew(JSpew_PICs, "relinking trace hint %p to %p\n",
54160:                jump.executableAddress(), target.executableAddress());
53277: }
54160: 
54160: static void
54160: DisableTraceHint(VMFrame &f, ic::MICInfo &mic)
54160: {
54160:     JS_ASSERT(mic.kind == ic::MICInfo::TRACER);
54160: 
54160:     DisableTraceHintSingle(mic.traceHint, mic.load);
54160: 
54160:     if (mic.u.hints.hasSlowTraceHintOne)
54160:         DisableTraceHintSingle(mic.slowTraceHintOne, mic.load);
54160: 
54160:     if (mic.u.hints.hasSlowTraceHintTwo)
54160:         DisableTraceHintSingle(mic.slowTraceHintTwo, mic.load);
53133: }
53133: #endif
53133: 
53133: #if JS_MONOIC
53133: void *
53133: RunTracer(VMFrame &f, ic::MICInfo &mic)
53133: #else
53133: void *
53133: RunTracer(VMFrame &f)
53133: #endif
53133: {
53133:     JSContext *cx = f.cx;
53482:     JSStackFrame *entryFrame = f.fp();
53133:     TracePointAction tpa;
53133: 
53133:     /* :TODO: nuke PIC? */
53133:     if (!cx->jitEnabled)
53133:         return NULL;
53133: 
53133:     bool blacklist;
53422:     uintN inlineCallCount = 0;
53133:     tpa = MonitorTracePoint(f.cx, inlineCallCount, blacklist);
53133:     JS_ASSERT(!TRACE_RECORDER(cx));
53133: 
53133: #if JS_MONOIC
53133:     if (blacklist)
53133:         DisableTraceHint(f, mic);
53133: #endif
53133: 
53133:     if ((tpa == TPA_RanStuff || tpa == TPA_Recorded) && cx->throwing)
53133:         tpa = TPA_Error;
53133: 
53482: 	/* Sync up the VMFrame's view of cx->fp(). */
53482: 	f.fp() = cx->fp();
53425: 
53133:     switch (tpa) {
53133:       case TPA_Nothing:
53133:         return NULL;
53133: 
53133:       case TPA_Error:
53133:         if (!SwallowErrors(f, entryFrame))
53133:             THROWV(NULL);
53840:         JS_ASSERT(!cx->fp()->hasImacropc());
53133:         break;
53133: 
53133:       case TPA_RanStuff:
53133:       case TPA_Recorded:
53133:         break;
53133:     }
53133: 
53133:     /*
53133:      * The tracer could have dropped us off on any frame at any position.
53133:      * Well, it could not have removed frames (recursion is disabled).
53133:      *
53471:      * Frames after the entryFrame cannot be entered via JaegerShotAtSafePoint()
53471:      * unless each is at a safe point. We can JaegerShotAtSafePoint these
53471:      * frames individually, but we must unwind to the entryFrame.
53471:      *
53471:      * Note carefully that JaegerShotAtSafePoint can resume methods at
53471:      * arbitrary safe points whereas JaegerShot cannot.
53133:      *
53133:      * If we land on entryFrame without a safe point in sight, we'll end up
53133:      * at the RETURN op. This is an edge case with two paths:
53133:      *
53133:      * 1) The entryFrame is the last inline frame. If it fell on a RETURN,
53133:      *    move the return value down.
53133:      * 2) The entryFrame is NOT the last inline frame. Pop the frame.
53133:      *
53471:      * In both cases, we hijack the stub to return to InjectJaegerReturn. This
53471:      * moves |oldFp->rval| into the scripted return registers.
53133:      */
53133: 
53133:   restart:
53133:     /* Step 1. Initial removal of excess frames. */
53133:     if (!RemoveExcessFrames(f, entryFrame))
53133:         THROWV(NULL);
53133: 
53626:     /* IMacros are guaranteed to have been removed by now. */
53840:     JS_ASSERT(!entryFrame->hasImacropc());
53133: 
53626:     /* Step 2. If entryFrame is at a safe point, just leave. */
53133:     if (AtSafePoint(cx)) {
53840:         uint32 offs = uint32(cx->regs->pc - entryFrame->script()->code);
53840:         JS_ASSERT(entryFrame->script()->nmap[offs]);
53840:         return entryFrame->script()->nmap[offs];
53133:     }
53133: 
53626:     /* Step 3. If entryFrame is at a RETURN, then leave slightly differently. */
53133:     if (JSOp op = FrameIsFinished(cx)) {
53133:         /* We're not guaranteed that the RETURN was run. */
53840:         if (op == JSOP_RETURN && !entryFrame->isBailedAtReturn())
53440:             entryFrame->setReturnValue(f.regs.sp[-1]);
53133: 
53133:         /* Don't pop the frame if it's maybe owned by an Invoke. */
53482:         if (f.fp() != f.entryFp) {
53422:             if (!InlineReturn(f, JS_TRUE))
53133:                 THROWV(NULL);
53133:         }
53471:         void *retPtr = JS_FUNC_TO_DATA_PTR(void *, InjectJaegerReturn);
53168:         *f.returnAddressLocation() = retPtr;
53133:         return NULL;
53133:     }
53133: 
53626:     /* Step 4. Do a partial interp, then restart the whole process. */
53428:     if (!PartialInterpret(f)) {
53133:         if (!SwallowErrors(f, entryFrame))
53133:             THROWV(NULL);
53133:     }
53133: 
53133:     goto restart;
53133: }
53133: 
53133: #endif /* JS_TRACER */
53133: 
53136: #if defined JS_TRACER
53136: # if defined JS_MONOIC
53133: void *JS_FASTCALL
53133: stubs::InvokeTracer(VMFrame &f, uint32 index)
53133: {
53840:     JSScript *script = f.fp()->script();
53133:     ic::MICInfo &mic = script->mics[index];
53133: 
53133:     JS_ASSERT(mic.kind == ic::MICInfo::TRACER);
53133: 
53133:     return RunTracer(f, mic);
53133: }
53133: 
53133: # else
53133: 
53133: void *JS_FASTCALL
53133: stubs::InvokeTracer(VMFrame &f)
53133: {
53133:     return RunTracer(f);
53133: }
53136: # endif /* JS_MONOIC */
53136: #endif /* JS_TRACER */
53133: 
