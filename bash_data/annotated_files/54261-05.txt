    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
16226:  *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
22917:  *   Ehsan Akhgari <ehsan.akhgari@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* a presentation of a document, part 1 */
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsPresContext.h"
    1: #include "nsIPresShell.h"
    1: #include "nsILinkHandler.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIContentViewer.h"
    1: #include "nsIDocumentViewer.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsStyleSet.h"
    1: #include "nsImageLoader.h"
    1: #include "nsIContent.h"
    1: #include "nsIFrame.h"
    1: #include "nsIRenderingContext.h"
    1: #include "nsIURL.h"
    1: #include "nsIDocument.h"
    1: #include "nsStyleContext.h"
    1: #include "nsILookAndFeel.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsIURIContentListener.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsContentPolicyUtils.h"
    1: #include "nsIDOMWindow.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsIWeakReferenceUtils.h"
    1: #include "nsCSSRendering.h"
    1: #include "prprf.h"
    1: #include "nsContentPolicyUtils.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsEventStateManager.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsFrameManager.h"
    1: #include "nsLayoutUtils.h"
    1: #include "nsIViewManager.h"
 3959: #include "nsCSSFrameConstructor.h"
16396: #include "nsCSSRuleProcessor.h"
 3959: #include "nsStyleChangeList.h"
 6734: #include "nsRuleNode.h"
19380: #include "nsEventDispatcher.h"
19962: #include "gfxUserFontSet.h"
21924: #include "gfxPlatform.h"
21924: #include "nsCSSRules.h"
21924: #include "nsFontFaceLoader.h"
20515: #include "nsIEventListenerManager.h"
25231: #include "nsStyleStructInlines.h"
27993: #include "nsIAppShell.h"
27993: #include "prenv.h"
29465: #include "nsIPrivateDOMEvent.h"
29465: #include "nsIDOMEventTarget.h"
30522: #include "nsObjectFrame.h"
33649: #include "nsTransitionManager.h"
41930: #include "mozilla/dom/Element.h"
42412: #include "nsIFrameMessageManager.h"
    1: 
23697: #ifdef MOZ_SMIL
23697: #include "nsSMILAnimationController.h"
23697: #endif // MOZ_SMIL
23697: 
    1: #ifdef IBMBIDI
    1: #include "nsBidiPresUtils.h"
    1: #endif // IBMBIDI
    1: 
    1: #include "nsContentUtils.h"
46695: #include "nsPIWindowRoot.h"
    1: 
    1: // Needed for Start/Stop of Image Animation
    1: #include "imgIContainer.h"
    1: #include "nsIImageLoadingContent.h"
    1: 
    1: //needed for resetting of image service color
    1: #include "nsLayoutCID.h"
 5235: 
33393: using mozilla::TimeDuration;
33393: using mozilla::TimeStamp;
41634: using namespace mozilla::dom;
33393: 
    1: static nscolor
    1: MakeColorPref(const char *colstr)
    1: {
    1:   PRUint32 red, green, blue;
    1:   nscolor colorref;
    1: 
    1:   // 4.x stored RGB color values as a string rather than as an int,
    1:   // thus we need to do this conversion
    1:   PR_sscanf(colstr, "#%02x%02x%02x", &red, &green, &blue);
    1:   colorref = NS_RGB(red, green, blue);
    1:   return colorref;
    1: }
    1: 
20261: int
    1: nsPresContext::PrefChangedCallback(const char* aPrefName, void* instance_data)
    1: {
    1:   nsPresContext*  presContext = (nsPresContext*)instance_data;
    1: 
    1:   NS_ASSERTION(nsnull != presContext, "bad instance data");
    1:   if (nsnull != presContext) {
    1:     presContext->PreferenceChanged(aPrefName);
    1:   }
    1:   return 0;  // PREF_OK
    1: }
    1: 
    1: 
    1: void
    1: nsPresContext::PrefChangedUpdateTimerCallback(nsITimer *aTimer, void *aClosure)
    1: {
    1:   nsPresContext*  presContext = (nsPresContext*)aClosure;
    1:   NS_ASSERTION(presContext != nsnull, "bad instance data");
    1:   if (presContext)
    1:     presContext->UpdateAfterPreferencesChanged();
    1: }
    1: 
    1: #ifdef IBMBIDI
    1: static PRBool
    1: IsVisualCharset(const nsCString& aCharset)
    1: {
    1:   if (aCharset.LowerCaseEqualsLiteral("ibm864")             // Arabic//ahmed
    1:       || aCharset.LowerCaseEqualsLiteral("ibm862")          // Hebrew
    1:       || aCharset.LowerCaseEqualsLiteral("iso-8859-8") ) {  // Hebrew
    1:     return PR_TRUE; // visual text type
    1:   }
    1:   else {
    1:     return PR_FALSE; // logical text type
    1:   }
    1: }
    1: #endif // IBMBIDI
    1: 
    1: 
20261: static PLDHashOperator
25231: destroy_loads(const void * aKey, nsRefPtr<nsImageLoader>& aData, void* closure)
    1: {
    1:   aData->Destroy();
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
    1: static NS_DEFINE_CID(kLookAndFeelCID,  NS_LOOKANDFEEL_CID);
    1: #include "nsContentCID.h"
    1: 
    1:   // NOTE! nsPresContext::operator new() zeroes out all members, so don't
    1:   // bother initializing members to 0.
    1: 
    1: nsPresContext::nsPresContext(nsIDocument* aDocument, nsPresContextType aType)
 4359:   : mType(aType), mDocument(aDocument), mTextZoom(1.0), mFullZoom(1.0),
  653:     mPageSize(-1, -1), mPPScale(1.0f),
    1:     mViewportStyleOverflow(NS_STYLE_OVERFLOW_AUTO, NS_STYLE_OVERFLOW_AUTO),
    1:     mImageAnimationModePref(imgIContainer::kNormalAnimMode),
    1:     // Font sizes default to zero; they will be set in GetFontPreferences
    1:     mDefaultVariableFont("serif", NS_FONT_STYLE_NORMAL, NS_FONT_VARIANT_NORMAL,
24408:                          NS_FONT_WEIGHT_NORMAL, NS_FONT_STRETCH_NORMAL, 0, 0),
  653:     mDefaultFixedFont("monospace", NS_FONT_STYLE_NORMAL,
24408:                       NS_FONT_VARIANT_NORMAL, NS_FONT_WEIGHT_NORMAL,
24408:                       NS_FONT_STRETCH_NORMAL, 0, 0),
    1:     mDefaultSerifFont("serif", NS_FONT_STYLE_NORMAL, NS_FONT_VARIANT_NORMAL,
24408:                       NS_FONT_WEIGHT_NORMAL, NS_FONT_STRETCH_NORMAL, 0, 0),
  653:     mDefaultSansSerifFont("sans-serif", NS_FONT_STYLE_NORMAL,
24408:                           NS_FONT_VARIANT_NORMAL, NS_FONT_WEIGHT_NORMAL,
24408:                           NS_FONT_STRETCH_NORMAL, 0, 0),
  653:     mDefaultMonospaceFont("monospace", NS_FONT_STYLE_NORMAL,
24408:                           NS_FONT_VARIANT_NORMAL, NS_FONT_WEIGHT_NORMAL,
24408:                           NS_FONT_STRETCH_NORMAL, 0, 0),
  653:     mDefaultCursiveFont("cursive", NS_FONT_STYLE_NORMAL,
24408:                         NS_FONT_VARIANT_NORMAL, NS_FONT_WEIGHT_NORMAL,
24408:                         NS_FONT_STRETCH_NORMAL, 0, 0),
  653:     mDefaultFantasyFont("fantasy", NS_FONT_STYLE_NORMAL,
24408:                         NS_FONT_VARIANT_NORMAL, NS_FONT_WEIGHT_NORMAL,
38816:                         NS_FONT_STRETCH_NORMAL, 0, 0)
    1: {
    1:   // NOTE! nsPresContext::operator new() zeroes out all members, so don't
    1:   // bother initializing members to 0.
    1: 
    1:   mDoScaledTwips = PR_TRUE;
    1: 
    1:   SetBackgroundImageDraw(PR_TRUE);		// always draw the background
    1:   SetBackgroundColorDraw(PR_TRUE);
    1: 
    1:   mBackgroundColor = NS_RGB(0xFF, 0xFF, 0xFF);
    1:   
    1:   mUseDocumentColors = PR_TRUE;
    1:   mUseDocumentFonts = PR_TRUE;
    1: 
    1:   // the minimum font-size is unconstrained by default
    1: 
    1:   mLinkColor = NS_RGB(0x00, 0x00, 0xEE);
    1:   mActiveLinkColor = NS_RGB(0xEE, 0x00, 0x00);
    1:   mVisitedLinkColor = NS_RGB(0x55, 0x1A, 0x8B);
    1:   mUnderlineLinks = PR_TRUE;
    1: 
    1:   mFocusTextColor = mDefaultColor;
    1:   mFocusBackgroundColor = mBackgroundColor;
    1:   mFocusRingWidth = 1;
    1: 
    1:   if (aType == eContext_Galley) {
    1:     mMedium = nsGkAtoms::screen;
    1:   } else {
    1:     mMedium = nsGkAtoms::print;
    1:     mPaginated = PR_TRUE;
    1:   }
    1: 
    1:   if (!IsDynamic()) {
    1:     mImageAnimationMode = imgIContainer::kDontAnimMode;
    1:     mNeverAnimate = PR_TRUE;
    1:   } else {
    1:     mImageAnimationMode = imgIContainer::kNormalAnimMode;
    1:     mNeverAnimate = PR_FALSE;
    1:   }
    1:   NS_ASSERTION(mDocument, "Null document");
19962:   mUserFontSet = nsnull;
21924:   mUserFontSetDirty = PR_TRUE;
    1: }
    1: 
    1: nsPresContext::~nsPresContext()
    1: {
    1:   NS_PRECONDITION(!mShell, "Presshell forgot to clear our mShell pointer");
    1:   SetShell(nsnull);
    1: 
36616:   if (mTransitionManager) {
36616:     mTransitionManager->Disconnect();
36616:   }
36590: 
36615:   // Disconnect the refresh driver *after* the transition manager, which
36615:   // needs it.
50366:   if (mRefreshDriver && mRefreshDriver->PresContext() == this) {
36615:     mRefreshDriver->Disconnect();
36615:   }
36615: 
    1:   if (mEventManager) {
    1:     // unclear if these are needed, but can't hurt
    1:     mEventManager->NotifyDestroyPresContext(this);
    1:     mEventManager->SetPresContext(nsnull);
    1: 
    1:     NS_RELEASE(mEventManager);
    1:   }
    1: 
    1:   if (mPrefChangedTimer)
    1:   {
    1:     mPrefChangedTimer->Cancel();
    1:     mPrefChangedTimer = nsnull;
    1:   }
    1: 
    1:   // Unregister preference callbacks
    1:   nsContentUtils::UnregisterPrefCallback("font.",
    1:                                          nsPresContext::PrefChangedCallback,
    1:                                          this);
    1:   nsContentUtils::UnregisterPrefCallback("browser.display.",
    1:                                          nsPresContext::PrefChangedCallback,
    1:                                          this);
    1:   nsContentUtils::UnregisterPrefCallback("browser.underline_anchors",
    1:                                          nsPresContext::PrefChangedCallback,
    1:                                          this);
    1:   nsContentUtils::UnregisterPrefCallback("browser.anchor_color",
    1:                                          nsPresContext::PrefChangedCallback,
    1:                                          this);
    1:   nsContentUtils::UnregisterPrefCallback("browser.active_color",
    1:                                          nsPresContext::PrefChangedCallback,
    1:                                          this);
    1:   nsContentUtils::UnregisterPrefCallback("browser.visited_color",
    1:                                          nsPresContext::PrefChangedCallback,
    1:                                          this);
    1:   nsContentUtils::UnregisterPrefCallback("image.animation_mode",
    1:                                          nsPresContext::PrefChangedCallback,
    1:                                          this);
    1: #ifdef IBMBIDI
    1:   nsContentUtils::UnregisterPrefCallback("bidi.", PrefChangedCallback, this);
    1: 
    1:   delete mBidiUtils;
    1: #endif // IBMBIDI
43347:   nsContentUtils::UnregisterPrefCallback("gfx.font_rendering.",
43347:                                          nsPresContext::PrefChangedCallback,
43347:                                          this);
    1:   nsContentUtils::UnregisterPrefCallback("layout.css.dpi",
    1:                                          nsPresContext::PrefChangedCallback,
    1:                                          this);
28470:   nsContentUtils::UnregisterPrefCallback("layout.css.devPixelsPerPx",
28470:                                          nsPresContext::PrefChangedCallback,
28470:                                          this);
    1: 
    1:   NS_IF_RELEASE(mDeviceContext);
    1:   NS_IF_RELEASE(mLookAndFeel);
38492:   NS_IF_RELEASE(mLanguage);
    1: }
    1: 
 4484: NS_IMPL_CYCLE_COLLECTION_CLASS(nsPresContext)
 4484: 
 4484: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsPresContext)
39823:    NS_INTERFACE_MAP_ENTRY(nsISupports)
 4484:    NS_INTERFACE_MAP_ENTRY(nsIObserver)
 4484: NS_INTERFACE_MAP_END
 4484: 
 4484: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsPresContext)
 4484: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsPresContext)
 4484: 
20261: static PLDHashOperator
25231: TraverseImageLoader(const void * aKey, nsRefPtr<nsImageLoader>& aData,
 4484:                     void* aClosure)
 4484: {
 4484:   nsCycleCollectionTraversalCallback *cb =
 4484:     static_cast<nsCycleCollectionTraversalCallback*>(aClosure);
 4484: 
 4484:   cb->NoteXPCOMChild(aData);
 4484: 
 4484:   return PL_DHASH_NEXT;
 4484: }
 4484: 
 4484: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsPresContext)
 4484:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDocument);
 4484:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(mDeviceContext); // worth bothering?
 4484:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(mEventManager);
 4484:   // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(mLookAndFeel); // a service
38492:   // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(mLanguage); // an atom
 4484: 
25231:   for (PRUint32 i = 0; i < IMAGE_LOAD_TYPE_COUNT; ++i)
25231:     tmp->mImageLoaders[i].Enumerate(TraverseImageLoader, &cb);
 4484: 
 4484:   // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mTheme); // a service
 4484:   // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLangService); // a service
 4484:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mPrintSettings);
 4484:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mPrefChangedTimer);
 4484: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 4484: 
 4484: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsPresContext)
 4484:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDocument);
 4484:   NS_RELEASE(tmp->mDeviceContext); // worth bothering?
 4484:   if (tmp->mEventManager) {
 4484:     // unclear if these are needed, but can't hurt
 4484:     tmp->mEventManager->NotifyDestroyPresContext(tmp);
 4484:     tmp->mEventManager->SetPresContext(nsnull);
 4484: 
 4484:     NS_RELEASE(tmp->mEventManager);
 4484:   }
 4484: 
 4484:   // NS_RELEASE(tmp->mLookAndFeel); // a service
38492:   // NS_RELEASE(tmp->mLanguage); // an atom
 4484: 
 4484:   // NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mTheme); // a service
 4484:   // NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mLangService); // a service
 4484:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mPrintSettings);
 4484:   if (tmp->mPrefChangedTimer)
 4484:   {
 4484:     tmp->mPrefChangedTimer->Cancel();
 4484:     tmp->mPrefChangedTimer = nsnull;
 4484:   }
 4484: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 4484: 
    1: 
    1: #define MAKE_FONT_PREF_KEY(_pref, _s0, _s1) \
    1:  _pref.Assign(_s0); \
    1:  _pref.Append(_s1);
    1: 
    1: static const char* const kGenericFont[] = {
    1:   ".variable.",
    1:   ".fixed.",
    1:   ".serif.", 
    1:   ".sans-serif.", 
    1:   ".monospace.",
    1:   ".cursive.",
    1:   ".fantasy."
    1: };
    1: 
25560: // whether no native theme service exists;
25560: // if this gets set to true, we'll stop asking for it.
25560: static PRBool sNoTheme = PR_FALSE;
25560: 
    1: // Set to true when LookAndFeelChanged needs to be called.  This is used
    1: // because the look and feel is a service, so there's no need to notify it from
    1: // more than one prescontext.
    1: static PRBool sLookAndFeelChanged;
    1: 
    1: // Set to true when ThemeChanged needs to be called on mTheme.  This is used
    1: // because mTheme is a service, so there's no need to notify it from more than
    1: // one prescontext.
    1: static PRBool sThemeChanged;
    1: 
    1: void
    1: nsPresContext::GetFontPreferences()
    1: {
    1:   /* Fetch the font prefs to be used -- see bug 61883 for details.
    1:      Not all prefs are needed upfront. Some are fallback prefs intended
    1:      for the GFX font sub-system...
    1: 
    1:   1) unit : assumed to be the same for all language groups -------------
    1:   font.size.unit = px | pt    XXX could be folded in the size... bug 90440
    1: 
    1:   2) attributes for generic fonts --------------------------------------
    1:   font.default = serif | sans-serif - fallback generic font
    1:   font.name.[generic].[langGroup] = current user' selected font on the pref dialog
    1:   font.name-list.[generic].[langGroup] = fontname1, fontname2, ... [factory pre-built list]
    1:   font.size.[generic].[langGroup] = integer - settable by the user
    1:   font.size-adjust.[generic].[langGroup] = "float" - settable by the user
    1:   font.minimum-size.[langGroup] = integer - settable by the user
    1:   */
    1: 
    1:   mDefaultVariableFont.size = CSSPixelsToAppUnits(16);
    1:   mDefaultFixedFont.size = CSSPixelsToAppUnits(13);
    1: 
38492:   // the font prefs are based on langGroup, not actual language
39100:   nsCAutoString langGroup;
38492:   if (mLanguage && mLangService) {
38492:     nsresult rv;
38492:     nsIAtom *group = mLangService->GetLanguageGroup(mLanguage, &rv);
38492:     if (NS_SUCCEEDED(rv) && group) {
39100:       group->ToUTF8String(langGroup);
38492:     }
39100:     else {
39100:       langGroup.AssignLiteral("x-western"); // Assume x-western is safe...
39100:     }
39100:   }
39100:   else {
39100:     langGroup.AssignLiteral("x-western"); // Assume x-western is safe...
 6850:   }
    1: 
    1:   nsCAutoString pref;
    1: 
    1:   // get the current applicable font-size unit
    1:   enum {eUnit_unknown = -1, eUnit_px, eUnit_pt};
    1:   PRInt32 unit = eUnit_px;
    1: 
    1:   nsAdoptingCString cvalue =
    1:     nsContentUtils::GetCharPref("font.size.unit");
    1: 
    1:   if (!cvalue.IsEmpty()) {
    1:     if (cvalue.Equals("px")) {
    1:       unit = eUnit_px;
    1:     }
    1:     else if (cvalue.Equals("pt")) {
    1:       unit = eUnit_pt;
    1:     }
    1:     else {
    1:       NS_WARNING("unexpected font-size unit -- expected: 'px' or 'pt'");
    1:       unit = eUnit_unknown;
    1:     }
    1:   }
    1: 
    1:   // get font.minimum-size.[langGroup]
    1: 
    1:   pref.Assign("font.minimum-size.");
    1:   pref.Append(langGroup);
    1: 
    1:   PRInt32 size = nsContentUtils::GetIntPref(pref.get());
    1:   if (unit == eUnit_px) {
    1:     mMinimumFontSize = CSSPixelsToAppUnits(size);
    1:   }
    1:   else if (unit == eUnit_pt) {
50791:     mMinimumFontSize = CSSPointsToAppUnits(size);
    1:   }
    1: 
    1:   // get attributes specific to each generic font
    1:   nsCAutoString generic_dot_langGroup;
    1:   for (PRInt32 eType = eDefaultFont_Variable; eType < eDefaultFont_COUNT; ++eType) {
    1:     generic_dot_langGroup.Assign(kGenericFont[eType]);
    1:     generic_dot_langGroup.Append(langGroup);
    1: 
    1:     nsFont* font;
    1:     switch (eType) {
    1:       case eDefaultFont_Variable:  font = &mDefaultVariableFont;  break;
    1:       case eDefaultFont_Fixed:     font = &mDefaultFixedFont;     break;
    1:       case eDefaultFont_Serif:     font = &mDefaultSerifFont;     break;
    1:       case eDefaultFont_SansSerif: font = &mDefaultSansSerifFont; break;
    1:       case eDefaultFont_Monospace: font = &mDefaultMonospaceFont; break;
    1:       case eDefaultFont_Cursive:   font = &mDefaultCursiveFont;   break;
    1:       case eDefaultFont_Fantasy:   font = &mDefaultFantasyFont;   break;
    1:     }
    1: 
    1:     // set the default variable font (the other fonts are seen as 'generic' fonts
    1:     // in GFX and will be queried there when hunting for alternative fonts)
    1:     if (eType == eDefaultFont_Variable) {
    1:       MAKE_FONT_PREF_KEY(pref, "font.name", generic_dot_langGroup);
    1: 
    1:       nsAdoptingString value =
    1:         nsContentUtils::GetStringPref(pref.get());
    1:       if (!value.IsEmpty()) {
    1:         font->name.Assign(value);
    1:       }
    1:       else {
    1:         MAKE_FONT_PREF_KEY(pref, "font.default.", langGroup);
    1:         value = nsContentUtils::GetStringPref(pref.get());
    1:         if (!value.IsEmpty()) {
    1:           mDefaultVariableFont.name.Assign(value);
    1:         }
    1:       } 
    1:     }
    1:     else {
    1:       if (eType == eDefaultFont_Monospace) {
    1:         // This takes care of the confusion whereby people often expect "monospace" 
    1:         // to have the same default font-size as "-moz-fixed" (this tentative
    1:         // size may be overwritten with the specific value for "monospace" when
    1:         // "font.size.monospace.[langGroup]" is read -- see below)
    1:         font->size = mDefaultFixedFont.size;
    1:       }
    1:       else if (eType != eDefaultFont_Fixed) {
    1:         // all the other generic fonts are initialized with the size of the
    1:         // variable font, but their specific size can supersede later -- see below
    1:         font->size = mDefaultVariableFont.size;
    1:       }
    1:     }
    1: 
    1:     // Bug 84398: for spec purists, a different font-size only applies to the
    1:     // .variable. and .fixed. fonts and the other fonts should get |font-size-adjust|.
    1:     // The problem is that only GfxWin has the support for |font-size-adjust|. So for
    1:     // parity, we enable the ability to set a different font-size on all platforms.
    1: 
    1:     // get font.size.[generic].[langGroup]
    1:     // size=0 means 'Auto', i.e., generic fonts retain the size of the variable font
    1:     MAKE_FONT_PREF_KEY(pref, "font.size", generic_dot_langGroup);
    1:     size = nsContentUtils::GetIntPref(pref.get());
    1:     if (size > 0) {
    1:       if (unit == eUnit_px) {
50791:         font->size = CSSPixelsToAppUnits(size);
    1:       }
    1:       else if (unit == eUnit_pt) {
50791:         font->size = CSSPointsToAppUnits(size);
    1:       }
    1:     }
    1: 
    1:     // get font.size-adjust.[generic].[langGroup]
    1:     // XXX only applicable on GFX ports that handle |font-size-adjust|
    1:     MAKE_FONT_PREF_KEY(pref, "font.size-adjust", generic_dot_langGroup);
    1:     cvalue = nsContentUtils::GetCharPref(pref.get());
    1:     if (!cvalue.IsEmpty()) {
    1:       font->sizeAdjust = (float)atof(cvalue.get());
    1:     }
    1: 
    1: #ifdef DEBUG_rbs
    1:     printf("%s Family-list:%s size:%d sizeAdjust:%.2f\n",
    1:            generic_dot_langGroup.get(),
    1:            NS_ConvertUTF16toUTF8(font->name).get(), font->size,
    1:            font->sizeAdjust);
    1: #endif
    1:   }
    1: }
    1: 
    1: void
    1: nsPresContext::GetDocumentColorPreferences()
    1: {
    1:   PRInt32 useAccessibilityTheme = 0;
    1:   PRBool usePrefColors = PR_TRUE;
    1:   nsCOMPtr<nsIDocShellTreeItem> docShell(do_QueryReferent(mContainer));
    1:   if (docShell) {
    1:     PRInt32 docShellType;
    1:     docShell->GetItemType(&docShellType);
    1:     if (nsIDocShellTreeItem::typeChrome == docShellType) {
    1:       usePrefColors = PR_FALSE;
    1:     }
    1:     else {
    1:       mLookAndFeel->GetMetric(nsILookAndFeel::eMetric_UseAccessibilityTheme, useAccessibilityTheme);
    1:       usePrefColors = !useAccessibilityTheme;
    1:     }
    1: 
    1:   }
    1:   if (usePrefColors) {
    1:     usePrefColors =
    1:       !nsContentUtils::GetBoolPref("browser.display.use_system_colors",
    1:                                    PR_FALSE);
    1:   }
    1: 
    1:   if (usePrefColors) {
    1:     nsAdoptingCString colorStr =
    1:       nsContentUtils::GetCharPref("browser.display.foreground_color");
    1: 
    1:     if (!colorStr.IsEmpty()) {
    1:       mDefaultColor = MakeColorPref(colorStr);
    1:     }
    1: 
    1:     colorStr =
    1:       nsContentUtils::GetCharPref("browser.display.background_color");
    1: 
    1:     if (!colorStr.IsEmpty()) {
    1:       mBackgroundColor = MakeColorPref(colorStr);
    1:     }
    1:   }
    1:   else {
    1:     mDefaultColor = NS_RGB(0x00, 0x00, 0x00);
    1:     mBackgroundColor = NS_RGB(0xFF, 0xFF, 0xFF);
    1:     mLookAndFeel->GetColor(nsILookAndFeel::eColor_WindowForeground,
    1:                            mDefaultColor);
    1:     mLookAndFeel->GetColor(nsILookAndFeel::eColor_WindowBackground,
    1:                            mBackgroundColor);
    1:   }
    1: 
19436:   // Wherever we got the default background color from, ensure it is
19436:   // opaque.
19436:   mBackgroundColor = NS_ComposeColors(NS_RGB(0xFF, 0xFF, 0xFF),
19436:                                       mBackgroundColor);
19436: 
    1:   mUseDocumentColors = !useAccessibilityTheme &&
    1:     nsContentUtils::GetBoolPref("browser.display.use_document_colors",
    1:                                 mUseDocumentColors);
    1: }
    1: 
    1: void
    1: nsPresContext::GetUserPreferences()
    1: {
    1:   if (!GetPresShell()) {
    1:     // No presshell means nothing to do here.  We'll do this when we
    1:     // get a presshell.
    1:     return;
    1:   }
    1:     
    1:   mFontScaler =
    1:     nsContentUtils::GetIntPref("browser.display.base_font_scaler",
    1:                                mFontScaler);
    1: 
11409: 
11409:   mAutoQualityMinFontSizePixelsPref =
11409:     nsContentUtils::GetIntPref("browser.display.auto_quality_min_font_size");
11409: 
    1:   // * document colors
    1:   GetDocumentColorPreferences();
    1: 
    1:   // * link colors
    1:   mUnderlineLinks =
    1:     nsContentUtils::GetBoolPref("browser.underline_anchors", mUnderlineLinks);
    1: 
    1:   nsAdoptingCString colorStr =
    1:     nsContentUtils::GetCharPref("browser.anchor_color");
    1: 
    1:   if (!colorStr.IsEmpty()) {
    1:     mLinkColor = MakeColorPref(colorStr);
    1:   }
    1: 
    1:   colorStr =
    1:     nsContentUtils::GetCharPref("browser.active_color");
    1: 
    1:   if (!colorStr.IsEmpty()) {
    1:     mActiveLinkColor = MakeColorPref(colorStr);
    1:   }
    1: 
    1:   colorStr = nsContentUtils::GetCharPref("browser.visited_color");
    1: 
    1:   if (!colorStr.IsEmpty()) {
    1:     mVisitedLinkColor = MakeColorPref(colorStr);
    1:   }
    1: 
    1:   mUseFocusColors =
    1:     nsContentUtils::GetBoolPref("browser.display.use_focus_colors",
    1:                                 mUseFocusColors);
    1: 
    1:   mFocusTextColor = mDefaultColor;
    1:   mFocusBackgroundColor = mBackgroundColor;
    1: 
    1:   colorStr = nsContentUtils::GetCharPref("browser.display.focus_text_color");
    1: 
    1:   if (!colorStr.IsEmpty()) {
    1:     mFocusTextColor = MakeColorPref(colorStr);
    1:   }
    1: 
    1:   colorStr =
    1:     nsContentUtils::GetCharPref("browser.display.focus_background_color");
    1: 
    1:   if (!colorStr.IsEmpty()) {
    1:     mFocusBackgroundColor = MakeColorPref(colorStr);
    1:   }
    1: 
    1:   mFocusRingWidth =
    1:     nsContentUtils::GetIntPref("browser.display.focus_ring_width",
    1:                                mFocusRingWidth);
    1: 
    1:   mFocusRingOnAnything =
    1:     nsContentUtils::GetBoolPref("browser.display.focus_ring_on_anything",
    1:                                 mFocusRingOnAnything);
    1: 
20177:   mFocusRingStyle =
20177:           nsContentUtils::GetIntPref("browser.display.focus_ring_style",
20177:                                       mFocusRingStyle);
    1:   // * use fonts?
    1:   mUseDocumentFonts =
    1:     nsContentUtils::GetIntPref("browser.display.use_document_fonts") != 0;
    1: 
    1:   // * replace backslashes with Yen signs? (bug 245770)
    1:   mEnableJapaneseTransform =
    1:     nsContentUtils::GetBoolPref("layout.enable_japanese_specific_transform");
    1: 
    1:   mPrefScrollbarSide =
    1:     nsContentUtils::GetIntPref("layout.scrollbar.side");
    1: 
    1:   GetFontPreferences();
    1: 
    1:   // * image animation
    1:   const nsAdoptingCString& animatePref =
    1:     nsContentUtils::GetCharPref("image.animation_mode");
    1:   if (animatePref.Equals("normal"))
    1:     mImageAnimationModePref = imgIContainer::kNormalAnimMode;
    1:   else if (animatePref.Equals("none"))
    1:     mImageAnimationModePref = imgIContainer::kDontAnimMode;
    1:   else if (animatePref.Equals("once"))
    1:     mImageAnimationModePref = imgIContainer::kLoopOnceAnimMode;
11409:   else // dynamic change to invalid value should act like it does initially
11409:     mImageAnimationModePref = imgIContainer::kNormalAnimMode;
    1: 
    1:   PRUint32 bidiOptions = GetBidi();
    1: 
    1:   PRInt32 prefInt =
    1:     nsContentUtils::GetIntPref(IBMBIDI_TEXTDIRECTION_STR,
    1:                                GET_BIDI_OPTION_DIRECTION(bidiOptions));
    1:   SET_BIDI_OPTION_DIRECTION(bidiOptions, prefInt);
    1:   mPrefBidiDirection = prefInt;
    1: 
    1:   prefInt =
    1:     nsContentUtils::GetIntPref(IBMBIDI_TEXTTYPE_STR,
    1:                                GET_BIDI_OPTION_TEXTTYPE(bidiOptions));
    1:   SET_BIDI_OPTION_TEXTTYPE(bidiOptions, prefInt);
    1: 
    1:   prefInt =
    1:     nsContentUtils::GetIntPref(IBMBIDI_NUMERAL_STR,
    1:                                GET_BIDI_OPTION_NUMERAL(bidiOptions));
    1:   SET_BIDI_OPTION_NUMERAL(bidiOptions, prefInt);
    1: 
    1:   prefInt =
    1:     nsContentUtils::GetIntPref(IBMBIDI_SUPPORTMODE_STR,
    1:                                GET_BIDI_OPTION_SUPPORT(bidiOptions));
    1:   SET_BIDI_OPTION_SUPPORT(bidiOptions, prefInt);
    1: 
    1:   prefInt =
    1:     nsContentUtils::GetIntPref(IBMBIDI_CHARSET_STR,
    1:                                GET_BIDI_OPTION_CHARACTERSET(bidiOptions));
    1:   SET_BIDI_OPTION_CHARACTERSET(bidiOptions, prefInt);
    1: 
    1:   // We don't need to force reflow: either we are initializing a new
    1:   // prescontext or we are being called from UpdateAfterPreferencesChanged()
    1:   // which triggers a reflow anyway.
    1:   SetBidi(bidiOptions, PR_FALSE);
    1: }
    1: 
50433: void
50433: nsPresContext::PreferenceChanged(const char* aPrefName)
    1: {
50433:   nsDependentCString prefName(aPrefName);
50433:   if (prefName.EqualsLiteral("layout.css.dpi") ||
50433:       prefName.EqualsLiteral("layout.css.devPixelsPerPx")) {
 9280:     PRInt32 oldAppUnitsPerDevPixel = AppUnitsPerDevPixel();
50433:     if (mDeviceContext->CheckDPIChange() && mShell) {
 9280:       mDeviceContext->FlushFontCache();
 9280: 
 8940:       // Re-fetch the view manager's window dimensions in case there's a deferred
 8940:       // resize which hasn't affected our mVisibleArea yet
 8940:       nscoord oldWidthAppUnits, oldHeightAppUnits;
26050:       nsIViewManager* vm = mShell->GetViewManager();
 8940:       vm->GetWindowDimensions(&oldWidthAppUnits, &oldHeightAppUnits);
 9280:       float oldWidthDevPixels = oldWidthAppUnits/oldAppUnitsPerDevPixel;
 9280:       float oldHeightDevPixels = oldHeightAppUnits/oldAppUnitsPerDevPixel;
    1: 
 8940:       nscoord width = NSToCoordRound(oldWidthDevPixels*AppUnitsPerDevPixel());
 8940:       nscoord height = NSToCoordRound(oldHeightDevPixels*AppUnitsPerDevPixel());
    1:       vm->SetWindowDimensions(width, height);
    1: 
16226:       MediaFeatureValuesChanged(PR_TRUE);
11409:       RebuildAllStyleData(NS_STYLE_HINT_REFLOW);
    1:     }
    1:     return;
    1:   }
11409:   if (StringBeginsWith(prefName, NS_LITERAL_CSTRING("font."))) {
11409:     // Changes to font family preferences don't change anything in the
11409:     // computed style data, so the style system won't generate a reflow
11409:     // hint for us.  We need to do that manually.
11409: 
11409:     // FIXME We could probably also handle changes to
11409:     // browser.display.auto_quality_min_font_size here, but that
11409:     // probably also requires clearing the text run cache, so don't
11409:     // bother (yet, anyway).
11409:     mPrefChangePendingNeedsReflow = PR_TRUE;
 4032:   }
22917:   if (StringBeginsWith(prefName, NS_LITERAL_CSTRING("bidi."))) {
22917:     // Changes to bidi prefs need to trigger a reflow (see bug 443629)
22917:     mPrefChangePendingNeedsReflow = PR_TRUE;
22917: 
22917:     // Changes to bidi.numeral also needs to empty the text run cache.
22917:     // This is handled in gfxTextRunWordCache.cpp.
22917:   }
43347:   if (StringBeginsWith(prefName, NS_LITERAL_CSTRING("gfx.font_rendering."))) {
43347:     // Changes to font_rendering prefs need to trigger a reflow
43347:     mPrefChangePendingNeedsReflow = PR_TRUE;
43347:   }
    1:   // we use a zero-delay timer to coalesce multiple pref updates
    1:   if (!mPrefChangedTimer)
    1:   {
    1:     mPrefChangedTimer = do_CreateInstance("@mozilla.org/timer;1");
    1:     if (!mPrefChangedTimer)
    1:       return;
    1:     mPrefChangedTimer->InitWithFuncCallback(nsPresContext::PrefChangedUpdateTimerCallback, (void*)this, 0, nsITimer::TYPE_ONE_SHOT);
    1:   }
    1: }
    1: 
    1: void
    1: nsPresContext::UpdateAfterPreferencesChanged()
    1: {
    1:   mPrefChangedTimer = nsnull;
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> docShell(do_QueryReferent(mContainer));
    1:   if (docShell) {
    1:     PRInt32 docShellType;
    1:     docShell->GetItemType(&docShellType);
    1:     if (nsIDocShellTreeItem::typeChrome == docShellType)
    1:       return;
    1:   }
    1: 
    1:   // Initialize our state from the user preferences
    1:   GetUserPreferences();
    1: 
    1:   // update the presShell: tell it to set the preference style rules up
    1:   if (mShell) {
    1:     mShell->SetPreferenceStyleRules(PR_TRUE);
    1:   }
    1: 
    1:   mDeviceContext->FlushFontCache();
11409: 
11409:   nsChangeHint hint = nsChangeHint(0);
11409: 
11409:   if (mPrefChangePendingNeedsReflow) {
11409:     NS_UpdateHint(hint, NS_STYLE_HINT_REFLOW);
11409:   }
11409: 
11409:   RebuildAllStyleData(hint);
    1: }
    1: 
    1: nsresult
    1: nsPresContext::Init(nsIDeviceContext* aDeviceContext)
    1: {
37970:   NS_ASSERTION(!mInitialized, "attempt to reinit pres context");
    1:   NS_ENSURE_ARG(aDeviceContext);
    1: 
    1:   mDeviceContext = aDeviceContext;
    1:   NS_ADDREF(mDeviceContext);
    1: 
 8362:   if (mDeviceContext->SetPixelScale(mFullZoom))
 8362:     mDeviceContext->FlushFontCache();
 5249:   mCurAppUnitsPerDevPixel = AppUnitsPerDevPixel();
 5249: 
25231:   for (PRUint32 i = 0; i < IMAGE_LOAD_TYPE_COUNT; ++i)
25231:     if (!mImageLoaders[i].Init())
21023:       return NS_ERROR_OUT_OF_MEMORY;
21023:   
    1:   // Get the look and feel service here; default colors will be initialized
    1:   // from calling GetUserPreferences() when we get a presshell.
    1:   nsresult rv = CallGetService(kLookAndFeelCID, &mLookAndFeel);
    1:   if (NS_FAILED(rv)) {
    1:     NS_ERROR("LookAndFeel service must be implemented for this toolkit");
    1:     return rv;
    1:   }
    1: 
    1:   mEventManager = new nsEventStateManager();
    1:   if (!mEventManager)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(mEventManager);
    1: 
33649:   mTransitionManager = new nsTransitionManager(this);
36615:   if (!mTransitionManager)
36615:     return NS_ERROR_OUT_OF_MEMORY;
36615: 
50366:   if (mDocument->GetDisplayDocument()) {
50366:     NS_ASSERTION(mDocument->GetDisplayDocument()->GetShell() &&
50366:                  mDocument->GetDisplayDocument()->GetShell()->GetPresContext(),
50366:                  "Why are we being initialized?");
50366:     mRefreshDriver = mDocument->GetDisplayDocument()->GetShell()->
50366:       GetPresContext()->RefreshDriver();
50366:   } else {
52103:     nsIDocument* parent = mDocument->GetParentDocument();
52103:     // Unfortunately, sometimes |parent| here has no presshell because
52103:     // printing screws up things.  Assert that in other cases it does,
52103:     // but whenever the shell is null just fall back on using our own
52103:     // refresh driver.
52103:     NS_ASSERTION(!parent || mDocument->IsStaticDocument() || parent->GetShell(),
52103:                  "How did we end up with a presshell if our parent doesn't "
52103:                  "have one?");
52103:     if (parent && parent->GetShell()) {
52103:       NS_ASSERTION(parent->GetShell()->GetPresContext(),
52103:                    "How did we get a presshell?");
52103: 
50366:       // We don't have our container set yet at this point
50366:       nsCOMPtr<nsISupports> ourContainer = mDocument->GetContainer();
52103: 
50366:       nsCOMPtr<nsIDocShellTreeItem> ourItem = do_QueryInterface(ourContainer);
50366:       if (ourItem) {
50366:         nsCOMPtr<nsIDocShellTreeItem> parentItem;
50366:         ourItem->GetSameTypeParent(getter_AddRefs(parentItem));
52103:         if (parentItem) {
52103:           mRefreshDriver = parent->GetShell()->GetPresContext()->RefreshDriver();
50366:         }
50366:       }
50366:     }
50366: 
50366:     if (!mRefreshDriver) {
36615:       mRefreshDriver = new nsRefreshDriver(this);
36615:       if (!mRefreshDriver)
36615:         return NS_ERROR_OUT_OF_MEMORY;
50366:     }
50366:   }
33649: 
    1:   mLangService = do_GetService(NS_LANGUAGEATOMSERVICE_CONTRACTID);
    1: 
    1:   // Register callbacks so we're notified when the preferences change
    1:   nsContentUtils::RegisterPrefCallback("font.",
    1:                                        nsPresContext::PrefChangedCallback,
    1:                                        this);
    1:   nsContentUtils::RegisterPrefCallback("browser.display.",
    1:                                        nsPresContext::PrefChangedCallback,
    1:                                        this);
    1:   nsContentUtils::RegisterPrefCallback("browser.underline_anchors",
    1:                                        nsPresContext::PrefChangedCallback,
    1:                                        this);
    1:   nsContentUtils::RegisterPrefCallback("browser.anchor_color",
    1:                                        nsPresContext::PrefChangedCallback,
    1:                                        this);
    1:   nsContentUtils::RegisterPrefCallback("browser.active_color",
    1:                                        nsPresContext::PrefChangedCallback,
    1:                                        this);
    1:   nsContentUtils::RegisterPrefCallback("browser.visited_color",
    1:                                        nsPresContext::PrefChangedCallback,
    1:                                        this);
    1:   nsContentUtils::RegisterPrefCallback("image.animation_mode",
    1:                                        nsPresContext::PrefChangedCallback,
    1:                                        this);
    1: #ifdef IBMBIDI
    1:   nsContentUtils::RegisterPrefCallback("bidi.", PrefChangedCallback,
    1:                                        this);
    1: #endif
43347:   nsContentUtils::RegisterPrefCallback("gfx.font_rendering.", PrefChangedCallback,
43347:                                        this);
    1:   nsContentUtils::RegisterPrefCallback("layout.css.dpi",
    1:                                        nsPresContext::PrefChangedCallback,
    1:                                        this);
28470:   nsContentUtils::RegisterPrefCallback("layout.css.devPixelsPerPx",
28470:                                        nsPresContext::PrefChangedCallback,
28470:                                        this);
    1: 
    1:   rv = mEventManager->Init();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   mEventManager->SetPresContext(this);
    1: 
    1: #ifdef DEBUG
    1:   mInitialized = PR_TRUE;
    1: #endif
    1: 
    1:   mBorderWidthTable[NS_STYLE_BORDER_WIDTH_THIN] = CSSPixelsToAppUnits(1);
    1:   mBorderWidthTable[NS_STYLE_BORDER_WIDTH_MEDIUM] = CSSPixelsToAppUnits(3);
    1:   mBorderWidthTable[NS_STYLE_BORDER_WIDTH_THICK] = CSSPixelsToAppUnits(5);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // Note: We don't hold a reference on the shell; it has a reference to
    1: // us
    1: void
    1: nsPresContext::SetShell(nsIPresShell* aShell)
    1: {
23932:   if (mUserFontSet) {
23932:     // Clear out user font set if we have one
23932:     mUserFontSet->Destroy();
23932:     NS_RELEASE(mUserFontSet);
23932:   }
23932: 
    1:   if (mShell) {
    1:     // Remove ourselves as the charset observer from the shell's doc, because
    1:     // this shell may be going away for good.
    1:     nsIDocument *doc = mShell->GetDocument();
    1:     if (doc) {
    1:       doc->RemoveCharSetObserver(this);
    1:     }
    1:   }    
    1: 
    1:   mShell = aShell;
    1: 
    1:   if (mShell) {
    1:     nsIDocument *doc = mShell->GetDocument();
    1:     NS_ASSERTION(doc, "expect document here");
    1:     if (doc) {
    1:       // Have to update PresContext's mDocument before calling any other methods.
    1:       mDocument = doc;
    1:     }
    1:     // Initialize our state from the user preferences, now that we
    1:     // have a presshell, and hence a document.
    1:     GetUserPreferences();
    1: 
    1:     if (doc) {
    1:       nsIURI *docURI = doc->GetDocumentURI();
    1: 
    1:       if (IsDynamic() && docURI) {
    1:         PRBool isChrome = PR_FALSE;
    1:         PRBool isRes = PR_FALSE;
    1:         docURI->SchemeIs("chrome", &isChrome);
    1:         docURI->SchemeIs("resource", &isRes);
    1: 
    1:         if (!isChrome && !isRes)
    1:           mImageAnimationMode = mImageAnimationModePref;
    1:         else
    1:           mImageAnimationMode = imgIContainer::kNormalAnimMode;
    1:       }
    1: 
    1:       if (mLangService) {
    1:         doc->AddCharSetObserver(this);
    1:         UpdateCharSet(doc->GetDocumentCharacterSet());
    1:       }
    1:     }
37172:   } else {
37172:     // Destroy image loaders now that the presshell is going away.
37172:     // This is important since imageloaders can have pointers to frames and
37172:     // we don't want those pointers to outlive the destruction of the frame
37172:     // arena.
37172:     for (PRUint32 i = 0; i < IMAGE_LOAD_TYPE_COUNT; ++i) {
37172:       mImageLoaders[i].Enumerate(destroy_loads, nsnull);
37172:       mImageLoaders[i].Clear();
37172:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsPresContext::UpdateCharSet(const nsAFlatCString& aCharSet)
    1: {
    1:   if (mLangService) {
38492:     NS_IF_RELEASE(mLanguage);
38492:     mLanguage = mLangService->LookupCharSet(aCharSet.get()).get();  // addrefs
38492:     // this will be a language group (or script) code rather than a true language code
    1: 
    1:     // bug 39570: moved from nsLanguageAtomService::LookupCharSet()
    1: #if !defined(XP_BEOS) 
38492:     if (mLanguage == nsGkAtoms::Unicode) {
38492:       NS_RELEASE(mLanguage);
38492:       NS_IF_ADDREF(mLanguage = mLangService->GetLocaleLanguage()); 
    1:     }
    1: #endif
    1:     GetFontPreferences();
    1:   }
    1: #ifdef IBMBIDI
    1:   //ahmed
    1: 
    1:   switch (GET_BIDI_OPTION_TEXTTYPE(GetBidi())) {
    1: 
    1:     case IBMBIDI_TEXTTYPE_LOGICAL:
    1:       SetVisualMode(PR_FALSE);
    1:       break;
    1: 
    1:     case IBMBIDI_TEXTTYPE_VISUAL:
    1:       SetVisualMode(PR_TRUE);
    1:       break;
    1: 
    1:     case IBMBIDI_TEXTTYPE_CHARSET:
    1:     default:
    1:       SetVisualMode(IsVisualCharset(aCharSet));
    1:   }
    1: #endif // IBMBIDI
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPresContext::Observe(nsISupports* aSubject, 
    1:                         const char* aTopic,
    1:                         const PRUnichar* aData)
    1: {
    1:   if (!nsCRT::strcmp(aTopic, "charset")) {
    1:     UpdateCharSet(NS_LossyConvertUTF16toASCII(aData));
    1:     mDeviceContext->FlushFontCache();
11409:     RebuildAllStyleData(NS_STYLE_HINT_REFLOW);
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_WARNING("unrecognized topic in nsPresContext::Observe");
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: // We may want to replace this with something faster, maybe caching the root prescontext
30514: nsRootPresContext*
37502: nsPresContext::GetRootPresContext()
    1: {
    1:   nsPresContext* pc = this;
    1:   for (;;) {
    1:     if (pc->mShell) {
    1:       nsIFrame* rootFrame = pc->mShell->FrameManager()->GetRootFrame();
    1:       if (rootFrame) {
    1:         nsIFrame* f = nsLayoutUtils::GetCrossDocParentFrame(rootFrame);
    1:         if (f) {
  238:           pc = f->PresContext();
    1:           continue;
    1:         }
    1:       }
    1:     }
37502:     return pc->IsRoot() ? static_cast<nsRootPresContext*>(pc) : nsnull;
    1:   }
    1: }
    1: 
    1: void
    1: nsPresContext::CompatibilityModeChanged()
    1: {
    1:   if (!mShell)
    1:     return;
    1: 
    1:   // enable/disable the QuirkSheet
    1:   mShell->StyleSet()->
    1:     EnableQuirkStyleSheet(CompatibilityMode() == eCompatibility_NavQuirks);
    1: }
    1: 
    1: // Helper function for setting Anim Mode on image
    1: static void SetImgAnimModeOnImgReq(imgIRequest* aImgReq, PRUint16 aMode)
    1: {
    1:   if (aImgReq) {
    1:     nsCOMPtr<imgIContainer> imgCon;
    1:     aImgReq->GetImage(getter_AddRefs(imgCon));
    1:     if (imgCon) {
    1:       imgCon->SetAnimationMode(aMode);
    1:     }
    1:   }
    1: }
    1: 
    1:  // Enumeration call back for HashTable
20261: static PLDHashOperator
25231: set_animation_mode(const void * aKey, nsRefPtr<nsImageLoader>& aData, void* closure)
    1: {
25231:   for (nsImageLoader *loader = aData; loader;
25231:        loader = loader->GetNextLoader()) {
25231:     imgIRequest* imgReq = loader->GetRequest();
    1:     SetImgAnimModeOnImgReq(imgReq, (PRUint16)NS_PTR_TO_INT32(closure));
25231:   }
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
    1: // IMPORTANT: Assumption is that all images for a Presentation 
    1: // have the same Animation Mode (pavlov said this was OK)
    1: //
    1: // Walks content and set the animation mode
    1: // this is a way to turn on/off image animations
    1: void nsPresContext::SetImgAnimations(nsIContent *aParent, PRUint16 aMode)
    1: {
    1:   nsCOMPtr<nsIImageLoadingContent> imgContent(do_QueryInterface(aParent));
    1:   if (imgContent) {
    1:     nsCOMPtr<imgIRequest> imgReq;
    1:     imgContent->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
    1:                            getter_AddRefs(imgReq));
    1:     SetImgAnimModeOnImgReq(imgReq, aMode);
    1:   }
    1:   
    1:   PRUint32 count = aParent->GetChildCount();
    1:   for (PRUint32 i = 0; i < count; ++i) {
    1:     SetImgAnimations(aParent->GetChildAt(i), aMode);
    1:   }
    1: }
    1: 
23697: #ifdef MOZ_SMIL
23697: void
23697: nsPresContext::SetSMILAnimations(nsIDocument *aDoc, PRUint16 aNewMode,
23697:                                  PRUint16 aOldMode)
23697: {
38869:   if (aDoc->HasAnimationController()) {
23697:     nsSMILAnimationController* controller = aDoc->GetAnimationController();
23697:     switch (aNewMode)
23697:     {
23697:       case imgIContainer::kNormalAnimMode:
23697:       case imgIContainer::kLoopOnceAnimMode:
23697:         if (aOldMode == imgIContainer::kDontAnimMode)
23697:           controller->Resume(nsSMILTimeContainer::PAUSE_USERPREF);
23697:         break;
23697: 
23697:       case imgIContainer::kDontAnimMode:
23697:         if (aOldMode != imgIContainer::kDontAnimMode)
23697:           controller->Pause(nsSMILTimeContainer::PAUSE_USERPREF);
23697:         break;
23697:     }
23697:   }
23697: }
23697: #endif // MOZ_SMIL
23697: 
    1: void
    1: nsPresContext::SetImageAnimationModeInternal(PRUint16 aMode)
    1: {
    1:   NS_ASSERTION(aMode == imgIContainer::kNormalAnimMode ||
    1:                aMode == imgIContainer::kDontAnimMode ||
    1:                aMode == imgIContainer::kLoopOnceAnimMode, "Wrong Animation Mode is being set!");
    1: 
    1:   // Image animation mode cannot be changed when rendering to a printer.
    1:   if (!IsDynamic())
    1:     return;
    1: 
21025:   // Set the mode on the image loaders.
25231:   for (PRUint32 i = 0; i < IMAGE_LOAD_TYPE_COUNT; ++i)
25231:     mImageLoaders[i].Enumerate(set_animation_mode, NS_INT32_TO_PTR(aMode));
    1: 
    1:   // Now walk the content tree and set the animation mode 
21025:   // on all the images.
    1:   if (mShell != nsnull) {
    1:     nsIDocument *doc = mShell->GetDocument();
    1:     if (doc) {
41634:       Element *rootElement = doc->GetRootElement();
41634:       if (rootElement) {
41634:         SetImgAnimations(rootElement, aMode);
    1:       }
23697: 
23697: #ifdef MOZ_SMIL
23697:       SetSMILAnimations(doc, aMode, mImageAnimationMode);
23697: #endif // MOZ_SMIL
    1:     }
    1:   }
    1: 
    1:   mImageAnimationMode = aMode;
    1: }
    1: 
    1: void
    1: nsPresContext::SetImageAnimationModeExternal(PRUint16 aMode)
    1: {
    1:   SetImageAnimationModeInternal(aMode);
    1: }
    1: 
    1: already_AddRefed<nsIFontMetrics>
23846: nsPresContext::GetMetricsFor(const nsFont& aFont, PRBool aUseUserFontSet)
    1: {
    1:   nsIFontMetrics* metrics = nsnull;
38492:   mDeviceContext->GetMetricsFor(aFont, mLanguage,
23846:                                 aUseUserFontSet ? GetUserFontSet() : nsnull,
23846:                                 metrics);
    1:   return metrics;
    1: }
    1: 
    1: const nsFont*
20218: nsPresContext::GetDefaultFont(PRUint8 aFontID) const
    1: {
    1:   const nsFont *font;
    1:   switch (aFontID) {
    1:     // Special (our default variable width font and fixed width font)
    1:     case kPresContext_DefaultVariableFont_ID:
    1:       font = &mDefaultVariableFont;
    1:       break;
    1:     case kPresContext_DefaultFixedFont_ID:
    1:       font = &mDefaultFixedFont;
    1:       break;
    1:     // CSS
    1:     case kGenericFont_serif:
    1:       font = &mDefaultSerifFont;
    1:       break;
    1:     case kGenericFont_sans_serif:
    1:       font = &mDefaultSansSerifFont;
    1:       break;
    1:     case kGenericFont_monospace:
    1:       font = &mDefaultMonospaceFont;
    1:       break;
    1:     case kGenericFont_cursive:
    1:       font = &mDefaultCursiveFont;
    1:       break;
    1:     case kGenericFont_fantasy: 
    1:       font = &mDefaultFantasyFont;
    1:       break;
    1:     default:
    1:       font = nsnull;
    1:       NS_ERROR("invalid arg");
    1:       break;
    1:   }
    1:   return font;
    1: }
    1: 
    1: void
 4003: nsPresContext::SetFullZoom(float aZoom)
    1: {
35581:   if (!mShell || mFullZoom == aZoom) {
 8331:     return;
 8331:   }
 8940:   // Re-fetch the view manager's window dimensions in case there's a deferred
 8940:   // resize which hasn't affected our mVisibleArea yet
 8940:   nscoord oldWidthAppUnits, oldHeightAppUnits;
26050:   mShell->GetViewManager()->GetWindowDimensions(&oldWidthAppUnits, &oldHeightAppUnits);
 8940:   float oldWidthDevPixels = oldWidthAppUnits / float(mCurAppUnitsPerDevPixel);
 8940:   float oldHeightDevPixels = oldHeightAppUnits / float(mCurAppUnitsPerDevPixel);
 4359:   if (mDeviceContext->SetPixelScale(aZoom)) {
 4003:     mDeviceContext->FlushFontCache();
 4359:   }
10872: 
37970:   NS_ASSERTION(!mSupressResizeReflow, "two zooms happening at the same time? impossible!");
10872:   mSupressResizeReflow = PR_TRUE;
10872: 
 4359:   mFullZoom = aZoom;
26050:   mShell->GetViewManager()->
26050:     SetWindowDimensions(NSToCoordRound(oldWidthDevPixels * AppUnitsPerDevPixel()),
 8940:                         NSToCoordRound(oldHeightDevPixels * AppUnitsPerDevPixel()));
23163:   if (HasCachedStyleData()) {
16226:     MediaFeatureValuesChanged(PR_TRUE);
11409:     RebuildAllStyleData(NS_STYLE_HINT_REFLOW);
23163:   }
10872: 
10872:   mSupressResizeReflow = PR_FALSE;
10872: 
 5249:   mCurAppUnitsPerDevPixel = AppUnitsPerDevPixel();
 4359: }
    1: 
25231: void
25231: nsPresContext::SetImageLoaders(nsIFrame* aTargetFrame,
25231:                                ImageLoadType aType,
25231:                                nsImageLoader* aImageLoaders)
    1: {
37172:   NS_ASSERTION(mShell || !aImageLoaders,
37172:                "Shouldn't add new image loader after the shell is gone");
37172: 
25231:   nsRefPtr<nsImageLoader> oldLoaders;
25231:   mImageLoaders[aType].Get(aTargetFrame, getter_AddRefs(oldLoaders));
    1: 
25231:   if (aImageLoaders) {
25231:     mImageLoaders[aType].Put(aTargetFrame, aImageLoaders);
25231:   } else if (oldLoaders) {
25231:     mImageLoaders[aType].Remove(aTargetFrame);
    1:   }
    1: 
25231:   if (oldLoaders)
25231:     oldLoaders->Destroy();
21023: }
21023: 
25231: void
25231: nsPresContext::SetupBackgroundImageLoaders(nsIFrame* aFrame,
25231:                                      const nsStyleBackground* aStyleBackground)
21023: {
25276:   nsRefPtr<nsImageLoader> loaders;
25276:   NS_FOR_VISIBLE_BACKGROUND_LAYERS_BACK_TO_FRONT(i, aStyleBackground) {
31749:     if (aStyleBackground->mLayers[i].mImage.GetType() == eStyleImageType_Image) {
32424:       PRUint32 actions = nsImageLoader::ACTION_REDRAW_ON_DECODE;
30993:       imgIRequest *image = aStyleBackground->mLayers[i].mImage.GetImageData();
32424:       loaders = nsImageLoader::Create(aFrame, image, actions, loaders);
25276:     }
30993:   }
25276:   SetImageLoaders(aFrame, BACKGROUND_IMAGE, loaders);
21023: }
21023: 
25231: void
25231: nsPresContext::SetupBorderImageLoaders(nsIFrame* aFrame,
25231:                                        const nsStyleBorder* aStyleBorder)
21023: {
32424:   PRUint32 actions = nsImageLoader::ACTION_REDRAW_ON_LOAD;
32424:   if (aStyleBorder->ImageBorderDiffers())
32424:     actions |= nsImageLoader::ACTION_REFLOW_ON_LOAD;
25231:   nsRefPtr<nsImageLoader> loader =
25231:     nsImageLoader::Create(aFrame, aStyleBorder->GetBorderImage(),
32424:                           actions, nsnull);
25231:   SetImageLoaders(aFrame, BORDER_IMAGE, loader);
15992: }
    1: 
    1: void
    1: nsPresContext::StopImagesFor(nsIFrame* aTargetFrame)
    1: {
25231:   for (PRUint32 i = 0; i < IMAGE_LOAD_TYPE_COUNT; ++i)
25231:     SetImageLoaders(aTargetFrame, ImageLoadType(i), nsnull);
15992: }
    1: 
    1: void
    1: nsPresContext::SetContainer(nsISupports* aHandler)
    1: {
    1:   mContainer = do_GetWeakReference(aHandler);
42557:   InvalidateIsChromeCache();
    1:   if (mContainer) {
    1:     GetDocumentColorPreferences();
    1:   }
    1: }
    1: 
    1: already_AddRefed<nsISupports>
 8088: nsPresContext::GetContainerInternal() const
    1: {
    1:   nsISupports *result = nsnull;
    1:   if (mContainer)
    1:     CallQueryReferent(mContainer.get(), &result);
    1: 
    1:   return result;
    1: }
    1: 
    1: already_AddRefed<nsISupports>
 8088: nsPresContext::GetContainerExternal() const
    1: {
    1:   return GetContainerInternal();
    1: }
    1: 
    1: #ifdef IBMBIDI
    1: void
15376: nsPresContext::SetBidiEnabled() const
    1: {
    1:   if (mShell) {
    1:     nsIDocument *doc = mShell->GetDocument();
    1:     if (doc) {
15376:       doc->SetBidiEnabled();
    1:     }
    1:   }
    1: }
    1: 
    1: nsBidiPresUtils*
    1: nsPresContext::GetBidiUtils()
    1: {
    1:   if (!mBidiUtils)
    1:     mBidiUtils = new nsBidiPresUtils;
    1: 
    1:   return mBidiUtils;
    1: }
    1: 
    1: void
10073: nsPresContext::SetBidi(PRUint32 aSource, PRBool aForceRestyle)
    1: {
    1:   // Don't do all this stuff unless the options have changed.
    1:   if (aSource == GetBidi()) {
    1:     return;
    1:   }
    1: 
10073:   NS_ASSERTION(!(aForceRestyle && (GetBidi() == 0)), 
    1:                "ForceReflow on new prescontext");
    1: 
    1:   Document()->SetBidiOptions(aSource);
    1:   if (IBMBIDI_TEXTDIRECTION_RTL == GET_BIDI_OPTION_DIRECTION(aSource)
    1:       || IBMBIDI_NUMERAL_HINDI == GET_BIDI_OPTION_NUMERAL(aSource)) {
15376:     SetBidiEnabled();
    1:   }
    1:   if (IBMBIDI_TEXTTYPE_VISUAL == GET_BIDI_OPTION_TEXTTYPE(aSource)) {
    1:     SetVisualMode(PR_TRUE);
    1:   }
    1:   else if (IBMBIDI_TEXTTYPE_LOGICAL == GET_BIDI_OPTION_TEXTTYPE(aSource)) {
    1:     SetVisualMode(PR_FALSE);
    1:   }
    1:   else {
    1:     nsIDocument* doc = mShell->GetDocument();
    1:     if (doc) {
    1:       SetVisualMode(IsVisualCharset(doc->GetDocumentCharacterSet()));
    1:     }
    1:   }
10073:   if (aForceRestyle) {
11409:     RebuildAllStyleData(NS_STYLE_HINT_REFLOW);
    1:   }
    1: }
    1: 
    1: PRUint32
    1: nsPresContext::GetBidi() const
    1: {
    1:   return Document()->GetBidiOptions();
    1: }
42982: 
42982: PRUint32
42982: nsPresContext::GetBidiMemoryUsed()
42982: {
42982:   if (!mBidiUtils)
42982:     return 0;
42982: 
42982:   return mBidiUtils->EstimateMemoryUsed();
42982: }
42982: 
    1: #endif //IBMBIDI
    1: 
39698: PRBool
39698: nsPresContext::IsTopLevelWindowInactive()
39698: {
39698:   nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryReferent(mContainer));
39698:   if (!treeItem)
39698:     return PR_FALSE;
39698: 
39698:   nsCOMPtr<nsIDocShellTreeItem> rootItem;
39698:   treeItem->GetRootTreeItem(getter_AddRefs(rootItem));
39698:   nsCOMPtr<nsPIDOMWindow> domWindow(do_GetInterface(rootItem));
39698: 
39698:   return domWindow && !domWindow->IsActive();
39698: }
39698: 
    1: nsITheme*
    1: nsPresContext::GetTheme()
    1: {
25560:   if (!sNoTheme && !mTheme) {
    1:     mTheme = do_GetService("@mozilla.org/chrome/chrome-native-theme;1");
    1:     if (!mTheme)
25560:       sNoTheme = PR_TRUE;
    1:   }
    1: 
    1:   return mTheme;
    1: }
    1: 
    1: void
    1: nsPresContext::ThemeChanged()
    1: {
    1:   if (!mPendingThemeChanged) {
    1:     sLookAndFeelChanged = PR_TRUE;
    1:     sThemeChanged = PR_TRUE;
    1: 
    1:     nsCOMPtr<nsIRunnable> ev =
41361:       NS_NewRunnableMethod(this, &nsPresContext::ThemeChangedInternal);
    1:     if (NS_SUCCEEDED(NS_DispatchToCurrentThread(ev))) {
    1:       mPendingThemeChanged = PR_TRUE;
    1:     }
    1:   }    
    1: }
    1: 
    1: void
    1: nsPresContext::ThemeChangedInternal()
    1: {
    1:   mPendingThemeChanged = PR_FALSE;
    1:   
    1:   // Tell the theme that it changed, so it can flush any handles to stale theme
    1:   // data.
    1:   if (mTheme && sThemeChanged) {
    1:     mTheme->ThemeChanged();
    1:     sThemeChanged = PR_FALSE;
    1:   }
    1: 
    1:   // Clear all cached nsILookAndFeel colors.
    1:   if (mLookAndFeel && sLookAndFeelChanged) {
    1:     mLookAndFeel->LookAndFeelChanged();
    1:     sLookAndFeelChanged = PR_FALSE;
    1:   }
    1: 
16396:   // This will force the system metrics to be generated the next time they're used
16396:   nsCSSRuleProcessor::FreeSystemMetrics();
16396: 
33894:   // Changes to system metrics can change media queries on them.
33894:   MediaFeatureValuesChanged(PR_TRUE);
33894: 
11409:   // Changes in theme can change system colors (whose changes are
11409:   // properly reflected in computed style data), system fonts (whose
11409:   // changes are not), and -moz-appearance (whose changes likewise are
11409:   // not), so we need to reflow.
11409:   RebuildAllStyleData(NS_STYLE_HINT_REFLOW);
    1: }
    1: 
    1: void
    1: nsPresContext::SysColorChanged()
    1: {
    1:   if (!mPendingSysColorChanged) {
    1:     sLookAndFeelChanged = PR_TRUE;
    1:     nsCOMPtr<nsIRunnable> ev =
41361:       NS_NewRunnableMethod(this, &nsPresContext::SysColorChangedInternal);
    1:     if (NS_SUCCEEDED(NS_DispatchToCurrentThread(ev))) {
    1:       mPendingSysColorChanged = PR_TRUE;
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsPresContext::SysColorChangedInternal()
    1: {
    1:   mPendingSysColorChanged = PR_FALSE;
    1:   
    1:   if (mLookAndFeel && sLookAndFeelChanged) {
    1:      // Don't use the cached values for the system colors
    1:     mLookAndFeel->LookAndFeelChanged();
    1:     sLookAndFeelChanged = PR_FALSE;
    1:   }
    1:    
    1:   // Reset default background and foreground colors for the document since
    1:   // they may be using system colors
    1:   GetDocumentColorPreferences();
    1: 
11409:   // The system color values are computed to colors in the style data,
11409:   // so normal style data comparison is sufficient here.
11409:   RebuildAllStyleData(nsChangeHint(0));
10073: }
10073: 
10073: void
11409: nsPresContext::RebuildAllStyleData(nsChangeHint aExtraHint)
10073: {
10073:   if (!mShell) {
10073:     // We must have been torn down. Nothing to do here.
10073:     return;
10073:   }
21925: 
21925:   RebuildUserFontSet();
21925: 
11409:   mShell->FrameConstructor()->RebuildAllStyleData(aExtraHint);
10073: }
10073: 
10073: void
22339: nsPresContext::PostRebuildAllStyleDataEvent(nsChangeHint aExtraHint)
10073: {
10073:   if (!mShell) {
10073:     // We must have been torn down. Nothing to do here.
10073:     return;
10073:   }
22339:   mShell->FrameConstructor()->PostRebuildAllStyleDataEvent(aExtraHint);
    1: }
    1: 
    1: void
16226: nsPresContext::MediaFeatureValuesChanged(PRBool aCallerWillRebuildStyleData)
16226: {
16226:   mPendingMediaFeatureValuesChanged = PR_FALSE;
34947:   if (mShell &&
34947:       mShell->StyleSet()->MediumFeaturesChanged(this) &&
16226:       !aCallerWillRebuildStyleData) {
16226:     RebuildAllStyleData(nsChangeHint(0));
16226:   }
16226: }
16226: 
16226: void
16226: nsPresContext::PostMediaFeatureValuesChangedEvent()
16226: {
16226:   if (!mPendingMediaFeatureValuesChanged) {
16226:     nsCOMPtr<nsIRunnable> ev =
41361:       NS_NewRunnableMethod(this, &nsPresContext::HandleMediaFeatureValuesChangedEvent);
16226:     if (NS_SUCCEEDED(NS_DispatchToCurrentThread(ev))) {
16226:       mPendingMediaFeatureValuesChanged = PR_TRUE;
16226:     }
16226:   }
16226: }
16226: 
16226: void
16226: nsPresContext::HandleMediaFeatureValuesChangedEvent()
16226: {
16226:   // Null-check mShell in case the shell has been destroyed (and the
16226:   // event is the only thing holding the pres context alive).
16226:   if (mPendingMediaFeatureValuesChanged && mShell) {
16226:     MediaFeatureValuesChanged(PR_FALSE);
16226:   }
16226: }
16226: 
16226: void
    1: nsPresContext::SetPaginatedScrolling(PRBool aPaginated)
    1: {
    1:   if (mType == eContext_PrintPreview || mType == eContext_PageLayout)
    1:     mCanPaginatedScroll = aPaginated;
    1: }
    1: 
    1: void
    1: nsPresContext::SetPrintSettings(nsIPrintSettings *aPrintSettings)
    1: {
    1:   if (mMedium == nsGkAtoms::print)
    1:     mPrintSettings = aPrintSettings;
    1: }
    1: 
    1: PRBool
29018: nsPresContext::EnsureVisible()
    1: {
    1:   nsCOMPtr<nsIDocShell> docShell(do_QueryReferent(mContainer));
    1:   if (docShell) {
    1:     nsCOMPtr<nsIContentViewer> cv;
    1:     docShell->GetContentViewer(getter_AddRefs(cv));
    1:     // Make sure this is the content viewer we belong with
    1:     nsCOMPtr<nsIDocumentViewer> docV(do_QueryInterface(cv));
    1:     if (docV) {
40039:       nsRefPtr<nsPresContext> currentPresContext;
    1:       docV->GetPresContext(getter_AddRefs(currentPresContext));
    1:       if (currentPresContext == this) {
29018:         // OK, this is us.  We want to call Show() on the content viewer.
    1:         cv->Show();
    1:         return PR_TRUE;
    1:       }
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: #ifdef MOZ_REFLOW_PERF
    1: void
    1: nsPresContext::CountReflows(const char * aName, nsIFrame * aFrame)
    1: {
    1:   if (mShell) {
    1:     mShell->CountReflows(aName, aFrame);
    1:   }
    1: }
    1: #endif
 1540: 
40699: PRBool
42557: nsPresContext::IsChromeSlow() const
 1540: {
 1540:   PRBool isChrome = PR_FALSE;
 1540:   nsCOMPtr<nsISupports> container = GetContainer();
 1540:   if (container) {
 1540:     nsresult result;
 1540:     nsCOMPtr<nsIDocShellTreeItem> docShell(do_QueryInterface(container, &result));
 1540:     if (NS_SUCCEEDED(result) && docShell) {
 1540:       PRInt32 docShellType;
 1540:       result = docShell->GetItemType(&docShellType);
 1540:       if (NS_SUCCEEDED(result)) {
 1540:         isChrome = nsIDocShellTreeItem::typeChrome == docShellType;
 1540:       }
 1540:     }
 1540:   }
40739:   mIsChrome = isChrome;
40739:   mIsChromeIsCached = PR_TRUE;
40739:   return mIsChrome;
40739: }
40739: 
40739: void
40739: nsPresContext::InvalidateIsChromeCacheExternal()
40739: {
40739:   InvalidateIsChromeCacheInternal();
 1540: }
 1540: 
 6734: /* virtual */ PRBool
42557: nsPresContext::HasAuthorSpecifiedRules(nsIFrame *aFrame, PRUint32 ruleTypeMask) const
 6734: {
23377:   return
23377:     nsRuleNode::HasAuthorSpecifiedRules(aFrame->GetStyleContext(),
29282:                                         ruleTypeMask,
29282:                                         UseDocumentColors());
 6734: }
19380: 
21924: static void
21983: InsertFontFaceRule(nsCSSFontFaceRule *aRule, gfxUserFontSet* aFontSet,
21983:                    PRUint8 aSheetType)
21924: {
47887:   NS_ABORT_IF_FALSE(aRule->GetType() == nsICSSRule::FONT_FACE_RULE,
21924:                     "InsertFontFaceRule passed a non-fontface CSS rule");
21924: 
21924:   // aRule->List();
21924: 
21924:   nsAutoString fontfamily;
21924:   nsCSSValue val;
21924: 
21924:   PRUint32 unit;
21924:   PRUint32 weight = NS_STYLE_FONT_WEIGHT_NORMAL;
21924:   PRUint32 stretch = NS_STYLE_FONT_STRETCH_NORMAL;
21924:   PRUint32 italicStyle = FONT_STYLE_NORMAL;
47359:   nsString featureSettings, languageOverride;
21924: 
21924:   // set up family name
21924:   aRule->GetDesc(eCSSFontDesc_Family, val);
21924:   unit = val.GetUnit();
21924:   if (unit == eCSSUnit_String) {
21924:     val.GetStringValue(fontfamily);
21924:   } else {
22353:     NS_ASSERTION(unit == eCSSUnit_Null,
22353:                  "@font-face family name has unexpected unit");
22353:     // If there is no family name, this rule cannot contribute a
22353:     // usable font, so there is no point in processing it further.
21924:     return;
19962:   }
19962: 
21924:   // set up weight
21924:   aRule->GetDesc(eCSSFontDesc_Weight, val);
21924:   unit = val.GetUnit();
22353:   if (unit == eCSSUnit_Integer || unit == eCSSUnit_Enumerated) {
22353:     weight = val.GetIntValue();
22353:   } else if (unit == eCSSUnit_Normal) {
21924:     weight = NS_STYLE_FONT_WEIGHT_NORMAL;
21924:   } else {
22353:     NS_ASSERTION(unit == eCSSUnit_Null,
22353:                  "@font-face weight has unexpected unit");
21924:   }
21924: 
21924:   // set up stretch
21924:   aRule->GetDesc(eCSSFontDesc_Stretch, val);
21924:   unit = val.GetUnit();
22353:   if (unit == eCSSUnit_Enumerated) {
22353:     stretch = val.GetIntValue();
22353:   } else if (unit == eCSSUnit_Normal) {
21924:     stretch = NS_STYLE_FONT_STRETCH_NORMAL;
21924:   } else {
22353:     NS_ASSERTION(unit == eCSSUnit_Null,
22353:                  "@font-face stretch has unexpected unit");
21924:   }
21924: 
21924:   // set up font style
21924:   aRule->GetDesc(eCSSFontDesc_Style, val);
22353:   unit = val.GetUnit();
22353:   if (unit == eCSSUnit_Enumerated) {
22353:     italicStyle = val.GetIntValue();
22353:   } else if (unit == eCSSUnit_Normal) {
21924:     italicStyle = FONT_STYLE_NORMAL;
21924:   } else {
22353:     NS_ASSERTION(unit == eCSSUnit_Null,
22353:                  "@font-face style has unexpected unit");
21924:   }
21924: 
47359:   // set up font features
47359:   aRule->GetDesc(eCSSFontDesc_FontFeatureSettings, val);
47359:   unit = val.GetUnit();
47359:   if (unit == eCSSUnit_Normal) {
47359:     // empty feature string
47359:   } else if (unit == eCSSUnit_String) {
47359:     val.GetStringValue(featureSettings);
47359:   } else {
47359:     NS_ASSERTION(unit == eCSSUnit_Null,
47359:                  "@font-face font-feature-settings has unexpected unit");
47359:   }
47359: 
47359:   // set up font language override
47359:   aRule->GetDesc(eCSSFontDesc_FontLanguageOverride, val);
47359:   unit = val.GetUnit();
47359:   if (unit == eCSSUnit_Normal) {
47359:     // empty feature string
47359:   } else if (unit == eCSSUnit_String) {
47359:     val.GetStringValue(languageOverride);
47359:   } else {
47359:     NS_ASSERTION(unit == eCSSUnit_Null,
47359:                  "@font-face font-language-override has unexpected unit");
47359:   }
47359: 
21924:   // set up src array
21924:   nsTArray<gfxFontFaceSrc> srcArray;
21924: 
21924:   aRule->GetDesc(eCSSFontDesc_Src, val);
21924:   unit = val.GetUnit();
21924:   if (unit == eCSSUnit_Array) {
21924:     nsCSSValue::Array *srcArr = val.GetArrayValue();
46243:     size_t numSrc = srcArr->Count();
21924:     
46243:     for (size_t i = 0; i < numSrc; i++) {
21924:       val = srcArr->Item(i);
21924:       unit = val.GetUnit();
21924:       gfxFontFaceSrc *face = srcArray.AppendElements(1);
21924:       if (!face)
21924:         return;
21924:             
21924:       switch (unit) {
21924:        
21924:       case eCSSUnit_Local_Font:
21924:         val.GetStringValue(face->mLocalName);
21924:         face->mIsLocal = PR_TRUE;
21924:         face->mURI = nsnull;
21924:         face->mFormatFlags = 0;
21924:         break;
21924:       case eCSSUnit_URL:
21924:         face->mIsLocal = PR_FALSE;
21924:         face->mURI = val.GetURLValue();
21924:         NS_ASSERTION(face->mURI, "null url in @font-face rule");
21924:         face->mReferrer = val.GetURLStructValue()->mReferrer;
21983:         face->mOriginPrincipal = val.GetURLStructValue()->mOriginPrincipal;
21983:         NS_ASSERTION(face->mOriginPrincipal, "null origin principal in @font-face rule");
21983:         
21983:         // agent and user stylesheets are treated slightly differently,
21983:         // the same-site origin check and access control headers are
21983:         // enforced against the sheet principal rather than the document
21983:         // principal to allow user stylesheets to include @font-face rules
21983:         face->mUseOriginPrincipal = (aSheetType == nsStyleSet::eUserSheet ||
21983:                                      aSheetType == nsStyleSet::eAgentSheet);
21983:                                      
21924:         face->mLocalName.Truncate();
21924:         face->mFormatFlags = 0;
21924:         while (i + 1 < numSrc && (val = srcArr->Item(i+1), 
21924:                  val.GetUnit() == eCSSUnit_Font_Format)) {
21924:           nsDependentString valueString(val.GetStringBufferValue());
32809:           if (valueString.LowerCaseEqualsASCII("woff")) {
32809:             face->mFormatFlags |= gfxUserFontSet::FLAG_FORMAT_WOFF; 
32809:           } else if (valueString.LowerCaseEqualsASCII("opentype")) {
21924:             face->mFormatFlags |= gfxUserFontSet::FLAG_FORMAT_OPENTYPE; 
21924:           } else if (valueString.LowerCaseEqualsASCII("truetype")) {
21924:             face->mFormatFlags |= gfxUserFontSet::FLAG_FORMAT_TRUETYPE; 
21924:           } else if (valueString.LowerCaseEqualsASCII("truetype-aat")) {
21924:             face->mFormatFlags |= gfxUserFontSet::FLAG_FORMAT_TRUETYPE_AAT; 
21924:           } else if (valueString.LowerCaseEqualsASCII("embedded-opentype")) {
21924:             face->mFormatFlags |= gfxUserFontSet::FLAG_FORMAT_EOT;   
21924:           } else if (valueString.LowerCaseEqualsASCII("svg")) {
21924:             face->mFormatFlags |= gfxUserFontSet::FLAG_FORMAT_SVG;   
23576:           } else {
23576:             // unknown format specified, mark to distinguish from the 
23576:             // case where no format hints are specified
23576:             face->mFormatFlags |= gfxUserFontSet::FLAG_FORMAT_UNKNOWN;
21924:           }
21924:           i++;
21924:         }
21924:         break;
21924:       default:
21924:         NS_ASSERTION(unit == eCSSUnit_Local_Font || unit == eCSSUnit_URL,
21924:                      "strange unit type in font-face src array");
21924:         break;
21924:       }
21924:      }
22353:   } else {
22353:     NS_ASSERTION(unit == eCSSUnit_Null, "@font-face src has unexpected unit");
21924:   }
21924:   
21924:   if (!fontfamily.IsEmpty() && srcArray.Length() > 0) {
47359:     aFontSet->AddFontFace(fontfamily, srcArray, weight, stretch, italicStyle,
47359:                           featureSettings, languageOverride);
21924:   }
21924: }
21924: 
21924: gfxUserFontSet*
22335: nsPresContext::GetUserFontSetInternal()
19962: {
21925:   // We want to initialize the user font set lazily the first time the
21925:   // user asks for it, rather than building it too early and forcing
21925:   // rule cascade creation.  Thus we try to enforce the invariant that
21925:   // we *never* build the user font set until the first call to
21925:   // GetUserFontSet.  However, once it's been requested, we can't wait
21925:   // for somebody to call GetUserFontSet in order to rebuild it (see
21925:   // comments below in RebuildUserFontSet for why).
24321: #ifdef DEBUG
24321:   PRBool userFontSetGottenBefore = mGetUserFontSetCalled;
24321: #endif
24321:   // Set mGetUserFontSetCalled up front, so that FlushUserFontSet will actually
24321:   // flush.
24321:   mGetUserFontSetCalled = PR_TRUE;
21924:   if (mUserFontSetDirty) {
21925:     // If this assertion fails, and there have actually been changes to
21925:     // @font-face rules, then we will call StyleChangeReflow in
22033:     // FlushUserFontSet.  If we're in the middle of reflow,
22033:     // that's a bad thing to do, and the caller was responsible for
22033:     // flushing first.  If we're not (e.g., in frame construction), it's
22033:     // ok.
40048:     NS_ASSERTION(!userFontSetGottenBefore || !mShell->IsReflowLocked(),
21925:                  "FlushUserFontSet should have been called first");
21925:     FlushUserFontSet();
21925:   }
21924: 
21925:   return mUserFontSet;
21925: }
21925: 
22335: gfxUserFontSet*
22335: nsPresContext::GetUserFontSetExternal()
22335: {
22335:   return GetUserFontSetInternal();
22335: }
22335: 
21925: void
21925: nsPresContext::FlushUserFontSet()
21925: {
21925:   if (!mShell)
21925:     return; // we've been torn down
21925: 
24321:   if (!mGetUserFontSetCalled) {
24321:     return; // No one cares about this font set yet, but we want to be careful
24321:             // to not unset our mUserFontSetDirty bit, so when someone really
24321:             // does we'll create it.
24321:   }
24321: 
21925:   if (mUserFontSetDirty) {
21924:     if (gfxPlatform::GetPlatform()->DownloadableFontsEnabled()) {
21925:       nsRefPtr<gfxUserFontSet> oldUserFontSet = mUserFontSet;
21925: 
21983:       nsTArray<nsFontFaceRuleContainer> rules;
21924:       if (!mShell->StyleSet()->AppendFontFaceRules(this, rules))
21925:         return;
21925: 
21925:       PRBool differ;
21925:       if (rules.Length() == mFontFaceRules.Length()) {
21925:         differ = PR_FALSE;
21925:         for (PRUint32 i = 0, i_end = rules.Length(); i < i_end; ++i) {
21983:           if (rules[i].mRule != mFontFaceRules[i].mRule ||
21983:               rules[i].mSheetType != mFontFaceRules[i].mSheetType) {
21925:             differ = PR_TRUE;
21925:             break;
21925:           }
21925:         }
21925:       } else {
21925:         differ = PR_TRUE;
21925:       }
21925: 
21925:       // Only rebuild things if the set of @font-face rules is different.
21925:       if (differ) {
23932:         if (mUserFontSet) {
23932:           mUserFontSet->Destroy();
23932:           NS_RELEASE(mUserFontSet);
23932:         }
21924: 
21924:         if (rules.Length() > 0) {
23932:           nsUserFontSet *fs = new nsUserFontSet(this);
22722:           if (!fs)
21925:             return;
21924:           mUserFontSet = fs;
21924:           NS_ADDREF(mUserFontSet);
21924: 
21924:           for (PRUint32 i = 0, i_end = rules.Length(); i < i_end; ++i) {
21983:             InsertFontFaceRule(rules[i].mRule, fs, rules[i].mSheetType);
21924:           }
21924:         }
21924:       }
21924: 
21925: #ifdef DEBUG
21925:       PRBool success =
21925: #endif
21925:         rules.SwapElements(mFontFaceRules);
21925:       NS_ASSERTION(success, "should never fail given both are heap arrays");
21925: 
21925:       if (mGetUserFontSetCalled && oldUserFontSet != mUserFontSet) {
21925:         // If we've changed, created, or destroyed a user font set, we
21925:         // need to trigger a style change reflow.
21925:         // We need to enqueue a style change reflow (for later) to
22507:         // reflect that we're dropping @font-face rules.  (However,
22507:         // without a reflow, nothing will happen to start any downloads
22507:         // that are needed.)
22507:         UserFontSetUpdated();
21925:       }
21925:     }
21925: 
21924:     mUserFontSetDirty = PR_FALSE;
21924:   }
21925: }
21925: 
21925: void
21925: nsPresContext::RebuildUserFontSet()
21925: {
21925:   if (!mGetUserFontSetCalled) {
21925:     // We want to lazily build the user font set the first time it's
21925:     // requested (so we don't force creation of rule cascades too
21925:     // early), so don't do anything now.
21925:     return;
21925:   }
21925: 
21925:   mUserFontSetDirty = PR_TRUE;
21925: 
21925:   // Somebody has already asked for the user font set, so we need to
21925:   // post an event to rebuild it.  Setting the user font set to be dirty
21925:   // and lazily rebuilding it isn't sufficient, since it is only the act
21925:   // of rebuilding it that will trigger the style change reflow that
21925:   // calls GetUserFontSet.  (This reflow causes rebuilding of text runs,
21925:   // which starts font loads, whose completion causes another style
21925:   // change reflow).
21925:   if (!mPostedFlushUserFontSet) {
21925:     nsCOMPtr<nsIRunnable> ev =
41361:       NS_NewRunnableMethod(this, &nsPresContext::HandleRebuildUserFontSet);
21925:     if (NS_SUCCEEDED(NS_DispatchToCurrentThread(ev))) {
21925:       mPostedFlushUserFontSet = PR_TRUE;
21925:     }
21925:   }    
19962: }
19962: 
19380: void
22507: nsPresContext::UserFontSetUpdated()
22507: {
22507:   if (!mShell)
22507:     return;
22507: 
22507:   // Changes to the set of available fonts can cause updates to layout by:
22507:   //
22507:   //   1. Changing the font used for text, which changes anything that
22507:   //      depends on text measurement, including line breaking and
22507:   //      intrinsic widths, and any other parts of layout that depend on
22507:   //      font metrics.  This requires a style change reflow to update.
22507:   //
22507:   //   2. Changing the value of the 'ex' and 'ch' units in style data,
22507:   //      which also depend on font metrics.  Updating this information
22507:   //      requires rebuilding the rule tree from the top, avoiding the
22507:   //      reuse of cached data even when no style rules have changed.
22507: 
22507:   PostRebuildAllStyleDataEvent(NS_STYLE_HINT_REFLOW);
22507: }
22507: 
36786: PRBool
36786: nsPresContext::EnsureSafeToHandOutCSSRules()
36786: {
36786:   nsCSSStyleSheet::EnsureUniqueInnerResult res =
36786:     mShell->StyleSet()->EnsureUniqueInnerOnCSSSheets();
36786:   if (res == nsCSSStyleSheet::eUniqueInner_AlreadyUnique) {
36786:     // Nothing to do.
36786:     return PR_TRUE;
36786:   }
36786:   if (res == nsCSSStyleSheet::eUniqueInner_CloneFailed) {
36786:     return PR_FALSE;
36786:   }
36786: 
36786:   NS_ABORT_IF_FALSE(res == nsCSSStyleSheet::eUniqueInner_ClonedInner,
36786:                     "unexpected result");
36786:   RebuildAllStyleData(nsChangeHint(0));
36786:   return PR_TRUE;
36786: }
36786: 
22507: void
19380: nsPresContext::FireDOMPaintEvent()
19380: {
29465:   nsPIDOMWindow* ourWindow = mDocument->GetWindow();
20515:   if (!ourWindow)
19380:     return;
20515: 
29465:   nsCOMPtr<nsIDOMEventTarget> dispatchTarget = do_QueryInterface(ourWindow);
29465:   nsCOMPtr<nsIDOMEventTarget> eventTarget = dispatchTarget;
32894:   if (!IsChrome()) {
32894:     PRBool isCrossDocOnly = PR_TRUE;
32894:     for (PRUint32 i = 0; i < mInvalidateRequests.mRequests.Length(); ++i) {
32894:       if (!(mInvalidateRequests.mRequests[i].mFlags & nsIFrame::INVALIDATE_CROSS_DOC)) {
32894:         isCrossDocOnly = PR_FALSE;
32894:       }
32894:     }
32894:     if (isCrossDocOnly) {
19380:       // Don't tell the window about this event, it should not know that
19380:       // something happened in a subdocument. Tell only the chrome event handler.
19380:       // (Events sent to the window get propagated to the chrome event handler
19380:       // automatically.)
29465:       dispatchTarget = do_QueryInterface(ourWindow->GetChromeEventHandler());
29465:       if (!dispatchTarget) {
20618:         return;
20618:       }
19380:     }
32894:   }
19380:   // Events sent to the window get propagated to the chrome event handler
19380:   // automatically.
29465:   nsCOMPtr<nsIDOMEvent> event;
32894:   // This will empty our list in case dispatching the event causes more damage
32894:   // (hopefully it won't, or we're likely to get an infinite loop! At least
32894:   // it won't be blocking app execution though).
29465:   NS_NewDOMNotifyPaintEvent(getter_AddRefs(event), this, nsnull,
29465:                             NS_AFTERPAINT,
32894:                             &mInvalidateRequests);
29465:   nsCOMPtr<nsIPrivateDOMEvent> pEvent = do_QueryInterface(event);
29465:   if (!pEvent) return;
19380: 
19380:   // Even if we're not telling the window about the event (so eventTarget is
19380:   // the chrome event handler, not the window), the window is still
19380:   // logically the event target.
29465:   pEvent->SetTarget(eventTarget);
29465:   pEvent->SetTrusted(PR_TRUE);
29465:   nsEventDispatcher::DispatchDOMEvent(dispatchTarget, nsnull, event, this, nsnull);
19380: }
19380: 
32894: static PRBool
32894: MayHavePaintEventListener(nsPIDOMWindow* aInnerWindow)
20515: {
20515:   if (!aInnerWindow)
20515:     return PR_FALSE;
20515:   if (aInnerWindow->HasPaintEventListeners())
20515:     return PR_TRUE;
20515: 
43680:   nsPIDOMEventTarget* parentTarget = aInnerWindow->GetParentTarget();
43680:   if (!parentTarget)
20515:     return PR_FALSE;
20515: 
42412:   nsIEventListenerManager* manager = nsnull;
43680:   if ((manager = parentTarget->GetListenerManager(PR_FALSE)) &&
42412:       manager->MayHavePaintEventListener()) {
42412:     return PR_TRUE;
42412:   }
43680: 
43680:   nsCOMPtr<nsINode> node;
43680:   if (parentTarget != aInnerWindow->GetChromeEventHandler()) {
43680:     nsCOMPtr<nsIInProcessContentFrameMessageManager> mm =
43680:       do_QueryInterface(parentTarget);
43680:     if (mm) {
42412:       node = mm->GetOwnerContent();
42412:     }
43680:   }
42412: 
42412:   if (!node) {
43680:     node = do_QueryInterface(parentTarget);
42412:   }
20515:   if (node)
20515:     return MayHavePaintEventListener(node->GetOwnerDoc()->GetInnerWindow());
20515: 
43680:   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(parentTarget);
20515:   if (window)
20515:     return MayHavePaintEventListener(window);
20515: 
46960:   nsCOMPtr<nsPIWindowRoot> root = do_QueryInterface(parentTarget);
46960:   nsPIDOMEventTarget* tabChildGlobal;
46960:   return root &&
46960:          (tabChildGlobal = root->GetParentTarget()) &&
46960:          (manager = tabChildGlobal->GetListenerManager(PR_FALSE)) &&
46960:          manager->MayHavePaintEventListener();
20515: }
20515: 
32894: PRBool
32894: nsPresContext::MayHavePaintEventListener()
32894: {
32894:   return ::MayHavePaintEventListener(mDocument->GetInnerWindow());
32894: }
32894: 
19380: void
32894: nsPresContext::NotifyInvalidation(const nsRect& aRect, PRUint32 aFlags)
19380: {
20515:   // If there is no paint event listener, then we don't need to fire
20515:   // the asynchronous event. We don't even need to record invalidation.
20515:   // MayHavePaintEventListener is pretty cheap and we could make it
20515:   // even cheaper by providing a more efficient
20515:   // nsPIDOMWindow::GetListenerManager.
32894:   if (aRect.IsEmpty() || !MayHavePaintEventListener())
19380:     return;
19380: 
23350:   if (!IsDOMPaintEventPending()) {
19380:     // No event is pending. Dispatch one now.
19380:     nsCOMPtr<nsIRunnable> ev =
41361:       NS_NewRunnableMethod(this, &nsPresContext::FireDOMPaintEvent);
19380:     NS_DispatchToCurrentThread(ev);
19380:   }
19380: 
32894:   nsInvalidateRequestList::Request* request =
32894:     mInvalidateRequests.mRequests.AppendElement();
32894:   if (!request)
32894:     return;
32894: 
32894:   request->mRect = aRect;
32894:   request->mFlags = aFlags;
19380: }
23163: 
37083: void
37083: nsPresContext::NotifyInvalidateRegion(const nsRegion& aRegion,
37083:                                       nsPoint aOffset, PRUint32 aFlags)
37083: {
37083:   const nsRect* r;
37083:   for (nsRegionRectIterator iter(aRegion); (r = iter.Next());) {
37083:     NotifyInvalidation(*r + aOffset, aFlags);
37083:   }
37083: }
37083: 
37083: void
37083: nsPresContext::NotifyInvalidateForScrolling(const nsRegion& aBlitRegion,
37083:                                             const nsRegion& aInvalidateRegion)
37083: {
37083:   nsPresContext* pc = this;
37083:   PRUint32 crossDocFlags = 0;
37083:   nsIFrame* rootFrame = FrameManager()->GetRootFrame();
37083:   nsPoint offset(0,0);
37083:   while (pc) {
37083:     if (pc->MayHavePaintEventListener()) {
37083:       pc->NotifyInvalidateRegion(aBlitRegion, offset,
37083:                                  nsIFrame::INVALIDATE_REASON_SCROLL_BLIT | crossDocFlags);
37083:       pc->NotifyInvalidateRegion(aInvalidateRegion, offset,
37083:                                  nsIFrame::INVALIDATE_REASON_SCROLL_REPAINT | crossDocFlags);
37083:     }
37083:     crossDocFlags = nsIFrame::INVALIDATE_CROSS_DOC;
37083: 
37083:     nsIFrame* rootParentFrame = nsLayoutUtils::GetCrossDocParentFrame(rootFrame);
37083:     if (!rootParentFrame)
37083:       break;
37083: 
37083:     pc = rootParentFrame->PresContext();
37083:     nsIFrame* nextRootFrame = pc->PresShell()->FrameManager()->GetRootFrame();
37083:     offset += rootFrame->GetOffsetTo(nextRootFrame);
37083:     rootFrame = nextRootFrame;
37083:   }
37083: }
37083: 
23163: PRBool
23163: nsPresContext::HasCachedStyleData()
23163: {
23163:   return mShell && mShell->StyleSet()->HasCachedStyleData();
23163: }
27993: 
27993: static PRBool sGotInterruptEnv = PR_FALSE;
27993: enum InterruptMode {
27993:   ModeRandom,
27993:   ModeCounter,
27993:   ModeEvent
27993: };
33393: // Controlled by the GECKO_REFLOW_INTERRUPT_MODE env var; allowed values are
33393: // "random" (except on Windows) or "counter".  If neither is used, the mode is
33393: // ModeEvent.
27993: static InterruptMode sInterruptMode = ModeEvent;
33393: // Used for the "random" mode.  Controlled by the GECKO_REFLOW_INTERRUPT_SEED
33393: // env var.
33393: static PRUint32 sInterruptSeed = 1;
33393: // Used for the "counter" mode.  This is the number of unskipped interrupt
33393: // checks that have to happen before we interrupt.  Controlled by the
33393: // GECKO_REFLOW_INTERRUPT_FREQUENCY env var.
33393: static PRUint32 sInterruptMaxCounter = 10;
33393: // Used for the "counter" mode.  This counts up to sInterruptMaxCounter and is
33393: // then reset to 0.
27993: static PRUint32 sInterruptCounter;
33393: // Number of interrupt checks to skip before really trying to interrupt.
33393: // Controlled by the GECKO_REFLOW_INTERRUPT_CHECKS_TO_SKIP env var.
33393: static PRUint32 sInterruptChecksToSkip = 200;
33393: // Number of milliseconds that a reflow should be allowed to run for before we
33393: // actually allow interruption.  Controlled by the
33393: // GECKO_REFLOW_MIN_NOINTERRUPT_DURATION env var.
33393: static TimeDuration sInterruptTimeout = TimeDuration::FromMilliseconds(100);
27993: 
27993: static void GetInterruptEnv()
27993: {
27993:   char *ev = PR_GetEnv("GECKO_REFLOW_INTERRUPT_MODE");
27993:   if (ev) {
27993: #ifndef XP_WIN
27993:     if (PL_strcasecmp(ev, "random") == 0) {
27993:       ev = PR_GetEnv("GECKO_REFLOW_INTERRUPT_SEED");
27993:       if (ev) {
27993:         sInterruptSeed = atoi(ev);
27993:       }
27993:       srandom(sInterruptSeed);
27993:       sInterruptMode = ModeRandom;
27993:     } else
27993: #endif
27993:       if (PL_strcasecmp(ev, "counter") == 0) {
27993:       ev = PR_GetEnv("GECKO_REFLOW_INTERRUPT_FREQUENCY");
27993:       if (ev) {
27993:         sInterruptMaxCounter = atoi(ev);
27993:       }
27993:       sInterruptCounter = 0;
27993:       sInterruptMode = ModeCounter;
27993:     }
27993:   }
27993:   ev = PR_GetEnv("GECKO_REFLOW_INTERRUPT_CHECKS_TO_SKIP");
27993:   if (ev) {
27993:     sInterruptChecksToSkip = atoi(ev);
27993:   }
33393: 
33393:   ev = PR_GetEnv("GECKO_REFLOW_MIN_NOINTERRUPT_DURATION");
33393:   if (ev) {
33393:     sInterruptTimeout = TimeDuration::FromMilliseconds(atoi(ev));
33393:   }
27993: }
27993: 
27993: PRBool
27993: nsPresContext::HavePendingInputEvent()
27993: {
27993:   switch (sInterruptMode) {
27993: #ifndef XP_WIN
27993:     case ModeRandom:
27993:       return (random() & 1);
27993: #endif
27993:     case ModeCounter:
27993:       if (sInterruptCounter < sInterruptMaxCounter) {
27993:         ++sInterruptCounter;
27993:         return PR_FALSE;
27993:       }
27993:       sInterruptCounter = 0;
27993:       return PR_TRUE;
27993:     default:
27993:     case ModeEvent: {
27993:       nsIFrame* f = PresShell()->GetRootFrame();
27993:       if (f) {
47148:         nsIWidget* w = f->GetNearestWidget();
27993:         if (w) {
27993:           return w->HasPendingInputEvent();
27993:         }
27993:       }
27993:       return PR_FALSE;
27993:     }
27993:   }
27993: }
27993: 
27993: void
27993: nsPresContext::ReflowStarted(PRBool aInterruptible)
27993: {
33393: #ifdef NOISY_INTERRUPTIBLE_REFLOW
33393:   if (!aInterruptible) {
33393:     printf("STARTING NONINTERRUPTIBLE REFLOW\n");
33393:   }
33393: #endif
27993:   // We don't support interrupting in paginated contexts, since page
27993:   // sequences only handle initial reflow
27993:   mInterruptsEnabled = aInterruptible && !IsPaginated();
27993: 
27993:   // Don't set mHasPendingInterrupt based on HavePendingInputEvent() here.  If
27993:   // we ever change that, then we need to update the code in
27993:   // PresShell::DoReflow to only add the just-reflown root to dirty roots if
27993:   // it's actually dirty.  Otherwise we can end up adding a root that has no
27993:   // interruptible descendants, just because we detected an interrupt at reflow
27993:   // start.
27993:   mHasPendingInterrupt = PR_FALSE;
27993: 
27993:   mInterruptChecksToSkip = sInterruptChecksToSkip;
33393: 
33393:   if (mInterruptsEnabled) {
33393:     mReflowStartTime = TimeStamp::Now();
33393:   }
27993: }
27993: 
27993: PRBool
27993: nsPresContext::CheckForInterrupt(nsIFrame* aFrame)
27993: {
27993:   if (mHasPendingInterrupt) {
27993:     mShell->FrameNeedsToContinueReflow(aFrame);
27993:     return PR_TRUE;
27993:   }
27993: 
27993:   if (!sGotInterruptEnv) {
27993:     sGotInterruptEnv = PR_TRUE;
27993:     GetInterruptEnv();
27993:   }
27993: 
27993:   if (!mInterruptsEnabled) {
27993:     return PR_FALSE;
27993:   }
27993: 
27993:   if (mInterruptChecksToSkip > 0) {
27993:     --mInterruptChecksToSkip;
27993:     return PR_FALSE;
27993:   }
27993:   mInterruptChecksToSkip = sInterruptChecksToSkip;
27993: 
33393:   // Don't interrupt if it's been less than sInterruptTimeout since we started
33393:   // the reflow.
33393:   mHasPendingInterrupt =
33393:     TimeStamp::Now() - mReflowStartTime > sInterruptTimeout &&
33393:     HavePendingInputEvent() &&
33393:     !IsChrome();
27993:   if (mHasPendingInterrupt) {
27993: #ifdef NOISY_INTERRUPTIBLE_REFLOW
27993:     printf("*** DETECTED pending interrupt (time=%lld)\n", PR_Now());
27993: #endif /* NOISY_INTERRUPTIBLE_REFLOW */
27993:     mShell->FrameNeedsToContinueReflow(aFrame);
27993:   }
27993:   return mHasPendingInterrupt;
27993: }
30514: 
52488: PRBool
52488: nsPresContext::IsRootContentDocument()
52488: {
52488:   // We are a root content document if: we are not chrome, we are a
52488:   // subdocument, and our parent is chrome.
52488:   if (IsChrome()) {
52488:     return PR_FALSE;
52488:   }
52488:   // We may not have a root frame, so use views.
52488:   nsIViewManager* vm = PresShell()->GetViewManager();
52488:   nsIView* view = nsnull;
52488:   if (NS_FAILED(vm->GetRootView(view)) || !view) {
52488:     return PR_FALSE;
52488:   }
52488:   view = view->GetParent(); // anonymous inner view
52488:   if (!view) {
52488:     return PR_FALSE;
52488:   }
52488:   view = view->GetParent(); // subdocumentframe's view
52488:   if (!view) {
52488:     return PR_FALSE;
52488:   }
52488: 
52488:   nsIFrame* f = static_cast<nsIFrame*>(view->GetClientData());
52488:   return (f && f->PresContext()->IsChrome());
52488: }
52488: 
30514: nsRootPresContext::nsRootPresContext(nsIDocument* aDocument,
30514:                                      nsPresContextType aType)
47756:   : nsPresContext(aDocument, aType),
47756:     mUpdatePluginGeometryForFrame(nsnull),
54261:     mDOMGeneration(0),
47756:     mNeedsToUpdatePluginGeometry(PR_FALSE)
30514: {
30522:   mRegisteredPlugins.Init();
30514: }
30522: 
30522: nsRootPresContext::~nsRootPresContext()
30522: {
30522:   NS_ASSERTION(mRegisteredPlugins.Count() == 0,
30522:                "All plugins should have been unregistered");
30522: }
30522: 
30522: void
30522: nsRootPresContext::RegisterPluginForGeometryUpdates(nsObjectFrame* aPlugin)
30522: {
30522:   mRegisteredPlugins.PutEntry(aPlugin);
30522: }
30522: 
30522: void
30522: nsRootPresContext::UnregisterPluginForGeometryUpdates(nsObjectFrame* aPlugin)
30522: {
30522:   mRegisteredPlugins.RemoveEntry(aPlugin);
30522: }
30522: 
30522: struct PluginGeometryClosure {
30522:   nsIFrame* mRootFrame;
47902:   PRInt32   mRootAPD;
30522:   nsIFrame* mChangedSubtree;
30522:   nsRect    mChangedRect;
30522:   nsTHashtable<nsPtrHashKey<nsObjectFrame> > mAffectedPlugins;
30522:   nsRect    mAffectedPluginBounds;
30522:   nsTArray<nsIWidget::Configuration>* mOutputConfigurations;
30522: };
30522: static PLDHashOperator
30522: PluginBoundsEnumerator(nsPtrHashKey<nsObjectFrame>* aEntry, void* userArg)
30522: {
30522:   PluginGeometryClosure* closure = static_cast<PluginGeometryClosure*>(userArg);
30522:   nsObjectFrame* f = aEntry->GetKey();
30522:   nsRect fBounds = f->GetContentRect() +
47902:       f->GetParent()->GetOffsetToCrossDoc(closure->mRootFrame);
47902:   PRInt32 APD = f->PresContext()->AppUnitsPerDevPixel();
47902:   fBounds = fBounds.ConvertAppUnitsRoundOut(APD, closure->mRootAPD);
30522:   // We're identifying the plugins that may have been affected by changes
30522:   // to the frame subtree rooted at aChangedRoot. Any plugin that overlaps
30522:   // the overflow area of aChangedRoot could have its clip region affected
30522:   // because it might be covered (or uncovered) by changes to the subtree.
30522:   // Plugins in the subtree might have changed position and/or size, and
30522:   // they might not be in aChangedRoot's overflow area (because they're
30522:   // being clipped by an ancestor in the subtree).
30522:   if (fBounds.Intersects(closure->mChangedRect) ||
30522:       nsLayoutUtils::IsAncestorFrameCrossDoc(closure->mChangedSubtree, f)) {
30522:     closure->mAffectedPluginBounds.UnionRect(
30522:         closure->mAffectedPluginBounds, fBounds);
30522:     closure->mAffectedPlugins.PutEntry(f);
30522:   }
30522:   return PL_DHASH_NEXT;
30522: }
30522: 
30522: static PLDHashOperator
30522: PluginHideEnumerator(nsPtrHashKey<nsObjectFrame>* aEntry, void* userArg)
30522: {
30522:   PluginGeometryClosure* closure = static_cast<PluginGeometryClosure*>(userArg);
30522:   nsObjectFrame* f = aEntry->GetKey();
30522:   f->GetEmptyClipConfiguration(closure->mOutputConfigurations);
30522:   return PL_DHASH_NEXT;
30522: }
30522: 
30522: static void
30522: RecoverPluginGeometry(nsDisplayListBuilder* aBuilder,
30522:     nsDisplayList* aList, PluginGeometryClosure* aClosure)
30522: {
30522:   for (nsDisplayItem* i = aList->GetBottom(); i; i = i->GetAbove()) {
30522:     switch (i->GetType()) {
30522:     case nsDisplayItem::TYPE_PLUGIN: {
30522:       nsDisplayPlugin* displayPlugin = static_cast<nsDisplayPlugin*>(i);
30522:       nsObjectFrame* f = static_cast<nsObjectFrame*>(
30522:           displayPlugin->GetUnderlyingFrame());
30522:       // Ignore plugins which aren't supposed to be affected by this
30522:       // operation --- their bounds will not have been included in the
30522:       // display list computations so the visible region computed for them
30522:       // would be incorrect
30522:       nsPtrHashKey<nsObjectFrame>* entry =
30522:         aClosure->mAffectedPlugins.GetEntry(f);
30522:       if (entry) {
30522:         displayPlugin->GetWidgetConfiguration(aBuilder,
30522:                                               aClosure->mOutputConfigurations);
30522:         // we've dealt with this plugin now
30522:         aClosure->mAffectedPlugins.RawRemoveEntry(entry);
30522:       }
30522:       break;
30522:     }
30522:     default: {
30522:       nsDisplayList* sublist = i->GetList();
30522:       if (sublist) {
30522:         RecoverPluginGeometry(aBuilder, sublist, aClosure);
30522:       }
30522:       break;
30522:     }
30522:     }
30522:   }
30522: }
30522: 
30522: #ifdef DEBUG
30522: #include <stdio.h>
30522: 
30522: static PRBool gDumpPluginList = PR_FALSE;
30522: #endif
30522: 
30522: void
30522: nsRootPresContext::GetPluginGeometryUpdates(nsIFrame* aChangedSubtree,
30522:                                             nsTArray<nsIWidget::Configuration>* aConfigurations)
30522: {
30522:   if (mRegisteredPlugins.Count() == 0)
30522:     return;
30522: 
30522:   PluginGeometryClosure closure;
30522:   closure.mRootFrame = mShell->FrameManager()->GetRootFrame();
47902:   closure.mRootAPD = closure.mRootFrame->PresContext()->AppUnitsPerDevPixel();
30522:   closure.mChangedSubtree = aChangedSubtree;
30522:   closure.mChangedRect = aChangedSubtree->GetOverflowRect() +
47902:       aChangedSubtree->GetOffsetToCrossDoc(closure.mRootFrame);
47902:   PRInt32 subtreeAPD = aChangedSubtree->PresContext()->AppUnitsPerDevPixel();
47902:   closure.mChangedRect =
47902:     closure.mChangedRect.ConvertAppUnitsRoundOut(subtreeAPD, closure.mRootAPD);
30522:   closure.mAffectedPlugins.Init();
30522:   closure.mOutputConfigurations = aConfigurations;
30522:   // Fill in closure.mAffectedPlugins and closure.mAffectedPluginBounds
30522:   mRegisteredPlugins.EnumerateEntries(PluginBoundsEnumerator, &closure);
30522: 
30522:   nsRect bounds;
30522:   if (bounds.IntersectRect(closure.mAffectedPluginBounds,
30522:                            closure.mRootFrame->GetRect())) {
30522:     nsDisplayListBuilder builder(closure.mRootFrame, PR_FALSE, PR_FALSE);
30522:     builder.SetAccurateVisibleRegions();
30522:     nsDisplayList list;
30522: 
30522:     builder.EnterPresShell(closure.mRootFrame, bounds);
30522:     closure.mRootFrame->BuildDisplayListForStackingContext(
30522:         &builder, bounds, &list);
30522:     builder.LeavePresShell(closure.mRootFrame, bounds);
30522: 
30522: #ifdef DEBUG
30522:     if (gDumpPluginList) {
30522:       fprintf(stderr, "Plugins --- before optimization (bounds %d,%d,%d,%d):\n",
30522:           bounds.x, bounds.y, bounds.width, bounds.height);
31709:       nsFrame::PrintDisplayList(&builder, list);
30522:     }
30522: #endif
30522: 
30522:     nsRegion visibleRegion(bounds);
51633:     list.ComputeVisibilityForRoot(&builder, &visibleRegion);
30522: 
30522: #ifdef DEBUG
30522:     if (gDumpPluginList) {
30522:       fprintf(stderr, "Plugins --- after optimization:\n");
31709:       nsFrame::PrintDisplayList(&builder, list);
30522:     }
30522: #endif
30522: 
30522:     RecoverPluginGeometry(&builder, &list, &closure);
30522:     list.DeleteAll();
30522:   }
30522: 
30522:   // Plugins that we didn't find in the display list are not visible
30522:   closure.mAffectedPlugins.EnumerateEntries(PluginHideEnumerator, &closure);
30522: }
30522: 
47757: static PRBool
47757: HasOverlap(const nsIntPoint& aOffset1, const nsTArray<nsIntRect>& aClipRects1,
47757:            const nsIntPoint& aOffset2, const nsTArray<nsIntRect>& aClipRects2)
47757: {
47757:   nsIntPoint offsetDelta = aOffset1 - aOffset2;
47757:   for (PRUint32 i = 0; i < aClipRects1.Length(); ++i) {
47757:     for (PRUint32 j = 0; j < aClipRects2.Length(); ++j) {
47757:       if ((aClipRects1[i] + offsetDelta).Intersects(aClipRects2[j]))
47757:         return PR_TRUE;
47757:     }
47757:   }
47757:   return PR_FALSE;
47757: }
47757: 
47757: /**
47757:  * Given a list of plugin windows to move to new locations, sort the list
47757:  * so that for each window move, the window moves to a location that
47757:  * does not intersect other windows. This minimizes flicker and repainting.
47757:  * It's not always possible to do this perfectly, since in general
47757:  * we might have cycles. But we do our best.
47757:  * We need to take into account that windows are clipped to particular
47757:  * regions and the clip regions change as the windows are moved.
47757:  */
47757: static void
47757: SortConfigurations(nsTArray<nsIWidget::Configuration>* aConfigurations)
47757: {
47757:   if (aConfigurations->Length() > 10) {
47757:     // Give up, we don't want to get bogged down here
47757:     return;
47757:   }
47757: 
47757:   nsTArray<nsIWidget::Configuration> pluginsToMove;
47757:   pluginsToMove.SwapElements(*aConfigurations);
47757: 
47757:   // Our algorithm is quite naive. At each step we try to identify
47757:   // a window that can be moved to its new location that won't overlap
47757:   // any other windows at the new location. If there is no such
47757:   // window, we just move the last window in the list anyway.
47757:   while (!pluginsToMove.IsEmpty()) {
47757:     // Find a window whose destination does not overlap any other window
47757:     PRUint32 i;
47757:     for (i = 0; i + 1 < pluginsToMove.Length(); ++i) {
47757:       nsIWidget::Configuration* config = &pluginsToMove[i];
47757:       PRBool foundOverlap = PR_FALSE;
47757:       for (PRUint32 j = 0; j < pluginsToMove.Length(); ++j) {
47757:         if (i == j)
47757:           continue;
47757:         nsIntRect bounds;
47757:         pluginsToMove[j].mChild->GetBounds(bounds);
47757:         nsAutoTArray<nsIntRect,1> clipRects;
47757:         pluginsToMove[j].mChild->GetWindowClipRegion(&clipRects);
47757:         if (HasOverlap(bounds.TopLeft(), clipRects,
47757:                        config->mBounds.TopLeft(),
47757:                        config->mClipRegion)) {
47757:           foundOverlap = PR_TRUE;
47757:           break;
47757:         }
47757:       }
47757:       if (!foundOverlap)
47757:         break;
47757:     }
47757:     // Note that we always move the last plugin in pluginsToMove, if we
47757:     // can't find any other plugin to move
47757:     aConfigurations->AppendElement(pluginsToMove[i]);
47757:     pluginsToMove.RemoveElementAt(i);
47757:   }
47757: }
47757: 
30522: void
47756: nsRootPresContext::UpdatePluginGeometry()
30522: {
47756:   if (!mNeedsToUpdatePluginGeometry)
47756:     return;
47756:   mNeedsToUpdatePluginGeometry = PR_FALSE;
47756: 
47756:   nsIFrame* f = mUpdatePluginGeometryForFrame;
47756:   if (f) {
47756:     mUpdatePluginGeometryForFrame->PresContext()->
47756:       SetContainsUpdatePluginGeometryFrame(PR_FALSE);
47756:     mUpdatePluginGeometryForFrame = nsnull;
47756:   } else {
47756:     f = FrameManager()->GetRootFrame();
47756:   }
47756: 
30522:   nsTArray<nsIWidget::Configuration> configurations;
47756:   GetPluginGeometryUpdates(f, &configurations);
30522:   if (configurations.IsEmpty())
30522:     return;
47757:   SortConfigurations(&configurations);
47148:   nsIWidget* widget = FrameManager()->GetRootFrame()->GetNearestWidget();
33373:   NS_ASSERTION(widget, "Plugins must have a parent window");
30522:   widget->ConfigureChildren(configurations);
30524:   DidApplyPluginGeometryUpdates();
30522: }
30524: 
47756: void
47756: nsRootPresContext::ForcePluginGeometryUpdate()
47756: {
47756:   // Force synchronous paint
47756:   nsIPresShell* shell = GetPresShell();
47756:   if (!shell)
47756:     return;
47756:   nsIFrame* rootFrame = shell->GetRootFrame();
47756:   if (!rootFrame)
47756:     return;
47756:   nsCOMPtr<nsIWidget> widget = rootFrame->GetNearestWidget();
47756:   if (!widget)
47756:     return;
47756:   // Force synchronous paint of a single pixel, just to force plugin
47756:   // updates to be flushed. Doing plugin updates during paint is the best
47756:   // way to ensure that plugin updates are in sync with our content.
47756:   widget->Invalidate(nsIntRect(0,0,1,1), PR_TRUE);
47756: 
47756:   // Update plugin geometry just in case that invalidate didn't work
47756:   // (e.g. if none of the widget is visible, it might not have processed
47756:   // a paint event). Normally this won't need to do anything.
47756:   UpdatePluginGeometry();
47756: }
47756: 
47756: void
47756: nsRootPresContext::RequestUpdatePluginGeometry(nsIFrame* aFrame)
47756: {
47756:   if (mRegisteredPlugins.Count() == 0)
47756:     return;
47756: 
47756:   if (!mNeedsToUpdatePluginGeometry) {
47960:     mNeedsToUpdatePluginGeometry = PR_TRUE;
47960: 
47756:     // Dispatch a Gecko event to ensure plugin geometry gets updated
47756:     nsCOMPtr<nsIRunnable> event =
47756:       NS_NewRunnableMethod(this, &nsRootPresContext::ForcePluginGeometryUpdate);
47756:     NS_DispatchToMainThread(event);
47756: 
47756:     mUpdatePluginGeometryForFrame = aFrame;
47756:     mUpdatePluginGeometryForFrame->PresContext()->
47756:       SetContainsUpdatePluginGeometryFrame(PR_TRUE);
47756:   } else {
47960:     if (!mUpdatePluginGeometryForFrame ||
47960:         aFrame == mUpdatePluginGeometryForFrame)
47960:       return;
47756:     mUpdatePluginGeometryForFrame->PresContext()->
47756:       SetContainsUpdatePluginGeometryFrame(PR_FALSE);
47756:     mUpdatePluginGeometryForFrame = nsnull;
47756:   }
47756: }
47756: 
30524: static PLDHashOperator
30524: PluginDidSetGeometryEnumerator(nsPtrHashKey<nsObjectFrame>* aEntry, void* userArg)
30524: {
30524:   nsObjectFrame* f = aEntry->GetKey();
30524:   f->DidSetWidgetGeometry();
30524:   return PL_DHASH_NEXT;
30524: }
30524: 
30524: void
30524: nsRootPresContext::DidApplyPluginGeometryUpdates()
30524: {
30524:   mRegisteredPlugins.EnumerateEntries(PluginDidSetGeometryEnumerator, nsnull);
30524: }
47756: 
47756: void
47756: nsRootPresContext::RootForgetUpdatePluginGeometryFrame(nsIFrame* aFrame)
47756: {
47756:   if (aFrame == mUpdatePluginGeometryForFrame) {
47756:     mUpdatePluginGeometryForFrame->PresContext()->
47756:       SetContainsUpdatePluginGeometryFrame(PR_FALSE);
47756:     mUpdatePluginGeometryForFrame = nsnull;
47756:   }
47756: }
