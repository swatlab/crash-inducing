36949: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
36949:  * ***** BEGIN LICENSE BLOCK *****
36949:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
36949:  *
36949:  * The contents of this file are subject to the Mozilla Public License Version
36949:  * 1.1 (the "License"); you may not use this file except in compliance with
36949:  * the License. You may obtain a copy of the License at
36949:  * http://www.mozilla.org/MPL/
36949:  *
36949:  * Software distributed under the License is distributed on an "AS IS" basis,
36949:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
36949:  * for the specific language governing rights and limitations under the
36949:  * License.
36949:  *
36949:  * The Original Code is Mozilla Corporation code.
36949:  *
36949:  * The Initial Developer of the Original Code is Mozilla Corporation.
36949:  * Portions created by the Initial Developer are Copyright (C) 2009
36949:  * the Initial Developer. All Rights Reserved.
36949:  *
36949:  * Contributor(s):
36949:  *   Stuart Parmenter <stuart@mozilla.com>
36949:  *   Masayuki Nakano <masayuki@d-toybox.com>
36949:  *   Mats Palmgren <mats.palmgren@bredband.net>
36949:  *   John Daggett <jdaggett@mozilla.com>
36949:  *   Jonathan Kew <jfkthame@gmail.com>
36949:  *
36949:  * Alternatively, the contents of this file may be used under the terms of
36949:  * either the GNU General Public License Version 2 or later (the "GPL"), or
36949:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
36949:  * in which case the provisions of the GPL or the LGPL are applicable instead
36949:  * of those above. If you wish to allow use of your version of this file only
36949:  * under the terms of either the GPL or the LGPL, and not to allow others to
36949:  * use your version of this file under the terms of the MPL, indicate your
36949:  * decision by deleting the provisions above and replace them with the notice
36949:  * and other provisions required by the GPL or the LGPL. If you do not delete
36949:  * the provisions above, a recipient may use your version of this file under
36949:  * the terms of any one of the MPL, the GPL or the LGPL.
36949:  *
36949:  * ***** END LICENSE BLOCK ***** */
36949: 
36949: #include "gfxGDIFontList.h"
36949: #include "gfxWindowsPlatform.h"
36949: #include "gfxUserFontSet.h"
36949: #include "gfxFontUtils.h"
36949: #include "gfxWindowsFonts.h"
36949: 
36949: #include "nsIPref.h"  // for pref changes callback notification
36949: #include "nsServiceManagerUtils.h"
36949: #include "nsTArray.h"
36949: #include "nsUnicharUtils.h"
36949: 
36949: #include "nsDirectoryServiceUtils.h"
36949: #include "nsDirectoryServiceDefs.h"
36949: #include "nsAppDirectoryServiceDefs.h"
36949: #include "nsISimpleEnumerator.h"
36949: #include "nsIWindowsRegKey.h"
36949: 
36949: #define ROUND(x) floor((x) + 0.5)
36949: 
36949: #ifdef PR_LOGGING
36949: static PRLogModuleInfo *gFontInfoLog = PR_NewLogModule("fontInfoLog");
36949: #endif /* PR_LOGGING */
36949: 
36949: #define LOG(args) PR_LOG(gFontInfoLog, PR_LOG_DEBUG, args)
36949: #define LOG_ENABLED() PR_LOG_TEST(gFontInfoLog, PR_LOG_DEBUG)
36949: 
36949: // font info loader constants
36949: static const PRUint32 kDelayBeforeLoadingFonts = 8 * 1000; // 8secs
36949: static const PRUint32 kIntervalBetweenLoadingFonts = 150; // 150ms
36949: 
36949: static __inline void
36949: BuildKeyNameFromFontName(nsAString &aName)
36949: {
36949:     if (aName.Length() >= LF_FACESIZE)
36949:         aName.Truncate(LF_FACESIZE - 1);
36949:     ToLowerCase(aName);
36949: }
36949: 
36949: // Implementation of gfxPlatformFontList for Win32 GDI,
36949: // using GDI font enumeration APIs to get the list of fonts
36949: 
36949: // from t2embapi.h, included in Platform SDK 6.1 but not 6.0
36949: 
36949: #ifndef __t2embapi__
36949: 
36949: #define TTLOAD_PRIVATE                  0x00000001
36949: #define LICENSE_PREVIEWPRINT            0x0004
36949: #define E_NONE                          0x0000L
36949: 
36949: typedef unsigned long( WINAPIV *READEMBEDPROC ) ( void*, void*, const unsigned long );
36949: 
36949: typedef struct
36949: {
36949:     unsigned short usStructSize;    // size in bytes of structure client should set to sizeof(TTLOADINFO)
36949:     unsigned short usRefStrSize;    // size in wide characters of pusRefStr including NULL terminator
36949:     unsigned short *pusRefStr;      // reference or actual string.
36949: }TTLOADINFO;
36949: 
36949: LONG WINAPI TTLoadEmbeddedFont
36949: (
36949:     HANDLE*  phFontReference,           // on completion, contains handle to identify embedded font installed
36949:                                         // on system
36949:     ULONG    ulFlags,                   // flags specifying the request 
36949:     ULONG*   pulPrivStatus,             // on completion, contains the embedding status
36949:     ULONG    ulPrivs,                   // allows for the reduction of licensing privileges
36949:     ULONG*   pulStatus,                 // on completion, may contain status flags for request 
36949:     READEMBEDPROC lpfnReadFromStream,   // callback function for doc/disk reads
36949:     LPVOID   lpvReadStream,             // the input stream tokin
36949:     LPWSTR   szWinFamilyName,           // the new 16 bit windows family name can be NULL
36949:     LPSTR    szMacFamilyName,           // the new 8 bit mac family name can be NULL
36949:     TTLOADINFO* pTTLoadInfo             // optional security
36949: );
36949: 
36949: #endif // __t2embapi__
36949: 
36949: typedef LONG( WINAPI *TTLoadEmbeddedFontProc ) (HANDLE* phFontReference, ULONG ulFlags, ULONG* pulPrivStatus, ULONG ulPrivs, ULONG* pulStatus, 
36949:                                              READEMBEDPROC lpfnReadFromStream, LPVOID lpvReadStream, LPWSTR szWinFamilyName, 
36949:                                              LPSTR szMacFamilyName, TTLOADINFO* pTTLoadInfo);
36949: 
36949: typedef LONG( WINAPI *TTDeleteEmbeddedFontProc ) (HANDLE hFontReference, ULONG ulFlags, ULONG* pulStatus);
36949: 
36949: 
36949: static TTLoadEmbeddedFontProc TTLoadEmbeddedFontPtr = nsnull;
36949: static TTDeleteEmbeddedFontProc TTDeleteEmbeddedFontPtr = nsnull;
36949: 
36949: class WinUserFontData : public gfxUserFontData {
36949: public:
36949:     WinUserFontData(HANDLE aFontRef, PRBool aIsCFF)
36949:         : mFontRef(aFontRef), mIsCFF(aIsCFF)
36949:     { }
36949: 
36949:     virtual ~WinUserFontData()
36949:     {
36949:         if (mIsCFF) {
36949:             RemoveFontMemResourceEx(mFontRef);
36949:         } else {
36949:             ULONG pulStatus;
36949:             TTDeleteEmbeddedFontPtr(mFontRef, 0, &pulStatus);
36949:         }
36949:     }
36949:     
36949:     HANDLE mFontRef;
36949:     PRPackedBool mIsCFF;
36949: };
36949: 
36949: BYTE 
36949: FontTypeToOutPrecision(PRUint8 fontType)
36949: {
36949:     BYTE ret;
36949:     switch (fontType) {
36949:     case GFX_FONT_TYPE_TT_OPENTYPE:
36949:     case GFX_FONT_TYPE_TRUETYPE:
36949:         ret = OUT_TT_ONLY_PRECIS;
36949:         break;
36949:     case GFX_FONT_TYPE_PS_OPENTYPE:
36949:         ret = OUT_PS_ONLY_PRECIS;
36949:         break;
36949:     case GFX_FONT_TYPE_TYPE1:
36949:         ret = OUT_OUTLINE_PRECIS;
36949:         break;
36949:     case GFX_FONT_TYPE_RASTER:
36949:         ret = OUT_RASTER_PRECIS;
36949:         break;
36949:     case GFX_FONT_TYPE_DEVICE:
36949:         ret = OUT_DEVICE_PRECIS;
36949:         break;
36949:     default:
36949:         ret = OUT_DEFAULT_PRECIS;
36949:     }
36949:     return ret;
36949: }
36949: 
36949: /***************************************************************
36949:  *
36949:  * GDIFontEntry
36949:  *
36949:  */
36949: 
36949: GDIFontEntry::GDIFontEntry(const nsAString& aFaceName, gfxWindowsFontType aFontType,
36949:                                    PRBool aItalic, PRUint16 aWeight, gfxUserFontData *aUserFontData) : 
36949:     gfxFontEntry(aFaceName), mFontType(aFontType),
36949:     mForceGDI(PR_FALSE), mUnknownCMAP(PR_FALSE),
36949:     mUnicodeFont(PR_FALSE),
36949:     mCharset(), mUnicodeRanges()
36949: {
36949:     mUserFontData = aUserFontData;
36949:     mItalic = aItalic;
36949:     mWeight = aWeight;
36949:     if (IsType1())
36949:         mForceGDI = PR_TRUE;
36949:     mIsUserFont = aUserFontData != nsnull;
36949:     InitLogFont(aFaceName, aFontType);
36949: }
36949: 
36949: nsresult
36949: GDIFontEntry::ReadCMAP()
36949: {
36949:     // attempt this once, if errors occur leave a blank cmap
36949:     if (mCmapInitialized)
36949:         return NS_OK;
36949:     mCmapInitialized = PR_TRUE;
36949: 
36949:     const PRUint32 kCmapTag = TRUETYPE_TAG('c','m','a','p');
36949:     nsAutoTArray<PRUint8,16384> buffer;
36949:     if (GetFontTable(kCmapTag, buffer) != NS_OK)
36949:         return NS_ERROR_FAILURE;
36949:     PRUint8 *cmap = buffer.Elements();
36949: 
36949:     PRPackedBool  unicodeFont = PR_FALSE, symbolFont = PR_FALSE;
36949:     nsresult rv = gfxFontUtils::ReadCMAP(cmap, buffer.Length(),
36949:                                          mCharacterMap, unicodeFont, symbolFont);
36949:     mUnicodeFont = unicodeFont;
36949:     mSymbolFont = symbolFont;
36949: 
36949:     PR_LOG(gFontInfoLog, PR_LOG_DEBUG, ("(fontinit-cmap) psname: %s, size: %d\n", 
36949:                                         NS_ConvertUTF16toUTF8(mName).get(), mCharacterMap.GetSize()));
36949:     return rv;
36949: }
36949: 
36949: nsresult
36949: GDIFontEntry::GetFontTable(PRUint32 aTableTag, nsTArray<PRUint8>& aBuffer)
36949: {
36949:     AutoDC dc;
36949:     AutoSelectFont font(dc.GetDC(), &mLogFont);
36949:     if (font.IsValid()) {
36949:         PRInt32 tableSize = ::GetFontData(dc.GetDC(), NS_SWAP32(aTableTag), 0, NULL, NULL);
36949:         if (tableSize != GDI_ERROR) {
36949:             if (aBuffer.SetLength(tableSize)) {
36949:                 ::GetFontData(dc.GetDC(), NS_SWAP32(aTableTag), 0, aBuffer.Elements(), tableSize);
36949:                 return NS_OK;
36949:             }
36949:             return NS_ERROR_OUT_OF_MEMORY;
36949:         }
36949:     }
36949:     return NS_ERROR_FAILURE;
36949: }
36949: 
36949: void
36949: GDIFontEntry::FillLogFont(LOGFONTW *aLogFont, PRBool aItalic,
36949:                               PRUint16 aWeight, gfxFloat aSize)
36949: {
36949:     memcpy(aLogFont, &mLogFont, sizeof(LOGFONTW));
36949: 
36949:     aLogFont->lfHeight = (LONG)-ROUND(aSize);
36949: 
36949:     if (aLogFont->lfHeight == 0)
36949:         aLogFont->lfHeight = -1;
36949: 
36949:     // always force lfItalic if we want it.  Font selection code will
36949:     // do its best to give us an italic font entry, but if no face exists
36949:     // it may give us a regular one based on weight.  Windows should
36949:     // do fake italic for us in that case.
36949:     aLogFont->lfItalic         = aItalic;
36949:     aLogFont->lfWeight         = aWeight;
36949: }
36949: 
36949: PRBool 
36949: GDIFontEntry::TestCharacterMap(PRUint32 aCh)
36949: {
36949:     if (ReadCMAP() != NS_OK) {
36949:         // Type1 fonts aren't necessarily Unicode but
36949:         // this is the best guess we can make here
36949:         mUnicodeFont = IsType1();
36949: 
36949:         // For fonts where we failed to read the character map,
36949:         // we can take a slow path to look up glyphs character by character
36949:         mUnknownCMAP = PR_TRUE;
36949:     }
36949: 
36949:     if (mUnknownCMAP) {
36949:         if (aCh > 0xFFFF)
36949:             return PR_FALSE;
36949: 
36949:         // previous code was using the group style
36949:         gfxFontStyle fakeStyle;  
36949:         if (mItalic)
36949:             fakeStyle.style = FONT_STYLE_ITALIC;
36949:         fakeStyle.weight = mWeight * 100;
36949: 
36949:         nsRefPtr<gfxWindowsFont> font =
36949:             gfxWindowsFont::GetOrMakeFont(this, &fakeStyle);
36949:         if (!font->IsValid())
36949:             return PR_FALSE;
36949: 
36949:         HDC dc = GetDC((HWND)nsnull);
36949:         SetGraphicsMode(dc, GM_ADVANCED);
36949:         HFONT hfont = font->GetHFONT();
36949:         HFONT oldFont = (HFONT)SelectObject(dc, hfont);
36949: 
36949:         PRUnichar str[1] = { (PRUnichar)aCh };
36949:         WORD glyph[1];
36949: 
36949:         PRBool hasGlyph = PR_FALSE;
36949:         if (IsType1()) {
36949:             // Type1 fonts and uniscribe APIs don't get along.  ScriptGetCMap will return E_HANDLE
36949:             DWORD ret = GetGlyphIndicesW(dc, str, 1, glyph, GGI_MARK_NONEXISTING_GLYPHS);
36949:             if (ret != GDI_ERROR && glyph[0] != 0xFFFF)
36949:                 hasGlyph = PR_TRUE;
36949:         } else {
36949:             // ScriptGetCMap works better than GetGlyphIndicesW for things like bitmap/vector fonts
36949:             HRESULT rv = ScriptGetCMap(dc, font->ScriptCache(), str, 1, 0, glyph);
36949:             if (rv == S_OK)
36949:                 hasGlyph = PR_TRUE;
36949:         }
36949: 
36949:         SelectObject(dc, oldFont);
36949:         ReleaseDC(NULL, dc);
36949: 
36949:         if (hasGlyph) {
36949:             mCharacterMap.set(aCh);
36949:             return PR_TRUE;
36949:         }
36949:     } else {
36949:         // font had a cmap so simply check that
36949:         return mCharacterMap.test(aCh);
36949:     }
36949: 
36949:     return PR_FALSE;
36949: }
36949: 
36949: void
36949: GDIFontEntry::InitLogFont(const nsAString& aName,
36949:                               gfxWindowsFontType aFontType)
36949: {
36949: #define CLIP_TURNOFF_FONTASSOCIATION 0x40
36949:     
36949:     mLogFont.lfHeight = -1;
36949: 
36949:     // Fill in logFont structure
36949:     mLogFont.lfWidth          = 0;
36949:     mLogFont.lfEscapement     = 0;
36949:     mLogFont.lfOrientation    = 0;
36949:     mLogFont.lfUnderline      = FALSE;
36949:     mLogFont.lfStrikeOut      = FALSE;
36949:     mLogFont.lfCharSet        = DEFAULT_CHARSET;
36949:     mLogFont.lfOutPrecision   = FontTypeToOutPrecision(aFontType);
36949:     mLogFont.lfClipPrecision  = CLIP_TURNOFF_FONTASSOCIATION;
36949:     mLogFont.lfQuality        = DEFAULT_QUALITY;
36949:     mLogFont.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
36949:     // always force lfItalic if we want it.  Font selection code will
36949:     // do its best to give us an italic font entry, but if no face exists
36949:     // it may give us a regular one based on weight.  Windows should
36949:     // do fake italic for us in that case.
36949:     mLogFont.lfItalic         = mItalic;
36949:     mLogFont.lfWeight         = mWeight;
36949: 
36949:     int len = PR_MIN(aName.Length(), LF_FACESIZE - 1);
36949:     memcpy(&mLogFont.lfFaceName, nsPromiseFlatString(aName).get(), len * 2);
36949:     mLogFont.lfFaceName[len] = '\0';
36949: }
36949: 
36949: GDIFontEntry* 
36949: GDIFontEntry::CreateFontEntry(const nsAString& aName, gfxWindowsFontType aFontType, 
36949:                                   PRBool aItalic, PRUint16 aWeight, 
36949:                                   gfxUserFontData* aUserFontData)
36949: {
36949:     // jtdfix - need to set charset, unicode ranges, pitch/family
36949: 
36949:     GDIFontEntry *fe = new GDIFontEntry(aName, aFontType, aItalic, aWeight,
36949:                                         aUserFontData);
36949: 
36949:     // ReadCMAP may change the values of mUnicodeFont and mSymbolFont
36949:     if (NS_FAILED(fe->ReadCMAP())) {
36949:         // Type1 fonts aren't necessarily Unicode but
36949:         // this is the best guess we can make here
36949:         if (fe->IsType1())
36949:             fe->mUnicodeFont = PR_TRUE;
36949:         else
36949:             fe->mUnicodeFont = PR_FALSE;
36949: 
36949:         // For fonts where we failed to read the character map,
36949:         // we can take a slow path to look up glyphs character by character
36949:         fe->mUnknownCMAP = PR_TRUE;
36949:     } 
36949: 
36949:     return fe;
36949: }
36949: 
36949: /***************************************************************
36949:  *
36949:  * GDIFontFamily
36949:  *
36949:  */
36949: 
36949: int CALLBACK
36949: GDIFontFamily::FamilyAddStylesProc(const ENUMLOGFONTEXW *lpelfe,
36949:                                         const NEWTEXTMETRICEXW *nmetrics,
36949:                                         DWORD fontType, LPARAM data)
36949: {
36949:     const NEWTEXTMETRICW& metrics = nmetrics->ntmTm;
36949:     LOGFONTW logFont = lpelfe->elfLogFont;
36949:     GDIFontFamily *ff = reinterpret_cast<GDIFontFamily*>(data);
36949: 
36949:     // Some fonts claim to support things > 900, but we don't so clamp the sizes
36949:     logFont.lfWeight = PR_MAX(PR_MIN(logFont.lfWeight, 900), 100);
36949: 
36949:     gfxWindowsFontType feType = GDIFontEntry::DetermineFontType(metrics, fontType);
36949: 
36949:     GDIFontEntry *fe = nsnull;
36949:     for (PRUint32 i = 0; i < ff->mAvailableFonts.Length(); ++i) {
36949:         fe = static_cast<GDIFontEntry*>(ff->mAvailableFonts[i].get());
36949:         if (feType > fe->mFontType) {
36949:             // if the new type is better than the old one, remove the old entries
36949:             ff->mAvailableFonts.RemoveElementAt(i);
36949:             --i;
36949:         } else if (feType < fe->mFontType) {
36949:             // otherwise if the new type is worse, skip it
36949:             return 1;
36949:         }
36949:     }
36949: 
36949:     for (PRUint32 i = 0; i < ff->mAvailableFonts.Length(); ++i) {
36949:         fe = static_cast<GDIFontEntry*>(ff->mAvailableFonts[i].get());
36949:         // check if we already know about this face
36949:         if (fe->mWeight == logFont.lfWeight &&
36949:             fe->mItalic == (logFont.lfItalic == 0xFF)) {
36949:             // update the charset bit here since this could be different
36949:             fe->mCharset[metrics.tmCharSet] = 1;
36949:             return 1; 
36949:         }
36949:     }
36949: 
36949:     fe = GDIFontEntry::CreateFontEntry(ff->mName, feType, (logFont.lfItalic == 0xFF),
36949:                                        (PRUint16) (logFont.lfWeight), nsnull);
36949:     if (!fe)
36949:         return 1;
36949: 
36949:     ff->mAvailableFonts.AppendElement(fe);
36967:     fe->SetFamily(ff);
36949: 
36949:     // mark the charset bit
36949:     fe->mCharset[metrics.tmCharSet] = 1;
36949: 
36949:     fe->mWindowsFamily = logFont.lfPitchAndFamily & 0xF0;
36949:     fe->mWindowsPitch = logFont.lfPitchAndFamily & 0x0F;
36949: 
36949:     if (nmetrics->ntmFontSig.fsUsb[0] != 0x00000000 &&
36949:         nmetrics->ntmFontSig.fsUsb[1] != 0x00000000 &&
36949:         nmetrics->ntmFontSig.fsUsb[2] != 0x00000000 &&
36949:         nmetrics->ntmFontSig.fsUsb[3] != 0x00000000) {
36949: 
36949:         // set the unicode ranges
36949:         PRUint32 x = 0;
36949:         for (PRUint32 i = 0; i < 4; ++i) {
36949:             DWORD range = nmetrics->ntmFontSig.fsUsb[i];
36949:             for (PRUint32 k = 0; k < 32; ++k) {
36949:                 fe->mUnicodeRanges[x++] = (range & (1 << k)) != 0;
36949:             }
36949:         }
36949:     }
36949: 
36949: #ifdef PR_LOGGING
36949:     if (LOG_ENABLED()) {
36949:         LOG(("(fontinit) added (%s) to family (%s)"
36949:              " with style: %s weight: %d stretch: %d",
36949:              NS_ConvertUTF16toUTF8(fe->Name()).get(), 
36949:              NS_ConvertUTF16toUTF8(ff->Name()).get(), 
36949:              (logFont.lfItalic == 0xff) ? "italic" : "normal",
36949:              logFont.lfWeight, fe->Stretch()));
36949:     }
36949: #endif
36949:     return 1;
36949: }
36949: 
36949: void
36949: GDIFontFamily::FindStyleVariations()
36949: {
36949:     if (mHasStyles)
36949:         return;
36949:     mHasStyles = PR_TRUE;
36949: 
36949:     HDC hdc = GetDC(nsnull);
36949:     SetGraphicsMode(hdc, GM_ADVANCED);
36949: 
36949:     LOGFONTW logFont;
36949:     memset(&logFont, 0, sizeof(LOGFONTW));
36949:     logFont.lfCharSet = DEFAULT_CHARSET;
36949:     logFont.lfPitchAndFamily = 0;
36949:     PRUint32 l = PR_MIN(mName.Length(), LF_FACESIZE - 1);
36949:     memcpy(logFont.lfFaceName,
36949:            nsPromiseFlatString(mName).get(),
36949:            l * sizeof(PRUnichar));
36949:     logFont.lfFaceName[l] = 0;
36949: 
36949:     EnumFontFamiliesExW(hdc, &logFont,
36949:                         (FONTENUMPROCW)GDIFontFamily::FamilyAddStylesProc,
36949:                         (LPARAM)this, 0);
36949: #ifdef DEBUG
36949:     if (mAvailableFonts.Length() == 0) {
36949:         char msgBuf[256];
36949:         (void)sprintf(msgBuf, "no styles available in family \"%s\"",
36949:                       NS_ConvertUTF16toUTF8(mName).get());
36949:         NS_ASSERTION(mAvailableFonts.Length() != 0, msgBuf);
36949:     }
36949: #endif
36949: 
36949:     ReleaseDC(nsnull, hdc);
36949: 
36949:     if (mIsBadUnderlineFamily)
36949:         SetBadUnderlineFonts();
36949: }
36949: 
36949: /***************************************************************
36949:  *
36949:  * gfxGDIFontList
36949:  *
36949:  */
36949: 
36949: gfxGDIFontList::gfxGDIFontList()
36949: {
36949:     mFontSubstitutes.Init(50);
36949: 
36949:     InitializeFontEmbeddingProcs();
36949: }
36949: 
36949: static void
36949: RemoveCharsetFromFontSubstitute(nsAString &aName)
36949: {
36949:     PRInt32 comma = aName.FindChar(PRUnichar(','));
36949:     if (comma >= 0)
36949:         aName.Truncate(comma);
36949: }
36949: 
36949: nsresult
36949: gfxGDIFontList::GetFontSubstitutes()
36949: {
36949:     // Create the list of FontSubstitutes
36949:     nsCOMPtr<nsIWindowsRegKey> regKey = do_CreateInstance("@mozilla.org/windows-registry-key;1");
36949:     if (!regKey)
36949:         return NS_ERROR_FAILURE;
36949:     NS_NAMED_LITERAL_STRING(kFontSubstitutesKey, "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes");
36949: 
36949:     nsresult rv = regKey->Open(nsIWindowsRegKey::ROOT_KEY_LOCAL_MACHINE,
36949:                                kFontSubstitutesKey, nsIWindowsRegKey::ACCESS_READ);
36949:     if (NS_FAILED(rv))
36949:         return rv;
36949: 
36949:     PRUint32 count;
36949:     rv = regKey->GetValueCount(&count);
36949:     if (NS_FAILED(rv) || count == 0)
36949:         return rv;
36949:     for (PRUint32 i = 0; i < count; i++) {
36949:         nsAutoString substituteName;
36949:         rv = regKey->GetValueName(i, substituteName);
36949:         if (NS_FAILED(rv) || substituteName.IsEmpty() || substituteName.CharAt(1) == PRUnichar('@'))
36949:             continue;
36949:         PRUint32 valueType;
36949:         rv = regKey->GetValueType(substituteName, &valueType);
36949:         if (NS_FAILED(rv) || valueType != nsIWindowsRegKey::TYPE_STRING)
36949:             continue;
36949:         nsAutoString actualFontName;
36949:         rv = regKey->ReadStringValue(substituteName, actualFontName);
36949:         if (NS_FAILED(rv))
36949:             continue;
36949: 
36949:         RemoveCharsetFromFontSubstitute(substituteName);
36949:         BuildKeyNameFromFontName(substituteName);
36949:         RemoveCharsetFromFontSubstitute(actualFontName);
36949:         BuildKeyNameFromFontName(actualFontName);
36949:         gfxFontFamily *ff;
36949:         if (!actualFontName.IsEmpty() && (ff = mFontFamilies.GetWeak(actualFontName))) {
36949:             mFontSubstitutes.Put(substituteName, ff);
36949:         } else {
36949:             mNonExistingFonts.AppendElement(substituteName);
36949:         }
36949:     }
36949:     return NS_OK;
36949: }
36949: 
36949: void
36949: gfxGDIFontList::InitFontList()
36949: {
36949:     gfxFontCache *fc = gfxFontCache::GetCache();
36949:     if (fc)
36949:         fc->AgeAllGenerations();
36949: 
36949:     mFontFamilies.Clear();
36949:     mOtherFamilyNames.Clear();
36949:     mOtherFamilyNamesInitialized = PR_FALSE;
36949:     mPrefFonts.Clear();
36949:     mFontSubstitutes.Clear();
36949:     mNonExistingFonts.Clear();
36949:     CancelLoader();
36949: 
36949:     // initialize ranges of characters for which system-wide font search should be skipped
36949:     mCodepointsWithNoFonts.reset();
36949:     mCodepointsWithNoFonts.SetRange(0,0x1f);     // C0 controls
36949:     mCodepointsWithNoFonts.SetRange(0x7f,0x9f);  // C1 controls
36949: 
36949:     // iterate over available families
36949:     LOGFONTW logfont;
36949:     memset(&logfont, 0, sizeof(logfont));
36949:     logfont.lfCharSet = DEFAULT_CHARSET;
36949: 
36949:     AutoDC hdc;
36949:     int result = EnumFontFamiliesExW(hdc.GetDC(), &logfont,
36949:                                      (FONTENUMPROCW)&EnumFontFamExProc,
36949:                                      0, 0);
36949: 
36949:     GetFontSubstitutes();
36949: 
36949:     InitBadUnderlineList();
36949: 
36949:     StartLoader(kDelayBeforeLoadingFonts, kIntervalBetweenLoadingFonts);
36949: }
36949:     
36949: int CALLBACK
36949: gfxGDIFontList::EnumFontFamExProc(ENUMLOGFONTEXW *lpelfe,
36949:                                       NEWTEXTMETRICEXW *lpntme,
36949:                                       DWORD fontType,
36949:                                       LPARAM lParam)
36949: {
36949:     const LOGFONTW& lf = lpelfe->elfLogFont;
36949: 
36949:     if (lf.lfFaceName[0] == '@') {
36949:         return 1;
36949:     }
36949: 
36949:     nsAutoString name(lf.lfFaceName);
36949:     BuildKeyNameFromFontName(name);
36949: 
36949:     gfxGDIFontList *fontList = PlatformFontList();
36949: 
36949:     if (!fontList->mFontFamilies.GetWeak(name)) {
36949:         nsRefPtr<gfxFontFamily> family = new GDIFontFamily(nsDependentString(lf.lfFaceName));
36949:         fontList->mFontFamilies.Put(name, family);
36949:     }
36949: 
36949:     return 1;
36949: }
36949: 
36949: gfxFontEntry* 
36949: gfxGDIFontList::LookupLocalFont(const gfxProxyFontEntry *aProxyEntry,
36949:                                 const nsAString& aFullname)
36949: {
36949:     LOGFONTW logFont;
36949:     memset(&logFont, 0, sizeof(LOGFONTW));
36949:     logFont.lfCharSet = DEFAULT_CHARSET;
36949:     PRUint32 namelen = PR_MIN(aFullname.Length(), LF_FACESIZE - 1);
36949:     ::memcpy(logFont.lfFaceName,
36949:              nsPromiseFlatString(aFullname).get(),
36949:              namelen * sizeof(PRUnichar));
36949:     logFont.lfFaceName[namelen] = 0;
36949: 
36949:     AutoDC dc;
36949:     ::SetGraphicsMode(dc.GetDC(), GM_ADVANCED);
36949: 
36949:     AutoSelectFont font(dc.GetDC(), &logFont);
36949:     if (!font.IsValid())
36949:         return nsnull;
36949: 
36949:     // fetch fullname from name table (Windows takes swapped tag order)
36949:     const PRUint32 kNameTag = NS_SWAP32(TRUETYPE_TAG('n','a','m','e'));
36949:     nsAutoString fullName;
36949: 
36949:     {
36949:         DWORD len = ::GetFontData(dc.GetDC(), kNameTag, 0, nsnull, 0);
36949:         if (len == GDI_ERROR || len == 0) // not a truetype font --
36949:             return nsnull;                // so just ignore
36949:     
36949:         nsAutoTArray<PRUint8,1024> nameData;
36949:         if (!nameData.AppendElements(len))
36949:             return nsnull;
36949:         PRUint8 *nameTable = nameData.Elements();
36949:     
36949:         DWORD newLen = ::GetFontData(dc.GetDC(), kNameTag, 0, nameTable, len);
36949:         if (newLen != len)
36949:             return nsnull;
36949:     
36949:         nsresult rv;
36949:         rv = gfxFontUtils::ReadCanonicalName(nameData, 
36949:                                              gfxFontUtils::NAME_ID_FULL,
36949:                                              fullName);
36949:         if (NS_FAILED(rv))
36949:             return nsnull;
36949:     }
36949: 
36949:     // reject if different from canonical fullname
36949:     if (!aFullname.Equals(fullName))
36949:         return nsnull;
36949: 
36949:     // create a new font entry
36949:     PRUint16 w = (aProxyEntry->mWeight == 0 ? 400 : aProxyEntry->mWeight);
36949:     PRBool isCFF = PR_FALSE; // jtdfix -- need to determine this
36949:     
36949:     gfxFontEntry *fe = GDIFontEntry::CreateFontEntry(aFullname, 
36949:         gfxWindowsFontType(isCFF ? GFX_FONT_TYPE_PS_OPENTYPE : GFX_FONT_TYPE_TRUETYPE) /*type*/, 
36949:         PRUint32(aProxyEntry->mItalic ? FONT_STYLE_ITALIC : FONT_STYLE_NORMAL), 
36949:         w, nsnull);
36949:         
36949:     if (!fe)
36949:         return fe;
36949: 
36949:     fe->mIsUserFont = PR_TRUE;
36949:     return fe;
36949: }
36949: 
36949: void gfxGDIFontList::InitializeFontEmbeddingProcs()
36949: {
36949:     HMODULE fontlib = LoadLibraryW(L"t2embed.dll");
36949:     if (!fontlib)
36949:         return;
36949:     TTLoadEmbeddedFontPtr = (TTLoadEmbeddedFontProc) GetProcAddress(fontlib, "TTLoadEmbeddedFont");
36949:     TTDeleteEmbeddedFontPtr = (TTDeleteEmbeddedFontProc) GetProcAddress(fontlib, "TTDeleteEmbeddedFont");
36949: }
36949: 
36949: // used to control stream read by Windows TTLoadEmbeddedFont API
36949: 
36949: class EOTFontStreamReader {
36949: public:
36949:     EOTFontStreamReader(const PRUint8 *aFontData, PRUint32 aLength, PRUint8 *aEOTHeader, 
36949:                            PRUint32 aEOTHeaderLen, FontDataOverlay *aNameOverlay)
36949:         : mCurrentChunk(0), mChunkOffset(0)
36949:     {
36949:         NS_ASSERTION(aFontData, "null font data ptr passed in");
36949:         NS_ASSERTION(aEOTHeader, "null EOT header ptr passed in");
36949:         NS_ASSERTION(aNameOverlay, "null name overlay struct passed in");
36949: 
36949:         if (aNameOverlay->overlaySrc) {
36949:             mNumChunks = 4;
36949:             // 0 : EOT header
36949:             mDataChunks[0].mData = aEOTHeader;
36949:             mDataChunks[0].mLength = aEOTHeaderLen;
36949:             // 1 : start of font data to overlayDest
36949:             mDataChunks[1].mData = aFontData;
36949:             mDataChunks[1].mLength = aNameOverlay->overlayDest;
36949:             // 2 : overlay data
36949:             mDataChunks[2].mData = aFontData + aNameOverlay->overlaySrc;
36949:             mDataChunks[2].mLength = aNameOverlay->overlaySrcLen;
36949:             // 3 : rest of font data
36949:             mDataChunks[3].mData = aFontData + aNameOverlay->overlayDest + aNameOverlay->overlaySrcLen;
36949:             mDataChunks[3].mLength = aLength - aNameOverlay->overlayDest - aNameOverlay->overlaySrcLen;
36949:         } else {
36949:             mNumChunks = 2;
36949:             // 0 : EOT header
36949:             mDataChunks[0].mData = aEOTHeader;
36949:             mDataChunks[0].mLength = aEOTHeaderLen;
36949:             // 1 : font data
36949:             mDataChunks[1].mData = aFontData;
36949:             mDataChunks[1].mLength = aLength;
36949:         }
36949:     }
36949: 
36949:     ~EOTFontStreamReader() 
36949:     { 
36949: 
36949:     }
36949: 
36949:     struct FontDataChunk {
36949:         const PRUint8 *mData;
36949:         PRUint32       mLength;
36949:     };
36949: 
36949:     PRUint32                mNumChunks;
36949:     FontDataChunk           mDataChunks[4];
36949:     PRUint32                mCurrentChunk;
36949:     PRUint32                mChunkOffset;
36949: 
36949:     unsigned long Read(void *outBuffer, const unsigned long aBytesToRead)
36949:     {
36949:         PRUint32 bytesLeft = aBytesToRead;  // bytes left in the out buffer
36949:         PRUint8 *out = static_cast<PRUint8*> (outBuffer);
36949: 
36949:         while (mCurrentChunk < mNumChunks && bytesLeft) {
36949:             FontDataChunk& currentChunk = mDataChunks[mCurrentChunk];
36949:             PRUint32 bytesToCopy = PR_MIN(bytesLeft, 
36949:                                           currentChunk.mLength - mChunkOffset);
36949:             memcpy(out, currentChunk.mData + mChunkOffset, bytesToCopy);
36949:             bytesLeft -= bytesToCopy;
36949:             mChunkOffset += bytesToCopy;
36949:             out += bytesToCopy;
36949: 
36949:             NS_ASSERTION(mChunkOffset <= currentChunk.mLength, "oops, buffer overrun");
36949: 
36949:             if (mChunkOffset == currentChunk.mLength) {
36949:                 mCurrentChunk++;
36949:                 mChunkOffset = 0;
36949:             }
36949:         }
36949: 
36949:         return aBytesToRead - bytesLeft;
36949:     }
36949: 
36949:     static unsigned long ReadEOTStream(void *aReadStream, void *outBuffer, 
36949:                                        const unsigned long aBytesToRead) 
36949:     {
36949:         EOTFontStreamReader *eotReader = 
36949:                                static_cast<EOTFontStreamReader*> (aReadStream);
36949:         return eotReader->Read(outBuffer, aBytesToRead);
36949:     }        
36949:         
36949: };
36949: 
36949: gfxFontEntry* 
36949: gfxGDIFontList::MakePlatformFont(const gfxProxyFontEntry *aProxyEntry, 
36949:                                  const PRUint8 *aFontData,
36949:                                  PRUint32 aLength)
36949: {
36949:     // MakePlatformFont is responsible for deleting the font data with NS_Free
36949:     // so we set up a stack object to ensure it is freed even if we take an
36949:     // early exit
36949:     struct FontDataDeleter {
36949:         FontDataDeleter(const PRUint8 *aFontData)
36949:             : mFontData(aFontData) { }
36949:         ~FontDataDeleter() { NS_Free((void*)mFontData); }
36949:         const PRUint8 *mFontData;
36949:     };
36949:     FontDataDeleter autoDelete(aFontData);
36949: 
36949:     // if calls aren't available, bail
36949:     if (!TTLoadEmbeddedFontPtr || !TTDeleteEmbeddedFontPtr)
36949:         return nsnull;
36949: 
36949:     PRBool isCFF = gfxFontUtils::IsCffFont(aFontData);
36949:         
36949:     nsresult rv;
36949:     HANDLE fontRef = nsnull;
36949:     PRBool isEmbedded = PR_FALSE;
36949: 
36949:     nsAutoString uniqueName;
36949:     rv = gfxFontUtils::MakeUniqueUserFontName(uniqueName);
36949:     if (NS_FAILED(rv))
36949:         return nsnull;
36949: 
36949:     // for TTF fonts, first try using the t2embed library
36949:     if (!isCFF) {
36949:         // TrueType-style glyphs, use EOT library
36949:         nsAutoTArray<PRUint8,2048> eotHeader;
36949:         PRUint8 *buffer;
36949:         PRUint32 eotlen;
36949: 
36949:         isEmbedded = PR_TRUE;
36949:         PRUint32 nameLen = PR_MIN(uniqueName.Length(), LF_FACESIZE - 1);
36949:         nsPromiseFlatString fontName(Substring(uniqueName, 0, nameLen));
36949:         
36949:         FontDataOverlay overlayNameData = {0, 0, 0};
36949: 
36949:         rv = gfxFontUtils::MakeEOTHeader(aFontData, aLength, &eotHeader, 
36949:                                          &overlayNameData);
36949:         if (NS_FAILED(rv))
36949:             return nsnull;
36949: 
36949:         // load in embedded font data
36949:         eotlen = eotHeader.Length();
36949:         buffer = reinterpret_cast<PRUint8*> (eotHeader.Elements());
36949:         
36949:         PRInt32 ret;
36949:         ULONG privStatus, pulStatus;
36949:         EOTFontStreamReader eotReader(aFontData, aLength, buffer, eotlen,
36949:                                       &overlayNameData);
36949: 
36949:         ret = TTLoadEmbeddedFontPtr(&fontRef, TTLOAD_PRIVATE, &privStatus, 
36949:                                    LICENSE_PREVIEWPRINT, &pulStatus, 
36949:                                    EOTFontStreamReader::ReadEOTStream, 
36949:                                    &eotReader, (PRUnichar*)(fontName.get()), 0, 0);
36949:         if (ret != E_NONE)
36949:             fontRef = nsnull;
36949:     }
36949: 
36949:     // load CFF fonts or fonts that failed with t2embed loader
36949:     if (fontRef == nsnull) {
36949:         // Postscript-style glyphs, swizzle name table, load directly
36949:         nsTArray<PRUint8> newFontData;
36949: 
36949:         isEmbedded = PR_FALSE;
36949:         rv = gfxFontUtils::RenameFont(uniqueName, aFontData, aLength, &newFontData);
36949: 
36949:         if (NS_FAILED(rv))
36949:             return nsnull;
36949:         
36949:         DWORD numFonts = 0;
36949: 
36949:         PRUint8 *fontData = reinterpret_cast<PRUint8*> (newFontData.Elements());
36949:         PRUint32 fontLength = newFontData.Length();
36949:         NS_ASSERTION(fontData, "null font data after renaming");
36949: 
36949:         // http://msdn.microsoft.com/en-us/library/ms533942(VS.85).aspx
36949:         // "A font that is added by AddFontMemResourceEx is always private 
36949:         //  to the process that made the call and is not enumerable."
36949:         fontRef = AddFontMemResourceEx(fontData, fontLength, 
36949:                                        0 /* reserved */, &numFonts);
36949:         if (!fontRef)
36949:             return nsnull;
36949: 
36949:         // only load fonts with a single face contained in the data
36949:         if (fontRef && numFonts != 1) {
36949:             RemoveFontMemResourceEx(fontRef);
36949:             return nsnull;
36949:         }
36949:     }
36949: 
36949:     // make a new font entry using the unique name
36949:     WinUserFontData *winUserFontData = new WinUserFontData(fontRef, isCFF);
36949:     PRUint16 w = (aProxyEntry->mWeight == 0 ? 400 : aProxyEntry->mWeight);
36949: 
36949:     GDIFontEntry *fe = GDIFontEntry::CreateFontEntry(uniqueName, 
36949:         gfxWindowsFontType(isCFF ? GFX_FONT_TYPE_PS_OPENTYPE : GFX_FONT_TYPE_TRUETYPE) /*type*/, 
36949:         PRUint32(aProxyEntry->mItalic ? FONT_STYLE_ITALIC : FONT_STYLE_NORMAL), 
36949:         w, winUserFontData);
36949: 
36949:     if (!fe)
36949:         return fe;
36949: 
36949:     fe->mIsUserFont = PR_TRUE;
36949: 
36949:     // Uniscribe doesn't place CFF fonts loaded privately via AddFontMemResourceEx
36949:     if (isCFF)
36949:         fe->mForceGDI = PR_TRUE;
36949:  
36949:     return fe;
36949: }
36949: 
36949: gfxFontEntry*
36949: gfxGDIFontList::GetDefaultFont(const gfxFontStyle* aStyle, PRBool& aNeedsBold)
36949: {
36949:     // this really shouldn't fail to find a font....
36949:     HGDIOBJ hGDI = ::GetStockObject(DEFAULT_GUI_FONT);
36949:     LOGFONTW logFont;
36949:     if (hGDI && ::GetObjectW(hGDI, sizeof(logFont), &logFont)) {
36949:         nsAutoString resolvedName;
36949:         if (ResolveFontName(nsDependentString(logFont.lfFaceName), resolvedName)) {
36949:             return FindFontForFamily(resolvedName, aStyle, aNeedsBold);
36949:         }
36949:     }
36949: 
36949:     // ...but just in case, try another approach as well
36949:     NONCLIENTMETRICSW ncm;
36949:     ncm.cbSize = sizeof(ncm);
36949:     BOOL status = ::SystemParametersInfoW(SPI_GETNONCLIENTMETRICS, 
36949:                                           sizeof(ncm), &ncm, 0);
36949:     if (status) {
36949:         nsAutoString resolvedName;
36949:         if (ResolveFontName(nsDependentString(ncm.lfMessageFont.lfFaceName), resolvedName)) {
36949:             return FindFontForFamily(resolvedName, aStyle, aNeedsBold);
36949:         }
36949:     }
36949: 
36949:     return nsnull;
36949: }
36949: 
36949: 
36949: PRBool 
36949: gfxGDIFontList::ResolveFontName(const nsAString& aFontName, nsAString& aResolvedFontName)
36949: {
36949:     nsAutoString keyName(aFontName);
36949:     BuildKeyNameFromFontName(keyName);
36949: 
36949:     nsRefPtr<gfxFontFamily> ff;
36949:     if (mFontSubstitutes.Get(keyName, &ff)) {
36949:         aResolvedFontName = ff->Name();
36949:         return PR_TRUE;
36949:     }
36949: 
36949:     if (mNonExistingFonts.Contains(keyName))
36949:         return PR_FALSE;
36949: 
36949:     if (gfxPlatformFontList::ResolveFontName(aFontName, aResolvedFontName))
36949:         return PR_TRUE;
36949: 
36949:     return PR_FALSE;
36949: }
