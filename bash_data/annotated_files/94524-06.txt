    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1:  
    1: /**
    1:  * MODULE NOTES:
    1:  * 
    1:  *  This class does two primary jobs:
    1:  *    1) It iterates the tokens provided during the 
    1:  *       tokenization process, identifing where elements
    1:  *       begin and end (doing validation and normalization).
    1:  *    2) It controls and coordinates with an instance of
    1:  *       the IContentSink interface, to coordinate the
    1:  *       the production of the content model.
    1:  *
    1:  *  The basic operation of this class assumes that an HTML
    1:  *  document is non-normalized. Therefore, we don't process
    1:  *  the document in a normalized way. Don't bother to look
    1:  *  for methods like: doHead() or doBody().
    1:  *
    1:  *  Instead, in order to be backward compatible, we must
    1:  *  scan the set of tokens and perform this basic set of
    1:  *  operations:
    1:  *    1)  Determine the token type (easy, since the tokens know)
    1:  *    2)  Determine the appropriate section of the HTML document
    1:  *        each token belongs in (HTML,HEAD,BODY,FRAMESET).
    1:  *    3)  Insert content into our document (via the sink) into
    1:  *        the correct section.
    1:  *    4)  In the case of tags that belong in the BODY, we must
    1:  *        ensure that our underlying document state reflects
    1:  *        the appropriate context for our tag. 
    1:  *
    1:  *        For example,if we see a <TR>, we must ensure our 
    1:  *        document contains a table into which the row can
    1:  *        be placed. This may result in "implicit containers" 
    1:  *        created to ensure a well-formed document.
    1:  *         
    1:  */
    1: 
    1: #ifndef NS_PARSER__
    1: #define NS_PARSER__
    1: 
    1: #include "nsIParser.h"
    1: #include "nsDeque.h"
    1: #include "nsParserNode.h"
    1: #include "nsIURL.h"
    1: #include "CParserContext.h"
    1: #include "nsParserCIID.h"
    1: #include "nsITokenizer.h"
    1: #include "nsHTMLTags.h"
    1: #include "nsDTDUtils.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsIContentSink.h"
    1: #include "nsCOMArray.h"
 6389: #include "nsCycleCollectionParticipant.h"
58891: #include "nsWeakReference.h"
    1: 
10953: class nsICharsetConverterManager;
    1: class nsIDTD;
    1: class nsScanner;
20053: class nsIThreadPool;
    1: 
    1: #ifdef _MSC_VER
    1: #pragma warning( disable : 4275 )
    1: #endif
    1: 
    1: 
    1: class nsParser : public nsIParser,
58891:                  public nsIStreamListener,
58891:                  public nsSupportsWeakReference
21569: {
    1:   public:
    1:     /**
    1:      * Called on module init
    1:      */
    1:     static nsresult Init();
    1: 
    1:     /**
    1:      * Called on module shutdown
    1:      */
    1:     static void Shutdown();
    1: 
 6389:     NS_DECL_CYCLE_COLLECTING_ISUPPORTS
 6389:     NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsParser, nsIParser)
    1: 
    1:     /**
    1:      * default constructor
    1:      * @update	gess5/11/98
    1:      */
    1:     nsParser();
    1: 
    1:     /**
    1:      * Destructor
    1:      * @update	gess5/11/98
    1:      */
    1:     virtual ~nsParser();
    1: 
    1:     /**
    1:      * Select given content sink into parser for parser output
    1:      * @update	gess5/11/98
    1:      * @param   aSink is the new sink to be used by parser
    1:      * @return  old sink, or NULL
    1:      */
    1:     NS_IMETHOD_(void) SetContentSink(nsIContentSink* aSink);
    1: 
    1:     /**
    1:      * retrive the sink set into the parser 
    1:      * @update	gess5/11/98
    1:      * @param   aSink is the new sink to be used by parser
    1:      * @return  old sink, or NULL
    1:      */
    1:     NS_IMETHOD_(nsIContentSink*) GetContentSink(void);
    1:     
    1:     /**
    1:      *  Call this method once you've created a parser, and want to instruct it
    1:      *  about the command which caused the parser to be constructed. For example,
    1:      *  this allows us to select a DTD which can do, say, view-source.
    1:      *  
    1:      *  @update  gess 3/25/98
    1:      *  @param   aCommand -- ptrs to string that contains command
    1:      *  @return	 nada
    1:      */
    1:     NS_IMETHOD_(void) GetCommand(nsCString& aCommand);
    1:     NS_IMETHOD_(void) SetCommand(const char* aCommand);
    1:     NS_IMETHOD_(void) SetCommand(eParserCommands aParserCommand);
    1: 
    1:     /**
    1:      *  Call this method once you've created a parser, and want to instruct it
    1:      *  about what charset to load
    1:      *  
    1:      *  @update  ftang 4/23/99
    1:      *  @param   aCharset- the charset of a document
    1:      *  @param   aCharsetSource- the source of the charset
    1:      *  @return	 nada
    1:      */
    1:     NS_IMETHOD_(void) SetDocumentCharset(const nsACString& aCharset, PRInt32 aSource);
    1: 
    1:     NS_IMETHOD_(void) GetDocumentCharset(nsACString& aCharset, PRInt32& aSource)
    1:     {
    1:          aCharset = mCharset;
    1:          aSource = mCharsetSource;
    1:     }
    1: 
    1:     /**
    1:      * Cause parser to parse input from given URL 
    1:      * @update	gess5/11/98
    1:      * @param   aURL is a descriptor for source document
    1:      * @param   aListener is a listener to forward notifications to
    1:      * @return  TRUE if all went well -- FALSE otherwise
    1:      */
    1:     NS_IMETHOD Parse(nsIURI* aURL,
    1:                      nsIRequestObserver* aListener = nsnull,
    1:                      void* aKey = 0,
    1:                      nsDTDMode aMode = eDTDMode_autodetect);
    1: 
    1:     /**
    1:      * This method needs documentation
    1:      */
    1:     NS_IMETHOD ParseFragment(const nsAString& aSourceBuffer,
74622:                              nsTArray<nsString>& aTagStack);
    1:                              
    1:     /**
    1:      * This method gets called when the tokens have been consumed, and it's time
    1:      * to build the model via the content sink.
    1:      * @update	gess5/11/98
    1:      * @return  YES if model building went well -- NO otherwise.
    1:      */
    1:     NS_IMETHOD BuildModel(void);
    1: 
    1:     NS_IMETHOD        ContinueInterruptedParsing();
    1:     NS_IMETHOD_(void) BlockParser();
    1:     NS_IMETHOD_(void) UnblockParser();
87805:     NS_IMETHOD_(void) ContinueInterruptedParsingAsync();
    1:     NS_IMETHOD        Terminate(void);
    1: 
    1:     /**
    1:      * Call this to query whether the parser is enabled or not.
    1:      *
    1:      *  @update  vidur 4/12/99
    1:      *  @return  current state
    1:      */
79445:     NS_IMETHOD_(bool) IsParserEnabled();
    1: 
    1:     /**
    1:      * Call this to query whether the parser thinks it's done with parsing.
    1:      *
    1:      *  @update  rickg 5/12/01
    1:      *  @return  complete state
    1:      */
79445:     NS_IMETHOD_(bool) IsComplete();
    1: 
    1:     /**
    1:      *  This rather arcane method (hack) is used as a signal between the
    1:      *  DTD and the parser. It allows the DTD to tell the parser that content
    1:      *  that comes through (parser::parser(string)) but not consumed should
    1:      *  propagate into the next string based parse call.
    1:      *  
    1:      *  @update  gess 9/1/98
    1:      *  @param   aState determines whether we propagate unused string content.
    1:      *  @return  current state
    1:      */
    1:     void SetUnusedInput(nsString& aBuffer);
    1: 
    1:     /**
    1:      * This method gets called (automatically) during incremental parsing
    1:      * @update	gess5/11/98
    1:      * @return  TRUE if all went well, otherwise FALSE
    1:      */
79445:     virtual nsresult ResumeParse(bool allowIteration = true, 
79445:                                  bool aIsFinalChunk = false,
79445:                                  bool aCanInterrupt = true);
    1: 
    1:      //*********************************************
    1:       // These methods are callback methods used by
    1:       // net lib to let us know about our inputstream.
    1:       //*********************************************
    1:     // nsIRequestObserver methods:
    1:     NS_DECL_NSIREQUESTOBSERVER
    1: 
    1:     // nsIStreamListener methods:
    1:     NS_DECL_NSISTREAMLISTENER
    1: 
    1:     void              PushContext(CParserContext& aContext);
    1:     CParserContext*   PopContext();
    1:     CParserContext*   PeekContext() {return mParserContext;}
    1: 
    1:     /** 
    1:      * Get the channel associated with this parser
    1:      * @update harishd,gagan 07/17/01
    1:      * @param aChannel out param that will contain the result
    1:      * @return NS_OK if successful
    1:      */
    1:     NS_IMETHOD GetChannel(nsIChannel** aChannel);
    1: 
    1:     /** 
    1:      * Get the DTD associated with this parser
    1:      * @update vidur 9/29/99
    1:      * @param aDTD out param that will contain the result
    1:      * @return NS_OK if successful, NS_ERROR_FAILURE for runtime error
    1:      */
    1:     NS_IMETHOD GetDTD(nsIDTD** aDTD);
    1:   
    1:     /**
32917:      * Get the nsIStreamListener for this parser
32917:      */
82297:     virtual nsIStreamListener* GetStreamListener();
32917: 
32917:     /** 
    1:      * Detects the existence of a META tag with charset information in 
    1:      * the given buffer.
    1:      */
79445:     bool DetectMetaTag(const char* aBytes, 
    1:                          PRInt32 aLen, 
    1:                          nsCString& oCharset, 
    1:                          PRInt32& oCharsetSource);
    1: 
    1:     void SetSinkCharset(nsACString& aCharset);
    1: 
    1:     /**
    1:      *  Removes continue parsing events
    1:      *  @update  kmcclusk 5/18/98
    1:      */
    1: 
    1:     NS_IMETHODIMP CancelParsingEvents();
    1: 
    1:     /**
34983:      * Return true.
34983:      */
79445:     virtual bool IsInsertionPointDefined();
34983: 
34983:     /**
34983:      * No-op.
34983:      */
34983:     virtual void BeginEvaluatingParserInsertedScript();
34983: 
34983:     /**
34983:      * No-op.
34983:      */
34983:     virtual void EndEvaluatingParserInsertedScript();
34983: 
34983:     /**
34983:      * No-op.
34983:      */
81151:     virtual void MarkAsNotScriptCreated(const char* aCommand);
34983: 
34983:     /**
34983:      * Always false.
34983:      */
79445:     virtual bool IsScriptCreated();
34983: 
34983:     /**  
    1:      *  Set to parser state to indicate whether parsing tokens can be interrupted
80486:      *  @param aCanInterrupt true if parser can be interrupted, false if it can not be interrupted.
    1:      *  @update  kmcclusk 5/18/98
    1:      */
79445:     void SetCanInterrupt(bool aCanInterrupt);
    1: 
    1:     /**
    1:      * This is called when the final chunk has been
    1:      * passed to the parser and the content sink has
    1:      * interrupted token processing. It schedules
    1:      * a ParserContinue PL_Event which will ask the parser
    1:      * to HandleParserContinueEvent when it is handled.
    1:      * @update	kmcclusk6/1/2001
    1:      */
    1:     nsresult PostContinueEvent();
    1: 
    1:     /**
    1:      *  Fired when the continue parse event is triggered.
    1:      *  @update  kmcclusk 5/18/98
    1:      */
    1:     void HandleParserContinueEvent(class nsParserContinueEvent *);
    1: 
10953:     static nsICharsetConverterManager* GetCharsetConverterManager() {
10953:       return sCharsetConverterManager;
10953:     }
10953: 
11423:     virtual void Reset() {
11423:       Cleanup();
11423:       Initialize();
11423:     }
11423: 
79445:     bool IsScriptExecuting() {
27387:       return mSink && mSink->IsScriptExecuting();
27387:     }
22702: 
79445:     bool IsOkToProcessNetworkData() {
34651:       return !IsScriptExecuting() && !mProcessingNetworkData;
34651:     }
34651: 
    1:  protected:
    1: 
79445:     void Initialize(bool aConstructor = false);
11423:     void Cleanup();
11423: 
    1:     /**
    1:      * 
    1:      * @update	gess5/18/98
    1:      * @param 
    1:      * @return
    1:      */
    1:     nsresult WillBuildModel(nsString& aFilename);
    1: 
    1:     /**
    1:      * 
    1:      * @update	gess5/18/98
    1:      * @param 
    1:      * @return
    1:      */
    1:     nsresult DidBuildModel(nsresult anErrorCode);
    1: 
    1: private:
    1: 
    1:     /*******************************************
    1:       These are the tokenization methods...
    1:      *******************************************/
    1: 
    1:     /**
    1:      *  Part of the code sandwich, this gets called right before
    1:      *  the tokenization process begins. The main reason for
    1:      *  this call is to allow the delegate to do initialization.
    1:      *  
    1:      *  @update  gess 3/25/98
    1:      *  @param   
    1:      *  @return  TRUE if it's ok to proceed
    1:      */
79445:     bool WillTokenize(bool aIsFinalChunk = false);
    1: 
    1:    
    1:     /**
    1:      *  This is the primary control routine. It iteratively
    1:      *  consumes tokens until an error occurs or you run out
    1:      *  of data.
    1:      *  
    1:      *  @update  gess 3/25/98
    1:      *  @return  error code 
    1:      */
79445:     nsresult Tokenize(bool aIsFinalChunk = false);
    1: 
    1:     /**
    1:      *  This is the tail-end of the code sandwich for the
    1:      *  tokenization process. It gets called once tokenziation
    1:      *  has completed.
    1:      *  
    1:      *  @update  gess 3/25/98
    1:      *  @param   
    1:      *  @return  TRUE if all went well
    1:      */
79445:     bool DidTokenize(bool aIsFinalChunk = false);
    1: 
94146:     /**
94146:      * Pushes XML fragment parsing data to expat without an input stream.
94146:      */
94146:     nsresult Parse(const nsAString& aSourceBuffer,
94146:                    void* aKey,
94146:                    bool aLastCall);
94146: 
    1: protected:
    1:     //*********************************************
    1:     // And now, some data members...
    1:     //*********************************************
    1:     
    1:       
    1:     CParserContext*              mParserContext;
26491:     nsCOMPtr<nsIDTD>             mDTD;
    1:     nsCOMPtr<nsIRequestObserver> mObserver;
    1:     nsCOMPtr<nsIContentSink>     mSink;
    1:     nsIRunnable*                 mContinueEvent;  // weak ref
    1:    
    1:     nsTokenAllocator          mTokenAllocator;
    1:     
    1:     eParserCommands     mCommand;
    1:     nsresult            mInternalState;
    1:     PRInt32             mStreamStatus;
    1:     PRInt32             mCharsetSource;
    1:     
    1:     PRUint16            mFlags;
    1: 
    1:     nsString            mUnusedInput;
    1:     nsCString           mCharset;
    1:     nsCString           mCommandStr;
    1: 
79445:     bool                mProcessingNetworkData;
94524:     bool                mIsAboutBlank;
34651: 
10953:     static nsICharsetConverterManager* sCharsetConverterManager;
    1: };
    1: 
    1: #endif 
    1: 
