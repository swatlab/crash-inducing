    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: // vim:cindent:ts=2:et:sw=2:
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Steve Clark <buster@netscape.com>
    1:  *   Robert O'Callahan <roc+moz@cs.cmu.edu>
    1:  *   L. David Baron <dbaron@dbaron.org>
    1:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* state used in reflow of block frames */
    1: 
    1: #include "nsBlockReflowContext.h"
    1: #include "nsBlockReflowState.h"
    1: #include "nsBlockFrame.h"
    1: #include "nsLineLayout.h"
    1: #include "nsPresContext.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIFrame.h"
    1: #include "nsFrameManager.h"
48983: #include "mozilla/AutoRestore.h"
    1: 
    1: #include "nsINameSpaceManager.h"
    1: 
    1: 
    1: #ifdef DEBUG
    1: #include "nsBlockDebugFlags.h"
    1: #endif
    1: 
48983: using namespace mozilla;
48983: 
    1: nsBlockReflowState::nsBlockReflowState(const nsHTMLReflowState& aReflowState,
    1:                                        nsPresContext* aPresContext,
    1:                                        nsBlockFrame* aFrame,
    1:                                        const nsHTMLReflowMetrics& aMetrics,
    1:                                        PRBool aTopMarginRoot,
    1:                                        PRBool aBottomMarginRoot,
23305:                                        PRBool aBlockNeedsFloatManager)
    1:   : mBlock(aFrame),
    1:     mPresContext(aPresContext),
    1:     mReflowState(aReflowState),
49010:     mPushedFloats(nsnull),
32448:     mOverflowTracker(nsnull),
    1:     mPrevBottomMargin(),
    1:     mLineNumber(0),
    1:     mFlags(0),
11852:     mFloatBreakType(NS_STYLE_CLEAR_NONE)
    1: {
    1:   SetFlag(BRS_ISFIRSTINFLOW, aFrame->GetPrevInFlow() == nsnull);
 4006:   SetFlag(BRS_ISOVERFLOWCONTAINER,
 6521:           IS_TRUE_OVERFLOW_CONTAINER(aFrame));
    1: 
    1:   const nsMargin& borderPadding = BorderPadding();
    1: 
    1:   if (aTopMarginRoot || 0 != aReflowState.mComputedBorderPadding.top) {
    1:     SetFlag(BRS_ISTOPMARGINROOT, PR_TRUE);
    1:   }
    1:   if (aBottomMarginRoot || 0 != aReflowState.mComputedBorderPadding.bottom) {
    1:     SetFlag(BRS_ISBOTTOMMARGINROOT, PR_TRUE);
    1:   }
    1:   if (GetFlag(BRS_ISTOPMARGINROOT)) {
    1:     SetFlag(BRS_APPLYTOPMARGIN, PR_TRUE);
    1:   }
23305:   if (aBlockNeedsFloatManager) {
23305:     SetFlag(BRS_FLOAT_MGR, PR_TRUE);
    1:   }
    1:   
23305:   mFloatManager = aReflowState.mFloatManager;
    1: 
23305:   NS_ASSERTION(mFloatManager,
23305:                "FloatManager should be set in nsBlockReflowState" );
23305:   if (mFloatManager) {
49569:     // Save the coordinate system origin for later.
23305:     mFloatManager->GetTranslation(mFloatManagerX, mFloatManagerY);
27100:     mFloatManager->PushState(&mFloatManagerStateBefore); // never popped
    1:   }
    1: 
    1:   mReflowStatus = NS_FRAME_COMPLETE;
    1: 
    1:   mPresContext = aPresContext;
 3233:   mNextInFlow = static_cast<nsBlockFrame*>(mBlock->GetNextInFlow());
    1: 
34267:   NS_WARN_IF_FALSE(NS_UNCONSTRAINEDSIZE != aReflowState.ComputedWidth(),
34267:                    "have unconstrained width; this should only result from "
34267:                    "very large sizes, not attempts at intrinsic width "
34267:                    "calculation");
    1:   mContentArea.width = aReflowState.ComputedWidth();
    1: 
    1:   // Compute content area height. Unlike the width, if we have a
    1:   // specified style height we ignore it since extra content is
    1:   // managed by the "overflow" property. When we don't have a
    1:   // specified style height then we may end up limiting our height if
    1:   // the availableHeight is constrained (this situation occurs when we
    1:   // are paginated).
    1:   if (NS_UNCONSTRAINEDSIZE != aReflowState.availableHeight) {
    1:     // We are in a paginated situation. The bottom edge is just inside
    1:     // the bottom border and padding. The content area height doesn't
    1:     // include either border or padding edge.
    1:     mBottomEdge = aReflowState.availableHeight - borderPadding.bottom;
32531:     mContentArea.height = NS_MAX(0, mBottomEdge - borderPadding.top);
    1:   }
    1:   else {
    1:     // When we are not in a paginated situation then we always use
    1:     // an constrained height.
    1:     SetFlag(BRS_UNCONSTRAINEDHEIGHT, PR_TRUE);
    1:     mContentArea.height = mBottomEdge = NS_UNCONSTRAINEDSIZE;
    1:   }
49569:   mContentArea.x = borderPadding.left;
49569:   mY = mContentArea.y = borderPadding.top;
    1: 
    1:   mPrevChild = nsnull;
    1:   mCurrentLine = aFrame->end_lines();
    1: 
28519:   mMinLineHeight = aReflowState.CalcLineHeight();
    1: }
    1: 
    1: nsLineBox*
    1: nsBlockReflowState::NewLineBox(nsIFrame* aFrame,
    1:                                PRInt32 aCount,
    1:                                PRBool aIsBlock)
    1: {
    1:   return NS_NewLineBox(mPresContext->PresShell(), aFrame, aCount, aIsBlock);
    1: }
    1: 
    1: void
    1: nsBlockReflowState::FreeLineBox(nsLineBox* aLine)
    1: {
    1:   if (aLine) {
    1:     aLine->Destroy(mPresContext->PresShell());
    1:   }
    1: }
    1: 
14324: void
14324: nsBlockReflowState::ComputeReplacedBlockOffsetsForFloats(nsIFrame* aFrame,
27103:                                                          const nsRect& aFloatAvailableSpace,
14324:                                                          nscoord& aLeftResult,
14324:                                                          nscoord& aRightResult,
14324:                                                          nsBlockFrame::
14324:                                                       ReplacedElementWidthToClear
14324:                                                                  *aReplacedWidth)
14324: {
23305:   // The frame is clueless about the float manager and therefore we
14324:   // only give it free space. An example is a table frame - the
14324:   // tables do not flow around floats.
14324:   // However, we can let its margins intersect floats.
49569:   NS_ASSERTION(aFloatAvailableSpace.x >= mContentArea.x, "bad avail space rect x");
27103:   NS_ASSERTION(aFloatAvailableSpace.width == 0 ||
49569:                aFloatAvailableSpace.XMost() <= mContentArea.XMost(),
14324:                "bad avail space rect width");
14324: 
14324:   nscoord leftOffset, rightOffset;
27103:   if (aFloatAvailableSpace.width == mContentArea.width) {
14324:     // We don't need to compute margins when there are no floats around.
14324:     leftOffset = 0;
14324:     rightOffset = 0;
14324:   } else {
14324:     // We pass in aReplacedWidth to make handling outer table frames
14324:     // work correctly.  For outer table frames, we need to subtract off
14324:     // the margin that's going to be at the edge of them, since we're
14324:     // dealing with margin that it's really the child's responsibility
14324:     // to place.
14324:     nsCSSOffsetState os(aFrame, mReflowState.rendContext, mContentArea.width);
14324:     NS_ASSERTION(!aReplacedWidth ||
14324:                  aFrame->GetType() == nsGkAtoms::tableOuterFrame ||
14324:                  (aReplacedWidth->marginLeft  == os.mComputedMargin.left &&
14324:                   aReplacedWidth->marginRight == os.mComputedMargin.right),
14324:                  "unexpected aReplacedWidth");
14324: 
49569:     nscoord leftFloatXOffset = aFloatAvailableSpace.x - mContentArea.x;
32531:     leftOffset = NS_MAX(leftFloatXOffset, os.mComputedMargin.left) -
14324:                  (aReplacedWidth ? aReplacedWidth->marginLeft
14324:                                  : os.mComputedMargin.left);
32531:     leftOffset = NS_MAX(leftOffset, 0); // in case of negative margin
27103:     nscoord rightFloatXOffset =
49569:       mContentArea.XMost() - aFloatAvailableSpace.XMost();
32531:     rightOffset = NS_MAX(rightFloatXOffset, os.mComputedMargin.right) -
14324:                   (aReplacedWidth ? aReplacedWidth->marginRight
14324:                                   : os.mComputedMargin.right);
32531:     rightOffset = NS_MAX(rightOffset, 0); // in case of negative margin
14324:   }
14324:   aLeftResult = leftOffset;
14324:   aRightResult = rightOffset;
14324: }
14324: 
    1: // Compute the amount of available space for reflowing a block frame
    1: // at the current Y coordinate. This method assumes that
    1: // GetAvailableSpace has already been called.
    1: void
    1: nsBlockReflowState::ComputeBlockAvailSpace(nsIFrame* aFrame,
    1:                                            const nsStyleDisplay* aDisplay,
27106:                                            const nsFlowAreaRect& aFloatAvailableSpace,
14910:                                            PRBool aBlockAvoidsFloats,
    1:                                            nsRect& aResult)
    1: {
    1: #ifdef REALLY_NOISY_REFLOW
27106:   printf("CBAS frame=%p has floats %d\n",
27106:          aFrame, aFloatAvailableSpace.mHasFloats);
    1: #endif
    1:   aResult.y = mY;
    1:   aResult.height = GetFlag(BRS_UNCONSTRAINEDHEIGHT)
    1:     ? NS_UNCONSTRAINEDSIZE
49009:     : mReflowState.availableHeight - mY;
 8933:   // mY might be greater than mBottomEdge if the block's top margin pushes
 8933:   // it off the page/column. Negative available height can confuse other code
 8933:   // and is nonsense in principle.
    1: 
10895:   // XXX Do we really want this condition to be this restrictive (i.e.,
10895:   // more restrictive than it used to be)?  The |else| here is allowed
10895:   // by the CSS spec, but only out of desperation given implementations,
10895:   // and the behavior it leads to is quite undesirable (it can cause
10895:   // things to become extremely narrow when they'd fit quite well a
10895:   // little bit lower).  Should the else be a quirk or something that
10895:   // applies to a specific set of frame classes and no new ones?
10895:   // If we did that, then for those frames where the condition below is
10895:   // true but nsBlockFrame::BlockCanIntersectFloats is false,
10895:   // nsBlockFrame::WidthToClearPastFloats would need to use the
10895:   // shrink-wrap formula, max(MIN_WIDTH, min(avail width, PREF_WIDTH))
10895:   // rather than just using MIN_WIDTH.
14910:   NS_ASSERTION(nsBlockFrame::BlockCanIntersectFloats(aFrame) == 
14910:                  !aBlockAvoidsFloats,
14324:                "unexpected replaced width");
14910:   if (!aBlockAvoidsFloats) {
27106:     if (aFloatAvailableSpace.mHasFloats) {
    1:       // Use the float-edge property to determine how the child block
    1:       // will interact with the float.
    1:       const nsStyleBorder* borderStyle = aFrame->GetStyleBorder();
    1:       switch (borderStyle->mFloatEdge) {
    1:         default:
    1:         case NS_STYLE_FLOAT_EDGE_CONTENT:  // content and only content does runaround of floats
    1:           // The child block will flow around the float. Therefore
    1:           // give it all of the available space.
49569:           aResult.x = mContentArea.x;
    1:           aResult.width = mContentArea.width;
    1:           break;
    1:         case NS_STYLE_FLOAT_EDGE_MARGIN:
    1:           {
    1:             // The child block's margins should be placed adjacent to,
    1:             // but not overlap the float.
49569:             aResult.x = aFloatAvailableSpace.mRect.x;
27106:             aResult.width = aFloatAvailableSpace.mRect.width;
    1:           }
    1:           break;
    1:       }
    1:     }
    1:     else {
    1:       // Since there are no floats present the float-edge property
    1:       // doesn't matter therefore give the block element all of the
    1:       // available space since it will flow around the float itself.
49569:       aResult.x = mContentArea.x;
    1:       aResult.width = mContentArea.width;
    1:     }
    1:   }
    1:   else {
14910:     nsBlockFrame::ReplacedElementWidthToClear replacedWidthStruct;
14910:     nsBlockFrame::ReplacedElementWidthToClear *replacedWidth = nsnull;
14910:     if (aFrame->GetType() == nsGkAtoms::tableOuterFrame) {
14910:       replacedWidth = &replacedWidthStruct;
27103:       replacedWidthStruct =
27106:         nsBlockFrame::WidthToClearPastFloats(*this, aFloatAvailableSpace.mRect,
27103:                                              aFrame);
14910:     }
14910: 
14324:     nscoord leftOffset, rightOffset;
27106:     ComputeReplacedBlockOffsetsForFloats(aFrame, aFloatAvailableSpace.mRect,
27103:                                          leftOffset, rightOffset,
14910:                                          replacedWidth);
49569:     aResult.x = mContentArea.x + leftOffset;
14324:     aResult.width = mContentArea.width - leftOffset - rightOffset;
    1:   }
    1: 
    1: #ifdef REALLY_NOISY_REFLOW
    1:   printf("  CBAS: result %d %d %d %d\n", aResult.x, aResult.y, aResult.width, aResult.height);
    1: #endif
    1: }
    1: 
27106: nsFlowAreaRect
27100: nsBlockReflowState::GetFloatAvailableSpaceWithState(
48978:                       nscoord aY,
27106:                       nsFloatManager::SavedState *aState) const
    1: {
    1: #ifdef DEBUG
    1:   // Verify that the caller setup the coordinate system properly
    1:   nscoord wx, wy;
23305:   mFloatManager->GetTranslation(wx, wy);
23305:   NS_ASSERTION((wx == mFloatManagerX) && (wy == mFloatManagerY),
    1:                "bad coord system");
    1: #endif
    1: 
48999:   nscoord height = (mContentArea.height == nscoord_MAX)
49569:                      ? nscoord_MAX : NS_MAX(mContentArea.YMost() - aY, 0);
27106:   nsFlowAreaRect result =
49569:     mFloatManager->GetFlowArea(aY, nsFloatManager::BAND_FROM_POINT,
49569:                                height, mContentArea, aState);
24630:   // Keep the width >= 0 for compatibility with nsSpaceManager.
27106:   if (result.mRect.width < 0)
27106:     result.mRect.width = 0;
    1: 
    1: #ifdef DEBUG
    1:   if (nsBlockFrame::gNoisyReflow) {
    1:     nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
23306:     printf("GetAvailableSpace: band=%d,%d,%d,%d hasfloats=%d\n",
27106:            result.mRect.x, result.mRect.y, result.mRect.width,
27106:            result.mRect.height, result.mHasFloats);
    1:   }
    1: #endif
27106:   return result;
    1: }
    1: 
28638: nsFlowAreaRect
28638: nsBlockReflowState::GetFloatAvailableSpaceForHeight(
28638:                       nscoord aY, nscoord aHeight,
28638:                       nsFloatManager::SavedState *aState) const
28638: {
28638: #ifdef DEBUG
28638:   // Verify that the caller setup the coordinate system properly
28638:   nscoord wx, wy;
28638:   mFloatManager->GetTranslation(wx, wy);
28638:   NS_ASSERTION((wx == mFloatManagerX) && (wy == mFloatManagerY),
28638:                "bad coord system");
28638: #endif
28638: 
28638:   nsFlowAreaRect result =
49569:     mFloatManager->GetFlowArea(aY, nsFloatManager::WIDTH_WITHIN_HEIGHT,
49569:                                aHeight, mContentArea, aState);
28638:   // Keep the width >= 0 for compatibility with nsSpaceManager.
28638:   if (result.mRect.width < 0)
28638:     result.mRect.width = 0;
28638: 
28638: #ifdef DEBUG
28638:   if (nsBlockFrame::gNoisyReflow) {
28638:     nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
28638:     printf("GetAvailableSpaceForHeight: space=%d,%d,%d,%d hasfloats=%d\n",
28638:            result.mRect.x, result.mRect.y, result.mRect.width,
28638:            result.mRect.height, result.mHasFloats);
28638:   }
28638: #endif
28638:   return result;
28638: }
28638: 
    1: /*
    1:  * Reconstruct the vertical margin before the line |aLine| in order to
    1:  * do an incremental reflow that begins with |aLine| without reflowing
    1:  * the line before it.  |aLine| may point to the fencepost at the end of
    1:  * the line list, and it is used this way since we (for now, anyway)
    1:  * always need to recover margins at the end of a block.
    1:  *
    1:  * The reconstruction involves walking backward through the line list to
    1:  * find any collapsed margins preceding the line that would have been in
    1:  * the reflow state's |mPrevBottomMargin| when we reflowed that line in
    1:  * a full reflow (under the rule in CSS2 that all adjacent vertical
    1:  * margins of blocks collapse).
    1:  */
    1: void
    1: nsBlockReflowState::ReconstructMarginAbove(nsLineList::iterator aLine)
    1: {
    1:   mPrevBottomMargin.Zero();
    1:   nsBlockFrame *block = mBlock;
    1: 
    1:   nsLineList::iterator firstLine = block->begin_lines();
    1:   for (;;) {
    1:     --aLine;
    1:     if (aLine->IsBlock()) {
    1:       mPrevBottomMargin = aLine->GetCarriedOutBottomMargin();
    1:       break;
    1:     }
    1:     if (!aLine->IsEmpty()) {
    1:       break;
    1:     }
    1:     if (aLine == firstLine) {
    1:       // If the top margin was carried out (and thus already applied),
    1:       // set it to zero.  Either way, we're done.
    1:       if (!GetFlag(BRS_ISTOPMARGINROOT)) {
    1:         mPrevBottomMargin.Zero();
    1:       }
    1:       break;
    1:     }
    1:   }
    1: }
    1: 
32108: void
49010: nsBlockReflowState::SetupPushedFloatList()
32108: {
49010:   NS_ABORT_IF_FALSE(!GetFlag(BRS_PROPTABLE_FLOATCLIST) == !mPushedFloats,
48990:                     "flag mismatch");
32108:   if (!GetFlag(BRS_PROPTABLE_FLOATCLIST)) {
48990:     // If we're being re-Reflow'd without our next-in-flow having been
49010:     // reflowed, some pushed floats from our previous reflow might
49010:     // still be on our pushed floats list.  However, that's
48990:     // actually fine, since they'll all end up being stolen and
48990:     // reordered into the correct order again.
49002:     // (nsBlockFrame::ReflowDirtyLines ensures that any lines with
49002:     // pushed floats are reflowed.)
49010:     mPushedFloats = mBlock->EnsurePushedFloats();
32108:     SetFlag(BRS_PROPTABLE_FLOATCLIST, PR_TRUE);
32108:   }
32108: }
32108: 
    1: /**
23305:  * Restore information about floats into the float manager for an
    1:  * incremental reflow, and simultaneously push the floats by
    1:  * |aDeltaY|, which is the amount |aLine| was pushed relative to its
    1:  * parent.  The recovery of state is one of the things that makes
    1:  * incremental reflow O(N^2) and this state should really be kept
    1:  * around, attached to the frame tree.
    1:  */
    1: void
    1: nsBlockReflowState::RecoverFloats(nsLineList::iterator aLine,
    1:                                   nscoord aDeltaY)
    1: {
    1:   if (aLine->HasFloats()) {
    1:     // Place the floats into the space-manager again. Also slide
    1:     // them, just like the regular frames on the line.
    1:     nsFloatCache* fc = aLine->GetFirstFloat();
    1:     while (fc) {
32107:       nsIFrame* floatFrame = fc->mFloat;
    1:       if (aDeltaY != 0) {
    1:         nsPoint p = floatFrame->GetPosition();
    1:         floatFrame->SetPosition(nsPoint(p.x, p.y + aDeltaY));
 3013:         nsContainerFrame::PositionFrameView(floatFrame);
 3013:         nsContainerFrame::PositionChildViews(floatFrame);
    1:       }
    1: #ifdef DEBUG
23305:       if (nsBlockFrame::gNoisyReflow || nsBlockFrame::gNoisyFloatManager) {
    1:         nscoord tx, ty;
23305:         mFloatManager->GetTranslation(tx, ty);
    1:         nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
    1:         printf("RecoverFloats: txy=%d,%d (%d,%d) ",
23305:                tx, ty, mFloatManagerX, mFloatManagerY);
    1:         nsFrame::ListTag(stdout, floatFrame);
30321:         nsRect region = nsFloatManager::GetRegionFor(floatFrame);
    1:         printf(" aDeltaY=%d region={%d,%d,%d,%d}\n",
30321:                aDeltaY, region.x, region.y, region.width, region.height);
    1:       }
    1: #endif
30321:       mFloatManager->AddFloat(floatFrame,
30321:                               nsFloatManager::GetRegionFor(floatFrame));
    1:       fc = fc->Next();
    1:     }
    1:   } else if (aLine->IsBlock()) {
32108:     nsBlockFrame::RecoverFloatsFor(aLine->mFirstChild, *mFloatManager);
    1:   }
    1: }
    1: 
    1: /**
    1:  * Everything done in this function is done O(N) times for each pass of
    1:  * reflow so it is O(N*M) where M is the number of incremental reflow
    1:  * passes.  That's bad.  Don't do stuff here.
    1:  *
    1:  * When this function is called, |aLine| has just been slid by |aDeltaY|
    1:  * and the purpose of RecoverStateFrom is to ensure that the
    1:  * nsBlockReflowState is in the same state that it would have been in
    1:  * had the line just been reflowed.
    1:  *
    1:  * Most of the state recovery that we have to do involves floats.
    1:  */
    1: void
    1: nsBlockReflowState::RecoverStateFrom(nsLineList::iterator aLine,
    1:                                      nscoord aDeltaY)
    1: {
    1:   // Make the line being recovered the current line
    1:   mCurrentLine = aLine;
    1: 
23305:   // Place floats for this line into the float manager
    1:   if (aLine->HasFloats() || aLine->IsBlock()) {
    1:     RecoverFloats(aLine, aDeltaY);
    1: 
    1: #ifdef DEBUG
23305:     if (nsBlockFrame::gNoisyReflow || nsBlockFrame::gNoisyFloatManager) {
23305:       mFloatManager->List(stdout);
    1:     }
    1: #endif
    1:   }
    1: }
    1: 
    1: // This is called by the line layout's AddFloat method when a
    1: // place-holder frame is reflowed in a line. If the float is a
    1: // left-most child (it's x coordinate is at the line's left margin)
    1: // then the float is place immediately, otherwise the float
    1: // placement is deferred until the line has been reflowed.
    1: 
    1: // XXXldb This behavior doesn't quite fit with CSS1 and CSS2 --
    1: // technically we're supposed let the current line flow around the
    1: // float as well unless it won't fit next to what we already have.
    1: // But nobody else implements it that way...
    1: PRBool
32108: nsBlockReflowState::AddFloat(nsLineLayout*       aLineLayout,
32107:                              nsIFrame*           aFloat,
48997:                              nscoord             aAvailableWidth)
    1: {
48991:   NS_PRECONDITION(aLineLayout, "must have line layout");
48991:   NS_PRECONDITION(mBlock->end_lines() != mCurrentLine, "null ptr");
32107:   NS_PRECONDITION(aFloat->GetStateBits() & NS_FRAME_OUT_OF_FLOW,
32107:                   "aFloat must be an out-of-flow frame");
    1: 
48992:   NS_ABORT_IF_FALSE(aFloat->GetParent(), "float must have parent");
48992:   NS_ABORT_IF_FALSE(aFloat->GetParent()->IsFrameOfType(nsIFrame::eBlockFrame),
48992:                     "float's parent must be block");
48992:   NS_ABORT_IF_FALSE(aFloat->GetParent() == mBlock ||
49010:                     (aFloat->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT),
48992:                     "float should be in this block unless it was marked as "
49010:                     "pushed float");
49010:   if (aFloat->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT) {
48992:     // If, in a previous reflow, the float was pushed entirely to
48992:     // another column/page, we need to steal it back.  (We might just
48992:     // push it again, though.)  Likewise, if that previous reflow
48992:     // reflowed this block but not its next continuation, we might need
48992:     // to steal it from our own float-continuations list.
48992:     nsBlockFrame *floatParent =
48992:       static_cast<nsBlockFrame*>(aFloat->GetParent());
48992:     floatParent->StealFrame(mPresContext, aFloat);
48992: 
49010:     aFloat->RemoveStateBits(NS_FRAME_IS_PUSHED_FLOAT);
48992: 
48992:     // Appending is fine, since if a float was pushed to the next
48992:     // page/column, all later floats were also pushed.
48992:     mBlock->mFloats.AppendFrame(mBlock, aFloat);
48992:   }
28636: 
    1:   // Because we are in the middle of reflowing a placeholder frame
    1:   // within a line (and possibly nested in an inline frame or two
    1:   // that's a child of our block) we need to restore the space
    1:   // manager's translation to the space that the block resides in
    1:   // before placing the float.
    1:   nscoord ox, oy;
23305:   mFloatManager->GetTranslation(ox, oy);
23305:   nscoord dx = ox - mFloatManagerX;
23305:   nscoord dy = oy - mFloatManagerY;
23305:   mFloatManager->Translate(-dx, -dy);
    1: 
27101:   PRBool placed;
27101: 
27101:   // Now place the float immediately if possible. Otherwise stash it
27101:   // away in mPendingFloats and place it later.
27101:   // If one or more floats has already been pushed to the next line,
27101:   // don't let this one go on the current line, since that would violate
27101:   // float ordering.
27106:   nsRect floatAvailableSpace = GetFloatAvailableSpace().mRect;
48991:   if (mBelowCurrentLineFloats.IsEmpty() &&
32108:       (aLineLayout->LineIsEmpty() ||
32108:        mBlock->ComputeFloatWidth(*this, floatAvailableSpace, aFloat)
48991:        <= aAvailableWidth)) {
    1:     // And then place it
48997:     placed = FlowAndPlaceFloat(aFloat);
48994:     if (placed) {
    1:       // Pass on updated available space to the current inline reflow engine
48978:       nsFlowAreaRect floatAvailSpace = GetFloatAvailableSpace(mY);
49569:       nsRect availSpace(nsPoint(floatAvailSpace.mRect.x, mY),
27106:                         floatAvailSpace.mRect.Size());
32108:       aLineLayout->UpdateBand(availSpace, aFloat);
    1:       // Record this float in the current-line list
32108:       mCurrentLineFloats.Append(mFloatCacheFreeList.Alloc(aFloat));
49001:     } else {
49001:       (*aLineLayout->GetLine())->SetHadFloatPushed();
32108:     }
    1:   }
    1:   else {
 2853:     // Always claim to be placed; we don't know whether we fit yet, so we
 2853:     // deal with this in PlaceBelowCurrentLineFloats
 2853:     placed = PR_TRUE;
    1:     // This float will be placed after the line is done (it is a
    1:     // below-current-line float).
32108:     mBelowCurrentLineFloats.Append(mFloatCacheFreeList.Alloc(aFloat));
    1:   }
27101: 
27101:   // Restore coordinate system
27101:   mFloatManager->Translate(dx, dy);
27101: 
    1:   return placed;
    1: }
    1: 
    1: PRBool
48979: nsBlockReflowState::CanPlaceFloat(nscoord aFloatWidth,
48978:                                   const nsFlowAreaRect& aFloatAvailableSpace)
    1: {
48979:   // A float fits at a given vertical position if there are no floats at
48979:   // its horizontal position (no matter what its width) or if its width
48979:   // fits in the space remaining after prior floats have been placed.
48979:   // FIXME: We should allow overflow by up to half a pixel here (bug 21193).
48979:   return !aFloatAvailableSpace.mHasFloats ||
48979:          aFloatAvailableSpace.mRect.width >= aFloatWidth;
    1: }
    1: 
48980: static nscoord
48980: FloatMarginWidth(const nsHTMLReflowState& aCBReflowState,
48980:                  nscoord aFloatAvailableWidth,
48980:                  nsIFrame *aFloat,
48980:                  const nsCSSOffsetState& aFloatOffsetState)
48980: {
48980:   return aFloat->ComputeSize(
48980:     aCBReflowState.rendContext,
48980:     nsSize(aCBReflowState.ComputedWidth(),
48980:            aCBReflowState.ComputedHeight()),
48980:     aFloatAvailableWidth,
48980:     nsSize(aFloatOffsetState.mComputedMargin.LeftRight(),
48980:            aFloatOffsetState.mComputedMargin.TopBottom()),
48980:     nsSize(aFloatOffsetState.mComputedBorderPadding.LeftRight() -
48980:              aFloatOffsetState.mComputedPadding.LeftRight(),
48980:            aFloatOffsetState.mComputedBorderPadding.TopBottom() -
48980:              aFloatOffsetState.mComputedPadding.TopBottom()),
48980:     nsSize(aFloatOffsetState.mComputedPadding.LeftRight(),
48980:            aFloatOffsetState.mComputedPadding.TopBottom()),
48980:     PR_TRUE).width +
48980:   aFloatOffsetState.mComputedMargin.LeftRight() +
48980:   aFloatOffsetState.mComputedBorderPadding.LeftRight();
48980: }
48980: 
    1: PRBool
48997: nsBlockReflowState::FlowAndPlaceFloat(nsIFrame* aFloat)
    1: {
    1:   // Save away the Y coordinate before placing the float. We will
    1:   // restore mY at the end after placing the float. This is
    1:   // necessary because any adjustments to mY during the float
    1:   // placement are for the float only, not for any non-floating
    1:   // content.
48983:   AutoRestore<nscoord> restoreY(mY);
48983:   // FIXME: Should give AutoRestore a getter for the value to avoid this.
48983:   const nscoord saveY = mY;
    1: 
    1:   // Grab the float's display information
32107:   const nsStyleDisplay* floatDisplay = aFloat->GetStyleDisplay();
    1: 
    1:   // The float's old region, so we can propagate damage.
32107:   nsRect oldRegion = nsFloatManager::GetRegionFor(aFloat);
    1: 
    1:   // Enforce CSS2 9.5.1 rule [2], i.e., make sure that a float isn't
    1:   // ``above'' another float that preceded it in the flow.
49569:   mY = NS_MAX(mFloatManager->GetLowestFloatTop(), mY);
    1: 
    1:   // See if the float should clear any preceding floats...
 2480:   // XXX We need to mark this float somehow so that it gets reflowed
 2480:   // when floats are inserted before it.
    1:   if (NS_STYLE_CLEAR_NONE != floatDisplay->mBreakType) {
    1:     // XXXldb Does this handle vertical margins correctly?
    1:     mY = ClearFloats(mY, floatDisplay->mBreakType);
    1:   }
    1:     // Get the band of available space
48978:   nsFlowAreaRect floatAvailableSpace = GetFloatAvailableSpace(mY);
48980:   nsRect adjustedAvailableSpace = mBlock->AdjustFloatAvailableSpace(*this,
48980:                                     floatAvailableSpace.mRect, aFloat);
    1: 
32107:   NS_ASSERTION(aFloat->GetParent() == mBlock,
    1:                "Float frame has wrong parent");
    1: 
48980:   nsCSSOffsetState offsets(aFloat, mReflowState.rendContext,
48980:                            mReflowState.ComputedWidth());
    1: 
48980:   nscoord floatMarginWidth = FloatMarginWidth(mReflowState,
48980:                                               adjustedAvailableSpace.width,
48980:                                               aFloat, offsets);
    1: 
    1:   // Find a place to place the float. The CSS2 spec doesn't want
    1:   // floats overlapping each other or sticking out of the containing
    1:   // block if possible (CSS2 spec section 9.5.1, see the rule list).
    1:   NS_ASSERTION((NS_STYLE_FLOAT_LEFT == floatDisplay->mFloats) ||
    1: 	       (NS_STYLE_FLOAT_RIGHT == floatDisplay->mFloats),
    1: 	       "invalid float type");
    1: 
    1:   // Can the float fit here?
    1:   PRBool keepFloatOnSameLine = PR_FALSE;
    1: 
48979:   for (;;) {
49003:     if (mReflowState.availableHeight != NS_UNCONSTRAINEDSIZE &&
49003:         floatAvailableSpace.mRect.height <= 0) {
    1:       // No space, nowhere to put anything.
48994:       PushFloatPastBreak(aFloat);
    1:       return PR_FALSE;
    1:     }
    1: 
48980:     if (CanPlaceFloat(floatMarginWidth, floatAvailableSpace)) {
48979:       // We found an appropriate place.
48979:       break;
48979:     }
48979: 
    1:     // Nope. try to advance to the next band.
    1:     if (NS_STYLE_DISPLAY_TABLE != floatDisplay->mDisplay ||
    1:           eCompatibility_NavQuirks != mPresContext->CompatibilityMode() ) {
    1: 
27106:       mY += floatAvailableSpace.mRect.height;
48980:       if (adjustedAvailableSpace.height != NS_UNCONSTRAINEDSIZE) {
48980:         adjustedAvailableSpace.height -= floatAvailableSpace.mRect.height;
48980:       }
48978:       floatAvailableSpace = GetFloatAvailableSpace(mY);
    1:     } else {
48980:       // This quirk matches the one in nsBlockFrame::AdjustFloatAvailableSpace
    1:       // IE handles float tables in a very special way
    1: 
    1:       // see if the previous float is also a table and has "align"
    1:       nsFloatCache* fc = mCurrentLineFloats.Head();
    1:       nsIFrame* prevFrame = nsnull;
    1:       while (fc) {
32107:         if (fc->mFloat == aFloat) {
    1:           break;
    1:         }
32107:         prevFrame = fc->mFloat;
    1:         fc = fc->Next();
    1:       }
    1:       
    1:       if(prevFrame) {
    1:         //get the frame type
    1:         if (nsGkAtoms::tableOuterFrame == prevFrame->GetType()) {
    1:           //see if it has "align="
    1:           // IE makes a difference between align and he float property
    1:           nsIContent* content = prevFrame->GetContent();
    1:           if (content) {
    1:             // we're interested only if previous frame is align=left
    1:             // IE messes things up when "right" (overlapping frames) 
    1:             if (content->AttrValueIs(kNameSpaceID_None, nsGkAtoms::align,
    1:                                      NS_LITERAL_STRING("left"), eIgnoreCase)) {
    1:               keepFloatOnSameLine = PR_TRUE;
    1:               // don't advance to next line (IE quirkie behaviour)
    1:               // it breaks rule CSS2/9.5.1/1, but what the hell
    1:               // since we cannot evangelize the world
    1:               break;
    1:             }
    1:           }
    1:         }
    1:       }
    1: 
    1:       // the table does not fit anymore in this line so advance to next band 
27106:       mY += floatAvailableSpace.mRect.height;
48980:       // To match nsBlockFrame::AdjustFloatAvailableSpace, we have to
48980:       // get a new width for the new band.
48978:       floatAvailableSpace = GetFloatAvailableSpace(mY);
48980:       adjustedAvailableSpace = mBlock->AdjustFloatAvailableSpace(*this,
48980:                                  floatAvailableSpace.mRect, aFloat);
48980:       floatMarginWidth = FloatMarginWidth(mReflowState,
48980:                                           adjustedAvailableSpace.width,
48980:                                           aFloat, offsets);
    1:     }
    1:   }
48980: 
    1:   // If the float is continued, it will get the same absolute x value as its prev-in-flow
    1: 
    1:   // We don't worry about the geometry of the prev in flow, let the continuation
    1:   // place and size itself as required.
    1: 
49569:   // Assign an x and y coordinate to the float.
    1:   nscoord floatX, floatY;
    1:   if (NS_STYLE_FLOAT_LEFT == floatDisplay->mFloats) {
27106:     floatX = floatAvailableSpace.mRect.x;
    1:   }
    1:   else {
    1:     if (!keepFloatOnSameLine) {
48980:       floatX = floatAvailableSpace.mRect.XMost() - floatMarginWidth;
    1:     } 
    1:     else {
    1:       // this is the IE quirk (see few lines above)
    1:       // the table is kept in the same line: don't let it overlap the
    1:       // previous float 
27106:       floatX = floatAvailableSpace.mRect.x;
    1:     }
    1:   }
    1:   // CSS2 spec, 9.5.1 rule [4]: "A floating box's outer top may not
    1:   // be higher than the top of its containing block."  (Since the
    1:   // containing block is the content edge of the block box, this
    1:   // means the margin edge of the float can't be higher than the
    1:   // content edge of the block that contains it.)
49569:   floatY = NS_MAX(mY, mContentArea.y);
    1: 
48980:   // Reflow the float after computing its vertical position so it knows
48980:   // where to break.
48980:   nsMargin floatMargin; // computed margin
48981:   PRBool pushedDown = mY != saveY;
48994:   nsReflowStatus reflowStatus;
48980:   mBlock->ReflowFloat(*this, adjustedAvailableSpace, aFloat,
48994:                       floatMargin, pushedDown, reflowStatus);
48980:   if (aFloat->GetPrevInFlow())
48980:     floatMargin.top = 0;
48994:   if (NS_FRAME_IS_NOT_COMPLETE(reflowStatus))
48980:     floatMargin.bottom = 0;
48980: 
48982:   // In the case that we're in columns and not splitting floats, we need
48982:   // to check here that the float's height fit, and if it didn't, bail.
48982:   // (This code is only for DISABLE_FLOAT_BREAKING_IN_COLUMNS .)
48994:   //
48994:   // Likewise, if none of the float fit, and it needs to be pushed in
48994:   // its entirety to the next page (NS_FRAME_IS_TRUNCATED), we need to
48994:   // do the same.
48994:   if ((mContentArea.height != NS_UNCONSTRAINEDSIZE &&
48982:        adjustedAvailableSpace.height == NS_UNCONSTRAINEDSIZE &&
48982:        (!mReflowState.mFlags.mIsTopOfPage || !IsAdjacentWithTop() ||
48982:         pushedDown) &&
48982:        aFloat->GetSize().height + floatMargin.TopBottom() >
49569:          mContentArea.YMost() - floatY) ||
48994:       NS_FRAME_IS_TRUNCATED(reflowStatus)) {
48994: 
48994:     PushFloatPastBreak(aFloat);
48982:     return PR_FALSE;
48982:   }
48982: 
 2480:   // Calculate the actual origin of the float frame's border rect
49569:   // relative to the parent block; the margin must be added in
 2480:   // to get the border rect
49569:   nsPoint origin(floatMargin.left + floatX,
49569:                  floatMargin.top + floatY);
    1: 
    1:   // If float is relatively positioned, factor that in as well
32107:   origin += aFloat->GetRelativeOffset(floatDisplay);
    1: 
    1:   // Position the float and make sure and views are properly
    1:   // positioned. We need to explicitly position its child views as
    1:   // well, since we're moving the float after flowing it.
32107:   aFloat->SetPosition(origin);
32107:   nsContainerFrame::PositionFrameView(aFloat);
32107:   nsContainerFrame::PositionChildViews(aFloat);
    1: 
    1:   // Update the float combined area state
32107:   nsRect combinedArea = aFloat->GetOverflowRect() + origin;
 2480: 
 2480:   // XXX Floats should really just get invalidated here if necessary
    1:   mFloatCombinedArea.UnionRect(combinedArea, mFloatCombinedArea);
    1: 
30321:   // Place the float in the float manager
30321:   // calculate region
32107:   nsRect region = nsFloatManager::CalculateRegionFor(aFloat, floatMargin);
30321:   // if the float split, then take up all of the vertical height
48994:   if (NS_FRAME_IS_NOT_COMPLETE(reflowStatus) &&
30321:       (NS_UNCONSTRAINEDSIZE != mContentArea.height)) {
32531:     region.height = NS_MAX(region.height, mContentArea.height - floatY);
30321:   }
30321:   nsresult rv =
49569:   mFloatManager->AddFloat(aFloat, region);
30321:   NS_ABORT_IF_FALSE(NS_SUCCEEDED(rv), "bad float placement");
30321:   // store region
32107:   rv = nsFloatManager::StoreRegionFor(aFloat, region);
30321:   NS_ABORT_IF_FALSE(NS_SUCCEEDED(rv), "float region storage failed");
30321: 
30321:   // If the float's dimensions have changed, note the damage in the
30321:   // float manager.
30321:   if (region != oldRegion) {
30321:     // XXXwaterson conservative: we could probably get away with noting
30321:     // less damage; e.g., if only height has changed, then only note the
30321:     // area into which the float has grown or from which the float has
30321:     // shrunk.
49569:     nscoord top = NS_MIN(region.y, oldRegion.y);
49569:     nscoord bottom = NS_MAX(region.YMost(), oldRegion.YMost());
30321:     mFloatManager->IncludeInDamage(top, bottom);
30321:   }
30321: 
50893:   if (!NS_FRAME_IS_FULLY_COMPLETE(reflowStatus)) {
48994:     mBlock->SplitFloat(*this, aFloat, reflowStatus);
48994:   }
48994: 
30321: #ifdef NOISY_FLOATMANAGER
30321:   nscoord tx, ty;
30321:   mFloatManager->GetTranslation(tx, ty);
30321:   nsFrame::ListTag(stdout, mBlock);
30321:   printf(": FlowAndPlaceFloat: AddFloat: txy=%d,%d (%d,%d) {%d,%d,%d,%d}\n",
30321:          tx, ty, mFloatManagerX, mFloatManagerY,
30321:          region.x, region.y, region.width, region.height);
30321: #endif
30321: 
    1: #ifdef DEBUG
    1:   if (nsBlockFrame::gNoisyReflow) {
32107:     nsRect r = aFloat->GetRect();
    1:     nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
    1:     printf("placed float: ");
32107:     nsFrame::ListTag(stdout, aFloat);
    1:     printf(" %d,%d,%d,%d\n", r.x, r.y, r.width, r.height);
    1:   }
    1: #endif
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
48994: void
48994: nsBlockReflowState::PushFloatPastBreak(nsIFrame *aFloat)
48994: {
48994:   // This ensures that we:
48994:   //  * don't try to place later but smaller floats (which CSS says
48994:   //    must have their tops below the top of this float)
48994:   //  * don't waste much time trying to reflow this float again until
48994:   //    after the break
48994:   if (aFloat->GetStyleDisplay()->mFloats == NS_STYLE_FLOAT_LEFT) {
48994:     mFloatManager->SetPushedLeftFloatPastBreak();
48994:   } else {
48994:     NS_ABORT_IF_FALSE(aFloat->GetStyleDisplay()->mFloats ==
48994:                         NS_STYLE_FLOAT_RIGHT,
48994:                       "unexpected float value");
48994:     mFloatManager->SetPushedRightFloatPastBreak();
48994:   }
48994: 
49010:   // Put the float on the pushed floats list, even though it
48994:   // isn't actually a continuation.
48994:   nsresult rv = mBlock->StealFrame(mPresContext, aFloat);
48994:   NS_ASSERTION(NS_SUCCEEDED(rv), "StealFrame should succeed");
49010:   AppendPushedFloat(aFloat);
48994: 
48994:   NS_FRAME_SET_OVERFLOW_INCOMPLETE(mReflowStatus);
48994: }
48994: 
    1: /**
    1:  * Place below-current-line floats.
    1:  */
48995: void
49001: nsBlockReflowState::PlaceBelowCurrentLineFloats(nsFloatCacheFreeList& aList,
49001:                                                 nsLineBox* aLine)
    1: {
    1:   nsFloatCache* fc = aList.Head();
    1:   while (fc) {
    1: #ifdef DEBUG
    1:     if (nsBlockFrame::gNoisyReflow) {
    1:       nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
    1:       printf("placing bcl float: ");
32107:       nsFrame::ListTag(stdout, fc->mFloat);
    1:       printf("\n");
    1:     }
    1: #endif
    1:     // Place the float
48997:     PRBool placed = FlowAndPlaceFloat(fc->mFloat);
48995:     nsFloatCache *next = fc->Next();
48994:     if (!placed) {
48995:       aList.Remove(fc);
48995:       delete fc;
49001:       aLine->SetHadFloatPushed();
    1:     }
48995:     fc = next;
    1:   }
    1: }
    1: 
    1: nscoord
10895: nsBlockReflowState::ClearFloats(nscoord aY, PRUint8 aBreakType,
48987:                                 nsIFrame *aReplacedBlock,
48987:                                 PRUint32 aFlags)
    1: {
    1: #ifdef DEBUG
    1:   if (nsBlockFrame::gNoisyReflow) {
    1:     nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
49569:     printf("clear floats: in: aY=%d\n", aY);
    1:   }
    1: #endif
    1: 
    1: #ifdef NOISY_FLOAT_CLEARING
    1:   printf("nsBlockReflowState::ClearFloats: aY=%d breakType=%d\n",
    1:          aY, aBreakType);
23305:   mFloatManager->List(stdout);
    1: #endif
    1:   
10895:   nscoord newY = aY;
10895: 
10895:   if (aBreakType != NS_STYLE_CLEAR_NONE) {
49569:     newY = mFloatManager->ClearFloats(newY, aBreakType, aFlags);
10895:   }
10895: 
14910:   if (aReplacedBlock) {
10895:     for (;;) {
48978:       nsFlowAreaRect floatAvailableSpace = GetFloatAvailableSpace(newY);
14910:       nsBlockFrame::ReplacedElementWidthToClear replacedWidth =
27106:         nsBlockFrame::WidthToClearPastFloats(*this, floatAvailableSpace.mRect,
27103:                                              aReplacedBlock);
27106:       if (!floatAvailableSpace.mHasFloats ||
49569:           NS_MAX(floatAvailableSpace.mRect.x - mContentArea.x,
49569:                  replacedWidth.marginLeft) +
14910:             replacedWidth.borderBoxWidth +
49569:             NS_MAX(mContentArea.XMost() - floatAvailableSpace.mRect.XMost(),
14910:                    replacedWidth.marginRight) <=
14324:           mContentArea.width) {
10895:         break;
10895:       }
10895:       // See the analogous code for inlines in nsBlockFrame::DoReflowInlineFrames
27106:       if (floatAvailableSpace.mRect.height > 0) {
10895:         // See if there's room in the next band.
27106:         newY += floatAvailableSpace.mRect.height;
10895:       } else {
10895:         if (mReflowState.availableHeight != NS_UNCONSTRAINEDSIZE) {
10895:           // Stop trying to clear here; we'll just get pushed to the
10895:           // next column or page and try again there.
10895:           break;
10895:         }
10895:         NS_NOTREACHED("avail space rect with zero height!");
10895:         newY += 1;
10895:       }
10895:     }
10895:   }
    1: 
    1: #ifdef DEBUG
    1:   if (nsBlockFrame::gNoisyReflow) {
    1:     nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
49569:     printf("clear floats: out: y=%d\n", newY);
    1:   }
    1: #endif
    1: 
    1:   return newY;
    1: }
    1: 
