    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Roland Mainz <roland.mainz@informatik.med.uni-giessen.de>
    1:  *   Benjamin Smedberg <benjamin@smedbergs.us>
    1:  *   Ben Goodger <ben@mozilla.org>
    1:  *   Fredrik Holmqvist <thesuckiestemail@yahoo.se>
    1:  *   Ben Turner <mozilla@songbirdnest.com>
    1:  *   Sergei Dolgov <sergei_d@fi.tartu.ee>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
 3706: #if defined(XP_OS2) && defined(MOZ_OS2_HIGH_MEMORY)
 3706: // os2safe.h has to be included before os2.h, needed for high mem
 3706: #include <os2safe.h>
 3706: #endif
    1: 
    1: #define XPCOM_TRANSLATE_NSGM_ENTRY_POINT 1
    1: 
    1: #include "nsAppRunner.h"
    1: #include "nsUpdateDriver.h"
    1: 
16759: #if defined(MOZ_WIDGET_QT)
16759: #include <qwidget.h>
16759: #include <qapplication.h>
16759: #endif
16759: 
    1: #ifdef XP_MACOSX
    1: #include "MacLaunchHelper.h"
    1: #include "MacApplicationDelegate.h"
    1: #endif
    1: 
    1: #ifdef XP_OS2
    1: #include "private/pprthred.h"
    1: #endif
    1: #include "prmem.h"
    1: #include "prnetdb.h"
    1: #include "prprf.h"
    1: #include "prproces.h"
    1: #include "prenv.h"
    1: 
    1: #include "nsIAppShellService.h"
    1: #include "nsIAppStartup.h"
    1: #include "nsIAppStartupNotifier.h"
    1: #include "nsIMutableArray.h"
    1: #include "nsICategoryManager.h"
    1: #include "nsIChromeRegistry.h"
    1: #include "nsICommandLineRunner.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsIComponentRegistrar.h"
    1: #include "nsIContentHandler.h"
    1: #include "nsIDialogParamBlock.h"
    1: #include "nsIDOMWindow.h"
    1: #include "nsIExtensionManager.h"
    1: #include "nsIFastLoadService.h" // for PLATFORM_FASL_SUFFIX
    1: #include "nsIGenericFactory.h"
 4738: #include "nsIIOService2.h"
    1: #include "nsIObserverService.h"
    1: #include "nsINativeAppSupport.h"
    1: #include "nsIProcess.h"
    1: #include "nsIProfileUnlocker.h"
    1: #include "nsIPromptService.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIStringBundle.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsITimelineService.h"
    1: #include "nsIToolkitChromeRegistry.h"
    1: #include "nsIToolkitProfile.h"
    1: #include "nsIToolkitProfileService.h"
    1: #include "nsIURI.h"
    1: #include "nsIWindowCreator.h"
    1: #include "nsIWindowMediator.h"
    1: #include "nsIWindowWatcher.h"
    1: #include "nsIXULAppInfo.h"
    1: #include "nsIXULRuntime.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIBaseWindow.h"
    1: #include "nsIWidget.h"
    1: #include "nsIDocShell.h"
    1: #include "nsAppShellCID.h"
    1: 
    1: #ifdef XP_WIN
    1: #include "nsIWinAppHelper.h"
30387: #include <windows.h>
30387: 
30387: #ifndef PROCESS_DEP_ENABLE
30387: #define PROCESS_DEP_ENABLE 0x1
30387: #endif
    1: #endif
    1: 
    1: #include "nsCRT.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsDirectoryServiceDefs.h"
    1: #include "nsDirectoryServiceUtils.h"
    1: #include "nsEmbedCID.h"
    1: #include "nsNetUtil.h"
 2962: #include "nsReadableUtils.h"
    1: #include "nsStaticComponents.h"
    1: #include "nsXPCOM.h"
23546: #include "nsXPCOMCIDInternal.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsXPFEComponentsCID.h"
    1: #include "nsVersionComparator.h"
    1: 
    1: #include "nsAppDirectoryServiceDefs.h"
    1: #include "nsXULAppAPI.h"
    1: #include "nsXREDirProvider.h"
    1: #include "nsToolkitCompsCID.h"
    1: 
    1: #include "nsINIParser.h"
    1: 
    1: #include <stdlib.h>
    1: 
29279: #if defined(MOZ_SPLASHSCREEN)
29279: #include "nsSplashScreen.h"
29279: #endif
29279: 
    1: #ifdef XP_UNIX
    1: #include <sys/stat.h>
    1: #include <unistd.h>
    1: #endif
    1: 
    1: #ifdef XP_BEOS
    1: // execv() behaves bit differently in R5 and Zeta, looks unreliable in such situation
    1: //#include <unistd.h>
    1: #include <AppKit.h>
    1: #include <AppFileInfo.h>
    1: #endif //XP_BEOS
    1: 
    1: #ifdef XP_WIN
22243: #ifndef WINCE
    1: #include <process.h>
    1: #include <shlobj.h>
22243: #endif
    1: #include "nsThreadUtils.h"
    1: #endif
    1: 
    1: #ifdef XP_MACOSX
    1: #include "nsILocalFileMac.h"
    1: #include "nsCommandLineServiceMac.h"
    1: #endif
    1: 
    1: // for X remote support
    1: #ifdef MOZ_ENABLE_XREMOTE
    1: #ifdef MOZ_WIDGET_PHOTON
    1: #include "PhRemoteClient.h"
    1: #else
    1: #include "XRemoteClient.h"
    1: #endif
    1: #include "nsIRemoteService.h"
    1: #endif
    1: 
    1: #ifdef NS_TRACE_MALLOC
    1: #include "nsTraceMalloc.h"
    1: #endif
    1: 
    1: #if defined(DEBUG) && defined(XP_WIN32)
    1: #include <malloc.h>
    1: #endif
    1: 
    1: #if defined (XP_MACOSX)
26366: #include <Carbon/Carbon.h>
    1: #endif
    1: 
    1: #ifdef DEBUG
    1: #include "prlog.h"
    1: #endif
    1: 
    1: #ifdef MOZ_JPROF
    1: #include "jprof.h"
    1: #endif
    1: 
 4389: #ifdef MOZ_CRASHREPORTER
 4389: #include "nsExceptionHandler.h"
  453: #include "nsICrashReporter.h"
  453: #define NS_CRASHREPORTER_CONTRACTID "@mozilla.org/toolkit/crash-reporter;1"
34844: #include "nsIPrefService.h"
    1: #endif
    1: 
31755: #ifdef WINCE
31755: class WindowsMutex {
31755: public:
31755:   WindowsMutex(const wchar_t *name) {
31755:     mHandle = CreateMutexW(0, FALSE, name);
31755:   }
31755: 
31755:   ~WindowsMutex() {
31755:     Unlock();
31755:     CloseHandle(mHandle);
31755:   }
31755: 
31755:   PRBool Lock(DWORD timeout = INFINITE) {
31755:     DWORD state = WaitForSingleObject(mHandle, timeout);
31755:     return state == WAIT_OBJECT_0;
31755:   }
31755:   
31755:   void Unlock() {
31755:     if (mHandle)
31755:       ReleaseMutex(mHandle);
31755:   }
31755: 
31755: protected:
31755:   HANDLE mHandle;
31755: };
31755: #endif
31755: 
36441: #if defined(XP_UNIX) || defined(XP_BEOS)
36441:   extern void InstallUnixSignalHandlers(const char *ProgramName);
36441: #endif
    1: 
33900: #define FILE_COMPATIBILITY_INFO NS_LITERAL_CSTRING("compatibility.ini")
33900: 
    1: int    gArgc;
    1: char **gArgv;
    1: 
 3041: static char gToolkitVersion[20];
 3041: static char gToolkitBuildID[40];
 3041: 
    1: static int    gRestartArgc;
    1: static char **gRestartArgv;
    1: 
  944: #if defined(MOZ_WIDGET_GTK2)
19744: #if defined(DEBUG) || defined(NS_BUILD_REFCNT_LOGGING) \
19744:   || defined(NS_TRACE_MALLOC)
19744: #define CLEANUP_MEMORY 1
19744: #define PANGO_ENABLE_BACKEND
19744: #include <pango/pangofc-fontmap.h>
19744: #endif
    1: #include <gtk/gtk.h>
16527: #ifdef MOZ_X11
 6618: #include <gdk/gdkx.h>
16527: #endif /* MOZ_X11 */
    1: #include "nsGTKToolkit.h"
    1: #endif
    1: 
 2962: // Save the given word to the specified environment variable.
 2962: static void
 2962: SaveWordToEnv(const char *name, const nsACString & word)
 2962: {
 2962:   char *expr = PR_smprintf("%s=%s", name, PromiseFlatCString(word).get());
 2962:   if (expr)
 2962:     PR_SetEnv(expr);
 2962:   // We intentionally leak |expr| here since it is required by PR_SetEnv.
 2962: }
 2962: 
    1: // Save the path of the given file to the specified environment variable.
    1: static void
    1: SaveFileToEnv(const char *name, nsIFile *file)
    1: {
 9738: #ifdef XP_WIN
 9738:   nsAutoString path;
 9738:   file->GetPath(path);
 9738:   SetEnvironmentVariableW(NS_ConvertASCIItoUTF16(name).get(), path.get());
 9738: #else
    1:   nsCAutoString path;
    1:   file->GetNativePath(path);
 2962:   SaveWordToEnv(name, path);
 9738: #endif
 9738: }
 9738: 
 9738: // Load the path of a file saved with SaveFileToEnv
 9738: static already_AddRefed<nsILocalFile>
 9738: GetFileFromEnv(const char *name)
 9738: {
 9738:   nsresult rv;
 9738:   nsILocalFile *file = nsnull;
 9738: 
 9738: #ifdef XP_WIN
 9738:   WCHAR path[_MAX_PATH];
 9738:   if (!GetEnvironmentVariableW(NS_ConvertASCIItoUTF16(name).get(),
 9738:                                path, _MAX_PATH))
 9738:     return nsnull;
 9738: 
 9738:   rv = NS_NewLocalFile(nsDependentString(path), PR_TRUE, &file);
 9738:   if (NS_FAILED(rv))
 9738:     return nsnull;
 9738: 
 9738:   return file;
 9738: #else
 9738:   const char *arg = PR_GetEnv(name);
 9738:   if (!arg || !*arg)
 9738:     return nsnull;
 9738: 
 9738:   rv = NS_NewNativeLocalFile(nsDependentCString(arg), PR_TRUE, &file);
 9738:   if (NS_FAILED(rv))
 9738:     return nsnull;
 9738: 
 9738:   return file;
 9738: #endif
 2962: }
 2962: 
 2962: // Save the path of the given word to the specified environment variable
 2962: // provided the environment variable does not have a value.
 2962: static void
 2962: SaveWordToEnvIfUnset(const char *name, const nsACString & word)
 2962: {
 2962:   const char *val = PR_GetEnv(name);
 2962:   if (!(val && *val))
 2962:     SaveWordToEnv(name, word);
    1: }
    1: 
    1: // Save the path of the given file to the specified environment variable
    1: // provided the environment variable does not have a value.
    1: static void
    1: SaveFileToEnvIfUnset(const char *name, nsIFile *file)
    1: {
    1:   const char *val = PR_GetEnv(name);
    1:   if (!(val && *val))
    1:     SaveFileToEnv(name, file);
    1: }
    1: 
    1: static PRBool
    1: strimatch(const char* lowerstr, const char* mixedstr)
    1: {
    1:   while(*lowerstr) {
    1:     if (!*mixedstr) return PR_FALSE; // mixedstr is shorter
    1:     if (tolower(*mixedstr) != *lowerstr) return PR_FALSE; // no match
    1: 
    1:     ++lowerstr;
    1:     ++mixedstr;
    1:   }
    1: 
    1:   if (*mixedstr) return PR_FALSE; // lowerstr is shorter
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: /**
    1:  * Output a string to the user.  This method is really only meant to be used to
    1:  * output last-ditch error messages designed for developers NOT END USERS.
    1:  *
    1:  * @param isError
    1:  *        Pass true to indicate severe errors.
    1:  * @param fmt
    1:  *        printf-style format string followed by arguments.
    1:  */
    1: static void Output(PRBool isError, const char *fmt, ... )
    1: {
    1:   va_list ap;
    1:   va_start(ap, fmt);
    1: 
    1: #if defined(XP_WIN) && !MOZ_WINCONSOLE
    1:   char *msg = PR_vsmprintf(fmt, ap);
    1:   if (msg)
    1:   {
    1:     UINT flags = MB_OK;
    1:     if (isError)
    1:       flags |= MB_ICONERROR;
    1:     else 
    1:       flags |= MB_ICONINFORMATION;
19738: 
19738:     wchar_t wide_msg[1024];
19738:     MultiByteToWideChar(CP_ACP,
19738:                         0,
19738:                         msg,
19738:                         -1,
19738:                         wide_msg,
19738:                         sizeof(wide_msg) / sizeof(wchar_t));
19738: 
19738:     MessageBoxW(NULL, wide_msg, L"XULRunner", flags);
    1:     PR_smprintf_free(msg);
    1:   }
    1: #else
    1:   vfprintf(stderr, fmt, ap);
    1: #endif
    1: 
    1:   va_end(ap);
    1: }
    1: 
 4817: enum RemoteResult {
 4817:   REMOTE_NOT_FOUND  = 0,
 4817:   REMOTE_FOUND      = 1,
 4817:   REMOTE_ARG_BAD    = 2
 4817: };
 4817: 
    1: enum ArgResult {
    1:   ARG_NONE  = 0,
    1:   ARG_FOUND = 1,
    1:   ARG_BAD   = 2 // you wanted a param, but there isn't one
    1: };
    1: 
    1: static void RemoveArg(char **argv)
    1: {
    1:   do {
    1:     *argv = *(argv + 1);
    1:     ++argv;
    1:   } while (*argv);
    1: 
    1:   --gArgc;
    1: }
    1: 
    1: /**
    1:  * Check for a commandline flag. If the flag takes a parameter, the
    1:  * parameter is returned in aParam. Flags may be in the form -arg or
    1:  * --arg (or /arg on win32/OS2).
    1:  *
    1:  * @param aArg the parameter to check. Must be lowercase.
 3321:  * @param aCheckOSInt if true returns ARG_BAD if the osint argument is present
 3321:  *        when aArg is also present.
    1:  * @param if non-null, the -arg <data> will be stored in this pointer. This is *not*
    1:  *        allocated, but rather a pointer to the argv data.
    1:  */
    1: static ArgResult
32011: CheckArg(const char* aArg, PRBool aCheckOSInt = PR_FALSE, const char **aParam = nsnull, PRBool aRemArg = PR_TRUE)
    1: {
    1:   char **curarg = gArgv + 1; // skip argv[0]
 3321:   ArgResult ar = ARG_NONE;
    1: 
    1:   while (*curarg) {
    1:     char *arg = curarg[0];
    1: 
    1:     if (arg[0] == '-'
    1: #if defined(XP_WIN) || defined(XP_OS2)
    1:         || *arg == '/'
    1: #endif
    1:         ) {
    1:       ++arg;
    1:       if (*arg == '-')
    1:         ++arg;
    1: 
    1:       if (strimatch(aArg, arg)) {
32011:         if (aRemArg)
    1:           RemoveArg(curarg);
    1:         if (!aParam) {
 3321:           ar = ARG_FOUND;
 3321:           break;
    1:         }
    1: 
    1:         if (*curarg) {
    1:           if (**curarg == '-'
    1: #if defined(XP_WIN) || defined(XP_OS2)
    1:               || **curarg == '/'
    1: #endif
    1:               )
    1:             return ARG_BAD;
    1: 
    1:           *aParam = *curarg;
32011:           if (aRemArg)
    1:             RemoveArg(curarg);
 3321:           ar = ARG_FOUND;
 3321:           break;
    1:         }
    1:         return ARG_BAD;
    1:       }
    1:     }
    1: 
    1:     ++curarg;
    1:   }
    1: 
 3321:   if (aCheckOSInt && ar == ARG_FOUND) {
 3321:     ArgResult arOSInt = CheckArg("osint");
 3321:     if (arOSInt == ARG_FOUND) {
 3321:       ar = ARG_BAD;
 3321:       PR_fprintf(PR_STDERR, "Error: argument -osint is invalid\n");
 3321:     }
 3321:   }
 3321: 
 3321:   return ar;
    1: }
    1: 
    1: #if defined(XP_WIN)
    1: /**
    1:  * Check for a commandline flag from the windows shell and remove it from the
    1:  * argv used when restarting. Flags MUST be in the form -arg.
    1:  *
    1:  * @param aArg the parameter to check. Must be lowercase.
    1:  */
    1: static ArgResult
    1: CheckArgShell(const char* aArg)
    1: {
    1:   char **curarg = gRestartArgv + 1; // skip argv[0]
    1: 
    1:   while (*curarg) {
    1:     char *arg = curarg[0];
    1: 
    1:     if (arg[0] == '-') {
    1:       ++arg;
    1: 
    1:       if (strimatch(aArg, arg)) {
    1:         do {
    1:           *curarg = *(curarg + 1);
    1:           ++curarg;
    1:         } while (*curarg);
    1: 
    1:         --gRestartArgc;
    1: 
    1:         return ARG_FOUND;
    1:       }
    1:     }
    1: 
    1:     ++curarg;
    1:   }
    1: 
    1:   return ARG_NONE;
    1: }
    1: 
    1: /**
15466:  * Enabled Native App Support to process DDE messages when the app needs to
15466:  * restart and the app has been launched by the Windows shell to open an url.
15466:  * When aWait is false this will process the DDE events manually. This prevents
15466:  * Windows from displaying an error message due to the DDE message not being
15466:  * acknowledged.
    1:  */
    1: static void
15466: ProcessDDE(nsINativeAppSupport* aNative, PRBool aWait)
    1: {
    1:   // When the app is launched by the windows shell the windows shell
    1:   // expects the app to be available for DDE messages and if it isn't
    1:   // windows displays an error dialog. To prevent the error the DDE server
    1:   // is enabled and pending events are processed when the app needs to
    1:   // restart after it was launched by the shell with the requestpending
    1:   // argument. The requestpending pending argument is removed to
    1:   // differentiate it from being launched when an app restart is not
    1:   // required.
    1:   ArgResult ar;
    1:   ar = CheckArgShell("requestpending");
    1:   if (ar == ARG_FOUND) {
    1:     aNative->Enable(); // enable win32 DDE responses
15466:     if (aWait) {
    1:       nsIThread *thread = NS_GetCurrentThread();
    1:       // This is just a guesstimate based on testing different values.
    1:       // If count is 8 or less windows will display an error dialog.
    1:       PRInt32 count = 20;
    1:       while(--count >= 0) {
    1:         NS_ProcessNextEvent(thread);
    1:         PR_Sleep(PR_MillisecondsToInterval(1));
    1:       }
    1:     }
    1:   }
15466: }
    1: #endif
    1: 
    1: PRBool gSafeMode = PR_FALSE;
    1: 
    1: /**
    1:  * The nsXULAppInfo object implements nsIFactory so that it can be its own
    1:  * singleton.
    1:  */
    1: class nsXULAppInfo : public nsIXULAppInfo,
    1: #ifdef XP_WIN
    1:                      public nsIWinAppHelper,
    1: #endif
 4389: #ifdef MOZ_CRASHREPORTER
  453:                      public nsICrashReporter,
  453: #endif
    1:                      public nsIXULRuntime
    1: 
    1: {
    1: public:
    1:   NS_DECL_ISUPPORTS_INHERITED
    1:   NS_DECL_NSIXULAPPINFO
    1:   NS_DECL_NSIXULRUNTIME
 4389: #ifdef MOZ_CRASHREPORTER
  453:   NS_DECL_NSICRASHREPORTER
  453: #endif
    1: #ifdef XP_WIN
    1:   NS_DECL_NSIWINAPPHELPER
    1: #endif
    1: };
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsXULAppInfo)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXULRuntime)
    1:   NS_INTERFACE_MAP_ENTRY(nsIXULRuntime)
    1: #ifdef XP_WIN
    1:   NS_INTERFACE_MAP_ENTRY(nsIWinAppHelper)
    1: #endif
 4389: #ifdef MOZ_CRASHREPORTER
  453:   NS_INTERFACE_MAP_ENTRY(nsICrashReporter)
  453: #endif
    1:   NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsIXULAppInfo, gAppData)
    1: NS_INTERFACE_MAP_END
    1: 
    1: NS_IMETHODIMP_(nsrefcnt)
    1: nsXULAppInfo::AddRef()
    1: {
    1:   return 1;
    1: }
    1: 
    1: NS_IMETHODIMP_(nsrefcnt)
    1: nsXULAppInfo::Release()
    1: {
    1:   return 1;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULAppInfo::GetVendor(nsACString& aResult)
    1: {
    1:   aResult.Assign(gAppData->vendor);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULAppInfo::GetName(nsACString& aResult)
    1: {
    1:   aResult.Assign(gAppData->name);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULAppInfo::GetID(nsACString& aResult)
    1: {
    1:   aResult.Assign(gAppData->ID);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULAppInfo::GetVersion(nsACString& aResult)
    1: {
    1:   aResult.Assign(gAppData->version);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULAppInfo::GetPlatformVersion(nsACString& aResult)
    1: {
 3676:   aResult.Assign(gToolkitVersion);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULAppInfo::GetAppBuildID(nsACString& aResult)
    1: {
    1:   aResult.Assign(gAppData->buildID);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULAppInfo::GetPlatformBuildID(nsACString& aResult)
    1: {
 3041:   aResult.Assign(gToolkitBuildID);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULAppInfo::GetLogConsoleErrors(PRBool *aResult)
    1: {
    1:   *aResult = gLogConsoleErrors;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULAppInfo::SetLogConsoleErrors(PRBool aValue)
    1: {
    1:   gLogConsoleErrors = aValue;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULAppInfo::GetInSafeMode(PRBool *aResult)
    1: {
    1:   *aResult = gSafeMode;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULAppInfo::GetOS(nsACString& aResult)
    1: {
    1:   aResult.AssignLiteral(OS_TARGET);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULAppInfo::GetXPCOMABI(nsACString& aResult)
    1: {
    1: #ifdef TARGET_XPCOM_ABI
    1:   aResult.AssignLiteral(TARGET_XPCOM_ABI);
    1:   return NS_OK;
    1: #else
    1:   return NS_ERROR_NOT_AVAILABLE;
    1: #endif
    1: }
    1: 
24526: NS_IMETHODIMP
24526: nsXULAppInfo::GetWidgetToolkit(nsACString& aResult)
24526: {
24526:   aResult.AssignLiteral(MOZ_WIDGET_TOOLKIT);
24526:   return NS_OK;
24526: }
24526: 
33900: NS_IMETHODIMP
33900: nsXULAppInfo::InvalidateCachesOnRestart()
33900: {
33900:   nsCOMPtr<nsIFile> file;
33900:   nsresult rv = NS_GetSpecialDirectory(NS_APP_PROFILE_DIR_STARTUP, 
33900:                                        getter_AddRefs(file));
33900:   if (NS_FAILED(rv))
33900:     return rv;
33900:   if (!file)
33900:     return NS_ERROR_NOT_AVAILABLE;
33900:   
33900:   file->AppendNative(FILE_COMPATIBILITY_INFO);
33900: 
33900:   nsCOMPtr<nsILocalFile> localFile(do_QueryInterface(file));
33900:   nsINIParser parser;
33900:   rv = parser.Init(localFile);
33900:   if (NS_FAILED(rv)) {
33900:     // This fails if compatibility.ini is not there, so we'll
33900:     // flush the caches on the next restart anyways.
33900:     return NS_OK;
33900:   }
33900:   
33900:   nsCAutoString buf;
33900:   rv = parser.GetString("Compatibility", "InvalidateCaches", buf);
33900:   
33900:   if (NS_FAILED(rv)) {
33900:     PRFileDesc *fd = nsnull;
33900:     localFile->OpenNSPRFileDesc(PR_RDWR | PR_APPEND, 0600, &fd);
33900:     if (!fd) {
33900:       NS_ERROR("could not create output stream");
33900:       return NS_ERROR_NOT_AVAILABLE;
33900:     }
33900:     static const char kInvalidationHeader[] = NS_LINEBREAK "InvalidateCaches=1" NS_LINEBREAK;
33900:     rv = PR_Write(fd, kInvalidationHeader, sizeof(kInvalidationHeader) - 1);
33900:     PR_Close(fd);
33900:     
33900:     if (NS_FAILED(rv))
33900:       return rv;
33900:   }
33900:   return NS_OK;
33900: }
33900: 
    1: #ifdef XP_WIN
 6144: // Matches the enum in WinNT.h for the Vista SDK but renamed so that we can
 6144: // safely build with the Vista SDK and without it.
 6144: typedef enum 
 6144: {
 6144:   VistaTokenElevationTypeDefault = 1,
 6144:   VistaTokenElevationTypeFull,
 6144:   VistaTokenElevationTypeLimited
 6144: } VISTA_TOKEN_ELEVATION_TYPE;
 6144: 
 6144: // avoid collision with TokeElevationType enum in WinNT.h
 6144: // of the Vista SDK
 6144: #define VistaTokenElevationType static_cast< TOKEN_INFORMATION_CLASS >( 18 )
 6144: 
 6144: NS_IMETHODIMP
 6144: nsXULAppInfo::GetUserCanElevate(PRBool *aUserCanElevate)
 6144: {
12606: #ifdef WINCE
12606:   *aUserCanElevate = PR_FALSE;
12606:   return NS_OK;
12606: #else
 6144:   HANDLE hToken;
 6144: 
 6144:   VISTA_TOKEN_ELEVATION_TYPE elevationType;
 6144:   DWORD dwSize; 
 6144: 
 6144:   if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken) ||
 6144:       !GetTokenInformation(hToken, VistaTokenElevationType, &elevationType,
 6144:                            sizeof(elevationType), &dwSize)) {
 6144:     *aUserCanElevate = PR_FALSE;
 6144:   } 
 6144:   else {
 6144:     // The possible values returned for elevationType and their meanings are:
 6144:     //   TokenElevationTypeDefault: The token does not have a linked token 
 6144:     //     (e.g. UAC disabled or a standard user, so they can't be elevated)
 6144:     //   TokenElevationTypeFull: The token is linked to an elevated token 
 6144:     //     (e.g. UAC is enabled and the user is already elevated so they can't
 6144:     //      be elevated again)
 6144:     //   TokenElevationTypeLimited: The token is linked to a limited token 
 6144:     //     (e.g. UAC is enabled and the user is not elevated, so they can be
 6144:     //	    elevated)
 6144:     *aUserCanElevate = (elevationType == VistaTokenElevationTypeLimited);
 6144:   }
 6144: 
 6144:   if (hToken)
 6144:     CloseHandle(hToken);
 6144: 
 6144:   return NS_OK;
12606: #endif // WINCE
 6144: }
    1: #endif
    1: 
 4389: #ifdef MOZ_CRASHREPORTER
  453: NS_IMETHODIMP
26867: nsXULAppInfo::GetEnabled(PRBool *aEnabled)
26867: {
26867:   *aEnabled = CrashReporter::GetEnabled();
26867:   return NS_OK;
26867: }
26867: 
26867: NS_IMETHODIMP
26867: nsXULAppInfo::SetEnabled(PRBool aEnabled)
26867: {
26867:   if (aEnabled) {
26867:     if (CrashReporter::GetEnabled())
26867:       // no point in erroring for double-enabling
26867:       return NS_OK;
26867: 
26867:     nsCOMPtr<nsILocalFile> xreDirectory;
26867:     if (gAppData) {
26867:       xreDirectory = gAppData->xreDirectory;
26867:     }
26867:     else {
26867:       // We didn't get started through XRE_Main, probably
26867:       nsCOMPtr<nsIFile> greDir;
26867:       NS_GetSpecialDirectory(NS_GRE_DIR, getter_AddRefs(greDir));
26867:       if (!greDir)
26867:         return NS_ERROR_FAILURE;
26867: 
26867:       xreDirectory = do_QueryInterface(greDir);
26867:       if (!xreDirectory)
26867:         return NS_ERROR_FAILURE;
26867:     }
26867:     return CrashReporter::SetExceptionHandler(xreDirectory, true);
26867:   }
26867:   else {
26867:     if (!CrashReporter::GetEnabled())
26867:       // no point in erroring for double-disabling
26867:       return NS_OK;
26867: 
26867:     return CrashReporter::UnsetExceptionHandler();
26867:   }
26867: }
26867: 
26867: NS_IMETHODIMP
26867: nsXULAppInfo::GetServerURL(nsIURL** aServerURL)
26867: {
26867:   if (!CrashReporter::GetEnabled())
26867:     return NS_ERROR_NOT_INITIALIZED;
26867: 
26867:   nsCAutoString data;
26867:   if (!CrashReporter::GetServerURL(data)) {
26867:     return NS_ERROR_FAILURE;
26867:   }
26867:   nsCOMPtr<nsIURI> uri;
26867:   NS_NewURI(getter_AddRefs(uri), data);
26867:   if (!uri)
26867:     return NS_ERROR_FAILURE;
26867: 
26867:   nsCOMPtr<nsIURL> url;
26867:   url = do_QueryInterface(uri);
26867:   NS_ADDREF(*aServerURL = url);
26867: 
26867:   return NS_OK;
26867: }
26867: 
26867: NS_IMETHODIMP
26867: nsXULAppInfo::SetServerURL(nsIURL* aServerURL)
26867: {
26867:   PRBool schemeOk;
26867:   // only allow https or http URLs
26867:   nsresult rv = aServerURL->SchemeIs("https", &schemeOk);
26867:   NS_ENSURE_SUCCESS(rv, rv);
26867:   if (!schemeOk) {
26867:     rv = aServerURL->SchemeIs("http", &schemeOk);
26867:     NS_ENSURE_SUCCESS(rv, rv);
26867: 
26867:     if (!schemeOk)
26867:       return NS_ERROR_INVALID_ARG;
26867:   }
26867:   nsCAutoString spec;
26867:   rv = aServerURL->GetSpec(spec);
26867:   NS_ENSURE_SUCCESS(rv, rv);
26867:   
26867:   return CrashReporter::SetServerURL(spec);
26867: }
26867: 
26867: NS_IMETHODIMP
26867: nsXULAppInfo::GetMinidumpPath(nsILocalFile** aMinidumpPath)
26867: {
26867:   if (!CrashReporter::GetEnabled())
26867:     return NS_ERROR_NOT_INITIALIZED;
26867: 
26867:   nsAutoString path;
26867:   if (!CrashReporter::GetMinidumpPath(path))
26867:     return NS_ERROR_FAILURE;
26867: 
26867:   nsresult rv = NS_NewLocalFile(path, PR_FALSE, aMinidumpPath);
26867:   NS_ENSURE_SUCCESS(rv, rv);
26867:   return NS_OK;
26867: }
26867: 
26867: NS_IMETHODIMP
26867: nsXULAppInfo::SetMinidumpPath(nsILocalFile* aMinidumpPath)
26867: {
26867:   nsAutoString path;
26867:   nsresult rv = aMinidumpPath->GetPath(path);
26867:   NS_ENSURE_SUCCESS(rv, rv);
26867:   return CrashReporter::SetMinidumpPath(path);
26867: }
26867: 
26867: NS_IMETHODIMP
  453: nsXULAppInfo::AnnotateCrashReport(const nsACString& key,
  453:                                   const nsACString& data)
  453: {
  453:   return CrashReporter::AnnotateCrashReport(key, data);
  453: }
11440: 
11440: NS_IMETHODIMP
16248: nsXULAppInfo::AppendAppNotesToCrashReport(const nsACString& data)
16248: {
16248:   return CrashReporter::AppendAppNotesToCrashReport(data);
16248: }
16248: 
16248: NS_IMETHODIMP
11440: nsXULAppInfo::WriteMinidumpForException(void* aExceptionInfo)
11440: {
11440: #ifdef XP_WIN32
11440:   return CrashReporter::WriteMinidumpForException(static_cast<EXCEPTION_POINTERS*>(aExceptionInfo));
11440: #else
11440:   return NS_ERROR_NOT_IMPLEMENTED;
11440: #endif
11440: }
  453: 
18492: NS_IMETHODIMP
18492: nsXULAppInfo::AppendObjCExceptionInfoToAppNotes(void* aException)
18492: {
18492: #ifdef XP_MACOSX
18492:   return CrashReporter::AppendObjCExceptionInfoToAppNotes(aException);
18492: #else
18492:   return NS_ERROR_NOT_IMPLEMENTED;
18492: #endif
18492: }
18494: #endif
18492: 
    1: static const nsXULAppInfo kAppInfo;
    1: static NS_METHOD AppInfoConstructor(nsISupports* aOuter,
    1:                                     REFNSIID aIID, void **aResult)
    1: {
    1:   NS_ENSURE_NO_AGGREGATION(aOuter);
    1: 
 3233:   return const_cast<nsXULAppInfo*>(&kAppInfo)->
    1:     QueryInterface(aIID, aResult);
    1: }
    1: 
    1: PRBool gLogConsoleErrors
    1: #ifdef DEBUG
    1:          = PR_TRUE;
    1: #else
    1:          = PR_FALSE;
    1: #endif
    1: 
    1: #define NS_ENSURE_TRUE_LOG(x, ret)               \
    1:   PR_BEGIN_MACRO                                 \
    1:   if (NS_UNLIKELY(!(x))) {                       \
    1:     NS_WARNING("NS_ENSURE_TRUE(" #x ") failed"); \
    1:     gLogConsoleErrors = PR_TRUE;                 \
    1:     return ret;                                  \
    1:   }                                              \
    1:   PR_END_MACRO
    1: 
    1: #define NS_ENSURE_SUCCESS_LOG(res, ret)          \
    1:   NS_ENSURE_TRUE_LOG(NS_SUCCEEDED(res), ret)
    1: 
    1: /**
    1:  * Because we're starting/stopping XPCOM several times in different scenarios,
    1:  * this class is a stack-based critter that makes sure that XPCOM is shut down
    1:  * during early returns.
    1:  */
    1: 
    1: class ScopedXPCOMStartup
    1: {
    1: public:
    1:   ScopedXPCOMStartup() :
    1:     mServiceManager(nsnull) { }
    1:   ~ScopedXPCOMStartup();
    1: 
    1:   nsresult Initialize();
    1:   nsresult DoAutoreg();
 4415:   nsresult RegisterProfileService();
    1:   nsresult SetWindowCreator(nsINativeAppSupport* native);
    1: 
    1: private:
    1:   nsIServiceManager* mServiceManager;
    1: };
    1: 
    1: ScopedXPCOMStartup::~ScopedXPCOMStartup()
    1: {
    1:   if (mServiceManager) {
 8897:     nsCOMPtr<nsIAppStartup> appStartup (do_GetService(NS_APPSTARTUP_CONTRACTID));
 8897:     if (appStartup)
 8897:       appStartup->DestroyHiddenWindow();
 8897: 
    1:     gDirServiceProvider->DoShutdown();
    1: 
    1:     WriteConsoleLog();
    1: 
    1:     NS_ShutdownXPCOM(mServiceManager);
    1:     mServiceManager = nsnull;
    1:   }
    1: }
    1: 
    1: // {95d89e3e-a169-41a3-8e56-719978e15b12}
    1: #define APPINFO_CID \
    1:   { 0x95d89e3e, 0xa169, 0x41a3, { 0x8e, 0x56, 0x71, 0x99, 0x78, 0xe1, 0x5b, 0x12 } }
    1: 
30669: static const nsModuleComponentInfo kComponents[] =
    1: {
    1:   {
    1:     "nsXULAppInfo",
    1:     APPINFO_CID,
    1:     XULAPPINFO_SERVICE_CONTRACTID,
    1:     AppInfoConstructor
23546:   },
23546:   {
23546:     "nsXULAppInfo",
23546:     APPINFO_CID,
23546:     XULRUNTIME_SERVICE_CONTRACTID,
23546:     AppInfoConstructor
    1:   }
 4389: #ifdef MOZ_CRASHREPORTER
  453: ,
  453:   {
  453:     "nsXULAppInfo",
  453:     APPINFO_CID,
  453:     NS_CRASHREPORTER_CONTRACTID,
  453:     AppInfoConstructor
  453:   }
  453: #endif
    1: };
    1: 
    1: NS_IMPL_NSGETMODULE(Apprunner, kComponents)
    1: 
    1: #if !defined(_BUILD_STATIC_BIN) && !defined(MOZ_ENABLE_LIBXUL)
    1: static nsStaticModuleInfo const kXREStaticModules[] =
    1: {
    1:   {
    1:     "Apprunner",
    1:     Apprunner_NSGetModule
    1:   }
    1: };
    1: 
    1: nsStaticModuleInfo const *const kPStaticModules = kXREStaticModules;
    1: PRUint32 const kStaticModuleCount = NS_ARRAY_LENGTH(kXREStaticModules);
    1: #endif
    1: 
    1: nsresult
    1: ScopedXPCOMStartup::Initialize()
    1: {
    1:   NS_ASSERTION(gDirServiceProvider, "Should not get here!");
    1: 
    1:   nsresult rv;
    1:   rv = NS_InitXPCOM3(&mServiceManager, gDirServiceProvider->GetAppDir(),
    1:                      gDirServiceProvider,
    1:                      kPStaticModules, kStaticModuleCount);
    1:   if (NS_FAILED(rv)) {
    1:     NS_ERROR("Couldn't start xpcom!");
    1:     mServiceManager = nsnull;
    1:   }
    1:   else {
    1:     nsCOMPtr<nsIComponentRegistrar> reg =
    1:       do_QueryInterface(mServiceManager);
    1:     NS_ASSERTION(reg, "Service Manager doesn't QI to Registrar.");
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: // {0C4A446C-EE82-41f2-8D04-D366D2C7A7D4}
    1: static const nsCID kNativeAppSupportCID =
    1:   { 0xc4a446c, 0xee82, 0x41f2, { 0x8d, 0x4, 0xd3, 0x66, 0xd2, 0xc7, 0xa7, 0xd4 } };
    1: 
    1: // {5F5E59CE-27BC-47eb-9D1F-B09CA9049836}
    1: static const nsCID kProfileServiceCID =
    1:   { 0x5f5e59ce, 0x27bc, 0x47eb, { 0x9d, 0x1f, 0xb0, 0x9c, 0xa9, 0x4, 0x98, 0x36 } };
    1: 
    1: nsresult
 4415: ScopedXPCOMStartup::RegisterProfileService()
    1: {
    1:   NS_ASSERTION(mServiceManager, "Not initialized!");
    1: 
 4415:   nsCOMPtr<nsIFactory> factory;
 4415:   NS_NewToolkitProfileFactory(getter_AddRefs(factory));
 4415:   if (!factory) return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   nsCOMPtr<nsIComponentRegistrar> reg (do_QueryInterface(mServiceManager));
    1:   if (!reg) return NS_ERROR_NO_INTERFACE;
    1: 
    1:   return reg->RegisterFactory(kProfileServiceCID,
    1:                               "Toolkit Profile Service",
    1:                               NS_PROFILESERVICE_CONTRACTID,
    1:                               factory);
    1: }
    1: 
    1: nsresult
    1: ScopedXPCOMStartup::DoAutoreg()
    1: {
    1: #ifdef DEBUG
    1:   // _Always_ autoreg if we're in a debug build, under the assumption
    1:   // that people are busily modifying components and will be angry if
    1:   // their changes aren't noticed.
    1:   nsCOMPtr<nsIComponentRegistrar> registrar
    1:     (do_QueryInterface(mServiceManager));
    1:   NS_ASSERTION(registrar, "Where's the component registrar?");
    1: 
    1:   registrar->AutoRegister(nsnull);
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /**
    1:  * This is a little factory class that serves as a singleton-service-factory
    1:  * for the nativeappsupport object.
    1:  */
    1: class nsSingletonFactory : public nsIFactory
    1: {
    1: public:
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSIFACTORY
    1: 
    1:   nsSingletonFactory(nsISupports* aSingleton);
    1:   ~nsSingletonFactory() { }
    1: 
    1: private:
    1:   nsCOMPtr<nsISupports> mSingleton;
    1: };
    1: 
    1: nsSingletonFactory::nsSingletonFactory(nsISupports* aSingleton)
    1:   : mSingleton(aSingleton)
    1: {
    1:   NS_ASSERTION(mSingleton, "Singleton was null!");
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS1(nsSingletonFactory, nsIFactory)
    1: 
    1: NS_IMETHODIMP
    1: nsSingletonFactory::CreateInstance(nsISupports* aOuter,
    1:                                    const nsIID& aIID,
    1:                                    void* *aResult)
    1: {
    1:   NS_ENSURE_NO_AGGREGATION(aOuter);
    1: 
    1:   return mSingleton->QueryInterface(aIID, aResult);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSingletonFactory::LockFactory(PRBool)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: /**
    1:  * Set our windowcreator on the WindowWatcher service.
    1:  */
    1: nsresult
    1: ScopedXPCOMStartup::SetWindowCreator(nsINativeAppSupport* native)
    1: {
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsIComponentRegistrar> registrar
    1:     (do_QueryInterface(mServiceManager));
    1:   NS_ASSERTION(registrar, "Where's the component registrar?");
    1: 
    1:   nsCOMPtr<nsIFactory> nativeFactory = new nsSingletonFactory(native);
    1:   NS_ENSURE_TRUE(nativeFactory, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   rv = registrar->RegisterFactory(kNativeAppSupportCID,
    1:                                   "Native App Support",
    1:                                   NS_NATIVEAPPSUPPORT_CONTRACTID,
    1:                                   nativeFactory);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Inform the chrome registry about OS accessibility
    1:   nsCOMPtr<nsIToolkitChromeRegistry> cr (do_GetService(NS_CHROMEREGISTRY_CONTRACTID));
    1:   if (cr)
    1:     cr->CheckForOSAccessibility();
    1: 
    1:   nsCOMPtr<nsIWindowCreator> creator (do_GetService(NS_APPSTARTUP_CONTRACTID));
    1:   if (!creator) return NS_ERROR_UNEXPECTED;
    1: 
    1:   nsCOMPtr<nsIWindowWatcher> wwatch
    1:     (do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return wwatch->SetWindowCreator(creator);
    1: }
    1: 
    1: /**
 4295:  * A helper class which calls NS_LogInit/NS_LogTerm in its scope.
    1:  */
    1: class ScopedLogging
    1: {
    1: public:
    1:   ScopedLogging() { NS_LogInit(); }
    1:   ~ScopedLogging() { NS_LogTerm(); }
    1: };
    1: 
    1: static void DumpArbitraryHelp()
    1: {
    1:   nsresult rv;
    1: 
    1:   ScopedLogging log;
    1: 
    1:   {
    1:     nsXREDirProvider dirProvider;
34542:     rv = dirProvider.Initialize(gAppData->directory, gAppData->xreDirectory);
34542:     if (NS_FAILED(rv))
34542:       return;
    1: 
    1:     ScopedXPCOMStartup xpcom;
    1:     xpcom.Initialize();
    1:     xpcom.DoAutoreg();
    1: 
    1:     nsCOMPtr<nsICommandLineRunner> cmdline
    1:       (do_CreateInstance("@mozilla.org/toolkit/command-line;1"));
    1:     if (!cmdline)
    1:       return;
    1: 
    1:     nsCString text;
    1:     rv = cmdline->GetHelpText(text);
    1:     if (NS_SUCCEEDED(rv))
    1:       printf("%s", text.get());
    1:   }
    1: }
    1: 
    1: // English text needs to go into a dtd file.
    1: // But when this is called we have no components etc. These strings must either be
    1: // here, or in a native resource file.
    1: static void
    1: DumpHelp()
    1: {
    1:   printf("Usage: %s [ options ... ] [URL]\n"
    1:          "       where options include:\n\n", gArgv[0]);
    1: 
    1: #ifdef MOZ_X11
    1:   printf("X11 options\n"
33705:          "  --display=DISPLAY  X display to use\n"
33705:          "  --sync             Make X calls synchronous\n"
33705:          "  --no-xshm          Don't use X shared memory extension\n"
33705:          "  --xim-preedit=STYLE\n"
33705:          "  --xim-status=STYLE\n");
    1: #endif
    1: #ifdef XP_UNIX
33705:   printf("  --g-fatal-warnings Make all warnings fatal\n"
18531:          "\n%s options\n", gAppData->name);
    1: #endif
    1: 
33705:   printf("  -h or -help        Print this message.\n"
33705:          "  -v or -version     Print %s version.\n"
33705:          "  -P <profile>       Start with <profile>.\n"
33705:          "  -migration         Start with migration wizard.\n"
33705:          "  -ProfileManager    Start with ProfileManager.\n"
33705:          "  -no-remote         Open new instance, not a new window in running instance.\n"
33705:          "  -UILocale <locale> Start with <locale> resources as UI Locale.\n"
33705:          "  -safe-mode         Disables extensions and themes for this session.\n", gAppData->name);
    1: 
    1: #if defined(XP_WIN) || defined(XP_OS2)
33705:   printf("  -console           Start %s with a debugging console.\n", gAppData->name);
    1: #endif
    1: 
    1:   // this works, but only after the components have registered.  so if you drop in a new command line handler, -help
    1:   // won't not until the second run.
    1:   // out of the bug, because we ship a component.reg file, it works correctly.
    1:   DumpArbitraryHelp();
    1: }
    1: 
    1: #ifdef DEBUG_warren
    1: #ifdef XP_WIN
    1: #define _CRTDBG_MAP_ALLOC
    1: #include <crtdbg.h>
    1: #endif
    1: #endif
    1: 
    1: #if defined(FREEBSD)
    1: // pick up fpsetmask prototype.
    1: #include <ieeefp.h>
    1: #endif
    1: 
    1: static inline void
    1: DumpVersion()
    1: {
 8479:   printf("%s %s %s", 
 8479:          gAppData->vendor ? gAppData->vendor : "", gAppData->name, gAppData->version);
 8479:   if (gAppData->copyright)
 8479:       printf(", %s", gAppData->copyright);
 8479:   printf("\n");
    1: }
    1: 
    1: #ifdef MOZ_ENABLE_XREMOTE
    1: // use int here instead of a PR type since it will be returned
    1: // from main - just to keep types consistent
    1: static int
    1: HandleRemoteArgument(const char* remote, const char* aDesktopStartupID)
    1: {
    1:   nsresult rv;
    1:   ArgResult ar;
    1: 
    1:   const char *profile = 0;
    1:   nsCAutoString program(gAppData->name);
    1:   ToLowerCase(program);
    1:   const char *username = getenv("LOGNAME");
    1: 
 3321:   ar = CheckArg("p", PR_FALSE, &profile);
    1:   if (ar == ARG_BAD) {
    1:     PR_fprintf(PR_STDERR, "Error: argument -p requires a profile name\n");
    1:     return 1;
    1:   }
    1: 
    1:   const char *temp = nsnull;
 3321:   ar = CheckArg("a", PR_FALSE, &temp);
    1:   if (ar == ARG_BAD) {
    1:     PR_fprintf(PR_STDERR, "Error: argument -a requires an application name\n");
    1:     return 1;
    1:   } else if (ar == ARG_FOUND) {
    1:     program.Assign(temp);
    1:   }
    1: 
 3321:   ar = CheckArg("u", PR_FALSE, &username);
    1:   if (ar == ARG_BAD) {
    1:     PR_fprintf(PR_STDERR, "Error: argument -u requires a username\n");
    1:     return 1;
    1:   }
    1: 
    1:   XRemoteClient client;
    1:   rv = client.Init();
    1:   if (NS_FAILED(rv)) {
    1:     PR_fprintf(PR_STDERR, "Error: Failed to connect to X server.\n");
    1:     return 1;
    1:   }
    1: 
    1:   nsXPIDLCString response;
    1:   PRBool success = PR_FALSE;
    1:   rv = client.SendCommand(program.get(), username, profile, remote,
    1:                           aDesktopStartupID, getter_Copies(response), &success);
    1:   // did the command fail?
    1:   if (NS_FAILED(rv)) {
    1:     PR_fprintf(PR_STDERR, "Error: Failed to send command: %s\n",
    1:                response ? response.get() : "No response included");
    1:     return 1;
    1:   }
    1: 
    1:   if (!success) {
    1:     PR_fprintf(PR_STDERR, "Error: No running window found\n");
    1:     return 2;
    1:   }
    1: 
    1:   return 0;
    1: }
    1: 
 4817: static RemoteResult
    1: RemoteCommandLine(const char* aDesktopStartupID)
    1: {
    1:   nsresult rv;
    1:   ArgResult ar;
    1: 
    1:   nsCAutoString program(gAppData->name);
    1:   ToLowerCase(program);
    1:   const char *username = getenv("LOGNAME");
    1: 
    1:   const char *temp = nsnull;
 3321:   ar = CheckArg("a", PR_TRUE, &temp);
    1:   if (ar == ARG_BAD) {
    1:     PR_fprintf(PR_STDERR, "Error: argument -a requires an application name\n");
 4817:     return REMOTE_ARG_BAD;
    1:   } else if (ar == ARG_FOUND) {
    1:     program.Assign(temp);
    1:   }
    1: 
 3321:   ar = CheckArg("u", PR_TRUE, &username);
    1:   if (ar == ARG_BAD) {
    1:     PR_fprintf(PR_STDERR, "Error: argument -u requires a username\n");
 4817:     return REMOTE_ARG_BAD;
    1:   }
    1: 
    1:   XRemoteClient client;
    1:   rv = client.Init();
    1:   if (NS_FAILED(rv))
 4817:     return REMOTE_NOT_FOUND;
    1:  
    1:   nsXPIDLCString response;
    1:   PRBool success = PR_FALSE;
    1:   rv = client.SendCommandLine(program.get(), username, nsnull,
    1:                               gArgc, gArgv, aDesktopStartupID,
    1:                               getter_Copies(response), &success);
    1:   // did the command fail?
    1:   if (NS_FAILED(rv) || !success)
 4817:     return REMOTE_NOT_FOUND;
 4817: 
 4817:   return REMOTE_FOUND;
    1: }
    1: #endif // MOZ_ENABLE_XREMOTE
    1: 
    1: #ifdef XP_MACOSX
    1: static char const *gBinaryPath;
    1: #endif
    1: 
    1: nsresult
    1: XRE_GetBinaryPath(const char* argv0, nsILocalFile* *aResult)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsILocalFile> lf;
    1: 
    1:   // We need to use platform-specific hackery to find the
    1:   // path of this executable. This is copied, with some modifications, from
    1:   // nsGREDirServiceProvider.cpp
    1: 
    1: #ifdef XP_WIN
 9738:   PRUnichar exePath[MAXPATHLEN];
 9738: 
 9738:   if (!::GetModuleFileNameW(0, exePath, MAXPATHLEN))
    1:     return NS_ERROR_FAILURE;
    1: 
 9738:   rv = NS_NewLocalFile(nsDependentString(exePath), PR_TRUE,
    1:                        getter_AddRefs(lf));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1: #elif defined(XP_MACOSX)
    1:   if (gBinaryPath)
    1:     return NS_NewNativeLocalFile(nsDependentCString(gBinaryPath), PR_FALSE,
    1:                                  aResult);
    1: 
    1:   NS_NewNativeLocalFile(EmptyCString(), PR_TRUE, getter_AddRefs(lf));
    1:   nsCOMPtr<nsILocalFileMac> lfm (do_QueryInterface(lf));
    1:   if (!lfm)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // Works even if we're not bundled.
    1:   CFBundleRef appBundle = CFBundleGetMainBundle();
    1:   if (!appBundle)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   CFURLRef bundleURL = CFBundleCopyExecutableURL(appBundle);
    1:   if (!bundleURL)
    1:     return NS_ERROR_FAILURE;
    1: 
34820:   FSRef fileRef;
34820:   if (!CFURLGetFSRef(bundleURL, &fileRef)) {
34820:     CFRelease(bundleURL);
34820:     return NS_ERROR_FAILURE;
34820:   }
34820: 
34820:   rv = lfm->InitWithFSRef(&fileRef);
    1:   CFRelease(bundleURL);
    1: 
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1: #elif defined(XP_UNIX)
    1:   struct stat fileStat;
    1:   char exePath[MAXPATHLEN];
    1:   char tmpPath[MAXPATHLEN];
    1: 
    1:   rv = NS_ERROR_FAILURE;
    1: 
    1:   // on unix, there is no official way to get the path of the current binary.
    1:   // instead of using the MOZILLA_FIVE_HOME hack, which doesn't scale to
    1:   // multiple applications, we will try a series of techniques:
    1:   //
    1:   // 1) look for /proc/<pid>/exe which is a symlink to the executable on newer
    1:   //    Linux kernels
    1:   // 2) use realpath() on argv[0], which works unless we're loaded from the
    1:   //    PATH
    1:   // 3) manually walk through the PATH and look for ourself
    1:   // 4) give up
    1: 
    1: // #ifdef __linux__
25453: // Commented out because it used to not work because it used to not deal
25453: // with readlink not null-terminating the buffer.
    1: #if 0
    1:   int r = readlink("/proc/self/exe", exePath, MAXPATHLEN);
    1: 
25453:   if (r > 0 && r < MAXPATHLEN) {
25453:     exePath[r] = '\0';
25453:     if (stat(exePath, &fileStat) == 0) {
    1:       rv = NS_OK;
    1:     }
25453:   }
    1: 
    1: #endif
    1:   if (NS_FAILED(rv) &&
    1:       realpath(argv0, exePath) && stat(exePath, &fileStat) == 0) {
    1:     rv = NS_OK;
    1:   }
    1: 
    1:   if (NS_FAILED(rv)) {
    1:     const char *path = getenv("PATH");
    1:     if (!path)
    1:       return NS_ERROR_FAILURE;
    1: 
    1:     char *pathdup = strdup(path);
    1:     if (!pathdup)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     PRBool found = PR_FALSE;
    1:     char *newStr = pathdup;
    1:     char *token;
    1:     while ( (token = nsCRT::strtok(newStr, ":", &newStr)) ) {
    1:       sprintf(tmpPath, "%s/%s", token, argv0);
    1:       if (realpath(tmpPath, exePath) && stat(exePath, &fileStat) == 0) {
    1:         found = PR_TRUE;
    1:         break;
    1:       }
    1:     }
    1:     free(pathdup);
    1:     if (!found)
    1:       return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   rv = NS_NewNativeLocalFile(nsDependentCString(exePath), PR_TRUE,
    1:                              getter_AddRefs(lf));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1: #elif defined(XP_OS2)
    1:   PPIB ppib;
    1:   PTIB ptib;
    1:   char exePath[MAXPATHLEN];
    1: 
    1:   DosGetInfoBlocks( &ptib, &ppib);
    1:   DosQueryModuleName( ppib->pib_hmte, MAXPATHLEN, exePath);
    1:   rv = NS_NewNativeLocalFile(nsDependentCString(exePath), PR_TRUE,
    1:                              getter_AddRefs(lf));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1: #elif defined(XP_BEOS)
    1:   int32 cookie = 0;
    1:   image_info info;
    1: 
    1:   if(get_next_image_info(0, &cookie, &info) != B_OK)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   rv = NS_NewNativeLocalFile(nsDependentCString(info.name), PR_TRUE,
    1:                              getter_AddRefs(lf));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
25127: #else
    1: #error Oops, you need platform-specific code here
    1: #endif
    1: 
    1:   NS_ADDREF(*aResult = lf);
    1:   return NS_OK;
    1: }
    1: 
    1: #define NS_ERROR_LAUNCHED_CHILD_PROCESS NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_PROFILE, 200)
    1: 
    1: #ifdef XP_WIN
    1: #include "nsWindowsRestart.cpp"
23244: #include <shellapi.h>
    1: #endif
    1: 
20303: #if defined(XP_OS2) && (__KLIBC__ == 0 && __KLIBC_MINOR__ >= 6) // broken kLibc
 3706: // Copy the environment maintained by the C library into an ASCIIZ array
 3706: // that can be used to pass it on to the OS/2 Dos* APIs (which otherwise
 3706: // don't know anything about the stuff set by PR_SetEnv() or setenv()).
 3706: char *createEnv()
 3706: {
 3706:   // just allocate the maximum amount (24 kB = 0x60000 bytes), to be able to
 3706:   // copy the existing environment
 3706:   char *env = (char *)calloc(0x6000, sizeof(char));
 3706:   if (!env) {
 3706:     return NULL;
 3706:   }
 3706: 
 3706:   // walk along the environ string array of the C library and copy
 3706:   // everything (that fits) into the output environment array, leaving
 3706:   // null bytes between the entries
 3706:   char *penv = env; // movable pointer to result environment ASCIIZ array
 3706:   int i = 0, space = 0x6000;
 3706:   while (environ[i] && environ[i][0]) {
 3706:     int len = strlen(environ[i]);
 3706:     if (space - len <= 0) {
 3706:       break;
 3706:     }
 3706:     strcpy(penv, environ[i]);
 3706:     i++; // next environment variable
 3706:     penv += len + 1; // jump to after next null byte
 3706:     space -= len - 1; // subtract consumed length from usable space
 3706:   }
 3706: 
 3706:   return env;
 3706: }
 3706: 
 3706: // OS2LaunchChild() is there to replace _execv() which is broken in the C
 3706: // runtime library that comes with GCC 3.3.5 on OS/2. It uses createEnv()
 3706: // to copy the process environment and add necessary variables
 3706: //
 3706: // returns -1 on failure and 0 on success
 3706: int OS2LaunchChild(const char *aExePath, int aArgc, char **aArgv)
 3706: {
 3706:   // find total length of aArgv
 3706:   int len = 0;
 3706:   for (int i = 0; i < aArgc; i++) {
 3706:     len += strlen(aArgv[i]) + 1; // plus space in between
 3706:   }
 3706:   len++; // leave space for null byte at end
 3706:   // allocate enough space for all strings and nulls,
 3706:   // calloc helpfully initializes to null
 3706:   char *args = (char *)calloc(len, sizeof(char));
 3706:   if (!args) {
 3706:     return -1;
 3706:   }
 3706:   char *pargs = args; // extra pointer to after the last argument
 3706:   // build argument list in the format the DosStartSession() wants,
 3706:   // adding spaces between the arguments
 3706:   for (int i = 0; i < aArgc; i++, *pargs++ = ' ') {
 3706:     strcpy(pargs, aArgv[i]);
 3706:     pargs += strlen(aArgv[i]);
 3706:   }
 3706:   if (aArgc > 1) {
 3706:     *(pargs-1) = '\0'; // replace last space
 3706:   }
 3706:   *pargs = '\0';
 3706:   // make sure that the program is separated by null byte
 3706:   pargs = strchr(args, ' ');
 3706:   if (pargs) {
 3706:     *pargs = '\0';
 3706:   }
 3706: 
 3706:   char *env = createEnv();
 3706: 
 3706:   char error[CCHMAXPATH] = { 0 };
 3706:   RESULTCODES crc = { 0 };
 3706:   ULONG rc = DosExecPgm(error, sizeof(error), EXEC_ASYNC, args, env,
 3706:                         &crc, (PSZ)aExePath);
 3706:   free(args); // done with the arguments
 3706:   if (env) {
 3706:     free(env);
 3706:   }
 3706:   if (rc != NO_ERROR) {
 3706:     return -1;
 3706:   }
 3706: 
 3706:   return 0;
 3706: }
 3706: #endif
 3706: 
    1: // If aBlankCommandLine is true, then the application will be launched with a
    1: // blank command line instead of being launched with the same command line that
    1: // it was initially started with.
    1: static nsresult LaunchChild(nsINativeAppSupport* aNative,
15484:                             PRBool aBlankCommandLine = PR_FALSE)
    1: {
    1:   aNative->Quit(); // release DDE mutex, if we're holding it
    1: 
    1:   // Restart this process by exec'ing it into the current process
    1:   // if supported by the platform.  Otherwise, use NSPR.
    1:  
    1:   if (aBlankCommandLine) {
 6903:     gRestartArgc = 1;
    1:     gRestartArgv[gRestartArgc] = nsnull;
    1:   }
    1: 
    1:   PR_SetEnv("MOZ_LAUNCHED_CHILD=1");
    1: 
    1: #if defined(XP_MACOSX)
22331:   SetupMacCommandLine(gRestartArgc, gRestartArgv);
    1:   LaunchChildMac(gRestartArgc, gRestartArgv);
    1: #else
    1:   nsCOMPtr<nsILocalFile> lf;
    1:   nsresult rv = XRE_GetBinaryPath(gArgv[0], getter_AddRefs(lf));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
 9738: #if defined(XP_WIN)
 9738:   nsAutoString exePath;
 9738:   rv = lf->GetPath(exePath);
 9738:   if (NS_FAILED(rv))
 9738:     return rv;
 9738: 
23244:   if (!WinLaunchChild(exePath.get(), gRestartArgc, gRestartArgv))
 9738:     return NS_ERROR_FAILURE;
 9738: 
 9738: #else
    1:   nsCAutoString exePath;
    1:   rv = lf->GetNativePath(exePath);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
20303: #if defined(XP_OS2) && (__KLIBC__ == 0 && __KLIBC_MINOR__ >= 6)
20303:   // implementation of _execv() is broken with kLibc 0.6.x and later
 3706:   if (OS2LaunchChild(exePath.get(), gRestartArgc, gRestartArgv) == -1)
 3706:     return NS_ERROR_FAILURE;
    1: #elif defined(XP_OS2)
    1:   if (_execv(exePath.get(), gRestartArgv) == -1)
    1:     return NS_ERROR_FAILURE;
    1: #elif defined(XP_UNIX)
    1:   if (execv(exePath.get(), gRestartArgv) == -1)
    1:     return NS_ERROR_FAILURE;
    1: #elif defined(XP_BEOS)
    1:   extern char **environ;
    1:   status_t res;
    1:   res = resume_thread(load_image(gRestartArgc,(const char **)gRestartArgv,(const char **)environ));
    1:   if (res != B_OK)
    1:     return NS_ERROR_FAILURE;
    1: #else
    1:   PRProcess* process = PR_CreateProcess(exePath.get(), gRestartArgv,
    1:                                         nsnull, nsnull);
    1:   if (!process) return NS_ERROR_FAILURE;
    1: 
    1:   PRInt32 exitCode;
    1:   PRStatus failed = PR_WaitProcess(process, &exitCode);
    1:   if (failed || exitCode)
    1:     return NS_ERROR_FAILURE;
 9738: #endif // XP_OS2 series
 9738: #endif // WP_WIN
 9738: #endif // WP_MACOSX
    1: 
    1:   return NS_ERROR_LAUNCHED_CHILD_PROCESS;
    1: }
    1: 
    1: static const char kProfileProperties[] =
    1:   "chrome://mozapps/locale/profile/profileSelection.properties";
    1: 
    1: static nsresult
    1: ProfileLockedDialog(nsILocalFile* aProfileDir, nsILocalFile* aProfileLocalDir,
    1:                     nsIProfileUnlocker* aUnlocker,
    1:                     nsINativeAppSupport* aNative, nsIProfileLock* *aResult)
    1: {
    1:   nsresult rv;
    1: 
    1:   ScopedXPCOMStartup xpcom;
    1:   rv = xpcom.Initialize();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = xpcom.DoAutoreg();
    1:   rv |= xpcom.SetWindowCreator(aNative);
    1:   NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
    1: 
    1:   { //extra scoping is needed so we release these components before xpcom shutdown
    1:     nsCOMPtr<nsIStringBundleService> sbs
    1:       (do_GetService(NS_STRINGBUNDLE_CONTRACTID));
    1:     NS_ENSURE_TRUE(sbs, NS_ERROR_FAILURE);
    1: 
    1:     nsCOMPtr<nsIStringBundle> sb;
    1:     sbs->CreateBundle(kProfileProperties, getter_AddRefs(sb));
    1:     NS_ENSURE_TRUE_LOG(sbs, NS_ERROR_FAILURE);
    1: 
    1:     NS_ConvertUTF8toUTF16 appName(gAppData->name);
    1:     const PRUnichar* params[] = {appName.get(), appName.get()};
    1: 
    1:     nsXPIDLString killMessage;
    1: #ifndef XP_MACOSX
    1:     static const PRUnichar kRestartNoUnlocker[] = {'r','e','s','t','a','r','t','M','e','s','s','a','g','e','N','o','U','n','l','o','c','k','e','r','\0'}; // "restartMessageNoUnlocker"
    1:     static const PRUnichar kRestartUnlocker[] = {'r','e','s','t','a','r','t','M','e','s','s','a','g','e','U','n','l','o','c','k','e','r','\0'}; // "restartMessageUnlocker"
    1: #else
    1:     static const PRUnichar kRestartNoUnlocker[] = {'r','e','s','t','a','r','t','M','e','s','s','a','g','e','N','o','U','n','l','o','c','k','e','r','M','a','c','\0'}; // "restartMessageNoUnlockerMac"
    1:     static const PRUnichar kRestartUnlocker[] = {'r','e','s','t','a','r','t','M','e','s','s','a','g','e','U','n','l','o','c','k','e','r','M','a','c','\0'}; // "restartMessageUnlockerMac"
    1: #endif
    1: 
    1:     sb->FormatStringFromName(aUnlocker ? kRestartUnlocker : kRestartNoUnlocker,
    1:                              params, 2, getter_Copies(killMessage));
    1: 
    1:     nsXPIDLString killTitle;
    1:     sb->FormatStringFromName(NS_LITERAL_STRING("restartTitle").get(),
    1:                              params, 1, getter_Copies(killTitle));
    1: 
    1:     if (!killMessage || !killTitle)
    1:       return NS_ERROR_FAILURE;
    1: 
    1:     nsCOMPtr<nsIPromptService> ps
    1:       (do_GetService(NS_PROMPTSERVICE_CONTRACTID));
    1:     NS_ENSURE_TRUE(ps, NS_ERROR_FAILURE);
    1: 
    1:     PRUint32 flags = nsIPromptService::BUTTON_TITLE_OK * nsIPromptService::BUTTON_POS_0;
    1: 
    1:     if (aUnlocker) {
    1:       flags =
    1:         nsIPromptService::BUTTON_TITLE_CANCEL * nsIPromptService::BUTTON_POS_0 +
    1:         nsIPromptService::BUTTON_TITLE_IS_STRING * nsIPromptService::BUTTON_POS_1 +
    1:         nsIPromptService::BUTTON_POS_1_DEFAULT;
    1:     }
    1: 
    1:     PRInt32 button;
29073:     PRBool checkState;
    1:     rv = ps->ConfirmEx(nsnull, killTitle, killMessage, flags,
29073:                        killTitle, nsnull, nsnull, nsnull, &checkState, &button);
    1:     NS_ENSURE_SUCCESS_LOG(rv, rv);
    1: 
    1:     if (button == 1 && aUnlocker) {
    1:       rv = aUnlocker->Unlock(nsIProfileUnlocker::FORCE_QUIT);
    1:       if (NS_FAILED(rv)) return rv;
    1: 
    1:       return NS_LockProfilePath(aProfileDir, aProfileLocalDir, nsnull, aResult);
    1:     }
    1: 
    1:     return NS_ERROR_ABORT;
    1:   }
    1: }
    1: 
    1: static const char kProfileManagerURL[] =
    1:   "chrome://mozapps/content/profile/profileSelection.xul";
    1: 
    1: static nsresult
    1: ShowProfileManager(nsIToolkitProfileService* aProfileSvc,
    1:                    nsINativeAppSupport* aNative)
    1: {
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsILocalFile> profD, profLD;
 2962:   PRUnichar* profileNamePtr;
 2962:   nsCAutoString profileName;
    1: 
    1:   {
    1:     ScopedXPCOMStartup xpcom;
    1:     rv = xpcom.Initialize();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
 4415:     rv = xpcom.DoAutoreg();
 4415:     rv |= xpcom.RegisterProfileService();
    1:     rv |= xpcom.SetWindowCreator(aNative);
    1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
    1: 
    1: #ifdef XP_MACOSX
    1:     SetupMacCommandLine(gRestartArgc, gRestartArgv);
    1: #endif
    1: 
    1: #ifdef XP_WIN
15466:     // we don't have to wait here because profile manager window will pump
15466:     // and DDE message will be handled
15466:     ProcessDDE(aNative, PR_FALSE);
    1: #endif
    1: 
    1:     { //extra scoping is needed so we release these components before xpcom shutdown
    1:       nsCOMPtr<nsIWindowWatcher> windowWatcher
    1:         (do_GetService(NS_WINDOWWATCHER_CONTRACTID));
    1:       nsCOMPtr<nsIDialogParamBlock> ioParamBlock
    1:         (do_CreateInstance(NS_DIALOGPARAMBLOCK_CONTRACTID));
    1:       nsCOMPtr<nsIMutableArray> dlgArray (do_CreateInstance(NS_ARRAY_CONTRACTID));
    1:       NS_ENSURE_TRUE(windowWatcher && ioParamBlock && dlgArray, NS_ERROR_FAILURE);
    1: 
    1:       ioParamBlock->SetObjects(dlgArray);
    1: 
    1:       nsCOMPtr<nsIAppStartup> appStartup
    1:         (do_GetService(NS_APPSTARTUP_CONTRACTID));
    1:       NS_ENSURE_TRUE(appStartup, NS_ERROR_FAILURE);
    1: 
    1:       nsCOMPtr<nsIDOMWindow> newWindow;
    1:       rv = windowWatcher->OpenWindow(nsnull,
    1:                                      kProfileManagerURL,
    1:                                      "_blank",
    1:                                      "centerscreen,chrome,modal,titlebar",
    1:                                      ioParamBlock,
    1:                                      getter_AddRefs(newWindow));
    1: 
    1:       NS_ENSURE_SUCCESS_LOG(rv, rv);
    1: 
    1:       aProfileSvc->Flush();
    1: 
    1:       PRInt32 dialogConfirmed;
    1:       rv = ioParamBlock->GetInt(0, &dialogConfirmed);
    1:       if (NS_FAILED(rv) || dialogConfirmed == 0) return NS_ERROR_ABORT;
    1: 
    1:       nsCOMPtr<nsIProfileLock> lock;
    1:       rv = dlgArray->QueryElementAt(0, NS_GET_IID(nsIProfileLock),
    1:                                     getter_AddRefs(lock));
    1:       NS_ENSURE_SUCCESS_LOG(rv, rv);
    1: 
    1:       rv = lock->GetDirectory(getter_AddRefs(profD));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       rv = lock->GetLocalDirectory(getter_AddRefs(profLD));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
 2962:       rv = ioParamBlock->GetString(0, &profileNamePtr);
 2962:       NS_ENSURE_SUCCESS(rv, rv);
 2962: 
 2962:       CopyUTF16toUTF8(profileNamePtr, profileName);
 2962:       NS_Free(profileNamePtr);
 2962: 
    1:       lock->Unlock();
    1:     }
    1:   }
    1: 
    1:   SaveFileToEnv("XRE_PROFILE_PATH", profD);
    1:   SaveFileToEnv("XRE_PROFILE_LOCAL_PATH", profLD);
 2962:   SaveWordToEnv("XRE_PROFILE_NAME", profileName);
    1: 
    1:   PRBool offline = PR_FALSE;
    1:   aProfileSvc->GetStartOffline(&offline);
    1:   if (offline) {
    1:     PR_SetEnv("XRE_START_OFFLINE=1");
    1:   }
    1: 
    1:   return LaunchChild(aNative);
    1: }
    1: 
    1: static nsresult
    1: ImportProfiles(nsIToolkitProfileService* aPService,
    1:                nsINativeAppSupport* aNative)
    1: {
    1:   nsresult rv;
    1: 
    1:   PR_SetEnv("XRE_IMPORT_PROFILES=1");
    1: 
    1:   // try to import old-style profiles
    1:   { // scope XPCOM
    1:     ScopedXPCOMStartup xpcom;
    1:     rv = xpcom.Initialize();
    1:     if (NS_SUCCEEDED(rv)) {
    1:       xpcom.DoAutoreg();
 4415:       xpcom.RegisterProfileService();
    1: 
    1: #ifdef XP_MACOSX
    1:       SetupMacCommandLine(gRestartArgc, gRestartArgv);
    1: #endif
    1: 
    1:       nsCOMPtr<nsIProfileMigrator> migrator
    1:         (do_GetService(NS_PROFILEMIGRATOR_CONTRACTID));
    1:       if (migrator) {
    1:         migrator->Import();
    1:       }
    1:     }
    1:   }
    1: 
    1:   aPService->Flush();
    1:   return LaunchChild(aNative);
    1: }
    1: 
    1: // Pick a profile. We need to end up with a profile lock.
    1: //
    1: // 1) check for -profile <path>
    1: // 2) check for -P <name>
    1: // 3) check for -ProfileManager
    1: // 4) use the default profile, if there is one
    1: // 5) if there are *no* profiles, set up profile-migration
    1: // 6) display the profile-manager UI
    1: 
    1: static PRBool gDoMigration = PR_FALSE;
    1: 
    1: static nsresult
    1: SelectProfile(nsIProfileLock* *aResult, nsINativeAppSupport* aNative,
 2962:               PRBool* aStartOffline, nsACString* aProfileName)
    1: {
    1:   nsresult rv;
    1:   ArgResult ar;
    1:   const char* arg;
    1:   *aResult = nsnull;
    1:   *aStartOffline = PR_FALSE;
    1: 
 3321:   ar = CheckArg("offline", PR_TRUE);
 3321:   if (ar == ARG_BAD) {
 3321:     PR_fprintf(PR_STDERR, "Error: argument -offline is invalid when argument -osint is specified\n");
 3321:     return NS_ERROR_FAILURE;
 3321:   }
 3321: 
    1:   arg = PR_GetEnv("XRE_START_OFFLINE");
 3321:   if ((arg && *arg) || ar)
    1:     *aStartOffline = PR_TRUE;
    1: 
 3321: 
 9738:   nsCOMPtr<nsILocalFile> lf = GetFileFromEnv("XRE_PROFILE_PATH");
 9738:   if (lf) {
 9738:     nsCOMPtr<nsILocalFile> localDir =
 9738:       GetFileFromEnv("XRE_PROFILE_LOCAL_PATH");
 9738:     if (!localDir) {
    1:       localDir = lf;
    1:     }
    1: 
 2962:     arg = PR_GetEnv("XRE_PROFILE_NAME");
 2962:     if (arg && *arg && aProfileName)
 2962:       aProfileName->Assign(nsDependentCString(arg));
 2962: 
    1:     // Clear out flags that we handled (or should have handled!) last startup.
    1:     const char *dummy;
 3321:     CheckArg("p", PR_FALSE, &dummy);
 3321:     CheckArg("profile", PR_FALSE, &dummy);
    1:     CheckArg("profilemanager");
    1: 
    1:     return NS_LockProfilePath(lf, localDir, nsnull, aResult);
    1:   }
    1: 
 3321:   ar = CheckArg("migration", PR_TRUE);
 3321:   if (ar == ARG_BAD) {
 3321:     PR_fprintf(PR_STDERR, "Error: argument -migration is invalid when argument -osint is specified\n");
 3321:     return NS_ERROR_FAILURE;
 3321:   } else if (ar == ARG_FOUND) {
    1:     gDoMigration = PR_TRUE;
 3321:   }
 3321: 
 3321:   ar = CheckArg("profile", PR_TRUE, &arg);
    1:   if (ar == ARG_BAD) {
    1:     PR_fprintf(PR_STDERR, "Error: argument -profile requires a path\n");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   if (ar) {
    1:     nsCOMPtr<nsILocalFile> lf;
    1:     rv = XRE_GetFileFromPath(arg, getter_AddRefs(lf));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsCOMPtr<nsIProfileUnlocker> unlocker;
    1: 
35415:     // Check if the profile path exists and it's a directory.
35415:     PRBool exists;
35415:     lf->Exists(&exists);
35415:     if (!exists) {
35415:         rv = lf->Create(nsIFile::DIRECTORY_TYPE, 0644);
35415:         NS_ENSURE_SUCCESS(rv, rv);
35415:     }
35415: 
    1:     // If a profile path is specified directory on the command line, then
    1:     // assume that the temp directory is the same as the given directory.
    1:     rv = NS_LockProfilePath(lf, lf, getter_AddRefs(unlocker), aResult);
    1:     if (NS_SUCCEEDED(rv))
    1:       return rv;
    1: 
    1:     return ProfileLockedDialog(lf, lf, unlocker, aNative, aResult);
    1:   }
    1: 
    1:   nsCOMPtr<nsIToolkitProfileService> profileSvc;
    1:   rv = NS_NewToolkitProfileService(getter_AddRefs(profileSvc));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 3321:   ar = CheckArg("createprofile", PR_TRUE, &arg);
    1:   if (ar == ARG_BAD) {
    1:     PR_fprintf(PR_STDERR, "Error: argument -createprofile requires a profile name\n");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   if (ar) {
    1:     nsCOMPtr<nsIToolkitProfile> profile;
    1: 
    1:     const char* delim = strchr(arg, ' ');
    1:     if (delim) {
    1:       nsCOMPtr<nsILocalFile> lf;
    1:       rv = NS_NewNativeLocalFile(nsDependentCString(delim + 1),
    1:                                    PR_TRUE, getter_AddRefs(lf));
    1:       if (NS_FAILED(rv)) {
    1:         PR_fprintf(PR_STDERR, "Error: profile path not valid.\n");
    1:         return rv;
    1:       }
    1:       
    1:       // As with -profile, assume that the given path will be used for both the
    1:       // main profile directory and the temp profile directory.
    1:       rv = profileSvc->CreateProfile(lf, lf, nsDependentCSubstring(arg, delim),
    1:                                      getter_AddRefs(profile));
    1:     } else {
    1:       rv = profileSvc->CreateProfile(nsnull, nsnull, nsDependentCString(arg),
    1:                                      getter_AddRefs(profile));
    1:     }
    1:     // Some pathological arguments can make it this far
    1:     if (NS_FAILED(rv)) {
    1:       PR_fprintf(PR_STDERR, "Error creating profile.\n");
    1:       return rv; 
    1:     }
    1:     rv = NS_ERROR_ABORT;  
    1:     profileSvc->Flush();
    1: 
    1:     // XXXben need to ensure prefs.js exists here so the tinderboxes will
    1:     //        not go orange.
    1:     nsCOMPtr<nsILocalFile> prefsJSFile;
    1:     profile->GetRootDir(getter_AddRefs(prefsJSFile));
    1:     prefsJSFile->AppendNative(NS_LITERAL_CSTRING("prefs.js"));
  826:     nsCAutoString pathStr;
  826:     prefsJSFile->GetNativePath(pathStr);
  826:     PR_fprintf(PR_STDERR, "Success: created profile '%s' at '%s'\n", arg, pathStr.get());
    1:     PRBool exists;
    1:     prefsJSFile->Exists(&exists);
    1:     if (!exists)
    1:       prefsJSFile->Create(nsIFile::NORMAL_FILE_TYPE, 0644);
    1:     // XXXdarin perhaps 0600 would be better?
    1: 
    1:     return rv;
    1:   }
    1: 
    1:   PRUint32 count;
    1:   rv = profileSvc->GetProfileCount(&count);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (gAppData->flags & NS_XRE_ENABLE_PROFILE_MIGRATOR) {
    1:     arg = PR_GetEnv("XRE_IMPORT_PROFILES");
    1:     if (!count && (!arg || !*arg)) {
    1:       return ImportProfiles(profileSvc, aNative);
    1:     }
    1:   }
    1: 
 3321:   ar = CheckArg("p", PR_FALSE, &arg);
    1:   if (ar == ARG_BAD) {
 3321:     ar = CheckArg("osint");
 3321:     if (ar == ARG_FOUND) {
 3321:       PR_fprintf(PR_STDERR, "Error: argument -p is invalid when argument -osint is specified\n");
 3321:       return NS_ERROR_FAILURE;
 3321:     }
    1:     return ShowProfileManager(profileSvc, aNative);
    1:   }
    1:   if (ar) {
 3321:     ar = CheckArg("osint");
 3321:     if (ar == ARG_FOUND) {
 3321:       PR_fprintf(PR_STDERR, "Error: argument -p is invalid when argument -osint is specified\n");
 3321:       return NS_ERROR_FAILURE;
 3321:     }
    1:     nsCOMPtr<nsIToolkitProfile> profile;
    1:     rv = profileSvc->GetProfileByName(nsDependentCString(arg),
    1:                                       getter_AddRefs(profile));
    1:     if (NS_SUCCEEDED(rv)) {
    1:       nsCOMPtr<nsIProfileUnlocker> unlocker;
    1:       rv = profile->Lock(nsnull, aResult);
 2962:       if (NS_SUCCEEDED(rv)) {
 2962:         if (aProfileName)
 2962:           aProfileName->Assign(nsDependentCString(arg));
    1:         return NS_OK;
 2962:       }
    1: 
    1:       nsCOMPtr<nsILocalFile> profileDir;
    1:       rv = profile->GetRootDir(getter_AddRefs(profileDir));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       nsCOMPtr<nsILocalFile> profileLocalDir;
    1:       rv = profile->GetLocalDir(getter_AddRefs(profileLocalDir));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       return ProfileLockedDialog(profileDir, profileLocalDir, unlocker,
    1:                                  aNative, aResult);
    1:     }
    1: 
    1:     return ShowProfileManager(profileSvc, aNative);
    1:   }
    1: 
 3321:   ar = CheckArg("profilemanager", PR_TRUE);
 3321:   if (ar == ARG_BAD) {
 3321:     PR_fprintf(PR_STDERR, "Error: argument -profilemanager is invalid when argument -osint is specified\n");
 3321:     return NS_ERROR_FAILURE;
 3321:   } else if (ar == ARG_FOUND) {
    1:     return ShowProfileManager(profileSvc, aNative);
    1:   }
    1: 
    1:   if (!count) {
    1:     gDoMigration = PR_TRUE;
    1: 
    1:     // create a default profile
    1:     nsCOMPtr<nsIToolkitProfile> profile;
    1:     nsresult rv = profileSvc->CreateProfile(nsnull, // choose a default dir for us
    1:                                             nsnull, // choose a default dir for us
    1:                                             NS_LITERAL_CSTRING("default"),
    1:                                             getter_AddRefs(profile));
    1:     if (NS_SUCCEEDED(rv)) {
    1:       profileSvc->Flush();
    1:       rv = profile->Lock(nsnull, aResult);
 2962:       if (NS_SUCCEEDED(rv)) {
 2962:         if (aProfileName)
 2962:           aProfileName->Assign(NS_LITERAL_CSTRING("default"));
    1:         return NS_OK;
    1:       }
    1:     }
 2962:   }
    1: 
    1:   PRBool useDefault = PR_TRUE;
    1:   if (count > 1)
    1:     profileSvc->GetStartWithLastProfile(&useDefault);
    1: 
    1:   if (useDefault) {
    1:     nsCOMPtr<nsIToolkitProfile> profile;
    1:     // GetSelectedProfile will auto-select the only profile if there's just one
    1:     profileSvc->GetSelectedProfile(getter_AddRefs(profile));
    1:     if (profile) {
    1:       nsCOMPtr<nsIProfileUnlocker> unlocker;
    1:       rv = profile->Lock(getter_AddRefs(unlocker), aResult);
 2962:       if (NS_SUCCEEDED(rv)) {
 2962:         // Try to grab the profile name.
 2962:         if (aProfileName) {
 2962:           rv = profile->GetName(*aProfileName);
 2962:           if (NS_FAILED(rv))
 2962:             aProfileName->Truncate(0);
 2962:         }
    1:         return NS_OK;
 2962:       }
    1: 
    1:       nsCOMPtr<nsILocalFile> profileDir;
    1:       rv = profile->GetRootDir(getter_AddRefs(profileDir));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       nsCOMPtr<nsILocalFile> profileLocalDir;
    1:       rv = profile->GetRootDir(getter_AddRefs(profileLocalDir));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       return ProfileLockedDialog(profileDir, profileLocalDir, unlocker,
    1:                                  aNative, aResult);
    1:     }
    1:   }
    1: 
    1:   return ShowProfileManager(profileSvc, aNative);
    1: }
    1: 
33900: /** 
33900:  * Checks the compatibility.ini file to see if we have updated our application
33900:  * or otherwise invalidated our caches. If the application has been updated, 
33900:  * we return PR_FALSE; otherwise, we return PR_TRUE. We also write the status 
33900:  * of the caches (valid/invalid) into the return param aCachesOK. The aCachesOK
33900:  * is always invalid if the application has been updated. 
33900:  */
    1: static PRBool
    1: CheckCompatibility(nsIFile* aProfileDir, const nsCString& aVersion,
    1:                    const nsCString& aOSABI, nsIFile* aXULRunnerDir,
33900:                    nsIFile* aAppDir, PRBool* aCachesOK)
    1: {
33900:   *aCachesOK = false;
    1:   nsCOMPtr<nsIFile> file;
    1:   aProfileDir->Clone(getter_AddRefs(file));
    1:   if (!file)
    1:     return PR_FALSE;
    1:   file->AppendNative(FILE_COMPATIBILITY_INFO);
    1: 
    1:   nsINIParser parser;
    1:   nsCOMPtr<nsILocalFile> localFile(do_QueryInterface(file));
    1:   nsresult rv = parser.Init(localFile);
    1:   if (NS_FAILED(rv))
    1:     return PR_FALSE;
    1: 
    1:   nsCAutoString buf;
    1:   rv = parser.GetString("Compatibility", "LastVersion", buf);
    1:   if (NS_FAILED(rv) || !aVersion.Equals(buf))
    1:     return PR_FALSE;
    1: 
    1:   rv = parser.GetString("Compatibility", "LastOSABI", buf);
    1:   if (NS_FAILED(rv) || !aOSABI.Equals(buf))
    1:     return PR_FALSE;
    1: 
    1:   rv = parser.GetString("Compatibility", "LastPlatformDir", buf);
    1:   if (NS_FAILED(rv))
    1:     return PR_FALSE;
    1: 
    1:   nsCOMPtr<nsILocalFile> lf;
    1:   rv = NS_NewNativeLocalFile(buf, PR_FALSE,
    1:                              getter_AddRefs(lf));
    1:   if (NS_FAILED(rv))
    1:     return PR_FALSE;
    1: 
    1:   PRBool eq;
    1:   rv = lf->Equals(aXULRunnerDir, &eq);
    1:   if (NS_FAILED(rv) || !eq)
    1:     return PR_FALSE;
    1: 
    1:   if (aAppDir) {
    1:     rv = parser.GetString("Compatibility", "LastAppDir", buf);
    1:     if (NS_FAILED(rv))
    1:       return PR_FALSE;
    1: 
    1:     rv = NS_NewNativeLocalFile(buf, PR_FALSE,
    1:                                getter_AddRefs(lf));
    1:     if (NS_FAILED(rv))
    1:       return PR_FALSE;
    1: 
    1:     rv = lf->Equals(aAppDir, &eq);
    1:     if (NS_FAILED(rv) || !eq)
    1:       return PR_FALSE;
    1:   }
    1: 
33900:   rv = parser.GetString("Compatibility", "InvalidateCaches", buf);
33900:   
33900:   // If we see this flag, caches are invalid.
33900:   *aCachesOK = (NS_FAILED(rv) || !buf.EqualsLiteral("1"));
    1:   return PR_TRUE;
    1: }
    1: 
    1: static void BuildVersion(nsCString &aBuf)
    1: {
    1:   aBuf.Assign(gAppData->version);
    1:   aBuf.Append('_');
    1:   aBuf.Append(gAppData->buildID);
    1:   aBuf.Append('/');
 3041:   aBuf.Append(gToolkitBuildID);
    1: }
    1: 
    1: static void
    1: WriteVersion(nsIFile* aProfileDir, const nsCString& aVersion,
    1:              const nsCString& aOSABI, nsIFile* aXULRunnerDir,
    1:              nsIFile* aAppDir)
    1: {
    1:   nsCOMPtr<nsIFile> file;
    1:   aProfileDir->Clone(getter_AddRefs(file));
    1:   if (!file)
    1:     return;
    1:   file->AppendNative(FILE_COMPATIBILITY_INFO);
    1: 
    1:   nsCOMPtr<nsILocalFile> lf = do_QueryInterface(file);
    1: 
    1:   nsCAutoString platformDir;
    1:   aXULRunnerDir->GetNativePath(platformDir);
    1: 
    1:   nsCAutoString appDir;
    1:   if (aAppDir)
    1:     aAppDir->GetNativePath(appDir);
    1: 
    1:   PRFileDesc *fd = nsnull;
    1:   lf->OpenNSPRFileDesc(PR_WRONLY | PR_CREATE_FILE | PR_TRUNCATE, 0600, &fd);
    1:   if (!fd) {
    1:     NS_ERROR("could not create output stream");
    1:     return;
    1:   }
    1: 
    1:   static const char kHeader[] = "[Compatibility]" NS_LINEBREAK
    1:                                 "LastVersion=";
    1: 
    1:   PR_Write(fd, kHeader, sizeof(kHeader) - 1);
    1:   PR_Write(fd, aVersion.get(), aVersion.Length());
    1: 
    1:   static const char kOSABIHeader[] = NS_LINEBREAK "LastOSABI=";
    1:   PR_Write(fd, kOSABIHeader, sizeof(kOSABIHeader) - 1);
    1:   PR_Write(fd, aOSABI.get(), aOSABI.Length());
    1: 
    1:   static const char kPlatformDirHeader[] = NS_LINEBREAK "LastPlatformDir=";
    1: 
    1:   PR_Write(fd, kPlatformDirHeader, sizeof(kPlatformDirHeader) - 1);
    1:   PR_Write(fd, platformDir.get(), platformDir.Length());
    1: 
    1:   static const char kAppDirHeader[] = NS_LINEBREAK "LastAppDir=";
    1:   if (aAppDir) {
    1:     PR_Write(fd, kAppDirHeader, sizeof(kAppDirHeader) - 1);
    1:     PR_Write(fd, appDir.get(), appDir.Length());
    1:   }
    1: 
    1:   static const char kNL[] = NS_LINEBREAK;
    1:   PR_Write(fd, kNL, sizeof(kNL) - 1);
    1: 
    1:   PR_Close(fd);
    1: }
    1: 
    1: static void RemoveComponentRegistries(nsIFile* aProfileDir, nsIFile* aLocalProfileDir,
    1:                                       PRBool aRemoveEMFiles)
    1: {
    1:   nsCOMPtr<nsIFile> file;
    1:   aProfileDir->Clone(getter_AddRefs(file));
    1:   if (!file)
    1:     return;
    1: 
    1:   file->AppendNative(NS_LITERAL_CSTRING("compreg.dat"));
    1:   file->Remove(PR_FALSE);
    1: 
    1:   file->SetNativeLeafName(NS_LITERAL_CSTRING("xpti.dat"));
    1:   file->Remove(PR_FALSE);
    1: 
    1:   file->SetNativeLeafName(NS_LITERAL_CSTRING(".autoreg"));
    1:   file->Remove(PR_FALSE);
    1: 
    1:   if (aRemoveEMFiles) {
    1:     file->SetNativeLeafName(NS_LITERAL_CSTRING("extensions.ini"));
    1:     file->Remove(PR_FALSE);
    1:   }
    1: 
    1:   aLocalProfileDir->Clone(getter_AddRefs(file));
    1:   if (!file)
    1:     return;
    1: 
    1:   file->AppendNative(NS_LITERAL_CSTRING("XUL" PLATFORM_FASL_SUFFIX));
    1:   file->Remove(PR_FALSE);
33900:   
33900:   file->SetNativeLeafName(NS_LITERAL_CSTRING("XPC" PLATFORM_FASL_SUFFIX));
33900:   file->Remove(PR_FALSE);
    1: }
    1: 
 6903: // To support application initiated restart via nsIAppStartup.quit, we
 6903: // need to save various environment variables, and then restore them
 6903: // before re-launching the application.
 6903: 
 6903: static struct {
 6903:   const char *name;
 6903:   char *value;
 6903: } gSavedVars[] = {
 6903:   {"XUL_APP_FILE", nsnull}
 6903: };
 6903: 
 6903: static void SaveStateForAppInitiatedRestart()
 6903: {
 6903:   for (size_t i = 0; i < NS_ARRAY_LENGTH(gSavedVars); ++i) {
 6903:     const char *s = PR_GetEnv(gSavedVars[i].name);
 6903:     if (s)
 6903:       gSavedVars[i].value = PR_smprintf("%s=%s", gSavedVars[i].name, s);
 6903:   }
 6903: }
 6903: 
 6903: static void RestoreStateForAppInitiatedRestart()
 6903: {
 6903:   for (size_t i = 0; i < NS_ARRAY_LENGTH(gSavedVars); ++i) {
 6903:     if (gSavedVars[i].value)
 6903:       PR_SetEnv(gSavedVars[i].value);
 6903:   }
 6903: }
 6903: 
 4389: #ifdef MOZ_CRASHREPORTER
 4389: // When we first initialize the crash reporter we don't have a profile,
    1: // so we set the minidump path to $TEMP.  Once we have a profile,
    1: // we set it to $PROFILE/minidumps, creating the directory
    1: // if needed.
    1: static void MakeOrSetMinidumpPath(nsIFile* profD)
    1: {
    1:   nsCOMPtr<nsIFile> dumpD;
    1:   nsresult rv = profD->Clone(getter_AddRefs(dumpD));
    1:   
    1:   if(dumpD) {
    1:     PRBool fileExists;
    1:     //XXX: do some more error checking here
    1:     dumpD->Append(NS_LITERAL_STRING("minidumps"));
    1:     rv = dumpD->Exists(&fileExists);
    1:     if(!fileExists) {
    1:       dumpD->Create(nsIFile::DIRECTORY_TYPE, 0700);
    1:     }
    1: 
    1:     nsAutoString pathStr;
    1:     if(NS_SUCCEEDED(dumpD->GetPath(pathStr)))
  155:       CrashReporter::SetMinidumpPath(pathStr);
    1:   }
    1: }
    1: #endif
    1: 
    1: const nsXREAppData* gAppData = nsnull;
    1: 
    1: #if defined(XP_OS2)
    1: // because we use early returns, we use a stack-based helper to un-set the OS2 FP handler
    1: class ScopedFPHandler {
    1: private:
    1:   EXCEPTIONREGISTRATIONRECORD excpreg;
    1: 
    1: public:
    1:   ScopedFPHandler() { PR_OS2_SetFloatExcpHandler(&excpreg); }
    1:   ~ScopedFPHandler() { PR_OS2_UnsetFloatExcpHandler(&excpreg); }
    1: };
    1: #endif
    1: 
    1: #ifdef MOZ_WIDGET_GTK2
    1: #include "prlink.h"
    1: typedef void (*_g_set_application_name_fn)(const gchar *application_name);
    1: typedef void (*_gtk_window_set_auto_startup_notification_fn)(gboolean setting);
    1: 
    1: static PRFuncPtr FindFunction(const char* aName)
    1: {
    1:   PRLibrary *lib = nsnull;
    1:   PRFuncPtr result = PR_FindFunctionSymbolAndLibrary(aName, &lib);
    1:   // Since the library was already loaded, we can safely unload it here.
    1:   if (lib) {
    1:     PR_UnloadLibrary(lib);
    1:   }
    1:   return result;
    1: }
    1: 
    1: static nsIWidget* GetMainWidget(nsIDOMWindow* aWindow)
    1: {
    1:   // get the native window for this instance
    1:   nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(aWindow));
    1:   NS_ENSURE_TRUE(window, nsnull);
    1: 
    1:   nsCOMPtr<nsIBaseWindow> baseWindow
    1:     (do_QueryInterface(window->GetDocShell()));
    1:   NS_ENSURE_TRUE(baseWindow, nsnull);
    1: 
    1:   nsCOMPtr<nsIWidget> mainWidget;
    1:   baseWindow->GetMainWidget(getter_AddRefs(mainWidget));
    1:   return mainWidget;
    1: }
    1: 
    1: static nsGTKToolkit* GetGTKToolkit()
    1: {
    1:   nsCOMPtr<nsIAppShellService> svc = do_GetService(NS_APPSHELLSERVICE_CONTRACTID);
    1:   if (!svc)
    1:     return nsnull;
    1:   nsCOMPtr<nsIDOMWindowInternal> window;
    1:   svc->GetHiddenDOMWindow(getter_AddRefs(window));
    1:   if (!window)
    1:     return nsnull;
    1:   nsIWidget* widget = GetMainWidget(window);
    1:   if (!widget)
    1:     return nsnull;
    1:   nsIToolkit* toolkit = widget->GetToolkit();
    1:   if (!toolkit)
    1:     return nsnull;
 3233:   return static_cast<nsGTKToolkit*>(toolkit);
    1: }
    1: 
 6618: static void MOZ_gdk_display_close(GdkDisplay *display)
 6618: {
14131:   // XXX wallpaper for bug 417163: don't close the Display if we're using the
14131:   // Qt theme because we crash (in Qt code) when using jemalloc.
14131:   PRBool theme_is_qt = PR_FALSE;
14131:   GtkSettings* settings =
14131:     gtk_settings_get_for_screen(gdk_display_get_default_screen(display));
14131:   gchar *theme_name;
14131:   g_object_get(settings, "gtk-theme-name", &theme_name, NULL);
14131:   if (theme_name) {
14131:     theme_is_qt = strcmp(theme_name, "Qt") == 0;
14131:     if (theme_is_qt)
14131:       NS_WARNING("wallpaper bug 417163 for Qt theme");
14131:     g_free(theme_name);
14131:   }
14131: 
 6618:   // gdk_display_close was broken prior to gtk+-2.10.0.
 6618:   // (http://bugzilla.gnome.org/show_bug.cgi?id=85715)
 6618:   // gdk_display_manager_set_default_display (gdk_display_manager_get(), NULL)
 6618:   // was also broken.
 6618:   if (gtk_check_version(2,10,0) != NULL) {
16527: #ifdef MOZ_X11
 6618:     // Version check failed - broken gdk_display_close.
 6618:     //
 6618:     // Let the gdk structures leak but at least close the Display,
 6618:     // assuming that gdk will not use it again.
 6618:     Display* dpy = GDK_DISPLAY_XDISPLAY(display);
14131:     if (!theme_is_qt)
 6618:       XCloseDisplay(dpy);
16527: #else
16527:     gdk_display_close(display);
16527: #endif /* MOZ_X11 */
 6618:   }
 6618:   else {
19744: #if CLEANUP_MEMORY
19744:     // Get a (new) Pango context that holds a reference to the fontmap that
19744:     // GTK has been using.  gdk_pango_context_get() must be called while GTK
19744:     // has a default display.
19744:     PangoContext *pangoContext = gdk_pango_context_get();
19744: #endif
19744: 
26700:     PRBool buggyCairoShutdown = cairo_version() < CAIRO_VERSION_ENCODE(1, 4, 0);
26700: 
26700:     if (!buggyCairoShutdown) {
26700:       // We should shut down GDK before we shut down libraries it depends on
26700:       // like Pango and cairo. But if cairo shutdown is buggy, we should
26700:       // shut down cairo first otherwise it may crash because of dangling
26700:       // references to Display objects (see bug 469831).
14131:       if (!theme_is_qt)
 6618:         gdk_display_close(display);
26700:     }
19744: 
19744: #if CLEANUP_MEMORY
19744:     // This doesn't take a reference.
19744:     PangoFontMap *fontmap = pango_context_get_font_map(pangoContext);
19744:     // Do some shutdown of the fontmap, which releases the fonts, clearing a
19744:     // bunch of circular references from the fontmap through the fonts back to
19744:     // itself.  The shutdown that this does is much less than what's done by
19744:     // the fontmap's finalize, though.
19744:     if (PANGO_IS_FC_FONT_MAP(fontmap))
19744:         pango_fc_font_map_shutdown(PANGO_FC_FONT_MAP(fontmap));
19744:     g_object_unref(pangoContext);
19744:     // PangoCairo still holds a reference to the fontmap.
19744:     // Now that we have finished with GTK and Pango, we could unref fontmap,
19744:     // which would allow us to call FcFini, but removing what is really
19744:     // Pango's ref feels a bit evil.  Pango-1.22 will have support for
19744:     // pango_cairo_font_map_set_default(NULL), which would release the
19744:     // reference on the old fontmap.
19744: 
19744: #if GTK_CHECK_VERSION(2,8,0)
19744:     // cairo_debug_reset_static_data() is prototyped through cairo.h included
19744:     // by gtk.h.
19744: #ifdef cairo_debug_reset_static_data
19744: #error "Looks like we're including Mozilla's cairo instead of system cairo"
19744: #endif
11579:     cairo_debug_reset_static_data();
19744: #endif // 2.8.0
19744: #endif // CLEANUP_MEMORY
26700: 
26700:     if (buggyCairoShutdown) {
26700:       if (!theme_is_qt)
26700:         gdk_display_close(display);
26700:     }
 6618:   }
 6618: }
 6618: #endif // MOZ_WIDGET_GTK2
    1: 
    1: /** 
    1:  * NSPR will search for the "nspr_use_zone_allocator" symbol throughout
    1:  * the process and use it to determine whether the application defines its own
    1:  * memory allocator or not.
    1:  *
    1:  * Since most applications (e.g. Firefox and Thunderbird) don't use any special
    1:  * allocators and therefore don't define this symbol, NSPR must search the
    1:  * entire process, which reduces startup performance.
    1:  *
    1:  * By defining the symbol here, we can avoid the wasted lookup and hopefully
    1:  * improve startup performance.
    1:  */
32483: NS_VISIBILITY_DEFAULT PRBool nspr_use_zone_allocator = PR_FALSE;
    1: 
29279: #ifdef MOZ_SPLASHSCREEN
29279: #define MOZ_SPLASHSCREEN_UPDATE(_i)  do { if (splashScreen) splashScreen->Update(_i); } while(0)
29279: #else
29279: #define MOZ_SPLASHSCREEN_UPDATE(_i)  do { } while(0)
29279: #endif
29279: 
30387: #ifdef XP_WIN
30387: typedef BOOL (WINAPI* SetProcessDEPPolicyFunc)(DWORD dwFlags);
30387: #endif
30387: 
    1: int
    1: XRE_main(int argc, char* argv[], const nsXREAppData* aAppData)
    1: {
29279: #ifdef MOZ_SPLASHSCREEN
31755:   nsSplashScreen *splashScreen = nsnull;
29279: #endif
29279: 
30387: #ifdef XP_WIN
30387:   /* On Windows XPSP3 and Windows Vista if DEP is configured off-by-default
30387:      we still want DEP protection: enable it explicitly and programmatically.
30387:      
30387:      This function is not available on WinXPSP2 so we dynamically load it.
30387:   */
30387: 
30387:   HMODULE kernel32 = GetModuleHandleW(L"kernel32.dll");
30387:   SetProcessDEPPolicyFunc _SetProcessDEPPolicy =
30387:     (SetProcessDEPPolicyFunc) GetProcAddress(kernel32, "SetProcessDEPPolicy");
30387:   if (_SetProcessDEPPolicy)
30387:     _SetProcessDEPPolicy(PROCESS_DEP_ENABLE);
30387: #endif
30387: 
    1:   nsresult rv;
 3321:   ArgResult ar;
    1:   NS_TIMELINE_MARK("enter main");
    1: 
    1: #ifdef DEBUG
    1:   if (PR_GetEnv("XRE_MAIN_BREAK"))
    1:     NS_BREAK();
    1: #endif
    1: 
12606: #if defined (XP_WIN32) && !defined (WINCE)
    1:   // Suppress the "DLL Foo could not be found" dialog, such that if dependent
    1:   // libraries (such as GDI+) are not preset, we gracefully fail to load those
    1:   // XPCOM components, instead of being ungraceful.
    1:   UINT realMode = SetErrorMode(0);
    1:   realMode |= SEM_FAILCRITICALERRORS;
    1:   // If XRE_NO_WINDOWS_CRASH_DIALOG is set, suppress displaying the "This
    1:   // application has crashed" dialog box.  This is mainly useful for
    1:   // automated testing environments, e.g. tinderbox, where there's no need
    1:   // for a dozen of the dialog boxes to litter the console
    1:   if (getenv("XRE_NO_WINDOWS_CRASH_DIALOG"))
    1:     realMode |= SEM_NOGPFAULTERRORBOX | SEM_NOOPENFILEERRORBOX;
    1: 
    1:   SetErrorMode(realMode);
    1: 
    1: #ifdef DEBUG
    1:   // Disable small heap allocator to get heapwalk() giving us
    1:   // accurate heap numbers. Win2k non-debug does not use small heap allocator.
    1:   // Win2k debug seems to be still using it.
    1:   // http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_crt__set_sbh_threshold.asp
    1:   _set_sbh_threshold(0);
    1: #endif
    1: #endif
    1: 
36441: #if defined(XP_UNIX) || defined(XP_BEOS)
36441:   InstallUnixSignalHandlers(argv[0]);
36441: #endif
    1: 
22807: #ifdef MOZ_ACCESSIBILITY_ATK
22807:   // Reset GTK_MODULES, strip atk-bridge if exists
22807:   // Mozilla will load libatk-bridge.so later if necessary
22807:   const char* gtkModules = PR_GetEnv("GTK_MODULES");
22807:   if (gtkModules && *gtkModules) {
22807:     nsCString gtkModulesStr(gtkModules);
22807:     gtkModulesStr.ReplaceSubstring("atk-bridge", "");
22807:     char* expr = PR_smprintf("GTK_MODULES=%s", gtkModulesStr.get());
22807:     if (expr)
22807:       PR_SetEnv(expr);
22807:     // We intentionally leak |expr| here since it is required by PR_SetEnv.
22807:   }
22992: 
22992:   // Suppress atk-bridge init at startup, it works after GNOME 2.24.2
22992:   PR_SetEnv("NO_AT_BRIDGE=1");
22807: #endif
22807: 
22243: #ifndef WINCE
    1:   // Unbuffer stdout, needed for tinderbox tests.
    1:   setbuf(stdout, 0);
22243: #endif
    1: 
    1: #if defined(FREEBSD)
    1:   // Disable all SIGFPE's on FreeBSD, as it has non-IEEE-conformant fp
    1:   // trap behavior that trips up on floating-point tests performed by
    1:   // the JS engine.  See bugzilla bug 9967 details.
    1:   fpsetmask(0);
    1: #endif
    1: 
    1:   gArgc = argc;
    1:   gArgv = argv;
    1: 
    1:   NS_ENSURE_TRUE(aAppData, 2);
    1: 
    1: #ifdef XP_MACOSX
    1:   // The xulrunner stub executable tricks CFBundleGetMainBundle on
    1:   // purpose into lying about the main bundle path. It will set
    1:   // XRE_BINARY_PATH to inform us of our real location.
    1:   gBinaryPath = getenv("XRE_BINARY_PATH");
    1: 
    1:   if (gBinaryPath && !*gBinaryPath)
    1:     gBinaryPath = nsnull;
    1: #endif
    1: 
 9468:   // Check for application.ini overrides
 9468:   const char* override = nsnull;
 9468:   ar = CheckArg("override", PR_TRUE, &override);
 9468:   if (ar == ARG_BAD) {
 9468:     Output(PR_TRUE, "Incorrect number of arguments passed to -override");
 9468:     return 1;
 9468:   }
 9468:   else if (ar == ARG_FOUND) {
 9468:     nsCOMPtr<nsILocalFile> overrideLF;
 9468:     rv = XRE_GetFileFromPath(override, getter_AddRefs(overrideLF));
 9468:     if (NS_FAILED(rv)) {
 9468:       Output(PR_TRUE, "Error: unrecognized override.ini path.\n");
 9468:       return 1;
 9468:     }
 9468: 
 9468:     nsXREAppData* overrideAppData = const_cast<nsXREAppData*>(aAppData);
 9468:     rv = XRE_ParseAppData(overrideLF, overrideAppData);
 9468:     if (NS_FAILED(rv)) {
 9468:       Output(PR_TRUE, "Couldn't read override.ini");
 9468:       return 1;
 9468:     }
 9468:   }
 9468: 
    1:   ScopedAppData appData(aAppData);
    1:   gAppData = &appData;
    1: 
    1:   // Check sanity and correctness of app data.
    1: 
    1:   if (!appData.name) {
    1:     Output(PR_TRUE, "Error: App:Name not specified in application.ini\n");
    1:     return 1;
    1:   }
    1:   if (!appData.buildID) {
    1:     Output(PR_TRUE, "Error: App:BuildID not specified in application.ini\n");
    1:     return 1;
    1:   }
    1: 
31755: #ifdef MOZ_SPLASHSCREEN
31755:   // check to see if we need to do a splash screen
31755:   PRBool wantsSplash = PR_TRUE;
32011:   PRBool isNoSplash = (CheckArg("nosplash", PR_FALSE, NULL, PR_FALSE) == ARG_FOUND);
32011:   PRBool isNoRemote = (CheckArg("no-remote", PR_FALSE, NULL, PR_FALSE) == ARG_FOUND);
31755: 
31755: #ifdef WINCE
31755:   // synchronize startup; if it looks like we're going to have to
31755:   // wait, then open up a splash screen
31755:   WindowsMutex winStartupMutex(L"FirefoxStartupMutex");
31755: 
31755:   // try to lock the mutex, but only wait 100ms to do so
31755:   PRBool needsMutexLock = ! winStartupMutex.Lock(100);
31755: 
31755:   // If we failed to lock the mutex quickly, then we'll want
31755:   // a splash screen for sure.
31755:   //
31755:   // If we did manage to lock it, then we'll only want one
31755:   // a splash screen if there is no existing message window;
31755:   // that is, if we are the first instance of the app.
31755:   if (!needsMutexLock && !isNoRemote) {
31755:     // check to see if there's a remote firefox up
31755:     static PRUnichar classNameBuffer[128];
31755:     _snwprintf(classNameBuffer, sizeof(classNameBuffer) / sizeof(PRUnichar),
31755:                L"%S%s",
31755:                gAppData->name, L"MessageWindow");
31755:     HANDLE h = FindWindowW(classNameBuffer, 0);
31755:     if (h) {
31755:       // Someone else has the window, and we were able to grab the mutex,
31755:       // meaning the other instance ahs presumably already finished starting
31755:       // up by now.  So no need for a splash screen.
31755:       wantsSplash = PR_FALSE;
31755:       CloseHandle(h);
31755:     } else {
31755:       // We couldn't find another window, and we were able to lock the mutex;
31755:       // we're likely the first instance starting up, so make sure a splash
31755:       // screen gets thrown up.
31755:       wantsSplash = PR_TRUE;
31755:     }
31755:   }
32013: #endif //WINCE
31755: 
31755:   if (wantsSplash && !isNoSplash)
31755:     splashScreen = nsSplashScreen::GetOrCreate();
31755: 
31755:   if (splashScreen)
31755:     splashScreen->Open();
31755: 
31755: #ifdef WINCE
31755:   // Now that the splash screen is open, wait indefinitely
31755:   // for the startup mutex on this thread if we need to.
31755:   if (needsMutexLock)
31755:     winStartupMutex.Lock();
32013: #endif //WINCE
32013: 
32013: #endif //MOZ_SPLASHSCREEN
31755: 
31755: 
 3041:   ScopedLogging log;
 3041: 
 3041:   if (!appData.xreDirectory) {
 3041:     nsCOMPtr<nsILocalFile> lf;
 3041:     rv = XRE_GetBinaryPath(gArgv[0], getter_AddRefs(lf));
 3041:     if (NS_FAILED(rv))
 3041:       return 2;
 3041: 
 3041:     nsCOMPtr<nsIFile> greDir;
 3041:     rv = lf->GetParent(getter_AddRefs(greDir));
 3041:     if (NS_FAILED(rv))
 3041:       return 2;
 3041:     
 3041:     rv = CallQueryInterface(greDir, &appData.xreDirectory);
 3041:     if (NS_FAILED(rv))
 3041:       return 2;
 3041:   }
 3041: 
 3041:   nsCOMPtr<nsIFile> iniFile;
 3041:   rv = appData.xreDirectory->Clone(getter_AddRefs(iniFile));
 3041:   if (NS_FAILED(rv))
 3041:     return 2;
 3041: 
 3041:   iniFile->AppendNative(NS_LITERAL_CSTRING("platform.ini"));
 3041: 
 3041:   nsCOMPtr<nsILocalFile> localIniFile = do_QueryInterface(iniFile);
 3041:   if (!localIniFile)
 3041:     return 2;
 3041: 
 3041:   nsINIParser parser;
 3041:   rv = parser.Init(localIniFile);
 3041:   if (NS_SUCCEEDED(rv)) {
 3041:     rv = parser.GetString("Build", "Milestone",
 3041:                           gToolkitVersion, sizeof(gToolkitVersion));
 3041:     NS_ASSERTION(NS_SUCCEEDED(rv), "Failed to get toolkit version");
 3041: 
 3041:     rv = parser.GetString("Build", "BuildID",
 3041:                           gToolkitBuildID, sizeof(gToolkitBuildID));
 3041:     NS_ASSERTION(NS_SUCCEEDED(rv), "Failed to get toolkit buildid");
 3041:   }
 3041:   else {
 3041:     NS_ERROR("Couldn't parse platform.ini!");
 3041:   }
 3041: 
 2806:   if (appData.size > offsetof(nsXREAppData, minVersion)) {
 2806:     if (!appData.minVersion) {
 2806:       Output(PR_TRUE, "Error: Gecko:MinVersion not specified in application.ini\n");
 2806:       return 1;
 2806:     }
 2806: 
 2806:     if (!appData.maxVersion) {
 2806:       // If no maxVersion is specified, we assume the app is only compatible
 2806:       // with the initial preview release. Do not increment this number ever!
 2806:       SetAllocatedString(appData.maxVersion, "1.*");
 2806:     }
 2806: 
 3041:     if (NS_CompareVersions(appData.minVersion, gToolkitVersion) > 0 ||
 3041:         NS_CompareVersions(appData.maxVersion, gToolkitVersion) < 0) {
 3041:       Output(PR_TRUE, "Error: Platform version '%s' is not compatible with\n"
 2806:              "minVersion >= %s\nmaxVersion <= %s\n",
 3041:              gToolkitVersion,
 2806:              appData.minVersion, appData.maxVersion);
 2806:       return 1;
 2806:     }
 2806:   }
 2806: 
 4389: #ifdef MOZ_CRASHREPORTER
 4389:   const char* crashreporterEnv = PR_GetEnv("MOZ_CRASHREPORTER");
 4389:   if (crashreporterEnv && *crashreporterEnv) {
 1715:     appData.flags |= NS_XRE_ENABLE_CRASH_REPORTER;
 1715:   }
 1715: 
 1715:   if ((appData.flags & NS_XRE_ENABLE_CRASH_REPORTER) &&
 1715:       NS_SUCCEEDED(
26867:          CrashReporter::SetExceptionHandler(appData.xreDirectory))) {
33294:     if (appData.crashReporterURL)
26867:       CrashReporter::SetServerURL(nsDependentCString(appData.crashReporterURL));
33294: 
 1715:     // pass some basic info from the app data
 1715:     if (appData.vendor)
 1715:       CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("Vendor"),
 1715:                                          nsDependentCString(appData.vendor));
 1715:     if (appData.name)
 1715:       CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("ProductName"),
 1715:                                          nsDependentCString(appData.name));
 1715:     if (appData.version)
 1715:       CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("Version"),
 1715:                                          nsDependentCString(appData.version));
 1715:     if (appData.buildID)
 1715:       CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("BuildID"),
 1715:                                          nsDependentCString(appData.buildID));
 1941:     CrashReporter::SetRestartArgs(argc, argv);
 3517: 
 3517:     // annotate other data (user id etc)
 3517:     nsXREDirProvider dirProvider;
 3517:     nsCOMPtr<nsILocalFile> userAppDataDir;
 3517:     rv = dirProvider.Initialize(gAppData->directory, gAppData->xreDirectory);
 3517:     if (NS_SUCCEEDED(rv) &&
 3517:         NS_SUCCEEDED(dirProvider.GetUserAppDataDirectory(
 3517:                                                          getter_AddRefs(userAppDataDir)))) {
 3565:       CrashReporter::SetupExtraData(userAppDataDir,
 3565:                                     nsDependentCString(appData.buildID));
10713: 
10713:       // see if we have a crashreporter-override.ini in the application directory
10713:       nsCOMPtr<nsIFile> overrideini;
10713:       PRBool exists;
10713:       static char overrideEnv[MAXPATHLEN];
10713:       if (NS_SUCCEEDED(dirProvider.GetAppDir()->Clone(getter_AddRefs(overrideini))) &&
10713:           NS_SUCCEEDED(overrideini->AppendNative(NS_LITERAL_CSTRING("crashreporter-override.ini"))) &&
10713:           NS_SUCCEEDED(overrideini->Exists(&exists)) &&
10713:           exists) {
10713: #ifdef XP_WIN
10713:         nsAutoString overridePathW;
10713:         overrideini->GetPath(overridePathW);
10713:         NS_ConvertUTF16toUTF8 overridePath(overridePathW);
10713: #else
10714:         nsCAutoString overridePath;
10713:         overrideini->GetNativePath(overridePath);
10713: #endif
10713: 
10713:         sprintf(overrideEnv, "MOZ_CRASHREPORTER_STRINGS_OVERRIDE=%s",
10713:                 overridePath.get());
10713:         PR_SetEnv(overrideEnv);
10713:       }
 3517:     }
 1715:   }
 1715: #endif
 1715: 
    1: #ifdef XP_MACOSX
    1:   if (PR_GetEnv("MOZ_LAUNCHED_CHILD")) {
 1549:     // This is needed, on relaunch, to force the OS to use the "Cocoa Dock
 1549:     // API".  Otherwise the call to ReceiveNextEvent() below will make it
 1549:     // use the "Carbon Dock API".  For more info see bmo bug 377166.
 1549:     EnsureUseCocoaDockAPI();
 1549: 
    1:     // When the app relaunches, the original process exits.  This causes
    1:     // the dock tile to stop bouncing, lose the "running" triangle, and
    1:     // if the tile does not permanently reside in the Dock, even disappear.
    1:     // This can be confusing to the user, who is expecting the app to launch.
    1:     // Calling ReceiveNextEvent without requesting any event is enough to
    1:     // cause a dock tile for the child process to appear.
    1:     const EventTypeSpec kFakeEventList[] = { { INT_MAX, INT_MAX } };
    1:     EventRef event;
    1:     ::ReceiveNextEvent(GetEventTypeCount(kFakeEventList), kFakeEventList,
    1:                        kEventDurationNoWait, PR_FALSE, &event);
    1:   }
    1: 
    1:   if (CheckArg("foreground")) {
    1:     // The original process communicates that it was in the foreground by
    1:     // adding this argument.  This new process, which is taking over for
    1:     // the old one, should make itself the active application.
    1:     ProcessSerialNumber psn;
    1:     if (::GetCurrentProcess(&psn) == noErr)
    1:       ::SetFrontProcess(&psn);
    1:   }
    1: #endif
    1: 
    1:   PR_SetEnv("MOZ_LAUNCHED_CHILD=");
    1: 
    1:   gRestartArgc = gArgc;
16745:   gRestartArgv = (char**) malloc(sizeof(char*) * (gArgc + 1 + (override ? 2 : 0)));
 6903:   if (!gRestartArgv) return 1;
 6903: 
 6903:   int i;
 6903:   for (i = 0; i < gArgc; ++i) {
 6903:     gRestartArgv[i] = gArgv[i];
 6901:   }
16745:   
16745:   // Add the -override argument back (it is removed automatically be CheckArg) if there is one
16745:   if (override) {
16745:     gRestartArgv[gRestartArgc++] = const_cast<char*>("-override");
16745:     gRestartArgv[gRestartArgc++] = const_cast<char*>(override);
16745:   }
16745: 
16745:   gRestartArgv[gRestartArgc] = nsnull;
16745:   
    1: 
    1: #if defined(XP_OS2)
    1:   PRBool StartOS2App(int aArgc, char **aArgv);
    1:   if (!StartOS2App(gArgc, gArgv))
    1:     return 1;
    1:   ScopedFPHandler handler;
    1: #endif /* XP_OS2 */
    1: 
 3321:   ar = CheckArg("safe-mode", PR_TRUE);
 3321:   if (ar == ARG_BAD) {
 3321:     PR_fprintf(PR_STDERR, "Error: argument -safe-mode is invalid when argument -osint is specified\n");
 3321:     return 1;
 3321:   } else if (ar == ARG_FOUND) {
 3321:     gSafeMode = PR_TRUE;
 3321:   }
 3321: 
    1: #ifdef XP_MACOSX
12558:   if (GetCurrentEventKeyModifiers() & optionKey)
 3321:     gSafeMode = PR_TRUE;
    1: #endif
    1: 
    1:   // Handle -no-remote command line argument. Setup the environment to
    1:   // better accommodate other components and various restart scenarios.
 3321:   ar = CheckArg("no-remote", PR_TRUE);
 3321:   if (ar == ARG_BAD) {
 3321:     PR_fprintf(PR_STDERR, "Error: argument -a requires an application name\n");
 3321:     return 1;
 3321:   } else if (ar == ARG_FOUND) {
    1:     PR_SetEnv("MOZ_NO_REMOTE=1");
 3321:   }
    1: 
    1:   // Handle -help and -version command line arguments.
    1:   // They should return quickly, so we deal with them here.
    1:   if (CheckArg("h") || CheckArg("help") || CheckArg("?")) {
    1:     DumpHelp();
    1:     return 0;
    1:   }
    1: 
    1:   if (CheckArg("v") || CheckArg("version")) {
    1:     DumpVersion();
    1:     return 0;
    1:   }
    1:     
    1: #ifdef NS_TRACE_MALLOC
    1:   gArgc = argc = NS_TraceMallocStartupArgs(gArgc, gArgv);
    1: #endif
    1: 
29279:   MOZ_SPLASHSCREEN_UPDATE(20);
29279: 
    1:   {
    1:     nsXREDirProvider dirProvider;
    1:     rv = dirProvider.Initialize(gAppData->directory, gAppData->xreDirectory);
    1:     if (NS_FAILED(rv))
    1:       return 1;
    1: 
    1:     // Check for -register, which registers chrome and then exits immediately.
 3321:     ar = CheckArg("register", PR_TRUE);
 3321:     if (ar == ARG_BAD) {
 3321:       PR_fprintf(PR_STDERR, "Error: argument -register is invalid when argument -osint is specified\n");
 3321:       return 1;
 3321:     } else if (ar == ARG_FOUND) {
    1:       ScopedXPCOMStartup xpcom;
    1:       rv = xpcom.Initialize();
    1:       NS_ENSURE_SUCCESS(rv, 1);
    1: 
    1:       {
    1:         nsCOMPtr<nsIChromeRegistry> chromeReg
    1:           (do_GetService("@mozilla.org/chrome/chrome-registry;1"));
    1:         NS_ENSURE_TRUE(chromeReg, 1);
    1: 
    1:         chromeReg->CheckForNewChrome();
    1:       }
    1:       return 0;
    1:     }
    1: 
  944: #if defined(MOZ_WIDGET_GTK2) || defined(MOZ_ENABLE_XREMOTE)
    1:     // Stash DESKTOP_STARTUP_ID in malloc'ed memory because gtk_init will clear it.
    1: #define HAVE_DESKTOP_STARTUP_ID
    1:     const char* desktopStartupIDEnv = PR_GetEnv("DESKTOP_STARTUP_ID");
    1:     nsCAutoString desktopStartupID;
    1:     if (desktopStartupIDEnv) {
    1:       desktopStartupID.Assign(desktopStartupIDEnv);
    1:     }
    1: #endif
    1: 
16759: #if defined(MOZ_WIDGET_QT)
16759:     QApplication app(gArgc, gArgv);
16759: #endif
  944: #if defined(MOZ_WIDGET_GTK2)
15459: #ifdef MOZ_MEMORY
15459:     // Disable the slice allocator, since jemalloc already uses similar layout
15459:     // algorithms, and using a sub-allocator tends to increase fragmentation.
15459:     // This must be done before g_thread_init() is called.
15459:     g_slice_set_config(G_SLICE_CONFIG_ALWAYS_MALLOC, 1);
15459: #endif
 2504:     g_thread_init(NULL);
    1:     // setup for private colormap.  Ideally we'd like to do this
    1:     // in nsAppShell::Create, but we need to get in before gtk
    1:     // has been initialized to make sure everything is running
    1:     // consistently.
    1:     if (CheckArg("install"))
    1:       gdk_rgb_set_install(TRUE);
    1: 
 6370:     // Initialize GTK here for splash.
 6370: 
 6370:     // Open the display ourselves instead of using gtk_init, so that we can
 6370:     // close it without fear that one day gtk might clean up the display it
 6370:     // opens.
 6370:     if (!gtk_parse_args(&gArgc, &gArgv))
 6370:       return 1;
 6370: 
 6370:     // display_name is owned by gdk.
 6370:     const char *display_name = gdk_get_display_arg_name();
17106:     if (display_name) {
17106:       SaveWordToEnv("DISPLAY", nsDependentCString(display_name));
17106:     } else {
 6370:       display_name = PR_GetEnv("DISPLAY");
 6370:       if (!display_name) {
 6370:         PR_fprintf(PR_STDERR, "Error: no display specified\n");
 6370:         return 1;
 6370:       }
 6370:     }
16744: #endif /* MOZ_WIDGET_GTK2 */
16744: 
16744: #ifdef MOZ_ENABLE_XREMOTE
16744:     // handle -remote now that xpcom is fired up
16744: 
16744:     const char* xremotearg;
16744:     ar = CheckArg("remote", PR_TRUE, &xremotearg);
16744:     if (ar == ARG_BAD) {
16744:       PR_fprintf(PR_STDERR, "Error: -remote requires an argument\n");
16744:       return 1;
16744:     }
16744:     const char* desktopStartupIDPtr =
16744:       desktopStartupID.IsEmpty() ? nsnull : desktopStartupID.get();
16744:     if (ar) {
16744:       return HandleRemoteArgument(xremotearg, desktopStartupIDPtr);
16744:     }
16744: 
16744:     if (!PR_GetEnv("MOZ_NO_REMOTE")) {
16744:       // Try to remote the entire command line. If this fails, start up normally.
16744:       RemoteResult rr = RemoteCommandLine(desktopStartupIDPtr);
16744:       if (rr == REMOTE_FOUND)
16744:         return 0;
16744:       else if (rr == REMOTE_ARG_BAD)
16744:         return 1;
16744:     }
16744: #endif
16744: 
16744: #if defined(MOZ_WIDGET_GTK2)
16744:     GdkDisplay* display = nsnull;
 6370:     display = gdk_display_open(display_name);
 6370:     if (!display) {
 6370:       PR_fprintf(PR_STDERR, "Error: cannot open display: %s\n", display_name);
 6370:       return 1;
 6370:     }
 6370:     gdk_display_manager_set_default_display (gdk_display_manager_get(),
 6370:                                              display);
    1:     
    1:     // g_set_application_name () is only defined in glib2.2 and higher.
    1:     _g_set_application_name_fn _g_set_application_name =
    1:       (_g_set_application_name_fn)FindFunction("g_set_application_name");
    1:     if (_g_set_application_name) {
    1:       _g_set_application_name(gAppData->name);
    1:     }
    1:     _gtk_window_set_auto_startup_notification_fn _gtk_window_set_auto_startup_notification =
    1:       (_gtk_window_set_auto_startup_notification_fn)FindFunction("gtk_window_set_auto_startup_notification");
    1:     if (_gtk_window_set_auto_startup_notification) {
    1:       _gtk_window_set_auto_startup_notification(PR_FALSE);
    1:     }
    1: 
24530:     gtk_widget_set_default_colormap(gdk_rgb_get_colormap());
  944: #endif /* MOZ_WIDGET_GTK2 */
    1: 
    1:     // Call the code to install our handler
    1: #ifdef MOZ_JPROF
    1:     setupProfilingStuff();
    1: #endif
    1: 
    1:     // Try to allocate "native app support."
    1:     nsCOMPtr<nsINativeAppSupport> nativeApp;
    1:     rv = NS_CreateNativeAppSupport(getter_AddRefs(nativeApp));
    1:     if (NS_FAILED(rv))
    1:       return 1;
    1: 
    1:     PRBool canRun = PR_FALSE;
    1:     rv = nativeApp->Start(&canRun);
    1:     if (NS_FAILED(rv) || !canRun) {
    1:       return 1;
    1:     }
    1: 
    1: #if defined(MOZ_UPDATER)
    1:   // Check for and process any available updates
  676:   nsCOMPtr<nsIFile> updRoot;
  676:   PRBool persistent;
  676:   rv = dirProvider.GetFile(XRE_UPDATE_ROOT_DIR, &persistent,
  676:                            getter_AddRefs(updRoot));
  676:   // XRE_UPDATE_ROOT_DIR may fail. Fallback to appDir if failed
  676:   if (NS_FAILED(rv))
  676:     updRoot = dirProvider.GetAppDir();
    1: 
    1:   ProcessUpdates(dirProvider.GetGREDir(),
    1:                  dirProvider.GetAppDir(),
  676:                  updRoot,
    1:                  gRestartArgc,
21647:                  gRestartArgv,
21647:                  appData.version);
    1: #endif
    1: 
    1:     nsCOMPtr<nsIProfileLock> profileLock;
    1:     PRBool startOffline = PR_FALSE;
 2962:     nsCAutoString profileName;
 2962: 
 2962:     rv = SelectProfile(getter_AddRefs(profileLock), nativeApp, &startOffline,
 2962:                        &profileName);
    1:     if (rv == NS_ERROR_LAUNCHED_CHILD_PROCESS ||
    1:         rv == NS_ERROR_ABORT) return 0;
    1:     if (NS_FAILED(rv)) return 1;
    1: 
    1:     nsCOMPtr<nsILocalFile> profD;
    1:     rv = profileLock->GetDirectory(getter_AddRefs(profD));
    1:     NS_ENSURE_SUCCESS(rv, 1);
    1: 
    1:     nsCOMPtr<nsILocalFile> profLD;
    1:     rv = profileLock->GetLocalDirectory(getter_AddRefs(profLD));
    1:     NS_ENSURE_SUCCESS(rv, 1);
    1: 
    1:     rv = dirProvider.SetProfile(profD, profLD);
    1:     NS_ENSURE_SUCCESS(rv, 1);
    1: 
32013: #if defined(WINCE) && defined(MOZ_SPLASHSCREEN)
31755:     // give up the mutex, let other app startups happen
31755:     winStartupMutex.Unlock();
31755: #endif
31755: 
    1:     //////////////////////// NOW WE HAVE A PROFILE ////////////////////////
    1: 
 4389: #ifdef MOZ_CRASHREPORTER
 1527:     if (appData.flags & NS_XRE_ENABLE_CRASH_REPORTER)
    1:         MakeOrSetMinidumpPath(profD);
    1: #endif
    1: 
    1:     PRBool upgraded = PR_FALSE;
    1: 
    1:     nsCAutoString version;
    1:     BuildVersion(version);
    1: 
    1: #ifdef TARGET_OS_ABI
    1:     NS_NAMED_LITERAL_CSTRING(osABI, TARGET_OS_ABI);
    1: #else
    1:     // No TARGET_XPCOM_ABI, but at least the OS is known
    1:     NS_NAMED_LITERAL_CSTRING(osABI, OS_TARGET "_UNKNOWN");
    1: #endif
    1: 
    1:     // Check for version compatibility with the last version of the app this 
    1:     // profile was started with.  The format of the version stamp is defined
    1:     // by the BuildVersion function.
33900:     // Also check to see if something has happened to invalidate our
33900:     // fastload caches, like an extension upgrade or installation.
33900:     PRBool cachesOK;
    1:     PRBool versionOK = CheckCompatibility(profD, version, osABI, 
    1:                                           dirProvider.GetGREDir(),
33900:                                           gAppData->directory, &cachesOK);
    1: 
    1:     // Every time a profile is loaded by a build with a different version,
    1:     // it updates the compatibility.ini file saying what version last wrote
    1:     // the compreg.dat.  On subsequent launches if the version matches, 
    1:     // there is no need for re-registration.  If the user loads the same
    1:     // profile in different builds the component registry must be
    1:     // re-generated to prevent mysterious component loading failures.
    1:     //
    1:     if (gSafeMode) {
    1:       RemoveComponentRegistries(profD, profLD, PR_FALSE);
    1:       WriteVersion(profD, NS_LITERAL_CSTRING("Safe Mode"), osABI,
    1:                    dirProvider.GetGREDir(), gAppData->directory);
    1:     }
    1:     else if (versionOK) {
33900:       if (!cachesOK) {
    1:         // Remove compreg.dat and xpti.dat, forcing component re-registration.
    1:         // The new list of additional components directories is derived from
    1:         // information in "extensions.ini".
    1:         RemoveComponentRegistries(profD, profLD, PR_FALSE);
33900:         
33900:         // Rewrite compatibility.ini to remove the flag
33900:         WriteVersion(profD, version, osABI,
33900:                      dirProvider.GetGREDir(), gAppData->directory);
    1:       }
    1:       // Nothing need be done for the normal startup case.
    1:     }
    1:     else {
    1:       // Remove compreg.dat and xpti.dat, forcing component re-registration
    1:       // with the default set of components (this disables any potentially
    1:       // troublesome incompatible XPCOM components). 
    1:       RemoveComponentRegistries(profD, profLD, PR_TRUE);
    1: 
    1:       // Tell the Extension Manager it should check for incompatible 
    1:       // Extensions and re-write the "extensions.ini" file with a list of 
    1:       // directories for compatible extensions
    1:       upgraded = PR_TRUE;
    1: 
    1:       // Write out version
    1:       WriteVersion(profD, version, osABI,
    1:                    dirProvider.GetGREDir(), gAppData->directory);
    1:     }
    1: 
    1:     PRBool needsRestart = PR_FALSE;
    1:     PRBool appInitiatedRestart = PR_FALSE;
    1: 
29279:     MOZ_SPLASHSCREEN_UPDATE(30);
29279: 
    1:     // Allows the user to forcefully bypass the restart process at their
    1:     // own risk. Useful for debugging or for tinderboxes where child 
    1:     // processes can be problematic.
    1:     {
    1:       // Start the real application
    1:       ScopedXPCOMStartup xpcom;
    1:       rv = xpcom.Initialize();
    1:       NS_ENSURE_SUCCESS(rv, 1); 
    1:       rv = xpcom.DoAutoreg();
 4415:       rv |= xpcom.RegisterProfileService();
    1:       rv |= xpcom.SetWindowCreator(nativeApp);
    1:       NS_ENSURE_SUCCESS(rv, 1);
    1: 
34844: #ifdef MOZ_CRASHREPORTER
34844:       // tell the crash reporter to also send the release channel
34844:       nsCOMPtr<nsIPrefService> prefs = do_GetService("@mozilla.org/preferences-service;1", &rv);
34844:       if (NS_SUCCEEDED(rv)) {
34844:         nsCOMPtr<nsIPrefBranch> defaultPrefBranch;
34844:         rv = prefs->GetDefaultBranch(nsnull, getter_AddRefs(defaultPrefBranch));
34844: 
34844:         if (NS_SUCCEEDED(rv)) {
34844:           nsXPIDLCString sval;
34844:           rv = defaultPrefBranch->GetCharPref("app.update.channel", getter_Copies(sval));
34844:           if (NS_SUCCEEDED(rv)) {
34844:             CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("ReleaseChannel"),
34844:                                                sval);
34844:           }
34844:         }
34844:       }
34844: #endif
    1:       {
    1:         if (startOffline) {
 4738:           nsCOMPtr<nsIIOService2> io (do_GetService("@mozilla.org/network/io-service;1"));
    1:           NS_ENSURE_TRUE(io, 1);
 4738:           io->SetManageOfflineStatus(PR_FALSE);
    1:           io->SetOffline(PR_TRUE);
    1:         }
    1: 
    1:         {
    1:           NS_TIMELINE_ENTER("startupNotifier");
    1:           nsCOMPtr<nsIObserver> startupNotifier
    1:             (do_CreateInstance(NS_APPSTARTUPNOTIFIER_CONTRACTID, &rv));
    1:           NS_ENSURE_SUCCESS(rv, 1);
    1: 
    1:           startupNotifier->Observe(nsnull, APPSTARTUP_TOPIC, nsnull);
    1:           NS_TIMELINE_LEAVE("startupNotifier");
    1:         }
    1: 
27580:         nsCOMPtr<nsIAppStartup2> appStartup
    1:           (do_GetService(NS_APPSTARTUP_CONTRACTID));
    1:         NS_ENSURE_TRUE(appStartup, 1);
    1: 
    1:         if (gDoMigration) {
    1:           nsCOMPtr<nsIFile> file;
    1:           dirProvider.GetAppDir()->Clone(getter_AddRefs(file));
    1:           file->AppendNative(NS_LITERAL_CSTRING("override.ini"));
    1:           nsINIParser parser;
    1:           nsCOMPtr<nsILocalFile> localFile(do_QueryInterface(file));
    1:           nsresult rv = parser.Init(localFile);
    1:           if (NS_SUCCEEDED(rv)) {
    1:             nsCAutoString buf;
    1:             rv = parser.GetString("XRE", "EnableProfileMigrator", buf);
    1:             if (NS_SUCCEEDED(rv)) {
    1:               if (buf[0] == '0' || buf[0] == 'f' || buf[0] == 'F') {
    1:                 gDoMigration = PR_FALSE;
    1:               }
    1:             }
    1:           }
    1:         }
    1: 
    1:         // Profile Migration
    1:         if (gAppData->flags & NS_XRE_ENABLE_PROFILE_MIGRATOR && gDoMigration) {
    1:           gDoMigration = PR_FALSE;
    1:           nsCOMPtr<nsIProfileMigrator> pm
    1:             (do_CreateInstance(NS_PROFILEMIGRATOR_CONTRACTID));
    1:           if (pm)
    1:             pm->Migrate(&dirProvider);
    1:         }
    1:         dirProvider.DoStartup();
    1: 
27580:         PRBool shuttingDown = PR_FALSE;
27580:         appStartup->GetShuttingDown(&shuttingDown);
27580: 
27580:         nsCOMPtr<nsICommandLineRunner> cmdLine;
27580: 
27582:         nsCOMPtr<nsIFile> workingDir;
27582:         rv = NS_GetSpecialDirectory(NS_OS_CURRENT_WORKING_DIR, getter_AddRefs(workingDir));
27582:         NS_ENSURE_SUCCESS(rv, 1);
27582: 
27580:         if (!shuttingDown) {
27580:           cmdLine = do_CreateInstance("@mozilla.org/toolkit/command-line;1");
    1:           NS_ENSURE_TRUE(cmdLine, 1);
    1: 
    1:           rv = cmdLine->Init(gArgc, gArgv,
    1:                              workingDir, nsICommandLine::STATE_INITIAL_LAUNCH);
    1:           NS_ENSURE_SUCCESS(rv, 1);
    1: 
    1:           /* Special-case services that need early access to the command
    1:              line. */
32490:           nsCOMPtr<nsIObserverService> obsService
32490:             (do_GetService("@mozilla.org/observer-service;1"));
32490:           if (obsService) {
32490:             obsService->NotifyObservers(cmdLine, "command-line-startup", nsnull);
    1:           }
    1: 
    1:           NS_TIMELINE_ENTER("appStartup->CreateHiddenWindow");
    1:           rv = appStartup->CreateHiddenWindow();
    1:           NS_TIMELINE_LEAVE("appStartup->CreateHiddenWindow");
    1:           NS_ENSURE_SUCCESS(rv, 1);
    1: 
29279:           MOZ_SPLASHSCREEN_UPDATE(50);
29279: 
33657: #if defined(HAVE_DESKTOP_STARTUP_ID) && defined(MOZ_WIDGET_GTK2)
33657:           nsRefPtr<nsGTKToolkit> toolkit = GetGTKToolkit();
33657:           if (toolkit && !desktopStartupID.IsEmpty()) {
33657:             toolkit->SetDesktopStartupID(desktopStartupID);
33657:           }
33657: #endif
33657: 
    1:           // Extension Compatibility Checking and Startup
    1:           if (gAppData->flags & NS_XRE_ENABLE_EXTENSION_MANAGER) {
    1:             nsCOMPtr<nsIExtensionManager> em(do_GetService("@mozilla.org/extensions/manager;1"));
    1:             NS_ENSURE_TRUE(em, 1);
    1: 
    1:             if (upgraded) {
    1:               rv = em->CheckForMismatches(&needsRestart);
    1:               if (NS_FAILED(rv)) {
    1:                 needsRestart = PR_FALSE;
    1:                 upgraded = PR_FALSE;
    1:               }
    1:             }
    1:             
    1:             if (!upgraded || !needsRestart)
28225:               em->Start(&needsRestart);
    1:           }
    1: 
    1:           // We want to restart no more than 2 times. The first restart,
    1:           // NO_EM_RESTART == "0" , and the second time, "1".
    1:           char* noEMRestart = PR_GetEnv("NO_EM_RESTART");
    1:           if (noEMRestart && *noEMRestart && *noEMRestart == '1') {
    1:             if (upgraded || needsRestart) {
    1:               NS_WARNING("EM tried to force us to restart twice! Forcefully preventing that.");
    1:             }
    1:             needsRestart = upgraded = PR_FALSE;
    1:           }
27580:         }
    1: 
    1:         if (!upgraded && !needsRestart) {
 6903:           SaveStateForAppInitiatedRestart();
 6903: 
    1:           // clear out any environment variables which may have been set 
    1:           // during the relaunch process now that we know we won't be relaunching.
    1:           PR_SetEnv("XRE_PROFILE_PATH=");
    1:           PR_SetEnv("XRE_PROFILE_LOCAL_PATH=");
 2962:           PR_SetEnv("XRE_PROFILE_NAME=");
    1:           PR_SetEnv("XRE_START_OFFLINE=");
    1:           PR_SetEnv("XRE_IMPORT_PROFILES=");
    1:           PR_SetEnv("NO_EM_RESTART=");
 6903:           PR_SetEnv("XUL_APP_FILE=");
    1:           PR_SetEnv("XRE_BINARY_PATH=");
    1: 
27580:           if (!shuttingDown) {
    1: #ifdef XP_MACOSX
    1:             // we re-initialize the command-line service and do appleevents munging
    1:             // after we are sure that we're not restarting
    1:             cmdLine = do_CreateInstance("@mozilla.org/toolkit/command-line;1");
    1:             NS_ENSURE_TRUE(cmdLine, 1);
    1: 
    1:             SetupMacCommandLine(gArgc, gArgv);
    1: 
    1:             rv = cmdLine->Init(gArgc, gArgv,
    1:                                workingDir, nsICommandLine::STATE_INITIAL_LAUNCH);
    1:             NS_ENSURE_SUCCESS(rv, 1);
    1: #endif
    1: #ifdef MOZ_WIDGET_COCOA
    1:             // Prepare Cocoa's form of Apple Event handling.
    1:             SetupMacApplicationDelegate();
    1: #endif
27580: 
29279:             MOZ_SPLASHSCREEN_UPDATE(70);
29279: 
    1:             nsCOMPtr<nsIObserverService> obsService
    1:               (do_GetService("@mozilla.org/observer-service;1"));
    1:             if (obsService)
    1:               obsService->NotifyObservers(nsnull, "final-ui-startup", nsnull);
    1: 
27580:             appStartup->GetShuttingDown(&shuttingDown);
27580:           }
27580: 
27580:           if (!shuttingDown) {
    1:             rv = cmdLine->Run();
    1:             NS_ENSURE_SUCCESS_LOG(rv, 1);
    1: 
27580:             appStartup->GetShuttingDown(&shuttingDown);
27580:           }
27580: 
27582: #ifdef MOZ_ENABLE_XREMOTE
27580:           nsCOMPtr<nsIRemoteService> remoteService;
27582: #endif /* MOZ_ENABLE_XREMOTE */
27580:           if (!shuttingDown) {
    1: #ifdef MOZ_ENABLE_XREMOTE
    1:             // if we have X remote support, start listening for requests on the
    1:             // proxy window.
    1:             remoteService = do_GetService("@mozilla.org/toolkit/remote-service;1");
    1:             if (remoteService)
 2962:               remoteService->Startup(gAppData->name,
 2962:                                      PromiseFlatCString(profileName).get());
    1: #endif /* MOZ_ENABLE_XREMOTE */
    1: 
    1:             // enable win32 DDE responses and Mac appleevents responses
    1:             nativeApp->Enable();
27580:           }
    1: 
29279:           MOZ_SPLASHSCREEN_UPDATE(90);
29279: 
    1:           NS_TIMELINE_ENTER("appStartup->Run");
    1:           rv = appStartup->Run();
    1:           NS_TIMELINE_LEAVE("appStartup->Run");
    1:           if (NS_FAILED(rv)) {
    1:             NS_ERROR("failed to run appstartup");
    1:             gLogConsoleErrors = PR_TRUE;
    1:           }
    1: 
    1:           // Check for an application initiated restart.  This is one that
    1:           // corresponds to nsIAppStartup.quit(eRestart)
    1:           if (rv == NS_SUCCESS_RESTART_APP) {
    1:             needsRestart = PR_TRUE;
    1:             appInitiatedRestart = PR_TRUE;
    1:           }
    1: 
27580:           if (!shuttingDown) {
    1: #ifdef MOZ_ENABLE_XREMOTE
    1:             // shut down the x remote proxy window
    1:             if (remoteService)
    1:               remoteService->Shutdown();
    1: #endif /* MOZ_ENABLE_XREMOTE */
27580:           }
    1: 
    1: #ifdef MOZ_TIMELINE
    1:           // Make sure we print this out even if timeline is runtime disabled
    1:           if (NS_FAILED(NS_TIMELINE_LEAVE("main1")))
    1:             NS_TimelineForceMark("...main1");
    1: #endif
    1:         }
    1:         else {
    1:           // Upgrade condition (build id changes), but the restart hint was 
    1:           // not set by the Extension Manager. This is because the compatibility
    1:           // resolution for Extensions is different than for the component 
    1:           // registry - major milestone vs. build id. 
    1:           needsRestart = PR_TRUE;
    1: 
    1: #ifdef XP_WIN
15466:           ProcessDDE(nativeApp, PR_TRUE);
    1: #endif
    1: 
    1: #ifdef XP_MACOSX
    1:           SetupMacCommandLine(gRestartArgc, gRestartArgv);
    1: #endif
    1:         }
    1:       }
 3367:     }
 3367: 
 3367:     // unlock the profile after ScopedXPCOMStartup object (xpcom) 
 3367:     // has gone out of scope.  see bug #386739 for more details
    1:     profileLock->Unlock();
    1: 
    1:     // Restart the app after XPCOM has been shut down cleanly. 
    1:     if (needsRestart) {
29279:       MOZ_SPLASHSCREEN_UPDATE(90);
29279: 
 6903:       if (appInitiatedRestart) {
 6903:         RestoreStateForAppInitiatedRestart();
 6903:       }
 6903:       else {
    1:         char* noEMRestart = PR_GetEnv("NO_EM_RESTART");
    1:         if (noEMRestart && *noEMRestart) {
    1:           PR_SetEnv("NO_EM_RESTART=1");
    1:         }
    1:         else {
    1:           PR_SetEnv("NO_EM_RESTART=0");
    1:         }
    1:       }
    1: 
    1:       // Ensure that these environment variables are set:
    1:       SaveFileToEnvIfUnset("XRE_PROFILE_PATH", profD);
    1:       SaveFileToEnvIfUnset("XRE_PROFILE_LOCAL_PATH", profLD);
 2962:       SaveWordToEnvIfUnset("XRE_PROFILE_NAME", profileName);
    1: 
    1: #ifdef XP_MACOSX
    1:       if (gBinaryPath) {
    1:         static char kEnvVar[MAXPATHLEN];
    1:         sprintf(kEnvVar, "XRE_BINARY_PATH=%s", gBinaryPath);
    1:         PR_SetEnv(kEnvVar);
    1:       }
    1: #endif
    1: 
 6370: // XXXkt s/MOZ_TOOLKIT_GTK2/MOZ_WIDGET_GTK2/?
 6370: // but the hidden window has been destroyed so toolkit is NULL anyway.
    1: #if defined(HAVE_DESKTOP_STARTUP_ID) && defined(MOZ_TOOLKIT_GTK2)
    1:       nsGTKToolkit* toolkit = GetGTKToolkit();
    1:       if (toolkit) {
    1:         nsCAutoString currentDesktopStartupID;
    1:         toolkit->GetDesktopStartupID(&currentDesktopStartupID);
    1:         if (!currentDesktopStartupID.IsEmpty()) {
    1:           nsCAutoString desktopStartupEnv;
    1:           desktopStartupEnv.AssignLiteral("DESKTOP_STARTUP_ID=");
    1:           desktopStartupEnv.Append(currentDesktopStartupID);
    1:           // Leak it with extreme prejudice!
    1:           PR_SetEnv(ToNewCString(desktopStartupEnv));
    1:         }
    1:       }
    1: #endif
    1: 
 6370: #ifdef MOZ_WIDGET_GTK2
 6618:       MOZ_gdk_display_close(display);
 6370: #endif
 6370: 
15484:       rv = LaunchChild(nativeApp, appInitiatedRestart);
  155: 
 4389: #ifdef MOZ_CRASHREPORTER
 1527:       if (appData.flags & NS_XRE_ENABLE_CRASH_REPORTER)
  155:         CrashReporter::UnsetExceptionHandler();
  157: #endif
  157: 
    1:       return rv == NS_ERROR_LAUNCHED_CHILD_PROCESS ? 0 : 1;
    1:     }
 6370: 
 6370: #ifdef MOZ_WIDGET_GTK2
 6370:     // gdk_display_close also calls gdk_display_manager_set_default_display
 6370:     // appropriately when necessary.
 6618:     MOZ_gdk_display_close(display);
 6370: #endif
    1:   }
    1: 
 4389: #ifdef MOZ_CRASHREPORTER
 1527:   if (appData.flags & NS_XRE_ENABLE_CRASH_REPORTER)
  155:       CrashReporter::UnsetExceptionHandler();
  157: #endif
  157: 
    1:   return NS_FAILED(rv) ? 1 : 0;
    1: }
