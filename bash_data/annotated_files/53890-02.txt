29805: /*
29805:  * Copyright (c) 2007 Henri Sivonen
39864:  * Copyright (c) 2007-2010 Mozilla Foundation
29805:  * Portions of comments Copyright 2004-2008 Apple Computer, Inc., Mozilla 
29805:  * Foundation, and Opera Software ASA.
29805:  *
29805:  * Permission is hereby granted, free of charge, to any person obtaining a 
29805:  * copy of this software and associated documentation files (the "Software"), 
29805:  * to deal in the Software without restriction, including without limitation 
29805:  * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
29805:  * and/or sell copies of the Software, and to permit persons to whom the 
29805:  * Software is furnished to do so, subject to the following conditions:
29805:  *
29805:  * The above copyright notice and this permission notice shall be included in 
29805:  * all copies or substantial portions of the Software.
29805:  *
29805:  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
29805:  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
29805:  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
29805:  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
29805:  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
29805:  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
29805:  * DEALINGS IN THE SOFTWARE.
29805:  */
29805: 
29805: /*
29805:  * The comments following this one that use the same comment syntax as this 
29805:  * comment are quotes from the WHATWG HTML 5 spec as of 27 June 2007 
29805:  * amended as of June 28 2007.
29805:  * That document came with this statement:
29805:  * "Â© Copyright 2004-2007 Apple Computer, Inc., Mozilla Foundation, and 
29805:  * Opera Software ASA. You are granted a license to use, reproduce and 
29805:  * create derivative works of this document."
29805:  */
29805: 
29805: package nu.validator.htmlparser.impl;
29805: 
29805: import java.util.Arrays;
29805: import java.util.HashMap;
29805: import java.util.Map;
29805: 
39864: import nu.validator.htmlparser.annotation.Const;
29805: import nu.validator.htmlparser.annotation.IdType;
29805: import nu.validator.htmlparser.annotation.Inline;
29805: import nu.validator.htmlparser.annotation.Literal;
29805: import nu.validator.htmlparser.annotation.Local;
29805: import nu.validator.htmlparser.annotation.NoLength;
29805: import nu.validator.htmlparser.annotation.NsUri;
29805: import nu.validator.htmlparser.common.DoctypeExpectation;
29805: import nu.validator.htmlparser.common.DocumentMode;
29805: import nu.validator.htmlparser.common.DocumentModeHandler;
39864: import nu.validator.htmlparser.common.Interner;
29805: import nu.validator.htmlparser.common.TokenHandler;
29805: import nu.validator.htmlparser.common.XmlViolationPolicy;
29805: 
29805: import org.xml.sax.ErrorHandler;
29805: import org.xml.sax.SAXException;
29805: import org.xml.sax.SAXParseException;
29805: 
39864: public abstract class TreeBuilder<T> implements TokenHandler,
39864:         TreeBuilderState<T> {
39864:     
46394:     /**
46394:      * Array version of U+FFFD.
46394:      */
46394:     private static final @NoLength char[] REPLACEMENT_CHARACTER = { '\uFFFD' };
46394:     
29805:     // Start dispatch groups
29805: 
29805:     final static int OTHER = 0;
29805: 
29805:     final static int A = 1;
29805: 
29805:     final static int BASE = 2;
29805: 
29805:     final static int BODY = 3;
29805: 
29805:     final static int BR = 4;
29805: 
29805:     final static int BUTTON = 5;
29805: 
29805:     final static int CAPTION = 6;
29805: 
29805:     final static int COL = 7;
29805: 
29805:     final static int COLGROUP = 8;
29805: 
29805:     final static int FORM = 9;
29805: 
29805:     final static int FRAME = 10;
29805: 
29805:     final static int FRAMESET = 11;
29805: 
29805:     final static int IMAGE = 12;
29805: 
29805:     final static int INPUT = 13;
29805: 
29805:     final static int ISINDEX = 14;
29805: 
29805:     final static int LI = 15;
29805: 
46393:     final static int LINK_OR_BASEFONT_OR_BGSOUND = 16;
29805: 
29805:     final static int MATH = 17;
29805: 
29805:     final static int META = 18;
29805: 
29805:     final static int SVG = 19;
29805: 
29805:     final static int HEAD = 20;
29805: 
29805:     final static int HR = 22;
29805: 
29805:     final static int HTML = 23;
29805: 
29805:     final static int NOBR = 24;
29805: 
29805:     final static int NOFRAMES = 25;
29805: 
29805:     final static int NOSCRIPT = 26;
29805: 
29805:     final static int OPTGROUP = 27;
29805: 
29805:     final static int OPTION = 28;
29805: 
29805:     final static int P = 29;
29805: 
29805:     final static int PLAINTEXT = 30;
29805: 
29805:     final static int SCRIPT = 31;
29805: 
29805:     final static int SELECT = 32;
29805: 
29805:     final static int STYLE = 33;
29805: 
29805:     final static int TABLE = 34;
29805: 
29805:     final static int TEXTAREA = 35;
29805: 
29805:     final static int TITLE = 36;
29805: 
29805:     final static int TR = 37;
29805: 
29805:     final static int XMP = 38;
29805: 
29805:     final static int TBODY_OR_THEAD_OR_TFOOT = 39;
29805: 
29805:     final static int TD_OR_TH = 40;
29805: 
29805:     final static int DD_OR_DT = 41;
29805: 
29805:     final static int H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6 = 42;
29805: 
29805:     final static int MARQUEE_OR_APPLET = 43;
29805: 
29805:     final static int PRE_OR_LISTING = 44;
29805: 
29805:     final static int B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U = 45;
29805: 
29805:     final static int UL_OR_OL_OR_DL = 46;
29805: 
29805:     final static int IFRAME = 47;
29805: 
29805:     final static int EMBED_OR_IMG = 48;
29805: 
46393:     final static int AREA_OR_SPACER_OR_WBR = 49;
29805: 
29805:     final static int DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU = 50;
29805: 
39864:     final static int ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_HGROUP_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION = 51;
29805: 
29805:     final static int RUBY_OR_SPAN_OR_SUB_OR_SUP_OR_VAR = 52;
29805: 
29805:     final static int RT_OR_RP = 53;
29805: 
39864:     final static int COMMAND = 54;
29805: 
29805:     final static int PARAM_OR_SOURCE = 55;
29805: 
29805:     final static int MGLYPH_OR_MALIGNMARK = 56;
29805: 
29805:     final static int MI_MO_MN_MS_MTEXT = 57;
29805: 
29805:     final static int ANNOTATION_XML = 58;
29805: 
29805:     final static int FOREIGNOBJECT_OR_DESC = 59;
29805: 
29805:     final static int NOEMBED = 60;
29805: 
29805:     final static int FIELDSET = 61;
29805: 
29805:     final static int OUTPUT_OR_LABEL = 62;
29805: 
29805:     final static int OBJECT = 63;
29805: 
29805:     final static int FONT = 64;
29805: 
29805:     final static int KEYGEN = 65;
29805: 
29805:     // start insertion modes
29805: 
29805:     private static final int INITIAL = 0;
29805: 
29805:     private static final int BEFORE_HTML = 1;
29805: 
29805:     private static final int BEFORE_HEAD = 2;
29805: 
29805:     private static final int IN_HEAD = 3;
29805: 
29805:     private static final int IN_HEAD_NOSCRIPT = 4;
29805: 
29805:     private static final int AFTER_HEAD = 5;
29805: 
29805:     private static final int IN_BODY = 6;
29805: 
29805:     private static final int IN_TABLE = 7;
29805: 
29805:     private static final int IN_CAPTION = 8;
29805: 
29805:     private static final int IN_COLUMN_GROUP = 9;
29805: 
29805:     private static final int IN_TABLE_BODY = 10;
29805: 
29805:     private static final int IN_ROW = 11;
29805: 
29805:     private static final int IN_CELL = 12;
29805: 
29805:     private static final int IN_SELECT = 13;
29805: 
29805:     private static final int IN_SELECT_IN_TABLE = 14;
29805: 
29805:     private static final int AFTER_BODY = 15;
29805: 
29805:     private static final int IN_FRAMESET = 16;
29805: 
29805:     private static final int AFTER_FRAMESET = 17;
29805: 
29805:     private static final int AFTER_AFTER_BODY = 18;
29805: 
29805:     private static final int AFTER_AFTER_FRAMESET = 19;
29805: 
39864:     private static final int TEXT = 20;
29805: 
29805:     private static final int FRAMESET_OK = 21;
29805: 
29805:     // start charset states
29805: 
29805:     private static final int CHARSET_INITIAL = 0;
29805: 
29805:     private static final int CHARSET_C = 1;
29805: 
29805:     private static final int CHARSET_H = 2;
29805: 
29805:     private static final int CHARSET_A = 3;
29805: 
29805:     private static final int CHARSET_R = 4;
29805: 
29805:     private static final int CHARSET_S = 5;
29805: 
29805:     private static final int CHARSET_E = 6;
29805: 
29805:     private static final int CHARSET_T = 7;
29805: 
29805:     private static final int CHARSET_EQUALS = 8;
29805: 
29805:     private static final int CHARSET_SINGLE_QUOTED = 9;
29805: 
29805:     private static final int CHARSET_DOUBLE_QUOTED = 10;
29805: 
29805:     private static final int CHARSET_UNQUOTED = 11;
29805: 
29805:     // end pseudo enums
29805: 
29805:     // [NOCPP[
29805: 
29805:     private final static String[] HTML4_PUBLIC_IDS = {
29805:             "-//W3C//DTD HTML 4.0 Frameset//EN",
29805:             "-//W3C//DTD HTML 4.0 Transitional//EN",
29805:             "-//W3C//DTD HTML 4.0//EN", "-//W3C//DTD HTML 4.01 Frameset//EN",
29805:             "-//W3C//DTD HTML 4.01 Transitional//EN",
29805:             "-//W3C//DTD HTML 4.01//EN" };
29805: 
29805:     // ]NOCPP]
29805: 
29805:     @Literal private final static String[] QUIRKY_PUBLIC_IDS = {
29805:             "+//silmaril//dtd html pro v0r11 19970101//",
29805:             "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
29805:             "-//as//dtd html 3.0 aswedit + extensions//",
29805:             "-//ietf//dtd html 2.0 level 1//",
29805:             "-//ietf//dtd html 2.0 level 2//",
29805:             "-//ietf//dtd html 2.0 strict level 1//",
29805:             "-//ietf//dtd html 2.0 strict level 2//",
29805:             "-//ietf//dtd html 2.0 strict//",
29805:             "-//ietf//dtd html 2.0//",
29805:             "-//ietf//dtd html 2.1e//",
29805:             "-//ietf//dtd html 3.0//",
29805:             "-//ietf//dtd html 3.2 final//",
29805:             "-//ietf//dtd html 3.2//",
29805:             "-//ietf//dtd html 3//",
29805:             "-//ietf//dtd html level 0//",
29805:             "-//ietf//dtd html level 1//",
29805:             "-//ietf//dtd html level 2//",
29805:             "-//ietf//dtd html level 3//",
29805:             "-//ietf//dtd html strict level 0//",
29805:             "-//ietf//dtd html strict level 1//",
29805:             "-//ietf//dtd html strict level 2//",
29805:             "-//ietf//dtd html strict level 3//",
29805:             "-//ietf//dtd html strict//",
29805:             "-//ietf//dtd html//",
29805:             "-//metrius//dtd metrius presentational//",
29805:             "-//microsoft//dtd internet explorer 2.0 html strict//",
29805:             "-//microsoft//dtd internet explorer 2.0 html//",
29805:             "-//microsoft//dtd internet explorer 2.0 tables//",
29805:             "-//microsoft//dtd internet explorer 3.0 html strict//",
29805:             "-//microsoft//dtd internet explorer 3.0 html//",
29805:             "-//microsoft//dtd internet explorer 3.0 tables//",
29805:             "-//netscape comm. corp.//dtd html//",
29805:             "-//netscape comm. corp.//dtd strict html//",
29805:             "-//o'reilly and associates//dtd html 2.0//",
29805:             "-//o'reilly and associates//dtd html extended 1.0//",
29805:             "-//o'reilly and associates//dtd html extended relaxed 1.0//",
29805:             "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
29805:             "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
29805:             "-//spyglass//dtd html 2.0 extended//",
29805:             "-//sq//dtd html 2.0 hotmetal + extensions//",
29805:             "-//sun microsystems corp.//dtd hotjava html//",
29805:             "-//sun microsystems corp.//dtd hotjava strict html//",
29805:             "-//w3c//dtd html 3 1995-03-24//", "-//w3c//dtd html 3.2 draft//",
29805:             "-//w3c//dtd html 3.2 final//", "-//w3c//dtd html 3.2//",
29805:             "-//w3c//dtd html 3.2s draft//", "-//w3c//dtd html 4.0 frameset//",
29805:             "-//w3c//dtd html 4.0 transitional//",
29805:             "-//w3c//dtd html experimental 19960712//",
29805:             "-//w3c//dtd html experimental 970421//", "-//w3c//dtd w3 html//",
29805:             "-//w3o//dtd w3 html 3.0//", "-//webtechs//dtd mozilla html 2.0//",
29805:             "-//webtechs//dtd mozilla html//" };
29805: 
29805:     private static final int NOT_FOUND_ON_STACK = Integer.MAX_VALUE;
29805: 
29805:     // [NOCPP[
29805: 
29805:     private static final @Local String HTML_LOCAL = "html";
29805: 
29805:     // ]NOCPP]
29805: 
29805:     private int mode = INITIAL;
29805: 
29805:     private int originalMode = INITIAL;
29805:     
39864:     /**
39864:      * Used only when moving back to IN_BODY.
39864:      */
39864:     private boolean framesetOk = true;
39864: 
41449:     private boolean inForeign = false;
29805: 
29805:     protected Tokenizer tokenizer;
29805: 
29805:     // [NOCPP[
29805: 
29805:     protected ErrorHandler errorHandler;
29805: 
29805:     private DocumentModeHandler documentModeHandler;
29805: 
29805:     private DoctypeExpectation doctypeExpectation = DoctypeExpectation.HTML;
29805: 
29805:     // ]NOCPP]
29805: 
29805:     private boolean scriptingEnabled = false;
29805: 
29805:     private boolean needToDropLF;
29805: 
29805:     // [NOCPP[
29805: 
29805:     private boolean wantingComments;
29805: 
29805:     // ]NOCPP]
29805: 
29805:     private boolean fragment;
29805: 
29805:     private @Local String contextName;
29805: 
29805:     private @NsUri String contextNamespace;
29805: 
29805:     private T contextNode;
29805: 
29805:     private StackNode<T>[] stack;
29805: 
29805:     private int currentPtr = -1;
29805: 
29805:     private StackNode<T>[] listOfActiveFormattingElements;
29805: 
29805:     private int listPtr = -1;
29805: 
29805:     private T formPointer;
29805: 
29805:     private T headPointer;
29805: 
53890:     /**
53890:      * Used to work around Gecko limitations. Not used in Java.
53890:      */
53890:     private T deepTreeSurrogateParent;
53890: 
29805:     protected char[] charBuffer;
29805: 
29805:     protected int charBufferLen = 0;
29805: 
29805:     private boolean quirks = false;
29805: 
29805:     // [NOCPP[
29805: 
29805:     private boolean reportingDoctype = true;
29805: 
29805:     private XmlViolationPolicy namePolicy = XmlViolationPolicy.ALTER_INFOSET;
29805: 
29805:     private final Map<String, LocatorImpl> idLocations = new HashMap<String, LocatorImpl>();
29805: 
29805:     private boolean html4;
29805: 
29805:     // ]NOCPP]
29805: 
29805:     protected TreeBuilder() {
29805:         fragment = false;
29805:     }
29805: 
29805:     /**
29805:      * Reports an condition that would make the infoset incompatible with XML
29805:      * 1.0 as fatal.
29805:      * 
29805:      * @throws SAXException
29805:      * @throws SAXParseException
29805:      */
29805:     protected void fatal() throws SAXException {
29805:     }
29805: 
29805:     // [NOCPP[
29805: 
29805:     protected final void fatal(Exception e) throws SAXException {
29805:         SAXParseException spe = new SAXParseException(e.getMessage(),
29805:                 tokenizer, e);
29805:         if (errorHandler != null) {
29805:             errorHandler.fatalError(spe);
29805:         }
29805:         throw spe;
29805:     }
29805: 
29805:     final void fatal(String s) throws SAXException {
29805:         SAXParseException spe = new SAXParseException(s, tokenizer);
29805:         if (errorHandler != null) {
29805:             errorHandler.fatalError(spe);
29805:         }
29805:         throw spe;
29805:     }
29805: 
29805:     // ]NOCPP]
29805: 
29805:     /**
29805:      * Reports a Parse Error.
29805:      * 
29805:      * @param message
29805:      *            the message
29805:      * @throws SAXException
29805:      */
29805:     final void err(String message) throws SAXException {
29805:         // [NOCPP[
29805:         if (errorHandler == null) {
29805:             return;
29805:         }
41449:         errNoCheck(message);
41449:         // ]NOCPP]
41449:     }
41449:     
41449:     /**
41449:      * Reports a Parse Error without checking if an error handler is present.
41449:      * 
41449:      * @param message
41449:      *            the message
41449:      * @throws SAXException
41449:      */
41449:     final void errNoCheck(String message) throws SAXException {
41449:         // [NOCPP[
29805:         SAXParseException spe = new SAXParseException(message, tokenizer);
29805:         errorHandler.error(spe);
29805:         // ]NOCPP]
29805:     }
29805: 
29805:     /**
29805:      * Reports a warning
29805:      * 
29805:      * @param message
29805:      *            the message
29805:      * @throws SAXException
29805:      */
29805:     final void warn(String message) throws SAXException {
29805:         // [NOCPP[
29805:         if (errorHandler == null) {
29805:             return;
29805:         }
29805:         SAXParseException spe = new SAXParseException(message, tokenizer);
29805:         errorHandler.warning(spe);
29805:         // ]NOCPP]
29805:     }
29805: 
39864:     @SuppressWarnings("unchecked") public final void startTokenization(Tokenizer self) throws SAXException {
29805:         tokenizer = self;
29805:         stack = new StackNode[64];
29805:         listOfActiveFormattingElements = new StackNode[64];
29805:         needToDropLF = false;
29805:         originalMode = INITIAL;
29805:         currentPtr = -1;
29805:         listPtr = -1;
29805:         Portability.releaseElement(formPointer);
29805:         formPointer = null;
29805:         Portability.releaseElement(headPointer);
29805:         headPointer = null;
53890:         Portability.releaseElement(deepTreeSurrogateParent);
53890:         deepTreeSurrogateParent = null;
29805:         // [NOCPP[
29805:         html4 = false;
29805:         idLocations.clear();
29805:         wantingComments = wantsComments();
29805:         // ]NOCPP]
29805:         start(fragment);
29805:         charBufferLen = 0;
29805:         charBuffer = new char[1024];
39864:         framesetOk = true;
29805:         if (fragment) {
29805:             T elt;
29805:             if (contextNode != null) {
29805:                 elt = contextNode;
29805:                 Portability.retainElement(elt);
29805:             } else {
29805:                 elt = createHtmlElementSetAsRoot(tokenizer.emptyAttributes());
29805:             }
29805:             StackNode<T> node = new StackNode<T>(
29805:                     "http://www.w3.org/1999/xhtml", ElementName.HTML, elt);
29805:             currentPtr++;
29805:             stack[currentPtr] = node;
29805:             resetTheInsertionMode();
29805:             if ("title" == contextName || "textarea" == contextName) {
40985:                 tokenizer.setStateAndEndTagExpectation(Tokenizer.RCDATA, contextName);
39864:             } else if ("style" == contextName || "xmp" == contextName
39864:                     || "iframe" == contextName || "noembed" == contextName
39864:                     || "noframes" == contextName
29805:                     || (scriptingEnabled && "noscript" == contextName)) {
40985:                 tokenizer.setStateAndEndTagExpectation(Tokenizer.RAWTEXT, contextName);
29805:             } else if ("plaintext" == contextName) {
40985:                 tokenizer.setStateAndEndTagExpectation(Tokenizer.PLAINTEXT, contextName);
39864:             } else if ("script" == contextName) {
40985:                 tokenizer.setStateAndEndTagExpectation(Tokenizer.SCRIPT_DATA,
39864:                         contextName);
29805:             } else {
40985:                 tokenizer.setStateAndEndTagExpectation(Tokenizer.DATA, contextName);
29805:             }
29805:             Portability.releaseLocal(contextName);
29805:             contextName = null;
29805:             Portability.releaseElement(contextNode);
29805:             contextNode = null;
29805:             Portability.releaseElement(elt);
29805:         } else {
29805:             mode = INITIAL;
41449:             inForeign = false;
29805:         }
29805:     }
29805: 
29805:     public final void doctype(@Local String name, String publicIdentifier,
29805:             String systemIdentifier, boolean forceQuirks) throws SAXException {
29805:         needToDropLF = false;
41449:         if (!inForeign) {
29805:             switch (mode) {
29805:                 case INITIAL:
29805:                     // [NOCPP[
29805:                     if (reportingDoctype) {
29805:                         // ]NOCPP]
29805:                         String emptyString = Portability.newEmptyString();
41449:                         appendDoctypeToDocument(name == null ? "" : name,
29805:                                 publicIdentifier == null ? emptyString
29805:                                         : publicIdentifier,
29805:                                 systemIdentifier == null ? emptyString
29805:                                         : systemIdentifier);
29805:                         Portability.releaseString(emptyString);
29805:                         // [NOCPP[
29805:                     }
29805:                     switch (doctypeExpectation) {
29805:                         case HTML:
29805:                             // ]NOCPP]
29805:                             if (isQuirky(name, publicIdentifier,
29805:                                     systemIdentifier, forceQuirks)) {
29805:                                 err("Quirky doctype. Expected \u201C<!DOCTYPE html>\u201D.");
41449:                                 documentModeInternal(DocumentMode.QUIRKS_MODE,
41449:                                         publicIdentifier, systemIdentifier,
41449:                                         false);
41449:                             } else if (isAlmostStandards(publicIdentifier,
41449:                                     systemIdentifier)) {
29805:                                 err("Almost standards mode doctype. Expected \u201C<!DOCTYPE html>\u201D.");
29805:                                 documentModeInternal(
29805:                                         DocumentMode.ALMOST_STANDARDS_MODE,
41449:                                         publicIdentifier, systemIdentifier,
41449:                                         false);
29805:                             } else {
29805:                                 // [NOCPP[
39864:                                 if ((Portability.literalEqualsString(
39864:                                         "-//W3C//DTD HTML 4.0//EN",
39864:                                         publicIdentifier) && (systemIdentifier == null || Portability.literalEqualsString(
39864:                                         "http://www.w3.org/TR/REC-html40/strict.dtd",
39864:                                         systemIdentifier)))
39864:                                         || (Portability.literalEqualsString(
39864:                                                 "-//W3C//DTD HTML 4.01//EN",
39864:                                                 publicIdentifier) && (systemIdentifier == null || Portability.literalEqualsString(
39864:                                                 "http://www.w3.org/TR/html4/strict.dtd",
39864:                                                 systemIdentifier)))
39864:                                         || (Portability.literalEqualsString(
39864:                                                 "-//W3C//DTD XHTML 1.0 Strict//EN",
39864:                                                 publicIdentifier) && Portability.literalEqualsString(
39864:                                                 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd",
39864:                                                 systemIdentifier))
39864:                                         || (Portability.literalEqualsString(
39864:                                                 "-//W3C//DTD XHTML 1.1//EN",
39864:                                                 publicIdentifier) && Portability.literalEqualsString(
39864:                                                 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd",
39864:                                                 systemIdentifier))
39864: 
39864:                                 ) {
39864:                                     warn("Obsolete doctype. Expected \u201C<!DOCTYPE html>\u201D.");
39864:                                 } else if (!((systemIdentifier == null || Portability.literalEqualsString(
41449:                                         "about:legacy-compat", systemIdentifier)) && publicIdentifier == null)) {
29805:                                     err("Legacy doctype. Expected \u201C<!DOCTYPE html>\u201D.");
29805:                                 }
29805:                                 // ]NOCPP]
29805:                                 documentModeInternal(
29805:                                         DocumentMode.STANDARDS_MODE,
41449:                                         publicIdentifier, systemIdentifier,
41449:                                         false);
29805:                             }
29805:                             // [NOCPP[
29805:                             break;
29805:                         case HTML401_STRICT:
29805:                             html4 = true;
29805:                             tokenizer.turnOnAdditionalHtml4Errors();
29805:                             if (isQuirky(name, publicIdentifier,
29805:                                     systemIdentifier, forceQuirks)) {
29805:                                 err("Quirky doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
41449:                                 documentModeInternal(DocumentMode.QUIRKS_MODE,
41449:                                         publicIdentifier, systemIdentifier,
41449:                                         true);
41449:                             } else if (isAlmostStandards(publicIdentifier,
41449:                                     systemIdentifier)) {
29805:                                 err("Almost standards mode doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
29805:                                 documentModeInternal(
29805:                                         DocumentMode.ALMOST_STANDARDS_MODE,
41449:                                         publicIdentifier, systemIdentifier,
41449:                                         true);
29805:                             } else {
29805:                                 if ("-//W3C//DTD HTML 4.01//EN".equals(publicIdentifier)) {
29805:                                     if (!"http://www.w3.org/TR/html4/strict.dtd".equals(systemIdentifier)) {
29805:                                         warn("The doctype did not contain the system identifier prescribed by the HTML 4.01 specification. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
29805:                                     }
29805:                                 } else {
29805:                                     err("The doctype was not the HTML 4.01 Strict doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
29805:                                 }
29805:                                 documentModeInternal(
29805:                                         DocumentMode.STANDARDS_MODE,
41449:                                         publicIdentifier, systemIdentifier,
41449:                                         true);
29805:                             }
29805:                             break;
29805:                         case HTML401_TRANSITIONAL:
29805:                             html4 = true;
29805:                             tokenizer.turnOnAdditionalHtml4Errors();
29805:                             if (isQuirky(name, publicIdentifier,
29805:                                     systemIdentifier, forceQuirks)) {
29805:                                 err("Quirky doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
41449:                                 documentModeInternal(DocumentMode.QUIRKS_MODE,
41449:                                         publicIdentifier, systemIdentifier,
41449:                                         true);
41449:                             } else if (isAlmostStandards(publicIdentifier,
41449:                                     systemIdentifier)) {
29805:                                 if ("-//W3C//DTD HTML 4.01 Transitional//EN".equals(publicIdentifier)
29805:                                         && systemIdentifier != null) {
29805:                                     if (!"http://www.w3.org/TR/html4/loose.dtd".equals(systemIdentifier)) {
29805:                                         warn("The doctype did not contain the system identifier prescribed by the HTML 4.01 specification. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
29805:                                     }
29805:                                 } else {
29805:                                     err("The doctype was not a non-quirky HTML 4.01 Transitional doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
29805:                                 }
29805:                                 documentModeInternal(
29805:                                         DocumentMode.ALMOST_STANDARDS_MODE,
41449:                                         publicIdentifier, systemIdentifier,
41449:                                         true);
29805:                             } else {
29805:                                 err("The doctype was not the HTML 4.01 Transitional doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
29805:                                 documentModeInternal(
29805:                                         DocumentMode.STANDARDS_MODE,
41449:                                         publicIdentifier, systemIdentifier,
41449:                                         true);
29805:                             }
29805:                             break;
29805:                         case AUTO:
29805:                             html4 = isHtml4Doctype(publicIdentifier);
29805:                             if (html4) {
29805:                                 tokenizer.turnOnAdditionalHtml4Errors();
29805:                             }
29805:                             if (isQuirky(name, publicIdentifier,
29805:                                     systemIdentifier, forceQuirks)) {
29805:                                 err("Quirky doctype. Expected e.g. \u201C<!DOCTYPE html>\u201D.");
41449:                                 documentModeInternal(DocumentMode.QUIRKS_MODE,
41449:                                         publicIdentifier, systemIdentifier,
41449:                                         html4);
41449:                             } else if (isAlmostStandards(publicIdentifier,
41449:                                     systemIdentifier)) {
29805:                                 if ("-//W3C//DTD HTML 4.01 Transitional//EN".equals(publicIdentifier)) {
29805:                                     if (!"http://www.w3.org/TR/html4/loose.dtd".equals(systemIdentifier)) {
29805:                                         warn("The doctype did not contain the system identifier prescribed by the HTML 4.01 specification. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
29805:                                     }
29805:                                 } else {
29805:                                     err("Almost standards mode doctype. Expected e.g. \u201C<!DOCTYPE html>\u201D.");
29805:                                 }
29805:                                 documentModeInternal(
29805:                                         DocumentMode.ALMOST_STANDARDS_MODE,
41449:                                         publicIdentifier, systemIdentifier,
41449:                                         html4);
29805:                             } else {
29805:                                 if ("-//W3C//DTD HTML 4.01//EN".equals(publicIdentifier)) {
29805:                                     if (!"http://www.w3.org/TR/html4/strict.dtd".equals(systemIdentifier)) {
29805:                                         warn("The doctype did not contain the system identifier prescribed by the HTML 4.01 specification. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
29805:                                     }
29805:                                 } else {
29805:                                     if (!(publicIdentifier == null && systemIdentifier == null)) {
29805:                                         err("Legacy doctype. Expected e.g. \u201C<!DOCTYPE html>\u201D.");
29805:                                     }
29805:                                 }
29805:                                 documentModeInternal(
29805:                                         DocumentMode.STANDARDS_MODE,
41449:                                         publicIdentifier, systemIdentifier,
41449:                                         html4);
29805:                             }
29805:                             break;
29805:                         case NO_DOCTYPE_ERRORS:
29805:                             if (isQuirky(name, publicIdentifier,
29805:                                     systemIdentifier, forceQuirks)) {
41449:                                 documentModeInternal(DocumentMode.QUIRKS_MODE,
41449:                                         publicIdentifier, systemIdentifier,
41449:                                         false);
41449:                             } else if (isAlmostStandards(publicIdentifier,
41449:                                     systemIdentifier)) {
29805:                                 documentModeInternal(
29805:                                         DocumentMode.ALMOST_STANDARDS_MODE,
41449:                                         publicIdentifier, systemIdentifier,
41449:                                         false);
29805:                             } else {
29805:                                 documentModeInternal(
29805:                                         DocumentMode.STANDARDS_MODE,
41449:                                         publicIdentifier, systemIdentifier,
41449:                                         false);
29805:                             }
29805:                             break;
29805:                     }
29805:                     // ]NOCPP]
29805: 
29805:                     /*
29805:                      * 
29805:                      * Then, switch to the root element mode of the tree
29805:                      * construction stage.
29805:                      */
29805:                     mode = BEFORE_HTML;
29805:                     return;
29805:                 default:
41449:                     break;
41449:             }
29805:         }
29805:         /*
29805:          * A DOCTYPE token Parse error.
29805:          */
29805:         err("Stray doctype.");
29805:         /*
29805:          * Ignore the token.
29805:          */
29805:         return;
29805:     }
29805: 
29805:     // [NOCPP[
29805: 
29805:     private boolean isHtml4Doctype(String publicIdentifier) {
29805:         if (publicIdentifier != null
29805:                 && (Arrays.binarySearch(TreeBuilder.HTML4_PUBLIC_IDS,
29805:                         publicIdentifier) > -1)) {
29805:             return true;
29805:         }
29805:         return false;
29805:     }
29805: 
29805:     // ]NOCPP]
29805: 
29805:     public final void comment(@NoLength char[] buf, int start, int length)
29805:             throws SAXException {
29805:         needToDropLF = false;
29805:         // [NOCPP[
29805:         if (!wantingComments) {
29805:             return;
29805:         }
29805:         // ]NOCPP]
41449:         if (!inForeign) {
29805:             switch (mode) {
29805:                 case INITIAL:
29805:                 case BEFORE_HTML:
29805:                 case AFTER_AFTER_BODY:
29805:                 case AFTER_AFTER_FRAMESET:
29805:                     /*
40985:                      * A comment token Append a Comment node to the Document
40985:                      * object with the data attribute set to the data given in
40985:                      * the comment token.
29805:                      */
29805:                     appendCommentToDocument(buf, start, length);
29805:                     return;
29805:                 case AFTER_BODY:
29805:                     /*
40985:                      * A comment token Append a Comment node to the first
40985:                      * element in the stack of open elements (the html element),
40985:                      * with the data attribute set to the data given in the
40985:                      * comment token.
29805:                      */
29805:                     flushCharacters();
29805:                     appendComment(stack[0].node, buf, start, length);
29805:                     return;
29805:                 default:
40985:                     break;
29805:             }
29805:         }
29805:         /*
29805:          * A comment token Append a Comment node to the current node with the
29805:          * data attribute set to the data given in the comment token.
29805:          */
29805:         flushCharacters();
29805:         appendComment(stack[currentPtr].node, buf, start, length);
29805:         return;
29805:     }
29805: 
29805:     /**
29805:      * @see nu.validator.htmlparser.common.TokenHandler#characters(char[], int,
29805:      *      int)
29805:      */
39864:     public final void characters(@Const @NoLength char[] buf, int start, int length)
29805:             throws SAXException {
29805:         if (needToDropLF) {
29805:             if (buf[start] == '\n') {
29805:                 start++;
29805:                 length--;
29805:                 if (length == 0) {
29805:                     return;
29805:                 }
29805:             }
29805:             needToDropLF = false;
29805:         }
29805: 
46394:         if (inForeign) {
46394:             accumulateCharacters(buf, start, length);
46394:             return;
46394:         }
29805:         // optimize the most common case
29805:         switch (mode) {
29805:             case IN_BODY:
29805:             case IN_CELL:
29805:             case IN_CAPTION:
29805:                 reconstructTheActiveFormattingElements();
29805:                 // fall through
39864:             case TEXT:
29805:                 accumulateCharacters(buf, start, length);
29805:                 return;
29805:             default:
29805:                 int end = start + length;
29805:                 charactersloop: for (int i = start; i < end; i++) {
29805:                     switch (buf[i]) {
29805:                         case ' ':
29805:                         case '\t':
29805:                         case '\n':
39864:                         case '\r':
29805:                         case '\u000C':
29805:                             /*
29805:                              * A character token that is one of one of U+0009
29805:                              * CHARACTER TABULATION, U+000A LINE FEED (LF),
29805:                              * U+000C FORM FEED (FF), or U+0020 SPACE
29805:                              */
29805:                             switch (mode) {
29805:                                 case INITIAL:
29805:                                 case BEFORE_HTML:
29805:                                 case BEFORE_HEAD:
29805:                                     /*
29805:                                      * Ignore the token.
29805:                                      */
29805:                                     start = i + 1;
29805:                                     continue;
29805:                                 case FRAMESET_OK:
29805:                                 case IN_HEAD:
29805:                                 case IN_HEAD_NOSCRIPT:
29805:                                 case AFTER_HEAD:
29805:                                 case IN_COLUMN_GROUP:
29805:                                 case IN_FRAMESET:
29805:                                 case AFTER_FRAMESET:
29805:                                     /*
29805:                                      * Append the character to the current node.
29805:                                      */
29805:                                     continue;
29805:                                 case IN_BODY:
29805:                                 case IN_CELL:
29805:                                 case IN_CAPTION:
29805:                                     // XXX is this dead code?
29805:                                     if (start < i) {
29805:                                         accumulateCharacters(buf, start, i
29805:                                                 - start);
29805:                                         start = i;
29805:                                     }
29805: 
29805:                                     /*
29805:                                      * Reconstruct the active formatting
29805:                                      * elements, if any.
29805:                                      */
29805:                                     reconstructTheActiveFormattingElements();
29805:                                     /*
29805:                                      * Append the token's character to the
29805:                                      * current node.
29805:                                      */
29805:                                     break charactersloop;
29805:                                 case IN_SELECT:
29805:                                 case IN_SELECT_IN_TABLE:
29805:                                     break charactersloop;
29805:                                 case IN_TABLE:
29805:                                 case IN_TABLE_BODY:
29805:                                 case IN_ROW:
29805:                                     reconstructTheActiveFormattingElements();
29805:                                     accumulateCharacter(buf[i]);
29805:                                     start = i + 1;
29805:                                     continue;
29805:                                 case AFTER_BODY:
29805:                                     if (start < i) {
29805:                                         accumulateCharacters(buf, start, i
29805:                                                 - start);
29805:                                         start = i;
29805:                                     }
29805:                                     /*
29805:                                      * Reconstruct the active formatting
29805:                                      * elements, if any.
29805:                                      */
29805:                                     reconstructTheActiveFormattingElements();
29805:                                     /*
29805:                                      * Append the token's character to the
29805:                                      * current node.
29805:                                      */
29805:                                     continue;
29805:                                 case AFTER_AFTER_BODY:
29805:                                 case AFTER_AFTER_FRAMESET:
29805:                                     if (start < i) {
29805:                                         accumulateCharacters(buf, start, i
29805:                                                 - start);
29805:                                         start = i;
29805:                                     }
29805:                                     /*
29805:                                      * Reconstruct the active formatting
29805:                                      * elements, if any.
29805:                                      */
29805:                                     reconstructTheActiveFormattingElements();
29805:                                     /*
29805:                                      * Append the token's character to the
29805:                                      * current node.
29805:                                      */
29805:                                     continue;
29805:                             }
29805:                         default:
29805:                             /*
29805:                              * A character token that is not one of one of
29805:                              * U+0009 CHARACTER TABULATION, U+000A LINE FEED
29805:                              * (LF), U+000C FORM FEED (FF), or U+0020 SPACE
29805:                              */
29805:                             switch (mode) {
29805:                                 case INITIAL:
29805:                                     /*
29805:                                      * Parse error.
29805:                                      */
29805:                                     // [NOCPP[
29805:                                     switch (doctypeExpectation) {
29805:                                         case AUTO:
29805:                                             err("Non-space characters found without seeing a doctype first. Expected e.g. \u201C<!DOCTYPE html>\u201D.");
29805:                                             break;
29805:                                         case HTML:
29805:                                             err("Non-space characters found without seeing a doctype first. Expected \u201C<!DOCTYPE html>\u201D.");
29805:                                             break;
29805:                                         case HTML401_STRICT:
29805:                                             err("Non-space characters found without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
29805:                                             break;
29805:                                         case HTML401_TRANSITIONAL:
29805:                                             err("Non-space characters found without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
29805:                                             break;
29805:                                         case NO_DOCTYPE_ERRORS:
29805:                                     }
29805:                                     // ]NOCPP]
29805:                                     /*
29805:                                      * 
29805:                                      * Set the document to quirks mode.
29805:                                      */
29805:                                     documentModeInternal(
29805:                                             DocumentMode.QUIRKS_MODE, null,
29805:                                             null, false);
29805:                                     /*
29805:                                      * Then, switch to the root element mode of
29805:                                      * the tree construction stage
29805:                                      */
29805:                                     mode = BEFORE_HTML;
29805:                                     /*
29805:                                      * and reprocess the current token.
29805:                                      */
29805:                                     i--;
29805:                                     continue;
29805:                                 case BEFORE_HTML:
29805:                                     /*
29805:                                      * Create an HTMLElement node with the tag
29805:                                      * name html, in the HTML namespace. Append
29805:                                      * it to the Document object.
29805:                                      */
29805:                                     appendHtmlElementToDocumentAndPush();
29805:                                     /* Switch to the main mode */
29805:                                     mode = BEFORE_HEAD;
29805:                                     /*
29805:                                      * reprocess the current token.
29805:                                      */
29805:                                     i--;
29805:                                     continue;
29805:                                 case BEFORE_HEAD:
29805:                                     if (start < i) {
29805:                                         accumulateCharacters(buf, start, i
29805:                                                 - start);
29805:                                         start = i;
29805:                                     }
29805:                                     /*
29805:                                      * /Act as if a start tag token with the tag
29805:                                      * name "head" and no attributes had been
29805:                                      * seen,
29805:                                      */
29805:                                     appendToCurrentNodeAndPushHeadElement(HtmlAttributes.EMPTY_ATTRIBUTES);
29805:                                     mode = IN_HEAD;
29805:                                     /*
29805:                                      * then reprocess the current token.
29805:                                      * 
29805:                                      * This will result in an empty head element
29805:                                      * being generated, with the current token
29805:                                      * being reprocessed in the "after head"
29805:                                      * insertion mode.
29805:                                      */
29805:                                     i--;
29805:                                     continue;
29805:                                 case IN_HEAD:
29805:                                     if (start < i) {
29805:                                         accumulateCharacters(buf, start, i
29805:                                                 - start);
29805:                                         start = i;
29805:                                     }
29805:                                     /*
29805:                                      * Act as if an end tag token with the tag
29805:                                      * name "head" had been seen,
29805:                                      */
29805:                                     pop();
29805:                                     mode = AFTER_HEAD;
29805:                                     /*
29805:                                      * and reprocess the current token.
29805:                                      */
29805:                                     i--;
29805:                                     continue;
29805:                                 case IN_HEAD_NOSCRIPT:
29805:                                     if (start < i) {
29805:                                         accumulateCharacters(buf, start, i
29805:                                                 - start);
29805:                                         start = i;
29805:                                     }
29805:                                     /*
29805:                                      * Parse error. Act as if an end tag with
29805:                                      * the tag name "noscript" had been seen
29805:                                      */
29805:                                     err("Non-space character inside \u201Cnoscript\u201D inside \u201Chead\u201D.");
29805:                                     pop();
29805:                                     mode = IN_HEAD;
29805:                                     /*
29805:                                      * and reprocess the current token.
29805:                                      */
29805:                                     i--;
29805:                                     continue;
29805:                                 case AFTER_HEAD:
29805:                                     if (start < i) {
29805:                                         accumulateCharacters(buf, start, i
29805:                                                 - start);
29805:                                         start = i;
29805:                                     }
29805:                                     /*
29805:                                      * Act as if a start tag token with the tag
29805:                                      * name "body" and no attributes had been
29805:                                      * seen,
29805:                                      */
29805:                                     appendToCurrentNodeAndPushBodyElement();
29805:                                     mode = FRAMESET_OK;
29805:                                     /*
29805:                                      * and then reprocess the current token.
29805:                                      */
29805:                                     i--;
29805:                                     continue;
29805:                                 case FRAMESET_OK:
39864:                                     framesetOk = false;
29805:                                     mode = IN_BODY;
29805:                                     i--;
29805:                                     continue;
29805:                                 case IN_BODY:
29805:                                 case IN_CELL:
29805:                                 case IN_CAPTION:
29805:                                     if (start < i) {
29805:                                         accumulateCharacters(buf, start, i
29805:                                                 - start);
29805:                                         start = i;
29805:                                     }
29805:                                     /*
29805:                                      * Reconstruct the active formatting
29805:                                      * elements, if any.
29805:                                      */
29805:                                     reconstructTheActiveFormattingElements();
29805:                                     /*
29805:                                      * Append the token's character to the
29805:                                      * current node.
29805:                                      */
29805:                                     break charactersloop;
29805:                                 case IN_TABLE:
29805:                                 case IN_TABLE_BODY:
29805:                                 case IN_ROW:
29805:                                     reconstructTheActiveFormattingElements();
29805:                                     accumulateCharacter(buf[i]);
29805:                                     start = i + 1;
29805:                                     continue;
29805:                                 case IN_COLUMN_GROUP:
29805:                                     if (start < i) {
29805:                                         accumulateCharacters(buf, start, i
29805:                                                 - start);
29805:                                         start = i;
29805:                                     }
29805:                                     /*
29805:                                      * Act as if an end tag with the tag name
29805:                                      * "colgroup" had been seen, and then, if
29805:                                      * that token wasn't ignored, reprocess the
29805:                                      * current token.
29805:                                      */
29805:                                     if (currentPtr == 0) {
29805:                                         err("Non-space in \u201Ccolgroup\u201D when parsing fragment.");
29805:                                         start = i + 1;
29805:                                         continue;
29805:                                     }
29805:                                     pop();
29805:                                     mode = IN_TABLE;
29805:                                     i--;
29805:                                     continue;
29805:                                 case IN_SELECT:
29805:                                 case IN_SELECT_IN_TABLE:
29805:                                     break charactersloop;
29805:                                 case AFTER_BODY:
29805:                                     err("Non-space character after body.");
29805:                                     fatal();
39864:                                     mode = framesetOk ? FRAMESET_OK : IN_BODY;
29805:                                     i--;
29805:                                     continue;
29805:                                 case IN_FRAMESET:
29805:                                     if (start < i) {
29805:                                         accumulateCharacters(buf, start, i
29805:                                                 - start);
29805:                                         start = i;
29805:                                     }
29805:                                     /*
29805:                                      * Parse error.
29805:                                      */
29805:                                     err("Non-space in \u201Cframeset\u201D.");
29805:                                     /*
29805:                                      * Ignore the token.
29805:                                      */
29805:                                     start = i + 1;
29805:                                     continue;
29805:                                 case AFTER_FRAMESET:
29805:                                     if (start < i) {
29805:                                         accumulateCharacters(buf, start, i
29805:                                                 - start);
29805:                                         start = i;
29805:                                     }
29805:                                     /*
29805:                                      * Parse error.
29805:                                      */
29805:                                     err("Non-space after \u201Cframeset\u201D.");
29805:                                     /*
29805:                                      * Ignore the token.
29805:                                      */
29805:                                     start = i + 1;
29805:                                     continue;
29805:                                 case AFTER_AFTER_BODY:
29805:                                     /*
29805:                                      * Parse error.
29805:                                      */
29805:                                     err("Non-space character in page trailer.");
29805:                                     /*
29805:                                      * Switch back to the main mode and
29805:                                      * reprocess the token.
29805:                                      */
39864:                                     mode = framesetOk ? FRAMESET_OK : IN_BODY;
29805:                                     i--;
29805:                                     continue;
29805:                                 case AFTER_AFTER_FRAMESET:
29805:                                     /*
29805:                                      * Parse error.
29805:                                      */
29805:                                     err("Non-space character in page trailer.");
29805:                                     /*
29805:                                      * Switch back to the main mode and
29805:                                      * reprocess the token.
29805:                                      */
29805:                                     mode = IN_FRAMESET;
29805:                                     i--;
29805:                                     continue;
29805:                             }
29805:                     }
29805:                 }
29805:                 if (start < end) {
29805:                     accumulateCharacters(buf, start, end - start);
29805:                 }
29805:         }
29805:     }
29805: 
46394:     /**
46394:      * @see nu.validator.htmlparser.common.TokenHandler#zeroOriginatingReplacementCharacter()
46394:      */
46394:     @Override public void zeroOriginatingReplacementCharacter()
46394:             throws SAXException {
46394:         if (inForeign || mode == TEXT) {
46394:             characters(REPLACEMENT_CHARACTER, 0, 1);
46394:         }
46394:     }
46394: 
29805:     public final void eof() throws SAXException {
29805:         flushCharacters();
41449:         if (inForeign) {
29805:             err("End of file in a foreign namespace context.");
29805:             while (stack[currentPtr].ns != "http://www.w3.org/1999/xhtml") {
29805:                 popOnEof();
29805:             }
41449:             inForeign = false;
29805:         }
29805:         eofloop: for (;;) {
29805:             switch (mode) {
29805:                 case INITIAL:
29805:                     /*
29805:                      * Parse error.
29805:                      */
29805:                     // [NOCPP[
29805:                     switch (doctypeExpectation) {
29805:                         case AUTO:
29805:                             err("End of file seen without seeing a doctype first. Expected e.g. \u201C<!DOCTYPE html>\u201D.");
29805:                             break;
29805:                         case HTML:
29805:                             err("End of file seen without seeing a doctype first. Expected \u201C<!DOCTYPE html>\u201D.");
29805:                             break;
29805:                         case HTML401_STRICT:
29805:                             err("End of file seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
29805:                             break;
29805:                         case HTML401_TRANSITIONAL:
29805:                             err("End of file seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
29805:                             break;
29805:                         case NO_DOCTYPE_ERRORS:
29805:                     }
29805:                     // ]NOCPP]
29805:                     /*
29805:                      * 
29805:                      * Set the document to quirks mode.
29805:                      */
29805:                     documentModeInternal(DocumentMode.QUIRKS_MODE, null, null,
29805:                             false);
29805:                     /*
29805:                      * Then, switch to the root element mode of the tree
29805:                      * construction stage
29805:                      */
29805:                     mode = BEFORE_HTML;
29805:                     /*
29805:                      * and reprocess the current token.
29805:                      */
29805:                     continue;
29805:                 case BEFORE_HTML:
29805:                     /*
29805:                      * Create an HTMLElement node with the tag name html, in the
29805:                      * HTML namespace. Append it to the Document object.
29805:                      */
29805:                     appendHtmlElementToDocumentAndPush();
29805:                     // XXX application cache manifest
29805:                     /* Switch to the main mode */
29805:                     mode = BEFORE_HEAD;
29805:                     /*
29805:                      * reprocess the current token.
29805:                      */
29805:                     continue;
29805:                 case BEFORE_HEAD:
29805:                     appendToCurrentNodeAndPushHeadElement(HtmlAttributes.EMPTY_ATTRIBUTES);
29805:                     mode = IN_HEAD;
29805:                     continue;
29805:                 case IN_HEAD:
41449:                     if (errorHandler != null && currentPtr > 1) {
29805:                         err("End of file seen and there were open elements.");
29805:                     }
29805:                     while (currentPtr > 0) {
29805:                         popOnEof();
29805:                     }
29805:                     mode = AFTER_HEAD;
29805:                     continue;
29805:                 case IN_HEAD_NOSCRIPT:
29805:                     err("End of file seen and there were open elements.");
29805:                     while (currentPtr > 1) {
29805:                         popOnEof();
29805:                     }
29805:                     mode = IN_HEAD;
29805:                     continue;
29805:                 case AFTER_HEAD:
29805:                     appendToCurrentNodeAndPushBodyElement();
29805:                     mode = IN_BODY;
29805:                     continue;
29805:                 case IN_COLUMN_GROUP:
29805:                     if (currentPtr == 0) {
29805:                         assert fragment;
29805:                         break eofloop;
29805:                     } else {
29805:                         popOnEof();
29805:                         mode = IN_TABLE;
29805:                         continue;
29805:                     }
29805:                 case FRAMESET_OK:
29805:                 case IN_CAPTION:
29805:                 case IN_CELL:
29805:                 case IN_BODY:
29805:                     // [NOCPP[
29805:                     openelementloop: for (int i = currentPtr; i >= 0; i--) {
29805:                         int group = stack[i].group;
29805:                         switch (group) {
29805:                             case DD_OR_DT:
29805:                             case LI:
29805:                             case P:
29805:                             case TBODY_OR_THEAD_OR_TFOOT:
29805:                             case TD_OR_TH:
29805:                             case BODY:
29805:                             case HTML:
29805:                                 break;
29805:                             default:
29805:                                 err("End of file seen and there were open elements.");
29805:                                 break openelementloop;
29805:                         }
29805:                     }
29805:                     // ]NOCPP]
29805:                     break eofloop;
39864:                 case TEXT:
39864:                     err("End of file seen when expecting text or an end tag.");
29805:                     // XXX mark script as already executed
29805:                     if (originalMode == AFTER_HEAD) {
29805:                         popOnEof();
29805:                     }
29805:                     popOnEof();
29805:                     mode = originalMode;
29805:                     continue;
29805:                 case IN_TABLE_BODY:
29805:                 case IN_ROW:
29805:                 case IN_TABLE:
29805:                 case IN_SELECT:
29805:                 case IN_SELECT_IN_TABLE:
29805:                 case IN_FRAMESET:
41449:                     if (errorHandler != null && currentPtr > 0) {
41449:                         errNoCheck("End of file seen and there were open elements.");
29805:                     }
29805:                     break eofloop;
29805:                 case AFTER_BODY:
29805:                 case AFTER_FRAMESET:
29805:                 case AFTER_AFTER_BODY:
29805:                 case AFTER_AFTER_FRAMESET:
29805:                 default:
29805:                     // [NOCPP[
29805:                     if (currentPtr == 0) { // This silliness is here to poison
29805:                         // buggy compiler optimizations in
29805:                         // GWT
29805:                         System.currentTimeMillis();
29805:                     }
29805:                     // ]NOCPP]
29805:                     break eofloop;
29805:             }
29805:         }
29805:         while (currentPtr > 0) {
29805:             popOnEof();
29805:         }
29805:         if (!fragment) {
29805:             popOnEof();
29805:         }
29805:         /* Stop parsing. */
29805:     }
29805: 
29805:     /**
29805:      * @see nu.validator.htmlparser.common.TokenHandler#endTokenization()
29805:      */
29805:     public final void endTokenization() throws SAXException {
29805:         Portability.releaseElement(formPointer);
29805:         formPointer = null;
29805:         Portability.releaseElement(headPointer);
29805:         headPointer = null;
53890:         Portability.releaseElement(deepTreeSurrogateParent);
53890:         deepTreeSurrogateParent = null;
39864:         if (stack != null) {
29805:             while (currentPtr > -1) {
29805:                 stack[currentPtr].release();
29805:                 currentPtr--;
29805:             }
29805:             Portability.releaseArray(stack);
29805:             stack = null;
39864:         }
39864:         if (listOfActiveFormattingElements != null) {
29805:             while (listPtr > -1) {
29805:                 if (listOfActiveFormattingElements[listPtr] != null) {
29805:                     listOfActiveFormattingElements[listPtr].release();
29805:                 }
29805:                 listPtr--;
29805:             }
29805:             Portability.releaseArray(listOfActiveFormattingElements);
29805:             listOfActiveFormattingElements = null;
39864:         }
29805:         // [NOCPP[
29805:         idLocations.clear();
29805:         // ]NOCPP]
39864:         if (charBuffer != null) {
29805:             Portability.releaseArray(charBuffer);
29805:             charBuffer = null;
39864:         }
29805:         end();
29805:     }
29805: 
29805:     public final void startTag(ElementName elementName,
29805:             HtmlAttributes attributes, boolean selfClosing) throws SAXException {
29805:         // [NOCPP[
29805:         if (errorHandler != null) {
29805:             // ID uniqueness
29805:             @IdType String id = attributes.getId();
29805:             if (id != null) {
29805:                 LocatorImpl oldLoc = idLocations.get(id);
29805:                 if (oldLoc != null) {
29805:                     err("Duplicate ID \u201C" + id + "\u201D.");
29805:                     errorHandler.warning(new SAXParseException(
29805:                             "The first occurrence of ID \u201C" + id
29805:                             + "\u201D was here.", oldLoc));
29805:                 } else {
29805:                     idLocations.put(id, new LocatorImpl(tokenizer));
29805:                 }
29805:             }
29805:         }
29805:         // ]NOCPP]
29805: 
29805:         int eltPos;
29805:         needToDropLF = false;
29805:         boolean needsPostProcessing = false;
29805:         starttagloop: for (;;) {
29805:             int group = elementName.group;
29805:             @Local String name = elementName.name;
41449:             if (inForeign) {
29805:                 StackNode<T> currentNode = stack[currentPtr];
29805:                 @NsUri String currNs = currentNode.ns;
29805:                 int currGroup = currentNode.group;
29805:                 if (("http://www.w3.org/1999/xhtml" == currNs)
29805:                         || ("http://www.w3.org/1998/Math/MathML" == currNs && ((MGLYPH_OR_MALIGNMARK != group && MI_MO_MN_MS_MTEXT == currGroup) || (SVG == group && ANNOTATION_XML == currGroup)))
29805:                         || ("http://www.w3.org/2000/svg" == currNs && (TITLE == currGroup || (FOREIGNOBJECT_OR_DESC == currGroup)))) {
29805:                     needsPostProcessing = true;
29805:                     // fall through to non-foreign behavior
29805:                 } else {
29805:                     switch (group) {
29805:                         case B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U:
29805:                         case DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU:
29805:                         case BODY:
29805:                         case BR:
29805:                         case RUBY_OR_SPAN_OR_SUB_OR_SUP_OR_VAR:
29805:                         case DD_OR_DT:
29805:                         case UL_OR_OL_OR_DL:
29805:                         case EMBED_OR_IMG:
29805:                         case H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6:
29805:                         case HEAD:
29805:                         case HR:
29805:                         case LI:
29805:                         case META:
29805:                         case NOBR:
29805:                         case P:
29805:                         case PRE_OR_LISTING:
29805:                         case TABLE:
29805:                             err("HTML start tag \u201C"
29805:                                     + name
29805:                                     + "\u201D in a foreign namespace context.");
29805:                             while (stack[currentPtr].ns != "http://www.w3.org/1999/xhtml") {
29805:                                 pop();
29805:                             }
41449:                             inForeign = false;
29805:                             continue starttagloop;
29805:                         case FONT:
39864:                             if (attributes.contains(AttributeName.COLOR)
39864:                                     || attributes.contains(AttributeName.FACE)
39864:                                     || attributes.contains(AttributeName.SIZE)) {
29805:                                 err("HTML start tag \u201C"
29805:                                         + name
29805:                                         + "\u201D in a foreign namespace context.");
29805:                                 while (stack[currentPtr].ns != "http://www.w3.org/1999/xhtml") {
29805:                                     pop();
29805:                                 }
41449:                                 inForeign = false;
29805:                                 continue starttagloop;
29805:                             }
29805:                             // else fall thru
29805:                         default:
29805:                             if ("http://www.w3.org/2000/svg" == currNs) {
29805:                                 attributes.adjustForSvg();
29805:                                 if (selfClosing) {
29805:                                     appendVoidElementToCurrentMayFosterCamelCase(
29805:                                             currNs, elementName, attributes);
29805:                                     selfClosing = false;
29805:                                 } else {
29805:                                     appendToCurrentNodeAndPushElementMayFosterCamelCase(
29805:                                             currNs, elementName, attributes);
29805:                                 }
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             } else {
29805:                                 attributes.adjustForMath();
29805:                                 if (selfClosing) {
29805:                                     appendVoidElementToCurrentMayFoster(
29805:                                             currNs, elementName, attributes);
29805:                                     selfClosing = false;
29805:                                 } else {
29805:                                     appendToCurrentNodeAndPushElementMayFosterNoScoping(
29805:                                             currNs, elementName, attributes);
29805:                                 }
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             }
41449:                     } // switch
41449:                 } // foreignObject / annotation-xml
41449:             }
29805:             switch (mode) {
29805:                 case IN_TABLE_BODY:
29805:                     switch (group) {
29805:                         case TR:
29805:                             clearStackBackTo(findLastInTableScopeOrRootTbodyTheadTfoot());
29805:                             appendToCurrentNodeAndPushElement(
29805:                                     "http://www.w3.org/1999/xhtml",
29805:                                     elementName, attributes);
29805:                             mode = IN_ROW;
39864:                             attributes = null; // CPP
29805:                             break starttagloop;
29805:                         case TD_OR_TH:
29805:                             err("\u201C" + name
29805:                                     + "\u201D start tag in table body.");
29805:                             clearStackBackTo(findLastInTableScopeOrRootTbodyTheadTfoot());
29805:                             appendToCurrentNodeAndPushElement(
29805:                                     "http://www.w3.org/1999/xhtml",
29805:                                     ElementName.TR,
29805:                                     HtmlAttributes.EMPTY_ATTRIBUTES);
29805:                             mode = IN_ROW;
29805:                             continue;
29805:                         case CAPTION:
29805:                         case COL:
29805:                         case COLGROUP:
29805:                         case TBODY_OR_THEAD_OR_TFOOT:
29805:                             eltPos = findLastInTableScopeOrRootTbodyTheadTfoot();
29805:                             if (eltPos == 0) {
41449:                                 err("Stray \u201C" + name + "\u201D start tag.");
29805:                                 break starttagloop;
29805:                             } else {
29805:                                 clearStackBackTo(eltPos);
29805:                                 pop();
29805:                                 mode = IN_TABLE;
29805:                                 continue;
29805:                             }
29805:                         default:
29805:                             // fall through to IN_TABLE
29805:                     }
29805:                 case IN_ROW:
29805:                     switch (group) {
29805:                         case TD_OR_TH:
29805:                             clearStackBackTo(findLastOrRoot(TreeBuilder.TR));
29805:                             appendToCurrentNodeAndPushElement(
29805:                                     "http://www.w3.org/1999/xhtml",
29805:                                     elementName, attributes);
29805:                             mode = IN_CELL;
29805:                             insertMarker();
39864:                             attributes = null; // CPP
29805:                             break starttagloop;
29805:                         case CAPTION:
29805:                         case COL:
29805:                         case COLGROUP:
29805:                         case TBODY_OR_THEAD_OR_TFOOT:
29805:                         case TR:
29805:                             eltPos = findLastOrRoot(TreeBuilder.TR);
29805:                             if (eltPos == 0) {
29805:                                 assert fragment;
29805:                                 err("No table row to close.");
29805:                                 break starttagloop;
29805:                             }
29805:                             clearStackBackTo(eltPos);
29805:                             pop();
29805:                             mode = IN_TABLE_BODY;
29805:                             continue;
29805:                         default:
29805:                             // fall through to IN_TABLE
29805:                     }
29805:                 case IN_TABLE:
29805:                     intableloop: for (;;) {
29805:                         switch (group) {
29805:                             case CAPTION:
29805:                                 clearStackBackTo(findLastOrRoot(TreeBuilder.TABLE));
29805:                                 insertMarker();
29805:                                 appendToCurrentNodeAndPushElement(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         elementName, attributes);
29805:                                 mode = IN_CAPTION;
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case COLGROUP:
29805:                                 clearStackBackTo(findLastOrRoot(TreeBuilder.TABLE));
29805:                                 appendToCurrentNodeAndPushElement(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         elementName, attributes);
29805:                                 mode = IN_COLUMN_GROUP;
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case COL:
29805:                                 clearStackBackTo(findLastOrRoot(TreeBuilder.TABLE));
29805:                                 appendToCurrentNodeAndPushElement(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         ElementName.COLGROUP,
29805:                                         HtmlAttributes.EMPTY_ATTRIBUTES);
29805:                                 mode = IN_COLUMN_GROUP;
29805:                                 continue starttagloop;
29805:                             case TBODY_OR_THEAD_OR_TFOOT:
29805:                                 clearStackBackTo(findLastOrRoot(TreeBuilder.TABLE));
29805:                                 appendToCurrentNodeAndPushElement(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         elementName, attributes);
29805:                                 mode = IN_TABLE_BODY;
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case TR:
29805:                             case TD_OR_TH:
29805:                                 clearStackBackTo(findLastOrRoot(TreeBuilder.TABLE));
29805:                                 appendToCurrentNodeAndPushElement(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         ElementName.TBODY,
29805:                                         HtmlAttributes.EMPTY_ATTRIBUTES);
29805:                                 mode = IN_TABLE_BODY;
29805:                                 continue starttagloop;
29805:                             case TABLE:
29805:                                 err("Start tag for \u201Ctable\u201D seen but the previous \u201Ctable\u201D is still open.");
29805:                                 eltPos = findLastInTableScope(name);
29805:                                 if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
29805:                                     assert fragment;
29805:                                     break starttagloop;
29805:                                 }
29805:                                 generateImpliedEndTags();
29805:                                 // XXX is the next if dead code?
41449:                                 if (errorHandler != null && !isCurrent("table")) {
41449:                                     errNoCheck("Unclosed elements on stack.");
29805:                                 }
29805:                                 while (currentPtr >= eltPos) {
29805:                                     pop();
29805:                                 }
29805:                                 resetTheInsertionMode();
29805:                                 continue starttagloop;
29805:                             case SCRIPT:
29805:                                 // XXX need to manage much more stuff
29805:                                 // here if
29805:                                 // supporting
29805:                                 // document.write()
29805:                                 appendToCurrentNodeAndPushElement(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         elementName, attributes);
29805:                                 originalMode = mode;
39864:                                 mode = TEXT;
40985:                                 tokenizer.setStateAndEndTagExpectation(
39864:                                         Tokenizer.SCRIPT_DATA, elementName);
39864:                                 attributes = null; // CPP
39864:                                 break starttagloop;
39864:                             case STYLE:
39864:                                 appendToCurrentNodeAndPushElement(
39864:                                         "http://www.w3.org/1999/xhtml",
39864:                                         elementName, attributes);
39864:                                 originalMode = mode;
39864:                                 mode = TEXT;
40985:                                 tokenizer.setStateAndEndTagExpectation(
39864:                                         Tokenizer.RAWTEXT, elementName);
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case INPUT:
29805:                                 if (!Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
29805:                                         "hidden",
29805:                                         attributes.getValue(AttributeName.TYPE))) {
29805:                                     break intableloop;
29805:                                 }
29805:                                 appendVoidElementToCurrent(
41449:                                         "http://www.w3.org/1999/xhtml", name,
41449:                                         attributes, formPointer);
29805:                                 selfClosing = false;
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
39864:                             case FORM:
39864:                                 if (formPointer != null) {
39864:                                     err("Saw a \u201Cform\u201D start tag, but there was already an active \u201Cform\u201D element. Nested forms are not allowed. Ignoring the tag.");
39864:                                     break starttagloop;
39864:                                 } else {
39864:                                     err("Start tag \u201Cform\u201D seen in \u201Ctable\u201D.");
39864:                                     appendVoidFormToCurrent(attributes);
39864:                                     attributes = null; // CPP
39864:                                     break starttagloop;
39864:                                 }
29805:                             default:
41449:                                 err("Start tag \u201C" + name
29805:                                         + "\u201D seen in \u201Ctable\u201D.");
29805:                                 // fall through to IN_BODY
29805:                                 break intableloop;
29805:                         }
29805:                     }
29805:                 case IN_CAPTION:
29805:                     switch (group) {
29805:                         case CAPTION:
29805:                         case COL:
29805:                         case COLGROUP:
29805:                         case TBODY_OR_THEAD_OR_TFOOT:
29805:                         case TR:
29805:                         case TD_OR_TH:
29805:                             err("Stray \u201C"
29805:                                     + name
29805:                                     + "\u201D start tag in \u201Ccaption\u201D.");
29805:                             eltPos = findLastInTableScope("caption");
29805:                             if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
29805:                                 break starttagloop;
29805:                             }
29805:                             generateImpliedEndTags();
41449:                             if (errorHandler != null && currentPtr != eltPos) {
41449:                                 errNoCheck("Unclosed elements on stack.");
29805:                             }
29805:                             while (currentPtr >= eltPos) {
29805:                                 pop();
29805:                             }
29805:                             clearTheListOfActiveFormattingElementsUpToTheLastMarker();
29805:                             mode = IN_TABLE;
29805:                             continue;
29805:                         default:
29805:                             // fall through to IN_BODY
29805:                     }
29805:                 case IN_CELL:
29805:                     switch (group) {
29805:                         case CAPTION:
29805:                         case COL:
29805:                         case COLGROUP:
29805:                         case TBODY_OR_THEAD_OR_TFOOT:
29805:                         case TR:
29805:                         case TD_OR_TH:
29805:                             eltPos = findLastInTableScopeTdTh();
29805:                             if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
29805:                                 err("No cell to close.");
29805:                                 break starttagloop;
29805:                             } else {
29805:                                 closeTheCell(eltPos);
29805:                                 continue;
29805:                             }
29805:                         default:
29805:                             // fall through to IN_BODY
29805:                     }
29805:                 case FRAMESET_OK:
29805:                     switch (group) {
29805:                         case FRAMESET:
29805:                             if (mode == FRAMESET_OK) {
41449:                                 if (currentPtr == 0 || stack[1].group != BODY) {
29805:                                     assert fragment;
29805:                                     err("Stray \u201Cframeset\u201D start tag.");
29805:                                     break starttagloop;
29805:                                 } else {
39864:                                     err("\u201Cframeset\u201D start tag seen.");
29805:                                     detachFromParent(stack[1].node);
29805:                                     while (currentPtr > 0) {
29805:                                         pop();
29805:                                     }
29805:                                     appendToCurrentNodeAndPushElement(
29805:                                             "http://www.w3.org/1999/xhtml",
29805:                                             elementName, attributes);
29805:                                     mode = IN_FRAMESET;
39864:                                     attributes = null; // CPP
29805:                                     break starttagloop;
29805:                                 }
29805:                             } else {
29805:                                 err("Stray \u201Cframeset\u201D start tag.");
29805:                                 break starttagloop;
29805:                             }
29805:                             // NOT falling through!
29805:                         case PRE_OR_LISTING:
29805:                         case LI:
29805:                         case DD_OR_DT:
29805:                         case BUTTON:
29805:                         case MARQUEE_OR_APPLET:
29805:                         case OBJECT:
29805:                         case TABLE:
46393:                         case AREA_OR_SPACER_OR_WBR:
29805:                         case BR:
29805:                         case EMBED_OR_IMG:
29805:                         case INPUT:
29805:                         case KEYGEN:
29805:                         case HR:
29805:                         case TEXTAREA:
29805:                         case XMP:
29805:                         case IFRAME:
29805:                         case SELECT:
29805:                             if (mode == FRAMESET_OK) {
39864:                                 framesetOk = false;
29805:                                 mode = IN_BODY;
29805:                             }
29805:                             // fall through to IN_BODY
29805:                         default:
29805:                             // fall through to IN_BODY
29805:                     }
29805:                 case IN_BODY:
29805:                     inbodyloop: for (;;) {
29805:                         switch (group) {
29805:                             case HTML:
29805:                                 err("Stray \u201Chtml\u201D start tag.");
43391:                                 if (!fragment) {
29805:                                     addAttributesToHtml(attributes);
39864:                                     attributes = null; // CPP
43391:                                 }
29805:                                 break starttagloop;
29805:                             case BASE:
46393:                             case LINK_OR_BASEFONT_OR_BGSOUND:
29805:                             case META:
29805:                             case STYLE:
29805:                             case SCRIPT:
29805:                             case TITLE:
39864:                             case COMMAND:
29805:                                 // Fall through to IN_HEAD
29805:                                 break inbodyloop;
29805:                             case BODY:
29805:                                 err("\u201Cbody\u201D start tag found but the \u201Cbody\u201D element is already open.");
43391:                                 if (addAttributesToBody(attributes)) {
39864:                                     attributes = null; // CPP
43391:                                 }
29805:                                 break starttagloop;
29805:                             case P:
29805:                             case DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU:
29805:                             case UL_OR_OL_OR_DL:
39864:                             case ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_HGROUP_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION:
29805:                                 implicitlyCloseP();
29805:                                 appendToCurrentNodeAndPushElementMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         elementName, attributes);
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6:
29805:                                 implicitlyCloseP();
29805:                                 if (stack[currentPtr].group == H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6) {
29805:                                     err("Heading cannot be a child of another heading.");
29805:                                     pop();
29805:                                 }
29805:                                 appendToCurrentNodeAndPushElementMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         elementName, attributes);
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case FIELDSET:
29805:                                 implicitlyCloseP();
29805:                                 appendToCurrentNodeAndPushElementMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
41449:                                         elementName, attributes, formPointer);
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case PRE_OR_LISTING:
29805:                                 implicitlyCloseP();
29805:                                 appendToCurrentNodeAndPushElementMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         elementName, attributes);
29805:                                 needToDropLF = true;
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case FORM:
29805:                                 if (formPointer != null) {
29805:                                     err("Saw a \u201Cform\u201D start tag, but there was already an active \u201Cform\u201D element. Nested forms are not allowed. Ignoring the tag.");
29805:                                     break starttagloop;
29805:                                 } else {
29805:                                     implicitlyCloseP();
29805:                                     appendToCurrentNodeAndPushFormElementMayFoster(attributes);
39864:                                     attributes = null; // CPP
29805:                                     break starttagloop;
29805:                                 }
29805:                             case LI:
29805:                             case DD_OR_DT:
29805:                                 eltPos = currentPtr;
29805:                                 for (;;) {
39864:                                     StackNode<T> node = stack[eltPos]; // weak
39864:                                     // ref
29805:                                     if (node.group == group) { // LI or
29805:                                         // DD_OR_DT
29805:                                         generateImpliedEndTagsExceptFor(node.name);
41449:                                         if (errorHandler != null
41449:                                                 && eltPos != currentPtr) {
41449:                                             errNoCheck("Unclosed elements inside a list.");
29805:                                         }
29805:                                         while (currentPtr >= eltPos) {
29805:                                             pop();
29805:                                         }
29805:                                         break;
29805:                                     } else if (node.scoping
29805:                                             || (node.special
29805:                                                     && node.name != "p"
29805:                                                     && node.name != "address" && node.name != "div")) {
29805:                                         break;
29805:                                     }
29805:                                     eltPos--;
29805:                                 }
29805:                                 implicitlyCloseP();
29805:                                 appendToCurrentNodeAndPushElementMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         elementName, attributes);
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case PLAINTEXT:
29805:                                 implicitlyCloseP();
29805:                                 appendToCurrentNodeAndPushElementMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         elementName, attributes);
40985:                                 tokenizer.setStateAndEndTagExpectation(
41449:                                         Tokenizer.PLAINTEXT, elementName);
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case A:
29805:                                 int activeAPos = findInListOfActiveFormattingElementsContainsBetweenEndAndLastMarker("a");
29805:                                 if (activeAPos != -1) {
29805:                                     err("An \u201Ca\u201D start tag seen with already an active \u201Ca\u201D element.");
29805:                                     StackNode<T> activeA = listOfActiveFormattingElements[activeAPos];
29805:                                     activeA.retain();
29805:                                     adoptionAgencyEndTag("a");
29805:                                     removeFromStack(activeA);
29805:                                     activeAPos = findInListOfActiveFormattingElements(activeA);
29805:                                     if (activeAPos != -1) {
29805:                                         removeFromListOfActiveFormattingElements(activeAPos);
29805:                                     }
29805:                                     activeA.release();
29805:                                 }
29805:                                 reconstructTheActiveFormattingElements();
29805:                                 appendToCurrentNodeAndPushFormattingElementMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         elementName, attributes);
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U:
29805:                             case FONT:
29805:                                 reconstructTheActiveFormattingElements();
29805:                                 appendToCurrentNodeAndPushFormattingElementMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         elementName, attributes);
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case NOBR:
29805:                                 reconstructTheActiveFormattingElements();
29805:                                 if (TreeBuilder.NOT_FOUND_ON_STACK != findLastInScope("nobr")) {
29805:                                     err("\u201Cnobr\u201D start tag seen when there was an open \u201Cnobr\u201D element in scope.");
29805:                                     adoptionAgencyEndTag("nobr");
29805:                                 }
29805:                                 appendToCurrentNodeAndPushFormattingElementMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         elementName, attributes);
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case BUTTON:
29805:                                 eltPos = findLastInScope(name);
29805:                                 if (eltPos != TreeBuilder.NOT_FOUND_ON_STACK) {
29805:                                     err("\u201Cbutton\u201D start tag seen when there was an open \u201Cbutton\u201D element in scope.");
40920: 
29805:                                     generateImpliedEndTags();
41449:                                     if (errorHandler != null
41449:                                             && !isCurrent(name)) {
41449:                                         errNoCheck("End tag \u201Cbutton\u201D seen but there were unclosed elements.");
29805:                                     }
29805:                                     while (currentPtr >= eltPos) {
29805:                                         pop();
29805:                                     }
29805:                                     continue starttagloop;
29805:                                 } else {
29805:                                     reconstructTheActiveFormattingElements();
29805:                                     appendToCurrentNodeAndPushElementMayFoster(
29805:                                             "http://www.w3.org/1999/xhtml",
29805:                                             elementName, attributes,
29805:                                             formPointer);
39864:                                     attributes = null; // CPP
29805:                                     break starttagloop;
29805:                                 }
29805:                             case OBJECT:
29805:                                 reconstructTheActiveFormattingElements();
29805:                                 appendToCurrentNodeAndPushElementMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
41449:                                         elementName, attributes, formPointer);
29805:                                 insertMarker();
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case MARQUEE_OR_APPLET:
29805:                                 reconstructTheActiveFormattingElements();
29805:                                 appendToCurrentNodeAndPushElementMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         elementName, attributes);
29805:                                 insertMarker();
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case TABLE:
39864:                                 // The only quirk. Blame Hixie and
39864:                                 // Acid2.
29805:                                 if (!quirks) {
29805:                                     implicitlyCloseP();
29805:                                 }
29805:                                 appendToCurrentNodeAndPushElementMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         elementName, attributes);
29805:                                 mode = IN_TABLE;
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case BR:
29805:                             case EMBED_OR_IMG:
46393:                             case AREA_OR_SPACER_OR_WBR:
29805:                                 reconstructTheActiveFormattingElements();
29805:                                 // FALL THROUGH to PARAM_OR_SOURCE
29805:                             case PARAM_OR_SOURCE:
29805:                                 appendVoidElementToCurrentMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         elementName, attributes);
29805:                                 selfClosing = false;
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case HR:
29805:                                 implicitlyCloseP();
29805:                                 appendVoidElementToCurrentMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         elementName, attributes);
29805:                                 selfClosing = false;
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case IMAGE:
29805:                                 err("Saw a start tag \u201Cimage\u201D.");
29805:                                 elementName = ElementName.IMG;
29805:                                 continue starttagloop;
29805:                             case KEYGEN:
29805:                             case INPUT:
29805:                                 reconstructTheActiveFormattingElements();
29805:                                 appendVoidElementToCurrentMayFoster(
41449:                                         "http://www.w3.org/1999/xhtml", name,
41449:                                         attributes, formPointer);
29805:                                 selfClosing = false;
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case ISINDEX:
29805:                                 err("\u201Cisindex\u201D seen.");
29805:                                 if (formPointer != null) {
29805:                                     break starttagloop;
29805:                                 }
29805:                                 implicitlyCloseP();
41449:                                 HtmlAttributes formAttrs = new HtmlAttributes(0);
29805:                                 int actionIndex = attributes.getIndex(AttributeName.ACTION);
29805:                                 if (actionIndex > -1) {
29805:                                     formAttrs.addAttribute(
29805:                                             AttributeName.ACTION,
29805:                                             attributes.getValue(actionIndex)
29805:                                             // [NOCPP[
29805:                                             , XmlViolationPolicy.ALLOW
29805:                                     // ]NOCPP]
29805:                                     );
29805:                                 }
29805:                                 appendToCurrentNodeAndPushFormElementMayFoster(formAttrs);
29805:                                 appendVoidElementToCurrentMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         ElementName.HR,
29805:                                         HtmlAttributes.EMPTY_ATTRIBUTES);
29805:                                 appendToCurrentNodeAndPushElementMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         ElementName.LABEL,
29805:                                         HtmlAttributes.EMPTY_ATTRIBUTES);
29805:                                 int promptIndex = attributes.getIndex(AttributeName.PROMPT);
29805:                                 if (promptIndex > -1) {
29805:                                     char[] prompt = Portability.newCharArrayFromString(attributes.getValue(promptIndex));
41449:                                     appendCharacters(stack[currentPtr].node,
29805:                                             prompt, 0, prompt.length);
29805:                                     Portability.releaseArray(prompt);
29805:                                 } else {
44175:                                     appendIsindexPrompt(stack[currentPtr].node);
29805:                                 }
39864:                                 HtmlAttributes inputAttributes = new HtmlAttributes(
39864:                                         0);
29805:                                 inputAttributes.addAttribute(
39864:                                         AttributeName.NAME,
39864:                                         Portability.newStringFromLiteral("isindex")
29805:                                         // [NOCPP[
29805:                                         , XmlViolationPolicy.ALLOW
29805:                                 // ]NOCPP]
29805:                                 );
29805:                                 for (int i = 0; i < attributes.getLength(); i++) {
29805:                                     AttributeName attributeQName = attributes.getAttributeName(i);
39864:                                     if (AttributeName.NAME == attributeQName
39864:                                             || AttributeName.PROMPT == attributeQName) {
30007:                                         attributes.releaseValue(i);
30007:                                     } else if (AttributeName.ACTION != attributeQName) {
29805:                                         inputAttributes.addAttribute(
29805:                                                 attributeQName,
29805:                                                 attributes.getValue(i)
29805:                                                 // [NOCPP[
41449:                                                 , XmlViolationPolicy.ALLOW
29805:                                         // ]NOCPP]
29805: 
29805:                                         );
29805:                                     }
29805:                                 }
29805:                                 attributes.clearWithoutReleasingContents();
29805:                                 appendVoidElementToCurrentMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
41449:                                         "input", inputAttributes, formPointer);
29805:                                 pop(); // label
29805:                                 appendVoidElementToCurrentMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         ElementName.HR,
29805:                                         HtmlAttributes.EMPTY_ATTRIBUTES);
29805:                                 pop(); // form
29805:                                 selfClosing = false;
39864:                                 // Portability.delete(formAttrs);
39864:                                 // Portability.delete(inputAttributes);
41449:                                 // Don't delete attributes, they are deleted
41449:                                 // later
29805:                                 break starttagloop;
29805:                             case TEXTAREA:
29805:                                 appendToCurrentNodeAndPushElementMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
41449:                                         elementName, attributes, formPointer);
40985:                                 tokenizer.setStateAndEndTagExpectation(
29805:                                         Tokenizer.RCDATA, elementName);
29805:                                 originalMode = mode;
39864:                                 mode = TEXT;
29805:                                 needToDropLF = true;
39864:                                 attributes = null; // CPP
39864:                                 break starttagloop;
39864:                             case XMP:
39864:                                 implicitlyCloseP();
39864:                                 reconstructTheActiveFormattingElements();
39864:                                 appendToCurrentNodeAndPushElementMayFoster(
39864:                                         "http://www.w3.org/1999/xhtml",
39864:                                         elementName, attributes);
39864:                                 originalMode = mode;
39864:                                 mode = TEXT;
40985:                                 tokenizer.setStateAndEndTagExpectation(
39864:                                         Tokenizer.RAWTEXT, elementName);
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case NOSCRIPT:
29805:                                 if (!scriptingEnabled) {
29805:                                     reconstructTheActiveFormattingElements();
29805:                                     appendToCurrentNodeAndPushElementMayFoster(
29805:                                             "http://www.w3.org/1999/xhtml",
29805:                                             elementName, attributes);
39864:                                     attributes = null; // CPP
29805:                                     break starttagloop;
29805:                                 } else {
29805:                                     // fall through
29805:                                 }
29805:                             case NOFRAMES:
29805:                             case IFRAME:
29805:                             case NOEMBED:
29805:                                 appendToCurrentNodeAndPushElementMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         elementName, attributes);
29805:                                 originalMode = mode;
39864:                                 mode = TEXT;
40985:                                 tokenizer.setStateAndEndTagExpectation(
39864:                                         Tokenizer.RAWTEXT, elementName);
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case SELECT:
29805:                                 reconstructTheActiveFormattingElements();
29805:                                 appendToCurrentNodeAndPushElementMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
41449:                                         elementName, attributes, formPointer);
29805:                                 switch (mode) {
29805:                                     case IN_TABLE:
29805:                                     case IN_CAPTION:
29805:                                     case IN_COLUMN_GROUP:
29805:                                     case IN_TABLE_BODY:
29805:                                     case IN_ROW:
29805:                                     case IN_CELL:
29805:                                         mode = IN_SELECT_IN_TABLE;
29805:                                         break;
29805:                                     default:
29805:                                         mode = IN_SELECT;
29805:                                         break;
29805:                                 }
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case OPTGROUP:
29805:                             case OPTION:
29805:                                 /*
41449:                                  * If the stack of open elements has an option
41449:                                  * element in scope, then act as if an end tag
41449:                                  * with the tag name "option" had been seen.
29805:                                  */
29805:                                 if (findLastInScope("option") != TreeBuilder.NOT_FOUND_ON_STACK) {
29805:                                     optionendtagloop: for (;;) {
29805:                                         if (isCurrent("option")) {
29805:                                             pop();
29805:                                             break optionendtagloop;
29805:                                         }
29805: 
29805:                                         eltPos = currentPtr;
29805:                                         for (;;) {
29805:                                             if (stack[eltPos].name == "option") {
29805:                                                 generateImpliedEndTags();
41449:                                                 if (errorHandler != null
41449:                                                         && !isCurrent("option")) {
41449:                                                     errNoCheck("End tag \u201C"
29805:                                                             + name
29805:                                                             + "\u201D seen but there were unclosed elements.");
29805:                                                 }
29805:                                                 while (currentPtr >= eltPos) {
29805:                                                     pop();
29805:                                                 }
29805:                                                 break optionendtagloop;
29805:                                             }
29805:                                             eltPos--;
29805:                                         }
29805:                                     }
29805:                                 }
29805:                                 /*
41449:                                  * Reconstruct the active formatting elements,
41449:                                  * if any.
29805:                                  */
29805:                                 reconstructTheActiveFormattingElements();
29805:                                 /*
29805:                                  * Insert an HTML element for the token.
29805:                                  */
29805:                                 appendToCurrentNodeAndPushElementMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         elementName, attributes);
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case RT_OR_RP:
29805:                                 /*
41449:                                  * If the stack of open elements has a ruby
41449:                                  * element in scope, then generate implied end
41449:                                  * tags. If the current node is not then a ruby
41449:                                  * element, this is a parse error; pop all the
41449:                                  * nodes from the current node up to the node
41449:                                  * immediately before the bottommost ruby
41449:                                  * element on the stack of open elements.
29805:                                  * 
29805:                                  * Insert an HTML element for the token.
29805:                                  */
29805:                                 eltPos = findLastInScope("ruby");
29805:                                 if (eltPos != NOT_FOUND_ON_STACK) {
29805:                                     generateImpliedEndTags();
29805:                                 }
29805:                                 if (eltPos != currentPtr) {
29805:                                     err("Unclosed children in \u201Cruby\u201D.");
29805:                                     while (currentPtr > eltPos) {
29805:                                         pop();
29805:                                     }
29805:                                 }
29805:                                 appendToCurrentNodeAndPushElementMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         elementName, attributes);
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case MATH:
29805:                                 reconstructTheActiveFormattingElements();
29805:                                 attributes.adjustForMath();
29805:                                 if (selfClosing) {
29805:                                     appendVoidElementToCurrentMayFoster(
29805:                                             "http://www.w3.org/1998/Math/MathML",
29805:                                             elementName, attributes);
29805:                                     selfClosing = false;
29805:                                 } else {
29805:                                     appendToCurrentNodeAndPushElementMayFoster(
29805:                                             "http://www.w3.org/1998/Math/MathML",
29805:                                             elementName, attributes);
41449:                                     inForeign = true;
29805:                                 }
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case SVG:
29805:                                 reconstructTheActiveFormattingElements();
29805:                                 attributes.adjustForSvg();
29805:                                 if (selfClosing) {
29805:                                     appendVoidElementToCurrentMayFosterCamelCase(
29805:                                             "http://www.w3.org/2000/svg",
29805:                                             elementName, attributes);
29805:                                     selfClosing = false;
29805:                                 } else {
29805:                                     appendToCurrentNodeAndPushElementMayFoster(
29805:                                             "http://www.w3.org/2000/svg",
29805:                                             elementName, attributes);
41449:                                     inForeign = true;
29805:                                 }
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case CAPTION:
29805:                             case COL:
29805:                             case COLGROUP:
29805:                             case TBODY_OR_THEAD_OR_TFOOT:
29805:                             case TR:
29805:                             case TD_OR_TH:
29805:                             case FRAME:
29805:                             case FRAMESET:
29805:                             case HEAD:
41449:                                 err("Stray start tag \u201C" + name + "\u201D.");
29805:                                 break starttagloop;
29805:                             case OUTPUT_OR_LABEL:
29805:                                 reconstructTheActiveFormattingElements();
29805:                                 appendToCurrentNodeAndPushElementMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
41449:                                         elementName, attributes, formPointer);
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             default:
29805:                                 reconstructTheActiveFormattingElements();
29805:                                 appendToCurrentNodeAndPushElementMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         elementName, attributes);
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                         }
29805:                     }
29805:                 case IN_HEAD:
29805:                     inheadloop: for (;;) {
29805:                         switch (group) {
29805:                             case HTML:
29805:                                 err("Stray \u201Chtml\u201D start tag.");
43391:                                 if (!fragment) {
29805:                                     addAttributesToHtml(attributes);
39864:                                     attributes = null; // CPP
43391:                                 }
29805:                                 break starttagloop;
29805:                             case BASE:
39864:                             case COMMAND:
29805:                                 appendVoidElementToCurrentMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         elementName, attributes);
29805:                                 selfClosing = false;
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case META:
46393:                             case LINK_OR_BASEFONT_OR_BGSOUND:
29805:                                 // Fall through to IN_HEAD_NOSCRIPT
29805:                                 break inheadloop;
29805:                             case TITLE:
29805:                                 appendToCurrentNodeAndPushElementMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         elementName, attributes);
29805:                                 originalMode = mode;
39864:                                 mode = TEXT;
40985:                                 tokenizer.setStateAndEndTagExpectation(
29805:                                         Tokenizer.RCDATA, elementName);
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case NOSCRIPT:
29805:                                 if (scriptingEnabled) {
29805:                                     appendToCurrentNodeAndPushElement(
29805:                                             "http://www.w3.org/1999/xhtml",
29805:                                             elementName, attributes);
29805:                                     originalMode = mode;
39864:                                     mode = TEXT;
40985:                                     tokenizer.setStateAndEndTagExpectation(
41449:                                             Tokenizer.RAWTEXT, elementName);
29805:                                 } else {
29805:                                     appendToCurrentNodeAndPushElementMayFoster(
29805:                                             "http://www.w3.org/1999/xhtml",
29805:                                             elementName, attributes);
29805:                                     mode = IN_HEAD_NOSCRIPT;
29805:                                 }
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case SCRIPT:
29805:                                 // XXX need to manage much more stuff
29805:                                 // here if
29805:                                 // supporting
29805:                                 // document.write()
29805:                                 appendToCurrentNodeAndPushElementMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         elementName, attributes);
29805:                                 originalMode = mode;
39864:                                 mode = TEXT;
40985:                                 tokenizer.setStateAndEndTagExpectation(
39864:                                         Tokenizer.SCRIPT_DATA, elementName);
39864:                                 attributes = null; // CPP
39864:                                 break starttagloop;
39864:                             case STYLE:
39864:                             case NOFRAMES:
39864:                                 appendToCurrentNodeAndPushElementMayFoster(
39864:                                         "http://www.w3.org/1999/xhtml",
39864:                                         elementName, attributes);
39864:                                 originalMode = mode;
39864:                                 mode = TEXT;
40985:                                 tokenizer.setStateAndEndTagExpectation(
39864:                                         Tokenizer.RAWTEXT, elementName);
39864:                                 attributes = null; // CPP
29805:                                 break starttagloop;
29805:                             case HEAD:
29805:                                 /* Parse error. */
29805:                                 err("Start tag for \u201Chead\u201D seen when \u201Chead\u201D was already open.");
29805:                                 /* Ignore the token. */
29805:                                 break starttagloop;
29805:                             default:
29805:                                 pop();
29805:                                 mode = AFTER_HEAD;
29805:                                 continue starttagloop;
29805:                         }
29805:                     }
29805:                 case IN_HEAD_NOSCRIPT:
29805:                     switch (group) {
29805:                         case HTML:
29805:                             // XXX did Hixie really mean to omit "base"
29805:                             // here?
29805:                             err("Stray \u201Chtml\u201D start tag.");
43391:                             if (!fragment) {
29805:                                 addAttributesToHtml(attributes);
39864:                                 attributes = null; // CPP
43391:                             }
29805:                             break starttagloop;
46393:                         case LINK_OR_BASEFONT_OR_BGSOUND:
29805:                             appendVoidElementToCurrentMayFoster(
29805:                                     "http://www.w3.org/1999/xhtml",
29805:                                     elementName, attributes);
29805:                             selfClosing = false;
39864:                             attributes = null; // CPP
29805:                             break starttagloop;
29805:                         case META:
29805:                             checkMetaCharset(attributes);
29805:                             appendVoidElementToCurrentMayFoster(
29805:                                     "http://www.w3.org/1999/xhtml",
29805:                                     elementName, attributes);
29805:                             selfClosing = false;
39864:                             attributes = null; // CPP
29805:                             break starttagloop;
29805:                         case STYLE:
29805:                         case NOFRAMES:
29805:                             appendToCurrentNodeAndPushElement(
29805:                                     "http://www.w3.org/1999/xhtml",
29805:                                     elementName, attributes);
29805:                             originalMode = mode;
39864:                             mode = TEXT;
40985:                             tokenizer.setStateAndEndTagExpectation(
39864:                                     Tokenizer.RAWTEXT, elementName);
39864:                             attributes = null; // CPP
29805:                             break starttagloop;
29805:                         case HEAD:
29805:                             err("Start tag for \u201Chead\u201D seen when \u201Chead\u201D was already open.");
29805:                             break starttagloop;
29805:                         case NOSCRIPT:
29805:                             err("Start tag for \u201Cnoscript\u201D seen when \u201Cnoscript\u201D was already open.");
29805:                             break starttagloop;
29805:                         default:
29805:                             err("Bad start tag in \u201C" + name
29805:                                     + "\u201D in \u201Chead\u201D.");
29805:                             pop();
29805:                             mode = IN_HEAD;
29805:                             continue;
29805:                     }
29805:                 case IN_COLUMN_GROUP:
29805:                     switch (group) {
29805:                         case HTML:
29805:                             err("Stray \u201Chtml\u201D start tag.");
43391:                             if (!fragment) {
29805:                                 addAttributesToHtml(attributes);
39864:                                 attributes = null; // CPP
43391:                             }
29805:                             break starttagloop;
29805:                         case COL:
29805:                             appendVoidElementToCurrentMayFoster(
29805:                                     "http://www.w3.org/1999/xhtml",
29805:                                     elementName, attributes);
29805:                             selfClosing = false;
39864:                             attributes = null; // CPP
29805:                             break starttagloop;
29805:                         default:
29805:                             if (currentPtr == 0) {
29805:                                 assert fragment;
29805:                                 err("Garbage in \u201Ccolgroup\u201D fragment.");
29805:                                 break starttagloop;
29805:                             }
29805:                             pop();
29805:                             mode = IN_TABLE;
29805:                             continue;
29805:                     }
29805:                 case IN_SELECT_IN_TABLE:
29805:                     switch (group) {
29805:                         case CAPTION:
29805:                         case TBODY_OR_THEAD_OR_TFOOT:
29805:                         case TR:
29805:                         case TD_OR_TH:
29805:                         case TABLE:
29805:                             err("\u201C"
29805:                                     + name
29805:                                     + "\u201D start tag with \u201Cselect\u201D open.");
39864:                             eltPos = findLastInTableScope("select");
39864:                             if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
39864:                                 assert fragment;
39864:                                 break starttagloop; // http://www.w3.org/Bugs/Public/show_bug.cgi?id=8375
39864:                             }
39864:                             while (currentPtr >= eltPos) {
39864:                                 pop();
39864:                             }
39864:                             resetTheInsertionMode();
29805:                             continue;
29805:                         default:
29805:                             // fall through to IN_SELECT
29805:                     }
29805:                 case IN_SELECT:
29805:                     switch (group) {
29805:                         case HTML:
29805:                             err("Stray \u201Chtml\u201D start tag.");
43391:                             if (!fragment) {
29805:                                 addAttributesToHtml(attributes);
39864:                                 attributes = null; // CPP
43391:                             }
29805:                             break starttagloop;
29805:                         case OPTION:
29805:                             if (isCurrent("option")) {
29805:                                 pop();
29805:                             }
29805:                             appendToCurrentNodeAndPushElement(
29805:                                     "http://www.w3.org/1999/xhtml",
29805:                                     elementName, attributes);
39864:                             attributes = null; // CPP
29805:                             break starttagloop;
29805:                         case OPTGROUP:
29805:                             if (isCurrent("option")) {
29805:                                 pop();
29805:                             }
29805:                             if (isCurrent("optgroup")) {
29805:                                 pop();
29805:                             }
29805:                             appendToCurrentNodeAndPushElement(
29805:                                     "http://www.w3.org/1999/xhtml",
29805:                                     elementName, attributes);
39864:                             attributes = null; // CPP
29805:                             break starttagloop;
29805:                         case SELECT:
29805:                             err("\u201Cselect\u201D start tag where end tag expected.");
29805:                             eltPos = findLastInTableScope(name);
29805:                             if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
29805:                                 assert fragment;
29805:                                 err("No \u201Cselect\u201D in table scope.");
29805:                                 break starttagloop;
29805:                             } else {
29805:                                 while (currentPtr >= eltPos) {
29805:                                     pop();
29805:                                 }
29805:                                 resetTheInsertionMode();
29805:                                 break starttagloop;
29805:                             }
39864:                         case INPUT:
29805:                         case TEXTAREA:
39864:                         case KEYGEN:
29805:                             err("\u201C"
29805:                                     + name
29805:                                     + "\u201D start tag seen in \u201Cselect\2201D.");
39864:                             eltPos = findLastInTableScope("select");
39864:                             if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
39864:                                 assert fragment;
39864:                                 break starttagloop;
39864:                             }
39864:                             while (currentPtr >= eltPos) {
39864:                                 pop();
39864:                             }
39864:                             resetTheInsertionMode();
29805:                             continue;
29805:                         case SCRIPT:
29805:                             // XXX need to manage much more stuff
29805:                             // here if
29805:                             // supporting
29805:                             // document.write()
29805:                             appendToCurrentNodeAndPushElementMayFoster(
29805:                                     "http://www.w3.org/1999/xhtml",
29805:                                     elementName, attributes);
29805:                             originalMode = mode;
39864:                             mode = TEXT;
40985:                             tokenizer.setStateAndEndTagExpectation(
39864:                                     Tokenizer.SCRIPT_DATA, elementName);
39864:                             attributes = null; // CPP
29805:                             break starttagloop;
29805:                         default:
41449:                             err("Stray \u201C" + name + "\u201D start tag.");
29805:                             break starttagloop;
29805:                     }
29805:                 case AFTER_BODY:
29805:                     switch (group) {
29805:                         case HTML:
29805:                             err("Stray \u201Chtml\u201D start tag.");
43391:                             if (!fragment) {
29805:                                 addAttributesToHtml(attributes);
39864:                                 attributes = null; // CPP
43391:                             }
29805:                             break starttagloop;
29805:                         default:
41449:                             err("Stray \u201C" + name + "\u201D start tag.");
39864:                             mode = framesetOk ? FRAMESET_OK : IN_BODY;
29805:                             continue;
29805:                     }
29805:                 case IN_FRAMESET:
29805:                     switch (group) {
29805:                         case FRAMESET:
29805:                             appendToCurrentNodeAndPushElement(
29805:                                     "http://www.w3.org/1999/xhtml",
29805:                                     elementName, attributes);
39864:                             attributes = null; // CPP
29805:                             break starttagloop;
29805:                         case FRAME:
29805:                             appendVoidElementToCurrentMayFoster(
29805:                                     "http://www.w3.org/1999/xhtml",
29805:                                     elementName, attributes);
29805:                             selfClosing = false;
39864:                             attributes = null; // CPP
29805:                             break starttagloop;
29805:                         default:
29805:                             // fall through to AFTER_FRAMESET
29805:                     }
29805:                 case AFTER_FRAMESET:
29805:                     switch (group) {
29805:                         case HTML:
29805:                             err("Stray \u201Chtml\u201D start tag.");
43391:                             if (!fragment) {
29805:                                 addAttributesToHtml(attributes);
39864:                                 attributes = null; // CPP
43391:                             }
29805:                             break starttagloop;
29805:                         case NOFRAMES:
29805:                             appendToCurrentNodeAndPushElement(
29805:                                     "http://www.w3.org/1999/xhtml",
29805:                                     elementName, attributes);
29805:                             originalMode = mode;
39864:                             mode = TEXT;
40985:                             tokenizer.setStateAndEndTagExpectation(
39864:                                     Tokenizer.RAWTEXT, elementName);
39864:                             attributes = null; // CPP
29805:                             break starttagloop;
29805:                         default:
41449:                             err("Stray \u201C" + name + "\u201D start tag.");
29805:                             break starttagloop;
29805:                     }
29805:                 case INITIAL:
29805:                     /*
29805:                      * Parse error.
29805:                      */
29805:                     // [NOCPP[
29805:                     switch (doctypeExpectation) {
29805:                         case AUTO:
29805:                             err("Start tag seen without seeing a doctype first. Expected e.g. \u201C<!DOCTYPE html>\u201D.");
29805:                             break;
29805:                         case HTML:
29805:                             err("Start tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE html>\u201D.");
29805:                             break;
29805:                         case HTML401_STRICT:
29805:                             err("Start tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
29805:                             break;
29805:                         case HTML401_TRANSITIONAL:
29805:                             err("Start tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
29805:                             break;
29805:                         case NO_DOCTYPE_ERRORS:
29805:                     }
29805:                     // ]NOCPP]
29805:                     /*
29805:                      * 
29805:                      * Set the document to quirks mode.
29805:                      */
41449:                     documentModeInternal(DocumentMode.QUIRKS_MODE, null, null,
41449:                             false);
29805:                     /*
29805:                      * Then, switch to the root element mode of the tree
29805:                      * construction stage
29805:                      */
29805:                     mode = BEFORE_HTML;
29805:                     /*
29805:                      * and reprocess the current token.
29805:                      */
29805:                     continue;
29805:                 case BEFORE_HTML:
29805:                     switch (group) {
29805:                         case HTML:
29805:                             // optimize error check and streaming SAX by
29805:                             // hoisting
29805:                             // "html" handling here.
29805:                             if (attributes == HtmlAttributes.EMPTY_ATTRIBUTES) {
29805:                                 // This has the right magic side effect
29805:                                 // that
29805:                                 // it
29805:                                 // makes attributes in SAX Tree mutable.
29805:                                 appendHtmlElementToDocumentAndPush();
29805:                             } else {
29805:                                 appendHtmlElementToDocumentAndPush(attributes);
29805:                             }
29805:                             // XXX application cache should fire here
29805:                             mode = BEFORE_HEAD;
39864:                             attributes = null; // CPP
29805:                             break starttagloop;
29805:                         default:
29805:                             /*
41449:                              * Create an HTMLElement node with the tag name
41449:                              * html, in the HTML namespace. Append it to the
41449:                              * Document object.
29805:                              */
29805:                             appendHtmlElementToDocumentAndPush();
29805:                             /* Switch to the main mode */
29805:                             mode = BEFORE_HEAD;
29805:                             /*
29805:                              * reprocess the current token.
29805:                              */
29805:                             continue;
29805:                     }
29805:                 case BEFORE_HEAD:
29805:                     switch (group) {
29805:                         case HTML:
29805:                             err("Stray \u201Chtml\u201D start tag.");
43391:                             if (!fragment) {
29805:                                 addAttributesToHtml(attributes);
39864:                                 attributes = null; // CPP
43391:                             }
29805:                             break starttagloop;
29805:                         case HEAD:
29805:                             /*
29805:                              * A start tag whose tag name is "head"
29805:                              * 
29805:                              * Create an element for the token.
29805:                              * 
41449:                              * Set the head element pointer to this new element
41449:                              * node.
29805:                              * 
41449:                              * Append the new element to the current node and
41449:                              * push it onto the stack of open elements.
29805:                              */
29805:                             appendToCurrentNodeAndPushHeadElement(attributes);
29805:                             /*
29805:                              * Change the insertion mode to "in head".
29805:                              */
29805:                             mode = IN_HEAD;
39864:                             attributes = null; // CPP
29805:                             break starttagloop;
29805:                         default:
29805:                             /*
29805:                              * Any other start tag token
41449:                              * 
41449:                              * Act as if a start tag token with the tag name
41449:                              * "head" and no attributes had been seen,
29805:                              */
29805:                             appendToCurrentNodeAndPushHeadElement(HtmlAttributes.EMPTY_ATTRIBUTES);
29805:                             mode = IN_HEAD;
29805:                             /*
29805:                              * then reprocess the current token.
29805:                              * 
41449:                              * This will result in an empty head element being
41449:                              * generated, with the current token being
41449:                              * reprocessed in the "after head" insertion mode.
29805:                              */
29805:                             continue;
29805:                     }
29805:                 case AFTER_HEAD:
29805:                     switch (group) {
29805:                         case HTML:
29805:                             err("Stray \u201Chtml\u201D start tag.");
43391:                             if (!fragment) {
29805:                                 addAttributesToHtml(attributes);
39864:                                 attributes = null; // CPP
43391:                             }
29805:                             break starttagloop;
29805:                         case BODY:
29805:                             if (attributes.getLength() == 0) {
29805:                                 // This has the right magic side effect
29805:                                 // that
29805:                                 // it
29805:                                 // makes attributes in SAX Tree mutable.
29805:                                 appendToCurrentNodeAndPushBodyElement();
29805:                             } else {
29805:                                 appendToCurrentNodeAndPushBodyElement(attributes);
29805:                             }
39864:                             framesetOk = false;
39864:                             mode = IN_BODY;
39864:                             attributes = null; // CPP
29805:                             break starttagloop;
29805:                         case FRAMESET:
29805:                             appendToCurrentNodeAndPushElement(
29805:                                     "http://www.w3.org/1999/xhtml",
29805:                                     elementName, attributes);
29805:                             mode = IN_FRAMESET;
39864:                             attributes = null; // CPP
29805:                             break starttagloop;
29805:                         case BASE:
29805:                             err("\u201Cbase\u201D element outside \u201Chead\u201D.");
29805:                             pushHeadPointerOntoStack();
29805:                             appendVoidElementToCurrentMayFoster(
29805:                                     "http://www.w3.org/1999/xhtml",
29805:                                     elementName, attributes);
29805:                             selfClosing = false;
29805:                             pop(); // head
39864:                             attributes = null; // CPP
29805:                             break starttagloop;
46393:                         case LINK_OR_BASEFONT_OR_BGSOUND:
29805:                             err("\u201Clink\u201D element outside \u201Chead\u201D.");
29805:                             pushHeadPointerOntoStack();
29805:                             appendVoidElementToCurrentMayFoster(
29805:                                     "http://www.w3.org/1999/xhtml",
29805:                                     elementName, attributes);
29805:                             selfClosing = false;
29805:                             pop(); // head
39864:                             attributes = null; // CPP
29805:                             break starttagloop;
29805:                         case META:
29805:                             err("\u201Cmeta\u201D element outside \u201Chead\u201D.");
29805:                             checkMetaCharset(attributes);
29805:                             pushHeadPointerOntoStack();
29805:                             appendVoidElementToCurrentMayFoster(
29805:                                     "http://www.w3.org/1999/xhtml",
29805:                                     elementName, attributes);
29805:                             selfClosing = false;
29805:                             pop(); // head
39864:                             attributes = null; // CPP
29805:                             break starttagloop;
29805:                         case SCRIPT:
29805:                             err("\u201Cscript\u201D element between \u201Chead\u201D and \u201Cbody\u201D.");
29805:                             pushHeadPointerOntoStack();
29805:                             appendToCurrentNodeAndPushElement(
29805:                                     "http://www.w3.org/1999/xhtml",
29805:                                     elementName, attributes);
29805:                             originalMode = mode;
39864:                             mode = TEXT;
40985:                             tokenizer.setStateAndEndTagExpectation(
39864:                                     Tokenizer.SCRIPT_DATA, elementName);
39864:                             attributes = null; // CPP
29805:                             break starttagloop;
29805:                         case STYLE:
29805:                         case NOFRAMES:
29805:                             err("\u201C"
29805:                                     + name
29805:                                     + "\u201D element between \u201Chead\u201D and \u201Cbody\u201D.");
29805:                             pushHeadPointerOntoStack();
29805:                             appendToCurrentNodeAndPushElement(
29805:                                     "http://www.w3.org/1999/xhtml",
29805:                                     elementName, attributes);
29805:                             originalMode = mode;
39864:                             mode = TEXT;
40985:                             tokenizer.setStateAndEndTagExpectation(
39864:                                     Tokenizer.RAWTEXT, elementName);
39864:                             attributes = null; // CPP
29805:                             break starttagloop;
29805:                         case TITLE:
29805:                             err("\u201Ctitle\u201D element outside \u201Chead\u201D.");
29805:                             pushHeadPointerOntoStack();
29805:                             appendToCurrentNodeAndPushElement(
29805:                                     "http://www.w3.org/1999/xhtml",
29805:                                     elementName, attributes);
29805:                             originalMode = mode;
39864:                             mode = TEXT;
40985:                             tokenizer.setStateAndEndTagExpectation(
29805:                                     Tokenizer.RCDATA, elementName);
39864:                             attributes = null; // CPP
29805:                             break starttagloop;
29805:                         case HEAD:
29805:                             err("Stray start tag \u201Chead\u201D.");
29805:                             break starttagloop;
29805:                         default:
29805:                             appendToCurrentNodeAndPushBodyElement();
29805:                             mode = FRAMESET_OK;
29805:                             continue;
29805:                     }
29805:                 case AFTER_AFTER_BODY:
29805:                     switch (group) {
29805:                         case HTML:
29805:                             err("Stray \u201Chtml\u201D start tag.");
43391:                             if (!fragment) {
29805:                                 addAttributesToHtml(attributes);
39864:                                 attributes = null; // CPP
43391:                             }
29805:                             break starttagloop;
29805:                         default:
41449:                             err("Stray \u201C" + name + "\u201D start tag.");
29805:                             fatal();
39864:                             mode = framesetOk ? FRAMESET_OK : IN_BODY;
29805:                             continue;
29805:                     }
29805:                 case AFTER_AFTER_FRAMESET:
29805:                     switch (group) {
29805:                         case NOFRAMES:
29805:                             appendToCurrentNodeAndPushElementMayFoster(
29805:                                     "http://www.w3.org/1999/xhtml",
29805:                                     elementName, attributes);
29805:                             originalMode = mode;
39864:                             mode = TEXT;
40985:                             tokenizer.setStateAndEndTagExpectation(
39864:                                     Tokenizer.SCRIPT_DATA, elementName);
39864:                             attributes = null; // CPP
29805:                             break starttagloop;
29805:                         default:
41449:                             err("Stray \u201C" + name + "\u201D start tag.");
29805:                             break starttagloop;
29805:                     }
39864:                 case TEXT:
29805:                     assert false;
41449:                     break starttagloop; // Avoid infinite loop if the assertion
41449:                                         // fails
41449:             }
41449:         }
41449:         if (needsPostProcessing && inForeign                && !hasForeignInScope()) {
29805:             /*
29805:              * If, after doing so, the insertion mode is still "in foreign
29805:              * content", but there is no element in scope that has a namespace
29805:              * other than the HTML namespace, switch the insertion mode to the
29805:              * secondary insertion mode.
29805:              */
41449:             inForeign = false;
41449:         }
41449:         if (errorHandler != null && selfClosing) {
41449:             errNoCheck("Self-closing syntax (\u201C/>\u201D) used on a non-void HTML element. Ignoring the slash and treating as a start tag.");
29805:         }
39864:         if (attributes != HtmlAttributes.EMPTY_ATTRIBUTES) {
39864:             Portability.delete(attributes);
39864:         }
29805:     }
29805: 
29805:     /**
29805:      * 
29805:      * <p>
29805:      * C++ memory note: The return value must be released.
29805:      * 
29805:      * @return
29805:      * @throws SAXException
29805:      * @throws StopSniffingException
29805:      */
29805:     public static String extractCharsetFromContent(String attributeValue) {
29805:         // This is a bit ugly. Converting the string to char array in order to
29805:         // make the portability layer smaller.
29805:         int charsetState = CHARSET_INITIAL;
29805:         int start = -1;
29805:         int end = -1;
29805:         char[] buffer = Portability.newCharArrayFromString(attributeValue);
29805: 
29805:         charsetloop: for (int i = 0; i < buffer.length; i++) {
29805:             char c = buffer[i];
29805:             switch (charsetState) {
29805:                 case CHARSET_INITIAL:
29805:                     switch (c) {
29805:                         case 'c':
29805:                         case 'C':
29805:                             charsetState = CHARSET_C;
29805:                             continue;
29805:                         default:
29805:                             continue;
29805:                     }
29805:                 case CHARSET_C:
29805:                     switch (c) {
29805:                         case 'h':
29805:                         case 'H':
29805:                             charsetState = CHARSET_H;
29805:                             continue;
29805:                         default:
29805:                             charsetState = CHARSET_INITIAL;
29805:                             continue;
29805:                     }
29805:                 case CHARSET_H:
29805:                     switch (c) {
29805:                         case 'a':
29805:                         case 'A':
29805:                             charsetState = CHARSET_A;
29805:                             continue;
29805:                         default:
29805:                             charsetState = CHARSET_INITIAL;
29805:                             continue;
29805:                     }
29805:                 case CHARSET_A:
29805:                     switch (c) {
29805:                         case 'r':
29805:                         case 'R':
29805:                             charsetState = CHARSET_R;
29805:                             continue;
29805:                         default:
29805:                             charsetState = CHARSET_INITIAL;
29805:                             continue;
29805:                     }
29805:                 case CHARSET_R:
29805:                     switch (c) {
29805:                         case 's':
29805:                         case 'S':
29805:                             charsetState = CHARSET_S;
29805:                             continue;
29805:                         default:
29805:                             charsetState = CHARSET_INITIAL;
29805:                             continue;
29805:                     }
29805:                 case CHARSET_S:
29805:                     switch (c) {
29805:                         case 'e':
29805:                         case 'E':
29805:                             charsetState = CHARSET_E;
29805:                             continue;
29805:                         default:
29805:                             charsetState = CHARSET_INITIAL;
29805:                             continue;
29805:                     }
29805:                 case CHARSET_E:
29805:                     switch (c) {
29805:                         case 't':
29805:                         case 'T':
29805:                             charsetState = CHARSET_T;
29805:                             continue;
29805:                         default:
29805:                             charsetState = CHARSET_INITIAL;
29805:                             continue;
29805:                     }
29805:                 case CHARSET_T:
29805:                     switch (c) {
29805:                         case '\t':
29805:                         case '\n':
29805:                         case '\u000C':
29805:                         case '\r':
29805:                         case ' ':
29805:                             continue;
29805:                         case '=':
29805:                             charsetState = CHARSET_EQUALS;
29805:                             continue;
29805:                         default:
29805:                             return null;
29805:                     }
29805:                 case CHARSET_EQUALS:
29805:                     switch (c) {
29805:                         case '\t':
29805:                         case '\n':
29805:                         case '\u000C':
29805:                         case '\r':
29805:                         case ' ':
29805:                             continue;
29805:                         case '\'':
29805:                             start = i + 1;
29805:                             charsetState = CHARSET_SINGLE_QUOTED;
29805:                             continue;
29805:                         case '\"':
29805:                             start = i + 1;
29805:                             charsetState = CHARSET_DOUBLE_QUOTED;
29805:                             continue;
29805:                         default:
29805:                             start = i;
29805:                             charsetState = CHARSET_UNQUOTED;
29805:                             continue;
29805:                     }
29805:                 case CHARSET_SINGLE_QUOTED:
29805:                     switch (c) {
29805:                         case '\'':
29805:                             end = i;
29805:                             break charsetloop;
29805:                         default:
29805:                             continue;
29805:                     }
29805:                 case CHARSET_DOUBLE_QUOTED:
29805:                     switch (c) {
29805:                         case '\"':
29805:                             end = i;
29805:                             break charsetloop;
29805:                         default:
29805:                             continue;
29805:                     }
29805:                 case CHARSET_UNQUOTED:
29805:                     switch (c) {
29805:                         case '\t':
29805:                         case '\n':
29805:                         case '\u000C':
29805:                         case '\r':
29805:                         case ' ':
29805:                         case ';':
29805:                             end = i;
29805:                             break charsetloop;
29805:                         default:
29805:                             continue;
29805:                     }
29805:             }
29805:         }
30334:         String charset = null;
29805:         if (start != -1) {
29805:             if (end == -1) {
29805:                 end = buffer.length;
29805:             }
39864:             charset = Portability.newStringFromBuffer(buffer, start, end
39864:                     - start);
29805:         }
29805:         Portability.releaseArray(buffer);
30334:         return charset;
29805:     }
29805: 
29805:     private void checkMetaCharset(HtmlAttributes attributes)
29805:             throws SAXException {
29805:         String content = attributes.getValue(AttributeName.CONTENT);
29805:         String internalCharsetLegacy = null;
29805:         if (content != null) {
29805:             internalCharsetLegacy = TreeBuilder.extractCharsetFromContent(content);
29805:             // [NOCPP[
29805:             if (errorHandler != null
29805:                     && internalCharsetLegacy != null
29805:                     && !Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
29805:                             "content-type",
29805:                             attributes.getValue(AttributeName.HTTP_EQUIV))) {
29805:                 warn("Attribute \u201Ccontent\u201D would be sniffed as an internal character encoding declaration but there was no matching \u201Chttp-equiv='Content-Type'\u201D attribute.");
29805:             }
29805:             // ]NOCPP]
29805:         }
29805:         if (internalCharsetLegacy == null) {
29805:             String internalCharsetHtml5 = attributes.getValue(AttributeName.CHARSET);
29805:             if (internalCharsetHtml5 != null) {
29805:                 tokenizer.internalEncodingDeclaration(internalCharsetHtml5);
29805:                 requestSuspension();
29805:             }
29805:         } else {
29805:             tokenizer.internalEncodingDeclaration(internalCharsetLegacy);
29805:             Portability.releaseString(internalCharsetLegacy);
29805:             requestSuspension();
29805:         }
29805:     }
29805: 
29805:     public final void endTag(ElementName elementName) throws SAXException {
29805:         needToDropLF = false;
29805:         int eltPos;
29805:         int group = elementName.group;
29805:         @Local String name = elementName.name;
49146:         endtagloop: for (;;) {
42863:             assert !inForeign || currentPtr >= 0 : "In foreign without a root element?";
49146:             if (inForeign
49146:                     && stack[currentPtr].ns != "http://www.w3.org/1999/xhtml") {
49146:                 if (errorHandler != null && stack[currentPtr].name != name) {
42863:                     errNoCheck("End tag \u201C"
42863:                             + name
42863:                             + "\u201D did not match the name of the current open element (\u201C"
49146:                             + stack[currentPtr].popName + "\u201D).");
49146:                 }
49146:                 eltPos = currentPtr;
49146:                 for (;;) {
49146:                     if (stack[eltPos].name == name) {
49146:                         while (currentPtr >= eltPos) {
42863:                             pop();
42863:                         }
42863:                         return;
42863:                     }
49146:                     if (stack[--eltPos].ns == "http://www.w3.org/1999/xhtml") {
49146:                         break;
49146:                     }
49146:                 }
49146:             }
29805:             switch (mode) {
29805:                 case IN_ROW:
29805:                     switch (group) {
29805:                         case TR:
29805:                             eltPos = findLastOrRoot(TreeBuilder.TR);
29805:                             if (eltPos == 0) {
29805:                                 assert fragment;
29805:                                 err("No table row to close.");
29805:                                 break endtagloop;
29805:                             }
29805:                             clearStackBackTo(eltPos);
29805:                             pop();
29805:                             mode = IN_TABLE_BODY;
29805:                             break endtagloop;
29805:                         case TABLE:
29805:                             eltPos = findLastOrRoot(TreeBuilder.TR);
29805:                             if (eltPos == 0) {
29805:                                 assert fragment;
29805:                                 err("No table row to close.");
29805:                                 break endtagloop;
29805:                             }
29805:                             clearStackBackTo(eltPos);
29805:                             pop();
29805:                             mode = IN_TABLE_BODY;
29805:                             continue;
29805:                         case TBODY_OR_THEAD_OR_TFOOT:
29805:                             if (findLastInTableScope(name) == TreeBuilder.NOT_FOUND_ON_STACK) {
49146:                                 err("Stray end tag \u201C" + name + "\u201D.");
29805:                                 break endtagloop;
29805:                             }
29805:                             eltPos = findLastOrRoot(TreeBuilder.TR);
29805:                             if (eltPos == 0) {
29805:                                 assert fragment;
29805:                                 err("No table row to close.");
29805:                                 break endtagloop;
29805:                             }
29805:                             clearStackBackTo(eltPos);
29805:                             pop();
29805:                             mode = IN_TABLE_BODY;
29805:                             continue;
29805:                         case BODY:
29805:                         case CAPTION:
29805:                         case COL:
29805:                         case COLGROUP:
29805:                         case HTML:
29805:                         case TD_OR_TH:
29805:                             err("Stray end tag \u201C" + name + "\u201D.");
29805:                             break endtagloop;
29805:                         default:
29805:                             // fall through to IN_TABLE
29805:                     }
29805:                 case IN_TABLE_BODY:
29805:                     switch (group) {
29805:                         case TBODY_OR_THEAD_OR_TFOOT:
29805:                             eltPos = findLastOrRoot(name);
29805:                             if (eltPos == 0) {
49146:                                 err("Stray end tag \u201C" + name + "\u201D.");
29805:                                 break endtagloop;
29805:                             }
29805:                             clearStackBackTo(eltPos);
29805:                             pop();
29805:                             mode = IN_TABLE;
29805:                             break endtagloop;
29805:                         case TABLE:
29805:                             eltPos = findLastInTableScopeOrRootTbodyTheadTfoot();
29805:                             if (eltPos == 0) {
29805:                                 assert fragment;
29805:                                 err("Stray end tag \u201Ctable\u201D.");
29805:                                 break endtagloop;
29805:                             }
29805:                             clearStackBackTo(eltPos);
29805:                             pop();
29805:                             mode = IN_TABLE;
29805:                             continue;
29805:                         case BODY:
29805:                         case CAPTION:
29805:                         case COL:
29805:                         case COLGROUP:
29805:                         case HTML:
29805:                         case TD_OR_TH:
29805:                         case TR:
29805:                             err("Stray end tag \u201C" + name + "\u201D.");
29805:                             break endtagloop;
29805:                         default:
29805:                             // fall through to IN_TABLE
29805:                     }
29805:                 case IN_TABLE:
29805:                     switch (group) {
29805:                         case TABLE:
29805:                             eltPos = findLast("table");
29805:                             if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
29805:                                 assert fragment;
29805:                                 err("Stray end tag \u201Ctable\u201D.");
29805:                                 break endtagloop;
29805:                             }
29805:                             while (currentPtr >= eltPos) {
29805:                                 pop();
29805:                             }
29805:                             resetTheInsertionMode();
29805:                             break endtagloop;
29805:                         case BODY:
29805:                         case CAPTION:
29805:                         case COL:
29805:                         case COLGROUP:
29805:                         case HTML:
29805:                         case TBODY_OR_THEAD_OR_TFOOT:
29805:                         case TD_OR_TH:
29805:                         case TR:
29805:                             err("Stray end tag \u201C" + name + "\u201D.");
29805:                             break endtagloop;
29805:                         default:
29805:                             err("Stray end tag \u201C" + name + "\u201D.");
29805:                             // fall through to IN_BODY
29805:                     }
29805:                 case IN_CAPTION:
29805:                     switch (group) {
29805:                         case CAPTION:
29805:                             eltPos = findLastInTableScope("caption");
29805:                             if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
29805:                                 break endtagloop;
29805:                             }
29805:                             generateImpliedEndTags();
49146:                             if (errorHandler != null && currentPtr != eltPos) {
41449:                                 errNoCheck("Unclosed elements on stack.");
29805:                             }
29805:                             while (currentPtr >= eltPos) {
29805:                                 pop();
29805:                             }
29805:                             clearTheListOfActiveFormattingElementsUpToTheLastMarker();
29805:                             mode = IN_TABLE;
29805:                             break endtagloop;
29805:                         case TABLE:
29805:                             err("\u201Ctable\u201D closed but \u201Ccaption\u201D was still open.");
29805:                             eltPos = findLastInTableScope("caption");
29805:                             if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
29805:                                 break endtagloop;
29805:                             }
29805:                             generateImpliedEndTags();
49146:                             if (errorHandler != null && currentPtr != eltPos) {
41449:                                 errNoCheck("Unclosed elements on stack.");
29805:                             }
29805:                             while (currentPtr >= eltPos) {
29805:                                 pop();
29805:                             }
29805:                             clearTheListOfActiveFormattingElementsUpToTheLastMarker();
29805:                             mode = IN_TABLE;
29805:                             continue;
29805:                         case BODY:
29805:                         case COL:
29805:                         case COLGROUP:
29805:                         case HTML:
29805:                         case TBODY_OR_THEAD_OR_TFOOT:
29805:                         case TD_OR_TH:
29805:                         case TR:
29805:                             err("Stray end tag \u201C" + name + "\u201D.");
29805:                             break endtagloop;
29805:                         default:
29805:                             // fall through to IN_BODY
29805:                     }
29805:                 case IN_CELL:
29805:                     switch (group) {
29805:                         case TD_OR_TH:
29805:                             eltPos = findLastInTableScope(name);
29805:                             if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
49146:                                 err("Stray end tag \u201C" + name + "\u201D.");
29805:                                 break endtagloop;
29805:                             }
29805:                             generateImpliedEndTags();
41449:                             if (errorHandler != null && !isCurrent(name)) {
41449:                                 errNoCheck("Unclosed elements.");
29805:                             }
29805:                             while (currentPtr >= eltPos) {
29805:                                 pop();
29805:                             }
29805:                             clearTheListOfActiveFormattingElementsUpToTheLastMarker();
29805:                             mode = IN_ROW;
29805:                             break endtagloop;
29805:                         case TABLE:
29805:                         case TBODY_OR_THEAD_OR_TFOOT:
29805:                         case TR:
29805:                             if (findLastInTableScope(name) == TreeBuilder.NOT_FOUND_ON_STACK) {
49146:                                 err("Stray end tag \u201C" + name + "\u201D.");
29805:                                 break endtagloop;
29805:                             }
29805:                             closeTheCell(findLastInTableScopeTdTh());
29805:                             continue;
29805:                         case BODY:
29805:                         case CAPTION:
29805:                         case COL:
29805:                         case COLGROUP:
29805:                         case HTML:
29805:                             err("Stray end tag \u201C" + name + "\u201D.");
29805:                             break endtagloop;
29805:                         default:
29805:                             // fall through to IN_BODY
29805:                     }
29805:                 case FRAMESET_OK:
29805:                 case IN_BODY:
29805:                     switch (group) {
29805:                         case BODY:
29805:                             if (!isSecondOnStackBody()) {
29805:                                 assert fragment;
29805:                                 err("Stray end tag \u201Cbody\u201D.");
29805:                                 break endtagloop;
29805:                             }
29805:                             assert currentPtr >= 1;
29805:                             if (errorHandler != null) {
29805:                                 uncloseloop1: for (int i = 2; i <= currentPtr; i++) {
29805:                                     switch (stack[i].group) {
29805:                                         case DD_OR_DT:
29805:                                         case LI:
29805:                                         case OPTGROUP:
29805:                                         case OPTION: // is this possible?
29805:                                         case P:
29805:                                         case RT_OR_RP:
29805:                                         case TD_OR_TH:
29805:                                         case TBODY_OR_THEAD_OR_TFOOT:
29805:                                             break;
29805:                                         default:
29805:                                             err("End tag for \u201Cbody\u201D seen but there were unclosed elements.");
29805:                                             break uncloseloop1;
29805:                                     }
29805:                                 }
29805:                             }
29805:                             mode = AFTER_BODY;
29805:                             break endtagloop;
29805:                         case HTML:
29805:                             if (!isSecondOnStackBody()) {
29805:                                 assert fragment;
29805:                                 err("Stray end tag \u201Chtml\u201D.");
29805:                                 break endtagloop;
29805:                             }
29805:                             if (errorHandler != null) {
29805:                                 uncloseloop2: for (int i = 0; i <= currentPtr; i++) {
29805:                                     switch (stack[i].group) {
29805:                                         case DD_OR_DT:
29805:                                         case LI:
29805:                                         case P:
29805:                                         case TBODY_OR_THEAD_OR_TFOOT:
29805:                                         case TD_OR_TH:
29805:                                         case BODY:
29805:                                         case HTML:
29805:                                             break;
29805:                                         default:
29805:                                             err("End tag for \u201Chtml\u201D seen but there were unclosed elements.");
29805:                                             break uncloseloop2;
29805:                                     }
29805:                                 }
29805:                             }
29805:                             mode = AFTER_BODY;
29805:                             continue;
29805:                         case DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU:
29805:                         case UL_OR_OL_OR_DL:
29805:                         case PRE_OR_LISTING:
29805:                         case FIELDSET:
40920:                         case BUTTON:
39864:                         case ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_HGROUP_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION:
29805:                             eltPos = findLastInScope(name);
29805:                             if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
49146:                                 err("Stray end tag \u201C" + name + "\u201D.");
29805:                             } else {
29805:                                 generateImpliedEndTags();
49146:                                 if (errorHandler != null && !isCurrent(name)) {
41449:                                     errNoCheck("End tag \u201C"
29805:                                             + name
29805:                                             + "\u201D seen but there were unclosed elements.");
29805:                                 }
29805:                                 while (currentPtr >= eltPos) {
29805:                                     pop();
29805:                                 }
29805:                             }
29805:                             break endtagloop;
29805:                         case FORM:
29805:                             if (formPointer == null) {
49146:                                 err("Stray end tag \u201C" + name + "\u201D.");
29805:                                 break endtagloop;
29805:                             }
29805:                             Portability.releaseElement(formPointer);
29805:                             formPointer = null;
29805:                             eltPos = findLastInScope(name);
29805:                             if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
49146:                                 err("Stray end tag \u201C" + name + "\u201D.");
29805:                                 break endtagloop;
29805:                             }
29805:                             generateImpliedEndTags();
41449:                             if (errorHandler != null && !isCurrent(name)) {
41449:                                 errNoCheck("End tag \u201C"
29805:                                         + name
29805:                                         + "\u201D seen but there were unclosed elements.");
29805:                             }
29805:                             removeFromStack(eltPos);
29805:                             break endtagloop;
29805:                         case P:
29805:                             eltPos = findLastInScope("p");
29805:                             if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
29805:                                 err("No \u201Cp\u201D element in scope but a \u201Cp\u201D end tag seen.");
29805:                                 // XXX inline this case
41449:                                 if (inForeign) {
29805:                                     err("HTML start tag \u201C"
29805:                                             + name
29805:                                             + "\u201D in a foreign namespace context.");
29805:                                     while (stack[currentPtr].ns != "http://www.w3.org/1999/xhtml") {
29805:                                         pop();
29805:                                     }
41449:                                     inForeign = false;
29805:                                 }
29805:                                 appendVoidElementToCurrentMayFoster(
29805:                                         "http://www.w3.org/1999/xhtml",
29805:                                         elementName,
29805:                                         HtmlAttributes.EMPTY_ATTRIBUTES);
29805:                                 break endtagloop;
29805:                             }
29805:                             generateImpliedEndTagsExceptFor("p");
29805:                             assert eltPos != TreeBuilder.NOT_FOUND_ON_STACK;
49146:                             if (errorHandler != null && eltPos != currentPtr) {
41449:                                 errNoCheck("End tag for \u201Cp\u201D seen, but there were unclosed elements.");
29805:                             }
29805:                             while (currentPtr >= eltPos) {
29805:                                 pop();
29805:                             }
29805:                             break endtagloop;
39864:                         case LI:
39864:                             eltPos = findLastInListScope(name);
39864:                             if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
39864:                                 err("No \u201Cli\u201D element in list scope but a \u201Cli\u201D end tag seen.");
39864:                             } else {
39864:                                 generateImpliedEndTagsExceptFor(name);
42863:                                 if (errorHandler != null
42863:                                         && eltPos != currentPtr) {
41449:                                     errNoCheck("End tag for \u201Cli\u201D seen, but there were unclosed elements.");
39864:                                 }
39864:                                 while (currentPtr >= eltPos) {
39864:                                     pop();
39864:                                 }
39864:                             }
39864:                             break endtagloop;
29805:                         case DD_OR_DT:
29805:                             eltPos = findLastInScope(name);
29805:                             if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
29805:                                 err("No \u201C"
29805:                                         + name
29805:                                         + "\u201D element in scope but a \u201C"
29805:                                         + name + "\u201D end tag seen.");
29805:                             } else {
29805:                                 generateImpliedEndTagsExceptFor(name);
42863:                                 if (errorHandler != null
42863:                                         && eltPos != currentPtr) {
41449:                                     errNoCheck("End tag for \u201C"
29805:                                             + name
29805:                                             + "\u201D seen, but there were unclosed elements.");
29805:                                 }
29805:                                 while (currentPtr >= eltPos) {
29805:                                     pop();
29805:                                 }
29805:                             }
29805:                             break endtagloop;
29805:                         case H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6:
29805:                             eltPos = findLastInScopeHn();
29805:                             if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
49146:                                 err("Stray end tag \u201C" + name + "\u201D.");
29805:                             } else {
29805:                                 generateImpliedEndTags();
49146:                                 if (errorHandler != null && !isCurrent(name)) {
41449:                                     errNoCheck("End tag \u201C"
29805:                                             + name
29805:                                             + "\u201D seen but there were unclosed elements.");
29805:                                 }
29805:                                 while (currentPtr >= eltPos) {
29805:                                     pop();
29805:                                 }
29805:                             }
29805:                             break endtagloop;
29805:                         case A:
29805:                         case B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U:
29805:                         case FONT:
29805:                         case NOBR:
29805:                             adoptionAgencyEndTag(name);
29805:                             break endtagloop;
29805:                         case OBJECT:
29805:                         case MARQUEE_OR_APPLET:
29805:                             eltPos = findLastInScope(name);
29805:                             if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
49146:                                 err("Stray end tag \u201C" + name + "\u201D.");
29805:                             } else {
29805:                                 generateImpliedEndTags();
49146:                                 if (errorHandler != null && !isCurrent(name)) {
41449:                                     errNoCheck("End tag \u201C"
29805:                                             + name
29805:                                             + "\u201D seen but there were unclosed elements.");
29805:                                 }
29805:                                 while (currentPtr >= eltPos) {
29805:                                     pop();
29805:                                 }
29805:                                 clearTheListOfActiveFormattingElementsUpToTheLastMarker();
29805:                             }
29805:                             break endtagloop;
29805:                         case BR:
29805:                             err("End tag \u201Cbr\u201D.");
41449:                             if (inForeign) {
29805:                                 err("HTML start tag \u201C"
29805:                                         + name
29805:                                         + "\u201D in a foreign namespace context.");
29805:                                 while (stack[currentPtr].ns != "http://www.w3.org/1999/xhtml") {
29805:                                     pop();
29805:                                 }
41449:                                 inForeign = false;
29805:                             }
29805:                             reconstructTheActiveFormattingElements();
29805:                             appendVoidElementToCurrentMayFoster(
29805:                                     "http://www.w3.org/1999/xhtml",
29805:                                     elementName,
29805:                                     HtmlAttributes.EMPTY_ATTRIBUTES);
29805:                             break endtagloop;
46393:                         case AREA_OR_SPACER_OR_WBR:
29805:                         case PARAM_OR_SOURCE:
29805:                         case EMBED_OR_IMG:
29805:                         case IMAGE:
29805:                         case INPUT:
29805:                         case KEYGEN: // XXX??
29805:                         case HR:
29805:                         case ISINDEX:
29805:                         case IFRAME:
29805:                         case NOEMBED: // XXX???
29805:                         case NOFRAMES: // XXX??
29805:                         case SELECT:
29805:                         case TABLE:
29805:                         case TEXTAREA: // XXX??
29805:                             err("Stray end tag \u201C" + name + "\u201D.");
29805:                             break endtagloop;
29805:                         case NOSCRIPT:
29805:                             if (scriptingEnabled) {
29805:                                 err("Stray end tag \u201Cnoscript\u201D.");
29805:                                 break endtagloop;
29805:                             } else {
29805:                                 // fall through
29805:                             }
29805:                         default:
29805:                             if (isCurrent(name)) {
29805:                                 pop();
29805:                                 break endtagloop;
29805:                             }
29805: 
29805:                             eltPos = currentPtr;
29805:                             for (;;) {
29805:                                 StackNode<T> node = stack[eltPos];
29805:                                 if (node.name == name) {
29805:                                     generateImpliedEndTags();
42863:                                     if (errorHandler != null
42863:                                             && !isCurrent(name)) {
41449:                                         errNoCheck("End tag \u201C"
29805:                                                 + name
29805:                                                 + "\u201D seen but there were unclosed elements.");
29805:                                     }
29805:                                     while (currentPtr >= eltPos) {
29805:                                         pop();
29805:                                     }
29805:                                     break endtagloop;
29805:                                 } else if (node.scoping || node.special) {
29805:                                     err("Stray end tag \u201C" + name
29805:                                             + "\u201D.");
29805:                                     break endtagloop;
29805:                                 }
29805:                                 eltPos--;
29805:                             }
29805:                     }
29805:                 case IN_COLUMN_GROUP:
29805:                     switch (group) {
29805:                         case COLGROUP:
29805:                             if (currentPtr == 0) {
29805:                                 assert fragment;
29805:                                 err("Garbage in \u201Ccolgroup\u201D fragment.");
29805:                                 break endtagloop;
29805:                             }
29805:                             pop();
29805:                             mode = IN_TABLE;
29805:                             break endtagloop;
29805:                         case COL:
29805:                             err("Stray end tag \u201Ccol\u201D.");
29805:                             break endtagloop;
29805:                         default:
29805:                             if (currentPtr == 0) {
29805:                                 assert fragment;
29805:                                 err("Garbage in \u201Ccolgroup\u201D fragment.");
29805:                                 break endtagloop;
29805:                             }
29805:                             pop();
29805:                             mode = IN_TABLE;
29805:                             continue;
29805:                     }
29805:                 case IN_SELECT_IN_TABLE:
29805:                     switch (group) {
29805:                         case CAPTION:
29805:                         case TABLE:
29805:                         case TBODY_OR_THEAD_OR_TFOOT:
29805:                         case TR:
29805:                         case TD_OR_TH:
29805:                             err("\u201C"
29805:                                     + name
29805:                                     + "\u201D end tag with \u201Cselect\u201D open.");
29805:                             if (findLastInTableScope(name) != TreeBuilder.NOT_FOUND_ON_STACK) {
39864:                                 eltPos = findLastInTableScope("select");
39864:                                 if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
39864:                                     assert fragment;
39864:                                     break endtagloop; // http://www.w3.org/Bugs/Public/show_bug.cgi?id=8375
39864:                                 }
39864:                                 while (currentPtr >= eltPos) {
39864:                                     pop();
39864:                                 }
39864:                                 resetTheInsertionMode();
29805:                                 continue;
29805:                             } else {
29805:                                 break endtagloop;
29805:                             }
29805:                         default:
29805:                             // fall through to IN_SELECT
29805:                     }
29805:                 case IN_SELECT:
29805:                     switch (group) {
29805:                         case OPTION:
29805:                             if (isCurrent("option")) {
29805:                                 pop();
29805:                                 break endtagloop;
29805:                             } else {
29805:                                 err("Stray end tag \u201Coption\u201D");
29805:                                 break endtagloop;
29805:                             }
29805:                         case OPTGROUP:
29805:                             if (isCurrent("option")
29805:                                     && "optgroup" == stack[currentPtr - 1].name) {
29805:                                 pop();
29805:                             }
29805:                             if (isCurrent("optgroup")) {
29805:                                 pop();
29805:                             } else {
29805:                                 err("Stray end tag \u201Coptgroup\u201D");
29805:                             }
29805:                             break endtagloop;
29805:                         case SELECT:
39864:                             eltPos = findLastInTableScope("select");
39864:                             if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
39864:                                 assert fragment;
39864:                                 err("Stray end tag \u201Cselect\u201D");
39864:                                 break endtagloop;
39864:                             }
39864:                             while (currentPtr >= eltPos) {
39864:                                 pop();
39864:                             }
39864:                             resetTheInsertionMode();
29805:                             break endtagloop;
29805:                         default:
29805:                             err("Stray end tag \u201C" + name + "\u201D");
29805:                             break endtagloop;
29805:                     }
29805:                 case AFTER_BODY:
29805:                     switch (group) {
29805:                         case HTML:
29805:                             if (fragment) {
29805:                                 err("Stray end tag \u201Chtml\u201D");
29805:                                 break endtagloop;
29805:                             } else {
29805:                                 mode = AFTER_AFTER_BODY;
29805:                                 break endtagloop;
29805:                             }
29805:                         default:
29805:                             err("Saw an end tag after \u201Cbody\u201D had been closed.");
39864:                             mode = framesetOk ? FRAMESET_OK : IN_BODY;
29805:                             continue;
29805:                     }
29805:                 case IN_FRAMESET:
29805:                     switch (group) {
29805:                         case FRAMESET:
29805:                             if (currentPtr == 0) {
29805:                                 assert fragment;
29805:                                 err("Stray end tag \u201Cframeset\u201D");
29805:                                 break endtagloop;
29805:                             }
29805:                             pop();
29805:                             if ((!fragment) && !isCurrent("frameset")) {
29805:                                 mode = AFTER_FRAMESET;
29805:                             }
29805:                             break endtagloop;
29805:                         default:
29805:                             err("Stray end tag \u201C" + name + "\u201D");
29805:                             break endtagloop;
29805:                     }
29805:                 case AFTER_FRAMESET:
29805:                     switch (group) {
29805:                         case HTML:
29805:                             mode = AFTER_AFTER_FRAMESET;
29805:                             break endtagloop;
29805:                         default:
29805:                             err("Stray end tag \u201C" + name + "\u201D");
29805:                             break endtagloop;
29805:                     }
29805:                 case INITIAL:
29805:                     /*
29805:                      * Parse error.
29805:                      */
29805:                     // [NOCPP[
29805:                     switch (doctypeExpectation) {
29805:                         case AUTO:
29805:                             err("End tag seen without seeing a doctype first. Expected e.g. \u201C<!DOCTYPE html>\u201D.");
29805:                             break;
29805:                         case HTML:
29805:                             err("End tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE html>\u201D.");
29805:                             break;
29805:                         case HTML401_STRICT:
29805:                             err("End tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
29805:                             break;
29805:                         case HTML401_TRANSITIONAL:
29805:                             err("End tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
29805:                             break;
29805:                         case NO_DOCTYPE_ERRORS:
29805:                     }
29805:                     // ]NOCPP]
29805:                     /*
29805:                      * 
29805:                      * Set the document to quirks mode.
29805:                      */
49146:                     documentModeInternal(DocumentMode.QUIRKS_MODE, null, null,
49146:                             false);
29805:                     /*
29805:                      * Then, switch to the root element mode of the tree
29805:                      * construction stage
29805:                      */
29805:                     mode = BEFORE_HTML;
29805:                     /*
29805:                      * and reprocess the current token.
29805:                      */
29805:                     continue;
29805:                 case BEFORE_HTML:
39864:                     switch (group) {
39864:                         case HEAD:
39864:                         case BR:
39864:                         case HTML:
39864:                         case BODY:
29805:                             /*
42863:                              * Create an HTMLElement node with the tag name
42863:                              * html, in the HTML namespace. Append it to the
42863:                              * Document object.
29805:                              */
29805:                             appendHtmlElementToDocumentAndPush();
29805:                             /* Switch to the main mode */
29805:                             mode = BEFORE_HEAD;
29805:                             /*
29805:                              * reprocess the current token.
29805:                              */
29805:                             continue;
39864:                         default:
39864:                             err("Stray end tag \u201C" + name + "\u201D.");
39864:                             break endtagloop;
39864:                     }
29805:                 case BEFORE_HEAD:
29805:                     switch (group) {
29805:                         case HEAD:
29805:                         case BR:
29805:                         case HTML:
29805:                         case BODY:
29805:                             appendToCurrentNodeAndPushHeadElement(HtmlAttributes.EMPTY_ATTRIBUTES);
29805:                             mode = IN_HEAD;
29805:                             continue;
29805:                         default:
29805:                             err("Stray end tag \u201C" + name + "\u201D.");
29805:                             break endtagloop;
29805:                     }
29805:                 case IN_HEAD:
29805:                     switch (group) {
29805:                         case HEAD:
29805:                             pop();
29805:                             mode = AFTER_HEAD;
29805:                             break endtagloop;
29805:                         case BR:
29805:                         case HTML:
29805:                         case BODY:
29805:                             pop();
29805:                             mode = AFTER_HEAD;
29805:                             continue;
29805:                         default:
29805:                             err("Stray end tag \u201C" + name + "\u201D.");
29805:                             break endtagloop;
29805:                     }
29805:                 case IN_HEAD_NOSCRIPT:
29805:                     switch (group) {
29805:                         case NOSCRIPT:
29805:                             pop();
29805:                             mode = IN_HEAD;
29805:                             break endtagloop;
29805:                         case BR:
29805:                             err("Stray end tag \u201C" + name + "\u201D.");
29805:                             pop();
29805:                             mode = IN_HEAD;
29805:                             continue;
29805:                         default:
29805:                             err("Stray end tag \u201C" + name + "\u201D.");
29805:                             break endtagloop;
29805:                     }
29805:                 case AFTER_HEAD:
29805:                     switch (group) {
29805:                         case HTML:
29805:                         case BODY:
29805:                         case BR:
29805:                             appendToCurrentNodeAndPushBodyElement();
29805:                             mode = FRAMESET_OK;
29805:                             continue;
29805:                         default:
29805:                             err("Stray end tag \u201C" + name + "\u201D.");
29805:                             break endtagloop;
29805:                     }
29805:                 case AFTER_AFTER_BODY:
29805:                     err("Stray \u201C" + name + "\u201D end tag.");
39864:                     mode = framesetOk ? FRAMESET_OK : IN_BODY;
29805:                     continue;
29805:                 case AFTER_AFTER_FRAMESET:
29805:                     err("Stray \u201C" + name + "\u201D end tag.");
29805:                     mode = IN_FRAMESET;
29805:                     continue;
39864:                 case TEXT:
29805:                     // XXX need to manage insertion point here
39864:                     pop();
29805:                     if (originalMode == AFTER_HEAD) {
39864:                         silentPop();
39864:                     }
29805:                     mode = originalMode;
29805:                     break endtagloop;
29805:             }
42863:         } // endtagloop
41449:         if (inForeign && !hasForeignInScope()) {
29805:             /*
29805:              * If, after doing so, the insertion mode is still "in foreign
49146:              * content", but there is no element in scope that has a namespace
49146:              * other than the HTML namespace, switch the insertion mode to the
49146:              * secondary insertion mode.
29805:              */
41449:             inForeign = false;
29805:         }
29805:     }
29805: 
29805:     private int findLastInTableScopeOrRootTbodyTheadTfoot() {
29805:         for (int i = currentPtr; i > 0; i--) {
29805:             if (stack[i].group == TreeBuilder.TBODY_OR_THEAD_OR_TFOOT) {
29805:                 return i;
29805:             }
29805:         }
29805:         return 0;
29805:     }
29805: 
29805:     private int findLast(@Local String name) {
29805:         for (int i = currentPtr; i > 0; i--) {
29805:             if (stack[i].name == name) {
29805:                 return i;
29805:             }
29805:         }
29805:         return TreeBuilder.NOT_FOUND_ON_STACK;
29805:     }
29805: 
29805:     private int findLastInTableScope(@Local String name) {
29805:         for (int i = currentPtr; i > 0; i--) {
29805:             if (stack[i].name == name) {
29805:                 return i;
29805:             } else if (stack[i].name == "table") {
29805:                 return TreeBuilder.NOT_FOUND_ON_STACK;
29805:             }
29805:         }
29805:         return TreeBuilder.NOT_FOUND_ON_STACK;
29805:     }
29805: 
29805:     private int findLastInScope(@Local String name) {
29805:         for (int i = currentPtr; i > 0; i--) {
29805:             if (stack[i].name == name) {
29805:                 return i;
29805:             } else if (stack[i].scoping) {
29805:                 return TreeBuilder.NOT_FOUND_ON_STACK;
29805:             }
29805:         }
29805:         return TreeBuilder.NOT_FOUND_ON_STACK;
29805:     }
29805: 
39864:     private int findLastInListScope(@Local String name) {
39864:         for (int i = currentPtr; i > 0; i--) {
39864:             if (stack[i].name == name) {
39864:                 return i;
39864:             } else if (stack[i].scoping || stack[i].name == "ul" || stack[i].name == "ol") {
39864:                 return TreeBuilder.NOT_FOUND_ON_STACK;
39864:             }
39864:         }
39864:         return TreeBuilder.NOT_FOUND_ON_STACK;
39864:     }
39864:     
29805:     private int findLastInScopeHn() {
29805:         for (int i = currentPtr; i > 0; i--) {
29805:             if (stack[i].group == TreeBuilder.H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6) {
29805:                 return i;
29805:             } else if (stack[i].scoping) {
29805:                 return TreeBuilder.NOT_FOUND_ON_STACK;
29805:             }
29805:         }
29805:         return TreeBuilder.NOT_FOUND_ON_STACK;
29805:     }
29805: 
29805:     private boolean hasForeignInScope() {
29805:         for (int i = currentPtr; i > 0; i--) {
29805:             if (stack[i].ns != "http://www.w3.org/1999/xhtml") {
29805:                 return true;
29805:             } else if (stack[i].scoping) {
29805:                 return false;
29805:             }
29805:         }
29805:         return false;
29805:     }
29805: 
29805:     private void generateImpliedEndTagsExceptFor(@Local String name)
29805:             throws SAXException {
29805:         for (;;) {
29805:             StackNode<T> node = stack[currentPtr];
29805:             switch (node.group) {
29805:                 case P:
29805:                 case LI:
29805:                 case DD_OR_DT:
29805:                 case OPTION:
29805:                 case OPTGROUP:
29805:                 case RT_OR_RP:
29805:                     if (node.name == name) {
29805:                         return;
29805:                     }
29805:                     pop();
29805:                     continue;
29805:                 default:
29805:                     return;
29805:             }
29805:         }
29805:     }
29805: 
29805:     private void generateImpliedEndTags() throws SAXException {
29805:         for (;;) {
29805:             switch (stack[currentPtr].group) {
29805:                 case P:
29805:                 case LI:
29805:                 case DD_OR_DT:
29805:                 case OPTION:
29805:                 case OPTGROUP:
29805:                 case RT_OR_RP:
29805:                     pop();
29805:                     continue;
29805:                 default:
29805:                     return;
29805:             }
29805:         }
29805:     }
29805: 
29805:     private boolean isSecondOnStackBody() {
29805:         return currentPtr >= 1 && stack[1].group == TreeBuilder.BODY;
29805:     }
29805: 
29805:     private void documentModeInternal(DocumentMode m, String publicIdentifier,
29805:             String systemIdentifier, boolean html4SpecificAdditionalErrorChecks)
29805:             throws SAXException {
29805:         quirks = (m == DocumentMode.QUIRKS_MODE);
29805:         if (documentModeHandler != null) {
29805:             documentModeHandler.documentMode(
29805:                     m
29805:                     // [NOCPP[
29805:                     , publicIdentifier, systemIdentifier,
29805:                     html4SpecificAdditionalErrorChecks
29805:             // ]NOCPP]
29805:             );
29805:         }
29805:         // [NOCPP[
29805:         documentMode(m, publicIdentifier, systemIdentifier,
29805:                 html4SpecificAdditionalErrorChecks);
29805:         // ]NOCPP]
29805:     }
29805: 
29805:     private boolean isAlmostStandards(String publicIdentifier,
29805:             String systemIdentifier) {
29805:         if (Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
29805:                 "-//w3c//dtd xhtml 1.0 transitional//en", publicIdentifier)) {
29805:             return true;
29805:         }
29805:         if (Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
29805:                 "-//w3c//dtd xhtml 1.0 frameset//en", publicIdentifier)) {
29805:             return true;
29805:         }
29805:         if (systemIdentifier != null) {
29805:             if (Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
29805:                     "-//w3c//dtd html 4.01 transitional//en", publicIdentifier)) {
29805:                 return true;
29805:             }
29805:             if (Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
29805:                     "-//w3c//dtd html 4.01 frameset//en", publicIdentifier)) {
29805:                 return true;
29805:             }
29805:         }
29805:         return false;
29805:     }
29805: 
29805:     private boolean isQuirky(@Local String name, String publicIdentifier,
29805:             String systemIdentifier, boolean forceQuirks) {
29805:         if (forceQuirks) {
29805:             return true;
29805:         }
29805:         if (name != HTML_LOCAL) {
29805:             return true;
29805:         }
29805:         if (publicIdentifier != null) {
29805:             for (int i = 0; i < TreeBuilder.QUIRKY_PUBLIC_IDS.length; i++) {
29805:                 if (Portability.lowerCaseLiteralIsPrefixOfIgnoreAsciiCaseString(
29805:                         TreeBuilder.QUIRKY_PUBLIC_IDS[i], publicIdentifier)) {
29805:                     return true;
29805:                 }
29805:             }
29805:             if (Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
29805:                     "-//w3o//dtd w3 html strict 3.0//en//", publicIdentifier)
29805:                     || Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
29805:                             "-/w3c/dtd html 4.0 transitional/en",
29805:                             publicIdentifier)
29805:                     || Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
29805:                             "html", publicIdentifier)) {
29805:                 return true;
29805:             }
29805:         }
29805:         if (systemIdentifier == null) {
29805:             if (Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
29805:                     "-//w3c//dtd html 4.01 transitional//en", publicIdentifier)) {
29805:                 return true;
29805:             } else if (Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
29805:                     "-//w3c//dtd html 4.01 frameset//en", publicIdentifier)) {
29805:                 return true;
29805:             }
29805:         } else if (Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
29805:                 "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd",
29805:                 systemIdentifier)) {
29805:             return true;
29805:         }
29805:         return false;
29805:     }
29805: 
29805:     private void closeTheCell(int eltPos) throws SAXException {
29805:         generateImpliedEndTags();
41449:         if (errorHandler != null && eltPos != currentPtr) {
41449:             errNoCheck("Unclosed elements.");
29805:         }
29805:         while (currentPtr >= eltPos) {
29805:             pop();
29805:         }
29805:         clearTheListOfActiveFormattingElementsUpToTheLastMarker();
29805:         mode = IN_ROW;
29805:         return;
29805:     }
29805: 
29805:     private int findLastInTableScopeTdTh() {
29805:         for (int i = currentPtr; i > 0; i--) {
29805:             @Local String name = stack[i].name;
29805:             if ("td" == name || "th" == name) {
29805:                 return i;
29805:             } else if (name == "table") {
29805:                 return TreeBuilder.NOT_FOUND_ON_STACK;
29805:             }
29805:         }
29805:         return TreeBuilder.NOT_FOUND_ON_STACK;
29805:     }
29805: 
29805:     private void clearStackBackTo(int eltPos) throws SAXException {
29805:         while (currentPtr > eltPos) { // > not >= intentional
29805:             pop();
29805:         }
29805:     }
29805: 
29805:     private void resetTheInsertionMode() {
41449:         inForeign = false;
29805:         StackNode<T> node;
29805:         @Local String name;
29805:         @NsUri String ns;
29805:         for (int i = currentPtr; i >= 0; i--) {
29805:             node = stack[i];
29805:             name = node.name;
29805:             ns = node.ns;
29805:             if (i == 0) {
29805:                 if (!(contextNamespace == "http://www.w3.org/1999/xhtml" && (contextName == "td" || contextName == "th"))) {
29805:                     name = contextName;
29805:                     ns = contextNamespace;
29805:                 } else {
39864:                     mode = framesetOk ? FRAMESET_OK : IN_BODY; // XXX from Hixie's email
29805:                     return;
29805:                 }
29805:             }
29805:             if ("select" == name) {
29805:                 mode = IN_SELECT;
29805:                 return;
29805:             } else if ("td" == name || "th" == name) {
29805:                 mode = IN_CELL;
29805:                 return;
29805:             } else if ("tr" == name) {
29805:                 mode = IN_ROW;
29805:                 return;
29805:             } else if ("tbody" == name || "thead" == name || "tfoot" == name) {
29805:                 mode = IN_TABLE_BODY;
29805:                 return;
29805:             } else if ("caption" == name) {
29805:                 mode = IN_CAPTION;
29805:                 return;
29805:             } else if ("colgroup" == name) {
29805:                 mode = IN_COLUMN_GROUP;
29805:                 return;
29805:             } else if ("table" == name) {
29805:                 mode = IN_TABLE;
29805:                 return;
39864:             } else if ("http://www.w3.org/1999/xhtml" != ns) {
41449:                 inForeign = true;
39864:                 mode = framesetOk ? FRAMESET_OK : IN_BODY;
29805:                 return;
29805:             } else if ("head" == name) {
39864:                 mode = framesetOk ? FRAMESET_OK : IN_BODY; // really
29805:                 return;
29805:             } else if ("body" == name) {
39864:                 mode = framesetOk ? FRAMESET_OK : IN_BODY;
29805:                 return;
29805:             } else if ("frameset" == name) {
29805:                 mode = IN_FRAMESET;
29805:                 return;
29805:             } else if ("html" == name) {
29805:                 if (headPointer == null) {
29805:                     mode = BEFORE_HEAD;
29805:                 } else {
29805:                     mode = AFTER_HEAD;
29805:                 }
29805:                 return;
29805:             } else if (i == 0) {
39864:                 mode = framesetOk ? FRAMESET_OK : IN_BODY;
29805:                 return;
29805:             }
29805:         }
29805:     }
29805: 
29805:     /**
29805:      * @throws SAXException
29805:      * 
29805:      */
29805:     private void implicitlyCloseP() throws SAXException {
29805:         int eltPos = findLastInScope("p");
29805:         if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
29805:             return;
29805:         }
29805:         generateImpliedEndTagsExceptFor("p");
41449:         if (errorHandler != null && eltPos != currentPtr) {
29805:             err("Unclosed elements.");
29805:         }
29805:         while (currentPtr >= eltPos) {
29805:             pop();
29805:         }
29805:     }
29805: 
29805:     private boolean clearLastStackSlot() {
29805:         stack[currentPtr] = null;
29805:         return true;
29805:     }
29805: 
29805:     private boolean clearLastListSlot() {
29805:         listOfActiveFormattingElements[listPtr] = null;
29805:         return true;
29805:     }
29805: 
39864:     @SuppressWarnings("unchecked") private void push(StackNode<T> node) throws SAXException {
29805:         currentPtr++;
29805:         if (currentPtr == stack.length) {
29805:             StackNode<T>[] newStack = new StackNode[stack.length + 64];
29805:             System.arraycopy(stack, 0, newStack, 0, stack.length);
29805:             Portability.releaseArray(stack);
29805:             stack = newStack;
29805:         }
29805:         stack[currentPtr] = node;
29805:         elementPushed(node.ns, node.popName, node.node);
29805:     }
29805: 
39864:     @SuppressWarnings("unchecked") private void silentPush(StackNode<T> node) throws SAXException {
39864:         currentPtr++;
39864:         if (currentPtr == stack.length) {
39864:             StackNode<T>[] newStack = new StackNode[stack.length + 64];
39864:             System.arraycopy(stack, 0, newStack, 0, stack.length);
39864:             Portability.releaseArray(stack);
39864:             stack = newStack;
39864:         }
39864:         stack[currentPtr] = node;
39864:     }
39864: 
39864:     @SuppressWarnings("unchecked") private void append(StackNode<T> node) {
29805:         listPtr++;
29805:         if (listPtr == listOfActiveFormattingElements.length) {
29805:             StackNode<T>[] newList = new StackNode[listOfActiveFormattingElements.length + 64];
29805:             System.arraycopy(listOfActiveFormattingElements, 0, newList, 0,
29805:                     listOfActiveFormattingElements.length);
29805:             Portability.releaseArray(listOfActiveFormattingElements);
29805:             listOfActiveFormattingElements = newList;
29805:         }
29805:         listOfActiveFormattingElements[listPtr] = node;
29805:     }
29805: 
29805:     @Inline private void insertMarker() {
29805:         append(null);
29805:     }
29805: 
29805:     private void clearTheListOfActiveFormattingElementsUpToTheLastMarker() {
29805:         while (listPtr > -1) {
29805:             if (listOfActiveFormattingElements[listPtr] == null) {
29805:                 --listPtr;
29805:                 return;
29805:             }
29805:             listOfActiveFormattingElements[listPtr].release();
29805:             --listPtr;
29805:         }
29805:     }
29805: 
29805:     @Inline private boolean isCurrent(@Local String name) {
29805:         return name == stack[currentPtr].name;
29805:     }
29805: 
29805:     private void removeFromStack(int pos) throws SAXException {
29805:         if (currentPtr == pos) {
29805:             pop();
29805:         } else {
29805:             fatal();
29805:             stack[pos].release();
29805:             System.arraycopy(stack, pos + 1, stack, pos, currentPtr - pos);
29805:             assert clearLastStackSlot();
29805:             currentPtr--;
29805:         }
29805:     }
29805: 
29805:     private void removeFromStack(StackNode<T> node) throws SAXException {
29805:         if (stack[currentPtr] == node) {
29805:             pop();
29805:         } else {
29805:             int pos = currentPtr - 1;
29805:             while (pos >= 0 && stack[pos] != node) {
29805:                 pos--;
29805:             }
29805:             if (pos == -1) {
29805:                 // dead code?
29805:                 return;
29805:             }
29805:             fatal();
29805:             node.release();
29805:             System.arraycopy(stack, pos + 1, stack, pos, currentPtr - pos);
29805:             currentPtr--;
29805:         }
29805:     }
29805: 
29805:     private void removeFromListOfActiveFormattingElements(int pos) {
29805:         assert listOfActiveFormattingElements[pos] != null;
29805:         listOfActiveFormattingElements[pos].release();
29805:         if (pos == listPtr) {
29805:             assert clearLastListSlot();
29805:             listPtr--;
29805:             return;
29805:         }
29805:         assert pos < listPtr;
29805:         System.arraycopy(listOfActiveFormattingElements, pos + 1,
29805:                 listOfActiveFormattingElements, pos, listPtr - pos);
29805:         assert clearLastListSlot();
29805:         listPtr--;
29805:     }
29805: 
29805:     private void adoptionAgencyEndTag(@Local String name) throws SAXException {
29805:         // If you crash around here, perhaps some stack node variable claimed to
29805:         // be a weak ref isn't.
29805:         flushCharacters();
29805:         for (;;) {
29805:             int formattingEltListPos = listPtr;
29805:             while (formattingEltListPos > -1) {
39864:                 StackNode<T> listNode = listOfActiveFormattingElements[formattingEltListPos]; // weak
39864:                                                                                               // ref
29805:                 if (listNode == null) {
29805:                     formattingEltListPos = -1;
29805:                     break;
29805:                 } else if (listNode.name == name) {
29805:                     break;
29805:                 }
29805:                 formattingEltListPos--;
29805:             }
29805:             if (formattingEltListPos == -1) {
29805:                 err("No element \u201C" + name + "\u201D to close.");
29805:                 return;
29805:             }
29805:             StackNode<T> formattingElt = listOfActiveFormattingElements[formattingEltListPos]; // this
29805:             // *looks*
29805:             // like
29805:             // a
29805:             // weak
29805:             // ref
29805:             // to
29805:             // the
29805:             // list
29805:             // of
29805:             // formatting
29805:             // elements
29805:             int formattingEltStackPos = currentPtr;
29805:             boolean inScope = true;
29805:             while (formattingEltStackPos > -1) {
29805:                 StackNode<T> node = stack[formattingEltStackPos]; // weak ref
29805:                 if (node == formattingElt) {
29805:                     break;
29805:                 } else if (node.scoping) {
29805:                     inScope = false;
29805:                 }
29805:                 formattingEltStackPos--;
29805:             }
29805:             if (formattingEltStackPos == -1) {
29805:                 err("No element \u201C" + name + "\u201D to close.");
29805:                 removeFromListOfActiveFormattingElements(formattingEltListPos);
29805:                 return;
29805:             }
29805:             if (!inScope) {
29805:                 err("No element \u201C" + name + "\u201D to close.");
29805:                 return;
29805:             }
29805:             // stackPos now points to the formatting element and it is in scope
41449:             if (errorHandler != null && formattingEltStackPos != currentPtr) {
41449:                 errNoCheck("End tag \u201C" + name + "\u201D violates nesting rules.");
29805:             }
29805:             int furthestBlockPos = formattingEltStackPos + 1;
29805:             while (furthestBlockPos <= currentPtr) {
29805:                 StackNode<T> node = stack[furthestBlockPos]; // weak ref
29805:                 if (node.scoping || node.special) {
29805:                     break;
29805:                 }
29805:                 furthestBlockPos++;
29805:             }
29805:             if (furthestBlockPos > currentPtr) {
29805:                 // no furthest block
29805:                 while (currentPtr >= formattingEltStackPos) {
29805:                     pop();
29805:                 }
29805:                 removeFromListOfActiveFormattingElements(formattingEltListPos);
29805:                 return;
29805:             }
29805:             StackNode<T> commonAncestor = stack[formattingEltStackPos - 1]; // weak
29805:             // ref
29805:             StackNode<T> furthestBlock = stack[furthestBlockPos]; // weak ref
29805:             // detachFromParent(furthestBlock.node); XXX AAA CHANGE
29805:             int bookmark = formattingEltListPos;
29805:             int nodePos = furthestBlockPos;
29805:             StackNode<T> lastNode = furthestBlock; // weak ref
29805:             for (;;) {
29805:                 nodePos--;
29805:                 StackNode<T> node = stack[nodePos]; // weak ref
29805:                 int nodeListPos = findInListOfActiveFormattingElements(node);
29805:                 if (nodeListPos == -1) {
29805:                     assert formattingEltStackPos < nodePos;
29805:                     assert bookmark < nodePos;
29805:                     assert furthestBlockPos > nodePos;
29805:                     removeFromStack(nodePos); // node is now a bad pointer in
29805:                     // C++
29805:                     furthestBlockPos--;
29805:                     continue;
29805:                 }
29805:                 // now node is both on stack and in the list
29805:                 if (nodePos == formattingEltStackPos) {
29805:                     break;
29805:                 }
29805:                 if (nodePos == furthestBlockPos) {
29805:                     bookmark = nodeListPos + 1;
29805:                 }
29805:                 // if (hasChildren(node.node)) { XXX AAA CHANGE
29805:                 assert node == listOfActiveFormattingElements[nodeListPos];
29805:                 assert node == stack[nodePos];
39864:                 T clone = createElement("http://www.w3.org/1999/xhtml",
39864:                         node.name, node.attributes.cloneAttributes(null));
29805:                 StackNode<T> newNode = new StackNode<T>(node.group, node.ns,
29805:                         node.name, clone, node.scoping, node.special,
39864:                         node.fosterParenting, node.popName, node.attributes); // creation
29805:                 // ownership
29805:                 // goes
29805:                 // to
29805:                 // stack
39864:                 node.dropAttributes(); // adopt ownership to newNode
29805:                 stack[nodePos] = newNode;
29805:                 newNode.retain(); // retain for list
29805:                 listOfActiveFormattingElements[nodeListPos] = newNode;
29805:                 node.release(); // release from stack
29805:                 node.release(); // release from list
29805:                 node = newNode;
29805:                 Portability.releaseElement(clone);
29805:                 // } XXX AAA CHANGE
29805:                 detachFromParent(lastNode.node);
29805:                 appendElement(lastNode.node, node.node);
29805:                 lastNode = node;
29805:             }
29805:             if (commonAncestor.fosterParenting) {
29805:                 fatal();
29805:                 detachFromParent(lastNode.node);
29805:                 insertIntoFosterParent(lastNode.node);
29805:             } else {
29805:                 detachFromParent(lastNode.node);
29805:                 appendElement(lastNode.node, commonAncestor.node);
29805:             }
39864:             T clone = createElement("http://www.w3.org/1999/xhtml",
39864:                     formattingElt.name,
39864:                     formattingElt.attributes.cloneAttributes(null));
29805:             StackNode<T> formattingClone = new StackNode<T>(
29805:                     formattingElt.group, formattingElt.ns, formattingElt.name,
29805:                     clone, formattingElt.scoping, formattingElt.special,
39864:                     formattingElt.fosterParenting, formattingElt.popName,
39864:                     formattingElt.attributes); // Ownership
29805:             // transfers
29805:             // to
29805:             // stack
29805:             // below
39864:             formattingElt.dropAttributes(); // transfer ownership to
39864:                                             // formattingClone
29805:             appendChildrenToNewParent(furthestBlock.node, clone);
29805:             appendElement(clone, furthestBlock.node);
29805:             removeFromListOfActiveFormattingElements(formattingEltListPos);
29805:             insertIntoListOfActiveFormattingElements(formattingClone, bookmark);
29805:             assert formattingEltStackPos < furthestBlockPos;
29805:             removeFromStack(formattingEltStackPos);
29805:             // furthestBlockPos is now off by one and points to the slot after
29805:             // it
29805:             insertIntoStack(formattingClone, furthestBlockPos);
29805:             Portability.releaseElement(clone);
29805:         }
29805:     }
29805: 
29805:     private void insertIntoStack(StackNode<T> node, int position)
29805:             throws SAXException {
29805:         assert currentPtr + 1 < stack.length;
29805:         assert position <= currentPtr + 1;
29805:         if (position == currentPtr + 1) {
29805:             flushCharacters();
29805:             push(node);
29805:         } else {
29805:             System.arraycopy(stack, position, stack, position + 1,
29805:                     (currentPtr - position) + 1);
29805:             currentPtr++;
29805:             stack[position] = node;
29805:         }
29805:     }
29805: 
29805:     private void insertIntoListOfActiveFormattingElements(
29805:             StackNode<T> formattingClone, int bookmark) {
29805:         formattingClone.retain();
29805:         assert listPtr + 1 < listOfActiveFormattingElements.length;
29805:         if (bookmark <= listPtr) {
29805:             System.arraycopy(listOfActiveFormattingElements, bookmark,
29805:                     listOfActiveFormattingElements, bookmark + 1,
29805:                     (listPtr - bookmark) + 1);
29805:         }
29805:         listPtr++;
29805:         listOfActiveFormattingElements[bookmark] = formattingClone;
29805:     }
29805: 
29805:     private int findInListOfActiveFormattingElements(StackNode<T> node) {
29805:         for (int i = listPtr; i >= 0; i--) {
29805:             if (node == listOfActiveFormattingElements[i]) {
29805:                 return i;
29805:             }
29805:         }
29805:         return -1;
29805:     }
29805: 
29805:     private int findInListOfActiveFormattingElementsContainsBetweenEndAndLastMarker(
29805:             @Local String name) {
29805:         for (int i = listPtr; i >= 0; i--) {
29805:             StackNode<T> node = listOfActiveFormattingElements[i];
29805:             if (node == null) {
29805:                 return -1;
29805:             } else if (node.name == name) {
29805:                 return i;
29805:             }
29805:         }
29805:         return -1;
29805:     }
29805: 
29805:     private int findLastOrRoot(@Local String name) {
29805:         for (int i = currentPtr; i > 0; i--) {
29805:             if (stack[i].name == name) {
29805:                 return i;
29805:             }
29805:         }
29805:         return 0;
29805:     }
29805: 
29805:     private int findLastOrRoot(int group) {
29805:         for (int i = currentPtr; i > 0; i--) {
29805:             if (stack[i].group == group) {
29805:                 return i;
29805:             }
29805:         }
29805:         return 0;
29805:     }
29805: 
43391:     /**
43391:      * Attempt to add attribute to the body element.
43391:      * @param attributes the attributes
43391:      * @return <code>true</code> iff the attributes were added
43391:      * @throws SAXException
43391:      */
43391:     private boolean addAttributesToBody(HtmlAttributes attributes)
29805:             throws SAXException {
29805:         // [NOCPP[
29805:         checkAttributes(attributes, "http://www.w3.org/1999/xhtml");
29805:         // ]NOCPP]
29805:         if (currentPtr >= 1) {
29805:             StackNode<T> body = stack[1];
29805:             if (body.group == TreeBuilder.BODY) {
29805:                 addAttributesToElement(body.node, attributes);
43391:                 return true;
43391:             }
43391:         }
43391:         return false;
29805:     }
29805: 
29805:     private void addAttributesToHtml(HtmlAttributes attributes)
29805:             throws SAXException {
29805:         // [NOCPP[
29805:         checkAttributes(attributes, "http://www.w3.org/1999/xhtml");
29805:         // ]NOCPP]
29805:         addAttributesToElement(stack[0].node, attributes);
29805:     }
29805: 
29805:     private void pushHeadPointerOntoStack() throws SAXException {
39864:         assert headPointer != null;
39864:         assert !fragment;
39864:         assert mode == AFTER_HEAD;
29805:         flushCharacters();
29805:         fatal();
39864:         silentPush(new StackNode<T>("http://www.w3.org/1999/xhtml", ElementName.HEAD,
39864:                 headPointer));
29805:     }
29805: 
29805:     /**
29805:      * @throws SAXException
29805:      * 
29805:      */
29805:     private void reconstructTheActiveFormattingElements() throws SAXException {
29805:         if (listPtr == -1) {
29805:             return;
29805:         }
29805:         StackNode<T> mostRecent = listOfActiveFormattingElements[listPtr];
29805:         if (mostRecent == null || isInStack(mostRecent)) {
29805:             return;
29805:         }
29805:         int entryPos = listPtr;
29805:         for (;;) {
29805:             entryPos--;
29805:             if (entryPos == -1) {
29805:                 break;
29805:             }
29805:             if (listOfActiveFormattingElements[entryPos] == null) {
29805:                 break;
29805:             }
29805:             if (isInStack(listOfActiveFormattingElements[entryPos])) {
29805:                 break;
29805:             }
29805:         }
29805:         if (entryPos < listPtr) {
29805:             flushCharacters();
29805:         }
29805:         while (entryPos < listPtr) {
29805:             entryPos++;
29805:             StackNode<T> entry = listOfActiveFormattingElements[entryPos];
39864:             T clone = createElement("http://www.w3.org/1999/xhtml", entry.name,
39864:                     entry.attributes.cloneAttributes(null));
29805:             StackNode<T> entryClone = new StackNode<T>(entry.group, entry.ns,
29805:                     entry.name, clone, entry.scoping, entry.special,
39864:                     entry.fosterParenting, entry.popName, entry.attributes);
39864:             entry.dropAttributes(); // transfer ownership to entryClone
29805:             StackNode<T> currentNode = stack[currentPtr];
29805:             if (currentNode.fosterParenting) {
29805:                 insertIntoFosterParent(clone);
29805:             } else {
29805:                 appendElement(clone, currentNode.node);
29805:             }
29805:             push(entryClone);
29805:             // stack takes ownership of the local variable
29805:             listOfActiveFormattingElements[entryPos] = entryClone;
29805:             // overwriting the old entry on the list, so release & retain
29805:             entry.release();
29805:             entryClone.retain();
29805:         }
29805:     }
29805: 
29805:     private void insertIntoFosterParent(T child) throws SAXException {
29805:         int eltPos = findLastOrRoot(TreeBuilder.TABLE);
29805:         StackNode<T> node = stack[eltPos];
29805:         T elt = node.node;
29805:         if (eltPos == 0) {
29805:             appendElement(child, elt);
29805:             return;
29805:         }
29805:         insertFosterParentedChild(child, elt, stack[eltPos - 1].node);
29805:     }
29805: 
29805:     private boolean isInStack(StackNode<T> node) {
29805:         for (int i = currentPtr; i >= 0; i--) {
29805:             if (stack[i] == node) {
29805:                 return true;
29805:             }
29805:         }
29805:         return false;
29805:     }
29805: 
29805:     private void pop() throws SAXException {
29805:         flushCharacters();
29805:         StackNode<T> node = stack[currentPtr];
29805:         assert clearLastStackSlot();
29805:         currentPtr--;
29805:         elementPopped(node.ns, node.popName, node.node);
29805:         node.release();
29805:     }
29805: 
39864:     private void silentPop() throws SAXException {
39864:         flushCharacters();
39864:         StackNode<T> node = stack[currentPtr];
39864:         assert clearLastStackSlot();
39864:         currentPtr--;
39864:         node.release();
39864:     }
39864: 
29805:     private void popOnEof() throws SAXException {
29805:         flushCharacters();
29805:         StackNode<T> node = stack[currentPtr];
29805:         assert clearLastStackSlot();
29805:         currentPtr--;
39864:         markMalformedIfScript(node.node);
29805:         elementPopped(node.ns, node.popName, node.node);
29805:         node.release();
29805:     }
29805: 
29805:     // [NOCPP[
29805:     private void checkAttributes(HtmlAttributes attributes, @NsUri String ns)
29805:             throws SAXException {
29805:         if (errorHandler != null) {
29805:             int len = attributes.getXmlnsLength();
29805:             for (int i = 0; i < len; i++) {
29805:                 AttributeName name = attributes.getXmlnsAttributeName(i);
29805:                 if (name == AttributeName.XMLNS) {
29805:                     if (html4) {
29805:                         err("Attribute \u201Cxmlns\u201D not allowed here. (HTML4-only error.)");
29805:                     } else {
29805:                         String xmlns = attributes.getXmlnsValue(i);
29805:                         if (!ns.equals(xmlns)) {
29805:                             err("Bad value \u201C"
29805:                                     + xmlns
29805:                                     + "\u201D for the attribute \u201Cxmlns\u201D (only \u201C"
29805:                                     + ns + "\u201D permitted here).");
29805:                             switch (namePolicy) {
29805:                                 case ALTER_INFOSET:
29805:                                     // fall through
29805:                                 case ALLOW:
29805:                                     warn("Attribute \u201Cxmlns\u201D is not serializable as XML 1.0.");
29805:                                     break;
29805:                                 case FATAL:
29805:                                     fatal("Attribute \u201Cxmlns\u201D is not serializable as XML 1.0.");
29805:                                     break;
29805:                             }
29805:                         }
29805:                     }
39864:                 } else if (ns != "http://www.w3.org/1999/xhtml"
39864:                         && name == AttributeName.XMLNS_XLINK) {
29805:                     String xmlns = attributes.getXmlnsValue(i);
39864:                     if (!"http://www.w3.org/1999/xlink".equals(xmlns)) {
29805:                         err("Bad value \u201C"
29805:                                 + xmlns
39864:                                 + "\u201D for the attribute \u201Cxmlns:link\u201D (only \u201Chttp://www.w3.org/1999/xlink\u201D permitted here).");
29805:                         switch (namePolicy) {
29805:                             case ALTER_INFOSET:
29805:                                 // fall through
29805:                             case ALLOW:
29805:                                 warn("Attribute \u201Cxmlns:xlink\u201D with the value \u201Chttp://www.w3org/1999/xlink\u201D is not serializable as XML 1.0 without changing document semantics.");
29805:                                 break;
29805:                             case FATAL:
29805:                                 fatal("Attribute \u201Cxmlns:xlink\u201D with the value \u201Chttp://www.w3org/1999/xlink\u201D is not serializable as XML 1.0 without changing document semantics.");
29805:                                 break;
29805:                         }
29805:                     }
29805:                 } else {
39864:                     err("Attribute \u201C" + attributes.getXmlnsLocalName(i)
39864:                             + "\u201D not allowed here.");
29805:                     switch (namePolicy) {
29805:                         case ALTER_INFOSET:
29805:                             // fall through
29805:                         case ALLOW:
39864:                             warn("Attribute with the local name \u201C"
39864:                                     + attributes.getXmlnsLocalName(i)
39864:                                     + "\u201D is not serializable as XML 1.0.");
29805:                             break;
29805:                         case FATAL:
39864:                             fatal("Attribute with the local name \u201C"
39864:                                     + attributes.getXmlnsLocalName(i)
39864:                                     + "\u201D is not serializable as XML 1.0.");
29805:                             break;
29805:                     }
29805:                 }
29805:             }
29805:         }
29805:         attributes.processNonNcNames(this, namePolicy);
29805:     }
29805: 
29805:     private String checkPopName(@Local String name) throws SAXException {
29805:         if (NCName.isNCName(name)) {
29805:             return name;
29805:         } else {
29805:             switch (namePolicy) {
29805:                 case ALLOW:
29805:                     warn("Element name \u201C" + name
29805:                             + "\u201D cannot be represented as XML 1.0.");
29805:                     return name;
29805:                 case ALTER_INFOSET:
29805:                     warn("Element name \u201C" + name
29805:                             + "\u201D cannot be represented as XML 1.0.");
29805:                     return NCName.escapeName(name);
29805:                 case FATAL:
29805:                     fatal("Element name \u201C" + name
29805:                             + "\u201D cannot be represented as XML 1.0.");
29805:             }
29805:         }
29805:         return null; // keep compiler happy
29805:     }
29805: 
29805:     // ]NOCPP]
29805: 
29805:     private void appendHtmlElementToDocumentAndPush(HtmlAttributes attributes)
29805:             throws SAXException {
29805:         // [NOCPP[
29805:         checkAttributes(attributes, "http://www.w3.org/1999/xhtml");
29805:         // ]NOCPP]
29805:         T elt = createHtmlElementSetAsRoot(attributes);
29805:         StackNode<T> node = new StackNode<T>("http://www.w3.org/1999/xhtml",
29805:                 ElementName.HTML, elt);
29805:         push(node);
29805:         Portability.releaseElement(elt);
29805:     }
29805: 
29805:     private void appendHtmlElementToDocumentAndPush() throws SAXException {
29805:         appendHtmlElementToDocumentAndPush(tokenizer.emptyAttributes());
29805:     }
29805: 
29805:     private void appendToCurrentNodeAndPushHeadElement(HtmlAttributes attributes)
29805:             throws SAXException {
29805:         flushCharacters();
29805:         // [NOCPP[
29805:         checkAttributes(attributes, "http://www.w3.org/1999/xhtml");
29805:         // ]NOCPP]
29805:         T elt = createElement("http://www.w3.org/1999/xhtml", "head",
29805:                 attributes);
29805:         appendElement(elt, stack[currentPtr].node);
29805:         headPointer = elt;
29805:         Portability.retainElement(headPointer);
29805:         StackNode<T> node = new StackNode<T>("http://www.w3.org/1999/xhtml",
29805:                 ElementName.HEAD, elt);
29805:         push(node);
29805:         Portability.releaseElement(elt);
29805:     }
29805: 
29805:     private void appendToCurrentNodeAndPushBodyElement(HtmlAttributes attributes)
29805:             throws SAXException {
29805:         appendToCurrentNodeAndPushElement("http://www.w3.org/1999/xhtml",
29805:                 ElementName.BODY, attributes);
29805:     }
29805: 
29805:     private void appendToCurrentNodeAndPushBodyElement() throws SAXException {
29805:         appendToCurrentNodeAndPushBodyElement(tokenizer.emptyAttributes());
29805:     }
29805: 
29805:     private void appendToCurrentNodeAndPushFormElementMayFoster(
29805:             HtmlAttributes attributes) throws SAXException {
29805:         flushCharacters();
29805:         // [NOCPP[
29805:         checkAttributes(attributes, "http://www.w3.org/1999/xhtml");
29805:         // ]NOCPP]
29805:         T elt = createElement("http://www.w3.org/1999/xhtml", "form",
29805:                 attributes);
29805:         formPointer = elt;
29805:         Portability.retainElement(formPointer);
29805:         StackNode<T> current = stack[currentPtr];
29805:         if (current.fosterParenting) {
29805:             fatal();
29805:             insertIntoFosterParent(elt);
29805:         } else {
29805:             appendElement(elt, current.node);
29805:         }
29805:         StackNode<T> node = new StackNode<T>("http://www.w3.org/1999/xhtml",
29805:                 ElementName.FORM, elt);
29805:         push(node);
29805:         Portability.releaseElement(elt);
29805:     }
29805: 
29805:     private void appendToCurrentNodeAndPushFormattingElementMayFoster(
29805:             @NsUri String ns, ElementName elementName, HtmlAttributes attributes)
29805:             throws SAXException {
29805:         flushCharacters();
29805:         // [NOCPP[
29805:         checkAttributes(attributes, ns);
29805:         // ]NOCPP]
29805:         // This method can't be called for custom elements
29805:         T elt = createElement(ns, elementName.name, attributes);
29805:         StackNode<T> current = stack[currentPtr];
29805:         if (current.fosterParenting) {
29805:             fatal();
29805:             insertIntoFosterParent(elt);
29805:         } else {
29805:             appendElement(elt, current.node);
29805:         }
39864:         StackNode<T> node = new StackNode<T>(ns, elementName, elt,
39864:                 attributes.cloneAttributes(null));
29805:         push(node);
29805:         append(node);
29805:         node.retain(); // append doesn't retain itself
29805:         Portability.releaseElement(elt);
29805:     }
29805: 
29805:     private void appendToCurrentNodeAndPushElement(@NsUri String ns,
29805:             ElementName elementName, HtmlAttributes attributes)
29805:             throws SAXException {
29805:         flushCharacters();
29805:         // [NOCPP[
29805:         checkAttributes(attributes, ns);
29805:         // ]NOCPP]
29805:         // This method can't be called for custom elements
29805:         T elt = createElement(ns, elementName.name, attributes);
29805:         appendElement(elt, stack[currentPtr].node);
29805:         StackNode<T> node = new StackNode<T>(ns, elementName, elt);
29805:         push(node);
29805:         Portability.releaseElement(elt);
29805:     }
29805: 
29805:     private void appendToCurrentNodeAndPushElementMayFoster(@NsUri String ns,
29805:             ElementName elementName, HtmlAttributes attributes)
29805:             throws SAXException {
29805:         flushCharacters();
29805:         @Local String popName = elementName.name;
29805:         // [NOCPP[
29805:         checkAttributes(attributes, ns);
29805:         if (elementName.custom) {
29805:             popName = checkPopName(popName);
29805:         }
29805:         // ]NOCPP]
29805:         T elt = createElement(ns, popName, attributes);
29805:         StackNode<T> current = stack[currentPtr];
29805:         if (current.fosterParenting) {
29805:             fatal();
29805:             insertIntoFosterParent(elt);
29805:         } else {
29805:             appendElement(elt, current.node);
29805:         }
29805:         StackNode<T> node = new StackNode<T>(ns, elementName, elt, popName);
29805:         push(node);
29805:         Portability.releaseElement(elt);
29805:     }
29805: 
29805:     private void appendToCurrentNodeAndPushElementMayFosterNoScoping(
29805:             @NsUri String ns, ElementName elementName, HtmlAttributes attributes)
29805:             throws SAXException {
29805:         flushCharacters();
29805:         @Local String popName = elementName.name;
29805:         // [NOCPP[
29805:         checkAttributes(attributes, ns);
29805:         if (elementName.custom) {
29805:             popName = checkPopName(popName);
29805:         }
29805:         // ]NOCPP]
29805:         T elt = createElement(ns, popName, attributes);
29805:         StackNode<T> current = stack[currentPtr];
29805:         if (current.fosterParenting) {
29805:             fatal();
29805:             insertIntoFosterParent(elt);
29805:         } else {
29805:             appendElement(elt, current.node);
29805:         }
29805:         StackNode<T> node = new StackNode<T>(ns, elementName, elt, popName,
29805:                 false);
29805:         push(node);
29805:         Portability.releaseElement(elt);
29805:     }
29805: 
29805:     private void appendToCurrentNodeAndPushElementMayFosterCamelCase(
29805:             @NsUri String ns, ElementName elementName, HtmlAttributes attributes)
29805:             throws SAXException {
29805:         flushCharacters();
29805:         @Local String popName = elementName.camelCaseName;
29805:         // [NOCPP[
29805:         checkAttributes(attributes, ns);
29805:         if (elementName.custom) {
29805:             popName = checkPopName(popName);
29805:         }
29805:         // ]NOCPP]
29805:         T elt = createElement(ns, popName, attributes);
29805:         StackNode<T> current = stack[currentPtr];
29805:         if (current.fosterParenting) {
29805:             fatal();
29805:             insertIntoFosterParent(elt);
29805:         } else {
29805:             appendElement(elt, current.node);
29805:         }
29805:         StackNode<T> node = new StackNode<T>(ns, elementName, elt, popName,
29805:                 ElementName.FOREIGNOBJECT == elementName);
29805:         push(node);
29805:         Portability.releaseElement(elt);
29805:     }
29805: 
29805:     private void appendToCurrentNodeAndPushElementMayFoster(@NsUri String ns,
29805:             ElementName elementName, HtmlAttributes attributes, T form)
29805:             throws SAXException {
29805:         flushCharacters();
29805:         // [NOCPP[
29805:         checkAttributes(attributes, ns);
29805:         // ]NOCPP]
29805:         // Can't be called for custom elements
41754:         T elt = createElement(ns, elementName.name, attributes, fragment ? null
41754:                 : form);
29805:         StackNode<T> current = stack[currentPtr];
29805:         if (current.fosterParenting) {
29805:             fatal();
29805:             insertIntoFosterParent(elt);
29805:         } else {
29805:             appendElement(elt, current.node);
29805:         }
29805:         StackNode<T> node = new StackNode<T>(ns, elementName, elt);
29805:         push(node);
29805:         Portability.releaseElement(elt);
29805:     }
29805: 
39864:     private void appendVoidElementToCurrentMayFoster(
29805:             @NsUri String ns, @Local String name, HtmlAttributes attributes,
29805:             T form) throws SAXException {
29805:         flushCharacters();
29805:         // [NOCPP[
29805:         checkAttributes(attributes, ns);
29805:         // ]NOCPP]
29805:         // Can't be called for custom elements
41754:         T elt = createElement(ns, name, attributes, fragment ? null : form);
29805:         StackNode<T> current = stack[currentPtr];
29805:         if (current.fosterParenting) {
29805:             fatal();
29805:             insertIntoFosterParent(elt);
29805:         } else {
29805:             appendElement(elt, current.node);
29805:         }
29805:         elementPushed(ns, name, elt);
29805:         elementPopped(ns, name, elt);
29805:         Portability.releaseElement(elt);
29805:     }
29805: 
39864:     private void appendVoidElementToCurrentMayFoster(
29805:             @NsUri String ns, ElementName elementName, HtmlAttributes attributes)
29805:             throws SAXException {
29805:         flushCharacters();
29805:         @Local String popName = elementName.name;
29805:         // [NOCPP[
29805:         checkAttributes(attributes, ns);
29805:         if (elementName.custom) {
29805:             popName = checkPopName(popName);
29805:         }
29805:         // ]NOCPP]
29805:         T elt = createElement(ns, popName, attributes);
29805:         StackNode<T> current = stack[currentPtr];
29805:         if (current.fosterParenting) {
29805:             fatal();
29805:             insertIntoFosterParent(elt);
29805:         } else {
29805:             appendElement(elt, current.node);
29805:         }
29805:         elementPushed(ns, popName, elt);
29805:         elementPopped(ns, popName, elt);
29805:         Portability.releaseElement(elt);
29805:     }
29805: 
39864:     private void appendVoidElementToCurrentMayFosterCamelCase(
29805:             @NsUri String ns, ElementName elementName, HtmlAttributes attributes)
29805:             throws SAXException {
29805:         flushCharacters();
29805:         @Local String popName = elementName.camelCaseName;
29805:         // [NOCPP[
29805:         checkAttributes(attributes, ns);
29805:         if (elementName.custom) {
29805:             popName = checkPopName(popName);
29805:         }
29805:         // ]NOCPP]
29805:         T elt = createElement(ns, popName, attributes);
29805:         StackNode<T> current = stack[currentPtr];
29805:         if (current.fosterParenting) {
29805:             fatal();
29805:             insertIntoFosterParent(elt);
29805:         } else {
29805:             appendElement(elt, current.node);
29805:         }
29805:         elementPushed(ns, popName, elt);
29805:         elementPopped(ns, popName, elt);
29805:         Portability.releaseElement(elt);
29805:     }
29805: 
39864:     private void appendVoidElementToCurrent(
29805:             @NsUri String ns, @Local String name, HtmlAttributes attributes,
29805:             T form) throws SAXException {
29805:         flushCharacters();
29805:         // [NOCPP[
29805:         checkAttributes(attributes, ns);
29805:         // ]NOCPP]
29805:         // Can't be called for custom elements
41754:         T elt = createElement(ns, name, attributes, fragment ? null : form);
29805:         StackNode<T> current = stack[currentPtr];
29805:         appendElement(elt, current.node);
29805:         elementPushed(ns, name, elt);
29805:         elementPopped(ns, name, elt);
29805:         Portability.releaseElement(elt);
29805:     }
29805: 
39864:     private void appendVoidFormToCurrent(HtmlAttributes attributes) throws SAXException {
39864:         flushCharacters();
39864:         // [NOCPP[
39864:         checkAttributes(attributes, "http://www.w3.org/1999/xhtml");
39864:         // ]NOCPP]
39864:         T elt = createElement("http://www.w3.org/1999/xhtml", "form",
39864:                 attributes);
39864:         formPointer = elt;
39864:         // ownership transferred to form pointer
39864:         StackNode<T> current = stack[currentPtr];
39864:         appendElement(elt, current.node);
39864:         elementPushed("http://www.w3.org/1999/xhtml", "form", elt);
39864:         elementPopped("http://www.w3.org/1999/xhtml", "form", elt);
39864:     }
39864: 
39864:     protected void accumulateCharacters(@Const @NoLength char[] buf, int start,
29805:             int length) throws SAXException {
29805:         appendCharacters(stack[currentPtr].node, buf, start, length);
29805:     }
29805: 
40000:     protected final void accumulateCharacter(char c) throws SAXException {
40000:         int newLen = charBufferLen + 1;
40000:         if (newLen > charBuffer.length) {
40000:             char[] newBuf = new char[newLen];
40000:             System.arraycopy(charBuffer, 0, newBuf, 0, charBufferLen);
40000:             Portability.releaseArray(charBuffer);
40000:             charBuffer = newBuf;
40000:         }
40000:         charBuffer[charBufferLen] = c;
40000:         charBufferLen = newLen;
39864:     }
29805: 
29805:     // ------------------------------- //
29805: 
29805:     protected final void requestSuspension() {
29805:         tokenizer.requestSuspension();
29805:     }
29805: 
29805:     protected abstract T createElement(@NsUri String ns, @Local String name,
29805:             HtmlAttributes attributes) throws SAXException;
29805: 
29805:     protected T createElement(@NsUri String ns, @Local String name,
29805:             HtmlAttributes attributes, T form) throws SAXException {
29805:         return createElement("http://www.w3.org/1999/xhtml", name, attributes);
29805:     }
29805: 
29805:     protected abstract T createHtmlElementSetAsRoot(HtmlAttributes attributes)
29805:             throws SAXException;
29805: 
29805:     protected abstract void detachFromParent(T element) throws SAXException;
29805: 
29805:     protected abstract boolean hasChildren(T element) throws SAXException;
29805: 
29805:     protected abstract void appendElement(T child, T newParent)
29805:             throws SAXException;
29805: 
29805:     protected abstract void appendChildrenToNewParent(T oldParent, T newParent)
29805:             throws SAXException;
29805: 
39864:     protected abstract void insertFosterParentedChild(T child, T table,
39864:             T stackParent) throws SAXException;
39864: 
39864:     protected abstract void insertFosterParentedCharacters(
39864:             @NoLength char[] buf, int start, int length, T table, T stackParent)
29805:             throws SAXException;
29805: 
29805:     protected abstract void appendCharacters(T parent, @NoLength char[] buf,
29805:             int start, int length) throws SAXException;
29805: 
44175:     protected abstract void appendIsindexPrompt(T parent) throws SAXException;
44175:     
29805:     protected abstract void appendComment(T parent, @NoLength char[] buf,
29805:             int start, int length) throws SAXException;
29805: 
29805:     protected abstract void appendCommentToDocument(@NoLength char[] buf,
29805:             int start, int length) throws SAXException;
29805: 
29805:     protected abstract void addAttributesToElement(T element,
29805:             HtmlAttributes attributes) throws SAXException;
29805: 
29805:     protected void markMalformedIfScript(T elt) throws SAXException {
29805: 
29805:     }
29805: 
39864:     protected void start(boolean fragmentMode) throws SAXException {
29805: 
29805:     }
29805: 
29805:     protected void end() throws SAXException {
29805: 
29805:     }
29805: 
29805:     protected void appendDoctypeToDocument(@Local String name,
29805:             String publicIdentifier, String systemIdentifier)
29805:             throws SAXException {
29805: 
29805:     }
29805: 
29805:     protected void elementPushed(@NsUri String ns, @Local String name, T node)
29805:             throws SAXException {
29805: 
29805:     }
29805: 
29805:     protected void elementPopped(@NsUri String ns, @Local String name, T node)
29805:             throws SAXException {
29805: 
29805:     }
29805: 
29805:     // [NOCPP[
29805: 
29805:     protected void documentMode(DocumentMode m, String publicIdentifier,
29805:             String systemIdentifier, boolean html4SpecificAdditionalErrorChecks)
29805:             throws SAXException {
29805: 
29805:     }
29805: 
29805:     /**
29805:      * @see nu.validator.htmlparser.common.TokenHandler#wantsComments()
29805:      */
29805:     public boolean wantsComments() {
29805:         return wantingComments;
29805:     }
29805: 
29805:     public void setIgnoringComments(boolean ignoreComments) {
29805:         wantingComments = !ignoreComments;
29805:     }
29805: 
29805:     /**
29805:      * Sets the errorHandler.
29805:      * 
29805:      * @param errorHandler
29805:      *            the errorHandler to set
29805:      */
29805:     public final void setErrorHandler(ErrorHandler errorHandler) {
29805:         this.errorHandler = errorHandler;
29805:     }
29805: 
29805:     /**
29805:      * Returns the errorHandler.
29805:      * 
29805:      * @return the errorHandler
29805:      */
29805:     public ErrorHandler getErrorHandler() {
29805:         return errorHandler;
29805:     }
29805: 
29805:     /**
29805:      * The argument MUST be an interned string or <code>null</code>.
29805:      * 
29805:      * @param context
29805:      */
29805:     public final void setFragmentContext(@Local String context) {
29805:         this.contextName = context;
29805:         this.contextNamespace = "http://www.w3.org/1999/xhtml";
29805:         this.contextNode = null;
29805:         this.fragment = (contextName != null);
29805:         this.quirks = false;
29805:     }
29805: 
29805:     // ]NOCPP]
29805: 
29805:     /**
29805:      * The argument MUST be an interned string or <code>null</code>.
29805:      * 
29805:      * @param context
29805:      */
39864:     public final void setFragmentContext(@Local String context,
39864:             @NsUri String ns, T node, boolean quirks) {
29805:         this.contextName = context;
29805:         Portability.retainLocal(context);
29805:         this.contextNamespace = ns;
29805:         this.contextNode = node;
29805:         Portability.retainElement(node);
29805:         this.fragment = (contextName != null);
29805:         this.quirks = quirks;
29805:     }
29805: 
29805:     protected final T currentNode() {
29805:         return stack[currentPtr].node;
29805:     }
29805: 
29805:     /**
29805:      * Returns the scriptingEnabled.
29805:      * 
29805:      * @return the scriptingEnabled
29805:      */
29805:     public boolean isScriptingEnabled() {
29805:         return scriptingEnabled;
29805:     }
29805: 
29805:     /**
29805:      * Sets the scriptingEnabled.
29805:      * 
29805:      * @param scriptingEnabled
29805:      *            the scriptingEnabled to set
29805:      */
29805:     public void setScriptingEnabled(boolean scriptingEnabled) {
29805:         this.scriptingEnabled = scriptingEnabled;
29805:     }
29805: 
29805:     // [NOCPP[
29805: 
29805:     /**
29805:      * Sets the doctypeExpectation.
29805:      * 
29805:      * @param doctypeExpectation
29805:      *            the doctypeExpectation to set
29805:      */
29805:     public void setDoctypeExpectation(DoctypeExpectation doctypeExpectation) {
29805:         this.doctypeExpectation = doctypeExpectation;
29805:     }
29805: 
29805:     public void setNamePolicy(XmlViolationPolicy namePolicy) {
29805:         this.namePolicy = namePolicy;
29805:     }
29805: 
29805:     /**
29805:      * Sets the documentModeHandler.
29805:      * 
29805:      * @param documentModeHandler
29805:      *            the documentModeHandler to set
29805:      */
29805:     public void setDocumentModeHandler(DocumentModeHandler documentModeHandler) {
29805:         this.documentModeHandler = documentModeHandler;
29805:     }
29805: 
29805:     /**
29805:      * Sets the reportingDoctype.
29805:      * 
29805:      * @param reportingDoctype
29805:      *            the reportingDoctype to set
29805:      */
29805:     public void setReportingDoctype(boolean reportingDoctype) {
29805:         this.reportingDoctype = reportingDoctype;
29805:     }
29805: 
29805:     // ]NOCPP]
29805: 
29805:     /**
39864:      * Flushes the pending characters. Public for document.write use cases only.
39864:      * @throws SAXException
39864:      */
39864:     public final void flushCharacters() throws SAXException {
29805:         if (charBufferLen > 0) {
29805:             StackNode<T> current = stack[currentPtr];
29805:             if (current.fosterParenting && charBufferContainsNonWhitespace()) {
29805:                 err("Misplaced non-space characters insided a table.");
29805:                 int eltPos = findLastOrRoot(TreeBuilder.TABLE);
29805:                 StackNode<T> node = stack[eltPos];
29805:                 T elt = node.node;
29805:                 if (eltPos == 0) {
29805:                     appendCharacters(elt, charBuffer, 0, charBufferLen);
29805:                     charBufferLen = 0;
29805:                     return;
29805:                 }
29805:                 insertFosterParentedCharacters(charBuffer, 0, charBufferLen,
29805:                         elt, stack[eltPos - 1].node);
29805:                 charBufferLen = 0;
29805:                 return;
29805:             }
29805:             appendCharacters(currentNode(), charBuffer, 0, charBufferLen);
29805:             charBufferLen = 0;
29805:         }
29805:     }
29805: 
29805:     private boolean charBufferContainsNonWhitespace() {
29805:         for (int i = 0; i < charBufferLen; i++) {
29805:             switch (charBuffer[i]) {
29805:                 case ' ':
29805:                 case '\t':
29805:                 case '\n':
39864:                 case '\r':
29805:                 case '\u000C':
29805:                     continue;
29805:                 default:
29805:                     return true;
29805:             }
29805:         }
29805:         return false;
29805:     }
29805: 
29805:     /**
39864:      * Creates a comparable snapshot of the tree builder state. Snapshot
39864:      * creation is only supported immediately after a script end tag has been
39864:      * processed. In C++ the caller is responsible for calling
39864:      * <code>delete</code> on the returned object.
29805:      * 
29805:      * @return a snapshot.
39864:      * @throws SAXException
29805:      */
39864:     @SuppressWarnings("unchecked") public TreeBuilderState<T> newSnapshot()
39864:             throws SAXException {
29805:         StackNode<T>[] listCopy = new StackNode[listPtr + 1];
29805:         for (int i = 0; i < listCopy.length; i++) {
29805:             StackNode<T> node = listOfActiveFormattingElements[i];
29805:             if (node != null) {
39864:                 StackNode<T> newNode = new StackNode<T>(node.group, node.ns,
39864:                         node.name, node.node, node.scoping, node.special,
39864:                         node.fosterParenting, node.popName,
39864:                         node.attributes.cloneAttributes(null));
39864:                 listCopy[i] = newNode;
39864:             } else {
39864:                 listCopy[i] = null;
39864:             }
39864:         }
39864:         StackNode<T>[] stackCopy = new StackNode[currentPtr + 1];
39864:         for (int i = 0; i < stackCopy.length; i++) {
39864:             StackNode<T> node = stack[i];
39864:             int listIndex = findInListOfActiveFormattingElements(node);
39864:             if (listIndex == -1) {
39864:                 StackNode<T> newNode = new StackNode<T>(node.group, node.ns,
39864:                         node.name, node.node, node.scoping, node.special,
39864:                         node.fosterParenting, node.popName,
39864:                         null);
39864:                 stackCopy[i] = newNode;
39864:             } else {
39864:                 stackCopy[i] = listCopy[listIndex];
39864:                 stackCopy[i].retain();
39864:             }
29805:         }
29805:         Portability.retainElement(formPointer);
53890:         return new StateSnapshot<T>(stackCopy, listCopy, formPointer, headPointer, deepTreeSurrogateParent, mode, originalMode, framesetOk, inForeign, needToDropLF, quirks);
39864:     }
39864: 
39864:     public boolean snapshotMatches(TreeBuilderState<T> snapshot) {
39864:         StackNode<T>[] stackCopy = snapshot.getStack();
39864:         int stackLen = snapshot.getStackLength();
39864:         StackNode<T>[] listCopy = snapshot.getListOfActiveFormattingElements();
40984:         int listLen = snapshot.getListOfActiveFormattingElementsLength();
39864: 
39864:         if (stackLen != currentPtr + 1
39864:                 || listLen != listPtr + 1
39864:                 || formPointer != snapshot.getFormPointer()
39864:                 || headPointer != snapshot.getHeadPointer()
53890:                 || deepTreeSurrogateParent != snapshot.getDeepTreeSurrogateParent()
39864:                 || mode != snapshot.getMode()
39864:                 || originalMode != snapshot.getOriginalMode()
39864:                 || framesetOk != snapshot.isFramesetOk()
41449:                 || inForeign != snapshot.isInForeign()
39864:                 || needToDropLF != snapshot.isNeedToDropLF()
39864:                 || quirks != snapshot.isQuirks()) { // maybe just assert quirks
29805:             return false;
29805:         }
39864:         for (int i = listLen - 1; i >= 0; i--) {
39864:             if (listCopy[i] == null
39864:                     && listOfActiveFormattingElements[i] == null) {
39864:                 continue;
39864:             } else if (listCopy[i] == null
39864:                     || listOfActiveFormattingElements[i] == null) {
29805:                 return false;
29805:             }
39864:             if (listCopy[i].node != listOfActiveFormattingElements[i].node) {
39864:                 return false; // it's possible that this condition is overly
39864:                               // strict
39864:             }
39864:         }
39864:         for (int i = stackLen - 1; i >= 0; i--) {
39864:             if (stackCopy[i].node != stack[i].node) {
29805:                 return false;
29805:             }
29805:         }
29805:         return true;
29805:     }
29805: 
39864:     @SuppressWarnings("unchecked") public void loadState(
39864:             TreeBuilderState<T> snapshot, Interner interner)
39864:             throws SAXException {
39864:         StackNode<T>[] stackCopy = snapshot.getStack();
39864:         int stackLen = snapshot.getStackLength();
39864:         StackNode<T>[] listCopy = snapshot.getListOfActiveFormattingElements();
40984:         int listLen = snapshot.getListOfActiveFormattingElementsLength();
39864:         
39864:         for (int i = 0; i <= listPtr; i++) {
39864:             if (listOfActiveFormattingElements[i] != null) {
39864:                 listOfActiveFormattingElements[i].release();
39864:             }
39864:         }
39864:         if (listOfActiveFormattingElements.length < listLen) {
39864:             Portability.releaseArray(listOfActiveFormattingElements);
39864:             listOfActiveFormattingElements = new StackNode[listLen];
39864:         }
39864:         listPtr = listLen - 1;
39864: 
39864:         for (int i = 0; i <= currentPtr; i++) {
39864:             stack[i].release();
39864:         }
39864:         if (stack.length < stackLen) {
39864:             Portability.releaseArray(stack);
39864:             stack = new StackNode[stackLen];
39864:         }
39864:         currentPtr = stackLen - 1;
39864: 
39864:         for (int i = 0; i < listLen; i++) {
39864:             StackNode<T> node = listCopy[i];
39864:             if (node != null) {
39864:                 StackNode<T> newNode = new StackNode<T>(node.group, node.ns,
39864:                         Portability.newLocalFromLocal(node.name, interner), node.node,
39864:                         node.scoping, node.special, node.fosterParenting,
39864:                         Portability.newLocalFromLocal(node.popName, interner),
39864:                         node.attributes.cloneAttributes(null));
39864:                 listOfActiveFormattingElements[i] = newNode;
39864:             } else {
39864:                 listOfActiveFormattingElements[i] = null;
39864:             }
39864:         }
39864:         for (int i = 0; i < stackLen; i++) {
39864:             StackNode<T> node = stackCopy[i];
39864:             int listIndex = findInArray(node, listCopy);
39864:             if (listIndex == -1) {
39864:                 StackNode<T> newNode = new StackNode<T>(node.group, node.ns,
39864:                         Portability.newLocalFromLocal(node.name, interner), node.node,
39864:                         node.scoping, node.special, node.fosterParenting,
39864:                         Portability.newLocalFromLocal(node.popName, interner),
39864:                         null);
39864:                 stack[i] = newNode;
39864:             } else {
39864:                 stack[i] = listOfActiveFormattingElements[listIndex];
39864:                 stack[i].retain();
39864:             }
39864:         }
39864:         Portability.releaseElement(formPointer);
39864:         formPointer = snapshot.getFormPointer();
39864:         Portability.retainElement(formPointer);
39864:         Portability.releaseElement(headPointer);
39864:         headPointer = snapshot.getHeadPointer();
39864:         Portability.retainElement(headPointer);
53890:         Portability.releaseElement(deepTreeSurrogateParent);
53890:         deepTreeSurrogateParent = snapshot.getDeepTreeSurrogateParent();
53890:         Portability.retainElement(deepTreeSurrogateParent);
39864:         mode = snapshot.getMode();
39864:         originalMode = snapshot.getOriginalMode();
39864:         framesetOk = snapshot.isFramesetOk();
41449:         inForeign = snapshot.isInForeign();
39864:         needToDropLF = snapshot.isNeedToDropLF();
39864:         quirks = snapshot.isQuirks();
39864:     }
39864: 
39864:     private int findInArray(StackNode<T> node, StackNode<T>[] arr) {
39864:         for (int i = listPtr; i >= 0; i--) {
39864:             if (node == arr[i]) {
39864:                 return i;
39864:             }
39864:         }
39864:         return -1;
39864:     }
39864: 
39864:     /**
39864:      * @see nu.validator.htmlparser.impl.TreeBuilderState#getFormPointer()
39864:      */
39864:     public T getFormPointer() {
39864:         return formPointer;
39864:     }
39864: 
39864:     /**
39864:      * Returns the headPointer.
39864:      * 
39864:      * @return the headPointer
39864:      */
39864:     public T getHeadPointer() {
39864:         return headPointer;
39864:     }
39864:     
39864:     /**
53890:      * Returns the deepTreeSurrogateParent.
53890:      * 
53890:      * @return the deepTreeSurrogateParent
53890:      */
53890:     public T getDeepTreeSurrogateParent() {
53890:         return deepTreeSurrogateParent;
53890:     }
53890: 
53890:     /**
39864:      * @see nu.validator.htmlparser.impl.TreeBuilderState#getListOfActiveFormattingElements()
39864:      */
39864:     public StackNode<T>[] getListOfActiveFormattingElements() {
39864:         return listOfActiveFormattingElements;
39864:     }
39864: 
39864:     /**
39864:      * @see nu.validator.htmlparser.impl.TreeBuilderState#getStack()
39864:      */
39864:     public StackNode<T>[] getStack() {
39864:         return stack;
39864:     }
39864: 
39864:     /**
39864:      * Returns the mode.
39864:      * 
39864:      * @return the mode
39864:      */
39864:     public int getMode() {
39864:         return mode;
39864:     }
39864: 
39864:     /**
39864:      * Returns the originalMode.
39864:      * 
39864:      * @return the originalMode
39864:      */
39864:     public int getOriginalMode() {
39864:         return originalMode;
39864:     }
39864: 
39864:     /**
39864:      * Returns the framesetOk.
39864:      * 
39864:      * @return the framesetOk
39864:      */
39864:     public boolean isFramesetOk() {
39864:         return framesetOk;
39864:     }
39864:     
39864:     /**
39864:      * Returns the foreignFlag.
39864:      *
41449:      * @see nu.validator.htmlparser.common.TokenHandler#isInForeign()
39864:      * @return the foreignFlag
39864:      */
41449:     public boolean isInForeign() {
41449:         return inForeign;
39864:     }
39864: 
39864:     /**
39864:      * Returns the needToDropLF.
39864:      * 
39864:      * @return the needToDropLF
39864:      */
39864:     public boolean isNeedToDropLF() {
39864:         return needToDropLF;
39864:     }
39864: 
39864:     /**
39864:      * Returns the quirks.
39864:      * 
39864:      * @return the quirks
39864:      */
39864:     public boolean isQuirks() {
39864:         return quirks;
39864:     }
39864: 
39864:     /**
40984:      * @see nu.validator.htmlparser.impl.TreeBuilderState#getListOfActiveFormattingElementsLength()
39864:      */
40984:     public int getListOfActiveFormattingElementsLength() {
39864:         return listPtr + 1;
39864:     }
39864: 
39864:     /**
39864:      * @see nu.validator.htmlparser.impl.TreeBuilderState#getStackLength()
39864:      */
39864:     public int getStackLength() {
39864:         return currentPtr + 1;
39864:     }
39864: 
39864: }
