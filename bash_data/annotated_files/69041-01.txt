    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Travis Bogard <travis@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nscore.h"
    1: #include "nsBarProps.h"
    1: #include "nsGlobalWindow.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsIScrollable.h"
    1: #include "nsIWebBrowserChrome.h"
    1: #include "nsIDOMWindowInternal.h"
    1: #include "nsDOMClassInfo.h"
    1: 
    1: //
    1: //  Basic (virtual) BarProp class implementation
    1: //
69041: nsBarProp::nsBarProp(nsGlobalWindow *aWindow)
    1: {
69041:   mDOMWindow = aWindow;
69041:   nsISupports *supwin = static_cast<nsIScriptGlobalObject *>(aWindow);
69041:   mDOMWindowWeakref = do_GetWeakReference(supwin);
    1: }
    1: 
    1: nsBarProp::~nsBarProp()
    1: {
    1: }
    1: 
    1: 
40490: DOMCI_DATA(BarProp, nsBarProp)
40490: 
    1: // QueryInterface implementation for BarProp
    1: NS_INTERFACE_MAP_BEGIN(nsBarProp)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMBarProp)
    1:   NS_INTERFACE_MAP_ENTRY(nsISupports)
    1:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(BarProp)
    1: NS_INTERFACE_MAP_END
    1: 
    1: 
    1: NS_IMPL_ADDREF(nsBarProp)
    1: NS_IMPL_RELEASE(nsBarProp)
    1: 
    1: NS_IMETHODIMP
    1: nsBarProp::GetVisibleByFlag(PRBool *aVisible, PRUint32 aChromeFlag)
    1: {
51429:   *aVisible = PR_FALSE;
69041: 
69041:   nsCOMPtr<nsIWebBrowserChrome> browserChrome = GetBrowserChrome();
69041:   NS_ENSURE_TRUE(browserChrome, NS_OK);
    1: 
    1:   PRUint32 chromeFlags;
    1: 
69041:   NS_ENSURE_SUCCESS(browserChrome->GetChromeFlags(&chromeFlags),
    1:                     NS_ERROR_FAILURE);
    1:   if (chromeFlags & aChromeFlag)
    1:     *aVisible = PR_TRUE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBarProp::SetVisibleByFlag(PRBool aVisible, PRUint32 aChromeFlag)
    1: {
69041:   nsCOMPtr<nsIWebBrowserChrome> browserChrome = GetBrowserChrome();
69041:   NS_ENSURE_TRUE(browserChrome, NS_OK);
    1: 
    1:   PRBool enabled = PR_FALSE;
    1: 
    1:   nsCOMPtr<nsIScriptSecurityManager>
    1:            securityManager(do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID));
    1:   if (securityManager)
    1:     securityManager->IsCapabilityEnabled("UniversalBrowserWrite", &enabled);
    1:   if (!enabled)
    1:     return NS_OK;
    1: 
    1:   PRUint32 chromeFlags;
    1: 
69041:   NS_ENSURE_SUCCESS(browserChrome->GetChromeFlags(&chromeFlags),
    1:                     NS_ERROR_FAILURE);
    1:   if (aVisible)
    1:     chromeFlags |= aChromeFlag;
    1:   else
    1:     chromeFlags &= ~aChromeFlag;
69041:   NS_ENSURE_SUCCESS(browserChrome->SetChromeFlags(chromeFlags),
    1:                     NS_ERROR_FAILURE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
69041: already_AddRefed<nsIWebBrowserChrome>
69041: nsBarProp::GetBrowserChrome()
69041: {
69041:   // Check that the window is still alive.
69041:   nsCOMPtr<nsIDOMWindow> domwin(do_QueryReferent(mDOMWindowWeakref));
69041:   if (!domwin)
69041:     return nsnull;
69041: 
69041:   nsIWebBrowserChrome *browserChrome = nsnull;
69041:   mDOMWindow->GetWebBrowserChrome(&browserChrome);
69041:   return browserChrome;
69041: }
69041: 
    1: //
    1: // MenubarProp class implementation
    1: //
    1: 
69041: nsMenubarProp::nsMenubarProp(nsGlobalWindow *aWindow) 
69041:   : nsBarProp(aWindow)
    1: {
    1: }
    1: 
    1: nsMenubarProp::~nsMenubarProp()
    1: {
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMenubarProp::GetVisible(PRBool *aVisible)
    1: {
    1:   return nsBarProp::GetVisibleByFlag(aVisible,
    1:                                      nsIWebBrowserChrome::CHROME_MENUBAR);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMenubarProp::SetVisible(PRBool aVisible)
    1: {
    1:   return nsBarProp::SetVisibleByFlag(aVisible,
    1:                                      nsIWebBrowserChrome::CHROME_MENUBAR);
    1: }
    1: 
    1: //
    1: // ToolbarProp class implementation
    1: //
    1: 
69041: nsToolbarProp::nsToolbarProp(nsGlobalWindow *aWindow)
69041:   : nsBarProp(aWindow)
    1: {
    1: }
    1: 
    1: nsToolbarProp::~nsToolbarProp()
    1: {
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsToolbarProp::GetVisible(PRBool *aVisible)
    1: {
    1:   return nsBarProp::GetVisibleByFlag(aVisible,
    1:                                      nsIWebBrowserChrome::CHROME_TOOLBAR);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsToolbarProp::SetVisible(PRBool aVisible)
    1: {
    1:   return nsBarProp::SetVisibleByFlag(aVisible,
    1:                                      nsIWebBrowserChrome::CHROME_TOOLBAR);
    1: }
    1: 
    1: //
    1: // LocationbarProp class implementation
    1: //
    1: 
69041: nsLocationbarProp::nsLocationbarProp(nsGlobalWindow *aWindow)
69041:   : nsBarProp(aWindow)
    1: {
    1: }
    1: 
    1: nsLocationbarProp::~nsLocationbarProp()
    1: {
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocationbarProp::GetVisible(PRBool *aVisible)
    1: {
    1:   return
    1:     nsBarProp::GetVisibleByFlag(aVisible,
    1:                                 nsIWebBrowserChrome::CHROME_LOCATIONBAR);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocationbarProp::SetVisible(PRBool aVisible)
    1: {
    1:   return
    1:     nsBarProp::SetVisibleByFlag(aVisible,
    1:                                 nsIWebBrowserChrome::CHROME_LOCATIONBAR);
    1: }
    1: 
    1: //
    1: // PersonalbarProp class implementation
    1: //
    1: 
69041: nsPersonalbarProp::nsPersonalbarProp(nsGlobalWindow *aWindow)
69041:   : nsBarProp(aWindow)
    1: {
    1: }
    1: 
    1: nsPersonalbarProp::~nsPersonalbarProp()
    1: {
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPersonalbarProp::GetVisible(PRBool *aVisible)
    1: {
    1:   return
    1:     nsBarProp::GetVisibleByFlag(aVisible,
    1:                                 nsIWebBrowserChrome::CHROME_PERSONAL_TOOLBAR);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPersonalbarProp::SetVisible(PRBool aVisible)
    1: {
    1:   return
    1:     nsBarProp::SetVisibleByFlag(aVisible,
    1:                                 nsIWebBrowserChrome::CHROME_PERSONAL_TOOLBAR);
    1: }
    1: 
    1: //
    1: // StatusbarProp class implementation
    1: //
    1: 
69041: nsStatusbarProp::nsStatusbarProp(nsGlobalWindow *aWindow)
69041:   : nsBarProp(aWindow)
    1: {
    1: }
    1: 
    1: nsStatusbarProp::~nsStatusbarProp()
    1: {
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsStatusbarProp::GetVisible(PRBool *aVisible)
    1: {
    1:   return nsBarProp::GetVisibleByFlag(aVisible,
    1:                                      nsIWebBrowserChrome::CHROME_STATUSBAR);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsStatusbarProp::SetVisible(PRBool aVisible)
    1: {
    1:   return nsBarProp::SetVisibleByFlag(aVisible,
    1:                                      nsIWebBrowserChrome::CHROME_STATUSBAR);
    1: }
    1: 
    1: //
    1: // ScrollbarsProp class implementation
    1: //
    1: 
    1: nsScrollbarsProp::nsScrollbarsProp(nsGlobalWindow *aWindow)
69041: : nsBarProp(aWindow)
    1: {
    1: }
    1: 
    1: nsScrollbarsProp::~nsScrollbarsProp()
    1: {
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsScrollbarsProp::GetVisible(PRBool *aVisible)
    1: {
    1:   *aVisible = PR_TRUE; // one assumes
    1: 
    1:   nsCOMPtr<nsIDOMWindow> domwin(do_QueryReferent(mDOMWindowWeakref));
    1:   if (domwin) { // dom window not deleted
    1:     nsCOMPtr<nsIScrollable> scroller =
    1:       do_QueryInterface(mDOMWindow->GetDocShell());
    1: 
    1:     if (scroller) {
    1:       PRInt32 prefValue;
    1:       scroller->GetDefaultScrollbarPreferences(
    1:                   nsIScrollable::ScrollOrientation_Y, &prefValue);
    1:       if (prefValue == nsIScrollable::Scrollbar_Never) // try the other way
    1:         scroller->GetDefaultScrollbarPreferences(
    1:                     nsIScrollable::ScrollOrientation_X, &prefValue);
    1: 
    1:       if (prefValue == nsIScrollable::Scrollbar_Never)
    1:         *aVisible = PR_FALSE;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsScrollbarsProp::SetVisible(PRBool aVisible)
    1: {
    1:   PRBool   enabled = PR_FALSE;
    1: 
    1:   nsCOMPtr<nsIScriptSecurityManager>
    1:            securityManager(do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID));
    1:   if (securityManager)
    1:     securityManager->IsCapabilityEnabled("UniversalBrowserWrite", &enabled);
    1:   if (!enabled)
    1:     return NS_OK;
    1: 
    1:   /* Scrollbars, unlike the other barprops, implement visibility directly
    1:      rather than handing off to the superclass (and from there to the
    1:      chrome window) because scrollbar visibility uniquely applies only
    1:      to the window making the change (arguably. it does now, anyway.)
    1:      and because embedding apps have no interface for implementing this
    1:      themselves, and therefore the implementation must be internal. */
    1: 
    1:   nsCOMPtr<nsIDOMWindow> domwin(do_QueryReferent(mDOMWindowWeakref));
    1:   if (domwin) { // dom window must still exist. use away.
    1:     nsCOMPtr<nsIScrollable> scroller =
    1:       do_QueryInterface(mDOMWindow->GetDocShell());
    1: 
    1:     if (scroller) {
    1:       PRInt32 prefValue;
    1: 
    1:       if (aVisible) {
    1:         prefValue = nsIScrollable::Scrollbar_Auto;
    1:       } else {
    1:         prefValue = nsIScrollable::Scrollbar_Never;
    1:       }
    1: 
    1:       scroller->SetDefaultScrollbarPreferences(
    1:                   nsIScrollable::ScrollOrientation_Y, prefValue);
    1:       scroller->SetDefaultScrollbarPreferences(
    1:                   nsIScrollable::ScrollOrientation_X, prefValue);
    1:     }
    1:   }
    1: 
    1:   /* Notably absent is the part where we notify the chrome window using
69041:      GetBrowserChrome()->SetChromeFlags(). Given the possibility of multiple
    1:      DOM windows (multiple top-level windows, even) within a single
    1:      chrome window, the historical concept of a single "has scrollbars"
    1:      flag in the chrome is inapplicable, and we can't tell at this level
    1:      whether we represent the particular DOM window that makes this decision
    1:      for the chrome.
    1: 
    1:      So only this object (and its corresponding DOM window) knows whether
    1:      scrollbars are visible. The corresponding chrome window will need to
    1:      ask (one of) its DOM window(s) when it needs to know about scrollbar
    1:      visibility, rather than caching its own copy of that information.
    1:   */
    1: 
    1:   return NS_OK;
    1: }
    1: 
