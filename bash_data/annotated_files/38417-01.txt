    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   John Gaunt (jgaunt@netscape.com)
    1:  *   Aaron Leventhal (aaronl@netscape.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsAccessible.h"
 1628: #include "nsAccessibleRelation.h"
 4451: #include "nsHyperTextAccessibleWrap.h"
 4451: 
    1: #include "nsIAccessibleDocument.h"
 4451: #include "nsIAccessibleHyperText.h"
28315: #include "nsIXBLAccessible.h"
38358: #include "nsAccTreeWalker.h"
 4451: 
 4451: #include "nsIDOMElement.h"
 4451: #include "nsIDOMDocument.h"
 4451: #include "nsIDOMDocumentXBL.h"
 4451: #include "nsIDOMDocumentTraversal.h"
 4451: #include "nsIDOMHTMLDocument.h"
 4451: #include "nsIDOMHTMLFormElement.h"
 4451: #include "nsIDOMNodeFilter.h"
 1253: #include "nsIDOMNSHTMLElement.h"
 4451: #include "nsIDOMTreeWalker.h"
 4451: #include "nsIDOMXULButtonElement.h"
 4451: #include "nsIDOMXULDocument.h"
 4451: #include "nsIDOMXULElement.h"
 4451: #include "nsIDOMXULLabelElement.h"
 4451: #include "nsIDOMXULSelectCntrlEl.h"
 4451: #include "nsIDOMXULSelectCntrlItemEl.h"
 4451: #include "nsPIDOMWindow.h"
 4451: 
 4451: #include "nsIDocument.h"
 4451: #include "nsIContent.h"
 4451: #include "nsIForm.h"
 4451: #include "nsIFormControl.h"
 4451: 
    1: #include "nsIPresShell.h"
    1: #include "nsPresContext.h"
    1: #include "nsIFrame.h"
37073: #include "nsIView.h"
 4451: #include "nsIDocShellTreeItem.h"
12642: #include "nsIScrollableFrame.h"
29018: #include "nsFocusManager.h"
 4451: 
    1: #include "nsXPIDLString.h"
    1: #include "nsUnicharUtils.h"
 6279: #include "nsReadableUtils.h"
    1: #include "prdtoa.h"
    1: #include "nsIAtom.h"
    1: #include "nsIPrefService.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIURI.h"
24822: #include "nsArrayUtils.h"
    1: #include "nsIMutableArray.h"
  511: #include "nsIObserverService.h"
 4451: #include "nsIServiceManager.h"
 7830: #include "nsWhitespaceTokenizer.h"
13012: #include "nsAttrName.h"
13757: #include "nsNetUtil.h"
    1: 
    1: #ifdef NS_DEBUG
    1: #include "nsIDOMCharacterData.h"
    1: #endif
    1: 
    1: /**
    1:  * nsAccessibleDOMStringList implementation
    1:  */
    1: nsAccessibleDOMStringList::nsAccessibleDOMStringList()
    1: {
    1: }
    1: 
    1: nsAccessibleDOMStringList::~nsAccessibleDOMStringList()
    1: {
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS1(nsAccessibleDOMStringList, nsIDOMDOMStringList)
    1: 
    1: NS_IMETHODIMP
    1: nsAccessibleDOMStringList::Item(PRUint32 aIndex, nsAString& aResult)
    1: {
23904:   if (aIndex >= mNames.Length()) {
    1:     SetDOMStringToNull(aResult);
    1:   } else {
23904:     aResult = mNames.ElementAt(aIndex);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAccessibleDOMStringList::GetLength(PRUint32 *aLength)
    1: {
23904:   *aLength = mNames.Length();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAccessibleDOMStringList::Contains(const nsAString& aString, PRBool *aResult)
    1: {
23904:   *aResult = mNames.Contains(aString);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /*
    1:  * Class nsAccessible
    1:  */
    1: 
16428: ////////////////////////////////////////////////////////////////////////////////
16428: // nsAccessible. nsISupports
16428: 
16428: NS_IMPL_CYCLE_COLLECTION_CLASS(nsAccessible)
16428: 
16428: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsAccessible, nsAccessNode)
36989:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mParent");
36989:   cb.NoteXPCOMChild(static_cast<nsIAccessible*>(tmp->mParent.get()));
36989: 
36989:   PRUint32 i, length = tmp->mChildren.Length();
36989:   for (i = 0; i < length; ++i) {
36989:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mChildren[i]");
36989:     cb.NoteXPCOMChild(static_cast<nsIAccessible*>(tmp->mChildren[i].get()));
36989:   }
16428: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
16428: 
16428: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsAccessible, nsAccessNode)
16428:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mParent)
36989:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSTARRAY(mChildren)
16428: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
16428: 
    1: NS_IMPL_ADDREF_INHERITED(nsAccessible, nsAccessNode)
    1: NS_IMPL_RELEASE_INHERITED(nsAccessible, nsAccessNode)
    1: 
    1: nsresult nsAccessible::QueryInterface(REFNSIID aIID, void** aInstancePtr)
    1: {
    1:   // Custom-built QueryInterface() knows when we support nsIAccessibleSelectable
 8937:   // based on role attribute and aria-multiselectable
    1:   *aInstancePtr = nsnull;
    1: 
16428:   if (aIID.Equals(NS_GET_IID(nsXPCOMCycleCollectionParticipant))) {
16428:     *aInstancePtr = &NS_CYCLE_COLLECTION_NAME(nsAccessible);
16428:     return NS_OK;
16428:   }
16428: 
    1:   if (aIID.Equals(NS_GET_IID(nsIAccessible))) {
 3233:     *aInstancePtr = static_cast<nsIAccessible*>(this);
    1:     NS_ADDREF_THIS();
    1:     return NS_OK;
    1:   }
    1: 
20246:   if (aIID.Equals(NS_GET_IID(nsAccessible))) {
20246:     *aInstancePtr = static_cast<nsAccessible*>(this);
20246:     NS_ADDREF_THIS();
20246:     return NS_OK;
20246:   }
20246: 
    1:   if (aIID.Equals(NS_GET_IID(nsIAccessibleSelectable))) {
35584:     if (mRoleMapEntry &&
35584:         (mRoleMapEntry->attributeMap1 == eARIAMultiSelectable ||
35584:          mRoleMapEntry->attributeMap2 == eARIAMultiSelectable ||
35584:          mRoleMapEntry->attributeMap3 == eARIAMultiSelectable)) {
35584: 
35584:       // If we have an ARIA role attribute present and the role allows multi
35584:       // selectable state, then we need to support nsIAccessibleSelectable.
    1:       // If either attribute (role or multiselectable) change, then we'll
    1:       // destroy this accessible so that we can follow COM identity rules.
35584: 
 3233:       *aInstancePtr = static_cast<nsIAccessibleSelectable*>(this);
    1:       NS_ADDREF_THIS();
 4648:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   if (aIID.Equals(NS_GET_IID(nsIAccessibleValue))) {
    1:     if (mRoleMapEntry && mRoleMapEntry->valueRule != eNoValue) {
 3233:       *aInstancePtr = static_cast<nsIAccessibleValue*>(this);
    1:       NS_ADDREF_THIS();
 4648:       return NS_OK;
    1:     }
    1:   }                       
    1: 
    1:   if (aIID.Equals(NS_GET_IID(nsIAccessibleHyperLink))) {
36989:     nsCOMPtr<nsIAccessibleHyperText> hyperTextParent =
36989:       nsAccUtils::QueryObject<nsIAccessibleHyperText>(GetParent());
36989: 
    1:     if (hyperTextParent) {
 3233:       *aInstancePtr = static_cast<nsIAccessibleHyperLink*>(this);
    1:       NS_ADDREF_THIS();
    1:       return NS_OK;
    1:     }
    1:     return NS_ERROR_NO_INTERFACE;
    1:   }
    1: 
 4470:   return nsAccessNodeWrap::QueryInterface(aIID, aInstancePtr);
    1: }
    1: 
    1: nsAccessible::nsAccessible(nsIDOMNode* aNode, nsIWeakReference* aShell): nsAccessNodeWrap(aNode, aShell), 
35523:   mParent(nsnull), mRoleMapEntry(nsnull),
35523:   mAreChildrenInitialized(PR_FALSE)
    1: {
    1: #ifdef NS_DEBUG_X
    1:    {
    1:      nsCOMPtr<nsIPresShell> shell(do_QueryReferent(aShell));
  732:      printf(">>> %p Created Acc - DOM: %p  PS: %p", 
 3233:             (void*)static_cast<nsIAccessible*>(this), (void*)aNode,
  732:             (void*)shell.get());
  732:     nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
  732:     if (content) {
  732:       nsAutoString buf;
  732:       if (content->NodeInfo())
  732:         content->NodeInfo()->GetQualifiedName(buf);
  732:       printf(" Con: %s@%p", NS_ConvertUTF16toUTF8(buf).get(), (void *)content.get());
  732:       if (NS_SUCCEEDED(GetName(buf))) {
  732:         printf(" Name:[%s]", NS_ConvertUTF16toUTF8(buf).get());
    1:        }
    1:      }
    1:      printf("\n");
    1:    }
    1: #endif
    1: }
    1: 
    1: //-----------------------------------------------------
    1: // destruction
    1: //-----------------------------------------------------
    1: nsAccessible::~nsAccessible()
    1: {
    1: }
    1: 
29320: void
29320: nsAccessible::SetRoleMapEntry(nsRoleMapEntry* aRoleMapEntry)
 7830: {
 7830:   mRoleMapEntry = aRoleMapEntry;
 7830: }
 7830: 
20246: NS_IMETHODIMP
20246: nsAccessible::GetName(nsAString& aName)
    1: {
    1:   aName.Truncate();
20246: 
20246:   if (IsDefunct())
20246:     return NS_ERROR_FAILURE;
20246: 
20246:   GetARIAName(aName);
20246:   if (!aName.IsEmpty())
    1:     return NS_OK;
20246: 
28315:   nsCOMPtr<nsIXBLAccessible> xblAccessible(do_QueryInterface(mDOMNode));
28315:   if (xblAccessible) {
29559:     xblAccessible->GetAccessibleName(aName);
28315:     if (!aName.IsEmpty())
28315:       return NS_OK;
28315:   }
28315: 
22205:   nsresult rv = GetNameInternal(aName);
22205:   NS_ENSURE_SUCCESS(rv, rv);
22205: 
22205:   if (!aName.IsEmpty())
22205:     return NS_OK;
22205: 
22205:   // In the end get the name from tooltip.
22205:   nsCOMPtr<nsIContent> content = nsCoreUtils::GetRoleContent(mDOMNode);
22205:   if (!content)
22205:     return NS_OK;
22205: 
22205:   nsIAtom *tooltipAttr = nsnull;
22205: 
33329:   if (content->IsHTML())
22205:     tooltipAttr = nsAccessibilityAtoms::title;
33329:   else if (content->IsXUL())
22205:     tooltipAttr = nsAccessibilityAtoms::tooltiptext;
22205:   else
22205:     return NS_OK;
22205: 
22205:   // XXX: if CompressWhiteSpace worked on nsAString we could avoid a copy.
22205:   nsAutoString name;
22205:   if (content->GetAttr(kNameSpaceID_None, tooltipAttr, name)) {
22205:     name.CompressWhitespace();
22205:     aName = name;
25591:     return NS_OK_NAME_FROM_TOOLTIP;
25591:   }
25591: 
25591:   if (rv != NS_OK_EMPTY_NAME)
22205:     aName.SetIsVoid(PR_TRUE);
22205: 
22205:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessible::GetDescription(nsAString& aDescription)
    1: {
27711:   if (IsDefunct())
27711:     return NS_ERROR_FAILURE;
27711: 
    1:   // There are 4 conditions that make an accessible have no accDescription:
    1:   // 1. it's a text node; or
    1:   // 2. It has no DHTML describedby property
    1:   // 3. it doesn't have an accName; or
    1:   // 4. its title attribute already equals to its accName nsAutoString name; 
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
27711:   NS_ASSERTION(content, "No content of valid accessible!");
27711:   if (!content)
27711:     return NS_ERROR_FAILURE;
27711: 
    1:   if (!content->IsNodeOfType(nsINode::eTEXT)) {
    1:     nsAutoString description;
25175:     nsresult rv = nsTextEquivUtils::
25175:       GetTextEquivFromIDRefs(this, nsAccessibilityAtoms::aria_describedby,
25175:                              description);
27711:     NS_ENSURE_SUCCESS(rv, rv);
27711: 
27711:     if (description.IsEmpty()) {
33329:       PRBool isXUL = content->IsXUL();
    1:       if (isXUL) {
    1:         // Try XUL <description control="[id]">description text</description>
    1:         nsIContent *descriptionContent =
20521:           nsCoreUtils::FindNeighbourPointingToNode(content,
20521:                                                    nsAccessibilityAtoms::control,
 8937:                                                    nsAccessibilityAtoms::description);
    1: 
    1:         if (descriptionContent) {
    1:           // We have a description content node
25175:           nsTextEquivUtils::
25175:             AppendTextEquivFromContent(this, descriptionContent, &description);
    1:         }
    1:       }
    1:       if (description.IsEmpty()) {
    1:         nsIAtom *descAtom = isXUL ? nsAccessibilityAtoms::tooltiptext :
    1:                                     nsAccessibilityAtoms::title;
    1:         if (content->GetAttr(kNameSpaceID_None, descAtom, description)) {
    1:           nsAutoString name;
    1:           GetName(name);
    1:           if (name.IsEmpty() || description == name) {
    1:             // Don't use tooltip for a description if this object
    1:             // has no name or the tooltip is the same as the name
    1:             description.Truncate();
    1:           }
    1:         }
    1:       }
    1:     }
    1:     description.CompressWhitespace();
    1:     aDescription = description;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // mask values for ui.key.chromeAccess and ui.key.contentAccess
    1: #define NS_MODIFIER_SHIFT    1
    1: #define NS_MODIFIER_CONTROL  2
    1: #define NS_MODIFIER_ALT      4
    1: #define NS_MODIFIER_META     8
    1: 
    1: // returns the accesskey modifier mask used in the given node's context
    1: // (i.e. chrome or content), or 0 if an error occurs
    1: static PRInt32
 5414: GetAccessModifierMask(nsIContent* aContent)
    1: {
    1:   nsCOMPtr<nsIPrefBranch> prefBranch =
    1:     do_GetService(NS_PREFSERVICE_CONTRACTID);
    1:   if (!prefBranch)
    1:     return 0;
    1: 
    1:   // use ui.key.generalAccessKey (unless it is -1)
    1:   PRInt32 accessKey;
    1:   nsresult rv = prefBranch->GetIntPref("ui.key.generalAccessKey", &accessKey);
    1:   if (NS_SUCCEEDED(rv) && accessKey != -1) {
    1:     switch (accessKey) {
    1:       case nsIDOMKeyEvent::DOM_VK_SHIFT:   return NS_MODIFIER_SHIFT;
    1:       case nsIDOMKeyEvent::DOM_VK_CONTROL: return NS_MODIFIER_CONTROL;
    1:       case nsIDOMKeyEvent::DOM_VK_ALT:     return NS_MODIFIER_ALT;
    1:       case nsIDOMKeyEvent::DOM_VK_META:    return NS_MODIFIER_META;
    1:       default:                             return 0;
    1:     }
    1:   }
    1: 
    1:   // get the docShell to this DOMNode, return 0 on failure
 5414:   nsCOMPtr<nsIDocument> document = aContent->GetCurrentDoc();
    1:   if (!document)
    1:     return 0;
    1:   nsCOMPtr<nsISupports> container = document->GetContainer();
    1:   if (!container)
    1:     return 0;
    1:   nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryInterface(container));
    1:   if (!treeItem)
    1:     return 0;
    1: 
    1:   // determine the access modifier used in this context
    1:   PRInt32 itemType, accessModifierMask = 0;
    1:   treeItem->GetItemType(&itemType);
    1:   switch (itemType) {
    1: 
    1:   case nsIDocShellTreeItem::typeChrome:
    1:     rv = prefBranch->GetIntPref("ui.key.chromeAccess", &accessModifierMask);
    1:     break;
    1: 
    1:   case nsIDocShellTreeItem::typeContent:
    1:     rv = prefBranch->GetIntPref("ui.key.contentAccess", &accessModifierMask);
    1:     break;
    1:   }
    1: 
    1:   return NS_SUCCEEDED(rv) ? accessModifierMask : 0;
    1: }
    1: 
 5414: NS_IMETHODIMP
 5414: nsAccessible::GetKeyboardShortcut(nsAString& aAccessKey)
    1: {
 5414:   aAccessKey.Truncate();
 5414: 
 5414:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
 5414:   if (!content)
    1:     return NS_ERROR_FAILURE;
 5414: 
20521:   PRUint32 key = nsCoreUtils::GetAccessKeyFor(content);
 6095:   if (!key && content->IsNodeOfType(nsIContent::eELEMENT)) {
 6095:     // Copy access key from label node unless it is labeled
 6095:     // via an ancestor <label>, in which case that would be redundant
20566:     nsCOMPtr<nsIContent> labelContent(nsCoreUtils::GetLabelContent(content));
37539:     nsCOMPtr<nsINode> thisNode = do_QueryInterface(mDOMNode);
37539:     if (labelContent && !nsCoreUtils::IsAncestorOf(labelContent, thisNode))
20521:       key = nsCoreUtils::GetAccessKeyFor(labelContent);
 5414:   }
 5414: 
 5414:   if (!key)
 5414:     return NS_OK;
 5414: 
 5414:   nsAutoString accesskey(key);
 5414: 
 5414:   // Append the modifiers in reverse order, result: Control+Alt+Shift+Meta+<key>
    1:   nsAutoString propertyKey;
 5414:   PRInt32 modifierMask = GetAccessModifierMask(content);
    1:   if (modifierMask & NS_MODIFIER_META) {
    1:     propertyKey.AssignLiteral("VK_META");
    1:     nsAccessible::GetFullKeyName(propertyKey, accesskey, accesskey);
    1:   }
    1:   if (modifierMask & NS_MODIFIER_SHIFT) {
    1:     propertyKey.AssignLiteral("VK_SHIFT");
    1:     nsAccessible::GetFullKeyName(propertyKey, accesskey, accesskey);
    1:   }
    1:   if (modifierMask & NS_MODIFIER_ALT) {
    1:     propertyKey.AssignLiteral("VK_ALT");
    1:     nsAccessible::GetFullKeyName(propertyKey, accesskey, accesskey);
    1:   }
    1:   if (modifierMask & NS_MODIFIER_CONTROL) {
    1:     propertyKey.AssignLiteral("VK_CONTROL");
    1:     nsAccessible::GetFullKeyName(propertyKey, accesskey, accesskey);
    1:   }
 5414: 
 5414:   aAccessKey = accesskey;
    1:   return NS_OK;
    1: }
    1: 
21169: nsresult
21169: nsAccessible::Shutdown()
    1: {
 8286:   // Invalidate the child count and pointers to other accessibles, also make
20072:   // sure none of its children point to this parent
    1:   InvalidateChildren();
    1:   if (mParent) {
36989:     mParent->InvalidateChildren();
    1:     mParent = nsnull;
    1:   }
    1: 
    1:   return nsAccessNodeWrap::Shutdown();
    1: }
    1: 
29320: NS_IMETHODIMP
29320: nsAccessible::GetParent(nsIAccessible **aParent)
29320: {
35523:   NS_ENSURE_ARG_POINTER(aParent);
35523: 
35523:   NS_IF_ADDREF(*aParent = GetParent());
35523:   return *aParent ? NS_OK : NS_ERROR_FAILURE;
35523: }
35523: 
35523:   /* readonly attribute nsIAccessible nextSibling; */
35523: NS_IMETHODIMP
35523: nsAccessible::GetNextSibling(nsIAccessible **aNextSibling) 
35523: {
35523:   NS_ENSURE_ARG_POINTER(aNextSibling);
35523: 
35523:   nsresult rv = NS_OK;
35523:   NS_IF_ADDREF(*aNextSibling = GetSiblingAtOffset(1, &rv));
35523:   return rv;
35523: }
35523: 
35523:   /* readonly attribute nsIAccessible previousSibling; */
35523: NS_IMETHODIMP
35523: nsAccessible::GetPreviousSibling(nsIAccessible * *aPreviousSibling) 
35523: {
35523:   NS_ENSURE_ARG_POINTER(aPreviousSibling);
35523: 
35523:   nsresult rv = NS_OK;
35523:   NS_IF_ADDREF(*aPreviousSibling = GetSiblingAtOffset(-1, &rv));
35523:   return rv;
35523: }
35523: 
35523:   /* readonly attribute nsIAccessible firstChild; */
35523: NS_IMETHODIMP
35523: nsAccessible::GetFirstChild(nsIAccessible **aFirstChild) 
35523: {
35523:   NS_ENSURE_ARG_POINTER(aFirstChild);
35523:   *aFirstChild = nsnull;
35523: 
35523:   if (gIsCacheDisabled)
35523:     InvalidateChildren();
35523: 
35523:   PRInt32 childCount = GetChildCount();
35523:   NS_ENSURE_TRUE(childCount != -1, NS_ERROR_FAILURE);
35523: 
35523:   if (childCount > 0)
35523:     NS_ADDREF(*aFirstChild = GetChildAt(0));
35523: 
35136:   return NS_OK;
35136: }
35136: 
35523:   /* readonly attribute nsIAccessible lastChild; */
35523: NS_IMETHODIMP
35523: nsAccessible::GetLastChild(nsIAccessible **aLastChild)
35136: {
35523:   NS_ENSURE_ARG_POINTER(aLastChild);
35523:   *aLastChild = nsnull;
35523: 
35523:   PRInt32 childCount = GetChildCount();
35523:   NS_ENSURE_TRUE(childCount != -1, NS_ERROR_FAILURE);
35523: 
35523:   NS_IF_ADDREF(*aLastChild = GetChildAt(childCount - 1));
35523:   return NS_OK;
35523: }
35523: 
35523: NS_IMETHODIMP
35523: nsAccessible::GetChildAt(PRInt32 aChildIndex, nsIAccessible **aChild)
35136: {
35523:   NS_ENSURE_ARG_POINTER(aChild);
35523:   *aChild = nsnull;
35523: 
35523:   PRInt32 childCount = GetChildCount();
35523:   NS_ENSURE_TRUE(childCount != -1, NS_ERROR_FAILURE);
35523: 
35523:   // If child index is negative, then return last child.
35523:   // XXX: do we really need this?
35523:   if (aChildIndex < 0)
35523:     aChildIndex = childCount - 1;
35523: 
36989:   nsAccessible* child = GetChildAt(aChildIndex);
35523:   if (!child)
35523:     return NS_ERROR_INVALID_ARG;
35523: 
35523:   NS_ADDREF(*aChild = child);
35523:   return NS_OK;
35523: }
35523: 
35523: // readonly attribute nsIArray children;
35523: NS_IMETHODIMP
35523: nsAccessible::GetChildren(nsIArray **aOutChildren)
35133: {
35523:   NS_ENSURE_ARG_POINTER(aOutChildren);
10871:   *aOutChildren = nsnull;
35523: 
35523:   PRInt32 childCount = GetChildCount();
35523:   NS_ENSURE_TRUE(childCount != -1, NS_ERROR_FAILURE);
35523: 
35523:   nsresult rv = NS_OK;
35523:   nsCOMPtr<nsIMutableArray> children =
35523:     do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
35523:   NS_ENSURE_SUCCESS(rv, rv);
35523: 
35523:   for (PRInt32 childIdx = 0; childIdx < childCount; childIdx++) {
35523:     nsIAccessible* child = GetChildAt(childIdx);
35523:     children->AppendElement(child, PR_FALSE);
    1:   }
    1: 
    1:   NS_ADDREF(*aOutChildren = children);
    1:   return NS_OK;
    1: }
    1: 
    1: nsIAccessible *nsAccessible::NextChild(nsCOMPtr<nsIAccessible>& aAccessible)
    1: {
    1:   nsCOMPtr<nsIAccessible> nextChild;
    1:   if (!aAccessible) {
    1:     GetFirstChild(getter_AddRefs(nextChild));
    1:   }
    1:   else {
    1:     aAccessible->GetNextSibling(getter_AddRefs(nextChild));
    1:   }
    1:   return (aAccessible = nextChild);
    1: }
    1: 
29320: PRBool
29320: nsAccessible::GetAllowsAnonChildAccessibles()
    1: {
29320:   return PR_TRUE;
    1: }
    1: 
    1: /* readonly attribute long childCount; */
35523: NS_IMETHODIMP
35523: nsAccessible::GetChildCount(PRInt32 *aChildCount) 
    1: {
35523:   NS_ENSURE_ARG_POINTER(aChildCount);
35523: 
35523:   *aChildCount = GetChildCount();
35523:   return *aChildCount != -1 ? NS_OK : NS_ERROR_FAILURE;  
    1: }
    1: 
    1: /* readonly attribute long indexInParent; */
35523: NS_IMETHODIMP
35523: nsAccessible::GetIndexInParent(PRInt32 *aIndexInParent)
    1: {
35523:   NS_ENSURE_ARG_POINTER(aIndexInParent);
35523: 
35523:   *aIndexInParent = GetIndexInParent();
35523:   return *aIndexInParent != -1 ? NS_OK : NS_ERROR_FAILURE;
    1: }
    1: 
    1: nsresult nsAccessible::GetTranslatedString(const nsAString& aKey, nsAString& aStringOut)
    1: {
    1:   nsXPIDLString xsValue;
    1: 
    1:   if (!gStringBundle || 
    1:     NS_FAILED(gStringBundle->GetStringFromName(PromiseFlatString(aKey).get(), getter_Copies(xsValue)))) 
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   aStringOut.Assign(xsValue);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsAccessible::GetFullKeyName(const nsAString& aModifierName, const nsAString& aKeyName, nsAString& aStringOut)
    1: {
    1:   nsXPIDLString modifierName, separator;
    1: 
    1:   if (!gKeyStringBundle ||
    1:       NS_FAILED(gKeyStringBundle->GetStringFromName(PromiseFlatString(aModifierName).get(), 
    1:                                                     getter_Copies(modifierName))) ||
    1:       NS_FAILED(gKeyStringBundle->GetStringFromName(PromiseFlatString(NS_LITERAL_STRING("MODIFIER_SEPARATOR")).get(), 
    1:                                                     getter_Copies(separator)))) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   aStringOut = modifierName + separator + aKeyName; 
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool nsAccessible::IsVisible(PRBool *aIsOffscreen) 
    1: {
    1:   // We need to know if at least a kMinPixels around the object is visible
    1:   // Otherwise it will be marked nsIAccessibleStates::STATE_OFFSCREEN
    1:   // The STATE_INVISIBLE flag is for elements which are programmatically hidden
    1:   
  733:   *aIsOffscreen = PR_TRUE;
 7763:   if (!mDOMNode) {
 7763:     return PR_FALSE; // Defunct object
 7763:   }
    1: 
    1:   const PRUint16 kMinPixels  = 12;
    1:    // Set up the variables we need, return false if we can't get at them all
    1:   nsCOMPtr<nsIPresShell> shell(GetPresShell());
    1:   if (!shell) 
    1:     return PR_FALSE;
    1: 
    1:   nsIFrame *frame = GetFrame();
    1:   if (!frame) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   // If visibility:hidden or visibility:collapsed then mark with STATE_INVISIBLE
    1:   if (!frame->GetStyleVisibility()->IsVisible())
    1:   {
    1:       return PR_FALSE;
    1:   }
    1: 
    1:   // We don't use the more accurate GetBoundsRect, because that is more expensive
    1:   // and the STATE_OFFSCREEN flag that this is used for only needs to be a rough
    1:   // indicator
37073:   nsSize frameSize = frame->GetSize();
37073:   nsRectVisibility rectVisibility =
37073:     shell->GetRectVisibility(frame, nsRect(nsPoint(0,0), frameSize),
37073:                              nsPresContext::CSSPixelsToAppUnits(kMinPixels));
37073: 
37073:   if (frame->GetRect().IsEmpty()) {
37073:     PRBool isEmpty = PR_TRUE;
37073: 
 9480:     nsIAtom *frameType = frame->GetType();
 9480:     if (frameType == nsAccessibilityAtoms::textFrame) {
    1:       // Zero area rects can occur in the first frame of a multi-frame text flow,
 9480:       // in which case the rendered text is not empty and the frame should not be marked invisible
 9480:       nsAutoString renderedText;
 9480:       frame->GetRenderedText (&renderedText, nsnull, nsnull, 0, 1);
37073:       isEmpty = renderedText.IsEmpty();
 9480:     }
 9480:     else if (frameType == nsAccessibilityAtoms::inlineFrame) {
    1:       // Yuck. Unfortunately inline frames can contain larger frames inside of them,
    1:       // so we can't really believe this is a zero area rect without checking more deeply.
    1:       // GetBounds() will do that for us.
    1:       PRInt32 x, y, width, height;
    1:       GetBounds(&x, &y, &width, &height);
37073:       isEmpty = width == 0 || height == 0;
37073:     }
37073: 
37073:     if (isEmpty && !(frame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
37073:       // Consider zero area objects hidden unless they are absolutely positioned
 7763:       // or floating and may have descendants that have a non-zero size
 7763:       return PR_FALSE;
  733:     }
37073:   }
37073: 
37073:   // The frame intersects the viewport, but we need to check the parent view chain :(
    1:   nsCOMPtr<nsIDOMDocument> domDoc;
    1:   mDOMNode->GetOwnerDocument(getter_AddRefs(domDoc));
    1:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(domDoc));
  733:   if (!doc)  {
  673:     return PR_FALSE;
    1:   }
    1: 
37074:   nsIFrame* frameWithView =
37074:     frame->HasView() ? frame : frame->GetAncestorWithViewExternal();
37074:   nsIView* view = frameWithView->GetViewExternal();
37074:   PRBool isVisible = CheckVisibilityInParentChain(doc, view);
  733:   if (isVisible && rectVisibility == nsRectVisibility_kVisible) {
  733:     *aIsOffscreen = PR_FALSE;
  733:   }
  733:   return isVisible;
  733: }
  733: 
 5424: nsresult
21256: nsAccessible::GetStateInternal(PRUint32 *aState, PRUint32 *aExtraState)
    1: {
    1:   *aState = 0;
    1: 
21984:   if (IsDefunct()) {
21984:     if (aExtraState)
 8052:       *aExtraState = nsIAccessibleStates::EXT_STATE_DEFUNCT;
21984: 
21984:     return NS_OK_DEFUNCT_OBJECT;
 8052:   }
 8052: 
  262:   if (aExtraState)
  262:     *aExtraState = 0;
  262: 
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
  618:   if (!content) {
  618:     return NS_OK;  // On document, this is not an error
  618:   }
    1: 
    1:   // Set STATE_UNAVAILABLE state based on disabled attribute
    1:   // The disabled attribute is mostly used in XUL elements and HTML forms, but
    1:   // if someone sets it on another attribute, 
    1:   // it seems reasonable to consider it unavailable
    1:   PRBool isDisabled;
33329:   if (content->IsHTML()) {
    1:     // In HTML, just the presence of the disabled attribute means it is disabled,
    1:     // therefore disabled="false" indicates disabled!
    1:     isDisabled = content->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::disabled);
    1:   }
    1:   else {
    1:     isDisabled = content->AttrValueIs(kNameSpaceID_None,
    1:                                       nsAccessibilityAtoms::disabled,
    1:                                       nsAccessibilityAtoms::_true,
    1:                                       eCaseMatters);
    1:   }
    1:   if (isDisabled) {
    1:     *aState |= nsIAccessibleStates::STATE_UNAVAILABLE;
    1:   }
    1:   else if (content->IsNodeOfType(nsINode::eELEMENT)) {
    1:     nsIFrame *frame = GetFrame();
    1:     if (frame && frame->IsFocusable()) {
    1:       *aState |= nsIAccessibleStates::STATE_FOCUSABLE;
    1:     }
    1: 
    1:     if (gLastFocusedNode == mDOMNode) {
    1:       *aState |= nsIAccessibleStates::STATE_FOCUSED;
    1:     }
    1:   }
    1: 
    1:   // Check if nsIAccessibleStates::STATE_INVISIBLE and
    1:   // STATE_OFFSCREEN flags should be turned on for this object.
    1:   PRBool isOffscreen;
    1:   if (!IsVisible(&isOffscreen)) {
    1:     *aState |= nsIAccessibleStates::STATE_INVISIBLE;
    1:   }
    1:   if (isOffscreen) {
    1:     *aState |= nsIAccessibleStates::STATE_OFFSCREEN;
    1:   }
    1: 
 5707:   nsIFrame *frame = GetFrame();
 5707:   if (frame && (frame->GetStateBits() & NS_FRAME_OUT_OF_FLOW))
 5707:     *aState |= nsIAccessibleStates::STATE_FLOATING;
 5707: 
31782:   // Check if a XUL element has the popup attribute (an attached popup menu).
33329:   if (content->IsXUL())
31782:     if (content->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::popup))
31782:       *aState |= nsIAccessibleStates::STATE_HASPOPUP;
31782: 
13757:   // Add 'linked' state for simple xlink.
20521:   if (nsCoreUtils::IsXLink(content))
13757:     *aState |= nsIAccessibleStates::STATE_LINKED;
13757: 
    1:   return NS_OK;
    1: }
    1: 
    1:   /* readonly attribute boolean focusedChild; */
    1: NS_IMETHODIMP nsAccessible::GetFocusedChild(nsIAccessible **aFocusedChild) 
    1: { 
    1:   nsCOMPtr<nsIAccessible> focusedChild;
    1:   if (gLastFocusedNode == mDOMNode) {
    1:     focusedChild = this;
    1:   }
    1:   else if (gLastFocusedNode) {
    1:     nsCOMPtr<nsIAccessibilityService> accService =
    1:       do_GetService("@mozilla.org/accessibilityService;1");
    1:     NS_ENSURE_TRUE(accService, NS_ERROR_FAILURE);
  674: 
  674:     accService->GetAccessibleFor(gLastFocusedNode,
    1:                                  getter_AddRefs(focusedChild));
    1:     if (focusedChild) {
    1:       nsCOMPtr<nsIAccessible> focusedParentAccessible;
    1:       focusedChild->GetParent(getter_AddRefs(focusedParentAccessible));
    1:       if (focusedParentAccessible != this) {
    1:         focusedChild = nsnull;
    1:       }
    1:     }
    1:   }
    1: 
    1:   NS_IF_ADDREF(*aFocusedChild = focusedChild);
    1:   return NS_OK;
    1: }
    1: 
28197: // nsAccessible::GetChildAtPoint()
28197: nsresult
28197: nsAccessible::GetChildAtPoint(PRInt32 aX, PRInt32 aY, PRBool aDeepestChild,
28197:                               nsIAccessible **aChild)
    1: {
 6068:   // If we can't find the point in a child, we will return the fallback answer:
28197:   // we return |this| if the point is within it, otherwise nsnull.
28197:   PRInt32 x = 0, y = 0, width = 0, height = 0;
28197:   nsresult rv = GetBounds(&x, &y, &width, &height);
28197:   NS_ENSURE_SUCCESS(rv, rv);
28197: 
 6068:   nsCOMPtr<nsIAccessible> fallbackAnswer;
28197:   if (aX >= x && aX < x + width && aY >= y && aY < y + height)
 6068:     fallbackAnswer = this;
28197: 
20566:   if (nsAccUtils::MustPrune(this)) {  // Do not dig any further
28197:     NS_IF_ADDREF(*aChild = fallbackAnswer);
 6068:     return NS_OK;
 6068:   }
 6068: 
 5680:   // Search an accessible at the given point starting from accessible document
 5680:   // because containing block (see CSS2) for out of flow element (for example,
 5680:   // absolutely positioned element) may be different from its DOM parent and
 5680:   // therefore accessible for containing block may be different from accessible
 5680:   // for DOM parent but GetFrameForPoint() should be called for containing block
 5680:   // to get an out of flow element.
 5680:   nsCOMPtr<nsIAccessibleDocument> accDocument;
28197:   rv = GetAccessibleDocument(getter_AddRefs(accDocument));
 5680:   NS_ENSURE_SUCCESS(rv, rv);
 6068:   NS_ENSURE_TRUE(accDocument, NS_ERROR_FAILURE);
 5680: 
21169:   nsRefPtr<nsAccessNode> docAccessNode =
21169:     nsAccUtils::QueryAccessNode(accDocument);
21169: 
21169:   nsIFrame *frame = docAccessNode->GetFrame();
 5680:   NS_ENSURE_STATE(frame);
 5680: 
 5680:   nsPresContext *presContext = frame->PresContext();
 5680: 
 5680:   nsIntRect screenRect = frame->GetScreenRectExternal();
 5680:   nsPoint offset(presContext->DevPixelsToAppUnits(aX - screenRect.x),
 5680:                  presContext->DevPixelsToAppUnits(aY - screenRect.y));
 5680: 
 5680:   nsCOMPtr<nsIPresShell> presShell = presContext->PresShell();
 5680:   nsIFrame *foundFrame = presShell->GetFrameForPoint(frame, offset);
28197: 
28197:   nsIContent* content = nsnull;
 6068:   if (!foundFrame || !(content = foundFrame->GetContent())) {
28197:     NS_IF_ADDREF(*aChild = fallbackAnswer);
    1:     return NS_OK;
 6068:   }
 5680: 
 5680:   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(content));
 5680:   nsCOMPtr<nsIAccessibilityService> accService = GetAccService();
 5680: 
 5680:   nsCOMPtr<nsIDOMNode> relevantNode;
 5680:   accService->GetRelevantContentNodeFor(node, getter_AddRefs(relevantNode));
 6068:   if (!relevantNode) {
28197:     NS_IF_ADDREF(*aChild = fallbackAnswer);
 5680:     return NS_OK;
 6068:   }
 5680: 
 5680:   nsCOMPtr<nsIAccessible> accessible;
 5680:   accService->GetAccessibleFor(relevantNode, getter_AddRefs(accessible));
 6068:   if (!accessible) {
 6068:     // No accessible for the node with the point, so find the first
 6068:     // accessible in the DOM parent chain
 6486:     accDocument->GetAccessibleInParentChain(relevantNode, PR_TRUE,
 6068:                                             getter_AddRefs(accessible));
 6068:     if (!accessible) {
28197:       NS_IF_ADDREF(*aChild = fallbackAnswer);
 5680:       return NS_OK;
 6068:     }
 6068:   }
 6068: 
 6068:   if (accessible == this) {
28197:     // Manually walk through accessible children and see if the are within this
28197:     // point. Skip offscreen or invisible accessibles. This takes care of cases
28197:     // where layout won't walk into things for us, such as image map areas and
28197:     // sub documents (XXX: subdocuments should be handled by methods of
28197:     // nsOuterDocAccessibles).
 6068:     nsCOMPtr<nsIAccessible> child;
 6068:     while (NextChild(child)) {
 6068:       PRInt32 childX, childY, childWidth, childHeight;
 6068:       child->GetBounds(&childX, &childY, &childWidth, &childHeight);
 6068:       if (aX >= childX && aX < childX + childWidth &&
 6068:           aY >= childY && aY < childY + childHeight &&
20566:           (nsAccUtils::State(child) & nsIAccessibleStates::STATE_INVISIBLE) == 0) {
28197: 
28197:         if (aDeepestChild)
28197:           return child->GetDeepestChildAtPoint(aX, aY, aChild);
28197: 
28197:         NS_IF_ADDREF(*aChild = child);
 6068:         return NS_OK;
 6068:       }
 6068:     }
28197: 
28197:     // The point is in this accessible but not in a child. We are allowed to
28197:     // return |this| as the answer.
28197:     NS_IF_ADDREF(*aChild = accessible);
28197:     return NS_OK;
28197:   }
28197: 
28197:   // Since DOM node of obtained accessible may be out of flow then we should
28197:   // ensure obtained accessible is a child of this accessible.
28197:   nsCOMPtr<nsIAccessible> parent, child(accessible);
28197:   while (PR_TRUE) {
28197:     child->GetParent(getter_AddRefs(parent));
28197:     if (!parent) {
28197:       // Reached the top of the hierarchy. These bounds were inside an
28197:       // accessible that is not a descendant of this one.
28197:       NS_IF_ADDREF(*aChild = fallbackAnswer);      
28197:       return NS_OK;
28197:     }
28197: 
28197:     if (parent == this) {
28197:       NS_ADDREF(*aChild = (aDeepestChild ? accessible : child));
28197:       return NS_OK;
28197:     }
28197:     child.swap(parent);
28197:   }
28197: 
19323:   return NS_OK;
19323: }
19323: 
19323: // nsIAccessible getChildAtPoint(in long x, in long y)
19323: NS_IMETHODIMP
19323: nsAccessible::GetChildAtPoint(PRInt32 aX, PRInt32 aY,
19323:                               nsIAccessible **aAccessible)
19323: {
28197:   NS_ENSURE_ARG_POINTER(aAccessible);
28197:   *aAccessible = nsnull;
28197: 
28197:   if (IsDefunct())
28197:     return NS_ERROR_FAILURE;
28197: 
28197:   return GetChildAtPoint(aX, aY, PR_FALSE, aAccessible);
28197: }
28197: 
28197: // nsIAccessible getDeepestChildAtPoint(in long x, in long y)
28197: NS_IMETHODIMP
28197: nsAccessible::GetDeepestChildAtPoint(PRInt32 aX, PRInt32 aY,
28197:                                      nsIAccessible **aAccessible)
28197: {
28197:   NS_ENSURE_ARG_POINTER(aAccessible);
28197:   *aAccessible = nsnull;
28197: 
28197:   if (IsDefunct())
28197:     return NS_ERROR_FAILURE;
28197: 
28197:   return GetChildAtPoint(aX, aY, PR_TRUE, aAccessible);
    1: }
    1: 
    1: void nsAccessible::GetBoundsRect(nsRect& aTotalBounds, nsIFrame** aBoundingFrame)
    1: {
    1: /*
    1:  * This method is used to determine the bounds of a content node.
    1:  * Because HTML wraps and links are not always rectangular, this
    1:  * method uses the following algorithm:
    1:  *
    1:  * 1) Start with an empty rectangle
    1:  * 2) Add the rect for the primary frame from for the DOM node.
    1:  * 3) For each next frame at the same depth with the same DOM node, add that rect to total
    1:  * 4) If that frame is an inline frame, search deeper at that point in the tree, adding all rects
    1:  */
    1: 
    1:   // Initialization area
    1:   *aBoundingFrame = nsnull;
    1:   nsIFrame *firstFrame = GetBoundsFrame();
    1:   if (!firstFrame)
    1:     return;
    1: 
    1:   // Find common relative parent
    1:   // This is an ancestor frame that will incompass all frames for this content node.
    1:   // We need the relative parent so we can get absolute screen coordinates
    1:   nsIFrame *ancestorFrame = firstFrame;
    1: 
    1:   while (ancestorFrame) {  
    1:     *aBoundingFrame = ancestorFrame;
    1:     // If any other frame type, we only need to deal with the primary frame
    1:     // Otherwise, there may be more frames attached to the same content node
20566:     if (!nsCoreUtils::IsCorrectFrameType(ancestorFrame,
20566:                                          nsAccessibilityAtoms::inlineFrame) &&
20566:         !nsCoreUtils::IsCorrectFrameType(ancestorFrame,
20566:                                          nsAccessibilityAtoms::textFrame))
    1:       break;
    1:     ancestorFrame = ancestorFrame->GetParent();
    1:   }
    1: 
    1:   nsIFrame *iterFrame = firstFrame;
    1:   nsCOMPtr<nsIContent> firstContent(do_QueryInterface(mDOMNode));
    1:   nsIContent* iterContent = firstContent;
    1:   PRInt32 depth = 0;
    1: 
    1:   // Look only at frames below this depth, or at this depth (if we're still on the content node we started with)
    1:   while (iterContent == firstContent || depth > 0) {
    1:     // Coordinates will come back relative to parent frame
    1:     nsRect currFrameBounds = iterFrame->GetRect();
    1:     
    1:     // Make this frame's bounds relative to common parent frame
    1:     currFrameBounds +=
    1:       iterFrame->GetParent()->GetOffsetToExternal(*aBoundingFrame);
    1: 
    1:     // Add this frame's bounds to total
    1:     aTotalBounds.UnionRect(aTotalBounds, currFrameBounds);
    1: 
    1:     nsIFrame *iterNextFrame = nsnull;
    1: 
20566:     if (nsCoreUtils::IsCorrectFrameType(iterFrame,
20566:                                         nsAccessibilityAtoms::inlineFrame)) {
    1:       // Only do deeper bounds search if we're on an inline frame
    1:       // Inline frames can contain larger frames inside of them
    1:       iterNextFrame = iterFrame->GetFirstChild(nsnull);
    1:     }
    1: 
    1:     if (iterNextFrame) 
    1:       ++depth;  // Child was found in code above this: We are going deeper in this iteration of the loop
    1:     else {  
    1:       // Use next sibling if it exists, or go back up the tree to get the first next-in-flow or next-sibling 
    1:       // within our search
    1:       while (iterFrame) {
    1:         iterNextFrame = iterFrame->GetNextContinuation();
    1:         if (!iterNextFrame)
    1:           iterNextFrame = iterFrame->GetNextSibling();
    1:         if (iterNextFrame || --depth < 0) 
    1:           break;
    1:         iterFrame = iterFrame->GetParent();
    1:       }
    1:     }
    1: 
    1:     // Get ready for the next round of our loop
    1:     iterFrame = iterNextFrame;
    1:     if (iterFrame == nsnull)
    1:       break;
    1:     iterContent = nsnull;
    1:     if (depth == 0)
    1:       iterContent = iterFrame->GetContent();
    1:   }
    1: }
    1: 
    1: 
    1: /* void getBounds (out long x, out long y, out long width, out long height); */
    1: NS_IMETHODIMP nsAccessible::GetBounds(PRInt32 *x, PRInt32 *y, PRInt32 *width, PRInt32 *height)
    1: {
    1:   // This routine will get the entire rectange for all the frames in this node
    1:   // -------------------------------------------------------------------------
    1:   //      Primary Frame for node
    1:   //  Another frame, same node                <- Example
    1:   //  Another frame, same node
    1: 
    1:   nsPresContext *presContext = GetPresContext();
    1:   if (!presContext)
    1:   {
    1:     *x = *y = *width = *height = 0;
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsRect unionRectTwips;
    1:   nsIFrame* aBoundingFrame = nsnull;
    1:   GetBoundsRect(unionRectTwips, &aBoundingFrame);   // Unions up all primary frames for this node and all siblings after it
    1:   if (!aBoundingFrame) {
    1:     *x = *y = *width = *height = 0;
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   *x      = presContext->AppUnitsToDevPixels(unionRectTwips.x); 
    1:   *y      = presContext->AppUnitsToDevPixels(unionRectTwips.y);
    1:   *width  = presContext->AppUnitsToDevPixels(unionRectTwips.width);
    1:   *height = presContext->AppUnitsToDevPixels(unionRectTwips.height);
    1: 
    1:   // We have the union of the rectangle, now we need to put it in absolute screen coords
    1: 
23738:   nsIntRect orgRectPixels = aBoundingFrame->GetScreenRectExternal();
    1:   *x += orgRectPixels.x;
    1:   *y += orgRectPixels.y;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // helpers
    1: 
    1: nsIFrame* nsAccessible::GetBoundsFrame()
    1: {
    1:   return GetFrame();
    1: }
    1: 
    1: /* void removeSelection (); */
    1: NS_IMETHODIMP nsAccessible::SetSelected(PRBool aSelect)
    1: {
    1:   // Add or remove selection
    1:   if (!mDOMNode) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
20566:   PRUint32 state = nsAccUtils::State(this);
    1:   if (state & nsIAccessibleStates::STATE_SELECTABLE) {
20566:     nsCOMPtr<nsIAccessible> multiSelect =
35584:       nsAccUtils::GetMultiSelectableContainer(mDOMNode);
    1:     if (!multiSelect) {
    1:       return aSelect ? TakeFocus() : NS_ERROR_FAILURE;
    1:     }
    1:     nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
    1:     NS_ASSERTION(content, "Called for dead accessible");
    1: 
 6279:     if (mRoleMapEntry) {
    1:       if (aSelect) {
 6279:         return content->SetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_selected,
 6279:                                 NS_LITERAL_STRING("true"), PR_TRUE);
 6279:       }
 6279:       return content->UnsetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_selected, PR_TRUE);
 6279:     }
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: /* void takeSelection (); */
    1: NS_IMETHODIMP nsAccessible::TakeSelection()
    1: {
    1:   // Select only this item
    1:   if (!mDOMNode) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
20566:   PRUint32 state = nsAccUtils::State(this);
    1:   if (state & nsIAccessibleStates::STATE_SELECTABLE) {
20566:     nsCOMPtr<nsIAccessible> multiSelect =
35584:       nsAccUtils::GetMultiSelectableContainer(mDOMNode);
    1:     if (multiSelect) {
    1:       nsCOMPtr<nsIAccessibleSelectable> selectable = do_QueryInterface(multiSelect);
    1:       selectable->ClearSelection();
    1:     }
    1:     return SetSelected(PR_TRUE);
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: /* void takeFocus (); */
14605: NS_IMETHODIMP
14605: nsAccessible::TakeFocus()
    1: {
14605:   if (IsDefunct())
14605:     return NS_ERROR_FAILURE;
14605: 
14605:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
14605: 
14605:   nsIFrame *frame = GetFrame();
14605:   NS_ENSURE_STATE(frame);
14605: 
14605:   // If the current element can't take real DOM focus and if it has an ID and
14605:   // ancestor with a the aria-activedescendant attribute present, then set DOM
14605:   // focus to that ancestor and set aria-activedescendant on the ancestor to
14605:   // the ID of the desired element.
14605:   if (!frame->IsFocusable()) {
14605:     nsAutoString id;
20521:     if (content && nsCoreUtils::GetID(content, id)) {
14605: 
14605:       nsCOMPtr<nsIContent> ancestorContent = content;
14605:       while ((ancestorContent = ancestorContent->GetParent()) &&
14605:              !ancestorContent->HasAttr(kNameSpaceID_None,
14605:                                        nsAccessibilityAtoms::aria_activedescendant));
14605: 
14605:       if (ancestorContent) {
14605:         nsCOMPtr<nsIPresShell> presShell(do_QueryReferent(mWeakShell));
14605:         if (presShell) {
36654:           nsIFrame *frame = ancestorContent->GetPrimaryFrame();
14605:           if (frame && frame->IsFocusable()) {
14605: 
14605:             content = ancestorContent;            
14605:             content->SetAttr(kNameSpaceID_None,
14605:                              nsAccessibilityAtoms::aria_activedescendant,
14605:                              id, PR_TRUE);
14605:           }
14605:         }
14605:       }
14605:     }
14605:   }
14605: 
29018:   nsCOMPtr<nsIDOMElement> element(do_QueryInterface(content));
29018:   nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
29018:   if (fm)
29018:     fm->SetFocus(element, 0);
29018: 
    1:   return NS_OK;
    1: }
    1: 
22204: nsresult
22204: nsAccessible::GetHTMLName(nsAString& aLabel)
    1: {
20566:   nsCOMPtr<nsIContent> content = nsCoreUtils::GetRoleContent(mDOMNode);
20362:   if (!content) {
20362:     aLabel.SetIsVoid(PR_TRUE);
18793:     return NS_OK;
20362:   }
    1: 
20566:   nsIContent *labelContent = nsCoreUtils::GetHTMLLabelContent(content);
    1:   if (labelContent) {
20246:     nsAutoString label;
25175:     nsresult rv =
25175:       nsTextEquivUtils::AppendTextEquivFromContent(this, labelContent, &label);
20362:     NS_ENSURE_SUCCESS(rv, rv);
20362: 
    1:     label.CompressWhitespace();
    1:     if (!label.IsEmpty()) {
    1:       aLabel = label;
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
25175:   return nsTextEquivUtils::GetNameFromSubtree(this, aLabel);
    1: }
    1: 
    1: /**
    1:   * 3 main cases for XUL Controls to be labeled
    1:   *   1 - control contains label="foo"
    1:   *   2 - control has, as a child, a label element
    1:   *        - label has either value="foo" or children
    1:   *   3 - non-child label contains control="controlID"
    1:   *        - label has either value="foo" or children
    1:   * Once a label is found, the search is discontinued, so a control
    1:   *  that has a label child as well as having a label external to
    1:   *  the control that uses the control="controlID" syntax will use
    1:   *  the child label for its Name.
    1:   */
22204: nsresult
22204: nsAccessible::GetXULName(nsAString& aLabel)
    1: {
20246:   // CASE #1 (via label attribute) -- great majority of the cases
20246:   nsresult rv = NS_OK;
20246: 
    1:   nsAutoString label;
    1:   nsCOMPtr<nsIDOMXULLabeledControlElement> labeledEl(do_QueryInterface(mDOMNode));
    1:   if (labeledEl) {
    1:     rv = labeledEl->GetLabel(label);
    1:   }
    1:   else {
    1:     nsCOMPtr<nsIDOMXULSelectControlItemElement> itemEl(do_QueryInterface(mDOMNode));
    1:     if (itemEl) {
    1:       rv = itemEl->GetLabel(label);
    1:     }
    1:     else {
    1:       nsCOMPtr<nsIDOMXULSelectControlElement> select(do_QueryInterface(mDOMNode));
    1:       // Use label if this is not a select control element which 
    1:       // uses label attribute to indicate which option is selected
    1:       if (!select) {
    1:         nsCOMPtr<nsIDOMXULElement> xulEl(do_QueryInterface(mDOMNode));
    1:         if (xulEl) {
    1:           rv = xulEl->GetAttribute(NS_LITERAL_STRING("label"), label);
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   // CASES #2 and #3 ------ label as a child or <label control="id" ... > </label>
20566:   nsCOMPtr<nsIContent> content = nsCoreUtils::GetRoleContent(mDOMNode);
20246:   if (!content)
20246:     return NS_OK;
20246: 
    1:   if (NS_FAILED(rv) || label.IsEmpty()) {
    1:     label.Truncate();
    1:     nsIContent *labelContent =
20521:       nsCoreUtils::FindNeighbourPointingToNode(content, nsAccessibilityAtoms::control,
 8937:                                                nsAccessibilityAtoms::label);
    1: 
    1:     nsCOMPtr<nsIDOMXULLabelElement> xulLabel(do_QueryInterface(labelContent));
    1:     // Check if label's value attribute is used
    1:     if (xulLabel && NS_SUCCEEDED(xulLabel->GetValue(label)) && label.IsEmpty()) {
    1:       // If no value attribute, a non-empty label must contain
20072:       // children that define its text -- possibly using HTML
25175:       nsTextEquivUtils::AppendTextEquivFromContent(this, labelContent, &label);
    1:     }
    1:   }
    1: 
    1:   // XXX If CompressWhiteSpace worked on nsAString we could avoid a copy
    1:   label.CompressWhitespace();
    1:   if (!label.IsEmpty()) {
    1:     aLabel = label;
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Can get text from title of <toolbaritem> if we're a child of a <toolbaritem>
    1:   nsIContent *bindingParent = content->GetBindingParent();
    1:   nsIContent *parent = bindingParent? bindingParent->GetParent() :
    1:                                       content->GetParent();
    1:   while (parent) {
    1:     if (parent->Tag() == nsAccessibilityAtoms::toolbaritem &&
    1:         parent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::title, label)) {
    1:       label.CompressWhitespace();
    1:       aLabel = label;
    1:       return NS_OK;
    1:     }
    1:     parent = parent->GetParent();
    1:   }
    1: 
25175:   return nsTextEquivUtils::GetNameFromSubtree(this, aLabel);
    1: }
    1: 
29320: nsresult
37299: nsAccessible::HandleAccEvent(nsAccEvent *aEvent)
  511: {
  763:   NS_ENSURE_ARG_POINTER(aEvent);
  763:   nsCOMPtr<nsIDOMNode> eventNode;
  763:   aEvent->GetDOMNode(getter_AddRefs(eventNode));
20566:   NS_ENSURE_TRUE(nsAccUtils::IsNodeRelevant(eventNode), NS_ERROR_FAILURE);
  763: 
  511:   nsCOMPtr<nsIObserverService> obsService =
  511:     do_GetService("@mozilla.org/observer-service;1");
  511:   NS_ENSURE_TRUE(obsService, NS_ERROR_FAILURE);
  511: 
  511:   return obsService->NotifyObservers(aEvent, NS_ACCESSIBLE_EVENT_TOPIC, nsnull);
    1: }
    1: 
25822: NS_IMETHODIMP
25822: nsAccessible::GetRole(PRUint32 *aRole)
    1: {
 4850:   NS_ENSURE_ARG_POINTER(aRole);
29085: 
 4850:   *aRole = nsIAccessibleRole::ROLE_NOTHING;
 4850: 
29085:   if (IsDefunct())
29085:     return NS_ERROR_FAILURE;
29085: 
    1:   if (mRoleMapEntry) {
    1:     *aRole = mRoleMapEntry->role;
 4265: 
 4265:     // These unfortunate exceptions don't fit into the ARIA table
 4265:     // This is where the nsIAccessible role depends on both the role and ARIA state
11615:     if (*aRole == nsIAccessibleRole::ROLE_PUSHBUTTON) {
 4265:       nsCOMPtr<nsIContent> content = do_QueryInterface(mDOMNode);
 4265:       if (content) {
23549:         if (nsAccUtils::HasDefinedARIAToken(content, nsAccessibilityAtoms::aria_pressed)) {
23549:           // For simplicity, any existing pressed attribute except "", or "undefined"
23549:           // indicates a toggle
 4265:           *aRole = nsIAccessibleRole::ROLE_TOGGLE_BUTTON;
 4265:         }
10736:         else if (content->AttrValueIs(kNameSpaceID_None, nsAccessibilityAtoms::aria_haspopup,
 8937:                                       nsAccessibilityAtoms::_true, eCaseMatters)) {
 8937:           // For button with aria-haspopup="true"
 4265:           *aRole = nsIAccessibleRole::ROLE_BUTTONMENU;
 4265:         }
 4265:       }
 4265:     }
 8051:     else if (*aRole == nsIAccessibleRole::ROLE_LISTBOX) {
 8051:       // A listbox inside of a combo box needs a special role because of ATK mapping to menu
13012:       nsCOMPtr<nsIAccessible> possibleCombo;
13012:       GetParent(getter_AddRefs(possibleCombo));
20566:       if (nsAccUtils::Role(possibleCombo) == nsIAccessibleRole::ROLE_COMBOBOX) {
 8051:         *aRole = nsIAccessibleRole::ROLE_COMBOBOX_LIST;
 8051:       }
13012:       else {   // Check to see if combo owns the listbox instead
24822:         possibleCombo = nsRelUtils::
24822:           GetRelatedAccessible(this, nsIAccessibleRelation::RELATION_NODE_CHILD_OF);
20566:         if (nsAccUtils::Role(possibleCombo) == nsIAccessibleRole::ROLE_COMBOBOX)
13012:           *aRole = nsIAccessibleRole::ROLE_COMBOBOX_LIST;
13012:       }
13012:     }
 8051:     else if (*aRole == nsIAccessibleRole::ROLE_OPTION) {
 8051:       nsCOMPtr<nsIAccessible> parent;
 8051:       GetParent(getter_AddRefs(parent));
20566:       if (nsAccUtils::Role(parent) == nsIAccessibleRole::ROLE_COMBOBOX_LIST)
 8051:         *aRole = nsIAccessibleRole::ROLE_COMBOBOX_OPTION;
 8051:     }
 4265: 
29085:     // We are done if the mapped role trumps native semantics
29085:     if (mRoleMapEntry->roleRule == kUseMapRole)
    1:       return NS_OK;
    1:   }
29085: 
29085:   return GetRoleInternal(aRole);
    1: }
    1: 
  401: NS_IMETHODIMP
  401: nsAccessible::GetAttributes(nsIPersistentProperties **aAttributes)
    1: {
13094:   NS_ENSURE_ARG_POINTER(aAttributes);  // In/out param. Created if necessary.
 8937:   
15511:   if (IsDefunct())
15511:     return NS_ERROR_FAILURE;
15511: 
20566:   nsCOMPtr<nsIContent> content = nsCoreUtils::GetRoleContent(mDOMNode);
 8937:   if (!content) {
  665:     return NS_ERROR_FAILURE;
 8937:   }
  665: 
13094:   nsCOMPtr<nsIPersistentProperties> attributes = *aAttributes;
13094:   if (!attributes) {
13094:     // Create only if an array wasn't already passed in
13094:     attributes = do_CreateInstance(NS_PERSISTENTPROPERTIES_CONTRACTID);
    1:     NS_ENSURE_TRUE(attributes, NS_ERROR_OUT_OF_MEMORY);
13094:     NS_ADDREF(*aAttributes = attributes);
13094:   }
 4516:  
  401:   nsresult rv = GetAttributesInternal(attributes);
  401:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsAutoString id;
 6844:   nsAutoString oldValueUnused;
20521:   if (nsCoreUtils::GetID(content, id)) {
13094:     // Expose ID. If an <iframe id> exists override the one on the <body> of the source doc,
13094:     // because the specific instance is what makes the ID useful for scripts
    1:     attributes->SetStringProperty(NS_LITERAL_CSTRING("id"), id, oldValueUnused);
 6844:   }
 6844:   
 8937:   nsAutoString xmlRoles;
 8937:   if (content->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::role, xmlRoles)) {
 8937:     attributes->SetStringProperty(NS_LITERAL_CSTRING("xml-roles"),  xmlRoles, oldValueUnused);          
    1:   }
    1: 
11394:   nsCOMPtr<nsIAccessibleValue> supportsValue = do_QueryInterface(static_cast<nsIAccessible*>(this));
11394:   if (supportsValue) {
11394:     // We support values, so expose the string value as well, via the valuetext object attribute
11394:     // We test for the value interface because we don't want to expose traditional get_accValue()
11394:     // information such as URL's on links and documents, or text in an input
11394:     nsAutoString valuetext;
11394:     GetValue(valuetext);
11394:     attributes->SetStringProperty(NS_LITERAL_CSTRING("valuetext"), valuetext, oldValueUnused);
11394:   }
11394: 
25348:   // Expose checkable object attribute if the accessible has checkable state
25348:   if (nsAccUtils::State(this) & nsIAccessibleStates::STATE_CHECKABLE)
25348:     nsAccUtils::SetAccAttr(attributes, nsAccessibilityAtoms::checkable, NS_LITERAL_STRING("true"));
13012: 
23326:   // Group attributes (level/setsize/posinset)
36879:   PRInt32 level = 0, posInSet = 0, setSize = 0;
36879:   rv = GroupPosition(&level, &setSize, &posInSet);
36879:   if (NS_SUCCEEDED(rv))
36879:     nsAccUtils::SetAccGroupAttrs(attributes, level, setSize, posInSet);
  401: 
25174:   // Expose object attributes from ARIA attributes.
13012:   PRUint32 numAttrs = content->GetAttrCount();
13012:   for (PRUint32 count = 0; count < numAttrs; count ++) {
13012:     const nsAttrName *attr = content->GetAttrNameAt(count);
13012:     if (attr && attr->NamespaceEquals(kNameSpaceID_None)) {
13012:       nsIAtom *attrAtom = attr->Atom();
13012:       const char *attrStr;
13012:       attrAtom->GetUTF8String(&attrStr);
13012:       if (PL_strncmp(attrStr, "aria-", 5)) 
13012:         continue; // Not ARIA
24997:       PRUint8 attrFlags = nsAccUtils::GetAttributeCharacteristics(attrAtom);
25997:       if (attrFlags & ATTR_BYPASSOBJ)
25997:         continue; // No need to handle exposing as obj attribute here
24997:       if ((attrFlags & ATTR_VALTOKEN) &&
24997:           !nsAccUtils::HasDefinedARIAToken(content, attrAtom))
24997:         continue; // only expose token based attributes if they are defined
13012:       nsAutoString value;
13012:       if (content->GetAttr(kNameSpaceID_None, attrAtom, value)) {
13012:         attributes->SetStringProperty(nsDependentCString(attrStr + 5), value, oldValueUnused);
13012:       }
13012:     }
13012:   }
13012: 
25174:   // If there is no aria-live attribute then expose default value of 'live'
25174:   // object attribute used for ARIA role of this accessible.
25174:   if (mRoleMapEntry) {
25174:     nsAutoString live;
25174:     nsAccUtils::GetAccAttr(attributes, nsAccessibilityAtoms::live, live);
25174:     if (live.IsEmpty()) {
32053:       if (nsAccUtils::GetLiveAttrValue(mRoleMapEntry->liveAttRule, live))
25174:         nsAccUtils::SetAccAttr(attributes, nsAccessibilityAtoms::live, live);
25174:     }
25174:   }
25174: 
    1:   return NS_OK;
    1: }
    1: 
  401: nsresult
  401: nsAccessible::GetAttributesInternal(nsIPersistentProperties *aAttributes)
  401: {
13094:   // Attributes set by this method will not be used to override attributes on a sub-document accessible
13094:   // when there is a <frame>/<iframe> element that spawned the sub-document
20566:   nsIContent *content = nsCoreUtils::GetRoleContent(mDOMNode);
13094:   nsCOMPtr<nsIDOMElement> element(do_QueryInterface(content));
  401:   NS_ENSURE_TRUE(element, NS_ERROR_UNEXPECTED);
  401: 
  401:   nsAutoString tagName;
  401:   element->GetTagName(tagName);
  401:   if (!tagName.IsEmpty()) {
  401:     nsAutoString oldValueUnused;
  401:     aAttributes->SetStringProperty(NS_LITERAL_CSTRING("tag"), tagName,
  401:                                    oldValueUnused);
  401:   }
  401: 
37339:   nsEventShell::GetEventAttributes(mDOMNode, aAttributes);
13094:  
13094:   // Expose class because it may have useful microformat information
13094:   // Let the class from an iframe's document be exposed, don't override from <iframe class>
13094:   nsAutoString _class;
13094:   if (content->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::_class, _class))
20536:     nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::_class, _class);
13094: 
13094:   // Get container-foo computed live region properties based on the closest container with
13094:   // the live region attribute. 
13094:   // Inner nodes override outer nodes within the same document --
13094:   //   The inner nodes can be used to override live region behavior on more general outer nodes
13094:   // However, nodes in outer documents override nodes in inner documents:
13094:   //   Outer doc author may want to override properties on a widget they used in an iframe
13094:   nsCOMPtr<nsIDOMNode> startNode = mDOMNode;
13094:   nsIContent *startContent = content;
13094:   while (PR_TRUE) {
13094:     NS_ENSURE_STATE(startContent);
13094:     nsIDocument *doc = startContent->GetDocument();
13094:     nsCOMPtr<nsIDOMNode> docNode = do_QueryInterface(doc);
13094:     NS_ENSURE_STATE(docNode);
20566:     nsIContent *topContent = nsCoreUtils::GetRoleContent(docNode);
13094:     NS_ENSURE_STATE(topContent);
20536:     nsAccUtils::SetLiveContainerAttributes(aAttributes, startContent,
20521:                                            topContent);
21169: 
13094:     // Allow ARIA live region markup from outer documents to override
13094:     nsCOMPtr<nsISupports> container = doc->GetContainer(); 
21169:     nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem =
21169:       do_QueryInterface(container);
13351:     if (!docShellTreeItem)
13351:       break;
21169: 
21169:     nsCOMPtr<nsIDocShellTreeItem> sameTypeParent;
21169:     docShellTreeItem->GetSameTypeParent(getter_AddRefs(sameTypeParent));
13094:     if (!sameTypeParent || sameTypeParent == docShellTreeItem)
13094:       break;
21169: 
13094:     nsIDocument *parentDoc = doc->GetParentDocument();
13408:     if (!parentDoc)
13408:       break;
21169: 
13094:     startContent = parentDoc->FindContentForSubDocument(doc);      
13094:   }
13094: 
15645:   // Expose 'display' attribute.
21002:   nsAutoString value;
15645:   nsresult rv = GetComputedStyleValue(EmptyString(),
15645:                                       NS_LITERAL_STRING("display"),
21002:                                       value);
15645:   if (NS_SUCCEEDED(rv))
20536:     nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::display,
21002:                            value);
21002: 
21002:   // Expose 'text-align' attribute.
21002:   rv = GetComputedStyleValue(EmptyString(), NS_LITERAL_STRING("text-align"),
21002:                              value);
21002:   if (NS_SUCCEEDED(rv))
21002:     nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::textAlign,
21002:                            value);
21002: 
21002:   // Expose 'text-indent' attribute.
21002:   rv = GetComputedStyleValue(EmptyString(), NS_LITERAL_STRING("text-indent"),
21002:                              value);
21002:   if (NS_SUCCEEDED(rv))
21002:     nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::textIndent,
21002:                            value);
21002: 
29397:   // Expose draggable object attribute?
29397:   nsCOMPtr<nsIDOMNSHTMLElement> htmlElement = do_QueryInterface(content);
29397:   if (htmlElement) {
29397:     PRBool draggable = PR_FALSE;
29397:     htmlElement->GetDraggable(&draggable);
29397:     if (draggable) {
29397:       nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::draggable,
29397:                              NS_LITERAL_STRING("true"));
29397:     }
29397:   }
29397: 
  401:   return NS_OK;
  401: }
  401: 
  144: NS_IMETHODIMP
  144: nsAccessible::GroupPosition(PRInt32 *aGroupLevel,
  144:                             PRInt32 *aSimilarItemsInGroup,
  144:                             PRInt32 *aPositionInGroup)
  144: {
  144:   NS_ENSURE_ARG_POINTER(aGroupLevel);
36879:   *aGroupLevel = 0;
36879: 
  144:   NS_ENSURE_ARG_POINTER(aSimilarItemsInGroup);
36879:   *aSimilarItemsInGroup = 0;
36879: 
  144:   NS_ENSURE_ARG_POINTER(aPositionInGroup);
  144:   *aPositionInGroup = 0;
  144: 
36879:   if (IsDefunct())
  757:     return NS_ERROR_FAILURE;
36879: 
36879:   // Get group position from ARIA attributes.
36879:   nsCOMPtr<nsIContent> content = nsCoreUtils::GetRoleContent(mDOMNode);
36879:   if (!content)
  144:     return NS_OK;
  144: 
37109:   nsCoreUtils::GetUIntAttr(content, nsAccessibilityAtoms::aria_level,
37109:                            aGroupLevel);
37109:   nsCoreUtils::GetUIntAttr(content, nsAccessibilityAtoms::aria_posinset,
37109:                            aPositionInGroup);
37109:   nsCoreUtils::GetUIntAttr(content, nsAccessibilityAtoms::aria_setsize,
37109:                            aSimilarItemsInGroup);
36879: 
36879:   // If ARIA is missed and the accessible is visible then calculate group
36879:   // position from hierarchy.
36879:   if (nsAccUtils::State(this) & nsIAccessibleStates::STATE_INVISIBLE)
36879:     return NS_OK;
36879: 
36879:   // Calculate group level if ARIA is missed.
36879:   if (*aGroupLevel == 0) {
36879:     PRInt32 level = GetLevelInternal();
36879:     if (level != 0)
36879:       *aGroupLevel = level;
36879:   }
36879: 
36879:   // Calculate position in group and group size if ARIA is missed.
36879:   if (*aSimilarItemsInGroup == 0 || *aPositionInGroup == 0) {
36879:     PRInt32 posInSet = 0, setSize = 0;
36879:     GetPositionAndSizeInternal(&posInSet, &setSize);
36879:     if (posInSet != 0 && setSize != 0) {
36879:       if (*aPositionInGroup == 0)
36879:         *aPositionInGroup = posInSet;
36879: 
36879:       if (*aSimilarItemsInGroup == 0)
 7888:         *aSimilarItemsInGroup = setSize;
36879:     }
36879:   }
  144: 
  144:   return NS_OK;
  144: }
  144: 
  262: NS_IMETHODIMP
21256: nsAccessible::GetState(PRUint32 *aState, PRUint32 *aExtraState)
    1: {
  262:   NS_ENSURE_ARG_POINTER(aState);
  262: 
29442:   if (!IsDefunct()) {
29442:     // Flush layout so that all the frame construction, reflow, and styles are
29442:     // up-to-date since we rely on frames, and styles when calculating state.
29442:     // We don't flush the display because we don't care about painting.
29442:     nsCOMPtr<nsIPresShell> presShell = GetPresShell();
29442:     presShell->FlushPendingNotifications(Flush_Layout);
29442:   }
29442: 
21256:   nsresult rv = GetStateInternal(aState, aExtraState);
21984:   NS_ENSURE_A11Y_SUCCESS(rv, rv);
  262: 
 4381:   // Apply ARIA states to be sure accessible states will be overriden.
29565:   GetARIAState(aState, aExtraState);
 4381: 
 6596:   if (mRoleMapEntry && mRoleMapEntry->role == nsIAccessibleRole::ROLE_PAGETAB) {
 6596:     if (*aState & nsIAccessibleStates::STATE_FOCUSED) {
 6596:       *aState |= nsIAccessibleStates::STATE_SELECTED;
 6596:     } else {
 6596:       // Expose 'selected' state on ARIA tab if the focus is on internal element
 6596:       // of related tabpanel.
24822:       nsCOMPtr<nsIAccessible> tabPanel = nsRelUtils::
24822:         GetRelatedAccessible(this, nsIAccessibleRelation::RELATION_LABEL_FOR);
 6596: 
20566:       if (nsAccUtils::Role(tabPanel) == nsIAccessibleRole::ROLE_PROPERTYPAGE) {
 6596:         nsCOMPtr<nsIAccessNode> tabPanelAccessNode(do_QueryInterface(tabPanel));
37539:         nsCOMPtr<nsIDOMNode> tabPanelDOMNode;
37539:         tabPanelAccessNode->GetDOMNode(getter_AddRefs(tabPanelDOMNode));
37539:         NS_ENSURE_STATE(tabPanelDOMNode);
37539: 
37539:         nsCOMPtr<nsINode> tabPanelNode(do_QueryInterface(tabPanelDOMNode));
37539:         nsCOMPtr<nsINode> lastFocusedNode(do_QueryInterface(gLastFocusedNode));
37539:         if (nsCoreUtils::IsAncestorOf(tabPanelNode, lastFocusedNode))
 6596:           *aState |= nsIAccessibleStates::STATE_SELECTED;
 6596:       }
 6596:     }
 6596:   }
 6596: 
20128:   const PRUint32 kExpandCollapseStates =
20128:     nsIAccessibleStates::STATE_COLLAPSED | nsIAccessibleStates::STATE_EXPANDED;
20128:   if ((*aState & kExpandCollapseStates) == kExpandCollapseStates) {
20128:     // Cannot be both expanded and collapsed -- this happens in ARIA expanded
20128:     // combobox because of limitation of nsARIAMap.
20128:     // XXX: Perhaps we will be able to make this less hacky if we support
20128:     // extended states in nsARIAMap, e.g. derive COLLAPSED from
20128:     // EXPANDABLE && !EXPANDED.
20128:     *aState &= ~nsIAccessibleStates::STATE_COLLAPSED;
20128:   }
20128: 
 3465:   // Set additional states which presence depends on another states.
 6172:   if (!aExtraState)
 6172:     return NS_OK;
 6172: 
 3465:   if (!(*aState & nsIAccessibleStates::STATE_UNAVAILABLE)) {
 3465:     *aExtraState |= nsIAccessibleStates::EXT_STATE_ENABLED |
 3465:                     nsIAccessibleStates::EXT_STATE_SENSITIVE;
 3465:   }
 3465: 
20128:   if ((*aState & nsIAccessibleStates::STATE_COLLAPSED) ||
20128:       (*aState & nsIAccessibleStates::STATE_EXPANDED))
 3465:     *aExtraState |= nsIAccessibleStates::EXT_STATE_EXPANDABLE;
 6172: 
 8862:   if (mRoleMapEntry) {
 8862:     // If an object has an ancestor with the activedescendant property
 8862:     // pointing at it, we mark it as ACTIVE even if it's not currently focused.
 8862:     // This allows screen reader virtual buffer modes to know which descendant
 8862:     // is the current one that would get focus if the user navigates to the container widget.
 8862:     nsCOMPtr<nsIContent> content = do_QueryInterface(mDOMNode);
 8862:     nsAutoString id;
20521:     if (content && nsCoreUtils::GetID(content, id)) {
 8862:       nsIContent *ancestorContent = content;
 8862:       nsAutoString activeID;
 8862:       while ((ancestorContent = ancestorContent->GetParent()) != nsnull) {
 8862:         if (ancestorContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_activedescendant, activeID)) {
 8862:           if (id == activeID) {
 8862:             *aExtraState |= nsIAccessibleStates::EXT_STATE_ACTIVE;
 8862:           }
 8862:           break;
 8862:         }
 8862:       }
 8862:     }
 8862:   }
 8862: 
 6172:   PRUint32 role;
25822:   rv = GetRole(&role);
 6172:   NS_ENSURE_SUCCESS(rv, rv);
 6172: 
 6172:   // For some reasons DOM node may have not a frame. We tract such accessibles
 6172:   // as invisible.
 5424:   nsIFrame *frame = GetFrame();
 6172:   if (!frame)
 6172:     return NS_OK;
 6172: 
 5424:   const nsStyleDisplay* display = frame->GetStyleDisplay();
 5424:   if (display && display->mOpacity == 1.0f &&
 5424:       !(*aState & nsIAccessibleStates::STATE_INVISIBLE)) {
 5424:     *aExtraState |= nsIAccessibleStates::EXT_STATE_OPAQUE;
 5424:   }
 5424: 
 5424:   const nsStyleXUL *xulStyle = frame->GetStyleXUL();
 5424:   if (xulStyle) {
 5424:     // In XUL all boxes are either vertical or horizontal
 5424:     if (xulStyle->mBoxOrient == NS_STYLE_BOX_ORIENT_VERTICAL) {
 5424:       *aExtraState |= nsIAccessibleStates::EXT_STATE_VERTICAL;
 5424:     }
 5424:     else {
 5424:       *aExtraState |= nsIAccessibleStates::EXT_STATE_HORIZONTAL;
 5424:     }
 5424:   }
 3465:   
25066:   // If we are editable, force readonly bit off
25066:   if (*aExtraState & nsIAccessibleStates::EXT_STATE_EDITABLE)
25066:     *aState &= ~nsIAccessibleStates::STATE_READONLY;
25066:  
 4381:   return NS_OK;
  262: }
  262: 
13094: nsresult
29565: nsAccessible::GetARIAState(PRUint32 *aState, PRUint32 *aExtraState)
  262: {
    1:   // Test for universal states first
20566:   nsIContent *content = nsCoreUtils::GetRoleContent(mDOMNode);
 5448:   if (!content) {
13094:     return NS_OK;
 5448:   }
 5448: 
 2136:   PRUint32 index = 0;
29565:   while (nsStateMapEntry::MapToStates(content, aState, aExtraState,
29565:                                       nsARIAMap::gWAIUnivStateMap[index])) {
 2136:     ++ index;
  262:   }
  262: 
15374:   if (mRoleMapEntry) {
32104: 
32104:     // We only force the readonly bit off if we have a real mapping for the aria
32104:     // role. This preserves the ability for screen readers to use readonly
32104:     // (primarily on the document) as the hint for creating a virtual buffer.
32104:     if (mRoleMapEntry->role != nsIAccessibleRole::ROLE_NOTHING)
13715:       *aState &= ~nsIAccessibleStates::STATE_READONLY;
13715: 
13716:     if (content->HasAttr(kNameSpaceID_None, content->GetIDAttributeName())) {
13716:       // If has a role & ID and aria-activedescendant on the container, assume focusable
13716:       nsIContent *ancestorContent = content;
13716:       while ((ancestorContent = ancestorContent->GetParent()) != nsnull) {
13716:         if (ancestorContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_activedescendant)) {
13716:             // ancestor has activedescendant property, this content could be active
13716:           *aState |= nsIAccessibleStates::STATE_FOCUSABLE;
13716:           break;
13716:         }
13716:       }
13716:     }
15374:   }
15374: 
15374:   if (*aState & nsIAccessibleStates::STATE_FOCUSABLE) {
15374:     // Special case: aria-disabled propagates from ancestors down to any focusable descendant
15374:     nsIContent *ancestorContent = content;
15374:     while ((ancestorContent = ancestorContent->GetParent()) != nsnull) {
15374:       if (ancestorContent->AttrValueIs(kNameSpaceID_None, nsAccessibilityAtoms::aria_disabled,
15374:                                        nsAccessibilityAtoms::_true, eCaseMatters)) {
15374:           // ancestor has aria-disabled property, this is disabled
15374:         *aState |= nsIAccessibleStates::STATE_UNAVAILABLE;
15374:         break;
15374:       }
15374:     }    
15374:   }
15374: 
15374:   if (!mRoleMapEntry)
15374:     return NS_OK;
13716: 
25066:   // Note: the readonly bitflag will be overridden later if content is editable
13715:   *aState |= mRoleMapEntry->state;
29565:   if (nsStateMapEntry::MapToStates(content, aState, aExtraState,
29565:                                    mRoleMapEntry->attributeMap1) &&
29565:       nsStateMapEntry::MapToStates(content, aState, aExtraState,
29565:                                    mRoleMapEntry->attributeMap2)) {
29565:     nsStateMapEntry::MapToStates(content, aState, aExtraState,
29565:                                  mRoleMapEntry->attributeMap3);
13094:   }
13094: 
13094:   return NS_OK;
    1: }
    1: 
    1: // Not implemented by this class
    1: 
    1: /* DOMString getValue (); */
13757: NS_IMETHODIMP
13757: nsAccessible::GetValue(nsAString& aValue)
    1: {
13757:   if (IsDefunct())
13757:     return NS_ERROR_FAILURE;
13757: 
13757:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
13775:   if (!content)
13775:     return NS_OK;
13757: 
    1:   if (mRoleMapEntry) {
    1:     if (mRoleMapEntry->valueRule == eNoValue) {
    1:       return NS_OK;
    1:     }
13757: 
11394:     // aria-valuenow is a number, and aria-valuetext is the optional text equivalent
11394:     // For the string value, we will try the optional text equivalent first
11394:     if (!content->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_valuetext, aValue)) {
11394:       content->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_valuenow, aValue);
    1:     }
    1:   }
13757: 
13757:   if (!aValue.IsEmpty())
13757:     return NS_OK;
13757: 
20072:   // Check if it's a simple xlink.
20521:   if (nsCoreUtils::IsXLink(content)) {
13757:     nsCOMPtr<nsIPresShell> presShell(do_QueryReferent(mWeakShell));
13757:     if (presShell)
13757:       return presShell->GetLinkLocation(mDOMNode, aValue);
13757:   }
13757: 
    1:   return NS_OK;
    1: }
    1: 
 4274: // nsIAccessibleValue
 4274: NS_IMETHODIMP
 4274: nsAccessible::GetMaximumValue(double *aMaximumValue)
    1: {
 8937:   return GetAttrValue(nsAccessibilityAtoms::aria_valuemax, aMaximumValue);
 4274: }
 4274: 
 4274: NS_IMETHODIMP
 4274: nsAccessible::GetMinimumValue(double *aMinimumValue)
 4274: {
 8937:   return GetAttrValue(nsAccessibilityAtoms::aria_valuemin, aMinimumValue);
 4274: }
 4274: 
 4274: NS_IMETHODIMP
 4274: nsAccessible::GetMinimumIncrement(double *aMinIncrement)
 4274: {
 4274:   NS_ENSURE_ARG_POINTER(aMinIncrement);
 4274:   *aMinIncrement = 0;
 4274: 
 4274:   // No mimimum increment in dynamic content spec right now
 4274:   return NS_OK_NO_ARIA_VALUE;
 4274: }
 4274: 
 4274: NS_IMETHODIMP
 4274: nsAccessible::GetCurrentValue(double *aValue)
 4274: {
 8937:   return GetAttrValue(nsAccessibilityAtoms::aria_valuenow, aValue);
 4274: }
 4274: 
 4274: NS_IMETHODIMP
 4274: nsAccessible::SetCurrentValue(double aValue)
 4274: {
 4274:   if (!mDOMNode)
 4039:     return NS_ERROR_FAILURE;  // Node already shut down
 4274: 
 4274:   if (!mRoleMapEntry || mRoleMapEntry->valueRule == eNoValue)
 4274:     return NS_OK_NO_ARIA_VALUE;
 4274: 
    1:   const PRUint32 kValueCannotChange = nsIAccessibleStates::STATE_READONLY |
    1:                                       nsIAccessibleStates::STATE_UNAVAILABLE;
    1: 
20566:   if (nsAccUtils::State(this) & kValueCannotChange)
    1:     return NS_ERROR_FAILURE;
 4274: 
 4274:   double minValue = 0;
 4274:   if (NS_SUCCEEDED(GetMinimumValue(&minValue)) && aValue < minValue)
    1:     return NS_ERROR_INVALID_ARG;
 4274: 
 4274:   double maxValue = 0;
 4274:   if (NS_SUCCEEDED(GetMaximumValue(&maxValue)) && aValue > maxValue)
    1:     return NS_ERROR_INVALID_ARG;
 4274: 
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
 4274:   NS_ENSURE_STATE(content);
 4274: 
    1:   nsAutoString newValue;
    1:   newValue.AppendFloat(aValue);
 6279:   return content->SetAttr(kNameSpaceID_None,
 6279:                           nsAccessibilityAtoms::aria_valuenow, newValue, PR_TRUE);
 6279: }
    1: 
    1: /* void setName (in DOMString name); */
    1: NS_IMETHODIMP nsAccessible::SetName(const nsAString& name)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAccessible::GetDefaultKeyBinding(nsAString& aKeyBinding)
    1: {
    1:   aKeyBinding.Truncate();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAccessible::GetKeyBindings(PRUint8 aActionIndex,
    1:                              nsIDOMDOMStringList **aKeyBindings)
    1: {
    1:   // Currently we support only unique key binding on element for default action.
    1:   NS_ENSURE_TRUE(aActionIndex == 0, NS_ERROR_INVALID_ARG);
    1: 
    1:   nsAccessibleDOMStringList *keyBindings = new nsAccessibleDOMStringList();
    1:   NS_ENSURE_TRUE(keyBindings, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   nsAutoString defaultKey;
    1:   nsresult rv = GetDefaultKeyBinding(defaultKey);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!defaultKey.IsEmpty())
    1:     keyBindings->Add(defaultKey);
    1: 
    1:   NS_ADDREF(*aKeyBindings = keyBindings);
    1:   return NS_OK;
    1: }
    1: 
    1: /* unsigned long getRole (); */
25822: nsresult
25822: nsAccessible::GetRoleInternal(PRUint32 *aRole)
    1: {
    1:   *aRole = nsIAccessibleRole::ROLE_NOTHING;
13757: 
13757:   if (IsDefunct())
13757:     return NS_ERROR_FAILURE;
13757: 
13757:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
20521:   if (nsCoreUtils::IsXLink(content))
13757:     *aRole = nsIAccessibleRole::ROLE_LINK;
13757: 
    1:   return NS_OK;
    1: }
    1: 
20140: // readonly attribute PRUint8 numActions
13129: NS_IMETHODIMP
13129: nsAccessible::GetNumActions(PRUint8 *aNumActions)
    1: {
13129:   NS_ENSURE_ARG_POINTER(aNumActions);
    1:   *aNumActions = 0;
13129: 
13129:   if (IsDefunct())
13129:     return NS_ERROR_FAILURE;
13129: 
20566:   PRUint32 actionRule = GetActionRule(nsAccUtils::State(this));
20140:   if (actionRule == eNoAction)
15309:     return NS_OK;
15309: 
13757:   *aNumActions = 1;
13757:   return NS_OK;
13757: }
13757: 
    1: /* DOMString getAccActionName (in PRUint8 index); */
13129: NS_IMETHODIMP
13129: nsAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
    1: {
13129:   aName.Truncate();
13129: 
13129:   if (aIndex != 0)
13129:     return NS_ERROR_INVALID_ARG;
13129: 
13129:   if (IsDefunct())
    1:     return NS_ERROR_FAILURE;
13129: 
20566:   PRUint32 states = nsAccUtils::State(this);
20140:   PRUint32 actionRule = GetActionRule(states);
20140: 
20140:  switch (actionRule) {
20140:    case eActivateAction:
20140:      aName.AssignLiteral("activate");
20140:      return NS_OK;
20140: 
20140:    case eClickAction:
20140:      aName.AssignLiteral("click");
20140:      return NS_OK;
20140: 
20140:    case eCheckUncheckAction:
25968:      if (states & nsIAccessibleStates::STATE_CHECKED)
25968:        aName.AssignLiteral("uncheck");
25968:      else if (states & nsIAccessibleStates::STATE_MIXED)
25871:        aName.AssignLiteral("cycle");
20140:      else
20140:        aName.AssignLiteral("check");
20140:      return NS_OK;
20140: 
20140:    case eJumpAction:
13757:      aName.AssignLiteral("jump");
13757:      return NS_OK;
20140: 
20140:    case eOpenCloseAction:
20140:      if (states & nsIAccessibleStates::STATE_COLLAPSED)
20140:        aName.AssignLiteral("open");
20140:      else
20140:        aName.AssignLiteral("close");
13129:      return NS_OK;
20140: 
20140:    case eSelectAction:
20140:      aName.AssignLiteral("select");
20140:      return NS_OK;
20140: 
20140:    case eSwitchAction:
20140:      aName.AssignLiteral("switch");
20140:      return NS_OK;
27511:      
27511:    case eSortAction:
27511:      aName.AssignLiteral("sort");
27511:      return NS_OK;
27511:    
27511:    case eExpandAction:
27511:      if (states & nsIAccessibleStates::STATE_COLLAPSED)
27511:        aName.AssignLiteral("expand");
27511:      else
27511:        aName.AssignLiteral("collapse");
27511:      return NS_OK;
13129:   }
13129: 
13129:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
20140: // AString getActionDescription(in PRUint8 index)
13129: NS_IMETHODIMP
13129: nsAccessible::GetActionDescription(PRUint8 aIndex, nsAString& aDescription)
    1: {
    1:   // default to localized action name.
    1:   nsAutoString name;
    1:   nsresult rv = GetActionName(aIndex, name);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return GetTranslatedString(name, aDescription);
    1: }
    1: 
20140: // void doAction(in PRUint8 index)
13129: NS_IMETHODIMP
13129: nsAccessible::DoAction(PRUint8 aIndex)
    1: {
13129:   if (aIndex != 0)
13129:     return NS_ERROR_INVALID_ARG;
13129: 
13129:   if (IsDefunct())
    1:     return NS_ERROR_FAILURE;
13129: 
20566:   if (GetActionRule(nsAccUtils::State(this)) != eNoAction) {
37481:     DoCommand();
37481:     return NS_OK;
20140:   }
13129: 
13129:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
    1: /* DOMString getHelp (); */
    1: NS_IMETHODIMP nsAccessible::GetHelp(nsAString& _retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* nsIAccessible getAccessibleToRight(); */
    1: NS_IMETHODIMP nsAccessible::GetAccessibleToRight(nsIAccessible **_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* nsIAccessible getAccessibleToLeft(); */
    1: NS_IMETHODIMP nsAccessible::GetAccessibleToLeft(nsIAccessible **_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* nsIAccessible getAccessibleAbove(); */
    1: NS_IMETHODIMP nsAccessible::GetAccessibleAbove(nsIAccessible **_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* nsIAccessible getAccessibleBelow(); */
    1: NS_IMETHODIMP nsAccessible::GetAccessibleBelow(nsIAccessible **_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
 6066: nsIDOMNode* nsAccessible::GetAtomicRegion()
 6066: {
20566:   nsCOMPtr<nsIContent> content = nsCoreUtils::GetRoleContent(mDOMNode);
 6066:   nsIContent *loopContent = content;
 6066:   nsAutoString atomic;
 8937:   while (loopContent && !loopContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_atomic, atomic)) {
 6066:     loopContent = loopContent->GetParent();
 6066:   }
 6066: 
 6066:   nsCOMPtr<nsIDOMNode> atomicRegion;
 6066:   if (atomic.EqualsLiteral("true")) {
 6066:     atomicRegion = do_QueryInterface(loopContent);
 6066:   }
 6066:   return atomicRegion;
 6066: }
    1: 
24822: // nsIAccessible getRelationByType()
24822: NS_IMETHODIMP
24822: nsAccessible::GetRelationByType(PRUint32 aRelationType,
24822:                                 nsIAccessibleRelation **aRelation)
    1: {
24822:   NS_ENSURE_ARG_POINTER(aRelation);
24822:   *aRelation = nsnull;
24822: 
24822:   if (IsDefunct())
24822:     return NS_ERROR_FAILURE;
24822: 
24822:   // Relationships are defined on the same content node that the role would be
24822:   // defined on.
20566:   nsIContent *content = nsCoreUtils::GetRoleContent(mDOMNode);
24822:   if (!content)
24822:     return NS_OK;
24822: 
24822:   nsresult rv;
24822: 
    1:   switch (aRelationType)
    1:   {
 1628:   case nsIAccessibleRelation::RELATION_LABEL_FOR:
    1:     {
    1:       if (content->Tag() == nsAccessibilityAtoms::label) {
33329:         nsIAtom *IDAttr = content->IsHTML() ?
    1:           nsAccessibilityAtoms::_for : nsAccessibilityAtoms::control;
24822:         rv = nsRelUtils::
24822:           AddTargetFromIDRefAttr(aRelationType, aRelation, content, IDAttr);
24822:         NS_ENSURE_SUCCESS(rv, rv);
24822: 
24822:         if (rv != NS_OK_NO_RELATION_TARGET)
24822:           return NS_OK; // XXX bug 381599, avoid performance problems
24822:       }
24822: 
24822:       return nsRelUtils::
24822:         AddTargetFromNeighbour(aRelationType, aRelation, content,
24822:                                nsAccessibilityAtoms::aria_labelledby);
24822:     }
24822: 
 1628:   case nsIAccessibleRelation::RELATION_LABELLED_BY:
    1:     {
24822:       rv = nsRelUtils::
24822:         AddTargetFromIDRefsAttr(aRelationType, aRelation, content,
24822:                                 nsAccessibilityAtoms::aria_labelledby);
24822:       NS_ENSURE_SUCCESS(rv, rv);
24822: 
24822:       if (rv != NS_OK_NO_RELATION_TARGET)
24822:         return NS_OK; // XXX bug 381599, avoid performance problems
24822: 
24822:       return nsRelUtils::
24822:         AddTargetFromContent(aRelationType, aRelation,
24822:                              nsCoreUtils::GetLabelContent(content));
24822:     }
24822: 
 1628:   case nsIAccessibleRelation::RELATION_DESCRIBED_BY:
    1:     {
24822:       rv = nsRelUtils::
24822:         AddTargetFromIDRefsAttr(aRelationType, aRelation, content,
24822:                                 nsAccessibilityAtoms::aria_describedby);
24822:       NS_ENSURE_SUCCESS(rv, rv);
24822: 
24822:       if (rv != NS_OK_NO_RELATION_TARGET)
24822:         return NS_OK; // XXX bug 381599, avoid performance problems
24822: 
24822:       return nsRelUtils::
24822:         AddTargetFromNeighbour(aRelationType, aRelation, content,
24822:                                nsAccessibilityAtoms::control,
24822:                                nsAccessibilityAtoms::description);
24822:     }
24822: 
 1628:   case nsIAccessibleRelation::RELATION_DESCRIPTION_FOR:
    1:     {
24822:       rv = nsRelUtils::
24822:         AddTargetFromNeighbour(aRelationType, aRelation, content,
24822:                                nsAccessibilityAtoms::aria_describedby);
24822:       NS_ENSURE_SUCCESS(rv, rv);
24822: 
24822:       if (rv != NS_OK_NO_RELATION_TARGET)
24822:         return NS_OK; // XXX bug 381599, avoid performance problems
24822: 
24822:       if (content->Tag() == nsAccessibilityAtoms::description &&
33329:           content->IsXUL()) {
    1:         // This affectively adds an optional control attribute to xul:description,
    1:         // which only affects accessibility, by allowing the description to be
    1:         // tied to a control.
24822:         return nsRelUtils::
24822:           AddTargetFromIDRefAttr(aRelationType, aRelation, content,
24822:                                  nsAccessibilityAtoms::control);
24822:       }
24822: 
24822:       return NS_OK;
24822:     }
24822: 
 1628:   case nsIAccessibleRelation::RELATION_NODE_CHILD_OF:
    1:     {
24822:       rv = nsRelUtils::
24822:         AddTargetFromNeighbour(aRelationType, aRelation, content,
24822:                                nsAccessibilityAtoms::aria_owns);
24822:       NS_ENSURE_SUCCESS(rv, rv);
24822: 
24822:       if (rv != NS_OK_NO_RELATION_TARGET)
24822:         return NS_OK; // XXX bug 381599, avoid performance problems
24822: 
34028:       // This is an ARIA tree or treegrid that doesn't use owns, so we need to
34028:       // get the parent the hard way.
24822:       if (mRoleMapEntry &&
34028:           (mRoleMapEntry->role == nsIAccessibleRole::ROLE_OUTLINEITEM ||
34028:            mRoleMapEntry->role == nsIAccessibleRole::ROLE_ROW)) {
34028: 
24822:         nsCOMPtr<nsIAccessible> accTarget;
24822:         nsAccUtils::GetARIATreeItemParent(this, content,
24822:                                           getter_AddRefs(accTarget));
34028: 
24822:         return nsRelUtils::AddTarget(aRelationType, aRelation, accTarget);
24822:       }
24822: 
30527:       // If accessible is in its own Window, or is the root of a document,
30527:       // then we should provide NODE_CHILD_OF relation so that MSAA clients
30527:       // can easily get to true parent instead of getting to oleacc's
30527:       // ROLE_WINDOW accessible which will prevent us from going up further
30527:       // (because it is system generated and has no idea about the hierarchy
30527:       // above it).
12642:       nsIFrame *frame = GetFrame();
12642:       if (frame) {
12642:         nsIView *view = frame->GetViewExternal();
12642:         if (view) {
23554:           nsIScrollableFrame *scrollFrame = do_QueryFrame(frame);
30527:           if (scrollFrame || view->GetWidget() || !frame->GetParent()) {
36989:             return nsRelUtils::AddTarget(aRelationType, aRelation, GetParent());
24822:           }
24822:         }
24822:       }
24822: 
24822:       return NS_OK;
24822:     }
24822: 
 1628:   case nsIAccessibleRelation::RELATION_CONTROLLED_BY:
    1:     {
24822:       return nsRelUtils::
24822:         AddTargetFromNeighbour(aRelationType, aRelation, content,
24822:                                nsAccessibilityAtoms::aria_controls);
24822:     }
24822: 
 1628:   case nsIAccessibleRelation::RELATION_CONTROLLER_FOR:
    1:     {
24822:       return nsRelUtils::
24822:         AddTargetFromIDRefsAttr(aRelationType, aRelation, content,
24822:                                 nsAccessibilityAtoms::aria_controls);
24822:     }
24822: 
 1628:   case nsIAccessibleRelation::RELATION_FLOWS_TO:
    1:     {
24822:       return nsRelUtils::
24822:         AddTargetFromIDRefsAttr(aRelationType, aRelation, content,
24822:                                 nsAccessibilityAtoms::aria_flowto);
24822:     }
24822: 
 1628:   case nsIAccessibleRelation::RELATION_FLOWS_FROM:
    1:     {
24822:       return nsRelUtils::
24822:         AddTargetFromNeighbour(aRelationType, aRelation, content,
24822:                                nsAccessibilityAtoms::aria_flowto);
24822:     }
24822: 
 1628:   case nsIAccessibleRelation::RELATION_DEFAULT_BUTTON:
    1:     {
33329:       if (content->IsHTML()) {
 4451:         // HTML form controls implements nsIFormControl interface.
 4451:         nsCOMPtr<nsIFormControl> control(do_QueryInterface(content));
 4451:         if (control) {
 4451:           nsCOMPtr<nsIDOMHTMLFormElement> htmlform;
 4451:           control->GetForm(getter_AddRefs(htmlform));
 4451:           nsCOMPtr<nsIForm> form(do_QueryInterface(htmlform));
24822:           if (form) {
24822:             nsCOMPtr<nsIContent> formContent =
24822:               do_QueryInterface(form->GetDefaultSubmitElement());
24822:             return nsRelUtils::AddTargetFromContent(aRelationType, aRelation,
24822:                                                     formContent);
24822:           }
    1:         }
    1:       }
    1:       else {
    1:         // In XUL, use first <button default="true" .../> in the document
    1:         nsCOMPtr<nsIDOMXULDocument> xulDoc = do_QueryInterface(content->GetDocument());
    1:         nsCOMPtr<nsIDOMXULButtonElement> buttonEl;
    1:         if (xulDoc) {
    1:           nsCOMPtr<nsIDOMNodeList> possibleDefaultButtons;
    1:           xulDoc->GetElementsByAttribute(NS_LITERAL_STRING("default"),
    1:                                          NS_LITERAL_STRING("true"),
    1:                                          getter_AddRefs(possibleDefaultButtons));
    1:           if (possibleDefaultButtons) {
    1:             PRUint32 length;
    1:             possibleDefaultButtons->GetLength(&length);
    1:             nsCOMPtr<nsIDOMNode> possibleButton;
    1:             // Check for button in list of default="true" elements
    1:             for (PRUint32 count = 0; count < length && !buttonEl; count ++) {
    1:               possibleDefaultButtons->Item(count, getter_AddRefs(possibleButton));
    1:               buttonEl = do_QueryInterface(possibleButton);
    1:             }
    1:           }
    1:           if (!buttonEl) { // Check for anonymous accept button in <dialog>
    1:             nsCOMPtr<nsIDOMDocumentXBL> xblDoc(do_QueryInterface(xulDoc));
    1:             if (xblDoc) {
    1:               nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(xulDoc);
    1:               NS_ASSERTION(domDoc, "No DOM document");
    1:               nsCOMPtr<nsIDOMElement> rootEl;
    1:               domDoc->GetDocumentElement(getter_AddRefs(rootEl));
    1:               if (rootEl) {
    1:                 nsCOMPtr<nsIDOMElement> possibleButtonEl;
    1:                 xblDoc->GetAnonymousElementByAttribute(rootEl,
    1:                                                       NS_LITERAL_STRING("default"),
    1:                                                       NS_LITERAL_STRING("true"),
    1:                                                       getter_AddRefs(possibleButtonEl));
    1:                 buttonEl = do_QueryInterface(possibleButtonEl);
    1:               }
    1:             }
    1:           }
24822:           nsCOMPtr<nsIContent> relatedContent(do_QueryInterface(buttonEl));
24822:           return nsRelUtils::AddTargetFromContent(aRelationType, aRelation,
24822:                                                   relatedContent);
24822:         }
24822:       }
24822:       return NS_OK;
24822:     }
24822: 
 4516:   case nsIAccessibleRelation::RELATION_MEMBER_OF:
 4516:     {
24822:       nsCOMPtr<nsIContent> regionContent = do_QueryInterface(GetAtomicRegion());
24822:       return nsRelUtils::
24822:         AddTargetFromContent(aRelationType, aRelation, regionContent);
24822:     }
24822: 
28489:   case nsIAccessibleRelation::RELATION_SUBWINDOW_OF:
28489:   case nsIAccessibleRelation::RELATION_EMBEDS:
28489:   case nsIAccessibleRelation::RELATION_EMBEDDED_BY:
28489:   case nsIAccessibleRelation::RELATION_POPUP_FOR:
28489:   case nsIAccessibleRelation::RELATION_PARENT_WINDOW_OF:
28489:     {
28489:       return NS_OK_NO_RELATION_TARGET;
28489:     }
28489: 
    1:   default:
24822:     return NS_ERROR_INVALID_ARG;
24822:   }
    1: }
    1: 
 1628: NS_IMETHODIMP
 1628: nsAccessible::GetRelationsCount(PRUint32 *aCount)
 1628: {
 1628:   NS_ENSURE_ARG_POINTER(aCount);
 1628:   *aCount = 0;
 1628: 
 1628:   nsCOMPtr<nsIArray> relations;
 1628:   nsresult rv = GetRelations(getter_AddRefs(relations));
 1628:   NS_ENSURE_SUCCESS(rv, rv);
 1628: 
 1628:   return relations->GetLength(aCount);
 1628: }
 1628: 
 1628: NS_IMETHODIMP
 1628: nsAccessible::GetRelation(PRUint32 aIndex, nsIAccessibleRelation **aRelation)
 1628: {
 1628:   NS_ENSURE_ARG_POINTER(aRelation);
 1628:   *aRelation = nsnull;
 1628: 
 1628:   nsCOMPtr<nsIArray> relations;
 1628:   nsresult rv = GetRelations(getter_AddRefs(relations));
 1628:   NS_ENSURE_SUCCESS(rv, rv);
 1628: 
 1628:   nsCOMPtr<nsIAccessibleRelation> relation;
 1628:   rv = relations->QueryElementAt(aIndex, NS_GET_IID(nsIAccessibleRelation),
 1628:                                  getter_AddRefs(relation));
13730: 
13730:   // nsIArray::QueryElementAt() returns NS_ERROR_ILLEGAL_VALUE on invalid index.
13730:   if (rv == NS_ERROR_ILLEGAL_VALUE)
13730:     return NS_ERROR_INVALID_ARG;
13730: 
 1628:   NS_ENSURE_SUCCESS(rv, rv);
 1628: 
 1628:   NS_IF_ADDREF(*aRelation = relation);
13730:   return NS_OK;
 1628: }
 1628: 
 1628: NS_IMETHODIMP
 1628: nsAccessible::GetRelations(nsIArray **aRelations)
 1628: {
 1628:   NS_ENSURE_ARG_POINTER(aRelations);
 1628: 
 1628:   nsCOMPtr<nsIMutableArray> relations = do_CreateInstance(NS_ARRAY_CONTRACTID);
 1628:   NS_ENSURE_TRUE(relations, NS_ERROR_OUT_OF_MEMORY);
 1628: 
 5475:   for (PRUint32 relType = nsIAccessibleRelation::RELATION_FIRST;
 5475:        relType < nsIAccessibleRelation::RELATION_LAST;
 5475:        ++relType) {
24822: 
24822:     nsCOMPtr<nsIAccessibleRelation> relation;
24822:     nsresult rv = GetRelationByType(relType, getter_AddRefs(relation));
24822: 
24822:     if (NS_SUCCEEDED(rv) && relation)
 1628:       relations->AppendElement(relation, PR_FALSE);
 1628:   }
 1628: 
 1628:   NS_ADDREF(*aRelations = relations);
 1628:   return NS_OK;
 1628: }
 1628: 
    1: /* void extendSelection (); */
    1: NS_IMETHODIMP nsAccessible::ExtendSelection()
    1: {
    1:   // XXX Should be implemented, but not high priority
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* [noscript] void getNativeInterface(out voidPtr aOutAccessible); */
    1: NS_IMETHODIMP nsAccessible::GetNativeInterface(void **aOutAccessible)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
37481: void
31673: nsAccessible::DoCommand(nsIContent *aContent, PRUint32 aActionIndex)
31673: {
31673:   nsCOMPtr<nsIContent> content = aContent;
31673:   if (!content)
38417:     content = nsCoreUtils::GetRoleContent(mDOMNode);
31673: 
37480:   NS_DISPATCH_RUNNABLEMETHOD_ARG2(DispatchClickEvent, this,
37480:                                   content, aActionIndex)
31673: }
31673: 
31673: void
31673: nsAccessible::DispatchClickEvent(nsIContent *aContent, PRUint32 aActionIndex)
31673: {
31673:   if (IsDefunct())
    1:     return;
16427: 
31673:   nsCOMPtr<nsIPresShell> presShell = GetPresShell();
16427: 
16427:   // Scroll into view.
31673:   presShell->ScrollContentIntoView(aContent, NS_PRESSHELL_SCROLL_ANYWHERE,
16427:                                    NS_PRESSHELL_SCROLL_ANYWHERE);
16427: 
16427:   // Fire mouse down and mouse up events.
20521:   PRBool res = nsCoreUtils::DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, presShell,
31673:                                                aContent);
16427:   if (!res)
16427:     return;
16427: 
31673:   nsCoreUtils::DispatchMouseEvent(NS_MOUSE_BUTTON_UP, presShell, aContent);
    1: }
    1: 
    1: already_AddRefed<nsIAccessible>
    1: nsAccessible::GetNextWithState(nsIAccessible *aStart, PRUint32 matchState)
    1: {
    1:   // Return the next descendant that matches one of the states in matchState
    1:   // Uses depth first search
    1:   NS_ASSERTION(matchState, "GetNextWithState() not called with a state to match");
    1:   NS_ASSERTION(aStart, "GetNextWithState() not called with an accessible to start with");
    1:   nsCOMPtr<nsIAccessible> look, current = aStart;
    1:   PRUint32 state = 0;
    1:   while (0 == (state & matchState)) {
    1:     current->GetFirstChild(getter_AddRefs(look));
    1:     while (!look) {
    1:       if (current == this) {
    1:         return nsnull; // At top of subtree
    1:       }
    1:       current->GetNextSibling(getter_AddRefs(look));
    1:       if (!look) {
    1:         current->GetParent(getter_AddRefs(look));
 7759:         current = look;
 7759:         look = nsnull;
    1:         continue;
    1:       }
    1:     }
    1:     current.swap(look);
20566:     state = nsAccUtils::State(current);
    1:   }
    1: 
    1:   nsIAccessible *returnAccessible = nsnull;
    1:   current.swap(returnAccessible);
    1: 
    1:   return returnAccessible;
    1: }
    1: 
    1: // nsIAccessibleSelectable
    1: NS_IMETHODIMP nsAccessible::GetSelectedChildren(nsIArray **aSelectedAccessibles)
    1: {
    1:   *aSelectedAccessibles = nsnull;
    1: 
    1:   nsCOMPtr<nsIMutableArray> selectedAccessibles =
    1:     do_CreateInstance(NS_ARRAY_CONTRACTID);
    1:   NS_ENSURE_STATE(selectedAccessibles);
    1: 
    1:   nsCOMPtr<nsIAccessible> selected = this;
    1:   while ((selected = GetNextWithState(selected, nsIAccessibleStates::STATE_SELECTED)) != nsnull) {
    1:     selectedAccessibles->AppendElement(selected, PR_FALSE);
    1:   }
    1: 
    1:   PRUint32 length = 0;
    1:   selectedAccessibles->GetLength(&length); 
    1:   if (length) { // length of nsIArray containing selected options
    1:     *aSelectedAccessibles = selectedAccessibles;
    1:     NS_ADDREF(*aSelectedAccessibles);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // return the nth selected descendant nsIAccessible object
    1: NS_IMETHODIMP nsAccessible::RefSelection(PRInt32 aIndex, nsIAccessible **aSelected)
    1: {
    1:   *aSelected = nsnull;
    1:   if (aIndex < 0) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   nsCOMPtr<nsIAccessible> selected = this;
    1:   PRInt32 count = 0;
    1:   while (count ++ <= aIndex) {
    1:     selected = GetNextWithState(selected, nsIAccessibleStates::STATE_SELECTED);
    1:     if (!selected) {
    1:       return NS_ERROR_FAILURE; // aIndex out of range
    1:     }
    1:   }
    1:   NS_IF_ADDREF(*aSelected = selected);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessible::GetSelectionCount(PRInt32 *aSelectionCount)
    1: {
    1:   *aSelectionCount = 0;
    1:   nsCOMPtr<nsIAccessible> selected = this;
    1:   while ((selected = GetNextWithState(selected, nsIAccessibleStates::STATE_SELECTED)) != nsnull) {
    1:     ++ *aSelectionCount;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessible::AddChildToSelection(PRInt32 aIndex)
    1: {
    1:   // Tree views and other container widgets which may have grandchildren should
    1:   // implement a selection methods for their specific interfaces, because being
    1:   // able to deal with selection on a per-child basis would not be enough.
    1: 
    1:   NS_ENSURE_TRUE(aIndex >= 0, NS_ERROR_FAILURE);
    1: 
36989:   nsAccessible* child = GetChildAt(aIndex);
20566:   PRUint32 state = nsAccUtils::State(child);
    1:   if (!(state & nsIAccessibleStates::STATE_SELECTABLE)) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   return child->SetSelected(PR_TRUE);
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessible::RemoveChildFromSelection(PRInt32 aIndex)
    1: {
    1:   // Tree views and other container widgets which may have grandchildren should
    1:   // implement a selection methods for their specific interfaces, because being
    1:   // able to deal with selection on a per-child basis would not be enough.
    1: 
    1:   NS_ENSURE_TRUE(aIndex >= 0, NS_ERROR_FAILURE);
    1: 
36989:   nsAccessible* child = GetChildAt(aIndex);
20566:   PRUint32 state = nsAccUtils::State(child);
    1:   if (!(state & nsIAccessibleStates::STATE_SELECTED)) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   return child->SetSelected(PR_FALSE);
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessible::IsChildSelected(PRInt32 aIndex, PRBool *aIsSelected)
    1: {
    1:   // Tree views and other container widgets which may have grandchildren should
    1:   // implement a selection methods for their specific interfaces, because being
    1:   // able to deal with selection on a per-child basis would not be enough.
    1: 
    1:   *aIsSelected = PR_FALSE;
    1:   NS_ENSURE_TRUE(aIndex >= 0, NS_ERROR_FAILURE);
    1: 
36989:   nsAccessible* child = GetChildAt(aIndex);
20566:   PRUint32 state = nsAccUtils::State(child);
    1:   if (state & nsIAccessibleStates::STATE_SELECTED) {
    1:     *aIsSelected = PR_TRUE;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessible::ClearSelection()
    1: {
    1:   nsCOMPtr<nsIAccessible> selected = this;
    1:   while ((selected = GetNextWithState(selected, nsIAccessibleStates::STATE_SELECTED)) != nsnull) {
    1:     selected->SetSelected(PR_FALSE);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessible::SelectAllSelection(PRBool *_retval)
    1: {
    1:   nsCOMPtr<nsIAccessible> selectable = this;
    1:   while ((selectable = GetNextWithState(selectable, nsIAccessibleStates::STATE_SELECTED)) != nsnull) {
    1:     selectable->SetSelected(PR_TRUE);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // nsIAccessibleHyperLink
    1: // Because of new-atk design, any embedded object in text can implement
    1: // nsIAccessibleHyperLink, which helps determine where it is located
    1: // within containing text
    1: 
14223: // readonly attribute long nsIAccessibleHyperLink::anchorCount
13749: NS_IMETHODIMP
14223: nsAccessible::GetAnchorCount(PRInt32 *aAnchorCount)
    1: {
14223:   NS_ENSURE_ARG_POINTER(aAnchorCount);
14223:   *aAnchorCount = 1;
    1:   return NS_OK;
    1: }
    1: 
13749: // readonly attribute long nsIAccessibleHyperLink::startIndex
13749: NS_IMETHODIMP
13749: nsAccessible::GetStartIndex(PRInt32 *aStartIndex)
    1: {
13749:   NS_ENSURE_ARG_POINTER(aStartIndex);
    1:   *aStartIndex = 0;
    1:   PRInt32 endIndex;
    1:   return GetLinkOffset(aStartIndex, &endIndex);
    1: }
    1: 
13749: // readonly attribute long nsIAccessibleHyperLink::endIndex
13749: NS_IMETHODIMP
13749: nsAccessible::GetEndIndex(PRInt32 *aEndIndex)
    1: {
13749:   NS_ENSURE_ARG_POINTER(aEndIndex);
    1:   *aEndIndex = 0;
    1:   PRInt32 startIndex;
    1:   return GetLinkOffset(&startIndex, aEndIndex);
    1: }
    1: 
13749: NS_IMETHODIMP
13757: nsAccessible::GetURI(PRInt32 aIndex, nsIURI **aURI)
    1: {
13749:   NS_ENSURE_ARG_POINTER(aURI);
    1:   *aURI = nsnull;
13757: 
13757:   if (aIndex != 0)
13757:     return NS_ERROR_INVALID_ARG;
13757: 
20072:   // Check if it's a simple xlink.
13757:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
20521:   if (nsCoreUtils::IsXLink(content)) {
13757:     nsAutoString href;
13757:     content->GetAttr(kNameSpaceID_XLink, nsAccessibilityAtoms::href, href);
13757: 
13757:     nsCOMPtr<nsIURI> baseURI = content->GetBaseURI();
13757:     nsCOMPtr<nsIDocument> document = content->GetOwnerDoc();
13757:     return NS_NewURI(aURI, href,
13757:                      document ? document->GetDocumentCharacterSet().get() : nsnull,
13757:                      baseURI);
13757:   }
13757: 
13757:   return NS_OK;
13757: }
13757: 
    1: 
13749: NS_IMETHODIMP
13749: nsAccessible::GetAnchor(PRInt32 aIndex,
    1:                         nsIAccessible **aAccessible)
    1: {
13730:   NS_ENSURE_ARG_POINTER(aAccessible);
    1:   *aAccessible = nsnull;
13730: 
13730:   if (aIndex != 0)
13730:     return NS_ERROR_INVALID_ARG;
13730: 
    1:   *aAccessible = this;
    1:   NS_ADDREF_THIS();
    1:   return NS_OK;
    1: }
    1: 
13749: // readonly attribute boolean nsIAccessibleHyperLink::valid
13749: NS_IMETHODIMP
13749: nsAccessible::GetValid(PRBool *aValid)
    1: {
13749:   NS_ENSURE_ARG_POINTER(aValid);
20566:   PRUint32 state = nsAccUtils::State(this);
13749:   *aValid = (0 == (state & nsIAccessibleStates::STATE_INVALID));
    1:   // XXX In order to implement this we would need to follow every link
    1:   // Perhaps we can get information about invalid links from the cache
13749:   // In the mean time authors can use role="link" aria-invalid="true"
    1:   // to force it for links they internally know to be invalid
    1:   return NS_OK;
    1: }
    1: 
13749: // readonly attribute boolean nsIAccessibleHyperLink::selected
13749: NS_IMETHODIMP
13749: nsAccessible::GetSelected(PRBool *aSelected)
    1: {
13749:   NS_ENSURE_ARG_POINTER(aSelected);
13749:   *aSelected = (gLastFocusedNode == mDOMNode);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsAccessible::GetLinkOffset(PRInt32* aStartOffset, PRInt32* aEndOffset)
    1: {
    1:   *aStartOffset = *aEndOffset = 0;
36989:   nsAccessible* parent = GetParent();
    1:   if (!parent) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsCOMPtr<nsIAccessible> accessible, nextSibling;
    1:   PRInt32 characterCount = 0;
    1:   parent->GetFirstChild(getter_AddRefs(accessible));
    1: 
    1:   while (accessible) {
20566:     if (nsAccUtils::IsText(accessible))
20566:       characterCount += nsAccUtils::TextLength(accessible);
20566: 
    1:     else if (accessible == this) {
    1:       *aStartOffset = characterCount;
    1:       *aEndOffset = characterCount + 1;
    1:       return NS_OK;
    1:     }
    1:     else {
    1:       ++ characterCount;
    1:     }
    1:     accessible->GetNextSibling(getter_AddRefs(nextSibling));
    1:     accessible.swap(nextSibling);
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
29320: nsresult
 4261: nsAccessible::AppendTextTo(nsAString& aText, PRUint32 aStartOffset, PRUint32 aLength)
  460: {
  460:   return NS_OK;
    1: }
    1: 
20246: ////////////////////////////////////////////////////////////////////////////////
20246: // nsAccessible public methods
20246: 
20246: nsresult
20246: nsAccessible::GetARIAName(nsAString& aName)
20246: {
20566:   nsCOMPtr<nsIContent> content = nsCoreUtils::GetRoleContent(mDOMNode);
20246:   if (!content)
20246:     return NS_OK;
20246: 
20246:   // First check for label override via aria-label property
20246:   nsAutoString label;
20246:   if (content->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_label, label)) {
25175:     label.CompressWhitespace();
20246:     aName = label;
20246:     return NS_OK;
20246:   }
20246:   
20246:   // Second check for label override via aria-labelledby relationship
25175:   nsresult rv = nsTextEquivUtils::
25175:     GetTextEquivFromIDRefs(this, nsAccessibilityAtoms::aria_labelledby, label);
25175:   if (NS_SUCCEEDED(rv)) {
25175:     label.CompressWhitespace();
20246:     aName = label;
25175:   }
20246: 
20246:   return rv;
20246: }
20246: 
20246: nsresult
20246: nsAccessible::GetNameInternal(nsAString& aName)
20246: {
20566:   nsCOMPtr<nsIContent> content = nsCoreUtils::GetRoleContent(mDOMNode);
20246:   if (!content)
20246:     return NS_OK;
20246: 
33329:   if (content->IsHTML())
22204:     return GetHTMLName(aName);
20246: 
33329:   if (content->IsXUL())
22204:     return GetXULName(aName);
20246: 
20246:   return NS_OK;
20246: }
20246: 
35523: void
36989: nsAccessible::SetParent(nsAccessible *aParent)
35523: {
35523:   NS_PRECONDITION(aParent, "This method isn't used to set null parent!");
35523: 
35523:   if (mParent && mParent != aParent) {
35523:     // Adopt a child -- we allow this now. the new parent
35523:     // may be a dom node which wasn't previously accessible but now is.
35523:     // The old parent's children now need to be invalidated, since 
35523:     // it no longer owns the child, the new parent does
35523:     NS_ASSERTION(PR_FALSE, "Adopting child!");
36989:     if (mParent)
36989:       mParent->InvalidateChildren();
35523:   }
35523: 
35523:   mParent = aParent;
35523: }
35523: 
35523: void
35523: nsAccessible::InvalidateChildren()
35523: {
36989:   PRInt32 childCount = mChildren.Length();
35523:   for (PRInt32 childIdx = 0; childIdx < childCount; childIdx++) {
36989:     nsAccessible* child = mChildren.ElementAt(childIdx);
35523:     child->mParent = nsnull;
35523:   }
35523: 
35523:   mChildren.Clear();
35523:   mAreChildrenInitialized = PR_FALSE;
35523: }
35523: 
36989: nsAccessible*
35523: nsAccessible::GetParent()
35523: {
35523:   if (IsDefunct())
35523:     return nsnull;
35523: 
35523:   if (mParent)
35523:     return mParent;
35523: 
35523:   nsCOMPtr<nsIAccessibleDocument> docAccessible(GetDocAccessible());
35523:   NS_ASSERTION(docAccessible, "No document accessible for valid accessible!");
35523: 
35523:   if (!docAccessible)
35523:     return nsnull;
35523: 
35523:   nsCOMPtr<nsIAccessible> parent;
35523:   docAccessible->GetAccessibleInParentChain(mDOMNode, PR_TRUE,
35523:                                             getter_AddRefs(parent));
35523: 
36989:   nsRefPtr<nsAccessible> parentAcc = nsAccUtils::QueryAccessible(parent);
36989: 
35523: #ifdef DEBUG
35523:   NS_ASSERTION(!parentAcc->IsDefunct(), "Defunct parent!");
35523: 
35523:   parentAcc->EnsureChildren();
35523:   if (parent != mParent)
35523:     NS_WARNING("Bad accessible tree!");
35523: #endif
35523: 
36989:   return parentAcc;
36989: }
36989: 
36989: nsAccessible*
35523: nsAccessible::GetChildAt(PRUint32 aIndex)
35523: {
35523:   if (EnsureChildren())
35523:     return nsnull;
35523: 
36989:   nsAccessible *child = mChildren.SafeElementAt(aIndex, nsnull);
35523:   if (!child)
35523:     return nsnull;
35523: 
35523: #ifdef DEBUG
36989:   nsAccessible* realParent = child->mParent;
35523:   NS_ASSERTION(!realParent || realParent == this,
35523:                "Two accessibles have the same first child accessible!");
35523: #endif
35523: 
35523:   return child;
35523: }
35523: 
35523: PRInt32
35523: nsAccessible::GetChildCount()
35523: {
36989:   return EnsureChildren() ? -1 : mChildren.Length();
35523: }
35523: 
35523: PRInt32
35523: nsAccessible::GetIndexOf(nsIAccessible *aChild)
35523: {
35523:   return EnsureChildren() ? -1 : mChildren.IndexOf(aChild);
35523: }
35523: 
35523: PRInt32
35523: nsAccessible::GetIndexInParent()
35523: {
36989:   nsAccessible *parent = GetParent();
36989:   return parent ? parent->GetIndexOf(this) : -1;
36989: }
36989: 
36989: nsAccessible*
35523: nsAccessible::GetCachedParent()
35523: {
35523:   if (IsDefunct())
35523:     return nsnull;
35523: 
36989:   return mParent;
36989: }
36989: 
36989: nsAccessible*
35523: nsAccessible::GetCachedFirstChild()
35523: {
35523:   if (IsDefunct())
35523:     return nsnull;
35523: 
36989:   return mChildren.SafeElementAt(0, nsnull);
35523: }
35523: 
35523: 
20246: ////////////////////////////////////////////////////////////////////////////////
35523: // nsAccessible protected methods
35523: 
35523: void
35523: nsAccessible::CacheChildren()
35523: {
38358:   nsAccTreeWalker walker(mWeakShell, nsCoreUtils::GetRoleContent(mDOMNode),
38358:                          GetAllowsAnonChildAccessibles());
38358: 
38359:   nsRefPtr<nsAccessible> child;
38358:   while ((child = walker.GetNextChild())) {
38359:     mChildren.AppendElement(child);
38359:     child->SetParent(this);
35523:   }
35523: }
35523: 
35523: void
36989: nsAccessible::TestChildCache(nsAccessible *aCachedChild)
35523: {
38000: #ifdef DEBUG
35523:   // All cached accessible nodes should be in the parent
35523:   // It will assert if not all the children were created
35523:   // when they were first cached, and no invalidation
35523:   // ever corrected parent accessible's child cache.
36989:   PRUint32 childCount = mChildren.Length();
35523:   if (childCount == 0) {
35523:     NS_ASSERTION(mAreChildrenInitialized,
38000:                  "Children are stored but not initialized!");
35523:     return;
35523:   }
35523: 
38000:   nsAccessible *child;
35523:   for (PRInt32 childIdx = 0; childIdx < childCount; childIdx++) {
38000:     child = GetChildAt(childIdx);
35523:     if (child == aCachedChild)
35523:       break;
35523:   }
35523: 
35523:   NS_ASSERTION(child == aCachedChild,
35523:                "[TestChildCache] cached accessible wasn't found. Wrong accessible tree!");  
35523: #endif
35523: }
35523: 
35523: PRBool
35523: nsAccessible::EnsureChildren()
35523: {
35523:   if (IsDefunct()) {
35523:     mAreChildrenInitialized = PR_FALSE;
35523:     return PR_TRUE;
35523:   }
35523: 
35523:   if (mAreChildrenInitialized)
35523:     return PR_FALSE;
35523: 
35523:   mAreChildrenInitialized = PR_TRUE; // Prevent reentry
35523:   CacheChildren();
35523: 
35523:   return PR_FALSE;
35523: }
35523: 
35523: nsIAccessible*
35523: nsAccessible::GetSiblingAtOffset(PRInt32 aOffset, nsresult* aError)
35523: {
35523:   if (IsDefunct()) {
35523:     if (aError)
35523:       *aError = NS_ERROR_FAILURE;
35523: 
35523:     return nsnull;
35523:   }
35523: 
36989:   nsAccessible *parent = GetParent();
35523:   if (!parent) {
35523:     if (aError)
35523:       *aError = NS_ERROR_UNEXPECTED;
35523: 
35523:     return nsnull;
35523:   }
35523: 
36989:   PRInt32 indexInParent = parent->GetIndexOf(this);
35523:   if (indexInParent == -1) {
35523:     if (aError)
35523:       *aError = NS_ERROR_UNEXPECTED;
35523: 
35523:     return nsnull;
35523:   }
35523: 
35523:   if (aError) {
36989:     PRInt32 childCount = parent->GetChildCount();
35523:     if (indexInParent + aOffset >= childCount) {
35523:       *aError = NS_OK; // fail peacefully
35523:       return nsnull;
35523:     }
35523:   }
35523: 
36989:   nsAccessible *child = parent->GetChildAt(indexInParent + aOffset);
35523:   if (aError && !child)
35523:     *aError = NS_ERROR_UNEXPECTED;
35523: 
35523:   return child;
35523: }
20246: 
    1: already_AddRefed<nsIAccessible>
34455: nsAccessible::GetFirstAvailableAccessible(nsIDOMNode *aStartNode)
    1: {
    1:   nsCOMPtr<nsIAccessible> accessible;
    1:   nsCOMPtr<nsIDOMTreeWalker> walker; 
    1:   nsCOMPtr<nsIDOMNode> currentNode(aStartNode);
    1: 
    1:   while (currentNode) {
37808:     GetAccService()->GetAccessibleInWeakShell(currentNode, mWeakShell,
37808:                                               getter_AddRefs(accessible));
34455:     if (accessible)
34455:       return accessible.forget();
34455: 
    1:     if (!walker) {
    1:       // Instantiate walker lazily since we won't need it in 90% of the cases
    1:       // where the first DOM node we're given provides an accessible
    1:       nsCOMPtr<nsIDOMDocument> document;
    1:       currentNode->GetOwnerDocument(getter_AddRefs(document));
    1:       nsCOMPtr<nsIDOMDocumentTraversal> trav = do_QueryInterface(document);
    1:       NS_ASSERTION(trav, "No DOM document traversal for document");
    1:       NS_ENSURE_TRUE(trav, nsnull);
    1:       trav->CreateTreeWalker(mDOMNode, nsIDOMNodeFilter::SHOW_ELEMENT | nsIDOMNodeFilter::SHOW_TEXT,
    1:                             nsnull, PR_FALSE, getter_AddRefs(walker));
    1:       NS_ENSURE_TRUE(walker, nsnull);
    1:       walker->SetCurrentNode(currentNode);
    1:     }
    1: 
    1:     walker->NextNode(getter_AddRefs(currentNode));
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: PRBool nsAccessible::CheckVisibilityInParentChain(nsIDocument* aDocument, nsIView* aView)
    1: {
    1:   nsIDocument* document = aDocument;
    1:   nsIView* view = aView;
    1:   // both view chain and widget chain are broken between chrome and content
    1:   while (document != nsnull) {
    1:     while (view != nsnull) {
    1:       if (view->GetVisibility() == nsViewVisibility_kHide) {
    1:         return PR_FALSE;
    1:       }
    1:       view = view->GetParent();
    1:     }
    1: 
    1:     nsIDocument* parentDoc = document->GetParentDocument();
    1:     if (parentDoc != nsnull) {
    1:       nsIContent* content = parentDoc->FindContentForSubDocument(document);
    1:       if (content != nsnull) {
  981:         nsIPresShell* shell = parentDoc->GetPrimaryShell();
 7889:         if (!shell) {
 7889:           return PR_FALSE;
 7889:         }
36654:         nsIFrame* frame = content->GetPrimaryFrame();
    1:         while (frame != nsnull && !frame->HasView()) {
    1:           frame = frame->GetParent();
    1:         }
    1: 
    1:         if (frame != nsnull) {
    1:           view = frame->GetViewExternal();
    1:         }
    1:       }
    1:     }
    1: 
    1:     document = parentDoc;
    1:   }
    1: 
    1:   return PR_TRUE;
    1: }
 4274: 
 4274: nsresult
 8937: nsAccessible::GetAttrValue(nsIAtom *aProperty, double *aValue)
 4274: {
 4274:   NS_ENSURE_ARG_POINTER(aValue);
 4274:   *aValue = 0;
 4274: 
28024:   if (IsDefunct())
 4274:     return NS_ERROR_FAILURE;  // Node already shut down
 4274: 
 4274:  if (!mRoleMapEntry || mRoleMapEntry->valueRule == eNoValue)
 4274:     return NS_OK_NO_ARIA_VALUE;
 4274: 
 4274:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
 4274:   NS_ENSURE_STATE(content);
 4274: 
28024:   nsAutoString attrValue;
28024:   content->GetAttr(kNameSpaceID_None, aProperty, attrValue);
28024: 
28024:   // Return zero value if there is no attribute or its value is empty.
28024:   if (attrValue.IsEmpty())
28024:     return NS_OK;
28024: 
28024:   PRInt32 error = NS_OK;
28024:   double value = attrValue.ToFloat(&error);
28024:   if (NS_SUCCEEDED(error))
28024:     *aValue = value;
28024: 
28024:   return NS_OK;
 4274: }
 4274: 
20140: PRUint32
20140: nsAccessible::GetActionRule(PRUint32 aStates)
20140: {
20140:   if (aStates & nsIAccessibleStates::STATE_UNAVAILABLE)
20140:     return eNoAction;
20140: 
27511:   nsIContent* content = nsCoreUtils::GetRoleContent(mDOMNode);
27511:   if (!content)
27511:     return eNoAction;
27511:   
20140:   // Check if it's simple xlink.
20521:   if (nsCoreUtils::IsXLink(content))
20140:     return eJumpAction;
20140: 
31782:   // Return "click" action on elements that have an attached popup menu.
33329:   if (content->IsXUL())
31782:     if (content->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::popup))
31782:       return eClickAction;
31782: 
20140:   // Has registered 'click' event handler.
37859:   PRBool isOnclick = nsCoreUtils::HasClickListener(content);
20140: 
20140:   if (isOnclick)
20140:     return eClickAction;
20140:   
20140:   // Get an action based on ARIA role.
27511:   if (mRoleMapEntry &&
27511:       mRoleMapEntry->actionRule != eNoAction)
20140:     return mRoleMapEntry->actionRule;
20140: 
27511:   // Get an action based on ARIA attribute.
27511:   if (nsAccUtils::HasDefinedARIAToken(content,
27511:                                    nsAccessibilityAtoms::aria_expanded))
27511:     return eExpandAction;
27511: 
20140:   return eNoAction;
20140: }
23326: 
36879: void
36879: nsAccessible::GetPositionAndSizeInternal(PRInt32 *aPosInSet, PRInt32 *aSetSize)
23326: {
36879:   PRUint32 role = nsAccUtils::Role(this);
36879:   if (role != nsIAccessibleRole::ROLE_LISTITEM &&
36879:       role != nsIAccessibleRole::ROLE_MENUITEM &&
36879:       role != nsIAccessibleRole::ROLE_CHECK_MENU_ITEM &&
36879:       role != nsIAccessibleRole::ROLE_RADIO_MENU_ITEM &&
36879:       role != nsIAccessibleRole::ROLE_RADIOBUTTON &&
36879:       role != nsIAccessibleRole::ROLE_PAGETAB &&
36879:       role != nsIAccessibleRole::ROLE_OPTION &&
36879:       role != nsIAccessibleRole::ROLE_OUTLINEITEM &&
36879:       role != nsIAccessibleRole::ROLE_ROW &&
36879:       role != nsIAccessibleRole::ROLE_GRID_CELL)
36879:     return;
36879: 
36879:   PRUint32 baseRole = role;
36879:   if (role == nsIAccessibleRole::ROLE_CHECK_MENU_ITEM ||
36879:       role == nsIAccessibleRole::ROLE_RADIO_MENU_ITEM)
23326:     baseRole = nsIAccessibleRole::ROLE_MENUITEM;
23326: 
36989:   nsAccessible* parent = GetParent();
36879:   NS_ENSURE_TRUE(parent,);
23326: 
37109:   PRInt32 indexInParent = parent->GetIndexOf(this);
37109:   PRInt32 level = nsAccUtils::GetARIAOrDefaultLevel(this);
37109: 
37109:   // Compute 'posinset'.
37109:   PRInt32 positionInGroup = 1;
37109:   for (PRInt32 idx = indexInParent - 1; idx >= 0; idx--) {
37109:     nsAccessible* sibling = parent->GetChildAt(idx);
36989: 
36989:     PRUint32 siblingRole = siblingRole = nsAccUtils::Role(sibling);
37109: 
37109:     // If the sibling is separator then the group is ended.
37109:     if (siblingRole == nsIAccessibleRole::ROLE_SEPARATOR)
37109:       break;
37109: 
36989:     PRUint32 siblingBaseRole = siblingRole;
23326:     if (siblingRole == nsIAccessibleRole::ROLE_CHECK_MENU_ITEM ||
23326:         siblingRole == nsIAccessibleRole::ROLE_RADIO_MENU_ITEM)
23326:       siblingBaseRole = nsIAccessibleRole::ROLE_MENUITEM;
23326: 
37109:     // If sibling is visible and has the same base role
23326:     if (siblingBaseRole == baseRole &&
23326:         !(nsAccUtils::State(sibling) & nsIAccessibleStates::STATE_INVISIBLE)) {
37109: 
37109:       // and check if it's hierarchical flatten structure, i.e. if the sibling
37109:       // level is lesser than this one then group is ended, if the sibling level
37109:       // is greater than this one then the group is splited by some child
37109:       // elements (group will be continued).
37109:       PRInt32 siblingLevel = nsAccUtils::GetARIAOrDefaultLevel(sibling);
37109:       if (siblingLevel < level)
37109:         break;
37109:       else if (level == siblingLevel)
37109:         ++ positionInGroup;
37109:     }
37109:   }
37109: 
37109:   // Compute 'setsize'.
37109:   PRInt32 setSize = positionInGroup;
37109: 
37109:   PRInt32 siblingCount = parent->GetChildCount();
37109:   for (PRInt32 idx = indexInParent + 1; idx < siblingCount; idx++) {
37109:     nsAccessible* sibling = parent->GetChildAt(idx);
37109:     NS_ENSURE_TRUE(sibling,);
37109: 
37109:     PRUint32 siblingRole = nsAccUtils::Role(sibling);
37109: 
37109:     // If the sibling is separator then the group is ended.
37109:     if (siblingRole == nsIAccessibleRole::ROLE_SEPARATOR)
37109:       break;
37109: 
37109:     PRUint32 siblingBaseRole = siblingRole;
37109:     if (siblingRole == nsIAccessibleRole::ROLE_CHECK_MENU_ITEM ||
37109:         siblingRole == nsIAccessibleRole::ROLE_RADIO_MENU_ITEM)
37109:       siblingBaseRole = nsIAccessibleRole::ROLE_MENUITEM;
37109: 
37109:     // If sibling is visible and has the same base role
37109:     if (siblingBaseRole == baseRole &&
37109:         !(nsAccUtils::State(sibling) & nsIAccessibleStates::STATE_INVISIBLE)) {
37109: 
37109:       // and check if it's hierarchical flatten structure.
37109:       PRInt32 siblingLevel = nsAccUtils::GetARIAOrDefaultLevel(sibling);
37109:       if (siblingLevel < level)
37109:         break;
37109:       else if (level == siblingLevel)
23326:         ++ setSize;
23326:     }
23326:   }
23326: 
36879:   *aPosInSet = positionInGroup;
36879:   *aSetSize = setSize;
36879: }
36879: 
36879: PRInt32
36879: nsAccessible::GetLevelInternal()
36879: {
37109:   PRInt32 level = nsAccUtils::GetDefaultLevel(this);
37109: 
36879:   PRUint32 role = nsAccUtils::Role(this);
36989:   nsAccessible* parent = GetParent();
36879: 
36879:   if (role == nsIAccessibleRole::ROLE_OUTLINEITEM) {
23326:     // Always expose 'level' attribute for 'outlineitem' accessible. The number
23326:     // of nested 'grouping' accessibles containing 'outlineitem' accessible is
23326:     // its level.
37109:     level = 1;
37109: 
23326:     while (parent) {
23326:       PRUint32 parentRole = nsAccUtils::Role(parent);
23326: 
23326:       if (parentRole == nsIAccessibleRole::ROLE_OUTLINE)
23326:         break;
23326:       if (parentRole == nsIAccessibleRole::ROLE_GROUPING)
36879:         ++ level;
23326: 
36989:       parent = parent->GetParent();
23326:     }
36879: 
37109:   } else if (role == nsIAccessibleRole::ROLE_LISTITEM) {
23326:     // Expose 'level' attribute on nested lists. We assume nested list is a last
23326:     // child of listitem of parent list. We don't handle the case when nested
23326:     // lists have more complex structure, for example when there are accessibles
23326:     // between parent listitem and nested list.
23326: 
23326:     // Calculate 'level' attribute based on number of parent listitems.
37109:     level = 0;
36879: 
23326:     while (parent) {
23326:       PRUint32 parentRole = nsAccUtils::Role(parent);
23326: 
23326:       if (parentRole == nsIAccessibleRole::ROLE_LISTITEM)
36879:         ++ level;
23326:       else if (parentRole != nsIAccessibleRole::ROLE_LIST)
23326:         break;
23326: 
36989:       parent = parent->GetParent();
23326:     }
23326: 
36879:     if (level == 0) {
23326:       // If this listitem is on top of nested lists then expose 'level'
23326:       // attribute.
36989:       nsAccessible* parent(GetParent());
36989:       PRInt32 siblingCount = parent->GetChildCount();
36989:       for (PRInt32 siblingIdx = 0; siblingIdx < siblingCount; siblingIdx++) {
36989:         nsAccessible* sibling = parent->GetChildAt(siblingIdx);
36989: 
23326:         nsCOMPtr<nsIAccessible> siblingChild;
23326:         sibling->GetLastChild(getter_AddRefs(siblingChild));
23326:         if (nsAccUtils::Role(siblingChild) == nsIAccessibleRole::ROLE_LIST) {
36879:           level = 1;
23326:           break;
23326:         }
23326:       }
36879:     } else {
36879:       ++ level; // level is 1-index based
36879:     }
37109:   }
36879: 
36879:   return level;
36879: }
