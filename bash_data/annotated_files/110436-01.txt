 42593: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 42593: 
 42593: #include "FrameLayerBuilder.h"
 42593: 
 42593: #include "nsDisplayList.h"
 42593: #include "nsPresContext.h"
 42593: #include "nsLayoutUtils.h"
 47736: #include "Layers.h"
 47751: #include "BasicLayers.h"
 51754: #include "nsSubDocumentFrame.h"
 52292: #include "nsCSSRendering.h"
 54261: #include "nsCSSFrameConstructor.h"
 58579: #include "gfxUtils.h"
 60712: #include "nsImageFrame.h"
 68487: #include "nsRenderingContext.h"
102918: #include "MaskLayerImageCache.h"
 47736: 
 82255: #include "mozilla/Preferences.h"
 84290: #include "sampler.h"
 82255: 
107003: #include "nsAnimationManager.h"
107003: #include "nsTransitionManager.h"
107003: 
 47736: #ifdef DEBUG
 47736: #include <stdio.h>
 47736: #endif
 42593: 
 42593: using namespace mozilla::layers;
 42593: 
 42593: namespace mozilla {
 42593: 
108991: FrameLayerBuilder::DisplayItemData::DisplayItemData(Layer* aLayer, uint32_t aKey, LayerState aLayerState, uint32_t aGeneration)
108884:   : mLayer(aLayer)
108884:   , mDisplayItemKey(aKey)
108884:   , mContainerLayerGeneration(aGeneration)
108884:   , mLayerState(aLayerState)
108884: {}
108884: 
108884: FrameLayerBuilder::DisplayItemData::~DisplayItemData()
108884: {}
108884: 
 42593: /**
 47736:  * This is the userdata we associate with a layer manager.
 42593:  */
 51946: class LayerManagerData : public LayerUserData {
 42593: public:
103530:   LayerManagerData(LayerManager *aManager) :
103530:     mInvalidateAllLayers(false),
103530:     mLayerManager(aManager)
 42593:   {
 51946:     MOZ_COUNT_CTOR(LayerManagerData);
 47736:     mFramesWithLayers.Init();
 42593:   }
 51946:   ~LayerManagerData() {
 51947:     // Remove display item data properties now, since we won't be able
 51947:     // to find these frames again without mFramesWithLayers.
 51947:     mFramesWithLayers.EnumerateEntries(
106838:         FrameLayerBuilder::RemoveDisplayItemDataForFrame, nullptr);
103523:     MOZ_COUNT_DTOR(LayerManagerData);
 51946:   }
 42593: 
 47736:   /**
 47736:    * Tracks which frames have layers associated with them.
 47736:    */
 79931:   nsTHashtable<FrameLayerBuilder::DisplayItemDataEntry> mFramesWithLayers;
 79445:   bool mInvalidateAllLayers;
103530:   /** Layer manager we belong to, we hold a reference to this object. */
103530:   nsRefPtr<LayerManager> mLayerManager;
 42593: };
 42593: 
105568: LayerManagerLayerBuilder::~LayerManagerLayerBuilder()
105568: {
105568:   MOZ_COUNT_DTOR(LayerManagerLayerBuilder);
105568:   if (mDelete) {
105568:     delete mLayerBuilder;
105568:   }
105568: }
105568: 
101681: namespace {
101681: 
102919: // a global cache of image containers used for mask layers
106838: static MaskLayerImageCache* gMaskLayerImageCache = nullptr;
102919: 
102919: static inline MaskLayerImageCache* GetMaskLayerImageCache()
102919: {
102919:   if (!gMaskLayerImageCache) {
102919:     gMaskLayerImageCache = new MaskLayerImageCache();
102919:   }
102919: 
102919:   return gMaskLayerImageCache;
102919: }
102919: 
103530: static void DestroyRefCountedRegion(void* aPropertyValue)
103530: {
103530:   static_cast<RefCountedRegion*>(aPropertyValue)->Release();
103530: }
103530: 
103530: /**
103530:  * This property represents a region that should be invalidated in every
103530:  * ThebesLayer child whose parent ContainerLayer is associated with the
103530:  * frame. This is an nsRegion*; the coordinates of the region are
103530:  * relative to the top-left of the border-box of the frame the property
103530:  * is attached to (which is the frame for the ContainerLayer).
103530:  * 
103530:  * We add to this region in InvalidateThebesLayerContents. The region
103530:  * is propagated to ContainerState in BuildContainerLayerFor, and then
103530:  * the region(s) are actually invalidated in CreateOrRecycleThebesLayer.
103530:  *
103530:  * When the property value is null, the region is infinite --- i.e. all
103530:  * areas of the ThebesLayers should be invalidated.
103530:  */
103530: NS_DECLARE_FRAME_PROPERTY(ThebesLayerInvalidRegionProperty, DestroyRefCountedRegion)
103530: 
103530: static void DestroyPoint(void* aPropertyValue)
103530: {
103530:   delete static_cast<nsPoint*>(aPropertyValue);
103530: }
103530: 
103530: /**
103530:  * The valid content in our child ThebesLayers is defined relative to
103530:  * the offset from this frame to its active scroll root, mapped back
103530:  * by the ThebesLayer's inverse transform.  Since we accumulate the
103530:  * region invalidated between last-paint and next-paint, and because
103530:  * the offset of this frame to its active root may change during that
103530:  * period, we save the offset at last-paint in this property and use
103530:  * it to invalidate at next-paint.
103530:  */
103530: NS_DECLARE_FRAME_PROPERTY(ThebesLayerLastPaintOffsetProperty, DestroyPoint)
103530: 
 47736: /**
 47736:  * This is a helper object used to build up the layer children for
 47736:  * a ContainerLayer.
 47736:  */
 47736: class ContainerState {
 47736: public:
 47736:   ContainerState(nsDisplayListBuilder* aBuilder,
 47736:                  LayerManager* aManager,
105568:                  FrameLayerBuilder* aLayerBuilder,
 47736:                  nsIFrame* aContainerFrame,
 72231:                  ContainerLayer* aContainerLayer,
 72231:                  const FrameLayerBuilder::ContainerParameters& aParameters) :
 47736:     mBuilder(aBuilder), mManager(aManager),
105568:     mLayerBuilder(aLayerBuilder),
 47736:     mContainerFrame(aContainerFrame), mContainerLayer(aContainerLayer),
 72231:     mParameters(aParameters),
108785:     mNextFreeRecycledThebesLayer(0), mInvalidateAllThebesContent(false)
 47736:   {
 95051:     nsPresContext* presContext = aContainerFrame->PresContext();
 95051:     mAppUnitsPerDevPixel = presContext->AppUnitsPerDevPixel();
 95051:     // When AllowResidualTranslation is false, display items will be drawn
 95051:     // scaled with a translation by integer pixels, so we know how the snapping
 95051:     // will work.
 95051:     mSnappingEnabled = aManager->IsSnappingEffectiveTransforms() &&
 95051:       !mParameters.AllowResidualTranslation();
 97431:     mRecycledMaskImageLayers.Init();
 47745:     CollectOldLayers();
 47736:   }
 47736: 
106095:   enum ProcessDisplayItemsFlags {
106095:     NO_COMPONENT_ALPHA = 0x01,
106095:   };
106095: 
103531:   void AddInvalidThebesContent(const nsIntRegion& aRegion)
103530:   {
103531:     mInvalidThebesContent.Or(mInvalidThebesContent, aRegion);
103530:   }
103530:   void SetInvalidateAllThebesContent()
103530:   {
103530:     mInvalidateAllThebesContent = true;
103530:   }
 47736:   /**
 47736:    * This is the method that actually walks a display list and builds
 47736:    * the child layers. We invoke it recursively to process clipped sublists.
 47736:    * @param aClipRect the clip rect to apply to the list items, or null
 47736:    * if no clipping is required
 47736:    */
 47736:   void ProcessDisplayItems(const nsDisplayList& aList,
106095:                            FrameLayerBuilder::Clip& aClip,
108991:                            uint32_t aFlags);
 47736:   /**
 47736:    * This finalizes all the open ThebesLayers by popping every element off
 47736:    * mThebesLayerDataStack, then sets the children of the container layer
 47736:    * to be all the layers in mNewChildLayers in that order and removes any
 47736:    * layers as children of the container that aren't in mNewChildLayers.
 59482:    * @param aTextContentFlags if any child layer has CONTENT_COMPONENT_ALPHA,
 59482:    * set *aTextContentFlags to CONTENT_COMPONENT_ALPHA
 47736:    */
108991:   void Finish(uint32_t *aTextContentFlags);
 47736: 
 62985:   nsRect GetChildrenBounds() { return mBounds; }
 62985: 
 95051:   nscoord GetAppUnitsPerDevPixel() { return mAppUnitsPerDevPixel; }
 95051: 
 95051:   nsIntRect ScaleToNearestPixels(const nsRect& aRect)
 95051:   {
 95051:     return aRect.ScaleToNearestPixels(mParameters.mXScale, mParameters.mYScale,
 95051:                                       mAppUnitsPerDevPixel);
 95051:   }
106093:   nsIntRegion ScaleRegionToNearestPixels(const nsRegion& aRegion)
106093:   {
106093:     return aRegion.ScaleToNearestPixels(mParameters.mXScale, mParameters.mYScale,
106093:                                         mAppUnitsPerDevPixel);
106093:   }
 95051:   nsIntRect ScaleToOutsidePixels(const nsRect& aRect, bool aSnap)
 95051:   {
 95051:     if (aSnap && mSnappingEnabled) {
 95051:       return ScaleToNearestPixels(aRect);
 95051:     }
 95051:     return aRect.ScaleToOutsidePixels(mParameters.mXScale, mParameters.mYScale,
 95051:                                       mAppUnitsPerDevPixel);
 95051:   }
 95051:   nsIntRect ScaleToInsidePixels(const nsRect& aRect, bool aSnap)
 95051:   {
 95051:     if (aSnap && mSnappingEnabled) {
 95051:       return ScaleToNearestPixels(aRect);
 95051:     }
 95051:     return aRect.ScaleToInsidePixels(mParameters.mXScale, mParameters.mYScale,
 95051:                                      mAppUnitsPerDevPixel);
 95051:   }
 95051: 
106093:   nsIntRegion ScaleRegionToInsidePixels(const nsRegion& aRegion, bool aSnap)
106093:   {
106093:     if (aSnap && mSnappingEnabled) {
106093:       return ScaleRegionToNearestPixels(aRegion);
106093:     }
106093:     return aRegion.ScaleToInsidePixels(mParameters.mXScale, mParameters.mYScale,
106093:                                         mAppUnitsPerDevPixel);
106093:   }
106093: 
103531:   const FrameLayerBuilder::ContainerParameters& ScaleParameters() { return mParameters; };
103531: 
 47736: protected:
 47736:   /**
 47736:    * We keep a stack of these to represent the ThebesLayers that are
 47736:    * currently available to have display items added to.
 47736:    * We use a stack here because as much as possible we want to
 47736:    * assign display items to existing ThebesLayers, and to the lowest
 47736:    * ThebesLayer in z-order. This reduces the number of layers and
 47736:    * makes it more likely a display item will be rendered to an opaque
 47736:    * layer, giving us the best chance of getting subpixel AA.
 47736:    */
 47736:   class ThebesLayerData {
 47736:   public:
 47745:     ThebesLayerData() :
106838:       mActiveScrolledRoot(nullptr), mLayer(nullptr),
 80486:       mIsSolidColorInVisibleRegion(false),
 80486:       mNeedComponentAlpha(false),
 80486:       mForceTransparentSurface(false),
106838:       mImage(nullptr),
 97433:       mCommonClipCount(-1) {}
 47736:     /**
 47736:      * Record that an item has been added to the ThebesLayer, so we
 47736:      * need to update our regions.
 47772:      * @param aVisibleRect the area of the item that's visible
 48689:      * @param aDrawRect the area of the item that would be drawn if it
 48689:      * was completely visible
 47772:      * @param aOpaqueRect if non-null, the area of the item that's opaque.
 47772:      * We pass in a separate opaque rect because the opaque rect can be
 47772:      * bigger than the visible rect, and we want to have the biggest
 47772:      * opaque rect that we can.
 47772:      * @param aSolidColor if non-null, the visible area of the item is
 47772:      * a constant color given by *aSolidColor
 47736:      */
 72231:     void Accumulate(ContainerState* aState,
 51949:                     nsDisplayItem* aItem,
 51949:                     const nsIntRect& aVisibleRect,
 59779:                     const nsIntRect& aDrawRect,
 59779:                     const FrameLayerBuilder::Clip& aClip);
 47736:     nsIFrame* GetActiveScrolledRoot() { return mActiveScrolledRoot; }
 47736: 
 47736:     /**
 60712:      * If this represents only a nsDisplayImage, and the image type
 60712:      * supports being optimized to an ImageLayer (TYPE_RASTER only) returns
 60712:      * an ImageContainer for the image.
 60712:      */
 89204:     already_AddRefed<ImageContainer> CanOptimizeImageLayer();
 60712: 
 60712:     /**
 47736:      * The region of visible content in the layer, relative to the
 47736:      * container layer (which is at the snapped top-left of the display
 47736:      * list reference frame).
 47736:      */
 47736:     nsIntRegion  mVisibleRegion;
 47736:     /**
 47736:      * The region of visible content above the layer and below the
 47736:      * next ThebesLayerData currently in the stack, if any. Note that not
 47736:      * all ThebesLayers for the container are in the ThebesLayerData stack.
 47736:      * Same coordinate system as mVisibleRegion.
 87083:      * This is a conservative approximation: it contains the true region.
 47736:      */
 47736:     nsIntRegion  mVisibleAboveRegion;
 47736:     /**
 48689:      * The region containing the bounds of all display items in the layer,
 48689:      * regardless of visbility.
 48689:      * Same coordinate system as mVisibleRegion.
 87083:      * This is a conservative approximation: it contains the true region.
 48689:      */
 48689:     nsIntRegion  mDrawRegion;
 48689:     /**
 48689:      * The region containing the bounds of all display items (regardless
 48689:      * of visibility) in the layer and below the next ThebesLayerData
 48689:      * currently in the stack, if any.
 48689:      * Note that not all ThebesLayers for the container are in the
 48689:      * ThebesLayerData stack.
 48689:      * Same coordinate system as mVisibleRegion.
 48689:      */
 48689:     nsIntRegion  mDrawAboveRegion;
 48689:     /**
 47736:      * The region of visible content in the layer that is opaque.
 47736:      * Same coordinate system as mVisibleRegion.
 47736:      */
 47736:     nsIntRegion  mOpaqueRegion;
 47736:     /**
 47736:      * The "active scrolled root" for all content in the layer. Must
 47736:      * be non-null; all content in a ThebesLayer must have the same
 47736:      * active scrolled root.
 47736:      */
 47736:     nsIFrame*    mActiveScrolledRoot;
 47736:     ThebesLayer* mLayer;
 47745:     /**
 47745:      * If mIsSolidColorInVisibleRegion is true, this is the color of the visible
 47745:      * region.
 47745:      */
 47745:     nscolor      mSolidColor;
 47745:     /**
 47745:      * True if every pixel in mVisibleRegion will have color mSolidColor.
 47745:      */
 79445:     bool mIsSolidColorInVisibleRegion;
 51951:     /**
 51951:      * True if there is any text visible in the layer that's over
 51951:      * transparent pixels in the layer.
 51951:      */
 79445:     bool mNeedComponentAlpha;
 56101:     /**
 56101:      * Set if the layer should be treated as transparent, even if its entire
 56101:      * area is covered by opaque display items. For example, this needs to
 56101:      * be set if something is going to "punch holes" in the layer by clearing
 56101:      * part of its surface.
 56101:      */
 79445:     bool mForceTransparentSurface;
 60712: 
 60712:     /**
 60712:      * Stores the pointer to the nsDisplayImage if we want to
 60712:      * convert this to an ImageLayer.
 60712:      */
 60712:     nsDisplayImage* mImage;
 64533:     /**
 97433:      * Stores the clip that we need to apply to the image or, if there is no
 97433:      * image, a clip for SOME item in the layer. There is no guarantee which
 97433:      * item's clip will be stored here and mItemClip should not be used to clip
 97433:      * the whole layer - only some part of the clip should be used, as determined
 97433:      * by ThebesDisplayItemLayerUserData::GetCommonClipCount() - which may even be
 97433:      * no part at all.
 64533:      */
 97433:     FrameLayerBuilder::Clip mItemClip;
 97433:     /**
 97433:      * The first mCommonClipCount rounded rectangle clips are identical for
 97433:      * all items in the layer.
 97433:      * -1 if there are no items in the layer; must be >=0 by the time that this
 97433:      * data is popped from the stack.
 97433:      */
108991:     int32_t mCommonClipCount;
 97433:     /*
 97433:      * Updates mCommonClipCount by checking for rounded rect clips in common
 97433:      * between the clip on a new item (aCurrentClip) and the common clips
 97433:      * on items already in the layer (the first mCommonClipCount rounded rects
 97433:      * in mItemClip).
 97433:      */
 97433:     void UpdateCommonClipCount(const FrameLayerBuilder::Clip& aCurrentClip);
 42593:   };
 72231:   friend class ThebesLayerData;
 42593: 
 42593:   /**
 47736:    * Grab the next recyclable ThebesLayer, or create one if there are no
 47736:    * more recyclable ThebesLayers. Does any necessary invalidation of
 47736:    * a recycled ThebesLayer, and sets up the transform on the ThebesLayer
 47745:    * to account for scrolling.
 42593:    */
 47736:   already_AddRefed<ThebesLayer> CreateOrRecycleThebesLayer(nsIFrame* aActiveScrolledRoot);
 47736:   /**
 47745:    * Grab the next recyclable ColorLayer, or create one if there are no
 47745:    * more recyclable ColorLayers.
 47745:    */
108785:   already_AddRefed<ColorLayer> CreateOrRecycleColorLayer(ThebesLayer* aThebes);
 47745:   /**
 60712:    * Grab the next recyclable ImageLayer, or create one if there are no
 60712:    * more recyclable ImageLayers.
 60712:    */
108785:   already_AddRefed<ImageLayer> CreateOrRecycleImageLayer(ThebesLayer* aThebes);
 60712:   /**
 97431:    * Grab a recyclable ImageLayer for use as a mask layer for aLayer (that is a
 97431:    * mask layer which has been used for aLayer before), or create one if such
 97431:    * a layer doesn't exist.
 97431:    */
 97431:   already_AddRefed<ImageLayer> CreateOrRecycleMaskImageLayerFor(Layer* aLayer);
 97431:   /**
 47745:    * Grabs all ThebesLayers and ColorLayers from the ContainerLayer and makes them
 47736:    * available for recycling.
 47736:    */
 47745:   void CollectOldLayers();
 47736:   /**
 47751:    * If aItem used to belong to a ThebesLayer, invalidates the area of
 47751:    * aItem in that layer. If aNewLayer is a ThebesLayer, invalidates the area of
 47751:    * aItem in that layer.
 47751:    */
103513:   void InvalidateForLayerChange(nsDisplayItem* aItem, Layer* aNewLayer);
 47751:   /**
 51947:    * Try to determine whether the ThebesLayer at aThebesLayerIndex
 60025:    * has a single opaque color behind it, over the entire bounds of its visible
 60025:    * region.
 51947:    * If successful, return that color, otherwise return NS_RGBA(0,0,0,0).
 51947:    */
108991:   nscolor FindOpaqueBackgroundColorFor(int32_t aThebesLayerIndex);
 51947:   /**
 47736:    * Indicate that we are done adding items to the ThebesLayer at the top of
 47736:    * mThebesLayerDataStack. Set the final visible region and opaque-content
 47736:    * flag, and pop it off the stack.
 47736:    */
 47736:   void PopThebesLayerData();
 47736:   /**
 47736:    * Find the ThebesLayer to which we should assign the next display item.
 48689:    * We scan the ThebesLayerData stack to find the topmost ThebesLayer
 48689:    * that is compatible with the display item (i.e., has the same
 48689:    * active scrolled root), and that has no content from other layers above
 48689:    * it and intersecting the aVisibleRect.
 47736:    * Returns the layer, and also updates the ThebesLayerData. Will
 48689:    * push a new ThebesLayerData onto the stack if no suitable existing
 48689:    * layer is found. If we choose a ThebesLayer that's already on the
 48689:    * ThebesLayerData stack, later elements on the stack will be popped off.
 47736:    * @param aVisibleRect the area of the next display item that's visible
 47736:    * @param aActiveScrolledRoot the active scrolled root for the next
 47736:    * display item
 47772:    * @param aOpaqueRect if non-null, a region of the display item that is opaque
 47745:    * @param aSolidColor if non-null, indicates that every pixel in aVisibleRect
 47745:    * will be painted with aSolidColor by the item
 47736:    */
 97433:   ThebesLayerData* FindThebesLayerFor(nsDisplayItem* aItem,
 51949:                                                    const nsIntRect& aVisibleRect,
 48689:                                                    const nsIntRect& aDrawRect,
 59779:                                                    const FrameLayerBuilder::Clip& aClip,
 51949:                                                    nsIFrame* aActiveScrolledRoot);
 47736:   ThebesLayerData* GetTopThebesLayerData()
 47736:   {
106838:     return mThebesLayerDataStack.IsEmpty() ? nullptr
 47736:         : mThebesLayerDataStack[mThebesLayerDataStack.Length() - 1].get();
 47736:   }
 42593: 
 97433:   /* Build a mask layer to represent the clipping region. Will return null if
 97433:    * there is no clipping specified or a mask layer cannot be built.
 97433:    * Builds an ImageLayer for the appropriate backend; the mask is relative to
 97433:    * aLayer's visible region.
 97433:    * aLayer is the layer to be clipped.
 97433:    * aRoundedRectClipCount is used when building mask layers for ThebesLayers,
 97433:    * SetupMaskLayer will build a mask layer for only the first
 97433:    * aRoundedRectClipCount rounded rects in aClip
 97433:    */
 97433:   void SetupMaskLayer(Layer *aLayer, const FrameLayerBuilder::Clip& aClip,
108991:                       uint32_t aRoundedRectClipCount = PR_UINT32_MAX);
 97433: 
 47736:   nsDisplayListBuilder*            mBuilder;
 47736:   LayerManager*                    mManager;
105568:   FrameLayerBuilder*               mLayerBuilder;
 47736:   nsIFrame*                        mContainerFrame;
 47736:   ContainerLayer*                  mContainerLayer;
 72231:   FrameLayerBuilder::ContainerParameters mParameters;
 47736:   /**
 47736:    * The region of ThebesLayers that should be invalidated every time
 47736:    * we recycle one.
 47736:    */
 47736:   nsIntRegion                      mInvalidThebesContent;
 62985:   nsRect                           mBounds;
 47736:   nsAutoTArray<nsAutoPtr<ThebesLayerData>,1>  mThebesLayerDataStack;
 47736:   /**
 47736:    * We collect the list of children in here. During ProcessDisplayItems,
 47736:    * the layers in this array either have mContainerLayer as their parent,
 47736:    * or no parent.
 47736:    */
 57140:   typedef nsAutoTArray<nsRefPtr<Layer>,1> AutoLayersArray;
 57140:   AutoLayersArray                  mNewChildLayers;
 47736:   nsTArray<nsRefPtr<ThebesLayer> > mRecycledThebesLayers;
 97431:   nsDataHashtable<nsPtrHashKey<Layer>, nsRefPtr<ImageLayer> >
 97431:     mRecycledMaskImageLayers;
108991:   uint32_t                         mNextFreeRecycledThebesLayer;
 95051:   nscoord                          mAppUnitsPerDevPixel;
103530:   bool                             mInvalidateAllThebesContent;
 95051:   bool                             mSnappingEnabled;
 42593: };
 42593: 
 51947: class ThebesDisplayItemLayerUserData : public LayerUserData
 51947: {
 51947: public:
 51947:   ThebesDisplayItemLayerUserData() :
 72247:     mForcedBackgroundColor(NS_RGBA(0,0,0,0)),
 72247:     mXScale(1.f), mYScale(1.f),
 72247:     mActiveScrolledRootPosition(0, 0) {}
 51947: 
 60025:   /**
 60025:    * A color that should be painted over the bounds of the layer's visible
 60025:    * region before any other content is painted.
 60025:    */
 51947:   nscolor mForcedBackgroundColor;
 72231:   /**
 72231:    * The resolution scale used.
 72231:    */
 72231:   float mXScale, mYScale;
 97433: 
 72247:   /**
 72247:    * We try to make 0,0 of the ThebesLayer be the top-left of the
 72247:    * border-box of the "active scrolled root" frame (i.e. the nearest ancestor
 72247:    * frame for the display items that is being actively scrolled). But
 72247:    * we force the ThebesLayer transform to be an integer translation, and we may
 72247:    * have a resolution scale, so we have to snap the ThebesLayer transform, so
 72247:    * 0,0 may not be exactly the top-left of the active scrolled root. Here we
 72247:    * store the coordinates in ThebesLayer space of the top-left of the
 72247:    * active scrolled root.
 72247:    */
 72247:   gfxPoint mActiveScrolledRootPosition;
108785: 
108785:   nsRefPtr<ColorLayer> mColorLayer;
108785:   nsRefPtr<ImageLayer> mImageLayer;
 51947: };
 51947: 
 97430: /*
 97430:  * User data for layers which will be used as masks.
 97430:  */
 97430: struct MaskLayerUserData : public LayerUserData
 97430: {
106838:   MaskLayerUserData() : mImageKey(nullptr) {}
102918: 
102918:   bool
102918:   operator== (const MaskLayerUserData& aOther) const
102918:   {
102918:     return mRoundedClipRects == aOther.mRoundedClipRects &&
102918:            mScaleX == aOther.mScaleX &&
102918:            mScaleY == aOther.mScaleY;
102918:   }
102918: 
102918:   nsRefPtr<const MaskLayerImageCache::MaskLayerImageKey> mImageKey;
 97430:   // properties of the mask layer; the mask layer may be re-used if these
 97430:   // remain unchanged.
 97430:   nsTArray<FrameLayerBuilder::Clip::RoundedRect> mRoundedClipRects;
102918:   // scale from the masked layer which is applied to the mask
102918:   float mScaleX, mScaleY;
 97430: };
 97430: 
 42593: /**
 47736:  * The address of gThebesDisplayItemLayerUserData is used as the user
 51946:  * data key for ThebesLayers created by FrameLayerBuilder.
 47736:  * It identifies ThebesLayers used to draw non-layer content, which are
 47736:  * therefore eligible for recycling. We want display items to be able to
 47736:  * create their own dedicated ThebesLayers in BuildLayer, if necessary,
 47736:  * and we wouldn't want to accidentally recycle those.
 51947:  * The user data is a ThebesDisplayItemLayerUserData.
 42593:  */
108991: uint8_t gThebesDisplayItemLayerUserData;
 47745: /**
 47745:  * The address of gColorLayerUserData is used as the user
 51946:  * data key for ColorLayers created by FrameLayerBuilder.
 51946:  * The user data is null.
 47745:  */
108991: uint8_t gColorLayerUserData;
 51946: /**
 60712:  * The address of gImageLayerUserData is used as the user
 60712:  * data key for ImageLayers created by FrameLayerBuilder.
 60712:  * The user data is null.
 60712:  */
108991: uint8_t gImageLayerUserData;
 60712: /**
 51946:  * The address of gLayerManagerUserData is used as the user
 51946:  * data key for retained LayerManagers managed by FrameLayerBuilder.
 51946:  * The user data is a LayerManagerData.
 51946:  */
108991: uint8_t gLayerManagerUserData;
 97430: /**
 97430:  * The address of gMaskLayerUserData is used as the user
 97430:  * data key for mask layers managed by FrameLayerBuilder.
 97430:  * The user data is a MaskLayerUserData.
 97430:  */
108991: uint8_t gMaskLayerUserData;
 42593: 
 97433: /**
 97433:   * Helper functions for getting user data and casting it to the correct type.
 97433:   * aLayer is the layer where the user data is stored.
 97433:   */
 97433: MaskLayerUserData* GetMaskLayerUserData(Layer* aLayer)
 97433: {
 97433:   return static_cast<MaskLayerUserData*>(aLayer->GetUserData(&gMaskLayerUserData));
 97433: }
 97433: 
 97433: ThebesDisplayItemLayerUserData* GetThebesDisplayItemLayerUserData(Layer* aLayer)
 97433: {
 97433:   return static_cast<ThebesDisplayItemLayerUserData*>(
 97433:     aLayer->GetUserData(&gThebesDisplayItemLayerUserData));
 97433: }
 97433: 
 47736: } // anonymous namespace
 47736: 
102920: /* static */ void
102920: FrameLayerBuilder::Shutdown()
102920: {
102920:   if (gMaskLayerImageCache) {
102920:     delete gMaskLayerImageCache;
106838:     gMaskLayerImageCache = nullptr;
102920:   }
102920: }
102920: 
 54261: void
108884: FrameLayerBuilder::Init(nsDisplayListBuilder* aBuilder, LayerManager* aManager)
 54261: {
 54261:   mRootPresContext = aBuilder->ReferenceFrame()->PresContext()->GetRootPresContext();
 54261:   if (mRootPresContext) {
 54261:     mInitialDOMGeneration = mRootPresContext->GetDOMGeneration();
 54261:   }
108884:   aManager->SetUserData(&gLayerManagerLayerBuilder, new LayerManagerLayerBuilder(this));
 54261: }
 54261: 
 79445: bool
 70037: FrameLayerBuilder::DisplayItemDataEntry::HasNonEmptyContainerLayer()
 42593: {
103531:   if (mIsSharingContainerLayer)
103531:     return true;
108991:   for (uint32_t i = 0; i < mData.Length(); ++i) {
 70037:     if (mData[i].mLayer->GetType() == Layer::TYPE_CONTAINER &&
 70037:         mData[i].mLayerState != LAYER_ACTIVE_EMPTY)
 80486:       return true;
 47736:   }
 80486:   return false;
 42593: }
 42593: 
 82255: void
 82255: FrameLayerBuilder::FlashPaint(gfxContext *aContext)
 82255: {
 82255:   static bool sPaintFlashingEnabled;
 82255:   static bool sPaintFlashingPrefCached = false;
 82255: 
 82255:   if (!sPaintFlashingPrefCached) {
 82255:     sPaintFlashingPrefCached = true;
 82255:     mozilla::Preferences::AddBoolVarCache(&sPaintFlashingEnabled,
 82255:                                           "nglayout.debug.paint_flashing");
 82255:   }
 82255: 
 82255:   if (sPaintFlashingEnabled) {
 82255:     float r = float(rand()) / RAND_MAX;
 82255:     float g = float(rand()) / RAND_MAX;
 82255:     float b = float(rand()) / RAND_MAX;
 82255:     aContext->SetColor(gfxRGBA(r, g, b, 0.2));
 82255:     aContext->Paint();
 82255:   }
 82255: }
 82255: 
103530: /* static */ nsTArray<FrameLayerBuilder::DisplayItemData>*
 79931: FrameLayerBuilder::GetDisplayItemDataArrayForFrame(nsIFrame* aFrame)
 47736: {
103530:   FrameProperties props = aFrame->Properties();
103530:   LayerManagerData *data =
103530:     reinterpret_cast<LayerManagerData*>(props.Get(LayerManagerDataProperty()));
103530:   if (!data)
106838:     return nullptr;
103530: 
 79931:   DisplayItemDataEntry *entry = data->mFramesWithLayers.GetEntry(aFrame);
103530:   NS_ASSERTION(entry, "out of sync?");
 79931:   if (!entry)
106838:     return nullptr;
 42593: 
 79931:   return &entry->mData;
 42593: }
 42593: 
103295: /* static */ void
103295: FrameLayerBuilder::RemoveFrameFromLayerManager(nsIFrame* aFrame,
103295:                                                void* aPropertyValue)
103295: {
103295:   LayerManagerData *data = reinterpret_cast<LayerManagerData*>(aPropertyValue);
103530:   data->mFramesWithLayers.RemoveEntry(aFrame);
103530:   if (data->mFramesWithLayers.Count() == 0) {
103530:     data->mLayerManager->RemoveUserData(&gLayerManagerUserData);
103295:   }
103295: }
103295: 
103295: void
103295: FrameLayerBuilder::DidBeginRetainedLayerTransaction(LayerManager* aManager)
103295: {
103295:   mRetainingManager = aManager;
103295:   LayerManagerData* data = static_cast<LayerManagerData*>
103295:     (aManager->GetUserData(&gLayerManagerUserData));
103295:   if (data) {
103295:     mInvalidateAllLayers = data->mInvalidateAllLayers;
103295:   }
103295: }
103295: 
103295: /**
103295:  * A helper function to remove the mThebesLayerItems entries for every
103295:  * layer in aLayer's subtree.
103295:  */
103295: void
103295: FrameLayerBuilder::RemoveThebesItemsForLayerSubtree(Layer* aLayer)
103295: {
103295:   ThebesLayer* thebes = aLayer->AsThebesLayer();
103295:   if (thebes) {
103295:     mThebesLayerItems.RemoveEntry(thebes);
103295:     return;
103295:   }
103295: 
103295:   for (Layer* child = aLayer->GetFirstChild(); child;
103295:        child = child->GetNextSibling()) {
103295:     RemoveThebesItemsForLayerSubtree(child);
103295:   }
103295: }
103295: 
103295: void
103530: FrameLayerBuilder::DidEndTransaction(LayerManager* aManager)
103295: {
103530:   if (aManager != mRetainingManager) {
103530:     Layer* root = aManager->GetRoot();
103530:     if (root) {
103530:       RemoveThebesItemsForLayerSubtree(root);
103530:     }
103530:   }
103530: 
103295:   GetMaskLayerImageCache()->Sweep();
103295: }
103295: 
103295: void
103530: FrameLayerBuilder::WillEndTransaction(LayerManager* aManager)
103295: {
103530:   if (aManager != mRetainingManager)
103295:     return;
103295: 
103530:   // We need to save the data we'll need to support retaining. We do this
103530:   // before we paint so that invalidation triggered by painting will
103530:   // be able to update the ThebesLayerInvalidRegionProperty values
103530:   // correctly and the NS_FRAME_HAS_CONTAINER_LAYER bits will be set
103530:   // correctly.
103295:   LayerManagerData* data = static_cast<LayerManagerData*>
103295:     (mRetainingManager->GetUserData(&gLayerManagerUserData));
103523:   if (data) {
103295:     // Update all the frames that used to have layers.
103295:     data->mFramesWithLayers.EnumerateEntries(UpdateDisplayItemDataForFrame, this);
103523:   } else {
103530:     data = new LayerManagerData(mRetainingManager);
103523:     mRetainingManager->SetUserData(&gLayerManagerUserData, data);
103523:   }
103295:   // Now go through all the frames that didn't have any retained
103295:   // display items before, and record those retained display items.
103295:   // This also empties mNewDisplayItemData.
103295:   mNewDisplayItemData.EnumerateEntries(StoreNewDisplayItemData, data);
103295:   data->mInvalidateAllLayers = false;
103530: 
103530:   NS_ASSERTION(data->mFramesWithLayers.Count() > 0,
103530:                "Some frame must have a layer!");
103295: }
103295: 
103530: /**
103530:  * If *aThebesLayerInvalidRegion is non-null, use it as this frame's
103530:  * region property. Otherwise set it to the frame's region property.
103530:  */
103530: static void
104565: SetHasContainerLayer(nsIFrame* aFrame, nsPoint aOffsetToRoot)
103295: {
103530:   aFrame->AddStateBits(NS_FRAME_HAS_CONTAINER_LAYER);
103530:   for (nsIFrame* f = aFrame;
103530:        f && !(f->GetStateBits() & NS_FRAME_HAS_CONTAINER_LAYER_DESCENDANT);
103530:        f = nsLayoutUtils::GetCrossDocParentFrame(f)) {
103530:     f->AddStateBits(NS_FRAME_HAS_CONTAINER_LAYER_DESCENDANT);
103295:   }
103295: 
103530:   FrameProperties props = aFrame->Properties();
103530:   nsPoint* lastPaintOffset = static_cast<nsPoint*>
103530:     (props.Get(ThebesLayerLastPaintOffsetProperty()));
103530:   if (lastPaintOffset) {
103530:     *lastPaintOffset = aOffsetToRoot;
103530:   } else {
103530:     props.Set(ThebesLayerLastPaintOffsetProperty(), new nsPoint(aOffsetToRoot));
103530:   }
103530: }
103530: 
103530: static void
103530: SetNoContainerLayer(nsIFrame* aFrame)
103530: {
103530:   FrameProperties props = aFrame->Properties();
103530:   props.Delete(ThebesLayerInvalidRegionProperty());
103530:   props.Delete(ThebesLayerLastPaintOffsetProperty());
103530:   aFrame->RemoveStateBits(NS_FRAME_HAS_CONTAINER_LAYER);
103295: }
103295: 
104565: /* static */ void
104565: FrameLayerBuilder::SetAndClearInvalidRegion(DisplayItemDataEntry* aEntry)
104565: {
104565:   if (aEntry->mInvalidRegion) {
104565:     nsIFrame* f = aEntry->GetKey();
104565:     FrameProperties props = f->Properties();
104565: 
104565:     RefCountedRegion* invalidRegion;
104565:     aEntry->mInvalidRegion.forget(&invalidRegion);
104565: 
104565:     invalidRegion->mRegion.SetEmpty();
109155:     invalidRegion->mIsInfinite = false;
104565:     props.Set(ThebesLayerInvalidRegionProperty(), invalidRegion);
104565:   }
104565: }
104565: 
103295: /* static */ PLDHashOperator
103295: FrameLayerBuilder::UpdateDisplayItemDataForFrame(DisplayItemDataEntry* aEntry,
103295:                                                  void* aUserArg)
103295: {
103295:   FrameLayerBuilder* builder = static_cast<FrameLayerBuilder*>(aUserArg);
103295:   nsIFrame* f = aEntry->GetKey();
103523:   FrameProperties props = f->Properties();
103295:   DisplayItemDataEntry* newDisplayItems =
106838:     builder ? builder->mNewDisplayItemData.GetEntry(f) : nullptr;
109150:   if (!newDisplayItems || (newDisplayItems->mData.IsEmpty() &&
109281:                            !newDisplayItems->mIsSharingContainerLayer)) {
103295:     // This frame was visible, but isn't anymore.
106095:     if (newDisplayItems) {
106095:       builder->mNewDisplayItemData.RawRemoveEntry(newDisplayItems);
106095:     }
103530:     bool found;
103530:     props.Remove(LayerManagerDataProperty(), &found);
103530:     NS_ASSERTION(found, "How can the frame property be missing?");
103530:     SetNoContainerLayer(f);
103295:     return PL_DHASH_REMOVE;
103295:   }
103295: 
103530:   if (!newDisplayItems->HasNonEmptyContainerLayer()) {
103530:     SetNoContainerLayer(f);
103523:   }
103295: 
104565:   // Steal the list of display item layers and invalid region
103295:   aEntry->mData.SwapElements(newDisplayItems->mData);
104565:   aEntry->mInvalidRegion.swap(newDisplayItems->mInvalidRegion);
104565:   // Clear and reset the invalid region now so we can start collecting new
104565:   // dirty areas.
104565:   SetAndClearInvalidRegion(aEntry);
103295:   // Don't need to process this frame again
103295:   builder->mNewDisplayItemData.RawRemoveEntry(newDisplayItems);
103295:   return PL_DHASH_NEXT;
103295: }
103295: 
103295: /* static */ PLDHashOperator
103295: FrameLayerBuilder::StoreNewDisplayItemData(DisplayItemDataEntry* aEntry,
103295:                                            void* aUserArg)
103295: {
103295:   LayerManagerData* data = static_cast<LayerManagerData*>(aUserArg);
103295:   nsIFrame* f = aEntry->GetKey();
103523:   FrameProperties props = f->Properties();
104565: 
104565:   // Clear and reset the invalid region now so we can start collecting new
104565:   // dirty areas.
104565:   SetAndClearInvalidRegion(aEntry);
104565: 
103295:   // Remember that this frame has display items in retained layers
103295:   NS_ASSERTION(!data->mFramesWithLayers.GetEntry(f),
103295:                "We shouldn't get here if we're already in mFramesWithLayers");
103295:   DisplayItemDataEntry *newEntry = data->mFramesWithLayers.PutEntry(f);
103530:   NS_ASSERTION(!props.Get(LayerManagerDataProperty()),
103530:                "mFramesWithLayers out of sync");
103295: 
103295:   newEntry->mData.SwapElements(aEntry->mData);
103523:   props.Set(LayerManagerDataProperty(), data);
103295:   return PL_DHASH_REMOVE;
103295: }
103295: 
103530: bool
108991: FrameLayerBuilder::HasRetainedLayerFor(nsIFrame* aFrame, uint32_t aDisplayItemKey)
103295: {
103530:   nsTArray<DisplayItemData> *array = GetDisplayItemDataArrayForFrame(aFrame);
103530:   if (!array)
103530:     return false;
103295: 
108991:   for (uint32_t i = 0; i < array->Length(); ++i) {
103530:     if (array->ElementAt(i).mDisplayItemKey == aDisplayItemKey) {
103530:       Layer* layer = array->ElementAt(i).mLayer;
103295:       if (layer->Manager()->GetUserData(&gLayerManagerUserData)) {
103295:         // All layer managers with our user data are retained layer managers
103295:         return true;
103295:       }
103295:     }
103530:   }
103295:   return false;
103295: }
103295: 
103295: Layer*
110436: FrameLayerBuilder::GetOldLayerFor(nsIFrame* aFrame, uint32_t aDisplayItemKey)
103295: {
103295:   // If we need to build a new layer tree, then just refuse to recycle
103295:   // anything.
103295:   if (!mRetainingManager || mInvalidateAllLayers)
106838:     return nullptr;
103295: 
103295:   nsTArray<DisplayItemData> *array = GetDisplayItemDataArrayForFrame(aFrame);
103295:   if (!array)
106838:     return nullptr;
103295: 
108991:   for (uint32_t i = 0; i < array->Length(); ++i) {
103295:     if (array->ElementAt(i).mDisplayItemKey == aDisplayItemKey) {
103295:       Layer* layer = array->ElementAt(i).mLayer;
103530:       if (layer->Manager() == mRetainingManager)
103295:         return layer;
103295:     }
103295:   }
106838:   return nullptr;
103295: }
103295: 
105568: /* static */ Layer*
108991: FrameLayerBuilder::GetDebugOldLayerFor(nsIFrame* aFrame, uint32_t aDisplayItemKey)
105568: {
105568:   FrameProperties props = aFrame->Properties();
105568:   LayerManagerData* data = static_cast<LayerManagerData*>(props.Get(LayerManagerDataProperty()));
105568:   if (!data) {
106838:     return nullptr;
105568:   }
105568:   DisplayItemDataEntry *entry = data->mFramesWithLayers.GetEntry(aFrame);
105568:   if (!entry)
106838:     return nullptr;
105568: 
105568:   nsTArray<DisplayItemData> *array = &entry->mData;
105568:   if (!array)
106838:     return nullptr;
105568: 
108991:   for (uint32_t i = 0; i < array->Length(); ++i) {
105568:     if (array->ElementAt(i).mDisplayItemKey == aDisplayItemKey) {
105568:       return array->ElementAt(i).mLayer;
105568:     }
105568:   }
106838:   return nullptr;
105568: }
105568: 
103530: /**
103530:  * Invalidate aRegion in aLayer. aLayer is in the coordinate system
103530:  * *after* aTranslation has been applied, so we need to
103530:  * apply the inverse of that transform before calling InvalidateRegion.
103530:  */
103530: static void
103530: InvalidatePostTransformRegion(ThebesLayer* aLayer, const nsIntRegion& aRegion,
103530:                               const nsIntPoint& aTranslation)
103295: {
103530:   // Convert the region from the coordinates of the container layer
103530:   // (relative to the snapped top-left of the display list reference frame)
103530:   // to the ThebesLayer's own coordinates
103530:   nsIntRegion rgn = aRegion;
103530:   rgn.MoveBy(-aTranslation);
103530:   aLayer->InvalidateRegion(rgn);
 42593: }
 42593: 
 47745: already_AddRefed<ColorLayer>
108785: ContainerState::CreateOrRecycleColorLayer(ThebesLayer *aThebes)
 47745: {
108785:   ThebesDisplayItemLayerUserData* data = 
108785:       static_cast<ThebesDisplayItemLayerUserData*>(aThebes->GetUserData(&gThebesDisplayItemLayerUserData));
108785:   nsRefPtr<ColorLayer> layer = data->mColorLayer;
108785:   if (layer) {
106838:     layer->SetClipRect(nullptr);
106838:     layer->SetMaskLayer(nullptr);
 47745:   } else {
 47745:     // Create a new layer
 47745:     layer = mManager->CreateColorLayer();
 47745:     if (!layer)
106838:       return nullptr;
 47745:     // Mark this layer as being used for Thebes-painting display items
108785:     data->mColorLayer = layer;
106838:     layer->SetUserData(&gColorLayerUserData, nullptr);
108785:     
108785:     // Remove other layer types we might have stored for this ThebesLayer
108785:     data->mImageLayer = nullptr;
 47745:   }
 47745:   return layer.forget();
 47745: }
 47745: 
 60712: already_AddRefed<ImageLayer>
108785: ContainerState::CreateOrRecycleImageLayer(ThebesLayer *aThebes)
 60712: {
108785:   ThebesDisplayItemLayerUserData* data = 
108785:       static_cast<ThebesDisplayItemLayerUserData*>(aThebes->GetUserData(&gThebesDisplayItemLayerUserData));
108785:   nsRefPtr<ImageLayer> layer = data->mImageLayer;
108785:   if (layer) {
106838:     layer->SetClipRect(nullptr);
106838:     layer->SetMaskLayer(nullptr);
 60712:   } else {
 60712:     // Create a new layer
 60712:     layer = mManager->CreateImageLayer();
 60712:     if (!layer)
106838:       return nullptr;
 60712:     // Mark this layer as being used for Thebes-painting display items
108785:     data->mImageLayer = layer;
106838:     layer->SetUserData(&gImageLayerUserData, nullptr);
108785: 
108785:     // Remove other layer types we might have stored for this ThebesLayer
108785:     data->mColorLayer = nullptr;
 60712:   }
 60712:   return layer.forget();
 60712: }
 60712: 
 97431: already_AddRefed<ImageLayer>
 97431: ContainerState::CreateOrRecycleMaskImageLayerFor(Layer* aLayer)
 97431: {
 97431:   nsRefPtr<ImageLayer> result = mRecycledMaskImageLayers.Get(aLayer);
 97431:   if (result) {
 97431:     mRecycledMaskImageLayers.Remove(aLayer);
102919:     // XXX if we use clip on mask layers, null it out here
 97431:   } else {
 97431:     // Create a new layer
 97431:     result = mManager->CreateImageLayer();
 97431:     if (!result)
106838:       return nullptr;
 97431:     result->SetUserData(&gMaskLayerUserData, new MaskLayerUserData());
 99139:     result->SetForceSingleTile(true);
 97431:   }
 97431:   
 97431:   return result.forget();
 97431: }
 97431: 
 70022: static nsIntPoint
 70022: GetTranslationForThebesLayer(ThebesLayer* aLayer)
 70022: {
 70022:   gfxMatrix transform;
 87082:   if (!aLayer->GetTransform().Is2D(&transform) ||
 70022:       transform.HasNonIntegerTranslation()) {
 70022:     NS_ERROR("ThebesLayers should have integer translations only");
 70022:     return nsIntPoint(0, 0);
 70022:   }
108991:   return nsIntPoint(int32_t(transform.x0), int32_t(transform.y0));
 70022: }
 70022: 
 98202: static const double SUBPIXEL_OFFSET_EPSILON = 0.02;
 98202: 
107849: static bool
 98202: SubpixelOffsetFuzzyEqual(gfxPoint aV1, gfxPoint aV2)
 98202: {
 98202:   return fabs(aV2.x - aV1.x) < SUBPIXEL_OFFSET_EPSILON &&
 98202:          fabs(aV2.y - aV1.y) < SUBPIXEL_OFFSET_EPSILON;
 98202: }
 98202: 
 98202: /**
 98202:  * This normally computes NSToIntRoundUp(aValue). However, if that would
 98202:  * give a residual near 0.5 while aOldResidual is near -0.5, or
 98202:  * it would give a residual near -0.5 while aOldResidual is near 0.5, then
 98202:  * instead we return the integer in the other direction so that the residual
 98202:  * is close to aOldResidual.
 98202:  */
108991: static int32_t
 98202: RoundToMatchResidual(double aValue, double aOldResidual)
 98202: {
108991:   int32_t v = NSToIntRoundUp(aValue);
 98202:   double residual = aValue - v;
 98202:   if (aOldResidual < 0) {
 98202:     if (residual > 0 && fabs(residual - 1.0 - aOldResidual) < SUBPIXEL_OFFSET_EPSILON) {
 98202:       // Round up instead
108991:       return int32_t(ceil(aValue));
 98202:     }
 98202:   } else if (aOldResidual > 0) {
 98202:     if (residual < 0 && fabs(residual + 1.0 - aOldResidual) < SUBPIXEL_OFFSET_EPSILON) {
 98202:       // Round down instead
108991:       return int32_t(floor(aValue));
 98202:     }
 98202:   }
 98202:   return v;
 98191: }
 98191: 
 47736: already_AddRefed<ThebesLayer>
 47736: ContainerState::CreateOrRecycleThebesLayer(nsIFrame* aActiveScrolledRoot)
 47736: {
 47736:   // We need a new thebes layer
 47736:   nsRefPtr<ThebesLayer> layer;
 72231:   ThebesDisplayItemLayerUserData* data;
 47745:   if (mNextFreeRecycledThebesLayer < mRecycledThebesLayers.Length()) {
 47736:     // Recycle a layer
 47736:     layer = mRecycledThebesLayers[mNextFreeRecycledThebesLayer];
 47736:     ++mNextFreeRecycledThebesLayer;
 97431:     // Clear clip rect and mask layer so we don't accidentally stay clipped.
 97431:     // We will reapply any necessary clipping.
106838:     layer->SetClipRect(nullptr);
106838:     layer->SetMaskLayer(nullptr);
 47736: 
 72231:     data = static_cast<ThebesDisplayItemLayerUserData*>
 72231:         (layer->GetUserData(&gThebesDisplayItemLayerUserData));
 72231:     NS_ASSERTION(data, "Recycled ThebesLayers must have user data");
 72231: 
 47736:     // This gets called on recycled ThebesLayers that are going to be in the
 47736:     // final layer tree, so it's a convenient time to invalidate the
 47736:     // content that changed where we don't know what ThebesLayer it belonged
 47736:     // to, or if we need to invalidate the entire layer, we can do that.
 47736:     // This needs to be done before we update the ThebesLayer to its new
 47736:     // transform. See nsGfxScrollFrame::InvalidateInternal, where
 47736:     // we ensure that mInvalidThebesContent is updated according to the
 47736:     // scroll position as of the most recent paint.
103530:     if (mInvalidateAllThebesContent ||
103530:         data->mXScale != mParameters.mXScale ||
 72231:         data->mYScale != mParameters.mYScale) {
 47736:       nsIntRect invalidate = layer->GetValidRegion().GetBounds();
 47736:       layer->InvalidateRegion(invalidate);
103530:     } else {
103530:       InvalidatePostTransformRegion(layer, mInvalidThebesContent,
103530:                                     GetTranslationForThebesLayer(layer));
103295:     }
 47736:     // We do not need to Invalidate these areas in the widget because we
 62315:     // assume the caller of InvalidateThebesLayerContents has ensured
 47736:     // the area is invalidated in the widget.
 47736:   } else {
 47736:     // Create a new thebes layer
 47736:     layer = mManager->CreateThebesLayer();
 47736:     if (!layer)
106838:       return nullptr;
 47736:     // Mark this layer as being used for Thebes-painting display items
 72231:     data = new ThebesDisplayItemLayerUserData();
 72231:     layer->SetUserData(&gThebesDisplayItemLayerUserData, data);
 42593:   }
 72231:   data->mXScale = mParameters.mXScale;
 72231:   data->mYScale = mParameters.mYScale;
 95051:   layer->SetAllowResidualTranslation(mParameters.AllowResidualTranslation());
 42593: 
105568:   mLayerBuilder->SaveLastPaintOffset(layer);
 69962: 
 47736:   // Set up transform so that 0,0 in the Thebes layer corresponds to the
 47736:   // (pixel-snapped) top-left of the aActiveScrolledRoot.
 47736:   nsPoint offset = mBuilder->ToReferenceFrame(aActiveScrolledRoot);
 72247:   nscoord appUnitsPerDevPixel = aActiveScrolledRoot->PresContext()->AppUnitsPerDevPixel();
 72247:   gfxPoint scaledOffset(
 72247:       NSAppUnitsToDoublePixels(offset.x, appUnitsPerDevPixel)*mParameters.mXScale,
 72247:       NSAppUnitsToDoublePixels(offset.y, appUnitsPerDevPixel)*mParameters.mYScale);
 98202:   // We call RoundToMatchResidual here so that the residual after rounding
 98202:   // is close to data->mActiveScrolledRootPosition if possible.
 98202:   nsIntPoint pixOffset(RoundToMatchResidual(scaledOffset.x, data->mActiveScrolledRootPosition.x),
 98202:                        RoundToMatchResidual(scaledOffset.y, data->mActiveScrolledRootPosition.y));
 47736:   gfxMatrix matrix;
 47736:   matrix.Translate(gfxPoint(pixOffset.x, pixOffset.y));
106915:   layer->SetBaseTransform(gfx3DMatrix::From2D(matrix));
 47736: 
 93090:   // FIXME: Temporary workaround for bug 681192 and bug 724786.
 92870: #ifndef MOZ_JAVA_COMPOSITOR
 72247:   // Calculate exact position of the top-left of the active scrolled root.
 72247:   // This might not be 0,0 due to the snapping in ScaleToNearestPixels.
 72247:   gfxPoint activeScrolledRootTopLeft = scaledOffset - matrix.GetTranslation();
 72247:   // If it has changed, then we need to invalidate the entire layer since the
 72247:   // pixels in the layer buffer have the content at a (subpixel) offset
 72247:   // from what we need.
 98202:   if (!SubpixelOffsetFuzzyEqual(activeScrolledRootTopLeft, data->mActiveScrolledRootPosition)) {
 72247:     data->mActiveScrolledRootPosition = activeScrolledRootTopLeft;
 72247:     nsIntRect invalidate = layer->GetValidRegion().GetBounds();
 72247:     layer->InvalidateRegion(invalidate);
 72247:   }
 92829: #endif
 72247: 
 47736:   return layer.forget();
 42593: }
 42593: 
 47736: /**
 47736:  * Returns the appunits per dev pixel for the item's frame. The item must
 47736:  * have a frame because only nsDisplayClip items don't have a frame,
 47736:  * and those items are flattened away by ProcessDisplayItems.
 47736:  */
108991: static int32_t
 47736: AppUnitsPerDevPixel(nsDisplayItem* aItem)
 47736: {
 49158:   // The underlying frame for zoom items is the root frame of the subdocument.
 49158:   // But zoom display items report their bounds etc using the parent document's
 49158:   // APD because zoom items act as a conversion layer between the two different
 49158:   // APDs.
 49158:   if (aItem->GetType() == nsDisplayItem::TYPE_ZOOM) {
 49158:     return static_cast<nsDisplayZoom*>(aItem)->GetParentAppUnitsPerDevPixel();
 49158:   }
 47736:   return aItem->GetUnderlyingFrame()->PresContext()->AppUnitsPerDevPixel();
 42593: }
 42593: 
 47736: /**
 62985:  * Restrict the visible region of aLayer to the region that is actually visible.
 62985:  * Because we only reduce the visible region here, we don't need to worry
 62985:  * about whether CONTENT_OPAQUE is set; if layer was opauqe in the old
 62985:  * visible region, it will still be opaque in the new one.
 62985:  * @param aItemVisible the visible region of the display item (that is,
 62985:  * after any layer transform has been applied)
 47736:  */
 47736: static void
 62985: RestrictVisibleRegionForLayer(Layer* aLayer, const nsIntRect& aItemVisible)
 47736: {
 74753:   gfx3DMatrix transform = aLayer->GetTransform();
 62985: 
 42593:   // if 'transform' is not invertible, then nothing will be displayed
 42593:   // for the layer, so it doesn't really matter what we do here
 62985:   gfxRect itemVisible(aItemVisible.x, aItemVisible.y, aItemVisible.width, aItemVisible.height);
 74753:   gfxRect layerVisible = transform.Inverse().ProjectRectBounds(itemVisible);
 42593:   layerVisible.RoundOut();
 62985: 
 47736:   nsIntRect visibleRect;
 62985:   if (!gfxUtils::GfxRectToIntRect(layerVisible, &visibleRect))
 62985:     return;
 62985: 
 62985:   nsIntRegion rgn = aLayer->GetVisibleRegion();
 62985:   if (!visibleRect.Contains(rgn.GetBounds())) {
 62985:     rgn.And(rgn, visibleRect);
 62985:     aLayer->SetVisibleRegion(rgn);
 42593:   }
 42593: }
 42593: 
 51947: nscolor
108991: ContainerState::FindOpaqueBackgroundColorFor(int32_t aThebesLayerIndex)
 51947: {
 51947:   ThebesLayerData* target = mThebesLayerDataStack[aThebesLayerIndex];
108991:   for (int32_t i = aThebesLayerIndex - 1; i >= 0; --i) {
 51947:     ThebesLayerData* candidate = mThebesLayerDataStack[i];
 51947:     nsIntRegion visibleAboveIntersection;
 51947:     visibleAboveIntersection.And(candidate->mVisibleAboveRegion, target->mVisibleRegion);
 51947:     if (!visibleAboveIntersection.IsEmpty()) {
 51947:       // Some non-Thebes content between target and candidate; this is
 51947:       // hopeless
 51947:       break;
 51947:     }
 51947: 
 51947:     nsIntRegion intersection;
 51947:     intersection.And(candidate->mVisibleRegion, target->mVisibleRegion);
 51947:     if (intersection.IsEmpty()) {
 51947:       // The layer doesn't intersect our target, ignore it and move on
 51947:       continue;
 51947:     }
 51947: 
 51947:     // The candidate intersects our target. If any layer has a solid-color
 51947:     // area behind our target, this must be it. Scan its display items.
 51947:     nsRect rect =
 95051:       target->mVisibleRegion.GetBounds().ToAppUnits(mAppUnitsPerDevPixel);
 72231:     rect.ScaleInverseRoundOut(mParameters.mXScale, mParameters.mYScale);
105568:     return mLayerBuilder->
 51947:       FindOpaqueColorCovering(mBuilder, candidate->mLayer, rect);
 51947:   }
 51947:   return NS_RGBA(0,0,0,0);
 51947: }
 51947: 
 97433: void
 97433: ContainerState::ThebesLayerData::UpdateCommonClipCount(
 97433:     const FrameLayerBuilder::Clip& aCurrentClip)
 97433: {
 97433:   if (mCommonClipCount >= 0) {
108991:     int32_t end = NS_MIN<int32_t>(aCurrentClip.mRoundedClipRects.Length(),
 97433:                                   mCommonClipCount);
108991:     int32_t clipCount = 0;
 97433:     for (; clipCount < end; ++clipCount) {
 97433:       if (mItemClip.mRoundedClipRects[clipCount] !=
 97433:           aCurrentClip.mRoundedClipRects[clipCount]) {
 97433:         break;
 97433:       }
 97433:     }
 97433:     mCommonClipCount = clipCount;
108991:     NS_ASSERTION(mItemClip.mRoundedClipRects.Length() >= uint32_t(mCommonClipCount),
 97433:                  "Inconsistent common clip count.");
 97433:   } else {
 97433:     // first item in the layer
 97433:     mCommonClipCount = aCurrentClip.mRoundedClipRects.Length();
 97433:   }
 97433: }
 97433: 
 88529: already_AddRefed<ImageContainer>
 89204: ContainerState::ThebesLayerData::CanOptimizeImageLayer()
 60712: {
 97433:   if (!mImage) {
106838:     return nullptr;
 60712:   }
 60712: 
 89204:   return mImage->GetContainer();
 60712: }
 60712: 
 47736: void
 47736: ContainerState::PopThebesLayerData()
 47736: {
 47736:   NS_ASSERTION(!mThebesLayerDataStack.IsEmpty(), "Can't pop");
 47736: 
108991:   int32_t lastIndex = mThebesLayerDataStack.Length() - 1;
 47736:   ThebesLayerData* data = mThebesLayerDataStack[lastIndex];
 47736: 
 60712:   nsRefPtr<Layer> layer;
 89204:   nsRefPtr<ImageContainer> imageContainer = data->CanOptimizeImageLayer();
 60712: 
 90237:   if ((data->mIsSolidColorInVisibleRegion || imageContainer) &&
 90237:       data->mLayer->GetValidRegion().IsEmpty()) {
 60712:     NS_ASSERTION(!(data->mIsSolidColorInVisibleRegion && imageContainer),
 60712:                  "Can't be a solid color as well as an image!");
 60712:     if (imageContainer) {
108785:       nsRefPtr<ImageLayer> imageLayer = CreateOrRecycleImageLayer(data->mLayer);
 60712:       imageLayer->SetContainer(imageContainer);
 60712:       data->mImage->ConfigureLayer(imageLayer);
107388:       imageLayer->SetPostScale(mParameters.mXScale,
107388:                                mParameters.mYScale);
 97433:       if (data->mItemClip.mHaveClipRect) {
 97433:         nsIntRect clip = ScaleToNearestPixels(data->mItemClip.mClipRect);
 72231:         imageLayer->IntersectClipRect(clip);
 64533:       }
 60712:       layer = imageLayer;
 60712:     } else {
108785:       nsRefPtr<ColorLayer> colorLayer = CreateOrRecycleColorLayer(data->mLayer);
 67668:       colorLayer->SetIsFixedPosition(data->mLayer->GetIsFixedPosition());
 47745:       colorLayer->SetColor(data->mSolidColor);
 47745: 
106839:       // Copy transform
106915:       colorLayer->SetBaseTransform(data->mLayer->GetBaseTransform());
107388:       colorLayer->SetPostScale(data->mLayer->GetPostXScale(), data->mLayer->GetPostYScale());
 47745: 
 47745:       // Clip colorLayer to its visible region, since ColorLayers are
 47745:       // allowed to paint outside the visible region. Here we rely on the
 47745:       // fact that uniform display items fill rectangles; obviously the
 47745:       // area to fill must contain the visible region, and because it's
 47745:       // a rectangle, it must therefore contain the visible region's GetBounds.
 47745:       // Note that the visible region is already clipped appropriately.
 47745:       nsIntRect visibleRect = data->mVisibleRegion.GetBounds();
 47745:       colorLayer->SetClipRect(&visibleRect);
 47745: 
 60712:       layer = colorLayer;
 60712:     }
 60712: 
 60712:     NS_ASSERTION(!mNewChildLayers.Contains(layer), "Layer already in list???");
 60712:     AutoLayersArray::index_type index = mNewChildLayers.IndexOf(data->mLayer);
 60712:     NS_ASSERTION(index != AutoLayersArray::NoIndex, "Thebes layer not found?");
 60712:     mNewChildLayers.InsertElementAt(index + 1, layer);
 60712: 
 47745:     // Hide the ThebesLayer. We leave it in the layer tree so that we
 47745:     // can find and recycle it later.
 47745:     data->mLayer->IntersectClipRect(nsIntRect());
 47745:     data->mLayer->SetVisibleRegion(nsIntRegion());
 47745:   } else {
 47745:     layer = data->mLayer;
106838:     imageContainer = nullptr;
 47745:   }
 47745: 
 47736:   gfxMatrix transform;
 60712:   if (!layer->GetTransform().Is2D(&transform)) {
 60712:     NS_ERROR("Only 2D transformations currently supported");
 60712:   }
 60712: 
 60712:   // ImageLayers are already configured with a visible region
 60712:   if (!imageContainer) {
 47736:     NS_ASSERTION(!transform.HasNonIntegerTranslation(),
 47736:                  "Matrix not just an integer translation?");
 47736:     // Convert from relative to the container to relative to the
 47736:     // ThebesLayer itself.
 47736:     nsIntRegion rgn = data->mVisibleRegion;
108991:     rgn.MoveBy(-nsIntPoint(int32_t(transform.x0), int32_t(transform.y0)));
 47745:     layer->SetVisibleRegion(rgn);
 47736:   }
 47736: 
 47736:   nsIntRegion transparentRegion;
 47736:   transparentRegion.Sub(data->mVisibleRegion, data->mOpaqueRegion);
 79445:   bool isOpaque = transparentRegion.IsEmpty();
 51947:   // For translucent ThebesLayers, try to find an opaque background
 51947:   // color that covers the entire area beneath it so we can pull that
 51947:   // color into this layer to make it opaque.
 51947:   if (layer == data->mLayer) {
 51947:     nscolor backgroundColor = NS_RGBA(0,0,0,0);
 51947:     if (!isOpaque) {
 51947:       backgroundColor = FindOpaqueBackgroundColorFor(lastIndex);
 51947:       if (NS_GET_A(backgroundColor) == 255) {
 80486:         isOpaque = true;
 51947:       }
 51947:     }
 51947: 
 51947:     // Store the background color
 51947:     ThebesDisplayItemLayerUserData* userData =
 97433:       GetThebesDisplayItemLayerUserData(data->mLayer);
 51947:     NS_ASSERTION(userData, "where did our user data go?");
 51947:     if (userData->mForcedBackgroundColor != backgroundColor) {
 51947:       // Invalidate the entire target ThebesLayer since we're changing
 51947:       // the background color
 51947:       data->mLayer->InvalidateRegion(data->mLayer->GetValidRegion());
 51947:     }
 51947:     userData->mForcedBackgroundColor = backgroundColor;
 97433: 
 97433:     // use a mask layer for rounded rect clipping
108991:     int32_t commonClipCount = data->mCommonClipCount;
 97433:     NS_ASSERTION(commonClipCount >= 0, "Inconsistent clip count.");
 97433:     SetupMaskLayer(layer, data->mItemClip, commonClipCount);
 97433:     // copy commonClipCount to the entry
105568:     FrameLayerBuilder::ThebesLayerItemsEntry* entry = mLayerBuilder->
 97433:       GetThebesLayerItemsEntry(static_cast<ThebesLayer*>(layer.get()));
 97433:     entry->mCommonClipCount = commonClipCount;
 97433:   } else {
 97433:     // mask layer for image and color layers
 97433:     SetupMaskLayer(layer, data->mItemClip);
 51947:   }
108991:   uint32_t flags;
 59482:   if (isOpaque && !data->mForceTransparentSurface) {
 59482:     flags = Layer::CONTENT_OPAQUE;
 59482:   } else if (data->mNeedComponentAlpha) {
 59482:     flags = Layer::CONTENT_COMPONENT_ALPHA;
 59482:   } else {
 59482:     flags = 0;
 59482:   }
 51950:   layer->SetContentFlags(flags);
 51947: 
 51947:   if (lastIndex > 0) {
 51947:     // Since we're going to pop off the last ThebesLayerData, the
 51947:     // mVisibleAboveRegion of the second-to-last item will need to include
 51947:     // the regions of the last item.
 51947:     ThebesLayerData* nextData = mThebesLayerDataStack[lastIndex - 1];
 51947:     nextData->mVisibleAboveRegion.Or(nextData->mVisibleAboveRegion,
 51947:                                      data->mVisibleAboveRegion);
 51947:     nextData->mVisibleAboveRegion.Or(nextData->mVisibleAboveRegion,
 51947:                                      data->mVisibleRegion);
 87083:     nextData->mVisibleAboveRegion.SimplifyOutward(4);
 51947:     nextData->mDrawAboveRegion.Or(nextData->mDrawAboveRegion,
 51947:                                      data->mDrawAboveRegion);
 51947:     nextData->mDrawAboveRegion.Or(nextData->mDrawAboveRegion,
 51947:                                      data->mDrawRegion);
 87083:     nextData->mDrawAboveRegion.SimplifyOutward(4);
 51947:   }
 47736: 
 47736:   mThebesLayerDataStack.RemoveElementAt(lastIndex);
 47736: }
 47736: 
 79445: static bool
 59778: SuppressComponentAlpha(nsDisplayListBuilder* aBuilder,
 59781:                        nsDisplayItem* aItem,
 59781:                        const nsRect& aComponentAlphaBounds)
 59778: {
 59778:   const nsRegion* windowTransparentRegion = aBuilder->GetFinalTransparentRegion();
 59778:   if (!windowTransparentRegion || windowTransparentRegion->IsEmpty())
 80486:     return false;
 59778: 
 59778:   // Suppress component alpha for items in the toplevel window that are over
 59778:   // the window translucent area
 59778:   nsIFrame* f = aItem->GetUnderlyingFrame();
 59778:   nsIFrame* ref = aBuilder->ReferenceFrame();
 59778:   if (f->PresContext() != ref->PresContext())
 80486:     return false;
 59778: 
 59778:   for (nsIFrame* t = f; t; t = t->GetParent()) {
 59778:     if (t->IsTransformed())
 80486:       return false;
 59778:   }
 59778: 
 59781:   return windowTransparentRegion->Intersects(aComponentAlphaBounds);
 59778: }
 59778: 
 79445: static bool
 59782: WindowHasTransparency(nsDisplayListBuilder* aBuilder)
 59782: {
 59782:   const nsRegion* windowTransparentRegion = aBuilder->GetFinalTransparentRegion();
 59782:   return windowTransparentRegion && !windowTransparentRegion->IsEmpty();
 59782: }
 59782: 
 47736: void
 72231: ContainerState::ThebesLayerData::Accumulate(ContainerState* aState,
 51949:                                             nsDisplayItem* aItem,
 51949:                                             const nsIntRect& aVisibleRect,
 59779:                                             const nsIntRect& aDrawRect,
 59779:                                             const FrameLayerBuilder::Clip& aClip)
 47736: {
 97420:   if (aState->mBuilder->NeedToForceTransparentSurfaceForItem(aItem)) {
 97420:     mForceTransparentSurface = true;
 97420:   }
 97421:   if (aState->mParameters.mDisableSubpixelAntialiasingInDescendants) {
 97421:     // Disable component alpha.
 97421:     // Note that the transform (if any) on the ThebesLayer is always an integer translation so
 97421:     // we don't have to factor that in here.
 97421:     aItem->DisableComponentAlpha();
 97421:   }
 80876: 
 80876:   /* Mark as available for conversion to image layer if this is a nsDisplayImage and
 80876:    * we are the first visible item in the ThebesLayerData object.
 80876:    */
 95567:   if (mVisibleRegion.IsEmpty() && aItem->GetType() == nsDisplayItem::TYPE_IMAGE) {
 80876:     mImage = static_cast<nsDisplayImage*>(aItem);
 80876:   } else {
106838:     mImage = nullptr;
 80876:   }
 97433:   mItemClip = aClip;
 80876: 
 97421:   if (!mIsSolidColorInVisibleRegion && mOpaqueRegion.Contains(aDrawRect) &&
 97421:       mVisibleRegion.Contains(aVisibleRect)) {
 97421:     // A very common case! Most pages have a ThebesLayer with the page
 97421:     // background (opaque) visible and most or all of the page content over the
 97421:     // top of that background.
 97421:     // The rest of this method won't do anything. mVisibleRegion, mOpaqueRegion
 97421:     // and mDrawRegion don't need updating. mVisibleRegion contains aVisibleRect
 97421:     // already, mOpaqueRegion contains aDrawRect and therefore whatever
 97421:     // the opaque region of the item is. mDrawRegion must contain mOpaqueRegion
 97421:     // and therefore aDrawRect.
 97421:     NS_ASSERTION(mDrawRegion.Contains(aDrawRect), "Draw region not covered");
 97421:     return;
 97421:   }
 97421: 
 97421:   nscolor uniformColor;
 97421:   bool isUniform = aItem->IsUniform(aState->mBuilder, &uniformColor);
 97421: 
 60675:   // Some display items have to exist (so they can set forceTransparentSurface
 60675:   // below) but don't draw anything. They'll return true for isUniform but
 60675:   // a color with opacity 0.
 60675:   if (!isUniform || NS_GET_A(uniformColor) > 0) {
 95051:     // Make sure that the visible area is covered by uniform pixels. In
 95051:     // particular this excludes cases where the edges of the item are not
 95051:     // pixel-aligned (thus the item will not be truly uniform).
 95051:     if (isUniform) {
 95051:       bool snap;
 95051:       nsRect bounds = aItem->GetBounds(aState->mBuilder, &snap);
 95051:       if (!aState->ScaleToInsidePixels(bounds, snap).Contains(aVisibleRect)) {
 95051:         isUniform = false;
 95051:       }
 95051:     }
 97087:     if (isUniform && aClip.mRoundedClipRects.IsEmpty()) {
 47745:       if (mVisibleRegion.IsEmpty()) {
 47745:         // This color is all we have
 51949:         mSolidColor = uniformColor;
 80486:         mIsSolidColorInVisibleRegion = true;
 47745:       } else if (mIsSolidColorInVisibleRegion &&
 48689:                  mVisibleRegion.IsEqual(nsIntRegion(aVisibleRect))) {
 47745:         // we can just blend the colors together
 51949:         mSolidColor = NS_ComposeColors(mSolidColor, uniformColor);
 47745:       } else {
 80486:         mIsSolidColorInVisibleRegion = false;
 47745:       }
 47745:     } else {
 80486:       mIsSolidColorInVisibleRegion = false;
 47745:     }
 47745: 
 48689:     mVisibleRegion.Or(mVisibleRegion, aVisibleRect);
 47736:     mVisibleRegion.SimplifyOutward(4);
 48689:     mDrawRegion.Or(mDrawRegion, aDrawRect);
 48689:     mDrawRegion.SimplifyOutward(4);
 60675:   }
 51949:   
 95051:   bool snap;
 97420:   nsRegion opaque = aItem->GetOpaqueRegion(aState->mBuilder, &snap);
 59779:   if (!opaque.IsEmpty()) {
106093:     nsRegion opaqueClipped;
 59779:     nsRegionRectIterator iter(opaque);
 59779:     for (const nsRect* r = iter.Next(); r; r = iter.Next()) {
106093:       opaqueClipped.Or(opaqueClipped, aClip.ApproximateIntersect(*r));
106093:     }
106093: 
106093:     nsIntRegion opaquePixels = aState->ScaleRegionToInsidePixels(opaqueClipped, snap);
106093: 
106093:     nsIntRegionRectIterator iter2(opaquePixels);
106093:     for (const nsIntRect* r = iter2.Next(); r; r = iter2.Next()) {
 47772:       // We don't use SimplifyInward here since it's not defined exactly
 47772:       // what it will discard. For our purposes the most important case
 47772:       // is a large opaque background at the bottom of z-order (e.g.,
 47772:       // a canvas background), so we need to make sure that the first rect
 47772:       // we see doesn't get discarded.
 47772:       nsIntRegion tmp;
106093:       tmp.Or(mOpaqueRegion, *r);
 59782:        // Opaque display items in chrome documents whose window is partially
 59782:        // transparent are always added to the opaque region. This helps ensure
 59782:        // that we get as much subpixel-AA as possible in the chrome.
 59782:        if (tmp.GetNumRects() <= 4 ||
 72231:            (WindowHasTransparency(aState->mBuilder) &&
 59782:             aItem->GetUnderlyingFrame()->PresContext()->IsChrome())) {
 47772:         mOpaqueRegion = tmp;
 47772:       }
 59779:     }
 59779:   }
 97421: 
 97421:   if (!aState->mParameters.mDisableSubpixelAntialiasingInDescendants) {
 72231:     nsRect componentAlpha = aItem->GetComponentAlphaBounds(aState->mBuilder);
 59781:     if (!componentAlpha.IsEmpty()) {
 95051:       nsIntRect componentAlphaRect =
 95051:         aState->ScaleToOutsidePixels(componentAlpha, false).Intersect(aVisibleRect);
 95051:       if (!mOpaqueRegion.Contains(componentAlphaRect)) {
 72231:         if (SuppressComponentAlpha(aState->mBuilder, aItem, componentAlpha)) {
 59778:           aItem->DisableComponentAlpha();
 59778:         } else {
 80486:           mNeedComponentAlpha = true;
 51951:         }
 47736:       }
 59778:     }
 87082:   }
 47736: }
 47736: 
 97433: ContainerState::ThebesLayerData*
 51949: ContainerState::FindThebesLayerFor(nsDisplayItem* aItem,
 51949:                                    const nsIntRect& aVisibleRect,
 48689:                                    const nsIntRect& aDrawRect,
 59779:                                    const FrameLayerBuilder::Clip& aClip,
 51949:                                    nsIFrame* aActiveScrolledRoot)
 47736: {
108991:   int32_t i;
108991:   int32_t lowestUsableLayerWithScrolledRoot = -1;
108991:   int32_t topmostLayerWithScrolledRoot = -1;
 47736:   for (i = mThebesLayerDataStack.Length() - 1; i >= 0; --i) {
 47736:     ThebesLayerData* data = mThebesLayerDataStack[i];
 48689:     if (data->mDrawAboveRegion.Intersects(aVisibleRect)) {
 47736:       ++i;
 47736:       break;
 47736:     }
 47736:     if (data->mActiveScrolledRoot == aActiveScrolledRoot) {
 47736:       lowestUsableLayerWithScrolledRoot = i;
 47736:       if (topmostLayerWithScrolledRoot < 0) {
 47736:         topmostLayerWithScrolledRoot = i;
 47736:       }
 47736:     }
 48689:     if (data->mDrawRegion.Intersects(aVisibleRect))
 47736:       break;
 47736:   }
 47736:   if (topmostLayerWithScrolledRoot < 0) {
 47736:     --i;
 47736:     for (; i >= 0; --i) {
 47736:       ThebesLayerData* data = mThebesLayerDataStack[i];
 47736:       if (data->mActiveScrolledRoot == aActiveScrolledRoot) {
 47736:         topmostLayerWithScrolledRoot = i;
 47736:         break;
 47736:       }
 47736:     }
 47736:   }
 47736: 
 47736:   if (topmostLayerWithScrolledRoot >= 0) {
108991:     while (uint32_t(topmostLayerWithScrolledRoot + 1) < mThebesLayerDataStack.Length()) {
 47736:       PopThebesLayerData();
 47736:     }
 47736:   }
 47736: 
 47736:   nsRefPtr<ThebesLayer> layer;
106838:   ThebesLayerData* thebesLayerData = nullptr;
 47736:   if (lowestUsableLayerWithScrolledRoot < 0) {
 47736:     layer = CreateOrRecycleThebesLayer(aActiveScrolledRoot);
 47745: 
 47745:     NS_ASSERTION(!mNewChildLayers.Contains(layer), "Layer already in list???");
 47745:     mNewChildLayers.AppendElement(layer);
 47745: 
 47736:     thebesLayerData = new ThebesLayerData();
 47736:     mThebesLayerDataStack.AppendElement(thebesLayerData);
 47736:     thebesLayerData->mLayer = layer;
 47736:     thebesLayerData->mActiveScrolledRoot = aActiveScrolledRoot;
 47736:   } else {
 47736:     thebesLayerData = mThebesLayerDataStack[lowestUsableLayerWithScrolledRoot];
 47736:     layer = thebesLayerData->mLayer;
 47736:   }
 47736: 
 72231:   thebesLayerData->Accumulate(this, aItem, aVisibleRect, aDrawRect, aClip);
 97433: 
 97433:   return thebesLayerData;
 47736: }
 47736: 
 93035: #ifdef MOZ_DUMP_PAINTING
 93035: static void
 93035: DumpPaintedImage(nsDisplayItem* aItem, gfxASurface* aSurf)
 93035: {
 93035:   nsCString string(aItem->Name());
 93035:   string.Append("-");
108991:   string.AppendInt((uint64_t)aItem);
 93035:   fprintf(gfxUtils::sDumpPaintFile, "array[\"%s\"]=\"", string.BeginReading());
 93035:   aSurf->DumpAsDataURL(gfxUtils::sDumpPaintFile);
 93035:   fprintf(gfxUtils::sDumpPaintFile, "\";");
 93035: }
 93035: #endif
 93035: 
 62293: static void
 62293: PaintInactiveLayer(nsDisplayListBuilder* aBuilder,
 62293:                    nsDisplayItem* aItem,
105566:                    gfxContext* aContext,
105568:                    nsRenderingContext* aCtx,
105568:                    FrameLayerBuilder *aLayerBuilder)
 48765: {
 62293:   // This item has an inactive layer. Render it to a ThebesLayer
 62293:   // using a temporary BasicLayerManager.
108991:   int32_t appUnitsPerDevPixel = AppUnitsPerDevPixel(aItem);
 93035:   nsIntRect itemVisibleRect =
 93035:     aItem->GetVisibleRect().ToOutsidePixels(appUnitsPerDevPixel);
 93035: 
103530:   nsRefPtr<gfxContext> context = aContext;
103530: #ifdef MOZ_DUMP_PAINTING
 93035:   nsRefPtr<gfxASurface> surf;
 93035:   if (gfxUtils::sDumpPainting) {
 93035:     surf = gfxPlatform::GetPlatform()->CreateOffscreenSurface(itemVisibleRect.Size(),
 93035:                                                               gfxASurface::CONTENT_COLOR_ALPHA);
 93035:     surf->SetDeviceOffset(-itemVisibleRect.TopLeft());
 93035:     context = new gfxContext(surf);
 93035:   }
 93035: #endif
 93035: 
103530:   nsRefPtr<BasicLayerManager> tempManager = new BasicLayerManager();
105568:   tempManager->SetUserData(&gLayerManagerLayerBuilder, new LayerManagerLayerBuilder(aLayerBuilder, false));
103530:   tempManager->BeginTransactionWithTarget(context);
103530:   nsRefPtr<Layer> layer =
103530:     aItem->BuildLayer(aBuilder, tempManager, FrameLayerBuilder::ContainerParameters());
103530:   if (!layer) {
106838:     tempManager->EndTransaction(nullptr, nullptr);
103530:     return;
103530:   }
103530:   RestrictVisibleRegionForLayer(layer, itemVisibleRect);
103530:   
103530:   tempManager->SetRoot(layer);
105568:   aLayerBuilder->WillEndTransaction(tempManager);
105566:   if (aItem->GetType() == nsDisplayItem::TYPE_SVG_EFFECTS) {
105566:     static_cast<nsDisplaySVGEffects*>(aItem)->PaintAsLayer(aBuilder, aCtx, tempManager);
105881:     if (tempManager->InTransaction()) {
105881:       tempManager->AbortTransaction();
105881:     }
105566:   } else {
103530:     tempManager->EndTransaction(FrameLayerBuilder::DrawThebesLayer, aBuilder);
105566:   }
105568:   aLayerBuilder->DidEndTransaction(tempManager);
 48765:  
 93035: #ifdef MOZ_DUMP_PAINTING
 93035:   if (gfxUtils::sDumpPainting) {
 93035:     DumpPaintedImage(aItem, surf);
 93035: 
 93035:     surf->SetDeviceOffset(gfxPoint(0, 0));
 93035:     aContext->SetSource(surf, itemVisibleRect.TopLeft());
 93035:     aContext->Rectangle(itemVisibleRect);
 93035:     aContext->Fill();
 93035:     aItem->SetPainted();
 93035:   }
 93035: #endif
 48765: }
 48765: 
 47736: /*
 47736:  * Iterate through the non-clip items in aList and its descendants.
 47736:  * For each item we compute the effective clip rect. Each item is assigned
 47736:  * to a layer. We invalidate the areas in ThebesLayers where an item
 47736:  * has moved from one ThebesLayer to another. Also,
 47736:  * aState->mInvalidThebesContent is invalidated in every ThebesLayer.
 97433:  * We set the clip rect for items that generated their own layer, and
 97433:  * create a mask layer to do any rounded rect clipping.
 47736:  * (ThebesLayers don't need a clip rect on the layer, we clip the items
 47736:  * individually when we draw them.)
 47736:  * We set the visible rect for all layers, although the actual setting
 47736:  * of visible rects for some ThebesLayers is deferred until the calling
 47736:  * of ContainerState::Finish.
 47736:  */
 47736: void
 47736: ContainerState::ProcessDisplayItems(const nsDisplayList& aList,
106095:                                     FrameLayerBuilder::Clip& aClip,
108991:                                     uint32_t aFlags)
 47736: {
 96794:   SAMPLE_LABEL("ContainerState", "ProcessDisplayItems");
 47736:   for (nsDisplayItem* item = aList.GetBottom(); item; item = item->GetAbove()) {
 52292:     nsDisplayItem::Type type = item->GetType();
 52292:     if (type == nsDisplayItem::TYPE_CLIP ||
 52292:         type == nsDisplayItem::TYPE_CLIP_ROUNDED_RECT) {
 52292:       FrameLayerBuilder::Clip childClip(aClip, item);
106095:       ProcessDisplayItems(*item->GetList(), childClip, aFlags);
 47736:       continue;
 47736:     }
 47736: 
 95051:     NS_ASSERTION(mAppUnitsPerDevPixel == AppUnitsPerDevPixel(item),
 49164:       "items in a container layer should all have the same app units per dev pixel");
 49164: 
 80868:     nsIntRect itemVisibleRect =
 95051:       ScaleToOutsidePixels(item->GetVisibleRect(), false);
 95051:     bool snap;
 95051:     nsRect itemContent = item->GetBounds(mBuilder, &snap);
 95347:     nsIntRect itemDrawRect = ScaleToOutsidePixels(itemContent, snap);
 52292:     if (aClip.mHaveClipRect) {
 95347:       itemContent.IntersectRect(itemContent, aClip.mClipRect);
 95347:       nsIntRect clipRect = ScaleToNearestPixels(aClip.mClipRect);
 95347:       itemDrawRect.IntersectRect(itemDrawRect, clipRect);
 48689:     }
 62985:     mBounds.UnionRect(mBounds, itemContent);
 95051:     itemVisibleRect.IntersectRect(itemVisibleRect, itemDrawRect);
 95051: 
 97534:     LayerState layerState = item->GetLayerState(mBuilder, mManager, mParameters);
 47751: 
106095:     nsIFrame* activeScrolledRoot;
106095:     bool forceInactive = false;
106095:     if (aFlags & NO_COMPONENT_ALPHA) {
106095:       activeScrolledRoot =
106095:         nsLayoutUtils::GetActiveScrolledRootFor(mContainerFrame,
106095:                                                 mBuilder->ReferenceFrame());
106095:       forceInactive = true;
106095:     } else {
106095:       activeScrolledRoot = nsLayoutUtils::GetActiveScrolledRootFor(item, mBuilder);
106095:     }
 67668: 
 47751:     // Assign the item to a layer
 63413:     if (layerState == LAYER_ACTIVE_FORCE ||
106095:         (!forceInactive &&
106095:          (layerState == LAYER_ACTIVE_EMPTY ||
106095:           layerState == LAYER_ACTIVE))) {
 68445: 
 68445:       // LAYER_ACTIVE_EMPTY means the layer is created just for its metadata.
 68445:       // We should never see an empty layer with any visible content!
 68445:       NS_ASSERTION(layerState != LAYER_ACTIVE_EMPTY ||
 80868:                    itemVisibleRect.IsEmpty(),
 68445:                    "State is LAYER_ACTIVE_EMPTY but visible rect is not.");
 68445: 
 47763:       // If the item would have its own layer but is invisible, just hide it.
 47763:       // Note that items without their own layers can't be skipped this
 47763:       // way, since their ThebesLayer may decide it wants to draw them
 47763:       // into its buffer even if they're currently covered.
 80868:       if (itemVisibleRect.IsEmpty() && layerState != LAYER_ACTIVE_EMPTY) {
106838:         InvalidateForLayerChange(item, nullptr);
 47763:         continue;
 47763:       }
 47763: 
 47751:       // Just use its layer.
 72231:       nsRefPtr<Layer> ownLayer = item->BuildLayer(mBuilder, mManager, mParameters);
 47751:       if (!ownLayer) {
103513:         InvalidateForLayerChange(item, ownLayer);
 47751:         continue;
 47751:       }
 47751: 
 72231:       // If it's not a ContainerLayer, we need to apply the scale transform
 72231:       // ourselves.
 72231:       if (!ownLayer->AsContainerLayer()) {
107388:         ownLayer->SetPostScale(mParameters.mXScale,
107388:                                mParameters.mYScale);
 72231:       }
 72231: 
 99197:       ownLayer->SetIsFixedPosition(
 99197:         !nsLayoutUtils::IsScrolledByRootContentDocumentDisplayportScrolling(
 67668:                                       activeScrolledRoot, mBuilder));
 67668: 
 47751:       // Update that layer's clip and visible rects.
 47736:       NS_ASSERTION(ownLayer->Manager() == mManager, "Wrong manager");
 51946:       NS_ASSERTION(!ownLayer->HasUserData(&gLayerManagerUserData),
 47736:                    "We shouldn't have a FrameLayerBuilder-managed layer here!");
 87747:       NS_ASSERTION(aClip.mHaveClipRect ||
 87747:                      aClip.mRoundedClipRects.IsEmpty(),
 87747:                    "If we have rounded rects, we must have a clip rect");
 47736:       // It has its own layer. Update that layer's clip and visible rects.
 52292:       if (aClip.mHaveClipRect) {
 47736:         ownLayer->IntersectClipRect(
 95051:           ScaleToNearestPixels(aClip.NonRoundedIntersection()));
 47736:       }
 47736:       ThebesLayerData* data = GetTopThebesLayerData();
 47736:       if (data) {
 80868:         data->mVisibleAboveRegion.Or(data->mVisibleAboveRegion, itemVisibleRect);
 87083:         data->mVisibleAboveRegion.SimplifyOutward(4);
 48689:         // Add the entire bounds rect to the mDrawAboveRegion.
 48689:         // The visible region may be excluding opaque content above the
 48689:         // item, and we need to ensure that that content is not placed
 48689:         // in a ThebesLayer below the item!
 48689:         data->mDrawAboveRegion.Or(data->mDrawAboveRegion, itemDrawRect);
 87083:         data->mDrawAboveRegion.SimplifyOutward(4);
 47736:       }
 80868:       RestrictVisibleRegionForLayer(ownLayer, itemVisibleRect);
 97433: 
 97433:       // rounded rectangle clipping using mask layers
 97433:       // (must be done after visible rect is set on layer)
 97433:       if (aClip.IsRectClippedByRoundedCorner(itemContent)) {
 97433:           SetupMaskLayer(ownLayer, aClip);
 97433:       }
 97433: 
 47736:       ContainerLayer* oldContainer = ownLayer->GetParent();
 47736:       if (oldContainer && oldContainer != mContainerLayer) {
 47736:         oldContainer->RemoveChild(ownLayer);
 47736:       }
 47736:       NS_ASSERTION(!mNewChildLayers.Contains(ownLayer),
 47736:                    "Layer already in list???");
 47751: 
103513:       InvalidateForLayerChange(item, ownLayer);
 47751: 
 47736:       mNewChildLayers.AppendElement(ownLayer);
105568:       mLayerBuilder->AddLayerDisplayItem(ownLayer, item, layerState);
 47736:     } else {
 97433:       ThebesLayerData* data =
 80868:         FindThebesLayerFor(item, itemVisibleRect, itemDrawRect, aClip,
 51949:                            activeScrolledRoot);
 47736: 
 99197:       data->mLayer->SetIsFixedPosition(
 99197:         !nsLayoutUtils::IsScrolledByRootContentDocumentDisplayportScrolling(
 67668:                                        activeScrolledRoot, mBuilder));
 67668: 
103513:       InvalidateForLayerChange(item, data->mLayer);
 47751: 
105568:       mLayerBuilder->AddThebesDisplayItem(data->mLayer, item, aClip,
 97433:                                           mContainerFrame,
 62293:                                           layerState);
 97433: 
 97433:       // check to see if the new item has rounded rect clips in common with
 97433:       // other items in the layer
 97433:       data->UpdateCommonClipCount(aClip);
 47751:     }
 47751:   }
 47751: }
 47751: 
 47751: void
103513: ContainerState::InvalidateForLayerChange(nsDisplayItem* aItem, Layer* aNewLayer)
 47751: {
110436:   nsIFrame* f = aItem->GetUnderlyingFrame();
110436:   NS_ASSERTION(f, "Display items that render using Thebes must have a frame");
110436:   uint32_t key = aItem->GetPerFrameKey();
110436:   NS_ASSERTION(key, "Display items that render using Thebes must have a key");
110436:   Layer* oldLayer = mLayerBuilder->GetOldLayerFor(f, key);
103530:   if (!oldLayer) {
103530:     // Nothing to do here, this item didn't have a layer before
103530:     return;
103530:   }
103530:   if (aNewLayer != oldLayer) {
 47736:     // The item has changed layers.
 47736:     // Invalidate the bounds in the old layer and new layer.
 47736:     // The bounds might have changed, but we assume that any difference
 47736:     // in the bounds will have been invalidated for all Thebes layers
 47736:     // in the container via regular frame invalidation.
103530:     bool snap;
103530:     nsRect bounds = aItem->GetBounds(mBuilder, &snap);
103530: 
 47751:     ThebesLayer* t = oldLayer->AsThebesLayer();
 47751:     if (t) {
103530:       ThebesDisplayItemLayerUserData* data =
103530:           static_cast<ThebesDisplayItemLayerUserData*>(t->GetUserData(&gThebesDisplayItemLayerUserData));
 72231:       // Note that whenever the layer's scale changes, we invalidate the whole thing,
 72231:       // so it doesn't matter whether we are using the old scale at last paint
 72231:       // or a new scale here
 72231:       InvalidatePostTransformRegion(t,
103530:           bounds.ScaleToOutsidePixels(data->mXScale, data->mYScale, mAppUnitsPerDevPixel),
105568:           mLayerBuilder->GetLastPaintOffset(t));
 47751:     }
 47751:     if (aNewLayer) {
103530:       ThebesLayer* newLayer = aNewLayer->AsThebesLayer();
103530:       if (newLayer) {
 72231:         ThebesDisplayItemLayerUserData* data =
103530:             static_cast<ThebesDisplayItemLayerUserData*>(newLayer->GetUserData(&gThebesDisplayItemLayerUserData));
103530:         InvalidatePostTransformRegion(newLayer,
103530:             bounds.ScaleToOutsidePixels(data->mXScale, data->mYScale, mAppUnitsPerDevPixel),
103530:             GetTranslationForThebesLayer(newLayer));
103295:       }
103295:     }
 47736: 
103530:     mContainerFrame->InvalidateWithFlags(
103530:         bounds - mBuilder->ToReferenceFrame(mContainerFrame),
103530:         nsIFrame::INVALIDATE_NO_THEBES_LAYERS |
103530:         nsIFrame::INVALIDATE_EXCLUDE_CURRENT_PAINT);
 47736:   }
 47736: }
 47736: 
 79445: bool
 62289: FrameLayerBuilder::NeedToInvalidateFixedDisplayItem(nsDisplayListBuilder* aBuilder,
 62289:                                                     nsDisplayItem* aItem)
 62289: {
103530:   return !aItem->ShouldFixToViewport(aBuilder) ||
103530:       !HasRetainedLayerFor(aItem->GetUnderlyingFrame(), aItem->GetPerFrameKey());
 62289: }
 62289: 
 47736: void
 47736: FrameLayerBuilder::AddThebesDisplayItem(ThebesLayer* aLayer,
 47736:                                         nsDisplayItem* aItem,
 52292:                                         const Clip& aClip,
 47751:                                         nsIFrame* aContainerLayerFrame,
 62293:                                         LayerState aLayerState)
 47736: {
103530:   AddLayerDisplayItem(aLayer, aItem, aLayerState);
 47736: 
 47736:   ThebesLayerItemsEntry* entry = mThebesLayerItems.PutEntry(aLayer);
 47736:   if (entry) {
 47736:     entry->mContainerLayerFrame = aContainerLayerFrame;
106095:     entry->mContainerLayerGeneration = mContainerLayerGeneration;
 47736:     NS_ASSERTION(aItem->GetUnderlyingFrame(), "Must have frame");
 47751:     ClippedDisplayItem* cdi =
106095:       entry->mItems.AppendElement(ClippedDisplayItem(aItem, aClip,
106095:                                                      mContainerLayerGeneration));
103530:     cdi->mInactiveLayer = aLayerState != LAYER_NONE;
 47736:   }
 47736: }
 47736: 
 47736: void
 47736: FrameLayerBuilder::AddLayerDisplayItem(Layer* aLayer,
 70037:                                        nsDisplayItem* aItem,
103530:                                        LayerState aLayerState)
 47736: {
 47736:   if (aLayer->Manager() != mRetainingManager)
 47736:     return;
 47736: 
 47736:   nsIFrame* f = aItem->GetUnderlyingFrame();
110436:   DisplayItemDataEntry* entry = mNewDisplayItemData.PutEntry(f);
110436:   entry->mContainerLayerGeneration = mContainerLayerGeneration;
110436:   if (entry) {
110436:     entry->mData.AppendElement(DisplayItemData(aLayer, aItem->GetPerFrameKey(), aLayerState, mContainerLayerGeneration));
 47736:   }
 47736: }
 47736: 
 70022: nsIntPoint
 70022: FrameLayerBuilder::GetLastPaintOffset(ThebesLayer* aLayer)
 69962: {
 69962:   ThebesLayerItemsEntry* entry = mThebesLayerItems.PutEntry(aLayer);
106095:   if (entry) {
106095:     entry->mContainerLayerGeneration = mContainerLayerGeneration;
106095:     if (entry->mHasExplicitLastPaintOffset)
 70022:       return entry->mLastPaintOffset;
106095:   }
 70022:   return GetTranslationForThebesLayer(aLayer);
 69962: }
 69962: 
 69962: void
 70022: FrameLayerBuilder::SaveLastPaintOffset(ThebesLayer* aLayer)
 69962: {
 69962:   ThebesLayerItemsEntry* entry = mThebesLayerItems.PutEntry(aLayer);
 69962:   if (entry) {
106095:     entry->mContainerLayerGeneration = mContainerLayerGeneration;
 70022:     entry->mLastPaintOffset = GetTranslationForThebesLayer(aLayer);
 80486:     entry->mHasExplicitLastPaintOffset = true;
 69962:   }
 69962: }
 69962: 
 51947: nscolor
 51947: FrameLayerBuilder::FindOpaqueColorCovering(nsDisplayListBuilder* aBuilder,
 51947:                                            ThebesLayer* aLayer,
 51947:                                            const nsRect& aRect)
 51947: {
 51947:   ThebesLayerItemsEntry* entry = mThebesLayerItems.GetEntry(aLayer);
 51947:   NS_ASSERTION(entry, "Must know about this layer!");
108991:   for (int32_t i = entry->mItems.Length() - 1; i >= 0; --i) {
 51947:     nsDisplayItem* item = entry->mItems[i].mItem;
 51947:     const nsRect& visible = item->GetVisibleRect();
 51947:     if (!visible.Intersects(aRect))
 51947:       continue;
 51947: 
 51947:     nscolor color;
 51947:     if (visible.Contains(aRect) && item->IsUniform(aBuilder, &color) &&
 51947:         NS_GET_A(color) == 255)
 51947:       return color;
 51947:     break;
 51947:   }
 51947:   return NS_RGBA(0,0,0,0);
 51947: }
 51947: 
 47736: void
 47745: ContainerState::CollectOldLayers()
 47736: {
 47736:   for (Layer* layer = mContainerLayer->GetFirstChild(); layer;
 47736:        layer = layer->GetNextSibling()) {
 97431:     NS_ASSERTION(!layer->HasUserData(&gMaskLayerUserData),
 97431:                  "Mask layer in layer tree; could not be recycled.");
108785:     if (layer->HasUserData(&gThebesDisplayItemLayerUserData)) {
 47745:       NS_ASSERTION(layer->AsThebesLayer(), "Wrong layer type");
 47745:       mRecycledThebesLayers.AppendElement(static_cast<ThebesLayer*>(layer));
 47736:     }
 97431: 
 97431:     if (Layer* maskLayer = layer->GetMaskLayer()) {
 97431:       NS_ASSERTION(maskLayer->GetType() == Layer::TYPE_IMAGE,
 97431:                    "Could not recycle mask layer, unsupported layer type.");
 97431:       mRecycledMaskImageLayers.Put(layer, static_cast<ImageLayer*>(maskLayer));
 97431:     }
 47736:   }
 47736: }
 47736: 
 47736: void
108991: ContainerState::Finish(uint32_t* aTextContentFlags)
 47736: {
 47736:   while (!mThebesLayerDataStack.IsEmpty()) {
 47736:     PopThebesLayerData();
 47736:   }
 47736: 
108991:   uint32_t textContentFlags = 0;
108991: 
108991:   for (uint32_t i = 0; i <= mNewChildLayers.Length(); ++i) {
 47736:     // An invariant of this loop is that the layers in mNewChildLayers
 47736:     // with index < i are the first i child layers of mContainerLayer.
 47736:     Layer* layer;
 47736:     if (i < mNewChildLayers.Length()) {
 47736:       layer = mNewChildLayers[i];
 59481:       if (!layer->GetVisibleRegion().IsEmpty()) {
 59482:         textContentFlags |= layer->GetContentFlags() & Layer::CONTENT_COMPONENT_ALPHA;
 59481:       }
 47736:       if (!layer->GetParent()) {
 47736:         // This is not currently a child of the container, so just add it
 47736:         // now.
106838:         Layer* prevChild = i == 0 ? nullptr : mNewChildLayers[i - 1].get();
 47736:         mContainerLayer->InsertAfter(layer, prevChild);
103530:         continue;
 47736:       }
 47736:       NS_ASSERTION(layer->GetParent() == mContainerLayer,
 47736:                    "Layer shouldn't be the child of some other container");
 47736:     } else {
106838:       layer = nullptr;
 47736:     }
 47736: 
 47736:     // If layer is non-null, then it's already a child of the container,
 47736:     // so scan forward until we find it, removing the other layers we
 47736:     // don't want here.
 47736:     // If it's null, scan forward until we've removed all the leftover
 47736:     // children.
 47736:     Layer* nextOldChild = i == 0 ? mContainerLayer->GetFirstChild() :
 47736:       mNewChildLayers[i - 1]->GetNextSibling();
 47736:     while (nextOldChild != layer) {
 47736:       Layer* tmp = nextOldChild;
 47736:       nextOldChild = nextOldChild->GetNextSibling();
 47736:       mContainerLayer->RemoveChild(tmp);
 47736:     }
 47736:     // If non-null, 'layer' is now in the right place in the list, so we
 47736:     // can just move on to the next one.
 47736:   }
 59481: 
 59481:   *aTextContentFlags = textContentFlags;
 47736: }
 42593: 
 72231: static FrameLayerBuilder::ContainerParameters
 72231: ChooseScaleAndSetTransform(FrameLayerBuilder* aLayerBuilder,
 72231:                            nsIFrame* aContainerFrame,
 72231:                            const gfx3DMatrix* aTransform,
 72231:                            const FrameLayerBuilder::ContainerParameters& aIncomingScale,
 72231:                            ContainerLayer* aLayer)
 72231: {
 72231:   gfx3DMatrix transform =
 77290:     gfx3DMatrix::ScalingMatrix(aIncomingScale.mXScale, aIncomingScale.mYScale, 1.0);
 72231:   if (aTransform) {
 72231:     // aTransform is applied first, then the scale is applied to the result
 72231:     transform = (*aTransform)*transform;
 72231:   }
 72231: 
 72231:   gfxMatrix transform2d;
 90993:   bool canDraw2D = transform.CanDraw2D(&transform2d);
 72231:   gfxSize scale;
 87082:   bool isRetained = aLayerBuilder->GetRetainingLayerManager() == aLayer->Manager();
 72231:   // Only fiddle with scale factors for the retaining layer manager, since
 72231:   // it only matters for retained layers
 87082:   // XXX Should we do something for 3D transforms?
 90993:   if (canDraw2D && isRetained) {
 72231:     //Scale factors are normalized to a power of 2 to reduce the number of resolution changes
 80486:     scale = transform2d.ScaleFactors(true);
 72242:     // For frames with a changing transform that's not just a translation,
 72242:     // round scale factors up to nearest power-of-2 boundary so that we don't
 72242:     // keep having to redraw the content as it scales up and down. Rounding up to nearest
 72231:     // power-of-2 boundary ensures we never scale up, only down --- avoiding
 72231:     // jaggies. It also ensures we never scale down by more than a factor of 2,
 72231:     // avoiding bad downscaling quality.
 72242:     gfxMatrix frameTransform;
 72242:     if (aContainerFrame->AreLayersMarkedActive(nsChangeHint_UpdateTransformLayer) &&
 72242:         aTransform &&
 72242:         (!aTransform->Is2D(&frameTransform) || frameTransform.HasNonTranslationOrFlip())) {
 84204:       // Don't clamp the scale factor when the new desired scale factor matches the old one
 84204:       // or it was previously unscaled.
 84204:       bool clamp = true;
 84204:       gfxMatrix oldFrameTransform2d;
 84204:       if (aLayer->GetTransform().Is2D(&oldFrameTransform2d)) {
 84204:         gfxSize oldScale = oldFrameTransform2d.ScaleFactors(true);
 84204:         if (oldScale == scale || oldScale == gfxSize(1.0, 1.0))
 84204:           clamp = false;
 84204:       }
 84204:       if (clamp) {
 72231:         scale.width = gfxUtils::ClampToScaleFactor(scale.width);
 72231:         scale.height = gfxUtils::ClampToScaleFactor(scale.height);
 84204:       }
 72231:     } else {
 72231:       // XXX Do we need to move nearly-integer values to integers here?
 72231:     }
 72231:     // If the scale factors are too small, just use 1.0. The content is being
 72231:     // scaled out of sight anyway.
 72248:     if (fabs(scale.width) < 1e-8 || fabs(scale.height) < 1e-8) {
 97193:       scale = gfxSize(1.0, 1.0);
 72231:     }
 72231:   } else {
 72231:     scale = gfxSize(1.0, 1.0);
 72231:   }
 72231: 
107388:   // Store the inverse of our resolution-scale on the layer
106915:   aLayer->SetBaseTransform(transform);
107388:   aLayer->SetPreScale(1.0f/float(scale.width),
107388:                       1.0f/float(scale.height));
 72243: 
 72243:   FrameLayerBuilder::ContainerParameters
 72243:     result(scale.width, scale.height, aIncomingScale);
 72243:   if (aTransform) {
 72243:     result.mInTransformedSubtree = true;
 72243:     if (aContainerFrame->AreLayersMarkedActive(nsChangeHint_UpdateTransformLayer)) {
 72243:       result.mInActiveTransformedSubtree = true;
 72243:     }
 72243:   }
 90993:   if (isRetained && (!canDraw2D || transform2d.HasNonIntegerTranslation())) {
 87082:     result.mDisableSubpixelAntialiasingInDescendants = true;
 87082:   }
 72243:   return result;
 72231: }
 72231: 
103531: static void
103531: ApplyThebesLayerInvalidation(nsDisplayListBuilder* aBuilder,
103531:                              nsIFrame* aContainerFrame,
103531:                              nsDisplayItem* aContainerItem,
103531:                              ContainerState& aState,
108264:                              nsPoint* aCurrentOffset,
108264:                              nsDisplayTransform* aTransform)
103531: {
103531:   *aCurrentOffset = aContainerItem ? aContainerItem->ToReferenceFrame()
103531:     : aBuilder->ToReferenceFrame(aContainerFrame);
103531: 
103531:   FrameProperties props = aContainerFrame->Properties();
103531:   RefCountedRegion* invalidThebesContent = static_cast<RefCountedRegion*>
103531:     (props.Get(ThebesLayerInvalidRegionProperty()));
109155:   const FrameLayerBuilder::ContainerParameters& scaleParameters = aState.ScaleParameters();
109155: 
109155:   nsRegion invalidRegion;
103531:   if (invalidThebesContent) {
109155:     if (invalidThebesContent->mIsInfinite) {
109155:       // The region was marked as infinite to indicate that everything should be
109155:       // invalidated.
109155:       aState.SetInvalidateAllThebesContent();
109155:       return;
109155:     }
109155: 
109155:     invalidRegion = invalidThebesContent->mRegion;
109155:   } else {
109155:     // The region doesn't exist, so this is a newly visible frame. Invalidate
109155:     // the frame area.
109155:     invalidRegion =
109155:       aContainerFrame->GetVisualOverflowRectRelativeToSelf() + *aCurrentOffset;
109155:   }
109155: 
108264:   if (aTransform) {
108264:     // XXX We're simplifying the transform by only using the bounds of the
108264:     //     region. This may have performance implications.
109155:     invalidRegion = aTransform->
109155:       TransformRectOut(invalidRegion.GetBounds(),
108264:                        aTransform->GetUnderlyingFrame(), -(*aCurrentOffset));
109155:   }
109155: 
109155:   aState.AddInvalidThebesContent(invalidRegion.
108264:     ScaleToOutsidePixels(scaleParameters.mXScale, scaleParameters.mYScale,
108264:                          aState.GetAppUnitsPerDevPixel()));
109155: 
103531:   // We have to preserve the current contents of invalidThebesContent
103531:   // because there might be multiple container layers for the same
103531:   // frame and we need to invalidate the ThebesLayer children of all
103531:   // of them. Also, multiple calls to ApplyThebesLayerInvalidation for the
103531:   // same layer can share the same region.
103531: }
103531: 
106095: /* static */ PLDHashOperator
106095: FrameLayerBuilder::RestoreDisplayItemData(DisplayItemDataEntry* aEntry, void* aUserArg)
106095: {
108991:   uint32_t *generation = static_cast<uint32_t*>(aUserArg);
106095: 
106095:   if (aEntry->mContainerLayerGeneration >= *generation) {
106095:     return PL_DHASH_REMOVE;
106095:   }
106095: 
108991:   for (uint32_t i = 0; i < aEntry->mData.Length(); i++) {
106095:     if (aEntry->mData[i].mContainerLayerGeneration >= *generation) {
106095:       aEntry->mData.TruncateLength(i);
106095:       return PL_DHASH_NEXT;
106095:     }
106095:   }
106095: 
106095:   return PL_DHASH_NEXT;
106095: }
106095: 
106095: /* static */ PLDHashOperator
106095: FrameLayerBuilder::RestoreThebesLayerItemEntries(ThebesLayerItemsEntry* aEntry, void* aUserArg)
106095: {
108991:   uint32_t *generation = static_cast<uint32_t*>(aUserArg);
106095: 
106095:   if (aEntry->mContainerLayerGeneration >= *generation) {
106095:     return PL_DHASH_REMOVE;
106095:   }
106095: 
108991:   for (uint32_t i = 0; i < aEntry->mItems.Length(); i++) {
106095:     if (aEntry->mItems[i].mContainerLayerGeneration >= *generation) {
106095:       aEntry->mItems.TruncateLength(i);
106095:       return PL_DHASH_NEXT;
106095:     }
106095:   }
106095: 
106095:   return PL_DHASH_NEXT;
106095: }
106095: 
108264: static nsDisplayTransform* FindTransformForContainerFrame(nsIFrame* aContainerFrame,
108264:                                                           nsDisplayItem* aContainerItem)
108264: {
108264:   if (!aContainerFrame->IsTransformed() ||
108264:       aContainerItem->GetType() == nsDisplayItem::TYPE_TRANSFORM)
108282:     return nullptr;
108264: 
108264:   nsTArray<nsDisplayItem*> queue;
108264:   queue.AppendElement(aContainerItem);
108264:   while (queue.Length()) {
108264:     nsDisplayItem* item = queue[queue.Length() - 1];
108264:     queue.RemoveElementAt(queue.Length() - 1);
108264: 
108264:     if (item->GetType() == nsDisplayItem::TYPE_TRANSFORM) {
108264:       return static_cast<nsDisplayTransform*>(item);
108264:     }
108264: 
108264:     if (item->GetList()) {
108264:       for (nsDisplayItem* child = item->GetList()->GetBottom(); child;
108264:            child = child->GetAbove()) {
108264:         if (child->GetUnderlyingFrame() == aContainerFrame) {
108264:           queue.AppendElement(child);
108264:         }
108264:       }
108264:     }
108264:   }
108264: 
108282:   return nullptr;
108264: }
108264: 
 54078: already_AddRefed<ContainerLayer>
 47736: FrameLayerBuilder::BuildContainerLayerFor(nsDisplayListBuilder* aBuilder,
 42593:                                           LayerManager* aManager,
 47736:                                           nsIFrame* aContainerFrame,
 47736:                                           nsDisplayItem* aContainerItem,
 72230:                                           const nsDisplayList& aChildren,
 72230:                                           const ContainerParameters& aParameters,
 72230:                                           const gfx3DMatrix* aTransform)
 42593: {
108991:   uint32_t containerDisplayItemKey =
 47736:     aContainerItem ? aContainerItem->GetPerFrameKey() : 0;
 47736:   NS_ASSERTION(aContainerFrame, "Container display items here should have a frame");
 47736:   NS_ASSERTION(!aContainerItem ||
 47736:                aContainerItem->GetUnderlyingFrame() == aContainerFrame,
 47736:                "Container display item must match given frame");
 47736: 
 47736:   nsRefPtr<ContainerLayer> containerLayer;
103530:   if (aManager == mRetainingManager) {
110436:     Layer* oldLayer = GetOldLayerFor(aContainerFrame, containerDisplayItemKey);
 47736:     if (oldLayer) {
103530:       NS_ASSERTION(oldLayer->Manager() == aManager, "Wrong manager");
 51946:       if (oldLayer->HasUserData(&gThebesDisplayItemLayerUserData)) {
 47751:         // The old layer for this item is actually our ThebesLayer
 47751:         // because we rendered its layer into that ThebesLayer. So we
 47751:         // don't actually have a retained container layer.
 47751:       } else {
 47736:         NS_ASSERTION(oldLayer->GetType() == Layer::TYPE_CONTAINER,
 47736:                      "Wrong layer type");
 47736:         containerLayer = static_cast<ContainerLayer*>(oldLayer);
 47751:         // Clear clip rect; the caller will set it if necessary.
106838:         containerLayer->SetClipRect(nullptr);
106838:         containerLayer->SetMaskLayer(nullptr);
 47736:       }
 47736:     }
103530:   }
 47736:   if (!containerLayer) {
 47736:     // No suitable existing layer was found.
 47736:     containerLayer = aManager->CreateContainerLayer();
 47736:     if (!containerLayer)
106838:       return nullptr;
 47736:   }
 42593: 
 70037:   if (aContainerItem &&
 97534:       aContainerItem->GetLayerState(aBuilder, aManager, aParameters) == LAYER_ACTIVE_EMPTY) {
 70037:     // Empty layers only have metadata and should never have display items. We
 70037:     // early exit because later, invalidation will walk up the frame tree to
 70037:     // determine which thebes layer gets invalidated. Since an empty layer
 70037:     // should never have anything to paint, it should never be invalidated.
 70037:     NS_ASSERTION(aChildren.IsEmpty(), "Should have no children");
 70037:     return containerLayer.forget();
 70037:   }
 70037: 
 72231:   ContainerParameters scaleParameters =
 72231:     ChooseScaleAndSetTransform(this, aContainerFrame, aTransform, aParameters,
 72231:                                containerLayer);
101659: 
108991:   uint32_t oldGeneration = mContainerLayerGeneration;
106095:   mContainerLayerGeneration = ++mMaxContainerLayerGeneration;
106095: 
106838:   nsRefPtr<RefCountedRegion> thebesLayerInvalidRegion = nullptr;
103530:   if (aManager == mRetainingManager) {
104565:     FrameProperties props = aContainerFrame->Properties();
 47736:     DisplayItemDataEntry* entry = mNewDisplayItemData.PutEntry(aContainerFrame);
 47736:     if (entry) {
103530:       entry->mData.AppendElement(
106095:           DisplayItemData(containerLayer, containerDisplayItemKey,
106095:                           LAYER_ACTIVE, mContainerLayerGeneration));
104565:       thebesLayerInvalidRegion = static_cast<RefCountedRegion*>
104565:         (props.Get(ThebesLayerInvalidRegionProperty()));
104565:       if (!thebesLayerInvalidRegion) {
104565:         thebesLayerInvalidRegion = new RefCountedRegion();
104565:       }
104565:       entry->mInvalidRegion = thebesLayerInvalidRegion;
106095:       entry->mContainerLayerGeneration = mContainerLayerGeneration;
103299:     }
106095:   }
106095: 
106095:   nsRect bounds;
106095:   nsIntRect pixBounds;
108991:   int32_t appUnitsPerDevPixel;
108991:   uint32_t stateFlags =
106095:     (aContainerFrame->GetStateBits() & NS_FRAME_NO_COMPONENT_ALPHA) ?
106095:       ContainerState::NO_COMPONENT_ALPHA : 0;
108991:   uint32_t flags;
106095:   bool flattenedLayers = false;
106095:   while (true) {
108884:     ContainerState state(aBuilder, aManager, aManager->GetLayerBuilder(),
106095:                          aContainerFrame, containerLayer, scaleParameters);
106095:     if (flattenedLayers) {
106095:       state.SetInvalidateAllThebesContent();
106095:     }
106095: 
106095:     if (aManager == mRetainingManager) {
108264:       // If the container frame has a transform and it's contained in the
108264:       // container item's sub-tree, we need to transform the invalid region
108264:       // before applying it.
108264:       nsDisplayTransform* transformItem =
108264:         FindTransformForContainerFrame(aContainerFrame, aContainerItem);
108264: 
103531:       nsPoint currentOffset;
103531:       ApplyThebesLayerInvalidation(aBuilder, aContainerFrame, aContainerItem, state,
108264:                                    &currentOffset, transformItem);
104565:       SetHasContainerLayer(aContainerFrame, currentOffset);
103530: 
103531:       nsAutoTArray<nsIFrame*,4> mergedFrames;
103531:       if (aContainerItem) {
103531:         aContainerItem->GetMergedFrames(&mergedFrames);
103530:       }
108991:       for (uint32_t i = 0; i < mergedFrames.Length(); ++i) {
103531:         nsIFrame* mergedFrame = mergedFrames[i];
103531:         DisplayItemDataEntry* entry = mNewDisplayItemData.PutEntry(mergedFrame);
103531:         if (entry) {
103531:           // Ensure that UpdateDisplayItemDataForFrame recognizes that we
103531:           // still have a container layer associated with this frame.
103531:           entry->mIsSharingContainerLayer = true;
104565: 
104565:           // Store the invalid region property in case this frame is represented
104565:           // by multiple container layers. This is cleared and set when iterating
104565:           // over the DisplayItemDataEntry's in WillEndTransaction.
104565:           entry->mInvalidRegion = thebesLayerInvalidRegion;
103531:         }
106838:         ApplyThebesLayerInvalidation(aBuilder, mergedFrame, nullptr, state,
108264:                                      &currentOffset, transformItem);
104565:         SetHasContainerLayer(mergedFrame, currentOffset);
103531:       }
103299:     }
103299: 
103526:     Clip clip;
106095:     state.ProcessDisplayItems(aChildren, clip, stateFlags);
103299: 
 59482:     // Set CONTENT_COMPONENT_ALPHA if any of our children have it.
 59481:     // This is suboptimal ... a child could have text that's over transparent
 59481:     // pixels in its own layer, but over opaque parts of previous siblings.
103530:     state.Finish(&flags);
106095:     bounds = state.GetChildrenBounds();
106095:     pixBounds = state.ScaleToOutsidePixels(bounds, false);
106095:     appUnitsPerDevPixel = state.GetAppUnitsPerDevPixel();
103299: 
106095:     if ((flags & Layer::CONTENT_COMPONENT_ALPHA) &&
106095:         mRetainingManager &&
106095:         !mRetainingManager->AreComponentAlphaLayersEnabled() &&
106095:         !stateFlags) {
106095:       // Since we don't want any component alpha layers on BasicLayers, we repeat
106095:       // the layer building process with this explicitely forced off.
106095:       // We restore the previous FrameLayerBuilder state since the first set
106095:       // of layer building will have changed it.
106095:       stateFlags = ContainerState::NO_COMPONENT_ALPHA;
106095:       mNewDisplayItemData.EnumerateEntries(RestoreDisplayItemData,
106095:                                            &mContainerLayerGeneration);
106095:       mThebesLayerItems.EnumerateEntries(RestoreThebesLayerItemEntries,
106095:                                          &mContainerLayerGeneration);
106095:       aContainerFrame->AddStateBits(NS_FRAME_NO_COMPONENT_ALPHA);
106095:       flattenedLayers = true;
106095:       continue;
106095:     }
106095:     break;
106095:   }
106095: 
 68638:   NS_ASSERTION(bounds.IsEqualInterior(aChildren.GetBounds(aBuilder)), "Wrong bounds");
 62985:   containerLayer->SetVisibleRegion(pixBounds);
 62985:   // Make sure that rounding the visible region out didn't add any area
 62985:   // we won't paint
 72231:   if (aChildren.IsOpaque() && !aChildren.NeedsTransparentSurface()) {
 72231:     bounds.ScaleRoundIn(scaleParameters.mXScale, scaleParameters.mYScale);
106095:     if (bounds.Contains(pixBounds.ToAppUnits(appUnitsPerDevPixel))) {
 59482:       // Clear CONTENT_COMPONENT_ALPHA
 59482:       flags = Layer::CONTENT_OPAQUE;
 59481:     }
 72231:   }
 51950:   containerLayer->SetContentFlags(flags);
 59481: 
106095:   mContainerLayerGeneration = oldGeneration;
 48946:   return containerLayer.forget();
 42593: }
 42593: 
 47731: Layer*
 47731: FrameLayerBuilder::GetLeafLayerFor(nsDisplayListBuilder* aBuilder,
103530:                                    LayerManager* aManager,
 47731:                                    nsDisplayItem* aItem)
 47731: {
103530:   if (aManager != mRetainingManager)
106838:     return nullptr;
103530: 
 47736:   nsIFrame* f = aItem->GetUnderlyingFrame();
 47736:   NS_ASSERTION(f, "Can only call GetLeafLayerFor on items that have a frame");
110436:   Layer* layer = GetOldLayerFor(f, aItem->GetPerFrameKey());
 47736:   if (!layer)
106838:     return nullptr;
 51946:   if (layer->HasUserData(&gThebesDisplayItemLayerUserData)) {
 47736:     // This layer was created to render Thebes-rendered content for this
 47736:     // display item. The display item should not use it for its own
 47736:     // layer rendering.
106838:     return nullptr;
 47736:   }
 47736:   // Clear clip rect; the caller is responsible for setting it.
106838:   layer->SetClipRect(nullptr);
106838:   layer->SetMaskLayer(nullptr);
 47736:   return layer;
 47731: }
 47731: 
 47731: /* static */ void
103530: FrameLayerBuilder::InvalidateThebesLayerContents(nsIFrame* aFrame,
103530:                                                  const nsRect& aRect)
103530: {
103530:   FrameProperties props = aFrame->Properties();
103530:   RefCountedRegion* invalidThebesContent = static_cast<RefCountedRegion*>
103530:     (props.Get(ThebesLayerInvalidRegionProperty()));
103530:   if (!invalidThebesContent)
103530:     return;
103530: 
103530:   nsPoint* offsetAtLastPaint = static_cast<nsPoint*>
103530:     (props.Get(ThebesLayerLastPaintOffsetProperty()));
103530:   NS_ASSERTION(offsetAtLastPaint,
103530:                "This must have been set up along with ThebesLayerInvalidRegionProperty");
103530:   invalidThebesContent->mRegion.Or(invalidThebesContent->mRegion,
103530:           aRect + *offsetAtLastPaint);
103530:   invalidThebesContent->mRegion.SimplifyOutward(20);
103530: }
103530: 
103530: /**
103530:  * Returns true if we find a descendant with a container layer
103530:  */
103530: static bool
107653: InternalInvalidateThebesLayersInSubtree(nsIFrame* aFrame, bool aTrustFrameGeometry)
103530: {
103530:   if (!(aFrame->GetStateBits() & NS_FRAME_HAS_CONTAINER_LAYER_DESCENDANT))
103530:     return false;
103530: 
103530:   bool foundContainerLayer = false;
103530:   if (aFrame->GetStateBits() & NS_FRAME_HAS_CONTAINER_LAYER) {
107653:     if (aTrustFrameGeometry) {
107653:       // Just invalidate the area covered by the frame. This helps if a single
107653:       // region is being shared by multiple container layers.
107653:       FrameLayerBuilder::InvalidateThebesLayerContents(aFrame,
107653:         aFrame->GetVisualOverflowRectRelativeToSelf());
107653:     } else {
109155:       // Mark the invalid region as infinite to indicate that all Thebes
109155:       // contents need to be invalidated
109155:       FrameProperties props = aFrame->Properties();
109155:       RefCountedRegion* invalidRegion = static_cast<RefCountedRegion*>
109155:         (props.Get(ThebesLayerInvalidRegionProperty()));
109155:       if (!invalidRegion) {
109155:         invalidRegion = new RefCountedRegion();
109155:         invalidRegion->AddRef();
109155:         props.Set(ThebesLayerInvalidRegionProperty(), invalidRegion);
109155:       }
109155:       invalidRegion->mIsInfinite = true;
107653:     }
103530:     foundContainerLayer = true;
103530:   }
103530: 
103530:   nsAutoTArray<nsIFrame::ChildList,4> childListArray;
103530:   if (!aFrame->GetFirstPrincipalChild()) {
103530:     nsSubDocumentFrame* subdocumentFrame = do_QueryFrame(aFrame);
103530:     if (subdocumentFrame) {
103530:       // Descend into the subdocument
103530:       nsIFrame* root = subdocumentFrame->GetSubdocumentRootFrame();
103530:       if (root) {
103530:         childListArray.AppendElement(nsIFrame::ChildList(
103530:           nsFrameList(root, nsLayoutUtils::GetLastSibling(root)),
103530:           nsIFrame::kPrincipalList));
103530:       }
103530:     }
103530:   }
103530: 
103530:   aFrame->GetChildLists(&childListArray);
103530:   nsIFrame::ChildListArrayIterator lists(childListArray);
103530:   for (; !lists.IsDone(); lists.Next()) {
103530:     nsFrameList::Enumerator childFrames(lists.CurrentList());
103530:     for (; !childFrames.AtEnd(); childFrames.Next()) {
107653:       if (InternalInvalidateThebesLayersInSubtree(childFrames.get(),
107653:                                                   aTrustFrameGeometry)) {
103530:         foundContainerLayer = true;
103530:       }
103530:     }
103530:   }
103530: 
103530:   if (!foundContainerLayer) {
103530:     aFrame->RemoveStateBits(NS_FRAME_HAS_CONTAINER_LAYER_DESCENDANT);
103530:   }
103530:   return foundContainerLayer;
103530: }
103530: 
103530: /* static */ void
103530: FrameLayerBuilder::InvalidateThebesLayersInSubtree(nsIFrame* aFrame)
103530: {
107653:   InternalInvalidateThebesLayersInSubtree(aFrame, true);
107653: }
107653: 
107653: /* static */ void
107653: FrameLayerBuilder::InvalidateThebesLayersInSubtreeWithUntrustedFrameGeometry(nsIFrame* aFrame)
107653: {
107653:   InternalInvalidateThebesLayersInSubtree(aFrame, false);
103530: }
103530: 
103530: /* static */ void
 47736: FrameLayerBuilder::InvalidateAllLayers(LayerManager* aManager)
 47736: {
 47736:   LayerManagerData* data = static_cast<LayerManagerData*>
 51946:     (aManager->GetUserData(&gLayerManagerUserData));
 47736:   if (data) {
 80486:     data->mInvalidateAllLayers = true;
 47736:   }
 47731: }
 47731: 
 47740: /* static */
 64542: Layer*
108991: FrameLayerBuilder::GetDedicatedLayer(nsIFrame* aFrame, uint32_t aDisplayItemKey)
 47740: {
103530:   nsTArray<DisplayItemData>* array = GetDisplayItemDataArrayForFrame(aFrame);
103530:   if (!array)
106838:     return nullptr;
103523: 
108991:   for (uint32_t i = 0; i < array->Length(); ++i) {
103530:     if (array->ElementAt(i).mDisplayItemKey == aDisplayItemKey) {
103530:       Layer* layer = array->ElementAt(i).mLayer;
 51946:       if (!layer->HasUserData(&gColorLayerUserData) &&
 60712:           !layer->HasUserData(&gImageLayerUserData) &&
103523:           !layer->HasUserData(&gThebesDisplayItemLayerUserData))
 64542:         return layer;
 47740:     }
103523:   }
106838:   return nullptr;
 47740: }
 47740: 
107527: static gfxSize
107527: PredictScaleForContent(nsIFrame* aFrame, nsIFrame* aAncestorWithScale,
107527:                        const gfxSize& aScale)
 98192: {
107527:   gfx3DMatrix transform =
107527:     gfx3DMatrix::ScalingMatrix(aScale.width, aScale.height, 1.0);
107527:   // aTransform is applied first, then the scale is applied to the result
107527:   transform = nsLayoutUtils::GetTransformToAncestor(aFrame, aAncestorWithScale)*transform;
107527:   gfxMatrix transform2d;
107527:   if (transform.CanDraw2D(&transform2d)) {
107527:      return transform2d.ScaleFactors(true);
107527:   }
107527:   return gfxSize(1.0, 1.0);
107527: }
107527: 
107527: gfxSize
107527: FrameLayerBuilder::GetThebesLayerScaleForFrame(nsIFrame* aFrame)
107527: {
107527:   nsIFrame* last;
107527:   for (nsIFrame* f = aFrame; f; f = nsLayoutUtils::GetCrossDocParentFrame(f)) {
107527:     last = f;
107527:     if (f->GetStateBits() & NS_FRAME_HAS_CONTAINER_LAYER) {
107527:       nsTArray<DisplayItemData>* array = GetDisplayItemDataArrayForFrame(f);
107530: 	  // Some frames with NS_FRAME_HAS_CONTAINER_LAYER may not have display items.
107530: 	  // In particular the root frame probably doesn't!
107530:       if (!array)
107530: 	    continue;
108991:       for (uint32_t i = 0; i < array->Length(); ++i) {
107497:         Layer* layer = array->ElementAt(i).mLayer;
107527:         ContainerLayer* container = layer->AsContainerLayer();
107527:         if (!container) {
107527:           continue;
107527:         }
107527:         for (Layer* l = container->GetFirstChild(); l; l = l->GetNextSibling()) {
107497:           ThebesDisplayItemLayerUserData* data =
107497:               static_cast<ThebesDisplayItemLayerUserData*>
107527:                 (l->GetUserData(&gThebesDisplayItemLayerUserData));
107527:           if (data) {
107527:             return PredictScaleForContent(aFrame, f, gfxSize(data->mXScale, data->mYScale));
107527:           }
107527:         }
107485:       }
107497:     }
107485:   }
107485: 
107527:   return PredictScaleForContent(aFrame, last,
107527:       last->PresContext()->PresShell()->GetResolution());
 98192: }
 98192: 
 93035: #ifdef MOZ_DUMP_PAINTING
 93035: static void DebugPaintItem(nsRenderingContext* aDest, nsDisplayItem *aItem, nsDisplayListBuilder* aBuilder)
 93035: {
 95051:   bool snap;
 95051:   nsRect appUnitBounds = aItem->GetBounds(aBuilder, &snap);
 93035:   gfxRect bounds(appUnitBounds.x, appUnitBounds.y, appUnitBounds.width, appUnitBounds.height);
 93035:   bounds.ScaleInverse(aDest->AppUnitsPerDevPixel());
 93035: 
 93035:   nsRefPtr<gfxASurface> surf =
 93035:     gfxPlatform::GetPlatform()->CreateOffscreenSurface(gfxIntSize(bounds.width, bounds.height),
 93035:                                                        gfxASurface::CONTENT_COLOR_ALPHA);
 93035:   surf->SetDeviceOffset(-bounds.TopLeft());
 93035:   nsRefPtr<gfxContext> context = new gfxContext(surf);
 93035:   nsRefPtr<nsRenderingContext> ctx = new nsRenderingContext();
 93035:   ctx->Init(aDest->DeviceContext(), context);
 93035: 
 93035:   aItem->Paint(aBuilder, ctx);
 93035:   DumpPaintedImage(aItem, surf);
 93035:   aItem->SetPainted();
 93035: 
 93035:   surf->SetDeviceOffset(gfxPoint(0, 0));
 93035:   aDest->ThebesContext()->SetSource(surf, bounds.TopLeft());
 93035:   aDest->ThebesContext()->Rectangle(bounds);
 93035:   aDest->ThebesContext()->Fill();
 93035: }
 93035: #endif
 93035: 
 72243: /*
 72243:  * A note on residual transforms:
 72243:  *
 72243:  * In a transformed subtree we sometimes apply the ThebesLayer's
 72243:  * "residual transform" when drawing content into the ThebesLayer.
 72243:  * This is a translation by components in the range [-0.5,0.5) provided
 72243:  * by the layer system; applying the residual transform followed by the
 72243:  * transforms used by layer compositing ensures that the subpixel alignment
 72243:  * of the content of the ThebesLayer exactly matches what it would be if
 72243:  * we used cairo/Thebes to draw directly to the screen without going through
 72243:  * retained layer buffers.
 72243:  *
 72243:  * The visible and valid regions of the ThebesLayer are computed without
 72243:  * knowing the residual transform (because we don't know what the residual
 72243:  * transform is going to be until we've built the layer tree!). So we have to
 72243:  * consider whether content painted in the range [x, xmost) might be painted
 72243:  * outside the visible region we computed for that content. The visible region
 72243:  * would be [floor(x), ceil(xmost)). The content would be rendered at
 72243:  * [x + r, xmost + r), where -0.5 <= r < 0.5. So some half-rendered pixels could
 72243:  * indeed fall outside the computed visible region, which is not a big deal;
 72243:  * similar issues already arise when we snap cliprects to nearest pixels.
 72243:  * Note that if the rendering of the content is snapped to nearest pixels ---
 72243:  * which it often is --- then the content is actually rendered at
 72243:  * [snap(x + r), snap(xmost + r)). It turns out that floor(x) <= snap(x + r)
 72243:  * and ceil(xmost) >= snap(xmost + r), so the rendering of snapped content
 72243:  * always falls within the visible region we computed.
 72243:  */
 72243: 
 42593: /* static */ void
 42593: FrameLayerBuilder::DrawThebesLayer(ThebesLayer* aLayer,
 42593:                                    gfxContext* aContext,
 42593:                                    const nsIntRegion& aRegionToDraw,
 47108:                                    const nsIntRegion& aRegionToInvalidate,
 42593:                                    void* aCallbackData)
 42593: {
 84290:   SAMPLE_LABEL("gfx", "DrawThebesLayer");
 84290: 
 47736:   nsDisplayListBuilder* builder = static_cast<nsDisplayListBuilder*>
 47736:     (aCallbackData);
 54261: 
108884:   FrameLayerBuilder *layerBuilder = aLayer->Manager()->GetLayerBuilder();
105568: 
105568:   if (layerBuilder->CheckDOMModified())
 54261:     return;
 54261: 
 47766:   nsTArray<ClippedDisplayItem> items;
108991:   uint32_t commonClipCount;
 47766:   nsIFrame* containerLayerFrame;
 47766:   {
105568:     ThebesLayerItemsEntry* entry = layerBuilder->mThebesLayerItems.GetEntry(aLayer);
 47736:     NS_ASSERTION(entry, "We shouldn't be drawing into a layer with no items!");
 47766:     items.SwapElements(entry->mItems);
 97433:     commonClipCount = entry->mCommonClipCount;
 47766:     containerLayerFrame = entry->mContainerLayerFrame;
 47766:     // Later after this point, due to calls to DidEndTransaction
 47766:     // for temporary layer managers, mThebesLayerItems can change,
 47766:     // so 'entry' could become invalid.
 47766:   }
 47108: 
106336:   if (!containerLayerFrame) {
106336:     return;
106336:   }
106336: 
 51947:   ThebesDisplayItemLayerUserData* userData =
 51947:     static_cast<ThebesDisplayItemLayerUserData*>
 51947:       (aLayer->GetUserData(&gThebesDisplayItemLayerUserData));
 51947:   NS_ASSERTION(userData, "where did our user data go?");
 51947:   if (NS_GET_A(userData->mForcedBackgroundColor) > 0) {
 60025:     nsIntRect r = aLayer->GetVisibleRegion().GetBounds();
 60025:     aContext->NewPath();
 60025:     aContext->Rectangle(gfxRect(r.x, r.y, r.width, r.height));
 51947:     aContext->SetColor(gfxRGBA(userData->mForcedBackgroundColor));
 60025:     aContext->Fill();
 51947:   }
 51947: 
 47736:   // make the origin of the context coincide with the origin of the
 47736:   // ThebesLayer
 47736:   gfxContextMatrixAutoSaveRestore saveMatrix(aContext);
 70022:   nsIntPoint offset = GetTranslationForThebesLayer(aLayer);
 72243:   // Apply the residual transform if it has been enabled, to ensure that
 72243:   // snapping when we draw into aContext exactly matches the ideal transform.
 72243:   // See above for why this is OK.
 72243:   aContext->Translate(aLayer->GetResidualTranslation() - gfxPoint(offset.x, offset.y));
 72249:   aContext->Scale(userData->mXScale, userData->mYScale);
 42593: 
 47766:   nsPresContext* presContext = containerLayerFrame->PresContext();
108991:   int32_t appUnitsPerDevPixel = presContext->AppUnitsPerDevPixel();
103530:   if (!aRegionToInvalidate.IsEmpty()) {
103530:     nsRect r = (aRegionToInvalidate.GetBounds() + offset).
103530:       ToAppUnits(appUnitsPerDevPixel);
103530:     r.ScaleInverseRoundOut(userData->mXScale, userData->mYScale);
103530:     containerLayerFrame->InvalidateWithFlags(r,
103530:         nsIFrame::INVALIDATE_NO_THEBES_LAYERS |
103530:         nsIFrame::INVALIDATE_EXCLUDE_CURRENT_PAINT);
103530:   }
 42593: 
108991:   uint32_t i;
 47736:   // Update visible regions. We need perform visibility analysis again
 47736:   // because we may be asked to draw into part of a ThebesLayer that
 47736:   // isn't actually visible in the window (e.g., because a ThebesLayer
 47736:   // expanded its visible region to a rectangle internally), in which
 47736:   // case the mVisibleRect stored in the display item may be wrong.
 47736:   nsRegion visible = aRegionToDraw.ToAppUnits(appUnitsPerDevPixel);
 47736:   visible.MoveBy(NSIntPixelsToAppUnits(offset.x, appUnitsPerDevPixel),
 47736:                  NSIntPixelsToAppUnits(offset.y, appUnitsPerDevPixel));
 72231:   visible.ScaleInverseRoundOut(userData->mXScale, userData->mYScale);
 47736: 
 47766:   for (i = items.Length(); i > 0; --i) {
 47766:     ClippedDisplayItem* cdi = &items[i - 1];
 47736: 
 49163:     NS_ASSERTION(AppUnitsPerDevPixel(cdi->mItem) == appUnitsPerDevPixel,
 49163:                  "a thebes layer should contain items only at the same zoom");
 47736: 
 52292:     NS_ABORT_IF_FALSE(cdi->mClip.mHaveClipRect ||
 52292:                       cdi->mClip.mRoundedClipRects.IsEmpty(),
 52292:                       "If we have rounded rects, we must have a clip rect");
 52292: 
 52292:     if (!cdi->mClip.mHaveClipRect ||
 52292:         (cdi->mClip.mRoundedClipRects.IsEmpty() &&
 52292:          cdi->mClip.mClipRect.Contains(visible.GetBounds()))) {
 47736:       cdi->mItem->RecomputeVisibility(builder, &visible);
 47736:       continue;
 47736:     }
 47736: 
 47736:     // Do a little dance to account for the fact that we're clipping
 47736:     // to cdi->mClipRect
 47736:     nsRegion clipped;
 52292:     clipped.And(visible, cdi->mClip.mClipRect);
 47736:     nsRegion finalClipped = clipped;
 47736:     cdi->mItem->RecomputeVisibility(builder, &finalClipped);
 52292:     // If we have rounded clip rects, don't subtract from the visible
 52292:     // region since we aren't displaying everything inside the rect.
 52292:     if (cdi->mClip.mRoundedClipRects.IsEmpty()) {
 47736:       nsRegion removed;
 47736:       removed.Sub(clipped, finalClipped);
 47736:       nsRegion newVisible;
 47736:       newVisible.Sub(visible, removed);
 47736:       // Don't let the visible region get too complex.
 47736:       if (newVisible.GetNumRects() <= 15) {
 47736:         visible = newVisible;
 47736:       }
 47736:     }
 61322:     if (!cdi->mClip.IsRectClippedByRoundedCorner(cdi->mItem->GetVisibleRect())) {
 61322:       cdi->mClip.RemoveRoundedCorners();
 61322:     }
 52292:   }
 47736: 
 68670:   nsRefPtr<nsRenderingContext> rc = new nsRenderingContext();
 49163:   rc->Init(presContext->DeviceContext(), aContext);
 49163: 
 52292:   Clip currentClip;
 79445:   bool setClipRect = false;
 49163: 
 47766:   for (i = 0; i < items.Length(); ++i) {
 47766:     ClippedDisplayItem* cdi = &items[i];
 47736: 
 47736:     if (cdi->mItem->GetVisibleRect().IsEmpty())
 47736:       continue;
 47736: 
 42593:     // If the new desired clip state is different from the current state,
 42593:     // update the clip.
 52292:     if (setClipRect != cdi->mClip.mHaveClipRect ||
 52292:         (cdi->mClip.mHaveClipRect && cdi->mClip != currentClip)) {
 42593:       if (setClipRect) {
 42593:         aContext->Restore();
 42593:       }
 52292:       setClipRect = cdi->mClip.mHaveClipRect;
 42593:       if (setClipRect) {
 52292:         currentClip = cdi->mClip;
 42593:         aContext->Save();
 97433:         NS_ASSERTION(commonClipCount < 100,
 97433:           "Maybe you really do have more than a hundred clipping rounded rects, or maybe something has gone wrong.");
 97433:         currentClip.ApplyTo(aContext, presContext, commonClipCount);
 42593:       }
 42593:     }
 47736: 
 62293:     if (cdi->mInactiveLayer) {
105568:       PaintInactiveLayer(builder, cdi->mItem, aContext, rc, layerBuilder);
 47751:     } else {
 80875:       nsIFrame* frame = cdi->mItem->GetUnderlyingFrame();
 80875:       if (frame) {
 80875:         frame->AddStateBits(NS_FRAME_PAINTED_THEBES);
 80875:       }
 93035: #ifdef MOZ_DUMP_PAINTING
 93035: 
 93035:       if (gfxUtils::sDumpPainting) {
 93035:         DebugPaintItem(rc, cdi->mItem, builder);
 93035:       } else {
 93035: #else
 93035:       {
 93035: #endif
 47736:         cdi->mItem->Paint(builder, rc);
 42593:       }
 93035:     }
 54261: 
105568:     if (layerBuilder->CheckDOMModified())
 54261:       break;
 47751:   }
 47736: 
103931:   {
103931:     ThebesLayerItemsEntry* entry =
105568:       layerBuilder->mThebesLayerItems.GetEntry(aLayer);
103931:     items.SwapElements(entry->mItems);
103931:   }
103931: 
 42593:   if (setClipRect) {
 42593:     aContext->Restore();
 42593:   }
 82255: 
 82255:   FlashPaint(aContext);
 42593: }
 42593: 
 79445: bool
 54261: FrameLayerBuilder::CheckDOMModified()
 54261: {
 54324:   if (!mRootPresContext ||
 54261:       mInitialDOMGeneration == mRootPresContext->GetDOMGeneration())
 80486:     return false;
 54261:   if (mDetectedDOMModification) {
 54261:     // Don't spam the console with extra warnings
 80486:     return true;
 54261:   }
 80486:   mDetectedDOMModification = true;
 54261:   // Painting is not going to complete properly. There's not much
 54261:   // we can do here though. Invalidating the window to get another repaint
 54261:   // is likely to lead to an infinite repaint loop.
 54261:   NS_WARNING("Detected DOM modification during paint, bailing out!");
 80486:   return true;
 54261: }
 54261: 
 82351: #ifdef MOZ_DUMP_PAINTING
105568: /* static */ void
107692: FrameLayerBuilder::DumpRetainedLayerTree(LayerManager* aManager, FILE* aFile, bool aDumpHtml)
 47736: {
107692:   aManager->Dump(aFile, "", aDumpHtml);
 47736: }
 47736: #endif
 47736: 
 52292: FrameLayerBuilder::Clip::Clip(const Clip& aOther, nsDisplayItem* aClipItem)
 52292:   : mRoundedClipRects(aOther.mRoundedClipRects),
 80486:     mHaveClipRect(true)
 52292: {
 52292:   nsDisplayItem::Type type = aClipItem->GetType();
 52292:   NS_ABORT_IF_FALSE(type == nsDisplayItem::TYPE_CLIP ||
 52292:                     type == nsDisplayItem::TYPE_CLIP_ROUNDED_RECT,
 52292:                     "unexpected display item type");
 52292:   nsDisplayClip* item = static_cast<nsDisplayClip*>(aClipItem);
 52292:   // Always intersect with mClipRect, even if we're going to add a
 52292:   // rounded rect.
 52292:   if (aOther.mHaveClipRect) {
 52292:     mClipRect.IntersectRect(aOther.mClipRect, item->GetClipRect());
 52292:   } else {
 52292:     mClipRect = item->GetClipRect();
 52292:   }
 52292: 
 52292:   if (type == nsDisplayItem::TYPE_CLIP_ROUNDED_RECT) {
 52292:     RoundedRect *rr = mRoundedClipRects.AppendElement();
 52292:     if (rr) {
 52292:       rr->mRect = item->GetClipRect();
 52292:       static_cast<nsDisplayClipRoundedRect*>(item)->GetRadii(rr->mRadii);
 52292:     }
 52292:   }
 52292: 
 52292:   // FIXME: Optimize away excess rounded rectangles due to the new addition.
 52292: }
 52292: 
 52292: void
 52292: FrameLayerBuilder::Clip::ApplyTo(gfxContext* aContext,
 97433:                                  nsPresContext* aPresContext,
108991:                                  uint32_t aBegin, uint32_t aEnd)
 97433: {
108991:   int32_t A2D = aPresContext->AppUnitsPerDevPixel();
 97433:   ApplyRectTo(aContext, A2D);
 97433:   ApplyRoundedRectsTo(aContext, A2D, aBegin, aEnd);
 97433: }
 97433: 
 97433: void
108991: FrameLayerBuilder::Clip::ApplyRectTo(gfxContext* aContext, int32_t A2D) const
 52292: {
 52292:   aContext->NewPath();
 52292:   gfxRect clip = nsLayoutUtils::RectToGfxRect(mClipRect, A2D);
 80486:   aContext->Rectangle(clip, true);
 52292:   aContext->Clip();
 97433: }
 52292: 
 97433: void
 97433: FrameLayerBuilder::Clip::ApplyRoundedRectsTo(gfxContext* aContext,
108991:                                              int32_t A2D,
108991:                                              uint32_t aBegin, uint32_t aEnd) const
 97433: {
108991:   aEnd = NS_MIN<uint32_t>(aEnd, mRoundedClipRects.Length());
108991: 
108991:   for (uint32_t i = aBegin; i < aEnd; ++i) {
 99572:     AddRoundedRectPathTo(aContext, A2D, mRoundedClipRects[i]);
 99572:     aContext->Clip();
 99572:   }
 99572: }
 52292: 
 99572: void
 99572: FrameLayerBuilder::Clip::DrawRoundedRectsTo(gfxContext* aContext,
108991:                                             int32_t A2D,
108991:                                             uint32_t aBegin, uint32_t aEnd) const
 99572: {
108991:   aEnd = NS_MIN<uint32_t>(aEnd, mRoundedClipRects.Length());
 99572: 
 99572:   if (aEnd - aBegin == 0)
 99572:     return;
 99572: 
 99572:   // If there is just one rounded rect we can just fill it, if there are more then we
 99572:   // must clip the rest to get the intersection of clips
 99572:   ApplyRoundedRectsTo(aContext, A2D, aBegin, aEnd - 1);
 99572:   AddRoundedRectPathTo(aContext, A2D, mRoundedClipRects[aEnd - 1]);
 99572:   aContext->Fill();
 99572: }
 99572: 
 99572: void
 99572: FrameLayerBuilder::Clip::AddRoundedRectPathTo(gfxContext* aContext,
108991:                                               int32_t A2D,
 99572:                                               const RoundedRect &aRoundRect) const
 99572: {
 52292:   gfxCornerSizes pixelRadii;
 99572:   nsCSSRendering::ComputePixelRadii(aRoundRect.mRadii, A2D, &pixelRadii);
 52292: 
 99572:   gfxRect clip = nsLayoutUtils::RectToGfxRect(aRoundRect.mRect, A2D);
 52292:   clip.Round();
 52292:   clip.Condition();
 52292: 
 52292:   aContext->NewPath();
 52292:   aContext->RoundedRectangle(clip, pixelRadii);
 52292: }
 52292: 
 59779: nsRect
 59779: FrameLayerBuilder::Clip::ApproximateIntersect(const nsRect& aRect) const
 59779: {
 59779:   nsRect r = aRect;
 59779:   if (mHaveClipRect) {
 59779:     r.IntersectRect(r, mClipRect);
 59779:   }
108991:   for (uint32_t i = 0, iEnd = mRoundedClipRects.Length();
 59779:        i < iEnd; ++i) {
 59779:     const Clip::RoundedRect &rr = mRoundedClipRects[i];
 59779:     nsRegion rgn = nsLayoutUtils::RoundedRectIntersectRect(rr.mRect, rr.mRadii, r);
 59779:     r = rgn.GetLargestRectangle();
 59779:   }
 59779:   return r;
 59779: }
 59779: 
 61322: // Test if (aXPoint, aYPoint) is in the ellipse with center (aXCenter, aYCenter)
 61322: // and radii aXRadius, aYRadius.
 61322: bool IsInsideEllipse(nscoord aXRadius, nscoord aXCenter, nscoord aXPoint,
 61322:                      nscoord aYRadius, nscoord aYCenter, nscoord aYPoint)
 61322: {
 61322:   float scaledX = float(aXPoint - aXCenter) / float(aXRadius);
 61322:   float scaledY = float(aYPoint - aYCenter) / float(aYRadius);
 61322:   return scaledX * scaledX + scaledY * scaledY < 1.0f;
 61322: }
 61322: 
 61322: bool
 61322: FrameLayerBuilder::Clip::IsRectClippedByRoundedCorner(const nsRect& aRect) const
 61322: {
 61322:   if (mRoundedClipRects.IsEmpty())
 61322:     return false;
 61322: 
 61322:   nsRect rect;
 61322:   rect.IntersectRect(aRect, NonRoundedIntersection());
108991:   for (uint32_t i = 0, iEnd = mRoundedClipRects.Length();
 61322:        i < iEnd; ++i) {
 61322:     const Clip::RoundedRect &rr = mRoundedClipRects[i];
 61322:     // top left
 61322:     if (rect.x < rr.mRect.x + rr.mRadii[NS_CORNER_TOP_LEFT_X] &&
 61322:         rect.y < rr.mRect.y + rr.mRadii[NS_CORNER_TOP_LEFT_Y]) {
 61322:       if (!IsInsideEllipse(rr.mRadii[NS_CORNER_TOP_LEFT_X],
 61322:                            rr.mRect.x + rr.mRadii[NS_CORNER_TOP_LEFT_X],
 61322:                            rect.x,
 61322:                            rr.mRadii[NS_CORNER_TOP_LEFT_Y],
 61322:                            rr.mRect.y + rr.mRadii[NS_CORNER_TOP_LEFT_Y],
 61322:                            rect.y)) {
 61322:         return true;
 61322:       }
 61322:     }
 61322:     // top right
 61322:     if (rect.XMost() > rr.mRect.XMost() - rr.mRadii[NS_CORNER_TOP_RIGHT_X] &&
 61322:         rect.y < rr.mRect.y + rr.mRadii[NS_CORNER_TOP_RIGHT_Y]) {
 61322:       if (!IsInsideEllipse(rr.mRadii[NS_CORNER_TOP_RIGHT_X],
 61322:                            rr.mRect.XMost() - rr.mRadii[NS_CORNER_TOP_RIGHT_X],
 61322:                            rect.XMost(),
 61322:                            rr.mRadii[NS_CORNER_TOP_RIGHT_Y],
 61322:                            rr.mRect.y + rr.mRadii[NS_CORNER_TOP_RIGHT_Y],
 61322:                            rect.y)) {
 61322:         return true;
 61322:       }
 61322:     }
 61322:     // bottom left
 61322:     if (rect.x < rr.mRect.x + rr.mRadii[NS_CORNER_BOTTOM_LEFT_X] &&
 61322:         rect.YMost() > rr.mRect.YMost() - rr.mRadii[NS_CORNER_BOTTOM_LEFT_Y]) {
 61322:       if (!IsInsideEllipse(rr.mRadii[NS_CORNER_BOTTOM_LEFT_X],
 61322:                            rr.mRect.x + rr.mRadii[NS_CORNER_BOTTOM_LEFT_X],
 61322:                            rect.x,
 61322:                            rr.mRadii[NS_CORNER_BOTTOM_LEFT_Y],
 61322:                            rr.mRect.YMost() - rr.mRadii[NS_CORNER_BOTTOM_LEFT_Y],
 61322:                            rect.YMost())) {
 61322:         return true;
 61322:       }
 61322:     }
 61322:     // bottom right
 61322:     if (rect.XMost() > rr.mRect.XMost() - rr.mRadii[NS_CORNER_BOTTOM_RIGHT_X] &&
 61322:         rect.YMost() > rr.mRect.YMost() - rr.mRadii[NS_CORNER_BOTTOM_RIGHT_Y]) {
 61322:       if (!IsInsideEllipse(rr.mRadii[NS_CORNER_BOTTOM_RIGHT_X],
 61322:                            rr.mRect.XMost() - rr.mRadii[NS_CORNER_BOTTOM_RIGHT_X],
 61322:                            rect.XMost(),
 61322:                            rr.mRadii[NS_CORNER_BOTTOM_RIGHT_Y],
 61322:                            rr.mRect.YMost() - rr.mRadii[NS_CORNER_BOTTOM_RIGHT_Y],
 61322:                            rect.YMost())) {
 61322:         return true;
 61322:       }
 61322:     }
 61322:   }
 61322:   return false;
 61322: }
 61322: 
 61322: nsRect
 61322: FrameLayerBuilder::Clip::NonRoundedIntersection() const
 61322: {
 61322:   nsRect result = mClipRect;
108991:   for (uint32_t i = 0, iEnd = mRoundedClipRects.Length();
 61322:        i < iEnd; ++i) {
 61322:     result.IntersectRect(result, mRoundedClipRects[i].mRect);
 61322:   }
 61322:   return result;
 61322: }
 61322: 
 61322: void
 61322: FrameLayerBuilder::Clip::RemoveRoundedCorners()
 61322: {
 61322:   if (mRoundedClipRects.IsEmpty())
 61322:     return;
 61322: 
 61322:   mClipRect = NonRoundedIntersection();
 61322:   mRoundedClipRects.Clear();
 61322: }
 61322: 
102919: gfxRect
108991: CalculateBounds(nsTArray<FrameLayerBuilder::Clip::RoundedRect> aRects, int32_t A2D)
 97433: {
102919:   nsRect bounds = aRects[0].mRect;
108991:   for (uint32_t i = 1; i < aRects.Length(); ++i) {
102919:     bounds.UnionRect(bounds, aRects[i].mRect);
 97433:    }
 97433:  
102919:   return nsLayoutUtils::RectToGfxRect(bounds, A2D);
 97433: }
 97433:  
 97433: void
 97433: ContainerState::SetupMaskLayer(Layer *aLayer, const FrameLayerBuilder::Clip& aClip,
108991:                                uint32_t aRoundedRectClipCount)
 97433: {
 97433:   // don't build an unnecessary mask
102919:   nsIntRect layerBounds = aLayer->GetVisibleRegion().GetBounds();
 97433:   if (aClip.mRoundedClipRects.IsEmpty() ||
 99647:       aRoundedRectClipCount <= 0 ||
102919:       layerBounds.IsEmpty()) {
 97433:     return;
 97433:   }
 97433: 
 97433:   // check if we can re-use the mask layer
 97433:   nsRefPtr<ImageLayer> maskLayer =  CreateOrRecycleMaskImageLayerFor(aLayer);
 97433:   MaskLayerUserData* userData = GetMaskLayerUserData(maskLayer);
102919: 
102919:   MaskLayerUserData newData;
102919:   newData.mRoundedClipRects.AppendElements(aClip.mRoundedClipRects);
102919:   if (aRoundedRectClipCount < newData.mRoundedClipRects.Length()) {
102919:     newData.mRoundedClipRects.TruncateLength(aRoundedRectClipCount);
102919:   }
102919:   newData.mScaleX = mParameters.mXScale;
102919:   newData.mScaleY = mParameters.mYScale;
102919: 
102919:   if (*userData == newData) {
 97433:     aLayer->SetMaskLayer(maskLayer);
 97433:     return;
 97433:   }
 97433: 
102919:   // calculate a more precise bounding rect
108991:   const int32_t A2D = mContainerFrame->PresContext()->AppUnitsPerDevPixel();
102919:   gfxRect boundingRect = CalculateBounds(newData.mRoundedClipRects, A2D);
102919:   boundingRect.Scale(mParameters.mXScale, mParameters.mYScale);
 97433: 
108991:   uint32_t maxSize = mManager->GetMaxTextureSize();
 99141:   NS_ASSERTION(maxSize > 0, "Invalid max texture size");
108991:   nsIntSize surfaceSize(NS_MIN<int32_t>(boundingRect.Width(), maxSize),
108991:                         NS_MIN<int32_t>(boundingRect.Height(), maxSize));
 99141: 
102919:   // maskTransform is applied to the clip when it is painted into the mask (as a
102919:   // component of imageTransform), and its inverse used when the mask is used for
102919:   // masking.
102919:   // It is the transform from the masked layer's space to mask space
102919:   gfxMatrix maskTransform;
102919:   maskTransform.Scale(float(surfaceSize.width)/float(boundingRect.Width()),
102919:                       float(surfaceSize.height)/float(boundingRect.Height()));
102919:   maskTransform.Translate(-boundingRect.TopLeft());
102919:   // imageTransform is only used when the clip is painted to the mask
102919:   gfxMatrix imageTransform = maskTransform;
102919:   imageTransform.Scale(mParameters.mXScale, mParameters.mYScale);
102919: 
102919:   // copy and transform the rounded rects
102919:   nsTArray<MaskLayerImageCache::PixelRoundedRect> roundedRects;
108991:   for (uint32_t i = 0; i < newData.mRoundedClipRects.Length(); ++i) {
102919:     roundedRects.AppendElement(
102919:       MaskLayerImageCache::PixelRoundedRect(newData.mRoundedClipRects[i],
102919:                                             mContainerFrame->PresContext()));
102919:     roundedRects[i].ScaleAndTranslate(imageTransform);
102919:   }
102919:  
102919:   // check to see if we can reuse a mask image
102919:   const MaskLayerImageCache::MaskLayerImageKey* key =
108201:     new MaskLayerImageCache::MaskLayerImageKey(roundedRects, aLayer->Manager()->GetBackendType());
102919:   const MaskLayerImageCache::MaskLayerImageKey* lookupKey = key;
102919: 
102919:   nsRefPtr<ImageContainer> container =
102919:     GetMaskLayerImageCache()->FindImageFor(&lookupKey);
102919: 
102919:   if (container) {
102919:     // track the returned key for the mask image
102919:     delete key;
102919:     key = lookupKey;
102919:   } else {
102919:     // no existing mask image, so build a new one
 97433:     nsRefPtr<gfxASurface> surface =
102921:       aLayer->Manager()->CreateOptimalMaskSurface(surfaceSize);
 97433: 
 97433:     // fail if we can't get the right surface
 97433:     if (!surface || surface->CairoStatus()) {
 97433:       NS_WARNING("Could not create surface for mask layer.");
 97433:       return;
 97433:     }
 97433: 
 97433:     nsRefPtr<gfxContext> context = new gfxContext(surface);
102919:     context->Multiply(imageTransform);
 97433: 
 99572:     // paint the clipping rects with alpha to create the mask
102921:     context->SetColor(gfxRGBA(1, 1, 1, 1));
 99572:     aClip.DrawRoundedRectsTo(context, A2D, 0, aRoundedRectClipCount);
 97433: 
 97433:     // build the image and container
102919:     container = aLayer->Manager()->CreateImageContainer();
 97433:     NS_ASSERTION(container, "Could not create image container for mask layer.");
108757:     static const ImageFormat format = CAIRO_SURFACE;
 97433:     nsRefPtr<Image> image = container->CreateImage(&format, 1);
 97433:     NS_ASSERTION(image, "Could not create image container for mask layer.");
 97433:     CairoImage::Data data;
 97433:     data.mSurface = surface;
 99141:     data.mSize = surfaceSize;
 97433:     static_cast<CairoImage*>(image.get())->SetData(data);
106770:     container->SetCurrentImageInTransaction(image);
 97433: 
102919:     GetMaskLayerImageCache()->PutImage(key, container);
102919:   }
102919: 
102910:   maskLayer->SetContainer(container);
106915:   maskLayer->SetBaseTransform(gfx3DMatrix::From2D(maskTransform.Invert()));
102919: 
102910:   // save the details of the clip in user data
102919:   userData->mScaleX = newData.mScaleX;
102919:   userData->mScaleY = newData.mScaleY;
102919:   userData->mRoundedClipRects.SwapElements(newData.mRoundedClipRects);
102919:   userData->mImageKey = key;
 97433: 
 97433:   aLayer->SetMaskLayer(maskLayer);
 97433:   return;
 97433: }
 97433: 
 42593: } // namespace mozilla
