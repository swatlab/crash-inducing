83485: /* -*- Mode: Java; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
83485:  * ***** BEGIN LICENSE BLOCK *****
83485:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
83485:  *
83485:  * The contents of this file are subject to the Mozilla Public License Version
83485:  * 1.1 (the "License"); you may not use this file except in compliance with
83485:  * the License. You may obtain a copy of the License at
83485:  * http://www.mozilla.org/MPL/
83485:  *
83485:  * Software distributed under the License is distributed on an "AS IS" basis,
83485:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
83485:  * for the specific language governing rights and limitations under the
83485:  * License.
83485:  *
83485:  * The Original Code is Mozilla Android code.
83485:  *
83485:  * The Initial Developer of the Original Code is Mozilla Foundation.
83485:  * Portions created by the Initial Developer are Copyright (C) 2011
83485:  * the Initial Developer. All Rights Reserved.
83485:  *
83485:  * Contributor(s):
83485:  *   Vladimir Vukicevic <vladimir@pobox.com>
83485:  *   Wes Johnston <wjohnston@mozilla.com>
83485:  *   Mark Finkle <mfinkle@mozilla.com>
83485:  *
83485:  * Alternatively, the contents of this file may be used under the terms of
83485:  * either the GNU General Public License Version 2 or later (the "GPL"), or
83485:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
83485:  * in which case the provisions of the GPL or the LGPL are applicable instead
83485:  * of those above. If you wish to allow use of your version of this file only
83485:  * under the terms of either the GPL or the LGPL, and not to allow others to
83485:  * use your version of this file under the terms of the MPL, indicate your
83485:  * decision by deleting the provisions above and replace them with the notice
83485:  * and other provisions required by the GPL or the LGPL. If you do not delete
83485:  * the provisions above, a recipient may use your version of this file under
83485:  * the terms of any one of the MPL, the GPL or the LGPL.
83485:  *
83485:  * ***** END LICENSE BLOCK ***** */
83485: 
83485: package org.mozilla.gecko;
83485: 
83551: import android.app.Activity;
85061: import android.app.ActionBar;
83551: import android.content.Intent;
85114: import android.content.ContentResolver;
83630: import android.content.Context;
83867: import android.content.res.Resources;
83774: import android.content.res.Configuration;
85114: import android.database.Cursor;
85114: import android.graphics.Bitmap;
85114: import android.graphics.BitmapFactory;
85061: import android.os.Build;
83551: import android.os.Bundle;
83551: import android.text.Editable;
83551: import android.text.TextWatcher;
83873: import android.util.AttributeSet;
83551: import android.util.Log;
85114: import android.view.ContextMenu;
85114: import android.view.ContextMenu.ContextMenuInfo;
83551: import android.view.KeyEvent;
85114: import android.view.MenuInflater;
85114: import android.view.MenuItem;
83551: import android.view.View;
83630: import android.view.inputmethod.InputMethodManager;
84657: import android.view.inputmethod.EditorInfo;
85114: import android.widget.AdapterView;
83949: import android.widget.Button;
83551: import android.widget.EditText;
85148: import android.widget.ExpandableListView;
83949: import android.widget.ImageButton;
85061: import android.widget.RelativeLayout;
85114: import android.widget.ListView;
85517: import android.widget.TabWidget;
85360: import android.widget.Toast;
85114: 
85148: import java.util.Map;
85148: 
85114: import org.mozilla.gecko.db.BrowserDB.URLColumns;
85114: import org.mozilla.gecko.db.BrowserDB;
83485: 
84211: import org.json.JSONObject;
84211: 
84211: public class AwesomeBar extends Activity implements GeckoEventListener {
83868:     private static final String LOGTAG = "GeckoAwesomeBar";
83868: 
83551:     static final String URL_KEY = "url";
83551:     static final String CURRENT_URL_KEY = "currenturl";
83551:     static final String TYPE_KEY = "type";
84211:     static final String SEARCH_KEY = "search";
83551:     static enum Type { ADD, EDIT };
83551: 
83541:     private String mType;
83597:     private AwesomeBarTabs mAwesomeTabs;
83873:     private AwesomeBarEditText mText;
83949:     private ImageButton mGoButton;
83485: 
83485:     @Override
83485:     public void onCreate(Bundle savedInstanceState) {
83485:         super.onCreate(savedInstanceState);
83485: 
83868:         Log.d(LOGTAG, "creating awesomebar");
83485: 
85325:         setContentView(R.layout.awesomebar);
83485: 
85061:         if (Build.VERSION.SDK_INT >= 11) {
85325:             RelativeLayout actionBarLayout = (RelativeLayout) getLayoutInflater().inflate(R.layout.awesomebar_search, null);
85061: 
85061:             GeckoActionBar.setDisplayOptions(this, ActionBar.DISPLAY_SHOW_CUSTOM, ActionBar.DISPLAY_SHOW_CUSTOM |
85061:                                                                                   ActionBar.DISPLAY_SHOW_HOME |
85061:                                                                                   ActionBar.DISPLAY_SHOW_TITLE |
85061:                                                                                   ActionBar.DISPLAY_USE_LOGO);
85061:             GeckoActionBar.setCustomView(this, actionBarLayout);
85061: 
85061:             mGoButton = (ImageButton) actionBarLayout.findViewById(R.id.awesomebar_button);
85061:             mText = (AwesomeBarEditText) actionBarLayout.findViewById(R.id.awesomebar_text);
85061:         } else {
85061:             mGoButton = (ImageButton) findViewById(R.id.awesomebar_button);
85061:             mText = (AwesomeBarEditText) findViewById(R.id.awesomebar_text);
85061:         }
85061: 
85517:         TabWidget tabWidget = (TabWidget) findViewById(android.R.id.tabs);
85517:         tabWidget.setDividerDrawable(null);
85517: 
83597:         mAwesomeTabs = (AwesomeBarTabs) findViewById(R.id.awesomebar_tabs);
83597:         mAwesomeTabs.setOnUrlOpenListener(new AwesomeBarTabs.OnUrlOpenListener() {
84210:             public void onUrlOpen(String url) {
85572:                 openUrlAndFinish(url);
83597:             }
84211: 
84211:             public void onSearch(String engine) {
84211:                 openSearchAndFinish(mText.getText().toString(), engine);
84211:             }
83597:         });
83485: 
83949:         mGoButton.setOnClickListener(new Button.OnClickListener() {
83949:             public void onClick(View v) {
85572:                 openUrlAndFinish(mText.getText().toString());
83949:             }
83949:         });
83949: 
83867:         Resources resources = getResources();
83867:         
83867:         int padding[] = { mText.getPaddingLeft(),
83867:                           mText.getPaddingTop(),
83867:                           mText.getPaddingRight(),
83867:                           mText.getPaddingBottom() };
83867: 
83867:         GeckoStateListDrawable states = new GeckoStateListDrawable();
83867:         states.initializeFilter(GeckoApp.mBrowserToolbar.getHighlightColor());
83867:         states.addState(new int[] { android.R.attr.state_focused }, resources.getDrawable(R.drawable.address_bar_url_pressed));
83867:         states.addState(new int[] { android.R.attr.state_pressed }, resources.getDrawable(R.drawable.address_bar_url_pressed));
83867:         states.addState(new int[] { }, resources.getDrawable(R.drawable.address_bar_url_default));
83867:         mText.setBackgroundDrawable(states);
83867: 
83867:         mText.setPadding(padding[0], padding[1], padding[2], padding[3]);
83867: 
83541:         Intent intent = getIntent();
83541:         String currentUrl = intent.getStringExtra(CURRENT_URL_KEY);
83551:         mType = intent.getStringExtra(TYPE_KEY);
83485:         if (currentUrl != null) {
83774:             mText.setText(currentUrl);
83774:             mText.selectAll();
83485:         }
83485: 
83873:         mText.setOnKeyPreImeListener(new AwesomeBarEditText.OnKeyPreImeListener() {
83873:             public boolean onKeyPreIme(View v, int keyCode, KeyEvent event) {
83873:                 InputMethodManager imm =
83873:                         (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
83873: 
85214:                 if (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_DOWN) {
85572:                     openUrlAndFinish(mText.getText().toString());
85214:                     return true;
85214:                 }
85214: 
83873:                 // If input method is in fullscreen mode, we want to dismiss
83873:                 // it instead of closing awesomebar straight away.
83873:                 if (!imm.isFullscreenMode() && keyCode == KeyEvent.KEYCODE_BACK) {
83873:                     cancelAndFinish();
83873:                     return true;
83873:                 }
83873: 
83873:                 return false;
83873:             }
83873:         });
83873: 
83774:         mText.addTextChangedListener(new TextWatcher() {
83485:             public void afterTextChanged(Editable s) {
83485:                 // do nothing
83485:             }
83485: 
83485:             public void beforeTextChanged(CharSequence s, int start, int count,
83485:                                           int after) {
83485:                 // do nothing
83485:             }
83485: 
83485:             public void onTextChanged(CharSequence s, int start, int before,
83485:                                       int count) {
83949:                 String text = s.toString();
83949: 
83949:                 mAwesomeTabs.filter(text);
83949:                 updateGoButton(text);
83485:             }
83485:         });
83485: 
83774:         mText.setOnKeyListener(new View.OnKeyListener() {
83485:             public boolean onKey(View v, int keyCode, KeyEvent event) {
83487:                 if (keyCode == KeyEvent.KEYCODE_ENTER) {
83541:                     if (event.getAction() != KeyEvent.ACTION_DOWN)
83541:                         return true;
83541: 
85572:                     openUrlAndFinish(mText.getText().toString());
83485:                     return true;
83487:                 } else {
83487:                     return false;
83487:                 }
83485:             }
83485:         });
83630: 
83774:         mText.setOnFocusChangeListener(new View.OnFocusChangeListener() {
83630:             public void onFocusChange(View v, boolean hasFocus) {
83630:                 if (!hasFocus) {
83630:                     InputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
83630:                     imm.hideSoftInputFromWindow(v.getWindowToken(), 0);
83630:                 }
83630:             }
83630:         });
84211: 
85114:         registerForContextMenu(mAwesomeTabs.findViewById(R.id.all_pages_list));
85114:         registerForContextMenu(mAwesomeTabs.findViewById(R.id.bookmarks_list));
85114:         registerForContextMenu(mAwesomeTabs.findViewById(R.id.history_list));
85114: 
84211:         GeckoAppShell.registerGeckoEventListener("SearchEngines:Data", this);
84211:         GeckoAppShell.sendEventToGecko(new GeckoEvent("SearchEngines:Get", null));
84211:     }
84211: 
84211:     public void handleMessage(String event, JSONObject message) {
84211:         try {
84211:             if (event.equals("SearchEngines:Data")) {
84211:                 mAwesomeTabs.setSearchEngines(message.getJSONArray("searchEngines"));
84211:             }
84211:         } catch (Exception e) {
84211:             // do nothing
84211:             Log.i(LOGTAG, "handleMessage throws " + e + " for message: " + event);
84211:         }
83485:     }
83485: 
83774:     @Override
83774:     public void onConfigurationChanged(Configuration newConfiguration) {
83774:         super.onConfigurationChanged(newConfiguration);
83774:     }
83774: 
83845:     @Override
83845:     public boolean onSearchRequested() {
83872:         cancelAndFinish();
83872:         return true;
83872:     }
83872: 
84489:     /*
84489:      * This method tries to guess if the given string could be a search query or URL
84489:      * Search examples:
84489:      *  foo
84489:      *  foo bar.com
84489:      *  foo http://bar.com
84489:      *
84489:      * URL examples
84489:      *  foo.com
84489:      *  foo.c
84489:      *  :foo
84489:      *  http://foo.com bar
84489:     */
84489:     private boolean isSearchUrl(String text) {
84489:         text = text.trim();
84489:         if (text.length() == 0)
84489:             return false;
84489: 
84489:         int colon = text.indexOf(':');
84489:         int dot = text.indexOf('.');
84489:         int space = text.indexOf(' ');
84489: 
84489:         // If a space is found before any dot or colon, we assume this is a search query
84489:         boolean spacedOut = space > -1 && (space < colon || space < dot);
84489: 
84522:         return spacedOut || (dot == -1 && colon == -1);
84489:     }
84489: 
83949:     private void updateGoButton(String text) {
83949:         if (text.length() == 0) {
83949:             mGoButton.setVisibility(View.GONE);
83949:             return;
83949:         }
83949: 
83949:         mGoButton.setVisibility(View.VISIBLE);
83949: 
83949:         int imageResource = R.drawable.ic_awesomebar_go;
84657:         int imeAction = EditorInfo.IME_ACTION_GO;
84657:         if (isSearchUrl(text)) {
83949:             imageResource = R.drawable.ic_awesomebar_search;
84657:             imeAction = EditorInfo.IME_ACTION_SEARCH;
84657:         }
84657:         mGoButton.setImageResource(imageResource);
84489: 
84657:         if ((mText.getImeOptions() & EditorInfo.IME_MASK_ACTION) != imeAction) {
84657:             InputMethodManager imm = (InputMethodManager) mText.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
84657:             mText.setImeOptions(imeAction);
84657:             imm.restartInput(mText);
84657:         }
83949:     }
83949: 
83872:     private void cancelAndFinish() {
83845:         setResult(Activity.RESULT_CANCELED);
83845:         finish();
83845:     }
83845: 
84211:     private void finishWithResult(Intent intent) {
84211:         setResult(Activity.RESULT_OK, intent);
84211:         finish();
84211:         overridePendingTransition(0, 0);
84211:     }
84211: 
83598:     private void openUrlAndFinish(String url) {
83598:         Intent resultIntent = new Intent();
83598:         resultIntent.putExtra(URL_KEY, url);
83598:         resultIntent.putExtra(TYPE_KEY, mType);
84211:         finishWithResult(resultIntent);
84211:     }
83598: 
84211:     private void openSearchAndFinish(String url, String engine) {
84211:         Intent resultIntent = new Intent();
84211:         resultIntent.putExtra(URL_KEY, url);
84211:         resultIntent.putExtra(TYPE_KEY, mType);
84211:         resultIntent.putExtra(SEARCH_KEY, engine);
84211:         finishWithResult(resultIntent);
83598:     }
83598: 
83485:     @Override
83801:     public boolean onKeyDown(int keyCode, KeyEvent event) {
83801:         // This method is called only if the key event was not handled
83801:         // by any of the views, which usually means the edit box lost focus
83801:         if (keyCode == KeyEvent.KEYCODE_BACK ||
83845:             keyCode == KeyEvent.KEYCODE_MENU ||
83845:             keyCode == KeyEvent.KEYCODE_SEARCH ||
83801:             keyCode == KeyEvent.KEYCODE_DPAD_UP ||
83801:             keyCode == KeyEvent.KEYCODE_DPAD_DOWN ||
83801:             keyCode == KeyEvent.KEYCODE_DPAD_LEFT ||
83801:             keyCode == KeyEvent.KEYCODE_DPAD_RIGHT ||
83954:             keyCode == KeyEvent.KEYCODE_DPAD_CENTER ||
84814:             keyCode == KeyEvent.KEYCODE_DEL ||
84814:             keyCode == KeyEvent.KEYCODE_VOLUME_UP ||
84814:             keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
83801:             return super.onKeyDown(keyCode, event);
83801:         } else {
83947:             int selStart = -1;
83947:             int selEnd = -1;
83947:             if (mText.hasSelection()) {
83947:                 selStart = mText.getSelectionStart();
83947:                 selEnd = mText.getSelectionEnd();
83947:             }
83947: 
83801:             // Return focus to the edit box, and dispatch the event to it
83801:             mText.requestFocusFromTouch();
83947: 
83947:             if (selStart >= 0) {
83947:                 // Restore the selection, which gets lost due to the focus switch
83947:                 mText.setSelection(selStart, selEnd);
83947:             }
83947: 
83801:             mText.dispatchKeyEvent(event);
83801:             return true;
83801:         }
83801:     }
83801: 
83801:     @Override
85172:     public void onResume() {
85172:         super.onResume();
85172:         if (mText != null && mText.getText() != null)
85172:             updateGoButton(mText.getText().toString());
85172:     }
85172: 
85172:     @Override
83485:     public void onDestroy() {
83485:         super.onDestroy();
83597:         mAwesomeTabs.destroy();
84211:         GeckoAppShell.unregisterGeckoEventListener("SearchEngines:Data", this);
83485:     }
83873: 
85148:     private Object mContextMenuSubject = null;
85114: 
85114:     @Override
85114:     public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfo) {
85114:         super.onCreateContextMenu(menu, view, menuInfo);
85148:         ListView list = (ListView) view;
85148:         Object selectedItem = null;
85148:         String title = "";
85114: 
85148:         if (view == (ListView)findViewById(R.id.history_list)) {
85514:             if (! (menuInfo instanceof ExpandableListView.ExpandableListContextMenuInfo)) {
85514:                 Log.e(LOGTAG, "menuInfo is not ExpandableListContextMenuInfo");
85514:                 return;
85514:             }
85148:             ExpandableListView.ExpandableListContextMenuInfo info = (ExpandableListView.ExpandableListContextMenuInfo) menuInfo;
85148:             ExpandableListView exList = (ExpandableListView)list;
85515:             int childPosition = ExpandableListView.getPackedPositionChild(info.packedPosition);
85515:             int groupPosition = ExpandableListView.getPackedPositionGroup(info.packedPosition);
85438: 
85438:             // Check if long tap is on a header row
85438:             if (groupPosition < 0 || childPosition < 0)
85438:                 return;
85438: 
85148:             selectedItem = exList.getExpandableListAdapter().getChild(groupPosition, childPosition);
85148: 
85390:             Map map = (Map)selectedItem;
85148:             title = (String)map.get(URLColumns.TITLE);
85148:         } else {
85514:             if (! (menuInfo instanceof AdapterView.AdapterContextMenuInfo)) {
85514:                 Log.e(LOGTAG, "menuInfo is not AdapterContextMenuInfo");
85514:                 return;
85514:             }
85114:             AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) menuInfo;
85148:             selectedItem = list.getItemAtPosition(info.position);
85763:             if (! (selectedItem instanceof Cursor)) {
85763:                 Log.e(LOGTAG, "item at " + info.position + " is not a Cursor");
85763:                 return;
85763:             }
85148:             Cursor cursor = (Cursor)selectedItem;
85148:             title = cursor.getString(cursor.getColumnIndexOrThrow(URLColumns.TITLE));
85148:         }
85148: 
85148:         if (selectedItem == null || !((selectedItem instanceof Cursor) || (selectedItem instanceof Map))) {
85148:             mContextMenuSubject = null;
85114:             return;
85114:         }
85114: 
85148:         mContextMenuSubject = selectedItem;
85114: 
85114:         MenuInflater inflater = getMenuInflater();
85114:         inflater.inflate(R.menu.awesomebar_contextmenu, menu);
85114:         
85360:         if (view != (ListView)findViewById(R.id.bookmarks_list)) {
85360:             MenuItem removeBookmarkItem = menu.findItem(R.id.remove_bookmark);
85360:             removeBookmarkItem.setVisible(false);
85360:         }
85360: 
85114:         menu.setHeaderTitle(title);
85114:     }
85114: 
85114:     @Override
85114:     public boolean onContextItemSelected(MenuItem item) {
85148:         if (mContextMenuSubject == null)
85114:             return false;
85114: 
85148:         String url = "";
85148:         byte[] b = null;
85148:         String title = "";
85148:         if (mContextMenuSubject instanceof Cursor) {
85148:             Cursor cursor = (Cursor)mContextMenuSubject;
85148:             url = cursor.getString(cursor.getColumnIndexOrThrow(URLColumns.URL));
85391:             b = cursor.getBlob(cursor.getColumnIndexOrThrow(URLColumns.FAVICON));
85148:             title = cursor.getString(cursor.getColumnIndexOrThrow(URLColumns.TITLE));
85148:         } else if (mContextMenuSubject instanceof Map) {
85390:             Map map = (Map)mContextMenuSubject;
85148:             url = (String)map.get(URLColumns.URL);
85148:             b = (byte[]) map.get(URLColumns.FAVICON);
85148:             title = (String)map.get(URLColumns.TITLE);
85148:         } else {
85148:             return false;
85148:         }
85148: 
85148:         mContextMenuSubject = null;
85114: 
85114:         switch (item.getItemId()) {
85114:             case R.id.open_new_tab: {
85114:                 GeckoApp.mAppContext.loadUrl(url, AwesomeBar.Type.ADD);
85642:                 Toast.makeText(this, R.string.new_tab_opened, Toast.LENGTH_SHORT).show();
85114:                 break;
85114:             }
85360:             case R.id.remove_bookmark: {
85360:                 ContentResolver resolver = Tabs.getInstance().getContentResolver();
85360:                 BrowserDB.removeBookmark(resolver, url);
85360:                 Toast.makeText(this, R.string.bookmark_removed, Toast.LENGTH_SHORT).show();
85360:                 break;
85360:             }
85114:             case R.id.add_to_launcher: {
85114:                 Bitmap bitmap = null;
85114:                 if (b != null)
85114:                     bitmap = BitmapFactory.decodeByteArray(b, 0, b.length);
85114:     
85114:                 GeckoAppShell.createShortcut(title, url, bitmap, "");
85114:                 break;
85114:             }
85114:             case R.id.share: {
85114:                 GeckoAppShell.openUriExternal(url, "text/plain", "", "",
85114:                                               Intent.ACTION_SEND, title);
85114:                 break;
85114:             }
85114:             default: {
85114:                 return super.onContextItemSelected(item);
85114:             }
85114:         }
85114:         return true;
85114:     }
85114: 
83873:     public static class AwesomeBarEditText extends EditText {
83873:         OnKeyPreImeListener mOnKeyPreImeListener;
83873: 
83873:         public interface OnKeyPreImeListener {
83873:             public boolean onKeyPreIme(View v, int keyCode, KeyEvent event);
83485:         }
83873: 
83873:         public AwesomeBarEditText(Context context, AttributeSet attrs) {
83873:             super(context, attrs);
83873:             mOnKeyPreImeListener = null;
83873:         }
83873: 
83873:         @Override
83873:         public boolean onKeyPreIme(int keyCode, KeyEvent event) {
83873:             if (mOnKeyPreImeListener != null)
83873:                 return mOnKeyPreImeListener.onKeyPreIme(this, keyCode, event);
83873: 
83873:             return false;
83873:         }
83873: 
83873:         public void setOnKeyPreImeListener(OnKeyPreImeListener listener) {
83873:             mOnKeyPreImeListener = listener;
83873:         }
83873:     }
83873: }
