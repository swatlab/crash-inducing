    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  * vim: set ts=2 sw=2 et tw=78:
98983:  * This Source Code Form is subject to the terms of the Mozilla Public
98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/.
    1:  */
    1: 
    1: /*
    1:  * structures that represent things to be painted (ordered in z-order),
    1:  * used during painting and hit testing
    1:  */
    1: 
    1: #include "nsDisplayList.h"
    1: 
    1: #include "nsCSSRendering.h"
68487: #include "nsRenderingContext.h"
    1: #include "nsISelectionController.h"
    1: #include "nsIPresShell.h"
    1: #include "nsRegion.h"
    1: #include "nsFrameManager.h"
    1: #include "gfxContext.h"
15992: #include "nsStyleStructInlines.h"
19214: #include "nsStyleTransformMatrix.h"
19214: #include "gfxMatrix.h"
19125: #include "nsSVGIntegrationUtils.h"
30519: #include "nsLayoutUtils.h"
47777: #include "nsIScrollableFrame.h"
48165: #include "nsThemeConstants.h"
    1: 
27153: #include "imgIContainer.h"
27153: #include "nsIInterfaceRequestorUtils.h"
38803: #include "BasicLayers.h"
58577: #include "nsBoxFrame.h"
67670: #include "nsViewportFrame.h"
82353: #include "nsSVGEffects.h"
82353: #include "nsSVGClipPathFrame.h"
96794: #include "sampler.h"
38803: 
95340: #include "mozilla/StandardInteger.h"
95340: 
42593: using namespace mozilla;
38803: using namespace mozilla::layers;
60443: typedef FrameMetrics::ViewID ViewID;
27153: 
    1: nsDisplayListBuilder::nsDisplayListBuilder(nsIFrame* aReferenceFrame,
79445:     Mode aMode, bool aBuildCaret)
    1:     : mReferenceFrame(aReferenceFrame),
    1:       mIgnoreScrollFrame(nsnull),
13961:       mCurrentTableItem(nsnull),
59778:       mFinalTransparentRegion(nsnull),
95645:       mCachedOffsetFrame(aReferenceFrame),
95645:       mCachedOffset(0, 0),
97420:       mGlassDisplayItem(nsnull),
58600:       mMode(aMode),
    1:       mBuildCaret(aBuildCaret),
80486:       mIgnoreSuppression(false),
80486:       mHadToIgnoreSuppression(false),
80486:       mIsAtRootOfPseudoStackingContext(false),
80486:       mIncludeAllOutOfFlows(false),
80486:       mSelectedFramesOnly(false),
80486:       mAccurateVisibleRegions(false),
80486:       mInTransform(false),
80486:       mSyncDecodeImages(false),
80486:       mIsPaintingToWindow(false),
80486:       mHasDisplayPort(false),
80486:       mHasFixedItems(false)
67670: {
43900:   MOZ_COUNT_CTOR(nsDisplayListBuilder);
47957:   PL_InitArenaPool(&mPool, "displayListArena", 1024,
47957:                    NS_MAX(NS_ALIGNMENT_OF(void*),NS_ALIGNMENT_OF(double))-1);
    1: 
  238:   nsPresContext* pc = aReferenceFrame->PresContext();
    1:   nsIPresShell *shell = pc->PresShell();
    1:   if (pc->IsRenderingOnlySelection()) {
    1:     nsCOMPtr<nsISelectionController> selcon(do_QueryInterface(shell));
    1:     if (selcon) {
    1:       selcon->GetSelection(nsISelectionController::SELECTION_NORMAL,
    1:                            getter_AddRefs(mBoundingSelection));
    1:     }
    1:   }
    1: 
67670:   if(mReferenceFrame->GetType() == nsGkAtoms::viewportFrame) {
67670:     ViewportFrame* viewportFrame = static_cast<ViewportFrame*>(mReferenceFrame);
77154:     if (!viewportFrame->GetChildList(nsIFrame::kFixedList).IsEmpty()) {
80486:       mHasFixedItems = true;
67670:     }
67670:   }
67670: 
54261:   LayerBuilder()->Init(this);
54261: 
47768:   PR_STATIC_ASSERT(nsDisplayItem::TYPE_MAX < (1 << nsDisplayItem::TYPE_BITS));
    1: }
    1: 
    1: static void MarkFrameForDisplay(nsIFrame* aFrame, nsIFrame* aStopAtFrame) {
  238:   nsFrameManager* frameManager = aFrame->PresContext()->PresShell()->FrameManager();
    1: 
    1:   for (nsIFrame* f = aFrame; f;
    1:        f = nsLayoutUtils::GetParentOrPlaceholderFor(frameManager, f)) {
    1:     if (f->GetStateBits() & NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO)
    1:       return;
    1:     f->AddStateBits(NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO);
    1:     if (f == aStopAtFrame) {
    1:       // we've reached a frame that we know will be painted, so we can stop.
    1:       break;
    1:     }
    1:   }
    1: }
    1: 
79445: static bool IsFixedFrame(nsIFrame* aFrame)
67670: {
67670:   return aFrame && aFrame->GetParent() && !aFrame->GetParent()->GetParent();
67670: }
67670: 
86220: static bool IsFixedItem(nsDisplayItem *aItem, nsDisplayListBuilder* aBuilder)
67670: {
67670:   nsIFrame* activeScrolledRoot =
86220:     nsLayoutUtils::GetActiveScrolledRootFor(aItem, aBuilder);
67670:   return activeScrolledRoot &&
97660:          !nsLayoutUtils::ScrolledByViewportScrolling(activeScrolledRoot,
97660:                                                      aBuilder);
67670: }
67670: 
79445: static bool ForceVisiblityForFixedItem(nsDisplayListBuilder* aBuilder,
86220:                                        nsDisplayItem* aItem)
67670: {
69752:   return aBuilder->GetDisplayPort() && aBuilder->GetHasFixedItems() &&
86220:          IsFixedItem(aItem, aBuilder);
67670: }
67670: 
69909: void nsDisplayListBuilder::SetDisplayPort(const nsRect& aDisplayPort)
69909: {
69909:     static bool fixedPositionLayersEnabled = getenv("MOZ_ENABLE_FIXED_POSITION_LAYERS") != 0;
69909:     if (fixedPositionLayersEnabled) {
80486:       mHasDisplayPort = true;
69909:       mDisplayPort = aDisplayPort;
69909:     }
69909: }
69909: 
67670: void nsDisplayListBuilder::MarkOutOfFlowFrameForDisplay(nsIFrame* aDirtyFrame,
67670:                                                         nsIFrame* aFrame,
67670:                                                         const nsRect& aDirtyRect)
67670: {
    1:   nsRect dirty = aDirtyRect - aFrame->GetOffsetTo(aDirtyFrame);
55040:   nsRect overflowRect = aFrame->GetVisualOverflowRect();
67670: 
67670:   if (mHasDisplayPort && IsFixedFrame(aFrame)) {
67670:     dirty = overflowRect;
67670:   }
67670: 
    1:   if (!dirty.IntersectRect(dirty, overflowRect))
    1:     return;
39965:   aFrame->Properties().Set(nsDisplayListBuilder::OutOfFlowDirtyRectProperty(),
39965:                            new nsRect(dirty));
    1: 
    1:   MarkFrameForDisplay(aFrame, aDirtyFrame);
    1: }
    1: 
    1: static void UnmarkFrameForDisplay(nsIFrame* aFrame) {
39965:   nsPresContext* presContext = aFrame->PresContext();
39965:   presContext->PropertyTable()->
39965:     Delete(aFrame, nsDisplayListBuilder::OutOfFlowDirtyRectProperty());
    1: 
39965:   nsFrameManager* frameManager = presContext->PresShell()->FrameManager();
    1: 
    1:   for (nsIFrame* f = aFrame; f;
    1:        f = nsLayoutUtils::GetParentOrPlaceholderFor(frameManager, f)) {
    1:     if (!(f->GetStateBits() & NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO))
    1:       return;
    1:     f->RemoveStateBits(NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO);
    1:   }
    1: }
    1: 
60443: static void RecordFrameMetrics(nsIFrame* aForFrame,
69189:                                nsIFrame* aScrollFrame,
60443:                                ContainerLayer* aRoot,
72251:                                const nsRect& aVisibleRect,
72251:                                const nsRect& aViewport,
63414:                                nsRect* aDisplayPort,
72251:                                ViewID aScrollId,
72251:                                const nsDisplayItem::ContainerParameters& aContainerParameters) {
60443:   nsPresContext* presContext = aForFrame->PresContext();
72251:   PRInt32 auPerDevPixel = presContext->AppUnitsPerDevPixel();
60443: 
72251:   nsIntRect visible = aVisibleRect.ScaleToNearestPixels(
72251:     aContainerParameters.mXScale, aContainerParameters.mYScale, auPerDevPixel);
60443:   aRoot->SetVisibleRegion(nsIntRegion(visible));
60443: 
60443:   FrameMetrics metrics;
60443: 
72251:   metrics.mViewport = aViewport.ScaleToNearestPixels(
72251:     aContainerParameters.mXScale, aContainerParameters.mYScale, auPerDevPixel);
72251: 
63414:   if (aDisplayPort) {
72251:     metrics.mDisplayPort = aDisplayPort->ScaleToNearestPixels(
72251:       aContainerParameters.mXScale, aContainerParameters.mYScale, auPerDevPixel);
60443:   }
60443: 
63414:   nsIScrollableFrame* scrollableFrame = nsnull;
69189:   if (aScrollFrame)
69189:     scrollableFrame = aScrollFrame->GetScrollTargetFrame();
63413: 
63413:   if (scrollableFrame) {
60449:     nsSize contentSize =
63413:       scrollableFrame->GetScrollRange().Size() +
63413:       scrollableFrame->GetScrollPortRect().Size();
95789:     metrics.mCSSContentSize = gfx::Size(nsPresContext::AppUnitsToFloatCSSPixels(contentSize.width),
95789:                                         nsPresContext::AppUnitsToFloatCSSPixels(contentSize.height));
72251:     metrics.mContentSize = contentSize.ScaleToNearestPixels(
72251:       aContainerParameters.mXScale, aContainerParameters.mYScale, auPerDevPixel);
72251:     metrics.mViewportScrollOffset = scrollableFrame->GetScrollPosition().ScaleToNearestPixels(
72251:       aContainerParameters.mXScale, aContainerParameters.mYScale, auPerDevPixel);
60868:   }
60868:   else {
60868:     nsSize contentSize = aForFrame->GetSize();
95789:     metrics.mCSSContentSize = gfx::Size(nsPresContext::AppUnitsToFloatCSSPixels(contentSize.width),
95789:                                         nsPresContext::AppUnitsToFloatCSSPixels(contentSize.height));
72251:     metrics.mContentSize = contentSize.ScaleToNearestPixels(
72251:       aContainerParameters.mXScale, aContainerParameters.mYScale, auPerDevPixel);
60443:   }
60443: 
60868:   metrics.mScrollId = aScrollId;
96930: 
96930:   nsIPresShell* presShell = presContext->GetPresShell();
96930:   metrics.mResolution = gfxSize(presShell->GetXResolution(), presShell->GetYResolution());
96930: 
60443:   aRoot->SetFrameMetrics(metrics);
60443: }
60443: 
    1: nsDisplayListBuilder::~nsDisplayListBuilder() {
 9798:   NS_ASSERTION(mFramesMarkedForDisplay.Length() == 0,
 9798:                "All frames should have been unmarked");
 9798:   NS_ASSERTION(mPresShellStates.Length() == 0,
 9798:                "All presshells should have been exited");
13961:   NS_ASSERTION(!mCurrentTableItem, "No table item should be active");
    1: 
    1:   PL_FreeArenaPool(&mPool);
    1:   PL_FinishArenaPool(&mPool);
43900:   MOZ_COUNT_DTOR(nsDisplayListBuilder);
    1: }
    1: 
32425: PRUint32
32425: nsDisplayListBuilder::GetBackgroundPaintFlags() {
32425:   PRUint32 flags = 0;
32425:   if (mSyncDecodeImages) {
32425:     flags |= nsCSSRendering::PAINTBG_SYNC_DECODE_IMAGES;
32425:   }
56434:   if (mIsPaintingToWindow) {
56434:     flags |= nsCSSRendering::PAINTBG_TO_WINDOW;
56434:   }
32425:   return flags;
32425: }
32425: 
59824: static PRUint64 RegionArea(const nsRegion& aRegion)
59824: {
59824:   PRUint64 area = 0;
59824:   nsRegionRectIterator iter(aRegion);
59824:   const nsRect* r;
59824:   while ((r = iter.Next()) != nsnull) {
59824:     area += PRUint64(r->width)*r->height;
59824:   }
59824:   return area;
59824: }
59824: 
31544: void
31544: nsDisplayListBuilder::SubtractFromVisibleRegion(nsRegion* aVisibleRegion,
69802:                                                 const nsRegion& aRegion)
31544: {
59779:   if (aRegion.IsEmpty())
59779:     return;
59779: 
32908:   nsRegion tmp;
32908:   tmp.Sub(*aVisibleRegion, aRegion);
32908:   // Don't let *aVisibleRegion get too complex, but don't let it fluff out
32908:   // to its bounds either, which can be very bad (see bug 516740).
59824:   // Do let aVisibleRegion get more complex if by doing so we reduce its
59824:   // area by at least half.
69802:   if (GetAccurateVisibleRegions() || tmp.GetNumRects() <= 15 ||
59824:       RegionArea(tmp) <= RegionArea(*aVisibleRegion)/2) {
32908:     *aVisibleRegion = tmp;
31544:   }
31544: }
31544: 
15969: nsCaret *
    1: nsDisplayListBuilder::GetCaret() {
39960:   nsRefPtr<nsCaret> caret = CurrentPresShellState()->mPresShell->GetCaret();
    1:   return caret;
    1: }
    1: 
    1: void
    1: nsDisplayListBuilder::EnterPresShell(nsIFrame* aReferenceFrame,
    1:                                      const nsRect& aDirtyRect) {
 9798:   PresShellState* state = mPresShellStates.AppendElement();
 9798:   if (!state)
 9798:     return;
 9798:   state->mPresShell = aReferenceFrame->PresContext()->PresShell();
 9798:   state->mCaretFrame = nsnull;
 9798:   state->mFirstFrameMarkedForDisplay = mFramesMarkedForDisplay.Length();
 9798: 
27834:   state->mPresShell->UpdateCanvasBackground();
27834: 
42240:   if (mIsPaintingToWindow) {
61717:     mReferenceFrame->AddPaintedPresShell(state->mPresShell);
61717:     
42240:     state->mPresShell->IncrementPaintCount();
42240:   }
42240: 
79445:   bool buildCaret = mBuildCaret;
51851:   if (mIgnoreSuppression || !state->mPresShell->IsPaintingSuppressed()) {
51851:     if (state->mPresShell->IsPaintingSuppressed()) {
80486:       mHadToIgnoreSuppression = true;
51851:     }
80486:     state->mIsBackgroundOnly = false;
51851:   } else {
80486:     state->mIsBackgroundOnly = true;
80486:     buildCaret = false;
51851:   }
51851: 
51851:   if (!buildCaret)
    1:     return;
    1: 
39960:   nsRefPtr<nsCaret> caret = state->mPresShell->GetCaret();
 9798:   state->mCaretFrame = caret->GetCaretFrame();
    1: 
 9798:   if (state->mCaretFrame) {
    1:     // Check if the dirty rect intersects with the caret's dirty rect.
    1:     nsRect caretRect =
 9798:       caret->GetCaretRect() + state->mCaretFrame->GetOffsetTo(aReferenceFrame);
    1:     if (caretRect.Intersects(aDirtyRect)) {
    1:       // Okay, our rects intersect, let's mark the frame and all of its ancestors.
 9798:       mFramesMarkedForDisplay.AppendElement(state->mCaretFrame);
 9798:       MarkFrameForDisplay(state->mCaretFrame, nsnull);
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsDisplayListBuilder::LeavePresShell(nsIFrame* aReferenceFrame,
27834:                                      const nsRect& aDirtyRect) {
 9798:   if (CurrentPresShellState()->mPresShell != aReferenceFrame->PresContext()->PresShell()) {
 9798:     // Must have not allocated a state for this presshell, presumably due
 9798:     // to OOM.
    1:     return;
 9798:   }
    1: 
 9798:   // Unmark and pop off the frames marked for display in this pres shell.
 9798:   PRUint32 firstFrameForShell = CurrentPresShellState()->mFirstFrameMarkedForDisplay;
 9798:   for (PRUint32 i = firstFrameForShell;
 9798:        i < mFramesMarkedForDisplay.Length(); ++i) {
 9798:     UnmarkFrameForDisplay(mFramesMarkedForDisplay[i]);
 9798:   }
 9798:   mFramesMarkedForDisplay.SetLength(firstFrameForShell);
 9798:   mPresShellStates.SetLength(mPresShellStates.Length() - 1);
    1: }
    1: 
    1: void
30782: nsDisplayListBuilder::MarkFramesForDisplayList(nsIFrame* aDirtyFrame,
30782:                                                const nsFrameList& aFrames,
    1:                                                const nsRect& aDirtyRect) {
30782:   for (nsFrameList::Enumerator e(aFrames); !e.AtEnd(); e.Next()) {
30782:     mFramesMarkedForDisplay.AppendElement(e.get());
30782:     MarkOutOfFlowFrameForDisplay(aDirtyFrame, e.get(), aDirtyRect);
    1:   }
    1: }
    1: 
98299: void
98299: nsDisplayListBuilder::MarkPreserve3DFramesForDisplayList(nsIFrame* aDirtyFrame, const nsRect& aDirtyRect) 
98299: {
98299:   nsAutoTArray<nsIFrame::ChildList,4> childListArray;
98299:   aDirtyFrame->GetChildLists(&childListArray);
98299:   nsIFrame::ChildListArrayIterator lists(childListArray);
98299:   for (; !lists.IsDone(); lists.Next()) {
98299:     nsFrameList::Enumerator childFrames(lists.CurrentList());
98299:     for (; !childFrames.AtEnd(); childFrames.Next()) {
98299:       nsIFrame *child = childFrames.get();
98299:       if (child->Preserves3D()) {
98299:         mFramesMarkedForDisplay.AppendElement(child);
98299:         nsRect dirty = aDirtyRect - child->GetOffsetTo(aDirtyFrame);
98299: 
98299:         child->Properties().Set(nsDisplayListBuilder::Preserve3DDirtyRectProperty(),
98299:                            new nsRect(dirty));
98299: 
98299:         MarkFrameForDisplay(child, aDirtyFrame);
98299:       }
98299:     }
98299:   }
98299: }
98299: 
    1: void*
    1: nsDisplayListBuilder::Allocate(size_t aSize) {
    1:   void *tmp;
    1:   PL_ARENA_ALLOCATE(tmp, &mPool, aSize);
    1:   return tmp;
    1: }
    1: 
    1: void nsDisplayListSet::MoveTo(const nsDisplayListSet& aDestination) const
    1: {
    1:   aDestination.BorderBackground()->AppendToTop(BorderBackground());
    1:   aDestination.BlockBorderBackgrounds()->AppendToTop(BlockBorderBackgrounds());
    1:   aDestination.Floats()->AppendToTop(Floats());
    1:   aDestination.Content()->AppendToTop(Content());
    1:   aDestination.PositionedDescendants()->AppendToTop(PositionedDescendants());
    1:   aDestination.Outlines()->AppendToTop(Outlines());
    1: }
    1: 
    1: void
 7819: nsDisplayList::FlattenTo(nsTArray<nsDisplayItem*>* aElements) {
    1:   nsDisplayItem* item;
    1:   while ((item = RemoveBottom()) != nsnull) {
47732:     if (item->GetType() == nsDisplayItem::TYPE_WRAP_LIST) {
    1:       item->GetList()->FlattenTo(aElements);
    1:       item->~nsDisplayItem();
    1:     } else {
    1:       aElements->AppendElement(item);
    1:     }
    1:   }
    1: }
    1: 
19125: nsRect
19125: nsDisplayList::GetBounds(nsDisplayListBuilder* aBuilder) const {
19125:   nsRect bounds;
19125:   for (nsDisplayItem* i = GetBottom(); i != nsnull; i = i->GetAbove()) {
95051:     bool snap;
95051:     bounds.UnionRect(bounds, i->GetBounds(aBuilder, &snap));
19125:   }
19125:   return bounds;
19125: }
19125: 
79445: bool
51633: nsDisplayList::ComputeVisibilityForRoot(nsDisplayListBuilder* aBuilder,
50393:                                         nsRegion* aVisibleRegion) {
96794:   SAMPLE_LABEL("nsDisplayList", "ComputeVisibilityForRoot");
51633:   nsRegion r;
51633:   r.And(*aVisibleRegion, GetBounds(aBuilder));
69802:   return ComputeVisibilityForSublist(aBuilder, aVisibleRegion, r.GetBounds(), r.GetBounds());
51633: }
51633: 
59779: static nsRegion
97420: TreatAsOpaque(nsDisplayItem* aItem, nsDisplayListBuilder* aBuilder)
57094: {
95051:   bool snap;
97420:   nsRegion opaque = aItem->GetOpaqueRegion(aBuilder, &snap);
57094:   if (aBuilder->IsForPluginGeometry()) {
70349:     // Treat all chrome items as opaque, unless their frames are opacity:0.
70349:     // Since opacity:0 frames generate an nsDisplayOpacity, that item will
70349:     // not be treated as opaque here, so opacity:0 chrome content will be
70349:     // effectively ignored, as it should be.
57094:     nsIFrame* f = aItem->GetUnderlyingFrame();
70349:     if (f && f->PresContext()->IsChrome() && f->GetStyleDisplay()->mOpacity != 0.0) {
95051:       opaque = aItem->GetBounds(aBuilder, &snap);
57094:     }
59779:   }
59779:   return opaque;
57094: }
57094: 
86220: static nsRect
86220: GetDisplayPortBounds(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem)
69752: {
86220:   // GetDisplayPortBounds() rectangle is used in order to restrict fixed aItem's
86220:   // visible bounds. nsDisplayTransform bounds already take item's
86220:   // transform into account, so there is no need to apply it here one more time.
86220:   // Start TransformRectToBoundsInAncestor() calculations from aItem's frame
86220:   // parent in this case.
69752:   nsIFrame* frame = aItem->GetUnderlyingFrame();
86220:   if (aItem->GetType() == nsDisplayItem::TYPE_TRANSFORM) {
86220:     frame = nsLayoutUtils::GetCrossDocParentFrame(frame);
86220:   }
86220: 
74753:   const nsRect* displayport = aBuilder->GetDisplayPort();
86353:   nsRect result = nsLayoutUtils::TransformAncestorRectToFrame(
74753:                     frame,
69752:                     nsRect(0, 0, displayport->width, displayport->height),
74753:                     aBuilder->ReferenceFrame());
86220:   result.MoveBy(aBuilder->ToReferenceFrame(frame));
86220:   return result;
69752: }
69752: 
79445: bool
51633: nsDisplayList::ComputeVisibilityForSublist(nsDisplayListBuilder* aBuilder,
51633:                                            nsRegion* aVisibleRegion,
61411:                                            const nsRect& aListVisibleBounds,
69802:                                            const nsRect& aAllowVisibleRegionExpansion) {
95051:   bool snap;
51633: #ifdef DEBUG
51633:   nsRegion r;
51633:   r.And(*aVisibleRegion, GetBounds(aBuilder));
68638:   NS_ASSERTION(r.GetBounds().IsEqualInterior(aListVisibleBounds),
51633:                "bad aListVisibleBounds");
51633: #endif
51633:   mVisibleRect = aListVisibleBounds;
79445:   bool anyVisible = false;
42246: 
 7819:   nsAutoTArray<nsDisplayItem*, 512> elements;
    1:   FlattenTo(&elements);
    1: 
79445:   bool forceTransparentSurface = false;
56101: 
 7819:   for (PRInt32 i = elements.Length() - 1; i >= 0; --i) {
 7819:     nsDisplayItem* item = elements[i];
 7819:     nsDisplayItem* belowItem = i < 1 ? nsnull : elements[i - 1];
    1: 
    1:     if (belowItem && item->TryMerge(aBuilder, belowItem)) {
    1:       belowItem->~nsDisplayItem();
 7819:       elements.ReplaceElementsAt(i - 1, 1, item);
    1:       continue;
    1:     }
    1: 
69189:     nsDisplayList* list = item->GetList();
69189:     if (list && item->ShouldFlattenAway(aBuilder)) {
69189:       // The elements on the list >= i no longer serve any use.
69189:       elements.SetLength(i);
69189:       list->FlattenTo(&elements);
69189:       i = elements.Length();
69189:       item->~nsDisplayItem();
69189:       continue;
69189:     }
69189: 
95051:     nsRect bounds = item->GetBounds(aBuilder, &snap);
33368: 
33368:     nsRegion itemVisible;
86220:     if (ForceVisiblityForFixedItem(aBuilder, item)) {
86220:       itemVisible.And(GetDisplayPortBounds(aBuilder, item), bounds);
69752:     } else {
33368:       itemVisible.And(*aVisibleRegion, bounds);
69752:     }
33368:     item->mVisibleRect = itemVisible.GetBounds();
33368: 
69802:     if (item->ComputeVisibility(aBuilder, aVisibleRegion, aAllowVisibleRegionExpansion)) {
80486:       anyVisible = true;
97420:       nsRegion opaque = TreatAsOpaque(item, aBuilder);
34210:       // Subtract opaque item from the visible region
69802:       aBuilder->SubtractFromVisibleRegion(aVisibleRegion, opaque);
97420:       if (aBuilder->NeedToForceTransparentSurfaceForItem(item) ||
97420:           (list && list->NeedsTransparentSurface())) {
97420:         forceTransparentSurface = true;
97420:       }
    1:     }
47763:     AppendToBottom(item);
    1:   }
31544: 
51633:   mIsOpaque = !aVisibleRegion->Intersects(mVisibleRect);
56101:   mForceTransparentSurface = forceTransparentSurface;
33368: #ifdef DEBUG
80486:   mDidComputeVisibility = true;
33368: #endif
47763:   return anyVisible;
    1: }
    1: 
42246: void nsDisplayList::PaintRoot(nsDisplayListBuilder* aBuilder,
68481:                               nsRenderingContext* aCtx,
42246:                               PRUint32 aFlags) const {
96794:   SAMPLE_LABEL("nsDisplayList", "PaintRoot");
42246:   PaintForFrame(aBuilder, aCtx, aBuilder->ReferenceFrame(), aFlags);
42246: }
42246: 
38803: /**
38803:  * We paint by executing a layer manager transaction, constructing a
38803:  * single layer representing the display list, and then making it the
38803:  * root of the layer manager, drawing into the ThebesLayers.
38803:  */
42246: void nsDisplayList::PaintForFrame(nsDisplayListBuilder* aBuilder,
68481:                                   nsRenderingContext* aCtx,
42246:                                   nsIFrame* aForFrame,
38805:                                   PRUint32 aFlags) const {
33368:   NS_ASSERTION(mDidComputeVisibility,
33368:                "Must call ComputeVisibility before calling Paint");
33368: 
38805:   nsRefPtr<LayerManager> layerManager;
60857:   bool allowRetaining = false;
60857:   bool doBeginTransaction = true;
38805:   if (aFlags & PAINT_USE_WIDGET_LAYERS) {
38805:     nsIFrame* referenceFrame = aBuilder->ReferenceFrame();
38805:     NS_ASSERTION(referenceFrame == nsLayoutUtils::GetDisplayRootFrame(referenceFrame),
38805:                  "Reference frame must be a display root for us to use the layer manager");
47148:     nsIWidget* window = referenceFrame->GetNearestWidget();
38805:     if (window) {
55858:       layerManager = window->GetLayerManager(&allowRetaining);
60857:       if (layerManager) {
60857:         doBeginTransaction = !(aFlags & PAINT_EXISTING_TRANSACTION);
47738:       }
38805:     }
38805:   }
38805:   if (!layerManager) {
38805:     if (!aCtx) {
38805:       NS_WARNING("Nowhere to paint into");
38805:       return;
38805:     }
47767:     layerManager = new BasicLayerManager();
38805:   }
38805: 
47739:   if (aFlags & PAINT_FLUSH_LAYERS) {
47739:     FrameLayerBuilder::InvalidateAllLayers(layerManager);
47739:   }
47739: 
60857:   if (doBeginTransaction) {
38805:     if (aCtx) {
38803:       layerManager->BeginTransactionWithTarget(aCtx->ThebesContext());
38805:     } else {
38805:       layerManager->BeginTransaction();
38805:     }
60857:   }
60857:   if (allowRetaining) {
60857:     aBuilder->LayerBuilder()->DidBeginRetainedLayerTransaction(layerManager);
60857:   }
38803: 
72231:   nsPresContext* presContext = aForFrame->PresContext();
72231:   nsIPresShell* presShell = presContext->GetPresShell();
72231: 
72231:   nsDisplayItem::ContainerParameters containerParameters
72231:     (presShell->GetXResolution(), presShell->GetYResolution());
54078:   nsRefPtr<ContainerLayer> root = aBuilder->LayerBuilder()->
72230:     BuildContainerLayerFor(aBuilder, layerManager, aForFrame, nsnull, *this,
72231:                            containerParameters, nsnull);
38803:   if (!root)
38803:     return;
72231:   // Root is being scaled up by the X/Y resolution. Scale it back down.
72231:   gfx3DMatrix rootTransform = root->GetTransform()*
77290:     gfx3DMatrix::ScalingMatrix(1.0f/containerParameters.mXScale,
72231:                                1.0f/containerParameters.mYScale, 1.0f);
72231:   root->SetTransform(rootTransform);
54080: 
60443:   ViewID id = presContext->IsRootContentDocument() ? FrameMetrics::ROOT_SCROLL_ID
60443:                                                    : FrameMetrics::NULL_SCROLL_ID;
42246: 
63413:   nsIFrame* rootScrollFrame = presShell->GetRootScrollFrame();
63414:   nsRect displayport;
63414:   bool usingDisplayport = false;
63413:   if (rootScrollFrame) {
63413:     nsIContent* content = rootScrollFrame->GetContent();
63413:     if (content) {
63414:       usingDisplayport = nsLayoutUtils::GetDisplayPort(content, &displayport);
63413:     }
63413:   }
63414:   RecordFrameMetrics(aForFrame, rootScrollFrame,
63414:                      root, mVisibleRect, mVisibleRect,
72251:                      (usingDisplayport ? &displayport : nsnull), id,
72251:                      containerParameters);
80777:   if (usingDisplayport &&
80777:       !(root->GetContentFlags() & Layer::CONTENT_OPAQUE)) {
80777:     // See bug 693938, attachment 567017
80777:     NS_WARNING("We don't support transparent content with displayports, force it to be opqaue");
80777:     root->SetContentFlags(Layer::CONTENT_OPAQUE);
80777:   }
54080: 
38803:   layerManager->SetRoot(root);
47771:   aBuilder->LayerBuilder()->WillEndTransaction(layerManager);
42593:   layerManager->EndTransaction(FrameLayerBuilder::DrawThebesLayer,
42593:                                aBuilder);
47736:   aBuilder->LayerBuilder()->DidEndTransaction(layerManager);
38803: 
47739:   if (aFlags & PAINT_FLUSH_LAYERS) {
47739:     FrameLayerBuilder::InvalidateAllLayers(layerManager);
47739:   }
47739: 
38803:   nsCSSRendering::DidPaint();
    1: }
38803: 
    1: PRUint32 nsDisplayList::Count() const {
    1:   PRUint32 count = 0;
    1:   for (nsDisplayItem* i = GetBottom(); i; i = i->GetAbove()) {
    1:     ++count;
    1:   }
    1:   return count;
    1: }
    1: 
    1: nsDisplayItem* nsDisplayList::RemoveBottom() {
    1:   nsDisplayItem* item = mSentinel.mAbove;
    1:   if (!item)
    1:     return nsnull;
    1:   mSentinel.mAbove = item->mAbove;
    1:   if (item == mTop) {
    1:     // must have been the only item
    1:     mTop = &mSentinel;
    1:   }
    1:   item->mAbove = nsnull;
    1:   return item;
    1: }
    1: 
    1: void nsDisplayList::DeleteAll() {
    1:   nsDisplayItem* item;
    1:   while ((item = RemoveBottom()) != nsnull) {
    1:     item->~nsDisplayItem();
    1:   }
    1: }
    1: 
79445: static bool
58577: GetMouseThrough(const nsIFrame* aFrame)
58577: {
58577:   if (!aFrame->IsBoxFrame())
80486:     return false;
58577: 
58577:   const nsIFrame* frame = aFrame;
58577:   while (frame) {
58577:     if (frame->GetStateBits() & NS_FRAME_MOUSE_THROUGH_ALWAYS) {
80486:       return true;
58577:     } else if (frame->GetStateBits() & NS_FRAME_MOUSE_THROUGH_NEVER) {
80486:       return false;
58577:     }
58577:     frame = frame->GetParentBox();
58577:   }
80486:   return false;
58577: }
58577: 
79926: // A list of frames, and their z depth. Used for sorting
79926: // the results of hit testing.
79926: struct FramesWithDepth
79926: {
79926:   FramesWithDepth(float aDepth) :
79926:     mDepth(aDepth)
79926:   {}
79926: 
79926:   bool operator<(const FramesWithDepth& aOther) const {
79926:     if (mDepth != aOther.mDepth) {
79926:       // We want to sort so that the shallowest item (highest depth value) is first
79926:       return mDepth > aOther.mDepth;
79926:     }
79926:     return this < &aOther;
79926:   }
79926:   bool operator==(const FramesWithDepth& aOther) const {
79926:     return this == &aOther;
79926:   }
79926: 
79926:   float mDepth;
79926:   nsTArray<nsIFrame*> mFrames;
79926: };
79926: 
79926: // Sort the frames by depth and then moves all the contained frames to the destination
79926: void FlushFramesArray(nsTArray<FramesWithDepth>& aSource, nsTArray<nsIFrame*>* aDest)
79926: {
79926:   if (aSource.IsEmpty()) {
79926:     return;
79926:   }
79926:   aSource.Sort();
79926:   PRUint32 length = aSource.Length();
79926:   for (PRUint32 i = 0; i < length; i++) {
79926:     aDest->MoveElementsFrom(aSource[i].mFrames);
79926:   }
79926:   aSource.Clear();
79926: }
79926: 
40570: void nsDisplayList::HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
40570:                             nsDisplayItem::HitTestState* aState,
40570:                             nsTArray<nsIFrame*> *aOutFrames) const {
 9799:   PRInt32 itemBufferStart = aState->mItemBuffer.Length();
    1:   nsDisplayItem* item;
    1:   for (item = GetBottom(); item; item = item->GetAbove()) {
 9799:     aState->mItemBuffer.AppendElement(item);
    1:   }
79926:   nsAutoTArray<FramesWithDepth, 16> temp;
 9799:   for (PRInt32 i = aState->mItemBuffer.Length() - 1; i >= itemBufferStart; --i) {
 9799:     // Pop element off the end of the buffer. We want to shorten the buffer
 9799:     // so that recursive calls to HitTest have more buffer space.
 9799:     item = aState->mItemBuffer[i];
 9799:     aState->mItemBuffer.SetLength(i);
 9799: 
95051:     bool snap;
95051:     if (aRect.Intersects(item->GetBounds(aBuilder, &snap))) {
78688:       nsAutoTArray<nsIFrame*, 16> outFrames;
40570:       item->HitTest(aBuilder, aRect, aState, &outFrames);
40570:       
79926:       // For 3d transforms with preserve-3d we add hit frames into the temp list 
79926:       // so we can sort them later, otherwise we add them directly to the output list.
79926:       nsTArray<nsIFrame*> *writeFrames = aOutFrames;
79926:       if (item->GetType() == nsDisplayItem::TYPE_TRANSFORM &&
79926:           item->GetUnderlyingFrame()->Preserves3D()) {
80242:         if (outFrames.Length()) {
79926:           nsDisplayTransform *transform = static_cast<nsDisplayTransform*>(item);
79926:           nsPoint point = aRect.TopLeft();
79926:           // A 1x1 rect means a point, otherwise use the center of the rect
79926:           if (aRect.width != 1 || aRect.height != 1) {
79926:             point = aRect.Center();
79926:           }
79926:           temp.AppendElement(FramesWithDepth(transform->GetHitDepthAtPoint(point)));
79926:           writeFrames = &temp[temp.Length() - 1].mFrames;
80242:         }
79926:       } else {
79926:         // We may have just finished a run of consecutive preserve-3d transforms, 
79926:         // so flush these into the destination array before processing our frame list.
79926:         FlushFramesArray(temp, aOutFrames);
79926:       }
79926: 
40570:       for (PRUint32 j = 0; j < outFrames.Length(); j++) {
40570:         nsIFrame *f = outFrames.ElementAt(j);
32021:         // Handle the XUL 'mousethrough' feature and 'pointer-events'.
58577:         if (!GetMouseThrough(f) &&
32021:             f->GetStyleVisibility()->mPointerEvents != NS_STYLE_POINTER_EVENTS_NONE) {
79926:           writeFrames->AppendElement(f);
    1:         }
    1:       }
    1:     }
 9799:   }
79926:   // Clear any remaining preserve-3d transforms.
79926:   FlushFramesArray(temp, aOutFrames);
19214:   NS_ASSERTION(aState->mItemBuffer.Length() == PRUint32(itemBufferStart),
 9799:                "How did we forget to pop some elements?");
    1: }
    1: 
    1: static void Sort(nsDisplayList* aList, PRInt32 aCount, nsDisplayList::SortLEQ aCmp,
    1:                  void* aClosure) {
    1:   if (aCount < 2)
    1:     return;
    1: 
    1:   nsDisplayList list1;
    1:   nsDisplayList list2;
    1:   int i;
    1:   PRInt32 half = aCount/2;
79445:   bool sorted = true;
    1:   nsDisplayItem* prev = nsnull;
    1:   for (i = 0; i < aCount; ++i) {
    1:     nsDisplayItem* item = aList->RemoveBottom();
    1:     (i < half ? &list1 : &list2)->AppendToTop(item);
    1:     if (sorted && prev && !aCmp(prev, item, aClosure)) {
80486:       sorted = false;
    1:     }
    1:     prev = item;
    1:   }
    1:   if (sorted) {
    1:     aList->AppendToTop(&list1);
    1:     aList->AppendToTop(&list2);
    1:     return;
    1:   }
    1:   
    1:   Sort(&list1, half, aCmp, aClosure);
    1:   Sort(&list2, aCount - half, aCmp, aClosure);
    1: 
    1:   for (i = 0; i < aCount; ++i) {
    1:     if (list1.GetBottom() &&
    1:         (!list2.GetBottom() ||
    1:          aCmp(list1.GetBottom(), list2.GetBottom(), aClosure))) {
    1:       aList->AppendToTop(list1.RemoveBottom());
    1:     } else {
    1:       aList->AppendToTop(list2.RemoveBottom());
    1:     }
    1:   }
    1: }
    1: 
79445: static bool IsContentLEQ(nsDisplayItem* aItem1, nsDisplayItem* aItem2,
    1:                            void* aClosure) {
    1:   // These GetUnderlyingFrame calls return non-null because we're only used
    1:   // in sorting
    1:   return nsLayoutUtils::CompareTreePosition(
    1:       aItem1->GetUnderlyingFrame()->GetContent(),
    1:       aItem2->GetUnderlyingFrame()->GetContent(),
 3233:       static_cast<nsIContent*>(aClosure)) <= 0;
    1: }
    1: 
79445: static bool IsZOrderLEQ(nsDisplayItem* aItem1, nsDisplayItem* aItem2,
    1:                           void* aClosure) {
    1:   // These GetUnderlyingFrame calls return non-null because we're only used
40129:   // in sorting.  Note that we can't just take the difference of the two
40129:   // z-indices here, because that might overflow a 32-bit int.
40129:   PRInt32 index1 = nsLayoutUtils::GetZIndex(aItem1->GetUnderlyingFrame());
40129:   PRInt32 index2 = nsLayoutUtils::GetZIndex(aItem2->GetUnderlyingFrame());
95691:   if (index1 == index2)
95691:     return IsContentLEQ(aItem1, aItem2, aClosure);
95691:   return index1 < index2;
    1: }
    1: 
    1: void nsDisplayList::ExplodeAnonymousChildLists(nsDisplayListBuilder* aBuilder) {
    1:   // See if there's anything to do
79445:   bool anyAnonymousItems = false;
    1:   nsDisplayItem* i;
    1:   for (i = GetBottom(); i != nsnull; i = i->GetAbove()) {
    1:     if (!i->GetUnderlyingFrame()) {
80486:       anyAnonymousItems = true;
    1:       break;
    1:     }
    1:   }
    1:   if (!anyAnonymousItems)
    1:     return;
    1: 
    1:   nsDisplayList tmp;
    1:   while ((i = RemoveBottom()) != nsnull) {
    1:     if (i->GetUnderlyingFrame()) {
    1:       tmp.AppendToTop(i);
    1:     } else {
    1:       nsDisplayList* list = i->GetList();
    1:       NS_ASSERTION(list, "leaf items can't be anonymous");
    1:       list->ExplodeAnonymousChildLists(aBuilder);
    1:       nsDisplayItem* j;
    1:       while ((j = list->RemoveBottom()) != nsnull) {
 3233:         tmp.AppendToTop(static_cast<nsDisplayWrapList*>(i)->
    1:             WrapWithClone(aBuilder, j));
    1:       }
    1:       i->~nsDisplayItem();
    1:     }
    1:   }
    1:   
    1:   AppendToTop(&tmp);
    1: }
    1: 
    1: void nsDisplayList::SortByZOrder(nsDisplayListBuilder* aBuilder,
    1:                                  nsIContent* aCommonAncestor) {
    1:   Sort(aBuilder, IsZOrderLEQ, aCommonAncestor);
    1: }
    1: 
    1: void nsDisplayList::SortByContentOrder(nsDisplayListBuilder* aBuilder,
    1:                                        nsIContent* aCommonAncestor) {
    1:   Sort(aBuilder, IsContentLEQ, aCommonAncestor);
    1: }
    1: 
    1: void nsDisplayList::Sort(nsDisplayListBuilder* aBuilder,
    1:                          SortLEQ aCmp, void* aClosure) {
    1:   ExplodeAnonymousChildLists(aBuilder);
    1:   ::Sort(this, Count(), aCmp, aClosure);
    1: }
    1: 
79445: bool nsDisplayItem::RecomputeVisibility(nsDisplayListBuilder* aBuilder,
47736:                                           nsRegion* aVisibleRegion) {
95051:   bool snap;
95051:   nsRect bounds = GetBounds(aBuilder, &snap);
47736: 
47736:   nsRegion itemVisible;
86220:   if (ForceVisiblityForFixedItem(aBuilder, this)) {
86220:     itemVisible.And(GetDisplayPortBounds(aBuilder, this), bounds);
69752:   } else {
47736:     itemVisible.And(*aVisibleRegion, bounds);
69752:   }
47736:   mVisibleRect = itemVisible.GetBounds();
47736: 
62700:   // When we recompute visibility within layers we don't need to
62700:   // expand the visible region for content behind plugins (the plugin
62700:   // is not in the layer).
69802:   if (!ComputeVisibility(aBuilder, aVisibleRegion, nsRect()))
80486:     return false;
47736: 
97420:   nsRegion opaque = TreatAsOpaque(this, aBuilder);
59825:   aBuilder->SubtractFromVisibleRegion(aVisibleRegion, opaque);
80486:   return true;
47736: }
47736: 
69786: nsRect
95051: nsDisplaySolidColor::GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap)
69786: {
95051:   *aSnap = true;
95051:   return mBounds;
69786: }
69786: 
69786: void
69786: nsDisplaySolidColor::Paint(nsDisplayListBuilder* aBuilder,
69786:                            nsRenderingContext* aCtx)
69786: {
27834:   aCtx->SetColor(mColor);
33368:   aCtx->FillRect(mVisibleRect);
27834: }
27834: 
48165: static void
60289: RegisterThemeGeometry(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame)
48165: {
48165:   nsIFrame* displayRoot = nsLayoutUtils::GetDisplayRootFrame(aFrame);
48165: 
48165:   for (nsIFrame* f = aFrame; f; f = f->GetParent()) {
48165:     // Bail out if we're in a transformed subtree
48165:     if (f->IsTransformed())
48165:       return;
48165:     // Bail out if we're not in the displayRoot's document
48165:     if (!f->GetParent() && f != displayRoot)
48165:       return;
48165:   }
48165: 
48165:   nsRect borderBox(aFrame->GetOffsetTo(displayRoot), aFrame->GetSize());
60289:   aBuilder->RegisterThemeGeometry(aFrame->GetStyleDisplay()->mAppearance,
60289:       borderBox.ToNearestPixels(aFrame->PresContext()->AppUnitsPerDevPixel()));
48165: }
48165: 
51260: nsDisplayBackground::nsDisplayBackground(nsDisplayListBuilder* aBuilder,
51260:                                          nsIFrame* aFrame)
95051:   : nsDisplayItem(aBuilder, aFrame)
48165: {
48165:   MOZ_COUNT_CTOR(nsDisplayBackground);
48165:   const nsStyleDisplay* disp = mFrame->GetStyleDisplay();
48165:   mIsThemed = mFrame->IsThemed(disp, &mThemeTransparency);
48165: 
67670:   if (mIsThemed) {
60289:     // Perform necessary RegisterThemeGeometry
67670:     if (disp->mAppearance == NS_THEME_MOZ_MAC_UNIFIED_TOOLBAR ||
67670:         disp->mAppearance == NS_THEME_TOOLBAR) {
60289:       RegisterThemeGeometry(aBuilder, aFrame);
97420:     } else if (disp->mAppearance == NS_THEME_WIN_BORDERLESS_GLASS ||
97420:                disp->mAppearance == NS_THEME_WIN_GLASS) {
97420:       aBuilder->SetGlassDisplayItem(this);
48165:     }
67670:   } else {
67670:     // Set HasFixedItems if we construct a background-attachment:fixed item
67670:     nsPresContext* presContext = mFrame->PresContext();
67670:     nsStyleContext* bgSC;
79445:     bool hasBG = nsCSSRendering::FindBackground(presContext, mFrame, &bgSC);
67670:     if (hasBG && bgSC->GetStyleBackground()->HasFixedBackground()) {
67670:       aBuilder->SetHasFixedItems();
67670:     }
67670:   }
48165: }
48165: 
55316: // Helper for RoundedRectIntersectsRect.
79445: static bool
55316: CheckCorner(nscoord aXOffset, nscoord aYOffset,
55316:             nscoord aXRadius, nscoord aYRadius)
55316: {
55316:   NS_ABORT_IF_FALSE(aXOffset > 0 && aYOffset > 0,
55316:                     "must not pass nonpositives to CheckCorner");
55316:   NS_ABORT_IF_FALSE(aXRadius >= 0 && aYRadius >= 0,
55316:                     "must not pass negatives to CheckCorner");
55316: 
55316:   // Avoid floating point math unless we're either (1) within the
55316:   // quarter-ellipse area at the rounded corner or (2) outside the
55316:   // rounding.
55316:   if (aXOffset >= aXRadius || aYOffset >= aYRadius)
80486:     return true;
55316: 
55316:   // Convert coordinates to a unit circle with (0,0) as the center of
55316:   // curvature, and see if we're inside the circle or outside.
55316:   float scaledX = float(aXRadius - aXOffset) / float(aXRadius);
55316:   float scaledY = float(aYRadius - aYOffset) / float(aYRadius);
55316:   return scaledX * scaledX + scaledY * scaledY < 1.0f;
55316: }
55316: 
55316: 
55316: /**
55316:  * Return whether any part of aTestRect is inside of the rounded
55316:  * rectangle formed by aBounds and aRadii (which are indexed by the
55316:  * NS_CORNER_* constants in nsStyleConsts.h).
55316:  *
55316:  * See also RoundedRectContainsRect.
55316:  */
79445: static bool
55316: RoundedRectIntersectsRect(const nsRect& aRoundedRect, nscoord aRadii[8],
55316:                           const nsRect& aTestRect)
55316: {
55316:   NS_ABORT_IF_FALSE(aTestRect.Intersects(aRoundedRect),
55316:                     "we should already have tested basic rect intersection");
55316: 
55316:   // distances from this edge of aRoundedRect to opposite edge of aTestRect,
55316:   // which we know are positive due to the Intersects check above.
55316:   nsMargin insets;
55316:   insets.top = aTestRect.YMost() - aRoundedRect.y;
55316:   insets.right = aRoundedRect.XMost() - aTestRect.x;
55316:   insets.bottom = aRoundedRect.YMost() - aTestRect.y;
55316:   insets.left = aTestRect.XMost() - aRoundedRect.x;
55316: 
55316:   // Check whether the bottom-right corner of aTestRect is inside the
55316:   // top left corner of aBounds when rounded by aRadii, etc.  If any
55316:   // corner is not, then fail; otherwise succeed.
55316:   return CheckCorner(insets.left, insets.top,
55316:                      aRadii[NS_CORNER_TOP_LEFT_X],
55316:                      aRadii[NS_CORNER_TOP_LEFT_Y]) &&
55316:          CheckCorner(insets.right, insets.top,
55316:                      aRadii[NS_CORNER_TOP_RIGHT_X],
55316:                      aRadii[NS_CORNER_TOP_RIGHT_Y]) &&
55316:          CheckCorner(insets.right, insets.bottom,
55316:                      aRadii[NS_CORNER_BOTTOM_RIGHT_X],
55316:                      aRadii[NS_CORNER_BOTTOM_RIGHT_Y]) &&
55316:          CheckCorner(insets.left, insets.bottom,
55316:                      aRadii[NS_CORNER_BOTTOM_LEFT_X],
55316:                      aRadii[NS_CORNER_BOTTOM_LEFT_Y]);
55316: }
55316: 
55316: // Check that the rounded border of aFrame, added to aToReferenceFrame,
55316: // intersects aRect.  Assumes that the unrounded border has already
55316: // been checked for intersection.
79445: static bool
55316: RoundedBorderIntersectsRect(nsIFrame* aFrame,
55316:                             const nsPoint& aFrameToReferenceFrame,
55316:                             const nsRect& aTestRect)
55316: {
60029:   if (!nsRect(aFrameToReferenceFrame, aFrame->GetSize()).Intersects(aTestRect))
80486:     return false;
60029: 
55316:   nscoord radii[8];
55316:   return !aFrame->GetBorderRadii(radii) ||
55316:          RoundedRectIntersectsRect(nsRect(aFrameToReferenceFrame,
55316:                                           aFrame->GetSize()),
55316:                                    radii, aTestRect);
55316: }
55316: 
27703: // Returns TRUE if aContainedRect is guaranteed to be contained in
27703: // the rounded rect defined by aRoundedRect and aRadii. Complex cases are
27703: // handled conservatively by returning FALSE in some situations where
27703: // a more thorough analysis could return TRUE.
55316: //
55316: // See also RoundedRectIntersectsRect.
79445: static bool RoundedRectContainsRect(const nsRect& aRoundedRect,
27703:                                       const nscoord aRadii[8],
27703:                                       const nsRect& aContainedRect) {
59779:   nsRegion rgn = nsLayoutUtils::RoundedRectIntersectRect(aRoundedRect, aRadii, aContainedRect);
59779:   return rgn.Contains(aContainedRect);
27703: }
27703: 
97537: bool
97537: nsDisplayBackground::TryOptimizeToImageLayer(nsDisplayListBuilder* aBuilder)
97537: {
97537:   if (mIsThemed)
97537:     return false;
97537: 
97537:   nsPresContext* presContext = mFrame->PresContext();
97537:   nsStyleContext* bgSC;
97537:   if (!nsCSSRendering::FindBackground(presContext, mFrame, &bgSC))
97537:     return false;
97537: 
97537:   bool drawBackgroundImage;
97537:   bool drawBackgroundColor;
97537:   nsCSSRendering::DetermineBackgroundColor(presContext,
97537:                                            bgSC,
97537:                                            mFrame,
97537:                                            drawBackgroundImage,
97537:                                            drawBackgroundColor);
97537: 
97537:   // For now we don't know how to draw image layers with a background color.
97537:   if (!drawBackgroundImage || drawBackgroundColor)
97537:     return false;
97537: 
97537:   const nsStyleBackground *bg = bgSC->GetStyleBackground();
97537: 
97537:   // We could pretty easily support multiple image layers, but for now we
97537:   // just punt here.
97537:   if (bg->mLayers.Length() != 1)
97537:     return false;
97537: 
97537:   PRUint32 flags = aBuilder->GetBackgroundPaintFlags();
97537:   nsPoint offset = ToReferenceFrame();
97537:   nsRect borderArea = nsRect(offset, mFrame->GetSize());
97537: 
97537:   const nsStyleBackground::Layer &layer = bg->mLayers[0];
97537: 
97537:   nsBackgroundLayerState state =
97537:     nsCSSRendering::PrepareBackgroundLayer(presContext,
97537:                                            mFrame,
97537:                                            flags,
97537:                                            borderArea,
97537:                                            borderArea,
97537:                                            *bg,
97537:                                            layer);
97537: 
99013:   nsImageRenderer* imageRenderer = &state.mImageRenderer;
97537:   // We only care about images here, not gradients.
99013:   if (imageRenderer->IsRasterImage())
99013:     return false;
99013: 
99013:   nsRefPtr<ImageContainer> imageContainer = imageRenderer->GetContainer();
99013:   // Image is not ready to be made into a layer yet
99013:   if (!imageContainer)
97537:     return false;
97537: 
97537:   // We currently can't handle tiled or partial backgrounds.
97537:   if (!state.mDestArea.IsEqualEdges(state.mFillArea)) {
97537:     return false;
97537:   }
97537: 
97537:   // Sub-pixel alignment is hard, lets punt on that.
97537:   if (state.mAnchor != nsPoint(0.0f, 0.0f)) {
97537:     return false;
97537:   }
97537: 
97537:   PRInt32 appUnitsPerDevPixel = presContext->AppUnitsPerDevPixel();
97537:   mDestRect = nsLayoutUtils::RectToGfxRect(state.mDestArea, appUnitsPerDevPixel);
99013:   mImageContainer = imageContainer;
97537: 
97537:   // Ok, we can turn this into a layer if needed.
97537:   return true;
97537: }
97537: 
97537: LayerState
97537: nsDisplayBackground::GetLayerState(nsDisplayListBuilder* aBuilder,
97537:                                    LayerManager* aManager,
97537:                                    const FrameLayerBuilder::ContainerParameters& aParameters)
97537: {
97537:   if (!aManager->IsCompositingCheap() ||
97537:       !nsLayoutUtils::GPUImageScalingEnabled() ||
97537:       !TryOptimizeToImageLayer(aBuilder)) {
97537:     return LAYER_NONE;
97537:   }
97537: 
97537:   gfxSize imageSize = mImageContainer->GetCurrentSize();
97537:   NS_ASSERTION(imageSize.width != 0 && imageSize.height != 0, "Invalid image size!");
97537: 
97537:   gfxRect destRect = mDestRect;
97537: 
97537:   destRect.width *= aParameters.mXScale;
97537:   destRect.height *= aParameters.mYScale;
97537: 
97537:   // Calculate the scaling factor for the frame.
97537:   gfxSize scale = gfxSize(destRect.width / imageSize.width, destRect.height / imageSize.height);
97537: 
97537:   // If we are not scaling at all, no point in separating this into a layer.
97537:   if (scale.width == 1.0f && scale.height == 1.0f) {
97537:     return LAYER_INACTIVE;
97537:   }
97537: 
97537:   // If the target size is pretty small, no point in using a layer.
97537:   if (destRect.width * destRect.height < 64 * 64) {
97537:     return LAYER_INACTIVE;
97537:   }
97537: 
97537:   return LAYER_ACTIVE;
97537: }
97537: 
97537: already_AddRefed<Layer>
97537: nsDisplayBackground::BuildLayer(nsDisplayListBuilder* aBuilder,
97537:                                 LayerManager* aManager,
97537:                                 const ContainerParameters& aParameters)
97537: {
97537:   nsRefPtr<ImageLayer> layer = aManager->CreateImageLayer();
97537:   layer->SetContainer(mImageContainer);
97537:   ConfigureLayer(layer);
97537:   return layer.forget();
97537: }
97537: 
97537: void
97537: nsDisplayBackground::ConfigureLayer(ImageLayer* aLayer)
97537: {
97537:   aLayer->SetFilter(nsLayoutUtils::GetGraphicsFilterForFrame(mFrame));
97537: 
97537:   gfxIntSize imageSize = mImageContainer->GetCurrentSize();
97537:   NS_ASSERTION(imageSize.width != 0 && imageSize.height != 0, "Invalid image size!");
97537: 
97537:   gfxMatrix transform;
97537:   transform.Translate(mDestRect.TopLeft());
97537:   transform.Scale(mDestRect.width/imageSize.width,
97537:                   mDestRect.height/imageSize.height);
97537:   aLayer->SetTransform(gfx3DMatrix::From2D(transform));
97537: 
97537:   aLayer->SetVisibleRegion(nsIntRect(0, 0, imageSize.width, imageSize.height));
97537: }
97537: 
55316: void
55316: nsDisplayBackground::HitTest(nsDisplayListBuilder* aBuilder,
55316:                              const nsRect& aRect,
55316:                              HitTestState* aState,
55316:                              nsTArray<nsIFrame*> *aOutFrames)
55316: {
75047:   if (mIsThemed) {
75047:     // For theme backgrounds, assume that any point in our border rect is a hit.
75047:     if (!nsRect(ToReferenceFrame(), mFrame->GetSize()).Intersects(aRect))
75047:       return;
75047:   } else {
75047:     if (!RoundedBorderIntersectsRect(mFrame, ToReferenceFrame(), aRect)) {
55316:       // aRect doesn't intersect our border-radius curve.
55316:       return;
55316:     }
75047:   }
55316: 
55316:   aOutFrames->AppendElement(mFrame);
55316: }
55316: 
79445: bool
47754: nsDisplayBackground::ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                        nsRegion* aVisibleRegion,
69802:                                        const nsRect& aAllowVisibleRegionExpansion)
47754: {
61411:   if (!nsDisplayItem::ComputeVisibility(aBuilder, aVisibleRegion,
69802:                                         aAllowVisibleRegionExpansion)) {
80486:     return false;
61411:   }
47763: 
47754:   // Return false if the background was propagated away from this
47754:   // frame. We don't want this display item to show up and confuse
47754:   // anything.
47754:   nsStyleContext* bgSC;
47754:   return mIsThemed ||
47754:     nsCSSRendering::FindBackground(mFrame->PresContext(), mFrame, &bgSC);
47754: }
47754: 
59779: nsRegion
60027: nsDisplayBackground::GetInsideClipRegion(nsPresContext* aPresContext,
95051:                                          PRUint8 aClip, const nsRect& aRect,
95051:                                          bool* aSnap)
59780: {
59780:   nsRegion result;
59780:   if (aRect.IsEmpty())
59780:     return result;
59780: 
59780:   nscoord radii[8];
59780:   nsRect clipRect;
79445:   bool haveRadii;
59780:   switch (aClip) {
59780:   case NS_STYLE_BG_CLIP_BORDER:
59780:     haveRadii = mFrame->GetBorderRadii(radii);
59780:     clipRect = nsRect(ToReferenceFrame(), mFrame->GetSize());
59780:     break;
59780:   case NS_STYLE_BG_CLIP_PADDING:
59780:     haveRadii = mFrame->GetPaddingBoxBorderRadii(radii);
59780:     clipRect = mFrame->GetPaddingRect() - mFrame->GetPosition() + ToReferenceFrame();
59780:     break;
59780:   case NS_STYLE_BG_CLIP_CONTENT:
59780:     haveRadii = mFrame->GetContentBoxBorderRadii(radii);
59780:     clipRect = mFrame->GetContentRect() - mFrame->GetPosition() + ToReferenceFrame();
59780:     break;
59780:   default:
59780:     NS_NOTREACHED("Unknown clip type");
59780:     return result;
59780:   }
59780: 
59780:   if (haveRadii) {
95051:     *aSnap = false;
95051:     result = nsLayoutUtils::RoundedRectIntersectRect(clipRect, radii, aRect);
59780:   } else {
98137:     result = clipRect.Intersect(aRect);
59780:   }
59780:   return result;
59780: }
59780: 
59780: nsRegion
59779: nsDisplayBackground::GetOpaqueRegion(nsDisplayListBuilder* aBuilder,
97420:                                      bool* aSnap) {
59779:   nsRegion result;
95051:   *aSnap = false;
    1:   // theme background overrides any other background
56101:   if (mIsThemed) {
59779:     if (mThemeTransparency == nsITheme::eOpaque) {
95051:       result = GetBounds(aBuilder, aSnap);
59779:     }
59779:     return result;
56101:   }
    1: 
40177:   nsStyleContext* bgSC;
59780:   nsPresContext* presContext = mFrame->PresContext();
95646:   if (!nsCSSRendering::FindBackground(presContext, mFrame, &bgSC))
59779:     return result;
40177:   const nsStyleBackground* bg = bgSC->GetStyleBackground();
27153:   const nsStyleBackground::Layer& bottomLayer = bg->BottomLayer();
27153: 
95051:   *aSnap = true;
95051: 
59780:   nsRect borderBox = nsRect(ToReferenceFrame(), mFrame->GetSize());
29987:   if (NS_GET_A(bg->mBackgroundColor) == 255 &&
59779:       !nsCSSRendering::IsCanvasFrame(mFrame)) {
95051:     result = GetInsideClipRegion(presContext, bottomLayer.mClip, borderBox, aSnap);
59779:   }
27153: 
59780:   // For policies other than EACH_BOX, don't try to optimize here, since
59780:   // this could easily lead to O(N^2) behavior inside InlineBackgroundData,
59780:   // which expects frames to be sent to it in content order, not reverse
59780:   // content order which we'll produce here.
59780:   // Of course, if there's only one frame in the flow, it doesn't matter.
59780:   if (bg->mBackgroundInlinePolicy == NS_STYLE_BG_INLINE_POLICY_EACH_BOX ||
59780:       (!mFrame->GetPrevContinuation() && !mFrame->GetNextContinuation())) {
59780:     NS_FOR_VISIBLE_BACKGROUND_LAYERS_BACK_TO_FRONT(i, bg) {
59780:       const nsStyleBackground::Layer& layer = bg->mLayers[i];
59780:       if (layer.mImage.IsOpaque()) {
59780:         nsRect r = nsCSSRendering::GetBackgroundLayerRect(presContext, mFrame,
59780:             borderBox, *bg, layer);
95051:         result.Or(result, GetInsideClipRegion(presContext, layer.mClip, r, aSnap));
59779:       }
59780:     }
59780:   }
59780: 
59779:   return result;
    1: }
    1: 
79445: bool
42436: nsDisplayBackground::IsUniform(nsDisplayListBuilder* aBuilder, nscolor* aColor) {
    1:   // theme background overrides any other background
60675:   if (mIsThemed) {
60675:     const nsStyleDisplay* disp = mFrame->GetStyleDisplay();
60675:     if (disp->mAppearance == NS_THEME_WIN_BORDERLESS_GLASS ||
60675:         disp->mAppearance == NS_THEME_WIN_GLASS) {
60675:       *aColor = NS_RGBA(0,0,0,0);
80486:       return true;
60675:     }
80486:     return false;
60675:   }
    1: 
40177:   nsStyleContext *bgSC;
79445:   bool hasBG =
40177:     nsCSSRendering::FindBackground(mFrame->PresContext(), mFrame, &bgSC);
42436:   if (!hasBG) {
42436:     *aColor = NS_RGBA(0,0,0,0);
80486:     return true;
42436:   }
40177:   const nsStyleBackground* bg = bgSC->GetStyleBackground();
31749:   if (bg->BottomLayer().mImage.IsEmpty() &&
25276:       bg->mImageCount == 1 &&
20039:       !nsLayoutUtils::HasNonZeroCorner(mFrame->GetStyleBorder()->mBorderRadius) &&
42436:       bg->BottomLayer().mClip == NS_STYLE_BG_CLIP_BORDER) {
42436:     // Canvas frames don't actually render their background color, since that
42436:     // gets propagated to the solid color of the viewport
42436:     // (see nsCSSRendering::PaintBackgroundWithSC)
42436:     *aColor = nsCSSRendering::IsCanvasFrame(mFrame) ? NS_RGBA(0,0,0,0)
42436:         : bg->mBackgroundColor;
80486:     return true;
42436:   }
80486:   return false;
    1: }
    1: 
79445: bool
50392: nsDisplayBackground::IsVaryingRelativeToMovingFrame(nsDisplayListBuilder* aBuilder,
50392:                                                     nsIFrame* aFrame)
    1: {
47777:   // theme background overrides any other background and is never fixed
47777:   if (mIsThemed)
80486:     return false;
47777: 
14202:   nsPresContext* presContext = mFrame->PresContext();
40177:   nsStyleContext *bgSC;
79445:   bool hasBG =
47754:     nsCSSRendering::FindBackground(presContext, mFrame, &bgSC);
    1:   if (!hasBG)
80486:     return false;
40177:   const nsStyleBackground* bg = bgSC->GetStyleBackground();
    1:   if (!bg->HasFixedBackground())
80486:     return false;
    1: 
50392:   // If aFrame is mFrame or an ancestor in this document, and aFrame is
50392:   // not the viewport frame, then moving aFrame will move mFrame
50392:   // relative to the viewport, so our fixed-pos background will change.
50392:   return aFrame->GetParent() &&
50392:     (aFrame == mFrame ||
50392:      nsLayoutUtils::IsProperAncestorFrame(aFrame, mFrame));
    1: }
    1: 
79445: bool
67668: nsDisplayBackground::ShouldFixToViewport(nsDisplayListBuilder* aBuilder)
47777: {
47777:   if (mIsThemed)
80486:     return false;
47777: 
47777:   nsPresContext* presContext = mFrame->PresContext();
47777:   nsStyleContext* bgSC;
79445:   bool hasBG =
47777:     nsCSSRendering::FindBackground(presContext, mFrame, &bgSC);
47777:   if (!hasBG)
80486:     return false;
47777: 
47777:   const nsStyleBackground* bg = bgSC->GetStyleBackground();
47777:   if (!bg->HasFixedBackground())
80486:     return false;
47777: 
47777:   NS_FOR_VISIBLE_BACKGROUND_LAYERS_BACK_TO_FRONT(i, bg) {
47777:     const nsStyleBackground::Layer& layer = bg->mLayers[i];
47777:     if (layer.mAttachment != NS_STYLE_BG_ATTACHMENT_FIXED &&
47777:         !layer.mImage.IsEmpty()) {
80486:       return false;
47777:     }
47777:     if (layer.mClip != NS_STYLE_BG_CLIP_BORDER)
80486:       return false;
47777:   }
47777: 
47777:   if (nsLayoutUtils::HasNonZeroCorner(mFrame->GetStyleBorder()->mBorderRadius))
80486:     return false;
47777: 
95051:   bool snap;
95051:   nsRect bounds = GetBounds(aBuilder, &snap);
47777:   nsIFrame* rootScrollFrame = presContext->PresShell()->GetRootScrollFrame();
47777:   if (!rootScrollFrame)
80486:     return false;
47777:   nsIScrollableFrame* scrollable = do_QueryFrame(rootScrollFrame);
47777:   nsRect scrollport = scrollable->GetScrollPortRect() +
47777:     aBuilder->ToReferenceFrame(rootScrollFrame);
47777:   return bounds.Contains(scrollport);
47777: }
47777: 
    1: void
    1: nsDisplayBackground::Paint(nsDisplayListBuilder* aBuilder,
68481:                            nsRenderingContext* aCtx) {
51261:   nsPoint offset = ToReferenceFrame();
32425:   PRUint32 flags = aBuilder->GetBackgroundPaintFlags();
28800:   nsDisplayItem* nextItem = GetAbove();
28800:   if (nextItem && nextItem->GetUnderlyingFrame() == mFrame &&
28800:       nextItem->GetType() == TYPE_BORDER) {
32425:     flags |= nsCSSRendering::PAINTBG_WILL_PAINT_BORDER;
28800:   }
  238:   nsCSSRendering::PaintBackground(mFrame->PresContext(), *aCtx, mFrame,
33368:                                   mVisibleRect,
33368:                                   nsRect(offset, mFrame->GetSize()),
28800:                                   flags);
    1: }
    1: 
    1: nsRect
95051: nsDisplayBackground::GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap) {
51266:   nsRect r(nsPoint(0,0), mFrame->GetSize());
51266:   nsPresContext* presContext = mFrame->PresContext();
60027: 
60027:   if (mIsThemed) {
51266:     presContext->GetTheme()->
51266:         GetWidgetOverflow(presContext->DeviceContext(), mFrame,
51266:                           mFrame->GetStyleDisplay()->mAppearance, &r);
51266:   }
 9369: 
95051:   *aSnap = true;
95051:   return r + ToReferenceFrame();
 9369: }
 9369: 
 9369: nsRect
95051: nsDisplayOutline::GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap) {
95051:   *aSnap = false;
57625:   return mFrame->GetVisualOverflowRectRelativeToSelf() + ToReferenceFrame();
    1: }
    1: 
    1: void
    1: nsDisplayOutline::Paint(nsDisplayListBuilder* aBuilder,
68481:                         nsRenderingContext* aCtx) {
    1:   // TODO join outlines together
51261:   nsPoint offset = ToReferenceFrame();
  238:   nsCSSRendering::PaintOutline(mFrame->PresContext(), *aCtx, mFrame,
33368:                                mVisibleRect,
33368:                                nsRect(offset, mFrame->GetSize()),
16424:                                mFrame->GetStyleContext());
    1: }
    1: 
79445: bool
33368: nsDisplayOutline::ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                     nsRegion* aVisibleRegion,
69802:                                     const nsRect& aAllowVisibleRegionExpansion) {
61411:   if (!nsDisplayItem::ComputeVisibility(aBuilder, aVisibleRegion,
69802:                                         aAllowVisibleRegionExpansion)) {
80486:     return false;
61411:   }
    1: 
    1:   const nsStyleOutline* outline = mFrame->GetStyleOutline();
51261:   nsRect borderBox(ToReferenceFrame(), mFrame->GetSize());
34210:   if (borderBox.Contains(aVisibleRegion->GetBounds()) &&
20039:       !nsLayoutUtils::HasNonZeroCorner(outline->mOutlineRadius)) {
19205:     if (outline->mOutlineOffset >= 0) {
    1:       // the visible region is entirely inside the border-rect, and the outline
    1:       // isn't rendered inside the border-rect, so the outline is not visible
80486:       return false;
    1:     }
    1:   }
    1: 
80486:   return true;
    1: }
    1: 
    1: void
55316: nsDisplayEventReceiver::HitTest(nsDisplayListBuilder* aBuilder,
55316:                                 const nsRect& aRect,
55316:                                 HitTestState* aState,
55316:                                 nsTArray<nsIFrame*> *aOutFrames)
55316: {
55316:   if (!RoundedBorderIntersectsRect(mFrame, ToReferenceFrame(), aRect)) {
55316:     // aRect doesn't intersect our border-radius curve.
55316:     return;
55316:   }
55316: 
55316:   aOutFrames->AppendElement(mFrame);
55316: }
55316: 
55316: void
    1: nsDisplayCaret::Paint(nsDisplayListBuilder* aBuilder,
68481:                       nsRenderingContext* aCtx) {
    1:   // Note: Because we exist, we know that the caret is visible, so we don't
    1:   // need to check for the caret's visibility.
51261:   mCaret->PaintCaret(aBuilder, aCtx, mFrame, ToReferenceFrame());
    1: }
    1: 
79445: bool
33368: nsDisplayBorder::ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                    nsRegion* aVisibleRegion,
69802:                                    const nsRect& aAllowVisibleRegionExpansion) {
61411:   if (!nsDisplayItem::ComputeVisibility(aBuilder, aVisibleRegion,
69802:                                         aAllowVisibleRegionExpansion)) {
80486:     return false;
61411:   }
    1: 
 6376:   nsRect paddingRect = mFrame->GetPaddingRect() - mFrame->GetPosition() +
51261:     ToReferenceFrame();
15992:   const nsStyleBorder *styleBorder;
 6376:   if (paddingRect.Contains(aVisibleRegion->GetBounds()) &&
15992:       !(styleBorder = mFrame->GetStyleBorder())->IsBorderImageLoaded() &&
20039:       !nsLayoutUtils::HasNonZeroCorner(styleBorder->mBorderRadius)) {
    1:     // the visible region is entirely inside the content rect, and no part
    1:     // of the border is rendered inside the content rect, so we are not
    1:     // visible
15992:     // Skip this if there's a border-image (which draws a background
15992:     // too) or if there is a border-radius (which makes the border draw
15992:     // further in).
80486:     return false;
    1:   }
    1: 
80486:   return true;
    1: }
    1: 
    1: void
    1: nsDisplayBorder::Paint(nsDisplayListBuilder* aBuilder,
68481:                        nsRenderingContext* aCtx) {
51261:   nsPoint offset = ToReferenceFrame();
  238:   nsCSSRendering::PaintBorder(mFrame->PresContext(), *aCtx, mFrame,
33368:                               mVisibleRect,
33368:                               nsRect(offset, mFrame->GetSize()),
16424:                               mFrame->GetStyleContext(),
16424:                               mFrame->GetSkipSides());
    1: }
    1: 
60027: nsRect
95051: nsDisplayBorder::GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap)
60027: {
86084:   nsRect borderBounds(ToReferenceFrame(), mFrame->GetSize());
86084:   borderBounds.Inflate(mFrame->GetStyleBorder()->GetImageOutset());
95051:   *aSnap = true;
95051:   return borderBounds;
60027: }
60027: 
35288: // Given a region, compute a conservative approximation to it as a list
35288: // of rectangles that aren't vertically adjacent (i.e., vertically
35288: // adjacent or overlapping rectangles are combined).
35288: // Right now this is only approximate, some vertically overlapping rectangles
35288: // aren't guaranteed to be combined.
35288: static void
35288: ComputeDisjointRectangles(const nsRegion& aRegion,
35288:                           nsTArray<nsRect>* aRects) {
35288:   nscoord accumulationMargin = nsPresContext::CSSPixelsToAppUnits(25);
35288:   nsRect accumulated;
35288:   nsRegionRectIterator iter(aRegion);
80486:   while (true) {
35288:     const nsRect* r = iter.Next();
35288:     if (r && !accumulated.IsEmpty() &&
35288:         accumulated.YMost() >= r->y - accumulationMargin) {
35288:       accumulated.UnionRect(accumulated, *r);
35288:       continue;
35288:     }
35288: 
35288:     if (!accumulated.IsEmpty()) {
35288:       aRects->AppendElement(accumulated);
68639:       accumulated.SetEmpty();
35288:     }
35288: 
35288:     if (!r)
35288:       break;
35288: 
35288:     accumulated = *r;
35288:   }
35288: }
35288: 
15700: void
24818: nsDisplayBoxShadowOuter::Paint(nsDisplayListBuilder* aBuilder,
68481:                                nsRenderingContext* aCtx) {
51261:   nsPoint offset = ToReferenceFrame();
35288:   nsRect borderRect = nsRect(offset, mFrame->GetSize());
35288:   nsPresContext* presContext = mFrame->PresContext();
35288:   nsAutoTArray<nsRect,10> rects;
35288:   ComputeDisjointRectangles(mVisibleRegion, &rects);
35288: 
98057:   SAMPLE_LABEL("nsDisplayBoxShadowOuter", "Paint");
35288:   for (PRUint32 i = 0; i < rects.Length(); ++i) {
35288:     aCtx->PushState();
68485:     aCtx->IntersectClip(rects[i]);
35288:     nsCSSRendering::PaintBoxShadowOuter(presContext, *aCtx, mFrame,
35288:                                         borderRect, rects[i]);
35288:     aCtx->PopState();
35288:   }
15700: }
15700: 
15700: nsRect
95051: nsDisplayBoxShadowOuter::GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap) {
95051:   *aSnap = false;
57625:   return mFrame->GetVisualOverflowRectRelativeToSelf() + ToReferenceFrame();
15700: }
15700: 
79445: bool
33368: nsDisplayBoxShadowOuter::ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                            nsRegion* aVisibleRegion,
69802:                                            const nsRect& aAllowVisibleRegionExpansion) {
61411:   if (!nsDisplayItem::ComputeVisibility(aBuilder, aVisibleRegion,
69802:                                         aAllowVisibleRegionExpansion)) {
80486:     return false;
61411:   }
24439: 
35288:   // Store the actual visible region
35288:   mVisibleRegion.And(*aVisibleRegion, mVisibleRect);
35288: 
51261:   nsPoint origin = ToReferenceFrame();
34210:   nsRect visibleBounds = aVisibleRegion->GetBounds();
27703:   nsRect frameRect(origin, mFrame->GetSize());
27703:   if (!frameRect.Contains(visibleBounds))
80486:     return true;
27703: 
24439:   // the visible region is entirely inside the border-rect, and box shadows
24439:   // never render within the border-rect (unless there's a border radius).
27703:   nscoord twipsRadii[8];
79445:   bool hasBorderRadii = mFrame->GetBorderRadii(twipsRadii);
27703:   if (!hasBorderRadii)
80486:     return false;
24439: 
27703:   return !RoundedRectContainsRect(frameRect, twipsRadii, visibleBounds);
24439: }
24439: 
24818: void
24818: nsDisplayBoxShadowInner::Paint(nsDisplayListBuilder* aBuilder,
68481:                                nsRenderingContext* aCtx) {
51261:   nsPoint offset = ToReferenceFrame();
35288:   nsRect borderRect = nsRect(offset, mFrame->GetSize());
35288:   nsPresContext* presContext = mFrame->PresContext();
35288:   nsAutoTArray<nsRect,10> rects;
35288:   ComputeDisjointRectangles(mVisibleRegion, &rects);
35288: 
98057:   SAMPLE_LABEL("nsDisplayBoxShadowInner", "Paint");
35288:   for (PRUint32 i = 0; i < rects.Length(); ++i) {
35288:     aCtx->PushState();
68485:     aCtx->IntersectClip(rects[i]);
35288:     nsCSSRendering::PaintBoxShadowInner(presContext, *aCtx, mFrame,
35288:                                         borderRect, rects[i]);
35288:     aCtx->PopState();
35288:   }
35288: }
35288: 
79445: bool
35288: nsDisplayBoxShadowInner::ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                            nsRegion* aVisibleRegion,
69802:                                            const nsRect& aAllowVisibleRegionExpansion) {
61411:   if (!nsDisplayItem::ComputeVisibility(aBuilder, aVisibleRegion,
69802:                                         aAllowVisibleRegionExpansion)) {
80486:     return false;
61411:   }
35288: 
35288:   // Store the actual visible region
35288:   mVisibleRegion.And(*aVisibleRegion, mVisibleRect);
80486:   return true;
24818: }
24818: 
51260: nsDisplayWrapList::nsDisplayWrapList(nsDisplayListBuilder* aBuilder,
51260:                                      nsIFrame* aFrame, nsDisplayList* aList)
51260:   : nsDisplayItem(aBuilder, aFrame) {
    1:   mList.AppendToTop(aList);
95693:   UpdateBounds(aBuilder);
    1: }
    1: 
51260: nsDisplayWrapList::nsDisplayWrapList(nsDisplayListBuilder* aBuilder,
51260:                                      nsIFrame* aFrame, nsDisplayItem* aItem)
51260:   : nsDisplayItem(aBuilder, aFrame) {
    1:   mList.AppendToTop(aItem);
95693:   UpdateBounds(aBuilder);
    1: }
    1: 
69189: nsDisplayWrapList::nsDisplayWrapList(nsDisplayListBuilder* aBuilder,
95645:                                      nsIFrame* aFrame, nsDisplayItem* aItem,
95645:                                      const nsPoint& aToReferenceFrame)
95645:   : nsDisplayItem(aBuilder, aFrame, aToReferenceFrame) {
95645:   mList.AppendToTop(aItem);
95645:   mBounds = mList.GetBounds(aBuilder);
69189: }
69189: 
    1: nsDisplayWrapList::~nsDisplayWrapList() {
    1:   mList.DeleteAll();
    1: }
    1: 
40570: void
40570: nsDisplayWrapList::HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
40570:                            HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames) {
40570:   mList.HitTest(aBuilder, aRect, aState, aOutFrames);
    1: }
    1: 
    1: nsRect
95051: nsDisplayWrapList::GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap) {
95051:   *aSnap = false;
95348:   return mBounds;
    1: }
    1: 
79445: bool
33368: nsDisplayWrapList::ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                      nsRegion* aVisibleRegion,
69802:                                      const nsRect& aAllowVisibleRegionExpansion) {
51633:   return mList.ComputeVisibilityForSublist(aBuilder, aVisibleRegion,
61411:                                            mVisibleRect,
69802:                                            aAllowVisibleRegionExpansion);
    1: }
    1: 
59779: nsRegion
59779: nsDisplayWrapList::GetOpaqueRegion(nsDisplayListBuilder* aBuilder,
97420:                                    bool* aSnap) {
95051:   *aSnap = false;
59779:   nsRegion result;
59779:   if (mList.IsOpaque()) {
95348:     // Everything within GetBounds that's visible is opaque.
95051:     result = GetBounds(aBuilder, aSnap);
59779:   }
59779:   return result;
    1: }
    1: 
79445: bool nsDisplayWrapList::IsUniform(nsDisplayListBuilder* aBuilder, nscolor* aColor) {
80486:   // We could try to do something but let's conservatively just return false.
80486:   return false;
    1: }
    1: 
79445: bool nsDisplayWrapList::IsVaryingRelativeToMovingFrame(nsDisplayListBuilder* aBuilder,
50392:                                                          nsIFrame* aFrame) {
14202:   NS_WARNING("nsDisplayWrapList::IsVaryingRelativeToMovingFrame called unexpectedly");
80486:   // We could try to do something but let's conservatively just return true.
80486:   return true;
    1: }
    1: 
    1: void nsDisplayWrapList::Paint(nsDisplayListBuilder* aBuilder,
68481:                               nsRenderingContext* aCtx) {
38803:   NS_ERROR("nsDisplayWrapList should have been flattened away for painting");
    1: }
    1: 
79445: bool nsDisplayWrapList::ChildrenCanBeInactive(nsDisplayListBuilder* aBuilder,
47751:                                               LayerManager* aManager,
97534:                                               const ContainerParameters& aParameters,
47751:                                               const nsDisplayList& aList,
47751:                                               nsIFrame* aActiveScrolledRoot) {
47751:   for (nsDisplayItem* i = aList.GetBottom(); i; i = i->GetAbove()) {
47751:     nsIFrame* f = i->GetUnderlyingFrame();
47751:     if (f) {
47751:       nsIFrame* activeScrolledRoot =
49156:         nsLayoutUtils::GetActiveScrolledRootFor(f, nsnull);
47751:       if (activeScrolledRoot != aActiveScrolledRoot)
80486:         return false;
47751:     }
47751: 
97534:     LayerState state = i->GetLayerState(aBuilder, aManager, aParameters);
47751:     if (state == LAYER_ACTIVE)
80486:       return false;
47751:     if (state == LAYER_NONE) {
47751:       nsDisplayList* list = i->GetList();
97534:       if (list && !ChildrenCanBeInactive(aBuilder, aManager, aParameters, *list, aActiveScrolledRoot))
80486:         return false;
47751:     }
47751:   }
80486:   return true;
47751: }
47751: 
59781: nsRect nsDisplayWrapList::GetComponentAlphaBounds(nsDisplayListBuilder* aBuilder)
55291: {
59781:   nsRect bounds;
55291:   for (nsDisplayItem* i = mList.GetBottom(); i; i = i->GetAbove()) {
59781:     bounds.UnionRect(bounds, i->GetComponentAlphaBounds(aBuilder));
55291:   }
59781:   return bounds;
55291: }
55291: 
    1: static nsresult
    1: WrapDisplayList(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
    1:                 nsDisplayList* aList, nsDisplayWrapper* aWrapper) {
50393:   if (!aList->GetTop())
    1:     return NS_OK;
    1:   nsDisplayItem* item = aWrapper->WrapList(aBuilder, aFrame, aList);
    1:   if (!item)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   // aList was emptied
    1:   aList->AppendToTop(item);
    1:   return NS_OK;
    1: }
    1: 
    1: static nsresult
    1: WrapEachDisplayItem(nsDisplayListBuilder* aBuilder,
    1:                     nsDisplayList* aList, nsDisplayWrapper* aWrapper) {
    1:   nsDisplayList newList;
    1:   nsDisplayItem* item;
    1:   while ((item = aList->RemoveBottom())) {
    1:     item = aWrapper->WrapItem(aBuilder, item);
    1:     if (!item)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     newList.AppendToTop(item);
    1:   }
    1:   // aList was emptied
    1:   aList->AppendToTop(&newList);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsDisplayWrapper::WrapLists(nsDisplayListBuilder* aBuilder,
    1:     nsIFrame* aFrame, const nsDisplayListSet& aIn, const nsDisplayListSet& aOut)
    1: {
    1:   nsresult rv = WrapListsInPlace(aBuilder, aFrame, aIn);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (&aOut == &aIn)
    1:     return NS_OK;
    1:   aOut.BorderBackground()->AppendToTop(aIn.BorderBackground());
    1:   aOut.BlockBorderBackgrounds()->AppendToTop(aIn.BlockBorderBackgrounds());
    1:   aOut.Floats()->AppendToTop(aIn.Floats());
    1:   aOut.Content()->AppendToTop(aIn.Content());
    1:   aOut.PositionedDescendants()->AppendToTop(aIn.PositionedDescendants());
    1:   aOut.Outlines()->AppendToTop(aIn.Outlines());
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsDisplayWrapper::WrapListsInPlace(nsDisplayListBuilder* aBuilder,
    1:     nsIFrame* aFrame, const nsDisplayListSet& aLists)
    1: {
    1:   nsresult rv;
    1:   if (WrapBorderBackground()) {
    1:     // Our border-backgrounds are in-flow
    1:     rv = WrapDisplayList(aBuilder, aFrame, aLists.BorderBackground(), this);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1:   // Our block border-backgrounds are in-flow
    1:   rv = WrapDisplayList(aBuilder, aFrame, aLists.BlockBorderBackgrounds(), this);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   // The floats are not in flow
    1:   rv = WrapEachDisplayItem(aBuilder, aLists.Floats(), this);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   // Our child content is in flow
    1:   rv = WrapDisplayList(aBuilder, aFrame, aLists.Content(), this);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   // The positioned descendants may not be in-flow
    1:   rv = WrapEachDisplayItem(aBuilder, aLists.PositionedDescendants(), this);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   // The outlines may not be in-flow
    1:   return WrapEachDisplayItem(aBuilder, aLists.Outlines(), this);
    1: }
    1: 
51260: nsDisplayOpacity::nsDisplayOpacity(nsDisplayListBuilder* aBuilder,
51260:                                    nsIFrame* aFrame, nsDisplayList* aList)
51260:     : nsDisplayWrapList(aBuilder, aFrame, aList) {
    1:   MOZ_COUNT_CTOR(nsDisplayOpacity);
    1: }
    1: 
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1: nsDisplayOpacity::~nsDisplayOpacity() {
    1:   MOZ_COUNT_DTOR(nsDisplayOpacity);
    1: }
    1: #endif
    1: 
59779: nsRegion nsDisplayOpacity::GetOpaqueRegion(nsDisplayListBuilder* aBuilder,
97420:                                            bool* aSnap) {
95051:   *aSnap = false;
    1:   // We are never opaque, if our opacity was < 1 then we wouldn't have
    1:   // been created.
59779:   return nsRegion();
    1: }
    1: 
38803: // nsDisplayOpacity uses layers for rendering
38803: already_AddRefed<Layer>
38803: nsDisplayOpacity::BuildLayer(nsDisplayListBuilder* aBuilder,
72230:                              LayerManager* aManager,
72230:                              const ContainerParameters& aContainerParameters) {
42593:   nsRefPtr<Layer> layer = aBuilder->LayerBuilder()->
72230:     BuildContainerLayerFor(aBuilder, aManager, mFrame, this, mList,
72230:                            aContainerParameters, nsnull);
38803:   if (!layer)
38803:     return nsnull;
    1: 
42246:   layer->SetOpacity(mFrame->GetStyleDisplay()->mOpacity);
38803:   return layer.forget();
38803: }
    1: 
80904: /**
80904:  * This doesn't take into account layer scaling --- the layer may be
80904:  * rendered at a higher (or lower) resolution, affecting the retained layer
80904:  * size --- but this should be good enough.
80904:  */
80904: static bool
80904: IsItemTooSmallForActiveLayer(nsDisplayItem* aItem)
80904: {
80904:   nsIntRect visibleDevPixels = aItem->GetVisibleRect().ToOutsidePixels(
80904:           aItem->GetUnderlyingFrame()->PresContext()->AppUnitsPerDevPixel());
80904:   static const int MIN_ACTIVE_LAYER_SIZE_DEV_PIXELS = 16;
80904:   return visibleDevPixels.Size() <
80904:     nsIntSize(MIN_ACTIVE_LAYER_SIZE_DEV_PIXELS, MIN_ACTIVE_LAYER_SIZE_DEV_PIXELS);
80904: }
80904: 
47751: nsDisplayItem::LayerState
47751: nsDisplayOpacity::GetLayerState(nsDisplayListBuilder* aBuilder,
97534:                                 LayerManager* aManager,
97534:                                 const ContainerParameters& aParameters) {
80904:   if (mFrame->AreLayersMarkedActive(nsChangeHint_UpdateOpacityLayer) &&
80904:       !IsItemTooSmallForActiveLayer(this))
47753:     return LAYER_ACTIVE;
47751:   nsIFrame* activeScrolledRoot =
49156:     nsLayoutUtils::GetActiveScrolledRootFor(mFrame, nsnull);
97534:   return !ChildrenCanBeInactive(aBuilder, aManager, aParameters, mList, activeScrolledRoot)
47751:       ? LAYER_ACTIVE : LAYER_INACTIVE;
47751: }
47751: 
79445: bool
69802: nsDisplayOpacity::ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                     nsRegion* aVisibleRegion,
69802:                                     const nsRect& aAllowVisibleRegionExpansion) {
    1:   // Our children are translucent so we should not allow them to subtract
    1:   // area from aVisibleRegion. We do need to find out what is visible under
    1:   // our children in the temporary compositing buffer, because if our children
    1:   // paint our entire bounds opaquely then we don't need an alpha channel in
    1:   // the temporary compositing buffer.
95051:   bool snap;
95051:   nsRect bounds = GetBounds(aBuilder, &snap);
38803:   nsRegion visibleUnderChildren;
38803:   visibleUnderChildren.And(*aVisibleRegion, bounds);
98137:   nsRect allowExpansion = bounds.Intersect(aAllowVisibleRegionExpansion);
38803:   return
61411:     nsDisplayWrapList::ComputeVisibility(aBuilder, &visibleUnderChildren,
69802:                                          allowExpansion);
    1: }
    1: 
79445: bool nsDisplayOpacity::TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem) {
    1:   if (aItem->GetType() != TYPE_OPACITY)
80486:     return false;
    1:   // items for the same content element should be merged into a single
    1:   // compositing group
    1:   // aItem->GetUnderlyingFrame() returns non-null because it's nsDisplayOpacity
    1:   if (aItem->GetUnderlyingFrame()->GetContent() != mFrame->GetContent())
80486:     return false;
95566:   MergeFromTrackingMergedFrames(static_cast<nsDisplayOpacity*>(aItem));
80486:   return true;
    1: }
    1: 
51260: nsDisplayOwnLayer::nsDisplayOwnLayer(nsDisplayListBuilder* aBuilder,
51260:                                      nsIFrame* aFrame, nsDisplayList* aList)
51260:     : nsDisplayWrapList(aBuilder, aFrame, aList) {
47744:   MOZ_COUNT_CTOR(nsDisplayOwnLayer);
47744: }
47744: 
47744: #ifdef NS_BUILD_REFCNT_LOGGING
47744: nsDisplayOwnLayer::~nsDisplayOwnLayer() {
47744:   MOZ_COUNT_DTOR(nsDisplayOwnLayer);
47744: }
47744: #endif
47744: 
47744: // nsDisplayOpacity uses layers for rendering
47744: already_AddRefed<Layer>
47744: nsDisplayOwnLayer::BuildLayer(nsDisplayListBuilder* aBuilder,
72230:                               LayerManager* aManager,
72230:                               const ContainerParameters& aContainerParameters) {
47744:   nsRefPtr<Layer> layer = aBuilder->LayerBuilder()->
72230:     BuildContainerLayerFor(aBuilder, aManager, mFrame, this, mList,
72230:                            aContainerParameters, nsnull);
47744:   return layer.forget();
47744: }
47744: 
60447: nsDisplayScrollLayer::nsDisplayScrollLayer(nsDisplayListBuilder* aBuilder,
60447:                                            nsDisplayList* aList,
60447:                                            nsIFrame* aForFrame,
69189:                                            nsIFrame* aScrolledFrame,
69189:                                            nsIFrame* aScrollFrame)
69189:   : nsDisplayWrapList(aBuilder, aForFrame, aList)
69189:   , mScrollFrame(aScrollFrame)
69189:   , mScrolledFrame(aScrolledFrame)
60447: {
60447: #ifdef NS_BUILD_REFCNT_LOGGING
60466:   MOZ_COUNT_CTOR(nsDisplayScrollLayer);
60447: #endif
60447: 
69189:   NS_ASSERTION(mScrolledFrame && mScrolledFrame->GetContent(),
60447:                "Need a child frame with content");
60447: }
60447: 
69189: nsDisplayScrollLayer::nsDisplayScrollLayer(nsDisplayListBuilder* aBuilder,
69189:                                            nsDisplayItem* aItem,
69189:                                            nsIFrame* aForFrame,
69189:                                            nsIFrame* aScrolledFrame,
69189:                                            nsIFrame* aScrollFrame)
69189:   : nsDisplayWrapList(aBuilder, aForFrame, aItem)
69189:   , mScrollFrame(aScrollFrame)
69189:   , mScrolledFrame(aScrolledFrame)
69189: {
69189: #ifdef NS_BUILD_REFCNT_LOGGING
69189:   MOZ_COUNT_CTOR(nsDisplayScrollLayer);
69189: #endif
69189: 
69189:   NS_ASSERTION(mScrolledFrame && mScrolledFrame->GetContent(),
69189:                "Need a child frame with content");
69189: }
69189: 
69189: nsDisplayScrollLayer::nsDisplayScrollLayer(nsDisplayListBuilder* aBuilder,
69189:                                            nsIFrame* aForFrame,
69189:                                            nsIFrame* aScrolledFrame,
69189:                                            nsIFrame* aScrollFrame)
69189:   : nsDisplayWrapList(aBuilder, aForFrame)
69189:   , mScrollFrame(aScrollFrame)
69189:   , mScrolledFrame(aScrolledFrame)
69189: {
69189: #ifdef NS_BUILD_REFCNT_LOGGING
69189:   MOZ_COUNT_CTOR(nsDisplayScrollLayer);
69189: #endif
69189: 
69189:   NS_ASSERTION(mScrolledFrame && mScrolledFrame->GetContent(),
69189:                "Need a child frame with content");
69189: }
69189: 
69189: #ifdef NS_BUILD_REFCNT_LOGGING
69189: nsDisplayScrollLayer::~nsDisplayScrollLayer()
69189: {
69189:   MOZ_COUNT_DTOR(nsDisplayScrollLayer);
69189: }
69189: #endif
69189: 
60447: already_AddRefed<Layer>
60447: nsDisplayScrollLayer::BuildLayer(nsDisplayListBuilder* aBuilder,
72230:                                  LayerManager* aManager,
72230:                                  const ContainerParameters& aContainerParameters) {
60447:   nsRefPtr<ContainerLayer> layer = aBuilder->LayerBuilder()->
72230:     BuildContainerLayerFor(aBuilder, aManager, mFrame, this, mList,
72230:                            aContainerParameters, nsnull);
60447: 
60447:   // Get the already set unique ID for scrolling this content remotely.
60447:   // Or, if not set, generate a new ID.
69189:   nsIContent* content = mScrolledFrame->GetContent();
60450:   ViewID scrollId = nsLayoutUtils::FindIDFor(content);
60447: 
69189:   nsRect viewport = mScrollFrame->GetRect() -
69189:                     mScrollFrame->GetPosition() +
69189:                     aBuilder->ToReferenceFrame(mScrollFrame);
60447: 
63414:   bool usingDisplayport = false;
63414:   nsRect displayport;
63414:   if (content) {
63414:     usingDisplayport = nsLayoutUtils::GetDisplayPort(content, &displayport);
63414:   }
69189:   RecordFrameMetrics(mScrolledFrame, mScrollFrame, layer, mVisibleRect, viewport,
72251:                      (usingDisplayport ? &displayport : nsnull), scrollId,
72251:                      aContainerParameters);
60447: 
60447:   return layer.forget();
60447: }
60447: 
79445: bool
60447: nsDisplayScrollLayer::ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                         nsRegion* aVisibleRegion,
69802:                                         const nsRect& aAllowVisibleRegionExpansion)
60447: {
63414:   nsRect displayport;
69189:   if (nsLayoutUtils::GetDisplayPort(mScrolledFrame->GetContent(), &displayport)) {
60447:     // The visible region for the children may be much bigger than the hole we
60447:     // are viewing the children from, so that the compositor process has enough
60447:     // content to asynchronously pan while content is being refreshed.
60447: 
69189:     nsRegion childVisibleRegion = displayport + aBuilder->ToReferenceFrame(mScrollFrame);
60447: 
98137:     nsRect boundedRect =
98137:       childVisibleRegion.GetBounds().Intersect(mList.GetBounds(aBuilder));
98137:     nsRect allowExpansion = boundedRect.Intersect(aAllowVisibleRegionExpansion);
79445:     bool visible = mList.ComputeVisibilityForSublist(
69802:       aBuilder, &childVisibleRegion, boundedRect, allowExpansion);
60447:     mVisibleRect = boundedRect;
60447: 
60447:     return visible;
60447: 
60447:   } else {
69189:     return nsDisplayWrapList::ComputeVisibility(aBuilder, aVisibleRegion,
69802:                                                 aAllowVisibleRegionExpansion);
60447:   }
60447: }
60447: 
69189: LayerState
69189: nsDisplayScrollLayer::GetLayerState(nsDisplayListBuilder* aBuilder,
97534:                                     LayerManager* aManager,
97534:                                     const ContainerParameters& aParameters)
60447: {
69189:   // Force this as a layer so we can scroll asynchronously.
69189:   // This causes incorrect rendering for rounded clips!
69189:   return LAYER_ACTIVE_FORCE;
60447: }
69189: 
79445: bool
69189: nsDisplayScrollLayer::TryMerge(nsDisplayListBuilder* aBuilder,
69189:                                nsDisplayItem* aItem)
69189: {
69189:   if (aItem->GetType() != TYPE_SCROLL_LAYER) {
80486:     return false;
69189:   }
69189: 
69189:   nsDisplayScrollLayer* other = static_cast<nsDisplayScrollLayer*>(aItem);
69189:   if (other->mScrolledFrame != this->mScrolledFrame) {
80486:     return false;
69189:   }
69189: 
69189:   FrameProperties props = mScrolledFrame->Properties();
69189:   props.Set(nsIFrame::ScrollLayerCount(),
69189:     reinterpret_cast<void*>(GetScrollLayerCount() - 1));
69189: 
95566:   // Swap frames with the other item before doing MergeFrom.
91260:   // XXX - This ensures that the frame associated with a scroll layer after
91260:   // merging is the first, rather than the last. This tends to change less,
91260:   // ensuring we're more likely to retain the associated gfx layer.
91260:   // See Bug 729534 and Bug 731641.
95566:   nsIFrame* tmp = mFrame;
91260:   mFrame = other->mFrame;
95566:   other->mFrame = tmp;
95566:   MergeFromTrackingMergedFrames(other);
80486:   return true;
69189: }
69189: 
79445: bool
69189: nsDisplayScrollLayer::ShouldFlattenAway(nsDisplayListBuilder* aBuilder)
69189: {
69189:   return GetScrollLayerCount() > 1;
69189: }
69189: 
95340: intptr_t
69189: nsDisplayScrollLayer::GetScrollLayerCount()
69189: {
69189:   FrameProperties props = mScrolledFrame->Properties();
69189: #ifdef DEBUG
79445:   bool hasCount = false;
95340:   intptr_t result = reinterpret_cast<intptr_t>(
69189:     props.Get(nsIFrame::ScrollLayerCount(), &hasCount));
69189:   // If this aborts, then the property was either not added before scroll
69189:   // layers were created or the property was deleted to early. If the latter,
69189:   // make sure that nsDisplayScrollInfoLayer is on the bottom of the list so
69189:   // that it is processed last.
69189:   NS_ABORT_IF_FALSE(hasCount, "nsDisplayScrollLayer should always be defined");
69189:   return result;
69189: #else
95340:   return reinterpret_cast<intptr_t>(props.Get(nsIFrame::ScrollLayerCount()));
60447: #endif
69189: }
69189: 
95340: intptr_t
69189: nsDisplayScrollLayer::RemoveScrollLayerCount()
69189: {
95340:   intptr_t result = GetScrollLayerCount();
69189:   FrameProperties props = mScrolledFrame->Properties();
69189:   props.Remove(nsIFrame::ScrollLayerCount());
69189:   return result;
69189: }
69189: 
60447: 
67860: nsDisplayScrollInfoLayer::nsDisplayScrollInfoLayer(
67860:   nsDisplayListBuilder* aBuilder,
69189:   nsIFrame* aScrolledFrame,
69189:   nsIFrame* aScrollFrame)
69189:   : nsDisplayScrollLayer(aBuilder, aScrolledFrame, aScrolledFrame, aScrollFrame)
67860: {
67860: #ifdef NS_BUILD_REFCNT_LOGGING
67860:   MOZ_COUNT_CTOR(nsDisplayScrollInfoLayer);
67860: #endif
67860: }
67860: 
67860: #ifdef NS_BUILD_REFCNT_LOGGING
67860: nsDisplayScrollInfoLayer::~nsDisplayScrollInfoLayer()
67860: {
67860:   MOZ_COUNT_DTOR(nsDisplayScrollInfoLayer);
67860: }
67860: #endif
67860: 
69189: LayerState
69189: nsDisplayScrollInfoLayer::GetLayerState(nsDisplayListBuilder* aBuilder,
97534:                                         LayerManager* aManager,
97534:                                         const ContainerParameters& aParameters)
69189: {
69189:   return LAYER_ACTIVE_EMPTY;
69189: }
69189: 
79445: bool
69189: nsDisplayScrollInfoLayer::TryMerge(nsDisplayListBuilder* aBuilder,
69189:                                    nsDisplayItem* aItem)
69189: {
80486:   return false;
69189: }
69189: 
79445: bool
69189: nsDisplayScrollInfoLayer::ShouldFlattenAway(nsDisplayListBuilder* aBuilder)
69189: {
69189:   // Layer metadata for a particular scroll frame needs to be unique. Only
69189:   // one nsDisplayScrollLayer (with rendered content) or one
69189:   // nsDisplayScrollInfoLayer (with only the metadata) should survive the
69189:   // visibility computation. 
69189:   return RemoveScrollLayerCount() == 1;
69189: }
69189: 
51260: nsDisplayClip::nsDisplayClip(nsDisplayListBuilder* aBuilder,
52289:                              nsIFrame* aFrame, nsDisplayItem* aItem,
52289:                              const nsRect& aRect)
95645:    : nsDisplayWrapList(aBuilder, aFrame, aItem,
95645:        aFrame == aItem->GetUnderlyingFrame() ? aItem->ToReferenceFrame() : aBuilder->ToReferenceFrame(aFrame)),
95645:      mClip(aRect) {
    1:   MOZ_COUNT_CTOR(nsDisplayClip);
    1: }
    1: 
51260: nsDisplayClip::nsDisplayClip(nsDisplayListBuilder* aBuilder,
52289:                              nsIFrame* aFrame, nsDisplayList* aList,
52289:                              const nsRect& aRect)
95051:    : nsDisplayWrapList(aBuilder, aFrame, aList), mClip(aRect) {
    1:   MOZ_COUNT_CTOR(nsDisplayClip);
95051: }
95051: 
95051: nsRect nsDisplayClip::GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap) {
95051:   nsRect r = nsDisplayWrapList::GetBounds(aBuilder, aSnap);
95347:   *aSnap = false;
98137:   return mClip.Intersect(r);
    1: }
    1: 
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1: nsDisplayClip::~nsDisplayClip() {
    1:   MOZ_COUNT_DTOR(nsDisplayClip);
    1: }
    1: #endif
    1: 
    1: void nsDisplayClip::Paint(nsDisplayListBuilder* aBuilder,
68481:                           nsRenderingContext* aCtx) {
38803:   NS_ERROR("nsDisplayClip should have been flattened away for painting");
    1: }
    1: 
79445: bool nsDisplayClip::ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                         nsRegion* aVisibleRegion,
69802:                                         const nsRect& aAllowVisibleRegionExpansion) {
34210:   nsRegion clipped;
34210:   clipped.And(*aVisibleRegion, mClip);
34210: 
34210:   nsRegion finalClipped(clipped);
98137:   nsRect allowExpansion = mClip.Intersect(aAllowVisibleRegionExpansion);
79445:   bool anyVisible =
61411:     nsDisplayWrapList::ComputeVisibility(aBuilder, &finalClipped,
69802:                                          allowExpansion);
34210: 
34210:   nsRegion removed;
34210:   removed.Sub(clipped, finalClipped);
69802:   aBuilder->SubtractFromVisibleRegion(aVisibleRegion, removed);
34210: 
    1:   return anyVisible;
    1: }
    1: 
79445: bool nsDisplayClip::TryMerge(nsDisplayListBuilder* aBuilder,
    1:                              nsDisplayItem* aItem) {
    1:   if (aItem->GetType() != TYPE_CLIP)
80486:     return false;
 3233:   nsDisplayClip* other = static_cast<nsDisplayClip*>(aItem);
68638:   if (!other->mClip.IsEqualInterior(mClip))
80486:     return false;
95566:   // No need to track merged frames for clipping
95348:   MergeFrom(other);
80486:   return true;
    1: }
    1: 
    1: nsDisplayWrapList* nsDisplayClip::WrapWithClone(nsDisplayListBuilder* aBuilder,
    1:                                                 nsDisplayItem* aItem) {
14466:   return new (aBuilder)
52289:     nsDisplayClip(aBuilder, aItem->GetUnderlyingFrame(), aItem, mClip);
    1: }
19125: 
52292: nsDisplayClipRoundedRect::nsDisplayClipRoundedRect(
52292:                              nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
52292:                              nsDisplayItem* aItem,
52292:                              const nsRect& aRect, nscoord aRadii[8])
52292:     : nsDisplayClip(aBuilder, aFrame, aItem, aRect)
52292: {
52292:   MOZ_COUNT_CTOR(nsDisplayClipRoundedRect);
52292:   memcpy(mRadii, aRadii, sizeof(mRadii));
52292: }
52292: 
52292: nsDisplayClipRoundedRect::nsDisplayClipRoundedRect(
52292:                              nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
52292:                              nsDisplayList* aList,
52292:                              const nsRect& aRect, nscoord aRadii[8])
52292:     : nsDisplayClip(aBuilder, aFrame, aList, aRect)
52292: {
52292:   MOZ_COUNT_CTOR(nsDisplayClipRoundedRect);
52292:   memcpy(mRadii, aRadii, sizeof(mRadii));
52292: }
52292: 
52292: #ifdef NS_BUILD_REFCNT_LOGGING
52292: nsDisplayClipRoundedRect::~nsDisplayClipRoundedRect()
52292: {
52292:   MOZ_COUNT_DTOR(nsDisplayClipRoundedRect);
52292: }
52292: #endif
52292: 
59779: nsRegion
59779: nsDisplayClipRoundedRect::GetOpaqueRegion(nsDisplayListBuilder* aBuilder,
97420:                                           bool* aSnap)
52292: {
95051:   *aSnap = false;
59779:   return nsRegion();
52292: }
52292: 
52292: void
52292: nsDisplayClipRoundedRect::HitTest(nsDisplayListBuilder* aBuilder,
52292:                                   const nsRect& aRect, HitTestState* aState,
52292:                                   nsTArray<nsIFrame*> *aOutFrames)
52292: {
55316:   if (!RoundedRectIntersectsRect(mClip, mRadii, aRect)) {
55316:     // aRect doesn't intersect our border-radius curve.
55316: 
55316:     // FIXME: This isn't quite sufficient for aRect having nontrivial
55316:     // size (which is the unusual case here), since it's possible that
55316:     // the part of aRect that intersects the the rounded rect isn't the
55316:     // part that intersects the items in mList.
55316:     return;
55316:   }
55316: 
52292:   mList.HitTest(aBuilder, aRect, aState, aOutFrames);
52292: }
52292: 
52292: nsDisplayWrapList*
52292: nsDisplayClipRoundedRect::WrapWithClone(nsDisplayListBuilder* aBuilder,
52292:                                         nsDisplayItem* aItem) {
52292:   return new (aBuilder)
52292:     nsDisplayClipRoundedRect(aBuilder, aItem->GetUnderlyingFrame(), aItem,
52292:                              mClip, mRadii);
52292: }
52292: 
79445: bool nsDisplayClipRoundedRect::ComputeVisibility(
52292:                                     nsDisplayListBuilder* aBuilder,
61411:                                     nsRegion* aVisibleRegion,
69802:                                     const nsRect& aAllowVisibleRegionExpansion)
52292: {
52292:   nsRegion clipped;
52292:   clipped.And(*aVisibleRegion, mClip);
52292: 
69802:   return nsDisplayWrapList::ComputeVisibility(aBuilder, &clipped, nsRect());
52292:   // FIXME: Remove a *conservative* opaque region from aVisibleRegion
52292:   // (like in nsDisplayClip::ComputeVisibility).
52292: }
52292: 
79445: bool nsDisplayClipRoundedRect::TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem)
52292: {
52292:   if (aItem->GetType() != TYPE_CLIP_ROUNDED_RECT)
80486:     return false;
52292:   nsDisplayClipRoundedRect* other =
52292:     static_cast<nsDisplayClipRoundedRect*>(aItem);
68638:   if (!mClip.IsEqualInterior(other->mClip) ||
59653:       memcmp(mRadii, other->mRadii, sizeof(mRadii)) != 0)
80486:     return false;
95566:   // No need to track merged frames for clipping
95348:   MergeFrom(other);
80486:   return true;
52292: }
52292: 
51260: nsDisplayZoom::nsDisplayZoom(nsDisplayListBuilder* aBuilder,
51260:                              nsIFrame* aFrame, nsDisplayList* aList,
47900:                              PRInt32 aAPD, PRInt32 aParentAPD)
51260:     : nsDisplayOwnLayer(aBuilder, aFrame, aList), mAPD(aAPD),
51260:       mParentAPD(aParentAPD) {
47900:   MOZ_COUNT_CTOR(nsDisplayZoom);
47900: }
19214: 
47900: #ifdef NS_BUILD_REFCNT_LOGGING
47900: nsDisplayZoom::~nsDisplayZoom() {
47900:   MOZ_COUNT_DTOR(nsDisplayZoom);
47900: }
47900: #endif
47900: 
95051: nsRect nsDisplayZoom::GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap)
47900: {
95051:   nsRect bounds = nsDisplayWrapList::GetBounds(aBuilder, aSnap);
95051:   *aSnap = false;
47900:   return bounds.ConvertAppUnitsRoundOut(mAPD, mParentAPD);
47900: }
47900: 
47900: void nsDisplayZoom::HitTest(nsDisplayListBuilder *aBuilder,
47900:                             const nsRect& aRect,
47900:                             HitTestState *aState,
47900:                             nsTArray<nsIFrame*> *aOutFrames)
47900: {
47900:   nsRect rect;
47900:   // A 1x1 rect indicates we are just hit testing a point, so pass down a 1x1
47900:   // rect as well instead of possibly rounding the width or height to zero.
47900:   if (aRect.width == 1 && aRect.height == 1) {
47900:     rect.MoveTo(aRect.TopLeft().ConvertAppUnits(mParentAPD, mAPD));
47900:     rect.width = rect.height = 1;
47900:   } else {
47900:     rect = aRect.ConvertAppUnitsRoundOut(mParentAPD, mAPD);
47900:   }
47900:   mList.HitTest(aBuilder, rect, aState, aOutFrames);
47900: }
47900: 
47900: void nsDisplayZoom::Paint(nsDisplayListBuilder* aBuilder,
68481:                           nsRenderingContext* aCtx)
47900: {
47900:   mList.PaintForFrame(aBuilder, aCtx, mFrame, nsDisplayList::PAINT_DEFAULT);
47900: }
47900: 
79445: bool nsDisplayZoom::ComputeVisibility(nsDisplayListBuilder *aBuilder,
61411:                                       nsRegion *aVisibleRegion,
69802:                                       const nsRect& aAllowVisibleRegionExpansion)
47900: {
47900:   // Convert the passed in visible region to our appunits.
47900:   nsRegion visibleRegion =
47900:     aVisibleRegion->ConvertAppUnitsRoundOut(mParentAPD, mAPD);
47900:   nsRegion originalVisibleRegion = visibleRegion;
47900: 
51633:   nsRect transformedVisibleRect =
51633:     mVisibleRect.ConvertAppUnitsRoundOut(mParentAPD, mAPD);
62700:   nsRect allowExpansion =
62700:     aAllowVisibleRegionExpansion.ConvertAppUnitsRoundIn(mParentAPD, mAPD);
79445:   bool retval =
51633:     mList.ComputeVisibilityForSublist(aBuilder, &visibleRegion,
61411:                                       transformedVisibleRect,
69802:                                       allowExpansion);
47900: 
47900:   nsRegion removed;
47900:   // removed = originalVisibleRegion - visibleRegion
47900:   removed.Sub(originalVisibleRegion, visibleRegion);
47900:   // Convert removed region to parent appunits.
47900:   removed = removed.ConvertAppUnitsRoundIn(mAPD, mParentAPD);
47900:   // aVisibleRegion = aVisibleRegion - removed (modulo any simplifications
47900:   // SubtractFromVisibleRegion does)
69802:   aBuilder->SubtractFromVisibleRegion(aVisibleRegion, removed);
47900: 
47900:   return retval;
47900: }
19214: 
19214: ///////////////////////////////////////////////////
19214: // nsDisplayTransform Implementation
19214: //
19214: 
19214: // Write #define UNIFIED_CONTINUATIONS here to have the transform property try
19214: // to transform content with continuations as one unified block instead of
19214: // several smaller ones.  This is currently disabled because it doesn't work
30710: // correctly, since when the frames are initially being reflowed, their
19214: // continuations all compute their bounding rects independently of each other
19214: // and consequently get the wrong value.  Write #define DEBUG_HIT here to have
19214: // the nsDisplayTransform class dump out a bunch of information about hit
19214: // detection.
19214: #undef  UNIFIED_CONTINUATIONS
19214: #undef  DEBUG_HIT
19214: 
19214: /* Returns the bounds of a frame as defined for transforms.  If
19214:  * UNIFIED_CONTINUATIONS is not defined, this is simply the frame's bounding
19214:  * rectangle, translated to the origin. Otherwise, returns the smallest
19214:  * rectangle containing a frame and all of its continuations.  For example, if
19214:  * there is a <span> element with several continuations split over several
19214:  * lines, this function will return the rectangle containing all of those
19214:  * continuations.  This rectangle is relative to the origin of the frame's local
19214:  * coordinate space.
19214:  */
19214: #ifndef UNIFIED_CONTINUATIONS
19214: 
19214: nsRect
19214: nsDisplayTransform::GetFrameBoundsForTransform(const nsIFrame* aFrame)
19214: {
19214:   NS_PRECONDITION(aFrame, "Can't get the bounds of a nonexistent frame!");
98711: 
98711:   if (aFrame->GetStateBits() & NS_FRAME_SVG_LAYOUT) {
98711:     // TODO: SVG needs to define what percentage translations resolve against.
98711:     return nsRect();
98711:   }
98711: 
19214:   return nsRect(nsPoint(0, 0), aFrame->GetSize());
19214: }
19214: 
19214: #else
19214: 
19214: nsRect
19214: nsDisplayTransform::GetFrameBoundsForTransform(const nsIFrame* aFrame)
19214: {
19214:   NS_PRECONDITION(aFrame, "Can't get the bounds of a nonexistent frame!");
19214: 
19214:   nsRect result;
19214:   
98711:   if (aFrame->GetStateBits() & NS_FRAME_SVG_LAYOUT) {
98711:     // TODO: SVG needs to define what percentage translations resolve against.
98711:     return result;
98711:   }
98711: 
19214:   /* Iterate through the continuation list, unioning together all the
19214:    * bounding rects.
19214:    */
19214:   for (const nsIFrame *currFrame = aFrame->GetFirstContinuation();
19214:        currFrame != nsnull;
19214:        currFrame = currFrame->GetNextContinuation())
19214:     {
19214:       /* Get the frame rect in local coordinates, then translate back to the
19214:        * original coordinates.
19214:        */
19214:       result.UnionRect(result, nsRect(currFrame->GetOffsetTo(aFrame),
19214:                                       currFrame->GetSize()));
19214:     }
19214: 
19214:   return result;
19214: }
19214: 
19214: #endif
19214: 
43138: /* Returns the delta specified by the -moz-transform-origin property.
19214:  * This is a positive delta, meaning that it indicates the direction to move
19214:  * to get from (0, 0) of the frame to the transform origin.
19214:  */
19214: static
74757: gfxPoint3D GetDeltaToMozTransformOrigin(const nsIFrame* aFrame,
90354:                                         float aAppUnitsPerPixel,
19214:                                         const nsRect* aBoundsOverride)
19214: {
19214:   NS_PRECONDITION(aFrame, "Can't get delta for a null frame!");
98711:   NS_PRECONDITION(aFrame->IsTransformed(),
98711:                   "Shouldn't get a delta for an untransformed frame!");
19214: 
19214:   /* For both of the coordinates, if the value of -moz-transform is a
19214:    * percentage, it's relative to the size of the frame.  Otherwise, if it's
19214:    * a distance, it's already computed for us!
19214:    */
19214:   const nsStyleDisplay* display = aFrame->GetStyleDisplay();
19214:   nsRect boundingRect = (aBoundsOverride ? *aBoundsOverride :
19214:                          nsDisplayTransform::GetFrameBoundsForTransform(aFrame));
19214: 
19214:   /* Allows us to access named variables by index. */
74757:   gfxPoint3D result;
74757:   gfxFloat* coords[3] = {&result.x, &result.y, &result.z};
19214:   const nscoord* dimensions[2] =
19214:     {&boundingRect.width, &boundingRect.height};
19214: 
19214:   for (PRUint8 index = 0; index < 2; ++index) {
19214:     /* If the -moz-transform-origin specifies a percentage, take the percentage
19214:      * of the size of the box.
19214:      */
53920:     const nsStyleCoord &coord = display->mTransformOrigin[index];
53920:     if (coord.GetUnit() == eStyleUnit_Calc) {
53920:       const nsStyleCoord::Calc *calc = coord.GetCalcValue();
90354:       *coords[index] =
90354:         NSAppUnitsToFloatPixels(*dimensions[index], aAppUnitsPerPixel) *
53920:           calc->mPercent +
90354:         NSAppUnitsToFloatPixels(calc->mLength, aAppUnitsPerPixel);
53920:     } else if (coord.GetUnit() == eStyleUnit_Percent) {
90354:       *coords[index] =
90354:         NSAppUnitsToFloatPixels(*dimensions[index], aAppUnitsPerPixel) *
53920:         coord.GetPercentValue();
53920:     } else {
53920:       NS_ABORT_IF_FALSE(coord.GetUnit() == eStyleUnit_Coord, "unexpected unit");
90354:       *coords[index] =
90354:         NSAppUnitsToFloatPixels(coord.GetCoordValue(), aAppUnitsPerPixel);
90354:     }
98711:     if ((aFrame->GetStateBits() & NS_FRAME_SVG_LAYOUT) &&
98711:         coord.GetUnit() != eStyleUnit_Percent) {
98711:       // <length> values represent offsets from the origin of the SVG element's
98711:       // user space, not the top left of its bounds, so we must adjust for that:
98711:       nscoord offset =
98711:         (index == 0) ? aFrame->GetPosition().x : aFrame->GetPosition().y;
98711:       *coords[index] -= NSAppUnitsToFloatPixels(offset, aAppUnitsPerPixel);
98711:     }
90354:   }
90354: 
90354:   *coords[2] = NSAppUnitsToFloatPixels(display->mTransformOrigin[2].GetCoordValue(),
90354:                                        aAppUnitsPerPixel);
19214:   /* Adjust based on the origin of the rectangle. */
90354:   result.x += NSAppUnitsToFloatPixels(boundingRect.x, aAppUnitsPerPixel);
90354:   result.y += NSAppUnitsToFloatPixels(boundingRect.y, aAppUnitsPerPixel);
19214: 
19214:   return result;
19214: }
19214: 
74759: /* Returns the delta specified by the -moz-perspective-origin property.
74759:  * This is a positive delta, meaning that it indicates the direction to move
74759:  * to get from (0, 0) of the frame to the perspective origin.
74759:  */
74759: static
74759: gfxPoint3D GetDeltaToMozPerspectiveOrigin(const nsIFrame* aFrame,
92049:                                           float aAppUnitsPerPixel)
74759: {
74759:   NS_PRECONDITION(aFrame, "Can't get delta for a null frame!");
98711:   NS_PRECONDITION(aFrame->IsTransformed(),
98711:                   "Shouldn't get a delta for an untransformed frame!");
90156:   NS_PRECONDITION(aFrame->GetParentStyleContextFrame(), 
90156:                   "Can't get delta without a style parent!");
74759: 
74759:   /* For both of the coordinates, if the value of -moz-perspective-origin is a
74759:    * percentage, it's relative to the size of the frame.  Otherwise, if it's
74759:    * a distance, it's already computed for us!
74759:    */
74759: 
74759:   //TODO: Should this be using our bounds or the parent's bounds?
74759:   // How do we handle aBoundsOverride in the latter case?
90156:   nsIFrame* parent = aFrame->GetParentStyleContextFrame();
97086:   const nsStyleDisplay* display = parent->GetStyleDisplay();
92049:   nsRect boundingRect = nsDisplayTransform::GetFrameBoundsForTransform(parent);
74759: 
74759:   /* Allows us to access named variables by index. */
74759:   gfxPoint3D result;
74759:   result.z = 0.0f;
74759:   gfxFloat* coords[2] = {&result.x, &result.y};
74759:   const nscoord* dimensions[2] =
74759:     {&boundingRect.width, &boundingRect.height};
74759: 
74759:   for (PRUint8 index = 0; index < 2; ++index) {
74759:     /* If the -moz-transform-origin specifies a percentage, take the percentage
74759:      * of the size of the box.
74759:      */
74759:     const nsStyleCoord &coord = display->mPerspectiveOrigin[index];
74759:     if (coord.GetUnit() == eStyleUnit_Calc) {
74759:       const nsStyleCoord::Calc *calc = coord.GetCalcValue();
90354:       *coords[index] =
90354:         NSAppUnitsToFloatPixels(*dimensions[index], aAppUnitsPerPixel) *
74759:           calc->mPercent +
90354:         NSAppUnitsToFloatPixels(calc->mLength, aAppUnitsPerPixel);
74759:     } else if (coord.GetUnit() == eStyleUnit_Percent) {
90354:       *coords[index] =
90354:         NSAppUnitsToFloatPixels(*dimensions[index], aAppUnitsPerPixel) *
74759:         coord.GetPercentValue();
74759:     } else {
74759:       NS_ABORT_IF_FALSE(coord.GetUnit() == eStyleUnit_Coord, "unexpected unit");
90354:       *coords[index] =
90354:         NSAppUnitsToFloatPixels(coord.GetCoordValue(), aAppUnitsPerPixel);
74759:     }
74759:   }
74759: 
90156:   nsPoint parentOffset = aFrame->GetOffsetTo(parent);
90354:   gfxPoint3D gfxOffset(
90354:                NSAppUnitsToFloatPixels(parentOffset.x, aAppUnitsPerPixel),
90354:                NSAppUnitsToFloatPixels(parentOffset.y, aAppUnitsPerPixel),
90354:                0.0f);
90156: 
90156:   return result - gfxOffset;
74759: }
74759: 
19214: /* Wraps up the -moz-transform matrix in a change-of-basis matrix pair that
19214:  * translates from local coordinate space to transform coordinate space, then
19214:  * hands it back.
19214:  */
74283: gfx3DMatrix
19214: nsDisplayTransform::GetResultingTransformMatrix(const nsIFrame* aFrame,
19214:                                                 const nsPoint &aOrigin,
90354:                                                 float aAppUnitsPerPixel,
77286:                                                 const nsRect* aBoundsOverride,
77286:                                                 nsIFrame** aOutAncestor)
19214: {
19214:   NS_PRECONDITION(aFrame, "Cannot get transform matrix for a null frame!");
77286: 
77286:   if (aOutAncestor) {
77286:       *aOutAncestor = nsLayoutUtils::GetCrossDocParentFrame(aFrame);
77286:   }
77286: 
19214:   /* Account for the -moz-transform-origin property by translating the
19214:    * coordinate space to the new origin.
19214:    */
90354:   gfxPoint3D toMozOrigin =
90354:     GetDeltaToMozTransformOrigin(aFrame, aAppUnitsPerPixel, aBoundsOverride);
90354:   gfxPoint3D newOrigin =
90354:     gfxPoint3D(NSAppUnitsToFloatPixels(aOrigin.x, aAppUnitsPerPixel),
90354:                NSAppUnitsToFloatPixels(aOrigin.y, aAppUnitsPerPixel),
74757:                0.0f);
19214: 
19214:   /* Get the underlying transform matrix.  This requires us to get the
19214:    * bounds of the frame.
19214:    */
19214:   const nsStyleDisplay* disp = aFrame->GetStyleDisplay();
19214:   nsRect bounds = (aBoundsOverride ? *aBoundsOverride :
19214:                    nsDisplayTransform::GetFrameBoundsForTransform(aFrame));
19214: 
19214:   /* Get the matrix, then change its basis to factor in the origin. */
79445:   bool dummy;
77286:   gfx3DMatrix result;
98711:   // Call IsSVGTransformed() regardless of the value of
98711:   // disp->mSpecifiedTransform, since we still need any transformFromSVGParent.
98711:   gfxMatrix svgTransform, transformFromSVGParent;
98711:   bool hasSVGTransforms =
98711:     aFrame->IsSVGTransformed(&svgTransform, &transformFromSVGParent);
77286:   /* Transformed frames always have a transform, or are preserving 3d (and might still have perspective!) */
77286:   if (disp->mSpecifiedTransform) {
77286:     result = nsStyleTransformMatrix::ReadTransforms(disp->mSpecifiedTransform,
74281:                                                     aFrame->GetStyleContext(),
74281:                                                     aFrame->PresContext(),
90354:                                                     dummy, bounds, aAppUnitsPerPixel);
98711:   } else if (hasSVGTransforms) {
98711:     result = gfx3DMatrix::From2D(svgTransform);
77286:   } else {
92048:      NS_ASSERTION(aFrame->GetStyleDisplay()->mTransformStyle == NS_STYLE_TRANSFORM_STYLE_PRESERVE_3D ||
92048:                   aFrame->GetStyleDisplay()->mBackfaceVisibility == NS_STYLE_BACKFACE_VISIBILITY_HIDDEN,
92048:                   "If we don't have a transform, then we must have another reason to have an nsDisplayTransform created");
77286:   }
74754: 
98711:   if (hasSVGTransforms && !transformFromSVGParent.IsIdentity()) {
98711:     result = result * gfx3DMatrix::From2D(transformFromSVGParent);
98711:   }
98711: 
74754:   const nsStyleDisplay* parentDisp = nsnull;
86529:   nsStyleContext* parentStyleContext = aFrame->GetStyleContext()->GetParent();
86529:   if (parentStyleContext) {
86529:     parentDisp = parentStyleContext->GetStyleDisplay();
74754:   }
74754:   if (nsLayoutUtils::Are3DTransformsEnabled() &&
74754:       parentDisp && parentDisp->mChildPerspective.GetUnit() == eStyleUnit_Coord &&
74754:       parentDisp->mChildPerspective.GetCoordValue() > 0.0) {
74754:     gfx3DMatrix perspective;
74754:     perspective._34 =
74754:       -1.0 / NSAppUnitsToFloatPixels(parentDisp->mChildPerspective.GetCoordValue(),
90354:                                      aAppUnitsPerPixel);
81099:     /* At the point when perspective is applied, we have been translated to the transform origin.
81099:      * The translation to the perspective origin is the difference between these values.
81099:      */
92049:     gfxPoint3D toPerspectiveOrigin = GetDeltaToMozPerspectiveOrigin(aFrame, aAppUnitsPerPixel);
81099:     result = result * nsLayoutUtils::ChangeMatrixBasis(toPerspectiveOrigin - toMozOrigin, perspective);
74754:   }
77286: 
77286:   if (aFrame->Preserves3D() && nsLayoutUtils::Are3DTransformsEnabled()) {
77286:       // Include the transform set on our parent
77286:       NS_ASSERTION(aFrame->GetParent() &&
77286:                    aFrame->GetParent()->IsTransformed() &&
77286:                    aFrame->GetParent()->Preserves3DChildren(),
77286:                    "Preserve3D mismatch!");
77286:       gfx3DMatrix parent = GetResultingTransformMatrix(aFrame->GetParent(), aOrigin - aFrame->GetPosition(),
90354:                                                        aAppUnitsPerPixel, nsnull, aOutAncestor);
77286:       return nsLayoutUtils::ChangeMatrixBasis(newOrigin + toMozOrigin, result) * parent;
77286:   }
77286: 
74754:   return nsLayoutUtils::ChangeMatrixBasis
74754:     (newOrigin + toMozOrigin, result);
74281: }
74281: 
84920: bool
84920: nsDisplayTransform::ShouldPrerenderTransformedContent(nsDisplayListBuilder* aBuilder,
84920:                                                       nsIFrame* aFrame)
84920: {
90088:   if (aFrame->AreLayersMarkedActive(nsChangeHint_UpdateTransformLayer)) {
90088:     nsSize refSize = aBuilder->ReferenceFrame()->GetSize();
90088:     // Only prerender if the transformed frame's size is <= the
90088:     // reference frame size (~viewport), allowing a 1/8th fuzz factor
90088:     // for shadows, borders, etc.
90088:     refSize += nsSize(refSize.width / 8, refSize.height / 8);
91353:     if (aFrame->GetVisualOverflowRectRelativeToSelf().Size() <= refSize) {
91353:       // Bug 717521 - pre-render max 4096 x 4096 device pixels.
91353:       nscoord max = aFrame->PresContext()->DevPixelsToAppUnits(4096);
91353:       nsRect visual = aFrame->GetVisualOverflowRect();
91353:       if (visual.width <= max && visual.height <= max) {
91353:         return true;
91353:       }
91353:     }
90088:   }
90088:   return false;
84920: }
84920: 
80243: /* If the matrix is singular, or a hidden backface is shown, the frame won't be visible or hit. */
80243: static bool IsFrameVisible(nsIFrame* aFrame, const gfx3DMatrix& aMatrix) 
80243: {
80243:   if (aMatrix.IsSingular()) {
80243:     return false;
80243:   }
80243:   if (aFrame->GetStyleDisplay()->mBackfaceVisibility == NS_STYLE_BACKFACE_VISIBILITY_HIDDEN &&
80243:       aMatrix.IsBackfaceVisible()) {
80243:     return false;
80243:   }
80243:   return true;
80243: }
80243: 
74283: const gfx3DMatrix&
90354: nsDisplayTransform::GetTransform(float aAppUnitsPerPixel)
74281: {
90354:   if (mTransform.IsIdentity() || mCachedAppUnitsPerPixel != aAppUnitsPerPixel) {
74281:     mTransform =
74281:       GetResultingTransformMatrix(mFrame, ToReferenceFrame(),
90354:                                   aAppUnitsPerPixel,
74281:                                   nsnull);
90354:     mCachedAppUnitsPerPixel = aAppUnitsPerPixel;
74281:   }
74281:   return mTransform;
19214: }
19214: 
48693: already_AddRefed<Layer> nsDisplayTransform::BuildLayer(nsDisplayListBuilder *aBuilder,
72230:                                                        LayerManager *aManager,
72230:                                                        const ContainerParameters& aContainerParameters)
19214: {
74283:   const gfx3DMatrix& newTransformMatrix = 
74281:     GetTransform(mFrame->PresContext()->AppUnitsPerDevPixel());
74755: 
80243:   if (!IsFrameVisible(mFrame, newTransformMatrix)) {
48693:     return nsnull;
74755:   }
19517: 
79925:   nsRefPtr<ContainerLayer> container = aBuilder->LayerBuilder()->
72230:     BuildContainerLayerFor(aBuilder, aManager, mFrame, this, *mStoredList.GetList(),
74283:                            aContainerParameters, &newTransformMatrix);
79925: 
79925:   // Add the preserve-3d flag for this layer, BuildContainerLayerFor clears all flags,
79925:   // so we never need to explicitely unset this flag.
82357:   if (mFrame->Preserves3D() || mFrame->Preserves3DChildren()) {
79925:     container->SetContentFlags(container->GetContentFlags() | Layer::CONTENT_PRESERVE_3D);
79925:   }
79925:   return container.forget();
48693: }
19214: 
48693: nsDisplayItem::LayerState
48693: nsDisplayTransform::GetLayerState(nsDisplayListBuilder* aBuilder,
97534:                                   LayerManager* aManager,
97534:                                   const ContainerParameters& aParameters) {
80904:   // Here we check if the *post-transform* bounds of this item are big enough
80904:   // to justify an active layer.
80904:   if (mFrame->AreLayersMarkedActive(nsChangeHint_UpdateTransformLayer) &&
80904:       !IsItemTooSmallForActiveLayer(this))
48693:     return LAYER_ACTIVE;
79925:   if (!GetTransform(mFrame->PresContext()->AppUnitsPerDevPixel()).Is2D() || mFrame->Preserves3D())
74750:     return LAYER_ACTIVE;
48693:   nsIFrame* activeScrolledRoot =
49156:     nsLayoutUtils::GetActiveScrolledRootFor(mFrame, nsnull);
48693:   return !mStoredList.ChildrenCanBeInactive(aBuilder, 
48693:                                             aManager, 
97534:                                             aParameters,
48693:                                             *mStoredList.GetList(), 
48693:                                             activeScrolledRoot)
48693:       ? LAYER_ACTIVE : LAYER_INACTIVE;
19214: }
19214: 
79445: bool nsDisplayTransform::ComputeVisibility(nsDisplayListBuilder *aBuilder,
61411:                                              nsRegion *aVisibleRegion,
69802:                                              const nsRect& aAllowVisibleRegionExpansion)
19214: {
33368:   /* As we do this, we need to be sure to
33368:    * untransform the visible rect, since we want everything that's painting to
74283:    * think that it's painting in its original rectangular coordinate space.
74283:    * If we can't untransform, take the entire overflow rect */
74283:   nsRect untransformedVisibleRect;
90079:   float factor = nsPresContext::AppUnitsPerCSSPixel();
84920:   if (ShouldPrerenderTransformedContent(aBuilder, mFrame) ||
90079:       !UntransformRectMatrix(mVisibleRect,
90079:                              GetTransform(factor),
90079:                              factor,
74283:                              &untransformedVisibleRect)) 
74283:   {
74283:     untransformedVisibleRect = mFrame->GetVisualOverflowRectRelativeToSelf() +  
74283:                                aBuilder->ToReferenceFrame(mFrame);
74283:   }
74283:   nsRegion untransformedVisible = untransformedVisibleRect;
78018:   // Call RecomputeVisiblity instead of ComputeVisibility since
51633:   // nsDisplayItem::ComputeVisibility should only be called from
51633:   // nsDisplayList::ComputeVisibility (which sets mVisibleRect on the item)
51633:   mStoredList.RecomputeVisibility(aBuilder, &untransformedVisible);
80486:   return true;
19214: }
19214: 
19214: #ifdef DEBUG_HIT
19214: #include <time.h>
19214: #endif
19214: 
19214: /* HitTest does some fun stuff with matrix transforms to obtain the answer. */
40570: void nsDisplayTransform::HitTest(nsDisplayListBuilder *aBuilder,
40570:                                  const nsRect& aRect,
40570:                                  HitTestState *aState,
40570:                                  nsTArray<nsIFrame*> *aOutFrames)
19214: {
19214:   /* Here's how this works:
19214:    * 1. Get the matrix.  If it's singular, abort (clearly we didn't hit
19214:    *    anything).
19214:    * 2. Invert the matrix.
40570:    * 3. Use it to transform the rect into the correct space.
40570:    * 4. Pass that rect down through to the list's version of HitTest.
19214:    */
19214:   float factor = nsPresContext::AppUnitsPerCSSPixel();
74283:   gfx3DMatrix matrix = GetTransform(factor);
74281: 
80243:   if (!IsFrameVisible(mFrame, matrix)) {
40570:     return;
74755:   }
19214: 
19214:   /* We want to go from transformed-space to regular space.
19214:    * Thus we have to invert the matrix, which normally does
19214:    * the reverse operation (e.g. regular->transformed)
19214:    */
19214: 
19214:   /* Now, apply the transform and pass it down the channel. */
40570:   nsRect resultingRect;
40570:   if (aRect.width == 1 && aRect.height == 1) {
78032:     // Magic width/height indicating we're hit testing a point, not a rect
74753:     gfxPoint point = matrix.Inverse().ProjectPoint(
74753:                        gfxPoint(NSAppUnitsToFloatPixels(aRect.x, factor),
40570:                                 NSAppUnitsToFloatPixels(aRect.y, factor)));
40570: 
40570:     resultingRect = nsRect(NSFloatPixelsToAppUnits(float(point.x), factor),
40570:                            NSFloatPixelsToAppUnits(float(point.y), factor),
40570:                            1, 1);
40570: 
40570:   } else {
40570:     gfxRect originalRect(NSAppUnitsToFloatPixels(aRect.x, factor),
40570:                          NSAppUnitsToFloatPixels(aRect.y, factor),
40570:                          NSAppUnitsToFloatPixels(aRect.width, factor),
40570:                          NSAppUnitsToFloatPixels(aRect.height, factor));
40570: 
74753:     gfxRect rect = matrix.Inverse().ProjectRectBounds(originalRect);;
40570: 
40570:     resultingRect = nsRect(NSFloatPixelsToAppUnits(float(rect.X()), factor),
40570:                            NSFloatPixelsToAppUnits(float(rect.Y()), factor),
40570:                            NSFloatPixelsToAppUnits(float(rect.Width()), factor),
40570:                            NSFloatPixelsToAppUnits(float(rect.Height()), factor));
40570:   }
40570:   
19214: 
19214: #ifdef DEBUG_HIT
19214:   printf("Frame: %p\n", dynamic_cast<void *>(mFrame));
40570:   printf("  Untransformed point: (%f, %f)\n", resultingRect.X(), resultingRect.Y());
40570:   PRUint32 originalFrameCount = aOutFrames.Length();
19214: #endif
19214: 
40570:   mStoredList.HitTest(aBuilder, resultingRect, aState, aOutFrames);
19214: 
19214: #ifdef DEBUG_HIT
40570:   if (originalFrameCount != aOutFrames.Length())
40570:     printf("  Hit! Time: %f, first frame: %p\n", static_cast<double>(clock()),
40570:            dynamic_cast<void *>(aOutFrames.ElementAt(0)));
19214:   printf("=== end of hit test ===\n");
19214: #endif
19214: 
19214: }
19214: 
79926: float
79926: nsDisplayTransform::GetHitDepthAtPoint(const nsPoint& aPoint)
79926: {
79926:   float factor = nsPresContext::AppUnitsPerCSSPixel();
79926:   gfx3DMatrix matrix = GetTransform(factor);
79926: 
80243:   NS_ASSERTION(IsFrameVisible(mFrame, matrix), "We can't have hit a frame that isn't visible!");
79926:     
79926:   gfxPoint point = 
79926:     matrix.Inverse().ProjectPoint(gfxPoint(NSAppUnitsToFloatPixels(aPoint.x, factor),
79926:                                            NSAppUnitsToFloatPixels(aPoint.y, factor)));
79926: 
79926:   gfxPoint3D transformed = matrix.Transform3D(gfxPoint3D(point.x, point.y, 0));
79926:   return transformed.z;
79926: }
79926: 
19214: /* The bounding rectangle for the object is the overflow rectangle translated
19214:  * by the reference point.
19214:  */
95051: nsRect nsDisplayTransform::GetBounds(nsDisplayListBuilder *aBuilder, bool* aSnap)
19214: {
90080:   nsRect untransformedBounds =
90080:     ShouldPrerenderTransformedContent(aBuilder, mFrame) ?
90080:     mFrame->GetVisualOverflowRectRelativeToSelf() + ToReferenceFrame() :
95051:     mStoredList.GetBounds(aBuilder, aSnap);
95051:   *aSnap = false;
90078:   float factor = nsPresContext::AppUnitsPerCSSPixel();
90080:   return nsLayoutUtils::MatrixTransformRect(untransformedBounds,
90078:                                             GetTransform(factor),
90078:                                             factor);
19214: }
19214: 
19214: /* The transform is opaque iff the transform consists solely of scales and
58321:  * translations and if the underlying content is opaque.  Thus if the transform
19214:  * is of the form
19214:  *
19214:  * |a c e|
19214:  * |b d f|
19214:  * |0 0 1|
19214:  *
19214:  * We need b and c to be zero.
58321:  *
58321:  * We also need to check whether the underlying opaque content completely fills
58321:  * our visible rect. We use UntransformRect which expands to the axis-aligned
58321:  * bounding rect, but that's OK since if
58321:  * mStoredList.GetVisibleRect().Contains(untransformedVisible), then it
58321:  * certainly contains the actual (non-axis-aligned) untransformed rect.
19214:  */
59779: nsRegion nsDisplayTransform::GetOpaqueRegion(nsDisplayListBuilder *aBuilder,
97420:                                              bool* aSnap)
19214: {
95051:   *aSnap = false;
74283:   nsRect untransformedVisible;
90079:   float factor = nsPresContext::AppUnitsPerCSSPixel();
90079:   if (!UntransformRectMatrix(mVisibleRect, GetTransform(factor), factor, &untransformedVisible)) {
74283:       return nsRegion();
74283:   }
74281:   
74283:   const gfx3DMatrix& matrix = GetTransform(nsPresContext::AppUnitsPerCSSPixel());
74281: 
59779:   nsRegion result;
74283:   gfxMatrix matrix2d;
95051:   bool tmpSnap;
74283:   if (matrix.Is2D(&matrix2d) &&
74283:       matrix2d.PreservesAxisAlignedRectangles() &&
97420:       mStoredList.GetOpaqueRegion(aBuilder, &tmpSnap).Contains(untransformedVisible)) {
59779:     result = mVisibleRect;
59779:   }
59779:   return result;
19214: }
19214: 
19214: /* The transform is uniform if it fills the entire bounding rect and the
59779:  * wrapped list is uniform.  See GetOpaqueRegion for discussion of why this
19214:  * works.
19214:  */
79445: bool nsDisplayTransform::IsUniform(nsDisplayListBuilder *aBuilder, nscolor* aColor)
19214: {
74283:   nsRect untransformedVisible;
90079:   float factor = nsPresContext::AppUnitsPerCSSPixel();
90079:   if (!UntransformRectMatrix(mVisibleRect, GetTransform(factor), factor, &untransformedVisible)) {
80486:     return false;
74283:   }
74283:   const gfx3DMatrix& matrix = GetTransform(nsPresContext::AppUnitsPerCSSPixel());
74281: 
74283:   gfxMatrix matrix2d;
74283:   return matrix.Is2D(&matrix2d) &&
74283:          matrix2d.PreservesAxisAlignedRectangles() &&
58321:          mStoredList.GetVisibleRect().Contains(untransformedVisible) &&
42436:          mStoredList.IsUniform(aBuilder, aColor);
19214: }
19214: 
19214: /* If UNIFIED_CONTINUATIONS is defined, we can merge two display lists that
19214:  * share the same underlying content.  Otherwise, doing so results in graphical
19214:  * glitches.
19214:  */
19214: #ifndef UNIFIED_CONTINUATIONS
19214: 
79445: bool
19214: nsDisplayTransform::TryMerge(nsDisplayListBuilder *aBuilder,
19214:                              nsDisplayItem *aItem)
19214: {
80486:   return false;
19214: }
19214: 
19214: #else
19214: 
79445: bool
19214: nsDisplayTransform::TryMerge(nsDisplayListBuilder *aBuilder,
19214:                              nsDisplayItem *aItem)
19214: {
19214:   NS_PRECONDITION(aItem, "Why did you try merging with a null item?");
19214:   NS_PRECONDITION(aBuilder, "Why did you try merging with a null builder?");
19214: 
19214:   /* Make sure that we're dealing with two transforms. */
19214:   if (aItem->GetType() != TYPE_TRANSFORM)
80486:     return false;
19214: 
19214:   /* Check to see that both frames are part of the same content. */
19214:   if (aItem->GetUnderlyingFrame()->GetContent() != mFrame->GetContent())
80486:     return false;
19214: 
19214:   /* Now, move everything over to this frame and signal that
19214:    * we merged things!
19214:    */
95348:   mStoredList.MergeFrom(&static_cast<nsDisplayTransform*>(aItem)->mStoredList);
80486:   return true;
19214: }
19214: 
19214: #endif
19214: 
19214: /* TransformRect takes in as parameters a rectangle (in app space) and returns
19214:  * the smallest rectangle (in app space) containing the transformed image of
19214:  * that rectangle.  That is, it takes the four corners of the rectangle,
19214:  * transforms them according to the matrix associated with the specified frame,
19214:  * then returns the smallest rectangle containing the four transformed points.
19214:  *
19214:  * @param aUntransformedBounds The rectangle (in app units) to transform.
19214:  * @param aFrame The frame whose transformation should be applied.
19214:  * @param aOrigin The delta from the frame origin to the coordinate space origin
19214:  * @param aBoundsOverride (optional) Force the frame bounds to be the
19214:  *        specified bounds.
19214:  * @return The smallest rectangle containing the image of the transformed
19214:  *         rectangle.
19214:  */
19214: nsRect nsDisplayTransform::TransformRect(const nsRect &aUntransformedBounds,
19214:                                          const nsIFrame* aFrame,
19214:                                          const nsPoint &aOrigin,
19214:                                          const nsRect* aBoundsOverride)
19214: {
19214:   NS_PRECONDITION(aFrame, "Can't take the transform based on a null frame!");
19214: 
19214:   float factor = nsPresContext::AppUnitsPerCSSPixel();
19214:   return nsLayoutUtils::MatrixTransformRect
19214:     (aUntransformedBounds,
19214:      GetResultingTransformMatrix(aFrame, aOrigin, factor, aBoundsOverride),
19214:      factor);
19214: }
19214: 
63072: nsRect nsDisplayTransform::TransformRectOut(const nsRect &aUntransformedBounds,
63072:                                             const nsIFrame* aFrame,
63072:                                             const nsPoint &aOrigin,
63072:                                             const nsRect* aBoundsOverride)
63072: {
63072:   NS_PRECONDITION(aFrame, "Can't take the transform based on a null frame!");
63072: 
63072:   float factor = nsPresContext::AppUnitsPerCSSPixel();
63072:   return nsLayoutUtils::MatrixTransformRectOut
63072:     (aUntransformedBounds,
63072:      GetResultingTransformMatrix(aFrame, aOrigin, factor, aBoundsOverride),
63072:      factor);
63072: }
63072: 
90079: bool nsDisplayTransform::UntransformRectMatrix(const nsRect &aUntransformedBounds,
90079:                                                const gfx3DMatrix& aMatrix,
90354:                                                float aAppUnitsPerPixel,
90079:                                                nsRect *aOutRect)
90079: {
90079:   if (aMatrix.IsSingular())
90079:     return false;
90079: 
90354:   gfxRect result(NSAppUnitsToFloatPixels(aUntransformedBounds.x, aAppUnitsPerPixel),
90354:                  NSAppUnitsToFloatPixels(aUntransformedBounds.y, aAppUnitsPerPixel),
90354:                  NSAppUnitsToFloatPixels(aUntransformedBounds.width, aAppUnitsPerPixel),
90354:                  NSAppUnitsToFloatPixels(aUntransformedBounds.height, aAppUnitsPerPixel));
90079: 
90079:   /* We want to untransform the matrix, so invert the transformation first! */
90079:   result = aMatrix.Inverse().ProjectRectBounds(result);
90079: 
90354:   *aOutRect = nsLayoutUtils::RoundGfxRectToAppRect(result, aAppUnitsPerPixel);
90079: 
90079:   return true;
90079: }
90079: 
79445: bool nsDisplayTransform::UntransformRect(const nsRect &aUntransformedBounds,
19214:                                            const nsIFrame* aFrame,
74283:                                            const nsPoint &aOrigin,
74283:                                            nsRect* aOutRect)
19214: {
19214:   NS_PRECONDITION(aFrame, "Can't take the transform based on a null frame!");
19214: 
19214:   /* Grab the matrix.  If the transform is degenerate, just hand back the
19214:    * empty rect.
19214:    */
19214:   float factor = nsPresContext::AppUnitsPerCSSPixel();
74283:   gfx3DMatrix matrix = GetResultingTransformMatrix(aFrame, aOrigin, factor, nsnull);
90079: 
90079:   return UntransformRectMatrix(aUntransformedBounds, matrix, factor, aOutRect);
19214: }
19214: 
51260: nsDisplaySVGEffects::nsDisplaySVGEffects(nsDisplayListBuilder* aBuilder,
51260:                                          nsIFrame* aFrame, nsDisplayList* aList)
95644:     : nsDisplayWrapList(aBuilder, aFrame, aList),
95348:       mEffectsBounds(aFrame->GetVisualOverflowRectRelativeToSelf())
19125: {
19125:   MOZ_COUNT_CTOR(nsDisplaySVGEffects);
19125: }
19125: 
19125: #ifdef NS_BUILD_REFCNT_LOGGING
19125: nsDisplaySVGEffects::~nsDisplaySVGEffects()
19125: {
19125:   MOZ_COUNT_DTOR(nsDisplaySVGEffects);
19125: }
19125: #endif
19125: 
59779: nsRegion nsDisplaySVGEffects::GetOpaqueRegion(nsDisplayListBuilder* aBuilder,
97420:                                               bool* aSnap)
19125: {
95051:   *aSnap = false;
59779:   return nsRegion();
19125: }
19125: 
40570: void
40570: nsDisplaySVGEffects::HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
40570:                              HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames)
19125: {
40570:   nsPoint rectCenter(aRect.x + aRect.width / 2, aRect.y + aRect.height / 2);
95644:   if (nsSVGIntegrationUtils::HitTestFrameForEffects(mFrame,
95644:       rectCenter - ToReferenceFrame())) {
40570:     mList.HitTest(aBuilder, aRect, aState, aOutFrames);
40570:   }
19125: }
19125: 
19125: void nsDisplaySVGEffects::Paint(nsDisplayListBuilder* aBuilder,
68481:                                 nsRenderingContext* aCtx)
19125: {
19125:   nsSVGIntegrationUtils::PaintFramesWithEffects(aCtx,
95644:           mFrame, mVisibleRect, aBuilder, &mList);
19125: }
19125: 
79445: bool nsDisplaySVGEffects::ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                               nsRegion* aVisibleRegion,
69802:                                               const nsRect& aAllowVisibleRegionExpansion) {
95644:   nsPoint offset = ToReferenceFrame();
34210:   nsRect dirtyRect =
95644:     nsSVGIntegrationUtils::GetRequiredSourceForInvalidArea(mFrame,
34210:                                                            mVisibleRect - offset) +
34210:     offset;
19125: 
34210:   // Our children may be made translucent or arbitrarily deformed so we should
34210:   // not allow them to subtract area from aVisibleRegion.
34210:   nsRegion childrenVisible(dirtyRect);
98137:   nsRect r = dirtyRect.Intersect(mList.GetBounds(aBuilder));
69802:   mList.ComputeVisibilityForSublist(aBuilder, &childrenVisible, r, nsRect());
80486:   return true;
19125: }
19125: 
79445: bool nsDisplaySVGEffects::TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem)
19125: {
19125:   if (aItem->GetType() != TYPE_SVG_EFFECTS)
80486:     return false;
19125:   // items for the same content element should be merged into a single
19125:   // compositing group
19125:   // aItem->GetUnderlyingFrame() returns non-null because it's nsDisplaySVGEffects
19125:   if (aItem->GetUnderlyingFrame()->GetContent() != mFrame->GetContent())
80486:     return false;
19125:   nsDisplaySVGEffects* other = static_cast<nsDisplaySVGEffects*>(aItem);
95566:   MergeFromTrackingMergedFrames(other);
95348:   mEffectsBounds.UnionRect(mEffectsBounds,
95644:     other->mEffectsBounds + other->mFrame->GetOffsetTo(mFrame));
80486:   return true;
19125: }
82353: 
82353: #ifdef MOZ_DUMP_PAINTING
82353: void
82353: nsDisplaySVGEffects::PrintEffects(FILE* aOutput)
82353: {
82353:   nsIFrame* firstFrame =
95644:     nsLayoutUtils::GetFirstContinuationOrSpecialSibling(mFrame);
82353:   nsSVGEffects::EffectProperties effectProperties =
82353:     nsSVGEffects::GetEffectProperties(firstFrame);
82353:   bool isOK = true;
82353:   nsSVGClipPathFrame *clipPathFrame = effectProperties.GetClipPathFrame(&isOK);
82353:   bool first = true;
82353:   fprintf(aOutput, " effects=(");
95644:   if (mFrame->GetStyleDisplay()->mOpacity != 1.0f) {
82353:     first = false;
95644:     fprintf(aOutput, "opacity(%f)", mFrame->GetStyleDisplay()->mOpacity);
82353:   }
82353:   if (clipPathFrame) {
82353:     if (!first) {
82353:       fprintf(aOutput, ", ");
82353:     }
82353:     fprintf(aOutput, "clip(%s)", clipPathFrame->IsTrivial() ? "trivial" : "non-trivial");
82353:     first = false;
82353:   }
82353:   if (effectProperties.GetFilterFrame(&isOK)) {
82353:     if (!first) {
82353:       fprintf(aOutput, ", ");
82353:     }
82353:     fprintf(aOutput, "filter");
82353:     first = false;
82353:   }
82353:   if (effectProperties.GetMaskFrame(&isOK)) {
82353:     if (!first) {
82353:       fprintf(aOutput, ", ");
82353:     }
82353:     fprintf(aOutput, "mask");
82353:   }
82353:   fprintf(aOutput, ")");
82353: }
82353: #endif
82353: 
