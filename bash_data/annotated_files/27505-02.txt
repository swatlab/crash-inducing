    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Paul Ashford <arougthopher@lizardland.net>
    1:  *   Sergei Dolgov <sergei_d@fi.tartu.ee>
    1:  *   Fredrik Holmqvist <thesuckiestemail@yahoo.se>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #ifndef Window_h__
    1: #define Window_h__
    1: #define BeIME
    1: 
    1: #include "nsBaseWidget.h"
    1: #include "nsdefs.h"
    1: #include "nsSwitchToUIThread.h"
    1: #include "nsToolkit.h"
    1: 
    1: #include "nsIWidget.h"
    1: 
    1: #include "nsIEventListener.h"
    1: #include "nsString.h"
    1: #include "nsRegion.h"
    1: 
    1: #include <Window.h>
    1: #include <View.h>
    1: #include <Region.h>
    1: 
    1: #if defined(BeIME)
    1: #include <Messenger.h>
    1: #endif
    1: 
    1: #include <gfxBeOSSurface.h>
    1: 
    1: #define NSRGB_2_COLOREF(color) \
    1:             RGB(NS_GET_R(color),NS_GET_G(color),NS_GET_B(color))
    1: 
    1: // forward declaration
    1: class nsViewBeOS;
    1: class nsIRollupListener;
    1: #if defined(BeIME)
    1: class nsIMEBeOS;
    1: #endif
    1: 
    1: /**
    1:  * Native BeOS window wrapper. 
    1:  */
    1: 
    1: class nsWindow : public nsSwitchToUIThread,
    1:                  public nsBaseWidget
    1: {
    1: 
    1: public:
    1: 	nsWindow();
    1: 	virtual ~nsWindow();
    1: 
    1: 	// In BeOS, each window runs in its own thread.  Because of this,
    1: 	// we have a proxy layer between the mozilla UI thread, and calls made
    1: 	// within the window's thread via CallMethod().  However, since the windows
    1: 	// are still running in their own thread, and reference counting takes place within
    1: 	// that thread, we need to reference and de-reference outselves atomically.
    1: 	// See BugZilla Bug# 92793
    1: 	NS_IMETHOD_(nsrefcnt) AddRef(void);                                       
    1: 	NS_IMETHOD_(nsrefcnt) Release(void);          
    1: 
    1: 	// nsIWidget interface
    1: 	NS_IMETHOD              Create(nsIWidget *aParent,
    1: 	                               const nsRect &aRect,
    1: 	                               EVENT_CALLBACK aHandleEventFunction,
    1: 	                               nsIDeviceContext *aContext,
    1: 	                               nsIAppShell *aAppShell = nsnull,
    1: 	                               nsIToolkit *aToolkit = nsnull,
    1: 	                               nsWidgetInitData *aInitData = nsnull);
    1: 	NS_IMETHOD              Create(nsNativeWidget aParent,
    1: 	                               const nsRect &aRect,
    1: 	                               EVENT_CALLBACK aHandleEventFunction,
    1: 	                               nsIDeviceContext *aContext,
    1: 	                               nsIAppShell *aAppShell = nsnull,
    1: 	                               nsIToolkit *aToolkit = nsnull,
    1: 	                               nsWidgetInitData *aInitData = nsnull);
    1: 
    1: 	// Utility method for implementing both Create(nsIWidget ...) and
    1: 	// Create(nsNativeWidget...)
    1: 
    1: 	NS_IMETHOD          PreCreateWidget(nsWidgetInitData *aWidgetInitData);
    1: 
    1: 	virtual nsresult        StandardWindowCreate(nsIWidget *aParent,
    1: 	                                             const nsRect &aRect,
    1: 	                                             EVENT_CALLBACK aHandleEventFunction,
    1: 	                                             nsIDeviceContext *aContext,
    1: 	                                             nsIAppShell *aAppShell,
    1: 	                                             nsIToolkit *aToolkit,
    1: 	                                             nsWidgetInitData *aInitData,
    1: 	                                             nsNativeWidget aNativeParent = nsnull);
    1: 
    1: 	gfxASurface*            GetThebesSurface();
    1: 
    1: 	NS_IMETHOD              Destroy();
    1: 	virtual nsIWidget*        GetParent(void);
    1: 	NS_IMETHOD              Show(PRBool bState);
    1:  	NS_IMETHOD              CaptureMouse(PRBool aCapture);
    1: 	NS_IMETHOD              CaptureRollupEvents(nsIRollupListener *aListener,
    1: 	                                            PRBool aDoCapture,
    1: 	                                            PRBool aConsumeRollupEvent);
    1: 	NS_IMETHOD              IsVisible(PRBool & aState);
    1: 
    1: 	NS_IMETHOD              ConstrainPosition(PRBool aAllowSlop,
    1: 	                                          PRInt32 *aX, PRInt32 *aY);
    1: 	NS_IMETHOD              Move(PRInt32 aX, PRInt32 aY);
    1: 	NS_IMETHOD              Resize(PRInt32 aWidth,
    1: 	                               PRInt32 aHeight,
    1: 	                               PRBool   aRepaint);
    1: 	NS_IMETHOD              Resize(PRInt32 aX,
    1: 	                               PRInt32 aY,
    1: 	                               PRInt32 aWidth,
    1: 	                               PRInt32 aHeight,
    1: 	                               PRBool   aRepaint);
    1: 	NS_IMETHOD              SetModal(PRBool aModal);
    1: 	NS_IMETHOD              Enable(PRBool aState);
    1: 	NS_IMETHOD              IsEnabled(PRBool *aState);
    1: 	NS_IMETHOD              SetFocus(PRBool aRaise);
    1: 	NS_IMETHOD              GetScreenBounds(nsRect &aRect);
    1: 	NS_IMETHOD              SetBackgroundColor(const nscolor &aColor);
    1: 	NS_IMETHOD              SetCursor(nsCursor aCursor);
    1: 	NS_IMETHOD              Invalidate(PRBool aIsSynchronous);
    1: 	NS_IMETHOD              Invalidate(const nsRect & aRect, PRBool aIsSynchronous);
    1: 	NS_IMETHOD              InvalidateRegion(const nsIRegion *aRegion,
    1: 	                                         PRBool aIsSynchronous);
    1: 	NS_IMETHOD              Update();
    1: 	virtual void*           GetNativeData(PRUint32 aDataType);
    1: 	NS_IMETHOD              SetColorMap(nsColorMap *aColorMap);
    1: 	NS_IMETHOD              Scroll(PRInt32 aDx, PRInt32 aDy, nsRect *aClipRect);
    1: 	NS_IMETHOD              SetTitle(const nsAString& aTitle);
15578: 	NS_IMETHOD              SetMenuBar(void * aMenuBar) { return NS_ERROR_FAILURE; }
    1: 	NS_IMETHOD              ShowMenuBar(PRBool aShow) { return NS_ERROR_FAILURE; }
    1: 	NS_IMETHOD              WidgetToScreen(const nsRect& aOldRect, nsRect& aNewRect);
    1: 	NS_IMETHOD              ScreenToWidget(const nsRect& aOldRect, nsRect& aNewRect);
    1: 	NS_IMETHOD              BeginResizingChildren(void);
    1: 	NS_IMETHOD              EndResizingChildren(void);
    1: 	NS_IMETHOD              GetPreferredSize(PRInt32& aWidth, PRInt32& aHeight);
    1: 	NS_IMETHOD              SetPreferredSize(PRInt32 aWidth, PRInt32 aHeight);
    1: 	NS_IMETHOD              DispatchEvent(nsGUIEvent* event, nsEventStatus & aStatus);
    1: 	NS_IMETHOD              HideWindowChrome(PRBool aShouldHide);
    1: 
    1: 	virtual void            ConvertToDeviceCoordinates(nscoord	&aX,nscoord	&aY) {}
    1: 
    1: 
    1: 	// nsSwitchToUIThread interface
    1: 	virtual bool            CallMethod(MethodInfo *info);
    1: 	virtual PRBool          DispatchMouseEvent(PRUint32 aEventType, 
    1: 	                                           nsPoint aPoint, 
    1: 	                                           PRUint32 clicks, 
    1: 	                                           PRUint32 mod,
    1: 	                                           PRUint16 aButton = nsMouseEvent::eLeftButton);
    1: 
    1: 
    1: 	void                   InitEvent(nsGUIEvent& event, nsPoint* aPoint = nsnull);
    1: 
    1: protected:
    1: 
    1: 	static PRBool           EventIsInsideWindow(nsWindow* aWindow, nsPoint pos) ;
    1: 	static PRBool           DealWithPopups(uint32 methodID, nsPoint pos);
    1:     // Following methods need to be virtual if we will subclassing
    1: 	void                    OnDestroy();
    1: 	void                    OnWheel(PRInt32 aDirection, uint32 aButtons, BPoint aPoint, nscoord aDelta);
    1: 	PRBool                  OnMove(PRInt32 aX, PRInt32 aY);
    1: 	nsresult                OnPaint(BRegion *breg);
    1: 	PRBool                  OnResize(nsRect &aWindowRect);
    1: 	PRBool                  OnKeyDown(PRUint32 aEventType, 
    1: 	                                  const char *bytes, 
    1: 	                                  int32 numBytes, 
    1: 	                                  PRUint32 mod, 
    1: 	                                  PRUint32 bekeycode, 
    1: 	                                  int32 rawcode);
    1: 	PRBool                  OnKeyUp(PRUint32 aEventType, 
    1: 	                                const char *bytes, 
    1: 	                                int32 numBytes, 
    1: 	                                PRUint32 mod, 
    1: 	                                PRUint32 bekeycode, 
    1: 	                                int32 rawcode);
    1: 	PRBool                  DispatchKeyEvent(PRUint32 aEventType, PRUint32 aCharCode,
    1:                                            PRUint32 aKeyCode, PRUint32 aFlags = 0);
    1: 	PRBool                  DispatchFocus(PRUint32 aEventType);
    1: 	static PRBool           ConvertStatus(nsEventStatus aStatus)
    1: 	                        { return aStatus == nsEventStatus_eConsumeNoDefault; }
    1: 	PRBool                  DispatchStandardEvent(PRUint32 aMsg);
    1: 
    1: 	PRBool                  DispatchWindowEvent(nsGUIEvent* event);
    1: 	void                    HideKids(PRBool state);
    1: 
    1: 
    1: 	nsCOMPtr<nsIWidget> mParent;
    1: 	nsWindow*        mWindowParent;
    1: 	nsCOMPtr<nsIRegion> mUpdateArea;
    1: 	nsIFontMetrics*  mFontMetrics;
    1: 
    1: 	nsViewBeOS*      mView;
    1: 	PRInt32          mPreferredWidth;
    1: 	PRInt32          mPreferredHeight;
    1: 	window_feel      mBWindowFeel;
    1: 	window_look      mBWindowLook;
    1: 
    1: 	nsRefPtr<gfxBeOSSurface> mThebesSurface;
    1: 
    1: 	//Just for saving space we use packed bools.
    1: 	PRPackedBool           mIsTopWidgetWindow;
    1: 	PRPackedBool           mIsMetaDown;
27505: 	PRPackedBool           mIsShiftDown;
27505: 	PRPackedBool           mIsControlDown;
27505: 	PRPackedBool           mIsAltDown;
27505: 	PRPackedBool           mIsDestroying;
    1: 	PRPackedBool           mIsVisible;
    1: 	PRPackedBool           mEnabled;
    1: 	PRPackedBool           mIsScrolling;
    1: 	PRPackedBool           mListenForResizes;
    1: 	
    1: public:	// public on BeOS to allow BViews to access it
    1: 
    1: 	nsToolkit *GetToolkit() { return (nsToolkit *)nsBaseWidget::GetToolkit(); }
    1: };
    1: 
    1: //
    1: // Each class need to subclass this as part of the subclass
    1: //
    1: class nsIWidgetStore
    1: {
    1: public:
    1: 	                        nsIWidgetStore(nsIWidget *aWindow);
    1: 	virtual                ~nsIWidgetStore();
    1: 
    1: 	virtual nsIWidget      *GetMozillaWidget(void);
    1: 
    1: private:
    1: 	nsIWidget       *mWidget;
    1: };
    1: 
    1: //
    1: // A BWindow subclass
    1: //
    1: class nsWindowBeOS : public BWindow, public nsIWidgetStore
    1: {
    1: public:
    1: 	                        nsWindowBeOS(nsIWidget *aWidgetWindow,  
    1: 	                                     BRect aFrame, 
    1: 	                                     const char *aName, 
    1: 	                                     window_look aLook,
    1: 	                                     window_feel aFeel, 
    1: 	                                     int32 aFlags, 
    1: 	                                     int32 aWorkspace = B_CURRENT_WORKSPACE);
    1: 	virtual                ~nsWindowBeOS();
    1: 
    1: 	virtual bool            QuitRequested( void );
    1: 	virtual void            MessageReceived(BMessage *msg);
    1: 	virtual void            DispatchMessage(BMessage *msg, BHandler *handler);
    1: 	virtual void            WindowActivated(bool active);
    1: 	virtual void            FrameMoved(BPoint origin);
    1: 	virtual void            WorkspacesChanged(uint32 oldworkspace, uint32 newworkspace);
    1: 	virtual void            FrameResized(float width, float height);
    1: 	bool                    fJustGotBounds;	
    1: private:
    1: 	BPoint          lastWindowPoint;
    1: };
    1: 
    1: //
    1: // A BView subclass
    1: //
    1: class nsViewBeOS : public BView, public nsIWidgetStore
    1: {
    1: public:
    1: 	                        nsViewBeOS(nsIWidget *aWidgetWindow, 
    1: 	                                   BRect aFrame, 
    1: 	                                   const char *aName,
    1: 	                                   uint32 aResizingMode, 
    1: 	                                   uint32 aFlags);
    1: 
    1: 	virtual void            Draw(BRect updateRect);
    1: 	virtual void            MouseDown(BPoint point);
    1: 	virtual void            MouseMoved(BPoint point, 
    1: 	                                   uint32 transit, 
    1: 	                                   const BMessage *message);
    1: 	virtual void            MouseUp(BPoint point);
    1: 	bool                    GetPaintRegion(BRegion *breg);
    1: 	void                    Validate(BRegion *reg);
    1: 	BPoint                  GetWheel();
    1: 	void                    KeyDown(const char *bytes, int32 numBytes);
    1: 	void                    KeyUp(const char *bytes, int32 numBytes);
    1: 	virtual void            MakeFocus(bool focused);
    1: 	virtual void            MessageReceived(BMessage *msg);
    1: 	void                    SetVisible(bool visible);
    1: 	bool                    Visible();
    1: 	BRegion                 paintregion;
    1: 	uint32                  buttons;
    1: 
    1: private:
    1: #if defined(BeIME)
    1:  	void                 DoIME(BMessage *msg);
    1: #endif
    1: 	BPoint               mousePos;
    1: 	uint32               mouseMask;
    1: 	// actually it is delta, not point, using it as convenient x,y storage
    1: 	BPoint               wheel;
    1: 	bool                 fRestoreMouseMask;	
    1: 	bool                 fJustValidated;
    1: 	bool                 fWheelDispatched;
    1: 	bool                 fVisible;
    1: };
    1: 
    1: #if defined(BeIME)
    1: class nsIMEBeOS 
    1: {
    1: public:
    1: 	nsIMEBeOS();
    1: //	virtual ~nsIMEBeOS();
    1: 	void	RunIME(uint32 *args, nsWindow *owner, BView* view);
    1: 	void	DispatchText(nsString &text, PRUint32 txtCount, nsTextRange* txtRuns);
    1: 	void	DispatchIME(PRUint32 what);
    1: 	void	DispatchCancelIME();
    1: 	PRBool	DispatchWindowEvent(nsGUIEvent* event);
    1: 	
    1: 	static  nsIMEBeOS *GetIME();
    1: 
    1: private:
    1: 	nsWindow*	imeTarget;
    1: 	BMessenger	imeMessenger;
    1: 	nsString	imeText;
    1: 	BPoint		imeCaret;
    1: 	PRUint32	imeState, imeWidth, imeHeight;
    1: 	static	    nsIMEBeOS *beosIME;
    1: };
    1: #endif
    1: #endif // Window_h__
