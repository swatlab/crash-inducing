101616: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
101616: /* This Source Code Form is subject to the terms of the Mozilla Public
101616:  * License, v. 2.0. If a copy of the MPL was not distributed with this
101616:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
101616: 
101616: #include "HTMLTableAccessible.h"
101616: 
101616: #include "Accessible-inl.h"
101616: #include "nsAccessibilityService.h"
101616: #include "nsAccUtils.h"
101616: #include "DocAccessible.h"
122312: #include "nsIAccessibleRelation.h"
101616: #include "nsTextEquivUtils.h"
101616: #include "Relation.h"
101616: #include "Role.h"
101616: #include "States.h"
122312: #include "TreeWalker.h"
101616: 
101616: #include "nsIDOMElement.h"
101616: #include "nsIDOMDocument.h"
101616: #include "nsIDOMRange.h"
101616: #include "nsISelectionPrivate.h"
101616: #include "nsINameSpaceManager.h"
101616: #include "nsIDOMNodeList.h"
101616: #include "nsIDOMHTMLCollection.h"
101616: #include "nsIDOMHTMLTableCellElement.h"
101616: #include "nsIDOMHTMLTableElement.h"
101616: #include "nsIDOMHTMLTableRowElement.h"
101616: #include "nsIDOMHTMLTableSectionElem.h"
101616: #include "nsIDocument.h"
122312: #include "nsIMutableArray.h"
101616: #include "nsIPresShell.h"
101616: #include "nsITableLayout.h"
101616: #include "nsITableCellLayout.h"
101616: #include "nsFrameSelection.h"
108290: #include "nsError.h"
101616: #include "nsArrayUtils.h"
101616: #include "nsComponentManagerUtils.h"
101616: 
106071: using namespace mozilla;
101616: using namespace mozilla::a11y;
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // HTMLTableCellAccessible
101616: ////////////////////////////////////////////////////////////////////////////////
101616: 
101616: HTMLTableCellAccessible::
101616:   HTMLTableCellAccessible(nsIContent* aContent, DocAccessible* aDoc) :
106837:   HyperTextAccessibleWrap(aContent, aDoc), xpcAccessibleTableCell(this)
101616: {
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // HTMLTableCellAccessible: nsISupports implementation
101616: 
101616: NS_IMPL_ISUPPORTS_INHERITED1(HTMLTableCellAccessible,
101616:                              HyperTextAccessible,
101616:                              nsIAccessibleTableCell)
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // HTMLTableCellAccessible: Accessible implementation
101616: 
106837: void
106837: HTMLTableCellAccessible::Shutdown()
106837: {
106838:   mTableCell = nullptr;
106837:   HyperTextAccessibleWrap::Shutdown();
106837: }
106837: 
101616: role
101616: HTMLTableCellAccessible::NativeRole()
101616: {
101616:   return roles::CELL;
101616: }
101616: 
108991: uint64_t
101616: HTMLTableCellAccessible::NativeState()
101616: {
108991:   uint64_t state = HyperTextAccessibleWrap::NativeState();
101616: 
101616:   nsIFrame *frame = mContent->GetPrimaryFrame();
101616:   NS_ASSERTION(frame, "No frame for valid cell accessible!");
101616: 
101616:   if (frame && frame->IsSelected())
101616:     state |= states::SELECTED;
101616: 
101616:   return state;
101616: }
101616: 
108991: uint64_t
101616: HTMLTableCellAccessible::NativeInteractiveState() const
101616: {
101616:   return HyperTextAccessibleWrap::NativeInteractiveState() | states::SELECTABLE;
101616: }
101616: 
119399: already_AddRefed<nsIPersistentProperties>
119399: HTMLTableCellAccessible::NativeAttributes()
101616: {
119399:   nsCOMPtr<nsIPersistentProperties> attributes =
119399:     HyperTextAccessibleWrap::NativeAttributes();
101616: 
101616:   // table-cell-index attribute
111345:   TableAccessible* table = Table();
111345:   if (!table)
119399:     return attributes.forget();
101616: 
108991:   int32_t rowIdx = -1, colIdx = -1;
119399:   nsresult rv = GetCellIndexes(rowIdx, colIdx);
119399:   if (NS_FAILED(rv))
119399:     return attributes.forget();
101616: 
101616:   nsAutoString stringIdx;
111345:   stringIdx.AppendInt(table->CellIndexAt(rowIdx, colIdx));
119399:   nsAccUtils::SetAccAttr(attributes, nsGkAtoms::tableCellIndex, stringIdx);
101616: 
101616:   // abbr attribute
101616: 
101616:   // Pick up object attribute from abbr DOM element (a child of the cell) or
101616:   // from abbr DOM attribute.
101616:   nsAutoString abbrText;
101616:   if (ChildCount() == 1) {
101616:     Accessible* abbr = FirstChild();
101616:     if (abbr->IsAbbreviation()) {
125386:       nsIContent* firstChildNode = abbr->GetContent()->GetFirstChild();
125386:       if (firstChildNode) {
101616:         nsTextEquivUtils::
125386:           AppendTextEquivFromTextContent(firstChildNode, &abbrText);
125386:       }
101616:     }
101616:   }
101616:   if (abbrText.IsEmpty())
101616:     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::abbr, abbrText);
101616: 
101616:   if (!abbrText.IsEmpty())
119399:     nsAccUtils::SetAccAttr(attributes, nsGkAtoms::abbr, abbrText);
101616: 
101616:   // axis attribute
101616:   nsAutoString axisText;
101616:   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::axis, axisText);
101616:   if (!axisText.IsEmpty())
119399:     nsAccUtils::SetAccAttr(attributes, nsGkAtoms::axis, axisText);
101616: 
119399:   return attributes.forget();
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // HTMLTableCellAccessible: nsIAccessibleTableCell implementation
101616: 
111345: TableAccessible*
111345: HTMLTableCellAccessible::Table() const
101616: {
111345:   Accessible* parent = const_cast<HTMLTableCellAccessible*>(this);
111345:   while ((parent = parent->Parent())) {
111345:     roles::Role role = parent->Role();
111345:     if (role == roles::TABLE || role == roles::TREE_TABLE)
111345:       return parent->AsTable();
101616:   }
101616: 
111345:   return nullptr;
101616: }
101616: 
111345: uint32_t
111345: HTMLTableCellAccessible::ColIdx() const
101616: {
111345:   nsITableCellLayout* cellLayout = GetCellLayout();
111345:   NS_ENSURE_TRUE(cellLayout, 0);
101616: 
111345:   int32_t colIdx = 0;
111345:   cellLayout->GetColIndex(colIdx);
111345:   return colIdx > 0 ? static_cast<uint32_t>(colIdx) : 0;
101616: }
101616: 
111345: uint32_t
111345: HTMLTableCellAccessible::RowIdx() const
101616: {
111345:   nsITableCellLayout* cellLayout = GetCellLayout();
111345:   NS_ENSURE_TRUE(cellLayout, 0);
101616: 
111345:   int32_t rowIdx = 0;
111345:   cellLayout->GetRowIndex(rowIdx);
111345:   return rowIdx > 0 ? static_cast<uint32_t>(rowIdx) : 0;
111345: }
111345: 
111345: uint32_t
111345: HTMLTableCellAccessible::ColExtent() const
111345: {
108991:   int32_t rowIdx = -1, colIdx = -1;
101616:   GetCellIndexes(rowIdx, colIdx);
101616: 
111345:   TableAccessible* table = Table();
111345:   NS_ASSERTION(table, "cell not in a table!");
111345:   if (!table)
111345:     return 0;
101616: 
111345:   return table->ColExtentAt(rowIdx, colIdx);
101616: }
101616: 
111345: uint32_t
111345: HTMLTableCellAccessible::RowExtent() const
101616: {
108991:   int32_t rowIdx = -1, colIdx = -1;
101616:   GetCellIndexes(rowIdx, colIdx);
101616: 
111345:   TableAccessible* table = Table();
111345:   NS_ASSERTION(table, "cell not in atable!");
111345:   if (!table)
111345:     return 0;
101616: 
111345:   return table->RowExtentAt(rowIdx, colIdx);
101616: }
101616: 
111345: void
111345: HTMLTableCellAccessible::ColHeaderCells(nsTArray<Accessible*>* aCells)
101616: {
111345:   IDRefsIterator itr(mDoc, mContent, nsGkAtoms::headers);
111345:   while (Accessible* cell = itr.Next())
111345:     if (cell->Role() == roles::COLUMNHEADER)
111345:       aCells->AppendElement(cell);
101616: 
111345:   if (aCells->IsEmpty())
111345:     TableCellAccessible::ColHeaderCells(aCells);
101616: }
101616: 
111345: void
111345: HTMLTableCellAccessible::RowHeaderCells(nsTArray<Accessible*>* aCells)
101616: {
111345:   IDRefsIterator itr(mDoc, mContent, nsGkAtoms::headers);
111345:   while (Accessible* cell = itr.Next())
111345:     if (cell->Role() == roles::ROWHEADER)
111345:       aCells->AppendElement(cell);
101616: 
111345:   if (aCells->IsEmpty())
111345:     TableCellAccessible::RowHeaderCells(aCells);
101616: }
101616: 
111345: bool
111345: HTMLTableCellAccessible::Selected()
101616: {
108991:   int32_t rowIdx = -1, colIdx = -1;
101616:   GetCellIndexes(rowIdx, colIdx);
101616: 
111345:   TableAccessible* table = Table();
111345:   NS_ENSURE_TRUE(table, false);
101616: 
111345:   return table->IsCellSelected(rowIdx, colIdx);
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // HTMLTableCellAccessible: protected implementation
101616: 
111345: nsITableCellLayout*
111345: HTMLTableCellAccessible::GetCellLayout() const
101616: {
111345:   return do_QueryFrame(mContent->GetPrimaryFrame());
101616: }
101616: 
101616: nsresult
111345: HTMLTableCellAccessible::GetCellIndexes(int32_t& aRowIdx, int32_t& aColIdx) const
101616: {
101616:   nsITableCellLayout *cellLayout = GetCellLayout();
101616:   NS_ENSURE_STATE(cellLayout);
101616: 
111345:   return cellLayout->GetCellIndexes(aRowIdx, aColIdx);
101616: }
101616: 
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // HTMLTableHeaderCellAccessible
101616: ////////////////////////////////////////////////////////////////////////////////
101616: 
101616: HTMLTableHeaderCellAccessible::
101616:   HTMLTableHeaderCellAccessible(nsIContent* aContent, DocAccessible* aDoc) :
101616:   HTMLTableCellAccessible(aContent, aDoc)
101616: {
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // HTMLTableHeaderCellAccessible: Accessible implementation
101616: 
101616: role
101616: HTMLTableHeaderCellAccessible::NativeRole()
101616: {
101616:   // Check value of @scope attribute.
101616:   static nsIContent::AttrValuesArray scopeValues[] =
106838:     {&nsGkAtoms::col, &nsGkAtoms::row, nullptr};
108991:   int32_t valueIdx =
101616:     mContent->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::scope,
101616:                               scopeValues, eCaseMatters);
101616: 
101616:   switch (valueIdx) {
101616:     case 0:
101616:       return roles::COLUMNHEADER;
101616:     case 1:
101616:       return roles::ROWHEADER;
101616:   }
101616: 
101616:   // Assume it's columnheader if there are headers in siblings, oterwise
101616:   // rowheader.
101616:   nsIContent* parentContent = mContent->GetParent();
101616:   if (!parentContent) {
101616:     NS_ERROR("Deattached content on alive accessible?");
101616:     return roles::NOTHING;
101616:   }
101616: 
101616:   for (nsIContent* siblingContent = mContent->GetPreviousSibling(); siblingContent;
101616:        siblingContent = siblingContent->GetPreviousSibling()) {
101616:     if (siblingContent->IsElement()) {
101616:       return nsCoreUtils::IsHTMLTableHeader(siblingContent) ?
101616: 	     roles::COLUMNHEADER : roles::ROWHEADER;
101616:     }
101616:   }
101616: 
101616:   for (nsIContent* siblingContent = mContent->GetNextSibling(); siblingContent;
101616:        siblingContent = siblingContent->GetNextSibling()) {
101616:     if (siblingContent->IsElement()) {
101616:       return nsCoreUtils::IsHTMLTableHeader(siblingContent) ?
101616: 	     roles::COLUMNHEADER : roles::ROWHEADER;
101616:     }
101616:   }
101616: 
101616:   // No elements in siblings what means the table has one column only. Therefore
101616:   // it should be column header.
101616:   return roles::COLUMNHEADER;
101616: }
101616: 
124439: 
124439: ////////////////////////////////////////////////////////////////////////////////
124439: // HTMLTableRowAccessible
124439: ////////////////////////////////////////////////////////////////////////////////
124439: 
124439: NS_IMPL_ISUPPORTS_INHERITED0(HTMLTableRowAccessible, Accessible)
124439: 
124439: role
124439: HTMLTableRowAccessible::NativeRole()
124439: {
124439:   return roles::ROW;
124439: }
124439: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // HTMLTableAccessible
101616: ////////////////////////////////////////////////////////////////////////////////
101616: 
101616: HTMLTableAccessible::
101616:   HTMLTableAccessible(nsIContent* aContent, DocAccessible* aDoc) :
101616:   AccessibleWrap(aContent, aDoc), xpcAccessibleTable(this)
101616: {
124439:   mFlags |= eTableAccessible;
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // HTMLTableAccessible: nsISupports implementation
101616: 
101616: NS_IMPL_ISUPPORTS_INHERITED1(HTMLTableAccessible, Accessible,
101616:                              nsIAccessibleTable)
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: //nsAccessNode
101616: 
101616: void
101616: HTMLTableAccessible::Shutdown()
101616: {
106838:   mTable = nullptr;
101616:   AccessibleWrap::Shutdown();
101616: }
101616: 
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // HTMLTableAccessible: Accessible implementation
101616: 
101616: void
101616: HTMLTableAccessible::CacheChildren()
101616: {
101616:   // Move caption accessible so that it's the first child. Check for the first
101616:   // caption only, because nsAccessibilityService ensures we don't create
101616:   // accessibles for the other captions, since only the first is actually
101616:   // visible.
122312:   TreeWalker walker(this, mContent);
101616: 
106838:   Accessible* child = nullptr;
101616:   while ((child = walker.NextChild())) {
101616:     if (child->Role() == roles::CAPTION) {
101616:       InsertChildAt(0, child);
101616:       while ((child = walker.NextChild()) && AppendChild(child));
101616:       break;
101616:     }
101616:     AppendChild(child);
101616:   }
101616: }
101616: 
101616: role
101616: HTMLTableAccessible::NativeRole()
101616: {
101616:   return roles::TABLE;
101616: }
101616: 
108991: uint64_t
101616: HTMLTableAccessible::NativeState()
101616: {
101616:   return Accessible::NativeState() | states::READONLY;
101616: }
101616: 
118863: ENameValueFlag
118863: HTMLTableAccessible::NativeName(nsString& aName)
101616: {
119159:   ENameValueFlag nameFlag = Accessible::NativeName(aName);
101616:   if (!aName.IsEmpty())
119159:     return nameFlag;
101616: 
101616:   // Use table caption as a name.
101616:   Accessible* caption = Caption();
101616:   if (caption) {
101616:     nsIContent* captionContent = caption->GetContent();
101616:     if (captionContent) {
101616:       nsTextEquivUtils::AppendTextEquivFromContent(this, captionContent, &aName);
101616:       if (!aName.IsEmpty())
118863:         return eNameOK;
101616:     }
101616:   }
101616: 
101616:   // If no caption then use summary as a name.
101616:   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::summary, aName);
118863:   return eNameOK;
101616: }
101616: 
119399: already_AddRefed<nsIPersistentProperties>
119399: HTMLTableAccessible::NativeAttributes()
101616: {
119399:   nsCOMPtr<nsIPersistentProperties> attributes =
119399:     AccessibleWrap::NativeAttributes();
101616:   if (IsProbablyLayoutTable()) {
119399:     nsAutoString unused;
119399:     attributes->SetStringProperty(NS_LITERAL_CSTRING("layout-guess"),
119399:                                   NS_LITERAL_STRING("true"), unused);
101616:   }
101616: 
119399:   return attributes.forget();
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // HTMLTableAccessible: nsIAccessible implementation
101616: 
101616: Relation
108991: HTMLTableAccessible::RelationByType(uint32_t aType)
101616: {
101616:   Relation rel = AccessibleWrap::RelationByType(aType);
101616:   if (aType == nsIAccessibleRelation::RELATION_LABELLED_BY)
101616:     rel.AppendTarget(Caption());
101616: 
101616:   return rel;
101616: }
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // HTMLTableAccessible: nsIAccessibleTable implementation
101616: 
101616: Accessible*
101616: HTMLTableAccessible::Caption()
101616: {
106838:   Accessible* child = mChildren.SafeElementAt(0, nullptr);
106838:   return child && child->Role() == roles::CAPTION ? child : nullptr;
101616: }
101616: 
101616: void
101616: HTMLTableAccessible::Summary(nsString& aSummary)
101616: {
101616:   nsCOMPtr<nsIDOMHTMLTableElement> table(do_QueryInterface(mContent));
101616: 
101616:   if (table)
101616:     table->GetSummary(aSummary);
101616: }
101616: 
108991: uint32_t
101616: HTMLTableAccessible::ColCount()
101616: {
101616:   nsITableLayout* tableLayout = GetTableLayout();
101616:   if (!tableLayout)
101616:     return 0;
101616: 
108991:   int32_t rowCount = 0, colCount = 0;
101616:   tableLayout->GetTableSize(rowCount, colCount);
101616:   return colCount;
101616: }
101616: 
108991: uint32_t
101616: HTMLTableAccessible::RowCount()
101616: {
101616:   nsITableLayout* tableLayout = GetTableLayout();
101616:   if (!tableLayout)
101616:     return 0;
101616: 
108991:   int32_t rowCount = 0, colCount = 0;
101616:   tableLayout->GetTableSize(rowCount, colCount);
101616:   return rowCount;
101616: }
101616: 
108991: uint32_t
102458: HTMLTableAccessible::SelectedCellCount()
101616: {
102458:   nsITableLayout *tableLayout = GetTableLayout();
102458:   if (!tableLayout)
102458:     return 0;
101616: 
108991:   uint32_t count = 0, rowCount = RowCount(), colCount = ColCount();
101616: 
101616:   nsCOMPtr<nsIDOMElement> domElement;
108991:   int32_t startRowIndex = 0, startColIndex = 0,
101616:     rowSpan, colSpan, actualRowSpan, actualColSpan;
101616:   bool isSelected = false;
101616: 
108991:   for (uint32_t rowIdx = 0; rowIdx < rowCount; rowIdx++) {
108991:     for (uint32_t colIdx = 0; colIdx < colCount; colIdx++) {
102458:       nsresult rv = tableLayout->GetCellDataAt(rowIdx, colIdx,
101616:                                                *getter_AddRefs(domElement),
101616:                                                startRowIndex, startColIndex,
101616:                                                rowSpan, colSpan,
101616:                                                actualRowSpan, actualColSpan,
101616:                                                isSelected);
101616: 
102458:       if (NS_SUCCEEDED(rv) && startRowIndex == rowIdx &&
102458:           startColIndex == colIdx && isSelected)
102458:         count++;
101616:     }
101616:   }
101616: 
102458:   return count;
101616: }
101616: 
108991: uint32_t
102458: HTMLTableAccessible::SelectedColCount()
101616: {
108991:   uint32_t count = 0, colCount = ColCount();
101616: 
108991:   for (uint32_t colIdx = 0; colIdx < colCount; colIdx++)
102458:     if (IsColSelected(colIdx))
102458:       count++;
101616: 
102458:   return count;
101616: }
101616: 
108991: uint32_t
102458: HTMLTableAccessible::SelectedRowCount()
102458: {
108991:   uint32_t count = 0, rowCount = RowCount();
101616: 
108991:   for (uint32_t rowIdx = 0; rowIdx < rowCount; rowIdx++)
102458:     if (IsRowSelected(rowIdx))
102458:       count++;
101616: 
102458:   return count;
101616: }
101616: 
103223: void
103223: HTMLTableAccessible::SelectedCells(nsTArray<Accessible*>* aCells)
101616: {
108991:   uint32_t rowCount = RowCount(), colCount = ColCount();
101616: 
101616:   nsITableLayout *tableLayout = GetTableLayout();
103223:   if (!tableLayout) 
103223:     return;
101616: 
101616:   nsCOMPtr<nsIDOMElement> cellElement;
108991:   int32_t startRowIndex = 0, startColIndex = 0,
101616:     rowSpan, colSpan, actualRowSpan, actualColSpan;
101616:   bool isSelected = false;
101616: 
108991:   for (uint32_t rowIdx = 0; rowIdx < rowCount; rowIdx++) {
108991:     for (uint32_t colIdx = 0; colIdx < colCount; colIdx++) {
103223:       nsresult rv = tableLayout->GetCellDataAt(rowIdx, colIdx,
101616:                                       *getter_AddRefs(cellElement),
101616:                                       startRowIndex, startColIndex,
101616:                                       rowSpan, colSpan,
101616:                                       actualRowSpan, actualColSpan,
101616:                                       isSelected);
101616: 
103223:       if (NS_SUCCEEDED(rv) && startRowIndex == rowIdx &&
103223:           startColIndex == colIdx && isSelected) {
101616:         nsCOMPtr<nsIContent> cellContent(do_QueryInterface(cellElement));
101616:         Accessible* cell = mDoc->GetAccessible(cellContent);
103223:         aCells->AppendElement(cell);
101616:       }
101616:     }
101616:   }
101616: }
101616: 
102803: void
108991: HTMLTableAccessible::SelectedCellIndices(nsTArray<uint32_t>* aCells)
101616: {
102803:   nsITableLayout *tableLayout = GetTableLayout();
102803:   if (!tableLayout)
102803:     return;
101616: 
108991:   uint32_t rowCount = RowCount(), colCount = ColCount();
101616: 
101616:   nsCOMPtr<nsIDOMElement> domElement;
108991:   int32_t startRowIndex = 0, startColIndex = 0,
101616:     rowSpan, colSpan, actualRowSpan, actualColSpan;
101616:   bool isSelected = false;
101616: 
108991:   for (uint32_t rowIdx = 0; rowIdx < rowCount; rowIdx++) {
108991:     for (uint32_t colIdx = 0; colIdx < colCount; colIdx++) {
102803:       nsresult rv = tableLayout->GetCellDataAt(rowIdx, colIdx,
101616:                                                *getter_AddRefs(domElement),
101616:                                                startRowIndex, startColIndex,
101616:                                                rowSpan, colSpan,
101616:                                                actualRowSpan, actualColSpan,
101616:                                                isSelected);
101616: 
102803:       if (NS_SUCCEEDED(rv) && startRowIndex == rowIdx &&
102803:           startColIndex == colIdx && isSelected)
102803:         aCells->AppendElement(CellIndexAt(rowIdx, colIdx));
101616:     }
101616:   }
101616: }
101616: 
102803: void
108991: HTMLTableAccessible::SelectedColIndices(nsTArray<uint32_t>* aCols)
102803: {
108991:   uint32_t colCount = ColCount();
108991:   for (uint32_t colIdx = 0; colIdx < colCount; colIdx++)
102803:     if (IsColSelected(colIdx))
102803:       aCols->AppendElement(colIdx);
101616: }
101616: 
102803: void
108991: HTMLTableAccessible::SelectedRowIndices(nsTArray<uint32_t>* aRows)
101616: {
108991:   uint32_t rowCount = RowCount();
108991:   for (uint32_t rowIdx = 0; rowIdx < rowCount; rowIdx++)
102803:     if (IsRowSelected(rowIdx))
102803:       aRows->AppendElement(rowIdx);
101616: }
101616: 
101616: Accessible*
108991: HTMLTableAccessible::CellAt(uint32_t aRowIndex, uint32_t aColumnIndex)
101616: { 
101616:   nsCOMPtr<nsIDOMElement> cellElement;
101616:   GetCellAt(aRowIndex, aColumnIndex, *getter_AddRefs(cellElement));
101616:   if (!cellElement)
106838:     return nullptr;
101616: 
101616:   nsCOMPtr<nsIContent> cellContent(do_QueryInterface(cellElement));
101616:   if (!cellContent)
106838:     return nullptr;
101616: 
101616:   Accessible* cell = mDoc->GetAccessible(cellContent);
101616: 
101616:   // XXX bug 576838: crazy tables (like table6 in tables/test_table2.html) may
101616:   // return itself as a cell what makes Orca hang.
106838:   return cell == this ? nullptr : cell;
101616: }
101616: 
108991: int32_t
108991: HTMLTableAccessible::CellIndexAt(uint32_t aRowIdx, uint32_t aColIdx)
101616: {
101616:   nsITableLayout* tableLayout = GetTableLayout();
101616: 
108991:   int32_t index = -1;
101616:   tableLayout->GetIndexByRowAndColumn(aRowIdx, aColIdx, &index);
101616:   return index;
101616: }
101616: 
108991: int32_t
108991: HTMLTableAccessible::ColIndexAt(uint32_t aCellIdx)
101616: {
102804:   nsITableLayout* tableLayout = GetTableLayout();
102804:   if (!tableLayout) 
102804:     return -1;
101616: 
108991:   int32_t rowIdx = -1, colIdx = -1;
102804:   tableLayout->GetRowAndColumnByIndex(aCellIdx, &rowIdx, &colIdx);
102804:   return colIdx;
101616: }
101616: 
108991: int32_t
108991: HTMLTableAccessible::RowIndexAt(uint32_t aCellIdx)
101616: {
102804:   nsITableLayout* tableLayout = GetTableLayout();
102804:   if (!tableLayout) 
102804:     return -1;
101616: 
108991:   int32_t rowIdx = -1, colIdx = -1;
102804:   tableLayout->GetRowAndColumnByIndex(aCellIdx, &rowIdx, &colIdx);
102804:   return rowIdx;
101616: }
101616: 
102804: void
108991: HTMLTableAccessible::RowAndColIndicesAt(uint32_t aCellIdx, int32_t* aRowIdx,
108991:                                         int32_t* aColIdx)
101616: {
102804:   nsITableLayout* tableLayout = GetTableLayout();
101616: 
101616:   if (tableLayout)
102804:     tableLayout->GetRowAndColumnByIndex(aCellIdx, aRowIdx, aColIdx);
101616: }
101616: 
108991: uint32_t
108991: HTMLTableAccessible::ColExtentAt(uint32_t aRowIdx, uint32_t aColIdx)
101616: {
101616:   nsITableLayout* tableLayout = GetTableLayout();
101616:   if (!tableLayout)
101616:     return 0;
101616: 
101616:   nsCOMPtr<nsIDOMElement> domElement;
108991:   int32_t startRowIndex, startColIndex, rowSpan, colSpan, actualRowSpan;
101616:   bool isSelected;
108991:   int32_t columnExtent = 0;
101616: 
106071:   DebugOnly<nsresult> rv = tableLayout->
101616:     GetCellDataAt(aRowIdx, aColIdx, *getter_AddRefs(domElement),
101616:                   startRowIndex, startColIndex, rowSpan, colSpan,
101616:                   actualRowSpan, columnExtent, isSelected);
106071:   NS_ASSERTION(NS_SUCCEEDED(rv), "Could not get cell data");
101616: 
101616:   return columnExtent;
101616: }
101616: 
108991: uint32_t
108991: HTMLTableAccessible::RowExtentAt(uint32_t aRowIdx, uint32_t aColIdx)
101616: {
101616:   nsITableLayout* tableLayout = GetTableLayout();
101616:   if (!tableLayout)
101616:     return 0;
101616: 
101616:   nsCOMPtr<nsIDOMElement> domElement;
108991:   int32_t startRowIndex, startColIndex, rowSpan, colSpan, actualColSpan;
101616:   bool isSelected;
108991:   int32_t rowExtent = 0;
101616: 
106071:   DebugOnly<nsresult> rv = tableLayout->
101616:     GetCellDataAt(aRowIdx, aColIdx, *getter_AddRefs(domElement),
101616:                   startRowIndex, startColIndex, rowSpan, colSpan,
101616:                   rowExtent, actualColSpan, isSelected);
106071:   NS_ASSERTION(NS_SUCCEEDED(rv), "Could not get cell data");
101616: 
101616:   return rowExtent;
101616: }
101616: 
102096: bool
108991: HTMLTableAccessible::IsColSelected(uint32_t aColIdx)
101616: {
102096:   bool isSelected = false;
101616: 
108991:   uint32_t rowCount = RowCount();
108991:   for (uint32_t rowIdx = 0; rowIdx < rowCount; rowIdx++) {
102096:     isSelected = IsCellSelected(rowIdx, aColIdx);
101616:     if (!isSelected)
102096:       return false;
101616:   }
101616: 
102096:   return isSelected;
101616: }
101616: 
102096: bool
108991: HTMLTableAccessible::IsRowSelected(uint32_t aRowIdx)
101616: {
102096:   bool isSelected = false;
101616: 
108991:   uint32_t colCount = ColCount();
108991:   for (uint32_t colIdx = 0; colIdx < colCount; colIdx++) {
102096:     isSelected = IsCellSelected(aRowIdx, colIdx);
101616:     if (!isSelected)
102096:       return false;
101616:   }
101616: 
102096:   return isSelected;
101616: }
101616: 
102096: bool
108991: HTMLTableAccessible::IsCellSelected(uint32_t aRowIdx, uint32_t aColIdx)
101616: {
101616:   nsITableLayout *tableLayout = GetTableLayout();
102096:   if (!tableLayout)
102096:     return false;
101616: 
101616:   nsCOMPtr<nsIDOMElement> domElement;
108991:   int32_t startRowIndex = 0, startColIndex = 0,
101616:           rowSpan, colSpan, actualRowSpan, actualColSpan;
102096:   bool isSelected = false;
101616: 
102096:   tableLayout->GetCellDataAt(aRowIdx, aColIdx, *getter_AddRefs(domElement),
101616:                              startRowIndex, startColIndex, rowSpan, colSpan,
102096:                              actualRowSpan, actualColSpan, isSelected);
101616: 
102096:   return isSelected;
101616: }
101616: 
101672: void
108991: HTMLTableAccessible::SelectRow(uint32_t aRowIdx)
101616: {
102096:   nsresult rv =
102096:     RemoveRowsOrColumnsFromSelection(aRowIdx,
101616:                                      nsISelectionPrivate::TABLESELECTION_ROW,
101616:                                      true);
101672:   NS_ASSERTION(NS_SUCCEEDED(rv),
101672:                "RemoveRowsOrColumnsFromSelection() Shouldn't fail!");
101616: 
101672:   AddRowOrColumnToSelection(aRowIdx, nsISelectionPrivate::TABLESELECTION_ROW);
101616: }
101616: 
101672: void
108991: HTMLTableAccessible::SelectCol(uint32_t aColIdx)
101616: {
102096:   nsresult rv =
102096:     RemoveRowsOrColumnsFromSelection(aColIdx,
101616:                                      nsISelectionPrivate::TABLESELECTION_COLUMN,
101616:                                      true);
101672:   NS_ASSERTION(NS_SUCCEEDED(rv),
101672:                "RemoveRowsOrColumnsFromSelection() Shouldn't fail!");
101616: 
101672:   AddRowOrColumnToSelection(aColIdx, nsISelectionPrivate::TABLESELECTION_COLUMN);
101616: }
101616: 
101616: void
108991: HTMLTableAccessible::UnselectRow(uint32_t aRowIdx)
101616: {
101616:   RemoveRowsOrColumnsFromSelection(aRowIdx,
101616:                                    nsISelectionPrivate::TABLESELECTION_ROW,
101616:                                    false);
101616: }
101616: 
101616: void
108991: HTMLTableAccessible::UnselectCol(uint32_t aColIdx)
101616: {
101616:   RemoveRowsOrColumnsFromSelection(aColIdx,
101616:                                    nsISelectionPrivate::TABLESELECTION_COLUMN,
101616:                                    false);
101616: }
101616: 
101616: nsresult
108991: HTMLTableAccessible::AddRowOrColumnToSelection(int32_t aIndex, uint32_t aTarget)
101616: {
101616:   bool doSelectRow = (aTarget == nsISelectionPrivate::TABLESELECTION_ROW);
101616: 
101616:   nsITableLayout *tableLayout = GetTableLayout();
101616:   NS_ENSURE_STATE(tableLayout);
101616: 
101616:   nsCOMPtr<nsIDOMElement> cellElm;
108991:   int32_t startRowIdx, startColIdx, rowSpan, colSpan,
101616:     actualRowSpan, actualColSpan;
101616:   bool isSelected = false;
101616: 
101616:   nsresult rv = NS_OK;
108991:   int32_t count = 0;
101616:   if (doSelectRow)
101616:     rv = GetColumnCount(&count);
101616:   else
101616:     rv = GetRowCount(&count);
101616: 
101616:   NS_ENSURE_SUCCESS(rv, rv);
101616: 
101616:   nsIPresShell* presShell(mDoc->PresShell());
101616:   nsRefPtr<nsFrameSelection> tableSelection =
101616:     const_cast<nsFrameSelection*>(presShell->ConstFrameSelection());
101616: 
108991:   for (int32_t idx = 0; idx < count; idx++) {
108991:     int32_t rowIdx = doSelectRow ? aIndex : idx;
108991:     int32_t colIdx = doSelectRow ? idx : aIndex;
101616:     rv = tableLayout->GetCellDataAt(rowIdx, colIdx,
101616:                                     *getter_AddRefs(cellElm),
101616:                                     startRowIdx, startColIdx,
101616:                                     rowSpan, colSpan,
101616:                                     actualRowSpan, actualColSpan,
101616:                                     isSelected);
101616: 
101616:     if (NS_SUCCEEDED(rv) && !isSelected) {
101616:       nsCOMPtr<nsIContent> cellContent(do_QueryInterface(cellElm));
101616:       rv = tableSelection->SelectCellElement(cellContent);
101616:       NS_ENSURE_SUCCESS(rv, rv);
101616:     }
101616:   }
101616: 
101616:   return NS_OK;
101616: }
101616: 
101616: nsresult
108991: HTMLTableAccessible::RemoveRowsOrColumnsFromSelection(int32_t aIndex,
108991:                                                       uint32_t aTarget,
101616:                                                       bool aIsOuter)
101616: {
101616:   nsITableLayout *tableLayout = GetTableLayout();
101616:   NS_ENSURE_STATE(tableLayout);
101616: 
101616:   nsIPresShell* presShell(mDoc->PresShell());
101616:   nsRefPtr<nsFrameSelection> tableSelection =
101616:     const_cast<nsFrameSelection*>(presShell->ConstFrameSelection());
101616: 
101616:   bool doUnselectRow = (aTarget == nsISelectionPrivate::TABLESELECTION_ROW);
108991:   int32_t count = 0;
101616:   nsresult rv = doUnselectRow ? GetColumnCount(&count) : GetRowCount(&count);
101616:   NS_ENSURE_SUCCESS(rv, rv);
101616: 
108991:   int32_t startRowIdx = doUnselectRow ? aIndex : 0;
108991:   int32_t endRowIdx = doUnselectRow ? aIndex : count - 1;
108991:   int32_t startColIdx = doUnselectRow ? 0 : aIndex;
108991:   int32_t endColIdx = doUnselectRow ? count - 1 : aIndex;
101616: 
101616:   if (aIsOuter)
101616:     return tableSelection->RestrictCellsToSelection(mContent,
101616:                                                     startRowIdx, startColIdx,
101616:                                                     endRowIdx, endColIdx);
101616: 
101616:   return tableSelection->RemoveCellsFromSelection(mContent,
101616:                                                   startRowIdx, startColIdx,
101616:                                                   endRowIdx, endColIdx);
101616: }
101616: 
101616: nsITableLayout*
101616: HTMLTableAccessible::GetTableLayout()
101616: {
101616:   nsIFrame *frame = mContent->GetPrimaryFrame();
101616:   if (!frame)
106838:     return nullptr;
101616: 
101616:   nsITableLayout *tableLayout = do_QueryFrame(frame);
101616:   return tableLayout;
101616: }
101616: 
101616: nsresult
108991: HTMLTableAccessible::GetCellAt(int32_t aRowIndex, int32_t aColIndex,
101616:                                nsIDOMElement*& aCell)
101616: {
108991:   int32_t startRowIndex = 0, startColIndex = 0,
101616:           rowSpan, colSpan, actualRowSpan, actualColSpan;
101616:   bool isSelected;
101616: 
101616:   nsITableLayout *tableLayout = GetTableLayout();
101616:   NS_ENSURE_STATE(tableLayout);
101616: 
101616:   nsresult rv = tableLayout->
101616:     GetCellDataAt(aRowIndex, aColIndex, aCell, startRowIndex, startColIndex,
101616:                   rowSpan, colSpan, actualRowSpan, actualColSpan, isSelected);
101616: 
101616:   if (rv == NS_TABLELAYOUT_CELL_NOT_FOUND)
101616:     return NS_ERROR_INVALID_ARG;
101616:   return rv;
101616: }
101616: 
101616: void
101616: HTMLTableAccessible::Description(nsString& aDescription)
101616: {
101616:   // Helpful for debugging layout vs. data tables
101616:   aDescription.Truncate();
101616:   Accessible::Description(aDescription);
101616:   if (!aDescription.IsEmpty())
101616:     return;
101616: 
101616:   // Use summary as description if it weren't used as a name.
101616:   // XXX: get rid code duplication with NameInternal().
101616:   Accessible* caption = Caption();
101616:   if (caption) {
101616:     nsIContent* captionContent = caption->GetContent();
101616:     if (captionContent) {
101616:       nsAutoString captionText;
101616:       nsTextEquivUtils::AppendTextEquivFromContent(this, captionContent,
101616:                                                    &captionText);
101616: 
101616:       if (!captionText.IsEmpty()) { // summary isn't used as a name.
101616:         mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::summary,
101616:                           aDescription);
101616:       }
101616:     }
101616:   }
101616: 
101616: #ifdef SHOW_LAYOUT_HEURISTIC
101616:   if (aDescription.IsEmpty()) {
101616:     bool isProbablyForLayout = IsProbablyLayoutTable();
101616:     aDescription = mLayoutHeuristic;
101616:   }
101616:   printf("\nTABLE: %s\n", NS_ConvertUTF16toUTF8(mLayoutHeuristic).get());
101616: #endif
101616: }
101616: 
101616: bool
101616: HTMLTableAccessible::HasDescendant(const nsAString& aTagName, bool aAllowEmpty)
101616: {
101616:   nsCOMPtr<nsIDOMElement> tableElt(do_QueryInterface(mContent));
101616:   NS_ENSURE_TRUE(tableElt, false);
101616: 
119414:   nsCOMPtr<nsIDOMHTMLCollection> nodeList;
101616:   tableElt->GetElementsByTagName(aTagName, getter_AddRefs(nodeList));
101616:   NS_ENSURE_TRUE(nodeList, false);
101616: 
101616:   nsCOMPtr<nsIDOMNode> foundItem;
101616:   nodeList->Item(0, getter_AddRefs(foundItem));
101616:   if (!foundItem)
101616:     return false;
101616: 
101616:   if (aAllowEmpty)
101616:     return true;
101616: 
101616:   // Make sure that the item we found has contents and either has multiple
101616:   // children or the found item is not a whitespace-only text node.
101616:   nsCOMPtr<nsIContent> foundItemContent = do_QueryInterface(foundItem);
101616:   if (foundItemContent->GetChildCount() > 1)
101616:     return true; // Treat multiple child nodes as non-empty
101616: 
101616:   nsIContent *innerItemContent = foundItemContent->GetFirstChild();
101616:   if (innerItemContent && !innerItemContent->TextIsOnlyWhitespace())
101616:     return true;
101616: 
101616:   // If we found more than one node then return true not depending on
101616:   // aAllowEmpty flag.
101616:   // XXX it might be dummy but bug 501375 where we changed this addresses
101616:   // performance problems only. Note, currently 'aAllowEmpty' flag is used for
101616:   // caption element only. On another hand we create accessible object for
101616:   // the first entry of caption element (see
101616:   // HTMLTableAccessible::CacheChildren).
101616:   nodeList->Item(1, getter_AddRefs(foundItem));
101616:   return !!foundItem;
101616: }
101616: 
101616: bool
101616: HTMLTableAccessible::IsProbablyLayoutTable()
101616: {
101616:   // Implement a heuristic to determine if table is most likely used for layout
101616:   // XXX do we want to look for rowspan or colspan, especialy that span all but a couple cells
101616:   // at the beginning or end of a row/col, and especially when they occur at the edge of a table?
101616:   // XXX expose this info via object attributes to AT-SPI
101616: 
101616:   // XXX For now debugging descriptions are always on via SHOW_LAYOUT_HEURISTIC
101616:   // This will allow release trunk builds to be used by testers to refine the algorithm
101616:   // Change to |#define SHOW_LAYOUT_HEURISTIC DEBUG| before final release
101616: #ifdef SHOW_LAYOUT_HEURISTIC
101616: #define RETURN_LAYOUT_ANSWER(isLayout, heuristic) \
101616:   { \
101616:     mLayoutHeuristic = isLayout ? \
101616:       NS_LITERAL_STRING("layout table: " heuristic) : \
101616:       NS_LITERAL_STRING("data table: " heuristic); \
101616:     return isLayout; \
101616:   }
101616: #else
101616: #define RETURN_LAYOUT_ANSWER(isLayout, heuristic) { return isLayout; }
101616: #endif
101616: 
101616:   DocAccessible* docAccessible = Document();
101616:   if (docAccessible) {
108991:     uint64_t docState = docAccessible->State();
101616:     if (docState & states::EDITABLE) {  // Need to see all elements while document is being edited
101616:       RETURN_LAYOUT_ANSWER(false, "In editable document");
101616:     }
101616:   }
101616: 
101616:   // Check to see if an ARIA role overrides the role from native markup,
101616:   // but for which we still expose table semantics (treegrid, for example).
101616:   if (Role() != roles::TABLE)
101616:     RETURN_LAYOUT_ANSWER(false, "Has role attribute");
101616: 
101616:   if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::role)) {
101616:     // Role attribute is present, but overridden roles have already been dealt with.
101616:     // Only landmarks and other roles that don't override the role from native
101616:     // markup are left to deal with here.
101616:     RETURN_LAYOUT_ANSWER(false, "Has role attribute, weak role, and role is table");
101616:   }
101616: 
101616:   if (mContent->Tag() != nsGkAtoms::table)
101616:     RETURN_LAYOUT_ANSWER(true, "table built by CSS display:table style");
101616: 
101616:   // Check if datatable attribute has "0" value.
101616:   if (mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::datatable,
101616:                             NS_LITERAL_STRING("0"), eCaseMatters)) {
101616:     RETURN_LAYOUT_ANSWER(true, "Has datatable = 0 attribute, it's for layout");
101616:   }
101616: 
101616:   // Check for legitimate data table attributes.
101616:   nsAutoString summary;
101616:   if (mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::summary, summary) &&
101616:       !summary.IsEmpty())
101616:     RETURN_LAYOUT_ANSWER(false, "Has summary -- legitimate table structures");
101616: 
101616:   // Check for legitimate data table elements.
101616:   Accessible* caption = FirstChild();
101616:   if (caption && caption->Role() == roles::CAPTION && caption->HasChildren()) 
101616:     RETURN_LAYOUT_ANSWER(false, "Not empty caption -- legitimate table structures");
101616: 
101616:   for (nsIContent* childElm = mContent->GetFirstChild(); childElm;
101616:        childElm = childElm->GetNextSibling()) {
101616:     if (!childElm->IsHTML())
101616:       continue;
101616: 
101616:     if (childElm->Tag() == nsGkAtoms::col ||
101616:         childElm->Tag() == nsGkAtoms::colgroup ||
101616:         childElm->Tag() == nsGkAtoms::tfoot ||
101616:         childElm->Tag() == nsGkAtoms::thead) {
101616:       RETURN_LAYOUT_ANSWER(false,
101616:                            "Has col, colgroup, tfoot or thead -- legitimate table structures");
101616:     }
101616: 
101616:     if (childElm->Tag() == nsGkAtoms::tbody) {
101616:       for (nsIContent* rowElm = childElm->GetFirstChild(); rowElm;
101616:            rowElm = rowElm->GetNextSibling()) {
101616:         if (rowElm->IsHTML() && rowElm->Tag() == nsGkAtoms::tr) {
101616:           for (nsIContent* cellElm = rowElm->GetFirstChild(); cellElm;
101616:                cellElm = cellElm->GetNextSibling()) {
101616:             if (cellElm->IsHTML()) {
101616: 
101616:               if (cellElm->NodeInfo()->Equals(nsGkAtoms::th)) {
101616:                 RETURN_LAYOUT_ANSWER(false,
101616:                                      "Has th -- legitimate table structures");
101616:               }
101616: 
101616:               if (cellElm->HasAttr(kNameSpaceID_None, nsGkAtoms::headers) ||
101616:                   cellElm->HasAttr(kNameSpaceID_None, nsGkAtoms::scope) ||
101616:                   cellElm->HasAttr(kNameSpaceID_None, nsGkAtoms::abbr)) {
101616:                 RETURN_LAYOUT_ANSWER(false,
101616:                                      "Has headers, scope, or abbr attribute -- legitimate table structures");
101616:               }
101616: 
101616:               Accessible* cell = mDoc->GetAccessible(cellElm);
101616:               if (cell && cell->ChildCount() == 1 &&
101616:                   cell->FirstChild()->IsAbbreviation()) {
101616:                 RETURN_LAYOUT_ANSWER(false,
101616:                                      "has abbr -- legitimate table structures");
101616:               }
101616:             }
101616:           }
101616:         }
101616:       }
101616:     }
101616:   }
101616: 
101616:   if (HasDescendant(NS_LITERAL_STRING("table"))) {
101616:     RETURN_LAYOUT_ANSWER(true, "Has a nested table within it");
101616:   }
101616: 
101616:   // If only 1 column or only 1 row, it's for layout
108991:   int32_t columns, rows;
101616:   GetColumnCount(&columns);
101616:   if (columns <=1) {
101616:     RETURN_LAYOUT_ANSWER(true, "Has only 1 column");
101616:   }
101616:   GetRowCount(&rows);
101616:   if (rows <=1) {
101616:     RETURN_LAYOUT_ANSWER(true, "Has only 1 row");
101616:   }
101616: 
101616:   // Check for many columns
101616:   if (columns >= 5) {
101616:     RETURN_LAYOUT_ANSWER(false, ">=5 columns");
101616:   }
101616: 
101616:   // Now we know there are 2-4 columns and 2 or more rows
101616:   // Check to see if there are visible borders on the cells
101616:   // XXX currently, we just check the first cell -- do we really need to do more?
101616:   nsCOMPtr<nsIDOMElement> cellElement;
101616:   nsresult rv = GetCellAt(0, 0, *getter_AddRefs(cellElement));
108738:   NS_ENSURE_SUCCESS(rv, false);
101616: 
101616:   nsCOMPtr<nsIContent> cellContent(do_QueryInterface(cellElement));
108738:   NS_ENSURE_TRUE(cellContent, false);
101616:   nsIFrame *cellFrame = cellContent->GetPrimaryFrame();
101616:   if (!cellFrame) {
108738:     RETURN_LAYOUT_ANSWER(false, "Could not get frame for cellContent");
101616:   }
101616:   nsMargin border;
101616:   cellFrame->GetBorder(border);
101616:   if (border.top && border.bottom && border.left && border.right) {
101616:     RETURN_LAYOUT_ANSWER(false, "Has nonzero border-width on table cell");
101616:   }
101616: 
101616:   /**
101616:    * Rules for non-bordered tables with 2-4 columns and 2+ rows from here on forward
101616:    */
101616: 
101616:   // Check for styled background color across rows (alternating background
101616:   // color is a common feature for data tables).
108991:   uint32_t childCount = ChildCount();
102254:   nscolor rowColor = 0;
102254:   nscolor prevRowColor;
108991:   for (uint32_t childIdx = 0; childIdx < childCount; childIdx++) {
101616:     Accessible* child = GetChildAt(childIdx);
101616:     if (child->Role() == roles::ROW) {
101616:       prevRowColor = rowColor;
101616:       nsIFrame* rowFrame = child->GetFrame();
101616:       rowColor = rowFrame->GetStyleBackground()->mBackgroundColor;
101616: 
101616:       if (childIdx > 0 && prevRowColor != rowColor)
101616:         RETURN_LAYOUT_ANSWER(false, "2 styles of row background color, non-bordered");
101616:     }
101616:   }
101616: 
101616:   // Check for many rows
108991:   const int32_t kMaxLayoutRows = 20;
101616:   if (rows > kMaxLayoutRows) { // A ton of rows, this is probably for data
101616:     RETURN_LAYOUT_ANSWER(false, ">= kMaxLayoutRows (20) and non-bordered");
101616:   }
101616: 
101616:   // Check for very wide table.
101616:   nsIFrame* documentFrame = Document()->GetFrame();
101616:   nsSize documentSize = documentFrame->GetSize();
101616:   if (documentSize.width > 0) {
101616:     nsSize tableSize = GetFrame()->GetSize();
108991:     int32_t percentageOfDocWidth = (100 * tableSize.width) / documentSize.width;
101616:     if (percentageOfDocWidth > 95) {
101616:       // 3-4 columns, no borders, not a lot of rows, and 95% of the doc's width
101616:       // Probably for layout
101616:       RETURN_LAYOUT_ANSWER(true,
101616:                            "<= 4 columns, table width is 95% of document width");
101616:     }
101616:   }
101616: 
101616:   // Two column rules
101616:   if (rows * columns <= 10) {
101616:     RETURN_LAYOUT_ANSWER(true, "2-4 columns, 10 cells or less, non-bordered");
101616:   }
101616: 
101616:   if (HasDescendant(NS_LITERAL_STRING("embed")) ||
101616:       HasDescendant(NS_LITERAL_STRING("object")) ||
101616:       HasDescendant(NS_LITERAL_STRING("applet")) ||
101616:       HasDescendant(NS_LITERAL_STRING("iframe"))) {
101616:     RETURN_LAYOUT_ANSWER(true, "Has no borders, and has iframe, object, applet or iframe, typical of advertisements");
101616:   }
101616: 
101616:   RETURN_LAYOUT_ANSWER(false, "no layout factor strong enough, so will guess data");
101616: }
101616: 
101616: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // HTMLCaptionAccessible
101616: ////////////////////////////////////////////////////////////////////////////////
101616: 
101616: Relation
108991: HTMLCaptionAccessible::RelationByType(uint32_t aType)
101616: {
101616:   Relation rel = HyperTextAccessible::RelationByType(aType);
101616:   if (aType == nsIAccessibleRelation::RELATION_LABEL_FOR)
101616:     rel.AppendTarget(Parent());
101616: 
101616:   return rel;
101616: }
101616: 
101616: role
101616: HTMLCaptionAccessible::NativeRole()
101616: {
101616:   return roles::CAPTION;
101616: }
