33903: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
33903: /* ***** BEGIN LICENSE BLOCK *****
33903:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
33903:  *
33903:  * The contents of this file are subject to the Mozilla Public License Version
33903:  * 1.1 (the "License"); you may not use this file except in compliance with
33903:  * the License. You may obtain a copy of the License at
33903:  * http://www.mozilla.org/MPL/
33903:  *
33903:  * Software distributed under the License is distributed on an "AS IS" basis,
33903:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
33903:  * for the specific language governing rights and limitations under the
33903:  * License.
33903:  *
33903:  * The Original Code is mozilla.org code.
33903:  *
33903:  * The Initial Developer of the Original Code is Mozilla Foundation.
33903:  * Portions created by the Initial Developer are Copyright (C) 2009
33903:  * the Initial Developer. All Rights Reserved.
33903:  *
33903:  * Contributor(s):
33903:  *   Olli Pettay <Olli.Pettay@helsinki.fi> (Original Author)
33903:  *
33903:  * Alternatively, the contents of this file may be used under the terms of
33903:  * either of the GNU General Public License Version 2 or later (the "GPL"),
33903:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
33903:  * in which case the provisions of the GPL or the LGPL are applicable instead
33903:  * of those above. If you wish to allow use of your version of this file only
33903:  * under the terms of either the GPL or the LGPL, and not to allow others to
33903:  * use your version of this file under the terms of the MPL, indicate your
33903:  * decision by deleting the provisions above and replace them with the notice
33903:  * and other provisions required by the GPL or the LGPL. If you do not delete
33903:  * the provisions above, a recipient may use your version of this file under
33903:  * the terms of any one of the MPL, the GPL or the LGPL.
33903:  *
33903:  * ***** END LICENSE BLOCK ***** */
33903: #include "nsEventListenerService.h"
33903: #include "nsCOMArray.h"
43438: #include "nsEventListenerManager.h"
33903: #include "nsPIDOMEventTarget.h"
33903: #include "nsIVariant.h"
33903: #include "nsIServiceManager.h"
33903: #include "nsMemory.h"
33903: #include "nsContentUtils.h"
33903: #include "nsIXPConnect.h"
33903: #include "nsIDOMWindow.h"
33903: #include "nsPIDOMWindow.h"
33903: #include "nsJSUtils.h"
33903: #include "nsIPrivateDOMEvent.h"
33903: #include "nsIJSContextStack.h"
33903: #include "nsGUIEvent.h"
33903: #include "nsEventDispatcher.h"
33903: #include "nsIJSEventListener.h"
43438: #include "nsIDOMEventGroup.h"
33989: #ifdef MOZ_JSDEBUGGER
33989: #include "jsdIDebuggerService.h"
33989: #endif
33903: 
33903: NS_IMPL_CYCLE_COLLECTION_1(nsEventListenerInfo, mListener)
33903: 
40490: DOMCI_DATA(EventListenerInfo, nsEventListenerInfo)
40490: 
33903: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsEventListenerInfo)
33903:   NS_INTERFACE_MAP_ENTRY(nsIEventListenerInfo)
33903:   NS_INTERFACE_MAP_ENTRY(nsISupports)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(EventListenerInfo)
33903: NS_INTERFACE_MAP_END
33903: 
33903: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsEventListenerInfo)
33903: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsEventListenerInfo)
33903: 
33903: NS_IMETHODIMP
33903: nsEventListenerInfo::GetType(nsAString& aType)
33903: {
33903:   aType = mType;
33903:   return NS_OK;
33903: }
33903: 
33903: NS_IMETHODIMP
33903: nsEventListenerInfo::GetCapturing(PRBool* aCapturing)
33903: {
33903:   *aCapturing = mCapturing;
33903:   return NS_OK;
33903: }
33903: 
33903: NS_IMETHODIMP
33903: nsEventListenerInfo::GetAllowsUntrusted(PRBool* aAllowsUntrusted)
33903: {
33903:   *aAllowsUntrusted = mAllowsUntrusted;
33903:   return NS_OK;
33903: }
33903: 
33903: NS_IMETHODIMP
33903: nsEventListenerInfo::GetInSystemEventGroup(PRBool* aInSystemEventGroup)
33903: {
33903:   *aInSystemEventGroup = mInSystemEventGroup;
33903:   return NS_OK;
33903: }
33903: 
33903: NS_IMPL_ISUPPORTS1(nsEventListenerService, nsIEventListenerService)
33903: 
33989: // Caller must root *aJSVal!
33989: PRBool
33989: nsEventListenerInfo::GetJSVal(jsval* aJSVal)
33989: {
33989:   *aJSVal = JSVAL_NULL;
33989:   nsCOMPtr<nsIXPConnectWrappedJS> wrappedJS = do_QueryInterface(mListener);
33989:   if (wrappedJS) {
33989:     JSObject* object = nsnull;
33989:     wrappedJS->GetJSObject(&object);
33989:     *aJSVal = OBJECT_TO_JSVAL(object);
33989:     return PR_TRUE;
33989:   }
33989: 
33989:   nsCOMPtr<nsIJSEventListener> jsl = do_QueryInterface(mListener);
33989:   if (jsl) {
33989:     nsresult rv = jsl->GetJSVal(mType, aJSVal);
33989:     if (NS_SUCCEEDED(rv)) {
33989:       return PR_TRUE;
33989:     }
33989:   }
33989:   return PR_FALSE;
33989: }
33989: 
33903: NS_IMETHODIMP
33903: nsEventListenerInfo::ToSource(nsAString& aResult)
33903: {
33903:   aResult.SetIsVoid(PR_TRUE);
33989: 
33903:   nsCOMPtr<nsIThreadJSContextStack> stack =
33903:     nsContentUtils::ThreadJSContextStack();
33903:   if (stack) {
33903:     JSContext* cx = nsnull;
33903:     stack->GetSafeJSContext(&cx);
33903:     if (cx && NS_SUCCEEDED(stack->Push(cx))) {
48481:       {
48481:         // Extra block to finish the auto request before calling pop
33903:         JSAutoRequest ar(cx);
58977:         jsval v = JSVAL_NULL;
58977:         if (GetJSVal(&v)) {
33903:           JSString* str = JS_ValueToSource(cx, v);
33903:           if (str) {
59889:             nsDependentJSString depStr;
59889:             if (depStr.init(cx, str)) {
59889:               aResult.Assign(depStr);
59889:             }
33903:           }
48481:         }
58977:       }
33903:       stack->Pop(&cx);
33903:     }
33903:   }
33989:   
33989:   return NS_OK;
33903: }
33989: 
33989: NS_IMETHODIMP
33989: nsEventListenerInfo::GetDebugObject(nsISupports** aRetVal)
33989: {
33989:   *aRetVal = nsnull;
33989: 
33989: #ifdef MOZ_JSDEBUGGER
33989:   nsresult rv = NS_OK;
33989:   nsCOMPtr<jsdIDebuggerService> jsd =
33989:     do_GetService("@mozilla.org/js/jsd/debugger-service;1", &rv);
33989:   NS_ENSURE_SUCCESS(rv, NS_OK);
33989:   
33989:   PRBool isOn = PR_FALSE;
33989:   jsd->GetIsOn(&isOn);
33989:   NS_ENSURE_TRUE(isOn, NS_OK);
33989: 
58977:   nsCOMPtr<nsIThreadJSContextStack> stack =
58977:     nsContentUtils::ThreadJSContextStack();
58977:   if (stack) {
58977:     JSContext* cx = nsnull;
58977:     stack->GetSafeJSContext(&cx);
58977:     if (cx && NS_SUCCEEDED(stack->Push(cx))) {
58977:       {
58977:         // Extra block to finish the auto request before calling pop
58977:         JSAutoRequest ar(cx);
58977: 
58977:         jsval v = JSVAL_NULL;
58977:         if (GetJSVal(&v)) {
33989:           nsCOMPtr<jsdIValue> jsdValue;
33989:           jsd->WrapJSValue(v, getter_AddRefs(jsdValue));
33989:           *aRetVal = jsdValue.forget().get();
33903:         }
58977:       }
61057:       stack->Pop(&cx);
58977:     }
58977:   }
33989: #endif
33989: 
33903:   return NS_OK;
33903: }
33903: 
33903: NS_IMETHODIMP
33903: nsEventListenerService::GetListenerInfoFor(nsIDOMEventTarget* aEventTarget,
33903:                                            PRUint32* aCount,
33903:                                            nsIEventListenerInfo*** aOutArray)
33903: {
33903:   *aCount = 0;
33903:   *aOutArray = nsnull;
33903:   nsCOMArray<nsIEventListenerInfo> listenerInfos;
33903:   nsCOMPtr<nsPIDOMEventTarget> target = do_QueryInterface(aEventTarget);
33903:   if (target) {
33903:     nsCOMPtr<nsIEventListenerManager> elm =
33903:       target->GetListenerManager(PR_FALSE);
33903:     if (elm) {
33903:       elm->GetListenerInfo(&listenerInfos);
33903:     }
33903:   }
33903: 
33903:   PRInt32 count = listenerInfos.Count();
33903:   if (count == 0) {
33903:     return NS_OK;
33903:   }
33903: 
33903:   *aOutArray =
33903:     static_cast<nsIEventListenerInfo**>(
33903:       nsMemory::Alloc(sizeof(nsIEventListenerInfo*) * count));
33903:   NS_ENSURE_TRUE(*aOutArray, NS_ERROR_OUT_OF_MEMORY);
33903: 
33903:   for (PRInt32 i = 0; i < count; ++i) {
33903:     NS_ADDREF((*aOutArray)[i] = listenerInfos[i]);
33903:   }
33903:   *aCount = count;
33903:   return NS_OK;
33903: }
33903: 
33903: NS_IMETHODIMP
33903: nsEventListenerService::GetEventTargetChainFor(nsIDOMEventTarget* aEventTarget,
33903:                                                PRUint32* aCount,
33903:                                                nsIDOMEventTarget*** aOutArray)
33903: {
33903:   *aCount = 0;
33903:   *aOutArray = nsnull;
33903:   nsCOMPtr<nsPIDOMEventTarget> target = do_QueryInterface(aEventTarget);
33903:   NS_ENSURE_ARG(target);
33903:   nsEvent event(PR_TRUE, NS_EVENT_TYPE_NULL);
33903:   nsCOMArray<nsPIDOMEventTarget> targets;
33903:   nsresult rv = nsEventDispatcher::Dispatch(target, nsnull, &event,
33903:                                             nsnull, nsnull, nsnull, &targets);
33903:   NS_ENSURE_SUCCESS(rv, rv);
33903:   PRInt32 count = targets.Count();
33903:   if (count == 0) {
33903:     return NS_OK;
33903:   }
33903: 
33903:   *aOutArray =
33903:     static_cast<nsIDOMEventTarget**>(
33903:       nsMemory::Alloc(sizeof(nsPIDOMEventTarget*) * count));
33903:   NS_ENSURE_TRUE(*aOutArray, NS_ERROR_OUT_OF_MEMORY);
33903: 
33903:   for (PRInt32 i = 0; i < count; ++i) {
33903:     nsCOMPtr<nsIDOMEventTarget> target = do_QueryInterface(targets[i]);
33903:     (*aOutArray)[i] = target.forget().get();
33903:   }
33903:   *aCount = count;
33903: 
33903:   return NS_OK;
33903: }
33903: 
43438: NS_IMETHODIMP
43438: nsEventListenerService::GetSystemEventGroup(nsIDOMEventGroup** aSystemGroup)
43438: {
43438:   NS_ENSURE_ARG_POINTER(aSystemGroup);
43438:   *aSystemGroup = nsEventListenerManager::GetSystemEventGroup();
43438:   NS_ENSURE_TRUE(*aSystemGroup, NS_ERROR_OUT_OF_MEMORY);
43438:   NS_ADDREF(*aSystemGroup);
43438:   return NS_OK;
43438: }
43438: 
33903: nsresult
33903: NS_NewEventListenerService(nsIEventListenerService** aResult)
33903: {
33903:   *aResult = new nsEventListenerService();
33903:   NS_ENSURE_TRUE(*aResult, NS_ERROR_OUT_OF_MEMORY);
33903:   NS_ADDREF(*aResult);
33903:   return NS_OK;
33903: }
