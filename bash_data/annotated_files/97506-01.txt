94512: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-*/
94512: /* vim: set ts=2 sw=2 et tw=79: */
94512: /* This Source Code Form is subject to the terms of the Mozilla Public
94512:  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
94512:  * You can obtain one at http://mozilla.org/MPL/2.0/. */
94512: 
97422: #ifndef mozilla_dom_BindingUtils_h__
97422: #define mozilla_dom_BindingUtils_h__
94512: 
97422: #include "mozilla/dom/DOMJSClass.h"
96937: #include "mozilla/dom/workers/Workers.h"
94512: 
94512: #include "jsapi.h"
95834: #include "jsfriendapi.h"
94512: 
94512: #include "XPCQuickStubs.h"
94512: #include "XPCWrapper.h"
94512: #include "nsTraceRefcnt.h"
94512: #include "nsWrapperCacheInlines.h"
94512: 
97422: // nsGlobalWindow implements nsWrapperCache, but doesn't always use it. Don't
97422: // try to use it without fixing that first.
97422: class nsGlobalWindow;
97422: 
94512: namespace mozilla {
94512: namespace dom {
94512: 
94512: template<bool mainThread>
94512: inline bool
94512: Throw(JSContext* cx, nsresult rv)
94512: {
96937:   using mozilla::dom::workers::exceptions::ThrowDOMExceptionForNSResult;
96937: 
94512:   // XXX Introduce exception machinery.
94512:   if (mainThread) {
94512:     XPCThrower::Throw(rv, cx);
94512:   } else {
94512:     if (!JS_IsExceptionPending(cx)) {
96937:       ThrowDOMExceptionForNSResult(cx, rv);
94512:     }
94512:   }
94512:   return false;
94512: }
94512: 
94512: template<bool mainThread>
94512: inline bool
94512: ThrowMethodFailedWithDetails(JSContext* cx, nsresult rv,
94512:                              const char* /* ifaceName */,
94512:                              const char* /* memberName */)
94512: {
94512:   return Throw<mainThread>(cx, rv);
94512: }
94512: 
94512: inline bool
94512: IsDOMClass(const JSClass* clasp)
94512: {
94512:   return clasp->flags & JSCLASS_IS_DOMJSCLASS;
94512: }
94512: 
94512: template <class T>
94512: inline T*
94512: UnwrapDOMObject(JSObject* obj, const JSClass* clasp)
94512: {
94512:   MOZ_ASSERT(IsDOMClass(clasp));
94512:   MOZ_ASSERT(JS_GetClass(obj) == clasp);
94512: 
94512:   size_t slot = DOMJSClass::FromJSClass(clasp)->mNativeSlot;
94512:   MOZ_ASSERT((slot == DOM_OBJECT_SLOT &&
94512:               !(clasp->flags & JSCLASS_DOM_GLOBAL)) ||
94512:              (slot == DOM_GLOBAL_OBJECT_SLOT &&
94512:               (clasp->flags & JSCLASS_DOM_GLOBAL)));
94512: 
94512:   JS::Value val = js::GetReservedSlot(obj, slot);
94512:   // XXXbz/khuey worker code tries to unwrap interface objects (which have
94512:   // nothing here).  That needs to stop.
94512:   // XXX We don't null-check UnwrapObject's result; aren't we going to crash
94512:   // anyway?
94512:   if (val.isUndefined()) {
94512:     return NULL;
94512:   }
94512:   
94512:   return static_cast<T*>(val.toPrivate());
94512: }
94512: 
94512: template <class T>
94512: inline T*
94512: UnwrapDOMObject(JSObject* obj, const js::Class* clasp)
94512: {
94512:   return UnwrapDOMObject<T>(obj, Jsvalify(clasp));
94512: }
94512: 
94512: // Some callers don't want to set an exception when unwrappin fails
94512: // (for example, overload resolution uses unwrapping to tell what sort
94512: // of thing it's looking at).
94512: template <prototypes::ID PrototypeID, class T>
94512: inline nsresult
94512: UnwrapObject(JSContext* cx, JSObject* obj, T** value)
94512: {
94512:   /* First check to see whether we have a DOM object */
94512:   JSClass* clasp = js::GetObjectJSClass(obj);
94512:   if (!IsDOMClass(clasp)) {
94512:     /* Maybe we have a security wrapper or outer window? */
94512:     if (!js::IsWrapper(obj)) {
94512:       /* Not a DOM object, not a wrapper, just bail */
94512:       return NS_ERROR_XPC_BAD_CONVERT_JS;
94512:     }
94512: 
94512:     obj = XPCWrapper::Unwrap(cx, obj, false);
94512:     if (!obj) {
94512:       return NS_ERROR_XPC_SECURITY_MANAGER_VETO;
94512:     }
94512:     MOZ_ASSERT(!js::IsWrapper(obj));
94512:     clasp = js::GetObjectJSClass(obj);
94512:     if (!IsDOMClass(clasp)) {
94512:       /* We don't have a DOM object */
94512:       return NS_ERROR_XPC_BAD_CONVERT_JS;
94512:     }
94512:   }
94512: 
94512:   MOZ_ASSERT(IsDOMClass(clasp));
94512: 
94512:   /* This object is a DOM object.  Double-check that it is safely
94512:      castable to T by checking whether it claims to inherit from the
94512:      class identified by protoID. */
94512:   DOMJSClass* domClass = DOMJSClass::FromJSClass(clasp);
94512:   if (domClass->mInterfaceChain[PrototypeTraits<PrototypeID>::Depth] ==
94512:       PrototypeID) {
94512:     *value = UnwrapDOMObject<T>(obj, clasp);
94512:     return NS_OK;
94512:   }
94512: 
94512:   /* It's the wrong sort of DOM object */
94512:   return NS_ERROR_XPC_BAD_CONVERT_JS;
94512: }
94512: 
94512: inline bool
94512: IsArrayLike(JSContext* cx, JSObject* obj)
94512: {
94512:   MOZ_ASSERT(obj);
94512:   // For simplicity, check for security wrappers up front
94512:   if (js::IsWrapper(obj)) {
94512:     obj = XPCWrapper::Unwrap(cx, obj, false);
94512:     if (!obj) {
94512:       // Let's say it's not
94512:       return false;
94512:     }
94512:   }
94512: 
94512:   // XXXbz need to detect platform objects (including listbinding
94512:   // ones) with indexGetters here!
94512:   return JS_IsArrayObject(cx, obj);
94512: }
94512: 
94512: inline bool
94512: IsPlatformObject(JSContext* cx, JSObject* obj)
94512: {
94512:   // XXXbz Should be treating list-binding objects as platform objects
94512:   // too?  The one consumer so far wants non-array-like platform
94512:   // objects, so listbindings that have an indexGetter should test
94512:   // false from here.  Maybe this function should have a different
94512:   // name?
94512:   MOZ_ASSERT(obj);
94512:   // Fast-path the common case
94512:   JSClass* clasp = js::GetObjectJSClass(obj);
94512:   if (IsDOMClass(clasp)) {
94512:     return true;
94512:   }
94512:   // Now for simplicity check for security wrappers before anything else
94512:   if (js::IsWrapper(obj)) {
94512:     obj = XPCWrapper::Unwrap(cx, obj, false);
94512:     if (!obj) {
94512:       // Let's say it's not
94512:       return false;
94512:     }
94512:     clasp = js::GetObjectJSClass(obj);
94512:   }
94512:   return IS_WRAPPER_CLASS(js::Valueify(clasp)) || IsDOMClass(clasp) ||
95834:     JS_IsArrayBufferObject(obj, cx);
94512: }
94512: 
94512: template <class T>
94512: inline nsresult
94512: UnwrapObject(JSContext* cx, JSObject* obj, T* *value)
94512: {
94512:   return UnwrapObject<static_cast<prototypes::ID>(
94512:            PrototypeIDMap<T>::PrototypeID)>(cx, obj, value);
94512: }
94512: 
94512: const size_t kProtoOrIfaceCacheCount =
94512:   prototypes::id::_ID_Count + constructors::id::_ID_Count;
94512: 
94512: inline void
94512: AllocateProtoOrIfaceCache(JSObject* obj)
94512: {
94512:   MOZ_ASSERT(js::GetObjectClass(obj)->flags & JSCLASS_DOM_GLOBAL);
94512:   MOZ_ASSERT(js::GetReservedSlot(obj, DOM_PROTOTYPE_SLOT).isUndefined());
94512: 
94512:   // Important: The () at the end ensure zero-initialization
94512:   JSObject** protoOrIfaceArray = new JSObject*[kProtoOrIfaceCacheCount]();
94512: 
94512:   js::SetReservedSlot(obj, DOM_PROTOTYPE_SLOT,
94512:                       JS::PrivateValue(protoOrIfaceArray));
94512: }
94512: 
94512: inline void
97506: TraceProtoOrIfaceCache(JSTracer* trc, JSObject* obj)
97506: {
97506:   MOZ_ASSERT(js::GetObjectClass(obj)->flags & JSCLASS_DOM_GLOBAL);
97506: 
97506:   JSObject** protoOrIfaceArray = GetProtoOrIfaceArray(obj);
97506:   for (size_t i = 0; i < kProtoOrIfaceCacheCount; ++i) {
97506:     JSObject* proto = protoOrIfaceArray[i];
97506:     if (proto) {
97506:       JS_CALL_OBJECT_TRACER(trc, proto, "protoOrIfaceArray[i]");
97506:     }
97506:   }
97506: }
97506: 
97506: inline void
94512: DestroyProtoOrIfaceCache(JSObject* obj)
94512: {
94512:   MOZ_ASSERT(js::GetObjectClass(obj)->flags & JSCLASS_DOM_GLOBAL);
94512: 
94512:   JSObject** protoOrIfaceArray = GetProtoOrIfaceArray(obj);
94512: 
94512:   delete [] protoOrIfaceArray;
94512: }
94512: 
94512: struct ConstantSpec
94512: {
94512:   const char* name;
94512:   JS::Value value;
94512: };
94512: 
94512: /*
94512:  * Create a DOM interface object (if constructorClass is non-null) and/or a
94512:  * DOM interface prototype object (if protoClass is non-null).
94512:  *
97127:  * global is used as the parent of the interface object and the interface
97127:  *        prototype object
97127:  * receiver is the object on which we need to define the interface object as a
97127:  *          property
97127:  * protoProto is the prototype to use for the interface prototype object.
94512:  * protoClass is the JSClass to use for the interface prototype object.
94512:  *            This is null if we should not create an interface prototype
94512:  *            object.
94512:  * constructorClass is the JSClass to use for the interface object.
97423:  *                  This is null if we should not create an interface object or
97423:  *                  if it should be a function object.
97423:  * constructor is the JSNative to use as a constructor.  If this is non-null, it
97423:  *             should be used as a JSNative to back the interface object, which
97423:  *             should be a Function.  If this is null, then we should create an
97423:  *             object of constructorClass, unless that's also null, in which
97423:  *             case we should not create an interface object at all.
97423:  * ctorNargs is the length of the constructor function; 0 if no constructor
94512:  * methods and properties are to be defined on the interface prototype object;
94512:  *                        these arguments are allowed to be null if there are no
94512:  *                        methods or properties respectively.
94512:  * constants are to be defined on the interface object and on the interface
94512:  *           prototype object; allowed to be null if there are no constants.
94512:  * staticMethods are to be defined on the interface object; allowed to be null
94512:  *               if there are no static methods.
94512:  *
94512:  * At least one of protoClass and constructorClass should be non-null.
94512:  * If constructorClass is non-null, the resulting interface object will be
94512:  * defined on the given global with property name |name|, which must also be
94512:  * non-null.
94512:  *
94512:  * returns the interface prototype object if protoClass is non-null, else it
94512:  * returns the interface object.
94512:  */
94512: JSObject*
97127: CreateInterfaceObjects(JSContext* cx, JSObject* global, JSObject* receiver,
97127:                        JSObject* protoProto, JSClass* protoClass,
97423:                        JSClass* constructorClass, JSNative constructor,
97423:                        unsigned ctorNargs, JSFunctionSpec* methods,
97127:                        JSPropertySpec* properties, ConstantSpec* constants,
97127:                        JSFunctionSpec* staticMethods, const char* name);
94512: 
94512: template <class T>
94512: inline bool
94512: WrapNewBindingObject(JSContext* cx, JSObject* scope, T* value, JS::Value* vp)
94512: {
94512:   JSObject* obj = value->GetWrapper();
94512:   if (obj && js::GetObjectCompartment(obj) == js::GetObjectCompartment(scope)) {
94512:     *vp = JS::ObjectValue(*obj);
94512:     return true;
94512:   }
94512: 
94512:   if (!obj) {
94512:     bool triedToWrap;
94512:     obj = value->WrapObject(cx, scope, &triedToWrap);
94512:     if (!obj) {
94512:       // At this point, obj is null, so just return false.  We could
94512:       // try to communicate triedToWrap to the caller, but in practice
94512:       // callers seem to be testing JS_IsExceptionPending(cx) to
94512:       // figure out whether WrapObject() threw instead.
94512:       return false;
94512:     }
94512:   }
94512: 
96738:   // When called via XrayWrapper, we end up here while running in the
96738:   // chrome compartment.  But the obj we have would be created in
96738:   // whatever the content compartment is.  So at this point we need to
96738:   // make sure it's correctly wrapped for the compartment of |scope|.
96738:   // cx should already be in the compartment of |scope| here.
96738:   MOZ_ASSERT(js::IsObjectInContextCompartment(scope, cx));
94512:   *vp = JS::ObjectValue(*obj);
94512:   return JS_WrapValue(cx, vp);
94512: }
94512: 
94512: // Helper for smart pointers (nsAutoPtr/nsRefPtr/nsCOMPtr).
94512: template <template <class> class SmartPtr, class T>
94512: inline bool
94512: WrapNewBindingObject(JSContext* cx, JSObject* scope, const SmartPtr<T>& value,
94512:                      JS::Value* vp)
94512: {
94512:   return WrapNewBindingObject(cx, scope, value.get(), vp);
94512: }
94512: 
94512: /**
94512:  * A method to handle new-binding wrap failure, by possibly falling back to
94512:  * wrapping as a non-new-binding object.
94512:  */
94512: bool
94512: DoHandleNewBindingWrappingFailure(JSContext* cx, JSObject* scope,
94512:                                   nsISupports* value, JS::Value* vp);
94512: 
94512: /**
94512:  * An easy way to call the above when you have a value which
94512:  * multiply-inherits from nsISupports.
94512:  */
94512: template <class T>
94512: bool
94512: HandleNewBindingWrappingFailure(JSContext* cx, JSObject* scope, T* value,
94512:                                 JS::Value* vp)
94512: {
94512:   nsCOMPtr<nsISupports> val;
94512:   CallQueryInterface(value, getter_AddRefs(val));
94512:   return DoHandleNewBindingWrappingFailure(cx, scope, val, vp);
94512: }
94512: 
94512: // Helper for smart pointers (nsAutoPtr/nsRefPtr/nsCOMPtr).
94512: template <template <class> class SmartPtr, class T>
94512: MOZ_ALWAYS_INLINE bool
94512: HandleNewBindingWrappingFailure(JSContext* cx, JSObject* scope,
94512:                                 const SmartPtr<T>& value, JS::Value* vp)
94512: {
94512:   return HandleNewBindingWrappingFailure(cx, scope, value.get(), vp);
94512: }
94512: 
94512: struct EnumEntry {
94512:   const char* value;
94512:   size_t length;
94512: };
94512: 
94512: inline int
94512: FindEnumStringIndex(JSContext* cx, JS::Value v, const EnumEntry* values, bool* ok)
94512: {
94512:   // JS_StringEqualsAscii is slow as molasses, so don't use it here.
94512:   JSString* str = JS_ValueToString(cx, v);
94512:   if (!str) {
94512:     *ok = false;
94512:     return 0;
94512:   }
94512:   JS::Anchor<JSString*> anchor(str);
94512:   size_t length;
94512:   const jschar* chars = JS_GetStringCharsAndLength(cx, str, &length);
94512:   if (!chars) {
94512:     *ok = false;
94512:     return 0;
94512:   }
94512:   int i = 0;
94512:   for (const EnumEntry* value = values; value->value; ++value, ++i) {
94512:     if (length != value->length) {
94512:       continue;
94512:     }
94512: 
94512:     bool equal = true;
94512:     const char* val = value->value;
94512:     for (size_t j = 0; j != length; ++j) {
94512:       if (unsigned(val[j]) != unsigned(chars[j])) {
94512:         equal = false;
94512:         break;
94512:       }
94512:     }
94512: 
94512:     if (equal) {
94512:       *ok = true;
94512:       return i;
94512:     }
94512:   }
94512: 
94512:   // XXX we don't know whether we're on the main thread, so play it safe
94512:   *ok = Throw<false>(cx, NS_ERROR_XPC_BAD_CONVERT_JS);
94512:   return 0;
94512: }
94512: 
94512: inline nsWrapperCache*
94512: GetWrapperCache(nsWrapperCache* cache)
94512: {
94512:   return cache;
94512: }
94512: 
94512: inline nsWrapperCache*
94512: GetWrapperCache(nsGlobalWindow* not_allowed);
94512: 
94512: inline nsWrapperCache*
94512: GetWrapperCache(void* p)
94512: {
94512:   return NULL;
94512: }
94512: 
94512: // Only set allowNativeWrapper to false if you really know you need it, if in
94512: // doubt use true. Setting it to false disables security wrappers.
94512: bool
94512: XPCOMObjectToJsval(JSContext* cx, JSObject* scope, xpcObjectHelper &helper,
94512:                    const nsIID* iid, bool allowNativeWrapper, JS::Value* rval);
94512: 
94512: template<class T>
94512: inline bool
94512: WrapObject(JSContext* cx, JSObject* scope, T* p, nsWrapperCache* cache,
94512:            const nsIID* iid, JS::Value* vp)
94512: {
94512:   if (xpc_FastGetCachedWrapper(cache, scope, vp))
94512:     return true;
94512:   qsObjectHelper helper(p, cache);
94512:   return XPCOMObjectToJsval(cx, scope, helper, iid, true, vp);
94512: }
94512: 
94512: template<class T>
94512: inline bool
94512: WrapObject(JSContext* cx, JSObject* scope, T* p, const nsIID* iid,
94512:            JS::Value* vp)
94512: {
94512:   return WrapObject(cx, scope, p, GetWrapperCache(p), iid, vp);
94512: }
94512: 
94512: template<class T>
94512: inline bool
94512: WrapObject(JSContext* cx, JSObject* scope, T* p, JS::Value* vp)
94512: {
94512:   return WrapObject(cx, scope, p, NULL, vp);
94512: }
94512: 
94512: template<class T>
94512: inline bool
94512: WrapObject(JSContext* cx, JSObject* scope, nsCOMPtr<T> &p, const nsIID* iid,
94512:            JS::Value* vp)
94512: {
94512:   return WrapObject(cx, scope, p.get(), iid, vp);
94512: }
94512: 
94512: template<class T>
94512: inline bool
94512: WrapObject(JSContext* cx, JSObject* scope, nsCOMPtr<T> &p, JS::Value* vp)
94512: {
94512:   return WrapObject(cx, scope, p, NULL, vp);
94512: }
94512: 
94512: template<class T>
94512: inline bool
94512: WrapObject(JSContext* cx, JSObject* scope, nsRefPtr<T> &p, const nsIID* iid,
94512:            JS::Value* vp)
94512: {
94512:   return WrapObject(cx, scope, p.get(), iid, vp);
94512: }
94512: 
94512: template<class T>
94512: inline bool
94512: WrapObject(JSContext* cx, JSObject* scope, nsRefPtr<T> &p, JS::Value* vp)
94512: {
94512:   return WrapObject(cx, scope, p, NULL, vp);
94512: }
94512: 
94512: template<>
94512: inline bool
94512: WrapObject<JSObject>(JSContext* cx, JSObject* scope, JSObject* p, JS::Value* vp)
94512: {
94512:   vp->setObjectOrNull(p);
94512:   return true;
94512: }
94512: 
94512: template<class T>
94512: static inline JSObject*
94512: WrapNativeParent(JSContext* cx, JSObject* scope, T* p)
94512: {
94512:   if (!p)
94512:     return scope;
94512: 
94512:   nsWrapperCache* cache = GetWrapperCache(p);
94512:   JSObject* obj;
94512:   if (cache && (obj = cache->GetWrapper())) {
94512: #ifdef DEBUG
94512:     qsObjectHelper helper(p, cache);
94512:     JS::Value debugVal;
94512: 
94512:     bool ok = XPCOMObjectToJsval(cx, scope, helper, NULL, false, &debugVal);
94512:     NS_ASSERTION(ok && JSVAL_TO_OBJECT(debugVal) == obj,
94512:                  "Unexpected object in nsWrapperCache");
94512: #endif
94512:     return obj;
94512:   }
94512: 
94512:   qsObjectHelper helper(p, cache);
94512:   JS::Value v;
94512:   return XPCOMObjectToJsval(cx, scope, helper, NULL, false, &v) ?
94512:          JSVAL_TO_OBJECT(v) :
94512:          NULL;
94512: }
94512: 
94512: // Spec needs a name property
94512: template <typename Spec>
94512: static bool
94512: InitIds(JSContext* cx, Spec* specs, jsid* ids)
94512: {
94512:   Spec* spec = specs;
94512:   do {
94512:     JSString *str = ::JS_InternString(cx, spec->name);
94512:     if (!str) {
94512:       return false;
94512:     }
94512: 
94512:     *ids = INTERNED_STRING_TO_JSID(cx, str);
94512:   } while (++ids, (++spec)->name);
94512: 
94512:   return true;
94512: }
94512: 
94512: JSBool
94512: QueryInterface(JSContext* cx, unsigned argc, JS::Value* vp);
97423: JSBool
97423: ThrowingConstructor(JSContext* cx, unsigned argc, JS::Value* vp);
97423: JSBool
97423: ThrowingConstructorWorkers(JSContext* cx, unsigned argc, JS::Value* vp);
94512: 
94512: } // namespace dom
94512: } // namespace mozilla
94512: 
97422: #endif /* mozilla_dom_BindingUtils_h__ */
