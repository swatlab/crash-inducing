29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
43532:  * vim: set ts=8 sw=4 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS debugging API.
    1:  */
    1: #include <string.h>
62057: #include "jsprvtd.h"
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
55477: #include "jsutil.h"
    1: #include "jsclist.h"
62057: #include "jshashtable.h"
    1: #include "jsapi.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsdbgapi.h"
 8444: #include "jsemit.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jslock.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
 8444: #include "jsparse.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
28997: #include "jsstaticcheck.h"
    1: #include "jsstr.h"
56704: #include "jswrapper.h"
    1: 
30283: #include "jsatominlines.h"
57752: #include "jsdbgapiinlines.h"
53840: #include "jsinterpinlines.h"
40410: #include "jsobjinlines.h"
35453: #include "jsscopeinlines.h"
59968: #include "jsscriptinlines.h"
30283: 
15453: #include "jsautooplen.h"
15453: 
53168: #include "methodjit/MethodJIT.h"
53168: #include "methodjit/Retcon.h"
53168: 
37741: using namespace js;
54707: using namespace js::gc;
37741: 
    1: typedef struct JSTrap {
    1:     JSCList         links;
    1:     JSScript        *script;
    1:     jsbytecode      *pc;
    1:     JSOp            op;
    1:     JSTrapHandler   handler;
41863:     jsval           closure;
    1: } JSTrap;
    1: 
    1: #define DBG_LOCK(rt)            JS_ACQUIRE_LOCK((rt)->debuggerLock)
    1: #define DBG_UNLOCK(rt)          JS_RELEASE_LOCK((rt)->debuggerLock)
    1: #define DBG_LOCK_EVAL(rt,expr)  (DBG_LOCK(rt), (expr), DBG_UNLOCK(rt))
    1: 
53391: JS_PUBLIC_API(JSBool)
53391: JS_GetDebugMode(JSContext *cx)
53391: {
53391:     return cx->compartment->debugMode;
53391: }
53391: 
62057: JS_PUBLIC_API(JSBool)
62057: JS_SetDebugMode(JSContext *cx, JSBool debug)
53391: {
62057:     return JS_SetDebugModeForCompartment(cx, cx->compartment, debug);
53391: }
53391: 
56783: JS_PUBLIC_API(void)
56783: JS_SetRuntimeDebugMode(JSRuntime *rt, JSBool debug)
56783: {
56783:     rt->debugMode = debug;
56783: }
56783: 
62779: #ifdef DEBUG
62779: static bool
62779: CompartmentHasLiveScripts(JSCompartment *comp)
62057: {
62779: #ifdef JS_METHODJIT
62058: # ifdef JS_THREADSAFE
62057:     jsword currentThreadId = reinterpret_cast<jsword>(js_CurrentThreadId());
62058: # endif
62779: #endif
62057: 
62779:     // Unsynchronized context iteration is technically a race; but this is only
62779:     // for debug asserts where such a race would be rare
62779:     JSContext *iter = NULL;
62057:     JSContext *icx;
62779:     while ((icx = JS_ContextIterator(comp->rt, &iter))) {
62058: #ifdef JS_THREADSAFE
62057:         if (JS_GetContextThread(icx) != currentThreadId)
62057:             continue;
62058: #endif
62057:         for (AllFramesIter i(icx); !i.done(); ++i) {
62057:             JSScript *script = i.fp()->maybeScript();
62779:             if (script && script->compartment == comp)
62779:                 return JS_TRUE;
62057:         }
62057:     }
62057: 
62779:     return JS_FALSE;
62779: }
62779: #endif
62779: 
62779: JS_FRIEND_API(JSBool)
62779: JS_SetDebugModeForCompartment(JSContext *cx, JSCompartment *comp, JSBool debug)
62779: {
62779:     // This should only be called when no scripts are live. It would even be
62779:     // incorrect to discard just the non-live scripts' JITScripts because they
62779:     // might share ICs with live scripts (bug 632343).
62779:     JS_ASSERT(!CompartmentHasLiveScripts(comp));
62779: 
62779:     // All scripts compiled from this point on should be in the requested debugMode.
62057:     comp->debugMode = debug;
62057: 
62779:     // Discard JIT code for any scripts that change debugMode. This function
62779:     // assumes that 'comp' is in the same thread as 'cx'.
62779: 
62779: #ifdef JS_METHODJIT
62601:     JSAutoEnterCompartment ac;
62600: 
62057:     for (JSScript *script = (JSScript *)comp->scripts.next;
62057:          &script->links != &comp->scripts;
58693:          script = (JSScript *)script->links.next)
58693:     {
62057:         if (!script->debugMode == !debug)
62057:             continue;
58693: 
62057:         /*
62057:          * If compartment entry fails, debug mode is left partially on, leading
62057:          * to a small performance overhead but no loss of correctness. We set
62057:          * the debug flags to false so that the caller will not later attempt
62057:          * to use debugging features.
62057:          */
62057:         if (!ac.entered() && !ac.enter(cx, script)) {
62057:             comp->debugMode = JS_FALSE;
62057:             return JS_FALSE;
62057:         }
58693: 
62057:         mjit::ReleaseScriptCode(cx, script);
62057:         script->debugMode = !!debug;
60794:     }
58693: #endif
58693: 
61245:     return JS_TRUE;
53391: }
53391: 
59882: JS_FRIEND_API(JSBool)
59882: js_SetSingleStepMode(JSContext *cx, JSScript *script, JSBool singleStep)
59882: {
60170: #ifdef JS_METHODJIT
59882:     if (!script->singleStepMode == !singleStep)
59882:         return JS_TRUE;
60170: #endif
59882: 
59882:     JS_ASSERT_IF(singleStep, cx->compartment->debugMode);
59882: 
59882: #ifdef JS_METHODJIT
59882:     /* request the next recompile to inject single step interrupts */
59882:     script->singleStepMode = !!singleStep;
59882: 
59882:     js::mjit::JITScript *jit = script->jitNormal ? script->jitNormal : script->jitCtor;
59882:     if (jit && script->singleStepMode != jit->singleStepMode) {
59882:         js::mjit::Recompiler recompiler(cx, script);
59882:         if (!recompiler.recompile()) {
59882:             script->singleStepMode = !singleStep;
59882:             return JS_FALSE;
59882:         }
59882:     }
59882: #endif
59882:     return JS_TRUE;
59882: }
59882: 
53391: static JSBool
53391: CheckDebugMode(JSContext *cx)
53391: {
53391:     JSBool debugMode = JS_GetDebugMode(cx);
53391:     /*
53391:      * :TODO:
53391:      * This probably should be an assertion, since it's indicative of a severe
53391:      * API misuse.
53391:      */
53391:     if (!debugMode) {
53391:         JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR, js_GetErrorMessage,
53391:                                      NULL, JSMSG_NEED_DEBUG_MODE);
53391:     }
53391:     return debugMode;
53391: }
53391: 
59882: JS_PUBLIC_API(JSBool)
59882: JS_SetSingleStepMode(JSContext *cx, JSScript *script, JSBool singleStep)
59882: {
59882:     if (!CheckDebugMode(cx))
59882:         return JS_FALSE;
59882: 
59882:     return js_SetSingleStepMode(cx, script, singleStep);
59882: }
59882: 
    1: /*
    1:  * NB: FindTrap must be called with rt->debuggerLock acquired.
    1:  */
    1: static JSTrap *
    1: FindTrap(JSRuntime *rt, JSScript *script, jsbytecode *pc)
    1: {
    1:     JSTrap *trap;
    1: 
    1:     for (trap = (JSTrap *)rt->trapList.next;
18414:          &trap->links != &rt->trapList;
    1:          trap = (JSTrap *)trap->links.next) {
    1:         if (trap->script == script && trap->pc == pc)
    1:             return trap;
    1:     }
    1:     return NULL;
    1: }
    1: 
13496: jsbytecode *
13496: js_UntrapScriptCode(JSContext *cx, JSScript *script)
    1: {
13496:     jsbytecode *code;
13496:     JSRuntime *rt;
    1:     JSTrap *trap;
    1: 
13496:     code = script->code;
13496:     rt = cx->runtime;
13496:     DBG_LOCK(rt);
13496:     for (trap = (JSTrap *)rt->trapList.next;
18414:          &trap->links !=
18414:                 &rt->trapList;
13496:          trap = (JSTrap *)trap->links.next) {
14917:         if (trap->script == script &&
14917:             (size_t)(trap->pc - script->code) < script->length) {
13496:             if (code == script->code) {
14665:                 jssrcnote *sn, *notes;
14665:                 size_t nbytes;
14665: 
14665:                 nbytes = script->length * sizeof(jsbytecode);
32723:                 notes = script->notes();
14665:                 for (sn = notes; !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn))
14665:                     continue;
14665:                 nbytes += (sn - notes + 1) * sizeof *sn;
14665: 
30851:                 code = (jsbytecode *) cx->malloc(nbytes);
13496:                 if (!code)
13496:                     break;
14665:                 memcpy(code, script->code, nbytes);
26569:                 JS_PURGE_GSN_CACHE(cx);
13496:             }
13496:             code[trap->pc - script->code] = trap->op;
13496:         }
13496:     }
13496:     DBG_UNLOCK(rt);
13496:     return code;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetTrap(JSContext *cx, JSScript *script, jsbytecode *pc,
41863:            JSTrapHandler handler, jsval closure)
    1: {
    1:     JSTrap *junk, *trap, *twin;
    1:     JSRuntime *rt;
    1:     uint32 sample;
    1: 
53391:     if (!CheckDebugMode(cx))
53391:         return JS_FALSE;
53391: 
13474:     JS_ASSERT((JSOp) *pc != JSOP_TRAP);
    1:     junk = NULL;
    1:     rt = cx->runtime;
    1:     DBG_LOCK(rt);
    1:     trap = FindTrap(rt, script, pc);
    1:     if (trap) {
    1:         JS_ASSERT(trap->script == script && trap->pc == pc);
    1:         JS_ASSERT(*pc == JSOP_TRAP);
    1:     } else {
    1:         sample = rt->debuggerMutations;
    1:         DBG_UNLOCK(rt);
30851:         trap = (JSTrap *) cx->malloc(sizeof *trap);
14790:         if (!trap)
14790:             return JS_FALSE;
41863:         trap->closure = JSVAL_NULL;
    1:         DBG_LOCK(rt);
    1:         twin = (rt->debuggerMutations != sample)
    1:                ? FindTrap(rt, script, pc)
    1:                : NULL;
    1:         if (twin) {
    1:             junk = trap;
    1:             trap = twin;
    1:         } else {
    1:             JS_APPEND_LINK(&trap->links, &rt->trapList);
    1:             ++rt->debuggerMutations;
    1:             trap->script = script;
    1:             trap->pc = pc;
    1:             trap->op = (JSOp)*pc;
    1:             *pc = JSOP_TRAP;
    1:         }
    1:     }
    1:     trap->handler = handler;
    1:     trap->closure = closure;
    1:     DBG_UNLOCK(rt);
35076:     if (junk)
30851:         cx->free(junk);
53168: 
53168: #ifdef JS_METHODJIT
55503:     if (script->hasJITCode()) {
56773:         js::mjit::Recompiler recompiler(cx, script);
53168:         if (!recompiler.recompile())
53168:             return JS_FALSE;
53168:     }
53168: #endif
53168: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSOp)
    1: JS_GetTrapOpcode(JSContext *cx, JSScript *script, jsbytecode *pc)
    1: {
11813:     JSRuntime *rt;
    1:     JSTrap *trap;
11813:     JSOp op;
    1: 
11813:     rt = cx->runtime;
11813:     DBG_LOCK(rt);
11813:     trap = FindTrap(rt, script, pc);
11813:     op = trap ? trap->op : (JSOp) *pc;
11813:     DBG_UNLOCK(rt);
11813:     return op;
    1: }
    1: 
    1: static void
    1: DestroyTrapAndUnlock(JSContext *cx, JSTrap *trap)
    1: {
    1:     ++cx->runtime->debuggerMutations;
    1:     JS_REMOVE_LINK(&trap->links);
    1:     *trap->pc = (jsbytecode)trap->op;
    1:     DBG_UNLOCK(cx->runtime);
30851:     cx->free(trap);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ClearTrap(JSContext *cx, JSScript *script, jsbytecode *pc,
41863:              JSTrapHandler *handlerp, jsval *closurep)
    1: {
    1:     JSTrap *trap;
    1:     
    1:     DBG_LOCK(cx->runtime);
    1:     trap = FindTrap(cx->runtime, script, pc);
    1:     if (handlerp)
    1:         *handlerp = trap ? trap->handler : NULL;
    1:     if (closurep)
41863:         *closurep = trap ? trap->closure : JSVAL_NULL;
    1:     if (trap)
    1:         DestroyTrapAndUnlock(cx, trap);
    1:     else
    1:         DBG_UNLOCK(cx->runtime);
53168: 
53168: #ifdef JS_METHODJIT
55503:     if (script->hasJITCode()) {
53168:         mjit::Recompiler recompiler(cx, script);
53168:         recompiler.recompile();
53168:     }
53168: #endif
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ClearScriptTraps(JSContext *cx, JSScript *script)
    1: {
    1:     JSRuntime *rt;
    1:     JSTrap *trap, *next;
    1:     uint32 sample;
    1: 
    1:     rt = cx->runtime;
    1:     DBG_LOCK(rt);
    1:     for (trap = (JSTrap *)rt->trapList.next;
18414:          &trap->links != &rt->trapList;
    1:          trap = next) {
    1:         next = (JSTrap *)trap->links.next;
    1:         if (trap->script == script) {
    1:             sample = rt->debuggerMutations;
    1:             DestroyTrapAndUnlock(cx, trap);
    1:             DBG_LOCK(rt);
    1:             if (rt->debuggerMutations != sample + 1)
    1:                 next = (JSTrap *)rt->trapList.next;
    1:         }
    1:     }
    1:     DBG_UNLOCK(rt);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ClearAllTraps(JSContext *cx)
    1: {
    1:     JSRuntime *rt;
    1:     JSTrap *trap, *next;
    1:     uint32 sample;
    1: 
    1:     rt = cx->runtime;
    1:     DBG_LOCK(rt);
    1:     for (trap = (JSTrap *)rt->trapList.next;
18414:          &trap->links != &rt->trapList;
    1:          trap = next) {
    1:         next = (JSTrap *)trap->links.next;
    1:         sample = rt->debuggerMutations;
    1:         DestroyTrapAndUnlock(cx, trap);
    1:         DBG_LOCK(rt);
    1:         if (rt->debuggerMutations != sample + 1)
    1:             next = (JSTrap *)rt->trapList.next;
    1:     }
    1:     DBG_UNLOCK(rt);
    1: }
    1: 
35076: /*
35076:  * NB: js_MarkTraps does not acquire cx->runtime->debuggerLock, since the
35076:  * debugger should never be racing with the GC (i.e., the debugger must
35076:  * respect the request model).
35076:  */
35076: void
35076: js_MarkTraps(JSTracer *trc)
35076: {
35076:     JSRuntime *rt = trc->context->runtime;
35076: 
35076:     for (JSTrap *trap = (JSTrap *) rt->trapList.next;
35076:          &trap->links != &rt->trapList;
35076:          trap = (JSTrap *) trap->links.next) {
48470:         MarkValue(trc, Valueify(trap->closure), "trap->closure");
35076:     }
35076: }
35076: 
    1: JS_PUBLIC_API(JSTrapStatus)
    1: JS_HandleTrap(JSContext *cx, JSScript *script, jsbytecode *pc, jsval *rval)
    1: {
    1:     JSTrap *trap;
    1:     jsint op;
    1:     JSTrapStatus status;
    1: 
    1:     DBG_LOCK(cx->runtime);
    1:     trap = FindTrap(cx->runtime, script, pc);
    1:     JS_ASSERT(!trap || trap->handler);
    1:     if (!trap) {
    1:         op = (JSOp) *pc;
    1:         DBG_UNLOCK(cx->runtime);
    1: 
    1:         /* Defend against "pc for wrong script" API usage error. */
    1:         JS_ASSERT(op != JSOP_TRAP);
    1: 
    1: #ifdef JS_THREADSAFE
    1:         /* If the API was abused, we must fail for want of the real op. */
    1:         if (op == JSOP_TRAP)
    1:             return JSTRAP_ERROR;
    1: 
    1:         /* Assume a race with a debugger thread and try to carry on. */
    1:         *rval = INT_TO_JSVAL(op);
    1:         return JSTRAP_CONTINUE;
    1: #else
    1:         /* Always fail if single-threaded (must be an API usage error). */
    1:         return JSTRAP_ERROR;
    1: #endif
    1:     }
    1:     DBG_UNLOCK(cx->runtime);
    1: 
    1:     /*
    1:      * It's important that we not use 'trap->' after calling the callback --
    1:      * the callback might remove the trap!
    1:      */
    1:     op = (jsint)trap->op;
    1:     status = trap->handler(cx, script, pc, rval, trap->closure);
    1:     if (status == JSTRAP_CONTINUE) {
    1:         /* By convention, return the true op to the interpreter in rval. */
    1:         *rval = INT_TO_JSVAL(op);
    1:     }
    1:     return status;
    1: }
    1: 
35331: #ifdef JS_TRACER
35331: static void
35331: JITInhibitingHookChange(JSRuntime *rt, bool wasInhibited)
35331: {
35331:     if (wasInhibited) {
35331:         if (!rt->debuggerInhibitsJIT()) {
35331:             for (JSCList *cl = rt->contextList.next; cl != &rt->contextList; cl = cl->next)
35331:                 js_ContextFromLinkField(cl)->updateJITEnabled();
35331:         }
35331:     } else if (rt->debuggerInhibitsJIT()) {
35331:         for (JSCList *cl = rt->contextList.next; cl != &rt->contextList; cl = cl->next)
54175:             js_ContextFromLinkField(cl)->traceJitEnabled = false;
35331:     }
35331: }
35331: #endif
35331: 
    1: JS_PUBLIC_API(JSBool)
41863: JS_SetInterrupt(JSRuntime *rt, JSInterruptHook hook, void *closure)
    1: {
35331: #ifdef JS_TRACER
40840:     {
40840:         AutoLockGC lock(rt);
35331:         bool wasInhibited = rt->debuggerInhibitsJIT();
35331: #endif
41863:         rt->globalDebugHooks.interruptHook = hook;
41863:         rt->globalDebugHooks.interruptHookData = closure;
35331: #ifdef JS_TRACER
35331:         JITInhibitingHookChange(rt, wasInhibited);
40840:     }
35331: #endif
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
41863: JS_ClearInterrupt(JSRuntime *rt, JSInterruptHook *hoop, void **closurep)
    1: {
35331: #ifdef JS_TRACER
40840:     AutoLockGC lock(rt);
35331:     bool wasInhibited = rt->debuggerInhibitsJIT();
35331: #endif
41863:     if (hoop)
41863:         *hoop = rt->globalDebugHooks.interruptHook;
    1:     if (closurep)
41863:         *closurep = rt->globalDebugHooks.interruptHookData;
41863:     rt->globalDebugHooks.interruptHook = 0;
41863:     rt->globalDebugHooks.interruptHookData = 0;
35331: #ifdef JS_TRACER
35331:     JITInhibitingHookChange(rt, wasInhibited);
35331: #endif
    1:     return JS_TRUE;
    1: }
    1: 
    1: /************************************************************************/
    1: 
57751: struct JSWatchPoint {
    1:     JSCList             links;
62588:     JSObject            *object;        /* weak link, see js_SweepWatchPoints */
52503:     const Shape         *shape;
62395:     StrictPropertyOp    setter;
    1:     JSWatchPointHandler handler;
32694:     JSObject            *closure;
    1:     uintN               flags;
57751: };
    1: 
    1: #define JSWP_LIVE       0x1             /* live because set and not cleared */
    1: #define JSWP_HELD       0x2             /* held while running handler/setter */
    1: 
    1: /*
    1:  * NB: DropWatchPointAndUnlock releases cx->runtime->debuggerLock in all cases.
    1:  */
    1: static JSBool
    1: DropWatchPointAndUnlock(JSContext *cx, JSWatchPoint *wp, uintN flag)
    1: {
52503:     bool ok = true;
52503:     JSRuntime *rt = cx->runtime;
    1: 
    1:     wp->flags &= ~flag;
    1:     if (wp->flags != 0) {
52503:         DBG_UNLOCK(rt);
    1:         return ok;
    1:     }
    1: 
62077:     /*
62077:      * Switch to the same compartment as the watch point, since changeProperty, below,
62077:      * needs to have a compartment.
62077:      */
62077:     SwitchToCompartment sc(cx, wp->object);
62077: 
57752:     /* Remove wp from the list, then restore wp->shape->setter from wp. */
52503:     ++rt->debuggerMutations;
    1:     JS_REMOVE_LINK(&wp->links);
52503:     DBG_UNLOCK(rt);
52503: 
    1:     /*
57752:      * If the property isn't found on wp->object, then someone else must have deleted it,
57752:      * and we don't need to change the property attributes.
    1:      */
57752:     const Shape *shape = wp->shape;
52503:     const Shape *wprop = wp->object->nativeLookup(shape->id);
35453:     if (wprop &&
52503:         wprop->hasSetterValue() == shape->hasSetterValue() &&
57751:         IsWatchedProperty(cx, wprop)) {
52503:         shape = wp->object->changeProperty(cx, wprop, 0, wprop->attributes(),
39894:                                            wprop->getter(), wp->setter);
52503:         if (!shape)
52503:             ok = false;
    1:     }
    1: 
30851:     cx->free(wp);
    1:     return ok;
    1: }
    1: 
    1: /*
  583:  * NB: js_TraceWatchPoints does not acquire cx->runtime->debuggerLock, since
    1:  * the debugger should never be racing with the GC (i.e., the debugger must
    1:  * respect the request model).
    1:  */
    1: void
 5816: js_TraceWatchPoints(JSTracer *trc, JSObject *obj)
    1: {
    1:     JSRuntime *rt;
    1:     JSWatchPoint *wp;
    1: 
  583:     rt = trc->context->runtime;
  583: 
    1:     for (wp = (JSWatchPoint *)rt->watchPointList.next;
18414:          &wp->links != &rt->watchPointList;
    1:          wp = (JSWatchPoint *)wp->links.next) {
 5816:         if (wp->object == obj) {
52503:             wp->shape->trace(trc);
52503:             if (wp->shape->hasSetterValue() && wp->setter)
54707:                 MarkObject(trc, *CastAsObject(wp->setter), "wp->setter");
54707:             MarkObject(trc, *wp->closure, "wp->closure");
    1:         }
 5816:     }
 5816: }
 5816: 
 5816: void
 5816: js_SweepWatchPoints(JSContext *cx)
 5816: {
 5816:     JSRuntime *rt;
 5816:     JSWatchPoint *wp, *next;
 5816:     uint32 sample;
 5816: 
 5816:     rt = cx->runtime;
 5816:     DBG_LOCK(rt);
 5816:     for (wp = (JSWatchPoint *)rt->watchPointList.next;
18414:          &wp->links != &rt->watchPointList;
 5816:          wp = next) {
 5816:         next = (JSWatchPoint *)wp->links.next;
60258:         if (IsAboutToBeFinalized(cx, wp->object)) {
 5816:             sample = rt->debuggerMutations;
 5816: 
 5816:             /* Ignore failures. */
 5816:             DropWatchPointAndUnlock(cx, wp, JSWP_LIVE);
 5816:             DBG_LOCK(rt);
 5816:             if (rt->debuggerMutations != sample + 1)
 5816:                 next = (JSWatchPoint *)rt->watchPointList.next;
 5816:         }
 5816:     }
 5816:     DBG_UNLOCK(rt);
 5816: }
 5816: 
 5816: 
    1: 
    1: /*
57752:  * NB: LockedFindWatchPoint must be called with rt->debuggerLock acquired.
    1:  */
    1: static JSWatchPoint *
57752: LockedFindWatchPoint(JSRuntime *rt, JSObject *obj, jsid id)
    1: {
    1:     JSWatchPoint *wp;
    1: 
    1:     for (wp = (JSWatchPoint *)rt->watchPointList.next;
18414:          &wp->links != &rt->watchPointList;
    1:          wp = (JSWatchPoint *)wp->links.next) {
52503:         if (wp->object == obj && wp->shape->id == id)
    1:             return wp;
    1:     }
    1:     return NULL;
    1: }
    1: 
57752: static JSWatchPoint *
57752: FindWatchPoint(JSRuntime *rt, JSObject *obj, jsid id)
    1: {
    1:     JSWatchPoint *wp;
    1: 
    1:     DBG_LOCK(rt);
57752:     wp = LockedFindWatchPoint(rt, obj, id);
    1:     DBG_UNLOCK(rt);
57752:     return wp;
    1: }
    1: 
18907: JSBool
62395: js_watch_set(JSContext *cx, JSObject *obj, jsid id, JSBool strict, Value *vp)
    1: {
42714:     JSRuntime *rt = cx->runtime;
    1:     DBG_LOCK(rt);
42714:     for (JSWatchPoint *wp = (JSWatchPoint *)rt->watchPointList.next;
18414:          &wp->links != &rt->watchPointList;
    1:          wp = (JSWatchPoint *)wp->links.next) {
52503:         const Shape *shape = wp->shape;
62588:         if (wp->object == obj && SHAPE_USERID(shape) == id && !(wp->flags & JSWP_HELD)) {
    1:             wp->flags |= JSWP_HELD;
    1:             DBG_UNLOCK(rt);
    1: 
52503:             jsid propid = shape->id;
62588:             shape = obj->nativeLookup(propid);
62588:             JS_ASSERT(IsWatchedProperty(cx, shape));
52503:             jsid userid = SHAPE_USERID(shape);
    1: 
62588:             /* Determine the property's old value. */
62588:             bool ok;
62588:             uint32 slot = shape->slot;
62588:             Value old = obj->containsSlot(slot) ? obj->nativeGetSlot(slot) : UndefinedValue();
62588:             const Shape *needMethodSlotWrite = NULL;
62588:             if (shape->isMethod()) {
62588:                 /*
62588:                  * We get here in two cases: (1) the existing watched property
62588:                  * is a method; or (2) the watched property was deleted and is
62588:                  * now in the middle of being re-added via JSOP_SETMETHOD. In
62588:                  * both cases we must trip the method read barrier in order to
62588:                  * avoid passing an uncloned function object to the handler.
62588:                  *
62588:                  * Case 2 is especially hairy. js_watch_set, uniquely, gets
62588:                  * called in the middle of creating a method property, after
62588:                  * shape is in obj but before the slot has been set. So in this
62588:                  * case we must finish initializing the half-finished method
62588:                  * property before triggering the method read barrier.
62588:                  *
62588:                  * Bonus weirdness: because this changes obj's shape,
62588:                  * js_NativeSet (which is our caller) will not write to the
62588:                  * slot, as it will appear the property was deleted and a new
62588:                  * property added. We must write the slot ourselves -- however
62588:                  * we must do it after calling the watchpoint handler. So set
62588:                  * needMethodSlotWrite here and use it to write to the slot
62588:                  * below, if the handler does not tinker with the property
62588:                  * further.
62588:                  */
62588:                 JS_ASSERT(!wp->setter);
62588:                 Value method = ObjectValue(shape->methodObject());
62588:                 if (old.isUndefined())
62588:                     obj->nativeSetSlot(slot, method);
62588:                 ok = obj->methodReadBarrier(cx, *shape, &method);
62588:                 if (!ok)
62588:                     goto out;
62588:                 wp->shape = shape = needMethodSlotWrite = obj->nativeLookup(propid);
62588:                 JS_ASSERT(shape->isDataDescriptor());
62588:                 JS_ASSERT(!shape->isMethod());
62588:                 if (old.isUndefined())
62588:                     obj->nativeSetSlot(shape->slot, old);
62588:                 else
62588:                     old = method;
42714:             }
42714: 
62588:             {
62588:                 Conditionally<AutoShapeRooter> tvr(needMethodSlotWrite, cx, needMethodSlotWrite);
60525: 
    1:                 /*
62588:                  * Call the handler. This invalidates shape, so re-lookup the shape.
62588:                  * NB: wp is held, so we can safely dereference it still.
62588:                  */
62588:                 ok = wp->handler(cx, obj, propid, Jsvalify(old), Jsvalify(vp), wp->closure);
62588:                 if (!ok)
62588:                     goto out;
62588:                 shape = obj->nativeLookup(propid);
62588:                 JS_ASSERT_IF(!shape, !wp->setter);
62588: 
62588:                 if (!shape) {
62588:                     ok = true;
62588:                 } else if (wp->setter) {
62588:                     /*
51134:                      * Pass the output of the handler to the setter. Security wrappers
51134:                      * prevent any funny business between watchpoints and setters.
    1:                      */
62588:                     ok = shape->hasSetterValue()
61734:                          ? ExternalInvoke(cx, ObjectValue(*obj),
48470:                                           ObjectValue(*CastAsObject(wp->setter)),
    1:                                           1, vp, vp)
62588:                          : CallJSPropertyOpSetter(cx, wp->setter, obj, userid, strict, vp);
62588:                 } else if (shape == needMethodSlotWrite) {
62588:                     /* See comment above about needMethodSlotWrite. */
62588:                     obj->nativeSetSlot(shape->slot, *vp);
62588:                     ok = true;
62588:                 } else {
62588:                     /*
62588:                      * A property with the default setter might be either a method
62588:                      * or an ordinary function-valued data property subject to the
62588:                      * method write barrier.
62588:                      *
62588:                      * It is not the setter's job to call methodWriteBarrier,
62588:                      * but js_watch_set must do so, because the caller will be
62588:                      * fooled into not doing it: shape does *not* have the
62588:                      * default setter and therefore seems not to be a method.
62588:                      */
62588:                     ok = obj->methodWriteBarrier(cx, *shape, *vp) != NULL;
62588:                 }
62588:             }
42714: 
62588:         out:
    1:             DBG_LOCK(rt);
    1:             return DropWatchPointAndUnlock(cx, wp, JSWP_HELD) && ok;
    1:         }
    1:     }
    1:     DBG_UNLOCK(rt);
62588:     return true;
    1: }
    1: 
57752: static JSBool
53557: js_watch_set_wrapper(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
53557:     if (!obj)
53557:         return false;
    1: 
53557:     JSObject &funobj = JS_CALLEE(cx, vp).toObject();
53557:     JSFunction *wrapper = funobj.getFunctionPrivate();
53557:     jsid userid = ATOM_TO_JSID(wrapper->atom);
53557: 
53557:     JS_SET_RVAL(cx, vp, argc ? JS_ARGV(cx, vp)[0] : UndefinedValue());
62395:     /*
62395:      * The strictness we pass here doesn't matter, since we know that it's
62395:      * a JS setter, which can't depend on the assigning code's strictness.
62395:      */
62395:     return js_watch_set(cx, obj, userid, false, vp);
    1: }
    1: 
62382: namespace js {
62382: 
62382: bool
57751: IsWatchedProperty(JSContext *cx, const Shape *shape)
35453: {
57751:     if (shape->hasSetterValue()) {
57751:         JSObject *funobj = shape->setterObject();
41860:         if (!funobj || !funobj->isFunction())
39904:             return false;
39904: 
62382:         JSFunction *fun = funobj->getFunctionPrivate();
53557:         return fun->maybeNative() == js_watch_set_wrapper;
35453:     }
57751:     return shape->setterOp() == js_watch_set;
35453: }
35453: 
62382: }
62382: 
57751: /*
57751:  * Return an appropriate setter to substitute for |setter| on a property
57751:  * with attributes |attrs|, to implement a watchpoint on the property named
57751:  * |id|.
57751:  */
62395: static StrictPropertyOp
62395: WrapWatchedSetter(JSContext *cx, jsid id, uintN attrs, StrictPropertyOp setter)
    1: {
    1:     JSAtom *atom;
    1:     JSFunction *wrapper;
    1: 
62395:     /* Wrap a C++ setter simply by returning our own C++ setter. */
    1:     if (!(attrs & JSPROP_SETTER))
    1:         return &js_watch_set;   /* & to silence schoolmarmish MSVC */
    1: 
57751:     /*
57751:      * Wrap a JSObject * setter by constructing our own JSFunction * that saves the
57751:      * property id as the function name, and calls js_watch_set.
57751:      */
    1:     if (JSID_IS_ATOM(id)) {
    1:         atom = JSID_TO_ATOM(id);
    1:     } else if (JSID_IS_INT(id)) {
48470:         if (!js_ValueToStringId(cx, IdToValue(id), &id))
    1:             return NULL;
10573:         atom = JSID_TO_ATOM(id);
    1:     } else {
    1:         atom = NULL;
    1:     }
41120: 
    1:     wrapper = js_NewFunction(cx, NULL, js_watch_set_wrapper, 1, 0,
41860:                              setter ? CastAsObject(setter)->getParent() : NULL, atom);
    1:     if (!wrapper)
    1:         return NULL;
62395:     return CastAsStrictPropertyOp(FUN_OBJECT(wrapper));
    1: }
    1: 
62586: static const Shape *
62586: UpdateWatchpointShape(JSContext *cx, JSWatchPoint *wp, const Shape *newShape)
57752: {
57752:     JS_ASSERT_IF(wp->shape, wp->shape->id == newShape->id);
57752:     JS_ASSERT(!IsWatchedProperty(cx, newShape));
57752: 
57752:     /* Create a watching setter we can substitute for the new shape's setter. */
62586:     StrictPropertyOp watchingSetter =
62395:         WrapWatchedSetter(cx, newShape->id, newShape->attributes(), newShape->setter());
57752:     if (!watchingSetter)
62586:         return NULL;
57752: 
57752:     /*
57752:      * Save the shape's setter; we don't know whether js_ChangeNativePropertyAttrs will
57752:      * return a new shape, or mutate this one.
57752:      */
62586:     StrictPropertyOp originalSetter = newShape->setter();
57752: 
57752:     /*
57752:      * Drop the watching setter into the object, in place of newShape. Note that a single
57752:      * watchpoint-wrapped shape may correspond to more than one non-watchpoint shape: we
57752:      * wrap all (JSPropertyOp, not JSObject *) setters with js_watch_set, so shapes that
57752:      * differ only in their setter may all get wrapped to the same shape.
57752:      */
62586:     const Shape *watchingShape = 
57752:         js_ChangeNativePropertyAttrs(cx, wp->object, newShape, 0, newShape->attributes(),
57752:                                      newShape->getter(), watchingSetter);
57752:     if (!watchingShape)
62586:         return NULL;
57752: 
57752:     /* Update the watchpoint with the new shape and its original setter. */
57752:     wp->setter = originalSetter;
57752:     wp->shape = watchingShape;
57752: 
62586:     return watchingShape;
57752: }
57752: 
62586: const Shape *
62586: js_SlowPathUpdateWatchpointsForShape(JSContext *cx, JSObject *obj, const Shape *newShape)
57752: {
57752:     /*
57752:      * The watchpoint code uses the normal property-modification functions to install its
57752:      * own watchpoint-aware shapes. Those functions report those changes back to the
57752:      * watchpoint code, just as they do user-level changes. So if this change is
57752:      * installing a watchpoint-aware shape, it's something we asked for ourselves, and can
57752:      * proceed without interference.
57752:      */
57752:     if (IsWatchedProperty(cx, newShape))
62586:         return newShape;
57752: 
57752:     JSWatchPoint *wp = FindWatchPoint(cx->runtime, obj, newShape->id);
57752:     if (!wp)
62586:         return newShape;
57752: 
57752:     return UpdateWatchpointShape(cx, wp, newShape);
57752: }
57752: 
57752: /*
57752:  * Return the underlying setter for |shape| on |obj|, seeing through any
57752:  * watchpoint-wrapping. Note that we need |obj| to disambiguate, since a single
57752:  * watchpoint-wrapped shape may correspond to more than one non-watchpoint shape; see the
57752:  * comments in UpdateWatchpointShape.
57752:  */
62395: static StrictPropertyOp
57752: UnwrapSetter(JSContext *cx, JSObject *obj, const Shape *shape)
57752: {
57752:     /* If it's not a watched property, its setter is not wrapped. */
57752:     if (!IsWatchedProperty(cx, shape))
57752:         return shape->setter();
57752: 
57752:     /* Look up the watchpoint, from which we can retrieve the underlying setter. */
57752:     JSWatchPoint *wp = FindWatchPoint(cx->runtime, obj, shape->id);
57752: 
57752:     /* 
57752:      * Since we know |shape| is watched, we *must* find a watchpoint: we should never
57752:      * leave wrapped setters lying around in shapes after removing a watchpoint.
57752:      */
57752:     JS_ASSERT(wp);
57752: 
57752:     return wp->setter;
57752: }
57752: 
    1: JS_PUBLIC_API(JSBool)
48470: JS_SetWatchPoint(JSContext *cx, JSObject *obj, jsid id,
51134:                  JSWatchPointHandler handler, JSObject *closure)
    1: {
35046:     JSObject *origobj;
48470:     Value v;
35046:     uintN attrs;
    1:     jsid propid;
    1: 
35046:     origobj = obj;
35046:     OBJ_TO_INNER_OBJECT(cx, obj);
35046:     if (!obj)
    1:         return JS_FALSE;
    1: 
43203:     AutoValueRooter idroot(cx);
48470:     if (JSID_IS_INT(id)) {
48470:         propid = id;
24284:     } else {
48470:         if (!js_ValueToStringId(cx, IdToValue(id), &propid))
    1:             return JS_FALSE;
30270:         propid = js_CheckForStringIndex(propid);
48470:         idroot.set(IdToValue(propid));
24284:     }
    1: 
35046:     /*
35046:      * If, by unwrapping and innerizing, we changed the object, check
35046:      * again to make sure that we're allowed to set a watch point.
35046:      */
47455:     if (origobj != obj && !CheckAccess(cx, obj, propid, JSACC_WATCH, &v, &attrs))
35046:         return JS_FALSE;
35046: 
40430:     if (!obj->isNative()) {
35046:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_WATCH,
40826:                              obj->getClass()->name);
35046:         return JS_FALSE;
35046:     }
35046: 
57752:     JSObject *pobj;
57751:     JSProperty *prop;
    1:     if (!js_LookupProperty(cx, obj, propid, &pobj, &prop))
    1:         return JS_FALSE;
57751:     const Shape *shape = (Shape *) prop;
57751:     JSRuntime *rt = cx->runtime;
52503:     if (!shape) {
    1:         /* Check for a deleted symbol watchpoint, which holds its property. */
57752:         JSWatchPoint *wp = FindWatchPoint(rt, obj, propid);
57752:         if (!wp) {
    1:             /* Make a new property in obj so we can watch for the first set. */
48470:             if (!js_DefineNativeProperty(cx, obj, propid, UndefinedValue(), NULL, NULL,
32573:                                          JSPROP_ENUMERATE, 0, 0, &prop)) {
    1:                 return JS_FALSE;
    1:             }
52503:             shape = (Shape *) prop;
    1:         }
    1:     } else if (pobj != obj) {
    1:         /* Clone the prototype property so we can watch the right object. */
43203:         AutoValueRooter valroot(cx);
62395:         PropertyOp getter;
62395:         StrictPropertyOp setter;
    1:         uintN attrs, flags;
    1:         intN shortid;
    1: 
40430:         if (pobj->isNative()) {
52503:             valroot.set(pobj->containsSlot(shape->slot)
56567:                         ? pobj->nativeGetSlot(shape->slot)
48470:                         : UndefinedValue());
52503:             getter = shape->getter();
57752:             setter = UnwrapSetter(cx, pobj, shape);
52503:             attrs = shape->attributes();
52503:             flags = shape->getFlags();
52503:             shortid = shape->shortid;
    1:         } else {
43203:             if (!pobj->getProperty(cx, propid, valroot.addr()) ||
43290:                 !pobj->getAttributes(cx, propid, &attrs)) {
    1:                 return JS_FALSE;
    1:             }
62395:             getter = NULL;
62395:             setter = NULL;
    1:             flags = 0;
    1:             shortid = 0;
    1:         }
    1: 
    1:         /* Recall that obj is native, whether or not pobj is native. */
43203:         if (!js_DefineNativeProperty(cx, obj, propid, valroot.value(),
43203:                                      getter, setter, attrs, flags,
43203:                                      shortid, &prop)) {
    1:             return JS_FALSE;
    1:         }
52503:         shape = (Shape *) prop;
    1:     }
    1: 
    1:     /*
52503:      * At this point, prop/shape exists in obj, obj is locked, and we must
43290:      * unlock the object before returning.
    1:      */
    1:     DBG_LOCK(rt);
57752:     JSWatchPoint *wp = LockedFindWatchPoint(rt, obj, propid);
    1:     if (!wp) {
    1:         DBG_UNLOCK(rt);
30851:         wp = (JSWatchPoint *) cx->malloc(sizeof *wp);
56567:         if (!wp)
56567:             return JS_FALSE;
    1:         wp->handler = NULL;
    1:         wp->closure = NULL;
    1:         wp->object = obj;
57752:         wp->shape = NULL;
    1:         wp->flags = JSWP_LIVE;
    1: 
    1:         /* XXXbe nest in obj lock here */
57752:         if (!UpdateWatchpointShape(cx, wp, shape)) {
    1:             /* Self-link so DropWatchPointAndUnlock can JS_REMOVE_LINK it. */
    1:             JS_INIT_CLIST(&wp->links);
    1:             DBG_LOCK(rt);
    1:             DropWatchPointAndUnlock(cx, wp, JSWP_LIVE);
56567:             return JS_FALSE;
    1:         }
    1: 
    1:         /*
    1:          * Now that wp is fully initialized, append it to rt's wp list.
    1:          * Because obj is locked we know that no other thread could have added
    1:          * a watchpoint for (obj, propid).
    1:          */
    1:         DBG_LOCK(rt);
57752:         JS_ASSERT(!LockedFindWatchPoint(rt, obj, propid));
    1:         JS_APPEND_LINK(&wp->links, &rt->watchPointList);
    1:         ++rt->debuggerMutations;
    1:     }
62587: 
62587:     /*
62587:      * Ensure that an object with watchpoints never has the same shape as an
62587:      * object without them, even if the watched properties are deleted.
62587:      */
62587:     obj->watchpointOwnShapeChange(cx);
62587: 
    1:     wp->handler = handler;
32694:     wp->closure = reinterpret_cast<JSObject*>(closure);
    1:     DBG_UNLOCK(rt);
56567:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
48470: JS_ClearWatchPoint(JSContext *cx, JSObject *obj, jsid id,
51134:                    JSWatchPointHandler *handlerp, JSObject **closurep)
    1: {
    1:     JSRuntime *rt;
    1:     JSWatchPoint *wp;
    1: 
    1:     rt = cx->runtime;
    1:     DBG_LOCK(rt);
    1:     for (wp = (JSWatchPoint *)rt->watchPointList.next;
18414:          &wp->links != &rt->watchPointList;
    1:          wp = (JSWatchPoint *)wp->links.next) {
52503:         if (wp->object == obj && SHAPE_USERID(wp->shape) == id) {
    1:             if (handlerp)
    1:                 *handlerp = wp->handler;
    1:             if (closurep)
    1:                 *closurep = wp->closure;
    1:             return DropWatchPointAndUnlock(cx, wp, JSWP_LIVE);
    1:         }
    1:     }
    1:     DBG_UNLOCK(rt);
    1:     if (handlerp)
    1:         *handlerp = NULL;
    1:     if (closurep)
    1:         *closurep = NULL;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ClearWatchPointsForObject(JSContext *cx, JSObject *obj)
    1: {
    1:     JSRuntime *rt;
    1:     JSWatchPoint *wp, *next;
    1:     uint32 sample;
    1: 
    1:     rt = cx->runtime;
    1:     DBG_LOCK(rt);
    1:     for (wp = (JSWatchPoint *)rt->watchPointList.next;
18414:          &wp->links != &rt->watchPointList;
    1:          wp = next) {
    1:         next = (JSWatchPoint *)wp->links.next;
    1:         if (wp->object == obj) {
    1:             sample = rt->debuggerMutations;
    1:             if (!DropWatchPointAndUnlock(cx, wp, JSWP_LIVE))
    1:                 return JS_FALSE;
    1:             DBG_LOCK(rt);
    1:             if (rt->debuggerMutations != sample + 1)
    1:                 next = (JSWatchPoint *)rt->watchPointList.next;
    1:         }
    1:     }
    1:     DBG_UNLOCK(rt);
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ClearAllWatchPoints(JSContext *cx)
    1: {
    1:     JSRuntime *rt;
    1:     JSWatchPoint *wp, *next;
    1:     uint32 sample;
    1: 
    1:     rt = cx->runtime;
    1:     DBG_LOCK(rt);
    1:     for (wp = (JSWatchPoint *)rt->watchPointList.next;
18414:          &wp->links != &rt->watchPointList;
    1:          wp = next) {
    1:         next = (JSWatchPoint *)wp->links.next;
    1:         sample = rt->debuggerMutations;
    1:         if (!DropWatchPointAndUnlock(cx, wp, JSWP_LIVE))
    1:             return JS_FALSE;
    1:         DBG_LOCK(rt);
    1:         if (rt->debuggerMutations != sample + 1)
    1:             next = (JSWatchPoint *)rt->watchPointList.next;
    1:     }
    1:     DBG_UNLOCK(rt);
    1:     return JS_TRUE;
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: JS_PUBLIC_API(uintN)
    1: JS_PCToLineNumber(JSContext *cx, JSScript *script, jsbytecode *pc)
    1: {
    1:     return js_PCToLineNumber(cx, script, pc);
    1: }
    1: 
    1: JS_PUBLIC_API(jsbytecode *)
    1: JS_LineNumberToPC(JSContext *cx, JSScript *script, uintN lineno)
    1: {
    1:     return js_LineNumberToPC(script, lineno);
    1: }
    1: 
55561: JS_PUBLIC_API(jsbytecode *)
55561: JS_EndPC(JSContext *cx, JSScript *script)
55561: {
55561:     return script->code + script->length;
55561: }
55561: 
48470: JS_PUBLIC_API(uintN)
48470: JS_GetFunctionArgumentCount(JSContext *cx, JSFunction *fun)
48470: {
48470:     return fun->nargs;
48470: }
48470: 
48470: JS_PUBLIC_API(JSBool)
48470: JS_FunctionHasLocalNames(JSContext *cx, JSFunction *fun)
48470: {
59968:     return fun->script()->bindings.hasLocalNames();
48470: }
48470: 
48470: extern JS_PUBLIC_API(jsuword *)
48470: JS_GetFunctionLocalNameArray(JSContext *cx, JSFunction *fun, void **markp)
48470: {
48470:     *markp = JS_ARENA_MARK(&cx->tempPool);
59968:     return fun->script()->bindings.getLocalNameArray(cx, &cx->tempPool);
48470: }
48470: 
48470: extern JS_PUBLIC_API(JSAtom *)
48470: JS_LocalNameToAtom(jsuword w)
48470: {
48470:     return JS_LOCAL_NAME_TO_ATOM(w);
48470: }
48470: 
48470: extern JS_PUBLIC_API(JSString *)
48470: JS_AtomKey(JSAtom *atom)
48470: {
48470:     return ATOM_TO_STRING(atom);
48470: }
48470: 
48470: extern JS_PUBLIC_API(void)
48470: JS_ReleaseFunctionLocalNameArray(JSContext *cx, void *mark)
48470: {
48470:     JS_ARENA_RELEASE(&cx->tempPool, mark);
48470: }
48470: 
    1: JS_PUBLIC_API(JSScript *)
    1: JS_GetFunctionScript(JSContext *cx, JSFunction *fun)
    1: {
    1:     return FUN_SCRIPT(fun);
    1: }
    1: 
    1: JS_PUBLIC_API(JSNative)
    1: JS_GetFunctionNative(JSContext *cx, JSFunction *fun)
    1: {
53557:     return Jsvalify(fun->maybeNative());
 4127: }
 4127: 
    1: JS_PUBLIC_API(JSPrincipals *)
    1: JS_GetScriptPrincipals(JSContext *cx, JSScript *script)
    1: {
    1:     return script->principals;
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: /*
    1:  *  Stack Frame Iterator
    1:  */
    1: JS_PUBLIC_API(JSStackFrame *)
    1: JS_FrameIterator(JSContext *cx, JSStackFrame **iteratorp)
    1: {
53840:     *iteratorp = (*iteratorp == NULL) ? js_GetTopStackFrame(cx) : (*iteratorp)->prev();
    1:     return *iteratorp;
    1: }
    1: 
    1: JS_PUBLIC_API(JSScript *)
    1: JS_GetFrameScript(JSContext *cx, JSStackFrame *fp)
    1: {
51056:     return fp->maybeScript();
    1: }
    1: 
    1: JS_PUBLIC_API(jsbytecode *)
    1: JS_GetFramePC(JSContext *cx, JSStackFrame *fp)
    1: {
42717:     return fp->pc(cx);
    1: }
    1: 
    1: JS_PUBLIC_API(JSStackFrame *)
    1: JS_GetScriptedCaller(JSContext *cx, JSStackFrame *fp)
    1: {
22652:     return js_GetScriptedCaller(cx, fp);
    1: }
    1: 
53557: JSPrincipals *
53557: js_StackFramePrincipals(JSContext *cx, JSStackFrame *fp)
    1: {
18870:     JSSecurityCallbacks *callbacks;
18870: 
53840:     if (fp->isFunctionFrame()) {
18870:         callbacks = JS_GetSecurityCallbacks(cx);
18870:         if (callbacks && callbacks->findObjectPrincipals) {
53840:             if (&fp->fun()->compiledFunObj() != &fp->callee())
53840:                 return callbacks->findObjectPrincipals(cx, &fp->callee());
    1:             /* FALL THROUGH */
    1:         }
    1:     }
53840:     if (fp->isScriptFrame())
53840:         return fp->script()->principals;
    1:     return NULL;
    1: }
    1: 
38586: JSPrincipals *
38586: js_EvalFramePrincipals(JSContext *cx, JSObject *callee, JSStackFrame *caller)
    1: {
    1:     JSPrincipals *principals, *callerPrincipals;
18870:     JSSecurityCallbacks *callbacks;
    1: 
18870:     callbacks = JS_GetSecurityCallbacks(cx);
38586:     if (callbacks && callbacks->findObjectPrincipals)
38586:         principals = callbacks->findObjectPrincipals(cx, callee);
38586:     else
    1:         principals = NULL;
    1:     if (!caller)
    1:         return principals;
53557:     callerPrincipals = js_StackFramePrincipals(cx, caller);
    1:     return (callerPrincipals && principals &&
    1:             callerPrincipals->subsume(callerPrincipals, principals))
    1:            ? principals
    1:            : callerPrincipals;
    1: }
    1: 
    1: JS_PUBLIC_API(void *)
    1: JS_GetFrameAnnotation(JSContext *cx, JSStackFrame *fp)
    1: {
53840:     if (fp->annotation() && fp->isScriptFrame()) {
53557:         JSPrincipals *principals = js_StackFramePrincipals(cx, fp);
    1: 
    1:         if (principals && principals->globalPrivilegesEnabled(cx, principals)) {
    1:             /*
    1:              * Give out an annotation only if privileges have not been revoked
    1:              * or disabled globally.
    1:              */
53840:             return fp->annotation();
    1:         }
    1:     }
    1: 
    1:     return NULL;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetFrameAnnotation(JSContext *cx, JSStackFrame *fp, void *annotation)
    1: {
51054:     fp->setAnnotation(annotation);
    1: }
    1: 
    1: JS_PUBLIC_API(void *)
    1: JS_GetFramePrincipalArray(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     JSPrincipals *principals;
    1: 
53557:     principals = js_StackFramePrincipals(cx, fp);
    1:     if (!principals)
    1:         return NULL;
    1:     return principals->getPrincipalArray(cx, principals);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
53557: JS_IsScriptFrame(JSContext *cx, JSStackFrame *fp)
    1: {
53557:     return !fp->isDummyFrame();
    1: }
    1: 
    1: /* this is deprecated, use JS_GetFrameScopeChain instead */
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetFrameObject(JSContext *cx, JSStackFrame *fp)
    1: {
53840:     return &fp->scopeChain();
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetFrameScopeChain(JSContext *cx, JSStackFrame *fp)
    1: {
42714:     JS_ASSERT(cx->stack().contains(fp));
42714: 
56704:     js::AutoCompartment ac(cx, &fp->scopeChain());
56704:     if (!ac.enter())
56704:         return NULL;
56704: 
    1:     /* Force creation of argument and call objects if not yet created */
    1:     (void) JS_GetFrameCallObject(cx, fp);
56729:     return GetScopeChain(cx, fp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetFrameCallObject(JSContext *cx, JSStackFrame *fp)
    1: {
42714:     JS_ASSERT(cx->stack().contains(fp));
42714: 
53840:     if (!fp->isFunctionFrame())
    1:         return NULL;
    1: 
56704:     js::AutoCompartment ac(cx, &fp->scopeChain());
56704:     if (!ac.enter())
56704:         return NULL;
56704: 
    1:     /* Force creation of argument object if not yet created */
    1:     (void) js_GetArgsObject(cx, fp);
    1: 
    1:     /*
    1:      * XXX ill-defined: null return here means error was reported, unlike a
    1:      *     null returned above or in the #else
    1:      */
25217:     return js_GetCallObject(cx, fp);
    1: }
    1: 
55713: JS_PUBLIC_API(JSBool)
55713: JS_GetFrameThis(JSContext *cx, JSStackFrame *fp, jsval *thisv)
    1: {
50484:     if (fp->isDummyFrame())
55713:         return false;
56704: 
56704:     js::AutoCompartment ac(cx, &fp->scopeChain());
56704:     if (!ac.enter())
56704:         return false;
56704: 
55713:     if (!fp->computeThis(cx))
55713:         return false;
55713:     *thisv = Jsvalify(fp->thisValue());
55713:     return true;
    1: }
    1: 
    1: JS_PUBLIC_API(JSFunction *)
    1: JS_GetFrameFunction(JSContext *cx, JSStackFrame *fp)
    1: {
53840:     return fp->maybeFun();
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetFrameFunctionObject(JSContext *cx, JSStackFrame *fp)
    1: {
53840:     if (!fp->isFunctionFrame())
18955:         return NULL;
18572: 
53840:     JS_ASSERT(fp->callee().isFunction());
53840:     JS_ASSERT(fp->callee().getPrivate() == fp->fun());
53840:     return &fp->callee();
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_IsConstructorFrame(JSContext *cx, JSStackFrame *fp)
    1: {
53840:     return fp->isConstructing();
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetFrameCalleeObject(JSContext *cx, JSStackFrame *fp)
    1: {
53840:     return fp->maybeCallee();
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
48676: JS_GetValidFrameCalleeObject(JSContext *cx, JSStackFrame *fp, jsval *vp)
48676: {
48676:     Value v;
48676: 
48676:     if (!fp->getValidCalleeObject(cx, &v))
48676:         return false;
48676:     *vp = Jsvalify(v);
48676:     return true;
48676: }
48676: 
48676: JS_PUBLIC_API(JSBool)
    1: JS_IsDebuggerFrame(JSContext *cx, JSStackFrame *fp)
    1: {
53840:     return fp->isDebuggerFrame();
    1: }
    1: 
    1: JS_PUBLIC_API(jsval)
    1: JS_GetFrameReturnValue(JSContext *cx, JSStackFrame *fp)
    1: {
53840:     return Jsvalify(fp->returnValue());
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetFrameReturnValue(JSContext *cx, JSStackFrame *fp, jsval rval)
    1: {
57727: #ifdef JS_METHODJIT
57727:     JS_ASSERT_IF(fp->isScriptFrame(), fp->script()->debugMode);
57727: #endif
56704:     assertSameCompartment(cx, fp, rval);
51056:     fp->setReturnValue(Valueify(rval));
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: JS_PUBLIC_API(const char *)
    1: JS_GetScriptFilename(JSContext *cx, JSScript *script)
    1: {
    1:     return script->filename;
    1: }
    1: 
    1: JS_PUBLIC_API(uintN)
    1: JS_GetScriptBaseLineNumber(JSContext *cx, JSScript *script)
    1: {
    1:     return script->lineno;
    1: }
    1: 
    1: JS_PUBLIC_API(uintN)
    1: JS_GetScriptLineExtent(JSContext *cx, JSScript *script)
    1: {
    1:     return js_GetScriptLineExtent(script);
    1: }
    1: 
    1: JS_PUBLIC_API(JSVersion)
    1: JS_GetScriptVersion(JSContext *cx, JSScript *script)
    1: {
53848:     return VersionNumber(script->getVersion());
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetNewScriptHook(JSRuntime *rt, JSNewScriptHook hook, void *callerdata)
    1: {
 2433:     rt->globalDebugHooks.newScriptHook = hook;
 2433:     rt->globalDebugHooks.newScriptHookData = callerdata;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetDestroyScriptHook(JSRuntime *rt, JSDestroyScriptHook hook,
    1:                         void *callerdata)
    1: {
 2433:     rt->globalDebugHooks.destroyScriptHook = hook;
 2433:     rt->globalDebugHooks.destroyScriptHookData = callerdata;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_EvaluateUCInStackFrame(JSContext *cx, JSStackFrame *fp,
    1:                           const jschar *chars, uintN length,
    1:                           const char *filename, uintN lineno,
    1:                           jsval *rval)
    1: {
28998:     JS_ASSERT_NOT_ON_TRACE(cx);
28997: 
53391:     if (!CheckDebugMode(cx))
58070:         return false;
53391: 
48582:     JSObject *scobj = JS_GetFrameScopeChain(cx, fp);
    1:     if (!scobj)
48582:         return false;
    1: 
56704:     js::AutoCompartment ac(cx, scobj);
56704:     if (!ac.enter())
58070:         return false;
56704: 
24620:     /*
24620:      * NB: This function breaks the assumption that the compiler can see all
27012:      * calls and properly compute a static level. In order to get around this,
27012:      * we use a static level that will cause us not to attempt to optimize
24620:      * variable references made by this frame.
24620:      */
53557:     JSScript *script = Compiler::compileScript(cx, scobj, fp, js_StackFramePrincipals(cx, fp),
58990:                                                TCF_COMPILE_N_GO, chars, length,
61450:                                                filename, lineno, cx->findVersion(),
61450:                                                NULL, UpvarCookie::UPVAR_LEVEL_LIMIT);
28952: 
    1:     if (!script)
48582:         return false;
    1: 
53840:     bool ok = Execute(cx, scobj, script, fp, JSFRAME_DEBUGGER | JSFRAME_EVAL, Valueify(rval));
28952: 
    1:     js_DestroyScript(cx, script);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_EvaluateInStackFrame(JSContext *cx, JSStackFrame *fp,
    1:                         const char *bytes, uintN length,
    1:                         const char *filename, uintN lineno,
    1:                         jsval *rval)
    1: {
    1:     jschar *chars;
    1:     JSBool ok;
    1:     size_t len = length;
    1:     
53391:     if (!CheckDebugMode(cx))
53391:         return JS_FALSE;
53391: 
    1:     chars = js_InflateString(cx, bytes, &len);
    1:     if (!chars)
    1:         return JS_FALSE;
    1:     length = (uintN) len;
    1:     ok = JS_EvaluateUCInStackFrame(cx, fp, chars, length, filename, lineno,
    1:                                    rval);
30851:     cx->free(chars);
    1: 
    1:     return ok;
    1: }
    1: 
    1: /************************************************************************/
    1: 
52503: /* This all should be reworked to avoid requiring JSScopeProperty types. */
    1: 
    1: JS_PUBLIC_API(JSScopeProperty *)
    1: JS_PropertyIterator(JSObject *obj, JSScopeProperty **iteratorp)
    1: {
52503:     const Shape *shape;
    1: 
52503:     /* The caller passes null in *iteratorp to get things started. */
52503:     shape = (Shape *) *iteratorp;
52503:     if (!shape) {
52503:         shape = obj->lastProperty();
52503:     } else {
52503:         shape = shape->previous();
52503:         if (!shape->previous()) {
52503:             JS_ASSERT(JSID_IS_EMPTY(shape->id));
52503:             shape = NULL;
52503:         }
52503:     }
    1: 
52503:     return *iteratorp = reinterpret_cast<JSScopeProperty *>(const_cast<Shape *>(shape));
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_GetPropertyDesc(JSContext *cx, JSObject *obj, JSScopeProperty *sprop,
    1:                    JSPropertyDesc *pd)
    1: {
56704:     assertSameCompartment(cx, obj);
52503:     Shape *shape = (Shape *) sprop;
52503:     pd->id = IdToJsval(shape->id);
    1: 
60211:     JSBool wasThrowing = cx->isExceptionPending();
60211:     Value lastException = UndefinedValue();
60211:     if (wasThrowing)
60211:         lastException = cx->getPendingException();
60211:     cx->clearPendingException();
    1: 
52503:     if (!js_GetProperty(cx, obj, shape->id, Valueify(&pd->value))) {
60211:         if (!cx->isExceptionPending()) {
    1:             pd->flags = JSPD_ERROR;
    1:             pd->value = JSVAL_VOID;
    1:         } else {
    1:             pd->flags = JSPD_EXCEPTION;
60211:             pd->value = Jsvalify(cx->getPendingException());
    1:         }
    1:     } else {
    1:         pd->flags = 0;
    1:     }
    1: 
35076:     if (wasThrowing)
60211:         cx->setPendingException(lastException);
    1: 
52503:     pd->flags |= (shape->enumerable() ? JSPD_ENUMERATE : 0)
52503:               |  (!shape->writable()  ? JSPD_READONLY  : 0)
52503:               |  (!shape->configurable() ? JSPD_PERMANENT : 0);
13706:     pd->spare = 0;
58293:     if (shape->getter() == GetCallArg) {
52503:         pd->slot = shape->shortid;
13706:         pd->flags |= JSPD_ARGUMENT;
58293:     } else if (shape->getter() == GetCallVar) {
52503:         pd->slot = shape->shortid;
13706:         pd->flags |= JSPD_VARIABLE;
13706:     } else {
13706:         pd->slot = 0;
    1:     }
    1:     pd->alias = JSVAL_VOID;
35076: 
52503:     if (obj->containsSlot(shape->slot)) {
52503:         for (Shape::Range r = obj->lastProperty()->all(); !r.empty(); r.popFront()) {
52503:             const Shape &aprop = r.front();
52503:             if (&aprop != shape && aprop.slot == shape->slot) {
52503:                 pd->alias = IdToJsval(aprop.id);
    1:                 break;
    1:             }
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_GetPropertyDescArray(JSContext *cx, JSObject *obj, JSPropertyDescArray *pda)
    1: {
56704:     assertSameCompartment(cx, obj);
48470:     Class *clasp = obj->getClass();
40430:     if (!obj->isNative() || (clasp->flags & JSCLASS_NEW_ENUMERATE)) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_CANT_DESCRIBE_PROPS, clasp->name);
    1:         return JS_FALSE;
    1:     }
    1:     if (!clasp->enumerate(cx, obj))
    1:         return JS_FALSE;
    1: 
52503:     /* Return an empty pda early if obj has no own properties. */
52503:     if (obj->nativeEmpty()) {
    1:         pda->length = 0;
    1:         pda->array = NULL;
    1:         return JS_TRUE;
    1:     }
    1: 
52503:     uint32 n = obj->propertyCount();
52503:     JSPropertyDesc *pd = (JSPropertyDesc *) cx->malloc(size_t(n) * sizeof(JSPropertyDesc));
    1:     if (!pd)
    1:         return JS_FALSE;
52503:     uint32 i = 0;
52503:     for (Shape::Range r = obj->lastProperty()->all(); !r.empty(); r.popFront()) {
48470:         if (!js_AddRoot(cx, Valueify(&pd[i].id), NULL))
    1:             goto bad;
48470:         if (!js_AddRoot(cx, Valueify(&pd[i].value), NULL))
    1:             goto bad;
52503:         Shape *shape = const_cast<Shape *>(&r.front());
52503:         if (!JS_GetPropertyDesc(cx, obj, reinterpret_cast<JSScopeProperty *>(shape), &pd[i]))
    1:             goto bad;
48470:         if ((pd[i].flags & JSPD_ALIAS) && !js_AddRoot(cx, Valueify(&pd[i].alias), NULL))
    1:             goto bad;
    1:         if (++i == n)
    1:             break;
    1:     }
    1:     pda->length = i;
    1:     pda->array = pd;
    1:     return JS_TRUE;
    1: 
    1: bad:
    1:     pda->length = i + 1;
    1:     pda->array = pd;
    1:     JS_PutPropertyDescArray(cx, pda);
    1:     return JS_FALSE;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_PutPropertyDescArray(JSContext *cx, JSPropertyDescArray *pda)
    1: {
    1:     JSPropertyDesc *pd;
    1:     uint32 i;
    1: 
    1:     pd = pda->array;
    1:     for (i = 0; i < pda->length; i++) {
    1:         js_RemoveRoot(cx->runtime, &pd[i].id);
    1:         js_RemoveRoot(cx->runtime, &pd[i].value);
    1:         if (pd[i].flags & JSPD_ALIAS)
    1:             js_RemoveRoot(cx->runtime, &pd[i].alias);
    1:     }
30851:     cx->free(pd);
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: JS_PUBLIC_API(JSBool)
41863: JS_SetDebuggerHandler(JSRuntime *rt, JSDebuggerHandler handler, void *closure)
    1: {
 2433:     rt->globalDebugHooks.debuggerHandler = handler;
 2433:     rt->globalDebugHooks.debuggerHandlerData = closure;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetSourceHandler(JSRuntime *rt, JSSourceHandler handler, void *closure)
    1: {
 2433:     rt->globalDebugHooks.sourceHandler = handler;
 2433:     rt->globalDebugHooks.sourceHandlerData = closure;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetExecuteHook(JSRuntime *rt, JSInterpreterHook hook, void *closure)
    1: {
 2433:     rt->globalDebugHooks.executeHook = hook;
 2433:     rt->globalDebugHooks.executeHookData = closure;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetCallHook(JSRuntime *rt, JSInterpreterHook hook, void *closure)
    1: {
35331: #ifdef JS_TRACER
40840:     {
40840:         AutoLockGC lock(rt);
35331:         bool wasInhibited = rt->debuggerInhibitsJIT();
35331: #endif
 2433:         rt->globalDebugHooks.callHook = hook;
 2433:         rt->globalDebugHooks.callHookData = closure;
35331: #ifdef JS_TRACER
35331:         JITInhibitingHookChange(rt, wasInhibited);
40840:     }
35331: #endif
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
41863: JS_SetThrowHook(JSRuntime *rt, JSThrowHook hook, void *closure)
    1: {
 2433:     rt->globalDebugHooks.throwHook = hook;
 2433:     rt->globalDebugHooks.throwHookData = closure;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetDebugErrorHook(JSRuntime *rt, JSDebugErrorHook hook, void *closure)
    1: {
 2433:     rt->globalDebugHooks.debugErrorHook = hook;
 2433:     rt->globalDebugHooks.debugErrorHookData = closure;
    1:     return JS_TRUE;
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: JS_PUBLIC_API(size_t)
    1: JS_GetObjectTotalSize(JSContext *cx, JSObject *obj)
    1: {
55746:     return obj->slotsAndStructSize();
    1: }
    1: 
    1: static size_t
    1: GetAtomTotalSize(JSContext *cx, JSAtom *atom)
    1: {
    1:     size_t nbytes;
    1: 
 4529:     nbytes = sizeof(JSAtom *) + sizeof(JSDHashEntryStub);
    1:     nbytes += sizeof(JSString);
29366:     nbytes += (ATOM_TO_STRING(atom)->flatLength() + 1) * sizeof(jschar);
    1:     return nbytes;
    1: }
    1: 
    1: JS_PUBLIC_API(size_t)
    1: JS_GetFunctionTotalSize(JSContext *cx, JSFunction *fun)
    1: {
    1:     size_t nbytes;
    1: 
    1:     nbytes = sizeof *fun;
13824:     nbytes += JS_GetObjectTotalSize(cx, FUN_OBJECT(fun));
    1:     if (FUN_INTERPRETED(fun))
    1:         nbytes += JS_GetScriptTotalSize(cx, fun->u.i.script);
    1:     if (fun->atom)
    1:         nbytes += GetAtomTotalSize(cx, fun->atom);
    1:     return nbytes;
    1: }
    1: 
    1: #include "jsemit.h"
    1: 
    1: JS_PUBLIC_API(size_t)
    1: JS_GetScriptTotalSize(JSContext *cx, JSScript *script)
    1: {
    1:     size_t nbytes, pbytes;
    1:     jsatomid i;
    1:     jssrcnote *sn, *notes;
 3235:     JSObjectArray *objarray;
    1:     JSPrincipals *principals;
    1: 
    1:     nbytes = sizeof *script;
18285:     if (script->u.object)
18285:         nbytes += JS_GetObjectTotalSize(cx, script->u.object);
    1: 
    1:     nbytes += script->length * sizeof script->code[0];
    1:     nbytes += script->atomMap.length * sizeof script->atomMap.vector[0];
    1:     for (i = 0; i < script->atomMap.length; i++)
    1:         nbytes += GetAtomTotalSize(cx, script->atomMap.vector[i]);
    1: 
    1:     if (script->filename)
    1:         nbytes += strlen(script->filename) + 1;
    1: 
32723:     notes = script->notes();
    1:     for (sn = notes; !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn))
    1:         continue;
    1:     nbytes += (sn - notes + 1) * sizeof *sn;
    1: 
59221:     if (JSScript::isValidOffset(script->objectsOffset)) {
32723:         objarray = script->objects();
 3235:         i = objarray->length;
 3235:         nbytes += sizeof *objarray + i * sizeof objarray->vector[0];
 3235:         do {
 3235:             nbytes += JS_GetObjectTotalSize(cx, objarray->vector[--i]);
 3235:         } while (i != 0);
 3235:     }
 3235: 
59221:     if (JSScript::isValidOffset(script->regexpsOffset)) {
32723:         objarray = script->regexps();
 3235:         i = objarray->length;
 3235:         nbytes += sizeof *objarray + i * sizeof objarray->vector[0];
 3235:         do {
 3235:             nbytes += JS_GetObjectTotalSize(cx, objarray->vector[--i]);
 3235:         } while (i != 0);
 3235:     }
 3235: 
59221:     if (JSScript::isValidOffset(script->trynotesOffset)) {
 3235:         nbytes += sizeof(JSTryNoteArray) +
32723:             script->trynotes()->length * sizeof(JSTryNote);
    1:     }
    1: 
    1:     principals = script->principals;
    1:     if (principals) {
    1:         JS_ASSERT(principals->refcount);
    1:         pbytes = sizeof *principals;
    1:         if (principals->refcount > 1)
    1:             pbytes = JS_HOWMANY(pbytes, principals->refcount);
    1:         nbytes += pbytes;
    1:     }
    1: 
    1:     return nbytes;
    1: }
    1: 
    1: JS_PUBLIC_API(uint32)
    1: JS_GetTopScriptFilenameFlags(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     if (!fp)
22652:         fp = js_GetTopStackFrame(cx);
    1:     while (fp) {
53840:         if (fp->isScriptFrame())
53840:             return JS_GetScriptFilenameFlags(fp->script());
53840:         fp = fp->prev();
    1:     }
    1:     return 0;
    1:  }
    1: 
    1: JS_PUBLIC_API(uint32)
    1: JS_GetScriptFilenameFlags(JSScript *script)
    1: {
    1:     JS_ASSERT(script);
    1:     if (!script->filename)
    1:         return JSFILENAME_NULL;
    1:     return js_GetScriptFilenameFlags(script->filename);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_FlagScriptFilenamePrefix(JSRuntime *rt, const char *prefix, uint32 flags)
    1: {
    1:     if (!js_SaveScriptFilenameRT(rt, prefix, flags))
    1:         return JS_FALSE;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_IsSystemObject(JSContext *cx, JSObject *obj)
    1: {
32603:     return obj->isSystem();
    1: }
    1: 
43286: JS_PUBLIC_API(JSBool)
43286: JS_MakeSystemObject(JSContext *cx, JSObject *obj)
    1: {
32603:     obj->setSystem();
43286:     return true;
    1: }
 2433: 
 2433: /************************************************************************/
 2433: 
60563: JS_PUBLIC_API(JSObject *)
60563: JS_UnwrapObject(JSContext *cx, JSObject *obj)
60563: {
60563:     return obj->unwrap();
60563: }
60563: 
60563: /************************************************************************/
60563: 
53848: JS_FRIEND_API(void)
53848: js_RevertVersion(JSContext *cx)
53848: {
53848:     cx->clearVersionOverride();
53848: }
53848: 
35331: JS_PUBLIC_API(const JSDebugHooks *)
 2433: JS_GetGlobalDebugHooks(JSRuntime *rt)
 2433: {
 2433:     return &rt->globalDebugHooks;
 2433: }
 2433: 
37717: const JSDebugHooks js_NullDebugHooks = {};
37717: 
 2433: JS_PUBLIC_API(JSDebugHooks *)
35331: JS_SetContextDebugHooks(JSContext *cx, const JSDebugHooks *hooks)
 2433: {
35331:     JS_ASSERT(hooks);
37717:     if (hooks != &cx->runtime->globalDebugHooks && hooks != &js_NullDebugHooks)
37741:         LeaveTrace(cx);
 2433: 
35331: #ifdef JS_TRACER
40840:     AutoLockGC lock(cx->runtime);
35331: #endif
35331:     JSDebugHooks *old = const_cast<JSDebugHooks *>(cx->debugHooks);
 2433:     cx->debugHooks = hooks;
35331: #ifdef JS_TRACER
35331:     cx->updateJITEnabled();
35331: #endif
 2433:     return old;
 2433: }
10339: 
37717: JS_PUBLIC_API(JSDebugHooks *)
37717: JS_ClearContextDebugHooks(JSContext *cx)
37717: {
37717:     return JS_SetContextDebugHooks(cx, &js_NullDebugHooks);
37717: }
37717: 
60787: JS_PUBLIC_API(JSBool)
60787: JS_StartProfiling()
60787: {
60787:     return Probes::startProfiling();
60787: }
10339: 
60787: JS_PUBLIC_API(void)
60787: JS_StopProfiling()
60787: {
60787:     Probes::stopProfiling();
60787: }
60787: 
60787: #ifdef MOZ_PROFILING
60787: 
60787: static JSBool
60787: StartProfiling(JSContext *cx, uintN argc, jsval *vp)
60787: {
61065:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(JS_StartProfiling()));
60787:     return true;
60787: }
60787: 
60787: static JSBool
60787: StopProfiling(JSContext *cx, uintN argc, jsval *vp)
60787: {
61065:     JS_StopProfiling();
60791:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
60787:     return true;
60787: }
60787: 
60791: #ifdef MOZ_SHARK
60791: 
60791: static JSBool
60791: IgnoreAndReturnTrue(JSContext *cx, uintN argc, jsval *vp)
60791: {
60791:     JS_SET_RVAL(cx, vp, JSVAL_TRUE);
60791:     return true;
60791: }
60791: 
60791: #endif
60791: 
60787: static JSFunctionSpec profiling_functions[] = {
60787:     JS_FN("startProfiling",  StartProfiling,      0,0),
60787:     JS_FN("stopProfiling",   StopProfiling,       0,0),
60791: #ifdef MOZ_SHARK
60791:     /* Keep users of the old shark API happy. */
60791:     JS_FN("connectShark",    IgnoreAndReturnTrue, 0,0),
60791:     JS_FN("disconnectShark", IgnoreAndReturnTrue, 0,0),
60791:     JS_FN("startShark",      StartProfiling,      0,0),
60791:     JS_FN("stopShark",       StopProfiling,       0,0),
60791: #endif
60787:     JS_FS_END
60787: };
60787: 
60787: #endif
13496: 
10447: JS_PUBLIC_API(JSBool)
60787: JS_DefineProfilingFunctions(JSContext *cx, JSObject *obj)
10339: {
60787: #ifdef MOZ_PROFILING
60787:     return JS_DefineFunctions(cx, obj, profiling_functions);
60787: #else
60787:     return true;
60787: #endif
10339: }
10339: 
15763: #ifdef MOZ_CALLGRIND
15763: 
15763: #include <valgrind/callgrind.h>
15763: 
15763: JS_FRIEND_API(JSBool)
53557: js_StartCallgrind(JSContext *cx, uintN argc, jsval *vp)
15763: {
15763:     CALLGRIND_START_INSTRUMENTATION;
15763:     CALLGRIND_ZERO_STATS;
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
15763:     return JS_TRUE;
15763: }
15763: 
15763: JS_FRIEND_API(JSBool)
53557: js_StopCallgrind(JSContext *cx, uintN argc, jsval *vp)
15763: {
15763:     CALLGRIND_STOP_INSTRUMENTATION;
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
15763:     return JS_TRUE;
15763: }
15763: 
15763: JS_FRIEND_API(JSBool)
53557: js_DumpCallgrind(JSContext *cx, uintN argc, jsval *vp)
15763: {
15763:     JSString *str;
15763: 
53557:     jsval *argv = JS_ARGV(cx, vp);
15763:     if (argc > 0 && JSVAL_IS_STRING(argv[0])) {
15763:         str = JSVAL_TO_STRING(argv[0]);
59893:         JSAutoByteString bytes(cx, str);
59893:         if (!!bytes) {
59893:             CALLGRIND_DUMP_STATS_AT(bytes.ptr());
15763:             return JS_TRUE;
15763:         }
15763:     }
15763:     CALLGRIND_DUMP_STATS;
15763: 
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
15763:     return JS_TRUE;
15763: }
15763: 
15763: #endif /* MOZ_CALLGRIND */
16288: 
16288: #ifdef MOZ_VTUNE
16288: #include <VTuneApi.h>
16288: 
16288: static const char *vtuneErrorMessages[] = {
16288:   "unknown, error #0",
16288:   "invalid 'max samples' field",
16288:   "invalid 'samples per buffer' field",
16288:   "invalid 'sample interval' field",
16288:   "invalid path",
16288:   "sample file in use",
16288:   "invalid 'number of events' field",
16288:   "unknown, error #7",
16288:   "internal error",
16288:   "bad event name",
16288:   "VTStopSampling called without calling VTStartSampling",
16288:   "no events selected for event-based sampling",
16288:   "events selected cannot be run together",
16288:   "no sampling parameters",
16288:   "sample database already exists",
16288:   "sampling already started",
16288:   "time-based sampling not supported",
16288:   "invalid 'sampling parameters size' field",
16288:   "invalid 'event size' field",
16288:   "sampling file already bound",
16288:   "invalid event path",
16288:   "invalid license",
16288:   "invalid 'global options' field",
16288: 
16288: };
16288: 
16288: JS_FRIEND_API(JSBool)
53646: js_StartVtune(JSContext *cx, uintN argc, jsval *vp)
16288: {
16288:     VTUNE_EVENT events[] = {
16288:         { 1000000, 0, 0, 0, "CPU_CLK_UNHALTED.CORE" },
16288:         { 1000000, 0, 0, 0, "INST_RETIRED.ANY" },
16288:     };
16288: 
16288:     U32 n_events = sizeof(events) / sizeof(VTUNE_EVENT);
16288:     char *default_filename = "mozilla-vtune.tb5";
16288:     JSString *str;
16288:     U32 status;
16288: 
54568:     VTUNE_SAMPLING_PARAMS params = {
16288:         sizeof(VTUNE_SAMPLING_PARAMS),
16288:         sizeof(VTUNE_EVENT),
16288:         0, 0, /* Reserved fields */
16288:         1,    /* Initialize in "paused" state */
16288:         0,    /* Max samples, or 0 for "continuous" */
16288:         4096, /* Samples per buffer */
16288:         0.1,  /* Sampling interval in ms */
16288:         1,    /* 1 for event-based sampling, 0 for time-based */
16288: 
16288:         n_events,
16288:         events,
16288:         default_filename,
16288:     };
16288: 
53646:     jsval *argv = JS_ARGV(cx, vp);
16288:     if (argc > 0 && JSVAL_IS_STRING(argv[0])) {
16288:         str = JSVAL_TO_STRING(argv[0]);
29366:         params.tb5Filename = js_DeflateString(cx, str->chars(), str->length());
16288:     }
16288: 
16288:     status = VTStartSampling(&params);
16288: 
16288:     if (params.tb5Filename != default_filename)
30851:         cx->free(params.tb5Filename);
16288: 
16288:     if (status != 0) {
16288:         if (status == VTAPI_MULTIPLE_RUNS)
16288:             VTStopSampling(0);
16288:         if (status < sizeof(vtuneErrorMessages))
16288:             JS_ReportError(cx, "Vtune setup error: %s",
16288:                            vtuneErrorMessages[status]);
16288:         else
16288:             JS_ReportError(cx, "Vtune setup error: %d",
16288:                            status);
54568:         return false;
16288:     }
54568:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
54568:     return true;
16288: }
16288: 
16288: JS_FRIEND_API(JSBool)
53646: js_StopVtune(JSContext *cx, uintN argc, jsval *vp)
16288: {
16288:     U32 status = VTStopSampling(1);
16288:     if (status) {
16288:         if (status < sizeof(vtuneErrorMessages))
16288:             JS_ReportError(cx, "Vtune shutdown error: %s",
16288:                            vtuneErrorMessages[status]);
16288:         else
16288:             JS_ReportError(cx, "Vtune shutdown error: %d",
16288:                            status);
54568:         return false;
16288:     }
54568:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
54568:     return true;
16288: }
16288: 
16288: JS_FRIEND_API(JSBool)
53646: js_PauseVtune(JSContext *cx, uintN argc, jsval *vp)
16288: {
16288:     VTPause();
54568:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
54568:     return true;
16288: }
16288: 
16288: JS_FRIEND_API(JSBool)
53646: js_ResumeVtune(JSContext *cx, uintN argc, jsval *vp)
16288: {
16288:     VTResume();
54568:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
54568:     return true;
16288: }
16288: 
16288: #endif /* MOZ_VTUNE */
31063: 
31063: #ifdef MOZ_TRACEVIS
31063: /*
31063:  * Ethogram - Javascript wrapper for TraceVis state
31063:  *
31063:  * ethology: The scientific study of animal behavior,
31063:  *           especially as it occurs in a natural environment.
31063:  * ethogram: A pictorial catalog of the behavioral patterns of
31063:  *           an organism or a species.
31063:  *
31063:  */
31063: #if defined(XP_WIN)
52897: #include "jswin.h"
31063: #else
31063: #include <sys/time.h>
31063: #endif
31063: #include "jstracer.h"
31063: 
31063: #define ETHOGRAM_BUF_SIZE 65536
31063: 
31063: static JSBool
53646: ethogram_construct(JSContext *cx, uintN argc, jsval *vp);
31063: static void
31063: ethogram_finalize(JSContext *cx, JSObject *obj);
31063: 
31063: static JSClass ethogram_class = {
31063:     "Ethogram",
31063:     JSCLASS_HAS_PRIVATE,
62397:     JS_PropertyStub, JS_PropertyStub, JS_PropertyStub, JS_StrictPropertyStub,
31063:     JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub, ethogram_finalize,
31063:     JSCLASS_NO_OPTIONAL_MEMBERS
31063: };
31063: 
31063: struct EthogramEvent {
31063:     TraceVisState s;
31063:     TraceVisExitReason r;
31063:     int ts;
31063:     int tus;
31063:     JSString *filename;
31063:     int lineno;
31063: };
31063: 
31063: static int
31063: compare_strings(const void *k1, const void *k2)
31063: {
31063:     return strcmp((const char *) k1, (const char *) k2) == 0;
31063: }
31063: 
31063: class EthogramEventBuffer {
31063: private:
31063:     EthogramEvent mBuf[ETHOGRAM_BUF_SIZE];
31063:     int mReadPos;
31063:     int mWritePos;
31063:     JSObject *mFilenames;
31063:     int mStartSecond;
31063: 
31063:     struct EthogramScriptEntry {
31063:         char *filename;
31063:         JSString *jsfilename;
31063: 
31063:         EthogramScriptEntry *next;
31063:     };
31063:     EthogramScriptEntry *mScripts;
31063: 
31063: public:
31063:     friend JSBool
53646:     ethogram_construct(JSContext *cx, uintN argc, jsval *vp);
31063: 
31063:     inline void push(TraceVisState s, TraceVisExitReason r, char *filename, int lineno) {
31063:         mBuf[mWritePos].s = s;
31063:         mBuf[mWritePos].r = r;
31063: #if defined(XP_WIN)
31063:         FILETIME now;
31063:         GetSystemTimeAsFileTime(&now);
31063:         unsigned long long raw_us = 0.1 *
31063:             (((unsigned long long) now.dwHighDateTime << 32ULL) |
31063:              (unsigned long long) now.dwLowDateTime);
31063:         unsigned int sec = raw_us / 1000000L;
31063:         unsigned int usec = raw_us % 1000000L;
31063:         mBuf[mWritePos].ts = sec - mStartSecond;
31063:         mBuf[mWritePos].tus = usec;
31063: #else
31063:         struct timeval tv;
31063:         gettimeofday(&tv, NULL);
31063:         mBuf[mWritePos].ts = tv.tv_sec - mStartSecond;
31063:         mBuf[mWritePos].tus = tv.tv_usec;
31063: #endif
31063: 
31063:         JSString *jsfilename = findScript(filename);
31063:         mBuf[mWritePos].filename = jsfilename;
31063:         mBuf[mWritePos].lineno = lineno;
31063: 
31063:         mWritePos = (mWritePos + 1) % ETHOGRAM_BUF_SIZE;
31063:         if (mWritePos == mReadPos) {
31063:             mReadPos = (mWritePos + 1) % ETHOGRAM_BUF_SIZE;
31063:         }
31063:     }
31063: 
31063:     inline EthogramEvent *pop() {
31063:         EthogramEvent *e = &mBuf[mReadPos];
31063:         mReadPos = (mReadPos + 1) % ETHOGRAM_BUF_SIZE;
31063:         return e;
31063:     }
31063: 
31063:     bool isEmpty() {
31063:         return (mReadPos == mWritePos);
31063:     }
31063: 
31063:     EthogramScriptEntry *addScript(JSContext *cx, JSObject *obj, char *filename, JSString *jsfilename) {
31063:         JSHashNumber hash = JS_HashString(filename);
31063:         JSHashEntry **hep = JS_HashTableRawLookup(traceVisScriptTable, hash, filename);
31063:         if (*hep != NULL)
59912:             return NULL;
31063: 
31063:         JS_HashTableRawAdd(traceVisScriptTable, hep, hash, filename, this);
31063: 
31063:         EthogramScriptEntry * entry = (EthogramScriptEntry *) JS_malloc(cx, sizeof(EthogramScriptEntry));
31063:         if (entry == NULL)
31063:             return NULL;
31063: 
31063:         entry->next = mScripts;
31063:         mScripts = entry;
31063:         entry->filename = filename;
31063:         entry->jsfilename = jsfilename;
31063: 
31063:         return mScripts;
31063:     }
31063: 
31063:     void removeScripts(JSContext *cx) {
31063:         EthogramScriptEntry *se = mScripts;
31063:         while (se != NULL) {
31063:             char *filename = se->filename;
31063: 
31063:             JSHashNumber hash = JS_HashString(filename);
31063:             JSHashEntry **hep = JS_HashTableRawLookup(traceVisScriptTable, hash, filename);
31063:             JSHashEntry *he = *hep;
31063:             if (he) {
31063:                 /* we hardly knew he */
31063:                 JS_HashTableRawRemove(traceVisScriptTable, hep, he);
31063:             }
31063: 
31063:             EthogramScriptEntry *se_head = se;
31063:             se = se->next;
31063:             JS_free(cx, se_head);
31063:         }
31063:     }
31063: 
31063:     JSString *findScript(char *filename) {
31063:         EthogramScriptEntry *se = mScripts;
31063:         while (se != NULL) {
31063:             if (compare_strings(se->filename, filename))
31063:                 return (se->jsfilename);
31063:             se = se->next;
31063:         }
31063:         return NULL;
31063:     }
31063: 
31063:     JSObject *filenames() {
31063:         return mFilenames;
31063:     }
31063: 
31063:     int length() {
31063:         if (mWritePos < mReadPos)
31063:             return (mWritePos + ETHOGRAM_BUF_SIZE) - mReadPos;
31063:         else
31063:             return mWritePos - mReadPos;
31063:     }
31063: };
31063: 
31063: static char jstv_empty[] = "<null>";
31063: 
31063: inline char *
31063: jstv_Filename(JSStackFrame *fp)
31063: {
54568:     while (fp && !fp->isScriptFrame())
54568:         fp = fp->prev();
54568:     return (fp && fp->maybeScript() && fp->script()->filename)
54568:            ? (char *)fp->script()->filename
31063:            : jstv_empty;
31063: }
31063: inline uintN
31063: jstv_Lineno(JSContext *cx, JSStackFrame *fp)
31063: {
43048:     while (fp && fp->pc(cx) == NULL)
54568:         fp = fp->prev();
43048:     return (fp && fp->pc(cx)) ? js_FramePCToLineNumber(cx, fp) : 0;
31063: }
31063: 
31063: /* Collect states here and distribute to a matching buffer, if any */
31063: JS_FRIEND_API(void)
38585: js::StoreTraceVisState(JSContext *cx, TraceVisState s, TraceVisExitReason r)
31063: {
51449:     JSStackFrame *fp = cx->fp();
31063: 
31063:     char *script_file = jstv_Filename(fp);
31063:     JSHashNumber hash = JS_HashString(script_file);
31063: 
31063:     JSHashEntry **hep = JS_HashTableRawLookup(traceVisScriptTable, hash, script_file);
31063:     /* update event buffer, flag if overflowed */
31063:     JSHashEntry *he = *hep;
31063:     if (he) {
31063:         EthogramEventBuffer *p;
31063:         p = (EthogramEventBuffer *) he->value;
31063: 
31063:         p->push(s, r, script_file, jstv_Lineno(cx, fp));
31063:     }
31063: }
31063: 
31063: static JSBool
53646: ethogram_construct(JSContext *cx, uintN argc, jsval *vp)
31063: {
31063:     EthogramEventBuffer *p;
31063: 
31063:     p = (EthogramEventBuffer *) JS_malloc(cx, sizeof(EthogramEventBuffer));
56017:     if (!p)
56017:         return JS_FALSE;
31063: 
31063:     p->mReadPos = p->mWritePos = 0;
31063:     p->mScripts = NULL;
31063:     p->mFilenames = JS_NewArrayObject(cx, 0, NULL);
31063: 
31063: #if defined(XP_WIN)
31063:     FILETIME now;
31063:     GetSystemTimeAsFileTime(&now);
31063:     unsigned long long raw_us = 0.1 *
31063:         (((unsigned long long) now.dwHighDateTime << 32ULL) |
31063:          (unsigned long long) now.dwLowDateTime);
31063:     unsigned int s = raw_us / 1000000L;
31063:     p->mStartSecond = s;
31063: #else
31063:     struct timeval tv;
31063:     gettimeofday(&tv, NULL);
31063:     p->mStartSecond = tv.tv_sec;
31063: #endif
54568:     JSObject *obj;
54568:     if (JS_IsConstructing(cx, vp)) {
54568:         obj = JS_NewObject(cx, &ethogram_class, NULL, NULL);
54568:         if (!obj)
54568:             return JS_FALSE;
54568:     } else {
54568:         obj = JS_THIS_OBJECT(cx, vp);
54568:     }
54568: 
31063:     jsval filenames = OBJECT_TO_JSVAL(p->filenames());
31063:     if (!JS_DefineProperty(cx, obj, "filenames", filenames,
31063:                            NULL, NULL, JSPROP_READONLY|JSPROP_PERMANENT))
31063:         return JS_FALSE;
31063: 
54568:     JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(obj));
31063:     JS_SetPrivate(cx, obj, p);
31063:     return JS_TRUE;
31063: }
31063: 
31063: static void
31063: ethogram_finalize(JSContext *cx, JSObject *obj)
31063: {
31063:     EthogramEventBuffer *p;
31063:     p = (EthogramEventBuffer *) JS_GetInstancePrivate(cx, obj, &ethogram_class, NULL);
31063:     if (!p)
31063:         return;
31063: 
31063:     p->removeScripts(cx);
31063: 
31063:     JS_free(cx, p);
31063: }
31063: 
31063: static JSBool
53646: ethogram_addScript(JSContext *cx, uintN argc, jsval *vp)
31063: {
31063:     JSString *str;
31063:     char *filename = NULL;
53646:     jsval *argv = JS_ARGV(cx, vp);
54568:     JSObject *obj = JS_THIS_OBJECT(cx, vp);
54568:     if (!obj)
54568:         return false;
54568:     if (argc < 1) {
54568:         /* silently ignore no args */
54568:         JS_SET_RVAL(cx, vp, JSVAL_VOID);
54568:         return true;
54568:     }
54568:     if (JSVAL_IS_STRING(argv[0])) {
31063:         str = JSVAL_TO_STRING(argv[0]);
54568:         filename = js_DeflateString(cx, str->chars(), str->length());
54568:         if (!filename)
54568:             return false;
31063:     }
31063: 
31063:     EthogramEventBuffer *p = (EthogramEventBuffer *) JS_GetInstancePrivate(cx, obj, &ethogram_class, argv);
31063: 
31063:     p->addScript(cx, obj, filename, str);
54568:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
54568:     jsval dummy;
54568:     JS_CallFunctionName(cx, p->filenames(), "push", 1, argv, &dummy);
54568:     return true;
31063: }
31063: 
31063: static JSBool
53646: ethogram_getAllEvents(JSContext *cx, uintN argc, jsval *vp)
31063: {
31063:     EthogramEventBuffer *p;
54568:     jsval *argv = JS_ARGV(cx, vp);
31063: 
54568:     JSObject *obj = JS_THIS_OBJECT(cx, vp);
54568:     if (!obj)
54568:         return JS_FALSE;
54568: 
31063:     p = (EthogramEventBuffer *) JS_GetInstancePrivate(cx, obj, &ethogram_class, argv);
31063:     if (!p)
31063:         return JS_FALSE;
31063: 
31063:     if (p->isEmpty()) {
54568:         JS_SET_RVAL(cx, vp, JSVAL_NULL);
31063:         return JS_TRUE;
31063:     }
31063: 
31063:     JSObject *rarray = JS_NewArrayObject(cx, 0, NULL);
31063:     if (rarray == NULL) {
54568:         JS_SET_RVAL(cx, vp, JSVAL_NULL);
31063:         return JS_TRUE;
31063:     }
31063: 
54568:     JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(rarray));
31063: 
31063:     for (int i = 0; !p->isEmpty(); i++) {
31063: 
31063:         JSObject *x = JS_NewObject(cx, NULL, NULL, NULL);
31063:         if (x == NULL)
31063:             return JS_FALSE;
31063: 
31063:         EthogramEvent *e = p->pop();
31063: 
31063:         jsval state = INT_TO_JSVAL(e->s);
31063:         jsval reason = INT_TO_JSVAL(e->r);
31063:         jsval ts = INT_TO_JSVAL(e->ts);
31063:         jsval tus = INT_TO_JSVAL(e->tus);
31063: 
31063:         jsval filename = STRING_TO_JSVAL(e->filename);
31063:         jsval lineno = INT_TO_JSVAL(e->lineno);
31063: 
31063:         if (!JS_SetProperty(cx, x, "state", &state))
31063:             return JS_FALSE;
31063:         if (!JS_SetProperty(cx, x, "reason", &reason))
31063:             return JS_FALSE;
31063:         if (!JS_SetProperty(cx, x, "ts", &ts))
31063:             return JS_FALSE;
31063:         if (!JS_SetProperty(cx, x, "tus", &tus))
31063:             return JS_FALSE;
31063: 
31063:         if (!JS_SetProperty(cx, x, "filename", &filename))
31063:             return JS_FALSE;
31063:         if (!JS_SetProperty(cx, x, "lineno", &lineno))
31063:             return JS_FALSE;
31063: 
31063:         jsval element = OBJECT_TO_JSVAL(x);
31063:         JS_SetElement(cx, rarray, i, &element);
31063:     }
31063: 
31063:     return JS_TRUE;
31063: }
31063: 
31063: static JSBool
53646: ethogram_getNextEvent(JSContext *cx, uintN argc, jsval *vp)
31063: {
31063:     EthogramEventBuffer *p;
54568:     jsval *argv = JS_ARGV(cx, vp);
31063: 
54568:     JSObject *obj = JS_THIS_OBJECT(cx, vp);
54568:     if (!obj)
54568:         return JS_FALSE;
54568: 
31063:     p = (EthogramEventBuffer *) JS_GetInstancePrivate(cx, obj, &ethogram_class, argv);
31063:     if (!p)
31063:         return JS_FALSE;
31063: 
31063:     JSObject *x = JS_NewObject(cx, NULL, NULL, NULL);
31063:     if (x == NULL)
31063:         return JS_FALSE;
31063: 
31063:     if (p->isEmpty()) {
54568:         JS_SET_RVAL(cx, vp, JSVAL_NULL);
31063:         return JS_TRUE;
31063:     }
31063: 
31063:     EthogramEvent *e = p->pop();
31063:     jsval state = INT_TO_JSVAL(e->s);
31063:     jsval reason = INT_TO_JSVAL(e->r);
31063:     jsval ts = INT_TO_JSVAL(e->ts);
31063:     jsval tus = INT_TO_JSVAL(e->tus);
31063: 
31063:     jsval filename = STRING_TO_JSVAL(e->filename);
31063:     jsval lineno = INT_TO_JSVAL(e->lineno);
31063: 
31063:     if (!JS_SetProperty(cx, x, "state", &state))
31063:         return JS_FALSE;
31063:     if (!JS_SetProperty(cx, x, "reason", &reason))
31063:         return JS_FALSE;
31063:     if (!JS_SetProperty(cx, x, "ts", &ts))
31063:         return JS_FALSE;
31063:     if (!JS_SetProperty(cx, x, "tus", &tus))
31063:         return JS_FALSE;
31063:     if (!JS_SetProperty(cx, x, "filename", &filename))
31063:         return JS_FALSE;
31063: 
31063:     if (!JS_SetProperty(cx, x, "lineno", &lineno))
31063:         return JS_FALSE;
31063: 
54568:     JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(x));
31063: 
31063:     return JS_TRUE;
31063: }
31063: 
31063: static JSFunctionSpec ethogram_methods[] = {
54568:     JS_FN("addScript",    ethogram_addScript,    1,0),
54568:     JS_FN("getAllEvents", ethogram_getAllEvents, 0,0),
54568:     JS_FN("getNextEvent", ethogram_getNextEvent, 0,0),
54568:     JS_FS_END
31063: };
31063: 
31063: /*
31063:  * An |Ethogram| organizes the output of a collection of files that should be
31063:  * monitored together. A single object gets events for the group.
31063:  */
31063: JS_FRIEND_API(JSBool)
53646: js_InitEthogram(JSContext *cx, uintN argc, jsval *vp)
31063: {
31063:     if (!traceVisScriptTable) {
31063:         traceVisScriptTable = JS_NewHashTable(8, JS_HashString, compare_strings,
31063:                                          NULL, NULL, NULL);
31063:     }
31063: 
31063:     JS_InitClass(cx, JS_GetGlobalObject(cx), NULL, &ethogram_class,
31063:                  ethogram_construct, 0, NULL, ethogram_methods,
31063:                  NULL, NULL);
31063: 
54568:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
54568:     return true;
31063: }
31063: 
31063: JS_FRIEND_API(JSBool)
53646: js_ShutdownEthogram(JSContext *cx, uintN argc, jsval *vp)
31063: {
31063:     if (traceVisScriptTable)
31063:         JS_HashTableDestroy(traceVisScriptTable);
31063: 
54568:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
54568:     return true;
31063: }
31063: 
31063: #endif /* MOZ_TRACEVIS */
