    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * Base class for all our document implementations.
    1:  */
    1: 
    1: #ifndef nsDocument_h___
    1: #define nsDocument_h___
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsCRT.h"
    1: #include "nsIDocument.h"
    1: #include "nsWeakReference.h"
    1: #include "nsWeakPtr.h"
    1: #include "nsVoidArray.h"
26413: #include "nsTArray.h"
    1: #include "nsHashSets.h"
    1: #include "nsIDOMXMLDocument.h"
    1: #include "nsIDOM3Document.h"
    1: #include "nsIDOMDocumentView.h"
    1: #include "nsIDOMDocumentXBL.h"
    1: #include "nsIDOMNSDocument.h"
    1: #include "nsIDOMNSDocumentStyle.h"
    1: #include "nsIDOMDocumentRange.h"
    1: #include "nsIDOMDocumentTraversal.h"
    1: #include "nsStubDocumentObserver.h"
    1: #include "nsIDOM3EventTarget.h"
    1: #include "nsIDOMNSEventTarget.h"
    1: #include "nsIDOMStyleSheetList.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIDOMEventTarget.h"
    1: #include "nsIContent.h"
    1: #include "nsIEventListenerManager.h"
    1: #include "nsIDOM3Node.h"
16106: #include "nsIDOMNodeSelector.h"
    1: #include "nsIPrincipal.h"
    1: #include "nsIParser.h"
    1: #include "nsBindingManager.h"
    1: #include "nsINodeInfo.h"
    1: #include "nsIDOMDocumentEvent.h"
    1: #include "nsIDOM3DocumentEvent.h"
    1: #include "nsHashtable.h"
    1: #include "nsInterfaceHashtable.h"
    1: #include "nsIBoxObject.h"
    1: #include "nsPIBoxObject.h"
    1: #include "nsIScriptObjectPrincipal.h"
    1: #include "nsIURI.h"
    1: #include "nsScriptLoader.h"
    1: #include "nsICSSLoader.h"
    1: #include "nsIRadioGroupContainer.h"
    1: #include "nsIScriptEventManager.h"
    1: #include "nsILayoutHistoryState.h"
    1: #include "nsIRequest.h"
    1: #include "nsILoadGroup.h"
    1: #include "nsTObserverArray.h"
    1: #include "nsStubMutationObserver.h"
    1: #include "nsIChannel.h"
    1: #include "nsCycleCollectionParticipant.h"
15474: #include "nsContentList.h"
16977: #include "nsGkAtoms.h"
18430: #include "nsIApplicationCache.h"
18430: #include "nsIApplicationCacheContainer.h"
    1: 
    1: // Put these here so all document impls get them automatically
    1: #include "nsHTMLStyleSheet.h"
36782: #include "nsHTMLCSSStyleSheet.h"
    1: 
    1: #include "nsStyleSet.h"
    1: #include "nsXMLEventsManager.h"
    1: #include "pldhash.h"
    1: #include "nsAttrAndChildArray.h"
    1: #include "nsDOMAttributeMap.h"
 1722: #include "nsPresShellIterator.h"
16056: #include "nsContentUtils.h"
16977: #include "nsThreadUtils.h"
20078: #include "nsIDocumentViewer.h"
29215: #include "nsIDOMXPathNSResolver.h"
20078: #include "nsIInterfaceRequestor.h"
21877: #include "nsILoadContext.h"
21877: #include "nsIProgressEventSink.h"
21877: #include "nsISecurityEventSink.h"
21877: #include "nsIChannelEventSink.h"
30065: #include "imgIRequest.h"
34007: #include "nsIDOMDOMImplementation.h"
    1: 
    1: #define XML_DECLARATION_BITS_DECLARATION_EXISTS   (1 << 0)
    1: #define XML_DECLARATION_BITS_ENCODING_EXISTS      (1 << 1)
    1: #define XML_DECLARATION_BITS_STANDALONE_EXISTS    (1 << 2)
    1: #define XML_DECLARATION_BITS_STANDALONE_YES       (1 << 3)
    1: 
    1: 
    1: class nsIEventListenerManager;
    1: class nsDOMStyleSheetList;
    1: class nsDOMStyleSheetSetList;
    1: class nsIOutputStream;
    1: class nsDocument;
    1: class nsIDTD;
    1: class nsIRadioVisitor;
    1: class nsIFormControl;
    1: struct nsRadioGroupStruct;
    1: class nsOnloadBlocker;
    1: class nsUnblockOnloadEvent;
    1: class nsChildContentList;
23697: #ifdef MOZ_SMIL
23697: class nsSMILAnimationController;
23697: #endif // MOZ_SMIL
    1: 
    1: /**
    1:  * Hashentry using a PRUint32 key and a cheap set of nsIContent* owning
    1:  * pointers for the value.
    1:  *
    1:  * @see nsTHashtable::EntryType for specification
    1:  */
    1: class nsUint32ToContentHashEntry : public PLDHashEntryHdr
    1: {
    1:   public:
    1:     typedef const PRUint32& KeyType;
    1:     typedef const PRUint32* KeyTypePointer;
    1: 
    1:     nsUint32ToContentHashEntry(const KeyTypePointer key) :
    1:       mValue(*key), mValOrHash(nsnull) { }
    1:     nsUint32ToContentHashEntry(const nsUint32ToContentHashEntry& toCopy) :
    1:       mValue(toCopy.mValue), mValOrHash(toCopy.mValOrHash)
    1:     {
    1:       // Pathetic attempt to not die: clear out the other mValOrHash so we're
    1:       // effectively stealing it. If toCopy is destroyed right after this,
    1:       // we'll be OK.
 3233:       const_cast<nsUint32ToContentHashEntry&>(toCopy).mValOrHash = nsnull;
    1:       NS_ERROR("Copying not supported. Fasten your seat belt.");
    1:     }
    1:     ~nsUint32ToContentHashEntry() { Destroy(); }
    1: 
    1:     KeyType GetKey() const { return mValue; }
    1: 
    1:     PRBool KeyEquals(KeyTypePointer aKey) const { return mValue == *aKey; }
    1: 
    1:     static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
    1:     static PLDHashNumber HashKey(KeyTypePointer aKey) { return *aKey; }
    1:     enum { ALLOW_MEMMOVE = PR_TRUE };
    1: 
    1:     // Content set methods
    1:     nsresult PutContent(nsIContent* aContent);
    1: 
    1:     void RemoveContent(nsIContent* aContent);
    1: 
    1:     struct Visitor {
    1:       virtual void Visit(nsIContent* aContent) = 0;
    1:     };
    1:     void VisitContent(Visitor* aVisitor);
    1: 
    1:     PRBool IsEmpty() { return mValOrHash == nsnull; }
    1: 
    1:   private:
27256:     typedef PRUptrdiff PtrBits;
    1:     typedef nsTHashtable<nsISupportsHashKey> HashSet;
    1:     /** Get the hash pointer (or null if we're not a hash) */
    1:     HashSet* GetHashSet()
    1:     {
    1:       return (PtrBits(mValOrHash) & 0x1) ? nsnull : (HashSet*)mValOrHash;
    1:     }
    1:     /** Find out whether it is an nsIContent (returns weak) */
    1:     nsIContent* GetContent()
    1:     {
    1:       return (PtrBits(mValOrHash) & 0x1)
    1:              ? (nsIContent*)(PtrBits(mValOrHash) & ~0x1)
    1:              : nsnull;
    1:     }
    1:     /** Set the single element, adding a reference */
    1:     nsresult SetContent(nsIContent* aVal)
    1:     {
    1:       NS_IF_ADDREF(aVal);
    1:       mValOrHash = (void*)(PtrBits(aVal) | 0x1);
    1:       return NS_OK;
    1:     }
    1:     /** Initialize the hash */
    1:     nsresult InitHashSet(HashSet** aSet);
    1: 
    1:     void Destroy();
    1: 
    1:   private:
    1:     const PRUint32 mValue;
    1:     /** A hash or nsIContent ptr, depending on the lower bit (0=hash, 1=ptr) */
    1:     void* mValOrHash;
    1: };
    1: 
15474: /**
15474:  * Right now our identifier map entries contain information for 'name'
15474:  * and 'id' mappings of a given string. This is so that
15474:  * nsHTMLDocument::ResolveName only has to do one hash lookup instead
15474:  * of two. It's not clear whether this still matters for performance.
15474:  * 
15474:  * We also store the document.all result list here. This is mainly so that
15474:  * when all elements with the given ID are removed and we remove
15474:  * the ID's nsIdentifierMapEntry, the document.all result is released too.
15474:  * Perhaps the document.all results should have their own hashtable
15474:  * in nsHTMLDocument.
15474:  */
15474: class nsIdentifierMapEntry : public nsISupportsHashKey
15474: {
15474: public:
15474:   nsIdentifierMapEntry(const nsISupports* aKey) :
15474:     nsISupportsHashKey(aKey), mNameContentList(nsnull)
15474:   {
15474:   }
15474:   nsIdentifierMapEntry(const nsIdentifierMapEntry& aOther) :
15474:     nsISupportsHashKey(GetKey())
15474:   {
15474:     NS_ERROR("Should never be called");
15474:   }
15474:   ~nsIdentifierMapEntry();
15474: 
15474:   void SetInvalidName();
15474:   PRBool IsInvalidName();
15474:   void AddNameContent(nsIContent* aContent);
15474:   void RemoveNameContent(nsIContent* aContent);
15474:   PRBool HasNameContentList() {
15474:     return mNameContentList != nsnull;
15474:   }
15474:   nsBaseContentList* GetNameContentList() {
15474:     return mNameContentList;
15474:   }
15474:   nsresult CreateNameContentList();
15474: 
15474:   /**
15474:    * Returns the element if we know the element associated with this
15474:    * id. Otherwise returns null.
15474:    */
26475:   nsIContent* GetIdContent();
26475:   /**
26475:    * Append all the elements with this id to aElements
26475:    */
15475:   void AppendAllIdContent(nsCOMArray<nsIContent>* aElements);
15515:   /**
15515:    * This can fire ID change callbacks.
15515:    * @return true if the content could be added, false if we failed due
15515:    * to OOM.
15515:    */
15474:   PRBool AddIdContent(nsIContent* aContent);
15475:   /**
15515:    * This can fire ID change callbacks.
15475:    * @return true if this map entry should be removed
15475:    */
15474:   PRBool RemoveIdContent(nsIContent* aContent);
15474: 
15515:   PRBool HasContentChangeCallback() { return mChangeCallbacks != nsnull; }
15515:   void AddContentChangeCallback(nsIDocument::IDTargetObserver aCallback, void* aData);
15515:   void RemoveContentChangeCallback(nsIDocument::IDTargetObserver aCallback, void* aData);
15515: 
15474:   void Traverse(nsCycleCollectionTraversalCallback* aCallback);
15474: 
15474:   void SetDocAllList(nsContentList* aContentList) { mDocAllList = aContentList; }
15474:   nsContentList* GetDocAllList() { return mDocAllList; }
15474: 
15515:   struct ChangeCallback {
15515:     nsIDocument::IDTargetObserver mCallback;
15515:     void* mData;
15515:   };
15515: 
15515:   struct ChangeCallbackEntry : public PLDHashEntryHdr {
15515:     typedef const ChangeCallback KeyType;
15515:     typedef const ChangeCallback* KeyTypePointer;
15515: 
15515:     ChangeCallbackEntry(const ChangeCallback* key) :
15515:       mKey(*key) { }
15515:     ChangeCallbackEntry(const ChangeCallbackEntry& toCopy) :
15515:       mKey(toCopy.mKey) { }
15515: 
15515:     KeyType GetKey() const { return mKey; }
15515:     PRBool KeyEquals(KeyTypePointer aKey) const {
15515:       return aKey->mCallback == mKey.mCallback &&
15515:              aKey->mData == mKey.mData;
15515:     }
15515: 
15515:     static KeyTypePointer KeyToPointer(KeyType& aKey) { return &aKey; }
15515:     static PLDHashNumber HashKey(KeyTypePointer aKey)
15515:     {
20340:       return (NS_PTR_TO_INT32(aKey->mCallback) >> 2) ^
20340:              (NS_PTR_TO_INT32(aKey->mData));
15515:     }
15515:     enum { ALLOW_MEMMOVE = PR_TRUE };
15515:     
15515:     ChangeCallback mKey;
15515:   };
15515: 
15474: private:
15515:   void FireChangeCallbacks(nsIContent* aOldContent, nsIContent* aNewContent);
15515: 
33810:   // empty if there are no nodes with this ID.
33810:   // The content nodes are stored addrefed.
15474:   nsSmallVoidArray mIdContentList;
15474:   // NAME_NOT_VALID if this id cannot be used as a 'name'
15474:   nsBaseContentList *mNameContentList;
15474:   nsRefPtr<nsContentList> mDocAllList;
15515:   nsAutoPtr<nsTHashtable<ChangeCallbackEntry> > mChangeCallbacks;
15474: };
    1: 
    1: class nsDocHeaderData
    1: {
    1: public:
    1:   nsDocHeaderData(nsIAtom* aField, const nsAString& aData)
    1:     : mField(aField), mData(aData), mNext(nsnull)
    1:   {
    1:   }
    1: 
    1:   ~nsDocHeaderData(void)
    1:   {
    1:     delete mNext;
    1:   }
    1: 
    1:   nsCOMPtr<nsIAtom> mField;
    1:   nsString          mData;
    1:   nsDocHeaderData*  mNext;
    1: };
    1: 
    1: class nsDOMStyleSheetList : public nsIDOMStyleSheetList,
    1:                             public nsStubDocumentObserver
    1: {
    1: public:
    1:   nsDOMStyleSheetList(nsIDocument *aDocument);
    1:   virtual ~nsDOMStyleSheetList();
    1: 
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   NS_DECL_NSIDOMSTYLESHEETLIST
    1: 
    1:   // nsIDocumentObserver
    1:   virtual void NodeWillBeDestroyed(const nsINode *aNode);
    1:   virtual void StyleSheetAdded(nsIDocument *aDocument,
    1:                                nsIStyleSheet* aStyleSheet,
    1:                                PRBool aDocumentSheet);
    1:   virtual void StyleSheetRemoved(nsIDocument *aDocument,
    1:                                  nsIStyleSheet* aStyleSheet,
    1:                                  PRBool aDocumentSheet);
    1: 
20752:   nsIStyleSheet* GetItemAt(PRUint32 aIndex);
20752: 
20752:   static nsDOMStyleSheetList* FromSupports(nsISupports* aSupports)
20752:   {
20752:     nsIDOMStyleSheetList* list = static_cast<nsIDOMStyleSheetList*>(aSupports);
20752: #ifdef DEBUG
20752:     {
20752:       nsCOMPtr<nsIDOMStyleSheetList> list_qi = do_QueryInterface(aSupports);
20752: 
20752:       // If this assertion fires the QI implementation for the object in
20752:       // question doesn't use the nsIDOMStyleSheetList pointer as the
20752:       // nsISupports pointer. That must be fixed, or we'll crash...
20752:       NS_ASSERTION(list_qi == list, "Uh, fix QI!");
20752:     }
20752: #endif
20752:     return static_cast<nsDOMStyleSheetList*>(list);
20752:   }
20752: 
    1: protected:
    1:   PRInt32       mLength;
    1:   nsIDocument*  mDocument;
    1: };
    1: 
    1: class nsOnloadBlocker : public nsIRequest
    1: {
    1: public:
    1:   nsOnloadBlocker() {}
    1: 
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSIREQUEST
    1: 
    1: private:
    1:   ~nsOnloadBlocker() {}
    1: };
    1: 
20078: class nsExternalResourceMap
20078: {
20078: public:
20078:   typedef nsIDocument::ExternalResourceLoad ExternalResourceLoad;
20078:   nsExternalResourceMap();
20078: 
20078:   /**
20078:    * Request an external resource document.  This does exactly what
20078:    * nsIDocument::RequestExternalResource is documented to do.
20078:    */
20078:   nsIDocument* RequestResource(nsIURI* aURI,
20078:                                nsINode* aRequestingNode,
20078:                                nsDocument* aDisplayDocument,
20078:                                ExternalResourceLoad** aPendingLoad);
20078: 
20078:   /**
20078:    * Enumerate the resource documents.  See
20078:    * nsIDocument::EnumerateExternalResources.
20078:    */
20078:   void EnumerateResources(nsIDocument::nsSubDocEnumFunc aCallback, void* aData);
20078: 
20078:   /**
20078:    * Traverse ourselves for cycle-collection
20078:    */
20078:   void Traverse(nsCycleCollectionTraversalCallback* aCallback) const;
20078: 
20078:   /**
20078:    * Shut ourselves down (used for cycle-collection unlink), as well
20078:    * as for document destruction.
20078:    */
20078:   void Shutdown()
20078:   {
20078:     mPendingLoads.Clear();
20078:     mMap.Clear();
20078:     mHaveShutDown = PR_TRUE;
20078:   }
20078: 
20078:   PRBool HaveShutDown() const
20078:   {
20078:     return mHaveShutDown;
20078:   }
20078: 
20078:   // Needs to be public so we can traverse them sanely
20078:   struct ExternalResource
20078:   {
20078:     ~ExternalResource();
20078:     nsCOMPtr<nsIDocument> mDocument;
20078:     nsCOMPtr<nsIContentViewer> mViewer;
20078:     nsCOMPtr<nsILoadGroup> mLoadGroup;
20078:   };
20078: 
20078: protected:
20078:   class PendingLoad : public ExternalResourceLoad,
20078:                       public nsIStreamListener
20078:   {
20078:   public:
20078:     PendingLoad(nsDocument* aDisplayDocument) :
20078:       mDisplayDocument(aDisplayDocument)
20078:     {}
20078: 
20078:     NS_DECL_ISUPPORTS
20078:     NS_DECL_NSISTREAMLISTENER
20078:     NS_DECL_NSIREQUESTOBSERVER
20078: 
20078:     /**
20078:      * Start aURI loading.  This will perform the necessary security checks and
20078:      * so forth.
20078:      */
20078:     nsresult StartLoad(nsIURI* aURI, nsINode* aRequestingNode);
20078: 
20078:     /**
20078:      * Set up an nsIDocumentViewer based on aRequest.  This is guaranteed to
20078:      * put null in *aViewer and *aLoadGroup on all failures.
20078:      */
20078:     nsresult SetupViewer(nsIRequest* aRequest, nsIDocumentViewer** aViewer,
20078:                          nsILoadGroup** aLoadGroup);
20078: 
20078:   private:
20078:     nsRefPtr<nsDocument> mDisplayDocument;
20078:     nsCOMPtr<nsIStreamListener> mTargetListener;
20078:     nsCOMPtr<nsIURI> mURI;
20078:   };
20078:   friend class PendingLoad;
20078: 
20078:   class LoadgroupCallbacks : public nsIInterfaceRequestor
20078:   {
20078:   public:
20078:     LoadgroupCallbacks(nsIInterfaceRequestor* aOtherCallbacks)
20078:       : mCallbacks(aOtherCallbacks)
20078:     {}
20078:     NS_DECL_ISUPPORTS
20078:     NS_DECL_NSIINTERFACEREQUESTOR
20078:   private:
21877:     // The only reason it's safe to hold a strong ref here without leaking is
21877:     // that the notificationCallbacks on a loadgroup aren't the docshell itself
21877:     // but a shim that holds a weak reference to the docshell.
20078:     nsCOMPtr<nsIInterfaceRequestor> mCallbacks;
21877: 
21877:     // Use shims for interfaces that docshell implements directly so that we
21877:     // don't hand out references to the docshell.  The shims should all allow
21877:     // getInterface back on us, but other than that each one should only
21877:     // implement one interface.
21877:     
21877:     // XXXbz I wish we could just derive the _allcaps thing from _i
21877: #define DECL_SHIM(_i, _allcaps)                                              \
21877:     class _i##Shim : public nsIInterfaceRequestor,                           \
21877:                      public _i                                               \
21877:     {                                                                        \
21877:     public:                                                                  \
21877:       _i##Shim(nsIInterfaceRequestor* aIfreq, _i* aRealPtr)                  \
21877:         : mIfReq(aIfreq), mRealPtr(aRealPtr)                                 \
21877:       {                                                                      \
21877:         NS_ASSERTION(mIfReq, "Expected non-null here");                      \
21877:         NS_ASSERTION(mRealPtr, "Expected non-null here");                    \
21877:       }                                                                      \
21877:       NS_DECL_ISUPPORTS                                                      \
21877:       NS_FORWARD_NSIINTERFACEREQUESTOR(mIfReq->);                            \
21877:       NS_FORWARD_##_allcaps(mRealPtr->);                                     \
21877:     private:                                                                 \
21877:       nsCOMPtr<nsIInterfaceRequestor> mIfReq;                                \
21877:       nsCOMPtr<_i> mRealPtr;                                                 \
21877:     };
21877: 
21877:     DECL_SHIM(nsILoadContext, NSILOADCONTEXT)
21877:     DECL_SHIM(nsIProgressEventSink, NSIPROGRESSEVENTSINK)
21877:     DECL_SHIM(nsIChannelEventSink, NSICHANNELEVENTSINK)
21877:     DECL_SHIM(nsISecurityEventSink, NSISECURITYEVENTSINK)
21877:     DECL_SHIM(nsIApplicationCacheContainer, NSIAPPLICATIONCACHECONTAINER)
21877: #undef DECL_SHIM
20078:   };
20078:   
20078:   /**
20078:    * Add an ExternalResource for aURI.  aViewer and aLoadGroup might be null
20078:    * when this is called if the URI didn't result in an XML document.  This
20078:    * function makes sure to remove the pending load for aURI, if any, from our
20078:    * hashtable, and to notify its observers, if any.
20078:    */
20078:   nsresult AddExternalResource(nsIURI* aURI, nsIDocumentViewer* aViewer,
20078:                                nsILoadGroup* aLoadGroup,
20078:                                nsIDocument* aDisplayDocument);
20078:   
20078:   nsClassHashtable<nsURIHashKey, ExternalResource> mMap;
20078:   nsRefPtrHashtable<nsURIHashKey, PendingLoad> mPendingLoads;
20078:   PRPackedBool mHaveShutDown;
20078: };
20078: 
    1: // Base class for our document implementations.
    1: //
    1: // Note that this class *implements* nsIDOMXMLDocument, but it's not
    1: // really an nsIDOMXMLDocument. The reason for implementing
    1: // nsIDOMXMLDocument on this class is to avoid having to duplicate all
    1: // its inherited methods on document classes that *are*
    1: // nsIDOMXMLDocument's. nsDocument's QI should *not* claim to support
    1: // nsIDOMXMLDocument unless someone writes a real implementation of
    1: // the interface.
    1: class nsDocument : public nsIDocument,
    1:                    public nsIDOMXMLDocument, // inherits nsIDOMDocument
    1:                    public nsIDOMNSDocument,
    1:                    public nsIDOMDocumentEvent,
    1:                    public nsIDOM3DocumentEvent,
    1:                    public nsIDOMNSDocumentStyle,
    1:                    public nsIDOMDocumentView,
    1:                    public nsIDOMDocumentRange,
    1:                    public nsIDOMDocumentTraversal,
    1:                    public nsIDOMDocumentXBL,
    1:                    public nsIDOM3Document,
    1:                    public nsSupportsWeakReference,
 1418:                    public nsIDOMEventTarget,
    1:                    public nsIDOM3EventTarget,
    1:                    public nsIDOMNSEventTarget,
    1:                    public nsIScriptObjectPrincipal,
    1:                    public nsIRadioGroupContainer,
16106:                    public nsIDOMNodeSelector,
18430:                    public nsIApplicationCacheContainer,
29215:                    public nsIDOMXPathNSResolver,
    1:                    public nsStubMutationObserver
    1: {
    1: public:
    1:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
    1: 
    1:   virtual void Reset(nsIChannel *aChannel, nsILoadGroup *aLoadGroup);
    1:   virtual void ResetToURI(nsIURI *aURI, nsILoadGroup *aLoadGroup,
    1:                           nsIPrincipal* aPrincipal);
    1: 
    1:   // StartDocumentLoad is pure virtual so that subclasses must override it.
    1:   // The nsDocument StartDocumentLoad does some setup, but does NOT set
    1:   // *aDocListener; this is the job of subclasses.
    1:   virtual nsresult StartDocumentLoad(const char* aCommand,
    1:                                      nsIChannel* aChannel,
    1:                                      nsILoadGroup* aLoadGroup,
    1:                                      nsISupports* aContainer,
    1:                                      nsIStreamListener **aDocListener,
    1:                                      PRBool aReset = PR_TRUE,
    1:                                      nsIContentSink* aContentSink = nsnull) = 0;
    1: 
    1:   virtual void StopDocumentLoad();
    1: 
16977:   virtual void NotifyPossibleTitleChange(PRBool aBoundTitleElement);
16977: 
    1:   virtual void SetDocumentURI(nsIURI* aURI);
    1:   
    1:   /**
    1:    * Set the principal responsible for this document.
    1:    */
    1:   virtual void SetPrincipal(nsIPrincipal *aPrincipal);
    1: 
    1:   /**
    1:    * Get the Content-Type of this document.
    1:    */
    1:   // NS_IMETHOD GetContentType(nsAString& aContentType);
    1:   // Already declared in nsIDOMNSDocument
    1: 
    1:   /**
    1:    * Set the Content-Type of this document.
    1:    */
    1:   virtual void SetContentType(const nsAString& aContentType);
    1: 
    1:   virtual nsresult SetBaseURI(nsIURI* aURI);
    1: 
    1:   /**
    1:    * Get/Set the base target of a link in a document.
    1:    */
    1:   virtual void GetBaseTarget(nsAString &aBaseTarget) const;
    1:   virtual void SetBaseTarget(const nsAString &aBaseTarget);
    1: 
    1:   /**
    1:    * Return a standard name for the document's character set. This will
    1:    * trigger a startDocumentLoad if necessary to answer the question.
    1:    */
    1:   virtual void SetDocumentCharacterSet(const nsACString& aCharSetID);
    1: 
    1:   /**
    1:    * Add an observer that gets notified whenever the charset changes.
    1:    */
    1:   virtual nsresult AddCharSetObserver(nsIObserver* aObserver);
    1: 
    1:   /**
    1:    * Remove a charset observer.
    1:    */
    1:   virtual void RemoveCharSetObserver(nsIObserver* aObserver);
    1: 
15515:   virtual nsIContent* AddIDTargetObserver(nsIAtom* aID,
15515:                                           IDTargetObserver aObserver, void* aData);
15515:   virtual void RemoveIDTargetObserver(nsIAtom* aID,
15515:                                       IDTargetObserver aObserver, void* aData);
15515: 
    1:   /**
    1:    * Access HTTP header data (this may also get set from other sources, like
    1:    * HTML META tags).
    1:    */
    1:   virtual void GetHeaderData(nsIAtom* aHeaderField, nsAString& aData) const;
    1:   virtual void SetHeaderData(nsIAtom* aheaderField,
    1:                              const nsAString& aData);
    1: 
    1:   /**
    1:    * Create a new presentation shell that will use aContext for
24112:    * its presentation context (presentation context's <b>must not</b> be
    1:    * shared among multiple presentation shell's).
    1:    */
    1:   virtual nsresult CreateShell(nsPresContext* aContext,
    1:                                nsIViewManager* aViewManager,
    1:                                nsStyleSet* aStyleSet,
    1:                                nsIPresShell** aInstancePtrResult);
    1:   virtual PRBool DeleteShell(nsIPresShell* aShell);
  981:   virtual nsIPresShell *GetPrimaryShell() const;
    1: 
    1:   virtual nsresult SetSubDocumentFor(nsIContent *aContent,
    1:                                      nsIDocument* aSubDoc);
    1:   virtual nsIDocument* GetSubDocumentFor(nsIContent *aContent) const;
    1:   virtual nsIContent* FindContentForSubDocument(nsIDocument *aDocument) const;
 8938:   virtual nsIContent* GetRootContentInternal() const;
    1: 
    1:   /**
    1:    * Get the style sheets owned by this document.
    1:    * These are ordered, highest priority last
    1:    */
    1:   virtual PRInt32 GetNumberOfStyleSheets() const;
    1:   virtual nsIStyleSheet* GetStyleSheetAt(PRInt32 aIndex) const;
    1:   virtual PRInt32 GetIndexOfStyleSheet(nsIStyleSheet* aSheet) const;
    1:   virtual void AddStyleSheet(nsIStyleSheet* aSheet);
    1:   virtual void RemoveStyleSheet(nsIStyleSheet* aSheet);
    1: 
    1:   virtual void UpdateStyleSheets(nsCOMArray<nsIStyleSheet>& aOldSheets,
    1:                                  nsCOMArray<nsIStyleSheet>& aNewSheets);
    1:   virtual void AddStyleSheetToStyleSets(nsIStyleSheet* aSheet);
    1:   virtual void RemoveStyleSheetFromStyleSets(nsIStyleSheet* aSheet);
    1: 
    1:   virtual void InsertStyleSheetAt(nsIStyleSheet* aSheet, PRInt32 aIndex);
    1:   virtual void SetStyleSheetApplicableState(nsIStyleSheet* aSheet,
    1:                                             PRBool aApplicable);
    1: 
    1:   virtual PRInt32 GetNumberOfCatalogStyleSheets() const;
    1:   virtual nsIStyleSheet* GetCatalogStyleSheetAt(PRInt32 aIndex) const;
    1:   virtual void AddCatalogStyleSheet(nsIStyleSheet* aSheet);
    1:   virtual void EnsureCatalogStyleSheet(const char *aStyleSheetURI);
    1: 
    1:   virtual nsIChannel* GetChannel() const {
    1:     return mChannel;
    1:   }
    1: 
    1:   /**
    1:    * Get this document's attribute stylesheet.  May return null if
    1:    * there isn't one.
    1:    */
    1:   virtual nsHTMLStyleSheet* GetAttributeStyleSheet() const {
    1:     return mAttrStyleSheet;
    1:   }
    1: 
    1:   /**
    1:    * Get this document's inline style sheet.  May return null if there
    1:    * isn't one
    1:    */
36782:   virtual nsHTMLCSSStyleSheet* GetInlineStyleSheet() const {
    1:     return mStyleAttrStyleSheet;
    1:   }
    1:   
    1:   /**
    1:    * Set the object from which a document can get a script context.
    1:    * This is the context within which all scripts (during document
    1:    * creation and during event handling) will run.
    1:    */
    1:   virtual nsIScriptGlobalObject* GetScriptGlobalObject() const;
    1:   virtual void SetScriptGlobalObject(nsIScriptGlobalObject* aGlobalObject);
    1: 
 6475:   virtual nsIScriptGlobalObject*
 6475:     GetScriptHandlingObject(PRBool& aHasHadScriptHandlingObject) const;
 6475:   virtual void SetScriptHandlingObject(nsIScriptGlobalObject* aScriptObject);
 6475: 
    1:   virtual nsIScriptGlobalObject* GetScopeObject();
    1: 
    1:   /**
    1:    * Return the window containing the document (the outer window).
    1:    */
    1:   virtual nsPIDOMWindow *GetWindow();
    1: 
    1:   /**
    1:    * Return the inner window used as the script compilation scope for
    1:    * this document. If you're not absolutely sure you need this, use
    1:    * GetWindow().
    1:    */
    1:   virtual nsPIDOMWindow *GetInnerWindow();
    1: 
    1:   /**
    1:    * Get the script loader for this document
    1:    */
 2007:   virtual nsScriptLoader* ScriptLoader();
    1: 
    1:   /**
    1:    * Add a new observer of document change notifications. Whenever
    1:    * content is changed, appended, inserted or removed the observers are
    1:    * informed.
    1:    */
    1:   virtual void AddObserver(nsIDocumentObserver* aObserver);
    1: 
    1:   /**
    1:    * Remove an observer of document change notifications. This will
    1:    * return false if the observer cannot be found.
    1:    */
    1:   virtual PRBool RemoveObserver(nsIDocumentObserver* aObserver);
    1: 
    1:   // Observation hooks used to propagate notifications to document
    1:   // observers.
    1:   virtual void BeginUpdate(nsUpdateType aUpdateType);
    1:   virtual void EndUpdate(nsUpdateType aUpdateType);
    1:   virtual void BeginLoad();
    1:   virtual void EndLoad();
23639: 
23639:   virtual void SetReadyStateInternal(ReadyState rs);
29975:   virtual ReadyState GetReadyStateEnum();
23639: 
    1:   virtual void ContentStatesChanged(nsIContent* aContent1,
    1:                                     nsIContent* aContent2,
    1:                                     PRInt32 aStateMask);
    1: 
    1:   virtual void StyleRuleChanged(nsIStyleSheet* aStyleSheet,
    1:                                 nsIStyleRule* aOldStyleRule,
    1:                                 nsIStyleRule* aNewStyleRule);
    1:   virtual void StyleRuleAdded(nsIStyleSheet* aStyleSheet,
    1:                               nsIStyleRule* aStyleRule);
    1:   virtual void StyleRuleRemoved(nsIStyleSheet* aStyleSheet,
    1:                                 nsIStyleRule* aStyleRule);
    1: 
    1:   virtual void FlushPendingNotifications(mozFlushType aType);
    1:   virtual nsIScriptEventManager* GetScriptEventManager();
    1:   virtual void SetXMLDeclaration(const PRUnichar *aVersion,
    1:                                  const PRUnichar *aEncoding,
    1:                                  const PRInt32 aStandalone);
    1:   virtual void GetXMLDeclaration(nsAString& aVersion,
    1:                                  nsAString& aEncoding,
    1:                                  nsAString& Standalone);
    1:   virtual PRBool IsScriptEnabled();
    1: 
25572:   virtual void OnPageShow(PRBool aPersisted, nsIDOMEventTarget* aDispatchStartTarget);
25572:   virtual void OnPageHide(PRBool aPersisted, nsIDOMEventTarget* aDispatchStartTarget);
    1:   
   62:   virtual void WillDispatchMutationEvent(nsINode* aTarget);
   62:   virtual void MutationEventDispatched(nsINode* aTarget);
   62: 
    1:   // nsINode
    1:   virtual PRBool IsNodeOfType(PRUint32 aFlags) const;
    1:   virtual nsIContent *GetChildAt(PRUint32 aIndex) const;
22251:   virtual nsIContent * const * GetChildArray(PRUint32* aChildCount) const;
    1:   virtual PRInt32 IndexOf(nsINode* aPossibleChild) const;
    1:   virtual PRUint32 GetChildCount() const;
    1:   virtual nsresult InsertChildAt(nsIContent* aKid, PRUint32 aIndex,
    1:                                  PRBool aNotify);
    1:   virtual nsresult AppendChildTo(nsIContent* aKid, PRBool aNotify);
29805:   virtual nsresult RemoveChildAt(PRUint32 aIndex, PRBool aNotify, PRBool aMutationEvent = PR_TRUE);
    1:   virtual nsresult PreHandleEvent(nsEventChainPreVisitor& aVisitor);
    1:   virtual nsresult PostHandleEvent(nsEventChainPostVisitor& aVisitor);
    1:   virtual nsresult DispatchDOMEvent(nsEvent* aEvent, nsIDOMEvent* aDOMEvent,
    1:                                     nsPresContext* aPresContext,
    1:                                     nsEventStatus* aEventStatus);
29474:   virtual nsIEventListenerManager* GetListenerManager(PRBool aCreateIfNotFound);
 1418:   virtual nsresult AddEventListenerByIID(nsIDOMEventListener *aListener,
 1418:                                          const nsIID& aIID);
 1418:   virtual nsresult RemoveEventListenerByIID(nsIDOMEventListener *aListener,
 1418:                                             const nsIID& aIID);
 1418:   virtual nsresult GetSystemEventGroup(nsIDOMEventGroup** aGroup);
27700:   virtual nsIScriptContext* GetContextForEventHandlers(nsresult* aRv)
16056:   {
27700:     return nsContentUtils::GetContextForEventHandlers(this, aRv);
16056:   }
    1:   virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const
    1:   {
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1:   }
    1: 
    1:   // nsIRadioGroupContainer
    1:   NS_IMETHOD WalkRadioGroup(const nsAString& aName,
    1:                             nsIRadioVisitor* aVisitor,
    1:                             PRBool aFlushContent);
    1:   NS_IMETHOD SetCurrentRadioButton(const nsAString& aName,
    1:                                    nsIDOMHTMLInputElement* aRadio);
    1:   NS_IMETHOD GetCurrentRadioButton(const nsAString& aName,
    1:                                    nsIDOMHTMLInputElement** aRadio);
    1:   NS_IMETHOD GetPositionInGroup(nsIDOMHTMLInputElement *aRadio,
    1:                                 PRInt32 *aPositionIndex,
    1:                                 PRInt32 *aItemsInGroup);
    1:   NS_IMETHOD GetNextRadioButton(const nsAString& aName,
    1:                                 const PRBool aPrevious,
    1:                                 nsIDOMHTMLInputElement*  aFocusedRadio,
    1:                                 nsIDOMHTMLInputElement** aRadioOut);
    1:   NS_IMETHOD AddToRadioGroup(const nsAString& aName,
    1:                              nsIFormControl* aRadio);
    1:   NS_IMETHOD RemoveFromRadioGroup(const nsAString& aName,
    1:                                   nsIFormControl* aRadio);
    1: 
    1:   // for radio group
    1:   nsresult GetRadioGroup(const nsAString& aName,
    1:                          nsRadioGroupStruct **aRadioGroup);
    1: 
    1:   // nsIDOMNode
    1:   NS_DECL_NSIDOMNODE
    1: 
    1:   // nsIDOM3Node
    1:   NS_DECL_NSIDOM3NODE
    1: 
    1:   // nsIDOMDocument
    1:   NS_DECL_NSIDOMDOCUMENT
    1: 
    1:   // nsIDOM3Document
    1:   NS_DECL_NSIDOM3DOCUMENT
    1: 
    1:   // nsIDOMXMLDocument
    1:   NS_DECL_NSIDOMXMLDOCUMENT
    1: 
    1:   // nsIDOMNSDocument
    1:   NS_DECL_NSIDOMNSDOCUMENT
    1: 
    1:   // nsIDOMDocumentEvent
    1:   NS_DECL_NSIDOMDOCUMENTEVENT
    1: 
    1:   // nsIDOM3DocumentEvent
    1:   NS_DECL_NSIDOM3DOCUMENTEVENT
    1: 
    1:   // nsIDOMDocumentStyle
    1:   NS_DECL_NSIDOMDOCUMENTSTYLE
    1: 
    1:   // nsIDOMNSDocumentStyle
    1:   NS_DECL_NSIDOMNSDOCUMENTSTYLE
    1: 
    1:   // nsIDOMDocumentView
    1:   NS_DECL_NSIDOMDOCUMENTVIEW
    1: 
    1:   // nsIDOMDocumentRange
    1:   NS_DECL_NSIDOMDOCUMENTRANGE
    1: 
    1:   // nsIDOMDocumentTraversal
    1:   NS_DECL_NSIDOMDOCUMENTTRAVERSAL
    1: 
    1:   // nsIDOMDocumentXBL
    1:   NS_DECL_NSIDOMDOCUMENTXBL
    1: 
    1:   // nsIDOMEventTarget
    1:   NS_DECL_NSIDOMEVENTTARGET
    1: 
    1:   // nsIDOM3EventTarget
    1:   NS_DECL_NSIDOM3EVENTTARGET
    1: 
    1:   // nsIDOMNSEventTarget
    1:   NS_DECL_NSIDOMNSEVENTTARGET
    1: 
16106:   // nsIDOMNodeSelector
16106:   NS_DECL_NSIDOMNODESELECTOR
16106: 
15474:   // nsIMutationObserver
15474:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
15474:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
15474:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
15474:   NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTECHANGED
29833:   NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTEWILLCHANGE
15474: 
    1:   // nsIScriptObjectPrincipal
    1:   virtual nsIPrincipal* GetPrincipal();
    1: 
18430:   // nsIApplicationCacheContainer
18430:   NS_DECL_NSIAPPLICATIONCACHECONTAINER
18430: 
    1:   virtual nsresult Init();
    1:   
    1:   virtual nsresult AddXMLEventsContent(nsIContent * aXMLEventsElement);
    1: 
    1:   virtual nsresult CreateElem(nsIAtom *aName, nsIAtom *aPrefix,
    1:                               PRInt32 aNamespaceID,
    1:                               PRBool aDocumentDefaultType,
    1:                               nsIContent **aResult);
    1: 
    1:   virtual NS_HIDDEN_(nsresult) Sanitize();
    1: 
    1:   virtual NS_HIDDEN_(void) EnumerateSubDocuments(nsSubDocEnumFunc aCallback,
    1:                                                  void *aData);
    1: 
    1:   virtual NS_HIDDEN_(PRBool) CanSavePresentation(nsIRequest *aNewRequest);
    1:   virtual NS_HIDDEN_(void) Destroy();
14469:   virtual NS_HIDDEN_(void) RemovedFromDocShell();
    1:   virtual NS_HIDDEN_(already_AddRefed<nsILayoutHistoryState>) GetLayoutHistoryState() const;
    1: 
    1:   virtual NS_HIDDEN_(void) BlockOnload();
    1:   virtual NS_HIDDEN_(void) UnblockOnload(PRBool aFireSync);
    1: 
    1:   virtual NS_HIDDEN_(void) AddStyleRelevantLink(nsIContent* aContent, nsIURI* aURI);
    1:   virtual NS_HIDDEN_(void) ForgetLink(nsIContent* aContent);
    1:   virtual NS_HIDDEN_(void) NotifyURIVisitednessChanged(nsIURI* aURI);
    1: 
    1:   NS_HIDDEN_(void) ClearBoxObjectFor(nsIContent* aContent);
26701:   NS_IMETHOD GetBoxObjectFor(nsIDOMElement* aElement, nsIBoxObject** aResult);
    1: 
    1:   virtual NS_HIDDEN_(nsresult) GetXBLChildNodesFor(nsIContent* aContent,
    1:                                                    nsIDOMNodeList** aResult);
    1:   virtual NS_HIDDEN_(nsresult) GetContentListFor(nsIContent* aContent,
    1:                                                  nsIDOMNodeList** aResult);
21333: 
21333:   virtual NS_HIDDEN_(nsresult) ElementFromPointHelper(PRInt32 aX, PRInt32 aY,
21333:                                                       PRBool aIgnoreRootScrollFrame,
21333:                                                       PRBool aFlushLayout,
21333:                                                       nsIDOMElement** aReturn);
21333: 
    1:   virtual NS_HIDDEN_(void) FlushSkinBindings();
    1: 
13433:   virtual NS_HIDDEN_(nsresult) InitializeFrameLoader(nsFrameLoader* aLoader);
12256:   virtual NS_HIDDEN_(nsresult) FinalizeFrameLoader(nsFrameLoader* aLoader);
14660:   virtual NS_HIDDEN_(void) TryCancelFrameLoaderInitialization(nsIDocShell* aShell);
14757:   virtual NS_HIDDEN_(PRBool) FrameLoaderScheduledToBeFinalized(nsIDocShell* aShell);
20078:   virtual NS_HIDDEN_(nsIDocument*)
20078:     RequestExternalResource(nsIURI* aURI,
20078:                             nsINode* aRequestingNode,
20078:                             ExternalResourceLoad** aPendingLoad);
20078:   virtual NS_HIDDEN_(void)
20078:     EnumerateExternalResources(nsSubDocEnumFunc aCallback, void* aData);
12256: 
23697: #ifdef MOZ_SMIL
23697:   nsSMILAnimationController* GetAnimationController();
23697: #endif // MOZ_SMIL
23697: 
25722:   virtual void SuppressEventHandling(PRUint32 aIncrease);
25722: 
25722:   virtual void UnsuppressEventHandlingAndFireEvents(PRBool aFireEvents);
25722:   
25722:   void DecreaseEventSuppression() { --mEventsSuppressed; }
25722: 
30001:   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS(nsDocument,
30001:                                                          nsIDocument)
    1: 
    1:   /**
 6158:    * Utility method for getElementsByClassName.  aRootNode is the node (either
 6158:    * document or element), which getElementsByClassName was called on.
    1:    */
 6158:   static nsresult GetElementsByClassNameHelper(nsINode* aRootNode,
    1:                                                const nsAString& aClasses,
    1:                                                nsIDOMNodeList** aReturn);
16977: 
16977:   void DoNotifyPossibleTitleChange();
16977: 
20078:   nsExternalResourceMap& ExternalResourceMap()
20078:   {
20078:     return mExternalResourceMap;
20078:   }
20078: 
19384:   void SetLoadedAsData(PRBool aLoadedAsData) { mLoadedAsData = aLoadedAsData; }
19384: 
19384:   nsresult CloneDocHelper(nsDocument* clone) const;
19384: 
24482:   void MaybeInitializeFinalizeFrameLoaders();
24482: 
24482:   void MaybeEndOutermostXBLUpdate();
30065: 
30065:   virtual void MaybePreLoadImage(nsIURI* uri);
34394: 
34394:   virtual nsISupports* GetCurrentContentSink();
34394: 
    1: protected:
32360:   friend class nsNodeUtils;
15474:   void RegisterNamedItems(nsIContent *aContent);
15474:   void UnregisterNamedItems(nsIContent *aContent);
15474:   void UpdateNameTableEntry(nsIContent *aContent);
15474:   void UpdateIdTableEntry(nsIContent *aContent);
15474:   void RemoveFromNameTable(nsIContent *aContent);
15474:   void RemoveFromIdTable(nsIContent *aContent);
15474: 
    1:   /**
    1:    * Check that aId is not empty and log a message to the console
    1:    * service if it is.
    1:    * @returns PR_TRUE if aId looks correct, PR_FALSE otherwise.
    1:    */
15515:   static PRBool CheckGetElementByIdArg(const nsIAtom* aId);
15515:   nsIdentifierMapEntry* GetElementByIdInternal(nsIAtom* aID);
    1: 
24144:   void DispatchContentLoadedEvents();
24144: 
    1:   void RetrieveRelevantHeaders(nsIChannel *aChannel);
    1: 
    1:   static PRBool TryChannelCharset(nsIChannel *aChannel,
    1:                                   PRInt32& aCharsetSource,
    1:                                   nsACString& aCharset);
    1: 
    1:   void UpdateLinkMap();
    1:   // Call this before the document does something that will unbind all content.
    1:   // That will stop us from resolving URIs for all links as they are removed.
    1:   void DestroyLinkMap();
    1: 
33055:   // Refreshes the hrefs of all the links in the document.
33055:   void RefreshLinkHrefs();
33055: 
33055:   nsIContent* GetFirstBaseNodeWithHref();
33055:   nsresult SetFirstBaseNodeWithHref(nsIContent *node);
33055: 
16977:   // Get the root <html> element, or return null if there isn't one (e.g.
16977:   // if the root isn't <html>)
16977:   nsIContent* GetHtmlContent();
16977:   // Returns the first child of GetHtmlContent which has the given tag,
16977:   // or nsnull if that doesn't exist.
16977:   nsIContent* GetHtmlChildContent(nsIAtom* aTag);
16977:   // Get the canonical <body> element, or return null if there isn't one (e.g.
16977:   // if the root isn't <html> or if the <body> isn't there)
16977:   nsIContent* GetBodyContent() {
16977:     return GetHtmlChildContent(nsGkAtoms::body);
16977:   }
16977:   // Get the canonical <head> element, or return null if there isn't one (e.g.
16977:   // if the root isn't <html> or if the <head> isn't there)
16977:   nsIContent* GetHeadContent() {
16977:     return GetHtmlChildContent(nsGkAtoms::head);
16977:   }
31946: 
16977:   // Get the first <title> element with the given IsNodeOfType type, or
16977:   // return null if there isn't one
16977:   nsIContent* GetTitleContent(PRUint32 aNodeType);
16977:   // Find the first "title" element in the given IsNodeOfType type and
16977:   // append the concatenation of its text node children to aTitle. Do
16977:   // nothing if there is no such element.
16977:   void GetTitleFromElement(PRUint32 aNodeType, nsAString& aTitle);
16977: 
    1:   nsresult doCreateShell(nsPresContext* aContext,
    1:                          nsIViewManager* aViewManager, nsStyleSet* aStyleSet,
    1:                          nsCompatibility aCompatMode,
    1:                          nsIPresShell** aInstancePtrResult);
    1: 
    1:   nsresult ResetStylesheetsToURI(nsIURI* aURI);
    1:   virtual nsStyleSet::sheetType GetAttrSheetType();
    1:   void FillStyleSet(nsStyleSet* aStyleSet);
    1: 
    1:   // Return whether all the presshells for this document are safe to flush
    1:   PRBool IsSafeToFlush() const;
    1:   
    1:   virtual PRInt32 GetDefaultNamespaceID() const
    1:   {
    1:     return kNameSpaceID_None;
  731:   }
    1: 
29539:   void DispatchPageTransition(nsPIDOMEventTarget* aDispatchTarget,
29539:                               const nsAString& aType,
29539:                               PRBool aPersisted);
    1: 
    1:   // nsContentList match functions for GetElementsByClassName
    1:   static PRBool MatchClassNames(nsIContent* aContent, PRInt32 aNamespaceID,
    1:                                 nsIAtom* aAtom, void* aData);
    1: 
    1:   static void DestroyClassNameArray(void* aData);
    1: 
    1: #define NS_DOCUMENT_NOTIFY_OBSERVERS(func_, params_)                  \
    1:   NS_OBSERVER_ARRAY_NOTIFY_OBSERVERS(mObservers, nsIDocumentObserver, \
    1:                                      func_, params_);
    1:   
    1: #ifdef DEBUG
    1:   void VerifyRootContentState();
    1: #endif
    1: 
    1:   nsDocument(const char* aContentType);
    1:   virtual ~nsDocument();
    1: 
    1:   nsCString mReferrer;
    1:   nsString mLastModified;
    1: 
26413:   nsTArray<nsIObserver*> mCharSetObservers;
    1: 
    1:   PLDHashTable *mSubDocuments;
    1: 
    1:   // Array of owning references to all children
    1:   nsAttrAndChildArray mChildren;
    1: 
    1:   // Pointer to our parser if we're currently in the process of being
    1:   // parsed into.
    1:   nsCOMPtr<nsIParser> mParser;
    1: 
 6170:   // Weak reference to our sink for in case we no longer have a parser.  This
 6170:   // will allow us to flush out any pending stuff from the sink even if
 6170:   // EndLoad() has already happened.
 6170:   nsWeakPtr mWeakSink;
 6170: 
    1:   nsCOMArray<nsIStyleSheet> mStyleSheets;
    1:   nsCOMArray<nsIStyleSheet> mCatalogSheets;
    1: 
    1:   // Array of observers
 9536:   nsTObserverArray<nsIDocumentObserver*> mObservers;
    1: 
    1:   // The document's script global object, the object from which the
    1:   // document can get its script context and scope. This is the
    1:   // *inner* window object.
    1:   nsCOMPtr<nsIScriptGlobalObject> mScriptGlobalObject;
 9596:   // Weak reference to mScriptGlobalObject QI:d to nsPIDOMWindow,
 9596:   // updated on every set of mSecriptGlobalObject.
 9596:   nsPIDOMWindow *mWindow;
    1: 
 6475:   // If document is created for example using
 6475:   // document.implementation.createDocument(...), mScriptObject points to
 6475:   // the script global object of the original document.
 6475:   nsWeakPtr mScriptObject;
 6475: 
    1:   // Weak reference to the scope object (aka the script global object)
    1:   // that, unlike mScriptGlobalObject, is never unset once set. This
    1:   // is a weak reference to avoid leaks due to circular references.
    1:   nsWeakPtr mScopeObject;
    1: 
    1:   nsCOMPtr<nsIEventListenerManager> mListenerManager;
    1:   nsCOMPtr<nsIDOMStyleSheetList> mDOMStyleSheets;
    1:   nsRefPtr<nsDOMStyleSheetSetList> mStyleSheetSetList;
    1:   nsRefPtr<nsScriptLoader> mScriptLoader;
    1:   nsDocHeaderData* mHeaderData;
15474:   /* mIdentifierMap works as follows for IDs:
15474:    * 1) Attribute changes affect the table immediately (removing and adding
15474:    *    entries as needed).
15474:    * 2) Removals from the DOM affect the table immediately
26475:    * 3) Additions to the DOM always update existing entries for names, and add
26475:    *    new ones for IDs.
15474:    */
15474:   nsTHashtable<nsIdentifierMapEntry> mIdentifierMap;
    1: 
 6365:   nsClassHashtable<nsStringHashKey, nsRadioGroupStruct> mRadioGroups;
    1: 
    1:   // True if the document has been detached from its content viewer.
    1:   PRPackedBool mIsGoingAway:1;
    1:   // True if the document is being destroyed.
    1:   PRPackedBool mInDestructor:1;
 6475:   // True if document has ever had script handling object.
 6475:   PRPackedBool mHasHadScriptHandlingObject:1;
31946: 
16977:   // True if this document has ever had an HTML or SVG <title> element
16977:   // bound to it
16977:   PRPackedBool mMayHaveTitleElement:1;
    1: 
11731:   PRPackedBool mHasWarnedAboutBoxObjects:1;
11731: 
14464:   PRPackedBool mDelayFrameLoaderInitialization:1;
14464: 
24144:   PRPackedBool mSynchronousDOMContentLoaded:1;
24144: 
16447:   // If true, we have an input encoding.  If this is false, then the
16447:   // document was created entirely in memory
16447:   PRPackedBool mHaveInputEncoding:1;
16447: 
24482:   PRPackedBool mInXBLUpdate:1;
24482: 
36884:   // This flag is only set in nsXMLDocument, for e.g. documents used in XBL. We
36884:   // don't want animations to play in such documents, so we need to store the
36884:   // flag here so that we can check it in nsDocument::GetAnimationController.
36884:   PRPackedBool mLoadedAsInteractiveData:1;
36884: 
    1:   PRUint8 mXMLDeclarationBits;
    1: 
    1:   PRUint8 mDefaultElementType;
    1: 
11731:   nsInterfaceHashtable<nsVoidPtrHashKey, nsPIBoxObject> *mBoxObjectTable;
    1: 
    1:   // The channel that got passed to StartDocumentLoad(), if any
    1:   nsCOMPtr<nsIChannel> mChannel;
    1:   nsRefPtr<nsHTMLStyleSheet> mAttrStyleSheet;
36782:   nsRefPtr<nsHTMLCSSStyleSheet> mStyleAttrStyleSheet;
    1:   nsRefPtr<nsXMLEventsManager> mXMLEventsManager;
    1: 
    1:   nsCOMPtr<nsIScriptEventManager> mScriptEventManager;
    1: 
    1:   nsString mBaseTarget;
    1: 
 7199:   // Our update nesting level
 7199:   PRUint32 mUpdateNestLevel;
 7199: 
18430:   // The application cache that this document is associated with, if
18430:   // any.  This can change during the lifetime of the document.
18430:   nsCOMPtr<nsIApplicationCache> mApplicationCache;
18430: 
33055:   nsCOMPtr<nsIContent> mFirstBaseNodeWithHref;
33055: 
12033: private:
    1:   friend class nsUnblockOnloadEvent;
    1: 
    1:   void PostUnblockOnloadEvent();
    1:   void DoUnblockOnload();
    1: 
    1:   /**
    1:    * See if aDocument is a child of this.  If so, return the frame element in
    1:    * this document that holds currentDoc (or an ancestor).
    1:    */
    1:   already_AddRefed<nsIDOMElement>
    1:     CheckAncestryAndGetFrame(nsIDocument* aDocument) const;
    1: 
    1:   // Just like EnableStyleSheetsForSet, but doesn't check whether
    1:   // aSheetSet is null and allows the caller to control whether to set
    1:   // aSheetSet as the preferred set in the CSSLoader.
    1:   void EnableStyleSheetsForSetInternal(const nsAString& aSheetSet,
    1:                                        PRBool aUpdateCSSLoader);
    1: 
    1:   // These are not implemented and not supported.
    1:   nsDocument(const nsDocument& aOther);
    1:   nsDocument& operator=(const nsDocument& aOther);
    1: 
    1:   nsCOMPtr<nsISupports> mXPathEvaluatorTearoff;
    1: 
    1:   // The layout history state that should be used by nodes in this
    1:   // document.  We only actually store a pointer to it when:
    1:   // 1)  We have no script global object.
    1:   // 2)  We haven't had Destroy() called on us yet.
    1:   nsCOMPtr<nsILayoutHistoryState> mLayoutHistoryState;
    1: 
    1:   PRUint32 mOnloadBlockCount;
    1:   nsCOMPtr<nsIRequest> mOnloadBlocker;
23639:   ReadyState mReadyState;
    1:   
    1:   // A map from unvisited URI hashes to content elements
    1:   nsTHashtable<nsUint32ToContentHashEntry> mLinkMap;
    1:   // URIs whose visitedness has changed while we were hidden
    1:   nsCOMArray<nsIURI> mVisitednessChangedURIs;
    1: 
    1:   // Member to store out last-selected stylesheet set.
    1:   nsString mLastStyleSheetSet;
12256: 
13433:   nsTArray<nsRefPtr<nsFrameLoader> > mInitializableFrameLoaders;
12256:   nsTArray<nsRefPtr<nsFrameLoader> > mFinalizableFrameLoaders;
24482:   nsRefPtr<nsRunnableMethod<nsDocument> > mFrameLoaderRunner;
16977: 
28045:   nsRevocableEventPtr<nsNonOwningRunnableMethod<nsDocument> >
28045:     mPendingTitleChangeEvent;
20078: 
20078:   nsExternalResourceMap mExternalResourceMap;
23697: 
30065:   // All images in process of being preloaded
30065:   nsCOMArray<imgIRequest> mPreloadingImages;
30065: 
34007:   nsCOMPtr<nsIDOMDOMImplementation> mDOMImplementation;
34007: 
23697: #ifdef MOZ_SMIL
23697:   nsAutoPtr<nsSMILAnimationController> mAnimationController;
23697: #endif // MOZ_SMIL
31428: 
31428: #ifdef DEBUG
31428: protected:
31428:   PRBool mWillReparent;
31428: #endif
    1: };
    1: 
21218: #define NS_DOCUMENT_INTERFACE_TABLE_BEGIN(_class)                             \
21218:   NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                            \
21218:   NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMDocument, nsDocument)      \
21218:   NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMNSDocument, nsDocument)    \
21218:   NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMDocumentEvent, nsDocument) \
21218:   NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMDocumentView, nsDocument)  \
21218:   NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMDocumentTraversal,         \
21218:                                      nsDocument)                              \
21218:   NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMEventTarget, nsDocument)   \
21218:   NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMNode, nsDocument)          \
21218:   NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOM3Node, nsDocument)         \
21218:   NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOM3Document, nsDocument)
21218: 
    1: #endif /* nsDocument_h___ */
