    1: ; ***** BEGIN LICENSE BLOCK *****
    1: ; Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1: ;
    1: ; The contents of this file are subject to the Mozilla Public License Version
    1: ; 1.1 (the "License"); you may not use this file except in compliance with
    1: ; the License. You may obtain a copy of the License at
    1: ; http://www.mozilla.org/MPL/
    1: ;
    1: ; Software distributed under the License is distributed on an "AS IS" basis,
    1: ; WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1: ; for the specific language governing rights and limitations under the
    1: ; License.
    1: ;
    1: ; The Original Code is mozilla.org code.
    1: ;
    1: ; The Initial Developer of the Original Code is 
    1: ; Makoto Kato <m_kato@ga2.so-net.ne.jp>.
    1: ; Portions created by the Initial Developer are Copyright (C) 2004
    1: ; the Initial Developer. All Rights Reserved.
    1: ;
    1: ; Contributor(s):
    1: ;
    1: ; Alternatively, the contents of this file may be used under the terms of
    1: ; either the GNU General Public License Version 2 or later (the "GPL"), or
    1: ; the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1: ; in which case the provisions of the GPL or the LGPL are applicable instead
    1: ; of those above. If you wish to allow use of your version of this file only
    1: ; under the terms of either the GPL or the LGPL, and not to allow others to
    1: ; use your version of this file under the terms of the MPL, indicate your
    1: ; decision by deleting the provisions above and replace them with the notice
    1: ; and other provisions required by the GPL or the LGPL. If you do not delete
    1: ; the provisions above, a recipient may use your version of this file under
    1: ; the terms of any one of the MPL, the GPL or the LGPL.
    1: ;
    1: ; ***** END LICENSE BLOCK *****
    1: 
    1: extrn invoke_copy_to_stack:PROC
    1: 
    1: 
    1: .CODE
    1: 
    1: ;
    1: ;XPTC__InvokebyIndex(nsISupports* that, PRUint32 methodIndex,
    1: ;                   PRUint32 paramCount, nsXPTCVariant* params)
    1: ;
    1: 
22279: XPTC__InvokebyIndex PROC FRAME
    1: 
22279:    ; store register parameters
    1: 
22279:     mov     qword ptr [rsp+32], r9        ; params
22279:     mov     dword ptr [rsp+24], r8d       ; paramCount
22279:     mov     dword ptr [rsp+16], edx       ; methodIndex
22279:     mov     qword ptr [rsp+8], rcx        ; that
    1: 
42889:     push    rbp
42889:     .PUSHREG rbp
    1:     mov     rbp, rsp            ; store current RSP to RBP
22279:     .SETFRAME rbp, 0
22279:     .ENDPROLOG
22279: 
22279:     sub     rsp, 32
    1: 
    1:     ; maybe we don't have any parameters to copy
    1: 
    1:     test    r8d, r8d
    1:     jz      noparams
    1: 
    1:     ;
42889:     ; Build stack for stdcall
42889:     ;
42889: 
42889:     ; 1st parameter is space for parameters
    1: 
    1:     mov     eax, r8d
42889:     or      eax, 1
22279:     shl     rax, 3              ; *= 8
    1:     sub     rsp, rax
    1:     mov     rcx, rsp
    1: 
    1:     ; 2nd parameter is parameter count
    1: 
    1:     mov     edx, r8d
    1: 
    1:     ; 3rd parameter is params
    1: 
    1:     mov     r8, r9
    1: 
42889:     sub     rsp, 40
    1:     call    invoke_copy_to_stack ; rcx = d
    1:                                  ; edx = paramCount
    1:                                  ; r8  = s
    1:     add     rsp, 32
    1: 
42889:     ; Current stack is the following.
22279:     ;
42889:     ;  0h: [space (for this)]
42889:     ;  8h: [1st parameter]
42889:     ; 10h: [2nd parameter]
42889:     ; 18h: [3rd parameter]
42889:     ; 20h: [4th parameter]
42889:     ; ...
22279:     ;
42889:     ; On Win64 ABI, the first 4 parameters are passed using registers,
42889:     ; and others are on stack. 
22279: 
42889:     ; 1st, 2nd and 3rd arguments are passed via registers
    1: 
42889:     mov     rdx, qword ptr [rsp+8] ; 1st parameter
42889:     movsd   xmm1, qword ptr [rsp+8] ; for double
    1: 
42889:     mov     r8, qword ptr [rsp+16] ; 2nd parameter
42889:     movsd   xmm2, qword ptr [rsp+16] ; for double
    1: 
42889:     mov     r9, qword ptr [rsp+24] ; 3rd parameter
42889:     movsd   xmm3, qword ptr [rsp+24] ; for double
    1: 
42889:     ; rcx register is this
42889: 
42889:     mov     rcx, qword ptr [rbp+8+8] ; that
22279: 
22279: noparams:
    1: 
    1:     ; calculate call address
    1: 
22279:     mov     r11, qword ptr [rcx]
42889:     mov     eax, dword ptr [rbp+16+8] ; methodIndex
    1: 
22279:     call    qword ptr [r11+rax*8]      ; stdcall, i.e. callee cleans up stack.
    1: 
    1:     mov     rsp, rbp
42889:     pop     rbp
    1: 
    1:     ret
    1: 
    1: XPTC__InvokebyIndex ENDP
    1: 
    1: 
    1: END
