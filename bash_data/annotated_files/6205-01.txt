   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* vim: set ts=2 sw=2 et tw=78: */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Johnny Stenback <jst@netscape.com>
   1:  *   L. David Baron  <dbaron@dbaron.org>
   1:  *   Pierre Phaneuf  <pp@ludusdesign.com>
   1:  *   Pete Collins    <petejc@collab.net>
   1:  *   James Ross      <silver@warwickcompsoc.co.uk>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: /*
   1:  * Base class for all our document implementations.
   1:  */
   1: 
   1: #include "plstr.h"
   1: 
   1: #include "nsIInterfaceRequestor.h"
   1: #include "nsIInterfaceRequestorUtils.h"
   1: #include "nsDocument.h"
   1: #include "nsUnicharUtils.h"
   1: #include "nsIPrivateDOMEvent.h"
   1: #include "nsIEventStateManager.h"
   1: #include "nsIFocusController.h"
   1: #include "nsContentList.h"
   1: #include "nsIObserver.h"
   1: #include "nsIBaseWindow.h"
   1: #include "nsIDocShell.h"
   1: #include "nsIDocShellTreeItem.h"
   1: #include "nsIScriptRuntime.h"
   1: #include "nsCOMArray.h"
   1: 
   1: #include "nsGUIEvent.h"
   1: 
   1: #include "nsIDOMStyleSheet.h"
   1: #include "nsDOMAttribute.h"
   1: #include "nsIDOMDOMStringList.h"
   1: #include "nsIDOMDOMImplementation.h"
   1: #include "nsIDOMDocumentView.h"
   1: #include "nsIDOMAbstractView.h"
   1: #include "nsIDOMDocumentXBL.h"
   1: #include "nsGenericElement.h"
   1: #include "nsIDOMEventGroup.h"
   1: #include "nsIDOMCDATASection.h"
   1: #include "nsIDOMProcessingInstruction.h"
   1: #include "nsDOMString.h"
   1: #include "nsNodeUtils.h"
5440: #include "nsLayoutUtils.h" // for GetFrameForPoint
5440: #include "nsIFrame.h"
   1: 
   1: #include "nsRange.h"
   1: #include "nsIDOMText.h"
   1: #include "nsIDOMComment.h"
   1: #include "nsDOMDocumentType.h"
   1: #include "nsTreeWalker.h"
   1: 
   1: #include "nsIServiceManager.h"
   1: 
   1: #include "nsContentCID.h"
   1: #include "nsDOMError.h"
   1: #include "nsIPresShell.h"
   1: #include "nsPresContext.h"
   1: #include "nsContentUtils.h"
   1: #include "nsThreadUtils.h"
   1: #include "nsNodeInfoManager.h"
   1: #include "nsIXBLService.h"
   1: #include "nsIXPointer.h"
   1: #include "nsIFileChannel.h"
   1: #include "nsIMultiPartChannel.h"
   1: #include "nsIRefreshURI.h"
   1: #include "nsIWebNavigation.h"
   1: #include "nsIScriptError.h"
   1: 
   1: #include "nsNetUtil.h"     // for NS_MakeAbsoluteURI
   1: 
   1: #include "nsIScriptSecurityManager.h"
   1: #include "nsIPrincipal.h"
   1: #include "nsIPrivateDOMImplementation.h"
   1: 
   1: #include "nsIDOMWindowInternal.h"
   1: #include "nsPIDOMWindow.h"
   1: #include "nsIDOMElement.h"
   1: 
   1: #include "nsGkAtoms.h"
   1: 
   1: // for radio group stuff
   1: #include "nsIDOMHTMLInputElement.h"
   1: #include "nsIRadioVisitor.h"
   1: #include "nsIFormControl.h"
   1: 
   1: #include "nsXMLEventsManager.h"
   1: 
   1: #include "nsBidiUtils.h"
   1: 
   1: static NS_DEFINE_CID(kDOMEventGroupCID, NS_DOMEVENTGROUP_CID);
   1: 
   1: #include "nsIDOMUserDataHandler.h"
   1: #include "nsScriptEventManager.h"
   1: #include "nsIDOMXPathEvaluator.h"
   1: #include "nsIXPathEvaluatorInternal.h"
   1: #include "nsIParserService.h"
   1: #include "nsContentCreatorFunctions.h"
   1: 
   1: #include "nsIScriptContext.h"
   1: #include "nsBindingManager.h"
   1: #include "nsIDOMHTMLDocument.h"
   1: #include "nsIDOMHTMLFormElement.h"
   1: #include "nsIRequest.h"
   1: #include "nsILink.h"
   1: 
   1: #include "nsICharsetAlias.h"
   1: #include "nsIParser.h"
   1: #include "nsIContentSink.h"
   1: 
   1: #include "nsDateTimeFormatCID.h"
   1: #include "nsIDateTimeFormat.h"
   1: #include "nsEventDispatcher.h"
  62: #include "nsMutationEvent.h"
   1: #include "nsIDOMXPathEvaluator.h"
   1: #include "nsDOMCID.h"
   1: 
   1: #include "nsLayoutStatics.h"
   1: #include "nsIJSContextStack.h"
   1: #include "nsIXPConnect.h"
   1: #include "nsCycleCollector.h"
1353: #include "nsCCUncollectableMarker.h"
2324: #include "nsIContentPolicy.h"
   1: 
   1: #ifdef MOZ_LOGGING
   1: // so we can get logging even in release builds
   1: #define FORCE_PR_LOG 1
   1: #endif
   1: #include "prlog.h"
   1: 
   1: #ifdef PR_LOGGING
   1: static PRLogModuleInfo* gDocumentLeakPRLog;
   1: #endif
   1: 
   1: void
   1: nsUint32ToContentHashEntry::Destroy()
   1: {
   1:   HashSet* set = GetHashSet();
   1:   if (set) {
   1:     delete set;
   1:   } else {
   1:     nsIContent* content = GetContent();
   1:     NS_IF_RELEASE(content);
   1:   }
   1: }
   1: 
   1: nsresult
   1: nsUint32ToContentHashEntry::PutContent(nsIContent* aVal)
   1: {
   1:   // Add the value to the hash if it is there
   1:   HashSet* set = GetHashSet();
   1:   if (set) {
   1:     nsISupportsHashKey* entry = set->PutEntry(aVal);
   1:     return entry ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: 
   1:   // If an element is already there, create a hashtable and both of these to it
   1:   nsIContent* oldVal = GetContent();
   1:   if (oldVal) {
   1:     nsresult rv = InitHashSet(&set);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:     nsISupportsHashKey* entry = set->PutEntry(oldVal);
   1:     if (!entry) {
   1:       // OOM - we can't insert aVal, but we can at least put oldVal back (even
   1:       // if we didn't, we'd still have to release oldVal so that we don't leak)
   1:       delete set;
   1:       SetContent(oldVal);
   1:       // SetContent adds another reference, so release the one we had
   1:       NS_RELEASE(oldVal);
   1:       return NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1:     // The hashset adds its own reference, so release the one we had
   1:     NS_RELEASE(oldVal);
   1: 
   1:     entry = set->PutEntry(aVal);
   1:     return entry ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: 
   1:   // Nothing exists in the hash right now, so just set the single pointer
   1:   return SetContent(aVal);
   1: }
   1: 
   1: void
   1: nsUint32ToContentHashEntry::RemoveContent(nsIContent* aVal)
   1: {
   1:   // Remove from the hash if the hash is there
   1:   HashSet* set = GetHashSet();
   1:   if (set) {
   1:     set->RemoveEntry(aVal);
   1:     if (set->Count() == 0) {
   1:       delete set;
   1:       mValOrHash = nsnull;
   1:     }
   1:     return;
   1:   }
   1: 
   1:   // Remove the ptr if there is just a ptr
   1:   nsIContent* v = GetContent();
   1:   if (v == aVal) {
   1:     NS_IF_RELEASE(v);
   1:     mValOrHash = nsnull;
   1:   }
   1: }
   1: 
   1: nsresult
   1: nsUint32ToContentHashEntry::InitHashSet(HashSet** aSet)
   1: {
   1:   HashSet* newSet = new HashSet();
   1:   if (!newSet) {
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: 
   1:   nsresult rv = newSet->Init();
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   mValOrHash = newSet;
   1:   *aSet = newSet;
   1:   return NS_OK;
   1: }
   1: 
   1: static PLDHashOperator PR_CALLBACK
   1: nsUint32ToContentHashEntryVisitorCallback(nsISupportsHashKey* aEntry,
   1:                                           void* aClosure)
   1: {
   1:   nsUint32ToContentHashEntry::Visitor* visitor =
3233:     static_cast<nsUint32ToContentHashEntry::Visitor*>(aClosure);
3233:   visitor->Visit(static_cast<nsIContent*>(aEntry->GetKey()));
   1:   return PL_DHASH_NEXT;
   1: }
   1: 
   1: void
   1: nsUint32ToContentHashEntry::VisitContent(Visitor* aVisitor)
   1: {
   1:   HashSet* set = GetHashSet();
   1:   if (set) {
   1:     set->EnumerateEntries(nsUint32ToContentHashEntryVisitorCallback, aVisitor);
   1:     if (set->Count() == 0) {
   1:       delete set;
   1:       mValOrHash = nsnull;
   1:     }
   1:     return;
   1:   }
   1: 
   1:   nsIContent* v = GetContent();
   1:   if (v) {
   1:     aVisitor->Visit(v);
   1:   }
   1: }
   1: 
   1: // Helper structs for the content->subdoc map
   1: 
   1: class SubDocMapEntry : public PLDHashEntryHdr
   1: {
   1: public:
   1:   // Both of these are strong references
   1:   nsIContent *mKey; // must be first, to look like PLDHashEntryStub
   1:   nsIDocument *mSubDocument;
   1: };
   1: 
   1: struct FindContentData
   1: {
   1:   FindContentData(nsIDocument *aSubDoc)
   1:     : mSubDocument(aSubDoc), mResult(nsnull)
   1:   {
   1:   }
   1: 
   1:   nsISupports *mSubDocument;
   1:   nsIContent *mResult;
   1: };
   1: 
   1: 
   1: /**
   1:  * A struct that holds all the information about a radio group.
   1:  */
   1: struct nsRadioGroupStruct
   1: {
   1:   /**
   1:    * A strong pointer to the currently selected radio button.
   1:    */
   1:   nsCOMPtr<nsIDOMHTMLInputElement> mSelectedRadioButton;
   1:   nsSmallVoidArray mRadioButtons;
   1: };
   1: 
   1: 
   1: nsDOMStyleSheetList::nsDOMStyleSheetList(nsIDocument *aDocument)
   1: {
   1:   mLength = -1;
   1:   // Not reference counted to avoid circular references.
   1:   // The document will tell us when its going away.
   1:   mDocument = aDocument;
   1:   mDocument->AddObserver(this);
   1: }
   1: 
   1: nsDOMStyleSheetList::~nsDOMStyleSheetList()
   1: {
   1:   if (mDocument) {
   1:     mDocument->RemoveObserver(this);
   1:   }
   1: }
   1: 
   1: 
   1: // XXX couldn't we use the GetIIDs method from CSSStyleSheetList here?
   1: // QueryInterface implementation for nsDOMStyleSheetList
   1: NS_INTERFACE_MAP_BEGIN(nsDOMStyleSheetList)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOMStyleSheetList)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDocumentObserver)
   1:   NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)
   1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMStyleSheetList)
   1:   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(DocumentStyleSheetList)
   1: NS_INTERFACE_MAP_END
   1: 
   1: 
   1: NS_IMPL_ADDREF(nsDOMStyleSheetList)
   1: NS_IMPL_RELEASE(nsDOMStyleSheetList)
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsDOMStyleSheetList::GetLength(PRUint32* aLength)
   1: {
   1:   if (mDocument) {
   1:     // XXX Find the number and then cache it. We'll use the
   1:     // observer notification to figure out if new ones have
   1:     // been added or removed.
   1:     if (-1 == mLength) {
   1:       mLength = mDocument->GetNumberOfStyleSheets();
   1: 
   1: #ifdef DEBUG
   1:       PRInt32 i;
   1:       for (i = 0; i < mLength; i++) {
   1:         nsIStyleSheet *sheet = mDocument->GetStyleSheetAt(i);
   1:         nsCOMPtr<nsIDOMStyleSheet> domss(do_QueryInterface(sheet));
   1:         NS_ASSERTION(domss, "All \"normal\" sheets implement nsIDOMStyleSheet");
   1:       }
   1: #endif
   1:     }
   1:     *aLength = mLength;
   1:   }
   1:   else {
   1:     *aLength = 0;
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDOMStyleSheetList::Item(PRUint32 aIndex, nsIDOMStyleSheet** aReturn)
   1: {
   1:   *aReturn = nsnull;
   1:   if (mDocument) {
   1:     PRInt32 count = mDocument->GetNumberOfStyleSheets();
   1:     if (aIndex < (PRUint32)count) {
   1:       nsIStyleSheet *sheet = mDocument->GetStyleSheetAt(aIndex);
   1:       NS_ASSERTION(sheet, "Must have a sheet");
   1:       return CallQueryInterface(sheet, aReturn);
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: void
   1: nsDOMStyleSheetList::NodeWillBeDestroyed(const nsINode *aNode)
   1: {
   1:   mDocument = nsnull;
   1: }
   1: 
   1: void
   1: nsDOMStyleSheetList::StyleSheetAdded(nsIDocument *aDocument,
   1:                                      nsIStyleSheet* aStyleSheet,
   1:                                      PRBool aDocumentSheet)
   1: {
   1:   if (aDocumentSheet && -1 != mLength) {
   1:     nsCOMPtr<nsIDOMStyleSheet> domss(do_QueryInterface(aStyleSheet));
   1:     if (domss) {
   1:       mLength++;
   1:     }
   1:   }
   1: }
   1: 
   1: void
   1: nsDOMStyleSheetList::StyleSheetRemoved(nsIDocument *aDocument,
   1:                                        nsIStyleSheet* aStyleSheet,
   1:                                        PRBool aDocumentSheet)
   1: {
   1:   if (aDocumentSheet && -1 != mLength) {
   1:     nsCOMPtr<nsIDOMStyleSheet> domss(do_QueryInterface(aStyleSheet));
   1:     if (domss) {
   1:       mLength--;
   1:     }
   1:   }
   1: }
   1: 
   1: // nsOnloadBlocker implementation
   1: NS_IMPL_ISUPPORTS1(nsOnloadBlocker, nsIRequest)
   1: 
   1: NS_IMETHODIMP
   1: nsOnloadBlocker::GetName(nsACString &aResult)
   1: { 
   1:   aResult.AssignLiteral("about:document-onload-blocker");
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsOnloadBlocker::IsPending(PRBool *_retval)
   1: {
   1:   *_retval = PR_TRUE;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsOnloadBlocker::GetStatus(nsresult *status)
   1: {
   1:   *status = NS_OK;
   1:   return NS_OK;
   1: } 
   1: 
   1: NS_IMETHODIMP
   1: nsOnloadBlocker::Cancel(nsresult status)
   1: {
   1:   return NS_OK;
   1: }
   1: NS_IMETHODIMP
   1: nsOnloadBlocker::Suspend(void)
   1: {
   1:   return NS_OK;
   1: }
   1: NS_IMETHODIMP
   1: nsOnloadBlocker::Resume(void)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsOnloadBlocker::GetLoadGroup(nsILoadGroup * *aLoadGroup)
   1: {
   1:   *aLoadGroup = nsnull;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsOnloadBlocker::SetLoadGroup(nsILoadGroup * aLoadGroup)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsOnloadBlocker::GetLoadFlags(nsLoadFlags *aLoadFlags)
   1: {
   1:   *aLoadFlags = nsIRequest::LOAD_NORMAL;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsOnloadBlocker::SetLoadFlags(nsLoadFlags aLoadFlags)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: // ==================================================================
   1: // =
   1: // ==================================================================
   1: 
   1: // If we ever have an nsIDocumentObserver notification for stylesheet title
   1: // changes, we could make this inherit from nsDOMStringList instead of
   1: // reimplementing nsIDOMDOMStringList.
   1: class nsDOMStyleSheetSetList : public nsIDOMDOMStringList
   1:                           
   1: {
   1: public:
   1:   NS_DECL_ISUPPORTS
   1: 
   1:   NS_DECL_NSIDOMDOMSTRINGLIST
   1: 
   1:   nsDOMStyleSheetSetList(nsIDocument* aDocument);
   1: 
   1:   void Disconnect()
   1:   {
   1:     mDocument = nsnull;
   1:   }
   1: 
   1: protected:
   1:   // Rebuild our list of style sets
   1:   nsresult GetSets(nsStringArray& aStyleSets);
   1:   
   1:   nsIDocument* mDocument;  // Our document; weak ref.  It'll let us know if it
   1:                            // dies.
   1: };
   1: 
   1: NS_IMPL_ADDREF(nsDOMStyleSheetSetList)
   1: NS_IMPL_RELEASE(nsDOMStyleSheetSetList)
   1: NS_INTERFACE_MAP_BEGIN(nsDOMStyleSheetSetList)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOMDOMStringList)
   1:   NS_INTERFACE_MAP_ENTRY(nsISupports)
   1:   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(DOMStringList)
   1: NS_INTERFACE_MAP_END
   1: 
   1: nsDOMStyleSheetSetList::nsDOMStyleSheetSetList(nsIDocument* aDocument)
   1:   : mDocument(aDocument)
   1: {
   1:   NS_ASSERTION(mDocument, "Must have document!");
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDOMStyleSheetSetList::Item(PRUint32 aIndex, nsAString& aResult)
   1: {
   1:   nsStringArray styleSets;
   1:   nsresult rv = GetSets(styleSets);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1:   
   1:   if (aIndex >= (PRUint32)styleSets.Count()) {
   1:     SetDOMStringToNull(aResult);
   1:   } else {
   1:     styleSets.StringAt(aIndex, aResult);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDOMStyleSheetSetList::GetLength(PRUint32 *aLength)
   1: {
   1:   nsStringArray styleSets;
   1:   nsresult rv = GetSets(styleSets);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1:   
   1:   *aLength = (PRUint32)styleSets.Count();
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDOMStyleSheetSetList::Contains(const nsAString& aString, PRBool *aResult)
   1: {
   1:   nsStringArray styleSets;
   1:   nsresult rv = GetSets(styleSets);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1:   
   1:   *aResult = styleSets.IndexOf(aString) != -1;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsDOMStyleSheetSetList::GetSets(nsStringArray& aStyleSets)
   1: {
   1:   if (!mDocument) {
   1:     return NS_OK; // Spec says "no exceptions", and we have no style sets if we
   1:                   // have no document, for sure
   1:   }
   1:   
   1:   PRInt32 count = mDocument->GetNumberOfStyleSheets();
   1:   nsAutoString title;
   1:   nsAutoString temp;
   1:   for (PRInt32 index = 0; index < count; index++) {
   1:     nsIStyleSheet* sheet = mDocument->GetStyleSheetAt(index);
   1:     NS_ASSERTION(sheet, "Null sheet in sheet list!");
   1:     sheet->GetTitle(title);
   1:     if (!title.IsEmpty() && aStyleSets.IndexOf(title) == -1 &&
   1:         !aStyleSets.AppendString(title)) {
   1:       return NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: // ==================================================================
   1: // =
   1: // ==================================================================
   1: 
   1: class nsDOMImplementation : public nsIDOMDOMImplementation,
   1:                             public nsIPrivateDOMImplementation
   1: {
   1: public:
   1:   nsDOMImplementation(nsIURI* aDocumentURI,
   1:                       nsIURI* aBaseURI,
   1:                       nsIPrincipal* aPrincipal);
   1:   virtual ~nsDOMImplementation();
   1: 
   1:   NS_DECL_ISUPPORTS
   1: 
   1:   // nsIDOMDOMImplementation
   1:   NS_DECL_NSIDOMDOMIMPLEMENTATION
   1: 
   1:   // nsIPrivateDOMImplementation
   1:   NS_IMETHOD Init(nsIURI* aDocumentURI, nsIURI* aBaseURI,
   1:                   nsIPrincipal* aPrincipal);
   1: 
   1: protected:
   1:   nsCOMPtr<nsIURI> mDocumentURI;
   1:   nsCOMPtr<nsIURI> mBaseURI;
   1:   nsCOMPtr<nsIPrincipal> mPrincipal;
   1: };
   1: 
   1: 
   1: nsresult
   1: NS_NewDOMImplementation(nsIDOMDOMImplementation** aInstancePtrResult)
   1: {
   1:   *aInstancePtrResult = new nsDOMImplementation(nsnull, nsnull, nsnull);
   1:   if (!*aInstancePtrResult) {
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: 
   1:   NS_ADDREF(*aInstancePtrResult);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsDOMImplementation::nsDOMImplementation(nsIURI* aDocumentURI,
   1:                                          nsIURI* aBaseURI,
   1:                                          nsIPrincipal* aPrincipal)
   1:   : mDocumentURI(aDocumentURI),
   1:     mBaseURI(aBaseURI),
   1:     mPrincipal(aPrincipal)
   1: {
   1: }
   1: 
   1: nsDOMImplementation::~nsDOMImplementation()
   1: {
   1: }
   1: 
   1: // QueryInterface implementation for nsDOMImplementation
   1: NS_INTERFACE_MAP_BEGIN(nsDOMImplementation)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOMDOMImplementation)
   1:   NS_INTERFACE_MAP_ENTRY(nsIPrivateDOMImplementation)
   1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMDOMImplementation)
   1:   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(DOMImplementation)
   1: NS_INTERFACE_MAP_END
   1: 
   1: 
   1: NS_IMPL_ADDREF(nsDOMImplementation)
   1: NS_IMPL_RELEASE(nsDOMImplementation)
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsDOMImplementation::HasFeature(const nsAString& aFeature,
   1:                                 const nsAString& aVersion,
   1:                                 PRBool* aReturn)
   1: {
   1:   return nsGenericElement::InternalIsSupported(
3233:            static_cast<nsIDOMDOMImplementation*>(this),
   1:            aFeature, aVersion, aReturn);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDOMImplementation::CreateDocumentType(const nsAString& aQualifiedName,
   1:                                         const nsAString& aPublicId,
   1:                                         const nsAString& aSystemId,
   1:                                         nsIDOMDocumentType** aReturn)
   1: {
   1:   *aReturn = nsnull;
   1: 
   1:   nsresult rv = nsContentUtils::CheckQName(aQualifiedName);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsCOMPtr<nsIAtom> name = do_GetAtom(aQualifiedName);
   1:   NS_ENSURE_TRUE(name, NS_ERROR_OUT_OF_MEMORY);
   1:     
   1:   return NS_NewDOMDocumentType(aReturn, nsnull, mPrincipal, name, nsnull,
   1:                                nsnull, aPublicId, aSystemId, EmptyString());
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDOMImplementation::CreateDocument(const nsAString& aNamespaceURI,
   1:                                     const nsAString& aQualifiedName,
   1:                                     nsIDOMDocumentType* aDoctype,
   1:                                     nsIDOMDocument** aReturn)
   1: {
   1:   *aReturn = nsnull;
   1: 
   1:   nsresult rv;
   1:   if (!aQualifiedName.IsEmpty()) {
   1:     nsIParserService *parserService = nsContentUtils::GetParserService();
   1:     NS_ENSURE_TRUE(parserService, NS_ERROR_FAILURE);
   1: 
   1:     const nsAFlatString& qName = PromiseFlatString(aQualifiedName);
   1:     const PRUnichar *colon;
   1:     rv = parserService->CheckQName(qName, PR_TRUE, &colon);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:     if (colon &&
   1:         (DOMStringIsNull(aNamespaceURI) ||
   1:          (Substring(qName.get(), colon).EqualsLiteral("xml") &&
   1:           !aNamespaceURI.EqualsLiteral("http://www.w3.org/XML/1998/namespace")))) {
   1:       return NS_ERROR_DOM_NAMESPACE_ERR;
   1:     }
   1:   }
   1:   else if (DOMStringIsNull(aQualifiedName) &&
   1:            !DOMStringIsNull(aNamespaceURI)) {
   1:     return NS_ERROR_DOM_NAMESPACE_ERR;
   1:   }
   1: 
   1:   if (aDoctype) {
   1:     nsCOMPtr<nsIDOMDocument> owner;
   1:     aDoctype->GetOwnerDocument(getter_AddRefs(owner));
   1:     if (owner) {
   1:       return NS_ERROR_DOM_WRONG_DOCUMENT_ERR;
   1:     }
   1:   }
   1: 
   1:   return nsContentUtils::CreateDocument(aNamespaceURI, aQualifiedName, aDoctype,
   1:                                         mDocumentURI, mBaseURI, mPrincipal,
   1:                                         aReturn);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDOMImplementation::Init(nsIURI* aDocumentURI, nsIURI* aBaseURI,
   1:                           nsIPrincipal* aPrincipal)
   1: {
   1:   // Note: can't require that the args be non-null, since at least one
   1:   // caller (XMLHttpRequest) doesn't have decent args to pass in.
   1:   mDocumentURI = aDocumentURI;
   1:   mBaseURI = aBaseURI;
   1:   mPrincipal = aPrincipal;
   1:   return NS_OK;
   1: }
   1: 
   1: // ==================================================================
   1: // =
   1: // ==================================================================
   1: 
   1:   // NOTE! nsDocument::operator new() zeroes out all members, so don't
   1:   // bother initializing members to 0.
   1: 
   1: nsDocument::nsDocument(const char* aContentType)
   1:   : nsIDocument(),
   1:     mVisible(PR_TRUE)
   1: {
   1:   nsLayoutStatics::AddRef();
   1:   mContentType = aContentType;
   1:   
   1: #ifdef PR_LOGGING
   1:   if (!gDocumentLeakPRLog)
   1:     gDocumentLeakPRLog = PR_NewLogModule("DocumentLeak");
   1: 
   1:   if (gDocumentLeakPRLog)
   1:     PR_LOG(gDocumentLeakPRLog, PR_LOG_DEBUG,
   1:            ("DOCUMENT %p created", this));
   1: #endif
   1: 
   1:   // Start out mLastStyleSheetSet as null, per spec
   1:   SetDOMStringToNull(mLastStyleSheetSet);
   1: }
   1: 
   1: nsDocument::~nsDocument()
   1: {
   1: #ifdef PR_LOGGING
   1:   if (gDocumentLeakPRLog)
   1:     PR_LOG(gDocumentLeakPRLog, PR_LOG_DEBUG,
   1:            ("DOCUMENT %p destroyed", this));
   1: #endif
   1: 
   1: #ifdef DEBUG
3233:   nsCycleCollector_DEBUG_wasFreed(static_cast<nsIDocument*>(this));
   1: #endif
   1: 
   1:   mInDestructor = PR_TRUE;
   1: 
   1:   // Clear mObservers to keep it in sync with the mutationobserver list
   1:   mObservers.Clear();
   1: 
   1:   if (mStyleSheetSetList) {
   1:     mStyleSheetSetList->Disconnect();
   1:   }
   1: 
   1:   mParentDocument = nsnull;
   1: 
   1:   // Kill the subdocument map, doing this will release its strong
   1:   // references, if any.
   1:   if (mSubDocuments) {
   1:     PL_DHashTableDestroy(mSubDocuments);
   1: 
   1:     mSubDocuments = nsnull;
   1:   }
   1: 
   1:   PRInt32 indx;
   1:   if (mRootContent) {
   1:     if (mRootContent->GetCurrentDoc()) {
   1:       NS_ASSERTION(mRootContent->GetCurrentDoc() == this,
   1:                    "Unexpected current doc in root content");
   1:       // The root content still has a pointer back to the document,
   1:       // clear the document pointer in all children.
   1:       
   1:       // Destroy link map now so we don't waste time removing
   1:       // links one by one
   1:       DestroyLinkMap();
   1: 
   1:       PRUint32 count = mChildren.ChildCount();
   1:       for (indx = PRInt32(count) - 1; indx >= 0; --indx) {
   1:         mChildren.ChildAt(indx)->UnbindFromTree();
   1:         mChildren.RemoveChildAt(indx);
   1:       }
   1:     }
   1:   }
   1: 
   1:   mRootContent = nsnull;
   1: 
   1:   // Let the stylesheets know we're going away
   1:   indx = mStyleSheets.Count();
   1:   while (--indx >= 0) {
   1:     mStyleSheets[indx]->SetOwningDocument(nsnull);
   1:   }
   1:   indx = mCatalogSheets.Count();
   1:   while (--indx >= 0) {
   1:     mCatalogSheets[indx]->SetOwningDocument(nsnull);
   1:   }
   1:   if (mAttrStyleSheet)
   1:     mAttrStyleSheet->SetOwningDocument(nsnull);
   1:   if (mStyleAttrStyleSheet)
   1:     mStyleAttrStyleSheet->SetOwningDocument(nsnull);
   1: 
   1:   if (mListenerManager) {
   1:     mListenerManager->Disconnect();
   1:   }
   1: 
   1:   if (mScriptLoader) {
   1:     mScriptLoader->DropDocumentReference();
   1:   }
   1: 
   1:   if (mCSSLoader) {
   1:     // Could be null here if Init() failed
   1:     mCSSLoader->DropDocumentReference();
   1:     NS_RELEASE(mCSSLoader);
   1:   }
   1: 
   1:   // XXX Ideally we'd do this cleanup in the nsIDocument destructor.
   1:   if (mNodeInfoManager) {
   1:     mNodeInfoManager->DropDocumentReference();
   1:     NS_RELEASE(mNodeInfoManager);
   1:   }
   1: 
   1:   if (mAttrStyleSheet) {
   1:     mAttrStyleSheet->SetOwningDocument(nsnull);
   1:   }
   1:   
   1:   if (mStyleAttrStyleSheet) {
   1:     mStyleAttrStyleSheet->SetOwningDocument(nsnull);
   1:   }
   1: 
   1:   NS_IF_RELEASE(mBindingManager);
   1: 
   1:   delete mHeaderData;
   1:   delete mBoxObjectTable;
   1:   delete mContentWrapperHash;
   1:   nsLayoutStatics::Release();
   1: }
   1: 
   1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsDocument)
   1: 
 791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsDocument)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDocument)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOMDocument)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOMNSDocument)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOMDocumentEvent)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOM3DocumentEvent)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOMDocumentStyle)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOMNSDocumentStyle)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOMDocumentView)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOMDocumentRange)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOMDocumentTraversal)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOMDocumentXBL)
   1:   NS_INTERFACE_MAP_ENTRY(nsIScriptObjectPrincipal)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOMEventTarget)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOM3EventTarget)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOMNSEventTarget)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
   1:   NS_INTERFACE_MAP_ENTRY(nsPIDOMEventTarget)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOM3Node)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOM3Document)
   1:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
   1:   NS_INTERFACE_MAP_ENTRY(nsIRadioGroupContainer)
   1:   NS_INTERFACE_MAP_ENTRY(nsINode)
   1:   NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)
   1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDocument)
   1:   if (aIID.Equals(NS_GET_IID(nsIDOMXPathEvaluator)) ||
   1:       aIID.Equals(NS_GET_IID(nsIXPathEvaluatorInternal))) {
   1:     if (!mXPathEvaluatorTearoff) {
   1:       nsresult rv;
   1:       mXPathEvaluatorTearoff =
   1:         do_CreateInstance(NS_XPATH_EVALUATOR_CONTRACTID,
3233:                           static_cast<nsIDocument *>(this), &rv);
   1:       NS_ENSURE_SUCCESS(rv, rv);
   1:     }
   1: 
   1:     return mXPathEvaluatorTearoff->QueryInterface(aIID, aInstancePtr);
   1:   }
   1:   else
   1: NS_INTERFACE_MAP_END
   1: 
   1: 
   1: NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsDocument, nsIDocument)
   1: NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS_WITH_DESTROY(nsDocument, 
   1:                                                         nsIDocument,
1391:                                                         nsNodeUtils::LastRelease(this))
   1: 
   1: 
   1: PR_STATIC_CALLBACK(PLDHashOperator)
   1: SubDocTraverser(PLDHashTable *table, PLDHashEntryHdr *hdr, PRUint32 number,
   1:                 void *arg)
   1: {
3233:   SubDocMapEntry *entry = static_cast<SubDocMapEntry*>(hdr);
   1:   nsCycleCollectionTraversalCallback *cb = 
3233:     static_cast<nsCycleCollectionTraversalCallback*>(arg);
   1: 
   1:   cb->NoteXPCOMChild(entry->mKey);
   1:   cb->NoteXPCOMChild(entry->mSubDocument);
   1: 
   1:   return PL_DHASH_NEXT;
   1: }
   1: 
   1: PR_STATIC_CALLBACK(PRIntn)
   1: RadioGroupsTraverser(nsHashKey *aKey, void *aData, void* aClosure)
   1: {
3233:   nsRadioGroupStruct *entry = static_cast<nsRadioGroupStruct*>(aData);
   1:   nsCycleCollectionTraversalCallback *cb = 
3233:     static_cast<nsCycleCollectionTraversalCallback*>(aClosure);
   1: 
   1:   cb->NoteXPCOMChild(entry->mSelectedRadioButton);
   1: 
   1:   nsSmallVoidArray &radioButtons = entry->mRadioButtons;
   1:   PRUint32 i, count = radioButtons.Count();
   1:   for (i = 0; i < count; ++i) {
3233:     cb->NoteXPCOMChild(static_cast<nsIFormControl*>(radioButtons[i]));
   1:   }
   1:   
   1: 
   1:   return kHashEnumerateNext;
   1: }
   1: 
   1: PR_STATIC_CALLBACK(PLDHashOperator)
   1: BoxObjectTraverser(nsISupports* key, nsPIBoxObject* boxObject, void* userArg)
   1: {
   1:   nsCycleCollectionTraversalCallback *cb = 
3233:     static_cast<nsCycleCollectionTraversalCallback*>(userArg);
   1:  
   1:   cb->NoteXPCOMChild(key);
   1:   cb->NoteXPCOMChild(boxObject);
   1: 
   1:   return PL_DHASH_NEXT;
   1: }
   1: 
   1: class LinkMapTraversalVisitor : public nsUint32ToContentHashEntry::Visitor
   1: {
   1: public:
   1:   nsCycleCollectionTraversalCallback *mCb;
   1:   virtual void Visit(nsIContent* aContent)
   1:   {
   1:     mCb->NoteXPCOMChild(aContent);
   1:   }
   1: };
   1: 
   1: PLDHashOperator PR_CALLBACK
   1: LinkMapTraverser(nsUint32ToContentHashEntry* aEntry, void* userArg)
   1: {
   1:   LinkMapTraversalVisitor visitor;
3233:   visitor.mCb = static_cast<nsCycleCollectionTraversalCallback*>(userArg);
   1:   aEntry->VisitContent(&visitor);
   1:   return PL_DHASH_NEXT;
   1: }
   1: 
   1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsDocument)
1353:   if (nsCCUncollectableMarker::InGeneration(tmp->GetMarkedCCGeneration())) {
1353:     return NS_OK;
1353:   }
1353: 
   1:   // Traverse the mChildren nsAttrAndChildArray.
   1:   for (PRInt32 indx = PRInt32(tmp->mChildren.ChildCount()); indx > 0; --indx) {
   1:     cb.NoteXPCOMChild(tmp->mChildren.ChildAt(indx - 1));
   1:   }
   1: 
1391:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_USERDATA
1391: 
   1:   // Traverse all nsIDocument pointer members.
   1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(mBindingManager)
   1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mSecurityInfo)
   1: 
   1:   // Traverse all nsDocument nsCOMPtrs.
   1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mParser)
   1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mScriptGlobalObject)
   1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mListenerManager)
   1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDOMStyleSheets)
   1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mScriptLoader)
   1: 
   1:   tmp->mRadioGroups.Enumerate(RadioGroupsTraverser, &cb);
   1: 
   1:   // The boxobject for an element will only exist as long as it's in the
   1:   // document, so we'll traverse the table here instead of from the element.
   1:   if (tmp->mBoxObjectTable) {
   1:     tmp->mBoxObjectTable->EnumerateRead(BoxObjectTraverser, &cb);
   1:   }
   1: 
   1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mChannel)
   1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mStyleAttrStyleSheet)
   1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mScriptEventManager)
   1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mXPathEvaluatorTearoff)
   1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLayoutHistoryState)
   1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnloadBlocker)
   1: 
   1:   // An element will only be in the linkmap as long as it's in the
   1:   // document, so we'll traverse the table here instead of from the element.
   1:   if (tmp->mLinkMap.IsInitialized()) {
   1:     tmp->mLinkMap.EnumerateEntries(LinkMapTraverser, &cb);
   1:   }
   1: 
   1:   // Traverse all our nsCOMArrays.
   1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mStyleSheets)
   1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mCatalogSheets)
   1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mVisitednessChangedURIs)
   1: 
   1:   // Traverse any associated preserved wrapper.
   1:   cb.NoteXPCOMChild(tmp->GetReference(tmp));
   1: 
   1:   if (tmp->mSubDocuments && tmp->mSubDocuments->ops) {
   1:     PL_DHashTableEnumerate(tmp->mSubDocuments, SubDocTraverser, &cb);
   1:   }
   1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
   1: 
   1: 
   1: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsDocument)
   1:   // Unlink the mChildren nsAttrAndChildArray.
   1:   for (PRInt32 indx = PRInt32(tmp->mChildren.ChildCount()) - 1; 
   1:        indx >= 0; --indx) {
   1:     tmp->mChildren.ChildAt(indx)->UnbindFromTree();
   1:     tmp->mChildren.RemoveChildAt(indx);
   1:   }
   1: 
1391:   NS_IMPL_CYCLE_COLLECTION_UNLINK_USERDATA
1391: 
   1:   // Unlink any associated preserved wrapper.
   1:   tmp->RemoveReference(tmp);
   1: 
   1:   tmp->mParentDocument = nsnull;
   1:   tmp->mRootContent = nsnull;
   1: 
   1:   // nsDocument has a pretty complex destructor, so we're going to
   1:   // assume that *most* cycles you actually want to break somewhere
   1:   // else, and not unlink an awful lot here.
   1:   //
   1:   // In rare cases where you think an unlink will help here, add one
   1:   // manually.
   1: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
   1: 
   1: 
   1: nsresult
   1: nsDocument::Init()
   1: {
2007:   if (mBindingManager || mCSSLoader || mNodeInfoManager || mScriptLoader) {
   1:     return NS_ERROR_ALREADY_INITIALIZED;
   1:   }
   1: 
   1:   mLinkMap.Init();
   1: 
   1:   // Force initialization.
   1:   nsBindingManager *bindingManager = new nsBindingManager();
   1:   NS_ENSURE_TRUE(bindingManager, NS_ERROR_OUT_OF_MEMORY);
   1:   NS_ADDREF(mBindingManager = bindingManager);
   1: 
   1:   // The binding manager needs to come before everything but us in our
   1:   // mutation observer list.
   1:   nsINode::nsSlots* slots = GetSlots();
   1:   NS_ENSURE_TRUE(slots &&
   1:                  slots->mMutationObservers.PrependObserver(bindingManager),
   1:                  NS_ERROR_OUT_OF_MEMORY);
   1: 
   1:   // Prepend self as mutation-observer whether we need it or not (some
   1:   // subclasses currently do, other don't). This is because the code in
   1:   // nsNodeUtils always notifies the first observer first, expecting the
   1:   // first observer to be the document.
   1:   NS_ENSURE_TRUE(slots->mMutationObservers.PrependObserver(this),
   1:                  NS_ERROR_OUT_OF_MEMORY);
   1: 
   1: 
   1:   mOnloadBlocker = new nsOnloadBlocker();
   1:   NS_ENSURE_TRUE(mOnloadBlocker, NS_ERROR_OUT_OF_MEMORY);
   1:   
   1:   NS_NewCSSLoader(this, &mCSSLoader);
   1:   NS_ENSURE_TRUE(mCSSLoader, NS_ERROR_OUT_OF_MEMORY);
   1:   // Assume we're not HTML and not quirky, until we know otherwise
   1:   mCSSLoader->SetCaseSensitive(PR_TRUE);
   1:   mCSSLoader->SetCompatibilityMode(eCompatibility_FullStandards);
   1: 
   1:   mNodeInfoManager = new nsNodeInfoManager();
   1:   NS_ENSURE_TRUE(mNodeInfoManager, NS_ERROR_OUT_OF_MEMORY);
   1: 
   1:   NS_ADDREF(mNodeInfoManager);
   1: 
   1:   nsresult  rv = mNodeInfoManager->Init(this);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   mNodeInfo = mNodeInfoManager->GetDocumentNodeInfo();
   1:   NS_ENSURE_TRUE(mNodeInfo, NS_ERROR_OUT_OF_MEMORY);
   1: 
   1:   NS_ASSERTION(GetOwnerDoc() == this, "Our nodeinfo is busted!");
   1: 
2007:   mScriptLoader = new nsScriptLoader(this);
2007:   NS_ENSURE_TRUE(mScriptLoader, NS_ERROR_OUT_OF_MEMORY);
2007: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsDocument::AddXMLEventsContent(nsIContent *aXMLEventsElement)
   1: {
   1:   if (!mXMLEventsManager) {
   1:     mXMLEventsManager = new nsXMLEventsManager();
   1:     NS_ENSURE_TRUE(mXMLEventsManager, NS_ERROR_OUT_OF_MEMORY);
   1:     AddObserver(mXMLEventsManager);
   1:   }
   1:   mXMLEventsManager->AddXMLEventsContent(aXMLEventsElement);
   1:   return NS_OK;
   1: }
   1: 
   1: void
   1: nsDocument::Reset(nsIChannel* aChannel, nsILoadGroup* aLoadGroup)
   1: {
   1:   nsCOMPtr<nsIURI> uri;
   1:   nsCOMPtr<nsIPrincipal> principal;
   1:   if (aChannel) {
   1:     // Note: this code is duplicated in nsXULDocument::StartDocumentLoad and
   1:     // nsScriptSecurityManager::GetChannelPrincipal.    
   1:     // Note: this should match nsDocShell::OnLoadingSite
   1:     nsLoadFlags loadFlags = 0;
   1:     nsresult rv = aChannel->GetLoadFlags(&loadFlags);
   1:     if (NS_SUCCEEDED(rv) && (loadFlags & nsIChannel::LOAD_REPLACE)) {
   1:       aChannel->GetURI(getter_AddRefs(uri));
   1:     } else {
   1:       aChannel->GetOriginalURI(getter_AddRefs(uri));
   1:     }
   1: 
   1:     nsIScriptSecurityManager *securityManager =
   1:       nsContentUtils::GetSecurityManager();
   1:     if (securityManager) {
   1:       securityManager->GetChannelPrincipal(aChannel,
   1:                                            getter_AddRefs(principal));
   1:     }
   1:   }
   1: 
   1:   ResetToURI(uri, aLoadGroup, principal);
   1: 
   1:   mChannel = aChannel;
   1: }
   1: 
   1: void
   1: nsDocument::ResetToURI(nsIURI *aURI, nsILoadGroup *aLoadGroup,
   1:                        nsIPrincipal* aPrincipal)
   1: {
   1:   NS_PRECONDITION(aURI, "Null URI passed to ResetToURI");
   1: 
   1: #ifdef PR_LOGGING
   1:   if (gDocumentLeakPRLog && PR_LOG_TEST(gDocumentLeakPRLog, PR_LOG_DEBUG)) {
   1:     nsCAutoString spec;
   1:     aURI->GetSpec(spec);
   1:     PR_LogPrint("DOCUMENT %p ResetToURI %s", this, spec.get());
   1:   }
   1: #endif
   1: 
   1:   mDocumentTitle.SetIsVoid(PR_TRUE);
   1: 
   1:   SetPrincipal(nsnull);
   1:   mSecurityInfo = nsnull;
   1: 
   1:   mDocumentLoadGroup = nsnull;
   1: 
   1:   // Delete references to sub-documents and kill the subdocument map,
   1:   // if any. It holds strong references
   1:   if (mSubDocuments) {
   1:     PL_DHashTableDestroy(mSubDocuments);
   1: 
   1:     mSubDocuments = nsnull;
   1:   }
   1: 
   1:   // Destroy link map now so we don't waste time removing
   1:   // links one by one
   1:   DestroyLinkMap();
   1: 
   1:   mRootContent = nsnull;
   1:   PRUint32 count = mChildren.ChildCount();
   1:   for (PRInt32 i = PRInt32(count) - 1; i >= 0; i--) {
   1:     nsCOMPtr<nsIContent> content = mChildren.ChildAt(i);
   1: 
   1:     nsNodeUtils::ContentRemoved(this, content, i);
   1:     content->UnbindFromTree();
   1:     mChildren.RemoveChildAt(i);
   1:   }
   1: 
   1:   // Reset our stylesheets
   1:   ResetStylesheetsToURI(aURI);
   1:   
   1:   // Release the listener manager
   1:   if (mListenerManager) {
   1:     mListenerManager->Disconnect();
   1:     mListenerManager = nsnull;
   1:   }
   1: 
   1:   // Release the stylesheets list.
   1:   mDOMStyleSheets = nsnull;
   1: 
   1:   SetDocumentURI(aURI);
   1:   mDocumentBaseURI = mDocumentURI;
   1: 
   1:   if (aLoadGroup) {
   1:     mDocumentLoadGroup = do_GetWeakReference(aLoadGroup);
   1:     // there was an assertion here that aLoadGroup was not null.  This
   1:     // is no longer valid nsWebShell::SetDocument does not create a
   1:     // load group, and it works just fine.
   1:   }
   1: 
   1:   mLastModified.Truncate();
   1:   // XXXbz I guess we're assuming that the caller will either pass in
   1:   // a channel with a useful type or call SetContentType?
   1:   mContentType.Truncate();
   1:   mContentLanguage.Truncate();
   1:   mBaseTarget.Truncate();
   1:   mReferrer.Truncate();
   1: 
   1:   mXMLDeclarationBits = 0;
   1: 
   1:   // Now get our new principal
   1:   if (aPrincipal) {
   1:     SetPrincipal(aPrincipal);
   1:   } else {
   1:     nsIScriptSecurityManager *securityManager =
   1:       nsContentUtils::GetSecurityManager();
   1:     if (securityManager) {
   1:       nsCOMPtr<nsIPrincipal> principal;
   1:       nsresult rv =
   1:         securityManager->GetCodebasePrincipal(mDocumentURI,
   1:                                               getter_AddRefs(principal));
   1:       if (NS_SUCCEEDED(rv)) {
   1:         SetPrincipal(principal);
   1:       }
   1:     }
   1:   }
   1: }
   1: 
   1: nsresult
   1: nsDocument::ResetStylesheetsToURI(nsIURI* aURI)
   1: {
   1:   NS_PRECONDITION(aURI, "Null URI passed to ResetStylesheetsToURI");
   1: 
   1:   mozAutoDocUpdate upd(this, UPDATE_STYLE, PR_TRUE);
   1:   
   1:   // The stylesheets should forget us
   1:   PRInt32 indx = mStyleSheets.Count();
   1:   while (--indx >= 0) {
   1:     nsIStyleSheet* sheet = mStyleSheets[indx];
   1:     sheet->SetOwningDocument(nsnull);
   1: 
   1:     PRBool applicable;
   1:     sheet->GetApplicable(applicable);
   1:     if (applicable) {
   1:       RemoveStyleSheetFromStyleSets(sheet);
   1:     }
   1: 
   1:     // XXX Tell observers?
   1:   }
   1: 
   1:   indx = mCatalogSheets.Count();
   1:   while (--indx >= 0) {
   1:     nsIStyleSheet* sheet = mCatalogSheets[indx];
   1:     sheet->SetOwningDocument(nsnull);
   1: 
   1:     PRBool applicable;
   1:     sheet->GetApplicable(applicable);
   1:     if (applicable) {
1722:       nsPresShellIterator iter(this);
1722:       nsCOMPtr<nsIPresShell> shell;
1722:       while ((shell = iter.GetNextShell())) {
1722:         shell->StyleSet()->RemoveStyleSheet(nsStyleSet::eAgentSheet, sheet);
   1:       }
   1:     }
   1: 
   1:     // XXX Tell observers?
   1:   }
   1: 
   1: 
   1:   // Release all the sheets
   1:   mStyleSheets.Clear();
   1:   // NOTE:  We don't release the catalog sheets.  It doesn't really matter
   1:   // now, but it could in the future -- in which case not releasing them
   1:   // is probably the right thing to do.
   1: 
   1:   // Now reset our inline style and attribute sheets.
   1:   nsresult rv;
   1:   nsStyleSet::sheetType attrSheetType = GetAttrSheetType();
   1:   if (mAttrStyleSheet) {
   1:     // Remove this sheet from all style sets
1722:     nsPresShellIterator iter(this);
1722:     nsCOMPtr<nsIPresShell> shell;
1722:     while ((shell = iter.GetNextShell())) {
1722:       shell->StyleSet()->RemoveStyleSheet(attrSheetType, mAttrStyleSheet);
   1:     }
   1:     rv = mAttrStyleSheet->Reset(aURI);
   1:   } else {
   1:     rv = NS_NewHTMLStyleSheet(getter_AddRefs(mAttrStyleSheet), aURI, this);
   1:   }
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   // Don't use AddStyleSheet, since it'll put the sheet into style
   1:   // sets in the document level, which is not desirable here.
   1:   mAttrStyleSheet->SetOwningDocument(this);
   1:   
   1:   if (mStyleAttrStyleSheet) {
   1:     // Remove this sheet from all style sets
1722:     nsPresShellIterator iter(this);
1722:     nsCOMPtr<nsIPresShell> shell;
1722:     while ((shell = iter.GetNextShell())) {
1722:       shell->StyleSet()->
   1:         RemoveStyleSheet(nsStyleSet::eStyleAttrSheet, mStyleAttrStyleSheet);
   1:     }
   1:     rv = mStyleAttrStyleSheet->Reset(aURI);
   1:   } else {
   1:     rv = NS_NewHTMLCSSStyleSheet(getter_AddRefs(mStyleAttrStyleSheet), aURI,
   1:                                                 this);
   1:   }
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   // The loop over style sets below will handle putting this sheet
   1:   // into style sets as needed.
   1:   mStyleAttrStyleSheet->SetOwningDocument(this);
   1: 
   1:   // Now set up our style sets
1722:   nsPresShellIterator iter(this);
1722:   nsCOMPtr<nsIPresShell> shell;
1722:   while ((shell = iter.GetNextShell())) {
1722:     FillStyleSet(shell->StyleSet());
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: nsStyleSet::sheetType
   1: nsDocument::GetAttrSheetType()
   1: {
   1:   return nsStyleSet::ePresHintSheet;
   1: }
   1: 
   1: void
   1: nsDocument::FillStyleSet(nsStyleSet* aStyleSet)
   1: {
   1:   NS_PRECONDITION(aStyleSet, "Must have a style set");
   1:   NS_PRECONDITION(aStyleSet->SheetCount(nsStyleSet::ePresHintSheet) == 0,
   1:                   "Style set already has a preshint sheet?");
   1:   NS_PRECONDITION(aStyleSet->SheetCount(nsStyleSet::eHTMLPresHintSheet) == 0,
   1:                   "Style set already has a HTML preshint sheet?");
   1:   NS_PRECONDITION(aStyleSet->SheetCount(nsStyleSet::eDocSheet) == 0,
   1:                   "Style set already has document sheets?");
   1:   NS_PRECONDITION(aStyleSet->SheetCount(nsStyleSet::eStyleAttrSheet) == 0,
   1:                   "Style set already has style attr sheets?");
   1:   NS_PRECONDITION(mStyleAttrStyleSheet, "No style attr stylesheet?");
   1:   NS_PRECONDITION(mAttrStyleSheet, "No attr stylesheet?");
   1:   
   1:   aStyleSet->AppendStyleSheet(GetAttrSheetType(), mAttrStyleSheet);
   1: 
   1:   aStyleSet->AppendStyleSheet(nsStyleSet::eStyleAttrSheet,
   1:                               mStyleAttrStyleSheet);
   1: 
   1:   PRInt32 i;
   1:   for (i = mStyleSheets.Count() - 1; i >= 0; --i) {
   1:     nsIStyleSheet* sheet = mStyleSheets[i];
   1:     PRBool sheetApplicable;
   1:     sheet->GetApplicable(sheetApplicable);
   1:     if (sheetApplicable) {
   1:       aStyleSet->AddDocStyleSheet(sheet, this);
   1:     }
   1:   }
   1: 
   1:   for (i = mCatalogSheets.Count() - 1; i >= 0; --i) {
   1:     nsIStyleSheet* sheet = mCatalogSheets[i];
   1:     PRBool sheetApplicable;
   1:     sheet->GetApplicable(sheetApplicable);
   1:     if (sheetApplicable) {
   1:       aStyleSet->AppendStyleSheet(nsStyleSet::eAgentSheet, sheet);
   1:     }
   1:   }
   1: }
   1: 
   1: nsresult
   1: nsDocument::StartDocumentLoad(const char* aCommand, nsIChannel* aChannel,
   1:                               nsILoadGroup* aLoadGroup,
   1:                               nsISupports* aContainer,
   1:                               nsIStreamListener **aDocListener,
   1:                               PRBool aReset, nsIContentSink* aSink)
   1: {
   1: #ifdef PR_LOGGING
   1:   if (gDocumentLeakPRLog && PR_LOG_TEST(gDocumentLeakPRLog, PR_LOG_DEBUG)) {
   1:     nsCOMPtr<nsIURI> uri;
   1:     aChannel->GetURI(getter_AddRefs(uri));
   1:     nsCAutoString spec;
   1:     if (uri)
   1:       uri->GetSpec(spec);
   1:     PR_LogPrint("DOCUMENT %p StartDocumentLoad %s", this, spec.get());
   1:   }
   1: #endif
   1: 
4064:   if (nsCRT::strcmp(kLoadAsData, aCommand) == 0) {
4064:     mLoadedAsData = PR_TRUE;
4064:     // We need to disable script & style loading in this case.
4064:     // We leave them disabled even in EndLoad(), and let anyone
4064:     // who puts the document on display to worry about enabling.
4064: 
4064:     // Do not load/process scripts when loading as data
4064:     ScriptLoader()->SetEnabled(PR_FALSE);
4064: 
4064:     // styles
4064:     CSSLoader()->SetEnabled(PR_FALSE); // Do not load/process styles when loading as data
4064:   }
4064: 
   1:   if (aReset) {
   1:     Reset(aChannel, aLoadGroup);
   1:   }
   1: 
   1:   nsCAutoString contentType;
   1:   if (NS_SUCCEEDED(aChannel->GetContentType(contentType))) {
   1:     // XXX this is only necessary for viewsource:
   1:     nsACString::const_iterator start, end, semicolon;
   1:     contentType.BeginReading(start);
   1:     contentType.EndReading(end);
   1:     semicolon = start;
   1:     FindCharInReadable(';', semicolon, end);
   1:     mContentType = Substring(start, semicolon);
   1:   }
   1: 
   1:   RetrieveRelevantHeaders(aChannel);
   1: 
   1:   mChannel = aChannel;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: void
   1: nsDocument::StopDocumentLoad()
   1: {
   1:   if (mParser) {
   1:     mParser->Terminate();
   1:   }
   1: }
   1: 
   1: void
   1: nsDocument::SetDocumentURI(nsIURI* aURI)
   1: {
   1:   mDocumentURI = NS_TryToMakeImmutable(aURI);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetLastModified(nsAString& aLastModified)
   1: {
   1:   if (!mLastModified.IsEmpty()) {
   1:     aLastModified.Assign(mLastModified);
   1:   } else {
   1:     // If we for whatever reason failed to find the last modified time
   1:     // (or even the current time), fall back to what NS4.x returned.
   1:     aLastModified.Assign(NS_LITERAL_STRING("01/01/1970 00:00:00"));
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsIPrincipal*
   1: nsDocument::GetPrincipal()
   1: {
   1:   return NodePrincipal();
   1: }
   1: 
   1: void
   1: nsDocument::SetPrincipal(nsIPrincipal *aNewPrincipal)
   1: {
   1:   mNodeInfoManager->SetDocumentPrincipal(aNewPrincipal);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetContentType(nsAString& aContentType)
   1: {
   1:   CopyUTF8toUTF16(mContentType, aContentType);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: void
   1: nsDocument::SetContentType(const nsAString& aContentType)
   1: {
   1:   NS_ASSERTION(mContentType.IsEmpty() ||
   1:                mContentType.Equals(NS_ConvertUTF16toUTF8(aContentType)),
   1:                "Do you really want to change the content-type?");
   1: 
   1:   CopyUTF16toUTF8(aContentType, mContentType);
   1: }
   1: 
   1: /* Return true if the document is in the focused top-level window, and is an
   1:  * ancestor of the focused DOMWindow. */
   1: NS_IMETHODIMP
   1: nsDocument::HasFocus(PRBool* aResult)
   1: {
   1:   *aResult = PR_FALSE;
   1: 
   1:   nsPIDOMWindow* window = GetWindow();
   1:   nsIFocusController* focusController = window ?
   1:     window->GetRootFocusController() : nsnull;
   1:   if (!focusController) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   // Does the top-level window have focus?
   1:   PRBool active;
   1:   nsresult rv = focusController->GetActive(&active);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1:   if (!active){
   1:     return NS_OK;
   1:   }
   1: 
   1:   // Is there a focused DOMWindow?
   1:   nsCOMPtr<nsIDOMWindowInternal> focusedWindow;
   1:   rv = focusController->GetFocusedWindow(getter_AddRefs(focusedWindow));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1:   if (!focusedWindow) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   // Are we an ancestor of the focused DOMWindow?
   1:   nsCOMPtr<nsIDOMDocument> domDocument;
   1:   focusedWindow->GetDocument(getter_AddRefs(domDocument));
   1:   nsCOMPtr<nsIDocument> document = do_QueryInterface(domDocument);
   1: 
   1:   for (nsIDocument* currentDoc = document; currentDoc;
   1:        currentDoc = currentDoc->GetParentDocument()) {
   1:     if (currentDoc == this) {
   1:       // Yes, we are an ancestor
   1:       *aResult = PR_TRUE;
   1:       return NS_OK;
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetReferrer(nsAString& aReferrer)
   1: {
   1:   CopyUTF8toUTF16(mReferrer, aReferrer);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetActiveElement(nsIDOMElement **aElement)
   1: {
   1:   *aElement = nsnull;
   1: 
   1:   // Get the focused element.
   1:   nsPIDOMWindow* window = GetWindow();
   1:   if (!window) {
   1:     return NS_ERROR_NOT_AVAILABLE;
   1:   }
   1: 
   1:   nsIFocusController* focusController = window->GetRootFocusController();
   1:   if (!focusController) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   nsCOMPtr<nsIDOMElement> focusedElement;
   1:   focusController->GetFocusedElement(getter_AddRefs(focusedElement));
   1:   nsCOMPtr<nsIContent> content = do_QueryInterface(focusedElement);
   1:   if (content) {
   1:     // Found a focused element.  See if it's in this document.
   1:     nsIDocument* currentDoc = content->GetCurrentDoc();
   1:     if (currentDoc == this) {
   1:       focusedElement.swap(*aElement);
   1:       return NS_OK;
   1:     }
   1: 
   1:     // Not in this document.  If it's in a child document, return the iframe in
   1:     // this document that's an ancestor of the child.
   1:     if (currentDoc) {
   1:       *aElement = CheckAncestryAndGetFrame(currentDoc).get();
   1:       if (*aElement) {
   1:         return NS_OK;
   1:       }
   1:     }
   1:   }
   1: 
   1:   // Couldn't find a focused element.  Check if something like an IFRAME is
   1:   // focused, which will give us a focused window rather than a focused
   1:   // element.
   1:   nsCOMPtr<nsIDOMWindowInternal> focusedWindow;
   1:   focusController->GetFocusedWindow(getter_AddRefs(focusedWindow));
   1:   if (focusedWindow) {
   1:     // Found a focused window.  See if it's in a child of this document.  (If
   1:     // the window's document is this, then we should just fall through to
   1:     // returning the BODY below).
   1:     nsCOMPtr<nsIDOMDocument> domDocument;
   1:     focusedWindow->GetDocument(getter_AddRefs(domDocument));
   1:     nsCOMPtr<nsIDocument> document = do_QueryInterface(domDocument);
   1: 
   1:     if (document && (document != this)) {
   1:       *aElement = CheckAncestryAndGetFrame(document).get();
   1:       if (*aElement) {
   1:         return NS_OK;
   1:       }
   1:     }
   1:   }
   1: 
   1:   // No focused element anywhere in this document.  Try to get the BODY.
   1:   nsCOMPtr<nsIDOMHTMLDocument> htmlDoc =
3233:     do_QueryInterface(static_cast<nsIDocument*>(this));
   1:   if (htmlDoc) {
   1:     nsCOMPtr<nsIDOMHTMLElement> bodyElement;
   1:     htmlDoc->GetBody(getter_AddRefs(bodyElement));
   1:     if (bodyElement) {
   1:       *aElement = bodyElement;
   1:       NS_ADDREF(*aElement);
   1:       return NS_OK;
   1:     }
   1:   }
   1: 
   1:   // If we couldn't get a BODY, return the root element.
   1:   return GetDocumentElement(aElement);
   1: }
   1: 
   1: NS_IMETHODIMP
5440: nsDocument::ElementFromPoint(PRInt32 aX, PRInt32 aY, nsIDOMElement** aReturn)
5440: {
5440:   NS_ENSURE_ARG_POINTER(aReturn);
5440:   *aReturn = nsnull;
5440:   // As per the the spec, we return null if either coord is negative
5440:   if (aX < 0 || aY < 0)
5440:     return NS_OK;
5440: 
5440:   nscoord x = nsPresContext::CSSPixelsToAppUnits(aX);
5440:   nscoord y = nsPresContext::CSSPixelsToAppUnits(aY);
5440:   nsPoint pt(x, y);
5440: 
5440:   // Make sure the layout information we get is up-to-date, and
5440:   // ensure we get a root frame (for everything but XUL)
5440:   FlushPendingNotifications(Flush_Layout);
5440: 
5440:   nsIPresShell *ps = GetPrimaryShell();
5440:   NS_ENSURE_STATE(ps);
5440:   nsIFrame *rootFrame = ps->GetRootFrame();
5440: 
5440:   // XUL docs, unlike HTML, have no frame tree until everything's done loading
5440:   if (!rootFrame)
5440:     return NS_OK; // return null to premature XUL callers as a reminder to wait
5440: 
5440:   nsIFrame *ptFrame = nsLayoutUtils::GetFrameForPoint(rootFrame, pt, PR_TRUE);
5440:   if (!ptFrame)
5440:     return NS_OK;
5440: 
5440:   nsIContent* ptContent = ptFrame->GetContent();
5440:   NS_ENSURE_STATE(ptContent);
5440: 
5440:   // If the content is in a subdocument, try to get the element from |this| doc
5440:   nsIDocument *currentDoc = ptContent->GetCurrentDoc();
5440:   if (currentDoc && (currentDoc != this)) {
5440:     *aReturn = CheckAncestryAndGetFrame(currentDoc).get();
5440:     return NS_OK;
5440:   }
5440: 
5440:   // If we have an anonymous element (such as an internal div from a textbox),
5440:   // or a node that isn't an element (such as a text frame node),
5440:   // replace it with the first non-anonymous parent node of type element.
5440:   while (ptContent &&
5440:          !ptContent->IsNodeOfType(nsINode::eELEMENT) ||
5440:          ptContent->GetBindingParent() ||
5440:          ptContent->IsNativeAnonymous()) {
5440:     ptContent = ptContent->GetParent();
5440:   }
5440:  
5440:   if (ptContent)
5440:     CallQueryInterface(ptContent, aReturn);
5440:   return NS_OK;
5440: }
5440: 
5440: NS_IMETHODIMP
   1: nsDocument::GetElementsByClassName(const nsAString& aClasses,
   1:                                    nsIDOMNodeList** aReturn)
   1: {
6158:   return GetElementsByClassNameHelper(this, aClasses, aReturn);
   1: }
   1: 
   1: 
   1: // static GetElementsByClassName helpers
   1: nsresult
6158: nsDocument::GetElementsByClassNameHelper(nsINode* aRootNode,
   1:                                          const nsAString& aClasses,
   1:                                          nsIDOMNodeList** aReturn)
   1: {
6158:   NS_PRECONDITION(aRootNode, "Must have root node");
6158:   
   1:   nsAttrValue attrValue;
   1:   attrValue.ParseAtomArray(aClasses);
   1:   // nsAttrValue::Equals is sensitive to order, so we'll send an array
   1:   nsCOMArray<nsIAtom>* classes = new nsCOMArray<nsIAtom>;
   1:   NS_ENSURE_TRUE(classes, NS_ERROR_OUT_OF_MEMORY);
   1: 
   1:   if (attrValue.Type() == nsAttrValue::eAtomArray) {
   1:     classes->AppendObjects(*(attrValue.GetAtomArrayValue()));
   1:   } else if (!attrValue.IsEmptyString()) {
   1:     classes->AppendObject(attrValue.GetAtomValue());
   1:   }
   1:   
   1:   nsBaseContentList* elements;
6158:   if (classes->Count() > 0) {
6158:     elements = new nsContentList(aRootNode, MatchClassNames,
   1:                                  DestroyClassNameArray, classes);
   1:   } else {
   1:     elements = new nsBaseContentList();
   1:   }
   1:   if (!elements) {
   1:     delete classes;
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: 
   1:   *aReturn = elements;
   1:   NS_ADDREF(*aReturn);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: // static
   1: PRBool
   1: nsDocument::MatchClassNames(nsIContent* aContent,
   1:                             PRInt32 aNamespaceID,
   1:                             nsIAtom* aAtom, void* aData)
   1: {
   1:   // We can't match if there are no class names
   1:   const nsAttrValue* classAttr = aContent->GetClasses();
   1:   if (!classAttr) {
   1:     return PR_FALSE;
   1:   }
   1:   
   1:   // need to match *all* of the classes
3233:   nsCOMArray<nsIAtom>* classes = static_cast<nsCOMArray<nsIAtom>*>(aData);
   1:   PRInt32 length = classes->Count();
   1:   PRInt32 i;
   1:   for (i = 0; i < length; ++i) {
   1:     if (!classAttr->Contains(classes->ObjectAt(i), eCaseMatters)) {
   1:       return PR_FALSE;
   1:     }
   1:   }
   1:   
   1:   return PR_TRUE;
   1: }
   1: 
   1: // static
   1: void
   1: nsDocument::DestroyClassNameArray(void* aData)
   1: {
3233:   nsCOMArray<nsIAtom>* classes = static_cast<nsCOMArray<nsIAtom>*>(aData);
   1:   delete classes;
   1: }
   1: 
   1: nsresult
   1: nsDocument::SetBaseURI(nsIURI* aURI)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   if (aURI) {
   1:     rv = nsContentUtils::GetSecurityManager()->
   1:       CheckLoadURIWithPrincipal(NodePrincipal(), aURI,
   1:                                 nsIScriptSecurityManager::STANDARD);
   1:     if (NS_SUCCEEDED(rv)) {
   1:       mDocumentBaseURI = NS_TryToMakeImmutable(aURI);
   1:     }
   1:   } else {
   1:     mDocumentBaseURI = nsnull;
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: void
   1: nsDocument::GetBaseTarget(nsAString &aBaseTarget) const
   1: {
   1:   aBaseTarget.Assign(mBaseTarget);
   1: }
   1: 
   1: void
   1: nsDocument::SetBaseTarget(const nsAString &aBaseTarget)
   1: {
   1:   mBaseTarget.Assign(aBaseTarget);
   1: }
   1: 
   1: void
   1: nsDocument::SetDocumentCharacterSet(const nsACString& aCharSetID)
   1: {
   1:   if (!mCharacterSet.Equals(aCharSetID)) {
   1:     mCharacterSet = aCharSetID;
   1: 
   1: #ifdef DEBUG
   1:     nsCOMPtr<nsICharsetAlias> calias(do_GetService(NS_CHARSETALIAS_CONTRACTID));
   1:     if (calias) {
   1:       nsCAutoString canonicalName;
   1:       calias->GetPreferred(aCharSetID, canonicalName);
   1:       NS_ASSERTION(canonicalName.Equals(aCharSetID),
   1:                    "charset name must be canonical");
   1:     }
   1: #endif
   1: 
   1:     PRInt32 n = mCharSetObservers.Count();
   1: 
   1:     for (PRInt32 i = 0; i < n; i++) {
   1:       nsIObserver* observer =
3233:         static_cast<nsIObserver *>(mCharSetObservers.ElementAt(i));
3233: 
3233:       observer->Observe(static_cast<nsIDocument *>(this), "charset",
   1:                         NS_ConvertASCIItoUTF16(aCharSetID).get());
   1:     }
   1:   }
   1: }
   1: 
   1: nsresult
   1: nsDocument::AddCharSetObserver(nsIObserver* aObserver)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aObserver);
   1: 
   1:   NS_ENSURE_TRUE(mCharSetObservers.AppendElement(aObserver), NS_ERROR_FAILURE);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: void
   1: nsDocument::RemoveCharSetObserver(nsIObserver* aObserver)
   1: {
   1:   mCharSetObservers.RemoveElement(aObserver);
   1: }
   1: 
   1: void
   1: nsDocument::GetHeaderData(nsIAtom* aHeaderField, nsAString& aData) const
   1: {
   1:   aData.Truncate();
   1:   const nsDocHeaderData* data = mHeaderData;
   1:   while (data) {
   1:     if (data->mField == aHeaderField) {
   1:       aData = data->mData;
   1: 
   1:       break;
   1:     }
   1:     data = data->mNext;
   1:   }
   1: }
   1: 
   1: void
   1: nsDocument::SetHeaderData(nsIAtom* aHeaderField, const nsAString& aData)
   1: {
   1:   if (!aHeaderField) {
   1:     NS_ERROR("null headerField");
   1:     return;
   1:   }
   1: 
   1:   if (!mHeaderData) {
   1:     if (!aData.IsEmpty()) { // don't bother storing empty string
   1:       mHeaderData = new nsDocHeaderData(aHeaderField, aData);
   1:     }
   1:   }
   1:   else {
   1:     nsDocHeaderData* data = mHeaderData;
   1:     nsDocHeaderData** lastPtr = &mHeaderData;
   1:     PRBool found = PR_FALSE;
   1:     do {  // look for existing and replace
   1:       if (data->mField == aHeaderField) {
   1:         if (!aData.IsEmpty()) {
   1:           data->mData.Assign(aData);
   1:         }
   1:         else {  // don't store empty string
   1:           *lastPtr = data->mNext;
   1:           data->mNext = nsnull;
   1:           delete data;
   1:         }
   1:         found = PR_TRUE;
   1: 
   1:         break;
   1:       }
   1:       lastPtr = &(data->mNext);
   1:       data = *lastPtr;
   1:     } while (data);
   1: 
   1:     if (!aData.IsEmpty() && !found) {
   1:       // didn't find, append
   1:       *lastPtr = new nsDocHeaderData(aHeaderField, aData);
   1:     }
   1:   }
   1: 
   1:   if (aHeaderField == nsGkAtoms::headerContentLanguage) {
   1:     CopyUTF16toUTF8(aData, mContentLanguage);
   1:   }
   1: 
   1:   // Set the default script-type on the root element.
   1:   if (aHeaderField == nsGkAtoms::headerContentScriptType) {
   1:     nsIContent *root = GetRootContent();
   1:     if (root) {
   1:       // Get the script-type ID for this value.
   1:       nsresult rv;
   1:       nsCOMPtr<nsIScriptRuntime> runtime;
   1:       rv = NS_GetScriptRuntime(aData, getter_AddRefs(runtime));
   1:       if (NS_FAILED(rv) || runtime == nsnull) {
   1:         NS_WARNING("The script-type is unknown");
   1:       } else {
   1:         root->SetScriptTypeID(runtime->GetScriptTypeID());
   1:       }
   1:     }
   1:   }
   1: 
   1:   if (aHeaderField == nsGkAtoms::headerDefaultStyle) {
   1:     // Only mess with our stylesheets if we don't have a lastStyleSheetSet, per
   1:     // spec.
   1:     if (DOMStringIsNull(mLastStyleSheetSet)) {
   1:       // Calling EnableStyleSheetsForSetInternal, not SetSelectedStyleSheetSet,
   1:       // per spec.  The idea here is that we're changing our preferred set and
   1:       // that shouldn't change the value of lastStyleSheetSet.  Also, we're
   1:       // using the Internal version so we can update the CSSLoader and not have
   1:       // to worry about null strings.
   1:       EnableStyleSheetsForSetInternal(aData, PR_TRUE);
   1:     }
   1:   }
   1: 
   1:   if (aHeaderField == nsGkAtoms::refresh) {
   1:     // We get into this code before we have a script global yet, so get to
   1:     // our container via mDocumentContainer.
   1:     nsCOMPtr<nsIRefreshURI> refresher = do_QueryReferent(mDocumentContainer);
   1:     if (refresher) {
   1:       // Note: using mDocumentURI instead of mBaseURI here, for consistency
   1:       // (used to just use the current URI of our webnavigation, but that
   1:       // should really be the same thing).  Note that this code can run
   1:       // before the current URI of the webnavigation has been updated, so we
   1:       // can't assert equality here.
   1:       refresher->SetupRefreshURIFromHeader(mDocumentURI,
   1:                                            NS_LossyConvertUTF16toASCII(aData));
   1:     }
   1:   }
   1: }
   1: 
   1: PRBool
   1: nsDocument::TryChannelCharset(nsIChannel *aChannel,
   1:                               PRInt32& aCharsetSource,
   1:                               nsACString& aCharset)
   1: {
   1:   if(kCharsetFromChannel <= aCharsetSource) {
   1:     return PR_TRUE;
   1:   }
   1: 
   1:   if (aChannel) {
   1:     nsCAutoString charsetVal;
   1:     nsresult rv = aChannel->GetContentCharset(charsetVal);
   1:     if (NS_SUCCEEDED(rv)) {
   1:       nsCOMPtr<nsICharsetAlias> calias(do_GetService(NS_CHARSETALIAS_CONTRACTID));
   1:       if (calias) {
   1:         nsCAutoString preferred;
   1:         rv = calias->GetPreferred(charsetVal,
   1:                                   preferred);
   1:         if(NS_SUCCEEDED(rv)) {
   1:           aCharset = preferred;
   1:           aCharsetSource = kCharsetFromChannel;
   1:           return PR_TRUE;
   1:         }
   1:       }
   1:     }
   1:   }
   1:   return PR_FALSE;
   1: }
   1: 
   1: nsresult
   1: nsDocument::CreateShell(nsPresContext* aContext, nsIViewManager* aViewManager,
   1:                         nsStyleSet* aStyleSet,
   1:                         nsIPresShell** aInstancePtrResult)
   1: {
   1:   // Don't add anything here.  Add it to |doCreateShell| instead.
   1:   // This exists so that subclasses can pass other values for the 4th
   1:   // parameter some of the time.
   1:   return doCreateShell(aContext, aViewManager, aStyleSet,
   1:                        eCompatibility_FullStandards, aInstancePtrResult);
   1: }
   1: 
   1: nsresult
   1: nsDocument::doCreateShell(nsPresContext* aContext,
   1:                           nsIViewManager* aViewManager, nsStyleSet* aStyleSet,
   1:                           nsCompatibility aCompatMode,
   1:                           nsIPresShell** aInstancePtrResult)
   1: {
   1:   *aInstancePtrResult = nsnull;
   1: 
   1:   NS_ENSURE_FALSE(mShellsAreHidden, NS_ERROR_FAILURE);
   1: 
   1:   FillStyleSet(aStyleSet);
   1:   
   1:   nsCOMPtr<nsIPresShell> shell;
   1:   nsresult rv = NS_NewPresShell(getter_AddRefs(shell));
   1:   if (NS_FAILED(rv)) {
   1:     return rv;
   1:   }
   1: 
   1:   rv = shell->Init(this, aContext, aViewManager, aStyleSet, aCompatMode);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   // Note: we don't hold a ref to the shell (it holds a ref to us)
1722:   NS_ENSURE_TRUE(mPresShells.AppendObserver(shell), NS_ERROR_OUT_OF_MEMORY);
   1:   shell.swap(*aInstancePtrResult);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: PRBool
   1: nsDocument::DeleteShell(nsIPresShell* aShell)
   1: {
1722:   return mPresShells.RemoveObserver(aShell);
1722: }
1722: 
   1: 
 981: nsIPresShell *
 981: nsDocument::GetPrimaryShell() const
 981: {
1722:   return mShellsAreHidden ? nsnull : mPresShells.SafeObserverAt(0);
   1: }
   1: 
   1: PR_STATIC_CALLBACK(void)
   1: SubDocClearEntry(PLDHashTable *table, PLDHashEntryHdr *entry)
   1: {
3233:   SubDocMapEntry *e = static_cast<SubDocMapEntry *>(entry);
   1: 
   1:   NS_RELEASE(e->mKey);
   1:   NS_IF_RELEASE(e->mSubDocument);
   1: }
   1: 
   1: PR_STATIC_CALLBACK(PRBool)
   1: SubDocInitEntry(PLDHashTable *table, PLDHashEntryHdr *entry, const void *key)
   1: {
   1:   SubDocMapEntry *e =
3233:     const_cast<SubDocMapEntry *>
3233:               (static_cast<const SubDocMapEntry *>(entry));
3233: 
3233:   e->mKey = const_cast<nsIContent *>
3233:                       (static_cast<const nsIContent *>(key));
   1:   NS_ADDREF(e->mKey);
   1: 
   1:   e->mSubDocument = nsnull;
   1:   return PR_TRUE;
   1: }
   1: 
   1: nsresult
   1: nsDocument::SetSubDocumentFor(nsIContent *aContent, nsIDocument* aSubDoc)
   1: {
   1:   NS_ENSURE_TRUE(aContent, NS_ERROR_UNEXPECTED);
   1: 
   1:   if (!aSubDoc) {
   1:     // aSubDoc is nsnull, remove the mapping
   1: 
   1:     if (mSubDocuments) {
   1:       SubDocMapEntry *entry =
3233:         static_cast<SubDocMapEntry*>
3233:                    (PL_DHashTableOperate(mSubDocuments, aContent,
   1:                                             PL_DHASH_LOOKUP));
   1: 
   1:       if (PL_DHASH_ENTRY_IS_BUSY(entry)) {
   1:         entry->mSubDocument->SetParentDocument(nsnull);
   1: 
   1:         PL_DHashTableRawRemove(mSubDocuments, entry);
   1:       }
   1:     }
   1:   } else {
   1:     if (!mSubDocuments) {
   1:       // Create a new hashtable
   1: 
   1:       static PLDHashTableOps hash_table_ops =
   1:       {
   1:         PL_DHashAllocTable,
   1:         PL_DHashFreeTable,
   1:         PL_DHashVoidPtrKeyStub,
   1:         PL_DHashMatchEntryStub,
   1:         PL_DHashMoveEntryStub,
   1:         SubDocClearEntry,
   1:         PL_DHashFinalizeStub,
   1:         SubDocInitEntry
   1:       };
   1: 
   1:       mSubDocuments = PL_NewDHashTable(&hash_table_ops, nsnull,
   1:                                        sizeof(SubDocMapEntry), 16);
   1:       if (!mSubDocuments) {
   1:         return NS_ERROR_OUT_OF_MEMORY;
   1:       }
   1:     }
   1: 
   1:     // Add a mapping to the hash table
   1:     SubDocMapEntry *entry =
3233:       static_cast<SubDocMapEntry*>
3233:                  (PL_DHashTableOperate(mSubDocuments, aContent,
   1:                                           PL_DHASH_ADD));
   1: 
   1:     if (!entry) {
   1:       return NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1: 
   1:     if (entry->mSubDocument) {
   1:       entry->mSubDocument->SetParentDocument(nsnull);
   1: 
   1:       // Release the old sub document
   1:       NS_RELEASE(entry->mSubDocument);
   1:     }
   1: 
   1:     entry->mSubDocument = aSubDoc;
   1:     NS_ADDREF(entry->mSubDocument);
   1: 
   1:     aSubDoc->SetParentDocument(this);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsIDocument*
   1: nsDocument::GetSubDocumentFor(nsIContent *aContent) const
   1: {
   1:   if (mSubDocuments) {
   1:     SubDocMapEntry *entry =
3233:       static_cast<SubDocMapEntry*>
3233:                  (PL_DHashTableOperate(mSubDocuments, aContent,
   1:                                           PL_DHASH_LOOKUP));
   1: 
   1:     if (PL_DHASH_ENTRY_IS_BUSY(entry)) {
   1:       return entry->mSubDocument;
   1:     }
   1:   }
   1: 
   1:   return nsnull;
   1: }
   1: 
   1: PR_STATIC_CALLBACK(PLDHashOperator)
   1: FindContentEnumerator(PLDHashTable *table, PLDHashEntryHdr *hdr,
   1:                       PRUint32 number, void *arg)
   1: {
3233:   SubDocMapEntry *entry = static_cast<SubDocMapEntry*>(hdr);
3233:   FindContentData *data = static_cast<FindContentData*>(arg);
   1: 
   1:   if (entry->mSubDocument == data->mSubDocument) {
   1:     data->mResult = entry->mKey;
   1: 
   1:     return PL_DHASH_STOP;
   1:   }
   1: 
   1:   return PL_DHASH_NEXT;
   1: }
   1: 
   1: nsIContent*
   1: nsDocument::FindContentForSubDocument(nsIDocument *aDocument) const
   1: {
   1:   NS_ENSURE_TRUE(aDocument, nsnull);
   1: 
   1:   if (!mSubDocuments) {
   1:     return nsnull;
   1:   }
   1: 
   1:   FindContentData data(aDocument);
   1:   PL_DHashTableEnumerate(mSubDocuments, FindContentEnumerator, &data);
   1: 
   1:   return data.mResult;
   1: }
   1: 
   1: PRBool
   1: nsDocument::IsNodeOfType(PRUint32 aFlags) const
   1: {
   1:     return !(aFlags & ~eDOCUMENT);
   1: }
   1: 
   1: nsIContent *
   1: nsDocument::GetChildAt(PRUint32 aIndex) const
   1: {
   1:   return mChildren.GetSafeChildAt(aIndex);
   1: }
   1: 
   1: PRInt32
   1: nsDocument::IndexOf(nsINode* aPossibleChild) const
   1: {
   1:   return mChildren.IndexOfChild(aPossibleChild);
   1: }
   1: 
   1: PRUint32
   1: nsDocument::GetChildCount() const
   1: {
   1:   return mChildren.ChildCount();
   1: }
   1: 
   1: nsresult
   1: nsDocument::InsertChildAt(nsIContent* aKid, PRUint32 aIndex,
   1:                           PRBool aNotify)
   1: {
   1:   if (aKid->IsNodeOfType(nsINode::eELEMENT)) {
   1:     if (mRootContent) {
   1:       NS_ERROR("Inserting element child when we already have one");
   1:       return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
   1:     }
   1: 
   1:     mRootContent = aKid;
   1:   }
   1:   
   1:   nsresult rv = nsGenericElement::doInsertChildAt(aKid, aIndex, aNotify,
   1:                                                   nsnull, this, mChildren);
   1: 
   1:   if (NS_FAILED(rv) && mRootContent == aKid) {
   1:     PRInt32 kidIndex = mChildren.IndexOfChild(aKid);
   1:     NS_ASSERTION(kidIndex == -1,
   1:                  "Error result and still have same root content but it's in "
   1:                  "our child list?");
   1:     // Check to make sure that we're keeping mRootContent in sync with our
   1:     // child list... but really, if kidIndex != -1 we have major problems
   1:     // coming up; hence the assert above.  This check is just a feeble attempt
   1:     // to not die due to mRootContent being bogus.
   1:     if (kidIndex == -1) {
   1:       mRootContent = nsnull;
   1:     }
   1:   }
   1: 
   1: #ifdef DEBUG
   1:   VerifyRootContentState();
   1: #endif
   1: 
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsDocument::AppendChildTo(nsIContent* aKid, PRBool aNotify)
   1: {
   1:   // Make sure to _not_ call the subclass InsertChildAt here.  If
   1:   // subclasses wanted to hook into this stuff, they would have
   1:   // overridden AppendChildTo.
   1:   // XXXbz maybe this should just be a non-virtual method on nsINode?
   1:   // Feels that way to me...
   1:   return nsDocument::InsertChildAt(aKid, GetChildCount(), aNotify);
   1: }
   1: 
   1: nsresult
   1: nsDocument::RemoveChildAt(PRUint32 aIndex, PRBool aNotify)
   1: {
   1:   nsCOMPtr<nsIContent> oldKid = GetChildAt(aIndex);
   1:   nsresult rv = NS_OK;
   1:   if (oldKid) {
   1:     if (oldKid == mRootContent) {
   1:       NS_ASSERTION(oldKid->IsNodeOfType(nsINode::eELEMENT),
   1:                    "Non-element root content?");
   1:       // Destroy the link map up front and null out mRootContent before we mess
   1:       // with the child list.  Hopefully no one in doRemoveChildAt will compare
   1:       // the content being removed to GetRootContent()....  Need to do this
   1:       // before calling doRemoveChildAt because DOM events might fire while
   1:       // we're inside the doInsertChildAt call and want to set a new
   1:       // mRootContent; if they do that, setting mRootContent after the
   1:       // doRemoveChildAt call would clobber state.  If we ever fix the issue of
   1:       // DOM events firing at inconvenient times, consider changing the order
   1:       // here.  Just make sure we DestroyLinkMap() before unbinding the
   1:       // content.
   1:       DestroyLinkMap();
   1:       mRootContent = nsnull;
   1:     }
   1:     
   1:     rv = nsGenericElement::doRemoveChildAt(aIndex, aNotify, oldKid,
   1:                                            nsnull, this, mChildren);
   1:     if (NS_FAILED(rv) && mChildren.IndexOfChild(oldKid) != -1) {
   1:       mRootContent = oldKid;
   1:     }
   1:   }
   1: 
   1: #ifdef DEBUG
   1:   VerifyRootContentState();
   1: #endif
   1: 
   1:   return rv;
   1: }
   1: 
   1: #ifdef DEBUG
   1: void
   1: nsDocument::VerifyRootContentState()
   1: {
   1:   nsIContent* elementChild = nsnull;
   1:   for (PRUint32 i = 0; i < GetChildCount(); ++i) {
   1:     nsIContent* kid = GetChildAt(i);
   1:     NS_ASSERTION(kid, "Must have kid here");
   1: 
   1:     if (kid->IsNodeOfType(nsINode::eELEMENT)) {
   1:       NS_ASSERTION(!elementChild, "Multiple element kids?");
   1:       elementChild = kid;
   1:     }
   1:   }
   1: 
   1:   NS_ASSERTION(mRootContent == elementChild, "Incorrect mRootContent");
   1: }
   1: #endif // DEBUG
   1: 
   1: PRInt32
   1: nsDocument::GetNumberOfStyleSheets() const
   1: {
   1:   return mStyleSheets.Count();
   1: }
   1: 
   1: nsIStyleSheet*
   1: nsDocument::GetStyleSheetAt(PRInt32 aIndex) const
   1: {
   1:   NS_ENSURE_TRUE(0 <= aIndex && aIndex < mStyleSheets.Count(), nsnull);
   1:   return mStyleSheets[aIndex];
   1: }
   1: 
   1: PRInt32
   1: nsDocument::GetIndexOfStyleSheet(nsIStyleSheet* aSheet) const
   1: {
   1:   return mStyleSheets.IndexOf(aSheet);
   1: }
   1: 
   1: void
   1: nsDocument::AddStyleSheetToStyleSets(nsIStyleSheet* aSheet)
   1: {
1722:   nsPresShellIterator iter(this);
1722:   nsCOMPtr<nsIPresShell> shell;
1722:   while ((shell = iter.GetNextShell())) {
1722:     shell->StyleSet()->AddDocStyleSheet(aSheet, this);
   1:   }
   1: }
   1: 
   1: void
   1: nsDocument::AddStyleSheet(nsIStyleSheet* aSheet)
   1: {
   1:   NS_PRECONDITION(aSheet, "null arg");
   1:   mStyleSheets.AppendObject(aSheet);
   1:   aSheet->SetOwningDocument(this);
   1: 
   1:   PRBool applicable;
   1:   aSheet->GetApplicable(applicable);
   1: 
   1:   if (applicable) {
   1:     AddStyleSheetToStyleSets(aSheet);
   1:   }
   1: 
   1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleSheetAdded, (this, aSheet, PR_TRUE));
   1: }
   1: 
   1: void
   1: nsDocument::RemoveStyleSheetFromStyleSets(nsIStyleSheet* aSheet)
   1: {
1722:   nsPresShellIterator iter(this);
1722:   nsCOMPtr<nsIPresShell> shell;
1722:   while ((shell = iter.GetNextShell())) {
1722:     shell->StyleSet()->RemoveStyleSheet(nsStyleSet::eDocSheet, aSheet);
1722:   }
   1: }
   1: 
   1: void
   1: nsDocument::RemoveStyleSheet(nsIStyleSheet* aSheet)
   1: {
   1:   NS_PRECONDITION(aSheet, "null arg");
   1:   nsCOMPtr<nsIStyleSheet> sheet = aSheet; // hold ref so it won't die too soon
   1: 
   1:   if (!mStyleSheets.RemoveObject(aSheet)) {
   1:     NS_NOTREACHED("stylesheet not found");
   1:     return;
   1:   }
   1: 
   1:   if (!mIsGoingAway) {
   1:     PRBool applicable = PR_TRUE;
   1:     aSheet->GetApplicable(applicable);
   1:     if (applicable) {
   1:       RemoveStyleSheetFromStyleSets(aSheet);
   1:     }
   1: 
   1:     NS_DOCUMENT_NOTIFY_OBSERVERS(StyleSheetRemoved, (this, aSheet, PR_TRUE));
   1:   }
   1: 
   1:   aSheet->SetOwningDocument(nsnull);
   1: }
   1: 
   1: void
   1: nsDocument::UpdateStyleSheets(nsCOMArray<nsIStyleSheet>& aOldSheets,
   1:                               nsCOMArray<nsIStyleSheet>& aNewSheets)
   1: {
   1:   BeginUpdate(UPDATE_STYLE);
   1: 
   1:   // XXX Need to set the sheet on the ownernode, if any
   1:   NS_PRECONDITION(aOldSheets.Count() == aNewSheets.Count(),
   1:                   "The lists must be the same length!");
   1:   PRInt32 count = aOldSheets.Count();
   1: 
   1:   nsCOMPtr<nsIStyleSheet> oldSheet;
   1:   PRInt32 i;
   1:   for (i = 0; i < count; ++i) {
   1:     oldSheet = aOldSheets[i];
   1: 
   1:     // First remove the old sheet.
   1:     NS_ASSERTION(oldSheet, "None of the old sheets should be null");
   1:     PRInt32 oldIndex = mStyleSheets.IndexOf(oldSheet);
   1:     RemoveStyleSheet(oldSheet);  // This does the right notifications
   1: 
   1:     // Now put the new one in its place.  If it's null, just ignore it.
   1:     nsIStyleSheet* newSheet = aNewSheets[i];
   1:     if (newSheet) {
   1:       mStyleSheets.InsertObjectAt(newSheet, oldIndex);
   1:       newSheet->SetOwningDocument(this);
   1:       PRBool applicable = PR_TRUE;
   1:       newSheet->GetApplicable(applicable);
   1:       if (applicable) {
   1:         AddStyleSheetToStyleSets(newSheet);
   1:       }
   1: 
   1:       NS_DOCUMENT_NOTIFY_OBSERVERS(StyleSheetAdded, (this, newSheet, PR_TRUE));
   1:     }
   1:   }
   1: 
   1:   EndUpdate(UPDATE_STYLE);
   1: }
   1: 
   1: void
   1: nsDocument::InsertStyleSheetAt(nsIStyleSheet* aSheet, PRInt32 aIndex)
   1: {
   1:   NS_PRECONDITION(aSheet, "null ptr");
   1:   mStyleSheets.InsertObjectAt(aSheet, aIndex);
   1: 
   1:   aSheet->SetOwningDocument(this);
   1: 
   1:   PRBool applicable;
   1:   aSheet->GetApplicable(applicable);
   1: 
   1:   if (applicable) {
   1:     AddStyleSheetToStyleSets(aSheet);
   1:   }
   1: 
   1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleSheetAdded, (this, aSheet, PR_TRUE));
   1: }
   1: 
   1: 
   1: void
   1: nsDocument::SetStyleSheetApplicableState(nsIStyleSheet* aSheet,
   1:                                          PRBool aApplicable)
   1: {
   1:   NS_PRECONDITION(aSheet, "null arg");
   1: 
   1:   // If we're actually in the document style sheet list
   1:   if (-1 != mStyleSheets.IndexOf(aSheet)) {
   1:     if (aApplicable) {
   1:       AddStyleSheetToStyleSets(aSheet);
   1:     } else {
   1:       RemoveStyleSheetFromStyleSets(aSheet);
   1:     }
   1:   }
   1: 
   1:   // We have to always notify, since this will be called for sheets
   1:   // that are children of sheets in our style set, as well as some
   1:   // sheets for nsHTMLEditor.
   1: 
   1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleSheetApplicableStateChanged,
   1:                                (this, aSheet, aApplicable));
   1: }
   1: 
   1: // These three functions are a lot like the implementation of the
   1: // corresponding API for regular stylesheets.
   1: 
   1: PRInt32
   1: nsDocument::GetNumberOfCatalogStyleSheets() const
   1: {
   1:   return mCatalogSheets.Count();
   1: }
   1: 
   1: nsIStyleSheet*
   1: nsDocument::GetCatalogStyleSheetAt(PRInt32 aIndex) const
   1: {
   1:   NS_ENSURE_TRUE(0 <= aIndex && aIndex < mCatalogSheets.Count(), nsnull);
   1:   return mCatalogSheets[aIndex];
   1: }
   1: 
   1: void
   1: nsDocument::AddCatalogStyleSheet(nsIStyleSheet* aSheet)
   1: {
   1:   mCatalogSheets.AppendObject(aSheet);
   1:   aSheet->SetOwningDocument(this);
   1: 
   1:   PRBool applicable;
   1:   aSheet->GetApplicable(applicable);
   1:                                                                                 
   1:   if (applicable) {
   1:     // This is like |AddStyleSheetToStyleSets|, but for an agent sheet.
1722:     nsPresShellIterator iter(this);
1722:     nsCOMPtr<nsIPresShell> shell;
1722:     while ((shell = iter.GetNextShell())) {
1722:       shell->StyleSet()->AppendStyleSheet(nsStyleSet::eAgentSheet, aSheet);
1722:     }
   1:   }
   1:                                                                                 
   1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleSheetAdded, (this, aSheet, PR_FALSE));
   1: }
   1: 
   1: void
   1: nsDocument::EnsureCatalogStyleSheet(const char *aStyleSheetURI)
   1: {
   1:   nsICSSLoader* cssLoader = CSSLoader();
   1:   PRBool enabled;
   1:   if (NS_SUCCEEDED(cssLoader->GetEnabled(&enabled)) && enabled) {
   1:     PRInt32 sheetCount = GetNumberOfCatalogStyleSheets();
   1:     for (PRInt32 i = 0; i < sheetCount; i++) {
   1:       nsIStyleSheet* sheet = GetCatalogStyleSheetAt(i);
   1:       NS_ASSERTION(sheet, "unexpected null stylesheet in the document");
   1:       if (sheet) {
   1:         nsCOMPtr<nsIURI> uri;
   1:         sheet->GetSheetURI(getter_AddRefs(uri));
   1:         nsCAutoString uriStr;
   1:         uri->GetSpec(uriStr);
   1:         if (uriStr.Equals(aStyleSheetURI))
   1:           return;
   1:       }
   1:     }
   1: 
   1:     nsCOMPtr<nsIURI> uri;
   1:     NS_NewURI(getter_AddRefs(uri), aStyleSheetURI);
   1:     if (uri) {
   1:       nsCOMPtr<nsICSSStyleSheet> sheet;
   1:       cssLoader->LoadSheetSync(uri, PR_TRUE, getter_AddRefs(sheet));
   1:       if (sheet) {
   1:         BeginUpdate(UPDATE_STYLE);
   1:         AddCatalogStyleSheet(sheet);
   1:         EndUpdate(UPDATE_STYLE);
   1:       }
   1:     }
   1:   }
   1: }
   1: 
   1: nsIScriptGlobalObject*
   1: nsDocument::GetScriptGlobalObject() const
   1: {
   1:    // If we're going away, we've already released the reference to our
   1:    // ScriptGlobalObject.  We can, however, try to obtain it for the
   1:    // caller through our docshell.
   1: 
   1:    if (mIsGoingAway) {
   1:      nsCOMPtr<nsIInterfaceRequestor> requestor =
   1:        do_QueryReferent(mDocumentContainer);
   1:      if (requestor) {
   1:        nsCOMPtr<nsIScriptGlobalObject> globalObject = do_GetInterface(requestor);
   1:        return globalObject;
   1:      }
   1:    }
   1: 
   1:    return mScriptGlobalObject;
   1: }
   1: 
   1: nsIScriptGlobalObject*
   1: nsDocument::GetScopeObject()
   1: {
   1:   nsCOMPtr<nsIScriptGlobalObject> scope(do_QueryReferent(mScopeObject));
   1:   return scope;
   1: }
   1: 
   1: void
   1: nsDocument::SetScriptGlobalObject(nsIScriptGlobalObject *aScriptGlobalObject)
   1: {
   1: #ifdef DEBUG
   1:   {
   1:     nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(aScriptGlobalObject));
   1: 
   1:     NS_ASSERTION(!win || win->IsInnerWindow(),
   1:                  "Script global object must be an inner window!");
   1:   }
   1: #endif
   1: 
   1:   if (mScriptGlobalObject && !aScriptGlobalObject) {
   1:     // We're detaching from the window.  We need to grab a pointer to
   1:     // our layout history state now.
   1:     mLayoutHistoryState = GetLayoutHistoryState();
   1: 
   1:     // Also make sure to remove our onload blocker now if we haven't done it yet
   1:     if (mOnloadBlockCount != 0) {
   1:       nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
   1:       if (loadGroup) {
   1:         loadGroup->RemoveRequest(mOnloadBlocker, nsnull, NS_OK);
   1:       }
   1:     }
   1:   }
   1: 
   1:   mScriptGlobalObject = aScriptGlobalObject;
   1: 
   1:   if (aScriptGlobalObject) {
   1:     // Go back to using the docshell for the layout history state
   1:     mLayoutHistoryState = nsnull;
   1:     mScopeObject = do_GetWeakReference(aScriptGlobalObject);
   1:   }
   1: }
   1: 
   1: nsPIDOMWindow *
   1: nsDocument::GetWindow()
   1: {
   1:   nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(GetScriptGlobalObject()));
   1: 
   1:   if (!win) {
   1:     return nsnull;
   1:   }
   1: 
   1:   return win->GetOuterWindow();
   1: }
   1: 
   1: nsPIDOMWindow *
   1: nsDocument::GetInnerWindow()
   1: {
   1:   nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(GetScriptGlobalObject()));
   1: 
   1:   return win;
   1: }
   1: 
   1: nsScriptLoader*
2007: nsDocument::ScriptLoader()
2007: {
   1:   return mScriptLoader;
   1: }
   1: 
   1: void
   1: nsDocument::AddMutationObserver(nsIMutationObserver* aMutationObserver)
   1: {
   1:   mBindingManager->AddObserver(aMutationObserver);
   1: }
   1: 
   1: void
   1: nsDocument::RemoveMutationObserver(nsIMutationObserver* aMutationObserver)
   1: {
   1:   mBindingManager->RemoveObserver(aMutationObserver);
   1: }
   1: 
   1: // Note: We don't hold a reference to the document observer; we assume
   1: // that it has a live reference to the document.
   1: void
   1: nsDocument::AddObserver(nsIDocumentObserver* aObserver)
   1: {
   1:   // The array makes sure the observer isn't already in the list
   1:   mObservers.AppendObserver(aObserver);
   1:   AddMutationObserver(aObserver);
   1: }
   1: 
   1: PRBool
   1: nsDocument::RemoveObserver(nsIDocumentObserver* aObserver)
   1: {
   1:   // If we're in the process of destroying the document (and we're
   1:   // informing the observers of the destruction), don't remove the
   1:   // observers from the list. This is not a big deal, since we
   1:   // don't hold a live reference to the observers.
   1:   if (!mInDestructor) {
   1:     RemoveMutationObserver(aObserver);
   1:     return mObservers.RemoveObserver(aObserver);
   1:   }
   1: 
   1:   return mObservers.Contains(aObserver);
   1: }
   1: 
   1: void
   1: nsDocument::BeginUpdate(nsUpdateType aUpdateType)
   1: {
2025:   if (mUpdateNestLevel == 0) {
2025:     mBindingManager->BeginOutermostUpdate();
2025:   }
2025:   
   1:   ++mUpdateNestLevel;
   1:   if (mScriptLoader) {
   1:     mScriptLoader->AddExecuteBlocker();
   1:   }
   1:   NS_DOCUMENT_NOTIFY_OBSERVERS(BeginUpdate, (this, aUpdateType));
   1: }
   1: 
   1: void
   1: nsDocument::EndUpdate(nsUpdateType aUpdateType)
   1: {
   1:   NS_DOCUMENT_NOTIFY_OBSERVERS(EndUpdate, (this, aUpdateType));
   1: 
   1:   --mUpdateNestLevel;
   1:   if (mUpdateNestLevel == 0) {
2025:     // This set of updates may have created XBL bindings.  Let the
2025:     // binding manager know we're done.
2025:     mBindingManager->EndOutermostUpdate();
   1:   }
   1: 
   1:   if (mScriptLoader) {
   1:     mScriptLoader->RemoveExecuteBlocker();
   1:   }
   1: }
   1: 
   1: void
   1: nsDocument::BeginLoad()
   1: {
   1:   // Block onload here to prevent having to deal with blocking and
   1:   // unblocking it while we know the document is loading.
   1:   BlockOnload();
   1: 
   1:   NS_DOCUMENT_NOTIFY_OBSERVERS(BeginLoad, (this));
   1: }
   1: 
   1: PRBool
   1: nsDocument::CheckGetElementByIdArg(const nsAString& aId)
   1: {
   1:   if (aId.IsEmpty()) {
   1:     nsContentUtils::ReportToConsole(
   1:         nsContentUtils::eDOM_PROPERTIES,
   1:         "EmptyGetElementByIdParam",
   1:         nsnull, 0,
   1:         nsnull,
   1:         EmptyString(), 0, 0,
   1:         nsIScriptError::warningFlag,
   1:         "DOM");
   1:     return PR_FALSE;
   1:   }
   1:   return PR_TRUE;
   1: }
   1: 
   1: static void
   1: GetDocumentFromDocShellTreeItem(nsIDocShellTreeItem *aDocShell,
   1:                                 nsIDocument **aDocument)
   1: {
   1:   *aDocument = nsnull;
   1: 
   1:   nsCOMPtr<nsIDOMWindow> window(do_GetInterface(aDocShell));
   1: 
   1:   if (window) {
   1:     nsCOMPtr<nsIDOMDocument> dom_doc;
   1:     window->GetDocument(getter_AddRefs(dom_doc));
   1: 
   1:     if (dom_doc) {
   1:       CallQueryInterface(dom_doc, aDocument);
   1:     }
   1:   }
   1: }
   1: 
   1: void
   1: nsDocument::DispatchContentLoadedEvents()
   1: {
6205:   // If you add early returns from this method, make sure you're
6205:   // calling UnblockOnload properly.
6205:   
   1:   // Fire a DOM event notifying listeners that this document has been
   1:   // loaded (excluding images and other loads initiated by this
   1:   // document).
3233:   nsContentUtils::DispatchTrustedEvent(this, static_cast<nsIDocument*>(this),
   1:                                        NS_LITERAL_STRING("DOMContentLoaded"),
   1:                                        PR_TRUE, PR_TRUE);
   1: 
   1:   // If this document is a [i]frame, fire a DOMFrameContentLoaded
   1:   // event on all parent documents notifying that the HTML (excluding
   1:   // other external files such as images and stylesheets) in a frame
   1:   // has finished loading.
   1: 
   1:   nsCOMPtr<nsIDocShellTreeItem> docShellParent;
   1: 
   1:   // target_frame is the [i]frame element that will be used as the
   1:   // target for the event. It's the [i]frame whose content is done
   1:   // loading.
   1:   nsCOMPtr<nsIDOMEventTarget> target_frame;
   1: 
   1:   nsPIDOMWindow *win = GetWindow();
   1:   if (win) {
   1:     nsCOMPtr<nsIDocShellTreeItem> docShellAsItem =
   1:       do_QueryInterface(win->GetDocShell());
   1: 
   1:     if (docShellAsItem) {
   1:       docShellAsItem->GetSameTypeParent(getter_AddRefs(docShellParent));
   1: 
   1:       nsCOMPtr<nsIDocument> parent_doc;
   1: 
   1:       GetDocumentFromDocShellTreeItem(docShellParent,
   1:                                       getter_AddRefs(parent_doc));
   1: 
   1:       if (parent_doc) {
   1:         target_frame = do_QueryInterface(parent_doc->FindContentForSubDocument(this));
   1:       }
   1:     }
   1:   }
   1: 
   1:   if (target_frame) {
   1:     while (docShellParent) {
   1:       nsCOMPtr<nsIDocument> ancestor_doc;
   1: 
   1:       GetDocumentFromDocShellTreeItem(docShellParent,
   1:                                       getter_AddRefs(ancestor_doc));
   1: 
   1:       if (!ancestor_doc) {
   1:         break;
   1:       }
   1: 
   1:       nsCOMPtr<nsIDOMDocumentEvent> document_event =
   1:         do_QueryInterface(ancestor_doc);
   1: 
   1:       nsCOMPtr<nsIDOMEvent> event;
   1:       nsCOMPtr<nsIPrivateDOMEvent> privateEvent;
   1:       if (document_event) {
   1:         document_event->CreateEvent(NS_LITERAL_STRING("Events"),
   1:                                     getter_AddRefs(event));
   1: 
   1:         privateEvent = do_QueryInterface(event);
   1:       }
   1: 
   1:       if (event && privateEvent) {
   1:         event->InitEvent(NS_LITERAL_STRING("DOMFrameContentLoaded"), PR_TRUE,
   1:                          PR_TRUE);
   1: 
   1:         privateEvent->SetTarget(target_frame);
   1:         privateEvent->SetTrusted(PR_TRUE);
   1: 
   1:         // To dispatch this event we must manually call
   1:         // nsEventDispatcher::Dispatch() on the ancestor document since the
   1:         // target is not in the same document, so the event would never reach
   1:         // the ancestor document if we used the normal event
   1:         // dispatching code.
   1: 
   1:         nsEvent* innerEvent;
   1:         privateEvent->GetInternalNSEvent(&innerEvent);
   1:         if (innerEvent) {
   1:           nsEventStatus status = nsEventStatus_eIgnore;
   1: 
 981:           nsIPresShell *shell = ancestor_doc->GetPrimaryShell();
   1:           if (shell) {
   1:             nsCOMPtr<nsPresContext> context = shell->GetPresContext();
   1: 
   1:             if (context) {
   1:               nsEventDispatcher::Dispatch(ancestor_doc, context, innerEvent,
   1:                                           event, &status);
   1:             }
   1:           }
   1:         }
   1:       }
   1: 
   1:       nsCOMPtr<nsIDocShellTreeItem> tmp(docShellParent);
   1:       tmp->GetSameTypeParent(getter_AddRefs(docShellParent));
   1:     }
   1:   }
6205: 
6205:   UnblockOnload(PR_TRUE);
   1: }
   1: 
   1: void
   1: nsDocument::EndLoad()
   1: {
6177:   // Drop the ref to our parser, if any, but keep hold of the sink so that we
6177:   // can flush it from FlushPendingNotifications as needed.  We might have to
6177:   // do that to get a StartLayout() to happen.
6170:   if (mParser) {
6170:     mWeakSink = do_GetWeakReference(mParser->GetContentSink());
   1:     mParser = nsnull;
6170:   }
   1:   
   1:   NS_DOCUMENT_NOTIFY_OBSERVERS(EndLoad, (this));
   1: 
6205:   nsRefPtr<nsIRunnable> ev =
6205:     new nsRunnableMethod<nsDocument>(this,
6205:                                      &nsDocument::DispatchContentLoadedEvents);
6205:   NS_DispatchToCurrentThread(ev);
   1: }
   1: 
   1: void
   1: nsDocument::ContentStatesChanged(nsIContent* aContent1, nsIContent* aContent2,
   1:                                  PRInt32 aStateMask)
   1: {
   1:   NS_DOCUMENT_NOTIFY_OBSERVERS(ContentStatesChanged,
   1:                                (this, aContent1, aContent2, aStateMask));
   1: }
   1: 
   1: void
   1: nsDocument::AttributeWillChange(nsIContent* aChild, PRInt32 aNameSpaceID,
   1:                                 nsIAtom* aAttribute)
   1: {
   1:   NS_ASSERTION(aChild, "Null child!");
   1: }
   1: 
   1: void
   1: nsDocument::StyleRuleChanged(nsIStyleSheet* aStyleSheet,
   1:                              nsIStyleRule* aOldStyleRule,
   1:                              nsIStyleRule* aNewStyleRule)
   1: {
   1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleRuleChanged,
   1:                                (this, aStyleSheet,
   1:                                 aOldStyleRule, aNewStyleRule));
   1: }
   1: 
   1: void
   1: nsDocument::StyleRuleAdded(nsIStyleSheet* aStyleSheet,
   1:                            nsIStyleRule* aStyleRule)
   1: {
   1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleRuleAdded,
   1:                                (this, aStyleSheet, aStyleRule));
   1: }
   1: 
   1: void
   1: nsDocument::StyleRuleRemoved(nsIStyleSheet* aStyleSheet,
   1:                              nsIStyleRule* aStyleRule)
   1: {
   1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleRuleRemoved,
   1:                                (this, aStyleSheet, aStyleRule));
   1: }
   1: 
   1: 
   1: //
   1: // nsIDOMDocument interface
   1: //
   1: NS_IMETHODIMP
   1: nsDocument::GetDoctype(nsIDOMDocumentType** aDoctype)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aDoctype);
   1: 
   1:   *aDoctype = nsnull;
   1:   PRInt32 i, count;
   1:   count = mChildren.ChildCount();
   1:   nsCOMPtr<nsIDOMNode> rootContentNode(do_QueryInterface(mRootContent) );
   1:   nsCOMPtr<nsIDOMNode> node;
   1: 
   1:   for (i = 0; i < count; i++) {
   1:     node = do_QueryInterface(mChildren.ChildAt(i));
   1: 
   1:     NS_ASSERTION(node, "null element of mChildren");
   1: 
   1:     // doctype can't be after the root
   1:     // XXX Do we really want to enforce this when we don't enforce
   1:     // anything else?
   1:     if (node == rootContentNode)
   1:       return NS_OK;
   1: 
   1:     if (node) {
   1:       PRUint16 nodeType;
   1: 
   1:       node->GetNodeType(&nodeType);
   1: 
   1:       if (nodeType == nsIDOMNode::DOCUMENT_TYPE_NODE) {
   1:         return CallQueryInterface(node, aDoctype);
   1:       }
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetImplementation(nsIDOMDOMImplementation** aImplementation)
   1: {
   1:   // For now, create a new implementation every time. This shouldn't
   1:   // be a high bandwidth operation
   1:   nsCOMPtr<nsIURI> uri;
   1:   NS_NewURI(getter_AddRefs(uri), "about:blank");
   1:   NS_ENSURE_TRUE(uri, NS_ERROR_OUT_OF_MEMORY);
   1:   
   1:   *aImplementation = new nsDOMImplementation(uri, uri, NodePrincipal());
   1:   if (!*aImplementation) {
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: 
   1:   NS_ADDREF(*aImplementation);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetDocumentElement(nsIDOMElement** aDocumentElement)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aDocumentElement);
   1: 
   1:   nsresult rv = NS_OK;
   1: 
   1:   if (mRootContent) {
   1:     rv = CallQueryInterface(mRootContent, aDocumentElement);
   1:     NS_ASSERTION(NS_OK == rv, "Must be a DOM Element");
   1:   } else {
   1:     *aDocumentElement = nsnull;
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::CreateElement(const nsAString& aTagName,
   1:                           nsIDOMElement** aReturn)
   1: {
   1:   *aReturn = nsnull;
   1: 
   1:   nsresult rv = nsContentUtils::CheckQName(aTagName, PR_FALSE);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   NS_ASSERTION(IsCaseSensitive(),
   1:                "nsDocument::CreateElement() called on document that is not "
   1:                "case sensitive. Fix caller, or fix "
   1:                "nsDocument::CreateElement()!");
   1: 
   1:   nsCOMPtr<nsIAtom> name = do_GetAtom(aTagName);
   1: 
   1:   nsCOMPtr<nsIContent> content;
   1:   rv = CreateElem(name, nsnull, GetDefaultNamespaceID(), PR_TRUE,
   1:                   getter_AddRefs(content));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   return CallQueryInterface(content, aReturn);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::CreateElementNS(const nsAString& aNamespaceURI,
   1:                             const nsAString& aQualifiedName,
   1:                             nsIDOMElement** aReturn)
   1: {
   1:   *aReturn = nsnull;
   1: 
   1:   nsCOMPtr<nsINodeInfo> nodeInfo;
   1:   nsresult rv = nsContentUtils::GetNodeInfoFromQName(aNamespaceURI,
   1:                                                      aQualifiedName,
   1:                                                      mNodeInfoManager,
   1:                                                      getter_AddRefs(nodeInfo));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsCOMPtr<nsIContent> content;
   1:   NS_NewElement(getter_AddRefs(content), nodeInfo->NamespaceID(), nodeInfo);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   return CallQueryInterface(content, aReturn);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::CreateTextNode(const nsAString& aData, nsIDOMText** aReturn)
   1: {
   1:   *aReturn = nsnull;
   1: 
   1:   nsCOMPtr<nsIContent> text;
   1:   nsresult rv = NS_NewTextNode(getter_AddRefs(text), mNodeInfoManager);
   1: 
   1:   if (NS_SUCCEEDED(rv)) {
   1:     // Don't notify; this node is still being created.
   1:     text->SetText(aData, PR_FALSE);
   1: 
   1:     rv = CallQueryInterface(text, aReturn);
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::CreateDocumentFragment(nsIDOMDocumentFragment** aReturn)
   1: {
   1:   return NS_NewDocumentFragment(aReturn, mNodeInfoManager);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::CreateComment(const nsAString& aData, nsIDOMComment** aReturn)
   1: {
   1:   *aReturn = nsnull;
   1: 
   1:   // Make sure the substring "--" is not present in aData.  Otherwise
   1:   // we'll create a document that can't be serialized.
   1:   if (FindInReadable(NS_LITERAL_STRING("--"), aData)) {
   1:     return NS_ERROR_DOM_INVALID_CHARACTER_ERR;
   1:   }
   1: 
   1:   nsCOMPtr<nsIContent> comment;
   1:   nsresult rv = NS_NewCommentNode(getter_AddRefs(comment), mNodeInfoManager);
   1: 
   1:   if (NS_SUCCEEDED(rv)) {
   1:     // Don't notify; this node is still being created.
   1:     comment->SetText(aData, PR_FALSE);
   1: 
   1:     rv = CallQueryInterface(comment, aReturn);
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::CreateCDATASection(const nsAString& aData,
   1:                                nsIDOMCDATASection** aReturn)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aReturn);
   1:   *aReturn = nsnull;
   1: 
   1:   if (FindInReadable(NS_LITERAL_STRING("]]>"), aData))
   1:     return NS_ERROR_DOM_INVALID_CHARACTER_ERR;
   1: 
   1:   nsCOMPtr<nsIContent> content;
   1:   nsresult rv = NS_NewXMLCDATASection(getter_AddRefs(content),
   1:                                       mNodeInfoManager);
   1: 
   1:   if (NS_SUCCEEDED(rv)) {
   1:     // Don't notify; this node is still being created.
   1:     content->SetText(aData, PR_FALSE);
   1: 
   1:     rv = CallQueryInterface(content, aReturn);
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::CreateProcessingInstruction(const nsAString& aTarget,
   1:                                         const nsAString& aData,
   1:                                         nsIDOMProcessingInstruction** aReturn)
   1: {
   1:   *aReturn = nsnull;
   1: 
   1:   nsresult rv = nsContentUtils::CheckQName(aTarget, PR_FALSE);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   if (FindInReadable(NS_LITERAL_STRING("?>"), aData)) {
   1:     return NS_ERROR_DOM_INVALID_CHARACTER_ERR;
   1:   }
   1: 
   1:   nsCOMPtr<nsIContent> content;
   1:   rv = NS_NewXMLProcessingInstruction(getter_AddRefs(content),
   1:                                       mNodeInfoManager, aTarget, aData);
   1:   if (NS_FAILED(rv)) {
   1:     return rv;
   1:   }
   1: 
   1:   return CallQueryInterface(content, aReturn);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::CreateAttribute(const nsAString& aName,
   1:                             nsIDOMAttr** aReturn)
   1: {
   1:   *aReturn = nsnull;
   1:   NS_ENSURE_TRUE(mNodeInfoManager, NS_ERROR_NOT_INITIALIZED);
   1: 
   1:   nsresult rv = nsContentUtils::CheckQName(aName, PR_FALSE);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsAutoString value;
   1:   nsDOMAttribute* attribute;
   1: 
   1:   nsCOMPtr<nsINodeInfo> nodeInfo;
   1:   rv = mNodeInfoManager->GetNodeInfo(aName, nsnull, kNameSpaceID_None,
   1:                                      getter_AddRefs(nodeInfo));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   attribute = new nsDOMAttribute(nsnull, nodeInfo, value);
   1:   NS_ENSURE_TRUE(attribute, NS_ERROR_OUT_OF_MEMORY);
   1: 
   1:   return CallQueryInterface(attribute, aReturn);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::CreateAttributeNS(const nsAString & aNamespaceURI,
   1:                               const nsAString & aQualifiedName,
   1:                               nsIDOMAttr **aResult)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aResult);
   1:   *aResult = nsnull;
   1: 
   1:   nsCOMPtr<nsINodeInfo> nodeInfo;
   1:   nsresult rv = nsContentUtils::GetNodeInfoFromQName(aNamespaceURI,
   1:                                                      aQualifiedName,
   1:                                                      mNodeInfoManager,
   1:                                                      getter_AddRefs(nodeInfo));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsAutoString value;
   1:   nsDOMAttribute* attribute = new nsDOMAttribute(nsnull, nodeInfo, value);
   1:   NS_ENSURE_TRUE(attribute, NS_ERROR_OUT_OF_MEMORY);
   1: 
   1:   return CallQueryInterface(attribute, aResult);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::CreateEntityReference(const nsAString& aName,
   1:                                   nsIDOMEntityReference** aReturn)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aReturn);
   1: 
   1:   *aReturn = nsnull;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetElementsByTagName(const nsAString& aTagname,
   1:                                  nsIDOMNodeList** aReturn)
   1: {
   1:   nsCOMPtr<nsIAtom> nameAtom = do_GetAtom(aTagname);
   1:   NS_ENSURE_TRUE(nameAtom, NS_ERROR_OUT_OF_MEMORY);
   1: 
   1:   nsContentList *list = NS_GetContentList(this, nameAtom, kNameSpaceID_Unknown).get();
   1:   NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
   1: 
   1:   // transfer ref to aReturn
   1:   *aReturn = list;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetElementsByTagNameNS(const nsAString& aNamespaceURI,
   1:                                    const nsAString& aLocalName,
   1:                                    nsIDOMNodeList** aReturn)
   1: {
   1:   PRInt32 nameSpaceId = kNameSpaceID_Wildcard;
   1: 
   1:   if (!aNamespaceURI.EqualsLiteral("*")) {
   1:     nsresult rv =
   1:       nsContentUtils::NameSpaceManager()->RegisterNameSpace(aNamespaceURI,
   1:                                                             nameSpaceId);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1:   }
   1: 
   1:   nsCOMPtr<nsIAtom> nameAtom = do_GetAtom(aLocalName);
   1:   NS_ENSURE_TRUE(nameAtom, NS_ERROR_OUT_OF_MEMORY);
   1: 
   1:   nsContentList *list = NS_GetContentList(this, nameAtom, nameSpaceId).get();
   1:   NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
   1: 
   1:   // transfer ref to aReturn
   1:   *aReturn = list;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetElementById(const nsAString & elementId,
   1:                            nsIDOMElement **_retval)
   1: {
   1:   // Should be implemented by subclass
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetAsync(PRBool *aAsync)
   1: {
   1:   NS_ERROR("nsDocument::GetAsync() should be overriden by subclass!");
   1: 
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::SetAsync(PRBool aAsync)
   1: {
   1:   NS_ERROR("nsDocument::SetAsync() should be overriden by subclass!");
   1: 
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::Load(const nsAString& aUrl, PRBool *aReturn)
   1: {
   1:   NS_ERROR("nsDocument::Load() should be overriden by subclass!");
   1: 
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::EvaluateFIXptr(const nsAString& aExpression, nsIDOMRange **aRange)
   1: {
   1:   NS_ERROR("nsDocument::EvaluateFIXptr() should be overriden by subclass!");
   1: 
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::EvaluateXPointer(const nsAString& aExpression,
   1:                              nsIXPointerResult **aResult)
   1: {
   1:   NS_ERROR("nsDocument::EvaluateXPointer() should be overriden by subclass!");
   1: 
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetStyleSheets(nsIDOMStyleSheetList** aStyleSheets)
   1: {
   1:   if (!mDOMStyleSheets) {
   1:     mDOMStyleSheets = new nsDOMStyleSheetList(this);
   1:     if (!mDOMStyleSheets) {
   1:       return NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1:   }
   1: 
   1:   *aStyleSheets = mDOMStyleSheets;
   1:   NS_ADDREF(*aStyleSheets);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetSelectedStyleSheetSet(nsAString& aSheetSet)
   1: {
   1:   aSheetSet.Truncate();
   1:   
   1:   // Look through our sheets, find the selected set title
   1:   PRInt32 count = GetNumberOfStyleSheets();
   1:   nsAutoString title;
   1:   for (PRInt32 index = 0; index < count; index++) {
   1:     nsIStyleSheet* sheet = GetStyleSheetAt(index);
   1:     NS_ASSERTION(sheet, "Null sheet in sheet list!");
   1: 
   1:     nsCOMPtr<nsIDOMStyleSheet> domSheet = do_QueryInterface(sheet);
   1:     NS_ASSERTION(domSheet, "Sheet must QI to nsIDOMStyleSheet");
   1:     PRBool disabled;
   1:     domSheet->GetDisabled(&disabled);
   1:     if (disabled) {
   1:       // Disabled sheets don't affect the currently selected set
   1:       continue;
   1:     }
   1:     
   1:     sheet->GetTitle(title);
   1: 
   1:     if (aSheetSet.IsEmpty()) {
   1:       aSheetSet = title;
   1:     } else if (!title.IsEmpty() && !aSheetSet.Equals(title)) {
   1:       // Sheets from multiple sets enabled; return null string, per spec.
   1:       SetDOMStringToNull(aSheetSet);
   1:       break;
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::SetSelectedStyleSheetSet(const nsAString& aSheetSet)
   1: {
   1:   if (DOMStringIsNull(aSheetSet)) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   // Must update mLastStyleSheetSet before doing anything else with stylesheets
   1:   // or CSSLoaders.
   1:   mLastStyleSheetSet = aSheetSet;
   1:   EnableStyleSheetsForSetInternal(aSheetSet, PR_TRUE);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetLastStyleSheetSet(nsAString& aSheetSet)
   1: {
   1:   aSheetSet = mLastStyleSheetSet;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetPreferredStyleSheetSet(nsAString& aSheetSet)
   1: {
   1:   GetHeaderData(nsGkAtoms::headerDefaultStyle, aSheetSet);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetStyleSheetSets(nsIDOMDOMStringList** aList)
   1: {
   1:   if (!mStyleSheetSetList) {
   1:     mStyleSheetSetList = new nsDOMStyleSheetSetList(this);
   1:     if (!mStyleSheetSetList) {
   1:       return NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1:   }
   1: 
   1:   NS_ADDREF(*aList = mStyleSheetSetList);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::EnableStyleSheetsForSet(const nsAString& aSheetSet)
   1: {
   1:   // Per spec, passing in null is a no-op.
   1:   if (!DOMStringIsNull(aSheetSet)) {
   1:     // Note: must make sure to not change the CSSLoader's preferred sheet --
   1:     // that value should be equal to either our lastStyleSheetSet (if that's
   1:     // non-null) or to our preferredStyleSheetSet.  And this method doesn't
   1:     // change either of those.
   1:     EnableStyleSheetsForSetInternal(aSheetSet, PR_FALSE);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: void
   1: nsDocument::EnableStyleSheetsForSetInternal(const nsAString& aSheetSet,
   1:                                             PRBool aUpdateCSSLoader)
   1: {
   1:   BeginUpdate(UPDATE_STYLE);
   1:   PRInt32 count = GetNumberOfStyleSheets();
   1:   nsAutoString title;
   1:   for (PRInt32 index = 0; index < count; index++) {
   1:     nsIStyleSheet* sheet = GetStyleSheetAt(index);
   1:     NS_ASSERTION(sheet, "Null sheet in sheet list!");
   1:     sheet->GetTitle(title);
   1:     if (!title.IsEmpty()) {
   1:       sheet->SetEnabled(title.Equals(aSheetSet));
   1:     }
   1:   }
   1:   if (aUpdateCSSLoader) {
   1:     CSSLoader()->SetPreferredSheet(aSheetSet);
   1:   }
   1:   EndUpdate(UPDATE_STYLE);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetCharacterSet(nsAString& aCharacterSet)
   1: {
   1:   CopyASCIItoUTF16(GetDocumentCharacterSet(), aCharacterSet);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::ImportNode(nsIDOMNode* aImportedNode,
   1:                        PRBool aDeep,
   1:                        nsIDOMNode** aResult)
   1: {
   1:   NS_ENSURE_ARG(aImportedNode);
   1: 
   1:   *aResult = nsnull;
   1: 
   1:   nsresult rv = nsContentUtils::CheckSameOrigin(this, aImportedNode);
   1:   if (NS_FAILED(rv)) {
   1:     return rv;
   1:   }
   1: 
   1:   PRUint16 nodeType;
   1:   aImportedNode->GetNodeType(&nodeType);
   1:   switch (nodeType) {
   1:     case nsIDOMNode::ATTRIBUTE_NODE:
   1:     case nsIDOMNode::DOCUMENT_FRAGMENT_NODE:
   1:     case nsIDOMNode::ELEMENT_NODE:
   1:     case nsIDOMNode::PROCESSING_INSTRUCTION_NODE:
   1:     case nsIDOMNode::TEXT_NODE:
   1:     case nsIDOMNode::CDATA_SECTION_NODE:
   1:     case nsIDOMNode::COMMENT_NODE:
   1:     {
   1:       nsCOMPtr<nsINode> imported = do_QueryInterface(aImportedNode);
   1:       NS_ENSURE_TRUE(imported, NS_ERROR_FAILURE);
   1: 
   1:       nsCOMPtr<nsIDOMNode> newNode;
   1:       nsCOMArray<nsINode> nodesWithProperties;
   1:       rv = nsNodeUtils::Clone(imported, aDeep, mNodeInfoManager,
   1:                               nodesWithProperties, getter_AddRefs(newNode));
   1:       NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:       nsIDocument *ownerDoc = imported->GetOwnerDoc();
   1:       if (ownerDoc) {
   1:         rv = nsNodeUtils::CallUserDataHandlers(nodesWithProperties, ownerDoc,
   1:                                                nsIDOMUserDataHandler::NODE_IMPORTED,
   1:                                                PR_TRUE);
   1:         NS_ENSURE_SUCCESS(rv, rv);
   1:       }
   1: 
   1:       newNode.swap(*aResult);
   1: 
   1:       return NS_OK;
   1:     }
   1:     case nsIDOMNode::ENTITY_NODE:
   1:     case nsIDOMNode::ENTITY_REFERENCE_NODE:
   1:     case nsIDOMNode::NOTATION_NODE:
   1:     {
   1:       return NS_ERROR_NOT_IMPLEMENTED;
   1:     }
   1:     default:
   1:     {
   1:       NS_WARNING("Don't know how to clone this nodetype for importNode.");
   1: 
   1:       return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
   1:     }
   1:   }
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::AddBinding(nsIDOMElement* aContent, const nsAString& aURI)
   1: {
   1:   NS_ENSURE_ARG(aContent);
   1:   
   1:   nsresult rv = nsContentUtils::CheckSameOrigin(this, aContent);
   1:   if (NS_FAILED(rv)) {
   1:     return rv;
   1:   }
   1: 
   1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aContent));
   1: 
   1:   nsCOMPtr<nsIURI> uri;
   1:   rv = NS_NewURI(getter_AddRefs(uri), aURI);
   1:   if (NS_FAILED(rv)) {
   1:     return rv;
   1:   }
   1: 
3645:   // Figure out the right principal to use
3645:   nsCOMPtr<nsIPrincipal> subject;
3645:   nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
3645:   if (secMan) {
3645:     rv = secMan->GetSubjectPrincipal(getter_AddRefs(subject));
3645:     NS_ENSURE_SUCCESS(rv, rv);
3645:   }
3645: 
3645:   if (!subject) {
3645:     // Fall back to our principal.  Or should we fall back to the null
3645:     // principal?  The latter would just mean no binding loads....
3645:     subject = NodePrincipal();
3645:   }
3645:   
3645:   return mBindingManager->AddLayeredBinding(content, uri, subject);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::RemoveBinding(nsIDOMElement* aContent, const nsAString& aURI)
   1: {
   1:   NS_ENSURE_ARG(aContent);
   1: 
   1:   nsresult rv = nsContentUtils::CheckSameOrigin(this, aContent);
   1:   if (NS_FAILED(rv)) {
   1:     return rv;
   1:   }
   1: 
   1:   nsCOMPtr<nsIURI> uri;
   1:   rv = NS_NewURI(getter_AddRefs(uri), aURI);
   1:   if (NS_FAILED(rv)) {
   1:     return rv;
   1:   }
   1: 
   1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aContent));
   1:   return mBindingManager->RemoveLayeredBinding(content, uri);
   1: }
   1: 
   1: NS_IMETHODIMP
2324: nsDocument::LoadBindingDocument(const nsAString& aURI)
   1: {
   1:   nsCOMPtr<nsIURI> uri;
   1:   nsresult rv = NS_NewURI(getter_AddRefs(uri), aURI,
   1:                           mCharacterSet.get(),
3233:                           static_cast<nsIDocument *>(this)->GetBaseURI());
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
3645:   // Figure out the right principal to use
3645:   nsCOMPtr<nsIPrincipal> subject;
3645:   nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
3645:   if (secMan) {
3645:     rv = secMan->GetSubjectPrincipal(getter_AddRefs(subject));
3645:     NS_ENSURE_SUCCESS(rv, rv);
3645:   }
3645: 
3645:   if (!subject) {
3645:     // Fall back to our principal.  Or should we fall back to the null
3645:     // principal?  The latter would just mean no binding loads....
3645:     subject = NodePrincipal();
3645:   }
3645:   
3645:   mBindingManager->LoadBindingDocument(this, uri, subject);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetBindingParent(nsIDOMNode* aNode, nsIDOMElement** aResult)
   1: {
   1:   *aResult = nsnull;
   1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aNode));
   1:   if (!content)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   nsCOMPtr<nsIDOMElement> elt(do_QueryInterface(content->GetBindingParent()));
   1:   NS_IF_ADDREF(*aResult = elt);
   1:   return NS_OK;
   1: }
   1: 
   1: static nsresult
   1: GetElementByAttribute(nsIContent* aContent, nsIAtom* aAttrName,
   1:                       const nsAString& aAttrValue, PRBool aUniversalMatch,
   1:                       nsIDOMElement** aResult)
   1: {
   1:   if (aUniversalMatch ? aContent->HasAttr(kNameSpaceID_None, aAttrName) :
   1:                         aContent->AttrValueIs(kNameSpaceID_None, aAttrName,
   1:                                               aAttrValue, eCaseMatters)) {
   1:     return CallQueryInterface(aContent, aResult);
   1:   }
   1: 
   1:   PRUint32 childCount = aContent->GetChildCount();
   1: 
   1:   for (PRUint32 i = 0; i < childCount; ++i) {
   1:     nsIContent *current = aContent->GetChildAt(i);
   1: 
   1:     GetElementByAttribute(current, aAttrName, aAttrValue, aUniversalMatch,
   1:                           aResult);
   1: 
   1:     if (*aResult)
   1:       return NS_OK;
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetAnonymousElementByAttribute(nsIDOMElement* aElement,
   1:                                            const nsAString& aAttrName,
   1:                                            const nsAString& aAttrValue,
   1:                                            nsIDOMElement** aResult)
   1: {
   1:   *aResult = nsnull;
   1: 
   1:   nsCOMPtr<nsIDOMNodeList> nodeList;
   1:   GetAnonymousNodes(aElement, getter_AddRefs(nodeList));
   1: 
   1:   if (!nodeList)
   1:     return NS_OK;
   1: 
   1:   nsCOMPtr<nsIAtom> attribute = do_GetAtom(aAttrName);
   1: 
   1:   PRUint32 length;
   1:   nodeList->GetLength(&length);
   1: 
   1:   PRBool universalMatch = aAttrValue.EqualsLiteral("*");
   1: 
   1:   for (PRUint32 i = 0; i < length; ++i) {
   1:     nsCOMPtr<nsIDOMNode> current;
   1:     nodeList->Item(i, getter_AddRefs(current));
   1: 
   1:     nsCOMPtr<nsIContent> content(do_QueryInterface(current));
   1: 
   1:     GetElementByAttribute(content, attribute, aAttrValue, universalMatch,
   1:                           aResult);
   1:     if (*aResult)
   1:       return NS_OK;
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetAnonymousNodes(nsIDOMElement* aElement,
   1:                               nsIDOMNodeList** aResult)
   1: {
   1:   *aResult = nsnull;
   1: 
   1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aElement));
   1:   return mBindingManager->GetAnonymousNodesFor(content, aResult);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::CreateRange(nsIDOMRange** aReturn)
   1: {
   1:   nsresult rv = NS_NewRange(aReturn);
   1: 
   1:   if (NS_SUCCEEDED(rv)) {
   1:     (*aReturn)->SetStart(this, 0);
   1:     (*aReturn)->SetEnd(this, 0);
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::CreateNodeIterator(nsIDOMNode *aRoot,
   1:                                PRUint32 aWhatToShow,
   1:                                nsIDOMNodeFilter *aFilter,
   1:                                PRBool aEntityReferenceExpansion,
   1:                                nsIDOMNodeIterator **_retval)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::CreateTreeWalker(nsIDOMNode *aRoot,
   1:                              PRUint32 aWhatToShow,
   1:                              nsIDOMNodeFilter *aFilter,
   1:                              PRBool aEntityReferenceExpansion,
   1:                              nsIDOMTreeWalker **_retval)
   1: {
   1:   *_retval = nsnull;
   1: 
   1:   if (!aRoot) {
   1:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
   1:   }
   1: 
   1:   nsresult rv = nsContentUtils::CheckSameOrigin(this, aRoot);
   1:   if (NS_FAILED(rv)) {
   1:     return rv;
   1:   }
   1: 
   1:   return NS_NewTreeWalker(aRoot, aWhatToShow, aFilter,
   1:                           aEntityReferenceExpansion, _retval);
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetDefaultView(nsIDOMAbstractView** aDefaultView)
   1: {
   1:   nsPIDOMWindow* win = GetWindow();
   1:   if (win) {
   1:     return CallQueryInterface(win, aDefaultView);
   1:   }
   1: 
   1:   *aDefaultView = nsnull;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetLocation(nsIDOMLocation **_retval)
   1: {
   1:   NS_ENSURE_ARG_POINTER(_retval);
   1:   *_retval = nsnull;
   1: 
   1:   nsCOMPtr<nsIDOMWindowInternal> w(do_QueryInterface(mScriptGlobalObject));
   1: 
   1:   if (!w) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   return w->GetLocation(_retval);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetTitle(nsAString& aTitle)
   1: {
   1:   aTitle.Assign(mDocumentTitle);
   1:   // Make sure not to return null from this method even if
   1:   // mDocumentTitle is void.
   1:   aTitle.SetIsVoid(PR_FALSE);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::SetTitle(const nsAString& aTitle)
   1: {
1722:   nsPresShellIterator iter(this);
1722:   nsCOMPtr<nsIPresShell> shell;
1722:   while ((shell = iter.GetNextShell())) {
   1:     nsCOMPtr<nsISupports> container = shell->GetPresContext()->GetContainer();
   1:     if (!container)
   1:       continue;
   1: 
   1:     nsCOMPtr<nsIBaseWindow> docShellWin = do_QueryInterface(container);
   1:     if (!docShellWin)
   1:       continue;
   1: 
   1:     nsresult rv = docShellWin->SetTitle(PromiseFlatString(aTitle).get());
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1:   }
   1: 
   1:   mDocumentTitle.Assign(aTitle);
   1: 
   1:   // Fire a DOM event for the title change.
3233:   nsContentUtils::DispatchTrustedEvent(this, static_cast<nsIDocument*>(this),
   1:                                        NS_LITERAL_STRING("DOMTitleChanged"),
   1:                                        PR_TRUE, PR_TRUE);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetBoxObjectFor(nsIDOMElement* aElement, nsIBoxObject** aResult)
   1: {
   1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aElement));
   1:   NS_ENSURE_TRUE(content, NS_ERROR_UNEXPECTED);
1839: 
1839:   nsIDocument* doc = content->HasFlag(NODE_FORCE_XBL_BINDINGS) ?
1839:     content->GetOwnerDoc() : content->GetCurrentDoc();
1839:   NS_ENSURE_TRUE(doc == this, NS_ERROR_DOM_WRONG_DOCUMENT_ERR);
   1:   
   1:   *aResult = nsnull;
   1: 
   1:   if (!mBoxObjectTable) {
   1:     mBoxObjectTable = new nsInterfaceHashtable<nsISupportsHashKey, nsPIBoxObject>;
   1:     if (mBoxObjectTable && !mBoxObjectTable->Init(12)) {
   1:       mBoxObjectTable = nsnull;
   1:     }
   1:   } else {
   1:     // Want to use Get(content, aResult); but it's the wrong type
   1:     *aResult = mBoxObjectTable->GetWeak(content);
   1:     if (*aResult) {
   1:       NS_ADDREF(*aResult);
   1:       return NS_OK;
   1:     }
   1:   }
   1: 
   1:   PRInt32 namespaceID;
   1:   nsCOMPtr<nsIAtom> tag = mBindingManager->ResolveTag(content, &namespaceID);
   1: 
   1:   nsCAutoString contractID("@mozilla.org/layout/xul-boxobject");
   1:   if (namespaceID == kNameSpaceID_XUL) {
   1:     if (tag == nsGkAtoms::browser ||
   1:         tag == nsGkAtoms::editor ||
   1:         tag == nsGkAtoms::iframe)
   1:       contractID += "-container";
   1:     else if (tag == nsGkAtoms::menu)
   1:       contractID += "-menu";
   1:     else if (tag == nsGkAtoms::popup ||
   1:              tag == nsGkAtoms::menupopup ||
3129:              tag == nsGkAtoms::panel ||
   1:              tag == nsGkAtoms::tooltip)
   1:       contractID += "-popup";
   1:     else if (tag == nsGkAtoms::tree)
   1:       contractID += "-tree";
   1:     else if (tag == nsGkAtoms::listbox)
   1:       contractID += "-listbox";
   1:     else if (tag == nsGkAtoms::scrollbox)
   1:       contractID += "-scrollbox";
   1:   }
   1:   contractID += ";1";
   1: 
   1:   nsCOMPtr<nsPIBoxObject> boxObject(do_CreateInstance(contractID.get()));
   1:   if (!boxObject)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   boxObject->Init(content);
   1: 
   1:   if (mBoxObjectTable) {
   1:     mBoxObjectTable->Put(content, boxObject.get());
   1:   }
   1: 
   1:   *aResult = boxObject;
   1:   NS_ADDREF(*aResult);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: void
   1: nsDocument::ClearBoxObjectFor(nsIContent* aContent)
   1: {
   1:   if (mBoxObjectTable) {
   1:     nsPIBoxObject *boxObject = mBoxObjectTable->GetWeak(aContent);
   1:     if (boxObject) {
   1:       boxObject->Clear();
   1:       mBoxObjectTable->Remove(aContent);
   1:     }
   1:   }
   1: }
   1: 
   1: nsresult
   1: nsDocument::GetXBLChildNodesFor(nsIContent* aContent, nsIDOMNodeList** aResult)
   1: {
   1:   return mBindingManager->GetXBLChildNodesFor(aContent, aResult);
   1: }
   1: 
   1: nsresult
   1: nsDocument::GetContentListFor(nsIContent* aContent, nsIDOMNodeList** aResult)
   1: {
   1:   return mBindingManager->GetContentListFor(aContent, aResult);
   1: }
   1: 
   1: void
   1: nsDocument::FlushSkinBindings()
   1: {
   1:   mBindingManager->FlushSkinBindings();
   1: }
   1: 
   1: struct DirTable {
   1:   const char* mName;
   1:   PRUint8     mValue;
   1: };
   1: 
   1: static const DirTable dirAttributes[] = {
   1:   {"ltr", IBMBIDI_TEXTDIRECTION_LTR},
   1:   {"rtl", IBMBIDI_TEXTDIRECTION_RTL},
   1:   {0}
   1: };
   1: 
   1: /**
   1:  * Retrieve the "direction" property of the document.
   1:  *
   1:  * @lina 01/09/2001
   1:  */
   1: NS_IMETHODIMP
   1: nsDocument::GetDir(nsAString& aDirection)
   1: {
   1:   PRUint32 options = GetBidiOptions();
   1:   for (const DirTable* elt = dirAttributes; elt->mName; elt++) {
   1:     if (GET_BIDI_OPTION_DIRECTION(options) == elt->mValue) {
   1:       CopyASCIItoUTF16(elt->mName, aDirection);
   1:       break;
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: /**
   1:  * Set the "direction" property of the document.
   1:  *
   1:  * @lina 01/09/2001
   1:  */
   1: NS_IMETHODIMP
   1: nsDocument::SetDir(const nsAString& aDirection)
   1: {
   1:   PRUint32 options = GetBidiOptions();
   1: 
   1:   for (const DirTable* elt = dirAttributes; elt->mName; elt++) {
   1:     if (aDirection == NS_ConvertASCIItoUTF16(elt->mName)) {
   1:       if (GET_BIDI_OPTION_DIRECTION(options) != elt->mValue) {
   1:         SET_BIDI_OPTION_DIRECTION(options, elt->mValue);
 981:         nsIPresShell *shell = GetPrimaryShell();
   1:         if (shell) {
   1:           nsPresContext *context = shell->GetPresContext();
   1:           NS_ENSURE_TRUE(context, NS_ERROR_UNEXPECTED);
   1:           context->SetBidi(options, PR_TRUE);
   1:         } else {
   1:           // No presentation; just set it on ourselves
   1:           SetBidiOptions(options);
   1:         }
   1:       }
   1: 
   1:       break;
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: //
   1: // nsIDOMNode methods
   1: //
   1: NS_IMETHODIMP
   1: nsDocument::GetNodeName(nsAString& aNodeName)
   1: {
   1:   aNodeName.AssignLiteral("#document");
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetNodeValue(nsAString& aNodeValue)
   1: {
   1:   SetDOMStringToNull(aNodeValue);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::SetNodeValue(const nsAString& aNodeValue)
   1: {
   1:   // The DOM spec says that when nodeValue is defined to be null "setting it
   1:   // has no effect", so we don't throw an exception.
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetNodeType(PRUint16* aNodeType)
   1: {
   1:   *aNodeType = nsIDOMNode::DOCUMENT_NODE;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetParentNode(nsIDOMNode** aParentNode)
   1: {
   1:   *aParentNode = nsnull;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetChildNodes(nsIDOMNodeList** aChildNodes)
   1: {
   1:   nsSlots *slots = GetSlots();
   1:   NS_ENSURE_TRUE(slots, NS_ERROR_OUT_OF_MEMORY);
   1: 
   1:   if (!slots->mChildNodes) {
   1:     slots->mChildNodes = new nsChildContentList(this);
   1:     NS_ENSURE_TRUE(slots->mChildNodes, NS_ERROR_OUT_OF_MEMORY);
   1:     NS_ADDREF(slots->mChildNodes);
   1:   }
   1: 
   1:   NS_ADDREF(*aChildNodes = slots->mChildNodes);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::HasChildNodes(PRBool* aHasChildNodes)
   1: {
   1:   NS_ENSURE_ARG(aHasChildNodes);
   1: 
   1:   *aHasChildNodes = (mChildren.ChildCount() != 0);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::HasAttributes(PRBool* aHasAttributes)
   1: {
   1:   NS_ENSURE_ARG(aHasAttributes);
   1: 
   1:   *aHasAttributes = PR_FALSE;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetFirstChild(nsIDOMNode** aFirstChild)
   1: {
   1:   if (mChildren.ChildCount()) {
   1:     return CallQueryInterface(mChildren.ChildAt(0), aFirstChild);
   1:   }
   1: 
   1:   *aFirstChild = nsnull;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetLastChild(nsIDOMNode** aLastChild)
   1: {
   1:   PRInt32 count = mChildren.ChildCount();
   1:   if (count) {
   1:     return CallQueryInterface(mChildren.ChildAt(count-1), aLastChild);
   1:   }
   1: 
   1:   *aLastChild = nsnull;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetPreviousSibling(nsIDOMNode** aPreviousSibling)
   1: {
   1:   *aPreviousSibling = nsnull;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetNextSibling(nsIDOMNode** aNextSibling)
   1: {
   1:   *aNextSibling = nsnull;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetAttributes(nsIDOMNamedNodeMap** aAttributes)
   1: {
   1:   *aAttributes = nsnull;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetNamespaceURI(nsAString& aNamespaceURI)
   1: {
   1:   SetDOMStringToNull(aNamespaceURI);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetPrefix(nsAString& aPrefix)
   1: {
   1:   SetDOMStringToNull(aPrefix);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::SetPrefix(const nsAString& aPrefix)
   1: {
   1:   return NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetLocalName(nsAString& aLocalName)
   1: {
   1:   SetDOMStringToNull(aLocalName);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::InsertBefore(nsIDOMNode* aNewChild, nsIDOMNode* aRefChild,
   1:                          nsIDOMNode** aReturn)
   1: {
   1:   return nsGenericElement::doReplaceOrInsertBefore(PR_FALSE, aNewChild, aRefChild, nsnull, this,
   1:                                           aReturn);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::ReplaceChild(nsIDOMNode* aNewChild, nsIDOMNode* aOldChild,
   1:                          nsIDOMNode** aReturn)
   1: {
   1:   return nsGenericElement::doReplaceOrInsertBefore(PR_TRUE, aNewChild, aOldChild, nsnull, this,
   1:                                           aReturn);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::RemoveChild(nsIDOMNode* aOldChild, nsIDOMNode** aReturn)
   1: {
   1:   return nsGenericElement::doRemoveChild(aOldChild, nsnull, this, aReturn);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::AppendChild(nsIDOMNode* aNewChild, nsIDOMNode** aReturn)
   1: {
   1:   return nsDocument::InsertBefore(aNewChild, nsnull, aReturn);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::CloneNode(PRBool aDeep, nsIDOMNode** aReturn)
   1: {
   1:   // XXX should be implemented by subclass
   1:   *aReturn = nsnull;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::Normalize()
   1: {
   1:   PRInt32 count = mChildren.ChildCount();
   1:   for (PRInt32 i = 0; i < count; ++i) {
   1:     nsCOMPtr<nsIDOMNode> node(do_QueryInterface(mChildren.ChildAt(i)));
   1: 
   1:     if (node) {
   1:       node->Normalize();
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::IsSupported(const nsAString& aFeature, const nsAString& aVersion,
   1:                         PRBool* aReturn)
   1: {
3233:   return nsGenericElement::InternalIsSupported(static_cast<nsIDOMDocument*>(this),
   1:                                                aFeature, aVersion, aReturn);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetBaseURI(nsAString &aURI)
   1: {
   1:   nsCAutoString spec;
   1:   if (mDocumentBaseURI) {
   1:     mDocumentBaseURI->GetSpec(spec);
   1:   }
   1: 
   1:   CopyUTF8toUTF16(spec, aURI);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetTextContent(nsAString &aTextContent)
   1: {
   1:   SetDOMStringToNull(aTextContent);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::SetTextContent(const nsAString& aTextContent)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::CompareDocumentPosition(nsIDOMNode* aOther, PRUint16* aReturn)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aOther);
   1: 
   1:   // We could optimize this by getting the other nodes current document
   1:   // and comparing with ourself. But then we'd have to deal with the
   1:   // current document being null and such so it's easier this way.
   1:   // It's hardly a case to optimize anyway.
   1: 
   1:   nsCOMPtr<nsINode> other = do_QueryInterface(aOther);
   1:   NS_ENSURE_TRUE(other, NS_ERROR_DOM_NOT_SUPPORTED_ERR);
   1: 
   1:   *aReturn = nsContentUtils::ComparePosition(other, this);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::IsSameNode(nsIDOMNode* aOther, PRBool* aReturn)
   1: {
   1:   PRBool sameNode = PR_FALSE;
   1: 
   1:   if (this == aOther) {
   1:     sameNode = PR_TRUE;
   1:   }
   1: 
   1:   *aReturn = sameNode;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::IsEqualNode(nsIDOMNode* aOther, PRBool* aReturn)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aOther);
   1: 
   1:   *aReturn = PR_FALSE;
   1: 
   1:   // Node type check by QI.  We also reuse this later.
   1:   nsCOMPtr<nsIDocument> aOtherDoc = do_QueryInterface(aOther);
   1:   if (!aOtherDoc) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   // Child nodes check.
   1:   PRUint32 childCount = GetChildCount();
   1:   if (childCount != aOtherDoc->GetChildCount()) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   for (PRUint32 i = 0; i < childCount; i++) {
   1:     nsIContent* aChild1 = GetChildAt(i);
   1:     nsIContent* aChild2 = aOtherDoc->GetChildAt(i);
   1:     if (!nsNode3Tearoff::AreNodesEqual(aChild1, aChild2)) {
   1:       return NS_OK;
   1:     }
   1:   }
   1: 
   1:   /* Checks not needed:  Prefix, namespace URI, local name, node name,
   1:      node value, attributes.
   1:    */
   1: 
   1:   *aReturn = PR_TRUE;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::IsDefaultNamespace(const nsAString& aNamespaceURI,
   1:                                PRBool* aReturn)
   1: {
   1:   nsAutoString defaultNamespace;
   1:   LookupNamespaceURI(EmptyString(), defaultNamespace);
   1:   *aReturn = aNamespaceURI.Equals(defaultNamespace);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetFeature(const nsAString& aFeature,
   1:                        const nsAString& aVersion,
   1:                        nsISupports** aReturn)
   1: {
3233:   return nsGenericElement::InternalGetFeature(static_cast<nsIDOMDocument*>(this),
   1:                                               aFeature, aVersion, aReturn);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::SetUserData(const nsAString &aKey,
   1:                         nsIVariant *aData,
   1:                         nsIDOMUserDataHandler *aHandler,
   1:                         nsIVariant **aResult)
   1: {
1391:   return nsNodeUtils::SetUserData(this, aKey, aData, aHandler, aResult);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetUserData(const nsAString &aKey,
   1:                         nsIVariant **aResult)
   1: {
1391:   return nsNodeUtils::GetUserData(this, aKey, aResult);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::LookupPrefix(const nsAString& aNamespaceURI,
   1:                          nsAString& aPrefix)
   1: {
   1:   nsCOMPtr<nsIDOM3Node> root(do_QueryInterface(mRootContent));
   1:   if (root) {
   1:     return root->LookupPrefix(aNamespaceURI, aPrefix);
   1:   }
   1: 
   1:   SetDOMStringToNull(aPrefix);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::LookupNamespaceURI(const nsAString& aNamespacePrefix,
   1:                                nsAString& aNamespaceURI)
   1: {
   1:   if (NS_FAILED(nsContentUtils::LookupNamespaceURI(mRootContent,
   1:                                                    aNamespacePrefix,
   1:                                                    aNamespaceURI))) {
   1:     SetDOMStringToNull(aNamespaceURI);
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetInputEncoding(nsAString& aInputEncoding)
   1: {
   1:   return GetCharacterSet(aInputEncoding);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetXmlEncoding(nsAString& aXmlEncoding)
   1: {
   1:   if (mXMLDeclarationBits & XML_DECLARATION_BITS_DECLARATION_EXISTS &&
   1:       mXMLDeclarationBits & XML_DECLARATION_BITS_ENCODING_EXISTS) {
   1:     // XXX We don't store the encoding given in the xml declaration.
   1:     // For now, just output the inputEncoding which we do store.
   1:     GetInputEncoding(aXmlEncoding);
   1:   } else {
   1:     SetDOMStringToNull(aXmlEncoding);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetXmlStandalone(PRBool *aXmlStandalone)
   1: {
   1:   *aXmlStandalone = 
   1:     mXMLDeclarationBits & XML_DECLARATION_BITS_DECLARATION_EXISTS &&
   1:     mXMLDeclarationBits & XML_DECLARATION_BITS_STANDALONE_EXISTS &&
   1:     mXMLDeclarationBits & XML_DECLARATION_BITS_STANDALONE_YES;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::SetXmlStandalone(PRBool aXmlStandalone)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetXmlVersion(nsAString& aXmlVersion)
   1: {
   1:   // If there is no declaration, the value is "1.0".
   1: 
   1:   // XXX We only support "1.0", so always output "1.0" until that changes.
   1:   aXmlVersion.AssignLiteral("1.0");
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::SetXmlVersion(const nsAString& aXmlVersion)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetStrictErrorChecking(PRBool *aStrictErrorChecking)
   1: {
   1:   // This attribute is true by default, and we don't really support it being false.
   1:   *aStrictErrorChecking = PR_TRUE;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::SetStrictErrorChecking(PRBool aStrictErrorChecking)
   1: {
   1:   // We don't really support non-strict error checking, so just no-op for now.
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetDocumentURI(nsAString& aDocumentURI)
   1: {
   1:   if (mDocumentURI) {
   1:     nsCAutoString uri;
   1:     mDocumentURI->GetSpec(uri);
   1:     CopyUTF8toUTF16(uri, aDocumentURI);
   1:   } else {
   1:     SetDOMStringToNull(aDocumentURI);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::SetDocumentURI(const nsAString& aDocumentURI)
   1: {
   1:   // Not allowing this yet, need to think about security ramifications first.
   1:   // We use mDocumentURI to get principals for this document.
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: static void BlastSubtreeToPieces(nsINode *aNode);
   1: 
   1: PLDHashOperator PR_CALLBACK
   1: BlastFunc(nsAttrHashKey::KeyType aKey, nsIDOMNode *aData, void* aUserArg)
   1: {
   1:   nsCOMPtr<nsIAttribute> *attr =
3233:     static_cast<nsCOMPtr<nsIAttribute>*>(aUserArg);
   1: 
   1:   *attr = do_QueryInterface(aData);
   1: 
   1:   NS_ASSERTION(attr->get(),
   1:                "non-nsIAttribute somehow made it into the hashmap?!");
   1: 
   1:   return PL_DHASH_STOP;
   1: }
   1: 
   1: static void
   1: BlastSubtreeToPieces(nsINode *aNode)
   1: {
   1:   PRUint32 i, count;
   1:   if (aNode->IsNodeOfType(nsINode::eELEMENT)) {
3233:     nsGenericElement *element = static_cast<nsGenericElement*>(aNode);
   1:     const nsDOMAttributeMap *map = element->GetAttributeMap();
   1:     if (map) {
   1:       nsCOMPtr<nsIAttribute> attr;
   1:       while (map->Enumerate(BlastFunc, &attr) > 0) {
   1:         BlastSubtreeToPieces(attr);
   1: 
   1:         nsresult rv = element->UnsetAttr(attr->NodeInfo()->NamespaceID(),
   1:                                          attr->NodeInfo()->NameAtom(),
   1:                                          PR_FALSE);
   1: 
   1:         // XXX Should we abort here?
   1:         NS_ASSERTION(NS_SUCCEEDED(rv), "Uhoh, UnsetAttr shouldn't fail!");
   1:       }
   1:     }
   1:   }
   1: 
   1:   count = aNode->GetChildCount();
   1:   for (i = 0; i < count; ++i) {
   1:     BlastSubtreeToPieces(aNode->GetChildAt(0));
   1: 
   1:     nsresult rv = aNode->RemoveChildAt(0, PR_FALSE);
   1: 
   1:     // XXX Should we abort here?
   1:     NS_ASSERTION(NS_SUCCEEDED(rv), "Uhoh, RemoveChildAt shouldn't fail!");
   1:   }
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::AdoptNode(nsIDOMNode *aAdoptedNode, nsIDOMNode **aResult)
   1: {
   1:   NS_ENSURE_ARG(aAdoptedNode);
   1: 
   1:   *aResult = nsnull;
   1: 
   1:   nsresult rv = nsContentUtils::CheckSameOrigin(this, aAdoptedNode);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsCOMPtr<nsINode> adoptedNode;
   1:   PRUint16 nodeType;
   1:   aAdoptedNode->GetNodeType(&nodeType);
   1:   switch (nodeType) {
   1:     case nsIDOMNode::ATTRIBUTE_NODE:
   1:     {
   1:       // Remove from ownerElement.
   1:       nsCOMPtr<nsIDOMAttr> adoptedAttr = do_QueryInterface(aAdoptedNode, &rv);
   1:       NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:       nsCOMPtr<nsIDOMElement> ownerElement;
   1:       rv = adoptedAttr->GetOwnerElement(getter_AddRefs(ownerElement));
   1:       NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:       if (ownerElement) {
   1:         nsCOMPtr<nsIDOMAttr> newAttr;
   1:         rv = ownerElement->RemoveAttributeNode(adoptedAttr,
   1:                                                getter_AddRefs(newAttr));
   1:         NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:         newAttr.swap(adoptedAttr);
   1:       }
   1: 
   1:       adoptedNode = do_QueryInterface(adoptedAttr, &rv);
   1:       NS_ENSURE_SUCCESS(rv, rv);
   1:       break;
   1:     }
   1:     case nsIDOMNode::DOCUMENT_FRAGMENT_NODE:
   1:     case nsIDOMNode::ELEMENT_NODE:
   1:     case nsIDOMNode::PROCESSING_INSTRUCTION_NODE:
   1:     case nsIDOMNode::TEXT_NODE:
   1:     case nsIDOMNode::CDATA_SECTION_NODE:
   1:     case nsIDOMNode::COMMENT_NODE:
   1:     {
   1:       adoptedNode = do_QueryInterface(aAdoptedNode, &rv);
   1:       NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:       // We don't want to adopt an element into its own contentDocument or into
   1:       // a descendant contentDocument, so we check if the frameElement of this
   1:       // document or any of its parents is the adopted node or one of its
   1:       // descendants.
   1:       nsIDocument *doc = this;
   1:       do {
   1:         nsPIDOMWindow *win = doc->GetWindow();
   1:         if (win) {
   1:           nsCOMPtr<nsINode> node =
   1:             do_QueryInterface(win->GetFrameElementInternal());
   1:           if (node &&
   1:               nsContentUtils::ContentIsDescendantOf(node, adoptedNode)) {
   1:             return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
   1:           }
   1:         }
   1:       } while ((doc = doc->GetParentDocument()));
   1: 
   1:       // Remove from parent.
   1:       nsCOMPtr<nsIDOMNode> parent;
   1:       aAdoptedNode->GetParentNode(getter_AddRefs(parent));
   1:       NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:       if (parent) {
   1:         nsCOMPtr<nsIDOMNode> newChild;
   1:         rv = parent->RemoveChild(aAdoptedNode, getter_AddRefs(newChild));
   1:         NS_ENSURE_SUCCESS(rv, rv);
   1:       }
   1: 
   1:       break;
   1:     }
   1:     case nsIDOMNode::ENTITY_REFERENCE_NODE:
   1:     {
   1:       return NS_ERROR_NOT_IMPLEMENTED;
   1:     }
   1:     case nsIDOMNode::DOCUMENT_NODE:
   1:     case nsIDOMNode::DOCUMENT_TYPE_NODE:
   1:     case nsIDOMNode::ENTITY_NODE:
   1:     case nsIDOMNode::NOTATION_NODE:
   1:     {
   1:       return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
   1:     }
   1:     default:
   1:     {
   1:       NS_WARNING("Don't know how to adopt this nodetype for adoptNode.");
   1: 
   1:       return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
   1:     }
   1:   }
   1: 
   1:   nsIDocument *oldDocument = adoptedNode->GetOwnerDoc();
   1:   PRBool sameDocument = oldDocument == this;
   1: 
   1:   JSContext *cx = nsnull;
   1:   JSObject *oldScope = nsnull;
   1:   JSObject *newScope = nsnull;
   1:   if (!sameDocument && oldDocument) {
   1:     rv = nsContentUtils::GetContextAndScopes(oldDocument, this, &cx, &oldScope,
   1:                                              &newScope);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1:   }
   1: 
   1:   nsCOMArray<nsINode> nodesWithProperties;
   1:   rv = nsNodeUtils::Adopt(adoptedNode, sameDocument ? nsnull : mNodeInfoManager,
   1:                           cx, oldScope, newScope, nodesWithProperties);
   1:   if (NS_FAILED(rv)) {
   1:     // Disconnect all nodes from their parents, since some have the old document
   1:     // as their ownerDocument and some have this as their ownerDocument.
   1:     BlastSubtreeToPieces(adoptedNode);
   1: 
   1:     if (!sameDocument && oldDocument) {
   1:       PRUint32 i, count = nodesWithProperties.Count();
   1:       for (i = 0; i < count; ++i) {
   1:         // Remove all properties.
   1:         oldDocument->PropertyTable()->
   1:           DeleteAllPropertiesFor(nodesWithProperties[i]);
   1:       }
   1:     }
   1: 
   1:     return rv;
   1:   }
   1: 
   1:   PRUint32 i, count = nodesWithProperties.Count();
   1:   if (!sameDocument && oldDocument) {
   1:     nsPropertyTable *oldTable = oldDocument->PropertyTable();
   1:     nsPropertyTable *newTable = PropertyTable();
   1:     for (i = 0; i < count; ++i) {
   1:       rv = oldTable->TransferOrDeleteAllPropertiesFor(nodesWithProperties[i],
   1:                                                       newTable);
   1:       if (NS_FAILED(rv)) {
   1:         while (++i < count) {
   1:           oldTable->DeleteAllPropertiesFor(nodesWithProperties[i]);
   1:         }
   1: 
   1:         // Disconnect all nodes from their parents.
   1:         BlastSubtreeToPieces(adoptedNode);
   1: 
   1:         return rv;
   1:       }
   1:     }
   1:   }
   1: 
   1:   rv = nsNodeUtils::CallUserDataHandlers(nodesWithProperties, this,
   1:                                          nsIDOMUserDataHandler::NODE_ADOPTED,
   1:                                          PR_FALSE);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   return CallQueryInterface(adoptedNode, aResult);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetDomConfig(nsIDOMDOMConfiguration **aConfig)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::NormalizeDocument()
   1: {
   1:   // We don't support DOMConfigurations yet, so this just
   1:   // does a straight shot of normalization.
   1:   return Normalize();
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::RenameNode(nsIDOMNode *aNode,
   1:                        const nsAString& namespaceURI,
   1:                        const nsAString& qualifiedName,
   1:                        nsIDOMNode **aReturn)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetOwnerDocument(nsIDOMDocument** aOwnerDocument)
   1: {
   1:   *aOwnerDocument = nsnull;
   1: 
   1:   return NS_OK;
   1: }
   1: 
1418: nsresult
   1: nsDocument::GetListenerManager(PRBool aCreateIfNotFound,
   1:                                nsIEventListenerManager** aInstancePtrResult)
   1: {
   1:   if (mListenerManager) {
   1:     *aInstancePtrResult = mListenerManager;
   1:     NS_ADDREF(*aInstancePtrResult);
   1: 
   1:     return NS_OK;
   1:   }
   1:   if (!aCreateIfNotFound) {
   1:     *aInstancePtrResult = nsnull;
   1:     return NS_OK;
   1:   }
   1: 
   1:   nsresult rv = NS_NewEventListenerManager(getter_AddRefs(mListenerManager));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
3233:   mListenerManager->SetListenerTarget(static_cast<nsIDocument *>(this));
   1: 
   1:   *aInstancePtrResult = mListenerManager;
   1:   NS_ADDREF(*aInstancePtrResult);
   1: 
   1:   return NS_OK;
   1: }
   1: 
1419: nsresult
   1: nsDocument::GetSystemEventGroup(nsIDOMEventGroup **aGroup)
   1: {
   1:   nsCOMPtr<nsIEventListenerManager> manager;
   1:   if (NS_SUCCEEDED(GetListenerManager(PR_TRUE, getter_AddRefs(manager))) &&
   1:       manager) {
   1:     return manager->GetSystemEventGroupLM(aGroup);
   1:   }
   1: 
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1: nsresult
   1: nsDocument::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
   1: {
   1:   aVisitor.mCanHandle = PR_TRUE;
   1:    // FIXME! This is a hack to make middle mouse paste working also in Editor.
   1:    // Bug 329119
   1:   aVisitor.mForceContentDispatch = PR_TRUE;
   1: 
   1:   // Load events must not propagate to |window| object, see bug 335251.
   1:   if (aVisitor.mEvent->message != NS_LOAD) {
   1:     aVisitor.mParentTarget = GetWindow();
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsDocument::PostHandleEvent(nsEventChainPostVisitor& aVisitor)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsDocument::DispatchDOMEvent(nsEvent* aEvent,
   1:                              nsIDOMEvent* aDOMEvent,
   1:                              nsPresContext* aPresContext,
   1:                              nsEventStatus* aEventStatus)
   1: {
3233:   return nsEventDispatcher::DispatchDOMEvent(static_cast<nsINode*>(this),
   1:                                              aEvent, aDOMEvent,
   1:                                              aPresContext, aEventStatus);
   1: }
   1: 
   1: nsresult
   1: nsDocument::AddEventListenerByIID(nsIDOMEventListener *aListener,
   1:                                   const nsIID& aIID)
   1: {
   1:   nsCOMPtr<nsIEventListenerManager> manager;
   1: 
   1:   GetListenerManager(PR_TRUE, getter_AddRefs(manager));
   1:   if (manager) {
   1:     manager->AddEventListenerByIID(aListener, aIID, NS_EVENT_FLAG_BUBBLE);
   1:     return NS_OK;
   1:   }
   1: 
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1: nsresult
   1: nsDocument::RemoveEventListenerByIID(nsIDOMEventListener *aListener,
   1:                                      const nsIID& aIID)
   1: {
   1:   if (!mListenerManager) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   mListenerManager->RemoveEventListenerByIID(aListener, aIID,
   1:                                              NS_EVENT_FLAG_BUBBLE);
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsDocument::AddEventListener(const nsAString& aType,
   1:                              nsIDOMEventListener* aListener,
   1:                              PRBool aUseCapture)
   1: {
   1:   return AddEventListener(aType, aListener, aUseCapture,
   1:                           !nsContentUtils::IsChromeDoc(this));
   1: }
   1: 
   1: nsresult
   1: nsDocument::RemoveEventListener(const nsAString& aType,
   1:                                 nsIDOMEventListener* aListener,
   1:                                 PRBool aUseCapture)
   1: {
   1:   return RemoveGroupedEventListener(aType, aListener, aUseCapture, nsnull);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::DispatchEvent(nsIDOMEvent* aEvent, PRBool *_retval)
   1: {
   1:   // Obtain a presentation context
 981:   nsIPresShell *shell = GetPrimaryShell();
   1:   nsCOMPtr<nsPresContext> context;
   1:   if (shell) {
   1:      context = shell->GetPresContext();
   1:   }
   1: 
   1:   nsEventStatus status = nsEventStatus_eIgnore;
   1:   nsresult rv =
3233:     nsEventDispatcher::DispatchDOMEvent(static_cast<nsINode*>(this),
   1:                                         nsnull, aEvent, context, &status);
   1: 
   1:   *_retval = (status != nsEventStatus_eConsumeNoDefault);
   1:   return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::AddGroupedEventListener(const nsAString& aType,
   1:                                     nsIDOMEventListener *aListener,
   1:                                     PRBool aUseCapture,
   1:                                     nsIDOMEventGroup *aEvtGrp)
   1: {
   1:   nsCOMPtr<nsIEventListenerManager> manager;
   1: 
   1:   nsresult rv = GetListenerManager(PR_TRUE, getter_AddRefs(manager));
   1:   if (NS_SUCCEEDED(rv) && manager) {
   1:     PRInt32 flags = aUseCapture ? NS_EVENT_FLAG_CAPTURE : NS_EVENT_FLAG_BUBBLE;
   1: 
   1:     manager->AddEventListenerByType(aListener, aType, flags, aEvtGrp);
   1:     return NS_OK;
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::RemoveGroupedEventListener(const nsAString& aType,
   1:                                        nsIDOMEventListener *aListener,
   1:                                        PRBool aUseCapture,
   1:                                        nsIDOMEventGroup *aEvtGrp)
   1: {
   1:   if (!mListenerManager) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   PRInt32 flags = aUseCapture ? NS_EVENT_FLAG_CAPTURE : NS_EVENT_FLAG_BUBBLE;
   1: 
   1:   mListenerManager->RemoveEventListenerByType(aListener, aType, flags,
   1:                                               aEvtGrp);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::CanTrigger(const nsAString & type, PRBool *_retval)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::IsRegisteredHere(const nsAString & type, PRBool *_retval)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::AddEventListener(const nsAString& aType,
   1:                              nsIDOMEventListener *aListener,
   1:                              PRBool aUseCapture, PRBool aWantsUntrusted)
   1: {
   1:   nsCOMPtr<nsIEventListenerManager> manager;
   1:   nsresult rv = GetListenerManager(PR_TRUE, getter_AddRefs(manager));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   PRInt32 flags = aUseCapture ? NS_EVENT_FLAG_CAPTURE : NS_EVENT_FLAG_BUBBLE;
   1: 
   1:   if (aWantsUntrusted) {
   1:     flags |= NS_PRIV_EVENT_UNTRUSTED_PERMITTED;
   1:   }
   1: 
   1:   return manager->AddEventListenerByType(aListener, aType, flags, nsnull);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::CreateEvent(const nsAString& aEventType, nsIDOMEvent** aReturn)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aReturn);
   1:   *aReturn = nsnull;
   1: 
   1:   // Obtain a presentation shell
   1: 
 981:   nsIPresShell *shell = GetPrimaryShell();
   1: 
   1:   nsPresContext *presContext = nsnull;
   1: 
   1:   if (shell) {
   1:     // Retrieve the context
   1:     presContext = shell->GetPresContext();
   1:   }
   1: 
   1:   // Create event even without presContext.
   1:   return nsEventDispatcher::CreateEvent(presContext, nsnull,
   1:                                         aEventType, aReturn);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::CreateEventGroup(nsIDOMEventGroup **aInstancePtrResult)
   1: {
   1:   nsresult rv;
   1:   nsCOMPtr<nsIDOMEventGroup> group(do_CreateInstance(kDOMEventGroupCID, &rv));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   *aInstancePtrResult = group;
   1:   NS_ADDREF(*aInstancePtrResult);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: void
   1: nsDocument::FlushPendingNotifications(mozFlushType aType)
   1: {
6170:   nsCOMPtr<nsIContentSink> sink;
6170:   if (mParser) {
6170:     sink = mParser->GetContentSink();
6170:   } else {
6170:     sink = do_QueryReferent(mWeakSink);
6170:   }
   1:   // Determine if it is safe to flush the sink notifications
   1:   // by determining if it safe to flush all the presshells.
6170:   if (sink && (aType == Flush_Content || IsSafeToFlush())) {
   1:     sink->FlushPendingNotifications(aType);
   1:   }
   1: 
   1:   // Should we be flushing pending binding constructors in here?
   1: 
   1:   nsPIDOMWindow *window = GetWindow();
   1: 
4886:   if (aType <= Flush_ContentAndNotify || !window) {
   1:     // Nothing to do here
   1:     return;
   1:   }
   1: 
   1:   // We should be able to replace all this nsIDocShell* code with code
   1:   // that uses mParentDocument, but mParentDocument is never set in
   1:   // the current code!
   1: 
   1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem =
   1:     do_QueryInterface(window->GetDocShell());
   1: 
   1:   if (docShellAsItem) {
   1:     nsCOMPtr<nsIDocShellTreeItem> docShellParent;
   1:     docShellAsItem->GetSameTypeParent(getter_AddRefs(docShellParent));
   1: 
   1:     nsCOMPtr<nsIDOMWindow> parentWin(do_GetInterface(docShellParent));
   1: 
   1:     if (parentWin) {
   1:       nsCOMPtr<nsIDOMDocument> dom_doc;
   1:       parentWin->GetDocument(getter_AddRefs(dom_doc));
   1: 
   1:       nsCOMPtr<nsIDocument> doc(do_QueryInterface(dom_doc));
   1: 
   1:       // If we have a parent we must flush the parent too to ensure that our
   1:       // container is reflown if its size was changed.  But if it's not safe to
   1:       // flush ourselves, then don't flush the parent, since that can cause
   1:       // things like resizes of our frame's widget, which we can't handle while
   1:       // flushing is unsafe.
   1:       if (doc && IsSafeToFlush()) {
   1:         doc->FlushPendingNotifications(aType);
   1:       }
   1:     }
   1:   }
   1: 
1722:   nsPresShellIterator iter(this);
1722:   nsCOMPtr<nsIPresShell> shell;
1722:   while ((shell = iter.GetNextShell())) {
   1:     shell->FlushPendingNotifications(aType);
   1:   }
   1: }
   1: 
   1: void
   1: nsDocument::AddReference(void *aKey, nsISupports *aReference)
   1: {
   1:   if (mScriptGlobalObject) {
   1:     if (!mContentWrapperHash) {
   1:       mContentWrapperHash = new nsInterfaceHashtable<nsVoidPtrHashKey, nsISupports>;
   1:       if (mContentWrapperHash) {
   1:         mContentWrapperHash->Init(10);
   1:       }
   1:     }
   1:     
   1:     if (mContentWrapperHash)
   1:       mContentWrapperHash->Put(aKey, aReference);
   1:   }
   1: }
   1: 
   1: nsISupports*
   1: nsDocument::GetReference(void *aKey)
   1: {
   1:   // NB: This method is part of content cycle collection,
   1:   // and must *not* Addref its return value.
   1:     
   1:   if (mContentWrapperHash)
   1:     return mContentWrapperHash->GetWeak(aKey);
   1:   return nsnull;
   1: }
   1: 
   1: void
   1: nsDocument::RemoveReference(void *aKey)
   1: {
   1:   if (mContentWrapperHash) {
   1:     mContentWrapperHash->Remove(aKey);
   1:   }
   1: }
   1: 
   1: nsIScriptEventManager*
   1: nsDocument::GetScriptEventManager()
   1: {
   1:   if (!mScriptEventManager) {
   1:     mScriptEventManager = new nsScriptEventManager(this);
   1:     // automatically AddRefs
   1:   }
   1: 
   1:   return mScriptEventManager;
   1: }
   1: 
   1: void
   1: nsDocument::SetXMLDeclaration(const PRUnichar *aVersion,
   1:                               const PRUnichar *aEncoding,
   1:                               const PRInt32 aStandalone)
   1: {
   1:   if (!aVersion || *aVersion == '\0') {
   1:     mXMLDeclarationBits = 0;
   1:     return;
   1:   }
   1: 
   1:   mXMLDeclarationBits = XML_DECLARATION_BITS_DECLARATION_EXISTS;
   1: 
   1:   if (aEncoding && *aEncoding != '\0') {
   1:     mXMLDeclarationBits |= XML_DECLARATION_BITS_ENCODING_EXISTS;
   1:   }
   1: 
   1:   if (aStandalone == 1) {
   1:     mXMLDeclarationBits |= XML_DECLARATION_BITS_STANDALONE_EXISTS |
   1:                            XML_DECLARATION_BITS_STANDALONE_YES;
   1:   }
   1:   else if (aStandalone == 0) {
   1:     mXMLDeclarationBits |= XML_DECLARATION_BITS_STANDALONE_EXISTS;
   1:   }
   1: }
   1: 
   1: void
   1: nsDocument::GetXMLDeclaration(nsAString& aVersion, nsAString& aEncoding,
   1:                               nsAString& aStandalone)
   1: {
   1:   aVersion.Truncate();
   1:   aEncoding.Truncate();
   1:   aStandalone.Truncate();
   1: 
   1:   if (!(mXMLDeclarationBits & XML_DECLARATION_BITS_DECLARATION_EXISTS)) {
   1:     return;
   1:   }
   1: 
   1:   // always until we start supporting 1.1 etc.
   1:   aVersion.AssignLiteral("1.0");
   1: 
   1:   if (mXMLDeclarationBits & XML_DECLARATION_BITS_ENCODING_EXISTS) {
   1:     // This is what we have stored, not necessarily what was written
   1:     // in the original
   1:     GetCharacterSet(aEncoding);
   1:   }
   1: 
   1:   if (mXMLDeclarationBits & XML_DECLARATION_BITS_STANDALONE_EXISTS) {
   1:     if (mXMLDeclarationBits & XML_DECLARATION_BITS_STANDALONE_YES) {
   1:       aStandalone.AssignLiteral("yes");
   1:     } else {
   1:       aStandalone.AssignLiteral("no");
   1:     }
   1:   }
   1: }
   1: 
   1: PRBool
   1: nsDocument::IsScriptEnabled()
   1: {
   1:   nsCOMPtr<nsIScriptSecurityManager> sm(do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID));
   1:   NS_ENSURE_TRUE(sm, PR_TRUE);
   1: 
   1:   nsIScriptGlobalObject* globalObject = GetScriptGlobalObject();
   1:   NS_ENSURE_TRUE(globalObject, PR_TRUE);
   1: 
   1:   nsIScriptContext *scriptContext = globalObject->GetContext();
   1:   NS_ENSURE_TRUE(scriptContext, PR_TRUE);
   1: 
   1:   JSContext* cx = (JSContext *) scriptContext->GetNativeContext();
   1:   NS_ENSURE_TRUE(cx, PR_TRUE);
   1: 
   1:   PRBool enabled;
   1:   nsresult rv = sm->CanExecuteScripts(cx, NodePrincipal(), &enabled);
   1:   NS_ENSURE_SUCCESS(rv, PR_TRUE);
   1:   return enabled;
   1: }
   1: 
   1: nsresult
   1: nsDocument::GetRadioGroup(const nsAString& aName,
   1:                           nsRadioGroupStruct **aRadioGroup)
   1: {
   1:   nsAutoString tmKey(aName);
   1:   if(!IsCaseSensitive())
   1:      ToLowerCase(tmKey); //should case-insensitive.
   1:   nsStringKey key(tmKey);
   1:   nsRadioGroupStruct *radioGroup =
3233:     static_cast<nsRadioGroupStruct *>(mRadioGroups.Get(&key));
   1: 
   1:   if (!radioGroup) {
   1:     radioGroup = new nsRadioGroupStruct();
   1:     NS_ENSURE_TRUE(radioGroup, NS_ERROR_OUT_OF_MEMORY);
   1:     mRadioGroups.Put(&key, radioGroup);
   1:   }
   1: 
   1:   *aRadioGroup = radioGroup;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::SetCurrentRadioButton(const nsAString& aName,
   1:                                   nsIDOMHTMLInputElement* aRadio)
   1: {
   1:   nsRadioGroupStruct* radioGroup = nsnull;
   1:   GetRadioGroup(aName, &radioGroup);
   1:   if (radioGroup) {
   1:     radioGroup->mSelectedRadioButton = aRadio;
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetCurrentRadioButton(const nsAString& aName,
   1:                                   nsIDOMHTMLInputElement** aRadio)
   1: {
   1:   nsRadioGroupStruct* radioGroup = nsnull;
   1:   GetRadioGroup(aName, &radioGroup);
   1:   if (radioGroup) {
   1:     *aRadio = radioGroup->mSelectedRadioButton;
   1:     NS_IF_ADDREF(*aRadio);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetPositionInGroup(nsIDOMHTMLInputElement *aRadio,
   1:                                PRInt32 *aPositionIndex,
   1:                                PRInt32 *aItemsInGroup)
   1: {
   1:   *aPositionIndex = 0;
   1:   *aItemsInGroup = 1;
   1:   nsAutoString name;
   1:   aRadio->GetName(name);
   1:   if (name.IsEmpty()) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   nsRadioGroupStruct* radioGroup = nsnull;
   1:   nsresult rv = GetRadioGroup(name, &radioGroup);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsCOMPtr<nsIFormControl> radioControl(do_QueryInterface(aRadio));
   1:   NS_ASSERTION(radioControl, "Radio button should implement nsIFormControl");
   1:   *aPositionIndex = radioGroup->mRadioButtons.IndexOf(radioControl);
   1:   NS_ASSERTION(*aPositionIndex >= 0, "Radio button not found in its own group");
   1:   *aItemsInGroup = radioGroup->mRadioButtons.Count();
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetNextRadioButton(const nsAString& aName,
   1:                                const PRBool aPrevious,
   1:                                nsIDOMHTMLInputElement*  aFocusedRadio,
   1:                                nsIDOMHTMLInputElement** aRadioOut)
   1: {
   1:   // XXX Can we combine the HTML radio button method impls of 
   1:   //     nsDocument and nsHTMLFormControl?
   1:   // XXX Why is HTML radio button stuff in nsDocument, as 
   1:   //     opposed to nsHTMLDocument?
   1:   *aRadioOut = nsnull;
   1: 
   1:   nsRadioGroupStruct* radioGroup = nsnull;
   1:   GetRadioGroup(aName, &radioGroup);
   1:   if (!radioGroup) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   // Return the radio button relative to the focused radio button.
   1:   // If no radio is focused, get the radio relative to the selected one.
   1:   nsCOMPtr<nsIDOMHTMLInputElement> currentRadio;
   1:   if (aFocusedRadio) {
   1:     currentRadio = aFocusedRadio;
   1:   }
   1:   else {
   1:     currentRadio = radioGroup->mSelectedRadioButton;
   1:     if (!currentRadio) {
   1:       return NS_ERROR_FAILURE;
   1:     }
   1:   }
   1:   nsCOMPtr<nsIFormControl> radioControl(do_QueryInterface(currentRadio));
   1:   PRInt32 index = radioGroup->mRadioButtons.IndexOf(radioControl);
   1:   if (index < 0) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   PRInt32 numRadios = radioGroup->mRadioButtons.Count();
   1:   PRBool disabled;
   1:   nsCOMPtr<nsIDOMHTMLInputElement> radio;
   1:   do {
   1:     if (aPrevious) {
   1:       if (--index < 0) {
   1:         index = numRadios -1;
   1:       }
   1:     }
   1:     else if (++index >= numRadios) {
   1:       index = 0;
   1:     }
3233:     radio = do_QueryInterface(static_cast<nsIFormControl*>(radioGroup->mRadioButtons.ElementAt(index)));
   1:     NS_ASSERTION(radio, "mRadioButtons holding a non-radio button");
   1:     radio->GetDisabled(&disabled);
   1:   } while (disabled && radio != currentRadio);
   1: 
   1:   NS_IF_ADDREF(*aRadioOut = radio);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::AddToRadioGroup(const nsAString& aName,
   1:                             nsIFormControl* aRadio)
   1: {
   1:   nsRadioGroupStruct* radioGroup = nsnull;
   1:   GetRadioGroup(aName, &radioGroup);
   1:   if (radioGroup) {
   1:     radioGroup->mRadioButtons.AppendElement(aRadio);
   1:     NS_IF_ADDREF(aRadio);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::RemoveFromRadioGroup(const nsAString& aName,
   1:                                  nsIFormControl* aRadio)
   1: {
   1:   nsRadioGroupStruct* radioGroup = nsnull;
   1:   GetRadioGroup(aName, &radioGroup);
   1:   if (radioGroup) {
   1:     if (radioGroup->mRadioButtons.RemoveElement(aRadio)) {
   1:       NS_IF_RELEASE(aRadio);
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::WalkRadioGroup(const nsAString& aName,
   1:                            nsIRadioVisitor* aVisitor,
   1:                            PRBool aFlushContent)
   1: {
   1:   nsRadioGroupStruct* radioGroup = nsnull;
   1:   GetRadioGroup(aName, &radioGroup);
   1:   if (!radioGroup) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   PRBool stop = PR_FALSE;
   1:   for (int i = 0; i < radioGroup->mRadioButtons.Count(); i++) {
3233:     aVisitor->Visit(static_cast<nsIFormControl *>
3233:                                (radioGroup->mRadioButtons.ElementAt(i)),
   1:                     &stop);
   1:     if (stop) {
   1:       return NS_OK;
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: void
   1: nsDocument::RetrieveRelevantHeaders(nsIChannel *aChannel)
   1: {
   1:   nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(aChannel);
   1:   PRTime modDate = LL_ZERO;
   1:   nsresult rv;
   1: 
   1:   if (httpChannel) {
   1:     nsCAutoString tmp;
   1:     rv = httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("last-modified"),
   1:                                         tmp);
   1: 
   1:     if (NS_SUCCEEDED(rv)) {
   1:       PRTime time;
   1:       PRStatus st = PR_ParseTimeString(tmp.get(), PR_TRUE, &time);
   1:       if (st == PR_SUCCESS) {
   1:         modDate = time;
   1:       }
   1:     }
   1: 
   1:     // The misspelled key 'referer' is as per the HTTP spec
   1:     rv = httpChannel->GetRequestHeader(NS_LITERAL_CSTRING("referer"),
   1:                                        mReferrer);
   1:     if (NS_FAILED(rv)) {
   1:       mReferrer.Truncate();
   1:     }
   1: 
   1:     static const char *const headers[] = {
   1:       "default-style",
   1:       "content-style-type",
   1:       "content-language",
   1:       "content-disposition",
   1:       "refresh",
   1:       // add more http headers if you need
   1:       // XXXbz don't add content-location support without reading bug
   1:       // 238654 and its dependencies/dups first.
   1:       0
   1:     };
   1:     
   1:     nsCAutoString headerVal;
   1:     const char *const *name = headers;
   1:     while (*name) {
   1:       rv =
   1:         httpChannel->GetResponseHeader(nsDependentCString(*name), headerVal);
   1:       if (NS_SUCCEEDED(rv) && !headerVal.IsEmpty()) {
   1:         nsCOMPtr<nsIAtom> key = do_GetAtom(*name);
   1:         SetHeaderData(key, NS_ConvertASCIItoUTF16(headerVal));
   1:       }
   1:       ++name;
   1:     }
   1:   } else {
   1:     nsCOMPtr<nsIFileChannel> fileChannel = do_QueryInterface(aChannel);
   1:     if (fileChannel) {
   1:       nsCOMPtr<nsIFile> file;
   1:       fileChannel->GetFile(getter_AddRefs(file));
   1:       if (file) {
   1:         PRTime msecs;
   1:         rv = file->GetLastModifiedTime(&msecs);
   1: 
   1:         if (NS_SUCCEEDED(rv)) {
   1:           PRInt64 intermediateValue;
   1:           LL_I2L(intermediateValue, PR_USEC_PER_MSEC);
   1:           LL_MUL(modDate, msecs, intermediateValue);
   1:         }
   1:       }
   1:     } else {
   1:       nsCOMPtr<nsIMultiPartChannel> partChannel = do_QueryInterface(aChannel);
   1:       if (partChannel) {
   1:         nsCAutoString contentDisp;
   1:         rv = partChannel->GetContentDisposition(contentDisp);
   1:         if (NS_SUCCEEDED(rv) && !contentDisp.IsEmpty()) {
   1:           SetHeaderData(nsGkAtoms::headerContentDisposition,
   1:                         NS_ConvertASCIItoUTF16(contentDisp));
   1:         }
   1:       }
   1:     }
   1:   }
   1: 
   1:   if (LL_IS_ZERO(modDate)) {
   1:     // We got nothing from our attempt to ask nsIFileChannel and
   1:     // nsIHttpChannel for the last modified time. Return the current
   1:     // time.
   1:     modDate = PR_Now();
   1:   }
   1: 
   1:   mLastModified.Truncate();
   1:   if (LL_NE(modDate, LL_ZERO)) {
   1:     PRExplodedTime prtime;
   1:     PR_ExplodeTime(modDate, PR_LocalTimeParameters, &prtime);
   1:     // "MM/DD/YYYY hh:mm:ss"
   1:     char formatedTime[20];
   1:     if (sprintf(formatedTime, "%02d/%02d/%04d %02d:%02d:%02d",
   1:                 prtime.tm_month + 1, prtime.tm_mday, prtime.tm_year,
   1:                 prtime.tm_hour     ,  prtime.tm_min,  prtime.tm_sec)) {
   1:       CopyASCIItoUTF16(nsDependentCString(formatedTime), mLastModified);
   1:     }
   1:   }
   1: }
   1: 
   1: nsresult
   1: nsDocument::CreateElem(nsIAtom *aName, nsIAtom *aPrefix, PRInt32 aNamespaceID,
   1:                        PRBool aDocumentDefaultType, nsIContent **aResult)
   1: {
   1:   nsresult rv;
   1: #ifdef DEBUG
   1:   nsAutoString qName;
   1:   if (aPrefix) {
   1:     aPrefix->ToString(qName);
   1:     qName.Append(':');
   1:   }
   1:   const char *name;
   1:   aName->GetUTF8String(&name);
   1:   AppendUTF8toUTF16(name, qName);
   1: 
   1:   rv = nsContentUtils::CheckQName(qName, PR_TRUE);
   1:   NS_ASSERTION(NS_SUCCEEDED(rv),
   1:                "Don't pass invalid names to nsDocument::CreateElem, "
   1:                "check caller.");
   1: #endif
   1: 
   1:   *aResult = nsnull;
   1:   
   1:   PRInt32 elementType = aDocumentDefaultType ? mDefaultElementType :
   1:                                                aNamespaceID;
   1: 
   1:   nsCOMPtr<nsINodeInfo> nodeInfo;
   1:   rv = mNodeInfoManager->GetNodeInfo(aName, aPrefix, aNamespaceID,
   1:                                      getter_AddRefs(nodeInfo));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   return NS_NewElement(aResult, elementType, nodeInfo);
   1: }
   1: 
   1: PRBool
   1: nsDocument::IsSafeToFlush() const
   1: {
   1:   PRBool isSafeToFlush = PR_TRUE;
3233:   nsPresShellIterator iter(const_cast<nsIDocument*>
3233:                                      (static_cast<const nsIDocument*>(this)));
1722:   nsCOMPtr<nsIPresShell> shell;
1722:   while ((shell = iter.GetNextShell()) && isSafeToFlush) {
   1:     shell->IsSafeToFlush(isSafeToFlush);
   1:   }
   1:   return isSafeToFlush;
   1: }
   1: 
   1: nsresult
   1: nsDocument::Sanitize()
   1: {
   1:   // Sanitize the document by resetting all password fields and any form
   1:   // fields with autocomplete=off to their default values.  We do this now,
   1:   // instead of when the presentation is restored, to offer some protection
   1:   // in case there is ever an exploit that allows a cached document to be
   1:   // accessed from a different document.
   1: 
   1:   // First locate all input elements, regardless of whether they are
   1:   // in a form, and reset the password and autocomplete=off elements.
   1: 
   1:   nsCOMPtr<nsIDOMNodeList> nodes;
   1:   nsresult rv = GetElementsByTagName(NS_LITERAL_STRING("input"),
   1:                                      getter_AddRefs(nodes));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   PRUint32 length = 0;
   1:   if (nodes)
   1:     nodes->GetLength(&length);
   1: 
   1:   nsCOMPtr<nsIDOMNode> item;
   1:   nsAutoString value;
   1:   PRUint32 i;
   1: 
   1:   for (i = 0; i < length; ++i) {
   1:     nodes->Item(i, getter_AddRefs(item));
   1:     NS_ASSERTION(item, "null item in node list!");
   1: 
   1:     nsCOMPtr<nsIDOMHTMLInputElement> input = do_QueryInterface(item);
   1:     if (!input)
   1:       continue;
   1: 
   1:     PRBool resetValue = PR_FALSE;
   1: 
   1:     input->GetAttribute(NS_LITERAL_STRING("autocomplete"), value);
   1:     if (value.LowerCaseEqualsLiteral("off")) {
   1:       resetValue = PR_TRUE;
   1:     } else {
   1:       input->GetType(value);
   1:       if (value.LowerCaseEqualsLiteral("password"))
   1:         resetValue = PR_TRUE;
   1:     }
   1: 
   1:     if (resetValue) {
   1:       nsCOMPtr<nsIFormControl> fc = do_QueryInterface(input);
   1:       fc->Reset();
   1:     }
   1:   }
   1: 
   1:   // Now locate all _form_ elements that have autocomplete=off and reset them
   1:   rv = GetElementsByTagName(NS_LITERAL_STRING("form"), getter_AddRefs(nodes));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   length = 0;
   1:   if (nodes)
   1:     nodes->GetLength(&length);
   1: 
   1:   for (i = 0; i < length; ++i) {
   1:     nodes->Item(i, getter_AddRefs(item));
   1:     NS_ASSERTION(item, "null item in nodelist");
   1: 
   1:     nsCOMPtr<nsIDOMHTMLFormElement> form = do_QueryInterface(item);
   1:     if (!form)
   1:       continue;
   1: 
   1:     form->GetAttribute(NS_LITERAL_STRING("autocomplete"), value);
   1:     if (value.LowerCaseEqualsLiteral("off"))
   1:       form->Reset();
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: struct SubDocEnumArgs
   1: {
   1:   nsIDocument::nsSubDocEnumFunc callback;
   1:   void *data;
   1: };
   1: 
   1: PR_STATIC_CALLBACK(PLDHashOperator)
   1: SubDocHashEnum(PLDHashTable *table, PLDHashEntryHdr *hdr,
   1:                PRUint32 number, void *arg)
   1: {
3233:   SubDocMapEntry *entry = static_cast<SubDocMapEntry*>(hdr);
3233:   SubDocEnumArgs *args = static_cast<SubDocEnumArgs*>(arg);
   1: 
   1:   nsIDocument *subdoc = entry->mSubDocument;
   1:   PRBool next = subdoc ? args->callback(subdoc, args->data) : PR_TRUE;
   1: 
   1:   return next ? PL_DHASH_NEXT : PL_DHASH_STOP;
   1: }
   1: 
   1: void
   1: nsDocument::EnumerateSubDocuments(nsSubDocEnumFunc aCallback, void *aData)
   1: {
   1:   if (mSubDocuments) {
   1:     SubDocEnumArgs args = { aCallback, aData };
   1:     PL_DHashTableEnumerate(mSubDocuments, SubDocHashEnum, &args);
   1:   }
   1: }
   1: 
   1: PR_STATIC_CALLBACK(PLDHashOperator)
   1: CanCacheSubDocument(PLDHashTable *table, PLDHashEntryHdr *hdr,
   1:                     PRUint32 number, void *arg)
   1: {
3233:   SubDocMapEntry *entry = static_cast<SubDocMapEntry*>(hdr);
3233:   PRBool *canCacheArg = static_cast<PRBool*>(arg);
   1: 
   1:   nsIDocument *subdoc = entry->mSubDocument;
   1: 
   1:   // The aIgnoreRequest we were passed is only for us, so don't pass it on.
   1:   PRBool canCache = subdoc ? subdoc->CanSavePresentation(nsnull) : PR_FALSE;
   1:   if (!canCache) {
   1:     *canCacheArg = PR_FALSE;
   1:     return PL_DHASH_STOP;
   1:   }
   1: 
   1:   return PL_DHASH_NEXT;
   1: }
   1: 
   1: #ifdef DEBUG_bryner
   1: #define DEBUG_PAGE_CACHE
   1: #endif
   1: 
   1: PRBool
   1: nsDocument::CanSavePresentation(nsIRequest *aNewRequest)
   1: {
   1:   // Check our event listener manager for unload/beforeunload listeners.
1418:   nsCOMPtr<nsPIDOMEventTarget> piTarget = do_QueryInterface(mScriptGlobalObject);
1418:   if (piTarget) {
   1:     nsCOMPtr<nsIEventListenerManager> manager;
1418:     piTarget->GetListenerManager(PR_FALSE, getter_AddRefs(manager));
   1:     if (manager && manager->HasUnloadListeners()) {
   1:       return PR_FALSE;
   1:     }
   1:   }
   1: 
   1:   nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
   1:   if (loadGroup) {
   1:     nsCOMPtr<nsISimpleEnumerator> requests;
   1:     loadGroup->GetRequests(getter_AddRefs(requests));
   1: 
   1:     PRBool hasMore = PR_FALSE;
   1: 
   1:     while (NS_SUCCEEDED(requests->HasMoreElements(&hasMore)) && hasMore) {
   1:       nsCOMPtr<nsISupports> elem;
   1:       requests->GetNext(getter_AddRefs(elem));
   1: 
   1:       nsCOMPtr<nsIRequest> request = do_QueryInterface(elem);
   1:       if (request && request != aNewRequest) {
   1: #ifdef DEBUG_PAGE_CACHE
   1:         nsCAutoString requestName, docSpec;
   1:         request->GetName(requestName);
   1:         if (mDocumentURI)
   1:           mDocumentURI->GetSpec(docSpec);
   1: 
   1:         printf("document %s has request %s\n",
   1:                docSpec.get(), requestName.get());
   1: #endif
   1:         return PR_FALSE;
   1:       }
   1:     }
   1:   }
   1: 
   1:   PRBool canCache = PR_TRUE;
   1:   if (mSubDocuments)
   1:     PL_DHashTableEnumerate(mSubDocuments, CanCacheSubDocument, &canCache);
   1: 
   1:   return canCache;
   1: }
   1: 
   1: void
   1: nsDocument::Destroy()
   1: {
   1:   // The ContentViewer wants to release the document now.  So, tell our content
   1:   // to drop any references to the document so that it can be destroyed.
   1:   if (mIsGoingAway)
   1:     return;
   1: 
2545:   PRInt32 count = mChildren.ChildCount();
   1: 
   1:   mIsGoingAway = PR_TRUE;
2545:   DestroyLinkMap();
2545:   for (PRInt32 indx = 0; indx < count; ++indx) {
2545:     // XXXbz what we _should_ do here is to clear mChildren and null out
2545:     // mRootContent.  If we did this (or at least the latter), we could remove
2545:     // the silly null-checks in nsHTMLDocument::MatchLinks.  Unfortunately,
2545:     // doing that introduces several problems:
2545:     // 1) Focus issues (see bug 341730).  The fix for bug 303260 may fix these.
2545:     // 2) Crashes in OnPageHide if it fires after Destroy.  See bug 303260
2545:     //    comments 9 and 10.
2545:     // So we're just creating an inconsistent DOM for now and hoping.  :(
2545:     mChildren.ChildAt(indx)->UnbindFromTree();
2545:   }
   1:   mLayoutHistoryState = nsnull;
   1: 
   1:   nsContentList::OnDocumentDestroy(this);
2545:   delete mContentWrapperHash;
2545:   mContentWrapperHash = nsnull;
   1: }
   1: 
   1: already_AddRefed<nsILayoutHistoryState>
   1: nsDocument::GetLayoutHistoryState() const
   1: {
   1:   nsILayoutHistoryState* state = nsnull;
   1:   if (!mScriptGlobalObject) {
   1:     NS_IF_ADDREF(state = mLayoutHistoryState);
   1:   } else {
   1:     nsCOMPtr<nsIDocShell> docShell(do_QueryReferent(mDocumentContainer));
   1:     if (docShell) {
   1:       docShell->GetLayoutHistoryState(&state);
   1:     }
   1:   }
   1: 
   1:   return state;
   1: }
   1: 
   1: void
   1: nsDocument::BlockOnload()
   1: {
   1:   // If mScriptGlobalObject is null, we shouldn't be messing with the loadgroup
   1:   // -- it's not ours.
   1:   if (mOnloadBlockCount == 0 && mScriptGlobalObject) {
   1:     nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
   1:     if (loadGroup) {
   1:       loadGroup->AddRequest(mOnloadBlocker, nsnull);
   1:     }
   1:   }
   1:   ++mOnloadBlockCount;      
   1: }
   1: 
   1: void
   1: nsDocument::UnblockOnload(PRBool aFireSync)
   1: {
   1:   if (mOnloadBlockCount == 0) {
   1:     NS_NOTREACHED("More UnblockOnload() calls than BlockOnload() calls; dropping call");
   1:     return;
   1:   }
   1: 
   1:   --mOnloadBlockCount;
   1: 
   1:   // If mScriptGlobalObject is null, we shouldn't be messing with the loadgroup
   1:   // -- it's not ours.
   1:   if (mOnloadBlockCount == 0 && mScriptGlobalObject) {
   1:     if (aFireSync) {
   1:       // Increment mOnloadBlockCount, since DoUnblockOnload will decrement it
   1:       ++mOnloadBlockCount;
   1:       DoUnblockOnload();
   1:     } else {
   1:       PostUnblockOnloadEvent();
   1:     }
   1:   }
   1: }
   1: 
   1: class nsUnblockOnloadEvent : public nsRunnable {
   1: public:
   1:   nsUnblockOnloadEvent(nsDocument *doc) : mDoc(doc) {}
   1:   NS_IMETHOD Run() {
   1:     mDoc->DoUnblockOnload();
   1:     return NS_OK;
   1:   }
   1: private:  
   1:   nsRefPtr<nsDocument> mDoc;
   1: };
   1: 
   1: void
   1: nsDocument::PostUnblockOnloadEvent()
   1: {
   1:   nsCOMPtr<nsIRunnable> evt = new nsUnblockOnloadEvent(this);
   1:   nsresult rv = NS_DispatchToCurrentThread(evt);
   1:   if (NS_SUCCEEDED(rv)) {
   1:     // Stabilize block count so we don't post more events while this one is up
   1:     ++mOnloadBlockCount;
   1:   } else {
   1:     NS_WARNING("failed to dispatch nsUnblockOnloadEvent");
   1:   }
   1: }
   1: 
   1: void
   1: nsDocument::DoUnblockOnload()
   1: {
   1:   NS_ASSERTION(mOnloadBlockCount != 0,
   1:                "Shouldn't have a count of zero here, since we stabilized in "
   1:                "PostUnblockOnloadEvent");
   1:   
   1:   --mOnloadBlockCount;
   1:   
   1:   if (mOnloadBlockCount != 0) {
   1:     // We blocked again after the last unblock.  Nothing to do here.  We'll
   1:     // post a new event when we unblock again.
   1:     return;
   1:   }
   1: 
   1:   // If mScriptGlobalObject is null, we shouldn't be messing with the loadgroup
   1:   // -- it's not ours.
   1:   if (mScriptGlobalObject) {
   1:     nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
   1:     if (loadGroup) {
   1:       loadGroup->RemoveRequest(mOnloadBlocker, nsnull, NS_OK);
   1:     }
   1:   }
   1: }
   1: 
   1: /* See if document is a child of this.  If so, return the frame element in this
   1:  * document that holds currentDoc (or an ancestor). */
   1: already_AddRefed<nsIDOMElement>
   1: nsDocument::CheckAncestryAndGetFrame(nsIDocument* aDocument) const
   1: {
   1:   nsIDocument* parentDoc;
   1:   for (parentDoc = aDocument->GetParentDocument();
3233:        parentDoc != static_cast<const nsIDocument* const>(this);
   1:        parentDoc = parentDoc->GetParentDocument()) {
   1:     if (!parentDoc) {
   1:       return nsnull;
   1:     }
   1: 
   1:     aDocument = parentDoc;
   1:   }
   1: 
   1:   // In a child document.  Get the appropriate frame.
   1:   nsPIDOMWindow* currentWindow = aDocument->GetWindow();
   1:   if (!currentWindow) {
   1:     return nsnull;
   1:   }
   1:   nsIDOMElement* frameElement = currentWindow->GetFrameElementInternal();
   1:   if (!frameElement) {
   1:     return nsnull;
   1:   }
   1: 
   1:   // Sanity check result
   1:   nsCOMPtr<nsIDOMDocument> domDocument;
   1:   frameElement->GetOwnerDocument(getter_AddRefs(domDocument));
   1:   if (domDocument != this) {
   1:     NS_ERROR("Child documents should live in windows the parent owns");
   1:     return nsnull;
   1:   }
   1: 
   1:   NS_ADDREF(frameElement);
   1:   return frameElement;
   1: }
   1: 
   1: void
   1: nsDocument::DispatchEventToWindow(nsEvent *aEvent)
   1: {
   1:   nsPIDOMWindow *window = GetWindow();
   1:   if (!window)
   1:     return;
   1: 
3233:   aEvent->target = static_cast<nsIDocument*>(this);
   1:   nsEventDispatcher::Dispatch(window, nsnull, aEvent);
   1: }
   1: 
   1: void
   1: nsDocument::OnPageShow(PRBool aPersisted)
   1: {
   1:   mVisible = PR_TRUE;
   1:   UpdateLinkMap();
   1:   
   1:   if (aPersisted && mRootContent) {
   1:     // Send out notifications that our <link> elements are attached.
   1:     nsRefPtr<nsContentList> links = NS_GetContentList(mRootContent,
   1:                                                       nsGkAtoms::link,
   1:                                                       kNameSpaceID_Unknown);
   1: 
   1:     if (links) {
   1:       PRUint32 linkCount = links->Length(PR_TRUE);
   1:       for (PRUint32 i = 0; i < linkCount; ++i) {
   1:         nsCOMPtr<nsILink> link = do_QueryInterface(links->Item(i, PR_FALSE));
   1:         if (link) {
   1:           link->LinkAdded();
   1:         }
   1:       }
   1:     }
   1:   }
   1: 
   1:   nsPageTransitionEvent event(PR_TRUE, NS_PAGE_SHOW, aPersisted);
   1:   DispatchEventToWindow(&event);
   1: }
   1: 
   1: void
   1: nsDocument::OnPageHide(PRBool aPersisted)
   1: {
   1:   // Send out notifications that our <link> elements are detached,
   1:   // but only if this is not a full unload.
   1:   if (aPersisted && mRootContent) {
   1:     nsRefPtr<nsContentList> links = NS_GetContentList(mRootContent,
   1:                                                       nsGkAtoms::link,
   1:                                                       kNameSpaceID_Unknown);
   1: 
   1:     if (links) {
   1:       PRUint32 linkCount = links->Length(PR_TRUE);
   1:       for (PRUint32 i = 0; i < linkCount; ++i) {
   1:         nsCOMPtr<nsILink> link = do_QueryInterface(links->Item(i, PR_FALSE));
   1:         if (link) {
   1:           link->LinkRemoved();
   1:         }
   1:       }
   1:     }
   1:   }
   1: 
   1:   // Now send out a PageHide event.
   1:   nsPageTransitionEvent event(PR_TRUE, NS_PAGE_HIDE, aPersisted);
   1:   DispatchEventToWindow(&event);
   1: 
   1:   mVisible = PR_FALSE;
   1: }
   1: 
  62: void
  62: nsDocument::WillDispatchMutationEvent(nsINode* aTarget)
  62: {
  62:   NS_ASSERTION(mSubtreeModifiedDepth != 0 ||
  62:                mSubtreeModifiedTargets.Count() == 0,
  62:                "mSubtreeModifiedTargets not cleared after dispatching?");
  62:   ++mSubtreeModifiedDepth;
  62:   if (aTarget) {
3137:     // MayDispatchMutationEvent is often called just before this method,
3137:     // so it has already appended the node to mSubtreeModifiedTargets.
3137:     PRInt32 count = mSubtreeModifiedTargets.Count();
3137:     if (!count || mSubtreeModifiedTargets[count - 1] != aTarget) {
  62:       mSubtreeModifiedTargets.AppendObject(aTarget);
  62:     }
  62:   }
3137: }
  62: 
  62: void
  62: nsDocument::MutationEventDispatched(nsINode* aTarget)
  62: {
  62:   --mSubtreeModifiedDepth;
  62:   if (mSubtreeModifiedDepth == 0) {
  62:     PRInt32 count = mSubtreeModifiedTargets.Count();
  62:     if (!count) {
  62:       return;
  62:     }
  62: 
  62:     nsCOMPtr<nsPIDOMWindow> window;
  62:     window = do_QueryInterface(GetScriptGlobalObject());
  62:     if (window &&
  62:         !window->HasMutationListeners(NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED)) {
  62:       mSubtreeModifiedTargets.Clear();
  62:       return;
  62:     }
  62: 
  62:     nsCOMArray<nsINode> realTargets;
  62:     for (PRInt32 i = 0; i < count; ++i) {
  62:       nsINode* possibleTarget = mSubtreeModifiedTargets[i];
  62:       nsCOMPtr<nsIContent> content = do_QueryInterface(possibleTarget);
  62:       if (content && content->IsAnonymousForEvents()) {
  62:         if (realTargets.IndexOf(possibleTarget) == -1) {
  62:           realTargets.AppendObject(possibleTarget);
  62:         }
  62:         continue;
  62:       }
  62: 
  62:       nsINode* commonAncestor = nsnull;
  62:       PRInt32 realTargetCount = realTargets.Count();
  62:       for (PRInt32 j = 0; j < realTargetCount; ++j) {
  62:         commonAncestor =
  62:           nsContentUtils::GetCommonAncestor(possibleTarget, realTargets[j]);
  62:         if (commonAncestor) {
  62:           realTargets.ReplaceObjectAt(commonAncestor, j);
  62:           break;
  62:         }
  62:       }
  62:       if (!commonAncestor) {
  62:         realTargets.AppendObject(possibleTarget);
  62:       }
  62:     }
  62: 
  62:     mSubtreeModifiedTargets.Clear();
  62: 
  62:     PRInt32 realTargetCount = realTargets.Count();
  62:     for (PRInt32 k = 0; k < realTargetCount; ++k) {
  62:       nsMutationEvent mutation(PR_TRUE, NS_MUTATION_SUBTREEMODIFIED);
  62:       nsEventDispatcher::Dispatch(realTargets[k], nsnull, &mutation);
  62:     }
  62:   }
  62: }
  62: 
   1: static PRUint32 GetURIHash(nsIURI* aURI)
   1: {
   1:   nsCAutoString str;
   1:   aURI->GetSpec(str);
   1:   return HashString(str);
   1: }
   1: 
   1: void
   1: nsDocument::AddStyleRelevantLink(nsIContent* aContent, nsIURI* aURI)
   1: {
   1:   nsUint32ToContentHashEntry* entry = mLinkMap.PutEntry(GetURIHash(aURI));
   1:   if (!entry) // out of memory?
   1:     return;
   1:   entry->PutContent(aContent);
   1: }
   1: 
   1: void
   1: nsDocument::ForgetLink(nsIContent* aContent)
   1: {
   1:   // Important optimization! If the link map is empty (as it will be
   1:   // during teardown because we destroy the map early), then stop
   1:   // now before we waste time constructing a URI object.
   1:   if (mLinkMap.Count() == 0)
   1:     return;
   1: 
   1:   nsCOMPtr<nsIURI> uri;
   1:   if (!aContent->IsLink(getter_AddRefs(uri)))
   1:     return;
   1:   PRUint32 hash = GetURIHash(uri);
   1:   nsUint32ToContentHashEntry* entry = mLinkMap.GetEntry(hash);
   1:   if (!entry)
   1:     return;
   1: 
   1:   entry->RemoveContent(aContent);
   1:   if (entry->IsEmpty()) {
   1:     // Remove the entry and allow the table to resize, in case
   1:     // a lot of links are being removed from the document or modified
   1:     mLinkMap.RemoveEntry(hash);
   1:   }
   1: }
   1: 
   1: class URIVisitNotifier : public nsUint32ToContentHashEntry::Visitor
   1: {
   1: public:
   1:   nsCAutoString matchURISpec;
   1:   nsCOMArray<nsIContent> contentVisited;
   1:   
   1:   virtual void Visit(nsIContent* aContent) {
   1:     // Ensure that the URIs really match before we try to do anything
   1:     nsCOMPtr<nsIURI> uri;
   1:     if (!aContent->IsLink(getter_AddRefs(uri))) {
   1:       NS_ERROR("Should have found a URI for content in the link map");
   1:       return;
   1:     }
   1:     nsCAutoString spec;
   1:     uri->GetSpec(spec);
   1:     // We use nsCString::Equals here instead of nsIURI::Equals because
   1:     // history matching is all based on spec equality
   1:     if (!spec.Equals(matchURISpec))
   1:       return;
   1: 
   1:     // Throw away the cached link state so it gets refetched by the style
   1:     // system      
   1:     nsCOMPtr<nsILink> link = do_QueryInterface(aContent);
   1:     if (link) {
   1:       link->SetLinkState(eLinkState_Unknown);
   1:     }
   1:     contentVisited.AppendObject(aContent);
   1:   }
   1: };
   1: 
   1: void
   1: nsDocument::NotifyURIVisitednessChanged(nsIURI* aURI)
   1: {
   1:   if (!mVisible) {
   1:     mVisitednessChangedURIs.AppendObject(aURI);
   1:     return;
   1:   }
   1: 
   1:   nsUint32ToContentHashEntry* entry = mLinkMap.GetEntry(GetURIHash(aURI));
   1:   if (!entry)
   1:     return;
   1:   
   1:   URIVisitNotifier visitor;
   1:   aURI->GetSpec(visitor.matchURISpec);
   1:   entry->VisitContent(&visitor);
   1:   for (PRUint32 count = visitor.contentVisited.Count(), i = 0; i < count; ++i) {
   1:     ContentStatesChanged(visitor.contentVisited[i],
   1:                          nsnull, NS_EVENT_STATE_VISITED);
   1:   }
   1: }
   1: 
   1: void
   1: nsDocument::DestroyLinkMap()
   1: {
   1:   mVisitednessChangedURIs.Clear();
   1:   mLinkMap.Clear();
   1: }
   1: 
   1: void
   1: nsDocument::UpdateLinkMap()
   1: {
   1:   NS_ASSERTION(mVisible,
   1:                "Should only be updating the link map in visible documents");
   1:   if (!mVisible)
   1:     return;
   1:     
   1:   PRInt32 count = mVisitednessChangedURIs.Count();
   1:   for (PRInt32 i = 0; i < count; ++i) {
   1:     NotifyURIVisitednessChanged(mVisitednessChangedURIs[i]);
   1:   }
   1:   mVisitednessChangedURIs.Clear();
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::GetScriptTypeID(PRUint32 *aScriptType)
   1: {
   1:     NS_ERROR("No default script type here - ask some element");
   1:     return nsIProgrammingLanguage::UNKNOWN;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocument::SetScriptTypeID(PRUint32 aScriptType)
   1: {
   1:     NS_ERROR("Can't change default script type for a document");
   1:     return NS_ERROR_NOT_IMPLEMENTED;
   1: }
