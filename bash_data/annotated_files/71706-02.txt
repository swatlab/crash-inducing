29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS date methods.
    1:  */
    1: 
    1: /*
    1:  * "For example, OS/360 devotes 26 bytes of the permanently
    1:  *  resident date-turnover routine to the proper handling of
    1:  *  December 31 on leap years (when it is Day 366).  That
    1:  *  might have been left to the operator."
    1:  *
    1:  * Frederick Brooks, 'The Second-System Effect'.
    1:  */
    1: 
    1: #include <ctype.h>
    1: #include <locale.h>
    1: #include <math.h>
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsprf.h"
    1: #include "prmjtime.h"
55477: #include "jsutil.h"
    1: #include "jsapi.h"
18863: #include "jsversion.h"
20408: #include "jsbuiltins.h"
    1: #include "jscntxt.h"
    1: #include "jsdate.h"
    1: #include "jsinterp.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsstr.h"
71706: #include "jslibmath.h"
    1: 
40858: #include "jsobjinlines.h"
40858: 
69223: #include "vm/Stack-inl.h"
69223: 
40828: using namespace js;
40828: 
    1: /*
    1:  * The JS 'Date' object is patterned after the Java 'Date' object.
    1:  * Here is an script:
    1:  *
    1:  *    today = new Date();
    1:  *
    1:  *    print(today.toLocaleString());
    1:  *
    1:  *    weekDay = today.getDay();
    1:  *
    1:  *
    1:  * These Java (and ECMA-262) methods are supported:
    1:  *
    1:  *     UTC
    1:  *     getDate (getUTCDate)
    1:  *     getDay (getUTCDay)
    1:  *     getHours (getUTCHours)
    1:  *     getMinutes (getUTCMinutes)
    1:  *     getMonth (getUTCMonth)
    1:  *     getSeconds (getUTCSeconds)
    1:  *     getMilliseconds (getUTCMilliseconds)
    1:  *     getTime
    1:  *     getTimezoneOffset
    1:  *     getYear
    1:  *     getFullYear (getUTCFullYear)
    1:  *     parse
    1:  *     setDate (setUTCDate)
    1:  *     setHours (setUTCHours)
    1:  *     setMinutes (setUTCMinutes)
    1:  *     setMonth (setUTCMonth)
    1:  *     setSeconds (setUTCSeconds)
    1:  *     setMilliseconds (setUTCMilliseconds)
    1:  *     setTime
    1:  *     setYear (setFullYear, setUTCFullYear)
    1:  *     toGMTString (toUTCString)
    1:  *     toLocaleString
    1:  *     toString
    1:  *
    1:  *
    1:  * These Java methods are not supported
    1:  *
    1:  *     setDay
    1:  *     before
    1:  *     after
    1:  *     equals
    1:  *     hashCode
    1:  */
    1: 
    1: /*
    1:  * 11/97 - jsdate.c has been rewritten to conform to the ECMA-262 language
    1:  * definition and reduce dependence on NSPR.  NSPR is used to get the current
    1:  * time in milliseconds, the time zone offset, and the daylight savings time
    1:  * offset for a given time.  NSPR is also used for Date.toLocaleString(), for
    1:  * locale-specific formatting, and to get a string representing the timezone.
    1:  * (Which turns out to be platform-dependent.)
    1:  *
    1:  * To do:
    1:  * (I did some performance tests by timing how long it took to run what
    1:  *  I had of the js ECMA conformance tests.)
    1:  *
    1:  * - look at saving results across multiple calls to supporting
    1:  * functions; the toString functions compute some of the same values
    1:  * multiple times.  Although - I took a quick stab at this, and I lost
    1:  * rather than gained.  (Fractionally.)  Hard to tell what compilers/processors
    1:  * are doing these days.
    1:  *
    1:  * - look at tweaking function return types to return double instead
    1:  * of int; this seems to make things run slightly faster sometimes.
    1:  * (though it could be architecture-dependent.)  It'd be good to see
    1:  * how this does on win32.  (Tried it on irix.)  Types could use a
    1:  * general going-over.
    1:  */
    1: 
    1: /*
    1:  * Supporting functions - ECMA 15.9.1.*
    1:  */
    1: 
    1: #define HoursPerDay     24.0
    1: #define MinutesPerDay   (HoursPerDay * MinutesPerHour)
    1: #define MinutesPerHour  60.0
    1: #define SecondsPerDay   (MinutesPerDay * SecondsPerMinute)
    1: #define SecondsPerHour  (MinutesPerHour * SecondsPerMinute)
    1: #define SecondsPerMinute 60.0
    1: 
    1: #if defined(XP_WIN) || defined(XP_OS2)
    1: /* Work around msvc double optimization bug by making these runtime values; if
    1:  * they're available at compile time, msvc optimizes division by them by
    1:  * computing the reciprocal and multiplying instead of dividing - this loses
    1:  * when the reciprocal isn't representable in a double.
    1:  */
    1: static jsdouble msPerSecond = 1000.0;
    1: static jsdouble msPerDay = SecondsPerDay * 1000.0;
    1: static jsdouble msPerHour = SecondsPerHour * 1000.0;
    1: static jsdouble msPerMinute = SecondsPerMinute * 1000.0;
    1: #else
    1: #define msPerDay        (SecondsPerDay * msPerSecond)
    1: #define msPerHour       (SecondsPerHour * msPerSecond)
    1: #define msPerMinute     (SecondsPerMinute * msPerSecond)
    1: #define msPerSecond     1000.0
    1: #endif
    1: 
    1: #define Day(t)          floor((t) / msPerDay)
    1: 
    1: static jsdouble
    1: TimeWithinDay(jsdouble t)
    1: {
    1:     jsdouble result;
    1:     result = fmod(t, msPerDay);
    1:     if (result < 0)
    1:         result += msPerDay;
    1:     return result;
    1: }
    1: 
51115: static inline bool
51115: IsLeapYear(jsint year)
51115: {
51115:     return year % 4 == 0 && (year % 100 || (year % 400 == 0));
51115: }
51115: 
51115: static inline jsint
51115: DaysInYear(jsint year)
51115: {
51115:     return IsLeapYear(year) ? 366 : 365;
51115: }
51115: 
51115: static inline jsint
51115: DaysInFebruary(jsint year)
51115: {
51115:     return IsLeapYear(year) ? 29 : 28;
51115: }
    1: 
    1: /* math here has to be f.p, because we need
    1:  *  floor((1968 - 1969) / 4) == -1
    1:  */
    1: #define DayFromYear(y)  (365 * ((y)-1970) + floor(((y)-1969)/4.0)            \
    1:                          - floor(((y)-1901)/100.0) + floor(((y)-1601)/400.0))
    1: #define TimeFromYear(y) (DayFromYear(y) * msPerDay)
    1: 
    1: static jsint
    1: YearFromTime(jsdouble t)
    1: {
    1:     jsint y = (jsint) floor(t /(msPerDay*365.2425)) + 1970;
    1:     jsdouble t2 = (jsdouble) TimeFromYear(y);
    1: 
51077:     /*
51077:      * Adjust the year if the approximation was wrong.  Since the year was
51077:      * computed using the average number of ms per year, it will usually
51077:      * be wrong for dates within several hours of a year transition.
51077:      */
    1:     if (t2 > t) {
    1:         y--;
    1:     } else {
    1:         if (t2 + msPerDay * DaysInYear(y) <= t)
    1:             y++;
    1:     }
    1:     return y;
    1: }
    1: 
    1: #define DayWithinYear(t, year) ((intN) (Day(t) - DayFromYear(year)))
    1: 
    1: /*
    1:  * The following array contains the day of year for the first day of
    1:  * each month, where index 0 is January, and day 0 is January 1.
    1:  */
32576: static jsdouble firstDayOfMonth[2][13] = {
32576:     {0.0, 31.0, 59.0, 90.0, 120.0, 151.0, 181.0, 212.0, 243.0, 273.0, 304.0, 334.0, 365.0},
32576:     {0.0, 31.0, 60.0, 91.0, 121.0, 152.0, 182.0, 213.0, 244.0, 274.0, 305.0, 335.0, 366.0}
    1: };
    1: 
32576: #define DayFromMonth(m, leap) firstDayOfMonth[leap][(intN)m]
32576: 
32576: static intN
32576: DaysInMonth(jsint year, jsint month)
32576: {
51115:     JSBool leap = IsLeapYear(year);
33166:     intN result = intN(DayFromMonth(month, leap) - DayFromMonth(month-1, leap));
32576:     return result;
32576: }
    1: 
    1: static intN
    1: MonthFromTime(jsdouble t)
    1: {
    1:     intN d, step;
    1:     jsint year = YearFromTime(t);
    1:     d = DayWithinYear(t, year);
    1: 
    1:     if (d < (step = 31))
    1:         return 0;
51115:     if (d < (step += DaysInFebruary(year)))
    1:         return 1;
    1:     if (d < (step += 31))
    1:         return 2;
    1:     if (d < (step += 30))
    1:         return 3;
    1:     if (d < (step += 31))
    1:         return 4;
    1:     if (d < (step += 30))
    1:         return 5;
    1:     if (d < (step += 31))
    1:         return 6;
    1:     if (d < (step += 31))
    1:         return 7;
    1:     if (d < (step += 30))
    1:         return 8;
    1:     if (d < (step += 31))
    1:         return 9;
    1:     if (d < (step += 30))
    1:         return 10;
    1:     return 11;
    1: }
    1: 
    1: static intN
    1: DateFromTime(jsdouble t)
    1: {
    1:     intN d, step, next;
    1:     jsint year = YearFromTime(t);
    1:     d = DayWithinYear(t, year);
    1: 
    1:     if (d <= (next = 30))
    1:         return d + 1;
    1:     step = next;
51115:     if (d <= (next += DaysInFebruary(year)))
    1:         return d - step;
    1:     step = next;
    1:     if (d <= (next += 31))
    1:         return d - step;
    1:     step = next;
    1:     if (d <= (next += 30))
    1:         return d - step;
    1:     step = next;
    1:     if (d <= (next += 31))
    1:         return d - step;
    1:     step = next;
    1:     if (d <= (next += 30))
    1:         return d - step;
    1:     step = next;
    1:     if (d <= (next += 31))
    1:         return d - step;
    1:     step = next;
    1:     if (d <= (next += 31))
    1:         return d - step;
    1:     step = next;
    1:     if (d <= (next += 30))
    1:         return d - step;
    1:     step = next;
    1:     if (d <= (next += 31))
    1:         return d - step;
    1:     step = next;
    1:     if (d <= (next += 30))
    1:         return d - step;
    1:     step = next;
    1:     return d - step;
    1: }
    1: 
    1: static intN
    1: WeekDay(jsdouble t)
    1: {
    1:     jsint result;
    1:     result = (jsint) Day(t) + 4;
    1:     result = result % 7;
    1:     if (result < 0)
    1:         result += 7;
    1:     return (intN) result;
    1: }
    1: 
    1: #define MakeTime(hour, min, sec, ms) \
    1: ((((hour) * MinutesPerHour + (min)) * SecondsPerMinute + (sec)) * msPerSecond + (ms))
    1: 
    1: static jsdouble
    1: MakeDay(jsdouble year, jsdouble month, jsdouble date)
    1: {
    1:     JSBool leap;
    1:     jsdouble yearday;
    1:     jsdouble monthday;
    1: 
    1:     year += floor(month / 12);
    1: 
    1:     month = fmod(month, 12.0);
    1:     if (month < 0)
    1:         month += 12;
    1: 
51115:     leap = IsLeapYear((jsint) year);
    1: 
    1:     yearday = floor(TimeFromYear(year) / msPerDay);
    1:     monthday = DayFromMonth(month, leap);
    1: 
    1:     return yearday + monthday + date - 1;
    1: }
    1: 
    1: #define MakeDate(day, time) ((day) * msPerDay + (time))
    1: 
    1: /*
    1:  * Years and leap years on which Jan 1 is a Sunday, Monday, etc.
    1:  *
    1:  * yearStartingWith[0][i] is an example non-leap year where
    1:  * Jan 1 appears on Sunday (i == 0), Monday (i == 1), etc.
    1:  *
    1:  * yearStartingWith[1][i] is an example leap year where
    1:  * Jan 1 appears on Sunday (i == 0), Monday (i == 1), etc.
    1:  */
    1: static jsint yearStartingWith[2][7] = {
    1:     {1978, 1973, 1974, 1975, 1981, 1971, 1977},
    1:     {1984, 1996, 1980, 1992, 1976, 1988, 1972}
    1: };
    1: 
    1: /*
    1:  * Find a year for which any given date will fall on the same weekday.
    1:  *
    1:  * This function should be used with caution when used other than
    1:  * for determining DST; it hasn't been proven not to produce an
    1:  * incorrect year for times near year boundaries.
    1:  */
    1: static jsint
    1: EquivalentYearForDST(jsint year)
    1: {
    1:     jsint day;
    1: 
    1:     day = (jsint) DayFromYear(year) + 4;
    1:     day = day % 7;
    1:     if (day < 0)
    1:         day += 7;
    1: 
51115:     return yearStartingWith[IsLeapYear(year)][day];
    1: }
    1: 
29647: /* LocalTZA gets set by js_InitDateClass() */
29647: static jsdouble LocalTZA;
29647: 
    1: static jsdouble
43191: DaylightSavingTA(jsdouble t, JSContext *cx)
    1: {
    1:     /* abort if NaN */
    1:     if (JSDOUBLE_IS_NaN(t))
    1:         return t;
    1: 
    1:     /*
    1:      * If earlier than 1970 or after 2038, potentially beyond the ken of
    1:      * many OSes, map it to an equivalent year before asking.
    1:      */
    1:     if (t < 0.0 || t > 2145916800000.0) {
43192:         jsint year = EquivalentYearForDST(YearFromTime(t));
43192:         jsdouble day = MakeDay(year, MonthFromTime(t), DateFromTime(t));
    1:         t = MakeDate(day, TimeWithinDay(t));
    1:     }
    1: 
43192:     int64 timeMilliseconds = static_cast<int64>(t);
43192:     int64 offsetMilliseconds = cx->dstOffsetCache.getDSTOffsetMilliseconds(timeMilliseconds, cx);
43192:     return static_cast<jsdouble>(offsetMilliseconds);
    1: }
    1: 
29647: static jsdouble
43191: AdjustTime(jsdouble date, JSContext *cx)
29647: {
43191:     jsdouble t = DaylightSavingTA(date, cx) + LocalTZA;
29647:     t = (LocalTZA >= 0) ? fmod(t, msPerDay) : -fmod(msPerDay - t, msPerDay);
29647:     return t;
29647: }
29647: 
43191: static jsdouble
43191: LocalTime(jsdouble t, JSContext *cx)
43191: {
43191:     return t + AdjustTime(t, cx);
43191: }
29647: 
29647: static jsdouble
43191: UTC(jsdouble t, JSContext *cx)
29647: {
43191:     return t - AdjustTime(t - LocalTZA, cx);
29647: }
29647: 
    1: static intN
    1: HourFromTime(jsdouble t)
    1: {
    1:     intN result = (intN) fmod(floor(t/msPerHour), HoursPerDay);
    1:     if (result < 0)
    1:         result += (intN)HoursPerDay;
    1:     return result;
    1: }
    1: 
    1: static intN
    1: MinFromTime(jsdouble t)
    1: {
    1:     intN result = (intN) fmod(floor(t / msPerMinute), MinutesPerHour);
    1:     if (result < 0)
    1:         result += (intN)MinutesPerHour;
    1:     return result;
    1: }
    1: 
    1: static intN
    1: SecFromTime(jsdouble t)
    1: {
    1:     intN result = (intN) fmod(floor(t / msPerSecond), SecondsPerMinute);
    1:     if (result < 0)
    1:         result += (intN)SecondsPerMinute;
    1:     return result;
    1: }
    1: 
    1: static intN
    1: msFromTime(jsdouble t)
    1: {
    1:     intN result = (intN) fmod(t, msPerSecond);
    1:     if (result < 0)
    1:         result += (intN)msPerSecond;
    1:     return result;
    1: }
    1: 
    1: /**
    1:  * end of ECMA 'support' functions
    1:  */
16519: 
    1: /*
    1:  * Other Support routines and definitions
    1:  */
    1: 
48470: Class js_DateClass = {
    1:     js_Date_str,
51077:     JSCLASS_HAS_RESERVED_SLOTS(JSObject::DATE_CLASS_RESERVED_SLOTS) |
53557:     JSCLASS_HAS_CACHED_PROTO(JSProto_Date),
48622:     PropertyStub,         /* addProperty */
48622:     PropertyStub,         /* delProperty */
48622:     PropertyStub,         /* getProperty */
62395:     StrictPropertyStub,   /* setProperty */
48622:     EnumerateStub,
48622:     ResolveStub,
48622:     ConvertStub
    1: };
    1: 
    1: /* for use by date_parse */
    1: 
    1: static const char* wtb[] = {
    1:     "am", "pm",
    1:     "monday", "tuesday", "wednesday", "thursday", "friday",
    1:     "saturday", "sunday",
    1:     "january", "february", "march", "april", "may", "june",
    1:     "july", "august", "september", "october", "november", "december",
    1:     "gmt", "ut", "utc",
    1:     "est", "edt",
    1:     "cst", "cdt",
    1:     "mst", "mdt",
    1:     "pst", "pdt"
    1:     /* time zone table needs to be expanded */
    1: };
    1: 
    1: static int ttb[] = {
    1:     -1, -2, 0, 0, 0, 0, 0, 0, 0,       /* AM/PM */
    1:     2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
    1:     10000 + 0, 10000 + 0, 10000 + 0,   /* GMT/UT/UTC */
    1:     10000 + 5 * 60, 10000 + 4 * 60,    /* EST/EDT */
    1:     10000 + 6 * 60, 10000 + 5 * 60,    /* CST/CDT */
    1:     10000 + 7 * 60, 10000 + 6 * 60,    /* MST/MDT */
    1:     10000 + 8 * 60, 10000 + 7 * 60     /* PST/PDT */
    1: };
    1: 
    1: /* helper for date_parse */
    1: static JSBool
    1: date_regionMatches(const char* s1, int s1off, const jschar* s2, int s2off,
    1:                    int count, int ignoreCase)
    1: {
    1:     JSBool result = JS_FALSE;
    1:     /* return true if matches, otherwise, false */
    1: 
    1:     while (count > 0 && s1[s1off] && s2[s2off]) {
    1:         if (ignoreCase) {
    1:             if (JS_TOLOWER((jschar)s1[s1off]) != JS_TOLOWER(s2[s2off])) {
    1:                 break;
    1:             }
    1:         } else {
    1:             if ((jschar)s1[s1off] != s2[s2off]) {
    1:                 break;
    1:             }
    1:         }
    1:         s1off++;
    1:         s2off++;
    1:         count--;
    1:     }
    1: 
    1:     if (count == 0) {
    1:         result = JS_TRUE;
    1:     }
    1: 
    1:     return result;
    1: }
    1: 
    1: /* find UTC time from given date... no 1900 correction! */
    1: static jsdouble
    1: date_msecFromDate(jsdouble year, jsdouble mon, jsdouble mday, jsdouble hour,
    1:                   jsdouble min, jsdouble sec, jsdouble msec)
    1: {
    1:     jsdouble day;
    1:     jsdouble msec_time;
    1:     jsdouble result;
    1: 
    1:     day = MakeDay(year, mon, mday);
    1:     msec_time = MakeTime(hour, min, sec, msec);
    1:     result = MakeDate(day, msec_time);
    1:     return result;
    1: }
 4576: 
 4576: /* compute the time in msec (unclipped) from the given args */
    1: #define MAXARGS        7
 4127: 
    1: static JSBool
48470: date_msecFromArgs(JSContext *cx, uintN argc, Value *argv, jsdouble *rval)
    1: {
 4127:     uintN loop;
    1:     jsdouble array[MAXARGS];
 4576:     jsdouble msec_time;
    1: 
    1:     for (loop = 0; loop < MAXARGS; loop++) {
    1:         if (loop < argc) {
40828:             jsdouble d;
40828:             if (!ValueToNumber(cx, argv[loop], &d))
    1:                 return JS_FALSE;
 4576:             /* return NaN if any arg is not finite */
    1:             if (!JSDOUBLE_IS_FINITE(d)) {
34372:                 *rval = js_NaN;
 4576:                 return JS_TRUE;
    1:             }
 4576:             array[loop] = js_DoubleToInteger(d);
 4576:         } else {
 4576:             if (loop == 2) {
 4576:                 array[loop] = 1; /* Default the date argument to 1. */
    1:             } else {
    1:                 array[loop] = 0;
    1:             }
    1:         }
 4576:     }
    1: 
    1:     /* adjust 2-digit years into the 20th century */
    1:     if (array[0] >= 0 && array[0] <= 99)
    1:         array[0] += 1900;
    1: 
 4576:     msec_time = date_msecFromDate(array[0], array[1], array[2],
 4576:                                   array[3], array[4], array[5], array[6]);
 4576:     *rval = msec_time;
 4576:     return JS_TRUE;
 4576: }
    1: 
 4576: /*
 4576:  * See ECMA 15.9.4.[3-10];
 4576:  */
 4576: static JSBool
48470: date_UTC(JSContext *cx, uintN argc, Value *vp)
 4576: {
 4576:     jsdouble msec_time;
    1: 
 4581:     if (!date_msecFromArgs(cx, argc, vp + 2, &msec_time))
 4576:         return JS_FALSE;
 4576: 
 4576:     msec_time = TIMECLIP(msec_time);
 4576: 
48470:     vp->setNumber(msec_time);
48470:     return JS_TRUE;
    1: }
    1: 
32576: /*
32576:  * Read and convert decimal digits from s[*i] into *result
32576:  * while *i < limit.
32576:  *
32576:  * Succeed if any digits are converted. Advance *i only
32576:  * as digits are consumed.
32576:  */
32576: static JSBool
32576: digits(size_t *result, const jschar *s, size_t *i, size_t limit)
32576: {
32576:     size_t init = *i;
32576:     *result = 0;
32576:     while (*i < limit &&
32576:            ('0' <= s[*i] && s[*i] <= '9')) {
32576:         *result *= 10;
32576:         *result += (s[*i] - '0');
32576:         ++(*i);
32576:     }
32576:     return (*i != init);
32576: }
32576: 
32576: /*
32576:  * Read and convert decimal digits to the right of a decimal point,
32576:  * representing a fractional integer, from s[*i] into *result
32576:  * while *i < limit.
32576:  *
32576:  * Succeed if any digits are converted. Advance *i only
32576:  * as digits are consumed.
32576:  */
32576: static JSBool
32576: fractional(jsdouble *result, const jschar *s, size_t *i, size_t limit)
32576: {
32576:     jsdouble factor = 0.1;
32576:     size_t init = *i;
32576:     *result = 0.0;
32576:     while (*i < limit &&
32576:            ('0' <= s[*i] && s[*i] <= '9')) {
32576:         *result += (s[*i] - '0') * factor;
32576:         factor *= 0.1;
32576:         ++(*i);
32576:     }
32576:     return (*i != init);
32576: }
32576: 
32576: /*
32576:  * Read and convert exactly n decimal digits from s[*i]
32576:  * to s[min(*i+n,limit)] into *result.
32576:  *
32576:  * Succeed if exactly n digits are converted. Advance *i only
32576:  * on success.
32576:  */
32576: static JSBool
32576: ndigits(size_t n, size_t *result, const jschar *s, size_t* i, size_t limit)
32576: {
32576:     size_t init = *i;
32576: 
32576:     if (digits(result, s, i, JS_MIN(limit, init+n)))
32576:         return ((*i - init) == n);
32576: 
32576:     *i = init;
32576:     return JS_FALSE;
32576: }
32576: 
32576: /*
32576:  * Parse a string in one of the date-time formats given by the W3C
32576:  * "NOTE-datetime" specification. These formats make up a restricted
32576:  * profile of the ISO 8601 format. Quoted here:
32576:  *
32576:  *   The formats are as follows. Exactly the components shown here
32576:  *   must be present, with exactly this punctuation. Note that the "T"
32576:  *   appears literally in the string, to indicate the beginning of the
32576:  *   time element, as specified in ISO 8601.
32576:  *
32576:  *   Any combination of the date formats with the time formats is
32576:  *   allowed, and also either the date or the time can be missing.
32576:  *
32576:  *   The specification is silent on the meaning when fields are
32576:  *   ommitted so the interpretations are a guess, but hopefully a
32576:  *   reasonable one. We default the month to January, the day to the
32576:  *   1st, and hours minutes and seconds all to 0. If the date is
32576:  *   missing entirely then we assume 1970-01-01 so that the time can
32576:  *   be aded to a date later. If the time is missing then we assume
32576:  *   00:00 UTC.  If the time is present but the time zone field is
32576:  *   missing then we use local time.
32576:  *
32576:  * Date part:
32576:  *
32576:  *  Year:
32576:  *     YYYY (eg 1997)
32576:  *
32576:  *  Year and month:
32576:  *     YYYY-MM (eg 1997-07)
32576:  *
32576:  *  Complete date:
32576:  *     YYYY-MM-DD (eg 1997-07-16)
32576:  *
32576:  * Time part:
32576:  *
32576:  *  Hours and minutes:
32576:  *     Thh:mmTZD (eg T19:20+01:00)
32576:  *
32576:  *  Hours, minutes and seconds:
32576:  *     Thh:mm:ssTZD (eg T19:20:30+01:00)
32576:  *
32576:  *  Hours, minutes, seconds and a decimal fraction of a second:
32576:  *     Thh:mm:ss.sTZD (eg T19:20:30.45+01:00)
32576:  *
32576:  * where:
32576:  *
32576:  *   YYYY = four-digit year or six digit year as +YYYYYY or -YYYYYY
32576:  *   MM   = two-digit month (01=January, etc.)
32576:  *   DD   = two-digit day of month (01 through 31)
32576:  *   hh   = two digits of hour (00 through 23) (am/pm NOT allowed)
32576:  *   mm   = two digits of minute (00 through 59)
32576:  *   ss   = two digits of second (00 through 59)
32576:  *   s    = one or more digits representing a decimal fraction of a second
32576:  *   TZD  = time zone designator (Z or +hh:mm or -hh:mm or missing for local)
32576:  */
32576: 
32576: static JSBool
59890: date_parseISOString(JSLinearString *str, jsdouble *result, JSContext *cx)
32576: {
32576:     jsdouble msec;
32576: 
32576:     const jschar *s;
32576:     size_t limit;
32576:     size_t i = 0;
32576:     int tzMul = 1;
32576:     int dateMul = 1;
32576:     size_t year = 1970;
32576:     size_t month = 1;
32576:     size_t day = 1;
32576:     size_t hour = 0;
32576:     size_t min = 0;
32576:     size_t sec = 0;
32576:     jsdouble frac = 0;
32576:     bool isLocalTime = JS_FALSE;
32576:     size_t tzHour = 0;
32576:     size_t tzMin = 0;
32576: 
32576: #define PEEK(ch) (i < limit && s[i] == ch)
32576: 
32576: #define NEED(ch)                                                     \
32576:     JS_BEGIN_MACRO                                                   \
32576:         if (i >= limit || s[i] != ch) { goto syntax; } else { ++i; } \
32576:     JS_END_MACRO
32576: 
32576: #define DONE_DATE_UNLESS(ch)                                            \
32576:     JS_BEGIN_MACRO                                                      \
32576:         if (i >= limit || s[i] != ch) { goto done_date; } else { ++i; } \
32576:     JS_END_MACRO
32576: 
32576: #define DONE_UNLESS(ch)                                            \
32576:     JS_BEGIN_MACRO                                                 \
32576:         if (i >= limit || s[i] != ch) { goto done; } else { ++i; } \
32576:     JS_END_MACRO
32576: 
32576: #define NEED_NDIGITS(n, field)                                      \
32576:     JS_BEGIN_MACRO                                                  \
32576:         if (!ndigits(n, &field, s, &i, limit)) { goto syntax; }     \
32576:     JS_END_MACRO
32576: 
59890:     s = str->chars();
59890:     limit = str->length();
32576: 
32576:     if (PEEK('+') || PEEK('-')) {
32576:         if (PEEK('-'))
32576:             dateMul = -1;
32576:         ++i;
32576:         NEED_NDIGITS(6, year);
32576:     } else if (!PEEK('T')) {
32576:         NEED_NDIGITS(4, year);
32576:     }
32576:     DONE_DATE_UNLESS('-');
32576:     NEED_NDIGITS(2, month);
32576:     DONE_DATE_UNLESS('-');
32576:     NEED_NDIGITS(2, day);
32576: 
32576:  done_date:
32576:     DONE_UNLESS('T');
32576:     NEED_NDIGITS(2, hour);
32576:     NEED(':');
32576:     NEED_NDIGITS(2, min);
32576: 
32576:     if (PEEK(':')) {
32576:         ++i;
32576:         NEED_NDIGITS(2, sec);
32576:         if (PEEK('.')) {
32576:             ++i;
32576:             if (!fractional(&frac, s, &i, limit))
32576:                 goto syntax;
32576:         }
32576:     }
32576: 
32576:     if (PEEK('Z')) {
32576:         ++i;
32576:     } else if (PEEK('+') || PEEK('-')) {
32576:         if (PEEK('-'))
32576:             tzMul = -1;
32576:         ++i;
32576:         NEED_NDIGITS(2, tzHour);
32576:         NEED(':');
32576:         NEED_NDIGITS(2, tzMin);
32576:     } else {
32576:         isLocalTime = JS_TRUE;
32576:     }
32576: 
32576:  done:
32576:     if (year > 275943 // ceil(1e8/365) + 1970
32576:         || (month == 0 || month > 12)
32684:         || (day == 0 || day > size_t(DaysInMonth(year,month)))
32576:         || hour > 24
32576:         || ((hour == 24) && (min > 0 || sec > 0))
32576:         || min > 59
32576:         || sec > 59
32576:         || tzHour > 23
32576:         || tzMin > 59)
32576:         goto syntax;
32576: 
32576:     if (i != limit)
32576:         goto syntax;
32576: 
32576:     month -= 1; /* convert month to 0-based */
32576: 
32576:     msec = date_msecFromDate(dateMul * (jsdouble)year, month, day,
32576:                              hour, min, sec,
32576:                              frac * 1000.0);;
32576: 
32576:     if (isLocalTime) {
43191:         msec = UTC(msec, cx);
32576:     } else {
32576:         msec -= ((tzMul) * ((tzHour * msPerHour)
32576:                             + (tzMin * msPerMinute)));
32576:     }
32576: 
32576:     if (msec < -8.64e15 || msec > 8.64e15)
32576:         goto syntax;
32576: 
32576:     *result = msec;
32576: 
32576:     return JS_TRUE;
32576: 
32576:  syntax:
32576:     /* syntax error */
32576:     *result = 0;
32576:     return JS_FALSE;
32576: 
32576: #undef PEEK
32576: #undef NEED
32576: #undef DONE_UNLESS
32576: #undef NEED_NDIGITS
32576: }
32576: 
    1: static JSBool
59890: date_parseString(JSLinearString *str, jsdouble *result, JSContext *cx)
    1: {
    1:     jsdouble msec;
    1: 
 4718:     const jschar *s;
 4718:     size_t limit;
    1:     size_t i = 0;
    1:     int year = -1;
    1:     int mon = -1;
    1:     int mday = -1;
    1:     int hour = -1;
    1:     int min = -1;
    1:     int sec = -1;
    1:     int c = -1;
    1:     int n = -1;
 4127:     int tzoffset = -1;
    1:     int prevc = 0;
    1:     JSBool seenplusminus = JS_FALSE;
    1:     int temp;
    1:     JSBool seenmonthname = JS_FALSE;
    1: 
43191:     if (date_parseISOString(str, result, cx))
32576:         return JS_TRUE;
32576: 
59890:     s = str->chars();
59890:     limit = str->length();
    1:     if (limit == 0)
    1:         goto syntax;
    1:     while (i < limit) {
    1:         c = s[i];
    1:         i++;
    1:         if (c <= ' ' || c == ',' || c == '-') {
    1:             if (c == '-' && '0' <= s[i] && s[i] <= '9') {
    1:               prevc = c;
    1:             }
    1:             continue;
    1:         }
    1:         if (c == '(') { /* comments) */
    1:             int depth = 1;
    1:             while (i < limit) {
    1:                 c = s[i];
    1:                 i++;
    1:                 if (c == '(') depth++;
    1:                 else if (c == ')')
    1:                     if (--depth <= 0)
    1:                         break;
    1:             }
    1:             continue;
    1:         }
    1:         if ('0' <= c && c <= '9') {
    1:             n = c - '0';
    1:             while (i < limit && '0' <= (c = s[i]) && c <= '9') {
    1:                 n = n * 10 + c - '0';
    1:                 i++;
    1:             }
    1: 
    1:             /* allow TZA before the year, so
    1:              * 'Wed Nov 05 21:49:11 GMT-0800 1997'
    1:              * works */
    1: 
    1:             /* uses of seenplusminus allow : in TZA, so Java
    1:              * no-timezone style of GMT+4:30 works
    1:              */
    1: 
    1:             if ((prevc == '+' || prevc == '-')/*  && year>=0 */) {
    1:                 /* make ':' case below change tzoffset */
    1:                 seenplusminus = JS_TRUE;
    1: 
    1:                 /* offset */
    1:                 if (n < 24)
    1:                     n = n * 60; /* EG. "GMT-3" */
    1:                 else
    1:                     n = n % 100 + n / 100 * 60; /* eg "GMT-0430" */
    1:                 if (prevc == '+')       /* plus means east of GMT */
    1:                     n = -n;
    1:                 if (tzoffset != 0 && tzoffset != -1)
    1:                     goto syntax;
    1:                 tzoffset = n;
    1:             } else if (prevc == '/' && mon >= 0 && mday >= 0 && year < 0) {
    1:                 if (c <= ' ' || c == ',' || c == '/' || i >= limit)
    1:                     year = n;
    1:                 else
    1:                     goto syntax;
    1:             } else if (c == ':') {
    1:                 if (hour < 0)
    1:                     hour = /*byte*/ n;
    1:                 else if (min < 0)
    1:                     min = /*byte*/ n;
    1:                 else
    1:                     goto syntax;
    1:             } else if (c == '/') {
    1:                 /* until it is determined that mon is the actual
    1:                    month, keep it as 1-based rather than 0-based */
    1:                 if (mon < 0)
    1:                     mon = /*byte*/ n;
    1:                 else if (mday < 0)
    1:                     mday = /*byte*/ n;
    1:                 else
    1:                     goto syntax;
    1:             } else if (i < limit && c != ',' && c > ' ' && c != '-' && c != '(') {
    1:                 goto syntax;
    1:             } else if (seenplusminus && n < 60) {  /* handle GMT-3:30 */
    1:                 if (tzoffset < 0)
    1:                     tzoffset -= n;
    1:                 else
    1:                     tzoffset += n;
    1:             } else if (hour >= 0 && min < 0) {
    1:                 min = /*byte*/ n;
    1:             } else if (prevc == ':' && min >= 0 && sec < 0) {
    1:                 sec = /*byte*/ n;
    1:             } else if (mon < 0) {
    1:                 mon = /*byte*/n;
    1:             } else if (mon >= 0 && mday < 0) {
    1:                 mday = /*byte*/ n;
    1:             } else if (mon >= 0 && mday >= 0 && year < 0) {
    1:                 year = n;
    1:             } else {
    1:                 goto syntax;
    1:             }
    1:             prevc = 0;
    1:         } else if (c == '/' || c == ':' || c == '+' || c == '-') {
    1:             prevc = c;
    1:         } else {
    1:             size_t st = i - 1;
    1:             int k;
    1:             while (i < limit) {
    1:                 c = s[i];
    1:                 if (!(('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z')))
    1:                     break;
    1:                 i++;
    1:             }
    1:             if (i <= st + 1)
    1:                 goto syntax;
 8336:             for (k = JS_ARRAY_LENGTH(wtb); --k >= 0;)
    1:                 if (date_regionMatches(wtb[k], 0, s, st, i-st, 1)) {
    1:                     int action = ttb[k];
    1:                     if (action != 0) {
    1:                         if (action < 0) {
    1:                             /*
    1:                              * AM/PM. Count 12:30 AM as 00:30, 12:30 PM as
    1:                              * 12:30, instead of blindly adding 12 if PM.
    1:                              */
    1:                             JS_ASSERT(action == -1 || action == -2);
    1:                             if (hour > 12 || hour < 0) {
    1:                                 goto syntax;
    1:                             } else {
    1:                                 if (action == -1 && hour == 12) { /* am */
    1:                                     hour = 0;
    1:                                 } else if (action == -2 && hour != 12) { /* pm */
    1:                                     hour += 12;
    1:                                 }
    1:                             }
    1:                         } else if (action <= 13) { /* month! */
    1:                             /* Adjust mon to be 1-based until the final values
    1:                                for mon, mday and year are adjusted below */
    1:                             if (seenmonthname) {
    1:                                 goto syntax;
    1:                             }
    1:                             seenmonthname = JS_TRUE;
    1:                             temp = /*byte*/ (action - 2) + 1;
    1: 
    1:                             if (mon < 0) {
    1:                                 mon = temp;
    1:                             } else if (mday < 0) {
    1:                                 mday = mon;
    1:                                 mon = temp;
    1:                             } else if (year < 0) {
    1:                                 year = mon;
    1:                                 mon = temp;
    1:                             } else {
    1:                                 goto syntax;
    1:                             }
    1:                         } else {
    1:                             tzoffset = action - 10000;
    1:                         }
    1:                     }
    1:                     break;
    1:                 }
    1:             if (k < 0)
    1:                 goto syntax;
    1:             prevc = 0;
    1:         }
    1:     }
    1:     if (year < 0 || mon < 0 || mday < 0)
    1:         goto syntax;
    1:     /*
    1:       Case 1. The input string contains an English month name.
    1:               The form of the string can be month f l, or f month l, or
    1:               f l month which each evaluate to the same date.
    1:               If f and l are both greater than or equal to 70, or
    1:               both less than 70, the date is invalid.
    1:               The year is taken to be the greater of the values f, l.
    1:               If the year is greater than or equal to 70 and less than 100,
    1:               it is considered to be the number of years after 1900.
    1:       Case 2. The input string is of the form "f/m/l" where f, m and l are
    1:               integers, e.g. 7/16/45.
    1:               Adjust the mon, mday and year values to achieve 100% MSIE
    1:               compatibility.
    1:               a. If 0 <= f < 70, f/m/l is interpreted as month/day/year.
    1:                  i.  If year < 100, it is the number of years after 1900
    1:                  ii. If year >= 100, it is the number of years after 0.
    1:               b. If 70 <= f < 100
    1:                  i.  If m < 70, f/m/l is interpreted as
    1:                      year/month/day where year is the number of years after
    1:                      1900.
    1:                  ii. If m >= 70, the date is invalid.
    1:               c. If f >= 100
    1:                  i.  If m < 70, f/m/l is interpreted as
    1:                      year/month/day where year is the number of years after 0.
    1:                  ii. If m >= 70, the date is invalid.
    1:     */
    1:     if (seenmonthname) {
    1:         if ((mday >= 70 && year >= 70) || (mday < 70 && year < 70)) {
    1:             goto syntax;
    1:         }
    1:         if (mday > year) {
    1:             temp = year;
    1:             year = mday;
    1:             mday = temp;
    1:         }
    1:         if (year >= 70 && year < 100) {
    1:             year += 1900;
    1:         }
    1:     } else if (mon < 70) { /* (a) month/day/year */
    1:         if (year < 100) {
    1:             year += 1900;
    1:         }
    1:     } else if (mon < 100) { /* (b) year/month/day */
    1:         if (mday < 70) {
    1:             temp = year;
    1:             year = mon + 1900;
    1:             mon = mday;
    1:             mday = temp;
    1:         } else {
    1:             goto syntax;
    1:         }
    1:     } else { /* (c) year/month/day */
    1:         if (mday < 70) {
    1:             temp = year;
    1:             year = mon;
    1:             mon = mday;
    1:             mday = temp;
    1:         } else {
    1:             goto syntax;
    1:         }
    1:     }
    1:     mon -= 1; /* convert month to 0-based */
    1:     if (sec < 0)
    1:         sec = 0;
    1:     if (min < 0)
    1:         min = 0;
    1:     if (hour < 0)
    1:         hour = 0;
32576: 
32576:     msec = date_msecFromDate(year, mon, mday, hour, min, sec, 0);
32576: 
    1:     if (tzoffset == -1) { /* no time zone specified, have to use local */
43191:         msec = UTC(msec, cx);
32576:     } else {
32576:         msec += tzoffset * msPerMinute;
    1:     }
    1: 
    1:     *result = msec;
    1:     return JS_TRUE;
    1: 
    1: syntax:
    1:     /* syntax error */
    1:     *result = 0;
    1:     return JS_FALSE;
    1: }
    1: 
    1: static JSBool
48470: date_parse(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str;
    1:     jsdouble result;
    1: 
16519:     if (argc == 0) {
48470:         vp->setDouble(js_NaN);
34372:         return true;
16519:     }
 4127:     str = js_ValueToString(cx, vp[2]);
    1:     if (!str)
    1:         return JS_FALSE;
48470:     vp[2].setString(str);
59890:     JSLinearString *linearStr = str->ensureLinear(cx);
59890:     if (!linearStr)
59890:         return false;
59890: 
59890:     if (!date_parseString(linearStr, &result, cx)) {
48470:         vp->setDouble(js_NaN);
34372:         return true;
    1:     }
    1: 
    1:     result = TIMECLIP(result);
48470:     vp->setNumber(result);
48470:     return true;
    1: }
    1: 
25628: static inline jsdouble
25628: NowAsMillis()
25628: {
25628:     return (jsdouble) (PRMJ_Now() / PRMJ_USEC_PER_MSEC);
25628: }
25628: 
20408: static JSBool
48470: date_now(JSContext *cx, uintN argc, Value *vp)
    1: {
68410:     vp->setDouble(NowAsMillis());
48470:     return JS_TRUE;
    1: }
    1: 
20408: #ifdef JS_TRACER
20915: static jsdouble FASTCALL
20915: date_now_tn(JSContext*)
20408: {
68410:     return NowAsMillis();
20408: }
20408: #endif
20408: 
    1: /*
    1:  * Get UTC time from the date object. Returns false if the object is not
    1:  * Date type.
    1:  */
    1: static JSBool
48470: GetUTCTime(JSContext *cx, JSObject *obj, Value *vp, jsdouble *dp)
    1: {
67943:     if (!obj->isDate()) {
67943:         if (vp)
67943:             ReportIncompatibleMethod(cx, vp, &js_DateClass);
67943:         return false;
67943:     }
48470:     *dp = obj->getDateUTCTime().toNumber();
67943:     return true;
    1: }
    1: 
    1: /*
34346:  * Set UTC time to a given time and invalidate cached local time.
    1:  */
    1: static JSBool
48470: SetUTCTime(JSContext *cx, JSObject *obj, jsdouble t, Value *vp = NULL)
    1: {
51077:     JS_ASSERT(obj->isDate());
51077: 
51077:     size_t slotCap = JS_MIN(obj->numSlots(), JSObject::DATE_CLASS_RESERVED_SLOTS);
51077:     for (size_t ind = JSObject::JSSLOT_DATE_COMPONENTS_START; ind < slotCap; ind++)
51077:         obj->getSlotRef(ind).setUndefined();
51077: 
48470:     obj->setDateUTCTime(DoubleValue(t));
34346:     if (vp)
48470:         vp->setDouble(t);
34346:     return true;
    1: }
    1: 
51077: static void
51077: SetDateToNaN(JSContext *cx, JSObject *obj, Value *vp = NULL)
51077: {
51077:     jsdouble NaN = cx->runtime->NaNValue.getDoubleRef();
51077:     SetUTCTime(cx, obj, NaN, vp);
51077: }
51077: 
    1: /*
51077:  * Cache the local time, year, month, and so forth of the object.
51077:  * If UTC time is not finite (e.g., NaN), the local time
51077:  * slots will be set to the UTC time without conversion.
    1:  */
51077: static bool
51077: FillLocalTimes(JSContext *cx, JSObject *obj)
51077: {
51077:     JS_ASSERT(obj->isDate());
51077: 
51077:     jsdouble utcTime = obj->getDateUTCTime().toNumber();
51077: 
51077:     /* Make sure there are slots to store the cached information. */
51077:     if (obj->numSlots() < JSObject::DATE_CLASS_RESERVED_SLOTS) {
51077:         if (!obj->growSlots(cx, JSObject::DATE_CLASS_RESERVED_SLOTS))
51077:             return false;
51077:     }
51077: 
51077:     if (!JSDOUBLE_IS_FINITE(utcTime)) {
51077:         for (size_t ind = JSObject::JSSLOT_DATE_COMPONENTS_START;
51077:              ind < JSObject::DATE_CLASS_RESERVED_SLOTS;
51077:              ind++) {
51077:             obj->setSlot(ind, DoubleValue(utcTime));
51077:         }
51077:         return true;
51077:     }
51077: 
51077:     jsdouble localTime = LocalTime(utcTime, cx);
51077: 
51077:     obj->setSlot(JSObject::JSSLOT_DATE_LOCAL_TIME, DoubleValue(localTime));
51077: 
51077:     jsint year = (jsint) floor(localTime /(msPerDay*365.2425)) + 1970;
51077:     jsdouble yearStartTime = (jsdouble) TimeFromYear(year);
51077: 
51077:     /* Adjust the year in case the approximation was wrong, as in YearFromTime. */
51077:     jsint yearDays;
51077:     if (yearStartTime > localTime) {
51077:         year--;
51077:         yearStartTime -= (msPerDay * DaysInYear(year));
51077:         yearDays = DaysInYear(year);
51077:     } else {
51077:         yearDays = DaysInYear(year);
51077:         jsdouble nextStart = yearStartTime + (msPerDay * yearDays);
51077:         if (nextStart <= localTime) {
51077:             year++;
51077:             yearStartTime = nextStart;
51077:             yearDays = DaysInYear(year);
51077:         }
51077:     }
51077: 
51077:     obj->setSlot(JSObject::JSSLOT_DATE_LOCAL_YEAR, Int32Value(year));
51077: 
51077:     uint64 yearTime = uint64(localTime - yearStartTime);
51077:     jsint yearSeconds = uint32(yearTime / 1000);
51077: 
51077:     jsint day = yearSeconds / jsint(SecondsPerDay);
51077: 
51077:     jsint step = -1, next = 30;
51077:     jsint month;
51077: 
51077:     do {
51077:         if (day <= next) {
51077:             month = 0;
51077:             break;
51077:         }
51077:         step = next;
51077:         next += ((yearDays == 366) ? 29 : 28);
51077:         if (day <= next) {
51077:             month = 1;
51077:             break;
51077:         }
51077:         step = next;
51077:         if (day <= (next += 31)) {
51077:             month = 2;
51077:             break;
51077:         }
51077:         step = next;
51077:         if (day <= (next += 30)) {
51077:             month = 3;
51077:             break;
51077:         }
51077:         step = next;
51077:         if (day <= (next += 31)) {
51077:             month = 4;
51077:             break;
51077:         }
51077:         step = next;
51077:         if (day <= (next += 30)) {
51077:             month = 5;
51077:             break;
51077:         }
51077:         step = next;
51077:         if (day <= (next += 31)) {
51077:             month = 6;
51077:             break;
51077:         }
51077:         step = next;
51077:         if (day <= (next += 31)) {
51077:             month = 7;
51077:             break;
51077:         }
51077:         step = next;
51077:         if (day <= (next += 30)) {
51077:             month = 8;
51077:             break;
51077:         }
51077:         step = next;
51077:         if (day <= (next += 31)) {
51077:             month = 9;
51077:             break;
51077:         }
51077:         step = next;
51077:         if (day <= (next += 30)) {
51077:             month = 10;
51077:             break;
51077:         }
51077:         step = next;
51077:         month = 11;
51077:     } while (0);
51077: 
51077:     obj->setSlot(JSObject::JSSLOT_DATE_LOCAL_MONTH, Int32Value(month));
51077:     obj->setSlot(JSObject::JSSLOT_DATE_LOCAL_DATE, Int32Value(day - step));
51077: 
51077:     jsint weekday = WeekDay(localTime);
51077: 
51077:     obj->setSlot(JSObject::JSSLOT_DATE_LOCAL_DAY, Int32Value(weekday));
51077: 
51077:     jsint seconds = yearSeconds % 60;
51077: 
51077:     obj->setSlot(JSObject::JSSLOT_DATE_LOCAL_SECONDS, Int32Value(seconds));
51077: 
51077:     jsint minutes = (yearSeconds / 60) % 60;
51077: 
51077:     obj->setSlot(JSObject::JSSLOT_DATE_LOCAL_MINUTES, Int32Value(minutes));
51077: 
51077:     jsint hours = (yearSeconds / (60 * 60)) % 24;
51077: 
51077:     obj->setSlot(JSObject::JSSLOT_DATE_LOCAL_HOURS, Int32Value(hours));
51077: 
51077:     return true;
51077: }
51077: 
51077: /* Cache the local times in obj, if necessary. */
51077: static inline JSBool
51077: GetAndCacheLocalTime(JSContext *cx, JSObject *obj, Value *vp, jsdouble *time = NULL)
    1: {
67943:     if (!obj)
34372:         return false;
67943:     if (!obj->isDate()) {
67943:         if (vp)
67943:             ReportIncompatibleMethod(cx, vp, &js_DateClass);
67943:         return false;
67943:     }
34356: 
51077:     /* If the local time is undefined, we need to fill in the cached values. */
51077:     if (obj->getSlot(JSObject::JSSLOT_DATE_LOCAL_TIME).isUndefined()) {
51077:         if (!FillLocalTimes(cx, obj))
51077:             return false;
    1:     }
    1: 
51077:     if (time)
51077:         *time = obj->getSlot(JSObject::JSSLOT_DATE_LOCAL_TIME).toDouble();
51077: 
34372:     return true;
    1: }
    1: 
61734: static inline bool
61734: GetThisUTCTime(JSContext *cx, Value *vp, jsdouble *dp)
61734: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734:     return GetUTCTime(cx, obj, vp, dp);
61734: }
61734: 
    1: /*
    1:  * See ECMA 15.9.5.4 thru 15.9.5.23
    1:  */
    1: static JSBool
48470: date_getTime(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     jsdouble result;
61734:     if (!GetThisUTCTime(cx, vp, &result))
61734:         return false;
48470:     vp->setNumber(result);
61734:     return true;
    1: }
    1: 
    1: static JSBool
48470: date_getYear(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
51077:     if (!GetAndCacheLocalTime(cx, obj, vp))
61734:         return false;
51077: 
51077:     Value yearVal = obj->getSlot(JSObject::JSSLOT_DATE_LOCAL_YEAR);
51077:     if (yearVal.isInt32()) {
51077:         /* Follow ECMA-262 to the letter, contrary to IE JScript. */
51077:         jsint year = yearVal.toInt32() - 1900;
51077:         vp->setInt32(year);
51077:     } else {
51077:         *vp = yearVal;
51077:     }
51077: 
61734:     return true;
    1: }
    1: 
    1: static JSBool
48470: date_getFullYear(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
51077:     if (!GetAndCacheLocalTime(cx, obj, vp))
51077:         return JS_FALSE;
51077: 
51077:     *vp = obj->getSlot(JSObject::JSSLOT_DATE_LOCAL_YEAR);
51077:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
48470: date_getUTCFullYear(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     jsdouble result;
61734:     if (!GetThisUTCTime(cx, vp, &result))
61734:         return false;
    1: 
    1:     if (JSDOUBLE_IS_FINITE(result))
    1:         result = YearFromTime(result);
    1: 
48470:     vp->setNumber(result);
61734:     return true;
    1: }
    1: 
    1: static JSBool
48470: date_getMonth(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
51077:     if (!GetAndCacheLocalTime(cx, obj, vp))
61734:         return false;
    1: 
51077:     *vp = obj->getSlot(JSObject::JSSLOT_DATE_LOCAL_MONTH);
61734:     return true;
    1: }
    1: 
    1: static JSBool
48470: date_getUTCMonth(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     jsdouble result;
61734:     if (!GetThisUTCTime(cx, vp, &result))
61734:         return false;
    1: 
    1:     if (JSDOUBLE_IS_FINITE(result))
    1:         result = MonthFromTime(result);
    1: 
48470:     vp->setNumber(result);
61734:     return true;
    1: }
    1: 
    1: static JSBool
48470: date_getDate(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
51077:     if (!GetAndCacheLocalTime(cx, obj, vp))
61734:         return false;
    1: 
51077:     *vp = obj->getSlot(JSObject::JSSLOT_DATE_LOCAL_DATE);
61734:     return true;
    1: }
    1: 
    1: static JSBool
48470: date_getUTCDate(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     jsdouble result;
61734:     if (!GetThisUTCTime(cx, vp, &result))
61734:         return false;
    1: 
    1:     if (JSDOUBLE_IS_FINITE(result))
    1:         result = DateFromTime(result);
    1: 
48470:     vp->setNumber(result);
61734:     return true;
    1: }
    1: 
    1: static JSBool
48470: date_getDay(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
51077:     if (!GetAndCacheLocalTime(cx, obj, vp))
61734:         return false;
    1: 
51077:     *vp = obj->getSlot(JSObject::JSSLOT_DATE_LOCAL_DAY);
61734:     return true;
    1: }
    1: 
    1: static JSBool
48470: date_getUTCDay(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     jsdouble result;
61734:     if (!GetThisUTCTime(cx, vp, &result))
61734:         return false;
    1: 
    1:     if (JSDOUBLE_IS_FINITE(result))
    1:         result = WeekDay(result);
    1: 
48470:     vp->setNumber(result);
61734:     return true;
    1: }
    1: 
    1: static JSBool
48470: date_getHours(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
51077:     if (!GetAndCacheLocalTime(cx, obj, vp))
61734:         return false;
    1: 
51077:     *vp = obj->getSlot(JSObject::JSSLOT_DATE_LOCAL_HOURS);
61734:     return true;
    1: }
    1: 
    1: static JSBool
48470: date_getUTCHours(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     jsdouble result;
61734:     if (!GetThisUTCTime(cx, vp, &result))
61734:         return false;
    1: 
    1:     if (JSDOUBLE_IS_FINITE(result))
    1:         result = HourFromTime(result);
    1: 
48470:     vp->setNumber(result);
48470:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
48470: date_getMinutes(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
51077:     if (!GetAndCacheLocalTime(cx, obj, vp))
61734:         return false;
    1: 
51077:     *vp = obj->getSlot(JSObject::JSSLOT_DATE_LOCAL_MINUTES);
61734:     return true;
    1: }
    1: 
    1: static JSBool
48470: date_getUTCMinutes(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     jsdouble result;
61734:     if (!GetThisUTCTime(cx, vp, &result))
61734:         return false;
    1: 
    1:     if (JSDOUBLE_IS_FINITE(result))
    1:         result = MinFromTime(result);
    1: 
48470:     vp->setNumber(result);
61734:     return true;
    1: }
    1: 
    1: /* Date.getSeconds is mapped to getUTCSeconds */
    1: 
    1: static JSBool
48470: date_getUTCSeconds(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
51077:     if (!GetAndCacheLocalTime(cx, obj, vp))
61734:         return false;
    1: 
51077:     *vp = obj->getSlot(JSObject::JSSLOT_DATE_LOCAL_SECONDS);
61734:     return true;
    1: }
    1: 
    1: /* Date.getMilliseconds is mapped to getUTCMilliseconds */
    1: 
    1: static JSBool
48470: date_getUTCMilliseconds(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     jsdouble result;
61734:     if (!GetThisUTCTime(cx, vp, &result))
61734:         return false;
    1: 
    1:     if (JSDOUBLE_IS_FINITE(result))
    1:         result = msFromTime(result);
    1: 
48470:     vp->setNumber(result);
61734:     return true;
    1: }
    1: 
    1: static JSBool
48470: date_getTimezoneOffset(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
 4127: 
61734:     jsdouble utctime;
 4127:     if (!GetUTCTime(cx, obj, vp, &utctime))
61734:         return false;
61734: 
61734:     jsdouble localtime;
12042:     if (!GetAndCacheLocalTime(cx, obj, NULL, &localtime))
61734:         return false;
    1: 
    1:     /*
 4127:      * Return the time zone offset in minutes for the current locale that is
 4127:      * appropriate for this time. This value would be a constant except for
 4127:      * daylight savings time.
    1:      */
61734:     jsdouble result = (utctime - localtime) / msPerMinute;
48470:     vp->setNumber(result);
61734:     return true;
    1: }
    1: 
    1: static JSBool
48470: date_setTime(JSContext *cx, uintN argc, Value *vp)
16519: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
67943:     if (!obj->isDate()) {
67943:         ReportIncompatibleMethod(cx, vp, &js_DateClass);
34346:         return false;
67943:     }
16519: 
34346:     if (argc == 0) {
34346:         SetDateToNaN(cx, obj, vp);
34346:         return true;
16519:     }
16519: 
40828:     jsdouble result;
40828:     if (!ValueToNumber(cx, vp[2], &result))
34346:         return false;
    1: 
34346:     return SetUTCTime(cx, obj, TIMECLIP(result), vp);
    1: }
    1: 
    1: static JSBool
48470: date_makeTime(JSContext *cx, uintN maxargs, JSBool local, uintN argc, Value *vp)
    1: {
48470:     Value *argv;
    1:     uintN i;
    1:     jsdouble args[4], *argp, *stop;
    1:     jsdouble hour, min, sec, msec;
    1:     jsdouble lorutime; /* Local or UTC version of *date */
    1: 
    1:     jsdouble msec_time;
    1:     jsdouble result;
    1: 
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
 4127:     if (!GetUTCTime(cx, obj, vp, &result))
34346:         return false;
    1: 
    1:     /* just return NaN if the date is already NaN */
48470:     if (!JSDOUBLE_IS_FINITE(result)) {
48470:         vp->setNumber(result);
48470:         return true;
48470:     }
    1: 
 4127:     /*
 4127:      * Satisfy the ECMA rule that if a function is called with
    1:      * fewer arguments than the specified formal arguments, the
    1:      * remaining arguments are set to undefined.  Seems like all
    1:      * the Date.setWhatever functions in ECMA are only varargs
    1:      * beyond the first argument; this should be set to undefined
    1:      * if it's not given.  This means that "d = new Date();
    1:      * d.setMilliseconds()" returns NaN.  Blech.
    1:      */
34346:     if (argc == 0) {
34346:         SetDateToNaN(cx, obj, vp);
34346:         return true;
34346:     }
16519:     if (argc > maxargs)
    1:         argc = maxargs;  /* clamp argc */
16519:     JS_ASSERT(argc <= 4);
    1: 
 4127:     argv = vp + 2;
    1:     for (i = 0; i < argc; i++) {
40828:         if (!ValueToNumber(cx, argv[i], &args[i]))
34346:             return false;
34346:         if (!JSDOUBLE_IS_FINITE(args[i])) {
34346:             SetDateToNaN(cx, obj, vp);
34346:             return true;
34346:         }
    1:         args[i] = js_DoubleToInteger(args[i]);
    1:     }
    1: 
29647:     if (local)
43191:         lorutime = LocalTime(result, cx);
29647:     else
    1:         lorutime = result;
    1: 
    1:     argp = args;
    1:     stop = argp + argc;
    1:     if (maxargs >= 4 && argp < stop)
    1:         hour = *argp++;
    1:     else
    1:         hour = HourFromTime(lorutime);
    1: 
    1:     if (maxargs >= 3 && argp < stop)
    1:         min = *argp++;
    1:     else
    1:         min = MinFromTime(lorutime);
    1: 
    1:     if (maxargs >= 2 && argp < stop)
    1:         sec = *argp++;
    1:     else
    1:         sec = SecFromTime(lorutime);
    1: 
    1:     if (maxargs >= 1 && argp < stop)
    1:         msec = *argp;
    1:     else
    1:         msec = msFromTime(lorutime);
    1: 
    1:     msec_time = MakeTime(hour, min, sec, msec);
    1:     result = MakeDate(Day(lorutime), msec_time);
    1: 
29647: /*     fprintf(stderr, "%f\n", result); */
29647: 
29647:     if (local)
43191:         result = UTC(result, cx);
29647: 
29647: /*     fprintf(stderr, "%f\n", result); */
    1: 
34346:     return SetUTCTime(cx, obj, TIMECLIP(result), vp);
    1: }
    1: 
    1: static JSBool
48470: date_setMilliseconds(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return date_makeTime(cx, 1, JS_TRUE, argc, vp);
    1: }
    1: 
    1: static JSBool
48470: date_setUTCMilliseconds(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return date_makeTime(cx, 1, JS_FALSE, argc, vp);
    1: }
    1: 
    1: static JSBool
48470: date_setSeconds(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return date_makeTime(cx, 2, JS_TRUE, argc, vp);
    1: }
    1: 
    1: static JSBool
48470: date_setUTCSeconds(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return date_makeTime(cx, 2, JS_FALSE, argc, vp);
    1: }
    1: 
    1: static JSBool
48470: date_setMinutes(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return date_makeTime(cx, 3, JS_TRUE, argc, vp);
    1: }
    1: 
    1: static JSBool
48470: date_setUTCMinutes(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return date_makeTime(cx, 3, JS_FALSE, argc, vp);
    1: }
    1: 
    1: static JSBool
48470: date_setHours(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return date_makeTime(cx, 4, JS_TRUE, argc, vp);
    1: }
    1: 
    1: static JSBool
48470: date_setUTCHours(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return date_makeTime(cx, 4, JS_FALSE, argc, vp);
    1: }
    1: 
    1: static JSBool
48470: date_makeDate(JSContext *cx, uintN maxargs, JSBool local, uintN argc, Value *vp)
    1: {
48470:     Value *argv;
    1:     uintN i;
    1:     jsdouble lorutime; /* local or UTC version of *date */
    1:     jsdouble args[3], *argp, *stop;
    1:     jsdouble year, month, day;
    1:     jsdouble result;
    1: 
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
 4127:     if (!GetUTCTime(cx, obj, vp, &result))
34346:         return false;
    1: 
    1:     /* see complaint about ECMA in date_MakeTime */
34346:     if (argc == 0) {
35051:         SetDateToNaN(cx, obj, vp);
34346:         return true;
34346:     }
16519:     if (argc > maxargs)
    1:         argc = maxargs;   /* clamp argc */
 4127:     JS_ASSERT(1 <= argc && argc <= 3);
    1: 
 4127:     argv = vp + 2;
    1:     for (i = 0; i < argc; i++) {
40828:         if (!ValueToNumber(cx, argv[i], &args[i]))
    1:             return JS_FALSE;
34346:         if (!JSDOUBLE_IS_FINITE(args[i])) {
34346:             SetDateToNaN(cx, obj, vp);
34346:             return true;
34346:         }
    1:         args[i] = js_DoubleToInteger(args[i]);
    1:     }
    1: 
    1:     /* return NaN if date is NaN and we're not setting the year,
    1:      * If we are, use 0 as the time. */
    1:     if (!(JSDOUBLE_IS_FINITE(result))) {
48470:         if (maxargs < 3) {
48470:             vp->setDouble(result);
48470:             return true;
48470:         }
    1:         lorutime = +0.;
    1:     } else {
43191:         lorutime = local ? LocalTime(result, cx) : result;
    1:     }
    1: 
    1:     argp = args;
    1:     stop = argp + argc;
    1:     if (maxargs >= 3 && argp < stop)
    1:         year = *argp++;
    1:     else
    1:         year = YearFromTime(lorutime);
    1: 
    1:     if (maxargs >= 2 && argp < stop)
    1:         month = *argp++;
    1:     else
    1:         month = MonthFromTime(lorutime);
    1: 
    1:     if (maxargs >= 1 && argp < stop)
    1:         day = *argp++;
    1:     else
    1:         day = DateFromTime(lorutime);
    1: 
    1:     day = MakeDay(year, month, day); /* day within year */
    1:     result = MakeDate(day, TimeWithinDay(lorutime));
    1: 
29647:     if (local)
43191:         result = UTC(result, cx);
    1: 
34346:     return SetUTCTime(cx, obj, TIMECLIP(result), vp);
    1: }
    1: 
    1: static JSBool
48470: date_setDate(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return date_makeDate(cx, 1, JS_TRUE, argc, vp);
    1: }
    1: 
    1: static JSBool
48470: date_setUTCDate(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return date_makeDate(cx, 1, JS_FALSE, argc, vp);
    1: }
    1: 
    1: static JSBool
48470: date_setMonth(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return date_makeDate(cx, 2, JS_TRUE, argc, vp);
    1: }
    1: 
    1: static JSBool
48470: date_setUTCMonth(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return date_makeDate(cx, 2, JS_FALSE, argc, vp);
    1: }
    1: 
    1: static JSBool
48470: date_setFullYear(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return date_makeDate(cx, 3, JS_TRUE, argc, vp);
    1: }
    1: 
    1: static JSBool
48470: date_setUTCFullYear(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return date_makeDate(cx, 3, JS_FALSE, argc, vp);
    1: }
    1: 
    1: static JSBool
48470: date_setYear(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
34346: 
    1:     jsdouble result;
34346:     if (!GetUTCTime(cx, obj, vp, &result))
34346:         return false;
    1: 
34346:     if (argc == 0) {
34346:         /* Call this only after GetUTCTime has verified that obj is Date. */
34346:         SetDateToNaN(cx, obj, vp);
34346:         return true;
    1:     }
    1: 
40828:     jsdouble year;
40828:     if (!ValueToNumber(cx, vp[2], &year))
34346:         return false;
34346:     if (!JSDOUBLE_IS_FINITE(year)) {
34346:         SetDateToNaN(cx, obj, vp);
34346:         return true;
34346:     }
34346:     year = js_DoubleToInteger(year);
    1:     if (year >= 0 && year <= 99)
    1:         year += 1900;
    1: 
43191:     jsdouble t = JSDOUBLE_IS_FINITE(result) ? LocalTime(result, cx) : +0.0;
34346:     jsdouble day = MakeDay(year, MonthFromTime(t), DateFromTime(t));
    1:     result = MakeDate(day, TimeWithinDay(t));
43191:     result = UTC(result, cx);
    1: 
34346:     return SetUTCTime(cx, obj, TIMECLIP(result), vp);
    1: }
    1: 
    1: /* constants for toString, toUTCString */
    1: static char js_NaN_date_str[] = "Invalid Date";
    1: static const char* days[] =
    1: {
    1:    "Sun","Mon","Tue","Wed","Thu","Fri","Sat"
    1: };
    1: static const char* months[] =
    1: {
    1:    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
    1: };
    1: 
20587: 
20587: // Avoid dependence on PRMJ_FormatTimeUSEnglish, because it
20587: // requires a PRMJTime... which only has 16-bit years.  Sub-ECMA.
20587: static void
20587: print_gmt_string(char* buf, size_t size, jsdouble utctime)
20587: {
20587:     JS_snprintf(buf, size, "%s, %.2d %s %.4d %.2d:%.2d:%.2d GMT",
20587:                 days[WeekDay(utctime)],
20587:                 DateFromTime(utctime),
20587:                 months[MonthFromTime(utctime)],
20587:                 YearFromTime(utctime),
20587:                 HourFromTime(utctime),
20587:                 MinFromTime(utctime),
20587:                 SecFromTime(utctime));
20587: }
20587: 
20587: static void
20587: print_iso_string(char* buf, size_t size, jsdouble utctime)
20587: {
20587:     JS_snprintf(buf, size, "%.4d-%.2d-%.2dT%.2d:%.2d:%.2d.%.3dZ",
20587:                 YearFromTime(utctime),
20587:                 MonthFromTime(utctime) + 1,
20587:                 DateFromTime(utctime),
20587:                 HourFromTime(utctime),
20587:                 MinFromTime(utctime),
20587:                 SecFromTime(utctime),
20587:                 msFromTime(utctime));
20587: }
20587: 
    1: static JSBool
48470: date_utc_format(JSContext *cx, Value *vp,
20587:                 void (*printFunc)(char*, size_t, jsdouble))
    1: {
61734:     jsdouble utctime;
61734:     if (!GetThisUTCTime(cx, vp, &utctime))
61734:         return false;
61734: 
    1:     char buf[100];
68956:     if (!JSDOUBLE_IS_FINITE(utctime)) {
68956:         if (printFunc == print_iso_string) {
68956:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INVALID_DATE);
68956:             return false;
68956:         }
68956: 
61734:         JS_snprintf(buf, sizeof buf, js_NaN_date_str);
68956:     } else {
61734:         (*printFunc)(buf, sizeof buf, utctime);
68956:     }
    1: 
61734:     JSString *str = JS_NewStringCopyZ(cx, buf);
    1:     if (!str)
61734:         return false;
48470:     vp->setString(str);
61734:     return true;
    1: }
    1: 
20587: static JSBool
48470: date_toGMTString(JSContext *cx, uintN argc, Value *vp)
20587: {
20587:     return date_utc_format(cx, vp, print_gmt_string);
20587: }
20587: 
20587: static JSBool
48470: date_toISOString(JSContext *cx, uintN argc, Value *vp)
20587: {
20587:     return date_utc_format(cx, vp, print_iso_string);
20587: }
20587: 
51100: /* ES5 15.9.5.44. */
56593: static JSBool
51100: date_toJSON(JSContext *cx, uintN argc, Value *vp)
51100: {
51100:     /* Step 1. */
61734:     JSObject *obj = ToObject(cx, &vp[1]);
51100:     if (!obj)
51100:         return false;
51100: 
51100:     /* Step 2. */
51100:     Value &tv = vp[0];
51100:     if (!DefaultValue(cx, obj, JSTYPE_NUMBER, &tv))
51100:         return false;
51100: 
51100:     /* Step 3. */
51100:     if (tv.isDouble() && !JSDOUBLE_IS_FINITE(tv.toDouble())) {
51100:         vp->setNull();
51100:         return true;
51100:     }
51100: 
51100:     /* Step 4. */
51100:     Value &toISO = vp[0];
51100:     if (!obj->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.toISOStringAtom), &toISO))
51100:         return false;
51100: 
51100:     /* Step 5. */
51100:     if (!js_IsCallable(toISO)) {
51100:         JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR, js_GetErrorMessage, NULL,
51100:                                      JSMSG_BAD_TOISOSTRING_PROP);
51100:         return false;
51100:     }
51100: 
51100:     /* Step 6. */
51100:     LeaveTrace(cx);
51100:     InvokeArgsGuard args;
69223:     if (!cx->stack.pushInvokeArgs(cx, 0, &args))
51100:         return false;
51100: 
68893:     args.calleev() = toISO;
51100:     args.thisv().setObject(*obj);
51100: 
69223:     if (!Invoke(cx, args))
51100:         return false;
51100:     *vp = args.rval();
51100:     return true;
51100: }
51100: 
    1: /* for Date.toLocaleString; interface to PRMJTime date struct.
    1:  */
    1: static void
43191: new_explode(jsdouble timeval, PRMJTime *split, JSContext *cx)
    1: {
    1:     jsint year = YearFromTime(timeval);
    1: 
    1:     split->tm_usec = (int32) msFromTime(timeval) * 1000;
    1:     split->tm_sec = (int8) SecFromTime(timeval);
    1:     split->tm_min = (int8) MinFromTime(timeval);
    1:     split->tm_hour = (int8) HourFromTime(timeval);
    1:     split->tm_mday = (int8) DateFromTime(timeval);
    1:     split->tm_mon = (int8) MonthFromTime(timeval);
    1:     split->tm_wday = (int8) WeekDay(timeval);
 7909:     split->tm_year = year;
    1:     split->tm_yday = (int16) DayWithinYear(timeval, year);
    1: 
    1:     /* not sure how this affects things, but it doesn't seem
    1:        to matter. */
43191:     split->tm_isdst = (DaylightSavingTA(timeval, cx) != 0);
    1: }
    1: 
    1: typedef enum formatspec {
    1:     FORMATSPEC_FULL, FORMATSPEC_DATE, FORMATSPEC_TIME
    1: } formatspec;
    1: 
    1: /* helper function */
    1: static JSBool
48470: date_format(JSContext *cx, jsdouble date, formatspec format, Value *rval)
    1: {
    1:     char buf[100];
    1:     JSString *str;
    1:     char tzbuf[100];
    1:     JSBool usetz;
    1:     size_t i, tzlen;
    1:     PRMJTime split;
    1: 
    1:     if (!JSDOUBLE_IS_FINITE(date)) {
    1:         JS_snprintf(buf, sizeof buf, js_NaN_date_str);
    1:     } else {
43191:         jsdouble local = LocalTime(date, cx);
    1: 
    1:         /* offset from GMT in minutes.  The offset includes daylight savings,
    1:            if it applies. */
43191:         jsint minutes = (jsint) floor(AdjustTime(date, cx) / msPerMinute);
    1: 
    1:         /* map 510 minutes to 0830 hours */
    1:         intN offset = (minutes / 60) * 100 + minutes % 60;
    1: 
    1:         /* print as "Wed Nov 05 19:38:03 GMT-0800 (PST) 1997" The TZA is
    1:          * printed as 'GMT-0800' rather than as 'PST' to avoid
    1:          * operating-system dependence on strftime (which
    1:          * PRMJ_FormatTimeUSEnglish calls, for %Z only.)  win32 prints
    1:          * PST as 'Pacific Standard Time.'  This way we always know
    1:          * what we're getting, and can parse it if we produce it.
    1:          * The OS TZA string is included as a comment.
    1:          */
    1: 
    1:         /* get a timezone string from the OS to include as a
    1:            comment. */
43191:         new_explode(date, &split, cx);
    1:         if (PRMJ_FormatTime(tzbuf, sizeof tzbuf, "(%Z)", &split) != 0) {
    1: 
    1:             /* Decide whether to use the resulting timezone string.
    1:              *
    1:              * Reject it if it contains any non-ASCII, non-alphanumeric
    1:              * characters.  It's then likely in some other character
    1:              * encoding, and we probably won't display it correctly.
    1:              */
    1:             usetz = JS_TRUE;
    1:             tzlen = strlen(tzbuf);
    1:             if (tzlen > 100) {
    1:                 usetz = JS_FALSE;
    1:             } else {
    1:                 for (i = 0; i < tzlen; i++) {
    1:                     jschar c = tzbuf[i];
    1:                     if (c > 127 ||
    1:                         !(isalpha(c) || isdigit(c) ||
    1:                           c == ' ' || c == '(' || c == ')')) {
    1:                         usetz = JS_FALSE;
    1:                     }
    1:                 }
    1:             }
    1: 
    1:             /* Also reject it if it's not parenthesized or if it's '()'. */
    1:             if (tzbuf[0] != '(' || tzbuf[1] == ')')
    1:                 usetz = JS_FALSE;
    1:         } else
    1:             usetz = JS_FALSE;
    1: 
    1:         switch (format) {
    1:           case FORMATSPEC_FULL:
    1:             /*
    1:              * Avoid dependence on PRMJ_FormatTimeUSEnglish, because it
    1:              * requires a PRMJTime... which only has 16-bit years.  Sub-ECMA.
    1:              */
    1:             /* Tue Oct 31 2000 09:41:40 GMT-0800 (PST) */
    1:             JS_snprintf(buf, sizeof buf,
    1:                         "%s %s %.2d %.4d %.2d:%.2d:%.2d GMT%+.4d%s%s",
    1:                         days[WeekDay(local)],
    1:                         months[MonthFromTime(local)],
    1:                         DateFromTime(local),
    1:                         YearFromTime(local),
    1:                         HourFromTime(local),
    1:                         MinFromTime(local),
    1:                         SecFromTime(local),
    1:                         offset,
    1:                         usetz ? " " : "",
    1:                         usetz ? tzbuf : "");
    1:             break;
    1:           case FORMATSPEC_DATE:
    1:             /* Tue Oct 31 2000 */
    1:             JS_snprintf(buf, sizeof buf,
    1:                         "%s %s %.2d %.4d",
    1:                         days[WeekDay(local)],
    1:                         months[MonthFromTime(local)],
    1:                         DateFromTime(local),
    1:                         YearFromTime(local));
    1:             break;
    1:           case FORMATSPEC_TIME:
    1:             /* 09:41:40 GMT-0800 (PST) */
    1:             JS_snprintf(buf, sizeof buf,
    1:                         "%.2d:%.2d:%.2d GMT%+.4d%s%s",
    1:                         HourFromTime(local),
    1:                         MinFromTime(local),
    1:                         SecFromTime(local),
    1:                         offset,
    1:                         usetz ? " " : "",
    1:                         usetz ? tzbuf : "");
    1:             break;
    1:         }
    1:     }
    1: 
    1:     str = JS_NewStringCopyZ(cx, buf);
    1:     if (!str)
    1:         return JS_FALSE;
48470:     rval->setString(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
61734: date_toLocaleHelper(JSContext *cx, JSObject *obj, const char *format, Value *vp)
    1: {
    1:     char buf[100];
    1:     JSString *str;
    1:     PRMJTime split;
    1:     jsdouble utctime;
    1: 
 4127:     if (!GetUTCTime(cx, obj, vp, &utctime))
61734:         return false;
    1: 
    1:     if (!JSDOUBLE_IS_FINITE(utctime)) {
    1:         JS_snprintf(buf, sizeof buf, js_NaN_date_str);
    1:     } else {
    1:         intN result_len;
43191:         jsdouble local = LocalTime(utctime, cx);
43191:         new_explode(local, &split, cx);
    1: 
    1:         /* let PRMJTime format it.       */
    1:         result_len = PRMJ_FormatTime(buf, sizeof buf, format, &split);
    1: 
    1:         /* If it failed, default to toString. */
    1:         if (result_len == 0)
29647:             return date_format(cx, utctime, FORMATSPEC_FULL, vp);
    1: 
    1:         /* Hacked check against undesired 2-digit year 00/00/00 form. */
    1:         if (strcmp(format, "%x") == 0 && result_len >= 6 &&
    1:             /* Format %x means use OS settings, which may have 2-digit yr, so
    1:                hack end of 3/11/22 or 11.03.22 or 11Mar22 to use 4-digit yr...*/
    1:             !isdigit(buf[result_len - 3]) &&
    1:             isdigit(buf[result_len - 2]) && isdigit(buf[result_len - 1]) &&
    1:             /* ...but not if starts with 4-digit year, like 2022/3/11. */
    1:             !(isdigit(buf[0]) && isdigit(buf[1]) &&
    1:               isdigit(buf[2]) && isdigit(buf[3]))) {
    1:             JS_snprintf(buf + (result_len - 2), (sizeof buf) - (result_len - 2),
    1:                         "%d", js_DateGetYear(cx, obj));
    1:         }
    1: 
    1:     }
    1: 
    1:     if (cx->localeCallbacks && cx->localeCallbacks->localeToUnicode)
48470:         return cx->localeCallbacks->localeToUnicode(cx, buf, Jsvalify(vp));
    1: 
    1:     str = JS_NewStringCopyZ(cx, buf);
    1:     if (!str)
61734:         return false;
48470:     vp->setString(str);
61734:     return true;
    1: }
    1: 
    1: static JSBool
48470: date_toLocaleString(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
61734:     /*
61734:      * Use '%#c' for windows, because '%c' is backward-compatible and non-y2k
61734:      * with msvc; '%#c' requests that a full year be used in the result string.
    1:      */
61734:     return date_toLocaleHelper(cx, obj,
    1: #if defined(_WIN32) && !defined(__MWERKS__)
    1:                                    "%#c"
    1: #else
    1:                                    "%c"
    1: #endif
 4127:                                , vp);
    1: }
    1: 
    1: static JSBool
48470: date_toLocaleDateString(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
61734:     /*
61734:      * Use '%#x' for windows, because '%x' is backward-compatible and non-y2k
61734:      * with msvc; '%#x' requests that a full year be used in the result string.
    1:      */
61734:     return date_toLocaleHelper(cx, obj,
    1: #if defined(_WIN32) && !defined(__MWERKS__)
    1:                                    "%#x"
    1: #else
    1:                                    "%x"
    1: #endif
 4127:                                , vp);
    1: }
    1: 
    1: static JSBool
48470: date_toLocaleTimeString(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
61734:     return date_toLocaleHelper(cx, obj, "%X", vp);
    1: }
    1: 
    1: static JSBool
48470: date_toLocaleFormat(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     if (argc == 0)
 4127:         return date_toLocaleString(cx, argc, vp);
    1: 
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
57812:     JSString *fmt = js_ValueToString(cx, vp[2]);
    1:     if (!fmt)
61734:         return false;
48470:     vp[2].setString(fmt);
57812:     JSAutoByteString fmtbytes(cx, fmt);
    1:     if (!fmtbytes)
61734:         return false;
    1: 
61734:     return date_toLocaleHelper(cx, obj, fmtbytes.ptr(), vp);
    1: }
    1: 
    1: static JSBool
48470: date_toTimeString(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     jsdouble utctime;
61734:     if (!GetThisUTCTime(cx, vp, &utctime))
61734:         return false;
29647:     return date_format(cx, utctime, FORMATSPEC_TIME, vp);
    1: }
    1: 
    1: static JSBool
48470: date_toDateString(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     jsdouble utctime;
61734:     if (!GetThisUTCTime(cx, vp, &utctime))
61734:         return false;
29647:     return date_format(cx, utctime, FORMATSPEC_DATE, vp);
    1: }
    1: 
    1: #if JS_HAS_TOSOURCE
    1: #include <string.h>
53852: #include "jsnum.h"
    1: 
    1: static JSBool
48470: date_toSource(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     jsdouble utctime;
61734:     if (!GetThisUTCTime(cx, vp, &utctime))
61734:         return false;
    1: 
53852:     ToCStringBuf cbuf;
61734:     char *numStr = NumberToCString(cx, &cbuf, utctime);
    1:     if (!numStr) {
    1:         JS_ReportOutOfMemory(cx);
61734:         return false;
    1:     }
    1: 
61734:     char *bytes = JS_smprintf("(new %s(%s))", js_Date_str, numStr);
    1:     if (!bytes) {
    1:         JS_ReportOutOfMemory(cx);
61734:         return false;
    1:     }
    1: 
61734:     JSString *str = JS_NewStringCopyZ(cx, bytes);
64560:     cx->free_(bytes);
59008:     if (!str)
61734:         return false;
48470:     vp->setString(str);
61734:     return true;
    1: }
    1: #endif
    1: 
    1: static JSBool
48470: date_toString(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     jsdouble utctime;
61734:     if (!GetThisUTCTime(cx, vp, &utctime))
61734:         return false;
 4127: 
29647:     return date_format(cx, utctime, FORMATSPEC_FULL, vp);
    1: }
    1: 
    1: static JSBool
48470: date_valueOf(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     /*
61734:      * It is an error to call date_valueOf on a non-date object, but we don't
    1:      * need to check for that explicitly here because every path calls
    1:      * GetUTCTime, which does the check.
    1:      */
    1: 
    1:     /* If called directly with no arguments, convert to a time number. */
    1:     if (argc == 0)
 4127:         return date_getTime(cx, argc, vp);
    1: 
61734:     /* Verify this before extracting a string from the first argument. */
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
    1:     /* Convert to number only if the hint was given, otherwise favor string. */
59890:     JSString *str = js_ValueToString(cx, vp[2]);
    1:     if (!str)
61734:         return false;
59890:     JSLinearString *linear_str = str->ensureLinear(cx);
59890:     if (!linear_str)
61734:         return false;
59890:     JSAtom *number_str = cx->runtime->atomState.typeAtoms[JSTYPE_NUMBER];
59890:     if (EqualStrings(linear_str, number_str))
 4127:         return date_getTime(cx, argc, vp);
 4127:     return date_toString(cx, argc, vp);
    1: }
    1: 
20408: // Don't really need an argument here, but we don't support arg-less builtins
20930: JS_DEFINE_TRCINFO_1(date_now,
48613:     (1, (static, DOUBLE, date_now_tn, CONTEXT, 0, nanojit::ACCSET_STORE_ANY)))
20408: 
    1: static JSFunctionSpec date_static_methods[] = {
16519:     JS_FN("UTC",                 date_UTC,                MAXARGS,0),
16519:     JS_FN("parse",               date_parse,              1,0),
32669:     JS_TN("now",                 date_now,                0,0, &date_now_trcinfo),
 4127:     JS_FS_END
    1: };
    1: 
    1: static JSFunctionSpec date_methods[] = {
16519:     JS_FN("getTime",             date_getTime,            0,0),
16519:     JS_FN("getTimezoneOffset",   date_getTimezoneOffset,  0,0),
16519:     JS_FN("getYear",             date_getYear,            0,0),
16519:     JS_FN("getFullYear",         date_getFullYear,        0,0),
16519:     JS_FN("getUTCFullYear",      date_getUTCFullYear,     0,0),
16519:     JS_FN("getMonth",            date_getMonth,           0,0),
16519:     JS_FN("getUTCMonth",         date_getUTCMonth,        0,0),
16519:     JS_FN("getDate",             date_getDate,            0,0),
16519:     JS_FN("getUTCDate",          date_getUTCDate,         0,0),
16519:     JS_FN("getDay",              date_getDay,             0,0),
16519:     JS_FN("getUTCDay",           date_getUTCDay,          0,0),
16519:     JS_FN("getHours",            date_getHours,           0,0),
16519:     JS_FN("getUTCHours",         date_getUTCHours,        0,0),
16519:     JS_FN("getMinutes",          date_getMinutes,         0,0),
16519:     JS_FN("getUTCMinutes",       date_getUTCMinutes,      0,0),
16519:     JS_FN("getSeconds",          date_getUTCSeconds,      0,0),
16519:     JS_FN("getUTCSeconds",       date_getUTCSeconds,      0,0),
16519:     JS_FN("getMilliseconds",     date_getUTCMilliseconds, 0,0),
16519:     JS_FN("getUTCMilliseconds",  date_getUTCMilliseconds, 0,0),
16519:     JS_FN("setTime",             date_setTime,            1,0),
16519:     JS_FN("setYear",             date_setYear,            1,0),
16519:     JS_FN("setFullYear",         date_setFullYear,        3,0),
16519:     JS_FN("setUTCFullYear",      date_setUTCFullYear,     3,0),
16519:     JS_FN("setMonth",            date_setMonth,           2,0),
16519:     JS_FN("setUTCMonth",         date_setUTCMonth,        2,0),
16519:     JS_FN("setDate",             date_setDate,            1,0),
16519:     JS_FN("setUTCDate",          date_setUTCDate,         1,0),
16519:     JS_FN("setHours",            date_setHours,           4,0),
16519:     JS_FN("setUTCHours",         date_setUTCHours,        4,0),
16519:     JS_FN("setMinutes",          date_setMinutes,         3,0),
16519:     JS_FN("setUTCMinutes",       date_setUTCMinutes,      3,0),
16519:     JS_FN("setSeconds",          date_setSeconds,         2,0),
16519:     JS_FN("setUTCSeconds",       date_setUTCSeconds,      2,0),
16519:     JS_FN("setMilliseconds",     date_setMilliseconds,    1,0),
16519:     JS_FN("setUTCMilliseconds",  date_setUTCMilliseconds, 1,0),
16519:     JS_FN("toUTCString",         date_toGMTString,        0,0),
16519:     JS_FN(js_toLocaleString_str, date_toLocaleString,     0,0),
16519:     JS_FN("toLocaleDateString",  date_toLocaleDateString, 0,0),
16519:     JS_FN("toLocaleTimeString",  date_toLocaleTimeString, 0,0),
16519:     JS_FN("toLocaleFormat",      date_toLocaleFormat,     0,0),
16519:     JS_FN("toDateString",        date_toDateString,       0,0),
16519:     JS_FN("toTimeString",        date_toTimeString,       0,0),
20587:     JS_FN("toISOString",         date_toISOString,        0,0),
51100:     JS_FN(js_toJSON_str,         date_toJSON,             1,0),
    1: #if JS_HAS_TOSOURCE
16519:     JS_FN(js_toSource_str,       date_toSource,           0,0),
    1: #endif
16519:     JS_FN(js_toString_str,       date_toString,           0,0),
41857:     JS_FN(js_valueOf_str,        date_valueOf,            0,0),
 4127:     JS_FS_END
    1: };
    1: 
20402: JSBool
50489: js_Date(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     /* Date called as function. */
53557:     if (!IsConstructing(vp))
50489:         return date_format(cx, NowAsMillis(), FORMATSPEC_FULL, vp);
    1: 
53557:     Value *argv = vp + 2;
53557: 
    1:     /* Date called as constructor. */
34346:     jsdouble d;
    1:     if (argc == 0) {
34346:         d = NowAsMillis();
    1:     } else if (argc == 1) {
53557:         if (!argv[0].isString()) {
    1:             /* the argument is a millisecond number */
53557:             if (!ValueToNumber(cx, argv[0], &d))
53557:                 return false;
34346:             d = TIMECLIP(d);
    1:         } else {
    1:             /* the argument is a string; parse it. */
53557:             JSString *str = js_ValueToString(cx, argv[0]);
    1:             if (!str)
53557:                 return false;
53557:             argv[0].setString(str);
59890:             JSLinearString *linearStr = str->ensureLinear(cx);
59890:             if (!linearStr)
59890:                 return false;
    1: 
59890:             if (!date_parseString(linearStr, &d, cx))
34346:                 d = js_NaN;
34346:             else
34346:                 d = TIMECLIP(d);
    1:         }
    1:     } else {
    1:         jsdouble msec_time;
53557:         if (!date_msecFromArgs(cx, argc, argv, &msec_time))
53557:             return false;
    1: 
 4576:         if (JSDOUBLE_IS_FINITE(msec_time)) {
43191:             msec_time = UTC(msec_time, cx);
 4576:             msec_time = TIMECLIP(msec_time);
 4576:         }
34346:         d = msec_time;
    1:     }
50489: 
50489:     JSObject *obj = js_NewDateObjectMsec(cx, d);
50489:     if (!obj)
53557:         return false;
50489:     vp->setObject(*obj);
50489: 
53557:     return true;
    1: }
    1: 
    1: JSObject *
    1: js_InitDateClass(JSContext *cx, JSObject *obj)
    1: {
29647:     /* set static LocalTZA */
29647:     LocalTZA = -(PRMJ_LocalGMTDifference() * msPerSecond);
53557:     JSObject *proto = js_InitClass(cx, obj, NULL, &js_DateClass, js_Date, MAXARGS,
28086:                                    NULL, date_methods, NULL, date_static_methods);
    1:     if (!proto)
    1:         return NULL;
    1: 
47533:     AutoObjectRooter tvr(cx, proto);
47533: 
34346:     SetDateToNaN(cx, proto);
34346: 
47533:     /*
47533:      * ES5 B.2.6:
47533:      *   The Function object that is the initial value of
47533:      *   Date.prototype.toGMTString is the same Function
47533:      *   object that is the initial value of
47533:      *   Date.prototype.toUTCString.
47533:      */
47533:     AutoValueRooter toUTCStringFun(cx);
47533:     jsid toUTCStringId = ATOM_TO_JSID(cx->runtime->atomState.toUTCStringAtom);
47533:     jsid toGMTStringId = ATOM_TO_JSID(cx->runtime->atomState.toGMTStringAtom);
47533:     if (!js_GetProperty(cx, proto, toUTCStringId, toUTCStringFun.addr()) ||
48470:         !js_DefineProperty(cx, proto, toGMTStringId, toUTCStringFun.addr(),
62395:                            PropertyStub, StrictPropertyStub, 0)) {
    1:         return NULL;
47533:     }
    1: 
    1:     return proto;
    1: }
    1: 
    1: JS_FRIEND_API(JSObject *)
    1: js_NewDateObjectMsec(JSContext *cx, jsdouble msec_time)
    1: {
47497:     JSObject *obj = NewBuiltinClassInstance(cx, &js_DateClass);
55746:     if (!obj || !obj->ensureSlots(cx, JSObject::DATE_CLASS_RESERVED_SLOTS))
55746:         return NULL;
55746:     if (!SetUTCTime(cx, obj, msec_time))
    1:         return NULL;
    1:     return obj;
    1: }
    1: 
    1: JS_FRIEND_API(JSObject *)
    1: js_NewDateObject(JSContext* cx, int year, int mon, int mday,
    1:                  int hour, int min, int sec)
    1: {
    1:     JSObject *obj;
    1:     jsdouble msec_time;
    1: 
 9800:     JS_ASSERT(mon < 12);
    1:     msec_time = date_msecFromDate(year, mon, mday, hour, min, sec, 0);
43191:     obj = js_NewDateObjectMsec(cx, UTC(msec_time, cx));
    1:     return obj;
    1: }
    1: 
    1: JS_FRIEND_API(JSBool)
    1: js_DateIsValid(JSContext *cx, JSObject* obj)
    1: {
    1:     jsdouble utctime;
    1:     return GetUTCTime(cx, obj, NULL, &utctime) && !JSDOUBLE_IS_NaN(utctime);
    1: }
    1: 
    1: JS_FRIEND_API(int)
    1: js_DateGetYear(JSContext *cx, JSObject* obj)
    1: {
    1:     jsdouble localtime;
    1: 
    1:     /* Preserve legacy API behavior of returning 0 for invalid dates. */
12042:     if (!GetAndCacheLocalTime(cx, obj, NULL, &localtime) ||
12042:         JSDOUBLE_IS_NaN(localtime)) {
    1:         return 0;
12042:     }
    1: 
    1:     return (int) YearFromTime(localtime);
    1: }
    1: 
    1: JS_FRIEND_API(int)
    1: js_DateGetMonth(JSContext *cx, JSObject* obj)
    1: {
    1:     jsdouble localtime;
    1: 
12042:     if (!GetAndCacheLocalTime(cx, obj, NULL, &localtime) ||
12042:         JSDOUBLE_IS_NaN(localtime)) {
    1:         return 0;
12042:     }
    1: 
    1:     return (int) MonthFromTime(localtime);
    1: }
    1: 
    1: JS_FRIEND_API(int)
    1: js_DateGetDate(JSContext *cx, JSObject* obj)
    1: {
    1:     jsdouble localtime;
    1: 
12042:     if (!GetAndCacheLocalTime(cx, obj, NULL, &localtime) ||
12042:         JSDOUBLE_IS_NaN(localtime)) {
    1:         return 0;
12042:     }
    1: 
    1:     return (int) DateFromTime(localtime);
    1: }
    1: 
    1: JS_FRIEND_API(int)
    1: js_DateGetHours(JSContext *cx, JSObject* obj)
    1: {
    1:     jsdouble localtime;
    1: 
12042:     if (!GetAndCacheLocalTime(cx, obj, NULL, &localtime) ||
12042:         JSDOUBLE_IS_NaN(localtime)) {
    1:         return 0;
12042:     }
    1: 
    1:     return (int) HourFromTime(localtime);
    1: }
    1: 
    1: JS_FRIEND_API(int)
    1: js_DateGetMinutes(JSContext *cx, JSObject* obj)
    1: {
    1:     jsdouble localtime;
    1: 
12042:     if (!GetAndCacheLocalTime(cx, obj, NULL, &localtime) ||
12042:         JSDOUBLE_IS_NaN(localtime)) {
    1:         return 0;
12042:     }
    1: 
    1:     return (int) MinFromTime(localtime);
    1: }
    1: 
    1: JS_FRIEND_API(int)
    1: js_DateGetSeconds(JSContext *cx, JSObject* obj)
    1: {
    1:     jsdouble utctime;
    1: 
    1:     if (!GetUTCTime(cx, obj, NULL, &utctime) || JSDOUBLE_IS_NaN(utctime))
    1:         return 0;
    1: 
    1:     return (int) SecFromTime(utctime);
    1: }
    1: 
    1: JS_FRIEND_API(jsdouble)
    1: js_DateGetMsecSinceEpoch(JSContext *cx, JSObject *obj)
    1: {
    1:     jsdouble utctime;
    1:     if (!GetUTCTime(cx, obj, NULL, &utctime))
    1:         return 0;
    1:     return utctime;
    1: }
25087: 
25087: #ifdef JS_THREADSAFE
25087: #include "prinrval.h"
25087: 
28090: JS_FRIEND_API(uint32)
25087: js_IntervalNow()
25087: {
25087:     return uint32(PR_IntervalToMilliseconds(PR_IntervalNow()));
25087: }
25087: 
25087: #else /* !JS_THREADSAFE */
25087: 
28090: JS_FRIEND_API(uint32)
25087: js_IntervalNow()
25087: {
25087:     return uint32(PRMJ_Now() / PRMJ_USEC_PER_MSEC);
25087: }
25087: #endif
