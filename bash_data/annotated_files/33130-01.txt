29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JavaScript iterators.
    1:  */
    1: #include <string.h>     /* for memcpy */
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsutil.h"
    1: #include "jsarena.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jsbool.h"
28089: #include "jsbuiltins.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsexn.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jsiter.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
 3164: #include "jsscan.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
24499: #include "jsstaticcheck.h"
24499: #include "jstracer.h"
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: #include "jsxml.h"
    1: #endif
    1: 
31452: JS_STATIC_ASSERT(JSSLOT_ITER_FLAGS < JS_INITIAL_NSLOTS);
    1: 
 3436: #if JS_HAS_GENERATORS
 3436: 
24499: static JS_REQUIRES_STACK JSBool
 3436: CloseGenerator(JSContext *cx, JSObject *genobj);
 3436: 
 3436: #endif
 3436: 
    1: /*
    1:  * Shared code to close iterator's state either through an explicit call or
    1:  * when GC detects that the iterator is no longer reachable.
    1:  */
    1: void
 3025: js_CloseNativeIterator(JSContext *cx, JSObject *iterobj)
    1: {
    1:     jsval state;
    1:     JSObject *iterable;
    1: 
 3025:     JS_ASSERT(STOBJ_GET_CLASS(iterobj) == &js_IteratorClass);
    1: 
    1:     /* Avoid double work if js_CloseNativeIterator was called on obj. */
    1:     state = STOBJ_GET_SLOT(iterobj, JSSLOT_ITER_STATE);
    1:     if (JSVAL_IS_NULL(state))
    1:         return;
    1: 
    1:     /* Protect against failure to fully initialize obj. */
33128:     iterable = iterobj->getParent();
    1:     if (iterable) {
    1: #if JS_HAS_XML_SUPPORT
    1:         uintN flags = JSVAL_TO_INT(STOBJ_GET_SLOT(iterobj, JSSLOT_ITER_FLAGS));
    1:         if ((flags & JSITER_FOREACH) && OBJECT_IS_XML(cx, iterable)) {
26187:             js_EnumerateXMLValues(cx, iterable, JSENUMERATE_DESTROY, &state,
    1:                                   NULL, NULL);
    1:         } else
    1: #endif
31501:             iterable->enumerate(cx, JSENUMERATE_DESTROY, &state, NULL);
    1:     }
    1:     STOBJ_SET_SLOT(iterobj, JSSLOT_ITER_STATE, JSVAL_NULL);
    1: }
    1: 
33128: static void
33128: iterator_trace(JSTracer *trc, JSObject *obj)
33128: {
33128:     /*
33128:      * The GC marks iter_state during the normal slot scanning if
33128:      * JSVAL_IS_TRACEABLE(iter_state) is true duplicating the efforts of
33128:      * js_MarkEnumeratorState. But this is rare so we optimize for code
33128:      * simplicity.
33128:      */
33128:     JSObject *iterable = obj->getParent();
33130:     if (!iterable) {
33130:         /* for (x in null) creates an iterator object with a null parent. */
33130:         return;
33130:     }
33128:     jsval iter_state = obj->fslots[JSSLOT_ITER_STATE];
33128:     js_MarkEnumeratorState(trc, iterable, iter_state);
33128: }
33128: 
    1: JSClass js_IteratorClass = {
    1:     "Iterator",
    1:     JSCLASS_HAS_RESERVED_SLOTS(2) | /* slots for state and flags */
33128:     JSCLASS_HAS_CACHED_PROTO(JSProto_Iterator) |
33128:     JSCLASS_MARK_IS_TRACE,
    1:     JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,
30654:     JS_EnumerateStub, JS_ResolveStub,   JS_ConvertStub,   NULL,
33128:     NULL,             NULL,            NULL,            NULL,
33128:     NULL,             NULL,            JS_CLASS_TRACE(iterator_trace), NULL
    1: };
    1: 
    1: static JSBool
    1: InitNativeIterator(JSContext *cx, JSObject *iterobj, JSObject *obj, uintN flags)
    1: {
    1:     jsval state;
    1:     JSBool ok;
    1: 
    1:     JS_ASSERT(STOBJ_GET_CLASS(iterobj) == &js_IteratorClass);
    1: 
    1:     /* Initialize iterobj in case of enumerate hook failure. */
    1:     STOBJ_SET_PARENT(iterobj, obj);
    1:     STOBJ_SET_SLOT(iterobj, JSSLOT_ITER_STATE, JSVAL_NULL);
    1:     STOBJ_SET_SLOT(iterobj, JSSLOT_ITER_FLAGS, INT_TO_JSVAL(flags));
    1:     if (!js_RegisterCloseableIterator(cx, iterobj))
    1:         return JS_FALSE;
    1:     if (!obj)
    1:         return JS_TRUE;
    1: 
    1:     ok =
    1: #if JS_HAS_XML_SUPPORT
    1:          ((flags & JSITER_FOREACH) && OBJECT_IS_XML(cx, obj))
26187:          ? js_EnumerateXMLValues(cx, obj, JSENUMERATE_INIT, &state, NULL, NULL)
    1:          :
    1: #endif
31501:            obj->enumerate(cx, JSENUMERATE_INIT, &state, NULL);
    1:     if (!ok)
    1:         return JS_FALSE;
    1: 
    1:     STOBJ_SET_SLOT(iterobj, JSSLOT_ITER_STATE, state);
    1:     if (flags & JSITER_ENUMERATE) {
    1:         /*
    1:          * The enumerating iterator needs the original object to suppress
    1:          * enumeration of deleted or shadowed prototype properties. Since the
    1:          * enumerator never escapes to scripts, we use the prototype slot to
    1:          * store the original object.
    1:          */
    1:         JS_ASSERT(obj != iterobj);
    1:         STOBJ_SET_PROTO(iterobj, obj);
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: Iterator(JSContext *cx, JSObject *iterobj, uintN argc, jsval *argv, jsval *rval)
    1: {
    1:     JSBool keyonly;
    1:     uintN flags;
    1:     JSObject *obj;
    1: 
10449:     keyonly = js_ValueToBoolean(argv[1]);
    1:     flags = keyonly ? 0 : JSITER_FOREACH;
    1: 
22652:     if (JS_IsConstructing(cx)) {
    1:         /* XXX work around old valueOf call hidden beneath js_ValueToObject */
    1:         if (!JSVAL_IS_PRIMITIVE(argv[0])) {
    1:             obj = JSVAL_TO_OBJECT(argv[0]);
    1:         } else {
    1:             obj = js_ValueToNonNullObject(cx, argv[0]);
    1:             if (!obj)
    1:                 return JS_FALSE;
    1:             argv[0] = OBJECT_TO_JSVAL(obj);
    1:         }
    1:         return InitNativeIterator(cx, iterobj, obj, flags);
    1:     }
    1: 
    1:     *rval = argv[0];
    1:     return js_ValueToIterator(cx, flags, rval);
    1: }
    1: 
    1: static JSBool
    1: NewKeyValuePair(JSContext *cx, jsid key, jsval val, jsval *rval)
    1: {
    1:     jsval vec[2];
    1:     JSTempValueRooter tvr;
    1:     JSObject *aobj;
    1: 
    1:     vec[0] = ID_TO_VALUE(key);
    1:     vec[1] = val;
    1: 
    1:     JS_PUSH_TEMP_ROOT(cx, 2, vec, &tvr);
    1:     aobj = js_NewArrayObject(cx, 2, vec);
    1:     *rval = OBJECT_TO_JSVAL(aobj);
    1:     JS_POP_TEMP_ROOT(cx, &tvr);
    1: 
    1:     return aobj != NULL;
    1: }
    1: 
    1: static JSBool
    1: IteratorNextImpl(JSContext *cx, JSObject *obj, jsval *rval)
    1: {
    1:     JSObject *iterable;
    1:     jsval state;
    1:     uintN flags;
    1:     JSBool foreach, ok;
    1:     jsid id;
    1: 
    1:     JS_ASSERT(OBJ_GET_CLASS(cx, obj) == &js_IteratorClass);
    1: 
    1:     iterable = OBJ_GET_PARENT(cx, obj);
    1:     JS_ASSERT(iterable);
17899:     state = STOBJ_GET_SLOT(obj, JSSLOT_ITER_STATE);
    1:     if (JSVAL_IS_NULL(state))
    1:         goto stop;
    1: 
17899:     flags = JSVAL_TO_INT(STOBJ_GET_SLOT(obj, JSSLOT_ITER_FLAGS));
    1:     JS_ASSERT(!(flags & JSITER_ENUMERATE));
    1:     foreach = (flags & JSITER_FOREACH) != 0;
    1:     ok =
    1: #if JS_HAS_XML_SUPPORT
    1:          (foreach && OBJECT_IS_XML(cx, iterable))
26187:          ? js_EnumerateXMLValues(cx, iterable, JSENUMERATE_NEXT, &state,
    1:                                  &id, rval)
    1:          :
    1: #endif
31501:            iterable->enumerate(cx, JSENUMERATE_NEXT, &state, &id);
    1:     if (!ok)
    1:         return JS_FALSE;
    1: 
11377:     STOBJ_SET_SLOT(obj, JSSLOT_ITER_STATE, state);
    1:     if (JSVAL_IS_NULL(state))
    1:         goto stop;
    1: 
    1:     if (foreach) {
    1: #if JS_HAS_XML_SUPPORT
    1:         if (!OBJECT_IS_XML(cx, iterable) &&
31501:             !iterable->getProperty(cx, id, rval)) {
    1:             return JS_FALSE;
    1:         }
    1: #endif
    1:         if (!NewKeyValuePair(cx, id, *rval, rval))
    1:             return JS_FALSE;
    1:     } else {
    1:         *rval = ID_TO_VALUE(id);
    1:     }
    1:     return JS_TRUE;
    1: 
    1:   stop:
17899:     JS_ASSERT(STOBJ_GET_SLOT(obj, JSSLOT_ITER_STATE) == JSVAL_NULL);
    1:     *rval = JSVAL_HOLE;
    1:     return JS_TRUE;
    1: }
    1: 
 6464: JSBool
 6464: js_ThrowStopIteration(JSContext *cx)
    1: {
    1:     jsval v;
    1: 
    1:     JS_ASSERT(!JS_IsExceptionPending(cx));
    1:     if (js_FindClassObject(cx, NULL, INT_TO_JSID(JSProto_StopIteration), &v))
    1:         JS_SetPendingException(cx, v);
    1:     return JS_FALSE;
    1: }
    1: 
    1: static JSBool
 4127: iterator_next(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     JSObject *obj;
 4127: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
 4127:     if (!JS_InstanceOf(cx, obj, &js_IteratorClass, vp + 2))
    1:         return JS_FALSE;
    1: 
 4127:     if (!IteratorNextImpl(cx, obj, vp))
    1:         return JS_FALSE;
    1: 
 4127:     if (*vp == JSVAL_HOLE) {
 4127:         *vp = JSVAL_NULL;
 6464:         js_ThrowStopIteration(cx);
    1:         return JS_FALSE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: iterator_self(JSContext *cx, uintN argc, jsval *vp)
    1: {
11809:     *vp = JS_THIS(cx, vp);
11809:     return !JSVAL_IS_NULL(*vp);
    1: }
    1: 
 4127: #define JSPROP_ROPERM   (JSPROP_READONLY | JSPROP_PERMANENT)
 4127: 
    1: static JSFunctionSpec iterator_methods[] = {
16519:     JS_FN(js_iterator_str,  iterator_self,  0,JSPROP_ROPERM),
16519:     JS_FN(js_next_str,      iterator_next,  0,JSPROP_ROPERM),
 4127:     JS_FS_END
    1: };
    1: 
    1: uintN
    1: js_GetNativeIteratorFlags(JSContext *cx, JSObject *iterobj)
    1: {
    1:     if (OBJ_GET_CLASS(cx, iterobj) != &js_IteratorClass)
    1:         return 0;
17899:     return JSVAL_TO_INT(STOBJ_GET_SLOT(iterobj, JSSLOT_ITER_FLAGS));
    1: }
    1: 
    1: /*
    1:  * Call ToObject(v).__iterator__(keyonly) if ToObject(v).__iterator__ exists.
11835:  * Otherwise construct the default iterator.
    1:  */
 9695: JS_FRIEND_API(JSBool)
    1: js_ValueToIterator(JSContext *cx, uintN flags, jsval *vp)
    1: {
    1:     JSObject *obj;
    1:     JSTempValueRooter tvr;
    1:     JSAtom *atom;
 5899:     JSClass *clasp;
 5899:     JSExtendedClass *xclasp;
    1:     JSBool ok;
    1:     JSObject *iterobj;
    1:     jsval arg;
    1: 
    1:     JS_ASSERT(!(flags & ~(JSITER_ENUMERATE |
    1:                           JSITER_FOREACH |
    1:                           JSITER_KEYVALUE)));
    1: 
    1:     /* JSITER_KEYVALUE must always come with JSITER_FOREACH */
    1:     JS_ASSERT(!(flags & JSITER_KEYVALUE) || (flags & JSITER_FOREACH));
    1: 
    1:     /* XXX work around old valueOf call hidden beneath js_ValueToObject */
    1:     if (!JSVAL_IS_PRIMITIVE(*vp)) {
    1:         obj = JSVAL_TO_OBJECT(*vp);
    1:     } else {
    1:         /*
    1:          * Enumerating over null and undefined gives an empty enumerator.
    1:          * This is contrary to ECMA-262 9.9 ToObject, invoked from step 3 of
    1:          * the first production in 12.6.4 and step 4 of the second production,
    1:          * but it's "web JS" compatible.
    1:          */
    1:         if ((flags & JSITER_ENUMERATE)) {
    1:             if (!js_ValueToObject(cx, *vp, &obj))
    1:                 return JS_FALSE;
    1:             if (!obj)
    1:                 goto default_iter;
    1:         } else {
    1:             obj = js_ValueToNonNullObject(cx, *vp);
    1:             if (!obj)
    1:                 return JS_FALSE;
    1:         }
    1:     }
    1: 
    1:     JS_ASSERT(obj);
    1:     JS_PUSH_TEMP_ROOT_OBJECT(cx, obj, &tvr);
    1: 
 5899:     clasp = OBJ_GET_CLASS(cx, obj);
 5899:     if ((clasp->flags & JSCLASS_IS_EXTENDED) &&
 5899:         (xclasp = (JSExtendedClass *) clasp)->iteratorObject) {
 5899:         iterobj = xclasp->iteratorObject(cx, obj, !(flags & JSITER_FOREACH));
 5899:         if (!iterobj)
 5899:             goto bad;
 5899:         *vp = OBJECT_TO_JSVAL(iterobj);
 5899:     } else {
    1:         atom = cx->runtime->atomState.iteratorAtom;
32658:         if (!js_GetMethod(cx, obj, ATOM_TO_JSID(atom), JSGET_NO_METHOD_BARRIER, vp))
    1:             goto bad;
    1:         if (JSVAL_IS_VOID(*vp)) {
    1:           default_iter:
    1:             /*
    1:              * Fail over to the default enumerating native iterator.
    1:              *
 5899:              * Create iterobj with a NULL parent to ensure that we use the
 5899:              * correct scope chain to lookup the iterator's constructor. Since
 5899:              * we use the parent slot to keep track of the iterable, we must
 5899:              * fix it up after.
    1:              */
30439:             iterobj = js_NewObject(cx, &js_IteratorClass, NULL, NULL);
    1:             if (!iterobj)
    1:                 goto bad;
    1: 
 5899:             /* Store in *vp to protect it from GC (callers must root vp). */
    1:             *vp = OBJECT_TO_JSVAL(iterobj);
    1: 
    1:             if (!InitNativeIterator(cx, iterobj, obj, flags))
    1:                 goto bad;
    1:         } else {
24499:             js_LeaveTrace(cx);
    1:             arg = BOOLEAN_TO_JSVAL((flags & JSITER_FOREACH) == 0);
 5899:             if (!js_InternalInvoke(cx, obj, *vp, JSINVOKE_ITERATOR, 1, &arg,
 5899:                                    vp)) {
    1:                 goto bad;
 5899:             }
    1:             if (JSVAL_IS_PRIMITIVE(*vp)) {
24873:                 js_ReportValueError(cx, JSMSG_BAD_ITERATOR_RETURN,
24873:                                     JSDVG_SEARCH_STACK, *vp, NULL);
    1:                 goto bad;
    1:             }
    1:         }
 5899:     }
    1: 
    1:     ok = JS_TRUE;
    1:   out:
    1:     if (obj)
    1:         JS_POP_TEMP_ROOT(cx, &tvr);
    1:     return ok;
    1:   bad:
    1:     ok = JS_FALSE;
    1:     goto out;
    1: }
    1: 
20408: JS_FRIEND_API(JSBool) JS_FASTCALL
 3025: js_CloseIterator(JSContext *cx, jsval v)
 3025: {
 3025:     JSObject *obj;
 3025:     JSClass *clasp;
 3025: 
 3025:     JS_ASSERT(!JSVAL_IS_PRIMITIVE(v));
 3025:     obj = JSVAL_TO_OBJECT(v);
 3025:     clasp = OBJ_GET_CLASS(cx, obj);
 3025: 
 3025:     if (clasp == &js_IteratorClass) {
 3025:         js_CloseNativeIterator(cx, obj);
 3025:     }
 3025: #if JS_HAS_GENERATORS
 3025:     else if (clasp == &js_GeneratorClass) {
24499:         JS_ASSERT_NOT_ON_TRACE(cx);
 3436:         if (!CloseGenerator(cx, obj))
 3025:             return JS_FALSE;
 3025:     }
 3025: #endif
 3025:     return JS_TRUE;
 3025: }
28088: JS_DEFINE_CALLINFO_2(FRIEND, BOOL, js_CloseIterator, CONTEXT, JSVAL, 0, 0)
 3025: 
    1: static JSBool
    1: CallEnumeratorNext(JSContext *cx, JSObject *iterobj, uintN flags, jsval *rval)
    1: {
    1:     JSObject *obj, *origobj;
    1:     jsval state;
    1:     JSBool foreach;
    1:     jsid id;
    1:     JSObject *obj2;
    1:     JSBool cond;
    1:     JSClass *clasp;
    1:     JSExtendedClass *xclasp;
    1:     JSProperty *prop;
    1:     JSString *str;
    1: 
    1:     JS_ASSERT(flags & JSITER_ENUMERATE);
    1:     JS_ASSERT(STOBJ_GET_CLASS(iterobj) == &js_IteratorClass);
    1: 
    1:     obj = STOBJ_GET_PARENT(iterobj);
    1:     origobj = STOBJ_GET_PROTO(iterobj);
    1:     state = STOBJ_GET_SLOT(iterobj, JSSLOT_ITER_STATE);
    1:     if (JSVAL_IS_NULL(state))
    1:         goto stop;
    1: 
    1:     foreach = (flags & JSITER_FOREACH) != 0;
    1: #if JS_HAS_XML_SUPPORT
    1:     /*
    1:      * Treat an XML object specially only when it starts the prototype chain.
    1:      * Otherwise we need to do the usual deleted and shadowed property checks.
    1:      */
    1:     if (obj == origobj && OBJECT_IS_XML(cx, obj)) {
    1:         if (foreach) {
26187:             if (!js_EnumerateXMLValues(cx, obj, JSENUMERATE_NEXT, &state,
    1:                                        &id, rval)) {
    1:                 return JS_FALSE;
    1:             }
    1:         } else {
31501:             if (!obj->enumerate(cx, JSENUMERATE_NEXT, &state, &id))
    1:                 return JS_FALSE;
    1:         }
    1:         STOBJ_SET_SLOT(iterobj, JSSLOT_ITER_STATE, state);
    1:         if (JSVAL_IS_NULL(state))
    1:             goto stop;
    1:     } else
    1: #endif
    1:     {
    1:       restart:
31501:         if (!obj->enumerate(cx, JSENUMERATE_NEXT, &state, &id))
11361:             return JS_FALSE;
    1: 
    1:         STOBJ_SET_SLOT(iterobj, JSSLOT_ITER_STATE, state);
    1:         if (JSVAL_IS_NULL(state)) {
    1: #if JS_HAS_XML_SUPPORT
    1:             if (OBJECT_IS_XML(cx, obj)) {
    1:                 /*
    1:                  * We just finished enumerating an XML obj that is present on
    1:                  * the prototype chain of a non-XML origobj. Stop further
    1:                  * prototype chain searches because XML objects don't
    1:                  * enumerate prototypes.
    1:                  */
    1:                 JS_ASSERT(origobj != obj);
    1:                 JS_ASSERT(!OBJECT_IS_XML(cx, origobj));
    1:             } else
    1: #endif
    1:             {
    1:                 obj = OBJ_GET_PROTO(cx, obj);
    1:                 if (obj) {
    1:                     STOBJ_SET_PARENT(iterobj, obj);
31501:                     if (!obj->enumerate(cx, JSENUMERATE_INIT, &state, NULL))
    1:                         return JS_FALSE;
    1:                     STOBJ_SET_SLOT(iterobj, JSSLOT_ITER_STATE, state);
    1:                     if (!JSVAL_IS_NULL(state))
    1:                         goto restart;
    1:                 }
    1:             }
    1:             goto stop;
    1:         }
    1: 
    1:         /* Skip properties not in obj when looking from origobj. */
31501:         if (!origobj->lookupProperty(cx, id, &obj2, &prop))
    1:             return JS_FALSE;
    1:         if (!prop)
    1:             goto restart;
31501:         obj2->dropProperty(cx, prop);
    1: 
    1:         /*
    1:          * If the id was found in a prototype object or an unrelated object
    1:          * (specifically, not in an inner object for obj), skip it. This step
31501:          * means that all lookupProperty implementations must return an
    1:          * object further along on the prototype chain, or else possibly an
    1:          * object returned by the JSExtendedClass.outerObject optional hook.
    1:          */
    1:         if (obj != obj2) {
    1:             cond = JS_FALSE;
    1:             clasp = OBJ_GET_CLASS(cx, obj2);
    1:             if (clasp->flags & JSCLASS_IS_EXTENDED) {
    1:                 xclasp = (JSExtendedClass *) clasp;
    1:                 cond = xclasp->outerObject &&
    1:                     xclasp->outerObject(cx, obj2) == obj;
    1:             }
    1:             if (!cond)
    1:                 goto restart;
    1:         }
    1: 
    1:         if (foreach) {
    1:             /* Get property querying the original object. */
31501:             if (!origobj->getProperty(cx, id, rval))
    1:                 return JS_FALSE;
    1:         }
    1:     }
    1: 
    1:     if (foreach) {
    1:         if (flags & JSITER_KEYVALUE) {
    1:             if (!NewKeyValuePair(cx, id, *rval, rval))
    1:                 return JS_FALSE;
    1:         }
    1:     } else {
    1:         /* Make rval a string for uniformity and compatibility. */
 4529:         str = js_ValueToString(cx, ID_TO_VALUE(id));
    1:         if (!str)
    1:             return JS_FALSE;
    1:         *rval = STRING_TO_JSVAL(str);
    1:     }
    1:     return JS_TRUE;
    1: 
    1:   stop:
    1:     JS_ASSERT(STOBJ_GET_SLOT(iterobj, JSSLOT_ITER_STATE) == JSVAL_NULL);
    1:     *rval = JSVAL_HOLE;
    1:     return JS_TRUE;
    1: }
    1: 
 9695: JS_FRIEND_API(JSBool)
    1: js_CallIteratorNext(JSContext *cx, JSObject *iterobj, jsval *rval)
    1: {
    1:     uintN flags;
    1: 
    1:     /* Fast path for native iterators */
    1:     if (OBJ_GET_CLASS(cx, iterobj) == &js_IteratorClass) {
17899:         flags = JSVAL_TO_INT(STOBJ_GET_SLOT(iterobj, JSSLOT_ITER_FLAGS));
    1:         if (flags & JSITER_ENUMERATE)
    1:             return CallEnumeratorNext(cx, iterobj, flags, rval);
    1: 
    1:         /*
    1:          * Call next directly as all the methods of the native iterator are
    1:          * read-only and permanent.
    1:          */
    1:         if (!IteratorNextImpl(cx, iterobj, rval))
    1:             return JS_FALSE;
    1:     } else {
    1:         jsid id = ATOM_TO_JSID(cx->runtime->atomState.nextAtom);
    1: 
    1:         if (!JS_GetMethodById(cx, iterobj, id, &iterobj, rval))
    1:             return JS_FALSE;
    1:         if (!js_InternalCall(cx, iterobj, *rval, 0, NULL, rval)) {
    1:             /* Check for StopIteration. */
21685:             if (!cx->throwing || !js_ValueIsStopIteration(cx->exception))
    1:                 return JS_FALSE;
    1: 
    1:             /* Inline JS_ClearPendingException(cx). */
    1:             cx->throwing = JS_FALSE;
    1:             cx->exception = JSVAL_VOID;
    1:             *rval = JSVAL_HOLE;
    1:             return JS_TRUE;
    1:         }
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: stopiter_hasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
    1: {
21685:     *bp = js_ValueIsStopIteration(v);
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSClass js_StopIterationClass = {
    1:     js_StopIteration_str,
    1:     JSCLASS_HAS_CACHED_PROTO(JSProto_StopIteration),
    1:     JS_PropertyStub,  JS_PropertyStub,
    1:     JS_PropertyStub,  JS_PropertyStub,
    1:     JS_EnumerateStub, JS_ResolveStub,
30654:     JS_ConvertStub,   NULL,
    1:     NULL,             NULL,
    1:     NULL,             NULL,
    1:     NULL,             stopiter_hasInstance,
    1:     NULL,             NULL
    1: };
    1: 
    1: #if JS_HAS_GENERATORS
    1: 
    1: static void
    1: generator_finalize(JSContext *cx, JSObject *obj)
    1: {
31452:     JSGenerator *gen = (JSGenerator *) obj->getPrivate();
31452:     if (!gen)
31452:         return;
    1: 
    1:     /*
31452:      * gen is open when a script has not called its close method while
31452:      * explicitly manipulating it.
    1:      */
31452:     JS_ASSERT(gen->state == JSGEN_NEWBORN ||
31452:               gen->state == JSGEN_CLOSED ||
    1:               gen->state == JSGEN_OPEN);
30851:     cx->free(gen);
    1: }
    1: 
  583: static void
  583: generator_trace(JSTracer *trc, JSObject *obj)
    1: {
31452:     JSGenerator *gen = (JSGenerator *) obj->getPrivate();
 4282:     if (!gen)
 4282:         return;
 4282: 
    1:     /*
 4282:      * js_TraceStackFrame does not recursively trace the down-linked frame
 4282:      * chain, so we insist that gen->frame has no parent to trace when the
 4282:      * generator is not running.
    1:      */
 4282:     JS_ASSERT_IF(gen->state != JSGEN_RUNNING && gen->state != JSGEN_CLOSING,
 4282:                  !gen->frame.down);
 4282: 
 4282:     /*
 4282:      * FIXME be 390950. Generator's frame is a part of the JS stack when the
 4282:      * generator is running or closing. Thus tracing the frame in this case
 4282:      * here duplicates the work done in js_TraceContext.
 4282:      */
  583:     js_TraceStackFrame(trc, &gen->frame);
    1: }
    1: 
27012: JS_FRIEND_DATA(JSClass) js_GeneratorClass = {
    1:     js_Generator_str,
    1:     JSCLASS_HAS_PRIVATE | JSCLASS_IS_ANONYMOUS |
  583:     JSCLASS_MARK_IS_TRACE | JSCLASS_HAS_CACHED_PROTO(JSProto_Generator),
    1:     JS_PropertyStub,  JS_PropertyStub, JS_PropertyStub, JS_PropertyStub,
    1:     JS_EnumerateStub, JS_ResolveStub,  JS_ConvertStub,  generator_finalize,
    1:     NULL,             NULL,            NULL,            NULL,
  583:     NULL,             NULL,            JS_CLASS_TRACE(generator_trace), NULL
    1: };
    1: 
    1: /*
    1:  * Called from the JSOP_GENERATOR case in the interpreter, with fp referring
    1:  * to the frame by which the generator function was activated.  Create a new
    1:  * JSGenerator object, which contains its own JSStackFrame that we populate
    1:  * from *fp.  We know that upon return, the JSOP_GENERATOR opcode will return
    1:  * from the activation in fp, so we can steal away fp->callobj and fp->argsobj
    1:  * if they are non-null.
    1:  */
    1: JSObject *
    1: js_NewGenerator(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     JSObject *obj;
21685:     uintN argc, nargs, nslots;
    1:     JSGenerator *gen;
16072:     jsval *slots;
    1: 
30439:     obj = js_NewObject(cx, &js_GeneratorClass, NULL, NULL);
    1:     if (!obj)
    1:         return NULL;
    1: 
    1:     /* Load and compute stack slot counts. */
    1:     argc = fp->argc;
    1:     nargs = JS_MAX(argc, fp->fun->nargs);
16072:     nslots = 2 + nargs + fp->script->nslots;
    1: 
    1:     /* Allocate obj's private data struct. */
    1:     gen = (JSGenerator *)
30851:         cx->malloc(sizeof(JSGenerator) + (nslots - 1) * sizeof(jsval));
    1:     if (!gen)
31452:         return NULL;
    1: 
    1:     gen->obj = obj;
    1: 
    1:     /* Steal away objects reflecting fp and point them at gen->frame. */
    1:     gen->frame.callobj = fp->callobj;
    1:     if (fp->callobj) {
31452:         fp->callobj->setPrivate(&gen->frame);
    1:         fp->callobj = NULL;
    1:     }
    1:     gen->frame.argsobj = fp->argsobj;
    1:     if (fp->argsobj) {
31452:         JSVAL_TO_OBJECT(fp->argsobj)->setPrivate(&gen->frame);
    1:         fp->argsobj = NULL;
    1:     }
    1: 
    1:     /* These two references can be shared with fp until it goes away. */
    1:     gen->frame.varobj = fp->varobj;
32774:     gen->frame.thisv = fp->thisv;
    1: 
    1:     /* Copy call-invariant script and function references. */
    1:     gen->frame.script = fp->script;
    1:     gen->frame.fun = fp->fun;
    1: 
16072:     /* Use slots to carve space out of gen->slots. */
16072:     slots = gen->slots;
    1:     gen->arena.next = NULL;
16072:     gen->arena.base = (jsuword) slots;
16072:     gen->arena.limit = gen->arena.avail = (jsuword) (slots + nslots);
    1: 
16072:     /* Copy rval, argv and vars. */
    1:     gen->frame.rval = fp->rval;
16072:     memcpy(slots, fp->argv - 2, (2 + nargs) * sizeof(jsval));
16072:     gen->frame.argc = nargs;
16072:     gen->frame.argv = slots + 2;
16072:     slots += 2 + nargs;
16072:     memcpy(slots, fp->slots, fp->script->nfixed * sizeof(jsval));
    1: 
    1:     /* Initialize or copy virtual machine state. */
    1:     gen->frame.down = NULL;
    1:     gen->frame.annotation = NULL;
    1:     gen->frame.scopeChain = fp->scopeChain;
    1: 
21685:     gen->frame.imacpc = NULL;
16072:     gen->frame.slots = slots;
16072:     JS_ASSERT(StackBase(fp) == fp->regs->sp);
16072:     gen->savedRegs.sp = slots + fp->script->nfixed;
13168:     gen->savedRegs.pc = fp->regs->pc;
13168:     gen->frame.regs = &gen->savedRegs;
    1: 
 6040:     gen->frame.flags = (fp->flags & ~JSFRAME_ROOTED_ARGV) | JSFRAME_GENERATOR;
    1:     gen->frame.dormantNext = NULL;
32729: 
26238:     /* JSOP_GENERATOR appears in the prologue, outside all blocks.  */
26238:     JS_ASSERT(!fp->blockChain);
    1:     gen->frame.blockChain = NULL;
    1: 
    1:     /* Note that gen is newborn. */
    1:     gen->state = JSGEN_NEWBORN;
    1: 
31452:     obj->setPrivate(gen);
    1:     return obj;
    1: }
    1: 
    1: typedef enum JSGeneratorOp {
    1:     JSGENOP_NEXT,
    1:     JSGENOP_SEND,
    1:     JSGENOP_THROW,
    1:     JSGENOP_CLOSE
    1: } JSGeneratorOp;
    1: 
    1: /*
    1:  * Start newborn or restart yielding generator and perform the requested
    1:  * operation inside its frame.
    1:  */
24499: static JS_REQUIRES_STACK JSBool
    1: SendToGenerator(JSContext *cx, JSGeneratorOp op, JSObject *obj,
12688:                 JSGenerator *gen, jsval arg)
    1: {
    1:     JSStackFrame *fp;
    1:     JSArena *arena;
    1:     JSBool ok;
    1: 
 3554:     if (gen->state == JSGEN_RUNNING || gen->state == JSGEN_CLOSING) {
 3554:         js_ReportValueError(cx, JSMSG_NESTING_GENERATOR,
 3554:                             JSDVG_SEARCH_STACK, OBJECT_TO_JSVAL(obj),
 3554:                             JS_GetFunctionId(gen->frame.fun));
 3554:         return JS_FALSE;
 3554:     }
 3554: 
    1:     JS_ASSERT(gen->state ==  JSGEN_NEWBORN || gen->state == JSGEN_OPEN);
    1:     switch (op) {
    1:       case JSGENOP_NEXT:
    1:       case JSGENOP_SEND:
    1:         if (gen->state == JSGEN_OPEN) {
    1:             /*
    1:              * Store the argument to send as the result of the yield
    1:              * expression.
    1:              */
13168:             gen->savedRegs.sp[-1] = arg;
    1:         }
    1:         gen->state = JSGEN_RUNNING;
    1:         break;
    1: 
    1:       case JSGENOP_THROW:
    1:         JS_SetPendingException(cx, arg);
    1:         gen->state = JSGEN_RUNNING;
    1:         break;
    1: 
    1:       default:
    1:         JS_ASSERT(op == JSGENOP_CLOSE);
    1:         JS_SetPendingException(cx, JSVAL_ARETURN);
    1:         gen->state = JSGEN_CLOSING;
    1:         break;
    1:     }
    1: 
    1:     /* Extend the current stack pool with gen->arena. */
    1:     arena = cx->stackPool.current;
    1:     JS_ASSERT(!arena->next);
    1:     JS_ASSERT(!gen->arena.next);
    1:     JS_ASSERT(cx->stackPool.current != &gen->arena);
    1:     cx->stackPool.current = arena->next = &gen->arena;
    1: 
    1:     /* Push gen->frame around the interpreter activation. */
22652:     fp = js_GetTopStackFrame(cx);
    1:     cx->fp = &gen->frame;
    1:     gen->frame.down = fp;
12688:     ok = js_Interpret(cx);
    1:     cx->fp = fp;
    1:     gen->frame.down = NULL;
    1: 
    1:     /* Retract the stack pool and sanitize gen->arena. */
    1:     JS_ASSERT(!gen->arena.next);
    1:     JS_ASSERT(arena->next == &gen->arena);
    1:     JS_ASSERT(cx->stackPool.current == &gen->arena);
    1:     cx->stackPool.current = arena;
    1:     arena->next = NULL;
    1: 
    1:     if (gen->frame.flags & JSFRAME_YIELDING) {
    1:         /* Yield cannot fail, throw or be called on closing. */
    1:         JS_ASSERT(ok);
    1:         JS_ASSERT(!cx->throwing);
    1:         JS_ASSERT(gen->state == JSGEN_RUNNING);
    1:         JS_ASSERT(op != JSGENOP_CLOSE);
    1:         gen->frame.flags &= ~JSFRAME_YIELDING;
    1:         gen->state = JSGEN_OPEN;
    1:         return JS_TRUE;
    1:     }
    1: 
12688:     gen->frame.rval = JSVAL_VOID;
    1:     gen->state = JSGEN_CLOSED;
    1:     if (ok) {
    1:         /* Returned, explicitly or by falling off the end. */
    1:         if (op == JSGENOP_CLOSE)
    1:             return JS_TRUE;
 6464:         return js_ThrowStopIteration(cx);
    1:     }
    1: 
    1:     /*
 9780:      * An error, silent termination by operation callback or an exception.
    1:      * Propagate the condition to the caller.
    1:      */
    1:     return JS_FALSE;
    1: }
    1: 
24499: static JS_REQUIRES_STACK JSBool
 3436: CloseGenerator(JSContext *cx, JSObject *obj)
    1: {
31452:     JS_ASSERT(STOBJ_GET_CLASS(obj) == &js_GeneratorClass);
 3025: 
31452:     JSGenerator *gen = (JSGenerator *) obj->getPrivate();
 3025:     if (!gen) {
 3025:         /* Generator prototype object. */
 3025:         return JS_TRUE;
 3025:     }
 3025: 
 3025:     if (gen->state == JSGEN_CLOSED)
 3025:         return JS_TRUE;
 3025: 
12688:     return SendToGenerator(cx, JSGENOP_CLOSE, obj, gen, JSVAL_VOID);
    1: }
    1: 
    1: /*
    1:  * Common subroutine of generator_(next|send|throw|close) methods.
    1:  */
    1: static JSBool
16519: generator_op(JSContext *cx, JSGeneratorOp op, jsval *vp, uintN argc)
    1: {
 4127:     JSObject *obj;
    1:     jsval arg;
    1: 
24499:     js_LeaveTrace(cx);
24499: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
 4127:     if (!JS_InstanceOf(cx, obj, &js_GeneratorClass, vp + 2))
    1:         return JS_FALSE;
    1: 
31452:     JSGenerator *gen = (JSGenerator *) obj->getPrivate();
31452:     if (!gen) {
    1:         /* This happens when obj is the generator prototype. See bug 352885. */
    1:         goto closed_generator;
    1:     }
    1: 
 3554:     if (gen->state == JSGEN_NEWBORN) {
    1:         switch (op) {
    1:           case JSGENOP_NEXT:
    1:           case JSGENOP_THROW:
    1:             break;
    1: 
    1:           case JSGENOP_SEND:
16519:             if (argc >= 1 && !JSVAL_IS_VOID(vp[2])) {
    1:                 js_ReportValueError(cx, JSMSG_BAD_GENERATOR_SEND,
 4127:                                     JSDVG_SEARCH_STACK, vp[2], NULL);
    1:                 return JS_FALSE;
    1:             }
    1:             break;
    1: 
    1:           default:
    1:             JS_ASSERT(op == JSGENOP_CLOSE);
    1:             gen->state = JSGEN_CLOSED;
    1:             return JS_TRUE;
    1:         }
 3554:     } else if (gen->state == JSGEN_CLOSED) {
    1:       closed_generator:
    1:         switch (op) {
    1:           case JSGENOP_NEXT:
    1:           case JSGENOP_SEND:
 6464:             return js_ThrowStopIteration(cx);
    1:           case JSGENOP_THROW:
16519:             JS_SetPendingException(cx, argc >= 1 ? vp[2] : JSVAL_VOID);
    1:             return JS_FALSE;
    1:           default:
    1:             JS_ASSERT(op == JSGENOP_CLOSE);
    1:             return JS_TRUE;
    1:         }
    1:     }
    1: 
16519:     arg = ((op == JSGENOP_SEND || op == JSGENOP_THROW) && argc != 0)
 4127:           ? vp[2]
    1:           : JSVAL_VOID;
12688:     if (!SendToGenerator(cx, op, obj, gen, arg))
    1:         return JS_FALSE;
12688:     *vp = gen->frame.rval;
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: generator_send(JSContext *cx, uintN argc, jsval *vp)
    1: {
16519:     return generator_op(cx, JSGENOP_SEND, vp, argc);
    1: }
    1: 
    1: static JSBool
 4127: generator_next(JSContext *cx, uintN argc, jsval *vp)
    1: {
16519:     return generator_op(cx, JSGENOP_NEXT, vp, argc);
    1: }
    1: 
    1: static JSBool
 4127: generator_throw(JSContext *cx, uintN argc, jsval *vp)
    1: {
16519:     return generator_op(cx, JSGENOP_THROW, vp, argc);
    1: }
    1: 
    1: static JSBool
 4127: generator_close(JSContext *cx, uintN argc, jsval *vp)
    1: {
16519:     return generator_op(cx, JSGENOP_CLOSE, vp, argc);
    1: }
    1: 
    1: static JSFunctionSpec generator_methods[] = {
16519:     JS_FN(js_iterator_str,  iterator_self,      0,JSPROP_ROPERM),
16519:     JS_FN(js_next_str,      generator_next,     0,JSPROP_ROPERM),
16519:     JS_FN(js_send_str,      generator_send,     1,JSPROP_ROPERM),
16519:     JS_FN(js_throw_str,     generator_throw,    1,JSPROP_ROPERM),
16519:     JS_FN(js_close_str,     generator_close,    0,JSPROP_ROPERM),
 4127:     JS_FS_END
    1: };
    1: 
    1: #endif /* JS_HAS_GENERATORS */
    1: 
    1: JSObject *
    1: js_InitIteratorClasses(JSContext *cx, JSObject *obj)
    1: {
    1:     JSObject *proto, *stop;
    1: 
    1:     /* Idempotency required: we initialize several things, possibly lazily. */
    1:     if (!js_GetClassObject(cx, obj, JSProto_StopIteration, &stop))
    1:         return NULL;
    1:     if (stop)
    1:         return stop;
    1: 
    1:     proto = JS_InitClass(cx, obj, NULL, &js_IteratorClass, Iterator, 2,
    1:                          NULL, iterator_methods, NULL, NULL);
    1:     if (!proto)
    1:         return NULL;
    1:     STOBJ_SET_SLOT(proto, JSSLOT_ITER_STATE, JSVAL_NULL);
31928:     STOBJ_SET_SLOT(proto, JSSLOT_ITER_FLAGS, JSVAL_ZERO);
    1: 
    1: #if JS_HAS_GENERATORS
    1:     /* Initialize the generator internals if configured. */
    1:     if (!JS_InitClass(cx, obj, NULL, &js_GeneratorClass, NULL, 0,
    1:                       NULL, generator_methods, NULL, NULL)) {
    1:         return NULL;
    1:     }
    1: #endif
    1: 
    1:     return JS_InitClass(cx, obj, NULL, &js_StopIterationClass, NULL, 0,
    1:                         NULL, NULL, NULL, NULL);
    1: }
