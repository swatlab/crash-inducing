    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
15992:  *   Rob Arnold <robarnold@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * structs that contain the data provided by nsStyleContext, the
    1:  * internal API for computed style data for an element
    1:  */
    1: 
    1: #ifndef nsStyleStruct_h___
    1: #define nsStyleStruct_h___
    1: 
    1: #include "nsColor.h"
    1: #include "nsCoord.h"
    1: #include "nsMargin.h"
    1: #include "nsRect.h"
    1: #include "nsFont.h"
 3616: #include "nsVoidArray.h"
    1: #include "nsStyleCoord.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsChangeHint.h"
    1: #include "nsPresContext.h"
    1: #include "nsIPresShell.h"
    1: #include "nsCOMPtr.h"
 3616: #include "nsCOMArray.h"
    1: #include "nsIAtom.h"
    1: #include "nsIURI.h"
    1: #include "nsCSSValue.h"
19214: #include "nsStyleTransformMatrix.h"
    1: 
    1: class nsIFrame;
    1: class imgIRequest;
    1: 
  902: // Includes nsStyleStructID.
  902: #include "nsStyleStructFwd.h"
    1: 
    1: // Bits for each struct.
 6732: // NS_STYLE_INHERIT_BIT defined in nsStyleStructFwd.h
    1: #define NS_STYLE_INHERIT_MASK             0x00ffffff
    1: 
    1: // Additional bits for nsStyleContext's mBits:
    1: // A bit to test whether or not we have any text decorations.
    1: #define NS_STYLE_HAS_TEXT_DECORATIONS     0x01000000
    1: 
    1: // Additional bits for nsRuleNode's mDependentBits:
    1: #define NS_RULE_NODE_GC_MARK              0x02000000
 1539: #define NS_RULE_NODE_IS_IMPORTANT         0x08000000
 1539: #define NS_RULE_NODE_LEVEL_MASK           0xf0000000
 1539: #define NS_RULE_NODE_LEVEL_SHIFT          28
    1: 
    1: // The lifetime of these objects is managed by the presshell's arena.
    1: 
10152: struct nsStyleFont {
10073:   nsStyleFont(const nsFont& aFont, nsPresContext *aPresContext);
    1:   nsStyleFont(const nsStyleFont& aStyleFont);
    1:   nsStyleFont(nsPresContext *aPresContext);
  731:   ~nsStyleFont(void) {}
    1: 
    1:   nsChangeHint CalcDifference(const nsStyleFont& aOther) const;
    1: #ifdef DEBUG
    1:   static nsChangeHint MaxDifference();
    1: #endif
    1:   static nsChangeHint CalcFontDifference(const nsFont& aFont1, const nsFont& aFont2);
    1: 
    1:   static nscoord ZoomText(nsPresContext* aPresContext, nscoord aSize);
    1:   static nscoord UnZoomText(nsPresContext* aPresContext, nscoord aSize);
    1: 
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW;
    1:   void Destroy(nsPresContext* aContext);
    1: 
    1:   nsFont  mFont;        // [inherited]
20260:   nscoord mSize;        // [inherited] Our "computed size". Can be different
20260:                         // from mFont.size which is our "actual size" and is
20260:                         // enforced to be >= the user's preferred min-size.
20260:                         // mFont.size should be used for display purposes
20260:                         // while mSize is the value to return in
20260:                         // getComputedStyle() for example.
20260:   PRUint8 mGenericID;   // [inherited] generic CSS font family, if any;
20260:                         // value is a kGenericFont_* constant, see nsFont.h.
10073: 
10073: #ifdef MOZ_MATHML
10073:   // MathML scriptlevel support
10073:   PRInt8  mScriptLevel;          // [inherited]
10073:   // The value mSize would have had if scriptminsize had never been applied
10073:   nscoord mScriptUnconstrainedSize;
10073:   nscoord mScriptMinSize;        // [inherited] length
10073:   float   mScriptSizeMultiplier; // [inherited]
10073: #endif
    1: };
    1: 
10152: struct nsStyleColor {
    1:   nsStyleColor(nsPresContext* aPresContext);
    1:   nsStyleColor(const nsStyleColor& aOther);
  731:   ~nsStyleColor(void) {}
    1: 
    1:   nsChangeHint CalcDifference(const nsStyleColor& aOther) const;
    1: #ifdef DEBUG
    1:   static nsChangeHint MaxDifference();
    1: #endif
    1:   
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:     return aContext->AllocateFromShell(sz);
    1:   }
    1:   void Destroy(nsPresContext* aContext) {
    1:     this->~nsStyleColor();
    1:     aContext->FreeToShell(sizeof(nsStyleColor), this);
  731:   }
    1: 
    1:   // Don't add ANY members to this struct!  We can achieve caching in the rule
    1:   // tree (rather than the style tree) by letting color stay by itself! -dwh
    1:   nscolor mColor;                 // [inherited]
    1: };
    1: 
10152: struct nsStyleBackground {
19182:   nsStyleBackground();
    1:   nsStyleBackground(const nsStyleBackground& aOther);
    1:   ~nsStyleBackground();
    1: 
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:     return aContext->AllocateFromShell(sz);
    1:   }
    1:   void Destroy(nsPresContext* aContext) {
    1:     this->~nsStyleBackground();
    1:     aContext->FreeToShell(sizeof(nsStyleBackground), this);
  731:   }
    1: 
    1:   nsChangeHint CalcDifference(const nsStyleBackground& aOther) const;
    1: #ifdef DEBUG
    1:   static nsChangeHint MaxDifference();
    1: #endif
    1: 
    1:   PRUint8 mBackgroundFlags;        // [reset] See nsStyleConsts.h
18889:   PRUint8 mBackgroundAttachment;   // [reset] See nsStyleConsts.h
18889:   PRUint8 mBackgroundClip;         // [reset] See nsStyleConsts.h
18889:   PRUint8 mBackgroundInlinePolicy; // [reset] See nsStyleConsts.h
18889:   PRUint8 mBackgroundOrigin;       // [reset] See nsStyleConsts.h
18889:   PRUint8 mBackgroundRepeat;       // [reset] See nsStyleConsts.h
    1: 
    1:   // Note: a member of this union is valid IFF the appropriate bit flag
    1:   // is set in mBackgroundFlags.
    1:   union {
    1:     nscoord mCoord;
    1:     float   mFloat;
    1:   } mBackgroundXPosition,         // [reset]
    1:     mBackgroundYPosition;         // [reset]
    1: 
    1:   nscolor mBackgroundColor;       // [reset]
    1:   nsCOMPtr<imgIRequest> mBackgroundImage; // [reset]
    1: 
19182:   // True if this background is completely transparent.
    1:   PRBool IsTransparent() const
    1:   {
19182:     return (NS_GET_A(mBackgroundColor) == 0 &&
19182:             (mBackgroundFlags & NS_STYLE_BG_IMAGE_NONE));
    1:   }
    1: 
    1:   // We have to take slower codepaths for fixed background attachment,
    1:   // but we don't want to do that when there's no image.
    1:   // Not inline because it uses an nsCOMPtr<imgIRequest>
15992:   // FIXME: Should be in nsStyleStructInlines.h.
    1:   PRBool HasFixedBackground() const;
    1: };
    1: 
19209: // See https://bugzilla.mozilla.org/show_bug.cgi?id=271586#c43 for why
19209: // this is hard to replace with 'currentColor'.
    1: #define BORDER_COLOR_FOREGROUND   0x20
    1: #define OUTLINE_COLOR_INITIAL     0x80
19182: // FOREGROUND | INITIAL(OUTLINE)
19182: #define BORDER_COLOR_SPECIAL      0xA0
    1: #define BORDER_STYLE_MASK         0x1F
    1: 
    1: #define NS_SPACING_MARGIN   0
    1: #define NS_SPACING_PADDING  1
    1: #define NS_SPACING_BORDER   2
    1: 
    1: 
10152: struct nsStyleMargin {
    1:   nsStyleMargin(void);
    1:   nsStyleMargin(const nsStyleMargin& aMargin);
  731:   ~nsStyleMargin(void) {}
    1: 
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW;
    1:   void Destroy(nsPresContext* aContext);
    1: 
    1:   void RecalcData();
    1:   nsChangeHint CalcDifference(const nsStyleMargin& aOther) const;
    1: #ifdef DEBUG
    1:   static nsChangeHint MaxDifference();
    1: #endif
    1: 
19208:   nsStyleSides  mMargin;          // [reset] coord, percent, auto
    1: 
    1:   PRBool GetMargin(nsMargin& aMargin) const
    1:   {
    1:     if (mHasCachedMargin) {
    1:       aMargin = mCachedMargin;
    1:       return PR_TRUE;
    1:     }
    1:     return PR_FALSE;
    1:   }
    1: 
    1: protected:
    1:   PRPackedBool  mHasCachedMargin;
    1:   nsMargin      mCachedMargin;
    1: };
    1: 
    1: 
10152: struct nsStylePadding {
    1:   nsStylePadding(void);
    1:   nsStylePadding(const nsStylePadding& aPadding);
  731:   ~nsStylePadding(void) {}
    1: 
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW;
    1:   void Destroy(nsPresContext* aContext);
    1: 
    1:   void RecalcData();
    1:   nsChangeHint CalcDifference(const nsStylePadding& aOther) const;
    1: #ifdef DEBUG
    1:   static nsChangeHint MaxDifference();
    1: #endif
    1:   
19208:   nsStyleSides  mPadding;         // [reset] coord, percent
    1: 
    1:   PRBool GetPadding(nsMargin& aPadding) const
    1:   {
    1:     if (mHasCachedPadding) {
    1:       aPadding = mCachedPadding;
    1:       return PR_TRUE;
    1:     }
    1:     return PR_FALSE;
    1:   }
    1: 
    1: protected:
    1:   PRPackedBool  mHasCachedPadding;
    1:   nsMargin      mCachedPadding;
    1: };
    1: 
    1: struct nsBorderColors {
    1:   nsBorderColors* mNext;
    1:   nscolor mColor;
    1: 
20563:   nsBorderColors() : mNext(nsnull), mColor(NS_RGB(0,0,0)) {}
20563:   nsBorderColors(const nscolor& aColor) : mNext(nsnull), mColor(aColor) {}
20563:   ~nsBorderColors();
    1: 
20563:   nsBorderColors* Clone() const { return Clone(PR_TRUE); }
    1: 
19182:   static PRBool Equal(const nsBorderColors* c1,
19182:                       const nsBorderColors* c2) {
19182:     if (c1 == c2)
19182:       return PR_TRUE;
    1:     while (c1 && c2) {
19182:       if (c1->mColor != c2->mColor)
    1:         return PR_FALSE;
    1:       c1 = c1->mNext;
    1:       c2 = c2->mNext;
    1:     }
19182:     // both should be NULL if these are equal, otherwise one
19182:     // has more colors than another
    1:     return !c1 && !c2;
    1:   }
20563: 
20563: private:
20563:   nsBorderColors* Clone(PRBool aDeep) const;
    1: };
    1: 
15699: struct nsCSSShadowItem {
19207:   nscoord mXOffset;
19207:   nscoord mYOffset;
19207:   nscoord mRadius;
19207:   nscoord mSpread;
15699: 
15699:   nscolor      mColor;
15699:   PRPackedBool mHasColor; // Whether mColor should be used
15699: 
15699:   nsCSSShadowItem() : mHasColor(PR_FALSE) {
15699:     MOZ_COUNT_CTOR(nsCSSShadowItem);
15699:   }
15699:   ~nsCSSShadowItem() {
15699:     MOZ_COUNT_DTOR(nsCSSShadowItem);
15699:   }
15699: 
15699:   PRBool operator==(const nsCSSShadowItem& aOther) {
15699:     return (mXOffset == aOther.mXOffset &&
15699:             mYOffset == aOther.mYOffset &&
15699:             mRadius == aOther.mRadius &&
15699:             mHasColor == aOther.mHasColor &&
15699:             mSpread == aOther.mSpread &&
15699:             (!mHasColor || mColor == aOther.mColor));
15699:   }
15699:   PRBool operator!=(const nsCSSShadowItem& aOther) {
15699:     return !(*this == aOther);
15699:   }
15699: };
15699: 
15699: class nsCSSShadowArray {
15699:   public:
15699:     void* operator new(size_t aBaseSize, PRUint32 aArrayLen) {
15699:       // We can allocate both this nsCSSShadowArray and the
15699:       // actual array in one allocation. The amount of memory to
15699:       // allocate is equal to the class's size + the number of bytes for all
15699:       // but the first array item (because aBaseSize includes one
15699:       // item, see the private declarations)
15699:       return ::operator new(aBaseSize +
15699:                             (aArrayLen - 1) * sizeof(nsCSSShadowItem));
15699:     }
15699: 
15699:     nsCSSShadowArray(PRUint32 aArrayLen) :
15699:       mLength(aArrayLen), mRefCnt(0)
15699:     {
15699:       MOZ_COUNT_CTOR(nsCSSShadowArray);
15699:       for (PRUint32 i = 1; i < mLength; ++i) {
15699:         // Make sure we call the constructors of each nsCSSShadowItem
15699:         // (the first one is called for us because we declared it under private)
15699:         new (&mArray[i]) nsCSSShadowItem();
15699:       }
15699:     }
15699:     ~nsCSSShadowArray() {
15699:       MOZ_COUNT_DTOR(nsCSSShadowArray);
15699:       for (PRUint32 i = 1; i < mLength; ++i) {
15699:         mArray[i].~nsCSSShadowItem();
15699:       }
15699:     }
15699: 
15699:     nsrefcnt AddRef() { return ++mRefCnt; }
15699:     nsrefcnt Release();
15699: 
15699:     PRUint32 Length() const { return mLength; }
15699:     nsCSSShadowItem* ShadowAt(PRUint32 i) {
15699:       NS_ABORT_IF_FALSE(i < mLength, "Accessing too high an index in the text shadow array!");
15699:       return &mArray[i];
15699:     }
15699:     const nsCSSShadowItem* ShadowAt(PRUint32 i) const {
15699:       NS_ABORT_IF_FALSE(i < mLength, "Accessing too high an index in the text shadow array!");
15699:       return &mArray[i];
15699:     }
15699: 
15699:   private:
15699:     PRUint32 mLength;
15699:     PRUint32 mRefCnt;
15699:     nsCSSShadowItem mArray[1]; // This MUST be the last item
15699: };
15699: 
13519: // Border widths are rounded to the nearest-below integer number of pixels,
13519: // but values between zero and one device pixels are always rounded up to
13519: // one device pixel.
    1: #define NS_ROUND_BORDER_TO_PIXELS(l,tpp) \
13519:   ((l) == 0) ? 0 : PR_MAX((tpp), (l) / (tpp) * (tpp))
    1: // Outline offset is rounded to the nearest integer number of pixels, but values
    1: // between zero and one device pixels are always rounded up to one device pixel.
    1: // Note that the offset can be negative.
    1: #define NS_ROUND_OFFSET_TO_PIXELS(l,tpp) \
    1:   (((l) == 0) ? 0 : \
    1:     ((l) > 0) ? PR_MAX( (tpp), ((l) + ((tpp) / 2)) / (tpp) * (tpp)) : \
    1:                 PR_MIN(-(tpp), ((l) - ((tpp) / 2)) / (tpp) * (tpp)))
    1: 
16055: // Returns if the given border style type is visible or not
16055: static PRBool IsVisibleBorderStyle(PRUint8 aStyle)
16055: {
16055:   return (aStyle != NS_STYLE_BORDER_STYLE_NONE &&
16055:           aStyle != NS_STYLE_BORDER_STYLE_HIDDEN);
16055: }
16055: 
10152: struct nsStyleBorder {
    1:   nsStyleBorder(nsPresContext* aContext);
    1:   nsStyleBorder(const nsStyleBorder& aBorder);
15992:   ~nsStyleBorder();
    1: 
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW;
    1:   void Destroy(nsPresContext* aContext);
    1: 
    1:   nsChangeHint CalcDifference(const nsStyleBorder& aOther) const;
    1: #ifdef DEBUG
    1:   static nsChangeHint MaxDifference();
    1: #endif
15992:   PRBool ImageBorderDiffers() const;
    1:  
20039:   nsStyleCorners mBorderRadius;    // [reset] coord, percent
15992:   nsStyleSides  mBorderImageSplit; // [reset] integer, percent
    1:   PRUint8       mFloatEdge;       // [reset] see nsStyleConsts.h
15992:   PRUint8       mBorderImageHFill; // [reset]
15992:   PRUint8       mBorderImageVFill; // [reset]
    1:   nsBorderColors** mBorderColors; // [reset] multiple levels of color for a border.
15699:   nsRefPtr<nsCSSShadowArray> mBoxShadow; // [reset] NULL for 'none'
15992:   PRBool        mHaveBorderImageWidth; // [reset]
15992:   nsMargin      mBorderImageWidth; // [reset]
    1:   
    1:   void EnsureBorderColors() {
    1:     if (!mBorderColors) {
    1:       mBorderColors = new nsBorderColors*[4];
    1:       if (mBorderColors)
    1:         for (PRInt32 i = 0; i < 4; i++)
    1:           mBorderColors[i] = nsnull;
    1:     }
    1:   }
    1: 
    1:   void ClearBorderColors(PRUint8 aSide) {
    1:     if (mBorderColors[aSide]) {
    1:       delete mBorderColors[aSide];
    1:       mBorderColors[aSide] = nsnull;
    1:     }
    1:   }
    1: 
    1:   // Return whether aStyle is a visible style.  Invisible styles cause
    1:   // the relevant computed border width to be 0.
15992:   // Note that this does *not* consider the effects of 'border-image':
15992:   // if border-style is none, but there is a loaded border image,
15992:   // HasVisibleStyle will be false even though there *is* a border.
15992:   PRBool HasVisibleStyle(PRUint8 aSide)
15992:   {
16055:     return IsVisibleBorderStyle(GetBorderStyle(aSide));
15991:   }
    1: 
    1:   // aBorderWidth is in twips
15991:   void SetBorderWidth(PRUint8 aSide, nscoord aBorderWidth)
15991:   {
15992:     nscoord roundedWidth =
15992:       NS_ROUND_BORDER_TO_PIXELS(aBorderWidth, mTwipsPerPixel);
15992:     mBorder.side(aSide) = roundedWidth;
15992:     if (HasVisibleStyle(aSide))
15992:       mComputedBorder.side(aSide) = roundedWidth;
15992:   }
15992: 
15992:   void SetBorderImageWidthOverride(PRUint8 aSide, nscoord aBorderWidth)
15992:   {
15992:     mBorderImageWidth.side(aSide) =
15991:       NS_ROUND_BORDER_TO_PIXELS(aBorderWidth, mTwipsPerPixel);
15991:   }
15990: 
15992:   // Get the actual border, in twips.  (If there is no border-image
15992:   // loaded, this is the same as GetComputedBorder.  If there is a
15992:   // border-image loaded, it uses the border-image width overrides if
15992:   // present, and otherwise mBorder, which is GetComputedBorder without
15992:   // considering border-style: none.)
15992:   const nsMargin& GetActualBorder() const;
15992:   
15992:   // Get the computed border (plus rounding).  This does consider the
15992:   // effects of 'border-style: none', but does not consider
15992:   // 'border-image'.
15992:   const nsMargin& GetComputedBorder() const
    1:   {
15992:     return mComputedBorder;
    1:   }
    1: 
    1:   // Get the actual border width for a particular side, in twips.  Note that
    1:   // this is zero if and only if there is no border to be painted for this
    1:   // side.  That is, this value takes into account the border style and the
    1:   // value is rounded to the nearest device pixel by NS_ROUND_BORDER_TO_PIXELS.
15992:   nscoord GetActualBorderWidth(PRUint8 aSide) const
    1:   {
15992:     return GetActualBorder().side(aSide);
    1:   }
    1: 
    1:   PRUint8 GetBorderStyle(PRUint8 aSide) const
    1:   {
    1:     NS_ASSERTION(aSide <= NS_SIDE_LEFT, "bad side"); 
    1:     return (mBorderStyle[aSide] & BORDER_STYLE_MASK); 
    1:   }
    1: 
15991:   void SetBorderStyle(PRUint8 aSide, PRUint8 aStyle)
15991:   {
15991:     NS_ASSERTION(aSide <= NS_SIDE_LEFT, "bad side"); 
15991:     mBorderStyle[aSide] &= ~BORDER_STYLE_MASK; 
15991:     mBorderStyle[aSide] |= (aStyle & BORDER_STYLE_MASK);
15992:     mComputedBorder.side(aSide) =
15992:       (HasVisibleStyle(aSide) ? mBorder.side(aSide) : 0);
15991:   }
15992: 
15992:   // Defined in nsStyleStructInlines.h
15992:   inline PRBool IsBorderImageLoaded() const;
    1: 
    1:   void GetBorderColor(PRUint8 aSide, nscolor& aColor,
19182:                       PRBool& aForeground) const
    1:   {
19182:     aForeground = PR_FALSE;
    1:     NS_ASSERTION(aSide <= NS_SIDE_LEFT, "bad side"); 
    1:     if ((mBorderStyle[aSide] & BORDER_COLOR_SPECIAL) == 0)
    1:       aColor = mBorderColor[aSide]; 
    1:     else if (mBorderStyle[aSide] & BORDER_COLOR_FOREGROUND)
    1:       aForeground = PR_TRUE;
    1:     else
19182:       NS_NOTREACHED("OUTLINE_COLOR_INITIAL should not be set here");
    1:   }
    1: 
    1:   void SetBorderColor(PRUint8 aSide, nscolor aColor) 
    1:   {
    1:     NS_ASSERTION(aSide <= NS_SIDE_LEFT, "bad side"); 
    1:     mBorderColor[aSide] = aColor; 
    1:     mBorderStyle[aSide] &= ~BORDER_COLOR_SPECIAL;
    1:   }
    1: 
15992:   // These are defined in nsStyleStructInlines.h
15992:   inline void SetBorderImage(imgIRequest* aImage);
15992:   inline imgIRequest* GetBorderImage() const;
15992: 
    1:   void GetCompositeColors(PRInt32 aIndex, nsBorderColors** aColors) const
    1:   {
    1:     if (!mBorderColors)
    1:       *aColors = nsnull;
    1:     else
    1:       *aColors = mBorderColors[aIndex];
    1:   }
    1: 
19182:   void AppendBorderColor(PRInt32 aIndex, nscolor aColor)
    1:   {
    1:     NS_ASSERTION(aIndex >= 0 && aIndex <= 3, "bad side for composite border color");
19182:     nsBorderColors* colorEntry = new nsBorderColors(aColor);
    1:     if (!mBorderColors[aIndex])
    1:       mBorderColors[aIndex] = colorEntry;
    1:     else {
    1:       nsBorderColors* last = mBorderColors[aIndex];
    1:       while (last->mNext)
    1:         last = last->mNext;
    1:       last->mNext = colorEntry;
    1:     }
    1:     mBorderStyle[aIndex] &= ~BORDER_COLOR_SPECIAL;
    1:   }
    1: 
    1:   void SetBorderToForeground(PRUint8 aSide)
    1:   {
    1:     NS_ASSERTION(aSide <= NS_SIDE_LEFT, "bad side"); 
    1:     mBorderStyle[aSide] &= ~BORDER_COLOR_SPECIAL;
    1:     mBorderStyle[aSide] |= BORDER_COLOR_FOREGROUND; 
    1:   }
    1: 
    1: protected:
15992:   // mComputedBorder holds the CSS2.1 computed border-width values.  In
    1:   // particular, these widths take into account the border-style for the
15992:   // relevant side and the values are rounded to the nearest device
15992:   // pixel.  They are also rounded (which is not part of the definition
15992:   // of computed values).  However, they do *not* take into account the
15992:   // presence of border-image.  See GetActualBorder above for how to
15992:   // really get the actual border.
15992:   nsMargin      mComputedBorder;
    1: 
    1:   // mBorder holds the nscoord values for the border widths as they would be if
    1:   // all the border-style values were visible (not hidden or none).  This
15992:   // member exists so that when we create structs using the copy
    1:   // constructor during style resolution the new structs will know what the
    1:   // specified values of the border were in case they have more specific rules
    1:   // setting the border style.  Note that this isn't quite the CSS specified
    1:   // value, since this has had the enumerated border widths converted to
    1:   // lengths, and all lengths converted to twips.  But it's not quite the
15992:   // computed value either. The values are rounded to the nearest device pixel
15992:   // We also use these values when we have a loaded border-image that
15992:   // does not have width overrides.
    1:   nsMargin      mBorder;
    1: 
    1:   PRUint8       mBorderStyle[4];  // [reset] See nsStyleConsts.h
    1:   nscolor       mBorderColor[4];  // [reset] the colors to use for a simple border.  not used
    1:                                   // if -moz-border-colors is specified
    1: 
15992:   nsCOMPtr<imgIRequest> mBorderImage; // [reset]
15992: 
    1:   nscoord       mTwipsPerPixel;
    1: };
    1: 
    1: 
10152: struct nsStyleOutline {
    1:   nsStyleOutline(nsPresContext* aPresContext);
    1:   nsStyleOutline(const nsStyleOutline& aOutline);
  731:   ~nsStyleOutline(void) {}
    1: 
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:     return aContext->AllocateFromShell(sz);
    1:   }
    1:   void Destroy(nsPresContext* aContext) {
    1:     this->~nsStyleOutline();
    1:     aContext->FreeToShell(sizeof(nsStyleOutline), this);
  731:   }
    1: 
    1:   void RecalcData(nsPresContext* aContext);
    1:   nsChangeHint CalcDifference(const nsStyleOutline& aOther) const;
    1: #ifdef DEBUG
    1:   static nsChangeHint MaxDifference();
    1: #endif
    1:  
20039:   nsStyleCorners  mOutlineRadius; // [reset] coord, percent
    1: 
19205:   // Note that this is a specified value.  You can get the actual values
19205:   // with GetOutlineWidth.  You cannot get the computed value directly.
19208:   nsStyleCoord  mOutlineWidth;    // [reset] coord, enum (see nsStyleConsts.h)
19205:   nscoord       mOutlineOffset;   // [reset]
    1: 
    1:   PRBool GetOutlineWidth(nscoord& aWidth) const
    1:   {
    1:     if (mHasCachedOutline) {
    1:       aWidth = mCachedOutlineWidth;
    1:       return PR_TRUE;
    1:     }
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   PRUint8 GetOutlineStyle(void) const
    1:   {
    1:     return (mOutlineStyle & BORDER_STYLE_MASK);
    1:   }
    1: 
    1:   void SetOutlineStyle(PRUint8 aStyle)
    1:   {
    1:     mOutlineStyle &= ~BORDER_STYLE_MASK;
    1:     mOutlineStyle |= (aStyle & BORDER_STYLE_MASK);
    1:   }
    1: 
    1:   // PR_FALSE means initial value
    1:   PRBool GetOutlineColor(nscolor& aColor) const
    1:   {
    1:     if ((mOutlineStyle & BORDER_COLOR_SPECIAL) == 0) {
    1:       aColor = mOutlineColor;
    1:       return PR_TRUE;
    1:     }
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   void SetOutlineColor(nscolor aColor)
    1:   {
    1:     mOutlineColor = aColor;
    1:     mOutlineStyle &= ~BORDER_COLOR_SPECIAL;
    1:   }
    1: 
    1:   void SetOutlineInitialColor()
    1:   {
    1:     mOutlineStyle |= OUTLINE_COLOR_INITIAL;
    1:   }
    1: 
    1:   PRBool GetOutlineInitialColor() const
    1:   {
 6770:     return !!(mOutlineStyle & OUTLINE_COLOR_INITIAL);
    1:   }
    1: 
    1: protected:
    1:   // This value is the actual value, so it's rounded to the nearest device
    1:   // pixel.
    1:   nscoord       mCachedOutlineWidth;
    1: 
    1:   nscolor       mOutlineColor;    // [reset] 
    1: 
    1:   PRPackedBool  mHasCachedOutline;
    1:   PRUint8       mOutlineStyle;    // [reset] See nsStyleConsts.h
    1: 
    1:   nscoord       mTwipsPerPixel;
    1: };
    1: 
    1: 
10152: struct nsStyleList {
    1:   nsStyleList(void);
    1:   nsStyleList(const nsStyleList& aStyleList);
    1:   ~nsStyleList(void);
    1: 
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:     return aContext->AllocateFromShell(sz);
    1:   }
    1:   void Destroy(nsPresContext* aContext) {
    1:     this->~nsStyleList();
    1:     aContext->FreeToShell(sizeof(nsStyleList), this);
  731:   }
    1: 
    1:   nsChangeHint CalcDifference(const nsStyleList& aOther) const;
    1: #ifdef DEBUG
    1:   static nsChangeHint MaxDifference();
    1: #endif
    1:   
    1:   PRUint8   mListStyleType;             // [inherited] See nsStyleConsts.h
    1:   PRUint8   mListStylePosition;         // [inherited] 
    1:   nsCOMPtr<imgIRequest> mListStyleImage; // [inherited]
    1:   nsRect        mImageRegion;           // [inherited] the rect to use within an image  
    1: };
    1: 
10152: struct nsStylePosition {
    1:   nsStylePosition(void);
    1:   nsStylePosition(const nsStylePosition& aOther);
    1:   ~nsStylePosition(void);
    1: 
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:     return aContext->AllocateFromShell(sz);
    1:   }
    1:   void Destroy(nsPresContext* aContext) {
    1:     this->~nsStylePosition();
    1:     aContext->FreeToShell(sizeof(nsStylePosition), this);
  731:   }
    1: 
    1:   nsChangeHint CalcDifference(const nsStylePosition& aOther) const;
    1: #ifdef DEBUG
    1:   static nsChangeHint MaxDifference();
    1: #endif
    1:   
16369:   nsStyleSides  mOffset;                // [reset] coord, percent, auto
 1068:   nsStyleCoord  mWidth;                 // [reset] coord, percent, auto, enum
 1068:   nsStyleCoord  mMinWidth;              // [reset] coord, percent, enum
 1068:   nsStyleCoord  mMaxWidth;              // [reset] coord, percent, null, enum
    1:   nsStyleCoord  mHeight;                // [reset] coord, percent, auto
    1:   nsStyleCoord  mMinHeight;             // [reset] coord, percent
    1:   nsStyleCoord  mMaxHeight;             // [reset] coord, percent, null
    1:   PRUint8       mBoxSizing;             // [reset] see nsStyleConsts.h
16369:   nsStyleCoord  mZIndex;                // [reset] integer, auto
    1: };
    1: 
10152: struct nsStyleTextReset {
    1:   nsStyleTextReset(void);
    1:   nsStyleTextReset(const nsStyleTextReset& aOther);
    1:   ~nsStyleTextReset(void);
    1: 
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:     return aContext->AllocateFromShell(sz);
    1:   }
    1:   void Destroy(nsPresContext* aContext) {
    1:     this->~nsStyleTextReset();
    1:     aContext->FreeToShell(sizeof(nsStyleTextReset), this);
  731:   }
    1: 
    1:   nsChangeHint CalcDifference(const nsStyleTextReset& aOther) const;
    1: #ifdef DEBUG
    1:   static nsChangeHint MaxDifference();
    1: #endif
    1:   
    1:   PRUint8 mTextDecoration;              // [reset] see nsStyleConsts.h
    1:   PRUint8 mUnicodeBidi;                 // [reset] see nsStyleConsts.h
    1: 
16369:   nsStyleCoord  mVerticalAlign;         // [reset] coord, percent, enum (see nsStyleConsts.h)
    1: };
    1: 
10152: struct nsStyleText {
    1:   nsStyleText(void);
    1:   nsStyleText(const nsStyleText& aOther);
    1:   ~nsStyleText(void);
    1: 
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:     return aContext->AllocateFromShell(sz);
    1:   }
    1:   void Destroy(nsPresContext* aContext) {
    1:     this->~nsStyleText();
    1:     aContext->FreeToShell(sizeof(nsStyleText), this);
  731:   }
    1: 
    1:   nsChangeHint CalcDifference(const nsStyleText& aOther) const;
    1: #ifdef DEBUG
    1:   static nsChangeHint MaxDifference();
    1: #endif
    1: 
    1:   PRUint8 mTextAlign;                   // [inherited] see nsStyleConsts.h
    1:   PRUint8 mTextTransform;               // [inherited] see nsStyleConsts.h
    1:   PRUint8 mWhiteSpace;                  // [inherited] see nsStyleConsts.h
16166:   PRUint8 mWordWrap;                    // [inherited] see nsStyleConsts.h
    1: 
16369:   nsStyleCoord  mLetterSpacing;         // [inherited] coord, normal
16369:   nsStyleCoord  mLineHeight;            // [inherited] coord, factor, normal
16369:   nsStyleCoord  mTextIndent;            // [inherited] coord, percent
16369:   nsStyleCoord  mWordSpacing;           // [inherited] coord, normal
    1: 
15699:   nsRefPtr<nsCSSShadowArray> mTextShadow; // [inherited] NULL in case of a zero-length
15268:   
    1:   PRBool WhiteSpaceIsSignificant() const {
    1:     return mWhiteSpace == NS_STYLE_WHITESPACE_PRE ||
11894:            mWhiteSpace == NS_STYLE_WHITESPACE_PRE_WRAP;
    1:   }
    1: 
16575:   PRBool NewlineIsSignificant() const {
16575:     return mWhiteSpace == NS_STYLE_WHITESPACE_PRE ||
16575:            mWhiteSpace == NS_STYLE_WHITESPACE_PRE_WRAP ||
16575:            mWhiteSpace == NS_STYLE_WHITESPACE_PRE_LINE;
16575:   }
16575: 
    1:   PRBool WhiteSpaceCanWrap() const {
    1:     return mWhiteSpace == NS_STYLE_WHITESPACE_NORMAL ||
16575:            mWhiteSpace == NS_STYLE_WHITESPACE_PRE_WRAP ||
16575:            mWhiteSpace == NS_STYLE_WHITESPACE_PRE_LINE;
    1:   }
16166: 
16166:   PRBool WordCanWrap() const {
20548:     return WhiteSpaceCanWrap() && mWordWrap == NS_STYLE_WORDWRAP_BREAK_WORD;
16166:   }
    1: };
    1: 
10152: struct nsStyleVisibility {
    1:   nsStyleVisibility(nsPresContext* aPresContext);
    1:   nsStyleVisibility(const nsStyleVisibility& aVisibility);
  731:   ~nsStyleVisibility() {}
    1: 
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:     return aContext->AllocateFromShell(sz);
    1:   }
    1:   void Destroy(nsPresContext* aContext) {
    1:     this->~nsStyleVisibility();
    1:     aContext->FreeToShell(sizeof(nsStyleVisibility), this);
  731:   }
    1: 
    1:   nsChangeHint CalcDifference(const nsStyleVisibility& aOther) const;
    1: #ifdef DEBUG
    1:   static nsChangeHint MaxDifference();
    1: #endif
    1:   
    1:   PRUint8 mDirection;                  // [inherited] see nsStyleConsts.h NS_STYLE_DIRECTION_*
    1:   PRUint8   mVisible;                  // [inherited]
    1:   nsCOMPtr<nsIAtom> mLangGroup;        // [inherited]
    1:  
    1:   PRBool IsVisible() const {
    1:     return (mVisible == NS_STYLE_VISIBILITY_VISIBLE);
    1:   }
    1: 
    1:   PRBool IsVisibleOrCollapsed() const {
    1:     return ((mVisible == NS_STYLE_VISIBILITY_VISIBLE) ||
    1:             (mVisible == NS_STYLE_VISIBILITY_COLLAPSE));
    1:   }
    1: };
    1: 
10152: struct nsStyleDisplay {
    1:   nsStyleDisplay();
    1:   nsStyleDisplay(const nsStyleDisplay& aOther); 
  731:   ~nsStyleDisplay() {}
    1: 
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:     return aContext->AllocateFromShell(sz);
    1:   }
    1:   void Destroy(nsPresContext* aContext) {
    1:     this->~nsStyleDisplay();
    1:     aContext->FreeToShell(sizeof(nsStyleDisplay), this);
  731:   }
    1: 
    1:   nsChangeHint CalcDifference(const nsStyleDisplay& aOther) const;
    1: #ifdef DEBUG
    1:   static nsChangeHint MaxDifference();
    1: #endif
    1: 
 3645:   // We guarantee that if mBinding is non-null, so are mBinding->mURI and
 3645:   // mBinding->mOriginPrincipal.
 3645:   nsRefPtr<nsCSSValue::URL> mBinding;    // [reset]
    1: #if 0
    1:   // XXX This is how it is defined in the CSS2 spec, but the errata
    1:   // changed it to be consistent with the positioning draft and how
    1:   // Nav and IE implement it
    1:   nsMargin  mClip;              // [reset] offsets from respective edge
    1: #else
    1:   nsRect    mClip;              // [reset] offsets from upper-left border edge
    1: #endif
    1:   float   mOpacity;             // [reset]
    1:   PRUint8 mDisplay;             // [reset] see nsStyleConsts.h NS_STYLE_DISPLAY_*
    1:   PRUint8 mOriginalDisplay;     // [reset] saved mDisplay for position:absolute/fixed
    1:   PRUint8 mAppearance;          // [reset]
    1:   PRUint8 mPosition;            // [reset] see nsStyleConsts.h
    1:   PRUint8 mFloats;              // [reset] see nsStyleConsts.h NS_STYLE_FLOAT_*
    1:   PRUint8 mBreakType;           // [reset] see nsStyleConsts.h NS_STYLE_CLEAR_*
    1:   PRPackedBool mBreakBefore;    // [reset] 
    1:   PRPackedBool mBreakAfter;     // [reset] 
    1:   PRUint8 mOverflowX;           // [reset] see nsStyleConsts.h
    1:   PRUint8 mOverflowY;           // [reset] see nsStyleConsts.h
    1:   PRUint8   mClipFlags;         // [reset] see nsStyleConsts.h
19214:   PRPackedBool mTransformPresent;  // [reset] Whether there is a -moz-transform.
19214:   nsStyleTransformMatrix mTransform; // [reset] The stored transform matrix
19214:   nsStyleCoord mTransformOrigin[2]; // [reset] percent, coord.
    1: 
    1:   PRBool IsBlockInside() const {
    1:     return NS_STYLE_DISPLAY_BLOCK == mDisplay ||
    1:            NS_STYLE_DISPLAY_LIST_ITEM == mDisplay ||
    1:            NS_STYLE_DISPLAY_INLINE_BLOCK == mDisplay;
    1:     // Should TABLE_CELL and TABLE_CAPTION go here?  They have
    1:     // block frames nested inside of them.
    1:     // (But please audit all callers before changing.)
    1:   }
    1: 
    1:   PRBool IsBlockOutside() const {
    1:     return NS_STYLE_DISPLAY_BLOCK == mDisplay ||
    1:            NS_STYLE_DISPLAY_LIST_ITEM == mDisplay ||
    1:            NS_STYLE_DISPLAY_TABLE == mDisplay;
    1:   }
    1: 
    1:   PRBool IsInlineOutside() const {
    1:     return NS_STYLE_DISPLAY_INLINE == mDisplay ||
    1:            NS_STYLE_DISPLAY_INLINE_BLOCK == mDisplay ||
    1:            NS_STYLE_DISPLAY_INLINE_TABLE == mDisplay ||
    1:            NS_STYLE_DISPLAY_INLINE_BOX == mDisplay ||
    1:            NS_STYLE_DISPLAY_INLINE_GRID == mDisplay ||
 2829:            NS_STYLE_DISPLAY_INLINE_STACK == mDisplay;
    1:   }
    1: 
    1:   PRBool IsFloating() const {
    1:     return NS_STYLE_FLOAT_NONE != mFloats;
    1:   }
    1: 
    1:   PRBool IsAbsolutelyPositioned() const {return (NS_STYLE_POSITION_ABSOLUTE == mPosition) ||
    1:                                                 (NS_STYLE_POSITION_FIXED == mPosition);}
    1: 
19214:   /* Returns true if we're positioned or there's a transform in effect. */
19214:   PRBool IsPositioned() const {
19214:     return IsAbsolutelyPositioned() ||
19214:       NS_STYLE_POSITION_RELATIVE == mPosition || mTransformPresent;
19214:   }
    1: 
    1:   PRBool IsScrollableOverflow() const {
    1:     // mOverflowX and mOverflowY always match when one of them is
    1:     // NS_STYLE_OVERFLOW_VISIBLE or NS_STYLE_OVERFLOW_CLIP.
    1:     return mOverflowX != NS_STYLE_OVERFLOW_VISIBLE &&
    1:            mOverflowX != NS_STYLE_OVERFLOW_CLIP;
    1:   }
    1: 
    1:   // For table elements that don't support scroll frame creation, we
    1:   // support 'overflow: hidden' to mean 'overflow: -moz-hidden-unscrollable'.
    1:   PRBool IsTableClip() const {
    1:     return mOverflowX == NS_STYLE_OVERFLOW_CLIP ||
    1:            (mOverflowX == NS_STYLE_OVERFLOW_HIDDEN &&
    1:             mOverflowY == NS_STYLE_OVERFLOW_HIDDEN);
    1:   }
19214: 
19214:   /* Returns whether the element has the -moz-transform property. */
19214:   PRBool HasTransform() const {
19214:     return mTransformPresent;
19214:   }
    1: };
    1: 
10152: struct nsStyleTable {
    1:   nsStyleTable(void);
    1:   nsStyleTable(const nsStyleTable& aOther);
    1:   ~nsStyleTable(void);
    1: 
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:     return aContext->AllocateFromShell(sz);
    1:   }
    1:   void Destroy(nsPresContext* aContext) {
    1:     this->~nsStyleTable();
    1:     aContext->FreeToShell(sizeof(nsStyleTable), this);
  731:   }
    1: 
    1:   nsChangeHint CalcDifference(const nsStyleTable& aOther) const;
    1: #ifdef DEBUG
    1:   static nsChangeHint MaxDifference();
    1: #endif
    1:   
    1:   PRUint8       mLayoutStrategy;// [reset] see nsStyleConsts.h NS_STYLE_TABLE_LAYOUT_*
    1:   PRUint8       mFrame;         // [reset] see nsStyleConsts.h NS_STYLE_TABLE_FRAME_*
    1:   PRUint8       mRules;         // [reset] see nsStyleConsts.h NS_STYLE_TABLE_RULES_*
    1:   PRInt32       mCols;          // [reset] an integer if set, or see nsStyleConsts.h NS_STYLE_TABLE_COLS_*
    1:   PRInt32       mSpan;          // [reset] the number of columns spanned by a colgroup or col
    1: };
    1: 
10152: struct nsStyleTableBorder {
    1:   nsStyleTableBorder(nsPresContext* aContext);
    1:   nsStyleTableBorder(const nsStyleTableBorder& aOther);
    1:   ~nsStyleTableBorder(void);
    1: 
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:     return aContext->AllocateFromShell(sz);
    1:   }
    1:   void Destroy(nsPresContext* aContext) {
    1:     this->~nsStyleTableBorder();
    1:     aContext->FreeToShell(sizeof(nsStyleTableBorder), this);
  731:   }
    1: 
    1:   nsChangeHint CalcDifference(const nsStyleTableBorder& aOther) const;
    1: #ifdef DEBUG
    1:   static nsChangeHint MaxDifference();
    1: #endif
    1:   
19206:   nscoord       mBorderSpacingX;// [inherited]
19206:   nscoord       mBorderSpacingY;// [inherited]
    1:   PRUint8       mBorderCollapse;// [inherited]
    1:   PRUint8       mCaptionSide;   // [inherited]
    1:   PRUint8       mEmptyCells;    // [inherited]
    1: };
    1: 
    1: enum nsStyleContentType {
    1:   eStyleContentType_String        = 1,
    1:   eStyleContentType_Image         = 10,
    1:   eStyleContentType_Attr          = 20,
    1:   eStyleContentType_Counter       = 30,
    1:   eStyleContentType_Counters      = 31,
    1:   eStyleContentType_OpenQuote     = 40,
    1:   eStyleContentType_CloseQuote    = 41,
    1:   eStyleContentType_NoOpenQuote   = 42,
    1:   eStyleContentType_NoCloseQuote  = 43,
    1:   eStyleContentType_AltContent    = 50
    1: };
    1: 
    1: struct nsStyleContentData {
    1:   nsStyleContentType  mType;
    1:   union {
    1:     PRUnichar *mString;
    1:     imgIRequest *mImage;
    1:     nsCSSValue::Array* mCounters;
    1:   } mContent;
    1: 
    1:   nsStyleContentData() : mType(nsStyleContentType(0)) { mContent.mString = nsnull; }
    1:   ~nsStyleContentData();
    1:   nsStyleContentData& operator=(const nsStyleContentData& aOther);
    1:   PRBool operator==(const nsStyleContentData& aOther) const;
    1: 
    1:   PRBool operator!=(const nsStyleContentData& aOther) const {
    1:     return !(*this == aOther);
    1:   }
    1: private:
    1:   nsStyleContentData(const nsStyleContentData&); // not to be implemented
    1: };
    1: 
    1: struct nsStyleCounterData {
    1:   nsString  mCounter;
    1:   PRInt32   mValue;
    1: };
    1: 
    1: 
    1: #define DELETE_ARRAY_IF(array)  if (array) { delete[] array; array = nsnull; }
    1: 
10152: struct nsStyleQuotes {
    1:   nsStyleQuotes();
    1:   nsStyleQuotes(const nsStyleQuotes& aQuotes);
    1:   ~nsStyleQuotes();
    1: 
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:     return aContext->AllocateFromShell(sz);
    1:   }
    1:   void Destroy(nsPresContext* aContext) {
    1:     this->~nsStyleQuotes();
    1:     aContext->FreeToShell(sizeof(nsStyleQuotes), this);
  731:   }
    1: 
17037:   void SetInitial();
17037:   void CopyFrom(const nsStyleQuotes& aSource);
17037: 
    1:   nsChangeHint CalcDifference(const nsStyleQuotes& aOther) const;
    1: #ifdef DEBUG
    1:   static nsChangeHint MaxDifference();
    1: #endif
    1:   
    1:   PRUint32  QuotesCount(void) const { return mQuotesCount; } // [inherited]
    1: 
    1:   const nsString* OpenQuoteAt(PRUint32 aIndex) const
    1:   {
    1:     NS_ASSERTION(aIndex < mQuotesCount, "out of range");
    1:     return mQuotes + (aIndex * 2);
    1:   }
    1:   const nsString* CloseQuoteAt(PRUint32 aIndex) const
    1:   {
    1:     NS_ASSERTION(aIndex < mQuotesCount, "out of range");
    1:     return mQuotes + (aIndex * 2 + 1);
    1:   }
    1:   nsresult  GetQuotesAt(PRUint32 aIndex, nsString& aOpen, nsString& aClose) const {
    1:     if (aIndex < mQuotesCount) {
    1:       aIndex *= 2;
    1:       aOpen = mQuotes[aIndex];
    1:       aClose = mQuotes[++aIndex];
    1:       return NS_OK;
    1:     }
    1:     return NS_ERROR_ILLEGAL_VALUE;
    1:   }
    1: 
    1:   nsresult  AllocateQuotes(PRUint32 aCount) {
    1:     if (aCount != mQuotesCount) {
    1:       DELETE_ARRAY_IF(mQuotes);
    1:       if (aCount) {
    1:         mQuotes = new nsString[aCount * 2];
    1:         if (! mQuotes) {
    1:           mQuotesCount = 0;
    1:           return NS_ERROR_OUT_OF_MEMORY;
    1:         }
    1:       }
    1:       mQuotesCount = aCount;
    1:     }
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsresult  SetQuotesAt(PRUint32 aIndex, const nsString& aOpen, const nsString& aClose) {
    1:     if (aIndex < mQuotesCount) {
    1:       aIndex *= 2;
    1:       mQuotes[aIndex] = aOpen;
    1:       mQuotes[++aIndex] = aClose;
    1:       return NS_OK;
    1:     }
    1:     return NS_ERROR_ILLEGAL_VALUE;
    1:   }
    1: 
    1: protected:
    1:   PRUint32            mQuotesCount;
    1:   nsString*           mQuotes;
    1: };
    1: 
10152: struct nsStyleContent {
    1:   nsStyleContent(void);
    1:   nsStyleContent(const nsStyleContent& aContent);
    1:   ~nsStyleContent(void);
    1: 
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:     return aContext->AllocateFromShell(sz);
    1:   }
    1:   void Destroy(nsPresContext* aContext) {
    1:     this->~nsStyleContent();
    1:     aContext->FreeToShell(sizeof(nsStyleContent), this);
  731:   }
    1: 
    1:   nsChangeHint CalcDifference(const nsStyleContent& aOther) const;
    1: #ifdef DEBUG
    1:   static nsChangeHint MaxDifference();
    1: #endif
    1: 
    1:   PRUint32  ContentCount(void) const  { return mContentCount; } // [reset]
    1: 
    1:   const nsStyleContentData& ContentAt(PRUint32 aIndex) const {
    1:     NS_ASSERTION(aIndex < mContentCount, "out of range");
    1:     return mContents[aIndex];
    1:   }
    1: 
    1:   nsStyleContentData& ContentAt(PRUint32 aIndex) {
    1:     NS_ASSERTION(aIndex < mContentCount, "out of range");
    1:     return mContents[aIndex];
    1:   }
    1: 
    1:   nsresult AllocateContents(PRUint32 aCount);
    1: 
    1:   PRUint32  CounterIncrementCount(void) const { return mIncrementCount; }  // [reset]
    1:   const nsStyleCounterData* GetCounterIncrementAt(PRUint32 aIndex) const {
    1:     NS_ASSERTION(aIndex < mIncrementCount, "out of range");
    1:     return &mIncrements[aIndex];
    1:   }
    1: 
    1:   nsresult  AllocateCounterIncrements(PRUint32 aCount) {
    1:     if (aCount != mIncrementCount) {
    1:       DELETE_ARRAY_IF(mIncrements);
    1:       if (aCount) {
    1:         mIncrements = new nsStyleCounterData[aCount];
    1:         if (! mIncrements) {
    1:           mIncrementCount = 0;
    1:           return NS_ERROR_OUT_OF_MEMORY;
    1:         }
    1:       }
    1:       mIncrementCount = aCount;
    1:     }
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsresult  SetCounterIncrementAt(PRUint32 aIndex, const nsString& aCounter, PRInt32 aIncrement) {
    1:     if (aIndex < mIncrementCount) {
    1:       mIncrements[aIndex].mCounter = aCounter;
    1:       mIncrements[aIndex].mValue = aIncrement;
    1:       return NS_OK;
    1:     }
    1:     return NS_ERROR_ILLEGAL_VALUE;
    1:   }
    1: 
    1:   PRUint32  CounterResetCount(void) const { return mResetCount; }  // [reset]
    1:   const nsStyleCounterData* GetCounterResetAt(PRUint32 aIndex) const {
    1:     NS_ASSERTION(aIndex < mResetCount, "out of range");
    1:     return &mResets[aIndex];
    1:   }
    1: 
    1:   nsresult  AllocateCounterResets(PRUint32 aCount) {
    1:     if (aCount != mResetCount) {
    1:       DELETE_ARRAY_IF(mResets);
    1:       if (aCount) {
    1:         mResets = new nsStyleCounterData[aCount];
    1:         if (! mResets) {
    1:           mResetCount = 0;
    1:           return NS_ERROR_OUT_OF_MEMORY;
    1:         }
    1:       }
    1:       mResetCount = aCount;
    1:     }
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsresult  SetCounterResetAt(PRUint32 aIndex, const nsString& aCounter, PRInt32 aValue) {
    1:     if (aIndex < mResetCount) {
    1:       mResets[aIndex].mCounter = aCounter;
    1:       mResets[aIndex].mValue = aValue;
    1:       return NS_OK;
    1:     }
    1:     return NS_ERROR_ILLEGAL_VALUE;
    1:   }
    1: 
16369:   nsStyleCoord  mMarkerOffset;  // [reset] coord, auto
    1: 
    1: protected:
    1:   PRUint32            mContentCount;
    1:   nsStyleContentData* mContents;
    1: 
    1:   PRUint32            mIncrementCount;
    1:   nsStyleCounterData* mIncrements;
    1: 
    1:   PRUint32            mResetCount;
    1:   nsStyleCounterData* mResets;
    1: };
    1: 
10152: struct nsStyleUIReset {
    1:   nsStyleUIReset(void);
    1:   nsStyleUIReset(const nsStyleUIReset& aOther);
    1:   ~nsStyleUIReset(void);
    1: 
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:     return aContext->AllocateFromShell(sz);
    1:   }
    1:   void Destroy(nsPresContext* aContext) {
    1:     this->~nsStyleUIReset();
    1:     aContext->FreeToShell(sizeof(nsStyleUIReset), this);
  731:   }
    1: 
    1:   nsChangeHint CalcDifference(const nsStyleUIReset& aOther) const;
    1: #ifdef DEBUG
    1:   static nsChangeHint MaxDifference();
    1: #endif
    1: 
    1:   PRUint8   mUserSelect;      // [reset] (selection-style)
    1:   PRUint8   mForceBrokenImageIcon; // [reset]  (0 if not forcing, otherwise forcing)
 1520:   PRUint8   mIMEMode;         // [reset]
20464:   PRUint8   mWindowShadow;    // [reset]
    1: };
    1: 
    1: struct nsCursorImage {
    1:   nsCOMPtr<imgIRequest> mImage;
    1:   PRBool mHaveHotspot;
    1:   float mHotspotX, mHotspotY;
    1: 
    1:   nsCursorImage();
    1: };
    1: 
10152: struct nsStyleUserInterface {
    1:   nsStyleUserInterface(void);
    1:   nsStyleUserInterface(const nsStyleUserInterface& aOther);
    1:   ~nsStyleUserInterface(void);
    1: 
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:     return aContext->AllocateFromShell(sz);
    1:   }
    1:   void Destroy(nsPresContext* aContext) {
    1:     this->~nsStyleUserInterface();
    1:     aContext->FreeToShell(sizeof(nsStyleUserInterface), this);
  731:   }
    1: 
    1:   nsChangeHint CalcDifference(const nsStyleUserInterface& aOther) const;
    1: #ifdef DEBUG
    1:   static nsChangeHint MaxDifference();
    1: #endif
    1: 
    1:   PRUint8   mUserInput;       // [inherited]
    1:   PRUint8   mUserModify;      // [inherited] (modify-content)
    1:   PRUint8   mUserFocus;       // [inherited] (auto-select)
    1:   
    1:   PRUint8   mCursor;          // [inherited] See nsStyleConsts.h
    1: 
    1:   PRUint32 mCursorArrayLength;
    1:   nsCursorImage *mCursorArray;// [inherited] The specified URL values
    1:                               //   and coordinates.  Takes precedence over
    1:                               //   mCursor.  Zero-length array is represented
    1:                               //   by null pointer.
    1: 
    1:   // Does not free mCursorArray; the caller is responsible for calling
    1:   // |delete [] mCursorArray| first if it is needed.
    1:   void CopyCursorArrayFrom(const nsStyleUserInterface& aSource);
    1: };
    1: 
10152: struct nsStyleXUL {
    1:   nsStyleXUL();
    1:   nsStyleXUL(const nsStyleXUL& aSource);
    1:   ~nsStyleXUL();
    1: 
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:     return aContext->AllocateFromShell(sz);
    1:   }
    1:   void Destroy(nsPresContext* aContext) {
    1:     this->~nsStyleXUL();
    1:     aContext->FreeToShell(sizeof(nsStyleXUL), this);
  731:   }
    1: 
    1:   nsChangeHint CalcDifference(const nsStyleXUL& aOther) const;
    1: #ifdef DEBUG
    1:   static nsChangeHint MaxDifference();
    1: #endif
    1:   
    1:   float         mBoxFlex;               // [reset] see nsStyleConsts.h
    1:   PRUint32      mBoxOrdinal;            // [reset] see nsStyleConsts.h
    1:   PRUint8       mBoxAlign;              // [reset] see nsStyleConsts.h
    1:   PRUint8       mBoxDirection;          // [reset] see nsStyleConsts.h
    1:   PRUint8       mBoxOrient;             // [reset] see nsStyleConsts.h
    1:   PRUint8       mBoxPack;               // [reset] see nsStyleConsts.h
15260:   PRPackedBool  mStretchStack;          // [reset] see nsStyleConsts.h
    1: };
    1: 
10152: struct nsStyleColumn {
16055:   nsStyleColumn(nsPresContext* aPresContext);
    1:   nsStyleColumn(const nsStyleColumn& aSource);
    1:   ~nsStyleColumn();
    1: 
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:     return aContext->AllocateFromShell(sz);
    1:   }
    1:   void Destroy(nsPresContext* aContext) {
    1:     this->~nsStyleColumn();
    1:     aContext->FreeToShell(sizeof(nsStyleColumn), this);
  731:   }
    1: 
    1:   nsChangeHint CalcDifference(const nsStyleColumn& aOther) const;
    1: #ifdef DEBUG
    1:   static nsChangeHint MaxDifference();
    1: #endif
    1: 
    1:   PRUint32     mColumnCount; // [reset] see nsStyleConsts.h
16369:   nsStyleCoord mColumnWidth; // [reset] coord, auto
16369:   nsStyleCoord mColumnGap;   // [reset] coord, percent, normal
16055: 
16055:   nscolor      mColumnRuleColor;  // [reset]
16055:   PRUint8      mColumnRuleStyle;  // [reset]
19209:   // See https://bugzilla.mozilla.org/show_bug.cgi?id=271586#c43 for why
19209:   // this is hard to replace with 'currentColor'.
16055:   PRPackedBool mColumnRuleColorIsForeground;
16055: 
16055:   void SetColumnRuleWidth(nscoord aWidth) {
16055:     mColumnRuleWidth = NS_ROUND_BORDER_TO_PIXELS(aWidth, mTwipsPerPixel);
16055:   }
16055: 
16055:   nscoord GetComputedColumnRuleWidth() const {
16055:     return (IsVisibleBorderStyle(mColumnRuleStyle) ? mColumnRuleWidth : 0);
16055:   }
16055: 
16055: protected:
16055:   nscoord mColumnRuleWidth;  // [reset] coord
16055:   nscoord mTwipsPerPixel;
    1: };
    1: 
    1: #ifdef MOZ_SVG
    1: enum nsStyleSVGPaintType {
 7041:   eStyleSVGPaintType_None = 1,
    1:   eStyleSVGPaintType_Color,
    1:   eStyleSVGPaintType_Server
    1: };
    1: 
    1: struct nsStyleSVGPaint
    1: {
    1:   nsStyleSVGPaintType mType;
    1:   union {
    1:     nscolor mColor;
    1:     nsIURI *mPaintServer;
    1:   } mPaint;
    1:   nscolor mFallbackColor;
    1: 
 7041:   nsStyleSVGPaint() : mType(nsStyleSVGPaintType(0)) { mPaint.mPaintServer = nsnull; }
    1:   ~nsStyleSVGPaint();
 7041:   void SetType(nsStyleSVGPaintType aType);
    1:   nsStyleSVGPaint& operator=(const nsStyleSVGPaint& aOther);
    1:   PRBool operator==(const nsStyleSVGPaint& aOther) const; 
    1: 
    1:   PRBool operator!=(const nsStyleSVGPaint& aOther) const {
    1:     return !(*this == aOther);
    1:   }
    1: };
    1: 
10152: struct nsStyleSVG {
    1:   nsStyleSVG();
    1:   nsStyleSVG(const nsStyleSVG& aSource);
    1:   ~nsStyleSVG();
    1: 
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:     return aContext->AllocateFromShell(sz);
    1:   }
    1:   void Destroy(nsPresContext* aContext) {
    1:     this->~nsStyleSVG();
    1:     aContext->FreeToShell(sizeof(nsStyleSVG), this);
  731:   }
    1: 
    1:   nsChangeHint CalcDifference(const nsStyleSVG& aOther) const;
    1: #ifdef DEBUG
    1:   static nsChangeHint MaxDifference();
    1: #endif
    1: 
    1:   nsStyleSVGPaint  mFill;             // [inherited]
    1:   nsStyleSVGPaint  mStroke;           // [inherited]
    1:   nsCOMPtr<nsIURI> mMarkerEnd;        // [inherited]
    1:   nsCOMPtr<nsIURI> mMarkerMid;        // [inherited]
    1:   nsCOMPtr<nsIURI> mMarkerStart;      // [inherited]
16369:   nsStyleCoord    *mStrokeDasharray;  // [inherited] coord, percent, factor
    1: 
16369:   nsStyleCoord     mStrokeDashoffset; // [inherited] coord, percent, factor
16369:   nsStyleCoord     mStrokeWidth;      // [inherited] coord, percent, factor
    1: 
    1:   float            mFillOpacity;      // [inherited]
    1:   float            mStrokeMiterlimit; // [inherited]
    1:   float            mStrokeOpacity;    // [inherited]
    1: 
    1:   PRUint32         mStrokeDasharrayLength;
    1:   PRUint8          mClipRule;         // [inherited]
    1:   PRUint8          mColorInterpolation; // [inherited] see nsStyleConsts.h
    1:   PRUint8          mColorInterpolationFilters; // [inherited] see nsStyleConsts.h
    1:   PRUint8          mFillRule;         // [inherited] see nsStyleConsts.h
    1:   PRUint8          mPointerEvents;    // [inherited] see nsStyleConsts.h
    1:   PRUint8          mShapeRendering;   // [inherited] see nsStyleConsts.h
    1:   PRUint8          mStrokeLinecap;    // [inherited] see nsStyleConsts.h
    1:   PRUint8          mStrokeLinejoin;   // [inherited] see nsStyleConsts.h
    1:   PRUint8          mTextAnchor;       // [inherited] see nsStyleConsts.h
    1:   PRUint8          mTextRendering;    // [inherited] see nsStyleConsts.h
    1: };
    1: 
10152: struct nsStyleSVGReset {
    1:   nsStyleSVGReset();
    1:   nsStyleSVGReset(const nsStyleSVGReset& aSource);
    1:   ~nsStyleSVGReset();
    1: 
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:     return aContext->AllocateFromShell(sz);
    1:   }
    1:   void Destroy(nsPresContext* aContext) {
    1:     this->~nsStyleSVGReset();
    1:     aContext->FreeToShell(sizeof(nsStyleSVGReset), this);
  731:   }
    1: 
    1:   nsChangeHint CalcDifference(const nsStyleSVGReset& aOther) const;
    1: #ifdef DEBUG
    1:   static nsChangeHint MaxDifference();
    1: #endif
    1: 
    1:   nscolor          mStopColor;        // [reset]
    1:   nscolor          mFloodColor;       // [reset]
 4029:   nscolor          mLightingColor;    // [reset]
    1:   nsCOMPtr<nsIURI> mClipPath;         // [reset]
    1:   nsCOMPtr<nsIURI> mFilter;           // [reset]
    1:   nsCOMPtr<nsIURI> mMask;             // [reset]
    1: 
    1:   float            mStopOpacity;      // [reset]
    1:   float            mFloodOpacity;     // [reset]
    1: 
    1:   PRUint8          mDominantBaseline; // [reset] see nsStyleConsts.h
    1: };
    1: #endif
    1: 
    1: #endif /* nsStyleStruct_h___ */
