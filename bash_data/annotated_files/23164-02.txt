    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Jungshik Shin <jshin@mailaps.org>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsMediaDocument.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsRect.h"
    1: #include "nsPresContext.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIScrollable.h"
    1: #include "nsIViewManager.h"
    1: #include "nsITextToSubURI.h"
    1: #include "nsIURL.h"
    1: #include "nsPrintfCString.h"
    1: #include "nsIContentViewer.h"
    1: #include "nsIMarkupDocumentViewer.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIParser.h" // kCharsetFrom* macro definition
    1: #include "nsIDocumentCharsetInfo.h" 
    1: #include "nsNodeInfoManager.h"
    1: 
    1: nsMediaDocumentStreamListener::nsMediaDocumentStreamListener(nsMediaDocument *aDocument)
    1: {
    1:   mDocument = aDocument;
    1: }
    1: 
    1: nsMediaDocumentStreamListener::~nsMediaDocumentStreamListener()
    1: {
    1: }
    1: 
    1: 
    1: NS_IMPL_THREADSAFE_ISUPPORTS2(nsMediaDocumentStreamListener,
    1:                               nsIRequestObserver,
    1:                               nsIStreamListener)
    1: 
    1: 
    1: void
    1: nsMediaDocumentStreamListener::SetStreamListener(nsIStreamListener *aListener)
    1: {
    1:   mNextStream = aListener;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMediaDocumentStreamListener::OnStartRequest(nsIRequest* request, nsISupports *ctxt)
    1: {
    1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_FAILURE);
    1: 
    1:   mDocument->StartLayout();
    1: 
    1:   if (mNextStream) {
    1:     return mNextStream->OnStartRequest(request, ctxt);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMediaDocumentStreamListener::OnStopRequest(nsIRequest* request,
    1:                                              nsISupports *ctxt,
    1:                                              nsresult status)
    1: {
    1:   nsresult rv = NS_OK;
    1:   if (mNextStream) {
    1:     rv = mNextStream->OnStopRequest(request, ctxt, status);
    1:   }
    1: 
    1:   // No more need for our document so clear our reference and prevent leaks
    1:   mDocument = nsnull;
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMediaDocumentStreamListener::OnDataAvailable(nsIRequest* request,
    1:                                                nsISupports *ctxt,
    1:                                                nsIInputStream *inStr,
    1:                                                PRUint32 sourceOffset,
    1:                                                PRUint32 count)
    1: {
    1:   if (mNextStream) {
    1:     return mNextStream->OnDataAvailable(request, ctxt, inStr, sourceOffset, count);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // default format names for nsMediaDocument. 
    1: const char* const nsMediaDocument::sFormatNames[4] = 
    1: {
    1:   "MediaTitleWithNoInfo",    // eWithNoInfo
    1:   "MediaTitleWithFile",      // eWithFile
    1:   "",                        // eWithDim
    1:   ""                         // eWithDimAndFile
    1: };
    1: 
    1: nsMediaDocument::nsMediaDocument()
    1: {
    1: }
    1: nsMediaDocument::~nsMediaDocument()
    1: {
    1: }
    1: 
    1: nsresult
    1: nsMediaDocument::Init()
    1: {
    1:   nsresult rv = nsHTMLDocument::Init();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Create a bundle for the localization
    1:   nsCOMPtr<nsIStringBundleService> stringService(
    1:     do_GetService(NS_STRINGBUNDLE_CONTRACTID));
    1:   if (stringService) {
    1:     stringService->CreateBundle(NSMEDIADOCUMENT_PROPERTIES_URI,
    1:                                 getter_AddRefs(mStringBundle));
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsMediaDocument::StartDocumentLoad(const char*         aCommand,
    1:                                    nsIChannel*         aChannel,
    1:                                    nsILoadGroup*       aLoadGroup,
    1:                                    nsISupports*        aContainer,
    1:                                    nsIStreamListener** aDocListener,
    1:                                    PRBool              aReset,
    1:                                    nsIContentSink*     aSink)
    1: {
    1:   nsresult rv = nsDocument::StartDocumentLoad(aCommand, aChannel, aLoadGroup,
    1:                                               aContainer, aDocListener, aReset,
    1:                                               aSink);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   // We try to set the charset of the current document to that of the 
    1:   // 'genuine' (as opposed to an intervening 'chrome') parent document 
    1:   // that may be in a different window/tab. Even if we fail here,
    1:   // we just return NS_OK because another attempt is made in 
    1:   // |UpdateTitleAndCharset| and the worst thing possible is a mangled 
    1:   // filename in the titlebar and the file picker.
    1: 
    1:   // When this document is opened in the window/tab of the referring 
    1:   // document (by a simple link-clicking), |prevDocCharacterSet| contains 
    1:   // the charset of the referring document. On the other hand, if the
    1:   // document is opened in a new window, it is |defaultCharacterSet| of |muCV| 
    1:   // where the charset of our interest is stored. In case of openining 
    1:   // in a new tab, we get the charset from |documentCharsetInfo|. Note that we 
    1:   // exclude UTF-8 as 'invalid' because UTF-8 is likely to be the charset 
    1:   // of a chrome document that has nothing to do with the actual content 
    1:   // whose charset we want to know. Even if "the actual content" is indeed 
    1:   // in UTF-8, we don't lose anything because the default empty value is 
    1:   // considered synonymous with UTF-8. 
    1:     
    1:   nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(aContainer));
    1: 
    1:   // not being able to set the charset is not critical.
    1:   NS_ENSURE_TRUE(docShell, NS_OK); 
    1: 
    1:   nsCOMPtr<nsIDocumentCharsetInfo> dcInfo;
    1:   nsCAutoString charset;
    1: 
    1:   docShell->GetDocumentCharsetInfo(getter_AddRefs(dcInfo));
    1:   if (dcInfo) {
    1:     nsCOMPtr<nsIAtom> csAtom;
    1:     dcInfo->GetParentCharset(getter_AddRefs(csAtom));
    1:     if (csAtom) {   // opening in a new tab
    1:       csAtom->ToUTF8String(charset);
    1:     }
    1:   }
    1: 
    1:   if (charset.IsEmpty() || charset.Equals("UTF-8")) {
    1:     nsCOMPtr<nsIContentViewer> cv;
    1:     docShell->GetContentViewer(getter_AddRefs(cv));
    1: 
    1:     // not being able to set the charset is not critical.
    1:     NS_ENSURE_TRUE(cv, NS_OK); 
    1:     nsCOMPtr<nsIMarkupDocumentViewer> muCV = do_QueryInterface(cv);
    1:     if (muCV) {
    1:       muCV->GetPrevDocCharacterSet(charset);   // opening in the same window/tab
    1:       if (charset.Equals("UTF-8") || charset.IsEmpty()) {
    1:         muCV->GetDefaultCharacterSet(charset); // opening in a new window
    1:       }
    1:     } 
    1:   }
    1: 
    1:   if (!charset.IsEmpty() && !charset.Equals("UTF-8")) {
    1:     SetDocumentCharacterSet(charset);
    1:     mCharacterSetSource = kCharsetFromUserDefault;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsMediaDocument::CreateSyntheticDocument()
    1: {
    1:   // Synthesize an empty html document
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsINodeInfo> nodeInfo;
19197:   nodeInfo = mNodeInfoManager->GetNodeInfo(nsGkAtoms::html, nsnull,
19197:                                            kNameSpaceID_None);
19747:   NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   nsRefPtr<nsGenericHTMLElement> root = NS_NewHTMLHtmlElement(nodeInfo);
    1:   if (!root) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   NS_ASSERTION(GetChildCount() == 0, "Shouldn't have any kids");
    1:   rv = AppendChildTo(root, PR_FALSE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
19197:   nodeInfo = mNodeInfoManager->GetNodeInfo(nsGkAtoms::head, nsnull,
19197:                                            kNameSpaceID_None);
19747:   NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
16977: 
16977:   // Create a <head> so our title has somewhere to live
16977:   nsRefPtr<nsGenericHTMLElement> head = NS_NewHTMLHeadElement(nodeInfo);
16977:   if (!head) {
16977:     return NS_ERROR_OUT_OF_MEMORY;
16977:   }
16977: 
16977:   root->AppendChildTo(head, PR_FALSE);
16977: 
19197:   nodeInfo = mNodeInfoManager->GetNodeInfo(nsGkAtoms::body, nsnull,
19197:                                            kNameSpaceID_None);
19747:   NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   nsRefPtr<nsGenericHTMLElement> body = NS_NewHTMLBodyElement(nodeInfo);
    1:   if (!body) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   root->AppendChildTo(body, PR_FALSE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsMediaDocument::StartLayout()
    1: {
10474:   mMayStartLayout = PR_TRUE;
 1722:   nsPresShellIterator iter(this);
 1722:   nsCOMPtr<nsIPresShell> shell;
 1722:   while ((shell = iter.GetNextShell())) {
23164:     if (shell->DidInitialReflow()) {
20733:       // Don't mess with this presshell: someone has already handled
20733:       // its initial reflow.
20733:       continue;
20733:     }
20733:     
    1:     nsRect visibleArea = shell->GetPresContext()->GetVisibleArea();
    1:     nsresult rv = shell->InitialReflow(visibleArea.width, visibleArea.height);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
 1416:     // Now trigger a refresh.  vm might be null if the presshell got
 1416:     // Destroy() called already.
    1:     nsIViewManager* vm = shell->GetViewManager();
    1:     if (vm) {
    1:       vm->EnableRefresh(NS_VMREFRESH_IMMEDIATE);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void 
    1: nsMediaDocument::UpdateTitleAndCharset(const nsACString& aTypeStr,
    1:                                        const char* const* aFormatNames,
    1:                                        PRInt32 aWidth, PRInt32 aHeight,
    1:                                        const nsAString& aStatus)
    1: {
    1:   nsXPIDLString fileStr;
    1:   if (mDocumentURI) {
    1:     nsCAutoString fileName;
    1:     nsCOMPtr<nsIURL> url = do_QueryInterface(mDocumentURI);
    1:     if (url)
    1:       url->GetFileName(fileName);
    1: 
    1:     nsCAutoString docCharset;
    1: 
    1:     // Now that the charset is set in |StartDocumentLoad| to the charset of
    1:     // the document viewer instead of a bogus value ("ISO-8859-1" set in
    1:     // |nsDocument|'s ctor), the priority is given to the current charset. 
    1:     // This is necessary to deal with a media document being opened in a new 
    1:     // window or a new tab, in which case |originCharset| of |nsIURI| is not 
    1:     // reliable.
    1:     if (mCharacterSetSource != kCharsetUninitialized) {  
    1:       docCharset = mCharacterSet;
    1:     }
    1:     else {  
    1:       // resort to |originCharset|
    1:       mDocumentURI->GetOriginCharset(docCharset);
    1:       SetDocumentCharacterSet(docCharset);
    1:     }
    1:     if (!fileName.IsEmpty()) {
    1:       nsresult rv;
    1:       nsCOMPtr<nsITextToSubURI> textToSubURI = 
    1:         do_GetService(NS_ITEXTTOSUBURI_CONTRACTID, &rv);
    1:       if (NS_SUCCEEDED(rv))
    1:         // UnEscapeURIForUI always succeeds
    1:         textToSubURI->UnEscapeURIForUI(docCharset, fileName, fileStr);
    1:       else 
    1:         CopyUTF8toUTF16(fileName, fileStr);
    1:     }
    1:   }
    1: 
    1: 
    1:   NS_ConvertASCIItoUTF16 typeStr(aTypeStr);
    1:   nsXPIDLString title;
    1: 
    1:   if (mStringBundle) {
    1:     // if we got a valid size (not all media have a size)
    1:     if (aWidth != 0 && aHeight != 0) {
    1:       nsAutoString widthStr;
    1:       nsAutoString heightStr;
    1:       widthStr.AppendInt(aWidth);
    1:       heightStr.AppendInt(aHeight);
    1:       // If we got a filename, display it
    1:       if (!fileStr.IsEmpty()) {
    1:         const PRUnichar *formatStrings[4]  = {fileStr.get(), typeStr.get(), 
    1:           widthStr.get(), heightStr.get()};
    1:         NS_ConvertASCIItoUTF16 fmtName(aFormatNames[eWithDimAndFile]);
    1:         mStringBundle->FormatStringFromName(fmtName.get(), formatStrings, 4,
    1:                                             getter_Copies(title));
    1:       } 
    1:       else {
    1:         const PRUnichar *formatStrings[3]  = {typeStr.get(), widthStr.get(), 
    1:           heightStr.get()};
    1:         NS_ConvertASCIItoUTF16 fmtName(aFormatNames[eWithDim]);
    1:         mStringBundle->FormatStringFromName(fmtName.get(), formatStrings, 3,
    1:                                             getter_Copies(title));
    1:       }
    1:     } 
    1:     else {
    1:     // If we got a filename, display it
    1:       if (!fileStr.IsEmpty()) {
    1:         const PRUnichar *formatStrings[2] = {fileStr.get(), typeStr.get()};
    1:         NS_ConvertASCIItoUTF16 fmtName(aFormatNames[eWithFile]);
    1:         mStringBundle->FormatStringFromName(fmtName.get(), formatStrings, 2,
    1:                                             getter_Copies(title));
    1:       }
    1:       else {
    1:         const PRUnichar *formatStrings[1] = {typeStr.get()};
    1:         NS_ConvertASCIItoUTF16 fmtName(aFormatNames[eWithNoInfo]);
    1:         mStringBundle->FormatStringFromName(fmtName.get(), formatStrings, 1,
    1:                                             getter_Copies(title));
    1:       }
    1:     }
    1:   } 
    1: 
    1:   // set it on the document
    1:   if (aStatus.IsEmpty()) {
    1:     SetTitle(title);
    1:   }
    1:   else {
    1:     nsXPIDLString titleWithStatus;
    1:     const nsPromiseFlatString& status = PromiseFlatString(aStatus);
    1:     const PRUnichar *formatStrings[2] = {title.get(), status.get()};
    1:     NS_NAMED_LITERAL_STRING(fmtName, "TitleWithStatus");
    1:     mStringBundle->FormatStringFromName(fmtName.get(), formatStrings, 2,
    1:                                         getter_Copies(titleWithStatus));
    1:     SetTitle(titleWithStatus);
    1:   }
    1: }
