29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jsstr_h___
    1: #define jsstr_h___
64345: 
    1: #include <ctype.h>
48470: #include "jsapi.h"
    1: #include "jsprvtd.h"
40281: #include "jshashtable.h"
29366: #include "jslock.h"
40901: #include "jsobj.h"
48470: #include "jsvalue.h"
54707: #include "jscell.h"
40337: 
64345: /*
64345:  * JS strings
64345:  *
64345:  * Conceptually, a JS string is just an array of chars and a length. To improve
64345:  * performance of common string operations, the following optimizations are
64345:  * made which affect the engine's representation of strings:
64345:  *
64345:  *  - The plain vanilla representation is a "flat" string which consists of a
64345:  *    string header in the GC heap and a malloc'd null terminated char array.
64345:  *
64345:  *  - To avoid copying a substring of an existing "base" string , a "dependent"
64345:  *    string (JSDependentString) can be created which points into the base
64345:  *    string's char array.
64345:  *
64345:  *  - To avoid O(n^2) char buffer copying, a "rope" node (JSRope) can be created
64345:  *    to represent a delayed string concatenation. Concatenation (called
64345:  *    flattening) is performed if and when a linear char array is requested. In
64345:  *    general, ropes form a binary dag whose internal nodes are JSRope string
64345:  *    headers with no associated char array and whose leaf nodes are either flat
64345:  *    or dependent strings.
64345:  *
64345:  *  - To avoid copying the left-hand side when flattening, the left-hand side's
64345:  *    buffer may be grown to make space for a copy of the right-hand side (see
64345:  *    comment in JSString::flatten). This optimization requires that there are
64345:  *    no external pointers into the char array. We conservatively maintain this
64345:  *    property via a flat string's "extensible" property.
64345:  *
64345:  *  - To avoid allocating small char arrays, short strings can be stored inline
67901:  *    in the string header (JSInlineString). To increase the max size of such
67901:  *    inline strings, extra-large string headers can be used (JSShortString).
64345:  *
64345:  *  - To avoid comparing O(n) string equality comparison, strings can be
64345:  *    canonicalized to "atoms" (JSAtom) such that there is a single atom with a
64345:  *    given (length,chars).
64345:  *
64345:  *  - To avoid dynamic creation of common short strings (e.g., single-letter
64345:  *    alphanumeric strings, numeric strings up to 999) headers and char arrays
64345:  *    for such strings are allocated in static memory (JSStaticAtom) and used
64345:  *    as atoms.
64345:  *
64345:  *  - To avoid copying all strings created through the JSAPI, an "external"
64345:  *    string (JSExternalString) can be created whose chars are managed by the
64345:  *    JSAPI client.
64345:  *
64345:  * Although all strings share the same basic memory layout, we can conceptually
64345:  * arrange them into a hierarchy of operations/invariants and represent this
64345:  * hierarchy in C++ with classes:
64345:  *
64345:  * C++ type                     operations+fields / invariants+properties
64345:  *
64345:  * JSString (abstract)          getCharsZ, getChars, length / -
64345:  *  | \
64345:  *  | JSRope                    leftChild, rightChild / -
64345:  *  |
64345:  * JSLinearString (abstract)    chars / not null-terminated
64345:  *  | \
64345:  *  | JSDependentString         base / -
64345:  *  |
64345:  * JSFlatString (abstract)      chars / not null-terminated
64345:  *  | \
64345:  *  | JSExtensibleString        capacity / no external pointers into char array
64345:  *  |
64345:  * JSFixedString                - / may have external pointers into char array
64345:  *  | \  \
67901:  *  |  \ JSExternalString       - / char array memory managed by embedding
64345:  *  |   \
67901:  *  |   JSInlineString          - / chars stored in header
67901:  *  |     | \
67901:  *  |     | JSShortString       - / header is fat
67901:  *  |     |        |
67901:  * JSAtom |        |            - / string equality === pointer equality
67901:  *  | \   |        |
67901:  *  | JSInlineAtom |            - / atomized JSInlineString
64345:  *  |       \      |
64345:  *  |       JSShortAtom         - / atomized JSShortString
64345:  *  |
64345:  * JSStaticAtom                 - / header and chars statically allocated
64345:  *
64345:  * Classes marked with (abstract) above are not literally C++ Abstract Base
64345:  * Classes (since there are no virtual functions, pure or not, in this
64345:  * hierarchy), but have the same meaning: there are no strings with this type as
64345:  * its most-derived type.
64345:  *
64345:  * Derived string types can be queried from ancestor types via isX() and
64345:  * retrieved with asX() debug-only-checked casts.
64345:  *
64345:  * The ensureX() operations mutate 'this' in place to effectively the type to be
64345:  * at least X (e.g., ensureLinear will change a JSRope to be a JSFlatString).
64345:  */
30275: 
64345: class JSString : public js::gc::Cell
64345: {
64345:   protected:
64345:     static const size_t NUM_INLINE_CHARS = 2 * sizeof(void *) / sizeof(jschar);
29366: 
64345:     /* Fields only apply to string types commented on the right. */
64345:     struct Data
59888:     {
64345:         size_t                     lengthAndFlags;      /* JSString */
48491:         union {
64345:             const jschar           *chars;              /* JSLinearString */
64345:             JSString               *left;               /* JSRope */
64345:         } u1;
59888:         union {
67901:             jschar                 inlineStorage[NUM_INLINE_CHARS]; /* JS(Inline|Short)String */
59888:             struct {
59888:                 union {
64345:                     JSLinearString *base;               /* JSDependentString */
64345:                     JSString       *right;              /* JSRope */
64345:                     size_t         capacity;            /* JSFlatString (extensible) */
64345:                     size_t         externalStringType;  /* JSExternalString */
64345:                 } u2;
64345:                 union {
64345:                     JSString       *parent;             /* JSRope (temporary) */
64345:                     size_t         reserved;            /* may use for bug 615290 */
64345:                 } u3;
64345:             } s;
48491:         };
64345:     } d;
    1: 
64345:   public:
64345:     /* Flags exposed only for jits */
64343: 
59888:     static const size_t LENGTH_SHIFT      = 4;
64343:     static const size_t FLAGS_MASK        = JS_BITMASK(LENGTH_SHIFT);
64343:     static const size_t MAX_LENGTH        = JS_BIT(32 - LENGTH_SHIFT) - 1;
48491: 
64345:     /*
64345:      * The low LENGTH_SHIFT bits of lengthAndFlags are used to encode the type
64345:      * of the string.  The remaining bits store the string length (which must be
64345:      * less or equal than MAX_LENGTH).
64345:      * 
64345:      * Instead of using a dense index to represent the most-derived type, string
64345:      * types are encoded to allow single-op tests for hot queries (isRope,
64345:      * isDependent, isFlat, isAtom, isStaticAtom):
64345:      *
64345:      *   JSRope                xxx1
64345:      *   JSLinearString        xxx0
64345:      *   JSDependentString     xx1x
64345:      *   JSFlatString          xx00
64345:      *   JSExtensibleString    1100
64345:      *   JSFixedString         xy00 where xy != 11
67901:      *   JSInlineString        0100 and chars == inlineStorage
64345:      *   JSShortString         0100 and in FINALIZE_SHORT_STRING arena
64345:      *   JSExternalString      0100 and in FINALIZE_EXTERNAL_STRING arena
64345:      *   JSAtom                x000
64345:      *   JSStaticAtom          0000
64345:      *
64345:      * NB: this scheme takes advantage of the fact that there are no string
64345:      * instances whose most-derived type is JSString, JSLinearString, or
64345:      * JSFlatString.
64345:      */
64345: 
64345:     static const size_t ROPE_BIT          = JS_BIT(0);
64345: 
64343:     static const size_t LINEAR_MASK       = JS_BITMASK(1);
64343:     static const size_t LINEAR_FLAGS      = 0x0;
48491: 
64345:     static const size_t DEPENDENT_BIT     = JS_BIT(1);
64345: 
64343:     static const size_t FLAT_MASK         = JS_BITMASK(2);
64343:     static const size_t FLAT_FLAGS        = 0x0;
48491: 
64345:     static const size_t FIXED_FLAGS       = JS_BIT(2);
64345: 
64343:     static const size_t ATOM_MASK         = JS_BITMASK(3);
64343:     static const size_t ATOM_FLAGS        = 0x0;
48491: 
64343:     static const size_t STATIC_ATOM_MASK  = JS_BITMASK(4);
64343:     static const size_t STATIC_ATOM_FLAGS = 0x0;
64343: 
64343:     static const size_t EXTENSIBLE_FLAGS  = JS_BIT(2) | JS_BIT(3);
64343:     static const size_t NON_STATIC_ATOM   = JS_BIT(3);
 4718: 
59888:     size_t buildLengthAndFlags(size_t length, size_t flags) {
59888:         return (length << LENGTH_SHIFT) | flags;
29366:     }
 4718: 
64345:     static void staticAsserts() {
64345:         JS_STATIC_ASSERT(size_t(JSString::MAX_LENGTH) <= size_t(JSVAL_INT_MAX));
64345:         JS_STATIC_ASSERT(JSString::MAX_LENGTH <= JSVAL_INT_MAX);
64345:         JS_STATIC_ASSERT(JS_BITS_PER_WORD >= 32);
64345:         JS_STATIC_ASSERT(((JSString::MAX_LENGTH << JSString::LENGTH_SHIFT) >>
64345:                            JSString::LENGTH_SHIFT) == JSString::MAX_LENGTH);
64345:         JS_STATIC_ASSERT(sizeof(JSString) ==
64345:                          offsetof(JSString, d.inlineStorage) +
64345:                          NUM_INLINE_CHARS * sizeof(jschar));
54707:     }
54707: 
64345:     /* Avoid lame compile errors in JSRope::flatten */
64345:     friend class JSRope;
64345: 
64345:   public:
64345:     /* All strings have length. */
64345: 
64345:     JS_ALWAYS_INLINE
64345:     size_t length() const {
64345:         return d.lengthAndFlags >> LENGTH_SHIFT;
54707:     }
54707: 
64345:     JS_ALWAYS_INLINE
64345:     bool empty() const {
64345:         return d.lengthAndFlags <= FLAGS_MASK;
64343:     }
27471: 
64345:     /*
64345:      * All strings have a fallible operation to get an array of chars.
64345:      * getCharsZ additionally ensures the array is null terminated.
64345:      */
64345: 
64345:     inline const jschar *getChars(JSContext *cx);
64345:     inline const jschar *getCharsZ(JSContext *cx);
64345: 
64345:     /* Fallible conversions to more-derived string types. */
64345: 
64345:     inline JSLinearString *ensureLinear(JSContext *cx);
64345:     inline JSFlatString *ensureFlat(JSContext *cx);
64345:     inline JSFixedString *ensureFixed(JSContext *cx);
64345: 
64345:     /* Type query and debug-checked casts */
64345: 
64345:     JS_ALWAYS_INLINE
64345:     bool isRope() const {
64345:         bool rope = d.lengthAndFlags & ROPE_BIT;
64345:         JS_ASSERT_IF(rope, (d.lengthAndFlags & FLAGS_MASK) == ROPE_BIT);
64343:         return rope;
29366:     }
27471: 
64345:     JS_ALWAYS_INLINE
64345:     JSRope &asRope() {
64345:         JS_ASSERT(isRope());
64345:         return *(JSRope *)this;
64343:     }
64343: 
64345:     JS_ALWAYS_INLINE
64345:     bool isLinear() const {
64345:         return (d.lengthAndFlags & LINEAR_MASK) == LINEAR_FLAGS;
64345:     }
64345: 
64345:     JS_ALWAYS_INLINE
64345:     JSLinearString &asLinear() {
64345:         JS_ASSERT(isLinear());
64345:         return *(JSLinearString *)this;
64345:     }
64345: 
64345:     JS_ALWAYS_INLINE
64345:     bool isDependent() const {
64345:         bool dependent = d.lengthAndFlags & DEPENDENT_BIT;
64345:         JS_ASSERT_IF(dependent, (d.lengthAndFlags & FLAGS_MASK) == DEPENDENT_BIT);
64343:         return dependent;
64343:     }
64343: 
64345:     JS_ALWAYS_INLINE
64345:     JSDependentString &asDependent() {
64345:         JS_ASSERT(isDependent());
64345:         return *(JSDependentString *)this;
64345:     }
64345: 
64345:     JS_ALWAYS_INLINE
64345:     bool isFlat() const {
64345:         return (d.lengthAndFlags & FLAT_MASK) == FLAT_FLAGS;
64345:     }
64345: 
64345:     JS_ALWAYS_INLINE
64345:     JSFlatString &asFlat() {
64345:         JS_ASSERT(isFlat());
64345:         return *(JSFlatString *)this;
64345:     }
64345: 
64345:     JS_ALWAYS_INLINE
64345:     bool isExtensible() const {
64345:         return (d.lengthAndFlags & FLAGS_MASK) == EXTENSIBLE_FLAGS;
64345:     }
64345: 
64345:     JS_ALWAYS_INLINE
64345:     JSExtensibleString &asExtensible() const {
64345:         JS_ASSERT(isExtensible());
64345:         return *(JSExtensibleString *)this;
64345:     }
64345: 
64345: #ifdef DEBUG
64345:     bool isShort() const;
64345:     bool isFixed() const;
64345: #endif
64345: 
64345:     JS_ALWAYS_INLINE
64345:     JSFixedString &asFixed() {
64345:         JS_ASSERT(isFixed());
64345:         return *(JSFixedString *)this;
64345:     }
64345: 
64345:     JS_ALWAYS_INLINE
64345:     bool isAtom() const {
64345:         bool atomized = (d.lengthAndFlags & ATOM_MASK) == ATOM_FLAGS;
64343:         JS_ASSERT_IF(atomized, isFlat());
64343:         return atomized;
64343:     }
64343: 
64345:     JS_ALWAYS_INLINE
64345:     JSAtom &asAtom() const {
64345:         JS_ASSERT(isAtom());
64345:         return *(JSAtom *)this;
64343:     }
64343: 
64345:     JS_ALWAYS_INLINE
64345:     bool isStaticAtom() const {
64345:         return (d.lengthAndFlags & FLAGS_MASK) == STATIC_ATOM_FLAGS;
29366:     }
27471: 
64345:     /* Only called by the GC for strings with the FINALIZE_STRING kind. */
10444: 
64345:     inline void finalize(JSContext *cx);
29366: 
64345:     /* Called during GC for any string. */
29366: 
64345:     inline void mark(JSTracer *trc);
29366: 
64345:     /* Offsets for direct field from jit code. */
59888: 
59888:     static size_t offsetOfLengthAndFlags() {
64345:         return offsetof(JSString, d.lengthAndFlags);
59888:     }
59888: 
59888:     static size_t offsetOfChars() {
64345:         return offsetof(JSString, d.u1.chars);
59888:     }
29366: };
    1: 
64345: class JSRope : public JSString
59889: {
64345:     friend class JSString;
64345:     JSFlatString *flatten(JSContext *cx);
64345: 
64345:     void init(JSString *left, JSString *right, size_t length);
64345: 
64345:   public:
64345:     static inline JSRope *new_(JSContext *cx, JSString *left,
64345:                                JSString *right, size_t length);
64345: 
64345:     inline JSString *leftChild() const {
64345:         JS_ASSERT(isRope());
64345:         return d.u1.left;
64345:     }
64345: 
64345:     inline JSString *rightChild() const {
64345:         JS_ASSERT(isRope());
64345:         return d.s.u2.right;
64345:     }
64345: };
64345: 
64345: JS_STATIC_ASSERT(sizeof(JSRope) == sizeof(JSString));
64345: 
64345: class JSLinearString : public JSString
64345: {
64345:     friend class JSString;
64345:     inline void mark(JSTracer *trc);
64345: 
64345:   public:
64345:     JS_ALWAYS_INLINE
64345:     const jschar *chars() const {
64345:         JS_ASSERT(isLinear());
64345:         return d.u1.chars;
64345:     }
59890: };
59890: 
59890: JS_STATIC_ASSERT(sizeof(JSLinearString) == sizeof(JSString));
59890: 
64345: class JSDependentString : public JSLinearString
59890: {
64345:     friend class JSString;
64345:     JSFixedString *undepend(JSContext *cx);
64345: 
64345:     void init(JSLinearString *base, const jschar *chars, size_t length);
64345: 
64345:   public:
64345:     static inline JSDependentString *new_(JSContext *cx, JSLinearString *base,
64345:                                           const jschar *chars, size_t length);
64345: 
64345:     JSLinearString *base() const {
64345:         JS_ASSERT(isDependent());
64345:         return d.s.u2.base;
64345:     }
64345: };
64345: 
64345: JS_STATIC_ASSERT(sizeof(JSDependentString) == sizeof(JSString));
64345: 
64345: class JSFlatString : public JSLinearString
64345: {
64345:     friend class JSRope;
64345:     void morphExtensibleIntoDependent(JSLinearString *base) {
64345:         d.lengthAndFlags = buildLengthAndFlags(length(), DEPENDENT_BIT);
64345:         d.s.u2.base = base;
64345:     }
64345: 
64345:   public:
64345:     JS_ALWAYS_INLINE
64345:     const jschar *charsZ() const {
64345:         JS_ASSERT(isFlat());
64345:         return chars();
64345:     }
67900: 
67900:     /* Only called by the GC for strings with the FINALIZE_STRING kind. */
67900: 
67900:     inline void finalize(JSRuntime *rt);
59889: };
59889: 
59889: JS_STATIC_ASSERT(sizeof(JSFlatString) == sizeof(JSString));
59889: 
64345: class JSExtensibleString : public JSFlatString
59890: {
64345:   public:
64345:     JS_ALWAYS_INLINE
64345:     size_t capacity() const {
64345:         JS_ASSERT(isExtensible());
64345:         return d.s.u2.capacity;
64345:     }
59890: };
59890: 
64345: JS_STATIC_ASSERT(sizeof(JSExtensibleString) == sizeof(JSString));
64345: 
64345: class JSFixedString : public JSFlatString
59888: {
64345:     void init(const jschar *chars, size_t length);
64345: 
64345:   public:
64345:     static inline JSFixedString *new_(JSContext *cx, const jschar *chars, size_t length);
64345: 
64345:     /*
64345:      * Once a JSFixedString has been added to the atom table, this operation
64345:      * changes the type (in place) of the JSFixedString into a JSAtom.
64345:      */
64345:     inline JSAtom *morphInternedStringIntoAtom();
64345: };
64345: 
64345: JS_STATIC_ASSERT(sizeof(JSFixedString) == sizeof(JSString));
64345: 
67901: class JSInlineString : public JSFixedString
67901: {
67901:     static const size_t MAX_INLINE_LENGTH = NUM_INLINE_CHARS - 1;
67901: 
67901:   public:
67901:     static inline JSInlineString *new_(JSContext *cx);
67901: 
67901:     inline jschar *init(size_t length);
67901: 
67901:     inline void resetLength(size_t length);
67901: 
67901:     static bool lengthFits(size_t length) {
67901:         return length <= MAX_INLINE_LENGTH;
67901:     }
67901: 
67901: };
67901: 
67901: JS_STATIC_ASSERT(sizeof(JSInlineString) == sizeof(JSString));
67901: 
67901: class JSShortString : public JSInlineString
67901: {
67901:     /* This can be any value that is a multiple of sizeof(gc::FreeCell). */
67901:     static const size_t INLINE_EXTENSION_CHARS = sizeof(JSString::Data) / sizeof(jschar);
67901: 
67901:     static void staticAsserts() {
67901:         JS_STATIC_ASSERT(INLINE_EXTENSION_CHARS % sizeof(js::gc::FreeCell) == 0);
67901:         JS_STATIC_ASSERT(MAX_SHORT_LENGTH + 1 ==
67901:                          (sizeof(JSShortString) -
67901:                           offsetof(JSShortString, d.inlineStorage)) / sizeof(jschar));
67901:     }
67901: 
67901:     jschar inlineStorageExtension[INLINE_EXTENSION_CHARS];
67901: 
67901:   public:
67901:     static inline JSShortString *new_(JSContext *cx);
67901: 
67901:     jschar *inlineStorageBeforeInit() {
67901:         return d.inlineStorage;
67901:     }
67901: 
67901:     inline void initAtOffsetInBuffer(const jschar *chars, size_t length);
67901: 
67901:     static const size_t MAX_SHORT_LENGTH = JSString::NUM_INLINE_CHARS +
67901:                                            INLINE_EXTENSION_CHARS
67901:                                            -1 /* null terminator */;
67901: 
67901:     static bool lengthFits(size_t length) {
67901:         return length <= MAX_SHORT_LENGTH;
67901:     }
67901: 
67901:     /* Only called by the GC for strings with the FINALIZE_EXTERNAL_STRING kind. */
67901: 
67901:     JS_ALWAYS_INLINE void finalize(JSContext *cx);
67901: };
67901: 
67901: JS_STATIC_ASSERT(sizeof(JSShortString) == 2 * sizeof(JSString));
67901: 
64345: class JSExternalString : public JSFixedString
64345: {
64345:     static void staticAsserts() {
64345:         JS_STATIC_ASSERT(TYPE_LIMIT == 8);
64345:     }
64345: 
64345:     void init(const jschar *chars, size_t length, intN type);
64345: 
64345:   public:
64345:     static inline JSExternalString *new_(JSContext *cx, const jschar *chars,
64345:                                          size_t length, intN type);
64345: 
64345:     intN externalStringType() const {
64345:         JS_ASSERT(isFlat() && !isAtom());
64345:         JS_ASSERT(d.s.u2.externalStringType < TYPE_LIMIT);
64345:         return d.s.u2.externalStringType;
64345:     }
64345: 
57817:     static const uintN TYPE_LIMIT = 8;
57817:     static JSStringFinalizeOp str_finalizers[TYPE_LIMIT];
57817: 
57817:     static intN changeFinalizer(JSStringFinalizeOp oldop,
57817:                                 JSStringFinalizeOp newop) {
57817:         for (uintN i = 0; i != JS_ARRAY_LENGTH(str_finalizers); i++) {
57817:             if (str_finalizers[i] == oldop) {
57817:                 str_finalizers[i] = newop;
57817:                 return intN(i);
57817:             }
57817:         }
57817:         return -1;
57817:     }
57817: 
64345:     /* Only called by the GC for strings with the FINALIZE_EXTERNAL_STRING kind. */
64345: 
57817:     void finalize(JSContext *cx);
57817:     void finalize();
57817: };
57817: 
64345: JS_STATIC_ASSERT(sizeof(JSExternalString) == sizeof(JSString));
57817: 
64345: class JSAtom : public JSFixedString
64345: {
64345:   public:
64345:     /* Exposed only for jits. */
64345: 
64345:     static const size_t UNIT_STATIC_LIMIT   = 256U;
64345:     static const size_t SMALL_CHAR_LIMIT    = 128U; /* Bigger chars cannot be in a length-2 string. */
64345:     static const size_t NUM_SMALL_CHARS     = 64U;
64345:     static const size_t INT_STATIC_LIMIT    = 256U;
64345:     static const size_t NUM_HUNDRED_STATICS = 156U;
64345: 
64345: #ifdef __SUNPRO_CC
64345: # pragma align 8 (__1cGJSAtomPunitStaticTable_, __1cGJSAtomSlength2StaticTable_, __1cGJSAtomShundredStaticTable_)
64345: #endif
64345:     static const JSString::Data unitStaticTable[];
64345:     static const JSString::Data length2StaticTable[];
64345:     static const JSString::Data hundredStaticTable[];
64345:     static const JSString::Data *const intStaticTable[];
64345: 
64345:   private:
64345:     /* Defined in jsgcinlines.h */
64356:     static inline bool isUnitString(const void *ptr);
64356:     static inline bool isLength2String(const void *ptr);
64356:     static inline bool isHundredString(const void *ptr);
64345: 
64345:     typedef uint8 SmallChar;
64345:     static const SmallChar INVALID_SMALL_CHAR = -1;
64345: 
64345:     static inline bool fitsInSmallChar(jschar c);
64345: 
64345:     static const jschar fromSmallChar[];
64345:     static const SmallChar toSmallChar[];
64345: 
64345:     static void staticAsserts() {
64345:         JS_STATIC_ASSERT(sizeof(JSString::Data) == sizeof(JSString));
64345:     }
64345: 
64345:     static JSStaticAtom &length2Static(jschar c1, jschar c2);
64345:     static JSStaticAtom &length2Static(uint32 i);
48563: 
59888:   public:
48563:     /*
64345:      * While this query can be used for any pointer to GC thing, given a
64345:      * JSString 'str', it is more efficient to use 'str->isStaticAtom()'.
48563:      */
64356:     static inline bool isStatic(const void *ptr);
64345: 
64345:     static inline bool hasIntStatic(int32 i);
64345:     static inline JSStaticAtom &intStatic(jsint i);
64345: 
64345:     static inline bool hasUnitStatic(jschar c);
64345:     static JSStaticAtom &unitStatic(jschar c);
64345: 
64345:     /* May not return atom, returns null on (reported) failure. */
64345:     static inline JSLinearString *getUnitStringForElement(JSContext *cx, JSString *str, size_t index);
64345: 
64345:     /* Return null if no static atom exists for the given (chars, length). */
64345:     static inline JSStaticAtom *lookupStatic(const jschar *chars, size_t length);
67900: 
67900:     inline void finalize(JSRuntime *rt);
64345: };
64345: 
64345: JS_STATIC_ASSERT(sizeof(JSAtom) == sizeof(JSString));
64345: 
67901: class JSInlineAtom : public JSInlineString /*, JSAtom */
67901: {
67901:     /*
67901:      * JSInlineAtom is not explicitly used and is only present for consistency.
67901:      * See Atomize() for how JSInlineStrings get morphed into JSInlineAtoms.
67901:      */
67901: };
67901: 
67901: JS_STATIC_ASSERT(sizeof(JSInlineAtom) == sizeof(JSInlineString));
67901: 
67901: class JSShortAtom : public JSShortString /*, JSInlineAtom */
64345: {
64345:     /*
64345:      * JSShortAtom is not explicitly used and is only present for consistency.
64345:      * See Atomize() for how JSShortStrings get morphed into JSShortAtoms.
64345:      */
64345: };
64345: 
64345: JS_STATIC_ASSERT(sizeof(JSShortAtom) == sizeof(JSShortString));
64345: 
64345: class JSStaticAtom : public JSAtom
64345: {};
64345: 
64345: JS_STATIC_ASSERT(sizeof(JSStaticAtom) == sizeof(JSString));
64345: 
64345: /* Avoid requring jsstrinlines.h just to call getChars. */
64345: 
64345: JS_ALWAYS_INLINE const jschar *
64345: JSString::getChars(JSContext *cx)
64345: {
64345:     return ensureLinear(cx)->chars();
48563: }
48563: 
64345: JS_ALWAYS_INLINE const jschar *
64345: JSString::getCharsZ(JSContext *cx)
64345: {
64345:     return ensureFlat(cx)->chars();
57735: }
57735: 
64345: JS_ALWAYS_INLINE JSLinearString *
64345: JSString::ensureLinear(JSContext *cx)
64345: {
64345:     return isLinear()
64345:            ? &asLinear()
64345:            : asRope().flatten(cx);
57735: }
57735: 
64345: JS_ALWAYS_INLINE JSFlatString *
64345: JSString::ensureFlat(JSContext *cx)
64345: {
64345:     return isFlat()
64345:            ? &asFlat()
64345:            : isDependent()
64345:              ? asDependent().undepend(cx)
64345:              : asRope().flatten(cx);
48563: }
48563: 
64345: JS_ALWAYS_INLINE JSFixedString *
64345: JSString::ensureFixed(JSContext *cx)
64345: {
64345:     if (!ensureFlat(cx))
64345:         return NULL;
64345:     if (isExtensible()) {
64345:         JS_ASSERT((d.lengthAndFlags & FLAT_MASK) == 0);
64345:         JS_STATIC_ASSERT(EXTENSIBLE_FLAGS == (JS_BIT(2) | JS_BIT(3)));
64345:         JS_STATIC_ASSERT(FIXED_FLAGS == JS_BIT(2));
64345:         d.lengthAndFlags ^= JS_BIT(3);
48563:     }
64345:     return &asFixed();
48563: }
54707: 
59888: namespace js {
59888: 
64345: /* Implemented in jsstrinlines.h */
60571: class StringBuffer;
60571: 
48536: /*
59888:  * When an algorithm does not need a string represented as a single linear
59888:  * array of characters, this range utility may be used to traverse the string a
59888:  * sequence of linear arrays of characters. This avoids flattening ropes.
59888:  *
59888:  * Implemented in jsstrinlines.h.
48536:  */
59888: class StringSegmentRange;
59890: class MutatingRopeSegmentRange;
48536: 
59888: /*
59888:  * Utility for building a rope (lazy concatenation) of strings.
59888:  */
59888: class RopeBuilder;
48536: 
59888: }  /* namespace js */
48491: 
64345: extern JSString * JS_FASTCALL
64345: js_ConcatStrings(JSContext *cx, JSString *s1, JSString *s2);
 4718: 
18703: extern JSString * JS_FASTCALL
18703: js_toLowerCase(JSContext *cx, JSString *str);
18703: 
18703: extern JSString * JS_FASTCALL
18703: js_toUpperCase(JSContext *cx, JSString *str);
18703: 
    1: struct JSSubString {
    1:     size_t          length;
    1:     const jschar    *chars;
    1: };
    1: 
    1: extern jschar      js_empty_ucstr[];
    1: extern JSSubString js_EmptySubString;
    1: 
    1: /* Unicode character attribute lookup tables. */
    1: extern const uint8 js_X[];
    1: extern const uint8 js_Y[];
    1: extern const uint32 js_A[];
    1: 
    1: /* Enumerated Unicode general category types. */
    1: typedef enum JSCharType {
    1:     JSCT_UNASSIGNED             = 0,
    1:     JSCT_UPPERCASE_LETTER       = 1,
    1:     JSCT_LOWERCASE_LETTER       = 2,
    1:     JSCT_TITLECASE_LETTER       = 3,
    1:     JSCT_MODIFIER_LETTER        = 4,
    1:     JSCT_OTHER_LETTER           = 5,
    1:     JSCT_NON_SPACING_MARK       = 6,
    1:     JSCT_ENCLOSING_MARK         = 7,
    1:     JSCT_COMBINING_SPACING_MARK = 8,
    1:     JSCT_DECIMAL_DIGIT_NUMBER   = 9,
    1:     JSCT_LETTER_NUMBER          = 10,
    1:     JSCT_OTHER_NUMBER           = 11,
    1:     JSCT_SPACE_SEPARATOR        = 12,
    1:     JSCT_LINE_SEPARATOR         = 13,
    1:     JSCT_PARAGRAPH_SEPARATOR    = 14,
    1:     JSCT_CONTROL                = 15,
    1:     JSCT_FORMAT                 = 16,
    1:     JSCT_PRIVATE_USE            = 18,
    1:     JSCT_SURROGATE              = 19,
    1:     JSCT_DASH_PUNCTUATION       = 20,
    1:     JSCT_START_PUNCTUATION      = 21,
    1:     JSCT_END_PUNCTUATION        = 22,
    1:     JSCT_CONNECTOR_PUNCTUATION  = 23,
    1:     JSCT_OTHER_PUNCTUATION      = 24,
    1:     JSCT_MATH_SYMBOL            = 25,
    1:     JSCT_CURRENCY_SYMBOL        = 26,
    1:     JSCT_MODIFIER_SYMBOL        = 27,
    1:     JSCT_OTHER_SYMBOL           = 28
    1: } JSCharType;
    1: 
    1: /* Character classifying and mapping macros, based on java.lang.Character. */
    1: #define JS_CCODE(c)     (js_A[js_Y[(js_X[(uint16)(c)>>6]<<6)|((c)&0x3F)]])
    1: #define JS_CTYPE(c)     (JS_CCODE(c) & 0x1F)
    1: 
    1: #define JS_ISALPHA(c)   ((((1 << JSCT_UPPERCASE_LETTER) |                     \
    1:                            (1 << JSCT_LOWERCASE_LETTER) |                     \
    1:                            (1 << JSCT_TITLECASE_LETTER) |                     \
    1:                            (1 << JSCT_MODIFIER_LETTER) |                      \
    1:                            (1 << JSCT_OTHER_LETTER))                          \
    1:                           >> JS_CTYPE(c)) & 1)
    1: 
    1: #define JS_ISALNUM(c)   ((((1 << JSCT_UPPERCASE_LETTER) |                     \
    1:                            (1 << JSCT_LOWERCASE_LETTER) |                     \
    1:                            (1 << JSCT_TITLECASE_LETTER) |                     \
    1:                            (1 << JSCT_MODIFIER_LETTER) |                      \
    1:                            (1 << JSCT_OTHER_LETTER) |                         \
    1:                            (1 << JSCT_DECIMAL_DIGIT_NUMBER))                  \
    1:                           >> JS_CTYPE(c)) & 1)
    1: 
    1: /* A unicode letter, suitable for use in an identifier. */
    1: #define JS_ISLETTER(c)   ((((1 << JSCT_UPPERCASE_LETTER) |                    \
    1:                             (1 << JSCT_LOWERCASE_LETTER) |                    \
    1:                             (1 << JSCT_TITLECASE_LETTER) |                    \
    1:                             (1 << JSCT_MODIFIER_LETTER) |                     \
    1:                             (1 << JSCT_OTHER_LETTER) |                        \
    1:                             (1 << JSCT_LETTER_NUMBER))                        \
    1:                            >> JS_CTYPE(c)) & 1)
    1: 
    1: /*
    1:  * 'IdentifierPart' from ECMA grammar, is Unicode letter or combining mark or
    1:  * digit or connector punctuation.
    1:  */
    1: #define JS_ISIDPART(c)  ((((1 << JSCT_UPPERCASE_LETTER) |                     \
    1:                            (1 << JSCT_LOWERCASE_LETTER) |                     \
    1:                            (1 << JSCT_TITLECASE_LETTER) |                     \
    1:                            (1 << JSCT_MODIFIER_LETTER) |                      \
    1:                            (1 << JSCT_OTHER_LETTER) |                         \
    1:                            (1 << JSCT_LETTER_NUMBER) |                        \
    1:                            (1 << JSCT_NON_SPACING_MARK) |                     \
    1:                            (1 << JSCT_COMBINING_SPACING_MARK) |               \
    1:                            (1 << JSCT_DECIMAL_DIGIT_NUMBER) |                 \
    1:                            (1 << JSCT_CONNECTOR_PUNCTUATION))                 \
    1:                           >> JS_CTYPE(c)) & 1)
    1: 
    1: /* Unicode control-format characters, ignored in input */
    1: #define JS_ISFORMAT(c) (((1 << JSCT_FORMAT) >> JS_CTYPE(c)) & 1)
    1: 
    1: /*
30451:  * This table is used in JS_ISWORD.  The definition has external linkage to
30451:  * allow the raw table data to be used in the regular expression compiler.
    1:  */
30451: extern const bool js_alnum[];
30451: 
30451: /*
30451:  * This macro performs testing for the regular expression word class \w, which
30451:  * is defined by ECMA-262 15.10.2.6 to be [0-9A-Z_a-z].  If we want a
30451:  * Unicode-friendlier definition of "word", we should rename this macro to
30451:  * something regexp-y.
30451:  */
30451: #define JS_ISWORD(c)    ((c) < 128 && js_alnum[(c)])
    1: 
64310: extern const bool js_isidstart[];
64310: extern const bool js_isident[];
64310: 
64310: static inline bool
64310: JS_ISIDSTART(int c)
64310: {
64310:     unsigned w = c;
64310: 
64310:     return (w < 128) ? js_isidstart[w] : JS_ISLETTER(c);
64310: }
64310: 
64310: static inline bool
64310: JS_ISIDENT(int c)
64310: {
64310:     unsigned w = c;
64310: 
64310:     return (w < 128) ? js_isident[w] : JS_ISIDPART(c);
64310: }
    1: 
    1: #define JS_ISXMLSPACE(c)        ((c) == ' ' || (c) == '\t' || (c) == '\r' ||  \
    1:                                  (c) == '\n')
    1: #define JS_ISXMLNSSTART(c)      ((JS_CCODE(c) & 0x00000100) || (c) == '_')
    1: #define JS_ISXMLNS(c)           ((JS_CCODE(c) & 0x00000080) || (c) == '.' ||  \
    1:                                  (c) == '-' || (c) == '_')
    1: #define JS_ISXMLNAMESTART(c)    (JS_ISXMLNSSTART(c) || (c) == ':')
    1: #define JS_ISXMLNAME(c)         (JS_ISXMLNS(c) || (c) == ':')
    1: 
    1: #define JS_ISDIGIT(c)   (JS_CTYPE(c) == JSCT_DECIMAL_DIGIT_NUMBER)
    1: 
48545: const jschar BYTE_ORDER_MARK = 0xFEFF;
48545: const jschar NO_BREAK_SPACE  = 0x00A0;
48545: 
64309: extern const bool js_isspace[];
64309: 
32608: static inline bool
64309: JS_ISSPACE(int c)
32608: {
32614:     unsigned w = c;
32610: 
64309:     return (w < 128)
64309:            ? js_isspace[w]
64309:            : w == NO_BREAK_SPACE || w == BYTE_ORDER_MARK ||
64309:              (JS_CCODE(w) & 0x00070000) == 0x00040000;
64309: }
32610: 
64309: static inline bool
64309: JS_ISSPACE_OR_BOM(int c)
64309: {
64309:     unsigned w = c;
64309: 
64309:     /* Treat little- and big-endian BOMs as whitespace for compatibility. */
64309:     return (w < 128)
64309:            ? js_isspace[w]
64309:            : w == NO_BREAK_SPACE || w == BYTE_ORDER_MARK ||
64309:              (JS_CCODE(w) & 0x00070000) == 0x00040000 || w == 0xfffe || w == 0xfeff;
32608: }
32608: 
    1: #define JS_ISPRINT(c)   ((c) < 128 && isprint(c))
    1: 
    1: #define JS_ISUPPER(c)   (JS_CTYPE(c) == JSCT_UPPERCASE_LETTER)
    1: #define JS_ISLOWER(c)   (JS_CTYPE(c) == JSCT_LOWERCASE_LETTER)
    1: 
    1: #define JS_TOUPPER(c)   ((jschar) ((JS_CCODE(c) & 0x00100000)                 \
    1:                                    ? (c) - ((int32)JS_CCODE(c) >> 22)         \
    1:                                    : (c)))
    1: #define JS_TOLOWER(c)   ((jschar) ((JS_CCODE(c) & 0x00200000)                 \
    1:                                    ? (c) + ((int32)JS_CCODE(c) >> 22)         \
    1:                                    : (c)))
    1: 
    1: /*
    1:  * Shorthands for ASCII (7-bit) decimal and hex conversion.
    1:  * Manually inline isdigit for performance; MSVC doesn't do this for us.
    1:  */
    1: #define JS7_ISDEC(c)    ((((unsigned)(c)) - '0') <= 9)
64305: #define JS7_ISDECNZ(c)  ((((unsigned)(c)) - '1') <= 8)
    1: #define JS7_UNDEC(c)    ((c) - '0')
    1: #define JS7_ISHEX(c)    ((c) < 128 && isxdigit(c))
    1: #define JS7_UNHEX(c)    (uintN)(JS7_ISDEC(c) ? (c) - '0' : 10 + tolower(c) - 'a')
    1: #define JS7_ISLET(c)    ((c) < 128 && isalpha(c))
    1: 
    1: /* Initialize the String class, returning its prototype object. */
48470: extern js::Class js_StringClass;
    1: 
40901: inline bool
40901: JSObject::isString() const
40901: {
40901:     return getClass() == &js_StringClass;
40901: }
40901: 
    1: extern JSObject *
    1: js_InitStringClass(JSContext *cx, JSObject *obj);
    1: 
    1: extern const char js_escape_str[];
    1: extern const char js_unescape_str[];
    1: extern const char js_uneval_str[];
    1: extern const char js_decodeURI_str[];
    1: extern const char js_encodeURI_str[];
    1: extern const char js_decodeURIComponent_str[];
    1: extern const char js_encodeURIComponent_str[];
    1: 
    1: /* GC-allocate a string descriptor for the given malloc-allocated chars. */
64345: extern JSFixedString *
18040: js_NewString(JSContext *cx, jschar *chars, size_t length);
    1: 
59890: extern JSLinearString *
64345: js_NewDependentString(JSContext *cx, JSString *base, size_t start, size_t length);
    1: 
    1: /* Copy a counted string and GC-allocate a descriptor for it. */
64345: extern JSFixedString *
 4076: js_NewStringCopyN(JSContext *cx, const jschar *s, size_t n);
    1: 
64345: extern JSFixedString *
48563: js_NewStringCopyN(JSContext *cx, const char *s, size_t n);
48563: 
    1: /* Copy a C string and GC-allocate a descriptor for it. */
64345: extern JSFixedString *
 4076: js_NewStringCopyZ(JSContext *cx, const jschar *s);
    1: 
64345: extern JSFixedString *
48563: js_NewStringCopyZ(JSContext *cx, const char *s);
48563: 
 6117: /*
    1:  * Convert a value to a printable C string.
    1:  */
57812: extern const char *
57812: js_ValueToPrintable(JSContext *cx, const js::Value &,
57812:                     JSAutoByteString *bytes, bool asSource = false);
    1: 
    1: /*
    1:  * Convert a value to a string, returning null after reporting an error,
    1:  * otherwise returning a new string reference.
    1:  */
48470: extern JSString *
48470: js_ValueToString(JSContext *cx, const js::Value &v);
    1: 
55566: namespace js {
55566: 
55566: /*
55566:  * Most code that calls js_ValueToString knows the value is (probably) not a
55566:  * string, so it does not make sense to put this inline fast path into
55566:  * js_ValueToString.
55566:  */
55566: static JS_ALWAYS_INLINE JSString *
55566: ValueToString_TestForStringInline(JSContext *cx, const Value &v)
55566: {
55566:     if (v.isString())
55566:         return v.toString();
55566:     return js_ValueToString(cx, v);
55566: }
55566: 
    1: /*
30023:  * This function implements E-262-3 section 9.8, toString. Convert the given
30023:  * value to a string of jschars appended to the given buffer. On error, the
30023:  * passed buffer may have partial results appended.
30023:  */
67950: inline bool
60571: ValueToStringBuffer(JSContext *cx, const Value &v, StringBuffer &sb);
60571: 
60571: } /* namespace js */
30023: 
30023: /*
    1:  * Convert a value to its source expression, returning null after reporting
    1:  * an error, otherwise returning a new string reference.
    1:  */
    1: extern JS_FRIEND_API(JSString *)
48470: js_ValueToSource(JSContext *cx, const js::Value &v);
    1: 
64345: namespace js {
64345: 
    1: /*
 4529:  * Compute a hash function from str. The caller can call this function even if
 4529:  * str is not a GC-allocated thing.
    1:  */
59890: inline uint32
64345: HashChars(const jschar *chars, size_t length)
59890: {
64345:     uint32 h = 0;
64345:     for (; length; chars++, length--)
64345:         h = JS_ROTATE_LEFT32(h, 4) ^ *chars;
59890:     return h;
59890: }
59890: 
 4529: /*
 4529:  * Test if strings are equal. The caller can call the function even if str1
 4529:  * or str2 are not GC-allocated things.
 4529:  */
59890: extern bool
59890: EqualStrings(JSContext *cx, JSString *str1, JSString *str2, JSBool *result);
59890: 
59890: /* EqualStrings is infallible on linear strings. */
59890: extern bool
59890: EqualStrings(JSLinearString *str1, JSLinearString *str2);
    1: 
    1: /*
    1:  * Return less than, equal to, or greater than zero depending on whether
    1:  * str1 is less than, equal to, or greater than str2.
    1:  */
59890: extern bool
59890: CompareStrings(JSContext *cx, JSString *str1, JSString *str2, int32 *result);
    1: 
57721: /*
57721:  * Return true if the string matches the given sequence of ASCII bytes.
57721:  */
59890: extern bool
59890: StringEqualsAscii(JSLinearString *str, const char *asciiBytes);
57721: 
57721: } /* namespacejs */
57721: 
    1: extern size_t
    1: js_strlen(const jschar *s);
    1: 
    1: extern jschar *
    1: js_strchr(const jschar *s, jschar c);
    1: 
    1: extern jschar *
    1: js_strchr_limit(const jschar *s, jschar c, const jschar *limit);
    1: 
    1: #define js_strncpy(t, s, n)     memcpy((t), (s), (n) * sizeof(jschar))
    1: 
    1: /*
    1:  * Return s advanced past any Unicode white space characters.
    1:  */
32608: static inline const jschar *
32608: js_SkipWhiteSpace(const jschar *s, const jschar *end)
32608: {
32608:     JS_ASSERT(s <= end);
32608:     while (s != end && JS_ISSPACE(*s))
32608:         s++;
32608:     return s;
32608: }
    1: 
    1: /*
52503:  * Inflate bytes to JS chars and vice versa.  Report out of memory via cx and
52503:  * return null on error, otherwise return the jschar or byte vector that was
52503:  * JS_malloc'ed. length is updated to the length of the new string in jschars.
    1:  */
    1: extern jschar *
68124: js_InflateString(JSContext *cx, const char *bytes, size_t *length);
    1: 
    1: extern char *
    1: js_DeflateString(JSContext *cx, const jschar *chars, size_t length);
    1: 
    1: /*
    1:  * Inflate bytes to JS chars into a buffer. 'chars' must be large enough for
    1:  * 'length' jschars. The buffer is NOT null-terminated. The destination length
    1:  * must be be initialized with the buffer size and will contain on return the
40444:  * number of copied chars. Conversion behavior depends on js_CStringsAreUTF8.
    1:  */
    1: extern JSBool
    1: js_InflateStringToBuffer(JSContext *cx, const char *bytes, size_t length,
    1:                          jschar *chars, size_t *charsLength);
    1: 
    1: /*
68124:  * Same as js_InflateStringToBuffer, but always treats 'bytes' as UTF-8.
40444:  */
40444: extern JSBool
40444: js_InflateUTF8StringToBuffer(JSContext *cx, const char *bytes, size_t length,
68124:                              jschar *chars, size_t *charsLength);
40444: 
40444: /*
40444:  * Get number of bytes in the deflated sequence of characters. Behavior depends
40444:  * on js_CStringsAreUTF8.
    1:  */
    1: extern size_t
    1: js_GetDeflatedStringLength(JSContext *cx, const jschar *chars,
    1:                            size_t charsLength);
    1: 
    1: /*
68124:  * Same as js_GetDeflatedStringLength, but always treats the result as UTF-8.
40444:  */
40444: extern size_t
40444: js_GetDeflatedUTF8StringLength(JSContext *cx, const jschar *chars,
68124:                                size_t charsLength);
40444: 
40444: /*
    1:  * Deflate JS chars to bytes into a buffer. 'bytes' must be large enough for
    1:  * 'length chars. The buffer is NOT null-terminated. The destination length
    1:  * must to be initialized with the buffer size and will contain on return the
40444:  * number of copied bytes. Conversion behavior depends on js_CStringsAreUTF8.
    1:  */
    1: extern JSBool
    1: js_DeflateStringToBuffer(JSContext *cx, const jschar *chars,
    1:                          size_t charsLength, char *bytes, size_t *length);
    1: 
    1: /*
68124:  * Same as js_DeflateStringToBuffer, but always treats 'bytes' as UTF-8.
40444:  */
40444: extern JSBool
40444: js_DeflateStringToUTF8Buffer(JSContext *cx, const jschar *chars,
68124:                              size_t charsLength, char *bytes, size_t *length);
40444: 
18115: /* Export a few natives and a helper to other files in SpiderMonkey. */
18115: extern JSBool
61734: js_str_escape(JSContext *cx, uintN argc, js::Value *argv, js::Value *rval);
    1: 
48676: /*
48676:  * The String.prototype.replace fast-native entry point is exported for joined
48676:  * function optimization in js{interp,tracer}.cpp.
48676:  */
48676: namespace js {
48676: extern JSBool
48676: str_replace(JSContext *cx, uintN argc, js::Value *vp);
48676: }
48676: 
18115: extern JSBool
48470: js_str_toString(JSContext *cx, uintN argc, js::Value *vp);
30443: 
49109: extern JSBool
49109: js_str_charAt(JSContext *cx, uintN argc, js::Value *vp);
49109: 
49109: extern JSBool
49109: js_str_charCodeAt(JSContext *cx, uintN argc, js::Value *vp);
49109: 
    1: /*
    1:  * Convert one UCS-4 char and write it into a UTF-8 buffer, which must be at
    1:  * least 6 bytes long.  Return the number of UTF-8 bytes of data written.
    1:  */
    1: extern int
    1: js_OneUcs4ToUtf8Char(uint8 *utf8Buffer, uint32 ucs4Char);
    1: 
57721: namespace js {
57721: 
57721: extern size_t
59890: PutEscapedStringImpl(char *buffer, size_t size, FILE *fp, JSLinearString *str, uint32 quote);
57721: 
    1: /*
57721:  * Write str into buffer escaping any non-printable or non-ASCII character
57721:  * using \escapes for JS string literals.
57721:  * Guarantees that a NUL is at the end of the buffer unless size is 0. Returns
57721:  * the length of the written output, NOT including the NUL. Thus, a return
57721:  * value of size or more means that the output was truncated. If buffer
57721:  * is null, just returns the length of the output. If quote is not 0, it must
57721:  * be a single or double quote character that will quote the output.
    1: */
57721: inline size_t
59890: PutEscapedString(char *buffer, size_t size, JSLinearString *str, uint32 quote)
57721: {
57721:     size_t n = PutEscapedStringImpl(buffer, size, NULL, str, quote);
57721: 
57721:     /* PutEscapedStringImpl can only fail with a file. */
57721:     JS_ASSERT(n != size_t(-1));
57721:     return n;
57721: }
    1: 
    1: /*
    1:  * Write str into file escaping any non-printable or non-ASCII character.
57721:  * If quote is not 0, it must be a single or double quote character that
57721:  * will quote the output.
    1: */
57721: inline bool
59890: FileEscapedString(FILE *fp, JSLinearString *str, uint32 quote)
57721: {
57721:     return PutEscapedStringImpl(NULL, 0, fp, str, quote) != size_t(-1);
57721: }
    1: 
57721: } /* namespace js */
    1: 
26008: extern JSBool
50489: js_String(JSContext *cx, uintN argc, js::Value *vp);
40337: 
    1: #endif /* jsstr_h___ */
