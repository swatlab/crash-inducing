  7836: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
  7836:  * vim: set shiftwidth=4 tabstop=8 autoindent cindent expandtab: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
  4487: 
  4487: /* API for getting a stack trace of the C/C++ stack on the current thread */
  4487: 
 80467: #include "mozilla/Util.h"
 89958: #include "mozilla/StackWalk.h"
 83190: #include "nsDebug.h"
 83190: #include "nsStackWalkPrivate.h"
 80467: 
  4487: #include "nsStackWalk.h"
  4487: 
 89958: using namespace mozilla;
 89958: 
 83190: // The presence of this address is the stack must stop the stack walk. If
 83190: // there is no such address, the structure will be {NULL, true}.
 83190: struct CriticalAddress {
 83190:   void* mAddr;
 83190:   bool mInit;
 83190: };
 83190: static CriticalAddress gCriticalAddress;
 83190: 
 83190: #if defined(HAVE_DLOPEN) || defined(XP_MACOSX)
 83190: #include <dlfcn.h>
 83190: #endif
 83190: 
 86079: #define NSSTACKWALK_SUPPORTS_MACOSX \
 86079:     (defined(XP_MACOSX) && \
 86079:      (defined(__i386) || defined(__ppc__) || defined(HAVE__UNWIND_BACKTRACE)))
 86079: 
 86079: #define NSSTACKWALK_SUPPORTS_LINUX \
 86079:     (defined(linux) && \
 86079:      ((defined(__GNUC__) && (defined(__i386) || defined(PPC))) || \
 86079:       defined(HAVE__UNWIND_BACKTRACE)))
 86079: 
 86079: #define NSSTACKWALK_SUPPORTS_SOLARIS \
 86079:     (defined(__sun) && \
 86079:      (defined(__sparc) || defined(sparc) || defined(__i386) || defined(i386)))
 86079: 
 86079: #if NSSTACKWALK_SUPPORTS_MACOSX
 83190: #include <pthread.h>
 83190: #include <errno.h>
 83190: #include <CoreServices/CoreServices.h>
 83190: 
 83190: typedef void
 83190: malloc_logger_t(uint32_t type, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3,
 83190:                 uintptr_t result, uint32_t num_hot_frames_to_skip);
 83190: extern malloc_logger_t *malloc_logger;
 83190: 
 83190: static void
 83190: stack_callback(void *pc, void *closure)
 83190: {
 83190:   const char *name = reinterpret_cast<char *>(closure);
 83190:   Dl_info info;
 83190: 
 83190:   // On Leopard dladdr returns the wrong value for "new_sem_from_pool". The
 83190:   // stack shows up as having two pthread_cond_wait$UNIX2003 frames. The
 83190:   // correct one is the first that we find on our way up, so the
 83190:   // following check for gCriticalAddress.mAddr is critical.
 83190:   if (gCriticalAddress.mAddr || dladdr(pc, &info) == 0  ||
 83190:       info.dli_sname == NULL || strcmp(info.dli_sname, name) != 0)
 83190:     return;
 83190:   gCriticalAddress.mAddr = pc;
 83190: }
 83190: 
 83190: #define MAC_OS_X_VERSION_10_7_HEX 0x00001070
 83190: #define MAC_OS_X_VERSION_10_6_HEX 0x00001060
 83190: 
 83190: static PRInt32 OSXVersion()
 83190: {
 83190:   static PRInt32 gOSXVersion = 0x0;
 83190:   if (gOSXVersion == 0x0) {
 83190:     OSErr err = ::Gestalt(gestaltSystemVersion, (SInt32*)&gOSXVersion);
 83190:     MOZ_ASSERT(err == noErr);
 83190:   }
 83190:   return gOSXVersion;
 83190: }
 83190: 
 83190: static bool OnLionOrLater()
 83190: {
 83190:   return (OSXVersion() >= MAC_OS_X_VERSION_10_7_HEX);
 83190: }
 83190: 
 83190: static bool OnSnowLeopardOrLater()
 83190: {
 83190:   return (OSXVersion() >= MAC_OS_X_VERSION_10_6_HEX);
 83190: }
 83190: 
 83190: static void
 83190: my_malloc_logger(uint32_t type, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3,
 83190:                  uintptr_t result, uint32_t num_hot_frames_to_skip)
 83190: {
 83190:   static bool once = false;
 83190:   if (once)
 83190:     return;
 83190:   once = true;
 83190: 
 83190:   // On Leopard dladdr returns the wrong value for "new_sem_from_pool". The
 83190:   // stack shows up as having two pthread_cond_wait$UNIX2003 frames.
 83190:   const char *name = OnSnowLeopardOrLater() ? "new_sem_from_pool" :
 83190:     "pthread_cond_wait$UNIX2003";
 86282:   NS_StackWalk(stack_callback, 0, const_cast<char*>(name), 0);
 83190: }
 83190: 
 83190: void
 83190: StackWalkInitCriticalAddress()
 83190: {
 83190:   if(gCriticalAddress.mInit)
 83190:     return;
 83190:   gCriticalAddress.mInit = true;
 83190:   // We must not do work when 'new_sem_from_pool' calls realloc, since
 83190:   // it holds a non-reentrant spin-lock and we will quickly deadlock.
 83190:   // new_sem_from_pool is not directly accessible using dlsym, so
 83190:   // we force a situation where new_sem_from_pool is on the stack and
 83190:   // use dladdr to check the addresses.
 83190: 
 94175:   // malloc_logger can be set by external tools like 'Instruments' or 'leaks'
 93792:   malloc_logger_t *old_malloc_logger = malloc_logger;
 83190:   malloc_logger = my_malloc_logger;
 83190: 
 83190:   pthread_cond_t cond;
 83190:   int r = pthread_cond_init(&cond, 0);
 83190:   MOZ_ASSERT(r == 0);
 83190:   pthread_mutex_t mutex;
 83190:   r = pthread_mutex_init(&mutex,0);
 83190:   MOZ_ASSERT(r == 0);
 83190:   r = pthread_mutex_lock(&mutex);
 83190:   MOZ_ASSERT(r == 0);
 83190:   struct timespec abstime = {0, 1};
 83190:   r = pthread_cond_timedwait_relative_np(&cond, &mutex, &abstime);
 94175: 
 94175:   // restore the previous malloc logger
 93792:   malloc_logger = old_malloc_logger;
 83190: 
 83190:   // On Lion, malloc is no longer called from pthread_cond_*wait*. This prevents
 83190:   // us from finding the address, but that is fine, since with no call to malloc
 83190:   // there is no critical address.
 83190:   MOZ_ASSERT(OnLionOrLater() || gCriticalAddress.mAddr != NULL);
 83190:   MOZ_ASSERT(r == ETIMEDOUT);
 83190:   r = pthread_mutex_unlock(&mutex);
 83190:   MOZ_ASSERT(r == 0);
 83190:   r = pthread_mutex_destroy(&mutex);
 83190:   MOZ_ASSERT(r == 0);
 83190:   r = pthread_cond_destroy(&cond);
 83190:   MOZ_ASSERT(r == 0);
 83190: }
 83190: 
 83190: static bool IsCriticalAddress(void* aPC)
 83190: {
 83190:   return gCriticalAddress.mAddr == aPC;
 83190: }
 83190: #else
 83190: static bool IsCriticalAddress(void* aPC)
 83190: {
 83190:   return false;
 83190: }
 83190: // We still initialize gCriticalAddress.mInit so that this code behaves
 83190: // the same on all platforms. Otherwise a failure to init would be visible
 83190: // only on OS X.
 83190: void
 83190: StackWalkInitCriticalAddress()
 83190: {
 83190:   gCriticalAddress.mInit = true;
 83190: }
 83190: #endif
 83190: 
 69184: #if defined(_WIN32) && (defined(_M_IX86) || defined(_M_AMD64) || defined(_M_IA64)) // WIN32 x86 stack walking code
  4497: 
  4572: #include "nscore.h"
  4572: #include <windows.h>
  5365: #include <process.h>
  4572: #include <stdio.h>
104069: #include <malloc.h>
  4572: #include "plstr.h"
 42480: #include "mozilla/FunctionTimer.h"
  4572: 
  4572: #include "nspr.h"
  4572: #include <imagehlp.h>
  4572: // We need a way to know if we are building for WXP (or later), as if we are, we
  4572: // need to use the newer 64-bit APIs. API_VERSION_NUMBER seems to fit the bill.
  4572: // A value of 9 indicates we want to use the new APIs.
 90802: #if API_VERSION_NUMBER < 9
 90802: #error Too old imagehlp.h
  4572: #endif
  4572: 
  4572: // Define these as static pointers so that we can load the DLL on the
  4572: // fly (and not introduce a link-time dependency on it). Tip o' the
  4572: // hat to Matt Pietrick for this idea. See:
  4572: //
  4572: //   http://msdn.microsoft.com/library/periodic/period97/F1/D3/S245C6.htm
  4572: //
  4572: PR_BEGIN_EXTERN_C
  4572: 
  4572: extern HANDLE hStackWalkMutex; 
  4572: 
 79445: bool EnsureSymInitialized();
  4572: 
 79445: bool EnsureImageHlpInitialized();
  4572: 
  4572: struct WalkStackData {
  4572:   PRUint32 skipFrames;
  4572:   HANDLE thread;
 87964:   bool walkCallingThread;
  4572:   HANDLE process;
  5365:   HANDLE eventStart;
  5365:   HANDLE eventEnd;
  5365:   void **pcs;
  5365:   PRUint32 pc_size;
  5365:   PRUint32 pc_count;
  4572: };
  4572: 
  4572: void PrintError(char *prefix, WalkStackData* data);
  5365: unsigned int WINAPI WalkStackThread(void* data);
  4572: void WalkStackMain64(struct WalkStackData* data);
  4572: 
  4572: 
  5365: DWORD gStackWalkThread;
  5365: CRITICAL_SECTION gDbgHelpCS;
  4572: 
  4572: PR_END_EXTERN_C
  4572: 
  4572: // Routine to print an error message to standard error.
  4572: // Will also call callback with error, if data supplied.
  4572: void PrintError(char *prefix)
  4572: {
  4572:     LPVOID lpMsgBuf;
  4572:     DWORD lastErr = GetLastError();
 91573:     FormatMessageA(
  4572:       FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
  4572:       NULL,
  4572:       lastErr,
  4572:       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
 91573:       (LPSTR) &lpMsgBuf,
  4572:       0,
  4572:       NULL
  4572:     );
  4800:     fprintf(stderr, "### ERROR: %s: %s",
  4800:                     prefix, lpMsgBuf ? lpMsgBuf : "(null)\n");
  4572:     fflush(stderr);
  4572:     LocalFree(lpMsgBuf);
  4572: }
  4572: 
 79445: bool
  4572: EnsureImageHlpInitialized()
  4572: {
 79445:     static bool gInitialized = false;
  4572: 
  4572:     if (gInitialized)
  4572:         return gInitialized;
  4572: 
  5365:     // Hope that our first call doesn't happen during static
  5365:     // initialization.  If it does, this CreateThread call won't
  5365:     // actually start the thread until after the static initialization
  5365:     // is done, which means we'll deadlock while waiting for it to
  5365:     // process a stack.
  5365:     HANDLE readyEvent = ::CreateEvent(NULL, FALSE /* auto-reset*/,
  5365:                             FALSE /* initially non-signaled */, NULL);
  5365:     unsigned int threadID;
  5365:     HANDLE hStackWalkThread = (HANDLE)
  5365:       _beginthreadex(NULL, 0, WalkStackThread, (void*)readyEvent,
  5365:                      0, &threadID);
  5365:     gStackWalkThread = threadID;
  5365:     if (hStackWalkThread == NULL) {
  5365:         PrintError("CreateThread");
 80486:         return false;
  4572:     }
  5365:     ::CloseHandle(hStackWalkThread);
  5365: 
  5365:     // Wait for the thread's event loop to start before posting events to it.
  5365:     ::WaitForSingleObject(readyEvent, INFINITE);
  5365:     ::CloseHandle(readyEvent);
  5365: 
  5365:     ::InitializeCriticalSection(&gDbgHelpCS);
  4572: 
 80486:     return gInitialized = true;
  4572: }
  4572: 
  4572: void
  4572: WalkStackMain64(struct WalkStackData* data)
  4572: {
  4572:     // Get the context information for the thread. That way we will
  4572:     // know where our sp, fp, pc, etc. are and can fill in the
  4572:     // STACKFRAME64 with the initial values.
  4572:     CONTEXT context;
  4572:     HANDLE myProcess = data->process;
  4572:     HANDLE myThread = data->thread;
  4572:     DWORD64 addr;
  4572:     STACKFRAME64 frame64;
 87964:     // skip our own stack walking frames
 87964:     int skip = (data->walkCallingThread ? 3 : 0) + data->skipFrames;
  4572:     BOOL ok;
  4572: 
  4572:     // Get a context for the specified thread.
  4572:     memset(&context, 0, sizeof(CONTEXT));
  4572:     context.ContextFlags = CONTEXT_FULL;
  4572:     if (!GetThreadContext(myThread, &context)) {
  4572:         PrintError("GetThreadContext");
  4572:         return;
  4572:     }
  4572: 
  4572:     // Setup initial stack frame to walk from
  4572:     memset(&frame64, 0, sizeof(frame64));
  4572: #ifdef _M_IX86
  4572:     frame64.AddrPC.Offset    = context.Eip;
  4572:     frame64.AddrStack.Offset = context.Esp;
  4572:     frame64.AddrFrame.Offset = context.Ebp;
  4572: #elif defined _M_AMD64
  4572:     frame64.AddrPC.Offset    = context.Rip;
  4572:     frame64.AddrStack.Offset = context.Rsp;
  4572:     frame64.AddrFrame.Offset = context.Rbp;
  4572: #elif defined _M_IA64
  4572:     frame64.AddrPC.Offset    = context.StIIP;
  4572:     frame64.AddrStack.Offset = context.SP;
  4572:     frame64.AddrFrame.Offset = context.RsBSP;
  4572: #else
  5365: #error "Should not have compiled this code"
  4572: #endif
  4572:     frame64.AddrPC.Mode      = AddrModeFlat;
  4572:     frame64.AddrStack.Mode   = AddrModeFlat;
  4572:     frame64.AddrFrame.Mode   = AddrModeFlat;
  4572:     frame64.AddrReturn.Mode  = AddrModeFlat;
  4572: 
  5365:     // Now walk the stack
  4572:     while (1) {
  4572: 
  5365:         // debug routines are not threadsafe, so grab the lock.
  5365:         EnterCriticalSection(&gDbgHelpCS);
 90802:         ok = StackWalk64(
  4572: #ifdef _M_AMD64
  4572:           IMAGE_FILE_MACHINE_AMD64,
  4572: #elif defined _M_IA64
  4572:           IMAGE_FILE_MACHINE_IA64,
  4572: #elif defined _M_IX86
  4572:           IMAGE_FILE_MACHINE_I386,
  4572: #else
  5365: #error "Should not have compiled this code"
  4572: #endif
  4572:           myProcess,
  4572:           myThread,
  4572:           &frame64,
  4572:           &context,
  4572:           NULL,
 90802:           SymFunctionTableAccess64, // function table access routine
 90802:           SymGetModuleBase64,       // module base routine
  4572:           0
  4572:         );
  5365:         LeaveCriticalSection(&gDbgHelpCS);
  4572: 
  4572:         if (ok)
  4572:             addr = frame64.AddrPC.Offset;
  4572:         else {
  4572:             addr = 0;
  4572:             PrintError("WalkStack64");
  4572:         }
  4572: 
  4572:         if (!ok || (addr == 0)) {
  4572:             break;
  4572:         }
  4572: 
  4572:         if (skip-- > 0) {
  4572:             continue;
  4572:         }
  4572: 
  5365:         if (data->pc_count < data->pc_size)
  5365:             data->pcs[data->pc_count] = (void*)addr;
  5365:         ++data->pc_count;
  4572: 
  4572:         if (frame64.AddrReturn.Offset == 0)
  4572:             break;
  4572:     }
  4572:     return;
  4572: }
  4572: 
  4572: 
  5365: unsigned int WINAPI
  5365: WalkStackThread(void* aData)
  4572: {
  5365:     BOOL msgRet;
  5365:     MSG msg;
  5365: 
  5365:     // Call PeekMessage to force creation of a message queue so that
  5365:     // other threads can safely post events to us.
  5365:     ::PeekMessage(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);
  5365: 
  5365:     // and tell the thread that created us that we're ready.
  5365:     HANDLE readyEvent = (HANDLE)aData;
  5365:     ::SetEvent(readyEvent);
  5365: 
  5365:     while ((msgRet = ::GetMessage(&msg, (HWND)-1, 0, 0)) != 0) {
  5365:         if (msgRet == -1) {
  5365:             PrintError("GetMessage");
  5365:         } else {
  4572:             DWORD ret;
  4572: 
  5365:             struct WalkStackData *data = (WalkStackData *)msg.lParam;
 42480:             if (!data)
 42480:               continue;
  5365: 
  5365:             // Don't suspend the calling thread until it's waiting for
  5365:             // us; otherwise the number of frames on the stack could vary.
  5365:             ret = ::WaitForSingleObject(data->eventStart, INFINITE);
  5365:             if (ret != WAIT_OBJECT_0)
  5365:                 PrintError("WaitForSingleObject");
  5365: 
  4572:             // Suspend the calling thread, dump his stack, and then resume him.
  4572:             // He's currently waiting for us to finish so now should be a good time.
  4572:             ret = ::SuspendThread( data->thread );
  4572:             if (ret == -1) {
  4572:                 PrintError("ThreadSuspend");
  4572:             }
  4572:             else {
 90802:                 WalkStackMain64(data);
  5365: 
  4572:                 ret = ::ResumeThread(data->thread);
  4572:                 if (ret == -1) {
  4572:                     PrintError("ThreadResume");
  4572:                 }
  4572:             }
  4572: 
  5365:             ::SetEvent(data->eventEnd);
  5365:         }
  5365:     }
  5365: 
  4572:     return 0;
  4572: }
  4572: 
  4572: /**
  4572:  * Walk the stack, translating PC's found into strings and recording the
  4572:  * chain in aBuffer. For this to work properly, the DLLs must be rebased
  4572:  * so that the address in the file agrees with the address in memory.
  4572:  * Otherwise StackWalk will return FALSE when it hits a frame in a DLL
  4572:  * whose in memory address doesn't match its in-file address.
  4572:  */
  4572: 
  4572: EXPORT_XPCOM_API(nsresult)
  4572: NS_StackWalk(NS_WalkStackCallback aCallback, PRUint32 aSkipFrames,
 86282:              void *aClosure, uintptr_t aThread)
  4572: {
 83190:     MOZ_ASSERT(gCriticalAddress.mInit);
104067:     static HANDLE myProcess = NULL;
104067:     HANDLE myThread;
  4572:     DWORD walkerReturn;
  4572:     struct WalkStackData data;
  4572: 
  4572:     if (!EnsureImageHlpInitialized())
 80486:         return false;
  4572: 
 87964:     HANDLE targetThread = ::GetCurrentThread();
 87964:     data.walkCallingThread = true;
 86282:     if (aThread) {
 87964:         HANDLE threadToWalk = reinterpret_cast<HANDLE> (aThread);
 87964:         // walkCallingThread indicates whether we are walking the caller's stack
 87964:         data.walkCallingThread = (threadToWalk == targetThread);
 87964:         targetThread = threadToWalk;
 86282:     }
 86282: 
  4572:     // Have to duplicate handle to get a real handle.
104067:     if (!myProcess) {
  4572:         if (!::DuplicateHandle(::GetCurrentProcess(),
  4572:                                ::GetCurrentProcess(),
  4572:                                ::GetCurrentProcess(),
  4572:                                &myProcess,
  4800:                                PROCESS_ALL_ACCESS, FALSE, 0)) {
  4572:             PrintError("DuplicateHandle (process)");
  4572:             return NS_ERROR_FAILURE;
  4572:         }
104067:     }
  4572:     if (!::DuplicateHandle(::GetCurrentProcess(),
 86282:                            targetThread,
  4572:                            ::GetCurrentProcess(),
  4572:                            &myThread,
  4572:                            THREAD_ALL_ACCESS, FALSE, 0)) {
  4572:         PrintError("DuplicateHandle (thread)");
  4572:         return NS_ERROR_FAILURE;
  4572:     }
  4572: 
  4572:     data.skipFrames = aSkipFrames;
  4572:     data.thread = myThread;
  4572:     data.process = myProcess;
 88309:     void *local_pcs[1024];
 88309:     data.pcs = local_pcs;
 88309:     data.pc_count = 0;
 88309:     data.pc_size = ArrayLength(local_pcs);
 88309: 
 88309:     if (aThread) {
 88309:         // If we're walking the stack of another thread, we don't need to
 88309:         // use a separate walker thread.
 90802:         WalkStackMain64(&data);
104069: 
104069:         if (data.pc_count > data.pc_size) {
104069:             data.pcs = (void**) _alloca(data.pc_count * sizeof(void*));
104069:             data.pc_size = data.pc_count;
104069:             data.pc_count = 0;
104069:             WalkStackMain64(&data);
104069:         }
 88309:     } else {
  5365:         data.eventStart = ::CreateEvent(NULL, FALSE /* auto-reset*/,
  5365:                               FALSE /* initially non-signaled */, NULL);
  5365:         data.eventEnd = ::CreateEvent(NULL, FALSE /* auto-reset*/,
  5365:                             FALSE /* initially non-signaled */, NULL);
  5365: 
  5365:         ::PostThreadMessage(gStackWalkThread, WM_USER, 0, (LPARAM)&data);
  5365: 
  5365:         walkerReturn = ::SignalObjectAndWait(data.eventStart,
  5365:                            data.eventEnd, INFINITE, FALSE);
  5365:         if (walkerReturn != WAIT_OBJECT_0)
  5365:             PrintError("SignalObjectAndWait (1)");
  5365:         if (data.pc_count > data.pc_size) {
104069:             data.pcs = (void**) _alloca(data.pc_count * sizeof(void*));
  5365:             data.pc_size = data.pc_count;
  5365:             data.pc_count = 0;
  5365:             ::PostThreadMessage(gStackWalkThread, WM_USER, 0, (LPARAM)&data);
  5365:             walkerReturn = ::SignalObjectAndWait(data.eventStart,
  5365:                                data.eventEnd, INFINITE, FALSE);
  5365:             if (walkerReturn != WAIT_OBJECT_0)
  5365:                 PrintError("SignalObjectAndWait (2)");
  4572:         }
  5365: 
 88309:         ::CloseHandle(data.eventStart);
 88309:         ::CloseHandle(data.eventEnd);
 88309:     }
 88309: 
  4572:     ::CloseHandle(myThread);
  5365: 
  5365:     for (PRUint32 i = 0; i < data.pc_count; ++i)
  5365:         (*aCallback)(data.pcs[i], aClosure);
  5365: 
  4572:     return NS_OK;
  4572: }
  4572: 
  4572: 
  4572: static BOOL CALLBACK callbackEspecial64(
 11173:   PCSTR aModuleName,
  4572:   DWORD64 aModuleBase,
  4572:   ULONG aModuleSize,
  4572:   PVOID aUserContext)
  4572: {
  4572:     BOOL retval = TRUE;
  4572:     DWORD64 addr = *(DWORD64*)aUserContext;
  4572: 
  4572:     /*
  4572:      * You'll want to control this if we are running on an
  4572:      *  architecture where the addresses go the other direction.
  4572:      * Not sure this is even a realistic consideration.
  4572:      */
  4572:     const BOOL addressIncreases = TRUE;
  4572: 
  4572:     /*
  4572:      * If it falls in side the known range, load the symbols.
  4572:      */
  4572:     if (addressIncreases
  4572:        ? (addr >= aModuleBase && addr <= (aModuleBase + aModuleSize))
  4572:        : (addr <= aModuleBase && addr >= (aModuleBase - aModuleSize))
  4572:         ) {
 90802:         retval = SymLoadModule64(GetCurrentProcess(), NULL, (PSTR)aModuleName, NULL, aModuleBase, aModuleSize);
  4800:         if (!retval)
  4800:             PrintError("SymLoadModule64");
  4572:     }
  4572: 
  4572:     return retval;
  4572: }
  4572: 
  4572: /*
  4572:  * SymGetModuleInfoEspecial
  4572:  *
  4572:  * Attempt to determine the module information.
  4572:  * Bug 112196 says this DLL may not have been loaded at the time
  4572:  *  SymInitialize was called, and thus the module information
  4572:  *  and symbol information is not available.
  4572:  * This code rectifies that problem.
  4572:  */
  4572: 
  4801: // New members were added to IMAGEHLP_MODULE64 (that show up in the
  4801: // Platform SDK that ships with VC8, but not the Platform SDK that ships
  4801: // with VC7.1, i.e., between DbgHelp 6.0 and 6.1), but we don't need to
  4801: // use them, and it's useful to be able to function correctly with the
  4801: // older library.  (Stock Windows XP SP2 seems to ship with dbghelp.dll
  4801: // version 5.1.)  Since Platform SDK version need not correspond to
  4801: // compiler version, and the version number in debughlp.h was NOT bumped
  4801: // when these changes were made, ifdef based on a constant that was
  4801: // added between these versions.
  4801: #ifdef SSRVOPT_SETCONTEXT
  4801: #define NS_IMAGEHLP_MODULE64_SIZE (((offsetof(IMAGEHLP_MODULE64, LoadedPdbName) + sizeof(DWORD64) - 1) / sizeof(DWORD64)) * sizeof(DWORD64))
  4801: #else
  4801: #define NS_IMAGEHLP_MODULE64_SIZE sizeof(IMAGEHLP_MODULE64)
  4801: #endif
  4801: 
  4572: BOOL SymGetModuleInfoEspecial64(HANDLE aProcess, DWORD64 aAddr, PIMAGEHLP_MODULE64 aModuleInfo, PIMAGEHLP_LINE64 aLineInfo)
  4572: {
  4572:     BOOL retval = FALSE;
  4572: 
  4572:     /*
  4572:      * Init the vars if we have em.
  4572:      */
  4801:     aModuleInfo->SizeOfStruct = NS_IMAGEHLP_MODULE64_SIZE;
  4572:     if (nsnull != aLineInfo) {
  4572:         aLineInfo->SizeOfStruct = sizeof(IMAGEHLP_LINE64);
  4572:     }
  4572: 
  4572:     /*
  4572:      * Give it a go.
  4572:      * It may already be loaded.
  4572:      */
 90802:     retval = SymGetModuleInfo64(aProcess, aAddr, aModuleInfo);
  4572: 
  4572:     if (FALSE == retval) {
  4572:         BOOL enumRes = FALSE;
  4572: 
  4572:         /*
  4572:          * Not loaded, here's the magic.
  4572:          * Go through all the modules.
  4572:          */
 11174:         // Need to cast to PENUMLOADED_MODULES_CALLBACK64 because the
 11174:         // constness of the first parameter of
 11174:         // PENUMLOADED_MODULES_CALLBACK64 varies over SDK versions (from
 11174:         // non-const to const over time).  See bug 391848 and bug
 11175:         // 415426.
 90802:         enumRes = EnumerateLoadedModules64(aProcess, (PENUMLOADED_MODULES_CALLBACK64)callbackEspecial64, (PVOID)&aAddr);
  4572:         if (FALSE != enumRes)
  4572:         {
  4572:             /*
  4572:              * One final go.
  4572:              * If it fails, then well, we have other problems.
  4572:              */
 90802:             retval = SymGetModuleInfo64(aProcess, aAddr, aModuleInfo);
  4800:             if (!retval)
  4800:                 PrintError("SymGetModuleInfo64");
  4572:         }
  4572:     }
  4572: 
  4572:     /*
  4572:      * If we got module info, we may attempt line info as well.
  4572:      * We will not report failure if this does not work.
  4572:      */
 90802:     if (FALSE != retval && nsnull != aLineInfo) {
  4572:         DWORD displacement = 0;
  4572:         BOOL lineRes = FALSE;
 90802:         lineRes = SymGetLineFromAddr64(aProcess, aAddr, &displacement, aLineInfo);
 12185:         if (!lineRes) {
 12185:             // Clear out aLineInfo to indicate that it's not valid
 12185:             memset(aLineInfo, 0, sizeof(*aLineInfo));
 12185:         }
  4572:     }
  4572: 
  4572:     return retval;
  4572: }
  4572: 
 79445: bool
  4572: EnsureSymInitialized()
  4572: {
 79445:     static bool gInitialized = false;
 79445:     bool retStat;
  4572: 
  4572:     if (gInitialized)
  4572:         return gInitialized;
  4572: 
 42480:     NS_TIME_FUNCTION;
 42480: 
  4572:     if (!EnsureImageHlpInitialized())
 80486:         return false;
  4572: 
 90802:     SymSetOptions(SYMOPT_LOAD_LINES | SYMOPT_UNDNAME);
 90802:     retStat = SymInitialize(GetCurrentProcess(), NULL, TRUE);
  4572:     if (!retStat)
  4572:         PrintError("SymInitialize");
  4572: 
  4572:     gInitialized = retStat;
 90802:     /* XXX At some point we need to arrange to call SymCleanup */
  4572: 
  4572:     return retStat;
  4572: }
  4572: 
  4572: 
  4572: EXPORT_XPCOM_API(nsresult)
  4572: NS_DescribeCodeAddress(void *aPC, nsCodeAddressDetails *aDetails)
  4572: {
  4572:     aDetails->library[0] = '\0';
  4572:     aDetails->loffset = 0;
  4572:     aDetails->filename[0] = '\0';
  4572:     aDetails->lineno = 0;
  4572:     aDetails->function[0] = '\0';
  4572:     aDetails->foffset = 0;
  4572: 
  4572:     if (!EnsureSymInitialized())
  4572:         return NS_ERROR_FAILURE;
  4572: 
  4572:     HANDLE myProcess = ::GetCurrentProcess();
  4572:     BOOL ok;
  4572: 
  4572:     // debug routines are not threadsafe, so grab the lock.
  5365:     EnterCriticalSection(&gDbgHelpCS);
  4572: 
  4572:     //
  4572:     // Attempt to load module info before we attempt to resolve the symbol.
  4572:     // This just makes sure we get good info if available.
  4572:     //
  4572: 
  4572:     DWORD64 addr = (DWORD64)aPC;
  4572:     IMAGEHLP_MODULE64 modInfo;
  4626:     IMAGEHLP_LINE64 lineInfo;
  4572:     BOOL modInfoRes;
  4626:     modInfoRes = SymGetModuleInfoEspecial64(myProcess, addr, &modInfo, &lineInfo);
  4572: 
  4572:     if (modInfoRes) {
  4572:         PL_strncpyz(aDetails->library, modInfo.ModuleName,
  4572:                     sizeof(aDetails->library));
  4572:         aDetails->loffset = (char*) aPC - (char*) modInfo.BaseOfImage;
 12185:         
 12185:         if (lineInfo.FileName) {
  4626:             PL_strncpyz(aDetails->filename, lineInfo.FileName,
  4626:                         sizeof(aDetails->filename));
  4626:             aDetails->lineno = lineInfo.LineNumber;
  4572:         }
 12185:     }
  4572: 
  4572:     ULONG64 buffer[(sizeof(SYMBOL_INFO) +
  4572:       MAX_SYM_NAME*sizeof(TCHAR) + sizeof(ULONG64) - 1) / sizeof(ULONG64)];
  4572:     PSYMBOL_INFO pSymbol = (PSYMBOL_INFO)buffer;
  4572:     pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
  4572:     pSymbol->MaxNameLen = MAX_SYM_NAME;
  4572: 
  4572:     DWORD64 displacement;
 90802:     ok = SymFromAddr(myProcess, addr, &displacement, pSymbol);
  4572: 
  4572:     if (ok) {
  4572:         PL_strncpyz(aDetails->function, pSymbol->Name,
  4572:                     sizeof(aDetails->function));
  4572:         aDetails->foffset = displacement;
  4572:     }
  4572: 
  5365:     LeaveCriticalSection(&gDbgHelpCS); // release our lock
  4572:     return NS_OK;
  4572: }
  4572: 
  4572: EXPORT_XPCOM_API(nsresult)
  4572: NS_FormatCodeAddressDetails(void *aPC, const nsCodeAddressDetails *aDetails,
  4572:                             char *aBuffer, PRUint32 aBufferSize)
  4572: {
  4572:     if (aDetails->function[0])
  4626:         _snprintf(aBuffer, aBufferSize, "%s!%s+0x%016lX",
  4572:                   aDetails->library, aDetails->function, aDetails->foffset);
  4572:     else
  4626:         _snprintf(aBuffer, aBufferSize, "0x%016lX", aPC);
 90802: 
  4626:     aBuffer[aBufferSize - 1] = '\0';
  4626: 
  4626:     PRUint32 len = strlen(aBuffer);
  4626:     if (aDetails->filename[0]) {
  4626:         _snprintf(aBuffer + len, aBufferSize - len, " (%s, line %d)\n",
  4626:                   aDetails->filename, aDetails->lineno);
  4626:     } else {
  4626:         aBuffer[len] = '\n';
  4626:         if (++len != aBufferSize)
  4626:             aBuffer[len] = '\0';
  4626:     }
  4626:     aBuffer[aBufferSize - 2] = '\n';
  4626:     aBuffer[aBufferSize - 1] = '\0';
  4572:     return NS_OK;
  4572: }
  4487: 
  4487: // WIN32 x86 stack walking code
  4487: // i386 or PPC Linux stackwalking code or Solaris
 86079: #elif HAVE_DLADDR && (HAVE__UNWIND_BACKTRACE || NSSTACKWALK_SUPPORTS_LINUX || NSSTACKWALK_SUPPORTS_SOLARIS || NSSTACKWALK_SUPPORTS_MACOSX)
  4572: 
  4572: #include <stdlib.h>
  4572: #include <string.h>
  4572: #include <math.h>
  4572: #include "nscore.h"
  4572: #include <stdio.h>
  4572: #include "plstr.h"
  4572: 
  4572: // On glibc 2.1, the Dl_info api defined in <dlfcn.h> is only exposed
  4572: // if __USE_GNU is defined.  I suppose its some kind of standards
  4572: // adherence thing.
  4572: //
  4572: #if (__GLIBC_MINOR__ >= 1) && !defined(__USE_GNU)
  4572: #define __USE_GNU
  4572: #endif
  4572: 
  4572: // This thing is exported by libstdc++
  4572: // Yes, this is a gcc only hack
  4572: #if defined(MOZ_DEMANGLE_SYMBOLS)
  4572: #include <cxxabi.h>
  4572: #include <stdlib.h> // for free()
  4572: #endif // MOZ_DEMANGLE_SYMBOLS
  4572: 
  4572: void DemangleSymbol(const char * aSymbol, 
  4572:                     char * aBuffer,
  4572:                     int aBufLen)
  4572: {
  4572:     aBuffer[0] = '\0';
  4572: 
  4572: #if defined(MOZ_DEMANGLE_SYMBOLS)
  4572:     /* See demangle.h in the gcc source for the voodoo */
  4572:     char * demangled = abi::__cxa_demangle(aSymbol,0,0,0);
  4572:     
  4572:     if (demangled)
  4572:     {
  4572:         strncpy(aBuffer,demangled,aBufLen);
  4572:         free(demangled);
  4572:     }
  4572: #endif // MOZ_DEMANGLE_SYMBOLS
  4572: }
  4572: 
  4572: 
 86079: #if NSSTACKWALK_SUPPORTS_SOLARIS
  4572: 
  7836: /*
  7836:  * Stack walking code for Solaris courtesy of Bart Smaalder's "memtrak".
  7836:  */
  7836: 
  7836: #include <synch.h>
  7836: #include <ucontext.h>
  7836: #include <sys/frame.h>
  7836: #include <sys/regset.h>
  7836: #include <sys/stack.h>
  7836: 
  7836: static int    load_address ( void * pc, void * arg );
  7836: static struct bucket * newbucket ( void * pc );
  7836: static struct frame * cs_getmyframeptr ( void );
  7836: static void   cs_walk_stack ( void * (*read_func)(char * address),
  7836:                               struct frame * fp,
  7836:                               int (*operate_func)(void *, void *),
  7836:                               void * usrarg );
  7836: static void   cs_operate ( void (*operate_func)(void *, void *),
  7836:                            void * usrarg );
  7836: 
  7836: #ifndef STACK_BIAS
  7836: #define STACK_BIAS 0
  7836: #endif /*STACK_BIAS*/
  7836: 
  7836: #define LOGSIZE 4096
  7836: 
  7836: /* type of demangling function */
  7836: typedef int demf_t(const char *, char *, size_t);
  7836: 
  7836: static demf_t *demf;
  7836: 
  7836: static int initialized = 0;
  7836: 
  7836: #if defined(sparc) || defined(__sparc)
  7836: #define FRAME_PTR_REGISTER REG_SP
  7836: #endif
  7836: 
  7836: #if defined(i386) || defined(__i386)
  7836: #define FRAME_PTR_REGISTER EBP
  7836: #endif
  7836: 
  7836: struct bucket {
  7836:     void * pc;
  7836:     int index;
  7836:     struct bucket * next;
  7836: };
  7836: 
  7836: struct my_user_args {
  7836:     NS_WalkStackCallback callback;
  7836:     PRUint32 skipFrames;
  7836:     void *closure;
  7836: };
  7836: 
  7836: 
  7836: static void myinit();
  7836: 
  7836: #pragma init (myinit)
  7836: 
  7836: static void
  7836: myinit()
  7836: {
  7836: 
  7836:     if (! initialized) {
  7836: #ifndef __GNUC__
  7836:         void *handle;
  7836:         const char *libdem = "libdemangle.so.1";
  7836: 
  7836:         /* load libdemangle if we can and need to (only try this once) */
  7836:         if ((handle = dlopen(libdem, RTLD_LAZY)) != NULL) {
  7836:             demf = (demf_t *)dlsym(handle,
  7836:                            "cplus_demangle"); /*lint !e611 */
  7836:                 /*
  7836:                  * lint override above is to prevent lint from
  7836:                  * complaining about "suspicious cast".
  7836:                  */
  7836:         }
  7836: #endif /*__GNUC__*/
  7836:     }    
  7836:     initialized = 1;
  7836: }
  7836: 
  7836: 
  7836: static int
  7836: load_address(void * pc, void * arg )
  7836: {
  7836:     static struct bucket table[2048];
  7836:     static mutex_t lock;
  7836:     struct bucket * ptr;
  7836:     struct my_user_args * args = (struct my_user_args *) arg;
  7836: 
  7836:     unsigned int val = NS_PTR_TO_INT32(pc);
  7836: 
  7836:     ptr = table + ((val >> 2)&2047);
  7836: 
  7836:     mutex_lock(&lock);
  7836:     while (ptr->next) {
  7836:         if (ptr->next->pc == pc)
  7836:             break;
  7836:         ptr = ptr->next;
  7836:     }
  7836: 
  7836:     if (ptr->next) {
  7836:         mutex_unlock(&lock);
  7836:     } else {
  7836:         (args->callback)(pc, args->closure);
  7836: 
  7836:         ptr->next = newbucket(pc);
  7836:         mutex_unlock(&lock);
  7836:     }
  7836:     return 0;
  7836: }
  7836: 
  7836: 
  7836: static struct bucket *
  7836: newbucket(void * pc)
  7836: {
  7836:     struct bucket * ptr = (struct bucket *) malloc(sizeof (*ptr));
  7836:     static int index; /* protected by lock in caller */
  7836:                      
  7836:     ptr->index = index++;
  7836:     ptr->next = NULL;
  7836:     ptr->pc = pc;    
  7836:     return (ptr);    
  7836: }
  7836: 
  7836: 
  7836: static struct frame *
  7836: csgetframeptr()
  7836: {
  7836:     ucontext_t u;
  7836:     struct frame *fp;
  7836: 
  7836:     (void) getcontext(&u);
  7836: 
  7836:     fp = (struct frame *)
  7836:         ((char *)u.uc_mcontext.gregs[FRAME_PTR_REGISTER] +
  7836:         STACK_BIAS);
  7836: 
  7836:     /* make sure to return parents frame pointer.... */
  7836: 
  7836:     return ((struct frame *)((ulong_t)fp->fr_savfp + STACK_BIAS));
  7836: }
  7836: 
  7836: 
  7836: static void
  7836: cswalkstack(struct frame *fp, int (*operate_func)(void *, void *),
  7836:     void *usrarg)
  7836: {
  7836: 
  7836:     while (fp != 0 && fp->fr_savpc != 0) {
  7836: 
  7836:         if (operate_func((void *)fp->fr_savpc, usrarg) != 0)
  7836:             break;
  7836:         /*
  7836:          * watch out - libthread stacks look funny at the top
  7836:          * so they may not have their STACK_BIAS set
  7836:          */
  7836: 
  7836:         fp = (struct frame *)((ulong_t)fp->fr_savfp +
  7836:             (fp->fr_savfp?(ulong_t)STACK_BIAS:0));
  7836:     }
  7836: }
  7836: 
  7836: 
  7836: static void
  7836: cs_operate(int (*operate_func)(void *, void *), void * usrarg)
  7836: {
  7836:     cswalkstack(csgetframeptr(), operate_func, usrarg);
  7836: }
  7836: 
  7836: EXPORT_XPCOM_API(nsresult)
  7836: NS_StackWalk(NS_WalkStackCallback aCallback, PRUint32 aSkipFrames,
 86282:              void *aClosure, uintptr_t aThread)
  7836: {
 83190:     MOZ_ASSERT(gCriticalAddress.mInit);
 86282:     MOZ_ASSERT(!aThread);
  7836:     struct my_user_args args;
  7836: 
  7836:     if (!initialized)
  7836:         myinit();
  7836: 
  7836:     args.callback = aCallback;
  7836:     args.skipFrames = aSkipFrames; /* XXX Not handled! */
  7836:     args.closure = aClosure;
  7836:     cs_operate(load_address, &args);
  7836:     return NS_OK;
  7836: }
  7836: 
  7836: EXPORT_XPCOM_API(nsresult)
  7836: NS_DescribeCodeAddress(void *aPC, nsCodeAddressDetails *aDetails)
  7836: {
  7836:     aDetails->library[0] = '\0';
  7836:     aDetails->loffset = 0;
  7836:     aDetails->filename[0] = '\0';
  7836:     aDetails->lineno = 0;
  7836:     aDetails->function[0] = '\0';
  7836:     aDetails->foffset = 0;
  7836: 
  7836:     char dembuff[4096];
  7836:     Dl_info info;
  7836: 
  7836:     if (dladdr(aPC, & info)) {
  7836:         if (info.dli_fname) {
  7836:             PL_strncpyz(aDetails->library, info.dli_fname,
  7836:                         sizeof(aDetails->library));
  7836:             aDetails->loffset = (char*)aPC - (char*)info.dli_fbase;
  7836:         }
  7836:         if (info.dli_sname) {
  7836:             aDetails->foffset = (char*)aPC - (char*)info.dli_saddr;
  7836: #ifdef __GNUC__
  7836:             DemangleSymbol(info.dli_sname, dembuff, sizeof(dembuff));
  7836: #else
  7836:             if (!demf || demf(info.dli_sname, dembuff, sizeof (dembuff)))
  7836:                 dembuff[0] = 0;
  7836: #endif /*__GNUC__*/
  7836:             PL_strncpyz(aDetails->function,
  7836:                         (dembuff[0] != '\0') ? dembuff : info.dli_sname,
  7836:                         sizeof(aDetails->function));
  7836:         }
  7836:     }
  7836: 
  7836:     return NS_OK;
  7836: }
  7836: 
  7836: EXPORT_XPCOM_API(nsresult)
  7836: NS_FormatCodeAddressDetails(void *aPC, const nsCodeAddressDetails *aDetails,
  7836:                             char *aBuffer, PRUint32 aBufferSize)
  7836: {
  7836:     snprintf(aBuffer, aBufferSize, "%p %s:%s+0x%lx\n",
  7836:              aPC,
  7836:              aDetails->library[0] ? aDetails->library : "??",
  7836:              aDetails->function[0] ? aDetails->function : "??",
  7836:              aDetails->foffset);
  7836:     return NS_OK;
  7836: }
  7836: 
  7836: #else // not __sun-specific
  7836: 
  7836: #if __GLIBC__ > 2 || __GLIBC_MINOR > 1
  7836: #define HAVE___LIBC_STACK_END 1
  7836: #else
  7836: #define HAVE___LIBC_STACK_END 0
  7836: #endif
  7836: 
  7836: #if HAVE___LIBC_STACK_END
  7836: extern void *__libc_stack_end; // from ld-linux.so
  7836: #endif
 89958: namespace mozilla {
 89958: nsresult
 89958: FramePointerStackWalk(NS_WalkStackCallback aCallback, PRUint32 aSkipFrames,
 91921:                       void *aClosure, void **bp, void *aStackEnd)
  4572: {
  4572:   // Stack walking code courtesy Kipp's "leaky".
  4572: 
  4572:   int skip = aSkipFrames;
  7836:   while (1) {
  7836:     void **next = (void**)*bp;
  7836:     // bp may not be a frame pointer on i386 if code was compiled with
  7836:     // -fomit-frame-pointer, so do some sanity checks.
  7836:     // (bp should be a frame pointer on ppc(64) but checking anyway may help
  7836:     // a little if the stack has been corrupted.)
 91921:     // We don't need to check against the begining of the stack because
 91921:     // we can assume that bp > sp
  7836:     if (next <= bp ||
 91921:         next > aStackEnd ||
  7836:         (long(next) & 3)) {
  7836:       break;
  7836:     }
  7836: #if (defined(__ppc__) && defined(XP_MACOSX)) || defined(__powerpc64__)
  7836:     // ppc mac or powerpc64 linux
  4701:     void *pc = *(bp+2);
  7836: #else // i386 or powerpc32 linux
  4572:     void *pc = *(bp+1);
  4701: #endif
 83190:     if (IsCriticalAddress(pc)) {
 83190:       printf("Aborting stack trace, PC is critical\n");
 25120:       return NS_ERROR_UNEXPECTED;
 25120:     }
  4572:     if (--skip < 0) {
  4572:       (*aCallback)(pc, aClosure);
  4572:     }
  7836:     bp = next;
  4572:   }
  4572:   return NS_OK;
  4572: }
  4572: 
 89958: }
 89958: 
 89958: #define X86_OR_PPC (defined(__i386) || defined(PPC) || defined(__ppc__))
 89958: #if X86_OR_PPC && (NSSTACKWALK_SUPPORTS_MACOSX || NSSTACKWALK_SUPPORTS_LINUX) // i386 or PPC Linux or Mac stackwalking code
 89958: 
 89958: EXPORT_XPCOM_API(nsresult)
 89958: NS_StackWalk(NS_WalkStackCallback aCallback, PRUint32 aSkipFrames,
 89958:              void *aClosure, uintptr_t aThread)
 89958: {
 89958:   MOZ_ASSERT(gCriticalAddress.mInit);
 89958:   MOZ_ASSERT(!aThread);
 89958: 
 89958:   // Get the frame pointer
 89958:   void **bp;
 89958: #if defined(__i386) 
 89958:   __asm__( "movl %%ebp, %0" : "=g"(bp));
 89958: #else
 89958:   // It would be nice if this worked uniformly, but at least on i386 and
 89958:   // x86_64, it stopped working with gcc 4.1, because it points to the
 89958:   // end of the saved registers instead of the start.
 89958:   bp = (void**) __builtin_frame_address(0);
 89958: #endif
 91921: 
 91921:   void *stackEnd;
 91921: #if HAVE___LIBC_STACK_END
 91921:   stackEnd = __libc_stack_end;
 91921: #else
 91921:   stackEnd = reinterpret_cast<void*>(-1);
 91921: #endif
 89958:   return FramePointerStackWalk(aCallback, aSkipFrames,
 91921:                                aClosure, bp, stackEnd);
 89958: 
 89958: }
 89958: 
  7836: #elif defined(HAVE__UNWIND_BACKTRACE)
  7836: 
  7836: // libgcc_s.so symbols _Unwind_Backtrace@@GCC_3.3 and _Unwind_GetIP@@GCC_3.0
  7836: #include <unwind.h>
  7836: 
  7836: struct unwind_info {
  7836:     NS_WalkStackCallback callback;
  7836:     int skip;
  7836:     void *closure;
  7836: };
  7836: 
  7836: static _Unwind_Reason_Code
  7836: unwind_callback (struct _Unwind_Context *context, void *closure)
  7836: {
  7836:     unwind_info *info = static_cast<unwind_info *>(closure);
  7836:     void *pc = reinterpret_cast<void *>(_Unwind_GetIP(context));
 83190:     if (IsCriticalAddress(pc)) {
 83190:         printf("Aborting stack trace, PC is critical\n");
 83190:         /* We just want to stop the walk, so any error code will do.
 83190:            Using _URC_NORMAL_STOP would probably be the most accurate,
 83190:            but it is not defined on Android for ARM. */
 83190:         return _URC_FOREIGN_EXCEPTION_CAUGHT;
 83190:     }
 83190:     if (--info->skip < 0)
 83142:         (*info->callback)(pc, info->closure);
  7836:     return _URC_NO_REASON;
  7836: }
  7836: 
  7836: EXPORT_XPCOM_API(nsresult)
  7836: NS_StackWalk(NS_WalkStackCallback aCallback, PRUint32 aSkipFrames,
 86282:              void *aClosure, uintptr_t aThread)
  7836: {
 83190:     MOZ_ASSERT(gCriticalAddress.mInit);
 86282:     MOZ_ASSERT(!aThread);
  7836:     unwind_info info;
  7836:     info.callback = aCallback;
  7836:     info.skip = aSkipFrames + 1;
  7836:     info.closure = aClosure;
  7836: 
 83190:     _Unwind_Reason_Code t = _Unwind_Backtrace(unwind_callback, &info);
 83190:     if (t != _URC_END_OF_STACK)
 83190:         return NS_ERROR_UNEXPECTED;
  7836:     return NS_OK;
  7836: }
  7836: 
  7836: #endif
  7836: 
  4572: EXPORT_XPCOM_API(nsresult)
  4572: NS_DescribeCodeAddress(void *aPC, nsCodeAddressDetails *aDetails)
  4572: {
  4572:   aDetails->library[0] = '\0';
  4572:   aDetails->loffset = 0;
  4572:   aDetails->filename[0] = '\0';
  4572:   aDetails->lineno = 0;
  4572:   aDetails->function[0] = '\0';
  4572:   aDetails->foffset = 0;
  4572: 
  4572:   Dl_info info;
  4572:   int ok = dladdr(aPC, &info);
  4572:   if (!ok) {
  4572:     return NS_OK;
  4572:   }
  4572: 
  4572:   PL_strncpyz(aDetails->library, info.dli_fname, sizeof(aDetails->library));
  4572:   aDetails->loffset = (char*)aPC - (char*)info.dli_fbase;
  4572: 
  4572:   const char * symbol = info.dli_sname;
  4572:   int len;
  4572:   if (!symbol || !(len = strlen(symbol))) {
  4572:     return NS_OK;
  4572:   }
  4572: 
  4572:   char demangled[4096] = "\0";
  4572: 
  4572:   DemangleSymbol(symbol, demangled, sizeof(demangled));
  4572: 
  4572:   if (strlen(demangled)) {
  4572:     symbol = demangled;
  4572:     len = strlen(symbol);
  4572:   }
  4572: 
  4572:   PL_strncpyz(aDetails->function, symbol, sizeof(aDetails->function));
  4572:   aDetails->foffset = (char*)aPC - (char*)info.dli_saddr;
  4572:   return NS_OK;
  4572: }
  4572: 
  4572: EXPORT_XPCOM_API(nsresult)
  4572: NS_FormatCodeAddressDetails(void *aPC, const nsCodeAddressDetails *aDetails,
  4572:                             char *aBuffer, PRUint32 aBufferSize)
  4572: {
  4572:   if (!aDetails->library[0]) {
  4572:     snprintf(aBuffer, aBufferSize, "UNKNOWN %p\n", aPC);
  4572:   } else if (!aDetails->function[0]) {
  4572:     snprintf(aBuffer, aBufferSize, "UNKNOWN [%s +0x%08lX]\n",
  4572:                                    aDetails->library, aDetails->loffset);
  4572:   } else {
  4572:     snprintf(aBuffer, aBufferSize, "%s+0x%08lX [%s +0x%08lX]\n",
  4572:                                    aDetails->function, aDetails->foffset,
  4572:                                    aDetails->library, aDetails->loffset);
  4572:   }
  4572:   return NS_OK;
  4572: }
  4572: 
  4572: #endif
  4487: 
  4487: #else // unsupported platform.
  4487: 
  4487: EXPORT_XPCOM_API(nsresult)
  4487: NS_StackWalk(NS_WalkStackCallback aCallback, PRUint32 aSkipFrames,
 86282:              void *aClosure, uintptr_t aThread)
  4487: {
 83190:     MOZ_ASSERT(gCriticalAddress.mInit);
 86282:     MOZ_ASSERT(!aThread);
  4487:     return NS_ERROR_NOT_IMPLEMENTED;
  4487: }
  4487: 
 91650: namespace mozilla {
 91650: nsresult
 91650: FramePointerStackWalk(NS_WalkStackCallback aCallback, PRUint32 aSkipFrames,
 91650:                       void *aClosure, void **bp)
 91650: {
 91650:     return NS_ERROR_NOT_IMPLEMENTED;
 91650: }
 91650: }
 91650: 
  4488: EXPORT_XPCOM_API(nsresult)
  4488: NS_DescribeCodeAddress(void *aPC, nsCodeAddressDetails *aDetails)
  4488: {
  4488:     aDetails->library[0] = '\0';
  4488:     aDetails->loffset = 0;
  4488:     aDetails->filename[0] = '\0';
  4488:     aDetails->lineno = 0;
  4488:     aDetails->function[0] = '\0';
  4488:     aDetails->foffset = 0;
  4488:     return NS_ERROR_NOT_IMPLEMENTED;
  4488: }
  4488: 
  4488: EXPORT_XPCOM_API(nsresult)
  4488: NS_FormatCodeAddressDetails(void *aPC, const nsCodeAddressDetails *aDetails,
  4488:                             char *aBuffer, PRUint32 aBufferSize)
  4488: {
  4488:     aBuffer[0] = '\0';
  4488:     return NS_ERROR_NOT_IMPLEMENTED;
  4488: }
  4488: 
  4487: #endif
