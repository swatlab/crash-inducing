    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
32658:  * vim: set ts=8 sw=4 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jsscope_h___
    1: #define jsscope_h___
    1: /*
    1:  * JS symbol tables.
    1:  */
38562: #ifdef DEBUG
38562: #include <stdio.h>
38562: #endif
38562: 
    1: #include "jstypes.h"
40359: #include "jscntxt.h"
11377: #include "jslock.h"
    1: #include "jsobj.h"
    1: #include "jsprvtd.h"
    1: #include "jspubtd.h"
40359: #include "jspropertycache.h"
40359: #include "jspropertytree.h"
    1: 
33166: #ifdef _MSC_VER
33166: #pragma warning(push)
33166: #pragma warning(disable:4800)
39928: #pragma warning(push)
39928: #pragma warning(disable:4100) /* Silence unreferenced formal parameter warnings */
33166: #endif
33166: 
 3164: JS_BEGIN_EXTERN_C
 3164: 
    1: /*
    1:  * Given P independent, non-unique properties each of size S words mapped by
    1:  * all scopes in a runtime, construct a property tree of N nodes each of size
    1:  * S+L words (L for tree linkage).  A nominal L value is 2 for leftmost-child
    1:  * and right-sibling links.  We hope that the N < P by enough that the space
    1:  * overhead of L, and the overhead of scope entries pointing at property tree
    1:  * nodes, is worth it.
    1:  *
    1:  * The tree construction goes as follows.  If any empty scope in the runtime
    1:  * has a property X added to it, find or create a node under the tree root
    1:  * labeled X, and set scope->lastProp to point at that node.  If any non-empty
    1:  * scope whose most recently added property is labeled Y has another property
    1:  * labeled Z added, find or create a node for Z under the node that was added
    1:  * for Y, and set scope->lastProp to point at that node.
    1:  *
    1:  * A property is labeled by its members' values: id, getter, setter, slot,
    1:  * attributes, tiny or short id, and a field telling for..in order.  Note that
    1:  * labels are not unique in the tree, but they are unique among a node's kids
    1:  * (barring rare and benign multi-threaded race condition outcomes, see below)
    1:  * and along any ancestor line from the tree root to a given leaf node (except
    1:  * for the hard case of duplicate formal parameters to a function).
    1:  *
    1:  * Thus the root of the tree represents all empty scopes, and the first ply
    1:  * of the tree represents all scopes containing one property, etc.  Each node
    1:  * in the tree can stand for any number of scopes having the same ordered set
    1:  * of properties, where that node was the last added to the scope.  (We need
    1:  * not store the root of the tree as a node, and do not -- all we need are
    1:  * links to its kids.)
    1:  *
    1:  * Sidebar on for..in loop order: ECMA requires no particular order, but this
    1:  * implementation has promised and delivered property definition order, and
    1:  * compatibility is king.  We could use an order number per property, which
    1:  * would require a sort in js_Enumerate, and an entry order generation number
    1:  * per scope.  An order number beats a list, which should be doubly-linked for
    1:  * O(1) delete.  An even better scheme is to use a parent link in the property
    1:  * tree, so that the ancestor line can be iterated from scope->lastProp when
    1:  * filling in a JSIdArray from back to front.  This parent link also helps the
    1:  * GC to sweep properties iteratively.
    1:  *
    1:  * What if a property Y is deleted from a scope?  If Y is the last property in
    1:  * the scope, we simply adjust the scope's lastProp member after we remove the
    1:  * scope's hash-table entry pointing at that property node.  The parent link
    1:  * mentioned in the for..in sidebar above makes this adjustment O(1).  But if
    1:  * Y comes between X and Z in the scope, then we might have to "fork" the tree
    1:  * at X, leaving X->Y->Z in case other scopes have those properties added in
    1:  * that order; and to finish the fork, we'd add a node labeled Z with the path
    1:  * X->Z, if it doesn't exist.  This could lead to lots of extra nodes, and to
    1:  * O(n^2) growth when deleting lots of properties.
    1:  *
    1:  * Rather, for O(1) growth all around, we should share the path X->Y->Z among
    1:  * scopes having those three properties added in that order, and among scopes
    1:  * having only X->Z where Y was deleted.  All such scopes have a lastProp that
    1:  * points to the Z child of Y.  But a scope in which Y was deleted does not
    1:  * have a table entry for Y, and when iterating that scope by traversing the
    1:  * ancestor line from Z, we will have to test for a table entry for each node,
    1:  * skipping nodes that lack entries.
    1:  *
    1:  * What if we add Y again?  X->Y->Z->Y is wrong and we'll enumerate Y twice.
35453:  * Therefore we must fork in such a case if not earlier, or do something else.
35453:  * We used to fork on the theory that set after delete is rare, but the Web is
35453:  * a harsh mistress, and we now convert the scope to a "dictionary" on first
35453:  * delete, to avoid O(n^2) growth in the property tree.
    1:  *
    1:  * What about thread safety?  If the property tree operations done by requests
    1:  * are find-node and insert-node, then the only hazard is duplicate insertion.
    1:  * This is harmless except for minor bloat.  When all requests have ended or
    1:  * been suspended, the GC is free to sweep the tree after marking all nodes
 3046:  * reachable from scopes, performing remove-node operations as needed.
    1:  *
    1:  * Is the property tree worth it compared to property storage in each table's
    1:  * entries?  To decide, we must find the relation <> between the words used
    1:  * with a property tree and the words required without a tree.
    1:  *
    1:  * Model all scopes as one super-scope of capacity T entries (T a power of 2).
    1:  * Let alpha be the load factor of this double hash-table.  With the property
    1:  * tree, each entry in the table is a word-sized pointer to a node that can be
    1:  * shared by many scopes.  But all such pointers are overhead compared to the
    1:  * situation without the property tree, where the table stores property nodes
    1:  * directly, as entries each of size S words.  With the property tree, we need
    1:  * L=2 extra words per node for siblings and kids pointers.  Without the tree,
    1:  * (1-alpha)*S*T words are wasted on free or removed sentinel-entries required
    1:  * by double hashing.
    1:  *
    1:  * Therefore,
    1:  *
    1:  *      (property tree)                 <> (no property tree)
    1:  *      N*(S+L) + T                     <> S*T
    1:  *      N*(S+L) + T                     <> P*S + (1-alpha)*S*T
    1:  *      N*(S+L) + alpha*T + (1-alpha)*T <> P*S + (1-alpha)*S*T
    1:  *
    1:  * Note that P is alpha*T by definition, so
    1:  *
    1:  *      N*(S+L) + P + (1-alpha)*T <> P*S + (1-alpha)*S*T
    1:  *      N*(S+L)                   <> P*S - P + (1-alpha)*S*T - (1-alpha)*T
    1:  *      N*(S+L)                   <> (P + (1-alpha)*T) * (S-1)
    1:  *      N*(S+L)                   <> (P + (1-alpha)*P/alpha) * (S-1)
    1:  *      N*(S+L)                   <> P * (1/alpha) * (S-1)
    1:  *
    1:  * Let N = P*beta for a compression ratio beta, beta <= 1:
    1:  *
    1:  *      P*beta*(S+L) <> P * (1/alpha) * (S-1)
    1:  *      beta*(S+L)   <> (S-1)/alpha
    1:  *      beta         <> (S-1)/((S+L)*alpha)
    1:  *
    1:  * For S = 6 (32-bit architectures) and L = 2, the property tree wins iff
    1:  *
    1:  *      beta < 5/(8*alpha)
    1:  *
    1:  * We ensure that alpha <= .75, so the property tree wins if beta < .83_.  An
    1:  * average beta from recent Mozilla browser startups was around .6.
    1:  *
    1:  * Can we reduce L?  Observe that the property tree degenerates into a list of
    1:  * lists if at most one property Y follows X in all scopes.  In or near such a
    1:  * case, we waste a word on the right-sibling link outside of the root ply of
    1:  * the tree.  Note also that the root ply tends to be large, so O(n^2) growth
    1:  * searching it is likely, indicating the need for hashing (but with increased
    1:  * thread safety costs).
    1:  *
    1:  * If only K out of N nodes in the property tree have more than one child, we
    1:  * could eliminate the sibling link and overlay a children list or hash-table
    1:  * pointer on the leftmost-child link (which would then be either null or an
    1:  * only-child link; the overlay could be tagged in the low bit of the pointer,
    1:  * or flagged elsewhere in the property tree node, although such a flag must
    1:  * not be considered when comparing node labels during tree search).
    1:  *
    1:  * For such a system, L = 1 + (K * averageChildrenTableSize) / N instead of 2.
    1:  * If K << N, L approaches 1 and the property tree wins if beta < .95.
    1:  *
    1:  * We observe that fan-out below the root ply of the property tree appears to
    1:  * have extremely low degree (see the MeterPropertyTree code that histograms
    1:  * child-counts in jsscope.c), so instead of a hash-table we use a linked list
    1:  * of child node pointer arrays ("kid chunks").  The details are isolated in
    1:  * jsscope.c; others must treat JSScopeProperty.kids as opaque.  We leave it
    1:  * strongly typed for debug-ability of the common (null or one-kid) cases.
    1:  *
    1:  * One final twist (can you stand it?): the mean number of entries per scope
    1:  * in Mozilla is < 5, with a large standard deviation (~8).  Instead of always
    1:  * allocating scope->table, we leave it null while initializing all the other
    1:  * scope members as if it were non-null and minimal-length.  Until a property
35453:  * is added that crosses the threshold of 6 or more entries for hashing, we use
35453:  * linear search from scope->lastProp to find a given id, and save on the space
35453:  * overhead of a hash table.
40327:  *
40327:  * See jspropertytree.{h,cpp} for the actual PropertyTree implementation. This
40327:  * file contains object property map (historical misnomer: "scope" AKA JSScope)
40327:  * and property tree node ("sprop", JSScopeProperty) declarations.
    1:  */
    1: 
35117: struct JSEmptyScope;
35117: 
35453: #define SPROP_INVALID_SLOT              0xffffffff
35453: 
32777: struct JSScope : public JSObjectMap
32777: {
11739: #ifdef JS_THREADSAFE
11739:     JSTitle         title;              /* lock state */
11739: #endif
    1:     JSObject        *object;            /* object that owns this scope */
28353:     uint32          freeslot;           /* index of next free slot in object */
    1:     uint8           flags;              /* flags, see below */
    1:     int8            hashShift;          /* multiplicative hash shift */
30258: 
    1:     uint16          spare;              /* reserved */
    1:     uint32          entryCount;         /* number of entries in table */
    1:     uint32          removedCount;       /* removed entry sentinels in table */
    1:     JSScopeProperty **table;            /* table of ptrs to shared tree nodes */
37766:     JSEmptyScope    *emptyScope;        /* cache for getEmptyScope below */
35453: 
35453:     /*
35453:      * A little information hiding for scope->lastProp, in case it ever becomes
35453:      * a tagged pointer again.
35453:      */
35453:     inline JSScopeProperty *lastProperty() const;
30258: 
30258:   private:
35453:     JSScopeProperty *getChildProperty(JSContext *cx, JSScopeProperty *parent,
35453:                                       JSScopeProperty &child);
35453: 
35453:     JSScopeProperty *newDictionaryProperty(JSContext *cx, const JSScopeProperty &child,
35453:                                            JSScopeProperty **childp);
35453: 
35453:     bool toDictionaryMode(JSContext *cx, JSScopeProperty *&aprop);
35453: 
35453:     /*
35453:      * Private pointer to the last added property and methods to manipulate the
35453:      * list it links among properties in this scope. The {remove,insert} pair
35453:      * for DictionaryProperties assert that the scope is in dictionary mode and
35453:      * any reachable properties are flagged as dictionary properties.
35453:      *
35453:      * NB: these private methods do *not* update this scope's shape to track
35453:      * lastProp->shape after they finish updating the linked list in the case
35453:      * where lastProp is updated. It is up to calling code in jsscope.cpp to
35453:      * call updateShape(cx) after updating lastProp.
35453:      */
35453:     JSScopeProperty *lastProp;
35453: 
35453:     /* These four inline methods are defined further below in this .h file. */
35453:     inline void setLastProperty(JSScopeProperty *sprop);
35453:     inline void removeLastProperty();
35453:     inline void removeDictionaryProperty(JSScopeProperty *sprop);
35453:     inline void insertDictionaryProperty(JSScopeProperty *sprop, JSScopeProperty **childp);
35453: 
35453:     /* Defined in jsscopeinlines.h to avoid including implementation dependencies here. */
35453:     inline void updateShape(JSContext *cx);
37034:     inline void updateFlags(const JSScopeProperty *sprop);
35453: 
37766:   protected:
32652:     void initMinimal(JSContext *cx, uint32 newShape);
37766: 
37766:   private:
30258:     bool createTable(JSContext *cx, bool report);
30258:     bool changeTable(JSContext *cx, int change);
30258:     void reportReadOnlyScope(JSContext *cx);
40871: 
40871:     void setOwnShape()          { flags |= OWN_SHAPE; }
40871:     void clearOwnShape()        { flags &= ~OWN_SHAPE; }
30733:     void generateOwnShape(JSContext *cx);
40871: 
30281:     JSScopeProperty **searchTable(jsid id, bool adding);
30282:     inline JSScopeProperty **search(jsid id, bool adding);
37766:     inline JSEmptyScope *createEmptyScope(JSContext *cx, JSClass *clasp);
30258: 
35453:     JSScopeProperty *addPropertyHelper(JSContext *cx, jsid id,
35453:                                        JSPropertyOp getter, JSPropertyOp setter,
35453:                                        uint32 slot, uintN attrs,
35453:                                        uintN flags, intN shortid,
35453:                                        JSScopeProperty **spp);
35453: 
30258:   public:
37766:     JSScope(const JSObjectOps *ops, JSObject *obj)
32777:       : JSObjectMap(ops, 0), object(obj) {}
32777: 
30645:     /* Create a mutable, owned, empty scope. */
37766:     static JSScope *create(JSContext *cx, const JSObjectOps *ops,
37766:                            JSClass *clasp, JSObject *obj, uint32 shape);
30645: 
37766:     void destroy(JSContext *cx);
35117: 
30645:     /*
30645:      * Return an immutable, shareable, empty scope with the same ops as this
30645:      * and the same freeslot as this had when empty.
30645:      *
30645:      * If |this| is the scope of an object |proto|, the resulting scope can be
32717:      * used as the scope of a new object whose prototype is |proto|.
30645:      */
35117:     inline JSEmptyScope *getEmptyScope(JSContext *cx, JSClass *clasp);
30645: 
37743:     inline bool ensureEmptyScope(JSContext *cx, JSClass *clasp);
37743: 
35117:     inline bool canProvideEmptyScope(JSObjectOps *ops, JSClass *clasp);
30258: 
30258:     JSScopeProperty *lookup(jsid id);
30258: 
35453:     inline bool hasProperty(jsid id) { return lookup(id) != NULL; }
35453:     inline bool hasProperty(JSScopeProperty *sprop);
35453: 
35453:     /* Add a property whose id is not yet in this scope. */
35453:     JSScopeProperty *addProperty(JSContext *cx, jsid id,
30258:                                  JSPropertyOp getter, JSPropertyOp setter,
30258:                                  uint32 slot, uintN attrs,
30258:                                  uintN flags, intN shortid);
30258: 
35453:     /* Add a data property whose id is not yet in this scope. */
35453:     JSScopeProperty *addDataProperty(JSContext *cx, jsid id, uint32 slot, uintN attrs) {
35453:         JS_ASSERT(!(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
35453:         return addProperty(cx, id, NULL, NULL, slot, attrs, 0, 0);
35453:     }
35453: 
35453:     /* Add or overwrite a property for id in this scope. */
35453:     JSScopeProperty *putProperty(JSContext *cx, jsid id,
35453:                                  JSPropertyOp getter, JSPropertyOp setter,
35453:                                  uint32 slot, uintN attrs,
35453:                                  uintN flags, intN shortid);
35453: 
35453:     /* Change the given property into a sibling with the same id in this scope. */
35453:     JSScopeProperty *changeProperty(JSContext *cx, JSScopeProperty *sprop,
30258:                                     uintN attrs, uintN mask,
30258:                                     JSPropertyOp getter, JSPropertyOp setter);
30258: 
35453:     /* Remove id from this scope. */
35453:     bool removeProperty(JSContext *cx, jsid id);
35453: 
35453:     /* Clear the scope, making it empty. */
30258:     void clear(JSContext *cx);
30258: 
35453:     /* Extend this scope to have sprop as its last-added property. */
30258:     void extend(JSContext *cx, JSScopeProperty *sprop);
30258: 
32658:     /*
32658:      * Read barrier to clone a joined function object stored as a method.
35453:      * Defined in jsscopeinlines.h, but not declared inline per standard style
35453:      * in order to avoid gcc warnings.
32658:      */
34349:     bool methodReadBarrier(JSContext *cx, JSScopeProperty *sprop, jsval *vp);
32658: 
32658:     /*
32658:      * Write barrier to check for a method value change. Defined inline below
32658:      * after methodReadBarrier. Two flavors to handle JSOP_*GVAR, which deals
32658:      * in slots not sprops, while not deoptimizing to map slot to sprop unless
32658:      * flags show this is necessary. The methodShapeChange overload (directly
32658:      * below) parallels this.
32658:      */
34349:     bool methodWriteBarrier(JSContext *cx, JSScopeProperty *sprop, jsval v);
34349:     bool methodWriteBarrier(JSContext *cx, uint32 slot, jsval v);
32658: 
30852:     void trace(JSTracer *trc);
30852: 
30258:     void deletingShapeChange(JSContext *cx, JSScopeProperty *sprop);
41851:     bool methodShapeChange(JSContext *cx, JSScopeProperty *sprop);
41851:     bool methodShapeChange(JSContext *cx, uint32 slot);
30258:     void protoShapeChange(JSContext *cx);
30258:     void shadowingShapeChange(JSContext *cx, JSScopeProperty *sprop);
40871:     bool globalObjectOwnShapeChange(JSContext *cx);
30258: 
30258: /* By definition, hashShift = JS_DHASH_BITS - log2(capacity). */
30258: #define SCOPE_CAPACITY(scope)   JS_BIT(JS_DHASH_BITS-(scope)->hashShift)
30258: 
30258:     enum {
35453:         DICTIONARY_MODE         = 0x0001,
30258:         SEALED                  = 0x0002,
30258:         BRANDED                 = 0x0004,
30733:         INDEXED_PROPERTIES      = 0x0008,
30845:         OWN_SHAPE               = 0x0010,
32658:         METHOD_BARRIER          = 0x0020,
30845: 
30845:         /*
30845:          * This flag toggles with each shape-regenerating GC cycle.
30845:          * See JSRuntime::gcRegenShapesScopeFlag.
30845:          */
37685:         SHAPE_REGEN             = 0x0040,
37685: 
37685:         /* The anti-branded flag, to avoid overspecializing. */
37685:         GENERIC                 = 0x0080
30258:     };
30258: 
41855:     bool inDictionaryMode()     { return flags & DICTIONARY_MODE; }
35453:     void setDictionaryMode()    { flags |= DICTIONARY_MODE; }
35453:     void clearDictionaryMode()  { flags &= ~DICTIONARY_MODE; }
30258: 
30258:     /*
30258:      * Don't define clearSealed, as it can't be done safely because JS_LOCK_OBJ
30258:      * will avoid taking the lock if the object owns its scope and the scope is
30258:      * sealed.
30258:      */
41855:     bool sealed()               { return flags & SEALED; }
40327: 
40327:     void seal(JSContext *cx) {
37766:         JS_ASSERT(!isSharedEmpty());
40327:         JS_ASSERT(!sealed());
40327:         generateOwnShape(cx);
37766:         flags |= SEALED;
37766:     }
30258: 
30258:     /*
30258:      * A branded scope's object contains plain old methods (function-valued
30258:      * properties without magic getters and setters), and its scope->shape
30258:      * evolves whenever a function value changes.
30258:      */
41855:     bool branded()              { JS_ASSERT(!generic()); return flags & BRANDED; }
40327: 
40327:     bool brand(JSContext *cx, uint32 slot, jsval v) {
40327:         JS_ASSERT(!branded());
40327:         generateOwnShape(cx);
40327:         if (js_IsPropertyCacheDisabled(cx))  // check for rt->shapeGen overflow
40327:             return false;
40327:         flags |= BRANDED;
40327:         return true;
40327:     }
30733: 
41855:     bool generic()              { return flags & GENERIC; }
37685:     void setGeneric()           { flags |= GENERIC; }
37685: 
41855:     bool hadIndexedProperties() { return flags & INDEXED_PROPERTIES; }
30733:     void setIndexedProperties() { flags |= INDEXED_PROPERTIES; }
30733: 
41855:     bool hasOwnShape()          { return flags & OWN_SHAPE; }
30645: 
41855:     bool hasRegenFlag(uint8 regenFlag) { return (flags & SHAPE_REGEN) == regenFlag; }
30845: 
32658:     /*
32658:      * A scope has a method barrier when some compiler-created "null closure"
32658:      * function objects (functions that do not use lexical bindings above their
32658:      * scope, only free variable names) that have a correct JSSLOT_PARENT value
32658:      * thanks to the COMPILE_N_GO optimization are stored as newly added direct
35018:      * property values of the scope's object.
32658:      *
32658:      * The de-facto standard JS language requires each evaluation of such a
32658:      * closure to result in a unique (according to === and observable effects)
32658:      * function object. ES3 tried to allow implementations to "join" such
32658:      * objects to a single compiler-created object, but this makes an overt
32658:      * mutation hazard, also an "identity hazard" against interoperation among
32658:      * implementations that join and do not join.
32658:      *
32658:      * To stay compatible with the de-facto standard, we store the compiler-
35018:      * created function object as the method value and set the METHOD_BARRIER
35018:      * flag.
32658:      *
35018:      * The method value is part of the method property tree node's identity, so
35018:      * it effectively  brands the scope with a predictable shape corresponding
35018:      * to the method value, but without the overhead of setting the BRANDED
35018:      * flag, which requires assigning a new shape peculiar to each branded
35018:      * scope. Instead the shape is shared via the property tree among all the
35018:      * scopes referencing the method property tree node.
32658:      *
32658:      * Then when reading from a scope for which scope->hasMethodBarrier() is
32658:      * true, we count on the scope's qualified/guarded shape being unique and
32658:      * add a read barrier that clones the compiler-created function object on
32658:      * demand, reshaping the scope.
32658:      *
32658:      * This read barrier is bypassed when evaluating the callee sub-expression
32658:      * of a call expression (see the JOF_CALLOP opcodes in jsopcode.tbl), since
35018:      * such ops do not present an identity or mutation hazard. The compiler
35018:      * performs this optimization only for null closures that do not use their
35018:      * own name or equivalent built-in references (arguments.callee).
35018:      *
35018:      * The BRANDED write barrier, JSScope::methodWriteBarrer, must check for
35018:      * METHOD_BARRIER too, and regenerate this scope's shape if the method's
35018:      * value is in fact changing.
32658:      */
41855:     bool hasMethodBarrier()     { return flags & METHOD_BARRIER; }
35018:     void setMethodBarrier()     { flags |= METHOD_BARRIER; }
32658: 
35224:     /*
35224:      * Test whether this scope may be branded due to method calls, which means
35224:      * any assignment to a function-valued property must regenerate shape; else
35224:      * test whether this scope has method properties, which require a method
35224:      * write barrier.
35224:      */
41855:     bool
41855:     brandedOrHasMethodBarrier() { return flags & (BRANDED | METHOD_BARRIER); }
35224: 
37766:     bool isSharedEmpty() const  { return !object; }
37766: 
37766:     static bool initRuntimeState(JSContext *cx);
37766:     static void finishRuntimeState(JSContext *cx);
11739: };
11739: 
35117: struct JSEmptyScope : public JSScope
35117: {
35117:     JSClass * const clasp;
37766:     jsrefcount      nrefs;              /* count of all referencing objects */
35117: 
37766:     JSEmptyScope(JSContext *cx, const JSObjectOps *ops, JSClass *clasp);
37766: 
37766:     void hold() {
37766:         /* The method is only called for already held objects. */
37766:         JS_ASSERT(nrefs >= 1);
37766:         JS_ATOMIC_INCREMENT(&nrefs);
37766:     }
37766: 
37766:     void drop(JSContext *cx) {
37766:         JS_ASSERT(nrefs >= 1);
37766:         JS_ATOMIC_DECREMENT(&nrefs);
37766:         if (nrefs == 0)
37766:             destroy(cx);
37766:     }
37766: 
37766:     /*
37766:      * Optimized version of the drop method to use from the object finalizer
37766:      * to skip expensive JS_ATOMIC_DECREMENT.
37766:      */
37766:     void dropFromGC(JSContext *cx) {
37766: #ifdef JS_THREADSAFE
37766:         JS_ASSERT(CX_THREAD_IS_RUNNING_GC(cx));
37766: #endif
37766:         JS_ASSERT(nrefs >= 1);
37766:         --nrefs;
37766:         if (nrefs == 0)
37766:             destroy(cx);
37766:     }
35117: };
35117: 
32777: inline bool
32777: JS_IS_SCOPE_LOCKED(JSContext *cx, JSScope *scope)
32777: {
32777:     return JS_IS_TITLE_LOCKED(cx, &scope->title);
32777: }
    1: 
32777: inline JSScope *
40847: JSObject::scope() const
32777: {
40847:     JS_ASSERT(isNative());
40847:     return (JSScope *) map;
32777: }
32777: 
32777: inline uint32
40847: JSObject::shape() const
32777: {
40847:     JS_ASSERT(map->shape != JSObjectMap::SHAPELESS);
40847:     return map->shape;
40847: }
40847: 
40847: inline jsval
40847: JSObject::lockedGetSlot(uintN slot) const
40847: {
40847:     OBJ_CHECK_SLOT(this, slot);
40847:     return this->getSlot(slot);
40847: }
40847: 
40847: inline void
40847: JSObject::lockedSetSlot(uintN slot, jsval value)
40847: {
40847:     OBJ_CHECK_SLOT(this, slot);
40847:     this->setSlot(slot, value);
32777: }
12307: 
11377: /*
25218:  * Helpers for reinterpreting JSPropertyOp as JSObject* for scripted getters
25218:  * and setters.
25218:  */
41860: namespace js {
41860: 
32777: inline JSObject *
41860: CastAsObject(JSPropertyOp op)
25218: {
25218:     return JS_FUNC_TO_DATA_PTR(JSObject *, op);
25218: }
25218: 
32777: inline jsval
41860: CastAsObjectJSVal(JSPropertyOp op)
25218: {
25218:     return OBJECT_TO_JSVAL(JS_FUNC_TO_DATA_PTR(JSObject *, op));
25218: }
25218: 
40327: class PropertyTree;
41860: 
41860: } /* namespace js */
40327: 
    1: struct JSScopeProperty {
39928:     friend struct JSScope;
40327:     friend class js::PropertyTree;
40327:     friend JSDHashOperator js::RemoveNodeIfDead(JSDHashTable *table, JSDHashEntryHdr *hdr,
40327:                                                 uint32 number, void *arg);
40327:     friend void js::SweepScopeProperties(JSContext *cx);
38562: 
    1:     jsid            id;                 /* int-tagged jsval/untagged JSAtom* */
40331: 
39894:   private:
40331:     union {
39894:         JSPropertyOp    rawGetter;      /* getter and setter hooks or objects */
41860:         JSObject        *getterObj;     /* user-defined callable "get" object or
41860:                                            null if sprop->hasGetterValue() */
40331:         JSScopeProperty *next;          /* next node in freelist */
40331:     };
40331: 
40331:     union {
39894:         JSPropertyOp    rawSetter;      /* getter is JSObject* and setter is 0
32658:                                            if sprop->isMethod() */
41860:         JSObject        *setterObj;     /* user-defined callable "set" object or
41860:                                            null if sprop->hasSetterValue() */
40331:         JSScopeProperty **prevp;        /* pointer to previous node's next, or
40331:                                            pointer to head of freelist */
40331:     };
40331: 
40331:     void insertFree(JSScopeProperty *&list) {
40331:         id = JSVAL_NULL;
40331:         next = list;
40331:         prevp = &list;
40331:         if (list)
40331:             list->prevp = &next;
40331:         list = this;
40331:     }
40331: 
40331:     void removeFree() {
40331:         JS_ASSERT(JSVAL_IS_NULL(id));
40331:         *prevp = next;
40331:         if (next)
40331:             next->prevp = prevp;
40331:     }
40331: 
39894:   public:
    1:     uint32          slot;               /* abstract index in object slots */
40265:   private:
    1:     uint8           attrs;              /* attributes, see jsapi.h JSPROP_* */
    1:     uint8           flags;              /* flags, see below for defines */
38562:   public:
    1:     int16           shortid;            /* tinyid, or local arg/var index */
    1:     JSScopeProperty *parent;            /* parent node, reverse for..in order */
35453:     union {
    1:         JSScopeProperty *kids;          /* null, single child, or a tagged ptr
    1:                                            to many-kids data structure */
35453:         JSScopeProperty **childp;       /* dictionary list starting at lastProp
35453:                                            has a double-indirect back pointer,
35453:                                            either to sprop->parent if not last,
35453:                                            else to scope->lastProp */
35453:     };
11377:     uint32          shape;              /* property cache shape identifier */
30258: 
38562:   private:
40327:     /*
40327:      * Implementation-private bits stored in sprop->flags. See public: enum {}
40327:      * flags further below, which were allocated FCFS over time, so interleave
40327:      * with these bits.
40327:      */
38562:     enum {
38562:         /* GC mark flag. */
38562:         MARK            = 0x01,
32658: 
38562:         /*
38562:          * Set during a shape-regenerating GC if the shape has already been
38562:          * regenerated. Unlike JSScope::SHAPE_REGEN, this does not toggle with
40327:          * each GC. js::SweepScopeProperties clears it.
38562:          */
38562:         SHAPE_REGEN     = 0x08,
38562: 
38562:         /* Property stored in per-object dictionary, not shared property tree. */
38562:         IN_DICTIONARY   = 0x20
38562:     };
38562: 
39894:     JSScopeProperty(jsid id, JSPropertyOp getter, JSPropertyOp setter, uint32 slot,
39894:                     uintN attrs, uintN flags, intN shortid)
39928:         : id(id), rawGetter(getter), rawSetter(setter), slot(slot), attrs(uint8(attrs)),
39928:           flags(uint8(flags)), shortid(int16(shortid))
39894:     {
41860:         JS_ASSERT_IF(getter && (attrs & JSPROP_GETTER), getterObj->isCallable());
41860:         JS_ASSERT_IF(setter && (attrs & JSPROP_SETTER), setterObj->isCallable());
39894:     }
39894: 
38562:     bool marked() const { return (flags & MARK) != 0; }
38562:     void mark() { flags |= MARK; }
38562:     void clearMark() { flags &= ~MARK; }
38562: 
38562:     bool hasRegenFlag() const { return (flags & SHAPE_REGEN) != 0; }
38562:     void setRegenFlag() { flags |= SHAPE_REGEN; }
38562:     void clearRegenFlag() { flags &= ~SHAPE_REGEN; }
38562: 
38562:     bool inDictionary() const { return (flags & IN_DICTIONARY) != 0; }
38562: 
38562:   public:
38562:     /* Public bits stored in sprop->flags. */
38562:     enum {
38562:         ALIAS           = 0x02,
38562:         HAS_SHORTID     = 0x04,
38562:         METHOD          = 0x10,
38562:         PUBLIC_FLAGS    = ALIAS | HAS_SHORTID | METHOD
38562:     };
38562: 
38562:     uintN getFlags() const  { return flags & PUBLIC_FLAGS; }
38562:     bool isAlias() const    { return (flags & ALIAS) != 0; }
38562:     bool hasShortID() const { return (flags & HAS_SHORTID) != 0; }
38562:     bool isMethod() const   { return (flags & METHOD) != 0; }
38562: 
41860:     JSObject *methodObject() const { JS_ASSERT(isMethod()); return getterObj; }
41860:     jsval methodValue() const      { return OBJECT_TO_JSVAL(methodObject()); }
32658: 
39894:     JSPropertyOp getter() const    { return rawGetter; }
39894:     bool hasDefaultGetter() const  { return !rawGetter; }
41860:     JSPropertyOp getterOp() const  { JS_ASSERT(!hasGetterValue()); return rawGetter; }
41860:     JSObject *getterObject() const { JS_ASSERT(hasGetterValue()); return getterObj; }
41860: 
41860:     // Per ES5, decode null getterObj as the undefined value, which encodes as null.
32658:     jsval getterValue() const {
40265:         JS_ASSERT(hasGetterValue());
41860:         return getterObj ? OBJECT_TO_JSVAL(getterObj) : JSVAL_VOID;
32658:     }
32658: 
39894:     JSPropertyOp setter() const    { return rawSetter; }
39894:     bool hasDefaultSetter() const  { return !rawSetter; }
41860:     JSPropertyOp setterOp() const  { JS_ASSERT(!hasSetterValue()); return rawSetter; }
41860:     JSObject *setterObject() const { JS_ASSERT(hasSetterValue()); return setterObj; }
41860: 
41860:     // Per ES5, decode null setterObj as the undefined value, which encodes as null.
32658:     jsval setterValue() const {
40265:         JS_ASSERT(hasSetterValue());
41860:         return setterObj ? OBJECT_TO_JSVAL(setterObj) : JSVAL_VOID;
32658:     }
32658: 
38562:     inline JSDHashNumber hash() const;
38562:     inline bool matches(const JSScopeProperty *p) const;
38562:     inline bool matchesParamsAfterId(JSPropertyOp agetter, JSPropertyOp asetter, uint32 aslot,
38562:                                      uintN aattrs, uintN aflags, intN ashortid) const;
38562: 
32658:     bool get(JSContext* cx, JSObject* obj, JSObject *pobj, jsval* vp);
32658:     bool set(JSContext* cx, JSObject* obj, jsval* vp);
32658: 
40327:     inline bool isSharedPermanent() const;
40327: 
30258:     void trace(JSTracer *trc);
36991: 
40265:     bool hasSlot() const { return (attrs & JSPROP_SHARED) == 0; }
36991: 
40265:     uint8 attributes() const { return attrs; }
40265:     bool configurable() const { return (attrs & JSPROP_PERMANENT) == 0; }
40265:     bool enumerable() const { return (attrs & JSPROP_ENUMERATE) != 0; }
40265:     bool writable() const {
40265:         // JS_ASSERT(isDataDescriptor());
40265:         return (attrs & JSPROP_READONLY) == 0;
40265:     }
40265:     bool hasGetterValue() const { return attrs & JSPROP_GETTER; }
40265:     bool hasSetterValue() const { return attrs & JSPROP_SETTER; }
40265: 
40265:     bool hasDefaultGetterOrIsMethod() const {
40265:         return hasDefaultGetter() || isMethod();
40265:     }
40265: 
40265:     bool isDataDescriptor() const {
36991:         return (attrs & (JSPROP_SETTER | JSPROP_GETTER)) == 0;
36991:     }
40265:     bool isAccessorDescriptor() const {
36991:         return (attrs & (JSPROP_SETTER | JSPROP_GETTER)) != 0;
36991:     }
38562: 
38562: #ifdef DEBUG
38562:     void dump(JSContext *cx, FILE *fp);
38562:     void dumpSubtree(JSContext *cx, int level, FILE *fp);
38562: #endif
    1: };
    1: 
    1: /* JSScopeProperty pointer tag bit indicating a collision. */
    1: #define SPROP_COLLISION                 ((jsuword)1)
    1: #define SPROP_REMOVED                   ((JSScopeProperty *) SPROP_COLLISION)
    1: 
    1: /* Macros to get and set sprop pointer values and collision flags. */
    1: #define SPROP_IS_FREE(sprop)            ((sprop) == NULL)
    1: #define SPROP_IS_REMOVED(sprop)         ((sprop) == SPROP_REMOVED)
    1: #define SPROP_IS_LIVE(sprop)            ((sprop) > SPROP_REMOVED)
    1: #define SPROP_FLAG_COLLISION(spp,sprop) (*(spp) = (JSScopeProperty *)         \
    1:                                          ((jsuword)(sprop) | SPROP_COLLISION))
    1: #define SPROP_HAD_COLLISION(sprop)      ((jsuword)(sprop) & SPROP_COLLISION)
    1: #define SPROP_FETCH(spp)                SPROP_CLEAR_COLLISION(*(spp))
    1: 
    1: #define SPROP_CLEAR_COLLISION(sprop)                                          \
    1:     ((JSScopeProperty *) ((jsuword)(sprop) & ~SPROP_COLLISION))
    1: 
    1: #define SPROP_STORE_PRESERVING_COLLISION(spp, sprop)                          \
    1:     (*(spp) = (JSScopeProperty *) ((jsuword)(sprop)                           \
    1:                                    | SPROP_HAD_COLLISION(*(spp))))
    1: 
32658: inline JSScopeProperty *
30258: JSScope::lookup(jsid id)
30258: {
30258:     return SPROP_FETCH(search(id, false));
30258: }
30258: 
32658: inline bool
35453: JSScope::hasProperty(JSScopeProperty *sprop)
30258: {
30258:     return lookup(sprop->id) == sprop;
30258: }
30258: 
35453: inline JSScopeProperty *
35453: JSScope::lastProperty() const
35453: {
35453:     JS_ASSERT_IF(lastProp, !JSVAL_IS_NULL(lastProp->id));
35453:     return lastProp;
35453: }
35453: 
35453: /*
35453:  * Note that sprop must not be null, as emptying a scope requires extra work
35453:  * done only by methods in jsscope.cpp.
35453:  */
35453: inline void
35453: JSScope::setLastProperty(JSScopeProperty *sprop)
35453: {
35453:     JS_ASSERT(!JSVAL_IS_NULL(sprop->id));
35453:     JS_ASSERT_IF(lastProp, !JSVAL_IS_NULL(lastProp->id));
35453: 
35453:     lastProp = sprop;
35453: }
35453: 
35453: inline void
35453: JSScope::removeLastProperty()
35453: {
35453:     JS_ASSERT(!inDictionaryMode());
35453:     JS_ASSERT_IF(lastProp->parent, !JSVAL_IS_NULL(lastProp->parent->id));
35453: 
35453:     lastProp = lastProp->parent;
35453:     --entryCount;
35453: }
35453: 
35453: inline void
35453: JSScope::removeDictionaryProperty(JSScopeProperty *sprop)
35453: {
35453:     JS_ASSERT(inDictionaryMode());
38562:     JS_ASSERT(sprop->inDictionary());
35453:     JS_ASSERT(sprop->childp);
35453:     JS_ASSERT(!JSVAL_IS_NULL(sprop->id));
35453: 
38562:     JS_ASSERT(lastProp->inDictionary());
35453:     JS_ASSERT(lastProp->childp == &lastProp);
35453:     JS_ASSERT_IF(lastProp != sprop, !JSVAL_IS_NULL(lastProp->id));
35453:     JS_ASSERT_IF(lastProp->parent, !JSVAL_IS_NULL(lastProp->parent->id));
35453: 
35453:     if (sprop->parent)
35453:         sprop->parent->childp = sprop->childp;
35453:     *sprop->childp = sprop->parent;
35453:     --entryCount;
35453:     sprop->childp = NULL;
35453: }
35453: 
35453: inline void
35453: JSScope::insertDictionaryProperty(JSScopeProperty *sprop, JSScopeProperty **childp)
35453: {
35453:     /*
35453:      * Don't assert inDictionaryMode() here because we may be called from
35453:      * toDictionaryMode via newDictionaryProperty.
35453:      */
38562:     JS_ASSERT(sprop->inDictionary());
35453:     JS_ASSERT(!sprop->childp);
35453:     JS_ASSERT(!JSVAL_IS_NULL(sprop->id));
35453: 
38562:     JS_ASSERT_IF(*childp, (*childp)->inDictionary());
38562:     JS_ASSERT_IF(lastProp, lastProp->inDictionary());
35453:     JS_ASSERT_IF(lastProp, lastProp->childp == &lastProp);
35453:     JS_ASSERT_IF(lastProp, !JSVAL_IS_NULL(lastProp->id));
35453: 
35453:     sprop->parent = *childp;
35453:     *childp = sprop;
35453:     if (sprop->parent)
35453:         sprop->parent->childp = &sprop->parent;
35453:     sprop->childp = childp;
35453:     ++entryCount;
35453: }
35453: 
    1: /*
38562:  * If SHORTID is set in sprop->flags, we use sprop->shortid rather
    1:  * than id when calling sprop's getter or setter.
    1:  */
    1: #define SPROP_USERID(sprop)                                                   \
38562:     ((sprop)->hasShortID() ? INT_TO_JSVAL((sprop)->shortid)                   \
    1:                            : ID_TO_VALUE((sprop)->id))
    1: 
28353: #define SLOT_IN_SCOPE(slot,scope)         ((slot) < (scope)->freeslot)
    1: #define SPROP_HAS_VALID_SLOT(sprop,scope) SLOT_IN_SCOPE((sprop)->slot, scope)
    1: 
30258: #ifndef JS_THREADSAFE
30258: # define js_GenerateShape(cx, gcLocked)    js_GenerateShape (cx)
30258: #endif
30258: 
30258: extern uint32
30258: js_GenerateShape(JSContext *cx, bool gcLocked);
30258: 
35453: #ifdef DEBUG
32658: struct JSScopeStats {
32658:     jsrefcount          searches;
32658:     jsrefcount          hits;
32658:     jsrefcount          misses;
32658:     jsrefcount          hashes;
32658:     jsrefcount          steps;
32658:     jsrefcount          stepHits;
32658:     jsrefcount          stepMisses;
35453:     jsrefcount          tableAllocFails;
35453:     jsrefcount          toDictFails;
35453:     jsrefcount          wrapWatchFails;
32658:     jsrefcount          adds;
35453:     jsrefcount          addFails;
35453:     jsrefcount          puts;
35453:     jsrefcount          redundantPuts;
35453:     jsrefcount          putFails;
35453:     jsrefcount          changes;
35453:     jsrefcount          changeFails;
32658:     jsrefcount          compresses;
32658:     jsrefcount          grows;
32658:     jsrefcount          removes;
32658:     jsrefcount          removeFrees;
32658:     jsrefcount          uselessRemoves;
32658:     jsrefcount          shrinks;
32658: };
32658: 
32658: extern JS_FRIEND_DATA(JSScopeStats) js_scope_stats;
32658: 
30281: # define METER(x)       JS_ATOMIC_INCREMENT(&js_scope_stats.x)
30281: #else
30281: # define METER(x)       /* nothing */
30281: #endif
30281: 
30281: inline JSScopeProperty **
30281: JSScope::search(jsid id, bool adding)
30281: {
30281:     JSScopeProperty *sprop, **spp;
30281: 
30281:     METER(searches);
30281:     if (!table) {
30281:         /* Not enough properties to justify hashing: search from lastProp. */
30281:         for (spp = &lastProp; (sprop = *spp); spp = &sprop->parent) {
30281:             if (sprop->id == id) {
30281:                 METER(hits);
30281:                 return spp;
30281:             }
30281:         }
30281:         METER(misses);
30281:         return spp;
30281:     }
30281:     return searchTable(id, adding);
30281: }
30281: 
30281: #undef METER
30281: 
35117: inline bool
35117: JSScope::canProvideEmptyScope(JSObjectOps *ops, JSClass *clasp)
35117: {
40327:     /*
40327:      * An empty scope cannot provide another empty scope, or wrongful two-level
40327:      * prototype shape sharing ensues -- see bug 497789.
40327:      */
40327:     if (!object)
40327:         return false;
35117:     return this->ops == ops && (!emptyScope || emptyScope->clasp == clasp);
35117: }
35117: 
32658: inline bool
32658: JSScopeProperty::get(JSContext* cx, JSObject* obj, JSObject *pobj, jsval* vp)
32658: {
33133:     JS_ASSERT(!JSVAL_IS_NULL(this->id));
40265:     JS_ASSERT(!hasDefaultGetter());
30852: 
40265:     if (hasGetterValue()) {
32658:         JS_ASSERT(!isMethod());
32658:         jsval fval = getterValue();
32658:         return js_InternalGetOrSet(cx, obj, id, fval, JSACC_READ, 0, 0, vp);
32658:     }
    1: 
32658:     if (isMethod()) {
32658:         *vp = methodValue();
32658: 
40847:         JSScope *scope = pobj->scope();
32658:         JS_ASSERT(scope->object == pobj);
32658:         return scope->methodReadBarrier(cx, this, vp);
24852:     }
24852: 
28936:     /*
28936:      * JSObjectOps is private, so we know there are only two implementations
28936:      * of the thisObject hook: with objects and XPConnect wrapped native
28936:      * objects.  XPConnect objects don't expect the hook to be called here,
28936:      * but with objects do.
28936:      */
40410:     if (obj->getClass() == &js_WithClass)
28936:         obj = obj->map->ops->thisObject(cx, obj);
39894:     return getterOp()(cx, obj, SPROP_USERID(this), vp);
24852: }
24852: 
32658: inline bool
32658: JSScopeProperty::set(JSContext* cx, JSObject* obj, jsval* vp)
24852: {
40265:     JS_ASSERT_IF(hasDefaultSetter(), hasGetterValue());
24852: 
32658:     if (attrs & JSPROP_SETTER) {
32658:         jsval fval = setterValue();
32658:         return js_InternalGetOrSet(cx, obj, id, fval, JSACC_WRITE, 1, vp, vp);
24852:     }
24852: 
36491:     if (attrs & JSPROP_GETTER)
36491:         return !!js_ReportGetterOnlyAssignment(cx);
24852: 
32658:     /* See the comment in JSScopeProperty::get as to why we can check for With. */
40410:     if (obj->getClass() == &js_WithClass)
28936:         obj = obj->map->ops->thisObject(cx, obj);
39894:     return setterOp()(cx, obj, SPROP_USERID(this), vp);
24852: }
    1: 
40265: inline bool
40327: JSScopeProperty::isSharedPermanent() const
40265: {
40327:     return (~attrs & (JSPROP_SHARED | JSPROP_PERMANENT)) == 0;
40265: }
    1: 
    1: extern JSScope *
    1: js_GetMutableScope(JSContext *cx, JSObject *obj);
    1: 
    1: extern void
  583: js_TraceId(JSTracer *trc, jsid id);
    1: 
 3164: JS_END_EXTERN_C
 3164: 
33166: #ifdef _MSC_VER
33166: #pragma warning(pop)
39928: #pragma warning(pop)
33166: #endif
33166: 
    1: #endif /* jsscope_h___ */
