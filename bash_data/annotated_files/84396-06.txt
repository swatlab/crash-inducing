    1: /* vim:set ts=4 sw=4 et cindent: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2002
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Darin Fisher <darin@netscape.com>
    1:  *   Malcolm Smith <malsmith@cs.rmit.edu.au>
    1:  *   Andreas Otte <andreas.otte@debitel.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifdef MOZ_LOGGING
    1: #define FORCE_PR_LOG
    1: #endif
    1: 
    1: #include "nsSocketTransport2.h"
64101: #include "nsAtomicRefcnt.h"
    1: #include "nsIOService.h"
    1: #include "nsStreamUtils.h"
    1: #include "nsNetSegmentUtils.h"
    1: #include "nsTransportUtils.h"
    1: #include "nsProxyInfo.h"
    1: #include "nsNetCID.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsCOMPtr.h"
    1: #include "netCore.h"
    1: #include "prmem.h"
    1: #include "plstr.h"
    1: #include "prnetdb.h"
    1: #include "prerror.h"
    1: #include "prerr.h"
    1: 
    1: #include "nsIServiceManager.h"
    1: #include "nsISocketProviderService.h"
    1: #include "nsISocketProvider.h"
    1: #include "nsISSLSocketControl.h"
    1: #include "nsINSSErrorsService.h"
    1: #include "nsIPipe.h"
    1: #include "nsIProgrammingLanguage.h"
 3849: #include "nsIClassInfoImpl.h"
    1: 
51789: #if defined(XP_WIN) || defined(MOZ_PLATFORM_MAEMO)
    1: #include "nsNativeConnectionHelper.h"
    1: #endif
    1: 
64576: using namespace mozilla;
64576: 
    1: //-----------------------------------------------------------------------------
    1: 
    1: static NS_DEFINE_CID(kSocketProviderServiceCID, NS_SOCKETPROVIDERSERVICE_CID);
    1: static NS_DEFINE_CID(kDNSServiceCID, NS_DNSSERVICE_CID);
    1: 
    1: //-----------------------------------------------------------------------------
    1: 
    1: class nsSocketEvent : public nsRunnable
    1: {
    1: public:
    1:     nsSocketEvent(nsSocketTransport *transport, PRUint32 type,
    1:                   nsresult status = NS_OK, nsISupports *param = nsnull)
    1:         : mTransport(transport)
    1:         , mType(type)
    1:         , mStatus(status)
    1:         , mParam(param)
    1:     {}
    1: 
    1:     NS_IMETHOD Run()
    1:     {
    1:         mTransport->OnSocketEvent(mType, mStatus, mParam);
    1:         return NS_OK;
    1:     }
    1: 
    1: private:
    1:     nsRefPtr<nsSocketTransport> mTransport;
    1: 
    1:     PRUint32              mType;
    1:     nsresult              mStatus;
    1:     nsCOMPtr<nsISupports> mParam;
    1: };
    1: 
    1: //-----------------------------------------------------------------------------
    1: 
    1: //#define TEST_CONNECT_ERRORS
    1: #ifdef TEST_CONNECT_ERRORS
    1: #include <stdlib.h>
    1: static PRErrorCode RandomizeConnectError(PRErrorCode code)
    1: {
    1:     //
    1:     // To test out these errors, load http://www.yahoo.com/.  It should load
    1:     // correctly despite the random occurrence of these errors.
    1:     //
    1:     int n = rand();
    1:     if (n > RAND_MAX/2) {
    1:         struct {
    1:             PRErrorCode err_code;
    1:             const char *err_name;
    1:         } 
    1:         errors[] = {
    1:             //
    1:             // These errors should be recoverable provided there is another
    1:             // IP address in mDNSRecord.
    1:             //
    1:             { PR_CONNECT_REFUSED_ERROR, "PR_CONNECT_REFUSED_ERROR" },
    1:             { PR_CONNECT_TIMEOUT_ERROR, "PR_CONNECT_TIMEOUT_ERROR" },
    1:             //
    1:             // This error will cause this socket transport to error out;
    1:             // however, if the consumer is HTTP, then the HTTP transaction
    1:             // should be restarted when this error occurs.
    1:             //
    1:             { PR_CONNECT_RESET_ERROR, "PR_CONNECT_RESET_ERROR" },
    1:         };
    1:         n = n % (sizeof(errors)/sizeof(errors[0]));
    1:         code = errors[n].err_code;
56649:         SOCKET_LOG(("simulating NSPR error %d [%s]\n", code, errors[n].err_name));
    1:     }
    1:     return code;
    1: }
    1: #endif
    1: 
    1: //-----------------------------------------------------------------------------
    1: 
79445: static bool
 8680: IsNSSErrorCode(PRErrorCode code)
 8680: {
 8680:   return 
 8680:     ((code >= nsINSSErrorsService::NSS_SEC_ERROR_BASE) && 
 8680:       (code < nsINSSErrorsService::NSS_SEC_ERROR_LIMIT))
 8680:     ||
 8680:     ((code >= nsINSSErrorsService::NSS_SSL_ERROR_BASE) && 
 8680:       (code < nsINSSErrorsService::NSS_SSL_ERROR_LIMIT));
 8680: }
 8680: 
 8680: // this logic is duplicated from the implementation of
 8680: // nsINSSErrorsService::getXPCOMFromNSSError
 8680: // It might have been better to implement that interface here...
 8680: static nsresult
 8680: GetXPCOMFromNSSError(PRErrorCode code)
 8680: {
 8680:     return NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_SECURITY, -1 * code);
 8680: }
 8680: 
    1: static nsresult
    1: ErrorAccordingToNSPR(PRErrorCode errorCode)
    1: {
    1:     nsresult rv = NS_ERROR_FAILURE;
    1:     switch (errorCode) {
    1:     case PR_WOULD_BLOCK_ERROR:
    1:         rv = NS_BASE_STREAM_WOULD_BLOCK;
    1:         break;
    1:     case PR_CONNECT_ABORTED_ERROR:
    1:     case PR_CONNECT_RESET_ERROR:
    1:         rv = NS_ERROR_NET_RESET;
    1:         break;
    1:     case PR_END_OF_FILE_ERROR: // XXX document this correlation
    1:         rv = NS_ERROR_NET_INTERRUPT;
    1:         break;
    1:     case PR_CONNECT_REFUSED_ERROR:
    1:     case PR_NETWORK_UNREACHABLE_ERROR: // XXX need new nsresult for this!
    1:     case PR_HOST_UNREACHABLE_ERROR:    // XXX and this!
    1:     case PR_ADDRESS_NOT_AVAILABLE_ERROR:
    1:     // Treat EACCES as a soft error since (at least on Linux) connect() returns
    1:     // EACCES when an IPv6 connection is blocked by a firewall. See bug 270784.
    1:     case PR_ADDRESS_NOT_SUPPORTED_ERROR:
    1:     case PR_NO_ACCESS_RIGHTS_ERROR:
    1:         rv = NS_ERROR_CONNECTION_REFUSED;
    1:         break;
    1:     case PR_IO_TIMEOUT_ERROR:
    1:     case PR_CONNECT_TIMEOUT_ERROR:
    1:         rv = NS_ERROR_NET_TIMEOUT;
    1:         break;
    1:     default:
 8680:         if (IsNSSErrorCode(errorCode))
 8680:             rv = GetXPCOMFromNSSError(errorCode);
 8680:         break;
    1:     }
56649:     SOCKET_LOG(("ErrorAccordingToNSPR [in=%d out=%x]\n", errorCode, rv));
    1:     return rv;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // socket input stream impl 
    1: //-----------------------------------------------------------------------------
    1: 
    1: nsSocketInputStream::nsSocketInputStream(nsSocketTransport *trans)
    1:     : mTransport(trans)
    1:     , mReaderRefCnt(0)
    1:     , mCondition(NS_OK)
    1:     , mCallbackFlags(0)
    1:     , mByteCount(0)
    1: {
    1: }
    1: 
    1: nsSocketInputStream::~nsSocketInputStream()
    1: {
    1: }
    1: 
    1: // called on the socket transport thread...
    1: //
    1: //   condition : failure code if socket has been closed
    1: //
    1: void
    1: nsSocketInputStream::OnSocketReady(nsresult condition)
    1: {
56649:     SOCKET_LOG(("nsSocketInputStream::OnSocketReady [this=%x cond=%x]\n",
    1:         this, condition));
    1: 
    1:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
    1: 
    1:     nsCOMPtr<nsIInputStreamCallback> callback;
    1:     {
64576:         MutexAutoLock lock(mTransport->mLock);
    1: 
    1:         // update condition, but be careful not to erase an already
    1:         // existing error condition.
    1:         if (NS_SUCCEEDED(mCondition))
    1:             mCondition = condition;
    1: 
    1:         // ignore event if only waiting for closure and not closed.
    1:         if (NS_FAILED(mCondition) || !(mCallbackFlags & WAIT_CLOSURE_ONLY)) {
    1:             callback = mCallback;
    1:             mCallback = nsnull;
    1:             mCallbackFlags = 0;
    1:         }
    1:     }
    1: 
    1:     if (callback)
    1:         callback->OnInputStreamReady(this);
    1: }
    1: 
    1: NS_IMPL_QUERY_INTERFACE2(nsSocketInputStream,
    1:                          nsIInputStream,
    1:                          nsIAsyncInputStream)
    1: 
    1: NS_IMETHODIMP_(nsrefcnt)
    1: nsSocketInputStream::AddRef()
    1: {
64101:     NS_AtomicIncrementRefcnt(mReaderRefCnt);
    1:     return mTransport->AddRef();
    1: }
    1: 
    1: NS_IMETHODIMP_(nsrefcnt)
    1: nsSocketInputStream::Release()
    1: {
64101:     if (NS_AtomicDecrementRefcnt(mReaderRefCnt) == 0)
    1:         Close();
    1:     return mTransport->Release();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketInputStream::Close()
    1: {
    1:     return CloseWithStatus(NS_BASE_STREAM_CLOSED);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketInputStream::Available(PRUint32 *avail)
    1: {
56649:     SOCKET_LOG(("nsSocketInputStream::Available [this=%x]\n", this));
    1: 
    1:     *avail = 0;
    1: 
    1:     PRFileDesc *fd;
    1:     {
64576:         MutexAutoLock lock(mTransport->mLock);
    1: 
    1:         if (NS_FAILED(mCondition))
    1:             return mCondition;
    1: 
    1:         fd = mTransport->GetFD_Locked();
    1:         if (!fd)
    1:             return NS_OK;
    1:     }
    1: 
    1:     // cannot hold lock while calling NSPR.  (worried about the fact that PSM
    1:     // synchronously proxies notifications over to the UI thread, which could
    1:     // mistakenly try to re-enter this code.)
    1:     PRInt32 n = PR_Available(fd);
    1: 
    1:     nsresult rv;
    1:     {
64576:         MutexAutoLock lock(mTransport->mLock);
    1: 
    1:         mTransport->ReleaseFD_Locked(fd);
    1: 
    1:         if (n >= 0)
    1:             *avail = n;
    1:         else {
    1:             PRErrorCode code = PR_GetError();
    1:             if (code == PR_WOULD_BLOCK_ERROR)
    1:                 return NS_OK;
    1:             mCondition = ErrorAccordingToNSPR(code);
    1:         }
    1:         rv = mCondition;
    1:     }
    1:     if (NS_FAILED(rv))
    1:         mTransport->OnInputClosed(rv);
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketInputStream::Read(char *buf, PRUint32 count, PRUint32 *countRead)
    1: {
56649:     SOCKET_LOG(("nsSocketInputStream::Read [this=%x count=%u]\n", this, count));
    1: 
    1:     *countRead = 0;
    1: 
    1:     PRFileDesc *fd;
    1:     {
64576:         MutexAutoLock lock(mTransport->mLock);
    1: 
    1:         if (NS_FAILED(mCondition))
    1:             return (mCondition == NS_BASE_STREAM_CLOSED) ? NS_OK : mCondition;
    1: 
    1:         fd = mTransport->GetFD_Locked();
    1:         if (!fd)
    1:             return NS_BASE_STREAM_WOULD_BLOCK;
    1:     }
    1: 
56649:     SOCKET_LOG(("  calling PR_Read [count=%u]\n", count));
    1: 
    1:     // cannot hold lock while calling NSPR.  (worried about the fact that PSM
    1:     // synchronously proxies notifications over to the UI thread, which could
    1:     // mistakenly try to re-enter this code.)
    1:     PRInt32 n = PR_Read(fd, buf, count);
    1: 
56649:     SOCKET_LOG(("  PR_Read returned [n=%d]\n", n));
    1: 
    1:     nsresult rv;
    1:     {
64576:         MutexAutoLock lock(mTransport->mLock);
    1: 
    1: #ifdef ENABLE_SOCKET_TRACING
    1:         if (n > 0)
    1:             mTransport->TraceInBuf(buf, n);
    1: #endif
    1: 
    1:         mTransport->ReleaseFD_Locked(fd);
    1: 
    1:         if (n > 0)
    1:             mByteCount += (*countRead = n);
    1:         else if (n < 0) {
    1:             PRErrorCode code = PR_GetError();
    1:             if (code == PR_WOULD_BLOCK_ERROR)
    1:                 return NS_BASE_STREAM_WOULD_BLOCK;
    1:             mCondition = ErrorAccordingToNSPR(code);
    1:         }
    1:         rv = mCondition;
    1:     }
    1:     if (NS_FAILED(rv))
    1:         mTransport->OnInputClosed(rv);
    1: 
    1:     // only send this notification if we have indeed read some data.
    1:     // see bug 196827 for an example of why this is important.
    1:     if (n > 0)
    1:         mTransport->SendStatus(nsISocketTransport::STATUS_RECEIVING_FROM);
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketInputStream::ReadSegments(nsWriteSegmentFun writer, void *closure,
    1:                                   PRUint32 count, PRUint32 *countRead)
    1: {
    1:     // socket stream is unbuffered
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsSocketInputStream::IsNonBlocking(bool *nonblocking)
    1: {
80486:     *nonblocking = true;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketInputStream::CloseWithStatus(nsresult reason)
    1: {
56649:     SOCKET_LOG(("nsSocketInputStream::CloseWithStatus [this=%x reason=%x]\n", this, reason));
    1: 
    1:     // may be called from any thread
    1:  
    1:     nsresult rv;
    1:     {
64576:         MutexAutoLock lock(mTransport->mLock);
    1: 
    1:         if (NS_SUCCEEDED(mCondition))
    1:             rv = mCondition = reason;
    1:         else
    1:             rv = NS_OK;
    1:     }
    1:     if (NS_FAILED(rv))
    1:         mTransport->OnInputClosed(rv);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketInputStream::AsyncWait(nsIInputStreamCallback *callback,
    1:                                PRUint32 flags,
    1:                                PRUint32 amount,
    1:                                nsIEventTarget *target)
    1: {
56649:     SOCKET_LOG(("nsSocketInputStream::AsyncWait [this=%x]\n", this));
    1: 
    1:     // This variable will be non-null when we want to call the callback
    1:     // directly from this function, but outside the lock.
    1:     // (different from callback when target is not null)
    1:     nsCOMPtr<nsIInputStreamCallback> directCallback;
    1:     {
64576:         MutexAutoLock lock(mTransport->mLock);
    1: 
    1:         if (callback && target) {
    1:             //
    1:             // build event proxy
    1:             //
    1:             // failure to create an event proxy (most likely out of memory)
    1:             // shouldn't alter the state of the transport.
    1:             //
    1:             nsCOMPtr<nsIInputStreamCallback> temp;
    1:             nsresult rv = NS_NewInputStreamReadyEvent(getter_AddRefs(temp),
    1:                                                       callback, target);
    1:             if (NS_FAILED(rv)) return rv;
    1:             mCallback = temp;
    1:         }
    1:         else
    1:             mCallback = callback;
    1: 
    1:         if (NS_FAILED(mCondition))
    1:             directCallback.swap(mCallback);
    1:         else
    1:             mCallbackFlags = flags;
    1:     }
    1:     if (directCallback)
    1:         directCallback->OnInputStreamReady(this);
    1:     else
    1:         mTransport->OnInputPending();
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // socket output stream impl 
    1: //-----------------------------------------------------------------------------
    1: 
    1: nsSocketOutputStream::nsSocketOutputStream(nsSocketTransport *trans)
    1:     : mTransport(trans)
    1:     , mWriterRefCnt(0)
    1:     , mCondition(NS_OK)
    1:     , mCallbackFlags(0)
    1:     , mByteCount(0)
    1: {
    1: }
    1: 
    1: nsSocketOutputStream::~nsSocketOutputStream()
    1: {
    1: }
    1: 
    1: // called on the socket transport thread...
    1: //
    1: //   condition : failure code if socket has been closed
    1: //
    1: void
    1: nsSocketOutputStream::OnSocketReady(nsresult condition)
    1: {
56649:     SOCKET_LOG(("nsSocketOutputStream::OnSocketReady [this=%x cond=%x]\n",
    1:         this, condition));
    1: 
    1:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
    1: 
    1:     nsCOMPtr<nsIOutputStreamCallback> callback;
    1:     {
64576:         MutexAutoLock lock(mTransport->mLock);
    1: 
    1:         // update condition, but be careful not to erase an already
    1:         // existing error condition.
    1:         if (NS_SUCCEEDED(mCondition))
    1:             mCondition = condition;
    1: 
    1:         // ignore event if only waiting for closure and not closed.
    1:         if (NS_FAILED(mCondition) || !(mCallbackFlags & WAIT_CLOSURE_ONLY)) {
    1:             callback = mCallback;
    1:             mCallback = nsnull;
    1:             mCallbackFlags = 0;
    1:         }
    1:     }
    1: 
    1:     if (callback)
    1:         callback->OnOutputStreamReady(this);
    1: }
    1: 
    1: NS_IMPL_QUERY_INTERFACE2(nsSocketOutputStream,
    1:                          nsIOutputStream,
    1:                          nsIAsyncOutputStream)
    1: 
    1: NS_IMETHODIMP_(nsrefcnt)
    1: nsSocketOutputStream::AddRef()
    1: {
64101:     NS_AtomicIncrementRefcnt(mWriterRefCnt);
    1:     return mTransport->AddRef();
    1: }
    1: 
    1: NS_IMETHODIMP_(nsrefcnt)
    1: nsSocketOutputStream::Release()
    1: {
64101:     if (NS_AtomicDecrementRefcnt(mWriterRefCnt) == 0)
    1:         Close();
    1:     return mTransport->Release();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketOutputStream::Close()
    1: {
    1:     return CloseWithStatus(NS_BASE_STREAM_CLOSED);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketOutputStream::Flush()
    1: {
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketOutputStream::Write(const char *buf, PRUint32 count, PRUint32 *countWritten)
    1: {
56649:     SOCKET_LOG(("nsSocketOutputStream::Write [this=%x count=%u]\n", this, count));
    1: 
    1:     *countWritten = 0;
    1: 
84396:     if (count == 0)
    1:         return NS_OK;
    1: 
    1:     PRFileDesc *fd;
    1:     {
64576:         MutexAutoLock lock(mTransport->mLock);
    1: 
    1:         if (NS_FAILED(mCondition))
    1:             return mCondition;
    1:         
    1:         fd = mTransport->GetFD_Locked();
    1:         if (!fd)
    1:             return NS_BASE_STREAM_WOULD_BLOCK;
    1:     }
    1: 
56649:     SOCKET_LOG(("  calling PR_Write [count=%u]\n", count));
    1: 
    1:     // cannot hold lock while calling NSPR.  (worried about the fact that PSM
    1:     // synchronously proxies notifications over to the UI thread, which could
    1:     // mistakenly try to re-enter this code.)
    1:     PRInt32 n = PR_Write(fd, buf, count);
    1: 
56649:     SOCKET_LOG(("  PR_Write returned [n=%d]\n", n));
    1:     NS_ASSERTION(n != 0, "unexpected return value");
    1: 
    1:     nsresult rv;
    1:     {
64576:         MutexAutoLock lock(mTransport->mLock);
    1: 
    1: #ifdef ENABLE_SOCKET_TRACING
    1:     if (n > 0)
    1:         mTransport->TraceOutBuf(buf, n);
    1: #endif
    1: 
    1:         mTransport->ReleaseFD_Locked(fd);
    1: 
    1:         if (n > 0)
    1:             mByteCount += (*countWritten = n);
    1:         else if (n < 0) {
    1:             PRErrorCode code = PR_GetError();
    1:             if (code == PR_WOULD_BLOCK_ERROR)
    1:                 return NS_BASE_STREAM_WOULD_BLOCK;
    1:             mCondition = ErrorAccordingToNSPR(code);
    1:         }
    1:         rv = mCondition;
    1:     }
    1:     if (NS_FAILED(rv))
    1:         mTransport->OnOutputClosed(rv);
    1: 
    1:     // only send this notification if we have indeed written some data.
    1:     // see bug 196827 for an example of why this is important.
    1:     if (n > 0)
    1:         mTransport->SendStatus(nsISocketTransport::STATUS_SENDING_TO);
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketOutputStream::WriteSegments(nsReadSegmentFun reader, void *closure,
    1:                                     PRUint32 count, PRUint32 *countRead)
    1: {
    1:     // socket stream is unbuffered
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_METHOD
    1: nsSocketOutputStream::WriteFromSegments(nsIInputStream *input,
    1:                                         void *closure,
    1:                                         const char *fromSegment,
    1:                                         PRUint32 offset,
    1:                                         PRUint32 count,
    1:                                         PRUint32 *countRead)
    1: {
    1:     nsSocketOutputStream *self = (nsSocketOutputStream *) closure;
    1:     return self->Write(fromSegment, count, countRead);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketOutputStream::WriteFrom(nsIInputStream *stream, PRUint32 count, PRUint32 *countRead)
    1: {
    1:     return stream->ReadSegments(WriteFromSegments, this, count, countRead);
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsSocketOutputStream::IsNonBlocking(bool *nonblocking)
    1: {
80486:     *nonblocking = true;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketOutputStream::CloseWithStatus(nsresult reason)
    1: {
56649:     SOCKET_LOG(("nsSocketOutputStream::CloseWithStatus [this=%x reason=%x]\n", this, reason));
    1: 
    1:     // may be called from any thread
    1:  
    1:     nsresult rv;
    1:     {
64576:         MutexAutoLock lock(mTransport->mLock);
    1: 
    1:         if (NS_SUCCEEDED(mCondition))
    1:             rv = mCondition = reason;
    1:         else
    1:             rv = NS_OK;
    1:     }
    1:     if (NS_FAILED(rv))
    1:         mTransport->OnOutputClosed(rv);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketOutputStream::AsyncWait(nsIOutputStreamCallback *callback,
    1:                                 PRUint32 flags,
    1:                                 PRUint32 amount,
    1:                                 nsIEventTarget *target)
    1: {
56649:     SOCKET_LOG(("nsSocketOutputStream::AsyncWait [this=%x]\n", this));
    1: 
    1:     {
64576:         MutexAutoLock lock(mTransport->mLock);
    1: 
    1:         if (callback && target) {
    1:             //
    1:             // build event proxy
    1:             //
    1:             // failure to create an event proxy (most likely out of memory)
    1:             // shouldn't alter the state of the transport.
    1:             //
    1:             nsCOMPtr<nsIOutputStreamCallback> temp;
    1:             nsresult rv = NS_NewOutputStreamReadyEvent(getter_AddRefs(temp),
    1:                                                        callback, target);
    1:             if (NS_FAILED(rv)) return rv;
    1:             mCallback = temp;
    1:         }
    1:         else
    1:             mCallback = callback;
    1: 
    1:         mCallbackFlags = flags;
    1:     }
    1:     mTransport->OnOutputPending();
    1:     return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // socket transport impl
    1: //-----------------------------------------------------------------------------
    1: 
    1: nsSocketTransport::nsSocketTransport()
    1:     : mTypes(nsnull)
    1:     , mTypeCount(0)
    1:     , mPort(0)
    1:     , mProxyPort(0)
80486:     , mProxyTransparent(false)
80486:     , mProxyTransparentResolvesHost(false)
21294:     , mConnectionFlags(0)
    1:     , mState(STATE_CLOSED)
80486:     , mAttached(false)
80486:     , mInputClosed(true)
80486:     , mOutputClosed(true)
80486:     , mResolving(false)
64576:     , mLock("nsSocketTransport.mLock")
    1:     , mFD(nsnull)
    1:     , mFDref(0)
80486:     , mFDconnected(false)
    1:     , mInput(this)
    1:     , mOutput(this)
43040:     , mQoSBits(0x00)
    1: {
56649:     SOCKET_LOG(("creating nsSocketTransport @%x\n", this));
    1: 
    1:     NS_ADDREF(gSocketTransportService);
    1: 
    1:     mTimeouts[TIMEOUT_CONNECT]    = PR_UINT16_MAX; // no timeout
    1:     mTimeouts[TIMEOUT_READ_WRITE] = PR_UINT16_MAX; // no timeout
    1: }
    1: 
    1: nsSocketTransport::~nsSocketTransport()
    1: {
56649:     SOCKET_LOG(("destroying nsSocketTransport @%x\n", this));
    1: 
    1:     // cleanup socket type info
    1:     if (mTypes) {
    1:         PRUint32 i;
    1:         for (i=0; i<mTypeCount; ++i)
    1:             PL_strfree(mTypes[i]);
    1:         free(mTypes);
    1:     }
    1:  
    1:     nsSocketTransportService *serv = gSocketTransportService;
    1:     NS_RELEASE(serv); // nulls argument
    1: }
    1: 
    1: nsresult
    1: nsSocketTransport::Init(const char **types, PRUint32 typeCount,
    1:                         const nsACString &host, PRUint16 port,
    1:                         nsIProxyInfo *givenProxyInfo)
    1: {
    1:     nsCOMPtr<nsProxyInfo> proxyInfo;
    1:     if (givenProxyInfo) {
    1:         proxyInfo = do_QueryInterface(givenProxyInfo);
    1:         NS_ENSURE_ARG(proxyInfo);
    1:     }
    1: 
    1:     // init socket type info
    1: 
    1:     mPort = port;
    1:     mHost = host;
    1: 
    1:     const char *proxyType = nsnull;
    1:     if (proxyInfo) {
    1:         mProxyPort = proxyInfo->Port();
    1:         mProxyHost = proxyInfo->Host();
    1:         // grab proxy type (looking for "socks" for example)
    1:         proxyType = proxyInfo->Type();
    1:         if (proxyType && (strcmp(proxyType, "http") == 0 ||
    1:                           strcmp(proxyType, "direct") == 0 ||
    1:                           strcmp(proxyType, "unknown") == 0))
    1:             proxyType = nsnull;
    1:     }
    1: 
56649:     SOCKET_LOG(("nsSocketTransport::Init [this=%x host=%s:%hu proxy=%s:%hu]\n",
    1:         this, mHost.get(), mPort, mProxyHost.get(), mProxyPort));
    1: 
    1:     // include proxy type as a socket type if proxy type is not "http"
    1:     mTypeCount = typeCount + (proxyType != nsnull);
    1:     if (!mTypeCount)
    1:         return NS_OK;
    1: 
    1:     // if we have socket types, then the socket provider service had
    1:     // better exist!
    1:     nsresult rv;
    1:     nsCOMPtr<nsISocketProviderService> spserv =
    1:         do_GetService(kSocketProviderServiceCID, &rv);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     mTypes = (char **) malloc(mTypeCount * sizeof(char *));
    1:     if (!mTypes)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     // now verify that each socket type has a registered socket provider.
    1:     for (PRUint32 i = 0, type = 0; i < mTypeCount; ++i) {
    1:         // store socket types
    1:         if (i == 0 && proxyType)
    1:             mTypes[i] = PL_strdup(proxyType);
    1:         else
    1:             mTypes[i] = PL_strdup(types[type++]);
    1: 
    1:         if (!mTypes[i]) {
    1:             mTypeCount = i;
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:         }
    1:         nsCOMPtr<nsISocketProvider> provider;
    1:         rv = spserv->GetSocketProvider(mTypes[i], getter_AddRefs(provider));
    1:         if (NS_FAILED(rv)) {
    1:             NS_WARNING("no registered socket provider");
    1:             return rv;
    1:         }
    1: 
    1:         // note if socket type corresponds to a transparent proxy
    1:         // XXX don't hardcode SOCKS here (use proxy info's flags instead).
    1:         if ((strcmp(mTypes[i], "socks") == 0) ||
    1:             (strcmp(mTypes[i], "socks4") == 0)) {
80486:             mProxyTransparent = true;
    1: 
    1:             if (proxyInfo->Flags() & nsIProxyInfo::TRANSPARENT_PROXY_RESOLVES_HOST) {
    1:                 // we want the SOCKS layer to send the hostname
    1:                 // and port to the proxy and let it do the DNS.
80486:                 mProxyTransparentResolvesHost = true;
    1:             }
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsSocketTransport::InitWithConnectedSocket(PRFileDesc *fd, const PRNetAddr *addr)
    1: {
    1:     NS_ASSERTION(!mFD, "already initialized");
    1: 
    1:     char buf[64];
    1:     PR_NetAddrToString(addr, buf, sizeof(buf));
    1:     mHost.Assign(buf);
    1: 
    1:     PRUint16 port;
    1:     if (addr->raw.family == PR_AF_INET)
    1:         port = addr->inet.port;
    1:     else
    1:         port = addr->ipv6.port;
    1:     mPort = PR_ntohs(port);
    1: 
    1:     memcpy(&mNetAddr, addr, sizeof(PRNetAddr));
    1: 
    1:     mPollFlags = (PR_POLL_READ | PR_POLL_WRITE | PR_POLL_EXCEPT);
    1:     mPollTimeout = mTimeouts[TIMEOUT_READ_WRITE];
    1:     mState = STATE_TRANSFERRING;
    1: 
    1:     mFD = fd;
    1:     mFDref = 1;
    1:     mFDconnected = 1;
    1: 
    1:     // make sure new socket is non-blocking
    1:     PRSocketOptionData opt;
    1:     opt.option = PR_SockOpt_Nonblocking;
80486:     opt.value.non_blocking = true;
    1:     PR_SetSocketOption(mFD, &opt);
    1: 
56649:     SOCKET_LOG(("nsSocketTransport::InitWithConnectedSocket [this=%p addr=%s:%hu]\n",
    1:         this, mHost.get(), mPort));
    1: 
    1:     // jump to InitiateSocket to get ourselves attached to the STS poll list.
    1:     return PostEvent(MSG_RETRY_INIT_SOCKET);
    1: }
    1: 
    1: nsresult
    1: nsSocketTransport::PostEvent(PRUint32 type, nsresult status, nsISupports *param)
    1: {
56649:     SOCKET_LOG(("nsSocketTransport::PostEvent [this=%p type=%u status=%x param=%p]\n",
    1:         this, type, status, param));
    1: 
    1:     nsCOMPtr<nsIRunnable> event = new nsSocketEvent(this, type, status, param);
    1:     if (!event)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     return gSocketTransportService->Dispatch(event, NS_DISPATCH_NORMAL);
    1: }
    1: 
    1: void
    1: nsSocketTransport::SendStatus(nsresult status)
    1: {
56649:     SOCKET_LOG(("nsSocketTransport::SendStatus [this=%x status=%x]\n", this, status));
    1: 
    1:     nsCOMPtr<nsITransportEventSink> sink;
    1:     PRUint64 progress;
    1:     {
64576:         MutexAutoLock lock(mLock);
    1:         sink = mEventSink;
    1:         switch (status) {
    1:         case STATUS_SENDING_TO:
    1:             progress = mOutput.ByteCount();
    1:             break;
    1:         case STATUS_RECEIVING_FROM:
    1:             progress = mInput.ByteCount();
    1:             break;
    1:         default:
    1:             progress = 0;
    1:             break;
    1:         }
    1:     }
    1:     if (sink)
    1:         sink->OnTransportStatus(this, status, progress, LL_MAXUINT);
    1: }
    1: 
    1: nsresult
    1: nsSocketTransport::ResolveHost()
    1: {
56649:     SOCKET_LOG(("nsSocketTransport::ResolveHost [this=%x]\n", this));
    1: 
    1:     nsresult rv;
    1: 
    1:     if (!mProxyHost.IsEmpty()) {
    1:         if (!mProxyTransparent || mProxyTransparentResolvesHost) {
    1:             // When not resolving mHost locally, we still want to ensure that
    1:             // it only contains valid characters.  See bug 304904 for details.
    1:             if (!net_IsValidHostName(mHost))
    1:                 return NS_ERROR_UNKNOWN_HOST;
    1:         }
    1:         if (mProxyTransparentResolvesHost) {
    1:             // Name resolution is done on the server side.  Just pretend
    1:             // client resolution is complete, this will get picked up later.
    1:             // since we don't need to do DNS now, we bypass the resolving
    1:             // step by initializing mNetAddr to an empty address, but we
    1:             // must keep the port. The SOCKS IO layer will use the hostname
    1:             // we send it when it's created, rather than the empty address
    1:             // we send with the connect call.
    1:             mState = STATE_RESOLVING;
    1:             PR_SetNetAddr(PR_IpAddrAny, PR_AF_INET, SocketPort(), &mNetAddr);
    1:             return PostEvent(MSG_DNS_LOOKUP_COMPLETE, NS_OK, nsnull);
    1:         }
    1:     }
    1: 
    1:     nsCOMPtr<nsIDNSService> dns = do_GetService(kDNSServiceCID, &rv);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
80486:     mResolving = true;
    1: 
21294:     PRUint32 dnsFlags = 0;
21294:     if (mConnectionFlags & nsSocketTransport::BYPASS_CACHE)
21294:         dnsFlags = nsIDNSService::RESOLVE_BYPASS_CACHE;
72963:     if (mConnectionFlags & nsSocketTransport::DISABLE_IPV6)
72963:         dnsFlags |= nsIDNSService::RESOLVE_DISABLE_IPV6;
21294: 
70188:     SendStatus(STATUS_RESOLVING);
21294:     rv = dns->AsyncResolve(SocketHost(), dnsFlags, this, nsnull,
    1:                            getter_AddRefs(mDNSRequest));
    1:     if (NS_SUCCEEDED(rv)) {
56649:         SOCKET_LOG(("  advancing to STATE_RESOLVING\n"));
    1:         mState = STATE_RESOLVING;
    1:     }
    1:     return rv;
    1: }
    1: 
    1: nsresult
79445: nsSocketTransport::BuildSocket(PRFileDesc *&fd, bool &proxyTransparent, bool &usingSSL)
    1: {
56649:     SOCKET_LOG(("nsSocketTransport::BuildSocket [this=%x]\n", this));
    1: 
    1:     nsresult rv;
    1: 
80486:     proxyTransparent = false;
80486:     usingSSL = false;
    1: 
    1:     if (mTypeCount == 0) {
    1:         fd = PR_OpenTCPSocket(mNetAddr.raw.family);
    1:         rv = fd ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:     else {
    1:         fd = nsnull;
    1: 
    1:         nsCOMPtr<nsISocketProviderService> spserv =
    1:             do_GetService(kSocketProviderServiceCID, &rv);
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         const char *host       = mHost.get();
    1:         PRInt32     port       = (PRInt32) mPort;
    1:         const char *proxyHost  = mProxyHost.IsEmpty() ? nsnull : mProxyHost.get();
    1:         PRInt32     proxyPort  = (PRInt32) mProxyPort;
    1:         PRUint32    proxyFlags = 0;
    1: 
    1:         PRUint32 i;
    1:         for (i=0; i<mTypeCount; ++i) {
    1:             nsCOMPtr<nsISocketProvider> provider;
    1: 
56649:             SOCKET_LOG(("  pushing io layer [%u:%s]\n", i, mTypes[i]));
    1: 
    1:             rv = spserv->GetSocketProvider(mTypes[i], getter_AddRefs(provider));
    1:             if (NS_FAILED(rv))
    1:                 break;
    1: 
    1:             if (mProxyTransparentResolvesHost)
    1:                 proxyFlags |= nsISocketProvider::PROXY_RESOLVES_HOST;
    1:             
25076:             if (mConnectionFlags & nsISocketTransport::ANONYMOUS_CONNECT)
25076:                 proxyFlags |= nsISocketProvider::ANONYMOUS_CONNECT;
25076: 
    1:             nsCOMPtr<nsISupports> secinfo;
    1:             if (i == 0) {
    1:                 // if this is the first type, we'll want the 
    1:                 // service to allocate a new socket
    1:                 rv = provider->NewSocket(mNetAddr.raw.family,
    1:                                          host, port, proxyHost, proxyPort,
    1:                                          proxyFlags, &fd,
    1:                                          getter_AddRefs(secinfo));
    1: 
    1:                 if (NS_SUCCEEDED(rv) && !fd) {
    1:                     NS_NOTREACHED("NewSocket succeeded but failed to create a PRFileDesc");
    1:                     rv = NS_ERROR_UNEXPECTED;
    1:                 }
    1:             }
    1:             else {
    1:                 // the socket has already been allocated, 
    1:                 // so we just want the service to add itself
    1:                 // to the stack (such as pushing an io layer)
    1:                 rv = provider->AddToSocket(mNetAddr.raw.family,
    1:                                            host, port, proxyHost, proxyPort,
    1:                                            proxyFlags, fd,
    1:                                            getter_AddRefs(secinfo));
    1:             }
25076:             // proxyFlags = 0; not used below this point...
    1:             if (NS_FAILED(rv))
    1:                 break;
    1: 
    1:             // if the service was ssl or starttls, we want to hold onto the socket info
79445:             bool isSSL = (strcmp(mTypes[i], "ssl") == 0);
    1:             if (isSSL || (strcmp(mTypes[i], "starttls") == 0)) {
    1:                 // remember security info and give notification callbacks to PSM...
    1:                 nsCOMPtr<nsIInterfaceRequestor> callbacks;
    1:                 {
64576:                     MutexAutoLock lock(mLock);
    1:                     mSecInfo = secinfo;
    1:                     callbacks = mCallbacks;
56649:                     SOCKET_LOG(("  [secinfo=%x callbacks=%x]\n", mSecInfo.get(), mCallbacks.get()));
    1:                 }
    1:                 // don't call into PSM while holding mLock!!
    1:                 nsCOMPtr<nsISSLSocketControl> secCtrl(do_QueryInterface(secinfo));
    1:                 if (secCtrl)
    1:                     secCtrl->SetNotificationCallbacks(callbacks);
    1:                 // remember if socket type is SSL so we can ProxyStartSSL if need be.
    1:                 usingSSL = isSSL;
    1:             }
    1:             else if ((strcmp(mTypes[i], "socks") == 0) ||
    1:                      (strcmp(mTypes[i], "socks4") == 0)) {
    1:                 // since socks is transparent, any layers above
    1:                 // it do not have to worry about proxy stuff
    1:                 proxyHost = nsnull;
    1:                 proxyPort = -1;
80486:                 proxyTransparent = true;
    1:             }
    1:         }
    1: 
    1:         if (NS_FAILED(rv)) {
56649:             SOCKET_LOG(("  error pushing io layer [%u:%s rv=%x]\n", i, mTypes[i], rv));
    1:             if (fd)
    1:                 PR_Close(fd);
    1:         }
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsSocketTransport::InitiateSocket()
    1: {
56649:     SOCKET_LOG(("nsSocketTransport::InitiateSocket [this=%x]\n", this));
    1: 
    1:     nsresult rv;
    1: 
    1:     //
    1:     // find out if it is going to be ok to attach another socket to the STS.
    1:     // if not then we have to wait for the STS to tell us that it is ok.
    1:     // the notification is asynchronous, which means that when we could be
    1:     // in a race to call AttachSocket once notified.  for this reason, when
    1:     // we get notified, we just re-enter this function.  as a result, we are
    1:     // sure to ask again before calling AttachSocket.  in this way we deal
    1:     // with the race condition.  though it isn't the most elegant solution,
    1:     // it is far simpler than trying to build a system that would guarantee
    1:     // FIFO ordering (which wouldn't even be that valuable IMO).  see bug
    1:     // 194402 for more info.
    1:     //
    1:     if (!gSocketTransportService->CanAttachSocket()) {
    1:         nsCOMPtr<nsIRunnable> event =
    1:                 new nsSocketEvent(this, MSG_RETRY_INIT_SOCKET);
    1:         if (!event)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:         return gSocketTransportService->NotifyWhenCanAttachSocket(event);
    1:     }
    1: 
    1:     //
    1:     // if we already have a connected socket, then just attach and return.
    1:     //
    1:     if (mFD) {
    1:         rv = gSocketTransportService->AttachSocket(mFD, this);
    1:         if (NS_SUCCEEDED(rv))
80486:             mAttached = true;
    1:         return rv;
    1:     }
    1: 
    1:     //
    1:     // create new socket fd, push io layers, etc.
    1:     //
    1:     PRFileDesc *fd;
79445:     bool proxyTransparent;
79445:     bool usingSSL;
    1: 
    1:     rv = BuildSocket(fd, proxyTransparent, usingSSL);
    1:     if (NS_FAILED(rv)) {
56649:         SOCKET_LOG(("  BuildSocket failed [rv=%x]\n", rv));
    1:         return rv;
    1:     }
    1: 
    1:     PRStatus status;
    1: 
    1:     // Make the socket non-blocking...
    1:     PRSocketOptionData opt;
    1:     opt.option = PR_SockOpt_Nonblocking;
80486:     opt.value.non_blocking = true;
    1:     status = PR_SetSocketOption(fd, &opt);
    1:     NS_ASSERTION(status == PR_SUCCESS, "unable to make socket non-blocking");
    1: 
67710:     // disable the nagle algorithm - if we rely on it to coalesce writes into
67710:     // full packets the final packet of a multi segment POST/PUT or pipeline
67710:     // sequence is delayed a full rtt
67710:     opt.option = PR_SockOpt_NoDelay;
80486:     opt.value.no_delay = true;
67710:     PR_SetSocketOption(fd, &opt);
67710: 
24785:     // if the network.tcp.sendbuffer preference is set, use it to size SO_SNDBUF
24785:     // The Windows default of 8KB is too small and as of vista sp1, autotuning
24785:     // only applies to receive window
24785:     PRInt32 sndBufferSize;
24785:     gSocketTransportService->GetSendBufferSize(&sndBufferSize);
24785:     if (sndBufferSize > 0) {
24785:         opt.option = PR_SockOpt_SendBufferSize;
24785:         opt.value.send_buffer_size = sndBufferSize;
24785:         PR_SetSocketOption(fd, &opt);
24785:     }
24785: 
43040:     if (mQoSBits) {
43040:         opt.option = PR_SockOpt_IpTypeOfService;
43040:         opt.value.tos = mQoSBits;
43040:         PR_SetSocketOption(fd, &opt);
43040:     }
43040: 
    1:     // inform socket transport about this newly created socket...
    1:     rv = gSocketTransportService->AttachSocket(fd, this);
    1:     if (NS_FAILED(rv)) {
    1:         PR_Close(fd);
    1:         return rv;
    1:     }
80486:     mAttached = true;
    1: 
    1:     // assign mFD so that we can properly handle OnSocketDetached before we've
    1:     // established a connection.
    1:     {
64576:         MutexAutoLock lock(mLock);
    1:         mFD = fd;
    1:         mFDref = 1;
80486:         mFDconnected = false;
    1:     }
    1: 
56649:     SOCKET_LOG(("  advancing to STATE_CONNECTING\n"));
    1:     mState = STATE_CONNECTING;
    1:     mPollTimeout = mTimeouts[TIMEOUT_CONNECT];
    1:     SendStatus(STATUS_CONNECTING_TO);
    1: 
    1: #if defined(PR_LOGGING)
56649:     if (SOCKET_LOG_ENABLED()) {
    1:         char buf[64];
    1:         PR_NetAddrToString(&mNetAddr, buf, sizeof(buf));
56649:         SOCKET_LOG(("  trying address: %s\n", buf));
    1:     }
    1: #endif
    1: 
    1:     // 
    1:     // Initiate the connect() to the host...  
    1:     //
    1:     status = PR_Connect(fd, &mNetAddr, NS_SOCKET_CONNECT_TIMEOUT);
    1:     if (status == PR_SUCCESS) {
    1:         // 
    1:         // we are connected!
    1:         //
    1:         OnSocketConnected();
    1:     }
    1:     else {
    1:         PRErrorCode code = PR_GetError();
    1: #if defined(TEST_CONNECT_ERRORS)
    1:         code = RandomizeConnectError(code);
    1: #endif
    1:         //
    1:         // If the PR_Connect(...) would block, then poll for a connection.
    1:         //
    1:         if ((PR_WOULD_BLOCK_ERROR == code) || (PR_IN_PROGRESS_ERROR == code))
    1:             mPollFlags = (PR_POLL_EXCEPT | PR_POLL_WRITE);
    1:         //
    1:         // If the socket is already connected, then return success...
    1:         //
    1:         else if (PR_IS_CONNECTED_ERROR == code) {
    1:             //
    1:             // we are connected!
    1:             //
    1:             OnSocketConnected();
    1: 
    1:             if (mSecInfo && !mProxyHost.IsEmpty() && proxyTransparent && usingSSL) {
    1:                 // if the connection phase is finished, and the ssl layer has
    1:                 // been pushed, and we were proxying (transparently; ie. nothing
    1:                 // has to happen in the protocol layer above us), it's time for
    1:                 // the ssl to start doing it's thing.
    1:                 nsCOMPtr<nsISSLSocketControl> secCtrl =
    1:                     do_QueryInterface(mSecInfo);
    1:                 if (secCtrl) {
56649:                     SOCKET_LOG(("  calling ProxyStartSSL()\n"));
    1:                     secCtrl->ProxyStartSSL();
    1:                 }
    1:                 // XXX what if we were forced to poll on the socket for a successful
    1:                 // connection... wouldn't we need to call ProxyStartSSL after a call
    1:                 // to PR_ConnectContinue indicates that we are connected?
    1:                 //
    1:                 // XXX this appears to be what the old socket transport did.  why
    1:                 // isn't this broken?
    1:             }
    1:         }
    1:         //
64493:         // A SOCKS request was rejected; get the actual error code from
64493:         // the OS error
64493:         //
64493:         else if (PR_UNKNOWN_ERROR == code &&
64493:                  mProxyTransparent &&
64493:                  !mProxyHost.IsEmpty()) {
64493:             code = PR_GetOSError();
64493:             rv = ErrorAccordingToNSPR(code);
64493:         }
64493:         //
    1:         // The connection was refused...
    1:         //
    1:         else {
    1:             rv = ErrorAccordingToNSPR(code);
    1:             if ((rv == NS_ERROR_CONNECTION_REFUSED) && !mProxyHost.IsEmpty())
    1:                 rv = NS_ERROR_PROXY_CONNECTION_REFUSED;
    1:         }
    1:     }
    1:     return rv;
    1: }
    1: 
79445: bool
    1: nsSocketTransport::RecoverFromError()
    1: {
    1:     NS_ASSERTION(NS_FAILED(mCondition), "there should be something wrong");
    1: 
56649:     SOCKET_LOG(("nsSocketTransport::RecoverFromError [this=%x state=%x cond=%x]\n",
    1:         this, mState, mCondition));
    1: 
    1:     // can only recover from errors in these states
    1:     if (mState != STATE_RESOLVING && mState != STATE_CONNECTING)
80486:         return false;
    1: 
81272:     nsresult rv;
81272: 
    1:     // OK to check this outside mLock
    1:     NS_ASSERTION(!mFDconnected, "socket should not be connected");
    1: 
    1:     // can only recover from these errors
    1:     if (mCondition != NS_ERROR_CONNECTION_REFUSED &&
    1:         mCondition != NS_ERROR_PROXY_CONNECTION_REFUSED &&
    1:         mCondition != NS_ERROR_NET_TIMEOUT &&
    1:         mCondition != NS_ERROR_UNKNOWN_HOST &&
    1:         mCondition != NS_ERROR_UNKNOWN_PROXY_HOST)
80486:         return false;
    1: 
79445:     bool tryAgain = false;
    1: 
81272:     if (mConnectionFlags & DISABLE_IPV6 &&
81272:         mCondition == NS_ERROR_UNKNOWN_HOST &&
81272:         mState == STATE_RESOLVING &&
81272:         !mProxyTransparentResolvesHost) {
81272:         SOCKET_LOG(("  trying lookup again with both ipv4/ipv6 enabled\n"));
81272:         mConnectionFlags &= ~DISABLE_IPV6;
81272:         tryAgain = true;
81272:     }
81272: 
    1:     // try next ip address only if past the resolver stage...
    1:     if (mState == STATE_CONNECTING && mDNSRecord) {
74203:         mDNSRecord->ReportUnusable(SocketPort());
74203:         
    1:         nsresult rv = mDNSRecord->GetNextAddr(SocketPort(), &mNetAddr);
    1:         if (NS_SUCCEEDED(rv)) {
56649:             SOCKET_LOG(("  trying again with next ip address\n"));
80486:             tryAgain = true;
    1:         }
81272:         else if (mConnectionFlags & DISABLE_IPV6) {
81272:             // Drop state to closed.  This will trigger new round of DNS
81272:             // resolving bellow.
81272:             // XXX Here should idealy be set now non-existing flag DISABLE_IPV4
81272:             SOCKET_LOG(("  failed to connect all ipv4 hosts,"
81272:                         " trying lookup/connect again with both ipv4/ipv6\n"));
81272:             mState = STATE_CLOSED;
81272:             mConnectionFlags &= ~DISABLE_IPV6;
81272:             tryAgain = true;
81272:         }
    1:     }
    1: 
51789: #if defined(XP_WIN) || defined(MOZ_PLATFORM_MAEMO)
    1:     // If not trying next address, try to make a connection using dialup. 
    1:     // Retry if that connection is made.
    1:     if (!tryAgain) {
79445:         bool autodialEnabled;
    1:         gSocketTransportService->GetAutodialEnabled(&autodialEnabled);
18476:         if (autodialEnabled) {
18476:           tryAgain = nsNativeConnectionHelper::OnConnectionFailed(
18476:                        NS_ConvertUTF8toUTF16(SocketHost()).get());
18476: 	    }
    1:     }
    1: #endif
    1: 
    1:     // prepare to try again.
    1:     if (tryAgain) {
    1:         PRUint32 msg;
    1: 
    1:         if (mState == STATE_CONNECTING) {
    1:             mState = STATE_RESOLVING;
    1:             msg = MSG_DNS_LOOKUP_COMPLETE;
    1:         }
    1:         else {
    1:             mState = STATE_CLOSED;
    1:             msg = MSG_ENSURE_CONNECT;
    1:         }
    1: 
    1:         rv = PostEvent(msg, NS_OK);
    1:         if (NS_FAILED(rv))
80486:             tryAgain = false;
    1:     }
    1: 
    1:     return tryAgain;
    1: }
    1: 
    1: // called on the socket thread only
    1: void
    1: nsSocketTransport::OnMsgInputClosed(nsresult reason)
    1: {
56649:     SOCKET_LOG(("nsSocketTransport::OnMsgInputClosed [this=%x reason=%x]\n",
    1:         this, reason));
    1: 
    1:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
    1: 
80486:     mInputClosed = true;
    1:     // check if event should affect entire transport
    1:     if (NS_FAILED(reason) && (reason != NS_BASE_STREAM_CLOSED))
    1:         mCondition = reason;                // XXX except if NS_FAILED(mCondition), right??
    1:     else if (mOutputClosed)
    1:         mCondition = NS_BASE_STREAM_CLOSED; // XXX except if NS_FAILED(mCondition), right??
    1:     else {
    1:         if (mState == STATE_TRANSFERRING)
    1:             mPollFlags &= ~PR_POLL_READ;
    1:         mInput.OnSocketReady(reason);
    1:     }
    1: }
    1: 
    1: // called on the socket thread only
    1: void
    1: nsSocketTransport::OnMsgOutputClosed(nsresult reason)
    1: {
56649:     SOCKET_LOG(("nsSocketTransport::OnMsgOutputClosed [this=%x reason=%x]\n",
    1:         this, reason));
    1: 
    1:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
    1: 
80486:     mOutputClosed = true;
    1:     // check if event should affect entire transport
    1:     if (NS_FAILED(reason) && (reason != NS_BASE_STREAM_CLOSED))
    1:         mCondition = reason;                // XXX except if NS_FAILED(mCondition), right??
    1:     else if (mInputClosed)
    1:         mCondition = NS_BASE_STREAM_CLOSED; // XXX except if NS_FAILED(mCondition), right??
    1:     else {
    1:         if (mState == STATE_TRANSFERRING)
    1:             mPollFlags &= ~PR_POLL_WRITE;
    1:         mOutput.OnSocketReady(reason);
    1:     }
    1: }
    1: 
    1: void
    1: nsSocketTransport::OnSocketConnected()
    1: {
56649:     SOCKET_LOG(("  advancing to STATE_TRANSFERRING\n"));
    1: 
    1:     mPollFlags = (PR_POLL_READ | PR_POLL_WRITE | PR_POLL_EXCEPT);
    1:     mPollTimeout = mTimeouts[TIMEOUT_READ_WRITE];
    1:     mState = STATE_TRANSFERRING;
    1: 
    1:     // assign mFD (must do this within the transport lock), but take care not
    1:     // to trample over mFDref if mFD is already set.
    1:     {
64576:         MutexAutoLock lock(mLock);
    1:         NS_ASSERTION(mFD, "no socket");
    1:         NS_ASSERTION(mFDref == 1, "wrong socket ref count");
80486:         mFDconnected = true;
    1:     }
13323: 
13323:     SendStatus(STATUS_CONNECTED_TO);
    1: }
    1: 
    1: PRFileDesc *
    1: nsSocketTransport::GetFD_Locked()
    1: {
    1:     // mFD is not available to the streams while disconnected.
    1:     if (!mFDconnected)
    1:         return nsnull;
    1: 
    1:     if (mFD)
    1:         mFDref++;
    1: 
    1:     return mFD;
    1: }
    1: 
    1: void
    1: nsSocketTransport::ReleaseFD_Locked(PRFileDesc *fd)
    1: {
    1:     NS_ASSERTION(mFD == fd, "wrong fd");
    1: 
    1:     if (--mFDref == 0) {
56649:         SOCKET_LOG(("nsSocketTransport: calling PR_Close [this=%x]\n", this));
    1:         PR_Close(mFD);
    1:         mFD = nsnull;
    1:     }
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // socket event handler impl
    1: 
    1: void
    1: nsSocketTransport::OnSocketEvent(PRUint32 type, nsresult status, nsISupports *param)
    1: {
56649:     SOCKET_LOG(("nsSocketTransport::OnSocketEvent [this=%p type=%u status=%x param=%p]\n",
    1:         this, type, status, param));
    1: 
    1:     if (NS_FAILED(mCondition)) {
    1:         // block event since we're apparently already dead.
56649:         SOCKET_LOG(("  blocking event [condition=%x]\n", mCondition));
    1:         //
    1:         // notify input/output streams in case either has a pending notify.
    1:         //
    1:         mInput.OnSocketReady(mCondition);
    1:         mOutput.OnSocketReady(mCondition);
    1:         return;
    1:     }
    1: 
    1:     switch (type) {
    1:     case MSG_ENSURE_CONNECT:
56649:         SOCKET_LOG(("  MSG_ENSURE_CONNECT\n"));
    1:         //
    1:         // ensure that we have created a socket, attached it, and have a
    1:         // connection.
    1:         //
    1:         if (mState == STATE_CLOSED)
    1:             mCondition = ResolveHost();
    1:         else
56649:             SOCKET_LOG(("  ignoring redundant event\n"));
    1:         break;
    1: 
    1:     case MSG_DNS_LOOKUP_COMPLETE:
70188:         if (mDNSRequest)  // only send this if we actually resolved anything
70188:             SendStatus(STATUS_RESOLVED);
70188: 
56649:         SOCKET_LOG(("  MSG_DNS_LOOKUP_COMPLETE\n"));
    1:         mDNSRequest = 0;
    1:         if (param) {
 3233:             mDNSRecord = static_cast<nsIDNSRecord *>(param);
    1:             mDNSRecord->GetNextAddr(SocketPort(), &mNetAddr);
    1:         }
    1:         // status contains DNS lookup status
    1:         if (NS_FAILED(status)) {
    1:             // When using a HTTP proxy, NS_ERROR_UNKNOWN_HOST means the HTTP 
    1:             // proxy host is not found, so we fixup the error code.
    1:             // For SOCKS proxies (mProxyTransparent == true), the socket 
    1:             // transport resolves the real host here, so there's no fixup 
    1:             // (see bug 226943).
    1:             if ((status == NS_ERROR_UNKNOWN_HOST) && !mProxyTransparent &&
    1:                 !mProxyHost.IsEmpty())
    1:                 mCondition = NS_ERROR_UNKNOWN_PROXY_HOST;
    1:             else
    1:                 mCondition = status;
    1:         }
    1:         else if (mState == STATE_RESOLVING)
    1:             mCondition = InitiateSocket();
    1:         break;
    1: 
    1:     case MSG_RETRY_INIT_SOCKET:
    1:         mCondition = InitiateSocket();
    1:         break;
    1: 
    1:     case MSG_INPUT_CLOSED:
56649:         SOCKET_LOG(("  MSG_INPUT_CLOSED\n"));
    1:         OnMsgInputClosed(status);
    1:         break;
    1: 
    1:     case MSG_INPUT_PENDING:
56649:         SOCKET_LOG(("  MSG_INPUT_PENDING\n"));
    1:         OnMsgInputPending();
    1:         break;
    1: 
    1:     case MSG_OUTPUT_CLOSED:
56649:         SOCKET_LOG(("  MSG_OUTPUT_CLOSED\n"));
    1:         OnMsgOutputClosed(status);
    1:         break;
    1: 
    1:     case MSG_OUTPUT_PENDING:
56649:         SOCKET_LOG(("  MSG_OUTPUT_PENDING\n"));
    1:         OnMsgOutputPending();
    1:         break;
    1:     case MSG_TIMEOUT_CHANGED:
56649:         SOCKET_LOG(("  MSG_TIMEOUT_CHANGED\n"));
    1:         mPollTimeout = mTimeouts[(mState == STATE_TRANSFERRING)
    1:           ? TIMEOUT_READ_WRITE : TIMEOUT_CONNECT];
    1:         break;
    1:     default:
56649:         SOCKET_LOG(("  unhandled event!\n"));
    1:     }
    1:     
    1:     if (NS_FAILED(mCondition)) {
56649:         SOCKET_LOG(("  after event [this=%x cond=%x]\n", this, mCondition));
    1:         if (!mAttached) // need to process this error ourselves...
    1:             OnSocketDetached(nsnull);
    1:     }
    1:     else if (mPollFlags == PR_POLL_EXCEPT)
    1:         mPollFlags = 0; // make idle
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // socket handler impl
    1: 
    1: void
    1: nsSocketTransport::OnSocketReady(PRFileDesc *fd, PRInt16 outFlags)
    1: {
56649:     SOCKET_LOG(("nsSocketTransport::OnSocketReady [this=%x outFlags=%hd]\n",
    1:         this, outFlags));
    1: 
    1:     if (outFlags == -1) {
56649:         SOCKET_LOG(("socket timeout expired\n"));
    1:         mCondition = NS_ERROR_NET_TIMEOUT;
    1:         return;
    1:     }
    1: 
    1:     if (mState == STATE_TRANSFERRING) {
    1:         // if waiting to write and socket is writable or hit an exception.
    1:         if ((mPollFlags & PR_POLL_WRITE) && (outFlags & ~PR_POLL_READ)) {
    1:             // assume that we won't need to poll any longer (the stream will
    1:             // request that we poll again if it is still pending).
    1:             mPollFlags &= ~PR_POLL_WRITE;
    1:             mOutput.OnSocketReady(NS_OK);
    1:         }
    1:         // if waiting to read and socket is readable or hit an exception.
    1:         if ((mPollFlags & PR_POLL_READ) && (outFlags & ~PR_POLL_WRITE)) {
    1:             // assume that we won't need to poll any longer (the stream will
    1:             // request that we poll again if it is still pending).
    1:             mPollFlags &= ~PR_POLL_READ;
    1:             mInput.OnSocketReady(NS_OK);
    1:         }
    1:         // Update poll timeout in case it was changed
    1:         mPollTimeout = mTimeouts[TIMEOUT_READ_WRITE];
    1:     }
    1:     else if (mState == STATE_CONNECTING) {
    1:         PRStatus status = PR_ConnectContinue(fd, outFlags);
    1:         if (status == PR_SUCCESS) {
    1:             //
    1:             // we are connected!
    1:             //
    1:             OnSocketConnected();
    1:         }
    1:         else {
    1:             PRErrorCode code = PR_GetError();
    1: #if defined(TEST_CONNECT_ERRORS)
    1:             code = RandomizeConnectError(code);
    1: #endif
    1:             //
    1:             // If the connect is still not ready, then continue polling...
    1:             //
    1:             if ((PR_WOULD_BLOCK_ERROR == code) || (PR_IN_PROGRESS_ERROR == code)) {
    1:                 // Set up the select flags for connect...
    1:                 mPollFlags = (PR_POLL_EXCEPT | PR_POLL_WRITE);
    1:                 // Update poll timeout in case it was changed
    1:                 mPollTimeout = mTimeouts[TIMEOUT_CONNECT];
    1:             }
64493:             //
64493:             // The SOCKS proxy rejected our request. Find out why.
64493:             //
64493:             else if (PR_UNKNOWN_ERROR == code &&
64493:                      mProxyTransparent &&
64493:                      !mProxyHost.IsEmpty()) {
64493:                 code = PR_GetOSError();
64493:                 mCondition = ErrorAccordingToNSPR(code);
64493:             }
    1:             else {
    1:                 //
    1:                 // else, the connection failed...
    1:                 //
    1:                 mCondition = ErrorAccordingToNSPR(code);
    1:                 if ((mCondition == NS_ERROR_CONNECTION_REFUSED) && !mProxyHost.IsEmpty())
    1:                     mCondition = NS_ERROR_PROXY_CONNECTION_REFUSED;
56649:                 SOCKET_LOG(("  connection failed! [reason=%x]\n", mCondition));
    1:             }
    1:         }
    1:     }
    1:     else {
    1:         NS_ERROR("unexpected socket state");
    1:         mCondition = NS_ERROR_UNEXPECTED;
    1:     }
    1: 
    1:     if (mPollFlags == PR_POLL_EXCEPT)
    1:         mPollFlags = 0; // make idle
    1: }
    1: 
    1: // called on the socket thread only
    1: void
    1: nsSocketTransport::OnSocketDetached(PRFileDesc *fd)
    1: {
56649:     SOCKET_LOG(("nsSocketTransport::OnSocketDetached [this=%x cond=%x]\n",
    1:         this, mCondition));
    1: 
    1:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
    1: 
    1:     // if we didn't initiate this detach, then be sure to pass an error
    1:     // condition up to our consumers.  (e.g., STS is shutting down.)
    1:     if (NS_SUCCEEDED(mCondition))
    1:         mCondition = NS_ERROR_ABORT;
    1: 
    1:     if (RecoverFromError())
    1:         mCondition = NS_OK;
    1:     else {
    1:         mState = STATE_CLOSED;
    1: 
    1:         // make sure there isn't any pending DNS request
    1:         if (mDNSRequest) {
    1:             mDNSRequest->Cancel(NS_ERROR_ABORT);
    1:             mDNSRequest = 0;
    1:         }
    1: 
    1:         //
    1:         // notify input/output streams
    1:         //
    1:         mInput.OnSocketReady(mCondition);
    1:         mOutput.OnSocketReady(mCondition);
    1:     }
    1: 
    1:     // break any potential reference cycle between the security info object
    1:     // and ourselves by resetting its notification callbacks object.  see
    1:     // bug 285991 for details.
    1:     nsCOMPtr<nsISSLSocketControl> secCtrl = do_QueryInterface(mSecInfo);
    1:     if (secCtrl)
    1:         secCtrl->SetNotificationCallbacks(nsnull);
    1: 
    1:     // finally, release our reference to the socket (must do this within
11714:     // the transport lock) possibly closing the socket. Also release our
11714:     // listeners to break potential refcount cycles.
58513: 
58542:     // We should be careful not to release mEventSink and mCallbacks while
58542:     // we're locked, because releasing it might require acquiring the lock
58542:     // again, so we just null out mEventSink and mCallbacks while we're
58542:     // holding the lock, and let the stack based objects' destuctors take
58542:     // care of destroying it if needed.
58542:     nsCOMPtr<nsIInterfaceRequestor> ourCallbacks;
58513:     nsCOMPtr<nsITransportEventSink> ourEventSink;
    1:     {
64576:         MutexAutoLock lock(mLock);
    1:         if (mFD) {
    1:             ReleaseFD_Locked(mFD);
    1:             // flag mFD as unusable; this prevents other consumers from 
    1:             // acquiring a reference to mFD.
80486:             mFDconnected = false;
    1:         }
20263: 
20263:         // We must release mCallbacks and mEventSink to avoid memory leak
20263:         // but only when RecoverFromError() above failed. Otherwise we lose
20263:         // link with UI and security callbacks on next connection attempt 
20263:         // round. That would lead e.g. to a broken certificate exception page.
20263:         if (NS_FAILED(mCondition)) {
58542:             mCallbacks.swap(ourCallbacks);
58513:             mEventSink.swap(ourEventSink);
    1:         }
    1:     }
20263: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // xpcom api
    1: 
12033: NS_IMPL_THREADSAFE_ISUPPORTS4(nsSocketTransport,
12033:                               nsISocketTransport,
12033:                               nsITransport,
12033:                               nsIDNSListener,
12033:                               nsIClassInfo)
12033: NS_IMPL_CI_INTERFACE_GETTER3(nsSocketTransport,
12033:                              nsISocketTransport,
12033:                              nsITransport,
12033:                              nsIDNSListener)
12033: 
    1: NS_IMETHODIMP
    1: nsSocketTransport::OpenInputStream(PRUint32 flags,
    1:                                    PRUint32 segsize,
    1:                                    PRUint32 segcount,
    1:                                    nsIInputStream **result)
    1: {
56649:     SOCKET_LOG(("nsSocketTransport::OpenInputStream [this=%x flags=%x]\n",
    1:         this, flags));
    1: 
    1:     NS_ENSURE_TRUE(!mInput.IsReferenced(), NS_ERROR_UNEXPECTED);
    1: 
    1:     nsresult rv;
    1:     nsCOMPtr<nsIAsyncInputStream> pipeIn;
    1: 
    1:     if (!(flags & OPEN_UNBUFFERED) || (flags & OPEN_BLOCKING)) {
    1:         // XXX if the caller wants blocking, then the caller also gets buffered!
79445:         //bool openBuffered = !(flags & OPEN_UNBUFFERED);
79445:         bool openBlocking =  (flags & OPEN_BLOCKING);
    1: 
    1:         net_ResolveSegmentParams(segsize, segcount);
    1:         nsIMemory *segalloc = net_GetSegmentAlloc(segsize);
    1: 
    1:         // create a pipe
    1:         nsCOMPtr<nsIAsyncOutputStream> pipeOut;
    1:         rv = NS_NewPipe2(getter_AddRefs(pipeIn), getter_AddRefs(pipeOut),
80486:                          !openBlocking, true, segsize, segcount, segalloc);
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         // async copy from socket to pipe
    1:         rv = NS_AsyncCopy(&mInput, pipeOut, gSocketTransportService,
    1:                           NS_ASYNCCOPY_VIA_WRITESEGMENTS, segsize);
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         *result = pipeIn;
    1:     }
    1:     else
    1:         *result = &mInput;
    1: 
    1:     // flag input stream as open
80486:     mInputClosed = false;
    1: 
    1:     rv = PostEvent(MSG_ENSURE_CONNECT);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     NS_ADDREF(*result);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketTransport::OpenOutputStream(PRUint32 flags,
    1:                                     PRUint32 segsize,
    1:                                     PRUint32 segcount,
    1:                                     nsIOutputStream **result)
    1: {
56649:     SOCKET_LOG(("nsSocketTransport::OpenOutputStream [this=%x flags=%x]\n",
    1:         this, flags));
    1: 
    1:     NS_ENSURE_TRUE(!mOutput.IsReferenced(), NS_ERROR_UNEXPECTED);
    1: 
    1:     nsresult rv;
    1:     nsCOMPtr<nsIAsyncOutputStream> pipeOut;
    1:     if (!(flags & OPEN_UNBUFFERED) || (flags & OPEN_BLOCKING)) {
    1:         // XXX if the caller wants blocking, then the caller also gets buffered!
79445:         //bool openBuffered = !(flags & OPEN_UNBUFFERED);
79445:         bool openBlocking =  (flags & OPEN_BLOCKING);
    1: 
    1:         net_ResolveSegmentParams(segsize, segcount);
    1:         nsIMemory *segalloc = net_GetSegmentAlloc(segsize);
    1: 
    1:         // create a pipe
    1:         nsCOMPtr<nsIAsyncInputStream> pipeIn;
    1:         rv = NS_NewPipe2(getter_AddRefs(pipeIn), getter_AddRefs(pipeOut),
80486:                          true, !openBlocking, segsize, segcount, segalloc);
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         // async copy from socket to pipe
    1:         rv = NS_AsyncCopy(pipeIn, &mOutput, gSocketTransportService,
    1:                           NS_ASYNCCOPY_VIA_READSEGMENTS, segsize);
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         *result = pipeOut;
    1:     }
    1:     else
    1:         *result = &mOutput;
    1: 
    1:     // flag output stream as open
80486:     mOutputClosed = false;
    1: 
    1:     rv = PostEvent(MSG_ENSURE_CONNECT);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     NS_ADDREF(*result);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketTransport::Close(nsresult reason)
    1: {
    1:     if (NS_SUCCEEDED(reason))
    1:         reason = NS_BASE_STREAM_CLOSED;
    1: 
    1:     mInput.CloseWithStatus(reason);
    1:     mOutput.CloseWithStatus(reason);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketTransport::GetSecurityInfo(nsISupports **secinfo)
    1: {
64576:     MutexAutoLock lock(mLock);
    1:     NS_IF_ADDREF(*secinfo = mSecInfo);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketTransport::GetSecurityCallbacks(nsIInterfaceRequestor **callbacks)
    1: {
64576:     MutexAutoLock lock(mLock);
    1:     NS_IF_ADDREF(*callbacks = mCallbacks);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketTransport::SetSecurityCallbacks(nsIInterfaceRequestor *callbacks)
    1: {
64613:     nsCOMPtr<nsISupports> secinfo;
64613:     {
64576:         MutexAutoLock lock(mLock);
    1:         mCallbacks = callbacks;
64613:         SOCKET_LOG(("Reset callbacks for secinfo=%p callbacks=%p\n",
64613:                     mSecInfo.get(), mCallbacks.get()));
64613: 
64613:         secinfo = mSecInfo;
64613:     }
64613: 
64613:     // don't call into PSM while holding mLock!!
64613:     nsCOMPtr<nsISSLSocketControl> secCtrl(do_QueryInterface(secinfo));
64613:     if (secCtrl)
64613:         secCtrl->SetNotificationCallbacks(callbacks);
64613: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketTransport::SetEventSink(nsITransportEventSink *sink,
    1:                                 nsIEventTarget *target)
    1: {
    1:     nsCOMPtr<nsITransportEventSink> temp;
    1:     if (target) {
    1:         nsresult rv = net_NewTransportEventSinkProxy(getter_AddRefs(temp),
    1:                                                      sink, target);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:         sink = temp.get();
    1:     }
    1: 
64576:     MutexAutoLock lock(mLock);
    1:     mEventSink = sink;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsSocketTransport::IsAlive(bool *result)
    1: {
80486:     *result = false;
    1: 
    1:     PRFileDesc *fd;
    1:     {
64576:         MutexAutoLock lock(mLock);
    1:         if (NS_FAILED(mCondition))
    1:             return NS_OK;
    1:         fd = GetFD_Locked();
    1:         if (!fd)
    1:             return NS_OK;
    1:     }
    1: 
    1:     // XXX do some idle-time based checks??
    1: 
    1:     char c;
    1:     PRInt32 rval = PR_Recv(fd, &c, 1, PR_MSG_PEEK, 0);
    1: 
    1:     if ((rval > 0) || (rval < 0 && PR_GetError() == PR_WOULD_BLOCK_ERROR))
80486:         *result = true;
    1: 
    1:     {
64576:         MutexAutoLock lock(mLock);
    1:         ReleaseFD_Locked(fd);
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketTransport::GetHost(nsACString &host)
    1: {
    1:     host = SocketHost();
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketTransport::GetPort(PRInt32 *port)
    1: {
    1:     *port = (PRInt32) SocketPort();
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketTransport::GetPeerAddr(PRNetAddr *addr)
    1: {
    1:     // once we are in the connected state, mNetAddr will not change.
    1:     // so if we can verify that we are in the connected state, then
    1:     // we can freely access mNetAddr from any thread without being
    1:     // inside a critical section.
    1: 
    1:     NS_ENSURE_TRUE(mState == STATE_TRANSFERRING, NS_ERROR_NOT_AVAILABLE);
    1: 
    1:     memcpy(addr, &mNetAddr, sizeof(mNetAddr));
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketTransport::GetSelfAddr(PRNetAddr *addr)
    1: {
    1:     // we must not call any PR methods on our file descriptor
    1:     // while holding mLock since those methods might re-enter
    1:     // socket transport code.
    1: 
    1:     PRFileDesc *fd;
    1:     {
64576:         MutexAutoLock lock(mLock);
    1:         fd = GetFD_Locked();
    1:     }
    1: 
    1:     if (!fd)
    1:         return NS_ERROR_NOT_CONNECTED;
    1: 
    1:     nsresult rv =
    1:         (PR_GetSockName(fd, addr) == PR_SUCCESS) ? NS_OK : NS_ERROR_FAILURE;
    1: 
    1:     {
64576:         MutexAutoLock lock(mLock);
    1:         ReleaseFD_Locked(fd);
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketTransport::GetTimeout(PRUint32 type, PRUint32 *value)
    1: {
    1:     NS_ENSURE_ARG_MAX(type, nsISocketTransport::TIMEOUT_READ_WRITE);
    1:     *value = (PRUint32) mTimeouts[type];
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketTransport::SetTimeout(PRUint32 type, PRUint32 value)
    1: {
    1:     NS_ENSURE_ARG_MAX(type, nsISocketTransport::TIMEOUT_READ_WRITE);
    1:     // truncate overly large timeout values.
71173:     mTimeouts[type] = (PRUint16) NS_MIN(value, PR_UINT16_MAX);
    1:     PostEvent(MSG_TIMEOUT_CHANGED);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
43040: nsSocketTransport::SetQoSBits(PRUint8 aQoSBits)
43040: {
43040:     // Don't do any checking here of bits.  Why?  Because as of RFC-4594
43040:     // several different Class Selector and Assured Forwarding values
43040:     // have been defined, but that isn't to say more won't be added later.
43040:     // In that case, any checking would be an impediment to interoperating
43040:     // with newer QoS definitions.
43040: 
43040:     mQoSBits = aQoSBits;
43040:     return NS_OK;
43040: }
43040: 
43040: NS_IMETHODIMP
43040: nsSocketTransport::GetQoSBits(PRUint8 *aQoSBits)
43040: {
43040:     *aQoSBits = mQoSBits;
43040:     return NS_OK;
43040: }
43040: 
43040: NS_IMETHODIMP
    1: nsSocketTransport::OnLookupComplete(nsICancelable *request,
    1:                                     nsIDNSRecord  *rec,
    1:                                     nsresult       status)
    1: {
    1:     // flag host lookup complete for the benefit of the ResolveHost method.
80486:     mResolving = false;
    1: 
    1:     nsresult rv = PostEvent(MSG_DNS_LOOKUP_COMPLETE, status, rec);
    1: 
    1:     // if posting a message fails, then we should assume that the socket
    1:     // transport has been shutdown.  this should never happen!  if it does
    1:     // it means that the socket transport service was shutdown before the
    1:     // DNS service.
    1:     if (NS_FAILED(rv))
    1:         NS_WARNING("unable to post DNS lookup complete message");
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketTransport::GetInterfaces(PRUint32 *count, nsIID * **array)
    1: {
    1:     return NS_CI_INTERFACE_GETTER_NAME(nsSocketTransport)(count, array);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketTransport::GetHelperForLanguage(PRUint32 language, nsISupports **_retval)
    1: {
    1:     *_retval = nsnull;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketTransport::GetContractID(char * *aContractID)
    1: {
    1:     *aContractID = nsnull;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketTransport::GetClassDescription(char * *aClassDescription)
    1: {
    1:     *aClassDescription = nsnull;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketTransport::GetClassID(nsCID * *aClassID)
    1: {
    1:     *aClassID = nsnull;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketTransport::GetImplementationLanguage(PRUint32 *aImplementationLanguage)
    1: {
    1:     *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketTransport::GetFlags(PRUint32 *aFlags)
    1: {
    1:     *aFlags = nsIClassInfo::THREADSAFE;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSocketTransport::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
    1: {
    1:     return NS_ERROR_NOT_AVAILABLE;
    1: }
    1: 
    1: 
21294: NS_IMETHODIMP
21294: nsSocketTransport::GetConnectionFlags(PRUint32 *value)
21294: {
21294:     *value = mConnectionFlags;
21294:     return NS_OK;
21294: }
21294: 
21294: NS_IMETHODIMP
21294: nsSocketTransport::SetConnectionFlags(PRUint32 value)
21294: {
21294:     mConnectionFlags = value;
21294:     return NS_OK;
21294: }
21294: 
21294: 
    1: #ifdef ENABLE_SOCKET_TRACING
    1: 
    1: #include <stdio.h>
    1: #include <ctype.h>
    1: #include "prenv.h"
    1: 
    1: static void
    1: DumpBytesToFile(const char *path, const char *header, const char *buf, PRInt32 n)
    1: {
    1:     FILE *fp = fopen(path, "a");
    1: 
    1:     fprintf(fp, "\n%s [%d bytes]\n", header, n);
    1: 
    1:     const unsigned char *p;
    1:     while (n) {
    1:         p = (const unsigned char *) buf;
    1: 
71173:         PRInt32 i, row_max = NS_MIN(16, n);
    1: 
    1:         for (i = 0; i < row_max; ++i)
    1:             fprintf(fp, "%02x  ", *p++);
    1:         for (i = row_max; i < 16; ++i)
    1:             fprintf(fp, "    ");
    1: 
    1:         p = (const unsigned char *) buf;
    1:         for (i = 0; i < row_max; ++i, ++p) {
    1:             if (isprint(*p))
    1:                 fprintf(fp, "%c", *p);
    1:             else
    1:                 fprintf(fp, ".");
    1:         }
    1: 
    1:         fprintf(fp, "\n");
    1:         buf += row_max;
    1:         n -= row_max;
    1:     }
    1: 
    1:     fprintf(fp, "\n");
    1:     fclose(fp);
    1: }
    1: 
    1: void
    1: nsSocketTransport::TraceInBuf(const char *buf, PRInt32 n)
    1: {
    1:     char *val = PR_GetEnv("NECKO_SOCKET_TRACE_LOG");
    1:     if (!val || !*val)
    1:         return;
    1: 
    1:     nsCAutoString header;
    1:     header.Assign(NS_LITERAL_CSTRING("Reading from: ") + mHost);
    1:     header.Append(':');
    1:     header.AppendInt(mPort);
    1: 
    1:     DumpBytesToFile(val, header.get(), buf, n);
    1: }
    1: 
    1: void
    1: nsSocketTransport::TraceOutBuf(const char *buf, PRInt32 n)
    1: {
    1:     char *val = PR_GetEnv("NECKO_SOCKET_TRACE_LOG");
    1:     if (!val || !*val)
    1:         return;
    1: 
    1:     nsCAutoString header;
    1:     header.Assign(NS_LITERAL_CSTRING("Writing to: ") + mHost);
    1:     header.Append(':');
    1:     header.AppendInt(mPort);
    1: 
    1:     DumpBytesToFile(val, header.get(), buf, n);
    1: }
    1: 
    1: #endif
