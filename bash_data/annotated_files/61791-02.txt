 3037: /******* BEGIN LICENSE BLOCK *******
 3037:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 3037:  * 
 3037:  * The contents of this file are subject to the Mozilla Public License Version
 3037:  * 1.1 (the "License"); you may not use this file except in compliance with
 3037:  * the License. You may obtain a copy of the License at
 3037:  * http://www.mozilla.org/MPL/
 3037:  * 
 3037:  * Software distributed under the License is distributed on an "AS IS" basis,
 3037:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 3037:  * for the specific language governing rights and limitations under the
 3037:  * License.
 3037:  * 
 3037:  * The Initial Developers of the Original Code are Kevin Hendricks (MySpell)
 3042:  * and László Németh (Hunspell). Portions created by the Initial Developers
 3037:  * are Copyright (C) 2002-2005 the Initial Developers. All Rights Reserved.
 3037:  * 
 3037:  * Contributor(s): Kevin Hendricks (kevin.hendricks@sympatico.ca)
 3042:  *                 David Einstein (deinst@world.std.com)
 3037:  *                 László Németh (nemethl@gyorsposta.hu)
43385:  *                 Caolan McNamara (caolanm@redhat.com)
 3037:  *                 Davide Prina
 3037:  *                 Giuseppe Modugno
 3037:  *                 Gianluca Turconi
 3037:  *                 Simon Brouwer
 3037:  *                 Noll Janos
 3037:  *                 Biro Arpad
 3037:  *                 Goldman Eleonora
 3037:  *                 Sarlos Tamas
 3037:  *                 Bencsath Boldizsar
 3037:  *                 Halacsy Peter
 3037:  *                 Dvornik Laszlo
 3037:  *                 Gefferth Andras
 3037:  *                 Nagy Viktor
 3037:  *                 Varga Daniel
 3037:  *                 Chris Halls
 3037:  *                 Rene Engelhard
 3037:  *                 Bram Moolenaar
 3037:  *                 Dafydd Jones
 3037:  *                 Harri Pitkanen
 3037:  *                 Andras Timar
 3037:  *                 Tor Lillqvist
 3037:  * 
 3037:  * Alternatively, the contents of this file may be used under the terms of
 3037:  * either the GNU General Public License Version 2 or later (the "GPL"), or
 3037:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 3037:  * in which case the provisions of the GPL or the LGPL are applicable instead
 3037:  * of those above. If you wish to allow use of your version of this file only
 3037:  * under the terms of either the GPL or the LGPL, and not to allow others to
 3037:  * use your version of this file under the terms of the MPL, indicate your
 3037:  * decision by deleting the provisions above and replace them with the notice
 3037:  * and other provisions required by the GPL or the LGPL. If you do not delete
 3037:  * the provisions above, a recipient may use your version of this file under
 3037:  * the terms of any one of the MPL, the GPL or the LGPL.
 3037:  *
 3037:  ******* END LICENSE BLOCK *******/
 3037: 
 3037: #include <stdlib.h>
 3037: #include <string.h>
 3037: #include <stdio.h>
 3037: #include <ctype.h>
43385: 
43385: #include <vector>
43385: 
43385: #include "affixmgr.hxx"
21326: #include "affentry.hxx"
43385: #include "langnum.hxx"
43385: 
21326: #include "csutil.hxx"
 3037: 
21326: AffixMgr::AffixMgr(const char * affpath, HashMgr** ptr, int * md, const char * key) 
 3037: {
 3037:   // register hash manager and load affix data from aff file
21326:   pHMgr = ptr[0];
21326:   alldic = ptr;
21326:   maxdic = md;
 5768:   keystring = NULL;
 3037:   trystring = NULL;
 3037:   encoding=NULL;
43385:   csconv=NULL;
 3037:   utf8 = 0;
 3037:   complexprefixes = 0;
 3037:   maptable = NULL;
 3037:   nummap = 0;
 3037:   breaktable = NULL;
 3037:   numbreak = 0;
 3037:   reptable = NULL;
 3037:   numrep = 0;
21326:   iconvtable = NULL;
21326:   oconvtable = NULL;
 3037:   checkcpdtable = NULL;
21326:   // allow simplified compound forms (see 3rd field of CHECKCOMPOUNDPATTERN)
21326:   simplifiedcpd = 0;
 3037:   numcheckcpd = 0;
 3037:   defcpdtable = NULL;
 3037:   numdefcpd = 0;
 5768:   phone = NULL;
 3037:   compoundflag = FLAG_NULL; // permits word in compound forms
 3037:   compoundbegin = FLAG_NULL; // may be first word in compound forms
 3037:   compoundmiddle = FLAG_NULL; // may be middle word in compound forms
 3037:   compoundend = FLAG_NULL; // may be last word in compound forms
 3037:   compoundroot = FLAG_NULL; // compound word signing flag
 3037:   compoundpermitflag = FLAG_NULL; // compound permitting flag for suffixed word
 3037:   compoundforbidflag = FLAG_NULL; // compound fordidden flag for suffixed word
 3037:   checkcompounddup = 0; // forbid double words in compounds
 3037:   checkcompoundrep = 0; // forbid bad compounds (may be non compound word with a REP substitution)
 3037:   checkcompoundcase = 0; // forbid upper and lowercase combinations at word bounds
 3037:   checkcompoundtriple = 0; // forbid compounds with triple letters
21326:   simplifiedtriple = 0; // allow simplified triple letters in compounds (Schiff+fahrt -> Schiffahrt)
21326:   forbiddenword = FORBIDDENWORD; // forbidden word signing flag
 3037:   nosuggest = FLAG_NULL; // don't suggest words signed with NOSUGGEST flag
 3037:   lang = NULL; // language
 3037:   langnum = 0; // language code (see http://l10n.openoffice.org/languages.html)
21326:   needaffix = FLAG_NULL; // forbidden root, allowed only with suffixes
 3037:   cpdwordmax = -1; // default: unlimited wordcount in compound words
 3037:   cpdmin = -1;  // undefined
 3037:   cpdmaxsyllable = 0; // default: unlimited syllablecount in compound words
 3037:   cpdvowels=NULL; // vowels (for calculating of Hungarian compounding limit, O(n) search! XXX)
 3037:   cpdvowels_utf16=NULL; // vowels for UTF-8 encoding (bsearch instead of O(n) search)
 3037:   cpdvowels_utf16_len=0; // vowels
 3037:   pfxappnd=NULL; // previous prefix for counting the syllables of prefix BUG
 3037:   sfxappnd=NULL; // previous suffix for counting a special syllables BUG
 3037:   cpdsyllablenum=NULL; // syllable count incrementing flag
 3037:   checknum=0; // checking numbers, and word with numbers
 3037:   wordchars=NULL; // letters + spec. word characters
 3037:   wordchars_utf16=NULL; // letters + spec. word characters
 3037:   wordchars_utf16_len=0; // letters + spec. word characters
 3037:   ignorechars=NULL; // letters + spec. word characters
 3037:   ignorechars_utf16=NULL; // letters + spec. word characters
 3037:   ignorechars_utf16_len=0; // letters + spec. word characters
 3037:   version=NULL; // affix and dictionary file version string
 3037:   havecontclass=0; // flags of possible continuing classes (double affix)
 3037:   // LEMMA_PRESENT: not put root into the morphological output. Lemma presents
 3037:   // in morhological description in dictionary file. It's often combined with PSEUDOROOT.
 3037:   lemma_present = FLAG_NULL; 
 3037:   circumfix = FLAG_NULL; 
 3037:   onlyincompound = FLAG_NULL; 
 3037:   maxngramsugs = -1; // undefined
 3037:   nosplitsugs = 0;
 3037:   sugswithdots = 0;
 3037:   keepcase = 0;
 3037:   checksharps = 0;
21326:   substandard = FLAG_NULL;
21326:   fullstrip = 0;
21326: 
 3037:   sfx = NULL;
 3037:   pfx = NULL;
 3037: 
 3037:   for (int i=0; i < SETSIZE; i++) {
 3037:      pStart[i] = NULL;
 3037:      sStart[i] = NULL;
 3037:      pFlag[i] = NULL;
 3037:      sFlag[i] = NULL;
 3037:   }
 3037: 
 3037:   for (int j=0; j < CONTSIZE; j++) {
 3037:     contclasses[j] = 0;
 3037:   }
 3037: 
21326:   if (parse_file(affpath, key)) {
 3037:      HUNSPELL_WARNING(stderr, "Failure loading aff file %s\n",affpath);
 3037:   }
 3037:   
 3037:   if (cpdmin == -1) cpdmin = MINCPDLEN;
 3037: 
 3037: }
 3037: 
 3037: 
 3037: AffixMgr::~AffixMgr() 
 3037: {
 3037:   // pass through linked prefix entries and clean up
 3037:   for (int i=0; i < SETSIZE ;i++) {
 3037:        pFlag[i] = NULL;
43385:        PfxEntry * ptr = pStart[i];
 3037:        PfxEntry * nptr = NULL;
 3037:        while (ptr) {
 3037:             nptr = ptr->getNext();
 3037:             delete(ptr);
 3037:             ptr = nptr;
 3037:             nptr = NULL;
 3037:        }  
 3037:   }
 3037: 
 3037:   // pass through linked suffix entries and clean up
 3037:   for (int j=0; j < SETSIZE ; j++) {
 3037:        sFlag[j] = NULL;
43385:        SfxEntry * ptr = sStart[j];
 3037:        SfxEntry * nptr = NULL;
 3037:        while (ptr) {
 3037:             nptr = ptr->getNext();
 3037:             delete(ptr);
 3037:             ptr = nptr;
 3037:             nptr = NULL;
 3037:        }
 3037:        sStart[j] = NULL;
 3037:   }
 3037: 
 5768:   if (keystring) free(keystring);
 5768:   keystring=NULL;
 3037:   if (trystring) free(trystring);
 3037:   trystring=NULL;
 3037:   if (encoding) free(encoding);
 3037:   encoding=NULL;
 3037:   if (maptable) {  
 3037:      for (int j=0; j < nummap; j++) {
43385:         for (int k=0; k < maptable[j].len; k++) {
43385:            if (maptable[j].set[k]) free(maptable[j].set[k]);
43385:         }
43385:         free(maptable[j].set);
 3037:         maptable[j].set = NULL;
 3037:         maptable[j].len = 0;
 3037:      }
 3037:      free(maptable);  
 3037:      maptable = NULL;
 3037:   }
 3037:   nummap = 0;
 3037:   if (breaktable) {
 3037:      for (int j=0; j < numbreak; j++) {
 3037:         if (breaktable[j]) free(breaktable[j]);
 3037:         breaktable[j] = NULL;
 3037:      }
 3037:      free(breaktable);  
 3037:      breaktable = NULL;
 3037:   }
 3037:   numbreak = 0;
 3037:   if (reptable) {
 3037:      for (int j=0; j < numrep; j++) {
 3037:         free(reptable[j].pattern);
 3037:         free(reptable[j].pattern2);
 3037:      }
 3037:      free(reptable);  
 3037:      reptable = NULL;
 3037:   }
21326:   if (iconvtable) delete iconvtable;
21326:   if (oconvtable) delete oconvtable;
 5768:   if (phone && phone->rules) {
 5768:      for (int j=0; j < phone->num + 1; j++) {
 5768:         free(phone->rules[j * 2]);
 5768:         free(phone->rules[j * 2 + 1]);
 5768:      }
 5768:      free(phone->rules);
 5768:      free(phone);  
 5768:      phone = NULL;
 5768:   }
 5768: 
 3037:   if (defcpdtable) {  
 3037:      for (int j=0; j < numdefcpd; j++) {
 3037:         free(defcpdtable[j].def);
 3037:         defcpdtable[j].def = NULL;
 3037:      }
 3037:      free(defcpdtable);  
 3037:      defcpdtable = NULL;
 3037:   }
 3037:   numrep = 0;
 3037:   if (checkcpdtable) {  
 3037:      for (int j=0; j < numcheckcpd; j++) {
 3037:         free(checkcpdtable[j].pattern);
 3037:         free(checkcpdtable[j].pattern2);
21326:         free(checkcpdtable[j].pattern3);
 3037:         checkcpdtable[j].pattern = NULL;
 3037:         checkcpdtable[j].pattern2 = NULL;
21326:         checkcpdtable[j].pattern3 = NULL;
 3037:      }
 3037:      free(checkcpdtable);  
 3037:      checkcpdtable = NULL;
 3037:   }
 3037:   numcheckcpd = 0;
 3037:   FREE_FLAG(compoundflag);
 3037:   FREE_FLAG(compoundbegin);
 3037:   FREE_FLAG(compoundmiddle);
 3037:   FREE_FLAG(compoundend);
 3037:   FREE_FLAG(compoundpermitflag);
 3037:   FREE_FLAG(compoundforbidflag);
 3037:   FREE_FLAG(compoundroot);
 3037:   FREE_FLAG(forbiddenword);
 3037:   FREE_FLAG(nosuggest);
21326:   FREE_FLAG(needaffix);
 3037:   FREE_FLAG(lemma_present);
 3037:   FREE_FLAG(circumfix);
 3037:   FREE_FLAG(onlyincompound);
 3037:   
 3037:   cpdwordmax = 0;
 3037:   pHMgr = NULL;
 3037:   cpdmin = 0;
 3037:   cpdmaxsyllable = 0;
 3037:   if (cpdvowels) free(cpdvowels);
 3037:   if (cpdvowels_utf16) free(cpdvowels_utf16);
 3037:   if (cpdsyllablenum) free(cpdsyllablenum);
 3037:   free_utf_tbl();
 3037:   if (lang) free(lang);
 3037:   if (wordchars) free(wordchars);
 3037:   if (wordchars_utf16) free(wordchars_utf16);
 3037:   if (ignorechars) free(ignorechars);
 3037:   if (ignorechars_utf16) free(ignorechars_utf16);
 3037:   if (version) free(version);
 3037:   checknum=0;
43385: #ifdef MOZILLA_CLIENT
43385:   delete [] csconv;
43385: #endif
 3037: }
 3037: 
 3037: 
 3037: // read in aff file and build up prefix and suffix entry objects 
21326: int  AffixMgr::parse_file(const char * affpath, const char * key)
 3037: {
21326:   char * line; // io buffers
21326:   char ft;     // affix type
 3037:   
 3037:   // checking flag duplication
 3037:   char dupflags[CONTSIZE];
 3037:   char dupflags_ini = 1;
 3037: 
 3037:   // first line indicator for removing byte order mark
 3037:   int firstline = 1;
 3037:   
 3037:   // open the affix file
21326:   FileMgr * afflst = new FileMgr(affpath, key);
 3037:   if (!afflst) {
 3037:     HUNSPELL_WARNING(stderr, "error: could not open affix description file %s\n",affpath);
 3037:     return 1;
 3037:   }
 3037: 
 3037:   // step one is to parse the affix file building up the internal
 3037:   // affix data structures
 3037: 
 3037:     // read in each line ignoring any that do not
 3037:     // start with a known line type indicator
21326:     while ((line = afflst->getline())) {
 3037:        mychomp(line);
 3037: 
 3037:        /* remove byte order mark */
 3037:        if (firstline) {
 3037:          firstline = 0;
43385:          // Affix file begins with byte order mark: possible incompatibility with old Hunspell versions
 3037:          if (strncmp(line,"\xEF\xBB\xBF",3) == 0) {
 3037:             memmove(line, line+3, strlen(line+3)+1);
 3037:          }
 3037:        }
 3037: 
 5768:        /* parse in the keyboard string */
 5768:        if (strncmp(line,"KEY",3) == 0) {
21326:           if (parse_string(line, &keystring, afflst->getlinenum())) {
21326:              delete afflst;
 5768:              return 1;
 5768:           }
 5768:        }
 5768: 
 3037:        /* parse in the try string */
 3037:        if (strncmp(line,"TRY",3) == 0) {
21326:           if (parse_string(line, &trystring, afflst->getlinenum())) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
 3037:        /* parse in the name of the character set used by the .dict and .aff */
 3037:        if (strncmp(line,"SET",3) == 0) {
21326:           if (parse_string(line, &encoding, afflst->getlinenum())) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:           if (strcmp(encoding, "UTF-8") == 0) {
 3037:              utf8 = 1;
 3037: #ifndef OPENOFFICEORG
 3037: #ifndef MOZILLA_CLIENT
 3037:              if (initialize_utf_tbl()) return 1;
 3037: #endif
 3037: #endif
 3037:           }
 3037:        }
 3037: 
 3037:        /* parse COMPLEXPREFIXES for agglutinative languages with right-to-left writing system */
 3037:        if (strncmp(line,"COMPLEXPREFIXES",15) == 0)
 3037:                    complexprefixes = 1;
 3037: 
 3037:        /* parse in the flag used by the controlled compound words */
 3037:        if (strncmp(line,"COMPOUNDFLAG",12) == 0) {
21326:           if (parse_flag(line, &compoundflag, afflst)) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
 3037:        /* parse in the flag used by compound words */
 3037:        if (strncmp(line,"COMPOUNDBEGIN",13) == 0) {
 3037:           if (complexprefixes) {
21326:             if (parse_flag(line, &compoundend, afflst)) {
21326:               delete afflst;
 3037:               return 1;
 3037:             }
 3037:           } else {
21326:             if (parse_flag(line, &compoundbegin, afflst)) {
21326:               delete afflst;
 3037:               return 1;
 3037:             }
 3037:           }
 3037:        }
 3037: 
 3037:        /* parse in the flag used by compound words */
 3037:        if (strncmp(line,"COMPOUNDMIDDLE",14) == 0) {
21326:           if (parse_flag(line, &compoundmiddle, afflst)) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037:        /* parse in the flag used by compound words */
 3037:        if (strncmp(line,"COMPOUNDEND",11) == 0) {
 3037:           if (complexprefixes) {
21326:             if (parse_flag(line, &compoundbegin, afflst)) {
21326:               delete afflst;
 3037:               return 1;
 3037:             }
 3037:           } else {
21326:             if (parse_flag(line, &compoundend, afflst)) {
21326:               delete afflst;
 3037:               return 1;
 3037:             }
 3037:           }
 3037:        }
 3037: 
 3037:        /* parse in the data used by compound_check() method */
 3037:        if (strncmp(line,"COMPOUNDWORDMAX",15) == 0) {
21326:           if (parse_num(line, &cpdwordmax, afflst)) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
 3037:        /* parse in the flag sign compounds in dictionary */
 3037:        if (strncmp(line,"COMPOUNDROOT",12) == 0) {
21326:           if (parse_flag(line, &compoundroot, afflst)) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
 3037:        /* parse in the flag used by compound_check() method */
 3037:        if (strncmp(line,"COMPOUNDPERMITFLAG",18) == 0) {
21326:           if (parse_flag(line, &compoundpermitflag, afflst)) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
 3037:        /* parse in the flag used by compound_check() method */
 3037:        if (strncmp(line,"COMPOUNDFORBIDFLAG",18) == 0) {
21326:           if (parse_flag(line, &compoundforbidflag, afflst)) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
 3037:        if (strncmp(line,"CHECKCOMPOUNDDUP",16) == 0) {
 3037:                    checkcompounddup = 1;
 3037:        }
 3037: 
 3037:        if (strncmp(line,"CHECKCOMPOUNDREP",16) == 0) {
 3037:                    checkcompoundrep = 1;
 3037:        }
 3037: 
 3037:        if (strncmp(line,"CHECKCOMPOUNDTRIPLE",19) == 0) {
 3037:                    checkcompoundtriple = 1;
 3037:        }
 3037: 
21326:        if (strncmp(line,"SIMPLIFIEDTRIPLE",16) == 0) {
21326:                    simplifiedtriple = 1;
21326:        }
21326: 
 3037:        if (strncmp(line,"CHECKCOMPOUNDCASE",17) == 0) {
 3037:                    checkcompoundcase = 1;
 3037:        }
 3037: 
 3037:        if (strncmp(line,"NOSUGGEST",9) == 0) {
21326:           if (parse_flag(line, &nosuggest, afflst)) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
 3037:        /* parse in the flag used by forbidden words */
 3037:        if (strncmp(line,"FORBIDDENWORD",13) == 0) {
21326:           if (parse_flag(line, &forbiddenword, afflst)) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
 3037:        /* parse in the flag used by forbidden words */
 3037:        if (strncmp(line,"LEMMA_PRESENT",13) == 0) {
21326:           if (parse_flag(line, &lemma_present, afflst)) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
 3037:        /* parse in the flag used by circumfixes */
 3037:        if (strncmp(line,"CIRCUMFIX",9) == 0) {
21326:           if (parse_flag(line, &circumfix, afflst)) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
 3037:        /* parse in the flag used by fogemorphemes */
 3037:        if (strncmp(line,"ONLYINCOMPOUND",14) == 0) {
21326:           if (parse_flag(line, &onlyincompound, afflst)) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
21326:        /* parse in the flag used by `needaffixs' */
 3037:        if (strncmp(line,"PSEUDOROOT",10) == 0) {
21326:           if (parse_flag(line, &needaffix, afflst)) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
21326:        /* parse in the flag used by `needaffixs' */
 3037:        if (strncmp(line,"NEEDAFFIX",9) == 0) {
21326:           if (parse_flag(line, &needaffix, afflst)) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
 3037:        /* parse in the minimal length for words in compounds */
 3037:        if (strncmp(line,"COMPOUNDMIN",11) == 0) {
21326:           if (parse_num(line, &cpdmin, afflst)) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:           if (cpdmin < 1) cpdmin = 1;
 3037:        }
 3037: 
 3037:        /* parse in the max. words and syllables in compounds */
 3037:        if (strncmp(line,"COMPOUNDSYLLABLE",16) == 0) {
21326:           if (parse_cpdsyllable(line, afflst)) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
 3037:        /* parse in the flag used by compound_check() method */
 3037:        if (strncmp(line,"SYLLABLENUM",11) == 0) {
21326:           if (parse_string(line, &cpdsyllablenum, afflst->getlinenum())) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
 3037:        /* parse in the flag used by the controlled compound words */
 3037:        if (strncmp(line,"CHECKNUM",8) == 0) {
 3037:            checknum=1;
 3037:        }
 3037: 
 3037:        /* parse in the extra word characters */
 3037:        if (strncmp(line,"WORDCHARS",9) == 0) {
21326:           if (parse_array(line, &wordchars, &wordchars_utf16, &wordchars_utf16_len, utf8, afflst->getlinenum())) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
 3037:        /* parse in the ignored characters (for example, Arabic optional diacretics charachters */
 3037:        if (strncmp(line,"IGNORE",6) == 0) {
21326:           if (parse_array(line, &ignorechars, &ignorechars_utf16, &ignorechars_utf16_len, utf8, afflst->getlinenum())) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
 3037:        /* parse in the typical fault correcting table */
 3037:        if (strncmp(line,"REP",3) == 0) {
 3037:           if (parse_reptable(line, afflst)) {
21326:              delete afflst;
21326:              return 1;
21326:           }
21326:        }
21326: 
21326:        /* parse in the input conversion table */
21326:        if (strncmp(line,"ICONV",5) == 0) {
21326:           if (parse_convtable(line, afflst, &iconvtable, "ICONV")) {
21326:              delete afflst;
21326:              return 1;
21326:           }
21326:        }
21326: 
21326:        /* parse in the input conversion table */
21326:        if (strncmp(line,"OCONV",5) == 0) {
21326:           if (parse_convtable(line, afflst, &oconvtable, "OCONV")) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
 5768:        /* parse in the phonetic translation table */
 5768:        if (strncmp(line,"PHONE",5) == 0) {
 5768:           if (parse_phonetable(line, afflst)) {
21326:              delete afflst;
 5768:              return 1;
 5768:           }
 5768:        }
 5768: 
 3037:        /* parse in the checkcompoundpattern table */
 3037:        if (strncmp(line,"CHECKCOMPOUNDPATTERN",20) == 0) {
 3037:           if (parse_checkcpdtable(line, afflst)) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
 3037:        /* parse in the defcompound table */
 3037:        if (strncmp(line,"COMPOUNDRULE",12) == 0) {
 3037:           if (parse_defcpdtable(line, afflst)) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
 3037:        /* parse in the related character map table */
 3037:        if (strncmp(line,"MAP",3) == 0) {
 3037:           if (parse_maptable(line, afflst)) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
 3037:        /* parse in the word breakpoints table */
 3037:        if (strncmp(line,"BREAK",5) == 0) {
 3037:           if (parse_breaktable(line, afflst)) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
 3037:        /* parse in the language for language specific codes */
 3037:        if (strncmp(line,"LANG",4) == 0) {
21326:           if (parse_string(line, &lang, afflst->getlinenum())) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:           langnum = get_lang_num(lang);
 3037:        }
 3037: 
 3037:        if (strncmp(line,"VERSION",7) == 0) {
21326:           for(line = line + 7; *line == ' ' || *line == '\t'; line++);
21326:           version = mystrdup(line);
 3037:        }
 3037: 
 3037:        if (strncmp(line,"MAXNGRAMSUGS",12) == 0) {
21326:           if (parse_num(line, &maxngramsugs, afflst)) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
 3037:        if (strncmp(line,"NOSPLITSUGS",11) == 0) {
 3037:                    nosplitsugs=1;
 3037:        }
 3037: 
21326:        if (strncmp(line,"FULLSTRIP",9) == 0) {
21326:                    fullstrip=1;
21326:        }
21326: 
 3037:        if (strncmp(line,"SUGSWITHDOTS",12) == 0) {
 3037:                    sugswithdots=1;
 3037:        }
 3037: 
 3037:        /* parse in the flag used by forbidden words */
 3037:        if (strncmp(line,"KEEPCASE",8) == 0) {
21326:           if (parse_flag(line, &keepcase, afflst)) {
21326:              delete afflst;
21326:              return 1;
21326:           }
21326:        }
21326: 
21326:        /* parse in the flag used by the affix generator */
21326:        if (strncmp(line,"SUBSTANDARD",11) == 0) {
21326:           if (parse_flag(line, &substandard, afflst)) {
21326:              delete afflst;
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
 3037:        if (strncmp(line,"CHECKSHARPS",11) == 0) {
 3037:                    checksharps=1;
 3037:        }
 3037: 
 3037:        /* parse this affix: P - prefix, S - suffix */
 3037:        ft = ' ';
 3037:        if (strncmp(line,"PFX",3) == 0) ft = complexprefixes ? 'S' : 'P';
 3037:        if (strncmp(line,"SFX",3) == 0) ft = complexprefixes ? 'P' : 'S';
 3037:        if (ft != ' ') {
 3037:           if (dupflags_ini) {
43385:             memset(dupflags, 0, sizeof(dupflags));
 3037:             dupflags_ini = 0;
 3037:           }
 3037:           if (parse_affix(line, ft, afflst, dupflags)) {
21326:              delete afflst;
 3037:              process_pfx_tree_to_list();
 3037:              process_sfx_tree_to_list();
 3037:              return 1;
 3037:           }
 3037:        }
 3037: 
 3037:     }
21326:     delete afflst;
 3037: 
 3037:     // convert affix trees to sorted list
 3037:     process_pfx_tree_to_list();
 3037:     process_sfx_tree_to_list();
 3037: 
 3037:     // now we can speed up performance greatly taking advantage of the 
 3037:     // relationship between the affixes and the idea of "subsets".
 3037: 
 3037:     // View each prefix as a potential leading subset of another and view
 3037:     // each suffix (reversed) as a potential trailing subset of another.
 3037: 
 3037:     // To illustrate this relationship if we know the prefix "ab" is found in the
 3037:     // word to examine, only prefixes that "ab" is a leading subset of need be examined.
 3037:     // Furthermore is "ab" is not present then none of the prefixes that "ab" is
 3037:     // is a subset need be examined.
 3037:     // The same argument goes for suffix string that are reversed.
 3037: 
 3037:     // Then to top this off why not examine the first char of the word to quickly
 3037:     // limit the set of prefixes to examine (i.e. the prefixes to examine must 
 3037:     // be leading supersets of the first character of the word (if they exist)
 3037:  
 3037:     // To take advantage of this "subset" relationship, we need to add two links
 3037:     // from entry.  One to take next if the current prefix is found (call it nexteq)
 3037:     // and one to take next if the current prefix is not found (call it nextne).
 3037: 
43385:     // Since we have built ordered lists, all that remains is to properly initialize 
 3037:     // the nextne and nexteq pointers that relate them
 3037: 
 3037:     process_pfx_order();
 3037:     process_sfx_order();
 3037: 
 3037:     /* get encoding for CHECKCOMPOUNDCASE */
21326:     if (!utf8) {
 3037:     char * enc = get_encoding();
 3037:     csconv = get_current_cs(enc);
 3037:     free(enc);
 3037:     enc = NULL;
 3037: 
21326:     char expw[MAXLNLEN];
21326:     if (wordchars) {
21326:         strcpy(expw, wordchars);
21326:         free(wordchars);
21326:     } else *expw = '\0';
21326: 
21326:     for (int i = 0; i <= 255; i++) {
21326:         if ( (csconv[i].cupper != csconv[i].clower) &&
21326:             (! strchr(expw, (char) i))) {
21326:                 *(expw + strlen(expw) + 1) = '\0';
21326:                 *(expw + strlen(expw)) = (char) i;
21326:         }
21326:     }
21326: 
21326:     wordchars = mystrdup(expw);
21326:     }
21326: 
21326:     // default BREAK definition
21326:     if (!breaktable) {
21326:         breaktable = (char **) malloc(sizeof(char *) * 3);
 3037:         if (!breaktable) return 1;
 3037:         breaktable[0] = mystrdup("-");
21326:         breaktable[1] = mystrdup("^-");
21326:         breaktable[2] = mystrdup("-$");
21326:         if (breaktable[0] && breaktable[1] && breaktable[2]) numbreak = 3;
 3037:     }
 3037:     return 0;
 3037: }
 3037: 
 3037: 
 3037: // we want to be able to quickly access prefix information
 3037: // both by prefix flag, and sorted by prefix string itself 
 3037: // so we need to set up two indexes
 3037: 
43385: int AffixMgr::build_pfxtree(PfxEntry* pfxptr)
 3037: {
 3037:   PfxEntry * ptr;
 3037:   PfxEntry * pptr;
43385:   PfxEntry * ep = pfxptr;
 3037: 
 3037:   // get the right starting points
 3037:   const char * key = ep->getKey();
 3037:   const unsigned char flg = (unsigned char) (ep->getFlag() & 0x00FF);
 3037: 
 3037:   // first index by flag which must exist
43385:   ptr = pFlag[flg];
 3037:   ep->setFlgNxt(ptr);
43385:   pFlag[flg] = ep;
 3037: 
 3037: 
 3037:   // handle the special case of null affix string
 3037:   if (strlen(key) == 0) {
 3037:     // always inset them at head of list at element 0
43385:      ptr = pStart[0];
 3037:      ep->setNext(ptr);
43385:      pStart[0] = ep;
 3037:      return 0;
 3037:   }
 3037: 
 3037:   // now handle the normal case
 3037:   ep->setNextEQ(NULL);
 3037:   ep->setNextNE(NULL);
 3037: 
 3037:   unsigned char sp = *((const unsigned char *)key);
43385:   ptr = pStart[sp];
 3037:   
 3037:   // handle the first insert 
 3037:   if (!ptr) {
43385:      pStart[sp] = ep;
 3037:      return 0;
 3037:   }
 3037: 
 3037: 
 3037:   // otherwise use binary tree insertion so that a sorted
 3037:   // list can easily be generated later
 3037:   pptr = NULL;
 3037:   for (;;) {
 3037:     pptr = ptr;
 3037:     if (strcmp(ep->getKey(), ptr->getKey() ) <= 0) {
 3037:        ptr = ptr->getNextEQ();
 3037:        if (!ptr) {
 3037:           pptr->setNextEQ(ep);
 3037:           break;
 3037:        }
 3037:     } else {
 3037:        ptr = ptr->getNextNE();
 3037:        if (!ptr) {
 3037:           pptr->setNextNE(ep);
 3037:           break;
 3037:        }
 3037:     }
 3037:   }
 3037:   return 0;
 3037: }
 3037: 
 3037: // we want to be able to quickly access suffix information
 3037: // both by suffix flag, and sorted by the reverse of the
 3037: // suffix string itself; so we need to set up two indexes
43385: int AffixMgr::build_sfxtree(SfxEntry* sfxptr)
 3037: {
 3037:   SfxEntry * ptr;
 3037:   SfxEntry * pptr;
43385:   SfxEntry * ep = sfxptr;
 3037: 
 3037:   /* get the right starting point */
 3037:   const char * key = ep->getKey();
 3037:   const unsigned char flg = (unsigned char) (ep->getFlag() & 0x00FF);
 3037: 
 3037:   // first index by flag which must exist
43385:   ptr = sFlag[flg];
 3037:   ep->setFlgNxt(ptr);
43385:   sFlag[flg] = ep;
 3037: 
 3037:   // next index by affix string
 3037: 
 3037:   // handle the special case of null affix string
 3037:   if (strlen(key) == 0) {
 3037:     // always inset them at head of list at element 0
43385:      ptr = sStart[0];
 3037:      ep->setNext(ptr);
43385:      sStart[0] = ep;
 3037:      return 0;
 3037:   }
 3037: 
 3037:   // now handle the normal case
 3037:   ep->setNextEQ(NULL);
 3037:   ep->setNextNE(NULL);
 3037: 
 3037:   unsigned char sp = *((const unsigned char *)key);
43385:   ptr = sStart[sp];
 3037:   
 3037:   // handle the first insert 
 3037:   if (!ptr) {
43385:      sStart[sp] = ep;
 3037:      return 0;
 3037:   }
 3037: 
 3037:   // otherwise use binary tree insertion so that a sorted
 3037:   // list can easily be generated later
 3037:   pptr = NULL;
 3037:   for (;;) {
 3037:     pptr = ptr;
 3037:     if (strcmp(ep->getKey(), ptr->getKey() ) <= 0) {
 3037:        ptr = ptr->getNextEQ();
 3037:        if (!ptr) {
 3037:           pptr->setNextEQ(ep);
 3037:           break;
 3037:        }
 3037:     } else {
 3037:        ptr = ptr->getNextNE();
 3037:        if (!ptr) {
 3037:           pptr->setNextNE(ep);
 3037:           break;
 3037:        }
 3037:     }
 3037:   }
 3037:   return 0;
 3037: }
 3037: 
 3037: // convert from binary tree to sorted list
 3037: int AffixMgr::process_pfx_tree_to_list()
 3037: {
 3037:   for (int i=1; i< SETSIZE; i++) {
 3037:     pStart[i] = process_pfx_in_order(pStart[i],NULL);
 3037:   }
 3037:   return 0;
 3037: }
 3037: 
 3037: 
43385: PfxEntry* AffixMgr::process_pfx_in_order(PfxEntry* ptr, PfxEntry* nptr)
 3037: {
 3037:   if (ptr) {
43385:     nptr = process_pfx_in_order(ptr->getNextNE(), nptr);
43385:     ptr->setNext(nptr);
43385:     nptr = process_pfx_in_order(ptr->getNextEQ(), ptr);
 3037:   }
 3037:   return nptr;
 3037: }
 3037: 
 3037: 
 3037: // convert from binary tree to sorted list
 3037: int AffixMgr:: process_sfx_tree_to_list()
 3037: {
 3037:   for (int i=1; i< SETSIZE; i++) {
 3037:     sStart[i] = process_sfx_in_order(sStart[i],NULL);
 3037:   }
 3037:   return 0;
 3037: }
 3037: 
43385: SfxEntry* AffixMgr::process_sfx_in_order(SfxEntry* ptr, SfxEntry* nptr)
 3037: {
 3037:   if (ptr) {
43385:     nptr = process_sfx_in_order(ptr->getNextNE(), nptr);
43385:     ptr->setNext(nptr);
43385:     nptr = process_sfx_in_order(ptr->getNextEQ(), ptr);
 3037:   }
 3037:   return nptr;
 3037: }
 3037: 
 3037: 
 3037: // reinitialize the PfxEntry links NextEQ and NextNE to speed searching
 3037: // using the idea of leading subsets this time
 3037: int AffixMgr::process_pfx_order()
 3037: {
 3037:     PfxEntry* ptr;
 3037: 
 3037:     // loop through each prefix list starting point
 3037:     for (int i=1; i < SETSIZE; i++) {
 3037: 
43385:          ptr = pStart[i];
 3037: 
 3037:          // look through the remainder of the list
 3037:          //  and find next entry with affix that 
 3037:          // the current one is not a subset of
 3037:          // mark that as destination for NextNE
 3037:          // use next in list that you are a subset
 3037:          // of as NextEQ
 3037: 
 3037:          for (; ptr != NULL; ptr = ptr->getNext()) {
 3037: 
 3037:              PfxEntry * nptr = ptr->getNext();
 3037:              for (; nptr != NULL; nptr = nptr->getNext()) {
 3037:                  if (! isSubset( ptr->getKey() , nptr->getKey() )) break;
 3037:              }
 3037:              ptr->setNextNE(nptr);
 3037:              ptr->setNextEQ(NULL);
 3037:              if ((ptr->getNext()) && isSubset(ptr->getKey() , (ptr->getNext())->getKey())) 
 3037:                  ptr->setNextEQ(ptr->getNext());
 3037:          }
 3037: 
 3037:          // now clean up by adding smart search termination strings:
 3037:          // if you are already a superset of the previous prefix
 3037:          // but not a subset of the next, search can end here
 3037:          // so set NextNE properly
 3037: 
43385:          ptr = pStart[i];
 3037:          for (; ptr != NULL; ptr = ptr->getNext()) {
 3037:              PfxEntry * nptr = ptr->getNext();
 3037:              PfxEntry * mptr = NULL;
 3037:              for (; nptr != NULL; nptr = nptr->getNext()) {
 3037:                  if (! isSubset(ptr->getKey(),nptr->getKey())) break;
 3037:                  mptr = nptr;
 3037:              }
 3037:              if (mptr) mptr->setNextNE(NULL);
 3037:          }
 3037:     }
 3037:     return 0;
 3037: }
 3037: 
 3037: // initialize the SfxEntry links NextEQ and NextNE to speed searching
 3037: // using the idea of leading subsets this time
 3037: int AffixMgr::process_sfx_order()
 3037: {
 3037:     SfxEntry* ptr;
 3037: 
 3037:     // loop through each prefix list starting point
 3037:     for (int i=1; i < SETSIZE; i++) {
 3037: 
43385:          ptr = sStart[i];
 3037: 
 3037:          // look through the remainder of the list
 3037:          //  and find next entry with affix that 
 3037:          // the current one is not a subset of
 3037:          // mark that as destination for NextNE
 3037:          // use next in list that you are a subset
 3037:          // of as NextEQ
 3037: 
 3037:          for (; ptr != NULL; ptr = ptr->getNext()) {
 3037:              SfxEntry * nptr = ptr->getNext();
 3037:              for (; nptr != NULL; nptr = nptr->getNext()) {
 3037:                  if (! isSubset(ptr->getKey(),nptr->getKey())) break;
 3037:              }
 3037:              ptr->setNextNE(nptr);
 3037:              ptr->setNextEQ(NULL);
 3037:              if ((ptr->getNext()) && isSubset(ptr->getKey(),(ptr->getNext())->getKey())) 
 3037:                  ptr->setNextEQ(ptr->getNext());
 3037:          }
 3037: 
 3037: 
 3037:          // now clean up by adding smart search termination strings:
 3037:          // if you are already a superset of the previous suffix
 3037:          // but not a subset of the next, search can end here
 3037:          // so set NextNE properly
 3037: 
43385:          ptr = sStart[i];
 3037:          for (; ptr != NULL; ptr = ptr->getNext()) {
 3037:              SfxEntry * nptr = ptr->getNext();
 3037:              SfxEntry * mptr = NULL;
 3037:              for (; nptr != NULL; nptr = nptr->getNext()) {
 3037:                  if (! isSubset(ptr->getKey(),nptr->getKey())) break;
 3037:                  mptr = nptr;
 3037:              }
 3037:              if (mptr) mptr->setNextNE(NULL);
 3037:          }
 3037:     }
 3037:     return 0;
 3037: }
 3037: 
21326: // add flags to the result for dictionary debugging
21326: void AffixMgr::debugflag(char * result, unsigned short flag) {
21326:     char * st = encode_flag(flag);
21326:     mystrcat(result, " ", MAXLNLEN);
21326:     mystrcat(result, MORPH_FLAG, MAXLNLEN);
21326:     if (st) {
21326:         mystrcat(result, st, MAXLNLEN);
21326:         free(st);
21326:     }
21326: }
21326: 
21326: // calculate the character length of the condition
21326: int AffixMgr::condlen(char * st)
21326: {
21326:   int l = 0;
21326:   bool group = false;
21326:   for(; *st; st++) {
21326:     if (*st == '[') {
21326:         group = true;
21326:         l++;
21326:     } else if (*st == ']') group = false;
21326:     else if (!group && (!utf8 ||
21326:         (!(*st & 0x80) || ((*st & 0xc0) == 0x80)))) l++;
21326:   }
21326:   return l;
21326: }
 3037: 
43385: int AffixMgr::encodeit(affentry &entry, char * cs)
 3037: {
21326:   if (strcmp(cs,".") != 0) {
43385:     entry.numconds = (char) condlen(cs);
43385:     strncpy(entry.c.conds, cs, MAXCONDLEN);
21326:     // long condition (end of conds padded by strncpy)
43385:     if (entry.c.conds[MAXCONDLEN - 1] && cs[MAXCONDLEN]) {
43385:       entry.opts += aeLONGCOND;
43385:       entry.c.l.conds2 = mystrdup(cs + MAXCONDLEN_1);
43385:       if (!entry.c.l.conds2) return 1;
21326:     }
21326:   } else {
43385:     entry.numconds = 0;
43385:     entry.c.conds[0] = '\0';
21326:   }
 3037:   return 0;
 3037: }
 3037: 
 3037: // return 1 if s1 is a leading subset of s2 (dots are for infixes)
 3037: inline int AffixMgr::isSubset(const char * s1, const char * s2)
 3037:  {
 3037:     while (((*s1 == *s2) || (*s1 == '.')) && (*s1 != '\0')) {
 3037:         s1++;
 3037:         s2++;
 3037:     }
 3037:     return (*s1 == '\0');
 3037:  }
 3037: 
 3037: 
 3037: // check word for prefixes
 3037: struct hentry * AffixMgr::prefix_check(const char * word, int len, char in_compound,
 3037:     const FLAG needflag)
 3037: {
 3037:     struct hentry * rv= NULL;
 3037: 
 3037:     pfx = NULL;
 3037:     pfxappnd = NULL;
 3037:     sfxappnd = NULL;
 3037:     
 3037:     // first handle the special case of 0 length prefixes
43385:     PfxEntry * pe = pStart[0];
 3037:     while (pe) {
 3037:         if (
 3037:             // fogemorpheme
 3037:               ((in_compound != IN_CPD_NOT) || !(pe->getCont() &&
 3037:                   (TESTAFF(pe->getCont(), onlyincompound, pe->getContLen())))) &&
 3037:             // permit prefixes in compounds
 3037:               ((in_compound != IN_CPD_END) || (pe->getCont() &&
 3037:                   (TESTAFF(pe->getCont(), compoundpermitflag, pe->getContLen()))))
 3037:               ) {
 3037:                     // check prefix
 3037:                     rv = pe->checkword(word, len, in_compound, needflag);
 3037:                     if (rv) {
43385:                         pfx=pe; // BUG: pfx not stateless
 3037:                         return rv;
 3037:                     }
 3037:              }
 3037:        pe = pe->getNext();
 3037:     }
 3037:   
 3037:     // now handle the general case
 3037:     unsigned char sp = *((const unsigned char *)word);
43385:     PfxEntry * pptr = pStart[sp];
 3037: 
 3037:     while (pptr) {
 3037:         if (isSubset(pptr->getKey(),word)) {
 3037:              if (
 3037:             // fogemorpheme
 3037:               ((in_compound != IN_CPD_NOT) || !(pptr->getCont() &&
 3037:                   (TESTAFF(pptr->getCont(), onlyincompound, pptr->getContLen())))) &&
 3037:             // permit prefixes in compounds
 3037:               ((in_compound != IN_CPD_END) || (pptr->getCont() &&
 3037:                   (TESTAFF(pptr->getCont(), compoundpermitflag, pptr->getContLen()))))
 3037:               ) {
 3037:             // check prefix
 3037:                   rv = pptr->checkword(word, len, in_compound, needflag);
 3037:                   if (rv) {
43385:                     pfx=pptr; // BUG: pfx not stateless
 3037:                     return rv;
 3037:                   }
 3037:              }
 3037:              pptr = pptr->getNextEQ();
 3037:         } else {
 3037:              pptr = pptr->getNextNE();
 3037:         }
 3037:     }
 3037:     
 3037:     return NULL;
 3037: }
 3037: 
 3037: // check word for prefixes
 3037: struct hentry * AffixMgr::prefix_check_twosfx(const char * word, int len,
 3037:     char in_compound, const FLAG needflag)
 3037: {
 3037:     struct hentry * rv= NULL;
 3037: 
 3037:     pfx = NULL;
 3037:     sfxappnd = NULL;
 3037:     
 3037:     // first handle the special case of 0 length prefixes
43385:     PfxEntry * pe = pStart[0];
 3037:     
 3037:     while (pe) {
 3037:         rv = pe->check_twosfx(word, len, in_compound, needflag);
 3037:         if (rv) return rv;
 3037:         pe = pe->getNext();
 3037:     }
 3037:   
 3037:     // now handle the general case
 3037:     unsigned char sp = *((const unsigned char *)word);
43385:     PfxEntry * pptr = pStart[sp];
 3037: 
 3037:     while (pptr) {
 3037:         if (isSubset(pptr->getKey(),word)) {
 3037:             rv = pptr->check_twosfx(word, len, in_compound, needflag);
 3037:             if (rv) {
43385:                 pfx = pptr;
 3037:                 return rv;
 3037:             }
 3037:             pptr = pptr->getNextEQ();
 3037:         } else {
 3037:              pptr = pptr->getNextNE();
 3037:         }
 3037:     }
 3037:     
 3037:     return NULL;
 3037: }
 3037: 
 3037: // check word for prefixes
 3037: char * AffixMgr::prefix_check_morph(const char * word, int len, char in_compound,
 3037:     const FLAG needflag)
 3037: {
 3037:     char * st;
 3037: 
 3037:     char result[MAXLNLEN];
 3037:     result[0] = '\0';
 3037: 
 3037:     pfx = NULL;
 3037:     sfxappnd = NULL;
 3037:     
 3037:     // first handle the special case of 0 length prefixes
43385:     PfxEntry * pe = pStart[0];
 3037:     while (pe) {
 3037:        st = pe->check_morph(word,len,in_compound, needflag);
 3037:        if (st) {
21326:             mystrcat(result, st, MAXLNLEN);
 3037:             free(st);
 3037:        }
 3037:        // if (rv) return rv;
 3037:        pe = pe->getNext();
 3037:     }
 3037:   
 3037:     // now handle the general case
 3037:     unsigned char sp = *((const unsigned char *)word);
43385:     PfxEntry * pptr = pStart[sp];
 3037: 
 3037:     while (pptr) {
 3037:         if (isSubset(pptr->getKey(),word)) {
 3037:             st = pptr->check_morph(word,len,in_compound, needflag);
 3037:             if (st) {
 3037:               // fogemorpheme
 3037:               if ((in_compound != IN_CPD_NOT) || !((pptr->getCont() && 
 3037:                         (TESTAFF(pptr->getCont(), onlyincompound, pptr->getContLen()))))) {
21326:                     mystrcat(result, st, MAXLNLEN);
43385:                     pfx = pptr;
 3037:                 }
 3037:                 free(st);
 3037:             }
 3037:             pptr = pptr->getNextEQ();
 3037:         } else {
 3037:             pptr = pptr->getNextNE();
 3037:         }
 3037:     }
 3037:     
 3037:     if (*result) return mystrdup(result);
 3037:     return NULL;
 3037: }
 3037: 
 3037: 
 3037: // check word for prefixes
 3037: char * AffixMgr::prefix_check_twosfx_morph(const char * word, int len,
 3037:     char in_compound, const FLAG needflag)
 3037: {
 3037:     char * st;
 3037: 
 3037:     char result[MAXLNLEN];
 3037:     result[0] = '\0';
 3037: 
 3037:     pfx = NULL;
 3037:     sfxappnd = NULL;
 3037:     
 3037:     // first handle the special case of 0 length prefixes
43385:     PfxEntry * pe = pStart[0];
 3037:     while (pe) {
 3037:         st = pe->check_twosfx_morph(word,len,in_compound, needflag);
 3037:         if (st) {
21326:             mystrcat(result, st, MAXLNLEN);
 3037:             free(st);
 3037:         }
 3037:         pe = pe->getNext();
 3037:     }
 3037:   
 3037:     // now handle the general case
 3037:     unsigned char sp = *((const unsigned char *)word);
43385:     PfxEntry * pptr = pStart[sp];
 3037: 
 3037:     while (pptr) {
 3037:         if (isSubset(pptr->getKey(),word)) {
 3037:             st = pptr->check_twosfx_morph(word, len, in_compound, needflag);
 3037:             if (st) {
21326:                 mystrcat(result, st, MAXLNLEN);
 3037:                 free(st);
43385:                 pfx = pptr;
 3037:             }
 3037:             pptr = pptr->getNextEQ();
 3037:         } else {
 3037:             pptr = pptr->getNextNE();
 3037:         }
 3037:     }
 3037:     
 3037:     if (*result) return mystrdup(result);
 3037:     return NULL;
 3037: }
 3037: 
 3037: // Is word a non compound with a REP substitution (see checkcompoundrep)?
 3037: int AffixMgr::cpdrep_check(const char * word, int wl)
 3037: {
 3037:   char candidate[MAXLNLEN];
 3037:   const char * r;
 3037:   int lenr, lenp;
 3037: 
 3037:   if ((wl < 2) || !numrep) return 0;
 3037: 
 3037:   for (int i=0; i < numrep; i++ ) {
 3037:       r = word;
 3037:       lenr = strlen(reptable[i].pattern2);
 3037:       lenp = strlen(reptable[i].pattern);
 3037:       // search every occurence of the pattern in the word
 3037:       while ((r=strstr(r, reptable[i].pattern)) != NULL) {
 3037:           strcpy(candidate, word);
 3037:           if (r-word + lenr + strlen(r+lenp) >= MAXLNLEN) break;
 3037:           strcpy(candidate+(r-word),reptable[i].pattern2);
 3037:           strcpy(candidate+(r-word)+lenr, r+lenp);
 3037:           if (candidate_check(candidate,strlen(candidate))) return 1;
 3037:           r++; // search for the next letter
 3037:       }
 3037:    }
 3037:    return 0;
 3037: }
 3037: 
 3037: // forbid compoundings when there are special patterns at word bound
21326: int AffixMgr::cpdpat_check(const char * word, int pos, hentry * r1, hentry * r2)
 3037: {
 3037:   int len;
 3037:   for (int i = 0; i < numcheckcpd; i++) {
 3037:       if (isSubset(checkcpdtable[i].pattern2, word + pos) &&
21326:         (!r1 || !checkcpdtable[i].cond ||
21326:           (r1->astr && TESTAFF(r1->astr, checkcpdtable[i].cond, r1->alen))) &&
21326:         (!r2 || !checkcpdtable[i].cond2 ||
21326:           (r2->astr && TESTAFF(r2->astr, checkcpdtable[i].cond2, r2->alen))) &&
 3037:         (len = strlen(checkcpdtable[i].pattern)) && (pos > len) &&
 3037:         (strncmp(word + pos - len, checkcpdtable[i].pattern, len) == 0)) return 1;
 3037:   }
 3037:   return 0;
 3037: }
 3037: 
 3037: // forbid compounding with neighbouring upper and lower case characters at word bounds
 3037: int AffixMgr::cpdcase_check(const char * word, int pos)
 3037: {
 3037:   if (utf8) {
 3037:       w_char u, w;
 3037:       const char * p;
 3037:       u8_u16(&u, 1, word + pos);
 3037:       for (p = word + pos - 1; (*p & 0xc0) == 0x80; p--);
 3037:       u8_u16(&w, 1, p);
 3037:       unsigned short a = (u.h << 8) + u.l;
 3037:       unsigned short b = (w.h << 8) + w.l;
21326:       if (((unicodetoupper(a, langnum) == a) || (unicodetoupper(b, langnum) == b)) &&
21326:           (a != '-') && (b != '-')) return 1;
 3037:   } else {
 3037:       unsigned char a = *(word + pos - 1);
 3037:       unsigned char b = *(word + pos);
 3037:       if ((csconv[a].ccase || csconv[b].ccase) && (a != '-') && (b != '-')) return 1;
 3037:   }
 3037:   return 0;
 3037: }
 3037: 
 3037: // check compound patterns
 3037: int AffixMgr::defcpd_check(hentry *** words, short wnum, hentry * rv, hentry ** def, char all)
 3037: {
 3037:   signed short btpp[MAXWORDLEN]; // metacharacter (*, ?) positions for backtracking
 3037:   signed short btwp[MAXWORDLEN]; // word positions for metacharacters
 3037:   int btnum[MAXWORDLEN]; // number of matched characters in metacharacter positions
 3037:   short bt = 0;  
21326:   int i, j;
 3037:   int ok;
 3037:   int w = 0;
21326: 
 3037:   if (!*words) {
 3037:     w = 1;
 3037:     *words = def;
 3037:   }
43385: 
43385:   if (!*words) {
43385:     return 0;
43385:   }
43385: 
 3037:   (*words)[wnum] = rv;
 3037: 
21326:   // has the last word COMPOUNDRULE flag?
21326:   if (rv->alen == 0) {
21326:     (*words)[wnum] = NULL;
21326:     if (w) *words = NULL;
21326:     return 0;
21326:   }
21326:   ok = 0;
21326:   for (i = 0; i < numdefcpd; i++) {
21326:     for (j = 0; j < defcpdtable[i].len; j++) {
21326:        if (defcpdtable[i].def[j] != '*' && defcpdtable[i].def[j] != '?' &&
21326:           TESTAFF(rv->astr, defcpdtable[i].def[j], rv->alen)) ok = 1;
21326:     }
21326:   }
21326:   if (ok == 0) {
21326:     (*words)[wnum] = NULL;
21326:     if (w) *words = NULL;
21326:     return 0;
21326:   }
21326: 
 3037:   for (i = 0; i < numdefcpd; i++) {
 3037:     signed short pp = 0; // pattern position
 3037:     signed short wp = 0; // "words" position
 3037:     int ok2;
 3037:     ok = 1;
 3037:     ok2 = 1;
 3037:     do {
 3037:       while ((pp < defcpdtable[i].len) && (wp <= wnum)) {
 3037:         if (((pp+1) < defcpdtable[i].len) &&
 3037:           ((defcpdtable[i].def[pp+1] == '*') || (defcpdtable[i].def[pp+1] == '?'))) {
 3037:             int wend = (defcpdtable[i].def[pp+1] == '?') ? wp : wnum;
 3037:             ok2 = 1;
 3037:             pp+=2;
 3037:             btpp[bt] = pp;
 3037:             btwp[bt] = wp;
 3037:             while (wp <= wend) {
 3037:                 if (!(*words)[wp]->alen || 
 3037:                   !TESTAFF((*words)[wp]->astr, defcpdtable[i].def[pp-2], (*words)[wp]->alen)) {
 3037:                     ok2 = 0;
 3037:                     break;
 3037:                 }
 3037:                 wp++;
 3037:             }
 3037:             if (wp <= wnum) ok2 = 0;
 3037:             btnum[bt] = wp - btwp[bt];
 3037:             if (btnum[bt] > 0) bt++;
 3037:             if (ok2) break;
 3037:         } else {
 3037:             ok2 = 1;
 3037:             if (!(*words)[wp] || !(*words)[wp]->alen || 
 3037:               !TESTAFF((*words)[wp]->astr, defcpdtable[i].def[pp], (*words)[wp]->alen)) {
 3037:                 ok = 0;
 3037:                 break;
 3037:             }
 3037:             pp++;
 3037:             wp++;
 3037:             if ((defcpdtable[i].len == pp) && !(wp > wnum)) ok = 0;
 3037:         }
 3037:       }
 3037:     if (ok && ok2) { 
 3037:         int r = pp;
 3037:         while ((defcpdtable[i].len > r) && ((r+1) < defcpdtable[i].len) &&
 3037:             ((defcpdtable[i].def[r+1] == '*') || (defcpdtable[i].def[r+1] == '?'))) r+=2;
 3037:         if (defcpdtable[i].len <= r) return 1;
 3037:     }
 3037:     // backtrack
 3037:     if (bt) do {
 3037:         ok = 1;
 3037:         btnum[bt - 1]--;
 3037:         pp = btpp[bt - 1];
21326:         wp = btwp[bt - 1] + (signed short) btnum[bt - 1];
 3037:     } while ((btnum[bt - 1] < 0) && --bt);
 3037:   } while (bt);
 3037: 
 3037:   if (ok && ok2 && (!all || (defcpdtable[i].len <= pp))) return 1;
21326: 
 3037:   // check zero ending
 3037:   while (ok && ok2 && (defcpdtable[i].len > pp) && ((pp+1) < defcpdtable[i].len) &&
 3037:     ((defcpdtable[i].def[pp+1] == '*') || (defcpdtable[i].def[pp+1] == '?'))) pp+=2;
 3037:   if (ok && ok2 && (defcpdtable[i].len <= pp)) return 1;
 3037:   }
 3037:   (*words)[wnum] = NULL;
 3037:   if (w) *words = NULL;
 3037:   return 0;
 3037: }
 3037: 
 3037: inline int AffixMgr::candidate_check(const char * word, int len)
 3037: {
 3037:   struct hentry * rv=NULL;
 3037:   
 3037:   rv = lookup(word);
 3037:   if (rv) return 1;
 3037: 
 3037: //  rv = prefix_check(word,len,1);
 3037: //  if (rv) return 1;
 3037:   
 3037:   rv = affix_check(word,len);
 3037:   if (rv) return 1;
 3037:   return 0;
 3037: }
 3037: 
 3037: // calculate number of syllable for compound-checking
 3037: short AffixMgr::get_syllable(const char * word, int wlen)
 3037: {
 3037:     if (cpdmaxsyllable==0) return 0;
 3037:     
 3037:     short num=0;
 3037: 
 3037:     if (!utf8) {
 3037:         for (int i=0; i<wlen; i++) {
 3037:             if (strchr(cpdvowels, word[i])) num++;
 3037:         }
 3037:     } else if (cpdvowels_utf16) {
 3037:         w_char w[MAXWORDUTF8LEN];
 3037:         int i = u8_u16(w, MAXWORDUTF8LEN, word);
 5768:         for (; i > 0; i--) {
 3037:             if (flag_bsearch((unsigned short *) cpdvowels_utf16,
 3037:                 ((unsigned short *) w)[i - 1], cpdvowels_utf16_len)) num++;
 3037:         }
 3037:     }
 3037:     return num;
 3037: }
 3037: 
21326: void AffixMgr::setcminmax(int * cmin, int * cmax, const char * word, int len) {
21326:     if (utf8) {
21326:         int i;
21326:         for (*cmin = 0, i = 0; (i < cpdmin) && word[*cmin]; i++) {
21326:           for ((*cmin)++; (word[*cmin] & 0xc0) == 0x80; (*cmin)++);
21326:         }
21326:         for (*cmax = len, i = 0; (i < (cpdmin - 1)) && *cmax; i++) {
21326:           for ((*cmax)--; (word[*cmax] & 0xc0) == 0x80; (*cmax)--);
21326:         }
21326:     } else {
21326:         *cmin = cpdmin;
21326:         *cmax = len - cpdmin + 1;
21326:     }
21326: }
21326: 
 3037: // check if compound word is correctly spelled
 3037: // hu_mov_rule = spec. Hungarian rule (XXX)
 3037: struct hentry * AffixMgr::compound_check(const char * word, int len, 
 3037:     short wordnum, short numsyllable, short maxwordnum, short wnum, hentry ** words = NULL,
21326:     char hu_mov_rule = 0, char is_sug = 0)
 3037: {
 3037:     int i; 
 3037:     short oldnumsyllable, oldnumsyllable2, oldwordnum, oldwordnum2;
 3037:     struct hentry * rv = NULL;
 3037:     struct hentry * rv_first;
 3037:     struct hentry * rwords[MAXWORDLEN]; // buffer for COMPOUND pattern checking
 3037:     char st [MAXWORDUTF8LEN + 4];
 3037:     char ch;
 3037:     int cmin;
 3037:     int cmax;
21326:     int striple = 0;
21326:     int scpd = 0;
21326:     int soldi = 0;
21326:     int oldcmin = 0;
21326:     int oldcmax = 0;
21326:     int oldlen = 0;
21326:     int checkedstriple = 0;
 3037: 
 3037:     int checked_prefix;
 3037: 
21326:     setcminmax(&cmin, &cmax, word, len);
 3037: 
 3037:     strcpy(st, word);
 3037: 
 3037:     for (i = cmin; i < cmax; i++) {
 3037: 
 3037:         oldnumsyllable = numsyllable;
 3037:         oldwordnum = wordnum;
 3037:         checked_prefix = 0;
 3037: 
 3037:         // go to end of the UTF-8 character
 3037:         if (utf8) {
 3037:             for (; (st[i] & 0xc0) == 0x80; i++);
 3037:             if (i >= cmax) return NULL;
 3037:         }
 3037: 
21326:         do { // simplified checkcompoundpattern loop
21326: 
21326:         if (scpd > 0) {
21326:           for (; scpd <= numcheckcpd && (!checkcpdtable[scpd-1].pattern3 ||
21326:             strncmp(word + i, checkcpdtable[scpd-1].pattern3, strlen(checkcpdtable[scpd-1].pattern3)) != 0); scpd++);
21326: 
21326:           if (scpd > numcheckcpd) break; // break simplified checkcompoundpattern loop
21326:           strcpy(st + i, checkcpdtable[scpd-1].pattern);
21326:           soldi = i;
21326:           i += strlen(checkcpdtable[scpd-1].pattern);
21326:           strcpy(st + i, checkcpdtable[scpd-1].pattern2);
21326:           strcpy(st + i + strlen(checkcpdtable[scpd-1].pattern2), word + soldi + strlen(checkcpdtable[scpd-1].pattern3));
21326: 
21326:           oldlen = len;
21326:           len += strlen(checkcpdtable[scpd-1].pattern) + strlen(checkcpdtable[scpd-1].pattern2) - strlen(checkcpdtable[scpd-1].pattern3);
21326:           oldcmin = cmin;
21326:           oldcmax = cmax;
21326:           setcminmax(&cmin, &cmax, st, len);
21326: 
21326:           cmax = len - cpdmin + 1;
21326:         }
21326: 
 3037: 
 3037:         ch = st[i];
 3037:         st[i] = '\0';
 3037: 
 3037:         sfx = NULL;
 3037:         pfx = NULL;
 3037: 
 3037:         // FIRST WORD
 3037: 
 3037:         rv = lookup(st); // perhaps without prefix
 3037: 
 3037:         // search homonym with compound flag
 3037:         while ((rv) && !hu_mov_rule &&
21326:             ((needaffix && TESTAFF(rv->astr, needaffix, rv->alen)) ||
 3037:                 !((compoundflag && !words && TESTAFF(rv->astr, compoundflag, rv->alen)) ||
 3037:                   (compoundbegin && !wordnum &&
 3037:                         TESTAFF(rv->astr, compoundbegin, rv->alen)) ||
 3037:                   (compoundmiddle && wordnum && !words &&
 3037:                     TESTAFF(rv->astr, compoundmiddle, rv->alen)) ||
 3037:                   (numdefcpd &&
 3037:                     ((!words && !wordnum && defcpd_check(&words, wnum, rv, (hentry **) &rwords, 0)) ||
21326:                     (words && defcpd_check(&words, wnum, rv, (hentry **) &rwords, 0))))) ||
21326:                   (scpd != 0 && checkcpdtable[scpd-1].cond != FLAG_NULL &&
21326:                     !TESTAFF(rv->astr, checkcpdtable[scpd-1].cond, rv->alen)))
21326:                   ) {
 3037:             rv = rv->next_homonym;
 3037:         }
 3037: 
 3037:         if (!rv) {
 3037:             if (compoundflag && 
 3037:              !(rv = prefix_check(st, i, hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN, compoundflag))) {
 3037:                 if ((rv = suffix_check(st, i, 0, NULL, NULL, 0, NULL,
 3037:                         FLAG_NULL, compoundflag, hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN)) && !hu_mov_rule &&
43385:                     sfx->getCont() &&
43385:                         ((compoundforbidflag && TESTAFF(sfx->getCont(), compoundforbidflag, 
43385:                             sfx->getContLen())) || (compoundend &&
43385:                         TESTAFF(sfx->getCont(), compoundend, 
43385:                             sfx->getContLen())))) {
 3037:                         rv = NULL;
 3037:                 }
 3037:             }
21326: 
 3037:             if (rv ||
 3037:               (((wordnum == 0) && compoundbegin &&
 3037:                 ((rv = suffix_check(st, i, 0, NULL, NULL, 0, NULL, FLAG_NULL, compoundbegin, hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN)) ||
 3037:                 (rv = prefix_check(st, i, hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN, compoundbegin)))) ||
 3037:               ((wordnum > 0) && compoundmiddle &&
 3037:                 ((rv = suffix_check(st, i, 0, NULL, NULL, 0, NULL, FLAG_NULL, compoundmiddle, hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN)) ||
 3037:                 (rv = prefix_check(st, i, hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN, compoundmiddle)))))
 3037:               ) checked_prefix = 1;
21326:         // else check forbiddenwords and needaffix
 3037:         } else if (rv->astr && (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
21326:             TESTAFF(rv->astr, needaffix, rv->alen) || 
 3037:             (is_sug && nosuggest && TESTAFF(rv->astr, nosuggest, rv->alen))
 3037:              )) {
 3037:                 st[i] = ch;
 3037:                 continue;
 3037:         }
 3037: 
 3037:             // check non_compound flag in suffix and prefix
 3037:             if ((rv) && !hu_mov_rule &&
43385:                 ((pfx && pfx->getCont() &&
43385:                     TESTAFF(pfx->getCont(), compoundforbidflag, 
43385:                         pfx->getContLen())) ||
43385:                 (sfx && sfx->getCont() &&
43385:                     TESTAFF(sfx->getCont(), compoundforbidflag, 
43385:                         sfx->getContLen())))) {
 3037:                     rv = NULL;
 3037:             }
 3037: 
 3037:             // check compoundend flag in suffix and prefix
 3037:             if ((rv) && !checked_prefix && compoundend && !hu_mov_rule &&
43385:                 ((pfx && pfx->getCont() &&
43385:                     TESTAFF(pfx->getCont(), compoundend, 
43385:                         pfx->getContLen())) ||
43385:                 (sfx && sfx->getCont() &&
43385:                     TESTAFF(sfx->getCont(), compoundend, 
43385:                         sfx->getContLen())))) {
 3037:                     rv = NULL;
 3037:             }
 3037: 
 3037:             // check compoundmiddle flag in suffix and prefix
 3037:             if ((rv) && !checked_prefix && (wordnum==0) && compoundmiddle && !hu_mov_rule &&
43385:                 ((pfx && pfx->getCont() &&
43385:                     TESTAFF(pfx->getCont(), compoundmiddle, 
43385:                         pfx->getContLen())) ||
43385:                 (sfx && sfx->getCont() &&
43385:                     TESTAFF(sfx->getCont(), compoundmiddle, 
43385:                         sfx->getContLen())))) {
 3037:                     rv = NULL;
 3037:             }
 3037: 
 3037:         // check forbiddenwords
 3037:         if ((rv) && (rv->astr) && (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
 3037:             (is_sug && nosuggest && TESTAFF(rv->astr, nosuggest, rv->alen)))) {
 3037:                 return NULL;
 3037:             }
 3037: 
 3037:         // increment word number, if the second root has a compoundroot flag
 3037:         if ((rv) && compoundroot && 
 3037:             (TESTAFF(rv->astr, compoundroot, rv->alen))) {
 3037:                 wordnum++;
 3037:         }
 3037: 
 3037:         // first word is acceptable in compound words?
 3037:         if (((rv) && 
 3037:           ( checked_prefix || (words && words[wnum]) ||
 3037:             (compoundflag && TESTAFF(rv->astr, compoundflag, rv->alen)) ||
 3037:             ((oldwordnum == 0) && compoundbegin && TESTAFF(rv->astr, compoundbegin, rv->alen)) ||
 3037:             ((oldwordnum > 0) && compoundmiddle && TESTAFF(rv->astr, compoundmiddle, rv->alen))// ||
 3037: //            (numdefcpd && )
 3037: 
 3037: // LANG_hu section: spec. Hungarian rule
 3037:             || ((langnum == LANG_hu) && hu_mov_rule && (
 3037:                     TESTAFF(rv->astr, 'F', rv->alen) || // XXX hardwired Hungarian dictionary codes
 3037:                     TESTAFF(rv->astr, 'G', rv->alen) ||
 3037:                     TESTAFF(rv->astr, 'H', rv->alen)
 3037:                 )
 3037:               )
 3037: // END of LANG_hu section
21326:           ) &&
21326:           (
21326:              // test CHECKCOMPOUNDPATTERN conditions
21326:              scpd == 0 || checkcpdtable[scpd-1].cond == FLAG_NULL || 
21326:                 TESTAFF(rv->astr, checkcpdtable[scpd-1].cond, rv->alen)
 3037:           )
21326:           && ! (( checkcompoundtriple && scpd == 0 && !words && // test triple letters
 3037:                    (word[i-1]==word[i]) && (
 3037:                       ((i>1) && (word[i-1]==word[i-2])) ||
 3037:                       ((word[i-1]==word[i+1])) // may be word[i+1] == '\0'
 3037:                    )
 3037:                ) ||
 3037:                (
21326:                  checkcompoundcase && scpd == 0 && !words && cpdcase_check(word, i)
 3037:                ))
 3037:          )
 3037: // LANG_hu section: spec. Hungarian rule
 3037:          || ((!rv) && (langnum == LANG_hu) && hu_mov_rule && (rv = affix_check(st,i)) &&
43385:               (sfx && sfx->getCont() && ( // XXX hardwired Hungarian dic. codes
43385:                         TESTAFF(sfx->getCont(), (unsigned short) 'x', sfx->getContLen()) ||
43385:                         TESTAFF(sfx->getCont(), (unsigned short) '%', sfx->getContLen())
 3037:                     )
 3037:                )
 3037:              )
21326:          ) { // first word is ok condition
 3037: 
 3037: // LANG_hu section: spec. Hungarian rule
 3037:             if (langnum == LANG_hu) {
 3037:                 // calculate syllable number of the word
 3037:                 numsyllable += get_syllable(st, i);
 3037: 
 3037:                 // + 1 word, if syllable number of the prefix > 1 (hungarian convention)
43385:                 if (pfx && (get_syllable(pfx->getKey(),strlen(pfx->getKey())) > 1)) wordnum++;
 3037:             }
 3037: // END of LANG_hu section
 3037: 
 3037: 
 3037:             // NEXT WORD(S)
 3037:             rv_first = rv;
21326:             st[i] = ch;
21326: 
21326:         do { // striple loop
21326: 
21326:             // check simplifiedtriple
21326:             if (simplifiedtriple) { 
21326:               if (striple) { 
21326:                 checkedstriple = 1;
21326:                 i--; // check "fahrt" instead of "ahrt" in "Schiffahrt"
21326:               } else if (i > 2 && *(word+i - 1) == *(word + i - 2)) striple = 1;
21326:             }
21326: 
21326:             rv = lookup((st+i)); // perhaps without prefix
 3037: 
 3037:         // search homonym with compound flag
21326:         while ((rv) && ((needaffix && TESTAFF(rv->astr, needaffix, rv->alen)) ||
 3037:                         !((compoundflag && !words && TESTAFF(rv->astr, compoundflag, rv->alen)) ||
 3037:                           (compoundend && !words && TESTAFF(rv->astr, compoundend, rv->alen)) ||
21326:                            (numdefcpd && words && defcpd_check(&words, wnum + 1, rv, NULL,1))) ||
21326:                              (scpd != 0 && checkcpdtable[scpd-1].cond2 != FLAG_NULL &&
21326:                                 !TESTAFF(rv->astr, checkcpdtable[scpd-1].cond2, rv->alen))
21326:                            )) {
 3037:             rv = rv->next_homonym;
 3037:         }
 3037: 
21326:             if (rv && words && words[wnum + 1]) return rv_first;
 3037: 
 3037:             oldnumsyllable2 = numsyllable;
 3037:             oldwordnum2 = wordnum;
 3037: 
 3037: // LANG_hu section: spec. Hungarian rule, XXX hardwired dictionary code
 3037:             if ((rv) && (langnum == LANG_hu) && (TESTAFF(rv->astr, 'I', rv->alen)) && !(TESTAFF(rv->astr, 'J', rv->alen))) {
 3037:                 numsyllable--;
 3037:             }
 3037: // END of LANG_hu section
 3037: 
 3037:             // increment word number, if the second root has a compoundroot flag
 3037:             if ((rv) && (compoundroot) && 
 3037:                 (TESTAFF(rv->astr, compoundroot, rv->alen))) {
 3037:                     wordnum++;
 3037:             }
 3037: 
 3037:             // check forbiddenwords
 3037:             if ((rv) && (rv->astr) && (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
 3037:                (is_sug && nosuggest && TESTAFF(rv->astr, nosuggest, rv->alen)))) return NULL;
 3037: 
 3037:             // second word is acceptable, as a root?
 3037:             // hungarian conventions: compounding is acceptable,
 3037:             // when compound forms consist of 2 words, or if more,
 3037:             // then the syllable number of root words must be 6, or lesser.
 3037: 
 3037:             if ((rv) && (
 3037:                       (compoundflag && TESTAFF(rv->astr, compoundflag, rv->alen)) ||
 3037:                       (compoundend && TESTAFF(rv->astr, compoundend, rv->alen))
 3037:                     )
 3037:                 && (
 3037:                       ((cpdwordmax==-1) || (wordnum+1<cpdwordmax)) || 
21326:                       ((cpdmaxsyllable!=0) && 
21326:                           (numsyllable + get_syllable(HENTRY_WORD(rv), rv->clen)<=cpdmaxsyllable))
21326:                     ) &&
21326:                (
21326:                  // test CHECKCOMPOUNDPATTERN
21326:                  !numcheckcpd || scpd != 0 || !cpdpat_check(word, i, rv_first, rv)
21326:                ) &&
21326:                 (
 3037:                      (!checkcompounddup || (rv != rv_first))
 3037:                    )
21326:             // test CHECKCOMPOUNDPATTERN conditions
21326:                 && (scpd == 0 || checkcpdtable[scpd-1].cond2 == FLAG_NULL ||
21326:                       TESTAFF(rv->astr, checkcpdtable[scpd-1].cond2, rv->alen))
 3037:                 )
 3037:                  {
 3037:                       // forbid compound word, if it is a non compound word with typical fault
 3037:                       if (checkcompoundrep && cpdrep_check(word,len)) return NULL;
21326:                       return rv_first;
 3037:             }
 3037: 
 3037:             numsyllable = oldnumsyllable2;
 3037:             wordnum = oldwordnum2;
 3037: 
 3037:             // perhaps second word has prefix or/and suffix
 3037:             sfx = NULL;
 3037:             sfxflag = FLAG_NULL;
 3037:             rv = (compoundflag) ? affix_check((word+i),strlen(word+i), compoundflag, IN_CPD_END) : NULL;
 3037:             if (!rv && compoundend) {
 3037:                 sfx = NULL;
 3037:                 pfx = NULL;
 3037:                 rv = affix_check((word+i),strlen(word+i), compoundend, IN_CPD_END);
 3037:             }
 3037: 
 3037:             if (!rv && numdefcpd && words) {
 3037:                 rv = affix_check((word+i),strlen(word+i), 0, IN_CPD_END);
21326:                 if (rv && defcpd_check(&words, wnum + 1, rv, NULL, 1)) return rv_first;
 5768:                 rv = NULL;
 3037:             }
 3037: 
21326:             // test CHECKCOMPOUNDPATTERN conditions (allowed forms)
21326:             if (rv && !(scpd == 0 || checkcpdtable[scpd-1].cond2 == FLAG_NULL || 
21326:                 TESTAFF(rv->astr, checkcpdtable[scpd-1].cond2, rv->alen))) rv = NULL;
21326: 
21326:             // test CHECKCOMPOUNDPATTERN conditions (forbidden compounds)
21326:             if (rv && numcheckcpd && scpd == 0 && cpdpat_check(word, i, rv_first, rv)) rv = NULL;
21326: 
 3037:             // check non_compound flag in suffix and prefix
 3037:             if ((rv) && 
43385:                 ((pfx && pfx->getCont() &&
43385:                     TESTAFF(pfx->getCont(), compoundforbidflag, 
43385:                         pfx->getContLen())) ||
43385:                 (sfx && sfx->getCont() &&
43385:                     TESTAFF(sfx->getCont(), compoundforbidflag, 
43385:                         sfx->getContLen())))) {
 3037:                     rv = NULL;
 3037:             }
 3037: 
 3037:             // check forbiddenwords
 3037:             if ((rv) && (rv->astr) && (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
 3037:                (is_sug && nosuggest && TESTAFF(rv->astr, nosuggest, rv->alen)))) return NULL;
 3037: 
 3037:             // pfxappnd = prefix of word+i, or NULL
 3037:             // calculate syllable number of prefix.
 3037:             // hungarian convention: when syllable number of prefix is more,
 3037:             // than 1, the prefix+word counts as two words.
 3037: 
 3037:             if (langnum == LANG_hu) {
 3037:                 // calculate syllable number of the word
 3037:                 numsyllable += get_syllable(word + i, strlen(word + i));
 3037: 
 3037:                 // - affix syllable num.
 3037:                 // XXX only second suffix (inflections, not derivations)
 3037:                 if (sfxappnd) {
 3037:                     char * tmp = myrevstrdup(sfxappnd);
 3037:                     numsyllable -= get_syllable(tmp, strlen(tmp));
 3037:                     free(tmp);
 3037:                 }
 3037: 
 3037:                 // + 1 word, if syllable number of the prefix > 1 (hungarian convention)
43385:                 if (pfx && (get_syllable(pfx->getKey(),strlen(pfx->getKey())) > 1)) wordnum++;
 3037: 
 3037:                 // increment syllable num, if last word has a SYLLABLENUM flag
 3037:                 // and the suffix is beginning `s'
 3037: 
 3037:                 if (cpdsyllablenum) {
 3037:                     switch (sfxflag) {
 3037:                         case 'c': { numsyllable+=2; break; }
 3037:                         case 'J': { numsyllable += 1; break; }
 3037:                         case 'I': { if (TESTAFF(rv->astr, 'J', rv->alen)) numsyllable += 1; break; }
 3037:                     }
 3037:                 }
 3037:             }
 3037: 
 3037:             // increment word number, if the second word has a compoundroot flag
 3037:             if ((rv) && (compoundroot) && 
 3037:                 (TESTAFF(rv->astr, compoundroot, rv->alen))) {
 3037:                     wordnum++;
 3037:             }
 3037: 
 3037:             // second word is acceptable, as a word with prefix or/and suffix?
 3037:             // hungarian conventions: compounding is acceptable,
 3037:             // when compound forms consist 2 word, otherwise
 3037:             // the syllable number of root words is 6, or lesser.
 3037:             if ((rv) && 
 3037:                     (
 3037:                       ((cpdwordmax == -1) || (wordnum + 1 < cpdwordmax)) || 
21326:                       ((cpdmaxsyllable != 0) && 
 3037:                           (numsyllable <= cpdmaxsyllable))
 3037:                     )
 3037:                 && (
 3037:                    (!checkcompounddup || (rv != rv_first))
 3037:                    )) {
 3037:                     // forbid compound word, if it is a non compound word with typical fault
 3037:                     if (checkcompoundrep && cpdrep_check(word, len)) return NULL;
21326:                     return rv_first;
 3037:             }
 3037: 
 3037:             numsyllable = oldnumsyllable2;
 3037:             wordnum = oldwordnum2;
21326: 
 3037:             // perhaps second word is a compound word (recursive call)
 3037:             if (wordnum < maxwordnum) {
21326:                 rv = compound_check((st+i),strlen(st+i), wordnum+1,
21326:                      numsyllable, maxwordnum, wnum + 1, words, 0, is_sug);
43385:                 if (rv && numcheckcpd && ((scpd == 0 && cpdpat_check(word, i, rv_first, rv)) ||
43385:                    (scpd != 0 && !cpdpat_check(word, i, rv_first, rv)))) rv = NULL;
 3037:             } else {
 3037:                 rv=NULL;
 3037:             }
 3037:             if (rv) {
 3037:                 // forbid compound word, if it is a non compound word with typical fault
 3037:                 if (checkcompoundrep && cpdrep_check(word, len)) return NULL;
21326:                 return rv_first;
21326:             }
21326:           } while (striple && !checkedstriple); // end of striple loop
21326: 
21326:           if (checkedstriple) {
21326:             i++;
21326:             checkedstriple = 0;
21326:             striple = 0;
21326:           }
21326: 
21326:         } // first word is ok condition
21326: 
21326:         if (soldi != 0) {
21326:           i = soldi;
21326:           soldi = 0;
21326:           len = oldlen;
21326:           cmin = oldcmin;
21326:           cmax = oldcmax;
21326:         }
21326:         scpd++;
21326: 
21326:         } while (simplifiedcpd && scpd <= numcheckcpd); // end of simplifiedcpd loop
21326: 
21326:         if (soldi != 0) {
21326:           i = soldi;
21326:           strcpy(st, word); // XXX add more optim.
21326:           soldi = 0;
21326:         } else st[i] = ch;
21326: 
21326:         scpd = 0;
 3037:         wordnum = oldwordnum;
 3037:         numsyllable = oldnumsyllable;
 3037:     }
 3037: 
 3037:     return NULL;
 3037: }
 3037: 
 3037: // check if compound word is correctly spelled
 3037: // hu_mov_rule = spec. Hungarian rule (XXX)
 3037: int AffixMgr::compound_check_morph(const char * word, int len, 
 3037:     short wordnum, short numsyllable, short maxwordnum, short wnum, hentry ** words,
 3037:     char hu_mov_rule = 0, char ** result = NULL, char * partresult = NULL)
 3037: {
 3037:     int i;
 3037:     short oldnumsyllable, oldnumsyllable2, oldwordnum, oldwordnum2;
 3037:     int ok = 0;
 3037: 
 3037:     struct hentry * rv = NULL;
 3037:     struct hentry * rv_first;
 3037:     struct hentry * rwords[MAXWORDLEN]; // buffer for COMPOUND pattern checking
 3037:     char st [MAXWORDUTF8LEN + 4];
 3037:     char ch;
 3037: 
 3037:     int checked_prefix;
 3037:     char presult[MAXLNLEN];
 3037: 
 3037:     int cmin;
 3037:     int cmax;
 3037: 
21326:     setcminmax(&cmin, &cmax, word, len);
 3037: 
 3037:     strcpy(st, word);
 3037: 
 3037:     for (i = cmin; i < cmax; i++) {
 3037:         oldnumsyllable = numsyllable;
 3037:         oldwordnum = wordnum;
 3037:         checked_prefix = 0;
 3037: 
 3037:         // go to end of the UTF-8 character
 3037:         if (utf8) {
 3037:             for (; (st[i] & 0xc0) == 0x80; i++);
 3037:             if (i >= cmax) return 0;
 3037:         }
 3037: 
 3037:         ch = st[i];
 3037:         st[i] = '\0';
 3037:         sfx = NULL;
 3037: 
 3037:         // FIRST WORD
 3037:         *presult = '\0';
43385:         if (partresult) mystrcat(presult, partresult, MAXLNLEN);
 3037: 
 3037:         rv = lookup(st); // perhaps without prefix
 3037: 
 3037:         // search homonym with compound flag
 3037:         while ((rv) && !hu_mov_rule && 
21326:             ((needaffix && TESTAFF(rv->astr, needaffix, rv->alen)) ||
 3037:                 !((compoundflag && !words && TESTAFF(rv->astr, compoundflag, rv->alen)) ||
 3037:                 (compoundbegin && !wordnum &&
 3037:                         TESTAFF(rv->astr, compoundbegin, rv->alen)) ||
 3037:                 (compoundmiddle && wordnum && !words &&
 3037:                     TESTAFF(rv->astr, compoundmiddle, rv->alen)) ||
 3037:                   (numdefcpd &&
 3037:                     ((!words && !wordnum && defcpd_check(&words, wnum, rv, (hentry **) &rwords, 0)) ||
 3037:                     (words && defcpd_check(&words, wnum, rv, (hentry **) &rwords, 0))))
 3037:                   ))) {
 3037:             rv = rv->next_homonym;
 3037:         }
 3037: 
 3037:         if (rv)  {
21326:             sprintf(presult + strlen(presult), "%c%s%s", MSEP_FLD, MORPH_PART, st);
21326:             if (!HENTRY_FIND(rv, MORPH_STEM)) {
21326:                 sprintf(presult + strlen(presult), "%c%s%s", MSEP_FLD, MORPH_STEM, st);
21326:             }
21326:             // store the pointer of the hash entry
21326: //            sprintf(presult + strlen(presult), "%c%s%p", MSEP_FLD, MORPH_HENTRY, rv);
21326:             if (HENTRY_DATA(rv)) {
21326:                 sprintf(presult + strlen(presult), "%c%s", MSEP_FLD, HENTRY_DATA2(rv));
21326:             }
21326:         }        
 3037:         if (!rv) {
 3037:             if (compoundflag && 
 3037:              !(rv = prefix_check(st, i, hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN, compoundflag))) {
 3037:                 if ((rv = suffix_check(st, i, 0, NULL, NULL, 0, NULL,
 3037:                         FLAG_NULL, compoundflag, hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN)) && !hu_mov_rule &&
43385:                     sfx->getCont() &&
43385:                         ((compoundforbidflag && TESTAFF(sfx->getCont(), compoundforbidflag, 
43385:                             sfx->getContLen())) || (compoundend &&
43385:                         TESTAFF(sfx->getCont(), compoundend, 
43385:                             sfx->getContLen())))) {
 3037:                         rv = NULL;
 3037:                 }
 3037:             }
 3037: 
 3037:             if (rv ||
 3037:               (((wordnum == 0) && compoundbegin &&
 3037:                 ((rv = suffix_check(st, i, 0, NULL, NULL, 0, NULL, FLAG_NULL, compoundbegin, hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN)) ||
 3037:                 (rv = prefix_check(st, i, hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN, compoundbegin)))) ||
 3037:               ((wordnum > 0) && compoundmiddle &&
 3037:                 ((rv = suffix_check(st, i, 0, NULL, NULL, 0, NULL, FLAG_NULL, compoundmiddle, hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN)) ||
 3037:                 (rv = prefix_check(st, i, hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN, compoundmiddle)))))
 3037:               ) {
 3037:                 // char * p = prefix_check_morph(st, i, 0, compound);
 3037:                 char * p = NULL;
 3037:                 if (compoundflag) p = affix_check_morph(st, i, compoundflag);
 3037:                 if (!p || (*p == '\0')) {
21326:                    if (p) free(p);
21326:                    p = NULL;
 3037:                    if ((wordnum == 0) && compoundbegin) {
 3037:                      p = affix_check_morph(st, i, compoundbegin);
 3037:                    } else if ((wordnum > 0) && compoundmiddle) {
 3037:                      p = affix_check_morph(st, i, compoundmiddle);                   
 3037:                    }
 3037:                 }
21326:                 if (p && (*p != '\0')) {
21326:                     sprintf(presult + strlen(presult), "%c%s%s%s", MSEP_FLD,
21326:                         MORPH_PART, st, line_uniq_app(&p, MSEP_REC));
21326:                 }
21326:                 if (p) free(p);
 3037:                 checked_prefix = 1;
 3037:             }
 3037:         // else check forbiddenwords
 3037:         } else if (rv->astr && (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
21326:             TESTAFF(rv->astr, needaffix, rv->alen))) {
 3037:                 st[i] = ch;
 3037:                 continue;
 3037:         }
 3037: 
 3037:             // check non_compound flag in suffix and prefix
 3037:             if ((rv) && !hu_mov_rule &&
43385:                 ((pfx && pfx->getCont() &&
43385:                     TESTAFF(pfx->getCont(), compoundforbidflag, 
43385:                         pfx->getContLen())) ||
43385:                 (sfx && sfx->getCont() &&
43385:                     TESTAFF(sfx->getCont(), compoundforbidflag, 
43385:                         sfx->getContLen())))) {
 3037:                     continue;
 3037:             }
 3037: 
 3037:             // check compoundend flag in suffix and prefix
 3037:             if ((rv) && !checked_prefix && compoundend && !hu_mov_rule &&
43385:                 ((pfx && pfx->getCont() &&
43385:                     TESTAFF(pfx->getCont(), compoundend, 
43385:                         pfx->getContLen())) ||
43385:                 (sfx && sfx->getCont() &&
43385:                     TESTAFF(sfx->getCont(), compoundend, 
43385:                         sfx->getContLen())))) {
 3037:                     continue;
 3037:             }
 3037: 
 3037:             // check compoundmiddle flag in suffix and prefix
 3037:             if ((rv) && !checked_prefix && (wordnum==0) && compoundmiddle && !hu_mov_rule &&
43385:                 ((pfx && pfx->getCont() &&
43385:                     TESTAFF(pfx->getCont(), compoundmiddle, 
43385:                         pfx->getContLen())) ||
43385:                 (sfx && sfx->getCont() &&
43385:                     TESTAFF(sfx->getCont(), compoundmiddle, 
43385:                         sfx->getContLen())))) {
 3037:                     rv = NULL;
 3037:             }       
 3037: 
 3037:         // check forbiddenwords
 3037:         if ((rv) && (rv->astr) && TESTAFF(rv->astr, forbiddenword, rv->alen)) continue;
 3037: 
 3037:         // increment word number, if the second root has a compoundroot flag
 3037:         if ((rv) && (compoundroot) && 
 3037:             (TESTAFF(rv->astr, compoundroot, rv->alen))) {
 3037:                 wordnum++;
 3037:         }
 3037: 
 3037:         // first word is acceptable in compound words?
 3037:         if (((rv) && 
 3037:           ( checked_prefix || (words && words[wnum]) ||
 3037:             (compoundflag && TESTAFF(rv->astr, compoundflag, rv->alen)) ||
 3037:             ((oldwordnum == 0) && compoundbegin && TESTAFF(rv->astr, compoundbegin, rv->alen)) ||
 3037:             ((oldwordnum > 0) && compoundmiddle && TESTAFF(rv->astr, compoundmiddle, rv->alen)) 
 3037: // LANG_hu section: spec. Hungarian rule
 3037:             || ((langnum == LANG_hu) && // hu_mov_rule
 3037:                 hu_mov_rule && (
 3037:                     TESTAFF(rv->astr, 'F', rv->alen) ||
 3037:                     TESTAFF(rv->astr, 'G', rv->alen) ||
 3037:                     TESTAFF(rv->astr, 'H', rv->alen)
 3037:                 )
 3037:               )
 3037: // END of LANG_hu section
 3037:           )
21326:           && ! (( checkcompoundtriple && !words && // test triple letters
 3037:                    (word[i-1]==word[i]) && (
 3037:                       ((i>1) && (word[i-1]==word[i-2])) || 
 3037:                       ((word[i-1]==word[i+1])) // may be word[i+1] == '\0'
 3037:                    )
 3037:                ) ||
 3037:                (
 3037:                    // test CHECKCOMPOUNDPATTERN
21326:                    numcheckcpd && !words && cpdpat_check(word, i, rv, NULL)
 3037:                ) ||
 3037:                ( 
21326:                  checkcompoundcase && !words && cpdcase_check(word, i)
 3037:                ))
 3037:          )
 3037: // LANG_hu section: spec. Hungarian rule
 3037:          || ((!rv) && (langnum == LANG_hu) && hu_mov_rule && (rv = affix_check(st,i)) &&
43385:               (sfx && sfx->getCont() && (
43385:                         TESTAFF(sfx->getCont(), (unsigned short) 'x', sfx->getContLen()) ||
43385:                         TESTAFF(sfx->getCont(), (unsigned short) '%', sfx->getContLen())
 3037:                     )                
 3037:                )
 3037:              )
 3037: // END of LANG_hu section
 3037:          ) {
 3037: 
 3037: // LANG_hu section: spec. Hungarian rule
 3037:             if (langnum == LANG_hu) {
 3037:                 // calculate syllable number of the word
 3037:                 numsyllable += get_syllable(st, i);
 3037: 
 3037:                 // + 1 word, if syllable number of the prefix > 1 (hungarian convention)
43385:                 if (pfx && (get_syllable(pfx->getKey(),strlen(pfx->getKey())) > 1)) wordnum++;
 3037:             }
 3037: // END of LANG_hu section
 3037: 
 3037:             // NEXT WORD(S)
 3037:             rv_first = rv;
 3037:             rv = lookup((word+i)); // perhaps without prefix
 3037: 
 3037:         // search homonym with compound flag
21326:         while ((rv) && ((needaffix && TESTAFF(rv->astr, needaffix, rv->alen)) ||
 3037:                         !((compoundflag && !words && TESTAFF(rv->astr, compoundflag, rv->alen)) ||
 3037:                           (compoundend && !words && TESTAFF(rv->astr, compoundend, rv->alen)) ||
43385:                            (numdefcpd && words && defcpd_check(&words, wnum + 1, rv, NULL,1))))) {
 3037:             rv = rv->next_homonym;
 3037:         }
 3037: 
 3037:             if (rv && words && words[wnum + 1]) {
43385:                   mystrcat(*result, presult, MAXLNLEN);
43385:                   mystrcat(*result, " ", MAXLNLEN);
43385:                   mystrcat(*result, MORPH_PART, MAXLNLEN);
43385:                   mystrcat(*result, word+i, MAXLNLEN);
43385:                   if (complexprefixes && HENTRY_DATA(rv)) mystrcat(*result, HENTRY_DATA2(rv), MAXLNLEN);
21326:                   if (!HENTRY_FIND(rv, MORPH_STEM)) {
43385:                     mystrcat(*result, " ", MAXLNLEN);
43385:                     mystrcat(*result, MORPH_STEM, MAXLNLEN);
43385:                     mystrcat(*result, HENTRY_WORD(rv), MAXLNLEN);
21326:                   }
21326:                   // store the pointer of the hash entry
21326: //                  sprintf(*result + strlen(*result), " %s%p", MORPH_HENTRY, rv);
21326:                   if (!complexprefixes && HENTRY_DATA(rv)) {
43385:                     mystrcat(*result, " ", MAXLNLEN);
43385:                     mystrcat(*result, HENTRY_DATA2(rv), MAXLNLEN);
43385:                   }
43385:                   mystrcat(*result, "\n", MAXLNLEN);
 3037:                   ok = 1;
 3037:                   return 0;
 3037:             }
 3037: 
 3037:             oldnumsyllable2 = numsyllable;
 3037:             oldwordnum2 = wordnum;
 3037: 
 3037: // LANG_hu section: spec. Hungarian rule
 3037:             if ((rv) && (langnum == LANG_hu) && (TESTAFF(rv->astr, 'I', rv->alen)) && !(TESTAFF(rv->astr, 'J', rv->alen))) {
 3037:                 numsyllable--;
 3037:             }
 3037: // END of LANG_hu section
 3037:             // increment word number, if the second root has a compoundroot flag
 3037:             if ((rv) && (compoundroot) && 
 3037:                 (TESTAFF(rv->astr, compoundroot, rv->alen))) {
 3037:                     wordnum++;
 3037:             }
 3037: 
 3037:             // check forbiddenwords
 3037:             if ((rv) && (rv->astr) && TESTAFF(rv->astr, forbiddenword, rv->alen)) {
 3037:                 st[i] = ch;
 3037:                 continue;
 3037:             }
 3037: 
 3037:             // second word is acceptable, as a root?
 3037:             // hungarian conventions: compounding is acceptable,
 3037:             // when compound forms consist of 2 words, or if more,
 3037:             // then the syllable number of root words must be 6, or lesser.
 3037:             if ((rv) && (
 3037:                       (compoundflag && TESTAFF(rv->astr, compoundflag, rv->alen)) ||
 3037:                       (compoundend && TESTAFF(rv->astr, compoundend, rv->alen))
 3037:                     )
 3037:                 && (
 3037:                       ((cpdwordmax==-1) || (wordnum+1<cpdwordmax)) || 
21326:                       ((cpdmaxsyllable!=0) &&
21326:                           (numsyllable+get_syllable(HENTRY_WORD(rv),rv->blen)<=cpdmaxsyllable))
 3037:                     )
 3037:                 && (
 3037:                      (!checkcompounddup || (rv != rv_first))
 3037:                    )
 3037:                 )
 3037:                  {
 3037:                       // bad compound word
43385:                       mystrcat(*result, presult, MAXLNLEN);
43385:                       mystrcat(*result, " ", MAXLNLEN);
43385:                       mystrcat(*result, MORPH_PART, MAXLNLEN);
43385:                       mystrcat(*result, word+i, MAXLNLEN);
21326: 
21326:                       if (HENTRY_DATA(rv)) {
43385:                         if (complexprefixes) mystrcat(*result, HENTRY_DATA2(rv), MAXLNLEN);
21326:                         if (! HENTRY_FIND(rv, MORPH_STEM)) {
43385:                            mystrcat(*result, " ", MAXLNLEN);
43385:                            mystrcat(*result, MORPH_STEM, MAXLNLEN);
43385:                            mystrcat(*result, HENTRY_WORD(rv), MAXLNLEN);
21326:                         }
21326:                         // store the pointer of the hash entry
21326: //                        sprintf(*result + strlen(*result), " %s%p", MORPH_HENTRY, rv);
21326:                         if (!complexprefixes) {
43385:                             mystrcat(*result, " ", MAXLNLEN);
43385:                             mystrcat(*result, HENTRY_DATA2(rv), MAXLNLEN);
43385:                         }
43385:                       }
43385:                       mystrcat(*result, "\n", MAXLNLEN);
 3037:                               ok = 1;
 3037:             }
 3037: 
 3037:             numsyllable = oldnumsyllable2 ;
 3037:             wordnum = oldwordnum2;
 3037: 
 3037:             // perhaps second word has prefix or/and suffix
 3037:             sfx = NULL;
 3037:             sfxflag = FLAG_NULL;
 3037: 
 3037:             if (compoundflag) rv = affix_check((word+i),strlen(word+i), compoundflag); else rv = NULL;
 3037: 
 3037:             if (!rv && compoundend) {
 3037:                 sfx = NULL;
 3037:                 pfx = NULL;
 3037:                 rv = affix_check((word+i),strlen(word+i), compoundend);
 3037:             }
 3037: 
 3037:             if (!rv && numdefcpd && words) {
 3037:                 rv = affix_check((word+i),strlen(word+i), 0, IN_CPD_END);
 3037:                 if (rv && words && defcpd_check(&words, wnum + 1, rv, NULL, 1)) {
 3037:                       char * m = NULL;
 3037:                       if (compoundflag) m = affix_check_morph((word+i),strlen(word+i), compoundflag);
21326:                       if ((!m || *m == '\0') && compoundend) {
21326:                             if (m) free(m);
 3037:                             m = affix_check_morph((word+i),strlen(word+i), compoundend);
21326:                       }
43385:                       mystrcat(*result, presult, MAXLNLEN);
21326:                       if (m || (*m != '\0')) {
21326:                         sprintf(*result + strlen(*result), "%c%s%s%s", MSEP_FLD,
21326:                             MORPH_PART, word + i, line_uniq_app(&m, MSEP_REC));
21326:                       }
21326:                       if (m) free(m);
43385:                       mystrcat(*result, "\n", MAXLNLEN);
 3037:                       ok = 1;
 3037:                 }
 3037:             }
 3037: 
 3037:             // check non_compound flag in suffix and prefix
 3037:             if ((rv) && 
43385:                 ((pfx && pfx->getCont() &&
43385:                     TESTAFF(pfx->getCont(), compoundforbidflag, 
43385:                         pfx->getContLen())) ||
43385:                 (sfx && sfx->getCont() &&
43385:                     TESTAFF(sfx->getCont(), compoundforbidflag, 
43385:                         sfx->getContLen())))) {
 3037:                     rv = NULL;
 3037:             }
 3037: 
 3037:             // check forbiddenwords
 3037:             if ((rv) && (rv->astr) && (TESTAFF(rv->astr,forbiddenword,rv->alen))
21326:                     && (! TESTAFF(rv->astr, needaffix, rv->alen))) {
 3037:                         st[i] = ch;
 3037:                         continue;
 3037:                     }
 3037: 
 3037:             if (langnum == LANG_hu) {
 3037:                 // calculate syllable number of the word
 3037:                 numsyllable += get_syllable(word + i, strlen(word + i));
 3037: 
 3037:                 // - affix syllable num.
 3037:                 // XXX only second suffix (inflections, not derivations)
 3037:                 if (sfxappnd) {
 3037:                     char * tmp = myrevstrdup(sfxappnd);
 3037:                     numsyllable -= get_syllable(tmp, strlen(tmp));
 3037:                     free(tmp);
 3037:                 }
 3037: 
 3037:                 // + 1 word, if syllable number of the prefix > 1 (hungarian convention)
43385:                 if (pfx && (get_syllable(pfx->getKey(),strlen(pfx->getKey())) > 1)) wordnum++;
 3037: 
 3037:                 // increment syllable num, if last word has a SYLLABLENUM flag
 3037:                 // and the suffix is beginning `s'
 3037: 
 3037:                 if (cpdsyllablenum) {
 3037:                     switch (sfxflag) {
 3037:                         case 'c': { numsyllable+=2; break; }
 3037:                         case 'J': { numsyllable += 1; break; }
 3037:                         case 'I': { if (rv && TESTAFF(rv->astr, 'J', rv->alen)) numsyllable += 1; break; }
 3037:                     }
 3037:                 }
 3037:             }
 3037: 
 3037:             // increment word number, if the second word has a compoundroot flag
 3037:             if ((rv) && (compoundroot) && 
 3037:                 (TESTAFF(rv->astr, compoundroot, rv->alen))) {
 3037:                     wordnum++;
 3037:             }
 3037:             // second word is acceptable, as a word with prefix or/and suffix?
 3037:             // hungarian conventions: compounding is acceptable,
 3037:             // when compound forms consist 2 word, otherwise
 3037:             // the syllable number of root words is 6, or lesser.
 3037:             if ((rv) && 
 3037:                     (
 3037:                       ((cpdwordmax==-1) || (wordnum+1<cpdwordmax)) || 
21326:                       ((cpdmaxsyllable!=0) &&
 3037:                           (numsyllable <= cpdmaxsyllable))
 3037:                     )
 3037:                 && (
 3037:                    (!checkcompounddup || (rv != rv_first))
 3037:                    )) {
 3037:                       char * m = NULL;
 3037:                       if (compoundflag) m = affix_check_morph((word+i),strlen(word+i), compoundflag);
21326:                       if ((!m || *m == '\0') && compoundend) {
21326:                             if (m) free(m);
 3037:                             m = affix_check_morph((word+i),strlen(word+i), compoundend);
21326:                       }
43385:                       mystrcat(*result, presult, MAXLNLEN);
21326:                       if (m && (*m != '\0')) {
21326:                         sprintf(*result + strlen(*result), "%c%s%s%s", MSEP_FLD,
21326:                             MORPH_PART, word + i, line_uniq_app(&m, MSEP_REC));
21326:                       }
21326:                       if (m) free(m);
21326:                       sprintf(*result + strlen(*result), "%c", MSEP_REC);
 3037:                       ok = 1;
 3037:             }
 3037: 
 3037:             numsyllable = oldnumsyllable2;
 3037:             wordnum = oldwordnum2;
 3037: 
 3037:             // perhaps second word is a compound word (recursive call)
 3037:             if ((wordnum < maxwordnum) && (ok == 0)) {
 3037:                         compound_check_morph((word+i),strlen(word+i), wordnum+1, 
 3037:                              numsyllable, maxwordnum, wnum + 1, words, 0, result, presult);
 3037:             } else {
 3037:                 rv=NULL;
 3037:             }
 3037:         }
 3037:         st[i] = ch;
 3037:         wordnum = oldwordnum;
 3037:         numsyllable = oldnumsyllable;
 3037:     }
 3037:     return 0;
 3037: }    
 3037: 
 3037:  // return 1 if s1 (reversed) is a leading subset of end of s2
 3037: /* inline int AffixMgr::isRevSubset(const char * s1, const char * end_of_s2, int len)
 3037:  {
 3037:     while ((len > 0) && *s1 && (*s1 == *end_of_s2)) {
 3037:         s1++;
 3037:         end_of_s2--;
 3037:         len--;
 3037:     }
 3037:     return (*s1 == '\0');
 3037:  }
 3037:  */
 3037: 
 3037: inline int AffixMgr::isRevSubset(const char * s1, const char * end_of_s2, int len)
 3037:  {
 3037:     while ((len > 0) && (*s1 != '\0') && ((*s1 == *end_of_s2) || (*s1 == '.'))) {
 3037:         s1++;
 3037:         end_of_s2--;
 3037:         len--;
 3037:     }
 3037:     return (*s1 == '\0');
 3037:  }
 3037: 
 3037: // check word for suffixes
 3037: 
 3037: struct hentry * AffixMgr::suffix_check (const char * word, int len, 
43385:        int sfxopts, PfxEntry * ppfx, char ** wlst, int maxSug, int * ns, 
 3037:        const FLAG cclass, const FLAG needflag, char in_compound)
 3037: {
 3037:     struct hentry * rv = NULL;
43385:     PfxEntry* ep = ppfx;
 3037: 
 3037:     // first handle the special case of 0 length suffixes
43385:     SfxEntry * se = sStart[0];
 3037: 
 3037:     while (se) {
 3037:         if (!cclass || se->getCont()) {
 3037:             // suffixes are not allowed in beginning of compounds
 3037:             if ((((in_compound != IN_CPD_BEGIN)) || // && !cclass
 3037:              // except when signed with compoundpermitflag flag
 3037:              (se->getCont() && compoundpermitflag &&
 3037:                 TESTAFF(se->getCont(),compoundpermitflag,se->getContLen()))) && (!circumfix ||
 3037:               // no circumfix flag in prefix and suffix
 3037:               ((!ppfx || !(ep->getCont()) || !TESTAFF(ep->getCont(),
 3037:                    circumfix, ep->getContLen())) &&
 3037:                (!se->getCont() || !(TESTAFF(se->getCont(),circumfix,se->getContLen())))) ||
 3037:               // circumfix flag in prefix AND suffix
 3037:               ((ppfx && (ep->getCont()) && TESTAFF(ep->getCont(),
 3037:                    circumfix, ep->getContLen())) &&
 3037:                (se->getCont() && (TESTAFF(se->getCont(),circumfix,se->getContLen())))))  &&
 3037:             // fogemorpheme
 3037:               (in_compound || 
 3037:                  !((se->getCont() && (TESTAFF(se->getCont(), onlyincompound, se->getContLen()))))) &&
21326:             // needaffix on prefix or first suffix
 3037:               (cclass || 
21326:                    !(se->getCont() && TESTAFF(se->getCont(), needaffix, se->getContLen())) ||
 3037:                    (ppfx && !((ep->getCont()) &&
21326:                      TESTAFF(ep->getCont(), needaffix,
 3037:                        ep->getContLen())))
 3037:               )
 3037:             ) {
 3037:                 rv = se->checkword(word,len, sfxopts, ppfx, wlst, maxSug, ns, (FLAG) cclass, 
 3037:                     needflag, (in_compound ? 0 : onlyincompound));
 3037:                 if (rv) {
43385:                     sfx=se; // BUG: sfx not stateless
 3037:                     return rv;
 3037:                 }
 3037:             }
 3037:         }
 3037:        se = se->getNext();
 3037:     }
 3037: 
 3037:     // now handle the general case
61791:     if (len == 0) return NULL; // FULLSTRIP
 3037:     unsigned char sp = *((const unsigned char *)(word + len - 1));
43385:     SfxEntry * sptr = sStart[sp];
 3037: 
 3037:     while (sptr) {
 3037:         if (isRevSubset(sptr->getKey(), word + len - 1, len)
 3037:         ) {
 3037:             // suffixes are not allowed in beginning of compounds
 3037:             if ((((in_compound != IN_CPD_BEGIN)) || // && !cclass
 3037:              // except when signed with compoundpermitflag flag
 3037:              (sptr->getCont() && compoundpermitflag &&
 3037:                 TESTAFF(sptr->getCont(),compoundpermitflag,sptr->getContLen()))) && (!circumfix ||
 3037:               // no circumfix flag in prefix and suffix
 3037:               ((!ppfx || !(ep->getCont()) || !TESTAFF(ep->getCont(),
 3037:                    circumfix, ep->getContLen())) &&
 3037:                (!sptr->getCont() || !(TESTAFF(sptr->getCont(),circumfix,sptr->getContLen())))) ||
 3037:               // circumfix flag in prefix AND suffix
 3037:               ((ppfx && (ep->getCont()) && TESTAFF(ep->getCont(),
 3037:                    circumfix, ep->getContLen())) &&
 3037:                (sptr->getCont() && (TESTAFF(sptr->getCont(),circumfix,sptr->getContLen())))))  &&
 3037:             // fogemorpheme
 3037:               (in_compound || 
 3037:                  !((sptr->getCont() && (TESTAFF(sptr->getCont(), onlyincompound, sptr->getContLen()))))) &&
21326:             // needaffix on prefix or first suffix
 3037:               (cclass || 
21326:                   !(sptr->getCont() && TESTAFF(sptr->getCont(), needaffix, sptr->getContLen())) ||
 3037:                   (ppfx && !((ep->getCont()) &&
21326:                      TESTAFF(ep->getCont(), needaffix,
 3037:                        ep->getContLen())))
 3037:               )
 3037:             ) {
 3037:                 rv = sptr->checkword(word,len, sfxopts, ppfx, wlst,
 3037:                     maxSug, ns, cclass, needflag, (in_compound ? 0 : onlyincompound));
 3037:                 if (rv) {
43385:                     sfx=sptr; // BUG: sfx not stateless
 3037:                     sfxflag = sptr->getFlag(); // BUG: sfxflag not stateless
 3037:                     if (!sptr->getCont()) sfxappnd=sptr->getKey(); // BUG: sfxappnd not stateless
 3037:                     return rv;
 3037:                 }
 3037:              }
 3037:              sptr = sptr->getNextEQ();
 3037:         } else {
 3037:              sptr = sptr->getNextNE();
 3037:         }
 3037:     }
 3037: 
 3037:     return NULL;
 3037: }
 3037: 
 3037: // check word for two-level suffixes
 3037: 
 3037: struct hentry * AffixMgr::suffix_check_twosfx(const char * word, int len, 
43385:        int sfxopts, PfxEntry * ppfx, const FLAG needflag)
 3037: {
 3037:     struct hentry * rv = NULL;
 3037: 
 3037:     // first handle the special case of 0 length suffixes
43385:     SfxEntry * se = sStart[0];
 3037:     while (se) {
 3037:         if (contclasses[se->getFlag()])
 3037:         {
 3037:             rv = se->check_twosfx(word,len, sfxopts, ppfx, needflag);
 3037:             if (rv) return rv;
 3037:         }
 3037:         se = se->getNext();
 3037:     }
 3037: 
 3037:     // now handle the general case
61791:     if (len == 0) return NULL; // FULLSTRIP
 3037:     unsigned char sp = *((const unsigned char *)(word + len - 1));
43385:     SfxEntry * sptr = sStart[sp];
 3037: 
 3037:     while (sptr) {
 3037:         if (isRevSubset(sptr->getKey(), word + len - 1, len)) {
 3037:             if (contclasses[sptr->getFlag()])
 3037:             {
 3037:                 rv = sptr->check_twosfx(word,len, sfxopts, ppfx, needflag);
 3037:                 if (rv) {
 3037:                     sfxflag = sptr->getFlag(); // BUG: sfxflag not stateless
 3037:                     if (!sptr->getCont()) sfxappnd=sptr->getKey(); // BUG: sfxappnd not stateless
 3037:                     return rv;
 3037:                 }
 3037:             }
 3037:             sptr = sptr->getNextEQ();
 3037:         } else {
 3037:              sptr = sptr->getNextNE();
 3037:         }
 3037:     }
 3037: 
 3037:     return NULL;
 3037: }
 3037: 
 3037: char * AffixMgr::suffix_check_twosfx_morph(const char * word, int len, 
43385:        int sfxopts, PfxEntry * ppfx, const FLAG needflag)
 3037: {
 3037:     char result[MAXLNLEN];
 3037:     char result2[MAXLNLEN];
 3037:     char result3[MAXLNLEN];
 3037:     
 3037:     char * st;
 3037: 
 3037:     result[0] = '\0';
 3037:     result2[0] = '\0';
 3037:     result3[0] = '\0';
 3037: 
 3037:     // first handle the special case of 0 length suffixes
43385:     SfxEntry * se = sStart[0];
 3037:     while (se) {
 3037:         if (contclasses[se->getFlag()])
 3037:         {
 3037:             st = se->check_twosfx_morph(word,len, sfxopts, ppfx, needflag);
 3037:             if (st) {
 3037:                 if (ppfx) {
43385:                     if (ppfx->getMorph()) {
43385:                         mystrcat(result, ppfx->getMorph(), MAXLNLEN);
21326:                         mystrcat(result, " ", MAXLNLEN);
43385:                     } else debugflag(result, ppfx->getFlag());
21326:                 }
21326:                 mystrcat(result, st, MAXLNLEN);
 3037:                 free(st);
21326:                 if (se->getMorph()) {
21326:                     mystrcat(result, " ", MAXLNLEN);
21326:                     mystrcat(result, se->getMorph(), MAXLNLEN);
21326:                 } else debugflag(result, se->getFlag());
21326:                 mystrcat(result, "\n", MAXLNLEN);
 3037:             }
 3037:         }
 3037:         se = se->getNext();
 3037:     }
 3037: 
 3037:     // now handle the general case
61791:     if (len == 0) return NULL; // FULLSTRIP
 3037:     unsigned char sp = *((const unsigned char *)(word + len - 1));
43385:     SfxEntry * sptr = sStart[sp];
 3037: 
 3037:     while (sptr) {
 3037:         if (isRevSubset(sptr->getKey(), word + len - 1, len)) {
 3037:             if (contclasses[sptr->getFlag()]) 
 3037:             {
 3037:                 st = sptr->check_twosfx_morph(word,len, sfxopts, ppfx, needflag);
 3037:                 if (st) {
 3037:                     sfxflag = sptr->getFlag(); // BUG: sfxflag not stateless
 3037:                     if (!sptr->getCont()) sfxappnd=sptr->getKey(); // BUG: sfxappnd not stateless
 3037:                     strcpy(result2, st);
 3037:                     free(st);
 3037: 
 3037:                 result3[0] = '\0';
21326: 
21326:                 if (sptr->getMorph()) {
21326:                     mystrcat(result3, " ", MAXLNLEN);
21326:                     mystrcat(result3, sptr->getMorph(), MAXLNLEN);
21326:                 } else debugflag(result3, sptr->getFlag());
 3037:                 strlinecat(result2, result3);
21326:                 mystrcat(result2, "\n", MAXLNLEN);
21326:                 mystrcat(result,  result2, MAXLNLEN);
 3037:                 }
 3037:             }
 3037:             sptr = sptr->getNextEQ();
 3037:         } else {
 3037:              sptr = sptr->getNextNE();
 3037:         }
 3037:     }
21326:     if (*result) return mystrdup(result);
 3037:     return NULL;
 3037: }
 3037: 
 3037: char * AffixMgr::suffix_check_morph(const char * word, int len, 
43385:        int sfxopts, PfxEntry * ppfx, const FLAG cclass, const FLAG needflag, char in_compound)
 3037: {
 3037:     char result[MAXLNLEN];
 3037:     
 3037:     struct hentry * rv = NULL;
 3037: 
 3037:     result[0] = '\0';
 3037: 
43385:     PfxEntry* ep = ppfx;
 3037: 
 3037:     // first handle the special case of 0 length suffixes
43385:     SfxEntry * se = sStart[0];
 3037:     while (se) {
 3037:         if (!cclass || se->getCont()) {
 3037:             // suffixes are not allowed in beginning of compounds
 3037:             if (((((in_compound != IN_CPD_BEGIN)) || // && !cclass
 3037:              // except when signed with compoundpermitflag flag
 3037:              (se->getCont() && compoundpermitflag &&
 3037:                 TESTAFF(se->getCont(),compoundpermitflag,se->getContLen()))) && (!circumfix ||
 3037:               // no circumfix flag in prefix and suffix
 3037:               ((!ppfx || !(ep->getCont()) || !TESTAFF(ep->getCont(),
 3037:                    circumfix, ep->getContLen())) &&
 3037:                (!se->getCont() || !(TESTAFF(se->getCont(),circumfix,se->getContLen())))) ||
 3037:               // circumfix flag in prefix AND suffix
 3037:               ((ppfx && (ep->getCont()) && TESTAFF(ep->getCont(),
 3037:                    circumfix, ep->getContLen())) &&
 3037:                (se->getCont() && (TESTAFF(se->getCont(),circumfix,se->getContLen())))))  &&
 3037:             // fogemorpheme
 3037:               (in_compound || 
 3037:                  !((se->getCont() && (TESTAFF(se->getCont(), onlyincompound, se->getContLen()))))) &&
21326:             // needaffix on prefix or first suffix
 3037:               (cclass || 
21326:                    !(se->getCont() && TESTAFF(se->getCont(), needaffix, se->getContLen())) ||
 3037:                    (ppfx && !((ep->getCont()) &&
21326:                      TESTAFF(ep->getCont(), needaffix,
 3037:                        ep->getContLen())))
 3037:               )
 3037:             ))
 3037:             rv = se->checkword(word, len, sfxopts, ppfx, NULL, 0, 0, cclass, needflag);
 3037:          while (rv) {
 3037:            if (ppfx) {
43385:                 if (ppfx->getMorph()) {
43385:                     mystrcat(result, ppfx->getMorph(), MAXLNLEN);
21326:                     mystrcat(result, " ", MAXLNLEN);
43385:                 } else debugflag(result, ppfx->getFlag());
21326:             }
21326:             if (complexprefixes && HENTRY_DATA(rv)) mystrcat(result, HENTRY_DATA2(rv), MAXLNLEN);
21326:             if (! HENTRY_FIND(rv, MORPH_STEM)) {
21326:                 mystrcat(result, " ", MAXLNLEN);                                
21326:                 mystrcat(result, MORPH_STEM, MAXLNLEN);
21326:                 mystrcat(result, HENTRY_WORD(rv), MAXLNLEN);
21326:             }
21326:             // store the pointer of the hash entry
21326: //            sprintf(result + strlen(result), " %s%p", MORPH_HENTRY, rv);
21326:             
21326:             if (!complexprefixes && HENTRY_DATA(rv)) {
21326:                     mystrcat(result, " ", MAXLNLEN);                                
21326:                     mystrcat(result, HENTRY_DATA2(rv), MAXLNLEN);
21326:             }
21326:             if (se->getMorph()) {
21326:                 mystrcat(result, " ", MAXLNLEN);                                
21326:                 mystrcat(result, se->getMorph(), MAXLNLEN);
21326:             } else debugflag(result, se->getFlag());
21326:             mystrcat(result, "\n", MAXLNLEN);
 3037:             rv = se->get_next_homonym(rv, sfxopts, ppfx, cclass, needflag);
 3037:          }
 3037:        }
 3037:        se = se->getNext();
 3037:     }
 3037: 
 3037:     // now handle the general case
61791:     if (len == 0) return NULL; // FULLSTRIP
 3037:     unsigned char sp = *((const unsigned char *)(word + len - 1));
43385:     SfxEntry * sptr = sStart[sp];
 3037: 
 3037:     while (sptr) {
 3037:         if (isRevSubset(sptr->getKey(), word + len - 1, len)
 3037:         ) {
 3037:             // suffixes are not allowed in beginning of compounds
 3037:             if (((((in_compound != IN_CPD_BEGIN)) || // && !cclass
 3037:              // except when signed with compoundpermitflag flag
 3037:              (sptr->getCont() && compoundpermitflag &&
 3037:                 TESTAFF(sptr->getCont(),compoundpermitflag,sptr->getContLen()))) && (!circumfix ||
 3037:               // no circumfix flag in prefix and suffix
 3037:               ((!ppfx || !(ep->getCont()) || !TESTAFF(ep->getCont(),
 3037:                    circumfix, ep->getContLen())) &&
 3037:                (!sptr->getCont() || !(TESTAFF(sptr->getCont(),circumfix,sptr->getContLen())))) ||
 3037:               // circumfix flag in prefix AND suffix
 3037:               ((ppfx && (ep->getCont()) && TESTAFF(ep->getCont(),
 3037:                    circumfix, ep->getContLen())) &&
 3037:                (sptr->getCont() && (TESTAFF(sptr->getCont(),circumfix,sptr->getContLen())))))  &&
 3037:             // fogemorpheme
 3037:               (in_compound || 
 3037:                  !((sptr->getCont() && (TESTAFF(sptr->getCont(), onlyincompound, sptr->getContLen()))))) &&
21326:             // needaffix on first suffix
 3037:               (cclass || !(sptr->getCont() && 
21326:                    TESTAFF(sptr->getCont(), needaffix, sptr->getContLen())))
 3037:             )) rv = sptr->checkword(word,len, sfxopts, ppfx, NULL, 0, 0, cclass, needflag);
 3037:             while (rv) {
 3037:                     if (ppfx) {
43385:                         if (ppfx->getMorph()) {
43385:                             mystrcat(result, ppfx->getMorph(), MAXLNLEN);
21326:                             mystrcat(result, " ", MAXLNLEN);
43385:                         } else debugflag(result, ppfx->getFlag());
21326:                     }    
21326:                     if (complexprefixes && HENTRY_DATA(rv)) mystrcat(result, HENTRY_DATA2(rv), MAXLNLEN);
21326:                     if (! HENTRY_FIND(rv, MORPH_STEM)) {
21326:                             mystrcat(result, " ", MAXLNLEN);                                
21326:                             mystrcat(result, MORPH_STEM, MAXLNLEN);
21326:                             mystrcat(result, HENTRY_WORD(rv), MAXLNLEN);
21326:                     }
21326:                     // store the pointer of the hash entry
21326: //                    sprintf(result + strlen(result), " %s%p", MORPH_HENTRY, rv);
21326: 
21326:                     if (!complexprefixes && HENTRY_DATA(rv)) {
21326:                         mystrcat(result, " ", MAXLNLEN);                                
21326:                         mystrcat(result, HENTRY_DATA2(rv), MAXLNLEN);
21326:                     }
21326: 
21326:                 if (sptr->getMorph()) {
21326:                     mystrcat(result, " ", MAXLNLEN);
21326:                     mystrcat(result, sptr->getMorph(), MAXLNLEN);
21326:                 } else debugflag(result, sptr->getFlag());
21326:                 mystrcat(result, "\n", MAXLNLEN);
 3037:                 rv = sptr->get_next_homonym(rv, sfxopts, ppfx, cclass, needflag);
 3037:             }
 3037:              sptr = sptr->getNextEQ();
 3037:         } else {
 3037:              sptr = sptr->getNextNE();
 3037:         }
 3037:     }
 3037: 
 3037:     if (*result) return mystrdup(result);
 3037:     return NULL;
 3037: }
 3037: 
 3037: // check if word with affixes is correctly spelled
 3037: struct hentry * AffixMgr::affix_check (const char * word, int len, const FLAG needflag, char in_compound)
 3037: {
 3037:     struct hentry * rv= NULL;
 3037: 
 3037:     // check all prefixes (also crossed with suffixes if allowed) 
 3037:     rv = prefix_check(word, len, in_compound, needflag);
 3037:     if (rv) return rv;
 3037: 
 3037:     // if still not found check all suffixes
 3037:     rv = suffix_check(word, len, 0, NULL, NULL, 0, NULL, FLAG_NULL, needflag, in_compound);
 3037: 
 3037:     if (havecontclass) {
 3037:         sfx = NULL;
 3037:         pfx = NULL;
 3037:         if (rv) return rv;
 3037:         // if still not found check all two-level suffixes
 3037:         rv = suffix_check_twosfx(word, len, 0, NULL, needflag);
 3037:         if (rv) return rv;
 3037:         // if still not found check all two-level suffixes
 3037:         rv = prefix_check_twosfx(word, len, IN_CPD_NOT, needflag);
 3037:     }
 3037:     return rv;
 3037: }
 3037: 
 3037: // check if word with affixes is correctly spelled
 3037: char * AffixMgr::affix_check_morph(const char * word, int len, const FLAG needflag, char in_compound)
 3037: {
 3037:     char result[MAXLNLEN];
 3037:     char * st = NULL;
 3037: 
 3037:     *result = '\0';
 3037:     
 3037:     // check all prefixes (also crossed with suffixes if allowed) 
 3037:     st = prefix_check_morph(word, len, in_compound);
 3037:     if (st) {
21326:         mystrcat(result, st, MAXLNLEN);
 3037:         free(st);
 3037:     }
 3037: 
 3037:     // if still not found check all suffixes    
 3037:     st = suffix_check_morph(word, len, 0, NULL, '\0', needflag, in_compound);
 3037:     if (st) {
21326:         mystrcat(result, st, MAXLNLEN);
 3037:         free(st);
 3037:     }
 3037: 
 3037:     if (havecontclass) {
 3037:         sfx = NULL;
 3037:         pfx = NULL;
 3037:         // if still not found check all two-level suffixes
 3037:         st = suffix_check_twosfx_morph(word, len, 0, NULL, needflag);
 3037:         if (st) {
21326:             mystrcat(result, st, MAXLNLEN);
 3037:             free(st);
 3037:         }
 3037: 
 3037:         // if still not found check all two-level suffixes
 3037:         st = prefix_check_twosfx_morph(word, len, IN_CPD_NOT, needflag);
 3037:         if (st) {
21326:             mystrcat(result, st, MAXLNLEN);
 3037:             free(st);
 3037:         }
 3037:     }
 3037: 
 3037:     return mystrdup(result);
 3037: }
21326: 
21326: char * AffixMgr::morphgen(char * ts, int wl, const unsigned short * ap,
21326:     unsigned short al, char * morph, char * targetmorph, int level)
21326: {
21326:     // handle suffixes
21326:     char * stemmorph;
21326:     char * stemmorphcatpos;
21326:     char mymorph[MAXLNLEN];
21326: 
43385:     if (!morph) return NULL;
21326: 
21326:     // check substandard flag
21326:     if (TESTAFF(ap, substandard, al)) return NULL;
21326: 
21326:     if (morphcmp(morph, targetmorph) == 0) return mystrdup(ts);
21326: 
21326: //    int targetcount = get_sfxcount(targetmorph);
21326: 
21326:     // use input suffix fields, if exist
21326:     if (strstr(morph, MORPH_INFL_SFX) || strstr(morph, MORPH_DERI_SFX)) {
21326:         stemmorph = mymorph;
21326:         strcpy(stemmorph, morph);
43385:         mystrcat(stemmorph, " ", MAXLNLEN);
21326:         stemmorphcatpos = stemmorph + strlen(stemmorph);
21326:     } else {
21326:         stemmorph = morph;
21326:         stemmorphcatpos = NULL;
21326:     }
21326: 
21326:     for (int i = 0; i < al; i++) {
21326:         const unsigned char c = (unsigned char) (ap[i] & 0x00FF);
43385:         SfxEntry * sptr = sFlag[c];
21326:         while (sptr) {
21326:             if (sptr->getFlag() == ap[i] && sptr->getMorph() && ((sptr->getContLen() == 0) || 
21326:                 // don't generate forms with substandard affixes
21326:                 !TESTAFF(sptr->getCont(), substandard, sptr->getContLen()))) {
21326: 
21326:                 if (stemmorphcatpos) strcpy(stemmorphcatpos, sptr->getMorph());
21326:                 else stemmorph = (char *) sptr->getMorph();
21326: 
21326:                 int cmp = morphcmp(stemmorph, targetmorph);
21326: 
21326:                 if (cmp == 0) {
21326:                     char * newword = sptr->add(ts, wl);
21326:                     if (newword) {
21326:                         hentry * check = pHMgr->lookup(newword); // XXX extra dic
21326:                         if (!check || !check->astr || 
21326:                             !TESTAFF(check->astr, forbiddenword, check->alen)) {
21326:                                 return newword;
21326:                         }
21326:                         free(newword);
21326:                     }
21326:                 }
21326:                 
21326:                 // recursive call for secondary suffixes
21326:                 if ((level == 0) && (cmp == 1) && (sptr->getContLen() > 0) &&
21326: //                    (get_sfxcount(stemmorph) < targetcount) &&
21326:                     !TESTAFF(sptr->getCont(), substandard, sptr->getContLen())) {
21326:                     char * newword = sptr->add(ts, wl);
21326:                     if (newword) {
21326:                         char * newword2 = morphgen(newword, strlen(newword), sptr->getCont(),
21326:                             sptr->getContLen(), stemmorph, targetmorph, 1);
21326: 
21326:                         if (newword2) {
21326:                             free(newword);
21326:                             return newword2;
21326:                         }
21326:                         free(newword);
21326:                         newword = NULL;
21326:                     }
21326:                 }
21326:             }
43385:             sptr = sptr->getFlgNxt();
21326:         }
21326:     }
21326:    return NULL;
21326: }
 3037: 
 3037: 
 3037: int AffixMgr::expand_rootword(struct guessword * wlst, int maxn, const char * ts,
 5768:     int wl, const unsigned short * ap, unsigned short al, char * bad, int badl,
21326:     char * phon)
 3037: {
 3037:     int nh=0;
 3037:     // first add root word to list
21326:     if ((nh < maxn) && !(al && ((needaffix && TESTAFF(ap, needaffix, al)) ||
 3037:          (onlyincompound && TESTAFF(ap, onlyincompound, al))))) {
 3037:        wlst[nh].word = mystrdup(ts);
21326:        if (!wlst[nh].word) return 0;
 3037:        wlst[nh].allow = (1 == 0);
 5768:        wlst[nh].orig = NULL;
 3037:        nh++;
 5768:        // add special phonetic version
21326:        if (phon && (nh < maxn)) {
21326:     	    wlst[nh].word = mystrdup(phon);
21326:             if (!wlst[nh].word) return nh - 1;
 5768:     	    wlst[nh].allow = (1 == 0);
 5768:     	    wlst[nh].orig = mystrdup(ts);
21326:             if (!wlst[nh].orig) return nh - 1;
 5768:     	    nh++;
 5768:        }
 3037:     }
 3037: 
 3037:     // handle suffixes
 3037:     for (int i = 0; i < al; i++) {
 5768:        const unsigned char c = (unsigned char) (ap[i] & 0x00FF);
43385:        SfxEntry * sptr = sFlag[c];
 3037:        while (sptr) {
 5768:          if ((sptr->getFlag() == ap[i]) && (!sptr->getKeyLen() || ((badl > sptr->getKeyLen()) &&
 5768:                 (strcmp(sptr->getAffix(), bad + badl - sptr->getKeyLen()) == 0))) &&
21326:                 // check needaffix flag
21326:                 !(sptr->getCont() && ((needaffix && 
21326:                       TESTAFF(sptr->getCont(), needaffix, sptr->getContLen())) ||
 3037:                   (circumfix && 
 3037:                       TESTAFF(sptr->getCont(), circumfix, sptr->getContLen())) ||
 3037:                   (onlyincompound && 
 3037:                       TESTAFF(sptr->getCont(), onlyincompound, sptr->getContLen()))))
 3037:                 ) {
 3037:             char * newword = sptr->add(ts, wl);
 3037:             if (newword) {
 3037:                 if (nh < maxn) {
 3037:                     wlst[nh].word = newword;
 3037:                     wlst[nh].allow = sptr->allowCross();
 5768:                     wlst[nh].orig = NULL;
 3037:                     nh++;
 5768:                     // add special phonetic version
21326:     		    if (phon && (nh < maxn)) {
 5768:     			char st[MAXWORDUTF8LEN];
21326:     			strcpy(st, phon);
 5768:     			strcat(st, sptr->getKey());
21326:     			reverseword(st + strlen(phon));
 5768:     			wlst[nh].word = mystrdup(st);
21326:     			if (!wlst[nh].word) return nh - 1;
 5768:     			wlst[nh].allow = (1 == 0);
 5768:     			wlst[nh].orig = mystrdup(newword);
21326:                         if (!wlst[nh].orig) return nh - 1;
 5768:     			nh++;
 5768:     		    }
 3037:                 } else {
 3037:                     free(newword);
 3037:                 }
 3037:             }
 3037:          }
43385:          sptr = sptr->getFlgNxt();
 3037:        }
 3037:     }
 3037: 
 3037:     int n = nh;
 3037: 
 3037:     // handle cross products of prefixes and suffixes
 3037:     for (int j=1;j<n ;j++)
 3037:        if (wlst[j].allow) {
 3037:           for (int k = 0; k < al; k++) {
 5768:              const unsigned char c = (unsigned char) (ap[k] & 0x00FF);
43385:              PfxEntry * cptr = pFlag[c];
 3037:              while (cptr) {
 5768:                 if ((cptr->getFlag() == ap[k]) && cptr->allowCross() && (!cptr->getKeyLen() || ((badl > cptr->getKeyLen()) &&
 3037:                         (strncmp(cptr->getKey(), bad, cptr->getKeyLen()) == 0)))) {
 3037:                     int l1 = strlen(wlst[j].word);
 3037:                     char * newword = cptr->add(wlst[j].word, l1);
 3037:                     if (newword) {
 3037:                        if (nh < maxn) {
 3037:                           wlst[nh].word = newword;
 3037:                           wlst[nh].allow = cptr->allowCross();
 5768:                           wlst[nh].orig = NULL;
 3037:                           nh++;
 3037:                        } else {
 3037:                           free(newword);
 3037:                        }
 3037:                     }
 3037:                 }
43385:                 cptr = cptr->getFlgNxt();
 3037:              }
 3037:           }
 3037:        }
 3037: 
 3037: 
 3037:     // now handle pure prefixes
 3037:     for (int m = 0; m < al; m ++) {
 5768:        const unsigned char c = (unsigned char) (ap[m] & 0x00FF);
43385:        PfxEntry * ptr = pFlag[c];
 3037:        while (ptr) {
 5768:          if ((ptr->getFlag() == ap[m]) && (!ptr->getKeyLen() || ((badl > ptr->getKeyLen()) &&
 5768:                 (strncmp(ptr->getKey(), bad, ptr->getKeyLen()) == 0))) &&
21326:                 // check needaffix flag
21326:                 !(ptr->getCont() && ((needaffix && 
21326:                       TESTAFF(ptr->getCont(), needaffix, ptr->getContLen())) ||
 3037:                      (circumfix && 
 3037:                       TESTAFF(ptr->getCont(), circumfix, ptr->getContLen())) ||                      
 3037:                   (onlyincompound && 
 3037:                       TESTAFF(ptr->getCont(), onlyincompound, ptr->getContLen()))))
 3037:                 ) {
 3037:             char * newword = ptr->add(ts, wl);
 3037:             if (newword) {
 3037:                 if (nh < maxn) {
 3037:                     wlst[nh].word = newword;
 3037:                     wlst[nh].allow = ptr->allowCross();
 5768:                     wlst[nh].orig = NULL;
 3037:                     nh++;
 3037:                 } else {
 3037:                     free(newword);
 3037:                 } 
 3037:             }
 3037:          }
43385:          ptr = ptr->getFlgNxt();
 3037:        }
 3037:     }
 3037: 
 3037:     return nh;
 3037: }
 3037: 
 3037: // return length of replacing table
43385: int AffixMgr::get_numrep() const
 3037: {
 3037:   return numrep;
 3037: }
 3037: 
 3037: // return replacing table
43385: struct replentry * AffixMgr::get_reptable() const
 3037: {
 3037:   if (! reptable ) return NULL;
 3037:   return reptable;
 3037: }
 3037: 
21326: // return iconv table
43385: RepList * AffixMgr::get_iconvtable() const
21326: {
21326:   if (! iconvtable ) return NULL;
21326:   return iconvtable;
21326: }
21326: 
21326: // return oconv table
43385: RepList * AffixMgr::get_oconvtable() const
21326: {
21326:   if (! oconvtable ) return NULL;
21326:   return oconvtable;
21326: }
21326: 
 5768: // return replacing table
43385: struct phonetable * AffixMgr::get_phonetable() const
 5768: {
 5768:   if (! phone ) return NULL;
 5768:   return phone;
 5768: }
 5768: 
 3037: // return length of character map table
43385: int AffixMgr::get_nummap() const
 3037: {
 3037:   return nummap;
 3037: }
 3037: 
 3037: // return character map table
43385: struct mapentry * AffixMgr::get_maptable() const
 3037: {
 3037:   if (! maptable ) return NULL;
 3037:   return maptable;
 3037: }
 3037: 
 3037: // return length of word break table
43385: int AffixMgr::get_numbreak() const
 3037: {
 3037:   return numbreak;
 3037: }
 3037: 
 3037: // return character map table
43385: char ** AffixMgr::get_breaktable() const
 3037: {
 3037:   if (! breaktable ) return NULL;
 3037:   return breaktable;
 3037: }
 3037: 
 3037: // return text encoding of dictionary
 3037: char * AffixMgr::get_encoding()
 3037: {
21326:   if (! encoding ) encoding = mystrdup(SPELL_ENCODING);
 3037:   return mystrdup(encoding);
 3037: }
 3037: 
 3037: // return text encoding of dictionary
43385: int AffixMgr::get_langnum() const
 3037: {
 3037:   return langnum;
 3037: }
 3037: 
 3037: // return double prefix option
43385: int AffixMgr::get_complexprefixes() const
 3037: {
 3037:   return complexprefixes;
 3037: }
 3037: 
21326: // return FULLSTRIP option
43385: int AffixMgr::get_fullstrip() const
21326: {
21326:   return fullstrip;
21326: }
21326: 
43385: FLAG AffixMgr::get_keepcase() const
 3037: {
 3037:   return keepcase;
 3037: }
 3037: 
43385: int AffixMgr::get_checksharps() const
 3037: {
 3037:   return checksharps;
 3037: }
 3037: 
43385: char * AffixMgr::encode_flag(unsigned short aflag) const
21326: {
21326:   return pHMgr->encode_flag(aflag);
21326: }
21326: 
21326: 
 3037: // return the preferred ignore string for suggestions
43385: char * AffixMgr::get_ignore() const
 3037: {
 3037:   if (!ignorechars) return NULL;
 3648:   return ignorechars;
 3037: }
 3037: 
 3037: // return the preferred ignore string for suggestions
43385: unsigned short * AffixMgr::get_ignore_utf16(int * len) const
 3037: {
 3037:   *len = ignorechars_utf16_len;
 3037:   return ignorechars_utf16;
 3037: }
 3037: 
 5768: // return the keyboard string for suggestions
 5768: char * AffixMgr::get_key_string()
 5768: {
21326:   if (! keystring ) keystring = mystrdup(SPELL_KEYSTRING);
 5768:   return mystrdup(keystring);
 5768: }
 5768: 
 3037: // return the preferred try string for suggestions
43385: char * AffixMgr::get_try_string() const
 3037: {
 3037:   if (! trystring ) return NULL;
 3037:   return mystrdup(trystring);
 3037: }
 3037: 
 3037: // return the preferred try string for suggestions
43385: const char * AffixMgr::get_wordchars() const
 3037: {
 3037:   return wordchars;
 3037: }
 3037: 
43385: unsigned short * AffixMgr::get_wordchars_utf16(int * len) const
 3037: {
 3037:   *len = wordchars_utf16_len;
 3037:   return wordchars_utf16;
 3037: }
 3037: 
 3037: // is there compounding?
43385: int AffixMgr::get_compound() const
 3037: {
 3037:   return compoundflag || compoundbegin || numdefcpd;
 3037: }
 3037: 
 3037: // return the compound words control flag
43385: FLAG AffixMgr::get_compoundflag() const
 3037: {
 3037:   return compoundflag;
 3037: }
 3037: 
 3037: // return the forbidden words control flag
43385: FLAG AffixMgr::get_forbiddenword() const
 3037: {
 3037:   return forbiddenword;
 3037: }
 3037: 
 3037: // return the forbidden words control flag
43385: FLAG AffixMgr::get_nosuggest() const
 3037: {
 3037:   return nosuggest;
 3037: }
 3037: 
 3037: // return the forbidden words flag modify flag
43385: FLAG AffixMgr::get_needaffix() const
 3037: {
21326:   return needaffix;
 3037: }
 3037: 
 3037: // return the onlyincompound flag
43385: FLAG AffixMgr::get_onlyincompound() const
 3037: {
 3037:   return onlyincompound;
 3037: }
 3037: 
 3037: // return the compound word signal flag
43385: FLAG AffixMgr::get_compoundroot() const
 3037: {
 3037:   return compoundroot;
 3037: }
 3037: 
 3037: // return the compound begin signal flag
43385: FLAG AffixMgr::get_compoundbegin() const
 3037: {
 3037:   return compoundbegin;
 3037: }
 3037: 
 3037: // return the value of checknum
43385: int AffixMgr::get_checknum() const
 3037: {
 3037:   return checknum;
 3037: }
 3037: 
 3037: // return the value of prefix
43385: const char * AffixMgr::get_prefix() const
 3037: {
43385:   if (pfx) return pfx->getKey();
 3037:   return NULL;
 3037: }
 3037: 
 3037: // return the value of suffix
43385: const char * AffixMgr::get_suffix() const
 3037: {
 3037:   return sfxappnd;
 3037: }
 3037: 
 3037: // return the value of suffix
43385: const char * AffixMgr::get_version() const
 3037: {
 3037:   return version;
 3037: }
 3037: 
 3037: // return lemma_present flag
43385: FLAG AffixMgr::get_lemma_present() const
 3037: {
 3037:   return lemma_present;
 3037: }
 3037: 
 3037: // utility method to look up root words in hash table
 3037: struct hentry * AffixMgr::lookup(const char * word)
 3037: {
21326:   int i;
21326:   struct hentry * he = NULL;
21326:   for (i = 0; i < *maxdic && !he; i++) {
21326:     he = (alldic[i])->lookup(word);
21326:   }
21326:   return he;
 3037: }
 3037: 
 3037: // return the value of suffix
43385: int AffixMgr::have_contclass() const
 3037: {
 3037:   return havecontclass;
 3037: }
 3037: 
 3037: // return utf8
43385: int AffixMgr::get_utf8() const
 3037: {
 3037:   return utf8;
 3037: }
 3037: 
 3037: // return nosplitsugs
43385: int AffixMgr::get_maxngramsugs(void) const
 3037: {
 3037:   return maxngramsugs;
 3037: }
 3037: 
 3037: // return nosplitsugs
43385: int AffixMgr::get_nosplitsugs(void) const
 3037: {
 3037:   return nosplitsugs;
 3037: }
 3037: 
 3037: // return sugswithdots
43385: int AffixMgr::get_sugswithdots(void) const
 3037: {
 3037:   return sugswithdots;
 3037: }
 3037: 
 3037: /* parse flag */
21326: int AffixMgr::parse_flag(char * line, unsigned short * out, FileMgr * af) {
 3037:    char * s = NULL;
21326:    if (*out != FLAG_NULL && !(*out >= DEFAULTFLAGS)) {
21326:       HUNSPELL_WARNING(stderr, "error: line %d: multiple definitions of an affix file parameter\n", af->getlinenum());
 3037:       return 1;
 3037:    }
21326:    if (parse_string(line, &s, af->getlinenum())) return 1;
 3037:    *out = pHMgr->decode_flag(s);
 3037:    free(s);
 3037:    return 0;
 3037: }
 3037: 
 3037: /* parse num */
21326: int AffixMgr::parse_num(char * line, int * out, FileMgr * af) {
 3037:    char * s = NULL;
 3037:    if (*out != -1) {
21326:       HUNSPELL_WARNING(stderr, "error: line %d: multiple definitions of an affix file parameter\n", af->getlinenum());
 3037:       return 1;
 3037:    }
21326:    if (parse_string(line, &s, af->getlinenum())) return 1;
 3037:    *out = atoi(s);
 3037:    free(s);
 3037:    return 0;
 3037: }
 3037: 
 3037: /* parse in the max syllablecount of compound words and  */
21326: int  AffixMgr::parse_cpdsyllable(char * line, FileMgr * af)
 3037: {
 3037:    char * tp = line;
 3037:    char * piece;
 3037:    int i = 0;
 3037:    int np = 0;
 3037:    w_char w[MAXWORDLEN];
 3037:    piece = mystrsep(&tp, 0);
 3037:    while (piece) {
 3037:       if (*piece != '\0') {
 3037:           switch(i) {
 3037:              case 0: { np++; break; }
 3037:              case 1: { cpdmaxsyllable = atoi(piece); np++; break; }
 3037:              case 2: {
 3037:                 if (!utf8) {
 3037:                     cpdvowels = mystrdup(piece);
 3037:                 } else {
 3037:                     int n = u8_u16(w, MAXWORDLEN, piece);
 3037:                     if (n > 0) {
 3037:                         flag_qsort((unsigned short *) w, 0, n);
 3037:                         cpdvowels_utf16 = (w_char *) malloc(n * sizeof(w_char));
 3037:                         if (!cpdvowels_utf16) return 1;
 3037:                         memcpy(cpdvowels_utf16, w, n * sizeof(w_char));
 3037:                     }
 3037:                     cpdvowels_utf16_len = n;
 3037:                 }
 3037:                 np++;
 3037:                 break;
 3037:              }
 3037:              default: break;
 3037:           }
 3037:           i++;
 3037:       }
 3037:       piece = mystrsep(&tp, 0);
 3037:    }
 3037:    if (np < 2) {
21326:       HUNSPELL_WARNING(stderr, "error: line %d: missing compoundsyllable information\n", af->getlinenum());
 3037:       return 1;
 3037:    }
 3037:    if (np == 2) cpdvowels = mystrdup("aeiouAEIOU");
 3037:    return 0;
 3037: }
 3037: 
 3037: /* parse in the typical fault correcting table */
21326: int  AffixMgr::parse_reptable(char * line, FileMgr * af)
 3037: {
 3037:    if (numrep != 0) {
21326:       HUNSPELL_WARNING(stderr, "error: line %d: multiple table definitions\n", af->getlinenum());
 3037:       return 1;
 3037:    }
 3037:    char * tp = line;
 3037:    char * piece;
 3037:    int i = 0;
 3037:    int np = 0;
 3037:    piece = mystrsep(&tp, 0);
 3037:    while (piece) {
 3037:        if (*piece != '\0') {
 3037:           switch(i) {
 3037:              case 0: { np++; break; }
 3037:              case 1: { 
 3037:                        numrep = atoi(piece);
 3037:                        if (numrep < 1) {
21326:                           HUNSPELL_WARNING(stderr, "error: line %d: incorrect entry number\n", af->getlinenum());
 3037:                           return 1;
 3037:                        }
 3037:                        reptable = (replentry *) malloc(numrep * sizeof(struct replentry));
 3037:                        if (!reptable) return 1;
 3037:                        np++;
 3037:                        break;
 3037:                      }
 3037:              default: break;
 3037:           }
 3037:           i++;
 3037:        }
 3037:        piece = mystrsep(&tp, 0);
 3037:    }
 3037:    if (np != 2) {
21326:       HUNSPELL_WARNING(stderr, "error: line %d: missing data\n", af->getlinenum());
 3037:       return 1;
 3037:    } 
 3037:  
 3037:    /* now parse the numrep lines to read in the remainder of the table */
21326:    char * nl;
 3037:    for (int j=0; j < numrep; j++) {
21326:         if (!(nl = af->getline())) return 1;
 3037:         mychomp(nl);
 3037:         tp = nl;
 3037:         i = 0;
 3037:         reptable[j].pattern = NULL;
 3037:         reptable[j].pattern2 = NULL;
 3037:         piece = mystrsep(&tp, 0);
 3037:         while (piece) {
 3037:            if (*piece != '\0') {
 3037:                switch(i) {
 3037:                   case 0: {
 3037:                              if (strncmp(piece,"REP",3) != 0) {
21326:                                  HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n", af->getlinenum());
 3037:                                  numrep = 0;
 3037:                                  return 1;
 3037:                              }
 3037:                              break;
 3037:                           }
 3037:                   case 1: { reptable[j].pattern = mystrrep(mystrdup(piece),"_"," "); break; }
 3037:                   case 2: { reptable[j].pattern2 = mystrrep(mystrdup(piece),"_"," "); break; }
 3037:                   default: break;
 3037:                }
 3037:                i++;
 3037:            }
 3037:            piece = mystrsep(&tp, 0);
 3037:         }
 3037:         if ((!(reptable[j].pattern)) || (!(reptable[j].pattern2))) {
21326:              HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n", af->getlinenum());
 3037:              numrep = 0;
 3037:              return 1;
 3037:         }
 3037:    }
 3037:    return 0;
 3037: }
 3037: 
 5768: /* parse in the typical fault correcting table */
21326: int  AffixMgr::parse_convtable(char * line, FileMgr * af, RepList ** rl, const char * keyword)
21326: {
21326:    if (*rl) {
21326:       HUNSPELL_WARNING(stderr, "error: line %d: multiple table definitions\n", af->getlinenum());
21326:       return 1;
21326:    }
21326:    char * tp = line;
21326:    char * piece;
21326:    int i = 0;
21326:    int np = 0;
21326:    int numrl = 0;
21326:    piece = mystrsep(&tp, 0);
21326:    while (piece) {
21326:        if (*piece != '\0') {
21326:           switch(i) {
21326:              case 0: { np++; break; }
21326:              case 1: { 
21326:                        numrl = atoi(piece);
21326:                        if (numrl < 1) {
21326:                           HUNSPELL_WARNING(stderr, "error: line %d: incorrect entry number\n", af->getlinenum());
21326:                           return 1;
21326:                        }
21326:                        *rl = new RepList(numrl);
43385:                        if (!*rl) return 1;
21326:                        np++;
21326:                        break;
21326:                      }
21326:              default: break;
21326:           }
21326:           i++;
21326:        }
21326:        piece = mystrsep(&tp, 0);
21326:    }
21326:    if (np != 2) {
21326:       HUNSPELL_WARNING(stderr, "error: line %d: missing data\n", af->getlinenum());
21326:       return 1;
21326:    } 
21326:  
21326:    /* now parse the num lines to read in the remainder of the table */
21326:    char * nl;
21326:    for (int j=0; j < numrl; j++) {
21326:         if (!(nl = af->getline())) return 1;
21326:         mychomp(nl);
21326:         tp = nl;
21326:         i = 0;
21326:         char * pattern = NULL;
21326:         char * pattern2 = NULL;
21326:         piece = mystrsep(&tp, 0);
21326:         while (piece) {
21326:            if (*piece != '\0') {
21326:                switch(i) {
21326:                   case 0: {
21326:                              if (strncmp(piece, keyword, sizeof(keyword)) != 0) {
21326:                                  HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n", af->getlinenum());
21326:                                  delete *rl;
21326:                                  *rl = NULL;
21326:                                  return 1;
21326:                              }
21326:                              break;
21326:                           }
21326:                   case 1: { pattern = mystrrep(mystrdup(piece),"_"," "); break; }
21326:                   case 2: { 
21326:                     pattern2 = mystrrep(mystrdup(piece),"_"," ");
21326:                     break; 
21326:                   }
21326:                   default: break;
21326:                }
21326:                i++;
21326:            }
21326:            piece = mystrsep(&tp, 0);
21326:         }
21326:       if (!pattern || !pattern2) {
61626:          if (pattern)
61626:             free(pattern);
61626:          if (pattern2)
61626:             free(pattern2);
21326:          HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n", af->getlinenum());
21326:          return 1;
21326:       }
21326:       (*rl)->add(pattern, pattern2);
21326:    }
21326:    return 0;
21326: }
21326: 
21326: 
21326: /* parse in the typical fault correcting table */
21326: int  AffixMgr::parse_phonetable(char * line, FileMgr * af)
 5768: {
 5768:    if (phone) {
21326:       HUNSPELL_WARNING(stderr, "error: line %d: multiple table definitions\n", af->getlinenum());
 5768:       return 1;
 5768:    }
 5768:    char * tp = line;
 5768:    char * piece;
 5768:    int i = 0;
 5768:    int np = 0;
 5768:    piece = mystrsep(&tp, 0);
 5768:    while (piece) {
 5768:        if (*piece != '\0') {
 5768:           switch(i) {
 5768:              case 0: { np++; break; }
 5768:              case 1: { 
 5768:                        phone = (phonetable *) malloc(sizeof(struct phonetable));
43385:                        if (!phone) return 1;
 5768:                        phone->num = atoi(piece);
 5768:                        phone->rules = NULL;
21326:                        phone->utf8 = (char) utf8;
 5768:                        if (phone->num < 1) {
21326:                           HUNSPELL_WARNING(stderr, "error: line %d: bad entry number\n", af->getlinenum());
 5768:                           return 1;
 5768:                        }
 5768:                        phone->rules = (char * *) malloc(2 * (phone->num + 1) * sizeof(char *));
43385:                        if (!phone->rules) {
43385:                           free(phone);
43385:                           phone = NULL;
43385:                           return 1;
43385:                        }
 5768:                        np++;
 5768:                        break;
 5768:                      }
 5768:              default: break;
 5768:           }
 5768:           i++;
 5768:        }
 5768:        piece = mystrsep(&tp, 0);
 5768:    }
 5768:    if (np != 2) {
21326:       HUNSPELL_WARNING(stderr, "error: line %d: missing data\n", af->getlinenum());
 5768:       return 1;
 5768:    } 
 5768:  
 5768:    /* now parse the phone->num lines to read in the remainder of the table */
21326:    char * nl;
 5768:    for (int j=0; j < phone->num; j++) {
21326:         if (!(nl = af->getline())) return 1;
 5768:         mychomp(nl);
 5768:         tp = nl;
 5768:         i = 0;
 5768:         phone->rules[j * 2] = NULL;
 5768:         phone->rules[j * 2 + 1] = NULL;
 5768:         piece = mystrsep(&tp, 0);
 5768:         while (piece) {
 5768:            if (*piece != '\0') {
 5768:                switch(i) {
 5768:                   case 0: {
 5768:                              if (strncmp(piece,"PHONE",5) != 0) {
21326:                                  HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n", af->getlinenum());
 5768:                                  phone->num = 0;
 5768:                                  return 1;
 5768:                              }
 5768:                              break;
 5768:                           }
 5768:                   case 1: { phone->rules[j * 2] = mystrrep(mystrdup(piece),"_",""); break; }
 5768:                   case 2: { phone->rules[j * 2 + 1] = mystrrep(mystrdup(piece),"_",""); break; }
 5768:                   default: break;
 5768:                }
 5768:                i++;
 5768:            }
 5768:            piece = mystrsep(&tp, 0);
 5768:         }
 5768:         if ((!(phone->rules[j * 2])) || (!(phone->rules[j * 2 + 1]))) {
21326:              HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n", af->getlinenum());
 5768:              phone->num = 0;
 5768:              return 1;
 5768:         }
 5768:    }
 5768:    phone->rules[phone->num * 2] = mystrdup("");
 5768:    phone->rules[phone->num * 2 + 1] = mystrdup("");
 5768:    init_phonet_hash(*phone);
 5768:    return 0;
 5768: }
 5768: 
 3037: /* parse in the checkcompoundpattern table */
21326: int  AffixMgr::parse_checkcpdtable(char * line, FileMgr * af)
 3037: {
 3037:    if (numcheckcpd != 0) {
21326:       HUNSPELL_WARNING(stderr, "error: line %d: multiple table definitions\n", af->getlinenum());
 3037:       return 1;
 3037:    }
 3037:    char * tp = line;
 3037:    char * piece;
 3037:    int i = 0;
 3037:    int np = 0;
 3037:    piece = mystrsep(&tp, 0);
 3037:    while (piece) {
 3037:        if (*piece != '\0') {
 3037:           switch(i) {
 3037:              case 0: { np++; break; }
 3037:              case 1: { 
 3037:                        numcheckcpd = atoi(piece);
 3037:                        if (numcheckcpd < 1) {
21326:                           HUNSPELL_WARNING(stderr, "error: line %d: bad entry number\n", af->getlinenum());
 3037:                           return 1;
 3037:                        }
21326:                        checkcpdtable = (patentry *) malloc(numcheckcpd * sizeof(struct patentry));
 3037:                        if (!checkcpdtable) return 1;
 3037:                        np++;
 3037:                        break;
 3037:                      }
 3037:              default: break;
 3037:           }
 3037:           i++;
 3037:        }
 3037:        piece = mystrsep(&tp, 0);
 3037:    }
 3037:    if (np != 2) {
21326:       HUNSPELL_WARNING(stderr, "error: line %d: missing data\n",  af->getlinenum());
 3037:       return 1;
 3037:    }
 3037: 
 3037:    /* now parse the numcheckcpd lines to read in the remainder of the table */
21326:    char * nl;
 3037:    for (int j=0; j < numcheckcpd; j++) {
21326:         if (!(nl = af->getline())) return 1;
 3037:         mychomp(nl);
 3037:         tp = nl;
 3037:         i = 0;
 3037:         checkcpdtable[j].pattern = NULL;
 3037:         checkcpdtable[j].pattern2 = NULL;
21326:         checkcpdtable[j].pattern3 = NULL;
21326:         checkcpdtable[j].cond = FLAG_NULL;
21326:         checkcpdtable[j].cond2 = FLAG_NULL;
 3037:         piece = mystrsep(&tp, 0);
 3037:         while (piece) {
 3037:            if (*piece != '\0') {
 3037:                switch(i) {
 3037:                   case 0: {
 3037:                              if (strncmp(piece,"CHECKCOMPOUNDPATTERN",20) != 0) {
21326:                                  HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n", af->getlinenum());
 3037:                                  numcheckcpd = 0;
 3037:                                  return 1;
 3037:                              }
21326:                              break;
21326:                           }
21326:                   case 1: { 
21326:                     checkcpdtable[j].pattern = mystrdup(piece); 
21326:                     char * p = strchr(checkcpdtable[j].pattern, '/');
21326:                     if (p) {
21326:                       *p = '\0';
21326:                     checkcpdtable[j].cond = pHMgr->decode_flag(p + 1);
21326:                     }
21326:                     break; }
21326:                   case 2: { 
21326:                     checkcpdtable[j].pattern2 = mystrdup(piece);
21326:                     char * p = strchr(checkcpdtable[j].pattern2, '/');
21326:                     if (p) {
21326:                       *p = '\0';
21326:                       checkcpdtable[j].cond2 = pHMgr->decode_flag(p + 1);
21326:                     }
21326:                     break;
21326:                     }
21326:                   case 3: { checkcpdtable[j].pattern3 = mystrdup(piece); simplifiedcpd = 1; break; }
21326:                   default: break;
21326:                }
21326:                i++;
21326:            }
21326:            piece = mystrsep(&tp, 0);
21326:         }
21326:         if ((!(checkcpdtable[j].pattern)) || (!(checkcpdtable[j].pattern2))) {
21326:              HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n", af->getlinenum());
21326:              numcheckcpd = 0;
21326:              return 1;
21326:         }
 3037:    }
 3037:    return 0;
 3037: }
 3037: 
 3037: /* parse in the compound rule table */
21326: int  AffixMgr::parse_defcpdtable(char * line, FileMgr * af)
 3037: {
 3037:    if (numdefcpd != 0) {
21326:       HUNSPELL_WARNING(stderr, "error: line %d: multiple table definitions\n", af->getlinenum());
 3037:       return 1;
 3037:    }
 3037:    char * tp = line;
 3037:    char * piece;
 3037:    int i = 0;
 3037:    int np = 0;
 3037:    piece = mystrsep(&tp, 0);
 3037:    while (piece) {
 3037:        if (*piece != '\0') {
 3037:           switch(i) {
 3037:              case 0: { np++; break; }
 3037:              case 1: { 
 3037:                        numdefcpd = atoi(piece);
 3037:                        if (numdefcpd < 1) {
21326:                           HUNSPELL_WARNING(stderr, "error: line %d: bad entry number\n", af->getlinenum());
 3037:                           return 1;
 3037:                        }
 3037:                        defcpdtable = (flagentry *) malloc(numdefcpd * sizeof(flagentry));
 3037:                        if (!defcpdtable) return 1;
 3037:                        np++;
 3037:                        break;
 3037:                      }
 3037:              default: break;
 3037:           }
 3037:           i++;
 3037:        }
 3037:        piece = mystrsep(&tp, 0);
 3037:    }
 3037:    if (np != 2) {
21326:       HUNSPELL_WARNING(stderr, "error: line %d: missing data\n", af->getlinenum());
 3037:       return 1;
 3037:    } 
 3037:  
 3037:    /* now parse the numdefcpd lines to read in the remainder of the table */
21326:    char * nl;
 3037:    for (int j=0; j < numdefcpd; j++) {
21326:         if (!(nl = af->getline())) return 1;
 3037:         mychomp(nl);
 3037:         tp = nl;
 3037:         i = 0;
 3037:         defcpdtable[j].def = NULL;
 3037:         piece = mystrsep(&tp, 0);
 3037:         while (piece) {
 3037:            if (*piece != '\0') {
 3037:                switch(i) {
 3037:                   case 0: {
 3037:                              if (strncmp(piece, "COMPOUNDRULE", 12) != 0) {
21326:                                  HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n", af->getlinenum());
 3037:                                  numdefcpd = 0;
 3037:                                  return 1;
 3037:                              }
 3037:                              break;
 3037:                           }
21326:                   case 1: { // handle parenthesized flags
21326:                             if (strchr(piece, '(')) {
47948:                                 defcpdtable[j].def = (FLAG *) malloc(strlen(piece) * sizeof(FLAG));
21326:                                 defcpdtable[j].len = 0;
21326:                                 int end = 0;
21326:                                 FLAG * conv;
21326:                                 while (!end) {
21326:                                     char * par = piece + 1;
21326:                                     while (*par != '(' && *par != ')' && *par != '\0') par++;
21326:                                     if (*par == '\0') end = 1; else *par = '\0';
21326:                                     if (*piece == '(') piece++;
21326:                                     if (*piece == '*' || *piece == '?') {
21326:                                         defcpdtable[j].def[defcpdtable[j].len++] = (FLAG) *piece;
21326:                                     } else if (*piece != '\0') {
21326:                                         int l = pHMgr->decode_flags(&conv, piece, af);
21326:                                         for (int k = 0; k < l; k++) defcpdtable[j].def[defcpdtable[j].len++] = conv[k];
21326:                                         free(conv);
21326:                                     }
21326:                                     piece = par + 1;
21326:                                 }
21326:                             } else {
21326:                                 defcpdtable[j].len = pHMgr->decode_flags(&(defcpdtable[j].def), piece, af);
21326:                             }
 3037:                             break; 
 3037:                            }
 3037:                   default: break;
 3037:                }
 3037:                i++;
 3037:            }
 3037:            piece = mystrsep(&tp, 0);
 3037:         }
 3037:         if (!defcpdtable[j].len) {
21326:              HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n", af->getlinenum());
 3037:              numdefcpd = 0;
 3037:              return 1;
 3037:         }
 3037:    }
 3037:    return 0;
 3037: }
 3037: 
 3037: 
 3037: /* parse in the character map table */
21326: int  AffixMgr::parse_maptable(char * line, FileMgr * af)
 3037: {
 3037:    if (nummap != 0) {
21326:       HUNSPELL_WARNING(stderr, "error: line %d: multiple table definitions\n", af->getlinenum());
 3037:       return 1;
 3037:    }
 3037:    char * tp = line;
 3037:    char * piece;
 3037:    int i = 0;
 3037:    int np = 0;
 3037:    piece = mystrsep(&tp, 0);
 3037:    while (piece) {
 3037:        if (*piece != '\0') {
 3037:           switch(i) {
 3037:              case 0: { np++; break; }
 3037:              case 1: { 
 3037:                        nummap = atoi(piece);
 3037:                        if (nummap < 1) {
21326:                           HUNSPELL_WARNING(stderr, "error: line %d: bad entry number\n", af->getlinenum());
 3037:                           return 1;
 3037:                        }
 3037:                        maptable = (mapentry *) malloc(nummap * sizeof(struct mapentry));
 3037:                        if (!maptable) return 1;
 3037:                        np++;
 3037:                        break;
 3037:                      }
 3037:              default: break;
 3037:           }
 3037:           i++;
 3037:        }
 3037:        piece = mystrsep(&tp, 0);
 3037:    }
 3037:    if (np != 2) {
21326:       HUNSPELL_WARNING(stderr, "error: line %d: missing data\n", af->getlinenum());
 3037:       return 1;
 3037:    } 
 3037:  
 3037:    /* now parse the nummap lines to read in the remainder of the table */
21326:    char * nl;
 3037:    for (int j=0; j < nummap; j++) {
21326:         if (!(nl = af->getline())) return 1;
 3037:         mychomp(nl);
 3037:         tp = nl;
 3037:         i = 0;
 3037:         maptable[j].set = NULL;
 3037:         maptable[j].len = 0;
 3037:         piece = mystrsep(&tp, 0);
 3037:         while (piece) {
 3037:            if (*piece != '\0') {
 3037:                switch(i) {
 3037:                   case 0: {
 3037:                              if (strncmp(piece,"MAP",3) != 0) {
21326:                                  HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n", af->getlinenum());
 3037:                                  nummap = 0;
 3037:                                  return 1;
 3037:                              }
 3037:                              break;
 3037:                           }
 3037:                   case 1: {
43385: 			    int setn = 0;
43385:                             maptable[j].len = strlen(piece);
43385:                             maptable[j].set = (char **) malloc(maptable[j].len * sizeof(char*));
43385:                             if (!maptable[j].set) return 1;
43385: 			    for (int k = 0; k < maptable[j].len; k++) {
43385: 				int chl = 1;
43385: 				int chb = k;
43385: 			        if (piece[k] == '(') {
43385: 				    char * parpos = strchr(piece + k, ')');
43385: 				    if (parpos != NULL) {
43385: 					chb = k + 1;
43385: 					chl = (int)(parpos - piece) - k - 1;
43385: 					k = k + chl + 1;
43385: 				    }
 3037: 				} else {
43385: 				    if (utf8 && (piece[k] & 0xc0) == 0xc0) {
43385: 					for (k++; utf8 && (piece[k] & 0xc0) == 0x80; k++);
43385: 					chl = k - chb;
43385: 					k--;
43385: 				    }
43385: 				}
43385: 				maptable[j].set[setn] = (char *) malloc(chl + 1);
43385: 				if (!maptable[j].set[setn]) return 1;
43385: 				strncpy(maptable[j].set[setn], piece + chb, chl);
43385: 				maptable[j].set[setn][chl] = '\0';
43385: 				setn++;
43385: 			    }
43385:                             maptable[j].len = setn;
 3037:                             break; }
 3037:                   default: break;
 3037:                }
 3037:                i++;
 3037:            }
 3037:            piece = mystrsep(&tp, 0);
 3037:         }
43385:         if (!maptable[j].set || !maptable[j].len) {
21326:              HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n", af->getlinenum());
 3037:              nummap = 0;
 3037:              return 1;
 3037:         }
 3037:    }
 3037:    return 0;
 3037: }
 3037: 
 3037: /* parse in the word breakpoint table */
21326: int  AffixMgr::parse_breaktable(char * line, FileMgr * af)
 3037: {
 3037:    if (numbreak != 0) {
21326:       HUNSPELL_WARNING(stderr, "error: line %d: multiple table definitions\n", af->getlinenum());
 3037:       return 1;
 3037:    }
 3037:    char * tp = line;
 3037:    char * piece;
 3037:    int i = 0;
 3037:    int np = 0;
 3037:    piece = mystrsep(&tp, 0);
 3037:    while (piece) {
 3037:        if (*piece != '\0') {
 3037:           switch(i) {
 3037:              case 0: { np++; break; }
 3037:              case 1: { 
 3037:                        numbreak = atoi(piece);
 3037:                        if (numbreak < 1) {
21326:                           HUNSPELL_WARNING(stderr, "error: line %d: bad entry number\n", af->getlinenum());
 3037:                           return 1;
 3037:                        }
 3037:                        breaktable = (char **) malloc(numbreak * sizeof(char *));
 3037:                        if (!breaktable) return 1;
 3037:                        np++;
 3037:                        break;
 3037:                      }
 3037:              default: break;
 3037:           }
 3037:           i++;
 3037:        }
 3037:        piece = mystrsep(&tp, 0);
 3037:    }
 3037:    if (np != 2) {
21326:       HUNSPELL_WARNING(stderr, "error: line %d: missing data\n", af->getlinenum());
 3037:       return 1;
 3037:    } 
 3037:  
 3037:    /* now parse the numbreak lines to read in the remainder of the table */
21326:    char * nl;
 3037:    for (int j=0; j < numbreak; j++) {
21326:         if (!(nl = af->getline())) return 1;
 3037:         mychomp(nl);
 3037:         tp = nl;
 3037:         i = 0;
 3037:         piece = mystrsep(&tp, 0);
 3037:         while (piece) {
 3037:            if (*piece != '\0') {
 3037:                switch(i) {
 3037:                   case 0: {
 3037:                              if (strncmp(piece,"BREAK",5) != 0) {
21326:                                  HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n", af->getlinenum());
 3037:                                  numbreak = 0;
 3037:                                  return 1;
 3037:                              }
 3037:                              break;
 3037:                           }
 3037:                   case 1: {
 3037:                             breaktable[j] = mystrdup(piece);
 3037:                             break;
 3037:                           }
 3037:                   default: break;
 3037:                }
 3037:                i++;
 3037:            }
 3037:            piece = mystrsep(&tp, 0);
 3037:         }
 3037:         if (!breaktable) {
21326:              HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n", af->getlinenum());
 3037:              numbreak = 0;
 3037:              return 1;
 3037:         }
 3037:    }
 3037:    return 0;
 3037: }
 3037: 
21326: void AffixMgr::reverse_condition(char * piece) {
21326:     int neg = 0;
21326:     for (char * k = piece + strlen(piece) - 1; k >= piece; k--) {
21326:         switch(*k) {
21326:           case '[': {
21326:                 if (neg) *(k+1) = '['; else *k = ']';
21326:                     break;
21326:             }
21326:           case ']': {
21326:                 *k = '[';
21326:                 if (neg) *(k+1) = '^';
21326:                 neg = 0;
21326:                 break;
21326:             }
21326:           case '^': {
21326:                if (*(k+1) == ']') neg = 1; else *(k+1) = *k;
21326:                break;
21326:                 }
21326:           default: {
21326:             if (neg) *(k+1) = *k;
21326:           }
21326:        }
21326:     }
21326: }
21326: 
21326: int  AffixMgr::parse_affix(char * line, const char at, FileMgr * af, char * dupflags)
 3037: {
 3037:    int numents = 0;      // number of affentry structures to parse
 3037: 
 3037:    unsigned short aflag = 0;      // affix char identifier
 3037: 
 3037:    char ff=0;
43385:    std::vector<affentry> affentries;
 3037: 
 3037:    char * tp = line;
 3037:    char * nl = line;
 3037:    char * piece;
 3037:    int i = 0;
 3037: 
 3037:    // checking lines with bad syntax
 3037: #ifdef DEBUG
 3037:    int basefieldnum = 0;
 3037: #endif
 3037: 
 3037:    // split affix header line into pieces
 3037: 
 3037:    int np = 0;
21326: 
 3037:    piece = mystrsep(&tp, 0);
 3037:    while (piece) {
 3037:       if (*piece != '\0') {
 3037:           switch(i) {
 3037:              // piece 1 - is type of affix
 3037:              case 0: { np++; break; }
 3037:           
 3037:              // piece 2 - is affix char
 3037:              case 1: { 
 3037:                     np++;
 3037:                     aflag = pHMgr->decode_flag(piece);
 3037:                     if (((at == 'S') && (dupflags[aflag] & dupSFX)) ||
 3037:                         ((at == 'P') && (dupflags[aflag] & dupPFX))) {
21326:                         HUNSPELL_WARNING(stderr, "error: line %d: multiple definitions of an affix flag\n",
21326:                             af->getlinenum());
 3037:                         // return 1; XXX permissive mode for bad dictionaries
 3037:                     }
21326:                     dupflags[aflag] += (char) ((at == 'S') ? dupSFX : dupPFX);
 3037:                     break; 
 3037:                     }
 3037:              // piece 3 - is cross product indicator 
 3037:              case 2: { np++; if (*piece == 'Y') ff = aeXPRODUCT; break; }
 3037: 
 3037:              // piece 4 - is number of affentries
 3037:              case 3: { 
 3037:                        np++;
 3037:                        numents = atoi(piece); 
 3037:                        if (numents == 0) {
 3037:                            char * err = pHMgr->encode_flag(aflag);
21326:                            if (err) {
21326:                                 HUNSPELL_WARNING(stderr, "error: line %d: bad entry number\n",
21326:                                    af->getlinenum());
 3037:                                 free(err);
21326:                            }
 3037:                            return 1;
 3037:                        }
43385:                        affentries.resize(numents);
43385:                        affentries[0].opts = ff;
43385:                        if (utf8) affentries[0].opts += aeUTF8;
43385:                        if (pHMgr->is_aliasf()) affentries[0].opts += aeALIASF;
43385:                        if (pHMgr->is_aliasm()) affentries[0].opts += aeALIASM;
43385:                        affentries[0].aflag = aflag;
 3037:                      }
 3037: 
 3037:              default: break;
 3037:           }
 3037:           i++;
 3037:       }
 3037:       piece = mystrsep(&tp, 0);
 3037:    }
 3037:    // check to make sure we parsed enough pieces
 3037:    if (np != 4) {
 3037:        char * err = pHMgr->encode_flag(aflag);
21326:        if (err) {
21326:             HUNSPELL_WARNING(stderr, "error: line %d: missing data\n", af->getlinenum());
 3037:             free(err);
21326:        }
 3037:        return 1;
 3037:    }
 3037:  
 3037:    // now parse numents affentries for this affix
43385:    std::vector<affentry>::iterator start = affentries.begin();
43385:    std::vector<affentry>::iterator end = affentries.end();
43385:    for (std::vector<affentry>::iterator entry = start; entry != end; ++entry) {
21326:       if (!(nl = af->getline())) return 1;
 3037:       mychomp(nl);
 3037:       tp = nl;
 3037:       i = 0;
 3037:       np = 0;
 3037: 
 3037:       // split line into pieces
 3037:       piece = mystrsep(&tp, 0);
 3037:       while (piece) {
 3037:          if (*piece != '\0') {
 3037:              switch(i) {
 3037:                 // piece 1 - is type
 3037:                 case 0: { 
 3037:                           np++;
43385:                           if (entry != start) entry->opts = start->opts &
21326:                              (char) (aeXPRODUCT + aeUTF8 + aeALIASF + aeALIASM);
 3037:                           break;
 3037:                         }
 3037: 
 3037:                 // piece 2 - is affix char
 3037:                 case 1: { 
 3037:                           np++;
 3037:                           if (pHMgr->decode_flag(piece) != aflag) {
 3037:                               char * err = pHMgr->encode_flag(aflag);
21326:                               if (err) {
21326:                                 HUNSPELL_WARNING(stderr, "error: line %d: affix %s is corrupt\n",
21326:                                     af->getlinenum(), err);
 3037:                                 free(err);
21326:                               }
 3037:                               return 1;
 3037:                           }
 3037: 
43385:                           if (entry != start) entry->aflag = start->aflag;
 3037:                           break;
 3037:                         }
 3037: 
 3037:                 // piece 3 - is string to strip or 0 for null 
 3037:                 case 2: { 
 3037:                           np++;
 3037:                           if (complexprefixes) {
 3037:                             if (utf8) reverseword_utf(piece); else reverseword(piece);
 3037:                           }
43385:                           entry->strip = mystrdup(piece);
43385:                           entry->stripl = (unsigned char) strlen(entry->strip);
43385:                           if (strcmp(entry->strip,"0") == 0) {
43385:                               free(entry->strip);
43385:                               entry->strip=mystrdup("");
43385:                               entry->stripl = 0;
 3037:                           }   
 3037:                           break; 
 3037:                         }
 3037: 
 3037:                 // piece 4 - is affix string or 0 for null
 3037:                 case 3: { 
 3037:                           char * dash;  
43385:                           entry->morphcode = NULL;
43385:                           entry->contclass = NULL;
43385:                           entry->contclasslen = 0;
 3037:                           np++;
 3037:                           dash = strchr(piece, '/');
 3037:                           if (dash) {
 3037:                             *dash = '\0';
 3037: 
 3037:                             if (ignorechars) {
 3037:                               if (utf8) {
 3037:                                 remove_ignored_chars_utf(piece, ignorechars_utf16, ignorechars_utf16_len);
 3037:                               } else {
 3037:                                 remove_ignored_chars(piece,ignorechars);
 3037:                               }
 3037:                             }
 3037: 
 3037:                             if (complexprefixes) {
 3037:                                 if (utf8) reverseword_utf(piece); else reverseword(piece);
 3037:                             }
43385:                             entry->appnd = mystrdup(piece);
 3037: 
 3037:                             if (pHMgr->is_aliasf()) {
 3037:                                 int index = atoi(dash + 1);
43385:                                 entry->contclasslen = (unsigned short) pHMgr->get_aliasf(index, &(entry->contclass), af);
43385:                                 if (!entry->contclasslen) HUNSPELL_WARNING(stderr, "error: bad affix flag alias: \"%s\"\n", dash+1);
 3037:                             } else {
43385:                                 entry->contclasslen = (unsigned short) pHMgr->decode_flags(&(entry->contclass), dash + 1, af);
43385:                                 flag_qsort(entry->contclass, 0, entry->contclasslen);
 3037:                             }
 3037:                             *dash = '/';
 3037: 
 3037:                             havecontclass = 1;
43385:                             for (unsigned short _i = 0; _i < entry->contclasslen; _i++) {
43385:                               contclasses[(entry->contclass)[_i]] = 1;
 3037:                             }
 3037:                           } else {
 3037:                             if (ignorechars) {
 3037:                               if (utf8) {
 3037:                                 remove_ignored_chars_utf(piece, ignorechars_utf16, ignorechars_utf16_len);
 3037:                               } else {
 3037:                                 remove_ignored_chars(piece,ignorechars);
 3037:                               }
 3037:                             }
 3037: 
 3037:                             if (complexprefixes) {
 3037:                                 if (utf8) reverseword_utf(piece); else reverseword(piece);
 3037:                             }
43385:                             entry->appnd = mystrdup(piece);
43385:                           }
43385: 
43385:                           entry->appndl = (unsigned char) strlen(entry->appnd);
43385:                           if (strcmp(entry->appnd,"0") == 0) {
43385:                               free(entry->appnd);
43385:                               entry->appnd=mystrdup("");
43385:                               entry->appndl = 0;
 3037:                           }   
 3037:                           break; 
 3037:                         }
 3037: 
 3037:                 // piece 5 - is the conditions descriptions
 3037:                 case 4: { 
 3037:                           np++;
 3037:                           if (complexprefixes) {
 3037:                             if (utf8) reverseword_utf(piece); else reverseword(piece);
21326:                             reverse_condition(piece);
 3037:                           }
43385:                           if (entry->stripl && (strcmp(piece, ".") != 0) &&
43385:                             redundant_condition(at, entry->strip, entry->stripl, piece, af->getlinenum()))
 3037:                                 strcpy(piece, ".");
21326:                           if (at == 'S') {
21326:                             reverseword(piece);
21326:                             reverse_condition(piece);
21326:                           }
43385:                           if (encodeit(*entry, piece)) return 1;
 3037:                          break;
 3037:                 }
 3037: 
 3037:                 case 5: {
 3037:                           np++;
 3037:                           if (pHMgr->is_aliasm()) {
 3037:                             int index = atoi(piece);
43385:                             entry->morphcode = pHMgr->get_aliasm(index);
 3037:                           } else {
21326:                             if (complexprefixes) { // XXX - fix me for morph. gen.
 3037:                                 if (utf8) reverseword_utf(piece); else reverseword(piece);
 3037:                             }
21326:                             // add the remaining of the line
21326:                             if (*tp) {
21326:                                 *(tp - 1) = ' ';
21326:                                 tp = tp + strlen(tp);
21326:                             }
43385:                             entry->morphcode = mystrdup(piece);
43385:                             if (!entry->morphcode) return 1;
 3037:                           }
 3037:                           break; 
 3037:                 }
 3037:                 default: break;
 3037:              }
 3037:              i++;
 3037:          }
 3037:          piece = mystrsep(&tp, 0);
 3037:       }
 3037:       // check to make sure we parsed enough pieces
 3037:       if (np < 4) {
 3037:           char * err = pHMgr->encode_flag(aflag);
21326:           if (err) {
21326:             HUNSPELL_WARNING(stderr, "error: line %d: affix %s is corrupt\n",
21326:                 af->getlinenum(), err);
 3037:             free(err);
21326:           }
 3037:           return 1;
 3037:       }
 3037: 
 3037: #ifdef DEBUG
 3037:       // detect unnecessary fields, excepting comments
 3037:       if (basefieldnum) {
43385:         int fieldnum = !(entry->morphcode) ? 5 : ((*(entry->morphcode)=='#') ? 5 : 6);
 3037:           if (fieldnum != basefieldnum) 
21326:             HUNSPELL_WARNING(stderr, "warning: line %d: bad field number\n", af->getlinenum());
 3037:       } else {
43385:         basefieldnum = !(entry->morphcode) ? 5 : ((*(entry->morphcode)=='#') ? 5 : 6);
 3037:       }
 3037: #endif
 3037:    }
 3037:  
 3037:    // now create SfxEntry or PfxEntry objects and use links to
 3037:    // build an ordered (sorted by affix string) list
43385:    for (std::vector<affentry>::iterator entry = start; entry != end; ++entry) {
 3037:       if (at == 'P') {
43385:           PfxEntry * pfxptr = new PfxEntry(this,&(*entry));
43385:           build_pfxtree(pfxptr);
 3037:       } else {
43385:           SfxEntry * sfxptr = new SfxEntry(this,&(*entry));
43385:           build_sfxtree(sfxptr); 
43385:       }
43385:    }
 3037:    return 0;
 3037: }
 3037: 
21326: int AffixMgr::redundant_condition(char ft, char * strip, int stripl, const char * cond, int linenum) {
 3037:   int condl = strlen(cond);
 3037:   int i;
 3037:   int j;
 3037:   int neg;
 3037:   int in;
 3037:   if (ft == 'P') { // prefix
 3037:     if (strncmp(strip, cond, condl) == 0) return 1;
 3037:     if (utf8) {
 3037:     } else {
 3037:       for (i = 0, j = 0; (i < stripl) && (j < condl); i++, j++) {
 3037:         if (cond[j] != '[') {
 3037:           if (cond[j] != strip[i]) {
21326:             HUNSPELL_WARNING(stderr, "warning: line %d: incompatible stripping characters and condition\n", linenum);
21326:             return 0;
 3037:           }
 3037:         } else {
 3037:           neg = (cond[j+1] == '^') ? 1 : 0;
 3037:           in = 0;
 3037:           do {
 3037:             j++;
 3037:             if (strip[i] == cond[j]) in = 1;
 3037:           } while ((j < (condl - 1)) && (cond[j] != ']'));
 3037:           if (j == (condl - 1) && (cond[j] != ']')) {
43385:             HUNSPELL_WARNING(stderr, "error: line %d: missing ] in condition:\n%s\n", linenum, cond);
 3037:             return 0;
 3037:           }
 3037:           if ((!neg && !in) || (neg && in)) {
21326:             HUNSPELL_WARNING(stderr, "warning: line %d: incompatible stripping characters and condition\n", linenum);
 3037:             return 0;
 3037:           }
 3037:         }
 3037:       }
 3037:       if (j >= condl) return 1;
 3037:     }
 3037:   } else { // suffix
 3037:     if ((stripl >= condl) && strcmp(strip + stripl - condl, cond) == 0) return 1;
 3037:     if (utf8) {
 3037:     } else {
 3037:       for (i = stripl - 1, j = condl - 1; (i >= 0) && (j >= 0); i--, j--) {
 3037:         if (cond[j] != ']') {
 3037:           if (cond[j] != strip[i]) {
21326:             HUNSPELL_WARNING(stderr, "warning: line %d: incompatible stripping characters and condition\n", linenum);
21326:             return 0;
 3037:           }
 3037:         } else {
 3037:           in = 0;
 3037:           do {
 3037:             j--;
 3037:             if (strip[i] == cond[j]) in = 1;
 3037:           } while ((j > 0) && (cond[j] != '['));
 3037:           if ((j == 0) && (cond[j] != '[')) {
43385:             HUNSPELL_WARNING(stderr, "error: line: %d: missing ] in condition:\n%s\n", linenum, cond);
 3037:             return 0;
 3037:           }
 3037:           neg = (cond[j+1] == '^') ? 1 : 0;
 3037:           if ((!neg && !in) || (neg && in)) {
21326:             HUNSPELL_WARNING(stderr, "warning: line %d: incompatible stripping characters and condition\n", linenum);
 3037:             return 0;
 3037:           }
 3037:         }
 3037:       }
 3037:       if (j < 0) return 1;
 3037:     }
 3037:   }
 3037:   return 0;
 3037: }
