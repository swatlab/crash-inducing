    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   David Hyatt <hyatt@netscape.com> (Original Author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsIAtom.h"
    1: #include "nsString.h"
    1: #include "jsapi.h"
    1: #include "nsIContent.h"
    1: #include "nsIDocument.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsString.h"
41653: #include "mozilla/FunctionTimer.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsXBLProtoImplMethod.h"
    1: #include "nsIScriptContext.h"
    1: #include "nsContentUtils.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsIXPConnect.h"
81367: #include "nsXBLPrototypeBinding.h"
    1: 
    1: nsXBLProtoImplMethod::nsXBLProtoImplMethod(const PRUnichar* aName) :
    1:   nsXBLProtoImplMember(aName), 
11594:   mUncompiledMethod(BIT_UNCOMPILED)
    1: {
    1:   MOZ_COUNT_CTOR(nsXBLProtoImplMethod);
    1: }
    1: 
    1: nsXBLProtoImplMethod::~nsXBLProtoImplMethod()
    1: {
    1:   MOZ_COUNT_DTOR(nsXBLProtoImplMethod);
    1: 
11594:   if (!IsCompiled()) {
11594:     delete GetUncompiledMethod();
    1:   }
    1: }
    1: 
    1: void 
    1: nsXBLProtoImplMethod::AppendBodyText(const nsAString& aText)
    1: {
11594:   NS_PRECONDITION(!IsCompiled(),
    1:                   "Must not be compiled when accessing uncompiled method");
11594: 
11594:   nsXBLUncompiledMethod* uncompiledMethod = GetUncompiledMethod();
11594:   if (!uncompiledMethod) {
11594:     uncompiledMethod = new nsXBLUncompiledMethod();
11594:     if (!uncompiledMethod)
    1:       return;
11594:     SetUncompiledMethod(uncompiledMethod);
    1:   }
    1: 
11594:   uncompiledMethod->AppendBodyText(aText);
    1: }
    1: 
    1: void 
    1: nsXBLProtoImplMethod::AddParameter(const nsAString& aText)
    1: {
11594:   NS_PRECONDITION(!IsCompiled(),
    1:                   "Must not be compiled when accessing uncompiled method");
11594: 
11594:   nsXBLUncompiledMethod* uncompiledMethod = GetUncompiledMethod();
11594:   if (!uncompiledMethod) {
11594:     uncompiledMethod = new nsXBLUncompiledMethod();
11594:     if (!uncompiledMethod)
    1:       return;
11594:     SetUncompiledMethod(uncompiledMethod);
    1:   }
    1: 
11594:   uncompiledMethod->AddParameter(aText);
    1: }
    1: 
    1: void
    1: nsXBLProtoImplMethod::SetLineNumber(PRUint32 aLineNumber)
    1: {
11594:   NS_PRECONDITION(!IsCompiled(),
    1:                   "Must not be compiled when accessing uncompiled method");
11594: 
11594:   nsXBLUncompiledMethod* uncompiledMethod = GetUncompiledMethod();
11594:   if (!uncompiledMethod) {
11594:     uncompiledMethod = new nsXBLUncompiledMethod();
11594:     if (!uncompiledMethod)
    1:       return;
11594:     SetUncompiledMethod(uncompiledMethod);
    1:   }
    1: 
11594:   uncompiledMethod->SetLineNumber(aLineNumber);
    1: }
    1: 
    1: nsresult
    1: nsXBLProtoImplMethod::InstallMember(nsIScriptContext* aContext,
    1:                                     nsIContent* aBoundElement, 
    1:                                     void* aScriptObject,
    1:                                     void* aTargetClassObject,
    1:                                     const nsCString& aClassStr)
    1: {
11594:   NS_PRECONDITION(IsCompiled(),
    1:                   "Should not be installing an uncompiled method");
78415:   JSContext* cx = aContext->GetNativeContext();
    1: 
80526:   nsIDocument *ownerDoc = aBoundElement->OwnerDoc();
    1:   nsIScriptGlobalObject *sgo;
    1: 
80527:   if (!(sgo = ownerDoc->GetScopeObject())) {
    1:     return NS_ERROR_UNEXPECTED;
    1:   }
    1: 
    1:   JSObject * scriptObject = (JSObject *) aScriptObject;
    1:   NS_ASSERTION(scriptObject, "uh-oh, script Object should NOT be null or bad things will happen");
    1:   if (!scriptObject)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   JSObject * targetClassObject = (JSObject *) aTargetClassObject;
    1:   JSObject * globalObject = sgo->GetGlobalJSObject();
    1: 
    1:   // now we want to reevaluate our property using aContext and the script object for this window...
    1:   if (mJSMethodObject && targetClassObject) {
    1:     nsDependentString name(mName);
    1:     JSAutoRequest ar(cx);
55601:     JSAutoEnterCompartment ac;
55601: 
55631:     if (!ac.enter(cx, globalObject)) {
55601:       return NS_ERROR_UNEXPECTED;
55601:     }
55601: 
    1:     JSObject * method = ::JS_CloneFunctionObject(cx, mJSMethodObject, globalObject);
    1:     if (!method) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     if (!::JS_DefineUCProperty(cx, targetClassObject,
 3233:                                reinterpret_cast<const jschar*>(mName), 
    1:                                name.Length(), OBJECT_TO_JSVAL(method),
    1:                                NULL, NULL, JSPROP_ENUMERATE)) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult 
    1: nsXBLProtoImplMethod::CompileMember(nsIScriptContext* aContext, const nsCString& aClassStr,
82795:                                     JSObject* aClassObject)
    1: {
41653:   NS_TIME_FUNCTION_MIN(5);
11594:   NS_PRECONDITION(!IsCompiled(),
    1:                   "Trying to compile an already-compiled method");
    1:   NS_PRECONDITION(aClassObject,
    1:                   "Must have class object to compile");
    1: 
11594:   nsXBLUncompiledMethod* uncompiledMethod = GetUncompiledMethod();
    1: 
    1:   // No parameters or body was supplied, so don't install method.
11594:   if (!uncompiledMethod) {
11594:     // Early return after which we consider ourselves compiled.
11594:     mJSMethodObject = nsnull;
11594: 
    1:     return NS_OK;
11594:   }
    1: 
    1:   // Don't install method if no name was supplied.
    1:   if (!mName) {
11594:     delete uncompiledMethod;
11594: 
11594:     // Early return after which we consider ourselves compiled.
11594:     mJSMethodObject = nsnull;
11594: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   // We have a method.
    1:   // Allocate an array for our arguments.
11594:   PRInt32 paramCount = uncompiledMethod->GetParameterCount();
    1:   char** args = nsnull;
    1:   if (paramCount > 0) {
    1:     args = new char*[paramCount];
    1:     if (!args)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     // Add our parameters to our args array.
    1:     PRInt32 argPos = 0; 
11594:     for (nsXBLParameter* curr = uncompiledMethod->mParameters; 
    1:          curr; 
    1:          curr = curr->mNext) {
    1:       args[argPos] = curr->mName;
    1:       argPos++;
    1:     }
31358:   }
    1: 
    1:   // Get the body
    1:   nsDependentString body;
11594:   PRUnichar *bodyText = uncompiledMethod->mBodyText.GetText();
    1:   if (bodyText)
    1:     body.Rebind(bodyText);
    1: 
    1:   // Now that we have a body and args, compile the function
    1:   // and then define it.
    1:   NS_ConvertUTF16toUTF8 cname(mName);
    1:   nsCAutoString functionUri(aClassStr);
    1:   PRInt32 hash = functionUri.RFindChar('#');
    1:   if (hash != kNotFound) {
    1:     functionUri.Truncate(hash);
    1:   }
    1: 
    1:   JSObject* methodObject = nsnull;
    1:   nsresult rv = aContext->CompileFunction(aClassObject,
    1:                                           cname,
    1:                                           paramCount,
82797:                                           const_cast<const char**>(args),
    1:                                           body, 
    1:                                           functionUri.get(),
11594:                                           uncompiledMethod->mBodyText.GetLineNumber(),
11775:                                           JSVERSION_LATEST,
80486:                                           true,
82797:                                           &methodObject);
    1: 
    1:   // Destroy our uncompiled method and delete our arg list.
11594:   delete uncompiledMethod;
    1:   delete [] args;
    1:   if (NS_FAILED(rv)) {
11594:     SetUncompiledMethod(nsnull);
    1:     return rv;
    1:   }
    1: 
    1:   mJSMethodObject = methodObject;
    1: 
11594:   return NS_OK;
    1: }
    1: 
 1829: void
 7230: nsXBLProtoImplMethod::Trace(TraceCallback aCallback, void *aClosure) const
 1829: {
11594:   if (IsCompiled() && mJSMethodObject) {
69023:     aCallback(nsIProgrammingLanguage::JAVASCRIPT, mJSMethodObject, "mJSMethodObject", aClosure);
 7230:   }
 1829: }
 1829: 
    1: nsresult
81367: nsXBLProtoImplMethod::Read(nsIScriptContext* aContext,
81367:                            nsIObjectInputStream* aStream)
81367: {
82291:   nsresult rv = XBL_DeserializeFunction(aContext, aStream, &mJSMethodObject);
81367:   if (NS_FAILED(rv)) {
81367:     SetUncompiledMethod(nsnull);
81367:     return rv;
81367:   }
81367: 
81367: #ifdef DEBUG
81367:   mIsCompiled = true;
81367: #endif
81367: 
81367:   return NS_OK;
81367: }
81367: 
81367: nsresult
81367: nsXBLProtoImplMethod::Write(nsIScriptContext* aContext,
81367:                             nsIObjectOutputStream* aStream)
81367: {
90008:   if (mJSMethodObject) {
81367:     nsresult rv = aStream->Write8(XBLBinding_Serialize_Method);
81367:     NS_ENSURE_SUCCESS(rv, rv);
81367: 
81367:     rv = aStream->WriteWStringZ(mName);
81367:     NS_ENSURE_SUCCESS(rv, rv);
81367: 
81368:     return XBL_SerializeFunction(aContext, aStream, mJSMethodObject);
81367:   }
81367: 
90008:   return NS_OK;
90008: }
90008: 
81367: nsresult
    1: nsXBLProtoImplAnonymousMethod::Execute(nsIContent* aBoundElement)
    1: {
11594:   NS_PRECONDITION(IsCompiled(), "Can't execute uncompiled method");
    1:   
    1:   if (!mJSMethodObject) {
    1:     // Nothing to do here
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Get the script context the same way
    1:   // nsXBLProtoImpl::InstallImplementation does.
80526:   nsIDocument* document = aBoundElement->OwnerDoc();
    1: 
    1:   nsIScriptGlobalObject* global = document->GetScriptGlobalObject();
    1:   if (!global) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIScriptContext> context = global->GetContext();
    1:   if (!context) {
    1:     return NS_OK;
    1:   }
    1:   
78415:   JSContext* cx = context->GetNativeContext();
    1: 
    1:   JSObject* globalObject = global->GetGlobalJSObject();
    1: 
    1:   nsCOMPtr<nsIXPConnectJSObjectHolder> wrapper;
31981:   jsval v;
    1:   nsresult rv =
31981:     nsContentUtils::WrapNative(cx, globalObject, aBoundElement, &v,
    1:                                getter_AddRefs(wrapper));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
31981:   JSObject* thisObject = JSVAL_TO_OBJECT(v);
    1: 
    1:   JSAutoRequest ar(cx);
55631:   JSAutoEnterCompartment ac;
55631: 
55631:   if (!ac.enter(cx, thisObject))
55631:     return NS_ERROR_UNEXPECTED;
    1: 
    1:   // Clone the function object, using thisObject as the parent so "this" is in
    1:   // the scope chain of the resulting function (for backwards compat to the
    1:   // days when this was an event handler).
    1:   JSObject* method = ::JS_CloneFunctionObject(cx, mJSMethodObject, thisObject);
    1:   if (!method)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   // Now call the method
    1: 
    1:   // Use nsCxPusher to make sure we call ScriptEvaluated when we're done.
 6475:   nsCxPusher pusher;
 6475:   NS_ENSURE_STATE(pusher.Push(aBoundElement));
    1: 
    1:   // Check whether it's OK to call the method.
    1:   rv = nsContentUtils::GetSecurityManager()->CheckFunctionAccess(cx, method,
    1:                                                                  thisObject);
    1: 
    1:   JSBool ok = JS_TRUE;
    1:   if (NS_SUCCEEDED(rv)) {
    1:     jsval retval;
    1:     ok = ::JS_CallFunctionValue(cx, thisObject, OBJECT_TO_JSVAL(method),
    1:                                 0 /* argc */, nsnull /* argv */, &retval);
    1:   }
    1: 
    1:   if (!ok) {
28612:     // If a constructor or destructor threw an exception, it doesn't stop
28612:     // anything else.  We just report it.  Note that we need to set aside the
28612:     // frame chain here, since the constructor invocation is not related to
28612:     // whatever is on the stack right now, really.
71697:     JSBool saved = JS_SaveFrameChain(cx);
71697:     JS_ReportPendingException(cx);
71697:     if (saved)
71697:         JS_RestoreFrameChain(cx);
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
81367: 
81367: nsresult
81367: nsXBLProtoImplAnonymousMethod::Write(nsIScriptContext* aContext,
81367:                                      nsIObjectOutputStream* aStream,
81367:                                      XBLBindingSerializeDetails aType)
81367: {
81367:   if (mJSMethodObject) {
81367:     nsresult rv = aStream->Write8(aType);
81367:     NS_ENSURE_SUCCESS(rv, rv);
81367: 
81368:     rv = XBL_SerializeFunction(aContext, aStream, mJSMethodObject);
81367:     NS_ENSURE_SUCCESS(rv, rv);
81367:   }
81367: 
81367:   return NS_OK;
81367: }
