38504: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
10217:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jsobj_h___
    1: #define jsobj_h___
61451: 
61451: /* Gross special case for Gecko, which defines malloc/calloc/free. */
61451: #ifdef mozilla_mozalloc_macro_wrappers_h
61451: #  define JS_OBJ_UNDEFD_MOZALLOC_WRAPPERS
61451: /* The "anti-header" */
61451: #  include "mozilla/mozalloc_undef_macro_wrappers.h"
61451: #endif
61451: 
    1: /*
    1:  * JS object definitions.
    1:  *
    1:  * A JS object consists of a possibly-shared object descriptor containing
    1:  * ordered property names, called the map; and a dense vector of property
    1:  * values, called slots.  The map/slot pointer pair is GC'ed, while the map
    1:  * is reference counted and the slot vector is malloc'ed.
    1:  */
40901: #include "jsapi.h"
55477: #include "jshash.h"
36991: #include "jspubtd.h"
    1: #include "jsprvtd.h"
52503: #include "jslock.h"
48470: #include "jsvalue.h"
47447: #include "jsvector.h"
54707: #include "jscell.h"
36991: 
48470: namespace js {
48470: 
48470: class JSProxyHandler;
48470: class AutoPropDescArrayRooter;
48470: 
53531: namespace mjit {
53531: class Compiler;
53531: }
53531: 
48470: static inline PropertyOp
48470: CastAsPropertyOp(JSObject *object)
48470: {
48470:     return JS_DATA_TO_FUNC_PTR(PropertyOp, object);
48470: }
48470: 
62395: static inline StrictPropertyOp
62395: CastAsStrictPropertyOp(JSObject *object)
62395: {
62395:     return JS_DATA_TO_FUNC_PTR(StrictPropertyOp, object);
62395: }
62395: 
48470: static inline JSPropertyOp
48470: CastAsJSPropertyOp(JSObject *object)
48470: {
48470:     return JS_DATA_TO_FUNC_PTR(JSPropertyOp, object);
48470: }
48470: 
62395: static inline JSStrictPropertyOp
62395: CastAsJSStrictPropertyOp(JSObject *object)
62395: {
62395:     return JS_DATA_TO_FUNC_PTR(JSStrictPropertyOp, object);
62395: }
62395: 
48470: inline JSObject *
48470: CastAsObject(PropertyOp op)
48470: {
48470:     return JS_FUNC_TO_DATA_PTR(JSObject *, op);
48470: }
48470: 
62395: inline JSObject *
62395: CastAsObject(StrictPropertyOp op)
62395: {
62395:     return JS_FUNC_TO_DATA_PTR(JSObject *, op);
62395: }
62395: 
48470: inline Value
48470: CastAsObjectJsval(PropertyOp op)
48470: {
48483:     return ObjectOrNullValue(CastAsObject(op));
48470: }
48470: 
62395: inline Value
62395: CastAsObjectJsval(StrictPropertyOp op)
62395: {
62395:     return ObjectOrNullValue(CastAsObject(op));
62395: }
62395: 
48470: } /* namespace js */
40388: 
36991: /*
36991:  * A representation of ECMA-262 ed. 5's internal property descriptor data
36991:  * structure.
36991:  */
48470: struct PropDesc {
48470:     friend class js::AutoPropDescArrayRooter;
36999: 
48470:     PropDesc();
43214: 
42733:   public:
36991:     /* 8.10.5 ToPropertyDescriptor(Obj) */
48470:     bool initialize(JSContext* cx, jsid id, const js::Value &v);
36991: 
36991:     /* 8.10.1 IsAccessorDescriptor(desc) */
36991:     bool isAccessorDescriptor() const {
36991:         return hasGet || hasSet;
36991:     }
36991: 
36991:     /* 8.10.2 IsDataDescriptor(desc) */
36991:     bool isDataDescriptor() const {
36991:         return hasValue || hasWritable;
36991:     }
36991: 
36991:     /* 8.10.3 IsGenericDescriptor(desc) */
36991:     bool isGenericDescriptor() const {
36991:         return !isAccessorDescriptor() && !isDataDescriptor();
36991:     }
36991: 
36991:     bool configurable() const {
36991:         return (attrs & JSPROP_PERMANENT) == 0;
36991:     }
36991: 
36991:     bool enumerable() const {
36991:         return (attrs & JSPROP_ENUMERATE) != 0;
36991:     }
36991: 
36991:     bool writable() const {
36991:         return (attrs & JSPROP_READONLY) == 0;
36991:     }
36991: 
36991:     JSObject* getterObject() const {
48470:         return get.isUndefined() ? NULL : &get.toObject();
36991:     }
36991:     JSObject* setterObject() const {
48470:         return set.isUndefined() ? NULL : &set.toObject();
36991:     }
36991: 
48470:     const js::Value &getterValue() const {
36991:         return get;
36991:     }
48470:     const js::Value &setterValue() const {
36991:         return set;
36991:     }
36991: 
48470:     js::PropertyOp getter() const {
41860:         return js::CastAsPropertyOp(getterObject());
36991:     }
62395:     js::StrictPropertyOp setter() const {
62395:         return js::CastAsStrictPropertyOp(setterObject());
36991:     }
36991: 
48470:     js::Value pd;
36991:     jsid id;
48470:     js::Value value, get, set;
36991: 
36991:     /* Property descriptor boolean fields. */
36992:     uint8 attrs;
36991: 
36991:     /* Bits indicating which values are set. */
36991:     bool hasGet : 1;
36991:     bool hasSet : 1;
36991:     bool hasValue : 1;
36991:     bool hasWritable : 1;
36991:     bool hasEnumerable : 1;
36991:     bool hasConfigurable : 1;
36991: };
    1: 
47447: namespace js {
48529: 
48470: typedef Vector<PropDesc, 1> PropDescArray;
48529: 
48529: } /* namespace js */
48529: 
48622: struct JSObjectMap {
32777:     uint32 shape;       /* shape identifier */
53652:     uint32 slotSpan;    /* one more than maximum live slot number */
32777: 
57739:     static JS_FRIEND_DATA(const JSObjectMap) sharedNonNative;
57739: 
59729:     explicit JSObjectMap(uint32 shape) : shape(shape), slotSpan(0) {}
59729:     JSObjectMap(uint32 shape, uint32 slotSpan) : shape(shape), slotSpan(slotSpan) {}
32777: 
52503:     enum { INVALID_SHAPE = 0x8fffffff, SHAPELESS = 0xffffffff };
39928: 
48622:     bool isNative() const { return this != &sharedNonNative; }
48622: 
39928:   private:
39928:     /* No copy or assignment semantics. */
39928:     JSObjectMap(JSObjectMap &);
39928:     void operator=(JSObjectMap &);
    1: };
    1: 
48622: /*
48622:  * Unlike js_DefineNativeProperty, propp must be non-null. On success, and if
56567:  * id was found, return true with *objp non-null and with a property of *objp
56567:  * stored in *propp. If successful but id was not found, return true with both
56567:  * *objp and *propp null.
48622:  */
48622: extern JS_FRIEND_API(JSBool)
48622: js_LookupProperty(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
48622:                   JSProperty **propp);
48622: 
48622: extern JSBool
48622: js_DefineProperty(JSContext *cx, JSObject *obj, jsid id, const js::Value *value,
62395:                   js::PropertyOp getter, js::StrictPropertyOp setter, uintN attrs);
48622: 
48622: extern JSBool
56817: js_GetProperty(JSContext *cx, JSObject *obj, JSObject *receiver, jsid id, js::Value *vp);
56817: 
56817: inline JSBool
56817: js_GetProperty(JSContext *cx, JSObject *obj, jsid id, js::Value *vp)
56817: {
56817:     return js_GetProperty(cx, obj, obj, id, vp);
56817: }
48622: 
56211: namespace js {
56211: 
56211: extern JSBool
57734: GetPropertyDefault(JSContext *cx, JSObject *obj, jsid id, const Value &def, Value *vp);
56211: 
56211: } /* namespace js */
56211: 
48622: extern JSBool
56760: js_SetProperty(JSContext *cx, JSObject *obj, jsid id, js::Value *vp, JSBool strict);
48622: 
48622: extern JSBool
48622: js_GetAttributes(JSContext *cx, JSObject *obj, jsid id, uintN *attrsp);
48622: 
48622: extern JSBool
48622: js_SetAttributes(JSContext *cx, JSObject *obj, jsid id, uintN *attrsp);
48622: 
48622: extern JSBool
54169: js_DeleteProperty(JSContext *cx, JSObject *obj, jsid id, js::Value *rval, JSBool strict);
48622: 
48622: extern JS_FRIEND_API(JSBool)
48622: js_Enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
48622:              js::Value *statep, jsid *idp);
48622: 
48622: extern JSType
48622: js_TypeOf(JSContext *cx, JSObject *obj);
48622: 
55632: namespace js {
55632: 
42641: struct NativeIterator;
42641: 
55632: }
55632: 
48624: struct JSFunction;
48599: 
56180: namespace nanojit {
56180: class ValidateWriter;
56180: }
56180: 
    1: /*
27012:  * JSObject struct, with members sized to fit in 32 bytes on 32-bit targets,
27012:  * 64 bytes on 64-bit systems. The JSFunction struct is an extension of this
27012:  * struct allocated from a larger GC size-class.
27012:  *
52503:  * The clasp member stores the js::Class pointer for this object. We do *not*
52503:  * synchronize updates of clasp or flags -- API clients must take care.
52503:  *
48650:  * An object is a delegate if it is on another object's prototype (the proto
48650:  * field) or scope chain (the parent field), and therefore the delegate might
48650:  * be asked implicitly to get or set a property on behalf of another object.
48650:  * Delegates may be accessed directly too, as may any object, but only those
48650:  * objects linked after the head of any prototype or scope chain are flagged
48650:  * as delegates. This definition helps to optimize shape-based property cache
48650:  * invalidation (see Purge{Scope,Proto}Chain in jsobj.cpp).
27012:  *
27012:  * The meaning of the system object bit is defined by the API client. It is
27012:  * set in JS_NewSystemObject and is queried by JS_IsSystemObject (jsdbgapi.h),
27012:  * but it has no intrinsic meaning to SpiderMonkey. Further, JSFILENAME_SYSTEM
27012:  * and JS_FlagScriptFilenamePrefix (also exported via jsdbgapi.h) are intended
27012:  * to be complementary to this bit, but it is up to the API client to implement
27012:  * any such association.
27012:  *
52503:  * Both these flag bits are initially zero; they may be set or queried using
52503:  * the (is|set)(Delegate|System) inline methods.
27012:  *
55746:  * The slots member is a pointer to the slot vector for the object.
55746:  * This can be either a fixed array allocated immediately after the object,
55746:  * or a dynamically allocated array.  A dynamic array can be tested for with
55746:  * hasSlotsArray().  In all cases, capacity gives the number of usable slots.
55746:  * Two objects with the same shape have the same number of fixed slots,
55746:  * and either both have or neither have dynamically allocated slot arrays.
56180:  *
56180:  * If you change this struct, you'll probably need to change the AccSet values
56180:  * in jsbuiltins.h.
26970:  */
54707: struct JSObject : js::gc::Cell {
40796:     /*
40796:      * TraceRecorder must be a friend because it generates code that
40796:      * manipulates JSObjects, which requires peeking under any encapsulation.
56180:      * ValidateWriter must be a friend because it works in tandem with
56180:      * TraceRecorder.
40796:      */
40796:     friend class js::TraceRecorder;
56180:     friend class nanojit::ValidateWriter;
59970:     friend class GetPropCompiler;
40796: 
52503:     /*
52503:      * Private pointer to the last added property and methods to manipulate the
52503:      * list it links among properties in this scope. The {remove,insert} pair
52503:      * for DictionaryProperties assert that the scope is in dictionary mode and
52503:      * any reachable properties are flagged as dictionary properties.
52503:      *
62077:      * For native objects, this field is always a Shape. For non-native objects,
62077:      * it points to the singleton sharedNonNative JSObjectMap, whose shape field
62077:      * is SHAPELESS.
62077:      *
52503:      * NB: these private methods do *not* update this scope's shape to track
52503:      * lastProp->shape after they finish updating the linked list in the case
52503:      * where lastProp is updated. It is up to calling code in jsscope.cpp to
52503:      * call updateShape(cx) after updating lastProp.
52503:      */
52503:     union {
52503:         js::Shape       *lastProp;
52503:         JSObjectMap     *map;
52503:     };
52503: 
52503:     js::Class           *clasp;
52503: 
52503:   private:
52503:     inline void setLastProperty(const js::Shape *shape);
52503:     inline void removeLastProperty();
52503: 
53651: #ifdef DEBUG
53651:     void checkShapeConsistency();
53651: #endif
53651: 
52503:   public:
52503:     inline const js::Shape *lastProperty() const;
52503: 
52503:     inline js::Shape **nativeSearch(jsid id, bool adding = false);
52503:     inline const js::Shape *nativeLookup(jsid id);
52503: 
52503:     inline bool nativeContains(jsid id);
52503:     inline bool nativeContains(const js::Shape &shape);
52503: 
52503:     enum {
52503:         DELEGATE                  =  0x01,
52503:         SYSTEM                    =  0x02,
54563:         NOT_EXTENSIBLE            =  0x04,
52503:         BRANDED                   =  0x08,
52503:         GENERIC                   =  0x10,
52503:         METHOD_BARRIER            =  0x20,
52503:         INDEXED                   =  0x40,
54410:         OWN_SHAPE                 =  0x80,
56192:         BOUND_FUNCTION            = 0x100,
59227:         HAS_EQUALITY              = 0x200,
59227:         METHOD_THRASH_COUNT_MASK  = 0xc00,
59227:         METHOD_THRASH_COUNT_SHIFT =    10,
62900:         METHOD_THRASH_COUNT_MAX   = METHOD_THRASH_COUNT_MASK >> METHOD_THRASH_COUNT_SHIFT
52503:     };
52503: 
53650:     /*
53650:      * Impose a sane upper bound, originally checked only for dense arrays, on
53650:      * number of slots in an object.
53650:      */
52503:     enum {
53650:         NSLOTS_BITS     = 29,
53650:         NSLOTS_LIMIT    = JS_BIT(NSLOTS_BITS)
52503:     };
52503: 
53650:     uint32      flags;                      /* flags */
52503:     uint32      objShape;                   /* copy of lastProp->shape, or override if different */
52503: 
55746:     /* If prototype, lazily filled array of empty shapes for each object size. */
55746:     js::EmptyShape **emptyShapes;
55746: 
55746:     JSObject    *proto;                     /* object's prototype */
55746:     JSObject    *parent;                    /* object's parent */
55746:     void        *privateData;               /* private data */
55746:     jsuword     capacity;                   /* capacity of slots */
55746:     js::Value   *slots;                     /* dynamically allocated slots,
55746:                                                or pointer to fixedSlots() */
55746: 
52503:     /*
53652:      * Return an immutable, shareable, empty shape with the same clasp as this
53652:      * and the same slotSpan as this had when empty.
52503:      *
52503:      * If |this| is the scope of an object |proto|, the resulting scope can be
52503:      * used as the scope of a new object whose prototype is |proto|.
52503:      */
52503:     inline bool canProvideEmptyShape(js::Class *clasp);
55746:     inline js::EmptyShape *getEmptyShape(JSContext *cx, js::Class *aclasp,
55746:                                          /* gc::FinalizeKind */ unsigned kind);
38504: 
52503:     bool isNative() const       { return map->isNative(); }
31452: 
52503:     js::Class *getClass() const { return clasp; }
52503:     JSClass *getJSClass() const { return Jsvalify(clasp); }
48470: 
48470:     bool hasClass(const js::Class *c) const {
48470:         return c == clasp;
37694:     }
37694: 
48622:     const js::ObjectOps *getOps() const {
48622:         return &getClass()->ops;
48622:     }
48622: 
52503:     inline void trace(JSTracer *trc);
40847: 
52503:     uint32 shape() const {
52503:         JS_ASSERT(objShape != JSObjectMap::INVALID_SHAPE);
52503:         return objShape;
31452:     }
31452: 
52503:     bool isDelegate() const     { return !!(flags & DELEGATE); }
52503:     void setDelegate()          { flags |= DELEGATE; }
57779:     void clearDelegate()        { flags &= ~DELEGATE; }
32603: 
54410:     bool isBoundFunction() const { return !!(flags & BOUND_FUNCTION); }
54410: 
32603:     static void setDelegateNullSafe(JSObject *obj) {
32603:         if (obj)
32603:             obj->setDelegate();
32603:     }
32603: 
52503:     bool isSystem() const       { return !!(flags & SYSTEM); }
52503:     void setSystem()            { flags |= SYSTEM; }
52503: 
52503:     /*
52503:      * A branded object contains plain old methods (function-valued properties
52503:      * without magic getters and setters), and its shape evolves whenever a
52503:      * function value changes.
52503:      */
52503:     bool branded()              { return !!(flags & BRANDED); }
52503: 
59227:     /*
59227:      * NB: these return false on shape overflow but do not report any error.
59227:      * Callers who depend on shape guarantees should therefore bail off trace,
59227:      * e.g., on false returns.
59227:      */
57748:     bool brand(JSContext *cx);
52503:     bool unbrand(JSContext *cx);
52503: 
52503:     bool generic()              { return !!(flags & GENERIC); }
52503:     void setGeneric()           { flags |= GENERIC; }
52503: 
59227:     uintN getMethodThrashCount() const {
59227:         return (flags & METHOD_THRASH_COUNT_MASK) >> METHOD_THRASH_COUNT_SHIFT;
59227:     }
59227: 
59227:     void setMethodThrashCount(uintN count) {
59227:         JS_ASSERT(count <= METHOD_THRASH_COUNT_MAX);
59227:         flags = (flags & ~METHOD_THRASH_COUNT_MASK) | (count << METHOD_THRASH_COUNT_SHIFT);
59227:     }
59227: 
57806:     bool hasSpecialEquality() const { return !!(flags & HAS_EQUALITY); }
57806:     void assertSpecialEqualitySynced() const {
57806:         JS_ASSERT(!!clasp->ext.equality == hasSpecialEquality());
57806:     }
57806: 
57806:     /* Sets an object's HAS_EQUALITY flag based on its clasp. */
57806:     inline void syncSpecialEquality();
56192: 
52503:   private:
52503:     void generateOwnShape(JSContext *cx);
52503: 
52503:     void setOwnShape(uint32 s)  { flags |= OWN_SHAPE; objShape = s; }
52503:     void clearOwnShape()        { flags &= ~OWN_SHAPE; objShape = map->shape; }
52503: 
52503:   public:
52503:     inline bool nativeEmpty() const;
52503: 
52503:     bool hasOwnShape() const    { return !!(flags & OWN_SHAPE); }
52503: 
61713:     void setMap(const JSObjectMap *amap) {
52503:         JS_ASSERT(!hasOwnShape());
61713:         map = const_cast<JSObjectMap *>(amap);
52503:         objShape = map->shape;
32603:     }
32603: 
52503:     void setSharedNonNativeMap() {
61713:         setMap(&JSObjectMap::sharedNonNative);
32603:     }
32603: 
52503:     void deletingShapeChange(JSContext *cx, const js::Shape &shape);
60797:     const js::Shape *methodShapeChange(JSContext *cx, const js::Shape &shape);
52503:     bool methodShapeChange(JSContext *cx, uint32 slot);
52503:     void protoShapeChange(JSContext *cx);
52503:     void shadowingShapeChange(JSContext *cx, const js::Shape &shape);
52503:     bool globalObjectOwnShapeChange(JSContext *cx);
62587:     void watchpointOwnShapeChange(JSContext *cx) { generateOwnShape(cx); }
52503: 
54563:     void extensibleShapeChange(JSContext *cx) {
54563:         /* This will do for now. */
54563:         generateOwnShape(cx);
54563:     }
54563: 
52503:     /*
52503:      * A scope has a method barrier when some compiler-created "null closure"
52503:      * function objects (functions that do not use lexical bindings above their
52503:      * scope, only free variable names) that have a correct JSSLOT_PARENT value
52503:      * thanks to the COMPILE_N_GO optimization are stored as newly added direct
52503:      * property values of the scope's object.
52503:      *
52503:      * The de-facto standard JS language requires each evaluation of such a
52503:      * closure to result in a unique (according to === and observable effects)
52503:      * function object. ES3 tried to allow implementations to "join" such
52503:      * objects to a single compiler-created object, but this makes an overt
52503:      * mutation hazard, also an "identity hazard" against interoperation among
52503:      * implementations that join and do not join.
52503:      *
52503:      * To stay compatible with the de-facto standard, we store the compiler-
52503:      * created function object as the method value and set the METHOD_BARRIER
52503:      * flag.
52503:      *
52503:      * The method value is part of the method property tree node's identity, so
52503:      * it effectively  brands the scope with a predictable shape corresponding
52503:      * to the method value, but without the overhead of setting the BRANDED
52503:      * flag, which requires assigning a new shape peculiar to each branded
52503:      * scope. Instead the shape is shared via the property tree among all the
52503:      * scopes referencing the method property tree node.
52503:      *
52503:      * Then when reading from a scope for which scope->hasMethodBarrier() is
52503:      * true, we count on the scope's qualified/guarded shape being unique and
52503:      * add a read barrier that clones the compiler-created function object on
52503:      * demand, reshaping the scope.
52503:      *
52503:      * This read barrier is bypassed when evaluating the callee sub-expression
52503:      * of a call expression (see the JOF_CALLOP opcodes in jsopcode.tbl), since
52503:      * such ops do not present an identity or mutation hazard. The compiler
52503:      * performs this optimization only for null closures that do not use their
52503:      * own name or equivalent built-in references (arguments.callee).
52503:      *
52503:      * The BRANDED write barrier, JSObject::methodWriteBarrer, must check for
52503:      * METHOD_BARRIER too, and regenerate this scope's shape if the method's
52503:      * value is in fact changing.
52503:      */
52503:     bool hasMethodBarrier()     { return !!(flags & METHOD_BARRIER); }
52503:     void setMethodBarrier()     { flags |= METHOD_BARRIER; }
52503: 
52503:     /*
52503:      * Test whether this object may be branded due to method calls, which means
52503:      * any assignment to a function-valued property must regenerate shape; else
52503:      * test whether this object has method properties, which require a method
52503:      * write barrier.
52503:      */
52503:     bool brandedOrHasMethodBarrier() { return !!(flags & (BRANDED | METHOD_BARRIER)); }
52503: 
52503:     /*
52503:      * Read barrier to clone a joined function object stored as a method.
52503:      * Defined in jsobjinlines.h, but not declared inline per standard style in
52503:      * order to avoid gcc warnings.
52503:      */
62790:     const js::Shape *methodReadBarrier(JSContext *cx, const js::Shape &shape, js::Value *vp);
52503: 
52503:     /*
52503:      * Write barrier to check for a change of method value. Defined inline in
52503:      * jsobjinlines.h after methodReadBarrier. The slot flavor is required by
52503:      * JSOP_*GVAR, which deals in slots not shapes, while not deoptimizing to
52503:      * map slot to shape unless JSObject::flags show that this is necessary.
60797:      * The methodShapeChange overload (above) parallels this.
52503:      */
60797:     const js::Shape *methodWriteBarrier(JSContext *cx, const js::Shape &shape, const js::Value &v);
52503:     bool methodWriteBarrier(JSContext *cx, uint32 slot, const js::Value &v);
52503: 
52503:     bool isIndexed() const          { return !!(flags & INDEXED); }
52503:     void setIndexed()               { flags |= INDEXED; }
52503: 
52503:     /*
52503:      * Return true if this object is a native one that has been converted from
52503:      * shared-immutable prototype-rooted shape storage to dictionary-shapes in
52503:      * a doubly-linked list.
52503:      */
52503:     inline bool inDictionaryMode() const;
52503: 
52503:     inline uint32 propertyCount() const;
52503: 
52503:     inline bool hasPropertyTable() const;
52503: 
58534:     /* gc::FinalizeKind */ unsigned finalizeKind() const;
58534: 
55746:     uint32 numSlots() const { return capacity; }
40410: 
53555:     size_t slotsAndStructSize(uint32 nslots) const;
53555:     size_t slotsAndStructSize() const { return slotsAndStructSize(numSlots()); }
53555: 
55746:     inline js::Value* fixedSlots() const;
55746:     inline size_t numFixedSlots() const;
54426: 
55746:     static inline size_t getFixedSlotOffset(size_t slot);
41978: 
41978:   public:
55746:     /* Minimum size for dynamically allocated slots. */
55746:     static const uint32 SLOT_CAPACITY_MIN = 8;
55746: 
41978:     bool allocSlots(JSContext *cx, size_t nslots);
41978:     bool growSlots(JSContext *cx, size_t nslots);
41978:     void shrinkSlots(JSContext *cx, size_t nslots);
41978: 
55746:     bool ensureSlots(JSContext *cx, size_t nslots) {
55746:         if (numSlots() < nslots)
55746:             return growSlots(cx, nslots);
55746:         return true;
55746:     }
55746: 
52503:     /*
52503:      * Ensure that the object has at least JSCLASS_RESERVED_SLOTS(clasp) +
52503:      * nreserved slots.
52503:      *
52503:      * This method may be called only for native objects freshly created using
52503:      * NewObject or one of its variant where the new object will both (a) never
52503:      * escape to script and (b) never be extended with ad-hoc properties that
52503:      * would try to allocate higher slots without the fresh object first having
52503:      * its map set to a shape path that maps those slots.
52503:      *
52503:      * Block objects satisfy (a) and (b), as there is no evil eval-based way to
52503:      * add ad-hoc properties to a Block instance. Call objects satisfy (a) and
52503:      * (b) as well, because the compiler-created Shape path that covers args,
52503:      * vars, and upvars, stored in their callee function in u.i.names, becomes
52503:      * their initial map.
52503:      */
52503:     bool ensureInstanceReservedSlots(JSContext *cx, size_t nreserved);
52503: 
52503:     /*
55746:      * Get a direct pointer to the object's slots.
55746:      * This can be reallocated if the object is modified, watch out!
55746:      */
55746:     js::Value *getSlots() const {
55746:         return slots;
55746:     }
55746: 
55746:     /*
52503:      * NB: ensureClassReservedSlotsForEmptyObject asserts that nativeEmpty()
52503:      * Use ensureClassReservedSlots for any object, either empty or already
52503:      * extended with properties.
52503:      */
52503:     bool ensureClassReservedSlotsForEmptyObject(JSContext *cx);
52503: 
52503:     inline bool ensureClassReservedSlots(JSContext *cx);
52503: 
53652:     uint32 slotSpan() const { return map->slotSpan; }
53650: 
53652:     bool containsSlot(uint32 slot) const { return slot < slotSpan(); }
52503: 
48470:     js::Value& getSlotRef(uintN slot) {
55746:         JS_ASSERT(slot < capacity);
55746:         return slots[slot];
40410:     }
40410: 
56567:     js::Value &nativeGetSlotRef(uintN slot) {
56567:         JS_ASSERT(isNative());
56567:         JS_ASSERT(containsSlot(slot));
56567:         return getSlotRef(slot);
56567:     }
56567: 
48470:     const js::Value &getSlot(uintN slot) const {
55746:         JS_ASSERT(slot < capacity);
55746:         return slots[slot];
40410:     }
40410: 
56567:     const js::Value &nativeGetSlot(uintN slot) const {
56567:         JS_ASSERT(isNative());
56567:         JS_ASSERT(containsSlot(slot));
56567:         return getSlot(slot);
56567:     }
56567: 
48470:     void setSlot(uintN slot, const js::Value &value) {
55746:         JS_ASSERT(slot < capacity);
55746:         slots[slot] = value;
40410:     }
40410: 
56567:     void nativeSetSlot(uintN slot, const js::Value &value) {
56567:         JS_ASSERT(isNative());
56567:         JS_ASSERT(containsSlot(slot));
56567:         return setSlot(slot, value);
56567:     }
40410: 
48470:     inline js::Value getReservedSlot(uintN index) const;
47404: 
52503:     /* Defined in jsscopeinlines.h to avoid including implementation dependencies here. */
52503:     inline void updateShape(JSContext *cx);
52503:     inline void updateFlags(const js::Shape *shape, bool isDefinitelyAtom = false);
32603: 
52503:     /* Extend this object to have shape as its last-added property. */
52503:     inline void extend(JSContext *cx, const js::Shape *shape, bool isDefinitelyAtom = false);
52503: 
52503:     JSObject *getProto() const  { return proto; }
52503:     void clearProto()           { proto = NULL; }
32603: 
32603:     void setProto(JSObject *newProto) {
47505: #ifdef DEBUG
47505:         for (JSObject *obj = newProto; obj; obj = obj->getProto())
47505:             JS_ASSERT(obj != this);
47505: #endif
32603:         setDelegateNullSafe(newProto);
47465:         proto = newProto;
32603:     }
32603: 
32603:     JSObject *getParent() const {
48650:         return parent;
32603:     }
32603: 
32603:     void clearParent() {
48650:         parent = NULL;
32603:     }
32603: 
32603:     void setParent(JSObject *newParent) {
47505: #ifdef DEBUG
47505:         for (JSObject *obj = newParent; obj; obj = obj->getParent())
47505:             JS_ASSERT(obj != this);
47505: #endif
32603:         setDelegateNullSafe(newParent);
48650:         parent = newParent;
32603:     }
32603: 
55601:     JS_FRIEND_API(JSObject *) getGlobal() const;
40424: 
51471:     bool isGlobal() const {
51471:         return !!(getClass()->flags & JSCLASS_IS_GLOBAL);
51471:     }
51471: 
31452:     void *getPrivate() const {
31452:         JS_ASSERT(getClass()->flags & JSCLASS_HAS_PRIVATE);
55746:         return privateData;
31452:     }
31452: 
31452:     void setPrivate(void *data) {
31452:         JS_ASSERT(getClass()->flags & JSCLASS_HAS_PRIVATE);
55746:         privateData = data;
32684:     }
32684: 
54563: 
54563:     /*
54563:      * ES5 meta-object properties and operations.
54563:      */
54563: 
54563:   private:
57813:     enum ImmutabilityType { SEAL, FREEZE };
57813: 
54563:     /*
54563:      * The guts of Object.seal (ES5 15.2.3.8) and Object.freeze (ES5 15.2.3.9): mark the
54563:      * object as non-extensible, and adjust each property's attributes appropriately: each
54563:      * property becomes non-configurable, and if |freeze|, data properties become
54563:      * read-only as well.
54563:      */
57813:     bool sealOrFreeze(JSContext *cx, ImmutabilityType it);
54563: 
54563:   public:
54563:     bool isExtensible() const { return !(flags & NOT_EXTENSIBLE); }
54563:     bool preventExtensions(JSContext *cx, js::AutoIdVector *props);
54563: 
54563:     /* ES5 15.2.3.8: non-extensible, all props non-configurable */
57813:     inline bool seal(JSContext *cx) { return sealOrFreeze(cx, SEAL); }
54563:     /* ES5 15.2.3.9: non-extensible, all properties non-configurable, all data props read-only */
57813:     bool freeze(JSContext *cx) { return sealOrFreeze(cx, FREEZE); }
54563:         
40796:     /*
40901:      * Primitive-specific getters and setters.
40901:      */
40901: 
40901:   private:
55746:     static const uint32 JSSLOT_PRIMITIVE_THIS = 0;
40901: 
40901:   public:
48470:     inline const js::Value &getPrimitiveThis() const;
48470:     inline void setPrimitiveThis(const js::Value &pthis);
40901: 
40901:     /*
40796:      * Array-specific getters and setters (for both dense and slow arrays).
40796:      */
40796: 
40796:     inline uint32 getArrayLength() const;
48537:     inline void setArrayLength(uint32 length);
40864: 
55746:     inline uint32 getDenseArrayCapacity();
55746:     inline js::Value* getDenseArrayElements();
55746:     inline const js::Value &getDenseArrayElement(uintN idx);
55746:     inline js::Value* addressOfDenseArrayElement(uintN idx);
55746:     inline void setDenseArrayElement(uintN idx, const js::Value &val);
55746:     inline void shrinkDenseArrayElements(JSContext *cx, uintN cap);
41850: 
58702:     /*
58702:      * ensureDenseArrayElements ensures that the dense array can hold at least
58702:      * index + extra elements. It returns ED_OK on success, ED_FAILED on
58702:      * failure to grow the array, ED_SPARSE when the array is too sparse to
58702:      * grow (this includes the case of index + extra overflow). In the last
58702:      * two cases the array is kept intact.
58702:      */
58702:     enum EnsureDenseResult { ED_OK, ED_FAILED, ED_SPARSE };
58702:     inline EnsureDenseResult ensureDenseArrayElements(JSContext *cx, uintN index, uintN extra);
58702: 
58702:     /*
58702:      * Check if after growing the dense array will be too sparse.
58702:      * newElementsHint is an estimated number of elements to be added.
58702:      */
58702:     bool willBeSparseDenseArray(uintN requiredCapacity, uintN newElementsHint);
58702: 
43287:     JSBool makeDenseArraySlow(JSContext *cx);
43287: 
40796:     /*
40864:      * Arguments-specific getters and setters.
40864:      */
40864: 
43214:   private:
40864:     /*
59966:      * We represent arguments objects using js_ArgumentsClass and
59966:      * js::StrictArgumentsClass. The two are structured similarly, and methods
59966:      * valid on arguments objects of one class are also generally valid on
59966:      * arguments objects of the other.
40864:      *
59966:      * Arguments objects of either class store arguments length in a slot:
59966:      *
51095:      * JSSLOT_ARGS_LENGTH   - the number of actual arguments and a flag
40864:      *                        indicating whether arguments.length was
51095:      *                        overwritten. This slot is not used to represent
51092:      *                        arguments.length after that property has been
51095:      *                        assigned, even if the new value is integral: it's
51095:      *                        always the original length.
40864:      *
59966:      * Both arguments classes use a slot for storing arguments data:
59966:      *
59966:      * JSSLOT_ARGS_DATA     - pointer to an ArgumentsData structure
59966:      *
59966:      * ArgumentsData for normal arguments stores the value of arguments.callee,
59966:      * as long as that property has not been overwritten. If arguments.callee
59966:      * is overwritten, the corresponding value in ArgumentsData is set to
59966:      * MagicValue(JS_ARGS_HOLE). Strict arguments do not store this value
59966:      * because arguments.callee is a poison pill for strict mode arguments.
59966:      *
59966:      * The ArgumentsData structure also stores argument values. For normal
59966:      * arguments this occurs after the corresponding function has returned, and
59966:      * for strict arguments this occurs when the arguments object is created,
59966:      * or sometimes shortly after (but not observably so). arguments[i] is
59966:      * stored in ArgumentsData.slots[i], accessible via getArgsElement() and
59966:      * setArgsElement(). Deletion of arguments[i] overwrites that slot with
59966:      * MagicValue(JS_ARGS_HOLE); subsequent redefinition of arguments[i] will
59966:      * use a normal property to store the value, ignoring the slot.
59966:      *
59966:      * Non-strict arguments have a private:
59966:      *
59966:      * private              - the function's stack frame until the function
59966:      *                        returns, when it is replaced with null; also,
59966:      *                        JS_ARGUMENTS_OBJECT_ON_TRACE while on trace, if
59966:      *                        arguments was created on trace
59966:      *
59966:      * Technically strict arguments have a private, but it's always null.
59966:      * Conceptually it would be better to remove this oddity, but preserving it
59966:      * allows us to work with arguments objects of either kind more abstractly,
59966:      * so we keep it for now.
40864:      */
55746:     static const uint32 JSSLOT_ARGS_DATA = 1;
40864: 
40864:   public:
52503:     /* Number of extra fixed arguments object slots besides JSSLOT_PRIVATE. */
55746:     static const uint32 JSSLOT_ARGS_LENGTH = 0;
52503:     static const uint32 ARGS_CLASS_RESERVED_SLOTS = 2;
55746:     static const uint32 ARGS_FIRST_FREE_SLOT = ARGS_CLASS_RESERVED_SLOTS + 1;
40864: 
51095:     /* Lower-order bit stolen from the length slot. */
51092:     static const uint32 ARGS_LENGTH_OVERRIDDEN_BIT = 0x1;
51095:     static const uint32 ARGS_PACKED_BITS_COUNT = 1;
51092: 
51092:     /*
51095:      * Set the initial length of the arguments, and mark it as not overridden.
51092:      */
51092:     inline void setArgsLength(uint32 argc);
51092: 
51092:     /*
51092:      * Return the initial length of the arguments.  This may differ from the
51092:      * current value of arguments.length!
51092:      */
51091:     inline uint32 getArgsInitialLength() const;
51092: 
40864:     inline void setArgsLengthOverridden();
41871:     inline bool isArgsLengthOverridden() const;
40864: 
52503:     inline js::ArgumentsData *getArgsData() const;
52503:     inline void setArgsData(js::ArgumentsData *data);
52503: 
48470:     inline const js::Value &getArgsCallee() const;
48470:     inline void setArgsCallee(const js::Value &callee);
40864: 
48470:     inline const js::Value &getArgsElement(uint32 i) const;
57714:     inline js::Value *getArgsElements() const;
55746:     inline js::Value *addressOfArgsElement(uint32 i);
48470:     inline void setArgsElement(uint32 i, const js::Value &v);
41871: 
53840:   private:
53840:     /*
60146:      * Reserved slot structure for Call objects:
60146:      *
60146:      * private               - the stack frame corresponding to the Call object
60146:      *                         until js_PutCallObject or its on-trace analog
60146:      *                         is called, null thereafter
60146:      * JSSLOT_CALL_CALLEE    - callee function for the stack frame, or null if
60146:      *                         the stack frame is for strict mode eval code
60146:      * JSSLOT_CALL_ARGUMENTS - arguments object for non-strict mode eval stack
60146:      *                         frames (not valid for strict mode eval frames)
53840:      */
55746:     static const uint32 JSSLOT_CALL_CALLEE = 0;
55746:     static const uint32 JSSLOT_CALL_ARGUMENTS = 1;
53840: 
53840:   public:
55746:     /* Number of reserved slots. */
53840:     static const uint32 CALL_RESERVED_SLOTS = 2;
53840: 
60243:     /* True if this is for a strict mode eval frame or for a function call. */
60243:     inline bool callIsForEval() const;
60243: 
59969:     /* The stack frame for this Call object, if the frame is still active. */
59969:     inline JSStackFrame *maybeCallObjStackFrame() const;
59969: 
60146:     /*
60146:      * The callee function if this Call object was created for a function
60146:      * invocation, or null if it was created for a strict mode eval frame.
60146:      */
60146:     inline JSObject *getCallObjCallee() const;
53840:     inline JSFunction *getCallObjCalleeFunction() const; 
60146:     inline void setCallObjCallee(JSObject *callee);
53840: 
53840:     inline const js::Value &getCallObjArguments() const;
53840:     inline void setCallObjArguments(const js::Value &v);
53840: 
59969:     /* Returns the formal argument at the given index. */
59969:     inline const js::Value &callObjArg(uintN i) const;
59969:     inline js::Value &callObjArg(uintN i);
59969: 
59969:     /* Returns the variable at the given index. */
59969:     inline const js::Value &callObjVar(uintN i) const;
59969:     inline js::Value &callObjVar(uintN i);
59969: 
40864:     /*
40901:      * Date-specific getters and setters.
40901:      */
40901: 
55746:     static const uint32 JSSLOT_DATE_UTC_TIME = 0;
51077: 
51077:     /*
51077:      * Cached slots holding local properties of the date.
51077:      * These are undefined until the first actual lookup occurs
51077:      * and are reset to undefined whenever the date's time is modified.
51077:      */
55746:     static const uint32 JSSLOT_DATE_COMPONENTS_START = 1;
51077: 
55746:     static const uint32 JSSLOT_DATE_LOCAL_TIME = 1;
55746:     static const uint32 JSSLOT_DATE_LOCAL_YEAR = 2;
55746:     static const uint32 JSSLOT_DATE_LOCAL_MONTH = 3;
55746:     static const uint32 JSSLOT_DATE_LOCAL_DATE = 4;
55746:     static const uint32 JSSLOT_DATE_LOCAL_DAY = 5;
55746:     static const uint32 JSSLOT_DATE_LOCAL_HOURS = 6;
55746:     static const uint32 JSSLOT_DATE_LOCAL_MINUTES = 7;
55746:     static const uint32 JSSLOT_DATE_LOCAL_SECONDS = 8;
40901: 
51077:     static const uint32 DATE_CLASS_RESERVED_SLOTS = 9;
40901: 
48470:     inline const js::Value &getDateUTCTime() const;
48470:     inline void setDateUTCTime(const js::Value &pthis);
40901: 
40901:     /*
48599:      * Function-specific getters and setters.
48599:      */
48599: 
48599:   private:
48624:     friend struct JSFunction;
53531:     friend class js::mjit::Compiler;
48599: 
52503:     /*
52503:      * Flat closures with one or more upvars snapshot the upvars' values into a
52503:      * vector of js::Values referenced from this slot.
52503:      */
55746:     static const uint32 JSSLOT_FLAT_CLOSURE_UPVARS = 0;
52503: 
52503:     /*
52503:      * Null closures set or initialized as methods have these slots. See the
52503:      * "method barrier" comments and methods.
52503:      */
48599: 
55746:     static const uint32 JSSLOT_FUN_METHOD_ATOM = 0;
55746:     static const uint32 JSSLOT_FUN_METHOD_OBJ  = 1;
55746: 
55746:     static const uint32 JSSLOT_BOUND_FUNCTION_THIS       = 0;
55746:     static const uint32 JSSLOT_BOUND_FUNCTION_ARGS_COUNT = 1;
51682: 
48599:   public:
52503:     static const uint32 FUN_CLASS_RESERVED_SLOTS = 2;
52503: 
52503:     inline JSFunction *getFunctionPrivate() const;
52503: 
52503:     inline js::Value *getFlatClosureUpvars() const;
52503:     inline js::Value getFlatClosureUpvar(uint32 i) const;
59969:     inline js::Value &getFlatClosureUpvar(uint32 i);
52503:     inline void setFlatClosureUpvars(js::Value *upvars);
48599: 
48599:     inline bool hasMethodObj(const JSObject& obj) const;
48599:     inline void setMethodObj(JSObject& obj);
48599: 
52503:     inline bool initBoundFunction(JSContext *cx, const js::Value &thisArg,
51682:                                   const js::Value *args, uintN argslen);
51682: 
51682:     inline JSObject *getBoundFunctionTarget() const;
51682:     inline const js::Value &getBoundFunctionThis() const;
51682:     inline const js::Value *getBoundFunctionArguments(uintN &argslen) const;
51682: 
48599:     /*
40901:      * RegExp-specific getters and setters.
40901:      */
40901: 
40901:   private:
55746:     static const uint32 JSSLOT_REGEXP_LAST_INDEX = 0;
40901: 
40901:   public:
52503:     static const uint32 REGEXP_CLASS_RESERVED_SLOTS = 1;
40901: 
48470:     inline const js::Value &getRegExpLastIndex() const;
48470:     inline void setRegExpLastIndex(const js::Value &v);
48544:     inline void setRegExpLastIndex(jsdouble d);
40901:     inline void zeroRegExpLastIndex();
40901: 
40901:     /*
42641:      * Iterator-specific getters and setters.
42641:      */
42641: 
55632:     inline js::NativeIterator *getNativeIterator() const;
55632:     inline void setNativeIterator(js::NativeIterator *);
42641: 
42641:     /*
42693:      * XML-related getters and setters.
42693:      */
42693: 
42693:     /*
42693:      * Slots for XML-related classes are as follows:
42693:      * - js_NamespaceClass.base reserves the *_NAME_* and *_NAMESPACE_* slots.
42693:      * - js_QNameClass.base, js_AttributeNameClass, js_AnyNameClass reserve
42693:      *   the *_NAME_* and *_QNAME_* slots.
42693:      * - Others (js_XMLClass, js_XMLFilterClass) don't reserve any slots.
42693:      */
42693:   private:
55746:     static const uint32 JSSLOT_NAME_PREFIX          = 0;   // shared
55746:     static const uint32 JSSLOT_NAME_URI             = 1;   // shared
42693: 
55746:     static const uint32 JSSLOT_NAMESPACE_DECLARED   = 2;
42693: 
55746:     static const uint32 JSSLOT_QNAME_LOCAL_NAME     = 2;
42693: 
42693:   public:
52503:     static const uint32 NAMESPACE_CLASS_RESERVED_SLOTS = 3;
52503:     static const uint32 QNAME_CLASS_RESERVED_SLOTS     = 3;
42693: 
59890:     inline JSLinearString *getNamePrefix() const;
59890:     inline jsval getNamePrefixVal() const;
59890:     inline void setNamePrefix(JSLinearString *prefix);
59890:     inline void clearNamePrefix();
42693: 
59890:     inline JSLinearString *getNameURI() const;
59890:     inline jsval getNameURIVal() const;
59890:     inline void setNameURI(JSLinearString *uri);
42693: 
42693:     inline jsval getNamespaceDeclared() const;
42693:     inline void setNamespaceDeclared(jsval decl);
42693: 
59890:     inline JSLinearString *getQNameLocalName() const;
59890:     inline jsval getQNameLocalNameVal() const;
59890:     inline void setQNameLocalName(JSLinearString *name);
42693: 
42693:     /*
42733:      * Proxy-specific getters and setters.
42733:      */
42733: 
47498:     inline js::JSProxyHandler *getProxyHandler() const;
48470:     inline const js::Value &getProxyPrivate() const;
48470:     inline void setProxyPrivate(const js::Value &priv);
55599:     inline const js::Value &getProxyExtra() const;
55599:     inline void setProxyExtra(const js::Value &extra);
42733: 
42733:     /*
47417:      * With object-specific getters and setters.
47417:      */
47417:     inline JSObject *getWithThis() const;
47417:     inline void setWithThis(JSObject *thisp);
47417: 
47417:     /*
40796:      * Back to generic stuff.
40796:      */
42733:     inline bool isCallable();
38630: 
32684:     /* The map field is not initialized here and should be set separately. */
55746:     void init(JSContext *cx, js::Class *aclasp, JSObject *proto, JSObject *parent,
55746:               void *priv, bool useHoles);
32684: 
52503:     inline void finish(JSContext *cx);
57817:     JS_ALWAYS_INLINE void finalize(JSContext *cx);
32560: 
35117:     /*
35117:      * Like init, but also initializes map. The catch: proto must be the result
35117:      * of a call to js_InitClass(...clasp, ...).
35117:      */
55746:     inline bool initSharingEmptyShape(JSContext *cx,
55746:                                       js::Class *clasp,
53638:                                       JSObject *proto,
53638:                                       JSObject *parent,
53638:                                       void *priv,
55746:                                       /* gc::FinalizeKind */ unsigned kind);
35117: 
55746:     inline bool hasSlotsArray() const;
36997: 
36997:     /* This method can only be called when hasSlotsArray() returns true. */
36997:     inline void freeSlotsArray(JSContext *cx);
36997: 
55746:     /* Free the slots array and copy slots that fit into the fixed array. */
55746:     inline void revertToFixedSlots(JSContext *cx);
55746: 
52503:     inline bool hasProperty(JSContext *cx, jsid id, bool *foundp, uintN flags = 0);
52503: 
58979:     /*
58979:      * Allocate and free an object slot. Note that freeSlot is infallible: it
58979:      * returns true iff this is a dictionary-mode object and the freed slot was
58979:      * added to the freelist.
58979:      *
58979:      * FIXME: bug 593129 -- slot allocation should be done by object methods
58979:      * after calling object-parameter-free shape methods, avoiding coupling
58979:      * logic across the object vs. shape module wall.
58979:      */
52503:     bool allocSlot(JSContext *cx, uint32 *slotp);
58749:     bool freeSlot(JSContext *cx, uint32 slot);
52503: 
60780:   public:
54587:     bool reportReadOnly(JSContext* cx, jsid id, uintN report = JSREPORT_ERROR);
54587:     bool reportNotConfigurable(JSContext* cx, jsid id, uintN report = JSREPORT_ERROR);
54587:     bool reportNotExtensible(JSContext *cx, uintN report = JSREPORT_ERROR);
54587: 
52503:   private:
52503:     js::Shape *getChildProperty(JSContext *cx, js::Shape *parent, js::Shape &child);
52503: 
54587:     /*
54587:      * Internal helper that adds a shape not yet mapped by this object.
54587:      *
54587:      * Notes:
54587:      * 1. getter and setter must be normalized based on flags (see jsscope.cpp).
54587:      * 2. !isExtensible() checking must be done by callers.
54587:      */
54587:     const js::Shape *addPropertyInternal(JSContext *cx, jsid id,
62395:                                          js::PropertyOp getter, js::StrictPropertyOp setter,
52503:                                          uint32 slot, uintN attrs,
52503:                                          uintN flags, intN shortid,
52503:                                          js::Shape **spp);
52503: 
52503:     bool toDictionaryMode(JSContext *cx);
52503: 
52503:   public:
52503:     /* Add a property whose id is not yet in this scope. */
52503:     const js::Shape *addProperty(JSContext *cx, jsid id,
62395:                                  js::PropertyOp getter, js::StrictPropertyOp setter,
52503:                                  uint32 slot, uintN attrs,
52503:                                  uintN flags, intN shortid);
52503: 
52503:     /* Add a data property whose id is not yet in this scope. */
52503:     const js::Shape *addDataProperty(JSContext *cx, jsid id, uint32 slot, uintN attrs) {
52503:         JS_ASSERT(!(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
52503:         return addProperty(cx, id, NULL, NULL, slot, attrs, 0, 0);
52503:     }
52503: 
52503:     /* Add or overwrite a property for id in this scope. */
52503:     const js::Shape *putProperty(JSContext *cx, jsid id,
62395:                                  js::PropertyOp getter, js::StrictPropertyOp setter,
52503:                                  uint32 slot, uintN attrs,
52503:                                  uintN flags, intN shortid);
52503: 
52503:     /* Change the given property into a sibling with the same id in this scope. */
52503:     const js::Shape *changeProperty(JSContext *cx, const js::Shape *shape, uintN attrs, uintN mask,
62395:                                     js::PropertyOp getter, js::StrictPropertyOp setter);
52503: 
54587:     /* Remove the property named by id from this object. */
52503:     bool removeProperty(JSContext *cx, jsid id);
52503: 
52503:     /* Clear the scope, making it empty. */
52503:     void clear(JSContext *cx);
52503: 
48622:     JSBool lookupProperty(JSContext *cx, jsid id, JSObject **objp, JSProperty **propp) {
54746:         js::LookupPropOp op = getOps()->lookupProperty;
48622:         return (op ? op : js_LookupProperty)(cx, this, id, objp, propp);
31501:     }
31501: 
48470:     JSBool defineProperty(JSContext *cx, jsid id, const js::Value &value,
48470:                           js::PropertyOp getter = js::PropertyStub,
62395:                           js::StrictPropertyOp setter = js::StrictPropertyStub,
33165:                           uintN attrs = JSPROP_ENUMERATE) {
48622:         js::DefinePropOp op = getOps()->defineProperty;
48622:         return (op ? op : js_DefineProperty)(cx, this, id, &value, getter, setter, attrs);
31501:     }
31501: 
56817:     JSBool getProperty(JSContext *cx, JSObject *receiver, jsid id, js::Value *vp) {
56817:         js::PropertyIdOp op = getOps()->getProperty;
56817:         return (op ? op : (js::PropertyIdOp)js_GetProperty)(cx, this, receiver, id, vp);
56817:     }
56817: 
56760:     JSBool getProperty(JSContext *cx, jsid id, js::Value *vp) {
56817:         return getProperty(cx, this, id, vp);
31501:     }
31501: 
54169:     JSBool setProperty(JSContext *cx, jsid id, js::Value *vp, JSBool strict) {
56760:         js::StrictPropertyIdOp op = getOps()->setProperty;
56760:         return (op ? op : js_SetProperty)(cx, this, id, vp, strict);
31501:     }
31501: 
43290:     JSBool getAttributes(JSContext *cx, jsid id, uintN *attrsp) {
54746:         js::AttributesOp op = getOps()->getAttributes;
48622:         return (op ? op : js_GetAttributes)(cx, this, id, attrsp);
31501:     }
31501: 
43290:     JSBool setAttributes(JSContext *cx, jsid id, uintN *attrsp) {
54746:         js::AttributesOp op = getOps()->setAttributes;
48622:         return (op ? op : js_SetAttributes)(cx, this, id, attrsp);
31501:     }
31501: 
54169:     JSBool deleteProperty(JSContext *cx, jsid id, js::Value *rval, JSBool strict) {
56817:         js::DeleteIdOp op = getOps()->deleteProperty;
54169:         return (op ? op : js_DeleteProperty)(cx, this, id, rval, strict);
31501:     }
31501: 
48622:     JSBool enumerate(JSContext *cx, JSIterateOp iterop, js::Value *statep, jsid *idp) {
48622:         js::NewEnumerateOp op = getOps()->enumerate;
48622:         return (op ? op : js_Enumerate)(cx, this, iterop, statep, idp);
31501:     }
31501: 
38633:     JSType typeOf(JSContext *cx) {
54746:         js::TypeOfOp op = getOps()->typeOf;
48622:         return (op ? op : js_TypeOf)(cx, this);
38633:     }
38633: 
31501:     /* These four are time-optimized to avoid stub calls. */
32603:     JSObject *thisObject(JSContext *cx) {
48622:         JSObjectOp op = getOps()->thisObject;
48622:         return op ? op(cx, this) : this;
31501:     }
48622: 
48470:     static bool thisObject(JSContext *cx, const js::Value &v, js::Value *vp);
31501: 
55606:     inline JSCompartment *getCompartment() const;
43286: 
51090:     inline JSObject *getThrowTypeError() const;
51090: 
58534:     JS_FRIEND_API(JSObject *) clone(JSContext *cx, JSObject *proto, JSObject *parent);
58534:     JS_FRIEND_API(bool) copyPropertiesFrom(JSContext *cx, JSObject *obj);
58534:     bool swap(JSContext *cx, JSObject *other);
55746: 
54426:     const js::Shape *defineBlockVariable(JSContext *cx, jsid id, intN index);
54425: 
48599:     inline bool canHaveMethodBarrier() const;
48599: 
40405:     inline bool isArguments() const;
51095:     inline bool isNormalArguments() const;
51095:     inline bool isStrictArguments() const;
37003:     inline bool isArray() const;
37003:     inline bool isDenseArray() const;
40796:     inline bool isSlowArray() const;
40901:     inline bool isNumber() const;
40901:     inline bool isBoolean() const;
40901:     inline bool isString() const;
40901:     inline bool isPrimitive() const;
40901:     inline bool isDate() const;
37003:     inline bool isFunction() const;
48599:     inline bool isObject() const;
48599:     inline bool isWith() const;
48599:     inline bool isBlock() const;
53650:     inline bool isStaticBlock() const;
53650:     inline bool isClonedBlock() const;
52503:     inline bool isCall() const;
37003:     inline bool isRegExp() const;
37003:     inline bool isXML() const;
48591:     inline bool isXMLId() const;
42693:     inline bool isNamespace() const;
42693:     inline bool isQName() const;
37685: 
42733:     inline bool isProxy() const;
42733:     inline bool isObjectProxy() const;
42733:     inline bool isFunctionProxy() const;
42733: 
47574:     JS_FRIEND_API(bool) isWrapper() const;
47574:     JS_FRIEND_API(JSObject *) unwrap(uintN *flagsp = NULL);
47498: 
48470:     inline void initArrayClass();
32603: };
31501: 
55746: /* Check alignment for any fixed slots allocated after the object. */
55746: JS_STATIC_ASSERT(sizeof(JSObject) % sizeof(js::Value) == 0);
54426: 
55746: inline js::Value*
55746: JSObject::fixedSlots() const {
55746:     return (js::Value*) (jsuword(this) + sizeof(JSObject));
55746: }
54426: 
55746: inline bool
55746: JSObject::hasSlotsArray() const { return this->slots != fixedSlots(); }
54426: 
55746: /* static */ inline size_t
55746: JSObject::getFixedSlotOffset(size_t slot) {
55746:     return sizeof(JSObject) + (slot * sizeof(js::Value));
55746: }
55746: 
55746: struct JSObject_Slots2 : JSObject { js::Value fslots[2]; };
55746: struct JSObject_Slots4 : JSObject { js::Value fslots[4]; };
55746: struct JSObject_Slots8 : JSObject { js::Value fslots[8]; };
55746: struct JSObject_Slots12 : JSObject { js::Value fslots[12]; };
55746: struct JSObject_Slots16 : JSObject { js::Value fslots[16]; };
55746: 
55746: #define JSSLOT_FREE(clasp)  JSCLASS_RESERVED_SLOTS(clasp)
27891: 
    1: #ifdef JS_THREADSAFE
    1: 
    1: /*
    1:  * The GC runs only when all threads except the one on which the GC is active
40410:  * are suspended at GC-safe points, so calling obj->getSlot() from the GC's
42715:  * thread is safe when rt->gcRunning is set. See jsgc.cpp for details.
    1:  */
    1: #define THREAD_IS_RUNNING_GC(rt, thread)                                      \
    1:     ((rt)->gcRunning && (rt)->gcThread == (thread))
    1: 
    1: #define CX_THREAD_IS_RUNNING_GC(cx)                                           \
    1:     THREAD_IS_RUNNING_GC((cx)->runtime, (cx)->thread)
    1: 
40410: #endif /* JS_THREADSAFE */
    1: 
32603: inline void
31501: OBJ_TO_INNER_OBJECT(JSContext *cx, JSObject *&obj)
31501: {
48622:     if (JSObjectOp op = obj->getClass()->ext.innerObject)
48622:         obj = op(cx, obj);
31501: }
31501: 
32603: inline void
31501: OBJ_TO_OUTER_OBJECT(JSContext *cx, JSObject *&obj)
31501: {
48622:     if (JSObjectOp op = obj->getClass()->ext.outerObject)
48622:         obj = op(cx, obj);
31501: }
47485: 
48470: class JSValueArray {
47485:   public:
47485:     jsval *array;
47485:     size_t length;
47485: 
48470:     JSValueArray(jsval *v, size_t c) : array(v), length(c) {}
47485: };
31501: 
48470: class ValueArray {
48470:   public:
48470:     js::Value *array;
48470:     size_t length;
48470: 
48470:     ValueArray(js::Value *v, size_t c) : array(v), length(c) {}
48470: };
48470: 
48470: extern js::Class js_ObjectClass;
48470: extern js::Class js_WithClass;
48470: extern js::Class js_BlockClass;
    1: 
48599: inline bool JSObject::isObject() const { return getClass() == &js_ObjectClass; }
48599: inline bool JSObject::isWith() const   { return getClass() == &js_WithClass; }
48599: inline bool JSObject::isBlock() const  { return getClass() == &js_BlockClass; }
48599: 
    1: /*
    1:  * Block scope object macros.  The slots reserved by js_BlockClass are:
    1:  *
55746:  *   private              JSStackFrame *    active frame pointer or null
    1:  *   JSSLOT_BLOCK_DEPTH   int               depth of block slots in frame
    1:  *
    1:  * After JSSLOT_BLOCK_DEPTH come one or more slots for the block locals.
    1:  *
    1:  * A With object is like a Block object, in that both have one reserved slot
    1:  * telling the stack depth of the relevant slots (the slot whose value is the
    1:  * object named in the with statement, the slots containing the block's local
    1:  * variables); and both have a private slot referring to the JSStackFrame in
    1:  * whose activation they were created (or null if the with or block object
    1:  * outlives the frame).
    1:  */
55746: static const uint32 JSSLOT_BLOCK_DEPTH = 0;
54840: static const uint32 JSSLOT_BLOCK_FIRST_FREE_SLOT = JSSLOT_BLOCK_DEPTH + 1;
    1: 
53650: inline bool
53650: JSObject::isStaticBlock() const
30645: {
53650:     return isBlock() && !getProto();
53650: }
53650: 
53650: inline bool
53650: JSObject::isClonedBlock() const
53650: {
53650:     return isBlock() && !!getProto();
30645: }
30645: 
55746: static const uint32 JSSLOT_WITH_THIS = 1;
47417: 
    1: #define OBJ_BLOCK_COUNT(cx,obj)                                               \
53650:     (obj)->propertyCount()
    1: #define OBJ_BLOCK_DEPTH(cx,obj)                                               \
53650:     (obj)->getSlot(JSSLOT_BLOCK_DEPTH).toInt32()
    1: #define OBJ_SET_BLOCK_DEPTH(cx,obj,depth)                                     \
53650:     (obj)->setSlot(JSSLOT_BLOCK_DEPTH, Value(Int32Value(depth)))
    1: 
    1: /*
    1:  * To make sure this slot is well-defined, always call js_NewWithObject to
    1:  * create a With object, don't call js_NewObject directly.  When creating a
    1:  * With object that does not correspond to a stack slot, pass -1 for depth.
    1:  *
    1:  * When popping the stack across this object's "with" statement, client code
31452:  * must call withobj->setPrivate(NULL).
    1:  */
22652: extern JS_REQUIRES_STACK JSObject *
    1: js_NewWithObject(JSContext *cx, JSObject *proto, JSObject *parent, jsint depth);
    1: 
42672: inline JSObject *
42672: js_UnwrapWithObject(JSContext *cx, JSObject *withobj)
42672: {
42672:     JS_ASSERT(withobj->getClass() == &js_WithClass);
42672:     return withobj->getProto();
42672: }
42672: 
    1: /*
    1:  * Create a new block scope object not linked to any proto or parent object.
    1:  * Blocks are created by the compiler to reify let blocks and comprehensions.
    1:  * Only when dynamic scope is captured do they need to be cloned and spliced
    1:  * into an active scope chain.
    1:  */
    1: extern JSObject *
    1: js_NewBlockObject(JSContext *cx);
    1: 
    1: extern JSObject *
30645: js_CloneBlockObject(JSContext *cx, JSObject *proto, JSStackFrame *fp);
    1: 
22652: extern JS_REQUIRES_STACK JSBool
11859: js_PutBlockObject(JSContext *cx, JSBool normalUnwind);
    1: 
28093: JSBool
28093: js_XDRBlockObject(JSXDRState *xdr, JSObject **objp);
28093: 
    1: struct JSSharpObjectMap {
    1:     jsrefcount  depth;
    1:     jsatomid    sharpgen;
    1:     JSHashTable *table;
    1: };
    1: 
    1: #define SHARP_BIT       ((jsatomid) 1)
    1: #define BUSY_BIT        ((jsatomid) 2)
    1: #define SHARP_ID_SHIFT  2
40292: #define IS_SHARP(he)    (uintptr_t((he)->value) & SHARP_BIT)
40292: #define MAKE_SHARP(he)  ((he)->value = (void *) (uintptr_t((he)->value)|SHARP_BIT))
40292: #define IS_BUSY(he)     (uintptr_t((he)->value) & BUSY_BIT)
40292: #define MAKE_BUSY(he)   ((he)->value = (void *) (uintptr_t((he)->value)|BUSY_BIT))
40292: #define CLEAR_BUSY(he)  ((he)->value = (void *) (uintptr_t((he)->value)&~BUSY_BIT))
    1: 
    1: extern JSHashEntry *
    1: js_EnterSharpObject(JSContext *cx, JSObject *obj, JSIdArray **idap,
    1:                     jschar **sp);
    1: 
    1: extern void
    1: js_LeaveSharpObject(JSContext *cx, JSIdArray **idap);
    1: 
    1: /*
    1:  * Mark objects stored in map if GC happens between js_EnterSharpObject
    1:  * and js_LeaveSharpObject. GC calls this when map->depth > 0.
    1:  */
    1: extern void
  583: js_TraceSharpMap(JSTracer *trc, JSSharpObjectMap *map);
    1: 
    1: extern JSBool
54746: js_HasOwnPropertyHelper(JSContext *cx, js::LookupPropOp lookup, uintN argc,
48470:                         js::Value *vp);
    1: 
18062: extern JSBool
54746: js_HasOwnProperty(JSContext *cx, js::LookupPropOp lookup, JSObject *obj, jsid id,
36991:                   JSObject **objp, JSProperty **propp);
18062: 
18062: extern JSBool
48470: js_NewPropertyDescriptorObject(JSContext *cx, jsid id, uintN attrs,
48470:                                const js::Value &getter, const js::Value &setter,
48470:                                const js::Value &value, js::Value *vp);
42733: 
42733: extern JSBool
48470: js_PropertyIsEnumerable(JSContext *cx, JSObject *obj, jsid id, js::Value *vp);
18062: 
42260: #ifdef OLD_GETTER_SETTER_METHODS
48470: JS_FRIEND_API(JSBool) js_obj_defineGetter(JSContext *cx, uintN argc, js::Value *vp);
48470: JS_FRIEND_API(JSBool) js_obj_defineSetter(JSContext *cx, uintN argc, js::Value *vp);
42260: #endif
42260: 
    1: extern JSObject *
    1: js_InitObjectClass(JSContext *cx, JSObject *obj);
    1: 
61705: namespace js {
61705: JSObject *
61705: DefineConstructorAndPrototype(JSContext *cx, JSObject *obj, JSProtoKey key, JSAtom *atom,
61705:                               JSObject *protoProto, Class *clasp,
61705:                               Native constructor, uintN nargs,
61705:                               JSPropertySpec *ps, JSFunctionSpec *fs,
61705:                               JSPropertySpec *static_ps, JSFunctionSpec *static_fs);
61705: }
61705: 
25897: extern JSObject *
25897: js_InitClass(JSContext *cx, JSObject *obj, JSObject *parent_proto,
48470:              js::Class *clasp, js::Native constructor, uintN nargs,
25897:              JSPropertySpec *ps, JSFunctionSpec *fs,
28086:              JSPropertySpec *static_ps, JSFunctionSpec *static_fs);
25897: 
25702: /*
25702:  * Select Object.prototype method names shared between jsapi.cpp and jsobj.cpp.
25702:  */
    1: extern const char js_watch_str[];
    1: extern const char js_unwatch_str[];
    1: extern const char js_hasOwnProperty_str[];
    1: extern const char js_isPrototypeOf_str[];
    1: extern const char js_propertyIsEnumerable_str[];
40855: 
40855: #ifdef OLD_GETTER_SETTER_METHODS
    1: extern const char js_defineGetter_str[];
    1: extern const char js_defineSetter_str[];
    1: extern const char js_lookupGetter_str[];
    1: extern const char js_lookupSetter_str[];
40855: #endif
    1: 
42733: extern JSBool
42733: js_PopulateObject(JSContext *cx, JSObject *newborn, JSObject *props);
42733: 
25897: /*
    1:  * Fast access to immutable standard objects (constructors and prototypes).
    1:  */
    1: extern JSBool
    1: js_GetClassObject(JSContext *cx, JSObject *obj, JSProtoKey key,
    1:                   JSObject **objp);
    1: 
    1: extern JSBool
43258: js_SetClassObject(JSContext *cx, JSObject *obj, JSProtoKey key,
43258:                   JSObject *cobj, JSObject *prototype);
    1: 
38604: /*
38604:  * If protoKey is not JSProto_Null, then clasp is ignored. If protoKey is
38604:  * JSProto_Null, clasp must non-null.
38604:  */
    1: extern JSBool
48470: js_FindClassObject(JSContext *cx, JSObject *start, JSProtoKey key,
48470:                    js::Value *vp, js::Class *clasp = NULL);
    1: 
    1: extern JSObject *
48470: js_ConstructObject(JSContext *cx, js::Class *clasp, JSObject *proto,
48470:                    JSObject *parent, uintN argc, js::Value *argv);
    1: 
55503: // Specialized call for constructing |this| with a known function callee,
55503: // and a known prototype.
53557: extern JSObject *
55503: js_CreateThisForFunctionWithProto(JSContext *cx, JSObject *callee, JSObject *proto);
55503: 
55503: // Specialized call for constructing |this| with a known function callee.
55503: extern JSObject *
55503: js_CreateThisForFunction(JSContext *cx, JSObject *callee);
55503: 
55503: // Generic call for constructing |this|.
55503: extern JSObject *
55503: js_CreateThis(JSContext *cx, JSObject *callee);
53557: 
11524: extern jsid
30270: js_CheckForStringIndex(jsid id);
11524: 
    1: /*
25936:  * js_PurgeScopeChain does nothing if obj is not itself a prototype or parent
25936:  * scope, else it reshapes the scope and prototype chains it links. It calls
25936:  * js_PurgeScopeChainHelper, which asserts that obj is flagged as a delegate
25936:  * (i.e., obj has ever been on a prototype or parent chain).
25936:  */
25936: extern void
25936: js_PurgeScopeChainHelper(JSContext *cx, JSObject *obj, jsid id);
25936: 
48622: inline void
25936: js_PurgeScopeChain(JSContext *cx, JSObject *obj, jsid id)
25936: {
32603:     if (obj->isDelegate())
25936:         js_PurgeScopeChainHelper(cx, obj, id);
25936: }
25936: 
25936: /*
    1:  * Find or create a property named by id in obj's scope, with the given getter
    1:  * and setter, slot, attributes, and other members.
    1:  */
52503: extern const js::Shape *
    1: js_AddNativeProperty(JSContext *cx, JSObject *obj, jsid id,
62395:                      js::PropertyOp getter, js::StrictPropertyOp setter, uint32 slot,
    1:                      uintN attrs, uintN flags, intN shortid);
    1: 
    1: /*
52503:  * Change shape to have the given attrs, getter, and setter in scope, morphing
52503:  * it into a potentially new js::Shape.  Return a pointer to the changed
    1:  * or identical property.
    1:  */
52503: extern const js::Shape *
    1: js_ChangeNativePropertyAttrs(JSContext *cx, JSObject *obj,
52503:                              const js::Shape *shape, uintN attrs, uintN mask,
62395:                              js::PropertyOp getter, js::StrictPropertyOp setter);
    1: 
32573: extern JSBool
48470: js_DefineOwnProperty(JSContext *cx, JSObject *obj, jsid id,
48470:                      const js::Value &descriptor, JSBool *bp);
40356: 
32573: /*
32573:  * Flags for the defineHow parameter of js_DefineNativeProperty.
32573:  */
32573: const uintN JSDNP_CACHE_RESULT = 1; /* an interpreter call from JSOP_INITPROP */
32573: const uintN JSDNP_DONT_PURGE   = 2; /* suppress js_PurgeScopeChain */
32658: const uintN JSDNP_SET_METHOD   = 4; /* js_{DefineNativeProperty,SetPropertyHelper}
52503:                                        must pass the js::Shape::METHOD
52503:                                        flag on to JSObject::{add,put}Property */
41774: const uintN JSDNP_UNQUALIFIED  = 8; /* Unqualified property set.  Only used in
41774:                                        the defineHow argument of
41774:                                        js_SetPropertyHelper. */
32573: 
    1: /*
    1:  * On error, return false.  On success, if propp is non-null, return true with
    1:  * obj locked and with a held property in *propp; if propp is null, return true
56567:  * but release obj's lock first.
    1:  */
    1: extern JSBool
48470: js_DefineNativeProperty(JSContext *cx, JSObject *obj, jsid id, const js::Value &value,
62395:                         js::PropertyOp getter, js::StrictPropertyOp setter, uintN attrs,
24852:                         uintN flags, intN shortid, JSProperty **propp,
28397:                         uintN defineHow = 0);
    1: 
    1: /*
10217:  * Specialized subroutine that allows caller to preset JSRESOLVE_* flags and
10217:  * returns the index along the prototype chain in which *propp was found, or
10217:  * the last index if not found, or -1 on error.
    1:  */
10217: extern int
    1: js_LookupPropertyWithFlags(JSContext *cx, JSObject *obj, jsid id, uintN flags,
    1:                            JSObject **objp, JSProperty **propp);
    1: 
31467: 
31467: /*
31467:  * We cache name lookup results only for the global object or for native
31467:  * non-global objects without prototype or with prototype that never mutates,
31467:  * see bug 462734 and bug 487039.
31467:  */
48622: inline bool
31467: js_IsCacheableNonGlobalScope(JSObject *obj)
31467: {
48470:     extern JS_FRIEND_DATA(js::Class) js_CallClass;
48470:     extern JS_FRIEND_DATA(js::Class) js_DeclEnvClass;
39930:     JS_ASSERT(obj->getParent());
31467: 
48470:     js::Class *clasp = obj->getClass();
31467:     bool cacheable = (clasp == &js_CallClass ||
31467:                       clasp == &js_BlockClass ||
31467:                       clasp == &js_DeclEnvClass);
31467: 
48622:     JS_ASSERT_IF(cacheable, !obj->getOps()->lookupProperty);
31467:     return cacheable;
31467: }
31467: 
27575: /*
27575:  * If cacheResult is false, return JS_NO_PROP_CACHE_FILL on success.
27575:  */
40362: extern js::PropertyCacheEntry *
27575: js_FindPropertyHelper(JSContext *cx, jsid id, JSBool cacheResult,
27575:                       JSObject **objp, JSObject **pobjp, JSProperty **propp);
11377: 
10217: /*
10217:  * Return the index along the scope chain in which id was found, or the last
10217:  * index if not found, or -1 on error.
10217:  */
11377: extern JS_FRIEND_API(JSBool)
    1: js_FindProperty(JSContext *cx, jsid id, JSObject **objp, JSObject **pobjp,
    1:                 JSProperty **propp);
    1: 
22652: extern JS_REQUIRES_STACK JSObject *
27575: js_FindIdentifierBase(JSContext *cx, JSObject *scopeChain, jsid id);
    1: 
    1: extern JSObject *
    1: js_FindVariableScope(JSContext *cx, JSFunction **funp);
    1: 
    1: /*
32658:  * JSGET_CACHE_RESULT is the analogue of JSDNP_CACHE_RESULT for js_GetMethod.
32658:  *
32658:  * JSGET_METHOD_BARRIER (the default, hence 0 but provided for documentation)
32658:  * enables a read barrier that preserves standard function object semantics (by
32658:  * default we assume our caller won't leak a joined callee to script, where it
32658:  * would create hazardous mutable object sharing as well as observable identity
32658:  * according to == and ===.
32658:  *
32658:  * JSGET_NO_METHOD_BARRIER avoids the performance overhead of the method read
32658:  * barrier, which is not needed when invoking a lambda that otherwise does not
32658:  * leak its callee reference (via arguments.callee or its name).
32658:  */
32658: const uintN JSGET_CACHE_RESULT      = 1; // from a caching interpreter opcode
32658: const uintN JSGET_METHOD_BARRIER    = 0; // get can leak joined function object
32658: const uintN JSGET_NO_METHOD_BARRIER = 2; // call to joined function can't leak
32658: 
32658: /*
52503:  * NB: js_NativeGet and js_NativeSet are called with the scope containing shape
27490:  * (pobj's scope for Get, obj's for Set) locked, and on successful return, that
27490:  * scope is again locked.  But on failure, both functions return false with the
52503:  * scope containing shape unlocked.
    1:  */
    1: extern JSBool
52503: js_NativeGet(JSContext *cx, JSObject *obj, JSObject *pobj, const js::Shape *shape, uintN getHow,
52503:              js::Value *vp);
    1: 
    1: extern JSBool
52503: js_NativeSet(JSContext *cx, JSObject *obj, const js::Shape *shape, bool added,
62395:              bool strict, js::Value *vp);
    1: 
    1: extern JSBool
54177: js_GetPropertyHelper(JSContext *cx, JSObject *obj, jsid id, uint32 getHow, js::Value *vp);
54172: 
54172: extern bool
56817: js_GetPropertyHelperWithShape(JSContext *cx, JSObject *obj, JSObject *receiver, jsid id,
56817:                               uint32 getHow, js::Value *vp,
56817:                               const js::Shape **shapeOut, JSObject **holderOut);
11377: 
11377: extern JSBool
48470: js_GetOwnPropertyDescriptor(JSContext *cx, JSObject *obj, jsid id, js::Value *vp);
40356: 
40356: extern JSBool
48470: js_GetMethod(JSContext *cx, JSObject *obj, jsid id, uintN getHow, js::Value *vp);
26187: 
27372: /*
41774:  * Check whether it is OK to assign an undeclared property with name
41774:  * propname of the global object in the current script on cx.  Reports
41774:  * an error if one needs to be reported (in particular in all cases
41774:  * when it returns false).
27372:  */
35308: extern JS_FRIEND_API(bool)
48470: js_CheckUndeclaredVarAssignment(JSContext *cx, JSString *propname);
27372: 
27932: extern JSBool
56760: js_SetPropertyHelper(JSContext *cx, JSObject *obj, jsid id, uintN defineHow,
54169:                      js::Value *vp, JSBool strict);
11377: 
43290: /*
43290:  * Change attributes for the given native property. The caller must ensure
43290:  * that obj is locked and this function always unlocks obj on return.
43290:  */
43290: extern JSBool
52503: js_SetNativeAttributes(JSContext *cx, JSObject *obj, js::Shape *shape,
43290:                        uintN attrs);
    1: 
47607: namespace js {
47607: 
57686: /*
57686:  * If obj has a data property methodid which is a function object for the given
57686:  * native, return that function object. Otherwise, return NULL.
57686:  */
57686: extern JSObject *
57686: HasNativeMethod(JSObject *obj, jsid methodid, Native native);
57686: 
57686: extern bool
48470: DefaultValue(JSContext *cx, JSObject *obj, JSType hint, Value *vp);
47607: 
    1: extern JSBool
47455: CheckAccess(JSContext *cx, JSObject *obj, jsid id, JSAccessMode mode,
48470:             js::Value *vp, uintN *attrsp);
    1: 
48622: } /* namespace js */
38633: 
48470: extern bool
48470: js_IsDelegate(JSContext *cx, JSObject *obj, const js::Value &v);
    1: 
38604: /*
38604:  * If protoKey is not JSProto_Null, then clasp is ignored. If protoKey is
38604:  * JSProto_Null, clasp must non-null.
38604:  */
39541: extern JS_FRIEND_API(JSBool)
38604: js_GetClassPrototype(JSContext *cx, JSObject *scope, JSProtoKey protoKey,
48470:                      JSObject **protop, js::Class *clasp = NULL);
    1: 
    1: extern JSBool
    1: js_SetClassPrototype(JSContext *cx, JSObject *ctor, JSObject *proto,
    1:                      uintN attrs);
    1: 
 2383: /*
 2383:  * Wrap boolean, number or string as Boolean, Number or String object.
 2383:  * *vp must not be an object, null or undefined.
 2383:  */
 2383: extern JSBool
48470: js_PrimitiveToObject(JSContext *cx, js::Value *vp);
48470: 
48470: /*
48470:  * v and vp may alias. On successful return, vp->isObjectOrNull(). If vp is not
48470:  * rooted, the caller must root vp before the next possible GC.
48470:  */
48470: extern JSBool
48470: js_ValueToObjectOrNull(JSContext *cx, const js::Value &v, JSObject **objp);
48470: 
61734: namespace js {
61734: 
61734: /*
61734:  * Invokes the ES5 ToObject algorithm on *vp, writing back the object to vp.
61734:  * If *vp might already be an object, use ToObject.
61734:  */
61734: extern JSObject *
61734: ToObjectSlow(JSContext *cx, js::Value *vp);
61734: 
61734: JS_ALWAYS_INLINE JSObject *
61734: ToObject(JSContext *cx, js::Value *vp)
61734: {
61734:     if (vp->isObject())
61734:         return &vp->toObject();
61734:     return ToObjectSlow(cx, vp);
61734: }
61734: 
61734: }
61734: 
48470: /*
48470:  * v and vp may alias. On successful return, vp->isObject(). If vp is not
48470:  * rooted, the caller must root vp before the next possible GC.
48470:  */
48470: extern JSObject *
48470: js_ValueToNonNullObject(JSContext *cx, const js::Value &v);
 2383: 
    1: extern JSBool
48470: js_TryValueOf(JSContext *cx, JSObject *obj, JSType type, js::Value *rval);
    1: 
    1: extern JSBool
    1: js_TryMethod(JSContext *cx, JSObject *obj, JSAtom *atom,
48470:              uintN argc, js::Value *argv, js::Value *rval);
    1: 
    1: extern JSBool
    1: js_XDRObject(JSXDRState *xdr, JSObject **objp);
    1: 
  583: extern void
  583: js_TraceObject(JSTracer *trc, JSObject *obj);
    1: 
    1: extern void
11835: js_PrintObjectSlotName(JSTracer *trc, char *buf, size_t bufsize);
11835: 
11835: extern void
48622: js_ClearNative(JSContext *cx, JSObject *obj);
    1: 
32603: extern bool
48470: js_GetReservedSlot(JSContext *cx, JSObject *obj, uint32 index, js::Value *vp);
    1: 
47404: extern bool
48470: js_SetReservedSlot(JSContext *cx, JSObject *obj, uint32 index, const js::Value &v);
    1: 
    1: extern JSBool
    1: js_CheckPrincipalsAccess(JSContext *cx, JSObject *scopeobj,
    1:                          JSPrincipals *principals, JSAtom *caller);
 8179: 
39061: /* For CSP -- checks if eval() and friends are allowed to run. */
39061: extern JSBool
61215: js_CheckContentSecurityPolicy(JSContext *cx, JSObject *scopeObj);
39061: 
12690: /* NB: Infallible. */
12690: extern const char *
12690: js_ComputeFilename(JSContext *cx, JSStackFrame *caller,
12690:                    JSPrincipals *principals, uintN *linenop);
18062: 
36491: extern JSBool
27641: js_ReportGetterOnlyAssignment(JSContext *cx);
27641: 
27641: extern JS_FRIEND_API(JSBool)
62395: js_GetterOnlyPropertyStub(JSContext *cx, JSObject *obj, jsid id, JSBool strict, jsval *vp);
27641: 
19714: #ifdef DEBUG
19714: JS_FRIEND_API(void) js_DumpChars(const jschar *s, size_t n);
19714: JS_FRIEND_API(void) js_DumpString(JSString *str);
19714: JS_FRIEND_API(void) js_DumpAtom(JSAtom *atom);
48470: JS_FRIEND_API(void) js_DumpObject(JSObject *obj);
48470: JS_FRIEND_API(void) js_DumpValue(const js::Value &val);
19714: JS_FRIEND_API(void) js_DumpId(jsid id);
43283: JS_FRIEND_API(void) js_DumpStackFrame(JSContext *cx, JSStackFrame *start = NULL);
19714: #endif
19714: 
30034: extern uintN
30034: js_InferFlags(JSContext *cx, uintN defaultFlags);
30034: 
30860: /* Object constructor native. Exposed only so the JIT can know its address. */
30860: JSBool
50489: js_Object(JSContext *cx, uintN argc, js::Value *vp);
30860: 
    1: 
47465: namespace js {
47465: 
47465: extern bool
47465: SetProto(JSContext *cx, JSObject *obj, JSObject *proto, bool checkForCycles);
47465: 
47498: extern JSString *
47498: obj_toStringHelper(JSContext *cx, JSObject *obj);
47498: 
56775: enum EvalType { INDIRECT_EVAL, DIRECT_EVAL };
56775: 
56775: /*
56775:  * Common code implementing direct and indirect eval.
56775:  *
56775:  * Evaluate vp[2], if it is a string, in the context of the given calling
56775:  * frame, with the provided scope chain, with the semantics of either a direct
56775:  * or indirect eval (see ES5 10.4.2).  If this is an indirect eval, scopeobj
56775:  * must be a global object.
56775:  *
56775:  * On success, store the completion value in *vp and return true.
56775:  */
56775: extern bool
56775: EvalKernel(JSContext *cx, uintN argc, js::Value *vp, EvalType evalType, JSStackFrame *caller,
56775:            JSObject *scopeobj);
56775: 
61449: extern JS_FRIEND_API(bool)
56556: IsBuiltinEvalFunction(JSFunction *fun);
56556: 
47498: }
61451: 
61451: #ifdef JS_OBJ_UNDEFD_MOZALLOC_WRAPPERS
61451: #  include "mozilla/mozalloc_macro_wrappers.h"
61451: #endif
61451: 
    1: #endif /* jsobj_h___ */
