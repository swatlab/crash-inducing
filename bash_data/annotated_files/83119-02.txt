79410: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
79410:  * vim: set ts=8 sw=4 et tw=99 ft=cpp:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
79516:  * The Original Code is Mozilla SpiderMonkey JavaScript code.
    1:  *
    1:  * The Initial Developer of the Original Code is
79516:  * the Mozilla Foundation.
79516:  * Portions created by the Initial Developer are Copyright (C) 2011
79516:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
79410:  *  Chris Leary <cdleary@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
79516:  * either the GNU General Public License Version 2 or later (the "GPL"), or
79516:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
79410: #ifndef LifoAlloc_h__
79410: #define LifoAlloc_h__
78950: 
78950: /*
79410:  * This data structure supports stacky LIFO allocation (mark/release and
79410:  * LifoAllocScope). It does not maintain one contiguous segment; instead, it
79410:  * maintains a bunch of linked memory segments. In order to prevent malloc/free
79410:  * thrashing, unused segments are deallocated when garbage collection occurs.
78950:  */
78950: 
79410: #include "jsutil.h"
80202: 
80202: #include "js/TemplateLib.h"
77343: 
77343: namespace js {
77343: 
79410: namespace detail {
79410: 
79410: static const size_t LIFO_ALLOC_ALIGN = 8;
79410: 
79410: JS_ALWAYS_INLINE
79410: char *
79410: AlignPtr(void *orig)
77343: {
79410:     typedef tl::StaticAssert<
79410:         tl::FloorLog2<LIFO_ALLOC_ALIGN>::result == tl::CeilingLog2<LIFO_ALLOC_ALIGN>::result
79410:     >::result _;
79410: 
79647:     char *result = (char *) ((uintptr_t(orig) + (LIFO_ALLOC_ALIGN - 1)) & (~LIFO_ALLOC_ALIGN + 1));
79410:     JS_ASSERT(uintptr_t(result) % LIFO_ALLOC_ALIGN == 0);
79410:     return result;
79410: }
79410: 
79410: /* Header for a chunk of memory wrangled by the LifoAlloc. */
79410: class BumpChunk
79410: {
81205:     char        *bump;          /* start of the available data */
81205:     char        *limit;         /* end of the data */
81205:     BumpChunk   *next_;         /* the next BumpChunk */
81205:     size_t      bumpSpaceSize;  /* size of the data area */
79410: 
80214:     char *headerBase() { return reinterpret_cast<char *>(this); }
80214:     char *bumpBase() const { return limit - bumpSpaceSize; }
79410: 
79835:     BumpChunk *thisDuringConstruction() { return this; }
79835: 
79410:     explicit BumpChunk(size_t bumpSpaceSize)
79835:       : bump(reinterpret_cast<char *>(thisDuringConstruction()) + sizeof(BumpChunk)),
79835:         limit(bump + bumpSpaceSize),
79835:         next_(NULL), bumpSpaceSize(bumpSpaceSize)
79835:     {
79410:         JS_ASSERT(bump == AlignPtr(bump));
79410:     }
79410: 
79410:     void setBump(void *ptr) {
80214:         JS_ASSERT(bumpBase() <= ptr);
79410:         JS_ASSERT(ptr <= limit);
79410:         DebugOnly<char *> prevBump = bump;
79410:         bump = static_cast<char *>(ptr);
80306: #ifdef DEBUG
80306:         JS_ASSERT(contains(prevBump));
80306: 
80306:         /* Clobber the now-free space. */
80306:         if (prevBump > bump)
80306:             memset(bump, 0xcd, prevBump - bump);
80306: #endif
79410:     }
79410: 
79410:   public:
79410:     BumpChunk *next() const { return next_; }
79410:     void setNext(BumpChunk *succ) { next_ = succ; }
79410: 
80214:     size_t used() const { return bump - bumpBase(); }
82849:     size_t sizeOfIncludingThis(JSMallocSizeOfFun mallocSizeOf) {
82849:         return mallocSizeOf(this, limit - headerBase());
81205:     }
79410: 
79410:     void resetBump() {
80214:         setBump(headerBase() + sizeof(BumpChunk));
79410:     }
79410: 
79410:     void *mark() const { return bump; }
79410: 
79410:     void release(void *mark) {
79410:         JS_ASSERT(contains(mark));
79410:         JS_ASSERT(mark <= bump);
79410:         setBump(mark);
79410:     }
79410: 
79410:     bool contains(void *mark) const {
80214:         return bumpBase() <= mark && mark <= limit;
79410:     }
79410: 
80214:     bool canAlloc(size_t n);
80214:     bool canAllocUnaligned(size_t n);
79410: 
79410:     /* Try to perform an allocation of size |n|, return null if not possible. */
79410:     JS_ALWAYS_INLINE
79410:     void *tryAlloc(size_t n) {
79410:         char *aligned = AlignPtr(bump);
79410:         char *newBump = aligned + n;
80214: 
79410:         if (newBump > limit)
79410:             return NULL;
79410: 
80214:         /* Check for overflow. */
80214:         if (JS_UNLIKELY(newBump < bump))
80214:             return NULL;
80214: 
80214:         JS_ASSERT(canAlloc(n)); /* Ensure consistency between "can" and "try". */
79410:         setBump(newBump);
79410:         return aligned;
79410:     }
79410: 
79410:     void *tryAllocUnaligned(size_t n);
79410: 
79410:     void *allocInfallible(size_t n) {
79410:         void *result = tryAlloc(n);
79410:         JS_ASSERT(result);
79410:         return result;
79410:     }
79410: 
79410:     static BumpChunk *new_(size_t chunkSize);
80214:     static void delete_(BumpChunk *chunk);
79410: };
79410: 
79410: } /* namespace detail */
79410: 
79410: /*
79410:  * LIFO bump allocator: used for phase-oriented and fast LIFO allocations.
79410:  *
79410:  * Note: |latest| is not necessary "last". We leave BumpChunks latent in the
79410:  * chain after they've been released to avoid thrashing before a GC.
79410:  */
79410: class LifoAlloc
79410: {
79410:     typedef detail::BumpChunk BumpChunk;
79410: 
79410:     BumpChunk   *first;
79410:     BumpChunk   *latest;
79410:     size_t      markCount;
79410:     size_t      defaultChunkSize_;
79410: 
79410:     void operator=(const LifoAlloc &);
79410:     LifoAlloc(const LifoAlloc &);
79410: 
79410:     /* 
79410:      * Return a BumpChunk that can perform an allocation of at least size |n|
79410:      * and add it to the chain appropriately.
79410:      *
79410:      * Side effect: if retval is non-null, |first| and |latest| are initialized
79410:      * appropriately.
79410:      */
79410:     BumpChunk *getOrCreateChunk(size_t n);
79410: 
79410:     void reset(size_t defaultChunkSize) {
79410:         JS_ASSERT(RoundUpPow2(defaultChunkSize) == defaultChunkSize);
79410:         first = latest = NULL;
79410:         defaultChunkSize_ = defaultChunkSize;
79410:         markCount = 0;
79410:     }
79410: 
79410:   public:
79410:     explicit LifoAlloc(size_t defaultChunkSize) { reset(defaultChunkSize); }
79410: 
79410:     /* Steal allocated chunks from |other|. */
79410:     void steal(LifoAlloc *other) {
79410:         JS_ASSERT(!other->markCount);
79410:         PodCopy((char *) this, (char *) other, sizeof(*this));
79410:         other->reset(defaultChunkSize_);
79410:     }
79410: 
79410:     ~LifoAlloc() { freeAll(); }
79410: 
79410:     size_t defaultChunkSize() const { return defaultChunkSize_; }
79410: 
79410:     /* Frees all held memory. */
79410:     void freeAll();
79410: 
79410:     /* Should be called on GC in order to release any held chunks. */
79410:     void freeUnused();
79410: 
79410:     JS_ALWAYS_INLINE
79410:     void *alloc(size_t n) {
79410:         void *result;
79410:         if (latest && (result = latest->tryAlloc(n)))
79410:             return result;
79410: 
79410:         if (!getOrCreateChunk(n))
79410:             return NULL;
79410: 
79410:         return latest->allocInfallible(n);
77343:     }
77343: 
77343:     template <typename T>
79410:     T *newArray(size_t count) {
79410:         void *mem = alloc(sizeof(T) * count);
79410:         if (!mem)
79410:             return NULL;
79410:         JS_STATIC_ASSERT(tl::IsPodType<T>::result);
79410:         return (T *) mem;
77343:     }
77343: 
79410:     /*
79410:      * Create an array with uninitialized elements of type |T|.
79410:      * The caller is responsible for initialization.
79410:      */
79410:     template <typename T>
79410:     T *newArrayUninitialized(size_t count) {
79410:         return static_cast<T *>(alloc(sizeof(T) * count));
77343:     }
77343: 
79410:     void *mark() {
79410:         markCount++;
79410: 
79410:         return latest ? latest->mark() : NULL;
77343:     }
77343: 
79410:     void release(void *mark) {
79410:         markCount--;
79410: 
79410:         if (!mark) {
79410:             latest = first;
79410:             if (latest)
79410:                 latest->resetBump();
79410:             return;
77343:         }
77343: 
79410:         /* 
79410:          * Find the chunk that contains |mark|, and make sure we don't pass
79410:          * |latest| along the way -- we should be making the chain of active
79410:          * chunks shorter, not longer!
79410:          */
79410:         BumpChunk *container = first;
79410:         while (true) {
79410:             if (container->contains(mark))
79410:                 break;
79410:             JS_ASSERT(container != latest);
79410:             container = container->next();
79410:         }
79410:         latest = container;
79410:         latest->release(mark);
77343:     }
77343: 
79410:     /* Get the total "used" (occupied bytes) count for the arena chunks. */
79410:     size_t used() const {
79410:         size_t accum = 0;
79410:         BumpChunk *it = first;
79410:         while (it) {
79410:             accum += it->used();
79410:             it = it->next();
79410:         }
79410:         return accum;
77343:     }
77343: 
82849:     /* Get the total size of the arena chunks (including unused space). */
82849:     size_t sizeOfExcludingThis(JSMallocSizeOfFun mallocSizeOf) const {
81205:         size_t accum = 0;
81205:         BumpChunk *it = first;
81205:         while (it) {
82849:             accum += it->sizeOfIncludingThis(mallocSizeOf);
81205:             it = it->next();
81205:         }
81205:         return accum;
81205:     }
81205: 
82849:     /* Like sizeOfExcludingThis(), but includes the size of the LifoAlloc itself. */
82849:     size_t sizeOfIncludingThis(JSMallocSizeOfFun mallocSizeOf) const {
82849:         return mallocSizeOf(this, sizeof(LifoAlloc)) +
82849:                sizeOfExcludingThis(mallocSizeOf);
82849:     }
82849: 
79410:     /* Doesn't perform construction; useful for lazily-initialized POD types. */
79410:     template <typename T>
79410:     JS_ALWAYS_INLINE
79410:     T *newPod() {
79410:         return static_cast<T *>(alloc(sizeof(T)));
77343:     }
77343: 
79410:     JS_DECLARE_NEW_METHODS(alloc, JS_ALWAYS_INLINE)
79410: 
79410:     /* Some legacy clients (ab)use LifoAlloc to act like a vector, see bug 688891. */
79410: 
79410:     void *allocUnaligned(size_t n);
79410:     void *reallocUnaligned(void *origPtr, size_t origSize, size_t incr);
79410: };
79410: 
83119: class LifoAllocScope
83119: {
79410:     LifoAlloc   *lifoAlloc;
79410:     void        *mark;
79410:     bool        shouldRelease;
79410:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
79410: 
79410:   public:
79410:     explicit LifoAllocScope(LifoAlloc *lifoAlloc
79410:                             JS_GUARD_OBJECT_NOTIFIER_PARAM)
79410:       : lifoAlloc(lifoAlloc), shouldRelease(true) {
79410:         JS_GUARD_OBJECT_NOTIFIER_INIT;
79410:         mark = lifoAlloc->mark();
77439:     }
77439: 
79410:     ~LifoAllocScope() {
79410:         if (shouldRelease)
79410:             lifoAlloc->release(mark);
79410:     }
79410: 
80378:     LifoAlloc &alloc() {
80378:         return *lifoAlloc;
80378:     }
80378: 
79410:     void releaseEarly() {
79410:         JS_ASSERT(shouldRelease);
79410:         lifoAlloc->release(mark);
79410:         shouldRelease = false;
79410:     }
79410: };
79410: 
77343: } /* namespace js */
77343: 
79410: #endif
