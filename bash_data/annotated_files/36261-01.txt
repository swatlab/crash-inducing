 4133: /* -*- Mode: c; tab-width: 8; c-basic-offset: 4; indent-tabs-mode: t; -*- */
    1: /* cairo - a vector graphics library with display and print output
    1:  *
    1:  * Copyright © 2002 University of Southern California
    1:  * Copyright © 2005 Red Hat, Inc.
    1:  *
    1:  * This library is free software; you can redistribute it and/or
    1:  * modify it either under the terms of the GNU Lesser General Public
    1:  * License version 2.1 as published by the Free Software Foundation
    1:  * (the "LGPL") or, at your option, under the terms of the Mozilla
    1:  * Public License Version 1.1 (the "MPL"). If you do not alter this
    1:  * notice, a recipient may use your version of this file under either
    1:  * the MPL or the LGPL.
    1:  *
    1:  * You should have received a copy of the LGPL along with this library
    1:  * in the file COPYING-LGPL-2.1; if not, write to the Free Software
    1:  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
    1:  * You should have received a copy of the MPL along with this library
    1:  * in the file COPYING-MPL-1.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License
    1:  * Version 1.1 (the "License"); you may not use this file except in
    1:  * compliance with the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
    1:  * OF ANY KIND, either express or implied. See the LGPL or the MPL for
    1:  * the specific language governing rights and limitations.
    1:  *
    1:  * The Original Code is the cairo graphics library.
    1:  *
    1:  * The Initial Developer of the Original Code is University of Southern
    1:  * California.
    1:  *
    1:  * Contributor(s):
    1:  *	Carl D. Worth <cworth@cworth.org>
    1:  */
    1: 
 4133: #include "cairoint.h"
 3847: 
    1: #include "cairo-surface-fallback-private.h"
    1: #include "cairo-clip-private.h"
26419: #include "cairo-meta-surface-private.h"
    1: 
  314: #define DEFINE_NIL_SURFACE(status, name)			\
  314: const cairo_surface_t name = {					\
26419:     NULL,				/* backend */		\
26419:     CAIRO_SURFACE_TYPE_IMAGE,		/* type */		\
26419:     CAIRO_CONTENT_COLOR,		/* content */		\
 8452:     CAIRO_REFERENCE_COUNT_INVALID,	/* ref_count */		\
  314:     status,				/* status */		\
  314:     FALSE,				/* finished */		\
32473:     0,					/* unique id */		\
26419:     { 0, 0, 0, NULL, },			/* user_data */		\
26419:     { 0, 0, 0, NULL, },			/* mime_data */         \
26419:     { 1.0, 0.0, 0.0, 1.0, 0.0, 0.0 },   /* device_transform */	\
26419:     { 1.0, 0.0,	0.0, 1.0, 0.0, 0.0 },	/* device_transform_inverse */	\
 6154:     0.0,				/* x_resolution */	\
 6154:     0.0,				/* y_resolution */	\
  314:     0.0,				/* x_fallback_resolution */	\
  314:     0.0,				/* y_fallback_resolution */	\
  314:     NULL,				/* clip */		\
  314:     0,					/* next_clip_serial */	\
  314:     0,					/* current_clip_serial */	\
32473:     NULL,				/* snapshot_of */	\
32473:     NULL,				/* snapshot_detach */	\
32473:     { 0,	/* size */					\
32473:       0,	/* num_elements */				\
32473:       0,	/* element_size */				\
32473:       NULL,	/* elements */					\
32473:     },					/* snapshots */		\
  314:     FALSE,				/* has_font_options */	\
18904:     { CAIRO_ANTIALIAS_DEFAULT,		/* antialias */		\
18904:       CAIRO_SUBPIXEL_ORDER_DEFAULT,	/* subpixel_order */	\
18904:       CAIRO_HINT_STYLE_DEFAULT,		/* hint_style */	\
18904:       CAIRO_HINT_METRICS_DEFAULT	/* hint_metrics */	\
  314:     }					/* font_options */	\
  314: }
    1: 
10694: static DEFINE_NIL_SURFACE(CAIRO_STATUS_NO_MEMORY, _cairo_surface_nil);
32473: static DEFINE_NIL_SURFACE(CAIRO_STATUS_SURFACE_TYPE_MISMATCH, _cairo_surface_nil_surface_type_mismatch);
10694: static DEFINE_NIL_SURFACE(CAIRO_STATUS_INVALID_CONTENT, _cairo_surface_nil_invalid_content);
10694: static DEFINE_NIL_SURFACE(CAIRO_STATUS_INVALID_FORMAT, _cairo_surface_nil_invalid_format);
10694: static DEFINE_NIL_SURFACE(CAIRO_STATUS_INVALID_VISUAL, _cairo_surface_nil_invalid_visual);
10694: static DEFINE_NIL_SURFACE(CAIRO_STATUS_FILE_NOT_FOUND, _cairo_surface_nil_file_not_found);
10694: static DEFINE_NIL_SURFACE(CAIRO_STATUS_TEMP_FILE_ERROR, _cairo_surface_nil_temp_file_error);
10694: static DEFINE_NIL_SURFACE(CAIRO_STATUS_READ_ERROR, _cairo_surface_nil_read_error);
10694: static DEFINE_NIL_SURFACE(CAIRO_STATUS_WRITE_ERROR, _cairo_surface_nil_write_error);
11708: static DEFINE_NIL_SURFACE(CAIRO_STATUS_INVALID_STRIDE, _cairo_surface_nil_invalid_stride);
29608: static DEFINE_NIL_SURFACE(CAIRO_STATUS_INVALID_SIZE, _cairo_surface_nil_invalid_size);
    1: 
 4133: static cairo_status_t
26419: _cairo_surface_copy_pattern_for_destination (const cairo_pattern_t **pattern,
    1: 					     cairo_surface_t *destination,
26419: 					     cairo_pattern_t *pattern_copy);
    1: 
    1: /**
    1:  * _cairo_surface_set_error:
    1:  * @surface: a surface
16122:  * @status: a status value indicating an error
    1:  *
 8452:  * Atomically sets surface->status to @status and calls _cairo_error;
16122:  * Does nothing if status is %CAIRO_STATUS_SUCCESS or any of the internal
16122:  * status values.
    1:  *
    1:  * All assignments of an error status to surface->status should happen
 8452:  * through _cairo_surface_set_error(). Note that due to the nature of
 8452:  * the atomic operation, it is not safe to call this function on the
 8452:  * nil objects.
    1:  *
    1:  * The purpose of this function is to allow the user to set a
    1:  * breakpoint in _cairo_error() to generate a stack trace for when the
    1:  * user causes cairo to detect an error.
 8452:  *
 8452:  * Return value: the error status.
    1:  **/
 8452: cairo_status_t
    1: _cairo_surface_set_error (cairo_surface_t *surface,
    1: 			  cairo_status_t status)
    1: {
 8452:     if (status == CAIRO_STATUS_SUCCESS || status >= CAIRO_INT_STATUS_UNSUPPORTED)
 8452: 	return status;
 8452: 
    1:     /* Don't overwrite an existing error. This preserves the first
 8452:      * error, which is the most significant. */
 8452:     _cairo_status_set_error (&surface->status, status);
    1: 
 8452:     return _cairo_error (status);
    1: }
    1: 
    1: /**
    1:  * cairo_surface_get_type:
    1:  * @surface: a #cairo_surface_t
    1:  *
    1:  * This function returns the type of the backend used to create
    1:  * a surface. See #cairo_surface_type_t for available types.
    1:  *
    1:  * Return value: The type of @surface.
    1:  *
    1:  * Since: 1.2
    1:  **/
    1: cairo_surface_type_t
    1: cairo_surface_get_type (cairo_surface_t *surface)
    1: {
    1:     /* We don't use surface->backend->type here so that some of the
    1:      * special "wrapper" surfaces such as cairo_paginated_surface_t
    1:      * can override surface->type with the type of the "child"
    1:      * surface. */
    1:     return surface->type;
    1: }
    1: slim_hidden_def (cairo_surface_get_type);
    1: 
    1: /**
    1:  * cairo_surface_get_content:
    1:  * @surface: a #cairo_surface_t
    1:  *
  314:  * This function returns the content type of @surface which indicates
  314:  * whether the surface contains color and/or alpha information. See
    1:  * #cairo_content_t.
    1:  *
  314:  * Return value: The content type of @surface.
  314:  *
    1:  * Since: 1.2
    1:  **/
    1: cairo_content_t
    1: cairo_surface_get_content (cairo_surface_t *surface)
    1: {
    1:     return surface->content;
    1: }
    1: slim_hidden_def(cairo_surface_get_content);
    1: 
    1: /**
    1:  * cairo_surface_status:
    1:  * @surface: a #cairo_surface_t
    1:  *
    1:  * Checks whether an error has previously occurred for this
    1:  * surface.
    1:  *
    1:  * Return value: %CAIRO_STATUS_SUCCESS, %CAIRO_STATUS_NULL_POINTER,
    1:  * %CAIRO_STATUS_NO_MEMORY, %CAIRO_STATUS_READ_ERROR,
 8452:  * %CAIRO_STATUS_INVALID_CONTENT, %CAIRO_STATUS_INVALID_FORMAT, or
    1:  * %CAIRO_STATUS_INVALID_VISUAL.
    1:  **/
    1: cairo_status_t
    1: cairo_surface_status (cairo_surface_t *surface)
    1: {
    1:     return surface->status;
    1: }
    1: slim_hidden_def (cairo_surface_status);
    1: 
32473: static unsigned int
32473: _cairo_surface_allocate_unique_id (void)
32473: {
32473:     static unsigned int unique_id;
32473: 
32473: #if CAIRO_NO_MUTEX
32473:     if (++unique_id == 0)
32473: 	unique_id = 1;
32473:     return unique_id;
32473: #else
32473:     unsigned int old, id;
32473: 
32473:     do {
32473: 	old = _cairo_atomic_uint_get (&unique_id);
32473: 	id = old + 1;
32473: 	if (id == 0)
32473: 	    id = 1;
32473:     } while (! _cairo_atomic_uint_cmpxchg (&unique_id, old, id));
32473: 
32473:     return id;
32473: #endif
32473: }
32473: 
32473: static cairo_bool_t
32473: _cairo_surface_has_snapshots (cairo_surface_t *surface)
32473: {
32473:     return surface->snapshots.num_elements != 0;
32473: }
32473: 
32473: static void
32473: _cairo_surface_detach_snapshots (cairo_surface_t *surface)
32473: {
32473:     cairo_surface_t **snapshots;
32473:     unsigned int i;
32473: 
32473:     if (! _cairo_surface_has_snapshots (surface))
32473: 	return;
32473: 
32473:     /* XXX do something intelligent! */
32473: 
32473:     snapshots = _cairo_array_index (&surface->snapshots, 0);
32473:     for (i = 0; i < surface->snapshots.num_elements; i++) {
32473: 	snapshots[i]->snapshot_of = NULL;
32473: 
32473: 	if (snapshots[i]->snapshot_detach != NULL)
32473: 	    snapshots[i]->snapshot_detach (snapshots[i]);
32473: 
32473: 	cairo_surface_destroy (snapshots[i]);
32473:     }
32473:     surface->snapshots.num_elements = 0;
32473: 
32473:     assert (! _cairo_surface_has_snapshots (surface));
32473: }
32473: 
32473: cairo_status_t
32473: _cairo_surface_attach_snapshot (cairo_surface_t *surface,
32473: 				cairo_surface_t *snapshot,
32473: 				cairo_surface_func_t detach_func)
32473: {
32473:     cairo_status_t status;
32473: 
32473:     assert (surface != snapshot);
32473: 
32473:     if (snapshot->snapshot_of != NULL)
32473: 	_cairo_surface_detach_snapshot (snapshot);
32473: 
32473:     snapshot->snapshot_of = surface;
32473:     snapshot->snapshot_detach = detach_func;
32473: 
32473:     status = _cairo_array_append (&surface->snapshots, &snapshot);
32473:     if (unlikely (status))
32473: 	return status;
32473: 
32473:     cairo_surface_reference (snapshot);
32473:     return CAIRO_STATUS_SUCCESS;
32473: }
32473: 
32473: cairo_surface_t *
32473: _cairo_surface_has_snapshot (cairo_surface_t *surface,
32473: 			     const cairo_surface_backend_t *backend,
32473: 			     cairo_content_t content)
32473: {
32473:     cairo_surface_t **snapshots;
32473:     unsigned int i;
32473: 
32473:     snapshots = _cairo_array_index (&surface->snapshots, 0);
32473:     for (i = 0; i < surface->snapshots.num_elements; i++) {
32473: 	if (snapshots[i]->backend == backend &&
32473: 	    snapshots[i]->content == content)
32473: 	{
32473: 	    return snapshots[i];
32473: 	}
32473:     }
32473: 
32473:     return NULL;
32473: }
32473: 
32473: void
32473: _cairo_surface_detach_snapshot (cairo_surface_t *snapshot)
32473: {
32473:     cairo_surface_t *surface;
32473:     cairo_surface_t **snapshots;
32473:     unsigned int i;
32473: 
32473:     assert (snapshot->snapshot_of != NULL);
32473:     surface = snapshot->snapshot_of;
32473: 
32473:     snapshots = _cairo_array_index (&surface->snapshots, 0);
32473:     for (i = 0; i < surface->snapshots.num_elements; i++) {
32473: 	if (snapshots[i] == snapshot)
32473: 	    break;
32473:     }
32473:     assert (i < surface->snapshots.num_elements);
32473: 
32473:     surface->snapshots.num_elements--;
32473:     memmove (&snapshots[i],
32473: 	     &snapshots[i+1],
32473: 	     sizeof (cairo_surface_t *)*(surface->snapshots.num_elements - i));
32473: 
32473:     snapshot->snapshot_of = NULL;
32473: 
32473:     if (snapshot->snapshot_detach != NULL)
32473: 	snapshot->snapshot_detach (snapshot);
32473: 
32473:     cairo_surface_destroy (snapshot);
32473: }
32473: 
32473: static cairo_bool_t
32473: _cairo_surface_is_writable (cairo_surface_t *surface)
32473: {
32473:     return ! surface->finished &&
32473: 	   surface->snapshot_of == NULL &&
32473: 	   ! _cairo_surface_has_snapshots (surface);
32473: }
32473: 
32473: static void
32473: _cairo_surface_begin_modification (cairo_surface_t *surface)
32473: {
32473:     assert (surface->status == CAIRO_STATUS_SUCCESS);
32473:     assert (! surface->finished);
32473:     assert (surface->snapshot_of == NULL);
32473: 
32473:     _cairo_surface_detach_snapshots (surface);
32473: }
32473: 
    1: void
    1: _cairo_surface_init (cairo_surface_t			*surface,
    1: 		     const cairo_surface_backend_t	*backend,
    1: 		     cairo_content_t			 content)
    1: {
 4133:     CAIRO_MUTEX_INITIALIZE ();
 4133: 
 3847:     surface->backend = backend;
    1:     surface->content = content;
    1:     surface->type = backend->type;
    1: 
 8452:     CAIRO_REFERENCE_COUNT_INIT (&surface->ref_count, 1);
    1:     surface->status = CAIRO_STATUS_SUCCESS;
    1:     surface->finished = FALSE;
32473:     surface->unique_id = _cairo_surface_allocate_unique_id ();
    1: 
    1:     _cairo_user_data_array_init (&surface->user_data);
26419:     _cairo_user_data_array_init (&surface->mime_data);
    1: 
    1:     cairo_matrix_init_identity (&surface->device_transform);
    1:     cairo_matrix_init_identity (&surface->device_transform_inverse);
    1: 
 6154:     surface->x_resolution = CAIRO_SURFACE_RESOLUTION_DEFAULT;
 6154:     surface->y_resolution = CAIRO_SURFACE_RESOLUTION_DEFAULT;
 6154: 
    1:     surface->x_fallback_resolution = CAIRO_SURFACE_FALLBACK_RESOLUTION_DEFAULT;
    1:     surface->y_fallback_resolution = CAIRO_SURFACE_FALLBACK_RESOLUTION_DEFAULT;
    1: 
    1:     surface->clip = NULL;
    1:     surface->next_clip_serial = 0;
    1:     surface->current_clip_serial = 0;
    1: 
32473:     _cairo_array_init (&surface->snapshots, sizeof (cairo_surface_t *));
32473:     surface->snapshot_of = NULL;
    1: 
    1:     surface->has_font_options = FALSE;
    1: }
    1: 
    1: cairo_surface_t *
    1: _cairo_surface_create_similar_scratch (cairo_surface_t *other,
    1: 				       cairo_content_t	content,
    1: 				       int		width,
    1: 				       int		height)
    1: {
    1:     cairo_surface_t *surface = NULL;
    1: 
    1:     if (other->status)
10694: 	return _cairo_surface_create_in_error (other->status);
    1: 
  314:     if (other->backend->create_similar) {
    1: 	surface = other->backend->create_similar (other, content, width, height);
21379: 	if (surface != NULL && surface->status)
21379: 	    return surface;
  314:     }
    1: 
26419:     if (surface == NULL) {
26419: 	surface =
26419: 	    cairo_image_surface_create (_cairo_format_from_content (content),
26419: 					width, height);
26419:     }
    1: 
  314:     /* If any error occurred, then return the nil surface we received. */
26419:     if (unlikely (surface->status))
  314: 	return surface;
  314: 
26419:     if (other->has_font_options || other->backend != surface->backend) {
26419: 	cairo_font_options_t options;
26419: 
    1: 	cairo_surface_get_font_options (other, &options);
    1: 	_cairo_surface_set_font_options (surface, &options);
26419:     }
    1: 
    1:     cairo_surface_set_fallback_resolution (surface,
    1: 					   other->x_fallback_resolution,
    1: 					   other->y_fallback_resolution);
    1: 
    1:     return surface;
    1: }
    1: 
    1: /**
    1:  * cairo_surface_create_similar:
    1:  * @other: an existing surface used to select the backend of the new surface
    1:  * @content: the content for the new surface
    1:  * @width: width of the new surface, (in device-space units)
    1:  * @height: height of the new surface (in device-space units)
    1:  *
    1:  * Create a new surface that is as compatible as possible with an
    1:  * existing surface. For example the new surface will have the same
    1:  * fallback resolution and font options as @other. Generally, the new
    1:  * surface will also use the same backend as @other, unless that is
    1:  * not possible for some reason. The type of the returned surface may
    1:  * be examined with cairo_surface_get_type().
    1:  *
    1:  * Initially the surface contents are all 0 (transparent if contents
    1:  * have transparency, black otherwise.)
    1:  *
    1:  * Return value: a pointer to the newly allocated surface. The caller
11708:  * owns the surface and should call cairo_surface_destroy() when done
    1:  * with it.
    1:  *
    1:  * This function always returns a valid pointer, but it will return a
    1:  * pointer to a "nil" surface if @other is already in an error state
    1:  * or any other error occurs.
    1:  **/
    1: cairo_surface_t *
    1: cairo_surface_create_similar (cairo_surface_t  *other,
    1: 			      cairo_content_t	content,
    1: 			      int		width,
    1: 			      int		height)
    1: {
    1:     if (other->status)
10694: 	return _cairo_surface_create_in_error (other->status);
    1: 
10694:     if (! CAIRO_CONTENT_VALID (content))
10694: 	return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_INVALID_CONTENT));
    1: 
    1:     return _cairo_surface_create_similar_solid (other, content,
    1: 						width, height,
16122: 						CAIRO_COLOR_TRANSPARENT);
    1: }
    1: slim_hidden_def (cairo_surface_create_similar);
    1: 
    1: cairo_surface_t *
    1: _cairo_surface_create_similar_solid (cairo_surface_t	 *other,
    1: 				     cairo_content_t	  content,
    1: 				     int		  width,
    1: 				     int		  height,
16122: 				     const cairo_color_t *color)
    1: {
    1:     cairo_status_t status;
    1:     cairo_surface_t *surface;
16122:     cairo_solid_pattern_t solid_pattern;
    1: 
    1:     surface = _cairo_surface_create_similar_scratch (other, content,
    1: 						     width, height);
10694:     if (surface->status)
10694: 	return surface;
    1: 
16122:     _cairo_pattern_init_solid (&solid_pattern, color, content);
    1: 
    1:     status = _cairo_surface_paint (surface,
    1: 				   color == CAIRO_COLOR_TRANSPARENT ?
16122: 				   CAIRO_OPERATOR_CLEAR : CAIRO_OPERATOR_SOURCE,
26419: 				   &solid_pattern.base, NULL);
    1: 
16122:     _cairo_pattern_fini (&solid_pattern.base);
    1: 
26419:     if (unlikely (status)) {
    1: 	cairo_surface_destroy (surface);
10694: 	return _cairo_surface_create_in_error (status);
    1:     }
    1: 
    1:     return surface;
    1: }
    1: 
16122: cairo_surface_t *
16122: _cairo_surface_create_solid_pattern_surface (cairo_surface_t	   *other,
26419: 					     const cairo_solid_pattern_t *solid_pattern)
16122: {
26419:     if (other->backend->create_solid_pattern_surface != NULL) {
16122: 	cairo_surface_t *surface;
16122: 
26419: 	surface = other->backend->create_solid_pattern_surface (other,
26419: 								solid_pattern);
16122: 	if (surface)
16122: 	    return surface;
16122:     }
16122: 
26419:     return _cairo_surface_create_similar_solid (other,
16122: 						solid_pattern->content,
16122: 						1, 1,
16122: 						&solid_pattern->color);
16122: }
16122: 
16122: cairo_int_status_t
16122: _cairo_surface_repaint_solid_pattern_surface (cairo_surface_t	    *other,
16122: 					      cairo_surface_t       *solid_surface,
26419: 					      const cairo_solid_pattern_t *solid_pattern)
16122: {
26419:     /* Solid pattern surface for these backends are special and not trivial
26419:      * to repaint.  Skip repainting.
16122:      *
16122:      * This does not work optimally with things like analysis surface that
16122:      * are proxies.  But returning UNSUPPORTED is *safe* as it only
16122:      * disables some caching.
16122:      */
26419:     if (other->backend->create_solid_pattern_surface != NULL &&
26419: 	! other->backend->can_repaint_solid_pattern_surface (solid_surface,
26419: 							     solid_pattern))
26419:     {
16122: 	return CAIRO_INT_STATUS_UNSUPPORTED;
26419:     }
26419: 
26419:     return _cairo_surface_paint (solid_surface,
26419: 				 CAIRO_OPERATOR_SOURCE,
26419: 				 &solid_pattern->base,
26419: 				 NULL);
16122: }
16122: 
    1: cairo_clip_mode_t
    1: _cairo_surface_get_clip_mode (cairo_surface_t *surface)
    1: {
    1:     if (surface->backend->intersect_clip_path != NULL)
    1: 	return CAIRO_CLIP_MODE_PATH;
    1:     else if (surface->backend->set_clip_region != NULL)
    1: 	return CAIRO_CLIP_MODE_REGION;
    1:     else
    1: 	return CAIRO_CLIP_MODE_MASK;
    1: }
    1: 
    1: /**
    1:  * cairo_surface_reference:
    1:  * @surface: a #cairo_surface_t
    1:  *
    1:  * Increases the reference count on @surface by one. This prevents
    1:  * @surface from being destroyed until a matching call to
    1:  * cairo_surface_destroy() is made.
    1:  *
  314:  * The number of references to a #cairo_surface_t can be get using
  314:  * cairo_surface_get_reference_count().
  314:  *
    1:  * Return value: the referenced #cairo_surface_t.
    1:  **/
    1: cairo_surface_t *
    1: cairo_surface_reference (cairo_surface_t *surface)
    1: {
 8452:     if (surface == NULL ||
 8452: 	    CAIRO_REFERENCE_COUNT_IS_INVALID (&surface->ref_count))
    1: 	return surface;
    1: 
 8452:     assert (CAIRO_REFERENCE_COUNT_HAS_REFERENCE (&surface->ref_count));
    1: 
 8452:     _cairo_reference_count_inc (&surface->ref_count);
    1: 
    1:     return surface;
    1: }
    1: slim_hidden_def (cairo_surface_reference);
    1: 
    1: /**
    1:  * cairo_surface_destroy:
 4133:  * @surface: a #cairo_surface_t
    1:  *
    1:  * Decreases the reference count on @surface by one. If the result is
    1:  * zero, then @surface and all associated resources are freed.  See
    1:  * cairo_surface_reference().
    1:  **/
    1: void
    1: cairo_surface_destroy (cairo_surface_t *surface)
    1: {
 8452:     if (surface == NULL ||
 8452: 	    CAIRO_REFERENCE_COUNT_IS_INVALID (&surface->ref_count))
    1: 	return;
    1: 
 8452:     assert (CAIRO_REFERENCE_COUNT_HAS_REFERENCE (&surface->ref_count));
    1: 
 8452:     if (! _cairo_reference_count_dec_and_test (&surface->ref_count))
    1: 	return;
    1: 
32473:     assert (surface->snapshot_of == NULL);
32473: 
  314:     if (! surface->finished)
    1: 	cairo_surface_finish (surface);
    1: 
    1:     _cairo_user_data_array_fini (&surface->user_data);
26419:     _cairo_user_data_array_fini (&surface->mime_data);
32473:     _cairo_array_fini (&surface->snapshots);
    1: 
    1:     free (surface);
    1: }
    1: slim_hidden_def(cairo_surface_destroy);
    1: 
    1: /**
16122:  * _cairo_surface_reset:
 4133:  * @surface: a #cairo_surface_t
 4133:  *
 4133:  * Resets the surface back to defaults such that it may be reused in lieu
 4133:  * of creating a new surface.
 4133:  **/
 4133: cairo_status_t
 4133: _cairo_surface_reset (cairo_surface_t *surface)
 4133: {
 8452:     if (surface == NULL ||
 8452: 	    CAIRO_REFERENCE_COUNT_IS_INVALID (&surface->ref_count))
 4133: 	return CAIRO_STATUS_SUCCESS;
 4133: 
 8452:     assert (CAIRO_REFERENCE_COUNT_GET_VALUE (&surface->ref_count) == 1);
 4133: 
 4133:     _cairo_user_data_array_fini (&surface->user_data);
26419:     _cairo_user_data_array_fini (&surface->mime_data);
 4133: 
 4133:     if (surface->backend->reset != NULL) {
 4133: 	cairo_status_t status = surface->backend->reset (surface);
26419: 	if (unlikely (status))
 8452: 	    return _cairo_surface_set_error (surface, status);
 4133:     }
 4133: 
 4133:     _cairo_surface_init (surface, surface->backend, surface->content);
 4133: 
 4133:     return CAIRO_STATUS_SUCCESS;
 4133: }
 4133: 
 4133: /**
  314:  * cairo_surface_get_reference_count:
  314:  * @surface: a #cairo_surface_t
  314:  *
  314:  * Returns the current reference count of @surface.
  314:  *
  314:  * Return value: the current reference count of @surface.  If the
  314:  * object is a nil object, 0 will be returned.
  314:  *
  314:  * Since: 1.4
  314:  **/
  314: unsigned int
  314: cairo_surface_get_reference_count (cairo_surface_t *surface)
  314: {
 8452:     if (surface == NULL ||
 8452: 	    CAIRO_REFERENCE_COUNT_IS_INVALID (&surface->ref_count))
  314: 	return 0;
  314: 
 8452:     return CAIRO_REFERENCE_COUNT_GET_VALUE (&surface->ref_count);
  314: }
  314: 
  314: /**
    1:  * cairo_surface_finish:
    1:  * @surface: the #cairo_surface_t to finish
    1:  *
    1:  * This function finishes the surface and drops all references to
    1:  * external resources.  For example, for the Xlib backend it means
    1:  * that cairo will no longer access the drawable, which can be freed.
    1:  * After calling cairo_surface_finish() the only valid operations on a
16122:  * surface are getting and setting user, referencing and
16122:  * destroying, and flushing and finishing it.
16122:  * Further drawing to the surface will not affect the
16122:  * surface but will instead trigger a %CAIRO_STATUS_SURFACE_FINISHED
    1:  * error.
    1:  *
    1:  * When the last call to cairo_surface_destroy() decreases the
    1:  * reference count to zero, cairo will call cairo_surface_finish() if
    1:  * it hasn't been called already, before freeing the resources
    1:  * associated with the surface.
    1:  **/
    1: void
    1: cairo_surface_finish (cairo_surface_t *surface)
    1: {
    1:     cairo_status_t status;
    1: 
  314:     if (surface == NULL)
  314: 	return;
  314: 
 8452:     if (CAIRO_REFERENCE_COUNT_IS_INVALID (&surface->ref_count))
  314: 	return;
  314: 
16122:     if (surface->finished)
    1: 	return;
    1: 
16122:     cairo_surface_flush (surface);
    1: 
16122:     /* call finish even if in error mode */
16122:     if (surface->backend->finish) {
    1: 	status = surface->backend->finish (surface);
26419: 	if (unlikely (status))
 8452: 	    status = _cairo_surface_set_error (surface, status);
16122:     }
    1: 
    1:     surface->finished = TRUE;
32473: 
32473:     if (surface->snapshot_of != NULL)
32473: 	_cairo_surface_detach_snapshot (surface);
    1: }
    1: slim_hidden_def (cairo_surface_finish);
    1: 
    1: /**
    1:  * cairo_surface_get_user_data:
    1:  * @surface: a #cairo_surface_t
    1:  * @key: the address of the #cairo_user_data_key_t the user data was
    1:  * attached to
    1:  *
    1:  * Return user data previously attached to @surface using the specified
    1:  * key.  If no user data has been attached with the given key this
    1:  * function returns %NULL.
    1:  *
    1:  * Return value: the user data previously attached or %NULL.
    1:  **/
    1: void *
    1: cairo_surface_get_user_data (cairo_surface_t		 *surface,
    1: 			     const cairo_user_data_key_t *key)
    1: {
    1:     return _cairo_user_data_array_get_data (&surface->user_data,
    1: 					    key);
    1: }
    1: 
    1: /**
    1:  * cairo_surface_set_user_data:
    1:  * @surface: a #cairo_surface_t
    1:  * @key: the address of a #cairo_user_data_key_t to attach the user data to
    1:  * @user_data: the user data to attach to the surface
    1:  * @destroy: a #cairo_destroy_func_t which will be called when the
    1:  * surface is destroyed or when new user data is attached using the
    1:  * same key.
    1:  *
    1:  * Attach user data to @surface.  To remove user data from a surface,
    1:  * call this function with the key that was used to set it and %NULL
    1:  * for @data.
    1:  *
    1:  * Return value: %CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY if a
    1:  * slot could not be allocated for the user data.
    1:  **/
    1: cairo_status_t
    1: cairo_surface_set_user_data (cairo_surface_t		 *surface,
    1: 			     const cairo_user_data_key_t *key,
    1: 			     void			 *user_data,
    1: 			     cairo_destroy_func_t	 destroy)
    1: {
 8452:     if (CAIRO_REFERENCE_COUNT_IS_INVALID (&surface->ref_count))
21379: 	return surface->status;
    1: 
    1:     return _cairo_user_data_array_set_data (&surface->user_data,
    1: 					    key, user_data, destroy);
    1: }
    1: 
    1: /**
26419:  * cairo_surface_get_mime_data:
26419:  * @surface: a #cairo_surface_t
26419:  * @mime_type: the mime type of the image data
26419:  * @data: the image data to attached to the surface
26419:  * @length: the length of the image data
26419:  *
26419:  * Return mime data previously attached to @surface using the
26419:  * specified mime type.  If no data has been attached with the given
26419:  * mime type, @data is set %NULL.
26419:  *
26419:  * Since: 1.10
26419:  **/
26419: void
26419: cairo_surface_get_mime_data (cairo_surface_t		*surface,
26419:                              const char			*mime_type,
26419:                              const unsigned char       **data,
26419:                              unsigned int		*length)
26419: {
32473:     cairo_user_data_slot_t *slots;
32473:     int i, num_slots;
26419: 
26419:     *data = NULL;
26419:     *length = 0;
32473:     if (unlikely (surface->status))
26419: 	return;
26419: 
32473:     /* The number of mime-types attached to a surface is usually small,
32473:      * typically zero. Therefore it is quicker to do a strcmp() against
32473:      * each key than it is to intern the string (i.e. compute a hash,
32473:      * search the hash table, and do a final strcmp).
32473:      */
32473:     num_slots = surface->mime_data.num_elements;
32473:     slots = _cairo_array_index (&surface->mime_data, 0);
32473:     for (i = 0; i < num_slots; i++) {
32473: 	if (strcmp ((char *) slots[i].key, mime_type) == 0) {
32473: 	    cairo_mime_data_t *mime_data = slots[i].user_data;
32473: 
32473: 	    *data = mime_data->data;
32473: 	    *length = mime_data->length;
32346: 	    return;
32346: 	}
32473:     }
26419: }
26419: slim_hidden_def (cairo_surface_get_mime_data);
26419: 
26419: static void
26419: _cairo_mime_data_destroy (void *ptr)
26419: {
26419:     cairo_mime_data_t *mime_data = ptr;
26419: 
26419:     if (! _cairo_reference_count_dec_and_test (&mime_data->ref_count))
26419: 	return;
26419: 
26419:     if (mime_data->destroy && mime_data->closure)
26419: 	mime_data->destroy (mime_data->closure);
26419: 
26419:     free (mime_data);
26419: }
26419: 
26419: /**
26419:  * cairo_surface_set_mime_data:
26419:  * @surface: a #cairo_surface_t
26419:  * @mime_type: the mime type of the image data
26419:  * @data: the image data to attach to the surface
26419:  * @length: the length of the image data
26419:  * @destroy: a #cairo_destroy_func_t which will be called when the
26419:  * surface is destroyed or when new image data is attached using the
26419:  * same mime type.
26419:  * @closure: the data to be passed to the @destroy notifier
26419:  *
26419:  * Attach an image in the format @mime_type to @surface. To remove
26419:  * the data from a surface, call this function with same mime type
26419:  * and %NULL for @data.
26419:  *
26419:  * Since: 1.10
26419:  *
26419:  * Return value: %CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY if a
26419:  * slot could not be allocated for the user data.
26419:  **/
26419: cairo_status_t
26419: cairo_surface_set_mime_data (cairo_surface_t		*surface,
26419:                              const char			*mime_type,
26419:                              const unsigned char	*data,
26419:                              unsigned int		 length,
26419: 			     cairo_destroy_func_t	 destroy,
26419: 			     void			*closure)
26419: {
26419:     cairo_status_t status;
26419:     cairo_mime_data_t *mime_data;
26419: 
26419:     if (unlikely (surface->status))
26419: 	return surface->status;
26419: 
26419:     status = _cairo_intern_string (&mime_type, -1);
26419:     if (unlikely (status))
26419: 	return _cairo_surface_set_error (surface, status);
26419: 
26419:     if (data != NULL) {
26419: 	mime_data = malloc (sizeof (cairo_mime_data_t));
26419: 	if (unlikely (mime_data == NULL))
26419: 	    return _cairo_surface_set_error (surface, _cairo_error (CAIRO_STATUS_NO_MEMORY));
26419: 
26419: 	CAIRO_REFERENCE_COUNT_INIT (&mime_data->ref_count, 1);
26419: 
26419: 	mime_data->data = (unsigned char *) data;
26419: 	mime_data->length = length;
26419: 	mime_data->destroy = destroy;
26419: 	mime_data->closure = closure;
26419:     } else
26419: 	mime_data = NULL;
26419: 
26419:     status = _cairo_user_data_array_set_data (&surface->mime_data,
26419: 					      (cairo_user_data_key_t *) mime_type,
26419: 					      mime_data,
26419: 					      _cairo_mime_data_destroy);
26419:     if (unlikely (status)) {
26419: 	if (mime_data != NULL)
26419: 	    free (mime_data);
26419: 
26419: 	return _cairo_surface_set_error (surface, status);
26419:     }
26419: 
26419:     return CAIRO_STATUS_SUCCESS;
26419: }
26419: slim_hidden_def (cairo_surface_set_mime_data);
26419: 
26419: static void
26419: _cairo_mime_data_reference (const void *key, void *elt, void *closure)
26419: {
26419:     cairo_mime_data_t *mime_data = elt;
26419: 
26419:     _cairo_reference_count_inc (&mime_data->ref_count);
26419: }
26419: 
26419: cairo_status_t
26419: _cairo_surface_copy_mime_data (cairo_surface_t *dst,
26419: 			       cairo_surface_t *src)
26419: {
26419:     cairo_status_t status;
26419: 
26419:     if (dst->status)
26419: 	return dst->status;
26419: 
26419:     if (src->status)
26419: 	return _cairo_surface_set_error (dst, src->status);
26419: 
26419:     /* first copy the mime-data, discarding any already set on dst */
26419:     status = _cairo_user_data_array_copy (&dst->mime_data, &src->mime_data);
26419:     if (unlikely (status))
26419: 	return _cairo_surface_set_error (dst, status);
26419: 
26419:     /* now increment the reference counters for the copies */
26419:     _cairo_user_data_array_foreach (&dst->mime_data,
26419: 				    _cairo_mime_data_reference,
26419: 				    NULL);
26419: 
26419:     return CAIRO_STATUS_SUCCESS;
26419: }
26419: 
26419: /**
    1:  * _cairo_surface_set_font_options:
    1:  * @surface: a #cairo_surface_t
    1:  * @options: a #cairo_font_options_t object that contains the
    1:  *   options to use for this surface instead of backend's default
    1:  *   font options.
    1:  *
    1:  * Sets the default font rendering options for the surface.
    1:  * This is useful to correctly propagate default font options when
    1:  * falling back to an image surface in a backend implementation.
    1:  * This affects the options returned in cairo_surface_get_font_options().
    1:  *
    1:  * If @options is %NULL the surface options are reset to those of
    1:  * the backend default.
    1:  **/
    1: void
    1: _cairo_surface_set_font_options (cairo_surface_t       *surface,
    1: 				 cairo_font_options_t  *options)
    1: {
 8452:     cairo_status_t status;
 8452: 
 8452:     if (surface->status)
 8452: 	return;
 8452: 
32473:     assert (surface->snapshot_of == NULL);
21379: 
 8452:     if (surface->finished) {
 8452: 	status = _cairo_surface_set_error (surface,
 8452: 		                           CAIRO_STATUS_SURFACE_FINISHED);
 8452: 	return;
 8452:     }
 8452: 
    1:     if (options) {
    1: 	surface->has_font_options = TRUE;
    1: 	_cairo_font_options_init_copy (&surface->font_options, options);
    1:     } else {
    1: 	surface->has_font_options = FALSE;
    1:     }
    1: }
    1: 
    1: /**
    1:  * cairo_surface_get_font_options:
    1:  * @surface: a #cairo_surface_t
    1:  * @options: a #cairo_font_options_t object into which to store
    1:  *   the retrieved options. All existing values are overwritten
    1:  *
    1:  * Retrieves the default font rendering options for the surface.
    1:  * This allows display surfaces to report the correct subpixel order
    1:  * for rendering on them, print surfaces to disable hinting of
    1:  * metrics and so forth. The result can then be used with
    1:  * cairo_scaled_font_create().
    1:  **/
    1: void
    1: cairo_surface_get_font_options (cairo_surface_t       *surface,
    1: 				cairo_font_options_t  *options)
    1: {
 4133:     if (cairo_font_options_status (options))
 4133: 	return;
 4133: 
18904:     if (surface->status) {
18904: 	_cairo_font_options_init_default (options);
18904: 	return;
18904:     }
18904: 
    1:     if (! surface->has_font_options) {
    1: 	surface->has_font_options = TRUE;
    1: 
 4133: 	_cairo_font_options_init_default (&surface->font_options);
 4133: 
    1: 	if (!surface->finished && surface->backend->get_font_options) {
    1: 	    surface->backend->get_font_options (surface, &surface->font_options);
    1: 	}
    1:     }
    1: 
    1:     _cairo_font_options_init_copy (options, &surface->font_options);
    1: }
    1: slim_hidden_def (cairo_surface_get_font_options);
    1: 
    1: /**
    1:  * cairo_surface_flush:
    1:  * @surface: a #cairo_surface_t
    1:  *
    1:  * Do any pending drawing for the surface and also restore any
    1:  * temporary modification's cairo has made to the surface's
    1:  * state. This function must be called before switching from
    1:  * drawing on the surface with cairo to drawing on it directly
    1:  * with native APIs. If the surface doesn't support direct access,
    1:  * then this function does nothing.
    1:  **/
    1: void
    1: cairo_surface_flush (cairo_surface_t *surface)
    1: {
 8452:     cairo_status_t status;
 8452: 
    1:     if (surface->status)
    1: 	return;
    1: 
16122:     if (surface->finished)
    1: 	return;
    1: 
32473:     /* update the current snapshots *before* the user updates the surface */
32473:     _cairo_surface_detach_snapshots (surface);
32473: 
    1:     if (surface->backend->flush) {
    1: 	status = surface->backend->flush (surface);
26419: 	if (unlikely (status))
 8452: 	    status = _cairo_surface_set_error (surface, status);
    1:     }
    1: }
16122: slim_hidden_def (cairo_surface_flush);
    1: 
    1: /**
    1:  * cairo_surface_mark_dirty:
    1:  * @surface: a #cairo_surface_t
    1:  *
    1:  * Tells cairo that drawing has been done to surface using means other
    1:  * than cairo, and that cairo should reread any cached areas. Note
    1:  * that you must call cairo_surface_flush() before doing such drawing.
    1:  */
    1: void
    1: cairo_surface_mark_dirty (cairo_surface_t *surface)
    1: {
    1:     cairo_surface_mark_dirty_rectangle (surface, 0, 0, -1, -1);
    1: }
    1: 
    1: /**
    1:  * cairo_surface_mark_dirty_rectangle:
    1:  * @surface: a #cairo_surface_t
    1:  * @x: X coordinate of dirty rectangle
    1:  * @y: Y coordinate of dirty rectangle
    1:  * @width: width of dirty rectangle
    1:  * @height: height of dirty rectangle
    1:  *
    1:  * Like cairo_surface_mark_dirty(), but drawing has been done only to
    1:  * the specified rectangle, so that cairo can retain cached contents
    1:  * for other parts of the surface.
    1:  *
    1:  * Any cached clip set on the surface will be reset by this function,
    1:  * to make sure that future cairo calls have the clip set that they
    1:  * expect.
    1:  */
    1: void
    1: cairo_surface_mark_dirty_rectangle (cairo_surface_t *surface,
    1: 				    int              x,
    1: 				    int              y,
    1: 				    int              width,
    1: 				    int              height)
    1: {
 8452:     cairo_status_t status;
 8452: 
    1:     if (surface->status)
    1: 	return;
    1: 
32473:     assert (surface->snapshot_of == NULL);
21379: 
    1:     if (surface->finished) {
 8452: 	status = _cairo_surface_set_error (surface, CAIRO_STATUS_SURFACE_FINISHED);
    1: 	return;
    1:     }
    1: 
32473:     /* The application *should* have called cairo_surface_flush() before
32473:      * modifying the surface independently of cairo (and thus having to
32473:      * call mark_dirty()). */
32473:     assert (! _cairo_surface_has_snapshots (surface));
32473: 
    1:     /* Always reset the clip here, to avoid having external calls to
    1:      * clip manipulation functions of the underlying device clip result
    1:      * in a desync between the cairo clip and the backend clip, due to
    1:      * the clip caching.
    1:      */
    1:     surface->current_clip_serial = -1;
    1: 
    1:     if (surface->backend->mark_dirty_rectangle) {
    1: 	/* XXX: FRAGILE: We're ignoring the scaling component of
    1: 	 * device_transform here. I don't know what the right thing to
    1: 	 * do would actually be if there were some scaling here, but
    1: 	 * we avoid this since device_transfom scaling is not exported
    1: 	 * publicly and mark_dirty is not used internally. */
    1: 	status = surface->backend->mark_dirty_rectangle (surface,
    1:                                                          x + surface->device_transform.x0,
    1:                                                          y + surface->device_transform.y0,
    1: 							 width, height);
    1: 
26419: 	if (unlikely (status))
 8452: 	    status = _cairo_surface_set_error (surface, status);
    1:     }
    1: }
    1: slim_hidden_def (cairo_surface_mark_dirty_rectangle);
    1: 
    1: /**
    1:  * _cairo_surface_set_device_scale:
    1:  * @surface: a #cairo_surface_t
    1:  * @sx: a scale factor in the X direction
    1:  * @sy: a scale factor in the Y direction
    1:  *
    1:  * Private function for setting an extra scale factor to affect all
    1:  * drawing to a surface. This is used, for example, when replaying a
    1:  * meta surface to an image fallback intended for an eventual
    1:  * vector-oriented backend. Since the meta surface will record
    1:  * coordinates in one backend space, but the image fallback uses a
    1:  * different backend space, (differing by the fallback resolution
    1:  * scale factors), we need a scale factor correction.
    1:  *
16122:  * Caution: Not all places we use device transform correctly handle
16122:  * both a translate and a scale.  An audit would be nice.
    1:  **/
    1: void
    1: _cairo_surface_set_device_scale (cairo_surface_t *surface,
    1: 				 double		  sx,
    1: 				 double		  sy)
    1: {
 8452:     cairo_status_t status;
 8452: 
    1:     if (surface->status)
    1: 	return;
    1: 
32473:     assert (surface->snapshot_of == NULL);
21379: 
    1:     if (surface->finished) {
 8452: 	status = _cairo_surface_set_error (surface, CAIRO_STATUS_SURFACE_FINISHED);
    1: 	return;
    1:     }
    1: 
32473:     _cairo_surface_begin_modification (surface);
32473: 
    1:     surface->device_transform.xx = sx;
    1:     surface->device_transform.yy = sy;
16122:     surface->device_transform.xy = 0.0;
16122:     surface->device_transform.yx = 0.0;
    1: 
21379:     surface->device_transform_inverse = surface->device_transform;
21379:     status = cairo_matrix_invert (&surface->device_transform_inverse);
21379:     /* should always be invertible unless given pathological input */
21379:     assert (status == CAIRO_STATUS_SUCCESS);
    1: }
    1: 
    1: /**
    1:  * cairo_surface_set_device_offset:
    1:  * @surface: a #cairo_surface_t
    1:  * @x_offset: the offset in the X direction, in device units
    1:  * @y_offset: the offset in the Y direction, in device units
    1:  *
    1:  * Sets an offset that is added to the device coordinates determined
    1:  * by the CTM when drawing to @surface. One use case for this function
    1:  * is when we want to create a #cairo_surface_t that redirects drawing
    1:  * for a portion of an onscreen surface to an offscreen surface in a
    1:  * way that is completely invisible to the user of the cairo
    1:  * API. Setting a transformation via cairo_translate() isn't
    1:  * sufficient to do this, since functions like
    1:  * cairo_device_to_user() will expose the hidden offset.
    1:  *
    1:  * Note that the offset affects drawing to the surface as well as
    1:  * using the surface in a source pattern.
    1:  **/
    1: void
    1: cairo_surface_set_device_offset (cairo_surface_t *surface,
    1: 				 double           x_offset,
    1: 				 double           y_offset)
    1: {
 8452:     cairo_status_t status;
 8452: 
    1:     if (surface->status)
    1: 	return;
    1: 
32473:     assert (surface->snapshot_of == NULL);
21379: 
    1:     if (surface->finished) {
 8452: 	status = _cairo_surface_set_error (surface, CAIRO_STATUS_SURFACE_FINISHED);
    1: 	return;
    1:     }
    1: 
32473:     _cairo_surface_begin_modification (surface);
32473: 
    1:     surface->device_transform.x0 = x_offset;
    1:     surface->device_transform.y0 = y_offset;
    1: 
21379:     surface->device_transform_inverse = surface->device_transform;
21379:     status = cairo_matrix_invert (&surface->device_transform_inverse);
21379:     /* should always be invertible unless given pathological input */
21379:     assert (status == CAIRO_STATUS_SUCCESS);
    1: }
    1: slim_hidden_def (cairo_surface_set_device_offset);
    1: 
    1: /**
    1:  * cairo_surface_get_device_offset:
    1:  * @surface: a #cairo_surface_t
    1:  * @x_offset: the offset in the X direction, in device units
    1:  * @y_offset: the offset in the Y direction, in device units
    1:  *
    1:  * This function returns the previous device offset set by
    1:  * cairo_surface_set_device_offset().
    1:  *
    1:  * Since: 1.2
    1:  **/
    1: void
    1: cairo_surface_get_device_offset (cairo_surface_t *surface,
    1: 				 double          *x_offset,
    1: 				 double          *y_offset)
    1: {
  314:     if (x_offset)
    1: 	*x_offset = surface->device_transform.x0;
  314:     if (y_offset)
    1: 	*y_offset = surface->device_transform.y0;
    1: }
    1: slim_hidden_def (cairo_surface_get_device_offset);
    1: 
    1: /**
    1:  * cairo_surface_set_fallback_resolution:
    1:  * @surface: a #cairo_surface_t
    1:  * @x_pixels_per_inch: horizontal setting for pixels per inch
    1:  * @y_pixels_per_inch: vertical setting for pixels per inch
    1:  *
    1:  * Set the horizontal and vertical resolution for image fallbacks.
    1:  *
    1:  * When certain operations aren't supported natively by a backend,
    1:  * cairo will fallback by rendering operations to an image and then
    1:  * overlaying that image onto the output. For backends that are
    1:  * natively vector-oriented, this function can be used to set the
    1:  * resolution used for these image fallbacks, (larger values will
    1:  * result in more detailed images, but also larger file sizes).
    1:  *
    1:  * Some examples of natively vector-oriented backends are the ps, pdf,
    1:  * and svg backends.
    1:  *
    1:  * For backends that are natively raster-oriented, image fallbacks are
    1:  * still possible, but they are always performed at the native
    1:  * device resolution. So this function has no effect on those
    1:  * backends.
    1:  *
11708:  * Note: The fallback resolution only takes effect at the time of
    1:  * completing a page (with cairo_show_page() or cairo_copy_page()) so
    1:  * there is currently no way to have more than one fallback resolution
    1:  * in effect on a single page.
    1:  *
13980:  * The default fallback resoultion is 300 pixels per inch in both
13980:  * dimensions.
13980:  *
    1:  * Since: 1.2
    1:  **/
    1: void
    1: cairo_surface_set_fallback_resolution (cairo_surface_t	*surface,
    1: 				       double		 x_pixels_per_inch,
    1: 				       double		 y_pixels_per_inch)
    1: {
 8452:     cairo_status_t status;
 8452: 
 8452:     if (surface->status)
 8452: 	return;
 8452: 
32473:     assert (surface->snapshot_of == NULL);
21379: 
 8452:     if (surface->finished) {
 8452: 	status = _cairo_surface_set_error (surface, CAIRO_STATUS_SURFACE_FINISHED);
 8452: 	return;
 8452:     }
 8452: 
32473:     _cairo_surface_begin_modification (surface);
32473: 
    1:     surface->x_fallback_resolution = x_pixels_per_inch;
    1:     surface->y_fallback_resolution = y_pixels_per_inch;
    1: }
    1: slim_hidden_def (cairo_surface_set_fallback_resolution);
    1: 
16122: /**
16122:  * cairo_surface_get_fallback_resolution:
16122:  * @surface: a #cairo_surface_t
16122:  * @x_pixels_per_inch: horizontal pixels per inch
16122:  * @y_pixels_per_inch: vertical pixels per inch
16122:  *
16122:  * This function returns the previous fallback resolution set by
16122:  * cairo_surface_set_fallback_resolution(), or default fallback
16122:  * resolution if never set.
16122:  *
16122:  * Since: 1.8
16122:  **/
16122: void
16122: cairo_surface_get_fallback_resolution (cairo_surface_t	*surface,
16122: 				       double		*x_pixels_per_inch,
16122: 				       double		*y_pixels_per_inch)
16122: {
16122:     if (x_pixels_per_inch)
16122: 	*x_pixels_per_inch = surface->x_fallback_resolution;
16122:     if (y_pixels_per_inch)
16122: 	*y_pixels_per_inch = surface->y_fallback_resolution;
16122: }
16122: 
28304: int
28304: _cairo_surface_get_text_path_fill_threshold (const cairo_surface_t *surface)
28304: {
28304:     return surface->backend->fill == NULL ? 10240 : 256;
28304: }
28304: 
    1: cairo_bool_t
    1: _cairo_surface_has_device_transform (cairo_surface_t *surface)
    1: {
    1:     return ! _cairo_matrix_is_identity (&surface->device_transform);
    1: }
    1: 
    1: /**
    1:  * _cairo_surface_acquire_source_image:
    1:  * @surface: a #cairo_surface_t
    1:  * @image_out: location to store a pointer to an image surface that
    1:  *    has identical contents to @surface. This surface could be @surface
    1:  *    itself, a surface held internal to @surface, or it could be a new
    1:  *    surface with a copy of the relevant portion of @surface.
    1:  * @image_extra: location to store image specific backend data
    1:  *
    1:  * Gets an image surface to use when drawing as a fallback when drawing with
    1:  * @surface as a source. _cairo_surface_release_source_image() must be called
    1:  * when finished.
    1:  *
10414:  * Return value: %CAIRO_STATUS_SUCCESS if an image was stored in @image_out.
    1:  * %CAIRO_INT_STATUS_UNSUPPORTED if an image cannot be retrieved for the specified
    1:  * surface. Or %CAIRO_STATUS_NO_MEMORY.
    1:  **/
    1: cairo_status_t
    1: _cairo_surface_acquire_source_image (cairo_surface_t         *surface,
    1: 				     cairo_image_surface_t  **image_out,
    1: 				     void                   **image_extra)
    1: {
29608:     cairo_status_t status;
29608: 
12588:     if (surface->status)
12588: 	return surface->status;
12588: 
21379:     assert (!surface->finished);
21379: 
10414:     if (surface->backend->acquire_source_image == NULL)
10414: 	return CAIRO_INT_STATUS_UNSUPPORTED;
10414: 
29608:     status = surface->backend->acquire_source_image (surface,
29608: 						     image_out, image_extra);
29608:     if (unlikely (status))
29608: 	return _cairo_surface_set_error (surface, status);
29608: 
29608:     _cairo_debug_check_image_surface_is_defined (&(*image_out)->base);
29608: 
29608:     return CAIRO_STATUS_SUCCESS;
    1: }
    1: 
    1: /**
    1:  * _cairo_surface_release_source_image:
    1:  * @surface: a #cairo_surface_t
    1:  * @image_extra: same as return from the matching _cairo_surface_acquire_source_image()
    1:  *
    1:  * Releases any resources obtained with _cairo_surface_acquire_source_image()
    1:  **/
    1: void
    1: _cairo_surface_release_source_image (cairo_surface_t        *surface,
    1: 				     cairo_image_surface_t  *image,
    1: 				     void                   *image_extra)
    1: {
    1:     assert (!surface->finished);
    1: 
    1:     if (surface->backend->release_source_image)
    1: 	surface->backend->release_source_image (surface, image, image_extra);
    1: }
    1: 
    1: /**
    1:  * _cairo_surface_acquire_dest_image:
    1:  * @surface: a #cairo_surface_t
    1:  * @interest_rect: area of @surface for which fallback drawing is being done.
    1:  *    A value of %NULL indicates that the entire surface is desired.
11708:  *    XXXX I'd like to get rid of being able to pass %NULL here (nothing seems to)
    1:  * @image_out: location to store a pointer to an image surface that includes at least
    1:  *    the intersection of @interest_rect with the visible area of @surface.
    1:  *    This surface could be @surface itself, a surface held internal to @surface,
    1:  *    or it could be a new surface with a copy of the relevant portion of @surface.
    1:  *    If a new surface is created, it should have the same channels and depth
    1:  *    as @surface so that copying to and from it is exact.
    1:  * @image_rect: location to store area of the original surface occupied
    1:  *    by the surface stored in @image.
    1:  * @image_extra: location to store image specific backend data
    1:  *
    1:  * Retrieves a local image for a surface for implementing a fallback drawing
    1:  * operation. After calling this function, the implementation of the fallback
    1:  * drawing operation draws the primitive to the surface stored in @image_out
    1:  * then calls _cairo_surface_release_dest_image(),
    1:  * which, if a temporary surface was created, copies the bits back to the
    1:  * main surface and frees the temporary surface.
    1:  *
    1:  * Return value: %CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY.
    1:  *  %CAIRO_INT_STATUS_UNSUPPORTED can be returned but this will mean that
    1:  *  the backend can't draw with fallbacks. It's possible for the routine
11708:  *  to store %NULL in @local_out and return %CAIRO_STATUS_SUCCESS;
    1:  *  that indicates that no part of @interest_rect is visible, so no drawing
    1:  *  is necessary. _cairo_surface_release_dest_image() should not be called in that
    1:  *  case.
    1:  **/
    1: cairo_status_t
    1: _cairo_surface_acquire_dest_image (cairo_surface_t         *surface,
 4133: 				   cairo_rectangle_int_t   *interest_rect,
    1: 				   cairo_image_surface_t  **image_out,
 4133: 				   cairo_rectangle_int_t   *image_rect,
    1: 				   void                   **image_extra)
    1: {
29608:     cairo_status_t status;
29608: 
12588:     if (surface->status)
12588: 	return surface->status;
12588: 
32473:     assert (_cairo_surface_is_writable (surface));
21379: 
10414:     if (surface->backend->acquire_dest_image == NULL)
10414: 	return CAIRO_INT_STATUS_UNSUPPORTED;
10414: 
29608:     status = surface->backend->acquire_dest_image (surface,
    1: 						   interest_rect,
 8452: 						   image_out,
 8452: 						   image_rect,
29608: 						   image_extra);
29608:     if (unlikely (status))
29608: 	return _cairo_surface_set_error (surface, status);
29608: 
29608:     _cairo_debug_check_image_surface_is_defined (&(*image_out)->base);
29608: 
29608:     return CAIRO_STATUS_SUCCESS;
    1: }
    1: 
    1: /**
    1:  * _cairo_surface_release_dest_image:
    1:  * @surface: a #cairo_surface_t
    1:  * @interest_rect: same as passed to the matching _cairo_surface_acquire_dest_image()
    1:  * @image: same as returned from the matching _cairo_surface_acquire_dest_image()
    1:  * @image_rect: same as returned from the matching _cairo_surface_acquire_dest_image()
    1:  * @image_extra: same as return from the matching _cairo_surface_acquire_dest_image()
    1:  *
    1:  * Finishes the operation started with _cairo_surface_acquire_dest_image(), by, if
    1:  * necessary, copying the image from @image back to @surface and freeing any
    1:  * resources that were allocated.
    1:  **/
    1: void
    1: _cairo_surface_release_dest_image (cairo_surface_t         *surface,
 4133: 				   cairo_rectangle_int_t   *interest_rect,
    1: 				   cairo_image_surface_t   *image,
 4133: 				   cairo_rectangle_int_t   *image_rect,
    1: 				   void                    *image_extra)
    1: {
32473:     assert (_cairo_surface_is_writable (surface));
    1: 
    1:     if (surface->backend->release_dest_image)
    1: 	surface->backend->release_dest_image (surface, interest_rect,
    1: 					      image, image_rect, image_extra);
    1: }
    1: 
32473: static cairo_status_t
32473: _cairo_meta_surface_clone_similar (cairo_surface_t  *surface,
32473: 			           cairo_surface_t  *src,
32473: 				   cairo_content_t   content,
32473: 				   int               src_x,
32473: 				   int               src_y,
32473: 				   int               width,
32473: 				   int               height,
32473: 				   int              *clone_offset_x,
32473: 				   int              *clone_offset_y,
32473: 				   cairo_surface_t **clone_out)
32473: {
32473:     cairo_meta_surface_t *meta = (cairo_meta_surface_t *) src;
32473:     cairo_surface_t *similar;
32473:     cairo_status_t status;
32473: 
32473:     similar = _cairo_surface_has_snapshot (src,
32473: 					   surface->backend,
32473: 					   src->content & content);
32473:     if (similar != NULL) {
32473: 	*clone_out = cairo_surface_reference (similar);
32473: 	*clone_offset_x = 0;
32473: 	*clone_offset_y = 0;
32473: 	return CAIRO_STATUS_SUCCESS;
32473:     }
32473: 
32473:     if (width*height*8 < meta->extents.width*meta->extents.height) {
32473: 	similar = cairo_surface_create_similar (surface,
32473: 						src->content & content,
32473: 						width, height);
32473: 	status = similar->status;
32473: 	if (unlikely (status))
32473: 	    return status;
32473: 
32473: 	cairo_surface_set_device_offset (similar, -src_x, -src_y);
32473: 
32473: 	status = cairo_meta_surface_replay (src, similar);
32473: 	if (unlikely (status)) {
32473: 	    cairo_surface_destroy (similar);
32473: 	    return status;
32473: 	}
32473: 
32473:     } else {
32473: 	similar = cairo_surface_create_similar (surface,
32473: 						src->content & content,
32473: 						meta->extents.width,
32473: 						meta->extents.height);
32473: 	status = similar->status;
32473: 	if (unlikely (status))
32473: 	    return status;
32473: 
32473: 	status = cairo_meta_surface_replay (src, similar);
32473: 	if (unlikely (status)) {
32473: 	    cairo_surface_destroy (similar);
32473: 	    return status;
32473: 	}
32473: 
32473: 	status = _cairo_surface_attach_snapshot (src, similar, NULL);
32473: 	if (unlikely (status)) {
32473: 	    cairo_surface_destroy (similar);
32473: 	    return status;
32473: 	}
32473: 
32473: 	src_x = src_y = 0;
32473:     }
32473: 
32473:     *clone_out = similar;
32473:     *clone_offset_x = src_x;
32473:     *clone_offset_y = src_y;
32473:     return CAIRO_STATUS_SUCCESS;
32473: }
32473: 
26419: struct acquire_source_image_data
26419: {
26419:     cairo_surface_t *src;
26419:     cairo_image_surface_t *image;
26419:     void *image_extra;
26419: };
26419: 
26419: static void
26419: _wrap_release_source_image (void *data)
26419: {
26419:     struct acquire_source_image_data *acquire_data = data;
36261:     _cairo_surface_release_source_image (acquire_data->src,
36261: 					 acquire_data->image,
36261: 					 acquire_data->image_extra);
26419:     free(data);
26419: }
26419: 
26419: static cairo_status_t
26419: _wrap_image (cairo_surface_t *src,
26419: 	     cairo_image_surface_t *image,
26419: 	     void *image_extra,
26419: 	     cairo_image_surface_t **out)
26419: {
26419:     static cairo_user_data_key_t wrap_image_key;
28077:     cairo_image_surface_t *surface;
26419:     cairo_status_t status;
26419: 
26419:     struct acquire_source_image_data *data = malloc (sizeof (*data));
36261:     if (unlikely (data == NULL))
36261: 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
26419:     data->src = src;
26419:     data->image = image;
26419:     data->image_extra = image_extra;
26419: 
36261:     surface = (cairo_image_surface_t*)
36261: 	_cairo_image_surface_create_for_pixman_image (image->pixman_image,
36261: 						      image->pixman_format);
28077:     status = surface->base.status;
36261:     if (status) {
36261: 	free (data);
26419: 	return status;
36261:     }
26419: 
28077:     status = _cairo_user_data_array_set_data (&surface->base.user_data,
26419: 					      &wrap_image_key,
26419: 					      data,
26419: 					      _wrap_release_source_image);
26419:     if (status) {
28077: 	cairo_surface_destroy (&surface->base);
36261: 	free (data);
26419: 	return status;
26419:     }
26419: 
36261:     pixman_image_set_component_alpha (
36261: 	surface->pixman_image,
28363: 	pixman_image_get_component_alpha (image->pixman_image));
28077: 
28077:     *out = surface;
26419:     return CAIRO_STATUS_SUCCESS;
26419: }
26419: 
    1: /**
    1:  * _cairo_surface_clone_similar:
    1:  * @surface: a #cairo_surface_t
    1:  * @src: the source image
29849:  * @content: target content mask
    1:  * @src_x: extent for the rectangle in src we actually care about
    1:  * @src_y: extent for the rectangle in src we actually care about
    1:  * @width: extent for the rectangle in src we actually care about
    1:  * @height: extent for the rectangle in src we actually care about
    1:  * @clone_out: location to store a surface compatible with @surface
    1:  *   and with contents identical to @src. The caller must call
    1:  *   cairo_surface_destroy() on the result.
    1:  *
    1:  * Creates a surface with contents identical to @src but that
    1:  *   can be used efficiently with @surface. If @surface and @src are
    1:  *   already compatible then it may return a new reference to @src.
    1:  *
    1:  * Return value: %CAIRO_STATUS_SUCCESS if a surface was created and stored
    1:  *   in @clone_out. Otherwise %CAIRO_INT_STATUS_UNSUPPORTED or another
    1:  *   error like %CAIRO_STATUS_NO_MEMORY.
    1:  **/
    1: cairo_status_t
    1: _cairo_surface_clone_similar (cairo_surface_t  *surface,
    1: 			      cairo_surface_t  *src,
29849: 			      cairo_content_t	content,
    1: 			      int               src_x,
    1: 			      int               src_y,
    1: 			      int               width,
    1: 			      int               height,
21379: 			      int              *clone_offset_x,
21379: 			      int              *clone_offset_y,
    1: 			      cairo_surface_t **clone_out)
    1: {
 6154:     cairo_status_t status = CAIRO_INT_STATUS_UNSUPPORTED;
    1:     cairo_image_surface_t *image;
    1:     void *image_extra;
    1: 
26419:     if (unlikely (surface->status))
12588: 	return surface->status;
12588: 
26419:     if (unlikely (surface->finished))
 8452: 	return _cairo_error (CAIRO_STATUS_SURFACE_FINISHED);
    1: 
 6154:     if (surface->backend->clone_similar) {
21379: 	status = surface->backend->clone_similar (surface, src,
29849: 						  content,
21379: 						  src_x, src_y,
21379: 						  width, height,
21379: 						  clone_offset_x,
21379: 						  clone_offset_y,
21379: 						  clone_out);
 6154: 
 6154: 	if (status == CAIRO_INT_STATUS_UNSUPPORTED) {
29608: 	    if (_cairo_surface_is_image (src))
29608: 		return CAIRO_INT_STATUS_UNSUPPORTED;
29608: 
26419: 	    /* First check to see if we can replay to a similar surface */
26419: 	    if (_cairo_surface_is_meta (src)) {
32473: 		return _cairo_meta_surface_clone_similar (surface, src,
32473: 							  content,
32473: 							  src_x, src_y,
32473: 							  width, height,
32473: 							  clone_offset_x,
32473: 							  clone_offset_y,
32473: 							  clone_out);
26419: 	    }
26419: 
 6154: 	    /* If we failed, try again with an image surface */
 6154: 	    status = _cairo_surface_acquire_source_image (src, &image, &image_extra);
 6154: 	    if (status == CAIRO_STATUS_SUCCESS) {
26419: 		status = _wrap_image(src, image, image_extra, &image);
26419: 		if (status != CAIRO_STATUS_SUCCESS) {
26419: 		    _cairo_surface_release_source_image (src, image, image_extra);
26419: 		} else {
 6154: 		    status =
 6154: 			surface->backend->clone_similar (surface, &image->base,
29849: 							 content,
 4414: 							 src_x, src_y,
 4414: 							 width, height,
21379: 							 clone_offset_x,
21379: 							 clone_offset_y,
 4414: 							 clone_out);
26419: 		    cairo_surface_destroy(&image->base);
26419: 		}
 6154: 	    }
 6154: 	}
 6154:     }
 6154: 
 6154:     /* If we're still unsupported, hit our fallback path to get a clone */
29608:     if (status == CAIRO_INT_STATUS_UNSUPPORTED) {
 6154: 	status =
21379: 	    _cairo_surface_fallback_clone_similar (surface, src,
29849: 						   content,
21379: 						   src_x, src_y,
21379: 						   width, height,
21379: 						   clone_offset_x,
21379: 						   clone_offset_y,
21379: 						   clone_out);
29608:     }
    1: 
 6154:     /* We should never get UNSUPPORTED here, so if we have an error, bail. */
26419:     if (unlikely (status))
    1: 	return status;
    1: 
 6154:     /* Update the clone's device_transform (which the underlying surface
 6154:      * backend knows nothing about) */
 6154:     if (*clone_out != src) {
    1: 	(*clone_out)->device_transform = src->device_transform;
  314: 	(*clone_out)->device_transform_inverse = src->device_transform_inverse;
  314:     }
    1: 
    1:     return status;
    1: }
    1: 
    1: /* XXX: Shouldn't really need to do this here. */
    1: #include "cairo-meta-surface-private.h"
    1: 
    1: /**
    1:  * _cairo_surface_snapshot
    1:  * @surface: a #cairo_surface_t
    1:  *
    1:  * Make an immutable copy of @surface. It is an error to call a
    1:  * surface-modifying function on the result of this function.
    1:  *
    1:  * The caller owns the return value and should call
16122:  * cairo_surface_destroy() when finished with it. This function will not
11708:  * return %NULL, but will return a nil surface instead.
    1:  *
    1:  * Return value: The snapshot surface. Note that the return surface
    1:  * may not necessarily be of the same type as @surface.
    1:  **/
    1: cairo_surface_t *
    1: _cairo_surface_snapshot (cairo_surface_t *surface)
    1: {
26419:     cairo_surface_t *snapshot;
26419:     cairo_status_t status;
26419: 
12588:     if (surface->status)
12588: 	return _cairo_surface_create_in_error (surface->status);
12588: 
    1:     if (surface->finished)
10694: 	return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_SURFACE_FINISHED));
    1: 
32473:     if (surface->snapshot_of != NULL)
26419: 	return cairo_surface_reference (surface);
26419: 
32473:     snapshot = _cairo_surface_has_snapshot (surface,
32473: 					    surface->backend,
32473: 					    surface->content);
32473:     if (snapshot != NULL)
32473: 	return cairo_surface_reference (snapshot);
32473: 
32473:     if (surface->backend->snapshot != NULL) {
26419: 	snapshot = surface->backend->snapshot (surface);
26419: 	if (unlikely (snapshot->status))
26419: 	    return snapshot;
26419: 
32473: 	/* Is this surface just a proxy - e.g. paginated surfaces? */
32473: 	if (snapshot->backend != surface->backend) {
32473: 	    cairo_surface_t *previous;
32473: 
32473: 	    previous = _cairo_surface_has_snapshot (surface,
32473: 		                                    snapshot->backend,
32473: 						    snapshot->content);
32473: 	    if (previous != NULL) {
32473: 		cairo_surface_destroy (snapshot);
32473: 		return cairo_surface_reference (previous);
32473: 	    }
32473: 	}
32473:     }
32473: 
32473:     if (snapshot == NULL) {
32473: 	snapshot = _cairo_surface_has_snapshot (surface,
32473: 						&_cairo_image_surface_backend,
32473: 						surface->content);
32473: 	if (snapshot != NULL)
32473: 	    return cairo_surface_reference (snapshot);
32473: 
32473: 	snapshot = _cairo_surface_fallback_snapshot (surface);
32473: 	if (unlikely (snapshot->status))
32473: 	    return snapshot;
32473:     }
32473: 
26419:     status = _cairo_surface_copy_mime_data (snapshot, surface);
26419:     if (unlikely (status)) {
26419: 	cairo_surface_destroy (snapshot);
26419: 	return _cairo_surface_create_in_error (status);
26419:     }
26419: 
26419:     snapshot->device_transform = surface->device_transform;
26419:     snapshot->device_transform_inverse = surface->device_transform_inverse;
26419: 
32473:     status = _cairo_surface_attach_snapshot (surface, snapshot, NULL);
32473:     if (unlikely (status)) {
32473: 	cairo_surface_destroy (snapshot);
32473: 	return _cairo_surface_create_in_error (status);
32473:     }
26419: 
26419:     return snapshot;
    1: }
    1: 
 4133: /**
 4133:  * _cairo_surface_is_similar
 4133:  * @surface_a: a #cairo_surface_t
 4133:  * @surface_b: a #cairo_surface_t
 4133:  * @content: a #cairo_content_t
 4133:  *
 4133:  * Find out whether the given surfaces share the same backend,
 4133:  * and if so, whether they can be considered similar.
 4133:  *
 4133:  * The definition of "similar" depends on the backend. In
 4133:  * general, it means that the surface is equivalent to one
11708:  * that would have been generated by a call to cairo_surface_create_similar().
 4133:  *
11708:  * Return value: %TRUE if the surfaces are similar.
 4133:  **/
 4133: cairo_bool_t
 4133: _cairo_surface_is_similar (cairo_surface_t *surface_a,
 4133: 	                   cairo_surface_t *surface_b,
 4133: 			   cairo_content_t content)
 4133: {
 4133:     if (surface_a->backend != surface_b->backend)
 4133: 	return FALSE;
 4133: 
 4133:     if (surface_a->backend->is_similar != NULL)
 4133: 	return surface_a->backend->is_similar (surface_a, surface_b, content);
 4133: 
 4133:     return TRUE;
 4133: }
 4133: 
    1: cairo_status_t
    1: _cairo_surface_composite (cairo_operator_t	op,
26419: 			  const cairo_pattern_t	*src,
26419: 			  const cairo_pattern_t	*mask,
    1: 			  cairo_surface_t	*dst,
    1: 			  int			src_x,
    1: 			  int			src_y,
    1: 			  int			mask_x,
    1: 			  int			mask_y,
    1: 			  int			dst_x,
    1: 			  int			dst_y,
    1: 			  unsigned int		width,
    1: 			  unsigned int		height)
    1: {
    1:     cairo_int_status_t status;
    1: 
32473:     if (dst->status)
32473: 	return dst->status;
32473: 
32473:     assert (_cairo_surface_is_writable (dst));
32473: 
    1:     if (mask) {
    1: 	/* These operators aren't interpreted the same way by the backends;
    1: 	 * they are implemented in terms of other operators in cairo-gstate.c
    1: 	 */
    1: 	assert (op != CAIRO_OPERATOR_SOURCE && op != CAIRO_OPERATOR_CLEAR);
    1:     }
    1: 
    1:     if (dst->backend->composite) {
    1: 	status = dst->backend->composite (op,
    1: 					  src, mask, dst,
    1:                                           src_x, src_y,
    1:                                           mask_x, mask_y,
    1:                                           dst_x, dst_y,
    1: 					  width, height);
    1: 	if (status != CAIRO_INT_STATUS_UNSUPPORTED)
 8452: 	    return _cairo_surface_set_error (dst, status);
    1:     }
    1: 
 8452:     return _cairo_surface_set_error (dst,
 8452: 	    _cairo_surface_fallback_composite (op,
    1: 					      src, mask, dst,
    1: 					      src_x, src_y,
    1: 					      mask_x, mask_y,
    1: 					      dst_x, dst_y,
 8452: 					      width, height));
    1: }
    1: 
    1: /**
    1:  * _cairo_surface_fill_rectangle:
    1:  * @surface: a #cairo_surface_t
    1:  * @op: the operator to apply to the rectangle
    1:  * @color: the source color
    1:  * @x: X coordinate of rectangle, in backend coordinates
    1:  * @y: Y coordinate of rectangle, in backend coordinates
    1:  * @width: width of rectangle, in backend coordinates
    1:  * @height: height of rectangle, in backend coordinates
    1:  *
    1:  * Applies an operator to a rectangle using a solid color as the source.
    1:  * See _cairo_surface_fill_rectangles() for full details.
    1:  *
    1:  * Return value: %CAIRO_STATUS_SUCCESS or the error that occurred
    1:  **/
    1: cairo_status_t
    1: _cairo_surface_fill_rectangle (cairo_surface_t	   *surface,
    1: 			       cairo_operator_t	    op,
    1: 			       const cairo_color_t *color,
    1: 			       int		    x,
    1: 			       int		    y,
    1: 			       int		    width,
    1: 			       int		    height)
    1: {
 4133:     cairo_rectangle_int_t rect;
    1: 
    1:     if (surface->status)
    1: 	return surface->status;
    1: 
32473:     assert (_cairo_surface_is_writable (surface));
    1: 
    1:     rect.x = x;
    1:     rect.y = y;
    1:     rect.width = width;
    1:     rect.height = height;
    1: 
    1:     return _cairo_surface_fill_rectangles (surface, op, color, &rect, 1);
    1: }
    1: 
    1: /**
    1:  * _cairo_surface_fill_region:
    1:  * @surface: a #cairo_surface_t
    1:  * @op: the operator to apply to the region
    1:  * @color: the source color
    1:  * @region: the region to modify, in backend coordinates
    1:  *
    1:  * Applies an operator to a set of rectangles specified as a
 4133:  * #cairo_region_t using a solid color as the source.
    1:  * See _cairo_surface_fill_rectangles() for full details.
    1:  *
    1:  * Return value: %CAIRO_STATUS_SUCCESS or the error that occurred
    1:  **/
    1: cairo_status_t
    1: _cairo_surface_fill_region (cairo_surface_t	   *surface,
    1: 			    cairo_operator_t	    op,
    1: 			    const cairo_color_t    *color,
 4133: 			    cairo_region_t         *region)
    1: {
28364:     int num_rects;
10414:     cairo_rectangle_int_t stack_rects[CAIRO_STACK_ARRAY_LENGTH (cairo_rectangle_int_t)];
 8452:     cairo_rectangle_int_t *rects = stack_rects;
    1:     cairo_status_t status;
    1:     int i;
    1: 
12588:     if (surface->status)
12588: 	return surface->status;
12588: 
32473:     assert (_cairo_surface_is_writable (surface));
21379: 
28364:     num_rects = cairo_region_num_rectangles (region);
28364:     if (num_rects == 0)
 8452: 	return CAIRO_STATUS_SUCCESS;
 8452: 
28364:     if (num_rects > ARRAY_LENGTH (stack_rects)) {
28364: 	rects = _cairo_malloc_ab (num_rects,
 8452: 				  sizeof (cairo_rectangle_int_t));
26419: 	if (rects == NULL) {
 8452: 	    return _cairo_surface_set_error (surface,
26419: 					     _cairo_error (CAIRO_STATUS_NO_MEMORY));
 4133: 	}
 4133:     }
    1: 
28364:     for (i = 0; i < num_rects; i++)
28364: 	cairo_region_get_rectangle (region, i, &rects[i]);
    1: 
    1:     status =  _cairo_surface_fill_rectangles (surface, op,
28364: 					      color, rects, num_rects);
    1: 
 4133:     if (rects != stack_rects)
    1: 	free (rects);
    1: 
 8452:     return _cairo_surface_set_error (surface, status);
    1: }
    1: 
    1: /**
    1:  * _cairo_surface_fill_rectangles:
    1:  * @surface: a #cairo_surface_t
    1:  * @op: the operator to apply to the region
    1:  * @color: the source color
    1:  * @rects: the rectangles to modify, in backend coordinates
    1:  * @num_rects: the number of rectangles in @rects
    1:  *
    1:  * Applies an operator to a set of rectangles using a solid color
    1:  * as the source. Note that even if the operator is an unbounded operator
    1:  * such as %CAIRO_OPERATOR_IN, only the given set of rectangles
    1:  * is affected. This differs from _cairo_surface_composite_trapezoids()
    1:  * where the entire destination rectangle is cleared.
    1:  *
    1:  * Return value: %CAIRO_STATUS_SUCCESS or the error that occurred
    1:  **/
    1: cairo_status_t
    1: _cairo_surface_fill_rectangles (cairo_surface_t		*surface,
    1: 				cairo_operator_t         op,
    1: 				const cairo_color_t	*color,
 4133: 				cairo_rectangle_int_t	*rects,
    1: 				int			 num_rects)
    1: {
    1:     cairo_int_status_t status;
    1: 
    1:     if (surface->status)
    1: 	return surface->status;
    1: 
32473:     assert (_cairo_surface_is_writable (surface));
    1: 
    1:     if (num_rects == 0)
    1: 	return CAIRO_STATUS_SUCCESS;
    1: 
    1:     if (surface->backend->fill_rectangles) {
    1: 	status = surface->backend->fill_rectangles (surface, op, color,
    1: 						    rects, num_rects);
    1: 	if (status != CAIRO_INT_STATUS_UNSUPPORTED)
 8452: 	    return _cairo_surface_set_error (surface, status);
    1:     }
    1: 
 8452:     return _cairo_surface_set_error (surface,
 8452: 	    _cairo_surface_fallback_fill_rectangles (surface, op, color,
 8452: 						     rects, num_rects));
    1: }
    1: 
    1: cairo_status_t
    1: _cairo_surface_paint (cairo_surface_t	*surface,
    1: 		      cairo_operator_t	 op,
26419: 		      const cairo_pattern_t *source,
26419: 		      cairo_rectangle_int_t *extents)
    1: {
    1:     cairo_status_t status;
26419:     cairo_pattern_union_t dev_source;
    1: 
12588:     if (surface->status)
12588: 	return surface->status;
12588: 
32473:     _cairo_surface_begin_modification (surface);
21379: 
26419:     status = _cairo_surface_copy_pattern_for_destination (&source,
26419: 							  surface,
26419: 							  &dev_source.base);
26419:     if (unlikely (status))
 8452: 	return _cairo_surface_set_error (surface, status);
    1: 
    1:     if (surface->backend->paint) {
26419: 	status = surface->backend->paint (surface, op, source, extents);
    1: 	if (status != CAIRO_INT_STATUS_UNSUPPORTED)
    1:             goto FINISH;
    1:     }
    1: 
26419:     status = _cairo_surface_fallback_paint (surface, op, source);
    1: 
    1:  FINISH:
26419:     if (source == &dev_source.base)
26419: 	_cairo_pattern_fini (&dev_source.base);
    1: 
 8452:     return _cairo_surface_set_error (surface, status);
    1: }
    1: 
    1: cairo_status_t
    1: _cairo_surface_mask (cairo_surface_t		*surface,
    1: 		     cairo_operator_t		 op,
26419: 		     const cairo_pattern_t	*source,
26419: 		     const cairo_pattern_t	*mask,
26419: 		     cairo_rectangle_int_t      *extents)
    1: {
    1:     cairo_status_t status;
26419:     cairo_pattern_union_t dev_source;
26419:     cairo_pattern_union_t dev_mask;
    1: 
12588:     if (surface->status)
12588: 	return surface->status;
12588: 
32473:     _cairo_surface_begin_modification (surface);
21379: 
26419:     status = _cairo_surface_copy_pattern_for_destination (&source,
26419: 							  surface,
26419: 							  &dev_source.base);
26419:     if (unlikely (status))
 4133: 	goto FINISH;
 8452: 
26419:     status = _cairo_surface_copy_pattern_for_destination (&mask,
26419: 							  surface,
26419: 							  &dev_mask.base);
26419:     if (unlikely (status))
 4133: 	goto CLEANUP_SOURCE;
    1: 
    1:     if (surface->backend->mask) {
26419: 	status = surface->backend->mask (surface, op, source, mask, extents);
    1: 	if (status != CAIRO_INT_STATUS_UNSUPPORTED)
 4133:             goto CLEANUP_MASK;
    1:     }
    1: 
26419:     status = _cairo_surface_fallback_mask (surface, op, source, mask);
    1: 
 4133:  CLEANUP_MASK:
26419:     if (mask == &dev_mask.base)
26419: 	_cairo_pattern_fini (&dev_mask.base);
 4133:  CLEANUP_SOURCE:
26419:     if (source == &dev_source.base)
26419: 	_cairo_pattern_fini (&dev_source.base);
 3847:  FINISH:
    1: 
 8452:     return _cairo_surface_set_error (surface, status);
    1: }
    1: 
    1: cairo_status_t
 6154: _cairo_surface_fill_stroke (cairo_surface_t	    *surface,
 6154: 			    cairo_operator_t	     fill_op,
26419: 			    const cairo_pattern_t   *fill_source,
 6154: 			    cairo_fill_rule_t	     fill_rule,
 6154: 			    double		     fill_tolerance,
 6154: 			    cairo_antialias_t	     fill_antialias,
 6154: 			    cairo_path_fixed_t	    *path,
 6154: 			    cairo_operator_t	     stroke_op,
26419: 			    const cairo_pattern_t   *stroke_source,
 6154: 			    cairo_stroke_style_t    *stroke_style,
 6154: 			    cairo_matrix_t	    *stroke_ctm,
 6154: 			    cairo_matrix_t	    *stroke_ctm_inverse,
 6154: 			    double		     stroke_tolerance,
26419: 			    cairo_antialias_t	     stroke_antialias,
26419: 			    cairo_rectangle_int_t   *extents)
 6154: {
 6154:     cairo_status_t status;
 6154: 
12588:     if (surface->status)
12588: 	return surface->status;
12588: 
32473:     _cairo_surface_begin_modification (surface);
32473: 
 6154:     if (surface->backend->fill_stroke) {
26419: 	cairo_pattern_union_t dev_stroke_source;
26419: 	cairo_pattern_union_t dev_fill_source;
 6154: 	cairo_matrix_t dev_ctm = *stroke_ctm;
 6154: 	cairo_matrix_t dev_ctm_inverse = *stroke_ctm_inverse;
 6154: 
26419: 	status = _cairo_surface_copy_pattern_for_destination (&stroke_source,
26419: 							      surface,
26419: 							      &dev_stroke_source.base);
26419: 	if (unlikely (status))
 8452: 	    return _cairo_surface_set_error (surface, status);
 6154: 
26419: 	status = _cairo_surface_copy_pattern_for_destination (&fill_source,
26419: 							      surface,
26419: 							      &dev_fill_source.base);
26419: 	if (unlikely (status)) {
26419: 	    if (stroke_source == &dev_stroke_source.base)
26419: 		_cairo_pattern_fini (&dev_stroke_source.base);
26419: 
 8452: 	    return _cairo_surface_set_error (surface, status);
 6154: 	}
 6154: 
26419: 	status = surface->backend->fill_stroke (surface,
26419: 						fill_op, fill_source, fill_rule,
26419: 						fill_tolerance, fill_antialias,
26419: 						path,
26419: 						stroke_op, stroke_source,
26419: 						stroke_style,
26419: 						&dev_ctm, &dev_ctm_inverse,
26419: 						stroke_tolerance, stroke_antialias,
26419: 						extents);
26419: 
26419: 	if (stroke_source == &dev_stroke_source.base)
26419: 	    _cairo_pattern_fini (&dev_stroke_source.base);
26419: 
26419: 	if (fill_source == &dev_fill_source.base)
26419: 	    _cairo_pattern_fini (&dev_fill_source.base);
 6154: 
 6154: 	if (status != CAIRO_INT_STATUS_UNSUPPORTED)
 8452: 	    return _cairo_surface_set_error (surface, status);
 6154:     }
 6154: 
 6154:     status = _cairo_surface_fill (surface, fill_op, fill_source, path,
26419: 				  fill_rule, fill_tolerance, fill_antialias, NULL);
26419:     if (unlikely (status))
 8452: 	return _cairo_surface_set_error (surface, status);
 6154: 
 6154:     status = _cairo_surface_stroke (surface, stroke_op, stroke_source, path,
 6154: 				    stroke_style, stroke_ctm, stroke_ctm_inverse,
26419: 				    stroke_tolerance, stroke_antialias, NULL);
26419:     if (unlikely (status))
 8452: 	return _cairo_surface_set_error (surface, status);
 6154: 
 8452:     return CAIRO_STATUS_SUCCESS;
 6154: }
 6154: 
 6154: cairo_status_t
    1: _cairo_surface_stroke (cairo_surface_t		*surface,
    1: 		       cairo_operator_t		 op,
26419: 		       const cairo_pattern_t	*source,
    1: 		       cairo_path_fixed_t	*path,
    1: 		       cairo_stroke_style_t	*stroke_style,
    1: 		       cairo_matrix_t		*ctm,
    1: 		       cairo_matrix_t		*ctm_inverse,
    1: 		       double			 tolerance,
26419: 		       cairo_antialias_t	 antialias,
26419: 		       cairo_rectangle_int_t    *extents)
    1: {
    1:     cairo_status_t status;
26419:     cairo_pattern_union_t dev_source;
    1:     cairo_path_fixed_t *dev_path = path;
    1:     cairo_path_fixed_t real_dev_path;
    1:     cairo_matrix_t dev_ctm = *ctm;
    1:     cairo_matrix_t dev_ctm_inverse = *ctm_inverse;
    1: 
12588:     if (surface->status)
12588: 	return surface->status;
12588: 
32473:     _cairo_surface_begin_modification (surface);
21379: 
26419:     status = _cairo_surface_copy_pattern_for_destination (&source,
26419: 							  surface,
26419: 							  &dev_source.base);
26419:     if (unlikely (status))
 8452: 	return _cairo_surface_set_error (surface, status);
    1: 
    1:     if (surface->backend->stroke) {
26419: 	status = surface->backend->stroke (surface, op, source,
26419: 					   path, stroke_style,
26419: 					   &dev_ctm, &dev_ctm_inverse,
26419: 					   tolerance, antialias, extents);
26419: 
26419: 	if (status != CAIRO_INT_STATUS_UNSUPPORTED)
26419:             goto FINISH;
26419:     }
26419: 
26419:     status = _cairo_surface_fallback_stroke (surface, op, source,
    1:                                              path, stroke_style,
    1:                                              &dev_ctm, &dev_ctm_inverse,
    1:                                              tolerance, antialias);
    1: 
26419:  FINISH:
26419:     if (dev_path == &real_dev_path)
26419:         _cairo_path_fixed_fini (&real_dev_path);
26419: 
26419:     if (source == &dev_source.base)
26419: 	_cairo_pattern_fini (&dev_source.base);
26419: 
26419:     return _cairo_surface_set_error (surface, status);
26419: }
26419: 
26419: cairo_status_t
26419: _cairo_surface_fill (cairo_surface_t	*surface,
26419: 		     cairo_operator_t	 op,
26419: 		     const cairo_pattern_t *source,
26419: 		     cairo_path_fixed_t	*path,
26419: 		     cairo_fill_rule_t	 fill_rule,
26419: 		     double		 tolerance,
26419: 		     cairo_antialias_t	 antialias,
26419: 		     cairo_rectangle_int_t *extents)
26419: {
26419:     cairo_status_t status;
26419:     cairo_pattern_union_t dev_source;
26419: 
26419:     if (surface->status)
26419: 	return surface->status;
26419: 
32473:     _cairo_surface_begin_modification (surface);
26419: 
26419:     status = _cairo_surface_copy_pattern_for_destination (&source,
26419: 							  surface,
26419: 							  &dev_source.base);
26419:     if (unlikely (status))
26419: 	return _cairo_surface_set_error (surface, status);
26419: 
26419:     if (surface->backend->fill) {
26419: 	status = surface->backend->fill (surface, op, source,
26419: 					 path, fill_rule,
26419: 					 tolerance, antialias, extents);
26419: 
    1: 	if (status != CAIRO_INT_STATUS_UNSUPPORTED)
    1:             goto FINISH;
    1:     }
    1: 
26419:     status = _cairo_surface_fallback_fill (surface, op, source,
26419:                                            path, fill_rule,
    1:                                            tolerance, antialias);
    1: 
    1:  FINISH:
26419:     if (source == &dev_source.base)
26419: 	_cairo_pattern_fini (&dev_source.base);
    1: 
 8452:     return _cairo_surface_set_error (surface, status);
    1: }
    1: 
    1: cairo_status_t
    1: _cairo_surface_composite_trapezoids (cairo_operator_t		op,
26419: 				     const cairo_pattern_t	*pattern,
    1: 				     cairo_surface_t		*dst,
    1: 				     cairo_antialias_t		antialias,
    1: 				     int			src_x,
    1: 				     int			src_y,
    1: 				     int			dst_x,
    1: 				     int			dst_y,
    1: 				     unsigned int		width,
    1: 				     unsigned int		height,
    1: 				     cairo_trapezoid_t		*traps,
    1: 				     int			num_traps)
    1: {
    1:     cairo_int_status_t status;
    1: 
32473:     if (dst->status)
32473: 	return dst->status;
32473: 
32473:     assert (_cairo_surface_is_writable (dst));
32473: 
    1:     /* These operators aren't interpreted the same way by the backends;
    1:      * they are implemented in terms of other operators in cairo-gstate.c
    1:      */
    1:     assert (op != CAIRO_OPERATOR_SOURCE && op != CAIRO_OPERATOR_CLEAR);
    1: 
    1:     if (dst->backend->composite_trapezoids) {
    1: 	status = dst->backend->composite_trapezoids (op,
    1: 						     pattern, dst,
    1: 						     antialias,
    1: 						     src_x, src_y,
    1:                                                      dst_x, dst_y,
    1: 						     width, height,
    1: 						     traps, num_traps);
    1: 	if (status != CAIRO_INT_STATUS_UNSUPPORTED)
 8452: 	    return _cairo_surface_set_error (dst, status);
    1:     }
    1: 
 8452:     return  _cairo_surface_set_error (dst,
 8452: 	    _cairo_surface_fallback_composite_trapezoids (op, pattern, dst,
    1: 							  antialias,
    1: 							  src_x, src_y,
    1: 							  dst_x, dst_y,
    1: 							  width, height,
 8452: 							  traps, num_traps));
    1: }
    1: 
26419: cairo_span_renderer_t *
26419: _cairo_surface_create_span_renderer (cairo_operator_t		op,
26419: 				     const cairo_pattern_t     	*pattern,
26419: 				     cairo_surface_t		*dst,
26419: 				     cairo_antialias_t	        antialias,
26419: 				     const cairo_composite_rectangles_t *rects)
26419: {
32473:     assert (dst->snapshot_of == NULL);
26419: 
26419:     if (dst->status)
26419: 	return _cairo_span_renderer_create_in_error (dst->status);
26419: 
26419:     if (dst->finished)
26419: 	return _cairo_span_renderer_create_in_error (CAIRO_STATUS_SURFACE_FINISHED);
26419: 
26419:     if (dst->backend->create_span_renderer) {
26419: 	return dst->backend->create_span_renderer (op,
26419: 						   pattern, dst,
26419: 						   antialias,
26419: 						   rects);
26419:     }
26419:     ASSERT_NOT_REACHED;
26419:     return _cairo_span_renderer_create_in_error (CAIRO_INT_STATUS_UNSUPPORTED);
26419: }
26419: 
26419: cairo_bool_t
26419: _cairo_surface_check_span_renderer   (cairo_operator_t		op,
26419: 				      const cairo_pattern_t     *pattern,
26419: 				      cairo_surface_t		*dst,
26419: 				      cairo_antialias_t	        antialias,
26419: 				      const cairo_composite_rectangles_t *rects)
26419: {
26419:     cairo_int_status_t status;
26419: 
32473:     assert (dst->snapshot_of == NULL);
26419: 
26419:     if (dst->status)
26419: 	return FALSE;
26419: 
26419:     if (dst->finished) {
26419: 	status = _cairo_surface_set_error (dst, CAIRO_STATUS_SURFACE_FINISHED);
26419: 	return FALSE;
26419:     }
26419: 
26419:     if (dst->backend->check_span_renderer) {
26419: 	return dst->backend->check_span_renderer (op,
26419: 						  pattern, dst,
26419: 						  antialias,
26419: 						  rects);
26419:     }
26419:     return FALSE;
26419: }
26419: 
 6154: /**
 6154:  * cairo_surface_copy_page:
11708:  * @surface: a #cairo_surface_t
 6154:  *
 6154:  * Emits the current page for backends that support multiple pages,
 6154:  * but doesn't clear it, so that the contents of the current page will
 6154:  * be retained for the next page.  Use cairo_surface_show_page() if you
 6154:  * want to get an empty page after the emission.
 6154:  *
18904:  * There is a convenience function for this that takes a #cairo_t,
18904:  * namely cairo_copy_page().
18904:  *
 6154:  * Since: 1.6
 6154:  */
11708: void
 6154: cairo_surface_copy_page (cairo_surface_t *surface)
    1: {
11886:     cairo_status_t status_ignored;
11886: 
    1:     if (surface->status)
11708: 	return;
    1: 
32473:     assert (surface->snapshot_of == NULL);
21379: 
11708:     if (surface->finished) {
11886: 	status_ignored = _cairo_surface_set_error (surface,
11886: 		                                 CAIRO_STATUS_SURFACE_FINISHED);
11708: 	return;
11708:     }
    1: 
 4133:     /* It's fine if some backends don't implement copy_page */
    1:     if (surface->backend->copy_page == NULL)
11708: 	return;
    1: 
11886:     status_ignored = _cairo_surface_set_error (surface,
 8452: 			                 surface->backend->copy_page (surface));
    1: }
 6154: slim_hidden_def (cairo_surface_copy_page);
 6154: 
 6154: /**
 6154:  * cairo_surface_show_page:
 6154:  * @surface: a #cairo_Surface_t
 6154:  *
 6154:  * Emits and clears the current page for backends that support multiple
 6154:  * pages.  Use cairo_surface_copy_page() if you don't want to clear the page.
 6154:  *
18904:  * There is a convenience function for this that takes a #cairo_t,
18904:  * namely cairo_show_page().
18904:  *
 6154:  * Since: 1.6
 6154:  **/
11708: void
 6154: cairo_surface_show_page (cairo_surface_t *surface)
    1: {
11886:     cairo_status_t status_ignored;
11886: 
    1:     if (surface->status)
11708: 	return;
    1: 
32473:     _cairo_surface_begin_modification (surface);
21379: 
11708:     if (surface->finished) {
11886: 	status_ignored = _cairo_surface_set_error (surface,
11886: 		                                 CAIRO_STATUS_SURFACE_FINISHED);
11708: 	return;
11708:     }
    1: 
 4133:     /* It's fine if some backends don't implement show_page */
    1:     if (surface->backend->show_page == NULL)
11708: 	return;
    1: 
11886:     status_ignored = _cairo_surface_set_error (surface,
 8452: 			                 surface->backend->show_page (surface));
    1: }
 6154: slim_hidden_def (cairo_surface_show_page);
    1: 
    1: /**
    1:  * _cairo_surface_get_current_clip_serial:
    1:  * @surface: the #cairo_surface_t to return the serial number for
    1:  *
21379:  * This space left intentionally blank.
21379:  *
11708:  * Returns: the serial number associated with the current
    1:  * clip in the surface.  All gstate functions must
    1:  * verify that the correct clip is set in the surface before
21379:  * invoking any surface drawing function.
    1:  */
    1: unsigned int
    1: _cairo_surface_get_current_clip_serial (cairo_surface_t *surface)
    1: {
    1:     return surface->current_clip_serial;
    1: }
    1: 
    1: /**
    1:  * _cairo_surface_allocate_clip_serial:
    1:  * @surface: the #cairo_surface_t to allocate a serial number from
    1:  *
    1:  * Each surface has a separate set of clipping serial numbers, and
    1:  * this function allocates one from the specified surface.  As zero is
    1:  * reserved for the special no-clipping case, this function will not
    1:  * return that except for an in-error surface, (ie. surface->status !=
16122:  * %CAIRO_STATUS_SUCCESS).
    1:  */
    1: unsigned int
    1: _cairo_surface_allocate_clip_serial (cairo_surface_t *surface)
    1: {
    1:     unsigned int    serial;
    1: 
    1:     if (surface->status)
    1: 	return 0;
    1: 
    1:     if ((serial = ++(surface->next_clip_serial)) == 0)
    1: 	serial = ++(surface->next_clip_serial);
    1:     return serial;
    1: }
    1: 
    1: /**
    1:  * _cairo_surface_reset_clip:
    1:  * @surface: the #cairo_surface_t to reset the clip on
    1:  *
    1:  * This function sets the clipping for the surface to
    1:  * None, which is to say that drawing is entirely
    1:  * unclipped.  It also sets the clip serial number
    1:  * to zero.
    1:  */
    1: cairo_status_t
    1: _cairo_surface_reset_clip (cairo_surface_t *surface)
    1: {
    1:     cairo_status_t  status;
    1: 
    1:     if (surface->status)
    1: 	return surface->status;
    1: 
    1:     if (surface->finished)
 8452: 	return _cairo_surface_set_error (surface,CAIRO_STATUS_SURFACE_FINISHED);
    1: 
    1:     surface->current_clip_serial = 0;
    1: 
    1:     if (surface->backend->intersect_clip_path) {
    1: 	status = surface->backend->intersect_clip_path (surface,
    1: 							NULL,
    1: 							CAIRO_FILL_RULE_WINDING,
    1: 							0,
    1: 							CAIRO_ANTIALIAS_DEFAULT);
26419: 	if (unlikely (status))
 8452: 	    return _cairo_surface_set_error (surface, status);
    1:     }
    1: 
    1:     if (surface->backend->set_clip_region != NULL) {
    1: 	status = surface->backend->set_clip_region (surface, NULL);
26419: 	if (unlikely (status))
 8452: 	    return _cairo_surface_set_error (surface, status);
    1:     }
    1: 
    1:     return CAIRO_STATUS_SUCCESS;
    1: }
    1: 
    1: /**
    1:  * _cairo_surface_set_clip_region:
    1:  * @surface: the #cairo_surface_t to reset the clip on
 4133:  * @region: the #cairo_region_t to use for clipping
    1:  * @serial: the clip serial number associated with the region
    1:  *
    1:  * This function sets the clipping for the surface to
    1:  * the specified region and sets the surface clipping
    1:  * serial number to the associated serial number.
    1:  */
    1: cairo_status_t
    1: _cairo_surface_set_clip_region (cairo_surface_t	    *surface,
 4133: 				cairo_region_t	    *region,
    1: 				unsigned int	     serial)
    1: {
    1:     cairo_status_t status;
    1:     
    1:     if (surface->status)
    1: 	return surface->status;
    1: 
32473:     if (surface->finished)
32473: 	return _cairo_surface_set_error (surface,CAIRO_STATUS_SURFACE_FINISHED);
32473: 
    1:     assert (surface->backend->set_clip_region != NULL);
    1: 
26419:     status = surface->backend->set_clip_region (surface, region);
26419:     if (unlikely (status))
26419: 	return _cairo_surface_set_error (surface, status);
26419: 
    1:     surface->current_clip_serial = serial;
    1: 
26419:     return CAIRO_STATUS_SUCCESS;
    1: }
    1: 
    1: cairo_int_status_t
    1: _cairo_surface_intersect_clip_path (cairo_surface_t    *surface,
    1: 				    cairo_path_fixed_t *path,
    1: 				    cairo_fill_rule_t   fill_rule,
    1: 				    double		tolerance,
    1: 				    cairo_antialias_t	antialias)
    1: {
    1:     cairo_path_fixed_t *dev_path = path;
    1:     cairo_status_t status;
    1: 
    1:     if (surface->status)
    1: 	return surface->status;
    1: 
    1:     if (surface->finished)
 8452: 	return _cairo_surface_set_error (surface,CAIRO_STATUS_SURFACE_FINISHED);
    1: 
    1:     assert (surface->backend->intersect_clip_path != NULL);
    1: 
    1:     status = surface->backend->intersect_clip_path (surface,
    1: 						    dev_path,
    1: 						    fill_rule,
    1: 						    tolerance,
    1: 						    antialias);
    1: 
 8452:     return _cairo_surface_set_error (surface, status);
    1: }
    1: 
    1: static cairo_status_t
    1: _cairo_surface_set_clip_path_recursive (cairo_surface_t *surface,
    1: 					cairo_clip_path_t *clip_path)
    1: {
    1:     cairo_status_t status;
    1: 
12588:     if (surface->status)
12588: 	return surface->status;
12588: 
    1:     if (clip_path == NULL)
    1: 	return CAIRO_STATUS_SUCCESS;
    1: 
    1:     status = _cairo_surface_set_clip_path_recursive (surface, clip_path->prev);
26419:     if (unlikely (status))
    1: 	return status;
    1: 
    1:     return _cairo_surface_intersect_clip_path (surface,
    1: 					       &clip_path->path,
    1: 					       clip_path->fill_rule,
    1: 					       clip_path->tolerance,
    1: 					       clip_path->antialias);
    1: }
    1: 
    1: /**
    1:  * _cairo_surface_set_clip_path:
    1:  * @surface: the #cairo_surface_t to set the clip on
    1:  * @clip_path: the clip path to set
    1:  * @serial: the clip serial number associated with the clip path
    1:  *
    1:  * Sets the given clipping path for the surface and assigns the
    1:  * clipping serial to the surface.
    1:  **/
    1: static cairo_status_t
    1: _cairo_surface_set_clip_path (cairo_surface_t	*surface,
    1: 			      cairo_clip_path_t	*clip_path,
    1: 			      unsigned int	serial)
    1: {
    1:     cairo_status_t status;
    1: 
    1:     if (surface->status)
    1: 	return surface->status;
    1: 
    1:     if (surface->finished)
 8452: 	return _cairo_surface_set_error (surface,CAIRO_STATUS_SURFACE_FINISHED);
    1: 
    1:     assert (surface->backend->intersect_clip_path != NULL);
    1: 
    1:     status = surface->backend->intersect_clip_path (surface,
    1: 						    NULL,
    1: 						    CAIRO_FILL_RULE_WINDING,
    1: 						    0,
    1: 						    CAIRO_ANTIALIAS_DEFAULT);
26419:     if (unlikely (status))
 8452: 	return _cairo_surface_set_error (surface, status);
    1: 
    1:     status = _cairo_surface_set_clip_path_recursive (surface, clip_path);
26419:     if (unlikely (status))
 8452: 	return _cairo_surface_set_error (surface, status);
    1: 
    1:     surface->current_clip_serial = serial;
    1: 
    1:     return CAIRO_STATUS_SUCCESS;
    1: }
    1: 
 8452: 
 8452: /**
 8452:  * _cairo_surface_set_empty_clip_path:
 8452:  * @surface: the #cairo_surface_t to set the clip on
 8452:  * @serial: the clip serial number associated with the clip path
 8452:  *
 8452:  * Create an empty clip path, one that represents the entire surface clipped
 8452:  * out, and assigns the given clipping serial to the surface.
 8452:  **/
 8452: static cairo_status_t
 8452: _cairo_surface_set_empty_clip_path (cairo_surface_t *surface,
 8452: 	                            unsigned int serial)
 8452: {
 8452:     cairo_path_fixed_t path;
 8452:     cairo_status_t status;
 8452: 
12588:     if (surface->status)
12588: 	return surface->status;
12588: 
 8452:     _cairo_path_fixed_init (&path);
 8452: 
 8452:     status = surface->backend->intersect_clip_path (surface,
 8452: 						    &path,
 8452: 						    CAIRO_FILL_RULE_WINDING,
 8452: 						    0,
 8452: 						    CAIRO_ANTIALIAS_DEFAULT);
 8452: 
 8452:     if (status == CAIRO_STATUS_SUCCESS)
 8452: 	surface->current_clip_serial = serial;
 8452: 
 8452:     _cairo_path_fixed_fini (&path);
 8452: 
 8452:     return _cairo_surface_set_error (surface, status);
 8452: }
 8452: 
32473: /**
32473:  * _cairo_surface_set_empty_clip_region:
32473:  * @surface: the #cairo_surface_t to set the clip on
32473:  * @serial: the clip serial number associated with the clip path
32473:  *
32473:  * Create an empty clip region, one that represents the entire surface clipped
32473:  * out, and assigns the given clipping serial to the surface.
32473:  **/
32473: static cairo_status_t
32473: _cairo_surface_set_empty_clip_region (cairo_surface_t *surface,
32473: 				      unsigned int     serial)
32473: {
32473:     cairo_region_t *region;
32473:     cairo_status_t  status;
32473: 
32473:     if (surface->status)
32473: 	return surface->status;
32473: 
32473:     region = cairo_region_create ();
32473:     status = region->status;
32473: 
32473:     if (status == CAIRO_STATUS_SUCCESS)
32473: 	status = _cairo_surface_set_clip_region (surface, region, serial);
32473: 
32473:     cairo_region_destroy (region);
32473: 
32473:     return _cairo_surface_set_error (surface, status);
32473: }
32473: 
13979: cairo_clip_t *
13979: _cairo_surface_get_clip (cairo_surface_t *surface)
13979: {
13979:     return surface->clip;
13979: }
13979: 
    1: cairo_status_t
    1: _cairo_surface_set_clip (cairo_surface_t *surface, cairo_clip_t *clip)
    1: {
    1:     unsigned int serial = 0;
    1: 
    1:     if (surface->status)
    1: 	return surface->status;
    1: 
    1:     if (surface->finished)
 8452: 	return _cairo_surface_set_error (surface,CAIRO_STATUS_SURFACE_FINISHED);
    1: 
    1:     if (clip) {
    1: 	serial = clip->serial;
    1: 	if (serial == 0)
    1: 	    clip = NULL;
    1:     }
    1: 
    1:     surface->clip = clip;
    1: 
    1:     if (serial == _cairo_surface_get_current_clip_serial (surface))
    1: 	return CAIRO_STATUS_SUCCESS;
    1: 
    1:     if (clip) {
 8452: 	if (clip->all_clipped) {
 8452: 	    if (surface->backend->intersect_clip_path != NULL)
 8452: 		return _cairo_surface_set_empty_clip_path (surface,
 8452: 						           clip->serial);
 8452: 
 8452: 	    if (surface->backend->set_clip_region != NULL)
32473: 		return _cairo_surface_set_empty_clip_region (surface,
 8452: 							     clip->serial);
 8452: 	} else {
    1: 	    if (clip->path)
    1: 		return _cairo_surface_set_clip_path (surface,
    1: 						     clip->path,
    1: 						     clip->serial);
    1: 
28364: 	    if (clip->region)
    1: 		return _cairo_surface_set_clip_region (surface,
28364: 						       clip->region,
    1: 						       clip->serial);
    1: 	}
 8452:     }
    1: 
    1:     return _cairo_surface_reset_clip (surface);
    1: }
    1: 
    1: /**
    1:  * _cairo_surface_get_extents:
    1:  * @surface: the #cairo_surface_t to fetch extents for
    1:  *
    1:  * This function returns a bounding box for the surface.  The surface
    1:  * bounds are defined as a region beyond which no rendering will
    1:  * possibly be recorded, in other words, it is the maximum extent of
    1:  * potentially usable coordinates.
    1:  *
    1:  * For vector surfaces, (PDF, PS, SVG and meta-surfaces), the surface
    1:  * might be conceived as unbounded, but we force the user to provide a
    1:  * maximum size at the time of surface_create. So get_extents uses
    1:  * that size.
    1:  *
11708:  * Note: The coordinates returned are in "backend" space rather than
    1:  * "surface" space. That is, they are relative to the true (0,0)
    1:  * origin rather than the device_transform origin. This might seem a
11708:  * bit inconsistent with other #cairo_surface_t interfaces, but all
    1:  * current callers are within the surface layer where backend space is
    1:  * desired.
    1:  *
    1:  * This behavior would have to be changed is we ever exported a public
    1:  * variant of this function.
    1:  */
16122: cairo_int_status_t
    1: _cairo_surface_get_extents (cairo_surface_t         *surface,
16122: 			    cairo_rectangle_int_t   *extents)
    1: {
16122:     cairo_int_status_t status = CAIRO_INT_STATUS_UNSUPPORTED;
16122: 
    1:     if (surface->status)
    1: 	return surface->status;
    1: 
    1:     if (surface->finished)
 8452: 	return _cairo_surface_set_error (surface,CAIRO_STATUS_SURFACE_FINISHED);
    1: 
16122:     if (surface->backend->get_extents) {
16122: 	status = _cairo_surface_set_error (surface,
16122: 					   surface->backend->get_extents (surface, extents));
16122:     }
16122: 
16122:     if (status == CAIRO_INT_STATUS_UNSUPPORTED) {
16122: 	extents->x      = CAIRO_RECT_INT_MIN;
16122: 	extents->y      = CAIRO_RECT_INT_MIN;
16122: 	extents->width  = CAIRO_RECT_INT_MAX - CAIRO_RECT_INT_MIN;
16122: 	extents->height = CAIRO_RECT_INT_MAX - CAIRO_RECT_INT_MIN;
16122:     }
16122: 
16122:     return status;
16122: }
16122: 
18904: /**
18904:  * cairo_surface_has_show_text_glyphs:
18904:  * @surface: a #cairo_surface_t
18904:  *
18904:  * Returns whether the surface supports
18904:  * sophisticated cairo_show_text_glyphs() operations.  That is,
18904:  * whether it actually uses the provided text and cluster data
18904:  * to a cairo_show_text_glyphs() call.
18904:  *
18904:  * Note: Even if this function returns %FALSE, a
18904:  * cairo_show_text_glyphs() operation targeted at @surface will
18904:  * still succeed.  It just will
18904:  * act like a cairo_show_glyphs() operation.  Users can use this
18904:  * function to avoid computing UTF-8 text and cluster mapping if the
18904:  * target surface does not use it.
18904:  *
18904:  * Return value: %TRUE if @surface supports
18904:  *               cairo_show_text_glyphs(), %FALSE otherwise
18904:  *
18904:  * Since: 1.8
18904:  **/
16122: cairo_bool_t
18904: cairo_surface_has_show_text_glyphs (cairo_surface_t	    *surface)
16122: {
18904:     cairo_status_t status_ignored;
18904: 
18904:     if (surface->status)
18904: 	return FALSE;
18904: 
18904:     if (surface->finished) {
18904: 	status_ignored = _cairo_surface_set_error (surface,
18904: 						   CAIRO_STATUS_SURFACE_FINISHED);
18904: 	return FALSE;
18904:     }
18904: 
16122:     if (surface->backend->has_show_text_glyphs)
16122: 	return surface->backend->has_show_text_glyphs (surface);
16122:     else
16122: 	return surface->backend->show_text_glyphs != NULL;
    1: }
18904: slim_hidden_def (cairo_surface_has_show_text_glyphs);
    1: 
 6154: /* Note: the backends may modify the contents of the glyph array as long as
16122:  * they do not return %CAIRO_INT_STATUS_UNSUPPORTED. This makes it possible to
 6154:  * avoid copying the array again and again, and edit it in-place.
 6154:  * Backends are in fact free to use the array as a generic buffer as they
 6154:  * see fit.
16122:  *
16122:  * For show_glyphs backend method, and NOT for show_text_glyphs method,
16122:  * when they do return UNSUPPORTED, they may adjust remaining_glyphs to notify
16122:  * that they have successfully rendered some of the glyphs (from the beginning
16122:  * of the array), but not all.  If they don't touch remaining_glyphs, it
16122:  * defaults to all glyphs.
16122:  *
 6154:  * See commits 5a9642c5746fd677aed35ce620ce90b1029b1a0c and
 6154:  * 1781e6018c17909311295a9cc74b70500c6b4d0a for the rationale.
 6154:  */
    1: cairo_status_t
16122: _cairo_surface_show_text_glyphs (cairo_surface_t	    *surface,
    1: 				 cairo_operator_t	     op,
26419: 				 const cairo_pattern_t	    *source,
16122: 				 const char		    *utf8,
16122: 				 int			     utf8_len,
    1: 				 cairo_glyph_t		    *glyphs,
    1: 				 int			     num_glyphs,
16122: 				 const cairo_text_cluster_t *clusters,
16122: 				 int			     num_clusters,
21379: 				 cairo_text_cluster_flags_t  cluster_flags,
26419: 				 cairo_scaled_font_t	    *scaled_font,
26419: 				 cairo_rectangle_int_t      *extents)
    1: {
    1:     cairo_status_t status;
    1:     cairo_scaled_font_t *dev_scaled_font = scaled_font;
26419:     cairo_pattern_union_t dev_source;
    1: 
12588:     if (surface->status)
12588: 	return surface->status;
12588: 
32473:     if (num_glyphs == 0 && utf8_len == 0)
    1: 	return CAIRO_STATUS_SUCCESS;
    1: 
32473:     _cairo_surface_begin_modification (surface);
32473: 
26419:     status = _cairo_surface_copy_pattern_for_destination (&source,
    1: 						          surface,
26419: 							  &dev_source.base);
26419:     if (unlikely (status))
 8452: 	return _cairo_surface_set_error (surface, status);
    1: 
    1:     if (_cairo_surface_has_device_transform (surface) &&
    1: 	! _cairo_matrix_is_integer_translation (&surface->device_transform, NULL, NULL))
    1:     {
16122: 	cairo_font_options_t font_options;
16122: 	cairo_matrix_t dev_ctm, font_matrix;
    1: 
16122: 	cairo_scaled_font_get_font_matrix (scaled_font, &font_matrix);
    1: 	cairo_scaled_font_get_ctm (scaled_font, &dev_ctm);
    1: 	cairo_matrix_multiply (&dev_ctm, &dev_ctm, &surface->device_transform);
16122: 	cairo_scaled_font_get_font_options (scaled_font, &font_options);
    1: 	dev_scaled_font = cairo_scaled_font_create (cairo_scaled_font_get_font_face (scaled_font),
    1: 						    &font_matrix,
    1: 						    &dev_ctm,
16122: 						    &font_options);
    1:     }
 4133:     status = cairo_scaled_font_status (dev_scaled_font);
26419:     if (unlikely (status)) {
26419: 	if (source == &dev_source.base)
26419: 	    _cairo_pattern_fini (&dev_source.base);
26419: 
 8452: 	return _cairo_surface_set_error (surface, status);
 4133:     }
    1: 
  314:     status = CAIRO_INT_STATUS_UNSUPPORTED;
  314: 
16122:     /* The logic here is duplicated in _cairo_analysis_surface show_glyphs and
16122:      * show_text_glyphs.  Keep in synch. */
16122:     if (clusters) {
16122: 	/* A real show_text_glyphs call.  Try show_text_glyphs backend
16122: 	 * method first */
16122: 	if (surface->backend->show_text_glyphs) {
26419: 	    status = surface->backend->show_text_glyphs (surface, op,
26419: 							 source,
16122: 							 utf8, utf8_len,
16122: 							 glyphs, num_glyphs,
21379: 							 clusters, num_clusters, cluster_flags,
26419: 							 dev_scaled_font, extents);
16122: 	}
16122: 	if (status == CAIRO_INT_STATUS_UNSUPPORTED && surface->backend->show_glyphs) {
16122: 	    int remaining_glyphs = num_glyphs;
26419: 	    status = surface->backend->show_glyphs (surface, op,
26419: 						    source,
    1: 						    glyphs, num_glyphs,
16122: 						    dev_scaled_font,
26419: 						    &remaining_glyphs, extents);
16122: 	    glyphs += num_glyphs - remaining_glyphs;
16122: 	    num_glyphs = remaining_glyphs;
16122: 	    if (status == CAIRO_INT_STATUS_UNSUPPORTED && remaining_glyphs == 0)
16122: 		status = CAIRO_STATUS_SUCCESS;
16122: 	}
16122:     } else {
16122: 	/* A mere show_glyphs call.  Try show_glyphs backend method first */
16122: 	if (surface->backend->show_glyphs) {
16122: 	    int remaining_glyphs = num_glyphs;
26419: 	    status = surface->backend->show_glyphs (surface, op,
26419: 						    source,
16122: 						    glyphs, num_glyphs,
16122: 						    dev_scaled_font,
26419: 						    &remaining_glyphs, extents);
16122: 	    glyphs += num_glyphs - remaining_glyphs;
16122: 	    num_glyphs = remaining_glyphs;
16122: 	    if (status == CAIRO_INT_STATUS_UNSUPPORTED && remaining_glyphs == 0)
16122: 		status = CAIRO_STATUS_SUCCESS;
16122: 	} else if (surface->backend->show_text_glyphs) {
16122: 	    /* Intentionally only try show_text_glyphs method for show_glyphs
16122: 	     * calls if backend does not have show_glyphs.  If backend has
16122: 	     * both methods implemented, we don't fallback from show_glyphs to
16122: 	     * show_text_glyphs, and hence the backend can assume in its
16122: 	     * show_text_glyphs call that clusters is not NULL (which also
16122: 	     * implies that UTF-8 is not NULL, unless the text is
16122: 	     * zero-length).
16122: 	     */
26419: 	    status = surface->backend->show_text_glyphs (surface, op,
26419: 							 source,
16122: 							 utf8, utf8_len,
16122: 							 glyphs, num_glyphs,
21379: 							 clusters, num_clusters, cluster_flags,
26419: 							 dev_scaled_font, extents);
16122: 	}
16122:     }
    1: 
  314:     if (status == CAIRO_INT_STATUS_UNSUPPORTED)
26419: 	status = _cairo_surface_fallback_show_glyphs (surface, op,
26419: 						      source,
    1: 						      glyphs, num_glyphs,
    1: 						      dev_scaled_font);
    1: 
    1:     if (dev_scaled_font != scaled_font)
    1: 	cairo_scaled_font_destroy (dev_scaled_font);
    1: 
26419:     if (source == &dev_source.base)
26419: 	_cairo_pattern_fini (&dev_source.base);
    1: 
 8452:     return _cairo_surface_set_error (surface, status);
    1: }
    1: 
    1: /* XXX: Previously, we had a function named _cairo_surface_show_glyphs
16122:  * with not-so-useful semantics. We've now got a
16122:  * _cairo_surface_show_text_glyphs with the proper semantics, and its
    1:  * fallback still uses this old function (which still needs to be
    1:  * cleaned up in terms of both semantics and naming). */
    1: cairo_status_t
    1: _cairo_surface_old_show_glyphs (cairo_scaled_font_t	*scaled_font,
    1: 				cairo_operator_t	 op,
26419: 				const cairo_pattern_t	*pattern,
    1: 				cairo_surface_t		*dst,
    1: 				int			 source_x,
    1: 				int			 source_y,
    1: 				int			 dest_x,
    1: 				int			 dest_y,
    1: 				unsigned int		 width,
    1: 				unsigned int		 height,
    1: 				cairo_glyph_t		*glyphs,
    1: 				int			 num_glyphs)
    1: {
    1:     cairo_status_t status;
    1: 
    1:     if (dst->status)
    1: 	return dst->status;
    1: 
32473:     assert (_cairo_surface_is_writable (dst));
    1: 
    1:     if (dst->backend->old_show_glyphs) {
    1: 	status = dst->backend->old_show_glyphs (scaled_font,
    1: 						op, pattern, dst,
    1: 						source_x, source_y,
    1:                                                 dest_x, dest_y,
    1: 						width, height,
    1: 						glyphs, num_glyphs);
    1:     } else
    1: 	status = CAIRO_INT_STATUS_UNSUPPORTED;
    1: 
 8452:     return _cairo_surface_set_error (dst, status);
    1: }
    1: 
    1: static cairo_status_t
    1: _cairo_surface_composite_fixup_unbounded_internal (cairo_surface_t         *dst,
 4133: 						   cairo_rectangle_int_t   *src_rectangle,
 4133: 						   cairo_rectangle_int_t   *mask_rectangle,
    1: 						   int			    dst_x,
    1: 						   int			    dst_y,
    1: 						   unsigned int		    width,
    1: 						   unsigned int		    height)
    1: {
 4133:     cairo_rectangle_int_t dst_rectangle;
32473:     cairo_region_t clear_region;
 4133:     cairo_status_t status;
    1: 
28364:     /* The area that was drawn is the area in the destination rectangle but
28364:      * not within the source or the mask.
    1:      */
    1:     dst_rectangle.x = dst_x;
    1:     dst_rectangle.y = dst_y;
    1:     dst_rectangle.width = width;
    1:     dst_rectangle.height = height;
28364: 
32473:     _cairo_region_init_rectangle (&clear_region, &dst_rectangle);
    1: 
26419:     if (src_rectangle) {
28364:         if (! _cairo_rectangle_intersect (&dst_rectangle, src_rectangle))
26419: 	    goto EMPTY;
26419:     }
26419: 
26419:     if (mask_rectangle) {
28364:         if (! _cairo_rectangle_intersect (&dst_rectangle, mask_rectangle))
26419: 	    goto EMPTY;
26419:     }
    1: 
28364:     /* Now compute the area that is in dst but not drawn */
32473:     status = cairo_region_subtract_rectangle (&clear_region, &dst_rectangle);
26419:     if (unlikely (status))
    1:         goto CLEANUP_REGIONS;
    1: 
26419:   EMPTY:
    1:     status = _cairo_surface_fill_region (dst, CAIRO_OPERATOR_SOURCE,
    1:                                          CAIRO_COLOR_TRANSPARENT,
32473:                                          &clear_region);
    1: 
    1:   CLEANUP_REGIONS:
32473:     _cairo_region_fini (&clear_region);
    1: 
 8452:     return _cairo_surface_set_error (dst, status);
    1: }
    1: 
    1: /**
    1:  * _cairo_surface_composite_fixup_unbounded:
    1:  * @dst: the destination surface
    1:  * @src_attr: source surface attributes (from _cairo_pattern_acquire_surface())
    1:  * @src_width: width of source surface
    1:  * @src_height: height of source surface
    1:  * @mask_attr: mask surface attributes or %NULL if no mask
    1:  * @mask_width: width of mask surface
    1:  * @mask_height: height of mask surface
    1:  * @src_x: @src_x from _cairo_surface_composite()
    1:  * @src_y: @src_y from _cairo_surface_composite()
    1:  * @mask_x: @mask_x from _cairo_surface_composite()
    1:  * @mask_y: @mask_y from _cairo_surface_composite()
    1:  * @dst_x: @dst_x from _cairo_surface_composite()
    1:  * @dst_y: @dst_y from _cairo_surface_composite()
    1:  * @width: @width from _cairo_surface_composite()
    1:  * @height: @height_x from _cairo_surface_composite()
    1:  *
    1:  * Eeek! Too many parameters! This is a helper function to take care of fixing
    1:  * up for bugs in libpixman and RENDER where, when asked to composite an
    1:  * untransformed surface with an unbounded operator (like CLEAR or SOURCE)
    1:  * only the region inside both the source and the mask is affected.
    1:  * This function clears the region that should have been drawn but was wasn't.
    1:  **/
    1: cairo_status_t
    1: _cairo_surface_composite_fixup_unbounded (cairo_surface_t            *dst,
    1: 					  cairo_surface_attributes_t *src_attr,
    1: 					  int                         src_width,
    1: 					  int                         src_height,
    1: 					  cairo_surface_attributes_t *mask_attr,
    1: 					  int                         mask_width,
    1: 					  int                         mask_height,
    1: 					  int			      src_x,
    1: 					  int			      src_y,
    1: 					  int			      mask_x,
    1: 					  int			      mask_y,
    1: 					  int			      dst_x,
    1: 					  int			      dst_y,
    1: 					  unsigned int		      width,
    1: 					  unsigned int		      height)
    1: {
 4133:     cairo_rectangle_int_t src_tmp, mask_tmp;
 4133:     cairo_rectangle_int_t *src_rectangle = NULL;
 4133:     cairo_rectangle_int_t *mask_rectangle = NULL;
    1: 
12588:     if (dst->status)
12588: 	return dst->status;
12588: 
32473:     assert (_cairo_surface_is_writable (dst));
21379: 
    1:     /* The RENDER/libpixman operators are clipped to the bounds of the untransformed,
    1:      * non-repeating sources and masks. Other sources and masks can be ignored.
    1:      */
    1:     if (_cairo_matrix_is_integer_translation (&src_attr->matrix, NULL, NULL) &&
    1: 	src_attr->extend == CAIRO_EXTEND_NONE)
    1:     {
    1: 	src_tmp.x = (dst_x - (src_x + src_attr->x_offset));
    1: 	src_tmp.y = (dst_y - (src_y + src_attr->y_offset));
    1: 	src_tmp.width = src_width;
    1: 	src_tmp.height = src_height;
    1: 
    1: 	src_rectangle = &src_tmp;
    1:     }
    1: 
    1:     if (mask_attr &&
    1: 	_cairo_matrix_is_integer_translation (&mask_attr->matrix, NULL, NULL) &&
    1: 	mask_attr->extend == CAIRO_EXTEND_NONE)
    1:     {
    1: 	mask_tmp.x = (dst_x - (mask_x + mask_attr->x_offset));
    1: 	mask_tmp.y = (dst_y - (mask_y + mask_attr->y_offset));
    1: 	mask_tmp.width = mask_width;
    1: 	mask_tmp.height = mask_height;
    1: 
    1: 	mask_rectangle = &mask_tmp;
    1:     }
    1: 
    1:     return _cairo_surface_composite_fixup_unbounded_internal (dst, src_rectangle, mask_rectangle,
    1: 							      dst_x, dst_y, width, height);
    1: }
    1: 
    1: /**
    1:  * _cairo_surface_composite_shape_fixup_unbounded:
    1:  * @dst: the destination surface
    1:  * @src_attr: source surface attributes (from _cairo_pattern_acquire_surface())
    1:  * @src_width: width of source surface
    1:  * @src_height: height of source surface
    1:  * @mask_width: width of mask surface
    1:  * @mask_height: height of mask surface
    1:  * @src_x: @src_x from _cairo_surface_composite()
    1:  * @src_y: @src_y from _cairo_surface_composite()
    1:  * @mask_x: @mask_x from _cairo_surface_composite()
    1:  * @mask_y: @mask_y from _cairo_surface_composite()
    1:  * @dst_x: @dst_x from _cairo_surface_composite()
    1:  * @dst_y: @dst_y from _cairo_surface_composite()
    1:  * @width: @width from _cairo_surface_composite()
    1:  * @height: @height_x from _cairo_surface_composite()
    1:  *
    1:  * Like _cairo_surface_composite_fixup_unbounded(), but instead of
    1:  * handling the case where we have a source pattern and a mask
    1:  * pattern, handle the case where we are compositing a source pattern
    1:  * using a mask we create ourselves, as in
    1:  * _cairo_surface_composite_glyphs() or _cairo_surface_composite_trapezoids()
    1:  **/
    1: cairo_status_t
    1: _cairo_surface_composite_shape_fixup_unbounded (cairo_surface_t            *dst,
    1: 						cairo_surface_attributes_t *src_attr,
    1: 						int                         src_width,
    1: 						int                         src_height,
    1: 						int                         mask_width,
    1: 						int                         mask_height,
    1: 						int			    src_x,
    1: 						int			    src_y,
    1: 						int			    mask_x,
    1: 						int			    mask_y,
    1: 						int			    dst_x,
    1: 						int			    dst_y,
    1: 						unsigned int		    width,
    1: 						unsigned int		    height)
    1: {
 4133:     cairo_rectangle_int_t src_tmp, mask_tmp;
 4133:     cairo_rectangle_int_t *src_rectangle = NULL;
 4133:     cairo_rectangle_int_t *mask_rectangle = NULL;
    1: 
12588:     if (dst->status)
12588: 	return dst->status;
12588: 
32473:     assert (_cairo_surface_is_writable (dst));
21379: 
    1:     /* The RENDER/libpixman operators are clipped to the bounds of the untransformed,
    1:      * non-repeating sources and masks. Other sources and masks can be ignored.
    1:      */
    1:     if (_cairo_matrix_is_integer_translation (&src_attr->matrix, NULL, NULL) &&
    1: 	src_attr->extend == CAIRO_EXTEND_NONE)
    1:     {
    1: 	src_tmp.x = (dst_x - (src_x + src_attr->x_offset));
    1: 	src_tmp.y = (dst_y - (src_y + src_attr->y_offset));
    1: 	src_tmp.width = src_width;
    1: 	src_tmp.height = src_height;
    1: 
    1: 	src_rectangle = &src_tmp;
    1:     }
    1: 
    1:     mask_tmp.x = dst_x - mask_x;
    1:     mask_tmp.y = dst_y - mask_y;
    1:     mask_tmp.width = mask_width;
    1:     mask_tmp.height = mask_height;
    1: 
    1:     mask_rectangle = &mask_tmp;
    1: 
    1:     return _cairo_surface_composite_fixup_unbounded_internal (dst, src_rectangle, mask_rectangle,
    1: 							      dst_x, dst_y, width, height);
    1: }
    1: 
    1: /**
    1:  * _cairo_surface_copy_pattern_for_destination
    1:  * @pattern: the pattern to copy
    1:  * @destination: the destination surface for which the pattern is being copied
26419:  * @pattern_copy: the location to hold the copy
    1:  *
    1:  * Copies the given pattern, taking into account device scale and offsets
    1:  * of the destination surface.
    1:  */
 4133: static cairo_status_t
26419: _cairo_surface_copy_pattern_for_destination (const cairo_pattern_t **pattern,
    1:                                              cairo_surface_t *destination,
26419:                                              cairo_pattern_t *pattern_copy)
    1: {
 4133:     cairo_status_t status;
 4133: 
26419:     if (! _cairo_surface_has_device_transform (destination))
26419: 	return CAIRO_STATUS_SUCCESS;
26419: 
26419:     status = _cairo_pattern_init_copy (pattern_copy, *pattern);
26419:     if (unlikely (status))
 4133: 	return status;
    1: 
26419:     _cairo_pattern_transform (pattern_copy,
18904: 			      &destination->device_transform_inverse);
26419: 
26419: 
26419:     *pattern = pattern_copy;
 4133:     return CAIRO_STATUS_SUCCESS;
    1: }
    1: 
 6154: /**
 6154:  * _cairo_surface_set_resolution
 6154:  * @surface: the surface
 6154:  * @x_res: x resolution, in dpi
 6154:  * @y_res: y resolution, in dpi
 6154:  *
 6154:  * Set the actual surface resolution of @surface to the given x and y DPI.
 6154:  * Mainly used for correctly computing the scale factor when fallback
 6154:  * rendering needs to take place in the paginated surface.
 6154:  */
 6154: void
 6154: _cairo_surface_set_resolution (cairo_surface_t *surface,
 6154: 			       double x_res,
 6154: 			       double y_res)
 6154: {
12588:     if (surface->status)
12588: 	return;
12588: 
 6154:     surface->x_resolution = x_res;
 6154:     surface->y_resolution = y_res;
 6154: }
 6154: 
10694: cairo_surface_t *
10694: _cairo_surface_create_in_error (cairo_status_t status)
10694: {
10694:     switch (status) {
10694:     case CAIRO_STATUS_NO_MEMORY:
10694: 	return (cairo_surface_t *) &_cairo_surface_nil;
32473:     case CAIRO_STATUS_SURFACE_TYPE_MISMATCH:
32473: 	return (cairo_surface_t *) &_cairo_surface_nil_surface_type_mismatch;
10694:     case CAIRO_STATUS_INVALID_CONTENT:
10694: 	return (cairo_surface_t *) &_cairo_surface_nil_invalid_content;
10694:     case CAIRO_STATUS_INVALID_FORMAT:
10694: 	return (cairo_surface_t *) &_cairo_surface_nil_invalid_format;
10694:     case CAIRO_STATUS_INVALID_VISUAL:
10694: 	return (cairo_surface_t *) &_cairo_surface_nil_invalid_visual;
10694:     case CAIRO_STATUS_READ_ERROR:
10694: 	return (cairo_surface_t *) &_cairo_surface_nil_read_error;
10694:     case CAIRO_STATUS_WRITE_ERROR:
10694: 	return (cairo_surface_t *) &_cairo_surface_nil_write_error;
10694:     case CAIRO_STATUS_FILE_NOT_FOUND:
10694: 	return (cairo_surface_t *) &_cairo_surface_nil_file_not_found;
10694:     case CAIRO_STATUS_TEMP_FILE_ERROR:
10694: 	return (cairo_surface_t *) &_cairo_surface_nil_temp_file_error;
11708:     case CAIRO_STATUS_INVALID_STRIDE:
11708: 	return (cairo_surface_t *) &_cairo_surface_nil_invalid_stride;
29608:     case CAIRO_STATUS_INVALID_SIZE:
29608: 	return (cairo_surface_t *) &_cairo_surface_nil_invalid_size;
13979:     case CAIRO_STATUS_SUCCESS:
28364:     case CAIRO_STATUS_LAST_STATUS:
13979: 	ASSERT_NOT_REACHED;
13979: 	/* fall-through */
13979:     case CAIRO_STATUS_INVALID_RESTORE:
13979:     case CAIRO_STATUS_INVALID_POP_GROUP:
13979:     case CAIRO_STATUS_NO_CURRENT_POINT:
13979:     case CAIRO_STATUS_INVALID_MATRIX:
13979:     case CAIRO_STATUS_INVALID_STATUS:
13979:     case CAIRO_STATUS_NULL_POINTER:
13979:     case CAIRO_STATUS_INVALID_STRING:
13979:     case CAIRO_STATUS_INVALID_PATH_DATA:
13979:     case CAIRO_STATUS_SURFACE_FINISHED:
13979:     case CAIRO_STATUS_PATTERN_TYPE_MISMATCH:
13979:     case CAIRO_STATUS_INVALID_DASH:
13979:     case CAIRO_STATUS_INVALID_DSC_COMMENT:
13979:     case CAIRO_STATUS_INVALID_INDEX:
13979:     case CAIRO_STATUS_CLIP_NOT_REPRESENTABLE:
16122:     case CAIRO_STATUS_FONT_TYPE_MISMATCH:
16122:     case CAIRO_STATUS_USER_FONT_IMMUTABLE:
16122:     case CAIRO_STATUS_USER_FONT_ERROR:
16122:     case CAIRO_STATUS_NEGATIVE_COUNT:
16122:     case CAIRO_STATUS_INVALID_CLUSTERS:
18904:     case CAIRO_STATUS_INVALID_SLANT:
18904:     case CAIRO_STATUS_INVALID_WEIGHT:
29608:     case CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED:
10694:     default:
10694: 	_cairo_error_throw (CAIRO_STATUS_NO_MEMORY);
10694: 	return (cairo_surface_t *) &_cairo_surface_nil;
10694:     }
10694: }
10694: 
    1: /*  LocalWords:  rasterized
    1:  */
