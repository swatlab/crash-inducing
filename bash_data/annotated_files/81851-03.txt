    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
41423:  *   Mats Palmgren <matspal@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* rendering object to wrap rendering objects that should be scrollable */
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsPresContext.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIView.h"
    1: #include "nsIScrollable.h"
    1: #include "nsIViewManager.h"
    1: #include "nsHTMLContainerFrame.h"
    1: #include "nsGfxScrollFrame.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIDocument.h"
68493: #include "nsFontMetrics.h"
    1: #include "nsIDocumentObserver.h"
    1: #include "nsIDocument.h"
    1: #include "nsBoxLayoutState.h"
    1: #include "nsINodeInfo.h"
73635: #include "nsScrollbarFrame.h"
    1: #include "nsIScrollbarMediator.h"
    1: #include "nsITextControlFrame.h"
    1: #include "nsIDOMHTMLTextAreaElement.h"
    1: #include "nsNodeInfoManager.h"
    1: #include "nsIURI.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsContentCreatorFunctions.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsPresState.h"
    1: #include "nsDocShellCID.h"
11877: #include "nsIHTMLDocument.h"
    1: #include "nsEventDispatcher.h"
    1: #include "nsContentUtils.h"
    1: #include "nsLayoutUtils.h"
    1: #ifdef ACCESSIBILITY
61464: #include "nsAccessibilityService.h"
    1: #endif
    1: #include "nsBidiUtils.h"
33373: #include "nsFrameManager.h"
71641: #include "mozilla/Preferences.h"
78130: #include "mozilla/LookAndFeel.h"
41930: #include "mozilla/dom/Element.h"
62289: #include "FrameLayerBuilder.h"
63967: #include "nsSMILKeySpline.h"
62289: 
62289: using namespace mozilla;
41634: using namespace mozilla::dom;
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: //----------nsHTMLScrollFrame-------------------------------------------
    1: 
    1: nsIFrame*
79445: NS_NewHTMLScrollFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, bool aIsRoot)
    1: {
    1:   return new (aPresShell) nsHTMLScrollFrame(aPresShell, aContext, aIsRoot);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsHTMLScrollFrame)
32423: 
79445: nsHTMLScrollFrame::nsHTMLScrollFrame(nsIPresShell* aShell, nsStyleContext* aContext, bool aIsRoot)
    1:   : nsHTMLContainerFrame(aContext),
62087:     mInner(this, aIsRoot)
    1: {
    1: }
    1: 
    1: nsresult
69438: nsHTMLScrollFrame::CreateAnonymousContent(nsTArray<ContentInfo>& aElements)
    1: {
    1:   return mInner.CreateAnonymousContent(aElements);
    1: }
    1: 
    1: void
55877: nsHTMLScrollFrame::AppendAnonymousContentTo(nsBaseContentList& aElements,
55877:                                             PRUint32 aFilter)
38069: {
55877:   mInner.AppendAnonymousContentTo(aElements, aFilter);
38069: }
38069: 
38069: void
36647: nsHTMLScrollFrame::DestroyFrom(nsIFrame* aDestructRoot)
    1: {
    1:   mInner.Destroy();
79488:   DestroyAbsoluteFrames(aDestructRoot);
36647:   nsHTMLContainerFrame::DestroyFrom(aDestructRoot);
    1: }
    1: 
    1: NS_IMETHODIMP
77154: nsHTMLScrollFrame::SetInitialChildList(ChildListID  aListID,
30790:                                        nsFrameList& aChildList)
    1: {
77154:   nsresult rv = nsHTMLContainerFrame::SetInitialChildList(aListID, aChildList);
    1:   mInner.ReloadChildFrames();
    1:   return rv;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
77154: nsHTMLScrollFrame::AppendFrames(ChildListID  aListID,
30941:                                 nsFrameList& aFrameList)
    1: {
77154:   NS_ASSERTION(aListID == kPrincipalList, "Only main list supported");
    1:   mFrames.AppendFrames(nsnull, aFrameList);
    1:   mInner.ReloadChildFrames();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
77154: nsHTMLScrollFrame::InsertFrames(ChildListID aListID,
    1:                                 nsIFrame* aPrevFrame,
30941:                                 nsFrameList& aFrameList)
    1: {
77154:   NS_ASSERTION(aListID == kPrincipalList, "Only main list supported");
    1:   NS_ASSERTION(!aPrevFrame || aPrevFrame->GetParent() == this,
    1:                "inserting after sibling frame with different parent");
    1:   mFrames.InsertFrames(nsnull, aPrevFrame, aFrameList);
    1:   mInner.ReloadChildFrames();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
77154: nsHTMLScrollFrame::RemoveFrame(ChildListID aListID,
    1:                                nsIFrame* aOldFrame)
    1: {
77154:   NS_ASSERTION(aListID == kPrincipalList, "Only main list supported");
 8156:   mFrames.DestroyFrame(aOldFrame);
    1:   mInner.ReloadChildFrames();
    1:   return NS_OK;
    1: }
    1: 
    1: nsSplittableType
    1: nsHTMLScrollFrame::GetSplittableType() const
    1: {
    1:   return NS_FRAME_NOT_SPLITTABLE;
    1: }
    1: 
    1: PRIntn
    1: nsHTMLScrollFrame::GetSkipSides() const
    1: {
    1:   return 0;
    1: }
    1: 
    1: nsIAtom*
    1: nsHTMLScrollFrame::GetType() const
    1: {
    1:   return nsGkAtoms::scrollFrame; 
    1: }
    1: 
15910: void
15910: nsHTMLScrollFrame::InvalidateInternal(const nsRect& aDamageRect,
15910:                                       nscoord aX, nscoord aY, nsIFrame* aForChild,
19380:                                       PRUint32 aFlags)
15910: {
30690:   if (aForChild) {
30507:     if (aForChild == mInner.mScrolledFrame) {
19380:       nsRect damage = aDamageRect + nsPoint(aX, aY);
59496:       // This is the damage rect that we're going to pass up to our parent.
59496:       nsRect parentDamage;
63392:       // If we're using a displayport, we might be displaying an area
63392:       // different than our scroll port and the damage needs to be
63392:       // clipped to that instead.
63414:       nsRect displayport;
79445:       bool usingDisplayport = nsLayoutUtils::GetDisplayPort(GetContent(),
63414:                                                               &displayport);
63414:       if (usingDisplayport) {
63414:         parentDamage.IntersectRect(damage, displayport);
63392:       } else {
59496:         parentDamage.IntersectRect(damage, mInner.mScrollPort);
63392:       }
59496: 
59496:       if (IsScrollingActive()) {
59496:         // This is the damage rect that we're going to pass up and
59496:         // only request invalidation of ThebesLayers for.
47742:         // damage is now in our coordinate system, which means it was
47742:         // translated using the current scroll position. Adjust it to
47742:         // reflect the scroll position at last paint, since that's what
59496:         // the ThebesLayers are currently set up for.
59496:         // This should not be clipped to the scrollport since ThebesLayers
59496:         // can contain content outside the scrollport that may need to be
59496:         // invalidated.
59496:         nsRect thebesLayerDamage = damage + GetScrollPosition() - mInner.mScrollPosAtLastPaint;
68638:         if (parentDamage.IsEqualInterior(thebesLayerDamage)) {
59496:           // This single call will take care of both rects
59496:           nsHTMLContainerFrame::InvalidateInternal(parentDamage, 0, 0, aForChild, aFlags);
59496:         } else {
59496:           // Invalidate rects separately
59496:           if (!(aFlags & INVALIDATE_NO_THEBES_LAYERS)) {
59496:             nsHTMLContainerFrame::InvalidateInternal(thebesLayerDamage, 0, 0, aForChild,
55830:                                                      aFlags | INVALIDATE_ONLY_THEBES_LAYERS);
55830:           }
59496:           if (!(aFlags & INVALIDATE_ONLY_THEBES_LAYERS) && !parentDamage.IsEmpty()) {
59496:             nsHTMLContainerFrame::InvalidateInternal(parentDamage, 0, 0, aForChild,
59496:                                                      aFlags | INVALIDATE_NO_THEBES_LAYERS);
59496:           }
59496:         }
59496:       } else {
59496:         if (!parentDamage.IsEmpty()) {
59496:           nsHTMLContainerFrame::InvalidateInternal(parentDamage, 0, 0, aForChild, aFlags);
59496:         }
59496:       }
59496: 
68638:       if (mInner.mIsRoot && !parentDamage.IsEqualInterior(damage)) {
19380:         // Make sure we notify our prescontext about invalidations outside
19380:         // viewport clipping.
19380:         // This is important for things that are snapshotting the viewport,
19380:         // possibly outside the scrolled bounds.
19380:         // We don't need to propagate this any further up, though. Anyone who
19380:         // cares about scrolled-out-of-view invalidates had better be listening
19380:         // to our window directly.
32894:         PresContext()->NotifyInvalidation(damage, aFlags);
15910:       }
15910:       return;
30507:     } else if (aForChild == mInner.mHScrollbarBox) {
30507:       if (!mInner.mHasHorizontalScrollbar) {
30507:         // Our scrollbars may send up invalidations even when they're collapsed,
30507:         // because we just size a collapsed scrollbar to empty and some
30507:         // descendants may be non-empty. Suppress that invalidation here.
30507:         return;
30507:       }
30507:     } else if (aForChild == mInner.mVScrollbarBox) {
30507:       if (!mInner.mHasVerticalScrollbar) {
30507:         // Our scrollbars may send up invalidations even when they're collapsed,
30507:         // because we just size a collapsed scrollbar to empty and some
30507:         // descendants may be non-empty. Suppress that invalidation here.
30507:         return;
30507:       }
30507:     }
30690:   }
15910:  
19380:   nsHTMLContainerFrame::InvalidateInternal(aDamageRect, aX, aY, aForChild, aFlags);
15910: }
15910: 
    1: /**
    1:  HTML scrolling implementation
    1: 
    1:  All other things being equal, we prefer layouts with fewer scrollbars showing.
    1: */
    1: 
    1: struct ScrollReflowState {
    1:   const nsHTMLReflowState& mReflowState;
    1:   nsBoxLayoutState mBoxState;
    1:   nsGfxScrollFrameInner::ScrollbarStyles mStyles;
    1:   nsMargin mComputedBorder;
    1: 
 8731:   // === Filled in by ReflowScrolledFrame ===
37083:   nsRect mContentsOverflowArea;
79445:   bool mReflowedContentsWithHScrollbar;
79445:   bool mReflowedContentsWithVScrollbar;
 8731: 
    1:   // === Filled in when TryLayout succeeds ===
    1:   // The size of the inside-border area
    1:   nsSize mInsideBorderSize;
    1:   // Whether we decided to show the horizontal scrollbar
79445:   bool mShowHScrollbar;
    1:   // Whether we decided to show the vertical scrollbar
79445:   bool mShowVScrollbar;
    1: 
    1:   ScrollReflowState(nsIScrollableFrame* aFrame,
    1:                     const nsHTMLReflowState& aState) :
    1:     mReflowState(aState),
14159:     // mBoxState is just used for scrollbars so we don't need to
14159:     // worry about the reflow depth here
14159:     mBoxState(aState.frame->PresContext(), aState.rendContext, 0),
    1:     mStyles(aFrame->GetScrollbarStyles()) {
    1:   }
    1: };
    1: 
    1: // XXXldb Can this go away?
    1: static nsSize ComputeInsideBorderSize(ScrollReflowState* aState,
    1:                                       const nsSize& aDesiredInsideBorderSize)
    1: {
    1:   // aDesiredInsideBorderSize is the frame size; i.e., it includes
    1:   // borders and padding (but the scrolled child doesn't have
    1:   // borders). The scrolled child has the same padding as us.
    1:   nscoord contentWidth = aState->mReflowState.ComputedWidth();
    1:   if (contentWidth == NS_UNCONSTRAINEDSIZE) {
    1:     contentWidth = aDesiredInsideBorderSize.width -
    1:       aState->mReflowState.mComputedPadding.LeftRight();
    1:   }
 4166:   nscoord contentHeight = aState->mReflowState.ComputedHeight();
    1:   if (contentHeight == NS_UNCONSTRAINEDSIZE) {
    1:     contentHeight = aDesiredInsideBorderSize.height -
    1:       aState->mReflowState.mComputedPadding.TopBottom();
    1:   }
    1: 
    1:   aState->mReflowState.ApplyMinMaxConstraints(&contentWidth, &contentHeight);
    1:   return nsSize(contentWidth + aState->mReflowState.mComputedPadding.LeftRight(),
    1:                 contentHeight + aState->mReflowState.mComputedPadding.TopBottom());
    1: }
    1: 
    1: static void
    1: GetScrollbarMetrics(nsBoxLayoutState& aState, nsIBox* aBox, nsSize* aMin,
79445:                     nsSize* aPref, bool aVertical)
    1: {
    1:   NS_ASSERTION(aState.GetRenderingContext(),
    1:                "Must have rendering context in layout state for size "
    1:                "computations");
    1:   
    1:   if (aMin) {
    1:     *aMin = aBox->GetMinSize(aState);
40166:     nsBox::AddMargin(aBox, *aMin);
    1:   }
    1:  
    1:   if (aPref) {
    1:     *aPref = aBox->GetPrefSize(aState);
40166:     nsBox::AddMargin(aBox, *aPref);
    1:   }
    1: }
    1: 
    1: /**
    1:  * Assuming that we know the metrics for our wrapped frame and
    1:  * whether the horizontal and/or vertical scrollbars are present,
80486:  * compute the resulting layout and return true if the layout is
    1:  * consistent. If the layout is consistent then we fill in the
    1:  * computed fields of the ScrollReflowState.
    1:  *
    1:  * The layout is consistent when both scrollbars are showing if and only
    1:  * if they should be showing. A horizontal scrollbar should be showing if all
    1:  * following conditions are met:
    1:  * 1) the style is not HIDDEN
    1:  * 2) our inside-border height is at least the scrollbar height (i.e., the
    1:  * scrollbar fits vertically)
    1:  * 3) our scrollport width (the inside-border width minus the width allocated for a
    1:  * vertical scrollbar, if showing) is at least the scrollbar's min-width
    1:  * (i.e., the scrollbar fits horizontally)
    1:  * 4) the style is SCROLL, or the kid's overflow-area XMost is
    1:  * greater than the scrollport width
    1:  *
80486:  * @param aForce if true, then we just assume the layout is consistent.
    1:  */
79445: bool
    1: nsHTMLScrollFrame::TryLayout(ScrollReflowState* aState,
 8731:                              nsHTMLReflowMetrics* aKidMetrics,
79445:                              bool aAssumeHScroll, bool aAssumeVScroll,
79445:                              bool aForce, nsresult* aResult)
    1: {
 8731:   *aResult = NS_OK;
 8731: 
    1:   if ((aState->mStyles.mVertical == NS_STYLE_OVERFLOW_HIDDEN && aAssumeVScroll) ||
    1:       (aState->mStyles.mHorizontal == NS_STYLE_OVERFLOW_HIDDEN && aAssumeHScroll)) {
    1:     NS_ASSERTION(!aForce, "Shouldn't be forcing a hidden scrollbar to show!");
80486:     return false;
    1:   }
    1: 
 8731:   if (aAssumeVScroll != aState->mReflowedContentsWithVScrollbar ||
12142:       (aAssumeHScroll != aState->mReflowedContentsWithHScrollbar &&
12142:        ScrolledContentDependsOnHeight(aState))) {
 8731:     nsresult rv = ReflowScrolledFrame(aState, aAssumeHScroll, aAssumeVScroll,
80486:                                       aKidMetrics, false);
 8731:     if (NS_FAILED(rv)) {
 8731:       *aResult = rv;
80486:       return false;
 8731:     }
 8731:   }
 8731: 
    1:   nsSize vScrollbarMinSize(0, 0);
    1:   nsSize vScrollbarPrefSize(0, 0);
    1:   if (mInner.mVScrollbarBox) {
    1:     GetScrollbarMetrics(aState->mBoxState, mInner.mVScrollbarBox,
    1:                         &vScrollbarMinSize,
80486:                         aAssumeVScroll ? &vScrollbarPrefSize : nsnull, true);
    1:   }
    1:   nscoord vScrollbarDesiredWidth = aAssumeVScroll ? vScrollbarPrefSize.width : 0;
12186:   nscoord vScrollbarMinHeight = aAssumeVScroll ? vScrollbarMinSize.height : 0;
    1: 
    1:   nsSize hScrollbarMinSize(0, 0);
    1:   nsSize hScrollbarPrefSize(0, 0);
    1:   if (mInner.mHScrollbarBox) {
    1:     GetScrollbarMetrics(aState->mBoxState, mInner.mHScrollbarBox,
    1:                         &hScrollbarMinSize,
80486:                         aAssumeHScroll ? &hScrollbarPrefSize : nsnull, false);
    1:   }
    1:   nscoord hScrollbarDesiredHeight = aAssumeHScroll ? hScrollbarPrefSize.height : 0;
12186:   nscoord hScrollbarMinWidth = aAssumeHScroll ? hScrollbarMinSize.width : 0;
    1: 
    1:   // First, compute our inside-border size and scrollport size
    1:   // XXXldb Can we depend more on ComputeSize here?
    1:   nsSize desiredInsideBorderSize;
    1:   desiredInsideBorderSize.width = vScrollbarDesiredWidth +
32531:     NS_MAX(aKidMetrics->width, hScrollbarMinWidth);
    1:   desiredInsideBorderSize.height = hScrollbarDesiredHeight +
32531:     NS_MAX(aKidMetrics->height, vScrollbarMinHeight);
    1:   aState->mInsideBorderSize =
    1:     ComputeInsideBorderSize(aState, desiredInsideBorderSize);
32531:   nsSize scrollPortSize = nsSize(NS_MAX(0, aState->mInsideBorderSize.width - vScrollbarDesiredWidth),
32531:                                  NS_MAX(0, aState->mInsideBorderSize.height - hScrollbarDesiredHeight));
    1:                                                                                 
    1:   if (!aForce) {
37083:     nsRect scrolledRect =
37083:       mInner.GetScrolledRectInternal(aState->mContentsOverflowArea, scrollPortSize);
14659:     nscoord oneDevPixel = aState->mBoxState.PresContext()->DevPixelsToAppUnits(1);
    1: 
80486:     // If the style is HIDDEN then we already know that aAssumeHScroll is false
    1:     if (aState->mStyles.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN) {
79445:       bool wantHScrollbar =
    1:         aState->mStyles.mHorizontal == NS_STYLE_OVERFLOW_SCROLL ||
14659:         scrolledRect.XMost() >= scrollPortSize.width + oneDevPixel ||
14659:         scrolledRect.x <= -oneDevPixel;
    1:       if (aState->mInsideBorderSize.height < hScrollbarMinSize.height ||
    1:           scrollPortSize.width < hScrollbarMinSize.width)
80486:         wantHScrollbar = false;
    1:       if (wantHScrollbar != aAssumeHScroll)
80486:         return false;
80486:     }
80486: 
80486:     // If the style is HIDDEN then we already know that aAssumeVScroll is false
    1:     if (aState->mStyles.mVertical != NS_STYLE_OVERFLOW_HIDDEN) {
79445:       bool wantVScrollbar =
    1:         aState->mStyles.mVertical == NS_STYLE_OVERFLOW_SCROLL ||
14659:         scrolledRect.YMost() >= scrollPortSize.height + oneDevPixel ||
14659:         scrolledRect.y <= -oneDevPixel;
    1:       if (aState->mInsideBorderSize.width < vScrollbarMinSize.width ||
    1:           scrollPortSize.height < vScrollbarMinSize.height)
80486:         wantVScrollbar = false;
    1:       if (wantVScrollbar != aAssumeVScroll)
80486:         return false;
    1:     }
    1:   }
    1: 
    1:   nscoord vScrollbarActualWidth = aState->mInsideBorderSize.width - scrollPortSize.width;
    1: 
    1:   aState->mShowHScrollbar = aAssumeHScroll;
    1:   aState->mShowVScrollbar = aAssumeVScroll;
    1:   nsPoint scrollPortOrigin(aState->mComputedBorder.left,
    1:                            aState->mComputedBorder.top);
    1:   if (!mInner.IsScrollbarOnRight()) {
    1:     scrollPortOrigin.x += vScrollbarActualWidth;
    1:   }
37083:   mInner.mScrollPort = nsRect(scrollPortOrigin, scrollPortSize);
80486:   return true;
    1: }
    1: 
79445: bool
12142: nsHTMLScrollFrame::ScrolledContentDependsOnHeight(ScrollReflowState* aState)
12142: {
12142:   // Return true if ReflowScrolledFrame is going to do something different
12142:   // based on the presence of a horizontal scrollbar.
12142:   return (mInner.mScrolledFrame->GetStateBits() & NS_FRAME_CONTAINS_RELATIVE_HEIGHT) ||
12142:     aState->mReflowState.ComputedHeight() != NS_UNCONSTRAINEDSIZE ||
12142:     aState->mReflowState.mComputedMinHeight > 0 ||
12142:     aState->mReflowState.mComputedMaxHeight != NS_UNCONSTRAINEDSIZE;
12142: }
12142: 
    1: nsresult
 8731: nsHTMLScrollFrame::ReflowScrolledFrame(ScrollReflowState* aState,
79445:                                        bool aAssumeHScroll,
79445:                                        bool aAssumeVScroll,
    1:                                        nsHTMLReflowMetrics* aMetrics,
79445:                                        bool aFirstPass)
    1: {
32531:   // these could be NS_UNCONSTRAINEDSIZE ... NS_MIN arithmetic should
    1:   // be OK
 8731:   nscoord paddingLR = aState->mReflowState.mComputedPadding.LeftRight();
 8731: 
 8731:   nscoord availWidth = aState->mReflowState.ComputedWidth() + paddingLR;
 8731: 
 8731:   nscoord computedHeight = aState->mReflowState.ComputedHeight();
 8731:   nscoord computedMinHeight = aState->mReflowState.mComputedMinHeight;
 8731:   nscoord computedMaxHeight = aState->mReflowState.mComputedMaxHeight;
 8802:   if (!ShouldPropagateComputedHeightToScrolledContent()) {
 8802:     computedHeight = NS_UNCONSTRAINEDSIZE;
 8802:     computedMinHeight = 0;
 8802:     computedMaxHeight = NS_UNCONSTRAINEDSIZE;
 8802:   }
 8731:   if (aAssumeHScroll) {
 8731:     nsSize hScrollbarPrefSize = 
 8731:       mInner.mHScrollbarBox->GetPrefSize(const_cast<nsBoxLayoutState&>(aState->mBoxState));
 8731:     if (computedHeight != NS_UNCONSTRAINEDSIZE)
32531:       computedHeight = NS_MAX(0, computedHeight - hScrollbarPrefSize.height);
32531:     computedMinHeight = NS_MAX(0, computedMinHeight - hScrollbarPrefSize.height);
 8731:     if (computedMaxHeight != NS_UNCONSTRAINEDSIZE)
32531:       computedMaxHeight = NS_MAX(0, computedMaxHeight - hScrollbarPrefSize.height);
 8731:   }
    1: 
    1:   if (aAssumeVScroll) {
    1:     nsSize vScrollbarPrefSize = 
 8731:       mInner.mVScrollbarBox->GetPrefSize(const_cast<nsBoxLayoutState&>(aState->mBoxState));
32531:     availWidth = NS_MAX(0, availWidth - vScrollbarPrefSize.width);
    1:   }
    1: 
39965:   nsPresContext* presContext = PresContext();
39965: 
80486:   // Pass false for aInit so we can pass in the correct padding.
 8731:   nsHTMLReflowState kidReflowState(presContext, aState->mReflowState,
    1:                                    mInner.mScrolledFrame,
    1:                                    nsSize(availWidth, NS_UNCONSTRAINEDSIZE),
80486:                                    -1, -1, false);
    1:   kidReflowState.Init(presContext, -1, -1, nsnull,
 8731:                       &aState->mReflowState.mComputedPadding);
    1:   kidReflowState.mFlags.mAssumingHScrollbar = aAssumeHScroll;
    1:   kidReflowState.mFlags.mAssumingVScrollbar = aAssumeVScroll;
 8731:   kidReflowState.SetComputedHeight(computedHeight);
 8731:   kidReflowState.mComputedMinHeight = computedMinHeight;
 8731:   kidReflowState.mComputedMaxHeight = computedMaxHeight;
    1: 
37292:   // Temporarily set mHasHorizontalScrollbar/mHasVerticalScrollbar to
37292:   // reflect our assumptions while we reflow the child.
79445:   bool didHaveHorizontalScrollbar = mInner.mHasHorizontalScrollbar;
79445:   bool didHaveVerticalScrollbar = mInner.mHasVerticalScrollbar;
37292:   mInner.mHasHorizontalScrollbar = aAssumeHScroll;
37292:   mInner.mHasVerticalScrollbar = aAssumeVScroll;
37292: 
    1:   nsReflowStatus status;
    1:   nsresult rv = ReflowChild(mInner.mScrolledFrame, presContext, *aMetrics,
    1:                             kidReflowState, 0, 0,
    1:                             NS_FRAME_NO_MOVE_FRAME | NS_FRAME_NO_MOVE_VIEW, status);
37292: 
38153:   mInner.mHasHorizontalScrollbar = didHaveHorizontalScrollbar;
37292:   mInner.mHasVerticalScrollbar = didHaveVerticalScrollbar;
37292: 
37083:   // Don't resize or position the view (if any) because we're going to resize
    1:   // it to the correct size anyway in PlaceScrollArea. Allowing it to
    1:   // resize here would size it to the natural height of the frame,
    1:   // which will usually be different from the scrollport height;
    1:   // invalidating the difference will cause unnecessary repainting.
    1:   FinishReflowChild(mInner.mScrolledFrame, presContext,
    1:                     &kidReflowState, *aMetrics, 0, 0,
    1:                     NS_FRAME_NO_MOVE_FRAME | NS_FRAME_NO_MOVE_VIEW | NS_FRAME_NO_SIZE_VIEW);
    1: 
    1:   // XXX Some frames (e.g., nsObjectFrame, nsFrameFrame, nsTextFrame) don't bother
    1:   // setting their mOverflowArea. This is wrong because every frame should
    1:   // always set mOverflowArea. In fact nsObjectFrame and nsFrameFrame don't
    1:   // support the 'outline' property because of this. Rather than fix the world
    1:   // right now, just fix up the overflow area if necessary. Note that we don't
26950:   // check HasOverflowRect() because it could be set even though the
    1:   // overflow area doesn't include the frame bounds.
55039:   aMetrics->UnionOverflowAreasWithDesiredBounds();
    1: 
55040:   aState->mContentsOverflowArea = aMetrics->ScrollableOverflow();
 8731:   aState->mReflowedContentsWithHScrollbar = aAssumeHScroll;
 8731:   aState->mReflowedContentsWithVScrollbar = aAssumeVScroll;
 8731:   
    1:   return rv;
    1: }
    1: 
79445: bool
12142: nsHTMLScrollFrame::GuessHScrollbarNeeded(const ScrollReflowState& aState)
12142: {
12142:   if (aState.mStyles.mHorizontal != NS_STYLE_OVERFLOW_AUTO)
12142:     // no guessing required
12142:     return aState.mStyles.mHorizontal == NS_STYLE_OVERFLOW_SCROLL;
12142: 
12142:   return mInner.mHasHorizontalScrollbar;
12142: }
12142: 
79445: bool
    1: nsHTMLScrollFrame::GuessVScrollbarNeeded(const ScrollReflowState& aState)
    1: {
    1:   if (aState.mStyles.mVertical != NS_STYLE_OVERFLOW_AUTO)
    1:     // no guessing required
    1:     return aState.mStyles.mVertical == NS_STYLE_OVERFLOW_SCROLL;
    1: 
    1:   // If we've had at least one non-initial reflow, then just assume
    1:   // the state of the vertical scrollbar will be what we determined
    1:   // last time.
    1:   if (mInner.mHadNonInitialReflow) {
    1:     return mInner.mHasVerticalScrollbar;
    1:   }
    1: 
80486:   // If this is the initial reflow, guess false because usually
    1:   // we have very little content by then.
  823:   if (InInitialReflow())
80486:     return false;
    1: 
    1:   if (mInner.mIsRoot) {
42933:     // Assume that there will be a scrollbar; it seems to me
    1:     // that 'most pages' do have a scrollbar, and anyway, it's cheaper
    1:     // to do an extra reflow for the pages that *don't* need a
    1:     // scrollbar (because on average they will have less content).
80486:     return true;
    1:   }
    1: 
    1:   // For non-viewports, just guess that we don't need a scrollbar.
    1:   // XXX I wonder if statistically this is the right idea; I'm
    1:   // basically guessing that there are a lot of overflow:auto DIVs
    1:   // that get their intrinsic size and don't overflow
80486:   return false;
    1: }
    1: 
79445: bool
  823: nsHTMLScrollFrame::InInitialReflow() const
  823: {
  823:   // We're in an initial reflow if NS_FRAME_FIRST_REFLOW is set, unless we're a
  967:   // root scrollframe.  In that case we want to skip this clause altogether.
  967:   // The guess here is that there are lots of overflow:auto divs out there that
  967:   // end up auto-sizing so they don't overflow, and that the root basically
  967:   // always needs a scrollbar if it did last time we loaded this page (good
  967:   // assumption, because our initial reflow is no longer synchronous).
  967:   return !mInner.mIsRoot && (GetStateBits() & NS_FRAME_FIRST_REFLOW);
  823: }
  823: 
    1: nsresult
    1: nsHTMLScrollFrame::ReflowContents(ScrollReflowState* aState,
    1:                                   const nsHTMLReflowMetrics& aDesiredSize)
    1: {
    1:   nsHTMLReflowMetrics kidDesiredSize(aDesiredSize.mFlags);
12142:   nsresult rv = ReflowScrolledFrame(aState, GuessHScrollbarNeeded(*aState),
80486:       GuessVScrollbarNeeded(*aState), &kidDesiredSize, true);
 8731:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // There's an important special case ... if the child appears to fit
    1:   // in the inside-border rect (but overflows the scrollport), we
    1:   // should try laying it out without a vertical scrollbar. It will
    1:   // usually fit because making the available-width wider will not
    1:   // normally make the child taller. (The only situation I can think
    1:   // of is when you have a line containing %-width inline replaced
    1:   // elements whose percentages sum to more than 100%, so increasing
    1:   // the available width makes the line break where it was fitting
    1:   // before.) If we don't treat this case specially, then we will
    1:   // decide that showing scrollbars is OK because the content
    1:   // overflows when we're showing scrollbars and we won't try to
    1:   // remove the vertical scrollbar.
    1: 
    1:   // Detecting when we enter this special case is important for when
    1:   // people design layouts that exactly fit the container "most of the
    1:   // time".
 8731: 
 8731:   // XXX Is this check really sufficient to catch all the incremental cases
 8731:   // where the ideal case doesn't have a scrollbar?
 8731:   if ((aState->mReflowedContentsWithHScrollbar || aState->mReflowedContentsWithVScrollbar) &&
    1:       aState->mStyles.mVertical != NS_STYLE_OVERFLOW_SCROLL &&
    1:       aState->mStyles.mHorizontal != NS_STYLE_OVERFLOW_SCROLL) {
    1:     nsSize insideBorderSize =
    1:       ComputeInsideBorderSize(aState,
    1:                               nsSize(kidDesiredSize.width, kidDesiredSize.height));
37083:     nsRect scrolledRect =
55040:       mInner.GetScrolledRectInternal(kidDesiredSize.ScrollableOverflow(),
55040:                                      insideBorderSize);
    1:     if (nsRect(nsPoint(0, 0), insideBorderSize).Contains(scrolledRect)) {
 8731:       // Let's pretend we had no scrollbars coming in here
80486:       rv = ReflowScrolledFrame(aState, false, false,
80486:                                &kidDesiredSize, false);
 8731:       NS_ENSURE_SUCCESS(rv, rv);
 8731:     }
 8731:   }
 8731: 
 8731:   // Try vertical scrollbar settings that leave the vertical scrollbar unchanged.
 8731:   // Do this first because changing the vertical scrollbar setting is expensive,
 8731:   // forcing a reflow always.
 8731: 
12142:   // Try leaving the horizontal scrollbar unchanged first. This will be more
12142:   // efficient.
12142:   if (TryLayout(aState, &kidDesiredSize, aState->mReflowedContentsWithHScrollbar,
80486:                 aState->mReflowedContentsWithVScrollbar, false, &rv))
 8731:     return NS_OK;
12142:   if (TryLayout(aState, &kidDesiredSize, !aState->mReflowedContentsWithHScrollbar,
80486:                 aState->mReflowedContentsWithVScrollbar, false, &rv))
 8731:     return NS_OK;
 8731: 
 8731:   // OK, now try toggling the vertical scrollbar. The performance advantage
12142:   // of trying the status-quo horizontal scrollbar state
 8731:   // does not exist here (we'll have to reflow due to the vertical scrollbar
 8731:   // change), so always try no horizontal scrollbar first.
79445:   bool newVScrollbarState = !aState->mReflowedContentsWithVScrollbar;
80486:   if (TryLayout(aState, &kidDesiredSize, false, newVScrollbarState, false, &rv))
 8731:     return NS_OK;
80486:   if (TryLayout(aState, &kidDesiredSize, true, newVScrollbarState, false, &rv))
 8731:     return NS_OK;
 8731: 
 8941:   // OK, we're out of ideas. Try again enabling whatever scrollbars we can
 8941:   // enable and force the layout to stick even if it's inconsistent.
 8941:   // This just happens sometimes.
 8941:   TryLayout(aState, &kidDesiredSize,
 8941:             aState->mStyles.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN,
 8941:             aState->mStyles.mVertical != NS_STYLE_OVERFLOW_HIDDEN,
80486:             true, &rv);
 8523:   return rv;
    1: }
    1: 
    1: void
37083: nsHTMLScrollFrame::PlaceScrollArea(const ScrollReflowState& aState,
37083:                                    const nsPoint& aScrollPosition)
    1: {
    1:   nsIFrame *scrolledFrame = mInner.mScrolledFrame;
37083:   // Set the x,y of the scrolled frame to the correct value
37083:   scrolledFrame->SetPosition(mInner.mScrollPort.TopLeft() - aScrollPosition);
    1: 
    1:   nsRect scrolledArea;
12354:   // Preserve the width or height of empty rects
37083:   nsSize portSize = mInner.mScrollPort.Size();
37083:   nsRect scrolledRect = mInner.GetScrolledRectInternal(aState.mContentsOverflowArea, portSize);
68638:   scrolledArea.UnionRectEdges(scrolledRect,
37083:                               nsRect(nsPoint(0,0), portSize));
    1: 
    1:   // Store the new overflow area. Note that this changes where an outline
    1:   // of the scrolled frame would be painted, but scrolled frames can't have
    1:   // outlines (the outline would go on this scrollframe instead).
26950:   // Using FinishAndStoreOverflow is needed so the overflow rect
    1:   // gets set correctly.  It also messes with the overflow rect in the
    1:   // -moz-hidden-unscrollable case, but scrolled frames can't have
    1:   // 'overflow' either.
    1:   // This needs to happen before SyncFrameViewAfterReflow so
26950:   // HasOverflowRect() will return the correct value.
55024:   nsOverflowAreas overflow(scrolledArea, scrolledArea);
55024:   scrolledFrame->FinishAndStoreOverflow(overflow,
    1:                                         scrolledFrame->GetSize());
    1: 
    1:   // Note that making the view *exactly* the size of the scrolled area
    1:   // is critical, since the view scrolling code uses the size of the
    1:   // scrolled view to clamp scroll requests.
37083:   // Normally the scrolledFrame won't have a view but in some cases it
37083:   // might create its own.
  238:   nsContainerFrame::SyncFrameViewAfterReflow(scrolledFrame->PresContext(),
    1:                                              scrolledFrame,
37083:                                              scrolledFrame->GetView(),
55039:                                              scrolledArea,
37083:                                              0);
    1: }
    1: 
12407: nscoord
68481: nsHTMLScrollFrame::GetIntrinsicVScrollbarWidth(nsRenderingContext *aRenderingContext)
12407: {
12407:   nsGfxScrollFrameInner::ScrollbarStyles ss = GetScrollbarStyles();
12407:   if (ss.mVertical != NS_STYLE_OVERFLOW_SCROLL || !mInner.mVScrollbarBox)
12407:     return 0;
12407: 
14159:   // Don't need to worry about reflow depth here since it's
14159:   // just for scrollbars
14159:   nsBoxLayoutState bls(PresContext(), aRenderingContext, 0);
12407:   nsSize vScrollbarPrefSize(0, 0);
12407:   GetScrollbarMetrics(bls, mInner.mVScrollbarBox,
80486:                       nsnull, &vScrollbarPrefSize, true);
12407:   return vScrollbarPrefSize.width;
12407: }
12407: 
    1: /* virtual */ nscoord
68481: nsHTMLScrollFrame::GetMinWidth(nsRenderingContext *aRenderingContext)
    1: {
 8691:   nscoord result = mInner.mScrolledFrame->GetMinWidth(aRenderingContext);
    1:   DISPLAY_MIN_WIDTH(this, result);
12407:   return result + GetIntrinsicVScrollbarWidth(aRenderingContext);
    1: }
    1: 
    1: /* virtual */ nscoord
68481: nsHTMLScrollFrame::GetPrefWidth(nsRenderingContext *aRenderingContext)
    1: {
12407:   nscoord result = mInner.mScrolledFrame->GetPrefWidth(aRenderingContext);
    1:   DISPLAY_PREF_WIDTH(this, result);
12407:   return NSCoordSaturatingAdd(result, GetIntrinsicVScrollbarWidth(aRenderingContext));
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLScrollFrame::GetPadding(nsMargin& aMargin)
    1: {
    1:   // Our padding hangs out on the inside of the scrollframe, but XUL doesn't
    1:   // reaize that.  If we're stuck inside a XUL box, we need to claim no
    1:   // padding.
    1:   // @see also nsXULScrollFrame::GetPadding.
    1:   aMargin.SizeTo(0,0,0,0);
    1:   return NS_OK;
    1: }
    1: 
79445: bool
    1: nsHTMLScrollFrame::IsCollapsed(nsBoxLayoutState& aBoxLayoutState)
    1: {
    1:   // We're never collapsed in the box sense.
80486:   return false;
    1: }
    1: 
60693: // Return the <browser> if the scrollframe is for the root frame directly
60693: // inside a <browser>.
60693: static nsIContent*
60693: GetBrowserRoot(nsIContent* aContent)
60693: {
60693:   if (aContent) {
60693:     nsIDocument* doc = aContent->GetCurrentDoc();
60693:     nsPIDOMWindow* win = doc->GetWindow();
60693:     if (win) {
60693:       nsCOMPtr<nsIContent> frameContent =
60693:         do_QueryInterface(win->GetFrameElementInternal());
60693:       if (frameContent &&
60693:           frameContent->NodeInfo()->Equals(nsGkAtoms::browser, kNameSpaceID_XUL))
60693:         return frameContent;
60693:     }
60693:   }
60693: 
60693:   return nsnull;
60693: }
60693: 
60693: 
    1: NS_IMETHODIMP
    1: nsHTMLScrollFrame::Reflow(nsPresContext*           aPresContext,
    1:                           nsHTMLReflowMetrics&     aDesiredSize,
    1:                           const nsHTMLReflowState& aReflowState,
    1:                           nsReflowStatus&          aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsHTMLScrollFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
    1: 
    1:   ScrollReflowState state(this, aReflowState);
    1:   // sanity check: ensure that if we have no scrollbar, we treat it
    1:   // as hidden.
    1:   if (!mInner.mVScrollbarBox || mInner.mNeverHasVerticalScrollbar)
    1:     state.mStyles.mVertical = NS_STYLE_OVERFLOW_HIDDEN;
    1:   if (!mInner.mHScrollbarBox || mInner.mNeverHasHorizontalScrollbar)
    1:     state.mStyles.mHorizontal = NS_STYLE_OVERFLOW_HIDDEN;
    1: 
    1:   //------------ Handle Incremental Reflow -----------------
79445:   bool reflowContents = true; // XXX Ignored
79445:   bool reflowHScrollbar = true;
79445:   bool reflowVScrollbar = true;
79445:   bool reflowScrollCorner = true;
    1:   if (!aReflowState.ShouldReflowAllKids()) {
    1:     #define NEEDS_REFLOW(frame_) \
 1158:       ((frame_) && NS_SUBTREE_DIRTY(frame_))
    1: 
    1:     reflowContents = NEEDS_REFLOW(mInner.mScrolledFrame);
    1:     reflowHScrollbar = NEEDS_REFLOW(mInner.mHScrollbarBox);
    1:     reflowVScrollbar = NEEDS_REFLOW(mInner.mVScrollbarBox);
60693:     reflowScrollCorner = NEEDS_REFLOW(mInner.mScrollCornerBox) ||
60693:                          NEEDS_REFLOW(mInner.mResizerBox);
    1: 
    1:     #undef NEEDS_REFLOW
    1:   }
    1: 
60693:   if (mInner.mIsRoot) {
80486:     mInner.mCollapsedResizer = true;
60693: 
60693:     nsIContent* browserRoot = GetBrowserRoot(mContent);
60693:     if (browserRoot) {
79445:       bool showResizer = browserRoot->HasAttr(kNameSpaceID_None, nsGkAtoms::showresizer);
60693:       reflowScrollCorner = showResizer == mInner.mCollapsedResizer;
60693:       mInner.mCollapsedResizer = !showResizer;
60693:     }
60693:   }
60693: 
37083:   nsRect oldScrollAreaBounds = mInner.mScrollPort;
37083:   nsRect oldScrolledAreaBounds =
55040:     mInner.mScrolledFrame->GetScrollableOverflowRectRelativeToParent();
37083:   // Adjust to a multiple of device pixels to restore the invariant that
37083:   // oldScrollPosition is a multiple of device pixels. This could have been
37083:   // thrown out by a zoom change.
37083:   nsIntPoint ptDevPx;
39970:   nsPoint oldScrollPosition = mInner.GetScrollPosition();
37083:   
    1:   state.mComputedBorder = aReflowState.mComputedBorderPadding -
    1:     aReflowState.mComputedPadding;
    1: 
    1:   nsresult rv = ReflowContents(&state, aDesiredSize);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
39970:   // Restore the old scroll position, for now, even if that's not valid anymore
39970:   // because we changed size. We'll fix it up in a post-reflow callback, because
39970:   // our current size may only be temporary (e.g. we're compute XUL desired sizes).
37083:   PlaceScrollArea(state, oldScrollPosition);
29508:   if (!mInner.mPostedReflowCallback) {
29508:     // Make sure we'll try scrolling to restored position
29508:     PresContext()->PresShell()->PostReflowCallback(&mInner);
80486:     mInner.mPostedReflowCallback = true;
29508:   }
    1: 
79445:   bool didHaveHScrollbar = mInner.mHasHorizontalScrollbar;
79445:   bool didHaveVScrollbar = mInner.mHasVerticalScrollbar;
    1:   mInner.mHasHorizontalScrollbar = state.mShowHScrollbar;
    1:   mInner.mHasVerticalScrollbar = state.mShowVScrollbar;
37083:   nsRect newScrollAreaBounds = mInner.mScrollPort;
37083:   nsRect newScrolledAreaBounds =
55040:     mInner.mScrolledFrame->GetScrollableOverflowRectRelativeToParent();
    1:   if (mInner.mSkippedScrollbarLayout ||
    1:       reflowHScrollbar || reflowVScrollbar || reflowScrollCorner ||
    1:       (GetStateBits() & NS_FRAME_IS_DIRTY) ||
    1:       didHaveHScrollbar != state.mShowHScrollbar ||
    1:       didHaveVScrollbar != state.mShowVScrollbar ||
68638:       !oldScrollAreaBounds.IsEqualEdges(newScrollAreaBounds) ||
68638:       !oldScrolledAreaBounds.IsEqualEdges(newScrolledAreaBounds)) {
    1:     if (!mInner.mSupppressScrollbarUpdate) {
80486:       mInner.mSkippedScrollbarLayout = false;
    1:       mInner.SetScrollbarVisibility(mInner.mHScrollbarBox, state.mShowHScrollbar);
    1:       mInner.SetScrollbarVisibility(mInner.mVScrollbarBox, state.mShowVScrollbar);
    1:       // place and reflow scrollbars
    1:       nsRect insideBorderArea =
    1:         nsRect(nsPoint(state.mComputedBorder.left, state.mComputedBorder.top),
    1:                state.mInsideBorderSize);
    1:       mInner.LayoutScrollbars(state.mBoxState, insideBorderArea,
37083:                               oldScrollAreaBounds);
    1:     } else {
80486:       mInner.mSkippedScrollbarLayout = true;
    1:     }
    1:   }
    1: 
    1:   aDesiredSize.width = state.mInsideBorderSize.width +
    1:     state.mComputedBorder.LeftRight();
    1:   aDesiredSize.height = state.mInsideBorderSize.height +
    1:     state.mComputedBorder.TopBottom();
    1: 
55039:   aDesiredSize.SetOverflowAreasToDesiredBounds();
35704: 
35704:   CheckInvalidateSizeChange(aDesiredSize);
35704: 
79488:   FinishReflowWithAbsoluteFrames(aPresContext, aDesiredSize, aReflowState, aStatus);
    1: 
  823:   if (!InInitialReflow() && !mInner.mHadNonInitialReflow) {
80486:     mInner.mHadNonInitialReflow = true;
    1:   }
    1: 
68638:   if (mInner.mIsRoot && !oldScrolledAreaBounds.IsEqualEdges(newScrolledAreaBounds)) {
37084:     mInner.PostScrolledAreaEvent();
33011:   }
33011: 
    1:   aStatus = NS_FRAME_COMPLETE;
    1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
 6722:   mInner.PostOverflowEvent();
    1:   return rv;
    1: }
    1: 
33011: 
33011: ////////////////////////////////////////////////////////////////////////////////
33011: 
    1: #ifdef NS_DEBUG
    1: NS_IMETHODIMP
    1: nsHTMLScrollFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("HTMLScroll"), aResult);
    1: }
    1: #endif
    1: 
    1: #ifdef ACCESSIBILITY
46338: already_AddRefed<nsAccessible>
46338: nsHTMLScrollFrame::CreateAccessible()
    1: {
    1:   if (!IsFocusable()) {
46338:     return nsnull;
    1:   }
    1:   // Focusable via CSS, so needs to be in accessibility hierarchy
61464:   nsAccessibilityService* accService = nsIPresShell::AccService();
    1:   if (accService) {
46338:     return accService->CreateHyperTextAccessible(mContent,
46338:                                                  PresContext()->PresShell());
46338:   }
46338: 
46338:   return nsnull;
    1: }
    1: #endif
    1: 
23554: NS_QUERYFRAME_HEAD(nsHTMLScrollFrame)
23554:   NS_QUERYFRAME_ENTRY(nsIAnonymousContentCreator)
23554:   NS_QUERYFRAME_ENTRY(nsIScrollableFrame)
23554:   NS_QUERYFRAME_ENTRY(nsIStatefulFrame)
23554: NS_QUERYFRAME_TAIL_INHERITING(nsHTMLContainerFrame)
    1: 
    1: //----------nsXULScrollFrame-------------------------------------------
    1: 
    1: nsIFrame*
79445: NS_NewXULScrollFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, bool aIsRoot)
    1: {
    1:   return new (aPresShell) nsXULScrollFrame(aPresShell, aContext, aIsRoot);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsXULScrollFrame)
32423: 
79445: nsXULScrollFrame::nsXULScrollFrame(nsIPresShell* aShell, nsStyleContext* aContext, bool aIsRoot)
    1:   : nsBoxFrame(aShell, aContext, aIsRoot),
62087:     mInner(this, aIsRoot)
    1: {
    1:     SetLayoutManager(nsnull);
    1: }
    1: 
    1: nsMargin nsGfxScrollFrameInner::GetDesiredScrollbarSizes(nsBoxLayoutState* aState) {
    1:   NS_ASSERTION(aState && aState->GetRenderingContext(),
    1:                "Must have rendering context in layout state for size "
    1:                "computations");
    1:   
    1:   nsMargin result(0, 0, 0, 0);
    1: 
    1:   if (mVScrollbarBox) {
    1:     nsSize size = mVScrollbarBox->GetPrefSize(*aState);
40166:     nsBox::AddMargin(mVScrollbarBox, size);
    1:     if (IsScrollbarOnRight())
    1:       result.left = size.width;
    1:     else
    1:       result.right = size.width;
    1:   }
    1: 
    1:   if (mHScrollbarBox) {
    1:     nsSize size = mHScrollbarBox->GetPrefSize(*aState);
40166:     nsBox::AddMargin(mHScrollbarBox, size);
    1:     // We don't currently support any scripts that would require a scrollbar
    1:     // at the top. (Are there any?)
    1:     result.bottom = size.height;
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: nsresult
69438: nsXULScrollFrame::CreateAnonymousContent(nsTArray<ContentInfo>& aElements)
    1: {
    1:   return mInner.CreateAnonymousContent(aElements);
    1: }
    1: 
    1: void
55877: nsXULScrollFrame::AppendAnonymousContentTo(nsBaseContentList& aElements,
55877:                                            PRUint32 aFilter)
38069: {
55877:   mInner.AppendAnonymousContentTo(aElements, aFilter);
38069: }
38069: 
38069: void
36647: nsXULScrollFrame::DestroyFrom(nsIFrame* aDestructRoot)
    1: {
    1:   mInner.Destroy();
36647:   nsBoxFrame::DestroyFrom(aDestructRoot);
    1: }
    1: 
    1: NS_IMETHODIMP
77154: nsXULScrollFrame::SetInitialChildList(ChildListID     aListID,
30790:                                       nsFrameList&    aChildList)
    1: {
77154:   nsresult rv = nsBoxFrame::SetInitialChildList(aListID, aChildList);
    1:   mInner.ReloadChildFrames();
    1:   return rv;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
77154: nsXULScrollFrame::AppendFrames(ChildListID     aListID,
30941:                                nsFrameList&    aFrameList)
    1: {
77154:   nsresult rv = nsBoxFrame::AppendFrames(aListID, aFrameList);
    1:   mInner.ReloadChildFrames();
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
77154: nsXULScrollFrame::InsertFrames(ChildListID     aListID,
    1:                                nsIFrame*       aPrevFrame,
30941:                                nsFrameList&    aFrameList)
    1: {
77154:   nsresult rv = nsBoxFrame::InsertFrames(aListID, aPrevFrame, aFrameList);
    1:   mInner.ReloadChildFrames();
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
77154: nsXULScrollFrame::RemoveFrame(ChildListID     aListID,
    1:                               nsIFrame*       aOldFrame)
    1: {
77154:   nsresult rv = nsBoxFrame::RemoveFrame(aListID, aOldFrame);
    1:   mInner.ReloadChildFrames();
    1:   return rv;
    1: }
    1: 
    1: nsSplittableType
    1: nsXULScrollFrame::GetSplittableType() const
    1: {
    1:   return NS_FRAME_NOT_SPLITTABLE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULScrollFrame::GetPadding(nsMargin& aMargin)
    1: {
    1:    aMargin.SizeTo(0,0,0,0);
    1:    return NS_OK;
    1: }
    1: 
    1: PRIntn
    1: nsXULScrollFrame::GetSkipSides() const
    1: {
    1:   return 0;
    1: }
    1: 
    1: nsIAtom*
    1: nsXULScrollFrame::GetType() const
    1: {
    1:   return nsGkAtoms::scrollFrame; 
    1: }
    1: 
15910: void
15910: nsXULScrollFrame::InvalidateInternal(const nsRect& aDamageRect,
15910:                                      nscoord aX, nscoord aY, nsIFrame* aForChild,
19380:                                      PRUint32 aFlags)
15910: {
15910:   if (aForChild == mInner.mScrolledFrame) {
59498:     nsRect damage = aDamageRect + nsPoint(aX, aY);
59498:     // This is the damage rect that we're going to pass up to our parent.
59498:     nsRect parentDamage;
63392:     // If we're using a displayport, we might be displaying an area
63392:     // different than our scroll port and the damage needs to be
63392:     // clipped to that instead.
63414:     nsRect displayport;
79445:     bool usingDisplayport = nsLayoutUtils::GetDisplayPort(GetContent(),
63414:                                                             &displayport);
63414:     if (usingDisplayport) {
63414:       parentDamage.IntersectRect(damage, displayport);
63392:     } else {
59498:       parentDamage.IntersectRect(damage, mInner.mScrollPort);
63392:     }
59498: 
59498:     if (IsScrollingActive()) {
59498:       // This is the damage rect that we're going to pass up and
59498:       // only request invalidation of ThebesLayers for.
59498:       // damage is now in our coordinate system, which means it was
59498:       // translated using the current scroll position. Adjust it to
59498:       // reflect the scroll position at last paint, since that's what
59498:       // the ThebesLayers are currently set up for.
59498:       // This should not be clipped to the scrollport since ThebesLayers
59498:       // can contain content outside the scrollport that may need to be
59498:       // invalidated.
59498:       nsRect thebesLayerDamage = damage + GetScrollPosition() - mInner.mScrollPosAtLastPaint;
68638:       if (parentDamage.IsEqualInterior(thebesLayerDamage)) {
59498:         // This single call will take care of both rects
59498:         nsBoxFrame::InvalidateInternal(parentDamage, 0, 0, aForChild, aFlags);
59498:       } else {
59498:         // Invalidate rects separately
59498:         if (!(aFlags & INVALIDATE_NO_THEBES_LAYERS)) {
59498:           nsBoxFrame::InvalidateInternal(thebesLayerDamage, 0, 0, aForChild,
55830:                                          aFlags | INVALIDATE_ONLY_THEBES_LAYERS);
55830:         }
59498:         if (!(aFlags & INVALIDATE_ONLY_THEBES_LAYERS) && !parentDamage.IsEmpty()) {
59498:           nsBoxFrame::InvalidateInternal(parentDamage, 0, 0, aForChild,
59498:                                          aFlags | INVALIDATE_NO_THEBES_LAYERS);
59498:         }
59498:       }
59498:     } else {
59498:       if (!parentDamage.IsEmpty()) {
59498:         nsBoxFrame::InvalidateInternal(parentDamage, 0, 0, aForChild, aFlags);
59498:       }
15910:     }
15910:     return;
15910:   }
15910:   
19380:   nsBoxFrame::InvalidateInternal(aDamageRect, aX, aY, aForChild, aFlags);
15910: }
15910: 
    1: nscoord
    1: nsXULScrollFrame::GetBoxAscent(nsBoxLayoutState& aState)
    1: {
    1:   if (!mInner.mScrolledFrame)
    1:     return 0;
    1: 
    1:   nscoord ascent = mInner.mScrolledFrame->GetBoxAscent(aState);
    1:   nsMargin m(0,0,0,0);
    1:   GetBorderAndPadding(m);
    1:   ascent += m.top;
    1:   GetMargin(m);
    1:   ascent += m.top;
    1: 
    1:   return ascent;
    1: }
    1: 
    1: nsSize
    1: nsXULScrollFrame::GetPrefSize(nsBoxLayoutState& aState)
    1: {
    1: #ifdef DEBUG_LAYOUT
    1:   PropagateDebug(aState);
    1: #endif
    1: 
    1:   nsSize pref = mInner.mScrolledFrame->GetPrefSize(aState);
    1: 
    1:   nsGfxScrollFrameInner::ScrollbarStyles styles = GetScrollbarStyles();
    1: 
    1:   // scrolled frames don't have their own margins
    1: 
    1:   if (mInner.mVScrollbarBox &&
    1:       styles.mVertical == NS_STYLE_OVERFLOW_SCROLL) {
    1:     nsSize vSize = mInner.mVScrollbarBox->GetPrefSize(aState);
40166:     nsBox::AddMargin(mInner.mVScrollbarBox, vSize);
    1:     pref.width += vSize.width;
    1:   }
    1:    
    1:   if (mInner.mHScrollbarBox &&
    1:       styles.mHorizontal == NS_STYLE_OVERFLOW_SCROLL) {
    1:     nsSize hSize = mInner.mHScrollbarBox->GetPrefSize(aState);
40166:     nsBox::AddMargin(mInner.mHScrollbarBox, hSize);
    1:     pref.height += hSize.height;
    1:   }
    1: 
    1:   AddBorderAndPadding(pref);
79445:   bool widthSet, heightSet;
39604:   nsIBox::AddCSSPrefSize(this, pref, widthSet, heightSet);
    1:   return pref;
    1: }
    1: 
    1: nsSize
    1: nsXULScrollFrame::GetMinSize(nsBoxLayoutState& aState)
    1: {
    1: #ifdef DEBUG_LAYOUT
    1:   PropagateDebug(aState);
    1: #endif
    1: 
    1:   nsSize min = mInner.mScrolledFrame->GetMinSizeForScrollArea(aState);
    1: 
    1:   nsGfxScrollFrameInner::ScrollbarStyles styles = GetScrollbarStyles();
    1:      
    1:   if (mInner.mVScrollbarBox &&
    1:       styles.mVertical == NS_STYLE_OVERFLOW_SCROLL) {
    1:      nsSize vSize = mInner.mVScrollbarBox->GetMinSize(aState);
40166:      AddMargin(mInner.mVScrollbarBox, vSize);
    1:      min.width += vSize.width;
    1:      if (min.height < vSize.height)
    1:         min.height = vSize.height;
    1:   }
    1:         
    1:   if (mInner.mHScrollbarBox &&
    1:       styles.mHorizontal == NS_STYLE_OVERFLOW_SCROLL) {
    1:      nsSize hSize = mInner.mHScrollbarBox->GetMinSize(aState);
40166:      AddMargin(mInner.mHScrollbarBox, hSize);
    1:      min.height += hSize.height;
    1:      if (min.width < hSize.width)
    1:         min.width = hSize.width;
    1:   }
    1: 
    1:   AddBorderAndPadding(min);
79445:   bool widthSet, heightSet;
39604:   nsIBox::AddCSSMinSize(aState, this, min, widthSet, heightSet);
    1:   return min;
    1: }
    1: 
    1: nsSize
    1: nsXULScrollFrame::GetMaxSize(nsBoxLayoutState& aState)
    1: {
    1: #ifdef DEBUG_LAYOUT
    1:   PropagateDebug(aState);
    1: #endif
    1: 
12306:   nsSize maxSize(NS_INTRINSICSIZE, NS_INTRINSICSIZE);
12306: 
12306:   AddBorderAndPadding(maxSize);
79445:   bool widthSet, heightSet;
39604:   nsIBox::AddCSSMaxSize(this, maxSize, widthSet, heightSet);
12306:   return maxSize;
    1: }
    1: 
    1: #ifdef NS_DEBUG
    1: NS_IMETHODIMP
    1: nsXULScrollFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("XULScroll"), aResult);
    1: }
    1: #endif
    1: 
    1: NS_IMETHODIMP
    1: nsXULScrollFrame::DoLayout(nsBoxLayoutState& aState)
    1: {
    1:   PRUint32 flags = aState.LayoutFlags();
    1:   nsresult rv = Layout(aState);
    1:   aState.SetLayoutFlags(flags);
    1: 
    1:   nsBox::DoLayout(aState);
    1:   return rv;
    1: }
    1: 
23554: NS_QUERYFRAME_HEAD(nsXULScrollFrame)
23554:   NS_QUERYFRAME_ENTRY(nsIAnonymousContentCreator)
23554:   NS_QUERYFRAME_ENTRY(nsIScrollableFrame)
23554:   NS_QUERYFRAME_ENTRY(nsIStatefulFrame)
23554: NS_QUERYFRAME_TAIL_INHERITING(nsBoxFrame)
    1:  
    1: //-------------------- Inner ----------------------
    1: 
37083: #define SMOOTH_SCROLL_PREF_NAME "general.smoothScroll"
37083: 
63967: const double kCurrentVelocityWeighting = 0.25;
63967: const double kStopDecelerationWeighting = 0.4;
63967: const double kSmoothScrollAnimationDuration = 150; // milliseconds
63967: 
37083: class nsGfxScrollFrameInner::AsyncScroll {
37083: public:
63967:   typedef mozilla::TimeStamp TimeStamp;
63967:   typedef mozilla::TimeDuration TimeDuration;
63967: 
37083:   AsyncScroll() {}
37083:   ~AsyncScroll() {
37083:     if (mScrollTimer) mScrollTimer->Cancel();
37083:   }
37083: 
63967:   nsPoint PositionAt(TimeStamp aTime);
63967:   nsSize VelocityAt(TimeStamp aTime); // In nscoords per second
63967: 
63967:   void InitSmoothScroll(TimeStamp aTime, nsPoint aCurrentPos,
63967:                         nsSize aCurrentVelocity, nsPoint aDestination);
63967: 
79445:   bool IsFinished(TimeStamp aTime) {
63967:     return aTime > mStartTime + mDuration; // XXX or if we've hit the wall
63967:   }
63967: 
37083:   nsCOMPtr<nsITimer> mScrollTimer;
63967:   TimeStamp mStartTime;
63967:   TimeDuration mDuration;
63967:   nsPoint mStartPos;
63967:   nsPoint mDestination;
63967:   nsSMILKeySpline mTimingFunctionX;
63967:   nsSMILKeySpline mTimingFunctionY;
79445:   bool mIsSmoothScroll;
63967: 
63967: protected:
63967:   double ProgressAt(TimeStamp aTime) {
81029:     return clamped((aTime - mStartTime) / mDuration, 0.0, 1.0);
63967:   }
63967: 
63967:   nscoord VelocityComponent(double aTimeProgress,
63967:                             nsSMILKeySpline& aTimingFunction,
63967:                             nscoord aStart, nscoord aDestination);
63967: 
63967:   // Initializes the timing function in such a way that the current velocity is
63967:   // preserved.
63967:   void InitTimingFunction(nsSMILKeySpline& aTimingFunction,
63967:                           nscoord aCurrentPos, nscoord aCurrentVelocity,
63967:                           nscoord aDestination);
37083: };
37083: 
63967: nsPoint
63967: nsGfxScrollFrameInner::AsyncScroll::PositionAt(TimeStamp aTime) {
63967:   double progressX = mTimingFunctionX.GetSplineValue(ProgressAt(aTime));
63967:   double progressY = mTimingFunctionY.GetSplineValue(ProgressAt(aTime));
63967:   return nsPoint((1 - progressX) * mStartPos.x + progressX * mDestination.x,
63967:                  (1 - progressY) * mStartPos.y + progressY * mDestination.y);
63967: }
63967: 
63967: nsSize
63967: nsGfxScrollFrameInner::AsyncScroll::VelocityAt(TimeStamp aTime) {
63967:   double timeProgress = ProgressAt(aTime);
63967:   return nsSize(VelocityComponent(timeProgress, mTimingFunctionX,
63967:                                   mStartPos.x, mDestination.x),
63967:                 VelocityComponent(timeProgress, mTimingFunctionY,
63967:                                   mStartPos.y, mDestination.y));
63967: }
63967: 
63967: void
63967: nsGfxScrollFrameInner::AsyncScroll::InitSmoothScroll(TimeStamp aTime,
63967:                                                      nsPoint aCurrentPos,
63967:                                                      nsSize aCurrentVelocity,
63967:                                                      nsPoint aDestination) {
63967:   mStartTime = aTime;
63967:   mStartPos = aCurrentPos;
63967:   mDestination = aDestination;
63967:   mDuration = TimeDuration::FromMilliseconds(kSmoothScrollAnimationDuration);
63967:   InitTimingFunction(mTimingFunctionX, mStartPos.x, aCurrentVelocity.width, aDestination.x);
63967:   InitTimingFunction(mTimingFunctionY, mStartPos.y, aCurrentVelocity.height, aDestination.y);
63967: }
63967: 
63967: 
63967: nscoord
63967: nsGfxScrollFrameInner::AsyncScroll::VelocityComponent(double aTimeProgress,
63967:                                                       nsSMILKeySpline& aTimingFunction,
63967:                                                       nscoord aStart,
63967:                                                       nscoord aDestination)
37083: {
63967:   double dt, dxy;
63967:   aTimingFunction.GetSplineDerivativeValues(aTimeProgress, dt, dxy);
63967:   if (dt == 0)
63967:     return dxy >= 0 ? nscoord_MAX : nscoord_MIN;
63967: 
63967:   const TimeDuration oneSecond = TimeDuration::FromSeconds(1);
63967:   double slope = dxy / dt;
63967:   return (slope * (aDestination - aStart) / (mDuration / oneSecond));
63967: }
63967: 
63967: void
63967: nsGfxScrollFrameInner::AsyncScroll::InitTimingFunction(nsSMILKeySpline& aTimingFunction,
63967:                                                        nscoord aCurrentPos,
63967:                                                        nscoord aCurrentVelocity,
63967:                                                        nscoord aDestination)
63967: {
63967:   if (aDestination == aCurrentPos || kCurrentVelocityWeighting == 0) {
63967:     aTimingFunction.Init(0, 0, 1 - kStopDecelerationWeighting, 1);
63967:     return;
63967:   }
63967: 
63967:   const TimeDuration oneSecond = TimeDuration::FromSeconds(1);
63967:   double slope = aCurrentVelocity * (mDuration / oneSecond) / (aDestination - aCurrentPos);
63967:   double normalization = sqrt(1.0 + slope * slope);
63967:   double dt = 1.0 / normalization * kCurrentVelocityWeighting;
63967:   double dxy = slope / normalization * kCurrentVelocityWeighting;
63967:   aTimingFunction.Init(dt, dxy, 1 - kStopDecelerationWeighting, 1);
37083: }
37083: 
79445: static bool
37083: IsSmoothScrollingEnabled()
37083: {
79445:   return Preferences::GetBool(SMOOTH_SCROLL_PREF_NAME, false);
37083: }
37083: 
47750: class ScrollFrameActivityTracker : public nsExpirationTracker<nsGfxScrollFrameInner,4> {
47750: public:
51948:   // Wait for 3-4s between scrolls before we remove our layers.
51948:   // That's 4 generations of 1s each.
51948:   enum { TIMEOUT_MS = 1000 };
47750:   ScrollFrameActivityTracker()
47750:     : nsExpirationTracker<nsGfxScrollFrameInner,4>(TIMEOUT_MS) {}
47750:   ~ScrollFrameActivityTracker() {
47750:     AgeAllGenerations();
47750:   }
47750: 
47750:   virtual void NotifyExpired(nsGfxScrollFrameInner *aObject) {
47750:     RemoveObject(aObject);
59828:     aObject->MarkInactive();
47750:   }
47750: };
47750: 
47750: static ScrollFrameActivityTracker *gScrollFrameActivityTracker = nsnull;
47750: 
    1: nsGfxScrollFrameInner::nsGfxScrollFrameInner(nsContainerFrame* aOuter,
79445:                                              bool aIsRoot)
63414:   : mHScrollbarBox(nsnull)
63414:   , mVScrollbarBox(nsnull)
63414:   , mScrolledFrame(nsnull)
63414:   , mScrollCornerBox(nsnull)
63414:   , mResizerBox(nsnull)
63414:   , mOuter(aOuter)
63414:   , mAsyncScroll(nsnull)
63414:   , mDestination(0, 0)
63414:   , mScrollPosAtLastPaint(0, 0)
63414:   , mRestorePos(-1, -1)
63414:   , mLastPos(-1, -1)
80486:   , mNeverHasVerticalScrollbar(false)
80486:   , mNeverHasHorizontalScrollbar(false)
80486:   , mHasVerticalScrollbar(false)
80486:   , mHasHorizontalScrollbar(false)
80486:   , mFrameIsUpdatingScrollbar(false)
80486:   , mDidHistoryRestore(false)
63414:   , mIsRoot(aIsRoot)
80486:   , mSupppressScrollbarUpdate(false)
80486:   , mSkippedScrollbarLayout(false)
80486:   , mHadNonInitialReflow(false)
80486:   , mHorizontalOverflow(false)
80486:   , mVerticalOverflow(false)
80486:   , mPostedReflowCallback(false)
80486:   , mMayHaveDirtyFixedChildren(false)
80486:   , mUpdateScrollbarAttributes(false)
80486:   , mCollapsedResizer(false)
80486:   , mShouldBuildLayer(false)
    1: {
56302:   // lookup if we're allowed to overlap the content from the look&feel object
78130:   mScrollbarsCanOverlapContent =
78130:     LookAndFeel::GetInt(LookAndFeel::eIntID_ScrollbarsCanOverlapContent) != 0;
59827:   mScrollingActive = IsAlwaysActive();
    1: }
    1: 
    1: nsGfxScrollFrameInner::~nsGfxScrollFrameInner()
    1: {
47750:   if (mActivityExpirationState.IsTracked()) {
47750:     gScrollFrameActivityTracker->RemoveObject(this);
47750:   }
47750:   if (gScrollFrameActivityTracker &&
47750:       gScrollFrameActivityTracker->IsEmpty()) {
47750:     delete gScrollFrameActivityTracker;
47750:     gScrollFrameActivityTracker = nsnull;
47750:   }
37083:   delete mAsyncScroll;
37083: }
37083: 
37083: static nscoord
37083: Clamp(nscoord aLower, nscoord aVal, nscoord aUpper)
37083: {
37083:   if (aVal < aLower)
37083:     return aLower;
37083:   if (aVal > aUpper)
37083:     return aUpper;
37083:   return aVal;
37083: }
37083: 
37083: nsPoint
37083: nsGfxScrollFrameInner::ClampScrollPosition(const nsPoint& aPt) const
37083: {
37083:   nsRect range = GetScrollRange();
37083:   return nsPoint(Clamp(range.x, aPt.x, range.XMost()),
37083:                  Clamp(range.y, aPt.y, range.YMost()));
37083: }
37083: 
37083: /*
37083:  * Callback function from timer used in nsGfxScrollFrameInner::ScrollTo
37083:  */
37083: void
37083: nsGfxScrollFrameInner::AsyncScrollCallback(nsITimer *aTimer, void* anInstance)
37083: {
37083:   nsGfxScrollFrameInner* self = static_cast<nsGfxScrollFrameInner*>(anInstance);
37083:   if (!self || !self->mAsyncScroll)
37083:     return;
37083: 
37083:   if (self->mAsyncScroll->mIsSmoothScroll) {
63967:     TimeStamp now = TimeStamp::Now();
63967:     nsPoint destination = self->mAsyncScroll->PositionAt(now);
63967:     if (self->mAsyncScroll->IsFinished(now)) {
37083:       delete self->mAsyncScroll;
37083:       self->mAsyncScroll = nsnull;
37083:     }
37083: 
37083:     self->ScrollToImpl(destination);
37083:   } else {
37083:     delete self->mAsyncScroll;
37083:     self->mAsyncScroll = nsnull;
37083: 
37083:     self->ScrollToImpl(self->mDestination);
37083:   }
37083: }
37083: 
37083: /*
37083:  * this method wraps calls to ScrollToImpl(), either in one shot or incrementally,
37083:  *  based on the setting of the smooth scroll pref
37083:  */
37083: void
37083: nsGfxScrollFrameInner::ScrollTo(nsPoint aScrollPosition,
37083:                                 nsIScrollableFrame::ScrollMode aMode)
37083: {
37083:   mDestination = ClampScrollPosition(aScrollPosition);
37083: 
37083:   if (aMode == nsIScrollableFrame::INSTANT) {
37083:     // Asynchronous scrolling is not allowed, so we'll kill any existing
37083:     // async-scrolling process and do an instant scroll
37083:     delete mAsyncScroll;
37083:     mAsyncScroll = nsnull;
37083:     ScrollToImpl(mDestination);
37083:     return;
37083:   }
37083: 
63967:   TimeStamp now = TimeStamp::Now();
63967:   nsPoint currentPosition = GetScrollPosition();
63967:   nsSize currentVelocity(0, 0);
79445:   bool isSmoothScroll = (aMode == nsIScrollableFrame::SMOOTH) &&
61924:                           IsSmoothScrollingEnabled();
37083: 
37083:   if (mAsyncScroll) {
37083:     if (mAsyncScroll->mIsSmoothScroll) {
63967:       currentPosition = mAsyncScroll->PositionAt(now);
63967:       currentVelocity = mAsyncScroll->VelocityAt(now);
37083:     }
37083:   } else {
37083:     mAsyncScroll = new AsyncScroll;
37083:     mAsyncScroll->mScrollTimer = do_CreateInstance("@mozilla.org/timer;1");
37083:     if (!mAsyncScroll->mScrollTimer) {
37083:       delete mAsyncScroll;
37083:       mAsyncScroll = nsnull;
72509:       // allocation failed. Scroll the normal way.
37083:       ScrollToImpl(mDestination);
37083:       return;
37083:     }
37083:     if (isSmoothScroll) {
37083:       mAsyncScroll->mScrollTimer->InitWithFuncCallback(
63967:         AsyncScrollCallback, this, 1000 / 60,
63967:         nsITimer::TYPE_REPEATING_SLACK);
37083:     } else {
37083:       mAsyncScroll->mScrollTimer->InitWithFuncCallback(
37083:         AsyncScrollCallback, this, 0, nsITimer::TYPE_ONE_SHOT);
37083:     }
37083:   }
37083: 
37083:   mAsyncScroll->mIsSmoothScroll = isSmoothScroll;
37083: 
37083:   if (isSmoothScroll) {
63967:     mAsyncScroll->InitSmoothScroll(now, currentPosition, currentVelocity,
63967:                                    aScrollPosition);
37083:   }
37083: }
37083: 
37083: // We can't use nsContainerFrame::PositionChildViews here because
37083: // we don't want to invalidate views that have moved.
55828: static void AdjustViews(nsIFrame* aFrame)
37083: {
37083:   nsIView* view = aFrame->GetView();
37083:   if (view) {
37083:     nsPoint pt;
37083:     aFrame->GetParent()->GetClosestView(&pt);
37083:     pt += aFrame->GetPosition();
37083:     view->SetPosition(pt.x, pt.y);
37083: 
37083:     return;
37083:   }
37083: 
37083:   if (!(aFrame->GetStateBits() & NS_FRAME_HAS_CHILD_WITH_VIEW)) {
37083:     return;
37083:   }
37083: 
77153:   // Call AdjustViews recursively for all child frames except the popup list as
77153:   // the views for popups are not scrolled.
77153:   nsIFrame::ChildListIterator lists(aFrame);
77153:   for (; !lists.IsDone(); lists.Next()) {
77153:     if (lists.CurrentID() == nsIFrame::kPopupList) {
77153:       continue;
77153:     }
77153:     nsFrameList::Enumerator childFrames(lists.CurrentList());
77153:     for (; !childFrames.AtEnd(); childFrames.Next()) {
77153:       AdjustViews(childFrames.get());
77153:     }
77153:   }
37083: }
37083: 
79445: static bool
59827: CanScrollWithBlitting(nsIFrame* aFrame)
37083: {
80691:   if (aFrame->GetStateBits() & NS_SCROLLFRAME_INVALIDATE_CONTENTS_ON_SCROLL)
80691:     return false;
80691: 
41182:   for (nsIFrame* f = aFrame; f;
47742:        f = nsLayoutUtils::GetCrossDocParentFrame(f)) {
37083:     if (nsSVGIntegrationUtils::UsingEffectsForFrame(f) ||
37083:         f->IsFrameOfType(nsIFrame::eSVG)) {
80486:       return false;
37083:     }
59828:     nsIScrollableFrame* sf = do_QueryFrame(f);
81851:     if (sf && nsLayoutUtils::HasNonZeroCorner(f->GetStyleBorder()->mBorderRadius))
80486:       return false;
59827:     if (nsLayoutUtils::IsPopup(f))
41182:       break;
37083:   }
80486:   return true;
37083: }
37083: 
47742: static void
47742: InvalidateFixedBackgroundFramesFromList(nsDisplayListBuilder* aBuilder,
50392:                                         nsIFrame* aMovingFrame,
47742:                                         const nsDisplayList& aList)
47742: {
47742:   for (nsDisplayItem* item = aList.GetBottom(); item; item = item->GetAbove()) {
47742:     nsDisplayList* sublist = item->GetList();
47742:     if (sublist) {
50392:       InvalidateFixedBackgroundFramesFromList(aBuilder, aMovingFrame, *sublist);
47776:       continue;
47776:     }
47776:     nsIFrame* f = item->GetUnderlyingFrame();
50392:     if (f &&
50392:         item->IsVaryingRelativeToMovingFrame(aBuilder, aMovingFrame)) {
62289:       if (FrameLayerBuilder::NeedToInvalidateFixedDisplayItem(aBuilder, item)) {
62289:         // FrameLayerBuilder does not take care of scrolling this one
51261:         f->Invalidate(item->GetVisibleRect() - item->ToReferenceFrame());
47742:       }
47742:     }
47742:   }
47754: }
47742: 
47742: static void
47742: InvalidateFixedBackgroundFrames(nsIFrame* aRootFrame,
47742:                                 nsIFrame* aMovingFrame,
47742:                                 const nsRect& aUpdateRect)
47742: {
47742:   if (!aMovingFrame->PresContext()->MayHaveFixedBackgroundFrames())
47742:     return;
47742: 
47742:   NS_ASSERTION(aRootFrame != aMovingFrame,
47742:                "The root frame shouldn't be the one that's moving, that makes no sense");
47742: 
47742:   // Build the 'after' display list over the whole area of interest.
80486:   nsDisplayListBuilder builder(aRootFrame, nsDisplayListBuilder::OTHER, true);
47742:   builder.EnterPresShell(aRootFrame, aUpdateRect);
47742:   nsDisplayList list;
47742:   nsresult rv =
47742:     aRootFrame->BuildDisplayListForStackingContext(&builder, aUpdateRect, &list);
47742:   builder.LeavePresShell(aRootFrame, aUpdateRect);
47742:   if (NS_FAILED(rv))
47742:     return;
47742: 
47742:   nsRegion visibleRegion(aUpdateRect);
51633:   list.ComputeVisibilityForRoot(&builder, &visibleRegion);
47742: 
50392:   InvalidateFixedBackgroundFramesFromList(&builder, aMovingFrame, list);
47776:   list.DeleteAll();
47742: }
47742: 
79445: bool nsGfxScrollFrameInner::IsAlwaysActive() const
47750: {
47750:   // The root scrollframe for a non-chrome document which is the direct
47750:   // child of a chrome document is always treated as "active".
47751:   // XXX maybe we should extend this so that IFRAMEs which are fill the
47751:   // entire viewport (like GMail!) are always active
52488:   return mIsRoot && mOuter->PresContext()->IsRootContentDocument();
47750: }
47750: 
59828: void nsGfxScrollFrameInner::MarkInactive()
59828: {
59828:   if (IsAlwaysActive() || !mScrollingActive)
59828:     return;
59828: 
80486:   mScrollingActive = false;
59828:   mOuter->InvalidateFrameSubtree();
59828: }
59828: 
47750: void nsGfxScrollFrameInner::MarkActive()
47750: {
47750:   if (IsAlwaysActive())
47750:     return;
47750: 
80486:   mScrollingActive = true;
47750:   if (mActivityExpirationState.IsTracked()) {
47750:     gScrollFrameActivityTracker->MarkUsed(this);
47750:   } else {
47750:     if (!gScrollFrameActivityTracker) {
47750:       gScrollFrameActivityTracker = new ScrollFrameActivityTracker();
47750:     }
47750:     gScrollFrameActivityTracker->AddObject(this);
47750:   }
47750: }
47750: 
55829: void nsGfxScrollFrameInner::ScrollVisual()
37083: {
47756:   nsRootPresContext* rootPresContext = mOuter->PresContext()->GetRootPresContext();
37502:   if (!rootPresContext) {
37502:     return;
37502:   }
37083: 
47756:   rootPresContext->RequestUpdatePluginGeometry(mOuter);
47756: 
55828:   AdjustViews(mScrolledFrame);
55828:   // We need to call this after fixing up the view positions
55828:   // to be consistent with the frame hierarchy.
47742:   PRUint32 flags = nsIFrame::INVALIDATE_REASON_SCROLL_REPAINT;
79445:   bool canScrollWithBlitting = CanScrollWithBlitting(mOuter);
80691:   mOuter->RemoveStateBits(NS_SCROLLFRAME_INVALIDATE_CONTENTS_ON_SCROLL);
59828:   if (IsScrollingActive()) {
59828:     if (!canScrollWithBlitting) {
59828:       MarkInactive();
59828:     } else {
47742:       flags |= nsIFrame::INVALIDATE_NO_THEBES_LAYERS;
47742:     }
59828:   }
59828:   if (canScrollWithBlitting) {
47750:     MarkActive();
59828:   }
63414: 
63414:   nsRect invalidateRect, displayport;
63414:   invalidateRect =
63414:     (nsLayoutUtils::GetDisplayPort(mOuter->GetContent(), &displayport)) ?
63414:     displayport : mScrollPort;
63414: 
63414:   mOuter->InvalidateWithFlags(invalidateRect, flags);
47742: 
47742:   if (flags & nsIFrame::INVALIDATE_NO_THEBES_LAYERS) {
59827:     nsIFrame* displayRoot = nsLayoutUtils::GetDisplayRootFrame(mOuter);
49161:     nsRect update =
49161:       GetScrollPortRect() + mOuter->GetOffsetToCrossDoc(displayRoot);
49161:     update = update.ConvertAppUnitsRoundOut(
49161:       mOuter->PresContext()->AppUnitsPerDevPixel(),
49161:       displayRoot->PresContext()->AppUnitsPerDevPixel());
49161:     InvalidateFixedBackgroundFrames(displayRoot, mScrolledFrame, update);
37083:   }
37083: }
37083: 
37083: static PRInt32
37083: ClampInt(nscoord aLower, nscoord aVal, nscoord aUpper, nscoord aAppUnitsPerPixel)
37083: {
37083:   PRInt32 low = NSToIntCeil(float(aLower)/aAppUnitsPerPixel);
37083:   PRInt32 high = NSToIntFloor(float(aUpper)/aAppUnitsPerPixel);
37083:   PRInt32 v = NSToIntRound(float(aVal)/aAppUnitsPerPixel);
37083:   NS_ASSERTION(low <= high, "No integers in range; 0 is supposed to be in range");
37083:   if (v < low)
37083:     return low;
37083:   if (v > high)
37083:     return high;
37083:   return v;
37083: }
37083: 
37083: nsPoint
37083: nsGfxScrollFrameInner::ClampAndRestrictToDevPixels(const nsPoint& aPt,
37083:                                                    nsIntPoint* aPtDevPx) const
37083: {
37083:   nsPresContext* presContext = mOuter->PresContext();
37083:   nscoord appUnitsPerDevPixel = presContext->AppUnitsPerDevPixel();
37083:   // Convert to device pixels so we scroll to an integer offset of device
37083:   // pixels. But we also need to make sure that our position remains
37083:   // inside the allowed region.
37083:   nsRect scrollRange = GetScrollRange();
37083:   *aPtDevPx = nsIntPoint(ClampInt(scrollRange.x, aPt.x, scrollRange.XMost(), appUnitsPerDevPixel),
37083:                          ClampInt(scrollRange.y, aPt.y, scrollRange.YMost(), appUnitsPerDevPixel));
37083:   return nsPoint(NSIntPixelsToAppUnits(aPtDevPx->x, appUnitsPerDevPixel),
37083:                  NSIntPixelsToAppUnits(aPtDevPx->y, appUnitsPerDevPixel));
37083: }
37083: 
37083: void
37083: nsGfxScrollFrameInner::ScrollToImpl(nsPoint aPt)
37083: {
37083:   nsPresContext* presContext = mOuter->PresContext();
37083:   nscoord appUnitsPerDevPixel = presContext->AppUnitsPerDevPixel();
37083:   nsIntPoint ptDevPx;
37083:   nsPoint pt = ClampAndRestrictToDevPixels(aPt, &ptDevPx);
37083: 
37083:   nsPoint curPos = GetScrollPosition();
37083:   if (pt == curPos) {
37083:     return;
37083:   }
37083:   nsIntPoint curPosDevPx(NSAppUnitsToIntPixels(curPos.x, appUnitsPerDevPixel),
37083:                          NSAppUnitsToIntPixels(curPos.y, appUnitsPerDevPixel));
37083:   // We maintain the invariant that the scroll position is a multiple of device
37083:   // pixels.
37083:   NS_ASSERTION(curPosDevPx.x*appUnitsPerDevPixel == curPos.x,
37083:                "curPos.x not a multiple of device pixels");
37083:   NS_ASSERTION(curPosDevPx.y*appUnitsPerDevPixel == curPos.y,
37083:                "curPos.y not a multiple of device pixels");
37083: 
37083:   // notify the listeners.
41748:   for (PRUint32 i = 0; i < mListeners.Length(); i++) {
37083:     mListeners[i]->ScrollPositionWillChange(pt.x, pt.y);
37083:   }
37083:   
37083:   // Update frame position for scrolling
37083:   mScrolledFrame->SetPosition(mScrollPort.TopLeft() - pt);
37083: 
37083:   // We pass in the amount to move visually
55829:   ScrollVisual();
37083: 
80486:   presContext->PresShell()->SynthesizeMouseMove(true);
37083:   UpdateScrollbarPosition();
37083:   PostScrollEvent();
37083: 
37083:   // notify the listeners.
41748:   for (PRUint32 i = 0; i < mListeners.Length(); i++) {
37083:     mListeners[i]->ScrollPositionDidChange(pt.x, pt.y);
37083:   }
37083: }
    1: 
47744: static void
47744: AppendToTop(nsDisplayListBuilder* aBuilder, nsDisplayList* aDest,
79445:             nsDisplayList* aSource, nsIFrame* aSourceFrame, bool aOwnLayer)
47744: {
71077:   if (aSource->IsEmpty())
71077:     return;
47744:   if (aOwnLayer) {
51260:     aDest->AppendNewToTop(
51260:         new (aBuilder) nsDisplayOwnLayer(aBuilder, aSourceFrame, aSource));
47744:   } else {
47744:     aDest->AppendToTop(aSource);
47744:   }  
47744: }
47744: 
    1: nsresult
56302: nsGfxScrollFrameInner::AppendScrollPartsTo(nsDisplayListBuilder*          aBuilder,
56302:                                            const nsRect&                  aDirtyRect,
56302:                                            const nsDisplayListSet&        aLists,
56302:                                            const nsDisplayListCollection& aDest,
79445:                                            bool&                        aCreateLayer)
56302: {
56302:   nsresult rv = NS_OK;
79445:   bool hasResizer = HasResizer();
77154:   for (nsIFrame* kid = mOuter->GetFirstPrincipalChild(); kid; kid = kid->GetNextSibling()) {
56302:     if (kid != mScrolledFrame) {
60693:       if (kid == mResizerBox && hasResizer) {
56302:         // skip the resizer as this will be drawn later on top of the scrolled content
56302:         continue;
56302:       }
56302:       rv = mOuter->BuildDisplayListForChild(aBuilder, kid, aDirtyRect, aDest,
56302:                                             nsIFrame::DISPLAY_CHILD_FORCE_STACKING_CONTEXT);
56302:       NS_ENSURE_SUCCESS(rv, rv);
56302:       // DISPLAY_CHILD_FORCE_STACKING_CONTEXT put everything into the
56302:       // PositionedDescendants list.
56302:       ::AppendToTop(aBuilder, aLists.BorderBackground(),
56302:                     aDest.PositionedDescendants(), kid,
56302:                     aCreateLayer);
56302:     }
56302:   }
56302:   return rv;
56302: }
56302: 
79445: bool
63414: nsGfxScrollFrameInner::ShouldBuildLayer() const
63414: {
63414:   return mShouldBuildLayer;
63414: }
63414: 
69189: class ScrollLayerWrapper : public nsDisplayWrapper
69189: {
69189: public:
69189:   ScrollLayerWrapper(nsIFrame* aScrollFrame, nsIFrame* aScrolledFrame)
69189:     : mCount(0)
69189:     , mProps(aScrolledFrame->Properties())
69189:     , mScrollFrame(aScrollFrame)
69189:     , mScrolledFrame(aScrolledFrame)
69189:   {
69189:     SetCount(0);
69189:   }
69189: 
69189:   virtual nsDisplayItem* WrapList(nsDisplayListBuilder* aBuilder,
69189:                                   nsIFrame* aFrame,
69189:                                   nsDisplayList* aList) {
69189:     SetCount(++mCount);
69190:     return new (aBuilder) nsDisplayScrollLayer(aBuilder, aList, mScrolledFrame, mScrolledFrame, mScrollFrame);
69189:   }
69189: 
69189:   virtual nsDisplayItem* WrapItem(nsDisplayListBuilder* aBuilder,
69189:                                   nsDisplayItem* aItem) {
69189: 
69189:     SetCount(++mCount);
69189:     return new (aBuilder) nsDisplayScrollLayer(aBuilder, aItem, aItem->GetUnderlyingFrame(), mScrolledFrame, mScrollFrame);
69189:   }
69189: 
69189: protected:
69189:   void SetCount(PRWord aCount) {
69189:     mProps.Set(nsIFrame::ScrollLayerCount(), reinterpret_cast<void*>(aCount));
69189:   }
69189: 
69189:   PRWord mCount;
69189:   FrameProperties mProps;
69189:   nsIFrame* mScrollFrame;
69189:   nsIFrame* mScrolledFrame;
69189: };
69189: 
56302: nsresult
    1: nsGfxScrollFrameInner::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                         const nsRect&           aDirtyRect,
    1:                                         const nsDisplayListSet& aLists)
    1: {
    1:   nsresult rv = mOuter->DisplayBorderBackgroundOutline(aBuilder, aLists);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
47742:   if (aBuilder->IsPaintingToWindow()) {
47742:     mScrollPosAtLastPaint = GetScrollPosition();
59828:     if (IsScrollingActive() && !CanScrollWithBlitting(mOuter)) {
59828:       MarkInactive();
59828:     }
47742:   }
47742: 
    1:   if (aBuilder->GetIgnoreScrollFrame() == mOuter) {
    1:     // Don't clip the scrolled child, and don't paint scrollbars/scrollcorner.
    1:     // The scrolled frame shouldn't have its own background/border, so we
26699:     // can just pass aLists directly.
26699:     return mOuter->BuildDisplayListForChild(aBuilder, mScrolledFrame,
26699:                                             aDirtyRect, aLists);
    1:   }
    1: 
47744:   // We put scrollbars in their own layers when this is the root scroll
47744:   // frame and we are a toplevel content document. In this situation, the
47744:   // scrollbar(s) would normally be assigned their own layer anyway, since
47744:   // they're not scrolled with the rest of the document. But when both
47744:   // scrollbars are visible, the layer's visible rectangle would be the size
47744:   // of the viewport, so most layer implementations would create a layer buffer
47744:   // that's much larger than necessary. Creating independent layers for each
47744:   // scrollbar works around the problem.
79445:   bool createLayersForScrollbars = mIsRoot &&
52488:     mOuter->PresContext()->IsRootContentDocument();
56302: 
56302:   nsDisplayListCollection scrollParts;
56302:   if (!mScrollbarsCanOverlapContent) {
56302:     // Now display the scrollbars and scrollcorner. These parts are drawn
56302:     // in the border-background layer, on top of our own background and
56302:     // borders and underneath borders and backgrounds of later elements
56302:     // in the tree.
56302:     AppendScrollPartsTo(aBuilder, aDirtyRect, aLists,
56302:                         scrollParts, createLayersForScrollbars);
56302:   }
25539: 
    1:   // Overflow clipping can never clip frames outside our subtree, so there
    1:   // is no need to worry about whether we are a moving frame that might clip
    1:   // non-moving frames.
    1:   nsRect dirtyRect;
    1:   // Not all our descendants will be clipped by overflow clipping, but all
    1:   // the ones that aren't clipped will be out of flow frames that have already
    1:   // had dirty rects saved for them by their parent frames calling
    1:   // MarkOutOfFlowChildrenForDisplayList, so it's safe to restrict our
    1:   // dirty rect here.
63413:   dirtyRect.IntersectRect(aDirtyRect, mScrollPort);
63413: 
63414:   // Override the dirty rectangle if the displayport has been set.
79445:   bool usingDisplayport =
63414:     nsLayoutUtils::GetDisplayPort(mOuter->GetContent(), &dirtyRect);
    1: 
    1:   nsDisplayListCollection set;
69189:   rv = mOuter->BuildDisplayListForChild(aBuilder, mScrolledFrame, dirtyRect, set);
69189:   NS_ENSURE_SUCCESS(rv, rv);
63413: 
63413:   // Since making new layers is expensive, only use nsDisplayScrollLayer
63413:   // if the area is scrollable.
63413:   nsRect scrollRange = GetScrollRange();
63426:   ScrollbarStyles styles = GetScrollbarStylesFromFrame();
63414:   mShouldBuildLayer =
63413:      (XRE_GetProcessType() == GeckoProcessType_Content &&
63426:      (styles.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN ||
63426:       styles.mVertical != NS_STYLE_OVERFLOW_HIDDEN) &&
68416:      (scrollRange.width > 0 ||
68416:       scrollRange.height > 0) &&
67860:      (!mIsRoot || !mOuter->PresContext()->IsRootContentDocument()));
63413: 
63414:   if (ShouldBuildLayer()) {
69189:     // ScrollLayerWrapper must always be created because it initializes the
69189:     // scroll layer count. The display lists depend on this.
69189:     ScrollLayerWrapper wrapper(mOuter, mScrolledFrame);
69189: 
67860:     if (usingDisplayport) {
67860:       // Once a displayport is set, assume that scrolling needs to be fast
67860:       // so create a layer with all the content inside. The compositor
67860:       // process will be able to scroll the content asynchronously.
69189:       wrapper.WrapListsInPlace(aBuilder, mOuter, set);
69189:     }
69189: 
69189:     // In case we are not using displayport or the nsDisplayScrollLayers are
69189:     // flattened during visibility computation, we still need to export the
69189:     // metadata about this scroll box to the compositor process.
69189:     nsDisplayScrollInfoLayer* layerItem = new (aBuilder) nsDisplayScrollInfoLayer(
69189:       aBuilder, mScrolledFrame, mOuter);
71819:     set.BorderBackground()->AppendNewToBottom(layerItem);
69189:   }
69189: 
60447:   nsRect clip;
63413:   clip = mScrollPort + aBuilder->ToReferenceFrame(mOuter);
60447: 
52293:   nscoord radii[8];
52293:   // Our override of GetBorderRadii ensures we never have a radius at
52293:   // the corners where we have a scrollbar.
52293:   mOuter->GetPaddingBoxBorderRadii(radii);
63413: 
    1:   // mScrolledFrame may have given us a background, e.g., the scrolled canvas
    1:   // frame below the viewport. If so, we want it to be clipped. We also want
    1:   // to end up on our BorderBackground list.
    1:   // If we are the viewport scrollframe, then clip all our descendants (to ensure
    1:   // that fixed-pos elements get clipped by us).
52293:   rv = mOuter->OverflowClip(aBuilder, set, aLists, clip, radii,
80486:                             true, mIsRoot);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
56302:   if (mScrollbarsCanOverlapContent) {
56302:     AppendScrollPartsTo(aBuilder, aDirtyRect, aLists,
56302:                        scrollParts, createLayersForScrollbars);
56302:   }
56302: 
62312:   if (HasResizer()) {
60693:     rv = mOuter->BuildDisplayListForChild(aBuilder, mResizerBox, aDirtyRect, scrollParts,
46324:                                           nsIFrame::DISPLAY_CHILD_FORCE_STACKING_CONTEXT);
39640:     NS_ENSURE_SUCCESS(rv, rv);
46324:     // DISPLAY_CHILD_FORCE_STACKING_CONTEXT puts everything into the
46324:     // PositionedDescendants list.
62312:     // The resizer is positioned and has maximum z-index; we put it in
62312:     // PositionedDescendants() for the root frame to ensure that it appears
62312:     // above all content, bug 631337.
62312:     ::AppendToTop(aBuilder,
62312:                   mIsRoot ? aLists.PositionedDescendants() : aLists.Content(),
60693:                   scrollParts.PositionedDescendants(), mResizerBox,
47744:                   createLayersForScrollbars);
39640:   }
39640: 
    1:   return NS_OK;
    1: }
    1: 
    1: static void HandleScrollPref(nsIScrollable *aScrollable, PRInt32 aOrientation,
    1:                              PRUint8& aValue)
    1: {
    1:   PRInt32 pref;
    1:   aScrollable->GetDefaultScrollbarPreferences(aOrientation, &pref);
    1:   switch (pref) {
    1:     case nsIScrollable::Scrollbar_Auto:
    1:       // leave |aValue| untouched
    1:       break;
    1:     case nsIScrollable::Scrollbar_Never:
    1:       aValue = NS_STYLE_OVERFLOW_HIDDEN;
    1:       break;
    1:     case nsIScrollable::Scrollbar_Always:
    1:       aValue = NS_STYLE_OVERFLOW_SCROLL;
    1:       break;
    1:   }
    1: }
    1: 
    1: nsGfxScrollFrameInner::ScrollbarStyles
    1: nsGfxScrollFrameInner::GetScrollbarStylesFromFrame() const
    1: {
    1:   ScrollbarStyles result;
    1: 
  238:   nsPresContext* presContext = mOuter->PresContext();
    1:   if (!presContext->IsDynamic() &&
    1:       !(mIsRoot && presContext->HasPaginatedScrolling())) {
    1:     return ScrollbarStyles(NS_STYLE_OVERFLOW_HIDDEN, NS_STYLE_OVERFLOW_HIDDEN);
    1:   }
    1: 
    1:   if (mIsRoot) {
    1:     result = presContext->GetViewportOverflowOverride();
    1: 
    1:     nsCOMPtr<nsISupports> container = presContext->GetContainer();
    1:     nsCOMPtr<nsIScrollable> scrollable = do_QueryInterface(container);
    1:     if (scrollable) {
    1:       HandleScrollPref(scrollable, nsIScrollable::ScrollOrientation_X,
    1:                        result.mHorizontal);
    1:       HandleScrollPref(scrollable, nsIScrollable::ScrollOrientation_Y,
    1:                        result.mVertical);
63442:       // XXX EVIL COMPILER BUG BE CAREFUL WHEN CHANGING
63442:       //     There is a bug in the Android compiler :(
63442:       //     It seems that the compiler optimizes something out and uses
63442:       //     a bad value for result if we don't directly return here.
63442:       return result;
    1:     }
    1:   } else {
    1:     const nsStyleDisplay *disp = mOuter->GetStyleDisplay();
    1:     result.mHorizontal = disp->mOverflowX;
    1:     result.mVertical = disp->mOverflowY;
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
37055: static nscoord
37055: AlignToDevPixelRoundingToZero(nscoord aVal, PRInt32 aAppUnitsPerDevPixel)
37055: {
37055:   return (aVal/aAppUnitsPerDevPixel)*aAppUnitsPerDevPixel;
37055: }
37055: 
37055: nsRect
37055: nsGfxScrollFrameInner::GetScrollRange() const
37055: {
37083:   nsRect range = GetScrolledRect();
37083:   range.width -= mScrollPort.width;
37083:   range.height -= mScrollPort.height;
37055: 
37055:   nsPresContext* presContext = mOuter->PresContext();
37055:   PRInt32 appUnitsPerDevPixel = presContext->AppUnitsPerDevPixel();
37055:   range.width =
37055:     AlignToDevPixelRoundingToZero(range.XMost(), appUnitsPerDevPixel) - range.x;
37055:   range.height =
37055:     AlignToDevPixelRoundingToZero(range.YMost(), appUnitsPerDevPixel) - range.y;
37055:   range.x = AlignToDevPixelRoundingToZero(range.x, appUnitsPerDevPixel);
37055:   range.y = AlignToDevPixelRoundingToZero(range.y, appUnitsPerDevPixel);
37055:   return range;
37055: }
37055: 
37055: static void
37055: AdjustForWholeDelta(PRInt32 aDelta, nscoord* aCoord)
37055: {
37055:   if (aDelta < 0) {
37055:     *aCoord = nscoord_MIN;
37055:   } else if (aDelta > 0) {
37055:     *aCoord = nscoord_MAX;
37055:   }
37055: }
37055: 
37055: void
37055: nsGfxScrollFrameInner::ScrollBy(nsIntPoint aDelta,
37055:                                 nsIScrollableFrame::ScrollUnit aUnit,
37055:                                 nsIScrollableFrame::ScrollMode aMode,
37055:                                 nsIntPoint* aOverflow)
37055: {
37083:   nsSize deltaMultiplier;
37055:   switch (aUnit) {
37055:   case nsIScrollableFrame::DEVICE_PIXELS: {
37083:     nscoord appUnitsPerDevPixel =
37083:       mOuter->PresContext()->AppUnitsPerDevPixel();
37083:     deltaMultiplier = nsSize(appUnitsPerDevPixel, appUnitsPerDevPixel);
37055:     break;
37055:   }
37055:   case nsIScrollableFrame::LINES: {
37083:     deltaMultiplier = GetLineScrollAmount();
37055:     break;
37055:   }
37055:   case nsIScrollableFrame::PAGES: {
37083:     deltaMultiplier = GetPageScrollAmount();
37055:     break;
37055:   }
37055:   case nsIScrollableFrame::WHOLE: {
37055:     nsPoint pos = GetScrollPosition();
37055:     AdjustForWholeDelta(aDelta.x, &pos.x);
37055:     AdjustForWholeDelta(aDelta.y, &pos.y);
37055:     ScrollTo(pos, aMode);
37055:     if (aOverflow) {
37083:       *aOverflow = nsIntPoint(0, 0);
37083:     }
37083:     return;
37083:   }
37083:   default:
37083:     NS_ERROR("Invalid scroll mode");
37083:     return;
37083:   }
37083: 
37083:   nsPoint newPos = mDestination +
37083:     nsPoint(aDelta.x*deltaMultiplier.width, aDelta.y*deltaMultiplier.height);
37083:   ScrollTo(newPos, aMode);
37083: 
37083:   if (aOverflow) {
37083:     nsPoint clampAmount = mDestination - newPos;
37083:     float appUnitsPerDevPixel = mOuter->PresContext()->AppUnitsPerDevPixel();
37083:     *aOverflow = nsIntPoint(
72496:         NSAppUnitsToIntPixels(NS_ABS(clampAmount.x), appUnitsPerDevPixel),
72496:         NSAppUnitsToIntPixels(NS_ABS(clampAmount.y), appUnitsPerDevPixel));
37055:   }
37055: }
37055: 
37055: nsSize
37055: nsGfxScrollFrameInner::GetLineScrollAmount() const
37055: {
76294:   nsRefPtr<nsFontMetrics> fm;
76294:   nsLayoutUtils::GetFontMetricsForFrame(mOuter, getter_AddRefs(fm));
37083:   NS_ASSERTION(fm, "FontMetrics is null, assuming fontHeight == 1 appunit");
37083:   nscoord fontHeight = 1;
37083:   if (fm) {
68495:     fontHeight = fm->MaxHeight();
37083:   }
37083: 
37083:   return nsSize(fontHeight, fontHeight);
37055: }
37055: 
37055: nsSize
37055: nsGfxScrollFrameInner::GetPageScrollAmount() const
37055: {
37083:   nsSize lineScrollAmount = GetLineScrollAmount();
37083:   // The page increment is the size of the page, minus the smaller of
37083:   // 10% of the size or 2 lines.
37083:   return nsSize(
37083:     mScrollPort.width - NS_MIN(mScrollPort.width/10, 2*lineScrollAmount.width),
37083:     mScrollPort.height - NS_MIN(mScrollPort.height/10, 2*lineScrollAmount.height));
37055: }
37055: 
    1:   /**
    1:    * this code is resposible for restoring the scroll position back to some
    1:    * saved position. if the user has not moved the scroll position manually
    1:    * we keep scrolling down until we get to our original position. keep in
    1:    * mind that content could incrementally be coming in. we only want to stop
    1:    * when we reach our new position.
    1:    */
    1: void
    1: nsGfxScrollFrameInner::ScrollToRestoredPosition()
    1: {
37083:   if (mRestorePos.y == -1 || mLastPos.x == -1 || mLastPos.y == -1) {
    1:     return;
    1:   }
    1:   // make sure our scroll position did not change for where we last put
    1:   // it. if it does then the user must have moved it, and we no longer
    1:   // need to restore.
62087:   //
62087:   // In the RTL case, we check whether the scroll position changed using the
62087:   // logical scroll position, but we scroll to the physical scroll position in
62087:   // all cases
    1: 
    1:   // if we didn't move, we still need to restore
62087:   if (GetLogicalScrollPosition() == mLastPos) {
37083:     // if our desired position is different to the scroll position, scroll.
    1:     // remember that we could be incrementally loading so we may enter
    1:     // and scroll many times.
64063:     if (mRestorePos != mLastPos /* GetLogicalScrollPosition() */) {
64063:       nsPoint scrollToPos = mRestorePos;
64063:       if (!IsLTR())
64063:         // convert from logical to physical scroll position
64063:         scrollToPos.x = mScrollPort.x - 
64063:           (mScrollPort.XMost() - scrollToPos.x - mScrolledFrame->GetRect().width);
64063:       ScrollTo(scrollToPos, nsIScrollableFrame::INSTANT);
37083:       // Re-get the scroll position, it might not be exactly equal to
37083:       // mRestorePos due to rounding and clamping.
62087:       mLastPos = GetLogicalScrollPosition();
    1:     } else {
    1:       // if we reached the position then stop
37083:       mRestorePos.y = -1;
    1:       mLastPos.x = -1;
    1:       mLastPos.y = -1;
    1:     }
    1:   } else {
    1:     // user moved the position, so we won't need to restore
    1:     mLastPos.x = -1;
    1:     mLastPos.y = -1;
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsGfxScrollFrameInner::FireScrollPortEvent()
    1: {
    1:   mAsyncScrollPortEvent.Forget();
 6722: 
 6722:   // Keep this in sync with PostOverflowEvent().
37083:   nsSize scrollportSize = mScrollPort.Size();
37083:   nsSize childSize = GetScrolledRect().Size();
    1: 
79445:   bool newVerticalOverflow = childSize.height > scrollportSize.height;
79445:   bool vertChanged = mVerticalOverflow != newVerticalOverflow;
79445: 
79445:   bool newHorizontalOverflow = childSize.width > scrollportSize.width;
79445:   bool horizChanged = mHorizontalOverflow != newHorizontalOverflow;
    1: 
    1:   if (!vertChanged && !horizChanged) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // If both either overflowed or underflowed then we dispatch only one
    1:   // DOM event.
79445:   bool both = vertChanged && horizChanged &&
    1:                 newVerticalOverflow == newHorizontalOverflow;
    1:   nsScrollPortEvent::orientType orient;
    1:   if (both) {
    1:     orient = nsScrollPortEvent::both;
    1:     mHorizontalOverflow = newHorizontalOverflow;
    1:     mVerticalOverflow = newVerticalOverflow;
    1:   }
    1:   else if (vertChanged) {
    1:     orient = nsScrollPortEvent::vertical;
    1:     mVerticalOverflow = newVerticalOverflow;
    1:     if (horizChanged) {
    1:       // We need to dispatch a separate horizontal DOM event. Do that the next
    1:       // time around since dispatching the vertical DOM event might destroy
    1:       // the frame.
    1:       PostOverflowEvent();
    1:     }
    1:   }
    1:   else {
    1:     orient = nsScrollPortEvent::horizontal;
    1:     mHorizontalOverflow = newHorizontalOverflow;
    1:   }
    1: 
80486:   nsScrollPortEvent event(true,
    1:                           (orient == nsScrollPortEvent::horizontal ?
    1:                            mHorizontalOverflow : mVerticalOverflow) ?
    1:                             NS_SCROLLPORT_OVERFLOW : NS_SCROLLPORT_UNDERFLOW,
    1:                           nsnull);
    1:   event.orient = orient;
    1:   return nsEventDispatcher::Dispatch(mOuter->GetContent(),
  238:                                      mOuter->PresContext(), &event);
    1: }
    1: 
    1: void
    1: nsGfxScrollFrameInner::ReloadChildFrames()
    1: {
    1:   mScrolledFrame = nsnull;
    1:   mHScrollbarBox = nsnull;
    1:   mVScrollbarBox = nsnull;
    1:   mScrollCornerBox = nsnull;
60693:   mResizerBox = nsnull;
    1: 
77154:   nsIFrame* frame = mOuter->GetFirstPrincipalChild();
    1:   while (frame) {
    1:     nsIContent* content = frame->GetContent();
    1:     if (content == mOuter->GetContent()) {
    1:       NS_ASSERTION(!mScrolledFrame, "Already found the scrolled frame");
    1:       mScrolledFrame = frame;
    1:     } else {
    1:       nsAutoString value;
    1:       content->GetAttr(kNameSpaceID_None, nsGkAtoms::orient, value);
    1:       if (!value.IsEmpty()) {
    1:         // probably a scrollbar then
    1:         if (value.LowerCaseEqualsLiteral("horizontal")) {
    1:           NS_ASSERTION(!mHScrollbarBox, "Found multiple horizontal scrollbars?");
    1:           mHScrollbarBox = frame;
    1:         } else {
    1:           NS_ASSERTION(!mVScrollbarBox, "Found multiple vertical scrollbars?");
    1:           mVScrollbarBox = frame;
    1:         }
60693:       } else if (content->Tag() == nsGkAtoms::resizer) {
60693:         NS_ASSERTION(!mResizerBox, "Found multiple resizers");
60693:         mResizerBox = frame;
    1:       } else {
    1:         // probably a scrollcorner
    1:         NS_ASSERTION(!mScrollCornerBox, "Found multiple scrollcorners");
    1:         mScrollCornerBox = frame;
    1:       }
    1:     }
    1: 
    1:     frame = frame->GetNextSibling();
    1:   }
    1: }
    1:   
    1: nsresult
69438: nsGfxScrollFrameInner::CreateAnonymousContent(
69438:   nsTArray<nsIAnonymousContentCreator::ContentInfo>& aElements)
    1: {
  238:   nsPresContext* presContext = mOuter->PresContext();
    1:   nsIFrame* parent = mOuter->GetParent();
    1: 
57902:   // Don't create scrollbars if we're an SVG document being used as an image,
57902:   // or if we're printing/print previewing.
57902:   // (In the printing case, we allow scrollbars if this is the child of the
57902:   // viewport & paginated scrolling is enabled, because then we must be the
57902:   // scroll frame for the print preview window, & that does need scrollbars.)
57902:   if (presContext->Document()->IsBeingUsedAsImage() ||
57902:       (!presContext->IsDynamic() &&
57902:        !(mIsRoot && presContext->HasPaginatedScrolling()))) {
80486:     mNeverHasVerticalScrollbar = mNeverHasHorizontalScrollbar = true;
    1:     return NS_OK;
    1:   }
    1: 
39640:   // Check if the frame is resizable.
39744:   PRInt8 resizeStyle = mOuter->GetStyleDisplay()->mResize;
79445:   bool isResizable = resizeStyle != NS_STYLE_RESIZE_NONE;
39640: 
23554:   nsIScrollableFrame *scrollable = do_QueryFrame(mOuter);
    1: 
39758:   // If we're the scrollframe for the root, then we want to construct
39758:   // our scrollbar frames no matter what.  That way later dynamic
39758:   // changes to propagated overflow styles will show or hide
39758:   // scrollbars on the viewport without requiring frame reconstruction
39758:   // of the viewport (good!).
79445:   bool canHaveHorizontal;
79445:   bool canHaveVertical;
40502:   if (!mIsRoot) {
    1:     ScrollbarStyles styles = scrollable->GetScrollbarStyles();
39758:     canHaveHorizontal = styles.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN;
39758:     canHaveVertical = styles.mVertical != NS_STYLE_OVERFLOW_HIDDEN;
39640:     if (!canHaveHorizontal && !canHaveVertical && !isResizable) {
    1:       // Nothing to do.
    1:       return NS_OK;
    1:     }
39758:   } else {
80486:     canHaveHorizontal = true;
80486:     canHaveVertical = true;
39758:   }
    1: 
    1:   // The anonymous <div> used by <inputs> never gets scrollbars.
23554:   nsITextControlFrame* textFrame = do_QueryFrame(parent);
    1:   if (textFrame) {
    1:     // Make sure we are not a text area.
    1:     nsCOMPtr<nsIDOMHTMLTextAreaElement> textAreaElement(do_QueryInterface(parent->GetContent()));
    1:     if (!textAreaElement) {
80486:       mNeverHasVerticalScrollbar = mNeverHasHorizontalScrollbar = true;
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   nsNodeInfoManager *nodeInfoManager =
    1:     presContext->Document()->NodeInfoManager();
    1:   nsCOMPtr<nsINodeInfo> nodeInfo;
19197:   nodeInfo = nodeInfoManager->GetNodeInfo(nsGkAtoms::scrollbar, nsnull,
71746:                                           kNameSpaceID_XUL,
71746:                                           nsIDOMNode::ELEMENT_NODE);
19747:   NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   if (canHaveHorizontal) {
48124:     nsCOMPtr<nsINodeInfo> ni = nodeInfo;
51393:     NS_TrustedNewXULElement(getter_AddRefs(mHScrollbarContent), ni.forget());
    1:     mHScrollbarContent->SetAttr(kNameSpaceID_None, nsGkAtoms::orient,
80486:                                 NS_LITERAL_STRING("horizontal"), false);
47797:     mHScrollbarContent->SetAttr(kNameSpaceID_None, nsGkAtoms::clickthrough,
80486:                                 NS_LITERAL_STRING("always"), false);
    1:     if (!aElements.AppendElement(mHScrollbarContent))
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   if (canHaveVertical) {
48124:     nsCOMPtr<nsINodeInfo> ni = nodeInfo;
51393:     NS_TrustedNewXULElement(getter_AddRefs(mVScrollbarContent), ni.forget());
    1:     mVScrollbarContent->SetAttr(kNameSpaceID_None, nsGkAtoms::orient,
80486:                                 NS_LITERAL_STRING("vertical"), false);
47797:     mVScrollbarContent->SetAttr(kNameSpaceID_None, nsGkAtoms::clickthrough,
80486:                                 NS_LITERAL_STRING("always"), false);
    1:     if (!aElements.AppendElement(mVScrollbarContent))
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
39640:   if (isResizable) {
39640:     nsCOMPtr<nsINodeInfo> nodeInfo;
39640:     nodeInfo = nodeInfoManager->GetNodeInfo(nsGkAtoms::resizer, nsnull,
71746:                                             kNameSpaceID_XUL,
71746:                                             nsIDOMNode::ELEMENT_NODE);
39640:     NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
39640: 
60693:     NS_TrustedNewXULElement(getter_AddRefs(mResizerContent), nodeInfo.forget());
39640: 
39640:     nsAutoString dir;
39744:     switch (resizeStyle) {
39640:       case NS_STYLE_RESIZE_HORIZONTAL:
39640:         if (IsScrollbarOnRight()) {
39640:           dir.AssignLiteral("right");
39640:         }
39640:         else {
39640:           dir.AssignLiteral("left");
39640:         }
39640:         break;
39640:       case NS_STYLE_RESIZE_VERTICAL:
39640:         dir.AssignLiteral("bottom");
39640:         break;
39640:       case NS_STYLE_RESIZE_BOTH:
39640:         dir.AssignLiteral("bottomend");
39640:         break;
39640:       default:
39640:         NS_WARNING("only resizable types should have resizers");
39640:     }
80486:     mResizerContent->SetAttr(kNameSpaceID_None, nsGkAtoms::dir, dir, false);
60693: 
60693:     if (mIsRoot) {
60693:       nsIContent* browserRoot = GetBrowserRoot(mOuter->GetContent());
60693:       mCollapsedResizer = !(browserRoot &&
60693:                             browserRoot->HasAttr(kNameSpaceID_None, nsGkAtoms::showresizer));
60693:     }
60693:     else {
60693:       mResizerContent->SetAttr(kNameSpaceID_None, nsGkAtoms::element,
80486:                                     NS_LITERAL_STRING("_parent"), false);
60693:     }
60693: 
60693:     mResizerContent->SetAttr(kNameSpaceID_None, nsGkAtoms::clickthrough,
80486:                                   NS_LITERAL_STRING("always"), false);
39640: 
60693:     if (!aElements.AppendElement(mResizerContent))
39640:       return NS_ERROR_OUT_OF_MEMORY;
39640:   }
60693: 
60693:   if (canHaveHorizontal && canHaveVertical) {
19197:     nodeInfo = nodeInfoManager->GetNodeInfo(nsGkAtoms::scrollcorner, nsnull,
71746:                                             kNameSpaceID_XUL,
71746:                                             nsIDOMNode::ELEMENT_NODE);
51393:     NS_TrustedNewXULElement(getter_AddRefs(mScrollCornerContent), nodeInfo.forget());
    1:     if (!aElements.AppendElement(mScrollCornerContent))
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
55877: nsGfxScrollFrameInner::AppendAnonymousContentTo(nsBaseContentList& aElements,
55877:                                                 PRUint32 aFilter)
38069: {
38069:   aElements.MaybeAppendElement(mHScrollbarContent);
38069:   aElements.MaybeAppendElement(mVScrollbarContent);
38069:   aElements.MaybeAppendElement(mScrollCornerContent);
60693:   aElements.MaybeAppendElement(mResizerContent);
38069: }
38069: 
38069: void
    1: nsGfxScrollFrameInner::Destroy()
    1: {
    1:   // Unbind any content created in CreateAnonymousContent from the tree
    1:   nsContentUtils::DestroyAnonymousContent(&mHScrollbarContent);
    1:   nsContentUtils::DestroyAnonymousContent(&mVScrollbarContent);
    1:   nsContentUtils::DestroyAnonymousContent(&mScrollCornerContent);
60693:   nsContentUtils::DestroyAnonymousContent(&mResizerContent);
    1: 
    1:   if (mPostedReflowCallback) {
  238:     mOuter->PresContext()->PresShell()->CancelReflowCallback(this);
80486:     mPostedReflowCallback = false;
    1:   }
    1: }
    1: 
    1: /**
    1:  * Called when we want to update the scrollbar position, either because scrolling happened
    1:  * or the user moved the scrollbar position and we need to undo that (e.g., when the user
    1:  * clicks to scroll and we're using smooth scrolling, so we need to put the thumb back
    1:  * to its initial position for the start of the smooth sequence).
    1:  */
    1: void
37083: nsGfxScrollFrameInner::UpdateScrollbarPosition()
    1: {
80486:   mFrameIsUpdatingScrollbar = true;
37083: 
37083:   nsPoint pt = GetScrollPosition();
37083:   if (mVScrollbarBox) {
    1:     SetCoordAttribute(mVScrollbarBox->GetContent(), nsGkAtoms::curpos,
37083:                       pt.y - GetScrolledRect().y);
37083:   }
37083:   if (mHScrollbarBox) {
    1:     SetCoordAttribute(mHScrollbarBox->GetContent(), nsGkAtoms::curpos,
37083:                       pt.x - GetScrolledRect().x);
37083:   }
37083: 
80486:   mFrameIsUpdatingScrollbar = false;
    1: }
    1: 
    1: void nsGfxScrollFrameInner::CurPosAttributeChanged(nsIContent* aContent)
    1: {
    1:   NS_ASSERTION(aContent, "aContent must not be null");
    1:   NS_ASSERTION((mHScrollbarBox && mHScrollbarBox->GetContent() == aContent) ||
    1:                (mVScrollbarBox && mVScrollbarBox->GetContent() == aContent),
    1:                "unexpected child");
    1: 
    1:   // Attribute changes on the scrollbars happen in one of three ways:
    1:   // 1) The scrollbar changed the attribute in response to some user event
    1:   // 2) We changed the attribute in response to a ScrollPositionDidChange
    1:   // callback from the scrolling view
    1:   // 3) We changed the attribute to adjust the scrollbars for the start
    1:   // of a smooth scroll operation
    1:   //
37083:   // In cases 2 and 3 we do not need to scroll because we're just
37083:   // updating our scrollbar.
37083:   if (mFrameIsUpdatingScrollbar)
37083:     return;
37083: 
37083:   nsRect scrolledRect = GetScrolledRect();
    1: 
75304:   nsPoint current = GetScrollPosition() - scrolledRect.TopLeft();
62285:   nsPoint dest;
75304:   dest.x = GetCoordAttribute(mHScrollbarBox, nsGkAtoms::curpos, current.x) +
    1:            scrolledRect.x;
75304:   dest.y = GetCoordAttribute(mVScrollbarBox, nsGkAtoms::curpos, current.y) +
    1:            scrolledRect.y;
    1: 
62884:   // If we have an async scroll pending don't stomp on that by calling ScrollTo.
62884:   if (mAsyncScroll && dest == GetScrollPosition()) {
62285:     return;
62285:   }
62285: 
79445:   bool isSmooth = aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::smooth);
    1:   if (isSmooth) {
    1:     // Make sure an attribute-setting callback occurs even if the view
    1:     // didn't actually move yet.  We need to make sure other listeners
    1:     // see that the scroll position is not (yet) what they thought it
    1:     // was.
37083:     UpdateScrollbarPosition();
37083:   }
62285:   ScrollTo(dest,
37083:            isSmooth ? nsIScrollableFrame::SMOOTH : nsIScrollableFrame::INSTANT);
    1: }
    1: 
    1: /* ============= Scroll events ========== */
    1: 
    1: NS_IMETHODIMP
    1: nsGfxScrollFrameInner::ScrollEvent::Run()
    1: {
    1:   if (mInner)
    1:     mInner->FireScrollEvent();
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsGfxScrollFrameInner::FireScrollEvent()
    1: {
    1:   mScrollEvent.Forget();
    1: 
80486:   nsScrollbarEvent event(true, NS_SCROLL_EVENT, nsnull);
    1:   nsEventStatus status = nsEventStatus_eIgnore;
    1:   nsIContent* content = mOuter->GetContent();
  238:   nsPresContext* prescontext = mOuter->PresContext();
    1:   // Fire viewport scroll events at the document (where they
    1:   // will bubble to the window)
    1:   if (mIsRoot) {
    1:     nsIDocument* doc = content->GetCurrentDoc();
    1:     if (doc) {
    1:       nsEventDispatcher::Dispatch(doc, prescontext, &event, nsnull,  &status);
    1:     }
    1:   } else {
    1:     // scroll events fired at elements don't bubble (although scroll events
    1:     // fired at documents do, to the window)
    1:     event.flags |= NS_EVENT_FLAG_CANT_BUBBLE;
    1:     nsEventDispatcher::Dispatch(content, prescontext, &event, nsnull, &status);
    1:   }
    1: }
    1: 
    1: void
    1: nsGfxScrollFrameInner::PostScrollEvent()
    1: {
    1:   if (mScrollEvent.IsPending())
    1:     return;
    1: 
80879:   nsRootPresContext* rpc = mOuter->PresContext()->GetRootPresContext();
80879:   if (!rpc)
80879:     return;
80879:   mScrollEvent = new ScrollEvent(this);
80879:   rpc->AddWillPaintObserver(mScrollEvent.get());
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGfxScrollFrameInner::AsyncScrollPortEvent::Run()
    1: {
  514:   if (mInner) {
  514:     mInner->mOuter->PresContext()->GetPresShell()->
27993:       FlushPendingNotifications(Flush_InterruptibleLayout);
  514:   }
    1:   return mInner ? mInner->FireScrollPortEvent() : NS_OK;
    1: }
    1: 
79445: bool
79445: nsXULScrollFrame::AddHorizontalScrollbar(nsBoxLayoutState& aState, bool aOnBottom)
    1: {
    1:   if (!mInner.mHScrollbarBox)
80486:     return true;
80486: 
80486:   return AddRemoveScrollbar(aState, aOnBottom, true, true);
    1: }
    1: 
79445: bool
79445: nsXULScrollFrame::AddVerticalScrollbar(nsBoxLayoutState& aState, bool aOnRight)
    1: {
    1:   if (!mInner.mVScrollbarBox)
80486:     return true;
80486: 
80486:   return AddRemoveScrollbar(aState, aOnRight, false, true);
    1: }
    1: 
    1: void
79445: nsXULScrollFrame::RemoveHorizontalScrollbar(nsBoxLayoutState& aState, bool aOnBottom)
    1: {
    1:   // removing a scrollbar should always fit
    1: #ifdef DEBUG
79445:   bool result =
    1: #endif
80486:   AddRemoveScrollbar(aState, aOnBottom, true, false);
    1:   NS_ASSERTION(result, "Removing horizontal scrollbar failed to fit??");
    1: }
    1: 
    1: void
79445: nsXULScrollFrame::RemoveVerticalScrollbar(nsBoxLayoutState& aState, bool aOnRight)
    1: {
    1:   // removing a scrollbar should always fit
    1: #ifdef DEBUG
79445:   bool result =
    1: #endif
80486:   AddRemoveScrollbar(aState, aOnRight, false, false);
    1:   NS_ASSERTION(result, "Removing vertical scrollbar failed to fit??");
    1: }
    1: 
79445: bool
37083: nsXULScrollFrame::AddRemoveScrollbar(nsBoxLayoutState& aState,
79445:                                      bool aOnRightOrBottom, bool aHorizontal, bool aAdd)
    1: {
    1:   if (aHorizontal) {
    1:      if (mInner.mNeverHasHorizontalScrollbar || !mInner.mHScrollbarBox)
80486:        return false;
    1: 
    1:      nsSize hSize = mInner.mHScrollbarBox->GetPrefSize(aState);
40166:      nsBox::AddMargin(mInner.mHScrollbarBox, hSize);
    1: 
    1:      mInner.SetScrollbarVisibility(mInner.mHScrollbarBox, aAdd);
    1: 
79445:      bool hasHorizontalScrollbar;
79445:      bool fit = AddRemoveScrollbar(hasHorizontalScrollbar,
37083:                                      mInner.mScrollPort.y,
37083:                                      mInner.mScrollPort.height,
63569:                                      hSize.height, aOnRightOrBottom, aAdd);
79445:      mInner.mHasHorizontalScrollbar = hasHorizontalScrollbar;    // because mHasHorizontalScrollbar is a bool
    1:      if (!fit)
    1:         mInner.SetScrollbarVisibility(mInner.mHScrollbarBox, !aAdd);
    1: 
    1:      return fit;
    1:   } else {
    1:      if (mInner.mNeverHasVerticalScrollbar || !mInner.mVScrollbarBox)
80486:        return false;
    1: 
    1:      nsSize vSize = mInner.mVScrollbarBox->GetPrefSize(aState);
40166:      nsBox::AddMargin(mInner.mVScrollbarBox, vSize);
    1: 
    1:      mInner.SetScrollbarVisibility(mInner.mVScrollbarBox, aAdd);
    1: 
79445:      bool hasVerticalScrollbar;
79445:      bool fit = AddRemoveScrollbar(hasVerticalScrollbar,
37083:                                      mInner.mScrollPort.x,
37083:                                      mInner.mScrollPort.width,
63569:                                      vSize.width, aOnRightOrBottom, aAdd);
79445:      mInner.mHasVerticalScrollbar = hasVerticalScrollbar;    // because mHasVerticalScrollbar is a bool
    1:      if (!fit)
    1:         mInner.SetScrollbarVisibility(mInner.mVScrollbarBox, !aAdd);
    1: 
    1:      return fit;
    1:   }
    1: }
    1: 
79445: bool
79445: nsXULScrollFrame::AddRemoveScrollbar(bool& aHasScrollbar, nscoord& aXY,
    1:                                      nscoord& aSize, nscoord aSbSize,
79445:                                      bool aOnRightOrBottom, bool aAdd)
    1: { 
    1:    nscoord size = aSize;
    1:    nscoord xy = aXY;
    1: 
    1:    if (size != NS_INTRINSICSIZE) {
    1:      if (aAdd) {
    1:         size -= aSbSize;
63569:         if (!aOnRightOrBottom && size >= 0)
    1:           xy += aSbSize;
    1:      } else {
    1:         size += aSbSize;
63569:         if (!aOnRightOrBottom)
    1:           xy -= aSbSize;
    1:      }
    1:    }
    1: 
    1:    // not enough room? Yes? Return true.
    1:    if (size >= 0) {
    1:        aHasScrollbar = aAdd;
    1:        aSize = size;
    1:        aXY = xy;
80486:        return true;
80486:    }
80486: 
80486:    aHasScrollbar = false;
80486:    return false;
    1: }
    1: 
    1: void
37083: nsXULScrollFrame::LayoutScrollArea(nsBoxLayoutState& aState,
37083:                                    const nsPoint& aScrollPosition)
    1: {
    1:   PRUint32 oldflags = aState.LayoutFlags();
62492:   nsRect childRect = nsRect(mInner.mScrollPort.TopLeft() - aScrollPosition,
37083:                             mInner.mScrollPort.Size());
    1:   PRInt32 flags = NS_FRAME_NO_MOVE_VIEW;
    1: 
37868:   nsRect originalRect = mInner.mScrolledFrame->GetRect();
55040:   nsRect originalVisOverflow = mInner.mScrolledFrame->GetVisualOverflowRect();
37868: 
    1:   nsSize minSize = mInner.mScrolledFrame->GetMinSize(aState);
    1:   
    1:   if (minSize.height > childRect.height)
    1:     childRect.height = minSize.height;
    1:   
    1:   if (minSize.width > childRect.width)
    1:     childRect.width = minSize.width;
    1: 
    1:   aState.SetLayoutFlags(flags);
62492:   ClampAndSetBounds(aState, childRect, aScrollPosition);
    1:   mInner.mScrolledFrame->Layout(aState);
    1: 
    1:   childRect = mInner.mScrolledFrame->GetRect();
    1: 
37083:   if (childRect.width < mInner.mScrollPort.width ||
37083:       childRect.height < mInner.mScrollPort.height)
    1:   {
37083:     childRect.width = NS_MAX(childRect.width, mInner.mScrollPort.width);
37083:     childRect.height = NS_MAX(childRect.height, mInner.mScrollPort.height);
    1: 
55040:     // remove overflow areas when we update the bounds,
    1:     // because we've already accounted for it
55040:     // REVIEW: Have we accounted for both?
80486:     ClampAndSetBounds(aState, childRect, aScrollPosition, true);
62492:   }
62087: 
37868:   nsRect finalRect = mInner.mScrolledFrame->GetRect();
55040:   nsRect finalVisOverflow = mInner.mScrolledFrame->GetVisualOverflowRect();
37868:   // The position of the scrolled frame shouldn't change, but if it does or
37868:   // the position of the overflow rect changes just invalidate both the old
37868:   // and new overflow rect.
37868:   if (originalRect.TopLeft() != finalRect.TopLeft() ||
55040:       originalVisOverflow.TopLeft() != finalVisOverflow.TopLeft())
37868:   {
37868:     // The old overflow rect needs to be adjusted if the frame's position
37868:     // changed.
37868:     mInner.mScrolledFrame->Invalidate(
55040:       originalVisOverflow + originalRect.TopLeft() - finalRect.TopLeft());
55040:     mInner.mScrolledFrame->Invalidate(finalVisOverflow);
68638:   } else if (!originalVisOverflow.IsEqualInterior(finalVisOverflow)) {
37868:     // If the overflow rect changed then invalidate the difference between the
37868:     // old and new overflow rects.
37868:     mInner.mScrolledFrame->CheckInvalidateSizeChange(
55040:       originalRect, originalVisOverflow, finalRect.Size());
37868:     mInner.mScrolledFrame->InvalidateRectDifference(
55040:       originalVisOverflow, finalVisOverflow);
37868:   }
37868: 
    1:   aState.SetLayoutFlags(oldflags);
    1: 
    1: }
    1: 
    1: void nsGfxScrollFrameInner::PostOverflowEvent()
    1: {
    1:   if (mAsyncScrollPortEvent.IsPending())
    1:     return;
    1: 
 6722:   // Keep this in sync with FireScrollPortEvent().
37083:   nsSize scrollportSize = mScrollPort.Size();
37083:   nsSize childSize = GetScrolledRect().Size();
 6722: 
79445:   bool newVerticalOverflow = childSize.height > scrollportSize.height;
79445:   bool vertChanged = mVerticalOverflow != newVerticalOverflow;
79445: 
79445:   bool newHorizontalOverflow = childSize.width > scrollportSize.width;
79445:   bool horizChanged = mHorizontalOverflow != newHorizontalOverflow;
 6722: 
 6722:   if (!vertChanged && !horizChanged) {
 6722:     return;
 6722:   }
 6722: 
    1:   nsRefPtr<AsyncScrollPortEvent> ev = new AsyncScrollPortEvent(this);
    1:   if (NS_SUCCEEDED(NS_DispatchToCurrentThread(ev)))
    1:     mAsyncScrollPortEvent = ev;
    1: }
    1: 
79445: bool
    1: nsGfxScrollFrameInner::IsLTR() const
    1: {
    1:   //TODO make bidi code set these from preferences
    1: 
    1:   nsIFrame *frame = mOuter;
    1:   // XXX This is a bit on the slow side.
    1:   if (mIsRoot) {
    1:     // If we're the root scrollframe, we need the root element's style data.
  238:     nsPresContext *presContext = mOuter->PresContext();
    1:     nsIDocument *document = presContext->Document();
41634:     Element *root = document->GetRootElement();
41634: 
41634:     // But for HTML and XHTML we want the body element.
11877:     nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(document);
11875:     if (htmlDoc) {
41634:       Element *bodyElement = document->GetBodyElement();
41634:       if (bodyElement)
41634:         root = bodyElement; // we can trust the document to hold on to it
    1:     }
    1: 
    1:     if (root) {
36656:       nsIFrame *rootsFrame = root->GetPrimaryFrame();
    1:       if (rootsFrame)
    1:         frame = rootsFrame;
    1:     }
    1:   }
    1: 
    1:   return frame->GetStyleVisibility()->mDirection != NS_STYLE_DIRECTION_RTL;
    1: }
    1: 
79445: bool
    1: nsGfxScrollFrameInner::IsScrollbarOnRight() const
    1: {
  238:   nsPresContext *presContext = mOuter->PresContext();
40595: 
40595:   // The position of the scrollbar in top-level windows depends on the pref
40595:   // layout.scrollbar.side. For non-top-level elements, it depends only on the
40595:   // directionaliy of the element (equivalent to a value of "1" for the pref).
40595:   if (!mIsRoot)
40595:     return IsLTR();
    1:   switch (presContext->GetCachedIntPref(kPresContext_ScrollbarSide)) {
    1:     default:
    1:     case 0: // UI directionality
    1:       return presContext->GetCachedIntPref(kPresContext_BidiDirection)
    1:              == IBMBIDI_TEXTDIRECTION_LTR;
    1:     case 1: // Document / content directionality
    1:       return IsLTR();
    1:     case 2: // Always right
80486:       return true;
    1:     case 3: // Always left
80486:       return false;
    1:   }
    1: }
    1: 
    1: /**
    1:  * Reflow the scroll area if it needs it and return its size. Also determine if the reflow will
    1:  * cause any of the scrollbars to need to be reflowed.
    1:  */
    1: nsresult
    1: nsXULScrollFrame::Layout(nsBoxLayoutState& aState)
    1: {
79445:   bool scrollbarRight = mInner.IsScrollbarOnRight();
79445:   bool scrollbarBottom = true;
    1: 
    1:   // get the content rect
    1:   nsRect clientRect(0,0,0,0);
    1:   GetClientRect(clientRect);
    1: 
37083:   nsRect oldScrollAreaBounds = mInner.mScrollPort;
62087:   nsPoint oldScrollPosition = mInner.GetLogicalScrollPosition();
37083: 
    1:   // the scroll area size starts off as big as our content area
37083:   mInner.mScrollPort = clientRect;
    1: 
    1:   /**************
    1:    Our basic strategy here is to first try laying out the content with
    1:    the scrollbars in their current state. We're hoping that that will
    1:    just "work"; the content will overflow wherever there's a scrollbar
    1:    already visible. If that does work, then there's no need to lay out
    1:    the scrollarea. Otherwise we fix up the scrollbars; first we add a
    1:    vertical one to scroll the content if necessary, or remove it if
    1:    it's not needed. Then we reflow the content if the scrollbar
    1:    changed.  Then we add a horizontal scrollbar if necessary (or
    1:    remove if not needed), and if that changed, we reflow the content
    1:    again. At this point, any scrollbars that are needed to scroll the
    1:    content have been added.
    1: 
    1:    In the second phase we check to see if any scrollbars are too small
    1:    to display, and if so, we remove them. We check the horizontal
    1:    scrollbar first; removing it might make room for the vertical
    1:    scrollbar, and if we have room for just one scrollbar we'll save
    1:    the vertical one.
    1: 
    1:    Finally we position and size the scrollbars and scrollcorner (the
    1:    square that is needed in the corner of the window when two
    1:    scrollbars are visible), and reflow any fixed position views
    1:    (if we're the viewport and we added or removed a scrollbar).
    1:    **************/
    1: 
    1:   ScrollbarStyles styles = GetScrollbarStyles();
    1: 
    1:   // Look at our style do we always have vertical or horizontal scrollbars?
    1:   if (styles.mHorizontal == NS_STYLE_OVERFLOW_SCROLL)
80486:      mInner.mHasHorizontalScrollbar = true;
    1:   if (styles.mVertical == NS_STYLE_OVERFLOW_SCROLL)
80486:      mInner.mHasVerticalScrollbar = true;
    1: 
    1:   if (mInner.mHasHorizontalScrollbar)
37083:      AddHorizontalScrollbar(aState, scrollbarBottom);
    1: 
    1:   if (mInner.mHasVerticalScrollbar)
37083:      AddVerticalScrollbar(aState, scrollbarRight);
    1:      
    1:   // layout our the scroll area
37083:   LayoutScrollArea(aState, oldScrollPosition);
    1:   
    1:   // now look at the content area and see if we need scrollbars or not
79445:   bool needsLayout = false;
    1: 
    1:   // if we have 'auto' scrollbars look at the vertical case
    1:   if (styles.mVertical != NS_STYLE_OVERFLOW_SCROLL) {
    1:     // These are only good until the call to LayoutScrollArea.
37083:     nsRect scrolledRect = mInner.GetScrolledRect();
    1: 
    1:     // There are two cases to consider
62087:       if (scrolledRect.height <= mInner.mScrollPort.height
    1:           || styles.mVertical != NS_STYLE_OVERFLOW_AUTO) {
    1:         if (mInner.mHasVerticalScrollbar) {
    1:           // We left room for the vertical scrollbar, but it's not needed;
    1:           // remove it.
37083:           RemoveVerticalScrollbar(aState, scrollbarRight);
80486:           needsLayout = true;
    1:         }
    1:       } else {
    1:         if (!mInner.mHasVerticalScrollbar) {
    1:           // We didn't leave room for the vertical scrollbar, but it turns
    1:           // out we needed it
37083:           if (AddVerticalScrollbar(aState, scrollbarRight))
80486:             needsLayout = true;
    1:         }
    1:     }
    1: 
    1:     // ok layout at the right size
    1:     if (needsLayout) {
    1:        nsBoxLayoutState resizeState(aState);
37083:        LayoutScrollArea(resizeState, oldScrollPosition);
80486:        needsLayout = false;
    1:     }
    1:   }
    1: 
    1: 
    1:   // if scrollbars are auto look at the horizontal case
    1:   if (styles.mHorizontal != NS_STYLE_OVERFLOW_SCROLL)
    1:   {
    1:     // These are only good until the call to LayoutScrollArea.
37083:     nsRect scrolledRect = mInner.GetScrolledRect();
    1: 
    1:     // if the child is wider that the scroll area
    1:     // and we don't have a scrollbar add one.
62087:     if ((scrolledRect.width > mInner.mScrollPort.width)
    1:         && styles.mHorizontal == NS_STYLE_OVERFLOW_AUTO) {
    1: 
    1:       if (!mInner.mHasHorizontalScrollbar) {
    1:            // no scrollbar? 
37083:           if (AddHorizontalScrollbar(aState, scrollbarBottom))
80486:              needsLayout = true;
    1: 
16050:            // if we added a horizontal scrollbar and we did not have a vertical
16050:            // there is a chance that by adding the horizontal scrollbar we will
    1:            // suddenly need a vertical scrollbar. Is a special case but its 
    1:            // important.
62087:            //if (!mHasVerticalScrollbar && scrolledRect.height > scrollAreaRect.height - sbSize.height)
    1:            //  printf("****Gfx Scrollbar Special case hit!!*****\n");
    1:            
    1:       }
    1:     } else {
    1:         // if the area is smaller or equal to and we have a scrollbar then
    1:         // remove it.
    1:       if (mInner.mHasHorizontalScrollbar) {
37083:         RemoveHorizontalScrollbar(aState, scrollbarBottom);
80486:         needsLayout = true;
    1:       }
    1:     }
    1:   }
    1: 
    1:   // we only need to set the rect. The inner child stays the same size.
    1:   if (needsLayout) {
    1:      nsBoxLayoutState resizeState(aState);
37083:      LayoutScrollArea(resizeState, oldScrollPosition);
80486:      needsLayout = false;
    1:   }
    1:     
    1:   // get the preferred size of the scrollbars
    1:   nsSize hMinSize(0, 0);
    1:   if (mInner.mHScrollbarBox && mInner.mHasHorizontalScrollbar) {
80486:     GetScrollbarMetrics(aState, mInner.mHScrollbarBox, &hMinSize, nsnull, false);
    1:   }
    1:   nsSize vMinSize(0, 0);
    1:   if (mInner.mVScrollbarBox && mInner.mHasVerticalScrollbar) {
80486:     GetScrollbarMetrics(aState, mInner.mVScrollbarBox, &vMinSize, nsnull, true);
    1:   }
    1: 
    1:   // Disable scrollbars that are too small
    1:   // Disable horizontal scrollbar first. If we have to disable only one
    1:   // scrollbar, we'd rather keep the vertical scrollbar.
    1:   // Note that we always give horizontal scrollbars their preferred height,
    1:   // never their min-height. So check that there's room for the preferred height.
    1:   if (mInner.mHasHorizontalScrollbar &&
    1:       (hMinSize.width > clientRect.width - vMinSize.width
    1:        || hMinSize.height > clientRect.height)) {
37083:     RemoveHorizontalScrollbar(aState, scrollbarBottom);
80486:     needsLayout = true;
    1:   }
    1:   // Now disable vertical scrollbar if necessary
    1:   if (mInner.mHasVerticalScrollbar &&
    1:       (vMinSize.height > clientRect.height - hMinSize.height
    1:        || vMinSize.width > clientRect.width)) {
37083:     RemoveVerticalScrollbar(aState, scrollbarRight);
80486:     needsLayout = true;
    1:   }
    1: 
    1:   // we only need to set the rect. The inner child stays the same size.
    1:   if (needsLayout) {
    1:     nsBoxLayoutState resizeState(aState);
37083:     LayoutScrollArea(resizeState, oldScrollPosition);
    1:   }
    1: 
    1:   if (!mInner.mSupppressScrollbarUpdate) { 
37083:     mInner.LayoutScrollbars(aState, clientRect, oldScrollAreaBounds);
    1:   }
29508:   if (!mInner.mPostedReflowCallback) {
29508:     // Make sure we'll try scrolling to restored position
29508:     PresContext()->PresShell()->PostReflowCallback(&mInner);
80486:     mInner.mPostedReflowCallback = true;
29508:   }
    1:   if (!(GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
80486:     mInner.mHadNonInitialReflow = true;
    1:   }
    1: 
    1:   mInner.PostOverflowEvent();
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsGfxScrollFrameInner::FinishReflowForScrollbar(nsIContent* aContent,
    1:                                                 nscoord aMinXY, nscoord aMaxXY,
    1:                                                 nscoord aCurPosXY,
    1:                                                 nscoord aPageIncrement,
    1:                                                 nscoord aIncrement)
    1: {
    1:   // Scrollbars assume zero is the minimum position, so translate for them.
    1:   SetCoordAttribute(aContent, nsGkAtoms::curpos, aCurPosXY - aMinXY);
    1:   SetScrollbarEnabled(aContent, aMaxXY - aMinXY);
    1:   SetCoordAttribute(aContent, nsGkAtoms::maxpos, aMaxXY - aMinXY);
    1:   SetCoordAttribute(aContent, nsGkAtoms::pageincrement, aPageIncrement);
    1:   SetCoordAttribute(aContent, nsGkAtoms::increment, aIncrement);
    1: }
    1: 
79445: bool
    1: nsGfxScrollFrameInner::ReflowFinished()
    1: {
80486:   mPostedReflowCallback = false;
    1: 
29508:   ScrollToRestoredPosition();
29508: 
39970:   // Clamp scroll position
39970:   ScrollToImpl(GetScrollPosition());
39970: 
29508:   if (NS_SUBTREE_DIRTY(mOuter) || !mUpdateScrollbarAttributes)
80486:     return false;
80486: 
80486:   mUpdateScrollbarAttributes = false;
29508: 
29108:   // Update scrollbar attributes.
29108:   nsPresContext* presContext = mOuter->PresContext();
29108: 
 9564:   if (mMayHaveDirtyFixedChildren) {
80486:     mMayHaveDirtyFixedChildren = false;
 9564:     nsIFrame* parentFrame = mOuter->GetParent();
 9564:     for (nsIFrame* fixedChild =
77154:            parentFrame->GetFirstChild(nsIFrame::kFixedList);
 9564:          fixedChild; fixedChild = fixedChild->GetNextSibling()) {
 9564:       // force a reflow of the fixed child
29108:       presContext->PresShell()->
 9564:         FrameNeedsReflow(fixedChild, nsIPresShell::eResize,
 9564:                          NS_FRAME_HAS_DIRTY_CHILDREN);
 9564:     }
 9564:   }
 9564: 
37083:   nsRect scrolledContentRect = GetScrolledRect();
    1:   nscoord minX = scrolledContentRect.x;
37083:   nscoord maxX = scrolledContentRect.XMost() - mScrollPort.width;
    1:   nscoord minY = scrolledContentRect.y;
37083:   nscoord maxY = scrolledContentRect.YMost() - mScrollPort.height;
    1: 
    1:   // Suppress handling of the curpos attribute changes we make here.
37083:   NS_ASSERTION(!mFrameIsUpdatingScrollbar, "We shouldn't be reentering here");
80486:   mFrameIsUpdatingScrollbar = true;
    1: 
    1:   nsCOMPtr<nsIContent> vScroll =
    1:     mVScrollbarBox ? mVScrollbarBox->GetContent() : nsnull;
    1:   nsCOMPtr<nsIContent> hScroll =
    1:     mHScrollbarBox ? mHScrollbarBox->GetContent() : nsnull;
    1: 
    1:   // Note, in some cases mOuter may get deleted while finishing reflow
    1:   // for scrollbars.
    1:   if (vScroll || hScroll) {
    1:     nsWeakFrame weakFrame(mOuter);
37083:     nsPoint scrollPos = GetScrollPosition();
37083:     // XXX shouldn't we use GetPageScrollAmount/GetLineScrollAmount here?
    1:     if (vScroll) {
37083:       nscoord fontHeight = GetLineScrollAmount().height;
12167:       // We normally use (scrollArea.height - fontHeight) for height
12167:       // of page scrolling.  However, it is too small when
12167:       // fontHeight is very large. (If fontHeight is larger than
12167:       // scrollArea.height, direction of scrolling will be opposite).
12167:       // To avoid it, we use (float(scrollArea.height) * 0.8) as
12167:       // lower bound value of height of page scrolling. (bug 383267)
37083:       nscoord pageincrement = nscoord(mScrollPort.height - fontHeight);
37083:       nscoord pageincrementMin = nscoord(float(mScrollPort.height) * 0.8);
37083:       FinishReflowForScrollbar(vScroll, minY, maxY, scrollPos.y,
32531:                                NS_MAX(pageincrement,pageincrementMin),
    1:                                fontHeight);
    1:     }
    1:     if (hScroll) {
37083:       FinishReflowForScrollbar(hScroll, minX, maxX, scrollPos.x,
37083:                                nscoord(float(mScrollPort.width) * 0.8),
    1:                                nsPresContext::CSSPixelsToAppUnits(10));
    1:     }
80486:     NS_ENSURE_TRUE(weakFrame.IsAlive(), false);
80486:   }
80486: 
80486:   mFrameIsUpdatingScrollbar = false;
    1:   // We used to rely on the curpos attribute changes above to scroll the
    1:   // view.  However, for scrolling to the left of the viewport, we
    1:   // rescale the curpos attribute, which means that operations like
    1:   // resizing the window while it is scrolled all the way to the left
    1:   // hold the curpos attribute constant at 0 while still requiring
    1:   // scrolling.  So we suppress the effect of the changes above with
37083:   // mFrameIsUpdatingScrollbar and call CurPosAttributeChanged here.
    1:   // (It actually even works some of the time without this, thanks to
    1:   // nsSliderFrame::AttributeChanged's handling of maxpos, but not when
    1:   // we hide the scrollbar on a large size change, such as
    1:   // maximization.)
    1:   if (!mHScrollbarBox && !mVScrollbarBox)
80486:     return false;
    1:   CurPosAttributeChanged(mVScrollbarBox ? mVScrollbarBox->GetContent()
    1:                                         : mHScrollbarBox->GetContent());
80486:   return true;
    1: }
    1: 
 8509: void
 8509: nsGfxScrollFrameInner::ReflowCallbackCanceled()
 8509: {
80486:   mPostedReflowCallback = false;
 8509: }
 8509: 
  189: static void LayoutAndInvalidate(nsBoxLayoutState& aState,
47744:                                 nsIFrame* aBox, const nsRect& aRect,
79445:                                 bool aScrollbarIsBeingHidden)
  189: {
  189:   // When a child box changes shape of position, the parent
  189:   // is responsible for invalidation; the overflow rect must be invalidated
37175:   // to make sure to catch any overflow.
37175:   // We invalidate the parent (i.e. the scrollframe) directly, because
37175:   // invalidates coming from scrollbars are suppressed by nsHTMLScrollFrame when
37175:   // mHasVScrollbar/mHasHScrollbar is false, and this is called after those
37175:   // flags have been set ... if a scrollbar is being hidden, we still need
37175:   // to invalidate the scrollbar area here.
47744:   // But we also need to invalidate the scrollbar itself in case it has
47744:   // its own layer; we need to ensure that layer is updated.
79445:   bool rectChanged = !aBox->GetRect().IsEqualInterior(aRect);
37175:   if (rectChanged) {
47744:     if (aScrollbarIsBeingHidden) {
55040:       aBox->GetParent()->Invalidate(aBox->GetVisualOverflowRect() +
55040:                                     aBox->GetPosition());
47744:     } else {
51756:       aBox->InvalidateFrameSubtree();
47744:     }
37175:   }
  189:   nsBoxFrame::LayoutChildAt(aState, aBox, aRect);
37175:   if (rectChanged) {
47744:     if (aScrollbarIsBeingHidden) {
55040:       aBox->GetParent()->Invalidate(aBox->GetVisualOverflowRect() +
55040:                                     aBox->GetPosition());
47744:     } else {
51756:       aBox->InvalidateFrameSubtree();
47744:     }
37175:   }
  189: }
  189: 
39640: void
39640: nsGfxScrollFrameInner::AdjustScrollbarRectForResizer(
39640:                          nsIFrame* aFrame, nsPresContext* aPresContext,
79445:                          nsRect& aRect, bool aHasResizer, bool aVertical)
16520: {
16520:   if ((aVertical ? aRect.width : aRect.height) == 0)
16520:     return;
16520: 
39640:   // if a content resizer is present, use its size. Otherwise, check if the
39640:   // widget has a resizer.
39640:   nsRect resizerRect;
60693:   if (aHasResizer) {
60693:     resizerRect = mResizerBox->GetRect();
39640:   }
39640:   else {
47904:     nsPoint offset;
47904:     nsIWidget* widget = aFrame->GetNearestWidget(offset);
16520:     nsIntRect widgetRect;
37083:     if (!widget || !widget->ShowsResizeIndicator(&widgetRect))
16520:       return;
16520: 
39747:     resizerRect = nsRect(aPresContext->DevPixelsToAppUnits(widgetRect.x) - offset.x,
16520:                          aPresContext->DevPixelsToAppUnits(widgetRect.y) - offset.y,
16520:                          aPresContext->DevPixelsToAppUnits(widgetRect.width),
16520:                          aPresContext->DevPixelsToAppUnits(widgetRect.height));
39640:   }
16520: 
33453:   if (!resizerRect.Contains(aRect.BottomRight() - nsPoint(1, 1)))
16520:     return;
16520: 
16520:   if (aVertical)
32531:     aRect.height = NS_MAX(0, resizerRect.y - aRect.y);
16520:   else
32531:     aRect.width = NS_MAX(0, resizerRect.x - aRect.x);
16520: }
16520: 
    1: void
    1: nsGfxScrollFrameInner::LayoutScrollbars(nsBoxLayoutState& aState,
    1:                                         const nsRect& aContentArea,
37083:                                         const nsRect& aOldScrollArea)
    1: {
    1:   NS_ASSERTION(!mSupppressScrollbarUpdate,
    1:                "This should have been suppressed");
    1: 
79445:   bool hasResizer = HasResizer();
79445:   bool scrollbarOnLeft = !IsScrollbarOnRight();
39640: 
39640:   // place the scrollcorner
60693:   if (mScrollCornerBox || mResizerBox) {
60693:     NS_PRECONDITION(!mScrollCornerBox || mScrollCornerBox->IsBoxFrame(), "Must be a box frame!");
39640: 
39640:     nsRect r(0, 0, 0, 0);
39640:     if (aContentArea.x != mScrollPort.x || scrollbarOnLeft) {
39640:       // scrollbar (if any) on left
39640:       r.x = aContentArea.x;
60693:       r.width = mScrollPort.x - aContentArea.x;
39640:       NS_ASSERTION(r.width >= 0, "Scroll area should be inside client rect");
39640:     } else {
39640:       // scrollbar (if any) on right
60693:       r.width = aContentArea.XMost() - mScrollPort.XMost();
39640:       r.x = aContentArea.XMost() - r.width;
39640:       NS_ASSERTION(r.width >= 0, "Scroll area should be inside client rect");
39640:     }
39640:     if (aContentArea.y != mScrollPort.y) {
39640:       NS_ERROR("top scrollbars not supported");
39640:     } else {
39640:       // scrollbar (if any) on bottom
60693:       r.height = aContentArea.YMost() - mScrollPort.YMost();
39640:       r.y = aContentArea.YMost() - r.height;
39640:       NS_ASSERTION(r.height >= 0, "Scroll area should be inside client rect");
39640:     }
60693: 
60693:     if (mScrollCornerBox) {
80486:       LayoutAndInvalidate(aState, mScrollCornerBox, r, false);
39640:     }
39640: 
60693:     if (hasResizer) {
60693:       // if a resizer is present, get its size. Assume a default size of 15 pixels.
60693:       nsSize resizerSize;
60693:       nscoord defaultSize = nsPresContext::CSSPixelsToAppUnits(15);
60693:       resizerSize.width =
60693:         mVScrollbarBox ? mVScrollbarBox->GetMinSize(aState).width : defaultSize;
60693:       if (resizerSize.width > r.width) {
60693:         r.width = resizerSize.width;
60693:         if (aContentArea.x == mScrollPort.x && !scrollbarOnLeft)
60693:           r.x = aContentArea.XMost() - r.width;
60693:       }
60693: 
60693:       resizerSize.height =
60693:         mHScrollbarBox ? mHScrollbarBox->GetMinSize(aState).height : defaultSize;
60693:       if (resizerSize.height > r.height) {
60693:         r.height = resizerSize.height;
60693:         if (aContentArea.y == mScrollPort.y)
60693:           r.y = aContentArea.YMost() - r.height;
60693:       }
60693: 
80486:       LayoutAndInvalidate(aState, mResizerBox, r, false);
60693:     }
60693:     else if (mResizerBox) {
60693:       // otherwise lay out the resizer with an empty rectangle
80486:       LayoutAndInvalidate(aState, mResizerBox, nsRect(), false);
60693:     }
60693:   }
60693: 
16520:   nsPresContext* presContext = mScrolledFrame->PresContext();
    1:   if (mVScrollbarBox) {
    1:     NS_PRECONDITION(mVScrollbarBox->IsBoxFrame(), "Must be a box frame!");
37083:     nsRect vRect(mScrollPort);
37083:     vRect.width = aContentArea.width - mScrollPort.width;
39640:     vRect.x = scrollbarOnLeft ? aContentArea.x : mScrollPort.XMost();
    1:     nsMargin margin;
    1:     mVScrollbarBox->GetMargin(margin);
40166:     vRect.Deflate(margin);
80486:     AdjustScrollbarRectForResizer(mOuter, presContext, vRect, hasResizer, true);
47744:     LayoutAndInvalidate(aState, mVScrollbarBox, vRect, !mHasVerticalScrollbar);
    1:   }
    1: 
    1:   if (mHScrollbarBox) {
    1:     NS_PRECONDITION(mHScrollbarBox->IsBoxFrame(), "Must be a box frame!");
37083:     nsRect hRect(mScrollPort);
37083:     hRect.height = aContentArea.height - mScrollPort.height;
80486:     hRect.y = true ? mScrollPort.YMost() : aContentArea.y;
    1:     nsMargin margin;
    1:     mHScrollbarBox->GetMargin(margin);
40166:     hRect.Deflate(margin);
80486:     AdjustScrollbarRectForResizer(mOuter, presContext, hRect, hasResizer, false);
47744:     LayoutAndInvalidate(aState, mHScrollbarBox, hRect, !mHasHorizontalScrollbar);
    1:   }
    1: 
    1:   // may need to update fixed position children of the viewport,
    1:   // if the client area changed size because of an incremental
    1:   // reflow of a descendant.  (If the outer frame is dirty, the fixed
    1:   // children will be re-laid out anyway)
37083:   if (aOldScrollArea.Size() != mScrollPort.Size() && 
    1:       !(mOuter->GetStateBits() & NS_FRAME_IS_DIRTY) &&
    1:       mIsRoot) {
80486:     mMayHaveDirtyFixedChildren = true;
    1:   }
    1:   
    1:   // post reflow callback to modify scrollbar attributes
80486:   mUpdateScrollbarAttributes = true;
    1:   if (!mPostedReflowCallback) {
    1:     aState.PresContext()->PresShell()->PostReflowCallback(this);
80486:     mPostedReflowCallback = true;
    1:   }
    1: }
    1: 
    1: void
    1: nsGfxScrollFrameInner::SetScrollbarEnabled(nsIContent* aContent, nscoord aMaxPos)
    1: {
    1:   if (aMaxPos) {
80486:     aContent->UnsetAttr(kNameSpaceID_None, nsGkAtoms::disabled, true);
    1:   } else {
    1:     aContent->SetAttr(kNameSpaceID_None, nsGkAtoms::disabled,
80486:                       NS_LITERAL_STRING("true"), true);
    1:   }
    1: }
    1: 
    1: void
    1: nsGfxScrollFrameInner::SetCoordAttribute(nsIContent* aContent, nsIAtom* aAtom,
    1:                                          nscoord aSize)
    1: {
    1:   // convert to pixels
    1:   aSize = nsPresContext::AppUnitsToIntCSSPixels(aSize);
    1: 
    1:   // only set the attribute if it changed.
    1: 
    1:   nsAutoString newValue;
    1:   newValue.AppendInt(aSize);
    1: 
    1:   if (aContent->AttrValueIs(kNameSpaceID_None, aAtom, newValue, eCaseMatters))
    1:     return;
    1: 
80486:   aContent->SetAttr(kNameSpaceID_None, aAtom, newValue, true);
    1: }
    1: 
52133: static void
52133: ReduceRadii(nscoord aXBorder, nscoord aYBorder,
52133:             nscoord& aXRadius, nscoord& aYRadius)
52133: {
52133:   // In order to ensure that the inside edge of the border has no
52133:   // curvature, we need at least one of its radii to be zero.
52133:   if (aXRadius <= aXBorder || aYRadius <= aYBorder)
52133:     return;
52133: 
52133:   // For any corner where we reduce the radii, preserve the corner's shape.
52133:   double ratio = NS_MAX(double(aXBorder) / aXRadius,
52133:                         double(aYBorder) / aYRadius);
52133:   aXRadius *= ratio;
52133:   aYRadius *= ratio;
52133: }
52133: 
52133: /**
52133:  * Implement an override for nsIFrame::GetBorderRadii to ensure that
52133:  * the clipping region for the border radius does not clip the scrollbars.
52133:  *
52133:  * In other words, we require that the border radius be reduced until the
52133:  * inner border radius at the inner edge of the border is 0 wherever we
52133:  * have scrollbars.
52133:  */
79445: bool
52133: nsGfxScrollFrameInner::GetBorderRadii(nscoord aRadii[8]) const
52133: {
52133:   if (!mOuter->nsContainerFrame::GetBorderRadii(aRadii))
80486:     return false;
52133: 
52133:   // Since we can use GetActualScrollbarSizes (rather than
52133:   // GetDesiredScrollbarSizes) since this doesn't affect reflow, we
52133:   // probably should.
52133:   nsMargin sb = GetActualScrollbarSizes();
52133:   nsMargin border = mOuter->GetUsedBorder();
52133: 
52133:   if (sb.left > 0 || sb.top > 0) {
52133:     ReduceRadii(border.left, border.top,
52133:                 aRadii[NS_CORNER_TOP_LEFT_X],
52133:                 aRadii[NS_CORNER_TOP_LEFT_Y]);
52133:   }
52133: 
52133:   if (sb.top > 0 || sb.right > 0) {
52133:     ReduceRadii(border.right, border.top,
52133:                 aRadii[NS_CORNER_TOP_RIGHT_X],
52133:                 aRadii[NS_CORNER_TOP_RIGHT_Y]);
52133:   }
52133: 
52133:   if (sb.right > 0 || sb.bottom > 0) {
52133:     ReduceRadii(border.right, border.bottom,
52133:                 aRadii[NS_CORNER_BOTTOM_RIGHT_X],
52133:                 aRadii[NS_CORNER_BOTTOM_RIGHT_Y]);
52133:   }
52133: 
52133:   if (sb.bottom > 0 || sb.left > 0) {
52133:     ReduceRadii(border.left, border.bottom,
52133:                 aRadii[NS_CORNER_BOTTOM_LEFT_X],
52133:                 aRadii[NS_CORNER_BOTTOM_LEFT_Y]);
52133:   }
52133: 
80486:   return true;
52133: }
52133: 
    1: nsRect
37083: nsGfxScrollFrameInner::GetScrolledRect() const
    1: {
37083:   nsRect result =
55040:     GetScrolledRectInternal(mScrolledFrame->GetScrollableOverflowRect(),
37083:                             mScrollPort.Size());
37083: 
37083:   NS_ASSERTION(result.width >= mScrollPort.width,
37083:                "Scrolled rect smaller than scrollport?");
37083:   NS_ASSERTION(result.height >= mScrollPort.height,
37083:                "Scrolled rect smaller than scrollport?");
37083:   return result;
37083: }
37083: 
37083: nsRect
37083: nsGfxScrollFrameInner::GetScrolledRectInternal(const nsRect& aScrolledFrameOverflowArea,
37083:                                                const nsSize& aScrollPortSize) const
37083: {
37083:   nscoord x1 = aScrolledFrameOverflowArea.x,
37083:           x2 = aScrolledFrameOverflowArea.XMost(),
37083:           y1 = aScrolledFrameOverflowArea.y,
37083:           y2 = aScrolledFrameOverflowArea.YMost();
    1:   if (y1 < 0)
    1:     y1 = 0;
62087:   if (IsLTR()) {
    1:     if (x1 < 0)
    1:       x1 = 0;
    1:   } else {
    1:     if (x2 > aScrollPortSize.width)
    1:       x2 = aScrollPortSize.width;
15908:     // When the scrolled frame chooses a size larger than its available width (because
15908:     // its padding alone is larger than the available width), we need to keep the
15908:     // start-edge of the scroll frame anchored to the start-edge of the scrollport. 
15908:     // When the scrolled frame is RTL, this means moving it in our left-based
15908:     // coordinate system, so we need to compensate for its extra width here by
15908:     // effectively repositioning the frame.
32531:     nscoord extraWidth = NS_MAX(0, mScrolledFrame->GetSize().width - aScrollPortSize.width);
15908:     x2 += extraWidth;
    1:   }
    1:   return nsRect(x1, y1, x2 - x1, y2 - y1);
    1: }
    1: 
    1: nsMargin
37293: nsGfxScrollFrameInner::GetActualScrollbarSizes() const
37293: {
40166:   nsRect r = mOuter->GetPaddingRect() - mOuter->GetPosition();
40166: 
40166:   return nsMargin(mScrollPort.x - r.x, mScrollPort.y - r.y,
40166:                   r.XMost() - mScrollPort.XMost(),
40166:                   r.YMost() - mScrollPort.YMost());
    1: }
    1: 
    1: void
79445: nsGfxScrollFrameInner::SetScrollbarVisibility(nsIBox* aScrollbar, bool aVisible)
    1: {
73635:   nsScrollbarFrame* scrollbar = do_QueryFrame(aScrollbar);
    1:   if (scrollbar) {
    1:     // See if we have a mediator.
    1:     nsIScrollbarMediator* mediator = scrollbar->GetScrollbarMediator();
    1:     if (mediator) {
    1:       // Inform the mediator of the visibility change.
23554:       mediator->VisibilityChanged(aVisible);
    1:     }
    1:   }
    1: }
    1: 
    1: PRInt32
    1: nsGfxScrollFrameInner::GetCoordAttribute(nsIBox* aBox, nsIAtom* atom, PRInt32 defaultValue)
    1: {
    1:   if (aBox) {
    1:     nsIContent* content = aBox->GetContent();
    1: 
    1:     nsAutoString value;
    1:     content->GetAttr(kNameSpaceID_None, atom, value);
    1:     if (!value.IsEmpty())
    1:     {
    1:       PRInt32 error;
    1: 
    1:       // convert it to an integer
    1:       defaultValue = nsPresContext::CSSPixelsToAppUnits(value.ToInteger(&error));
    1:     }
    1:   }
    1: 
    1:   return defaultValue;
    1: }
    1: 
    1: nsPresState*
    1: nsGfxScrollFrameInner::SaveState(nsIStatefulFrame::SpecialStateID aStateID)
    1: {
    1:   // Don't save "normal" state for the root scrollframe; that's
    1:   // handled via the eDocumentScrollState state id
    1:   if (mIsRoot && aStateID == nsIStatefulFrame::eNoID) {
    1:     return nsnull;
    1:   }
    1: 
23554:   nsIScrollbarMediator* mediator = do_QueryFrame(GetScrolledFrame());
    1:   if (mediator) {
    1:     // child handles its own scroll state, so don't bother saving state here
    1:     return nsnull;
    1:   }
    1: 
64063:   nsPoint scrollPos = GetLogicalScrollPosition();
64063:   // Don't save scroll position if we are at (0,0)
64063:   if (scrollPos == nsPoint(0,0)) {
64063:     return nsnull;
64063:   }
    1: 
22740:   nsPresState* state = new nsPresState();
    1: 
37083:   state->SetScrollState(scrollPos);
    1: 
22740:   return state;
    1: }
    1: 
    1: void
    1: nsGfxScrollFrameInner::RestoreState(nsPresState* aState)
    1: {
37083:   mRestorePos = aState->GetScrollState();
    1:   mLastPos.x = -1;
    1:   mLastPos.y = -1;
80486:   mDidHistoryRestore = true;
62087:   mLastPos = mScrolledFrame ? GetLogicalScrollPosition() : nsPoint(0,0);
    1: }
34480: 
34480: void
37084: nsGfxScrollFrameInner::PostScrolledAreaEvent()
34480: {
37084:   if (mScrolledAreaEvent.IsPending()) {
34480:     return;
34480:   }
37084:   mScrolledAreaEvent = new ScrolledAreaEvent(this);
63774:   nsContentUtils::AddScriptRunner(mScrolledAreaEvent.get());
34480: }
34480: 
34480: ////////////////////////////////////////////////////////////////////////////////
34480: // ScrolledArea change event dispatch
34480: 
34480: NS_IMETHODIMP
37084: nsGfxScrollFrameInner::ScrolledAreaEvent::Run()
34480: {
37084:   if (mInner) {
37084:     mInner->FireScrolledAreaEvent();
37084:   }
34480:   return NS_OK;
34480: }
34480: 
34480: void
37084: nsGfxScrollFrameInner::FireScrolledAreaEvent()
34480: {
37084:   mScrolledAreaEvent.Forget();
34480: 
80486:   nsScrollAreaEvent event(true, NS_SCROLLEDAREACHANGED, nsnull);
34480:   nsPresContext *prescontext = mOuter->PresContext();
34480:   nsIContent* content = mOuter->GetContent();
34480: 
55040:   event.mArea = mScrolledFrame->GetScrollableOverflowRectRelativeToParent();
34480: 
34480:   nsIDocument *doc = content->GetCurrentDoc();
34480:   if (doc) {
34480:     nsEventDispatcher::Dispatch(doc, prescontext, &event, nsnull);
34480:   }
34480: }
