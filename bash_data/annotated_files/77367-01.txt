59900: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52873:  * vim: set ts=4 sw=4 et tw=99:
52873:  *
52873:  * ***** BEGIN LICENSE BLOCK *****
52873:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52873:  *
52873:  * The contents of this file are subject to the Mozilla Public License Version
52873:  * 1.1 (the "License"); you may not use this file except in compliance with
52873:  * the License. You may obtain a copy of the License at
52873:  * http://www.mozilla.org/MPL/
52873:  *
52873:  * Software distributed under the License is distributed on an "AS IS" basis,
52873:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52873:  * for the specific language governing rights and limitations under the
52873:  * License.
52873:  *
52873:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52873:  * May 28, 2008.
52873:  *
52873:  * The Initial Developer of the Original Code is
52873:  *   Brendan Eich <brendan@mozilla.org>
52873:  *
52873:  * Contributor(s):
52873:  *   David Anderson <danderson@mozilla.com>
52873:  *   David Mandelin <dmandelin@mozilla.com>
52873:  *
52873:  * Alternatively, the contents of this file may be used under the terms of
52873:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52873:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52873:  * in which case the provisions of the GPL or the LGPL are applicable instead
52873:  * of those above. If you wish to allow use of your version of this file only
52873:  * under the terms of either the GPL or the LGPL, and not to allow others to
52873:  * use your version of this file under the terms of the MPL, indicate your
52873:  * decision by deleting the provisions above and replace them with the notice
52873:  * and other provisions required by the GPL or the LGPL. If you do not delete
52873:  * the provisions above, a recipient may use your version of this file under
52873:  * the terms of any one of the MPL, the GPL or the LGPL.
52873:  *
52873:  * ***** END LICENSE BLOCK ***** */
52873: 
52873: #include "jscntxt.h"
52873: #include "jsscope.h"
52873: #include "jsobj.h"
52873: #include "jslibmath.h"
52873: #include "jsiter.h"
52873: #include "jsnum.h"
52873: #include "jsxml.h"
52873: #include "jsstaticcheck.h"
52873: #include "jsbool.h"
52873: #include "assembler/assembler/MacroAssemblerCodeRef.h"
53133: #include "assembler/assembler/CodeLocation.h"
52873: #include "jsiter.h"
52873: #include "jstypes.h"
52873: #include "methodjit/StubCalls.h"
52873: #include "jstracer.h"
52873: #include "jspropertycache.h"
53133: #include "methodjit/MonoIC.h"
56602: #include "jsanalyze.h"
58063: #include "methodjit/BaseCompiler.h"
60591: #include "methodjit/ICRepatcher.h"
53133: 
53840: #include "jsinterpinlines.h"
52873: #include "jspropertycacheinlines.h"
52873: #include "jsscopeinlines.h"
52873: #include "jsscriptinlines.h"
52873: #include "jsobjinlines.h"
52873: #include "jscntxtinlines.h"
52873: #include "jsatominlines.h"
54832: #include "StubCalls-inl.h"
62574: #include "MethodJIT-inl.h"
52873: 
52873: #include "jsautooplen.h"
52873: 
52873: using namespace js;
52873: using namespace js::mjit;
52873: using namespace JSC;
52873: 
60591: using ic::Repatcher;
60591: 
52873: static jsbytecode *
52873: FindExceptionHandler(JSContext *cx)
52873: {
69223:     StackFrame *fp = cx->fp();
53840:     JSScript *script = fp->script();
52873: 
52873: top:
60211:     if (cx->isExceptionPending() && JSScript::isValidOffset(script->trynotesOffset)) {
52873:         // The PC is updated before every stub call, so we can use it here.
69223:         unsigned offset = cx->regs().pc - script->main;
52873: 
52873:         JSTryNoteArray *tnarray = script->trynotes();
52873:         for (unsigned i = 0; i < tnarray->length; ++i) {
52873:             JSTryNote *tn = &tnarray->vector[i];
57782: 
53496:             // The following if condition actually tests two separate conditions:
53496:             //   (1) offset - tn->start >= tn->length
53496:             //       means the PC is not in the range of this try note, so we
53496:             //       should continue searching, after considering:
53496:             //   (2) offset - tn->start == tn->length
53496:             //       means the PC is at the first op of the exception handler
53496:             //       for this try note. This happens when an exception is thrown
53496:             //       during recording: the interpreter sets the PC to the handler
53496:             //       and then exits. In this case, we are in fact at the right
53496:             //       exception handler. 
53496:             //      
53496:             //       Hypothetically, the op we are at might have thrown an
53496:             //       exception, in which case this would not be the right handler.
53496:             //       But the first ops of exception handlers generated by our
53496:             //       bytecode compiler cannot throw, so this is not possible.
53496:             if (offset - tn->start > tn->length)
52873:                 continue;
69223:             if (tn->stackDepth > cx->regs().sp - fp->base())
52873:                 continue;
52873: 
52873:             jsbytecode *pc = script->main + tn->start + tn->length;
52873:             JSBool ok = js_UnwindScope(cx, tn->stackDepth, JS_TRUE);
69223:             JS_ASSERT(cx->regs().sp == fp->base() + tn->stackDepth);
52873: 
52873:             switch (tn->kind) {
52873:                 case JSTRY_CATCH:
53840:                   JS_ASSERT(js_GetOpcode(cx, fp->script(), pc) == JSOP_ENTERBLOCK);
52873: 
52873: #if JS_HAS_GENERATORS
52873:                   /* Catch cannot intercept the closing of a generator. */
60211:                   if (JS_UNLIKELY(cx->getPendingException().isMagic(JS_GENERATOR_CLOSING)))
52873:                       break;
52873: #endif
52873: 
52873:                   /*
52873:                    * Don't clear cx->throwing to save cx->exception from GC
52873:                    * until it is pushed to the stack via [exception] in the
52873:                    * catch block.
52873:                    */
52873:                   return pc;
52873: 
52873:                 case JSTRY_FINALLY:
52873:                   /*
52873:                    * Push (true, exception) pair for finally to indicate that
52873:                    * [retsub] should rethrow the exception.
52873:                    */
69223:                   cx->regs().sp[0].setBoolean(true);
69223:                   cx->regs().sp[1] = cx->getPendingException();
69223:                   cx->regs().sp += 2;
60211:                   cx->clearPendingException();
52873:                   return pc;
52873: 
52873:                 case JSTRY_ITER:
52873:                 {
52873:                   /*
52873:                    * This is similar to JSOP_ENDITER in the interpreter loop,
52873:                    * except the code now uses the stack slot normally used by
52873:                    * JSOP_NEXTITER, namely regs.sp[-1] before the regs.sp -= 2
52873:                    * adjustment and regs.sp[1] after, to save and restore the
52873:                    * pending exception.
52873:                    */
60211:                   Value v = cx->getPendingException();
53840:                   JS_ASSERT(js_GetOpcode(cx, fp->script(), pc) == JSOP_ENDITER);
60211:                   cx->clearPendingException();
69223:                   ok = !!js_CloseIterator(cx, &cx->regs().sp[-1].toObject());
69223:                   cx->regs().sp -= 1;
52873:                   if (!ok)
52873:                       goto top;
60211:                   cx->setPendingException(v);
52873:                 }
52873:             }
52873:         }
52873:     }
52873: 
52873:     return NULL;
52873: }
52873: 
54832: /*
68952:  * Clean up a frame and return.
68952:  */
68952: static void
68952: InlineReturn(VMFrame &f)
68952: {
68952:     JS_ASSERT(f.fp() != f.entryfp);
69223:     JS_ASSERT(!js_IsActiveWithOrBlock(f.cx, &f.fp()->scopeChain(), 0));
71697:     f.cx->stack.popInlineFrame(f.regs);
68952: }
68952: 
68952: void JS_FASTCALL
68952: stubs::SlowCall(VMFrame &f, uint32 argc)
68952: {
76192:     CallArgs args = CallArgsFromSp(argc, f.regs.sp);
76192:     if (!Invoke(f.cx, args))
68952:         THROW();
76192: 
76192:     f.script()->types.monitor(f.cx, f.pc(), args.rval());
68952: }
68952: 
68952: void JS_FASTCALL
68952: stubs::SlowNew(VMFrame &f, uint32 argc)
68952: {
76192:     CallArgs args = CallArgsFromSp(argc, f.regs.sp);
76192:     if (!InvokeConstructor(f.cx, args))
68952:         THROW();
76192: 
76192:     f.script()->types.monitor(f.cx, f.pc(), args.rval());
76192: }
76192: 
76192: static inline bool
76192: CheckStackQuota(VMFrame &f)
76192: {
76192:     JS_ASSERT(f.regs.sp == f.fp()->base());
76192: 
77354:     f.stackLimit = f.cx->stack.space().getStackLimit(f.cx, DONT_REPORT_ERROR);
77354:     if (f.stackLimit)
76192:         return true;
76192: 
76192:     /* Remove the current partially-constructed frame before throwing. */
76192:     f.cx->stack.popFrameAfterOverflow();
76192:     js_ReportOverRecursed(f.cx);
76192: 
76192:     return false;
68952: }
68952: 
68952: /*
53840:  * HitStackQuota is called after the early prologue pushing the new frame would
53840:  * overflow f.stackLimit.
53840:  */
53590: void JS_FASTCALL
53840: stubs::HitStackQuota(VMFrame &f)
53590: {
76192:     if (!CheckStackQuota(f))
53590:         THROW();
53590: }
53590: 
53840: /*
53840:  * This function must only be called after the early prologue, since it depends
53840:  * on fp->exec.fun.
53840:  */
53590: void * JS_FASTCALL
53840: stubs::FixupArity(VMFrame &f, uint32 nactual)
53590: {
53590:     JSContext *cx = f.cx;
69223:     StackFrame *oldfp = f.fp();
53590: 
53840:     JS_ASSERT(nactual != oldfp->numFormalArgs());
53590: 
53590:     /*
53590:      * Grossssss! *move* the stack frame. If this ends up being perf-critical,
53840:      * we can figure out how to spot-optimize it. Be careful to touch only the
71695:      * members that have been initialized by initJitFrameCallerHalf and the
53840:      * early prologue.
53590:      */
77341:     InitialFrameFlags initial = oldfp->initialFlags();
53840:     JSFunction *fun           = oldfp->fun();
71695:     JSScript *script          = fun->script();
53840:     void *ncode               = oldfp->nativeReturnAddress();
53590: 
53590:     /* Pop the inline frame. */
69223:     f.regs.popPartialFrame((Value *)oldfp);
53590: 
53840:     /* Reserve enough space for a callee frame. */
71695:     CallArgs args = CallArgsFromSp(nactual, f.regs.sp);
73495:     StackFrame *fp = cx->stack.getFixupFrame(cx, DONT_REPORT_ERROR, args, fun,
77354:                                              script, ncode, initial, &f.stackLimit);
76192: 
71695:     if (!fp) {
77354:         f.regs.updateForNcode(f.jit(), ncode);
73495:         js_ReportOverRecursed(cx);
53840:         THROWV(NULL);
62038:     }
53590: 
53840:     /* The caller takes care of assigning fp to regs. */
71695:     return fp;
53590: }
53590: 
76192: struct ResetStubRejoin {
76192:     VMFrame &f;
76192:     ResetStubRejoin(VMFrame &f) : f(f) {}
76192:     ~ResetStubRejoin() { f.stubRejoin = 0; }
76192: };
76192: 
53590: void * JS_FASTCALL
76192: stubs::CompileFunction(VMFrame &f, uint32 argc)
53590: {
53590:     /*
76192:      * Note: the stubRejoin kind for the frame was written before the call, and
76192:      * needs to be cleared out on all return paths (doing this directly in the
76192:      * IC stub will not handle cases where we recompiled or threw).
53590:      */
76192:     JS_ASSERT_IF(f.cx->typeInferenceEnabled(), f.stubRejoin);
76192:     ResetStubRejoin reset(f);
53590: 
77341:     InitialFrameFlags initial = f.fp()->initialFlags();
76192:     f.regs.popPartialFrame((Value *)f.fp());
53590: 
77341:     if (InitialFrameFlagsAreConstructing(initial))
77341:         return UncachedNew(f, argc);
77341:     else if (InitialFrameFlagsAreLowered(initial))
77341:         return UncachedLoweredCall(f, argc);
77341:     else
77341:         return UncachedCall(f, argc);
53590: }
53590: 
68952: static inline bool
77341: UncachedInlineCall(VMFrame &f, InitialFrameFlags initial,
77341:                    void **pret, bool *unjittable, uint32 argc)
68952: {
68952:     JSContext *cx = f.cx;
71695:     CallArgs args = CallArgsFromSp(argc, f.regs.sp);
71695:     JSObject &callee = args.callee();
68952:     JSFunction *newfun = callee.getFunctionPrivate();
68952:     JSScript *newscript = newfun->script();
68952: 
77341:     bool construct = InitialFrameFlagsAreConstructing(initial);
77341: 
76192:     bool newType = construct && cx->typeInferenceEnabled() &&
76192:         types::UseNewType(cx, f.script(), f.pc());
76192: 
76192:     types::TypeMonitorCall(cx, args, construct);
76192: 
76192:     /*
76192:      * Preserve f.regs.fp while pushing the new frame, for the invariant that
76192:      * f.regs reflects the state when we entered the stub call. This handoff is
76192:      * tricky: we need to make sure that f.regs is not updated to the new
76192:      * frame, and we also need to ensure that cx->regs still points to f.regs
76192:      * when space is reserved, in case doing so throws an exception.
76192:      */
76192:     FrameRegs regs = f.regs;
76192: 
68952:     /* Get pointer to new frame/slots, prepare arguments. */
77354:     if (!cx->stack.pushInlineFrame(cx, regs, args, callee, newfun, newscript, initial, &f.stackLimit))
68952:         return false;
68952: 
76192:     /* Finish the handoff to the new frame regs. */
76192:     PreserveRegsGuard regsGuard(cx, regs);
76192: 
68952:     /* Scope with a call object parented by callee's parent. */
76192:     if (newfun->isHeavyweight() && !js::CreateFunCallObject(cx, regs.fp()))
68952:         return false;
68952: 
68952:     /* Try to compile if not already compiled. */
71695:     if (newscript->getJITStatus(f.fp()->isConstructing()) == JITScript_None) {
76192:         CompileStatus status = CanMethodJIT(cx, newscript, regs.fp(), CompileRequest_Interpreter);
68952:         if (status == Compile_Error) {
68952:             /* A runtime exception was thrown, get out. */
76192:             f.cx->stack.popInlineFrame(regs);
68952:             return false;
68952:         }
68952:         if (status == Compile_Abort)
68952:             *unjittable = true;
68952:     }
68952: 
76192:     /*
76192:      * If newscript was successfully compiled, run it. Skip for calls which
76192:      * will be constructing a new type object for 'this'.
76192:      */
76192:     if (!newType) {
76192:         if (JITScript *jit = newscript->getJIT(regs.fp()->isConstructing())) {
68952:             *pret = jit->invokeEntry;
76192: 
76192:             /* Restore the old fp around and let the JIT code repush the new fp. */
76192:             regs.popFrame((Value *) regs.fp());
68952:             return true;
68952:         }
76192:     }
68952: 
68952:     /* Otherwise, run newscript in the interpreter. */
68952:     bool ok = !!Interpret(cx, cx->fp());
76192:     f.cx->stack.popInlineFrame(regs);
76192: 
76192:     if (ok)
76192:         f.script()->types.monitor(cx, f.pc(), args.rval());
68952: 
68952:     *pret = NULL;
68952:     return ok;
68952: }
68952: 
68952: void * JS_FASTCALL
68952: stubs::UncachedNew(VMFrame &f, uint32 argc)
68952: {
68952:     UncachedCallResult ucr;
68952:     UncachedNewHelper(f, argc, &ucr);
68952:     return ucr.codeAddr;
68952: }
68952: 
68952: void
68952: stubs::UncachedNewHelper(VMFrame &f, uint32 argc, UncachedCallResult *ucr)
68952: {
68952:     ucr->init();
68952:     JSContext *cx = f.cx;
71695:     CallArgs args = CallArgsFromSp(argc, f.regs.sp);
71695: 
68952:     /* Try to do a fast inline call before the general Invoke path. */
71695:     if (IsFunctionObject(args.calleev(), &ucr->fun) && ucr->fun->isInterpretedConstructor()) {
71695:         ucr->callee = &args.callee();
77341:         if (!UncachedInlineCall(f, INITIAL_CONSTRUCT, &ucr->codeAddr, &ucr->unjittable, argc))
68952:             THROW();
68952:     } else {
71695:         if (!InvokeConstructor(cx, args))
68952:             THROW();
76192:         f.script()->types.monitor(cx, f.pc(), args.rval());
68952:     }
68952: }
68952: 
68952: void * JS_FASTCALL
68952: stubs::UncachedCall(VMFrame &f, uint32 argc)
68952: {
68952:     UncachedCallResult ucr;
77341:     UncachedCallHelper(f, argc, false, &ucr);
77341:     return ucr.codeAddr;
77341: }
77341: 
77341: void * JS_FASTCALL
77341: stubs::UncachedLoweredCall(VMFrame &f, uint32 argc)
77341: {
77341:     UncachedCallResult ucr;
77341:     UncachedCallHelper(f, argc, true, &ucr);
68952:     return ucr.codeAddr;
68952: }
68952: 
56775: void JS_FASTCALL
56775: stubs::Eval(VMFrame &f, uint32 argc)
56775: {
71695:     CallArgs args = CallArgsFromSp(argc, f.regs.sp);
56775: 
71695:     if (!IsBuiltinEvalForScope(&f.fp()->scopeChain(), args.calleev())) {
71695:         if (!Invoke(f.cx, args))
56775:             THROW();
76192: 
76192:         f.script()->types.monitor(f.cx, f.pc(), args.rval());
56775:         return;
56775:     }
56775: 
69223:     JS_ASSERT(f.fp() == f.cx->fp());
71695:     if (!DirectEval(f.cx, args))
56775:         THROW();
68894: 
76192:     f.script()->types.monitor(f.cx, f.pc(), args.rval());
56775: }
56775: 
68952: void
77341: stubs::UncachedCallHelper(VMFrame &f, uint32 argc, bool lowered, UncachedCallResult *ucr)
68952: {
68952:     ucr->init();
68952: 
68952:     JSContext *cx = f.cx;
71695:     CallArgs args = CallArgsFromSp(argc, f.regs.sp);
68952: 
71695:     if (IsFunctionObject(args.calleev(), &ucr->callee)) {
71695:         ucr->callee = &args.callee();
68952:         ucr->fun = GET_FUNCTION_PRIVATE(cx, ucr->callee);
68952: 
68952:         if (ucr->fun->isInterpreted()) {
77341:             InitialFrameFlags initial = lowered ? INITIAL_LOWERED : INITIAL_NONE;
77341:             if (!UncachedInlineCall(f, initial, &ucr->codeAddr, &ucr->unjittable, argc))
68952:                 THROW();
68952:             return;
68952:         }
68952: 
68952:         if (ucr->fun->isNative()) {
71695:             if (!CallJSNative(cx, ucr->fun->u.n.native, args))
68952:                 THROW();
76192:             f.script()->types.monitor(cx, f.pc(), args.rval());
68952:             return;
68952:         }
68952:     }
68952: 
71695:     if (!Invoke(f.cx, args))
68952:         THROW();
68952: 
76192:     f.script()->types.monitor(cx, f.pc(), args.rval());
68952:     return;
68952: }
68952: 
52873: void JS_FASTCALL
53840: stubs::PutActivationObjects(VMFrame &f)
52873: {
53840:     JS_ASSERT(f.fp()->hasCallObj() || f.fp()->hasArgsObj());
69223:     f.fp()->putActivationObjects();
52873: }
52873: 
76192: static void
76192: RemoveOrphanedNative(JSContext *cx, StackFrame *fp)
76192: {
76192:     /*
76192:      * Remove fp from the list of frames holding a reference on the orphaned
76192:      * native pools. If all the references have been removed, release all the
76192:      * pools. We don't release pools piecemeal as a pool can be referenced by
76192:      * multiple frames.
76192:      */
76192:     JaegerCompartment *jc = cx->compartment->jaegerCompartment();
76192:     if (jc->orphanedNativeFrames.empty())
76192:         return;
76192:     for (unsigned i = 0; i < jc->orphanedNativeFrames.length(); i++) {
76192:         if (fp == jc->orphanedNativeFrames[i]) {
76192:             jc->orphanedNativeFrames[i] = jc->orphanedNativeFrames.back();
76192:             jc->orphanedNativeFrames.popBack();
76192:             break;
76192:         }
76192:     }
76192:     if (jc->orphanedNativeFrames.empty()) {
76192:         for (unsigned i = 0; i < jc->orphanedNativePools.length(); i++)
76192:             jc->orphanedNativePools[i]->release();
76192:         jc->orphanedNativePools.clear();
76192:     }
76192: }
76192: 
52873: extern "C" void *
52873: js_InternalThrow(VMFrame &f)
52873: {
52873:     JSContext *cx = f.cx;
52873: 
76192:     // The current frame may have an associated orphaned native, if the native
76192:     // or SplatApplyArgs threw an exception.
76192:     RemoveOrphanedNative(cx, f.fp());
76192: 
60540:     // It's possible that from within RunTracer(), Interpret() returned with
60540:     // an error and finished the frame (i.e., called ScriptEpilogue), but has
60540:     // not yet performed an inline return.
60540:     //
60540:     // In this case, RunTracer() has no choice but to propagate the error
60540:     // up to the method JIT, and thus to this function. But ScriptEpilogue()
60540:     // has already been called. Detect this, and avoid double-finishing the
60540:     // frame. See HandleErrorInExcessFrame() and bug 624100.
60540:     if (f.fp()->finishedInInterpreter()) {
60540:         // If it's the last frame, just propagate the failure up again.
60540:         if (f.fp() == f.entryfp)
60540:             return NULL;
60540: 
60540:         InlineReturn(f);
60540:     }
60540: 
52873:     // Make sure sp is up to date.
69223:     JS_ASSERT(&cx->regs() == &f.regs);
52873: 
53410:     // Call the throw hook if necessary
53410:     JSThrowHook handler = f.cx->debugHooks->throwHook;
53410:     if (handler) {
53410:         Value rval;
76192:         switch (handler(cx, f.script(), f.pc(), Jsvalify(&rval), cx->debugHooks->throwHookData)) {
53410:           case JSTRAP_ERROR:
60211:             cx->clearPendingException();
53410:             return NULL;
53410: 
53410:           case JSTRAP_RETURN:
60211:             cx->clearPendingException();
53482:             cx->fp()->setReturnValue(rval);
67899:             return cx->jaegerCompartment()->forceReturnFromExternC();
53410: 
53410:           case JSTRAP_THROW:
60211:             cx->setPendingException(rval);
53410:             break;
53410: 
53410:           default:
53410:             break;
53410:         }
53410:     }
53410: 
52873:     jsbytecode *pc = NULL;
52873:     for (;;) {
52873:         pc = FindExceptionHandler(cx);
52873:         if (pc)
52873:             break;
52873: 
60540:         // The JIT guarantees that ScriptEpilogue() has always been run
60540:         // upon exiting to its caller. This is important for consistency,
60540:         // where execution modes make similar guarantees about prologues
60540:         // and epilogues. RunTracer(), Interpret(), and Invoke() all
60540:         // rely on this property.
60540:         JS_ASSERT(!f.fp()->finishedInInterpreter());
60211:         js_UnwindScope(cx, 0, cx->isExceptionPending());
56201:         ScriptEpilogue(f.cx, f.fp(), false);
56201: 
60540:         // Don't remove the last frame, this is the responsibility of
60540:         // JaegerShot()'s caller. We only guarantee that ScriptEpilogue()
60540:         // has been run.
60540:         if (f.entryfp == f.fp())
52873:             break;
52873: 
69223:         JS_ASSERT(f.regs.sp == cx->regs().sp);
56201:         InlineReturn(f);
52873:     }
52873: 
69223:     JS_ASSERT(f.regs.sp == cx->regs().sp);
52873: 
53626:     if (!pc)
52873:         return NULL;
52873: 
69223:     StackFrame *fp = cx->fp();
55503:     JSScript *script = fp->script();
76192: 
77367:     if (cx->typeInferenceEnabled()) {
76192:         /*
77367:          * Fall back to EnterMethodJIT and finish the frame in the interpreter.
77367:          * With type inference enabled, we may wipe out all JIT code on the
77367:          * stack without patching ncode values to jump to the interpreter, and
77367:          * thus can only enter JIT code via EnterMethodJIT (which overwrites
77367:          * its entry frame's ncode). See ClearAllFrames.
76192:          */
77367:         cx->compartment->jaegerCompartment()->setLastUnfinished(Jaeger_Unfinished);
77367: 
77367:         analyze::AutoEnterAnalysis enter(cx);
77367:         analyze::ScriptAnalysis *analysis = script->analysis(cx);
77367:         if (analysis && !analysis->ranBytecode())
77367:             analysis->analyzeBytecode(cx);
77367:         if (!analysis || analysis->OOM()) {
77367:             js_ReportOutOfMemory(cx);
77367:             return NULL;
77367:         }
77367: 
77367:         cx->regs().pc = pc;
77367:         cx->regs().sp = fp->base() + analysis->getCode(pc).stackDepth;
77367: 
77367:         /*
77367:          * Interpret the ENTERBLOCK and EXCEPTION opcodes, so that we don't go
77367:          * back into the interpreter with a pending exception. This will cause
77367:          * it to immediately rethrow.
77367:          */
77367:         if (cx->isExceptionPending()) {
77367:             JS_ASSERT(js_GetOpcode(cx, script, pc) == JSOP_ENTERBLOCK);
77367:             JSObject *obj = script->getObject(GET_SLOTNO(pc));
77367:             Value *vp = cx->regs().sp + OBJ_BLOCK_COUNT(cx, obj);
77367:             SetValueRangeToUndefined(cx->regs().sp, vp);
77367:             cx->regs().sp = vp;
77367:             JS_ASSERT(js_GetOpcode(cx, script, pc + JSOP_ENTERBLOCK_LENGTH) == JSOP_EXCEPTION);
77367:             cx->regs().sp[0] = cx->getPendingException();
77367:             cx->clearPendingException();
77367:             cx->regs().sp++;
77367:             cx->regs().pc = pc + JSOP_ENTERBLOCK_LENGTH + JSOP_EXCEPTION_LENGTH;
77367:         }
77367: 
77367:         *f.oldregs = f.regs;
77367: 
76192:         return NULL;
76192:     }
76192: 
55520:     return script->nativeCodeForPC(fp->isConstructing(), pc);
52873: }
52873: 
52873: void JS_FASTCALL
64364: stubs::CreateFunCallObject(VMFrame &f)
52873: {
53840:     JS_ASSERT(f.fp()->fun()->isHeavyweight());
64364:     if (!js::CreateFunCallObject(f.cx, f.fp()))
52873:         THROW();
52873: }
52873: 
55503: void JS_FASTCALL
55503: stubs::CreateThis(VMFrame &f, JSObject *proto)
55503: {
55503:     JSContext *cx = f.cx;
69223:     StackFrame *fp = f.fp();
55503:     JSObject *callee = &fp->callee();
55503:     JSObject *obj = js_CreateThisForFunctionWithProto(cx, callee, proto);
55503:     if (!obj)
55503:         THROW();
55503:     fp->formalArgs()[-1].setObject(*obj);
55503: }
55503: 
56201: void JS_FASTCALL
64363: stubs::ScriptDebugPrologue(VMFrame &f)
53133: {
73073:     Probes::enterJSFun(f.cx, f.fp()->maybeFun(), f.fp()->script());
64363:     js::ScriptDebugPrologue(f.cx, f.fp());
56201: }
56201: 
56201: void JS_FASTCALL
64363: stubs::ScriptDebugEpilogue(VMFrame &f)
56201: {
73073:     Probes::exitJSFun(f.cx, f.fp()->maybeFun(), f.fp()->script());
64363:     if (!js::ScriptDebugEpilogue(f.cx, f.fp(), JS_TRUE))
56201:         THROW();
56201: }
53133: 
73073: void JS_FASTCALL
73073: stubs::ScriptProbeOnlyPrologue(VMFrame &f)
73073: {
73073:     Probes::enterJSFun(f.cx, f.fp()->fun(), f.fp()->script());
73073: }
73073: 
73073: void JS_FASTCALL
73073: stubs::ScriptProbeOnlyEpilogue(VMFrame &f)
73073: {
73073:     Probes::exitJSFun(f.cx, f.fp()->fun(), f.fp()->script());
73073: }
73073: 
53133: #ifdef JS_TRACER
53133: 
56201: /*
56201:  * Called when an error is in progress and the topmost frame could not handle
56201:  * it. This will unwind to a given frame, or find and align to an exception
56201:  * handler in the process.
56201:  */
53133: static inline bool
69223: HandleErrorInExcessFrame(VMFrame &f, StackFrame *stopFp, bool searchedTopmostFrame = true)
53133: {
53133:     JSContext *cx = f.cx;
53133: 
54736:     /*
54736:      * Callers of this called either Interpret() or JaegerShot(), which would
54736:      * have searched for exception handlers already. If we see stopFp, just
54736:      * return false. Otherwise, pop the frame, since it's guaranteed useless.
56201:      *
56201:      * Note that this also guarantees ScriptEpilogue() has been called.
54736:      */
69223:     StackFrame *fp = cx->fp();
56201:     if (searchedTopmostFrame) {
60540:         /*
60540:          * This is a special case meaning that fp->finishedInInterpreter() is
60540:          * true. If so, and fp == stopFp, our only choice is to propagate this
60540:          * error up, back to the method JIT, and then to js_InternalThrow,
60540:          * where this becomes a special case. See the comment there and bug
60540:          * 624100.
60540:          */
54736:         if (fp == stopFp)
54736:             return false;
54736: 
60540:         /*
60540:          * Otherwise, the protocol here (like Invoke) is to assume that the
60540:          * execution mode finished the frame, and to just pop it.
60540:          */
56201:         InlineReturn(f);
56201:     }
54736: 
54727:     /* Remove the bottom frame. */
56201:     bool returnOK = false;
54727:     for (;;) {
54736:         fp = cx->fp();
54723: 
54736:         /* Clear imacros. */
54736:         if (fp->hasImacropc()) {
69223:             cx->regs().pc = fp->imacropc();
53840:             fp->clearImacropc();
53133:         }
53840:         JS_ASSERT(!fp->hasImacropc());
53133: 
53133:         /* If there's an exception and a handler, set the pc and leave. */
60211:         if (cx->isExceptionPending()) {
53133:             jsbytecode *pc = FindExceptionHandler(cx);
53133:             if (pc) {
69223:                 cx->regs().pc = pc;
54736:                 returnOK = true;
53133:                 break;
53133:             }
54736:         }
53133: 
53133:         /* Don't unwind if this was the entry frame. */
53133:         if (fp == stopFp)
53133:             break;
53133: 
53133:         /* Unwind and return. */
60211:         returnOK &= bool(js_UnwindScope(cx, 0, returnOK || cx->isExceptionPending()));
56201:         returnOK = ScriptEpilogue(cx, fp, returnOK);
56201:         InlineReturn(f);
53133:     }
53133: 
69223:     JS_ASSERT(&f.regs == &cx->regs());
54739:     JS_ASSERT_IF(!returnOK, cx->fp() == stopFp);
53133: 
54736:     return returnOK;
53133: }
53133: 
56201: /* Returns whether the current PC has method JIT'd code. */
55520: static inline void *
53133: AtSafePoint(JSContext *cx)
53133: {
69223:     StackFrame *fp = cx->fp();
53840:     if (fp->hasImacropc())
68902:         return NULL;
53133: 
53840:     JSScript *script = fp->script();
69223:     return script->maybeNativeCodeForPC(fp->isConstructing(), cx->regs().pc);
53133: }
53133: 
56201: /*
56201:  * Interprets until either a safe point is reached that has method JIT'd
56201:  * code, or the current frame tries to return.
56201:  */
53133: static inline JSBool
53428: PartialInterpret(VMFrame &f)
53133: {
53428:     JSContext *cx = f.cx;
69223:     StackFrame *fp = cx->fp();
53133: 
55503: #ifdef DEBUG
55520:     JSScript *script = fp->script();
56201:     JS_ASSERT(!fp->finishedInInterpreter());
55520:     JS_ASSERT(fp->hasImacropc() ||
69223:               !script->maybeNativeCodeForPC(fp->isConstructing(), cx->regs().pc));
55503: #endif
53133: 
53133:     JSBool ok = JS_TRUE;
71363:     ok = Interpret(cx, fp, JSINTERP_SAFEPOINT);
53133: 
53133:     return ok;
53133: }
53133: 
53133: JS_STATIC_ASSERT(JSOP_NOP == 0);
53133: 
63239: /*
63239:  * Returns whether the current PC would return, or if the frame has already
63239:  * been completed. This distinction avoids re-entering the interpreter or JIT
63239:  * to complete a JSOP_RETURN. Instead, that edge case is handled in
63239:  * HandleFinishedFrame. We could consider reducing complexity, and making this
63239:  * function return only "finishedInInterpreter", and always using the full VM
63239:  * machinery to fully finish frames.
63239:  */
63239: static inline bool
53133: FrameIsFinished(JSContext *cx)
53133: {
69223:     JSOp op = JSOp(*cx->regs().pc);
53133:     return (op == JSOP_RETURN ||
53133:             op == JSOP_RETRVAL ||
53133:             op == JSOP_STOP)
63239:         ? true
63239:         : cx->fp()->finishedInInterpreter();
53133: }
53133: 
56201: 
56201: /* Simulate an inline_return by advancing the pc. */
56201: static inline void
56201: AdvanceReturnPC(JSContext *cx)
56201: {
69223:     JS_ASSERT(*cx->regs().pc == JSOP_CALL ||
69223:               *cx->regs().pc == JSOP_NEW ||
69223:               *cx->regs().pc == JSOP_EVAL ||
69223:               *cx->regs().pc == JSOP_FUNCALL ||
69223:               *cx->regs().pc == JSOP_FUNAPPLY);
69223:     cx->regs().pc += JSOP_CALL_LENGTH;
56201: }
56201: 
56201: 
56201: /*
56201:  * Given a frame that is about to return, make sure its return value and
56201:  * activation objects are fixed up. Then, pop the frame and advance the
56201:  * current PC. Note that while we could enter the JIT at this point, the
56201:  * logic would still be necessary for the interpreter, so it's easier
56201:  * (and faster) to finish frames in C++ even if at a safe point here.
56201:  */
56201: static bool
69223: HandleFinishedFrame(VMFrame &f, StackFrame *entryFrame)
56201: {
56201:     JSContext *cx = f.cx;
56201: 
56201:     JS_ASSERT(FrameIsFinished(cx));
56201: 
56201:     /*
56201:      * This is the most difficult and complicated piece of the tracer
56201:      * integration, and historically has been very buggy. The problem is that
56201:      * although this frame has to be popped (see RemoveExcessFrames), it may
56201:      * be at a JSOP_RETURN opcode, and it might not have ever been executed.
56201:      * That is, fp->rval may not be set to the top of the stack, and if it
56201:      * has, the stack has already been decremented. Note that fp->rval is not
56201:      * the only problem: the epilogue may never have been executed.
56201:      *
56201:      * Here are the edge cases and whether the frame has been exited cleanly:
56201:      *  1. No: A trace exited directly before a RETURN op, and the
56201:      *         interpreter never ran.
56201:      *  2. Yes: The interpreter exited cleanly.
56201:      *  3. No: The interpreter exited on a safe point. LEAVE_ON_SAFE_POINT
56201:      *         is not used in between JSOP_RETURN and advancing the PC,
56201:      *         therefore, it cannot have been run if at a safe point.
56201:      *  4. No: Somewhere in the RunTracer call tree, we removed a frame,
56201:      *         and we returned to a JSOP_RETURN opcode. Note carefully
56201:      *         that in this situation, FrameIsFinished() returns true!
63239:      *  5. Yes: The function exited in the method JIT, during
63239:      *         FinishExcessFrames() However, in this case, we'll never enter
63239:      *         HandleFinishedFrame(): we always immediately pop JIT'd frames.
56201:      *
56201:      * Since the only scenario where this fixup is NOT needed is a normal exit
56201:      * from the interpreter, we can cleanly check for this scenario by checking
56201:      * a bit it sets in the frame.
56201:      */
56201:     bool returnOK = true;
56201:     if (!cx->fp()->finishedInInterpreter()) {
69223:         if (JSOp(*cx->regs().pc) == JSOP_RETURN)
56201:             cx->fp()->setReturnValue(f.regs.sp[-1]);
56201: 
56201:         returnOK = ScriptEpilogue(cx, cx->fp(), true);
56201:     }
56201: 
56201:     if (cx->fp() != entryFrame) {
56201:         InlineReturn(f);
56201:         AdvanceReturnPC(cx);
56201:     }
56201: 
56201:     return returnOK;
56201: }
56201: 
56201: /*
56201:  * Given a frame newer than the entry frame, try to finish it. If it's at a
56201:  * return position, pop the frame. If it's at a safe point, execute it in
56201:  * Jaeger code. Otherwise, try to interpret until a safe point.
56201:  *
56201:  * While this function is guaranteed to make progress, it may not actually
56201:  * finish or pop the current frame. It can either:
56201:  *   1) Finalize a finished frame, or
56201:  *   2) Finish and finalize the frame in the Method JIT, or
56201:  *   3) Interpret, which can:
56201:  *     a) Propagate an error, or
56201:  *     b) Finish the frame, but not finalize it, or
56201:  *     c) Abruptly leave at any point in the frame, or in a newer frame
56201:  *        pushed by a call, that has method JIT'd code.
56201:  */
56201: static bool
69223: EvaluateExcessFrame(VMFrame &f, StackFrame *entryFrame)
56201: {
56201:     JSContext *cx = f.cx;
69223:     StackFrame *fp = cx->fp();
56201: 
56201:     /*
56201:      * A "finished" frame is when the interpreter rested on a STOP,
56201:      * RETURN, RETRVAL, etc. We check for finished frames BEFORE looking
56201:      * for a safe point. If the frame was finished, we could have already
56201:      * called ScriptEpilogue(), and entering the JIT could call it twice.
56201:      */
56201:     if (!fp->hasImacropc() && FrameIsFinished(cx))
56201:         return HandleFinishedFrame(f, entryFrame);
56201: 
56201:     if (void *ncode = AtSafePoint(cx)) {
77341:         if (!JaegerShotAtSafePoint(cx, ncode, false))
56201:             return false;
56201:         InlineReturn(f);
56201:         AdvanceReturnPC(cx);
56201:         return true;
56201:     }
56201: 
56201:     return PartialInterpret(f);
56201: }
56201: 
56201: /*
56201:  * Evaluate frames newer than the entry frame until all are gone. This will
56201:  * always leave f.regs.fp == entryFrame.
56201:  */
53133: static bool
69223: FinishExcessFrames(VMFrame &f, StackFrame *entryFrame)
53133: {
53133:     JSContext *cx = f.cx;
56201: 
56033:     while (cx->fp() != entryFrame || entryFrame->hasImacropc()) {
56201:         if (!EvaluateExcessFrame(f, entryFrame)) {
56201:             if (!HandleErrorInExcessFrame(f, entryFrame))
56033:                 return false;
53133:         }
53133:     }
53133: 
53133:     return true;
53133: }
53133: 
60591: #if defined JS_MONOIC
53133: static void
58063: UpdateTraceHintSingle(Repatcher &repatcher, JSC::CodeLocationJump jump, JSC::CodeLocationLabel target)
53133: {
53133:     /*
53133:      * Hack: The value that will be patched is before the executable address,
53133:      * so to get protection right, just unprotect the general region around
53133:      * the jump.
53133:      */
58063:     repatcher.relink(jump, target);
53277: 
53277:     JaegerSpew(JSpew_PICs, "relinking trace hint %p to %p\n",
54160:                jump.executableAddress(), target.executableAddress());
53277: }
54160: 
54160: static void
61056: DisableTraceHint(JITScript *jit, ic::TraceICInfo &ic)
54160: {
61056:     Repatcher repatcher(jit);
76192:     UpdateTraceHintSingle(repatcher, ic.traceHint, ic.fastTarget);
54160: 
60567:     if (ic.hasSlowTraceHint)
76192:         UpdateTraceHintSingle(repatcher, ic.slowTraceHint, ic.slowTarget);
56217: }
54160: 
56217: static void
60567: ResetTraceHintAt(JSScript *script, js::mjit::JITScript *jit,
60567:                  jsbytecode *pc, uint16_t index, bool full)
56217: {
59742:     if (index >= jit->nTraceICs)
59742:         return;
62075:     ic::TraceICInfo &ic = jit->traceICs()[index];
60567:     if (!ic.initialized)
59742:         return;
56217:     
60567:     JS_ASSERT(ic.jumpTargetPC == pc);
56217: 
56217:     JaegerSpew(JSpew_PICs, "Enabling trace IC %u in script %p\n", index, script);
56217: 
58063:     Repatcher repatcher(jit);
58063: 
60567:     UpdateTraceHintSingle(repatcher, ic.traceHint, ic.stubEntry);
56217: 
60567:     if (ic.hasSlowTraceHint)
60567:         UpdateTraceHintSingle(repatcher, ic.slowTraceHint, ic.stubEntry);
60567: 
60567:     if (full) {
60567:         ic.traceData = NULL;
60567:         ic.loopCounterStart = 1;
60567:         ic.loopCounter = ic.loopCounterStart;
60567:     }
53133: }
53133: #endif
53133: 
56217: void
60567: js::mjit::ResetTraceHint(JSScript *script, jsbytecode *pc, uint16_t index, bool full)
56217: {
56217: #if JS_MONOIC
56217:     if (script->jitNormal)
60567:         ResetTraceHintAt(script, script->jitNormal, pc, index, full);
56217: 
56217:     if (script->jitCtor)
60567:         ResetTraceHintAt(script, script->jitCtor, pc, index, full);
56217: #endif
56217: }
56217: 
53133: #if JS_MONOIC
53133: void *
60567: RunTracer(VMFrame &f, ic::TraceICInfo &ic)
53133: #else
53133: void *
53133: RunTracer(VMFrame &f)
53133: #endif
53133: {
53133:     JSContext *cx = f.cx;
69223:     StackFrame *entryFrame = f.fp();
53133:     TracePointAction tpa;
53133: 
53133:     /* :TODO: nuke PIC? */
54175:     if (!cx->traceJitEnabled)
53133:         return NULL;
53133: 
55483:     /*
55483:      * Force initialization of the entry frame's scope chain and return value,
55483:      * if necessary.  The tracer can query the scope chain without needing to
55483:      * check the HAS_SCOPECHAIN flag, and the frame is guaranteed to have the
55483:      * correct return value stored if we trace/interpret through to the end
55483:      * of the frame.
55483:      */
55483:     entryFrame->scopeChain();
55483:     entryFrame->returnValue();
55483: 
53133:     bool blacklist;
56551:     void **traceData;
56551:     uintN *traceEpoch;
60534:     uint32 *loopCounter;
60534:     uint32 hits;
56551: #if JS_MONOIC
60567:     traceData = &ic.traceData;
60567:     traceEpoch = &ic.traceEpoch;
60567:     loopCounter = &ic.loopCounter;
60534:     *loopCounter = 1;
60567:     hits = ic.loopCounterStart;
56551: #else
56551:     traceData = NULL;
56551:     traceEpoch = NULL;
60534:     loopCounter = NULL;
60534:     hits = 1;
56551: #endif
76192: 
76192:     {
76192:         /*
76192:          * While the tracer is running, redirect the regs to a local variable here.
76192:          * If the tracer exits during an inlined frame, it will synthesize those
76192:          * frames, point f.regs.fp at them and then enter the interpreter. If the
76192:          * interpreter pops the frames it will not be reflected here as a local
76192:          * set of regs is used by the interpreter, and f->regs end up pointing at
76192:          * garbage, confusing the recompiler.
76192:          */
76192:         FrameRegs regs = f.regs;
76192:         PreserveRegsGuard regsGuard(cx, regs);
76192: 
71363:         tpa = MonitorTracePoint(f.cx, &blacklist, traceData, traceEpoch,
60534:                                 loopCounter, hits);
53133:         JS_ASSERT(!TRACE_RECORDER(cx));
76192:     }
53133: 
53133: #if JS_MONOIC
60567:     ic.loopCounterStart = *loopCounter;
53133:     if (blacklist)
61056:         DisableTraceHint(entryFrame->jit(), ic);
53133: #endif
53133: 
56201:     // Even though ExecuteTree() bypasses the interpreter, it should propagate
56201:     // error failures correctly.
60211:     JS_ASSERT_IF(cx->isExceptionPending(), tpa == TPA_Error);
53133: 
56201:     JS_ASSERT(f.fp() == cx->fp());
53133:     switch (tpa) {
53133:       case TPA_Nothing:
53133:         return NULL;
53133: 
53133:       case TPA_Error:
56201:         if (!HandleErrorInExcessFrame(f, entryFrame, f.fp()->finishedInInterpreter()))
53133:             THROWV(NULL);
53840:         JS_ASSERT(!cx->fp()->hasImacropc());
53133:         break;
53133: 
53133:       case TPA_RanStuff:
53133:       case TPA_Recorded:
53133:         break;
53133:     }
53133: 
53133:     /*
53133:      * The tracer could have dropped us off on any frame at any position.
53133:      * Well, it could not have removed frames (recursion is disabled).
53133:      *
53471:      * Frames after the entryFrame cannot be entered via JaegerShotAtSafePoint()
53471:      * unless each is at a safe point. We can JaegerShotAtSafePoint these
53471:      * frames individually, but we must unwind to the entryFrame.
53471:      *
53471:      * Note carefully that JaegerShotAtSafePoint can resume methods at
53471:      * arbitrary safe points whereas JaegerShot cannot.
53133:      *
53133:      * If we land on entryFrame without a safe point in sight, we'll end up
53133:      * at the RETURN op. This is an edge case with two paths:
53133:      *
53133:      * 1) The entryFrame is the last inline frame. If it fell on a RETURN,
53133:      *    move the return value down.
53133:      * 2) The entryFrame is NOT the last inline frame. Pop the frame.
53133:      *
64365:      * In both cases, we hijack the stub to return to the force-return
64365:      * trampoline. This trampoline simulates the frame-popping portion of
64365:      * emitReturn (except without the benefit of the FrameState) and will
64365:      * produce the necessary register state to return to the caller.
53133:      */
53133: 
53133:   restart:
54736:     /* Step 1. Finish frames created after the entry frame. */
54736:     if (!FinishExcessFrames(f, entryFrame))
53133:         THROWV(NULL);
53133: 
53626:     /* IMacros are guaranteed to have been removed by now. */
56201:     JS_ASSERT(f.fp() == entryFrame);
53840:     JS_ASSERT(!entryFrame->hasImacropc());
53133: 
56201:     /* Step 2. If entryFrame is done, use a special path to return to EnterMethodJIT(). */
56201:     if (FrameIsFinished(cx)) {
56201:         if (!HandleFinishedFrame(f, entryFrame))
53133:             THROWV(NULL);
67899:         *f.returnAddressLocation() = cx->jaegerCompartment()->forceReturnFromFastCall();
53133:         return NULL;
53133:     }
53133: 
56201:     /* Step 3. If entryFrame is at a safe point, just leave. */
56201:     if (void *ncode = AtSafePoint(cx))
56201:         return ncode;
56201: 
53626:     /* Step 4. Do a partial interp, then restart the whole process. */
53428:     if (!PartialInterpret(f)) {
56201:         if (!HandleErrorInExcessFrame(f, entryFrame))
53133:             THROWV(NULL);
53133:     }
53133: 
53133:     goto restart;
53133: }
53133: 
53133: #endif /* JS_TRACER */
53133: 
53136: #if defined JS_TRACER
53136: # if defined JS_MONOIC
53133: void *JS_FASTCALL
60567: stubs::InvokeTracer(VMFrame &f, ic::TraceICInfo *ic)
53133: {
60567:     return RunTracer(f, *ic);
53133: }
53133: 
53133: # else
53133: 
53133: void *JS_FASTCALL
53133: stubs::InvokeTracer(VMFrame &f)
53133: {
53133:     return RunTracer(f);
53133: }
53136: # endif /* JS_MONOIC */
53136: #endif /* JS_TRACER */
53133: 
76192: /* :XXX: common out with identical copy in Compiler.cpp */
76192: #if defined(JS_METHODJIT_SPEW)
76192: static const char *OpcodeNames[] = {
76192: # define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format) #name,
76192: # include "jsopcode.tbl"
76192: # undef OPDEF
76192: };
76192: #endif
76192: 
76192: static void
76192: FinishVarIncOp(VMFrame &f, RejoinState rejoin, Value ov, Value nv, Value *vp)
76192: {
76192:     /* Finish an increment operation on a LOCAL or ARG. These do not involve property accesses. */
76192:     JS_ASSERT(rejoin == REJOIN_POS || rejoin == REJOIN_BINARY);
76192: 
76192:     JSContext *cx = f.cx;
76192: 
76192:     JSOp op = js_GetOpcode(cx, f.script(), f.pc());
76192:     const JSCodeSpec *cs = &js_CodeSpec[op];
76192: 
76192:     unsigned i = GET_SLOTNO(f.pc());
76192:     Value *var = (JOF_TYPE(cs->format) == JOF_LOCAL) ? f.fp()->slots() + i : &f.fp()->formalArg(i);
76192: 
76192:     if (rejoin == REJOIN_POS) {
76192:         double d = ov.toNumber();
76192:         double N = (cs->format & JOF_INC) ? 1 : -1;
76192:         if (!nv.setNumber(d + N))
76192:             f.script()->types.monitorOverflow(cx, f.pc());
76192:     }
76192: 
76192:     *var = nv;
76192:     *vp = (cs->format & JOF_POST) ? ov : nv;
76192: }
76192: 
76192: extern "C" void *
76192: js_InternalInterpret(void *returnData, void *returnType, void *returnReg, js::VMFrame &f)
76192: {
76192:     JSRejoinState jsrejoin = f.fp()->rejoin();
76192:     RejoinState rejoin;
76192:     if (jsrejoin & 0x1) {
76192:         /* Rejoin after a scripted call finished. Restore f.regs.pc and f.regs.inlined (NULL) */
76192:         uint32 pcOffset = jsrejoin >> 1;
76192:         f.regs.pc = f.fp()->script()->code + pcOffset;
76192:         f.regs.clearInlined();
76192:         rejoin = REJOIN_SCRIPTED;
76192:     } else {
76192:         rejoin = (RejoinState) (jsrejoin >> 1);
76192:     }
76192: 
76192:     JSContext *cx = f.cx;
76192:     StackFrame *fp = f.regs.fp();
76192:     JSScript *script = fp->script();
76192: 
76192:     jsbytecode *pc = f.regs.pc;
76192:     analyze::UntrapOpcode untrap(cx, script, pc);
76192: 
76192:     JSOp op = JSOp(*pc);
76192:     const JSCodeSpec *cs = &js_CodeSpec[op];
76192: 
76192:     analyze::AutoEnterAnalysis enter(cx);
76192: 
76192:     analyze::ScriptAnalysis *analysis = script->analysis(cx);
76192:     if (analysis && !analysis->ranBytecode())
76192:         analysis->analyzeBytecode(cx);
76192:     if (!analysis || analysis->OOM()) {
76192:         js_ReportOutOfMemory(cx);
76192:         return js_InternalThrow(f);
76192:     }
76192: 
76192:     /*
76192:      * f.regs.sp is not normally maintained by stubs (except for call prologues
76192:      * where it indicates the new frame), so is not expected to be coherent
76192:      * here. Update it to its value at the start of the opcode.
76192:      */
76192:     Value *oldsp = f.regs.sp;
76192:     f.regs.sp = fp->base() + analysis->getCode(pc).stackDepth;
76192: 
76192:     jsbytecode *nextpc = pc + analyze::GetBytecodeLength(pc);
76192:     Value *nextsp = NULL;
76192:     if (nextpc != script->code + script->length)
76192:         nextsp = fp->base() + analysis->getCode(nextpc).stackDepth;
76192: 
76192:     JS_ASSERT(&cx->regs() == &f.regs);
76192: 
76192: #ifdef JS_METHODJIT_SPEW
76192:     JaegerSpew(JSpew_Recompile, "interpreter rejoin (file \"%s\") (line \"%d\") (op %s) (opline \"%d\")\n",
76192:                script->filename, script->lineno, OpcodeNames[op], js_PCToLineNumber(cx, script, pc));
76192: #endif
76192: 
76192:     uint32 nextDepth = uint32(-1);
77341:     bool skipTrap = false;
76192: 
76192:     if ((cs->format & (JOF_INC | JOF_DEC)) &&
77357:         (rejoin == REJOIN_POS || rejoin == REJOIN_BINARY)) {
77357:         /*
77357:          * We may reenter the interpreter while finishing the INC/DEC operation
77357:          * on a local or arg (property INC/DEC operations will rejoin into the
77357:          * decomposed version of the op.
77357:          */
77357:         JS_ASSERT(cs->format & (JOF_LOCAL | JOF_QARG));
77357: 
76192:         nextDepth = analysis->getCode(nextpc).stackDepth;
76192:         untrap.retrap();
76192:         enter.leave();
76192: 
76192:         if (rejoin != REJOIN_BINARY || !analysis->incrementInitialValueObserved(pc)) {
76192:             /* Stack layout is 'V', 'N' or 'N+1' (only if the N is not needed) */
76192:             FinishVarIncOp(f, rejoin, nextsp[-1], nextsp[-1], &nextsp[-1]);
76192:         } else {
76192:             /* Stack layout is 'N N+1' */
76192:             FinishVarIncOp(f, rejoin, nextsp[-1], nextsp[0], &nextsp[-1]);
76192:         }
76192: 
76192:         rejoin = REJOIN_FALLTHROUGH;
76192:     }
76192: 
76192:     switch (rejoin) {
76192:       case REJOIN_SCRIPTED: {
76192: #ifdef JS_NUNBOX32
76192:         uint64 rvalBits = ((uint64)returnType << 32) | (uint32)returnData;
76192: #elif JS_PUNBOX64
76192:         uint64 rvalBits = (uint64)returnType | (uint64)returnData;
76192: #else
76192: #error "Unknown boxing format"
76192: #endif
76192:         nextsp[-1].setRawBits(rvalBits);
76192: 
76192:         /*
76192:          * When making a scripted call at monitored sites, it is the caller's
76192:          * responsibility to update the pushed type set.
76192:          */
76192:         script->types.monitor(cx, pc, nextsp[-1]);
76192:         f.regs.pc = nextpc;
76192:         break;
76192:       }
76192: 
76192:       case REJOIN_NONE:
76192:         JS_NOT_REACHED("Unpossible rejoin!");
76192:         break;
76192: 
76192:       case REJOIN_RESUME:
76192:         break;
76192: 
76192:       case REJOIN_TRAP:
77341:         /*
77341:          * Make sure when resuming in the interpreter we do not execute the
77341:          * trap again. Watch out for the case where the TRAP removed itself.
77341:          */
77341:         if (untrap.trap)
77341:             skipTrap = true;
76192:         break;
76192: 
76192:       case REJOIN_FALLTHROUGH:
76192:         f.regs.pc = nextpc;
76192:         break;
76192: 
76192:       case REJOIN_NATIVE:
76192:       case REJOIN_NATIVE_LOWERED: {
76192:         /*
76192:          * We don't rejoin until after the native stub finishes execution, in
76192:          * which case the return value will be in memory. For lowered natives,
76192:          * the return value will be in the 'this' value's slot.
76192:          */
76192:         if (rejoin == REJOIN_NATIVE_LOWERED)
76192:             nextsp[-1] = nextsp[0];
76192: 
76192:         /* Release this reference on the orphaned native stub. */
76192:         RemoveOrphanedNative(cx, fp);
76192: 
76192:         /*
76192:          * Note: there is no need to monitor the result of the native, the
76192:          * native stub will always do a type check before finishing.
76192:          */
76192:         f.regs.pc = nextpc;
76192:         break;
76192:       }
76192: 
76192:       case REJOIN_PUSH_BOOLEAN:
76192:         nextsp[-1].setBoolean(returnReg != NULL);
76192:         f.regs.pc = nextpc;
76192:         break;
76192: 
76192:       case REJOIN_PUSH_OBJECT:
76192:         nextsp[-1].setObject(* (JSObject *) returnReg);
76192:         f.regs.pc = nextpc;
76192:         break;
76192: 
76192:       case REJOIN_DEFLOCALFUN:
76192:         fp->slots()[GET_SLOTNO(pc)].setObject(* (JSObject *) returnReg);
76192:         f.regs.pc = nextpc;
76192:         break;
76192: 
76192:       case REJOIN_THIS_PROTOTYPE: {
76192:         JSObject *callee = &fp->callee();
76192:         JSObject *proto = f.regs.sp[0].isObject() ? &f.regs.sp[0].toObject() : NULL;
76192:         JSObject *obj = js_CreateThisForFunctionWithProto(cx, callee, proto);
76192:         if (!obj)
76192:             return js_InternalThrow(f);
76192:         fp->formalArgs()[-1].setObject(*obj);
76192: 
76192:         if (script->debugMode || Probes::callTrackingActive(cx))
76192:             js::ScriptDebugPrologue(cx, fp);
76192:         break;
76192:       }
76192: 
76192:       case REJOIN_CHECK_ARGUMENTS: {
76192:         /*
76192:          * Do all the work needed in arity check JIT prologues after the
76192:          * arguments check occurs (FixupArity has been called if needed, but
76192:          * the stack check and late prologue have not been performed.
76192:          */
76192:         if (!CheckStackQuota(f))
76192:             return js_InternalThrow(f);
77356: 
77356:         SetValueRangeToUndefined(fp->slots(), script->nfixed);
77356: 
76192:         if (fp->fun()->isHeavyweight()) {
76192:             if (!js::CreateFunCallObject(cx, fp))
76192:                 return js_InternalThrow(f);
76192:         }
77341: 
77356:         /* FALLTHROUGH */
77356:       }
77356: 
77356:       case REJOIN_CREATE_CALL_OBJECT: {
77341:         fp->scopeChain();
76192: 
77341:         /* Construct the 'this' object for the frame if necessary. */
77341:         if (!ScriptPrologueOrGeneratorResume(cx, fp, types::UseNewTypeAtEntry(cx, fp)))
77341:             return js_InternalThrow(f);
76192:         break;
76192:       }
76192: 
76192:       case REJOIN_CALL_PROLOGUE:
76192:       case REJOIN_CALL_PROLOGUE_LOWERED_CALL:
76192:       case REJOIN_CALL_PROLOGUE_LOWERED_APPLY:
76192:         if (returnReg) {
76192:             uint32 argc = 0;
76192:             if (rejoin == REJOIN_CALL_PROLOGUE)
76192:                 argc = GET_ARGC(pc);
76192:             else if (rejoin == REJOIN_CALL_PROLOGUE_LOWERED_CALL)
76192:                 argc = GET_ARGC(pc) - 1;
76192:             else
76192:                 argc = f.u.call.dynamicArgc;
76192: 
76192:             /*
76192:              * The caller frame's code was discarded, but we still need to
76192:              * execute the callee and have a JIT code pointer to do so.
76192:              * Set the argc and frame registers as the call path does, but set
76192:              * the callee frame's return address to jump back into the
76192:              * Interpoline, and change the caller frame's rejoin to reflect the
76192:              * state after the call.
76192:              */
76192:             f.regs.restorePartialFrame(oldsp); /* f.regs.sp stored the new frame */
76192:             f.scratch = (void *) argc;         /* The interpoline will load f.scratch into argc */
76192:             f.fp()->setNativeReturnAddress(JS_FUNC_TO_DATA_PTR(void *, JaegerInterpolineScripted));
76192:             fp->setRejoin(REJOIN_SCRIPTED | ((pc - script->code) << 1));
76192:             return returnReg;
76192:         } else {
76192:             /*
76192:              * The call has already finished, and the return value is on the
76192:              * stack. For lowered call/apply, the return value has been stored
76192:              * in the wrong slot, so adjust it here.
76192:              */
76192:             f.regs.pc = nextpc;
76192:             if (rejoin != REJOIN_CALL_PROLOGUE) {
76192:                 /* Same offset return value as for lowered native calls. */
76192:                 nextsp[-1] = nextsp[0];
76192:             }
76192:         }
76192:         break;
76192: 
76192:       case REJOIN_CALL_SPLAT: {
76192:         /* Leave analysis early and do the Invoke which SplatApplyArgs prepared. */
76192:         nextDepth = analysis->getCode(nextpc).stackDepth;
76192:         untrap.retrap();
76192:         enter.leave();
76192:         f.regs.sp = nextsp + 2 + f.u.call.dynamicArgc;
76192:         if (!Invoke(cx, CallArgsFromSp(f.u.call.dynamicArgc, f.regs.sp)))
76192:             return js_InternalThrow(f);
76192:         nextsp[-1] = nextsp[0];
76192:         f.regs.pc = nextpc;
76192:         break;
76192:       }
76192: 
76192:       case REJOIN_GETTER:
76192:         /*
76192:          * Match the PC to figure out whether this property fetch is part of a
76192:          * fused opcode which needs to be finished.
76192:          */
76192:         switch (op) {
76192:           case JSOP_NAME:
76192:           case JSOP_GETGNAME:
76192:           case JSOP_GETGLOBAL:
76192:           case JSOP_GETPROP:
76192:           case JSOP_GETXPROP:
76192:           case JSOP_LENGTH:
76192:             /* Non-fused opcode, state is already correct for the next op. */
76192:             f.regs.pc = nextpc;
76192:             break;
76192: 
76192:           case JSOP_CALLGNAME:
76192:             if (!ComputeImplicitThis(cx, &fp->scopeChain(), nextsp[-2], &nextsp[-1]))
76192:                 return js_InternalThrow(f);
76192:             f.regs.pc = nextpc;
76192:             break;
76192: 
76192:           case JSOP_CALLGLOBAL:
76192:             /* |this| is always undefined for CALLGLOBAL. */
76192:             nextsp[-1].setUndefined();
76192:             f.regs.pc = nextpc;
76192:             break;
76192: 
76192:           case JSOP_CALLPROP: {
76192:             /*
76192:              * CALLPROP is compiled in terms of GETPROP for known strings.
76192:              * In such cases the top two entries are in place, but are swapped.
76192:              */
76192:             JS_ASSERT(nextsp[-2].isString());
76192:             Value tmp = nextsp[-2];
76192:             nextsp[-2] = nextsp[-1];
76192:             nextsp[-1] = tmp;
76192:             f.regs.pc = nextpc;
76192:             break;
76192:           }
76192: 
76192:           case JSOP_INSTANCEOF: {
76192:             /*
76192:              * If we recompiled from a getprop used within JSOP_INSTANCEOF,
76192:              * the stack looks like 'LHS RHS protov'. Inline the remaining
76192:              * portion of fun_hasInstance.
76192:              */
76192:             if (f.regs.sp[0].isPrimitive()) {
76192:                 js_ReportValueError(cx, JSMSG_BAD_PROTOTYPE, -1, f.regs.sp[-1], NULL);
76192:                 return js_InternalThrow(f);
76192:             }
76192:             nextsp[-1].setBoolean(js_IsDelegate(cx, &f.regs.sp[0].toObject(), f.regs.sp[-2]));
76192:             f.regs.pc = nextpc;
76192:             break;
76192:           }
76192: 
76192:           default:
76192:             JS_NOT_REACHED("Bad rejoin getter op");
76192:         }
76192:         break;
76192: 
76192:       case REJOIN_POS:
76192:         /* Convert-to-number which might be part of an INC* op. */
76192:         JS_ASSERT(op == JSOP_POS);
76192:         f.regs.pc = nextpc;
76192:         break;
76192: 
76192:       case REJOIN_BINARY:
76192:         /* Binary arithmetic op which might be part of an INC* op. */
76192:         JS_ASSERT(op == JSOP_ADD || op == JSOP_SUB || op == JSOP_MUL || op == JSOP_DIV);
76192:         f.regs.pc = nextpc;
76192:         break;
76192: 
76192:       case REJOIN_BRANCH: {
76192:         /*
76192:          * This must be an opcode fused with IFNE/IFEQ. Unfused IFNE/IFEQ are
76192:          * implemented in terms of ValueToBoolean, which is infallible and
76192:          * cannot trigger recompilation.
76192:          */
76192:         bool takeBranch = false;
76192:         analyze::UntrapOpcode untrap(cx, script, nextpc);
76192:         switch (JSOp(*nextpc)) {
76192:           case JSOP_IFNE:
76192:           case JSOP_IFNEX:
76192:             takeBranch = returnReg != NULL;
76192:             break;
76192:           case JSOP_IFEQ:
76192:           case JSOP_IFEQX:
76192:             takeBranch = returnReg == NULL;
76192:             break;
76192:           default:
76192:             JS_NOT_REACHED("Bad branch op");
76192:         }
76192:         if (takeBranch)
76192:             f.regs.pc = nextpc + GET_JUMP_OFFSET(nextpc);
76192:         else
76192:             f.regs.pc = nextpc + analyze::GetBytecodeLength(nextpc);
76192:         break;
76192:       }
76192: 
76192:       default:
76192:         JS_NOT_REACHED("Missing rejoin");
76192:     }
76192: 
76192:     if (nextDepth == uint32(-1))
76192:         nextDepth = analysis->getCode(f.regs.pc).stackDepth;
76192:     f.regs.sp = fp->base() + nextDepth;
76192: 
77341:     /* Mark the entry frame as unfinished, and update the regs to resume at. */
77341:     JaegerStatus status = skipTrap ? Jaeger_UnfinishedAtTrap : Jaeger_Unfinished;
77341:     cx->compartment->jaegerCompartment()->setLastUnfinished(status);
77341:     *f.oldregs = f.regs;
76192: 
77341:     return NULL;
76192: }
