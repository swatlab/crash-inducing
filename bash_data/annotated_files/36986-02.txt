    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * Implementation of the DOM nsIDOMRange object.
    1:  */
    1: 
    1: #include "nscore.h"
    1: #include "nsRange.h"
    1: 
    1: #include "nsString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMNSDocument.h"
    1: #include "nsIDOMDocumentFragment.h"
    1: #include "nsIContent.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMText.h"
    1: #include "nsDOMError.h"
    1: #include "nsIContentIterator.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsContentUtils.h"
16205: #include "nsGenericDOMDataNode.h"
33027: #include "nsClientRect.h"
33027: #include "nsLayoutUtils.h"
33027: #include "nsTextFrame.h"
    1: 
    1: nsresult NS_NewContentIterator(nsIContentIterator** aInstancePtrResult);
    1: nsresult NS_NewContentSubtreeIterator(nsIContentIterator** aInstancePtrResult);
    1: 
    1: /******************************************************
    1:  * stack based utilty class for managing monitor
    1:  ******************************************************/
    1: 
    1: // NS_ERROR_DOM_NOT_OBJECT_ERR is not the correct one to throw, but spec doesn't say
    1: // what is
    1: #define VALIDATE_ACCESS(node_)                                                     \
    1:   PR_BEGIN_MACRO                                                                   \
    1:     if (!node_) {                                                                  \
    1:       return NS_ERROR_DOM_NOT_OBJECT_ERR;                                          \
    1:     }                                                                              \
    1:     if (!nsContentUtils::CanCallerAccess(node_)) {                                 \
    1:       return NS_ERROR_DOM_SECURITY_ERR;                                            \
    1:     }                                                                              \
    1:     if (mIsDetached) {                                                             \
    1:       return NS_ERROR_DOM_INVALID_STATE_ERR;                                       \
    1:     }                                                                              \
    1:   PR_END_MACRO
    1: 
    1: // Utility routine to detect if a content node is completely contained in a range
    1: // If outNodeBefore is returned true, then the node starts before the range does.
    1: // If outNodeAfter is returned true, then the node ends after the range does.
    1: // Note that both of the above might be true.
    1: // If neither are true, the node is contained inside of the range.
    1: // XXX - callers responsibility to ensure node in same doc as range! 
    1: 
    1: // static
    1: nsresult
20503: nsRange::CompareNodeToRange(nsINode* aNode, nsIDOMRange* aRange,
    1:                             PRBool *outNodeBefore, PRBool *outNodeAfter)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsIRange> range = do_QueryInterface(aRange, &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return CompareNodeToRange(aNode, range, outNodeBefore, outNodeAfter);
    1: }
    1: 
    1: // static
    1: nsresult
20503: nsRange::CompareNodeToRange(nsINode* aNode, nsIRange* aRange,
    1:                             PRBool *outNodeBefore, PRBool *outNodeAfter)
    1: {
12178:   NS_ENSURE_STATE(aNode);
    1:   // create a pair of dom points that expresses location of node:
    1:   //     NODE(start), NODE(end)
    1:   // Let incoming range be:
    1:   //    {RANGE(start), RANGE(end)}
    1:   // if (RANGE(start) <= NODE(start))  and (RANGE(end) => NODE(end))
    1:   // then the Node is contained (completely) by the Range.
    1:   
26992:   if (!aRange || !aRange->IsPositioned()) 
    1:     return NS_ERROR_UNEXPECTED; 
    1:   
    1:   // gather up the dom point info
    1:   PRInt32 nodeStart, nodeEnd;
    1:   nsINode* parent = aNode->GetNodeParent();
    1:   if (!parent) {
    1:     // can't make a parent/offset pair to represent start or 
20503:     // end of the root node, because it has no parent.
    1:     // so instead represent it by (node,0) and (node,numChildren)
    1:     parent = aNode;
    1:     nodeStart = 0;
    1:     nodeEnd = aNode->GetChildCount();
    1:   }
    1:   else {
    1:     nodeStart = parent->IndexOf(aNode);
    1:     nodeEnd = nodeStart + 1;
    1:   }
    1: 
26992:   nsINode* rangeStartParent = aRange->GetStartParent();
26992:   nsINode* rangeEndParent = aRange->GetEndParent();
26992:   PRInt32 rangeStartOffset = aRange->StartOffset();
26992:   PRInt32 rangeEndOffset = aRange->EndOffset();
    1: 
    1:   // is RANGE(start) <= NODE(start) ?
12178:   PRBool disconnected = PR_FALSE;
    1:   *outNodeBefore = nsContentUtils::ComparePoints(rangeStartParent,
    1:                                                  rangeStartOffset,
12178:                                                  parent, nodeStart,
12178:                                                  &disconnected) > 0;
12178:   NS_ENSURE_TRUE(!disconnected, NS_ERROR_DOM_WRONG_DOCUMENT_ERR);
12178: 
    1:   // is RANGE(end) >= NODE(end) ?
    1:   *outNodeAfter = nsContentUtils::ComparePoints(rangeEndParent,
    1:                                                 rangeEndOffset,
12178:                                                 parent, nodeEnd,
12178:                                                 &disconnected) < 0;
12178:   NS_ENSURE_TRUE(!disconnected, NS_ERROR_DOM_WRONG_DOCUMENT_ERR);
    1:   return NS_OK;
    1: }
    1: 
    1: /******************************************************
    1:  * non members
    1:  ******************************************************/
    1: 
    1: nsresult
    1: NS_NewRangeUtils(nsIRangeUtils** aResult)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aResult);
    1: 
    1:   nsRangeUtils* rangeUtil = new nsRangeUtils();
    1:   if (!rangeUtil) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   return CallQueryInterface(rangeUtil, aResult);
    1: }
    1: 
    1: /******************************************************
    1:  * nsISupports
    1:  ******************************************************/
    1: NS_IMPL_ISUPPORTS1(nsRangeUtils, nsIRangeUtils)
    1: 
    1: /******************************************************
    1:  * nsIRangeUtils methods
    1:  ******************************************************/
    1:  
    1: NS_IMETHODIMP_(PRInt32) 
    1: nsRangeUtils::ComparePoints(nsIDOMNode* aParent1, PRInt32 aOffset1,
    1:                             nsIDOMNode* aParent2, PRInt32 aOffset2)
    1: {
    1:   nsCOMPtr<nsINode> parent1 = do_QueryInterface(aParent1);
    1:   nsCOMPtr<nsINode> parent2 = do_QueryInterface(aParent2);
    1: 
    1:   NS_ENSURE_TRUE(parent1 && parent2, -1);
    1: 
    1:   return nsContentUtils::ComparePoints(parent1, aOffset1, parent2, aOffset2);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsRangeUtils::CompareNodeToRange(nsIContent* aNode, nsIDOMRange* aRange,
    1:                                  PRBool *outNodeBefore, PRBool *outNodeAfter)
    1: {
    1:   return nsRange::CompareNodeToRange(aNode, aRange, outNodeBefore,
    1:                                      outNodeAfter);
    1: }
    1: 
    1: /******************************************************
    1:  * non members
    1:  ******************************************************/
    1: 
    1: nsresult
    1: NS_NewRange(nsIDOMRange** aResult)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aResult);
    1: 
    1:   nsRange * range = new nsRange();
    1:   if (!range) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   return CallQueryInterface(range, aResult);
    1: }
    1: 
    1: /******************************************************
    1:  * constructor/destructor
    1:  ******************************************************/
    1: 
    1: nsRange::~nsRange() 
    1: {
    1:   DoSetRange(nsnull, 0, nsnull, 0, nsnull);
    1:   // we want the side effects (releases and list removals)
    1: } 
    1: 
    1: /******************************************************
    1:  * nsISupports
    1:  ******************************************************/
    1: 
22215: NS_IMPL_CYCLE_COLLECTION_CLASS(nsRange)
22215: 
22215: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsRange)
22215: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsRange)
22215: 
    1: // QueryInterface implementation for nsRange
22215: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsRange)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMRange)
    1:   NS_INTERFACE_MAP_ENTRY(nsIRange)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMNSRange)
    1:   NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIRange)
    1:   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(Range)
    1: NS_INTERFACE_MAP_END
    1: 
22215: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsRange)
22215:   tmp->Reset();
22215: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
22215: 
22215: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsRange)
22215:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mStartParent)
22215:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mEndParent)
22216:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mRoot)
22215: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
    1: /******************************************************
    1:  * nsIMutationObserver implementation
    1:  ******************************************************/
    1: 
    1: void
    1: nsRange::CharacterDataChanged(nsIDocument* aDocument,
    1:                               nsIContent* aContent,
    1:                               CharacterDataChangeInfo* aInfo)
    1: {
    1:   NS_ASSERTION(mIsPositioned, "shouldn't be notified if not positioned");
    1: 
11516:   // If the changed node contains our start boundary and the change starts
11516:   // before the boundary we'll need to adjust the offset.
    1:   if (aContent == mStartParent &&
    1:       aInfo->mChangeStart < (PRUint32)mStartOffset) {
11516:     // If boundary is inside changed text, position it before change
    1:     // else adjust start offset for the change in length
11516:     mStartOffset = (PRUint32)mStartOffset <= aInfo->mChangeEnd ?
    1:        aInfo->mChangeStart :
    1:        mStartOffset + aInfo->mChangeStart - aInfo->mChangeEnd +
    1:          aInfo->mReplaceLength;
    1:   }
    1: 
11516:   // Do the same thing for the end boundary.
    1:   if (aContent == mEndParent && aInfo->mChangeStart < (PRUint32)mEndOffset) {
11516:     mEndOffset = (PRUint32)mEndOffset <= aInfo->mChangeEnd ?
    1:        aInfo->mChangeStart :
    1:        mEndOffset + aInfo->mChangeStart - aInfo->mChangeEnd +
    1:          aInfo->mReplaceLength;
    1:   }
    1: }
    1: 
    1: void
    1: nsRange::ContentInserted(nsIDocument* aDocument,
    1:                          nsIContent* aContainer,
    1:                          nsIContent* aChild,
    1:                          PRInt32 aIndexInContainer)
    1: {
    1:   NS_ASSERTION(mIsPositioned, "shouldn't be notified if not positioned");
    1: 
    1:   nsINode* container = NODE_FROM(aContainer, aDocument);
    1: 
    1:   // Adjust position if a sibling was inserted.
    1:   if (container == mStartParent && aIndexInContainer < mStartOffset) {
    1:     ++mStartOffset;
    1:   }
    1:   if (container == mEndParent && aIndexInContainer < mEndOffset) {
    1:     ++mEndOffset;
    1:   }
    1: }
    1: 
    1: void
    1: nsRange::ContentRemoved(nsIDocument* aDocument,
    1:                         nsIContent* aContainer,
    1:                         nsIContent* aChild,
    1:                         PRInt32 aIndexInContainer)
    1: {
    1:   NS_ASSERTION(mIsPositioned, "shouldn't be notified if not positioned");
    1: 
    1:   nsINode* container = NODE_FROM(aContainer, aDocument);
    1: 
    1:   // Adjust position if a sibling was removed...
30712:   if (container == mStartParent) {
30712:     if (aIndexInContainer < mStartOffset) {
    1:       --mStartOffset;
    1:     }
30712:   }
    1:   // ...or gravitate if an ancestor was removed.
    1:   else if (nsContentUtils::ContentIsDescendantOf(mStartParent, aChild)) {
    1:     mStartParent = container;
    1:     mStartOffset = aIndexInContainer;
    1:   }
    1: 
    1:   // Do same thing for end boundry.
30712:   if (container == mEndParent) {
30712:     if (aIndexInContainer < mEndOffset) {
    1:       --mEndOffset;
    1:     }
30712:   }
    1:   else if (nsContentUtils::ContentIsDescendantOf(mEndParent, aChild)) {
    1:     mEndParent = container;
    1:     mEndOffset = aIndexInContainer;
    1:   }
    1: }
    1: 
    1: void
12178: nsRange::ParentChainChanged(nsIContent *aContent)
12178: {
12178:   NS_ASSERTION(mRoot == aContent, "Wrong ParentChainChanged notification?");
13002:   nsINode* newRoot = IsValidBoundary(mStartParent);
13002:   NS_ASSERTION(newRoot, "No valid boundary or root found!");
13002:   NS_ASSERTION(newRoot == IsValidBoundary(mEndParent),
13002:                "Start parent and end parent give different root!");
12178:   DoSetRange(mStartParent, mStartOffset, mEndParent, mEndOffset, newRoot);
12178: }
12178: 
    1: /********************************************************
    1:  * Utilities for comparing points: API from nsIDOMNSRange
    1:  ********************************************************/
    1: NS_IMETHODIMP
    1: nsRange::IsPointInRange(nsIDOMNode* aParent, PRInt32 aOffset, PRBool* aResult)
    1: {
    1:   PRInt16 compareResult = 0;
    1:   nsresult rv = ComparePoint(aParent, aOffset, &compareResult);
 8394:   // If the node isn't in the range's document, it clearly isn't in the range.
 8394:   if (rv == NS_ERROR_DOM_WRONG_DOCUMENT_ERR) {
 8394:     *aResult = PR_FALSE;
 8394:     return NS_OK;
 8394:   }
 8394: 
    1:   *aResult = compareResult == 0;
    1: 
    1:   return rv;
    1: }
    1:   
    1: // returns -1 if point is before range, 0 if point is in range,
    1: // 1 if point is after range.
    1: NS_IMETHODIMP
    1: nsRange::ComparePoint(nsIDOMNode* aParent, PRInt32 aOffset, PRInt16* aResult)
    1: {
    1:   if (mIsDetached)
    1:     return NS_ERROR_DOM_INVALID_STATE_ERR;
    1: 
    1:   // our range is in a good state?
    1:   if (!mIsPositioned) 
    1:     return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   nsCOMPtr<nsINode> parent = do_QueryInterface(aParent);
    1:   NS_ENSURE_TRUE(parent, NS_ERROR_DOM_HIERARCHY_REQUEST_ERR);
    1: 
    1:   if (!nsContentUtils::ContentIsDescendantOf(parent, mRoot)) {
    1:     return NS_ERROR_DOM_WRONG_DOCUMENT_ERR;
    1:   }
    1:   
    1:   PRInt32 cmp;
    1:   if ((cmp = nsContentUtils::ComparePoints(parent, aOffset,
    1:                                            mStartParent, mStartOffset)) <= 0) {
    1:     
    1:     *aResult = cmp;
    1:   }
    1:   else if (nsContentUtils::ComparePoints(mEndParent, mEndOffset,
20634:                                          parent, aOffset) == -1) {
    1:     *aResult = 1;
    1:   }
    1:   else {
    1:     *aResult = 0;
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1:   
    1: /******************************************************
    1:  * Private helper routines
    1:  ******************************************************/
    1: 
    1: // Get the length of aNode
26992: static PRUint32 GetNodeLength(nsINode *aNode)
    1: {
    1:   if(aNode->IsNodeOfType(nsINode::eDATA_NODE)) {
 3233:     return static_cast<nsIContent*>(aNode)->TextLength();
    1:   }
    1: 
    1:   return aNode->GetChildCount();
    1: }
    1: 
    1: // It's important that all setting of the range start/end points 
    1: // go through this function, which will do all the right voodoo
    1: // for content notification of range ownership.  
    1: // Calling DoSetRange with either parent argument null will collapse
    1: // the range to have both endpoints point to the other node
    1: void
    1: nsRange::DoSetRange(nsINode* aStartN, PRInt32 aStartOffset,
    1:                     nsINode* aEndN, PRInt32 aEndOffset,
    1:                     nsINode* aRoot)
    1: {
    1:   NS_PRECONDITION((aStartN && aEndN && aRoot) ||
    1:                   (!aStartN && !aEndN && !aRoot),
    1:                   "Set all or none");
    1:   NS_PRECONDITION(!aRoot ||
    1:                   (nsContentUtils::ContentIsDescendantOf(aStartN, aRoot) &&
    1:                    nsContentUtils::ContentIsDescendantOf(aEndN, aRoot) &&
    1:                    aRoot == IsValidBoundary(aStartN) &&
    1:                    aRoot == IsValidBoundary(aEndN)),
    1:                   "Wrong root");
    1:   NS_PRECONDITION(!aRoot ||
    1:                   (aStartN->IsNodeOfType(nsINode::eCONTENT) &&
    1:                    aEndN->IsNodeOfType(nsINode::eCONTENT) &&
    1:                    aRoot ==
 3233:                     static_cast<nsIContent*>(aStartN)->GetBindingParent() &&
    1:                    aRoot ==
 3233:                     static_cast<nsIContent*>(aEndN)->GetBindingParent()) ||
    1:                   (!aRoot->GetNodeParent() &&
    1:                    (aRoot->IsNodeOfType(nsINode::eDOCUMENT) ||
    1:                     aRoot->IsNodeOfType(nsINode::eATTRIBUTE) ||
12178:                     aRoot->IsNodeOfType(nsINode::eDOCUMENT_FRAGMENT) ||
12178:                      /*For backward compatibility*/
12178:                     aRoot->IsNodeOfType(nsINode::eCONTENT))),
    1:                   "Bad root");
    1: 
    1:   if (mRoot != aRoot) {
    1:     if (mRoot) {
    1:       mRoot->RemoveMutationObserver(this);
    1:     }
    1:     if (aRoot) {
    1:       aRoot->AddMutationObserver(this);
    1:     }
    1:   }
    1:  
    1:   mStartParent = aStartN;
    1:   mStartOffset = aStartOffset;
    1:   mEndParent = aEndN;
    1:   mEndOffset = aEndOffset;
    1:   mIsPositioned = !!mStartParent;
    1:   mRoot = aRoot;
    1: }
    1: 
    1: static PRInt32
    1: IndexOf(nsIDOMNode* aChildNode)
    1: {
    1:   // convert node to nsIContent, so that we can find the child index
    1: 
    1:   nsCOMPtr<nsINode> child = do_QueryInterface(aChildNode);
    1:   if (!child) {
    1:     return -1;
    1:   }
    1: 
    1:   nsINode *parent = child->GetNodeParent();
    1: 
    1:   // finally we get the index
    1:   return parent ? parent->IndexOf(child) : -1;
    1: }
    1: 
    1: /******************************************************
    1:  * nsIRange implementation
    1:  ******************************************************/
    1: 
    1: nsINode*
26993: nsRange::GetCommonAncestor() const
    1: {
    1:   return mIsPositioned ?
    1:     nsContentUtils::GetCommonAncestor(mStartParent, mEndParent) :
    1:     nsnull;
    1: }
    1: 
    1: void
    1: nsRange::Reset()
    1: {
    1:   DoSetRange(nsnull, 0, nsnull, 0, nsnull);
    1: }
    1: 
    1: /******************************************************
    1:  * public functionality
    1:  ******************************************************/
    1: 
    1: nsresult nsRange::GetStartContainer(nsIDOMNode** aStartParent)
    1: {
    1:   if (!mIsPositioned)
    1:     return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   return CallQueryInterface(mStartParent, aStartParent);
    1: }
    1: 
    1: nsresult nsRange::GetStartOffset(PRInt32* aStartOffset)
    1: {
    1:   if (!mIsPositioned)
    1:     return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   *aStartOffset = mStartOffset;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsRange::GetEndContainer(nsIDOMNode** aEndParent)
    1: {
    1:   if (!mIsPositioned)
    1:     return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   return CallQueryInterface(mEndParent, aEndParent);
    1: }
    1: 
    1: nsresult nsRange::GetEndOffset(PRInt32* aEndOffset)
    1: {
    1:   if (!mIsPositioned)
    1:     return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   *aEndOffset = mEndOffset;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsRange::GetCollapsed(PRBool* aIsCollapsed)
    1: {
    1:   if(mIsDetached)
    1:     return NS_ERROR_DOM_INVALID_STATE_ERR;
    1:   if (!mIsPositioned)
    1:     return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   *aIsCollapsed = Collapsed();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsRange::GetCommonAncestorContainer(nsIDOMNode** aCommonParent)
    1: {
    1:   *aCommonParent = nsnull;
    1:   if(mIsDetached)
    1:     return NS_ERROR_DOM_INVALID_STATE_ERR;
    1:   if (!mIsPositioned)
    1:     return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   nsINode* container = nsContentUtils::GetCommonAncestor(mStartParent, mEndParent);
    1:   if (container) {
    1:     return CallQueryInterface(container, aCommonParent);
    1:   }
    1: 
    1:   return NS_ERROR_NOT_INITIALIZED;
    1: }
    1: 
 2561: nsINode* nsRange::IsValidBoundary(nsINode* aNode)
    1: {
    1:   if (!aNode) {
    1:     return nsnull;
    1:   }
    1: 
    1:   if (aNode->IsNodeOfType(nsINode::eCONTENT)) {
 3233:     nsIContent* content = static_cast<nsIContent*>(aNode);
    1:     if (content->Tag() == nsGkAtoms::documentTypeNodeName) {
    1:       return nsnull;
    1:     }
    1: 
 2561:     if (!mMaySpanAnonymousSubtrees) {
    1:       // If the node has a binding parent, that should be the root.
    1:       // XXXbz maybe only for native anonymous content?
    1:       nsINode* root = content->GetBindingParent();
    1:       if (root) {
    1:         return root;
    1:       }
    1:     }
 2561:   }
    1: 
    1:   // Elements etc. must be in document or in document fragment,
    1:   // text nodes in document, in document fragment or in attribute.
    1:   nsINode* root = aNode->GetCurrentDoc();
    1:   if (root) {
    1:     return root;
    1:   }
    1: 
    1:   root = aNode;
    1:   while ((aNode = aNode->GetNodeParent())) {
    1:     root = aNode;
    1:   }
    1: 
    1:   NS_ASSERTION(!root->IsNodeOfType(nsINode::eDOCUMENT),
    1:                "GetCurrentDoc should have returned a doc");
    1: 
    1: #ifdef DEBUG_smaug
12178:   NS_WARN_IF_FALSE(root->IsNodeOfType(nsINode::eDOCUMENT_FRAGMENT) ||
12178:                    root->IsNodeOfType(nsINode::eATTRIBUTE),
12178:                    "Creating a DOM Range using root which isn't in DOM!");
    1: #endif
    1: 
12178:   // We allow this because of backward compatibility.
12178:   return root;
    1: }
    1: 
    1: nsresult nsRange::SetStart(nsIDOMNode* aParent, PRInt32 aOffset)
    1: {
    1:   VALIDATE_ACCESS(aParent);
    1: 
    1:   nsCOMPtr<nsINode> parent = do_QueryInterface(aParent);
26992:   return SetStart(parent, aOffset);
26992: }
26992: 
26992: nsresult nsRange::SetStart(nsINode* aParent, PRInt32 aOffset)
26992: {
26992:   nsINode* newRoot = IsValidBoundary(aParent);
    1:   NS_ENSURE_TRUE(newRoot, NS_ERROR_DOM_RANGE_INVALID_NODE_TYPE_ERR);
    1: 
26992:   PRInt32 len = GetNodeLength(aParent);
    1:   if (aOffset < 0 || aOffset > len)
    1:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
    1: 
    1:   // Collapse if not positioned yet, if positioned in another doc or
    1:   // if the new start is after end.
    1:   if (!mIsPositioned || newRoot != mRoot ||
26992:       nsContentUtils::ComparePoints(aParent, aOffset,
    1:                                     mEndParent, mEndOffset) == 1) {
26992:     DoSetRange(aParent, aOffset, aParent, aOffset, newRoot);
    1: 
    1:     return NS_OK;
    1:   }
    1: 
26992:   DoSetRange(aParent, aOffset, mEndParent, mEndOffset, mRoot);
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsRange::SetStartBefore(nsIDOMNode* aSibling)
    1: {
    1:   VALIDATE_ACCESS(aSibling);
    1:   
    1:   nsCOMPtr<nsIDOMNode> parent;
    1:   nsresult rv = aSibling->GetParentNode(getter_AddRefs(parent));
    1:   if (NS_FAILED(rv) || !parent) {
    1:     return NS_ERROR_DOM_RANGE_INVALID_NODE_TYPE_ERR;
    1:   }
    1: 
    1:   return SetStart(parent, IndexOf(aSibling));
    1: }
    1: 
    1: nsresult nsRange::SetStartAfter(nsIDOMNode* aSibling)
    1: {
    1:   VALIDATE_ACCESS(aSibling);
    1: 
    1:   nsCOMPtr<nsIDOMNode> nParent;
    1:   nsresult res = aSibling->GetParentNode(getter_AddRefs(nParent));
    1:   if (NS_FAILED(res) || !nParent) {
    1:     return NS_ERROR_DOM_RANGE_INVALID_NODE_TYPE_ERR;
    1:   }
    1: 
    1:   return SetStart(nParent, IndexOf(aSibling) + 1);
    1: }
    1: 
    1: nsresult nsRange::SetEnd(nsIDOMNode* aParent, PRInt32 aOffset)
    1: {
    1:   VALIDATE_ACCESS(aParent);
    1: 
    1:   nsCOMPtr<nsINode> parent = do_QueryInterface(aParent);
26992:   return SetEnd(parent, aOffset);
26992: }
26992: 
26992: 
26992: nsresult nsRange::SetEnd(nsINode* aParent, PRInt32 aOffset)
26992: {
26992:   nsINode* newRoot = IsValidBoundary(aParent);
    1:   NS_ENSURE_TRUE(newRoot, NS_ERROR_DOM_RANGE_INVALID_NODE_TYPE_ERR);
    1: 
26992:   PRInt32 len = GetNodeLength(aParent);
    1:   if (aOffset < 0 || aOffset > len) {
    1:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
    1:   }
    1: 
    1:   // Collapse if not positioned yet, if positioned in another doc or
    1:   // if the new end is before start.
    1:   if (!mIsPositioned || newRoot != mRoot ||
    1:       nsContentUtils::ComparePoints(mStartParent, mStartOffset,
26992:                                     aParent, aOffset) == 1) {
26992:     DoSetRange(aParent, aOffset, aParent, aOffset, newRoot);
    1: 
    1:     return NS_OK;
    1:   }
    1: 
26992:   DoSetRange(mStartParent, mStartOffset, aParent, aOffset, mRoot);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsRange::SetEndBefore(nsIDOMNode* aSibling)
    1: {
    1:   VALIDATE_ACCESS(aSibling);
    1:   
    1:   nsCOMPtr<nsIDOMNode> nParent;
    1:   nsresult rv = aSibling->GetParentNode(getter_AddRefs(nParent));
    1:   if (NS_FAILED(rv) || !nParent) {
    1:     return NS_ERROR_DOM_RANGE_INVALID_NODE_TYPE_ERR;
    1:   }
    1: 
    1:   return SetEnd(nParent, IndexOf(aSibling));
    1: }
    1: 
    1: nsresult nsRange::SetEndAfter(nsIDOMNode* aSibling)
    1: {
    1:   VALIDATE_ACCESS(aSibling);
    1:   
    1:   nsCOMPtr<nsIDOMNode> nParent;
    1:   nsresult res = aSibling->GetParentNode(getter_AddRefs(nParent));
    1:   if (NS_FAILED(res) || !nParent) {
    1:     return NS_ERROR_DOM_RANGE_INVALID_NODE_TYPE_ERR;
    1:   }
    1: 
    1:   return SetEnd(nParent, IndexOf(aSibling) + 1);
    1: }
    1: 
    1: nsresult nsRange::Collapse(PRBool aToStart)
    1: {
    1:   if(mIsDetached)
    1:     return NS_ERROR_DOM_INVALID_STATE_ERR;
    1:   if (!mIsPositioned)
    1:     return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   if (aToStart)
    1:     DoSetRange(mStartParent, mStartOffset, mStartParent, mStartOffset, mRoot);
    1:   else
    1:     DoSetRange(mEndParent, mEndOffset, mEndParent, mEndOffset, mRoot);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsRange::SelectNode(nsIDOMNode* aN)
    1: {
    1:   VALIDATE_ACCESS(aN);
    1:   
    1:   nsCOMPtr<nsINode> node = do_QueryInterface(aN);
    1:   NS_ENSURE_TRUE(node, NS_ERROR_DOM_RANGE_INVALID_NODE_TYPE_ERR);
    1: 
    1:   nsINode* parent = node->GetNodeParent();
    1:   nsINode* newRoot = IsValidBoundary(parent);
    1:   NS_ENSURE_TRUE(newRoot, NS_ERROR_DOM_RANGE_INVALID_NODE_TYPE_ERR);
    1: 
    1:   PRInt32 index = parent->IndexOf(node);
    1:   if (index < 0) {
    1:     return NS_ERROR_DOM_RANGE_INVALID_NODE_TYPE_ERR;
    1:   }
    1: 
    1:   DoSetRange(parent, index, parent, index + 1, newRoot);
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsRange::SelectNodeContents(nsIDOMNode* aN)
    1: {
    1:   VALIDATE_ACCESS(aN);
    1: 
    1:   nsCOMPtr<nsINode> node = do_QueryInterface(aN);
    1:   nsINode* newRoot = IsValidBoundary(node);
    1:   NS_ENSURE_TRUE(newRoot, NS_ERROR_DOM_RANGE_INVALID_NODE_TYPE_ERR);
    1:   
    1:   DoSetRange(node, 0, node, GetNodeLength(node), newRoot);
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: // The Subtree Content Iterator only returns subtrees that are
    1: // completely within a given range. It doesn't return a CharacterData
20321: // node that contains either the start or end point of the range.,
20321: // nor does it return element nodes when nothing in the element is selected.
    1: // We need an iterator that will also include these start/end points
    1: // so that our methods/algorithms aren't cluttered with special
    1: // case code that tries to include these points while iterating.
    1: //
    1: // The RangeSubtreeIterator class mimics the nsIContentIterator
    1: // methods we need, so should the Content Iterator support the
    1: // start/end points in the future, we can switchover relatively
    1: // easy.
    1: 
15594: class NS_STACK_CLASS RangeSubtreeIterator
    1: {
    1: private:
    1: 
    1:   enum RangeSubtreeIterState { eDone=0,
20321:                                eUseStart,
    1:                                eUseIterator,
20321:                                eUseEnd };
    1: 
    1:   nsCOMPtr<nsIContentIterator>  mIter;
    1:   RangeSubtreeIterState         mIterState;
    1: 
20321:   nsCOMPtr<nsIDOMNode> mStart;
20321:   nsCOMPtr<nsIDOMNode> mEnd;
    1: 
    1: public:
    1: 
    1:   RangeSubtreeIterator()
    1:     : mIterState(eDone)
    1:   {
    1:   }
    1:   ~RangeSubtreeIterator()
    1:   {
    1:   }
    1: 
    1:   nsresult Init(nsIDOMRange *aRange);
    1:   already_AddRefed<nsIDOMNode> GetCurrentNode();
    1:   void First();
    1:   void Last();
    1:   void Next();
    1:   void Prev();
    1: 
    1:   PRBool IsDone()
    1:   {
    1:     return mIterState == eDone;
    1:   }
    1: };
    1: 
    1: nsresult
    1: RangeSubtreeIterator::Init(nsIDOMRange *aRange)
    1: {
    1:   mIterState = eDone;
20321:   PRBool collapsed;
20321:   aRange->GetCollapsed(&collapsed);
20321:   if (collapsed) {
20321:     return NS_OK;
20321:   }
    1: 
    1:   nsCOMPtr<nsIDOMNode> node;
    1: 
    1:   // Grab the start point of the range and QI it to
    1:   // a CharacterData pointer. If it is CharacterData store
    1:   // a pointer to the node.
    1: 
    1:   nsresult res = aRange->GetStartContainer(getter_AddRefs(node));
    1:   if (!node) return NS_ERROR_FAILURE;
    1: 
20321:   nsCOMPtr<nsIDOMCharacterData> startData = do_QueryInterface(node);
20321:   if (startData) {
20321:     mStart = node;
20321:   } else {
20321:     PRInt32 startIndex;
20321:     aRange->GetStartOffset(&startIndex);
20321:     nsCOMPtr<nsINode> iNode = do_QueryInterface(node);
20321:     if (iNode->IsNodeOfType(nsINode::eELEMENT) && 
20321:         PRInt32(iNode->GetChildCount()) == startIndex) {
20321:       mStart = node;
20321:     }
20321:   }
    1: 
    1:   // Grab the end point of the range and QI it to
    1:   // a CharacterData pointer. If it is CharacterData store
    1:   // a pointer to the node.
    1: 
    1:   res = aRange->GetEndContainer(getter_AddRefs(node));
    1:   if (!node) return NS_ERROR_FAILURE;
    1: 
20321:   nsCOMPtr<nsIDOMCharacterData> endData = do_QueryInterface(node);
20321:   if (endData) {
20321:     mEnd = node;
20321:   } else {
20321:     PRInt32 endIndex;
20321:     aRange->GetEndOffset(&endIndex);
20321:     nsCOMPtr<nsINode> iNode = do_QueryInterface(node);
20321:     if (iNode->IsNodeOfType(nsINode::eELEMENT) && endIndex == 0) {
20321:       mEnd = node;
20321:     }
20321:   }
    1: 
20321:   if (mStart && mStart == mEnd)
    1:   {
    1:     // The range starts and stops in the same CharacterData
    1:     // node. Null out the end pointer so we only visit the
    1:     // node once!
    1: 
20321:     mEnd = nsnull;
    1:   }
    1:   else
    1:   {
    1:     // Now create a Content Subtree Iterator to be used
    1:     // for the subtrees between the end points!
    1: 
    1:     res = NS_NewContentSubtreeIterator(getter_AddRefs(mIter));
    1:     if (NS_FAILED(res)) return res;
    1: 
    1:     res = mIter->Init(aRange);
    1:     if (NS_FAILED(res)) return res;
    1: 
    1:     if (mIter->IsDone())
    1:     {
    1:       // The subtree iterator thinks there's nothing
    1:       // to iterate over, so just free it up so we
    1:       // don't accidentally call into it.
    1: 
    1:       mIter = nsnull;
    1:     }
    1:   }
    1: 
    1:   // Initialize the iterator by calling First().
    1:   // Note that we are ignoring the return value on purpose!
    1: 
    1:   First();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: already_AddRefed<nsIDOMNode>
    1: RangeSubtreeIterator::GetCurrentNode()
    1: {
    1:   nsIDOMNode *node = nsnull;
    1: 
20321:   if (mIterState == eUseStart && mStart) {
20321:     NS_ADDREF(node = mStart);
20321:   } else if (mIterState == eUseEnd && mEnd)
20321:     NS_ADDREF(node = mEnd);
    1:   else if (mIterState == eUseIterator && mIter)
    1:   {
20503:     nsINode* n = mIter->GetCurrentNode();
    1: 
20503:     if (n) {
20503:       CallQueryInterface(n, &node);
    1:     }
    1:   }
    1: 
    1:   return node;
    1: }
    1: 
    1: void
    1: RangeSubtreeIterator::First()
    1: {
20321:   if (mStart)
20321:     mIterState = eUseStart;
    1:   else if (mIter)
    1:   {
    1:     mIter->First();
    1: 
    1:     mIterState = eUseIterator;
    1:   }
20321:   else if (mEnd)
20321:     mIterState = eUseEnd;
    1:   else
    1:     mIterState = eDone;
    1: }
    1: 
    1: void
    1: RangeSubtreeIterator::Last()
    1: {
20321:   if (mEnd)
20321:     mIterState = eUseEnd;
    1:   else if (mIter)
    1:   {
    1:     mIter->Last();
    1: 
    1:     mIterState = eUseIterator;
    1:   }
20321:   else if (mStart)
20321:     mIterState = eUseStart;
    1:   else
    1:     mIterState = eDone;
    1: }
    1: 
    1: void
    1: RangeSubtreeIterator::Next()
    1: {
20321:   if (mIterState == eUseStart)
    1:   {
    1:     if (mIter)
    1:     {
    1:       mIter->First();
    1: 
    1:       mIterState = eUseIterator;
    1:     }
20321:     else if (mEnd)
20321:       mIterState = eUseEnd;
    1:     else
    1:       mIterState = eDone;
    1:   }
    1:   else if (mIterState == eUseIterator)
    1:   {
    1:     mIter->Next();
    1: 
    1:     if (mIter->IsDone())
    1:     {
20321:       if (mEnd)
20321:         mIterState = eUseEnd;
    1:       else
    1:         mIterState = eDone;
    1:     }
    1:   }
    1:   else
    1:     mIterState = eDone;
    1: }
    1: 
    1: void
    1: RangeSubtreeIterator::Prev()
    1: {
20321:   if (mIterState == eUseEnd)
    1:   {
    1:     if (mIter)
    1:     {
    1:       mIter->Last();
    1: 
    1:       mIterState = eUseIterator;
    1:     }
20321:     else if (mStart)
20321:       mIterState = eUseStart;
    1:     else
    1:       mIterState = eDone;
    1:   }
    1:   else if (mIterState == eUseIterator)
    1:   {
    1:     mIter->Prev();
    1: 
    1:     if (mIter->IsDone())
    1:     {
20321:       if (mStart)
20321:         mIterState = eUseStart;
    1:       else
    1:         mIterState = eDone;
    1:     }
    1:   }
    1:   else
    1:     mIterState = eDone;
    1: }
    1: 
    1: 
    1: // CollapseRangeAfterDelete() is a utility method that is used by
    1: // DeleteContents() and ExtractContents() to collapse the range
    1: // in the correct place, under the range's root container (the
    1: // range end points common container) as outlined by the Range spec:
    1: //
    1: // http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113/ranges.html
    1: // The assumption made by this method is that the delete or extract
    1: // has been done already, and left the range in a state where there is
    1: // no content between the 2 end points.
    1: 
    1: static nsresult
    1: CollapseRangeAfterDelete(nsIDOMRange *aRange)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aRange);
    1: 
    1:   // Check if range gravity took care of collapsing the range for us!
    1: 
    1:   PRBool isCollapsed = PR_FALSE;
    1:   nsresult res = aRange->GetCollapsed(&isCollapsed);
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   if (isCollapsed)
    1:   {
    1:     // aRange is collapsed so there's nothing for us to do.
    1:     //
    1:     // There are 2 possible scenarios here:
    1:     //
    1:     // 1. aRange could've been collapsed prior to the delete/extract,
    1:     //    which would've resulted in nothing being removed, so aRange
    1:     //    is already where it should be.
    1:     //
    1:     // 2. Prior to the delete/extract, aRange's start and end were in
    1:     //    the same container which would mean everything between them
    1:     //    was removed, causing range gravity to collapse the range.
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   // aRange isn't collapsed so figure out the appropriate place to collapse!
    1:   // First get both end points and their common ancestor.
    1: 
    1:   nsCOMPtr<nsIDOMNode> commonAncestor;
    1:   res = aRange->GetCommonAncestorContainer(getter_AddRefs(commonAncestor));
    1:   if(NS_FAILED(res)) return res;
    1: 
    1:   nsCOMPtr<nsIDOMNode> startContainer, endContainer;
    1: 
    1:   res = aRange->GetStartContainer(getter_AddRefs(startContainer));
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   res = aRange->GetEndContainer(getter_AddRefs(endContainer));
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   // Collapse to one of the end points if they are already in the
    1:   // commonAncestor. This should work ok since this method is called
    1:   // immediately after a delete or extract that leaves no content
    1:   // between the 2 end points!
    1: 
    1:   if (startContainer == commonAncestor)
    1:     return aRange->Collapse(PR_TRUE);
    1:   if (endContainer == commonAncestor)
    1:     return aRange->Collapse(PR_FALSE);
    1: 
    1:   // End points are at differing levels. We want to collapse to the
    1:   // point that is between the 2 subtrees that contain each point,
    1:   // under the common ancestor.
    1: 
    1:   nsCOMPtr<nsIDOMNode> nodeToSelect(startContainer), parent;
    1: 
    1:   while (nodeToSelect)
    1:   {
    1:     nsresult res = nodeToSelect->GetParentNode(getter_AddRefs(parent));
    1:     if (NS_FAILED(res)) return res;
    1: 
    1:     if (parent == commonAncestor)
    1:       break; // We found the nodeToSelect!
    1: 
    1:     nodeToSelect = parent;
    1:   }
    1: 
    1:   if (!nodeToSelect)
    1:     return NS_ERROR_FAILURE; // This should never happen!
    1: 
    1:   res = aRange->SelectNode(nodeToSelect);
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   return aRange->Collapse(PR_FALSE);
    1: }
    1: 
16205: /**
16205:  * Remove a node from the DOM entirely.
16205:  *
16205:  * @param aNode The node to remove.
16205:  */
16205: static nsresult
16205: RemoveNode(nsIDOMNode* aNode)
16205: {
16205:   nsCOMPtr<nsINode> node = do_QueryInterface(aNode);
16205:   nsCOMPtr<nsINode> parent = node->GetNodeParent();
16205:   return parent ? parent->RemoveChildAt(parent->IndexOf(node), PR_TRUE) : NS_OK;
16205: }
16205: 
16205: /**
29803:  * Split a data node into two parts.
16205:  *
29803:  * @param aStartNode          The original node we are trying to split.
29803:  * @param aStartIndex         The index at which to split.
29803:  * @param aEndNode            The second node.
16205:  * @param aCloneAfterOriginal Set PR_FALSE if the original node should be the
16205:  *                            latter one after split.
16205:  */
16205: static nsresult SplitDataNode(nsIDOMCharacterData* aStartNode,
16205:                               PRUint32 aStartIndex,
16205:                               nsIDOMCharacterData** aEndNode,
16205:                               PRBool aCloneAfterOriginal = PR_TRUE)
16205: {
16205:   nsresult rv;
16205:   nsCOMPtr<nsINode> node = do_QueryInterface(aStartNode);
16205:   NS_ENSURE_STATE(node && node->IsNodeOfType(nsINode::eDATA_NODE));
16205:   nsGenericDOMDataNode* dataNode = static_cast<nsGenericDOMDataNode*>(node.get());
16205: 
16205:   nsCOMPtr<nsIContent> newData;
16205:   rv = dataNode->SplitData(aStartIndex, getter_AddRefs(newData),
16205:                            aCloneAfterOriginal);
16205:   NS_ENSURE_SUCCESS(rv, rv);
29803:   return CallQueryInterface(newData, aEndNode);
16205: }
16205: 
20321: nsresult PrependChild(nsIDOMNode* aParent, nsIDOMNode* aChild)
20321: {
20321:   nsCOMPtr<nsIDOMNode> first, tmpNode;
20321:   aParent->GetFirstChild(getter_AddRefs(first));
20321:   return aParent->InsertBefore(aChild, first, getter_AddRefs(tmpNode));
20321: }
20321: 
16205: nsresult nsRange::CutContents(nsIDOMDocumentFragment** aFragment)
    1: { 
19010:   if (aFragment) {
19010:     *aFragment = nsnull;
19010:   }
19010: 
    1:   if (IsDetached())
    1:     return NS_ERROR_DOM_INVALID_STATE_ERR;
    1: 
16205:   nsresult rv;
16205: 
16205:   nsCOMPtr<nsIDocument> doc =
16205:     do_QueryInterface(mStartParent->GetOwnerDoc());
16205:   if (!doc) return NS_ERROR_UNEXPECTED;
16205: 
20321:   nsCOMPtr<nsIDOMNode> commonAncestor;
20321:   rv = GetCommonAncestorContainer(getter_AddRefs(commonAncestor));
20321:   NS_ENSURE_SUCCESS(rv, rv);
20321: 
16205:   // If aFragment isn't null, create a temporary fragment to hold our return.
16205:   nsCOMPtr<nsIDOMDocumentFragment> retval;
16205:   if (aFragment) {
16205:     rv = NS_NewDocumentFragment(getter_AddRefs(retval),
16205:                                 doc->NodeInfoManager());
16205:     NS_ENSURE_SUCCESS(rv, rv);
16205:   }
20321:   nsCOMPtr<nsIDOMNode> commonCloneAncestor(do_QueryInterface(retval));
16205: 
   62:   // Batch possible DOMSubtreeModified events.
   62:   mozAutoSubtreeModified subtree(mRoot ? mRoot->GetOwnerDoc(): nsnull, nsnull);
   62: 
    1:   // Save the range end points locally to avoid interference
    1:   // of Range gravity during our edits!
    1: 
    1:   nsCOMPtr<nsIDOMNode> startContainer = do_QueryInterface(mStartParent);
    1:   PRInt32              startOffset = mStartOffset;
    1:   nsCOMPtr<nsIDOMNode> endContainer = do_QueryInterface(mEndParent);
    1:   PRInt32              endOffset = mEndOffset;
    1: 
    1:   // Create and initialize a subtree iterator that will give
    1:   // us all the subtrees within the range.
    1: 
    1:   RangeSubtreeIterator iter;
    1: 
16205:   rv = iter.Init(this);
16205:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   if (iter.IsDone())
    1:   {
    1:     // There's nothing for us to delete.
19010:     rv = CollapseRangeAfterDelete(this);
19010:     if (NS_SUCCEEDED(rv) && aFragment) {
19010:       NS_ADDREF(*aFragment = retval);
19010:     }
19010:     return rv;
    1:   }
    1: 
    1:   // We delete backwards to avoid iterator problems!
    1: 
    1:   iter.Last();
    1: 
    1:   PRBool handled = PR_FALSE;
    1: 
    1:   // With the exception of text nodes that contain one of the range
    1:   // end points, the subtree iterator should only give us back subtrees
    1:   // that are completely contained between the range's end points.
    1: 
    1:   while (!iter.IsDone())
    1:   {
20321:     nsCOMPtr<nsIDOMNode> nodeToResult;
    1:     nsCOMPtr<nsIDOMNode> node(iter.GetCurrentNode());
    1: 
    1:     // Before we delete anything, advance the iterator to the
    1:     // next subtree.
    1: 
    1:     iter.Prev();
    1: 
    1:     handled = PR_FALSE;
    1: 
    1:     // If it's CharacterData, make sure we might need to delete
    1:     // part of the data, instead of removing the whole node.
    1:     //
    1:     // XXX_kin: We need to also handle ProcessingInstruction
    1:     // XXX_kin: according to the spec.
    1: 
    1:     nsCOMPtr<nsIDOMCharacterData> charData(do_QueryInterface(node));
    1: 
    1:     if (charData)
    1:     {
    1:       PRUint32 dataLength = 0;
    1: 
    1:       if (node == startContainer)
    1:       {
    1:         if (node == endContainer)
    1:         {
    1:           // This range is completely contained within a single text node.
16205:           // Delete or extract the data between startOffset and endOffset.
    1: 
    1:           if (endOffset > startOffset)
    1:           {
29803:             if (retval) {
29803:               nsAutoString cutValue;
29803:               rv = charData->SubstringData(startOffset, endOffset - startOffset,
29803:                                            cutValue);
16205:               NS_ENSURE_SUCCESS(rv, rv);
29803:               nsCOMPtr<nsIDOMNode> clone;
29803:               rv = charData->CloneNode(PR_FALSE, getter_AddRefs(clone));
29803:               NS_ENSURE_SUCCESS(rv, rv);
29803:               clone->SetNodeValue(cutValue);
29803:               nodeToResult = clone;
29803:             }
29803: 
29803:             rv = charData->DeleteData(startOffset, endOffset - startOffset);
29803:             NS_ENSURE_SUCCESS(rv, rv);
    1:           }
    1: 
    1:           handled = PR_TRUE;
    1:         }
    1:         else
    1:         {
16205:           // Delete or extract everything after startOffset.
    1: 
16205:           rv = charData->GetLength(&dataLength);
16205:           NS_ENSURE_SUCCESS(rv, rv);
    1: 
22768:           if (dataLength >= (PRUint32)startOffset)
    1:           {
16205:             nsCOMPtr<nsIDOMCharacterData> cutNode;
29803:             rv = SplitDataNode(charData, startOffset, getter_AddRefs(cutNode));
16205:             NS_ENSURE_SUCCESS(rv, rv);
20321:             nodeToResult = cutNode;
    1:           }
    1: 
    1:           handled = PR_TRUE;
    1:         }
    1:       }
    1:       else if (node == endContainer)
    1:       {
16205:         // Delete or extract everything before endOffset.
    1: 
22768:         if (endOffset >= 0)
    1:         {
16205:           nsCOMPtr<nsIDOMCharacterData> cutNode;
16205:           /* The Range spec clearly states clones get cut and original nodes
16205:              remain behind, so use PR_FALSE as the last parameter.
16205:           */
29803:           rv = SplitDataNode(charData, endOffset, getter_AddRefs(cutNode),
29803:                              PR_FALSE);
16205:           NS_ENSURE_SUCCESS(rv, rv);
20321:           nodeToResult = cutNode;
    1:         }
    1: 
    1:         handled = PR_TRUE;
    1:       }       
    1:     }
    1: 
20321:     if (!handled && (node == endContainer || node == startContainer))
20321:     {
20321:       nsCOMPtr<nsINode> iNode = do_QueryInterface(node);
20321:       if (iNode && iNode->IsNodeOfType(nsINode::eELEMENT) &&
20321:           ((node == endContainer && endOffset == 0) ||
20321:            (node == startContainer &&
20321:             PRInt32(iNode->GetChildCount()) == startOffset)))
20321:       {
20321:         if (retval) {
20321:           nsCOMPtr<nsIDOMNode> clone;
20321:           rv = node->CloneNode(PR_FALSE, getter_AddRefs(clone));
20321:           NS_ENSURE_SUCCESS(rv, rv);
20321:           nodeToResult = clone;
20321:         }
20321:         handled = PR_TRUE;
20321:       }
20321:     }
20321: 
    1:     if (!handled)
    1:     {
    1:       // node was not handled above, so it must be completely contained
    1:       // within the range. Just remove it from the tree!
20321:       nodeToResult = node;
20321:     }
20321: 
20321:     PRUint32 parentCount = 0;
20321:     nsCOMPtr<nsIDOMNode> tmpNode;
20321:     // Set the result to document fragment if we have 'retval'.
16205:     if (retval) {
20321:       nsCOMPtr<nsIDOMNode> oldCommonAncestor = commonAncestor;
20321:       if (!iter.IsDone()) {
20321:         // Setup the parameters for the next iteration of the loop.
20321:         nsCOMPtr<nsIDOMNode> prevNode(iter.GetCurrentNode());
20321:         NS_ENSURE_STATE(prevNode);
20321: 
20321:         // Get node's and prevNode's common parent. Do this before moving
20321:         // nodes from original DOM to result fragment.
20321:         nsContentUtils::GetCommonAncestor(node, prevNode,
20321:                                           getter_AddRefs(commonAncestor));
20321:         NS_ENSURE_STATE(commonAncestor);
20321: 
20321:         nsCOMPtr<nsIDOMNode> parentCounterNode = node;
20321:         while (parentCounterNode && parentCounterNode != commonAncestor)
20321:         {
20321:           ++parentCount;
20321:           tmpNode = parentCounterNode;
20321:           tmpNode->GetParentNode(getter_AddRefs(parentCounterNode));
20321:           NS_ENSURE_STATE(parentCounterNode);
    1:         }
    1:       }
20321: 
20321:       // Clone the parent hierarchy between commonAncestor and node.
20321:       nsCOMPtr<nsIDOMNode> closestAncestor, farthestAncestor;
20321:       rv = CloneParentsBetween(oldCommonAncestor, node,
20321:                                getter_AddRefs(closestAncestor),
20321:                                getter_AddRefs(farthestAncestor));
20321:       NS_ENSURE_SUCCESS(rv, rv);
20321: 
20321:       if (farthestAncestor)
20321:       {
20321:         rv = PrependChild(commonCloneAncestor, farthestAncestor);
20321:         NS_ENSURE_SUCCESS(rv, rv);
20321:       }
20321: 
20321:       rv = closestAncestor ? PrependChild(closestAncestor, nodeToResult)
20321:                            : PrependChild(commonCloneAncestor, nodeToResult);
20321:       NS_ENSURE_SUCCESS(rv, rv);
20321:     } else if (nodeToResult) {
20321:       rv = RemoveNode(nodeToResult);
20321:       NS_ENSURE_SUCCESS(rv, rv);
20321:     }
20321: 
20321:     if (!iter.IsDone() && retval) {
20321:       // Find the equivalent of commonAncestor in the cloned tree.
20321:       nsCOMPtr<nsIDOMNode> newCloneAncestor = nodeToResult;
20321:       for (PRUint32 i = parentCount; i; --i)
20321:       {
20321:         tmpNode = newCloneAncestor;
20321:         tmpNode->GetParentNode(getter_AddRefs(newCloneAncestor));
20321:         NS_ENSURE_STATE(newCloneAncestor);
20321:       }
20321:       commonCloneAncestor = newCloneAncestor;
20321:     }
    1:   }
    1: 
    1:   // XXX_kin: At this point we should be checking for the case
    1:   // XXX_kin: where we have 2 adjacent text nodes left, each
    1:   // XXX_kin: containing one of the range end points. The spec
    1:   // XXX_kin: says the 2 nodes should be merged in that case,
    1:   // XXX_kin: and to use Normalize() to do the merging, but
    1:   // XXX_kin: calling Normalize() on the common parent to accomplish
    1:   // XXX_kin: this might also normalize nodes that are outside the
    1:   // XXX_kin: range but under the common parent. Need to verify
    1:   // XXX_kin: with the range commitee members that this was the
    1:   // XXX_kin: desired behavior. For now we don't merge anything!
16205:   // XXX ajvincent Filed as https://bugzilla.mozilla.org/show_bug.cgi?id=401276
16205: 
19010:   rv = CollapseRangeAfterDelete(this);
19010:   if (NS_SUCCEEDED(rv) && aFragment) {
16205:     NS_ADDREF(*aFragment = retval);
16205:   }
19010:   return rv;
    1: }
    1: 
16205: nsresult nsRange::DeleteContents()
16205: {
16205:   return CutContents(nsnull);
16205: }
16205: 
16205: nsresult nsRange::ExtractContents(nsIDOMDocumentFragment** aReturn)
16205: {
16205:   NS_ENSURE_ARG_POINTER(aReturn);
16205:   return CutContents(aReturn);
16205: }
16205: 
    1: NS_IMETHODIMP
    1: nsRange::CompareBoundaryPoints(PRUint16 aHow, nsIDOMRange* aOtherRange,
    1:                                PRInt16* aCmpRet)
    1: {
    1:   nsCOMPtr<nsIRange> otherRange = do_QueryInterface(aOtherRange);
    1:   NS_ENSURE_TRUE(otherRange, NS_ERROR_NULL_POINTER);
    1: 
    1:   if(mIsDetached || otherRange->IsDetached())
    1:     return NS_ERROR_DOM_INVALID_STATE_ERR;
    1:   if (!mIsPositioned || !otherRange->IsPositioned())
    1:     return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   nsINode *ourNode, *otherNode;
    1:   PRInt32 ourOffset, otherOffset;
    1: 
    1:   switch (aHow) {
    1:     case nsIDOMRange::START_TO_START:
    1:       ourNode = mStartParent;
    1:       ourOffset = mStartOffset;
    1:       otherNode = otherRange->GetStartParent();
    1:       otherOffset = otherRange->StartOffset();
    1:       break;
    1:     case nsIDOMRange::START_TO_END:
    1:       ourNode = mEndParent;
    1:       ourOffset = mEndOffset;
    1:       otherNode = otherRange->GetStartParent();
    1:       otherOffset = otherRange->StartOffset();
    1:       break;
    1:     case nsIDOMRange::END_TO_START:
    1:       ourNode = mStartParent;
    1:       ourOffset = mStartOffset;
    1:       otherNode = otherRange->GetEndParent();
    1:       otherOffset = otherRange->EndOffset();
    1:       break;
    1:     case nsIDOMRange::END_TO_END:
    1:       ourNode = mEndParent;
    1:       ourOffset = mEndOffset;
    1:       otherNode = otherRange->GetEndParent();
    1:       otherOffset = otherRange->EndOffset();
    1:       break;
    1:     default:
    1:       // We were passed an illegal value
    1:       return NS_ERROR_ILLEGAL_VALUE;
    1:   }
    1: 
    1:   if (mRoot != otherRange->GetRoot())
    1:     return NS_ERROR_DOM_WRONG_DOCUMENT_ERR;
    1: 
    1:   *aCmpRet = nsContentUtils::ComparePoints(ourNode, ourOffset,
    1:                                            otherNode, otherOffset);
    1: 
    1:   return NS_OK;
    1: }
    1: 
20321: nsresult
20321: nsRange::CloneParentsBetween(nsIDOMNode *aAncestor,
    1:                              nsIDOMNode *aNode,
    1:                              nsIDOMNode **aClosestAncestor,
    1:                              nsIDOMNode **aFarthestAncestor)
    1: {
    1:   NS_ENSURE_ARG_POINTER((aAncestor && aNode && aClosestAncestor && aFarthestAncestor));
    1: 
    1:   *aClosestAncestor  = nsnull;
    1:   *aFarthestAncestor = nsnull;
    1: 
    1:   if (aAncestor == aNode)
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIDOMNode> parent, firstParent, lastParent;
    1: 
    1:   nsresult res = aNode->GetParentNode(getter_AddRefs(parent));
    1: 
    1:   while(parent && parent != aAncestor)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> clone, tmpNode;
    1: 
    1:     res = parent->CloneNode(PR_FALSE, getter_AddRefs(clone));
    1: 
    1:     if (NS_FAILED(res)) return res;
    1:     if (!clone)         return NS_ERROR_FAILURE;
    1: 
    1:     if (! firstParent)
    1:       firstParent = lastParent = clone;
    1:     else
    1:     {
    1:       res = clone->AppendChild(lastParent, getter_AddRefs(tmpNode));
    1: 
    1:       if (NS_FAILED(res)) return res;
    1: 
    1:       lastParent = clone;
    1:     }
    1: 
    1:     tmpNode = parent;
    1:     res = tmpNode->GetParentNode(getter_AddRefs(parent));
    1:   }
    1: 
    1:   *aClosestAncestor  = firstParent;
    1:   NS_IF_ADDREF(*aClosestAncestor);
    1: 
    1:   *aFarthestAncestor = lastParent;
    1:   NS_IF_ADDREF(*aFarthestAncestor);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsRange::CloneContents(nsIDOMDocumentFragment** aReturn)
    1: {
    1:   if (IsDetached())
    1:     return NS_ERROR_DOM_INVALID_STATE_ERR;
    1: 
    1:   nsresult res;
    1:   nsCOMPtr<nsIDOMNode> commonAncestor;
    1:   res = GetCommonAncestorContainer(getter_AddRefs(commonAncestor));
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   nsCOMPtr<nsIDOMDocument> document =
    1:     do_QueryInterface(mStartParent->GetOwnerDoc());
    1:   NS_ASSERTION(document, "CloneContents needs a document to continue.");
    1:   if (!document) return NS_ERROR_FAILURE;
    1: 
    1:   // Create a new document fragment in the context of this document,
    1:   // which might be null
    1: 
    1:   nsCOMPtr<nsIDOMDocumentFragment> clonedFrag;
    1: 
    1:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(document));
    1: 
    1:   res = NS_NewDocumentFragment(getter_AddRefs(clonedFrag),
    1:                                doc->NodeInfoManager());
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   nsCOMPtr<nsIDOMNode> commonCloneAncestor(do_QueryInterface(clonedFrag));
    1:   if (!commonCloneAncestor) return NS_ERROR_FAILURE;
    1: 
    1:   // Create and initialize a subtree iterator that will give
    1:   // us all the subtrees within the range.
    1: 
    1:   RangeSubtreeIterator iter;
    1: 
    1:   res = iter.Init(this);
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   if (iter.IsDone())
    1:   {
    1:     // There's nothing to add to the doc frag, we must be done!
    1: 
    1:     *aReturn = clonedFrag;
    1:     NS_IF_ADDREF(*aReturn);
    1:     return NS_OK;
    1:   }
    1: 
    1:   iter.First();
    1: 
    1:   // With the exception of text nodes that contain one of the range
20321:   // end points and elements which don't have any content selected the subtree
20321:   // iterator should only give us back subtrees that are completely contained
20321:   // between the range's end points.
    1:   //
    1:   // Unfortunately these subtrees don't contain the parent hierarchy/context
    1:   // that the Range spec requires us to return. This loop clones the
    1:   // parent hierarchy, adds a cloned version of the subtree, to it, then
    1:   // correctly places this new subtree into the doc fragment.
    1: 
    1:   while (!iter.IsDone())
    1:   {
    1:     nsCOMPtr<nsIDOMNode> node(iter.GetCurrentNode());
    1:     nsCOMPtr<nsINode> iNode = do_QueryInterface(node);
20321:     PRBool deepClone = !(iNode->IsNodeOfType(nsINode::eELEMENT)) ||
20321:                        (!(iNode == mEndParent && mEndOffset == 0) &&
20321:                         !(iNode == mStartParent &&
20321:                           mStartOffset == PRInt32(iNode->GetChildCount())));
20321: 
    1:     // Clone the current subtree!
    1: 
    1:     nsCOMPtr<nsIDOMNode> clone;
20321:     res = node->CloneNode(deepClone, getter_AddRefs(clone));
    1:     if (NS_FAILED(res)) return res;
    1: 
    1:     // If it's CharacterData, make sure we only clone what
    1:     // is in the range.
    1:     //
    1:     // XXX_kin: We need to also handle ProcessingInstruction
    1:     // XXX_kin: according to the spec.
    1: 
    1:     nsCOMPtr<nsIDOMCharacterData> charData(do_QueryInterface(clone));
    1: 
    1:     if (charData)
    1:     {
    1:       if (iNode == mEndParent)
    1:       {
    1:         // We only need the data before mEndOffset, so get rid of any
    1:         // data after it.
    1: 
    1:         PRUint32 dataLength = 0;
    1:         res = charData->GetLength(&dataLength);
    1:         if (NS_FAILED(res)) return res;
    1: 
    1:         if (dataLength > (PRUint32)mEndOffset)
    1:         {
    1:           res = charData->DeleteData(mEndOffset, dataLength - mEndOffset);
    1:           if (NS_FAILED(res)) return res;
    1:         }
    1:       }       
    1: 
    1:       if (iNode == mStartParent)
    1:       {
    1:         // We don't need any data before mStartOffset, so just
    1:         // delete it!
    1: 
    1:         if (mStartOffset > 0)
    1:         {
    1:           res = charData->DeleteData(0, mStartOffset);
    1:           if (NS_FAILED(res)) return res;
    1:         }
    1:       }
    1:     }
    1: 
    1:     // Clone the parent hierarchy between commonAncestor and node.
    1: 
    1:     nsCOMPtr<nsIDOMNode> closestAncestor, farthestAncestor;
    1: 
    1:     res = CloneParentsBetween(commonAncestor, node,
    1:                               getter_AddRefs(closestAncestor),
    1:                               getter_AddRefs(farthestAncestor));
    1: 
    1:     if (NS_FAILED(res)) return res;
    1: 
    1:     // Hook the parent hierarchy/context of the subtree into the clone tree.
    1: 
    1:     nsCOMPtr<nsIDOMNode> tmpNode;
    1: 
    1:     if (farthestAncestor)
    1:     {
    1:       res = commonCloneAncestor->AppendChild(farthestAncestor,
    1:                                              getter_AddRefs(tmpNode));
    1: 
    1:       if (NS_FAILED(res)) return res;
    1:     }
    1: 
    1:     // Place the cloned subtree into the cloned doc frag tree!
    1: 
    1:     if (closestAncestor)
    1:     {
    1:       // Append the subtree under closestAncestor since it is the
    1:       // immediate parent of the subtree.
    1: 
    1:       res = closestAncestor->AppendChild(clone, getter_AddRefs(tmpNode));
    1:     }
    1:     else
    1:     {
    1:       // If we get here, there is no missing parent hierarchy between 
    1:       // commonAncestor and node, so just append clone to commonCloneAncestor.
    1: 
    1:       res = commonCloneAncestor->AppendChild(clone, getter_AddRefs(tmpNode));
    1:     }
    1:     if (NS_FAILED(res)) return res;
    1: 
    1:     // Get the next subtree to be processed. The idea here is to setup
    1:     // the parameters for the next iteration of the loop.
    1: 
    1:     iter.Next();
    1: 
    1:     if (iter.IsDone())
    1:       break; // We must be done!
    1: 
    1:     nsCOMPtr<nsIDOMNode> nextNode(iter.GetCurrentNode());
    1:     if (!nextNode) return NS_ERROR_FAILURE;
    1: 
    1:     // Get node and nextNode's common parent.
    1:     nsContentUtils::GetCommonAncestor(node, nextNode, getter_AddRefs(commonAncestor));
    1: 
    1:     if (!commonAncestor)
    1:       return NS_ERROR_FAILURE;
    1: 
    1:     // Find the equivalent of commonAncestor in the cloned tree!
    1: 
    1:     while (node && node != commonAncestor)
    1:     {
    1:       tmpNode = node;
    1:       res = tmpNode->GetParentNode(getter_AddRefs(node));
    1:       if (NS_FAILED(res)) return res;
    1:       if (!node) return NS_ERROR_FAILURE;
    1: 
    1:       tmpNode = clone;
    1:       res = tmpNode->GetParentNode(getter_AddRefs(clone));
    1:       if (NS_FAILED(res)) return res;
12178:       if (!clone) return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     commonCloneAncestor = clone;
    1:   }
    1: 
    1:   *aReturn = clonedFrag;
    1:   NS_IF_ADDREF(*aReturn);
    1: 
    1:   return NS_OK;
    1: }
    1: 
26995: nsresult nsRange::DoCloneRange(nsIRange** aReturn) const
    1: {
    1:   if(mIsDetached)
    1:     return NS_ERROR_DOM_INVALID_STATE_ERR;
    1: 
    1:   if (aReturn == 0)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
26992:   nsRefPtr<nsRange> range = new nsRange();
    1:   NS_ENSURE_TRUE(range, NS_ERROR_OUT_OF_MEMORY);
    1: 
 2561:   range->SetMaySpanAnonymousSubtrees(mMaySpanAnonymousSubtrees);
 2561: 
    1:   range->DoSetRange(mStartParent, mStartOffset, mEndParent, mEndOffset, mRoot);
    1: 
26995:   *aReturn = range.forget().get();
26992: 
    1:   return NS_OK;
    1: }
    1: 
26992: NS_IMETHODIMP nsRange::CloneRange(nsIDOMRange** aReturn)
26992: {
26995:   nsIRange* clone;
26992:   nsresult rv = DoCloneRange(&clone);
26992:   if (NS_SUCCEEDED(rv)) {
26992:     *aReturn = clone;
26992:   }
26992:   return rv;
26992: }
26992: 
26993: nsresult nsRange::CloneRange(nsIRange** aReturn) const
26992: {
26995:   return DoCloneRange(aReturn);
26992: }
26992: 
    1: nsresult nsRange::InsertNode(nsIDOMNode* aN)
    1: {
    1:   VALIDATE_ACCESS(aN);
    1:   
    1:   nsresult res;
    1:   PRInt32 tStartOffset;
    1:   this->GetStartOffset(&tStartOffset);
    1: 
    1:   nsCOMPtr<nsIDOMNode> tStartContainer;
    1:   res = this->GetStartContainer(getter_AddRefs(tStartContainer));
    1:   if(NS_FAILED(res)) return res;
    1: 
    1:   nsCOMPtr<nsIDOMText> startTextNode(do_QueryInterface(tStartContainer));
    1:   if (startTextNode)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> tSCParentNode;
    1:     res = tStartContainer->GetParentNode(getter_AddRefs(tSCParentNode));
    1:     if(NS_FAILED(res)) return res;
12178:     NS_ENSURE_STATE(tSCParentNode);
    1: 
    1:     PRInt32 tEndOffset;
    1:     GetEndOffset(&tEndOffset);
    1: 
31645:     nsCOMPtr<nsIDOMNode> tEndContainer;
31645:     res = this->GetEndContainer(getter_AddRefs(tEndContainer));
31645:     if(NS_FAILED(res)) return res;
31645: 
    1:     nsCOMPtr<nsIDOMText> secondPart;
    1:     res = startTextNode->SplitText(tStartOffset, getter_AddRefs(secondPart));
    1:     if (NS_FAILED(res)) return res;
    1: 
31645:     nsCOMPtr<nsIDOMNode> tResultNode;
31645:     res = tSCParentNode->InsertBefore(aN, secondPart, getter_AddRefs(tResultNode));
31645:     if (NS_FAILED(res)) return res;
31645: 
31645:     if (tEndContainer == tStartContainer && tEndOffset != tStartOffset)
    1:       res = SetEnd(secondPart, tEndOffset - tStartOffset);
    1: 
31645:     return res;
    1:   }  
    1: 
    1:   nsCOMPtr<nsIDOMNodeList>tChildList;
    1:   res = tStartContainer->GetChildNodes(getter_AddRefs(tChildList));
    1:   if(NS_FAILED(res)) return res;
    1:   PRUint32 tChildListLength;
    1:   res = tChildList->GetLength(&tChildListLength);
    1:   if(NS_FAILED(res)) return res;
    1: 
    1:   // find the insertion point in the DOM and insert the Node
    1:   nsCOMPtr<nsIDOMNode>tChildNode;
    1:   res = tChildList->Item(tStartOffset, getter_AddRefs(tChildNode));
    1:   if(NS_FAILED(res)) return res;
    1:   
    1:   nsCOMPtr<nsIDOMNode> tResultNode;
    1:   return tStartContainer->InsertBefore(aN, tChildNode, getter_AddRefs(tResultNode));
    1: }
    1: 
    1: nsresult nsRange::SurroundContents(nsIDOMNode* aNewParent)
    1: {
    1:   VALIDATE_ACCESS(aNewParent);
    1: 
19294:   NS_ENSURE_TRUE(mRoot, NS_ERROR_DOM_INVALID_STATE_ERR);
19294:   // BAD_BOUNDARYPOINTS_ERR: Raised if the Range partially selects a non-text
19294:   // node.
19294:   if (mStartParent != mEndParent) {
19294:     PRBool startIsText = mStartParent->IsNodeOfType(nsINode::eTEXT);
19294:     PRBool endIsText = mEndParent->IsNodeOfType(nsINode::eTEXT);
19294:     nsINode* startGrandParent = mStartParent->GetNodeParent();
19294:     nsINode* endGrandParent = mEndParent->GetNodeParent();
19294:     NS_ENSURE_TRUE((startIsText && endIsText &&
19294:                     startGrandParent &&
19294:                     startGrandParent == endGrandParent) ||
19294:                    (startIsText &&
19294:                     startGrandParent &&
19294:                     startGrandParent == mEndParent) ||
19294:                    (endIsText &&
19294:                     endGrandParent &&
19294:                     endGrandParent == mStartParent),
19294:                    NS_ERROR_DOM_RANGE_BAD_BOUNDARYPOINTS_ERR);
19294:   }
19294: 
    1:   // Extract the contents within the range.
    1: 
    1:   nsCOMPtr<nsIDOMDocumentFragment> docFrag;
    1: 
    1:   nsresult res = ExtractContents(getter_AddRefs(docFrag));
    1: 
    1:   if (NS_FAILED(res)) return res;
    1:   if (!docFrag) return NS_ERROR_FAILURE;
    1: 
    1:   // Spec says we need to remove all of aNewParent's
    1:   // children prior to insertion.
    1: 
    1:   nsCOMPtr<nsIDOMNodeList> children;
    1:   res = aNewParent->GetChildNodes(getter_AddRefs(children));
    1: 
    1:   if (NS_FAILED(res)) return res;
    1:   if (!children) return NS_ERROR_FAILURE;
    1: 
    1:   PRUint32 numChildren = 0;
    1:   res = children->GetLength(&numChildren);
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   nsCOMPtr<nsIDOMNode> tmpNode;
    1: 
    1:   while (numChildren)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> child;
    1:     res = children->Item(--numChildren, getter_AddRefs(child));
    1: 
    1:     if (NS_FAILED(res)) return res;
    1:     if (!child) return NS_ERROR_FAILURE;
    1: 
    1:     res = aNewParent->RemoveChild(child, getter_AddRefs(tmpNode));
    1:     if (NS_FAILED(res)) return res;
    1:   }
    1: 
    1:   // Insert aNewParent at the range's start point.
    1: 
    1:   res = InsertNode(aNewParent);
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   // Append the content we extracted under aNewParent.
    1: 
    1:   res = aNewParent->AppendChild(docFrag, getter_AddRefs(tmpNode));
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   // Select aNewParent, and its contents.
    1: 
    1:   return SelectNode(aNewParent);
    1: }
    1: 
    1: nsresult nsRange::ToString(nsAString& aReturn)
    1: { 
    1:   if(mIsDetached)
    1:     return NS_ERROR_DOM_INVALID_STATE_ERR;
    1: 
    1:   // clear the string
    1:   aReturn.Truncate();
    1:   
    1:   // If we're unpositioned, return the empty string
    1:   if (!mIsPositioned) {
    1:     return NS_OK;
    1:   }
    1: 
    1: #ifdef DEBUG_range
    1:       printf("Range dump: -----------------------\n");
    1: #endif /* DEBUG */
    1:     
    1:   // effeciency hack for simple case
    1:   if (mStartParent == mEndParent)
    1:   {
    1:     nsCOMPtr<nsIDOMText> textNode( do_QueryInterface(mStartParent) );
    1:     
    1:     if (textNode)
    1:     {
    1: #ifdef DEBUG_range
    1:       // If debug, dump it:
    1:       nsCOMPtr<nsIContent> cN (do_QueryInterface(mStartParent));
    1:       if (cN) cN->List(stdout);
    1:       printf("End Range dump: -----------------------\n");
    1: #endif /* DEBUG */
    1: 
    1:       // grab the text
    1:       if (NS_FAILED(textNode->SubstringData(mStartOffset,mEndOffset-mStartOffset,aReturn)))
    1:         return NS_ERROR_UNEXPECTED;
    1:       return NS_OK;
    1:     }
    1:   } 
    1:   
    1:   /* complex case: mStartParent != mEndParent, or mStartParent not a text node
    1:      revisit - there are potential optimizations here and also tradeoffs.
    1:   */
    1: 
    1:   nsCOMPtr<nsIContentIterator> iter;
20503:   nsresult rv = NS_NewContentIterator(getter_AddRefs(iter));
20503:   NS_ENSURE_SUCCESS(rv, rv);
26992:   rv = iter->Init(static_cast<nsIRange*>(this));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   nsString tempString;
    1:  
    1:   // loop through the content iterator, which returns nodes in the range in 
    1:   // close tag order, and grab the text from any text node
    1:   while (!iter->IsDone())
    1:   {
20503:     nsINode *n = iter->GetCurrentNode();
    1: 
    1: #ifdef DEBUG_range
    1:     // If debug, dump it:
20503:     n->List(stdout);
    1: #endif /* DEBUG */
20503:     nsCOMPtr<nsIDOMText> textNode(do_QueryInterface(n));
    1:     if (textNode) // if it's a text node, get the text
    1:     {
20503:       if (n == mStartParent) // only include text past start offset
    1:       {
    1:         PRUint32 strLength;
    1:         textNode->GetLength(&strLength);
    1:         textNode->SubstringData(mStartOffset,strLength-mStartOffset,tempString);
    1:         aReturn += tempString;
    1:       }
20503:       else if (n == mEndParent)  // only include text before end offset
    1:       {
    1:         textNode->SubstringData(0,mEndOffset,tempString);
    1:         aReturn += tempString;
    1:       }
    1:       else  // grab the whole kit-n-kaboodle
    1:       {
    1:         textNode->GetData(tempString);
    1:         aReturn += tempString;
    1:       }
    1:     }
    1: 
    1:     iter->Next();
    1:   }
    1: 
    1: #ifdef DEBUG_range
    1:   printf("End Range dump: -----------------------\n");
    1: #endif /* DEBUG */
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: 
    1: nsresult
    1: nsRange::Detach()
    1: {
    1:   if(mIsDetached)
    1:     return NS_ERROR_DOM_INVALID_STATE_ERR;
    1: 
    1:   mIsDetached = PR_TRUE;
    1: 
    1:   DoSetRange(nsnull, 0, nsnull, 0, nsnull);
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: // nsIDOMNSRange interface
    1: NS_IMETHODIMP    
    1: nsRange::CreateContextualFragment(const nsAString& aFragment,
    1:                                   nsIDOMDocumentFragment** aReturn)
    1: {
    1:   nsCOMPtr<nsIDOMNode> start = do_QueryInterface(mStartParent);
12676:   if (mIsPositioned) {
12676:     return nsContentUtils::CreateContextualFragment(start, aFragment, PR_TRUE,
12676:                                                     aReturn);
    1:   }
12676:   return NS_ERROR_FAILURE;
12676: }
33027: 
33027: static void ExtractRectFromOffset(nsIFrame* aFrame,
33027:                                   const nsIFrame* aRelativeTo, 
33027:                                   const PRInt32 aOffset, nsRect* aR, PRBool aKeepLeft)
33027: {
33027:   nsPoint point;
33027:   aFrame->GetPointFromOffset(aOffset, &point);
33027: 
33027:   point += aFrame->GetOffsetTo(aRelativeTo);
33027: 
33027:   //given a point.x, extract left or right portion of rect aR
33027:   //point.x has to be within this rect
33027:   NS_ASSERTION(aR->x <= point.x && point.x <= aR->XMost(),
33027:                    "point.x should not be outside of rect r");
33027: 
33027:   if (aKeepLeft) {
33027:     aR->width = point.x - aR->x;
33027:   } else {
33027:     aR->width = aR->XMost() - point.x;
33027:     aR->x = point.x;
33027:   }
33027: }
33027: 
36655: static nsresult GetPartialTextRect(nsLayoutUtils::RectCallback* aCallback,
33027:                                    nsIContent* aContent, PRInt32 aStartOffset, PRInt32 aEndOffset)
33027: {
36655:   nsIFrame* frame = aContent->GetPrimaryFrame();
33027:   if (frame && frame->GetType() == nsGkAtoms::textFrame) {
33027:     nsTextFrame* textFrame = static_cast<nsTextFrame*>(frame);
33027:     nsIFrame* relativeTo = nsLayoutUtils::GetContainingBlockForClientRect(textFrame);
33027:     for (nsTextFrame* f = textFrame; f; f = static_cast<nsTextFrame*>(f->GetNextContinuation())) {
33027:       PRInt32 fstart = f->GetContentOffset(), fend = f->GetContentEnd();
33027:       PRBool rtl = f->GetTextRun()->IsRightToLeft();
33027:       if (fend <= aStartOffset || fstart >= aEndOffset)
33027:         continue;
33027: 
33027:       //overlaping with the offset we want
33027:       nsRect r(f->GetOffsetTo(relativeTo), f->GetSize());
33027:       if (fstart < aStartOffset) {
33027:         //aStartOffset is within this frame
33027:         ExtractRectFromOffset(f, relativeTo, aStartOffset, &r, rtl);
33027:       }
33027:       if (fend > aEndOffset) {
33027:         //aEndOffset is in the middle of this frame
33027:         ExtractRectFromOffset(f, relativeTo, aEndOffset, &r, !rtl);
33027:       }
33027:       aCallback->AddRect(r);
33027:     }
33027:   }
33027:   return NS_OK;
33027: }
33027: 
33027: static void CollectClientRects(nsLayoutUtils::RectCallback* aCollector, 
33027:                                nsRange* aRange,
33027:                                nsINode* aStartParent, PRInt32 aStartOffset,
33027:                                nsINode* aEndParent, PRInt32 aEndOffset)
33027: {
36655:   // Hold strong pointers across the flush
33027:   nsCOMPtr<nsIDOMNode> startContainer = do_QueryInterface(aStartParent);
33027:   nsCOMPtr<nsIDOMNode> endContainer = do_QueryInterface(aEndParent);
33027: 
36655:   // Flush out layout so our frames are up to date.
36655:   if (!aStartParent->IsInDoc()) {
36655:     return;
36655:   }
36655: 
36655:   aStartParent->GetCurrentDoc()->FlushPendingNotifications(Flush_Layout);
36655: 
36655:   // Recheck whether we're still in the document
36655:   if (!aStartParent->IsInDoc()) {
33027:     return;
33027:   }
33027: 
33027:   RangeSubtreeIterator iter;
33027: 
33027:   nsresult rv = iter.Init(aRange);
33027:   if (NS_FAILED(rv)) return;
33027: 
33027:   if (iter.IsDone()) {
33027:     // the range is collapsed, only continue if the cursor is in a text node
33027:     nsCOMPtr<nsIContent> content = do_QueryInterface(aStartParent);
36986:     if (content && content->IsNodeOfType(nsINode::eTEXT)) {
36655:       nsIFrame* frame = content->GetPrimaryFrame();
33027:       if (frame && frame->GetType() == nsGkAtoms::textFrame) {
33027:         nsTextFrame* textFrame = static_cast<nsTextFrame*>(frame);
33027:         PRInt32 outOffset;
33027:         nsIFrame* outFrame;
33027:         textFrame->GetChildFrameContainingOffset(aStartOffset, PR_FALSE, 
33027:           &outOffset, &outFrame);
33027:         if (outFrame) {
33027:            nsIFrame* relativeTo = 
33027:              nsLayoutUtils::GetContainingBlockForClientRect(outFrame);
33027:            nsRect r(outFrame->GetOffsetTo(relativeTo), outFrame->GetSize());
33027:            ExtractRectFromOffset(outFrame, relativeTo, aStartOffset, &r, PR_FALSE);
33027:            r.width = 0;
33027:            aCollector->AddRect(r);
33027:         }
33027:       }
33027:     }
33027:     return;
33027:   }
33027: 
33027:   do {
33027:     nsCOMPtr<nsIDOMNode> node(iter.GetCurrentNode());
33027:     iter.Next();
33027:     nsCOMPtr<nsIContent> content = do_QueryInterface(node);
36986:     if (!content)
36986:       continue;
33027:     if (content->IsNodeOfType(nsINode::eTEXT)) {
33027:        if (node == startContainer) {
33027:          PRInt32 offset = startContainer == endContainer ? 
33027:            aEndOffset : content->GetText()->GetLength();
36655:          GetPartialTextRect(aCollector, content, aStartOffset, offset);
33027:          continue;
33027:        } else if (node == endContainer) {
36655:          GetPartialTextRect(aCollector, content, 0, aEndOffset);
33027:          continue;
33027:        }
33027:     }
33027: 
36655:     nsIFrame* frame = content->GetPrimaryFrame();
33027:     if (frame) {
33027:       nsLayoutUtils::GetAllInFlowRects(frame,
33027:         nsLayoutUtils::GetContainingBlockForClientRect(frame), aCollector);
33027:     }
33027:   } while (!iter.IsDone());
33027: }
33027: 
33027: NS_IMETHODIMP
33027: nsRange::GetBoundingClientRect(nsIDOMClientRect** aResult)
33027: {
36986:   *aResult = nsnull;
36986: 
33027:   // Weak ref, since we addref it below
33027:   nsClientRect* rect = new nsClientRect();
33027:   if (!rect)
33027:     return NS_ERROR_OUT_OF_MEMORY;
33027: 
33027:   NS_ADDREF(*aResult = rect);
33027: 
36986:   if (!mStartParent)
36986:     return NS_OK;
36986: 
33027:   nsLayoutUtils::RectAccumulator accumulator;
33027:   
33027:   CollectClientRects(&accumulator, this, mStartParent, mStartOffset, 
33027:     mEndParent, mEndOffset);
33027: 
33027:   nsRect r = accumulator.mResultRect.IsEmpty() ? accumulator.mFirstRect : 
33027:     accumulator.mResultRect;
33027:   rect->SetLayoutRect(r);
33027:   return NS_OK;
33027: }
33027: 
33027: NS_IMETHODIMP
33027: nsRange::GetClientRects(nsIDOMClientRectList** aResult)
33027: {
33027:   *aResult = nsnull;
33027: 
36986:   if (!mStartParent)
36986:     return NS_OK;
36986: 
33027:   nsRefPtr<nsClientRectList> rectList = new nsClientRectList();
33027:   if (!rectList)
33027:     return NS_ERROR_OUT_OF_MEMORY;
33027: 
33027:   nsLayoutUtils::RectListBuilder builder(rectList);
33027: 
33027:   CollectClientRects(&builder, this, mStartParent, mStartOffset, 
33027:     mEndParent, mEndOffset);
33027: 
33027:   if (NS_FAILED(builder.mRV))
33027:     return builder.mRV;
33027:   rectList.forget(aResult);
33027:   return NS_OK;
33027: }
33027: 
