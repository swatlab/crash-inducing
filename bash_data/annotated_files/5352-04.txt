   1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Blake Ross <blaker@netscape.com> (Original Author)
   1:  *   Ben Goodger <ben@netscape.com> (Original Author)
1691:  *   Shawn Wilsher <me@shawnwilsher.com>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
   1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1:  
   1: #include "nsDownloadManager.h"
   1: #include "nsIWebProgress.h"
1691: #include "nsIRDFService.h"
1691: #include "nsIRDFContainer.h"
   1: #include "nsIRDFLiteral.h"
   1: #include "rdf.h"
   1: #include "nsNetUtil.h"
   1: #include "nsIURL.h"
   1: #include "nsIDOMChromeWindow.h"
   1: #include "nsIDOMWindow.h"
   1: #include "nsIDOMWindowInternal.h"
   1: #include "nsIDOMEvent.h"
   1: #include "nsIDOMEventTarget.h"
   1: #include "nsAppDirectoryServiceDefs.h"
4867: #include "nsDirectoryServiceDefs.h"
   1: #include "nsIWindowWatcher.h"
   1: #include "nsIWindowMediator.h"
   1: #include "nsIPromptService.h"
   1: #include "nsIPrefBranch.h"
   1: #include "nsIPrefService.h"
   1: #include "nsVoidArray.h"
   1: #include "nsEnumeratorUtils.h"
   1: #include "nsIFileURL.h"
   1: #include "nsEmbedCID.h"
1691: #include "mozStorageCID.h"
1691: #include "mozIStorageService.h"
2537: #include "mozStorageHelper.h"
1691: #include "nsIMutableArray.h"
1691: #include "nsIAlertsService.h"
4867: #include "nsIPropertyBag2.h"
4765: #include "nsIHttpChannel.h"
5352: #include "nsIDownloadManagerUI.h"
   1: 
   1: #ifdef XP_WIN
   1: #include <shlobj.h>
5176: #include "nsDownloadScanner.h"
   1: #endif
   1: 
   1: static PRBool gStoppingDownloads = PR_FALSE;
   1: 
   1: #define DOWNLOAD_MANAGER_BUNDLE "chrome://mozapps/locale/downloads/downloads.properties"
   1: #define DOWNLOAD_MANAGER_ALERT_ICON "chrome://mozapps/skin/downloads/downloadIcon.png"
   1: #define PREF_BDM_SHOWALERTONCOMPLETE "browser.download.manager.showAlertOnComplete"
   1: #define PREF_BDM_SHOWALERTINTERVAL "browser.download.manager.showAlertInterval"
   1: #define PREF_BDM_RETENTION "browser.download.manager.retention"
   1: #define PREF_BDM_CLOSEWHENDONE "browser.download.manager.closeWhenDone"
   1: #define PREF_BDM_ADDTORECENTDOCS "browser.download.manager.addToRecentDocs"
   1: 
1691: static const PRInt64 gUpdateInterval = 400 * PR_USEC_PER_MSEC;
   1: 
4765: #define DM_SCHEMA_VERSION      3
3095: #define DM_DB_NAME             NS_LITERAL_STRING("downloads.sqlite")
3095: #define DM_DB_CORRUPT_FILENAME NS_LITERAL_STRING("downloads.sqlite.corrupt")
3095: 
   1: ///////////////////////////////////////////////////////////////////////////////
   1: // nsDownloadManager
   1: 
2699: NS_IMPL_ISUPPORTS2(nsDownloadManager, nsIDownloadManager, nsIObserver)
   1: 
3409: nsDownloadManager *nsDownloadManager::gDownloadManagerService = nsnull;
3409: 
3409: nsDownloadManager *
3409: nsDownloadManager::GetSingleton()
3409: {
3409:   if (gDownloadManagerService) {
3409:     NS_ADDREF(gDownloadManagerService);
3409:     return gDownloadManagerService;
3409:   }
3409: 
3409:   gDownloadManagerService = new nsDownloadManager();
3409:   if (gDownloadManagerService) {
3409:     NS_ADDREF(gDownloadManagerService);
3409:     if (NS_FAILED(gDownloadManagerService->Init()))
3409:       NS_RELEASE(gDownloadManagerService);
3409:   }
3409: 
3409:   return gDownloadManagerService;
3409: }
3409: 
   1: nsDownloadManager::~nsDownloadManager()
   1: {
5176: #ifdef XP_WIN
5176:   delete mScanner;
5176: #endif
3409:   gDownloadManagerService = nsnull;
   1: }
   1: 
1691: nsresult
1691: nsDownloadManager::CancelAllDownloads()
   1: {
1691:   nsresult rv = NS_OK;
1691:   for (PRInt32 i = mCurrentDownloads.Count() - 1; i >= 0; --i) {
1691:     nsRefPtr<nsDownload> dl = mCurrentDownloads[0];
1691: 
1691:     nsresult result = CancelDownload(dl->mID);
1691:     // We want to try the rest of them because they should be canceled if they
1691:     // can be canceled.
1691:     if (NS_FAILED(result)) rv = result;
1691:   }
1691:   
1691:   return rv;
1691: }
1691: 
5176: void
5176: nsDownloadManager::CompleteDownload(nsDownload *aDownload)
5176: {
2487:   // we've stopped, so break the cycle we created at download start
2487:   aDownload->mCancelable = nsnull;
2487: 
2485:   (void)mCurrentDownloads.RemoveObject(aDownload);
2485: }
2485: 
2485: nsresult
1691: nsDownloadManager::InitDB(PRBool *aDoImport)
1691: {
   1:   nsresult rv;
1691:   *aDoImport = PR_FALSE;
   1: 
1691:   nsCOMPtr<mozIStorageService> storage =
1691:     do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID, &rv);
1691:   NS_ENSURE_SUCCESS(rv, rv);
   1:   
1691:   nsCOMPtr<nsIFile> dbFile;
1691:   rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
1691:                               getter_AddRefs(dbFile));
1691:   NS_ENSURE_SUCCESS(rv, rv);
3095:   rv = dbFile->Append(DM_DB_NAME);
1691:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
1691:   rv = storage->OpenDatabase(dbFile, getter_AddRefs(mDBConn));
1691:   if (rv == NS_ERROR_FILE_CORRUPTED) {
1691:     // delete and try again
1691:     rv = dbFile->Remove(PR_TRUE);
1691:     NS_ENSURE_SUCCESS(rv, rv);
1691:     rv = storage->OpenDatabase(dbFile, getter_AddRefs(mDBConn));
1691:   }
1691:   NS_ENSURE_SUCCESS(rv, rv);
1691: 
1691:   PRBool tableExists;
1691:   rv = mDBConn->TableExists(NS_LITERAL_CSTRING("moz_downloads"), &tableExists);
1691:   NS_ENSURE_SUCCESS(rv, rv);
1691:   if (!tableExists) {
1691:     *aDoImport = PR_TRUE;
1691:     rv = CreateTable();
1691:     NS_ENSURE_SUCCESS(rv, rv);
4504:     return NS_OK;
4504:   }
4504: 
3095:   // Checking the database schema now
3095:   PRInt32 schemaVersion;
3095:   rv = mDBConn->GetSchemaVersion(&schemaVersion);
3095:   NS_ENSURE_SUCCESS(rv, rv);
3095: 
3095:   // Changing the database?  Be sure to do these two things!
3095:   // 1) Increment DM_SCHEMA_VERSION
3095:   // 2) Implement the proper downgrade/upgrade code for the current version
3095: 
4504:   switch (schemaVersion) {
3095:   // Upgrading
3095:   // Every time you increment the database schema, you need to implement
3095:   // the upgrading code from the previous version to the new one.
4504:   // Also, don't forget to make a unit test to test your upgrading code!
4504:   case 1: // Drop a column (iconURL) from the database (bug 385875)
4504:     {
3746:       // Safely wrap this in a transaction so we don't hose the whole DB
3746:       mozStorageTransaction safeTransaction(mDBConn, PR_TRUE);
3746: 
4504:       // Create a temporary table that will store the existing records
3746:       rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
3746:         "CREATE TEMPORARY TABLE moz_downloads_backup ("
3746:           "id INTEGER PRIMARY KEY, "
3746:           "name TEXT, "
3746:           "source TEXT, "
3746:           "target TEXT, "
3746:           "startTime INTEGER, "
3746:           "endTime INTEGER, "
3746:           "state INTEGER"
3746:         ")"));
3746:       NS_ENSURE_SUCCESS(rv, rv);
3746: 
3746:       // Insert into a temporary table
3746:       rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
3746:         "INSERT INTO moz_downloads_backup "
3746:         "SELECT id, name, source, target, startTime, endTime, state "
3746:         "FROM moz_downloads"));
3746:       NS_ENSURE_SUCCESS(rv, rv);
3746: 
4504:       // Drop the old table
3746:       rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
3746:         "DROP TABLE moz_downloads"));
3746:       NS_ENSURE_SUCCESS(rv, rv);
3746: 
4504:       // Now recreate it with this schema version
3746:       rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
3746:         "CREATE  TABLE moz_downloads ("
3746:           "id INTEGER PRIMARY KEY, "
3746:           "name TEXT, "
3746:           "source TEXT, "
3746:           "target TEXT, "
3746:           "startTime INTEGER, "
3746:           "endTime INTEGER, "
3746:           "state INTEGER"
3746:         ")"));
3746:       NS_ENSURE_SUCCESS(rv, rv);
3746: 
4504:       // Insert the data back into it
3746:       rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
3746:         "INSERT INTO moz_downloads "
3746:         "SELECT id, name, source, target, startTime, endTime, state "
3746:         "FROM moz_downloads_backup"));
3746:       NS_ENSURE_SUCCESS(rv, rv);
3746: 
4504:       // And drop our temporary table
3746:       rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
3746:         "DROP TABLE moz_downloads_backup"));
3746:       NS_ENSURE_SUCCESS(rv, rv);
3746: 
3746:       // Finally, update the schemaVersion variable and the database schema
3746:       schemaVersion = 2;
3746:       rv = mDBConn->SetSchemaVersion(schemaVersion);
3746:       NS_ENSURE_SUCCESS(rv, rv);
3095:     }
4504:     // Fallthrough to the next upgrade
4504: 
4765:   case 2: // Add referrer column to the database
4765:     {
4765:       rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
4765:         "ALTER TABLE moz_downloads "
4765:         "ADD COLUMN referrer TEXT"));
4765:       NS_ENSURE_SUCCESS(rv, rv);
4765: 
4765:       // Finally, update the schemaVersion variable and the database schema
4765:       schemaVersion = 3;
4765:       rv = mDBConn->SetSchemaVersion(schemaVersion);
4765:       NS_ENSURE_SUCCESS(rv, rv);
4765:     }
4765:     // Fallthrough to the next upgrade
4765: 
4504:   case DM_SCHEMA_VERSION:
4504:     break;
4504: 
4504:   case 0:
4504:     {
4504:       NS_WARNING("Could not get download database's schema version!");
4504: 
4504:       // The table may still be usable - someone may have just messed with the
4504:       // schema version, so let's just treat this like a downgrade and verify
4504:       // that the needed columns are there.  If they aren't there, we'll drop
4504:       // the table anyway.
4504:       rv = mDBConn->SetSchemaVersion(DM_SCHEMA_VERSION);
4504:       NS_ENSURE_SUCCESS(rv, rv);
4504:     }
4504:     // Fallthrough to downgrade check
4504: 
4504:   // Downgrading
4504:   // If columns have been added to the table, we can still use the ones we
4504:   // understand safely.  If columns have been deleted or alterd, we just
4504:   // drop the table and start from scratch.  If you change how a column
4504:   // should be interpreted, make sure you also change its name so this
4504:   // check will catch it.
4504:   default:
4504:     {
4504:       nsCOMPtr<mozIStorageStatement> stmt;
4504:       rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
5333:         "SELECT id, name, source, target, startTime, endTime, state, referrer "
4504:         "FROM moz_downloads"), getter_AddRefs(stmt));
4504:       if (NS_SUCCEEDED(rv))
4504:         break;
4504: 
4504:       // if the statement fails, that means all the columns were not there.
4504:       // First we backup the database
4504:       nsCOMPtr<nsIFile> backup;
4504:       rv = mDBConn->BackupDB(DM_DB_CORRUPT_FILENAME, nsnull,
4504:                              getter_AddRefs(backup));
4504:       NS_ENSURE_SUCCESS(rv, rv);
4504: 
4504:       // Then we dump it
4504:       rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
4504:         "DROP TABLE moz_downloads"));
4504:       NS_ENSURE_SUCCESS(rv, rv);
4504: 
4504:       rv = CreateTable();
4504:       NS_ENSURE_SUCCESS(rv, rv);
4504:     }
4504:     break;
1691:   }
1691: 
1691:   return NS_OK;
1691: }
1691: 
1691: nsresult
1691: nsDownloadManager::CreateTable()
1691: {
3095:   nsresult rv = mDBConn->SetSchemaVersion(DM_SCHEMA_VERSION);
3095:   if (NS_FAILED(rv)) return rv;
3095: 
1691:   return mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
1691:     "CREATE TABLE moz_downloads ("
3746:       "id INTEGER PRIMARY KEY, "
3746:       "name TEXT, "
3746:       "source TEXT, "
3746:       "target TEXT, "
3746:       "startTime INTEGER, "
3746:       "endTime INTEGER, "
4765:       "state INTEGER, "
4765:       "referrer TEXT"
3746:     ")"));
1691: }
1691: 
1691: nsresult
1691: nsDownloadManager::ImportDownloadHistory()
1691: {
1691:   nsCOMPtr<nsIFile> dlFile;
1691:   nsresult rv = NS_GetSpecialDirectory(NS_APP_DOWNLOADS_50_FILE,
1691:                                        getter_AddRefs(dlFile));
1691:   NS_ENSURE_SUCCESS(rv, rv);
1691: 
1691:   PRBool check;
1691:   rv = dlFile->Exists(&check);
1691:   if (NS_FAILED(rv) || !check)
1691:     return rv;
1691:   
1691:   rv = dlFile->IsFile(&check);
1691:   if (NS_FAILED(rv) || !check)
1691:     return rv;
1691: 
1691:   nsCAutoString dlSrc;
1691:   rv = NS_GetURLSpecFromFile(dlFile, dlSrc);
1691:   NS_ENSURE_SUCCESS(rv, rv);
1691:   
1691:   nsCOMPtr<nsIRDFService> rdfs =
1691:     do_GetService("@mozilla.org/rdf/rdf-service;1", &rv);
1691:   NS_ENSURE_SUCCESS(rv, rv);
1691: 
1691:   nsCOMPtr<nsIRDFDataSource> ds;
1691:   rv = rdfs->GetDataSourceBlocking(dlSrc.get(), getter_AddRefs(ds));
1691:   NS_ENSURE_SUCCESS(rv, rv);
1691: 
1691:   // OK, we now have our datasouce, so lets get our resources
1691:   nsCOMPtr<nsIRDFResource> NC_DownloadsRoot;
1691:   rv = rdfs->GetResource(NS_LITERAL_CSTRING("NC:DownloadsRoot"),
1691:                          getter_AddRefs(NC_DownloadsRoot));
1691:   NS_ENSURE_SUCCESS(rv, rv);
1691:   nsCOMPtr<nsIRDFResource> NC_Name;
1691:   rv = rdfs->GetResource(NS_LITERAL_CSTRING(NC_NAMESPACE_URI "Name"),
1691:                          getter_AddRefs(NC_Name));
1691:   NS_ENSURE_SUCCESS(rv, rv);
1691:   nsCOMPtr<nsIRDFResource> NC_URL;
1691:   rv = rdfs->GetResource(NS_LITERAL_CSTRING(NC_NAMESPACE_URI "URL"),
1691:                          getter_AddRefs(NC_URL));
1691:   NS_ENSURE_SUCCESS(rv, rv);
1691:   nsCOMPtr<nsIRDFResource> NC_File;
1691:   rv = rdfs->GetResource(NS_LITERAL_CSTRING(NC_NAMESPACE_URI "File"),
1691:                          getter_AddRefs(NC_File));
1691:   NS_ENSURE_SUCCESS(rv, rv);
1691:   nsCOMPtr<nsIRDFResource> NC_DateStarted;
1691:   rv = rdfs->GetResource(NS_LITERAL_CSTRING(NC_NAMESPACE_URI "DateStarted"),
1691:                          getter_AddRefs(NC_DateStarted));
1691:   NS_ENSURE_SUCCESS(rv, rv);
1691:   nsCOMPtr<nsIRDFResource> NC_DateEnded;
1691:   rv = rdfs->GetResource(NS_LITERAL_CSTRING(NC_NAMESPACE_URI "DateEnded"),
1691:                          getter_AddRefs(NC_DateEnded));
1691:   NS_ENSURE_SUCCESS(rv, rv);
1691:   nsCOMPtr<nsIRDFResource> NC_DownloadState;
1691:   rv = rdfs->GetResource(NS_LITERAL_CSTRING(NC_NAMESPACE_URI "DownloadState"),
1691:                          getter_AddRefs(NC_DownloadState));
1691:   NS_ENSURE_SUCCESS(rv, rv);
1691: 
2537:   mozStorageTransaction transaction(mDBConn, PR_TRUE);
2537: 
1691:   // OK, now we can actually start to read and process our data
1691:   nsCOMPtr<nsIRDFContainer> container =
1691:     do_CreateInstance(NS_RDF_CONTRACTID "/container;1", &rv);
1691:   NS_ENSURE_SUCCESS(rv, rv);
1691:   rv = container->Init(ds, NC_DownloadsRoot);
1691:   NS_ENSURE_SUCCESS(rv, rv);
1691:   
1691:   nsCOMPtr<nsISimpleEnumerator> dls;
1691:   rv = container->GetElements(getter_AddRefs(dls));
1691:   NS_ENSURE_SUCCESS(rv, rv);
1691:   PRBool hasMore;
1691:   while (NS_SUCCEEDED(dls->HasMoreElements(&hasMore)) && hasMore) {
1691:     nsCOMPtr<nsISupports> itm;
1691:     rv = dls->GetNext(getter_AddRefs(itm));
1691:     if (NS_FAILED(rv)) continue;
1691: 
1691:     nsCOMPtr<nsIRDFResource> dl = do_QueryInterface(itm, &rv);
1691:     if (NS_FAILED(rv)) continue;
1691: 
1691:     nsCOMPtr<nsIRDFNode> node;
1691:     // Getting the data
1691:     nsString name;
1691:     nsCString source, target;
1691:     PRInt64 startTime, endTime;
1691:     PRInt32 state;
1691:     
1691:     rv = ds->GetTarget(dl, NC_Name, PR_TRUE, getter_AddRefs(node));
1691:     if (NS_FAILED(rv)) continue;
1691:     nsCOMPtr<nsIRDFLiteral> rdfLit = do_QueryInterface(node, &rv);
1691:     if (NS_FAILED(rv)) continue;
1691:     rv = rdfLit->GetValue(getter_Copies(name));
1691:     if (NS_FAILED(rv)) continue;
1691: 
1691:     rv = ds->GetTarget(dl, NC_URL, PR_TRUE, getter_AddRefs(node));
1691:     if (NS_FAILED(rv)) continue;
1691:     nsCOMPtr<nsIRDFResource> rdfRes = do_QueryInterface(node, &rv);
1691:     if (NS_FAILED(rv)) continue;
1691:     rv = rdfRes->GetValueUTF8(source);
1691:     if (NS_FAILED(rv)) continue;
1691: 
1691:     rv = ds->GetTarget(dl, NC_File, PR_TRUE, getter_AddRefs(node));
1691:     if (NS_FAILED(rv)) continue;
1691:     rdfRes = do_QueryInterface(node, &rv);
1691:     if (NS_FAILED(rv)) continue;
1691:     rv = rdfRes->GetValueUTF8(target);
1691:     if (NS_FAILED(rv)) continue;
1691: 
1691:     rv = ds->GetTarget(dl, NC_DateStarted, PR_TRUE, getter_AddRefs(node));
1863:     if (NS_FAILED(rv) || !node) {
1863:       rv = ds->GetTarget(dl, NC_DateEnded, PR_TRUE, getter_AddRefs(node));
1691:       if (NS_FAILED(rv)) continue;
1863:     }
1691:     nsCOMPtr<nsIRDFDate> rdfDate = do_QueryInterface(node, &rv);
1691:     if (NS_FAILED(rv)) continue;
1691:     rv = rdfDate->GetValue(&startTime);
1691:     if (NS_FAILED(rv)) continue;
1691:     
1691:     rv = ds->GetTarget(dl, NC_DateEnded, PR_TRUE, getter_AddRefs(node));
1691:     if (NS_FAILED(rv)) continue;
1691:     rdfDate = do_QueryInterface(node, &rv);
1691:     if (NS_FAILED(rv)) continue;
1691:     rv = rdfDate->GetValue(&endTime);
1691:     if (NS_FAILED(rv)) continue;
1691: 
1691:     rv = ds->GetTarget(dl, NC_DownloadState, PR_TRUE, getter_AddRefs(node));
1691:     if (NS_FAILED(rv)) continue;
1691:     nsCOMPtr<nsIRDFInt> rdfInt = do_QueryInterface(node, &rv);
1691:     if (NS_FAILED(rv)) continue;
1691:     rv = rdfInt->GetValue(&state);
1691:     if (NS_FAILED(rv)) continue;
1691:  
3746:     (void)AddDownloadToDB(name, source, target, startTime, endTime, state);
1691:   }
1691: 
1691:   return NS_OK;
1691: }
1691: 
1691: PRInt64
1691: nsDownloadManager::AddDownloadToDB(const nsAString &aName,
1691:                                    const nsACString &aSource,
1691:                                    const nsACString &aTarget,
1691:                                    PRInt64 aStartTime,
1691:                                    PRInt64 aEndTime,
1691:                                    PRInt32 aState)
1691: {
1691:   nsCOMPtr<mozIStorageStatement> stmt;
1691:   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
1691:     "INSERT INTO moz_downloads "
3746:     "(name, source, target, startTime, endTime, state) "
3746:     "VALUES (?1, ?2, ?3, ?4, ?5, ?6)"), getter_AddRefs(stmt));
1691:   NS_ENSURE_SUCCESS(rv, 0);
1691: 
1691:   // name
1691:   rv = stmt->BindStringParameter(0, aName);
1691:   NS_ENSURE_SUCCESS(rv, 0);
1691: 
1691:   // source
1691:   rv = stmt->BindUTF8StringParameter(1, aSource);
1691:   NS_ENSURE_SUCCESS(rv, 0);
1691: 
1691:   // target
1691:   rv = stmt->BindUTF8StringParameter(2, aTarget);
1691:   NS_ENSURE_SUCCESS(rv, 0);
1691: 
1691:   // startTime
3746:   rv = stmt->BindInt64Parameter(3, aStartTime);
1691:   NS_ENSURE_SUCCESS(rv, 0);
1691: 
1691:   // endTime
3746:   rv = stmt->BindInt64Parameter(4, aEndTime);
1691:   NS_ENSURE_SUCCESS(rv, 0);
1691: 
1691:   // state
3746:   rv = stmt->BindInt32Parameter(5, aState);
1691:   NS_ENSURE_SUCCESS(rv, 0);
1691: 
1691:   PRBool hasMore;
1691:   rv = stmt->ExecuteStep(&hasMore); // we want to keep our lock
1691:   NS_ENSURE_SUCCESS(rv, 0);
1691: 
1691:   PRInt64 id = 0;
1691:   rv = mDBConn->GetLastInsertRowID(&id);
1691:   NS_ENSURE_SUCCESS(rv, 0);
1691: 
1691:   // lock on DB from statement will be released once we return
1691:   return id;
   1: }
   1: 
   1: nsresult
   1: nsDownloadManager::Init()
   1: {
   1:   nsresult rv;
1691:   mObserverService = do_GetService("@mozilla.org/observer-service;1", &rv);
1691:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
1691:   PRBool doImport;
1691:   rv = InitDB(&doImport);
1691:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
1691:   if (doImport)
1691:     ImportDownloadHistory();
   1: 
1691:   nsCOMPtr<nsIStringBundleService> bundleService =
1691:     do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv);
1691:   NS_ENSURE_SUCCESS(rv, rv);
   1:   
1691:   rv = bundleService->CreateBundle(DOWNLOAD_MANAGER_BUNDLE,
1691:                                    getter_AddRefs(mBundle));
1691:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
5176: #ifdef XP_WIN
5176:   mScanner = new nsDownloadScanner();
5176:   if (!mScanner)
5176:     return NS_ERROR_OUT_OF_MEMORY;
5176:   rv = mScanner->Init();
5176:   if (NS_FAILED(rv)) {
5176:     delete mScanner;
5176:     mScanner = nsnull;
5176:   }
5176: #endif
5176: 
4765:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
4765:     "UPDATE moz_downloads "
4765:     "SET startTime = ?1, endTime = ?2, state = ?3, referrer = ?4 "
4765:     "WHERE id = ?5"), getter_AddRefs(mUpdateDownloadStatement));
4765:   NS_ENSURE_SUCCESS(rv, rv);
4765: 
   1:   // The following three AddObserver calls must be the last lines in this function,
   1:   // because otherwise, this function may fail (and thus, this object would be not
   1:   // completely initialized), but the observerservice would still keep a reference
   1:   // to us and notify us about shutdown, which may cause crashes.
   1:   // failure to add an observer is not critical
   1:   //
   1:   // These observers will be cleaned up automatically at app shutdown.  We do
   1:   // not bother explicitly breaking the observers because we are a singleton
   1:   // that lives for the duration of the app.
   1:   //
1691:   mObserverService->AddObserver(this, "quit-application", PR_FALSE);
1691:   mObserverService->AddObserver(this, "quit-application-requested", PR_FALSE);
1691:   mObserverService->AddObserver(this, "offline-requested", PR_FALSE);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: PRInt32 
   1: nsDownloadManager::GetRetentionBehavior()
   1: {
1691:   // We use 0 as the default, which is "remove when done"
1691:   nsresult rv;
1691:   nsCOMPtr<nsIPrefBranch> pref = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
1691:   NS_ENSURE_SUCCESS(rv, 0);
1691:   
1691:   PRInt32 val;
1691:   rv = pref->GetIntPref(PREF_BDM_RETENTION, &val);
1691:   NS_ENSURE_SUCCESS(rv, 0);
   1: 
   1:   return val;
   1: }
   1: 
2116: nsresult
2116: nsDownloadManager::GetDownloadFromDB(PRUint32 aID, nsDownload **retVal)
2116: {
2116:   NS_ASSERTION(!FindDownload(aID),
2116:                "If it is a current download, you should not call this method!");
2116: 
2116:   // First, let's query the database and see if it even exists
2116:   nsCOMPtr<mozIStorageStatement> stmt;
2116:   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
4765:     "SELECT id, state, startTime, source, target, name, referrer "
2116:     "FROM moz_downloads "
2116:     "WHERE id = ?1"), getter_AddRefs(stmt));
2116:   NS_ENSURE_SUCCESS(rv, rv);
2116: 
2116:   rv = stmt->BindInt64Parameter(0, aID);
2116:   NS_ENSURE_SUCCESS(rv, rv);
2116: 
2116:   PRBool hasResults = PR_FALSE;
2116:   rv = stmt->ExecuteStep(&hasResults);
2116:   if (NS_FAILED(rv) || !hasResults)
2116:     return NS_ERROR_NOT_AVAILABLE;
2116: 
2116:   // We have a download, so lets create it
2116:   nsRefPtr<nsDownload> dl = new nsDownload();
2116:   if (!dl)
2116:     return NS_ERROR_OUT_OF_MEMORY;
2116: 
2116:   // Setting all properties of the download now
2116:   dl->mCancelable = nsnull;
2116:   dl->mID = stmt->AsInt64(0);
2116:   dl->mDownloadState = stmt->AsInt32(1);
2116:   dl->mStartTime = stmt->AsInt64(2);
2116:   
2116:   nsCString source;
2116:   stmt->GetUTF8String(3, source);
2116:   rv = NS_NewURI(getter_AddRefs(dl->mSource), source);
2116:   NS_ENSURE_SUCCESS(rv, rv);
2116: 
2116:   nsCString target;
2116:   stmt->GetUTF8String(4, target);
2116:   rv = NS_NewURI(getter_AddRefs(dl->mTarget), target);
2116:   NS_ENSURE_SUCCESS(rv, rv);
2116: 
2116:   stmt->GetString(5, dl->mDisplayName);
2116: 
4765:   nsCString referrer;
4765:   rv = stmt->GetUTF8String(6, referrer);
4765:   if (NS_SUCCEEDED(rv) && !referrer.IsEmpty()) {
4765:     rv = NS_NewURI(getter_AddRefs(dl->mReferrer), referrer);
4765:     NS_ENSURE_SUCCESS(rv, rv);
4765:   }
4765: 
2116:   nsCOMPtr<nsILocalFile> file;
2116:   rv = dl->GetTargetFile(getter_AddRefs(file));
2116:   NS_ENSURE_SUCCESS(rv, rv);
2116: 
2116:   PRBool fileExists;
2116:   if (NS_SUCCEEDED(file->Exists(&fileExists)) && fileExists) {
2116:     if (dl->mDownloadState == nsIDownloadManager::DOWNLOAD_FINISHED) {
2116:       dl->mPercentComplete = 100;
2116:       
2116:       PRInt64 size;
2116:       rv = file->GetFileSize(&size);
2116:       NS_ENSURE_SUCCESS(rv, rv);
2116:       dl->mMaxBytes = dl->mCurrBytes = size;
2116:     } else {
2116:       dl->mPercentComplete = -1;
2116:       dl->mMaxBytes = LL_MAXUINT;
2116:     }
2116:   } else {
2116:     dl->mPercentComplete = 0;
2116:     dl->mMaxBytes = LL_MAXUINT;
2116:     dl->mCurrBytes = 0;
2116:   }
2116: 
2116:   // Addrefing and returning
2116:   NS_ADDREF(*retVal = dl);
2116:   return NS_OK;
2116: }
2116: 
5176: void
5176: nsDownloadManager::SendEvent(nsDownload *aDownload, const char *aTopic)
5176: {
5176:   (void)mObserverService->NotifyObservers(aDownload, aTopic, nsnull);
5176: }
5176: 
2116: ///////////////////////////////////////////////////////////////////////////////
2116: //// nsIDownloadManager
2116: 
   1: NS_IMETHODIMP
   1: nsDownloadManager::GetActiveDownloadCount(PRInt32 *aResult)
   1: {
1691:   *aResult = mCurrentDownloads.Count();
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
1691: nsDownloadManager::GetActiveDownloads(nsISimpleEnumerator **aResult)
   1: {
1691:   return NS_NewArrayEnumerator(aResult, mCurrentDownloads);
   1: }
   1: 
   1: NS_IMETHODIMP
4867: nsDownloadManager::GetDefaultDownloadsDirectory(nsILocalFile **aResult)
4867: {
4867:   nsCOMPtr<nsILocalFile> downloadDir;
4867: 
4867:   nsresult rv;
4867:   nsCOMPtr<nsIProperties> dirService =
4867:      do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID, &rv);
4867:   NS_ENSURE_SUCCESS(rv, rv);
4867: 
4867:   // OSX:
4867:   // Safari download folder or Desktop/Downloads
4867:   // Vista:
4867:   // Downloads
4867:   // XP/2K:
4867:   // Desktop/Downloads
4867:   // Linux:
4867:   // Home/Downloads
4867: 
4867:   nsXPIDLString folderName;
4867:   mBundle->GetStringFromName(NS_LITERAL_STRING("downloadsFolder").get(),
4867:                              getter_Copies(folderName));
4867: 
4867: #if defined (XP_MACOSX)
4867:   nsCOMPtr<nsILocalFile> desktopDir;
4867:   rv = dirService->Get(NS_OSX_DEFAULT_DOWNLOAD_DIR,
4867:                        NS_GET_IID(nsILocalFile),
4867:                        getter_AddRefs(downloadDir));
4867:   NS_ENSURE_SUCCESS(rv, rv);
4867:   rv = dirService->Get(NS_OSX_USER_DESKTOP_DIR,
4867:                        NS_GET_IID(nsILocalFile),
4867:                        getter_AddRefs(desktopDir));
4867:   NS_ENSURE_SUCCESS(rv, rv);
4867: 
4867:   // Check to see if we have the desktop or the Safari downloads folder
4867:   PRBool equals;
4867:   rv = downloadDir->Equals(desktopDir, &equals);
4867:   NS_ENSURE_SUCCESS(rv, rv);
4867:   if (equals) {
4867:     rv = downloadDir->Append(folderName);
4867:     NS_ENSURE_SUCCESS(rv, rv);
4867:   }
4867: #elif defined (XP_WIN)
4867:   rv = dirService->Get(NS_WIN_DEFAULT_DOWNLOAD_DIR,
4867:                        NS_GET_IID(nsILocalFile),
4867:                        getter_AddRefs(downloadDir));
4867:   NS_ENSURE_SUCCESS(rv, rv);
4867: 
4867:   // Check the os version
4867:   #define NS_SYSTEMINFO_CONTRACTID "@mozilla.org/system-info;1"
4867:   nsCOMPtr<nsIPropertyBag2> infoService =
4867:      do_GetService(NS_SYSTEMINFO_CONTRACTID, &rv);
4867:   NS_ENSURE_SUCCESS(rv, rv);
4867: 
4867:   PRInt32 version;
4867:   NS_NAMED_LITERAL_STRING(osVersion, "version");
4867:   rv = infoService->GetPropertyAsInt32(osVersion, &version);
4867:   if (version < 6) { // XP/2K
4867:     rv = downloadDir->Append(folderName);
4867:     NS_ENSURE_SUCCESS(rv, rv);
4867:   }
4867: #else
4867:   rv = dirService->Get(NS_OS_HOME_DIR,
4867:                        NS_GET_IID(nsILocalFile),
4867:                        getter_AddRefs(downloadDir));
4867:   NS_ENSURE_SUCCESS(rv, rv);
4867:   rv = downloadDir->Append(folderName);
4867:   NS_ENSURE_SUCCESS(rv, rv);
4867: #endif
4867: 
4867:   NS_ADDREF(*aResult = downloadDir);
4867: 
4867:   return NS_OK;
4867: }
4867: 
4867: #define NS_BRANCH_DOWNLOAD     "browser.download."
4867: #define NS_PREF_FOLDERLIST     "folderList"
4867: #define NS_PREF_DIR            "dir"
4867: 
4867: NS_IMETHODIMP
4867: nsDownloadManager::GetUserDownloadsDirectory(nsILocalFile **aResult)
4867: {
4867:   nsresult rv;
4867:   nsCOMPtr<nsIProperties> dirService =
4867:      do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID, &rv);
4867:   NS_ENSURE_SUCCESS(rv, rv);
4867: 
4867:   nsCOMPtr<nsIPrefService> prefService =
4867:      do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
4867:   NS_ENSURE_SUCCESS(rv, rv);
4867: 
4867:   nsCOMPtr<nsIPrefBranch> prefBranch;
4867:   rv = prefService->GetBranch(NS_BRANCH_DOWNLOAD, 
4867:                               getter_AddRefs(prefBranch));
4867:   NS_ENSURE_SUCCESS(rv, rv);
4867: 
4867:   PRInt32 val;
4867:   rv = prefBranch->GetIntPref(NS_PREF_FOLDERLIST,
4867:                               &val);
4867:   NS_ENSURE_SUCCESS(rv, rv);
4867: 
4867:   PRBool bRes = PR_FALSE;
4867: 
4867:   switch(val) {
4867:     case 0: // Desktop
4867:       {
4867:         nsCOMPtr<nsILocalFile> downloadDir;
4867:         nsCOMPtr<nsIProperties> dirService =
4867:            do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID, &rv);
4867:         NS_ENSURE_SUCCESS(rv, rv);
4867:         rv = dirService->Get(NS_OS_DESKTOP_DIR,
4867:                              NS_GET_IID(nsILocalFile),
4867:                              getter_AddRefs(downloadDir));
4867:         NS_ENSURE_SUCCESS(rv, rv);
4867:         NS_ADDREF(*aResult = downloadDir);
4867:         return NS_OK;
4867:       }
4867:       break;
4867:     case 1: // Downloads
4867:       {
4867:         rv = GetDefaultDownloadsDirectory(aResult); // refup
4867:         NS_ENSURE_SUCCESS(rv, rv);
4867:         (*aResult)->Exists(&bRes);
4867:         if (!bRes) {
4867:           rv = (*aResult)->Create(nsIFile::DIRECTORY_TYPE, 755);
4867:           NS_ENSURE_SUCCESS(rv, rv);
4867:         }
4867:         return NS_OK;
4867:       }
4867:       break;
4867:     case 2: // Custom
4867:       {
4867:         nsCOMPtr<nsISupportsString> customDirectory;
4867:         prefBranch->GetComplexValue(NS_PREF_DIR, 
4867:                                     NS_GET_IID(nsISupportsString),
4867:                                     getter_AddRefs(customDirectory));
4867:         if (customDirectory) {
4867:           nsCOMPtr<nsILocalFile> aFile = 
4867:             do_CreateInstance("@mozilla.org/file/local;1", &rv);
4867:           NS_ENSURE_SUCCESS(rv, rv);
4867:           nsAutoString dir;
4867:           customDirectory->GetData(dir);
4867:           rv = aFile->InitWithNativePath(NS_ConvertUTF16toUTF8(dir));
4867:           NS_ENSURE_SUCCESS(rv, rv);
4867:           aFile->Exists(&bRes);
4867:           if (bRes) {
4867:             NS_ADDREF(*aResult = aFile);
4867:             return NS_OK;
4867:           }
4867:           rv = aFile->Create(nsIFile::DIRECTORY_TYPE, 755);
4867:           NS_ENSURE_SUCCESS(rv, rv);
4867:           if (bRes) {
4867:             NS_ADDREF(*aResult = aFile);
4867:             return NS_OK;
4867:           }
4867:         }
4867:         rv = GetDefaultDownloadsDirectory(aResult); // refup
4867:         NS_ENSURE_SUCCESS(rv, rv);
4867:         (*aResult)->Exists(&bRes);
4867:         if (!bRes) {
4867:           rv = (*aResult)->Create(nsIFile::DIRECTORY_TYPE, 755);
4867:           NS_ENSURE_SUCCESS(rv, rv);
4867:           // Update dir pref
4867:           prefBranch->SetComplexValue(NS_PREF_DIR,
4867:                                       NS_GET_IID(nsILocalFile),
4867:                                       *aResult);
4867:         }
4867:         return NS_OK;
4867:       }
4867:       break;
4867:   }
4867:   return NS_ERROR_INVALID_ARG;
4867: }
4867: 
4867: NS_IMETHODIMP
   1: nsDownloadManager::AddDownload(DownloadType aDownloadType, 
   1:                                nsIURI* aSource,
   1:                                nsIURI* aTarget,
   1:                                const nsAString& aDisplayName,
   1:                                nsIMIMEInfo *aMIMEInfo,
   1:                                PRTime aStartTime,
   1:                                nsILocalFile* aTempFile,
   1:                                nsICancelable* aCancelable,
   1:                                nsIDownload** aDownload)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aSource);
   1:   NS_ENSURE_ARG_POINTER(aTarget);
   1:   NS_ENSURE_ARG_POINTER(aDownload);
   1: 
   1:   nsresult rv;
   1: 
   1:   // target must be on the local filesystem
   1:   nsCOMPtr<nsIFileURL> targetFileURL = do_QueryInterface(aTarget, &rv);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsCOMPtr<nsIFile> targetFile;
   1:   rv = targetFileURL->GetFile(getter_AddRefs(targetFile));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
1691:   nsRefPtr<nsDownload> dl = new nsDownload();
1691:   if (!dl)
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1: 
1691:   // give our new nsIDownload some info so it's ready to go off into the world
1691:   dl->mDownloadManager = this;
1691:   dl->mTarget = aTarget;
1691:   dl->mSource = aSource;
1691:   dl->mTempFile = aTempFile;
   1: 
1691:   dl->mDisplayName = aDisplayName;
1691:   if (dl->mDisplayName.IsEmpty())
1691:     targetFile->GetLeafName(dl->mDisplayName);
   1:  
1691:   dl->mMIMEInfo = aMIMEInfo;
1691:   dl->SetStartTime(aStartTime);
   1: 
2487:   // Creates a cycle that will be broken when the download finishes
1691:   dl->mCancelable = aCancelable;
1691: 
1691:   // Adding to the DB
1691:   nsCAutoString source, target;
1691:   aSource->GetSpec(source);
1691:   aTarget->GetSpec(target);
1691:   
3746:   PRInt64 id = AddDownloadToDB(dl->mDisplayName, source, target, aStartTime, 0,
1691:                                nsIDownloadManager::DOWNLOAD_NOTSTARTED);
1691:   NS_ENSURE_TRUE(id, NS_ERROR_FAILURE);
1691:   dl->mID = id;
   1: 
2116:   rv = AddToCurrentDownloads(dl);
4676:   (void)dl->SetState(nsIDownloadManager::DOWNLOAD_QUEUED);
2116:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
1691:   NS_ADDREF(*aDownload = dl);
   1:   
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
1691: nsDownloadManager::GetDownload(PRUint32 aID, nsIDownload **aDownloadItem)
   1: {
1691:   nsDownload *itm = FindDownload(aID);
   1: 
2330:   nsRefPtr<nsDownload> dl;
1691:   if (!itm) {
2330:     nsresult rv = GetDownloadFromDB(aID, getter_AddRefs(dl));
2330:     NS_ENSURE_SUCCESS(rv, rv);
1691: 
2330:     itm = dl.get();
1691:   }
1691:   
1691:   NS_ADDREF(*aDownloadItem = itm);
1691: 
1691:   return NS_OK;
1691: }
1691: 
1691: nsDownload *
1691: nsDownloadManager::FindDownload(PRUint32 aID)
1691: {
1691:   // we shouldn't ever have many downloads, so we can loop over them
1691:   for (PRInt32 i = mCurrentDownloads.Count() - 1; i >= 0; --i) {
1691:     nsDownload *dl = mCurrentDownloads[i];
1691: 
1691:     if (dl->mID == aID)
1691:       return dl;
1691:   }
1691: 
1691:   return nsnull;
1691: }
1691: 
1691: NS_IMETHODIMP
1691: nsDownloadManager::CancelDownload(PRUint32 aID)
1691: {
1691:   // We AddRef here so we don't lose access to member variables when we remove
1691:   nsRefPtr<nsDownload> dl = FindDownload(aID);
1691:   
1691:   // if it's null, someone passed us a bad id.
1691:   if (!dl)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   // Don't cancel if download is already finished
1691:   if (CompletedSuccessfully(dl->mDownloadState))
   1:     return NS_OK;
   1: 
4557:   // if the download is paused, we have to resume it so we can cancel it
4557:   if (dl->mPaused)
4557:     (void)dl->PauseResume(PR_FALSE);
4557: 
   1:   // Cancel using the provided object
1691:   if (dl->mCancelable)
1691:     dl->mCancelable->Cancel(NS_BINDING_ABORTED);
   1: 
   1:   // Dump the temp file.  This should really be done when the transfer
   1:   // is cancelled, but there are other cancellation causes that shouldn't
   1:   // remove this. We need to improve those bits.
1691:   if (dl->mTempFile) {
   1:     PRBool exists;
1691:     dl->mTempFile->Exists(&exists);
   1:     if (exists)
1691:       dl->mTempFile->Remove(PR_FALSE);
   1:   }
   1: 
5176:   nsresult rv = dl->SetState(nsIDownloadManager::DOWNLOAD_CANCELED);
1808:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
1808:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
2116: nsDownloadManager::RetryDownload(PRUint32 aID)
2116: {
2116:   nsRefPtr<nsDownload> dl;
2116:   nsresult rv = GetDownloadFromDB(aID, getter_AddRefs(dl));
2116:   NS_ENSURE_SUCCESS(rv, rv);
2116: 
2116:   // if our download is not canceled or failed, we should fail
2116:   if (dl->mDownloadState != nsIDownloadManager::DOWNLOAD_FAILED &&
4862:       dl->mDownloadState != nsIDownloadManager::DOWNLOAD_BLOCKED &&
2116:       dl->mDownloadState != nsIDownloadManager::DOWNLOAD_CANCELED)
2116:     return NS_ERROR_FAILURE;
2116: 
2116:   // we are redownloading this, so we need to link the download manager to the
2116:   // download else we'll try to dereference null pointers - eww
2116:   dl->mDownloadManager = this;
2116: 
2116:   dl->SetStartTime(PR_Now());
2116: 
2116:   nsCOMPtr<nsIWebBrowserPersist> wbp =
2116:     do_CreateInstance("@mozilla.org/embedding/browser/nsWebBrowserPersist;1", &rv);
2116:   NS_ENSURE_SUCCESS(rv, rv);
2116: 
2487:   // Creates a cycle that will be broken when the download finishes
2116:   dl->mCancelable = wbp;
2116:   wbp->SetProgressListener(dl);
2116: 
2116:   rv = wbp->SetPersistFlags(nsIWebBrowserPersist::PERSIST_FLAGS_REPLACE_EXISTING_FILES |
2116:                             nsIWebBrowserPersist::PERSIST_FLAGS_AUTODETECT_APPLY_CONVERSION);
4676:   if (NS_FAILED(rv)) {
4676:     dl->mCancelable = nsnull;
4676:     (void)wbp->SetProgressListener(nsnull);
4676:     return rv;
4676:   }
2116: 
2116:   rv = AddToCurrentDownloads(dl);
4676:   if (NS_FAILED(rv)) {
4676:     dl->mCancelable = nsnull;
4676:     (void)wbp->SetProgressListener(nsnull);
4676:     return rv;
4676:   }
4676:   (void)dl->SetState(nsIDownloadManager::DOWNLOAD_QUEUED);
2116: 
4676:   rv = wbp->SaveURI(dl->mSource, nsnull, nsnull, nsnull, nsnull, dl->mTarget);
4676:   if (NS_FAILED(rv)) {
4676:     dl->mCancelable = nsnull;
4676:     (void)wbp->SetProgressListener(nsnull);
4676:     return rv;
4676:   }
4676: 
4676:   return NS_OK;
2116: }
2116: 
2116: NS_IMETHODIMP
1691: nsDownloadManager::RemoveDownload(PRUint32 aID)
   1: {
1691:   nsDownload *dl = FindDownload(aID);
   1:   
1691:   NS_ASSERTION(!dl, "Can't call RemoveDownload on a download in progress!");
1691:   if (dl)
   1:     return NS_ERROR_FAILURE;
   1: 
1691:   nsCOMPtr<mozIStorageStatement> stmt;
1691:   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
1691:     "DELETE FROM moz_downloads "
1691:     "WHERE id = ?1"), getter_AddRefs(stmt));
1691:   NS_ENSURE_SUCCESS(rv, rv);
1691:   rv = stmt->BindInt64Parameter(0, aID); // unsigned; 64-bit to prevent overflow
1691:   NS_ENSURE_SUCCESS(rv, rv);
1691:   return stmt->Execute();
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDownloadManager::CleanUp()
   1: {
   1:   DownloadState states[] = { nsIDownloadManager::DOWNLOAD_FINISHED,
   1:                              nsIDownloadManager::DOWNLOAD_FAILED,
4862:                              nsIDownloadManager::DOWNLOAD_CANCELED,
4862:                              nsIDownloadManager::DOWNLOAD_BLOCKED };
   1: 
1691:   nsCOMPtr<mozIStorageStatement> stmt;
1691:   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
1691:     "DELETE FROM moz_downloads "
1691:     "WHERE state = ?1 "
1691:     "OR state = ?2 "
4862:     "OR state = ?3 "
4862:     "OR state = ?4"), getter_AddRefs(stmt));
1691:   NS_ENSURE_SUCCESS(rv, rv);
4862:   for (PRUint32 i = 0; i < 4; ++i) {
1691:     rv = stmt->BindInt32Parameter(i, states[i]);
1691:     NS_ENSURE_SUCCESS(rv, rv);
   1:   }
   1: 
1691:   return stmt->Execute();
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDownloadManager::GetCanCleanUp(PRBool *aResult)
   1: {
   1:   *aResult = PR_FALSE;
   1: 
   1:   DownloadState states[] = { nsIDownloadManager::DOWNLOAD_FINISHED,
   1:                              nsIDownloadManager::DOWNLOAD_FAILED,
4862:                              nsIDownloadManager::DOWNLOAD_CANCELED,
4862:                              nsIDownloadManager::DOWNLOAD_BLOCKED };
   1: 
1691:   nsCOMPtr<mozIStorageStatement> stmt;
1691:   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
1691:     "SELECT COUNT(*) "
1691:     "FROM moz_downloads "
1691:     "WHERE state = ?1 "
1691:     "OR state = ?2 "
4862:     "OR state = ?3 "
4862:     "OR state = ?4"), getter_AddRefs(stmt));
1691:   NS_ENSURE_SUCCESS(rv, rv);
4862:   for (PRUint32 i = 0; i < 4; ++i) {
1691:     rv = stmt->BindInt32Parameter(i, states[i]);
1691:     NS_ENSURE_SUCCESS(rv, rv);
   1:   }
   1: 
1691:   PRBool moreResults; // We don't really care...
1691:   rv = stmt->ExecuteStep(&moreResults);
1691:   NS_ENSURE_SUCCESS(rv, rv);
   1:  
1691:   PRInt32 count; 
1691:   rv = stmt->GetInt32(0, &count);
   1:   
1691:   if (count > 0)
1691:     *aResult = PR_TRUE;
   1:   
1691:   return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
1691: nsDownloadManager::PauseDownload(PRUint32 aID)
   1: {
1691:   return PauseResumeDownload(aID, PR_TRUE);
   1: }
   1: 
   1: NS_IMETHODIMP
1691: nsDownloadManager::ResumeDownload(PRUint32 aID)
   1: {
1691:   return PauseResumeDownload(aID, PR_FALSE);
1691: }
1691: 
1691: nsresult
1691: nsDownloadManager::PauseResumeDownload(PRUint32 aID, PRBool aPause)
1691: {
1691:   nsDownload *dl = FindDownload(aID);
1691:   
1691:   if (!dl)
1691:     return NS_ERROR_FAILURE;
1691: 
1691:   return dl->PauseResume(aPause);
   1: }
   1: 
   1: NS_IMETHODIMP
1691: nsDownloadManager::GetDBConnection(mozIStorageConnection **aDBConn)
1691: {
1691:   NS_ADDREF(*aDBConn = mDBConn);
1691: 
1691:   return NS_OK;
1691: }
1691: 
1877: NS_IMETHODIMP
1877: nsDownloadManager::AddListener(nsIDownloadProgressListener *aListener)
1877: {
1877:   mListeners.AppendObject(aListener);
1877:   
1877:   return NS_OK;
1877: }
1877: 
1877: NS_IMETHODIMP
1877: nsDownloadManager::RemoveListener(nsIDownloadProgressListener *aListener)
1877: {
1877:   mListeners.RemoveObject(aListener);
1877:   
1877:   return NS_OK;
1877: }
1877: 
1877: void
1877: nsDownloadManager::NotifyListenersOnDownloadStateChange(PRInt16 aOldState,
1877:                                                         nsIDownload *aDownload)
1877: {
1877:   for (PRInt32 i = mListeners.Count() - 1; i >= 0; --i)
1877:     mListeners[i]->OnDownloadStateChange(aOldState, aDownload);
1877: }
1877: 
1877: void
1877: nsDownloadManager::NotifyListenersOnProgressChange(nsIWebProgress *aProgress,
1877:                                                    nsIRequest *aRequest,
1877:                                                    PRInt64 aCurSelfProgress,
1877:                                                    PRInt64 aMaxSelfProgress,
1877:                                                    PRInt64 aCurTotalProgress,
1877:                                                    PRInt64 aMaxTotalProgress,
1877:                                                    nsIDownload *aDownload)
1877: {
1877:   for (PRInt32 i = mListeners.Count() - 1; i >= 0; --i)
1877:     mListeners[i]->OnProgressChange(aProgress, aRequest, aCurSelfProgress,
1877:                                     aMaxSelfProgress, aCurTotalProgress,
1877:                                     aMaxTotalProgress, aDownload);
1877: }
1877: 
1877: void
1877: nsDownloadManager::NotifyListenersOnStateChange(nsIWebProgress *aProgress,
1877:                                                 nsIRequest *aRequest,
1877:                                                 PRUint32 aStateFlags,
1877:                                                 nsresult aStatus,
1877:                                                 nsIDownload *aDownload)
1877: {
1877:   for (PRInt32 i = mListeners.Count() - 1; i >= 0; --i)
1877:     mListeners[i]->OnStateChange(aProgress, aRequest, aStateFlags, aStatus,
1877:                                  aDownload);
1877: }
1877: 
   1: ///////////////////////////////////////////////////////////////////////////////
   1: // nsIObserver
   1: 
   1: NS_IMETHODIMP
1691: nsDownloadManager::Observe(nsISupports *aSubject,
1691:                            const char *aTopic,
1691:                            const PRUnichar* aData)
   1: {
1691:   PRInt32 currDownloadCount = mCurrentDownloads.Count();
1691: 
   1:   nsresult rv;
1691:   if (strcmp(aTopic, "oncancel") == 0) {
1691:     nsCOMPtr<nsIDownload> dl = do_QueryInterface(aSubject, &rv);
1691:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
1691:     PRUint32 id;
1691:     dl->GetId(&id);
1691:     nsDownload *dl2 = FindDownload(id);
4765:     if (dl2)
1691:       return CancelDownload(id);  
1691:   } else if (strcmp(aTopic, "quit-application") == 0) {
1691:     gStoppingDownloads = PR_TRUE;
   1:     
2699:     if (currDownloadCount)
1691:       CancelAllDownloads();
   1: 
   1:     // Now that active downloads have been canceled, remove all downloads if 
   1:     // the user's retention policy specifies it. 
1691:     if (GetRetentionBehavior() == 1)
1691:       CleanUp();
1691:   } else if (strcmp(aTopic, "quit-application-requested") == 0 &&
1691:              currDownloadCount) {
1691:     nsCOMPtr<nsISupportsPRBool> cancelDownloads =
1691:       do_QueryInterface(aSubject, &rv);
1691:     NS_ENSURE_SUCCESS(rv, rv);
   1: #ifndef XP_MACOSX
   1:     ConfirmCancelDownloads(currDownloadCount, cancelDownloads,
   1:                            NS_LITERAL_STRING("quitCancelDownloadsAlertTitle").get(),
   1:                            NS_LITERAL_STRING("quitCancelDownloadsAlertMsgMultiple").get(),
   1:                            NS_LITERAL_STRING("quitCancelDownloadsAlertMsg").get(),
   1:                            NS_LITERAL_STRING("dontQuitButtonWin").get());
   1: #else
   1:     ConfirmCancelDownloads(currDownloadCount, cancelDownloads,
   1:                            NS_LITERAL_STRING("quitCancelDownloadsAlertTitle").get(),
   1:                            NS_LITERAL_STRING("quitCancelDownloadsAlertMsgMacMultiple").get(),
   1:                            NS_LITERAL_STRING("quitCancelDownloadsAlertMsgMac").get(),
   1:                            NS_LITERAL_STRING("dontQuitButtonMac").get());
   1: #endif
1691:   } else if (strcmp(aTopic, "offline-requested") == 0 && currDownloadCount) {
1691:     nsCOMPtr<nsISupportsPRBool> cancelDownloads =
1691:       do_QueryInterface(aSubject, &rv);
1691:     NS_ENSURE_SUCCESS(rv, rv);
   1:     ConfirmCancelDownloads(currDownloadCount, cancelDownloads,
   1:                            NS_LITERAL_STRING("offlineCancelDownloadsAlertTitle").get(),
   1:                            NS_LITERAL_STRING("offlineCancelDownloadsAlertMsgMultiple").get(),
   1:                            NS_LITERAL_STRING("offlineCancelDownloadsAlertMsg").get(),
   1:                            NS_LITERAL_STRING("dontGoOfflineButton").get());
1691:   } else if (strcmp(aTopic, "alertclickcallback") == 0) {
5352:     nsCOMPtr<nsIDownloadManagerUI> dmui =
5352:       do_GetService("@mozilla.org/download-manager-ui;1", &rv);
5352:     NS_ENSURE_SUCCESS(rv, rv);
5352:     return dmui->Show(nsnull, 0);
   1:   }
1691: 
   1:   return NS_OK;
   1: }
   1: 
   1: void
1691: nsDownloadManager::ConfirmCancelDownloads(PRInt32 aCount,
1691:                                           nsISupportsPRBool* aCancelDownloads,
   1:                                           const PRUnichar* aTitle, 
   1:                                           const PRUnichar* aCancelMessageMultiple, 
   1:                                           const PRUnichar* aCancelMessageSingle,
   1:                                           const PRUnichar* aDontCancelButton)
   1: {
   1:   nsXPIDLString title, message, quitButton, dontQuitButton;
   1:   
1691:   mBundle->GetStringFromName(aTitle, getter_Copies(title));    
   1: 
   1:   nsAutoString countString;
   1:   countString.AppendInt(aCount);
   1:   const PRUnichar* strings[1] = { countString.get() };
   1:   if (aCount > 1) {
1691:     mBundle->FormatStringFromName(aCancelMessageMultiple, strings, 1,
1691:                                   getter_Copies(message));
1691:     mBundle->FormatStringFromName(NS_LITERAL_STRING("cancelDownloadsOKTextMultiple").get(),
1691:                                   strings, 1, getter_Copies(quitButton));
1691:   } else {
1691:     mBundle->GetStringFromName(aCancelMessageSingle, getter_Copies(message));
1691:     mBundle->GetStringFromName(NS_LITERAL_STRING("cancelDownloadsOKText").get(),
1691:                                getter_Copies(quitButton));
   1:   }
   1: 
1691:   mBundle->GetStringFromName(aDontCancelButton, getter_Copies(dontQuitButton));
   1: 
   1:   // Get Download Manager window, to be parent of alert.
   1:   nsCOMPtr<nsIWindowMediator> wm = do_GetService(NS_WINDOWMEDIATOR_CONTRACTID);
   1:   nsCOMPtr<nsIDOMWindowInternal> dmWindow;
1691:   if (wm) {
1691:     wm->GetMostRecentWindow(NS_LITERAL_STRING("Download:Manager").get(),
1691:                             getter_AddRefs(dmWindow));
1691:   }
   1: 
   1:   // Show alert.
   1:   nsCOMPtr<nsIPromptService> prompter(do_GetService(NS_PROMPTSERVICE_CONTRACTID));
   1:   if (prompter) {
   1:     PRInt32 flags = (nsIPromptService::BUTTON_TITLE_IS_STRING * nsIPromptService::BUTTON_POS_0) + (nsIPromptService::BUTTON_TITLE_IS_STRING * nsIPromptService::BUTTON_POS_1);
   1:     PRBool nothing = PR_FALSE;
   1:     PRInt32 button;
   1:     prompter->ConfirmEx(dmWindow, title, message, flags, quitButton.get(), dontQuitButton.get(), nsnull, nsnull, &nothing, &button);
   1: 
   1:     aCancelDownloads->SetData(button == 1);
   1:   }
   1: }
   1: 
   1: ///////////////////////////////////////////////////////////////////////////////
   1: // nsDownload
   1: 
   1: NS_IMPL_ISUPPORTS4(nsDownload, nsIDownload, nsITransfer, nsIWebProgressListener,
   1:                    nsIWebProgressListener2)
   1: 
   1: nsDownload::nsDownload() : mDownloadState(nsIDownloadManager::DOWNLOAD_NOTSTARTED),
1691:                            mID(0),
   1:                            mPercentComplete(0),
2534:                            mCurrBytes(0),
2116:                            mMaxBytes(LL_MAXUINT),
2534:                            mStartTime(0),
1691:                            mLastUpdate(PR_Now() - (PRUint32)gUpdateInterval),
   1:                            mPaused(PR_FALSE),
   1:                            mSpeed(0)
   1: {
   1: }
   1: 
   1: nsDownload::~nsDownload()
   1: {  
   1: }
   1: 
1808: nsresult
1691: nsDownload::SetState(DownloadState aState)
   1: {
1837:   NS_ASSERTION(mDownloadState != aState,
1837:                "Trying to set the download state to what it already is set to!");
   1: 
1691:   PRInt16 oldState = mDownloadState;
1691:   mDownloadState = aState;
   1: 
5176:   nsresult rv;
5176: 
5176:   nsCOMPtr<nsIPrefBranch> pref = do_GetService(NS_PREFSERVICE_CONTRACTID);
5176: 
5176:   // We don't want to lose access to our member variables
5176:   nsRefPtr<nsDownload> kungFuDeathGrip = this;
5176: 
5176:   // When the state changed listener is dispatched, queries to the database and
5176:   // the download manager api should reflect what the nsIDownload object would
5176:   // return. So, if a download is done (finished, canceled, etc.), it should
5176:   // first be removed from the current downloads.  We will also have to update
5176:   // the database *before* notifying listeners.  At this point, you can safely
5176:   // dispatch to the observers as well.
5176:   switch (aState) {
5176:     case nsIDownloadManager::DOWNLOAD_BLOCKED:
5176:     case nsIDownloadManager::DOWNLOAD_CANCELED:
5260:     case nsIDownloadManager::DOWNLOAD_FAILED:
5176:       mDownloadManager->CompleteDownload(this);
5176:       break;
5176: #ifdef XP_WIN
5176:     case nsIDownloadManager::DOWNLOAD_SCANNING:
5176:     {
5176:       nsresult rv = mDownloadManager->mScanner ? mDownloadManager->mScanner->ScanDownload(this) : NS_ERROR_NOT_INITIALIZED;
5176:       // If we failed, then fall through to 'download finished'
5176:       if (NS_SUCCEEDED(rv))
5176:         break;
5176:       mDownloadState = aState = nsIDownloadManager::DOWNLOAD_FINISHED;
5176:     }
5176: #endif
5176:     case nsIDownloadManager::DOWNLOAD_FINISHED:
5176:     {
5176:       mDownloadManager->CompleteDownload(this);
5176: 
5176:       // Master pref to control this function. 
5176:       PRBool showTaskbarAlert = PR_TRUE;
5176:       if (pref)
5176:         pref->GetBoolPref(PREF_BDM_SHOWALERTONCOMPLETE, &showTaskbarAlert);
5176: 
5176:       if (showTaskbarAlert) {
5176:         PRInt32 alertInterval = 2000;
5176:         if (pref)
5176:           pref->GetIntPref(PREF_BDM_SHOWALERTINTERVAL, &alertInterval);
5176: 
5176:         PRInt64 alertIntervalUSec = alertInterval * PR_USEC_PER_MSEC;
5176:         PRInt64 goat = PR_Now() - mStartTime;
5176:         showTaskbarAlert = goat > alertIntervalUSec;
5176:        
5176:         PRInt32 size = mDownloadManager->mCurrentDownloads.Count();
5176:         if (showTaskbarAlert && size == 0) {
5176:           nsCOMPtr<nsIAlertsService> alerts =
5176:             do_GetService("@mozilla.org/alerts-service;1");
5176:           if (alerts) {
5176:               nsXPIDLString title, message;
5176: 
5176:               mDownloadManager->mBundle->GetStringFromName(
5176:                   NS_LITERAL_STRING("downloadsCompleteTitle").get(),
5176:                   getter_Copies(title));
5176:               mDownloadManager->mBundle->GetStringFromName(
5176:                   NS_LITERAL_STRING("downloadsCompleteMsg").get(),
5176:                   getter_Copies(message));
5176: 
5176:               PRBool removeWhenDone =
5176:                 mDownloadManager->GetRetentionBehavior() == 0;
5176: 
5176: 
5176:               // If downloads are automatically removed per the user's
5176:               // retention policy, there's no reason to make the text clickable
5176:               // because if it is, they'll click open the download manager and
5176:               // the items they downloaded will have been removed. 
5176:               alerts->ShowAlertNotification(
5176:                   NS_LITERAL_STRING(DOWNLOAD_MANAGER_ALERT_ICON), title,
5176:                   message, !removeWhenDone, EmptyString(), mDownloadManager);
5176:             }
5176:         }
5176:       }
5176: #ifdef XP_WIN
5176:       PRBool addToRecentDocs = PR_TRUE;
5176:       if (pref)
5176:         pref->GetBoolPref(PREF_BDM_ADDTORECENTDOCS, &addToRecentDocs);
5176: 
5176:       if (addToRecentDocs) {
5176:         LPSHELLFOLDER lpShellFolder = NULL;
5176: 
5176:         if (SUCCEEDED(::SHGetDesktopFolder(&lpShellFolder))) {
5176:           nsresult rv;
5176:           nsCOMPtr<nsIFileURL> fileURL = do_QueryInterface(mTarget, &rv);
5176:           NS_ENSURE_SUCCESS(rv, rv);
5176: 
5176:           nsCOMPtr<nsIFile> file;
5176:           rv = fileURL->GetFile(getter_AddRefs(file));
5176:           NS_ENSURE_SUCCESS(rv, rv);
5176:           
5176:           nsAutoString path;
5176:           rv = file->GetPath(path);
5176:           NS_ENSURE_SUCCESS(rv, rv);
5176: 
5176:           PRUnichar *filePath = ToNewUnicode(path);
5176:           LPITEMIDLIST lpItemIDList = NULL;
5176:           if (SUCCEEDED(lpShellFolder->ParseDisplayName(NULL, NULL, filePath,
5176:                   NULL, &lpItemIDList, NULL))) {
5176:             ::SHAddToRecentDocs(SHARD_PIDL, lpItemIDList);
5176:             ::CoTaskMemFree(lpItemIDList);
5176:           }
5176:           nsMemory::Free(filePath);
5176:           lpShellFolder->Release();
5176:         }
5176:       }
5176: #endif
5176: 
5176:       // Now remove the download if the user's retention policy is "Remove when Done"
5176:       if (mDownloadManager->GetRetentionBehavior() == 0)
5176:         mDownloadManager->RemoveDownload(mID);
5176: 
5176:     }
5176:     break;
5176:   default:
5176:     break;
5176:   }
5176:   
1808:   // Before notifying the listener, we must update the database so that calls
1808:   // to it work out properly.
5176:   rv = UpdateDB();
1808:   NS_ENSURE_SUCCESS(rv, rv);
1808: 
1877:   mDownloadManager->NotifyListenersOnDownloadStateChange(oldState, this);
1808: 
5176:   switch (mDownloadState) {
5176:     case nsIDownloadManager::DOWNLOAD_DOWNLOADING:
5176:       mDownloadManager->SendEvent(this, "dl-start");
5176:       break;
5176:     case nsIDownloadManager::DOWNLOAD_FAILED:
5176:       mDownloadManager->SendEvent(this, "dl-failed");
5176:       break;
5176:     case nsIDownloadManager::DOWNLOAD_SCANNING:
5176:       mDownloadManager->SendEvent(this, "dl-scanning");
5176:       break;
5176:     case nsIDownloadManager::DOWNLOAD_FINISHED:
5176:       mDownloadManager->SendEvent(this, "dl-done");
5176:       break;
5176:     case nsIDownloadManager::DOWNLOAD_BLOCKED:
5176:       mDownloadManager->SendEvent(this, "dl-blocked");
5176:       break;
5176:     default:
5176:       break;
5176:   }
1808:   return NS_OK;
   1: }
   1: 
   1: DownloadType
   1: nsDownload::GetDownloadType()
   1: {
   1:   return mDownloadType;
   1: }
   1: 
   1: void
   1: nsDownload::SetStartTime(PRInt64 aStartTime)
   1: {
   1:   mStartTime = aStartTime;
   1:   mLastUpdate = aStartTime;
   1: }
   1: 
   1: ///////////////////////////////////////////////////////////////////////////////
   1: // nsIWebProgressListener2
   1: 
   1: NS_IMETHODIMP
   1: nsDownload::OnProgressChange64(nsIWebProgress *aWebProgress,
   1:                                nsIRequest *aRequest,
   1:                                PRInt64 aCurSelfProgress,
   1:                                PRInt64 aMaxSelfProgress,
   1:                                PRInt64 aCurTotalProgress,
   1:                                PRInt64 aMaxTotalProgress)
   1: {
   1:   if (!mRequest)
   1:     mRequest = aRequest; // used for pause/resume
   1: 
4676:   if (mDownloadState == nsIDownloadManager::DOWNLOAD_QUEUED) {
4765:     // Obtain the referrer
4765:     nsresult rv;
4765:     nsCOMPtr<nsIChannel> channel(do_QueryInterface(aRequest));
4765:     if (channel) {
4765:       // first by trying to get the property
4765:       nsCOMPtr<nsIPropertyBag2> props(do_QueryInterface(channel));
4765:       if (props) {
4765:         // We have to check for a property on a property bag because the
4765:         // referrer may be empty for security reasons (for example, when loading
4765:         // an http page with an https referrer).
4765:         rv = props->GetPropertyAsInterface(NS_LITERAL_STRING("docshell.internalReferrer"),
4765:                                            NS_GET_IID(nsIURI),
4765:                                            getter_AddRefs(mReferrer));
4765:         if (NS_FAILED(rv))
4765:           mReferrer = nsnull;
4765:       }
4765: 
4765:       // if that didn't work, we can still try to get the referrer from the
4765:       // nsIHttpChannel (if we can QI to it)
4765:       if (!mReferrer) {
4765:         nsCOMPtr<nsIHttpChannel> chan = do_QueryInterface(aRequest);
4765:         if (chan) {
4765:           rv = chan->GetReferrer(getter_AddRefs(mReferrer));
4765:           if (NS_FAILED(rv))
4765:             mReferrer = nsnull;
4765:         }
4765:       }
4765:     }
4765: 
4765:     // Update the state and the database
4765:     rv = SetState(nsIDownloadManager::DOWNLOAD_DOWNLOADING);
2138:     NS_ENSURE_SUCCESS(rv, rv);
2138:   }
2138: 
   1:   // filter notifications since they come in so frequently
   1:   PRTime now = PR_Now();
1691:   PRIntervalTime delta = now - mLastUpdate;
1691:   if (delta < gUpdateInterval)
   1:     return NS_OK;
   1: 
   1:   mLastUpdate = now;
   1: 
   1:   // Calculate the speed using the elapsed delta time and bytes downloaded
   1:   // during that time for more accuracy.
   1:   double elapsedSecs = double(delta) / PR_USEC_PER_SEC;
   1:   if (elapsedSecs > 0) {
   1:     nsUint64 curTotalProgress = (PRUint64)aCurTotalProgress;
   1:     nsUint64 diffBytes = curTotalProgress - nsUint64(mCurrBytes);
   1:     double speed = double(diffBytes) / elapsedSecs;
1691:     if (mCurrBytes == 0) {
   1:       mSpeed = speed;
1691:     } else {
   1:       // Calculate 'smoothed average' of 10 readings.
   1:       mSpeed = mSpeed * 0.9 + speed * 0.1;
   1:     }
   1:   }
   1: 
   1:   if (aMaxTotalProgress > 0)
   1:     mPercentComplete = (PRInt32)((PRFloat64)aCurTotalProgress * 100 / aMaxTotalProgress + .5);
   1:   else
   1:     mPercentComplete = -1;
   1: 
   1:   mCurrBytes = aCurTotalProgress;
   1:   mMaxBytes = aMaxTotalProgress;
   1: 
1877:   mDownloadManager->NotifyListenersOnProgressChange(
1877:     aWebProgress, aRequest, aCurSelfProgress, aMaxSelfProgress,
1877:     aCurTotalProgress, aMaxTotalProgress, this);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDownload::OnRefreshAttempted(nsIWebProgress *aWebProgress,
   1:                                nsIURI *aUri,
   1:                                PRInt32 aDelay,
   1:                                PRBool aSameUri,
   1:                                PRBool *allowRefresh)
   1: {
   1:   *allowRefresh = PR_TRUE;
   1:   return NS_OK;
   1: }
   1: 
   1: ///////////////////////////////////////////////////////////////////////////////
   1: // nsIWebProgressListener
   1: 
   1: NS_IMETHODIMP
   1: nsDownload::OnProgressChange(nsIWebProgress *aWebProgress,
   1:                              nsIRequest *aRequest,
   1:                              PRInt32 aCurSelfProgress,
   1:                              PRInt32 aMaxSelfProgress,
   1:                              PRInt32 aCurTotalProgress,
   1:                              PRInt32 aMaxTotalProgress)
   1: {
   1:   return OnProgressChange64(aWebProgress, aRequest,
   1:                             aCurSelfProgress, aMaxSelfProgress,
   1:                             aCurTotalProgress, aMaxTotalProgress);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDownload::OnLocationChange(nsIWebProgress *aWebProgress,
   1:                              nsIRequest *aRequest, nsIURI *aLocation)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDownload::OnStatusChange(nsIWebProgress *aWebProgress,
   1:                            nsIRequest *aRequest, nsresult aStatus,
   1:                            const PRUnichar *aMessage)
   1: {   
   1:   if (NS_FAILED(aStatus)) {
2487:     // We don't want to lose access to our member variables
2487:     nsRefPtr<nsDownload> kungFuDeathGrip = this;
2487: 
5176:     (void)SetState(nsIDownloadManager::DOWNLOAD_FAILED);
   1: 
   1:     // Get title for alert.
   1:     nsXPIDLString title;
   1:     
1691:     nsCOMPtr<nsIStringBundle> bundle = mDownloadManager->mBundle;
1691:     bundle->GetStringFromName(NS_LITERAL_STRING("downloadErrorAlertTitle").get(),
1691:                               getter_Copies(title));
   1: 
   1:     // Get Download Manager window, to be parent of alert.
1691:     nsresult rv;
1691:     nsCOMPtr<nsIWindowMediator> wm =
1691:       do_GetService(NS_WINDOWMEDIATOR_CONTRACTID, &rv);
1691:     NS_ENSURE_SUCCESS(rv, rv);
   1:     nsCOMPtr<nsIDOMWindowInternal> dmWindow;
1691:     wm->GetMostRecentWindow(NS_LITERAL_STRING("Download:Manager").get(),
1691:                             getter_AddRefs(dmWindow));
   1: 
   1:     // Show alert.
1691:     nsCOMPtr<nsIPromptService> prompter =
1691:       do_GetService("@mozilla.org/embedcomp/prompt-service;1", &rv);
1691:     NS_ENSURE_SUCCESS(rv, rv);
   1:     prompter->Alert(dmWindow, title, aMessage);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDownload::OnStateChange(nsIWebProgress* aWebProgress,
   1:                           nsIRequest* aRequest, PRUint32 aStateFlags,
   1:                           nsresult aStatus)
   1: {
   1:   // Record the start time only if it hasn't been set.
2534:   if (mStartTime == 0 && (aStateFlags & STATE_START))
   1:     SetStartTime(PR_Now());
   1: 
1691:   // We don't want to lose access to our member variables
1691:   nsRefPtr<nsDownload> kungFuDeathGrip = this;
   1:   
   1:   // We need to update mDownloadState before updating the dialog, because
   1:   // that will close and call CancelDownload if it was the last open window.
   1: 
4862:   if (aStateFlags & STATE_START) {
4862:     nsresult rv;
4862:     nsCOMPtr<nsIHttpChannel> channel = do_QueryInterface(aRequest, &rv);
4862:     if (NS_SUCCEEDED(rv)) {
4862:       PRUint32 status;
4862:       rv = channel->GetResponseStatus(&status);
4862:       // HTTP 450 - Blocked by parental control proxies
4862:       if (NS_SUCCEEDED(rv) && status == 450) {
4862: 
4862:         // Cancel using the provided object
4862:         if (mCancelable)
4862:           (void)mCancelable->Cancel(NS_BINDING_ABORTED);
4862: 
4862:         // Fail the download - DOWNLOAD_BLOCKED
5176:         (void)SetState(nsIDownloadManager::DOWNLOAD_BLOCKED);
4862: 
4862:         mDownloadManager->NotifyListenersOnStateChange(aWebProgress, aRequest,
4862:                                                        aStateFlags, aStatus, this);
4862: 
4862:         return UpdateDB();
4862:       }
4862:     }
4862:   } else if (aStateFlags & STATE_STOP) {
   1:     if (nsDownloadManager::IsInFinalStage(mDownloadState)) {
5176:       // Set file size at the end of a transfer (for unknown transfer amounts)
1691:       if (mMaxBytes == LL_MAXUINT)
   1:         mMaxBytes = mCurrBytes;
   1: 
   1:       // Files less than 1Kb shouldn't show up as 0Kb.
   1:       if (mMaxBytes < 1024) {
   1:         mCurrBytes = 1024;
   1:         mMaxBytes  = 1024;
   1:       }
   1: 
   1:       mPercentComplete = 100;
   1: 
   1: #ifdef XP_WIN
5176:       (void)SetState(nsIDownloadManager::DOWNLOAD_SCANNING);
5176: #else
5176:       (void)SetState(nsIDownloadManager::DOWNLOAD_FINISHED);
   1: #endif
4862:     }
   1:   }
   1: 
1877:   mDownloadManager->NotifyListenersOnStateChange(aWebProgress, aRequest,
1877:                                                  aStateFlags, aStatus, this);
5176:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDownload::OnSecurityChange(nsIWebProgress *aWebProgress,
   1:                              nsIRequest *aRequest, PRUint32 aState)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: ///////////////////////////////////////////////////////////////////////////////
   1: // nsIDownload
   1: 
   1: NS_IMETHODIMP
   1: nsDownload::Init(nsIURI* aSource,
   1:                  nsIURI* aTarget,
   1:                  const nsAString& aDisplayName,
   1:                  nsIMIMEInfo *aMIMEInfo,
   1:                  PRTime aStartTime,
   1:                  nsILocalFile* aTempFile,
   1:                  nsICancelable* aCancelable)
   1: {
   1:   NS_WARNING("Huh...how did we get here?!");
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
1691: nsDownload::GetState(PRInt16 *aState)
   1: {
1691:   *aState = mDownloadState;
1691: 
1691:   return NS_OK;
1691: }
1691: 
1691: NS_IMETHODIMP
1691: nsDownload::GetDisplayName(nsAString &aDisplayName)
1691: {
1691:   aDisplayName = mDisplayName;
1691: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDownload::GetCancelable(nsICancelable** aCancelable)
   1: {
   1:   *aCancelable = mCancelable;
   1:   NS_IF_ADDREF(*aCancelable);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDownload::GetTarget(nsIURI** aTarget)
   1: {
   1:   *aTarget = mTarget;
   1:   NS_IF_ADDREF(*aTarget);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDownload::GetSource(nsIURI** aSource)
   1: {
   1:   *aSource = mSource;
   1:   NS_IF_ADDREF(*aSource);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDownload::GetStartTime(PRInt64* aStartTime)
   1: {
   1:   *aStartTime = mStartTime;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDownload::GetPercentComplete(PRInt32* aPercentComplete)
   1: {
   1:   *aPercentComplete = mPercentComplete;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDownload::GetAmountTransferred(PRUint64* aAmountTransferred)
   1: {
   1:   *aAmountTransferred = mCurrBytes;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDownload::GetSize(PRUint64* aSize)
   1: {
   1:   *aSize = mMaxBytes;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDownload::GetMIMEInfo(nsIMIMEInfo** aMIMEInfo)
   1: {
   1:   *aMIMEInfo = mMIMEInfo;
   1:   NS_IF_ADDREF(*aMIMEInfo);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDownload::GetTargetFile(nsILocalFile** aTargetFile)
   1: {
   1:   nsresult rv;
   1: 
   1:   nsCOMPtr<nsIFileURL> fileURL = do_QueryInterface(mTarget, &rv);
   1:   if (NS_FAILED(rv)) return rv;
   1: 
   1:   nsCOMPtr<nsIFile> file;
   1:   rv = fileURL->GetFile(getter_AddRefs(file));
   1:   if (NS_SUCCEEDED(rv))
   1:     rv = CallQueryInterface(file, aTargetFile);
   1:   return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDownload::GetSpeed(double* aSpeed)
   1: {
   1:   *aSpeed = mSpeed;
   1:   return NS_OK;
   1: }
   1: 
1691: NS_IMETHODIMP
1691: nsDownload::GetId(PRUint32 *aId)
   1: {
1691:   *aId = mID;
1691: 
1691:   return NS_OK;
   1: }
   1: 
4765: NS_IMETHODIMP 
4765: nsDownload::GetReferrer(nsIURI **referrer)
4765: {
4765:   NS_IF_ADDREF(*referrer = mReferrer);
4765: 
4765:   return NS_OK;
4765: }
4765: 
1691: nsresult
1691: nsDownload::PauseResume(PRBool aPause)
   1: {
1808:   if (mPaused == aPause || !mRequest)
1808:     return NS_OK;
1808: 
1691:   if (aPause) {
1691:     nsresult rv = mRequest->Suspend();
1691:     NS_ENSURE_SUCCESS(rv, rv);
1691:     mPaused = PR_TRUE;
1808:     return SetState(nsIDownloadManager::DOWNLOAD_PAUSED);
1808:   }
1808: 
1691:   nsresult rv = mRequest->Resume();
1691:   NS_ENSURE_SUCCESS(rv, rv);
1691:   mPaused = PR_FALSE;
1808:   return SetState(nsIDownloadManager::DOWNLOAD_DOWNLOADING);
1691: }
1691: 
1691: nsresult
1691: nsDownload::UpdateDB()
1691: {
1691:   NS_ASSERTION(mID, "Download ID is stored as zero.  This is bad!");
2116:   NS_ASSERTION(mDownloadManager, "Egads!  We have no download manager!");
1691: 
3038:   mozIStorageStatement *stmt = mDownloadManager->mUpdateDownloadStatement;
1691: 
1691:   // startTime
4765:   nsresult rv = stmt->BindInt64Parameter(0, mStartTime);
1691:   NS_ENSURE_SUCCESS(rv, rv);
1691: 
1691:   // endTime
4765:   rv = stmt->BindInt64Parameter(1, mLastUpdate);
1691:   NS_ENSURE_SUCCESS(rv, rv);
1691: 
1691:   // state
4765:   rv = stmt->BindInt32Parameter(2, mDownloadState);
4765:   NS_ENSURE_SUCCESS(rv, rv);
4765: 
4765:   // referrer
4765:   if (mReferrer) {
4765:     nsCAutoString referrer;
4765:     rv = mReferrer->GetSpec(referrer);
4765:     NS_ENSURE_SUCCESS(rv, rv);
4765:     rv = stmt->BindUTF8StringParameter(3, referrer);
4765:   } else {
4765:     rv = stmt->BindNullParameter(3);
4765:   }
1691:   NS_ENSURE_SUCCESS(rv, rv);
1691: 
1691:   // id
4765:   rv = stmt->BindInt64Parameter(4, mID);
1691:   NS_ENSURE_SUCCESS(rv, rv);
1691: 
1691:   return stmt->Execute();
1691: }
