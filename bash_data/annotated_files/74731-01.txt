29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
74581:  *   Nick Fitzgerald <nfitzgerald@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS script operations.
    1:  */
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
55477: #include "jsutil.h"
    1: #include "jsprf.h"
    1: #include "jsapi.h"
    1: #include "jsatom.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsdbgapi.h"
    1: #include "jsemit.h"
    1: #include "jsfun.h"
68933: #include "jsgc.h"
68933: #include "jsgcmark.h"
    1: #include "jsinterp.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsopcode.h"
 6561: #include "jsparse.h"
18955: #include "jsscope.h"
    1: #include "jsscript.h"
24879: #include "jstracer.h"
    1: #if JS_HAS_XDR
    1: #include "jsxdrapi.h"
    1: #endif
52559: #include "methodjit/MethodJIT.h"
    1: 
42733: #include "jsobjinlines.h"
32737: #include "jsscriptinlines.h"
32737: 
37741: using namespace js;
54707: using namespace js::gc;
37741: 
59968: namespace js {
59968: 
59968: BindingKind
59992: Bindings::lookup(JSContext *cx, JSAtom *name, uintN *indexp) const
59968: {
59968:     JS_ASSERT(lastBinding);
59968: 
59968:     Shape *shape =
59992:         SHAPE_FETCH(Shape::search(cx->runtime, const_cast<Shape **>(&lastBinding),
59992:                     ATOM_TO_JSID(name)));
59968:     if (!shape)
59968:         return NONE;
59968: 
59968:     if (indexp)
59968:         *indexp = shape->shortid;
59968: 
59968:     if (shape->getter() == GetCallArg)
59968:         return ARGUMENT;
60254:     if (shape->getter() == GetCallUpvar)
59968:         return UPVAR;
59968: 
59968:     return shape->writable() ? VARIABLE : CONSTANT;
59968: }
59968: 
59968: bool
59968: Bindings::add(JSContext *cx, JSAtom *name, BindingKind kind)
59968: {
59968:     JS_ASSERT(lastBinding);
59968: 
59968:     /*
59968:      * We still follow 10.2.3 of ES3 and make argument and variable properties
59968:      * of the Call objects enumerable. ES5 reformulated all of its Clause 10 to
59968:      * avoid objects as activations, something we should do too.
59968:      */
59968:     uintN attrs = JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_SHARED;
59968: 
59968:     uint16 *indexp;
62395:     PropertyOp getter;
62395:     StrictPropertyOp setter;
59968:     uint32 slot = JSObject::CALL_RESERVED_SLOTS;
59968: 
59968:     if (kind == ARGUMENT) {
59968:         JS_ASSERT(nvars == 0);
59968:         JS_ASSERT(nupvars == 0);
59968:         indexp = &nargs;
59968:         getter = GetCallArg;
59968:         setter = SetCallArg;
59968:         slot += nargs;
59968:     } else if (kind == UPVAR) {
59968:         indexp = &nupvars;
60254:         getter = GetCallUpvar;
60254:         setter = SetCallUpvar;
59968:         slot = SHAPE_INVALID_SLOT;
59968:     } else {
59968:         JS_ASSERT(kind == VARIABLE || kind == CONSTANT);
59968:         JS_ASSERT(nupvars == 0);
59968: 
59968:         indexp = &nvars;
59968:         getter = GetCallVar;
59968:         setter = SetCallVar;
59968:         if (kind == CONSTANT)
59968:             attrs |= JSPROP_READONLY;
59968:         slot += nargs + nvars;
59968:     }
59968: 
59974:     if (*indexp == BINDING_COUNT_LIMIT) {
59968:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
59968:                              (kind == ARGUMENT)
59968:                              ? JSMSG_TOO_MANY_FUN_ARGS
59968:                              : JSMSG_TOO_MANY_LOCALS);
59968:         return false;
59968:     }
59968: 
59968:     jsid id;
59968:     if (!name) {
59968:         JS_ASSERT(kind == ARGUMENT); /* destructuring */
59968:         id = INT_TO_JSID(nargs);
59968:     } else {
59968:         id = ATOM_TO_JSID(name);
59968:     }
59968: 
59968:     Shape child(id, getter, setter, slot, attrs, Shape::HAS_SHORTID, *indexp);
59968: 
59968:     Shape *shape = lastBinding->getChild(cx, child, &lastBinding);
59968:     if (!shape)
59968:         return false;
59968: 
59968:     JS_ASSERT(lastBinding == shape);
59968:     ++*indexp;
59968:     return true;
59968: }
59968: 
73058: bool
73058: Bindings::getLocalNameArray(JSContext *cx, Vector<JSAtom *> *namesp)
59968: {
59968:     JS_ASSERT(lastBinding);
59968:     JS_ASSERT(hasLocalNames());
59968: 
73058:     Vector<JSAtom *> &names = *namesp;
73058:     JS_ASSERT(names.empty());
73058: 
59968:     uintN n = countLocalNames();
73058:     if (!names.growByUninitialized(n))
73058:         return false;
59968: 
59968: #ifdef DEBUG
73058:     JSAtom * const POISON = reinterpret_cast<JSAtom *>(0xdeadbeef);
73058:     for (uintN i = 0; i < n; i++)
73058:         names[i] = POISON;
59968: #endif
59968: 
59968:     for (Shape::Range r = lastBinding; !r.empty(); r.popFront()) {
59968:         const Shape &shape = r.front();
59968:         uintN index = uint16(shape.shortid);
59968: 
59968:         if (shape.getter() == GetCallArg) {
59968:             JS_ASSERT(index < nargs);
60254:         } else if (shape.getter() == GetCallUpvar) {
59968:             JS_ASSERT(index < nupvars);
59968:             index += nargs + nvars;
59968:         } else {
59968:             JS_ASSERT(index < nvars);
59968:             index += nargs;
59968:         }
59968: 
69637:         if (JSID_IS_ATOM(shape.propid)) {
73058:             names[index] = JSID_TO_ATOM(shape.propid);
59968:         } else {
69637:             JS_ASSERT(JSID_IS_INT(shape.propid));
59968:             JS_ASSERT(shape.getter() == GetCallArg);
73058:             names[index] = NULL;
59968:         }
59968:     }
59968: 
59968: #ifdef DEBUG
73058:     for (uintN i = 0; i < n; i++)
73058:         JS_ASSERT(names[i] != POISON);
59968: #endif
73058: 
73058:     return true;
59968: }
59968: 
59968: const Shape *
59968: Bindings::lastArgument() const
59968: {
59968:     JS_ASSERT(lastBinding);
59968: 
59968:     const js::Shape *shape = lastVariable();
59968:     if (nvars > 0) {
59968:         while (shape->previous() && shape->getter() != GetCallArg)
59968:             shape = shape->previous();
59968:     }
59968:     return shape;
59968: }
59968: 
59968: const Shape *
59968: Bindings::lastVariable() const
59968: {
59968:     JS_ASSERT(lastBinding);
59968: 
59968:     const js::Shape *shape = lastUpvar();
59968:     if (nupvars > 0) {
60254:         while (shape->getter() == GetCallUpvar)
59968:             shape = shape->previous();
59968:     }
59968:     return shape;
59968: }
59968: 
59968: const Shape *
59968: Bindings::lastUpvar() const
59968: {
59968:     JS_ASSERT(lastBinding);
59968:     return lastBinding;
59968: }
59968: 
59968: int
59968: Bindings::sharpSlotBase(JSContext *cx)
59968: {
59968:     JS_ASSERT(lastBinding);
59968: #if JS_HAS_SHARP_VARS
70270:     if (JSAtom *name = js_Atomize(cx, "#array", 6)) {
59968:         uintN index = uintN(-1);
68941:         DebugOnly<BindingKind> kind = lookup(cx, name, &index);
59968:         JS_ASSERT(kind == VARIABLE);
59968:         return int(index);
59968:     }
59968: #endif
59968:     return -1;
59968: }
59968: 
59968: void
59968: Bindings::makeImmutable()
59968: {
59968:     JS_ASSERT(lastBinding);
59968:     Shape *shape = lastBinding;
59968:     if (shape->inDictionary()) {
59968:         do {
59968:             JS_ASSERT(!shape->frozen());
59968:             shape->setFrozen();
59968:         } while ((shape = shape->parent) != NULL);
59968:     }
59968: }
59968: 
59968: void
59968: Bindings::trace(JSTracer *trc)
59968: {
64360:     if (lastBinding)
64360:         MarkShape(trc, lastBinding, "shape");
59968: }
59968: 
64190: } /* namespace js */
59968: 
74335: static void
74335: volatile_memcpy(volatile char *dst, void *src, size_t n)
74335: {
74335:     for (size_t i = 0; i < n; i++)
74335:         dst[i] = ((char *)src)[i];
74335: }
74335: 
74335: static void
74335: CheckScript(JSScript *script, JSScript *prev)
74335: {
74335:     volatile char dbg1[sizeof(JSScript)], dbg2[sizeof(JSScript)];
74335:     if (script->cookie1 != JS_SCRIPT_COOKIE || script->cookie2 != JS_SCRIPT_COOKIE) {
74335:         volatile_memcpy(dbg1, script, sizeof(JSScript));
74335:         if (prev)
74335:             volatile_memcpy(dbg2, prev, sizeof(JSScript));
74335:     }
74335:     JS_OPT_ASSERT(script->cookie1 == JS_SCRIPT_COOKIE && script->cookie2 == JS_SCRIPT_COOKIE);
74335: }
74335: 
74335: static void
74335: CheckScriptOwner(JSScript *script, JSObject *owner)
74335: {
74335:     if (script->ownerObject != owner) {
74335:         volatile char scriptData[sizeof(JSScript)];
74335:         volatile char owner1Data[sizeof(JSObject)], owner2Data[sizeof(JSObject)];
74335:         volatile char savedOwner[sizeof(JSObject *)];
74335: 
74335:         volatile_memcpy(scriptData, script, sizeof(JSScript));
74335:         volatile_memcpy(savedOwner, &owner, sizeof(JSObject *));
74335:         if (script->ownerObject != JS_NEW_SCRIPT && script->ownerObject != JS_CACHED_SCRIPT)
74335:             volatile_memcpy(owner1Data, script->ownerObject, sizeof(JSObject));
74335:         if (owner != JS_NEW_SCRIPT && owner != JS_CACHED_SCRIPT)
74335:             volatile_memcpy(owner2Data, owner, sizeof(JSObject));
74335:     }
74335:     JS_OPT_ASSERT(script->ownerObject == owner);
74335: 
74335:     if (owner != JS_NEW_SCRIPT && owner != JS_CACHED_SCRIPT)
74335:         JS_OPT_ASSERT(script->compartment == owner->compartment());
74335: }
74335: 
    1: #if JS_HAS_XDR
    1: 
54840: enum ScriptBits {
54840:     NoScriptRval,
54840:     SavedCallerFun,
54840:     HasSharps,
54840:     StrictModeCode,
54840:     UsesEval,
54840:     UsesArguments
54840: };
54840: 
67927: static const char *
67927: SaveScriptFilename(JSContext *cx, const char *filename);
67927: 
    1: JSBool
64300: js_XDRScript(JSXDRState *xdr, JSScript **scriptp)
    1: {
59968:     JSScript *oldscript;
13474:     JSBool ok;
13474:     jsbytecode *code;
59968:     uint32 length, lineno, nslots;
59968:     uint32 natoms, nsrcnotes, ntrynotes, nobjects, nregexps, nconsts, i;
54840:     uint32 prologLength, version, encodedClosedCount;
55503:     uint16 nClosedArgs = 0, nClosedVars = 0;
 3235:     JSPrincipals *principals;
 3235:     uint32 encodeable;
18870:     JSSecurityCallbacks *callbacks;
54840:     uint32 scriptBits = 0;
    1: 
59968:     JSContext *cx = xdr->cx;
59968:     JSScript *script = *scriptp;
59968:     nsrcnotes = ntrynotes = natoms = nobjects = nregexps = nconsts = 0;
59968:     jssrcnote *notes = NULL;
64372:     XDRScriptState *state = xdr->state;
64372: 
64372:     JS_ASSERT(state);
    1: 
52555:     /* Should not XDR scripts optimized for a single global object. */
59221:     JS_ASSERT_IF(script, !JSScript::isValidOffset(script->globalsOffset));
52555: 
59968:     /* XDR arguments, local vars, and upvars. */
59968:     uint16 nargs, nvars, nupvars;
59974: #if defined(DEBUG) || defined(__GNUC__) /* quell GCC overwarning */
59974:     nargs = nvars = nupvars = Bindings::BINDING_COUNT_LIMIT;
59974: #endif
59968:     uint32 argsVars, paddingUpvars;
59968:     if (xdr->mode == JSXDR_ENCODE) {
59968:         nargs = script->bindings.countArgs();
59968:         nvars = script->bindings.countVars();
59968:         nupvars = script->bindings.countUpvars();
59968:         argsVars = (nargs << 16) | nvars;
59968:         paddingUpvars = nupvars;
59968:     }
59968:     if (!JS_XDRUint32(xdr, &argsVars) || !JS_XDRUint32(xdr, &paddingUpvars))
59968:         return false;
59968:     if (xdr->mode == JSXDR_DECODE) {
59968:         nargs = argsVars >> 16;
59968:         nvars = argsVars & 0xFFFF;
59968:         JS_ASSERT((paddingUpvars >> 16) == 0);
59968:         nupvars = paddingUpvars & 0xFFFF;
59968:     }
59974:     JS_ASSERT(nargs != Bindings::BINDING_COUNT_LIMIT);
59974:     JS_ASSERT(nvars != Bindings::BINDING_COUNT_LIMIT);
59974:     JS_ASSERT(nupvars != Bindings::BINDING_COUNT_LIMIT);
59968: 
64242:     EmptyShape *emptyCallShape = EmptyShape::getEmptyCallShape(cx);
64242:     if (!emptyCallShape)
64242:         return false;
64242:     AutoShapeRooter shapeRoot(cx, emptyCallShape);
64242: 
64242:     Bindings bindings(cx, emptyCallShape);
60555:     AutoBindingsRooter rooter(cx, bindings);
59968:     uint32 nameCount = nargs + nvars + nupvars;
59968:     if (nameCount > 0) {
59968:         struct AutoMark {
59968:           JSArenaPool * const pool;
59968:           void * const mark;
59968:           AutoMark(JSArenaPool *pool) : pool(pool), mark(JS_ARENA_MARK(pool)) { }
59968:           ~AutoMark() {
59968:             JS_ARENA_RELEASE(pool, mark);
59968:           }
59968:         } automark(&cx->tempPool);
59968: 
59968:         /*
59968:          * To xdr the names we prefix the names with a bitmap descriptor and
59968:          * then xdr the names as strings. For argument names (indexes below
59968:          * nargs) the corresponding bit in the bitmap is unset when the name
59968:          * is null. Such null names are not encoded or decoded. For variable
59968:          * names (indexes starting from nargs) bitmap's bit is set when the
59968:          * name is declared as const, not as ordinary var.
59968:          * */
59968:         uintN bitmapLength = JS_HOWMANY(nameCount, JS_BITS_PER_UINT32);
59968:         uint32 *bitmap;
59968:         JS_ARENA_ALLOCATE_CAST(bitmap, uint32 *, &cx->tempPool,
59968:                                bitmapLength * sizeof *bitmap);
59968:         if (!bitmap) {
71371:             js_ReportOutOfMemory(cx);
59968:             return false;
59968:         }
59968: 
73058:         Vector<JSAtom *> names(cx);
59968:         if (xdr->mode == JSXDR_ENCODE) {
73058:             if (!script->bindings.getLocalNameArray(cx, &names))
59968:                 return false;
59968:             PodZero(bitmap, bitmapLength);
59968:             for (uintN i = 0; i < nameCount; i++) {
73058:                 if (i < nargs && names[i])
59968:                     bitmap[i >> JS_BITS_PER_UINT32_LOG2] |= JS_BIT(i & (JS_BITS_PER_UINT32 - 1));
59968:             }
59968:         }
59968:         for (uintN i = 0; i < bitmapLength; ++i) {
59968:             if (!JS_XDRUint32(xdr, &bitmap[i]))
59968:                 return false;
59968:         }
59968: 
59968:         for (uintN i = 0; i < nameCount; i++) {
59968:             if (i < nargs &&
59968:                 !(bitmap[i >> JS_BITS_PER_UINT32_LOG2] & JS_BIT(i & (JS_BITS_PER_UINT32 - 1))))
59968:             {
59968:                 if (xdr->mode == JSXDR_DECODE) {
59968:                     uint16 dummy;
59968:                     if (!bindings.addDestructuring(cx, &dummy))
59968:                         return false;
59968:                 } else {
73058:                     JS_ASSERT(!names[i]);
59968:                 }
59968:                 continue;
59968:             }
59968: 
59968:             JSAtom *name;
59968:             if (xdr->mode == JSXDR_ENCODE)
73058:                 name = names[i];
59968:             if (!js_XDRAtom(xdr, &name))
59968:                 return false;
59968:             if (xdr->mode == JSXDR_DECODE) {
59968:                 BindingKind kind = (i < nargs)
59968:                                    ? ARGUMENT
59987:                                    : (i < uintN(nargs + nvars))
59968:                                    ? (bitmap[i >> JS_BITS_PER_UINT32_LOG2] &
59968:                                       JS_BIT(i & (JS_BITS_PER_UINT32 - 1))
59968:                                       ? CONSTANT
59968:                                       : VARIABLE)
59968:                                    : UPVAR;
59968:                 if (!bindings.add(cx, name, kind))
59968:                     return false;
59968:             }
59968:         }
59968: 
59968:         if (xdr->mode == JSXDR_DECODE)
59968:             bindings.makeImmutable();
59968:     }
59968: 
34290:     if (xdr->mode == JSXDR_ENCODE)
59220:         length = script->length;
34290:     if (!JS_XDRUint32(xdr, &length))
34290:         return JS_FALSE;
34290: 
34290:     if (xdr->mode == JSXDR_ENCODE) {
25144:         prologLength = script->main - script->code;
53848:         JS_ASSERT(script->getVersion() != JSVERSION_UNKNOWN);
53848:         version = (uint32)script->getVersion() | (script->nfixed << 16);
    1:         lineno = (uint32)script->lineno;
16072:         nslots = (uint32)script->nslots;
27012:         nslots = (uint32)((script->staticLevel << 16) | script->nslots);
 3235:         natoms = (uint32)script->atomMap.length;
    1: 
32723:         notes = script->notes();
72071:         nsrcnotes = script->numNotes();
    1: 
59221:         if (JSScript::isValidOffset(script->objectsOffset))
32723:             nobjects = script->objects()->length;
59221:         if (JSScript::isValidOffset(script->upvarsOffset))
59968:             JS_ASSERT(script->bindings.countUpvars() == script->upvars()->length);
59221:         if (JSScript::isValidOffset(script->regexpsOffset))
32723:             nregexps = script->regexps()->length;
59221:         if (JSScript::isValidOffset(script->trynotesOffset))
32723:             ntrynotes = script->trynotes()->length;
59221:         if (JSScript::isValidOffset(script->constOffset))
48470:             nconsts = script->consts()->length;
54840: 
54840:         nClosedArgs = script->nClosedArgs;
54840:         nClosedVars = script->nClosedVars;
54840:         encodedClosedCount = (nClosedArgs << 16) | nClosedVars;
54840: 
54840:         if (script->noScriptRval)
54840:             scriptBits |= (1 << NoScriptRval);
54840:         if (script->savedCallerFun)
54840:             scriptBits |= (1 << SavedCallerFun);
54840:         if (script->hasSharps)
54840:             scriptBits |= (1 << HasSharps);
54840:         if (script->strictModeCode)
54840:             scriptBits |= (1 << StrictModeCode);
54840:         if (script->usesEval)
54840:             scriptBits |= (1 << UsesEval);
54840:         if (script->usesArguments)
54840:             scriptBits |= (1 << UsesArguments);
59962:         JS_ASSERT(!script->compileAndGo);
59962:         JS_ASSERT(!script->hasSingletons);
    1:     }
    1: 
    1:     if (!JS_XDRUint32(xdr, &prologLength))
    1:         return JS_FALSE;
    1:     if (!JS_XDRUint32(xdr, &version))
    1:         return JS_FALSE;
    1: 
 3235:     /*
59968:      * To fuse allocations, we need srcnote, atom, objects, regexp, and trynote
59968:      * counts early.
 3235:      */
 3235:     if (!JS_XDRUint32(xdr, &natoms))
 3235:         return JS_FALSE;
    1:     if (!JS_XDRUint32(xdr, &nsrcnotes))
    1:         return JS_FALSE;
    1:     if (!JS_XDRUint32(xdr, &ntrynotes))
    1:         return JS_FALSE;
 3235:     if (!JS_XDRUint32(xdr, &nobjects))
 3235:         return JS_FALSE;
 3235:     if (!JS_XDRUint32(xdr, &nregexps))
 3235:         return JS_FALSE;
48470:     if (!JS_XDRUint32(xdr, &nconsts))
48470:         return JS_FALSE;
54840:     if (!JS_XDRUint32(xdr, &encodedClosedCount))
54840:         return JS_FALSE;
54840:     if (!JS_XDRUint32(xdr, &scriptBits))
54840:         return JS_FALSE;
    1: 
40395:     AutoScriptRooter tvr(cx, NULL);
40395: 
    1:     if (xdr->mode == JSXDR_DECODE) {
54840:         nClosedArgs = encodedClosedCount >> 16;
54840:         nClosedVars = encodedClosedCount & 0xFFFF;
54840: 
61450:         /* Note: version is packed into the 32b space with another 16b value. */
61450:         JSVersion version_ = JSVersion(version & JS_BITMASK(16));
61450:         JS_ASSERT((version_ & VersionFlags::FULL_MASK) == uintN(version_));
54840:         script = JSScript::NewScript(cx, length, nsrcnotes, natoms, nobjects, nupvars,
54840:                                      nregexps, ntrynotes, nconsts, 0, nClosedArgs,
61450:                                      nClosedVars, version_);
    1:         if (!script)
    1:             return JS_FALSE;
 3235: 
59968:         script->bindings.transfer(cx, &bindings);
59968: 
    1:         script->main += prologLength;
25628:         script->nfixed = uint16(version >> 16);
    1: 
    1:         /* If we know nsrcnotes, we allocated space for notes in script. */
32723:         notes = script->notes();
    1:         *scriptp = script;
40395:         tvr.setScript(script);
54840: 
54840:         if (scriptBits & (1 << NoScriptRval))
54840:             script->noScriptRval = true;
54840:         if (scriptBits & (1 << SavedCallerFun))
54840:             script->savedCallerFun = true;
54840:         if (scriptBits & (1 << HasSharps))
54840:             script->hasSharps = true;
54840:         if (scriptBits & (1 << StrictModeCode))
54840:             script->strictModeCode = true;
54840:         if (scriptBits & (1 << UsesEval))
54840:             script->usesEval = true;
54840:         if (scriptBits & (1 << UsesArguments))
54840:             script->usesArguments = true;
    1:     }
    1: 
    1:     /*
 3235:      * Control hereafter must goto error on failure, in order for the
 3235:      * DECODE case to destroy script.
    1:      */
    1:     oldscript = xdr->script;
13474:     code = script->code;
13474:     if (xdr->mode == JSXDR_ENCODE) {
13496:         code = js_UntrapScriptCode(cx, script);
13474:         if (!code)
13474:             goto error;
13474:     }
13474: 
    1:     xdr->script = script;
13474:     ok = JS_XDRBytes(xdr, (char *) code, length * sizeof(jsbytecode));
13474: 
13474:     if (code != script->code)
64560:         cx->free_(code);
13474: 
13474:     if (!ok)
    1:         goto error;
    1: 
    1:     if (!JS_XDRBytes(xdr, (char *)notes, nsrcnotes * sizeof(jssrcnote)) ||
    1:         !JS_XDRUint32(xdr, &lineno) ||
16072:         !JS_XDRUint32(xdr, &nslots)) {
    1:         goto error;
    1:     }
    1: 
64372:     if (xdr->mode == JSXDR_DECODE && state->filename) {
64372:         if (!state->filenameSaved) {
64372:             const char *filename = state->filename;
67927:             filename = SaveScriptFilename(xdr->cx, filename);
64560:             xdr->cx->free_((void *) state->filename);
64372:             state->filename = filename;
64372:             state->filenameSaved = true;
64372:             if (!filename)
64372:                 goto error;
64372:         }
64372:         script->filename = state->filename;
64372:     }
64301: 
64372:     JS_ASSERT_IF(xdr->mode == JSXDR_ENCODE, state->filename == script->filename);
64301: 
18870:     callbacks = JS_GetSecurityCallbacks(cx);
    1:     if (xdr->mode == JSXDR_ENCODE) {
    1:         principals = script->principals;
18870:         encodeable = callbacks && callbacks->principalsTranscoder;
    1:         if (!JS_XDRUint32(xdr, &encodeable))
    1:             goto error;
    1:         if (encodeable &&
18870:             !callbacks->principalsTranscoder(xdr, &principals)) {
    1:             goto error;
    1:         }
    1:     } else {
    1:         if (!JS_XDRUint32(xdr, &encodeable))
    1:             goto error;
    1:         if (encodeable) {
18870:             if (!(callbacks && callbacks->principalsTranscoder)) {
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_CANT_DECODE_PRINCIPALS);
    1:                 goto error;
    1:             }
18870:             if (!callbacks->principalsTranscoder(xdr, &principals))
    1:                 goto error;
    1:             script->principals = principals;
    1:         }
    1:     }
    1: 
    1:     if (xdr->mode == JSXDR_DECODE) {
    1:         script->lineno = (uintN)lineno;
18308:         script->nslots = (uint16)nslots;
27012:         script->staticLevel = (uint16)(nslots >> 16);
 3235:     }
    1: 
 3235:     for (i = 0; i != natoms; ++i) {
 3235:         if (!js_XDRAtom(xdr, &script->atomMap.vector[i]))
 3235:             goto error;
 3235:     }
 1825: 
    1:     /*
 3235:      * Here looping from 0-to-length to xdr objects is essential. It ensures
18308:      * that block objects from the script->objects array will be written and
28093:      * restored in the outer-to-inner order. js_XDRBlockObject relies on this
28093:      * to restore the parent chain.
    1:      */
 3235:     for (i = 0; i != nobjects; ++i) {
32723:         JSObject **objp = &script->objects()->vector[i];
28093:         uint32 isBlock;
28093:         if (xdr->mode == JSXDR_ENCODE) {
48470:             Class *clasp = (*objp)->getClass();
28093:             JS_ASSERT(clasp == &js_FunctionClass ||
28093:                       clasp == &js_BlockClass);
28093:             isBlock = (clasp == &js_BlockClass) ? 1 : 0;
28093:         }
28093:         if (!JS_XDRUint32(xdr, &isBlock))
    1:             goto error;
28093:         if (isBlock == 0) {
28093:             if (!js_XDRFunctionObject(xdr, objp))
28093:                 goto error;
28093:         } else {
28093:             JS_ASSERT(isBlock == 1);
28093:             if (!js_XDRBlockObject(xdr, objp))
28093:                 goto error;
28093:         }
    1:     }
18308:     for (i = 0; i != nupvars; ++i) {
47573:         if (!JS_XDRUint32(xdr, reinterpret_cast<uint32 *>(&script->upvars()->vector[i])))
18308:             goto error;
18308:     }
 3235:     for (i = 0; i != nregexps; ++i) {
32723:         if (!js_XDRRegExpObject(xdr, &script->regexps()->vector[i]))
 3235:             goto error;
    1:     }
54840:     for (i = 0; i != nClosedArgs; ++i) {
54840:         if (!JS_XDRUint32(xdr, &script->closedSlots[i]))
54840:             goto error;
54840:     }
54840:     for (i = 0; i != nClosedVars; ++i) {
54840:         if (!JS_XDRUint32(xdr, &script->closedSlots[nClosedArgs + i]))
54840:             goto error;
54840:     }
    1: 
 3235:     if (ntrynotes != 0) {
 1825:         /*
 3235:          * We combine tn->kind and tn->stackDepth when serializing as XDR is not
 1825:          * efficient when serializing small integer types.
 1825:          */
 3235:         JSTryNote *tn, *tnfirst;
 3235:         uint32 kindAndDepth;
 1825:         JS_STATIC_ASSERT(sizeof(tn->kind) == sizeof(uint8));
 1825:         JS_STATIC_ASSERT(sizeof(tn->stackDepth) == sizeof(uint16));
    1: 
32723:         tnfirst = script->trynotes()->vector;
32723:         JS_ASSERT(script->trynotes()->length == ntrynotes);
 3235:         tn = tnfirst + ntrynotes;
 3235:         do {
 3235:             --tn;
 3235:             if (xdr->mode == JSXDR_ENCODE) {
 3235:                 kindAndDepth = ((uint32)tn->kind << 16)
 3235:                                | (uint32)tn->stackDepth;
 3235:             }
 1825:             if (!JS_XDRUint32(xdr, &kindAndDepth) ||
 1825:                 !JS_XDRUint32(xdr, &tn->start) ||
 1825:                 !JS_XDRUint32(xdr, &tn->length)) {
    1:                 goto error;
    1:             }
 3235:             if (xdr->mode == JSXDR_DECODE) {
 1825:                 tn->kind = (uint8)(kindAndDepth >> 16);
 1825:                 tn->stackDepth = (uint16)kindAndDepth;
    1:             }
 3235:         } while (tn != tnfirst);
 3235:     }
    1: 
48470:     for (i = 0; i != nconsts; ++i) {
48470:         if (!JS_XDRValue(xdr, Jsvalify(&script->consts()->vector[i])))
48470:             goto error;
48470:     }
48470: 
    1:     xdr->script = oldscript;
    1:     return JS_TRUE;
    1: 
    1:   error:
    1:     if (xdr->mode == JSXDR_DECODE) {
74723:         js_DestroyScript(cx, script, 1);
    1:         *scriptp = NULL;
    1:     }
 3235:     xdr->script = oldscript;
    1:     return JS_FALSE;
    1: }
    1: 
    1: #endif /* JS_HAS_XDR */
    1: 
71699: bool
71699: JSPCCounters::init(JSContext *cx, size_t numBytecodes)
71699: {
71699:     this->numBytecodes = numBytecodes;
71699:     size_t nbytes = sizeof(*counts) * numBytecodes * JSRUNMODE_COUNT;
71699:     counts = (int*) cx->malloc_(nbytes);
71699:     if (!counts)
71699:         return false;
71699:     memset(counts, 0, nbytes);
71699:     return true;
71699: }
71699: 
71702: void
71702: JSPCCounters::destroy(JSContext *cx)
71702: {
71702:     if (counts) {
71702:         cx->free_(counts);
71702:         counts = NULL;
71702:     }
71702: }
71702: 
    1: static void
    1: script_finalize(JSContext *cx, JSObject *obj)
    1: {
31452:     JSScript *script = (JSScript *) obj->getPrivate();
    1:     if (script)
74335:         js_DestroyScriptFromGC(cx, script, obj);
    1: }
    1: 
  583: static void
  583: script_trace(JSTracer *trc, JSObject *obj)
    1: {
31452:     JSScript *script = (JSScript *) obj->getPrivate();
    1:     if (script)
74335:         js_TraceScript(trc, script, obj);
    1: }
    1: 
48470: Class js_ScriptClass = {
39926:     "Script",
40885:     JSCLASS_HAS_PRIVATE |
64218:     JSCLASS_HAS_CACHED_PROTO(JSProto_Object),
48622:     PropertyStub,         /* addProperty */
48622:     PropertyStub,         /* delProperty */
48622:     PropertyStub,         /* getProperty */
62395:     StrictPropertyStub,   /* setProperty */
48622:     EnumerateStub,
48622:     ResolveStub,
48622:     ConvertStub,
48622:     script_finalize,
48622:     NULL,                 /* reserved0   */
48622:     NULL,                 /* checkAccess */
48622:     NULL,                 /* call        */
48622:     NULL,                 /* construct   */
48622:     NULL,                 /* xdrObject   */
48622:     NULL,                 /* hasInstance */
64218:     script_trace
    1: };
    1: 
    1: /*
    1:  * Shared script filename management.
    1:  */
    1: 
67927: static const char *
67927: SaveScriptFilename(JSContext *cx, const char *filename)
67927: {
73899:     JSCompartment *comp = cx->compartment;
    1: 
73899:     ScriptFilenameTable::AddPtr p = comp->scriptFilenameTable.lookupForAdd(filename);
73899:     if (!p) {
73899:         size_t size = offsetof(ScriptFilenameEntry, filename) + strlen(filename) + 1;
73899:         ScriptFilenameEntry *entry = (ScriptFilenameEntry *) cx->malloc_(size);
73899:         if (!entry)
73899:             return NULL;
73899:         entry->marked = false;
73899:         strcpy(entry->filename, filename);
    1: 
73899:         if (!comp->scriptFilenameTable.add(p, entry)) {
73899:             Foreground::free_(entry);
67927:             JS_ReportOutOfMemory(cx);
    1:             return NULL;
67927:         }
    1:     }
    1: 
73899:     return (*p)->filename;
    1: }
    1: 
    1: /*
    1:  * Back up from a saved filename by its offset within its hash table entry.
    1:  */
    1: #define FILENAME_TO_SFE(fn) \
    1:     ((ScriptFilenameEntry *) ((fn) - offsetof(ScriptFilenameEntry, filename)))
    1: 
    1: void
    1: js_MarkScriptFilename(const char *filename)
    1: {
73899:     ScriptFilenameEntry *sfe = FILENAME_TO_SFE(filename);
73899:     sfe->marked = true;
    1: }
    1: 
    1: void
73899: js_SweepScriptFilenames(JSCompartment *comp)
    1: {
73899:     ScriptFilenameTable &table = comp->scriptFilenameTable;
73899:     for (ScriptFilenameTable::Enum e(table); !e.empty(); e.popFront()) {
73899:         ScriptFilenameEntry *entry = e.front();
73899:         if (entry->marked) {
73899:             entry->marked = false;
73899:         } else if (!comp->rt->gcKeepAtoms) {
73899:             Foreground::free_(entry);
73899:             e.removeFront();
    1:         }
    1:     }
    1: }
    1: 
 3235: /*
 3235:  * JSScript data structures memory alignment:
 3235:  *
 3235:  * JSScript
 3235:  * JSObjectArray    script objects' descriptor if JSScript.objectsOffset != 0,
32723:  *                    use script->objects() to access it.
 3235:  * JSObjectArray    script regexps' descriptor if JSScript.regexpsOffset != 0,
32723:  *                    use script->regexps() to access it.
 3235:  * JSTryNoteArray   script try notes' descriptor if JSScript.tryNotesOffset
32723:  *                    != 0, use script->trynotes() to access it.
 3235:  * JSAtom *a[]      array of JSScript.atomMap.length atoms pointed by
 3235:  *                    JSScript.atomMap.vector if any.
32723:  * JSObject *o[]    array of script->objects()->length objects if any
32723:  *                    pointed by script->objects()->vector.
32723:  * JSObject *r[]    array of script->regexps()->length regexps if any
32723:  *                    pointed by script->regexps()->vector.
32723:  * JSTryNote t[]    array of script->trynotes()->length try notes if any
32723:  *                    pointed by script->trynotes()->vector.
 3235:  * jsbytecode b[]   script bytecode pointed by JSScript.code.
32723:  * jssrcnote  s[]   script source notes, use script->notes() to access it
 3235:  *
 3235:  * The alignment avoids gaps between entries as alignment requirement for each
 3235:  * subsequent structure or array is the same or divides the alignment
 3235:  * requirement for the previous one.
 3235:  *
 3235:  * The followings asserts checks that assuming that the alignment requirement
 3235:  * for JSObjectArray and JSTryNoteArray are sizeof(void *) and for JSTryNote
 3235:  * it is sizeof(uint32) as the structure consists of 3 uint32 fields.
 3235:  */
 3235: JS_STATIC_ASSERT(sizeof(JSScript) % sizeof(void *) == 0);
 3235: JS_STATIC_ASSERT(sizeof(JSObjectArray) % sizeof(void *) == 0);
 3235: JS_STATIC_ASSERT(sizeof(JSTryNoteArray) == sizeof(JSObjectArray));
 3235: JS_STATIC_ASSERT(sizeof(JSAtom *) == sizeof(JSObject *));
 3235: JS_STATIC_ASSERT(sizeof(JSObject *) % sizeof(uint32) == 0);
 3235: JS_STATIC_ASSERT(sizeof(JSTryNote) == 3 * sizeof(uint32));
 3235: JS_STATIC_ASSERT(sizeof(uint32) % sizeof(jsbytecode) == 0);
 3235: JS_STATIC_ASSERT(sizeof(jsbytecode) % sizeof(jssrcnote) == 0);
 3235: 
 3235: /*
62029:  * Check that uint8 offsets is enough to reach any optional array allocated
62029:  * after JSScript. For that we check that the maximum possible offset for
62029:  * JSConstArray, that last optional array, still fits 1 byte and do not
62029:  * coincide with INVALID_OFFSET.
 3235:  */
62029: JS_STATIC_ASSERT(sizeof(JSObjectArray) +
62029:                  sizeof(JSUpvarArray) +
62029:                  sizeof(JSObjectArray) +
62029:                  sizeof(JSTryNoteArray) +
62029:                  sizeof(js::GlobalSlotArray)
62029:                  < JSScript::INVALID_OFFSET);
62029: JS_STATIC_ASSERT(JSScript::INVALID_OFFSET <= 255);
 3235: 
    1: JSScript *
54840: JSScript::NewScript(JSContext *cx, uint32 length, uint32 nsrcnotes, uint32 natoms,
18308:                     uint32 nobjects, uint32 nupvars, uint32 nregexps,
54840:                     uint32 ntrynotes, uint32 nconsts, uint32 nglobals,
61450:                     uint16 nClosedArgs, uint16 nClosedVars, JSVersion version)
    1: {
64242:     EmptyShape *emptyCallShape = EmptyShape::getEmptyCallShape(cx);
64242:     if (!emptyCallShape)
64242:         return NULL;
64242:     AutoShapeRooter shapeRoot(cx, emptyCallShape);
64242: 
 3235:     size_t size, vectorSize;
    1:     JSScript *script;
 3235:     uint8 *cursor;
48470:     unsigned constPadding = 0;
    1: 
54840:     uint32 totalClosed = nClosedArgs + nClosedVars;
54840: 
 3235:     size = sizeof(JSScript) +
48470:            sizeof(JSAtom *) * natoms;
48470: 
 3235:     if (nobjects != 0)
 3235:         size += sizeof(JSObjectArray) + nobjects * sizeof(JSObject *);
18308:     if (nupvars != 0)
18308:         size += sizeof(JSUpvarArray) + nupvars * sizeof(uint32);
 3235:     if (nregexps != 0)
 3235:         size += sizeof(JSObjectArray) + nregexps * sizeof(JSObject *);
 3235:     if (ntrynotes != 0)
 3235:         size += sizeof(JSTryNoteArray) + ntrynotes * sizeof(JSTryNote);
52555:     if (nglobals != 0)
52555:         size += sizeof(GlobalSlotArray) + nglobals * sizeof(GlobalSlotArray::Entry);
54840:     if (totalClosed != 0)
54840:         size += totalClosed * sizeof(uint32);
 3235: 
48470:     if (nconsts != 0) {
48470:         size += sizeof(JSConstArray);
48470:         /*
48470:          * Calculate padding assuming that consts go after the other arrays,
48470:          * but before the bytecode and source notes.
48470:          */
48470:         constPadding = (8 - (size % 8)) % 8;
48470:         size += constPadding + nconsts * sizeof(Value);
48470:     }
48470: 
48470:     size += length * sizeof(jsbytecode) +
48470:             nsrcnotes * sizeof(jssrcnote);
48470: 
64560:     script = (JSScript *) cx->malloc_(size);
    1:     if (!script)
    1:         return NULL;
53391: 
40229:     PodZero(script);
74070:     script->cookie1 = script->cookie2 = JS_SCRIPT_COOKIE;
74335:     script->ownerObject = JS_NEW_SCRIPT;
    1:     script->length = length;
61450:     script->version = version;
64242:     new (&script->bindings) Bindings(cx, emptyCallShape);
 3235: 
71699:     if (cx->hasRunOption(JSOPTION_PCCOUNT))
71699:         (void) script->pcCounters.init(cx, length);
71699: 
59221:     uint8 *scriptEnd = reinterpret_cast<uint8 *>(script + 1);
59221: 
59968:     cursor = scriptEnd;
 3235:     if (nobjects != 0) {
59221:         script->objectsOffset = (uint8)(cursor - scriptEnd);
 3235:         cursor += sizeof(JSObjectArray);
59221:     } else {
59221:         script->objectsOffset = JSScript::INVALID_OFFSET;
 3235:     }
18308:     if (nupvars != 0) {
59221:         script->upvarsOffset = (uint8)(cursor - scriptEnd);
18308:         cursor += sizeof(JSUpvarArray);
59221:     } else {
59221:         script->upvarsOffset = JSScript::INVALID_OFFSET;
18308:     }
 3235:     if (nregexps != 0) {
59221:         script->regexpsOffset = (uint8)(cursor - scriptEnd);
 3235:         cursor += sizeof(JSObjectArray);
59221:     } else {
59221:         script->regexpsOffset = JSScript::INVALID_OFFSET;
 3235:     }
 3235:     if (ntrynotes != 0) {
59221:         script->trynotesOffset = (uint8)(cursor - scriptEnd);
 3235:         cursor += sizeof(JSTryNoteArray);
59221:     } else {
59221:         script->trynotesOffset = JSScript::INVALID_OFFSET;
 3235:     }
52555:     if (nglobals != 0) {
59221:         script->globalsOffset = (uint8)(cursor - scriptEnd);
52555:         cursor += sizeof(GlobalSlotArray);
59221:     } else {
59221:         script->globalsOffset = JSScript::INVALID_OFFSET;
52555:     }
59968:     JS_ASSERT(cursor - scriptEnd < 0xFF);
48470:     if (nconsts != 0) {
59221:         script->constOffset = (uint8)(cursor - scriptEnd);
48470:         cursor += sizeof(JSConstArray);
59221:     } else {
59221:         script->constOffset = JSScript::INVALID_OFFSET;
48470:     }
 3235: 
59221:     JS_STATIC_ASSERT(sizeof(JSObjectArray) +
56003:                      sizeof(JSUpvarArray) +
56003:                      sizeof(JSObjectArray) +
56003:                      sizeof(JSTryNoteArray) +
59221:                      sizeof(GlobalSlotArray) < 0xFF);
56003: 
 3235:     if (natoms != 0) {
 3235:         script->atomMap.length = natoms;
 3235:         script->atomMap.vector = (JSAtom **)cursor;
 3235:         vectorSize = natoms * sizeof(script->atomMap.vector[0]);
 3235: 
 3235:         /*
 3235:          * Clear object map's vector so the GC tracing can run when not yet
 3235:          * all atoms are copied to the array.
 3235:          */
 3235:         memset(cursor, 0, vectorSize);
 3235:         cursor += vectorSize;
 3235:     }
17218: 
 3235:     if (nobjects != 0) {
32723:         script->objects()->length = nobjects;
32723:         script->objects()->vector = (JSObject **)cursor;
32723:         vectorSize = nobjects * sizeof(script->objects()->vector[0]);
 3235:         memset(cursor, 0, vectorSize);
 3235:         cursor += vectorSize;
 3235:     }
18308: 
 3235:     if (nregexps != 0) {
32723:         script->regexps()->length = nregexps;
32723:         script->regexps()->vector = (JSObject **)cursor;
32723:         vectorSize = nregexps * sizeof(script->regexps()->vector[0]);
 3235:         memset(cursor, 0, vectorSize);
 3235:         cursor += vectorSize;
 3235:     }
18308: 
 3235:     if (ntrynotes != 0) {
32723:         script->trynotes()->length = ntrynotes;
32723:         script->trynotes()->vector = (JSTryNote *)cursor;
32723:         vectorSize = ntrynotes * sizeof(script->trynotes()->vector[0]);
 3235: #ifdef DEBUG
 3235:         memset(cursor, 0, vectorSize);
 3235: #endif
 3235:         cursor += vectorSize;
 3235:     }
 3235: 
52555:     if (nglobals != 0) {
52555:         script->globals()->length = nglobals;
52555:         script->globals()->vector = (GlobalSlotArray::Entry *)cursor;
52555:         vectorSize = nglobals * sizeof(script->globals()->vector[0]);
52555:         cursor += vectorSize;
52555:     }
52555: 
54840:     if (totalClosed != 0) {
57791:         script->nClosedArgs = nClosedArgs;
57791:         script->nClosedVars = nClosedVars;
54840:         script->closedSlots = (uint32 *)cursor;
54840:         cursor += totalClosed * sizeof(uint32);
54840:     }
54840: 
32689:     /*
32689:      * NB: We allocate the vector of uint32 upvar cookies after all vectors of
32689:      * pointers, to avoid misalignment on 64-bit platforms. See bug 514645.
32689:      */
32689:     if (nupvars != 0) {
32723:         script->upvars()->length = nupvars;
47573:         script->upvars()->vector = reinterpret_cast<UpvarCookie *>(cursor);
32723:         vectorSize = nupvars * sizeof(script->upvars()->vector[0]);
32689:         memset(cursor, 0, vectorSize);
32689:         cursor += vectorSize;
32689:     }
32689: 
48470:     /* Must go after other arrays; see constPadding definition. */
48470:     if (nconsts != 0) {
48470:         cursor += constPadding;
48470:         script->consts()->length = nconsts;
48470:         script->consts()->vector = (Value *)cursor;
48470:         JS_ASSERT((size_t)cursor % sizeof(double) == 0);
48470:         vectorSize = nconsts * sizeof(script->consts()->vector[0]);
48470:         memset(cursor, 0, vectorSize);
48470:         cursor += vectorSize;
48470:     }
48470: 
 3235:     script->code = script->main = (jsbytecode *)cursor;
 3235:     JS_ASSERT(cursor +
 3235:               length * sizeof(jsbytecode) +
 3235:               nsrcnotes * sizeof(jssrcnote) ==
 3235:               (uint8 *)script + size);
 3235: 
55633:     script->compartment = cx->compartment;
11377: #ifdef CHECK_SCRIPT_OWNER
69223:     script->owner = cx->thread();
11377: #endif
53391: 
53391:     JS_APPEND_LINK(&script->links, &cx->compartment->scripts);
74070: 
61450:     JS_ASSERT(script->getVersion() == version);
    1:     return script;
    1: }
    1: 
 8444: JSScript *
54840: JSScript::NewScriptFromCG(JSContext *cx, JSCodeGenerator *cg)
    1: {
16072:     uint32 mainLength, prologLength, nsrcnotes, nfixed;
    1:     JSScript *script;
    1:     const char *filename;
13702:     JSFunction *fun;
    1: 
 3235:     /* The counts of indexed things must be checked during code generation. */
72579:     JS_ASSERT(cg->atomIndices->count() <= INDEX_LIMIT);
 3235:     JS_ASSERT(cg->objectList.length <= INDEX_LIMIT);
 3235:     JS_ASSERT(cg->regexpList.length <= INDEX_LIMIT);
 3235: 
    1:     mainLength = CG_OFFSET(cg);
    1:     prologLength = CG_PROLOG_OFFSET(cg);
34290: 
    1:     CG_COUNT_FINAL_SRCNOTES(cg, nsrcnotes);
58683:     uint16 nClosedArgs = uint16(cg->closedArgs.length());
58683:     JS_ASSERT(nClosedArgs == cg->closedArgs.length());
58683:     uint16 nClosedVars = uint16(cg->closedVars.length());
58683:     JS_ASSERT(nClosedVars == cg->closedVars.length());
72579:     size_t upvarIndexCount = cg->upvarIndices.hasMap() ? cg->upvarIndices->count() : 0;
54840:     script = NewScript(cx, prologLength + mainLength, nsrcnotes,
72579:                        cg->atomIndices->count(), cg->objectList.length,
72579:                        upvarIndexCount, cg->regexpList.length,
52684:                        cg->ntrynotes, cg->constList.length(),
61450:                        cg->globalUses.length(), nClosedArgs, nClosedVars, cg->version());
    1:     if (!script)
    1:         return NULL;
    1: 
71359:     cg->bindings.makeImmutable();
71359:     AutoShapeRooter shapeRoot(cx, cg->bindings.lastShape());
71359: 
    1:     /* Now that we have script, error control flow must go to label bad. */
    1:     script->main += prologLength;
    1:     memcpy(script->code, CG_PROLOG_BASE(cg), prologLength * sizeof(jsbytecode));
    1:     memcpy(script->main, CG_BASE(cg), mainLength * sizeof(jsbytecode));
57829:     nfixed = cg->inFunction()
59968:              ? cg->bindings.countVars()
54477:              : cg->sharpSlots();
16072:     JS_ASSERT(nfixed < SLOTNO_LIMIT);
16072:     script->nfixed = (uint16) nfixed;
72579:     js_InitAtomMap(cx, &script->atomMap, cg->atomIndices.getMap());
    1: 
40860:     filename = cg->parser->tokenStream.getFilename();
    1:     if (filename) {
67927:         script->filename = SaveScriptFilename(cx, filename);
    1:         if (!script->filename)
    1:             goto bad;
    1:     }
    1:     script->lineno = cg->firstLine;
18308:     if (script->nfixed + cg->maxStackDepth >= JS_BIT(16)) {
40320:         ReportCompileErrorNumber(cx, CG_TS(cg), NULL, JSREPORT_ERROR, JSMSG_NEED_DIET, "script");
18308:         goto bad;
18308:     }
16072:     script->nslots = script->nfixed + cg->maxStackDepth;
39928:     script->staticLevel = uint16(cg->staticLevel);
40860:     script->principals = cg->parser->principals;
 6561:     if (script->principals)
    1:         JSPRINCIPALS_HOLD(cx, script->principals);
    1: 
74581:     script->sourceMap = (jschar *) cg->parser->tokenStream.releaseSourceMap();
74581: 
32723:     if (!js_FinishTakingSrcNotes(cx, cg, script->notes()))
    1:         goto bad;
 3235:     if (cg->ntrynotes != 0)
32723:         js_FinishTakingTryNotes(cg, script->trynotes());
 3235:     if (cg->objectList.length != 0)
32723:         cg->objectList.finish(script->objects());
 3235:     if (cg->regexpList.length != 0)
32723:         cg->regexpList.finish(script->regexps());
48470:     if (cg->constList.length() != 0)
48470:         cg->constList.finish(script->consts());
27012:     if (cg->flags & TCF_NO_SCRIPT_RVAL)
33750:         script->noScriptRval = true;
32729:     if (cg->hasSharps())
33750:         script->hasSharps = true;
35113:     if (cg->flags & TCF_STRICT_MODE_CODE)
35113:         script->strictModeCode = true;
52825:     if (cg->flags & TCF_COMPILE_N_GO)
52825:         script->compileAndGo = true;
54840:     if (cg->callsEval())
52878:         script->usesEval = true;
54840:     if (cg->flags & TCF_FUN_USES_ARGUMENTS)
54840:         script->usesArguments = true;
59962:     if (cg->flags & TCF_HAS_SINGLETONS)
59962:         script->hasSingletons = true;
    1: 
72579:     if (cg->hasUpvarIndices()) {
73887:         JS_ASSERT(cg->upvarIndices->count() <= cg->upvarMap.length());
73887:         memcpy(script->upvars()->vector, cg->upvarMap.begin(),
73887:                cg->upvarIndices->count() * sizeof(cg->upvarMap[0]));
72579:         cg->upvarIndices->clear();
73887:         cg->upvarMap.clear();
18308:     }
18308: 
52555:     if (cg->globalUses.length()) {
52555:         memcpy(script->globals()->vector, &cg->globalUses[0],
52555:                cg->globalUses.length() * sizeof(GlobalSlotArray::Entry));
52555:     }
52555: 
54840:     if (script->nClosedArgs)
54840:         memcpy(script->closedSlots, &cg->closedArgs[0], script->nClosedArgs * sizeof(uint32));
54840:     if (script->nClosedVars) {
54840:         memcpy(&script->closedSlots[script->nClosedArgs], &cg->closedVars[0],
54840:                script->nClosedVars * sizeof(uint32));
54840:     }
54840: 
59968:     script->bindings.transfer(cx, &cg->bindings);
59968: 
    1:     /*
    1:      * We initialize fun->u.script to be the script constructed above
    1:      * so that the debugger has a valid FUN_SCRIPT(fun).
    1:      */
13691:     fun = NULL;
57829:     if (cg->inFunction()) {
57829:         fun = cg->fun();
59968:         JS_ASSERT(fun->isInterpreted());
59968:         JS_ASSERT(!fun->script());
59968: #ifdef DEBUG
59221:         if (JSScript::isValidOffset(script->upvarsOffset))
59968:             JS_ASSERT(script->upvars()->length == script->bindings.countUpvars());
34290:         else
59968:             JS_ASSERT(script->bindings.countUpvars() == 0);
59968: #endif
    1:         fun->u.i.script = script;
74335:         script->setOwnerObject(fun);
11377: #ifdef CHECK_SCRIPT_OWNER
11377:         script->owner = NULL;
11377: #endif
27012:         if (cg->flags & TCF_FUN_HEAVYWEIGHT)
    1:             fun->flags |= JSFUN_HEAVYWEIGHT;
    1:     }
    1: 
    1:     /* Tell the debugger about this compiled script. */
    1:     js_CallNewScriptHook(cx, script, fun);
58980: 
    1:     return script;
    1: 
    1: bad:
74723:     js_DestroyScript(cx, script, 2);
    1:     return NULL;
    1: }
    1: 
72071: size_t
72071: JSScript::totalSize()
72071: {
72071:     return code +
72071:            length * sizeof(jsbytecode) +
72071:            numNotes() * sizeof(jssrcnote) -
72071:            (uint8 *) this;
72071: }
72071: 
74335: void
74335: JSScript::setOwnerObject(JSObject *owner)
74335: {
74335:     CheckScriptOwner(this, JS_NEW_SCRIPT);
74335:     ownerObject = owner;
74335: }
74335: 
72071: /*
72071:  * Nb: srcnotes are variable-length.  This function computes the number of
72071:  * srcnote *slots*, which may be greater than the number of srcnotes.
72071:  */
72071: uint32
72071: JSScript::numNotes()
72071: {
72071:     jssrcnote *sn;
72071:     jssrcnote *notes_ = notes();
72071:     for (sn = notes_; !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn))
72071:         continue;
72071:     return sn - notes_ + 1;    /* +1 for the terminator */
72071: }
72071: 
    1: JS_FRIEND_API(void)
    1: js_CallNewScriptHook(JSContext *cx, JSScript *script, JSFunction *fun)
    1: {
    1:     JSNewScriptHook hook;
    1: 
 2433:     hook = cx->debugHooks->newScriptHook;
    1:     if (hook) {
40840:         AutoKeepAtoms keep(cx->runtime);
    1:         hook(cx, script->filename, script->lineno, script, fun,
 2433:              cx->debugHooks->newScriptHookData);
    1:     }
    1: }
    1: 
62571: void
    1: js_CallDestroyScriptHook(JSContext *cx, JSScript *script)
    1: {
    1:     JSDestroyScriptHook hook;
    1: 
 2433:     hook = cx->debugHooks->destroyScriptHook;
    1:     if (hook)
 2433:         hook(cx, script, cx->debugHooks->destroyScriptHookData);
62571:     JS_ClearScriptTraps(cx, script);
    1: }
    1: 
74070: namespace js {
74070: 
74070: void
74070: CheckCompartmentScripts(JSCompartment *comp)
74070: {
74070:     JSScript *prev = NULL;
74070:     for (JSScript *script = (JSScript *)comp->scripts.next;
74070:          &script->links != &comp->scripts;
74070:          prev = script, script = (JSScript *)script->links.next)
74070:     {
74070:         CheckScript(script, prev);
74070:     }
74070: }
74070: 
74070: } /* namespace js */
74070: 
74070: static void
74723: DestroyScript(JSContext *cx, JSScript *script, JSObject *owner, uint32 caller)
    1: {
74070:     CheckScript(script, NULL);
74335:     CheckScriptOwner(script, owner);
74070: 
    1:     if (script->principals)
    1:         JSPRINCIPALS_DROP(cx, script->principals);
11377: 
67915:     GSNCache *gsnCache = GetGSNCache(cx);
67915:     if (gsnCache->code == script->code)
67915:         gsnCache->purge();
11377: 
11377:     /*
30714:      * Worry about purging the property cache and any compiled traces related
30714:      * to its bytecode if this script is being destroyed from JS_DestroyScript
30714:      * or equivalent according to a mandatory "New/Destroy" protocol.
30714:      *
30733:      * The GC purges all property caches when regenerating shapes upon shape
30733:      * generator overflow, so no need in that event to purge just the entries
30733:      * for this script.
30733:      *
30733:      * The GC purges trace-JITted code on every GC activation, not just when
30733:      * regenerating shapes, so we don't have to purge fragments if the GC is
30733:      * currently running.
30733:      *
40362:      * JS_THREADSAFE note: The code below purges only the current thread's
40362:      * property cache, so a script not owned by a function or object, which
40362:      * hands off lifetime management for that script to the GC, must be used by
40362:      * only one thread over its lifetime.
11377:      *
11377:      * This should be an API-compatible change, since a script is never safe
11377:      * against premature GC if shared among threads without a rooted object
11377:      * wrapping it to protect the script's mapped atoms against GC. We use
11377:      * script->owner to enforce this requirement via assertions.
11377:      */
11377: #ifdef CHECK_SCRIPT_OWNER
11377:     JS_ASSERT_IF(cx->runtime->gcRunning, !script->owner);
11377: #endif
11377: 
30735:     /* FIXME: bug 506341; would like to do this only if regenerating shapes. */
30735:     if (!cx->runtime->gcRunning) {
63087:         JS_PROPERTY_CACHE(cx).purgeForScript(cx, script);
30734: 
11377: #ifdef CHECK_SCRIPT_OWNER
69223:         JS_ASSERT(script->owner == cx->thread());
11377: #endif
31843:     }
31843: 
24879: #ifdef JS_TRACER
72548:     if (script->compartment->hasTraceMonitor())
72548:         PurgeScriptFragments(script->compartment->traceMonitor(), script);
24879: #endif
11377: 
71699: #ifdef JS_METHODJIT
52559:     mjit::ReleaseScriptCode(cx, script);
52559: #endif
53391:     JS_REMOVE_LINK(&script->links);
52559: 
71702:     script->pcCounters.destroy(cx);
71702: 
74581:     if (script->sourceMap)
74581:         cx->free_(script->sourceMap);
74581: 
74723:     memset(script, 0xdb, script->totalSize());
74723:     *(uint32 *)script = caller;
64560:     cx->free_(script);
    1: }
    1: 
    1: void
74723: js_DestroyScript(JSContext *cx, JSScript *script, uint32 caller)
58041: {
58041:     JS_ASSERT(!cx->runtime->gcRunning);
62571:     js_CallDestroyScriptHook(cx, script);
74723:     DestroyScript(cx, script, JS_NEW_SCRIPT, caller);
58041: }
58041: 
58041: void
74335: js_DestroyScriptFromGC(JSContext *cx, JSScript *script, JSObject *owner)
58041: {
58041:     JS_ASSERT(cx->runtime->gcRunning);
62571:     js_CallDestroyScriptHook(cx, script);
74723:     DestroyScript(cx, script, owner, 100);
62571: }
62571: 
62571: void
62571: js_DestroyCachedScript(JSContext *cx, JSScript *script)
62571: {
62571:     JS_ASSERT(cx->runtime->gcRunning);
74723:     DestroyScript(cx, script, JS_CACHED_SCRIPT, 101);
58041: }
58041: 
58041: void
74335: js_TraceScript(JSTracer *trc, JSScript *script, JSObject *owner)
    1: {
74070:     CheckScript(script, NULL);
74335:     if (owner)
74335:         CheckScriptOwner(script, owner);
74070: 
74070:     JSRuntime *rt = trc->context->runtime;
74070:     if (rt->gcCheckCompartment && script->compartment != rt->gcCheckCompartment)
74070:         JS_Assert("compartment mismatch in GC", __FILE__, __LINE__);
74070: 
48470:     JSAtomMap *map = &script->atomMap;
48470:     MarkAtomRange(trc, map->length, map->vector, "atomMap");
 3235: 
59221:     if (JSScript::isValidOffset(script->objectsOffset)) {
48470:         JSObjectArray *objarray = script->objects();
68933:         MarkObjectRange(trc, objarray->length, objarray->vector, "objects");
 3235:     }
 3235: 
59221:     if (JSScript::isValidOffset(script->regexpsOffset)) {
48470:         JSObjectArray *objarray = script->regexps();
68933:         MarkObjectRange(trc, objarray->length, objarray->vector, "objects");
 3235:     }
    1: 
59221:     if (JSScript::isValidOffset(script->constOffset)) {
48470:         JSConstArray *constarray = script->consts();
48470:         MarkValueRange(trc, constarray->length, constarray->vector, "consts");
48470:     }
48470: 
68933:     if (script->u.object)
68933:         MarkObject(trc, *script->u.object, "object");
15336: 
  583:     if (IS_GC_MARKING_TRACER(trc) && script->filename)
    1:         js_MarkScriptFilename(script->filename);
59968: 
59968:     script->bindings.trace(trc);
74731: 
74731: #ifdef JS_METHODJIT
74731:     mjit::TraceScript(trc, script);
74731: #endif
    1: }
    1: 
64190: JSObject *
51440: js_NewScriptObject(JSContext *cx, JSScript *script)
51440: {
51440:     AutoScriptRooter root(cx, script);
51440: 
51440:     JS_ASSERT(!script->u.object);
51440: 
51440:     JSObject *obj = NewNonFunction<WithProto::Class>(cx, &js_ScriptClass, NULL, NULL);
51440:     if (!obj)
64190:         return NULL;
51440:     obj->setPrivate(script);
51440:     script->u.object = obj;
74335:     script->setOwnerObject(obj);
51440: 
51440:     /*
51440:      * Clear the object's proto, to avoid entraining stuff. Once we no longer use the parent
51440:      * for security checks, then we can clear the parent, too.
51440:      */
51440:     obj->clearProto();
51440: 
51440: #ifdef CHECK_SCRIPT_OWNER
51440:     script->owner = NULL;
51440: #endif
51440: 
64190:     return obj;
51440: }
51440: 
67915: namespace js {
    1: 
67915: static const uint32 GSN_CACHE_THRESHOLD = 100;
67915: static const uint32 GSN_CACHE_MAP_INIT_SIZE = 20;
67915: 
26569: void
67915: GSNCache::purge()
26569: {
67915:     code = NULL;
67915:     if (map.initialized())
67915:         map.finish();
26569: }
67915: 
67915: } /* namespace js */
26569: 
    1: jssrcnote *
    1: js_GetSrcNoteCached(JSContext *cx, JSScript *script, jsbytecode *pc)
    1: {
67915:     size_t target = pc - script->code;
67915:     if (target >= size_t(script->length))
    1:         return NULL;
    1: 
67915:     GSNCache *cache = GetGSNCache(cx);
67915:     if (cache->code == script->code) {
67915:         JS_ASSERT(cache->map.initialized());
67915:         GSNCache::Map::Ptr p = cache->map.lookup(pc);
67915:         return p ? p->value : NULL;
    1:     }
    1: 
67915:     size_t offset = 0;
67915:     jssrcnote *result;
67915:     for (jssrcnote *sn = script->notes(); ; sn = SN_NEXT(sn)) {
    1:         if (SN_IS_TERMINATOR(sn)) {
    1:             result = NULL;
    1:             break;
    1:         }
    1:         offset += SN_DELTA(sn);
    1:         if (offset == target && SN_IS_GETTABLE(sn)) {
    1:             result = sn;
    1:             break;
    1:         }
    1:     }
    1: 
67915:     if (cache->code != script->code && script->length >= GSN_CACHE_THRESHOLD) {
67915:         uintN nsrcnotes = 0;
67915:         for (jssrcnote *sn = script->notes(); !SN_IS_TERMINATOR(sn);
    1:              sn = SN_NEXT(sn)) {
    1:             if (SN_IS_GETTABLE(sn))
    1:                 ++nsrcnotes;
    1:         }
67915:         if (cache->code) {
67915:             JS_ASSERT(cache->map.initialized());
67915:             cache->map.finish();
67915:             cache->code = NULL;
67915:         }
67915:         if (cache->map.init(nsrcnotes)) {
    1:             pc = script->code;
67915:             for (jssrcnote *sn = script->notes(); !SN_IS_TERMINATOR(sn);
    1:                  sn = SN_NEXT(sn)) {
    1:                 pc += SN_DELTA(sn);
67915:                 if (SN_IS_GETTABLE(sn))
67915:                     JS_ALWAYS_TRUE(cache->map.put(pc, sn));
    1:             }
67915:             cache->code = script->code;
    1:         }
    1:     }
    1: 
    1:     return result;
    1: }
    1: 
    1: uintN
71363: js_FramePCToLineNumber(JSContext *cx, StackFrame *fp, jsbytecode *pc)
21685: {
71363:     return js_PCToLineNumber(cx, fp->script(), fp->hasImacropc() ? fp->imacropc() : pc);
21685: }
21685: 
21685: uintN
    1: js_PCToLineNumber(JSContext *cx, JSScript *script, jsbytecode *pc)
    1: {
25215:     JSOp op;
    1:     JSFunction *fun;
    1:     uintN lineno;
    1:     ptrdiff_t offset, target;
    1:     jssrcnote *sn;
    1:     JSSrcNoteType type;
    1: 
69223:     /* Cope with StackFrame.pc value prior to entering js_Interpret. */
    1:     if (!pc)
    1:         return 0;
    1: 
    1:     /*
    1:      * Special case: function definition needs no line number note because
    1:      * the function's script contains its starting line number.
    1:      */
25215:     op = js_GetOpcode(cx, script, pc);
25215:     if (js_CodeSpec[op].format & JOF_INDEXBASE)
25215:         pc += js_CodeSpec[op].length;
    1:     if (*pc == JSOP_DEFFUN) {
13824:         GET_FUNCTION_FROM_BYTECODE(script, pc, 0, fun);
70311:         return fun->script()->lineno;
    1:     }
    1: 
    1:     /*
    1:      * General case: walk through source notes accumulating their deltas,
    1:      * keeping track of line-number notes, until we pass the note for pc's
    1:      * offset within script->code.
    1:      */
    1:     lineno = script->lineno;
    1:     offset = 0;
25144:     target = pc - script->code;
32723:     for (sn = script->notes(); !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn)) {
    1:         offset += SN_DELTA(sn);
    1:         type = (JSSrcNoteType) SN_TYPE(sn);
    1:         if (type == SRC_SETLINE) {
    1:             if (offset <= target)
    1:                 lineno = (uintN) js_GetSrcNoteOffset(sn, 0);
    1:         } else if (type == SRC_NEWLINE) {
    1:             if (offset <= target)
    1:                 lineno++;
    1:         }
    1:         if (offset > target)
    1:             break;
    1:     }
    1:     return lineno;
    1: }
    1: 
    1: /* The line number limit is the same as the jssrcnote offset limit. */
    1: #define SN_LINE_LIMIT   (SN_3BYTE_OFFSET_FLAG << 16)
    1: 
    1: jsbytecode *
    1: js_LineNumberToPC(JSScript *script, uintN target)
    1: {
    1:     ptrdiff_t offset, best;
    1:     uintN lineno, bestdiff, diff;
    1:     jssrcnote *sn;
    1:     JSSrcNoteType type;
    1: 
    1:     offset = 0;
    1:     best = -1;
    1:     lineno = script->lineno;
    1:     bestdiff = SN_LINE_LIMIT;
32723:     for (sn = script->notes(); !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn)) {
  267:         /*
  267:          * Exact-match only if offset is not in the prolog; otherwise use
  267:          * nearest greater-or-equal line number match.
  267:          */
  267:         if (lineno == target && script->code + offset >= script->main)
    1:             goto out;
  267:         if (lineno >= target) {
    1:             diff = lineno - target;
    1:             if (diff < bestdiff) {
    1:                 bestdiff = diff;
    1:                 best = offset;
    1:             }
    1:         }
    1:         offset += SN_DELTA(sn);
    1:         type = (JSSrcNoteType) SN_TYPE(sn);
    1:         if (type == SRC_SETLINE) {
    1:             lineno = (uintN) js_GetSrcNoteOffset(sn, 0);
    1:         } else if (type == SRC_NEWLINE) {
    1:             lineno++;
    1:         }
    1:     }
    1:     if (best >= 0)
    1:         offset = best;
    1: out:
    1:     return script->code + offset;
    1: }
    1: 
    1: JS_FRIEND_API(uintN)
    1: js_GetScriptLineExtent(JSScript *script)
    1: {
73768: 
73768:     bool counting;
    1:     uintN lineno;
73768:     uintN maxLineNo;
    1:     jssrcnote *sn;
    1:     JSSrcNoteType type;
    1: 
    1:     lineno = script->lineno;
73768:     maxLineNo = 0;
73768:     counting = true;
32723:     for (sn = script->notes(); !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn)) {
    1:         type = (JSSrcNoteType) SN_TYPE(sn);
    1:         if (type == SRC_SETLINE) {
73768:             if (maxLineNo < lineno)
73768:                 maxLineNo = lineno;
    1:             lineno = (uintN) js_GetSrcNoteOffset(sn, 0);
73768:             counting = true;
73768:             if (maxLineNo < lineno)
73768:                 maxLineNo = lineno;
73768:             else
73768:                 counting = false;
    1:         } else if (type == SRC_NEWLINE) {
73768:             if (counting)
    1:                 lineno++;
    1:         }
    1:     }
73768: 
73768:     if (maxLineNo > lineno)
73768:         lineno = maxLineNo;
73768: 
    1:     return 1 + lineno - script->lineno;
    1: }
53498: 
71363: namespace js {
71363: 
71363: uintN
71363: CurrentLine(JSContext *cx)
71363: {
71363:     return js_FramePCToLineNumber(cx, cx->fp(), cx->regs().pc);
71363: }
71363: 
68894: const char *
71363: CurrentScriptFileAndLineSlow(JSContext *cx, uintN *linenop)
68894: {
71363:     FrameRegsIter iter(cx);
71363:     while (!iter.done() && !iter.fp()->isScriptFrame())
71363:         ++iter;
71363: 
71363:     if (iter.done()) {
68894:         *linenop = 0;
68894:         return NULL;
68894:     }
68894: 
71363:     *linenop = js_FramePCToLineNumber(cx, iter.fp(), iter.pc());
71363:     return iter.fp()->script()->filename;
68894: }
68894: 
71363: }  /* namespace js */
71363: 
55633: class DisablePrincipalsTranscoding {
55633:     JSSecurityCallbacks *callbacks;
55633:     JSPrincipalsTranscoder temp;
55633: 
55633:   public:
55708:     DisablePrincipalsTranscoding(JSContext *cx)
55708:       : callbacks(JS_GetRuntimeSecurityCallbacks(cx->runtime)),
55708:         temp(NULL)
55708:     {
55633:         if (callbacks) {
55633:             temp = callbacks->principalsTranscoder;
55633:             callbacks->principalsTranscoder = NULL;
55633:         }
55633:     }
55633: 
55633:     ~DisablePrincipalsTranscoding() {
55633:         if (callbacks)
55633:             callbacks->principalsTranscoder = temp;
55633:     }
55633: };
55633: 
64372: class AutoJSXDRState {
64372: public:
64378:     AutoJSXDRState(JSXDRState *x
64378:                    JS_GUARD_OBJECT_NOTIFIER_PARAM)
64378:         : xdr(x)
64378:     {
64378:         JS_GUARD_OBJECT_NOTIFIER_INIT;
64378:     }
64378:     ~AutoJSXDRState()
64378:     {
64372:         JS_XDRDestroy(xdr);
64372:     }
64372: 
64378:     operator JSXDRState*() const
64378:     {
64372:         return xdr;
64372:     }
64372: 
64372: private:
64372:     JSXDRState *const xdr;
64378:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
64372: };
64372: 
55633: JSScript *
55633: js_CloneScript(JSContext *cx, JSScript *script)
55633: {
55633:     JS_ASSERT(cx->compartment != script->compartment);
55633:     JS_ASSERT(script->compartment);
55633: 
55633:     // serialize script
64372:     AutoJSXDRState w(JS_XDRNewMem(cx, JSXDR_ENCODE));
55633:     if (!w)
55633:         return NULL;
55633: 
55633:     // we don't want gecko to transcribe our principals for us
55633:     DisablePrincipalsTranscoding disable(cx);
55633: 
64372:     XDRScriptState wstate(w);
64301: #ifdef DEBUG
64372:     wstate.filename = script->filename;
64301: #endif
64372:     if (!js_XDRScript(w, &script))
55633:         return NULL;
55633: 
55633:     uint32 nbytes;
55633:     void *p = JS_XDRMemGetData(w, &nbytes);
64372:     if (!p)
55633:         return NULL;
55633: 
55633:     // de-serialize script
64372:     AutoJSXDRState r(JS_XDRNewMem(cx, JSXDR_DECODE));
64372:     if (!r)
55633:         return NULL;
55633: 
55633:     // Hand p off from w to r.  Don't want them to share the data
55633:     // mem, lest they both try to free it in JS_XDRDestroy
55633:     JS_XDRMemSetData(r, p, nbytes);
55633:     JS_XDRMemSetData(w, NULL, 0);
55633: 
64372:     XDRScriptState rstate(r);
64372:     rstate.filename = script->filename;
64372:     rstate.filenameSaved = true;
64301: 
64300:     if (!js_XDRScript(r, &script))
55633:         return NULL;
55633: 
55633:     // set the proper principals for the script
55633:     script->principals = script->compartment->principals;
55633:     if (script->principals)
55633:         JSPRINCIPALS_HOLD(cx, script->principals);
55633: 
55633:     return script;
55633: }
55633: 
54840: void
54840: JSScript::copyClosedSlotsTo(JSScript *other)
54840: {
54840:     memcpy(other->closedSlots, closedSlots, nClosedArgs + nClosedVars);
54840: }
