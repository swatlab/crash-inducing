     1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 75138: #include "nsTextBoxFrame.h"
     1: 
     1: #include "nsReadableUtils.h"
     1: #include "nsCOMPtr.h"
     1: #include "nsGkAtoms.h"
     1: #include "nsPresContext.h"
 68481: #include "nsRenderingContext.h"
     1: #include "nsStyleContext.h"
     1: #include "nsIContent.h"
     1: #include "nsINameSpaceManager.h"
     1: #include "nsBoxLayoutState.h"
     1: #include "nsMenuBarListener.h"
     1: #include "nsXPIDLString.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsIDocument.h"
     1: #include "nsIDOMDocument.h"
     1: #include "nsIDOMElement.h"
     1: #include "nsIDOMXULLabelElement.h"
 68780: #include "nsEventStateManager.h"
     1: #include "nsITheme.h"
     1: #include "nsUnicharUtils.h"
     1: #include "nsContentUtils.h"
     1: #include "nsDisplayList.h"
  4302: #include "nsCSSRendering.h"
  4445: #include "nsIReflowCallback.h"
 43377: #include "nsBoxFrame.h"
 70976: #include "mozilla/Preferences.h"
 75138: #include "nsLayoutUtils.h"
     1: 
     1: #ifdef IBMBIDI
     1: #include "nsBidiUtils.h"
     1: #include "nsBidiPresUtils.h"
     1: #endif // IBMBIDI
     1: 
 70976: using namespace mozilla;
 70976: 
     1: class nsAccessKeyInfo
     1: {
     1: public:
     1:     PRInt32 mAccesskeyIndex;
     1:     nscoord mBeforeWidth, mAccessWidth, mAccessUnderlineSize, mAccessOffset;
     1: };
     1: 
     1: 
 79445: bool nsTextBoxFrame::gAlwaysAppendAccessKey          = false;
 79445: bool nsTextBoxFrame::gAccessKeyPrefInitialized       = false;
 79445: bool nsTextBoxFrame::gInsertSeparatorBeforeAccessKey = false;
 79445: bool nsTextBoxFrame::gInsertSeparatorPrefInitialized = false;
     1: 
     1: nsIFrame*
     1: NS_NewTextBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext)
     1: {
     1:     return new (aPresShell) nsTextBoxFrame (aPresShell, aContext);
 32423: }
 32423: 
 32423: NS_IMPL_FRAMEARENA_HELPERS(nsTextBoxFrame)
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsTextBoxFrame::AttributeChanged(PRInt32         aNameSpaceID,
     1:                                  nsIAtom*        aAttribute,
     1:                                  PRInt32         aModType)
     1: {
 79445:     bool aResize;
 79445:     bool aRedraw;
     1: 
     1:     UpdateAttributes(aAttribute, aResize, aRedraw);
     1: 
     1:     if (aResize) {
   238:         PresContext()->PresShell()->
  1158:             FrameNeedsReflow(this, nsIPresShell::eStyleChange,
  1158:                              NS_FRAME_IS_DIRTY);
     1:     } else if (aRedraw) {
   238:         nsBoxLayoutState state(PresContext());
     1:         Redraw(state);
     1:     }
     1: 
     1:     // If the accesskey changed, register for the new value
     1:     // The old value has been unregistered in nsXULElement::SetAttr
     1:     if (aAttribute == nsGkAtoms::accesskey || aAttribute == nsGkAtoms::control)
 80486:         RegUnregAccessKey(true);
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: nsTextBoxFrame::nsTextBoxFrame(nsIPresShell* aShell, nsStyleContext* aContext):
 28285:   nsLeafBoxFrame(aShell, aContext), mAccessKeyInfo(nsnull), mCropType(CropRight),
 80486:   mNeedsReflowCallback(false)
     1: {
     1:     MarkIntrinsicWidthsDirty();
     1: }
     1: 
     1: nsTextBoxFrame::~nsTextBoxFrame()
     1: {
     1:     delete mAccessKeyInfo;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsTextBoxFrame::Init(nsIContent*      aContent,
     1:                      nsIFrame*        aParent,
     1:                      nsIFrame*        aPrevInFlow)
     1: {
     1:     nsTextBoxFrameSuper::Init(aContent, aParent, aPrevInFlow);
     1: 
 79445:     bool aResize;
 79445:     bool aRedraw;
     1:     UpdateAttributes(nsnull, aResize, aRedraw); /* update all */
     1: 
     1:     // register access key
 80486:     RegUnregAccessKey(true);
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: void
 36647: nsTextBoxFrame::DestroyFrom(nsIFrame* aDestructRoot)
     1: {
     1:     // unregister access key
 80486:     RegUnregAccessKey(false);
 36647:     nsTextBoxFrameSuper::DestroyFrom(aDestructRoot);
     1: }
     1: 
 79445: bool
     1: nsTextBoxFrame::AlwaysAppendAccessKey()
     1: {
     1:   if (!gAccessKeyPrefInitialized) 
     1:   {
 80486:     gAccessKeyPrefInitialized = true;
     1: 
     1:     const char* prefName = "intl.menuitems.alwaysappendaccesskeys";
 70976:     nsAdoptingString val = Preferences::GetLocalizedString(prefName);
     1:     gAlwaysAppendAccessKey = val.Equals(NS_LITERAL_STRING("true"));
     1:   }
     1:   return gAlwaysAppendAccessKey;
     1: }
     1: 
 79445: bool
     1: nsTextBoxFrame::InsertSeparatorBeforeAccessKey()
     1: {
     1:   if (!gInsertSeparatorPrefInitialized)
     1:   {
 80486:     gInsertSeparatorPrefInitialized = true;
     1: 
     1:     const char* prefName = "intl.menuitems.insertseparatorbeforeaccesskeys";
 70976:     nsAdoptingString val = Preferences::GetLocalizedString(prefName);
     1:     gInsertSeparatorBeforeAccessKey = val.EqualsLiteral("true");
     1:   }
     1:   return gInsertSeparatorBeforeAccessKey;
     1: }
     1: 
  4445: class nsAsyncAccesskeyUpdate : public nsIReflowCallback
  4445: {
  4445: public:
  4445:     nsAsyncAccesskeyUpdate(nsIFrame* aFrame) : mWeakFrame(aFrame)
  4445:     {
  4445:     }
  4445: 
 79445:     virtual bool ReflowFinished()
  4445:     {
 79445:         bool shouldFlush = false;
  4445:         nsTextBoxFrame* frame =
  4445:             static_cast<nsTextBoxFrame*>(mWeakFrame.GetFrame());
  4445:         if (frame) {
  4445:             shouldFlush = frame->UpdateAccesskey(mWeakFrame);
  4445:         }
  4445:         delete this;
  4445:         return shouldFlush;
  4445:     }
  4445: 
  8509:     virtual void ReflowCallbackCanceled()
  8509:     {
  8509:         delete this;
  8509:     }
  8509: 
  4445:     nsWeakFrame mWeakFrame;
  4445: };
  4445: 
 79445: bool
  4445: nsTextBoxFrame::UpdateAccesskey(nsWeakFrame& aWeakThis)
  4445: {
  4445:     nsAutoString accesskey;
  4445:     nsCOMPtr<nsIDOMXULLabelElement> labelElement = do_QueryInterface(mContent);
 80486:     NS_ENSURE_TRUE(aWeakThis.IsAlive(), false);
  4445:     if (labelElement) {
  4445:         // Accesskey may be stored on control.
  4773:         // Because this method is called by the reflow callback, current context
  4773:         // may not be the right one. Pushing the context of mContent so that
  4773:         // if nsIDOMXULLabelElement is implemented in XBL, we don't get a
  4773:         // security exception.
  6475:         nsCxPusher cx;
  6475:         if (cx.Push(mContent)) {
  4445:           labelElement->GetAccessKey(accesskey);
 80486:           NS_ENSURE_TRUE(aWeakThis.IsAlive(), false);
  4445:         }
  6475:     }
  4445:     else {
  4445:         mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, accesskey);
  4445:     }
  4445: 
  4445:     if (!accesskey.Equals(mAccessKey)) {
  4445:         // Need to get clean mTitle.
  4445:         mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::value, mTitle);
  4445:         mAccessKey = accesskey;
  4445:         UpdateAccessTitle();
  4445:         PresContext()->PresShell()->
  4445:             FrameNeedsReflow(this, nsIPresShell::eStyleChange,
  4445:                              NS_FRAME_IS_DIRTY);
 80486:         return true;
  4445:     }
 80486:     return false;
  4445: }
  4445: 
     1: void
     1: nsTextBoxFrame::UpdateAttributes(nsIAtom*         aAttribute,
 79445:                                  bool&          aResize,
 79445:                                  bool&          aRedraw)
     1: {
 79445:     bool doUpdateTitle = false;
 80486:     aResize = false;
 80486:     aRedraw = false;
     1: 
     1:     if (aAttribute == nsnull || aAttribute == nsGkAtoms::crop) {
     1:         static nsIContent::AttrValuesArray strings[] =
     1:           {&nsGkAtoms::left, &nsGkAtoms::start, &nsGkAtoms::center,
     1:            &nsGkAtoms::right, &nsGkAtoms::end, nsnull};
     1:         CroppingStyle cropType;
     1:         switch (mContent->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::crop,
     1:                                           strings, eCaseMatters)) {
     1:           case 0:
     1:           case 1:
     1:             cropType = CropLeft;
     1:             break;
     1:           case 2:
     1:             cropType = CropCenter;
     1:             break;
     1:           case 3:
     1:           case 4:
     1:             cropType = CropRight;
     1:             break;
     1:           default:
     1:             cropType = CropNone;
     1:             break;
     1:         }
     1: 
     1:         if (cropType != mCropType) {
 80486:             aResize = true;
     1:             mCropType = cropType;
     1:         }
     1:     }
     1: 
     1:     if (aAttribute == nsnull || aAttribute == nsGkAtoms::value) {
     1:         mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::value, mTitle);
 80486:         doUpdateTitle = true;
     1:     }
     1: 
  5624:     if (aAttribute == nsnull || aAttribute == nsGkAtoms::accesskey) {
 80486:         mNeedsReflowCallback = true;
  4445:         // Ensure that layout is refreshed and reflow callback called.
 80486:         aResize = true;
     1:     }
     1: 
     1:     if (doUpdateTitle) {
     1:         UpdateAccessTitle();
 80486:         aResize = true;
     1:     }
     1: 
     1: }
     1: 
     1: class nsDisplayXULTextBox : public nsDisplayItem {
     1: public:
 51260:   nsDisplayXULTextBox(nsDisplayListBuilder* aBuilder,
 51260:                       nsTextBoxFrame* aFrame) :
 59778:     nsDisplayItem(aBuilder, aFrame),
 80486:     mDisableSubpixelAA(false)
 59778:   {
     1:     MOZ_COUNT_CTOR(nsDisplayXULTextBox);
     1:   }
     1: #ifdef NS_BUILD_REFCNT_LOGGING
     1:   virtual ~nsDisplayXULTextBox() {
     1:     MOZ_COUNT_DTOR(nsDisplayXULTextBox);
     1:   }
     1: #endif
     1: 
 33368:   virtual void Paint(nsDisplayListBuilder* aBuilder,
 68481:                      nsRenderingContext* aCtx);
 95051:   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap);
 47732:   NS_DISPLAY_DECL_NAME("XULTextBox", TYPE_XUL_TEXT_BOX)
 55291: 
 59781:   virtual nsRect GetComponentAlphaBounds(nsDisplayListBuilder* aBuilder);
 59778: 
 80486:   virtual void DisableComponentAlpha() { mDisableSubpixelAA = true; }
 59778: 
 72975:   void PaintTextToContext(nsRenderingContext* aCtx,
 72829:                           nsPoint aOffset,
 72829:                           const nscolor* aColor);
 72827: 
 79445:   bool mDisableSubpixelAA;
     1: };
     1: 
 72827: static void
 72827: PaintTextShadowCallback(nsRenderingContext* aCtx,
 72827:                         nsPoint aShadowOffset,
 72827:                         const nscolor& aShadowColor,
 72827:                         void* aData)
 72827: {
 72827:   reinterpret_cast<nsDisplayXULTextBox*>(aData)->
 72975:            PaintTextToContext(aCtx, aShadowOffset, &aShadowColor);
 72827: }
 72827: 
 21991: void
 21991: nsDisplayXULTextBox::Paint(nsDisplayListBuilder* aBuilder,
 68481:                            nsRenderingContext* aCtx)
     1: {
 59778:   gfxContextAutoDisableSubpixelAntialiasing disable(aCtx->ThebesContext(),
 59778:                                                     mDisableSubpixelAA);
 72827: 
 72827:   // Paint the text shadow before doing any foreground stuff
 72975:   nsRect drawRect = static_cast<nsTextBoxFrame*>(mFrame)->mTextDrawRect +
 72975:                     ToReferenceFrame();
 72827:   nsLayoutUtils::PaintTextShadow(mFrame, aCtx,
 72827:                                  drawRect, mVisibleRect,
 72827:                                  mFrame->GetStyleColor()->mColor,
 72827:                                  PaintTextShadowCallback,
 72827:                                  (void*)this);
 72827: 
 72975:   PaintTextToContext(aCtx, nsPoint(0, 0), nsnull);
 72827: }
 72827: 
 72827: void
 72975: nsDisplayXULTextBox::PaintTextToContext(nsRenderingContext* aCtx,
 72829:                                         nsPoint aOffset,
 72829:                                         const nscolor* aColor)
 72827: {
  3233:   static_cast<nsTextBoxFrame*>(mFrame)->
 72829:     PaintTitle(*aCtx, mVisibleRect, ToReferenceFrame() + aOffset, aColor);
     1: }
     1: 
 21991: nsRect
 95051: nsDisplayXULTextBox::GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap) {
 95051:   *aSnap = false;
 80733:   return mFrame->GetVisualOverflowRectRelativeToSelf() + ToReferenceFrame();
 21991: }
 21991: 
 59781: nsRect
 59781: nsDisplayXULTextBox::GetComponentAlphaBounds(nsDisplayListBuilder* aBuilder)
 59781: {
 59781:   return static_cast<nsTextBoxFrame*>(mFrame)->GetComponentAlphaBounds() +
 59781:       ToReferenceFrame();
 59781: }
 59781: 
     1: NS_IMETHODIMP
     1: nsTextBoxFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
     1:                                  const nsRect&           aDirtyRect,
     1:                                  const nsDisplayListSet& aLists)
     1: {
     1:     if (!IsVisibleForPainting(aBuilder))
     1:       return NS_OK;
     1: 
     1:     nsresult rv = nsLeafBoxFrame::BuildDisplayList(aBuilder, aDirtyRect, aLists);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:     
     1:     return aLists.Content()->AppendNewToTop(new (aBuilder)
 51260:         nsDisplayXULTextBox(aBuilder, this));
     1: }
     1: 
     1: void
 68481: nsTextBoxFrame::PaintTitle(nsRenderingContext& aRenderingContext,
     1:                            const nsRect&        aDirtyRect,
 72829:                            nsPoint              aPt,
 72829:                            const nscolor*       aOverrideColor)
     1: {
     1:     if (mTitle.IsEmpty())
     1:         return;
     1: 
 78406:     DrawText(aRenderingContext, aDirtyRect, mTextDrawRect + aPt, aOverrideColor);
 19949: }
 19949: 
 19949: void
 68481: nsTextBoxFrame::DrawText(nsRenderingContext& aRenderingContext,
 78406:                          const nsRect&       aDirtyRect,
 19949:                          const nsRect&       aTextRect,
 19961:                          const nscolor*      aOverrideColor)
 19949: {
 19949:     nsPresContext* presContext = PresContext();
     1: 
     1:     // paint the title
     1:     nscolor overColor;
     1:     nscolor underColor;
     1:     nscolor strikeColor;
 64458:     PRUint8 overStyle;
 64458:     PRUint8 underStyle;
 64458:     PRUint8 strikeStyle;
     1: 
 68819:     // Begin with no decorations
 68819:     PRUint8 decorations = NS_STYLE_TEXT_DECORATION_LINE_NONE;
 68819:     // A mask of all possible decorations.
 68819:     PRUint8 decorMask = NS_STYLE_TEXT_DECORATION_LINE_LINES_MASK;
     1: 
 75138:     nsIFrame* f = this;
     1:     do {  // find decoration colors
 75138:       nsStyleContext* context = f->GetStyleContext();
 75138:       if (!context->HasTextDecorationLines()) {
 75138:         break;
 75138:       }
     1:       const nsStyleTextReset* styleText = context->GetStyleTextReset();
     1:       
 68819:       if (decorMask & styleText->mTextDecorationLine) {  // a decoration defined here
 64458:         nscolor color;
 64458:         if (aOverrideColor) {
 64458:           color = *aOverrideColor;
 64458:         } else {
 79445:           bool isForeground;
 64458:           styleText->GetDecorationColor(color, isForeground);
 64458:           if (isForeground) {
 75138:             color = nsLayoutUtils::GetColor(f, eCSSProperty_color);
 64458:           }
 64458:         }
 64458:         PRUint8 style = styleText->GetDecorationStyle();
     1: 
 68819:         if (NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE & decorMask &
 68819:               styleText->mTextDecorationLine) {
     1:           underColor = color;
 64458:           underStyle = style;
 68819:           decorMask &= ~NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE;
 68819:           decorations |= NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE;
     1:         }
 68819:         if (NS_STYLE_TEXT_DECORATION_LINE_OVERLINE & decorMask &
 68819:               styleText->mTextDecorationLine) {
     1:           overColor = color;
 64458:           overStyle = style;
 68819:           decorMask &= ~NS_STYLE_TEXT_DECORATION_LINE_OVERLINE;
 68819:           decorations |= NS_STYLE_TEXT_DECORATION_LINE_OVERLINE;
     1:         }
 68819:         if (NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH & decorMask &
 68819:               styleText->mTextDecorationLine) {
     1:           strikeColor = color;
 64458:           strikeStyle = style;
 68819:           decorMask &= ~NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH;
 68819:           decorations |= NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH;
     1:         }
     1:       }
 75138:     } while (0 != decorMask &&
101446:              (f = nsLayoutUtils::GetParentOrPlaceholderFor(f)));
     1: 
 68493:     nsRefPtr<nsFontMetrics> fontMet;
  4353:     nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fontMet));
     1: 
     1:     nscoord offset;
     1:     nscoord size;
 68495:     nscoord ascent = fontMet->MaxAscent();
     1: 
  5601:     nscoord baseline =
 19949:       presContext->RoundAppUnitsToNearestDevPixels(aTextRect.y + ascent);
  9438:     nsRefPtr<gfxContext> ctx = aRenderingContext.ThebesContext();
 19949:     gfxPoint pt(presContext->AppUnitsToGfxUnits(aTextRect.x),
 19949:                 presContext->AppUnitsToGfxUnits(aTextRect.y));
 19949:     gfxFloat width = presContext->AppUnitsToGfxUnits(aTextRect.width);
  5601:     gfxFloat ascentPixel = presContext->AppUnitsToGfxUnits(ascent);
 78406:     gfxRect dirtyRect(presContext->AppUnitsToGfxUnits(aDirtyRect));
 20037: 
 20037:     // Underlines are drawn before overlines, and both before the text
 20037:     // itself, per http://www.w3.org/TR/CSS21/zindex.html point 7.2.1.4.1.1.
 20037:     // (We don't apply this rule to the access-key underline because we only
 20037:     // find out where that is as a side effect of drawing the text, in the
 20037:     // general case -- see below.)
 20037:     if (decorations & (NS_FONT_DECORATION_OVERLINE |
 20037:                        NS_FONT_DECORATION_UNDERLINE)) {
     1:       fontMet->GetUnderline(offset, size);
  5147:       gfxFloat offsetPixel = presContext->AppUnitsToGfxUnits(offset);
  5147:       gfxFloat sizePixel = presContext->AppUnitsToGfxUnits(size);
 68818:       if ((decorations & NS_FONT_DECORATION_UNDERLINE) &&
 68818:           underStyle != NS_STYLE_TEXT_DECORATION_STYLE_NONE) {
 78406:         nsCSSRendering::PaintDecorationLine(ctx, dirtyRect, underColor,
 20037:                           pt, gfxSize(width, sizePixel),
 20037:                           ascentPixel, offsetPixel,
 68819:                           NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE, underStyle);
 20037:       }
 68818:       if ((decorations & NS_FONT_DECORATION_OVERLINE) &&
 68818:           overStyle != NS_STYLE_TEXT_DECORATION_STYLE_NONE) {
 78406:         nsCSSRendering::PaintDecorationLine(ctx, dirtyRect, overColor,
  4302:                           pt, gfxSize(width, sizePixel),
  5601:                           ascentPixel, ascentPixel,
 68819:                           NS_STYLE_TEXT_DECORATION_LINE_OVERLINE, overStyle);
     1:       }
     1:     }
     1: 
 68481:     nsRefPtr<nsRenderingContext> refContext =
 60677:         PresContext()->PresShell()->GetReferenceRenderingContext();
 60677: 
  4353:     aRenderingContext.SetFont(fontMet);
 60677:     refContext->SetFont(fontMet);
     1: 
 60677:     CalculateUnderline(*refContext);
     1: 
 19961:     aRenderingContext.SetColor(aOverrideColor ? *aOverrideColor : GetStyleColor()->mColor);
     1: 
     1: #ifdef IBMBIDI
     1:     nsresult rv = NS_ERROR_FAILURE;
     1: 
     1:     if (mState & NS_FRAME_IS_BIDI) {
 15376:       presContext->SetBidiEnabled();
     1:       const nsStyleVisibility* vis = GetStyleVisibility();
     1:       nsBidiDirection direction = (NS_STYLE_DIRECTION_RTL == vis->mDirection) ? NSBIDI_RTL : NSBIDI_LTR;
     1:       if (mAccessKeyInfo && mAccessKeyInfo->mAccesskeyIndex != kNotFound) {
     1:           // We let the RenderText function calculate the mnemonic's
     1:           // underline position for us.
     1:           nsBidiPositionResolve posResolve;
     1:           posResolve.logicalIndex = mAccessKeyInfo->mAccesskeyIndex;
 73724:           rv = nsBidiPresUtils::RenderText(mCroppedTitle.get(), mCroppedTitle.Length(), direction,
     1:                                            presContext, aRenderingContext,
 60677:                                            *refContext,
 19949:                                            aTextRect.x, baseline,
     1:                                            &posResolve,
     1:                                            1);
     1:           mAccessKeyInfo->mBeforeWidth = posResolve.visualLeftTwips;
 26442:           mAccessKeyInfo->mAccessWidth = posResolve.visualWidth;
     1:       }
     1:       else
     1:       {
 73724:           rv = nsBidiPresUtils::RenderText(mCroppedTitle.get(), mCroppedTitle.Length(), direction,
     1:                                            presContext, aRenderingContext,
 60677:                                            *refContext,
 19949:                                            aTextRect.x, baseline);
     1:       }
     1:     }
     1:     if (NS_FAILED(rv) )
     1: #endif // IBMBIDI
     1:     {
 80486:        aRenderingContext.SetTextRunRTL(false);
     1: 
     1:        if (mAccessKeyInfo && mAccessKeyInfo->mAccesskeyIndex != kNotFound) {
     1:            // In the simple (non-BiDi) case, we calculate the mnemonic's
     1:            // underline position by getting the text metric.
     1:            // XXX are attribute values always two byte?
     1:            if (mAccessKeyInfo->mAccesskeyIndex > 0)
 68484:                mAccessKeyInfo->mBeforeWidth =
 68484:                    refContext->GetWidth(mCroppedTitle.get(),
 68484:                                         mAccessKeyInfo->mAccesskeyIndex);
     1:            else
     1:                mAccessKeyInfo->mBeforeWidth = 0;
     1:        }
     1: 
 68491:        fontMet->DrawString(mCroppedTitle.get(), mCroppedTitle.Length(),
 68491:                            aTextRect.x, baseline, &aRenderingContext,
 68491:                            refContext.get());
     1:     }
     1: 
     1:     if (mAccessKeyInfo && mAccessKeyInfo->mAccesskeyIndex != kNotFound) {
 19949:         aRenderingContext.FillRect(aTextRect.x + mAccessKeyInfo->mBeforeWidth,
 19949:                                    aTextRect.y + mAccessKeyInfo->mAccessOffset,
     1:                                    mAccessKeyInfo->mAccessWidth,
     1:                                    mAccessKeyInfo->mAccessUnderlineSize);
     1:     }
 20037: 
 20037:     // Strikeout is drawn on top of the text, per
 20037:     // http://www.w3.org/TR/CSS21/zindex.html point 7.2.1.4.1.1.
 68818:     if ((decorations & NS_FONT_DECORATION_LINE_THROUGH) &&
 68818:         strikeStyle != NS_STYLE_TEXT_DECORATION_STYLE_NONE) {
 20037:       fontMet->GetStrikeout(offset, size);
 20037:       gfxFloat offsetPixel = presContext->AppUnitsToGfxUnits(offset);
 20037:       gfxFloat sizePixel = presContext->AppUnitsToGfxUnits(size);
 78406:       nsCSSRendering::PaintDecorationLine(ctx, dirtyRect, strikeColor,
 26883:                         pt, gfxSize(width, sizePixel), ascentPixel, offsetPixel,
 68819:                         NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH,
 68819:                         strikeStyle);
 20037:     }
     1: }
     1: 
     1: void
 68481: nsTextBoxFrame::CalculateUnderline(nsRenderingContext& aRenderingContext)
     1: {
     1:     if (mAccessKeyInfo && mAccessKeyInfo->mAccesskeyIndex != kNotFound) {
     1:          // Calculate all fields of mAccessKeyInfo which
     1:          // are the same for both BiDi and non-BiDi frames.
     1:          const PRUnichar *titleString = mCroppedTitle.get();
 80486:          aRenderingContext.SetTextRunRTL(false);
 68484:          mAccessKeyInfo->mAccessWidth =
 68484:              aRenderingContext.GetWidth(titleString[mAccessKeyInfo->
 68484:                                                     mAccesskeyIndex]);
     1: 
     1:          nscoord offset, baseline;
 68493:          nsFontMetrics* metrics = aRenderingContext.FontMetrics();
     1:          metrics->GetUnderline(offset, mAccessKeyInfo->mAccessUnderlineSize);
 68495:          baseline = metrics->MaxAscent();
     1:          mAccessKeyInfo->mAccessOffset = baseline - offset;
     1:     }
     1: }
     1: 
 59781: nscoord
     1: nsTextBoxFrame::CalculateTitleForWidth(nsPresContext*      aPresContext,
 68481:                                        nsRenderingContext& aRenderingContext,
     1:                                        nscoord              aWidth)
     1: {
     1:     if (mTitle.IsEmpty())
 59781:         return 0;
     1: 
 76295:     nsRefPtr<nsFontMetrics> fm;
 76295:     nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fm));
 76295:     aRenderingContext.SetFont(fm);
     1: 
     1:     // see if the text will completely fit in the width given
 59781:     nscoord titleWidth = nsLayoutUtils::GetStringWidth(this, &aRenderingContext,
     1:                                                        mTitle.get(), mTitle.Length());
     1: 
 59781:     if (titleWidth <= aWidth) {
     1:         mCroppedTitle = mTitle;
     1: #ifdef IBMBIDI
 12922:         if (HasRTLChars(mTitle)) {
     1:             mState |= NS_FRAME_IS_BIDI;
     1:         }
     1: #endif // IBMBIDI
 59781:         return titleWidth;  // fits, done.
     1:     }
     1: 
 10727:     const nsDependentString& kEllipsis = nsContentUtils::GetLocalizedEllipsis();
     1:     // start with an ellipsis
  8167:     mCroppedTitle.Assign(kEllipsis);
     1: 
     1:     // see if the width is even smaller than the ellipsis
     1:     // if so, clear the text (XXX set as many '.' as we can?).
 80486:     aRenderingContext.SetTextRunRTL(false);
 68484:     titleWidth = aRenderingContext.GetWidth(kEllipsis);
     1: 
 59781:     if (titleWidth > aWidth) {
     1:         mCroppedTitle.SetLength(0);
 59781:         return 0;
     1:     }
     1: 
     1:     // if the ellipsis fits perfectly, no use in trying to insert
 59781:     if (titleWidth == aWidth)
 59781:         return titleWidth;
     1: 
 59781:     aWidth -= titleWidth;
     1: 
     1:     // XXX: This whole block should probably take surrogates into account
     1:     // XXX and clusters!
     1:     // ok crop things
     1:     switch (mCropType)
     1:     {
     1:         case CropNone:
     1:         case CropRight:
     1:         {
     1:             nscoord cwidth;
     1:             nscoord twidth = 0;
     1:             int length = mTitle.Length();
     1:             int i;
     1:             for (i = 0; i < length; ++i) {
     1:                 PRUnichar ch = mTitle.CharAt(i);
     1:                 // still in LTR mode
 68484:                 cwidth = aRenderingContext.GetWidth(ch);
     1:                 if (twidth + cwidth > aWidth)
     1:                     break;
     1: 
     1:                 twidth += cwidth;
     1: #ifdef IBMBIDI
     1:                 if (UCS2_CHAR_IS_BIDI(ch) ) {
     1:                   mState |= NS_FRAME_IS_BIDI;
     1:                 }
     1: #endif // IBMBIDI
     1:             }
     1: 
     1:             if (i == 0)
 59781:                 return titleWidth;
     1: 
     1:             // insert what character we can in.
     1:             nsAutoString title( mTitle );
     1:             title.Truncate(i);
     1:             mCroppedTitle.Insert(title, 0);
     1:         }
     1:         break;
     1: 
     1:         case CropLeft:
     1:         {
     1:             nscoord cwidth;
     1:             nscoord twidth = 0;
     1:             int length = mTitle.Length();
     1:             int i;
     1:             for (i=length-1; i >= 0; --i) {
     1:                 PRUnichar ch = mTitle.CharAt(i);
 68484:                 cwidth = aRenderingContext.GetWidth(ch);
     1:                 if (twidth + cwidth > aWidth)
     1:                     break;
     1: 
     1:                 twidth += cwidth;
     1: #ifdef IBMBIDI
     1:                 if (UCS2_CHAR_IS_BIDI(ch) ) {
     1:                   mState |= NS_FRAME_IS_BIDI;
     1:                 }
     1: #endif // IBMBIDI
     1:             }
     1: 
     1:             if (i == length-1)
 59781:                 return titleWidth;
     1: 
     1:             nsAutoString copy;
     1:             mTitle.Right(copy, length-1-i);
     1:             mCroppedTitle += copy;
     1:         }
     1:         break;
     1: 
     1:         case CropCenter:
     1:         {
     1:             nscoord stringWidth =
     1:                 nsLayoutUtils::GetStringWidth(this, &aRenderingContext,
     1:                                               mTitle.get(), mTitle.Length());
     1:             if (stringWidth <= aWidth) {
     1:                 // the entire string will fit in the maximum width
     1:                 mCroppedTitle.Insert(mTitle, 0);
     1:                 break;
     1:             }
     1: 
     1:             // determine how much of the string will fit in the max width
     1:             nscoord charWidth = 0;
     1:             nscoord totalWidth = 0;
     1:             PRUnichar ch;
     1:             int leftPos, rightPos;
     1:             nsAutoString leftString, rightString;
     1: 
     1:             rightPos = mTitle.Length() - 1;
 80486:             aRenderingContext.SetTextRunRTL(false);
     1:             for (leftPos = 0; leftPos <= rightPos;) {
     1:                 // look at the next character on the left end
     1:                 ch = mTitle.CharAt(leftPos);
 68484:                 charWidth = aRenderingContext.GetWidth(ch);
     1:                 totalWidth += charWidth;
     1:                 if (totalWidth > aWidth)
     1:                     // greater than the allowable width
     1:                     break;
     1:                 leftString.Insert(ch, leftString.Length());
     1: 
     1: #ifdef IBMBIDI
     1:                 if (UCS2_CHAR_IS_BIDI(ch))
     1:                     mState |= NS_FRAME_IS_BIDI;
     1: #endif
     1: 
     1:                 // look at the next character on the right end
     1:                 if (rightPos > leftPos) {
     1:                     // haven't looked at this character yet
     1:                     ch = mTitle.CharAt(rightPos);
 68484:                     charWidth = aRenderingContext.GetWidth(ch);
     1:                     totalWidth += charWidth;
     1:                     if (totalWidth > aWidth)
     1:                         // greater than the allowable width
     1:                         break;
     1:                     rightString.Insert(ch, 0);
     1: 
     1: #ifdef IBMBIDI
     1:                     if (UCS2_CHAR_IS_BIDI(ch))
     1:                         mState |= NS_FRAME_IS_BIDI;
     1: #endif
     1:                 }
     1: 
     1:                 // look at the next two characters
     1:                 leftPos++;
     1:                 rightPos--;
     1:             }
     1: 
  8167:             mCroppedTitle = leftString + kEllipsis + rightString;
     1:         }
     1:         break;
     1:     }
     1: 
 59781:     return nsLayoutUtils::GetStringWidth(this, &aRenderingContext,
     1:                                          mCroppedTitle.get(), mCroppedTitle.Length());
     1: }
     1: 
  8167: #define OLD_ELLIPSIS NS_LITERAL_STRING("...")
  8167: 
     1: // the following block is to append the accesskey to mTitle if there is an accesskey
     1: // but the mTitle doesn't have the character
     1: void
     1: nsTextBoxFrame::UpdateAccessTitle()
     1: {
     1:     /*
     1:      * Note that if you change appending access key label spec,
     1:      * you need to maintain same logic in following methods. See bug 324159.
     1:      * toolkit/content/commonDialog.js (setLabelForNode)
     1:      * toolkit/content/widgets/text.xml (formatAccessKey)
     1:      */
     1:     PRInt32 menuAccessKey;
     1:     nsMenuBarListener::GetMenuAccessKey(&menuAccessKey);
     1:     if (!menuAccessKey || mAccessKey.IsEmpty())
     1:         return;
     1: 
     1:     if (!AlwaysAppendAccessKey() &&
     1:         FindInReadable(mAccessKey, mTitle, nsCaseInsensitiveStringComparator()))
     1:         return;
     1: 
     1:     nsAutoString accessKeyLabel;
     1:     accessKeyLabel += '(';
     1:     accessKeyLabel += mAccessKey;
     1:     ToUpperCase(accessKeyLabel);
     1:     accessKeyLabel += ')';
     1: 
     1:     if (mTitle.IsEmpty()) {
     1:         mTitle = accessKeyLabel;
     1:         return;
     1:     }
     1: 
 10727:     const nsDependentString& kEllipsis = nsContentUtils::GetLocalizedEllipsis();
  8998:     PRUint32 offset = mTitle.Length();
  8998:     if (StringEndsWith(mTitle, kEllipsis)) {
  8998:         offset -= kEllipsis.Length();
  8998:     } else if (StringEndsWith(mTitle, OLD_ELLIPSIS)) {
  8167:         // Try to check with our old ellipsis (for old addons)
  8998:         offset -= OLD_ELLIPSIS.Length();
  8998:     } else {
  8998:         // Try to check with
  8998:         // our default ellipsis (for non-localized addons) or ':'
  8998:         const PRUnichar kLastChar = mTitle.Last();
  8998:         if (kLastChar == PRUnichar(0x2026) || kLastChar == PRUnichar(':'))
     1:             offset--;
     1:     }
     1: 
  8998:     if (InsertSeparatorBeforeAccessKey() &&
 42282:         offset > 0 && !NS_IS_SPACE(mTitle[offset - 1])) {
  8998:         mTitle.Insert(' ', offset);
     1:         offset++;
     1:     }
     1: 
  8998:     mTitle.Insert(accessKeyLabel, offset);
     1: }
     1: 
     1: void
     1: nsTextBoxFrame::UpdateAccessIndex()
     1: {
     1:     PRInt32 menuAccessKey;
     1:     nsMenuBarListener::GetMenuAccessKey(&menuAccessKey);
     1:     if (menuAccessKey) {
     1:         if (mAccessKey.IsEmpty()) {
     1:             if (mAccessKeyInfo) {
     1:                 delete mAccessKeyInfo;
     1:                 mAccessKeyInfo = nsnull;
     1:             }
     1:         } else {
     1:             if (!mAccessKeyInfo) {
     1:                 mAccessKeyInfo = new nsAccessKeyInfo();
     1:                 if (!mAccessKeyInfo)
     1:                     return;
     1:             }
     1: 
     1:             nsAString::const_iterator start, end;
     1:                 
     1:             mCroppedTitle.BeginReading(start);
     1:             mCroppedTitle.EndReading(end);
     1:             
     1:             // remember the beginning of the string
     1:             nsAString::const_iterator originalStart = start;
     1: 
 79445:             bool found;
     1:             if (!AlwaysAppendAccessKey()) {
     1:                 // not appending access key - do case-sensitive search
     1:                 // first
     1:                 found = FindInReadable(mAccessKey, start, end);
     1:                 if (!found) {
     1:                     // didn't find it - perform a case-insensitive search
     1:                     start = originalStart;
     1:                     found = FindInReadable(mAccessKey, start, end,
     1:                                            nsCaseInsensitiveStringComparator());
     1:                 }
     1:             } else {
     1:                 found = RFindInReadable(mAccessKey, start, end,
     1:                                         nsCaseInsensitiveStringComparator());
     1:             }
     1:             
     1:             if (found)
     1:                 mAccessKeyInfo->mAccesskeyIndex = Distance(originalStart, start);
     1:             else
     1:                 mAccessKeyInfo->mAccesskeyIndex = kNotFound;
     1:         }
     1:     }
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTextBoxFrame::DoLayout(nsBoxLayoutState& aBoxLayoutState)
     1: {
  5624:     if (mNeedsReflowCallback) {
  5624:         nsIReflowCallback* cb = new nsAsyncAccesskeyUpdate(this);
  5624:         if (cb) {
  5624:             PresContext()->PresShell()->PostReflowCallback(cb);
  5624:         }
 80486:         mNeedsReflowCallback = false;
  5624:     }
  5624: 
 59781:     nsresult rv = nsLeafBoxFrame::DoLayout(aBoxLayoutState);
     1: 
 59781:     CalcDrawRect(*aBoxLayoutState.GetRenderingContext());
 19949: 
 19949:     const nsStyleText* textStyle = GetStyleText();
 97088:     
 97190:     nsRect scrollBounds(nsPoint(0, 0), GetSize());
 97088:     nsRect textRect = mTextDrawRect;
 97088:     
 97088:     nsRefPtr<nsFontMetrics> fontMet;
 97088:     nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fontMet));
 97088:     nsBoundingMetrics metrics = 
 97190:       fontMet->GetInkBoundsForVisualOverflow(mCroppedTitle.get(),
 97190:                                              mCroppedTitle.Length(),
 97088:                                              aBoxLayoutState.GetRenderingContext());
 97088: 
 97088:     textRect.x -= metrics.leftBearing;
 97088:     textRect.width = metrics.width;
 97088:     // In DrawText() we always draw with the baseline at MaxAscent() (relative to mTextDrawRect), 
 97088:     textRect.y += fontMet->MaxAscent() - metrics.ascent;
 97088:     textRect.height = metrics.ascent + metrics.descent;
 97088: 
 97190:     // Our scrollable overflow is our bounds; our visual overflow may
 97190:     // extend beyond that.
 97190:     nsRect visualBounds;
 97190:     visualBounds.UnionRect(scrollBounds, textRect);
 97190:     nsOverflowAreas overflow(visualBounds, scrollBounds);
 97088: 
 19949:     if (textStyle->mTextShadow) {
 97190:       // text-shadow extends our visual but not scrollable bounds
 55028:       nsRect &vis = overflow.VisualOverflow();
 59781:       vis.UnionRect(vis, nsLayoutUtils::GetTextShadowRectsUnion(mTextDrawRect, this));
 97088:     }
 55028:     FinishAndStoreOverflow(overflow, GetSize());
 59781: 
 19949:     return rv;
     1: }
     1: 
 59781: nsRect
 59781: nsTextBoxFrame::GetComponentAlphaBounds()
 59781: {
 97088:   return GetVisualOverflowRectRelativeToSelf();
 59781: }
 59781: 
 79445: bool
 21991: nsTextBoxFrame::ComputesOwnOverflowArea()
 21991: {
 80486:     return true;
 21991: }
 21991: 
     1: /* virtual */ void
     1: nsTextBoxFrame::MarkIntrinsicWidthsDirty()
     1: {
 80486:     mNeedsRecalc = true;
     1:     nsTextBoxFrameSuper::MarkIntrinsicWidthsDirty();
     1: }
     1: 
     1: void
 68495: nsTextBoxFrame::GetTextSize(nsPresContext* aPresContext,
 68495:                             nsRenderingContext& aRenderingContext,
 68495:                             const nsString& aString,
 68495:                             nsSize& aSize, nscoord& aAscent)
     1: {
 68493:     nsRefPtr<nsFontMetrics> fontMet;
  4353:     nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fontMet));
 68495:     aSize.height = fontMet->MaxHeight();
     1:     aRenderingContext.SetFont(fontMet);
     1:     aSize.width =
 68495:       nsLayoutUtils::GetStringWidth(this, &aRenderingContext,
 68495:                                     aString.get(), aString.Length());
 68495:     aAscent = fontMet->MaxAscent();
     1: }
     1: 
     1: void
     1: nsTextBoxFrame::CalcTextSize(nsBoxLayoutState& aBoxLayoutState)
     1: {
     1:     if (mNeedsRecalc)
     1:     {
     1:         nsSize size;
     1:         nsPresContext* presContext = aBoxLayoutState.PresContext();
 68481:         nsRenderingContext* rendContext = aBoxLayoutState.GetRenderingContext();
     1:         if (rendContext) {
     1:             GetTextSize(presContext, *rendContext,
     1:                         mTitle, size, mAscent);
     1:             mTextSize = size;
 80486:             mNeedsRecalc = false;
     1:         }
     1:     }
     1: }
     1: 
 59781: void
 68481: nsTextBoxFrame::CalcDrawRect(nsRenderingContext &aRenderingContext)
 19949: {
 59781:     nsRect textRect(nsPoint(0, 0), GetSize());
 20712:     nsMargin borderPadding;
 20712:     GetBorderAndPadding(borderPadding);
 20712:     textRect.Deflate(borderPadding);
 59781: 
 19949:     // determine (cropped) title and underline position
 19949:     nsPresContext* presContext = PresContext();
 59781:     // determine (cropped) title which fits in aRect.width and its width
 59781:     nscoord titleWidth =
 59781:         CalculateTitleForWidth(presContext, aRenderingContext, textRect.width);
 59781:     // determine if and at which position to put the underline
 59781:     UpdateAccessIndex();
 19949: 
 19949:     // make the rect as small as our (cropped) text.
 19949:     nscoord outerWidth = textRect.width;
 59781:     textRect.width = titleWidth;
 19949: 
 19949:     // Align our text within the overall rect by checking our text-align property.
 19949:     const nsStyleVisibility* vis = GetStyleVisibility();
 19949:     const nsStyleText* textStyle = GetStyleText();
 19949: 
 19949:     if (textStyle->mTextAlign == NS_STYLE_TEXT_ALIGN_CENTER)
 19949:       textRect.x += (outerWidth - textRect.width)/2;
 24696:     else if (textStyle->mTextAlign == NS_STYLE_TEXT_ALIGN_RIGHT ||
 24696:              (textStyle->mTextAlign == NS_STYLE_TEXT_ALIGN_DEFAULT &&
 24696:               vis->mDirection == NS_STYLE_DIRECTION_RTL) ||
 24696:              (textStyle->mTextAlign == NS_STYLE_TEXT_ALIGN_END &&
 24696:               vis->mDirection == NS_STYLE_DIRECTION_LTR)) {
 19949:       textRect.x += (outerWidth - textRect.width);
 19949:     }
 59781: 
 59781:     mTextDrawRect = textRect;
 19949: }
 19949: 
     1: /**
     1:  * Ok return our dimensions
     1:  */
     1: nsSize
     1: nsTextBoxFrame::GetPrefSize(nsBoxLayoutState& aBoxLayoutState)
     1: {
     1:     CalcTextSize(aBoxLayoutState);
     1: 
     1:     nsSize size = mTextSize;
     1:     DISPLAY_PREF_SIZE(this, size);
     1: 
     1:     AddBorderAndPadding(size);
 79445:     bool widthSet, heightSet;
 39604:     nsIBox::AddCSSPrefSize(this, size, widthSet, heightSet);
     1: 
     1:     return size;
     1: }
     1: 
     1: /**
     1:  * Ok return our dimensions
     1:  */
     1: nsSize
     1: nsTextBoxFrame::GetMinSize(nsBoxLayoutState& aBoxLayoutState)
     1: {
     1:     CalcTextSize(aBoxLayoutState);
     1: 
     1:     nsSize size = mTextSize;
     1:     DISPLAY_MIN_SIZE(this, size);
     1: 
     1:     // if there is cropping our min width becomes our border and padding
     1:     if (mCropType != CropNone)
     1:         size.width = 0;
     1: 
     1:     AddBorderAndPadding(size);
 79445:     bool widthSet, heightSet;
 39604:     nsIBox::AddCSSMinSize(aBoxLayoutState, this, size, widthSet, heightSet);
     1: 
     1:     return size;
     1: }
     1: 
     1: nscoord
     1: nsTextBoxFrame::GetBoxAscent(nsBoxLayoutState& aBoxLayoutState)
     1: {
     1:     CalcTextSize(aBoxLayoutState);
     1: 
     1:     nscoord ascent = mAscent;
     1: 
     1:     nsMargin m(0,0,0,0);
     1:     GetBorderAndPadding(m);
     1:     ascent += m.top;
     1: 
     1:     return ascent;
     1: }
     1: 
     1: #ifdef DEBUG
     1: NS_IMETHODIMP
     1: nsTextBoxFrame::GetFrameName(nsAString& aResult) const
     1: {
     1:     MakeFrameName(NS_LITERAL_STRING("TextBox"), aResult);
     1:     aResult += NS_LITERAL_STRING("[value=") + mTitle + NS_LITERAL_STRING("]");
     1:     return NS_OK;
     1: }
     1: #endif
     1: 
     1: // If you make changes to this function, check its counterparts 
 23176: // in nsBoxFrame and nsXULLabelFrame
     1: nsresult
 79445: nsTextBoxFrame::RegUnregAccessKey(bool aDoReg)
     1: {
     1:     // if we have no content, we can't do anything
     1:     if (!mContent)
     1:         return NS_ERROR_FAILURE;
     1: 
     1:     // check if we have a |control| attribute
     1:     // do this check first because few elements have control attributes, and we
     1:     // can weed out most of the elements quickly.
     1: 
     1:     // XXXjag a side-effect is that we filter out anonymous <label>s
     1:     // in e.g. <menu>, <menuitem>, <button>. These <label>s inherit
     1:     // |accesskey| and would otherwise register themselves, overwriting
     1:     // the content we really meant to be registered.
     1:     if (!mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::control))
     1:         return NS_OK;
     1: 
     1:     // see if we even have an access key
     1:     nsAutoString accessKey;
     1:     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, accessKey);
     1: 
     1:     if (accessKey.IsEmpty())
     1:         return NS_OK;
     1: 
     1:     // With a valid PresContext we can get the ESM 
     1:     // and (un)register the access key
 68780:     nsEventStateManager *esm = PresContext()->EventStateManager();
     1: 
     1:     PRUint32 key = accessKey.First();
     1:     if (aDoReg)
 68780:         esm->RegisterAccessKey(mContent, key);
     1:     else
 68780:         esm->UnregisterAccessKey(mContent, key);
     1: 
 68780:     return NS_OK;
     1: }
