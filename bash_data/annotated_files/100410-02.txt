 67915: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 59931:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 59931: 
 59931: #ifndef jsfriendapi_h___
 59931: #define jsfriendapi_h___
 59931: 
 79734: #include "jsclass.h"
 59931: #include "jspubtd.h"
 59931: #include "jsprvtd.h"
 59931: 
 87272: #include "mozilla/GuardObjects.h"
 87272: 
 59931: JS_BEGIN_EXTERN_C
 59931: 
 80159: extern JS_FRIEND_API(void)
 80159: JS_SetGrayGCRootsTracer(JSRuntime *rt, JSTraceDataOp traceOp, void *data);
 80159: 
 59931: extern JS_FRIEND_API(JSString *)
 59931: JS_GetAnonymousString(JSRuntime *rt);
 59931: 
 67915: extern JS_FRIEND_API(JSObject *)
 67915: JS_FindCompilationScope(JSContext *cx, JSObject *obj);
 67915: 
 79734: extern JS_FRIEND_API(JSFunction *)
 79734: JS_GetObjectFunction(JSObject *obj);
 67915: 
 69223: extern JS_FRIEND_API(JSObject *)
 80154: JS_GetGlobalForFrame(JSStackFrame *fp);
 69223: 
 77353: extern JS_FRIEND_API(JSBool)
 77343: JS_SplicePrototype(JSContext *cx, JSObject *obj, JSObject *proto);
 77343: 
 77343: extern JS_FRIEND_API(JSObject *)
 77343: JS_NewObjectWithUniqueType(JSContext *cx, JSClass *clasp, JSObject *proto, JSObject *parent);
 77343: 
 84755: extern JS_FRIEND_API(uint32_t)
 77343: JS_ObjectCountDynamicSlots(JSObject *obj);
 77343: 
 82884: extern JS_FRIEND_API(void)
 86375: JS_ShrinkGCBuffers(JSRuntime *rt);
 86375: 
 74914: extern JS_FRIEND_API(size_t)
 74914: JS_GetE4XObjectsCreated(JSContext *cx);
 74914: 
 74914: extern JS_FRIEND_API(size_t)
 74914: JS_SetProtoCalled(JSContext *cx);
 74914: 
 74914: extern JS_FRIEND_API(size_t)
 74914: JS_GetCustomIteratorCount(JSContext *cx);
 74914: 
 80351: extern JS_FRIEND_API(JSBool)
 80351: JS_NondeterministicGetWeakMapKeys(JSContext *cx, JSObject *obj, JSObject **ret);
 80351: 
 84173: /*
 85055:  * Used by the cycle collector to trace through the shape and all
 85055:  * shapes it reaches, marking all non-shape children found in the
 85055:  * process. Uses bounded stack space.
 84173:  */
 85055: extern JS_FRIEND_API(void)
 85055: JS_TraceShapeCycleCollectorChildren(JSTracer *trc, void *shape);
 84173: 
 80213: enum {
 80213:     JS_TELEMETRY_GC_REASON,
 80213:     JS_TELEMETRY_GC_IS_COMPARTMENTAL,
 80213:     JS_TELEMETRY_GC_MS,
 80213:     JS_TELEMETRY_GC_MARK_MS,
 90410:     JS_TELEMETRY_GC_SWEEP_MS,
 90410:     JS_TELEMETRY_GC_SLICE_MS,
 90410:     JS_TELEMETRY_GC_MMU_50,
 90410:     JS_TELEMETRY_GC_RESET,
 91266:     JS_TELEMETRY_GC_INCREMENTAL_DISABLED,
 91266:     JS_TELEMETRY_GC_NON_INCREMENTAL
 80213: };
 80213: 
 80213: typedef void
 84755: (* JSAccumulateTelemetryDataCallback)(int id, uint32_t sample);
 80213: 
 80213: extern JS_FRIEND_API(void)
 80213: JS_SetAccumulateTelemetryCallback(JSRuntime *rt, JSAccumulateTelemetryDataCallback callback);
 80213: 
 78158: extern JS_FRIEND_API(JSPrincipals *)
 78158: JS_GetCompartmentPrincipals(JSCompartment *compartment);
 78158: 
 79734: /* Safe to call with input obj == NULL. Returns non-NULL iff obj != NULL. */
 79734: extern JS_FRIEND_API(JSObject *)
 79734: JS_ObjectToInnerObject(JSContext *cx, JSObject *obj);
 79734: 
 79734: /* Requires obj != NULL. */
 79734: extern JS_FRIEND_API(JSObject *)
 79734: JS_ObjectToOuterObject(JSContext *cx, JSObject *obj);
 79734: 
 79734: extern JS_FRIEND_API(JSObject *)
 79734: JS_CloneObject(JSContext *cx, JSObject *obj, JSObject *proto, JSObject *parent);
 79734: 
 79734: extern JS_FRIEND_API(JSBool)
 98960: js_GetterOnlyPropertyStub(JSContext *cx, JSHandleObject obj, JSHandleId id, JSBool strict, jsval *vp);
 79734: 
 87297: JS_FRIEND_API(void)
 87297: js_ReportOverRecursed(JSContext *maybecx);
 87297: 
 89265: #ifdef DEBUG
 89265: 
 89265: /*
 89265:  * Routines to print out values during debugging.  These are FRIEND_API to help
 89265:  * the debugger find them and to support temporarily hacking js_Dump* calls
 89265:  * into other code.
 89265:  */
 89265: 
 89265: extern JS_FRIEND_API(void)
 89265: js_DumpString(JSString *str);
 89265: 
 89265: extern JS_FRIEND_API(void)
 89265: js_DumpAtom(JSAtom *atom);
 89265: 
 89265: extern JS_FRIEND_API(void)
 89265: js_DumpObject(JSObject *obj);
 89265: 
 89265: extern JS_FRIEND_API(void)
 89265: js_DumpChars(const jschar *s, size_t n);
 89265: #endif
 89265: 
 78158: #ifdef __cplusplus
 78158: 
 79734: extern JS_FRIEND_API(bool)
 79734: JS_CopyPropertiesFrom(JSContext *cx, JSObject *target, JSObject *obj);
 79734: 
 78158: extern JS_FRIEND_API(JSBool)
 78158: JS_WrapPropertyDescriptor(JSContext *cx, js::PropertyDescriptor *desc);
 78158: 
 79734: extern JS_FRIEND_API(JSBool)
100410: JS_WrapAutoIdVector(JSContext *cx, JS::AutoIdVector &props);
100410: 
100410: extern JS_FRIEND_API(JSBool)
 98960: JS_EnumerateState(JSContext *cx, JSHandleObject obj, JSIterateOp enum_op, js::Value *statep, jsid *idp);
 79734: 
 91659: struct JSFunctionSpecWithHelp {
 91659:     const char      *name;
 91659:     JSNative        call;
 91659:     uint16_t        nargs;
 91659:     uint16_t        flags;
 91659:     const char      *usage;
 91659:     const char      *help;
 91659: };
 91659: 
 91659: #define JS_FN_HELP(name,call,nargs,flags,usage,help)                          \
 91659:     {name, call, nargs, (flags) | JSPROP_ENUMERATE | JSFUN_STUB_GSOPS, usage, help}
 91659: 
 91659: extern JS_FRIEND_API(bool)
 91659: JS_DefineFunctionsWithHelp(JSContext *cx, JSObject *obj, const JSFunctionSpecWithHelp *fs);
 91659: 
 78158: #endif
 78158: 
 59931: JS_END_EXTERN_C
 59931: 
 78158: #ifdef __cplusplus
 78158: 
 79734: namespace js {
 78158: 
 89261: struct RuntimeFriendFields {
 89261:     /*
 89261:      * If non-zero, we were been asked to call the operation callback as soon
 89261:      * as possible.
 89261:      */
 89261:     volatile int32_t    interrupt;
 89261: 
 89261:     /* Limit pointer for checking native stack consumption. */
 89261:     uintptr_t           nativeStackLimit;
 89261: 
 89261:     RuntimeFriendFields()
 89261:       : interrupt(0),
 89261:         nativeStackLimit(0) { }
 89261: 
 89261:     static const RuntimeFriendFields *get(const JSRuntime *rt) {
 89261:         return reinterpret_cast<const RuntimeFriendFields *>(rt);
 89261:     }
 89261: };
 89261: 
 89261: inline JSRuntime *
 89261: GetRuntime(const JSContext *cx)
 89261: {
 89261:     return ContextFriendFields::get(cx)->runtime;
 89261: }
 89261: 
 84729: typedef bool
 84729: (* PreserveWrapperCallback)(JSContext *cx, JSObject *obj);
 84729: 
 80670: #ifdef DEBUG
 80670:  /*
 80670:   * DEBUG-only method to dump the complete object graph of heap-allocated things.
 80670:   * fp is the file for the dump output.
 80670:   */
 80670: extern JS_FRIEND_API(void)
 91339: DumpHeapComplete(JSRuntime *rt, FILE *fp);
 80670: 
 80670: #endif
 80670: 
 78158: class JS_FRIEND_API(AutoSwitchCompartment) {
 78158:   private:
 78158:     JSContext *cx;
 78158:     JSCompartment *oldCompartment;
 78158:   public:
 78158:     AutoSwitchCompartment(JSContext *cx, JSCompartment *newCompartment
 78158:                           JS_GUARD_OBJECT_NOTIFIER_PARAM);
 78158:     AutoSwitchCompartment(JSContext *cx, JSObject *target JS_GUARD_OBJECT_NOTIFIER_PARAM);
 78158:     ~AutoSwitchCompartment();
 78158:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
 78158: };
 78158: 
 79734: #ifdef OLD_GETTER_SETTER_METHODS
 91237: JS_FRIEND_API(JSBool) obj_defineGetter(JSContext *cx, unsigned argc, js::Value *vp);
 91237: JS_FRIEND_API(JSBool) obj_defineSetter(JSContext *cx, unsigned argc, js::Value *vp);
 79734: #endif
 79734: 
 86105: extern JS_FRIEND_API(bool)
 86105: IsSystemCompartment(const JSCompartment *compartment);
 86105: 
 86986: extern JS_FRIEND_API(bool)
 91250: IsAtomsCompartment(const JSCompartment *c);
 86986: 
 79734: /*
 79734:  * Check whether it is OK to assign an undeclared property with name
 79734:  * propname of the global object in the current script on cx.  Reports
 79734:  * an error if one needs to be reported (in particular in all cases
 79734:  * when it returns false).
 79734:  */
 79734: extern JS_FRIEND_API(bool)
 79734: CheckUndeclaredVarAssignment(JSContext *cx, JSString *propname);
 79734: 
 82724: struct WeakMapTracer;
 82724: 
 82724: /*
 82724:  * Weak map tracer callback, called once for every binding of every
 82724:  * weak map that was live at the time of the last garbage collection.
 82724:  *
 82724:  * m will be NULL if the weak map is not contained in a JS Object.
 82724:  */
 82724: typedef void
 82724: (* WeakMapTraceCallback)(WeakMapTracer *trc, JSObject *m,
 82724:                          void *k, JSGCTraceKind kkind,
 82724:                          void *v, JSGCTraceKind vkind);
 82724: 
 82724: struct WeakMapTracer {
 89658:     JSRuntime            *runtime;
 82724:     WeakMapTraceCallback callback;
 82724: 
 89658:     WeakMapTracer(JSRuntime *rt, WeakMapTraceCallback cb)
 89658:         : runtime(rt), callback(cb) {}
 82724: };
 82724: 
 82724: extern JS_FRIEND_API(void)
 82724: TraceWeakMaps(WeakMapTracer *trc);
 82724: 
 89501: extern JS_FRIEND_API(bool)
 89501: GCThingIsMarkedGray(void *thing);
 89501: 
 79734: /*
 79734:  * Shadow declarations of JS internal structures, for access by inline access
 79734:  * functions below. Do not use these structures in any other way. When adding
 79734:  * new fields for access by inline methods, make sure to add static asserts to
 79734:  * the original header file to ensure that offsets are consistent.
 79734:  */
 79734: namespace shadow {
 79734: 
 79734: struct TypeObject {
 79734:     JSObject    *proto;
 79734: };
 79734: 
 83226: struct BaseShape {
 79734:     js::Class   *clasp;
 79734:     JSObject    *parent;
 83226: };
 83226: 
 83226: struct Shape {
 83226:     BaseShape   *base;
 83247:     jsid        _1;
 84755:     uint32_t    slotInfo;
 79734: 
 84755:     static const uint32_t FIXED_SLOTS_SHIFT = 27;
 83226: };
 83226: 
 79734: struct Object {
 83231:     Shape       *shape;
 83231:     TypeObject  *type;
 79734:     js::Value   *slots;
 83249:     js::Value   *_1;
 79734: 
 83247:     size_t numFixedSlots() const { return shape->slotInfo >> Shape::FIXED_SLOTS_SHIFT; }
 83233:     Value *fixedSlots() const {
 86976:         return (Value *)(uintptr_t(this) + sizeof(shadow::Object));
 83233:     }
 79734: 
 79734:     js::Value &slotRef(size_t slot) const {
 83233:         size_t nfixed = numFixedSlots();
 79734:         if (slot < nfixed)
 83233:             return fixedSlots()[slot];
 79734:         return slots[slot - nfixed];
 78158:     }
 79734: };
 79734: 
 89372: struct Atom {
 89372:     size_t _;
 89372:     const jschar *chars;
 89372: };
 89372: 
 79734: } /* namespace shadow */
 79734: 
 79734: extern JS_FRIEND_DATA(js::Class) AnyNameClass;
 79734: extern JS_FRIEND_DATA(js::Class) AttributeNameClass;
 79734: extern JS_FRIEND_DATA(js::Class) CallClass;
 79734: extern JS_FRIEND_DATA(js::Class) DeclEnvClass;
 79734: extern JS_FRIEND_DATA(js::Class) FunctionClass;
 79734: extern JS_FRIEND_DATA(js::Class) FunctionProxyClass;
 79734: extern JS_FRIEND_DATA(js::Class) NamespaceClass;
 79734: extern JS_FRIEND_DATA(js::Class) OuterWindowProxyClass;
 79734: extern JS_FRIEND_DATA(js::Class) ObjectProxyClass;
 79734: extern JS_FRIEND_DATA(js::Class) QNameClass;
 79734: extern JS_FRIEND_DATA(js::Class) XMLClass;
 86031: extern JS_FRIEND_DATA(js::Class) ObjectClass;
 79734: 
 79734: inline js::Class *
 79734: GetObjectClass(const JSObject *obj)
 79734: {
 83231:     return reinterpret_cast<const shadow::Object*>(obj)->shape->base->clasp;
 79734: }
 79734: 
 79734: inline JSClass *
 79734: GetObjectJSClass(const JSObject *obj)
 79734: {
 79734:     return js::Jsvalify(GetObjectClass(obj));
 79734: }
 79734: 
 83278: JS_FRIEND_API(bool)
 86483: IsScopeObject(JSObject *obj);
 83239: 
 79734: inline JSObject *
 86483: GetObjectParent(JSObject *obj)
 79734: {
 83239:     JS_ASSERT(!IsScopeObject(obj));
 86483:     return reinterpret_cast<shadow::Object*>(obj)->shape->base->parent;
 79734: }
 79734: 
 83239: JS_FRIEND_API(JSObject *)
 86483: GetObjectParentMaybeScope(JSObject *obj);
 83239: 
 83293: JS_FRIEND_API(JSObject *)
 83293: GetGlobalForObjectCrossCompartment(JSObject *obj);
 83293: 
 98147: JS_FRIEND_API(void)
 98147: NotifyAnimationActivity(JSObject *obj);
 98147: 
 83256: JS_FRIEND_API(bool)
 83256: IsOriginalScriptFunction(JSFunction *fun);
 83256: 
 83262: JS_FRIEND_API(JSFunction *)
 83262: DefineFunctionWithReserved(JSContext *cx, JSObject *obj, const char *name, JSNative call,
 91237:                            unsigned nargs, unsigned attrs);
 83262: 
 83262: JS_FRIEND_API(JSFunction *)
 91237: NewFunctionWithReserved(JSContext *cx, JSNative call, unsigned nargs, unsigned flags,
 83268:                         JSObject *parent, const char *name);
 83268: 
 83268: JS_FRIEND_API(JSFunction *)
 91237: NewFunctionByIdWithReserved(JSContext *cx, JSNative native, unsigned nargs, unsigned flags,
 83262:                             JSObject *parent, jsid id);
 83262: 
 83262: JS_FRIEND_API(JSObject *)
 83262: InitClassWithReserved(JSContext *cx, JSObject *obj, JSObject *parent_proto,
 91237:                       JSClass *clasp, JSNative constructor, unsigned nargs,
 83262:                       JSPropertySpec *ps, JSFunctionSpec *fs,
 83262:                       JSPropertySpec *static_ps, JSFunctionSpec *static_fs);
 83262: 
 83258: JS_FRIEND_API(const Value &)
 83258: GetFunctionNativeReserved(JSObject *fun, size_t which);
 83258: 
 83258: JS_FRIEND_API(void)
 83258: SetFunctionNativeReserved(JSObject *fun, size_t which, const Value &val);
 83258: 
 79734: inline JSObject *
 86483: GetObjectProto(JSObject *obj)
 79734: {
 79734:     return reinterpret_cast<const shadow::Object*>(obj)->type->proto;
 79734: }
 79734: 
 79734: inline void *
 86483: GetObjectPrivate(JSObject *obj)
 79734: {
 83233:     const shadow::Object *nobj = reinterpret_cast<const shadow::Object*>(obj);
 83233:     void **addr = reinterpret_cast<void**>(&nobj->fixedSlots()[nobj->numFixedSlots()]);
 83233:     return *addr;
 79734: }
 79734: 
 79734: /*
 79734:  * Get a slot that is both reserved for object's clasp *and* is fixed (fits
 79734:  * within the maximum capacity for the object's fixed slots).
 79734:  */
 79734: inline const Value &
 79734: GetReservedSlot(const JSObject *obj, size_t slot)
 79734: {
 83231:     JS_ASSERT(slot < JSCLASS_RESERVED_SLOTS(GetObjectClass(obj)));
 79734:     return reinterpret_cast<const shadow::Object *>(obj)->slotRef(slot);
 79734: }
 79734: 
 87982: JS_FRIEND_API(void)
 87982: SetReservedSlotWithBarrier(JSObject *obj, size_t slot, const Value &value);
 87982: 
 79734: inline void
 79734: SetReservedSlot(JSObject *obj, size_t slot, const Value &value)
 79734: {
 83231:     JS_ASSERT(slot < JSCLASS_RESERVED_SLOTS(GetObjectClass(obj)));
 87982:     shadow::Object *sobj = reinterpret_cast<shadow::Object *>(obj);
 87982:     if (sobj->slotRef(slot).isMarkable())
 87982:         SetReservedSlotWithBarrier(obj, slot, value);
 87982:     else
 87982:         sobj->slotRef(slot) = value;
 79734: }
 79734: 
 84755: JS_FRIEND_API(uint32_t)
 86483: GetObjectSlotSpan(JSObject *obj);
 80062: 
 80062: inline const Value &
 86483: GetObjectSlot(JSObject *obj, size_t slot)
 80062: {
 83252:     JS_ASSERT(slot < GetObjectSlotSpan(obj));
 80062:     return reinterpret_cast<const shadow::Object *>(obj)->slotRef(slot);
 80062: }
 80062: 
 83252: inline Shape *
 86483: GetObjectShape(JSObject *obj)
 80062: {
 83252:     shadow::Shape *shape = reinterpret_cast<const shadow::Object*>(obj)->shape;
 83252:     return reinterpret_cast<Shape *>(shape);
 80062: }
 80062: 
 89372: inline const jschar *
 89372: GetAtomChars(JSAtom *atom)
 89372: {
 89372:     return reinterpret_cast<shadow::Atom *>(atom)->chars;
 89372: }
 89372: 
 89372: inline JSLinearString *
 89372: AtomToLinearString(JSAtom *atom)
 89372: {
 89372:     return reinterpret_cast<JSLinearString *>(atom);
 89372: }
 89372: 
 79734: static inline js::PropertyOp
 79734: CastAsJSPropertyOp(JSObject *object)
 79734: {
 79734:     return JS_DATA_TO_FUNC_PTR(js::PropertyOp, object);
 79734: }
 79734: 
 79734: static inline js::StrictPropertyOp
 79734: CastAsJSStrictPropertyOp(JSObject *object)
 79734: {
 79734:     return JS_DATA_TO_FUNC_PTR(js::StrictPropertyOp, object);
 79734: }
 79734: 
 79734: JS_FRIEND_API(bool)
 91237: GetPropertyNames(JSContext *cx, JSObject *obj, unsigned flags, js::AutoIdVector *props);
 79734: 
 80661: JS_FRIEND_API(bool)
 91688: StringIsArrayIndex(JSLinearString *str, uint32_t *indexp);
 80661: 
 84729: JS_FRIEND_API(void)
 84729: SetPreserveWrapperCallback(JSRuntime *rt, PreserveWrapperCallback callback);
 84729: 
 86111: JS_FRIEND_API(bool)
 86111: IsObjectInContextCompartment(const JSObject *obj, const JSContext *cx);
 86111: 
 79734: /*
 79734:  * NB: these flag bits are encoded into the bytecode stream in the immediate
 94006:  * operand of JSOP_ITER, so don't change them without advancing vm/Xdr.h's
 94006:  * XDR_BYTECODE_VERSION.
 79734:  */
 79734: #define JSITER_ENUMERATE  0x1   /* for-in compatible hidden default iterator */
 79734: #define JSITER_FOREACH    0x2   /* return [key, value] pair rather than key */
 79734: #define JSITER_KEYVALUE   0x4   /* destructuring for-in wants [key, value] */
 79734: #define JSITER_OWNONLY    0x8   /* iterate over obj's own properties only */
 79734: #define JSITER_HIDDEN     0x10  /* also enumerate non-enumerable properties */
 89621: #define JSITER_FOR_OF     0x20  /* harmony for-of loop */
 79734: 
 89261: inline uintptr_t
 91339: GetNativeStackLimit(const JSRuntime *rt)
 89261: {
 91339:     return RuntimeFriendFields::get(rt)->nativeStackLimit;
 89261: }
 87297: 
 87297: #define JS_CHECK_RECURSION(cx, onerror)                                         \
 87297:     JS_BEGIN_MACRO                                                              \
 87297:         int stackDummy_;                                                        \
 91339:         if (!JS_CHECK_STACK_SIZE(js::GetNativeStackLimit(js::GetRuntime(cx)), &stackDummy_)) { \
 87297:             js_ReportOverRecursed(cx);                                          \
 87297:             onerror;                                                            \
 87297:         }                                                                       \
 87297:     JS_END_MACRO
 87297: 
 84803: JS_FRIEND_API(void)
 84803: StartPCCountProfiling(JSContext *cx);
 84803: 
 84803: JS_FRIEND_API(void)
 84803: StopPCCountProfiling(JSContext *cx);
 84803: 
 84803: JS_FRIEND_API(void)
 84803: PurgePCCounts(JSContext *cx);
 84803: 
 84803: JS_FRIEND_API(size_t)
 84803: GetPCCountScriptCount(JSContext *cx);
 84803: 
 84803: JS_FRIEND_API(JSString *)
 84803: GetPCCountScriptSummary(JSContext *cx, size_t script);
 84803: 
 84803: JS_FRIEND_API(JSString *)
 84803: GetPCCountScriptContents(JSContext *cx, size_t script);
 84803: 
 86984: #ifdef JS_THREADSAFE
 88135: JS_FRIEND_API(void *)
 88135: GetOwnerThread(const JSContext *cx);
 87282: 
 87282: JS_FRIEND_API(unsigned)
 87282: GetContextOutstandingRequests(const JSContext *cx);
 86984: #endif
 86984: 
 87284: JS_FRIEND_API(JSCompartment *)
 87284: GetContextCompartment(const JSContext *cx);
 87284: 
 87285: JS_FRIEND_API(bool)
 87285: HasUnrootedGlobal(const JSContext *cx);
 87285: 
 87286: typedef void
 87286: (* ActivityCallback)(void *arg, JSBool active);
 87286: 
 87286: /*
 87286:  * Sets a callback that is run whenever the runtime goes idle - the
 87286:  * last active request ceases - and begins activity - when it was
 91846:  * idle and a request begins.
 87286:  */
 87286: JS_FRIEND_API(void)
 87286: SetActivityCallback(JSRuntime *rt, ActivityCallback cb, void *arg);
 87286: 
 87277: extern JS_FRIEND_API(const JSStructuredCloneCallbacks *)
 87277: GetContextStructuredCloneCallbacks(JSContext *cx);
 87277: 
 87278: extern JS_FRIEND_API(JSVersion)
 99820: VersionSetMoarXML(JSVersion version, bool enable);
 87278: 
 87279: extern JS_FRIEND_API(bool)
 87279: CanCallContextDebugHandler(JSContext *cx);
 87279: 
 87279: extern JS_FRIEND_API(JSTrapStatus)
 87279: CallContextDebugHandler(JSContext *cx, JSScript *script, jsbytecode *bc, Value *rval);
 87279: 
 87291: extern JS_FRIEND_API(bool)
 87291: IsContextRunningJS(JSContext *cx);
 87291: 
 87293: class SystemAllocPolicy;
 87293: typedef Vector<JSCompartment*, 0, SystemAllocPolicy> CompartmentVector;
 87293: extern JS_FRIEND_API(const CompartmentVector&)
 87293: GetRuntimeCompartments(JSRuntime *rt);
 87293: 
 87298: extern JS_FRIEND_API(size_t)
 87298: SizeOfJSContext();
 87298: 
 88182: #define GCREASONS(D)                            \
 88182:     /* Reasons internal to the JS engine */     \
 88182:     D(API)                                      \
 88182:     D(MAYBEGC)                                  \
 88182:     D(LAST_CONTEXT)                             \
 88182:     D(DESTROY_CONTEXT)                          \
 88182:     D(LAST_DITCH)                               \
 88182:     D(TOO_MUCH_MALLOC)                          \
 88182:     D(ALLOC_TRIGGER)                            \
 91660:     D(DEBUG_GC)                                 \
 97686:     D(DEBUG_MODE_GC)                            \
 88182:     D(UNUSED3) /* was REFILL */                 \
 88182:                                                 \
 88182:     /* Reasons from Firefox */                  \
 88182:     D(DOM_WINDOW_UTILS)                         \
 88182:     D(COMPONENT_UTILS)                          \
 88182:     D(MEM_PRESSURE)                             \
 88182:     D(CC_WAITING)                               \
 88182:     D(CC_FORCED)                                \
 88182:     D(LOAD_END)                                 \
 88182:     D(POST_COMPARTMENT)                         \
 88182:     D(PAGE_HIDE)                                \
 88182:     D(NSJSCONTEXT_DESTROY)                      \
 88182:     D(SET_NEW_DOCUMENT)                         \
 88182:     D(SET_DOC_SHELL)                            \
 88182:     D(DOM_UTILS)                                \
 88182:     D(DOM_IPC)                                  \
 88182:     D(DOM_WORKER)                               \
 88182:     D(INTER_SLICE_GC)                           \
 98111:     D(REFRESH_FRAME)                            \
 98111:     D(FULL_GC_TIMER)
 88182: 
 88182: namespace gcreason {
 88182: 
 88182: /* GCReasons will end up looking like JSGC_MAYBEGC */
 88182: enum Reason {
 88182: #define MAKE_REASON(name) name,
 88182:     GCREASONS(MAKE_REASON)
 88182: #undef MAKE_REASON
 88182:     NO_REASON,
 88182:     NUM_REASONS
 88182: };
 88182: 
 88182: } /* namespace gcreason */
 88182: 
 88182: extern JS_FRIEND_API(void)
 94871: PrepareCompartmentForGC(JSCompartment *comp);
 88182: 
 88182: extern JS_FRIEND_API(void)
 94871: PrepareForFullGC(JSRuntime *rt);
 94871: 
 97770: extern JS_FRIEND_API(bool)
 97770: IsGCScheduled(JSRuntime *rt);
 97770: 
 98111: extern JS_FRIEND_API(void)
 98111: SkipCompartmentForGC(JSCompartment *comp);
 98111: 
 94871: /*
 94871:  * When triggering a GC using one of the functions below, it is first necessary
 94871:  * to select the compartments to be collected. To do this, you can call
 94871:  * PrepareCompartmentForGC on each compartment, or you can call PrepareForFullGC
 94871:  * to select all compartments. Failing to select any compartment is an error.
 94871:  */
 94871: 
 94871: extern JS_FRIEND_API(void)
 94960: GCForReason(JSRuntime *rt, gcreason::Reason reason);
 89284: 
 89284: extern JS_FRIEND_API(void)
 94960: ShrinkingGC(JSRuntime *rt, gcreason::Reason reason);
 88182: 
 90410: extern JS_FRIEND_API(void)
 94960: IncrementalGC(JSRuntime *rt, gcreason::Reason reason);
 90410: 
 90410: extern JS_FRIEND_API(void)
 90410: SetGCSliceTimeBudget(JSContext *cx, int64_t millis);
 90410: 
 90410: enum GCProgress {
 90410:     /*
 90410:      * During non-incremental GC, the GC is bracketed by JSGC_CYCLE_BEGIN/END
 90410:      * callbacks. During an incremental GC, the sequence of callbacks is as
 90410:      * follows:
 90410:      *   JSGC_CYCLE_BEGIN, JSGC_SLICE_END  (first slice)
 90410:      *   JSGC_SLICE_BEGIN, JSGC_SLICE_END  (second slice)
 90410:      *   ...
 90410:      *   JSGC_SLICE_BEGIN, JSGC_CYCLE_END  (last slice)
 90410:      */
 90410: 
 90410:     GC_CYCLE_BEGIN,
 90410:     GC_SLICE_BEGIN,
 90410:     GC_SLICE_END,
 90410:     GC_CYCLE_END
 90410: };
 90410: 
 92707: struct JS_FRIEND_API(GCDescription) {
 90410:     bool isCompartment;
 90410: 
 92707:     GCDescription(bool isCompartment)
 92707:       : isCompartment(isCompartment) {}
 92707: 
 92707:     jschar *formatMessage(JSRuntime *rt) const;
 93384:     jschar *formatJSON(JSRuntime *rt, uint64_t timestamp) const;
 90410: };
 90410: 
 90410: typedef void
 90410: (* GCSliceCallback)(JSRuntime *rt, GCProgress progress, const GCDescription &desc);
 90410: 
 90410: extern JS_FRIEND_API(GCSliceCallback)
 90410: SetGCSliceCallback(JSRuntime *rt, GCSliceCallback callback);
 90410: 
 90410: /*
 90410:  * Signals a good place to do an incremental slice, because the browser is
 90410:  * drawing a frame.
 90410:  */
 90410: extern JS_FRIEND_API(void)
 94960: NotifyDidPaint(JSRuntime *rt);
 90410: 
 90410: extern JS_FRIEND_API(bool)
 90410: IsIncrementalGCEnabled(JSRuntime *rt);
 90410: 
 91205: extern JS_FRIEND_API(void)
 91205: DisableIncrementalGC(JSRuntime *rt);
 91205: 
 87981: extern JS_FRIEND_API(bool)
 87981: IsIncrementalBarrierNeeded(JSRuntime *rt);
 87981: 
 87981: extern JS_FRIEND_API(bool)
 87981: IsIncrementalBarrierNeeded(JSContext *cx);
 87981: 
 90410: extern JS_FRIEND_API(bool)
 90410: IsIncrementalBarrierNeededOnObject(JSObject *obj);
 90410: 
 97587: extern JS_FRIEND_API(bool)
 97587: IsIncrementalBarrierNeededOnScript(JSScript *obj);
 97587: 
 87981: extern JS_FRIEND_API(void)
 87981: IncrementalReferenceBarrier(void *ptr);
 87981: 
 87981: extern JS_FRIEND_API(void)
 87981: IncrementalValueBarrier(const Value &v);
 87981: 
 99131: extern JS_FRIEND_API(void)
 99131: PokeGC(JSRuntime *rt);
 99131: 
 87981: class ObjectPtr
 87981: {
 87981:     JSObject *value;
 87981: 
 87981:   public:
 87981:     ObjectPtr() : value(NULL) {}
 87981: 
 87981:     ObjectPtr(JSObject *obj) : value(obj) {}
 87981: 
 87981:     /* Always call finalize before the destructor. */
 87981:     ~ObjectPtr() { JS_ASSERT(!value); }
 87981: 
 87981:     void finalize(JSRuntime *rt) {
 87981:         if (IsIncrementalBarrierNeeded(rt))
 87981:             IncrementalReferenceBarrier(value);
 87981:         value = NULL;
 87981:     }
 87981: 
 87981:     void init(JSObject *obj) { value = obj; }
 87981: 
 87981:     JSObject *get() const { return value; }
 87981: 
 87981:     void writeBarrierPre(JSRuntime *rt) {
 87981:         IncrementalReferenceBarrier(value);
 87981:     }
 87981: 
 87981:     ObjectPtr &operator=(JSObject *obj) {
 87981:         IncrementalReferenceBarrier(value);
 87981:         value = obj;
 87981:         return *this;
 87981:     }
 87981: 
 87981:     JSObject &operator*() const { return *value; }
 87981:     JSObject *operator->() const { return value; }
 87981:     operator JSObject *() const { return value; }
 87981: };
 87981: 
 91659: extern JS_FRIEND_API(JSObject *)
 91659: GetTestingFunctions(JSContext *cx);
 91659: 
 94738: /*
 94738:  * Helper to convert FreeOp to JSFreeOp when the definition of FreeOp is not
 94738:  * available and the compiler does not know that FreeOp inherits from
 94738:  * JSFreeOp.
 94738:  */
 94738: inline JSFreeOp *
 94738: CastToJSFreeOp(FreeOp *fop)
 94738: {
 94738:     return reinterpret_cast<JSFreeOp *>(fop);
 94738: }
 94738: 
 95212: /* Implemented in jsexn.cpp. */
 95212: 
 95212: /*
 95212:  * Get an error type name from a number.
 95212:  * If no exception is associated, return NULL.
 95212:  */
 95212: extern JS_FRIEND_API(const jschar*)
 95212: GetErrorTypeNameFromNumber(JSContext* cx, const unsigned errorNumber);
 95212: 
 96950: /* Implemented in jswrapper.cpp. */
 96950: typedef enum NukedGlobalHandling {
 96950:     NukeForGlobalObject,
 96950:     DontNukeForGlobalObject
 96950: } NukedGlobalHandling;
 96950: 
 96950: extern JS_FRIEND_API(JSBool)
 96950: NukeChromeCrossCompartmentWrappersForGlobal(JSContext *cx, JSObject *obj,
 96950:                                             NukedGlobalHandling nukeGlobal);
 96950: 
 79734: } /* namespace js */
 86105: 
 78158: #endif
 78158: 
 87274: /* Implemented in jsdate.cpp. */
 87274: 
 87274: /*
 87274:  * Detect whether the internal date value is NaN.  (Because failure is
 87274:  * out-of-band for js_DateGet*)
 87274:  */
 87274: extern JS_FRIEND_API(JSBool)
 87274: js_DateIsValid(JSContext *cx, JSObject* obj);
 87274: 
 87274: extern JS_FRIEND_API(double)
 87274: js_DateGetMsecSinceEpoch(JSContext *cx, JSObject *obj);
 87274: 
 87275: /* Implemented in jscntxt.cpp. */
 87275: 
 87275: /*
 87275:  * Report an exception, which is currently realized as a printf-style format
 87275:  * string and its arguments.
 87275:  */
 87275: typedef enum JSErrNum {
 87275: #define MSG_DEF(name, number, count, exception, format) \
 87275:     name = number,
 87275: #include "js.msg"
 87275: #undef MSG_DEF
 87275:     JSErr_Limit
 87275: } JSErrNum;
 87275: 
 87275: extern JS_FRIEND_API(const JSErrorFormatString *)
 91237: js_GetErrorMessage(void *userRef, const char *locale, const unsigned errorNumber);
 87275: 
 87276: /* Implemented in jsclone.cpp. */
 87276: 
 87276: extern JS_FRIEND_API(uint64_t)
 87276: js_GetSCOffset(JSStructuredCloneWriter* writer);
 87276: 
 95834: /* Typed Array functions, implemented in jstypedarray.cpp */
 95834: 
 95834: #ifdef __cplusplus
 95834: 
 95834: namespace js {
 95834: namespace ArrayBufferView {
 95834: 
 95834: enum ViewType {
 95834:     TYPE_INT8 = 0,
 95834:     TYPE_UINT8,
 95834:     TYPE_INT16,
 95834:     TYPE_UINT16,
 95834:     TYPE_INT32,
 95834:     TYPE_UINT32,
 95834:     TYPE_FLOAT32,
 95834:     TYPE_FLOAT64,
 95834: 
 95834:     /*
 95834:      * Special type that is a uint8_t, but assignments are clamped to [0, 256).
 95834:      * Treat the raw data type as a uint8_t.
 95834:      */
 95834:     TYPE_UINT8_CLAMPED,
 95834: 
 95834:     TYPE_MAX
 95834: };
 95834: 
 95834: } /* namespace ArrayBufferView */
 95834: } /* namespace js */
 95834: 
 95834: typedef js::ArrayBufferView::ViewType JSArrayBufferViewType;
 95834: #else
 95834: typedef uint32_t JSArrayBufferViewType;
 95834: #endif /* __cplusplus */
 95834: 
 95834: /*
 95834:  * Create a new typed array with nelements elements.
 95834:  */
 95834: 
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewInt8Array(JSContext *cx, uint32_t nelements);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewUint8Array(JSContext *cx, uint32_t nelements);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewUint8ClampedArray(JSContext *cx, uint32_t nelements);
 95834: 
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewInt16Array(JSContext *cx, uint32_t nelements);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewUint16Array(JSContext *cx, uint32_t nelements);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewInt32Array(JSContext *cx, uint32_t nelements);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewUint32Array(JSContext *cx, uint32_t nelements);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewFloat32Array(JSContext *cx, uint32_t nelements);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewFloat64Array(JSContext *cx, uint32_t nelements);
 95834: 
 95834: /*
 95834:  * Create a new typed array and copy in values from the given object. The
 95834:  * object is used as if it were an array; that is, the new array (if
 95834:  * successfully created) will have length given by array.length, and its
 95834:  * elements will be those specified by array[0], array[1], and so on, after
 95834:  * conversion to the typed array element type.
 95834:  */
 95834: 
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewInt8ArrayFromArray(JSContext *cx, JSObject *array);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewUint8ArrayFromArray(JSContext *cx, JSObject *array);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewUint8ClampedArrayFromArray(JSContext *cx, JSObject *array);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewInt16ArrayFromArray(JSContext *cx, JSObject *array);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewUint16ArrayFromArray(JSContext *cx, JSObject *array);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewInt32ArrayFromArray(JSContext *cx, JSObject *array);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewUint32ArrayFromArray(JSContext *cx, JSObject *array);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewFloat32ArrayFromArray(JSContext *cx, JSObject *array);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewFloat64ArrayFromArray(JSContext *cx, JSObject *array);
 95834: 
 95834: /*
 95834:  * Create a new typed array using the given ArrayBuffer for storage. byteOffset
 95834:  * must not exceed (signed) INT32_MAX. The length value is optional; if -1 is
 95834:  * passed, enough elements to use up the remainder of the byte array is used as
 95834:  * the default value.
 95834:  */
 95834: 
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewInt8ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
 95834:                           uint32_t byteOffset, int32_t length);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewUint8ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
 95834:                            uint32_t byteOffset, int32_t length);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewUint8ClampedArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
 95834:                                   uint32_t byteOffset, int32_t length);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewInt16ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
 95834:                            uint32_t byteOffset, int32_t length);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewUint16ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
 95834:                             uint32_t byteOffset, int32_t length);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewInt32ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
 95834:                            uint32_t byteOffset, int32_t length);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewUint32ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
 95834:                             uint32_t byteOffset, int32_t length);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewFloat32ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
 95834:                              uint32_t byteOffset, int32_t length);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewFloat64ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
 95834:                              uint32_t byteOffset, int32_t length);
 95834: 
 95834: /*
 95834:  * Create a new ArrayBuffer with the given byte length.
 95834:  */
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewArrayBuffer(JSContext *cx, uint32_t nbytes);
 95834: 
 95834: /*
 95834:  * Check whether obj supports JS_GetTypedArray* APIs. Note that this may return
 95834:  * false if a security wrapper is encountered that denies the unwrapping. If
 95834:  * this test or one of the JS_Is*Array tests succeeds, then it is safe to call
 95834:  * the various accessor JSAPI calls defined below.
 95834:  */
 95834: extern JS_FRIEND_API(JSBool)
 95834: JS_IsTypedArrayObject(JSObject *obj, JSContext *cx);
 95834: 
 95834: /*
 97574:  * Check whether obj supports JS_GetArrayBufferView* APIs. Note that this may
 97574:  * return false if a security wrapper is encountered that denies the
 97574:  * unwrapping. If this test or one of the more specific tests succeeds, then it
 97574:  * is safe to call the various ArrayBufferView accessor JSAPI calls defined
 97574:  * below. cx MUST be non-NULL and valid.
 97574:  */
 97574: extern JS_FRIEND_API(JSBool)
 97574: JS_IsArrayBufferViewObject(JSObject *obj, JSContext *cx);
 97574: 
 97574: /*
 95834:  * Test for specific typed array types (ArrayBufferView subtypes)
 95834:  */
 95834: 
 95834: extern JS_FRIEND_API(JSBool)
 95834: JS_IsInt8Array(JSObject *obj, JSContext *cx);
 95834: extern JS_FRIEND_API(JSBool)
 95834: JS_IsUint8Array(JSObject *obj, JSContext *cx);
 95834: extern JS_FRIEND_API(JSBool)
 95834: JS_IsUint8ClampedArray(JSObject *obj, JSContext *cx);
 95834: extern JS_FRIEND_API(JSBool)
 95834: JS_IsInt16Array(JSObject *obj, JSContext *cx);
 95834: extern JS_FRIEND_API(JSBool)
 95834: JS_IsUint16Array(JSObject *obj, JSContext *cx);
 95834: extern JS_FRIEND_API(JSBool)
 95834: JS_IsInt32Array(JSObject *obj, JSContext *cx);
 95834: extern JS_FRIEND_API(JSBool)
 95834: JS_IsUint32Array(JSObject *obj, JSContext *cx);
 95834: extern JS_FRIEND_API(JSBool)
 95834: JS_IsFloat32Array(JSObject *obj, JSContext *cx);
 95834: extern JS_FRIEND_API(JSBool)
 95834: JS_IsFloat64Array(JSObject *obj, JSContext *cx);
 95834: 
 95834: /*
 95834:  * Get the type of elements in a typed array.
 95834:  *
 95834:  * |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
 95834:  * be known that it would pass such a test: it is a typed array or a wrapper of
 95834:  * a typed array, and the unwrapping will succeed. If cx is NULL, then DEBUG
 95834:  * builds may be unable to assert when unwrapping should be disallowed.
 95834:  */
 95834: extern JS_FRIEND_API(JSArrayBufferViewType)
 95834: JS_GetTypedArrayType(JSObject *obj, JSContext *cx);
 95834: 
 95834: /*
 95834:  * Check whether obj supports the JS_GetArrayBuffer* APIs. Note that this may
 95834:  * return false if a security wrapper is encountered that denies the
 95834:  * unwrapping. If this test succeeds, then it is safe to call the various
 95834:  * accessor JSAPI calls defined below.
 95834:  */
 95834: extern JS_FRIEND_API(JSBool)
 95834: JS_IsArrayBufferObject(JSObject *obj, JSContext *cx);
 95834: 
 95834: /*
 95834:  * Return the available byte length of an array buffer.
 95834:  *
 95834:  * |obj| must have passed a JS_IsArrayBufferObject test, or somehow be known
 95834:  * that it would pass such a test: it is an ArrayBuffer or a wrapper of an
 95834:  * ArrayBuffer, and the unwrapping will succeed. If cx is NULL, then DEBUG
 95834:  * builds may be unable to assert when unwrapping should be disallowed.
 95834:  */
 95834: extern JS_FRIEND_API(uint32_t)
 95834: JS_GetArrayBufferByteLength(JSObject *obj, JSContext *cx);
 95834: 
 95834: /*
 95834:  * Return a pointer to an array buffer's data. The buffer is still owned by the
 95834:  * array buffer object, and should not be modified on another thread.
 95834:  *
 95834:  * |obj| must have passed a JS_IsArrayBufferObject test, or somehow be known
 95834:  * that it would pass such a test: it is an ArrayBuffer or a wrapper of an
 95834:  * ArrayBuffer, and the unwrapping will succeed. If cx is NULL, then DEBUG
 95834:  * builds may be unable to assert when unwrapping should be disallowed.
 95834:  */
 95834: extern JS_FRIEND_API(uint8_t *)
 95834: JS_GetArrayBufferData(JSObject *obj, JSContext *cx);
 95834: 
 95834: /*
 95834:  * Return the number of elements in a typed array.
 95834:  *
 95834:  * |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
 95834:  * be known that it would pass such a test: it is a typed array or a wrapper of
 95834:  * a typed array, and the unwrapping will succeed. If cx is NULL, then DEBUG
 95834:  * builds may be unable to assert when unwrapping should be disallowed.
 95834:  */
 95834: extern JS_FRIEND_API(uint32_t)
 95834: JS_GetTypedArrayLength(JSObject *obj, JSContext *cx);
 95834: 
 95834: /*
 95834:  * Return the byte offset from the start of an array buffer to the start of a
 95834:  * typed array view.
 95834:  *
 95834:  * |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
 95834:  * be known that it would pass such a test: it is a typed array or a wrapper of
 95834:  * a typed array, and the unwrapping will succeed. If cx is NULL, then DEBUG
 95834:  * builds may be unable to assert when unwrapping should be disallowed.
 95834:  */
 95834: extern JS_FRIEND_API(uint32_t)
 95834: JS_GetTypedArrayByteOffset(JSObject *obj, JSContext *cx);
 95834: 
 95834: /*
 95834:  * Return the byte length of a typed array.
 95834:  *
 95834:  * |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
 95834:  * be known that it would pass such a test: it is a typed array or a wrapper of
 95834:  * a typed array, and the unwrapping will succeed. If cx is NULL, then DEBUG
 95834:  * builds may be unable to assert when unwrapping should be disallowed.
 95834:  */
 95834: extern JS_FRIEND_API(uint32_t)
 95834: JS_GetTypedArrayByteLength(JSObject *obj, JSContext *cx);
 95834: 
 95834: /*
 96956:  * Check whether obj supports JS_ArrayBufferView* APIs. Note that this may
 96956:  * return false if a security wrapper is encountered that denies the
 96956:  * unwrapping.
 96956:  */
 96956: extern JS_FRIEND_API(JSBool)
 96956: JS_IsArrayBufferViewObject(JSObject *obj, JSContext *cx);
 96956: 
 96956: /*
 95834:  * More generic name for JS_GetTypedArrayByteLength to cover DataViews as well
 95834:  */
 95834: extern JS_FRIEND_API(uint32_t)
 95834: JS_GetArrayBufferViewByteLength(JSObject *obj, JSContext *cx);
 95834: 
 95834: /*
 95834:  * Return a pointer to the start of the data referenced by a typed array. The
 95834:  * data is still owned by the typed array, and should not be modified on
 95834:  * another thread.
 95834:  *
 95834:  * |obj| must have passed a JS_Is*Array test, or somehow be known that it would
 95834:  * pass such a test: it is a typed array or a wrapper of a typed array, and the
 95834:  * unwrapping will succeed. If cx is NULL, then DEBUG builds may be unable to
 95834:  * assert when unwrapping should be disallowed.
 95834:  */
 95834: 
 95834: extern JS_FRIEND_API(int8_t *)
 95834: JS_GetInt8ArrayData(JSObject *obj, JSContext *cx);
 95834: extern JS_FRIEND_API(uint8_t *)
 95834: JS_GetUint8ArrayData(JSObject *obj, JSContext *cx);
 95834: extern JS_FRIEND_API(uint8_t *)
 95834: JS_GetUint8ClampedArrayData(JSObject *obj, JSContext *cx);
 95834: extern JS_FRIEND_API(int16_t *)
 95834: JS_GetInt16ArrayData(JSObject *obj, JSContext *cx);
 95834: extern JS_FRIEND_API(uint16_t *)
 95834: JS_GetUint16ArrayData(JSObject *obj, JSContext *cx);
 95834: extern JS_FRIEND_API(int32_t *)
 95834: JS_GetInt32ArrayData(JSObject *obj, JSContext *cx);
 95834: extern JS_FRIEND_API(uint32_t *)
 95834: JS_GetUint32ArrayData(JSObject *obj, JSContext *cx);
 95834: extern JS_FRIEND_API(float *)
 95834: JS_GetFloat32ArrayData(JSObject *obj, JSContext *cx);
 95834: extern JS_FRIEND_API(double *)
 95834: JS_GetFloat64ArrayData(JSObject *obj, JSContext *cx);
 95834: 
 95834: /*
 95834:  * Same as above, but for any kind of ArrayBufferView. Prefer the type-specific
 95834:  * versions when possible.
 95834:  */
 95834: extern JS_FRIEND_API(void *)
 95834: JS_GetArrayBufferViewData(JSObject *obj, JSContext *cx);
 95834: 
 97574: /*
 97574:  * Check whether obj supports JS_GetDataView* APIs. Note that this may fail and
 97574:  * throw an exception if a security wrapper is encountered that denies the
 97574:  * operation.
 97574:  */
 97574: JS_FRIEND_API(JSBool)
 97574: JS_IsDataViewObject(JSContext *cx, JSObject *obj, JSBool *isDataView);
 97574: 
 97574: /*
 97574:  * Return the byte offset of a data view into its array buffer. |obj| must be a
 97574:  * DataView.
 97574:  *
 97574:  * |obj| must have passed a JS_IsDataViewObject test, or somehow be known that
 97574:  * it would pass such a test: it is a data view or a wrapper of a data view,
 97574:  * and the unwrapping will succeed. If cx is NULL, then DEBUG builds may be
 97574:  * unable to assert when unwrapping should be disallowed.
 97574:  */
 97574: JS_FRIEND_API(uint32_t)
 97574: JS_GetDataViewByteOffset(JSObject *obj, JSContext *cx);
 97574: 
 97574: /*
 97574:  * Return the byte length of a data view.
 97574:  *
 97574:  * |obj| must have passed a JS_IsDataViewObject test, or somehow be known that
 97574:  * it would pass such a test: it is a data view or a wrapper of a data view,
 97574:  * and the unwrapping will succeed. If cx is NULL, then DEBUG builds may be
 97574:  * unable to assert when unwrapping should be disallowed.
 97574:  */
 97574: JS_FRIEND_API(uint32_t)
 97574: JS_GetDataViewByteLength(JSObject *obj, JSContext *cx);
 97574: 
 97574: /*
 97574:  * Return a pointer to the beginning of the data referenced by a DataView.
 97574:  *
 97574:  * |obj| must have passed a JS_IsDataViewObject test, or somehow be known that
 97574:  * it would pass such a test: it is a data view or a wrapper of a data view,
 97574:  * and the unwrapping will succeed. If cx is NULL, then DEBUG builds may be
 97574:  * unable to assert when unwrapping should be disallowed.
 97574:  */
 97574: JS_FRIEND_API(void *)
 97574: JS_GetDataViewData(JSObject *obj, JSContext *cx);
 97574: 
 59931: #endif /* jsfriendapi_h___ */
