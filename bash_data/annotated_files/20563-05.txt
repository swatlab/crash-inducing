    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* representation of simple property values within CSS declarations */
    1: 
    1: #ifndef nsCSSValue_h___
    1: #define nsCSSValue_h___
    1: 
    1: #include "nsColor.h"
    1: #include "nsString.h"
    1: #include "nsCoord.h"
    1: #include "nsCSSProperty.h"
    1: #include "nsIURI.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsCRTGlue.h"
    1: #include "nsStringBuffer.h"
    1: 
    1: class imgIRequest;
    1: class nsIDocument;
 1036: class nsIPrincipal;
    1: 
20563: // Deletes a linked list iteratively to avoid blowing up the stack (bug 456196).
20563: #define NS_CSS_DELETE_LIST_MEMBER(type_, ptr_, member_)                        \
20563:   {                                                                            \
20563:     type_ *cur = (ptr_)->member_;                                              \
20563:     (ptr_)->member_ = nsnull;                                                  \
20563:     while (cur) {                                                              \
20563:       type_ *next = cur->member_;                                              \
20563:       cur->member_ = nsnull;                                                   \
20563:       delete cur;                                                              \
20563:       cur = next;                                                              \
20563:     }                                                                          \
20563:   }
20563: 
20563: // Clones a linked list iteratively to avoid blowing up the stack.
20563: // If it fails to clone the entire list then 'to_' is deleted and
20563: // we return null.
20563: #define NS_CSS_CLONE_LIST_MEMBER(type_, from_, member_, to_, args_)            \
20563:   {                                                                            \
20563:     type_ *dest = (to_);                                                       \
20563:     (to_)->member_ = nsnull;                                                   \
20563:     for (const type_ *src = (from_)->member_; src; src = src->member_) {       \
20563:       type_ *clone = src->Clone args_;                                         \
20563:       if (!clone) {                                                            \
20563:         delete (to_);                                                          \
20563:         return nsnull;                                                         \
20563:       }                                                                        \
20563:       dest->member_ = clone;                                                   \
20563:       dest = clone;                                                            \
20563:     }                                                                          \
20563:   }
20563: 
    1: enum nsCSSUnit {
    1:   eCSSUnit_Null         = 0,      // (n/a) null unit, value is not specified
    1:   eCSSUnit_Auto         = 1,      // (n/a) value is algorithmic
    1:   eCSSUnit_Inherit      = 2,      // (n/a) value is inherited
    1:   eCSSUnit_Initial      = 3,      // (n/a) value is default UA value
    1:   eCSSUnit_None         = 4,      // (n/a) value is none
    1:   eCSSUnit_Normal       = 5,      // (n/a) value is normal (algorithmic, different than auto)
 2302:   eCSSUnit_System_Font  = 6,      // (n/a) value is -moz-use-system-font
 6734:   eCSSUnit_Dummy        = 7,      // (n/a) a fake but specified value, used
 6734:                                   //       only in temporary values
20106:   eCSSUnit_DummyInherit = 8,      // (n/a) a fake but specified value, used
20106:                                   //       only in temporary values
    1:   eCSSUnit_String       = 10,     // (PRUnichar*) a string value
    1:   eCSSUnit_Attr         = 11,     // (PRUnichar*) a attr(string) value
16545:   eCSSUnit_Local_Font   = 12,     // (PRUnichar*) a local font name
16545:   eCSSUnit_Font_Format  = 13,     // (PRUnichar*) a font format name
    1:   eCSSUnit_Array        = 20,     // (nsCSSValue::Array*) a list of values
    1:   eCSSUnit_Counter      = 21,     // (nsCSSValue::Array*) a counter(string,[string]) value
    1:   eCSSUnit_Counters     = 22,     // (nsCSSValue::Array*) a counters(string,string[,string]) value
19214:   eCSSUnit_Function     = 23,     // (nsCSSValue::Array*) a function with parameters.  First elem of array is name,
19214:                                   //  the rest of the values are arguments.
19214: 
    1:   eCSSUnit_URL          = 30,     // (nsCSSValue::URL*) value
    1:   eCSSUnit_Image        = 31,     // (nsCSSValue::Image*) value
    1:   eCSSUnit_Integer      = 50,     // (int) simple value
    1:   eCSSUnit_Enumerated   = 51,     // (int) value has enumerated meaning
11408:   eCSSUnit_EnumColor    = 80,     // (int) enumerated color (kColorKTable)
11408:   eCSSUnit_Color        = 81,     // (nscolor) an RGBA value
    1:   eCSSUnit_Percent      = 90,     // (float) 1.0 == 100%) value is percentage of something
    1:   eCSSUnit_Number       = 91,     // (float) value is numeric (usually multiplier, different behavior that percent)
    1: 
    1:   // Length units - fixed
    1:   // US English
    1:   eCSSUnit_Inch         = 100,    // (float) 0.0254 meters
    1:   eCSSUnit_Foot         = 101,    // (float) 12 inches
    1:   eCSSUnit_Mile         = 102,    // (float) 5280 feet
    1: 
    1:   // Metric
    1:   eCSSUnit_Millimeter   = 207,    // (float) 1/1000 meter
    1:   eCSSUnit_Centimeter   = 208,    // (float) 1/100 meter
    1:   eCSSUnit_Meter        = 210,    // (float) Standard length
    1:   eCSSUnit_Kilometer    = 213,    // (float) 1000 meters
    1: 
    1:   // US Typographic
    1:   eCSSUnit_Point        = 300,    // (float) 1/72 inch
    1:   eCSSUnit_Pica         = 301,    // (float) 12 points == 1/6 inch
    1: 
    1:   // European Typographic
    1:   eCSSUnit_Didot        = 400,    // (float) 15 didots == 16 points
    1:   eCSSUnit_Cicero       = 401,    // (float) 12 didots
    1: 
    1:   // Length units - relative
    1:   // Font relative measure
    1:   eCSSUnit_EM           = 800,    // (float) == current font size
    1:   eCSSUnit_EN           = 801,    // (float) .5 em
    1:   eCSSUnit_XHeight      = 802,    // (float) distance from top of lower case x to baseline
    1:   eCSSUnit_CapHeight    = 803,    // (float) distance from top of uppercase case H to baseline
    1:   eCSSUnit_Char         = 804,    // (float) number of characters, used for width with monospace font
    1: 
    1:   // Screen relative measure
    1:   eCSSUnit_Pixel        = 900,    // (float) CSS pixel unit
    1: 
    1:   // Angular units
    1:   eCSSUnit_Degree       = 1000,    // (float) 360 per circle
    1:   eCSSUnit_Grad         = 1001,    // (float) 400 per circle
    1:   eCSSUnit_Radian       = 1002,    // (float) 2*pi per circle
    1: 
    1:   // Frequency units
    1:   eCSSUnit_Hertz        = 2000,    // (float) 1/seconds
    1:   eCSSUnit_Kilohertz    = 2001,    // (float) 1000 Hertz
    1: 
    1:   // Time units
    1:   eCSSUnit_Seconds      = 3000,    // (float) Standard time
    1:   eCSSUnit_Milliseconds = 3001     // (float) 1/1000 second
    1: };
    1: 
    1: class nsCSSValue {
    1: public:
    1:   struct Array;
    1:   friend struct Array;
    1: 
    1:   struct URL;
    1:   friend struct URL;
    1: 
    1:   struct Image;
    1:   friend struct Image;
    1:   
    1:   // for valueless units only (null, auto, inherit, none, normal)
    1:   explicit nsCSSValue(nsCSSUnit aUnit = eCSSUnit_Null)
    1:     : mUnit(aUnit)
    1:   {
20106:     NS_ASSERTION(aUnit <= eCSSUnit_DummyInherit, "not a valueless unit");
    1:   }
    1: 
    1:   nsCSSValue(PRInt32 aValue, nsCSSUnit aUnit) NS_HIDDEN;
    1:   nsCSSValue(float aValue, nsCSSUnit aUnit) NS_HIDDEN;
    1:   nsCSSValue(const nsString& aValue, nsCSSUnit aUnit) NS_HIDDEN;
    1:   explicit nsCSSValue(nscolor aValue) NS_HIDDEN;
    1:   nsCSSValue(Array* aArray, nsCSSUnit aUnit) NS_HIDDEN;
    1:   explicit nsCSSValue(URL* aValue) NS_HIDDEN;
    1:   explicit nsCSSValue(Image* aValue) NS_HIDDEN;
    1:   nsCSSValue(const nsCSSValue& aCopy) NS_HIDDEN;
 5368:   ~nsCSSValue() { Reset(); }
    1: 
    1:   NS_HIDDEN_(nsCSSValue&)  operator=(const nsCSSValue& aCopy);
    1:   NS_HIDDEN_(PRBool)      operator==(const nsCSSValue& aOther) const;
    1: 
    1:   PRBool operator!=(const nsCSSValue& aOther) const
    1:   {
    1:     return !(*this == aOther);
    1:   }
    1: 
  731:   nsCSSUnit GetUnit() const { return mUnit; }
    1:   PRBool    IsLengthUnit() const
16545:     { return eCSSUnit_Inch <= mUnit && mUnit <= eCSSUnit_Pixel; }
    1:   PRBool    IsFixedLengthUnit() const  
16545:     { return eCSSUnit_Inch <= mUnit && mUnit <= eCSSUnit_Cicero; }
    1:   PRBool    IsRelativeLengthUnit() const  
16545:     { return eCSSUnit_EM <= mUnit && mUnit <= eCSSUnit_Pixel; }
    1:   PRBool    IsAngularUnit() const  
16545:     { return eCSSUnit_Degree <= mUnit && mUnit <= eCSSUnit_Radian; }
    1:   PRBool    IsFrequencyUnit() const  
16545:     { return eCSSUnit_Hertz <= mUnit && mUnit <= eCSSUnit_Kilohertz; }
    1:   PRBool    IsTimeUnit() const  
16545:     { return eCSSUnit_Seconds <= mUnit && mUnit <= eCSSUnit_Milliseconds; }
16545: 
16545:   PRBool    UnitHasStringValue() const
16545:     { return eCSSUnit_String <= mUnit && mUnit <= eCSSUnit_Font_Format; }
    1: 
    1:   PRInt32 GetIntValue() const
    1:   {
11408:     NS_ASSERTION(mUnit == eCSSUnit_Integer || mUnit == eCSSUnit_Enumerated ||
11408:                  mUnit == eCSSUnit_EnumColor,
    1:                  "not an int value");
    1:     return mValue.mInt;
    1:   }
    1: 
    1:   float GetPercentValue() const
    1:   {
    1:     NS_ASSERTION(mUnit == eCSSUnit_Percent, "not a percent value");
    1:     return mValue.mFloat;
    1:   }
    1: 
    1:   float GetFloatValue() const
    1:   {
    1:     NS_ASSERTION(eCSSUnit_Number <= mUnit, "not a float value");
    1:     return mValue.mFloat;
    1:   }
    1: 
    1:   nsAString& GetStringValue(nsAString& aBuffer) const
    1:   {
16545:     NS_ASSERTION(UnitHasStringValue(), "not a string value");
    1:     aBuffer.Truncate();
    1:     PRUint32 len = NS_strlen(GetBufferValue(mValue.mString));
    1:     mValue.mString->ToString(len, aBuffer);
    1:     return aBuffer;
    1:   }
    1: 
    1:   const PRUnichar* GetStringBufferValue() const
    1:   {
16545:     NS_ASSERTION(UnitHasStringValue(), "not a string value");
    1:     return GetBufferValue(mValue.mString);
    1:   }
    1: 
    1:   nscolor GetColorValue() const
    1:   {
    1:     NS_ASSERTION((mUnit == eCSSUnit_Color), "not a color value");
    1:     return mValue.mColor;
    1:   }
    1: 
    1:   Array* GetArrayValue() const
    1:   {
19214:     NS_ASSERTION(eCSSUnit_Array <= mUnit && mUnit <= eCSSUnit_Function,
    1:                  "not an array value");
    1:     return mValue.mArray;
    1:   }
    1: 
    1:   nsIURI* GetURLValue() const
    1:   {
    1:     NS_ASSERTION(mUnit == eCSSUnit_URL || mUnit == eCSSUnit_Image,
    1:                  "not a URL value");
    1:     return mUnit == eCSSUnit_URL ?
    1:       mValue.mURL->mURI : mValue.mImage->mURI;
    1:   }
    1: 
 3645:   URL* GetURLStructValue() const
 3645:   {
 3645:     // Not allowing this for Image values, because if the caller takes
 3645:     // a ref to them they won't be able to delete them properly.
 3645:     NS_ASSERTION(mUnit == eCSSUnit_URL, "not a URL value");
 3645:     return mValue.mURL;
 3645:   }
 3645: 
    1:   const PRUnichar* GetOriginalURLValue() const
    1:   {
    1:     NS_ASSERTION(mUnit == eCSSUnit_URL || mUnit == eCSSUnit_Image,
    1:                  "not a URL value");
    1:     return GetBufferValue(mUnit == eCSSUnit_URL ?
    1:                             mValue.mURL->mString :
    1:                             mValue.mImage->mString);
    1:   }
    1: 
    1:   // Not making this inline because that would force us to include
    1:   // imgIRequest.h, which leads to REQUIRES hell, since this header is included
    1:   // all over.
    1:   NS_HIDDEN_(imgIRequest*) GetImageValue() const;
    1: 
    1:   NS_HIDDEN_(nscoord)   GetLengthTwips() const;
    1: 
    1:   NS_HIDDEN_(void)  Reset()  // sets to null
    1:   {
 5368:     if (mUnit != eCSSUnit_Null)
 5368:       DoReset();
    1:   }
 5368: private:
 5368:   NS_HIDDEN_(void)  DoReset();
    1: 
 5368: public:
    1:   NS_HIDDEN_(void)  SetIntValue(PRInt32 aValue, nsCSSUnit aUnit);
    1:   NS_HIDDEN_(void)  SetPercentValue(float aValue);
    1:   NS_HIDDEN_(void)  SetFloatValue(float aValue, nsCSSUnit aUnit);
    1:   NS_HIDDEN_(void)  SetStringValue(const nsString& aValue, nsCSSUnit aUnit);
    1:   NS_HIDDEN_(void)  SetColorValue(nscolor aValue);
    1:   NS_HIDDEN_(void)  SetArrayValue(nsCSSValue::Array* aArray, nsCSSUnit aUnit);
    1:   NS_HIDDEN_(void)  SetURLValue(nsCSSValue::URL* aURI);
    1:   NS_HIDDEN_(void)  SetImageValue(nsCSSValue::Image* aImage);
    1:   NS_HIDDEN_(void)  SetAutoValue();
    1:   NS_HIDDEN_(void)  SetInheritValue();
    1:   NS_HIDDEN_(void)  SetInitialValue();
    1:   NS_HIDDEN_(void)  SetNoneValue();
    1:   NS_HIDDEN_(void)  SetNormalValue();
 2302:   NS_HIDDEN_(void)  SetSystemFontValue();
 6734:   NS_HIDDEN_(void)  SetDummyValue();
20106:   NS_HIDDEN_(void)  SetDummyInheritValue();
 3076:   NS_HIDDEN_(void)  StartImageLoad(nsIDocument* aDocument)
    1:                                    const;  // Not really const, but pretending
    1: 
    1:   // Returns an already addrefed buffer.  Can return null on allocation
    1:   // failure.
    1:   static nsStringBuffer* BufferFromString(const nsString& aValue);
    1:   
    1:   struct Array {
    1: 
    1:     // return |Array| with reference count of zero
    1:     static Array* Create(PRUint16 aItemCount) {
    1:       return new (aItemCount) Array(aItemCount);
    1:     }
    1: 
    1:     nsCSSValue& operator[](PRUint16 aIndex) {
    1:       NS_ASSERTION(aIndex < mCount, "out of range");
    1:       return *(First() + aIndex);
    1:     }
    1: 
    1:     const nsCSSValue& operator[](PRUint16 aIndex) const {
    1:       NS_ASSERTION(aIndex < mCount, "out of range");
    1:       return *(First() + aIndex);
    1:     }
    1: 
    1:     nsCSSValue& Item(PRUint16 aIndex) { return (*this)[aIndex]; }
    1:     const nsCSSValue& Item(PRUint16 aIndex) const { return (*this)[aIndex]; }
    1: 
    1:     PRUint16 Count() const { return mCount; }
    1: 
    1:     PRBool operator==(const Array& aOther) const
    1:     {
    1:       if (mCount != aOther.mCount)
    1:         return PR_FALSE;
    1:       for (PRUint16 i = 0; i < mCount; ++i)
    1:         if ((*this)[i] != aOther[i])
    1:           return PR_FALSE;
    1:       return PR_TRUE;
    1:     }
    1: 
    1:     void AddRef() {
15609:       if (mRefCnt == PR_UINT16_MAX) {
15609:         NS_WARNING("refcount overflow, leaking nsCSSValue::Array");
15609:         return;
15609:       }
    1:       ++mRefCnt;
    1:       NS_LOG_ADDREF(this, mRefCnt, "nsCSSValue::Array", sizeof(*this));
    1:     }
    1:     void Release() {
15609:       if (mRefCnt == PR_UINT16_MAX) {
15609:         NS_WARNING("refcount overflow, leaking nsCSSValue::Array");
15609:         return;
15609:       }
    1:       --mRefCnt;
    1:       NS_LOG_RELEASE(this, mRefCnt, "nsCSSValue::Array");
    1:       if (mRefCnt == 0)
    1:         delete this;
    1:     }
    1: 
    1:   private:
    1: 
    1:     PRUint16 mRefCnt;
    1:     PRUint16 mCount;
    1: 
    1:     void* operator new(size_t aSelfSize, PRUint16 aItemCount) CPP_THROW_NEW {
    1:       return ::operator new(aSelfSize + sizeof(nsCSSValue)*aItemCount);
    1:     }
    1: 
    1:     void operator delete(void* aPtr) { ::operator delete(aPtr); }
    1: 
    1:     nsCSSValue* First() {
    1:       return (nsCSSValue*) (((char*)this) + sizeof(*this));
    1:     }
    1: 
    1:     const nsCSSValue* First() const {
    1:       return (const nsCSSValue*) (((const char*)this) + sizeof(*this));
    1:     }
    1: 
    1: #define CSSVALUE_LIST_FOR_VALUES(var)                                         \
    1:   for (nsCSSValue *var = First(), *var##_end = var + mCount;                  \
    1:        var != var##_end; ++var)
    1: 
    1:     Array(PRUint16 aItemCount)
    1:       : mRefCnt(0)
    1:       , mCount(aItemCount)
    1:     {
    1:       MOZ_COUNT_CTOR(nsCSSValue::Array);
    1:       CSSVALUE_LIST_FOR_VALUES(val) {
    1:         new (val) nsCSSValue();
    1:       }
    1:     }
    1: 
    1:     ~Array()
    1:     {
    1:       MOZ_COUNT_DTOR(nsCSSValue::Array);
    1:       CSSVALUE_LIST_FOR_VALUES(val) {
    1:         val->~nsCSSValue();
    1:       }
    1:     }
    1: 
    1: #undef CSSVALUE_LIST_FOR_VALUES
    1: 
    1:   private:
    1:     Array(const Array& aOther); // not to be implemented
    1:   };
    1: 
    1:   struct URL {
 1036:     // Methods are not inline because using an nsIPrincipal means requiring
 1036:     // caps, which leads to REQUIRES hell, since this header is included all
 1036:     // over.    
 1036: 
    1:     // aString must not be null.
 1036:     // aOriginPrincipal must not be null.
 1036:     URL(nsIURI* aURI, nsStringBuffer* aString, nsIURI* aReferrer,
 1036:         nsIPrincipal* aOriginPrincipal) NS_HIDDEN;
    1: 
 1036:     ~URL() NS_HIDDEN;
    1: 
 1036:     NS_HIDDEN_(PRBool) operator==(const URL& aOther) const;
    1: 
 3645:     // URIEquals only compares URIs and principals (unlike operator==, which
 3645:     // also compares the original strings).  URIEquals also assumes that the
 3645:     // mURI member of both URL objects is non-null.  Do NOT call this method
 3645:     // unless you're sure this is the case.
 3645:     NS_HIDDEN_(PRBool) URIEquals(const URL& aOther) const;
 3645: 
    1:     nsCOMPtr<nsIURI> mURI; // null == invalid URL
    1:     nsStringBuffer* mString; // Could use nsRefPtr, but it'd add useless
    1:                              // null-checks; this is never null.
    1:     nsCOMPtr<nsIURI> mReferrer;
 1036:     nsCOMPtr<nsIPrincipal> mOriginPrincipal;
    1: 
    1:     void AddRef() { ++mRefCnt; }
    1:     void Release() { if (--mRefCnt == 0) delete this; }
    1:   protected:
    1:     nsrefcnt mRefCnt;
    1:   };
    1: 
    1:   struct Image : public URL {
    1:     // Not making the constructor and destructor inline because that would
    1:     // force us to include imgIRequest.h, which leads to REQUIRES hell, since
    1:     // this header is included all over.
    1:     // aString must not be null.
    1:     Image(nsIURI* aURI, nsStringBuffer* aString, nsIURI* aReferrer,
 3076:           nsIPrincipal* aOriginPrincipal, nsIDocument* aDocument) NS_HIDDEN;
    1:     ~Image() NS_HIDDEN;
    1: 
    1:     // Inherit operator== from nsCSSValue::URL
    1: 
    1:     nsCOMPtr<imgIRequest> mRequest; // null == image load blocked or somehow failed
    1: 
    1:     // Override AddRef/Release so we delete ourselves via the right pointer.
    1:     void AddRef() { ++mRefCnt; }
    1:     void Release() { if (--mRefCnt == 0) delete this; }
    1:   };
    1: 
    1: private:
    1:   static const PRUnichar* GetBufferValue(nsStringBuffer* aBuffer) {
 3233:     return static_cast<PRUnichar*>(aBuffer->Data());
    1:   }
    1: 
    1: protected:
    1:   nsCSSUnit mUnit;
    1:   union {
    1:     PRInt32    mInt;
    1:     float      mFloat;
    1:     // Note: the capacity of the buffer may exceed the length of the string.
    1:     // If we're of a string type, mString is not null.
    1:     nsStringBuffer* mString;
    1:     nscolor    mColor;
    1:     Array*     mArray;
    1:     URL*       mURL;
    1:     Image*     mImage;
    1:   }         mValue;
    1: };
    1: 
    1: #endif /* nsCSSValue_h___ */
    1: 
