20627: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
20627: /* vim:set ts=2 sw=2 sts=2 et cindent: */
20627: /* ***** BEGIN LICENSE BLOCK *****
20627:  * Version: ML 1.1/GPL 2.0/LGPL 2.1
20627:  *
20627:  * The contents of this file are subject to the Mozilla Public License Version
20627:  * 1.1 (the "License"); you may not use this file except in compliance with
20627:  * the License. You may obtain a copy of the License at
20627:  * http://www.mozilla.org/MPL/
20627:  *
20627:  * Software distributed under the License is distributed on an "AS IS" basis,
20627:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
20627:  * for the specific language governing rights and limitations under the
20627:  * License.
20627:  *
20627:  * The Original Code is Mozilla code.
20627:  *
20627:  * The Initial Developer of the Original Code is the Mozilla Corporation.
20627:  * Portions created by the Initial Developer are Copyright (C) 2007
20627:  * the Initial Developer. All Rights Reserved.
20627:  *
20627:  * Contributor(s):
20627:  *  Chris Double <chris.double@double.co.nz>
20627:  *
20627:  * Alternatively, the contents of this file may be used under the terms of
20627:  * either the GNU General Public License Version 2 or later (the "GPL"), or
20627:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
20627:  * in which case the provisions of the GPL or the LGPL are applicable instead
20627:  * of those above. If you wish to allow use of your version of this file only
20627:  * under the terms of either the GPL or the LGPL, and not to allow others to
20627:  * use your version of this file under the terms of the MPL, indicate your
20627:  * decision by deleting the provisions above and replace them with the notice
20627:  * and other provisions required by the GPL or the LGPL. If you do not delete
20627:  * the provisions above, a recipient may use your version of this file under
20627:  * the terms of any one of the MPL, the GPL or the LGPL.
20627:  *
20627:  * ***** END LICENSE BLOCK ***** */
20627: #if !defined(nsMediaDecoder_h_)
20627: #define nsMediaDecoder_h_
20627: 
20627: #include "nsIObserver.h"
20627: #include "nsIPrincipal.h"
20627: #include "nsSize.h"
20627: #include "prlog.h"
20627: #include "gfxContext.h"
20627: #include "gfxRect.h"
20627: #include "nsITimer.h"
20627: 
20627: #ifdef PR_LOGGING
20627: extern PRLogModuleInfo* gVideoDecoderLog;
20627: #define LOG(type, msg) PR_LOG(gVideoDecoderLog, type, msg)
20627: #else
20627: #define LOG(type, msg)
20627: #endif
20627: 
20627: class nsHTMLMediaElement;
20627: 
20627: // All methods of nsMediaDecoder must be called from the main thread only
20627: // with the exception of SetRGBData. The latter can be called from any thread.
20627: class nsMediaDecoder : public nsIObserver
20627: {
20627:  public:
20627:   nsMediaDecoder();
20627:   virtual ~nsMediaDecoder();
20627: 
20627:   // Initialize the logging object
20627:   static nsresult InitLogger();
20627: 
20627:   // Perform any initialization required for the decoder.
20627:   // Return PR_TRUE on successful initialisation, PR_FALSE
20627:   // on failure.
20627:   virtual PRBool Init();
20627: 
20627:   // Return the current URI being played or downloaded.
20627:   virtual void GetCurrentURI(nsIURI** aURI) = 0;
20627: 
20627:   // Return the principal of the current URI being played or downloaded.
20627:   virtual nsIPrincipal* GetCurrentPrincipal() = 0;
20627: 
20627:   // Return the time position in the video stream being
20627:   // played measured in seconds.
20627:   virtual float GetCurrentTime() = 0;
20627: 
20627:   // Seek to the time position in (seconds) from the start of the video.
20627:   virtual nsresult Seek(float time) = 0;
20627: 
20627:   // Called by the element when the playback rate has been changed.
20627:   // Adjust the speed of the playback, optionally with pitch correction,
20627:   // when this is called.
20627:   virtual nsresult PlaybackRateChanged() = 0;
20627: 
20627:   // Return the duration of the video in seconds.
20627:   virtual float GetDuration() = 0;
20627:   
20627:   // Pause video playback.
20627:   virtual void Pause() = 0;
20627: 
20627:   // Return the current audio volume that the video plays at. 
20627:   // This is a value form 0 through to 1.0.
20627:   virtual float GetVolume() = 0;
20627: 
20627:   // Set the audio volume. It should be a value from 0 to 1.0.
20627:   virtual void SetVolume(float volume) = 0;
20627: 
20627:   // Start playback of a video. 'Load' must have previously been
20627:   // called.
20627:   virtual nsresult Play() = 0;
20627: 
20627:   // Stop playback of a video, and stop download of video stream.
20627:   virtual void Stop() = 0;
20627: 
21079:   // Start downloading the video. Decode the downloaded data up to the
21079:   // point of the first frame of data.
21079:   // Exactly one of aURI and aChannel must be null. aListener must be
21079:   // null if and only if aChannel is.
21079:   virtual nsresult Load(nsIURI* aURI,
21079:                         nsIChannel* aChannel,
21079:                         nsIStreamListener **aListener) = 0;
20627: 
20627:   // Draw the latest video data. This is done
20627:   // here instead of in nsVideoFrame so that the lock around the
20627:   // RGB buffer doesn't have to be exposed publically.
20627:   // The current video frame is drawn to fill aRect.
20627:   // Called in the main thread only.
20627:   virtual void Paint(gfxContext* aContext, const gfxRect& aRect);
20627: 
20627:   // Called when the video file has completed downloading.
20627:   virtual void ResourceLoaded() = 0;
20627: 
21394:   // Called if the media file encounters a network error.
21394:   virtual void NetworkError() = 0;
21394: 
20627:   // Call from any thread safely. Return PR_TRUE if we are currently
20627:   // seeking in the media resource.
20627:   virtual PRBool IsSeeking() const = 0;
20627: 
20627:   // Return the current number of bytes loaded from the video file.
20627:   // This is used for progress events.
20714:   virtual PRUint64 GetBytesLoaded() = 0;
20627: 
20627:   // Return the size of the video file in bytes. Return 0 if the
20627:   // size is unknown or the stream is infinite.
20627:   virtual PRInt64 GetTotalBytes() = 0;
20627: 
20627:   // Set the size of the video file in bytes.
20627:   virtual void SetTotalBytes(PRInt64 aBytes) = 0;
20627: 
21542:   // Set a flag indicating whether seeking is supported
21542:   virtual void SetSeekable(PRBool aSeekable) = 0;
21542: 
21542:   // Return PR_TRUE if seeking is supported.
21542:   virtual PRBool GetSeekable() = 0;
21542: 
20627:   // Called when the HTML DOM element is bound.
20627:   virtual void ElementAvailable(nsHTMLMediaElement* anElement);
20627: 
20627:   // Called when the HTML DOM element is unbound.
20627:   virtual void ElementUnavailable();
20627: 
20627:   // Invalidate the frame.
20627:   virtual void Invalidate();
20627: 
22408:   // Update progress information.
22408:   virtual void Progress();
20627: 
20627:   // Keep track of the number of bytes downloaded
20714:   virtual void UpdateBytesDownloaded(PRUint64 aBytes) = 0;
20627: 
20627:   // Cleanup internal data structures. Must be called on the main
20627:   // thread by the owning object before that object disposes of this object.  
20627:   virtual void Shutdown();
20627: 
20627: protected:
20627: 
20627:   // Start timer to update download progress information.
20627:   nsresult StartProgress();
20627: 
20627:   // Stop progress information timer.
20627:   nsresult StopProgress();
20627: 
20627:   // Set the RGB width, height and framerate. The passed RGB buffer is
20627:   // copied to the mRGB buffer. This also allocates the mRGB buffer if
20627:   // needed.
20627:   // This is the only nsMediaDecoder method that may be called 
20627:   // from threads other than the main thread.
20627:   // It must be called with the mVideoUpdateLock held.
20627:   void SetRGBData(PRInt32 aWidth, 
20627:                   PRInt32 aHeight, 
20627:                   float aFramerate, 
20627:                   unsigned char* aRGBBuffer);
20627: 
20627: protected:
20627:   // Timer used for updating progress events 
20627:   nsCOMPtr<nsITimer> mProgressTimer;
20627: 
20627:   // The element is not reference counted. Instead the decoder is
20627:   // notified when it is able to be used. It should only ever be
20627:   // accessed from the main thread.
20627:   nsHTMLMediaElement* mElement;
20627: 
20627:   // RGB data for last decoded frame of video data.
20627:   // The size of the buffer is mRGBWidth*mRGBHeight*4 bytes and
20627:   // contains bytes in RGBA format.
20627:   nsAutoArrayPtr<unsigned char> mRGB;
20627: 
20627:   PRInt32 mRGBWidth;
20627:   PRInt32 mRGBHeight;
20627: 
20627:   // Has our size changed since the last repaint?
20627:   PRPackedBool mSizeChanged;
20627: 
20627:   // Lock around the video RGB, width and size data. This
20627:   // is used in the decoder backend threads and the main thread
20627:   // to ensure that repainting the video does not use these
20627:   // values while they are out of sync (width changed but
20627:   // not height yet, etc).
20627:   // Backends that are updating the height, width or writing
20627:   // to the RGB buffer must obtain this lock first to ensure that
20627:   // the video element does not use video data or sizes that are
20627:   // in the midst of being changed.
20627:   PRLock* mVideoUpdateLock;
20627: 
20627:   // Framerate of video being displayed in the element
20627:   // expressed in numbers of frames per second.
20627:   float mFramerate;
22529: 
22529:   // True if the decoder is being shutdown. At this point all events that
22529:   // are currently queued need to return immediately to prevent javascript
22529:   // being run that operates on the element and decoder during shutdown.
22529:   // Read/Write from the main thread only.
22529:   PRPackedBool mShuttingDown;
22529: 
22529:   // True if the decoder is currently in the Stop() method. This is used to
22529:   // prevent recursive calls into Stop while it is spinning the event loop
22529:   // waiting for the playback event loop to shutdown. Read/Write from the
22529:   // main thread only.
22529:   PRPackedBool mStopping;
20627: };
20627: 
20627: #endif
