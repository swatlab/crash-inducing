 43113: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 43113: /* vim:set expandtab ts=4 sw=4 sts=4 cin: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 43113: 
 43113: #include "nsHttpChannel.h"
 43113: #include "nsHttpHandler.h"
 93839: #include "nsStandardURL.h"
 43113: #include "nsIApplicationCacheService.h"
 43113: #include "nsIApplicationCacheContainer.h"
 43113: #include "nsIAuthInformation.h"
 99876: #include "nsICryptoHash.h"
 43113: #include "nsIStringBundle.h"
 43113: #include "nsIIDNService.h"
 43113: #include "nsIStreamListenerTee.h"
 43113: #include "nsISeekableStream.h"
 43113: #include "nsMimeTypes.h"
 43113: #include "nsNetUtil.h"
 43113: #include "prprf.h"
 51363: #include "prnetdb.h"
 43113: #include "nsEscape.h"
 43113: #include "nsStreamUtils.h"
 43113: #include "nsIOService.h"
 43113: #include "nsICacheService.h"
 43113: #include "nsDNSPrefetch.h"
 43113: #include "nsChannelClassifier.h"
 49375: #include "nsIRedirectResultListener.h"
 70188: #include "mozilla/TimeStamp.h"
 78633: #include "nsDOMError.h"
 81029: #include "nsAlgorithm.h"
 87692: #include "sampler.h"
 93839: #include "nsIConsoleService.h"
 94799: #include "base/compiler_specific.h"
 96926: #include "NullHttpTransaction.h"
101868: #include "mozilla/Attributes.h"
 81029: 
 99874: namespace mozilla { namespace net {
 99874:  
 99874: namespace {
 43113: 
 79877: // Device IDs for various cache types
 79877: const char kDiskDeviceID[] = "disk";
 79877: const char kMemoryDeviceID[] = "memory";
 79877: const char kOfflineDeviceID[] = "offline";
 79877: 
 43113: // True if the local cache should be bypassed when processing a request.
 43113: #define BYPASS_LOCAL_CACHE(loadFlags) \
 43113:         (loadFlags & (nsIRequest::LOAD_BYPASS_CACHE | \
 43113:                       nsICachingChannel::LOAD_BYPASS_LOCAL_CACHE))
 43113: 
 43113: static NS_DEFINE_CID(kStreamListenerTeeCID, NS_STREAMLISTENERTEE_CID);
 99879: static NS_DEFINE_CID(kStreamTransportServiceCID,
 99879:                      NS_STREAMTRANSPORTSERVICE_CID);
 99879: 
 99880: const mozilla::Telemetry::ID UNKNOWN_DEVICE
 99880:     = static_cast<mozilla::Telemetry::ID>(0);
 99880: void
 99880: AccumulateCacheHitTelemetry(mozilla::Telemetry::ID deviceHistogram,
 99880:                             PRUint32 hitOrMiss)
 99880: {
 99880:     mozilla::Telemetry::Accumulate(
102655:             mozilla::Telemetry::HTTP_CACHE_DISPOSITION_2, hitOrMiss);
 99880:     if (deviceHistogram != UNKNOWN_DEVICE) {
 99880:         mozilla::Telemetry::Accumulate(deviceHistogram, hitOrMiss);
 99880:     }
 99880: }
 99880: 
 99879: const char *
 99879: GetCacheSessionNameForStoragePolicy(nsCacheStoragePolicy storagePolicy,
 99879:                                     bool isPrivate)
 99879: {
 99879:     MOZ_ASSERT(!isPrivate || storagePolicy == nsICache::STORE_IN_MEMORY);
 99879: 
 99879:     switch (storagePolicy) {
 99879:     case nsICache::STORE_IN_MEMORY:
 99879:         return isPrivate ? "HTTP-memory-only-PB" : "HTTP-memory-only";
 99879:     case nsICache::STORE_OFFLINE:
 99879:         return "HTTP-offline";
 99879:     default:
 99879:         return "HTTP";
 99879:     }
 99879: }
 43113: 
 99876: // Computes and returns a SHA1 hash of the input buffer. The input buffer
 99876: // must be a null-terminated string.
 99876: nsresult
 99876: Hash(const char *buf, nsACString &hash)
 99876: {
 99876:     nsresult rv;
 99876:       
 99876:     nsCOMPtr<nsICryptoHash> hasher
 99876:       = do_CreateInstance(NS_CRYPTO_HASH_CONTRACTID, &rv);
 99876:     NS_ENSURE_SUCCESS(rv, rv);
 99876: 
 99876:     rv = hasher->Init(nsICryptoHash::SHA1);
 99876:     NS_ENSURE_SUCCESS(rv, rv);
 99876: 
 99876:     rv = hasher->Update(reinterpret_cast<unsigned const char*>(buf),
 99876:                          strlen(buf));
 99876:     NS_ENSURE_SUCCESS(rv, rv);
 99876: 
 99876:     rv = hasher->Finish(true, hash);
 99876:     NS_ENSURE_SUCCESS(rv, rv);
 99876: 
 99876:     return NS_OK;
 99876: }
 99876: 
 99874: bool IsRedirectStatus(PRUint32 status)
 99874: {
 99874:     // 305 disabled as a security measure (see bug 187996).
 99874:     return status == 300 || status == 301 || status == 302 || status == 303 ||
 99874:            status == 307 || status == 308;
 99874: }
 99874: 
 99874: // We only treat 3xx responses as redirects if they have a Location header and
 99874: // the status code is in a whitelist.
 99874: bool
 99874: WillRedirect(const nsHttpResponseHead * response)
 99874: {
 99874:     return IsRedirectStatus(response->Status()) &&
 99874:            response->PeekHeader(nsHttp::Location);
 99874: }
 99874: 
 99874: void
 99874: MaybeMarkCacheEntryValid(const void * channel,
 99874:                          nsICacheEntryDescriptor * cacheEntry,
 99874:                          nsCacheAccessMode cacheAccess)
 99874: {
 99874:     // Mark the cache entry as valid in order to allow others access to it.
 99874:     // XXX: Is it really necessary to check for write acccess to the entry?
 99874:     if (cacheAccess & nsICache::ACCESS_WRITE) {
 99874:         nsresult rv = cacheEntry->MarkValid();
 99874:         LOG(("Marking cache entry valid "
 99874:              "[channel=%p, entry=%p, access=%d, result=%d]",
 99874:              channel, cacheEntry, PRIntn(cacheAccess), PRIntn(rv)));
 99874:     } else {
 99874:         LOG(("Not marking read-only cache entry valid "
 99874:              "[channel=%p, entry=%p, access=%d]", 
 99874:              channel, cacheEntry, PRIntn(cacheAccess)));
 99874:     }
 99874: }
 99874: 
 99874: } // unnamed namespace
 99874: 
 49375: class AutoRedirectVetoNotifier
 49375: {
 49375: public:
 49375:     AutoRedirectVetoNotifier(nsHttpChannel* channel) : mChannel(channel) {}
 49375:     ~AutoRedirectVetoNotifier() {ReportRedirectResult(false);}
 49375:     void RedirectSucceeded() {ReportRedirectResult(true);}
 49375: 
 49375: private:
 49375:     nsHttpChannel* mChannel;
 49375:     void ReportRedirectResult(bool succeeded);
 49375: };
 49375: 
 49375: void
 49375: AutoRedirectVetoNotifier::ReportRedirectResult(bool succeeded)
 49375: {
 49375:     if (!mChannel)
 49375:         return;
 49375: 
 51363:     mChannel->mRedirectChannel = nsnull;
 51363: 
 49375:     nsCOMPtr<nsIRedirectResultListener> vetoHook;
 49375:     NS_QueryNotificationCallbacks(mChannel, 
 49375:                                   NS_GET_IID(nsIRedirectResultListener), 
 49375:                                   getter_AddRefs(vetoHook));
 49375:     mChannel = nsnull;
 49375:     if (vetoHook)
 49375:         vetoHook->OnRedirectResult(succeeded);
 49375: }
 49375: 
 99879: class HttpCacheQuery : public nsRunnable, public nsICacheListener
 99878: {
 99878: public:
 99878:     HttpCacheQuery(nsHttpChannel * channel,
 99879:                    const nsACString & clientID,
 99879:                    nsCacheStoragePolicy storagePolicy,
 99879:                    bool usingPrivateBrowsing,
 99878:                    const nsACString & cacheKey,
 99879:                    nsCacheAccessMode accessToRequest,
 99879:                    bool noWait,
 99878:                    bool usingSSL,
 99878:                    bool loadedFromApplicationCache)
 99878:         // in
 99878:         : mChannel(channel)
 99879:         , mHasQueryString(HasQueryString(channel->mRequestHead.Method(),
 99879:                                          channel->mURI))
 99878:         , mLoadFlags(channel->mLoadFlags)
 99878:         , mCacheForOfflineUse(channel->mCacheForOfflineUse)
 99878:         , mFallbackChannel(channel->mFallbackChannel)
 99879:         , mClientID(clientID)
 99879:         , mStoragePolicy(storagePolicy)
 99879:         , mUsingPrivateBrowsing(usingPrivateBrowsing)
 99878:         , mCacheKey(cacheKey)
 99879:         , mAccessToRequest(accessToRequest)
 99879:         , mNoWait(noWait)
 99878:         , mUsingSSL(usingSSL)
 99878:         , mLoadedFromApplicationCache(loadedFromApplicationCache)
 99878:         // internal
 99878:         , mCacheAccess(0)
 99878:         , mStatus(NS_ERROR_NOT_INITIALIZED)
 99882:         , mRunCount(0)
 99878:         // in/out
 99878:         , mRequestHead(channel->mRequestHead)
 99878:         , mRedirectedCachekeys(channel->mRedirectedCachekeys.forget())
 99878:         // out
 99878:         , mCachedContentIsValid(false)
 99878:         , mCachedContentIsPartial(false)
 99878:         , mCustomConditionalRequest(false)
 99878:         , mDidReval(false)
 99880:         , mCacheEntryDeviceTelemetryID(UNKNOWN_DEVICE)
 99878:     {
 99878:         MOZ_ASSERT(NS_IsMainThread());
 99878:     }
 99878: 
 99879:     nsresult Dispatch();
 99879: 
 99878: private:
 99879:     NS_DECL_ISUPPORTS_INHERITED
 99879:     NS_DECL_NSIRUNNABLE
 99878:     NS_DECL_NSICACHELISTENER
 99878: 
 99879:     MOZ_ALWAYS_INLINE void AssertOnCacheThread() const
 99879:     {
 99879:         MOZ_ASSERT(mCacheThread);
 99879: #ifdef DEBUG
 99879:         bool onCacheThread;
 99879:         nsresult rv = mCacheThread->IsOnCurrentThread(&onCacheThread);
 99879:         MOZ_ASSERT(NS_SUCCEEDED(rv));
 99879:         MOZ_ASSERT(onCacheThread);
 99879: #endif
 99879:     }
 99879: 
 99879:     static bool HasQueryString(nsHttpAtom method, nsIURI * uri);
 99878:     nsresult CheckCache();
 99878:     bool ResponseWouldVary() const;
 99878:     bool MustValidateBasedOnQueryUrl() const;
 99878:     nsresult SetupByteRangeRequest(PRUint32 partialLen);
103136:     nsresult OpenCacheInputStream(bool startBuffering);
 99878: 
 99878:     nsCOMPtr<nsICacheListener> mChannel;
 99879:     const bool mHasQueryString;
 99878:     const PRUint32 mLoadFlags;
 99878:     const bool mCacheForOfflineUse;
 99878:     const bool mFallbackChannel;
 99879:     const InfallableCopyCString mClientID;
 99879:     const nsCacheStoragePolicy mStoragePolicy;
 99879:     const bool mUsingPrivateBrowsing;
 99878:     const InfallableCopyCString mCacheKey;
 99879:     const nsCacheAccessMode mAccessToRequest;
 99879:     const bool mNoWait;
 99878:     const bool mUsingSSL;
 99878:     const bool mLoadedFromApplicationCache;
 99878: 
 99878:     // Used only internally 
 99879:     nsCOMPtr<nsIEventTarget> mCacheThread;
 99878:     nsCOMPtr<nsICacheEntryDescriptor> mCacheEntry;
 99878:     nsCacheAccessMode mCacheAccess;
 99878:     nsresult mStatus;
 99882:     PRUint32 mRunCount;
 99878: 
 99878:     // Copied from HttpcacheQuery into nsHttpChannel by nsHttpChannel
 99878:     friend class nsHttpChannel;
 99878:     /*in/out*/ nsHttpRequestHead mRequestHead;
 99878:     /*in/out*/ nsAutoPtr<nsTArray<nsCString> > mRedirectedCachekeys;
103136:     /*out*/ AutoClose<nsIInputStream> mCacheInputStream;
 99878:     /*out*/ nsAutoPtr<nsHttpResponseHead> mCachedResponseHead;
 99878:     /*out*/ nsCOMPtr<nsISupports> mCachedSecurityInfo;
 99878:     /*out*/ bool mCachedContentIsValid;
 99878:     /*out*/ bool mCachedContentIsPartial;
 99878:     /*out*/ bool mCustomConditionalRequest;
 99878:     /*out*/ bool mDidReval;
 99880:     /*out*/ mozilla::Telemetry::ID mCacheEntryDeviceTelemetryID;
 99878: };
 99878: 
 99879: NS_IMPL_ISUPPORTS_INHERITED1(HttpCacheQuery, nsRunnable, nsICacheListener)
 99878: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpChannel <public>
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: nsHttpChannel::nsHttpChannel()
 94799:     : ALLOW_THIS_IN_INITIALIZER_LIST(HttpAsyncAborter<nsHttpChannel>(this))
 71646:     , mLogicalOffset(0)
 43113:     , mCacheAccess(0)
 99880:     , mCacheEntryDeviceTelemetryID(UNKNOWN_DEVICE)
 43113:     , mPostID(0)
 43113:     , mRequestTime(0)
 53987:     , mOnCacheEntryAvailableCallback(nsnull)
103134:     , mOfflineCacheAccess(0)
103134:     , mOfflineCacheLastModifiedTime(0)
 80486:     , mCachedContentIsValid(false)
 80486:     , mCachedContentIsPartial(false)
 80486:     , mTransactionReplaced(false)
 80486:     , mAuthRetryPending(false)
 80486:     , mResuming(false)
 80486:     , mInitedCacheEntry(false)
 80486:     , mCacheForOfflineUse(false)
 80486:     , mFallbackChannel(false)
 80486:     , mCustomConditionalRequest(false)
 80486:     , mFallingBack(false)
 80486:     , mWaitingForRedirectCallback(false)
 80486:     , mRequestTimeInitialized(false)
 78427:     , mDidReval(false)
 43113: {
 43113:     LOG(("Creating nsHttpChannel [this=%p]\n", this));
 70188:     mChannelCreationTime = PR_Now();
 70188:     mChannelCreationTimestamp = mozilla::TimeStamp::Now();
 43113: }
 43113: 
 43113: nsHttpChannel::~nsHttpChannel()
 43113: {
 43113:     LOG(("Destroying nsHttpChannel [this=%p]\n", this));
 43113: 
 46930:     if (mAuthProvider)
 46930:         mAuthProvider->Disconnect(NS_ERROR_ABORT);
 43113: }
 43113: 
 43113: nsresult
 43113: nsHttpChannel::Init(nsIURI *uri,
 43113:                     PRUint8 caps,
 43113:                     nsProxyInfo *proxyInfo)
 43113: {
 46909:     nsresult rv = HttpBaseChannel::Init(uri, caps, proxyInfo);
 43113:     if (NS_FAILED(rv))
 43113:         return rv;
 43113: 
 46909:     LOG(("nsHttpChannel::Init [this=%p]\n", this));
 43832: 
 43832:     mAuthProvider =
 43832:         do_CreateInstance("@mozilla.org/network/http-channel-auth-provider;1",
 43832:                           &rv);
 46909:     if (NS_FAILED(rv))
 46909:         return rv;
 43832:     rv = mAuthProvider->Init(this);
 43113: 
 43113:     return rv;
 43113: }
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpChannel <private>
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: nsresult
 99870: nsHttpChannel::Connect()
 43113: {
 43113:     nsresult rv;
 43113: 
 43113:     LOG(("nsHttpChannel::Connect [this=%p]\n", this));
 43113: 
 51363:     // Even if we're in private browsing mode, we still enforce existing STS
 51363:     // data (it is read-only).
 51363:     // if the connection is not using SSL and either the exact host matches or
 51363:     // a superdomain wants to force HTTPS, do it.
 79445:     bool usingSSL = false;
 51363:     rv = mURI->SchemeIs("https", &usingSSL);
 51363:     NS_ENSURE_SUCCESS(rv,rv);
 51363: 
 51363:     if (!usingSSL) {
 51363:         // enforce Strict-Transport-Security
 51363:         nsIStrictTransportSecurityService* stss = gHttpHandler->GetSTSService();
 51363:         NS_ENSURE_TRUE(stss, NS_ERROR_OUT_OF_MEMORY);
 51363: 
 79445:         bool isStsHost = false;
 51363:         rv = stss->IsStsURI(mURI, &isStsHost);
 52258: 
 52258:         // if STS fails, there's no reason to cancel the load, but it's
 52258:         // worrisome.
 52258:         NS_ASSERTION(NS_SUCCEEDED(rv),
 52258:                      "Something is wrong with STS: IsStsURI failed.");
 52258: 
 52258:         if (NS_SUCCEEDED(rv) && isStsHost) {
 51363:             LOG(("nsHttpChannel::Connect() STS permissions found\n"));
 51363:             return AsyncCall(&nsHttpChannel::HandleAsyncRedirectChannelToHttps);
 51363:         }
 84549: 
 84549:         // Check for a previous SPDY Alternate-Protocol directive
 84549:         if (gHttpHandler->IsSpdyEnabled() && mAllowSpdy) {
 84549:             nsCAutoString hostPort;
 84549: 
 84549:             if (NS_SUCCEEDED(mURI->GetHostPort(hostPort)) &&
 84549:                 gHttpHandler->ConnMgr()->GetSpdyAlternateProtocol(hostPort)) {
 84549:                 LOG(("nsHttpChannel::Connect() Alternate-Protocol found\n"));
 84549:                 return AsyncCall(
 84549:                     &nsHttpChannel::HandleAsyncRedirectChannelToHttps);
 84549:             }
 84549:         }
 51363:     }
 51363: 
 43113:     // ensure that we are using a valid hostname
 43113:     if (!net_IsValidHostName(nsDependentCString(mConnectionInfo->Host())))
 43113:         return NS_ERROR_UNKNOWN_HOST;
 43113: 
 96926:     // Consider opening a TCP connection right away
 96926:     SpeculativeConnect();
 96926: 
 43113:     // are we offline?
 79445:     bool offline = gIOService->IsOffline();
 43113:     if (offline)
 43113:         mLoadFlags |= LOAD_ONLY_FROM_CACHE;
 43113:     else if (PL_strcmp(mConnectionInfo->ProxyType(), "unknown") == 0)
 43113:         return ResolveProxy();  // Lazily resolve proxy info
 43113: 
 43113:     // Don't allow resuming when cache must be used
 43113:     if (mResuming && (mLoadFlags & LOAD_ONLY_FROM_CACHE)) {
 43113:         LOG(("Resuming from cache is not supported yet"));
 43113:         return NS_ERROR_DOCUMENT_NOT_CACHED;
 43113:     }
 43113: 
 99879:     if (!gHttpHandler->UseCache())
 99879:         return ContinueConnect();
 99879: 
 43113:     // open a cache entry for this channel...
 99878:     rv = OpenCacheEntry(usingSSL);
 43113: 
 93830:     // do not continue if asyncOpenCacheEntry is in progress
 93830:     if (mOnCacheEntryAvailableCallback) {
 93830:         NS_ASSERTION(NS_SUCCEEDED(rv), "Unexpected state");
 93830:         return NS_OK;
 93830:     }
 93830: 
 43113:     if (NS_FAILED(rv)) {
 43113:         LOG(("OpenCacheEntry failed [rv=%x]\n", rv));
 43113:         // if this channel is only allowed to pull from the cache, then
 43113:         // we must fail if we were unable to open a cache entry.
 43113:         if (mLoadFlags & LOAD_ONLY_FROM_CACHE) {
 43113:             // If we have a fallback URI (and we're not already
 43113:             // falling back), process the fallback asynchronously.
 43113:             if (!mFallbackChannel && !mFallbackKey.IsEmpty()) {
 43113:                 return AsyncCall(&nsHttpChannel::HandleAsyncFallback);
 43113:             }
 43113:             return NS_ERROR_DOCUMENT_NOT_CACHED;
 43113:         }
 43113:         // otherwise, let's just proceed without using the cache.
 43113:     }
 43113: 
 43113:     // if cacheForOfflineUse has been set, open up an offline cache
 43113:     // entry to update
 43113:     if (mCacheForOfflineUse) {
 43113:         rv = OpenOfflineCacheEntryForWriting();
 43113:         if (NS_FAILED(rv)) return rv;
 93830: 
 93830:         if (mOnCacheEntryAvailableCallback)
 43113:             return NS_OK;
 43113:     }
 99870: 
 99870:     return ContinueConnect();
 99870: }
 99870: 
 99870: nsresult
 99870: nsHttpChannel::ContinueConnect()
 99870: {
 43113:     // we may or may not have a cache entry at this point
 43113:     if (mCacheEntry) {
 43113:         // read straight from the cache if possible...
 43113:         if (mCachedContentIsValid) {
 43113:             nsRunnableMethod<nsHttpChannel> *event = nsnull;
 43113:             if (!mCachedContentIsPartial) {
 43113:                 AsyncCall(&nsHttpChannel::AsyncOnExamineCachedResponse, &event);
 43113:             }
 99878:             nsresult rv = ReadFromCache(true);
 43113:             if (NS_FAILED(rv) && event) {
 43113:                 event->Revoke();
 43113:             }
 99880: 
 99880:             AccumulateCacheHitTelemetry(mCacheEntryDeviceTelemetryID,
 79877:                                         kCacheHit);
 99880: 
 43113:             return rv;
 43113:         }
 43113:         else if (mLoadFlags & LOAD_ONLY_FROM_CACHE) {
 43113:             // the cache contains the requested resource, but it must be 
 43113:             // validated before we can reuse it.  since we are not allowed
 43113:             // to hit the net, there's nothing more to do.  the document
 43113:             // is effectively not in the cache.
 43113:             return NS_ERROR_DOCUMENT_NOT_CACHED;
 43113:         }
 43113:     }
 53987:     else if (mLoadFlags & LOAD_ONLY_FROM_CACHE) {
 53987:         // If we have a fallback URI (and we're not already
 53987:         // falling back), process the fallback asynchronously.
 53987:         if (!mFallbackChannel && !mFallbackKey.IsEmpty()) {
 53987:             return AsyncCall(&nsHttpChannel::HandleAsyncFallback);
 53987:         }
 53987:         return NS_ERROR_DOCUMENT_NOT_CACHED;
 53987:     }
 43113: 
 43113:     if (mLoadFlags & LOAD_NO_NETWORK_IO) {
 43113:         return NS_ERROR_DOCUMENT_NOT_CACHED;
 43113:     }
 43113: 
 43113:     // hit the net...
 99870:     nsresult rv = SetupTransaction();
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     rv = gHttpHandler->InitiateTransaction(mTransaction, mPriority);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 53987:     rv = mTransactionPump->AsyncRead(this, nsnull);
 53987:     if (NS_FAILED(rv)) return rv;
 53987: 
 53987:     PRUint32 suspendCount = mSuspendCount;
 53987:     while (suspendCount--)
 53987:         mTransactionPump->Suspend();
 53987: 
 53987:     return NS_OK;
 43113: }
 43113: 
 71646: void
 96926: nsHttpChannel::SpeculativeConnect()
 96926: {
 96926:     // Before we take the latency hit of dealing with the cache, try and
 96926:     // get the TCP (and SSL) handshakes going so they can overlap.
 96926: 
 96926:     // don't speculate on uses of the offline application cache or if
 96926:     // we are actually offline
 96926:     if (mApplicationCache || gIOService->IsOffline())
 96926:         return;
 96926: 
 98076:     // LOAD_ONLY_FROM_CACHE and LOAD_NO_NETWORK_IO must not hit network.
 98076:     // LOAD_FROM_CACHE and LOAD_CHECK_OFFLINE_CACHE are unlikely to hit network,
 98076:     // so skip preconnects for them.
 96926:     if (mLoadFlags & (LOAD_ONLY_FROM_CACHE | LOAD_FROM_CACHE |
 96926:                       LOAD_NO_NETWORK_IO | LOAD_CHECK_OFFLINE_CACHE))
 96926:         return;
 96926:     
 96926:     nsCOMPtr<nsIInterfaceRequestor> callbacks;
 96926:     NS_NewNotificationCallbacksAggregation(mCallbacks, mLoadGroup,
 96926:                                            getter_AddRefs(callbacks));
 96926:     if (!callbacks)
 96926:         return;
 96926: 
 96926:     mConnectionInfo->SetAnonymous((mLoadFlags & LOAD_ANONYMOUS) != 0);
 99692:     mConnectionInfo->SetPrivate(UsingPrivateBrowsing());
 96926:     gHttpHandler->SpeculativeConnect(mConnectionInfo,
 96926:                                      callbacks, NS_GetCurrentThread());
 96926: }
 96926: 
 96926: void
 71646: nsHttpChannel::DoNotifyListenerCleanup()
 69869: {
 63794:     // We don't need this info anymore
 63794:     CleanRedirectCacheChainIfNecessary();
 43113: }
 43113: 
 43113: void
 43113: nsHttpChannel::HandleAsyncRedirect()
 43113: {
 71646:     NS_PRECONDITION(!mCallOnResume, "How did that happen?");
 43113:     
 43113:     if (mSuspendCount) {
 43113:         LOG(("Waiting until resume to do async redirect [this=%p]\n", this));
 71646:         mCallOnResume = &nsHttpChannel::HandleAsyncRedirect;
 43113:         return;
 43113:     }
 43113: 
 43113:     nsresult rv = NS_OK;
 43113: 
 43113:     LOG(("nsHttpChannel::HandleAsyncRedirect [this=%p]\n", this));
 43113: 
 43113:     // since this event is handled asynchronously, it is possible that this
 43113:     // channel could have been canceled, in which case there would be no point
 43113:     // in processing the redirect.
 43113:     if (NS_SUCCEEDED(mStatus)) {
 48304:         PushRedirectAsyncFunc(&nsHttpChannel::ContinueHandleAsyncRedirect);
 48304:         rv = AsyncProcessRedirection(mResponseHead->Status());
 43113:         if (NS_FAILED(rv)) {
 48304:             PopRedirectAsyncFunc(&nsHttpChannel::ContinueHandleAsyncRedirect);
101254:             // TODO: if !DoNotRender3xxBody(), render redirect body instead.
101254:             // But first we need to cache 3xx bodies (bug 748510)
 48304:             ContinueHandleAsyncRedirect(rv);
 48304:         }
 48304:     }
 48304:     else {
 48304:         ContinueHandleAsyncRedirect(NS_OK);
 48304:     }
 48304: }
 48304: 
 48304: nsresult
 48304: nsHttpChannel::ContinueHandleAsyncRedirect(nsresult rv)
 48304: {
 48304:     if (NS_FAILED(rv)) {
 48304:         // If AsyncProcessRedirection fails, then we have to send out the
 43113:         // OnStart/OnStop notifications.
 48304:         LOG(("ContinueHandleAsyncRedirect got failure result [rv=%x]\n", rv));
 43113:         mStatus = rv;
 43113:         DoNotifyListener();
 43113:     }
 43113: 
 43113:     // close the cache entry.  Blow it away if we couldn't process the redirect
 43113:     // for some reason (the cache entry might be corrupt).
 43113:     if (mCacheEntry) {
 43113:         if (NS_FAILED(rv))
 43113:             mCacheEntry->Doom();
 99879:     }
 80486:     CloseCacheEntry(false);
 80486: 
 80486:     mIsPending = false;
 43113: 
 43113:     if (mLoadGroup)
 43113:         mLoadGroup->RemoveRequest(this, nsnull, mStatus);
 48304: 
 48304:     return NS_OK;
 43113: }
 43113: 
 43113: void
 43113: nsHttpChannel::HandleAsyncNotModified()
 43113: {
 71646:     NS_PRECONDITION(!mCallOnResume, "How did that happen?");
 43113:     
 43113:     if (mSuspendCount) {
 43113:         LOG(("Waiting until resume to do async not-modified [this=%p]\n",
 43113:              this));
 71646:         mCallOnResume = &nsHttpChannel::HandleAsyncNotModified;
 43113:         return;
 43113:     }
 43113:     
 43113:     LOG(("nsHttpChannel::HandleAsyncNotModified [this=%p]\n", this));
 43113: 
 43113:     DoNotifyListener();
 43113: 
 80486:     CloseCacheEntry(true);
 80486: 
 80486:     mIsPending = false;
 43113: 
 43113:     if (mLoadGroup)
 43113:         mLoadGroup->RemoveRequest(this, nsnull, mStatus);
 43113: }
 43113: 
 43113: void
 43113: nsHttpChannel::HandleAsyncFallback()
 43113: {
 71646:     NS_PRECONDITION(!mCallOnResume, "How did that happen?");
 43113: 
 43113:     if (mSuspendCount) {
 43113:         LOG(("Waiting until resume to do async fallback [this=%p]\n", this));
 71646:         mCallOnResume = &nsHttpChannel::HandleAsyncFallback;
 43113:         return;
 43113:     }
 43113: 
 43113:     nsresult rv = NS_OK;
 43113: 
 43113:     LOG(("nsHttpChannel::HandleAsyncFallback [this=%p]\n", this));
 43113: 
 43113:     // since this event is handled asynchronously, it is possible that this
 43113:     // channel could have been canceled, in which case there would be no point
 43113:     // in processing the fallback.
 43113:     if (!mCanceled) {
 48304:         PushRedirectAsyncFunc(&nsHttpChannel::ContinueHandleAsyncFallback);
 79445:         bool waitingForRedirectCallback;
 48304:         rv = ProcessFallback(&waitingForRedirectCallback);
 48304:         if (waitingForRedirectCallback)
 48304:             return;
 48304:         PopRedirectAsyncFunc(&nsHttpChannel::ContinueHandleAsyncFallback);
 48304:     }
 48304: 
 48304:     ContinueHandleAsyncFallback(rv);
 48304: }
 48304: 
 48304: nsresult
 48304: nsHttpChannel::ContinueHandleAsyncFallback(nsresult rv)
 48304: {
 48304:     if (!mCanceled && (NS_FAILED(rv) || !mFallingBack)) {
 43113:         // If ProcessFallback fails, then we have to send out the
 43113:         // OnStart/OnStop notifications.
 48304:         LOG(("ProcessFallback failed [rv=%x, %d]\n", rv, mFallingBack));
 43113:         mStatus = NS_FAILED(rv) ? rv : NS_ERROR_DOCUMENT_NOT_CACHED;
 43113:         DoNotifyListener();
 43113:     }
 43113: 
 80486:     mIsPending = false;
 43113: 
 43113:     if (mLoadGroup)
 43113:         mLoadGroup->RemoveRequest(this, nsnull, mStatus);
 48304: 
 48304:     return rv;
 43113: }
 43113: 
 43113: nsresult
 43113: nsHttpChannel::SetupTransaction()
 43113: {
 43113:     LOG(("nsHttpChannel::SetupTransaction [this=%p]\n", this));
 43113: 
 43113:     NS_ENSURE_TRUE(!mTransaction, NS_ERROR_ALREADY_INITIALIZED);
 43113: 
 43113:     nsresult rv;
 43113: 
 43113:     if (mCaps & NS_HTTP_ALLOW_PIPELINING) {
 43113:         //
 43113:         // disable pipelining if:
 93840:         //   (1) pipelining has been disabled by config
 93840:         //   (2) pipelining has been disabled by connection mgr info
 93840:         //   (3) request corresponds to a top-level document load (link click)
 93840:         //   (4) request method is non-idempotent
 93840:         //   (5) request is marked slow (e.g XHR)
 43113:         //
 93840:         if (!mAllowPipelining ||
 93840:            (mLoadFlags & (LOAD_INITIAL_DOCUMENT_URI | INHIBIT_PIPELINE)) ||
 43113:             !(mRequestHead.Method() == nsHttp::Get ||
 43113:               mRequestHead.Method() == nsHttp::Head ||
 93840:               mRequestHead.Method() == nsHttp::Options ||
 43113:               mRequestHead.Method() == nsHttp::Propfind ||
 43113:               mRequestHead.Method() == nsHttp::Proppatch)) {
 43113:             LOG(("  pipelining disallowed\n"));
 43113:             mCaps &= ~NS_HTTP_ALLOW_PIPELINING;
 43113:         }
 43113:     }
 43113: 
 84549:     if (!mAllowSpdy)
 84549:         mCaps |= NS_HTTP_DISALLOW_SPDY;
 84549: 
102885:     // use the URI path if not proxying (transparent proxying such as SSL proxy
102885:     // does not count here). also, figure out what version we should be speaking.
 43113:     nsCAutoString buf, path;
 43113:     nsCString* requestURI;
102295:     if (mConnectionInfo->UsingConnect() ||
 69816:         !mConnectionInfo->UsingHttpProxy()) {
 43113:         rv = mURI->GetPath(path);
 43113:         if (NS_FAILED(rv)) return rv;
 43113:         // path may contain UTF-8 characters, so ensure that they're escaped.
 43113:         if (NS_EscapeURL(path.get(), path.Length(), esc_OnlyNonASCII, buf))
 43113:             requestURI = &buf;
 43113:         else
 43113:             requestURI = &path;
 43113:         mRequestHead.SetVersion(gHttpHandler->HttpVersion());
 43113:     }
 43113:     else {
 43113:         rv = mURI->GetUserPass(buf);
 43113:         if (NS_FAILED(rv)) return rv;
 43113:         if (!buf.IsEmpty() && ((strncmp(mSpec.get(), "http:", 5) == 0) ||
 43113:                                 strncmp(mSpec.get(), "https:", 6) == 0)) {
 43113:             nsCOMPtr<nsIURI> tempURI;
 43113:             rv = mURI->Clone(getter_AddRefs(tempURI));
 43113:             if (NS_FAILED(rv)) return rv;
 43113:             rv = tempURI->SetUserPass(EmptyCString());
 43113:             if (NS_FAILED(rv)) return rv;
 43113:             rv = tempURI->GetAsciiSpec(path);
 43113:             if (NS_FAILED(rv)) return rv;
 43113:             requestURI = &path;
 43113:         }
 43113:         else
 43113:             requestURI = &mSpec;
 43113:         mRequestHead.SetVersion(gHttpHandler->ProxyHttpVersion());
 43113:     }
 43113: 
 43113:     // trim off the #ref portion if any...
 43113:     PRInt32 ref = requestURI->FindChar('#');
 43113:     if (ref != kNotFound)
 43113:         requestURI->SetLength(ref);
 43113: 
 43113:     mRequestHead.SetRequestURI(*requestURI);
 43113: 
 43113:     // set the request time for cache expiration calculations
 43113:     mRequestTime = NowInSeconds();
 80486:     mRequestTimeInitialized = true;
 43113: 
 43113:     // if doing a reload, force end-to-end
 43113:     if (mLoadFlags & LOAD_BYPASS_CACHE) {
 43113:         // We need to send 'Pragma:no-cache' to inhibit proxy caching even if
 43113:         // no proxy is configured since we might be talking with a transparent
 43113:         // proxy, i.e. one that operates at the network level.  See bug #14772.
 80486:         mRequestHead.SetHeader(nsHttp::Pragma, NS_LITERAL_CSTRING("no-cache"), true);
 43113:         // If we're configured to speak HTTP/1.1 then also send 'Cache-control:
 43113:         // no-cache'
 43113:         if (mRequestHead.Version() >= NS_HTTP_VERSION_1_1)
 80486:             mRequestHead.SetHeader(nsHttp::Cache_Control, NS_LITERAL_CSTRING("no-cache"), true);
 43113:     }
 43113:     else if ((mLoadFlags & VALIDATE_ALWAYS) && (mCacheAccess & nsICache::ACCESS_READ)) {
 43113:         // We need to send 'Cache-Control: max-age=0' to force each cache along
 43113:         // the path to the origin server to revalidate its own entry, if any,
 43113:         // with the next cache or server.  See bug #84847.
 43113:         //
 43113:         // If we're configured to speak HTTP/1.0 then just send 'Pragma: no-cache'
 43113:         if (mRequestHead.Version() >= NS_HTTP_VERSION_1_1)
 80486:             mRequestHead.SetHeader(nsHttp::Cache_Control, NS_LITERAL_CSTRING("max-age=0"), true);
 43113:         else
 80486:             mRequestHead.SetHeader(nsHttp::Pragma, NS_LITERAL_CSTRING("no-cache"), true);
 43113:     }
 43113: 
 43113:     if (mResuming) {
 43113:         char byteRange[32];
 43113:         PR_snprintf(byteRange, sizeof(byteRange), "bytes=%llu-", mStartPos);
 43113:         mRequestHead.SetHeader(nsHttp::Range, nsDependentCString(byteRange));
 43113: 
 43113:         if (!mEntityID.IsEmpty()) {
 43113:             // Also, we want an error if this resource changed in the meantime
 43113:             // Format of the entity id is: escaped_etag/size/lastmod
 43113:             nsCString::const_iterator start, end, slash;
 43113:             mEntityID.BeginReading(start);
 43113:             mEntityID.EndReading(end);
 43113:             mEntityID.BeginReading(slash);
 43113: 
 43113:             if (FindCharInReadable('/', slash, end)) {
 43113:                 nsCAutoString ifMatch;
 43113:                 mRequestHead.SetHeader(nsHttp::If_Match,
 43113:                         NS_UnescapeURL(Substring(start, slash), 0, ifMatch));
 43113: 
 43113:                 ++slash; // Incrementing, so that searching for '/' won't find
 43113:                          // the same slash again
 43113:             }
 43113: 
 43113:             if (FindCharInReadable('/', slash, end)) {
 43113:                 mRequestHead.SetHeader(nsHttp::If_Unmodified_Since,
 43113:                         Substring(++slash, end));
 43113:             }
 43113:         }
 43113:     }
 43113: 
 43113:     // create wrapper for this channel's notification callbacks
 43113:     nsCOMPtr<nsIInterfaceRequestor> callbacks;
 43113:     NS_NewNotificationCallbacksAggregation(mCallbacks, mLoadGroup,
 43113:                                            getter_AddRefs(callbacks));
 43113:     if (!callbacks)
 43113:         return NS_ERROR_OUT_OF_MEMORY;
 43113: 
 43113:     // create the transaction object
 43113:     mTransaction = new nsHttpTransaction();
 43113:     if (!mTransaction)
 43113:         return NS_ERROR_OUT_OF_MEMORY;
 43113: 
 43113:     // See bug #466080. Transfer LOAD_ANONYMOUS flag to socket-layer.
 43113:     if (mLoadFlags & LOAD_ANONYMOUS)
 43113:         mCaps |= NS_HTTP_LOAD_ANONYMOUS;
 43113: 
 70188:     if (mTimingEnabled)
 70188:         mCaps |= NS_HTTP_TIMING_ENABLED;
 70188: 
 43113:     mConnectionInfo->SetAnonymous((mLoadFlags & LOAD_ANONYMOUS) != 0);
 99366:     mConnectionInfo->SetPrivate(UsingPrivateBrowsing());
 43113: 
 70090:     if (mUpgradeProtocolCallback) {
 80486:         mRequestHead.SetHeader(nsHttp::Upgrade, mUpgradeProtocol, false);
 70090:         mRequestHead.SetHeader(nsHttp::Connection,
 70090:                                nsDependentCString(nsHttp::Upgrade.get()),
 80486:                                true);
 70090:         mCaps |=  NS_HTTP_STICKY_CONNECTION;
 70090:         mCaps &= ~NS_HTTP_ALLOW_PIPELINING;
 70090:         mCaps &= ~NS_HTTP_ALLOW_KEEPALIVE;
 84549:         mCaps |=  NS_HTTP_DISALLOW_SPDY;
 70090:     }
 70090: 
 43113:     nsCOMPtr<nsIAsyncInputStream> responseStream;
 43113:     rv = mTransaction->Init(mCaps, mConnectionInfo, &mRequestHead,
 43113:                             mUploadStream, mUploadStreamHasHeaders,
 43113:                             NS_GetCurrentThread(), callbacks, this,
 43113:                             getter_AddRefs(responseStream));
 43113:     if (NS_FAILED(rv)) {
 46790:         mTransaction = nsnull;
 43113:         return rv;
 43113:     }
 43113: 
 43113:     rv = nsInputStreamPump::Create(getter_AddRefs(mTransactionPump),
 43113:                                    responseStream);
 43113:     return rv;
 43113: }
 43113: 
 43113: // NOTE: This function duplicates code from nsBaseChannel. This will go away
 43113: // once HTTP uses nsBaseChannel (part of bug 312760)
 43113: static void
 43113: CallTypeSniffers(void *aClosure, const PRUint8 *aData, PRUint32 aCount)
 43113: {
 43113:   nsIChannel *chan = static_cast<nsIChannel*>(aClosure);
 43113: 
 43113:   const nsCOMArray<nsIContentSniffer>& sniffers =
 43113:     gIOService->GetContentSniffers();
 43113:   PRUint32 length = sniffers.Count();
 43113:   for (PRUint32 i = 0; i < length; ++i) {
 43113:     nsCAutoString newType;
 43113:     nsresult rv =
 43113:       sniffers[i]->GetMIMETypeFromContent(chan, aData, aCount, newType);
 43113:     if (NS_SUCCEEDED(rv) && !newType.IsEmpty()) {
 43113:       chan->SetContentType(newType);
 43113:       break;
 43113:     }
 43113:   }
 43113: }
 43113: 
 43113: nsresult
 43113: nsHttpChannel::CallOnStartRequest()
 43113: {
 80486:     mTracingEnabled = false;
 43113: 
 43113:     if (mResponseHead && mResponseHead->ContentType().IsEmpty()) {
 73543:         NS_ASSERTION(mConnectionInfo, "Should have connection info here");
 43113:         if (!mContentTypeHint.IsEmpty())
 43113:             mResponseHead->SetContentType(mContentTypeHint);
 73543:         else if (mResponseHead->Version() == NS_HTTP_VERSION_0_9 &&
 73543:                  mConnectionInfo->Port() != mConnectionInfo->DefaultPort())
 73543:             mResponseHead->SetContentType(NS_LITERAL_CSTRING(TEXT_PLAIN));
 43113:         else {
 43113:             // Uh-oh.  We had better find out what type we are!
 43113: 
 43113:             // XXX This does not work with content-encodings...  but
 43113:             // neither does applying the conversion from the URILoader
 43113: 
 43113:             nsCOMPtr<nsIStreamConverterService> serv;
 43113:             nsresult rv = gHttpHandler->
 43113:                 GetStreamConverterService(getter_AddRefs(serv));
 43113:             // If we failed, we just fall through to the "normal" case
 43113:             if (NS_SUCCEEDED(rv)) {
 43113:                 nsCOMPtr<nsIStreamListener> converter;
 43113:                 rv = serv->AsyncConvertData(UNKNOWN_CONTENT_TYPE,
 43113:                                             "*/*",
 43113:                                             mListener,
 43113:                                             mListenerContext,
 43113:                                             getter_AddRefs(converter));
 43113:                 if (NS_SUCCEEDED(rv)) {
 43113:                     mListener = converter;
 43113:                 }
 43113:             }
 43113:         }
 43113:     }
 43113: 
 43113:     if (mResponseHead && mResponseHead->ContentCharset().IsEmpty())
 43113:         mResponseHead->SetContentCharset(mContentCharsetHint);
 43113: 
 52144:     if (mResponseHead) {
 51740:         SetPropertyAsInt64(NS_CHANNEL_PROP_CONTENT_LENGTH,
 51740:                            mResponseHead->ContentLength());
 52144:         // If we have a cache entry, set its predicted size to ContentLength to
 52144:         // avoid caching an entry that will exceed the max size limit.
 52144:         if (mCacheEntry) {
 52144:             nsresult rv;
 52144:             PRInt64 predictedDataSize = -1; // -1 in case GetAsInt64 fails.
 52144:             GetPropertyAsInt64(NS_CHANNEL_PROP_CONTENT_LENGTH, 
 52144:                                &predictedDataSize);
 52144:             rv = mCacheEntry->SetPredictedDataSize(predictedDataSize);
 52144:             if (NS_FAILED(rv)) return rv;
 52144:         }
 52144:     }
 43113:     // Allow consumers to override our content type
 43113:     if ((mLoadFlags & LOAD_CALL_CONTENT_SNIFFERS) &&
 43113:         gIOService->GetContentSniffers().Count() != 0) {
 43113:         // NOTE: We can have both a txn pump and a cache pump when the cache
 43113:         // content is partial. In that case, we need to read from the cache,
 43113:         // because that's the one that has the initial contents. If that fails
 43113:         // then give the transaction pump a shot.
 43113: 
 43113:         nsIChannel* thisChannel = static_cast<nsIChannel*>(this);
 43113: 
 79445:         bool typeSniffersCalled = false;
 43113:         if (mCachePump) {
 43113:           typeSniffersCalled =
 43113:             NS_SUCCEEDED(mCachePump->PeekStream(CallTypeSniffers, thisChannel));
 43113:         }
 43113:         
 43113:         if (!typeSniffersCalled && mTransactionPump) {
 43113:           mTransactionPump->PeekStream(CallTypeSniffers, thisChannel);
 43113:         }
 43113:     }
 43113: 
 43113:     LOG(("  calling mListener->OnStartRequest\n"));
 43113:     nsresult rv = mListener->OnStartRequest(this, mListenerContext);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     // install stream converter if required
 43113:     rv = ApplyContentConversions();
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 93839:     rv = EnsureAssocReq();
 93839:     if (NS_FAILED(rv))
 93839:         return rv;
 93839: 
 52366:     // if this channel is for a download, close off access to the cache.
 52366:     if (mCacheEntry && mChannelIsForDownload) {
 52366:         mCacheEntry->Doom();
 80486:         CloseCacheEntry(false);
 52366:     }
 52366: 
 43113:     if (!mCanceled) {
 43113:         // create offline cache entry if offline caching was requested
 99873:         if (ShouldUpdateOfflineCacheEntry()) {
 43113:             LOG(("writing to the offline cache"));
 43113:             rv = InitOfflineCacheEntry();
 43113:             if (NS_FAILED(rv)) return rv;
 43113:             
103135:             // InitOfflineCacheEntry may have closed mOfflineCacheEntry
103135:             if (mOfflineCacheEntry) {
 43113:                 rv = InstallOfflineCacheListener();
 43113:                 if (NS_FAILED(rv)) return rv;
103135:             }
 99873:         } else if (mCacheForOfflineUse) {
 43113:             LOG(("offline cache is up to date, not updating"));
 43113:             CloseOfflineCacheEntry();
 43113:         }
 43113:     }
 43113: 
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: nsresult
102885: nsHttpChannel::ProcessFailedSSLConnect(PRUint32 httpStatus)
102885: {
102885:     // Failure to set up SSL proxy tunnel means one of the following:
 43113:     // 1) Proxy wants authorization, or forbids.
 43113:     // 2) DNS at proxy couldn't resolve target URL.
 43113:     // 3) Proxy connection to target failed or timed out.
102885:     // 4) Eve noticed our proxy CONNECT, and is replying with malicious HTML.
 43113:     // 
102885:     // Our current architecture will parse response content with the
102885:     // permission of the target URL!  Given #4, we must avoid rendering the
 43113:     // body of the reply, and instead give the user a (hopefully helpful) 
 43113:     // boilerplate error page, based on just the HTTP status of the reply.
 43113: 
102885:     NS_ABORT_IF_FALSE(mConnectionInfo->UsingSSL(),
102885:                       "SSL connect failed but not using SSL?");
 43113:     nsresult rv;
 43113:     switch (httpStatus) 
 43113:     {
 93695:     case 300: case 301: case 302: case 303: case 307: case 308:
 43113:         // Bad redirect: not top-level, or it's a POST, bad/missing Location,
 43113:         // or ProcessRedirect() failed for some other reason.  Legal
 43113:         // redirects that fail because site not available, etc., are handled
 43113:         // elsewhere, in the regular codepath.
 43113:         rv = NS_ERROR_CONNECTION_REFUSED;
 43113:         break;
 43113:     case 403: // HTTP/1.1: "Forbidden"
 43113:     case 407: // ProcessAuthentication() failed
 43113:     case 501: // HTTP/1.1: "Not Implemented"
 43113:         // user sees boilerplate Mozilla "Proxy Refused Connection" page.
 43113:         rv = NS_ERROR_PROXY_CONNECTION_REFUSED; 
 43113:         break;
 43113:     // Squid sends 404 if DNS fails (regular 404 from target is tunneled)
 43113:     case 404: // HTTP/1.1: "Not Found"
 43113:     // RFC 2616: "some deployed proxies are known to return 400 or 500 when
 43113:     // DNS lookups time out."  (Squid uses 500 if it runs out of sockets: so
 43113:     // we have a conflict here).
 43113:     case 400: // HTTP/1.1 "Bad Request"
 43113:     case 500: // HTTP/1.1: "Internal Server Error"
 43113:         /* User sees: "Address Not Found: Firefox can't find the server at
 43113:          * www.foo.com."
 43113:          */
 43113:         rv = NS_ERROR_UNKNOWN_HOST; 
 43113:         break;
 43113:     case 502: // HTTP/1.1: "Bad Gateway" (invalid resp from target server)
 43113:     // Squid returns 503 if target request fails for anything but DNS.
 43113:     case 503: // HTTP/1.1: "Service Unavailable"
 43113:         /* User sees: "Failed to Connect:
 43113:          *  Firefox can't establish a connection to the server at
 43113:          *  www.foo.com.  Though the site seems valid, the browser
 43113:          *  was unable to establish a connection."
 43113:          */
 43113:         rv = NS_ERROR_CONNECTION_REFUSED;
 43113:         break;
 43113:     // RFC 2616 uses 504 for both DNS and target timeout, so not clear what to
 43113:     // do here: picking target timeout, as DNS covered by 400/404/500
 43113:     case 504: // HTTP/1.1: "Gateway Timeout" 
 43113:         // user sees: "Network Timeout: The server at www.foo.com
 43113:         //              is taking too long to respond."
 43113:         rv = NS_ERROR_NET_TIMEOUT;
 43113:         break;
 43113:     // Confused proxy server or malicious response
 43113:     default:
 43113:         rv = NS_ERROR_PROXY_CONNECTION_REFUSED; 
 43113:         break;
 43113:     }
102885:     LOG(("Cancelling failed SSL proxy connection [this=%p httpStatus=%u]\n",
 43113:          this, httpStatus)); 
 43113:     Cancel(rv);
 43113:     CallOnStartRequest();
 43113:     return rv;
 43113: }
 43113: 
102885: bool
102885: nsHttpChannel::ShouldSSLProxyResponseContinue(PRUint32 httpStatus)
102885: {
102885:     // When SSL connect has failed, allow proxy reply to continue only if it's
102885:     // a 407 (proxy authentication required) response
102885:     return (httpStatus == 407);
102885: }
102885: 
 51363: /**
 51363:  * Decide whether or not to remember Strict-Transport-Security, and whether
 51363:  * or not to enforce channel integrity.
 51363:  *
 51363:  * @return NS_ERROR_FAILURE if there's security information missing even though
 51363:  *             it's an HTTPS connection.
 51363:  */
 51363: nsresult
 51363: nsHttpChannel::ProcessSTSHeader()
 51363: {
 51363:     nsresult rv;
 79445:     bool isHttps = false;
 51363:     rv = mURI->SchemeIs("https", &isHttps);
 51363:     NS_ENSURE_SUCCESS(rv, rv);
 51363: 
 51363:     // If this channel is not loading securely, STS doesn't do anything.
 51363:     // The upgrade to HTTPS takes place earlier in the channel load process.
 51363:     if (!isHttps)
 51363:         return NS_OK;
 51363: 
 51363:     nsCAutoString asciiHost;
 51363:     rv = mURI->GetAsciiHost(asciiHost);
 52258:     NS_ENSURE_SUCCESS(rv, NS_OK);
 51363: 
 51363:     // If the channel is not a hostname, but rather an IP, STS doesn't do
 51363:     // anything.
 51363:     PRNetAddr hostAddr;
 51363:     if (PR_SUCCESS == PR_StringToNetAddr(asciiHost.get(), &hostAddr))
 51363:         return NS_OK;
 51363: 
 51363:     nsIStrictTransportSecurityService* stss = gHttpHandler->GetSTSService();
 51363:     NS_ENSURE_TRUE(stss, NS_ERROR_OUT_OF_MEMORY);
 51363: 
 52258:     // mSecurityInfo may not always be present, and if it's not then it is okay
 52258:     // to just disregard any STS headers since we know nothing about the
 52258:     // security of the connection.
 52258:     NS_ENSURE_TRUE(mSecurityInfo, NS_OK);
 52258: 
 51363:     // Check the trustworthiness of the channel (are there any cert errors?)
 51363:     // If there are certificate errors, we still load the data, we just ignore
 51363:     // any STS headers that are present.
 79445:     bool tlsIsBroken = false;
 51363:     rv = stss->ShouldIgnoreStsHeader(mSecurityInfo, &tlsIsBroken);
 52258:     NS_ENSURE_SUCCESS(rv, NS_OK);
 51363: 
 51363:     // If this was already an STS host, the connection should have been aborted
 51363:     // by the bad cert handler in the case of cert errors.  If it didn't abort the connection,
 51363:     // there's probably something funny going on.
 51363:     // If this wasn't an STS host, errors are allowed, but no more STS processing
 51363:     // will happen during the session.
 79445:     bool wasAlreadySTSHost;
 51363:     rv = stss->IsStsURI(mURI, &wasAlreadySTSHost);
 52258:     // Failure here means STS is broken.  Don't prevent the load, but this
 52258:     // shouldn't fail.
 52258:     NS_ENSURE_SUCCESS(rv, NS_OK);
 51363:     NS_ASSERTION(!(wasAlreadySTSHost && tlsIsBroken),
 51363:                  "connection should have been aborted by nss-bad-cert-handler");
 51363: 
 51363:     // Any STS header is ignored if the channel is not trusted due to
 51363:     // certificate errors (STS Spec 7.1) -- there is nothing else to do, and
 51363:     // the load may progress.
 51363:     if (tlsIsBroken) {
 51363:         LOG(("STS: Transport layer is not trustworthy, ignoring "
 51363:              "STS headers and continuing load\n"));
 51363:         return NS_OK;
 51363:     }
 51363: 
 51363:     // If there's a STS header, process it (STS Spec 7.1).  At this point in
 51363:     // processing, the channel is trusted, so the header should not be ignored.
 51363:     const nsHttpAtom atom = nsHttp::ResolveAtom("Strict-Transport-Security");
 51363:     nsCAutoString stsHeader;
 51363:     rv = mResponseHead->GetHeader(atom, stsHeader);
 51363:     if (rv == NS_ERROR_NOT_AVAILABLE) {
 51363:         LOG(("STS: No STS header, continuing load.\n"));
 51363:         return NS_OK;
 51363:     }
 52258:     // All other failures are fatal.
 51363:     NS_ENSURE_SUCCESS(rv, rv);
 51363: 
 51363:     rv = stss->ProcessStsHeader(mURI, stsHeader.get());
 51363:     if (NS_FAILED(rv)) {
 51363:         LOG(("STS: Failed to parse STS header, continuing load.\n"));
 51363:         return NS_OK;
 51363:     }
 51363: 
 51363:     return NS_OK;
 51363: }
 51363: 
 43113: nsresult
 43113: nsHttpChannel::ProcessResponse()
 43113: {
 43113:     nsresult rv;
 43113:     PRUint32 httpStatus = mResponseHead->Status();
 43113: 
 43113:     LOG(("nsHttpChannel::ProcessResponse [this=%p httpStatus=%u]\n",
 43113:         this, httpStatus));
 43113: 
102885:     if (mTransaction->SSLConnectFailed()) {
102885:         if (!ShouldSSLProxyResponseContinue(httpStatus))
102885:             return ProcessFailedSSLConnect(httpStatus);
102885:         // If SSL proxy response needs to complete, wait to process connection
 52258:         // for Strict-Transport-Security.
 52258:     } else {
 52258:         // Given a successful connection, process any STS data that's relevant.
 51363:         rv = ProcessSTSHeader();
 52258:         NS_ASSERTION(NS_SUCCEEDED(rv), "ProcessSTSHeader failed, continuing load.");
 52258:     }
 51363: 
 99874:     MOZ_ASSERT(!mCachedContentIsValid);
 99874:     if (httpStatus != 304 && httpStatus != 206) {
103136:         mCacheInputStream.CloseAndRelease();
 99874:     }
 99874: 
 43113:     // notify "http-on-examine-response" observers
 43113:     gHttpHandler->OnExamineResponse(this);
 43113: 
 43113:     SetCookie(mResponseHead->PeekHeader(nsHttp::Set_Cookie));
 43113: 
 43113:     // handle unused username and password in url (see bug 232567)
 43113:     if (httpStatus != 401 && httpStatus != 407) {
 43832:         if (!mAuthRetryPending)
 43832:             mAuthProvider->CheckForSuperfluousAuth();
 43113:         if (mCanceled)
 43113:             return CallOnStartRequest();
 43113: 
 43832:         // reset the authentication's current continuation state because our
 43832:         // last authentication attempt has been completed successfully
 43832:         mAuthProvider->Disconnect(NS_ERROR_ABORT);
 43832:         mAuthProvider = nsnull;
 43113:         LOG(("  continuation state has been reset"));
 43113:     }
 43113: 
 78427:     bool successfulReval = false;
 78427: 
 43113:     // handle different server response categories.  Note that we handle
 43113:     // caching or not caching of error pages in
 43113:     // nsHttpResponseHead::MustValidate; if you change this switch, update that
 43113:     // one
 43113:     switch (httpStatus) {
 43113:     case 200:
 43113:     case 203:
 43113:         // Per RFC 2616, 14.35.2, "A server MAY ignore the Range header".
 43113:         // So if a server does that and sends 200 instead of 206 that we
 43113:         // expect, notify our caller.
 43113:         // However, if we wanted to start from the beginning, let it go through
 43113:         if (mResuming && mStartPos != 0) {
 43113:             LOG(("Server ignored our Range header, cancelling [this=%p]\n", this));
 43113:             Cancel(NS_ERROR_NOT_RESUMABLE);
 43113:             rv = CallOnStartRequest();
 43113:             break;
 43113:         }
 43113:         // these can normally be cached
 43113:         rv = ProcessNormal();
 43113:         MaybeInvalidateCacheEntryForSubsequentGet();
 43113:         break;
 43113:     case 206:
 43113:         if (mCachedContentIsPartial) // an internal byte range request...
 43113:             rv = ProcessPartialContent();
 99874:         else {
103136:             mCacheInputStream.CloseAndRelease();
 43113:             rv = ProcessNormal();
 99874:         }
 43113:         break;
 43113:     case 300:
 43113:     case 301:
 43113:     case 302:
 43113:     case 307:
 93695:     case 308:
 43113:     case 303:
 43113: #if 0
 43113:     case 305: // disabled as a security measure (see bug 187996).
 43113: #endif
 43113:         // don't store the response body for redirects
 43113:         MaybeInvalidateCacheEntryForSubsequentGet();
 48304:         PushRedirectAsyncFunc(&nsHttpChannel::ContinueProcessResponse);
 48304:         rv = AsyncProcessRedirection(httpStatus);
 48304:         if (NS_FAILED(rv)) {
 48304:             PopRedirectAsyncFunc(&nsHttpChannel::ContinueProcessResponse);
 48304:             LOG(("AsyncProcessRedirection failed [rv=%x]\n", rv));
101254:             // don't cache failed redirect responses.
101254:             if (mCacheEntry)
101254:                 mCacheEntry->Doom();
101254:             if (DoNotRender3xxBody(rv)) {
101254:                 mStatus = rv;
101254:                 DoNotifyListener();
101254:             } else {
 48304:                 rv = ContinueProcessResponse(rv);
 43113:             }
101254:         }
 43113:         break;
 43113:     case 304:
 43113:         rv = ProcessNotModified();
 43113:         if (NS_FAILED(rv)) {
 43113:             LOG(("ProcessNotModified failed [rv=%x]\n", rv));
103136:             mCacheInputStream.CloseAndRelease();
 43113:             rv = ProcessNormal();
 43113:         }
 78427:         else {
 78427:             successfulReval = true;
 78427:         }
 43113:         break;
 43113:     case 401:
 43113:     case 407:
 43832:         rv = mAuthProvider->ProcessAuthentication(
102885:             httpStatus, mConnectionInfo->UsingSSL() &&
102885:                         mTransaction->SSLConnectFailed());
 43832:         if (rv == NS_ERROR_IN_PROGRESS)  {
 43832:             // authentication prompt has been invoked and result
 43832:             // is expected asynchronously
 80486:             mAuthRetryPending = true;
 43832:             // suspend the transaction pump to stop receiving the
 43832:             // unauthenticated content data. We will throw that data
 43832:             // away when user provides credentials or resume the pump
 43832:             // when user refuses to authenticate.
 43832:             LOG(("Suspending the transaction, asynchronously prompting for credentials"));
 43832:             mTransactionPump->Suspend();
 43832:             rv = NS_OK;
 43832:         }
 43832:         else if (NS_FAILED(rv)) {
 43113:             LOG(("ProcessAuthentication failed [rv=%x]\n", rv));
102885:             if (mTransaction->SSLConnectFailed())
102885:                 return ProcessFailedSSLConnect(httpStatus);
 43832:             if (!mAuthRetryPending)
 43832:                 mAuthProvider->CheckForSuperfluousAuth();
 43113:             rv = ProcessNormal();
 43113:         }
 43832:         else
 80486:             mAuthRetryPending = true; // see DoAuthRetry
 43113:         break;
 43113:     default:
 43113:         rv = ProcessNormal();
 43113:         MaybeInvalidateCacheEntryForSubsequentGet();
 43113:         break;
 43113:     }
 43113: 
 99880:     PRUint32 cacheDisposition;
 78427:     if (!mDidReval)
 79877:         cacheDisposition = kCacheMissed;
 79877:     else if (successfulReval)
 79877:         cacheDisposition = kCacheHitViaReval;
 79877:     else
 79877:         cacheDisposition = kCacheMissedViaReval;
 79877: 
 99880:     AccumulateCacheHitTelemetry(mCacheEntry ? mCacheEntryDeviceTelemetryID
 99880:                                             : UNKNOWN_DEVICE,
 79877:                                 cacheDisposition);
 78427: 
 43113:     return rv;
 43113: }
 43113: 
 43113: nsresult
 48304: nsHttpChannel::ContinueProcessResponse(nsresult rv)
 48304: {
101254:     bool doNotRender = DoNotRender3xxBody(rv);
 95201: 
 78633:     if (rv == NS_ERROR_DOM_BAD_URI && mRedirectURI) {
 79445:         bool isHTTP = false;
 78633:         if (NS_FAILED(mRedirectURI->SchemeIs("http", &isHTTP)))
 80486:             isHTTP = false;
 78633:         if (!isHTTP && NS_FAILED(mRedirectURI->SchemeIs("https", &isHTTP)))
 80486:             isHTTP = false;
 78633: 
 78633:         if (!isHTTP) {
 78633:             // This was a blocked attempt to redirect and subvert the system by
 78633:             // redirecting to another protocol (perhaps javascript:)
 78633:             // In that case we want to throw an error instead of displaying the
 78633:             // non-redirected response body.
 78633:             LOG(("ContinueProcessResponse detected rejected Non-HTTP Redirection"));
101254:             doNotRender = true;
101254:             rv = NS_ERROR_CORRUPTED_CONTENT;
101254:         }
101254:     }
101254: 
101254:     if (doNotRender) {
101254:         Cancel(rv);
101254:         DoNotifyListener();
101254:         return rv;
 78633:     }
 78633: 
 48304:     if (NS_SUCCEEDED(rv)) {
 48304:         InitCacheEntry();
 80486:         CloseCacheEntry(false);
 48304: 
 48304:         if (mCacheForOfflineUse) {
 48304:             // Store response in the offline cache
 48304:             InitOfflineCacheEntry();
 48304:             CloseOfflineCacheEntry();
 48304:         }
 48304:         return NS_OK;
 48304:     }
 48304: 
 48304:     LOG(("ContinueProcessResponse got failure result [rv=%x]\n", rv));
102885:     if (mTransaction->SSLConnectFailed()) {
102885:         return ProcessFailedSSLConnect(mRedirectType);
 48304:     }
 48304:     return ProcessNormal();
 48304: }
 48304: 
 48304: nsresult
 43113: nsHttpChannel::ProcessNormal()
 43113: {
 43113:     nsresult rv;
 43113: 
 43113:     LOG(("nsHttpChannel::ProcessNormal [this=%p]\n", this));
 43113: 
 79445:     bool succeeded;
 43113:     rv = GetRequestSucceeded(&succeeded);
 43113:     if (NS_SUCCEEDED(rv) && !succeeded) {
 48304:         PushRedirectAsyncFunc(&nsHttpChannel::ContinueProcessNormal);
 79445:         bool waitingForRedirectCallback;
 63793:         (void)ProcessFallback(&waitingForRedirectCallback);
 48304:         if (waitingForRedirectCallback) {
 48304:             // The transaction has been suspended by ProcessFallback.
 48304:             return NS_OK;
 48304:         }
 48304:         PopRedirectAsyncFunc(&nsHttpChannel::ContinueProcessNormal);
 48304:     }
 48304: 
 48304:     return ContinueProcessNormal(NS_OK);
 48304: }
 48304: 
 48304: nsresult
 48304: nsHttpChannel::ContinueProcessNormal(nsresult rv)
 48304: {
 43113:     if (NS_FAILED(rv)) {
 48304:         // Fill the failure status here, we have failed to fall back, thus we
 48304:         // have to report our status as failed.
 48304:         mStatus = rv;
 43113:         DoNotifyListener();
 43113:         return rv;
 43113:     }
 43113: 
 48304:     if (mFallingBack) {
 43113:         // Do not continue with normal processing, fallback is in
 43113:         // progress now.
 43113:         return NS_OK;
 43113:     }
 43113: 
 43113:     // if we're here, then any byte-range requests failed to result in a partial
 43113:     // response.  we must clear this flag to prevent BufferPartialContent from
 43113:     // being called inside our OnDataAvailable (see bug 136678).
 80486:     mCachedContentIsPartial = false;
 43113: 
 43113:     ClearBogusContentEncodingIfNeeded();
 43113: 
 98084:     UpdateInhibitPersistentCachingFlag();
 98084: 
 43113:     // this must be called before firing OnStartRequest, since http clients,
 43113:     // such as imagelib, expect our cache entry to already have the correct
 43113:     // expiration time (bug 87710).
 43113:     if (mCacheEntry) {
 43113:         rv = InitCacheEntry();
 43113:         if (NS_FAILED(rv))
 80486:             CloseCacheEntry(true);
 43113:     }
 43113: 
 43113:     // Check that the server sent us what we were asking for
 43113:     if (mResuming) {
 43113:         // Create an entity id from the response
 43113:         nsCAutoString id;
 43113:         rv = GetEntityID(id);
 43113:         if (NS_FAILED(rv)) {
 43113:             // If creating an entity id is not possible -> error
 43113:             Cancel(NS_ERROR_NOT_RESUMABLE);
 43113:         }
 43113:         else if (mResponseHead->Status() != 206 &&
 43113:                  mResponseHead->Status() != 200) {
 43113:             // Probably 404 Not Found, 412 Precondition Failed or
 43113:             // 416 Invalid Range -> error
 43113:             LOG(("Unexpected response status while resuming, aborting [this=%p]\n",
 43113:                  this));
 43113:             Cancel(NS_ERROR_ENTITY_CHANGED);
 43113:         }
 43113:         // If we were passed an entity id, verify it's equal to the server's
 43113:         else if (!mEntityID.IsEmpty()) {
 43113:             if (!mEntityID.Equals(id)) {
 43113:                 LOG(("Entity mismatch, expected '%s', got '%s', aborting [this=%p]",
 43113:                      mEntityID.get(), id.get(), this));
 43113:                 Cancel(NS_ERROR_ENTITY_CHANGED);
 43113:             }
 43113:         }
 43113:     }
 43113: 
 43113:     rv = CallOnStartRequest();
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     // install cache listener if we still have a cache entry open
 43113:     if (mCacheEntry && (mCacheAccess & nsICache::ACCESS_WRITE)) {
 43113:         rv = InstallCacheListener();
 43113:         if (NS_FAILED(rv)) return rv;
 43113:     }
 43113: 
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: nsresult
 43113: nsHttpChannel::PromptTempRedirect()
 43113: {
 43113:     if (!gHttpHandler->PromptTempRedirect()) {
 43113:         return NS_OK;
 43113:     }
 43113:     nsresult rv;
 43113:     nsCOMPtr<nsIStringBundleService> bundleService =
 43113:             do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     nsCOMPtr<nsIStringBundle> stringBundle;
 43113:     rv = bundleService->CreateBundle(NECKO_MSGS_URL, getter_AddRefs(stringBundle));
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     nsXPIDLString messageString;
 43113:     rv = stringBundle->GetStringFromName(NS_LITERAL_STRING("RepostFormData").get(), getter_Copies(messageString));
 43113:     // GetStringFromName can return NS_OK and NULL messageString.
 43113:     if (NS_SUCCEEDED(rv) && messageString) {
 79445:         bool repost = false;
 43113: 
 43113:         nsCOMPtr<nsIPrompt> prompt;
 43113:         GetCallback(prompt);
 43113:         if (!prompt)
 43113:             return NS_ERROR_NO_INTERFACE;
 43113: 
 43113:         prompt->Confirm(nsnull, messageString, &repost);
 43113:         if (!repost)
 43113:             return NS_ERROR_FAILURE;
 43113:     }
 43113: 
 43113:     return rv;
 43113: }
 43113: 
 43113: nsresult
 43113: nsHttpChannel::ProxyFailover()
 43113: {
 43113:     LOG(("nsHttpChannel::ProxyFailover [this=%p]\n", this));
 43113: 
 43113:     nsresult rv;
 43113: 
 43113:     nsCOMPtr<nsIProtocolProxyService> pps =
 43113:             do_GetService(NS_PROTOCOLPROXYSERVICE_CONTRACTID, &rv);
 43113:     if (NS_FAILED(rv))
 43113:         return rv;
 43113: 
 43113:     nsCOMPtr<nsIProxyInfo> pi;
 43113:     rv = pps->GetFailoverForProxy(mConnectionInfo->ProxyInfo(), mURI, mStatus,
 43113:                                   getter_AddRefs(pi));
 43113:     if (NS_FAILED(rv))
 43113:         return rv;
 43113: 
 43113:     // XXXbz so where does this codepath remove us from the loadgroup,
 43113:     // exactly?
 48304:     return AsyncDoReplaceWithProxy(pi);
 43113: }
 43113: 
 43113: void
 43113: nsHttpChannel::HandleAsyncReplaceWithProxy()
 43113: {
 71646:     NS_PRECONDITION(!mCallOnResume, "How did that happen?");
 43113: 
 43113:     if (mSuspendCount) {
 43113:         LOG(("Waiting until resume to do async proxy replacement [this=%p]\n",
 43113:              this));
 71646:         mCallOnResume = &nsHttpChannel::HandleAsyncReplaceWithProxy;
 43113:         return;
 43113:     }
 43113: 
 43113:     nsresult status = mStatus;
 43113:     
 43113:     nsCOMPtr<nsIProxyInfo> pi;
 43113:     pi.swap(mTargetProxyInfo);
 43113:     if (!mCanceled) {
 48304:         PushRedirectAsyncFunc(&nsHttpChannel::ContinueHandleAsyncReplaceWithProxy);
 48304:         status = AsyncDoReplaceWithProxy(pi);
 48304:         if (NS_SUCCEEDED(status))
 48304:             return;
 48304:         PopRedirectAsyncFunc(&nsHttpChannel::ContinueHandleAsyncReplaceWithProxy);
 48304:     }
 48304: 
 48304:     if (NS_FAILED(status)) {
 48304:         ContinueHandleAsyncReplaceWithProxy(status);
 48304:     }
 48304: }
 48304: 
 48304: nsresult
 48304: nsHttpChannel::ContinueHandleAsyncReplaceWithProxy(nsresult status)
 48304: {
 43113:     if (mLoadGroup && NS_SUCCEEDED(status)) {
 43113:         mLoadGroup->RemoveRequest(this, nsnull, mStatus);
 43113:     }
 48304:     else if (NS_FAILED(status)) {
 43113:         AsyncAbort(status);
 43113:     }
 48304: 
 48304:     // Return NS_OK here, even it seems to be breaking the async function stack
 48304:     // contract (i.e. passing the result code to a function bellow).
 48304:     // ContinueHandleAsyncReplaceWithProxy will always be at the bottom of the
 48304:     // stack. If we would return the failure code, the async function stack
 48304:     // logic would cancel the channel synchronously, which is undesired after
 48304:     // invoking AsyncAbort above.
 48304:     return NS_OK;
 43113: }
 43113: 
 51363: void
 51363: nsHttpChannel::HandleAsyncRedirectChannelToHttps()
 51363: {
 71646:     NS_PRECONDITION(!mCallOnResume, "How did that happen?");
 51363: 
 51363:     if (mSuspendCount) {
 51363:         LOG(("Waiting until resume to do async redirect to https [this=%p]\n", this));
 71646:         mCallOnResume = &nsHttpChannel::HandleAsyncRedirectChannelToHttps;
 51363:         return;
 51363:     }
 51363: 
 51363:     nsresult rv = AsyncRedirectChannelToHttps();
 51363:     if (NS_FAILED(rv))
 51363:         ContinueAsyncRedirectChannelToHttps(rv);
 51363: }
 51363: 
 51363: nsresult
 51363: nsHttpChannel::AsyncRedirectChannelToHttps()
 51363: {
 51363:     nsresult rv = NS_OK;
 51363:     LOG(("nsHttpChannel::HandleAsyncRedirectChannelToHttps() [STS]\n"));
 51363: 
 51363:     nsCOMPtr<nsIChannel> newChannel;
 51363:     nsCOMPtr<nsIURI> upgradedURI;
 51363: 
 51363:     rv = mURI->Clone(getter_AddRefs(upgradedURI));
 51363:     NS_ENSURE_SUCCESS(rv,rv);
 51363: 
 51363:     upgradedURI->SetScheme(NS_LITERAL_CSTRING("https"));
 51363: 
 51363:     PRInt32 oldPort = -1;
 51363:     rv = mURI->GetPort(&oldPort);
 51363:     if (NS_FAILED(rv)) return rv;
 51363: 
 51363:     // Keep any nonstandard ports so only the scheme is changed.
 51363:     // For example:
 51363:     //  http://foo.com:80 -> https://foo.com:443
 51363:     //  http://foo.com:81 -> https://foo.com:81
 51363: 
 51363:     if (oldPort == 80 || oldPort == -1)
 51363:         upgradedURI->SetPort(-1);
 51363:     else
 51363:         upgradedURI->SetPort(oldPort);
 51363: 
 51363:     nsCOMPtr<nsIIOService> ioService;
 51363:     rv = gHttpHandler->GetIOService(getter_AddRefs(ioService));
 51363:     NS_ENSURE_SUCCESS(rv, rv);
 51363: 
 51363:     rv = ioService->NewChannelFromURI(upgradedURI, getter_AddRefs(newChannel));
 51363:     NS_ENSURE_SUCCESS(rv, rv);
 51363: 
 89558:     rv = SetupReplacementChannel(upgradedURI, newChannel, true, false);
 51363:     NS_ENSURE_SUCCESS(rv, rv);
 51363: 
 51363:     // Inform consumers about this fake redirect
 51363:     mRedirectChannel = newChannel;
 51363:     PRUint32 flags = nsIChannelEventSink::REDIRECT_PERMANENT;
 51363: 
 51363:     PushRedirectAsyncFunc(
 51363:         &nsHttpChannel::ContinueAsyncRedirectChannelToHttps);
 51363:     rv = gHttpHandler->AsyncOnChannelRedirect(this, newChannel, flags);
 51363: 
 51363:     if (NS_SUCCEEDED(rv))
 51363:         rv = WaitForRedirectCallback();
 51363: 
 51363:     if (NS_FAILED(rv)) {
 51363:         AutoRedirectVetoNotifier notifier(this);
 51363:         PopRedirectAsyncFunc(
 51363:             &nsHttpChannel::ContinueAsyncRedirectChannelToHttps);
 51363:     }
 51363: 
 51363:     return rv;
 51363: }
 51363: 
 51363: nsresult
 51363: nsHttpChannel::ContinueAsyncRedirectChannelToHttps(nsresult rv)
 51363: {
 51363:     AutoRedirectVetoNotifier notifier(this);
 51363: 
 51363:     if (NS_FAILED(rv)) {
 51363:         // Fill the failure status here, the update to https had been vetoed
 51363:         // but from the security reasons we have to discard the whole channel
 51363:         // load.
 51363:         mStatus = rv;
 51363:     }
 51363: 
 51363:     if (mLoadGroup)
 51363:         mLoadGroup->RemoveRequest(this, nsnull, mStatus);
 51363: 
 51363:     if (NS_FAILED(rv)) {
 51363:         // We have to manually notify the listener because there is not any pump
 51363:         // that would call our OnStart/StopRequest after resume from waiting for
 51363:         // the redirect callback.
 51363:         DoNotifyListener();
 51363:         return rv;
 51363:     }
 51363: 
 51363:     // Make sure to do this _after_ calling OnChannelRedirect
 51363:     mRedirectChannel->SetOriginalURI(mOriginalURI);
 51363: 
 51363:     // And now, notify observers the deprecated way
 51363:     nsCOMPtr<nsIHttpEventSink> httpEventSink;
 51363:     GetCallback(httpEventSink);
 51363:     if (httpEventSink) {
 51363:         // NOTE: nsIHttpEventSink is only used for compatibility with pre-1.8
 51363:         // versions.
 51363:         rv = httpEventSink->OnRedirect(this, mRedirectChannel);
 51363:         if (NS_FAILED(rv)) {
 51363:             mStatus = rv;
 51363:             DoNotifyListener();
 51363:             return rv;
 51363:         }
 51363:     }
 51363: 
 51363:     // open new channel
 51363:     rv = mRedirectChannel->AsyncOpen(mListener, mListenerContext);
 51363:     if (NS_FAILED(rv)) {
 51363:         mStatus = rv;
 51363:         DoNotifyListener();
 51363:         return rv;
 51363:     }
 51363: 
 51363:     mStatus = NS_BINDING_REDIRECTED;
 51363: 
 51363:     notifier.RedirectSucceeded();
 51363: 
 51363:     // disconnect from the old listeners...
 51363:     mListener = nsnull;
 51363:     mListenerContext = nsnull;
 51363: 
 51363:     // ...and the old callbacks
 51363:     mCallbacks = nsnull;
 51363:     mProgressSink = nsnull;
 51363: 
 51363:     return rv;
 51363: }
 51363: 
 43113: nsresult
 48304: nsHttpChannel::AsyncDoReplaceWithProxy(nsIProxyInfo* pi)
 43113: {
 48304:     LOG(("nsHttpChannel::AsyncDoReplaceWithProxy [this=%p pi=%p]", this, pi));
 43113:     nsresult rv;
 43113: 
 43113:     nsCOMPtr<nsIChannel> newChannel;
 43113:     rv = gHttpHandler->NewProxiedChannel(mURI, pi, getter_AddRefs(newChannel));
 43113:     if (NS_FAILED(rv))
 43113:         return rv;
 43113: 
 89558:     rv = SetupReplacementChannel(mURI, newChannel, true, true);
 43113:     if (NS_FAILED(rv))
 43113:         return rv;
 43113: 
 43113:     // Inform consumers about this fake redirect
 48304:     mRedirectChannel = newChannel;
 43113:     PRUint32 flags = nsIChannelEventSink::REDIRECT_INTERNAL;
 48304: 
 48304:     PushRedirectAsyncFunc(&nsHttpChannel::ContinueDoReplaceWithProxy);
 48304:     rv = gHttpHandler->AsyncOnChannelRedirect(this, newChannel, flags);
 48304: 
 48304:     if (NS_SUCCEEDED(rv))
 48304:         rv = WaitForRedirectCallback();
 48304: 
 48304:     if (NS_FAILED(rv)) {
 49375:         AutoRedirectVetoNotifier notifier(this);
 48304:         PopRedirectAsyncFunc(&nsHttpChannel::ContinueDoReplaceWithProxy);
 48304:     }
 48304: 
 48304:     return rv;
 48304: }
 48304: 
 48304: nsresult
 48304: nsHttpChannel::ContinueDoReplaceWithProxy(nsresult rv)
 48304: {
 49375:     AutoRedirectVetoNotifier notifier(this);
 49375: 
 43113:     if (NS_FAILED(rv))
 43113:         return rv;
 43113: 
 48304:     NS_PRECONDITION(mRedirectChannel, "No redirect channel?");
 48304: 
 43113:     // Make sure to do this _after_ calling OnChannelRedirect
 48304:     mRedirectChannel->SetOriginalURI(mOriginalURI);
 43113: 
 43113:     // open new channel
 48304:     rv = mRedirectChannel->AsyncOpen(mListener, mListenerContext);
 43113:     if (NS_FAILED(rv))
 43113:         return rv;
 43113: 
 43113:     mStatus = NS_BINDING_REDIRECTED;
 43113: 
 49375:     notifier.RedirectSucceeded();
 49375: 
 43113:     // disconnect from the old listeners...
 43113:     mListener = nsnull;
 43113:     mListenerContext = nsnull;
 43113: 
 43113:     // ...and the old callbacks
 43113:     mCallbacks = nsnull;
 43113:     mProgressSink = nsnull;
 43113: 
 43113:     return rv;
 43113: }
 43113: 
 43113: nsresult
 43113: nsHttpChannel::ResolveProxy()
 43113: {
 43113:     LOG(("nsHttpChannel::ResolveProxy [this=%p]\n", this));
 43113: 
 43113:     nsresult rv;
 43113: 
 43113:     nsCOMPtr<nsIProtocolProxyService> pps =
 43113:             do_GetService(NS_PROTOCOLPROXYSERVICE_CONTRACTID, &rv);
 43113:     if (NS_FAILED(rv))
 43113:         return rv;
 43113: 
 69816:     PRUint32 resolveFlags = 0;
 69816:     if (mConnectionInfo->ProxyInfo())
 69816:         mConnectionInfo->ProxyInfo()->GetResolveFlags(&resolveFlags);
 69816: 
 69816:     return pps->AsyncResolve(mURI, resolveFlags, this, getter_AddRefs(mProxyRequest));
 43113: }
 43113: 
 79445: bool
 99878: HttpCacheQuery::ResponseWouldVary() const
 43113: {
 99879:     AssertOnCacheThread();
 99879: 
 58260:     nsresult rv;
 43113:     nsCAutoString buf, metaKey;
 43113:     mCachedResponseHead->GetHeader(nsHttp::Vary, buf);
 43113:     if (!buf.IsEmpty()) {
 43113:         NS_NAMED_LITERAL_CSTRING(prefix, "request-");
 43113: 
 43113:         // enumerate the elements of the Vary header...
 43113:         char *val = buf.BeginWriting(); // going to munge buf
 43113:         char *token = nsCRT::strtok(val, NS_HTTP_HEADER_SEPS, &val);
 43113:         while (token) {
 99878:             LOG(("HttpCacheQuery::ResponseWouldVary [channel=%p] " \
 58260:                  "processing %s\n",
 99878:                  mChannel.get(), token));
 43113:             //
 43113:             // if "*", then assume response would vary.  technically speaking,
 43113:             // "Vary: header, *" is not permitted, but we allow it anyways.
 43113:             //
 58260:             // We hash values of cookie-headers for the following reasons:
 43113:             //
 43113:             //   1- cookies can be very large in size
 43113:             //
 43113:             //   2- cookies may contain sensitive information.  (for parity with
 43113:             //      out policy of not storing Set-cookie headers in the cache
 43113:             //      meta data, we likewise do not want to store cookie headers
 43113:             //      here.)
 43113:             //
 58260:             if (*token == '*')
 80486:                 return true; // if we encounter this, just get out of here
 58260: 
 43113:             // build cache meta data key...
 43113:             metaKey = prefix + nsDependentCString(token);
 43113: 
 43113:             // check the last value of the given request header to see if it has
 43113:             // since changed.  if so, then indeed the cached response is invalid.
 43113:             nsXPIDLCString lastVal;
 43113:             mCacheEntry->GetMetaDataElement(metaKey.get(), getter_Copies(lastVal));
 99878:             LOG(("HttpCacheQuery::ResponseWouldVary [channel=%p] "
 99878:                      "stored value = \"%s\"\n",
 99878:                  mChannel.get(), lastVal.get()));
 58260: 
 58260:             // Look for value of "Cookie" in the request headers
 43113:             nsHttpAtom atom = nsHttp::ResolveAtom(token);
 43113:             const char *newVal = mRequestHead.PeekHeader(atom);
 58260:             if (!lastVal.IsEmpty()) {
 58260:                 // value for this header in cache, but no value in request
 58260:                 if (!newVal)
 80486:                     return true; // yes - response would vary
 58260: 
 58260:                 // If this is a cookie-header, stored metadata is not
 58260:                 // the value itself but the hash. So we also hash the
 58260:                 // outgoing value here in order to compare the hashes
 58260:                 nsCAutoString hash;
 58260:                 if (atom == nsHttp::Cookie) {
 58260:                     rv = Hash(newVal, hash);
 58260:                     // If hash failed, be conservative (the cached hash
 58260:                     // exists at this point) and claim response would vary
 58260:                     if (NS_FAILED(rv))
 80486:                         return true;
 58260:                     newVal = hash.get();
 58260: 
 99878:                     LOG(("HttpCacheQuery::ResponseWouldVary [this=%p] " \
 58260:                             "set-cookie value hashed to %s\n",
 99878:                          mChannel.get(), newVal));
 58260:                 }
 58260: 
 58260:                 if (strcmp(newVal, lastVal))
 80486:                     return true; // yes, response would vary
 58260: 
 58260:             } else if (newVal) { // old value is empty, but newVal is set
 80486:                 return true;
 43113:             }
 43113: 
 43113:             // next token...
 43113:             token = nsCRT::strtok(val, NS_HTTP_HEADER_SEPS, &val);
 43113:         }
 43113:     }
 80486:     return false;
 58260: }
 58260: 
 71646: // We need to have an implementation of this function just so that we can keep
 71646: // all references to mCallOnResume of type nsHttpChannel:  it's not OK in C++
 71646: // to set a member function ptr to  a base class function.
 71646: void
 71646: nsHttpChannel::HandleAsyncAbort()
 71646: {
 71646:     HttpAsyncAborter<nsHttpChannel>::HandleAsyncAbort();
 71646: }
 71646: 
 71646: 
 58260: nsresult
 93839: nsHttpChannel::EnsureAssocReq()
 93839: {
 93839:     // Confirm Assoc-Req response header on pipelined transactions
 93839:     // per draft-nottingham-http-pipeline-01.txt
 93839:     // of the form: GET http://blah.com/foo/bar?qv
 93839:     // return NS_OK as long as we don't find a violation
 93839:     // (i.e. no header is ok, as are malformed headers, as are
 93839:     // transactions that have not been pipelined (unless those have been
 93839:     // opted in via pragma))
 93839: 
 93839:     if (!mResponseHead)
 93839:         return NS_OK;
 93839: 
 93839:     const char *assoc_val = mResponseHead->PeekHeader(nsHttp::Assoc_Req);
 93839:     if (!assoc_val)
 93839:         return NS_OK;
 93839: 
 93839:     if (!mTransaction || !mURI)
 93839:         return NS_OK;
 93839:     
 93839:     if (!mTransaction->PipelinePosition()) {
 93839:         // "Pragma: X-Verify-Assoc-Req" can be used to verify even non pipelined
 93839:         // transactions. It is used by test harness.
 93839: 
 93839:         const char *pragma_val = mResponseHead->PeekHeader(nsHttp::Pragma);
 93839:         if (!pragma_val ||
 93839:             !nsHttp::FindToken(pragma_val, "X-Verify-Assoc-Req",
 93839:                                HTTP_HEADER_VALUE_SEPS))
 93839:             return NS_OK;
 93839:     }
 93839: 
 93839:     char *method = net_FindCharNotInSet(assoc_val, HTTP_LWS);
 93839:     if (!method)
 93839:         return NS_OK;
 93839:     
 93839:     bool equals;
 93839:     char *endofmethod;
 93839:     
 93839:     assoc_val = nsnull;
 93839:     endofmethod = net_FindCharInSet(method, HTTP_LWS);
 93839:     if (endofmethod)
 93839:         assoc_val = net_FindCharNotInSet(endofmethod, HTTP_LWS);
 93839:     if (!assoc_val)
 93839:         return NS_OK;
 93839:     
 93839:     // check the method
 93839:     PRInt32 methodlen = PL_strlen(mRequestHead.Method().get());
 93839:     if ((methodlen != (endofmethod - method)) ||
 93839:         PL_strncmp(method,
 93839:                    mRequestHead.Method().get(),
 93839:                    endofmethod - method)) {
 93839:         LOG(("  Assoc-Req failure Method %s", method));
 93839:         if (mConnectionInfo)
 93840:             gHttpHandler->ConnMgr()->
 93840:                 PipelineFeedbackInfo(mConnectionInfo,
 93840:                                      nsHttpConnectionMgr::RedCorruptedContent,
 93840:                                      nsnull, 0);
 93839: 
 93839:         nsCOMPtr<nsIConsoleService> consoleService =
 93839:             do_GetService(NS_CONSOLESERVICE_CONTRACTID);
 93839:         if (consoleService) {
 93839:             nsAutoString message
 93839:                 (NS_LITERAL_STRING("Failed Assoc-Req. Received "));
 93839:             AppendASCIItoUTF16(
 93839:                 mResponseHead->PeekHeader(nsHttp::Assoc_Req),
 93839:                 message);
 93839:             message += NS_LITERAL_STRING(" expected method ");
 93839:             AppendASCIItoUTF16(mRequestHead.Method().get(), message);
 93839:             consoleService->LogStringMessage(message.get());
 93839:         }
 93839: 
 93839:         if (gHttpHandler->EnforceAssocReq())
 93839:             return NS_ERROR_CORRUPTED_CONTENT;
 93839:         return NS_OK;
 93839:     }
 93839:     
 93839:     // check the URL
 93839:     nsCOMPtr<nsIURI> assoc_url;
 93839:     if (NS_FAILED(NS_NewURI(getter_AddRefs(assoc_url), assoc_val)) ||
 93839:         !assoc_url)
 93839:         return NS_OK;
 93839: 
 93839:     mURI->Equals(assoc_url, &equals);
 93839:     if (!equals) {
 93839:         LOG(("  Assoc-Req failure URL %s", assoc_val));
 93839:         if (mConnectionInfo)
 93840:             gHttpHandler->ConnMgr()->
 93840:                 PipelineFeedbackInfo(mConnectionInfo,
 93840:                                      nsHttpConnectionMgr::RedCorruptedContent,
 93840:                                      nsnull, 0);
 93839: 
 93839:         nsCOMPtr<nsIConsoleService> consoleService =
 93839:             do_GetService(NS_CONSOLESERVICE_CONTRACTID);
 93839:         if (consoleService) {
 93839:             nsAutoString message
 93839:                 (NS_LITERAL_STRING("Failed Assoc-Req. Received "));
 93839:             AppendASCIItoUTF16(
 93839:                 mResponseHead->PeekHeader(nsHttp::Assoc_Req),
 93839:                 message);
 93839:             message += NS_LITERAL_STRING(" expected URL ");
 93839:             AppendASCIItoUTF16(mSpec.get(), message);
 93839:             consoleService->LogStringMessage(message.get());
 93839:         }
 93839: 
 93839:         if (gHttpHandler->EnforceAssocReq())
 93839:             return NS_ERROR_CORRUPTED_CONTENT;
 93839:     }
 93839:     return NS_OK;
 93839: }
 93839: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpChannel <byte-range>
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: nsresult
 99878: HttpCacheQuery::SetupByteRangeRequest(PRUint32 partialLen)
 43113: {
 99879:     AssertOnCacheThread();
 99879: 
 43113:     // cached content has been found to be partial, add necessary request
 43113:     // headers to complete cache entry.
 43113: 
 43113:     // use strongest validator available...
 43113:     const char *val = mCachedResponseHead->PeekHeader(nsHttp::ETag);
 43113:     if (!val)
 43113:         val = mCachedResponseHead->PeekHeader(nsHttp::Last_Modified);
 43113:     if (!val) {
 43113:         // if we hit this code it means mCachedResponseHead->IsResumable() is
 43113:         // either broken or not being called.
 43113:         NS_NOTREACHED("no cache validator");
 43113:         return NS_ERROR_FAILURE;
 43113:     }
 43113: 
 43113:     char buf[32];
 43113:     PR_snprintf(buf, sizeof(buf), "bytes=%u-", partialLen);
 43113: 
 43113:     mRequestHead.SetHeader(nsHttp::Range, nsDependentCString(buf));
 43113:     mRequestHead.SetHeader(nsHttp::If_Range, nsDependentCString(val));
 43113: 
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: nsresult
 43113: nsHttpChannel::ProcessPartialContent()
 43113: {
 43113:     // ok, we've just received a 206
 43113:     //
 43113:     // we need to stream whatever data is in the cache out first, and then
 43113:     // pick up whatever data is on the wire, writing it into the cache.
 43113: 
 43113:     LOG(("nsHttpChannel::ProcessPartialContent [this=%p]\n", this)); 
 43113: 
 43113:     NS_ENSURE_TRUE(mCachedResponseHead, NS_ERROR_NOT_INITIALIZED);
 43113:     NS_ENSURE_TRUE(mCacheEntry, NS_ERROR_NOT_INITIALIZED);
 43113: 
 43113:     // Make sure to clear bogus content-encodings before looking at the header
 43113:     ClearBogusContentEncodingIfNeeded();
 43113:     
 43113:     // Check if the content-encoding we now got is different from the one we
 43113:     // got before
 43113:     if (PL_strcasecmp(mResponseHead->PeekHeader(nsHttp::Content_Encoding),
 43113:                       mCachedResponseHead->PeekHeader(nsHttp::Content_Encoding))
 43113:                       != 0) {
 43113:         Cancel(NS_ERROR_INVALID_CONTENT_ENCODING);
 43113:         return CallOnStartRequest();
 43113:     }
 43113: 
 43113: 
 43113:     // suspend the current transaction
 43113:     nsresult rv = mTransactionPump->Suspend();
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     // merge any new headers with the cached response headers
 43113:     rv = mCachedResponseHead->UpdateHeaders(mResponseHead->Headers());
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     // update the cached response head
 43113:     nsCAutoString head;
 80486:     mCachedResponseHead->Flatten(head, true);
 43113:     rv = mCacheEntry->SetMetaDataElement("response-head", head.get());
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     // make the cached response be the current response
 43113:     mResponseHead = mCachedResponseHead;
 43113: 
 88544:     UpdateInhibitPersistentCachingFlag();
 88544: 
 43113:     rv = UpdateExpirationTime();
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     // notify observers interested in looking at a response that has been
 43113:     // merged with any cached headers (http-on-examine-merged-response).
 43113:     gHttpHandler->OnExamineMergedResponse(this);
 43113: 
 43113:     // the cached content is valid, although incomplete.
 80486:     mCachedContentIsValid = true;
 99874:     return ReadFromCache(false);
 43113: }
 43113: 
 43113: nsresult
 79445: nsHttpChannel::OnDoneReadingPartialCacheEntry(bool *streamDone)
 43113: {
 43113:     nsresult rv;
 43113: 
 43113:     LOG(("nsHttpChannel::OnDoneReadingPartialCacheEntry [this=%p]", this));
 43113: 
 43113:     // by default, assume we would have streamed all data or failed...
 80486:     *streamDone = true;
 43113: 
 43113:     // setup cache listener to append to cache entry
 43113:     PRUint32 size;
 43113:     rv = mCacheEntry->GetDataSize(&size);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     rv = InstallCacheListener(size);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     // need to track the logical offset of the data being sent to our listener
 43113:     mLogicalOffset = size;
 43113: 
 43113:     // we're now completing the cached content, so we can clear this flag.
 43113:     // this puts us in the state of a regular download.
 80486:     mCachedContentIsPartial = false;
 43113: 
 43113:     // resume the transaction if it exists, otherwise the pipe contained the
 43113:     // remaining part of the document and we've now streamed all of the data.
 43113:     if (mTransactionPump) {
 43113:         rv = mTransactionPump->Resume();
 43113:         if (NS_SUCCEEDED(rv))
 80486:             *streamDone = false;
 43113:     }
 43113:     else
 43113:         NS_NOTREACHED("no transaction");
 43113:     return rv;
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpChannel <cache>
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: nsresult
 43113: nsHttpChannel::ProcessNotModified()
 43113: {
 43113:     nsresult rv;
 43113: 
 43113:     LOG(("nsHttpChannel::ProcessNotModified [this=%p]\n", this)); 
 43113: 
 43113:     if (mCustomConditionalRequest) {
 43113:         LOG(("Bypassing ProcessNotModified due to custom conditional headers")); 
 43113:         return NS_ERROR_FAILURE;
 43113:     }
 43113: 
 43113:     NS_ENSURE_TRUE(mCachedResponseHead, NS_ERROR_NOT_INITIALIZED);
 43113:     NS_ENSURE_TRUE(mCacheEntry, NS_ERROR_NOT_INITIALIZED);
 43113: 
 93846:     // If the 304 response contains a Last-Modified different than the
 93846:     // one in our cache that is pretty suspicious and is, in at least the
 93846:     // case of bug 716840, a sign of the server having previously corrupted
 93846:     // our cache with a bad response. Take the minor step here of just dooming
 93846:     // that cache entry so there is a fighting chance of getting things on the
 93846:     // right track as well as disabling pipelining for that host.
 93846: 
 94989:     nsCAutoString lastModifiedCached;
 93846:     nsCAutoString lastModified304;
 93846: 
 93846:     rv = mCachedResponseHead->GetHeader(nsHttp::Last_Modified,
 94989:                                         lastModifiedCached);
 94989:     if (NS_SUCCEEDED(rv)) {
 93846:         rv = mResponseHead->GetHeader(nsHttp::Last_Modified, 
 93846:                                       lastModified304);
 94989:     }
 94989: 
 94989:     if (NS_SUCCEEDED(rv) && !lastModified304.Equals(lastModifiedCached)) {
 93846:         LOG(("Cache Entry and 304 Last-Modified Headers Do Not Match "
 94989:              "[%s] and [%s]\n",
 94989:              lastModifiedCached.get(), lastModified304.get()));
 93846: 
 93846:         mCacheEntry->Doom();
 93846:         if (mConnectionInfo)
 93846:             gHttpHandler->ConnMgr()->
 93846:                 PipelineFeedbackInfo(mConnectionInfo,
 93846:                                      nsHttpConnectionMgr::RedCorruptedContent,
 93846:                                      nsnull, 0);
 94989:         Telemetry::Accumulate(Telemetry::CACHE_LM_INCONSISTENT, true);
 93846:     }
 93846: 
 43113:     // merge any new headers with the cached response headers
 43113:     rv = mCachedResponseHead->UpdateHeaders(mResponseHead->Headers());
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     // update the cached response head
 43113:     nsCAutoString head;
 80486:     mCachedResponseHead->Flatten(head, true);
 43113:     rv = mCacheEntry->SetMetaDataElement("response-head", head.get());
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     // make the cached response be the current response
 43113:     mResponseHead = mCachedResponseHead;
 43113: 
 88544:     UpdateInhibitPersistentCachingFlag();
 88544: 
 43113:     rv = UpdateExpirationTime();
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 82085:     rv = AddCacheEntryHeaders(mCacheEntry);
 82085:     if (NS_FAILED(rv)) return rv;
 82085: 
 43113:     // notify observers interested in looking at a reponse that has been
 43113:     // merged with any cached headers
 43113:     gHttpHandler->OnExamineMergedResponse(this);
 43113: 
 80486:     mCachedContentIsValid = true;
 99874:     rv = ReadFromCache(false);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 80486:     mTransactionReplaced = true;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: nsresult
 79445: nsHttpChannel::ProcessFallback(bool *waitingForRedirectCallback)
 43113: {
 43113:     LOG(("nsHttpChannel::ProcessFallback [this=%p]\n", this));
 43113:     nsresult rv;
 43113: 
 80486:     *waitingForRedirectCallback = false;
 80486:     mFallingBack = false;
 43113: 
 43113:     // At this point a load has failed (either due to network problems
 43113:     // or an error returned on the server).  Perform an application
 43113:     // cache fallback if we have a URI to fall back to.
 43113:     if (!mApplicationCache || mFallbackKey.IsEmpty() || mFallbackChannel) {
 43113:         LOG(("  choosing not to fallback [%p,%s,%d]",
 43113:              mApplicationCache.get(), mFallbackKey.get(), mFallbackChannel));
 43113:         return NS_OK;
 43113:     }
 43113: 
 43113:     // Make sure the fallback entry hasn't been marked as a foreign
 43113:     // entry.
 43113:     PRUint32 fallbackEntryType;
 43113:     rv = mApplicationCache->GetTypes(mFallbackKey, &fallbackEntryType);
 43113:     NS_ENSURE_SUCCESS(rv, rv);
 43113: 
 43113:     if (fallbackEntryType & nsIApplicationCache::ITEM_FOREIGN) {
 43113:         // This cache points to a fallback that refers to a different
 43113:         // manifest.  Refuse to fall back.
 43113:         return NS_OK;
 43113:     }
 43113: 
 43113:     NS_ASSERTION(fallbackEntryType & nsIApplicationCache::ITEM_FALLBACK,
 43113:                  "Fallback entry not marked correctly!");
 43113: 
 94876:     // Kill any offline cache entry, and disable offline caching for the
 94876:     // fallback.
 43113:     if (mOfflineCacheEntry) {
 43113:         mOfflineCacheEntry->Doom();
 43113:         mOfflineCacheEntry = 0;
 43113:         mOfflineCacheAccess = 0;
 43113:     }
 43113: 
 80486:     mCacheForOfflineUse = false;
 43113:     mOfflineCacheClientID.Truncate();
 43113:     mOfflineCacheEntry = 0;
 43113:     mOfflineCacheAccess = 0;
 43113: 
 43113:     // Close the current cache entry.
 80486:     CloseCacheEntry(true);
 43113: 
 43113:     // Create a new channel to load the fallback entry.
 43113:     nsRefPtr<nsIChannel> newChannel;
 43113:     rv = gHttpHandler->NewChannel(mURI, getter_AddRefs(newChannel));
 43113:     NS_ENSURE_SUCCESS(rv, rv);
 43113: 
 89558:     rv = SetupReplacementChannel(mURI, newChannel, true, false);
 43113:     NS_ENSURE_SUCCESS(rv, rv);
 43113: 
 43113:     // Make sure the new channel loads from the fallback key.
 43113:     nsCOMPtr<nsIHttpChannelInternal> httpInternal =
 43113:         do_QueryInterface(newChannel, &rv);
 43113:     NS_ENSURE_SUCCESS(rv, rv);
 43113: 
 43113:     rv = httpInternal->SetupFallbackChannel(mFallbackKey.get());
 43113:     NS_ENSURE_SUCCESS(rv, rv);
 43113: 
 43113:     // ... and fallbacks should only load from the cache.
 43113:     PRUint32 newLoadFlags = mLoadFlags | LOAD_REPLACE | LOAD_ONLY_FROM_CACHE;
 43113:     rv = newChannel->SetLoadFlags(newLoadFlags);
 43113: 
 43113:     // Inform consumers about this fake redirect
 48304:     mRedirectChannel = newChannel;
 43113:     PRUint32 redirectFlags = nsIChannelEventSink::REDIRECT_INTERNAL;
 48304: 
 48304:     PushRedirectAsyncFunc(&nsHttpChannel::ContinueProcessFallback);
 48304:     rv = gHttpHandler->AsyncOnChannelRedirect(this, newChannel, redirectFlags);
 48304: 
 48304:     if (NS_SUCCEEDED(rv))
 48304:         rv = WaitForRedirectCallback();
 48304: 
 48304:     if (NS_FAILED(rv)) {
 49375:         AutoRedirectVetoNotifier notifier(this);
 48304:         PopRedirectAsyncFunc(&nsHttpChannel::ContinueProcessFallback);
 48304:         return rv;
 48304:     }
 48304: 
 48304:     // Indicate we are now waiting for the asynchronous redirect callback
 48304:     // if all went OK.
 80486:     *waitingForRedirectCallback = true;
 48304:     return NS_OK;
 48304: }
 48304: 
 48304: nsresult
 48304: nsHttpChannel::ContinueProcessFallback(nsresult rv)
 48304: {
 49375:     AutoRedirectVetoNotifier notifier(this);
 49375: 
 43113:     if (NS_FAILED(rv))
 43113:         return rv;
 43113: 
 48304:     NS_PRECONDITION(mRedirectChannel, "No redirect channel?");
 48304: 
 43113:     // Make sure to do this _after_ calling OnChannelRedirect
 48304:     mRedirectChannel->SetOriginalURI(mOriginalURI);
 48304: 
 48304:     rv = mRedirectChannel->AsyncOpen(mListener, mListenerContext);
 49375:     if (NS_FAILED(rv))
 49375:         return rv;
 43113: 
 43113:     // close down this channel
 43113:     Cancel(NS_BINDING_REDIRECTED);
 43113: 
 49375:     notifier.RedirectSucceeded();
 49375: 
 43113:     // disconnect from our listener
 43113:     mListener = 0;
 43113:     mListenerContext = 0;
 49375: 
 43113:     // and from our callbacks
 43113:     mCallbacks = nsnull;
 43113:     mProgressSink = nsnull;
 43113: 
 80486:     mFallingBack = true;
 43113: 
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: // Determines if a request is a byte range request for a subrange,
 43113: // i.e. is a byte range request, but not a 0- byte range request.
 79445: static bool
 43113: IsSubRangeRequest(nsHttpRequestHead &aRequestHead)
 43113: {
 43113:     if (!aRequestHead.PeekHeader(nsHttp::Range))
 80486:         return false;
 43113:     nsCAutoString byteRange;
 43113:     aRequestHead.GetHeader(nsHttp::Range, byteRange);
 43113:     return !byteRange.EqualsLiteral("bytes=0-");
 43113: }
 43113: 
 43113: nsresult
 99878: nsHttpChannel::OpenCacheEntry(bool usingSSL)
 43113: {
 43113:     nsresult rv;
 43113: 
 93830:     NS_ASSERTION(!mOnCacheEntryAvailableCallback, "Unexpected state");
 80486:     mLoadedFromApplicationCache = false;
 43113: 
 43113:     LOG(("nsHttpChannel::OpenCacheEntry [this=%p]", this));
 43113: 
 43113:     // make sure we're not abusing this function
 43113:     NS_PRECONDITION(!mCacheEntry, "cache entry already open");
 43113: 
 43113:     nsCAutoString cacheKey;
 43113: 
 43113:     if (mRequestHead.Method() == nsHttp::Post) {
 43113:         // If the post id is already set then this is an attempt to replay
 43113:         // a post transaction via the cache.  Otherwise, we need a unique
 43113:         // post id for this transaction.
 43113:         if (mPostID == 0)
 43113:             mPostID = gHttpHandler->GenerateUniqueID();
 43113:     }
 43113:     else if ((mRequestHead.Method() != nsHttp::Get) &&
 54823:              (mRequestHead.Method() != nsHttp::Head)) {
 43113:         // don't use the cache for other types of requests
 43113:         return NS_OK;
 43113:     }
 43113: 
 43113:     if (mResuming) {
 43113:         // We don't support caching for requests initiated
 43113:         // via nsIResumableChannel.
 43113:         return NS_OK;
 43113:     }
 43113: 
 43113:     // Don't cache byte range requests which are subranges, only cache 0-
 43113:     // byte range requests.
 43113:     if (IsSubRangeRequest(mRequestHead))
 43113:         return NS_OK;
 43113: 
 43113:     GenerateCacheKey(mPostID, cacheKey);
 43113: 
 43113:     // Set the desired cache access mode accordingly...
 43113:     nsCacheAccessMode accessRequested;
 53987:     rv = DetermineCacheAccess(&accessRequested);
 53987:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     if (!mApplicationCache && mInheritApplicationCache) {
 43113:         // Pick up an application cache from the notification
 43113:         // callbacks if available
 43113:         nsCOMPtr<nsIApplicationCacheContainer> appCacheContainer;
 43113:         GetCallback(appCacheContainer);
 43113: 
 43113:         if (appCacheContainer) {
 43113:             appCacheContainer->GetApplicationCache(getter_AddRefs(mApplicationCache));
 43113:         }
 43113:     }
 43113: 
 43113:     if (!mApplicationCache &&
 43113:         (mChooseApplicationCache || (mLoadFlags & LOAD_CHECK_OFFLINE_CACHE))) {
 43113:         // We're supposed to load from an application cache, but
 43113:         // one was not supplied by the load group.  Ask the
 43113:         // application cache service to choose one for us.
 43113:         nsCOMPtr<nsIApplicationCacheService> appCacheService =
 43113:             do_GetService(NS_APPLICATIONCACHESERVICE_CONTRACTID);
 43113:         if (appCacheService) {
 43113:             nsresult rv = appCacheService->ChooseApplicationCache
 43113:                 (cacheKey, getter_AddRefs(mApplicationCache));
 43113:             NS_ENSURE_SUCCESS(rv, rv);
 43113:         }
 43113:     }
 43113: 
 43113:     nsCOMPtr<nsICacheSession> session;
 43113: 
 43113:     // If we have an application cache, we check it first.
 43113:     if (mApplicationCache) {
 43113:         nsCAutoString appCacheClientID;
 99879:         rv = mApplicationCache->GetClientID(appCacheClientID);
 99879:         if (NS_SUCCEEDED(rv)) {
 99879:             // We open with ACCESS_READ only, because we don't want to overwrite
 99879:             // the offline cache entry non-atomically. ACCESS_READ will prevent
 99879:             // us from writing to the offline cache as a normal cache entry.
 99879:             mCacheQuery = new HttpCacheQuery(
 99879:                                 this, appCacheClientID,
 99879:                                 nsICache::STORE_OFFLINE, UsingPrivateBrowsing(),
 99879:                                 cacheKey, nsICache::ACCESS_READ,
 99879:                                 mLoadFlags & LOAD_BYPASS_LOCAL_CACHE_IF_BUSY,
 99879:                                 usingSSL, true);
 99366: 
 53987:             mOnCacheEntryAvailableCallback =
 53987:                 &nsHttpChannel::OnOfflineCacheEntryAvailable;
 99879: 
 99879:             rv = mCacheQuery->Dispatch();
 53987: 
 93830:             if (NS_SUCCEEDED(rv))
 53987:                 return NS_OK;
 93830: 
 99878:             mCacheQuery = nsnull;
 93830:             mOnCacheEntryAvailableCallback = nsnull;
 99879:         }
 93829: 
 93829:         // opening cache entry failed
 93830:         return OnOfflineCacheEntryAvailable(nsnull, nsICache::ACCESS_NONE, rv);
 93830:     }
 93830: 
 99878:     return OpenNormalCacheEntry(usingSSL);
 53987: }
 53987: 
 53987: nsresult
 53987: nsHttpChannel::OnOfflineCacheEntryAvailable(nsICacheEntryDescriptor *aEntry,
 53987:                                             nsCacheAccessMode aAccess,
 93830:                                             nsresult aEntryStatus)
 53987: {
 53987:     nsresult rv;
 53987: 
 53987:     if (NS_SUCCEEDED(aEntryStatus)) {
 53987:         // We successfully opened an offline cache session and the entry,
 53987:         // so indicate we will load from the offline cache.
 80486:         mLoadedFromApplicationCache = true;
 53987:         mCacheEntry = aEntry;
 53987:         mCacheAccess = aAccess;
 53987:     }
 53987: 
 99878:     // XXX: shouldn't we fail here? I thought we're supposed to fail the
 99878:     // connection if we can't open an offline cache entry for writing.
 93829:     if (aEntryStatus == NS_ERROR_CACHE_WAIT_FOR_VALIDATION) {
 93829:         LOG(("bypassing local cache since it is busy\n"));
 93829:         // Don't try to load normal cache entry
 93830:         return NS_ERROR_NOT_AVAILABLE;
 93829:     }
 93829: 
 53987:     if (mCanceled && NS_FAILED(mStatus)) {
 53987:         LOG(("channel was canceled [this=%p status=%x]\n", this, mStatus));
 53987:         return mStatus;
 53987:     }
 53987: 
 53987:     if (NS_SUCCEEDED(aEntryStatus))
 93830:         return NS_OK;
 53987: 
 53987:     if (!mCacheForOfflineUse && !mFallbackChannel) {
 53987:         nsCAutoString cacheKey;
 53987:         GenerateCacheKey(mPostID, cacheKey);
 53987: 
 43113:         // Check for namespace match.
 43113:         nsCOMPtr<nsIApplicationCacheNamespace> namespaceEntry;
 43113:         rv = mApplicationCache->GetMatchingNamespace
 43113:             (cacheKey, getter_AddRefs(namespaceEntry));
 43113:         NS_ENSURE_SUCCESS(rv, rv);
 43113: 
 43113:         PRUint32 namespaceType = 0;
 43113:         if (!namespaceEntry ||
 43113:             NS_FAILED(namespaceEntry->GetItemType(&namespaceType)) ||
 43113:             (namespaceType &
 43113:              (nsIApplicationCacheNamespace::NAMESPACE_FALLBACK |
 43113:               nsIApplicationCacheNamespace::NAMESPACE_BYPASS)) == 0) {
 43113:             // When loading from an application cache, only items
 43113:             // on the whitelist or matching a
 94876:             // fallback namespace should hit the network...
 43113:             mLoadFlags |= LOAD_ONLY_FROM_CACHE;
 43113: 
 43113:             // ... and if there were an application cache entry,
 43113:             // we would have found it earlier.
 93830:             return NS_ERROR_CACHE_KEY_NOT_FOUND;
 43113:         }
 43113: 
 43113:         if (namespaceType &
 43113:             nsIApplicationCacheNamespace::NAMESPACE_FALLBACK) {
 43113:             rv = namespaceEntry->GetData(mFallbackKey);
 43113:             NS_ENSURE_SUCCESS(rv, rv);
 43113:         }
 43113:     }
 53987: 
 99878:     bool usingSSL = false;
 99878:     (void) mURI->SchemeIs("https", &usingSSL);
 99878:     return OpenNormalCacheEntry(usingSSL);
 53987: }
 53987: 
 53987: 
 53987: nsresult
 99878: nsHttpChannel::OpenNormalCacheEntry(bool usingSSL)
 53987: {
 53987:     NS_ASSERTION(!mCacheEntry, "We have already mCacheEntry");
 53987: 
 53987:     nsresult rv;
 53987: 
 99879:     bool isPrivate = UsingPrivateBrowsing();
 99879:     nsCacheStoragePolicy storagePolicy = DetermineStoragePolicy(isPrivate);
 99879:     nsDependentCString clientID(
 99879:         GetCacheSessionNameForStoragePolicy(storagePolicy, isPrivate));
 99879: 
 53987:     nsCAutoString cacheKey;
 53987:     GenerateCacheKey(mPostID, cacheKey);
 53987: 
 99879:     nsCacheAccessMode accessRequested;
 53987:     rv = DetermineCacheAccess(&accessRequested);
 95233:     if (NS_FAILED(rv))
 95233:         return rv;
 53987:  
 99879:     mCacheQuery = new HttpCacheQuery(
 99879:                                 this, clientID, storagePolicy,
 99879:                                 UsingPrivateBrowsing(), cacheKey,
 99879:                                 accessRequested,
 99879:                                 mLoadFlags & LOAD_BYPASS_LOCAL_CACHE_IF_BUSY,
 99879:                                 usingSSL, false);
 99879: 
 53987:     mOnCacheEntryAvailableCallback =
 53987:         &nsHttpChannel::OnNormalCacheEntryAvailable;
 99879: 
 99879:     rv = mCacheQuery->Dispatch();
 93830:     if (NS_SUCCEEDED(rv))
 53987:         return NS_OK;
 93830: 
 99878:     mCacheQuery = nsnull;
 93830:     mOnCacheEntryAvailableCallback = nsnull;
 53987: 
 43113:     return rv;
 43113: }
 43113: 
 53987: nsresult
 53987: nsHttpChannel::OnNormalCacheEntryAvailable(nsICacheEntryDescriptor *aEntry,
 53987:                                            nsCacheAccessMode aAccess,
 93830:                                            nsresult aEntryStatus)
 53987: {
 53987:     if (NS_SUCCEEDED(aEntryStatus)) {
 53987:         mCacheEntry = aEntry;
 53987:         mCacheAccess = aAccess;
 53987:     }
 53987: 
 93829:     if (aEntryStatus == NS_ERROR_CACHE_WAIT_FOR_VALIDATION) {
 93829:         LOG(("bypassing local cache since it is busy\n"));
 93829:     }
 93829: 
 53987:     if (mCanceled && NS_FAILED(mStatus)) {
 53987:         LOG(("channel was canceled [this=%p status=%x]\n", this, mStatus));
 53987:         return mStatus;
 53987:     }
 53987: 
 53987:     if ((mLoadFlags & LOAD_ONLY_FROM_CACHE) && NS_FAILED(aEntryStatus))
 53987:         // if this channel is only allowed to pull from the cache, then
 53987:         // we must fail if we were unable to open a cache entry.
 53987:         return NS_ERROR_DOCUMENT_NOT_CACHED;
 53987: 
 53987:     // advance to the next state...
 93830:     return NS_OK;
 53987: }
 53987: 
 43113: 
 43113: nsresult
 43113: nsHttpChannel::OpenOfflineCacheEntryForWriting()
 43113: {
 43113:     nsresult rv;
 43113: 
 43113:     LOG(("nsHttpChannel::OpenOfflineCacheEntryForWriting [this=%p]", this));
 43113: 
 43113:     // make sure we're not abusing this function
 43113:     NS_PRECONDITION(!mOfflineCacheEntry, "cache entry already open");
 43113: 
 79445:     bool offline = gIOService->IsOffline();
 43113:     if (offline) {
 43113:         // only put things in the offline cache while online
 43113:         return NS_OK;
 43113:     }
 43113: 
 43113:     if (mRequestHead.Method() != nsHttp::Get) {
 43113:         // only cache complete documents offline
 43113:         return NS_OK;
 43113:     }
 43113: 
 43113:     // Don't cache byte range requests which are subranges, only cache 0-
 43113:     // byte range requests.
 43113:     if (IsSubRangeRequest(mRequestHead))
 43113:         return NS_OK;
 43113: 
 43113:     nsCAutoString cacheKey;
 43113:     GenerateCacheKey(mPostID, cacheKey);
 43113: 
 43113:     NS_ENSURE_TRUE(!mOfflineCacheClientID.IsEmpty(),
 43113:                    NS_ERROR_NOT_AVAILABLE);
 43113: 
 43113:     nsCOMPtr<nsICacheSession> session;
 43113:     nsCOMPtr<nsICacheService> serv =
 43113:         do_GetService(NS_CACHESERVICE_CONTRACTID, &rv);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     rv = serv->CreateSession(mOfflineCacheClientID.get(),
 43113:                              nsICache::STORE_OFFLINE,
 43113:                              nsICache::STREAM_BASED,
 43113:                              getter_AddRefs(session));
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
100212:     if (mProfileDirectory) {
100212:         rv = session->SetProfileDirectory(mProfileDirectory);
100212:         if (NS_FAILED(rv)) return rv;
100212:     }
100212: 
 93830:     mOnCacheEntryAvailableCallback =
 93830:         &nsHttpChannel::OnOfflineCacheEntryForWritingAvailable;
 93830:     rv = session->AsyncOpenCacheEntry(cacheKey, nsICache::ACCESS_READ_WRITE,
 93830:                                       this, true);
 93830:     if (NS_SUCCEEDED(rv))
 93830:         return NS_OK;
 93830: 
 93830:     mOnCacheEntryAvailableCallback = nsnull;
 93830: 
 93830:     return rv;
 93830: }
 93830: 
 93830: nsresult
 93830: nsHttpChannel::OnOfflineCacheEntryForWritingAvailable(
 93830:     nsICacheEntryDescriptor *aEntry,
 93830:     nsCacheAccessMode aAccess,
 93830:     nsresult aEntryStatus)
 93830: {
 93830:     if (NS_SUCCEEDED(aEntryStatus)) {
 93830:         mOfflineCacheEntry = aEntry;
 93830:         mOfflineCacheAccess = aAccess;
103134:         if (NS_FAILED(aEntry->GetLastModified(&mOfflineCacheLastModifiedTime))) {
103134:             mOfflineCacheLastModifiedTime = 0;
103134:         }
 93830:     }
 93830: 
 93830:     if (aEntryStatus == NS_ERROR_CACHE_WAIT_FOR_VALIDATION) {
 43113:         // access to the cache entry has been denied (because the cache entry
 43113:         // is probably in use by another channel).  Either the cache is being
 43113:         // read from (we're offline) or it's being updated elsewhere.
 93830:         aEntryStatus = NS_OK;
 93830:     }
 93830: 
 93830:     if (mCanceled && NS_FAILED(mStatus)) {
 93830:         LOG(("channel was canceled [this=%p status=%x]\n", this, mStatus));
 93830:         return mStatus;
 93830:     }
 93830: 
 93830:     // advance to the next state...
 93830:     return aEntryStatus;
 43113: }
 43113: 
 71627: // Generates the proper cache-key for this instance of nsHttpChannel
 43113: nsresult
 43113: nsHttpChannel::GenerateCacheKey(PRUint32 postID, nsACString &cacheKey)
 43113: {
 71627:     AssembleCacheKey(mFallbackChannel ? mFallbackKey.get() : mSpec.get(),
 71627:                      postID, cacheKey);
 71627:     return NS_OK;
 71627: }
 71627: 
 71627: // Assembles a cache-key from the given pieces of information and |mLoadFlags|
 71627: void
 71627: nsHttpChannel::AssembleCacheKey(const char *spec, PRUint32 postID,
 71627:                                 nsACString &cacheKey)
 71627: {
 43113:     cacheKey.Truncate();
 43113: 
 43113:     if (mLoadFlags & LOAD_ANONYMOUS) {
 43113:         cacheKey.AssignLiteral("anon&");
 43113:     }
 43113: 
 43113:     if (postID) {
 43113:         char buf[32];
 43113:         PR_snprintf(buf, sizeof(buf), "id=%x&", postID);
 43113:         cacheKey.Append(buf);
 43113:     }
 43113: 
 43113:     if (!cacheKey.IsEmpty()) {
 43113:         cacheKey.AppendLiteral("uri=");
 43113:     }
 43113: 
 43113:     // Strip any trailing #ref from the URL before using it as the key
 43113:     const char *p = strchr(spec, '#');
 43113:     if (p)
 43113:         cacheKey.Append(spec, p - spec);
 43113:     else
 43113:         cacheKey.Append(spec);
 43113: }
 43113: 
 43113: // UpdateExpirationTime is called when a new response comes in from the server.
 43113: // It updates the stored response-time and sets the expiration time on the
 43113: // cache entry.  
 43113: //
 43113: // From section 13.2.4 of RFC2616, we compute expiration time as follows:
 43113: //
 43113: //    timeRemaining = freshnessLifetime - currentAge
 43113: //    expirationTime = now + timeRemaining
 43113: // 
 43113: nsresult
 43113: nsHttpChannel::UpdateExpirationTime()
 43113: {
 43113:     NS_ENSURE_TRUE(mResponseHead, NS_ERROR_FAILURE);
 43113: 
 43113:     nsresult rv;
 43113: 
 43113:     PRUint32 expirationTime = 0;
 43113:     if (!mResponseHead->MustValidate()) {
 43113:         PRUint32 freshnessLifetime = 0;
 43113: 
 43113:         rv = mResponseHead->ComputeFreshnessLifetime(&freshnessLifetime);
 43113:         if (NS_FAILED(rv)) return rv;
 43113: 
 43113:         if (freshnessLifetime > 0) {
 43113:             PRUint32 now = NowInSeconds(), currentAge = 0;
 43113: 
 43113:             rv = mResponseHead->ComputeCurrentAge(now, mRequestTime, &currentAge); 
 43113:             if (NS_FAILED(rv)) return rv;
 43113: 
 43113:             LOG(("freshnessLifetime = %u, currentAge = %u\n",
 43113:                 freshnessLifetime, currentAge));
 43113: 
 43113:             if (freshnessLifetime > currentAge) {
 43113:                 PRUint32 timeRemaining = freshnessLifetime - currentAge;
 43113:                 // be careful... now + timeRemaining may overflow
 43113:                 if (now + timeRemaining < now)
 43113:                     expirationTime = PRUint32(-1);
 43113:                 else
 43113:                     expirationTime = now + timeRemaining;
 43113:             }
 43113:             else
 43113:                 expirationTime = now;
 43113:         }
 43113:     }
 43113: 
 43113:     rv = mCacheEntry->SetExpirationTime(expirationTime);
 43113:     NS_ENSURE_SUCCESS(rv, rv);
 43113: 
 43113:     if (mOfflineCacheEntry) {
 43113:         rv = mOfflineCacheEntry->SetExpirationTime(expirationTime);
 43113:         NS_ENSURE_SUCCESS(rv, rv);
 43113:     }
 43113: 
 43113:     return NS_OK;
 43113: }
 43113: 
 99878: NS_IMETHODIMP
 99878: HttpCacheQuery::OnCacheEntryDoomed(nsresult)
 99878: {
 99878:     return NS_ERROR_UNEXPECTED;
 99878: }
 99878: 
 99879: nsresult
 99879: HttpCacheQuery::Dispatch()
 99879: {
 99879:     MOZ_ASSERT(NS_IsMainThread());
 99879: 
 99879:     nsresult rv;
 99879: 
 99879:     // XXX: Start the cache service; otherwise DispatchToCacheIOThread will
 99879:     // fail.
 99879:     nsCOMPtr<nsICacheService> service = 
 99879:         do_GetService(NS_CACHESERVICE_CONTRACTID, &rv);
 99879: 
 99879:     // Ensure the stream transport service gets initialized on the main thread
 99879:     if (NS_SUCCEEDED(rv)) {
 99879:         nsCOMPtr<nsIStreamTransportService> sts =
 99879:             do_GetService(kStreamTransportServiceCID, &rv);
 99879:     }
 99879: 
 99879:     if (NS_SUCCEEDED(rv)) {
 99879:         rv = service->GetCacheIOTarget(getter_AddRefs(mCacheThread));
 99879:     }
 99879: 
 99879:     if (NS_SUCCEEDED(rv)) {
 99879:         rv = mCacheThread->Dispatch(this, NS_DISPATCH_NORMAL);
 99879:     }
 99879: 
 99879:     return rv;
 99879: }
 99879: 
 99879: NS_IMETHODIMP
 99879: HttpCacheQuery::Run()
 99879: {
 99879:     nsresult rv;
 99879:     if (!NS_IsMainThread()) {
 99879:         AssertOnCacheThread();
 99879: 
 99879:         nsCOMPtr<nsICacheService> serv =
 99879:             do_GetService(NS_CACHESERVICE_CONTRACTID, &rv);
 99879:         nsCOMPtr<nsICacheSession> session;
 99879:         if (NS_SUCCEEDED(rv)) {
 99879:             rv = serv->CreateSession(mClientID.get(), mStoragePolicy,
 99879:                                      nsICache::STREAM_BASED,
 99879:                                      getter_AddRefs(session));
 99879:         }
 99879:         if (NS_SUCCEEDED(rv)) {
 99879:             rv = session->SetIsPrivate(mUsingPrivateBrowsing);
 99879:         }
 99879:         if (NS_SUCCEEDED(rv)) {
 99879:             rv = session->SetDoomEntriesIfExpired(false);
 99879:         }
 99879:         if (NS_SUCCEEDED(rv)) {
 99879:             // AsyncOpenCacheEntry isn't really async when its called on the
 99879:             // cache service thread.
 99879:             rv = session->AsyncOpenCacheEntry(mCacheKey, mAccessToRequest, this,
 99879:                                               mNoWait);
 99879:         }
 99879:         if (NS_FAILED(rv)) {
 99882:             LOG(("Failed to open cache entry -- calling OnCacheEntryAvailable "
 99882:                  "directly."));
 99879:             rv = OnCacheEntryAvailable(nsnull, 0, rv);
 99879:         }
 99879:     } else {
 99879:         // break cycles
 99879:         nsCOMPtr<nsICacheListener> channel = mChannel.forget();
 99879:         mCacheThread = nsnull;
 99879:         nsCOMPtr<nsICacheEntryDescriptor> entry = mCacheEntry.forget();
 99879: 
 99879:         rv = channel->OnCacheEntryAvailable(entry, mCacheAccess, mStatus);
 99879:     }
 99879:     
 99879:     return rv;
 99879: }
 99879: 
 99878: NS_IMETHODIMP
 99878: HttpCacheQuery::OnCacheEntryAvailable(nsICacheEntryDescriptor *entry,
 99878:                                       nsCacheAccessMode access,
 99878:                                       nsresult status)
 99878: 
 99878: {
 99882:     LOG(("HttpCacheQuery::OnCacheEntryAvailable [channel=%p entry=%p "
 99882:          "access=%x status=%x, mRunConut=%d]\n", mChannel.get(), entry, access,
 99882:          status, PRIntn(mRunCount)));
 99882: 
 99882:     // XXX Bug 759805: Sometimes we will call this method directly from
 99882:     // HttpCacheQuery::Run when AsyncOpenCacheEntry fails, but
 99882:     // AsyncOpenCacheEntry will also call this method. As a workaround, we just
 99882:     // ensure we only execute this code once.
 99882:     NS_ENSURE_TRUE(mRunCount == 0, NS_ERROR_UNEXPECTED);
 99882:     ++mRunCount;
 99882: 
 99879:     AssertOnCacheThread();
 99879: 
 99878:     mCacheEntry = entry;
 99878:     mCacheAccess = access;
 99878:     mStatus = status;
 99878: 
 99878:     nsresult rv = CheckCache();
 99878:     if (NS_FAILED(rv))
 99878:         NS_WARNING("cache check failed");
 99878: 
 99880:     if (mCachedContentIsValid) {
 99880:         char* cacheDeviceID = nsnull;
 99880:         mCacheEntry->GetDeviceID(&cacheDeviceID);
 99880:         if (cacheDeviceID) {
 99880:             if (!strcmp(cacheDeviceID, kDiskDeviceID)) {
 99880:                 mCacheEntryDeviceTelemetryID
102655:                     = mozilla::Telemetry::HTTP_DISK_CACHE_DISPOSITION_2;
 99880:             } else if (!strcmp(cacheDeviceID, kMemoryDeviceID)) {
 99880:                 mCacheEntryDeviceTelemetryID
102655:                     = mozilla::Telemetry::HTTP_MEMORY_CACHE_DISPOSITION_2;
 99880:             } else if (!strcmp(cacheDeviceID, kOfflineDeviceID)) {
 99880:                 mCacheEntryDeviceTelemetryID
102655:                     = mozilla::Telemetry::HTTP_OFFLINE_CACHE_DISPOSITION_2;
 99880:             } else {
 99880:                 MOZ_NOT_REACHED("unknown cache device ID");
 99880:             }
 99880: 
 99880:             delete cacheDeviceID;
 99880:         }
 99880:     }
 99880: 
 99879:     rv = NS_DispatchToMainThread(this);
 99878:     return rv;
 99878: }
 99878: 
 43113: nsresult
 99878: HttpCacheQuery::CheckCache()
 43113: {
 99879:     AssertOnCacheThread();
 99879: 
 43113:     nsresult rv = NS_OK;
 43113: 
 99878:     LOG(("HttpCacheQuery::CheckCache enter [channel=%p entry=%p access=%d]",
 99878:         mChannel.get(), mCacheEntry.get(), mCacheAccess));
 43113:     
 43113:     // Be pessimistic: assume the cache entry has no useful data.
 80486:     mCachedContentIsValid = false;
 43113: 
 43113:     // Don't proceed unless we have opened a cache entry for reading.
 43113:     if (!mCacheEntry || !(mCacheAccess & nsICache::ACCESS_READ))
 43113:         return NS_OK;
 43113: 
 43113:     nsXPIDLCString buf;
 43113: 
 43113:     // Get the method that was used to generate the cached response
 43113:     rv = mCacheEntry->GetMetaDataElement("request-method", getter_Copies(buf));
 43113:     NS_ENSURE_SUCCESS(rv, rv);
 43113: 
 78638:     nsHttpAtom method = nsHttp::ResolveAtom(buf);
 43113:     if (method == nsHttp::Head) {
 43113:         // The cached response does not contain an entity.  We can only reuse
 43113:         // the response if the current request is also HEAD.
 43113:         if (mRequestHead.Method() != nsHttp::Head)
 43113:             return NS_OK;
 43113:     }
 43113:     buf.Adopt(0);
 43113: 
 43113:     // We'll need this value in later computations...
 43113:     PRUint32 lastModifiedTime;
 43113:     rv = mCacheEntry->GetLastModified(&lastModifiedTime);
 43113:     NS_ENSURE_SUCCESS(rv, rv);
 43113: 
 43113:     // Determine if this is the first time that this cache entry
 43113:     // has been accessed during this session.
 79445:     bool fromPreviousSession =
 43113:             (gHttpHandler->SessionStartTime() > lastModifiedTime);
 43113: 
 43113:     // Get the cached HTTP response headers
 43113:     rv = mCacheEntry->GetMetaDataElement("response-head", getter_Copies(buf));
 43113:     NS_ENSURE_SUCCESS(rv, rv);
 43113: 
 43113:     // Parse the cached HTTP response headers
 43113:     mCachedResponseHead = new nsHttpResponseHead();
 43113:     rv = mCachedResponseHead->Parse((char *) buf.get());
 43113:     NS_ENSURE_SUCCESS(rv, rv);
 43113:     buf.Adopt(0);
 43113: 
 99874:     bool isCachedRedirect = WillRedirect(mCachedResponseHead);
 99874: 
 99874:     // Do not return 304 responses from the cache, and also do not return
 99874:     // any other non-redirect 3xx responses from the cache (see bug 759043).
 99874:     NS_ENSURE_TRUE((mCachedResponseHead->Status() / 100 != 3) ||
 99874:                    isCachedRedirect, NS_ERROR_ABORT);
 99874: 
 43113:     // Don't bother to validate items that are read-only,
 43113:     // unless they are read-only because of INHIBIT_CACHING or because
 43113:     // we're updating the offline cache.
 43113:     // Don't bother to validate if this is a fallback entry.
 43113:     if (!mCacheForOfflineUse &&
 43113:         (mLoadedFromApplicationCache ||
 43113:          (mCacheAccess == nsICache::ACCESS_READ &&
 99878:           !(mLoadFlags & nsIRequest::INHIBIT_CACHING)) ||
 43113:          mFallbackChannel)) {
103136:         rv = OpenCacheInputStream(true);
 99874:         if (NS_SUCCEEDED(rv)) {
 80486:             mCachedContentIsValid = true;
 99874:             // XXX: Isn't the cache entry already valid?
 99874:             MaybeMarkCacheEntryValid(this, mCacheEntry, mCacheAccess);
 99874:         }
 99874:         return rv;
 99874:     }
 43113: 
 61973:     mCustomConditionalRequest =
 61973:         mRequestHead.PeekHeader(nsHttp::If_Modified_Since) ||
 61973:         mRequestHead.PeekHeader(nsHttp::If_None_Match) ||
 61973:         mRequestHead.PeekHeader(nsHttp::If_Unmodified_Since) ||
 61973:         mRequestHead.PeekHeader(nsHttp::If_Match) ||
 61973:         mRequestHead.PeekHeader(nsHttp::If_Range);
 61973: 
 43113:     if (method != nsHttp::Head && !isCachedRedirect) {
 43113:         // If the cached content-length is set and it does not match the data
 43113:         // size of the cached content, then the cached response is partial...
 43113:         // either we need to issue a byte range request or we need to refetch
 43113:         // the entire document.
 99874:         //
 99874:         // We exclude redirects from this check because we (usually) strip the
 99874:         // entity when we store the cache entry, and even if we didn't, we
 99874:         // always ignore a cached redirect's entity anyway. See bug 759043.
 64617:         PRInt64 contentLength = mCachedResponseHead->ContentLength();
 64617:         if (contentLength != PRInt64(-1)) {
 43113:             PRUint32 size;
 43113:             rv = mCacheEntry->GetDataSize(&size);
 43113:             NS_ENSURE_SUCCESS(rv, rv);
 43113: 
 64617:             if (PRInt64(size) != contentLength) {
 43113:                 LOG(("Cached data size does not match the Content-Length header "
 51740:                      "[content-length=%lld size=%u]\n", PRInt64(contentLength), size));
 61973: 
 79445:                 bool hasContentEncoding =
 61973:                     mCachedResponseHead->PeekHeader(nsHttp::Content_Encoding)
 61973:                     != nsnull;
 64617:                 if ((PRInt64(size) < contentLength) &&
 61973:                      size > 0 &&
 61973:                      !hasContentEncoding &&
 61973:                      mCachedResponseHead->IsResumable() &&
 61973:                      !mCustomConditionalRequest &&
 61973:                      !mCachedResponseHead->NoStore()) {
 99874:                     // looks like a partial entry we can reuse; add If-Range
 99874:                     // and Range headers.
 43113:                     rv = SetupByteRangeRequest(size);
 99874:                     mCachedContentIsPartial = NS_SUCCEEDED(rv);
 99874:                     if (mCachedContentIsPartial) {
103136:                         rv = OpenCacheInputStream(false);
 99874:                     } else {
 99874:                         // Make the request unconditional again.
 99874:                         mRequestHead.ClearHeader(nsHttp::Range);
 99874:                         mRequestHead.ClearHeader(nsHttp::If_Range);
 99874:                     }
 99874:                 }
 99874:                 return rv;
 43113:             }
 43113:         }
 43113:     }
 43113: 
 79445:     bool doValidation = false;
 79445:     bool canAddImsHeader = true;
 43113: 
 70828:     // Cached entry is not the entity we request (see bug #633743)
 70828:     if (ResponseWouldVary()) {
 70828:         LOG(("Validating based on Vary headers returning TRUE\n"));
 80486:         canAddImsHeader = false;
 80486:         doValidation = true;
 70828:     }
 70828:     // If the LOAD_FROM_CACHE flag is set, any cached data can simply be used
 99878:     else if (mLoadFlags & nsIRequest::LOAD_FROM_CACHE) {
 43113:         LOG(("NOT validating based on LOAD_FROM_CACHE load flag\n"));
 80486:         doValidation = false;
 43113:     }
 43113:     // If the VALIDATE_ALWAYS flag is set, any cached data won't be used until
 43113:     // it's revalidated with the server.
 99878:     else if (mLoadFlags & nsIRequest::VALIDATE_ALWAYS) {
 43113:         LOG(("Validating based on VALIDATE_ALWAYS load flag\n"));
 80486:         doValidation = true;
 43113:     }
 43113:     // Even if the VALIDATE_NEVER flag is set, there are still some cases in
 43113:     // which we must validate the cached response with the server.
 99878:     else if (mLoadFlags & nsIRequest::VALIDATE_NEVER) {
 43113:         LOG(("VALIDATE_NEVER set\n"));
 43113:         // if no-store or if no-cache and ssl, validate cached response (see
 43113:         // bug 112564 for an explanation of this logic)
 43113:         if (mCachedResponseHead->NoStore() ||
 99878:            (mCachedResponseHead->NoCache() && mUsingSSL)) {
 43113:             LOG(("Validating based on (no-store || (no-cache && ssl)) logic\n"));
 80486:             doValidation = true;
 43113:         }
 43113:         else {
 43113:             LOG(("NOT validating based on VALIDATE_NEVER load flag\n"));
 80486:             doValidation = false;
 43113:         }
 43113:     }
 43113:     // check if validation is strictly required...
 43113:     else if (mCachedResponseHead->MustValidate()) {
 43113:         LOG(("Validating based on MustValidate() returning TRUE\n"));
 80486:         doValidation = true;
 43113:     }
 43113: 
 43113:     else if (MustValidateBasedOnQueryUrl()) {
 43113:         LOG(("Validating based on RFC 2616 section 13.9 "
 43113:              "(query-url w/o explicit expiration-time)\n"));
 80486:         doValidation = true;
 43113:     }
 43113:     // Check if the cache entry has expired...
 43113:     else {
 43113:         PRUint32 time = 0; // a temporary variable for storing time values...
 43113: 
 43113:         rv = mCacheEntry->GetExpirationTime(&time);
 43113:         NS_ENSURE_SUCCESS(rv, rv);
 43113: 
 43113:         if (NowInSeconds() <= time)
 80486:             doValidation = false;
 43113:         else if (mCachedResponseHead->MustValidateIfExpired())
 80486:             doValidation = true;
 99878:         else if (mLoadFlags & nsIRequest::VALIDATE_ONCE_PER_SESSION) {
 43113:             // If the cached response does not include expiration infor-
 43113:             // mation, then we must validate the response, despite whether
 43113:             // or not this is the first access this session.  This behavior
 43113:             // is consistent with existing browsers and is generally expected
 43113:             // by web authors.
 43113:             rv = mCachedResponseHead->ComputeFreshnessLifetime(&time);
 43113:             NS_ENSURE_SUCCESS(rv, rv);
 43113: 
 43113:             if (time == 0)
 80486:                 doValidation = true;
 43113:             else
 43113:                 doValidation = fromPreviousSession;
 43113:         }
 43113:         else
 80486:             doValidation = true;
 43113: 
 43113:         LOG(("%salidating based on expiration time\n", doValidation ? "V" : "Not v"));
 43113:     }
 43113: 
 43113:     if (!doValidation && mRequestHead.PeekHeader(nsHttp::If_Match) &&
 43113:         (method == nsHttp::Get || method == nsHttp::Head)) {
 43113:         const char *requestedETag, *cachedETag;
 43113:         cachedETag = mCachedResponseHead->PeekHeader(nsHttp::ETag);
 43113:         requestedETag = mRequestHead.PeekHeader(nsHttp::If_Match);
 43113:         if (cachedETag && (!strncmp(cachedETag, "W/", 2) ||
 43113:             strcmp(requestedETag, cachedETag))) {
 43113:             // User has defined If-Match header, if the cached entry is not 
 43113:             // matching the provided header value or the cached ETag is weak,
 43113:             // force validation.
 80486:             doValidation = true;
 43113:         }
 43113:     }
 43113: 
 43113:     if (!doValidation) {
 43113:         //
 43113:         // Check the authorization headers used to generate the cache entry.
 43113:         // We must validate the cache entry if:
 43113:         //
 43113:         // 1) the cache entry was generated prior to this session w/
 43113:         //    credentials (see bug 103402).
 43113:         // 2) the cache entry was generated w/o credentials, but would now
 43113:         //    require credentials (see bug 96705).
 43113:         //
 43113:         // NOTE: this does not apply to proxy authentication.
 43113:         //
 43113:         mCacheEntry->GetMetaDataElement("auth", getter_Copies(buf));
 43113:         doValidation =
 43113:             (fromPreviousSession && !buf.IsEmpty()) ||
 43113:             (buf.IsEmpty() && mRequestHead.PeekHeader(nsHttp::Authorization));
 43113:     }
 43113: 
 63794:     // Bug #561276: We maintain a chain of cache-keys which returns cached
 63794:     // 3xx-responses (redirects) in order to detect cycles. If a cycle is
 63794:     // found, ignore the cached response and hit the net. Otherwise, use
 63794:     // the cached response and add the cache-key to the chain. Note that
 63794:     // a limited number of redirects (cached or not) is allowed and is
 63794:     // enforced independently of this mechanism
 63794:     if (!doValidation && isCachedRedirect) {
 63794:         if (!mRedirectedCachekeys)
 63794:             mRedirectedCachekeys = new nsTArray<nsCString>();
 99878:         else if (mRedirectedCachekeys->Contains(mCacheKey))
 80486:             doValidation = true;
 63794: 
 63794:         LOG(("Redirection-chain %s key %s\n",
 99878:              doValidation ? "contains" : "does not contain", mCacheKey.get()));
 63794: 
 63794:         // Append cacheKey if not in the chain already
 63794:         if (!doValidation)
 99878:             mRedirectedCachekeys->AppendElement(mCacheKey);
 43113:     }
 43113: 
 43113:     mCachedContentIsValid = !doValidation;
 43113: 
 43113:     if (doValidation) {
 43113:         //
 43113:         // now, we are definitely going to issue a HTTP request to the server.
 43113:         // make it conditional if possible.
 43113:         //
 43113:         // do not attempt to validate no-store content, since servers will not
 43113:         // expect it to be cached.  (we only keep it in our cache for the
 43113:         // purposes of back/forward, etc.)
 43113:         //
 43113:         // the request method MUST be either GET or HEAD (see bug 175641).
 43113:         //
 43113:         // do not override conditional headers when consumer has defined its own
 43113:         if (!mCachedResponseHead->NoStore() &&
 43113:             (mRequestHead.Method() == nsHttp::Get ||
 43113:              mRequestHead.Method() == nsHttp::Head) &&
 43113:              !mCustomConditionalRequest) {
 43113:             const char *val;
 43113:             // Add If-Modified-Since header if a Last-Modified was given
 43113:             // and we are allowed to do this (see bugs 510359 and 269303)
 43113:             if (canAddImsHeader) {
 43113:                 val = mCachedResponseHead->PeekHeader(nsHttp::Last_Modified);
 43113:                 if (val)
 43113:                     mRequestHead.SetHeader(nsHttp::If_Modified_Since,
 43113:                                            nsDependentCString(val));
 43113:             }
 43113:             // Add If-None-Match header if an ETag was given in the response
 43113:             val = mCachedResponseHead->PeekHeader(nsHttp::ETag);
 43113:             if (val)
 43113:                 mRequestHead.SetHeader(nsHttp::If_None_Match,
 43113:                                        nsDependentCString(val));
 78427:             mDidReval = true;
 43113:         }
 43113:     }
 43113: 
 99874:     if (mCachedContentIsValid || mDidReval) {
103136:         rv = OpenCacheInputStream(mCachedContentIsValid);
 99874:         if (NS_FAILED(rv)) {
 99874:             // If we can't get the entity then we have to act as though we
 99874:             // don't have the cache entry.
 99874:             if (mDidReval) {
 99874:                 // Make the request unconditional again.
 99874:                 mRequestHead.ClearHeader(nsHttp::If_Modified_Since);
 99874:                 mRequestHead.ClearHeader(nsHttp::ETag);
 99874:                 mDidReval = false;
 99874:             }
 99874:             mCachedContentIsValid = false;
 99874:         }
 99874:     }
 99874: 
 99874:     if (mCachedContentIsValid) {
 99874:         // XXX: Isn't the cache entry already valid?
 99874:         MaybeMarkCacheEntryValid(this, mCacheEntry, mCacheAccess);
 99874:     }
 99874: 
 99874:     LOG(("nsHTTPChannel::CheckCache exit [this=%p doValidation=%d]\n",
 99874:          this, doValidation));
 99874:     return rv;
 43113: }
 43113: 
 99879: /*static*/ inline bool
 99879: HttpCacheQuery::HasQueryString(nsHttpAtom method, nsIURI * uri)
 99879: {
 99879:     // Must be called on the main thread because nsIURI does not implement
 99879:     // thread-safe QueryInterface.
 99879:     MOZ_ASSERT(NS_IsMainThread());
 99879: 
 99879:     if (method != nsHttp::Get && method != nsHttp::Head)
 99879:         return false;
 99879: 
 99879:     nsCAutoString query;
 99879:     nsCOMPtr<nsIURL> url = do_QueryInterface(uri);
 99879:     nsresult rv = url->GetQuery(query);
 99879:     return NS_SUCCEEDED(rv) && !query.IsEmpty();
 99879: }
 99879: 
 79445: bool
 99878: HttpCacheQuery::MustValidateBasedOnQueryUrl() const
 43113: {
 99879:     AssertOnCacheThread();
 99879: 
 43113:     // RFC 2616, section 13.9 states that GET-requests with a query-url
 43113:     // MUST NOT be treated as fresh unless the server explicitly provides
 43113:     // an expiration-time in the response. See bug #468594
 43113:     // Section 13.2.1 (6th paragraph) defines "explicit expiration time"
 99879:     if (mHasQueryString)
 43113:     {
 43113:         PRUint32 tmp; // we don't need the value, just whether it's set
 99879:         nsresult rv = mCachedResponseHead->GetExpiresValue(&tmp);
 43113:         if (NS_FAILED(rv)) {
 43113:             rv = mCachedResponseHead->GetMaxAgeValue(&tmp);
 43113:             if (NS_FAILED(rv)) {
 80486:                 return true;
 80486:             }
 80486:         }
 80486:     }
 80486:     return false;
 43113: }
 43113: 
 43113: 
 99873: bool
 99873: nsHttpChannel::ShouldUpdateOfflineCacheEntry()
 43113: {
 99873:     if (!mCacheForOfflineUse || !mOfflineCacheEntry) {
 99873:         return false;
 43113:     }
 43113: 
 43113:     // if we're updating the cache entry, update the offline cache entry too
 43113:     if (mCacheEntry && (mCacheAccess & nsICache::ACCESS_WRITE)) {
 99873:         return true;
 43113:     }
 43113: 
 43113:     // if there's nothing in the offline cache, add it
 43113:     if (mOfflineCacheEntry && (mOfflineCacheAccess == nsICache::ACCESS_WRITE)) {
 99873:         return true;
 43113:     }
 43113: 
 43113:     // if the document is newer than the offline entry, update it
 43113:     PRUint32 docLastModifiedTime;
 43113:     nsresult rv = mResponseHead->GetLastModifiedValue(&docLastModifiedTime);
 43113:     if (NS_FAILED(rv)) {
 99873:         return true;
 43113:     }
 43113: 
103134:     if (mOfflineCacheLastModifiedTime == 0) {
 99873:         return false;
 99873:     }
 43113: 
103134:     if (docLastModifiedTime > mOfflineCacheLastModifiedTime) {
 99873:         return true;
 99873:     }
 99873: 
 99873:     return false;
 43113: }
 43113: 
 43113: nsresult
103136: HttpCacheQuery::OpenCacheInputStream(bool startBuffering)
 43113: {
 99879:     AssertOnCacheThread();
 99879: 
 99878:     if (mUsingSSL) {
 99874:         nsresult rv = mCacheEntry->GetSecurityInfo(
 99874:                                       getter_AddRefs(mCachedSecurityInfo));
 99874:         if (NS_FAILED(rv)) {
 99874:             LOG(("failed to parse security-info [channel=%p, entry=%p]",
 99874:                  this, mCacheEntry.get()));
 99874:             NS_WARNING("failed to parse security-info");
 99874:             return rv;
 99874:         }
 99874:         MOZ_ASSERT(mCachedSecurityInfo);
 99874:         if (!mCachedSecurityInfo) {
 99874:             LOG(("mCacheEntry->GetSecurityInfo returned success but did not "
 99874:                  "return the security info [channel=%p, entry=%p]",
 99874:                  this, mCacheEntry.get()));
 99874:             return NS_ERROR_UNEXPECTED; // XXX error code
 99874:         }
 99874:     }
 99874: 
 99874:     nsresult rv = NS_OK;
 99874: 
 99874:     // Keep the conditions below in sync with the conditions in ReadFromCache.
 99874: 
 99874:     if (WillRedirect(mCachedResponseHead)) {
 99874:         // Do not even try to read the entity for a redirect because we do not
 99874:         // return an entity to the application when we process redirects.
 99874:         LOG(("Will skip read of cached redirect entity\n"));
 99874:         return NS_OK;
 99874:     }
 99874: 
 99878:     if ((mLoadFlags & nsICachingChannel::LOAD_ONLY_IF_MODIFIED) &&
 99878:         !mCachedContentIsPartial) {
 99874:         // For LOAD_ONLY_IF_MODIFIED, we usually don't have to deal with the
 99874:         // cached entity. 
 99874:         if (!mCacheForOfflineUse) {
 99874:             LOG(("Will skip read from cache based on LOAD_ONLY_IF_MODIFIED "
 99874:                  "load flag\n"));
 99874:             return NS_OK;
 99874:         }
 99874: 
 99874:         // If offline caching has been requested and the offline cache needs
 99874:         // updating, we must complete the call even if the main cache entry
 99874:         // is up to date. We don't know yet for sure whether the offline
 99874:         // cache needs updating because at this point we haven't opened it
 99874:         // for writing yet, so we have to start reading the cached entity now
 99874:         // just in case.
 99874:         LOG(("May skip read from cache based on LOAD_ONLY_IF_MODIFIED "
 99874:               "load flag\n"));
 99874:     }
 99874: 
103136:     // Open an input stream for the entity, so that the call to OpenInputStream
103136:     // happens off the main thread.
103136:     nsCOMPtr<nsIInputStream> stream;
103136:     rv = mCacheEntry->OpenInputStream(0, getter_AddRefs(stream));
103136: 
103136:     if (NS_FAILED(rv)) {
103136:         LOG(("Failed to open cache input stream [channel=%p, "
103136:              "mCacheEntry=%p]", mChannel.get(), mCacheEntry.get()));
103136:         return rv;
103136:     }
103136: 
103136:     if (!startBuffering) {
103136:         // We do not connect the stream to the stream transport service if we
103136:         // have to validate the entry with the server. If we did, we would get
103136:         // into a race condition between the stream transport service reading
103136:         // the existing contents and the opening of the cache entry's output
103136:         // stream to write the new contents in the case where we get a non-304
103136:         // response.
103136:         LOG(("Opened cache input stream without buffering [channel=%p, "
103136:               "mCacheEntry=%p, stream=%p]", mChannel.get(),
103136:               mCacheEntry.get(), stream.get()));
103136:         mCacheInputStream.takeOver(stream);
103136:         return rv;
103136:     }
103136: 
103136:     // Have the stream transport service start reading the entity on one of its
103136:     // background threads.
103136:     
103136:     nsCOMPtr<nsITransport> transport;
 99874:     nsCOMPtr<nsIInputStream> wrapper;
 99874: 
 99874:     nsCOMPtr<nsIStreamTransportService> sts =
 99874:         do_GetService(kStreamTransportServiceCID, &rv);
 99874:     if (NS_SUCCEEDED(rv)) {
 99874:         rv = sts->CreateInputTransport(stream, PRInt64(-1), PRInt64(-1),
 99874:                                         true, getter_AddRefs(transport));
 99874:     }
 99874:     if (NS_SUCCEEDED(rv)) {
 99874:         rv = transport->OpenInputStream(0, 0, 0, getter_AddRefs(wrapper));
 99874:     }
 99874:     if (NS_SUCCEEDED(rv)) {
 99874:         LOG(("Opened cache input stream [channel=%p, wrapper=%p, "
 99874:               "transport=%p, stream=%p]", this, wrapper.get(),
 99874:               transport.get(), stream.get()));
 99874:     } else {
 99874:         LOG(("Failed to open cache input stream [channel=%p, "
 99874:               "wrapper=%p, transport=%p, stream=%p]", this,
 99874:               wrapper.get(), transport.get(), stream.get()));
 99874:     
 99874:         stream->Close();
 99874:         return rv;
 99874:     }
 99874: 
103136:     mCacheInputStream.takeOver(wrapper);
103136: 
103136:     return NS_OK;
103136: }
103136: 
 99874: // Actually process the cached response that we started to handle in CheckCache
 99874: // and/or StartBufferingCachedEntity.
 99874: nsresult
 99874: nsHttpChannel::ReadFromCache(bool alreadyMarkedValid)
 99874: {
 43113:     NS_ENSURE_TRUE(mCacheEntry, NS_ERROR_FAILURE);
 43113:     NS_ENSURE_TRUE(mCachedContentIsValid, NS_ERROR_FAILURE);
 43113: 
 43113:     LOG(("nsHttpChannel::ReadFromCache [this=%p] "
 43113:          "Using cached copy of: %s\n", this, mSpec.get()));
 43113: 
 46790:     if (mCachedResponseHead)
 43113:         mResponseHead = mCachedResponseHead;
 43113: 
 88544:     UpdateInhibitPersistentCachingFlag();
 88544: 
 43113:     // if we don't already have security info, try to get it from the cache 
 43113:     // entry. there are two cases to consider here: 1) we are just reading
 43113:     // from the cache, or 2) this may be due to a 304 not modified response,
 43113:     // in which case we could have security info from a socket transport.
 43113:     if (!mSecurityInfo)
 99874:         mSecurityInfo = mCachedSecurityInfo;
 99874: 
 99874:     if (!alreadyMarkedValid && !mCachedContentIsPartial) {
 99874:         // We validated the entry, and we have write access to the cache, so
 99874:         // mark the cache entry as valid in order to allow others access to
 99874:         // this cache entry.
 99874:         //
 99874:         // TODO: This should be done asynchronously so we don't take the cache
 99874:         // service lock on the main thread.
 99874:         MaybeMarkCacheEntryValid(this, mCacheEntry, mCacheAccess);
 99874:     }
 99874: 
 99874:     nsresult rv;
 99874: 
 99874:     // Keep the conditions below in sync with the conditions in
 99874:     // StartBufferingCachedEntity.
 99874: 
 99874:     if (WillRedirect(mResponseHead)) {
 99874:         // TODO: Bug 759040 - We should call HandleAsyncRedirect directly here,
 99874:         // to avoid event dispatching latency.
103136:         MOZ_ASSERT(!mCacheInputStream);
 99874:         LOG(("Skipping skip read of cached redirect entity\n"));
 43113:         return AsyncCall(&nsHttpChannel::HandleAsyncRedirect);
 99874:     }
 99874:     
 99874:     if ((mLoadFlags & LOAD_ONLY_IF_MODIFIED) && !mCachedContentIsPartial) {
 99874:         if (!mCacheForOfflineUse) {
 99874:             LOG(("Skipping read from cache based on LOAD_ONLY_IF_MODIFIED "
 43113:                  "load flag\n"));
103136:             MOZ_ASSERT(!mCacheInputStream);
 99874:             // TODO: Bug 759040 - We should call HandleAsyncNotModified directly
 99874:             // here, to avoid event dispatching latency.
 43113:             return AsyncCall(&nsHttpChannel::HandleAsyncNotModified);
 43113:         }
 43113:         
 99874:         if (!ShouldUpdateOfflineCacheEntry()) {
 99874:             LOG(("Skipping read from cache based on LOAD_ONLY_IF_MODIFIED "
 99874:                  "load flag (mCacheForOfflineUse case)\n"));
103136:             mCacheInputStream.CloseAndRelease();
 99874:             // TODO: Bug 759040 - We should call HandleAsyncNotModified directly
 99874:             // here, to avoid event dispatching latency.
 99874:             return AsyncCall(&nsHttpChannel::HandleAsyncNotModified);
 99874:         }
 99874:     }
 99874: 
103136:     MOZ_ASSERT(mCacheInputStream);
103136:     if (!mCacheInputStream) {
103136:         NS_ERROR("mCacheInputStream is null but we're expecting to "
 99874:                         "be able to read from it.");
 99874:         return NS_ERROR_UNEXPECTED;
 99874:     }
 99874: 
 99874: 
103136:     nsCOMPtr<nsIInputStream> inputStream = mCacheInputStream.forget();
 99874:  
 99874:     rv = nsInputStreamPump::Create(getter_AddRefs(mCachePump), inputStream,
 99874:                                    PRInt64(-1), PRInt64(-1), 0, 0, true);
 99874:     if (NS_FAILED(rv)) {
 99874:         inputStream->Close();
 99874:         return rv;
 99874:     }
 43113: 
 53987:     rv = mCachePump->AsyncRead(this, mListenerContext);
 53987:     if (NS_FAILED(rv)) return rv;
 53987: 
 70188:     if (mTimingEnabled)
 70188:         mCacheReadStart = mozilla::TimeStamp::Now();
 70188: 
 53987:     PRUint32 suspendCount = mSuspendCount;
 53987:     while (suspendCount--)
 53987:         mCachePump->Suspend();
 53987: 
 53987:     return NS_OK;
 43113: }
 43113: 
 43113: void
 79445: nsHttpChannel::CloseCacheEntry(bool doomOnFailure)
 43113: {
 99879:     mCacheQuery = nsnull;
103136:     mCacheInputStream.CloseAndRelease();
 99874: 
 61191:     if (!mCacheEntry)
 43113:         return;
 43113: 
 43113:     LOG(("nsHttpChannel::CloseCacheEntry [this=%p] mStatus=%x mCacheAccess=%x",
 43113:          this, mStatus, mCacheAccess));
 43113: 
 43113:     // If we have begun to create or replace a cache entry, and that cache
 43113:     // entry is not complete and not resumable, then it needs to be doomed.
 43113:     // Otherwise, CheckCache will make the mistake of thinking that the
 43113:     // partial cache entry is complete.
 43113: 
 79445:     bool doom = false;
 43113:     if (mInitedCacheEntry) {
 43113:         NS_ASSERTION(mResponseHead, "oops");
 61191:         if (NS_FAILED(mStatus) && doomOnFailure &&
 43113:             (mCacheAccess & nsICache::ACCESS_WRITE) &&
 43113:             !mResponseHead->IsResumable())
 80486:             doom = true;
 43113:     }
 43113:     else if (mCacheAccess == nsICache::ACCESS_WRITE)
 80486:         doom = true;
 43113: 
 43113:     if (doom) {
 43113:         LOG(("  dooming cache entry!!"));
 43113:         mCacheEntry->Doom();
 43113:     }
 43113: 
 46790:     mCachedResponseHead = nsnull;
 43113: 
 43113:     mCachePump = 0;
 43113:     mCacheEntry = 0;
 43113:     mCacheAccess = 0;
 80486:     mInitedCacheEntry = false;
 43113: }
 43113: 
 43113: 
 43113: void
 43113: nsHttpChannel::CloseOfflineCacheEntry()
 43113: {
 43113:     if (!mOfflineCacheEntry)
 43113:         return;
 43113: 
 43113:     LOG(("nsHttpChannel::CloseOfflineCacheEntry [this=%p]", this));
 43113: 
 43113:     if (NS_FAILED(mStatus)) {
 43113:         mOfflineCacheEntry->Doom();
 43113:     }
 43113:     else {
 79445:         bool succeeded;
 43113:         if (NS_SUCCEEDED(GetRequestSucceeded(&succeeded)) && !succeeded)
 43113:             mOfflineCacheEntry->Doom();
 43113:     }
 43113: 
 43113:     mOfflineCacheEntry = 0;
 43113:     mOfflineCacheAccess = 0;
 43113: }
 43113: 
 43113: 
 43113: // Initialize the cache entry for writing.
 43113: //  - finalize storage policy
 43113: //  - store security info
 43113: //  - update expiration time
 43113: //  - store headers and other meta data
 43113: nsresult
 43113: nsHttpChannel::InitCacheEntry()
 43113: {
 43113:     nsresult rv;
 43113: 
 43113:     NS_ENSURE_TRUE(mCacheEntry, NS_ERROR_UNEXPECTED);
 43113:     // if only reading, nothing to be done here.
 43113:     if (mCacheAccess == nsICache::ACCESS_READ)
 43113:         return NS_OK;
 43113: 
 43113:     // Don't cache the response again if already cached...
 43113:     if (mCachedContentIsValid)
 43113:         return NS_OK;
 43113: 
 43113:     LOG(("nsHttpChannel::InitCacheEntry [this=%p entry=%p]\n",
 43113:         this, mCacheEntry.get()));
 43113: 
 88544:     if (mLoadFlags & INHIBIT_PERSISTENT_CACHING) {
 88544:         rv = mCacheEntry->SetStoragePolicy(nsICache::STORE_IN_MEMORY);
 88544:         if (NS_FAILED(rv)) return rv;
 88544:     }
 88544: 
 88544:     // Set the expiration time for this cache entry
 88544:     rv = UpdateExpirationTime();
 88544:     if (NS_FAILED(rv)) return rv;
 88544: 
 88544:     rv = AddCacheEntryHeaders(mCacheEntry);
 88544:     if (NS_FAILED(rv)) return rv;
 88544: 
 88544:     mInitedCacheEntry = true;
 88544:     return NS_OK;
 88544: }
 88544: 
 88544: void
 88544: nsHttpChannel::UpdateInhibitPersistentCachingFlag()
 88544: {
 43113:     // The no-store directive within the 'Cache-Control:' header indicates
 43113:     // that we must not store the response in a persistent cache.
 43113:     if (mResponseHead->NoStore())
 43113:         mLoadFlags |= INHIBIT_PERSISTENT_CACHING;
 43113: 
 43113:     // Only cache SSL content on disk if the pref is set
 43113:     if (!gHttpHandler->IsPersistentHttpsCachingEnabled() &&
 43113:         mConnectionInfo->UsingSSL())
 43113:         mLoadFlags |= INHIBIT_PERSISTENT_CACHING;
 88544: }
 43113: 
 43113: nsresult
 43113: nsHttpChannel::InitOfflineCacheEntry()
 43113: {
 43113:     // This function can be called even when we fail to connect (bug 551990)
 43113: 
 43113:     if (!mOfflineCacheEntry) {
 43113:         return NS_OK;
 43113:     }
 43113: 
 96924:     if (!mResponseHead || mResponseHead->NoStore()) {
 43113:         CloseOfflineCacheEntry();
 43113: 
 43113:         return NS_OK;
 43113:     }
 43113: 
 43113:     // This entry's expiration time should match the main entry's expiration
 43113:     // time.  UpdateExpirationTime() will keep it in sync once the offline
 43113:     // cache entry has been created.
 43113:     if (mCacheEntry) {
 43113:         PRUint32 expirationTime;
 43113:         nsresult rv = mCacheEntry->GetExpirationTime(&expirationTime);
 43113:         NS_ENSURE_SUCCESS(rv, rv);
 43113: 
 43113:         mOfflineCacheEntry->SetExpirationTime(expirationTime);
 43113:     }
 43113: 
 43113:     return AddCacheEntryHeaders(mOfflineCacheEntry);
 43113: }
 43113: 
 43113: 
 43113: nsresult
 43113: nsHttpChannel::AddCacheEntryHeaders(nsICacheEntryDescriptor *entry)
 43113: {
 43113:     nsresult rv;
 43113: 
 58260:     LOG(("nsHttpChannel::AddCacheEntryHeaders [this=%x] begin", this));
 43113:     // Store secure data in memory only
 43113:     if (mSecurityInfo)
 43113:         entry->SetSecurityInfo(mSecurityInfo);
 43113: 
 43113:     // Store the HTTP request method with the cache entry so we can distinguish
 43113:     // for example GET and HEAD responses.
 43113:     rv = entry->SetMetaDataElement("request-method",
 78638:                                    mRequestHead.Method().get());
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     // Store the HTTP authorization scheme used if any...
 43113:     rv = StoreAuthorizationMetaData(entry);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     // Iterate over the headers listed in the Vary response header, and
 43113:     // store the value of the corresponding request header so we can verify
 43113:     // that it has not varied when we try to re-use the cached response at
 58260:     // a later time.  Take care to store "Cookie" headers only as hashes
 58260:     // due to security considerations and the fact that they can be pretty
 58260:     // large (bug 468426). We take care of "Vary: cookie" in ResponseWouldVary.
 43113:     //
 43113:     // NOTE: if "Vary: accept, cookie", then we will store the "accept" header
 43113:     // in the cache.  we could try to avoid needlessly storing the "accept"
 43113:     // header in this case, but it doesn't seem worth the extra code to perform
 43113:     // the check.
 43113:     {
 43113:         nsCAutoString buf, metaKey;
 43113:         mResponseHead->GetHeader(nsHttp::Vary, buf);
 43113:         if (!buf.IsEmpty()) {
 43113:             NS_NAMED_LITERAL_CSTRING(prefix, "request-");
 43113:            
 43113:             char *val = buf.BeginWriting(); // going to munge buf
 43113:             char *token = nsCRT::strtok(val, NS_HTTP_HEADER_SEPS, &val);
 43113:             while (token) {
 58260:                 LOG(("nsHttpChannel::AddCacheEntryHeaders [this=%x] " \
 58260:                         "processing %s", this, token));
 58260:                 if (*token != '*') {
 43113:                     nsHttpAtom atom = nsHttp::ResolveAtom(token);
 58260:                     const char *val = mRequestHead.PeekHeader(atom);
 58260:                     nsCAutoString hash;
 58260:                     if (val) {
 58260:                         // If cookie-header, store a hash of the value
 58260:                         if (atom == nsHttp::Cookie) {
 58260:                             LOG(("nsHttpChannel::AddCacheEntryHeaders [this=%x] " \
 58260:                                     "cookie-value %s", this, val));
 58260:                             rv = Hash(val, hash);
 58260:                             // If hash failed, store a string not very likely
 58260:                             // to be the result of subsequent hashes
 58260:                             if (NS_FAILED(rv))
 58260:                                 val = "<hash failed>";
 58260:                             else
 58260:                                 val = hash.get();
 58260: 
 58260:                             LOG(("   hashed to %s\n", val));
 58260:                         }
 58260: 
 43113:                         // build cache meta data key and set meta data element...
 43113:                         metaKey = prefix + nsDependentCString(token);
 58260:                         entry->SetMetaDataElement(metaKey.get(), val);
 58260:                     } else {
 58260:                         LOG(("nsHttpChannel::AddCacheEntryHeaders [this=%x] " \
 58260:                                 "clearing metadata for %s", this, token));
 58260:                         metaKey = prefix + nsDependentCString(token);
 58260:                         entry->SetMetaDataElement(metaKey.get(), nsnull);
 43113:                     }
 43113:                 }
 43113:                 token = nsCRT::strtok(val, NS_HTTP_HEADER_SEPS, &val);
 43113:             }
 43113:         }
 43113:     }
 43113: 
 43113: 
 43113:     // Store the received HTTP head with the cache entry as an element of
 43113:     // the meta data.
 43113:     nsCAutoString head;
 80486:     mResponseHead->Flatten(head, true);
 43113:     rv = entry->SetMetaDataElement("response-head", head.get());
 43113: 
 43113:     return rv;
 43113: }
 43113: 
 43113: inline void
 43113: GetAuthType(const char *challenge, nsCString &authType)
 43113: {
 43113:     const char *p;
 43113: 
 43113:     // get the challenge type
 43113:     if ((p = strchr(challenge, ' ')) != nsnull)
 43113:         authType.Assign(challenge, p - challenge);
 43113:     else
 43113:         authType.Assign(challenge);
 43113: }
 43113: 
 43113: nsresult
 43113: nsHttpChannel::StoreAuthorizationMetaData(nsICacheEntryDescriptor *entry)
 43113: {
 43113:     // Not applicable to proxy authorization...
 43113:     const char *val = mRequestHead.PeekHeader(nsHttp::Authorization);
 43113:     if (!val)
 43113:         return NS_OK;
 43113: 
 43113:     // eg. [Basic realm="wally world"]
 43113:     nsCAutoString buf;
 43113:     GetAuthType(val, buf);
 43113:     return entry->SetMetaDataElement("auth", buf.get());
 43113: }
 43113: 
 43113: // Finalize the cache entry
 43113: //  - may need to rewrite response headers if any headers changed
 43113: //  - may need to recalculate the expiration time if any headers changed
 43113: //  - called only for freshly written cache entries
 43113: nsresult
 43113: nsHttpChannel::FinalizeCacheEntry()
 43113: {
 43113:     LOG(("nsHttpChannel::FinalizeCacheEntry [this=%p]\n", this));
 43113: 
 43113:     if (mResponseHead && mResponseHeadersModified) {
 43113:         // Set the expiration time for this cache entry
 43113:         nsresult rv = UpdateExpirationTime();
 43113:         if (NS_FAILED(rv)) return rv;
 43113:     }
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: // Open an output stream to the cache entry and insert a listener tee into
 43113: // the chain of response listeners.
 43113: nsresult
 43113: nsHttpChannel::InstallCacheListener(PRUint32 offset)
 43113: {
 43113:     nsresult rv;
 43113: 
 43113:     LOG(("Preparing to write data into the cache [uri=%s]\n", mSpec.get()));
 43113: 
 43113:     NS_ASSERTION(mCacheEntry, "no cache entry");
 43113:     NS_ASSERTION(mListener, "no listener");
 43113: 
 84841:     nsCacheStoragePolicy policy;
 84841:     rv = mCacheEntry->GetStoragePolicy(&policy);
 84841:     if (NS_FAILED(rv)) {
 84841:         policy = nsICache::STORE_ON_DISK_AS_FILE;
 84841:     }
 84841: 
 84841:     // If the content is compressible and the server has not compressed it,
 84841:     // mark the cache entry for compression.
 84841:     if ((mResponseHead->PeekHeader(nsHttp::Content_Encoding) == nsnull) && (
 84841:          policy != nsICache::STORE_ON_DISK_AS_FILE) && (
 84841:          mResponseHead->ContentType().EqualsLiteral(TEXT_HTML) ||
 84841:          mResponseHead->ContentType().EqualsLiteral(TEXT_PLAIN) ||
 84841:          mResponseHead->ContentType().EqualsLiteral(TEXT_CSS) ||
 84841:          mResponseHead->ContentType().EqualsLiteral(TEXT_JAVASCRIPT) ||
 84841:          mResponseHead->ContentType().EqualsLiteral(TEXT_ECMASCRIPT) ||
 84841:          mResponseHead->ContentType().EqualsLiteral(TEXT_XML) ||
 84841:          mResponseHead->ContentType().EqualsLiteral(APPLICATION_JAVASCRIPT) ||
 84841:          mResponseHead->ContentType().EqualsLiteral(APPLICATION_ECMASCRIPT) ||
 84841:          mResponseHead->ContentType().EqualsLiteral(APPLICATION_XJAVASCRIPT) ||
 84841:          mResponseHead->ContentType().EqualsLiteral(APPLICATION_XHTML_XML))) {
 84841:         rv = mCacheEntry->SetMetaDataElement("uncompressed-len", "0"); 
 84841:         if (NS_FAILED(rv)) {
 84841:             LOG(("unable to mark cache entry for compression"));
 84841:         }
 84841:     } 
 84841:       
 43113:     nsCOMPtr<nsIOutputStream> out;
 43113:     rv = mCacheEntry->OpenOutputStream(offset, getter_AddRefs(out));
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     // XXX disk cache does not support overlapped i/o yet
 43113: #if 0
 43113:     // Mark entry valid inorder to allow simultaneous reading...
 43113:     rv = mCacheEntry->MarkValid();
 43113:     if (NS_FAILED(rv)) return rv;
 43113: #endif
 43113: 
 43113:     nsCOMPtr<nsIStreamListenerTee> tee =
 43113:         do_CreateInstance(kStreamListenerTeeCID, &rv);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 51302:     nsCOMPtr<nsICacheService> serv =
 51302:         do_GetService(NS_CACHESERVICE_CONTRACTID, &rv);
 51302:     NS_ENSURE_SUCCESS(rv, rv);
 51302: 
 51302:     nsCOMPtr<nsIEventTarget> cacheIOTarget;
 51302:     serv->GetCacheIOTarget(getter_AddRefs(cacheIOTarget));
 51302: 
 84841:     if (policy == nsICache::STORE_ON_DISK_AS_FILE ||
 51302:         !cacheIOTarget) {
 51302:         LOG(("nsHttpChannel::InstallCacheListener sync tee %p rv=%x policy=%d "
 51302:              "cacheIOTarget=%p", tee.get(), rv, policy, cacheIOTarget.get()));
 43113:         rv = tee->Init(mListener, out, nsnull);
 43113:     } else {
 51302:         LOG(("nsHttpChannel::InstallCacheListener async tee %p", tee.get()));
 51302:         rv = tee->InitAsync(mListener, cacheIOTarget, out, nsnull);
 43113:     }
 43113: 
 43113:     if (NS_FAILED(rv)) return rv;
 43113:     mListener = tee;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: nsresult
 43113: nsHttpChannel::InstallOfflineCacheListener()
 43113: {
 43113:     nsresult rv;
 43113: 
 43113:     LOG(("Preparing to write data into the offline cache [uri=%s]\n",
 43113:          mSpec.get()));
 43113: 
 43113:     NS_ASSERTION(mOfflineCacheEntry, "no offline cache entry");
 43113:     NS_ASSERTION(mListener, "no listener");
 43113: 
 43113:     nsCOMPtr<nsIOutputStream> out;
 43113:     rv = mOfflineCacheEntry->OpenOutputStream(0, getter_AddRefs(out));
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     nsCOMPtr<nsIStreamListenerTee> tee =
 43113:         do_CreateInstance(kStreamListenerTeeCID, &rv);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     rv = tee->Init(mListener, out, nsnull);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     mListener = tee;
 43113: 
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: void
 43113: nsHttpChannel::ClearBogusContentEncodingIfNeeded()
 43113: {
 43113:     // For .gz files, apache sends both a Content-Type: application/x-gzip
 43113:     // as well as Content-Encoding: gzip, which is completely wrong.  In
 43113:     // this case, we choose to ignore the rogue Content-Encoding header. We
 43113:     // must do this early on so as to prevent it from being seen up stream.
 43113:     // The same problem exists for Content-Encoding: compress in default
 43113:     // Apache installs.
 43113:     if (mResponseHead->HasHeaderValue(nsHttp::Content_Encoding, "gzip") && (
 43113:         mResponseHead->ContentType().EqualsLiteral(APPLICATION_GZIP) ||
 43113:         mResponseHead->ContentType().EqualsLiteral(APPLICATION_GZIP2) ||
 43113:         mResponseHead->ContentType().EqualsLiteral(APPLICATION_GZIP3))) {
 43113:         // clear the Content-Encoding header
 43113:         mResponseHead->ClearHeader(nsHttp::Content_Encoding);
 43113:     }
 43113:     else if (mResponseHead->HasHeaderValue(nsHttp::Content_Encoding, "compress") && (
 43113:              mResponseHead->ContentType().EqualsLiteral(APPLICATION_COMPRESS) ||
 43113:              mResponseHead->ContentType().EqualsLiteral(APPLICATION_COMPRESS2))) {
 43113:         // clear the Content-Encoding header
 43113:         mResponseHead->ClearHeader(nsHttp::Content_Encoding);
 43113:     }
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpChannel <redirect>
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: nsresult
 43113: nsHttpChannel::SetupReplacementChannel(nsIURI       *newURI, 
 43113:                                        nsIChannel   *newChannel,
 89558:                                        bool          preserveMethod,
 89558:                                        bool          forProxy)
 43113: {
 43113:     LOG(("nsHttpChannel::SetupReplacementChannel "
 43113:          "[this=%p newChannel=%p preserveMethod=%d]",
 43113:          this, newChannel, preserveMethod));
 49375: 
 89558:     nsresult rv = HttpBaseChannel::SetupReplacementChannel(newURI, newChannel,
 89558:                                                            preserveMethod, forProxy);
 49375:     if (NS_FAILED(rv))
 49375:         return rv;
 43113: 
 43113:     nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(newChannel);
 43113:     if (!httpChannel)
 43113:         return NS_OK; // no other options to set
 43113: 
 43113:     // convey the mApplyConversion flag (bug 91862)
 43113:     nsCOMPtr<nsIEncodedChannel> encodedChannel = do_QueryInterface(httpChannel);
 43113:     if (encodedChannel)
 43113:         encodedChannel->SetApplyConversion(mApplyConversion);
 43113: 
 43113:     // transfer the resume information
 43113:     if (mResuming) {
 43113:         nsCOMPtr<nsIResumableChannel> resumableChannel(do_QueryInterface(newChannel));
 43113:         if (!resumableChannel) {
 43113:             NS_WARNING("Got asked to resume, but redirected to non-resumable channel!");
 43113:             return NS_ERROR_NOT_RESUMABLE;
 43113:         }
 43113:         resumableChannel->ResumeAt(mStartPos, mEntityID);
 43113:     }
 43113: 
 89558:     if (forProxy) {
 89558:         // Transfer the cache info to the new channel, if needed.
 89558:         nsCOMPtr<nsICachingChannel> cachingChannel = do_QueryInterface(newChannel);
 89558:         if (cachingChannel) {
 89558:             // cacheKey is just mPostID wrapped in an nsISupportsPRUint32,
 89558:             // we don't need to transfer it if it's 0.
 89558:             if (mPostID) {
 89558:                 nsCOMPtr<nsISupports> cacheKey;
 89558:                 GetCacheKey(getter_AddRefs(cacheKey));
 89558:                 if (cacheKey) {
 89558:                     cachingChannel->SetCacheKey(cacheKey);
 89558:                 }
 89558:             }
 89558: 
 89558:             // cacheClientID, cacheForOfflineUse
 89558:             cachingChannel->SetOfflineCacheClientID(mOfflineCacheClientID);
 89558:             cachingChannel->SetCacheForOfflineUse(mCacheForOfflineUse);
100212:             cachingChannel->SetProfileDirectory(mProfileDirectory);
 89558:         }
 89558:     }
 89558: 
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: nsresult
 48304: nsHttpChannel::AsyncProcessRedirection(PRUint32 redirectType)
 43113: {
 48304:     LOG(("nsHttpChannel::AsyncProcessRedirection [this=%p type=%u]\n",
 43113:         this, redirectType));
 43113: 
 43113:     const char *location = mResponseHead->PeekHeader(nsHttp::Location);
 43113: 
 43113:     // if a location header was not given, then we can't perform the redirect,
 43113:     // so just carry on as though this were a normal response.
 43113:     if (!location)
 43113:         return NS_ERROR_FAILURE;
 43113: 
 43113:     // make sure non-ASCII characters in the location header are escaped.
 43113:     nsCAutoString locationBuf;
 43113:     if (NS_EscapeURL(location, -1, esc_OnlyNonASCII, locationBuf))
 43113:         location = locationBuf.get();
 43113: 
 43113:     if (mRedirectionLimit == 0) {
 43113:         LOG(("redirection limit reached!\n"));
 43113:         return NS_ERROR_REDIRECT_LOOP;
 43113:     }
 43113: 
 48304:     mRedirectType = redirectType;
 48304: 
 43113:     LOG(("redirecting to: %s [redirection-limit=%u]\n",
 43113:         location, PRUint32(mRedirectionLimit)));
 43113: 
 71627:     nsresult rv = CreateNewURI(location, getter_AddRefs(mRedirectURI));
 71627: 
 95201:     if (NS_FAILED(rv)) {
 95201:         LOG(("Invalid URI for redirect: Location: %s\n", location));
 95201:         return NS_ERROR_CORRUPTED_CONTENT;
 95201:     }
 43113: 
 43113:     if (mApplicationCache) {
 43113:         // if we are redirected to a different origin check if there is a fallback
 43113:         // cache entry to fall back to. we don't care about file strict 
 43113:         // checking, at least mURI is not a file URI.
 80486:         if (!NS_SecurityCompareURIs(mURI, mRedirectURI, false)) {
 48304:             PushRedirectAsyncFunc(&nsHttpChannel::ContinueProcessRedirectionAfterFallback);
 79445:             bool waitingForRedirectCallback;
 63793:             (void)ProcessFallback(&waitingForRedirectCallback);
 48304:             if (waitingForRedirectCallback)
 48304:                 return NS_OK;
 48304:             PopRedirectAsyncFunc(&nsHttpChannel::ContinueProcessRedirectionAfterFallback);
 48304:         }
 48304:     }
 48304: 
 48304:     return ContinueProcessRedirectionAfterFallback(NS_OK);
 48304: }
 48304: 
 71627: // Creates an URI to the given location using current URI for base and charset
 71627: nsresult
 71627: nsHttpChannel::CreateNewURI(const char *loc, nsIURI **newURI)
 71627: {
 71627:     nsCOMPtr<nsIIOService> ioService;
 71627:     nsresult rv = gHttpHandler->GetIOService(getter_AddRefs(ioService));
 71627:     if (NS_FAILED(rv)) return rv;
 71627: 
 71627:     // the new uri should inherit the origin charset of the current uri
 71627:     nsCAutoString originCharset;
 71627:     rv = mURI->GetOriginCharset(originCharset);
 71627:     if (NS_FAILED(rv))
 71627:         originCharset.Truncate();
 71627: 
 71627:     return ioService->NewURI(nsDependentCString(loc),
 71627:                              originCharset.get(),
 71627:                              mURI,
 71627:                              newURI);
 71627: }
 71627: 
 48304: nsresult
 48304: nsHttpChannel::ContinueProcessRedirectionAfterFallback(nsresult rv)
 48304: {
 48304:     if (NS_SUCCEEDED(rv) && mFallingBack) {
 43113:         // do not continue with redirect processing, fallback is in
 43113:         // progress now.
 43113:         return NS_OK;
 43113:     }
 43113: 
 43113:     // Kill the current cache entry if we are redirecting
 43113:     // back to ourself.
 79445:     bool redirectingBackToSameURI = false;
 43113:     if (mCacheEntry && (mCacheAccess & nsICache::ACCESS_WRITE) &&
 48304:         NS_SUCCEEDED(mURI->Equals(mRedirectURI, &redirectingBackToSameURI)) &&
 43113:         redirectingBackToSameURI)
 43113:             mCacheEntry->Doom();
 43113: 
 43113:     // move the reference of the old location to the new one if the new
 43113:     // one has none.
 43113:     nsCAutoString ref;
 70215:     rv = mRedirectURI->GetRef(ref);
 43113:     if (NS_SUCCEEDED(rv) && ref.IsEmpty()) {
 70215:         mURI->GetRef(ref);
 70215:         if (!ref.IsEmpty()) {
 70215:             // NOTE: SetRef will fail if mRedirectURI is immutable
 70215:             // (e.g. an about: URI)... Oh well.
 70215:             mRedirectURI->SetRef(ref);
 43113:         }
 43113:     }
 43113: 
 80420:     bool rewriteToGET = HttpBaseChannel::ShouldRewriteRedirectToGET(
 80420:         mRedirectType, mRequestHead.Method());
 80420:       
 80420:     // prompt if the method is not safe (such as POST, PUT, DELETE, ...)
 80420:     if (!rewriteToGET &&
 80420:         !HttpBaseChannel::IsSafeMethod(mRequestHead.Method())) {
 43113:         rv = PromptTempRedirect();
 43113:         if (NS_FAILED(rv)) return rv;
 43113:     }
 43113: 
 48304:     nsCOMPtr<nsIIOService> ioService;
 48304:     rv = gHttpHandler->GetIOService(getter_AddRefs(ioService));
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 48304:     nsCOMPtr<nsIChannel> newChannel;
 48304:     rv = ioService->NewChannelFromURI(mRedirectURI, getter_AddRefs(newChannel));
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 89558:     rv = SetupReplacementChannel(mRedirectURI, newChannel, !rewriteToGET, false);
 48304:     if (NS_FAILED(rv)) return rv;
 48304: 
 43113:     PRUint32 redirectFlags;
 48304:     if (mRedirectType == 301) // Moved Permanently
 43113:         redirectFlags = nsIChannelEventSink::REDIRECT_PERMANENT;
 43113:     else
 43113:         redirectFlags = nsIChannelEventSink::REDIRECT_TEMPORARY;
 43113: 
 43113:     // verify that this is a legal redirect
 48304:     mRedirectChannel = newChannel;
 48304: 
 48304:     PushRedirectAsyncFunc(&nsHttpChannel::ContinueProcessRedirection);
 48304:     rv = gHttpHandler->AsyncOnChannelRedirect(this, newChannel, redirectFlags);
 48304: 
 48304:     if (NS_SUCCEEDED(rv))
 48304:         rv = WaitForRedirectCallback();
 48304: 
 48304:     if (NS_FAILED(rv)) {
 49375:         AutoRedirectVetoNotifier notifier(this);
 48304:         PopRedirectAsyncFunc(&nsHttpChannel::ContinueProcessRedirection);
 48304:     }
 48304: 
 48304:     return rv;
 48304: }
 48304: 
 48304: nsresult
 48304: nsHttpChannel::ContinueProcessRedirection(nsresult rv)
 48304: {
 49375:     AutoRedirectVetoNotifier notifier(this);
 49375: 
 48889:     LOG(("ContinueProcessRedirection [rv=%x]\n", rv));
 43113:     if (NS_FAILED(rv))
 43113:         return rv;
 43113: 
 48304:     NS_PRECONDITION(mRedirectChannel, "No redirect channel?");
 48304: 
 43113:     // Make sure to do this _after_ calling OnChannelRedirect
 48304:     mRedirectChannel->SetOriginalURI(mOriginalURI);
 43113: 
 43113:     // And now, the deprecated way
 43113:     nsCOMPtr<nsIHttpEventSink> httpEventSink;
 43113:     GetCallback(httpEventSink);
 43113:     if (httpEventSink) {
 43113:         // NOTE: nsIHttpEventSink is only used for compatibility with pre-1.8
 43113:         // versions.
 48304:         rv = httpEventSink->OnRedirect(this, mRedirectChannel);
 48304:         if (NS_FAILED(rv))
 48304:             return rv;
 43113:     }
 43113:     // XXX we used to talk directly with the script security manager, but that
 43113:     // should really be handled by the event sink implementation.
 43113: 
 43113:     // begin loading the new channel
 48304:     rv = mRedirectChannel->AsyncOpen(mListener, mListenerContext);
 48304: 
 48304:     if (NS_FAILED(rv))
 48304:         return rv;
 43113: 
 43113:     // close down this channel
 43113:     Cancel(NS_BINDING_REDIRECTED);
 43113:     
 49375:     notifier.RedirectSucceeded();
 49375: 
 43113:     // disconnect from our listener
 43113:     mListener = 0;
 43113:     mListenerContext = 0;
 49375: 
 43113:     // and from our callbacks
 43113:     mCallbacks = nsnull;
 43113:     mProgressSink = nsnull;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpChannel <auth>
 43113: //-----------------------------------------------------------------------------
 43113: 
 43832: NS_IMETHODIMP nsHttpChannel::OnAuthAvailable()
 43113: {
 43113:     LOG(("nsHttpChannel::OnAuthAvailable [this=%p]", this));
 43113: 
 43113:     // setting mAuthRetryPending flag and resuming the transaction
 43113:     // triggers process of throwing away the unauthenticated data already
 43113:     // coming from the network
 80486:     mAuthRetryPending = true;
 43113:     LOG(("Resuming the transaction, we got credentials from user"));
 43113:     mTransactionPump->Resume();
 43113:   
 43113:     return NS_OK;
 43113: }
 43113: 
 79445: NS_IMETHODIMP nsHttpChannel::OnAuthCancelled(bool userCancel)
 43113: {
 43832:     LOG(("nsHttpChannel::OnAuthCancelled [this=%p]", this));
 43832: 
 56438:     if (mTransactionPump) {
 43832:         // ensure call of OnStartRequest of the current listener here,
 43832:         // it would not be called otherwise at all
 43832:         nsresult rv = CallOnStartRequest();
 43832: 
 43832:         // drop mAuthRetryPending flag and resume the transaction
 43832:         // this resumes load of the unauthenticated content data
 80486:         mAuthRetryPending = false;
 43832:         LOG(("Resuming the transaction, user cancelled the auth dialog"));
 43832:         mTransactionPump->Resume();
 43832: 
 43113:         if (NS_FAILED(rv))
 43832:             mTransactionPump->Cancel(rv);
 43832:     }
 43832:     
 43832:     return NS_OK;
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpChannel::nsISupports
 43113: //-----------------------------------------------------------------------------
 43113: 
 46790: NS_IMPL_ADDREF_INHERITED(nsHttpChannel, HttpBaseChannel)
 46790: NS_IMPL_RELEASE_INHERITED(nsHttpChannel, HttpBaseChannel)
 43113: 
 43113: NS_INTERFACE_MAP_BEGIN(nsHttpChannel)
 43113:     NS_INTERFACE_MAP_ENTRY(nsIRequest)
 43113:     NS_INTERFACE_MAP_ENTRY(nsIChannel)
 43113:     NS_INTERFACE_MAP_ENTRY(nsIRequestObserver)
 43113:     NS_INTERFACE_MAP_ENTRY(nsIStreamListener)
 43113:     NS_INTERFACE_MAP_ENTRY(nsIHttpChannel)
 46915:     NS_INTERFACE_MAP_ENTRY(nsICacheInfoChannel)
 43113:     NS_INTERFACE_MAP_ENTRY(nsICachingChannel)
 43113:     NS_INTERFACE_MAP_ENTRY(nsIUploadChannel)
 43113:     NS_INTERFACE_MAP_ENTRY(nsIUploadChannel2)
 43113:     NS_INTERFACE_MAP_ENTRY(nsICacheListener)
 43113:     NS_INTERFACE_MAP_ENTRY(nsIHttpChannelInternal)
 43113:     NS_INTERFACE_MAP_ENTRY(nsIResumableChannel)
 43113:     NS_INTERFACE_MAP_ENTRY(nsITransportEventSink)
 43113:     NS_INTERFACE_MAP_ENTRY(nsISupportsPriority)
 43113:     NS_INTERFACE_MAP_ENTRY(nsIProtocolProxyCallback)
 43113:     NS_INTERFACE_MAP_ENTRY(nsIProxiedChannel)
 43832:     NS_INTERFACE_MAP_ENTRY(nsIHttpAuthenticableChannel)
 43113:     NS_INTERFACE_MAP_ENTRY(nsIApplicationCacheContainer)
 43113:     NS_INTERFACE_MAP_ENTRY(nsIApplicationCacheChannel)
 48304:     NS_INTERFACE_MAP_ENTRY(nsIAsyncVerifyRedirectCallback)
 70188:     NS_INTERFACE_MAP_ENTRY(nsITimedChannel)
 46790: NS_INTERFACE_MAP_END_INHERITING(HttpBaseChannel)
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpChannel::nsIRequest
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpChannel::Cancel(nsresult status)
 43113: {
 43113:     LOG(("nsHttpChannel::Cancel [this=%p status=%x]\n", this, status));
 43113:     if (mCanceled) {
 43113:         LOG(("  ignoring; already canceled\n"));
 43113:         return NS_OK;
 43113:     }
 48304:     if (mWaitingForRedirectCallback) {
 48304:         LOG(("channel canceled during wait for redirect callback"));
 48304:     }
 80486:     mCanceled = true;
 43113:     mStatus = status;
 43113:     if (mProxyRequest)
 43113:         mProxyRequest->Cancel(status);
 43113:     if (mTransaction)
 43113:         gHttpHandler->CancelTransaction(mTransaction, status);
 43113:     if (mTransactionPump)
 43113:         mTransactionPump->Cancel(status);
 99879:     mCacheQuery = nsnull;
103136:     mCacheInputStream.CloseAndRelease();
 43113:     if (mCachePump)
 43113:         mCachePump->Cancel(status);
 43832:     if (mAuthProvider)
 43832:         mAuthProvider->Cancel(status);
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpChannel::Suspend()
 43113: {
 43113:     NS_ENSURE_TRUE(mIsPending, NS_ERROR_NOT_AVAILABLE);
 43113:     
 43113:     LOG(("nsHttpChannel::Suspend [this=%p]\n", this));
 43113: 
 43113:     ++mSuspendCount;
 43113: 
 43113:     if (mTransactionPump)
 43113:         return mTransactionPump->Suspend();
 43113:     if (mCachePump)
 43113:         return mCachePump->Suspend();
 43113: 
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpChannel::Resume()
 43113: {
 43113:     NS_ENSURE_TRUE(mSuspendCount > 0, NS_ERROR_UNEXPECTED);
 43113:     
 43113:     LOG(("nsHttpChannel::Resume [this=%p]\n", this));
 43113:         
 71646:     if (--mSuspendCount == 0 && mCallOnResume) {
 71646:         nsresult rv = AsyncCall(mCallOnResume);
 71646:         mCallOnResume = nsnull;
 43113:         NS_ENSURE_SUCCESS(rv, rv);
 43113:     }
 43113: 
 43113:     if (mTransactionPump)
 43113:         return mTransactionPump->Resume();
 43113:     if (mCachePump)
 43113:         return mCachePump->Resume();
 43113: 
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpChannel::nsIChannel
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpChannel::GetSecurityInfo(nsISupports **securityInfo)
 43113: {
 43113:     NS_ENSURE_ARG_POINTER(securityInfo);
 43113:     *securityInfo = mSecurityInfo;
 43113:     NS_IF_ADDREF(*securityInfo);
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpChannel::AsyncOpen(nsIStreamListener *listener, nsISupports *context)
 43113: {
 43113:     LOG(("nsHttpChannel::AsyncOpen [this=%p]\n", this));
 43113: 
 43113:     NS_ENSURE_ARG_POINTER(listener);
 43113:     NS_ENSURE_TRUE(!mIsPending, NS_ERROR_IN_PROGRESS);
 43113:     NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_ALREADY_OPENED);
 43113: 
 43113:     nsresult rv;
 43113: 
 49366:     if (mCanceled)
 49366:         return mStatus;
 49366: 
 43113:     rv = NS_CheckPortSafety(mURI);
 43113:     if (NS_FAILED(rv))
 43113:         return rv;
 43113: 
 43113:     if (!(mConnectionInfo && mConnectionInfo->UsingHttpProxy())) {
 43113:         // Start a DNS lookup very early in case the real open is queued the DNS can 
 43113:         // happen in parallel. Do not do so in the presence of an HTTP proxy as 
 43113:         // all lookups other than for the proxy itself are done by the proxy.
 70364:         //
 70364:         // We keep the DNS prefetch object around so that we can retrieve
 70364:         // timing information from it. There is no guarantee that we actually
 70364:         // use the DNS prefetch data for the real connection, but as we keep
 70364:         // this data around for 3 minutes by default, this should almost always
 70364:         // be correct, and even when it isn't, the timing still represents _a_
 70364:         // valid DNS lookup timing for the site, even if it is not _the_
 70364:         // timing we used.
 70364:         mDNSPrefetch = new nsDNSPrefetch(mURI, mTimingEnabled);
 70364:         mDNSPrefetch->PrefetchHigh();
 43113:     }
 43113:     
 43113:     // Remember the cookie header that was set, if any
 43113:     const char *cookieHeader = mRequestHead.PeekHeader(nsHttp::Cookie);
 46906:     if (cookieHeader) {
 43113:         mUserSetCookieHeader = cookieHeader;
 46906:     }
 46906: 
 43113:     AddCookiesToRequest();
 43113:  
 87308:     // check to see if authorization headers should be included
 87308:     mAuthProvider->AddAuthorizationHeaders();
 87308: 
 43113:     // notify "http-on-modify-request" observers
 43113:     gHttpHandler->OnModifyRequest(this);
 43113: 
 43113:     // Adjust mCaps according to our request headers:
 43113:     //  - If "Connection: close" is set as a request header, then do not bother
 43113:     //    trying to establish a keep-alive connection.
 43113:     if (mRequestHead.HasHeaderValue(nsHttp::Connection, "close"))
 43113:         mCaps &= ~(NS_HTTP_ALLOW_KEEPALIVE | NS_HTTP_ALLOW_PIPELINING);
 43113:     
 43113:     if ((mLoadFlags & VALIDATE_ALWAYS) || 
 43113:         (BYPASS_LOCAL_CACHE(mLoadFlags)))
 43113:         mCaps |= NS_HTTP_REFRESH_DNS;
 43113: 
 74259:     // Force-Reload should reset the persistent connection pool for this host
 74259:     if (mLoadFlags & LOAD_FRESH_CONNECTION)
 74259:         mCaps |= NS_HTTP_CLEAR_KEEPALIVES;
 74259:     
 80486:     mIsPending = true;
 80486:     mWasOpened = true;
 43113: 
 43113:     mListener = listener;
 43113:     mListenerContext = context;
 43113: 
 43113:     // add ourselves to the load group.  from this point forward, we'll report
 43113:     // all failures asynchronously.
 43113:     if (mLoadGroup)
 43113:         mLoadGroup->AddRequest(this, nsnull);
 43113: 
 70333:     // Collect mAsyncOpenTime after we have called all obsrevers like
 70333:     // "http-on-modify-request" and load group observers that may set
 70333:     // mTimingEnabled flag.
 70333:     if (mTimingEnabled)
 70333:         mAsyncOpenTime = mozilla::TimeStamp::Now();
 70333: 
 43113:     // We may have been cancelled already, either by on-modify-request
 43113:     // listeners or by load group observers; in that case, we should
 43113:     // not send the request to the server
 43113:     if (mCanceled)
 43113:         rv = mStatus;
 43113:     else
 43113:         rv = Connect();
 43113:     if (NS_FAILED(rv)) {
 43113:         LOG(("Calling AsyncAbort [rv=%x mCanceled=%i]\n", rv, mCanceled));
 80486:         CloseCacheEntry(true);
 43113:         AsyncAbort(rv);
 47861:     } else if (mLoadFlags & LOAD_CLASSIFY_URI) {
 43113:         nsRefPtr<nsChannelClassifier> classifier = new nsChannelClassifier();
 43113:         if (!classifier) {
 43113:             Cancel(NS_ERROR_OUT_OF_MEMORY);
 43113:             return NS_OK;
 43113:         }
 43113: 
 43113:         rv = classifier->Start(this);
 43113:         if (NS_FAILED(rv)) {
 43113:             Cancel(rv);
 43113:         }
 43113:     }
 43113: 
 43113:     return NS_OK;
 43113: }
 46790: 
 43113: //-----------------------------------------------------------------------------
 46790: // nsHttpChannel::nsIHttpChannelInternal
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: NS_IMETHODIMP
 46790: nsHttpChannel::SetupFallbackChannel(const char *aFallbackKey)
 43113: {
 99869:     ENSURE_CALLED_BEFORE_ASYNC_OPEN();
 99869: 
 46790:     LOG(("nsHttpChannel::SetupFallbackChannel [this=%x, key=%s]",
 46790:          this, aFallbackKey));
 80486:     mFallbackChannel = true;
 46790:     mFallbackKey = aFallbackKey;
 46790: 
 43113:     return NS_OK;
 43113: }
 52140: 
 52140: //-----------------------------------------------------------------------------
 43113: // nsHttpChannel::nsISupportsPriority
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpChannel::SetPriority(PRInt32 value)
 43113: {
 81029:     PRInt16 newValue = clamped(value, PR_INT16_MIN, PR_INT16_MAX);
 43113:     if (mPriority == newValue)
 43113:         return NS_OK;
 43113:     mPriority = newValue;
 43113:     if (mTransaction)
 43113:         gHttpHandler->RescheduleTransaction(mTransaction, mPriority);
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpChannel::nsIProtocolProxyCallback
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpChannel::OnProxyAvailable(nsICancelable *request, nsIURI *uri,
 43113:                                 nsIProxyInfo *pi, nsresult status)
 43113: {
 43113:     mProxyRequest = nsnull;
 43113: 
 43113:     // If status is a failure code, then it means that we failed to resolve
 43113:     // proxy info.  That is a non-fatal error assuming it wasn't because the
 43113:     // request was canceled.  We just failover to DIRECT when proxy resolution
 43113:     // fails (failure can mean that the PAC URL could not be loaded).
 43113:     
 43113:     // Need to replace this channel with a new one.  It would be complex to try
 43113:     // to change the value of mConnectionInfo since so much of our state may
 43113:     // depend on its state.
 43113:     mTargetProxyInfo = pi;
 43113:     HandleAsyncReplaceWithProxy();
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpChannel::nsIProxiedChannel
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpChannel::GetProxyInfo(nsIProxyInfo **result)
 43113: {
 43113:     if (!mConnectionInfo)
 43113:         *result = nsnull;
 43113:     else {
 43113:         *result = mConnectionInfo->ProxyInfo();
 43113:         NS_IF_ADDREF(*result);
 43113:     }
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 70188: // nsHttpChannel::nsITimedChannel
 70188: //-----------------------------------------------------------------------------
 70188: 
 70188: NS_IMETHODIMP
 79445: nsHttpChannel::SetTimingEnabled(bool enabled) {
 70188:     mTimingEnabled = enabled;
 70188:     return NS_OK;
 70188: }
 70188: 
 70188: NS_IMETHODIMP
 79445: nsHttpChannel::GetTimingEnabled(bool* _retval) {
 70188:     *_retval = mTimingEnabled;
 70188:     return NS_OK;
 70188: }
 70188: 
 70188: NS_IMETHODIMP
 70188: nsHttpChannel::GetChannelCreation(mozilla::TimeStamp* _retval) {
 70188:     *_retval = mChannelCreationTimestamp;
 70188:     return NS_OK;
 70188: }
 70188: 
 70188: NS_IMETHODIMP
 70188: nsHttpChannel::GetAsyncOpen(mozilla::TimeStamp* _retval) {
 70188:     *_retval = mAsyncOpenTime;
 70188:     return NS_OK;
 70188: }
 70188: 
 70188: NS_IMETHODIMP
 70188: nsHttpChannel::GetDomainLookupStart(mozilla::TimeStamp* _retval) {
 70364:     if (mDNSPrefetch && mDNSPrefetch->TimingsValid())
 70364:         *_retval = mDNSPrefetch->StartTimestamp();
 70364:     else if (mTransaction)
 70188:         *_retval = mTransaction->Timings().domainLookupStart;
 70188:     else
 70188:         *_retval = mTransactionTimings.domainLookupStart;
 70188:     return NS_OK;
 70188: }
 70188: 
 70188: NS_IMETHODIMP
 70188: nsHttpChannel::GetDomainLookupEnd(mozilla::TimeStamp* _retval) {
 70364:     if (mDNSPrefetch && mDNSPrefetch->TimingsValid())
 70364:         *_retval = mDNSPrefetch->EndTimestamp();
 70364:     else if (mTransaction)
 70188:         *_retval = mTransaction->Timings().domainLookupEnd;
 70188:     else
 70188:         *_retval = mTransactionTimings.domainLookupEnd;
 70188:     return NS_OK;
 70188: }
 70188: 
 70188: NS_IMETHODIMP
 70188: nsHttpChannel::GetConnectStart(mozilla::TimeStamp* _retval) {
 70188:     if (mTransaction)
 70188:         *_retval = mTransaction->Timings().connectStart;
 70188:     else
 70188:         *_retval = mTransactionTimings.connectStart;
 70188:     return NS_OK;
 70188: }
 70188: 
 70188: NS_IMETHODIMP
 70188: nsHttpChannel::GetConnectEnd(mozilla::TimeStamp* _retval) {
 70188:     if (mTransaction)
 70188:         *_retval = mTransaction->Timings().connectEnd;
 70188:     else
 70188:         *_retval = mTransactionTimings.connectEnd;
 70188:     return NS_OK;
 70188: }
 70188: 
 70188: NS_IMETHODIMP
 70188: nsHttpChannel::GetRequestStart(mozilla::TimeStamp* _retval) {
 70188:     if (mTransaction)
 70188:         *_retval = mTransaction->Timings().requestStart;
 70188:     else
 70188:         *_retval = mTransactionTimings.requestStart;
 70188:     return NS_OK;
 70188: }
 70188: 
 70188: NS_IMETHODIMP
 70188: nsHttpChannel::GetResponseStart(mozilla::TimeStamp* _retval) {
 70188:     if (mTransaction)
 70188:         *_retval = mTransaction->Timings().responseStart;
 70188:     else
 70188:         *_retval = mTransactionTimings.responseStart;
 70188:     return NS_OK;
 70188: }
 70188: 
 70188: NS_IMETHODIMP
 70188: nsHttpChannel::GetResponseEnd(mozilla::TimeStamp* _retval) {
 70188:     if (mTransaction)
 70188:         *_retval = mTransaction->Timings().responseEnd;
 70188:     else
 70188:         *_retval = mTransactionTimings.responseEnd;
 70188:     return NS_OK;
 70188: }
 70188: 
 70188: NS_IMETHODIMP
 70188: nsHttpChannel::GetCacheReadStart(mozilla::TimeStamp* _retval) {
 70188:     *_retval = mCacheReadStart;
 70188:     return NS_OK;
 70188: }
 70188: 
 70188: NS_IMETHODIMP
 70188: nsHttpChannel::GetCacheReadEnd(mozilla::TimeStamp* _retval) {
 70188:     *_retval = mCacheReadEnd;
 70188:     return NS_OK;
 70188: }
 70188: 
 70188: #define IMPL_TIMING_ATTR(name)                                 \
 70188: NS_IMETHODIMP                                                  \
 70188: nsHttpChannel::Get##name##Time(PRTime* _retval) {              \
 70188:     mozilla::TimeStamp stamp;                                  \
 70188:     Get##name(&stamp);                                         \
 70188:     if (stamp.IsNull()) {                                      \
 70188:         *_retval = 0;                                          \
 70188:         return NS_OK;                                          \
 70188:     }                                                          \
 70188:     *_retval = mChannelCreationTime +                          \
 94798:         (PRTime) ((stamp - mChannelCreationTimestamp).ToSeconds() * 1e6); \
 70188:     return NS_OK;                                              \
 70188: }
 70188: 
 70188: IMPL_TIMING_ATTR(ChannelCreation)
 70188: IMPL_TIMING_ATTR(AsyncOpen)
 70188: IMPL_TIMING_ATTR(DomainLookupStart)
 70188: IMPL_TIMING_ATTR(DomainLookupEnd)
 70188: IMPL_TIMING_ATTR(ConnectStart)
 70188: IMPL_TIMING_ATTR(ConnectEnd)
 70188: IMPL_TIMING_ATTR(RequestStart)
 70188: IMPL_TIMING_ATTR(ResponseStart)
 70188: IMPL_TIMING_ATTR(ResponseEnd)
 70188: IMPL_TIMING_ATTR(CacheReadStart)
 70188: IMPL_TIMING_ATTR(CacheReadEnd)
 70188: 
 70188: #undef IMPL_TIMING_ATTR
 70188: 
 70188: //-----------------------------------------------------------------------------
 43832: // nsHttpChannel::nsIHttpAuthenticableChannel
 43832: //-----------------------------------------------------------------------------
 43832: 
 43832: NS_IMETHODIMP
 79445: nsHttpChannel::GetIsSSL(bool *aIsSSL)
 43832: {
 43832:     *aIsSSL = mConnectionInfo->UsingSSL();
 43832:     return NS_OK;
 43832: }
 43832: 
 43832: NS_IMETHODIMP
 79445: nsHttpChannel::GetProxyMethodIsConnect(bool *aProxyMethodIsConnect)
 43832: {
102295:     *aProxyMethodIsConnect = mConnectionInfo->UsingConnect();
 43832:     return NS_OK;
 43832: }
 43832: 
 43832: NS_IMETHODIMP
 43832: nsHttpChannel::GetServerResponseHeader(nsACString &value)
 43832: {
 43832:     if (!mResponseHead)
 43832:         return NS_ERROR_NOT_AVAILABLE;
 43832:     return mResponseHead->GetHeader(nsHttp::Server, value);
 43832: }
 43832: 
 43832: NS_IMETHODIMP
 43832: nsHttpChannel::GetProxyChallenges(nsACString &value)
 43832: {
 43832:     if (!mResponseHead)
 43832:         return NS_ERROR_UNEXPECTED;
 43832:     return mResponseHead->GetHeader(nsHttp::Proxy_Authenticate, value);
 43832: }
 43832: 
 43832: NS_IMETHODIMP
 43832: nsHttpChannel::GetWWWChallenges(nsACString &value)
 43832: {
 43832:     if (!mResponseHead)
 43832:         return NS_ERROR_UNEXPECTED;
 43832:     return mResponseHead->GetHeader(nsHttp::WWW_Authenticate, value);
 43832: }
 43832: 
 43832: NS_IMETHODIMP
 43832: nsHttpChannel::SetProxyCredentials(const nsACString &value)
 43832: {
 43832:     return mRequestHead.SetHeader(nsHttp::Proxy_Authorization, value);
 43832: }
 43832: 
 43832: NS_IMETHODIMP
 43832: nsHttpChannel::SetWWWCredentials(const nsACString &value)
 43832: {
 43832:     return mRequestHead.SetHeader(nsHttp::Authorization, value);
 43832: }
 43832: 
 43832: //-----------------------------------------------------------------------------
 46909: // Methods that nsIHttpAuthenticableChannel dupes from other IDLs, which we
 46909: // get from HttpBaseChannel, must be explicitly forwarded, because C++ sucks.
 46909: //
 46909: 
 46909: NS_IMETHODIMP
 46909: nsHttpChannel::GetLoadFlags(nsLoadFlags *aLoadFlags)
 46909: {
 46909:     return HttpBaseChannel::GetLoadFlags(aLoadFlags);
 46909: }
 46909: 
 46909: NS_IMETHODIMP
 46909: nsHttpChannel::GetURI(nsIURI **aURI)
 46909: {
 46909:     return HttpBaseChannel::GetURI(aURI);
 46909: }
 46909: 
 46909: NS_IMETHODIMP
 46909: nsHttpChannel::GetNotificationCallbacks(nsIInterfaceRequestor **aCallbacks)
 46909: {
 46909:     return HttpBaseChannel::GetNotificationCallbacks(aCallbacks);
 46909: }
 46909: 
 46909: NS_IMETHODIMP
 46909: nsHttpChannel::GetLoadGroup(nsILoadGroup **aLoadGroup)
 46909: {
 46909:     return HttpBaseChannel::GetLoadGroup(aLoadGroup);
 46909: }
 46909: 
 46909: NS_IMETHODIMP
 46909: nsHttpChannel::GetRequestMethod(nsACString& aMethod)
 46909: {
 46909:     return HttpBaseChannel::GetRequestMethod(aMethod);
 46909: }
 46909: 
 46909: 
 46909: //-----------------------------------------------------------------------------
 43113: // nsHttpChannel::nsIRequestObserver
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpChannel::OnStartRequest(nsIRequest *request, nsISupports *ctxt)
 43113: {
 88104:     SAMPLE_LABEL("nsHttpChannel", "OnStartRequest");
 43113:     if (!(mCanceled || NS_FAILED(mStatus))) {
 43113:         // capture the request's status, so our consumers will know ASAP of any
 43113:         // connection failures, etc - bug 93581
 43113:         request->GetStatus(&mStatus);
 43113:     }
 43113: 
 43113:     LOG(("nsHttpChannel::OnStartRequest [this=%p request=%p status=%x]\n",
 43113:         this, request, mStatus));
 43113: 
 43113:     // Make sure things are what we expect them to be...
 43113:     NS_ASSERTION(request == mCachePump || request == mTransactionPump,
 43113:                  "Unexpected request");
 43113:     NS_ASSERTION(!(mTransactionPump && mCachePump) || mCachedContentIsPartial,
 43113:                  "If we have both pumps, the cache content must be partial");
 43113: 
 43113:     if (!mSecurityInfo && !mCachePump && mTransaction) {
 43113:         // grab the security info from the connection object; the transaction
 43113:         // is guaranteed to own a reference to the connection.
 43113:         mSecurityInfo = mTransaction->SecurityInfo();
 43113:     }
 43113: 
 88249:     if (!mCachePump && NS_FAILED(mStatus) &&
 84549:         (mLoadFlags & LOAD_REPLACE) && mOriginalURI && mAllowSpdy) {
 84549:         // For sanity's sake we may want to cancel an alternate protocol
 84549:         // redirection involving the original host name
 84549: 
 84549:         nsCAutoString hostPort;
 84549:         if (NS_SUCCEEDED(mOriginalURI->GetHostPort(hostPort)))
 84549:             gHttpHandler->ConnMgr()->RemoveSpdyAlternateProtocol(hostPort);
 84549:     }
 84549: 
 43113:     // don't enter this block if we're reading from the cache...
 43113:     if (NS_SUCCEEDED(mStatus) && !mCachePump && mTransaction) {
 72347:         // mTransactionPump doesn't hit OnInputStreamReady and call this until
 43113:         // all of the response headers have been acquired, so we can take ownership
 43113:         // of them from the transaction.
 43113:         mResponseHead = mTransaction->TakeResponseHead();
 43113:         // the response head may be null if the transaction was cancelled.  in
 43113:         // which case we just need to call OnStartRequest/OnStopRequest.
 43113:         if (mResponseHead)
 43113:             return ProcessResponse();
 43113: 
 43113:         NS_WARNING("No response head in OnStartRequest");
 43113:     }
 43113: 
 43113:     // avoid crashing if mListener happens to be null...
 43113:     if (!mListener) {
 43113:         NS_NOTREACHED("mListener is null");
 43113:         return NS_OK;
 43113:     }
 43113: 
 43113:     // on proxy errors, try to failover
 43113:     if (mConnectionInfo->ProxyInfo() &&
 43113:        (mStatus == NS_ERROR_PROXY_CONNECTION_REFUSED ||
 43113:         mStatus == NS_ERROR_UNKNOWN_PROXY_HOST ||
 43113:         mStatus == NS_ERROR_NET_TIMEOUT)) {
 48304: 
 48304:         PushRedirectAsyncFunc(&nsHttpChannel::ContinueOnStartRequest1);
 43113:         if (NS_SUCCEEDED(ProxyFailover()))
 43113:             return NS_OK;
 48304:         PopRedirectAsyncFunc(&nsHttpChannel::ContinueOnStartRequest1);
 48304:     }
 48304: 
 48304:     return ContinueOnStartRequest2(NS_OK);
 48304: }
 48304: 
 48304: nsresult
 48304: nsHttpChannel::ContinueOnStartRequest1(nsresult result)
 48304: {
 48304:     // Success indicates we passed ProxyFailover, in that case we must not continue
 48304:     // with this code chain.
 48304:     if (NS_SUCCEEDED(result))
 48304:         return NS_OK;
 48304: 
 48304:     return ContinueOnStartRequest2(result);
 48304: }
 48304: 
 48304: nsresult
 48304: nsHttpChannel::ContinueOnStartRequest2(nsresult result)
 48304: {
 43113:     // on other request errors, try to fall back
 48304:     if (NS_FAILED(mStatus)) {
 48304:         PushRedirectAsyncFunc(&nsHttpChannel::ContinueOnStartRequest3);
 79445:         bool waitingForRedirectCallback;
 54892:         ProcessFallback(&waitingForRedirectCallback);
 48304:         if (waitingForRedirectCallback)
 43113:             return NS_OK;
 48304:         PopRedirectAsyncFunc(&nsHttpChannel::ContinueOnStartRequest3);
 48304:     }
 48304: 
 48304:     return ContinueOnStartRequest3(NS_OK);
 48304: }
 48304: 
 48304: nsresult
 48304: nsHttpChannel::ContinueOnStartRequest3(nsresult result)
 48304: {
 48304:     if (mFallingBack)
 48304:         return NS_OK;
 43113: 
 43113:     return CallOnStartRequest();
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpChannel::OnStopRequest(nsIRequest *request, nsISupports *ctxt, nsresult status)
 43113: {
 87692:     SAMPLE_LABEL("network", "nsHttpChannel::OnStopRequest");
 43113:     LOG(("nsHttpChannel::OnStopRequest [this=%p request=%p status=%x]\n",
 43113:         this, request, status));
 43113: 
 70188:     if (mTimingEnabled && request == mCachePump) {
 70188:         mCacheReadEnd = mozilla::TimeStamp::Now();
 70188:     }
 70188: 
 63903:      // allow content to be cached if it was loaded successfully (bug #482935)
 79445:      bool contentComplete = NS_SUCCEEDED(status);
 63903: 
 43113:     // honor the cancelation status even if the underlying transaction completed.
 43113:     if (mCanceled || NS_FAILED(mStatus))
 43113:         status = mStatus;
 43113: 
 43113:     if (mCachedContentIsPartial) {
 43113:         if (NS_SUCCEEDED(status)) {
 43113:             // mTransactionPump should be suspended
 43113:             NS_ASSERTION(request != mTransactionPump,
 43113:                 "byte-range transaction finished prematurely");
 43113: 
 43113:             if (request == mCachePump) {
 79445:                 bool streamDone;
 43113:                 status = OnDoneReadingPartialCacheEntry(&streamDone);
 43113:                 if (NS_SUCCEEDED(status) && !streamDone)
 43113:                     return status;
 43113:                 // otherwise, fall through and fire OnStopRequest...
 43113:             }
 43113:             else
 43113:                 NS_NOTREACHED("unexpected request");
 43113:         }
 43113:         // Do not to leave the transaction in a suspended state in error cases.
 43113:         if (NS_FAILED(status) && mTransaction)
 43113:             gHttpHandler->CancelTransaction(mTransaction, status); 
 43113:     }
 43113: 
 43113:     if (mTransaction) {
 43113:         // determine if we should call DoAuthRetry
 79445:         bool authRetry = mAuthRetryPending && NS_SUCCEEDED(status);
 43113: 
 43113:         //
 70090:         // grab references to connection in case we need to retry an
 70090:         // authentication request over it or use it for an upgrade
 70090:         // to another protocol.
 43113:         //
 43113:         // this code relies on the code in nsHttpTransaction::Close, which
 43113:         // tests for NS_HTTP_STICKY_CONNECTION to determine whether or not to
 43113:         // keep the connection around after the transaction is finished.
 43113:         //
 69895:         nsRefPtr<nsAHttpConnection> conn;
 43113:         if (authRetry && (mCaps & NS_HTTP_STICKY_CONNECTION)) {
 69895:             conn = mTransaction->Connection();
 43113:             // This is so far a workaround to fix leak when reusing unpersistent
 43113:             // connection for authentication retry. See bug 459620 comment 4
 43113:             // for details.
 43113:             if (conn && !conn->IsPersistent())
 43113:                 conn = nsnull;
 43113:         }
 43113: 
 70090:         nsRefPtr<nsAHttpConnection> stickyConn;
 70090:         if (mCaps & NS_HTTP_STICKY_CONNECTION)
 70090:             stickyConn = mTransaction->Connection();
 70090:         
 43113:         // at this point, we're done with the transaction
 70188:         mTransactionTimings = mTransaction->Timings();
 46790:         mTransaction = nsnull;
 43113:         mTransactionPump = 0;
 43113: 
 70364:         // We no longer need the dns prefetch object
 70364:         if (mDNSPrefetch && mDNSPrefetch->TimingsValid()) {
 70364:             mTransactionTimings.domainLookupStart =
 70364:                 mDNSPrefetch->StartTimestamp();
 70364:             mTransactionTimings.domainLookupEnd =
 70364:                 mDNSPrefetch->EndTimestamp();
 70364:         }
 70364:         mDNSPrefetch = nsnull;
 70364: 
 43113:         // handle auth retry...
 43113:         if (authRetry) {
 80486:             mAuthRetryPending = false;
 43113:             status = DoAuthRetry(conn);
 43113:             if (NS_SUCCEEDED(status))
 43113:                 return NS_OK;
 43113:         }
 43113: 
 43113:         // If DoAuthRetry failed, or if we have been cancelled since showing
 43113:         // the auth. dialog, then we need to send OnStartRequest now
 43113:         if (authRetry || (mAuthRetryPending && NS_FAILED(status))) {
 43113:             NS_ASSERTION(NS_FAILED(status), "should have a failure code here");
 43113:             // NOTE: since we have a failure status, we can ignore the return
 43113:             // value from onStartRequest.
 43113:             mListener->OnStartRequest(this, mListenerContext);
 43113:         }
 43113: 
 43113:         // if this transaction has been replaced, then bail.
 43113:         if (mTransactionReplaced)
 43113:             return NS_OK;
 70090:         
 70090:         if (mUpgradeProtocolCallback && stickyConn &&
 70090:             mResponseHead && mResponseHead->Status() == 101) {
 96974:             gHttpHandler->ConnMgr()->CompleteUpgrade(stickyConn,
 96974:                                                      mUpgradeProtocolCallback);
 70090:         }
 43113:     }
 43113: 
 80486:     mIsPending = false;
 43113:     mStatus = status;
 43113: 
 61191:     // perform any final cache operations before we close the cache entry.
 61191:     if (mCacheEntry && (mCacheAccess & nsICache::ACCESS_WRITE) &&
 61191:         mRequestTimeInitialized){
 61191:         FinalizeCacheEntry();
 61191:     }
 61191:     
 43113:     if (mListener) {
 43113:         LOG(("  calling OnStopRequest\n"));
 43113:         mListener->OnStopRequest(this, mListenerContext, status);
 43113:         mListener = 0;
 43113:         mListenerContext = 0;
 43113:     }
 43113: 
 80890:     if (mCacheEntry) {
 80890:         bool asFile = false;
 80890:         if (mInitedCacheEntry && !mCachedContentIsPartial &&
 80890:             (NS_SUCCEEDED(mStatus) || contentComplete) &&
 80890:             (mCacheAccess & nsICache::ACCESS_WRITE) &&
 80890:             NS_SUCCEEDED(GetCacheAsFile(&asFile)) && asFile) {
 80890:             // We can allow others access to the cache entry
 80890:             // because we don't write to the cache anymore.
 80890:             // CloseCacheEntry may not actually close the cache
 80890:             // entry immediately because someone (such as XHR2
 80890:             // blob response) may hold the token to the cache
 80890:             // entry. So we mark the cache valid here.
 80890:             // We also need to check the entry is stored as file
 80890:             // because we write to the cache asynchronously when
 80890:             // it isn't stored in the file and it isn't completely
 80890:             // written to the disk yet.
 80890:             mCacheEntry->MarkValid();
 80890:         }
 99879:     }
 63903:     CloseCacheEntry(!contentComplete);
 43113: 
 43113:     if (mOfflineCacheEntry)
 43113:         CloseOfflineCacheEntry();
 43113: 
 43113:     if (mLoadGroup)
 43113:         mLoadGroup->RemoveRequest(this, nsnull, status);
 43113: 
 63794:     // We don't need this info anymore
 63794:     CleanRedirectCacheChainIfNecessary();
 63794: 
 43113:     mCallbacks = nsnull;
 43113:     mProgressSink = nsnull;
 43113:     
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpChannel::nsIStreamListener
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpChannel::OnDataAvailable(nsIRequest *request, nsISupports *ctxt,
 43113:                                nsIInputStream *input,
 43113:                                PRUint32 offset, PRUint32 count)
 43113: {
 87692:     SAMPLE_LABEL("network", "nsHttpChannel::OnDataAvailable");
 43113:     LOG(("nsHttpChannel::OnDataAvailable [this=%p request=%p offset=%u count=%u]\n",
 43113:         this, request, offset, count));
 43113: 
 43113:     // don't send out OnDataAvailable notifications if we've been canceled.
 43113:     if (mCanceled)
 43113:         return mStatus;
 43113: 
 43113:     NS_ASSERTION(mResponseHead, "No response head in ODA!!");
 43113: 
 43113:     NS_ASSERTION(!(mCachedContentIsPartial && (request == mTransactionPump)),
 43113:             "transaction pump not suspended");
 43113: 
 43113:     if (mAuthRetryPending || (request == mTransactionPump && mTransactionReplaced)) {
 43113:         PRUint32 n;
 43113:         return input->ReadSegments(NS_DiscardSegment, nsnull, count, &n);
 43113:     }
 43113: 
 43113:     if (mListener) {
 43113:         //
 43113:         // synthesize transport progress event.  we do this here since we want
 43113:         // to delay OnProgress events until we start streaming data.  this is
 43113:         // crucially important since it impacts the lock icon (see bug 240053).
 43113:         //
 43113:         nsresult transportStatus;
 43113:         if (request == mCachePump)
 43113:             transportStatus = nsITransport::STATUS_READING;
 43113:         else
 43113:             transportStatus = nsISocketTransport::STATUS_RECEIVING_FROM;
 43113: 
 43113:         // mResponseHead may reference new or cached headers, but either way it
 43113:         // holds our best estimate of the total content length.  Even in the case
 43113:         // of a byte range request, the content length stored in the cached
 43113:         // response headers is what we want to use here.
 43113: 
 51740:         PRUint64 progressMax(PRUint64(mResponseHead->ContentLength()));
 43113:         PRUint64 progress = mLogicalOffset + PRUint64(count);
 43113:         NS_ASSERTION(progress <= progressMax, "unexpected progress values");
 43113: 
 43113:         OnTransportStatus(nsnull, transportStatus, progress, progressMax);
 43113: 
 43113:         //
 43113:         // we have to manually keep the logical offset of the stream up-to-date.
 43113:         // we cannot depend solely on the offset provided, since we may have 
 43113:         // already streamed some data from another source (see, for example,
 43113:         // OnDoneReadingPartialCacheEntry).
 43113:         //
 94801: 
 94801:         // report the current stream offset to our listener... if we've
 94801:         // streamed more than PR_UINT32_MAX, then avoid overflowing the
 94801:         // stream offset.  it's the best we can do without a 64-bit stream
 94801:         // listener API. (Copied from nsInputStreamPump::OnStateTransfer.)
 94801:         PRUint32 odaOffset = mLogicalOffset > PR_UINT32_MAX
 94801:                            ? PR_UINT32_MAX : PRUint32(mLogicalOffset);
 94801: 
 43113:         nsresult rv =  mListener->OnDataAvailable(this,
 43113:                                                   mListenerContext,
 43113:                                                   input,
 94801:                                                   odaOffset,
 43113:                                                   count);
 43113:         if (NS_SUCCEEDED(rv))
 43113:             mLogicalOffset = progress;
 43113:         return rv;
 43113:     }
 43113: 
 43113:     return NS_ERROR_ABORT;
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpChannel::nsITransportEventSink
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpChannel::OnTransportStatus(nsITransport *trans, nsresult status,
 43113:                                  PRUint64 progress, PRUint64 progressMax)
 43113: {
 43113:     // cache the progress sink so we don't have to query for it each time.
 43113:     if (!mProgressSink)
 43113:         GetCallback(mProgressSink);
 43113: 
 67756:     if (status == nsISocketTransport::STATUS_CONNECTED_TO ||
 67756:         status == nsISocketTransport::STATUS_WAITING_FOR) {
 67756:         nsCOMPtr<nsISocketTransport> socketTransport =
 67756:             do_QueryInterface(trans);
 67756:         if (socketTransport) {
 67756:             socketTransport->GetSelfAddr(&mSelfAddr);
 67756:             socketTransport->GetPeerAddr(&mPeerAddr);
 67756:         }
 67756:     }
 67756: 
 43113:     // block socket status event after Cancel or OnStopRequest has been called.
 43113:     if (mProgressSink && NS_SUCCEEDED(mStatus) && mIsPending && !(mLoadFlags & LOAD_BACKGROUND)) {
 43113:         LOG(("sending status notification [this=%p status=%x progress=%llu/%llu]\n",
 43113:             this, status, progress, progressMax));
 43113: 
 43113:         nsCAutoString host;
 43113:         mURI->GetHost(host);
 43113:         mProgressSink->OnStatus(this, nsnull, status,
 43113:                                 NS_ConvertUTF8toUTF16(host).get());
 43113: 
 43113:         if (progress > 0) {
 43113:             NS_ASSERTION(progress <= progressMax, "unexpected progress values");
 43113:             mProgressSink->OnProgress(this, nsnull, progress, progressMax);
 43113:         }
 43113:     }
 43113: #ifdef DEBUG
 43113:     else
 43113:         LOG(("skipping status notification [this=%p sink=%p pending=%u background=%x]\n",
 43113:             this, mProgressSink.get(), mIsPending, (mLoadFlags & LOAD_BACKGROUND)));
 43113: #endif
 43113: 
 43113:     return NS_OK;
 43113: } 
 43113: 
 43113: //-----------------------------------------------------------------------------
 46915: // nsHttpChannel::nsICacheInfoChannel
 46915: //-----------------------------------------------------------------------------
 46915: 
 46915: NS_IMETHODIMP
 79445: nsHttpChannel::IsFromCache(bool *value)
 46915: {
 46915:     if (!mIsPending)
 46915:         return NS_ERROR_NOT_AVAILABLE;
 46915: 
 46915:     // return false if reading a partial cache entry; the data isn't entirely
 46915:     // from the cache!
 46915: 
 46915:     *value = (mCachePump || (mLoadFlags & LOAD_ONLY_IF_MODIFIED)) &&
 46915:               mCachedContentIsValid && !mCachedContentIsPartial;
 46915: 
 46915:     return NS_OK;
 46915: }
 46915: 
 46915: NS_IMETHODIMP
 46915: nsHttpChannel::GetCacheTokenExpirationTime(PRUint32 *_retval)
 46915: {
 46915:     NS_ENSURE_ARG_POINTER(_retval);
 46915:     if (!mCacheEntry)
 46915:         return NS_ERROR_NOT_AVAILABLE;
 46915: 
 46915:     return mCacheEntry->GetExpirationTime(_retval);
 46915: }
 46915: 
 46915: NS_IMETHODIMP
 46915: nsHttpChannel::GetCacheTokenCachedCharset(nsACString &_retval)
 46915: {
 46915:     nsresult rv;
 46915: 
 46915:     if (!mCacheEntry)
 46915:         return NS_ERROR_NOT_AVAILABLE;
 46915: 
 46915:     nsXPIDLCString cachedCharset;
 46915:     rv = mCacheEntry->GetMetaDataElement("charset",
 46915:                                          getter_Copies(cachedCharset));
 46915:     if (NS_SUCCEEDED(rv))
 46915:         _retval = cachedCharset;
 46915: 
 46915:     return rv;
 46915: }
 46915: 
 46915: NS_IMETHODIMP
 46915: nsHttpChannel::SetCacheTokenCachedCharset(const nsACString &aCharset)
 46915: {
 46915:     if (!mCacheEntry)
 46915:         return NS_ERROR_NOT_AVAILABLE;
 46915: 
 46915:     return mCacheEntry->SetMetaDataElement("charset",
 46915:                                            PromiseFlatCString(aCharset).get());
 46915: }
 46915: 
 46915: //-----------------------------------------------------------------------------
 43113: // nsHttpChannel::nsICachingChannel
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpChannel::GetCacheToken(nsISupports **token)
 43113: {
 43113:     NS_ENSURE_ARG_POINTER(token);
 43113:     if (!mCacheEntry)
 43113:         return NS_ERROR_NOT_AVAILABLE;
 43113:     return CallQueryInterface(mCacheEntry, token);
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpChannel::SetCacheToken(nsISupports *token)
 43113: {
 43113:     return NS_ERROR_NOT_IMPLEMENTED;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpChannel::GetOfflineCacheToken(nsISupports **token)
 43113: {
 43113:     NS_ENSURE_ARG_POINTER(token);
 43113:     if (!mOfflineCacheEntry)
 43113:         return NS_ERROR_NOT_AVAILABLE;
 43113:     return CallQueryInterface(mOfflineCacheEntry, token);
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpChannel::SetOfflineCacheToken(nsISupports *token)
 43113: {
 43113:     return NS_ERROR_NOT_IMPLEMENTED;
 43113: }
 43113: 
101868: class nsHttpChannelCacheKey MOZ_FINAL : public nsISupportsPRUint32,
 43113:                                         public nsISupportsCString
 43113: {
 43113:     NS_DECL_ISUPPORTS
 43113: 
 43113:     NS_DECL_NSISUPPORTSPRIMITIVE
 43113:     NS_FORWARD_NSISUPPORTSPRUINT32(mSupportsPRUint32->)
 43113:     
 43113:     // Both interfaces declares toString method with the same signature.
 43113:     // Thus we have to delegate only to nsISupportsPRUint32 implementation.
 43113:     NS_SCRIPTABLE NS_IMETHOD GetData(nsACString & aData) 
 43113:     { 
 43113:         return mSupportsCString->GetData(aData);
 43113:     }
 43113:     NS_SCRIPTABLE NS_IMETHOD SetData(const nsACString & aData)
 43113:     { 
 43113:         return mSupportsCString->SetData(aData);
 43113:     }
 43113:     
 43113: public:
 43113:     nsresult SetData(PRUint32 aPostID, const nsACString& aKey);
 43113: 
 43113: protected:
 43113:     nsCOMPtr<nsISupportsPRUint32> mSupportsPRUint32;
 43113:     nsCOMPtr<nsISupportsCString> mSupportsCString;
 43113: };
 43113: 
 43113: NS_IMPL_ADDREF(nsHttpChannelCacheKey)
 43113: NS_IMPL_RELEASE(nsHttpChannelCacheKey)
 43113: NS_INTERFACE_TABLE_HEAD(nsHttpChannelCacheKey)
 43113: NS_INTERFACE_TABLE_BEGIN
 43113: NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(nsHttpChannelCacheKey,
 43113:                                    nsISupports, nsISupportsPRUint32)
 43113: NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(nsHttpChannelCacheKey,
 43113:                                    nsISupportsPrimitive, nsISupportsPRUint32)
 43113: NS_INTERFACE_TABLE_ENTRY(nsHttpChannelCacheKey,
 43113:                          nsISupportsPRUint32)
 43113: NS_INTERFACE_TABLE_ENTRY(nsHttpChannelCacheKey,
 43113:                          nsISupportsCString)
 43113: NS_INTERFACE_TABLE_END
 43113: NS_INTERFACE_TABLE_TAIL
 43113: 
 43113: NS_IMETHODIMP nsHttpChannelCacheKey::GetType(PRUint16 *aType)
 43113: {
 43113:     NS_ENSURE_ARG_POINTER(aType);
 43113: 
 43113:     *aType = TYPE_PRUINT32;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: nsresult nsHttpChannelCacheKey::SetData(PRUint32 aPostID,
 43113:                                         const nsACString& aKey)
 43113: {
 43113:     nsresult rv;
 43113: 
 43113:     mSupportsCString = 
 43113:         do_CreateInstance(NS_SUPPORTS_CSTRING_CONTRACTID, &rv);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     mSupportsCString->SetData(aKey);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     mSupportsPRUint32 = 
 43113:         do_CreateInstance(NS_SUPPORTS_PRUINT32_CONTRACTID, &rv);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     mSupportsPRUint32->SetData(aPostID);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpChannel::GetCacheKey(nsISupports **key)
 43113: {
 43113:     nsresult rv;
 43113:     NS_ENSURE_ARG_POINTER(key);
 43113: 
 43113:     LOG(("nsHttpChannel::GetCacheKey [this=%p]\n", this));
 43113: 
 43113:     *key = nsnull;
 43113: 
 43113:     nsRefPtr<nsHttpChannelCacheKey> container =
 43113:         new nsHttpChannelCacheKey();
 43113: 
 43113:     if (!container)
 43113:         return NS_ERROR_OUT_OF_MEMORY;
 43113: 
 43113:     nsCAutoString cacheKey;
 43113:     rv = GenerateCacheKey(mPostID, cacheKey);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     rv = container->SetData(mPostID, cacheKey);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     return CallQueryInterface(container.get(), key);
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpChannel::SetCacheKey(nsISupports *key)
 43113: {
 43113:     nsresult rv;
 43113: 
 43113:     LOG(("nsHttpChannel::SetCacheKey [this=%p key=%p]\n", this, key));
 43113: 
 99869:     ENSURE_CALLED_BEFORE_ASYNC_OPEN();
 43113: 
 43113:     if (!key)
 43113:         mPostID = 0;
 43113:     else {
 43113:         // extract the post id
 43113:         nsCOMPtr<nsISupportsPRUint32> container = do_QueryInterface(key, &rv);
 43113:         if (NS_FAILED(rv)) return rv;
 43113: 
 43113:         rv = container->GetData(&mPostID);
 43113:         if (NS_FAILED(rv)) return rv;
 43113:     }
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 79445: nsHttpChannel::GetCacheAsFile(bool *value)
 43113: {
 43113:     NS_ENSURE_ARG_POINTER(value);
 43113:     if (!mCacheEntry)
 43113:         return NS_ERROR_NOT_AVAILABLE;
 43113:     nsCacheStoragePolicy storagePolicy;
 43113:     mCacheEntry->GetStoragePolicy(&storagePolicy);
 43113:     *value = (storagePolicy == nsICache::STORE_ON_DISK_AS_FILE);
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 79445: nsHttpChannel::SetCacheAsFile(bool value)
 43113: {
 43113:     if (!mCacheEntry || mLoadFlags & INHIBIT_PERSISTENT_CACHING)
 43113:         return NS_ERROR_NOT_AVAILABLE;
 43113:     nsCacheStoragePolicy policy;
 43113:     if (value)
 43113:         policy = nsICache::STORE_ON_DISK_AS_FILE;
 43113:     else
 43113:         policy = nsICache::STORE_ANYWHERE;
 43113:     return mCacheEntry->SetStoragePolicy(policy);
 43113: }
 43113: 
 43113: 
 43113: NS_IMETHODIMP
 79445: nsHttpChannel::GetCacheForOfflineUse(bool *value)
 43113: {
 43113:     *value = mCacheForOfflineUse;
 43113: 
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 79445: nsHttpChannel::SetCacheForOfflineUse(bool value)
 43113: {
 99869:     ENSURE_CALLED_BEFORE_ASYNC_OPEN();
 99869: 
 43113:     mCacheForOfflineUse = value;
 43113: 
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpChannel::GetOfflineCacheClientID(nsACString &value)
 43113: {
 43113:     value = mOfflineCacheClientID;
 43113: 
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpChannel::SetOfflineCacheClientID(const nsACString &value)
 43113: {
 99869:     ENSURE_CALLED_BEFORE_ASYNC_OPEN();
 99869: 
 43113:     mOfflineCacheClientID = value;
 43113: 
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
101111: nsHttpChannel::GetProfileDirectory(nsIFile **_result)
100212: {
100212:     NS_ENSURE_ARG(_result);
100212: 
101616:     if (!mProfileDirectory)
101616:         return NS_ERROR_NOT_AVAILABLE;
101616: 
100212:     NS_ADDREF(*_result = mProfileDirectory);
100212:     return NS_OK;
100212: }
100212: 
100212: NS_IMETHODIMP
101111: nsHttpChannel::SetProfileDirectory(nsIFile *value)
100212: {
100212:     mProfileDirectory = value;
100212:     return NS_OK;
100212: }
100212: 
100212: NS_IMETHODIMP
 43113: nsHttpChannel::GetCacheFile(nsIFile **cacheFile)
 43113: {
 43113:     if (!mCacheEntry)
 43113:         return NS_ERROR_NOT_AVAILABLE;
 43113:     return mCacheEntry->GetFile(cacheFile);
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpChannel::nsIResumableChannel
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpChannel::ResumeAt(PRUint64 aStartPos,
 43113:                         const nsACString& aEntityID)
 43113: {
 43113:     LOG(("nsHttpChannel::ResumeAt [this=%p startPos=%llu id='%s']\n",
 43113:          this, aStartPos, PromiseFlatCString(aEntityID).get()));
 43113:     mEntityID = aEntityID;
 43113:     mStartPos = aStartPos;
 80486:     mResuming = true;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpChannel::nsICacheListener
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpChannel::OnCacheEntryAvailable(nsICacheEntryDescriptor *entry,
 43113:                                      nsCacheAccessMode access,
 43113:                                      nsresult status)
 43113: {
 99878:     MOZ_ASSERT(NS_IsMainThread());
 99878: 
 53987:     nsresult rv;
 53987: 
 43113:     LOG(("nsHttpChannel::OnCacheEntryAvailable [this=%p entry=%p "
 43113:          "access=%x status=%x]\n", this, entry, access, status));
 43113: 
 99878:     if (mCacheQuery) {
 99878:         mRequestHead = mCacheQuery->mRequestHead;
 99878:         mRedirectedCachekeys = mCacheQuery->mRedirectedCachekeys.forget();
103136:         mCacheInputStream.takeOver(mCacheQuery->mCacheInputStream);
 99878:         mCachedResponseHead = mCacheQuery->mCachedResponseHead.forget();
 99878:         mCachedSecurityInfo = mCacheQuery->mCachedSecurityInfo.forget();
 99878:         mCachedContentIsValid = mCacheQuery->mCachedContentIsValid;
 99878:         mCachedContentIsPartial = mCacheQuery->mCachedContentIsPartial;
 99878:         mCustomConditionalRequest = mCacheQuery->mCustomConditionalRequest;
 99878:         mDidReval = mCacheQuery->mDidReval;
 99880:         mCacheEntryDeviceTelemetryID = mCacheQuery->mCacheEntryDeviceTelemetryID;
 99878:         mCacheQuery = nsnull;
 99878:     }
 99878: 
 43113:     // if the channel's already fired onStopRequest, then we should ignore
 43113:     // this event.
 99879:     if (!mIsPending) {
103136:         mCacheInputStream.CloseAndRelease();
 43113:         return NS_OK;
 99879:     }
 43113: 
 93830:     rv = OnCacheEntryAvailableInternal(entry, access, status);
 99878: 
 93830:     if (NS_FAILED(rv)) {
 93830:         CloseCacheEntry(true);
 93830:         AsyncAbort(rv);
 93830:     }
 93830: 
 93830:     return NS_OK;
 93830: }
 93830: 
 93830: nsresult
 93830: nsHttpChannel::OnCacheEntryAvailableInternal(nsICacheEntryDescriptor *entry,
 93830:                                              nsCacheAccessMode access,
 93830:                                              nsresult status)
 93830: {
 93830:     nsresult rv;
 93830: 
 53987:     nsOnCacheEntryAvailableCallback callback = mOnCacheEntryAvailableCallback;
 53987:     mOnCacheEntryAvailableCallback = nsnull;
 53987: 
 53987:     NS_ASSERTION(callback,
 53987:         "nsHttpChannel::OnCacheEntryAvailable called without callback");
 93830:     rv = ((*this).*callback)(entry, access, status);
 93830: 
 93830:     if (mOnCacheEntryAvailableCallback) {
 93830:         // callback fired another async open
 93830:         NS_ASSERTION(NS_SUCCEEDED(rv), "Unexpected state");
 93830:         return NS_OK;
 93830:     }
 93830: 
 93830:     if (callback != &nsHttpChannel::OnOfflineCacheEntryForWritingAvailable) {
 43113:         if (NS_FAILED(rv)) {
 53987:             LOG(("AsyncOpenCacheEntry failed [rv=%x]\n", rv));
 53987:             if (mLoadFlags & LOAD_ONLY_FROM_CACHE) {
 53987:                 // If we have a fallback URI (and we're not already
 53987:                 // falling back), process the fallback asynchronously.
 53987:                 if (!mFallbackChannel && !mFallbackKey.IsEmpty()) {
 93830:                     return AsyncCall(&nsHttpChannel::HandleAsyncFallback);
 93830:                 }
 93830:                 return NS_ERROR_DOCUMENT_NOT_CACHED;
 93830:             }
 93830:             // proceed without using the cache
 93830:         }
 93830: 
 93830:         // if cacheForOfflineUse has been set, open up an offline cache entry
 93830:         // to update
 93830:         if (mCacheForOfflineUse) {
 93830:             rv = OpenOfflineCacheEntryForWriting();
 93830:             if (mOnCacheEntryAvailableCallback) {
 93830:                 NS_ASSERTION(NS_SUCCEEDED(rv), "Unexpected state");
 93830:                 return NS_OK;
 93830:             }
 93830: 
 93830:             if (NS_FAILED(rv))
 53987:                 return rv;
 53987:         }
 93830:     } else {
 93830:         // check result of OnOfflineCacheEntryForWritingAvailable()
 93830:         if (NS_FAILED(rv))
 93830:             return rv;
 93830:     }
 93830: 
 99870:     return ContinueConnect();
 43113: }
 43113: 
 93831: NS_IMETHODIMP
 93831: nsHttpChannel::OnCacheEntryDoomed(nsresult status)
 93831: {
 93831:     return NS_ERROR_NOT_IMPLEMENTED;
 93831: }
 93831: 
 43113: nsresult
 43113: nsHttpChannel::DoAuthRetry(nsAHttpConnection *conn)
 43113: {
 43113:     LOG(("nsHttpChannel::DoAuthRetry [this=%p]\n", this));
 43113: 
 43113:     NS_ASSERTION(!mTransaction, "should not have a transaction");
 43113:     nsresult rv;
 43113: 
 43113:     // toggle mIsPending to allow nsIObserver implementations to modify
 43113:     // the request headers (bug 95044).
 80486:     mIsPending = false;
 43113: 
 43113:     // fetch cookies, and add them to the request header.
 43113:     // the server response could have included cookies that must be sent with
 43113:     // this authentication attempt (bug 84794).
 46906:     // TODO: save cookies from auth response and send them here (bug 572151).
 43113:     AddCookiesToRequest();
 43113:     
 43113:     // notify "http-on-modify-request" observers
 43113:     gHttpHandler->OnModifyRequest(this);
 43113: 
 80486:     mIsPending = true;
 43113: 
 43113:     // get rid of the old response headers
 43113:     mResponseHead = nsnull;
 43113: 
 43113:     // set sticky connection flag and disable pipelining.
 43113:     mCaps |=  NS_HTTP_STICKY_CONNECTION;
 43113:     mCaps &= ~NS_HTTP_ALLOW_PIPELINING;
 43113:    
 43113:     // and create a new one...
 43113:     rv = SetupTransaction();
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     // transfer ownership of connection to transaction
 43113:     if (conn)
 43113:         mTransaction->SetConnection(conn);
 43113: 
 43113:     // rewind the upload stream
 43113:     if (mUploadStream) {
 43113:         nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(mUploadStream);
 43113:         if (seekable)
 43113:             seekable->Seek(nsISeekableStream::NS_SEEK_SET, 0);
 43113:     }
 43113: 
 43113:     rv = gHttpHandler->InitiateTransaction(mTransaction, mPriority);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 53987:     rv = mTransactionPump->AsyncRead(this, nsnull);
 53987:     if (NS_FAILED(rv)) return rv;
 53987: 
 53987:     PRUint32 suspendCount = mSuspendCount;
 53987:     while (suspendCount--)
 53987:         mTransactionPump->Suspend();
 53987: 
 53987:     return NS_OK;
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpChannel::nsIApplicationCacheChannel
 43113: //-----------------------------------------------------------------------------
 43113: NS_IMETHODIMP
 43113: nsHttpChannel::GetApplicationCache(nsIApplicationCache **out)
 43113: {
 43113:     NS_IF_ADDREF(*out = mApplicationCache);
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpChannel::SetApplicationCache(nsIApplicationCache *appCache)
 43113: {
 99869:     ENSURE_CALLED_BEFORE_ASYNC_OPEN();
 43113: 
 43113:     mApplicationCache = appCache;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 79445: nsHttpChannel::GetLoadedFromApplicationCache(bool *aLoadedFromApplicationCache)
 43113: {
 43113:     *aLoadedFromApplicationCache = mLoadedFromApplicationCache;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 79445: nsHttpChannel::GetInheritApplicationCache(bool *aInherit)
 43113: {
 43113:     *aInherit = mInheritApplicationCache;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 79445: nsHttpChannel::SetInheritApplicationCache(bool aInherit)
 43113: {
 99869:     ENSURE_CALLED_BEFORE_ASYNC_OPEN();
 43113: 
 43113:     mInheritApplicationCache = aInherit;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 79445: nsHttpChannel::GetChooseApplicationCache(bool *aChoose)
 43113: {
 43113:     *aChoose = mChooseApplicationCache;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 79445: nsHttpChannel::SetChooseApplicationCache(bool aChoose)
 43113: {
 99869:     ENSURE_CALLED_BEFORE_ASYNC_OPEN();
 43113: 
 43113:     mChooseApplicationCache = aChoose;
 43113:     return NS_OK;
 43113: }
 43113: 
 97914: nsHttpChannel::OfflineCacheEntryAsForeignMarker*
 97914: nsHttpChannel::GetOfflineCacheEntryAsForeignMarker()
 97914: {
 97914:     if (!mApplicationCache)
 97914:         return nsnull;
 97914: 
 97914:     nsresult rv;
 97914: 
 97914:     nsCAutoString cacheKey;
 97914:     rv = GenerateCacheKey(mPostID, cacheKey);
 97914:     NS_ENSURE_SUCCESS(rv, nsnull);
 97914: 
 97914:     return new OfflineCacheEntryAsForeignMarker(mApplicationCache, cacheKey);
 97914: }
 97914: 
 97914: nsresult
 97914: nsHttpChannel::OfflineCacheEntryAsForeignMarker::MarkAsForeign()
 97914: {
 97914:     return mApplicationCache->MarkEntry(mCacheKey,
 97914:                                         nsIApplicationCache::ITEM_FOREIGN);
 97914: }
 97914: 
 56242: NS_IMETHODIMP
 56242: nsHttpChannel::MarkOfflineCacheEntryAsForeign()
 56242: {
 97914:     nsresult rv;
 97914: 
 97914:     nsAutoPtr<OfflineCacheEntryAsForeignMarker> marker(
 97914:         GetOfflineCacheEntryAsForeignMarker());
 97914: 
 97914:     if (!marker)
 97855:         return NS_ERROR_NOT_AVAILABLE;
 97855: 
 97914:     rv = marker->MarkAsForeign();
 56242:     NS_ENSURE_SUCCESS(rv, rv);
 56242: 
 56242:     return NS_OK;
 56242: }
 56242: 
 43113: //-----------------------------------------------------------------------------
 48304: // nsHttpChannel::nsIAsyncVerifyRedirectCallback
 48304: //-----------------------------------------------------------------------------
 48304: 
 48304: nsresult
 48304: nsHttpChannel::WaitForRedirectCallback()
 48304: {
 48304:     nsresult rv;
 50824:     LOG(("nsHttpChannel::WaitForRedirectCallback [this=%p]\n", this));
 50824: 
 48304:     if (mTransactionPump) {
 48304:         rv = mTransactionPump->Suspend();
 48304:         NS_ENSURE_SUCCESS(rv, rv);
 48304:     }
 48304:     if (mCachePump) {
 48304:         rv = mCachePump->Suspend();
 48304:         if (NS_FAILED(rv) && mTransactionPump) {
 54892: #ifdef DEBUG
 54892:             nsresult resume = 
 54892: #endif
 54892:             mTransactionPump->Resume();
 48304:             NS_ASSERTION(NS_SUCCEEDED(resume),
 48304:                 "Failed to resume transaction pump");
 48304:         }
 48304:         NS_ENSURE_SUCCESS(rv, rv);
 48304:     }
 48304: 
 80486:     mWaitingForRedirectCallback = true;
 48304:     return NS_OK;
 48304: }
 48304: 
 48304: NS_IMETHODIMP
 48304: nsHttpChannel::OnRedirectVerifyCallback(nsresult result)
 48304: {
 48889:     LOG(("nsHttpChannel::OnRedirectVerifyCallback [this=%p] "
 48889:          "result=%x stack=%d mWaitingForRedirectCallback=%u\n",
 48889:          this, result, mRedirectFuncStack.Length(), mWaitingForRedirectCallback));
 48304:     NS_ASSERTION(mWaitingForRedirectCallback,
 48304:                  "Someone forgot to call WaitForRedirectCallback() ?!");
 80486:     mWaitingForRedirectCallback = false;
 48304: 
 48304:     if (mCanceled && NS_SUCCEEDED(result))
 48304:         result = NS_BINDING_ABORTED;
 48304: 
 48304:     for (PRUint32 i = mRedirectFuncStack.Length(); i > 0;) {
 48304:         --i;
 48304:         // Pop the last function pushed to the stack
 48304:         nsContinueRedirectionFunc func = mRedirectFuncStack[i];
 48304:         mRedirectFuncStack.RemoveElementAt(mRedirectFuncStack.Length() - 1);
 48304: 
 48304:         // Call it with the result we got from the callback or the deeper
 48304:         // function call.
 48304:         result = (this->*func)(result);
 48304: 
 48304:         // If a new function has been pushed to the stack and placed us in the
 48304:         // waiting state, we need to break the chain and wait for the callback
 48304:         // again.
 48304:         if (mWaitingForRedirectCallback)
 48304:             break;
 48304:     }
 48304: 
 48304:     if (NS_FAILED(result) && !mCanceled) {
 48304:         // First, cancel this channel if we are in failure state to set mStatus
 48304:         // and let it be propagated to pumps.
 48304:         Cancel(result);
 48304:     }
 48304: 
 48304:     if (!mWaitingForRedirectCallback) {
 48304:         // We are not waiting for the callback. At this moment we must release
 48304:         // reference to the redirect target channel, otherwise we may leak.
 48304:         mRedirectChannel = nsnull;
 48304:     }
 48304: 
 48304:     // We always resume the pumps here. If all functions on stack have been
 48304:     // called we need OnStopRequest to be triggered, and if we broke out of the
 48304:     // loop above (and are thus waiting for a new callback) the suspension
 48304:     // count must be balanced in the pumps.
 48304:     if (mTransactionPump)
 48304:         mTransactionPump->Resume();
 48304:     if (mCachePump)
 48304:         mCachePump->Resume();
 48304: 
 48304:     return result;
 48304: }
 48304: 
 48304: void
 48304: nsHttpChannel::PushRedirectAsyncFunc(nsContinueRedirectionFunc func)
 48304: {
 48304:     mRedirectFuncStack.AppendElement(func);
 48304: }
 48304: 
 48304: void
 48304: nsHttpChannel::PopRedirectAsyncFunc(nsContinueRedirectionFunc func)
 48304: {
 48304:     NS_ASSERTION(func == mRedirectFuncStack[mRedirectFuncStack.Length() - 1],
 48304:         "Trying to pop wrong method from redirect async stack!");
 48304: 
 48304:     mRedirectFuncStack.TruncateLength(mRedirectFuncStack.Length() - 1);
 48304: }
 48304: 
 70436: 
 48304: //-----------------------------------------------------------------------------
 70436: // nsHttpChannel internal functions
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: void
 43113: nsHttpChannel::MaybeInvalidateCacheEntryForSubsequentGet()
 43113: {
 43113:     // See RFC 2616 section 5.1.1. These are considered valid
 43113:     // methods which DO NOT invalidate cache-entries for the
 43113:     // referred resource. POST, PUT and DELETE as well as any
 43113:     // other method not listed here will potentially invalidate
 43113:     // any cached copy of the resource
 43113:     if (mRequestHead.Method() == nsHttp::Options ||
 43113:        mRequestHead.Method() == nsHttp::Get ||
 43113:        mRequestHead.Method() == nsHttp::Head ||
 43113:        mRequestHead.Method() == nsHttp::Trace ||
 43113:        mRequestHead.Method() == nsHttp::Connect)
 43113:         return;
 43113: 
 71627: 
 71627:     // Invalidate the request-uri.
 71627:     // Pass 0 in first param to get the cache-key for a GET-request.
 71627:     nsCAutoString tmpCacheKey;
 71627:     GenerateCacheKey(0, tmpCacheKey);
 71627:     LOG(("MaybeInvalidateCacheEntryForSubsequentGet [this=%p uri=%s]\n", 
 71627:         this, tmpCacheKey.get()));
 71627:     DoInvalidateCacheEntry(tmpCacheKey);
 71627: 
 71627:     // Invalidate Location-header if set
 71627:     const char *location = mResponseHead->PeekHeader(nsHttp::Location);
 71627:     if (location) {
 71627:         LOG(("  Location-header=%s\n", location));
 71627:         InvalidateCacheEntryForLocation(location);
 71627:     }
 71627: 
 71627:     // Invalidate Content-Location-header if set
 71627:     location = mResponseHead->PeekHeader(nsHttp::Content_Location);
 71627:     if (location) {
 71627:         LOG(("  Content-Location-header=%s\n", location));
 71627:         InvalidateCacheEntryForLocation(location);
 71627:     }
 71627: }
 71627: 
 71627: void
 71627: nsHttpChannel::InvalidateCacheEntryForLocation(const char *location)
 71627: {
 71627:     nsCAutoString tmpCacheKey, tmpSpec;
 71627:     nsCOMPtr<nsIURI> resultingURI;
 71627:     nsresult rv = CreateNewURI(location, getter_AddRefs(resultingURI));
 71627:     if (NS_SUCCEEDED(rv) && HostPartIsTheSame(resultingURI)) {
 71627:         if (NS_SUCCEEDED(resultingURI->GetAsciiSpec(tmpSpec))) {
 71627:             location = tmpSpec.get();  //reusing |location|
 71627: 
 71627:             // key for a GET-request to |location| with current load-flags
 71627:             AssembleCacheKey(location, 0, tmpCacheKey);
 71627:             DoInvalidateCacheEntry(tmpCacheKey);
 71627:         } else
 71627:             NS_WARNING(("  failed getting ascii-spec\n"));
 71627:     } else {
 71627:         LOG(("  hosts not matching\n"));
 71627:     }
 71627: }
 71627: 
 71627: void
 99879: nsHttpChannel::DoInvalidateCacheEntry(const nsCString &key)
 71627: {
 43113:     // NOTE:
 43113:     // Following comments 24,32 and 33 in bug #327765, we only care about
 71627:     // the cache in the protocol-handler, not the application cache.
 43113:     // The logic below deviates from the original logic in OpenCacheEntry on
 43113:     // one point by using only READ_ONLY access-policy. I think this is safe.
 71627: 
 71627:     // First, find session holding the cache-entry - use current storage-policy
 99879:     bool isPrivate = UsingPrivateBrowsing();
 99879:     nsCacheStoragePolicy storagePolicy = DetermineStoragePolicy(isPrivate);
 99879:     const char * clientID = GetCacheSessionNameForStoragePolicy(storagePolicy,
 99879:                                                                 isPrivate);
 99879: 
 99879:     LOG(("DoInvalidateCacheEntry [channel=%p session=%s policy=%d key=%s]",
 99879:          this, clientID, PRIntn(storagePolicy), key.get()));
 99879: 
 99879:     nsresult rv;
 99879:     nsCOMPtr<nsICacheService> serv =
 99879:         do_GetService(NS_CACHESERVICE_CONTRACTID, &rv);
 43113:     nsCOMPtr<nsICacheSession> session;
 99879:     if (NS_SUCCEEDED(rv)) {
 99879:         rv = serv->CreateSession(clientID, storagePolicy,  
 99879:                                  nsICache::STREAM_BASED,
 43113:                                  getter_AddRefs(session));
 99879:     }
 99879:     if (NS_SUCCEEDED(rv)) {
 99879:         rv = session->SetIsPrivate(UsingPrivateBrowsing());
 99879:     }
 99879:     if (NS_SUCCEEDED(rv)) {
 99879:         rv = session->DoomEntry(key, nsnull);
 99879:     }
 99879: 
 99879:     LOG(("DoInvalidateCacheEntry [channel=%p session=%s policy=%d key=%s rv=%d]",
 99879:          this, clientID, PRIntn(storagePolicy), key.get(), PRIntn(rv)));
 43113: }
 43113: 
 43113: nsCacheStoragePolicy
 99879: nsHttpChannel::DetermineStoragePolicy(bool isPrivate)
 43113: {
 43113:     nsCacheStoragePolicy policy = nsICache::STORE_ANYWHERE;
 99879:     if (isPrivate)
 99366:         policy = nsICache::STORE_IN_MEMORY;
 99366:     else if (mLoadFlags & INHIBIT_PERSISTENT_CACHING)
 43113:         policy = nsICache::STORE_IN_MEMORY;
 43113: 
 43113:     return policy;
 43113: }
 43113: 
 53987: nsresult
 53987: nsHttpChannel::DetermineCacheAccess(nsCacheAccessMode *_retval)
 53987: {
 79445:     bool offline = gIOService->IsOffline();
 53987: 
 53987:     if (offline || (mLoadFlags & INHIBIT_CACHING)) {
 53987:         // If we have been asked to bypass the cache and not write to the
 53987:         // cache, then don't use the cache at all.  Unless we're actually
 53987:         // offline, which takes precedence over BYPASS_LOCAL_CACHE.
 53987:         if (BYPASS_LOCAL_CACHE(mLoadFlags) && !offline)
 53987:             return NS_ERROR_NOT_AVAILABLE;
 53987:         *_retval = nsICache::ACCESS_READ;
 53987:     }
 53987:     else if (BYPASS_LOCAL_CACHE(mLoadFlags))
 53987:         *_retval = nsICache::ACCESS_WRITE; // replace cache entry
 53987:     else
 53987:         *_retval = nsICache::ACCESS_READ_WRITE; // normal browsing
 53987: 
 53987:     return NS_OK;
 53987: }
 53987: 
 43113: void
 43113: nsHttpChannel::AsyncOnExamineCachedResponse()
 43113: {
 43113:     gHttpHandler->OnExamineCachedResponse(this);
 99366: 
 99366: }
 99874: 
 99874: } } // namespace mozilla::net
