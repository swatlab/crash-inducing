83543: /* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
51662:  * ***** BEGIN LICENSE BLOCK *****
43032:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43032:  *
43032:  * The contents of this file are subject to the Mozilla Public License Version
43032:  * 1.1 (the "License"); you may not use this file except in compliance with
43032:  * the License. You may obtain a copy of the License at
43032:  * http://www.mozilla.org/MPL/
43032:  *
43032:  * Software distributed under the License is distributed on an "AS IS" basis,
43032:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43032:  * for the specific language governing rights and limitations under the
43032:  * License.
43032:  *
43032:  * The Original Code is Mozilla Android code.
43032:  *
43032:  * The Initial Developer of the Original Code is Mozilla Foundation.
43032:  * Portions created by the Initial Developer are Copyright (C) 2009-2010
43032:  * the Initial Developer. All Rights Reserved.
43032:  *
43032:  * Contributor(s):
43032:  *   Vladimir Vukicevic <vladimir@pobox.com>
57436:  *   Matt Brubeck <mbrubeck@mozilla.com>
57436:  *   Vivien Nicolas <vnicolas@mozilla.com>
83584:  *   Sriram Ramasubramanian <sriram@mozilla.com>
43032:  *
43032:  * Alternatively, the contents of this file may be used under the terms of
43032:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43032:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43032:  * in which case the provisions of the GPL or the LGPL are applicable instead
43032:  * of those above. If you wish to allow use of your version of this file only
43032:  * under the terms of either the GPL or the LGPL, and not to allow others to
43032:  * use your version of this file under the terms of the MPL, indicate your
43032:  * decision by deleting the provisions above and replace them with the notice
43032:  * and other provisions required by the GPL or the LGPL. If you do not delete
43032:  * the provisions above, a recipient may use your version of this file under
43032:  * the terms of any one of the MPL, the GPL or the LGPL.
43032:  *
43032:  * ***** END LICENSE BLOCK ***** */
43032: 
43032: package org.mozilla.gecko;
43032: 
83935: import org.mozilla.gecko.gfx.FloatSize;
83777: import org.mozilla.gecko.gfx.GeckoSoftwareLayerClient;
83777: import org.mozilla.gecko.gfx.IntSize;
83777: import org.mozilla.gecko.gfx.LayerController;
83777: import org.mozilla.gecko.gfx.LayerView;
83777: import org.mozilla.gecko.gfx.PlaceholderLayerClient;
83824: import org.mozilla.gecko.gfx.RectUtils;
83934: import org.mozilla.gecko.gfx.ViewportMetrics;
83777: import org.mozilla.gecko.Tab.HistoryEntry;
83777: 
43032: import java.io.*;
43032: import java.util.*;
86795: import java.util.regex.Pattern;
86795: import java.util.regex.Matcher;
43032: import java.util.zip.*;
83536: import java.net.URL;
43032: import java.nio.*;
53801: import java.nio.channels.FileChannel;
56159: import java.util.concurrent.*;
78424: import java.lang.reflect.*;
83933: import java.net.*;
43032: 
83584: import org.json.*;
83584: 
43032: import android.os.*;
43032: import android.app.*;
43032: import android.text.*;
43032: import android.view.*;
43032: import android.view.inputmethod.*;
83700: import android.view.ViewGroup.LayoutParams;
43032: import android.content.*;
63152: import android.content.res.*;
43032: import android.graphics.*;
83536: import android.graphics.drawable.Drawable;
83584: import android.graphics.drawable.BitmapDrawable;
43032: import android.widget.*;
43032: import android.hardware.*;
83777: import android.location.*;
43032: 
43032: import android.util.*;
56159: import android.net.*;
71133: import android.database.*;
83485: import android.database.sqlite.*;
71133: import android.provider.*;
78424: import android.content.pm.*;
78424: import android.content.pm.PackageManager.*;
78424: import dalvik.system.*;
43032: 
43032: abstract public class GeckoApp
83777:     extends Activity implements GeckoEventListener, SensorEventListener, LocationListener
43032: {
83868:     private static final String LOGTAG = "GeckoApp";
76836: 
88042:     public static enum StartupMode {
88042:         NORMAL,
88042:         NEW_VERSION,
88042:         NEW_PROFILE
88042:     }
88042: 
51723:     public static final String ACTION_ALERT_CLICK   = "org.mozilla.gecko.ACTION_ALERT_CLICK";
51723:     public static final String ACTION_ALERT_CLEAR   = "org.mozilla.gecko.ACTION_ALERT_CLEAR";
75005:     public static final String ACTION_WEBAPP        = "org.mozilla.gecko.WEBAPP";
75005:     public static final String ACTION_DEBUG         = "org.mozilla.gecko.DEBUG";
75067:     public static final String ACTION_BOOKMARK      = "org.mozilla.gecko.BOOKMARK";
87594:     public static final String ACTION_LOAD          = "org.mozilla.gecko.LOAD";
83982:     public static final String SAVED_STATE_URI      = "uri";
83982:     public static final String SAVED_STATE_TITLE    = "title";
83982:     public static final String SAVED_STATE_VIEWPORT = "viewport";
83996:     public static final String SAVED_STATE_SCREEN   = "screen";
87063:     public static final String SAVED_STATE_SESSION  = "session";
51723: 
88042:     StartupMode mStartupMode = null;
83537:     private LinearLayout mMainLayout;
84036:     private RelativeLayout mGeckoLayout;
80216:     public static SurfaceView cameraView;
43032:     public static GeckoApp mAppContext;
83760:     public static boolean mFullScreen = false;
62123:     public static File sGREDir = null;
83603:     public static Menu sMenu;
86579:     private static GeckoThread sGeckoThread = null;
64514:     public Handler mMainHandler;
83998:     private File mProfileDir;
84012:     private static boolean sIsGeckoReady = false;
86027:     private static int mOrientation;
83979: 
69577:     private IntentFilter mConnectivityFilter;
83979:     private IntentFilter mBatteryFilter;
83979: 
69577:     private BroadcastReceiver mConnectivityReceiver;
82619:     private BroadcastReceiver mBatteryReceiver;
83924: 
83727:     public static BrowserToolbar mBrowserToolbar;
83727:     public static DoorHangerPopup mDoorHangerPopup;
84564:     public static AutoCompletePopup mAutoCompletePopup;
83719:     public Favicons mFavicons;
83924: 
83777:     private Geocoder mGeocoder;
83777:     private Address  mLastGeoAddress;
83777:     private static LayerController mLayerController;
83878:     private static PlaceholderLayerClient mPlaceholderLayerClient;
83777:     private static GeckoSoftwareLayerClient mSoftwareLayerClient;
85091:     private AboutHomeContent mAboutHomeContent;
84036:     private static AbsoluteLayout mPluginContainer;
43032: 
83982:     public String mLastUri;
83982:     public String mLastTitle;
83982:     public String mLastViewport;
83996:     public byte[] mLastScreen;
84009:     public int mOwnActivityDepth = 0;
87063:     private boolean mRestoreSession = false;
83982: 
83817:     private Vector<View> mPluginViews = new Vector<View>();
83817: 
83700:     public interface OnTabsChangedListener {
83884:         public void onTabsChanged(Tab tab);
83700:     }
83700:     
83700:     private static ArrayList<OnTabsChangedListener> mTabsChangedListeners;
83700: 
83603:     static class ExtraMenuItem implements MenuItem.OnMenuItemClickListener {
83603:         String label;
83603:         String icon;
83603:         int id;
83603:         public boolean onMenuItemClick(MenuItem item) {
83868:             Log.i(LOGTAG, "menu item clicked");
83603:             GeckoAppShell.sendEventToGecko(new GeckoEvent("Menu:Clicked", Integer.toString(id)));
83603:             return true;
83603:         }
83603:     }
83603: 
83603:     static Vector<ExtraMenuItem> sExtraMenuItems = new Vector<ExtraMenuItem>();
83603: 
83931:     public enum LaunchState {Launching, WaitForDebugger,
78217:                              Launched, GeckoRunning, GeckoExiting};
83485:     private static LaunchState sLaunchState = LaunchState.Launching;
74433:     private static boolean sTryCatchAttached = false;
58306: 
83485:     private static final int FILE_PICKER_REQUEST = 1;
83485:     private static final int AWESOMEBAR_REQUEST = 2;
83519:     private static final int CAMERA_CAPTURE_REQUEST = 3;
58306: 
83777:     public static boolean checkLaunchState(LaunchState checkState) {
58306:         synchronized(sLaunchState) {
58306:             return sLaunchState == checkState;
58306:         }
58306:     }
58306: 
58306:     static void setLaunchState(LaunchState setState) {
58306:         synchronized(sLaunchState) {
58306:             sLaunchState = setState;
58306:         }
58306:     }
58306: 
58306:     // if mLaunchState is equal to checkState this sets mLaunchState to setState
58306:     // and return true. Otherwise we return false.
58306:     static boolean checkAndSetLaunchState(LaunchState checkState, LaunchState setState) {
58306:         synchronized(sLaunchState) {
58306:             if (sLaunchState != checkState)
58306:                 return false;
58306:             sLaunchState = setState;
58306:             return true;
58306:         }
58306:     }
58306: 
78424:     public static final String PLUGIN_ACTION = "android.webkit.PLUGIN";
78424: 
78424:     /**
78424:      * A plugin that wish to be loaded in the WebView must provide this permission
78424:      * in their AndroidManifest.xml.
78424:      */
78424:     public static final String PLUGIN_PERMISSION = "android.webkit.permission.PLUGIN";
78424: 
78424:     private static final String PLUGIN_SYSTEM_LIB = "/system/lib/plugins/";
78424: 
78424:     private static final String PLUGIN_TYPE = "type";
78424:     private static final String TYPE_NATIVE = "native";
78424:     public ArrayList<PackageInfo> mPackageInfoCache = new ArrayList<PackageInfo>();
78424: 
78424:     String[] getPluginDirectories() {
84445:         // we don't support Honeycomb and later
84445:         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB)
84445:             return new String[0];
79515: 
87573:         Log.w(LOGTAG, "zerdatime " + SystemClock.uptimeMillis() + " - start of getPluginDirectories");
83485: 
78424:         ArrayList<String> directories = new ArrayList<String>();
78424:         PackageManager pm = this.mAppContext.getPackageManager();
78424:         List<ResolveInfo> plugins = pm.queryIntentServices(new Intent(PLUGIN_ACTION),
78424:                 PackageManager.GET_SERVICES | PackageManager.GET_META_DATA);
78424: 
78424:         synchronized(mPackageInfoCache) {
79515: 
78424:             // clear the list of existing packageInfo objects
78424:             mPackageInfoCache.clear();
78424: 
79515: 
78424:             for (ResolveInfo info : plugins) {
78424: 
78424:                 // retrieve the plugin's service information
78424:                 ServiceInfo serviceInfo = info.serviceInfo;
78424:                 if (serviceInfo == null) {
78424:                     Log.w(LOGTAG, "Ignore bad plugin");
78424:                     continue;
78424:                 }
78424: 
83948:                 // Blacklist HTC's flash lite.
83948:                 // See bug #704516 - We're not quite sure what Flash Lite does,
83948:                 // but loading it causes Flash to give errors and fail to draw.
83948:                 if (serviceInfo.packageName.equals("com.htc.flashliteplugin")) {
83948:                     Log.w(LOGTAG, "Skipping HTC's flash lite plugin");
83948:                     continue;
83948:                 }
83948: 
78424:                 Log.w(LOGTAG, "Loading plugin: " + serviceInfo.packageName);
78424: 
79515: 
78424:                 // retrieve information from the plugin's manifest
78424:                 PackageInfo pkgInfo;
78424:                 try {
78424:                     pkgInfo = pm.getPackageInfo(serviceInfo.packageName,
78424:                                     PackageManager.GET_PERMISSIONS
78424:                                     | PackageManager.GET_SIGNATURES);
78424:                 } catch (Exception e) {
78424:                     Log.w(LOGTAG, "Can't find plugin: " + serviceInfo.packageName);
78424:                     continue;
78424:                 }
78424:                 if (pkgInfo == null) {
78424:                     Log.w(LOGTAG, "Loading plugin: " + serviceInfo.packageName + ". Could not load package information.");
78424:                     continue;
78424:                 }
78424: 
78424:                 /*
78424:                  * find the location of the plugin's shared library. The default
78424:                  * is to assume the app is either a user installed app or an
78424:                  * updated system app. In both of these cases the library is
78424:                  * stored in the app's data directory.
78424:                  */
78424:                 String directory = pkgInfo.applicationInfo.dataDir + "/lib";
78424:                 final int appFlags = pkgInfo.applicationInfo.flags;
78424:                 final int updatedSystemFlags = ApplicationInfo.FLAG_SYSTEM |
78424:                                                ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
78424:                 // preloaded system app with no user updates
78424:                 if ((appFlags & updatedSystemFlags) == ApplicationInfo.FLAG_SYSTEM) {
78424:                     directory = PLUGIN_SYSTEM_LIB + pkgInfo.packageName;
78424:                 }
78424: 
78424:                 // check if the plugin has the required permissions
78424:                 String permissions[] = pkgInfo.requestedPermissions;
78424:                 if (permissions == null) {
78424:                     Log.w(LOGTAG, "Loading plugin: " + serviceInfo.packageName + ". Does not have required permission.");
78424:                     continue;
78424:                 }
78424:                 boolean permissionOk = false;
78424:                 for (String permit : permissions) {
78424:                     if (PLUGIN_PERMISSION.equals(permit)) {
78424:                         permissionOk = true;
78424:                         break;
78424:                     }
78424:                 }
78424:                 if (!permissionOk) {
78424:                     Log.w(LOGTAG, "Loading plugin: " + serviceInfo.packageName + ". Does not have required permission (2).");
78424:                     continue;
78424:                 }
78424: 
78424:                 // check to ensure the plugin is properly signed
78424:                 Signature signatures[] = pkgInfo.signatures;
78424:                 if (signatures == null) {
78424:                     Log.w(LOGTAG, "Loading plugin: " + serviceInfo.packageName + ". Not signed.");
78424:                     continue;
78424:                 }
78424: 
78424:                 // determine the type of plugin from the manifest
78424:                 if (serviceInfo.metaData == null) {
78424:                     Log.e(LOGTAG, "The plugin '" + serviceInfo.name + "' has no type defined");
78424:                     continue;
78424:                 }
78424: 
78424:                 String pluginType = serviceInfo.metaData.getString(PLUGIN_TYPE);
78424:                 if (!TYPE_NATIVE.equals(pluginType)) {
78424:                     Log.e(LOGTAG, "Unrecognized plugin type: " + pluginType);
78424:                     continue;
78424:                 }
78424: 
78424:                 try {
78424:                     Class<?> cls = getPluginClass(serviceInfo.packageName, serviceInfo.name);
78424: 
78424:                     //TODO implement any requirements of the plugin class here!
78424:                     boolean classFound = true;
78424: 
78424:                     if (!classFound) {
78424:                         Log.e(LOGTAG, "The plugin's class' " + serviceInfo.name + "' does not extend the appropriate class.");
78424:                         continue;
78424:                     }
78424: 
78424:                 } catch (NameNotFoundException e) {
78424:                     Log.e(LOGTAG, "Can't find plugin: " + serviceInfo.packageName);
78424:                     continue;
78424:                 } catch (ClassNotFoundException e) {
78424:                     Log.e(LOGTAG, "Can't find plugin's class: " + serviceInfo.name);
78424:                     continue;
78424:                 }
78424: 
78424:                 // if all checks have passed then make the plugin available
78424:                 mPackageInfoCache.add(pkgInfo);
78424:                 directories.add(directory);
78424:             }
78424:         }
78424: 
83485:         String [] result = directories.toArray(new String[directories.size()]);
87573:         Log.w(LOGTAG, "zerdatime " + SystemClock.uptimeMillis() + " - end of getPluginDirectories");
83485:         return result;
78424:     }
78424: 
83881:     String getPluginPackage(String pluginLib) {
83881: 
83881:         if (pluginLib == null || pluginLib.length() == 0) {
83881:             return null;
83881:         }
83881: 
83881:         synchronized(mPackageInfoCache) {
83881:             for (PackageInfo pkgInfo : mPackageInfoCache) {
83881:                 if (pluginLib.contains(pkgInfo.packageName)) {
83881:                     return pkgInfo.packageName;
83881:                 }
83881:             }
83881:         }
83881: 
83881:         return null;
83881:     }
83881: 
78424:     Class<?> getPluginClass(String packageName, String className)
78424:             throws NameNotFoundException, ClassNotFoundException {
78424:         Context pluginContext = this.mAppContext.createPackageContext(packageName,
78424:                 Context.CONTEXT_INCLUDE_CODE |
78424:                 Context.CONTEXT_IGNORE_SECURITY);
78424:         ClassLoader pluginCL = pluginContext.getClassLoader();
78424:         return pluginCL.loadClass(className);
78424:     }
78424: 
83485:     @Override
83485:     public boolean onCreateOptionsMenu(Menu menu)
83485:     {
83603:         sMenu = menu;
83494:         MenuInflater inflater = getMenuInflater();
83494:         inflater.inflate(R.layout.gecko_menu, menu);
83494:         return true;
83494:     }
83494: 
83494:     @Override
83603:     public boolean onPrepareOptionsMenu(Menu aMenu)
83603:     {
83603:         Iterator<ExtraMenuItem> i = sExtraMenuItems.iterator();
83603:         while (i.hasNext()) {
83603:             final ExtraMenuItem item = i.next();
83603:             if (aMenu.findItem(item.id) == null) {
83603:                 final MenuItem mi = aMenu.add(aMenu.NONE, item.id, aMenu.NONE, item.label);
83603:                 if (item.icon != null) {
83603:                     if (item.icon.startsWith("data")) {
83603:                         byte[] raw = Base64.decode(item.icon.substring(22), Base64.DEFAULT);
83603:                         Bitmap bitmap = BitmapFactory.decodeByteArray(raw, 0, raw.length);
83603:                         BitmapDrawable drawable = new BitmapDrawable(bitmap);
83603:                         mi.setIcon(drawable);
83603:                     }
83603:                     else if (item.icon.startsWith("jar:") || item.icon.startsWith("file://")) {
83603:                         GeckoAppShell.getHandler().post(new Runnable() {
60270:                             public void run() {
60270:                                 try {
83603:                                     URL url = new URL(item.icon);
83603:                                     InputStream is = (InputStream) url.getContent();
83603:                                     Drawable drawable = Drawable.createFromStream(is, "src");
83603:                                     mi.setIcon(drawable);
83603:                                 } catch (Exception e) {
86795:                                     Log.w(LOGTAG, "onPrepareOptionsMenu: Unable to set icon", e);
83603:                                 }
83603:                             }
83603:                         });
83603:                     }
83603:                 }
83603:                 mi.setOnMenuItemClickListener(item);
83603:             }
83603:         }
78603: 
84012:         if (!sIsGeckoReady)
85100:             aMenu.findItem(R.id.settings).setEnabled(false);
83764: 
83631:         Tab tab = Tabs.getInstance().getSelectedTab();
83631:         MenuItem bookmark = aMenu.findItem(R.id.bookmark);
83676:         MenuItem forward = aMenu.findItem(R.id.forward);
83929:         MenuItem share = aMenu.findItem(R.id.share);
84523:         MenuItem saveAsPDF = aMenu.findItem(R.id.save_as_pdf);
86757:         MenuItem downloads = aMenu.findItem(R.id.downloads);
87960:         MenuItem charEncoding = aMenu.findItem(R.id.char_encoding);
83631: 
83631:         if (tab == null) {
83764:             bookmark.setEnabled(false);
83764:             forward.setEnabled(false);
83929:             share.setEnabled(false);
84523:             saveAsPDF.setEnabled(false);
83631:             return true;
78603:         }
78603:         
83764:         bookmark.setEnabled(true);
83631:         bookmark.setCheckable(true);
83631:         
83631:         if (tab.isBookmark()) {
83631:             bookmark.setChecked(true);
83764:             bookmark.setIcon(R.drawable.ic_menu_bookmark_remove);
83631:         } else {
83631:             bookmark.setChecked(false);
83764:             bookmark.setIcon(R.drawable.ic_menu_bookmark_add);
83631:         }
83631: 
83676:         forward.setEnabled(tab.canDoForward());
83676: 
87181:         // Disable share menuitem for about:, chrome: and file: URIs
83929:         String scheme = Uri.parse(tab.getURL()).getScheme();
86012:         boolean enabled = !(scheme.equals("about") || scheme.equals("chrome") ||
86012:                             scheme.equals("file"));
86012:         share.setEnabled(enabled);
84523: 
84523:         // Disable save as PDF for about:home and xul pages
84523:         saveAsPDF.setEnabled(!(tab.getURL().equals("about:home") ||
84523:                                tab.getContentType().equals("application/vnd.mozilla.xul+xml")));
83929: 
86757:         // DownloadManager support is tied to level 12 and higher
86757:         if (Build.VERSION.SDK_INT < 12)
86757:             downloads.setVisible(false);
86757: 
87960:         charEncoding.setVisible(GeckoPreferences.getCharEncodingState());
87960: 
83603:         return true;
83603:     }
83603: 
83603:     @Override
83494:     public boolean onOptionsItemSelected(MenuItem item) {
83564:         Tab tab = null;
83631:         Intent intent = null;
83494:         switch (item.getItemId()) {
83718:             case R.id.quit:
83946:                 synchronized(sLaunchState) {
83946:                     if (sLaunchState == LaunchState.GeckoRunning)
83946:                         GeckoAppShell.notifyGeckoOfEvent(
83946:                             new GeckoEvent("Browser:Quit", null));
83946:                     else
83946:                         System.exit(0);
83946:                     sLaunchState = LaunchState.GeckoExiting;
83946:                 }
83718:                 return true;
83631:             case R.id.bookmark:
83564:                 tab = Tabs.getInstance().getSelectedTab();
83631:                 if (tab != null) {
83631:                     if (item.isChecked()) {
83631:                         tab.removeBookmark();
83631:                         Toast.makeText(this, R.string.bookmark_removed, Toast.LENGTH_SHORT).show();
83764:                         item.setIcon(R.drawable.ic_menu_bookmark_add);
83631:                     } else {
83631:                         tab.addBookmark();
83631:                         Toast.makeText(this, R.string.bookmark_added, Toast.LENGTH_SHORT).show();
83764:                         item.setIcon(R.drawable.ic_menu_bookmark_remove);
83610:                     }
83522:                 }
83520:                 return true;
83564:             case R.id.share:
83564:                 tab = Tabs.getInstance().getSelectedTab();
83929:                 if (tab != null) {
83929:                   GeckoAppShell.openUriExternal(tab.getURL(), "text/plain", "", "",
83929:                                                 Intent.ACTION_SEND, tab.getTitle());
83564:                 }
83564:                 return true;
83584:             case R.id.reload:
83584:                 doReload();
83541:                 return true;
83676:             case R.id.forward:
83676:                 doForward();
83676:                 return true;
83764:             case R.id.save_as_pdf:
83605:                 GeckoAppShell.sendEventToGecko(new GeckoEvent("SaveAs:PDF", null));
83605:                 return true;
85100:             case R.id.settings:
83611:                 intent = new Intent(this, GeckoPreferences.class);
83611:                 startActivity(intent);
83611:                 return true;
84883:             case R.id.site_settings:
84883:                 GeckoAppShell.sendEventToGecko(new GeckoEvent("Permissions:Get", null));
84883:                 return true;
83627:             case R.id.addons:
86518:                 loadUrlInTab("about:addons");
83627:                 return true;
86757:             case R.id.downloads:
86757:                 intent = new Intent(DownloadManager.ACTION_VIEW_DOWNLOADS);
86757:                 startActivity(intent);
86757:                 return true;
87960:             case R.id.char_encoding:
87960:                 GeckoAppShell.sendEventToGecko(new GeckoEvent("CharEncoding:Get", null));
87960:                 return true;
83494:             default:
83494:                 return super.onOptionsItemSelected(item);
83485:         }
83485:     }
83485: 
83982:     public String getLastViewport() {
83982:         return mLastViewport;
83934:     }
83934: 
83982:     protected void onSaveInstanceState(Bundle outState) {
83982:         super.onSaveInstanceState(outState);
84009:         if (mOwnActivityDepth > 0)
84009:             return; // we're showing one of our own activities and likely won't get paged out
84434: 
83982:         if (outState == null)
83982:             outState = new Bundle();
84434: 
84434:         new SessionSnapshotRunnable(null).run();
84434: 
83982:         outState.putString(SAVED_STATE_URI, mLastUri);
83982:         outState.putString(SAVED_STATE_TITLE, mLastTitle);
83982:         outState.putString(SAVED_STATE_VIEWPORT, mLastViewport);
83996:         outState.putByteArray(SAVED_STATE_SCREEN, mLastScreen);
87063:         outState.putBoolean(SAVED_STATE_SESSION, true);
83982:     }
83982: 
84434:     public class SessionSnapshotRunnable implements Runnable {
84434:         Tab mThumbnailTab;
84434:         SessionSnapshotRunnable(Tab thumbnailTab) {
84434:             mThumbnailTab = thumbnailTab;
84434:         }
84434: 
84010:         public void run() {
84434:             synchronized (mSoftwareLayerClient) {
83575:                 Tab tab = Tabs.getInstance().getSelectedTab();
83610:                 if (tab == null)
83610:                     return;
83610: 
83777:                 HistoryEntry lastHistoryEntry = tab.getLastHistoryEntry();
83777:                 if (lastHistoryEntry == null)
83777:                     return;
83777: 
83934:                 if (getLayerController().getLayerClient() != mSoftwareLayerClient)
83934:                     return;
83934: 
86512:                 if (lastHistoryEntry.mUri.equals(mLastUri))
84010:                     return;
84010: 
86565:                 ViewportMetrics viewportMetrics = mSoftwareLayerClient.getGeckoViewportMetrics();
86565:                 if (viewportMetrics != null)
86565:                     mLastViewport = viewportMetrics.toJSON();
86565: 
83982:                 mLastUri = lastHistoryEntry.mUri;
83982:                 mLastTitle = lastHistoryEntry.mTitle;
87591:                 getAndProcessThumbnailForTab(tab);
87591:             }
87591:         }
87591:     }
87591: 
87591:     void getAndProcessThumbnailForTab(Tab tab) {
87591:         Bitmap bitmap = null;
87591:         if (Tabs.getInstance().isSelectedTab(tab))
87591:             bitmap = mSoftwareLayerClient.getBitmap();
87329: 
84209:         if (bitmap != null) {
83996:             ByteArrayOutputStream bos = new ByteArrayOutputStream();
83996:             bitmap.compress(Bitmap.CompressFormat.PNG, 0, bos);
87329:             processThumbnail(tab, bitmap, bos.toByteArray());
84209:         } else {
84209:             mLastScreen = null;
87329:             GeckoAppShell.sendEventToGecko(
87329:                 new GeckoEvent("Tab:Screenshot", 
87329:                                "{\"width\": \"" + mSoftwareLayerClient.getWidth() + "\", " +
87329:                                "\"height\": \"" + mSoftwareLayerClient.getHeight() + "\", " +
87329:                                "\"tabID\": \"" + tab.getId() + "\" }"));
84209:         }
83575:     }
83575:     
87329:     void processThumbnail(Tab thumbnailTab, Bitmap bitmap, byte[] compressed) {
87329:         if (Tabs.getInstance().isSelectedTab(thumbnailTab))
87329:             mLastScreen = compressed;
87329:         if (thumbnailTab.getURL().equals("about:home")) {
87329:             thumbnailTab.updateThumbnail(null);
87329:             return;
87329:         }
87591:         try {
87329:             if (bitmap == null)
87329:                 bitmap = BitmapFactory.decodeByteArray(compressed, 0, compressed.length);
87329:             thumbnailTab.updateThumbnail(bitmap);
87591:         } catch (OutOfMemoryError ome) {
87591:             Log.w(LOGTAG, "decoding byte array ran out of memory", ome);
87591:         }
87329:     }
87329: 
83887:     private void maybeCancelFaviconLoad(Tab tab) {
83887:         long faviconLoadId = tab.getFaviconLoadId();
83887: 
83887:         if (faviconLoadId == Favicons.NOT_LOADING)
83887:             return;
83887: 
83887:         // Cancel pending favicon load task
83887:         mFavicons.cancelFaviconLoad(faviconLoadId);
83887: 
83887:         // Reset favicon load state
83887:         tab.setFaviconLoadId(Favicons.NOT_LOADING);
83887:     }
83887: 
83719:     private void loadFavicon(final Tab tab) {
83887:         maybeCancelFaviconLoad(tab);
83887: 
83887:         long id = mFavicons.loadFavicon(tab.getURL(), tab.getFaviconURL(),
83719:                         new Favicons.OnFaviconLoadedListener() {
83719: 
83719:             public void onFaviconLoaded(String pageUrl, Drawable favicon) {
83719:                 // Leave favicon UI untouched if we failed to load the image
83719:                 // for some reason.
83719:                 if (favicon == null)
83719:                     return;
83719: 
83868:                 Log.i(LOGTAG, "Favicon successfully loaded for URL = " + pageUrl);
83719: 
83719:                 // The tab might be pointing to another URL by the time the
83719:                 // favicon is finally loaded, in which case we simply ignore it.
83719:                 if (!tab.getURL().equals(pageUrl))
83719:                     return;
83719: 
83868:                 Log.i(LOGTAG, "Favicon is for current URL = " + pageUrl);
83719: 
83719:                 tab.updateFavicon(favicon);
83887:                 tab.setFaviconLoadId(Favicons.NOT_LOADING);
83719: 
83719:                 if (Tabs.getInstance().isSelectedTab(tab))
83719:                     mBrowserToolbar.setFavicon(tab.getFavicon());
83719: 
83884:                 onTabsChanged(tab);
83719:             }
83719:         });
83887: 
83887:         tab.setFaviconLoadId(id);
83719:     }
83719: 
84523:     void handleLocationChange(final int tabId, final String uri,
84523:                               final String documentURI, final String contentType) {
83629:         final Tab tab = Tabs.getInstance().getTab(tabId);
83616:         if (tab == null)
83616:             return;
83616: 
84018:         if (Tabs.getInstance().isSelectedTab(tab)) {
84018:             if (uri.equals("about:home"))
84018:                 showAboutHome();
84018:             else 
84018:                 hideAboutHome();
84018:         }
84018:         
83617:         String oldBaseURI = tab.getURL();
83541:         tab.updateURL(uri);
84523:         tab.setDocumentURI(documentURI);
84523:         tab.setContentType(contentType);
83541: 
83617:         String baseURI = uri;
83617:         if (baseURI.indexOf('#') != -1)
83617:             baseURI = uri.substring(0, uri.indexOf('#'));
83617: 
83617:         if (oldBaseURI != null && oldBaseURI.indexOf('#') != -1)
83616:             oldBaseURI = oldBaseURI.substring(0, oldBaseURI.indexOf('#'));
83616:         
84157:         if (baseURI.equals(oldBaseURI)) {
84157:             mMainHandler.post(new Runnable() {
84157:                 public void run() {
84157:                     if (Tabs.getInstance().isSelectedTab(tab)) {
84157:                         mBrowserToolbar.setTitle(uri);
84157:                     }
84157:                 }
84157:             });
83616:             return;
84157:         }
83616: 
83692:         tab.updateFavicon(null);
83719:         tab.updateFaviconURL(null);
83712:         tab.updateSecurityMode("unknown");
83827:         tab.removeTransientDoorHangers();
83692: 
83887:         maybeCancelFaviconLoad(tab);
83887: 
83536:         mMainHandler.post(new Runnable() {
83536:             public void run() {
83692:                 if (Tabs.getInstance().isSelectedTab(tab)) {
83559:                     mBrowserToolbar.setTitle(uri);
83574:                     mBrowserToolbar.setFavicon(null);
83712:                     mBrowserToolbar.setSecurityMode("unknown");
83835:                     mDoorHangerPopup.updatePopup();
85061:                     mBrowserToolbar.setShadowVisibility(!(tab.getURL().startsWith("about:")));
83692:                 }
83536:             }
83536:         });
83536:     }
83536: 
83712:     void handleSecurityChange(final int tabId, final String mode) {
83712:         final Tab tab = Tabs.getInstance().getTab(tabId);
83712:         if (tab == null)
83712:             return;
83712: 
83712:         tab.updateSecurityMode(mode);
83712:         
83712:         mMainHandler.post(new Runnable() { 
83712:             public void run() {
83712:                 if (Tabs.getInstance().isSelectedTab(tab))
83712:                     mBrowserToolbar.setSecurityMode(mode);
83712:             }
83712:         });
83712:     }
83712: 
84791:     void handleLoadError(final int tabId, final String uri, final String title) {
84791:         final Tab tab = Tabs.getInstance().getTab(tabId);
84791:         if (tab == null)
84791:             return;
84791:     
84791:         // When a load error occurs, the URLBar can get corrupt so we reset it
84791:         mMainHandler.post(new Runnable() {
84791:             public void run() {
84791:                 if (Tabs.getInstance().isSelectedTab(tab)) {
84791:                     mBrowserToolbar.setTitle(tab.getDisplayTitle());
84791:                     mBrowserToolbar.setFavicon(tab.getFavicon());
84791:                     mBrowserToolbar.setSecurityMode(tab.getSecurityMode());
84791:                     mBrowserToolbar.setProgressVisibility(tab.isLoading());
84791:                 }
84791:             }
84791:         });
84791:     }
84791: 
88042:     public StartupMode getStartupMode() {
88042:         // This function might touch the disk and should not
88042:         // be called from UI's main thread.
88042: 
88042:         synchronized(this) {
88042:             if (mStartupMode != null)
88042:                 return mStartupMode;
88042: 
88042:             String packageName = getPackageName();
88042:             SharedPreferences settings = getPreferences(Activity.MODE_PRIVATE);
88042: 
88042:             // This key should be profile-dependent. For now, we're simply hardcoding
88042:             // the "default" profile here.
88042:             String keyName = packageName + ".default.startup_version";
88042:             String appVersion = null;
88042: 
88042:             try {
88042:                 PackageInfo pkgInfo = getPackageManager().getPackageInfo(packageName, 0);
88042:                 appVersion = pkgInfo.versionName;
88042:             } catch(NameNotFoundException nnfe) {
88042:                 // If, for some reason, we can't fetch the app version
88042:                 // we fallback to NORMAL startup mode.
88042:                 mStartupMode = StartupMode.NORMAL;
88042:                 return mStartupMode;
88042:             }
88042: 
88042:             String startupVersion = settings.getString(keyName, null);
88042:             if (startupVersion == null) {
88042:                 mStartupMode = StartupMode.NEW_PROFILE;
88042:             } else {
88042:                 if (startupVersion.equals(appVersion))
88042:                     mStartupMode = StartupMode.NORMAL;
88042:                 else
88042:                     mStartupMode = StartupMode.NEW_VERSION;
88042:             }
88042: 
88042:             if (mStartupMode != StartupMode.NORMAL)
88042:                 settings.edit().putString(keyName, appVersion).commit();
88042: 
88042:             Log.i(LOGTAG, "Startup mode: " + mStartupMode);
88042: 
88042:             return mStartupMode;
88042:         }
88042:     }
88042: 
84272:     public File getProfileDir() {
84272:         return getProfileDir("default");
84272:     }
84272: 
84272:     public File getProfileDir(final String profileName) {
86795:         if (mProfileDir != null)
86795:             return mProfileDir;
86795:         try {
86795:             mProfileDir = GeckoDirProvider.getProfileDir(mAppContext, profileName);
86795:         } catch (IOException ex) {
86795:             Log.e(LOGTAG, "Error getting profile dir.", ex);
83998:         }
83998:         return mProfileDir;
83998:     }
83998: 
83662:     void addTab() {
84009:         showAwesomebar(AwesomeBar.Type.ADD);
83662:     }
83662: 
83584:     void showTabs() {
83700:         Intent intent = new Intent(mAppContext, TabsTray.class);
83709:         intent.addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);
83700:         startActivity(intent);
83709:         overridePendingTransition(R.anim.grow_fade_in, 0);
83584:     }
83584: 
83700:     public static void registerOnTabsChangedListener(OnTabsChangedListener listener) {
83700:         if (mTabsChangedListeners == null)
83700:             mTabsChangedListeners = new ArrayList<OnTabsChangedListener>();
83700:         
83700:         mTabsChangedListeners.add(listener);
83584:     }
83700: 
83700:     public static void unregisterOnTabsChangedListener(OnTabsChangedListener listener) {
83700:         if (mTabsChangedListeners == null)
83700:             return;
83700:         
83700:         mTabsChangedListeners.remove(listener);
83584:     }
83584: 
83884:     public void onTabsChanged(Tab tab) {
83700:         if (mTabsChangedListeners == null)
83584:             return;
83584: 
83700:         Iterator items = mTabsChangedListeners.iterator();
83700:         while (items.hasNext()) {
83884:             ((OnTabsChangedListener) items.next()).onTabsChanged(tab);
83584:         }
83584:     }
83584: 
83584:     public void handleMessage(String event, JSONObject message) {
83868:         Log.i(LOGTAG, "Got message: " + event);
54803:         try {
83603:             if (event.equals("Menu:Add")) {
83603:                 String name = message.getString("name");
83603:                 ExtraMenuItem item = new ExtraMenuItem();
83603:                 item.label = message.getString("name");
83603:                 item.id = message.getInt("id");
83603:                 try { // icon is optional
83603:                     item.icon = message.getString("icon");
83603:                 } catch (Exception ex) { }
83603:                 sExtraMenuItems.add(item);
83603:             } else if (event.equals("Menu:Remove")) {
83603:                 // remove it from the menu and from our vector
83603:                 Iterator<ExtraMenuItem> i = sExtraMenuItems.iterator();
83603:                 int id = message.getInt("id");
83603:                 while (i.hasNext()) {
83603:                     ExtraMenuItem item = i.next();
83603:                     if (item.id == id) {
83603:                         sExtraMenuItems.remove(item);
83603:                         MenuItem menu = sMenu.findItem(id);
83603:                         if (menu != null)
83603:                             sMenu.removeItem(id);
60270:                         return;
54803:                     }
83603:                 }
83618:             } else if (event.equals("Toast:Show")) {
83618:                 final String msg = message.getString("message");
83618:                 final String duration = message.getString("duration");
83618:                 handleShowToast(msg, duration);
83603:             } else if (event.equals("DOMContentLoaded")) {
83584:                 final int tabId = message.getInt("tabID");
83584:                 final String uri = message.getString("uri");
83584:                 final String title = message.getString("title");
83584:                 final CharSequence titleText = title;
83584:                 handleContentLoaded(tabId, uri, title);
83868:                 Log.i(LOGTAG, "URI - " + uri + ", title - " + title);
83584:             } else if (event.equals("DOMTitleChanged")) {
83584:                 final int tabId = message.getInt("tabID");
83584:                 final String title = message.getString("title");
83584:                 final CharSequence titleText = title;
83584:                 handleTitleChanged(tabId, title);
83868:                 Log.i(LOGTAG, "title - " + title);
83584:             } else if (event.equals("DOMLinkAdded")) {
83584:                 final int tabId = message.getInt("tabID");
83584:                 final String rel = message.getString("rel");
83584:                 final String href = message.getString("href");
83868:                 Log.i(LOGTAG, "link rel - " + rel + ", href - " + href);
83584:                 handleLinkAdded(tabId, rel, href);
86406:             } else if (event.equals("DOMWindowClose")) {
86406:                 final int tabId = message.getInt("tabID");
86406:                 handleWindowClose(tabId);
83584:             } else if (event.equals("log")) {
83584:                 // generic log listener
83584:                 final String msg = message.getString("msg");
83868:                 Log.i(LOGTAG, "Log: " + msg);
83712:             } else if (event.equals("Content:LocationChange")) {
83584:                 final int tabId = message.getInt("tabID");
83584:                 final String uri = message.getString("uri");
84523:                 final String documentURI = message.getString("documentURI");
84523:                 final String contentType = message.getString("contentType");
83868:                 Log.i(LOGTAG, "URI - " + uri);
84523:                 handleLocationChange(tabId, uri, documentURI, contentType);
83712:             } else if (event.equals("Content:SecurityChange")) {
83712:                 final int tabId = message.getInt("tabID");
83712:                 final String mode = message.getString("mode");
83868:                 Log.i(LOGTAG, "Security Mode - " + mode);
83712:                 handleSecurityChange(tabId, mode);
83712:             } else if (event.equals("Content:StateChange")) {
83584:                 final int tabId = message.getInt("tabID");
83584:                 int state = message.getInt("state");
83868:                 Log.i(LOGTAG, "State - " + state);
86026:                 if ((state & GeckoAppShell.WPL_STATE_IS_NETWORK) != 0) {
83584:                     if ((state & GeckoAppShell.WPL_STATE_START) != 0) {
83868:                         Log.i(LOGTAG, "Got a document start");
87744:                         final boolean showProgress = message.getBoolean("showProgress");
87744:                         handleDocumentStart(tabId, showProgress);
83584:                     } else if ((state & GeckoAppShell.WPL_STATE_STOP) != 0) {
83868:                         Log.i(LOGTAG, "Got a document stop");
83584:                         handleDocumentStop(tabId);
83584:                     }
83584:                 }
84791:             } else if (event.equals("Content:LoadError")) {
84791:                 final int tabId = message.getInt("tabID");
84791:                 final String uri = message.getString("uri");
84791:                 final String title = message.getString("title");
84791:                 handleLoadError(tabId, uri, title);
83584:             } else if (event.equals("onCameraCapture")) {
83584:                 //GeckoApp.mAppContext.doCameraCapture(message.getString("path"));
83584:                 doCameraCapture();
83584:             } else if (event.equals("Tab:Added")) {
83868:                 Log.i(LOGTAG, "Created a new tab");
85042:                 Tab tab = handleAddTab(message);
83762:                 Boolean selected = message.getBoolean("selected");
84019:                 if (selected)
85042:                     handleSelectTab(tab.getId());
87856:             } else if (event.equals("Tab:Closed")) {
87856:                 Log.i(LOGTAG, "Destroyed a tab");
87856:                 int tabId = message.getInt("tabID");
87856:                 handleCloseTab(tabId);
87329:             } else if (event.equals("Tab:ScreenshotData")) {
87329:                 int tabId = message.getInt("tabID");
87329:                 Tab tab = Tabs.getInstance().getTab(tabId);
87329:                 processThumbnail(tab, null, Base64.decode(message.getString("data").substring(22), Base64.DEFAULT));
83584:             } else if (event.equals("Tab:Selected")) {
83584:                 int tabId = message.getInt("tabID");
83868:                 Log.i(LOGTAG, "Switched to tab: " + tabId);
83584:                 handleSelectTab(tabId);
83590:             } else if (event.equals("Doorhanger:Add")) {
83792:                 handleDoorHanger(message);
83834:             } else if (event.equals("Doorhanger:Remove")) {
83834:                 handleDoorHangerRemove(message);
84012:             } else if (event.equals("Gecko:Ready")) {
84012:                 sIsGeckoReady = true;
83651:                 mMainHandler.post(new Runnable() {
83651:                     public void run() {
83651:                         if (sMenu != null)
85100:                             sMenu.findItem(R.id.settings).setEnabled(true);
83584:                     }
83651:                 });
83946:                 setLaunchState(GeckoApp.LaunchState.GeckoRunning);
83946:                 GeckoAppShell.sendPendingEventsToGecko();
84423:                 connectGeckoLayerClient();
83760:             } else if (event.equals("ToggleChrome:Hide")) {
83760:                 mMainHandler.post(new Runnable() {
83760:                     public void run() {
83760:                         mBrowserToolbar.setVisibility(View.GONE);
83760:                     }
83760:                 });
83760:             } else if (event.equals("ToggleChrome:Show")) {
83760:                 mMainHandler.post(new Runnable() {
83760:                     public void run() {
83760:                         mBrowserToolbar.setVisibility(View.VISIBLE);
83760:                     }
83760:                 });
84564:             } else if (event.equals("FormAssist:AutoComplete")) {
84564:                 final JSONArray suggestions = message.getJSONArray("suggestions");
84564:                 if (suggestions.length() == 0) {
84564:                     mMainHandler.post(new Runnable() {
84564:                         public void run() {
84564:                             mAutoCompletePopup.hide();
84564:                         }
84564:                     });
84564:                 } else {
84564:                     final JSONArray rect = message.getJSONArray("rect");
84564:                     final double zoom = message.getDouble("zoom");
84564:                     mMainHandler.post(new Runnable() {
84564:                         public void run() {
87061:                             // Don't show autocomplete popup when using fullscreen VKB
87466:                             InputMethodManager imm =
87466:                                 (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
87466:                             if (!imm.isFullscreenMode())
84564:                                 mAutoCompletePopup.show(suggestions, rect, zoom);
84564:                         }
84564:                     });
84564:                 }
84883:             } else if (event.equals("Permissions:Data")) {
84883:                 String host = message.getString("host");
84883:                 JSONArray permissions = message.getJSONArray("permissions");
84883:                 showSiteSettingsDialog(host, permissions);
86757:             } else if (event.equals("Downloads:Done")) {
86757:                 String displayName = message.getString("displayName");
86757:                 String path = message.getString("path");
86757:                 String mimeType = message.getString("mimeType");
86757:                 int size = message.getInt("size");
86757: 
86757:                 handleDownloadDone(displayName, path, mimeType, size);
87960:             } else if (event.equals("CharEncoding:Data")) {
87960:                 final JSONArray charsets = message.getJSONArray("charsets");
87960:                 int selected = message.getInt("selected");
87960: 
87960:                 final int len = charsets.length();
87960:                 final String[] titleArray = new String[len];
87960:                 for (int i = 0; i < len; i++) {
87960:                     JSONObject charset = charsets.getJSONObject(i);
87960:                     titleArray[i] = charset.getString("title");
87960:                 }
87960: 
87960:                 final AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(this);
87960:                 dialogBuilder.setSingleChoiceItems(titleArray, selected, new AlertDialog.OnClickListener() {
87960:                     @Override
87960:                     public void onClick(DialogInterface dialog, int which) {
87960:                         try {
87960:                             JSONObject charset = charsets.getJSONObject(which);
87960:                             GeckoAppShell.sendEventToGecko(new GeckoEvent("CharEncoding:Set", charset.getString("code")));
87960:                             dialog.dismiss();
87960:                         } catch (JSONException e) {
87960:                             Log.e(LOGTAG, "error parsing json", e);
87960:                         }
87960:                     }
87960:                 });
87960:                 dialogBuilder.setNegativeButton(R.string.button_cancel, new AlertDialog.OnClickListener() {
87960:                     @Override
87960:                     public void onClick(DialogInterface dialog, int which) {
87960:                         dialog.dismiss();
87960:                     }
87960:                 });
87960:                 mMainHandler.post(new Runnable() {
87960:                     public void run() {
87960:                         dialogBuilder.show();
87960:                     }
87960:                 });
87960:             } else if (event.equals("CharEncoding:State")) {
87960:                 final boolean visible = message.getString("visible").equals("true");
87960:                 GeckoPreferences.setCharEncodingState(visible);
87960:                 if (sMenu != null) {
87960:                     mMainHandler.post(new Runnable() {
87960:                         public void run() {
87960:                             sMenu.findItem(R.id.char_encoding).setVisible(visible);
87960:                         }
87960:                     });
87960:                 }
83651:             }
83584:         } catch (Exception e) {
83934:             Log.e(LOGTAG, "Exception handling message \"" + event + "\":", e);
83584:         }
83584:     }
58306: 
83975:     public void showAboutHome() {
83975:         Runnable r = new AboutHomeRunnable(true);
83975:         mMainHandler.postAtFrontOfQueue(r);
83975:     }
83975: 
83975:     public void hideAboutHome() {
83975:         Runnable r = new AboutHomeRunnable(false);
83975:         mMainHandler.postAtFrontOfQueue(r);
83975:     }
83975: 
83975:     public class AboutHomeRunnable implements Runnable {
83975:         boolean mShow;
83975:         AboutHomeRunnable(boolean show) {
83975:             mShow = show;
83975:         }
83975: 
83975:         public void run() {
84564:             mAutoCompletePopup.hide();
85091:             if (mAboutHomeContent == null && mShow) {
85091:                 mAboutHomeContent = new AboutHomeContent(GeckoApp.mAppContext, null);
83975:                 mAboutHomeContent.init(GeckoApp.mAppContext);
83975:                 mAboutHomeContent.setUriLoadCallback(new AboutHomeContent.UriLoadCallback() {
83975:                     public void callback(String url) {
83975:                         mBrowserToolbar.setProgressVisibility(true);
83975:                         loadUrl(url, AwesomeBar.Type.EDIT);
83975:                     }
83975:                 });
86000:                 RelativeLayout.LayoutParams lp = 
86000:                     new RelativeLayout.LayoutParams(LayoutParams.FILL_PARENT, 
86000:                                                     LayoutParams.FILL_PARENT);
86000:                 mGeckoLayout.addView(mAboutHomeContent, lp);
83975:             }
85091:             if (mAboutHomeContent != null)
83975:                 mAboutHomeContent.setVisibility(mShow ? View.VISIBLE : View.GONE);
83975:         }
83975:     }
83975: 
84883:     /**
84883:      * @param aPermissions
84883:      *        Array of JSON objects to represent site permissions.
84883:      *        Example: { type: "offline-app", setting: "Store Offline Data: Allow" }
84883:      */
84883:     private void showSiteSettingsDialog(String aHost, JSONArray aPermissions) {
84883:         final AlertDialog.Builder builder = new AlertDialog.Builder(this);
84883: 
84883:         View customTitleView = getLayoutInflater().inflate(R.layout.site_setting_title, null);
84883:         ((TextView) customTitleView.findViewById(R.id.title)).setText(R.string.site_settings_title);
84883:         ((TextView) customTitleView.findViewById(R.id.host)).setText(aHost);        
84883:         builder.setCustomTitle(customTitleView);
84883: 
84883:         // If there are no permissions to clear, show the user a message about that.
84883:         // In the future, we want to disable the menu item if there are no permissions to clear.
84883:         if (aPermissions.length() == 0) {
84883:             builder.setMessage(R.string.site_settings_no_settings);
84883:         } else {
84883:             // Eventually we should use a list adapter and custom checkable list items
84883:             // to make a two-line UI to match the mock-ups
84883:             CharSequence[] items = new CharSequence[aPermissions.length()];
84883:             boolean[] states = new boolean[aPermissions.length()];
84883:             for (int i = 0; i < aPermissions.length(); i++) {
84883:                 try {
84883:                     items[i] = aPermissions.getJSONObject(i).
84883:                                getString("setting");
84883:                     // Make all the items checked by default
84883:                     states[i] = true;
84883:                 } catch (JSONException e) {
84883:                     Log.i(LOGTAG, "JSONException: " + e);
84883:                 }
84883:             }
84883:             builder.setMultiChoiceItems(items, states, new DialogInterface.OnMultiChoiceClickListener(){
84883:                 public void onClick(DialogInterface dialog, int item, boolean state) {
84883:                     // Do nothing
84883:                 }
84883:             });
84883:             builder.setPositiveButton(R.string.site_settings_clear, new DialogInterface.OnClickListener() {
84883:                 public void onClick(DialogInterface dialog, int id) {
84883:                     ListView listView = ((AlertDialog) dialog).getListView();
84883:                     SparseBooleanArray checkedItemPositions = listView.getCheckedItemPositions();
84883: 
84883:                     // An array of the indices of the permissions we want to clear
84883:                     JSONArray permissionsToClear = new JSONArray();
84883:                     for (int i = 0; i < checkedItemPositions.size(); i++) {
84883:                         boolean checked = checkedItemPositions.get(i);
84883:                         if (checked)
84883:                             permissionsToClear.put(i);
84883:                     }
84883:                     GeckoAppShell.sendEventToGecko(new GeckoEvent("Permissions:Clear", permissionsToClear.toString()));
84883:                 }
84883:             });
84883:         }
84883: 
84883:         builder.setNegativeButton(R.string.site_settings_cancel, new DialogInterface.OnClickListener(){
84883:             public void onClick(DialogInterface dialog, int id) {
84883:                 dialog.cancel();
84883:             }            
84883:         });
84883: 
84883:         mMainHandler.post(new Runnable() {
84883:             public void run() {
84883:                 builder.create().show();
84883:             }
84883:         });
84883:     }
84883: 
83792:     void handleDoorHanger(JSONObject geckoObject) throws JSONException {
83792:         final String message = geckoObject.getString("message");
83698:         final String value = geckoObject.getString("value");
83590:         final JSONArray buttons = geckoObject.getJSONArray("buttons");
83792:         final int tabId = geckoObject.getInt("tabID");
83793:         final JSONObject options = geckoObject.getJSONObject("options");
83792: 
83868:         Log.i(LOGTAG, "DoorHanger received for tab " + tabId + ", msg:" + message);
83590: 
83590:         mMainHandler.post(new Runnable() {
83590:             public void run() {
83727:                 Tab tab = Tabs.getInstance().getTab(tabId);
83793:                 mAppContext.mDoorHangerPopup.addDoorHanger(message, value, buttons,
83793:                                                            tab, options);
83590:             }
83590:         });
83590:     }
83590: 
83834:     void handleDoorHangerRemove(JSONObject geckoObject) throws JSONException {
83834:         final String value = geckoObject.getString("value");
83834:         final int tabId = geckoObject.getInt("tabID");
83834: 
83868:         Log.i(LOGTAG, "Doorhanger:Remove received for tab " + tabId);
83834: 
83834:         mMainHandler.post(new Runnable() {
83834:             public void run() {
83834:                 Tab tab = Tabs.getInstance().getTab(tabId);
83834:                 if (tab == null)
83834:                     return;
83834:                 tab.removeDoorHanger(value);
83835:                 mDoorHangerPopup.updatePopup();
83834:             }
83834:         });
83834:     }
83834: 
85042:     Tab handleAddTab(JSONObject params) throws JSONException {
85042:         Log.i(LOGTAG, params.toString());
85042:         final Tab tab = Tabs.getInstance().addTab(params);
83762: 
83584:         mMainHandler.post(new Runnable() {
83584:             public void run() {
83584:                 mBrowserToolbar.updateTabs(Tabs.getInstance().getCount());
83584:             }
83584:         });
85042: 
85042:         return tab;
83584:     }
83584: 
83584:     void handleCloseTab(final int tabId) {
83727:         final Tab tab = Tabs.getInstance().getTab(tabId);
83584:         Tabs.getInstance().removeTab(tabId);
83792:         tab.removeAllDoorHangers();
83584: 
83584:         mMainHandler.post(new Runnable() { 
83584:             public void run() {
83884:                 onTabsChanged(tab);
83584:                 mBrowserToolbar.updateTabs(Tabs.getInstance().getCount());
83835:                 mDoorHangerPopup.updatePopup();
83584:             }
83584:         });
83584:     }
83584: 
83692:     void handleSelectTab(int tabId) {
83584:         final Tab tab = Tabs.getInstance().selectTab(tabId);
83584:         if (tab == null)
83584:             return;
83584: 
84019:         if (tab.getURL().equals("about:home"))
84019:             showAboutHome();
84019:         else
83975:             hideAboutHome();
83975: 
83584:         mMainHandler.post(new Runnable() { 
83584:             public void run() {
84564:                 mAutoCompletePopup.hide();
83692:                 if (Tabs.getInstance().isSelectedTab(tab)) {
83687:                     mBrowserToolbar.setTitle(tab.getDisplayTitle());
83584:                     mBrowserToolbar.setFavicon(tab.getFavicon());
83712:                     mBrowserToolbar.setSecurityMode(tab.getSecurityMode());
83584:                     mBrowserToolbar.setProgressVisibility(tab.isLoading());
83835:                     mDoorHangerPopup.updatePopup();
85061:                     mBrowserToolbar.setShadowVisibility(!(tab.getURL().startsWith("about:")));
83692:                 }
83584:             }
83584:         });
83584:     }
83584: 
87744:     void handleDocumentStart(int tabId, final boolean showProgress) {
83692:         final Tab tab = Tabs.getInstance().getTab(tabId);
83581:         if (tab == null)
83581:             return;
83581: 
83541:         tab.setLoading(true);
83712:         tab.updateSecurityMode("unknown");
83541: 
83584:         mMainHandler.post(new Runnable() {
83584:             public void run() {
83712:                 if (Tabs.getInstance().isSelectedTab(tab)) {
83712:                     mBrowserToolbar.setSecurityMode(tab.getSecurityMode());
87744:                     if (showProgress)
83692:                         mBrowserToolbar.setProgressVisibility(true);
83712:                 }
83884:                 onTabsChanged(tab);
83584:             }
83584:         });
83536:     }
83536: 
83692:     void handleDocumentStop(int tabId) {
83692:         final Tab tab = Tabs.getInstance().getTab(tabId);
83584:         if (tab == null)
83584:             return;
83584: 
83541:         tab.setLoading(false);
83541: 
83584:         mMainHandler.post(new Runnable() {
83584:             public void run() {
83692:                 if (Tabs.getInstance().isSelectedTab(tab))
83559:                     mBrowserToolbar.setProgressVisibility(false);
83884:                 onTabsChanged(tab);
83536:             }
83536:         });
84434: 
84434:         Runnable r = new SessionSnapshotRunnable(tab);
84434:         GeckoAppShell.getHandler().postDelayed(r, 500);
83536:     }
83536: 
83618:     void handleShowToast(final String message, final String duration) {
83618:         mMainHandler.post(new Runnable() {
83618:             public void run() {
83618:                 Toast toast;
83618:                 if (duration.equals("long"))
83618:                     toast = Toast.makeText(mAppContext, message, Toast.LENGTH_LONG);
83618:                 else
83618:                     toast = Toast.makeText(mAppContext, message, Toast.LENGTH_SHORT);
83618:                 toast.show();
83618:             }
83618:         });
83618:     }
83618: 
83692:     void handleContentLoaded(int tabId, String uri, String title) {
83692:         final Tab tab = Tabs.getInstance().getTab(tabId);
83692:         if (tab == null)
83692:             return;
83692: 
83692:         tab.updateTitle(title);
83692: 
84434:         // Make the UI changes
83692:         mMainHandler.post(new Runnable() {
83692:             public void run() {
83885:                 loadFavicon(tab);
83885: 
84434:                 if (Tabs.getInstance().isSelectedTab(tab))
83692:                     mBrowserToolbar.setTitle(tab.getDisplayTitle());
84434: 
83884:                 onTabsChanged(tab);
83692:             }
83692:         });
83692:     }
83692: 
83692:     void handleTitleChanged(int tabId, String title) {
83687:         final Tab tab = Tabs.getInstance().getTab(tabId);
83584:         if (tab == null)
83584:             return;
83584: 
83541:         tab.updateTitle(title);
83541: 
83584:         mMainHandler.post(new Runnable() {
83584:             public void run() {
83692:                 if (Tabs.getInstance().isSelectedTab(tab))
83692:                     mBrowserToolbar.setTitle(tab.getDisplayTitle());
83884:                 onTabsChanged(tab);
83584:             }
83584:         });
83536:     }
83536: 
83584:     void handleLinkAdded(final int tabId, String rel, final String href) {
84262:         if (rel.indexOf("[icon]") != -1) {
83885:             final Tab tab = Tabs.getInstance().getTab(tabId);
83719:             if (tab != null) {
83719:                 tab.updateFaviconURL(href);
83719: 
83719:                 // If tab is not loading and the favicon is updated, we
83719:                 // want to load the image straight away. If tab is still
83719:                 // loading, we only load the favicon once the page's content
83719:                 // is fully loaded (see handleContentLoaded()).
83885:                 if (!tab.isLoading()) {
83885:                     mMainHandler.post(new Runnable() {
83885:                         public void run() {
83719:                             loadFavicon(tab);
83587:                         }
83885:                     });
83885:                 }
83885:             }
83587:         }
83584:     }
83572: 
86406:     void handleWindowClose(final int tabId) {
86406:         Tabs tabs = Tabs.getInstance();
86406:         Tab tab = tabs.getTab(tabId);
86406:         tabs.closeTab(tab);
86406:     }
86406: 
86757:     void handleDownloadDone(String displayName, String path, String mimeType, int size) {
86757:         // DownloadManager.addCompletedDownload is supported in level 12 and higher
86757:         if (Build.VERSION.SDK_INT >= 12) {
86757:             DownloadManager dm = (DownloadManager) mAppContext.getSystemService(Context.DOWNLOAD_SERVICE);
86757:             dm.addCompletedDownload(displayName, displayName,
86757:                 false /* do not use media scanner */,
86757:                 mimeType, path, size,
86757:                 false /* no notification */);
86757:         }
86757:     }
86757: 
83537:     void addPluginView(final View view,
87659:                        final int x, final int y,
87659:                        final int w, final int h,
87659:                        final String metadata) {
83537:         mMainHandler.post(new Runnable() { 
83537:             public void run() {
83848:                 PluginLayoutParams lp;
87659:                 JSONObject viewportObject;
87659:                 ViewportMetrics pluginViewport;
83848: 
87659:                 ViewportMetrics targetViewport = mLayerController.getViewportMetrics();
87659:                 
87659:                 try {
87659:                     viewportObject = new JSONObject(metadata);
87659:                     pluginViewport = new ViewportMetrics(viewportObject);
87659:                 } catch (JSONException e) {
87659:                     Log.e(LOGTAG, "Bad viewport metadata: ", e);
87659:                     return;
87659:                 }
83937: 
84036:                 if (mPluginContainer.indexOfChild(view) == -1) {
87659:                     lp = new PluginLayoutParams(x, y, w, h, pluginViewport);
83848: 
83537:                     view.setWillNotDraw(false);
83815:                     if (view instanceof SurfaceView) {
83815:                         SurfaceView sview = (SurfaceView)view;
83815: 
83815:                         sview.setZOrderOnTop(false);
83815:                         sview.setZOrderMediaOverlay(true);
83815:                     }
83537: 
84036:                     mPluginContainer.addView(view, lp);
83817:                     mPluginViews.add(view);
83537:                 } else {
83848:                     lp = (PluginLayoutParams)view.getLayoutParams();
87659:                     lp.reset(x, y, w, h, pluginViewport);
87659:                     lp.reposition(targetViewport);
71129:                     try {
84036:                         mPluginContainer.updateViewLayout(view, lp);
83537:                     } catch (IllegalArgumentException e) {
83868:                         Log.i(LOGTAG, "e:" + e);
83537:                         // it can be the case where we
83537:                         // get an update before the view
83537:                         // is actually attached.
71129:                     }
60270:                 }
83537:             }
83537:         });
83537:     }
83537: 
83537:     void removePluginView(final View view) {
83537:         mMainHandler.post(new Runnable() { 
83537:             public void run() {
83537:                 try {
84036:                     mPluginContainer.removeView(view);
83817:                     mPluginViews.remove(view);
83537:                 } catch (Exception e) {}
83537:             }
83537:         });
83537:     }
83537: 
83848:     public void hidePluginViews() {
83848:         for (View view : mPluginViews) {
83848:             view.setVisibility(View.GONE);
83848:         }
83848:     }
83848: 
83848:     public void showPluginViews() {
83937:         repositionPluginViews(true);
83848:     }
83848: 
83937:     public void repositionPluginViews(boolean setVisible) {
83937:         ViewportMetrics targetViewport = mLayerController.getViewportMetrics();
83848: 
87659:         if (targetViewport == null)
83937:             return;
83937: 
83817:         for (View view : mPluginViews) {
83817:             PluginLayoutParams lp = (PluginLayoutParams)view.getLayoutParams();
87659:             lp.reposition(targetViewport);
83848: 
83848:             if (setVisible) {
83848:                 view.setVisibility(View.VISIBLE);
83848:             }
83848: 
84036:             mPluginContainer.updateViewLayout(view, lp);
83817:         }
83817:     }
83817: 
83760:     public void setFullScreen(final boolean fullscreen) {
83760:         mFullScreen = fullscreen;
83760:         mMainHandler.post(new Runnable() { 
83760:             public void run() {
83760:                 // Hide/show the system notification bar
83760:                 getWindow().setFlags(fullscreen ?
83760:                                      WindowManager.LayoutParams.FLAG_FULLSCREEN : 0,
83760:                                      WindowManager.LayoutParams.FLAG_FULLSCREEN);
83760:             }
83760:         });
43032:     }
43032: 
43032:     /** Called when the activity is first created. */
43032:     @Override
43032:     public void onCreate(Bundle savedInstanceState)
43032:     {
84460:         // StrictMode is set by defaults resource flag |enableStrictMode|.
84460:         if (getResources().getBoolean(R.bool.enableStrictMode)) {
84460:             enableStrictMode();
84460:         }
84459: 
86905:         System.loadLibrary("mozglue");
84430:         mMainHandler = new Handler();
87573:         Log.w(LOGTAG, "zerdatime " + SystemClock.uptimeMillis() + " - onCreate");
83982:         if (savedInstanceState != null) {
83982:             mLastUri = savedInstanceState.getString(SAVED_STATE_URI);
83982:             mLastTitle = savedInstanceState.getString(SAVED_STATE_TITLE);
83982:             mLastViewport = savedInstanceState.getString(SAVED_STATE_VIEWPORT);
83996:             mLastScreen = savedInstanceState.getByteArray(SAVED_STATE_SCREEN);
87063:             mRestoreSession = savedInstanceState.getBoolean(SAVED_STATE_SESSION);
83982:         }
86579: 
86579:         Intent intent = getIntent();
86795:         String args = intent.getStringExtra("args");
86795:         if (args != null && args.contains("-profile")) {
86795:             Pattern p = Pattern.compile("(?:-profile\\s*)(\\w*)(\\s*)");
86795:             Matcher m = p.matcher(args);
86795:             if (m.find()) {
86795:                 mProfileDir = new File(m.group(1));
86795:                 mLastUri = null;
86795:                 mLastTitle = null;
86795:                 mLastViewport = null;
86795:                 mLastScreen = null;
86795:             }
86795:         }
86795: 
86579:         String uri = intent.getDataString();
84430:         String title = uri;
84430:         if (uri != null && uri.length() > 0) {
84430:             mLastUri = uri;
84430:             mLastTitle = title;
84430:         }
84430: 
84430:         if (mLastUri == null || mLastUri.equals("") ||
84430:             mLastUri.equals("about:home")) {
84430:             showAboutHome();
84430:         }
84430: 
86579:         mAppContext = this;
86579: 
86579:         if (sGREDir == null)
86579:             sGREDir = new File(this.getApplicationInfo().dataDir);
86579: 
87594:         String passedUri = mLastUri;
86579: 
87594:         Uri data = intent.getData();
87594:         if (data != null && "http".equals(data.getScheme()) &&
87594:             isHostOnPrefetchWhitelist(data.getHost())) {
87594:             Intent copy = new Intent(intent);
87594:             copy.setAction(ACTION_LOAD);
87594:             GeckoAppShell.getHandler().post(new RedirectorRunnable(copy));
87594:             // We're going to handle this uri with the redirector, so setting
87594:             // the action to MAIN and clearing the uri data prevents us from
87594:             // loading it twice
87594:             intent.setAction(Intent.ACTION_MAIN);
87594:             intent.setData(null);
87594:             passedUri = null;
87594:         }
87594: 
87594:         sGeckoThread = new GeckoThread(intent, passedUri, mRestoreSession);
86579:         if (!ACTION_DEBUG.equals(intent.getAction()) &&
86579:             checkAndSetLaunchState(LaunchState.Launching, LaunchState.Launched))
86579:             sGeckoThread.start();
86579: 
83485:         super.onCreate(savedInstanceState);
83485: 
83485:         setContentView(R.layout.gecko_app);
83485: 
83942:         if (Build.VERSION.SDK_INT >= 11) {
86815:             mBrowserToolbar = (BrowserToolbar) getLayoutInflater().inflate(R.layout.browser_toolbar, null);
83942: 
85061:             GeckoActionBar.setBackgroundDrawable(this, getResources().getDrawable(R.drawable.gecko_actionbar_bg));
85061:             GeckoActionBar.setDisplayOptions(this, ActionBar.DISPLAY_SHOW_CUSTOM, ActionBar.DISPLAY_SHOW_CUSTOM |
83942:                                                                                   ActionBar.DISPLAY_SHOW_HOME |
83942:                                                                                   ActionBar.DISPLAY_SHOW_TITLE |
83942:                                                                                   ActionBar.DISPLAY_USE_LOGO);
85061:             GeckoActionBar.setCustomView(this, mBrowserToolbar);
83942:         } else {
83942:             mBrowserToolbar = (BrowserToolbar) findViewById(R.id.browser_toolbar);
83942:         }
83942: 
87006:         mBrowserToolbar.setTitle(mLastTitle);
87006: 
83719:         mFavicons = new Favicons(this);
83719: 
83485:         // setup gecko layout
84036:         mGeckoLayout = (RelativeLayout) findViewById(R.id.gecko_layout);
83621:         mMainLayout = (LinearLayout) findViewById(R.id.main_layout);
83621: 
83727:         mDoorHangerPopup = new DoorHangerPopup(this);
84564:         mAutoCompletePopup = (AutoCompletePopup) findViewById(R.id.autocomplete_popup);
83487: 
83631:         Tabs tabs = Tabs.getInstance();
83631:         Tab tab = tabs.getSelectedTab();
83583:         if (tab != null) {
83687:             mBrowserToolbar.setTitle(tab.getDisplayTitle());
83583:             mBrowserToolbar.setFavicon(tab.getFavicon());
83666:             mBrowserToolbar.setProgressVisibility(tab.isLoading());
83583:             mBrowserToolbar.updateTabs(Tabs.getInstance().getCount()); 
83583:         }
83583: 
83631:         tabs.setContentResolver(getContentResolver()); 
83631: 
83721:         if (cameraView == null) {
83721:             cameraView = new SurfaceView(this);
83721:             cameraView.getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
83721:         }
83721: 
83777:         if (mLayerController == null) {
83777:             /*
83777:              * Create a layer client so that Gecko will have a buffer to draw into, but don't hook
83777:              * it up to the layer controller yet.
83777:              */
83777:             mSoftwareLayerClient = new GeckoSoftwareLayerClient(this);
83777: 
83777:             /*
83777:              * Hook a placeholder layer client up to the layer controller so that the user can pan
83777:              * and zoom a cached screenshot of the previous page. This call will return null if
83777:              * there is no cached screenshot; in that case, we have no choice but to display a
83777:              * checkerboard.
83777:              *
83777:              * TODO: Fall back to a built-in screenshot of the Fennec Start page for a nice first-
83777:              * run experience, perhaps?
83777:              */
83798:             mLayerController = new LayerController(this);
86795:             mPlaceholderLayerClient = PlaceholderLayerClient.createInstance(this);
83878:             mLayerController.setLayerClient(mPlaceholderLayerClient);
84423: 
84422:             mGeckoLayout.addView(mLayerController.getView(), 0);
83777:         }
83516: 
84036:         mPluginContainer = (AbsoluteLayout) findViewById(R.id.plugin_container);
84036: 
87573:         Log.w(LOGTAG, "zerdatime " + SystemClock.uptimeMillis() + " - UI almost up");
83485: 
74433:         if (!sTryCatchAttached) {
74433:             sTryCatchAttached = true;
71129:             mMainHandler.post(new Runnable() {
71129:                 public void run() {
71129:                     try {
71129:                         Looper.loop();
71129:                     } catch (Exception e) {
87989:                         GeckoAppShell.reportJavaCrash(e);
71129:                     }
74433:                     // resetting this is kinda pointless, but oh well
74433:                     sTryCatchAttached = false;
71129:                 }
71129:             });
74433:         }
71129: 
83584:         //register for events
83584:         GeckoAppShell.registerGeckoEventListener("DOMContentLoaded", GeckoApp.mAppContext);
83584:         GeckoAppShell.registerGeckoEventListener("DOMTitleChanged", GeckoApp.mAppContext);
83584:         GeckoAppShell.registerGeckoEventListener("DOMLinkAdded", GeckoApp.mAppContext);
86406:         GeckoAppShell.registerGeckoEventListener("DOMWindowClose", GeckoApp.mAppContext);
83584:         GeckoAppShell.registerGeckoEventListener("log", GeckoApp.mAppContext);
83712:         GeckoAppShell.registerGeckoEventListener("Content:LocationChange", GeckoApp.mAppContext);
83712:         GeckoAppShell.registerGeckoEventListener("Content:SecurityChange", GeckoApp.mAppContext);
83712:         GeckoAppShell.registerGeckoEventListener("Content:StateChange", GeckoApp.mAppContext);
84791:         GeckoAppShell.registerGeckoEventListener("Content:LoadError", GeckoApp.mAppContext);
83584:         GeckoAppShell.registerGeckoEventListener("onCameraCapture", GeckoApp.mAppContext);
83584:         GeckoAppShell.registerGeckoEventListener("Tab:Added", GeckoApp.mAppContext);
87856:         GeckoAppShell.registerGeckoEventListener("Tab:Closed", GeckoApp.mAppContext);
83584:         GeckoAppShell.registerGeckoEventListener("Tab:Selected", GeckoApp.mAppContext);
87329:         GeckoAppShell.registerGeckoEventListener("Tab:ScreenshotData", GeckoApp.mAppContext);
83590:         GeckoAppShell.registerGeckoEventListener("Doorhanger:Add", GeckoApp.mAppContext);
83834:         GeckoAppShell.registerGeckoEventListener("Doorhanger:Remove", GeckoApp.mAppContext);
83603:         GeckoAppShell.registerGeckoEventListener("Menu:Add", GeckoApp.mAppContext);
83603:         GeckoAppShell.registerGeckoEventListener("Menu:Remove", GeckoApp.mAppContext);
83614:         GeckoAppShell.registerGeckoEventListener("Gecko:Ready", GeckoApp.mAppContext);
83618:         GeckoAppShell.registerGeckoEventListener("Toast:Show", GeckoApp.mAppContext);
83760:         GeckoAppShell.registerGeckoEventListener("ToggleChrome:Hide", GeckoApp.mAppContext);
83760:         GeckoAppShell.registerGeckoEventListener("ToggleChrome:Show", GeckoApp.mAppContext);
84564:         GeckoAppShell.registerGeckoEventListener("FormAssist:AutoComplete", GeckoApp.mAppContext);
84883:         GeckoAppShell.registerGeckoEventListener("Permissions:Data", GeckoApp.mAppContext);
86757:         GeckoAppShell.registerGeckoEventListener("Downloads:Done", GeckoApp.mAppContext);
87960:         GeckoAppShell.registerGeckoEventListener("CharEncoding:Data", GeckoApp.mAppContext);
87960:         GeckoAppShell.registerGeckoEventListener("CharEncoding:State", GeckoApp.mAppContext);
58306: 
69614:         mConnectivityFilter = new IntentFilter();
69614:         mConnectivityFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
69614:         mConnectivityReceiver = new GeckoConnectivityReceiver();
69614: 
82619:         IntentFilter batteryFilter = new IntentFilter();
82619:         batteryFilter.addAction(Intent.ACTION_BATTERY_CHANGED);
81324:         mBatteryReceiver = new GeckoBatteryManager();
82619:         registerReceiver(mBatteryReceiver, batteryFilter);
81324: 
87554:         if (SmsManager.getInstance() != null) {
88061:           SmsManager.getInstance().start();
87554:         }
87552: 
87564:         GeckoNetworkManager.getInstance().init();
87563: 
83485:         final GeckoApp self = this;
84556: 
86531:         GeckoAppShell.getHandler().postDelayed(new Runnable() {
84556:             public void run() {
87573:                 Log.w(LOGTAG, "zerdatime " + SystemClock.uptimeMillis() + " - pre checkLaunchState");
84556: 
84556:                 /*
84556:                   XXXX see bug 635342
84556:                    We want to disable this code if possible.  It is about 145ms in runtime
84556:                 SharedPreferences settings = getPreferences(Activity.MODE_PRIVATE);
84556:                 String localeCode = settings.getString(getPackageName() + ".locale", "");
84556:                 if (localeCode != null && localeCode.length() > 0)
84556:                     GeckoAppShell.setSelectedLocale(localeCode);
84556:                 */
84556: 
84556:                 if (!checkLaunchState(LaunchState.Launched)) {
84556:                     return;
84556:                 }
84556: 
84556:                 // it would be good only to do this if MOZ_UPDATER was defined
87573:                 long startTime = SystemClock.uptimeMillis();
84556:                 checkAndLaunchUpdate();
87573:                 Log.w(LOGTAG, "checking for an update took " + (SystemClock.uptimeMillis() - startTime) + "ms");
85057:                 checkMigrateProfile();
84556:             }
84556:         }, 50);
86027: 
86027:         mOrientation = getResources().getConfiguration().orientation;
58306:     }
58306: 
84459:     /**
84459:      * Enable Android StrictMode checks (for supported OS versions).
84459:      * http://developer.android.com/reference/android/os/StrictMode.html
84459:      */
84459:     private void enableStrictMode()
84459:     {
84459:         if (Build.VERSION.SDK_INT < Build.VERSION_CODES.GINGERBREAD) {
84459:             return;
84459:         }
84459: 
84459:         StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
84459:                                   .detectAll()
84459:                                   .penaltyLog()
84459:                                   .build());
84459: 
84459:         StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
84459:                                .detectAll()
84459:                                .penaltyLog()
84459:                                .build());
84459:     }
84459: 
81455:     public void enableCameraView() {
81455:         // Some phones (eg. nexus S) need at least a 8x16 preview size
83721:         mMainLayout.addView(cameraView, new AbsoluteLayout.LayoutParams(8, 16, 0, 0));
81455:     }
81455: 
81455:     public void disableCameraView() {
83721:         mMainLayout.removeView(cameraView);
81455:     }
81455: 
87594:     abstract public String getDefaultUAString();
87594:     abstract public String getUAStringForHost(String host);
87594: 
87594:     class RedirectorRunnable implements Runnable {
87594:         Intent mIntent;
87594:         RedirectorRunnable(Intent intent) {
87594:             mIntent = intent;
87594:         }
87594:         public void run() {
87594:             HttpURLConnection connection = null;
87594:             try {
87594:                 // this class should only be initialized with an intent with non-null data
87594:                 URL url = new URL(mIntent.getData().toString());
87594:                 // data url should have an http scheme
87594:                 connection = (HttpURLConnection) url.openConnection();
87594:                 connection.setRequestProperty("User-Agent", getUAStringForHost(url.getHost()));
87594:                 connection.setInstanceFollowRedirects(false);
87594:                 connection.setRequestMethod("GET");
87594:                 connection.connect();
87594:                 int code = connection.getResponseCode();
87594:                 if (code >= 300 && code < 400) {
87594:                     String location = connection.getHeaderField("Location");
87594:                     Uri data;
87594:                     if (location != null &&
87594:                         (data = Uri.parse(location)) != null &&
87594:                         !"about".equals(data.getScheme()) && 
87594:                         !"chrome".equals(data.getScheme())) {
87594:                         mIntent.setData(data);
87594:                         mLastUri = mLastTitle = location;
87594:                     } else {
87594:                         mIntent.putExtra("prefetched", 1);
87594:                     }
87594:                 } else {
87594:                     mIntent.putExtra("prefetched", 1);
87594:                 }
87594:             } catch (IOException ioe) {
87594:                 Log.i(LOGTAG, "exception trying to pre-fetch redirected url", ioe);
87594:                 mIntent.putExtra("prefetched", 1);
87594:             } catch (Exception e) {
87594:                 Log.w(LOGTAG, "unexpected exception, passing url directly to Gecko but we should explicitly catch this", e);
87594:                 mIntent.putExtra("prefetched", 1);
87594:             } finally {
87594:                 if (connection != null)
87594:                     connection.disconnect();
87594:             }
87594:             mMainHandler.postAtFrontOfQueue(new Runnable() {
87594:                 public void run() {
87594:                     onNewIntent(mIntent);
87594:                 }
87594:             });
87594:         }
87594:     }
87594: 
87594:     private final String kPrefetchWhiteListArray[] = new String[] { 
87594:         "t.co",
87594:         "bit.ly",
87594:         "moz.la",
87594:         "aje.me",
87594:         "facebook.com",
87594:         "goo.gl",
87594:         "tinyurl.com"
87594:     };
87594:     
87594:     private final CopyOnWriteArrayList<String> kPrefetchWhiteList =
87594:         new CopyOnWriteArrayList<String>(kPrefetchWhiteListArray);
87594: 
87594:     private boolean isHostOnPrefetchWhitelist(String host) {
87594:         return kPrefetchWhiteList.contains(host);
87594:     }
87594: 
43032:     @Override
43811:     protected void onNewIntent(Intent intent) {
87573:         Log.w(LOGTAG, "zerdatime " + SystemClock.uptimeMillis() + " - onNewIntent");
83485: 
58306:         if (checkLaunchState(LaunchState.GeckoExiting)) {
58306:             // We're exiting and shouldn't try to do anything else just incase
58306:             // we're hung for some reason we'll force the process to exit
58306:             System.exit(0);
58306:             return;
58306:         }
87594: 
87594:         if (checkLaunchState(LaunchState.Launched)) {
87594:             Uri data = intent.getData();
87594:             Bundle bundle = intent.getExtras();
87594:             // if the intent has data (i.e. a URI to be opened) and the scheme
87594:             // is either http, we'll prefetch it, which means warming
87594:             // up the radio and DNS cache by connecting and parsing the redirect
87594:             // if the return code is between 300 and 400
87594:             if (data != null && 
87594:                 "http".equals(data.getScheme()) &&
87594:                 (bundle == null || bundle.getInt("prefetched", 0) != 1) &&
87594:                 isHostOnPrefetchWhitelist(data.getHost())) {
87594:                 GeckoAppShell.getHandler().post(new RedirectorRunnable(intent));
87594:                 return;
87594:             }
87594:         }
43811:         final String action = intent.getAction();
78217:         if (ACTION_DEBUG.equals(action) &&
83931:             checkAndSetLaunchState(LaunchState.Launching, LaunchState.WaitForDebugger)) {
83931:             mMainHandler.postDelayed(new Runnable() {
83931:                 public void run() {
83931:                     Log.i(LOGTAG, "Launching from debug intent after 5s wait");
78217:                     setLaunchState(LaunchState.Launching);
86579:                     sGeckoThread.start();
78217:                 }
83931:             }, 1000 * 5 /* 5 seconds */);
83931:             Log.i(LOGTAG, "Intent : ACTION_DEBUG - waiting 5s before launching");
78217:             return;
78217:         }
86579:         if (checkLaunchState(LaunchState.WaitForDebugger) || intent == getIntent())
78217:             return;
58306: 
75067:         if (Intent.ACTION_MAIN.equals(action)) {
83868:             Log.i(LOGTAG, "Intent : ACTION_MAIN");
75067:             GeckoAppShell.sendEventToGecko(new GeckoEvent(""));
75067:         }
87594:         else if (ACTION_LOAD.equals(action)) {
87594:             String uri = intent.getDataString();
87594:             loadUrl(uri, AwesomeBar.Type.EDIT);
87594:             Log.i(LOGTAG,"onNewIntent: " + uri);
87594:         }
78217:         else if (Intent.ACTION_VIEW.equals(action)) {
43811:             String uri = intent.getDataString();
43811:             GeckoAppShell.sendEventToGecko(new GeckoEvent(uri));
83868:             Log.i(LOGTAG,"onNewIntent: " + uri);
43811:         }
78217:         else if (ACTION_WEBAPP.equals(action)) {
55889:             String uri = intent.getStringExtra("args");
55889:             GeckoAppShell.sendEventToGecko(new GeckoEvent(uri));
83868:             Log.i(LOGTAG,"Intent : WEBAPP - " + uri);
55889:         }
78217:         else if (ACTION_BOOKMARK.equals(action)) {
75067:             String args = intent.getStringExtra("args");
75067:             GeckoAppShell.sendEventToGecko(new GeckoEvent(args));
83868:             Log.i(LOGTAG,"Intent : BOOKMARK - " + args);
75067:         }
43811:     }
43811: 
43811:     @Override
43032:     public void onPause()
43032:     {
83868:         Log.i(LOGTAG, "pause");
83856: 
84434:         Runnable r = new SessionSnapshotRunnable(null);
84434:         GeckoAppShell.getHandler().post(r);
83705: 
43741:         GeckoAppShell.sendEventToGecko(new GeckoEvent(GeckoEvent.ACTIVITY_PAUSING));
43032:         // The user is navigating away from this activity, but nothing
43032:         // has come to the foreground yet; for Gecko, we may want to
43032:         // stop repainting, for example.
43032: 
43032:         // Whatever we do here should be fast, because we're blocking
43032:         // the next activity from showing up until we finish.
43032: 
43032:         // onPause will be followed by either onResume or onStop.
43032:         super.onPause();
69577: 
69577:         unregisterReceiver(mConnectivityReceiver);
87564:         GeckoNetworkManager.getInstance().stop();
43032:     }
43032: 
43032:     @Override
43032:     public void onResume()
43032:     {
83868:         Log.i(LOGTAG, "resume");
58306:         if (checkLaunchState(LaunchState.GeckoRunning))
61773:             GeckoAppShell.onResume();
43032:         // After an onPause, the activity is back in the foreground.
43032:         // Undo whatever we did in onPause.
43032:         super.onResume();
58306: 
58306:         // Just in case. Normally we start in onNewIntent
83485:         if (checkLaunchState(LaunchState.Launching))
58306:             onNewIntent(getIntent());
69577: 
69577:         registerReceiver(mConnectivityReceiver, mConnectivityFilter);
87564:         GeckoNetworkManager.getInstance().start();
87563: 
84009:         if (mOwnActivityDepth > 0)
84009:             mOwnActivityDepth--;
61773:     }
61773: 
61773:     @Override
61773:     public void onStop()
61773:     {
83868:         Log.i(LOGTAG, "stop");
61773:         // We're about to be stopped, potentially in preparation for
61773:         // being destroyed.  We're killable after this point -- as I
61773:         // understand it, in extreme cases the process can be terminated
61773:         // without going through onDestroy.
61773:         //
61773:         // We might also get an onRestart after this; not sure what
61773:         // that would mean for Gecko if we were to kill it here.
61773:         // Instead, what we should do here is save prefs, session,
61773:         // etc., and generally mark the profile as 'clean', and then
61773:         // dirty it again if we get an onResume.
61773: 
61773:         GeckoAppShell.sendEventToGecko(new GeckoEvent(GeckoEvent.ACTIVITY_STOPPING));
61773:         super.onStop();
61773:     }
61773: 
61773:     @Override
61773:     public void onRestart()
61773:     {
83868:         Log.i(LOGTAG, "restart");
61773:         super.onRestart();
61773:     }
61773: 
61773:     @Override
61773:     public void onStart()
61773:     {
87573:         Log.w(LOGTAG, "zerdatime " + SystemClock.uptimeMillis() + " - onStart");
83485: 
83868:         Log.i(LOGTAG, "start");
76942:         GeckoAppShell.sendEventToGecko(new GeckoEvent(GeckoEvent.ACTIVITY_START));
61773:         super.onStart();
46173:     }
46173: 
46173:     @Override
43032:     public void onDestroy()
43032:     {
83868:         Log.i(LOGTAG, "destroy");
83485: 
43032:         // Tell Gecko to shutting down; we'll end up calling System.exit()
43032:         // in onXreExit.
57135:         if (isFinishing())
59122:             GeckoAppShell.sendEventToGecko(new GeckoEvent(GeckoEvent.ACTIVITY_SHUTDOWN));
43032:         
83584:         GeckoAppShell.unregisterGeckoEventListener("DOMContentLoaded", GeckoApp.mAppContext);
83584:         GeckoAppShell.unregisterGeckoEventListener("DOMTitleChanged", GeckoApp.mAppContext);
83584:         GeckoAppShell.unregisterGeckoEventListener("DOMLinkAdded", GeckoApp.mAppContext);
86406:         GeckoAppShell.unregisterGeckoEventListener("DOMWindowClose", GeckoApp.mAppContext);
83584:         GeckoAppShell.unregisterGeckoEventListener("log", GeckoApp.mAppContext);
83712:         GeckoAppShell.unregisterGeckoEventListener("Content:LocationChange", GeckoApp.mAppContext);
83712:         GeckoAppShell.unregisterGeckoEventListener("Content:SecurityChange", GeckoApp.mAppContext);
83712:         GeckoAppShell.unregisterGeckoEventListener("Content:StateChange", GeckoApp.mAppContext);
84791:         GeckoAppShell.unregisterGeckoEventListener("Content:LoadError", GeckoApp.mAppContext);
83584:         GeckoAppShell.unregisterGeckoEventListener("onCameraCapture", GeckoApp.mAppContext);
83584:         GeckoAppShell.unregisterGeckoEventListener("Tab:Added", GeckoApp.mAppContext);
87856:         GeckoAppShell.unregisterGeckoEventListener("Tab:Closed", GeckoApp.mAppContext);
83584:         GeckoAppShell.unregisterGeckoEventListener("Tab:Selected", GeckoApp.mAppContext);
87329:         GeckoAppShell.unregisterGeckoEventListener("Tab:ScreenshotData", GeckoApp.mAppContext);
83590:         GeckoAppShell.unregisterGeckoEventListener("Doorhanger:Add", GeckoApp.mAppContext);
83603:         GeckoAppShell.unregisterGeckoEventListener("Menu:Add", GeckoApp.mAppContext);
83603:         GeckoAppShell.unregisterGeckoEventListener("Menu:Remove", GeckoApp.mAppContext);
83614:         GeckoAppShell.unregisterGeckoEventListener("Gecko:Ready", GeckoApp.mAppContext);
83618:         GeckoAppShell.unregisterGeckoEventListener("Toast:Show", GeckoApp.mAppContext);
83760:         GeckoAppShell.unregisterGeckoEventListener("ToggleChrome:Hide", GeckoApp.mAppContext);
83760:         GeckoAppShell.unregisterGeckoEventListener("ToggleChrome:Show", GeckoApp.mAppContext);
84564:         GeckoAppShell.unregisterGeckoEventListener("FormAssist:AutoComplete", GeckoApp.mAppContext);
84883:         GeckoAppShell.unregisterGeckoEventListener("Permissions:Data", GeckoApp.mAppContext);
86757:         GeckoAppShell.unregisterGeckoEventListener("Downloads:Done", GeckoApp.mAppContext);
87960:         GeckoAppShell.unregisterGeckoEventListener("CharEncoding:Data", GeckoApp.mAppContext);
87960:         GeckoAppShell.unregisterGeckoEventListener("CharEncoding:State", GeckoApp.mAppContext);
83584: 
83719:         mFavicons.close();
83832: 
87554:         if (SmsManager.getInstance() != null) {
88061:             SmsManager.getInstance().stop();
88061:             if (isFinishing())
87554:                 SmsManager.getInstance().shutdown();
87554:         }
87552: 
87564:         GeckoNetworkManager.getInstance().stop();
87564: 
43032:         super.onDestroy();
82619: 
82619:         unregisterReceiver(mBatteryReceiver);
43032:     }
43032: 
43032:     @Override
83975:     public void onContentChanged() {
83975:         super.onContentChanged();
85091:         if (mAboutHomeContent != null)
83975:             mAboutHomeContent.onActivityContentChanged(this);
83975:     }
83975: 
83975: 
83975:     @Override
86027:     public void onConfigurationChanged(Configuration newConfig)
43032:     {
83868:         Log.i(LOGTAG, "configuration changed");
84564: 
86027:         super.onConfigurationChanged(newConfig);
86027: 
86027:         if (mOrientation != newConfig.orientation) {
86027:             mOrientation = newConfig.orientation;
84564:             mAutoCompletePopup.hide();
84564: 
86027:             if (Build.VERSION.SDK_INT >= 11) {
86815:                 mBrowserToolbar = (BrowserToolbar) getLayoutInflater().inflate(R.layout.browser_toolbar, null);
86814: 
86814:                 Tab tab = Tabs.getInstance().getSelectedTab();
86814:                 if (tab != null) {
86814:                     mBrowserToolbar.setTitle(tab.getDisplayTitle());
86814:                     mBrowserToolbar.setFavicon(tab.getFavicon());
86814:                     mBrowserToolbar.setSecurityMode(tab.getSecurityMode());
86814:                     mBrowserToolbar.setProgressVisibility(tab.isLoading());
86814:                     mBrowserToolbar.setShadowVisibility(!(tab.getURL().startsWith("about:")));
86814:                     mBrowserToolbar.updateTabs(Tabs.getInstance().getCount());
86814:                 }
86814: 
86814:                 GeckoActionBar.setBackgroundDrawable(this, getResources().getDrawable(R.drawable.gecko_actionbar_bg));
86027:                 GeckoActionBar.setCustomView(mAppContext, mBrowserToolbar);
86027:             }
86027:         }
43032:     }
43032: 
43032:     @Override
43032:     public void onLowMemory()
43032:     {
83868:         Log.e(LOGTAG, "low memory");
58306:         if (checkLaunchState(LaunchState.GeckoRunning))
51794:             GeckoAppShell.onLowMemory();
43032:         super.onLowMemory();
43032:     }
43032: 
59565:     abstract public String getPackageName();
46245:     abstract public String getContentProcessName();
43032: 
56418:     public void addEnvToIntent(Intent intent) {
43032:         Map<String,String> envMap = System.getenv();
43032:         Set<Map.Entry<String,String>> envSet = envMap.entrySet();
43032:         Iterator<Map.Entry<String,String>> envIter = envSet.iterator();
43032:         int c = 0;
43032:         while (envIter.hasNext()) {
43032:             Map.Entry<String,String> entry = envIter.next();
56418:             intent.putExtra("env" + c, entry.getKey() + "="
43032:                             + entry.getValue());
43032:             c++;
43032:         }
43032:     }
43032: 
43032:     public void doRestart() {
43032:         try {
59565:             String action = "org.mozilla.gecko.restart";
56418:             Intent intent = new Intent(action);
59565:             intent.setClassName(getPackageName(),
59565:                                 getPackageName() + ".Restarter");
83777:             /* TODO: addEnvToIntent(intent); */
58498:             intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
58498:                             Intent.FLAG_ACTIVITY_MULTIPLE_TASK);
83868:             Log.i(LOGTAG, intent.toString());
63326:             GeckoAppShell.killAnyZombies();
56614:             startActivity(intent);
43032:         } catch (Exception e) {
83868:             Log.i(LOGTAG, "error doing restart", e);
43032:         }
56418:         finish();
63180:         // Give the restart process time to start before we die
63326:         GeckoAppShell.waitForAnotherGeckoProc();
43032:     }
51723: 
51723:     public void handleNotification(String action, String alertName, String alertCookie) {
51723:         GeckoAppShell.handleNotification(action, alertName, alertCookie);
43032:     }
53801: 
53801:     private void checkAndLaunchUpdate() {
83868:         Log.i(LOGTAG, "Checking for an update");
53801: 
53801:         int statusCode = 8; // UNEXPECTED_ERROR
62278:         File baseUpdateDir = null;
59798:         if (Build.VERSION.SDK_INT >= 8)
62278:             baseUpdateDir = getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS);
59798:         else
62278:             baseUpdateDir = new File(Environment.getExternalStorageDirectory().getPath(), "download");
53801: 
62278:         File updateDir = new File(new File(baseUpdateDir, "updates"),"0");
59798: 
59798:         File updateFile = new File(updateDir, "update.apk");
59798:         File statusFile = new File(updateDir, "update.status");
58005: 
58005:         if (!statusFile.exists() || !readUpdateStatus(statusFile).equals("pending"))
58005:             return;
53801: 
53801:         if (!updateFile.exists())
53801:             return;
53801: 
83868:         Log.i(LOGTAG, "Update is available!");
53801: 
53801:         // Launch APK
71523:         File updateFileToRun = new File(updateDir, getPackageName() + "-update.apk");
53801:         try {
54492:             if (updateFile.renameTo(updateFileToRun)) {
53801:                 String amCmd = "/system/bin/am start -a android.intent.action.VIEW " +
53801:                                "-n com.android.packageinstaller/.PackageInstallerActivity -d file://" +
53801:                                updateFileToRun.getPath();
83868:                 Log.i(LOGTAG, amCmd);
53801:                 Runtime.getRuntime().exec(amCmd);
53801:                 statusCode = 0; // OK
53801:             } else {
83868:                 Log.i(LOGTAG, "Cannot rename the update file!");
53801:                 statusCode = 7; // WRITE_ERROR
51723:             }
53801:         } catch (Exception e) {
83868:             Log.i(LOGTAG, "error launching installer to update", e);
53801:         }
53801: 
53801:         // Update the status file
53801:         String status = statusCode == 0 ? "succeeded\n" : "failed: "+ statusCode + "\n";
53801: 
53801:         OutputStream outStream;
53801:         try {
53801:             byte[] buf = status.getBytes("UTF-8");
53801:             outStream = new FileOutputStream(statusFile);
53801:             outStream.write(buf, 0, buf.length);
53801:             outStream.close();
53801:         } catch (Exception e) {
83868:             Log.i(LOGTAG, "error writing status file", e);
53801:         }
53801: 
53801:         if (statusCode == 0)
53801:             System.exit(0);
53801:     }
56159: 
58005:     private String readUpdateStatus(File statusFile) {
58005:         String status = "";
58005:         try {
58005:             BufferedReader reader = new BufferedReader(new FileReader(statusFile));
58005:             status = reader.readLine();
58005:             reader.close();
58005:         } catch (Exception e) {
83868:             Log.i(LOGTAG, "error reading update status", e);
58005:         }
58005:         return status;
58005:     }
58005: 
85057:     private void checkMigrateProfile() {
85057:         File profileDir = getProfileDir();
85057:         if (profileDir != null) {
85057:             Log.i(LOGTAG, "checking profile migration in: " + profileDir.getAbsolutePath());
87745:             final GeckoApp app = GeckoApp.mAppContext;
87745:             GeckoAppShell.ensureSQLiteLibsLoaded(app.getApplication().getPackageResourcePath());
85057:             ProfileMigrator profileMigrator =
87745:                 new ProfileMigrator(app.getContentResolver(), profileDir);
85057:             profileMigrator.launchBackground();
85057:         }
85057:     }
85057: 
83491:     private SynchronousQueue<String> mFilePickerResult = new SynchronousQueue<String>();
56942:     public String showFilePicker(String aMimeType) {
56159:         Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
56159:         intent.addCategory(Intent.CATEGORY_OPENABLE);
56942:         intent.setType(aMimeType);
56159:         GeckoApp.this.
56159:             startActivityForResult(
74666:                 Intent.createChooser(intent, getString(R.string.choose_file)),
56159:                 FILE_PICKER_REQUEST);
56159:         String filePickerResult = "";
76837: 
56159:         try {
76837:             while (null == (filePickerResult = mFilePickerResult.poll(1, TimeUnit.MILLISECONDS))) {
83868:                 Log.i(LOGTAG, "processing events from showFilePicker ");
76837:                 GeckoAppShell.processNextNativeEvent();
76837:             }
56159:         } catch (InterruptedException e) {
83868:             Log.i(LOGTAG, "showing file picker ",  e);
53801:         }
56159: 
56159:         return filePickerResult;
56159:     }
56159: 
56159:     @Override
83485:     public boolean onSearchRequested() {
83586:         return showAwesomebar(AwesomeBar.Type.ADD);
83485:     }
83485:  
83541:     public boolean onEditRequested() {
83586:         return showAwesomebar(AwesomeBar.Type.EDIT);
83586:     }
83586: 
83586:     public boolean showAwesomebar(AwesomeBar.Type aType) {
83541:         Intent intent = new Intent(getBaseContext(), AwesomeBar.class);
83541:         intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION | Intent.FLAG_ACTIVITY_NO_HISTORY);
83586:         intent.putExtra(AwesomeBar.TYPE_KEY, aType.name());
83586: 
83586:         if (aType != AwesomeBar.Type.ADD) {
83586:             // if we're not adding a new tab, show the old url
83541:             Tab tab = Tabs.getInstance().getSelectedTab();
83674:             if (tab != null) {
83674:                 Tab.HistoryEntry he = tab.getLastHistoryEntry();
83674:                 if (he != null) {
83674:                     intent.putExtra(AwesomeBar.CURRENT_URL_KEY, he.mUri);
83674:                 }
83541:             }
83586:         }
84009:         mOwnActivityDepth++;
83541:         startActivityForResult(intent, AWESOMEBAR_REQUEST);
83541:         return true;
83541:     }
83541: 
83485:     public boolean doReload() {
83868:         Log.i(LOGTAG, "Reload requested");
83541:         Tab tab = Tabs.getInstance().getSelectedTab();
83610:         if (tab == null)
83610:             return false;
83610: 
83541:         return tab.doReload();
83485:     }
83485: 
83676:     public boolean doForward() {
83868:         Log.i(LOGTAG, "Forward requested");
83676:         Tab tab = Tabs.getInstance().getSelectedTab();
83676:         if (tab == null)
83676:             return false;
83676: 
83676:         return tab.doForward();
83676:     }
83676: 
83864:     public boolean doStop() {
83868:         Log.i(LOGTAG, "Stop requested");
83864:         Tab tab = Tabs.getInstance().getSelectedTab();
83864:         if (tab == null)
83864:             return false;
83864: 
83864:         return tab.doStop();
83864:     }
83864: 
83485:     @Override
83485:     public void onBackPressed() {
83810:         if (mDoorHangerPopup.isShowing()) {
83810:             mDoorHangerPopup.dismiss();
83810:             return;
83810:         }
83810: 
83760:         if (mFullScreen) {
83760:             GeckoAppShell.sendEventToGecko(new GeckoEvent("FullScreen:Exit", null));
83760:             return;
83760:         }
83760: 
85042:         Tabs tabs = Tabs.getInstance();
85042:         Tab tab = tabs.getSelectedTab();
85042:         if (tab == null) {
83776:             moveTaskToBack(true);
85042:             return;
83485:         }
85042: 
85042:         if (tab.doBack())
85042:             return;
85042: 
85042:         if (tab.isExternal()) {
85042:             moveTaskToBack(true);
85042:             tabs.closeTab(tab);
85042:             return;
85042:         }
85042: 
85042:         int parentId = tab.getParentId();
85042:         Tab parent = tabs.getTab(parentId);
85042:         if (parent != null) {
85042:             // The back button should always return to the parent (not a sibling).
85042:             tabs.closeTab(tab, parent);
85042:             return;
85042:         }
85042: 
85042:         moveTaskToBack(true);
83485:     }
83485: 
83519:     static int kCaptureIndex = 0;
83519: 
83485:     @Override
56159:     protected void onActivityResult(int requestCode, int resultCode,
56159:                                     Intent data) {
83485:         super.onActivityResult(requestCode, resultCode, data);
83485:         switch (requestCode) {
83485:         case FILE_PICKER_REQUEST:
56159:             String filePickerResult = "";
56159:             if (data != null && resultCode == RESULT_OK) {
56159:                 try {
56159:                     ContentResolver cr = getContentResolver();
56159:                     Uri uri = data.getData();
71133:                     Cursor cursor = GeckoApp.mAppContext.getContentResolver().query(
71133:                         uri, 
71133:                         new String[] { OpenableColumns.DISPLAY_NAME },
71133:                         null, 
71133:                         null, 
71133:                         null);
71133:                     String name = null;
71133:                     if (cursor != null) {
71133:                         try {
71133:                             if (cursor.moveToNext()) {
71133:                                 name = cursor.getString(0);
71133:                             }
71133:                         } finally {
71133:                             cursor.close();
71133:                         }
71133:                     }
71133:                     String fileName = "tmp_";
71133:                     String fileExt = null;
71133:                     int period;
71133:                     if (name == null || (period = name.lastIndexOf('.')) == -1) {
56159:                         String mimeType = cr.getType(uri);
71133:                         fileExt = "." + GeckoAppShell.getExtensionFromMimeType(mimeType);
71133:                     } else {
71133:                         fileExt = name.substring(period);
71133:                         fileName = name.substring(0, period);
71133:                     }
71133:                     File file = File.createTempFile(fileName, fileExt, sGREDir);
56159: 
56159:                     FileOutputStream fos = new FileOutputStream(file);
56159:                     InputStream is = cr.openInputStream(uri);
56159:                     byte[] buf = new byte[4096];
56159:                     int len = is.read(buf);
56159:                     while (len != -1) {
56159:                         fos.write(buf, 0, len);
56159:                         len = is.read(buf);
56159:                     }
56159:                     fos.close();
56159:                     filePickerResult =  file.getAbsolutePath();
56159:                 }catch (Exception e) {
83868:                     Log.e(LOGTAG, "showing file picker", e);
56159:                 }
56159:             }
56159:             try {
56159:                 mFilePickerResult.put(filePickerResult);
56159:             } catch (InterruptedException e) {
83868:                 Log.i(LOGTAG, "error returning file picker result", e);
56159:             }
83485:             break;
83485:         case AWESOMEBAR_REQUEST:
83485:             if (data != null) {
83485:                 String url = data.getStringExtra(AwesomeBar.URL_KEY);
83551:                 AwesomeBar.Type type = AwesomeBar.Type.valueOf(data.getStringExtra(AwesomeBar.TYPE_KEY));
84211:                 String searchEngine = data.getStringExtra(AwesomeBar.SEARCH_KEY);
84791:                 if (url != null && url.length() > 0)
84211:                     loadRequest(url, type, searchEngine);
56159:             }
83485:             break;
83519:         case CAMERA_CAPTURE_REQUEST:
83868:             Log.i(LOGTAG, "Returning from CAMERA_CAPTURE_REQUEST: " + resultCode);
83519:             File file = new File(Environment.getExternalStorageDirectory(), "cameraCapture-" + Integer.toString(kCaptureIndex) + ".jpg");
83519:             kCaptureIndex++;
83519:             GeckoEvent e = new GeckoEvent("cameraCaptureDone", resultCode == Activity.RESULT_OK ?
83519:                                           "{\"ok\": true,  \"path\": \"" + file.getPath() + "\" }" :
83519:                                           "{\"ok\": false, \"path\": \"" + file.getPath() + "\" }");
83519:             GeckoAppShell.sendEventToGecko(e);
83519:             break;
83485:        }
83485:     }
83485: 
83519:     public void doCameraCapture() {
83519:         File file = new File(Environment.getExternalStorageDirectory(), "cameraCapture-" + Integer.toString(kCaptureIndex) + ".jpg");
83519: 
83519:         Intent intent = new Intent(android.provider.MediaStore.ACTION_IMAGE_CAPTURE);
83519:         intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(file));
83519: 
83519:         startActivityForResult(intent, CAMERA_CAPTURE_REQUEST);
83519:     }
83519: 
84211:     // If searchEngine is provided, url will be used as the search query.
84211:     // Otherwise, the url is loaded.
84211:     private void loadRequest(String url, AwesomeBar.Type type, String searchEngine) {
83559:         mBrowserToolbar.setTitle(url);
83868:         Log.d(LOGTAG, type.name());
84211:         JSONObject args = new JSONObject();
84211:         try {
84211:             args.put("url", url);
84211:             args.put("engine", searchEngine);
84211:         } catch (Exception e) {
84211:             Log.e(LOGTAG, "error building JSON arguments");
84211:         }
83541:         if (type == AwesomeBar.Type.ADD) {
84211:             GeckoAppShell.sendEventToGecko(new GeckoEvent("Tab:Add", args.toString()));
83541:         } else {
84211:             GeckoAppShell.sendEventToGecko(new GeckoEvent("Tab:Load", args.toString()));
83541:         }
83485:     }
83777: 
84211:     public void loadUrl(String url, AwesomeBar.Type type) {
84211:         loadRequest(url, type, null);
84211:     }
84211: 
85042:     /**
86518:      * Open the url as a new tab, and mark the selected tab as its "parent".
86518:      * If the url is already open in a tab, the existing tab is selected.
85042:      * Use this for tabs opened by the browser chrome, so users can press the
85042:      * "Back" button to return to the previous tab.
85042:      */
86518:     public void loadUrlInTab(String url) {
86518:         ArrayList<Tab> tabs = Tabs.getInstance().getTabsInOrder();
86518:         if (tabs != null) {
86518:             Iterator<Tab> tabsIter = tabs.iterator();
86518:             while (tabsIter.hasNext()) {
86518:                 Tab tab = tabsIter.next();
86518:                 if (url.equals(tab.getURL())) {
86518:                     GeckoAppShell.sendEventToGecko(new GeckoEvent("Tab:Select", String.valueOf(tab.getId())));
86518:                     return;
86518:                 }
86518:             }
86518:         }
86518: 
85042:         JSONObject args = new JSONObject();
85042:         try {
85042:             args.put("url", url);
85042:             args.put("parentId", Tabs.getInstance().getSelectedTabId());
85042:         } catch (Exception e) {
85042:             Log.e(LOGTAG, "error building JSON arguments");
85042:         }
85042:         GeckoAppShell.sendEventToGecko(new GeckoEvent("Tab:Add", args.toString()));
85042:     }
85042: 
83777:     public GeckoSoftwareLayerClient getSoftwareLayerClient() { return mSoftwareLayerClient; }
83777:     public LayerController getLayerController() { return mLayerController; }
83777: 
83777:     // accelerometer
83777:     public void onAccuracyChanged(Sensor sensor, int accuracy)
83777:     {
83485:     }
83777: 
83777:     public void onSensorChanged(SensorEvent event)
83777:     {
83777:         Log.w(LOGTAG, "onSensorChanged "+event);
83777:         GeckoAppShell.sendEventToGecko(new GeckoEvent(event));
83777:     }
83777: 
83784:     private class GeocoderRunnable implements Runnable {
83784:         Location mLocation;
83784:         GeocoderRunnable (Location location) {
83784:             mLocation = location;
83784:         }
83784:         public void run() {
83777:             try {
83784:                 List<Address> addresses = mGeocoder.getFromLocation(mLocation.getLatitude(),
83784:                                                                     mLocation.getLongitude(), 1);
83777:                 // grab the first address.  in the future,
83777:                 // may want to expose multiple, or filter
83777:                 // for best.
83777:                 mLastGeoAddress = addresses.get(0);
83784:                 GeckoAppShell.sendEventToGecko(new GeckoEvent(mLocation, mLastGeoAddress));
83777:             } catch (Exception e) {
83777:                 Log.w(LOGTAG, "GeocoderTask "+e);
83777:             }
83777:         }
83777:     }
83777: 
83777:     // geolocation
83777:     public void onLocationChanged(Location location)
83777:     {
83777:         Log.w(LOGTAG, "onLocationChanged "+location);
83777:         if (mGeocoder == null)
83777:             mGeocoder = new Geocoder(mLayerController.getView().getContext(), Locale.getDefault());
83777: 
83777:         if (mLastGeoAddress == null) {
83784:             GeckoAppShell.getHandler().post(new GeocoderRunnable(location));
83777:         }
83777:         else {
83777:             float[] results = new float[1];
83777:             Location.distanceBetween(location.getLatitude(),
83777:                                      location.getLongitude(),
83777:                                      mLastGeoAddress.getLatitude(),
83777:                                      mLastGeoAddress.getLongitude(),
83777:                                      results);
83777:             // pfm value.  don't want to slam the
83777:             // geocoder with very similar values, so
83777:             // only call after about 100m
83777:             if (results[0] > 100)
83784:                 GeckoAppShell.getHandler().post(new GeocoderRunnable(location));
83777:         }
83777: 
83777:         GeckoAppShell.sendEventToGecko(new GeckoEvent(location, mLastGeoAddress));
83777:     }
83777: 
83777:     public void onProviderDisabled(String provider)
83777:     {
83777:     }
83777: 
83777:     public void onProviderEnabled(String provider)
83777:     {
83777:     }
83777: 
83777:     public void onStatusChanged(String provider, int status, Bundle extras)
83777:     {
83777:     }
83777: 
83800: 
83800:     private void connectGeckoLayerClient() {
84423:         if (mPlaceholderLayerClient != null)
83878:             mPlaceholderLayerClient.destroy();
83878: 
83777:         LayerController layerController = getLayerController();
83777:         layerController.setLayerClient(mSoftwareLayerClient);
83777:     }
83817: 
83937: }
83933: 
83937: class PluginLayoutParams extends AbsoluteLayout.LayoutParams
83817: {
83848:     private static final int MAX_DIMENSION = 2048;
83937:     private static final String LOGTAG = "GeckoApp.PluginLayoutParams";
83848: 
83937:     private int mOriginalX;
83937:     private int mOriginalY;
83937:     private int mOriginalWidth;
83937:     private int mOriginalHeight;
87659:     private ViewportMetrics mOriginalViewport;
83937:     private float mLastResolution;
83937: 
87659:     public PluginLayoutParams(int aX, int aY, int aWidth, int aHeight, ViewportMetrics aViewport) {
83848:         super(aWidth, aHeight, aX, aY);
83817: 
87659:         Log.i(LOGTAG, "Creating plugin at " + aX + ", " + aY + ", " + aWidth + "x" + aHeight + ", (" + (aViewport.getZoomFactor() * 100) + "%)");
83937: 
83937:         mOriginalX = aX;
83937:         mOriginalY = aY;
83937:         mOriginalWidth = aWidth;
83937:         mOriginalHeight = aHeight;
87659:         mOriginalViewport = aViewport;
87659:         mLastResolution = aViewport.getZoomFactor();
83937: 
83937:         clampToMaxSize();
83777:     }
83817: 
83937:     private void clampToMaxSize() {
83848:         if (width > MAX_DIMENSION || height > MAX_DIMENSION) {
83848:             if (width > height) {
83848:                 height = (int)(((float)height/(float)width) * MAX_DIMENSION);
83848:                 width = MAX_DIMENSION;
83848:             } else {
83848:                 width = (int)(((float)width/(float)height) * MAX_DIMENSION);
83848:                 height = MAX_DIMENSION;
83817:             }
83817:         }
83848:     }
83937: 
87659:     public void reset(int aX, int aY, int aWidth, int aHeight, ViewportMetrics aViewport) {
87659:         x = mOriginalX = aX;
87659:         y = mOriginalY = aY;
87659:         width = mOriginalWidth = aWidth;
87659:         height = mOriginalHeight = aHeight;
87659:         mOriginalViewport = aViewport;
87659:         mLastResolution = aViewport.getZoomFactor();
83937: 
83937:         clampToMaxSize();
83848:     }
83937: 
83937:     private void reposition(Point aOffset, float aResolution) {
83937:         x = mOriginalX + aOffset.x;
83937:         y = mOriginalY + aOffset.y;
83937: 
83937:         if (!FloatUtils.fuzzyEquals(mLastResolution, aResolution)) {
87659:             width = Math.round(aResolution * mOriginalWidth);
87659:             height = Math.round(aResolution * mOriginalHeight);
83937:             mLastResolution = aResolution;
83937: 
83937:             clampToMaxSize();
83848:         }
83848:     }
83937: 
87659:     public void reposition(ViewportMetrics viewport) {
87659:         PointF targetOrigin = viewport.getDisplayportOrigin();
87659:         PointF originalOrigin = mOriginalViewport.getDisplayportOrigin();
83937: 
87659:         Point offset = new Point(Math.round(originalOrigin.x - targetOrigin.x),
87659:                                  Math.round(originalOrigin.y - targetOrigin.y));
83937: 
87659:         reposition(offset, viewport.getZoomFactor());
83937:     }
83937: }
