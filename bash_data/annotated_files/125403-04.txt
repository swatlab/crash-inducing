113445: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
113445:  * vim: set ts=4 sw=4 et tw=99:
111655:  *
113445:  * This Source Code Form is subject to the terms of the Mozilla Public
113445:  * License, v. 2.0. If a copy of the MPL was not distributed with this
113445:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
111655: 
111655: #ifndef jsion_mir_h__
111655: #define jsion_mir_h__
111655: 
111706: // This file declares everything needed to build actual MIR instructions: the
111706: // actual opcodes and instructions themselves, the instruction interface, and
111706: // use chains.
111655: #include "jscntxt.h"
112080: #include "jslibmath.h"
112247: #include "jsinfer.h"
112247: #include "jsinferinlines.h"
111685: #include "TypeOracle.h"
111800: #include "TypePolicy.h"
111677: #include "IonAllocPolicy.h"
111673: #include "InlineList.h"
111706: #include "MOpcodes.h"
111706: #include "FixedArityList.h"
112017: #include "IonMacroAssembler.h"
112118: #include "Bailouts.h"
112972: #include "FixedList.h"
113053: #include "CompilerRoot.h"
111655: 
111655: namespace js {
111655: namespace ion {
123949: 
112822: class ValueNumberData;
123949: class Range;
123949: 
111655: static const inline
111655: MIRType MIRTypeFromValue(const js::Value &vp)
111655: {
111655:     if (vp.isDouble())
111655:         return MIRType_Double;
112108:     return MIRTypeFromValueType(vp.extractNonDoubleType());
111655: }
111655: 
111838: #define MIR_FLAG_LIST(_)                                                        \
111838:     _(InWorklist)                                                               \
111838:     _(EmittedAtUses)                                                            \
111889:     _(LoopInvariant)                                                            \
111957:     _(Commutative)                                                              \
112302:     _(Movable)       /* Allow LICM and GVN to move this instruction */          \
112082:     _(Lowered)       /* (Debug only) has a virtual register */                  \
112118:     _(Guard)         /* Not removable if uses == 0 */                           \
125403:     _(Folded)        /* Has constant folded uses not reflected in SSA */        \
112082:                                                                                 \
112082:     /* The instruction has been marked dead for lazy removal from resume
112082:      * points.
112082:      */                                                                         \
113516:     _(Unused)                                                                   \
113516:     _(DOMFunction)   /* Contains or uses a common DOM method function */
111838: 
111795: class MDefinition;
111655: class MInstruction;
111655: class MBasicBlock;
111871: class MNode;
111671: class MUse;
111656: class MIRGraph;
112049: class MResumePoint;
111655: 
116487: static inline bool isOSRLikeValue (MDefinition *def);
116487: 
111871: // Represents a use of a node.
111871: class MUse : public TempObject, public InlineForwardListNode<MUse>
111871: {
111871:     friend class MDefinition;
111871: 
111871:     MNode *node_;           // The node that is using this operand.
124795:     uint32_t index_;        // The index of this operand in its owner.
124795: 
124795:     MUse(MNode *owner, uint32_t index)
111871:       : node_(owner),
111871:         index_(index)
111871:     { }
111871: 
111871:   public:
124795:     static inline MUse *New(MNode *owner, uint32_t index) {
111871:         return new MUse(owner, index);
111871:     }
111871: 
111871:     MNode *node() const {
111871:         return node_;
111871:     }
124795:     uint32_t index() const {
111871:         return index_;
111871:     }
111871: };
111871: 
111871: typedef InlineForwardList<MUse>::iterator MUseIterator;
111871: 
111796: // A node is an entry in the MIR graph. It has two kinds:
111796: //   MInstruction: an instruction which appears in the IR stream.
112049: //   MResumePoint: a list of instructions that correspond to the state of the
111796: //              interpreter stack.
111796: //
111796: // Nodes can hold references to MDefinitions. Each MDefinition has a list of
111796: // nodes holding such a reference (its use chain).
111796: class MNode : public TempObject
111796: {
111799:     friend class MDefinition;
111799: 
111797:   protected:
111797:     MBasicBlock *block_;    // Containing basic block.
111797: 
111796:   public:
111796:     enum Kind {
111796:         Definition,
112049:         ResumePoint
111796:     };
111796: 
111797:     MNode() : block_(NULL)
111797:     { }
111797:     MNode(MBasicBlock *block) : block_(block)
111797:     { }
111797: 
111796:     virtual Kind kind() const = 0;
111796: 
111796:     // Returns the definition at a given operand.
111796:     virtual MDefinition *getOperand(size_t index) const = 0;
111796:     virtual size_t numOperands() const = 0;
111796: 
111796:     bool isDefinition() const {
111796:         return kind() == Definition;
111796:     }
112049:     bool isResumePoint() const {
112049:         return kind() == ResumePoint;
111796:     }
111797:     MBasicBlock *block() const {
111797:         return block_;
111797:     }
111796: 
111800:     // Instructions needing to hook into type analysis should return a
111800:     // TypePolicy.
111800:     virtual TypePolicy *typePolicy() {
111800:         return NULL;
111800:     }
111800: 
111796:     // Replaces an operand, taking care to update use chains. No memory is
111796:     // allocated; the existing data structures are re-linked.
111871:     MUseIterator replaceOperand(MUseIterator use, MDefinition *ins);
111796:     void replaceOperand(size_t index, MDefinition *ins);
111796: 
111796:     inline MDefinition *toDefinition();
112049:     inline MResumePoint *toResumePoint();
111796: 
111796:   protected:
111796:     // Sets a raw operand, ignoring updating use information.
111796:     virtual void setOperand(size_t index, MDefinition *operand) = 0;
111797: 
111797:     // Initializes an operand for the first time.
111797:     inline void initOperand(size_t index, MDefinition *ins);
111796: };
111796: 
112302: class AliasSet {
112302:   private:
124795:     uint32_t flags_;
112302: 
112302:   public:
112302:     enum Flag {
112302:         None_             = 0,
112302:         ObjectFields      = 1 << 0, // shape, class, slots, length etc.
112302:         Element           = 1 << 1, // A member of obj->elements.
112302:         Slot              = 1 << 2, // A member of obj->slots.
112904:         TypedArrayElement = 1 << 3, // A typed array element.
112904:         Last              = TypedArrayElement,
112302:         Any               = Last | (Last - 1),
112302: 
112302:         // Indicates load or store.
112302:         Store_            = 1 << 31
112302:     };
124795:     AliasSet(uint32_t flags)
112302:       : flags_(flags)
112302:     { }
112302: 
112302:   public:
112302:     inline bool isNone() const {
112302:         return flags_ == None_;
112302:     }
124795:     uint32_t flags() const {
112302:         return flags_ & Any;
112302:     }
112302:     inline bool isStore() const {
112302:         return !!(flags_ & Store_);
112302:     }
112302:     inline bool isLoad() const {
112302:         return !isStore() && !isNone();
112302:     }
112302:     inline AliasSet operator |(const AliasSet &other) const {
112302:         return AliasSet(flags_ | other.flags_);
112302:     }
112302:     inline AliasSet operator &(const AliasSet &other) const {
112302:         return AliasSet(flags_ & other.flags_);
112302:     }
112302:     static AliasSet None() {
112302:         return AliasSet(None_);
112302:     }
124795:     static AliasSet Load(uint32_t flags) {
112302:         JS_ASSERT(flags && !(flags & Store_));
112302:         return AliasSet(flags);
112302:     }
124795:     static AliasSet Store(uint32_t flags) {
112302:         JS_ASSERT(flags && !(flags & Store_));
112302:         return AliasSet(flags | Store_);
112302:     }
112302: };
112302: 
112302: static const unsigned NUM_ALIAS_SETS = sizeof(AliasSet) * 8;
112302: 
111795: // An MDefinition is an SSA name.
111796: class MDefinition : public MNode
111655: {
111655:     friend class MBasicBlock;
111744:     friend class Loop;
111655: 
111655:   public:
111655:     enum Opcode {
111655: #   define DEFINE_OPCODES(op) Op_##op,
111655:         MIR_OPCODE_LIST(DEFINE_OPCODES)
111655: #   undef DEFINE_OPCODES
111655:         Op_Invalid
111655:     };
111655: 
111655:   private:
111871:     InlineForwardList<MUse> uses_; // Use chain.
124795:     uint32_t id_;                    // Instruction ID, which after block re-ordering
111796:                                    // is sorted within a basic block.
112822:     ValueNumberData *valueNumber_; // The instruction's value number (see GVN for details in use)
123949:     Range *range_;                 // Any computed range for this def.
112042:     MIRType resultType_;           // Representation of result type.
124795:     uint32_t flags_;                 // Bit flags.
112933:     union {
112302:         MDefinition *dependency_;  // Implicit dependency (store, call, etc.) of this instruction.
112933:                                    // Used by alias analysis, GVN and LICM.
124795:         uint32_t virtualRegister_;   // Used by lowering to map definitions to virtual registers.
112933:     };
111671: 
113587:     // Track bailouts by storing the current pc in MIR instruction. Also used
113587:     // for profiling and keeping track of what the last known pc was.
113587:     jsbytecode *trackedPc_;
113587: 
111655:   private:
111838:     enum Flag {
111838:         None = 0,
111838: #   define DEFINE_FLAG(flag) flag,
111838:         MIR_FLAG_LIST(DEFINE_FLAG)
111838: #   undef DEFINE_FLAG
111843:         Total
111838:     };
111714: 
111655:     void setBlock(MBasicBlock *block) {
111655:         block_ = block;
111655:     }
111655: 
124795:     bool hasFlags(uint32_t flags) const {
111714:         return (flags_ & flags) == flags;
111714:     }
124795:     void removeFlags(uint32_t flags) {
111714:         flags_ &= ~flags;
111714:     }
124795:     void setFlags(uint32_t flags) {
111714:         flags_ |= flags;
111714:     }
125215:     virtual bool neverHoist() const { return false; }
111655:   public:
111795:     MDefinition()
111871:       : id_(0),
112822:         valueNumber_(NULL),
113361:         range_(),
111673:         resultType_(MIRType_None),
112302:         flags_(0),
113587:         dependency_(NULL),
113587:         trackedPc_(NULL)
111655:     { }
111655: 
111655:     virtual Opcode op() const = 0;
111657:     void printName(FILE *fp);
112455:     static void PrintOpcodeName(FILE *fp, Opcode op);
111674:     virtual void printOpcode(FILE *fp);
111655: 
113587:     void setTrackedPc(jsbytecode *pc) {
113587:         trackedPc_ = pc;
113587:     }
113587: 
113587:     jsbytecode *trackedPc() {
113587:         return trackedPc_;
113587:     }
113587: 
123949:     Range *range() const {
123949:         return range_;
123949:     }
123949:     void setRange(Range *range) {
123949:         range_ = range;
113361:     }
113361: 
111756:     virtual HashNumber valueHash() const;
112474:     virtual bool congruentTo(MDefinition* const &ins) const {
112474:         return false;
112474:     }
112474:     bool congruentIfOperandsEqual(MDefinition * const &ins) const;
111957:     virtual MDefinition *foldsTo(bool useValueNumbers);
113359:     virtual void analyzeEdgeCasesForward();
113359:     virtual void analyzeEdgeCasesBackward();
112987:     virtual void analyzeTruncateBackward();
116489:     bool earlyAbortCheck();
123949: 
123949:     // Compute an absolute or symbolic range for the value of this node.
123949:     // Ranges are only computed for definitions whose type is int32.
123949:     virtual void computeRange() {
113361:     }
113361: 
111796:     MNode::Kind kind() const {
111796:         return MNode::Definition;
111796:     }
111796: 
124795:     uint32_t id() const {
111664:         JS_ASSERT(block_);
111657:         return id_;
111657:     }
124795:     void setId(uint32_t id) {
111659:         id_ = id;
111659:     }
111756: 
124795:     uint32_t valueNumber() const;
124795:     void setValueNumber(uint32_t vn);
112822:     ValueNumberData *valueNumberData() {
111756:         return valueNumber_;
111756:     }
112822:     void setValueNumberData(ValueNumberData *vn) {
112822:         JS_ASSERT(valueNumber_ == NULL);
111756:         valueNumber_ = vn;
111756:     }
111838: #define FLAG_ACCESSOR(flag) \
111838:     bool is##flag() const {\
111838:         return hasFlags(1 << flag);\
111838:     }\
111838:     void set##flag() {\
111838:         JS_ASSERT(!hasFlags(1 << flag));\
111838:         setFlags(1 << flag);\
111838:     }\
111838:     void setNot##flag() {\
111838:         JS_ASSERT(hasFlags(1 << flag));\
111838:         removeFlags(1 << flag);\
111838:     }\
111838:     void set##flag##Unchecked() {\
111838:         setFlags(1 << flag);\
111671:     }
111655: 
111838:     MIR_FLAG_LIST(FLAG_ACCESSOR)
111838: #undef FLAG_ACCESSOR
111744: 
111673:     MIRType type() const {
111673:         return resultType_;
111673:     }
111673: 
111871:     // Returns the beginning of this definition's use chain.
111871:     MUseIterator usesBegin() const {
111871:         return uses_.begin();
111655:     }
111673: 
111871:     // Returns the end of this definition's use chain.
111871:     MUseIterator usesEnd() const {
111871:         return uses_.end();
111871:     }
111871: 
112219:     bool canEmitAtUses() const {
112219:         return !isEmittedAtUses();
112219:     }
112219: 
111871:     // Removes a use at the given position
111871:     MUseIterator removeUse(MUseIterator use);
111655: 
111657:     // Number of uses of this instruction.
111657:     size_t useCount() const;
111657: 
111957:     bool hasUses() const {
111957:         return !uses_.empty();
111957:     }
111957: 
112302:     virtual bool isControlInstruction() const {
111753:         return false;
111753:     }
111753: 
111797:     void addUse(MNode *node, size_t index) {
111871:         uses_.pushFront(MUse::New(node, index));
111671:     }
111799:     void replaceAllUsesWith(MDefinition *dom);
111673: 
112488:     // Mark this instruction as having replaced all uses of ins, as during GVN,
112488:     // returning false if the replacement should not be performed. For use when
112488:     // GVN eliminates instructions which are not equivalent to one another.
112488:     virtual bool updateForReplacement(MDefinition *ins) {
112488:         return true;
112488:     }
112488: 
112987:     // Same thing, but for folding
112987:     virtual bool updateForFolding(MDefinition *ins) {
112987:         return true;
112987:     }
112987: 
111673:     // Adds a use from a node that is being recycled during operand
111673:     // replacement.
111797:     void linkUse(MUse *use) {
111796:         JS_ASSERT(use->node()->getOperand(use->index()) == this);
111871:         uses_.pushFront(use);
111671:     }
111655: 
124795:     void setVirtualRegister(uint32_t vreg) {
112933:         virtualRegister_ = vreg;
112032: #ifdef DEBUG
112032:         setLoweredUnchecked();
112032: #endif
112032:     }
124795:     uint32_t virtualRegister() const {
112032:         JS_ASSERT(isLowered());
112933:         return virtualRegister_;
112032:     }
112032: 
111673:   public:
111655:     // Opcode testing and casts.
111655: #   define OPCODE_CASTS(opcode)                                             \
111655:     bool is##opcode() const {                                               \
111655:         return op() == Op_##opcode;                                         \
111655:     }                                                                       \
111655:     inline M##opcode *to##opcode();
111655:     MIR_OPCODE_LIST(OPCODE_CASTS)
111655: #   undef OPCODE_CASTS
111655: 
111795:     inline MInstruction *toInstruction();
111795:     bool isInstruction() const {
111828:         return !isPhi();
111795:     }
111673: 
111673:     void setResultType(MIRType type) {
111673:         resultType_ = type;
111673:     }
112302: 
112302:     MDefinition *dependency() const {
112302:         return dependency_;
112302:     }
112302:     void setDependency(MDefinition *dependency) {
112302:         dependency_ = dependency;
112302:     }
112302:     virtual AliasSet getAliasSet() const {
112302:         // Instructions are effectful by default.
112302:         return AliasSet::Store(AliasSet::Any);
112302:     }
112302:     bool isEffectful() const {
112302:         return getAliasSet().isStore();
112302:     }
111655: };
111655: 
111807: // An MUseDefIterator walks over uses in a definition, skipping any use that is
111799: // not a definition. Items from the use list must not be deleted during
111799: // iteration.
111799: class MUseDefIterator
111799: {
111871:     MDefinition *def_;
111871:     MUseIterator current_;
111799: 
111871:     MUseIterator search(MUseIterator start) {
111871:         MUseIterator i(start);
111871:         for (; i != def_->usesEnd(); i++) {
111871:             if (i->node()->isDefinition())
111871:                 return i;
111799:         }
111871:         return def_->usesEnd();
111799:     }
111799: 
111799:   public:
111799:     MUseDefIterator(MDefinition *def)
111871:       : def_(def),
111871:         current_(search(def->usesBegin()))
111799:     {
111799:     }
111799: 
111799:     operator bool() const {
111871:         return current_ != def_->usesEnd();
111799:     }
111799:     MUseDefIterator operator ++(int) {
111799:         MUseDefIterator old(*this);
111928:         if (current_ != def_->usesEnd())
111928:             current_++;
111871:         current_ = search(current_);
111799:         return old;
111799:     }
111799:     MUse *use() const {
111871:         return *current_;
111799:     }
111799:     MDefinition *def() const {
111799:         return current_->node()->toDefinition();
111799:     }
111799:     size_t index() const {
111799:         return current_->index();
111799:     }
111799: };
111799: 
111795: // An instruction is an SSA name that is inserted into a basic block's IR
111795: // stream.
111795: class MInstruction
111795:   : public MDefinition,
111795:     public InlineListNode<MInstruction>
111795: {
112049:     MResumePoint *resumePoint_;
111797: 
111795:   public:
112455:     MInstruction()
112455:       : resumePoint_(NULL)
111797:     { }
111797: 
111795:     virtual bool accept(MInstructionVisitor *visitor) = 0;
111797: 
112049:     void setResumePoint(MResumePoint *resumePoint) {
112049:         JS_ASSERT(!resumePoint_);
112049:         resumePoint_ = resumePoint;
111797:     }
112049:     MResumePoint *resumePoint() const {
112049:         return resumePoint_;
111797:     }
111795: };
111795: 
111673: #define INSTRUCTION_HEADER(opcode)                                          \
111673:     Opcode op() const {                                                     \
111795:         return MDefinition::Op_##opcode;                                    \
111673:     }                                                                       \
111673:     bool accept(MInstructionVisitor *visitor) {                             \
111706:         return visitor->visit##opcode(this);                                \
111673:     }
111673: 
111655: template <size_t Arity>
111655: class MAryInstruction : public MInstruction
111655: {
111655:   protected:
111795:     FixedArityList<MDefinition*, Arity> operands_;
111655: 
111795:     void setOperand(size_t index, MDefinition *operand) {
111655:         operands_[index] = operand;
111655:     }
111655: 
111655:   public:
111795:     MDefinition *getOperand(size_t index) const {
111671:         return operands_[index];
111655:     }
111662:     size_t numOperands() const {
111662:         return Arity;
111662:     }
111655: };
111655: 
112541: class MNullaryInstruction : public MAryInstruction<0>
112541: { };
112541: 
112219: // Generates an LSnapshot without further effect.
112541: class MStart : public MNullaryInstruction
111715: {
111715:   public:
112219:     enum StartType {
112219:         StartType_Default,
112219:         StartType_Osr
112219:     };
112219: 
112219:   private:
112219:     StartType startType_;
112219: 
112219:   private:
112219:     MStart(StartType startType)
112219:       : startType_(startType)
112219:     { }
112219: 
112219:   public:
125300:     INSTRUCTION_HEADER(Start)
112219:     static MStart *New(StartType startType) {
112219:         return new MStart(startType);
112219:     }
112219: 
112219:     StartType startType() {
112219:         return startType_;
112219:     }
112219: };
112219: 
112219: // Instruction marking on entrypoint for on-stack replacement.
112219: // OSR may occur at loop headers (at JSOP_TRACE).
112219: // There is at most one MOsrEntry per MIRGraph.
112541: class MOsrEntry : public MNullaryInstruction
112219: {
112219:   protected:
112219:     MOsrEntry() {
112219:         setResultType(MIRType_StackFrame);
112219:     }
112219: 
112219:   public:
125300:     INSTRUCTION_HEADER(OsrEntry)
112219:     static MOsrEntry *New() {
112219:         return new MOsrEntry;
111715:     }
111715: };
111715: 
124557: // No-op instruction. This cannot be moved or eliminated, and is intended for
124557: // anchoring resume points at arbitrary points in a block.
124557: class MNop : public MNullaryInstruction
124557: {
124557:   protected:
124557:     MNop() {
124557:     }
124557: 
124557:   public:
125300:     INSTRUCTION_HEADER(Nop)
124557:     static MNop *New() {
124557:         return new MNop();
124557:     }
124557: 
124557:     AliasSet getAliasSet() const {
124557:         return AliasSet::None();
124557:     }
124557: };
124557: 
111715: // A constant js::Value.
112541: class MConstant : public MNullaryInstruction
111655: {
113415:     Value value_;
113199: 
113199:   protected:
111655:     MConstant(const Value &v);
111655: 
111655:   public:
125300:     INSTRUCTION_HEADER(Constant)
111677:     static MConstant *New(const Value &v);
111655: 
111655:     const js::Value &value() const {
111655:         return value_;
111655:     }
111706:     const js::Value *vp() const {
111706:         return &value_;
111706:     }
111889: 
111674:     void printOpcode(FILE *fp);
111756: 
111756:     HashNumber valueHash() const;
111795:     bool congruentTo(MDefinition * const &ins) const;
112302: 
112474:     AliasSet getAliasSet() const {
112302:         return AliasSet::None();
112302:     }
123949: 
123949:     void computeRange();
111655: };
111655: 
112541: class MParameter : public MNullaryInstruction
111655: {
124795:     int32_t index_;
124001:     const types::TypeSet *typeSet_;
111655: 
111655:   public:
124795:     static const int32_t THIS_SLOT = -1;
124795: 
124795:     MParameter(int32_t index, const types::TypeSet *types)
112132:       : index_(index),
112132:         typeSet_(types)
111655:     {
111673:         setResultType(MIRType_Value);
111655:     }
111655: 
111655:   public:
125300:     INSTRUCTION_HEADER(Parameter)
124795:     static MParameter *New(int32_t index, const types::TypeSet *types);
124795: 
124795:     int32_t index() const {
111655:         return index_;
111655:     }
124001:     const types::TypeSet *typeSet() const {
112132:         return typeSet_;
112132:     }
111675:     void printOpcode(FILE *fp);
111756: 
111756:     HashNumber valueHash() const;
111795:     bool congruentTo(MDefinition * const &ins) const;
111655: };
111655: 
112541: class MCallee : public MNullaryInstruction
112401: {
112401:   public:
112401:     MCallee()
112401:     {
112401:         setResultType(MIRType_Object);
112401:     }
112401: 
112401:   public:
125300:     INSTRUCTION_HEADER(Callee)
112690: 
112690:     bool congruentTo(MDefinition * const &ins) const {
112690:         return congruentIfOperandsEqual(ins);
112690:     }
112690: 
112401:     static MCallee *New() {
112401:         return new MCallee();
112401:     }
112690:     AliasSet getAliasSet() const {
112690:         return AliasSet::None();
112690:     }
112401: };
112401: 
111655: class MControlInstruction : public MInstruction
111655: {
111929:   public:
111929:     MControlInstruction()
111929:     { }
111929: 
111929:     virtual size_t numSuccessors() const = 0;
111929:     virtual MBasicBlock *getSuccessor(size_t i) const = 0;
111929:     virtual void replaceSuccessor(size_t i, MBasicBlock *successor) = 0;
112302: 
112302:     bool isControlInstruction() const {
112302:         return true;
112302:     }
111929: };
111929: 
111929: class MTableSwitch
119480:   : public MControlInstruction
111929: {
112843:     // The successors of the tableswitch
112843:     // - First successor = the default case
112843:     // - Successor 2 and higher = the cases sorted on case index.
111929:     Vector<MBasicBlock*, 0, IonAllocPolicy> successors_;
112029: 
112843:     // Contains the blocks/cases that still need to get build
112843:     Vector<MBasicBlock*, 0, IonAllocPolicy> blocks_;
112029: 
111929:     MDefinition *operand_;
124795:     int32_t low_;
124795:     int32_t high_;
124795: 
124795:     MTableSwitch(MDefinition *ins, int32_t low, int32_t high)
111929:       : successors_(),
112843:         blocks_(),
111929:         low_(low),
112843:         high_(high)
111929:     {
111929:         initOperand(0, ins);
111929:     }
111929: 
111655:   protected:
111929:     void setOperand(size_t index, MDefinition *operand) {
111929:         JS_ASSERT(index == 0);
111929:         operand_ = operand;
111929:     }
111655: 
111655:   public:
125300:     INSTRUCTION_HEADER(TableSwitch)
111929:     static MTableSwitch *New(MDefinition *ins,
124795:                              int32_t low, int32_t high);
111655: 
111929:     size_t numSuccessors() const {
111929:         return successors_.length();
111655:     }
111655: 
111929:     MBasicBlock *getSuccessor(size_t i) const {
111655:         JS_ASSERT(i < numSuccessors());
111929:         return successors_[i];
111655:     }
111749: 
112127:     void replaceSuccessor(size_t i, MBasicBlock *successor) {
112127:         JS_ASSERT(i < numSuccessors());
112127:         successors_[i] = successor;
112127:     }
112127: 
112843:     MBasicBlock** blocks() {
112843:         return &blocks_[0];
112843:     }
112843: 
112843:     size_t numBlocks() const {
112843:         return blocks_.length();
112127:     }
112127: 
124795:     int32_t low() const {
111929:         return low_;
111929:     }
111929: 
124795:     int32_t high() const {
111929:         return high_;
111929:     }
111929: 
111929:     MBasicBlock *getDefault() const {
112843:         return getSuccessor(0);
111929:     }
111929: 
112306:     MBasicBlock *getCase(size_t i) const {
112843:         return getSuccessor(i+1);
111929:     }
111929: 
111929:     size_t numCases() const {
111929:         return high() - low() + 1;
111929:     }
111929: 
111929:     void addDefault(MBasicBlock *block) {
112843:         JS_ASSERT(successors_.length() == 0);
111929:         successors_.append(block);
111929:     }
111929: 
112843:     void addCase(MBasicBlock *block) {
112843:         JS_ASSERT(successors_.length() < (size_t)(high_ - low_ + 2));
112843:         JS_ASSERT(successors_.length() != 0);
111929:         successors_.append(block);
111929:     }
112843: 
112843:     MBasicBlock *getBlock(size_t i) const {
112843:         JS_ASSERT(i < numBlocks());
112843:         return blocks_[i];
112843:     }
112843: 
112843:     void addBlock(MBasicBlock *block) {
112843:         blocks_.append(block);
112665:     }
111929: 
111929:     MDefinition *getOperand(size_t index) const {
111929:         JS_ASSERT(index == 0);
111929:         return operand_;
111929:     }
111929: 
111929:     size_t numOperands() const {
111929:         return 1;
111929:     }
111655: };
111655: 
112478: template <size_t Arity, size_t Successors>
111655: class MAryControlInstruction : public MControlInstruction
111655: {
111795:     FixedArityList<MDefinition *, Arity> operands_;
112478:     FixedArityList<MBasicBlock *, Successors> successors_;
111655: 
111655:   protected:
111795:     void setOperand(size_t index, MDefinition *operand) {
111655:         operands_[index] = operand;
111655:     }
112478:     void setSuccessor(size_t index, MBasicBlock *successor) {
112478:         successors_[index] = successor;
112478:     }
111655: 
111655:   public:
111795:     MDefinition *getOperand(size_t index) const {
111671:         return operands_[index];
111655:     }
111662:     size_t numOperands() const {
111662:         return Arity;
111662:     }
112478:     size_t numSuccessors() const {
112478:         return Successors;
112478:     }
112478:     MBasicBlock *getSuccessor(size_t i) const {
112478:         return successors_[i];
112478:     }
112478:     void replaceSuccessor(size_t i, MBasicBlock *succ) {
112478:         successors_[i] = succ;
112478:     }
111655: };
111655: 
111715: // Jump to the start of another basic block.
112478: class MGoto : public MAryControlInstruction<0, 1>
111655: {
112478:     MGoto(MBasicBlock *target) {
112478:         setSuccessor(0, target);
111655:     }
111655: 
111655:   public:
125300:     INSTRUCTION_HEADER(Goto)
111677:     static MGoto *New(MBasicBlock *target);
111708: 
111708:     MBasicBlock *target() {
112478:         return getSuccessor(0);
111708:     }
112474:     AliasSet getAliasSet() const {
112302:         return AliasSet::None();
112302:     }
111655: };
111655: 
123949: enum BranchDirection {
123949:     FALSE_BRANCH,
123949:     TRUE_BRANCH
123949: };
123949: 
123949: static inline BranchDirection
123949: NegateBranchDirection(BranchDirection dir)
123949: {
123949:     return (dir == FALSE_BRANCH) ? TRUE_BRANCH : FALSE_BRANCH;
123949: }
123949: 
111715: // Tests if the input instruction evaluates to true or false, and jumps to the
111715: // start of a corresponding basic block.
112714: class MTest
112714:   : public MAryControlInstruction<1, 2>,
112714:     public TestPolicy
111655: {
112478:     MTest(MDefinition *ins, MBasicBlock *if_true, MBasicBlock *if_false) {
111683:         initOperand(0, ins);
112478:         setSuccessor(0, if_true);
112478:         setSuccessor(1, if_false);
111655:     }
111655: 
111655:   public:
125300:     INSTRUCTION_HEADER(Test)
111795:     static MTest *New(MDefinition *ins,
111655:                       MBasicBlock *ifTrue, MBasicBlock *ifFalse);
111655: 
111721:     MBasicBlock *ifTrue() const {
111721:         return getSuccessor(0);
111721:     }
111721:     MBasicBlock *ifFalse() const {
111721:         return getSuccessor(1);
111721:     }
123949:     MBasicBlock *branchSuccessor(BranchDirection dir) const {
123949:         return (dir == TRUE_BRANCH) ? ifTrue() : ifFalse();
123949:     }
112714:     TypePolicy *typePolicy() {
112714:         return this;
112714:     }
112004: 
112474:     AliasSet getAliasSet() const {
112302:         return AliasSet::None();
112004:     }
112851:     MDefinition *foldsTo(bool useValueNumbers);
111655: };
111655: 
111715: // Returns from this function to the previous caller.
111801: class MReturn
112478:   : public MAryControlInstruction<1, 0>,
111801:     public BoxInputsPolicy
111655: {
112478:     MReturn(MDefinition *ins) {
111683:         initOperand(0, ins);
111683:     }
111683: 
111655:   public:
125300:     INSTRUCTION_HEADER(Return)
112478:     static MReturn *New(MDefinition *ins) {
112478:         return new MReturn(ins);
111929:     }
111929: 
111801:     TypePolicy *typePolicy() {
111801:         return this;
111801:     }
112474:     AliasSet getAliasSet() const {
112302:         return AliasSet::None();
112302:     }
111655: };
111655: 
112478: class MThrow
112478:   : public MAryControlInstruction<1, 0>,
112478:     public BoxInputsPolicy
112478: {
112478:     MThrow(MDefinition *ins) {
112478:         initOperand(0, ins);
112478:     }
112478: 
112478:   public:
125300:     INSTRUCTION_HEADER(Throw)
112478:     static MThrow *New(MDefinition *ins) {
112478:         return new MThrow(ins);
112478:     }
112478: 
112478:     TypePolicy *typePolicy() {
112478:         return this;
112478:     }
112478:     virtual AliasSet getAliasSet() const {
112478:         return AliasSet::None();
112478:     }
112478: };
112478: 
112541: class MNewArray : public MNullaryInstruction
112247: {
113529:   public:
113529:     enum AllocatingBehaviour {
113529:         NewArray_Allocating,
113529:         NewArray_Unallocating
113529:     };
113529: 
112981:   private:
112247:     // Number of space to allocate for the array.
124795:     uint32_t count_;
113485:     // Template for the created object.
113494:     CompilerRootObject templateObject_;
113529:     // Allocate space at initialization or not
113529:     AllocatingBehaviour allocating_;
112247: 
112247:   public:
125300:     INSTRUCTION_HEADER(NewArray)
112247: 
124795:     MNewArray(uint32_t count, JSObject *templateObject, AllocatingBehaviour allocating)
113443:       : count_(count),
113529:         templateObject_(templateObject),
113529:         allocating_(allocating)
112247:     {
112247:         setResultType(MIRType_Object);
112247:     }
112247: 
124795:     uint32_t count() const {
112247:         return count_;
112247:     }
112247: 
113485:     JSObject *templateObject() const {
113485:         return templateObject_;
112247:     }
112981: 
113529:     bool isAllocating() const {
113529:         return allocating_ == NewArray_Allocating;
113529:     }
113529: 
113443:     // NewArray is marked as non-effectful because all our allocations are
113443:     // either lazy when we are using "new Array(length)" or bounded by the
113443:     // script or the stack size when we are using "new Array(...)" or "[...]"
113443:     // notations.  So we might have to allocate the array twice if we bail
113443:     // during the computation of the first element of the square braket
113443:     // notation.
113443:     virtual AliasSet getAliasSet() const {
113443:         return AliasSet::None();
113443:     }
112247: };
112247: 
112764: class MNewObject : public MNullaryInstruction
112764: {
113494:     CompilerRootObject templateObject_;
113485: 
113485:     MNewObject(JSObject *templateObject)
113485:       : templateObject_(templateObject)
112764:     {
112764:         setResultType(MIRType_Object);
112764:     }
112764: 
112764:   public:
125300:     INSTRUCTION_HEADER(NewObject)
112764: 
113485:     static MNewObject *New(JSObject *templateObject) {
113485:         return new MNewObject(templateObject);
113485:     }
113485: 
113485:     JSObject *templateObject() const {
113485:         return templateObject_;
112908:     }
112764: };
112764: 
112976: // Slow path for adding a property to an object without a known base.
112976: class MInitProp
112976:   : public MAryInstruction<2>,
112976:     public MixPolicy<ObjectPolicy<0>, BoxPolicy<1> >
112976: {
112976:   public:
113095:     CompilerRootPropertyName name_;
112976: 
112976:   protected:
113095:     MInitProp(MDefinition *obj, HandlePropertyName name, MDefinition *value)
112976:       : name_(name)
112976:     {
112976:         initOperand(0, obj);
112976:         initOperand(1, value);
112976:         setResultType(MIRType_None);
112976:     }
112976: 
112976:   public:
125300:     INSTRUCTION_HEADER(InitProp)
112976: 
113095:     static MInitProp *New(MDefinition *obj, HandlePropertyName name, MDefinition *value) {
112976:         return new MInitProp(obj, name, value);
112976:     }
112976: 
112976:     MDefinition *getObject() const {
112976:         return getOperand(0);
112976:     }
112976:     MDefinition *getValue() const {
112976:         return getOperand(1);
112976:     }
112976: 
112976:     PropertyName *propertyName() const {
112976:         return name_;
112976:     }
113003:     TypePolicy *typePolicy() {
113003:         return this;
113003:     }
112976: };
112976: 
112064: // Designates the start of call frame construction.
112064: // Generates code to adjust the stack pointer for the argument vector.
112064: // Argc is inferred by checking the use chain during lowering.
112541: class MPrepareCall : public MNullaryInstruction
112064: {
112064:   public:
125300:     INSTRUCTION_HEADER(PrepareCall)
112064: 
112064:     MPrepareCall()
112064:     { }
112064: 
112064:     // Get the vector size for the upcoming call by looking at the call.
124795:     uint32_t argc() const;
112302: 
112474:     AliasSet getAliasSet() const {
112302:         return AliasSet::None();
112302:     }
112064: };
112064: 
112064: class MVariadicInstruction : public MInstruction
112064: {
112064:     FixedList<MDefinition *> operands_;
112064: 
112064:   protected:
112064:     bool init(size_t length) {
112064:         return operands_.init(length);
112064:     }
112064: 
112064:   public:
112064:     // Will assert if called before initialization.
112064:     MDefinition *getOperand(size_t index) const {
112064:         return operands_[index];
112064:     }
112064:     size_t numOperands() const {
112064:         return operands_.length();
112064:     }
112064:     void setOperand(size_t index, MDefinition *operand) {
112064:         operands_[index] = operand;
112064:     }
112064: };
112064: 
112064: class MCall
112064:   : public MVariadicInstruction,
112064:     public CallPolicy
112064: {
112064:   private:
112064:     // An MCall uses the MPrepareCall, MDefinition for the function, and
112064:     // MPassArg instructions. They are stored in the same list.
112064:     static const size_t PrepareCallOperandIndex  = 0;
112064:     static const size_t FunctionOperandIndex   = 1;
112064:     static const size_t NumNonArgumentOperands = 2;
112064: 
112064:   protected:
112520:     // True if the call is for JSOP_NEW.
112520:     bool construct_;
112718:     // Monomorphic cache of single target from TI, or NULL.
113053:     CompilerRootFunction target_;
112998:     // Original value of argc from the bytecode.
124795:     uint32_t numActualArgs_;
124795: 
124795:     MCall(JSFunction *target, uint32_t numActualArgs, bool construct)
112718:       : construct_(construct),
113053:         target_(target),
113196:         numActualArgs_(numActualArgs)
112064:     {
112064:         setResultType(MIRType_Value);
112064:     }
112064: 
112064:   public:
125300:     INSTRUCTION_HEADER(Call)
113196:     static MCall *New(JSFunction *target, size_t maxArgc, size_t numActualArgs, bool construct);
112064: 
112064:     void initPrepareCall(MDefinition *start) {
112064:         JS_ASSERT(start->isPrepareCall());
112064:         return initOperand(PrepareCallOperandIndex, start);
112064:     }
112064:     void initFunction(MDefinition *func) {
112064:         JS_ASSERT(!func->isPassArg());
112064:         return initOperand(FunctionOperandIndex, func);
112064:     }
112064: 
112064:     MDefinition *getFunction() const {
112064:         return getOperand(FunctionOperandIndex);
112064:     }
112064:     void replaceFunction(MInstruction *newfunc) {
112064:         replaceOperand(FunctionOperandIndex, newfunc);
112064:     }
112064: 
112064:     void addArg(size_t argnum, MPassArg *arg);
112064: 
124795:     MDefinition *getArg(uint32_t index) const {
112064:         return getOperand(NumNonArgumentOperands + index);
112064:     }
112064: 
112718:     // For TI-informed monomorphic callsites.
112718:     JSFunction *getSingleTarget() const {
112718:         return target_;
112718:     }
112718: 
112874:     bool isConstructing() const {
112520:         return construct_;
112520:     }
112520: 
113196:     // The number of stack arguments is the max between the number of formal
113196:     // arguments and the number of actual arguments. The number of stack
113196:     // argument includes the |undefined| padding added in case of underflow.
112064:     // Includes |this|.
124795:     uint32_t numStackArgs() const {
112064:         return numOperands() - NumNonArgumentOperands;
112064:     }
112064: 
113196:     // Does not include |this|.
124795:     uint32_t numActualArgs() const {
113196:         return numActualArgs_;
112998:     }
112998: 
112064:     TypePolicy *typePolicy() {
112064:         return this;
112064:     }
112474:     AliasSet getAliasSet() const {
112302:         return AliasSet::Store(AliasSet::Any);
112302:     }
112064: };
112064: 
113388: // fun.apply(self, arguments)
113388: class MApplyArgs
113388:   : public MAryInstruction<3>,
113388:     public MixPolicy<ObjectPolicy<0>, MixPolicy<IntPolicy<1>, BoxPolicy<2> > >
113388: {
113388:   protected:
113388:     // Monomorphic cache of single target from TI, or NULL.
113388:     CompilerRootFunction target_;
113388: 
113388:     MApplyArgs(JSFunction *target, MDefinition *fun, MDefinition *argc, MDefinition *self)
113388:       : target_(target)
113388:     {
113388:         initOperand(0, fun);
113388:         initOperand(1, argc);
113388:         initOperand(2, self);
113388:         setResultType(MIRType_Value);
113388:     }
113388: 
113388:   public:
125300:     INSTRUCTION_HEADER(ApplyArgs)
113388:     static MApplyArgs *New(JSFunction *target, MDefinition *fun, MDefinition *argc,
113388:                            MDefinition *self);
113388: 
113388:     MDefinition *getFunction() const {
113388:         return getOperand(0);
113388:     }
113388: 
113388:     // For TI-informed monomorphic callsites.
113388:     JSFunction *getSingleTarget() const {
113388:         return target_;
113388:     }
113388: 
113388:     MDefinition *getArgc() const {
113388:         return getOperand(1);
113388:     }
113388:     MDefinition *getThis() const {
113388:         return getOperand(2);
113388:     }
113388: 
113388:     TypePolicy *typePolicy() {
113388:         return this;
113388:     }
113388: };
113388: 
111655: class MUnaryInstruction : public MAryInstruction<1>
111655: {
111655:   protected:
111795:     MUnaryInstruction(MDefinition *ins)
111655:     {
111683:         initOperand(0, ins);
111655:     }
111655: };
111655: 
111655: class MBinaryInstruction : public MAryInstruction<2>
111655: {
111655:   protected:
111795:     MBinaryInstruction(MDefinition *left, MDefinition *right)
111655:     {
111683:         initOperand(0, left);
111683:         initOperand(1, right);
111655:     }
111957: 
112429:   public:
112429:     MDefinition *lhs() const {
112429:         return getOperand(0);
112429:     }
112429:     MDefinition *rhs() const {
112429:         return getOperand(1);
112429:     }
112429: 
112429:   protected:
111957:     HashNumber valueHash() const
111957:     {
111957:         MDefinition *lhs = getOperand(0);
111957:         MDefinition *rhs = getOperand(1);
111957: 
111957:         return op() ^ lhs->valueNumber() ^ rhs->valueNumber();
111957:     }
112737:     void swapOperands() {
112737:         MDefinition *temp = getOperand(0);
112737:         replaceOperand(0, getOperand(1));
112737:         replaceOperand(1, temp);
112737:     }
111957: 
111957:     bool congruentTo(MDefinition *const &ins) const
111957:     {
111957:         if (op() != ins->op())
111957:             return false;
111957: 
111979:         if (type() != ins->type())
111979:             return false;
111979: 
112471:         if (isEffectful() || ins->isEffectful())
112471:             return false;
112471: 
111957:         MDefinition *left = getOperand(0);
111957:         MDefinition *right = getOperand(1);
111957:         MDefinition *tmp;
111957: 
111957:         if (isCommutative() && left->valueNumber() > right->valueNumber()) {
111957:             tmp = right;
111957:             right = left;
111957:             left = tmp;
111957:         }
111957: 
111957:         MDefinition *insLeft = ins->getOperand(0);
111957:         MDefinition *insRight = ins->getOperand(1);
111957:         if (isCommutative() && insLeft->valueNumber() > insRight->valueNumber()) {
111957:             tmp = insRight;
111957:             insRight = insLeft;
111957:             insLeft = tmp;
111957:         }
111957: 
111957:         return (left->valueNumber() == insLeft->valueNumber()) &&
111957:                (right->valueNumber() == insRight->valueNumber());
111957:     }
111655: };
111655: 
112508: class MTernaryInstruction : public MAryInstruction<3>
112508: {
112508:   protected:
112508:     MTernaryInstruction(MDefinition *first, MDefinition *second, MDefinition *third)
112508:     {
112508:         initOperand(0, first);
112508:         initOperand(1, second);
112508:         initOperand(2, third);
112508:     }
112508: 
112508:   protected:
112508:     HashNumber valueHash() const
112508:     {
112508:         MDefinition *first = getOperand(0);
112508:         MDefinition *second = getOperand(1);
112508:         MDefinition *third = getOperand(2);
112508: 
112508:         return op() ^ first->valueNumber() ^ second->valueNumber() ^ third->valueNumber();
112508:     }
112508: 
112508:     bool congruentTo(MDefinition *const &ins) const
112508:     {
112508:         if (op() != ins->op())
112508:             return false;
112508: 
112508:         if (type() != ins->type())
112508:             return false;
112508: 
112508:         if (isEffectful() || ins->isEffectful())
112508:             return false;
112508: 
112508:         MDefinition *first = getOperand(0);
112508:         MDefinition *second = getOperand(1);
112508:         MDefinition *third = getOperand(2);
112508:         MDefinition *insFirst = ins->getOperand(0);
112508:         MDefinition *insSecond = ins->getOperand(1);
112508:         MDefinition *insThird = ins->getOperand(2);
112508: 
112508:         return first->valueNumber() == insFirst->valueNumber() &&
112508:                second->valueNumber() == insSecond->valueNumber() &&
112508:                third->valueNumber() == insThird->valueNumber();
112508:     }
112508: };
112508: 
111996: class MCompare
111996:   : public MBinaryInstruction,
111996:     public ComparePolicy
111996: {
112056:     JSOp jsop_;
111996: 
112056:     MCompare(MDefinition *left, MDefinition *right, JSOp jsop)
112056:       : MBinaryInstruction(left, right),
112056:         jsop_(jsop)
111996:     {
111996:         setResultType(MIRType_Boolean);
112302:         setMovable();
111996:     }
111996: 
111996:   public:
125300:     INSTRUCTION_HEADER(Compare)
111996:     static MCompare *New(MDefinition *left, MDefinition *right, JSOp op);
111996: 
113328:     bool tryFold(bool *result);
113429:     bool evaluateConstantOperands(bool *result);
113328:     MDefinition *foldsTo(bool useValueNumbers);
113328: 
112480:     void infer(JSContext *cx, const TypeOracle::BinaryTypes &b);
112004:     MIRType specialization() const {
112004:         return specialization_;
112004:     }
112004: 
112056:     JSOp jsop() const {
112056:         return jsop_;
112004:     }
112018:     TypePolicy *typePolicy() {
112018:         return this;
112018:     }
112474:     AliasSet getAliasSet() const {
113356:         // Strict equality is never effectful.
113356:         if (jsop_ == JSOP_STRICTEQ || jsop_ == JSOP_STRICTNE)
113356:             return AliasSet::None();
112480:         if (specialization_ == MIRType_None)
112302:             return AliasSet::Store(AliasSet::Any);
112494:         JS_ASSERT(specialization_ <= MIRType_Object);
112302:         return AliasSet::None();
112302:     }
112823: 
112823:   protected:
112823:     bool congruentTo(MDefinition *const &ins) const {
112823:         if (!MBinaryInstruction::congruentTo(ins))
112823:             return false;
112823:         return jsop() == ins->toCompare()->jsop();
112823:     }
111996: };
111996: 
111715: // Takes a typed value and returns an untyped value.
111673: class MBox : public MUnaryInstruction
111673: {
111795:     MBox(MDefinition *ins)
111685:       : MUnaryInstruction(ins)
111694:     {
111694:         setResultType(MIRType_Value);
112302:         setMovable();
111694:     }
111683: 
111673:   public:
125300:     INSTRUCTION_HEADER(Box)
111795:     static MBox *New(MDefinition *ins)
111673:     {
111673:         // Cannot box a box.
111674:         JS_ASSERT(ins->type() != MIRType_Value);
111673: 
111683:         return new MBox(ins);
111673:     }
112474:     bool congruentTo(MDefinition *const &ins) const {
112474:         return congruentIfOperandsEqual(ins);
112474:     }
112474:     AliasSet getAliasSet() const {
112302:         return AliasSet::None();
112302:     }
111673: };
111673: 
111715: // Takes a typed value and checks if it is a certain type. If so, the payload
111715: // is unpacked and returned as that type. Otherwise, it is considered a
111715: // deoptimization.
111687: class MUnbox : public MUnaryInstruction
111687: {
112118:   public:
112118:     enum Mode {
112844:         Fallible,       // Check the type, and deoptimize if unexpected.
112119:         Infallible,     // Type guard is not necessary.
112844:         TypeBarrier,    // Guard on the type, and act like a TypeBarrier on failure.
112844:         TypeGuard       // Guard on the type, and deoptimize otherwise.
112118:     };
112108: 
112118:   private:
112118:     Mode mode_;
112118: 
112118:     MUnbox(MDefinition *ins, MIRType type, Mode mode)
112108:       : MUnaryInstruction(ins),
112118:         mode_(mode)
111687:     {
111687:         JS_ASSERT(ins->type() == MIRType_Value);
112874:         JS_ASSERT(type == MIRType_Boolean ||
112874:                   type == MIRType_Int32   ||
112874:                   type == MIRType_Double  || 
112874:                   type == MIRType_String  ||
113411:                   type == MIRType_Object);
112874: 
111687:         setResultType(type);
112302:         setMovable();
112874: 
112844:         if (mode_ == TypeBarrier || mode_ == TypeGuard)
112120:             setGuard();
112844:         if (mode_ == TypeGuard)
112844:             mode_ = Fallible;
111687:     }
111687: 
111687:   public:
125300:     INSTRUCTION_HEADER(Unbox)
112118:     static MUnbox *New(MDefinition *ins, MIRType type, Mode mode)
111687:     {
112118:         return new MUnbox(ins, type, mode);
112108:     }
112108: 
112118:     Mode mode() const {
112118:         return mode_;
112118:     }
112118:     MDefinition *input() const {
112118:         return getOperand(0);
112118:     }
112118:     BailoutKind bailoutKind() const {
112119:         // If infallible, no bailout should be generated.
112118:         JS_ASSERT(fallible());
112118:         return mode() == Fallible
112118:                ? Bailout_Normal
112118:                : Bailout_TypeBarrier;
112118:     }
112118:     bool fallible() const {
112118:         return mode() != Infallible;
111687:     }
112474:     bool congruentTo(MDefinition *const &ins) const {
112474:         return congruentIfOperandsEqual(ins);
112474:     }
112474:     AliasSet getAliasSet() const {
112302:         return AliasSet::None();
112302:     }
111687: };
111687: 
112691: class MGuardObject : public MUnaryInstruction, public SingleObjectPolicy
112467: {
112467:     MGuardObject(MDefinition *ins)
112467:       : MUnaryInstruction(ins)
112467:     {
112467:         setGuard();
112467:         setMovable();
113148:         setResultType(MIRType_Object);
112467:     }
112467: 
112467:   public:
125300:     INSTRUCTION_HEADER(GuardObject)
112467: 
112467:     static MGuardObject *New(MDefinition *ins) {
112467:         return new MGuardObject(ins);
112467:     }
112467: 
113148:     MDefinition *input() const {
113148:         return getOperand(0);
113148:     }
113148: 
112467:     TypePolicy *typePolicy() {
112467:         return this;
112467:     }
112474:     AliasSet getAliasSet() const {
112467:         return AliasSet::None();
112467:     }
112467: };
112467: 
119481: class MGuardString
119481:   : public MUnaryInstruction,
119481:     public StringPolicy
119481: {
119481:     MGuardString(MDefinition *ins)
119481:       : MUnaryInstruction(ins)
119481:     {
119481:         setGuard();
119481:         setMovable();
119481:         setResultType(MIRType_String);
119481:     }
119481: 
119481:   public:
125300:     INSTRUCTION_HEADER(GuardString)
119481: 
119481:     static MGuardString *New(MDefinition *ins) {
119481:         return new MGuardString(ins);
119481:     }
119481: 
119481:     MDefinition *input() const {
119481:         return getOperand(0);
119481:     }
119481: 
119481:     TypePolicy *typePolicy() {
119481:         return this;
119481:     }
119481:     AliasSet getAliasSet() const {
119481:         return AliasSet::None();
119481:     }
119481: };
119481: 
112874: // Caller-side allocation of |this| for |new|:
112874: // Given a prototype operand, construct |this| for JSOP_NEW.
112874: // For native constructors, returns MagicValue(JS_IS_CONSTRUCTING).
112874: class MCreateThis
112874:   : public MAryInstruction<2>,
112874:     public MixPolicy<ObjectPolicy<0>, ObjectPolicy<1> >
112874: {
125310:     // Template for |this|, provided by TI, or NULL.
125310:     CompilerRootObject templateObject_;
125310: 
125310:     MCreateThis(MDefinition *callee, MDefinition *prototype, JSObject *templateObject)
125310:       : templateObject_(templateObject)
112874:     {
112874:         initOperand(0, callee);
112874:         initOperand(1, prototype);
125310:         setResultType(MIRType_Object);
112874:     }
112874: 
112874:   public:
125300:     INSTRUCTION_HEADER(CreateThis)
125310:     static MCreateThis *New(MDefinition *callee, MDefinition *prototype, JSObject *templateObject)
125310:     {
125310:         return new MCreateThis(callee, prototype, templateObject);
112874:     }
112874: 
112874:     MDefinition *getCallee() const {
112874:         return getOperand(0);
112874:     }
112874:     MDefinition *getPrototype() const {
112874:         return getOperand(1);
112874:     }
125310:     bool hasTemplateObject() const {
125310:         return !!templateObject_;
125310:     }
125310:     JSObject *getTemplateObject() const {
125310:         JS_ASSERT(hasTemplateObject());
125310:         return templateObject_;
112874:     }
112874: 
112874:     // Although creation of |this| modifies global state, it is safely repeatable.
112874:     AliasSet getAliasSet() const {
112874:         return AliasSet::None();
112874:     }
112874:     TypePolicy *typePolicy() {
112874:         return this;
112874:     }
112874: };
112874: 
113354: // Given a MIRType_Value A and a MIRType_Object B:
113354: // If the Value may be safely unboxed to an Object, return Object(A).
113354: // Otherwise, return B.
113354: // Used to implement return behavior for inlined constructors.
113354: class MReturnFromCtor
113354:   : public MAryInstruction<2>,
113354:     public MixPolicy<BoxPolicy<0>, ObjectPolicy<1> >
113354: {
113354:     MReturnFromCtor(MDefinition *value, MDefinition *object) {
113354:         initOperand(0, value);
113354:         initOperand(1, object);
113354:         setResultType(MIRType_Object);
113354:     }
113354: 
113354:   public:
125300:     INSTRUCTION_HEADER(ReturnFromCtor)
113354:     static MReturnFromCtor *New(MDefinition *value, MDefinition *object)
113354:     {
113354:         return new MReturnFromCtor(value, object);
113354:     }
113354: 
113354:     MDefinition *getValue() const {
113354:         return getOperand(0);
113354:     }
113354:     MDefinition *getObject() const {
113354:         return getOperand(1);
113354:     }
113354: 
113354:     AliasSet getAliasSet() const {
113354:         return AliasSet::None();
113354:     }
113354:     TypePolicy *typePolicy() {
113354:         return this;
113354:     }
113354: };
113354: 
112064: // Passes an MDefinition to an MCall. Must occur between an MPrepareCall and
112064: // MCall. Boxes the input and stores it to the correct location on stack.
112064: //
112064: // Arguments are *not* simply pushed onto a call stack: they are evaluated
112064: // left-to-right, but stored in the arg vector in C-style, right-to-left.
113636: class MPassArg : public MUnaryInstruction
112064: {
124795:     int32_t argnum_;
112064: 
112064:   private:
112064:     MPassArg(MDefinition *def)
112064:       : MUnaryInstruction(def), argnum_(-1)
112064:     {
113636:         setResultType(def->type());
112064:     }
112064: 
112064:   public:
125300:     INSTRUCTION_HEADER(PassArg)
112064:     static MPassArg *New(MDefinition *def)
112064:     {
112064:         return new MPassArg(def);
112064:     }
112064: 
112064:     MDefinition *getArgument() const {
112064:         return getOperand(0);
112064:     }
112064: 
112064:     // Set by the MCall.
124795:     void setArgnum(uint32_t argnum) {
112064:         argnum_ = argnum;
112064:     }
124795:     uint32_t getArgnum() const {
112064:         JS_ASSERT(argnum_ >= 0);
124795:         return (uint32_t)argnum_;
112064:     }
112474:     AliasSet getAliasSet() const {
112302:         return AliasSet::None();
112302:     }
112874:     void printOpcode(FILE *fp);
112064: };
112064: 
111802: // Converts a primitive (either typed or untyped) to a double. If the input is
111802: // not primitive at runtime, a bailout occurs.
112751: class MToDouble
113090:   : public MUnaryInstruction
111800: {
111802:     MToDouble(MDefinition *def)
111802:       : MUnaryInstruction(def)
111800:     {
111802:         setResultType(MIRType_Double);
112302:         setMovable();
111800:     }
111800: 
111800:   public:
125300:     INSTRUCTION_HEADER(ToDouble)
111802:     static MToDouble *New(MDefinition *def)
111800:     {
111802:         return new MToDouble(def);
111800:     }
111994: 
112084:     MDefinition *foldsTo(bool useValueNumbers);
111994:     MDefinition *input() const {
111994:         return getOperand(0);
111994:     }
112474:     bool congruentTo(MDefinition *const &ins) const {
112474:         return congruentIfOperandsEqual(ins);
112474:     }
112474:     AliasSet getAliasSet() const {
113090:         return AliasSet::None();
112302:     }
111800: };
111800: 
111802: // Converts a primitive (either typed or untyped) to an int32. If the input is
111802: // not primitive at runtime, a bailout occurs. If the input cannot be converted
111802: // to an int32 without loss (i.e. "5.5" or undefined) then a bailout occurs.
111802: class MToInt32 : public MUnaryInstruction
111655: {
112931:     bool canBeNegativeZero_;
112931: 
111802:     MToInt32(MDefinition *def)
112931:       : MUnaryInstruction(def),
112931:         canBeNegativeZero_(true)
111802:     {
111802:         setResultType(MIRType_Int32);
112302:         setMovable();
111802:     }
111802: 
111802:   public:
125300:     INSTRUCTION_HEADER(ToInt32)
111802:     static MToInt32 *New(MDefinition *def)
111802:     {
111802:         return new MToInt32(def);
111802:     }
111994: 
111994:     MDefinition *input() const {
111994:         return getOperand(0);
111994:     }
112231: 
112231:     MDefinition *foldsTo(bool useValueNumbers);
112987: 
112987:     // this only has backwards information flow.
113359:     void analyzeEdgeCasesBackward();
112931: 
112931:     bool canBeNegativeZero() {
112931:         return canBeNegativeZero_;
112931:     }
124615:     void setCanBeNegativeZero(bool negativeZero) {
124615:         canBeNegativeZero_ = negativeZero;
124615:     }
112302: 
112474:     bool congruentTo(MDefinition *const &ins) const {
112474:         return congruentIfOperandsEqual(ins);
112474:     }
112931: 
112474:     AliasSet getAliasSet() const {
112302:         return AliasSet::None();
112302:     }
111802: };
111802: 
111802: // Converts a value or typed input to a truncated int32, for use with bitwise
111802: // operations. This is an infallible ValueToECMAInt32.
111802: class MTruncateToInt32 : public MUnaryInstruction
111802: {
111802:     MTruncateToInt32(MDefinition *def)
111802:       : MUnaryInstruction(def)
111802:     {
111802:         setResultType(MIRType_Int32);
112302:         setMovable();
111802:     }
111802: 
111802:   public:
125300:     INSTRUCTION_HEADER(TruncateToInt32)
111802:     static MTruncateToInt32 *New(MDefinition *def)
111802:     {
111802:         return new MTruncateToInt32(def);
111802:     }
112044: 
112044:     MDefinition *input() const {
112044:         return getOperand(0);
112044:     }
112738: 
112738:     MDefinition *foldsTo(bool useValueNumbers);
112738: 
112474:     bool congruentTo(MDefinition *const &ins) const {
112474:         return congruentIfOperandsEqual(ins);
112474:     }
112474:     AliasSet getAliasSet() const {
112302:         return AliasSet::None();
112302:     }
111802: };
111802: 
112429: // Converts any type to a string
112429: class MToString : public MUnaryInstruction
112429: {
112429:     MToString(MDefinition *def)
112429:       : MUnaryInstruction(def)
112429:     {
112429:         setResultType(MIRType_String);
112429:         setMovable();
112429:     }
112429: 
112429:   public:
125300:     INSTRUCTION_HEADER(ToString)
112429:     static MToString *New(MDefinition *def)
112429:     {
112429:         return new MToString(def);
112429:     }
112429: 
112429:     MDefinition *input() const {
112429:         return getOperand(0);
112429:     }
112429: 
112429:     MDefinition *foldsTo(bool useValueNumbers);
112429: 
112474:     bool congruentTo(MDefinition *const &ins) const {
112474:         return congruentIfOperandsEqual(ins);
112474:     }
112474:     AliasSet getAliasSet() const {
112429:         JS_ASSERT(input()->type() < MIRType_Object);
112429:         return AliasSet::None();
112429:     }
112429: };
112429: 
111977: class MBitNot
111977:   : public MUnaryInstruction,
111977:     public BitwisePolicy
111977: {
111977:   protected:
111977:     MBitNot(MDefinition *input)
111977:       : MUnaryInstruction(input)
111977:     {
111977:         setResultType(MIRType_Int32);
112302:         setMovable();
111977:     }
111977: 
111977:   public:
125300:     INSTRUCTION_HEADER(BitNot)
111977:     static MBitNot *New(MDefinition *input);
111977: 
111977:     TypePolicy *typePolicy() {
111977:         return this;
111977:     }
111977: 
111977:     MDefinition *foldsTo(bool useValueNumbers);
114478:     void infer(const TypeOracle::UnaryTypes &u);
112302: 
112474:     bool congruentTo(MDefinition *const &ins) const {
112474:         return congruentIfOperandsEqual(ins);
112474:     }
112474:     AliasSet getAliasSet() const {
112682:         if (specialization_ == MIRType_None)
112302:             return AliasSet::Store(AliasSet::Any);
112302:         return AliasSet::None();
112302:     }
111977: };
111977: 
112684: class MTypeOf
112684:   : public MUnaryInstruction,
112684:     public BoxInputsPolicy
112684: {
112684:     MIRType inputType_;
112684: 
112684:     MTypeOf(MDefinition *def, MIRType inputType)
112684:       : MUnaryInstruction(def), inputType_(inputType)
112684:     {
112684:         setResultType(MIRType_String);
113507:         setMovable();
112684:     }
112684: 
112684:   public:
125300:     INSTRUCTION_HEADER(TypeOf)
112684: 
112684:     static MTypeOf *New(MDefinition *def, MIRType inputType) {
112684:         return new MTypeOf(def, inputType);
112684:     }
112684: 
112684:     TypePolicy *typePolicy() {
112684:         return this;
112684:     }
112684:     MIRType inputType() const {
112684:         return inputType_;
112684:     }
112684:     MDefinition *input() const {
112684:         return getOperand(0);
112684:     }
112684:     MDefinition *foldsTo(bool useValueNumbers);
112684: 
112684:     AliasSet getAliasSet() const {
112684:         if (inputType_ <= MIRType_String)
112684:             return AliasSet::None();
112684: 
112684:         // For objects, typeof may invoke an effectful typeof hook.
112684:         return AliasSet::Store(AliasSet::Any);
112684:     }
112684: };
112684: 
112705: class MToId
112705:   : public MBinaryInstruction,
112705:     public BoxInputsPolicy
112705: {
112705:     MToId(MDefinition *object, MDefinition *index)
112705:       : MBinaryInstruction(object, index)
112705:     {
112705:         setResultType(MIRType_Value);
112705:     }
112705: 
112705:   public:
125300:     INSTRUCTION_HEADER(ToId)
112705: 
112705:     static MToId *New(MDefinition *object, MDefinition *index) {
112705:         return new MToId(object, index);
112705:     }
112705: 
112705:     TypePolicy *typePolicy() {
112705:         return this;
112705:     }
112705: };
112705: 
111803: class MBinaryBitwiseInstruction
111802:   : public MBinaryInstruction,
111802:     public BitwisePolicy
111802: {
111802:   protected:
111803:     MBinaryBitwiseInstruction(MDefinition *left, MDefinition *right)
111685:       : MBinaryInstruction(left, right)
111673:     {
111673:         setResultType(MIRType_Int32);
112302:         setMovable();
111673:     }
111673: 
111655:   public:
111802:     TypePolicy *typePolicy() {
111802:         return this;
111802:     }
111889: 
112002:     MDefinition *foldsTo(bool useValueNumbers);
112002:     virtual MDefinition *foldIfZero(size_t operand) = 0;
113648:     virtual MDefinition *foldIfNegOne(size_t operand) = 0;
112002:     virtual MDefinition *foldIfEqual()  = 0;
114478:     virtual void infer(const TypeOracle::BinaryTypes &b);
112302: 
112474:     bool congruentTo(MDefinition *const &ins) const {
112474:         return congruentIfOperandsEqual(ins);
112474:     }
112474:     AliasSet getAliasSet() const {
112302:         if (specialization_ >= MIRType_Object)
112302:             return AliasSet::Store(AliasSet::Any);
112302:         return AliasSet::None();
112302:     }
111655: };
111655: 
111803: class MBitAnd : public MBinaryBitwiseInstruction
111802: {
111802:     MBitAnd(MDefinition *left, MDefinition *right)
111803:       : MBinaryBitwiseInstruction(left, right)
111802:     { }
111802: 
111802:   public:
125300:     INSTRUCTION_HEADER(BitAnd)
111802:     static MBitAnd *New(MDefinition *left, MDefinition *right);
112002: 
112002:     MDefinition *foldIfZero(size_t operand) {
112002:         return getOperand(operand); // 0 & x => 0;
112002:     }
113648:     MDefinition *foldIfNegOne(size_t operand) {
113648:         return getOperand(1 - operand); // x & -1 => x
113648:     }
112002:     MDefinition *foldIfEqual() {
112002:         return getOperand(0); // x & x => x;
112002:     }
123949:     void computeRange();
111802: };
111802: 
111803: class MBitOr : public MBinaryBitwiseInstruction
111780: {
111795:     MBitOr(MDefinition *left, MDefinition *right)
111803:       : MBinaryBitwiseInstruction(left, right)
111802:     { }
111780: 
111780:   public:
125300:     INSTRUCTION_HEADER(BitOr)
111795:     static MBitOr *New(MDefinition *left, MDefinition *right);
112002: 
112002:     MDefinition *foldIfZero(size_t operand) {
112002:         return getOperand(1 - operand); // 0 | x => x, so if ith is 0, return (1-i)th
112002:     }
113648:     MDefinition *foldIfNegOne(size_t operand) {
113648:         return getOperand(operand); // x | -1 => -1
113648:     }
112002:     MDefinition *foldIfEqual() {
112002:         return getOperand(0); // x | x => x
112002:     }
111780: };
111780: 
111803: class MBitXor : public MBinaryBitwiseInstruction
111780: {
111798:     MBitXor(MDefinition *left, MDefinition *right)
111803:       : MBinaryBitwiseInstruction(left, right)
111802:     { }
111780: 
111780:   public:
125300:     INSTRUCTION_HEADER(BitXor)
111798:     static MBitXor *New(MDefinition *left, MDefinition *right);
112002: 
112002:     MDefinition *foldIfZero(size_t operand) {
112002:         return getOperand(1 - operand); // 0 ^ x => x
112002:     }
113648:     MDefinition *foldIfNegOne(size_t operand) {
113648:         return this;
113648:     }
112002:     MDefinition *foldIfEqual() {
112002:         return MConstant::New(Int32Value(0));
112002:     }
111780: };
111780: 
112970: class MShiftInstruction
112970:   : public MBinaryBitwiseInstruction
112970: {
112970:   protected:
112970:     MShiftInstruction(MDefinition *left, MDefinition *right)
112970:       : MBinaryBitwiseInstruction(left, right)
112970:     { }
112970: 
112970:   public:
113648:     MDefinition *foldIfNegOne(size_t operand) {
113648:         return this;
113648:     }
112970:     MDefinition *foldIfEqual() {
112970:         return this;
112970:     }
114478:     virtual void infer(const TypeOracle::BinaryTypes &b);
112970: };
112970: 
112970: class MLsh : public MShiftInstruction
112026: {
112026:     MLsh(MDefinition *left, MDefinition *right)
112970:       : MShiftInstruction(left, right)
112026:     { }
112026: 
112026:   public:
125300:     INSTRUCTION_HEADER(Lsh)
112026:     static MLsh *New(MDefinition *left, MDefinition *right);
112026: 
112026:     MDefinition *foldIfZero(size_t operand) {
112026:         // 0 << x => 0
112026:         // x << 0 => x
112026:         return getOperand(0);
112026:     }
113361: 
123949:     void computeRange();
112026: };
112026: 
112970: class MRsh : public MShiftInstruction
112026: {
112026:     MRsh(MDefinition *left, MDefinition *right)
112970:       : MShiftInstruction(left, right)
112026:     { }
112026: 
112026:   public:
125300:     INSTRUCTION_HEADER(Rsh)
112026:     static MRsh *New(MDefinition *left, MDefinition *right);
112026: 
112026:     MDefinition *foldIfZero(size_t operand) {
112026:         // 0 >> x => 0
112026:         // x >> 0 => x
112026:         return getOperand(0);
112026:     }
123949:     void computeRange();
112026: };
112026: 
112970: class MUrsh : public MShiftInstruction
112026: {
112026:     bool canOverflow_;
112026: 
112026:     MUrsh(MDefinition *left, MDefinition *right)
112970:       : MShiftInstruction(left, right),
112026:         canOverflow_(true)
112026:     { }
112026: 
112026:   public:
125300:     INSTRUCTION_HEADER(Ursh)
112026:     static MUrsh *New(MDefinition *left, MDefinition *right);
112026: 
112026:     MDefinition *foldIfZero(size_t operand) {
112026:         // 0 >>> x => 0
112026:         if (operand == 0)
112026:             return getOperand(0);
112026: 
112026:         return this;
112026:     }
112026: 
114478:     void infer(const TypeOracle::BinaryTypes &b);
112026: 
112026:     bool canOverflow() {
112026:         // solution is only negative when lhs < 0 and rhs & 0x1f == 0
112026:         MDefinition *lhs = getOperand(0);
112026:         MDefinition *rhs = getOperand(1);
112026: 
112970:         if (lhs->isConstant()) {
112970:             Value lhsv = lhs->toConstant()->value();
112970:             if (lhsv.isInt32() && lhsv.toInt32() >= 0)
112026:                 return false;
112970:         }
112970: 
112970:         if (rhs->isConstant()) {
112970:             Value rhsv = rhs->toConstant()->value();
112970:             if (rhsv.isInt32() && rhsv.toInt32() % 32 != 0)
112026:                 return false;
112970:         }
112026: 
112026:         return canOverflow_;
112026:     }
112026: 
112026:     bool fallible() {
112026:         return canOverflow();
112026:     }
112026: };
112026: 
111800: class MBinaryArithInstruction
111800:   : public MBinaryInstruction,
112684:     public ArithPolicy
111800: {
111800:   public:
111800:     MBinaryArithInstruction(MDefinition *left, MDefinition *right)
111800:       : MBinaryInstruction(left, right)
112302:     {
112302:         setMovable();
112302:     }
111800: 
111800:     TypePolicy *typePolicy() {
111800:         return this;
111800:     }
111920:     MIRType specialization() const {
111920:         return specialization_;
111920:     }
112002: 
112002:     MDefinition *foldsTo(bool useValueNumbers);
112002: 
112002:     virtual double getIdentity() = 0;
112002: 
112962:     void infer(JSContext *cx, const TypeOracle::BinaryTypes &b);
112302: 
123949:     void setInt32() {
123949:         specialization_ = MIRType_Int32;
123949:         setResultType(MIRType_Int32);
123949:     }
123949: 
112474:     bool congruentTo(MDefinition *const &ins) const {
113467:         return MBinaryInstruction::congruentTo(ins);
112474:     }
112474:     AliasSet getAliasSet() const {
112302:         if (specialization_ >= MIRType_Object)
112302:             return AliasSet::Store(AliasSet::Any);
112302:         return AliasSet::None();
112302:     }
111800: };
111800: 
113532: class MMinMax
113532:   : public MBinaryInstruction,
113532:     public ArithPolicy
113532: {
113532:     bool isMax_;
113532: 
113532:     MMinMax(MDefinition *left, MDefinition *right, MIRType type, bool isMax)
113532:       : MBinaryInstruction(left, right),
113532:         isMax_(isMax)
113532:     {
113532:         JS_ASSERT(type == MIRType_Double || type == MIRType_Int32);
113532:         setResultType(type);
113532:         setMovable();
113532:         specialization_ = type;
113532:     }
113532: 
113532:   public:
125300:     INSTRUCTION_HEADER(MinMax)
113532:     static MMinMax *New(MDefinition *left, MDefinition *right, MIRType type, bool isMax) {
113532:         return new MMinMax(left, right, type, isMax);
113532:     }
113532: 
113532:     bool isMax() const {
113532:         return isMax_;
113532:     }
113532:     MIRType specialization() const {
113532:         return specialization_;
113532:     }
113532: 
113532:     TypePolicy *typePolicy() {
113532:         return this;
113532:     }
113532:     bool congruentTo(MDefinition *const &ins) const {
113532:         if (!ins->isMinMax())
113532:             return false;
113532:         if (isMax() != ins->toMinMax()->isMax())
113532:             return false;
113532:         return congruentIfOperandsEqual(ins);
113532:     }
113532: 
113532:     AliasSet getAliasSet() const {
113532:         return AliasSet::None();
113532:     }
113532: };
113532: 
112684: class MAbs
112684:   : public MUnaryInstruction,
112684:     public ArithPolicy
112655: {
112655:     MAbs(MDefinition *num, MIRType type)
112655:       : MUnaryInstruction(num)
112655:     {
112655:         JS_ASSERT(type == MIRType_Double || type == MIRType_Int32);
112655:         setResultType(type);
113507:         setMovable();
112986:         specialization_ = type;
112655:     }
112655: 
112655:   public:
125300:     INSTRUCTION_HEADER(Abs)
112655:     static MAbs *New(MDefinition *num, MIRType type) {
112655:         return new MAbs(num, type);
112655:     }
112655:     MDefinition *num() const {
112655:         return getOperand(0);
112655:     }
112684:     TypePolicy *typePolicy() {
112684:         return this;
112684:     }
112655:     bool congruentTo(MDefinition *const &ins) const {
112655:         return congruentIfOperandsEqual(ins);
112655:     }
112655: 
112655:     AliasSet getAliasSet() const {
112655:         return AliasSet::None();
112655:     }
123949:     void computeRange();
112655: };
112655: 
113476: // Inline implementation of Math.sqrt().
112905: class MSqrt
112905:   : public MUnaryInstruction,
113194:     public DoublePolicy<0>
112905: {
112905:     MSqrt(MDefinition *num)
112905:       : MUnaryInstruction(num)
112905:     {
112905:         setResultType(MIRType_Double);
113507:         setMovable();
112905:     }
112905: 
112905:   public:
125300:     INSTRUCTION_HEADER(Sqrt)
112905:     static MSqrt *New(MDefinition *num) {
112905:         return new MSqrt(num);
112905:     }
112905:     MDefinition *num() const {
112905:         return getOperand(0);
112905:     }
112905:     TypePolicy *typePolicy() {
112905:         return this;
112905:     }
112905:     bool congruentTo(MDefinition *const &ins) const {
112905:         return congruentIfOperandsEqual(ins);
112905:     }
112905: 
112905:     AliasSet getAliasSet() const {
112905:         return AliasSet::None();
112905:     }
112905: };
112655: 
113476: // Inline implementation of Math.pow().
113476: class MPow
113476:   : public MBinaryInstruction,
113476:     public PowPolicy
113476: {
113476:     MPow(MDefinition *input, MDefinition *power, MIRType powerType)
113476:       : MBinaryInstruction(input, power),
113476:         PowPolicy(powerType)
113476:     {
113476:         setResultType(MIRType_Double);
113476:         setMovable();
113476:     }
113476: 
113476:   public:
125300:     INSTRUCTION_HEADER(Pow)
113476:     static MPow *New(MDefinition *input, MDefinition *power, MIRType powerType) {
113476:         return new MPow(input, power, powerType);
113476:     }
113476: 
113476:     MDefinition *input() const {
113476:         return lhs();
113476:     }
113476:     MDefinition *power() const {
113476:         return rhs();
113476:     }
113476:     bool congruentTo(MDefinition *const &ins) const {
113476:         return congruentIfOperandsEqual(ins);
113476:     }
113476:     TypePolicy *typePolicy() {
113476:         return this;
113476:     }
113476:     AliasSet getAliasSet() const {
113476:         return AliasSet::None();
113476:     }
113476: };
113476: 
113476: // Inline implementation of Math.pow(x, 0.5), which subtly differs from Math.sqrt(x).
113476: class MPowHalf
113476:   : public MUnaryInstruction,
113476:     public DoublePolicy<0>
113476: {
113476:     MPowHalf(MDefinition *input)
113476:       : MUnaryInstruction(input)
113476:     {
113476:         setResultType(MIRType_Double);
113476:         setMovable();
113476:     }
113476: 
113476:   public:
125300:     INSTRUCTION_HEADER(PowHalf)
113476:     static MPowHalf *New(MDefinition *input) {
113476:         return new MPowHalf(input);
113476:     }
113476:     MDefinition *input() const {
113476:         return getOperand(0);
113476:     }
113476:     bool congruentTo(MDefinition *const &ins) const {
113476:         return congruentIfOperandsEqual(ins);
113476:     }
113476:     TypePolicy *typePolicy() {
113476:         return this;
113476:     }
113476:     AliasSet getAliasSet() const {
113476:         return AliasSet::None();
113476:     }
113476: };
113476: 
116303: // Inline implementation of Math.random().
116303: class MRandom : public MNullaryInstruction
116303: {
116303:     MRandom()
116303:     {
116303:         setResultType(MIRType_Double);
116303:     }
116303: 
116303:   public:
125300:     INSTRUCTION_HEADER(Random)
116303:     static MRandom *New() {
116303:         return new MRandom;
116303:     }
116303: 
116303:     AliasSet getAliasSet() const {
116303:         return AliasSet::None();
116303:     }
116303: };
116303: 
113194: class MMathFunction
113194:   : public MUnaryInstruction,
113194:     public DoublePolicy<0>
113194: {
113194:   public:
113194:     enum Function {
113194:         Log,
113194:         Sin,
113194:         Cos,
113194:         Tan
113194:     };
113194: 
113194:   private:
113194:     Function function_;
113485:     MathCache *cache_;
113485: 
113485:     MMathFunction(MDefinition *input, Function function, MathCache *cache)
113485:       : MUnaryInstruction(input), function_(function), cache_(cache)
113194:     {
113194:         setResultType(MIRType_Double);
113194:         setMovable();
113194:     }
113194: 
113194:   public:
125300:     INSTRUCTION_HEADER(MathFunction)
113485:     static MMathFunction *New(MDefinition *input, Function function, MathCache *cache) {
113485:         return new MMathFunction(input, function, cache);
113194:     }
113194:     Function function() const {
113194:         return function_;
113194:     }
113485:     MathCache *cache() const {
113485:         return cache_;
113485:     }
113194:     MDefinition *input() const {
113194:         return getOperand(0);
113194:     }
113194:     TypePolicy *typePolicy() {
113194:         return this;
113194:     }
113194:     bool congruentTo(MDefinition *const &ins) const {
113194:         if (!ins->isMathFunction())
113194:             return false;
113194:         if (ins->toMathFunction()->function() != function())
113194:             return false;
113194:         return congruentIfOperandsEqual(ins);
113194:     }
113194: 
113194:     AliasSet getAliasSet() const {
113194:         return AliasSet::None();
113194:     }
113194: };
113194: 
111800: class MAdd : public MBinaryArithInstruction
111700: {
112987:     bool implicitTruncate_;
112987: 
111795:     MAdd(MDefinition *left, MDefinition *right)
112987:       : MBinaryArithInstruction(left, right),
112987:         implicitTruncate_(false)
111700:     {
111700:         setResultType(MIRType_Value);
111700:     }
111700: 
111700:   public:
125300:     INSTRUCTION_HEADER(Add)
111795:     static MAdd *New(MDefinition *left, MDefinition *right) {
111700:         return new MAdd(left, right);
111700:     }
112987:     void analyzeTruncateBackward();
112987: 
112987:     bool isTruncated() const {
112987:         return implicitTruncate_;
112987:     }
124615:     void setTruncated(bool truncate) {
124615:         implicitTruncate_ = truncate;
112987:     }
112987:     bool updateForReplacement(MDefinition *ins);
112002:     double getIdentity() {
112002:         return 0;
112002:     }
113361: 
123949:     bool fallible();
123949:     void computeRange();
111700: };
111700: 
112068: class MSub : public MBinaryArithInstruction
112068: {
112987:     bool implicitTruncate_;
112068:     MSub(MDefinition *left, MDefinition *right)
112987:       : MBinaryArithInstruction(left, right),
112987:         implicitTruncate_(false)
112068:     {
112068:         setResultType(MIRType_Value);
112068:     }
112068: 
112068:   public:
125300:     INSTRUCTION_HEADER(Sub)
112068:     static MSub *New(MDefinition *left, MDefinition *right) {
112068:         return new MSub(left, right);
112068:     }
112068: 
112987:     void analyzeTruncateBackward();
112987:     bool isTruncated() const {
112987:         return implicitTruncate_;
112987:     }
124615:     void setTruncated(bool truncate) {
124615:         implicitTruncate_ = truncate;
112987:     }
112987:     bool updateForReplacement(MDefinition *ins);
112987: 
112068:     double getIdentity() {
112068:         return 0;
112068:     }
113361: 
123949:     bool fallible();
123949:     void computeRange();
112068: };
112068: 
112011: class MMul : public MBinaryArithInstruction
112011: {
121331:     // Annotation the result could be a negative zero
121331:     // and we need to guard this during execution.
112013:     bool canBeNegativeZero_;
112013: 
121331:     // Annotation the result of this Mul is only used in int32 domain
121331:     // and we could possible truncate the result.
121331:     bool possibleTruncate_;
121331: 
121331:     // Annotation the Mul can truncate. This is only set after range analysis,
121331:     // because the result could be in the imprecise double range.
121331:     // In that case the truncated result isn't correct.
121331:     bool implicitTruncate_;
121331: 
113476:     MMul(MDefinition *left, MDefinition *right, MIRType type)
112013:       : MBinaryArithInstruction(left, right),
121331:         canBeNegativeZero_(true),
121331:         possibleTruncate_(false),
121331:         implicitTruncate_(false)
112011:     {
113476:         if (type != MIRType_Value)
113476:             specialization_ = type;
113476:         setResultType(type);
112011:     }
112011: 
112011:   public:
125300:     INSTRUCTION_HEADER(Mul)
112011:     static MMul *New(MDefinition *left, MDefinition *right) {
113476:         return new MMul(left, right, MIRType_Value);
113476:     }
113476:     static MMul *New(MDefinition *left, MDefinition *right, MIRType type) {
113476:         return new MMul(left, right, type);
112011:     }
112011: 
112913:     MDefinition *foldsTo(bool useValueNumbers);
113359:     void analyzeEdgeCasesForward();
113359:     void analyzeEdgeCasesBackward();
121331:     void analyzeTruncateBackward();
112149: 
112011:     double getIdentity() {
112011:         return 1;
112011:     }
112013: 
123949:     bool canOverflow();
124615: 
124615:     bool canBeNegativeZero() {
124615:         return canBeNegativeZero_;
124615:     }
124615:     void setCanBeNegativeZero(bool negativeZero) {
124615:         canBeNegativeZero_ = negativeZero;
124615:     }
123949: 
112987:     bool updateForReplacement(MDefinition *ins);
112013: 
112013:     bool fallible() {
113361:         return canBeNegativeZero_ || canOverflow();
113361:     }
113361: 
123949:     void computeRange();
121331: 
121331:     bool isPossibleTruncated() const {
121331:         return possibleTruncate_;
121331:     }
121331: 
121331:     void setPossibleTruncated(bool truncate) {
121331:         possibleTruncate_ = truncate;
124615: 
124615:         // We can remove the negative zero check, because op if it is only used truncated.
124615:         // The "Possible" in the function name means that we are not sure,
124615:         // that "integer mul and disregarding overflow" == "double mul and ToInt32"
124615:         // Note: when removing truncated state, we have to add negative zero check again,
124615:         // because we are not sure if it was removed by this or other passes.
124615:         canBeNegativeZero_ = !truncate;
121331:     }
112011: };
112011: 
112072: class MDiv : public MBinaryArithInstruction
112072: {
112912:     bool canBeNegativeZero_;
112912:     bool canBeNegativeOverflow_;
112912:     bool canBeDivideByZero_;
112987:     bool implicitTruncate_;
112912: 
113476:     MDiv(MDefinition *left, MDefinition *right, MIRType type)
112912:       : MBinaryArithInstruction(left, right),
112912:         canBeNegativeZero_(true),
112912:         canBeNegativeOverflow_(true),
112987:         canBeDivideByZero_(true),
112987:         implicitTruncate_(false)
112072:     {
113476:         if (type != MIRType_Value)
113476:             specialization_ = type;
113476:         setResultType(type);
113476:     }
113476: 
112072: 
112072:   public:
125300:     INSTRUCTION_HEADER(Div)
112072:     static MDiv *New(MDefinition *left, MDefinition *right) {
113476:         return new MDiv(left, right, MIRType_Value);
113476:     }
113476:     static MDiv *New(MDefinition *left, MDefinition *right, MIRType type) {
113476:         return new MDiv(left, right, type);
112072:     }
112072: 
112072:     MDefinition *foldsTo(bool useValueNumbers);
113359:     void analyzeEdgeCasesForward();
113359:     void analyzeEdgeCasesBackward();
112987:     void analyzeTruncateBackward();
112912: 
112072:     double getIdentity() {
112072:         JS_NOT_REACHED("not used");
112072:         return 1;
112072:     }
112849: 
112987:     bool isTruncated() const {
112987:         return implicitTruncate_;
112987:     }
124615:     void setTruncated(bool truncate) {
124615:         implicitTruncate_ = truncate;
112987:     }
112987: 
112912:     bool canBeNegativeZero() {
112912:         return canBeNegativeZero_;
112912:     }
124615:     void setCanBeNegativeZero(bool negativeZero) {
124615:         canBeNegativeZero_ = negativeZero;
124615:     }
112912: 
112912:     bool canBeNegativeOverflow() {
112912:         return canBeNegativeOverflow_;
112912:     }
112912: 
112849:     bool canBeDivideByZero() {
112912:         return canBeDivideByZero_;
112849:     }
112987:     bool updateForReplacement(MDefinition *ins);
112987: 
112072: };
112072: 
112345: class MMod : public MBinaryArithInstruction
112345: {
112345:     MMod(MDefinition *left, MDefinition *right)
112345:       : MBinaryArithInstruction(left, right)
112345:     {
112345:         setResultType(MIRType_Value);
112345:     }
112345: 
112345:   public:
125300:     INSTRUCTION_HEADER(Mod)
112345:     static MMod *New(MDefinition *left, MDefinition *right) {
112345:         return new MMod(left, right);
112345:     }
112345: 
112345:     MDefinition *foldsTo(bool useValueNumbers);
112345:     double getIdentity() {
112345:         JS_NOT_REACHED("not used");
112345:         return 1;
112345:     }
113361: 
123949:     void computeRange();
112345: };
112345: 
112429: class MConcat
112429:   : public MBinaryInstruction,
112429:     public BinaryStringPolicy
112429: {
112429:     MConcat(MDefinition *left, MDefinition *right)
112429:       : MBinaryInstruction(left, right)
112429:     {
112429:         setMovable();
112429:         setResultType(MIRType_String);
112429:     }
112429: 
112429:   public:
125300:     INSTRUCTION_HEADER(Concat)
112429:     static MConcat *New(MDefinition *left, MDefinition *right) {
112429:         return new MConcat(left, right);
112429:     }
112429: 
112429:     TypePolicy *typePolicy() {
112429:         return this;
112429:     }
112474:     bool congruentTo(MDefinition *const &ins) const {
112474:         return congruentIfOperandsEqual(ins);
112474:     }
112474:     AliasSet getAliasSet() const {
112429:         return AliasSet::None();
112429:     }
112429: };
112429: 
112728: class MCharCodeAt
112728:   : public MBinaryInstruction,
112728:     public MixPolicy<StringPolicy, IntPolicy<1> >
112728: {
112728:     MCharCodeAt(MDefinition *str, MDefinition *index)
112728:         : MBinaryInstruction(str, index)
112728:     {
112728:         setMovable();
112728:         setResultType(MIRType_Int32);
112728:     }
112728: 
113164:   public:
125300:     INSTRUCTION_HEADER(CharCodeAt)
112728: 
113164:     static MCharCodeAt *New(MDefinition *str, MDefinition *index) {
113164:         return new MCharCodeAt(str, index);
113164:     }
113164: 
112728:     TypePolicy *typePolicy() {
112728:         return this;
112728:     }
112728: 
112728:     virtual AliasSet getAliasSet() const {
113164:         // Strings are immutable, so there is no implicit dependency.
113164:         return AliasSet::None();
112728:     }
123949: 
123949:     void computeRange();
112728: };
112728: 
112728: class MFromCharCode
112728:   : public MUnaryInstruction,
112728:     public IntPolicy<0>
112728: {
112728:     MFromCharCode(MDefinition *code)
112728:       : MUnaryInstruction(code)
112728:     {
112728:         setMovable();
112728:         setResultType(MIRType_String);
112728:     }
112728: 
113164:   public:
125300:     INSTRUCTION_HEADER(FromCharCode)
112728: 
113164:     static MFromCharCode *New(MDefinition *code) {
113164:         return new MFromCharCode(code);
113164:     }
113164: 
112728:     virtual AliasSet getAliasSet() const {
112728:         return AliasSet::None();
112728:     }
112728: };
112728: 
111897: class MPhi : public MDefinition, public InlineForwardListNode<MPhi>
111655: {
111795:     js::Vector<MDefinition *, 2, IonAllocPolicy> inputs_;
124795:     uint32_t slot_;
111800:     bool triedToSpecialize_;
113129:     bool isIterator_;
124795:     MPhi(uint32_t slot)
111800:       : slot_(slot),
113065:         triedToSpecialize_(false),
113129:         isIterator_(false)
111694:     {
111694:         setResultType(MIRType_Value);
111694:     }
111655: 
111655:   protected:
111795:     void setOperand(size_t index, MDefinition *operand) {
111655:         inputs_[index] = operand;
111655:     }
111655: 
111655:   public:
125300:     INSTRUCTION_HEADER(Phi)
124795:     static MPhi *New(uint32_t slot);
111655: 
111795:     MDefinition *getOperand(size_t index) const {
111671:         return inputs_[index];
111655:     }
111662:     size_t numOperands() const {
111662:         return inputs_.length();
111662:     }
124795:     uint32_t slot() const {
111662:         return slot_;
111662:     }
111800:     bool triedToSpecialize() const {
111800:         return triedToSpecialize_;
111800:     }
111800:     void specialize(MIRType type) {
111800:         triedToSpecialize_ = true;
111800:         setResultType(type);
111800:     }
111795:     bool addInput(MDefinition *ins);
111869: 
111957:     MDefinition *foldsTo(bool useValueNumbers);
111957: 
111869:     bool congruentTo(MDefinition * const &ins) const;
112302: 
113129:     bool isIterator() const {
113129:         return isIterator_;
113129:     }
113129:     void setIterator() {
113129:         isIterator_ = true;
113129:     }
113065: 
112474:     AliasSet getAliasSet() const {
112302:         return AliasSet::None();
112302:     }
123949:     void computeRange();
113361: };
113361: 
113361: // The goal of a Beta node is to split a def at a conditionally taken
113361: // branch, so that uses dominated by it have a different name.
113361: class MBeta : public MUnaryInstruction
113361: {
113361:   private:
123949:     const Range *comparison_;
113361:     MDefinition *val_;
123949:     MBeta(MDefinition *val, const Range *comp)
113361:         : MUnaryInstruction(val),
116486:           comparison_(comp),
113361:           val_(val)
113361:     {
123949:         setResultType(val->type());
113361:     }
113361: 
113361:   public:
125300:     INSTRUCTION_HEADER(Beta)
113361:     void printOpcode(FILE *fp);
123949:     static MBeta *New(MDefinition *val, const Range *comp)
116486:     {
116486:         return new MBeta(val, comp);
113361:     }
113361: 
113361:     AliasSet getAliasSet() const {
113361:         return AliasSet::None();
113361:     }
113361: 
123949:     void computeRange();
111655: };
111655: 
112219: // MIR representation of a Value on the OSR StackFrame.
112219: // The Value is indexed off of OsrFrameReg.
112755: class MOsrValue : public MUnaryInstruction
112219: {
112401:   private:
112219:     ptrdiff_t frameOffset_;
112219: 
112219:     MOsrValue(MOsrEntry *entry, ptrdiff_t frameOffset)
112755:       : MUnaryInstruction(entry),
112755:         frameOffset_(frameOffset)
112219:     {
112219:         setResultType(MIRType_Value);
112219:     }
112219: 
112219:   public:
125300:     INSTRUCTION_HEADER(OsrValue)
112219:     static MOsrValue *New(MOsrEntry *entry, ptrdiff_t frameOffset) {
112219:         return new MOsrValue(entry, frameOffset);
112219:     }
112219: 
112219:     ptrdiff_t frameOffset() const {
112219:         return frameOffset_;
112219:     }
112219: 
112219:     MOsrEntry *entry() {
112219:         return getOperand(0)->toOsrEntry();
112219:     }
112219: 
112474:     AliasSet getAliasSet() const {
112302:         return AliasSet::None();
112302:     }
112219: };
112219: 
112401: // MIR representation of a JSObject scope chain pointer on the OSR StackFrame.
112401: // The pointer is indexed off of OsrFrameReg.
112755: class MOsrScopeChain : public MUnaryInstruction
112401: {
112401:   private:
112401:     MOsrScopeChain(MOsrEntry *entry)
112755:       : MUnaryInstruction(entry)
112401:     {
112401:         setResultType(MIRType_Object);
112401:     }
112401: 
112401:   public:
125300:     INSTRUCTION_HEADER(OsrScopeChain)
112401:     static MOsrScopeChain *New(MOsrEntry *entry) {
112401:         return new MOsrScopeChain(entry);
112401:     }
112401: 
112401:     MOsrEntry *entry() {
112401:         return getOperand(0)->toOsrEntry();
112401:     }
112401: };
112401: 
112292: // Check the current frame for over-recursion past the global stack limit.
112541: class MCheckOverRecursed : public MNullaryInstruction
112292: {
112292:   public:
125300:     INSTRUCTION_HEADER(CheckOverRecursed)
112292: };
112292: 
112397: // Check the script's use count and trigger recompilation to inline
112397: // calls when the script becomes hot.
112541: class MRecompileCheck : public MNullaryInstruction
112397: {
113508:     uint32_t minUses_;
113508: 
124795:     MRecompileCheck(uint32_t minUses)
113508:       : minUses_(minUses)
113508:     {
112397:         setGuard();
112397:     }
112397: 
112397:   public:
125300:     INSTRUCTION_HEADER(RecompileCheck)
112397: 
113508:     uint32_t minUses() const {
113508:         return minUses_;
113508:     }
113508:     static MRecompileCheck *New(uint32_t minUses) {
113508:         return new MRecompileCheck(minUses);
113508:     }
112474:     AliasSet getAliasSet() const {
112397:         return AliasSet::None();
112397:     }
112397: };
112397: 
113116: // Check whether we need to fire the interrupt handler.
113116: class MInterruptCheck : public MNullaryInstruction
113116: {
113116:     MInterruptCheck() {
113116:         setGuard();
113116:     }
113116: 
113116:   public:
125300:     INSTRUCTION_HEADER(InterruptCheck)
113116: 
113116:     static MInterruptCheck *New() {
113116:         return new MInterruptCheck();
113116:     }
113116:     AliasSet getAliasSet() const {
113116:         return AliasSet::None();
113116:     }
113116: };
113116: 
112716: // If not defined, set a global variable to |undefined|.
112716: class MDefVar : public MUnaryInstruction
112716: {
112716:   PropertyName *name_; // Target name to be defined.
112781:   unsigned attrs_; // Attributes to be set.
112716: 
112716:   private:
112781:     MDefVar(PropertyName *name, unsigned attrs, MDefinition *scopeChain)
112716:       : MUnaryInstruction(scopeChain),
112716:         name_(name),
112716:         attrs_(attrs)
112716:     {
112716:     }
112716: 
112716:   public:
125300:     INSTRUCTION_HEADER(DefVar)
112716: 
112781:     static MDefVar *New(PropertyName *name, unsigned attrs, MDefinition *scopeChain) {
112716:         return new MDefVar(name, attrs, scopeChain);
112716:     }
112716: 
112716:     PropertyName *name() const {
112716:         return name_;
112716:     }
112781:     unsigned attrs() const {
112716:         return attrs_;
112716:     }
112716:     MDefinition *scopeChain() const {
112716:         return getOperand(0);
112716:     }
112716: 
112716: };
112716: 
112541: class MRegExp : public MNullaryInstruction
112541: {
112541:   public:
112541:     // In the future we can optimize MRegExp to reuse the source object
112541:     // instead of cloning in the case of some
112541:     // single-use-is-a-known-native-that-can't-observe-the-object
112541:     // operations (like test).
112541:     enum CloneBehavior {
112541:         UseSource,
112541:         MustClone
112541:     };
112541: 
112541:   private:
113494:     CompilerRoot<RegExpObject *> source_;
113494:     CompilerRootObject prototype_;
112541:     CloneBehavior shouldClone_;
112541: 
113485:     MRegExp(RegExpObject *source, JSObject *prototype, CloneBehavior shouldClone)
112541:       : source_(source),
113485:         prototype_(prototype),
112541:         shouldClone_(shouldClone)
112541:     {
112541:         setResultType(MIRType_Object);
112541: 
112541:         // Can't move if we're cloning, because cloning takes into
112541:         // account the RegExpStatics flags.
112541:         if (shouldClone == UseSource)
112541:             setMovable();
112541:     }
112541: 
112541:   public:
112541:     INSTRUCTION_HEADER(RegExp)
112541: 
113485:     static MRegExp *New(RegExpObject *source, JSObject *prototype, CloneBehavior shouldClone) {
113485:         return new MRegExp(source, prototype, shouldClone);
112541:     }
112541: 
113494:     RegExpObject *source() const {
112541:         return source_;
112541:     }
113485:     JSObject *getRegExpPrototype() const {
113485:         return prototype_;
113485:     }
112541:     CloneBehavior shouldClone() const {
112541:         return shouldClone_;
112541:     }
112541:     AliasSet getAliasSet() const {
112541:         return AliasSet::None();
112541:     }
112541: };
112541: 
116030: class MRegExpTest
116030:   : public MBinaryInstruction,
116030:     public MixPolicy<ObjectPolicy<1>, StringPolicy >
116030: {
116030:   private:
116030: 
116030:     MRegExpTest(MDefinition *regexp, MDefinition *string)
116030:       : MBinaryInstruction(string, regexp)
116030:     {
116030:         setResultType(MIRType_Boolean);
116030:     }
116030: 
116030:   public:
116030:     INSTRUCTION_HEADER(RegExpTest)
116030: 
116030:     static MRegExpTest *New(MDefinition *regexp, MDefinition *string) {
116030:         return new MRegExpTest(regexp, string);
116030:     }
116030: 
116030:     TypePolicy *typePolicy() {
116030:         return this;
116030:     }
116030: 
116030:     MDefinition *regexp() const {
116030:         return getOperand(1);
116030:     }
116030:     MDefinition *string() const {
116030:         return getOperand(0);
116030:     }
116030: };
116030: 
112691: class MLambda
112691:   : public MUnaryInstruction,
112691:     public SingleObjectPolicy
112691: {
113494:     CompilerRootFunction fun_;
112691: 
112691:     MLambda(MDefinition *scopeChain, JSFunction *fun)
112691:       : MUnaryInstruction(scopeChain), fun_(fun)
112691:     {
112691:         setResultType(MIRType_Object);
112691:     }
112691: 
112691:   public:
125300:     INSTRUCTION_HEADER(Lambda)
112691: 
112691:     static MLambda *New(MDefinition *scopeChain, JSFunction *fun) {
112691:         return new MLambda(scopeChain, fun);
112691:     }
112691:     MDefinition *scopeChain() const {
112691:         return getOperand(0);
112691:     }
113494:     JSFunction *fun() const {
112691:         return fun_;
112691:     }
112691:     TypePolicy *typePolicy() {
112691:         return this;
112691:     }
112691: };
112691: 
112259: // Determines the implicit |this| value for function calls.
112259: class MImplicitThis
112259:   : public MUnaryInstruction,
112691:     public SingleObjectPolicy
112259: {
112259:     MImplicitThis(MDefinition *callee)
112259:       : MUnaryInstruction(callee)
112259:     {
112259:         setResultType(MIRType_Value);
112302:         setMovable();
112259:     }
112259: 
112259:   public:
125300:     INSTRUCTION_HEADER(ImplicitThis)
112259: 
112259:     static MImplicitThis *New(MDefinition *callee) {
112259:         return new MImplicitThis(callee);
112259:     }
112259: 
112259:     TypePolicy *typePolicy() {
112259:         return this;
112259:     }
112259:     MDefinition *callee() const {
112259:         return getOperand(0);
112259:     }
112474:     AliasSet getAliasSet() const {
112302:         return AliasSet::None();
112302:     }
112259: };
112259: 
112118: // Returns obj->slots.
112118: class MSlots
112118:   : public MUnaryInstruction,
112691:     public SingleObjectPolicy
112118: {
112258:     MSlots(MDefinition *object)
112258:       : MUnaryInstruction(object)
112118:     {
112118:         setResultType(MIRType_Slots);
112302:         setMovable();
112118:     }
112118: 
112118:   public:
125300:     INSTRUCTION_HEADER(Slots)
112118: 
112258:     static MSlots *New(MDefinition *object) {
112258:         return new MSlots(object);
112118:     }
112118: 
112118:     TypePolicy *typePolicy() {
112118:         return this;
112118:     }
112258:     MDefinition *object() const {
112118:         return getOperand(0);
112118:     }
112474:     bool congruentTo(MDefinition *const &ins) const {
112474:         return congruentIfOperandsEqual(ins);
112474:     }
112474:     AliasSet getAliasSet() const {
112302:         return AliasSet::Load(AliasSet::ObjectFields);
112302:     }
112118: };
112118: 
112258: // Returns obj->elements.
112258: class MElements
112231:   : public MUnaryInstruction,
112691:     public SingleObjectPolicy
112231: {
112258:     MElements(MDefinition *object)
112231:       : MUnaryInstruction(object)
112231:     {
112258:         setResultType(MIRType_Elements);
112302:         setMovable();
112258:     }
112258: 
112258:   public:
125300:     INSTRUCTION_HEADER(Elements)
112258: 
112258:     static MElements *New(MDefinition *object) {
112258:         return new MElements(object);
112258:     }
112258: 
112258:     TypePolicy *typePolicy() {
112258:         return this;
112258:     }
112258:     MDefinition *object() const {
112258:         return getOperand(0);
112258:     }
112474:     bool congruentTo(MDefinition *const &ins) const {
112474:         return congruentIfOperandsEqual(ins);
112474:     }
112474:     AliasSet getAliasSet() const {
112302:         return AliasSet::Load(AliasSet::ObjectFields);
112302:     }
112258: };
112258: 
113395: // A constant value for some object's array elements or typed array elements.
113395: class MConstantElements : public MNullaryInstruction
113395: {
113395:     void *value_;
113395: 
113395:   protected:
113395:     MConstantElements(void *v)
113395:       : value_(v)
113395:     {
113395:         setResultType(MIRType_Elements);
113395:         setMovable();
113395:     }
113395: 
113395:   public:
125300:     INSTRUCTION_HEADER(ConstantElements)
113395:     static MConstantElements *New(void *v) {
113395:         return new MConstantElements(v);
113395:     }
113395: 
113395:     void *value() const {
113395:         return value_;
113395:     }
113395: 
113395:     void printOpcode(FILE *fp);
113395: 
113395:     HashNumber valueHash() const {
113396:         return (HashNumber)(size_t) value_;
113395:     }
113395: 
113395:     bool congruentTo(MDefinition * const &ins) const {
113395:         return ins->isConstantElements() && ins->toConstantElements()->value() == value();
113395:     }
113395: 
113395:     AliasSet getAliasSet() const {
113395:         return AliasSet::None();
113395:     }
113395: };
113395: 
112258: // Load a dense array's initialized length from an elements vector.
112258: class MInitializedLength
112258:   : public MUnaryInstruction
112258: {
112258:     MInitializedLength(MDefinition *elements)
112258:       : MUnaryInstruction(elements)
112258:     {
112231:         setResultType(MIRType_Int32);
112302:         setMovable();
112231:     }
112231: 
112231:   public:
125300:     INSTRUCTION_HEADER(InitializedLength)
112231: 
112258:     static MInitializedLength *New(MDefinition *elements) {
112258:         return new MInitializedLength(elements);
112231:     }
112231: 
112258:     MDefinition *elements() const {
112231:         return getOperand(0);
112231:     }
112474:     bool congruentTo(MDefinition *const &ins) const {
112474:         return congruentIfOperandsEqual(ins);
112474:     }
112474:     AliasSet getAliasSet() const {
112302:         return AliasSet::Load(AliasSet::ObjectFields);
112302:     }
112231: };
112231: 
112734: // Set a dense array's initialized length to an elements vector.
112734: class MSetInitializedLength
112734:   : public MAryInstruction<2>
112734: {
112734:     MSetInitializedLength(MDefinition *elements, MDefinition *index)
112734:     {
112755:         initOperand(0, elements);
112755:         initOperand(1, index);
112734:     }
112734: 
112734:   public:
125300:     INSTRUCTION_HEADER(SetInitializedLength)
112734: 
112734:     static MSetInitializedLength *New(MDefinition *elements, MDefinition *index) {
112734:         return new MSetInitializedLength(elements, index);
112734:     }
112734: 
112734:     MDefinition *elements() const {
112734:         return getOperand(0);
112734:     }
112734:     MDefinition *index() const {
112734:         return getOperand(1);
112734:     }
112734:     AliasSet getAliasSet() const {
112734:         return AliasSet::Store(AliasSet::ObjectFields);
112734:     }
112734: };
112734: 
112309: // Load a dense array's initialized length from an elements vector.
112309: class MArrayLength
112309:   : public MUnaryInstruction
112309: {
112309:   public:
112309:     MArrayLength(MDefinition *elements)
112309:       : MUnaryInstruction(elements)
112309:     {
112309:         setResultType(MIRType_Int32);
112309:         setMovable();
112309:     }
112309: 
125300:     INSTRUCTION_HEADER(ArrayLength)
112309: 
112309:     MDefinition *elements() const {
112309:         return getOperand(0);
112309:     }
112474:     bool congruentTo(MDefinition *const &ins) const {
112474:         return congruentIfOperandsEqual(ins);
112474:     }
112474:     AliasSet getAliasSet() const {
112309:         return AliasSet::Load(AliasSet::ObjectFields);
112309:     }
112309: };
112309: 
112867: // Read the length of a typed array.
112867: class MTypedArrayLength
112867:   : public MUnaryInstruction,
112867:     public SingleObjectPolicy
112867: {
112867:     MTypedArrayLength(MDefinition *obj)
112867:       : MUnaryInstruction(obj)
112867:     {
112867:         setResultType(MIRType_Int32);
112867:         setMovable();
112867:     }
112867: 
112867:   public:
125300:     INSTRUCTION_HEADER(TypedArrayLength)
112867: 
112867:     static MTypedArrayLength *New(MDefinition *obj) {
112867:         return new MTypedArrayLength(obj);
112867:     }
112867: 
112867:     TypePolicy *typePolicy() {
112867:         return this;
112867:     }
112867:     MDefinition *object() const {
112867:         return getOperand(0);
112867:     }
112867:     bool congruentTo(MDefinition *const &ins) const {
112867:         return congruentIfOperandsEqual(ins);
112867:     }
112867:     AliasSet getAliasSet() const {
112867:         // The typed array |length| property is immutable, so there is no
112867:         // implicit dependency.
112867:         return AliasSet::None();
112867:     }
112867: };
112867: 
112904: // Load a typed array's elements vector.
112904: class MTypedArrayElements
112904:   : public MUnaryInstruction,
112904:     public SingleObjectPolicy
112904: {
112904:     MTypedArrayElements(MDefinition *object)
112904:       : MUnaryInstruction(object)
112904:     {
112904:         setResultType(MIRType_Elements);
112904:         setMovable();
112904:     }
112904: 
112904:   public:
125300:     INSTRUCTION_HEADER(TypedArrayElements)
112904: 
112904:     static MTypedArrayElements *New(MDefinition *object) {
112904:         return new MTypedArrayElements(object);
112904:     }
112904: 
112904:     TypePolicy *typePolicy() {
112904:         return this;
112904:     }
112904:     MDefinition *object() const {
112904:         return getOperand(0);
112904:     }
112904:     bool congruentTo(MDefinition *const &ins) const {
112904:         return congruentIfOperandsEqual(ins);
112904:     }
112904:     AliasSet getAliasSet() const {
112904:         return AliasSet::Load(AliasSet::ObjectFields);
112904:     }
112904: };
112904: 
112696: // Perform !-operation
112759: class MNot
112759:   : public MUnaryInstruction,
112759:     public TestPolicy
112696: {
112696:   public:
112696:     MNot(MDefinition *elements)
112696:       : MUnaryInstruction(elements)
112696:     {
112696:         setResultType(MIRType_Boolean);
112696:         setMovable();
112696:     }
112696: 
125300:     INSTRUCTION_HEADER(Not)
112696: 
112696:     MDefinition *foldsTo(bool useValueNumbers);
112696: 
112696:     MDefinition *operand() const {
112696:         return getOperand(0);
112696:     }
112696: 
112696:     virtual AliasSet getAliasSet() const {
112696:         return AliasSet::None();
112696:     }
112759:     TypePolicy *typePolicy() {
112759:         return this;
112759:     }
112696: };
112696: 
112488: // Bailout if index + minimum < 0 or index + maximum >= length. The length used
112488: // in a bounds check must not be negative, or the wrong result may be computed
112488: // (unsigned comparisons may be used).
112231: class MBoundsCheck
112231:   : public MBinaryInstruction
112231: {
112488:     // Range over which to perform the bounds check, may be modified by GVN.
124795:     int32_t minimum_;
124795:     int32_t maximum_;
112488: 
112231:     MBoundsCheck(MDefinition *index, MDefinition *length)
112488:       : MBinaryInstruction(index, length), minimum_(0), maximum_(0)
112231:     {
112231:         setGuard();
112302:         setMovable();
112231:         JS_ASSERT(index->type() == MIRType_Int32);
112231:         JS_ASSERT(length->type() == MIRType_Int32);
113380: 
113380:         // Returns the checked index.
113380:         setResultType(MIRType_Int32);
112231:     }
112231: 
112231:   public:
125300:     INSTRUCTION_HEADER(BoundsCheck)
112231: 
112231:     static MBoundsCheck *New(MDefinition *index, MDefinition *length) {
112231:         return new MBoundsCheck(index, length);
112231:     }
112231:     MDefinition *index() const {
112231:         return getOperand(0);
112231:     }
112231:     MDefinition *length() const {
112231:         return getOperand(1);
112231:     }
124795:     int32_t minimum() const {
112488:         return minimum_;
112488:     }
124795:     void setMinimum(int32_t n) {
112488:         minimum_ = n;
112488:     }
124795:     int32_t maximum() const {
112488:         return maximum_;
112488:     }
124795:     void setMaximum(int32_t n) {
112488:         maximum_ = n;
112488:     }
113380:     bool congruentTo(MDefinition * const &ins) const {
113380:         if (!ins->isBoundsCheck())
113380:             return false;
113380:         MBoundsCheck *other = ins->toBoundsCheck();
113380:         if (minimum() != other->minimum() || maximum() != other->maximum())
113380:             return false;
113380:         return congruentIfOperandsEqual(other);
113380:     }
112488:     virtual AliasSet getAliasSet() const {
112488:         return AliasSet::None();
112488:     }
112488: };
112488: 
112488: // Bailout if index < minimum.
112488: class MBoundsCheckLower
112488:   : public MUnaryInstruction
112488: {
124795:     int32_t minimum_;
112488: 
112488:     MBoundsCheckLower(MDefinition *index)
112488:       : MUnaryInstruction(index), minimum_(0)
112488:     {
112488:         setGuard();
112488:         setMovable();
112488:         JS_ASSERT(index->type() == MIRType_Int32);
112488:     }
112488: 
112488:   public:
125300:     INSTRUCTION_HEADER(BoundsCheckLower)
112488: 
112488:     static MBoundsCheckLower *New(MDefinition *index) {
112488:         return new MBoundsCheckLower(index);
112488:     }
112488: 
112488:     MDefinition *index() const {
112488:         return getOperand(0);
112488:     }
124795:     int32_t minimum() const {
112488:         return minimum_;
112488:     }
124795:     void setMinimum(int32_t n) {
112488:         minimum_ = n;
112231:     }
112474:     AliasSet getAliasSet() const {
112302:         return AliasSet::None();
112302:     }
123949:     bool fallible();
112231: };
112231: 
112258: // Load a value from a dense array's element vector and does a hole check if the
112231: // array is not known to be packed.
112231: class MLoadElement
112231:   : public MBinaryInstruction,
112691:     public SingleObjectPolicy
112231: {
112231:     bool needsHoleCheck_;
112231: 
112258:     MLoadElement(MDefinition *elements, MDefinition *index, bool needsHoleCheck)
112258:       : MBinaryInstruction(elements, index),
112231:         needsHoleCheck_(needsHoleCheck)
112231:     {
112231:         setResultType(MIRType_Value);
112302:         setMovable();
112258:         JS_ASSERT(elements->type() == MIRType_Elements);
112231:         JS_ASSERT(index->type() == MIRType_Int32);
112231:     }
112231: 
112231:   public:
125300:     INSTRUCTION_HEADER(LoadElement)
112231: 
112258:     static MLoadElement *New(MDefinition *elements, MDefinition *index, bool needsHoleCheck) {
112258:         return new MLoadElement(elements, index, needsHoleCheck);
112231:     }
112231: 
112231:     TypePolicy *typePolicy() {
112231:         return this;
112231:     }
112258:     MDefinition *elements() const {
112231:         return getOperand(0);
112231:     }
112231:     MDefinition *index() const {
112231:         return getOperand(1);
112231:     }
112231:     bool needsHoleCheck() const {
112231:         return needsHoleCheck_;
112231:     }
112231:     bool fallible() const {
112231:         return needsHoleCheck();
112231:     }
112474:     AliasSet getAliasSet() const {
112302:         return AliasSet::Load(AliasSet::Element);
112302:     }
112231: };
112231: 
112508: // Load a value from a dense array's element vector. If the index is
112508: // out-of-bounds, or the indexed slot has a hole, undefined is returned
112508: // instead.
112508: class MLoadElementHole
112508:   : public MTernaryInstruction,
112691:     public SingleObjectPolicy
112508: {
112508:     bool needsHoleCheck_;
112508: 
112508:     MLoadElementHole(MDefinition *elements, MDefinition *index, MDefinition *initLength, bool needsHoleCheck)
112508:       : MTernaryInstruction(elements, index, initLength),
112508:         needsHoleCheck_(needsHoleCheck)
112508:     {
112508:         setResultType(MIRType_Value);
112508:         setMovable();
112508:         JS_ASSERT(elements->type() == MIRType_Elements);
112508:         JS_ASSERT(index->type() == MIRType_Int32);
112508:         JS_ASSERT(initLength->type() == MIRType_Int32);
112508:     }
112508: 
112508:   public:
125300:     INSTRUCTION_HEADER(LoadElementHole)
112508: 
112508:     static MLoadElementHole *New(MDefinition *elements, MDefinition *index,
112508:                                  MDefinition *initLength, bool needsHoleCheck) {
112508:         return new MLoadElementHole(elements, index, initLength, needsHoleCheck);
112508:     }
112508: 
112508:     TypePolicy *typePolicy() {
112508:         return this;
112508:     }
112508:     MDefinition *elements() const {
112508:         return getOperand(0);
112508:     }
112508:     MDefinition *index() const {
112508:         return getOperand(1);
112508:     }
112508:     MDefinition *initLength() const {
112508:         return getOperand(2);
112508:     }
112508:     bool needsHoleCheck() const {
112508:         return needsHoleCheck_;
112508:     }
112508:     AliasSet getAliasSet() const {
112508:         return AliasSet::Load(AliasSet::Element);
112508:     }
112508: };
112508: 
112524: class MStoreElementCommon
112524: {
112524:     bool needsBarrier_;
112524:     MIRType elementType_;
112524: 
112524:   protected:
112524:     MStoreElementCommon()
112524:       : needsBarrier_(false),
113100:         elementType_(MIRType_Value)
112524:     { }
112524: 
112524:   public:
112524:     MIRType elementType() const {
112524:         return elementType_;
112524:     }
112524:     void setElementType(MIRType elementType) {
112524:         JS_ASSERT(elementType != MIRType_None);
112524:         elementType_ = elementType;
112524:     }
112524:     bool needsBarrier() const {
112524:         return needsBarrier_;
112524:     }
113423:     void setNeedsBarrier() {
113423:         needsBarrier_ = true;
112524:     }
112524: };
112524: 
112231: // Store a value to a dense array slots vector.
112231: class MStoreElement
112231:   : public MAryInstruction<3>,
112524:     public MStoreElementCommon,
112691:     public SingleObjectPolicy
112231: {
112524:     MStoreElement(MDefinition *elements, MDefinition *index, MDefinition *value) {
112258:         initOperand(0, elements);
112231:         initOperand(1, index);
112231:         initOperand(2, value);
112258:         JS_ASSERT(elements->type() == MIRType_Elements);
112231:         JS_ASSERT(index->type() == MIRType_Int32);
112231:     }
112231: 
112231:   public:
125300:     INSTRUCTION_HEADER(StoreElement)
112231: 
112258:     static MStoreElement *New(MDefinition *elements, MDefinition *index, MDefinition *value) {
112258:         return new MStoreElement(elements, index, value);
112231:     }
112524:     MDefinition *elements() const {
112524:         return getOperand(0);
112524:     }
112524:     MDefinition *index() const {
112524:         return getOperand(1);
112524:     }
112524:     MDefinition *value() const {
112524:         return getOperand(2);
112524:     }
112231:     TypePolicy *typePolicy() {
112231:         return this;
112231:     }
112474:     AliasSet getAliasSet() const {
112474:         return AliasSet::Store(AliasSet::Element);
112302:     }
112231: };
112231: 
112524: // Like MStoreElement, but supports indexes >= initialized length. The downside
112524: // is that we cannot hoist the elements vector and bounds check, since this
112524: // instruction may update the (initialized) length and reallocate the elements
112524: // vector.
112524: class MStoreElementHole
112524:   : public MAryInstruction<4>,
112524:     public MStoreElementCommon,
112691:     public SingleObjectPolicy
112524: {
112524:     MStoreElementHole(MDefinition *object, MDefinition *elements,
112524:                       MDefinition *index, MDefinition *value) {
112524:         initOperand(0, object);
112524:         initOperand(1, elements);
112524:         initOperand(2, index);
112524:         initOperand(3, value);
112524:         JS_ASSERT(elements->type() == MIRType_Elements);
112524:         JS_ASSERT(index->type() == MIRType_Int32);
112524:     }
112524: 
112524:   public:
125300:     INSTRUCTION_HEADER(StoreElementHole)
112524: 
112524:     static MStoreElementHole *New(MDefinition *object, MDefinition *elements,
112524:                                   MDefinition *index, MDefinition *value) {
112524:         return new MStoreElementHole(object, elements, index, value);
112524:     }
112524: 
112524:     MDefinition *object() const {
112524:         return getOperand(0);
112524:     }
112524:     MDefinition *elements() const {
112524:         return getOperand(1);
112524:     }
112524:     MDefinition *index() const {
112524:         return getOperand(2);
112524:     }
112524:     MDefinition *value() const {
112524:         return getOperand(3);
112524:     }
112524:     TypePolicy *typePolicy() {
112524:         return this;
112524:     }
112524:     AliasSet getAliasSet() const {
112524:         // StoreElementHole can update the initialized length, the array length
112524:         // or reallocate obj->elements.
112524:         return AliasSet::Store(AliasSet::Element | AliasSet::ObjectFields);
112524:     }
112524: };
112524: 
112949: // Array.prototype.pop or Array.prototype.shift on a dense array.
112949: class MArrayPopShift
112949:   : public MUnaryInstruction,
112949:     public SingleObjectPolicy
112949: {
112949:   public:
112949:     enum Mode {
112949:         Pop,
112949:         Shift
112949:     };
112949: 
112949:   private:
112949:     Mode mode_;
112949:     bool needsHoleCheck_;
112949:     bool maybeUndefined_;
112949: 
112949:     MArrayPopShift(MDefinition *object, Mode mode, bool needsHoleCheck, bool maybeUndefined)
112949:       : MUnaryInstruction(object), mode_(mode), needsHoleCheck_(needsHoleCheck),
112949:         maybeUndefined_(maybeUndefined)
112949:     { }
112949: 
112949:   public:
125300:     INSTRUCTION_HEADER(ArrayPopShift)
112949: 
112949:     static MArrayPopShift *New(MDefinition *object, Mode mode, bool needsHoleCheck,
112949:                                bool maybeUndefined) {
112949:         return new MArrayPopShift(object, mode, needsHoleCheck, maybeUndefined);
112949:     }
112949: 
112949:     MDefinition *object() const {
112949:         return getOperand(0);
112949:     }
112949:     bool needsHoleCheck() const {
112949:         return needsHoleCheck_;
112949:     }
112949:     bool maybeUndefined() const {
112949:         return maybeUndefined_;
112949:     }
112949:     bool mode() const {
112949:         return mode_;
112949:     }
112949:     TypePolicy *typePolicy() {
112949:         return this;
112949:     }
112949:     AliasSet getAliasSet() const {
112949:         return AliasSet::Store(AliasSet::Element | AliasSet::ObjectFields);
112949:     }
112949: };
112949: 
112950: // Array.prototype.push on a dense array. Returns the new array length.
112950: class MArrayPush
112950:   : public MBinaryInstruction,
112950:     public SingleObjectPolicy
112950: {
112950:     MArrayPush(MDefinition *object, MDefinition *value)
112950:       : MBinaryInstruction(object, value)
112950:     {
112950:         setResultType(MIRType_Int32);
112950:     }
112950: 
112950:   public:
125300:     INSTRUCTION_HEADER(ArrayPush)
112950: 
112950:     static MArrayPush *New(MDefinition *object, MDefinition *value) {
112950:         return new MArrayPush(object, value);
112950:     }
112950: 
112950:     MDefinition *object() const {
112950:         return getOperand(0);
112950:     }
112950:     MDefinition *value() const {
112950:         return getOperand(1);
112950:     }
112950:     TypePolicy *typePolicy() {
112950:         return this;
112950:     }
112950:     AliasSet getAliasSet() const {
112950:         return AliasSet::Store(AliasSet::Element | AliasSet::ObjectFields);
112950:     }
112950: };
112950: 
116300: // Array.prototype.concat on two dense arrays.
116300: class MArrayConcat
116300:   : public MBinaryInstruction,
116300:     public MixPolicy<ObjectPolicy<0>, ObjectPolicy<1> >
116300: {
116300:     CompilerRootObject templateObj_;
116300: 
116300:     MArrayConcat(MDefinition *lhs, MDefinition *rhs, HandleObject templateObj)
116300:       : MBinaryInstruction(lhs, rhs),
116300:         templateObj_(templateObj)
116300:     {
116300:         setResultType(MIRType_Object);
116300:     }
116300: 
116300:   public:
125300:     INSTRUCTION_HEADER(ArrayConcat)
116300: 
116300:     static MArrayConcat *New(MDefinition *lhs, MDefinition *rhs, HandleObject templateObj) {
116300:         return new MArrayConcat(lhs, rhs, templateObj);
116300:     }
116300: 
116300:     JSObject *templateObj() const {
116300:         return templateObj_;
116300:     }
116300:     TypePolicy *typePolicy() {
116300:         return this;
116300:     }
116300:     AliasSet getAliasSet() const {
116300:         return AliasSet::Store(AliasSet::Element | AliasSet::ObjectFields);
116300:     }
116300: };
116300: 
112904: class MLoadTypedArrayElement
112904:   : public MBinaryInstruction
112904: {
112904:     int arrayType_;
112904: 
112904:     MLoadTypedArrayElement(MDefinition *elements, MDefinition *index, int arrayType)
112904:       : MBinaryInstruction(elements, index), arrayType_(arrayType)
112904:     {
112904:         setResultType(MIRType_Value);
112904:         setMovable();
112904:         JS_ASSERT(elements->type() == MIRType_Elements);
112904:         JS_ASSERT(index->type() == MIRType_Int32);
112904:         JS_ASSERT(arrayType >= 0 && arrayType < TypedArray::TYPE_MAX);
112904:     }
112904: 
112904:   public:
125300:     INSTRUCTION_HEADER(LoadTypedArrayElement)
112904: 
112904:     static MLoadTypedArrayElement *New(MDefinition *elements, MDefinition *index, int arrayType) {
112904:         return new MLoadTypedArrayElement(elements, index, arrayType);
112904:     }
112904: 
112904:     int arrayType() const {
112904:         return arrayType_;
112904:     }
112904:     bool fallible() const {
112904:         // Bailout if the result does not fit in an int32.
112904:         return arrayType_ == TypedArray::TYPE_UINT32 && type() == MIRType_Int32;
112904:     }
112904:     MDefinition *elements() const {
112904:         return getOperand(0);
112904:     }
112904:     MDefinition *index() const {
112904:         return getOperand(1);
112904:     }
112904:     AliasSet getAliasSet() const {
112904:         return AliasSet::Load(AliasSet::TypedArrayElement);
112904:     }
112904: };
112904: 
112904: // Load a value from a typed array. Out-of-bounds accesses are handled using
112904: // a VM call.
112904: class MLoadTypedArrayElementHole
112904:   : public MBinaryInstruction,
112904:     public SingleObjectPolicy
112904: {
112904:     int arrayType_;
112904:     bool allowDouble_;
112904: 
112904:     MLoadTypedArrayElementHole(MDefinition *object, MDefinition *index, int arrayType, bool allowDouble)
112904:       : MBinaryInstruction(object, index), arrayType_(arrayType), allowDouble_(allowDouble)
112904:     {
112904:         setResultType(MIRType_Value);
112904:         setMovable();
112904:         JS_ASSERT(index->type() == MIRType_Int32);
112904:         JS_ASSERT(arrayType >= 0 && arrayType < TypedArray::TYPE_MAX);
112904:     }
112904: 
112904:   public:
125300:     INSTRUCTION_HEADER(LoadTypedArrayElementHole)
112904: 
112904:     static MLoadTypedArrayElementHole *New(MDefinition *object, MDefinition *index, int arrayType, bool allowDouble) {
112904:         return new MLoadTypedArrayElementHole(object, index, arrayType, allowDouble);
112904:     }
112904: 
112904:     int arrayType() const {
112904:         return arrayType_;
112904:     }
112904:     bool allowDouble() const {
112904:         return allowDouble_;
112904:     }
112904:     bool fallible() const {
112904:         return arrayType_ == TypedArray::TYPE_UINT32 && !allowDouble_;
112904:     }
112904:     TypePolicy *typePolicy() {
112904:         return this;
112904:     }
112904:     MDefinition *object() const {
112904:         return getOperand(0);
112904:     }
112904:     MDefinition *index() const {
112904:         return getOperand(1);
112904:     }
112904:     AliasSet getAliasSet() const {
112904:         // Out-of-bounds accesses are handled using a VM call, this may
112904:         // invoke getters on the prototype chain.
112904:         return AliasSet::Store(AliasSet::Any);
112904:     }
112904: };
112904: 
112936: class MStoreTypedArrayElement
112936:   : public MTernaryInstruction,
112936:     public StoreTypedArrayPolicy
112936: {
112936:     int arrayType_;
112936: 
112936:     MStoreTypedArrayElement(MDefinition *elements, MDefinition *index, MDefinition *value,
112936:                             int arrayType)
112936:       : MTernaryInstruction(elements, index, value), arrayType_(arrayType)
112936:     {
112936:         setResultType(MIRType_Value);
112936:         setMovable();
112936:         JS_ASSERT(elements->type() == MIRType_Elements);
112936:         JS_ASSERT(index->type() == MIRType_Int32);
112936:         JS_ASSERT(arrayType >= 0 && arrayType < TypedArray::TYPE_MAX);
112936:     }
112936: 
112936:   public:
125300:     INSTRUCTION_HEADER(StoreTypedArrayElement)
112936: 
112936:     static MStoreTypedArrayElement *New(MDefinition *elements, MDefinition *index, MDefinition *value,
112936:                                         int arrayType) {
112936:         return new MStoreTypedArrayElement(elements, index, value, arrayType);
112936:     }
112936: 
112936:     int arrayType() const {
112936:         return arrayType_;
112936:     }
112936:     bool isByteArray() const {
112936:         return (arrayType_ == TypedArray::TYPE_INT8 ||
112936:                 arrayType_ == TypedArray::TYPE_UINT8 ||
112936:                 arrayType_ == TypedArray::TYPE_UINT8_CLAMPED);
112936:     }
112936:     bool isFloatArray() const {
112936:         return (arrayType_ == TypedArray::TYPE_FLOAT32 ||
112936:                 arrayType_ == TypedArray::TYPE_FLOAT64);
112936:     }
112936:     TypePolicy *typePolicy() {
112936:         return this;
112936:     }
112936:     MDefinition *elements() const {
112936:         return getOperand(0);
112936:     }
112936:     MDefinition *index() const {
112936:         return getOperand(1);
112936:     }
112936:     MDefinition *value() const {
112936:         return getOperand(2);
112936:     }
112936:     AliasSet getAliasSet() const {
112936:         return AliasSet::Store(AliasSet::TypedArrayElement);
112936:     }
112936: };
112936: 
112936: // Clamp input to range [0, 255] for Uint8ClampedArray.
112936: class MClampToUint8
112936:   : public MUnaryInstruction,
112936:     public ClampPolicy
112936: {
112936:     MClampToUint8(MDefinition *input)
112936:       : MUnaryInstruction(input)
112936:     {
112936:         setResultType(MIRType_Int32);
112936:         setMovable();
112936:     }
112936: 
112936:   public:
125300:     INSTRUCTION_HEADER(ClampToUint8)
112936: 
112936:     static MClampToUint8 *New(MDefinition *input) {
112936:         return new MClampToUint8(input);
112936:     }
112936: 
112936:     MDefinition *foldsTo(bool useValueNumbers);
112936: 
112936:     MDefinition *input() const {
112936:         return getOperand(0);
112936:     }
112936:     TypePolicy *typePolicy() {
112936:         return this;
112936:     }
112936:     bool congruentTo(MDefinition *const &ins) const {
112936:         return congruentIfOperandsEqual(ins);
112936:     }
112936:     AliasSet getAliasSet() const {
112936:         return AliasSet::None();
112936:     }
123949:     void computeRange();
112936: };
112936: 
113176: class MLoadFixedSlot
113176:   : public MUnaryInstruction,
113176:     public SingleObjectPolicy
112467: {
112467:     size_t slot_;
112467: 
113176:   protected:
112467:     MLoadFixedSlot(MDefinition *obj, size_t slot)
112467:       : MUnaryInstruction(obj), slot_(slot)
112467:     {
112467:         setResultType(MIRType_Value);
113176:         setMovable();
112467:     }
112467: 
112467:   public:
125300:     INSTRUCTION_HEADER(LoadFixedSlot)
112467: 
112467:     static MLoadFixedSlot *New(MDefinition *obj, size_t slot) {
112467:         return new MLoadFixedSlot(obj, slot);
112467:     }
112467: 
112467:     TypePolicy *typePolicy() {
112467:         return this;
112467:     }
112467: 
112467:     MDefinition *object() const {
112467:         return getOperand(0);
112467:     }
112467:     size_t slot() const {
112467:         return slot_;
112467:     }
112474:     bool congruentTo(MDefinition * const &ins) const {
112474:         if (!ins->isLoadFixedSlot())
112474:             return false;
112474:         if (slot() != ins->toLoadFixedSlot()->slot())
112474:             return false;
112474:         return congruentIfOperandsEqual(ins);
112474:     }
112474: 
112474:     AliasSet getAliasSet() const {
112467:         return AliasSet::Load(AliasSet::Slot);
112467:     }
112467: };
112467: 
113176: class MStoreFixedSlot
113176:   : public MBinaryInstruction,
113176:     public SingleObjectPolicy
112467: {
112726:     bool needsBarrier_;
112467:     size_t slot_;
112467: 
113176:     MStoreFixedSlot(MDefinition *obj, MDefinition *rval, size_t slot, bool barrier)
113176:       : MBinaryInstruction(obj, rval),
113176:         needsBarrier_(barrier),
113176:         slot_(slot)
112467:     {}
112467: 
112467:   public:
125300:     INSTRUCTION_HEADER(StoreFixedSlot)
112467: 
113175:     static MStoreFixedSlot *New(MDefinition *obj, size_t slot, MDefinition *rval) {
113176:         return new MStoreFixedSlot(obj, rval, slot, false);
113176:     }
113176:     static MStoreFixedSlot *NewBarriered(MDefinition *obj, size_t slot, MDefinition *rval) {
113176:         return new MStoreFixedSlot(obj, rval, slot, true);
112467:     }
112467: 
112467:     TypePolicy *typePolicy() {
112467:         return this;
112467:     }
112467: 
112467:     MDefinition *object() const {
112467:         return getOperand(0);
112467:     }
112467:     MDefinition *value() const {
112467:         return getOperand(1);
112467:     }
112467:     size_t slot() const {
112467:         return slot_;
112467:     }
112467: 
112474:     AliasSet getAliasSet() const {
112467:         return AliasSet::Store(AliasSet::Slot);
112467:     }
112726:     bool needsBarrier() const {
112726:         return needsBarrier_;
112726:     }
112726:     void setNeedsBarrier() {
112726:         needsBarrier_ = true;
112726:     }
112467: };
112467: 
113482: class InlinePropertyTable : public TempObject
113482: {
113511:     struct Entry : public TempObject {
113494:         CompilerRoot<types::TypeObject *> typeObj;
113494:         CompilerRootFunction func;
113482: 
113482:         Entry(types::TypeObject *typeObj, JSFunction *func)
113511:           : typeObj(typeObj),
113511:             func(func)
113511:         {
113511:         }
113482:     };
113482:     jsbytecode *pc_;
113482:     MResumePoint *priorResumePoint_;
113511:     Vector<Entry *, 4, IonAllocPolicy> entries_;
113482: 
113482:   public:
113482:     InlinePropertyTable(jsbytecode *pc)
113511:       : pc_(pc),
113511:         priorResumePoint_(NULL),
113511:         entries_()
113511:     {
113511:     }
113482: 
113482:     void setPriorResumePoint(MResumePoint *resumePoint) {
113482:         JS_ASSERT(priorResumePoint_ == NULL);
113482:         priorResumePoint_ = resumePoint;
113482:     }
113482: 
113482:     MResumePoint *priorResumePoint() const {
113482:         return priorResumePoint_;
113482:     }
113482: 
113482:     jsbytecode *pc() const {
113482:         return pc_;
113482:     }
113482: 
113482:     bool addEntry(types::TypeObject *typeObj, JSFunction *func) {
113511:         return entries_.append(new Entry(typeObj, func));
113482:     }
113482: 
113482:     size_t numEntries() const {
113482:         return entries_.length();
113482:     }
113482: 
113482:     types::TypeObject *getTypeObject(size_t i) const {
113482:         JS_ASSERT(i < numEntries());
113511:         return entries_[i]->typeObj;
113482:     }
113482: 
113482:     JSFunction *getFunction(size_t i) const {
113482:         JS_ASSERT(i < numEntries());
113511:         return entries_[i]->func;
113482:     }
113482: 
113482:     void trimToTargets(AutoObjectVector &targets) {
113482:         size_t i = 0;
113482:         while (i < numEntries()) {
113482:             bool foundFunc = false;
113482:             for (size_t j = 0; j < targets.length(); j++) {
113511:                 if (entries_[i]->func == targets[j]) {
113482:                     foundFunc = true;
113482:                     break;
113482:                 }
113482:             }
113482:             if (!foundFunc)
113482:                 entries_.erase(&(entries_[i]));
113482:             else
113482:                 i++;
113482:         }
113482:     }
113482: };
113482: 
112315: class MGetPropertyCache
112315:   : public MUnaryInstruction,
112691:     public SingleObjectPolicy
112315: {
113095:     CompilerRootPropertyName name_;
113386:     bool idempotent_;
116062:     bool allowGetters_;
113095: 
113482:     InlinePropertyTable *inlinePropertyTable_;
113482: 
113095:     MGetPropertyCache(MDefinition *obj, HandlePropertyName name)
112315:       : MUnaryInstruction(obj),
113386:         name_(name),
113482:         idempotent_(false),
116062:         allowGetters_(false),
113482:         inlinePropertyTable_(NULL)
112315:     {
112315:         setResultType(MIRType_Value);
113386: 
113386:         // The cache will invalidate if there are objects with e.g. lookup or
113386:         // resolve hooks on the proto chain. setGuard ensures this check is not
113386:         // eliminated.
113386:         setGuard();
112315:     }
112315: 
112315:   public:
125300:     INSTRUCTION_HEADER(GetPropertyCache)
112315: 
113095:     static MGetPropertyCache *New(MDefinition *obj, HandlePropertyName name) {
113095:         return new MGetPropertyCache(obj, name);
112315:     }
112315: 
113482:     InlinePropertyTable *initInlinePropertyTable(jsbytecode *pc) {
113482:         JS_ASSERT(inlinePropertyTable_ == NULL);
113482:         inlinePropertyTable_ = new InlinePropertyTable(pc);
113482:         return inlinePropertyTable_;
113482:     }
113482: 
113482:     void clearInlinePropertyTable() {
113482:         inlinePropertyTable_ = NULL;
113482:     }
113482: 
113482:     InlinePropertyTable *inlinePropertyTable() const {
113482:         return inlinePropertyTable_;
113482:     }
113482: 
112315:     MDefinition *object() const {
112315:         return getOperand(0);
112315:     }
113095:     PropertyName *name() const {
113095:         return name_;
112315:     }
113386:     bool idempotent() const {
113386:         return idempotent_;
113386:     }
113386:     void setIdempotent() {
113386:         idempotent_ = true;
113386:         setMovable();
113386:     }
116062:     bool allowGetters() const {
116062:         return allowGetters_;
116062:     }
116062:     void setAllowGetters() {
116062:         allowGetters_ = true;
116062:     }
112315:     TypePolicy *typePolicy() { return this; }
113386: 
113386:     bool congruentTo(MDefinition * const &ins) const {
113386:         if (!idempotent_)
113386:             return false;
113386:         if (!ins->isGetPropertyCache())
113386:             return false;
113386:         if (name() != ins->toGetPropertyCache()->name())
113386:             return false;
113386:         return congruentIfOperandsEqual(ins);
113386:     }
113386: 
113386:     AliasSet getAliasSet() const {
113386:         if (idempotent_)
113386:             return AliasSet::Load(AliasSet::ObjectFields | AliasSet::Slot);
113386:         return AliasSet::Store(AliasSet::Any);
113386:     }
113386: 
112315: };
112315: 
113482: // Represents a polymorphic dispatch to one or more functions.
113482: class MPolyInlineDispatch : public MControlInstruction, public SingleObjectPolicy
113482: {
113482:     // A table to map JSFunctions to the blocks that execute them.
113482:     struct Entry {
113482:         MConstant *funcConst;
113482:         MBasicBlock *block;
113482:         Entry(MConstant *funcConst, MBasicBlock *block)
113482:             : funcConst(funcConst), block(block) {}
113482:     };
113482:     Vector<Entry, 4, IonAllocPolicy> dispatchTable_;
113482: 
113482:     MDefinition *operand_;
113482:     InlinePropertyTable *inlinePropertyTable_;
113482:     MBasicBlock *fallbackPrepBlock_;
113482:     MBasicBlock *fallbackMidBlock_;
113482:     MBasicBlock *fallbackEndBlock_;
113482: 
113482:     MPolyInlineDispatch(MDefinition *ins)
113482:       : dispatchTable_(), operand_(NULL),
113482:         inlinePropertyTable_(NULL),
113482:         fallbackPrepBlock_(NULL),
113482:         fallbackMidBlock_(NULL),
113482:         fallbackEndBlock_(NULL)
113482:     {
113482:         initOperand(0, ins);
113482:     }
113482: 
113482:     MPolyInlineDispatch(MDefinition *ins, InlinePropertyTable *inlinePropertyTable,
113482:                         MBasicBlock *fallbackPrepBlock,
113482:                         MBasicBlock *fallbackMidBlock,
113482:                         MBasicBlock *fallbackEndBlock)
113482:       : dispatchTable_(), operand_(NULL),
113482:         inlinePropertyTable_(inlinePropertyTable),
113482:         fallbackPrepBlock_(fallbackPrepBlock),
113482:         fallbackMidBlock_(fallbackMidBlock),
113482:         fallbackEndBlock_(fallbackEndBlock)
113482:     {
113482:         initOperand(0, ins);
113482:     }
113482: 
113482:   protected:
113482:     virtual void setOperand(size_t index, MDefinition *operand) {
113482:         JS_ASSERT(index == 0);
113482:         operand_ = operand;
113482:     }
113482: 
113482:     void setSuccessor(size_t i, MBasicBlock *successor) {
113482:         JS_ASSERT(i < numSuccessors());
113482:         if (inlinePropertyTable_ && (i == numSuccessors() - 1))
113482:             fallbackPrepBlock_ = successor;
113482:         else
113482:             dispatchTable_[i].block = successor;
113482:     }
113482: 
113482:   public:
125300:     INSTRUCTION_HEADER(PolyInlineDispatch)
113482: 
113482:     virtual MDefinition *getOperand(size_t index) const {
113482:         JS_ASSERT(index == 0);
113482:         return operand_;
113482:     }
113482: 
113482:     virtual size_t numOperands() const {
113482:         return 1;
113482:     }
113482:     virtual size_t numSuccessors() const {
113482:         return dispatchTable_.length() + (inlinePropertyTable_ ? 1 : 0);
113482:     }
113482: 
113482:     virtual void replaceSuccessor(size_t i, MBasicBlock *successor) {
113482:         setSuccessor(i, successor);
113482:     }
113482: 
113482:     MBasicBlock *getSuccessor(size_t i) const {
113482:         JS_ASSERT(i < numSuccessors());
113482:         if (inlinePropertyTable_ && (i == numSuccessors() - 1))
113482:             return fallbackPrepBlock_;
113482:         else
113482:             return dispatchTable_[i].block;
113482:     }
113482: 
113482:     static MPolyInlineDispatch *New(MDefinition *ins) {
113482:         return new MPolyInlineDispatch(ins);
113482:     }
113482: 
113482:     static MPolyInlineDispatch *New(MDefinition *ins, InlinePropertyTable *inlinePropTable,
113482:                                     MBasicBlock *fallbackPrepBlock,
113482:                                     MBasicBlock *fallbackMidBlock,
113482:                                     MBasicBlock *fallbackEndBlock)
113482:     {
113482:         return new MPolyInlineDispatch(ins, inlinePropTable,
113482:                                        fallbackPrepBlock,
113482:                                        fallbackMidBlock,
113482:                                        fallbackEndBlock);
113482:     }
113482: 
113482:     size_t numCallees() const {
113482:         return dispatchTable_.length();
113482:     }
113482: 
113482:     void addCallee(MConstant *funcConst, MBasicBlock *block) {
113482:         dispatchTable_.append(Entry(funcConst, block));
113482:     }
113482: 
113482:     MConstant *getFunctionConstant(size_t i) const {
113482:         JS_ASSERT(i < numCallees());
113482:         return dispatchTable_[i].funcConst;
113482:     }
113482: 
113482:     JSFunction *getFunction(size_t i) const {
113482:         return getFunctionConstant(i)->value().toObject().toFunction();
113482:     }
113482: 
113482:     MBasicBlock *getFunctionBlock(size_t i) const {
113482:         JS_ASSERT(i < numCallees());
113482:         return dispatchTable_[i].block;
113482:     }
113482: 
113482:     MBasicBlock *getFunctionBlock(JSFunction *func) const {
113482:         for (size_t i = 0; i < numCallees(); i++) {
113482:             if (getFunction(i) == func)
113482:                 return getFunctionBlock(i);
113482:         }
113482:         JS_NOT_REACHED("Bad function lookup!");
113482:     }
113482: 
113482:     InlinePropertyTable *inlinePropertyTable() const {
113482:         return inlinePropertyTable_;
113482:     }
113482: 
113482:     MBasicBlock *fallbackPrepBlock() const {
113482:         JS_ASSERT(inlinePropertyTable_ != NULL);
113482:         return fallbackPrepBlock_;
113482:     }
113482: 
113482:     MBasicBlock *fallbackMidBlock() const {
113482:         JS_ASSERT(inlinePropertyTable_ != NULL);
113482:         return fallbackMidBlock_;
113482:     }
113482: 
113482:     MBasicBlock *fallbackEndBlock() const {
113482:         JS_ASSERT(inlinePropertyTable_ != NULL);
113482:         return fallbackEndBlock_;
113482:     }
113482: 
113482:     MDefinition *input() const {
113482:         return getOperand(0);
113482:     }
113482: 
113482:     TypePolicy *typePolicy() {
113482:         return this;
113482:     }
113482: };
113482: 
113482: 
113482: 
112859: class MGetElementCache
112859:   : public MBinaryInstruction,
112859:     public MixPolicy<ObjectPolicy<0>, BoxPolicy<1> >
112859: {
112859:     // See the comment in IonBuilder::jsop_getelem.
112859:     bool monitoredResult_;
112859: 
112859:     MGetElementCache(MDefinition *obj, MDefinition *value, bool monitoredResult)
112859:       : MBinaryInstruction(obj, value), monitoredResult_(monitoredResult)
112859:     {
112859:         setResultType(MIRType_Value);
112859:     }
112859: 
112859:   public:
125300:     INSTRUCTION_HEADER(GetElementCache)
112859: 
112859:     static MGetElementCache *New(MDefinition *obj, MDefinition *value, bool monitoredResult) {
112859:         return new MGetElementCache(obj, value, monitoredResult);
112859:     }
112859: 
112859:     MDefinition *object() const {
112859:         return getOperand(0);
112859:     }
112859:     MDefinition *index() const {
112859:         return getOperand(1);
112859:     }
112859:     bool monitoredResult() const {
112859:         return monitoredResult_;
112859:     }
112859:     TypePolicy *typePolicy() {
112859:         return this;
112859:     }
112859: };
112859: 
112766: class MBindNameCache
112766:   : public MUnaryInstruction,
112766:     public SingleObjectPolicy
112766: {
112766:     PropertyName *name_;
112766:     JSScript *script_;
112766:     jsbytecode *pc_;
112766: 
112766:     MBindNameCache(MDefinition *scopeChain, PropertyName *name, JSScript *script, jsbytecode *pc)
112766:       : MUnaryInstruction(scopeChain), name_(name), script_(script), pc_(pc)
112766:     {
112766:         setResultType(MIRType_Object);
112766:     }
112766: 
112766:   public:
125300:     INSTRUCTION_HEADER(BindNameCache)
112766: 
112766:     static MBindNameCache *New(MDefinition *scopeChain, PropertyName *name, JSScript *script,
112766:                                jsbytecode *pc) {
112766:         return new MBindNameCache(scopeChain, name, script, pc);
112766:     }
112766: 
112766:     TypePolicy *typePolicy() {
112766:         return this;
112766:     }
112766:     MDefinition *scopeChain() const {
112766:         return getOperand(0);
112766:     }
112766:     PropertyName *name() const {
112766:         return name_;
112766:     }
112766:     JSScript *script() const {
112766:         return script_;
112766:     }
112766:     jsbytecode *pc() const {
112766:         return pc_;
112766:     }
112766: };
112766: 
112118: // Guard on an object's shape.
112118: class MGuardShape
112118:   : public MUnaryInstruction,
112691:     public SingleObjectPolicy
112118: {
112118:     const Shape *shape_;
114366:     BailoutKind bailoutKind_;
114366: 
114366:     MGuardShape(MDefinition *obj, const Shape *shape, BailoutKind bailoutKind)
112118:       : MUnaryInstruction(obj),
114366:         shape_(shape),
114366:         bailoutKind_(bailoutKind)
112118:     {
112118:         setGuard();
112302:         setMovable();
120777:         setResultType(MIRType_Object);
112118:     }
112118: 
112118:   public:
125300:     INSTRUCTION_HEADER(GuardShape)
112118: 
114366:     static MGuardShape *New(MDefinition *obj, const Shape *shape, BailoutKind bailoutKind) {
114366:         return new MGuardShape(obj, shape, bailoutKind);
112118:     }
112118: 
112118:     TypePolicy *typePolicy() {
112118:         return this;
112118:     }
112118:     MDefinition *obj() const {
112118:         return getOperand(0);
112118:     }
112118:     const Shape *shape() const {
112118:         return shape_;
112118:     }
114366:     BailoutKind bailoutKind() const {
114366:         return bailoutKind_;
114366:     }
112118:     bool congruentTo(MDefinition * const &ins) const {
112118:         if (!ins->isGuardShape())
112118:             return false;
112118:         if (shape() != ins->toGuardShape()->shape())
112118:             return false;
114366:         if (bailoutKind() != ins->toGuardShape()->bailoutKind())
114366:             return false;
112474:         return congruentIfOperandsEqual(ins);
112118:     }
112302:     AliasSet getAliasSet() const {
112302:         return AliasSet::Load(AliasSet::ObjectFields);
112302:     }
112118: };
112118: 
112259: // Guard on an object's class.
112259: class MGuardClass
112259:   : public MUnaryInstruction,
112691:     public SingleObjectPolicy
112259: {
112259:     const Class *class_;
112259: 
112259:     MGuardClass(MDefinition *obj, const Class *clasp)
112259:       : MUnaryInstruction(obj),
112259:         class_(clasp)
112259:     {
112259:         setGuard();
112302:         setMovable();
112259:     }
112259: 
112259:   public:
125300:     INSTRUCTION_HEADER(GuardClass)
112259: 
112259:     static MGuardClass *New(MDefinition *obj, const Class *clasp) {
112259:         return new MGuardClass(obj, clasp);
112259:     }
112259: 
112259:     TypePolicy *typePolicy() {
112259:         return this;
112259:     }
112259:     MDefinition *obj() const {
112259:         return getOperand(0);
112259:     }
112259:     const Class *getClass() const {
112259:         return class_;
112259:     }
112259:     bool congruentTo(MDefinition * const &ins) const {
112259:         if (!ins->isGuardClass())
112259:             return false;
112259:         if (getClass() != ins->toGuardClass()->getClass())
112259:             return false;
112474:         return congruentIfOperandsEqual(ins);
112474:     }
112474:     AliasSet getAliasSet() const {
112302:         return AliasSet::Load(AliasSet::ObjectFields);
112302:     }
112259: };
112259: 
112118: // Load from vp[slot] (slots that are not inline in an object).
112118: class MLoadSlot
112118:   : public MUnaryInstruction,
112691:     public SingleObjectPolicy
112118: {
124795:     uint32_t slot_;
124795: 
124795:     MLoadSlot(MDefinition *slots, uint32_t slot)
112193:       : MUnaryInstruction(slots),
112118:         slot_(slot)
112118:     {
112118:         setResultType(MIRType_Value);
112302:         setMovable();
113544:         JS_ASSERT(slots->type() == MIRType_Slots);
112118:     }
112118: 
112118:   public:
125300:     INSTRUCTION_HEADER(LoadSlot)
112118: 
124795:     static MLoadSlot *New(MDefinition *slots, uint32_t slot) {
112193:         return new MLoadSlot(slots, slot);
112118:     }
112118: 
112118:     TypePolicy *typePolicy() {
112118:         return this;
112118:     }
112193:     MDefinition *slots() const {
112118:         return getOperand(0);
112118:     }
124795:     uint32_t slot() const {
112118:         return slot_;
112118:     }
112118:     bool congruentTo(MDefinition * const &ins) const {
112118:         if (!ins->isLoadSlot())
112118:             return false;
112118:         if (slot() != ins->toLoadSlot()->slot())
112118:             return false;
112474:         return congruentIfOperandsEqual(ins);
112474:     }
112474:     AliasSet getAliasSet() const {
113544:         JS_ASSERT(slots()->type() == MIRType_Slots);
112302:         return AliasSet::Load(AliasSet::Slot);
112302:     }
112118: };
112118: 
112401: // Inline call to access a function's environment (scope chain).
112401: class MFunctionEnvironment
112401:   : public MUnaryInstruction,
112691:     public SingleObjectPolicy
112401: {
112401:   public:
112401:     MFunctionEnvironment(MDefinition *function)
112401:         : MUnaryInstruction(function)
112401:     {
112401:         setResultType(MIRType_Object);
112401:     }
112401: 
125300:     INSTRUCTION_HEADER(FunctionEnvironment)
112401: 
112401:     static MFunctionEnvironment *New(MDefinition *function) {
112401:         return new MFunctionEnvironment(function);
112401:     }
112401: 
112401:     MDefinition *function() const {
112401:         return getOperand(0);
112401:     }
112401: };
112401: 
112193: // Store to vp[slot] (slots that are not inline in an object).
112193: class MStoreSlot
112193:   : public MBinaryInstruction,
112691:     public SingleObjectPolicy
112193: {
124795:     uint32_t slot_;
112193:     MIRType slotType_;
112199:     bool needsBarrier_;
112193: 
124795:     MStoreSlot(MDefinition *slots, uint32_t slot, MDefinition *value, bool barrier)
112193:         : MBinaryInstruction(slots, value),
112193:           slot_(slot),
113010:           slotType_(MIRType_Value),
113176:           needsBarrier_(barrier)
112193:     {
112193:         JS_ASSERT(slots->type() == MIRType_Slots);
112193:     }
112193: 
112193:   public:
125300:     INSTRUCTION_HEADER(StoreSlot)
112193: 
124795:     static MStoreSlot *New(MDefinition *slots, uint32_t slot, MDefinition *value) {
113176:         return new MStoreSlot(slots, slot, value, false);
113176:     }
124795:     static MStoreSlot *NewBarriered(MDefinition *slots, uint32_t slot, MDefinition *value) {
113176:         return new MStoreSlot(slots, slot, value, true);
112193:     }
112193: 
112193:     TypePolicy *typePolicy() {
112193:         return this;
112193:     }
112193:     MDefinition *slots() const {
112193:         return getOperand(0);
112193:     }
112193:     MDefinition *value() const {
112193:         return getOperand(1);
112193:     }
124795:     uint32_t slot() const {
112193:         return slot_;
112193:     }
112193:     MIRType slotType() const {
112193:         return slotType_;
112193:     }
112193:     void setSlotType(MIRType slotType) {
112193:         JS_ASSERT(slotType != MIRType_None);
112193:         slotType_ = slotType;
112193:     }
112199:     bool needsBarrier() const {
112199:         return needsBarrier_;
112199:     }
113423:     void setNeedsBarrier() {
113423:         needsBarrier_ = true;
112199:     }
112474:     AliasSet getAliasSet() const {
112302:         return AliasSet::Store(AliasSet::Slot);
112302:     }
112193: };
112193: 
113177: class MGetNameCache
112289:   : public MUnaryInstruction,
112691:     public SingleObjectPolicy
112289: {
112401:   public:
112401:     enum AccessKind {
112401:         NAMETYPEOF,
112401:         NAME
112401:     };
112401: 
112401:   private:
113095:     CompilerRootPropertyName name_;
112401:     AccessKind kind_;
112401: 
113177:     MGetNameCache(MDefinition *obj, HandlePropertyName name, AccessKind kind)
112289:       : MUnaryInstruction(obj),
113095:         name_(name),
112401:         kind_(kind)
112289:     {
112289:         setResultType(MIRType_Value);
112289:     }
112289: 
112401:   public:
125300:     INSTRUCTION_HEADER(GetNameCache)
113177: 
113177:     static MGetNameCache *New(MDefinition *obj, HandlePropertyName name, AccessKind kind) {
113177:         return new MGetNameCache(obj, name, kind);
113177:     }
112289:     TypePolicy *typePolicy() {
112289:         return this;
112289:     }
113177:     MDefinition *scopeObj() const {
112289:         return getOperand(0);
112289:     }
113095:     PropertyName *name() const {
113095:         return name_;
112289:     }
112401:     AccessKind accessKind() const {
112401:         return kind_;
112401:     }
112309: };
112309: 
122024: class MCallGetIntrinsicValue : public MNullaryInstruction
122024: {
122024:     CompilerRootPropertyName name_;
122024: 
122024:     MCallGetIntrinsicValue(HandlePropertyName name)
122024:       : name_(name)
122024:     {
122024:         setResultType(MIRType_Value);
122024:     }
122024: 
122024:   public:
125300:     INSTRUCTION_HEADER(CallGetIntrinsicValue)
122024: 
122024:     static MCallGetIntrinsicValue *New(HandlePropertyName name) {
122024:         return new MCallGetIntrinsicValue(name);
122024:     }
122024:     PropertyName *name() const {
122024:         return name_;
122024:     }
122024: };
122024: 
112675: class MSetPropertyInstruction : public MBinaryInstruction
112445: {
113095:     CompilerRootPropertyName name_;
112445:     bool strict_;
112726:     bool needsBarrier_;
112675: 
112675:   protected:
113095:     MSetPropertyInstruction(MDefinition *obj, MDefinition *value, HandlePropertyName name,
112675:                             bool strict)
112445:       : MBinaryInstruction(obj, value),
113095:         name_(name), strict_(strict), needsBarrier_(true)
112445:     {}
112445: 
112445:   public:
112445:     MDefinition *obj() const {
112445:         return getOperand(0);
112445:     }
112445:     MDefinition *value() const {
112445:         return getOperand(1);
112445:     }
113095:     PropertyName *name() const {
113095:         return name_;
112445:     }
112445:     bool strict() const {
112445:         return strict_;
112445:     }
112726:     bool needsBarrier() const {
112726:         return needsBarrier_;
112726:     }
112726:     void setNeedsBarrier() {
112726:         needsBarrier_ = true;
112726:     }
112675: };
112675: 
112834: class MDeleteProperty
112834:   : public MUnaryInstruction,
112834:     public BoxInputsPolicy
112834: {
114101:     CompilerRootPropertyName name_;
112834: 
112834:   protected:
114101:     MDeleteProperty(MDefinition *val, HandlePropertyName name)
112834:       : MUnaryInstruction(val),
114101:         name_(name)
112834:     {
112834:         setResultType(MIRType_Boolean);
112834:     }
112834: 
112834:   public:
125300:     INSTRUCTION_HEADER(DeleteProperty)
112834: 
114101:     static MDeleteProperty *New(MDefinition *obj, HandlePropertyName name) {
114101:         return new MDeleteProperty(obj, name);
112834:     }
112834:     MDefinition *value() const {
112834:         return getOperand(0);
112834:     }
114101:     PropertyName *name() const {
114101:         return name_;
112834:     }
112834:     virtual TypePolicy *typePolicy() {
112834:         return this;
112834:     }
112834: };
112834: 
112675: // Note: This uses CallSetElementPolicy to always box its second input,
112675: // ensuring we don't need two LIR instructions to lower this.
112675: class MCallSetProperty
112675:   : public MSetPropertyInstruction,
112675:     public CallSetElementPolicy
112675: {
113095:     MCallSetProperty(MDefinition *obj, MDefinition *value, HandlePropertyName name, bool strict)
113095:       : MSetPropertyInstruction(obj, value, name, strict)
112675:     {
112675:     }
112675: 
112675:   public:
125300:     INSTRUCTION_HEADER(CallSetProperty)
112675: 
113095:     static MCallSetProperty *New(MDefinition *obj, MDefinition *value, HandlePropertyName name, bool strict) {
113095:         return new MCallSetProperty(obj, value, name, strict);
112675:     }
112675: 
112675:     TypePolicy *typePolicy() {
112675:         return this;
112675:     }
112675: };
112675: 
112675: class MSetPropertyCache
112675:   : public MSetPropertyInstruction,
112691:     public SingleObjectPolicy
112675: {
113095:     MSetPropertyCache(MDefinition *obj, MDefinition *value, HandlePropertyName name, bool strict)
113095:       : MSetPropertyInstruction(obj, value, name, strict)
112675:     {
112675:     }
112675: 
112675:   public:
125300:     INSTRUCTION_HEADER(SetPropertyCache)
112675: 
113095:     static MSetPropertyCache *New(MDefinition *obj, MDefinition *value, HandlePropertyName name, bool strict) {
113095:         return new MSetPropertyCache(obj, value, name, strict);
112675:     }
112675: 
112450:     TypePolicy *typePolicy() {
112450:         return this;
112450:     }
112445: };
112445: 
112706: class MCallGetProperty
112706:   : public MUnaryInstruction,
112706:     public BoxInputsPolicy
112401: {
113095:     CompilerRootPropertyName name_;
124555:     bool idempotent_;
112706: 
113095:     MCallGetProperty(MDefinition *value, HandlePropertyName name)
113095:       : MUnaryInstruction(value), name_(name),
124555:         idempotent_(false)
112706:     {
112706:         setResultType(MIRType_Value);
112706:     }
112401: 
112401:   public:
125300:     INSTRUCTION_HEADER(CallGetProperty)
112401: 
113095:     static MCallGetProperty *New(MDefinition *value, HandlePropertyName name) {
113095:         return new MCallGetProperty(value, name);
112706:     }
112706:     MDefinition *value() const {
112706:         return getOperand(0);
112706:     }
113095:     PropertyName *name() const {
113095:         return name_;
112706:     }
112706:     TypePolicy *typePolicy() {
112706:         return this;
112401:     }
112874: 
112874:     // Constructors need to perform a GetProp on the function prototype.
112874:     // Since getters cannot be set on the prototype, fetching is non-effectful.
112874:     // The operation may be safely repeated in case of bailout.
124555:     void setIdempotent() {
124555:         idempotent_ = true;
112874:     }
112874:     AliasSet getAliasSet() const {
124555:         if (!idempotent_)
112874:             return AliasSet::Store(AliasSet::Any);
112874:         return AliasSet::None();
112874:     }
112401: };
112401: 
112486: // Inline call to handle lhs[rhs]. The first input is a Value so that this
112486: // instruction can handle both objects and strings.
112486: class MCallGetElement
112486:   : public MBinaryInstruction,
112486:     public BoxInputsPolicy
112486: {
112486:     MCallGetElement(MDefinition *lhs, MDefinition *rhs)
112486:       : MBinaryInstruction(lhs, rhs)
112486:     {
112486:         setResultType(MIRType_Value);
112486:     }
112486: 
112486:   public:
125300:     INSTRUCTION_HEADER(CallGetElement)
112486: 
112486:     static MCallGetElement *New(MDefinition *lhs, MDefinition *rhs) {
112486:         return new MCallGetElement(lhs, rhs);
112486:     }
112486:     TypePolicy *typePolicy() {
112486:         return this;
112486:     }
112486: };
112486: 
112487: class MCallSetElement
112487:   : public MAryInstruction<3>,
112487:     public CallSetElementPolicy
112487: {
112487:     MCallSetElement(MDefinition *object, MDefinition *index, MDefinition *value) {
112487:         initOperand(0, object);
112487:         initOperand(1, index);
112487:         initOperand(2, value);
112487:     }
112487: 
112487:   public:
125300:     INSTRUCTION_HEADER(CallSetElement)
112487: 
112487:     static MCallSetElement *New(MDefinition *object, MDefinition *index, MDefinition *value) {
112487:         return new MCallSetElement(object, index, value);
112487:     }
112487: 
112487:     TypePolicy *typePolicy() {
112487:         return this;
112487:     }
112487:     MDefinition *object() const {
112487:         return getOperand(0);
112487:     }
112487:     MDefinition *index() const {
112487:         return getOperand(1);
112487:     }
112487:     MDefinition *value() const {
112487:         return getOperand(2);
112487:     }
112487: };
112487: 
113515: class MSetDOMProperty
113515:   : public MAryInstruction<2>,
113515:     public MixPolicy<ObjectPolicy<0>, BoxPolicy<1> >
113515: {
113515:     const JSJitPropertyOp func_;
113515: 
113515:     MSetDOMProperty(const JSJitPropertyOp func, MDefinition *obj, MDefinition *val)
113515:       : func_(func)
113515:     {
113515:         initOperand(0, obj);
113515:         initOperand(1, val);
113515:     }
113515: 
113515:   public:
125300:     INSTRUCTION_HEADER(SetDOMProperty)
113515: 
113515:     static MSetDOMProperty *New(const JSJitPropertyOp func, MDefinition *obj, MDefinition *val)
113515:     {
113515:         return new MSetDOMProperty(func, obj, val);
113515:     }
113515: 
113515:     const JSJitPropertyOp fun() {
113515:         return func_;
113515:     }
113515: 
113515:     MDefinition *object() {
113515:         return getOperand(0);
113515:     }
113515: 
113515:     MDefinition *value()
113515:     {
113515:         return getOperand(1);
113515:     }
113515: 
113515:     TypePolicy *typePolicy() {
113515:         return this;
113515:     }
113515: };
113515: 
113515: class MGetDOMProperty
124266:   : public MAryInstruction<2>,
113515:     public ObjectPolicy<0>
113515: {
124266:     const JSJitInfo *info_;
124266: 
124266:     MGetDOMProperty(const JSJitInfo *jitinfo, MDefinition *obj, MDefinition *guard)
124266:       : info_(jitinfo)
124266:     {
124266:         JS_ASSERT(jitinfo);
124266: 
113515:         initOperand(0, obj);
113515: 
124266:         // Pin the guard as an operand if we want to hoist later
124266:         initOperand(1, guard);
124266: 
124266:         // We are movable iff the jitinfo says we can be.
124266:         if (jitinfo->isConstant)
124266:             setMovable();
124266: 
113515:         setResultType(MIRType_Value);
113515:     }
113515: 
124266:   protected:
124266:     const JSJitInfo *info() const {
124266:         return info_;
124266:     }
124266: 
113515:   public:
125300:     INSTRUCTION_HEADER(GetDOMProperty)
113515: 
124266:     static MGetDOMProperty *New(const JSJitInfo *info, MDefinition *obj, MDefinition *guard)
124266:     {
124266:         return new MGetDOMProperty(info, obj, guard);
113515:     }
113515: 
113515:     const JSJitPropertyOp fun() {
124266:         return info_->op;
124266:     }
124266:     bool isInfallible() const {
124266:         return info_->isInfallible;
124266:     }
124266:     bool isDomConstant() const {
124266:         return info_->isConstant;
113515:     }
113515:     MDefinition *object() {
113515:         return getOperand(0);
113515:     }
113515: 
113515:     TypePolicy *typePolicy() {
113515:         return this;
113515:     }
124266: 
124266:     bool congruentTo(MDefinition *const &ins) const {
124266:         if (!isDomConstant())
124266:             return false;
124266: 
124266:         if (!ins->isGetDOMProperty())
124266:             return false;
124266: 
124266:         // Checking the jitinfo is the same as checking the constant function
124266:         if (!(info() == ins->toGetDOMProperty()->info()))
124266:             return false;
124266: 
124266:         return congruentIfOperandsEqual(ins);
124266:     }
124266: 
124266:     AliasSet getAliasSet() const {
124266:         // The whole point of constancy is that it's non-effectful and doesn't
124266:         // conflict with anything
124266:         if (isDomConstant())
124266:             return AliasSet::None();
124266:         return AliasSet::Store(AliasSet::Any);
124266:     }
124266: 
113515: };
113515: 
112309: class MStringLength
112309:   : public MUnaryInstruction,
112309:     public StringPolicy
112309: {
112309:     MStringLength(MDefinition *string)
112309:       : MUnaryInstruction(string)
112309:     {
112309:         setResultType(MIRType_Int32);
112309:         setMovable();
112309:     }
112714:   public:
125300:     INSTRUCTION_HEADER(StringLength)
112309: 
112714:     static MStringLength *New(MDefinition *string) {
112714:         return new MStringLength(string);
112714:     }
112714: 
113429:     MDefinition *foldsTo(bool useValueNumbers);
113429: 
112309:     TypePolicy *typePolicy() {
112309:         return this;
112309:     }
112309: 
112309:     MDefinition *string() const {
112309:         return getOperand(0);
112309:     }
112474:     bool congruentTo(MDefinition *const &ins) const {
112474:         return congruentIfOperandsEqual(ins);
112474:     }
112474:     AliasSet getAliasSet() const {
113164:         // The string |length| property is immutable, so there is no
113164:         // implicit dependency.
113164:         return AliasSet::None();
112309:     }
112289: };
112289: 
113021: // Inlined version of Math.floor().
113021: class MFloor
113021:   : public MUnaryInstruction,
113021:     public DoublePolicy<0>
113021: {
113021:   public:
113021:     MFloor(MDefinition *num)
113021:       : MUnaryInstruction(num)
113021:     {
113021:         setResultType(MIRType_Int32);
113021:         setMovable();
113021:     }
113021: 
125300:     INSTRUCTION_HEADER(Floor)
113021: 
113021:     MDefinition *num() const {
113021:         return getOperand(0);
113021:     }
113021:     AliasSet getAliasSet() const {
113021:         return AliasSet::None();
113021:     }
113021:     TypePolicy *typePolicy() {
113021:         return this;
113021:     }
113021: };
113021: 
113021: // Inlined version of Math.round().
112655: class MRound
112750:   : public MUnaryInstruction,
112750:     public DoublePolicy<0>
112655: {
112655:   public:
113021:     MRound(MDefinition *num)
113021:       : MUnaryInstruction(num)
112655:     {
112655:         setResultType(MIRType_Int32);
112655:         setMovable();
112655:     }
112655: 
125300:     INSTRUCTION_HEADER(Round)
112655: 
112655:     MDefinition *num() const {
112655:         return getOperand(0);
112655:     }
112750:     AliasSet getAliasSet() const {
112655:         return AliasSet::None();
112655:     }
112750:     TypePolicy *typePolicy() {
112750:         return this;
112750:     }
112655: };
112655: 
112663: class MIteratorStart
112663:   : public MUnaryInstruction,
112691:     public SingleObjectPolicy
112663: {
124795:     uint8_t flags_;
124795: 
124795:     MIteratorStart(MDefinition *obj, uint8_t flags)
112663:       : MUnaryInstruction(obj), flags_(flags)
112663:     {
112663:         setResultType(MIRType_Object);
112663:     }
112663: 
112663:   public:
125300:     INSTRUCTION_HEADER(IteratorStart)
112663: 
124795:     static MIteratorStart *New(MDefinition *obj, uint8_t flags) {
112663:         return new MIteratorStart(obj, flags);
112663:     }
112663: 
112663:     TypePolicy *typePolicy() {
112663:         return this;
112663:     }
112663:     MDefinition *object() const {
112663:         return getOperand(0);
112663:     }
124795:     uint8_t flags() const {
112663:         return flags_;
112663:     }
112663: };
112663: 
112663: class MIteratorNext
112663:   : public MUnaryInstruction,
112691:     public SingleObjectPolicy
112663: {
112663:     MIteratorNext(MDefinition *iter)
112663:       : MUnaryInstruction(iter)
112663:     {
112663:         setResultType(MIRType_Value);
112663:     }
112663: 
112663:   public:
125300:     INSTRUCTION_HEADER(IteratorNext)
112663: 
112663:     static MIteratorNext *New(MDefinition *iter) {
112663:         return new MIteratorNext(iter);
112663:     }
112663: 
112663:     TypePolicy *typePolicy() {
112663:         return this;
112663:     }
112663:     MDefinition *iterator() const {
112663:         return getOperand(0);
112663:     }
112663: };
112663: 
112663: class MIteratorMore
112663:   : public MUnaryInstruction,
112691:     public SingleObjectPolicy
112663: {
112663:     MIteratorMore(MDefinition *iter)
112663:       : MUnaryInstruction(iter)
112663:     {
112663:         setResultType(MIRType_Boolean);
112663:     }
112663: 
112663:   public:
125300:     INSTRUCTION_HEADER(IteratorMore)
112663: 
112663:     static MIteratorMore *New(MDefinition *iter) {
112663:         return new MIteratorMore(iter);
112663:     }
112663: 
112663:     TypePolicy *typePolicy() {
112663:         return this;
112663:     }
112663:     MDefinition *iterator() const {
112663:         return getOperand(0);
112663:     }
112663: };
112663: 
112663: class MIteratorEnd
112663:   : public MUnaryInstruction,
112691:     public SingleObjectPolicy
112663: {
112663:     MIteratorEnd(MDefinition *iter)
112663:       : MUnaryInstruction(iter)
112663:     { }
112663: 
112663:   public:
125300:     INSTRUCTION_HEADER(IteratorEnd)
112663: 
112663:     static MIteratorEnd *New(MDefinition *iter) {
112663:         return new MIteratorEnd(iter);
112663:     }
112663: 
112663:     TypePolicy *typePolicy() {
112663:         return this;
112663:     }
112663:     MDefinition *iterator() const {
112663:         return getOperand(0);
112663:     }
112663: };
112663: 
119236: // Implementation for 'in' operator.
119236: class MIn
119236:   : public MBinaryInstruction,
119236:     public MixPolicy<BoxPolicy<0>, ObjectPolicy<1> >
119236: {
119236:   public:
119236:     MIn(MDefinition *key, MDefinition *obj)
119236:       : MBinaryInstruction(key, obj)
119236:     {
119236:         setResultType(MIRType_Boolean);
119236:     }
119236: 
125300:     INSTRUCTION_HEADER(In)
119236: 
119236:     TypePolicy *typePolicy() {
119236:         return this;
119236:     }
119236: };
119236: 
122291: 
122291: // Test whether the index is in the array bounds or a hole.
122291: class MInArray
122291:   : public MTernaryInstruction
122291: {
122291:     bool needsHoleCheck_;
122291: 
122291:     MInArray(MDefinition *elements, MDefinition *index, MDefinition *initLength, bool needsHoleCheck)
122291:       : MTernaryInstruction(elements, index, initLength),
122291:         needsHoleCheck_(needsHoleCheck)
122291:     {
122291:         setResultType(MIRType_Boolean);
122291:         setMovable();
122291:         JS_ASSERT(elements->type() == MIRType_Elements);
122291:         JS_ASSERT(index->type() == MIRType_Int32);
122291:         JS_ASSERT(initLength->type() == MIRType_Int32);
122291:     }
122291: 
122291:   public:
125300:     INSTRUCTION_HEADER(InArray)
122291: 
122291:     static MInArray *New(MDefinition *elements, MDefinition *index,
122291:                          MDefinition *initLength, bool needsHoleCheck) {
122291:         return new MInArray(elements, index, initLength, needsHoleCheck);
122291:     }
122291: 
122291:     MDefinition *elements() const {
122291:         return getOperand(0);
122291:     }
122291:     MDefinition *index() const {
122291:         return getOperand(1);
122291:     }
122291:     MDefinition *initLength() const {
122291:         return getOperand(2);
122291:     }
122291:     bool needsHoleCheck() const {
122291:         return needsHoleCheck_;
122291:     }
122291:     AliasSet getAliasSet() const {
122291:         return AliasSet::Load(AliasSet::Element);
122291:     }
122291: };
122291: 
123958: // Implementation for instanceof operator with specific rhs.
124034: class MInstanceOf
123958:   : public MUnaryInstruction,
123958:     public InstanceOfPolicy
123958: {
123958:     CompilerRootObject protoObj_;
123958: 
123958:   public:
124034:     MInstanceOf(MDefinition *obj, RawObject proto)
124150:       : MUnaryInstruction(obj),
124150:         protoObj_(proto)
124150:     {
123958:         setResultType(MIRType_Boolean);
123958:     }
123958: 
125300:     INSTRUCTION_HEADER(InstanceOf)
123958: 
123958:     TypePolicy *typePolicy() {
123958:         return this;
123958:     }
123958: 
123958:     RawObject prototypeObject() {
123958:         return protoObj_;
123958:     }
123958: };
123958: 
123958: // Implementation for instanceof operator with unknown rhs.
124034: class MCallInstanceOf
113170:   : public MBinaryInstruction,
124034:     public MixPolicy<BoxPolicy<0>, ObjectPolicy<1> >
113170: {
113170:   public:
124034:     MCallInstanceOf(MDefinition *obj, MDefinition *proto)
113170:       : MBinaryInstruction(obj, proto)
113170:     {
113170:         setResultType(MIRType_Boolean);
113170:     }
113170: 
125300:     INSTRUCTION_HEADER(CallInstanceOf)
113170: 
113170:     TypePolicy *typePolicy() {
113170:         return this;
113170:     }
113170: };
113170: 
113411: class MArgumentsLength : public MNullaryInstruction
113411: {
113411:     MArgumentsLength()
113199:     {
113199:         setResultType(MIRType_Int32);
113199:         setMovable();
113199:     }
113411: 
113199:   public:
125300:     INSTRUCTION_HEADER(ArgumentsLength)
113199: 
113411:     static MArgumentsLength *New() {
113411:         return new MArgumentsLength();
113411:     }
113411: 
113199:     bool congruentTo(MDefinition *const &ins) const {
113199:         return congruentIfOperandsEqual(ins);
113199:     }
113199:     AliasSet getAliasSet() const {
113200:         // Arguments |length| cannot be mutated by Ion Code.
113200:         return AliasSet::None();
113200:    }
113200: };
113200: 
113200: // This MIR instruction is used to get an argument from the actual arguments.
113200: class MGetArgument
113200:   : public MUnaryInstruction,
113200:     public IntPolicy<0>
113200: {
113200:     MGetArgument(MDefinition *idx)
113200:       : MUnaryInstruction(idx)
113200:     {
113200:         setResultType(MIRType_Value);
113200:         setMovable();
113200:     }
113200: 
113200:   public:
125300:     INSTRUCTION_HEADER(GetArgument)
113200: 
113200:     static MGetArgument *New(MDefinition *idx) {
113200:         return new MGetArgument(idx);
113200:     }
113200: 
113200:     MDefinition *index() const {
113200:         return getOperand(0);
113200:     }
113200: 
113200:     TypePolicy *typePolicy() {
113200:         return this;
113200:     }
113200:     bool congruentTo(MDefinition *const &ins) const {
113200:         return congruentIfOperandsEqual(ins);
113200:     }
113200:     AliasSet getAliasSet() const {
113199:         return AliasSet::None();
113199:    }
113199: };
113199: 
112118: // Given a value, guard that the value is in a particular TypeSet, then returns
112118: // that value.
112118: class MTypeBarrier : public MUnaryInstruction
112118: {
112118:     BailoutKind bailoutKind_;
124001:     const types::TypeSet *typeSet_;
124001: 
124001:     MTypeBarrier(MDefinition *def, const types::TypeSet *types)
112132:       : MUnaryInstruction(def),
112132:         typeSet_(types)
112118:     {
112118:         setResultType(MIRType_Value);
112118:         setGuard();
112302:         setMovable();
112302:         bailoutKind_ = def->isEffectful()
112302:                        ? Bailout_TypeBarrier
112302:                        : Bailout_Normal;
112118:     }
112118: 
112118:   public:
125300:     INSTRUCTION_HEADER(TypeBarrier)
112118: 
124001:     static MTypeBarrier *New(MDefinition *def, const types::TypeSet *types) {
112118:         return new MTypeBarrier(def, types);
112118:     }
112118:     bool congruentTo(MDefinition * const &def) const {
112118:         return false;
112118:     }
112118:     MDefinition *input() const {
112118:         return getOperand(0);
112118:     }
112118:     BailoutKind bailoutKind() const {
112118:         return bailoutKind_;
112118:     }
124001:     const types::TypeSet *typeSet() const {
112132:         return typeSet_;
112132:     }
112474:     AliasSet getAliasSet() const {
112302:         return AliasSet::None();
112302:     }
125215:     virtual bool neverHoist() const {
125215:         return typeSet()->empty();
125215:     }
125215: 
112118: };
112118: 
112743: // Like MTypeBarrier, guard that the value is in the given type set. This is
112743: // used after some VM calls (like GetElement) to avoid the slower calls to
112743: // TypeScript::Monitor inside these stubs.
112743: class MMonitorTypes : public MUnaryInstruction
112743: {
124001:     const types::TypeSet *typeSet_;
124001: 
124001:     MMonitorTypes(MDefinition *def, const types::TypeSet *types)
112743:       : MUnaryInstruction(def),
112743:         typeSet_(types)
112743:     {
112743:         setResultType(MIRType_Value);
112743:         setGuard();
112743:         JS_ASSERT(!types->unknown());
112743:     }
112743: 
112743:   public:
125300:     INSTRUCTION_HEADER(MonitorTypes)
112743: 
124001:     static MMonitorTypes *New(MDefinition *def, const types::TypeSet *types) {
112743:         return new MMonitorTypes(def, types);
112743:     }
112743:     MDefinition *input() const {
112743:         return getOperand(0);
112743:     }
124001:     const types::TypeSet *typeSet() const {
112743:         return typeSet_;
112743:     }
112743:     AliasSet getAliasSet() const {
112743:         return AliasSet::None();
112743:     }
112743: };
112743: 
113233: class MNewSlots : public MNullaryInstruction
113233: {
113233:     unsigned nslots_;
113233: 
113233:     MNewSlots(unsigned nslots)
113233:       : nslots_(nslots)
113233:     {
113233:         setResultType(MIRType_Slots);
113233:     }
113233: 
113233:   public:
125300:     INSTRUCTION_HEADER(NewSlots)
113233: 
113233:     static MNewSlots *New(unsigned nslots) {
113233:         return new MNewSlots(nslots);
113233:     }
113233:     unsigned nslots() const {
113233:         return nslots_;
113233:     }
113233:     AliasSet getAliasSet() const {
113233:         return AliasSet::None();
113233:     }
113233: };
113233: 
125292: class MNewDeclEnvObject : public MNullaryInstruction
125292: {
125292:     CompilerRootObject templateObj_;
125292: 
125292:     MNewDeclEnvObject(HandleObject templateObj)
125292:       : MNullaryInstruction(),
125292:         templateObj_(templateObj)
125292:     {
125292:         setResultType(MIRType_Object);
125292:     }
125292: 
125292:   public:
125292:     INSTRUCTION_HEADER(NewDeclEnvObject);
125292: 
125292:     static MNewDeclEnvObject *New(HandleObject templateObj) {
125292:         return new MNewDeclEnvObject(templateObj);
125292:     }
125292: 
125292:     JSObject *templateObj() {
125292:         return templateObj_;
125292:     }
125292:     AliasSet getAliasSet() const {
125292:         return AliasSet::None();
125292:     }
125292: };
125292: 
113233: class MNewCallObject : public MUnaryInstruction
113175: {
113175:     CompilerRootObject templateObj_;
113175: 
113233:     MNewCallObject(HandleObject templateObj, MDefinition *slots)
113233:       : MUnaryInstruction(slots),
113175:         templateObj_(templateObj)
113175:     {
113175:         setResultType(MIRType_Object);
113175:     }
113175: 
113175:   public:
125300:     INSTRUCTION_HEADER(NewCallObject)
113175: 
113233:     static MNewCallObject *New(HandleObject templateObj, MDefinition *slots) {
113233:         return new MNewCallObject(templateObj, slots);
113233:     }
113233: 
113233:     MDefinition *slots() {
113175:         return getOperand(0);
113175:     }
113175:     JSObject *templateObj() {
113175:         return templateObj_;
113175:     }
113175:     AliasSet getAliasSet() const {
113175:         return AliasSet::None();
113175:     }
113175: };
113175: 
115132: class MNewStringObject :
115132:   public MUnaryInstruction,
115132:   public StringPolicy
115132: {
115132:     CompilerRootObject templateObj_;
115132: 
115132:     MNewStringObject(MDefinition *input, HandleObject templateObj)
115132:       : MUnaryInstruction(input),
115132:         templateObj_(templateObj)
115132:     {
115132:         setResultType(MIRType_Object);
115132:     }
115132: 
115132:   public:
125300:     INSTRUCTION_HEADER(NewStringObject)
115132: 
115132:     static MNewStringObject *New(MDefinition *input, HandleObject templateObj) {
115132:         return new MNewStringObject(input, templateObj);
115132:     }
115132: 
115132:     MDefinition *input() const {
115132:         return getOperand(0);
115132:     }
115580: 
115580:     StringObject *templateObj() const;
115580: 
115132:     TypePolicy *typePolicy() {
115132:         return this;
115132:     }
115132: };
115132: 
113449: // Node that represents that a script has begun executing. This comes at the
113449: // start of the function and is called once per function (including inline
113449: // ones)
113587: class MFunctionBoundary : public MNullaryInstruction
113587: {
113587:   public:
113587:     enum Type {
113587:         Enter,        // a function has begun executing and it is not inline
113587:         Exit,         // any function has exited (inlined or normal)
113587:         Inline_Enter, // an inline function has begun executing
113587: 
113587:         Inline_Exit   // all instructions of an inline function are done, a
113587:                       // return from the inline function could have occurred
113587:                       // before this boundary
113587:     };
113587: 
113587:   private:
113587:     JSScript *script_;
113587:     Type type_;
113587:     unsigned inlineLevel_;
113587: 
113587:     MFunctionBoundary(JSScript *script, Type type, unsigned inlineLevel)
113587:       : script_(script), type_(type), inlineLevel_(inlineLevel)
113587:     {
113587:         JS_ASSERT_IF(type != Inline_Exit, script != NULL);
113587:         JS_ASSERT_IF(type == Inline_Enter, inlineLevel != 0);
113449:         setGuard();
113449:     }
113449: 
113449:   public:
125300:     INSTRUCTION_HEADER(FunctionBoundary)
113587: 
113587:     static MFunctionBoundary *New(JSScript *script, Type type,
113587:                                   unsigned inlineLevel = 0) {
113587:         return new MFunctionBoundary(script, type, inlineLevel);
113587:     }
113587: 
113587:     JSScript *script() {
113587:         return script_;
113587:     }
113587: 
113587:     Type type() {
113587:         return type_;
113587:     }
113587: 
113587:     unsigned inlineLevel() {
113587:         return inlineLevel_;
113449:     }
113449: 
113449:     AliasSet getAliasSet() const {
113449:         return AliasSet::None();
113449:     }
113449: };
113449: 
113176: // This is an alias for MLoadFixedSlot.
113176: class MEnclosingScope : public MLoadFixedSlot
113176: {
113176:     MEnclosingScope(MDefinition *obj)
113176:       : MLoadFixedSlot(obj, ScopeObject::enclosingScopeSlot())
113176:     {
113176:         setResultType(MIRType_Object);
113176:     }
113176: 
113176:   public:
113176:     static MEnclosingScope *New(MDefinition *obj) {
113176:         return new MEnclosingScope(obj);
113176:     }
113176: 
113176:     AliasSet getAliasSet() const {
113176:         // ScopeObject reserved slots are immutable.
113176:         return AliasSet::None();
113176:     }
113176: };
113176: 
112049: // A resume point contains the information needed to reconstruct the interpreter
112049: // state from a position in the JIT. See the big comment near resumeAfter() in
111715: // IonBuilder.cpp.
112049: class MResumePoint : public MNode
111679: {
112681:   public:
112681:     enum Mode {
113196:         ResumeAt,    // Resume until before the current instruction
113196:         ResumeAfter, // Resume after the current instruction
113196:         Outer        // State before inlining.
112681:     };
112681: 
112681:   private:
111687:     friend class MBasicBlock;
111687: 
111795:     MDefinition **operands_;
124795:     uint32_t stackDepth_;
111679:     jsbytecode *pc_;
112206:     MResumePoint *caller_;
124518:     MInstruction *instruction_;
112681:     Mode mode_;
112681: 
112681:     MResumePoint(MBasicBlock *block, jsbytecode *pc, MResumePoint *parent, Mode mode);
111679:     bool init(MBasicBlock *state);
111687:     void inherit(MBasicBlock *state);
111679: 
111679:   protected:
112755:     // Overwrites an operand without updating its Uses.
111795:     void setOperand(size_t index, MDefinition *operand) {
111679:         JS_ASSERT(index < stackDepth_);
111679:         operands_[index] = operand;
111679:     }
111679: 
111679:   public:
112681:     static MResumePoint *New(MBasicBlock *block, jsbytecode *pc, MResumePoint *parent, Mode mode);
111679: 
111797:     MNode::Kind kind() const {
112049:         return MNode::ResumePoint;
111694:     }
111679:     size_t numOperands() const {
111679:         return stackDepth_;
111679:     }
111795:     MDefinition *getOperand(size_t index) const {
111679:         JS_ASSERT(index < stackDepth_);
111679:         return operands_[index];
111679:     }
111679:     jsbytecode *pc() const {
111679:         return pc_;
111679:     }
124795:     uint32_t stackDepth() const {
111679:         return stackDepth_;
111679:     }
112206:     MResumePoint *caller() {
112206:         return caller_;
112206:     }
112206:     void setCaller(MResumePoint *caller) {
112206:         caller_ = caller;
112206:     }
124795:     uint32_t frameCount() const {
124795:         uint32_t count = 1;
112206:         for (MResumePoint *it = caller_; it; it = it->caller_)
112206:             count++;
112206:         return count;
112206:     }
124518:     MInstruction *instruction() {
124518:         return instruction_;
124518:     }
124518:     void setInstruction(MInstruction *ins) {
124518:         instruction_ = ins;
124518:     }
112681:     Mode mode() const {
112681:         return mode_;
112681:     }
112206: };
112206: 
112206: /*
112206:  * Facade for a chain of MResumePoints that cross frame boundaries (due to
112206:  * function inlining). Operands are ordered from oldest frame to newest.
112206:  */
112206: class FlattenedMResumePointIter
112206: {
112206:     Vector<MResumePoint *, 8, SystemAllocPolicy> resumePoints;
112206:     MResumePoint *newest;
112206:     size_t numOperands_;
112206: 
112206:   public:
112206:     explicit FlattenedMResumePointIter(MResumePoint *newest)
114205:       : newest(newest), numOperands_(0)
112206:     {}
112206: 
112206:     bool init() {
112206:         MResumePoint *it = newest;
112206:         do {
112206:             if (!resumePoints.append(it))
112206:                 return false;
112206:             it = it->caller();
112206:         } while (it);
112206:         Reverse(resumePoints.begin(), resumePoints.end());
112206:         return true;
112206:     }
112206: 
112206:     MResumePoint **begin() {
112206:         return resumePoints.begin();
112206:     }
112206:     MResumePoint **end() {
112206:         return resumePoints.end();
112206:     }
112206: 
112206:     size_t numOperands() const {
112206:         return numOperands_;
112206:     }
111679: };
111679: 
111673: #undef INSTRUCTION_HEADER
111673: 
111655: // Implement opcode casts now that the compiler can see the inheritance.
111655: #define OPCODE_CASTS(opcode)                                                \
111795:     M##opcode *MDefinition::to##opcode()                                    \
111655:     {                                                                       \
111655:         JS_ASSERT(is##opcode());                                            \
111655:         return static_cast<M##opcode *>(this);                              \
111655:     }
111655: MIR_OPCODE_LIST(OPCODE_CASTS)
111655: #undef OPCODE_CASTS
111655: 
111796: MDefinition *MNode::toDefinition()
111796: {
111796:     JS_ASSERT(isDefinition());
111796:     return (MDefinition *)this;
111796: }
111796: 
112049: MResumePoint *MNode::toResumePoint()
111800: {
112049:     JS_ASSERT(isResumePoint());
112049:     return (MResumePoint *)this;
111800: }
111800: 
111795: MInstruction *MDefinition::toInstruction()
111795: {
111795:     JS_ASSERT(!isPhi());
111795:     return (MInstruction *)this;
111795: }
111795: 
111797: void MNode::initOperand(size_t index, MDefinition *ins)
111797: {
111797:     setOperand(index, ins);
111797:     ins->addUse(this, index);
111797: }
116487: static inline bool isOSRLikeValue (MDefinition *def) {
116487:     if (def->isOsrValue())
116487:         return true;
116487: 
116487:     if (def->isUnbox())
116487:         if (def->getOperand(0)->isOsrValue())
116487:             return true;
116487: 
116487:     return false;
116487: }
111797: 
112206: typedef Vector<MDefinition *, 8, IonAllocPolicy> MDefinitionVector;
112206: 
111655: } // namespace ion
111655: } // namespace js
111655: 
111655: #endif // jsion_mir_h__
111655: 
