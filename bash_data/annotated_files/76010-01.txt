59900: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52873:  * vim: set ts=4 sw=4 et tw=99:
52873:  *
52873:  * ***** BEGIN LICENSE BLOCK *****
52873:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52873:  *
52873:  * The contents of this file are subject to the Mozilla Public License Version
52873:  * 1.1 (the "License"); you may not use this file except in compliance with
52873:  * the License. You may obtain a copy of the License at
52873:  * http://www.mozilla.org/MPL/
52873:  *
52873:  * Software distributed under the License is distributed on an "AS IS" basis,
52873:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52873:  * for the specific language governing rights and limitations under the
52873:  * License.
52873:  *
52873:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52873:  * May 28, 2008.
52873:  *
52873:  * The Initial Developer of the Original Code is
52873:  *   Brendan Eich <brendan@mozilla.org>
52873:  *
52873:  * Contributor(s):
52873:  *   David Anderson <danderson@mozilla.com>
52873:  *   David Mandelin <dmandelin@mozilla.com>
52873:  *
52873:  * Alternatively, the contents of this file may be used under the terms of
52873:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52873:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52873:  * in which case the provisions of the GPL or the LGPL are applicable instead
52873:  * of those above. If you wish to allow use of your version of this file only
52873:  * under the terms of either the GPL or the LGPL, and not to allow others to
52873:  * use your version of this file under the terms of the MPL, indicate your
52873:  * decision by deleting the provisions above and replace them with the notice
52873:  * and other provisions required by the GPL or the LGPL. If you do not delete
52873:  * the provisions above, a recipient may use your version of this file under
52873:  * the terms of any one of the MPL, the GPL or the LGPL.
52873:  *
52873:  * ***** END LICENSE BLOCK ***** */
52873: 
52873: #include "jscntxt.h"
52873: #include "jsscope.h"
52873: #include "jsobj.h"
52873: #include "jslibmath.h"
52873: #include "jsiter.h"
52873: #include "jsnum.h"
52873: #include "jsxml.h"
52873: #include "jsstaticcheck.h"
52873: #include "jsbool.h"
52873: #include "assembler/assembler/MacroAssemblerCodeRef.h"
53133: #include "assembler/assembler/CodeLocation.h"
52873: #include "jsiter.h"
52873: #include "jstypes.h"
52873: #include "methodjit/StubCalls.h"
52873: #include "jstracer.h"
52873: #include "jspropertycache.h"
53133: #include "methodjit/MonoIC.h"
56602: #include "jsanalyze.h"
58063: #include "methodjit/BaseCompiler.h"
60591: #include "methodjit/ICRepatcher.h"
53133: 
53840: #include "jsinterpinlines.h"
52873: #include "jspropertycacheinlines.h"
52873: #include "jsscopeinlines.h"
52873: #include "jsscriptinlines.h"
52873: #include "jsstrinlines.h"
52873: #include "jsobjinlines.h"
52873: #include "jscntxtinlines.h"
52873: #include "jsatominlines.h"
54832: #include "StubCalls-inl.h"
62574: #include "MethodJIT-inl.h"
52873: 
52873: #include "jsautooplen.h"
52873: 
52873: using namespace js;
52873: using namespace js::mjit;
52873: using namespace JSC;
52873: 
60591: using ic::Repatcher;
60591: 
52873: static jsbytecode *
52873: FindExceptionHandler(JSContext *cx)
52873: {
69223:     StackFrame *fp = cx->fp();
53840:     JSScript *script = fp->script();
52873: 
52873: top:
60211:     if (cx->isExceptionPending() && JSScript::isValidOffset(script->trynotesOffset)) {
52873:         // The PC is updated before every stub call, so we can use it here.
69223:         unsigned offset = cx->regs().pc - script->main;
52873: 
52873:         JSTryNoteArray *tnarray = script->trynotes();
52873:         for (unsigned i = 0; i < tnarray->length; ++i) {
52873:             JSTryNote *tn = &tnarray->vector[i];
57782: 
53496:             // The following if condition actually tests two separate conditions:
53496:             //   (1) offset - tn->start >= tn->length
53496:             //       means the PC is not in the range of this try note, so we
53496:             //       should continue searching, after considering:
53496:             //   (2) offset - tn->start == tn->length
53496:             //       means the PC is at the first op of the exception handler
53496:             //       for this try note. This happens when an exception is thrown
53496:             //       during recording: the interpreter sets the PC to the handler
53496:             //       and then exits. In this case, we are in fact at the right
53496:             //       exception handler. 
53496:             //      
53496:             //       Hypothetically, the op we are at might have thrown an
53496:             //       exception, in which case this would not be the right handler.
53496:             //       But the first ops of exception handlers generated by our
53496:             //       bytecode compiler cannot throw, so this is not possible.
53496:             if (offset - tn->start > tn->length)
52873:                 continue;
69223:             if (tn->stackDepth > cx->regs().sp - fp->base())
52873:                 continue;
52873: 
52873:             jsbytecode *pc = script->main + tn->start + tn->length;
52873:             JSBool ok = js_UnwindScope(cx, tn->stackDepth, JS_TRUE);
69223:             JS_ASSERT(cx->regs().sp == fp->base() + tn->stackDepth);
52873: 
52873:             switch (tn->kind) {
52873:                 case JSTRY_CATCH:
53840:                   JS_ASSERT(js_GetOpcode(cx, fp->script(), pc) == JSOP_ENTERBLOCK);
52873: 
52873: #if JS_HAS_GENERATORS
52873:                   /* Catch cannot intercept the closing of a generator. */
60211:                   if (JS_UNLIKELY(cx->getPendingException().isMagic(JS_GENERATOR_CLOSING)))
52873:                       break;
52873: #endif
52873: 
52873:                   /*
52873:                    * Don't clear cx->throwing to save cx->exception from GC
52873:                    * until it is pushed to the stack via [exception] in the
52873:                    * catch block.
52873:                    */
52873:                   return pc;
52873: 
52873:                 case JSTRY_FINALLY:
52873:                   /*
52873:                    * Push (true, exception) pair for finally to indicate that
52873:                    * [retsub] should rethrow the exception.
52873:                    */
69223:                   cx->regs().sp[0].setBoolean(true);
69223:                   cx->regs().sp[1] = cx->getPendingException();
69223:                   cx->regs().sp += 2;
60211:                   cx->clearPendingException();
52873:                   return pc;
52873: 
52873:                 case JSTRY_ITER:
52873:                 {
52873:                   /*
52873:                    * This is similar to JSOP_ENDITER in the interpreter loop,
52873:                    * except the code now uses the stack slot normally used by
52873:                    * JSOP_NEXTITER, namely regs.sp[-1] before the regs.sp -= 2
52873:                    * adjustment and regs.sp[1] after, to save and restore the
52873:                    * pending exception.
52873:                    */
60211:                   Value v = cx->getPendingException();
53840:                   JS_ASSERT(js_GetOpcode(cx, fp->script(), pc) == JSOP_ENDITER);
60211:                   cx->clearPendingException();
69223:                   ok = !!js_CloseIterator(cx, &cx->regs().sp[-1].toObject());
69223:                   cx->regs().sp -= 1;
52873:                   if (!ok)
52873:                       goto top;
60211:                   cx->setPendingException(v);
52873:                 }
52873:             }
52873:         }
52873:     }
52873: 
52873:     return NULL;
52873: }
52873: 
54832: /*
68952:  * Clean up a frame and return.
68952:  */
68952: static void
68952: InlineReturn(VMFrame &f)
68952: {
68952:     JS_ASSERT(f.fp() != f.entryfp);
69223:     JS_ASSERT(!js_IsActiveWithOrBlock(f.cx, &f.fp()->scopeChain(), 0));
69223:     f.cx->stack.popInlineFrame();
68952: }
68952: 
68952: void JS_FASTCALL
68952: stubs::SlowCall(VMFrame &f, uint32 argc)
68952: {
68952:     Value *vp = f.regs.sp - (argc + 2);
68952: 
69223:     if (!Invoke(f.cx, InvokeArgsAlreadyOnTheStack(argc, vp)))
68952:         THROW();
68952: }
68952: 
68952: void JS_FASTCALL
68952: stubs::SlowNew(VMFrame &f, uint32 argc)
68952: {
68952:     JSContext *cx = f.cx;
68952:     Value *vp = f.regs.sp - (argc + 2);
68952: 
69223:     if (!InvokeConstructor(cx, InvokeArgsAlreadyOnTheStack(argc, vp)))
68952:         THROW();
68952: }
68952: 
68952: /*
53840:  * This function must only be called after the early prologue, since it depends
53840:  * on fp->exec.fun.
53840:  */
53590: static inline void
69223: RemovePartialFrame(JSContext *cx, StackFrame *fp)
53590: {
69223:     cx->stack.popInlineFrame();
53590: }
53590: 
53840: /*
53840:  * HitStackQuota is called after the early prologue pushing the new frame would
53840:  * overflow f.stackLimit.
53840:  */
53590: void JS_FASTCALL
53840: stubs::HitStackQuota(VMFrame &f)
53590: {
75882:     /* Include space for any inline frames. */
75882:     uintN nvals = f.fp()->script()->nslots + StackSpace::STACK_EXTRA;
53840:     JS_ASSERT(f.regs.sp == f.fp()->base());
69223:     StackSpace &space = f.cx->stack.space();
69223:     if (space.bumpLimitWithinQuota(NULL, f.entryfp, f.regs.sp, nvals, &f.stackLimit))
53590:         return;
53590: 
53840:     /* Remove the current partially-constructed frame before throwing. */
53840:     RemovePartialFrame(f.cx, f.fp());
53590:     js_ReportOverRecursed(f.cx);
53590:     THROW();
53590: }
53590: 
53840: /*
53840:  * This function must only be called after the early prologue, since it depends
53840:  * on fp->exec.fun.
53840:  */
53590: void * JS_FASTCALL
53840: stubs::FixupArity(VMFrame &f, uint32 nactual)
53590: {
53590:     JSContext *cx = f.cx;
69223:     StackFrame *oldfp = f.fp();
53590: 
53840:     JS_ASSERT(nactual != oldfp->numFormalArgs());
53590: 
53590:     /*
53590:      * Grossssss! *move* the stack frame. If this ends up being perf-critical,
53840:      * we can figure out how to spot-optimize it. Be careful to touch only the
53840:      * members that have been initialized by initCallFrameCallerHalf and the
53840:      * early prologue.
53590:      */
53840:     uint32 flags         = oldfp->isConstructingFlag();
53840:     JSFunction *fun      = oldfp->fun();
53840:     void *ncode          = oldfp->nativeReturnAddress();
53590: 
53590:     /* Pop the inline frame. */
69223:     f.regs.popPartialFrame((Value *)oldfp);
53590: 
53840:     /* Reserve enough space for a callee frame. */
69223:     StackFrame *newfp = cx->stack.getInlineFrameWithinLimit(cx, (Value*) oldfp, nactual,
53840:                                                             fun, fun->script(), &flags,
57308:                                                             f.entryfp, &f.stackLimit);
62038:     if (!newfp) {
62038:         /*
62038:          * The PC is not coherent with the current frame, so fix it up for
62038:          * exception handling.
62038:          */
76001:         JSInlinedSite *inline_;
76001:         f.regs.pc = f.jit()->nativeToPC(ncode, &inline_);
76001:         JS_ASSERT(!inline_);
53840:         THROWV(NULL);
62038:     }
53590: 
53840:     /* Reset the part of the stack frame set by the caller. */
57715:     newfp->initCallFrameCallerHalf(cx, flags, ncode);
53590: 
53840:     /* Reset the part of the stack frame set by the prologue up to now. */
57715:     newfp->initCallFrameEarlyPrologue(fun, nactual);
53590: 
53840:     /* The caller takes care of assigning fp to regs. */
53590:     return newfp;
53590: }
53590: 
53590: void * JS_FASTCALL
53840: stubs::CompileFunction(VMFrame &f, uint32 nactual)
53590: {
53590:     /*
76010:      * Write the scratch field of the VMFrame to indicate this is a call to
76010:      * CompileFunction from an IC (the recompiler cannot detect calls made from
76010:      * ICs automatically). This needs to be cleared out on all return paths.
76010:      */
76010:     f.scratch = COMPILE_FUNCTION_SCRATCH_VALUE;
76010: 
76010:     /*
53590:      * We have a partially constructed frame. That's not really good enough to
53590:      * compile though because we could throw, so get a full, adjusted frame.
53590:      */
53590:     JSContext *cx = f.cx;
69223:     StackFrame *fp = f.fp();
53590: 
53840:     /*
53840:      * Since we can only use members set by initCallFrameCallerHalf,
53840:      * we must carefully extract the callee from the nactual.
53840:      */
53840:     JSObject &callee = fp->formalArgsEnd()[-(int(nactual) + 2)].toObject();
53840:     JSFunction *fun = callee.getFunctionPrivate();
53840:     JSScript *script = fun->script();
53590: 
53840:     /*
53840:      * FixupArity/RemovePartialFrame expect to be called after the early
62574:      * prologue.
53840:      */
57715:     fp->initCallFrameEarlyPrologue(fun, nactual);
53590: 
53840:     if (nactual != fp->numFormalArgs()) {
69223:         fp = (StackFrame *)FixupArity(f, nactual);
76010:         if (!fp) {
76010:             f.scratch = NULL;
53590:             return NULL;
53590:         }
76010:     }
53590: 
75975:     CallArgs args = CallArgsFromArgv(fp->numFormalArgs(), fp->formalArgs());
76010:     if (!cx->typeMonitorCall(args, fp->isConstructing())) {
76010:         f.scratch = NULL;
75831:         return NULL;
76010:     }
75831: 
53840:     /* Finish frame initialization. */
53840:     fp->initCallFrameLatePrologue();
53590: 
53840:     /* These would have been initialized by the prologue. */
69223:     f.regs.prepareToRun(fp, script);
53590: 
76010:     if (fun->isHeavyweight() && !js::CreateFunCallObject(cx, fp)) {
76010:         f.scratch = NULL;
53590:         THROWV(NULL);
76010:     }
53590: 
62574:     CompileStatus status = CanMethodJIT(cx, script, fp, CompileRequest_JIT);
75997:     if (status == Compile_Okay) {
75997:         void *entry = script->getJIT(fp->isConstructing())->invokeEntry;
75997: 
75997:         /* Same constraint on fp as UncachedInlineCall. */
76001:         f.regs.popFrame((Value *) f.regs.fp());
76010:         f.scratch = NULL;
75997:         return entry;
75997:     }
68902: 
75803:     /* Force computation of the previous PC, as Interpret will clear it. */
75803:     fp->prev()->pc(cx, fp);
53590: 
53590:     /* Function did not compile... interpret it. */
53590:     JSBool ok = Interpret(cx, fp);
56201:     InlineReturn(f);
53590: 
76010:     f.scratch = NULL;
76010: 
53590:     if (!ok)
53590:         THROWV(NULL);
53590: 
53590:     return NULL;
53590: }
53590: 
68952: static inline bool
75794: UncachedInlineCall(VMFrame &f, uint32 flags, void **pret, bool *unjittable, uint32 argc,
75794:                    types::ClonedTypeSet *argTypes)
68952: {
68952:     JSContext *cx = f.cx;
68952:     Value *vp = f.regs.sp - (argc + 2);
68952:     JSObject &callee = vp->toObject();
68952:     JSFunction *newfun = callee.getFunctionPrivate();
68952:     JSScript *newscript = newfun->script();
68952: 
76001:     bool newType = (flags & StackFrame::CONSTRUCTING) && cx->typeInferenceEnabled() &&
75864:         types::UseNewType(cx, f.script(), f.pc());
75788: 
75777:     if (argTypes && argc == newfun->nargs) {
75777:         /*
75777:          * Use the space of all possible types being passed at this callsite if there
75777:          * is a match between argc and nargs, so that the fastEntry can be subsequently
75777:          * used without further type checking. If there is an argument count mismatch,
75777:          * the callee's args will end up getting marked as unknown.
75777:          */
75794:         types::AutoEnterTypeInference enter(cx);
76001:         if (flags & StackFrame::CONSTRUCTING) {
75785:             if (!newscript->typeSetNewCalled(cx))
75776:                 return false;
75785:         } else {
75794:             if (!newscript->typeSetThis(cx, &argTypes[0]))
75785:                 return false;
75785:         }
75777:         for (unsigned i = 0; i < argc; i++) {
75794:             if (!newscript->typeSetArgument(cx, i, &argTypes[1 + i]))
75776:                 return false;
75776:         }
75776:     } else {
75975:         CallArgs args = CallArgsFromVp(argc, vp);
76001:         if (!cx->typeMonitorCall(args, flags & StackFrame::CONSTRUCTING))
75720:             return false;
75776:     }
75636: 
68952:     /* Get pointer to new frame/slots, prepare arguments. */
69223:     StackFrame *newfp = cx->stack.getInlineFrameWithinLimit(cx, f.regs.sp, argc,
68952:                                                             newfun, newscript, &flags,
68952:                                                             f.entryfp, &f.stackLimit);
68952:     if (JS_UNLIKELY(!newfp))
68952:         return false;
68952: 
68952:     /* Initialize frame, locals. */
68952:     newfp->initCallFrame(cx, callee, newfun, argc, flags);
68952:     SetValueRangeToUndefined(newfp->slots(), newscript->nfixed);
68952: 
68952:     /* Officially push the frame. */
69223:     cx->stack.pushInlineFrame(newscript, newfp, f.regs);
69223:     JS_ASSERT(newfp == f.fp());
68952: 
68952:     /* Scope with a call object parented by callee's parent. */
68952:     if (newfun->isHeavyweight() && !js::CreateFunCallObject(cx, newfp))
68952:         return false;
68952: 
68952:     /* Try to compile if not already compiled. */
68952:     if (newscript->getJITStatus(newfp->isConstructing()) == JITScript_None) {
68952:         CompileStatus status = CanMethodJIT(cx, newscript, newfp, CompileRequest_Interpreter);
68952:         if (status == Compile_Error) {
68952:             /* A runtime exception was thrown, get out. */
68952:             InlineReturn(f);
68952:             return false;
68952:         }
68952:         if (status == Compile_Abort)
68952:             *unjittable = true;
68952:     }
68952: 
75788:     /*
75788:      * If newscript was successfully compiled, run it. Skip for calls which
75788:      * will be constructing a new type object for 'this'.
75788:      */
75788:     if (!newType) {
68952:         if (JITScript *jit = newscript->getJIT(newfp->isConstructing())) {
68952:             *pret = jit->invokeEntry;
75956: 
75956:             /*
75956:              * Keep the old fp around and let the JIT code repush it. If we are
75956:              * rejoining into a recompiled frame then the code patching up
75956:              * doubles needs to see the calling script's frame.
75956:              */
76001:             f.regs.popFrame((Value *) f.regs.fp());
68952:             return true;
68952:         }
75788:     }
68952: 
68952:     /* Otherwise, run newscript in the interpreter. */
68952:     bool ok = !!Interpret(cx, cx->fp());
68952:     InlineReturn(f);
68952: 
68952:     *pret = NULL;
68952:     return ok;
68952: }
68952: 
68952: void * JS_FASTCALL
68952: stubs::UncachedNew(VMFrame &f, uint32 argc)
68952: {
68952:     UncachedCallResult ucr;
75776:     UncachedNewHelper(f, argc, NULL, &ucr);
68952:     return ucr.codeAddr;
68952: }
68952: 
68952: void
75794: stubs::UncachedNewHelper(VMFrame &f, uint32 argc, types::ClonedTypeSet *argTypes,
75794:                          UncachedCallResult *ucr)
68952: {
68952:     ucr->init();
68952:     JSContext *cx = f.cx;
68952:     Value *vp = f.regs.sp - (argc + 2);
68952:     /* Try to do a fast inline call before the general Invoke path. */
68964:     if (IsFunctionObject(*vp, &ucr->fun) && ucr->fun->isInterpretedConstructor()) {
68952:         ucr->callee = &vp->toObject();
76001:         if (!UncachedInlineCall(f, StackFrame::CONSTRUCTING, &ucr->codeAddr, &ucr->unjittable, argc, argTypes))
68952:             THROW();
68952:     } else {
69223:         if (!InvokeConstructor(cx, InvokeArgsAlreadyOnTheStack(argc, vp)))
68952:             THROW();
68952:     }
68952: }
68952: 
68952: void * JS_FASTCALL
68952: stubs::UncachedCall(VMFrame &f, uint32 argc)
68952: {
68952:     UncachedCallResult ucr;
75776:     UncachedCallHelper(f, argc, NULL, &ucr);
68952:     return ucr.codeAddr;
68952: }
68952: 
56775: void JS_FASTCALL
56775: stubs::Eval(VMFrame &f, uint32 argc)
56775: {
56775:     Value *vp = f.regs.sp - (argc + 2);
56775: 
69223:     if (!IsBuiltinEvalForScope(&f.fp()->scopeChain(), *vp)) {
69223:         if (!Invoke(f.cx, InvokeArgsAlreadyOnTheStack(argc, vp)))
56775:             THROW();
56775:         return;
56775:     }
56775: 
69223:     JS_ASSERT(f.fp() == f.cx->fp());
68894:     if (!DirectEval(f.cx, CallArgsFromVp(argc, vp)))
56775:         THROW();
68894: 
68894:     f.regs.sp = vp + 1;
56775: }
56775: 
68952: void
75794: stubs::UncachedCallHelper(VMFrame &f, uint32 argc, types::ClonedTypeSet *argTypes,
75794:                           UncachedCallResult *ucr)
68952: {
68952:     ucr->init();
68952: 
68952:     JSContext *cx = f.cx;
68952:     Value *vp = f.regs.sp - (argc + 2);
68952: 
68952:     if (IsFunctionObject(*vp, &ucr->callee)) {
68952:         ucr->callee = &vp->toObject();
68952:         ucr->fun = GET_FUNCTION_PRIVATE(cx, ucr->callee);
68952: 
68952:         if (ucr->fun->isInterpreted()) {
75776:             if (!UncachedInlineCall(f, 0, &ucr->codeAddr, &ucr->unjittable, argc, argTypes))
68952:                 THROW();
68952:             return;
68952:         }
68952: 
68952:         if (ucr->fun->isNative()) {
68952:             if (!CallJSNative(cx, ucr->fun->u.n.native, argc, vp))
68952:                 THROW();
68952:             return;
68952:         }
68952:     }
68952: 
69223:     if (!Invoke(f.cx, InvokeArgsAlreadyOnTheStack(argc, vp)))
68952:         THROW();
68952: 
68952:     return;
68952: }
68952: 
52873: void JS_FASTCALL
53840: stubs::PutActivationObjects(VMFrame &f)
52873: {
53840:     JS_ASSERT(f.fp()->hasCallObj() || f.fp()->hasArgsObj());
69223:     f.fp()->putActivationObjects();
52873: }
52873: 
52873: extern "C" void *
52873: js_InternalThrow(VMFrame &f)
52873: {
52873:     JSContext *cx = f.cx;
52873: 
60540:     // It's possible that from within RunTracer(), Interpret() returned with
60540:     // an error and finished the frame (i.e., called ScriptEpilogue), but has
60540:     // not yet performed an inline return.
60540:     //
60540:     // In this case, RunTracer() has no choice but to propagate the error
60540:     // up to the method JIT, and thus to this function. But ScriptEpilogue()
60540:     // has already been called. Detect this, and avoid double-finishing the
60540:     // frame. See HandleErrorInExcessFrame() and bug 624100.
60540:     if (f.fp()->finishedInInterpreter()) {
60540:         // If it's the last frame, just propagate the failure up again.
60540:         if (f.fp() == f.entryfp)
60540:             return NULL;
60540: 
60540:         InlineReturn(f);
60540:     }
60540: 
52873:     // Make sure sp is up to date.
69223:     JS_ASSERT(&cx->regs() == &f.regs);
52873: 
53410:     // Call the throw hook if necessary
53410:     JSThrowHook handler = f.cx->debugHooks->throwHook;
53410:     if (handler) {
53410:         Value rval;
75864:         switch (handler(cx, f.script(), f.pc(), Jsvalify(&rval), cx->debugHooks->throwHookData)) {
53410:           case JSTRAP_ERROR:
60211:             cx->clearPendingException();
53410:             return NULL;
53410: 
53410:           case JSTRAP_RETURN:
60211:             cx->clearPendingException();
53482:             cx->fp()->setReturnValue(rval);
67899:             return cx->jaegerCompartment()->forceReturnFromExternC();
53410: 
53410:           case JSTRAP_THROW:
60211:             cx->setPendingException(rval);
53410:             break;
53410: 
53410:           default:
53410:             break;
53410:         }
53410:     }
53410: 
52873:     jsbytecode *pc = NULL;
52873:     for (;;) {
52873:         pc = FindExceptionHandler(cx);
52873:         if (pc)
52873:             break;
52873: 
60540:         // The JIT guarantees that ScriptEpilogue() has always been run
60540:         // upon exiting to its caller. This is important for consistency,
60540:         // where execution modes make similar guarantees about prologues
60540:         // and epilogues. RunTracer(), Interpret(), and Invoke() all
60540:         // rely on this property.
60540:         JS_ASSERT(!f.fp()->finishedInInterpreter());
60211:         js_UnwindScope(cx, 0, cx->isExceptionPending());
56201:         ScriptEpilogue(f.cx, f.fp(), false);
56201: 
60540:         // Don't remove the last frame, this is the responsibility of
60540:         // JaegerShot()'s caller. We only guarantee that ScriptEpilogue()
60540:         // has been run.
60540:         if (f.entryfp == f.fp())
52873:             break;
52873: 
69223:         JS_ASSERT(f.regs.sp == cx->regs().sp);
56201:         InlineReturn(f);
52873:     }
52873: 
69223:     JS_ASSERT(f.regs.sp == cx->regs().sp);
52873: 
53626:     if (!pc)
52873:         return NULL;
52873: 
69223:     StackFrame *fp = cx->fp();
55503:     JSScript *script = fp->script();
55520:     return script->nativeCodeForPC(fp->isConstructing(), pc);
52873: }
52873: 
52873: void JS_FASTCALL
64364: stubs::CreateFunCallObject(VMFrame &f)
52873: {
53840:     JS_ASSERT(f.fp()->fun()->isHeavyweight());
64364:     if (!js::CreateFunCallObject(f.cx, f.fp()))
52873:         THROW();
52873: }
52873: 
55503: void JS_FASTCALL
55503: stubs::CreateThis(VMFrame &f, JSObject *proto)
55503: {
55503:     JSContext *cx = f.cx;
69223:     StackFrame *fp = f.fp();
55503:     JSObject *callee = &fp->callee();
55503:     JSObject *obj = js_CreateThisForFunctionWithProto(cx, callee, proto);
55503:     if (!obj)
55503:         THROW();
55503:     fp->formalArgs()[-1].setObject(*obj);
55503: }
55503: 
56201: void JS_FASTCALL
64363: stubs::ScriptDebugPrologue(VMFrame &f)
53133: {
64363:     js::ScriptDebugPrologue(f.cx, f.fp());
56201: }
56201: 
56201: void JS_FASTCALL
64363: stubs::ScriptDebugEpilogue(VMFrame &f)
56201: {
64363:     if (!js::ScriptDebugEpilogue(f.cx, f.fp(), JS_TRUE))
56201:         THROW();
56201: }
53133: 
53133: #ifdef JS_TRACER
53133: 
56201: /*
56201:  * Called when an error is in progress and the topmost frame could not handle
56201:  * it. This will unwind to a given frame, or find and align to an exception
56201:  * handler in the process.
56201:  */
53133: static inline bool
69223: HandleErrorInExcessFrame(VMFrame &f, StackFrame *stopFp, bool searchedTopmostFrame = true)
53133: {
53133:     JSContext *cx = f.cx;
53133: 
54736:     /*
54736:      * Callers of this called either Interpret() or JaegerShot(), which would
54736:      * have searched for exception handlers already. If we see stopFp, just
54736:      * return false. Otherwise, pop the frame, since it's guaranteed useless.
56201:      *
56201:      * Note that this also guarantees ScriptEpilogue() has been called.
54736:      */
69223:     StackFrame *fp = cx->fp();
56201:     if (searchedTopmostFrame) {
60540:         /*
60540:          * This is a special case meaning that fp->finishedInInterpreter() is
60540:          * true. If so, and fp == stopFp, our only choice is to propagate this
60540:          * error up, back to the method JIT, and then to js_InternalThrow,
60540:          * where this becomes a special case. See the comment there and bug
60540:          * 624100.
60540:          */
54736:         if (fp == stopFp)
54736:             return false;
54736: 
60540:         /*
60540:          * Otherwise, the protocol here (like Invoke) is to assume that the
60540:          * execution mode finished the frame, and to just pop it.
60540:          */
56201:         InlineReturn(f);
56201:     }
54736: 
54727:     /* Remove the bottom frame. */
56201:     bool returnOK = false;
54727:     for (;;) {
54736:         fp = cx->fp();
54723: 
54736:         /* Clear imacros. */
54736:         if (fp->hasImacropc()) {
69223:             cx->regs().pc = fp->imacropc();
53840:             fp->clearImacropc();
53133:         }
53840:         JS_ASSERT(!fp->hasImacropc());
53133: 
53133:         /* If there's an exception and a handler, set the pc and leave. */
60211:         if (cx->isExceptionPending()) {
53133:             jsbytecode *pc = FindExceptionHandler(cx);
53133:             if (pc) {
69223:                 cx->regs().pc = pc;
54736:                 returnOK = true;
53133:                 break;
53133:             }
54736:         }
53133: 
53133:         /* Don't unwind if this was the entry frame. */
53133:         if (fp == stopFp)
53133:             break;
53133: 
53133:         /* Unwind and return. */
60211:         returnOK &= bool(js_UnwindScope(cx, 0, returnOK || cx->isExceptionPending()));
56201:         returnOK = ScriptEpilogue(cx, fp, returnOK);
56201:         InlineReturn(f);
53133:     }
53133: 
69223:     JS_ASSERT(&f.regs == &cx->regs());
54739:     JS_ASSERT_IF(!returnOK, cx->fp() == stopFp);
53133: 
54736:     return returnOK;
53133: }
53133: 
56201: /* Returns whether the current PC has method JIT'd code. */
55520: static inline void *
53133: AtSafePoint(JSContext *cx)
53133: {
69223:     StackFrame *fp = cx->fp();
53840:     if (fp->hasImacropc())
68902:         return NULL;
53133: 
53840:     JSScript *script = fp->script();
69223:     return script->maybeNativeCodeForPC(fp->isConstructing(), cx->regs().pc);
53133: }
53133: 
56201: /*
56201:  * Interprets until either a safe point is reached that has method JIT'd
56201:  * code, or the current frame tries to return.
56201:  */
53133: static inline JSBool
53428: PartialInterpret(VMFrame &f)
53133: {
53428:     JSContext *cx = f.cx;
69223:     StackFrame *fp = cx->fp();
53133: 
55503: #ifdef DEBUG
55520:     JSScript *script = fp->script();
56201:     JS_ASSERT(!fp->finishedInInterpreter());
55520:     JS_ASSERT(fp->hasImacropc() ||
69223:               !script->maybeNativeCodeForPC(fp->isConstructing(), cx->regs().pc));
55503: #endif
53133: 
53133:     JSBool ok = JS_TRUE;
53626:     ok = Interpret(cx, fp, 0, JSINTERP_SAFEPOINT);
53133: 
53133:     return ok;
53133: }
53133: 
53133: JS_STATIC_ASSERT(JSOP_NOP == 0);
53133: 
63239: /*
63239:  * Returns whether the current PC would return, or if the frame has already
63239:  * been completed. This distinction avoids re-entering the interpreter or JIT
63239:  * to complete a JSOP_RETURN. Instead, that edge case is handled in
63239:  * HandleFinishedFrame. We could consider reducing complexity, and making this
63239:  * function return only "finishedInInterpreter", and always using the full VM
63239:  * machinery to fully finish frames.
63239:  */
63239: static inline bool
53133: FrameIsFinished(JSContext *cx)
53133: {
69223:     JSOp op = JSOp(*cx->regs().pc);
53133:     return (op == JSOP_RETURN ||
53133:             op == JSOP_RETRVAL ||
53133:             op == JSOP_STOP)
63239:         ? true
63239:         : cx->fp()->finishedInInterpreter();
53133: }
53133: 
56201: 
56201: /* Simulate an inline_return by advancing the pc. */
56201: static inline void
56201: AdvanceReturnPC(JSContext *cx)
56201: {
69223:     JS_ASSERT(*cx->regs().pc == JSOP_CALL ||
69223:               *cx->regs().pc == JSOP_NEW ||
69223:               *cx->regs().pc == JSOP_EVAL ||
69223:               *cx->regs().pc == JSOP_FUNCALL ||
69223:               *cx->regs().pc == JSOP_FUNAPPLY);
69223:     cx->regs().pc += JSOP_CALL_LENGTH;
56201: }
56201: 
56201: 
56201: /*
56201:  * Given a frame that is about to return, make sure its return value and
56201:  * activation objects are fixed up. Then, pop the frame and advance the
56201:  * current PC. Note that while we could enter the JIT at this point, the
56201:  * logic would still be necessary for the interpreter, so it's easier
56201:  * (and faster) to finish frames in C++ even if at a safe point here.
56201:  */
56201: static bool
69223: HandleFinishedFrame(VMFrame &f, StackFrame *entryFrame)
56201: {
56201:     JSContext *cx = f.cx;
56201: 
56201:     JS_ASSERT(FrameIsFinished(cx));
56201: 
56201:     /*
56201:      * This is the most difficult and complicated piece of the tracer
56201:      * integration, and historically has been very buggy. The problem is that
56201:      * although this frame has to be popped (see RemoveExcessFrames), it may
56201:      * be at a JSOP_RETURN opcode, and it might not have ever been executed.
56201:      * That is, fp->rval may not be set to the top of the stack, and if it
56201:      * has, the stack has already been decremented. Note that fp->rval is not
56201:      * the only problem: the epilogue may never have been executed.
56201:      *
56201:      * Here are the edge cases and whether the frame has been exited cleanly:
56201:      *  1. No: A trace exited directly before a RETURN op, and the
56201:      *         interpreter never ran.
56201:      *  2. Yes: The interpreter exited cleanly.
56201:      *  3. No: The interpreter exited on a safe point. LEAVE_ON_SAFE_POINT
56201:      *         is not used in between JSOP_RETURN and advancing the PC,
56201:      *         therefore, it cannot have been run if at a safe point.
56201:      *  4. No: Somewhere in the RunTracer call tree, we removed a frame,
56201:      *         and we returned to a JSOP_RETURN opcode. Note carefully
56201:      *         that in this situation, FrameIsFinished() returns true!
63239:      *  5. Yes: The function exited in the method JIT, during
63239:      *         FinishExcessFrames() However, in this case, we'll never enter
63239:      *         HandleFinishedFrame(): we always immediately pop JIT'd frames.
56201:      *
56201:      * Since the only scenario where this fixup is NOT needed is a normal exit
56201:      * from the interpreter, we can cleanly check for this scenario by checking
56201:      * a bit it sets in the frame.
56201:      */
56201:     bool returnOK = true;
56201:     if (!cx->fp()->finishedInInterpreter()) {
69223:         if (JSOp(*cx->regs().pc) == JSOP_RETURN)
56201:             cx->fp()->setReturnValue(f.regs.sp[-1]);
56201: 
56201:         returnOK = ScriptEpilogue(cx, cx->fp(), true);
56201:     }
56201: 
56201:     if (cx->fp() != entryFrame) {
56201:         InlineReturn(f);
56201:         AdvanceReturnPC(cx);
56201:     }
56201: 
56201:     return returnOK;
56201: }
56201: 
56201: /*
56201:  * Given a frame newer than the entry frame, try to finish it. If it's at a
56201:  * return position, pop the frame. If it's at a safe point, execute it in
56201:  * Jaeger code. Otherwise, try to interpret until a safe point.
56201:  *
56201:  * While this function is guaranteed to make progress, it may not actually
56201:  * finish or pop the current frame. It can either:
56201:  *   1) Finalize a finished frame, or
56201:  *   2) Finish and finalize the frame in the Method JIT, or
56201:  *   3) Interpret, which can:
56201:  *     a) Propagate an error, or
56201:  *     b) Finish the frame, but not finalize it, or
56201:  *     c) Abruptly leave at any point in the frame, or in a newer frame
56201:  *        pushed by a call, that has method JIT'd code.
56201:  */
56201: static bool
69223: EvaluateExcessFrame(VMFrame &f, StackFrame *entryFrame)
56201: {
56201:     JSContext *cx = f.cx;
69223:     StackFrame *fp = cx->fp();
56201: 
56201:     /*
56201:      * A "finished" frame is when the interpreter rested on a STOP,
56201:      * RETURN, RETRVAL, etc. We check for finished frames BEFORE looking
56201:      * for a safe point. If the frame was finished, we could have already
56201:      * called ScriptEpilogue(), and entering the JIT could call it twice.
56201:      */
56201:     if (!fp->hasImacropc() && FrameIsFinished(cx))
56201:         return HandleFinishedFrame(f, entryFrame);
56201: 
56201:     if (void *ncode = AtSafePoint(cx)) {
56201:         if (!JaegerShotAtSafePoint(cx, ncode))
56201:             return false;
56201:         InlineReturn(f);
56201:         AdvanceReturnPC(cx);
56201:         return true;
56201:     }
56201: 
56201:     return PartialInterpret(f);
56201: }
56201: 
56201: /*
56201:  * Evaluate frames newer than the entry frame until all are gone. This will
56201:  * always leave f.regs.fp == entryFrame.
56201:  */
53133: static bool
69223: FinishExcessFrames(VMFrame &f, StackFrame *entryFrame)
53133: {
53133:     JSContext *cx = f.cx;
56201: 
56033:     while (cx->fp() != entryFrame || entryFrame->hasImacropc()) {
56201:         if (!EvaluateExcessFrame(f, entryFrame)) {
56201:             if (!HandleErrorInExcessFrame(f, entryFrame))
56033:                 return false;
53133:         }
53133:     }
53133: 
53133:     return true;
53133: }
53133: 
60591: #if defined JS_MONOIC
53133: static void
58063: UpdateTraceHintSingle(Repatcher &repatcher, JSC::CodeLocationJump jump, JSC::CodeLocationLabel target)
53133: {
53133:     /*
53133:      * Hack: The value that will be patched is before the executable address,
53133:      * so to get protection right, just unprotect the general region around
53133:      * the jump.
53133:      */
58063:     repatcher.relink(jump, target);
53277: 
53277:     JaegerSpew(JSpew_PICs, "relinking trace hint %p to %p\n",
54160:                jump.executableAddress(), target.executableAddress());
53277: }
54160: 
54160: static void
61056: DisableTraceHint(JITScript *jit, ic::TraceICInfo &ic)
54160: {
61056:     Repatcher repatcher(jit);
75716:     UpdateTraceHintSingle(repatcher, ic.traceHint, ic.fastTarget);
54160: 
60567:     if (ic.hasSlowTraceHint)
75716:         UpdateTraceHintSingle(repatcher, ic.slowTraceHint, ic.slowTarget);
56217: }
54160: 
56217: static void
60567: ResetTraceHintAt(JSScript *script, js::mjit::JITScript *jit,
60567:                  jsbytecode *pc, uint16_t index, bool full)
56217: {
59742:     if (index >= jit->nTraceICs)
59742:         return;
62075:     ic::TraceICInfo &ic = jit->traceICs()[index];
60567:     if (!ic.initialized)
59742:         return;
56217:     
60567:     JS_ASSERT(ic.jumpTargetPC == pc);
56217: 
56217:     JaegerSpew(JSpew_PICs, "Enabling trace IC %u in script %p\n", index, script);
56217: 
58063:     Repatcher repatcher(jit);
58063: 
60567:     UpdateTraceHintSingle(repatcher, ic.traceHint, ic.stubEntry);
56217: 
60567:     if (ic.hasSlowTraceHint)
60567:         UpdateTraceHintSingle(repatcher, ic.slowTraceHint, ic.stubEntry);
60567: 
60567:     if (full) {
60567:         ic.traceData = NULL;
60567:         ic.loopCounterStart = 1;
60567:         ic.loopCounter = ic.loopCounterStart;
60567:     }
53133: }
53133: #endif
53133: 
56217: void
60567: js::mjit::ResetTraceHint(JSScript *script, jsbytecode *pc, uint16_t index, bool full)
56217: {
56217: #if JS_MONOIC
56217:     if (script->jitNormal)
60567:         ResetTraceHintAt(script, script->jitNormal, pc, index, full);
56217: 
56217:     if (script->jitCtor)
60567:         ResetTraceHintAt(script, script->jitCtor, pc, index, full);
56217: #endif
56217: }
56217: 
53133: #if JS_MONOIC
53133: void *
60567: RunTracer(VMFrame &f, ic::TraceICInfo &ic)
53133: #else
53133: void *
53133: RunTracer(VMFrame &f)
53133: #endif
53133: {
53133:     JSContext *cx = f.cx;
69223:     StackFrame *entryFrame = f.fp();
53133:     TracePointAction tpa;
53133: 
53133:     /* :TODO: nuke PIC? */
54175:     if (!cx->traceJitEnabled)
53133:         return NULL;
53133: 
55483:     /*
55483:      * Force initialization of the entry frame's scope chain and return value,
55483:      * if necessary.  The tracer can query the scope chain without needing to
55483:      * check the HAS_SCOPECHAIN flag, and the frame is guaranteed to have the
55483:      * correct return value stored if we trace/interpret through to the end
55483:      * of the frame.
55483:      */
55483:     entryFrame->scopeChain();
55483:     entryFrame->returnValue();
55483: 
53133:     bool blacklist;
53422:     uintN inlineCallCount = 0;
56551:     void **traceData;
56551:     uintN *traceEpoch;
60534:     uint32 *loopCounter;
60534:     uint32 hits;
56551: #if JS_MONOIC
60567:     traceData = &ic.traceData;
60567:     traceEpoch = &ic.traceEpoch;
60567:     loopCounter = &ic.loopCounter;
60534:     *loopCounter = 1;
60567:     hits = ic.loopCounterStart;
56551: #else
56551:     traceData = NULL;
56551:     traceEpoch = NULL;
60534:     loopCounter = NULL;
60534:     hits = 1;
56551: #endif
75933: 
75933:     {
75933:         /*
75933:          * While the tracer is running, redirect the regs to a local variable here.
75933:          * If the tracer exits during an inlined frame, it will synthesize those
75933:          * frames, point f.regs.fp at them and then enter the interpreter. If the
75933:          * interpreter pops the frames it will not be reflected here as a local
75933:          * set of regs is used by the interpreter, and f->regs end up pointing at
75933:          * garbage, confusing the recompiler.
75933:          */
76001:         FrameRegs regs = f.regs;
75933:         PreserveRegsGuard regsGuard(cx, regs);
75933: 
60534:         tpa = MonitorTracePoint(f.cx, inlineCallCount, &blacklist, traceData, traceEpoch,
60534:                                 loopCounter, hits);
53133:         JS_ASSERT(!TRACE_RECORDER(cx));
75933:     }
53133: 
53133: #if JS_MONOIC
60567:     ic.loopCounterStart = *loopCounter;
53133:     if (blacklist)
61056:         DisableTraceHint(entryFrame->jit(), ic);
53133: #endif
53133: 
56201:     // Even though ExecuteTree() bypasses the interpreter, it should propagate
56201:     // error failures correctly.
60211:     JS_ASSERT_IF(cx->isExceptionPending(), tpa == TPA_Error);
53133: 
56201:     JS_ASSERT(f.fp() == cx->fp());
53133:     switch (tpa) {
53133:       case TPA_Nothing:
53133:         return NULL;
53133: 
53133:       case TPA_Error:
56201:         if (!HandleErrorInExcessFrame(f, entryFrame, f.fp()->finishedInInterpreter()))
53133:             THROWV(NULL);
53840:         JS_ASSERT(!cx->fp()->hasImacropc());
53133:         break;
53133: 
53133:       case TPA_RanStuff:
53133:       case TPA_Recorded:
53133:         break;
53133:     }
53133: 
53133:     /*
53133:      * The tracer could have dropped us off on any frame at any position.
53133:      * Well, it could not have removed frames (recursion is disabled).
53133:      *
53471:      * Frames after the entryFrame cannot be entered via JaegerShotAtSafePoint()
53471:      * unless each is at a safe point. We can JaegerShotAtSafePoint these
53471:      * frames individually, but we must unwind to the entryFrame.
53471:      *
53471:      * Note carefully that JaegerShotAtSafePoint can resume methods at
53471:      * arbitrary safe points whereas JaegerShot cannot.
53133:      *
53133:      * If we land on entryFrame without a safe point in sight, we'll end up
53133:      * at the RETURN op. This is an edge case with two paths:
53133:      *
53133:      * 1) The entryFrame is the last inline frame. If it fell on a RETURN,
53133:      *    move the return value down.
53133:      * 2) The entryFrame is NOT the last inline frame. Pop the frame.
53133:      *
64365:      * In both cases, we hijack the stub to return to the force-return
64365:      * trampoline. This trampoline simulates the frame-popping portion of
64365:      * emitReturn (except without the benefit of the FrameState) and will
64365:      * produce the necessary register state to return to the caller.
53133:      */
53133: 
53133:   restart:
54736:     /* Step 1. Finish frames created after the entry frame. */
54736:     if (!FinishExcessFrames(f, entryFrame))
53133:         THROWV(NULL);
53133: 
53626:     /* IMacros are guaranteed to have been removed by now. */
56201:     JS_ASSERT(f.fp() == entryFrame);
53840:     JS_ASSERT(!entryFrame->hasImacropc());
53133: 
56201:     /* Step 2. If entryFrame is done, use a special path to return to EnterMethodJIT(). */
56201:     if (FrameIsFinished(cx)) {
56201:         if (!HandleFinishedFrame(f, entryFrame))
53133:             THROWV(NULL);
67899:         *f.returnAddressLocation() = cx->jaegerCompartment()->forceReturnFromFastCall();
53133:         return NULL;
53133:     }
53133: 
56201:     /* Step 3. If entryFrame is at a safe point, just leave. */
56201:     if (void *ncode = AtSafePoint(cx))
56201:         return ncode;
56201: 
53626:     /* Step 4. Do a partial interp, then restart the whole process. */
53428:     if (!PartialInterpret(f)) {
56201:         if (!HandleErrorInExcessFrame(f, entryFrame))
53133:             THROWV(NULL);
53133:     }
53133: 
53133:     goto restart;
53133: }
53133: 
53133: #endif /* JS_TRACER */
53133: 
53136: #if defined JS_TRACER
53136: # if defined JS_MONOIC
53133: void *JS_FASTCALL
60567: stubs::InvokeTracer(VMFrame &f, ic::TraceICInfo *ic)
53133: {
60567:     return RunTracer(f, *ic);
53133: }
53133: 
53133: # else
53133: 
53133: void *JS_FASTCALL
53133: stubs::InvokeTracer(VMFrame &f)
53133: {
53133:     return RunTracer(f);
53133: }
53136: # endif /* JS_MONOIC */
53136: #endif /* JS_TRACER */
53133: 
