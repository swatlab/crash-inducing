73549: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
73021: /* vim: set sw=2 ts=8 et tw=80 : */
70220: /* ***** BEGIN LICENSE BLOCK *****
70220:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
70220:  *
70220:  * The contents of this file are subject to the Mozilla Public License Version
70220:  * 1.1 (the "License"); you may not use this file except in compliance with
70220:  * the License. You may obtain a copy of the License at
70220:  * http://www.mozilla.org/MPL/
70220:  *
70220:  * Software distributed under the License is distributed on an "AS IS" basis,
70220:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
70220:  * for the specific language governing rights and limitations under the
70220:  * License.
70220:  *
70220:  * The Original Code is Mozilla.
70220:  *
70220:  * The Initial Developer of the Original Code is
70220:  * Mozilla Foundation.
70220:  * Portions created by the Initial Developer are Copyright (C) 2010 2011
70220:  * the Initial Developer. All Rights Reserved.
70220:  *
70220:  * Contributor(s):
70220:  *   Wellington Fernando de Macedo <wfernandom2004@gmail.com> (original author)
70220:  *   Patrick McManus <mcmanus@ducksong.com>
70220:  *
70220:  * Alternatively, the contents of this file may be used under the terms of
70220:  * either of the GNU General Public License Version 2 or later (the "GPL"),
70220:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
70220:  * in which case the provisions of the GPL or the LGPL are applicable instead
70220:  * of those above. If you wish to allow use of your version of this file only
70220:  * under the terms of either the GPL or the LGPL, and not to allow others to
70220:  * use your version of this file under the terms of the MPL, indicate your
70220:  * decision by deleting the provisions above and replace them with the notice
70220:  * and other provisions required by the GPL or the LGPL. If you do not delete
70220:  * the provisions above, a recipient may use your version of this file under
70220:  * the terms of any one of the MPL, the GPL or the LGPL.
70220:  *
70220:  * ***** END LICENSE BLOCK ***** */
70220: 
72966: #include "WebSocketLog.h"
73020: #include "WebSocketChannel.h"
70220: 
70220: #include "nsISocketTransportService.h"
70220: #include "nsIURI.h"
70220: #include "nsIChannel.h"
70220: #include "nsICryptoHash.h"
70220: #include "nsIRunnable.h"
70220: #include "nsIPrefBranch.h"
70220: #include "nsIPrefService.h"
70220: #include "nsICancelable.h"
70220: #include "nsIDNSRecord.h"
70220: #include "nsIDNSService.h"
70220: #include "nsIStreamConverterService.h"
70220: #include "nsIIOService2.h"
70220: #include "nsIProtocolProxyService.h"
70220: 
70220: #include "nsAutoPtr.h"
70220: #include "nsStandardURL.h"
70220: #include "nsNetCID.h"
70220: #include "nsServiceManagerUtils.h"
70220: #include "nsXPIDLString.h"
70220: #include "nsCRT.h"
70220: #include "nsThreadUtils.h"
70220: #include "nsNetError.h"
70220: #include "nsStringStream.h"
70220: #include "nsAlgorithm.h"
70220: #include "nsProxyRelease.h"
84709: #include "nsNetUtil.h"
70220: 
70220: #include "plbase64.h"
70220: #include "prmem.h"
70220: #include "prnetdb.h"
70220: #include "prbit.h"
70220: #include "zlib.h"
70220: 
70220: extern PRThread *gSocketThread;
70220: 
70220: namespace mozilla {
70220: namespace net {
70220: 
73020: NS_IMPL_THREADSAFE_ISUPPORTS11(WebSocketChannel,
73019:                                nsIWebSocketChannel,
70220:                                nsIHttpUpgradeListener,
70220:                                nsIRequestObserver,
70220:                                nsIStreamListener,
70220:                                nsIProtocolHandler,
70220:                                nsIInputStreamCallback,
70220:                                nsIOutputStreamCallback,
70220:                                nsITimerCallback,
70220:                                nsIDNSListener,
70220:                                nsIInterfaceRequestor,
70220:                                nsIChannelEventSink)
70220: 
85007: // We implement RFC 6455, which uses Sec-WebSocket-Version: 13 on the wire.
85007: #define SEC_WEBSOCKET_VERSION "13"
70220: 
70220: /*
70220:  * About SSL unsigned certificates
70220:  *
70220:  * wss will not work to a host using an unsigned certificate unless there
70220:  * is already an exception (i.e. it cannot popup a dialog asking for
70220:  * a security exception). This is similar to how an inlined img will
70220:  * fail without a dialog if fails for the same reason. This should not
70220:  * be a problem in practice as it is expected the websocket javascript
70220:  * is served from the same host as the websocket server (or of course,
70220:  * a valid cert could just be provided).
70220:  *
70220:  */
70220: 
70220: // some helper classes
70220: 
84709: //-----------------------------------------------------------------------------
84709: // CallOnMessageAvailable
84709: //-----------------------------------------------------------------------------
84709: 
70220: class CallOnMessageAvailable : public nsIRunnable
70220: {
70220: public:
70220:   NS_DECL_ISUPPORTS
70220: 
80658:   CallOnMessageAvailable(WebSocketChannel *aChannel,
70220:                          nsCString        &aData,
70220:                          PRInt32           aLen)
80658:     : mChannel(aChannel),
70220:       mData(aData),
70220:       mLen(aLen) {}
70220: 
84709:   NS_IMETHOD Run()
70220:   {
70220:     if (mLen < 0)
80658:       mChannel->mListener->OnMessageAvailable(mChannel->mContext, mData);
70220:     else
80658:       mChannel->mListener->OnBinaryMessageAvailable(mChannel->mContext, mData);
70220:     return NS_OK;
70220:   }
70220: 
70220: private:
70220:   ~CallOnMessageAvailable() {}
70220: 
80658:   nsRefPtr<WebSocketChannel>        mChannel;
70220:   nsCString                         mData;
70220:   PRInt32                           mLen;
70220: };
70220: NS_IMPL_THREADSAFE_ISUPPORTS1(CallOnMessageAvailable, nsIRunnable)
70220: 
84709: //-----------------------------------------------------------------------------
84709: // CallOnStop
84709: //-----------------------------------------------------------------------------
84709: 
70220: class CallOnStop : public nsIRunnable
70220: {
70220: public:
70220:   NS_DECL_ISUPPORTS
70220: 
80658:   CallOnStop(WebSocketChannel *aChannel,
70220:              nsresult          aData)
80658:     : mChannel(aChannel),
70220:       mData(aData) {}
70220: 
84709:   NS_IMETHOD Run()
70220:   {
86783:     NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
80658:     mChannel->mListener->OnStop(mChannel->mContext, mData);
70220:     return NS_OK;
70220:   }
70220: 
70220: private:
70220:   ~CallOnStop() {}
70220: 
80658:   nsRefPtr<WebSocketChannel>        mChannel;
70220:   nsresult                          mData;
70220: };
70220: NS_IMPL_THREADSAFE_ISUPPORTS1(CallOnStop, nsIRunnable)
70220: 
84709: //-----------------------------------------------------------------------------
84709: // CallOnServerClose
84709: //-----------------------------------------------------------------------------
84709: 
70220: class CallOnServerClose : public nsIRunnable
70220: {
70220: public:
70220:   NS_DECL_ISUPPORTS
70220: 
80658:   CallOnServerClose(WebSocketChannel *aChannel,
74812:                     PRUint16          aCode,
74812:                     nsCString        &aReason)
80658:     : mChannel(aChannel),
74812:       mCode(aCode),
74812:       mReason(aReason) {}
70220: 
84709:   NS_IMETHOD Run()
70220:   {
80658:     mChannel->mListener->OnServerClose(mChannel->mContext, mCode, mReason);
70220:     return NS_OK;
70220:   }
70220: 
70220: private:
70220:   ~CallOnServerClose() {}
70220: 
80658:   nsRefPtr<WebSocketChannel>        mChannel;
74812:   PRUint16                          mCode;
74812:   nsCString                         mReason;
70220: };
70220: NS_IMPL_THREADSAFE_ISUPPORTS1(CallOnServerClose, nsIRunnable)
70220: 
84709: //-----------------------------------------------------------------------------
84709: // CallAcknowledge
84709: //-----------------------------------------------------------------------------
84709: 
70220: class CallAcknowledge : public nsIRunnable
70220: {
70220: public:
70220:   NS_DECL_ISUPPORTS
70220: 
80658:   CallAcknowledge(WebSocketChannel *aChannel,
70220:                   PRUint32          aSize)
80658:     : mChannel(aChannel),
70220:       mSize(aSize) {}
70220: 
84709:   NS_IMETHOD Run()
70220:   {
73021:     LOG(("WebSocketChannel::CallAcknowledge: Size %u\n", mSize));
80658:     mChannel->mListener->OnAcknowledge(mChannel->mContext, mSize);
70220:     return NS_OK;
70220:   }
70220: 
70220: private:
70220:   ~CallAcknowledge() {}
70220: 
80658:   nsRefPtr<WebSocketChannel>        mChannel;
70220:   PRUint32                          mSize;
70220: };
70220: NS_IMPL_THREADSAFE_ISUPPORTS1(CallAcknowledge, nsIRunnable)
70220: 
84709: //-----------------------------------------------------------------------------
84709: // OutboundMessage
84709: //-----------------------------------------------------------------------------
84709: 
84709: enum WsMsgType {
84709:   kMsgTypeString = 0,
84709:   kMsgTypeBinaryString,
84709:   kMsgTypeStream,
84709:   kMsgTypePing,
84709:   kMsgTypePong,
84709:   kMsgTypeFin
84709: };
84709: 
84709: static const char* msgNames[] = {
84709:   "text",
84709:   "binaryString",
84709:   "binaryStream",
84709:   "ping",
84709:   "pong",
84709:   "close"
84709: };
84709: 
84709: class OutboundMessage
84709: {
84709: public:
84709:   OutboundMessage(WsMsgType type, nsCString *str)
84709:     : mMsgType(type)
84709:   {
84709:     MOZ_COUNT_CTOR(OutboundMessage);
84709:     mMsg.pString = str;
84709:     mLength = str ? str->Length() : 0;
84709:   }
84709: 
84709:   OutboundMessage(nsIInputStream *stream, PRUint32 length)
84709:     : mMsgType(kMsgTypeStream), mLength(length)
84709:   {
84709:     MOZ_COUNT_CTOR(OutboundMessage);
84709:     mMsg.pStream = stream;
84709:     mMsg.pStream->AddRef();
84709:   }
84709: 
84709:  ~OutboundMessage() {
84709:     MOZ_COUNT_DTOR(OutboundMessage);
84709:     switch (mMsgType) {
84709:       case kMsgTypeString:
84709:       case kMsgTypeBinaryString:
84709:       case kMsgTypePing:
84709:       case kMsgTypePong:
84709:         delete mMsg.pString;
84709:         break;
84709:       case kMsgTypeStream:
84709:         // for now this only gets hit if msg deleted w/o being sent
84709:         if (mMsg.pStream) {
84709:           mMsg.pStream->Close();
84709:           mMsg.pStream->Release();
84709:         }
84709:         break;
84709:       case kMsgTypeFin:
84709:         break;    // do-nothing: avoid compiler warning
84709:     }
84709:   }
84709: 
84709:   WsMsgType GetMsgType() const { return mMsgType; }
84709:   PRInt32 Length() const { return mLength; }
84709: 
84709:   PRUint8* BeginWriting() {
84709:     NS_ABORT_IF_FALSE(mMsgType != kMsgTypeStream,
84709:                       "Stream should have been converted to string by now");
84709:     return (PRUint8 *)(mMsg.pString ? mMsg.pString->BeginWriting() : nsnull);
84709:   }
84709: 
84709:   PRUint8* BeginReading() {
84709:     NS_ABORT_IF_FALSE(mMsgType != kMsgTypeStream,
84709:                       "Stream should have been converted to string by now");
84709:     return (PRUint8 *)(mMsg.pString ? mMsg.pString->BeginReading() : nsnull);
84709:   }
84709: 
84709:   nsresult ConvertStreamToString()
84709:   {
84709:     NS_ABORT_IF_FALSE(mMsgType == kMsgTypeStream, "Not a stream!");
84709: 
84709: #ifdef DEBUG
84709:     // Make sure we got correct length from Blob
84709:     PRUint32 bytes;
84709:     mMsg.pStream->Available(&bytes);
84709:     NS_ASSERTION(bytes == mLength, "Stream length != blob length!");
84709: #endif
84709: 
84709:     nsAutoPtr<nsCString> temp(new nsCString());
84709:     nsresult rv = NS_ReadInputStreamToString(mMsg.pStream, *temp, mLength);
84709: 
84709:     NS_ENSURE_SUCCESS(rv, rv);
84709: 
84709:     mMsg.pStream->Close();
84709:     mMsg.pStream->Release();
84709:     mMsg.pString = temp.forget();
84709:     mMsgType = kMsgTypeBinaryString;
84709: 
84709:     return NS_OK;
84709:   }
84709: 
84709: private:
84709:   union {
84709:     nsCString      *pString;
84709:     nsIInputStream *pStream;
84709:   }                           mMsg;
84709:   WsMsgType                   mMsgType;
84709:   PRUint32                    mLength;
84709: };
84709: 
84709: //-----------------------------------------------------------------------------
84709: // OutboundEnqueuer
84709: //-----------------------------------------------------------------------------
84709: 
84709: class OutboundEnqueuer : public nsIRunnable
70220: {
70220: public:
70220:   NS_DECL_ISUPPORTS
70220: 
84709:   OutboundEnqueuer(WebSocketChannel *aChannel, OutboundMessage *aMsg)
84709:     : mChannel(aChannel), mMessage(aMsg) {}
84709: 
84709:   NS_IMETHOD Run()
70220:   {
84709:     mChannel->EnqueueOutgoingMessage(mChannel->mOutgoingMessages, mMessage);
70220:     return NS_OK;
70220:   }
70220: 
70220: private:
84709:   ~OutboundEnqueuer() {}
70220: 
73020:   nsRefPtr<WebSocketChannel>  mChannel;
84709:   OutboundMessage            *mMessage;
70220: };
84709: NS_IMPL_THREADSAFE_ISUPPORTS1(OutboundEnqueuer, nsIRunnable)
84709: 
84709: //-----------------------------------------------------------------------------
84709: // nsWSAdmissionManager
84709: //-----------------------------------------------------------------------------
70220: 
84711: // Section 4.1 requires that only a single websocket at a time can be CONNECTING
84711: // to any given IP address (or hostname, if proxy doing DNS for us). This class
84711: // ensures that we delay connecting until any pending connection for the same
84711: // IP/addr is complete (i.e. until before the 101 upgrade complete response
84711: // comes back and an 'open' javascript event is created)
70220: 
70220: class nsWSAdmissionManager
70220: {
70220: public:
86784:   nsWSAdmissionManager() : mSessionCount(0)
71457:   {
71457:     MOZ_COUNT_CTOR(nsWSAdmissionManager);
71457:   }
70220: 
70220:   class nsOpenConn
70220:   {
70220:   public:
73020:     nsOpenConn(nsCString &addr, WebSocketChannel *channel)
73021:       : mAddress(addr), mChannel(channel) { MOZ_COUNT_CTOR(nsOpenConn); }
71457:     ~nsOpenConn() { MOZ_COUNT_DTOR(nsOpenConn); }
70220: 
70220:     nsCString mAddress;
74992:     WebSocketChannel *mChannel;
70220:   };
70220: 
70220:   ~nsWSAdmissionManager()
70220:   {
71457:     MOZ_COUNT_DTOR(nsWSAdmissionManager);
70220:     for (PRUint32 i = 0; i < mData.Length(); i++)
70220:       delete mData[i];
70220:   }
70220: 
79445:   bool ConditionallyConnect(nsCString &aStr, WebSocketChannel *ws)
70220:   {
70220:     NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
70220: 
70220:     // if aStr is not in mData then we return true, else false.
70220:     // in either case aStr is then added to mData - meaning
70220:     // there will be duplicates when this function has been
70220:     // called with the same parameter multiple times.
70220: 
70220:     // we could hash this, but the dataset is expected to be
70220:     // small
70220: 
84711:     // There may already be another WS channel connecting to this IP address, in
84711:     // which case we'll still create a new nsOpenConn but defer BeginOpen until
84711:     // that channel completes connecting.
79445:     bool found = (IndexOf(aStr) >= 0);
70220:     nsOpenConn *newdata = new nsOpenConn(aStr, ws);
70220:     mData.AppendElement(newdata);
70220: 
74992:     NS_ABORT_IF_FALSE (!ws->mOpenRunning && !ws->mOpenBlocked,
74992:                        "opening state");
74992: 
74992:     if (!found) {
74992:       ws->mOpenRunning = 1;
70220:       ws->BeginOpen();
74993:     } else {
74992:       ws->mOpenBlocked = 1;
74992:     }
74992: 
70220:     return !found;
70220:   }
70220: 
79445:   bool Complete(WebSocketChannel *aChannel)
70220:   {
70220:     NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
74992:     NS_ABORT_IF_FALSE(!aChannel->mOpenBlocked,
74992:                       "blocked, but complete nsOpenConn");
74992: 
74992:     // It is possible this has already been canceled
74992:     if (!aChannel->mOpenRunning)
80486:       return false;
74992: 
74992:     PRInt32 index = IndexOf(aChannel);
70220:     NS_ABORT_IF_FALSE(index >= 0, "completed connection not in open list");
70220: 
74992:     aChannel->mOpenRunning = 0;
70220:     nsOpenConn *olddata = mData[index];
70220:     mData.RemoveElementAt(index);
70220:     delete olddata;
70220: 
70220:     // are there more of the same address pending dispatch?
74993:     return ConnectNext(aChannel->mAddress);
70220:   }
70220: 
79445:   bool Cancel(WebSocketChannel *aChannel)
74992:   {
74992:     NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
74992:     PRInt32 index = IndexOf(aChannel);
74992:     NS_ABORT_IF_FALSE(index >= 0, "Cancelled connection not in open list");
74992:     NS_ABORT_IF_FALSE(aChannel->mOpenRunning ^ aChannel->mOpenBlocked,
74992:                       "cancel without running xor blocked");
74992: 
74992:     bool wasRunning = aChannel->mOpenRunning;
74992:     aChannel->mOpenRunning = 0;
74992:     aChannel->mOpenBlocked = 0;
74992:     nsOpenConn *olddata = mData[index];
74992:     mData.RemoveElementAt(index);
74992:     delete olddata;
74992: 
74992:     // if we are running we can run another one
74993:     if (wasRunning)
74993:       return ConnectNext(aChannel->mAddress);
74993: 
80486:     return false;
74993:   }
74993: 
79445:   bool ConnectNext(nsCString &hostName)
74993:   {
74993:     PRInt32 index = IndexOf(hostName);
74992:     if (index >= 0) {
74993:       WebSocketChannel *chan = mData[index]->mChannel;
74993: 
74993:       NS_ABORT_IF_FALSE(chan->mOpenBlocked,
74992:                         "transaction not blocked but in queue");
74993:       NS_ABORT_IF_FALSE(!chan->mOpenRunning, "transaction already running");
74993: 
74993:       chan->mOpenBlocked = 0;
74993:       chan->mOpenRunning = 1;
74993:       chan->BeginOpen();
80486:       return true;
74992:     }
74992: 
80486:     return false;
74992:   }
74992: 
86784:   void IncrementSessionCount()
72181:   {
86784:     PR_ATOMIC_INCREMENT(&mSessionCount);
72181:   }
72181: 
86784:   void DecrementSessionCount()
72181:   {
86784:     PR_ATOMIC_DECREMENT(&mSessionCount);
72181:   }
72181: 
86784:   PRInt32 SessionCount()
72181:   {
86784:     return mSessionCount;
72181:   }
72181: 
70220: private:
70220:   nsTArray<nsOpenConn *> mData;
70220: 
70220:   PRInt32 IndexOf(nsCString &aStr)
70220:   {
70220:     for (PRUint32 i = 0; i < mData.Length(); i++)
70220:       if (aStr == (mData[i])->mAddress)
70220:         return i;
70220:     return -1;
70220:   }
72181: 
74992:   PRInt32 IndexOf(WebSocketChannel *aChannel)
74992:   {
74992:     for (PRUint32 i = 0; i < mData.Length(); i++)
74992:       if (aChannel == (mData[i])->mChannel)
74992:         return i;
74992:     return -1;
74992:   }
74992: 
86784:   // SessionCount might be decremented from the main or the socket
72181:   // thread, so manage it with atomic counters
86784:   PRInt32 mSessionCount;
70220: };
70220: 
84709: //-----------------------------------------------------------------------------
84709: // nsWSCompression
84709: //
70220: // similar to nsDeflateConverter except for the mandatory FLUSH calls
70220: // required by websocket and the absence of the deflate termination
70220: // block which is appropriate because it would create data bytes after
70220: // sending the websockets CLOSE message.
84709: //-----------------------------------------------------------------------------
70220: 
70220: class nsWSCompression
70220: {
70220: public:
70220:   nsWSCompression(nsIStreamListener *aListener,
70220:                   nsISupports *aContext)
80486:     : mActive(false),
70220:       mContext(aContext),
70220:       mListener(aListener)
70220:   {
71457:     MOZ_COUNT_CTOR(nsWSCompression);
71457: 
70220:     mZlib.zalloc = allocator;
70220:     mZlib.zfree = destructor;
70220:     mZlib.opaque = Z_NULL;
70220: 
70220:     // Initialize the compressor - these are all the normal zlib
70220:     // defaults except window size is set to -15 instead of +15.
70220:     // This is the zlib way of specifying raw RFC 1951 output instead
70220:     // of the zlib rfc 1950 format which has a 2 byte header and
70220:     // adler checksum as a trailer
70220: 
70220:     nsresult rv;
70220:     mStream = do_CreateInstance(NS_STRINGINPUTSTREAM_CONTRACTID, &rv);
70220:     if (NS_SUCCEEDED(rv) && aContext && aListener &&
73021:       deflateInit2(&mZlib, Z_DEFAULT_COMPRESSION, Z_DEFLATED, -15, 8,
73021:                    Z_DEFAULT_STRATEGY) == Z_OK) {
80486:       mActive = true;
70220:     }
70220:   }
70220: 
70220:   ~nsWSCompression()
70220:   {
71457:     MOZ_COUNT_DTOR(nsWSCompression);
71457: 
70220:     if (mActive)
70220:       deflateEnd(&mZlib);
70220:   }
70220: 
79445:   bool Active()
70220:   {
70220:     return mActive;
70220:   }
70220: 
70220:   nsresult Deflate(PRUint8 *buf1, PRUint32 buf1Len,
70220:                    PRUint8 *buf2, PRUint32 buf2Len)
70220:   {
70220:     NS_ABORT_IF_FALSE(PR_GetCurrentThread() == gSocketThread,
70220:                           "not socket thread");
70220:     NS_ABORT_IF_FALSE(mActive, "not active");
70220: 
70220:     mZlib.avail_out = kBufferLen;
70220:     mZlib.next_out = mBuffer;
70220:     mZlib.avail_in = buf1Len;
70220:     mZlib.next_in = buf1;
70220: 
70220:     nsresult rv;
70220: 
70220:     while (mZlib.avail_in > 0) {
70220:       deflate(&mZlib, (buf2Len > 0) ? Z_NO_FLUSH : Z_SYNC_FLUSH);
70220:       rv = PushData();
70220:       if (NS_FAILED(rv))
70220:         return rv;
70220:       mZlib.avail_out = kBufferLen;
70220:       mZlib.next_out = mBuffer;
70220:     }
70220: 
70220:     mZlib.avail_in = buf2Len;
70220:     mZlib.next_in = buf2;
70220: 
70220:     while (mZlib.avail_in > 0) {
70220:       deflate(&mZlib, Z_SYNC_FLUSH);
70220:       rv = PushData();
70220:       if (NS_FAILED(rv))
70220:         return rv;
70220:       mZlib.avail_out = kBufferLen;
70220:       mZlib.next_out = mBuffer;
70220:     }
70220: 
70220:     return NS_OK;
70220:   }
70220: 
70220: private:
70220: 
70220:   // use zlib data types
70220:   static void *allocator(void *opaque, uInt items, uInt size)
70220:   {
70220:     return moz_xmalloc(items * size);
70220:   }
70220: 
70220:   static void destructor(void *opaque, void *addr)
70220:   {
70220:     moz_free(addr);
70220:   }
70220: 
70220:   nsresult PushData()
70220:   {
70220:     PRUint32 bytesToWrite = kBufferLen - mZlib.avail_out;
70220:     if (bytesToWrite > 0) {
70220:       mStream->ShareData(reinterpret_cast<char *>(mBuffer), bytesToWrite);
73021:       nsresult rv =
73021:         mListener->OnDataAvailable(nsnull, mContext, mStream, 0, bytesToWrite);
70220:       if (NS_FAILED(rv))
70220:         return rv;
70220:     }
70220:     return NS_OK;
70220:   }
70220: 
79445:   bool                            mActive;
70220:   z_stream                        mZlib;
70220:   nsCOMPtr<nsIStringInputStream>  mStream;
70220: 
70220:   nsISupports                    *mContext;     /* weak ref */
70220:   nsIStreamListener              *mListener;    /* weak ref */
70220: 
70220:   const static PRInt32            kBufferLen = 4096;
70220:   PRUint8                         mBuffer[kBufferLen];
70220: };
70220: 
70220: static nsWSAdmissionManager *sWebSocketAdmissions = nsnull;
70220: 
84709: //-----------------------------------------------------------------------------
73020: // WebSocketChannel
84709: //-----------------------------------------------------------------------------
73020: 
73020: WebSocketChannel::WebSocketChannel() :
70220:   mCloseTimeout(20000),
70220:   mOpenTimeout(20000),
70220:   mPingTimeout(0),
70220:   mPingResponseTimeout(10000),
72502:   mMaxConcurrentConnections(200),
70220:   mRecvdHttpOnStartRequest(0),
70220:   mRecvdHttpUpgradeTransport(0),
70220:   mRequestedClose(0),
70220:   mClientClosed(0),
70220:   mServerClosed(0),
70220:   mStopped(0),
70220:   mCalledOnStop(0),
70220:   mPingOutstanding(0),
70220:   mAllowCompression(1),
70220:   mAutoFollowRedirects(0),
70220:   mReleaseOnTransmit(0),
72181:   mTCPClosed(0),
74992:   mOpenBlocked(0),
74992:   mOpenRunning(0),
74993:   mChannelWasOpened(0),
85010:   mMaxMessageSize(PR_INT32_MAX),
70220:   mStopOnClose(NS_OK),
74812:   mServerCloseCode(CLOSE_ABNORMAL),
74812:   mScriptCloseCode(0),
75095:   mFragmentOpcode(kContinuation),
70220:   mFragmentAccumulator(0),
70220:   mBuffered(0),
85010:   mBufferSize(kIncomingBufferInitialSize),
70220:   mCurrentOut(nsnull),
70220:   mCurrentOutSent(0),
70220:   mCompressor(nsnull),
70220:   mDynamicOutputSize(0),
70220:   mDynamicOutput(nsnull)
70220: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
70220: 
73020:   LOG(("WebSocketChannel::WebSocketChannel() %p\n", this));
70220: 
70220:   if (!sWebSocketAdmissions)
70220:     sWebSocketAdmissions = new nsWSAdmissionManager();
70220: 
86784:   // The active session limit is enforced in AsyncOpen()
86784:   sWebSocketAdmissions->IncrementSessionCount();
86784: 
70220:   mFramePtr = mBuffer = static_cast<PRUint8 *>(moz_xmalloc(mBufferSize));
70220: }
70220: 
73020: WebSocketChannel::~WebSocketChannel()
70220: {
73020:   LOG(("WebSocketChannel::~WebSocketChannel() %p\n", this));
70220: 
86784:   if (sWebSocketAdmissions)
86784:     sWebSocketAdmissions->DecrementSessionCount();
86784: 
70220:   // this stop is a nop if the normal connect/close is followed
70220:   mStopped = 1;
70220:   StopSession(NS_ERROR_UNEXPECTED);
74992:   NS_ABORT_IF_FALSE(!mOpenRunning && !mOpenBlocked, "op");
70220: 
70220:   moz_free(mBuffer);
70220:   moz_free(mDynamicOutput);
70220:   delete mCompressor;
70220:   delete mCurrentOut;
70220: 
70220:   while ((mCurrentOut = (OutboundMessage *) mOutgoingPingMessages.PopFront()))
70220:     delete mCurrentOut;
70220:   while ((mCurrentOut = (OutboundMessage *) mOutgoingPongMessages.PopFront()))
70220:     delete mCurrentOut;
70220:   while ((mCurrentOut = (OutboundMessage *) mOutgoingMessages.PopFront()))
70220:     delete mCurrentOut;
70220: 
70220:   nsCOMPtr<nsIThread> mainThread;
70220:   nsIURI *forgettable;
70220:   NS_GetMainThread(getter_AddRefs(mainThread));
70220: 
70220:   if (mURI) {
70220:     mURI.forget(&forgettable);
80486:     NS_ProxyRelease(mainThread, forgettable, false);
70220:   }
70220: 
70220:   if (mOriginalURI) {
70220:     mOriginalURI.forget(&forgettable);
80486:     NS_ProxyRelease(mainThread, forgettable, false);
70220:   }
70220: 
70220:   if (mListener) {
70220:     nsIWebSocketListener *forgettableListener;
70220:     mListener.forget(&forgettableListener);
80486:     NS_ProxyRelease(mainThread, forgettableListener, false);
70220:   }
70220: 
70220:   if (mContext) {
70220:     nsISupports *forgettableContext;
70220:     mContext.forget(&forgettableContext);
80486:     NS_ProxyRelease(mainThread, forgettableContext, false);
70220:   }
73548: 
73548:   if (mLoadGroup) {
73548:     nsILoadGroup *forgettableGroup;
73548:     mLoadGroup.forget(&forgettableGroup);
80486:     NS_ProxyRelease(mainThread, forgettableGroup, false);
73548:   }
70220: }
70220: 
70220: void
73020: WebSocketChannel::Shutdown()
70220: {
70220:   delete sWebSocketAdmissions;
70220:   sWebSocketAdmissions = nsnull;
70220: }
70220: 
70220: nsresult
73020: WebSocketChannel::BeginOpen()
70220: {
73020:   LOG(("WebSocketChannel::BeginOpen() %p\n", this));
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
70220: 
70220:   nsresult rv;
70220: 
70220:   if (mRedirectCallback) {
73021:     LOG(("WebSocketChannel::BeginOpen: Resuming Redirect\n"));
70220:     rv = mRedirectCallback->OnRedirectVerifyCallback(NS_OK);
70220:     mRedirectCallback = nsnull;
70220:     return rv;
70220:   }
70220: 
70220:   nsCOMPtr<nsIChannel> localChannel = do_QueryInterface(mChannel, &rv);
70220:   if (NS_FAILED(rv)) {
73021:     LOG(("WebSocketChannel::BeginOpen: cannot async open\n"));
70220:     AbortSession(NS_ERROR_CONNECTION_REFUSED);
70220:     return rv;
70220:   }
70220: 
70220:   rv = localChannel->AsyncOpen(this, mHttpChannel);
70220:   if (NS_FAILED(rv)) {
73021:     LOG(("WebSocketChannel::BeginOpen: cannot async open\n"));
70220:     AbortSession(NS_ERROR_CONNECTION_REFUSED);
70220:     return rv;
70220:   }
74993:   mChannelWasOpened = 1;
70220: 
70220:   mOpenTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
70220:   if (NS_SUCCEEDED(rv))
73021:     mOpenTimer->InitWithCallback(this, mOpenTimeout, nsITimer::TYPE_ONE_SHOT);
70220: 
70220:   return rv;
70220: }
70220: 
79445: bool
73020: WebSocketChannel::IsPersistentFramePtr()
70220: {
70220:   return (mFramePtr >= mBuffer && mFramePtr < mBuffer + mBufferSize);
70220: }
70220: 
73021: // Extends the internal buffer by count and returns the total
70220: // amount of data available for read
74275: //
74275: // Accumulated fragment size is passed in instead of using the member
74275: // variable beacuse when transitioning from the stack to the persistent
74275: // read buffer we want to explicitly include them in the buffer instead
74275: // of as already existing data.
85010: bool
74275: WebSocketChannel::UpdateReadBuffer(PRUint8 *buffer, PRUint32 count,
85010:                                    PRUint32 accumulatedFragments,
85010:                                    PRUint32 *available)
70220: {
73020:   LOG(("WebSocketChannel::UpdateReadBuffer() %p [%p %u]\n",
70220:          this, buffer, count));
70220: 
70220:   if (!mBuffered)
70220:     mFramePtr = mBuffer;
70220: 
73021:   NS_ABORT_IF_FALSE(IsPersistentFramePtr(), "update read buffer bad mFramePtr");
74275:   NS_ABORT_IF_FALSE(mFramePtr - accumulatedFragments >= mBuffer,
74275:                     "reserved FramePtr bad");
70220: 
70220:   if (mBuffered + count <= mBufferSize) {
70220:     // append to existing buffer
73021:     LOG(("WebSocketChannel: update read buffer absorbed %u\n", count));
74275:   } else if (mBuffered + count - 
74275:              (mFramePtr - accumulatedFragments - mBuffer) <= mBufferSize) {
70220:     // make room in existing buffer by shifting unused data to start
74275:     mBuffered -= (mFramePtr - mBuffer - accumulatedFragments);
73021:     LOG(("WebSocketChannel: update read buffer shifted %u\n", mBuffered));
74275:     ::memmove(mBuffer, mFramePtr - accumulatedFragments, mBuffered);
74275:     mFramePtr = mBuffer + accumulatedFragments;
73021:   } else {
70220:     // existing buffer is not sufficient, extend it
85010:     mBufferSize += count + 8192 + mBufferSize/3;
73021:     LOG(("WebSocketChannel: update read buffer extended to %u\n", mBufferSize));
70220:     PRUint8 *old = mBuffer;
85010:     mBuffer = (PRUint8 *)moz_realloc(mBuffer, mBufferSize);
85010:     if (!mBuffer) {
85010:       mBuffer = old;
85010:       return false;
85010:     }
70220:     mFramePtr = mBuffer + (mFramePtr - old);
70220:   }
70220: 
70220:   ::memcpy(mBuffer + mBuffered, buffer, count);
70220:   mBuffered += count;
70220: 
85010:   if (available)
85010:     *available = mBuffered - (mFramePtr - mBuffer);
85010: 
85010:   return true;
70220: }
70220: 
70220: nsresult
73020: WebSocketChannel::ProcessInput(PRUint8 *buffer, PRUint32 count)
70220: {
73021:   LOG(("WebSocketChannel::ProcessInput %p [%d %d]\n", this, count, mBuffered));
73021:   NS_ABORT_IF_FALSE(PR_GetCurrentThread() == gSocketThread, "not socket thread");
70220: 
70220:   // reset the ping timer
70220:   if (mPingTimer) {
70220:     // The purpose of ping/pong is to actively probe the peer so that an
70220:     // unreachable peer is not mistaken for a period of idleness. This
73021:     // implementation accepts any application level read activity as a sign of
73021:     // life, it does not necessarily have to be a pong.
70220:     mPingOutstanding = 0;
70220:     mPingTimer->SetDelay(mPingTimeout);
70220:   }
70220: 
70220:   PRUint32 avail;
70220: 
70220:   if (!mBuffered) {
73021:     // Most of the time we can process right off the stack buffer without
73021:     // having to accumulate anything
70220:     mFramePtr = buffer;
70220:     avail = count;
73021:   } else {
85010:     if (!UpdateReadBuffer(buffer, count, mFragmentAccumulator, &avail)) {
85010:       AbortSession(NS_ERROR_FILE_TOO_BIG);
85010:       return NS_ERROR_FILE_TOO_BIG;
85010:     }
70220:   }
70220: 
70220:   PRUint8 *payload;
70220:   PRUint32 totalAvail = avail;
70220: 
70220:   while (avail >= 2) {
70220:     PRInt64 payloadLength = mFramePtr[1] & 0x7F;
70220:     PRUint8 finBit        = mFramePtr[0] & kFinalFragBit;
70220:     PRUint8 rsvBits       = mFramePtr[0] & 0x70;
70220:     PRUint8 maskBit       = mFramePtr[1] & kMaskBit;
70220:     PRUint8 opcode        = mFramePtr[0] & 0x0F;
70220: 
70220:     PRUint32 framingLength = 2;
70220:     if (maskBit)
70220:       framingLength += 4;
70220: 
70220:     if (payloadLength < 126) {
70220:       if (avail < framingLength)
70220:         break;
73021:     } else if (payloadLength == 126) {
70220:       // 16 bit length field
70220:       framingLength += 2;
70220:       if (avail < framingLength)
70220:         break;
70220: 
70220:       payloadLength = mFramePtr[2] << 8 | mFramePtr[3];
73021:     } else {
70220:       // 64 bit length
70220:       framingLength += 8;
70220:       if (avail < framingLength)
70220:         break;
72178: 
72178:       if (mFramePtr[2] & 0x80) {
72178:         // Section 4.2 says that the most significant bit MUST be
72178:         // 0. (i.e. this is really a 63 bit value)
73020:         LOG(("WebSocketChannel:: high bit of 64 bit length set"));
72178:         AbortSession(NS_ERROR_ILLEGAL_VALUE);
72178:         return NS_ERROR_ILLEGAL_VALUE;
72178:       }
72178: 
70220:       // copy this in case it is unaligned
70220:       PRUint64 tempLen;
70220:       memcpy(&tempLen, mFramePtr + 2, 8);
70220:       payloadLength = PR_ntohll(tempLen);
70220:     }
70220: 
70220:     payload = mFramePtr + framingLength;
70220:     avail -= framingLength;
70220: 
73021:     LOG(("WebSocketChannel::ProcessInput: payload %lld avail %lu\n",
70220:          payloadLength, avail));
70220: 
70220:     if (payloadLength + mFragmentAccumulator > mMaxMessageSize) {
70220:       AbortSession(NS_ERROR_FILE_TOO_BIG);
70220:       return NS_ERROR_FILE_TOO_BIG;
70220:     }
70220: 
70220:     if (avail < payloadLength)
70220:       break;
70220: 
73021:     LOG(("WebSocketChannel::ProcessInput: Frame accumulated - opcode %d\n",
70220:          opcode));
70220: 
70220:     if (maskBit) {
70220:       // This is unexpected - the server does not generally send masked
70220:       // frames to the client, but it is allowed
73020:       LOG(("WebSocketChannel:: Client RECEIVING masked frame."));
70220: 
70220:       PRUint32 mask;
70220:       memcpy(&mask, payload - 4, 4);
70220:       mask = PR_ntohl(mask);
70220:       ApplyMask(mask, payload, payloadLength);
70220:     }
70220: 
73021:     // Control codes are required to have the fin bit set
70220:     if (!finBit && (opcode & kControlFrameMask)) {
73021:       LOG(("WebSocketChannel:: fragmented control frame code %d\n", opcode));
70220:       AbortSession(NS_ERROR_ILLEGAL_VALUE);
70220:       return NS_ERROR_ILLEGAL_VALUE;
70220:     }
70220: 
70220:     if (rsvBits) {
73020:       LOG(("WebSocketChannel:: unexpected reserved bits %x\n", rsvBits));
70220:       AbortSession(NS_ERROR_ILLEGAL_VALUE);
70220:       return NS_ERROR_ILLEGAL_VALUE;
70220:     }
70220: 
70220:     if (!finBit || opcode == kContinuation) {
70220:       // This is part of a fragment response
70220: 
73021:       // Only the first frame has a non zero op code: Make sure we don't see a
73021:       // first frame while some old fragments are open
70220:       if ((mFragmentAccumulator != 0) && (opcode != kContinuation)) {
75095:         LOG(("WebSocketChannel:: nested fragments\n"));
70220:         AbortSession(NS_ERROR_ILLEGAL_VALUE);
70220:         return NS_ERROR_ILLEGAL_VALUE;
70220:       }
70220: 
73021:       LOG(("WebSocketChannel:: Accumulating Fragment %lld\n", payloadLength));
70220: 
70220:       if (opcode == kContinuation) {
75095: 
75095:         // Make sure this continuation fragment isn't the first fragment
75095:         if (mFragmentOpcode == kContinuation) {
75095:           LOG(("WebSocketHeandler:: continuation code in first fragment\n"));
75095:           AbortSession(NS_ERROR_ILLEGAL_VALUE);
75095:           return NS_ERROR_ILLEGAL_VALUE;
75095:         }
75095: 
73021:         // For frag > 1 move the data body back on top of the headers
70220:         // so we have contiguous stream of data
70220:         NS_ABORT_IF_FALSE(mFramePtr + framingLength == payload,
70220:                           "payload offset from frameptr wrong");
70220:         ::memmove(mFramePtr, payload, avail);
70220:         payload = mFramePtr;
70220:         if (mBuffered)
70220:           mBuffered -= framingLength;
73021:       } else {
70220:         mFragmentOpcode = opcode;
70220:       }
70220: 
70220:       if (finBit) {
73020:         LOG(("WebSocketChannel:: Finalizing Fragment\n"));
70220:         payload -= mFragmentAccumulator;
70220:         payloadLength += mFragmentAccumulator;
70220:         avail += mFragmentAccumulator;
70220:         mFragmentAccumulator = 0;
70220:         opcode = mFragmentOpcode;
75095:         // reset to detect if next message illegally starts with continuation
75095:         mFragmentOpcode = kContinuation;
70220:       } else {
70220:         opcode = kContinuation;
70220:         mFragmentAccumulator += payloadLength;
70220:       }
73021:     } else if (mFragmentAccumulator != 0 && !(opcode & kControlFrameMask)) {
73021:       // This frame is not part of a fragment sequence but we
70220:       // have an open fragment.. it must be a control code or else
70220:       // we have a problem
73021:       LOG(("WebSocketChannel:: illegal fragment sequence\n"));
70220:       AbortSession(NS_ERROR_ILLEGAL_VALUE);
70220:       return NS_ERROR_ILLEGAL_VALUE;
70220:     }
70220: 
70220:     if (mServerClosed) {
73020:       LOG(("WebSocketChannel:: ignoring read frame code %d after close\n",
70220:                  opcode));
70220:       // nop
73021:     } else if (mStopped) {
73021:       LOG(("WebSocketChannel:: ignoring read frame code %d after completion\n",
70220:            opcode));
73021:     } else if (opcode == kText) {
73020:       LOG(("WebSocketChannel:: text frame received\n"));
70220:       if (mListener) {
70220:         nsCString utf8Data((const char *)payload, payloadLength);
72179: 
85008:         // Section 8.1 says to fail connection if invalid utf-8 in text message
80486:         if (!IsUTF8(utf8Data, false)) {
73020:           LOG(("WebSocketChannel:: text frame invalid utf-8\n"));
85008:           AbortSession(NS_ERROR_CANNOT_CONVERT_DATA);
72179:           return NS_ERROR_ILLEGAL_VALUE;
72179:         }
72179: 
80658:         NS_DispatchToMainThread(new CallOnMessageAvailable(this, utf8Data, -1));
70220:       }
73021:     } else if (opcode & kControlFrameMask) {
70220:       // control frames
70220:       if (payloadLength > 125) {
73020:         LOG(("WebSocketChannel:: bad control frame code %d length %d\n",
70220:              opcode, payloadLength));
70220:         AbortSession(NS_ERROR_ILLEGAL_VALUE);
70220:         return NS_ERROR_ILLEGAL_VALUE;
70220:       }
70220: 
70220:       if (opcode == kClose) {
73020:         LOG(("WebSocketChannel:: close received\n"));
70220:         mServerClosed = 1;
70220: 
74812:         mServerCloseCode = CLOSE_NO_STATUS;
70220:         if (payloadLength >= 2) {
74812:           memcpy(&mServerCloseCode, payload, 2);
74812:           mServerCloseCode = PR_ntohs(mServerCloseCode);
74812:           LOG(("WebSocketChannel:: close recvd code %u\n", mServerCloseCode));
70220:           PRUint16 msglen = payloadLength - 2;
70220:           if (msglen > 0) {
74812:             mServerCloseReason.SetLength(msglen);
74812:             memcpy(mServerCloseReason.BeginWriting(),
74812:                    (const char *)payload + 2, msglen);
72179: 
72179:             // section 8.1 says to replace received non utf-8 sequences
72179:             // (which are non-conformant to send) with u+fffd,
72179:             // but secteam feels that silently rewriting messages is
72179:             // inappropriate - so we will fail the connection instead.
80486:             if (!IsUTF8(mServerCloseReason, false)) {
73020:               LOG(("WebSocketChannel:: close frame invalid utf-8\n"));
72179:               AbortSession(NS_ERROR_ILLEGAL_VALUE);
72179:               return NS_ERROR_ILLEGAL_VALUE;
72179:             }
72179: 
74812:             LOG(("WebSocketChannel:: close msg %s\n",
74812:                  mServerCloseReason.get()));
70220:           }
70220:         }
70220: 
70220:         if (mCloseTimer) {
70220:           mCloseTimer->Cancel();
70220:           mCloseTimer = nsnull;
70220:         }
80658:         if (mListener) {
80658:           NS_DispatchToMainThread(new CallOnServerClose(this, mServerCloseCode,
80658:                                                         mServerCloseReason));
80658:         }
70220: 
70220:         if (mClientClosed)
70220:           ReleaseSession();
73021:       } else if (opcode == kPing) {
73020:         LOG(("WebSocketChannel:: ping received\n"));
70220:         GeneratePong(payload, payloadLength);
74912:       } else if (opcode == kPong) {
73021:         // opcode kPong: the mere act of receiving the packet is all we need
73021:         // to do for the pong to trigger the activity timers
73020:         LOG(("WebSocketChannel:: pong received\n"));
74912:       } else {
74912:         /* unknown control frame opcode */
74912:         LOG(("WebSocketChannel:: unknown control op code %d\n", opcode));
74912:         AbortSession(NS_ERROR_ILLEGAL_VALUE);
74912:         return NS_ERROR_ILLEGAL_VALUE;
70220:       }
70220: 
70220:       if (mFragmentAccumulator) {
73021:         // Remove the control frame from the stream so we have a contiguous
73021:         // data buffer of reassembled fragments
73020:         LOG(("WebSocketChannel:: Removing Control From Read buffer\n"));
70220:         NS_ABORT_IF_FALSE(mFramePtr + framingLength == payload,
70220:                           "payload offset from frameptr wrong");
73021:         ::memmove(mFramePtr, payload + payloadLength, avail - payloadLength);
70220:         payload = mFramePtr;
70220:         avail -= payloadLength;
70220:         if (mBuffered)
70220:           mBuffered -= framingLength + payloadLength;
74911:         payloadLength = 0;
70220:       }
73021:     } else if (opcode == kBinary) {
73020:       LOG(("WebSocketChannel:: binary frame received\n"));
70220:       if (mListener) {
72179:         nsCString binaryData((const char *)payload, payloadLength);
80658:         NS_DispatchToMainThread(new CallOnMessageAvailable(this, binaryData,
73021:                                                            payloadLength));
70220:       }
73021:     } else if (opcode != kContinuation) {
70220:       /* unknown opcode */
73020:       LOG(("WebSocketChannel:: unknown op code %d\n", opcode));
70220:       AbortSession(NS_ERROR_ILLEGAL_VALUE);
70220:       return NS_ERROR_ILLEGAL_VALUE;
70220:     }
70220: 
70220:     mFramePtr = payload + payloadLength;
70220:     avail -= payloadLength;
70220:     totalAvail = avail;
70220:   }
70220: 
70220:   // Adjust the stateful buffer. If we were operating off the stack and
70220:   // now have a partial message then transition to the buffer, or if
70220:   // we were working off the buffer but no longer have any active state
70220:   // then transition to the stack
70220:   if (!IsPersistentFramePtr()) {
70220:     mBuffered = 0;
70220: 
70220:     if (mFragmentAccumulator) {
73020:       LOG(("WebSocketChannel:: Setup Buffer due to fragment"));
70220: 
85010:       if (!UpdateReadBuffer(mFramePtr - mFragmentAccumulator,
85010:                             totalAvail + mFragmentAccumulator, 0, nsnull)) {
85010:         AbortSession(NS_ERROR_ILLEGAL_VALUE);
85010:         return NS_ERROR_ILLEGAL_VALUE;
85010:       }
70220: 
70220:       // UpdateReadBuffer will reset the frameptr to the beginning
70220:       // of new saved state, so we need to skip past processed framgents
70220:       mFramePtr += mFragmentAccumulator;
73021:     } else if (totalAvail) {
73020:       LOG(("WebSocketChannel:: Setup Buffer due to partial frame"));
85010:       if (!UpdateReadBuffer(mFramePtr, totalAvail, 0, nsnull)) {
85010:         AbortSession(NS_ERROR_ILLEGAL_VALUE);
85010:         return NS_ERROR_ILLEGAL_VALUE;
85010:       }
70220:     }
73021:   } else if (!mFragmentAccumulator && !totalAvail) {
73021:     // If we were working off a saved buffer state and there is no partial
73021:     // frame or fragment in process, then revert to stack behavior
73020:     LOG(("WebSocketChannel:: Internal buffering not needed anymore"));
70220:     mBuffered = 0;
85010: 
85010:     // release memory if we've been processing a large message
85010:     if (mBufferSize > kIncomingBufferStableSize) {
85010:       mBufferSize = kIncomingBufferStableSize;
85010:       moz_free(mBuffer);
85010:       mBuffer = (PRUint8 *)moz_xmalloc(mBufferSize);
85010:     }
70220:   }
70220:   return NS_OK;
70220: }
70220: 
70220: void
73020: WebSocketChannel::ApplyMask(PRUint32 mask, PRUint8 *data, PRUint64 len)
70220: {
84709:   if (!data || len == 0)
84709:     return;
84709: 
70220:   // Optimally we want to apply the mask 32 bits at a time,
70220:   // but the buffer might not be alligned. So we first deal with
70220:   // 0 to 3 bytes of preamble individually
70220: 
71288:   while (len && (reinterpret_cast<PRUptrdiff>(data) & 3)) {
70220:     *data ^= mask >> 24;
70220:     mask = PR_ROTATE_LEFT32(mask, 8);
70220:     data++;
70220:     len--;
70220:   }
70220: 
70220:   // perform mask on full words of data
70220: 
70220:   PRUint32 *iData = (PRUint32 *) data;
70220:   PRUint32 *end = iData + (len / 4);
70220:   mask = PR_htonl(mask);
70220:   for (; iData < end; iData++)
70220:     *iData ^= mask;
70220:   mask = PR_ntohl(mask);
70220:   data = (PRUint8 *)iData;
70220:   len  = len % 4;
70220: 
70220:   // There maybe up to 3 trailing bytes that need to be dealt with
70220:   // individually 
70220: 
70220:   while (len) {
70220:     *data ^= mask >> 24;
70220:     mask = PR_ROTATE_LEFT32(mask, 8);
70220:     data++;
70220:     len--;
70220:   }
70220: }
70220: 
70220: void
73020: WebSocketChannel::GeneratePing()
70220: {
70220:   nsCString *buf = new nsCString();
70220:   buf->Assign("PING");
84709:   EnqueueOutgoingMessage(mOutgoingPingMessages,
84709:                          new OutboundMessage(kMsgTypePing, buf));
70220: }
70220: 
70220: void
73020: WebSocketChannel::GeneratePong(PRUint8 *payload, PRUint32 len)
70220: {
70220:   nsCString *buf = new nsCString();
70220:   buf->SetLength(len);
70220:   if (buf->Length() < len) {
73020:     LOG(("WebSocketChannel::GeneratePong Allocation Failure\n"));
70220:     delete buf;
70220:     return;
70220:   }
70220: 
70220:   memcpy(buf->BeginWriting(), payload, len);
84709:   EnqueueOutgoingMessage(mOutgoingPongMessages,
84709:                          new OutboundMessage(kMsgTypePong, buf));
84709: }
84709: 
84709: void
84709: WebSocketChannel::EnqueueOutgoingMessage(nsDeque &aQueue,
84709:                                          OutboundMessage *aMsg)
84709: {
84709:   NS_ABORT_IF_FALSE(PR_GetCurrentThread() == gSocketThread, "not socket thread");
84709: 
84709:   LOG(("WebSocketChannel::EnqueueOutgoingMessage %p "
84709:        "queueing msg %p [type=%s len=%d]\n",
84709:        this, aMsg, msgNames[aMsg->GetMsgType()], aMsg->Length()));
84709: 
84709:   aQueue.Push(aMsg);
70220:   OnOutputStreamReady(mSocketOut);
70220: }
70220: 
70220: 
72180: PRUint16
73020: WebSocketChannel::ResultToCloseCode(nsresult resultCode)
72180: {
72180:   if (NS_SUCCEEDED(resultCode))
74812:     return CLOSE_NORMAL;
72180:   if (resultCode == NS_ERROR_FILE_TOO_BIG)
74812:     return CLOSE_TOO_LARGE;
72180:   if (resultCode == NS_BASE_STREAM_CLOSED ||
72180:       resultCode == NS_ERROR_NET_TIMEOUT ||
73021:       resultCode == NS_ERROR_CONNECTION_REFUSED) {
74812:     return CLOSE_ABNORMAL;
73021:   }
85008:   if (resultCode == NS_ERROR_CANNOT_CONVERT_DATA)
85008:     return CLOSE_INVALID_PAYLOAD;
72180: 
74812:   return CLOSE_PROTOCOL_ERROR;
72180: }
72180: 
70220: void
73020: WebSocketChannel::PrimeNewOutgoingMessage()
70220: {
73020:   LOG(("WebSocketChannel::PrimeNewOutgoingMessage() %p\n", this));
73021:   NS_ABORT_IF_FALSE(PR_GetCurrentThread() == gSocketThread, "not socket thread");
70220:   NS_ABORT_IF_FALSE(!mCurrentOut, "Current message in progress");
70220: 
84709:   nsresult rv = NS_OK;
70220: 
70220:   mCurrentOut = (OutboundMessage *)mOutgoingPongMessages.PopFront();
70220:   if (mCurrentOut) {
84709:     NS_ABORT_IF_FALSE(mCurrentOut->GetMsgType() == kMsgTypePong,
84709:                      "Not pong message!");
70220:   } else {
70220:     mCurrentOut = (OutboundMessage *)mOutgoingPingMessages.PopFront();
70220:     if (mCurrentOut)
84709:       NS_ABORT_IF_FALSE(mCurrentOut->GetMsgType() == kMsgTypePing,
84709:                         "Not ping message!");
70220:     else
70220:       mCurrentOut = (OutboundMessage *)mOutgoingMessages.PopFront();
70220:   }
70220: 
70220:   if (!mCurrentOut)
70220:     return;
84709: 
84709:   WsMsgType msgType = mCurrentOut->GetMsgType();
84709: 
84709:   LOG(("WebSocketChannel::PrimeNewOutgoingMessage "
84709:        "%p found queued msg %p [type=%s len=%d]\n",
84709:        this, mCurrentOut, msgNames[msgType], mCurrentOut->Length()));
84709: 
70220:   mCurrentOutSent = 0;
70220:   mHdrOut = mOutHeader;
70220: 
70220:   PRUint8 *payload = nsnull;
84709: 
84709:   if (msgType == kMsgTypeFin) {
70220:     // This is a demand to create a close message
70220:     if (mClientClosed) {
70220:       PrimeNewOutgoingMessage();
70220:       return;
70220:     }
70220: 
70220:     mClientClosed = 1;
70220:     mOutHeader[0] = kFinalFragBit | kClose;
74812:     mOutHeader[1] = 0x02; // payload len = 2, maybe more for reason
70220:     mOutHeader[1] |= kMaskBit;
70220: 
70220:     // payload is offset 6 including 4 for the mask
70220:     payload = mOutHeader + 6;
70220: 
74812:     // length is 8 plus any reason information
74812:     mHdrOutToSend = 8;
74812: 
70220:     // The close reason code sits in the first 2 bytes of payload
74812:     // If the channel user provided a code and reason during Close()
74812:     // and there isn't an internal error, use that.
74812:     if (NS_SUCCEEDED(mStopOnClose) && mScriptCloseCode) {
74812:       *((PRUint16 *)payload) = PR_htons(mScriptCloseCode);
74812:       if (!mScriptCloseReason.IsEmpty()) {
74812:         NS_ABORT_IF_FALSE(mScriptCloseReason.Length() <= 123,
74812:                           "Close Reason Too Long");
74812:         mOutHeader[1] += mScriptCloseReason.Length();
74812:         mHdrOutToSend += mScriptCloseReason.Length();
74812:         memcpy (payload + 2,
74812:                 mScriptCloseReason.BeginReading(),
74812:                 mScriptCloseReason.Length());
74812:       }
74993:     } else {
72180:       *((PRUint16 *)payload) = PR_htons(ResultToCloseCode(mStopOnClose));
74812:     }
74812: 
70220:     if (mServerClosed) {
70220:       /* bidi close complete */
70220:       mReleaseOnTransmit = 1;
73021:     } else if (NS_FAILED(mStopOnClose)) {
70220:       /* result of abort session - give up */
70220:       StopSession(mStopOnClose);
73021:     } else {
70220:       /* wait for reciprocal close from server */
70220:       mCloseTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
70220:       if (NS_SUCCEEDED(rv)) {
70220:         mCloseTimer->InitWithCallback(this, mCloseTimeout,
70220:                                       nsITimer::TYPE_ONE_SHOT);
73021:       } else {
70220:         StopSession(rv);
70220:       }
70220:     }
73021:   } else {
84709:     switch (msgType) {
84709:     case kMsgTypePong:
73021:       mOutHeader[0] = kFinalFragBit | kPong;
84709:       break;
84709:     case kMsgTypePing:
73021:       mOutHeader[0] = kFinalFragBit | kPing;
84709:       break;
84709:     case kMsgTypeString:
73021:       mOutHeader[0] = kFinalFragBit | kText;
84709:       break;
84709:     case kMsgTypeStream:
84709:       // HACK ALERT:  read in entire stream into string.
84709:       // Will block socket transport thread if file is blocking.
84709:       // TODO: bug 704447:  don't block socket thread!
84709:       rv = mCurrentOut->ConvertStreamToString();
84709:       if (NS_FAILED(rv)) {
84709:         AbortSession(rv);
84709:         return;
84709:       }
84709:       // Now we're a binary string
84709:       msgType = kMsgTypeBinaryString;
84709: 
84709:       // no break: fall down into binary string case
84709: 
84709:     case kMsgTypeBinaryString:
70220:       mOutHeader[0] = kFinalFragBit | kBinary;
84709:       break;
84709:     case kMsgTypeFin:
84709:       NS_ABORT_IF_FALSE(false, "unreachable");  // avoid compiler warning
84709:       break;
70220:     }
70220: 
70220:     if (mCurrentOut->Length() < 126) {
70220:       mOutHeader[1] = mCurrentOut->Length() | kMaskBit;
70220:       mHdrOutToSend = 6;
79358:     } else if (mCurrentOut->Length() <= 0xffff) {
70220:       mOutHeader[1] = 126 | kMaskBit;
70220:       ((PRUint16 *)mOutHeader)[1] =
70220:         PR_htons(mCurrentOut->Length());
70220:       mHdrOutToSend = 8;
73021:     } else {
70220:       mOutHeader[1] = 127 | kMaskBit;
70220:       PRUint64 tempLen = mCurrentOut->Length();
70220:       tempLen = PR_htonll(tempLen);
70220:       memcpy(mOutHeader + 2, &tempLen, 8);
70220:       mHdrOutToSend = 14;
70220:     }
70220:     payload = mOutHeader + mHdrOutToSend;
70220:   }
70220: 
70220:   NS_ABORT_IF_FALSE(payload, "payload offset not found");
70220: 
84709:   // Perform the sending mask. Never use a zero mask
70220:   PRUint32 mask;
71216:   do {
71216:     PRUint8 *buffer;
71216:     nsresult rv = mRandomGenerator->GenerateRandomBytes(4, &buffer);
71216:     if (NS_FAILED(rv)) {
73021:       LOG(("WebSocketChannel::PrimeNewOutgoingMessage(): "
71216:            "GenerateRandomBytes failure %x\n", rv));
71216:       StopSession(rv);
71216:       return;
71216:     }
71216:     mask = * reinterpret_cast<PRUint32 *>(buffer);
71216:     NS_Free(buffer);
71216:   } while (!mask);
70220:   *(((PRUint32 *)payload) - 1) = PR_htonl(mask);
70220: 
73021:   LOG(("WebSocketChannel::PrimeNewOutgoingMessage() using mask %08x\n", mask));
70220: 
70220:   // We don't mask the framing, but occasionally we stick a little payload
73021:   // data in the buffer used for the framing. Close frames are the current
73021:   // example. This data needs to be masked, but it is never more than a
73021:   // handful of bytes and might rotate the mask, so we can just do it locally.
73021:   // For real data frames we ship the bulk of the payload off to ApplyMask()
70220: 
70220:   while (payload < (mOutHeader + mHdrOutToSend)) {
70220:     *payload ^= mask >> 24;
70220:     mask = PR_ROTATE_LEFT32(mask, 8);
70220:     payload++;
70220:   }
70220: 
70220:   // Mask the real message payloads
70220: 
73021:   ApplyMask(mask, mCurrentOut->BeginWriting(), mCurrentOut->Length());
70220: 
70220:   // for small frames, copy it all together for a contiguous write
70220:   if (mCurrentOut->Length() <= kCopyBreak) {
73021:     memcpy(mOutHeader + mHdrOutToSend, mCurrentOut->BeginWriting(),
70220:            mCurrentOut->Length());
70220:     mHdrOutToSend += mCurrentOut->Length();
70220:     mCurrentOutSent = mCurrentOut->Length();
70220:   }
70220: 
70220:   if (mCompressor) {
70220:     // assume a 1/3 reduction in size for sizing the buffer
70220:     // the buffer is used multiple times if necessary
70220:     PRUint32 currentHeaderSize = mHdrOutToSend;
70220:     mHdrOutToSend = 0;
70220: 
70220:     EnsureHdrOut(32 +
73021:                  (currentHeaderSize + mCurrentOut->Length() - mCurrentOutSent)
73021:                  / 2 * 3);
73021:     mCompressor->Deflate(mOutHeader, currentHeaderSize,
70220:                          mCurrentOut->BeginReading() + mCurrentOutSent,
70220:                          mCurrentOut->Length() - mCurrentOutSent);
70220: 
73021:     // All of the compressed data now resides in {mHdrOut, mHdrOutToSend}
70220:     // so do not send the body again
70220:     mCurrentOutSent = mCurrentOut->Length();
70220:   }
70220: 
73021:   // Transmitting begins - mHdrOutToSend bytes from mOutHeader and
73021:   // mCurrentOut->Length() bytes from mCurrentOut. The latter may be
73021:   // coaleseced into the former for small messages or as the result of the
73021:   // compression process,
70220: }
70220: 
70220: void
73020: WebSocketChannel::EnsureHdrOut(PRUint32 size)
70220: {
73020:   LOG(("WebSocketChannel::EnsureHdrOut() %p [%d]\n", this, size));
70220: 
70220:   if (mDynamicOutputSize < size) {
70220:     mDynamicOutputSize = size;
70220:     mDynamicOutput =
70220:       (PRUint8 *) moz_xrealloc(mDynamicOutput, mDynamicOutputSize);
70220:   }
70220: 
70220:   mHdrOut = mDynamicOutput;
70220: }
70220: 
70220: void
73020: WebSocketChannel::CleanupConnection()
72181: {
73020:   LOG(("WebSocketChannel::CleanupConnection() %p", this));
72181: 
72181:   if (mLingeringCloseTimer) {
72181:     mLingeringCloseTimer->Cancel();
72181:     mLingeringCloseTimer = nsnull;
72181:   }
72181: 
72181:   if (mSocketIn) {
72181:     mSocketIn->AsyncWait(nsnull, 0, 0, nsnull);
72181:     mSocketIn = nsnull;
72181:   }
72181: 
72181:   if (mSocketOut) {
72181:     mSocketOut->AsyncWait(nsnull, 0, 0, nsnull);
72181:     mSocketOut = nsnull;
72181:   }
72181: 
72181:   if (mTransport) {
72181:     mTransport->SetSecurityCallbacks(nsnull);
72181:     mTransport->SetEventSink(nsnull, nsnull);
72181:     mTransport->Close(NS_BASE_STREAM_CLOSED);
72181:     mTransport = nsnull;
72181:   }
72181: }
72181: 
72181: void
73020: WebSocketChannel::StopSession(nsresult reason)
70220: {
73020:   LOG(("WebSocketChannel::StopSession() %p [%x]\n", this, reason));
70220: 
70220:   // normally this should be called on socket thread, but it is ok to call it
70220:   // from OnStartRequest before the socket thread machine has gotten underway
70220: 
73021:   NS_ABORT_IF_FALSE(mStopped,
73021:                     "stopsession() has not transitioned through abort or close");
70220: 
74993:   if (!mChannelWasOpened) {
74992:     // The HTTP channel information will never be used in this case
74992:     mChannel = nsnull;
74992:     mHttpChannel = nsnull;
74992:     mLoadGroup = nsnull;
74992:     mCallbacks = nsnull;
74992:   }
74992: 
74992:   if (mOpenRunning || mOpenBlocked)
74992:     sWebSocketAdmissions->Cancel(this);
74992: 
70220:   if (mCloseTimer) {
70220:     mCloseTimer->Cancel();
70220:     mCloseTimer = nsnull;
70220:   }
70220: 
70220:   if (mOpenTimer) {
70220:     mOpenTimer->Cancel();
70220:     mOpenTimer = nsnull;
70220:   }
70220: 
70220:   if (mPingTimer) {
70220:     mPingTimer->Cancel();
70220:     mPingTimer = nsnull;
70220:   }
70220: 
72181:   if (mSocketIn && !mTCPClosed) {
73021:     // Drain, within reason, this socket. if we leave any data
70220:     // unconsumed (including the tcp fin) a RST will be generated
70220:     // The right thing to do here is shutdown(SHUT_WR) and then wait
70220:     // a little while to see if any data comes in.. but there is no
70220:     // reason to delay things for that when the websocket handshake
70220:     // is supposed to guarantee a quiet connection except for that fin.
70220: 
70220:     char     buffer[512];
70220:     PRUint32 count = 0;
70220:     PRUint32 total = 0;
70220:     nsresult rv;
70220:     do {
70220:       total += count;
70220:       rv = mSocketIn->Read(buffer, 512, &count);
72181:       if (rv != NS_BASE_STREAM_WOULD_BLOCK &&
72181:         (NS_FAILED(rv) || count == 0))
80486:         mTCPClosed = true;
70220:     } while (NS_SUCCEEDED(rv) && count > 0 && total < 32000);
70220:   }
70220: 
72181:   if (!mTCPClosed && mTransport && sWebSocketAdmissions &&
86784:       sWebSocketAdmissions->SessionCount() < kLingeringCloseThreshold) {
72181: 
73021:     // 7.1.1 says that the client SHOULD wait for the server to close the TCP
73021:     // connection. This is so we can reuse port numbers before 2 MSL expires,
73021:     // which is not really as much of a concern for us as the amount of state
73021:     // that might be accrued by keeping this channel object around waiting for
73021:     // the server. We handle the SHOULD by waiting a short time in the common
73021:     // case, but not waiting in the case of high concurrency.
72181:     //
72181:     // Normally this will be taken care of in AbortSession() after mTCPClosed
72181:     // is set when the server close arrives without waiting for the timeout to
72181:     // expire.
72181: 
73021:     LOG(("WebSocketChannel::StopSession: Wait for Server TCP close"));
72181: 
72181:     nsresult rv;
72181:     mLingeringCloseTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
72181:     if (NS_SUCCEEDED(rv))
72181:       mLingeringCloseTimer->InitWithCallback(this, kLingeringCloseTimeout,
72181:                                              nsITimer::TYPE_ONE_SHOT);
72181:     else
72181:       CleanupConnection();
73021:   } else {
72181:     CleanupConnection();
70220:   }
70220: 
70220:   if (mDNSRequest) {
70220:     mDNSRequest->Cancel(NS_ERROR_UNEXPECTED);
70220:     mDNSRequest = nsnull;
70220:   }
70220: 
70220:   mInflateReader = nsnull;
70220:   mInflateStream = nsnull;
70220: 
70220:   delete mCompressor;
70220:   mCompressor = nsnull;
70220: 
70220:   if (!mCalledOnStop) {
70220:     mCalledOnStop = 1;
73021:     if (mListener)
80658:       NS_DispatchToMainThread(new CallOnStop(this, reason));
71740:   }
70220: 
70220:   return;
70220: }
70220: 
70220: void
73020: WebSocketChannel::AbortSession(nsresult reason)
70220: {
73020:   LOG(("WebSocketChannel::AbortSession() %p [reason %x] stopped = %d\n",
70220:        this, reason, mStopped));
70220: 
70220:   // normally this should be called on socket thread, but it is ok to call it
72502:   // from the main thread before StartWebsocketData() has completed
70220: 
72181:   // When we are failing we need to close the TCP connection immediately
72181:   // as per 7.1.1
80486:   mTCPClosed = true;
72181: 
72181:   if (mLingeringCloseTimer) {
72181:     NS_ABORT_IF_FALSE(mStopped, "Lingering without Stop");
73021:     LOG(("WebSocketChannel:: Cleanup connection based on TCP Close"));
72181:     CleanupConnection();
72181:     return;
72181:   }
72181: 
70220:   if (mStopped)
70220:     return;
70220:   mStopped = 1;
70220: 
70220:   if (mTransport && reason != NS_BASE_STREAM_CLOSED &&
70220:       !mRequestedClose && !mClientClosed && !mServerClosed) {
70220:     mRequestedClose = 1;
86783:     mStopOnClose = reason;
84709:     mSocketThread->Dispatch(
84709:       new OutboundEnqueuer(this, new OutboundMessage(kMsgTypeFin, nsnull)),
73021:                            nsIEventTarget::DISPATCH_NORMAL);
73021:   } else {
70220:     StopSession(reason);
70220:   }
70220: }
70220: 
70220: // ReleaseSession is called on orderly shutdown
70220: void
73020: WebSocketChannel::ReleaseSession()
70220: {
73020:   LOG(("WebSocketChannel::ReleaseSession() %p stopped = %d\n",
70220:        this, mStopped));
73021:   NS_ABORT_IF_FALSE(PR_GetCurrentThread() == gSocketThread, "not socket thread");
70220: 
70220:   if (mStopped)
70220:     return;
70220:   mStopped = 1;
70220:   StopSession(NS_OK);
70220: }
70220: 
70220: nsresult
73020: WebSocketChannel::HandleExtensions()
70220: {
73020:   LOG(("WebSocketChannel::HandleExtensions() %p\n", this));
70220: 
70220:   nsresult rv;
70220:   nsCAutoString extensions;
70220: 
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
70220: 
70220:   rv = mHttpChannel->GetResponseHeader(
70220:     NS_LITERAL_CSTRING("Sec-WebSocket-Extensions"), extensions);
70220:   if (NS_SUCCEEDED(rv)) {
70220:     if (!extensions.IsEmpty()) {
70220:       if (!extensions.Equals(NS_LITERAL_CSTRING("deflate-stream"))) {
73021:         LOG(("WebSocketChannel::OnStartRequest: "
73021:              "HTTP Sec-WebSocket-Exensions negotiated unknown value %s\n",
70220:              extensions.get()));
70220:         AbortSession(NS_ERROR_ILLEGAL_VALUE);
70220:         return NS_ERROR_ILLEGAL_VALUE;
70220:       }
70220: 
70220:       if (!mAllowCompression) {
73021:         LOG(("WebSocketChannel::HandleExtensions: "
70220:              "Recvd Compression Extension that wasn't offered\n"));
70220:         AbortSession(NS_ERROR_ILLEGAL_VALUE);
70220:         return NS_ERROR_ILLEGAL_VALUE;
70220:       }
70220: 
70220:       nsCOMPtr<nsIStreamConverterService> serv =
70220:         do_GetService(NS_STREAMCONVERTERSERVICE_CONTRACTID, &rv);
70220:       if (NS_FAILED(rv)) {
73020:         LOG(("WebSocketChannel:: Cannot find compression service\n"));
70220:         AbortSession(NS_ERROR_UNEXPECTED);
70220:         return NS_ERROR_UNEXPECTED;
70220:       }
70220: 
73021:       rv = serv->AsyncConvertData("deflate", "uncompressed", this, nsnull,
70220:                                   getter_AddRefs(mInflateReader));
70220: 
70220:       if (NS_FAILED(rv)) {
73020:         LOG(("WebSocketChannel:: Cannot find inflate listener\n"));
70220:         AbortSession(NS_ERROR_UNEXPECTED);
70220:         return NS_ERROR_UNEXPECTED;
70220:       }
70220: 
73021:       mInflateStream = do_CreateInstance(NS_STRINGINPUTSTREAM_CONTRACTID, &rv);
70220: 
70220:       if (NS_FAILED(rv)) {
73020:         LOG(("WebSocketChannel:: Cannot find inflate stream\n"));
70220:         AbortSession(NS_ERROR_UNEXPECTED);
70220:         return NS_ERROR_UNEXPECTED;
70220:       }
70220: 
70220:       mCompressor = new nsWSCompression(this, mSocketOut);
70220:       if (!mCompressor->Active()) {
73020:         LOG(("WebSocketChannel:: Cannot init deflate object\n"));
70220:         delete mCompressor;
70220:         mCompressor = nsnull;
70220:         AbortSession(NS_ERROR_UNEXPECTED);
70220:         return NS_ERROR_UNEXPECTED;
70220:       }
74838:       mNegotiatedExtensions = extensions;
70220:     }
70220:   }
70220: 
70220:   return NS_OK;
70220: }
70220: 
70220: nsresult
73020: WebSocketChannel::SetupRequest()
70220: {
73020:   LOG(("WebSocketChannel::SetupRequest() %p\n", this));
70220: 
70220:   nsresult rv;
70220: 
70220:   if (mLoadGroup) {
70220:     rv = mHttpChannel->SetLoadGroup(mLoadGroup);
70220:     NS_ENSURE_SUCCESS(rv, rv);
70220:   }
70220: 
70220:   rv = mHttpChannel->SetLoadFlags(nsIRequest::LOAD_BACKGROUND |
70220:                                   nsIRequest::INHIBIT_CACHING |
70220:                                   nsIRequest::LOAD_BYPASS_CACHE);
70220:   NS_ENSURE_SUCCESS(rv, rv);
70220: 
70220:   // draft-ietf-hybi-thewebsocketprotocol-07 illustrates Upgrade: websocket
73021:   // in lower case, so go with that. It is technically case insensitive.
70220:   rv = mChannel->HTTPUpgrade(NS_LITERAL_CSTRING("websocket"), this);
70220:   NS_ENSURE_SUCCESS(rv, rv);
70220: 
70220:   mHttpChannel->SetRequestHeader(
70220:     NS_LITERAL_CSTRING("Sec-WebSocket-Version"),
80486:     NS_LITERAL_CSTRING(SEC_WEBSOCKET_VERSION), false);
70220: 
70220:   if (!mOrigin.IsEmpty())
85007:     mHttpChannel->SetRequestHeader(NS_LITERAL_CSTRING("Origin"), mOrigin,
85007:                                    false);
70220: 
70220:   if (!mProtocol.IsEmpty())
73021:     mHttpChannel->SetRequestHeader(NS_LITERAL_CSTRING("Sec-WebSocket-Protocol"),
80486:                                    mProtocol, true);
70220: 
70220:   if (mAllowCompression)
73021:     mHttpChannel->SetRequestHeader(NS_LITERAL_CSTRING("Sec-WebSocket-Extensions"),
73021:                                    NS_LITERAL_CSTRING("deflate-stream"),
80486:                                    false);
70220: 
71216:   PRUint8      *secKey;
70220:   nsCAutoString secKeyString;
71216: 
71216:   rv = mRandomGenerator->GenerateRandomBytes(16, &secKey);
71216:   NS_ENSURE_SUCCESS(rv, rv);
70220:   char* b64 = PL_Base64Encode((const char *)secKey, 16, nsnull);
71216:   NS_Free(secKey);
73021:   if (!b64)
73021:     return NS_ERROR_OUT_OF_MEMORY;
70220:   secKeyString.Assign(b64);
70220:   PR_Free(b64);
73021:   mHttpChannel->SetRequestHeader(NS_LITERAL_CSTRING("Sec-WebSocket-Key"),
80486:                                  secKeyString, false);
74745:   LOG(("WebSocketChannel::SetupRequest: client key %s\n", secKeyString.get()));
70220: 
70220:   // prepare the value we expect to see in
70220:   // the sec-websocket-accept response header
70220:   secKeyString.AppendLiteral("258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
70220:   nsCOMPtr<nsICryptoHash> hasher =
70220:     do_CreateInstance(NS_CRYPTO_HASH_CONTRACTID, &rv);
70220:   NS_ENSURE_SUCCESS(rv, rv);
70220:   rv = hasher->Init(nsICryptoHash::SHA1);
70220:   NS_ENSURE_SUCCESS(rv, rv);
70220:   rv = hasher->Update((const PRUint8 *) secKeyString.BeginWriting(),
70220:                       secKeyString.Length());
70220:   NS_ENSURE_SUCCESS(rv, rv);
80486:   rv = hasher->Finish(true, mHashedSecret);
70220:   NS_ENSURE_SUCCESS(rv, rv);
74745:   LOG(("WebSocketChannel::SetupRequest: expected server key %s\n",
70220:        mHashedSecret.get()));
70220: 
70220:   return NS_OK;
70220: }
70220: 
70220: nsresult
73020: WebSocketChannel::ApplyForAdmission()
70220: {
73020:   LOG(("WebSocketChannel::ApplyForAdmission() %p\n", this));
70220: 
70220:   // Websockets has a policy of 1 session at a time being allowed in the
70220:   // CONNECTING state per server IP address (not hostname)
70220: 
70220:   nsresult rv;
70220:   nsCOMPtr<nsIDNSService> dns = do_GetService(NS_DNSSERVICE_CONTRACTID, &rv);
70220:   NS_ENSURE_SUCCESS(rv, rv);
70220: 
70220:   nsCString hostName;
70220:   rv = mURI->GetHost(hostName);
70220:   NS_ENSURE_SUCCESS(rv, rv);
70220:   mAddress = hostName;
70220: 
70220:   // expect the callback in ::OnLookupComplete
74745:   LOG(("WebSocketChannel::ApplyForAdmission: checking for concurrent open\n"));
70220:   nsCOMPtr<nsIThread> mainThread;
70220:   NS_GetMainThread(getter_AddRefs(mainThread));
73021:   dns->AsyncResolve(hostName, 0, this, mainThread, getter_AddRefs(mDNSRequest));
70220:   NS_ENSURE_SUCCESS(rv, rv);
70220: 
70220:   return NS_OK;
70220: }
70220: 
72502: // Called after both OnStartRequest and OnTransportAvailable have
72502: // executed. This essentially ends the handshake and starts the websockets
72502: // protocol state machine.
72502: nsresult
73020: WebSocketChannel::StartWebsocketData()
72502: {
73020:   LOG(("WebSocketChannel::StartWebsocketData() %p", this));
72502: 
72502:   return mSocketIn->AsyncWait(this, 0, 0, mSocketThread);
72502: }
72502: 
70220: // nsIDNSListener
70220: 
70220: NS_IMETHODIMP
73020: WebSocketChannel::OnLookupComplete(nsICancelable *aRequest,
70220:                                      nsIDNSRecord *aRecord,
70220:                                      nsresult aStatus)
70220: {
73020:   LOG(("WebSocketChannel::OnLookupComplete() %p [%p %p %x]\n",
70220:        this, aRequest, aRecord, aStatus));
70220: 
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
74992:   NS_ABORT_IF_FALSE(aRequest == mDNSRequest || mStopped,
74992:                     "wrong dns request");
74992: 
86784:   if (mStopped) {
86784:     LOG(("WebSocketChannel::OnLookupComplete: Request Already Stopped\n"));
74992:     return NS_OK;
86784:   }
70220: 
70220:   mDNSRequest = nsnull;
70220: 
70220:   // These failures are not fatal - we just use the hostname as the key
70220:   if (NS_FAILED(aStatus)) {
73021:     LOG(("WebSocketChannel::OnLookupComplete: No DNS Response\n"));
73021:   } else {
70220:     nsresult rv = aRecord->GetNextAddrAsString(mAddress);
70220:     if (NS_FAILED(rv))
73021:       LOG(("WebSocketChannel::OnLookupComplete: Failed GetNextAddr\n"));
70220:   }
70220: 
70220:   if (sWebSocketAdmissions->ConditionallyConnect(mAddress, this)) {
73021:     LOG(("WebSocketChannel::OnLookupComplete: Proceeding with Open\n"));
73021:   } else {
73021:     LOG(("WebSocketChannel::OnLookupComplete: Deferring Open\n"));
70220:   }
70220: 
70220:   return NS_OK;
70220: }
70220: 
70220: // nsIInterfaceRequestor
70220: 
70220: NS_IMETHODIMP
73020: WebSocketChannel::GetInterface(const nsIID & iid, void **result NS_OUTPARAM)
70220: {
73020:   LOG(("WebSocketChannel::GetInterface() %p\n", this));
70220: 
70220:   if (iid.Equals(NS_GET_IID(nsIChannelEventSink)))
70220:     return QueryInterface(iid, result);
70220: 
70220:   if (mCallbacks)
70220:     return mCallbacks->GetInterface(iid, result);
70220: 
70220:   return NS_ERROR_FAILURE;
70220: }
70220: 
70220: // nsIChannelEventSink
70220: 
70220: NS_IMETHODIMP
73020: WebSocketChannel::AsyncOnChannelRedirect(
70220:                     nsIChannel *oldChannel,
70220:                     nsIChannel *newChannel,
70220:                     PRUint32 flags,
70220:                     nsIAsyncVerifyRedirectCallback *callback)
70220: {
73020:   LOG(("WebSocketChannel::AsyncOnChannelRedirect() %p\n", this));
70220:   nsresult rv;
70220: 
70220:   nsCOMPtr<nsIURI> newuri;
70220:   rv = newChannel->GetURI(getter_AddRefs(newuri));
70220:   NS_ENSURE_SUCCESS(rv, rv);
70220: 
84711:   // newuri is expected to be http or https
84711:   bool newuriIsHttps = false;
84711:   rv = newuri->SchemeIs("https", &newuriIsHttps);
84711:   NS_ENSURE_SUCCESS(rv, rv);
84711: 
70220:   if (!mAutoFollowRedirects) {
84711:     // Even if redirects configured off, still allow them for HTTP Strict
84711:     // Transport Security (from ws://FOO to https://FOO (mapped to wss://FOO)
84711: 
84711:     nsCOMPtr<nsIURI> clonedNewURI;
84711:     rv = newuri->Clone(getter_AddRefs(clonedNewURI));
84711:     NS_ENSURE_SUCCESS(rv, rv);
84711: 
84711:     rv = clonedNewURI->SetScheme(NS_LITERAL_CSTRING("ws"));
84711:     NS_ENSURE_SUCCESS(rv, rv);
84711: 
84711:     nsCOMPtr<nsIURI> currentURI;
84711:     rv = GetURI(getter_AddRefs(currentURI));
84711:     NS_ENSURE_SUCCESS(rv, rv);
84711: 
84711:     // currentURI is expected to be ws or wss
84711:     bool currentIsHttps = false;
84711:     rv = currentURI->SchemeIs("wss", &currentIsHttps);
84711:     NS_ENSURE_SUCCESS(rv, rv);
84711: 
84711:     bool uriEqual = false;
84711:     rv = clonedNewURI->Equals(currentURI, &uriEqual);
84711:     NS_ENSURE_SUCCESS(rv, rv);
84711: 
84711:     // It's only a HSTS redirect if we started with non-secure, are going to
84711:     // secure, and the new URI is otherwise the same as the old one.
84711:     if (!(!currentIsHttps && newuriIsHttps && uriEqual)) {
84711:       nsCAutoString newSpec;
84711:       rv = newuri->GetSpec(newSpec);
84711:       NS_ENSURE_SUCCESS(rv, rv);
84711: 
73021:       LOG(("WebSocketChannel: Redirect to %s denied by configuration\n",
84711:            newSpec.get()));
84711:       return NS_ERROR_FAILURE;
70220:     }
84711:   }
84711: 
84711:   if (mEncrypted && !newuriIsHttps) {
70220:     nsCAutoString spec;
70220:     if (NS_SUCCEEDED(newuri->GetSpec(spec)))
73021:       LOG(("WebSocketChannel: Redirect to %s violates encryption rule\n",
70220:            spec.get()));
84711:     return NS_ERROR_FAILURE;
70220:   }
70220: 
73021:   nsCOMPtr<nsIHttpChannel> newHttpChannel = do_QueryInterface(newChannel, &rv);
70220:   if (NS_FAILED(rv)) {
73021:     LOG(("WebSocketChannel: Redirect could not QI to HTTP\n"));
84711:     return rv;
70220:   }
70220: 
70220:   nsCOMPtr<nsIHttpChannelInternal> newUpgradeChannel =
70220:     do_QueryInterface(newChannel, &rv);
70220: 
70220:   if (NS_FAILED(rv)) {
73021:     LOG(("WebSocketChannel: Redirect could not QI to HTTP Upgrade\n"));
84711:     return rv;
70220:   }
70220: 
71217:   // The redirect is likely OK
70220: 
70220:   newChannel->SetNotificationCallbacks(this);
84711: 
84711:   mEncrypted = newuriIsHttps;
84711:   newuri->Clone(getter_AddRefs(mURI));
84711:   if (mEncrypted)
84711:     rv = mURI->SetScheme(NS_LITERAL_CSTRING("wss"));
84711:   else
84711:     rv = mURI->SetScheme(NS_LITERAL_CSTRING("ws"));
84711: 
70220:   mHttpChannel = newHttpChannel;
70220:   mChannel = newUpgradeChannel;
71217:   rv = SetupRequest();
71217:   if (NS_FAILED(rv)) {
73021:     LOG(("WebSocketChannel: Redirect could not SetupRequest()\n"));
84711:     return rv;
71217:   }
70220: 
73021:   // We cannot just tell the callback OK right now due to the 1 connect at a
73021:   // time policy. First we need to complete the old location and then start the
73021:   // lookup chain for the new location - once that is complete and we have been
73021:   // admitted, OnRedirectVerifyCallback(NS_OK) will be called out of BeginOpen()
70220: 
74992:   sWebSocketAdmissions->Complete(this);
70220:   mAddress.Truncate();
70220:   mRedirectCallback = callback;
70220: 
74993:   mChannelWasOpened = 0;
74992: 
70220:   rv = ApplyForAdmission();
70220:   if (NS_FAILED(rv)) {
73021:     LOG(("WebSocketChannel: Redirect failed due to DNS failure\n"));
70220:     mRedirectCallback = nsnull;
84711:     return rv;
70220:   }
70220: 
70220:   return NS_OK;
70220: }
70220: 
70220: // nsITimerCallback
70220: 
70220: NS_IMETHODIMP
73020: WebSocketChannel::Notify(nsITimer *timer)
70220: {
73020:   LOG(("WebSocketChannel::Notify() %p [%p]\n", this, timer));
70220: 
70220:   if (timer == mCloseTimer) {
70220:     NS_ABORT_IF_FALSE(mClientClosed, "Close Timeout without local close");
70220:     NS_ABORT_IF_FALSE(PR_GetCurrentThread() == gSocketThread,
70220:                       "not socket thread");
70220: 
70220:     mCloseTimer = nsnull;
70220:     if (mStopped || mServerClosed)                /* no longer relevant */
70220:       return NS_OK;
70220: 
73020:     LOG(("WebSocketChannel:: Expecting Server Close - Timed Out\n"));
70220:     AbortSession(NS_ERROR_NET_TIMEOUT);
73021:   } else if (timer == mOpenTimer) {
70220:     NS_ABORT_IF_FALSE(!mRecvdHttpOnStartRequest,
70220:                       "Open Timer after open complete");
70220:     NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
70220: 
70220:     mOpenTimer = nsnull;
73020:     LOG(("WebSocketChannel:: Connection Timed Out\n"));
70220:     if (mStopped || mServerClosed)                /* no longer relevant */
70220:       return NS_OK;
70220: 
70220:     AbortSession(NS_ERROR_NET_TIMEOUT);
73021:   } else if (timer == mPingTimer) {
70220:     NS_ABORT_IF_FALSE(PR_GetCurrentThread() == gSocketThread,
70220:                       "not socket thread");
70220: 
70220:     if (mClientClosed || mServerClosed || mRequestedClose) {
70220:       // no point in worrying about ping now
70220:       mPingTimer = nsnull;
70220:       return NS_OK;
70220:     }
70220: 
70220:     if (!mPingOutstanding) {
73021:       LOG(("nsWebSocketChannel:: Generating Ping\n"));
70220:       mPingOutstanding = 1;
70220:       GeneratePing();
70220:       mPingTimer->InitWithCallback(this, mPingResponseTimeout,
70220:                                    nsITimer::TYPE_ONE_SHOT);
73021:     } else {
73021:       LOG(("nsWebSocketChannel:: Timed out Ping\n"));
70220:       mPingTimer = nsnull;
70220:       AbortSession(NS_ERROR_NET_TIMEOUT);
70220:     }
73021:   } else if (timer == mLingeringCloseTimer) {
73020:     LOG(("WebSocketChannel:: Lingering Close Timer"));
72181:     CleanupConnection();
73021:   } else {
70220:     NS_ABORT_IF_FALSE(0, "Unknown Timer");
70220:   }
70220: 
70220:   return NS_OK;
70220: }
70220: 
70220: 
70220: NS_IMETHODIMP
73020: WebSocketChannel::GetSecurityInfo(nsISupports **aSecurityInfo)
70220: {
73020:   LOG(("WebSocketChannel::GetSecurityInfo() %p\n", this));
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
70220: 
70220:   if (mTransport) {
70220:     if (NS_FAILED(mTransport->GetSecurityInfo(aSecurityInfo)))
70220:       *aSecurityInfo = nsnull;
70220:   }
70220:   return NS_OK;
70220: }
70220: 
70220: 
70220: NS_IMETHODIMP
73020: WebSocketChannel::AsyncOpen(nsIURI *aURI,
70220:                             const nsACString &aOrigin,
70220:                             nsIWebSocketListener *aListener,
70220:                             nsISupports *aContext)
70220: {
73020:   LOG(("WebSocketChannel::AsyncOpen() %p\n", this));
70220: 
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
70220: 
70220:   if (!aURI || !aListener) {
73020:     LOG(("WebSocketChannel::AsyncOpen() Uri or Listener null"));
70220:     return NS_ERROR_UNEXPECTED;
70220:   }
70220: 
70220:   if (mListener)
70220:     return NS_ERROR_ALREADY_OPENED;
70220: 
70220:   nsresult rv;
70220: 
70220:   mSocketThread = do_GetService(NS_SOCKETTRANSPORTSERVICE_CONTRACTID, &rv);
70220:   if (NS_FAILED(rv)) {
70220:     NS_WARNING("unable to continue without socket transport service");
70220:     return rv;
70220:   }
70220: 
73021:   mRandomGenerator =
73021:     do_GetService("@mozilla.org/security/random-generator;1", &rv);
71216:   if (NS_FAILED(rv)) {
71216:     NS_WARNING("unable to continue without random number generator");
71216:     return rv;
71216:   }
71216: 
70220:   nsCOMPtr<nsIPrefBranch> prefService;
70220:   prefService = do_GetService(NS_PREFSERVICE_CONTRACTID);
70220: 
70220:   if (prefService) {
70220:     PRInt32 intpref;
79445:     bool boolpref;
73021:     rv = prefService->GetIntPref("network.websocket.max-message-size", 
73021:                                  &intpref);
70220:     if (NS_SUCCEEDED(rv)) {
85010:       mMaxMessageSize = clamped(intpref, 1024, PR_INT32_MAX);
70220:     }
73021:     rv = prefService->GetIntPref("network.websocket.timeout.close", &intpref);
70220:     if (NS_SUCCEEDED(rv)) {
81029:       mCloseTimeout = clamped(intpref, 1, 1800) * 1000;
70220:     }
73021:     rv = prefService->GetIntPref("network.websocket.timeout.open", &intpref);
70220:     if (NS_SUCCEEDED(rv)) {
81029:       mOpenTimeout = clamped(intpref, 1, 1800) * 1000;
70220:     }
73021:     rv = prefService->GetIntPref("network.websocket.timeout.ping.request",
73021:                                  &intpref);
70220:     if (NS_SUCCEEDED(rv)) {
81029:       mPingTimeout = clamped(intpref, 0, 86400) * 1000;
70220:     }
73021:     rv = prefService->GetIntPref("network.websocket.timeout.ping.response",
73021:                                  &intpref);
70220:     if (NS_SUCCEEDED(rv)) {
81029:       mPingResponseTimeout = clamped(intpref, 1, 3600) * 1000;
70220:     }
73021:     rv = prefService->GetBoolPref("network.websocket.extensions.stream-deflate",
73021:                                   &boolpref);
70220:     if (NS_SUCCEEDED(rv)) {
70220:       mAllowCompression = boolpref ? 1 : 0;
70220:     }
73021:     rv = prefService->GetBoolPref("network.websocket.auto-follow-http-redirects",
73021:                                   &boolpref);
70220:     if (NS_SUCCEEDED(rv)) {
70220:       mAutoFollowRedirects = boolpref ? 1 : 0;
70220:     }
72502:     rv = prefService->GetIntPref
72502:       ("network.websocket.max-connections", &intpref);
72502:     if (NS_SUCCEEDED(rv)) {
81029:       mMaxConcurrentConnections = clamped(intpref, 1, 0xffff);
72502:     }
72502:   }
72502: 
86784:   if (sWebSocketAdmissions)
86784:     LOG(("WebSocketChannel::AsyncOpen %p sessionCount=%d max=%d\n", this,
86784:          sWebSocketAdmissions->SessionCount(), mMaxConcurrentConnections));
86784: 
72502:   if (sWebSocketAdmissions &&
86784:       sWebSocketAdmissions->SessionCount() >= mMaxConcurrentConnections)
73021:   {
86784:     LOG(("WebSocketChannel: max concurrency %d exceeded (%d)",
86784:          mMaxConcurrentConnections,
86784:          sWebSocketAdmissions->SessionCount()));
72502: 
72502:     // WebSocket connections are expected to be long lived, so return
72502:     // an error here instead of queueing
72502:     return NS_ERROR_SOCKET_CREATE_FAILED;
70220:   }
70220: 
70220:   if (mPingTimeout) {
70220:     mPingTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
70220:     if (NS_FAILED(rv)) {
70220:       NS_WARNING("unable to create ping timer. Carrying on.");
73021:     } else {
73021:       LOG(("WebSocketChannel will generate ping after %d ms of receive silence\n",
73021:            mPingTimeout));
70220:       mPingTimer->SetTarget(mSocketThread);
73021:       mPingTimer->InitWithCallback(this, mPingTimeout, nsITimer::TYPE_ONE_SHOT);
70220:     }
70220:   }
70220: 
70220:   mOriginalURI = aURI;
70220:   mURI = mOriginalURI;
70220:   mListener = aListener;
70220:   mContext = aContext;
70220:   mOrigin = aOrigin;
70220: 
70220:   nsCOMPtr<nsIURI> localURI;
70220:   nsCOMPtr<nsIChannel> localChannel;
70220: 
70220:   mURI->Clone(getter_AddRefs(localURI));
70220:   if (mEncrypted)
70220:     rv = localURI->SetScheme(NS_LITERAL_CSTRING("https"));
70220:   else
70220:     rv = localURI->SetScheme(NS_LITERAL_CSTRING("http"));
70220:   NS_ENSURE_SUCCESS(rv, rv);
70220: 
70220:   nsCOMPtr<nsIIOService> ioService;
70220:   ioService = do_GetService(NS_IOSERVICE_CONTRACTID, &rv);
70220:   if (NS_FAILED(rv)) {
70220:     NS_WARNING("unable to continue without io service");
70220:     return rv;
70220:   }
70220: 
70220:   nsCOMPtr<nsIIOService2> io2 = do_QueryInterface(ioService, &rv);
70220:   if (NS_FAILED(rv)) {
73021:     NS_WARNING("WebSocketChannel: unable to continue without ioservice2");
70220:     return rv;
70220:   }
70220: 
70220:   rv = io2->NewChannelFromURIWithProxyFlags(
70220:               localURI,
70220:               mURI,
70220:               nsIProtocolProxyService::RESOLVE_PREFER_SOCKS_PROXY |
70220:               nsIProtocolProxyService::RESOLVE_PREFER_HTTPS_PROXY |
70220:               nsIProtocolProxyService::RESOLVE_ALWAYS_TUNNEL,
70220:               getter_AddRefs(localChannel));
70220:   NS_ENSURE_SUCCESS(rv, rv);
70220: 
73021:   // Pass most GetInterface() requests through to our instantiator, but handle
70220:   // nsIChannelEventSink in this object in order to deal with redirects
70220:   localChannel->SetNotificationCallbacks(this);
70220: 
70220:   mChannel = do_QueryInterface(localChannel, &rv);
70220:   NS_ENSURE_SUCCESS(rv, rv);
70220: 
70220:   mHttpChannel = do_QueryInterface(localChannel, &rv);
70220:   NS_ENSURE_SUCCESS(rv, rv);
70220: 
70220:   rv = SetupRequest();
70220:   if (NS_FAILED(rv))
70220:     return rv;
70220: 
70220:   return ApplyForAdmission();
70220: }
70220: 
70220: NS_IMETHODIMP
74812: WebSocketChannel::Close(PRUint16 code, const nsACString & reason)
70220: {
73020:   LOG(("WebSocketChannel::Close() %p\n", this));
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
74745: 
74745:   if (!mTransport) {
74745:     LOG(("WebSocketChannel::Close() without transport - aborting."));
74745:     AbortSession(NS_ERROR_NOT_CONNECTED);
74745:     return NS_ERROR_NOT_CONNECTED;
74745:   }
74745: 
70220:   if (mRequestedClose) {
73020:     LOG(("WebSocketChannel:: Double close error\n"));
70220:     return NS_ERROR_UNEXPECTED;
70220:   }
70220: 
74812:   // The API requires the UTF-8 string to be 123 or less bytes
74812:   if (reason.Length() > 123)
74812:     return NS_ERROR_ILLEGAL_VALUE;
74812: 
70220:   mRequestedClose = 1;
74812:   mScriptCloseReason = reason;
74812:   mScriptCloseCode = code;
70220: 
84709:   return mSocketThread->Dispatch(
84709:       new OutboundEnqueuer(this, new OutboundMessage(kMsgTypeFin, nsnull)),
73021:                            nsIEventTarget::DISPATCH_NORMAL);
70220: }
70220: 
70220: NS_IMETHODIMP
73020: WebSocketChannel::SendMsg(const nsACString &aMsg)
70220: {
73020:   LOG(("WebSocketChannel::SendMsg() %p\n", this));
84709: 
84709:   return SendMsgCommon(&aMsg, false, aMsg.Length());
70220: }
70220: 
70220: NS_IMETHODIMP
73020: WebSocketChannel::SendBinaryMsg(const nsACString &aMsg)
70220: {
73020:   LOG(("WebSocketChannel::SendBinaryMsg() %p len=%d\n", this, aMsg.Length()));
84709:   return SendMsgCommon(&aMsg, true, aMsg.Length());
84709: }
84709: 
84709: NS_IMETHODIMP
84709: WebSocketChannel::SendBinaryStream(nsIInputStream *aStream, PRUint32 aLength)
84709: {
84709:   LOG(("WebSocketChannel::SendBinaryStream() %p\n", this));
84709: 
84709:   return SendMsgCommon(nsnull, true, aLength, aStream);
84709: }
84709: 
84709: nsresult
84709: WebSocketChannel::SendMsgCommon(const nsACString *aMsg, bool aIsBinary,
84709:                                 PRUint32 aLength, nsIInputStream *aStream)
84709: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
70220: 
70220:   if (mRequestedClose) {
84709:     LOG(("WebSocketChannel:: Error: send when closed\n"));
70220:     return NS_ERROR_UNEXPECTED;
70220:   }
70220: 
70220:   if (mStopped) {
84709:     LOG(("WebSocketChannel:: Error: send when stopped\n"));
70220:     return NS_ERROR_NOT_CONNECTED;
70220:   }
70220: 
86641:   NS_ABORT_IF_FALSE(mMaxMessageSize >= 0, "max message size negative");
86641:   if (aLength > static_cast<PRUint32>(mMaxMessageSize)) {
85011:     LOG(("WebSocketChannel:: Error: message too big\n"));
85011:     return NS_ERROR_FILE_TOO_BIG;
85011:   }
85011: 
84709:   return mSocketThread->Dispatch(
84709:     aStream ? new OutboundEnqueuer(this, new OutboundMessage(aStream, aLength))
84709:             : new OutboundEnqueuer(this,
84709:                      new OutboundMessage(aIsBinary ? kMsgTypeBinaryString
84709:                                                    : kMsgTypeString,
84709:                                          new nsCString(*aMsg))),
73021:     nsIEventTarget::DISPATCH_NORMAL);
70220: }
70220: 
70220: NS_IMETHODIMP
73020: WebSocketChannel::OnTransportAvailable(nsISocketTransport *aTransport,
70220:                                        nsIAsyncInputStream *aSocketIn,
70220:                                        nsIAsyncOutputStream *aSocketOut)
70220: {
73021:   LOG(("WebSocketChannel::OnTransportAvailable %p [%p %p %p] rcvdonstart=%d\n",
70220:        this, aTransport, aSocketIn, aSocketOut, mRecvdHttpOnStartRequest));
70220: 
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
70220:   NS_ABORT_IF_FALSE(!mRecvdHttpUpgradeTransport, "OTA duplicated");
72181:   NS_ABORT_IF_FALSE(aSocketIn, "OTA with invalid socketIn");
70220: 
70220:   mTransport = aTransport;
70220:   mSocketIn = aSocketIn;
70220:   mSocketOut = aSocketOut;
70220: 
70220:   nsresult rv;
70220:   rv = mTransport->SetEventSink(nsnull, nsnull);
70220:   if (NS_FAILED(rv)) return rv;
80658:   rv = mTransport->SetSecurityCallbacks(this);
70220:   if (NS_FAILED(rv)) return rv;
70220: 
70220:   mRecvdHttpUpgradeTransport = 1;
70220:   if (mRecvdHttpOnStartRequest)
72502:     return StartWebsocketData();
70220:   return NS_OK;
70220: }
70220: 
70220: // nsIRequestObserver (from nsIStreamListener)
70220: 
70220: NS_IMETHODIMP
73020: WebSocketChannel::OnStartRequest(nsIRequest *aRequest,
70220:                                  nsISupports *aContext)
70220: {
73021:   LOG(("WebSocketChannel::OnStartRequest(): %p [%p %p] recvdhttpupgrade=%d\n",
70220:        this, aRequest, aContext, mRecvdHttpUpgradeTransport));
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
70220:   NS_ABORT_IF_FALSE(!mRecvdHttpOnStartRequest, "OTA duplicated");
70220: 
70220:   // Generating the onStart event will take us out of the
70220:   // CONNECTING state which means we can now open another,
70220:   // perhaps parallel, connection to the same host if one
70220:   // is pending
70220: 
74992:   if (sWebSocketAdmissions->Complete(this))
73021:     LOG(("WebSocketChannel::OnStartRequest: Starting Pending Open\n"));
70220:   else
73021:     LOG(("WebSocketChannel::OnStartRequest: No More Pending Opens\n"));
70220: 
70220:   if (mOpenTimer) {
70220:     mOpenTimer->Cancel();
70220:     mOpenTimer = nsnull;
70220:   }
70220: 
70220:   if (mStopped) {
73021:     LOG(("WebSocketChannel::OnStartRequest: Channel Already Done\n"));
70220:     AbortSession(NS_ERROR_CONNECTION_REFUSED);
70220:     return NS_ERROR_CONNECTION_REFUSED;
70220:   }
70220: 
70220:   nsresult rv;
70220:   PRUint32 status;
70220:   char *val, *token;
70220: 
70220:   rv = mHttpChannel->GetResponseStatus(&status);
70220:   if (NS_FAILED(rv)) {
73021:     LOG(("WebSocketChannel::OnStartRequest: No HTTP Response\n"));
70220:     AbortSession(NS_ERROR_CONNECTION_REFUSED);
70220:     return NS_ERROR_CONNECTION_REFUSED;
70220:   }
70220: 
73021:   LOG(("WebSocketChannel::OnStartRequest: HTTP status %d\n", status));
70220:   if (status != 101) {
70220:     AbortSession(NS_ERROR_CONNECTION_REFUSED);
70220:     return NS_ERROR_CONNECTION_REFUSED;
70220:   }
70220: 
70220:   nsCAutoString respUpgrade;
70220:   rv = mHttpChannel->GetResponseHeader(
70220:     NS_LITERAL_CSTRING("Upgrade"), respUpgrade);
70220: 
70220:   if (NS_SUCCEEDED(rv)) {
70220:     rv = NS_ERROR_ILLEGAL_VALUE;
70220:     if (!respUpgrade.IsEmpty()) {
70220:       val = respUpgrade.BeginWriting();
70220:       while ((token = nsCRT::strtok(val, ", \t", &val))) {
70220:         if (PL_strcasecmp(token, "Websocket") == 0) {
70220:           rv = NS_OK;
70220:           break;
70220:         }
70220:       }
70220:     }
70220:   }
70220: 
70220:   if (NS_FAILED(rv)) {
73021:     LOG(("WebSocketChannel::OnStartRequest: "
70220:          "HTTP response header Upgrade: websocket not found\n"));
70220:     AbortSession(rv);
70220:     return rv;
70220:   }
70220: 
70220:   nsCAutoString respConnection;
70220:   rv = mHttpChannel->GetResponseHeader(
70220:     NS_LITERAL_CSTRING("Connection"), respConnection);
70220: 
70220:   if (NS_SUCCEEDED(rv)) {
70220:     rv = NS_ERROR_ILLEGAL_VALUE;
70220:     if (!respConnection.IsEmpty()) {
70220:       val = respConnection.BeginWriting();
70220:       while ((token = nsCRT::strtok(val, ", \t", &val))) {
70220:         if (PL_strcasecmp(token, "Upgrade") == 0) {
70220:           rv = NS_OK;
70220:           break;
70220:         }
70220:       }
70220:     }
70220:   }
70220: 
70220:   if (NS_FAILED(rv)) {
73021:     LOG(("WebSocketChannel::OnStartRequest: "
73021:          "HTTP response header 'Connection: Upgrade' not found\n"));
70220:     AbortSession(rv);
70220:     return rv;
70220:   }
70220: 
70220:   nsCAutoString respAccept;
70220:   rv = mHttpChannel->GetResponseHeader(
73021:                        NS_LITERAL_CSTRING("Sec-WebSocket-Accept"),
73021:                        respAccept);
70220: 
70220:   if (NS_FAILED(rv) ||
70220:     respAccept.IsEmpty() || !respAccept.Equals(mHashedSecret)) {
73021:     LOG(("WebSocketChannel::OnStartRequest: "
70220:          "HTTP response header Sec-WebSocket-Accept check failed\n"));
73021:     LOG(("WebSocketChannel::OnStartRequest: Expected %s recevied %s\n",
70220:          mHashedSecret.get(), respAccept.get()));
70220:     AbortSession(NS_ERROR_ILLEGAL_VALUE);
70220:     return NS_ERROR_ILLEGAL_VALUE;
70220:   }
70220: 
70220:   // If we sent a sub protocol header, verify the response matches
70220:   // If it does not, set mProtocol to "" so the protocol attribute
70220:   // of the WebSocket JS object reflects that
70220:   if (!mProtocol.IsEmpty()) {
70220:     nsCAutoString respProtocol;
70220:     rv = mHttpChannel->GetResponseHeader(
73021:                          NS_LITERAL_CSTRING("Sec-WebSocket-Protocol"), 
73021:                          respProtocol);
70220:     if (NS_SUCCEEDED(rv)) {
70220:       rv = NS_ERROR_ILLEGAL_VALUE;
70220:       val = mProtocol.BeginWriting();
70220:       while ((token = nsCRT::strtok(val, ", \t", &val))) {
70220:         if (PL_strcasecmp(token, respProtocol.get()) == 0) {
70220:           rv = NS_OK;
70220:           break;
70220:         }
70220:       }
70220: 
70220:       if (NS_SUCCEEDED(rv)) {
73021:         LOG(("WebsocketChannel::OnStartRequest: subprotocol %s confirmed",
73021:              respProtocol.get()));
70220:         mProtocol = respProtocol;
73021:       } else {
73021:         LOG(("WebsocketChannel::OnStartRequest: "
70220:              "subprotocol [%s] not found - %s returned",
70220:              mProtocol.get(), respProtocol.get()));
70220:         mProtocol.Truncate();
70220:       }
73021:     } else {
73020:       LOG(("WebsocketChannel::OnStartRequest "
70220:                  "subprotocol [%s] not found - none returned",
70220:                  mProtocol.get()));
70220:       mProtocol.Truncate();
70220:     }
70220:   }
70220: 
70220:   rv = HandleExtensions();
70220:   if (NS_FAILED(rv))
70220:     return rv;
70220: 
73021:   LOG(("WebSocketChannel::OnStartRequest: Notifying Listener %p\n",
70220:        mListener.get()));
70220: 
70220:   if (mListener)
70220:     mListener->OnStart(mContext);
70220: 
70220:   mRecvdHttpOnStartRequest = 1;
70220:   if (mRecvdHttpUpgradeTransport)
72502:     return StartWebsocketData();
70220: 
70220:   return NS_OK;
70220: }
70220: 
70220: NS_IMETHODIMP
73020: WebSocketChannel::OnStopRequest(nsIRequest *aRequest,
70220:                                   nsISupports *aContext,
70220:                                   nsresult aStatusCode)
70220: {
73020:   LOG(("WebSocketChannel::OnStopRequest() %p [%p %p %x]\n",
70220:        this, aRequest, aContext, aStatusCode));
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
70220: 
73021:   // This is the end of the HTTP upgrade transaction, the
70220:   // upgraded streams live on
70220: 
70220:   mChannel = nsnull;
70220:   mHttpChannel = nsnull;
70220:   mLoadGroup = nsnull;
70220:   mCallbacks = nsnull;
70220: 
70220:   return NS_OK;
70220: }
70220: 
70220: // nsIInputStreamCallback
70220: 
70220: NS_IMETHODIMP
73020: WebSocketChannel::OnInputStreamReady(nsIAsyncInputStream *aStream)
70220: {
73020:   LOG(("WebSocketChannel::OnInputStreamReady() %p\n", this));
73021:   NS_ABORT_IF_FALSE(PR_GetCurrentThread() == gSocketThread, "not socket thread");
70220: 
77269:   if (!mSocketIn) // did we we clean up the socket after scheduling InputReady?
77269:     return NS_OK;
77269:   
70220:   nsRefPtr<nsIStreamListener>    deleteProtector1(mInflateReader);
70220:   nsRefPtr<nsIStringInputStream> deleteProtector2(mInflateStream);
70220: 
70220:   // this is after the  http upgrade - so we are speaking websockets
70220:   char  buffer[2048];
70220:   PRUint32 count;
70220:   nsresult rv;
70220: 
70220:   do {
70220:     rv = mSocketIn->Read((char *)buffer, 2048, &count);
73021:     LOG(("WebSocketChannel::OnInputStreamReady: read %u rv %x\n", count, rv));
70220: 
70220:     if (rv == NS_BASE_STREAM_WOULD_BLOCK) {
70220:       mSocketIn->AsyncWait(this, 0, 0, mSocketThread);
70220:       return NS_OK;
70220:     }
70220: 
70220:     if (NS_FAILED(rv)) {
80486:       mTCPClosed = true;
70220:       AbortSession(rv);
70220:       return rv;
70220:     }
70220: 
70220:     if (count == 0) {
80486:       mTCPClosed = true;
70220:       AbortSession(NS_BASE_STREAM_CLOSED);
70220:       return NS_OK;
70220:     }
70220: 
72181:     if (mStopped) {
72181:       NS_ABORT_IF_FALSE(mLingeringCloseTimer,
72181:                         "OnInputReady after stop without linger");
72181:       continue;
72181:     }
72181: 
70220:     if (mInflateReader) {
70220:       mInflateStream->ShareData(buffer, count);
73021:       rv = mInflateReader->OnDataAvailable(nsnull, mSocketIn, mInflateStream, 
73021:                                            0, count);
73021:     } else {
70220:       rv = ProcessInput((PRUint8 *)buffer, count);
70220:     }
70220: 
70220:     if (NS_FAILED(rv)) {
70220:       AbortSession(rv);
70220:       return rv;
70220:     }
70220:   } while (NS_SUCCEEDED(rv) && mSocketIn);
70220: 
70220:   return NS_OK;
70220: }
70220: 
70220: 
70220: // nsIOutputStreamCallback
70220: 
70220: NS_IMETHODIMP
73020: WebSocketChannel::OnOutputStreamReady(nsIAsyncOutputStream *aStream)
70220: {
73020:   LOG(("WebSocketChannel::OnOutputStreamReady() %p\n", this));
73021:   NS_ABORT_IF_FALSE(PR_GetCurrentThread() == gSocketThread, "not socket thread");
70220:   nsresult rv;
70220: 
70220:   if (!mCurrentOut)
70220:     PrimeNewOutgoingMessage();
70220: 
70220:   while (mCurrentOut && mSocketOut) {
70220:     const char *sndBuf;
70220:     PRUint32 toSend;
70220:     PRUint32 amtSent;
70220: 
70220:     if (mHdrOut) {
70220:       sndBuf = (const char *)mHdrOut;
70220:       toSend = mHdrOutToSend;
73021:       LOG(("WebSocketChannel::OnOutputStreamReady: "
73021:            "Try to send %u of hdr/copybreak\n", toSend));
73021:     } else {
70220:       sndBuf = (char *) mCurrentOut->BeginReading() + mCurrentOutSent;
70220:       toSend = mCurrentOut->Length() - mCurrentOutSent;
70220:       if (toSend > 0) {
73021:         LOG(("WebSocketChannel::OnOutputStreamReady: "
73021:              "Try to send %u of data\n", toSend));
70220:       }
70220:     }
70220: 
70220:     if (toSend == 0) {
70220:       amtSent = 0;
73021:     } else {
70220:       rv = mSocketOut->Write(sndBuf, toSend, &amtSent);
73021:       LOG(("WebSocketChannel::OnOutputStreamReady: write %u rv %x\n",
70220:            amtSent, rv));
70220: 
70220:       if (rv == NS_BASE_STREAM_WOULD_BLOCK) {
70220:         mSocketOut->AsyncWait(this, 0, 0, nsnull);
70220:         return NS_OK;
70220:       }
70220: 
70220:       if (NS_FAILED(rv)) {
70220:         AbortSession(rv);
70220:         return NS_OK;
70220:       }
70220:     }
70220: 
70220:     if (mHdrOut) {
70220:       if (amtSent == toSend) {
70220:         mHdrOut = nsnull;
70220:         mHdrOutToSend = 0;
73021:       } else {
70220:         mHdrOut += amtSent;
70220:         mHdrOutToSend -= amtSent;
70220:       }
73021:     } else {
70220:       if (amtSent == toSend) {
70220:         if (!mStopped) {
80658:           NS_DispatchToMainThread(new CallAcknowledge(this,
73021:                                                       mCurrentOut->Length()));
70220:         }
70220:         delete mCurrentOut;
70220:         mCurrentOut = nsnull;
70220:         mCurrentOutSent = 0;
70220:         PrimeNewOutgoingMessage();
73021:       } else {
70220:         mCurrentOutSent += amtSent;
70220:       }
70220:     }
70220:   }
70220: 
70220:   if (mReleaseOnTransmit)
70220:     ReleaseSession();
70220:   return NS_OK;
70220: }
70220: 
70220: // nsIStreamListener
70220: 
70220: NS_IMETHODIMP
73020: WebSocketChannel::OnDataAvailable(nsIRequest *aRequest,
70220:                                     nsISupports *aContext,
70220:                                     nsIInputStream *aInputStream,
70220:                                     PRUint32 aOffset,
70220:                                     PRUint32 aCount)
70220: {
73020:   LOG(("WebSocketChannel::OnDataAvailable() %p [%p %p %p %u %u]\n",
70220:          this, aRequest, aContext, aInputStream, aOffset, aCount));
70220: 
70220:   if (aContext == mSocketIn) {
70220:     // This is the deflate decoder
70220: 
73021:     LOG(("WebSocketChannel::OnDataAvailable: Deflate Data %u\n",
70220:              aCount));
70220: 
70220:     PRUint8  buffer[2048];
70220:     PRUint32 maxRead;
70220:     PRUint32 count;
70220:     nsresult rv;
70220: 
70220:     while (aCount > 0) {
70220:       if (mStopped)
70220:         return NS_BASE_STREAM_CLOSED;
70220: 
70220:       maxRead = NS_MIN(2048U, aCount);
70220:       rv = aInputStream->Read((char *)buffer, maxRead, &count);
73021:       LOG(("WebSocketChannel::OnDataAvailable: InflateRead read %u rv %x\n",
70220:            count, rv));
70220:       if (NS_FAILED(rv) || count == 0) {
70220:         AbortSession(rv);
70220:         break;
70220:       }
70220: 
70220:       aCount -= count;
70220:       rv = ProcessInput(buffer, count);
70220:     }
70220:     return NS_OK;
70220:   }
70220: 
70220:   if (aContext == mSocketOut) {
70220:     // This is the deflate encoder
70220: 
70220:     PRUint32 maxRead;
70220:     PRUint32 count;
70220:     nsresult rv;
70220: 
70220:     while (aCount > 0) {
70220:       if (mStopped)
70220:         return NS_BASE_STREAM_CLOSED;
70220: 
70220:       maxRead = NS_MIN(2048U, aCount);
70220:       EnsureHdrOut(mHdrOutToSend + aCount);
73021:       rv = aInputStream->Read((char *)mHdrOut + mHdrOutToSend, maxRead, &count);
73021:       LOG(("WebSocketChannel::OnDataAvailable: DeflateWrite read %u rv %x\n", 
73021:            count, rv));
70220:       if (NS_FAILED(rv) || count == 0) {
70220:         AbortSession(rv);
70220:         break;
70220:       }
70220: 
70220:       mHdrOutToSend += count;
70220:       aCount -= count;
70220:     }
70220:     return NS_OK;
70220:   }
70220: 
70220: 
70220:   // Otherwise, this is the HTTP OnDataAvailable Method, which means
70220:   // this is http data in response to the upgrade request and
70220:   // there should be no http response body if the upgrade succeeded
70220: 
70220:   // This generally should be caught by a non 101 response code in
70220:   // OnStartRequest().. so we can ignore the data here
70220: 
73021:   LOG(("WebSocketChannel::OnDataAvailable: HTTP data unexpected len>=%u\n",
70220:          aCount));
70220: 
70220:   return NS_OK;
70220: }
70220: 
70220: } // namespace mozilla::net
70220: } // namespace mozilla
